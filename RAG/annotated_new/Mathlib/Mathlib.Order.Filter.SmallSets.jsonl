{"name":"Filter.smallSets_eq_generate","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\n‚ä¢ Eq f.smallSets (Filter.generate (Set.image Set.powerset f.sets))","decl":"theorem smallSets_eq_generate {f : Filter Œ±} : f.smallSets = generate (powerset '' f.sets) := by\n  simp_rw [generate_eq_biInf, smallSets, iInf_image, Filter.lift', Filter.lift, Function.comp_apply,\n    Filter.mem_sets]\n\n-- TODO: get more properties from the adjunction?\n-- TODO: is there a general way to get a lower adjoint for the lift of an upper adjoint?\n"}
{"name":"Filter.bind_smallSets_gc","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\n‚ä¢ GaloisConnection (fun L => L.bind Filter.principal) Filter.smallSets","decl":"theorem bind_smallSets_gc :\n    GaloisConnection (fun L : Filter (Set Œ±) ‚Ü¶ L.bind principal) smallSets := by\n  intro L l\n  simp_rw [smallSets_eq_generate, le_generate_iff, image_subset_iff]\n  rfl\n\n"}
{"name":"Filter.HasBasis.smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nŒπ : Sort u_3\nl : Filter Œ±\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Œ±\nh : l.HasBasis p s\n‚ä¢ l.smallSets.HasBasis p fun i => (s i).powerset","decl":"protected theorem HasBasis.smallSets {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} (h : HasBasis l p s) :\n    HasBasis l.smallSets p fun i => ùí´ s i :=\n  h.lift' monotone_powerset\n\n"}
{"name":"Filter.hasBasis_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\n‚ä¢ l.smallSets.HasBasis (fun t => Membership.mem l t) Set.powerset","decl":"theorem hasBasis_smallSets (l : Filter Œ±) :\n    HasBasis l.smallSets (fun t : Set Œ± => t ‚àà l) powerset :=\n  l.basis_sets.smallSets\n\n"}
{"name":"Filter.Eventually.exists_mem_basis_of_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nŒπ : Sort u_3\nl : Filter Œ±\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Œ±\nP : Set Œ± ‚Üí Prop\nh‚ÇÅ : Filter.Eventually (fun t => P t) l.smallSets\nh‚ÇÇ : l.HasBasis p s\n‚ä¢ Exists fun i => And (p i) (P (s i))","decl":"theorem Eventually.exists_mem_basis_of_smallSets {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} {P : Set Œ± ‚Üí Prop}\n    (h‚ÇÅ : ‚àÄ·∂† t in l.smallSets, P t) (h‚ÇÇ : HasBasis l p s) : ‚àÉ i, p i ‚àß P (s i) :=\n  (h‚ÇÇ.smallSets.eventually_iff.mp h‚ÇÅ).imp fun _i ‚ü®hpi, hi‚ü© ‚Ü¶ ‚ü®hpi, hi Subset.rfl‚ü©\n\n"}
{"name":"Filter.Frequently.smallSets_of_forall_mem_basis","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nŒπ : Sort u_3\nl : Filter Œ±\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Œ±\nP : Set Œ± ‚Üí Prop\nh‚ÇÅ : ‚àÄ (i : Œπ), p i ‚Üí P (s i)\nh‚ÇÇ : l.HasBasis p s\n‚ä¢ Filter.Frequently (fun t => P t) l.smallSets","decl":"theorem Frequently.smallSets_of_forall_mem_basis {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} {P : Set Œ± ‚Üí Prop}\n    (h‚ÇÅ : ‚àÄ i, p i ‚Üí P (s i)) (h‚ÇÇ : HasBasis l p s) : ‚àÉ·∂† t in l.smallSets, P t :=\n  h‚ÇÇ.smallSets.frequently_iff.mpr fun _ hi => ‚ü®_, Subset.rfl, h‚ÇÅ _ hi‚ü©\n\n"}
{"name":"Filter.Eventually.exists_mem_of_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\np : Set Œ± ‚Üí Prop\nh : Filter.Eventually (fun t => p t) l.smallSets\n‚ä¢ Exists fun s => And (Membership.mem l s) (p s)","decl":"theorem Eventually.exists_mem_of_smallSets {p : Set Œ± ‚Üí Prop}\n    (h : ‚àÄ·∂† t in l.smallSets, p t) : ‚àÉ s ‚àà l, p s :=\n  h.exists_mem_basis_of_smallSets l.basis_sets\n\n"}
{"name":"Filter.tendsto_smallSets_iff","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nla : Filter Œ±\nlb : Filter Œ≤\nf : Œ± ‚Üí Set Œ≤\n‚ä¢ Iff (Filter.Tendsto f la lb.smallSets) (‚àÄ (t : Set Œ≤), Membership.mem lb t ‚Üí Filter.Eventually (fun x => HasSubset.Subset (f x) t) la)","decl":"/-- `g` converges to `f.smallSets` if for all `s ‚àà f`, eventually we have `g x ‚äÜ s`. -/\ntheorem tendsto_smallSets_iff {f : Œ± ‚Üí Set Œ≤} :\n    Tendsto f la lb.smallSets ‚Üî ‚àÄ t ‚àà lb, ‚àÄ·∂† x in la, f x ‚äÜ t :=\n  (hasBasis_smallSets lb).tendsto_right_iff\n\n"}
{"name":"Filter.eventually_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\np : Set Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun s => p s) l.smallSets) (Exists fun s => And (Membership.mem l s) (‚àÄ (t : Set Œ±), HasSubset.Subset t s ‚Üí p t))","decl":"theorem eventually_smallSets {p : Set Œ± ‚Üí Prop} :\n    (‚àÄ·∂† s in l.smallSets, p s) ‚Üî ‚àÉ s ‚àà l, ‚àÄ t, t ‚äÜ s ‚Üí p t :=\n  eventually_lift'_iff monotone_powerset\n\n"}
{"name":"Filter.eventually_smallSets'","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\np : Set Œ± ‚Üí Prop\nhp : ‚àÄ ‚¶És t : Set Œ±‚¶Ñ, HasSubset.Subset s t ‚Üí p t ‚Üí p s\n‚ä¢ Iff (Filter.Eventually (fun s => p s) l.smallSets) (Exists fun s => And (Membership.mem l s) (p s))","decl":"theorem eventually_smallSets' {p : Set Œ± ‚Üí Prop} (hp : ‚àÄ ‚¶És t‚¶Ñ, s ‚äÜ t ‚Üí p t ‚Üí p s) :\n    (‚àÄ·∂† s in l.smallSets, p s) ‚Üî ‚àÉ s ‚àà l, p s :=\n  eventually_smallSets.trans <|\n    exists_congr fun s => Iff.rfl.and ‚ü®fun H => H s Subset.rfl, fun hs _t ht => hp ht hs‚ü©\n\n"}
{"name":"Filter.frequently_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\np : Set Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Frequently (fun s => p s) l.smallSets) (‚àÄ (t : Set Œ±), Membership.mem l t ‚Üí Exists fun s => And (HasSubset.Subset s t) (p s))","decl":"theorem frequently_smallSets {p : Set Œ± ‚Üí Prop} :\n    (‚àÉ·∂† s in l.smallSets, p s) ‚Üî ‚àÄ t ‚àà l, ‚àÉ s, s ‚äÜ t ‚àß p s :=\n  l.hasBasis_smallSets.frequently_iff\n\n"}
{"name":"Filter.frequently_smallSets_mem","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\n‚ä¢ Filter.Frequently (fun s => Membership.mem l s) l.smallSets","decl":"theorem frequently_smallSets_mem (l : Filter Œ±) : ‚àÉ·∂† s in l.smallSets, s ‚àà l :=\n  frequently_smallSets.2 fun t ht => ‚ü®t, Subset.rfl, ht‚ü©\n\n"}
{"name":"Filter.tendsto_image_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nla : Filter Œ±\nlb : Filter Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (Filter.Tendsto (fun x => Set.image f x) la.smallSets lb.smallSets) (Filter.Tendsto f la lb)","decl":"@[simp]\nlemma tendsto_image_smallSets {f : Œ± ‚Üí Œ≤} :\n    Tendsto (f '' ¬∑) la.smallSets lb.smallSets ‚Üî Tendsto f la lb := by\n  rw [tendsto_smallSets_iff]\n  refine forall‚ÇÇ_congr fun u hu ‚Ü¶ ?_\n  rw [eventually_smallSets' fun s t hst ht ‚Ü¶ (image_subset _ hst).trans ht]\n  simp only [image_subset_iff, exists_mem_subset_iff, mem_map]\n\n"}
{"name":"Filter.Tendsto.image_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nla : Filter Œ±\nlb : Filter Œ≤\nf : Œ± ‚Üí Œ≤\na‚úù : Filter.Tendsto f la lb\n‚ä¢ Filter.Tendsto (fun x => Set.image f x) la.smallSets lb.smallSets","decl":"alias ‚ü®_, Tendsto.image_smallSets‚ü© := tendsto_image_smallSets\n\n"}
{"name":"Filter.HasAntitoneBasis.tendsto_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nŒπ : Type u_4\ninst‚úù : Preorder Œπ\ns : Œπ ‚Üí Set Œ±\nhl : l.HasAntitoneBasis s\n‚ä¢ Filter.Tendsto s Filter.atTop l.smallSets","decl":"theorem HasAntitoneBasis.tendsto_smallSets {Œπ} [Preorder Œπ] {s : Œπ ‚Üí Set Œ±}\n    (hl : l.HasAntitoneBasis s) : Tendsto s atTop l.smallSets :=\n  tendsto_smallSets_iff.2 fun _t ht => hl.eventually_subset ht\n\n"}
{"name":"Filter.monotone_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\n‚ä¢ Monotone Filter.smallSets","decl":"@[mono]\ntheorem monotone_smallSets : Monotone (@smallSets Œ±) :=\n  monotone_lift' monotone_id monotone_const\n\n"}
{"name":"Filter.smallSets_bot","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\n‚ä¢ Eq Bot.bot.smallSets (Pure.pure EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem smallSets_bot : (‚ä• : Filter Œ±).smallSets = pure ‚àÖ := by\n  rw [smallSets, lift'_bot, powerset_empty, principal_singleton]\n  exact monotone_powerset\n\n"}
{"name":"Filter.smallSets_top","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\n‚ä¢ Eq Top.top.smallSets Top.top","decl":"@[simp]\ntheorem smallSets_top : (‚ä§ : Filter Œ±).smallSets = ‚ä§ := by\n  rw [smallSets, lift'_top, powerset_univ, principal_univ]\n\n"}
{"name":"Filter.smallSets_principal","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\ns : Set Œ±\n‚ä¢ Eq (Filter.principal s).smallSets (Filter.principal s.powerset)","decl":"@[simp]\ntheorem smallSets_principal (s : Set Œ±) : (ùìü s).smallSets = ùìü (ùí´ s) :=\n  lift'_principal monotone_powerset\n\n"}
{"name":"Filter.smallSets_comap_eq_comap_image","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nl : Filter Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Eq (Filter.comap f l).smallSets (Filter.comap (Set.image f) l.smallSets)","decl":"theorem smallSets_comap_eq_comap_image (l : Filter Œ≤) (f : Œ± ‚Üí Œ≤) :\n    (comap f l).smallSets = comap (image f) l.smallSets := by\n  refine (gc_map_comap _).u_comm_of_l_comm (gc_map_comap _) bind_smallSets_gc bind_smallSets_gc ?_\n  simp [Function.comp_def, map_bind, bind_map]\n\n"}
{"name":"Filter.smallSets_comap","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nl : Filter Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Eq (Filter.comap f l).smallSets (l.lift' (Function.comp Set.powerset (Set.preimage f)))","decl":"theorem smallSets_comap (l : Filter Œ≤) (f : Œ± ‚Üí Œ≤) :\n    (comap f l).smallSets = l.lift' (powerset ‚àò preimage f) :=\n  comap_lift'_eq2 monotone_powerset\n\n"}
{"name":"Filter.comap_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nl : Filter Œ≤\nf : Œ± ‚Üí Set Œ≤\n‚ä¢ Eq (Filter.comap f l.smallSets) (l.lift' (Function.comp (Set.preimage f) Set.powerset))","decl":"theorem comap_smallSets (l : Filter Œ≤) (f : Œ± ‚Üí Set Œ≤) :\n    comap f l.smallSets = l.lift' (preimage f ‚àò powerset) :=\n  comap_lift'_eq\n\n"}
{"name":"Filter.smallSets_iInf","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nŒπ : Sort u_3\nf : Œπ ‚Üí Filter Œ±\n‚ä¢ Eq (iInf f).smallSets (iInf fun i => (f i).smallSets)","decl":"theorem smallSets_iInf {f : Œπ ‚Üí Filter Œ±} : (iInf f).smallSets = ‚®Ö i, (f i).smallSets :=\n  lift'_iInf_of_map_univ (powerset_inter _ _) powerset_univ\n\n"}
{"name":"Filter.smallSets_inf","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl‚ÇÅ l‚ÇÇ : Filter Œ±\n‚ä¢ Eq (Min.min l‚ÇÅ l‚ÇÇ).smallSets (Min.min l‚ÇÅ.smallSets l‚ÇÇ.smallSets)","decl":"theorem smallSets_inf (l‚ÇÅ l‚ÇÇ : Filter Œ±) : (l‚ÇÅ ‚äì l‚ÇÇ).smallSets = l‚ÇÅ.smallSets ‚äì l‚ÇÇ.smallSets :=\n  lift'_inf _ _ powerset_inter\n\n"}
{"name":"Filter.smallSets_neBot","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\n‚ä¢ l.smallSets.NeBot","decl":"instance smallSets_neBot (l : Filter Œ±) : NeBot l.smallSets := by\n  refine (lift'_neBot_iff ?_).2 fun _ _ => powerset_nonempty\n  exact monotone_powerset\n\n"}
{"name":"Filter.Tendsto.smallSets_mono","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nla : Filter Œ±\nlb : Filter Œ≤\ns t : Œ± ‚Üí Set Œ≤\nht : Filter.Tendsto t la lb.smallSets\nhst : Filter.Eventually (fun x => HasSubset.Subset (s x) (t x)) la\n‚ä¢ Filter.Tendsto s la lb.smallSets","decl":"theorem Tendsto.smallSets_mono {s t : Œ± ‚Üí Set Œ≤} (ht : Tendsto t la lb.smallSets)\n    (hst : ‚àÄ·∂† x in la, s x ‚äÜ t x) : Tendsto s la lb.smallSets := by\n  rw [tendsto_smallSets_iff] at ht ‚ä¢\n  exact fun u hu => (ht u hu).mp (hst.mono fun _ hst ht => hst.trans ht)\n\n"}
{"name":"Filter.Tendsto.of_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nla : Filter Œ±\nlb : Filter Œ≤\ns : Œ± ‚Üí Set Œ≤\nf : Œ± ‚Üí Œ≤\nhs : Filter.Tendsto s la lb.smallSets\nhf : Filter.Eventually (fun x => Membership.mem (s x) (f x)) la\n‚ä¢ Filter.Tendsto f la lb","decl":"/-- Generalized **squeeze theorem** (also known as **sandwich theorem**). If `s : Œ± ‚Üí Set Œ≤` is a\nfamily of sets that tends to `Filter.smallSets lb` along `la` and `f : Œ± ‚Üí Œ≤` is a function such\nthat `f x ‚àà s x` eventually along `la`, then `f` tends to `lb` along `la`.\n\nIf `s x` is the closed interval `[g x, h x]` for some functions `g`, `h` that tend to the same limit\n`ùìù y`, then we obtain the standard squeeze theorem, see\n`tendsto_of_tendsto_of_tendsto_of_le_of_le'`. -/\ntheorem Tendsto.of_smallSets {s : Œ± ‚Üí Set Œ≤} {f : Œ± ‚Üí Œ≤} (hs : Tendsto s la lb.smallSets)\n    (hf : ‚àÄ·∂† x in la, f x ‚àà s x) : Tendsto f la lb := fun t ht =>\n  hf.mp <| (tendsto_smallSets_iff.mp hs t ht).mono fun _ h‚ÇÅ h‚ÇÇ => h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"Filter.eventually_smallSets_eventually","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl l' : Filter Œ±\np : Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun s => Filter.Eventually (fun x => Membership.mem s x ‚Üí p x) l') l.smallSets) (Filter.Eventually (fun x => p x) (Min.min l l'))","decl":"@[simp]\ntheorem eventually_smallSets_eventually {p : Œ± ‚Üí Prop} :\n    (‚àÄ·∂† s in l.smallSets, ‚àÄ·∂† x in l', x ‚àà s ‚Üí p x) ‚Üî ‚àÄ·∂† x in l ‚äì l', p x :=\n  calc\n    _ ‚Üî ‚àÉ s ‚àà l, ‚àÄ·∂† x in l', x ‚àà s ‚Üí p x :=\n      eventually_smallSets' fun _ _ hst ht => ht.mono fun _ hx hs => hx (hst hs)\n    _ ‚Üî ‚àÉ s ‚àà l, ‚àÉ t ‚àà l', ‚àÄ x, x ‚àà t ‚Üí x ‚àà s ‚Üí p x := by simp only [eventually_iff_exists_mem]\n    _ ‚Üî ‚àÄ·∂† x in l ‚äì l', p x := by simp only [eventually_inf, and_comm, mem_inter_iff, ‚Üê and_imp]\n\n"}
{"name":"Filter.eventually_smallSets_forall","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\np : Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun s => ‚àÄ (x : Œ±), Membership.mem s x ‚Üí p x) l.smallSets) (Filter.Eventually (fun x => p x) l)","decl":"@[simp]\ntheorem eventually_smallSets_forall {p : Œ± ‚Üí Prop} :\n    (‚àÄ·∂† s in l.smallSets, ‚àÄ x ‚àà s, p x) ‚Üî ‚àÄ·∂† x in l, p x := by\n  simpa only [inf_top_eq, eventually_top] using @eventually_smallSets_eventually Œ± l ‚ä§ p\n\n"}
{"name":"Filter.Eventually.smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\np : Œ± ‚Üí Prop\na‚úù : Filter.Eventually (fun x => p x) l\n‚ä¢ Filter.Eventually (fun s => ‚àÄ (x : Œ±), Membership.mem s x ‚Üí p x) l.smallSets","decl":"alias ‚ü®Eventually.of_smallSets, Eventually.smallSets‚ü© := eventually_smallSets_forall\n\n"}
{"name":"Filter.Eventually.of_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\np : Œ± ‚Üí Prop\na‚úù : Filter.Eventually (fun s => ‚àÄ (x : Œ±), Membership.mem s x ‚Üí p x) l.smallSets\n‚ä¢ Filter.Eventually (fun x => p x) l","decl":"alias ‚ü®Eventually.of_smallSets, Eventually.smallSets‚ü© := eventually_smallSets_forall\n\n"}
{"name":"Filter.eventually_smallSets_subset","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\ns : Set Œ±\n‚ä¢ Iff (Filter.Eventually (fun t => HasSubset.Subset t s) l.smallSets) (Membership.mem l s)","decl":"@[simp]\ntheorem eventually_smallSets_subset {s : Set Œ±} : (‚àÄ·∂† t in l.smallSets, t ‚äÜ s) ‚Üî s ‚àà l :=\n  eventually_smallSets_forall\n\n"}
