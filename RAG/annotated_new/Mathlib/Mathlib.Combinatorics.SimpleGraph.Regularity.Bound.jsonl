{"name":"SzemerediRegularity.le_stepBound","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"⊢ LE.le id SzemerediRegularity.stepBound","decl":"theorem le_stepBound : id ≤ stepBound := fun n =>\n  Nat.le_mul_of_pos_right _ <| pow_pos (by norm_num) n\n\n"}
{"name":"SzemerediRegularity.stepBound_mono","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"⊢ Monotone SzemerediRegularity.stepBound","decl":"theorem stepBound_mono : Monotone stepBound := fun _ _ h =>\n  Nat.mul_le_mul h <| Nat.pow_le_pow_of_le_right (by norm_num) h\n\n"}
{"name":"SzemerediRegularity.stepBound_pos_iff","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"n : Nat\n⊢ Iff (LT.lt 0 (SzemerediRegularity.stepBound n)) (LT.lt 0 n)","decl":"theorem stepBound_pos_iff {n : ℕ} : 0 < stepBound n ↔ 0 < n :=\n  mul_pos_iff_of_pos_right <| by positivity\n\n"}
{"name":"SzemerediRegularity.stepBound_pos","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"n : Nat\na✝ : LT.lt 0 n\n⊢ LT.lt 0 (SzemerediRegularity.stepBound n)","decl":"alias ⟨_, stepBound_pos⟩ := stepBound_pos_iff\n\n"}
{"name":"SzemerediRegularity.coe_stepBound","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"α : Type u_1\ninst✝ : Semiring α\nn : Nat\n⊢ Eq (↑(SzemerediRegularity.stepBound n)) (HMul.hMul (↑n) (HPow.hPow 4 n))","decl":"@[norm_cast] lemma coe_stepBound {α : Type*} [Semiring α] (n : ℕ) :\n    (stepBound n : α) = n * 4 ^ n := by unfold stepBound; norm_cast\n\n"}
{"name":"SzemerediRegularity.m_pos","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nP : Finpartition Finset.univ\ninst✝ : Nonempty α\nhPα : LE.le (HMul.hMul P.parts.card (HPow.hPow 16 P.parts.card)) (Fintype.card α)\n⊢ LT.lt 0 (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card))","decl":"theorem m_pos [Nonempty α] (hPα : #P.parts * 16 ^ #P.parts ≤ card α) : 0 < m := by\n  sz_positivity\n\n"}
{"name":"SzemerediRegularity.coe_m_add_one_pos","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nP : Finpartition Finset.univ\n⊢ LT.lt 0 (HAdd.hAdd (↑(HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card))) 1)","decl":"theorem coe_m_add_one_pos : 0 < (m : ℝ) + 1 := by positivity\n\n"}
{"name":"SzemerediRegularity.one_le_m_coe","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nP : Finpartition Finset.univ\ninst✝ : Nonempty α\nhPα : LE.le (HMul.hMul P.parts.card (HPow.hPow 16 P.parts.card)) (Fintype.card α)\n⊢ LE.le 1 ↑(HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card))","decl":"theorem one_le_m_coe [Nonempty α] (hPα : #P.parts * 16 ^ #P.parts ≤ card α) : (1 : ℝ) ≤ m :=\n  Nat.one_le_cast.2 <| m_pos hPα\n\n"}
{"name":"SzemerediRegularity.eps_pow_five_pos","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nP : Finpartition Finset.univ\nε : Real\nhPε : LE.le 100 (HMul.hMul (HPow.hPow 4 P.parts.card) (HPow.hPow ε 5))\n⊢ LT.lt 0 (HPow.hPow ε 5)","decl":"theorem eps_pow_five_pos (hPε : 100 ≤ (4 : ℝ) ^ #P.parts * ε ^ 5) : ↑0 < ε ^ 5 :=\n  pos_of_mul_pos_right ((by norm_num : (0 : ℝ) < 100).trans_le hPε) <| pow_nonneg (by norm_num) _\n\n"}
{"name":"SzemerediRegularity.eps_pos","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nP : Finpartition Finset.univ\nε : Real\nhPε : LE.le 100 (HMul.hMul (HPow.hPow 4 P.parts.card) (HPow.hPow ε 5))\n⊢ LT.lt 0 ε","decl":"theorem eps_pos (hPε : 100 ≤ (4 : ℝ) ^ #P.parts * ε ^ 5) : 0 < ε :=\n  (Odd.pow_pos_iff (by decide)).mp (eps_pow_five_pos hPε)\n\n"}
{"name":"SzemerediRegularity.hundred_div_ε_pow_five_le_m","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nP : Finpartition Finset.univ\nε : Real\ninst✝ : Nonempty α\nhPα : LE.le (HMul.hMul P.parts.card (HPow.hPow 16 P.parts.card)) (Fintype.card α)\nhPε : LE.le 100 (HMul.hMul (HPow.hPow 4 P.parts.card) (HPow.hPow ε 5))\n⊢ LE.le (HDiv.hDiv 100 (HPow.hPow ε 5)) ↑(HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card))","decl":"theorem hundred_div_ε_pow_five_le_m [Nonempty α] (hPα : #P.parts * 16 ^ #P.parts ≤ card α)\n    (hPε : 100 ≤ (4 : ℝ) ^ #P.parts * ε ^ 5) : 100 / ε ^ 5 ≤ m :=\n  (div_le_of_le_mul₀ (eps_pow_five_pos hPε).le (by positivity) hPε).trans <| by\n    norm_cast\n    rwa [Nat.le_div_iff_mul_le (stepBound_pos (P.parts_nonempty <|\n      univ_nonempty.ne_empty).card_pos), stepBound, mul_left_comm, ← mul_pow]\n\n"}
{"name":"SzemerediRegularity.hundred_le_m","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nP : Finpartition Finset.univ\nε : Real\ninst✝ : Nonempty α\nhPα : LE.le (HMul.hMul P.parts.card (HPow.hPow 16 P.parts.card)) (Fintype.card α)\nhPε : LE.le 100 (HMul.hMul (HPow.hPow 4 P.parts.card) (HPow.hPow ε 5))\nhε : LE.le ε 1\n⊢ LE.le 100 (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card))","decl":"theorem hundred_le_m [Nonempty α] (hPα : #P.parts * 16 ^ #P.parts ≤ card α)\n    (hPε : 100 ≤ (4 : ℝ) ^ #P.parts * ε ^ 5) (hε : ε ≤ 1) : 100 ≤ m :=\n  mod_cast\n    (hundred_div_ε_pow_five_le_m hPα hPε).trans'\n      (le_div_self (by norm_num) (by sz_positivity) <| pow_le_one₀ (by sz_positivity) hε)\n\n"}
{"name":"SzemerediRegularity.a_add_one_le_four_pow_parts_card","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nP : Finpartition Finset.univ\n⊢ LE.le (HAdd.hAdd (HSub.hSub (HDiv.hDiv (Fintype.card α) P.parts.card) (HMul.hMul (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card)) (HPow.hPow 4 P.parts.card))) 1) (HPow.hPow 4 P.parts.card)","decl":"theorem a_add_one_le_four_pow_parts_card : a + 1 ≤ 4 ^ #P.parts := by\n  have h : 1 ≤ 4 ^ #P.parts := one_le_pow₀ (by norm_num)\n  rw [stepBound, ← Nat.div_div_eq_div_mul]\n  conv_rhs => rw [← Nat.sub_add_cancel h]\n  rw [add_le_add_iff_right, tsub_le_iff_left, ← Nat.add_sub_assoc h]\n  exact Nat.le_sub_one_of_lt (Nat.lt_div_mul_add h)\n\n"}
{"name":"SzemerediRegularity.card_aux₁","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nP : Finpartition Finset.univ\nu : Finset α\nhucard : Eq u.card (HAdd.hAdd (HMul.hMul (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card)) (HPow.hPow 4 P.parts.card)) (HSub.hSub (HDiv.hDiv (Fintype.card α) P.parts.card) (HMul.hMul (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card)) (HPow.hPow 4 P.parts.card))))\n⊢ Eq (HAdd.hAdd (HMul.hMul (HSub.hSub (HPow.hPow 4 P.parts.card) (HSub.hSub (HDiv.hDiv (Fintype.card α) P.parts.card) (HMul.hMul (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card)) (HPow.hPow 4 P.parts.card)))) (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card))) (HMul.hMul (HSub.hSub (HDiv.hDiv (Fintype.card α) P.parts.card) (HMul.hMul (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card)) (HPow.hPow 4 P.parts.card))) (HAdd.hAdd (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card)) 1))) u.card","decl":"theorem card_aux₁ (hucard : #u = m * 4 ^ #P.parts + a) :\n    (4 ^ #P.parts - a) * m + a * (m + 1) = #u := by\n  rw [hucard, mul_add, mul_one, ← add_assoc, ← add_mul,\n    Nat.sub_add_cancel ((Nat.le_succ _).trans a_add_one_le_four_pow_parts_card), mul_comm]\n\n"}
{"name":"SzemerediRegularity.card_aux₂","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nP : Finpartition Finset.univ\nu : Finset α\nhP : P.IsEquipartition\nhu : Membership.mem P.parts u\nhucard : Ne u.card (HAdd.hAdd (HMul.hMul (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card)) (HPow.hPow 4 P.parts.card)) (HSub.hSub (HDiv.hDiv (Fintype.card α) P.parts.card) (HMul.hMul (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card)) (HPow.hPow 4 P.parts.card))))\n⊢ Eq (HAdd.hAdd (HMul.hMul (HSub.hSub (HPow.hPow 4 P.parts.card) (HAdd.hAdd (HSub.hSub (HDiv.hDiv (Fintype.card α) P.parts.card) (HMul.hMul (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card)) (HPow.hPow 4 P.parts.card))) 1)) (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card))) (HMul.hMul (HAdd.hAdd (HSub.hSub (HDiv.hDiv (Fintype.card α) P.parts.card) (HMul.hMul (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card)) (HPow.hPow 4 P.parts.card))) 1) (HAdd.hAdd (HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card)) 1))) u.card","decl":"theorem card_aux₂ (hP : P.IsEquipartition) (hu : u ∈ P.parts) (hucard : #u ≠ m * 4 ^ #P.parts + a) :\n    (4 ^ #P.parts - (a + 1)) * m + (a + 1) * (m + 1) = #u := by\n  have : m * 4 ^ #P.parts ≤ card α / #P.parts := by\n    rw [stepBound, ← Nat.div_div_eq_div_mul]\n    exact Nat.div_mul_le_self _ _\n  rw [Nat.add_sub_of_le this] at hucard\n  rw [(hP.card_parts_eq_average hu).resolve_left hucard, mul_add, mul_one, ← add_assoc, ← add_mul,\n    Nat.sub_add_cancel a_add_one_le_four_pow_parts_card, ← add_assoc, mul_comm,\n    Nat.add_sub_of_le this, card_univ]\n\n"}
{"name":"SzemerediRegularity.pow_mul_m_le_card_part","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nP : Finpartition Finset.univ\nu : Finset α\nhP : P.IsEquipartition\nhu : Membership.mem P.parts u\n⊢ LE.le (HMul.hMul (HPow.hPow 4 P.parts.card) ↑(HDiv.hDiv (Fintype.card α) (SzemerediRegularity.stepBound P.parts.card))) ↑u.card","decl":"theorem pow_mul_m_le_card_part (hP : P.IsEquipartition) (hu : u ∈ P.parts) :\n    (4 : ℝ) ^ #P.parts * m ≤ #u := by\n  norm_cast\n  rw [stepBound, ← Nat.div_div_eq_div_mul]\n  exact (Nat.mul_div_le _ _).trans (hP.average_le_card_part hu)\n\n"}
{"name":"SzemerediRegularity.le_initialBound","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"ε : Real\nl : Nat\n⊢ LE.le l (SzemerediRegularity.initialBound ε l)","decl":"theorem le_initialBound : l ≤ initialBound ε l :=\n  (le_max_left _ _).trans <| le_max_right _ _\n\n"}
{"name":"SzemerediRegularity.seven_le_initialBound","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"ε : Real\nl : Nat\n⊢ LE.le 7 (SzemerediRegularity.initialBound ε l)","decl":"theorem seven_le_initialBound : 7 ≤ initialBound ε l :=\n  le_max_left _ _\n\n"}
{"name":"SzemerediRegularity.initialBound_pos","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"ε : Real\nl : Nat\n⊢ LT.lt 0 (SzemerediRegularity.initialBound ε l)","decl":"theorem initialBound_pos : 0 < initialBound ε l :=\n  Nat.succ_pos'.trans_le <| seven_le_initialBound _ _\n\n"}
{"name":"SzemerediRegularity.hundred_lt_pow_initialBound_mul","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"ε : Real\nhε : LT.lt 0 ε\nl : Nat\n⊢ LT.lt 100 (HMul.hMul (HPow.hPow 4 (SzemerediRegularity.initialBound ε l)) (HPow.hPow ε 5))","decl":"theorem hundred_lt_pow_initialBound_mul {ε : ℝ} (hε : 0 < ε) (l : ℕ) :\n    100 < ↑4 ^ initialBound ε l * ε ^ 5 := by\n  rw [← rpow_natCast 4, ← div_lt_iff₀ (pow_pos hε 5), lt_rpow_iff_log_lt _ zero_lt_four, ←\n    div_lt_iff₀, initialBound, Nat.cast_max, Nat.cast_max]\n  · push_cast\n    exact lt_max_of_lt_right (lt_max_of_lt_right <| Nat.lt_floor_add_one _)\n  · exact log_pos (by norm_num)\n  · exact div_pos (by norm_num) (pow_pos hε 5)\n\n"}
{"name":"SzemerediRegularity.initialBound_le_bound","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"ε : Real\nl : Nat\n⊢ LE.le (SzemerediRegularity.initialBound ε l) (SzemerediRegularity.bound ε l)","decl":"theorem initialBound_le_bound : initialBound ε l ≤ bound ε l :=\n  (id_le_iterate_of_id_le le_stepBound _ _).trans <| Nat.le_mul_of_pos_right _ <| by positivity\n\n"}
{"name":"SzemerediRegularity.le_bound","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"ε : Real\nl : Nat\n⊢ LE.le l (SzemerediRegularity.bound ε l)","decl":"theorem le_bound : l ≤ bound ε l :=\n  (le_initialBound ε l).trans <| initialBound_le_bound ε l\n\n"}
{"name":"SzemerediRegularity.bound_pos","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"ε : Real\nl : Nat\n⊢ LT.lt 0 (SzemerediRegularity.bound ε l)","decl":"theorem bound_pos : 0 < bound ε l :=\n  (initialBound_pos ε l).trans_le <| initialBound_le_bound ε l\n\n"}
{"name":"SzemerediRegularity.mul_sq_le_sum_sq","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"ι : Type u_2\n𝕜 : Type u_3\ninst✝ : LinearOrderedField 𝕜\ns t : Finset ι\nx : 𝕜\nhst : HasSubset.Subset s t\nf : ι → 𝕜\nhs : LE.le (HPow.hPow x 2) (HPow.hPow (HDiv.hDiv (s.sum fun i => f i) ↑s.card) 2)\nhs' : Ne (↑s.card) 0\n⊢ LE.le (HMul.hMul (↑s.card) (HPow.hPow x 2)) (t.sum fun i => HPow.hPow (f i) 2)","decl":"theorem mul_sq_le_sum_sq (hst : s ⊆ t) (f : ι → 𝕜) (hs : x ^ 2 ≤ ((∑ i ∈ s, f i) / #s) ^ 2)\n    (hs' : (#s : 𝕜) ≠ 0) : (#s : 𝕜) * x ^ 2 ≤ ∑ i ∈ t, f i ^ 2 :=\n  (mul_le_mul_of_nonneg_left (hs.trans sum_div_card_sq_le_sum_sq_div_card) <|\n    Nat.cast_nonneg _).trans <| (mul_div_cancel₀ _ hs').le.trans <|\n      sum_le_sum_of_subset_of_nonneg hst fun _ _ _ => sq_nonneg _\n\n"}
{"name":"SzemerediRegularity.add_div_le_sum_sq_div_card","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Bound","initialProofState":"ι : Type u_2\n𝕜 : Type u_3\ninst✝ : LinearOrderedField 𝕜\ns t : Finset ι\nx : 𝕜\nhst : HasSubset.Subset s t\nf : ι → 𝕜\nd : 𝕜\nhx : LE.le 0 x\nhs : LE.le x (abs (HSub.hSub (HDiv.hDiv (s.sum fun i => f i) ↑s.card) (HDiv.hDiv (t.sum fun i => f i) ↑t.card)))\nht : LE.le d (HPow.hPow (HDiv.hDiv (t.sum fun i => f i) ↑t.card) 2)\n⊢ LE.le (HAdd.hAdd d (HMul.hMul (HDiv.hDiv ↑s.card ↑t.card) (HPow.hPow x 2))) (HDiv.hDiv (t.sum fun i => HPow.hPow (f i) 2) ↑t.card)","decl":"theorem add_div_le_sum_sq_div_card (hst : s ⊆ t) (f : ι → 𝕜) (d : 𝕜) (hx : 0 ≤ x)\n    (hs : x ≤ |(∑ i ∈ s, f i) / #s - (∑ i ∈ t, f i) / #t|) (ht : d ≤ ((∑ i ∈ t, f i) / #t) ^ 2) :\n    d + #s / #t * x ^ 2 ≤ (∑ i ∈ t, f i ^ 2) / #t := by\n  obtain hscard | hscard := ((#s).cast_nonneg : (0 : 𝕜) ≤ #s).eq_or_lt\n  · simpa [← hscard] using ht.trans sum_div_card_sq_le_sum_sq_div_card\n  have htcard : (0 : 𝕜) < #t := hscard.trans_le (Nat.cast_le.2 (card_le_card hst))\n  have h₁ : x ^ 2 ≤ ((∑ i ∈ s, f i) / #s - (∑ i ∈ t, f i) / #t) ^ 2 :=\n    sq_le_sq.2 (by rwa [abs_of_nonneg hx])\n  have h₂ : x ^ 2 ≤ ((∑ i ∈ s, (f i - (∑ j ∈ t, f j) / #t)) / #s) ^ 2 := by\n    apply h₁.trans\n    rw [sum_sub_distrib, sum_const, nsmul_eq_mul, sub_div, mul_div_cancel_left₀ _ hscard.ne']\n  apply (add_le_add_right ht _).trans\n  rw [← mul_div_right_comm, le_div_iff₀ htcard, add_mul, div_mul_cancel₀ _ htcard.ne']\n  have h₃ := mul_sq_le_sum_sq hst (fun i => (f i - (∑ j ∈ t, f j) / #t)) h₂ hscard.ne'\n  apply (add_le_add_left h₃ _).trans\n  -- Porting note: was\n  -- simp [← mul_div_right_comm _ (#t : 𝕜), sub_div' _ _ _ htcard.ne', ← sum_div, ← add_div,\n  --   mul_pow, div_le_iff₀ (sq_pos_of_ne_zero htcard.ne'), sub_sq, sum_add_distrib, ← sum_mul,\n  --   ← mul_sum]\n  simp_rw [sub_div' _ _ _ htcard.ne']\n  conv_lhs => enter [2, 2, x]; rw [div_pow]\n  rw [div_pow, ← sum_div, ← mul_div_right_comm _ (#t : 𝕜), ← add_div,\n    div_le_iff₀ (sq_pos_of_ne_zero htcard.ne')]\n  simp_rw [sub_sq, sum_add_distrib, sum_const, nsmul_eq_mul, sum_sub_distrib, mul_pow, ← sum_mul,\n    ← mul_sum, ← sum_mul]\n  ring_nf; rfl\n\n"}
