{"name":"Nat.mono_cast","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddMonoidWithOne α\ninst✝² : PartialOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : ZeroLEOneClass α\n⊢ Monotone Nat.cast","decl":"@[mono]\ntheorem mono_cast : Monotone (Nat.cast : ℕ → α) :=\n  monotone_nat_of_le_succ fun n ↦ by\n    rw [Nat.cast_succ]; exact le_add_of_nonneg_right zero_le_one\n\n"}
{"name":"GCongr.natCast_le_natCast","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddMonoidWithOne α\ninst✝² : PartialOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : ZeroLEOneClass α\na b : Nat\nh : LE.le a b\n⊢ LE.le ↑a ↑b","decl":"@[gcongr]\ntheorem _root_.GCongr.natCast_le_natCast {a b : ℕ} (h : a ≤ b) : (a : α) ≤ b := mono_cast h\n\n"}
{"name":"Nat.cast_nonneg'","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddMonoidWithOne α\ninst✝² : PartialOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : ZeroLEOneClass α\nn : Nat\n⊢ LE.le 0 ↑n","decl":"/-- See also `Nat.cast_nonneg`, specialised for an `OrderedSemiring`. -/\n@[simp low]\ntheorem cast_nonneg' (n : ℕ) : 0 ≤ (n : α) :=\n  @Nat.cast_zero α _ ▸ mono_cast (Nat.zero_le n)\n\n"}
{"name":"Nat.ofNat_nonneg'","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : AddMonoidWithOne α\ninst✝³ : PartialOrder α\ninst✝² : AddLeftMono α\ninst✝¹ : ZeroLEOneClass α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ LE.le 0 (OfNat.ofNat n)","decl":"/-- See also `Nat.ofNat_nonneg`, specialised for an `OrderedSemiring`. -/\n@[simp low]\ntheorem ofNat_nonneg' (n : ℕ) [n.AtLeastTwo] : 0 ≤ (ofNat(n) : α) := cast_nonneg' n\n\n"}
{"name":"Nat.cast_add_one_pos","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : AddMonoidWithOne α\ninst✝³ : PartialOrder α\ninst✝² : AddLeftMono α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : NeZero 1\nn : Nat\n⊢ LT.lt 0 (HAdd.hAdd (↑n) 1)","decl":"theorem cast_add_one_pos (n : ℕ) : 0 < (n : α) + 1 := by\n  apply zero_lt_one.trans_le\n  convert (@mono_cast α _).imp (?_ : 1 ≤ n + 1)\n  <;> simp\n\n"}
{"name":"Nat.cast_pos'","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : AddMonoidWithOne α\ninst✝³ : PartialOrder α\ninst✝² : AddLeftMono α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : NeZero 1\nn : Nat\n⊢ Iff (LT.lt 0 ↑n) (LT.lt 0 n)","decl":"/-- See also `Nat.cast_pos`, specialised for an `OrderedSemiring`. -/\n@[simp low]\ntheorem cast_pos' {n : ℕ} : (0 : α) < n ↔ 0 < n := by cases n <;> simp [cast_add_one_pos]\n\n"}
{"name":"Nat.strictMono_cast","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : AddMonoidWithOne α\ninst✝³ : PartialOrder α\ninst✝² : AddLeftMono α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : CharZero α\n⊢ StrictMono Nat.cast","decl":"theorem strictMono_cast : StrictMono (Nat.cast : ℕ → α) :=\n  mono_cast.strictMono_of_injective cast_injective\n\n"}
{"name":"GCongr.natCast_lt_natCast","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : AddMonoidWithOne α\ninst✝³ : PartialOrder α\ninst✝² : AddLeftMono α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : CharZero α\na b : Nat\nh : LT.lt a b\n⊢ LT.lt ↑a ↑b","decl":"@[gcongr]\nlemma _root_.GCongr.natCast_lt_natCast {a b : ℕ} (h : a < b) : (a : α) < b := strictMono_cast h\n\n"}
{"name":"Nat.castOrderEmbedding_apply","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : AddMonoidWithOne α\ninst✝³ : PartialOrder α\ninst✝² : AddLeftMono α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : CharZero α\n⊢ Eq (⇑Nat.castOrderEmbedding) Nat.cast","decl":"/-- `Nat.cast : ℕ → α` as an `OrderEmbedding` -/\n@[simps! (config := .asFn)]\ndef castOrderEmbedding : ℕ ↪o α :=\n  OrderEmbedding.ofStrictMono Nat.cast Nat.strictMono_cast\n\n"}
{"name":"Nat.cast_le","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : AddMonoidWithOne α\ninst✝³ : PartialOrder α\ninst✝² : AddLeftMono α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : CharZero α\nm n : Nat\n⊢ Iff (LE.le ↑m ↑n) (LE.le m n)","decl":"@[simp, norm_cast]\ntheorem cast_le : (m : α) ≤ n ↔ m ≤ n :=\n  strictMono_cast.le_iff_le\n\n"}
{"name":"Nat.cast_lt","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : AddMonoidWithOne α\ninst✝³ : PartialOrder α\ninst✝² : AddLeftMono α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : CharZero α\nm n : Nat\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt m n)","decl":"@[simp, norm_cast, mono]\ntheorem cast_lt : (m : α) < n ↔ m < n :=\n  strictMono_cast.lt_iff_lt\n\n"}
{"name":"Nat.one_lt_cast","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : AddMonoidWithOne α\ninst✝³ : PartialOrder α\ninst✝² : AddLeftMono α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : CharZero α\nn : Nat\n⊢ Iff (LT.lt 1 ↑n) (LT.lt 1 n)","decl":"@[simp, norm_cast]\ntheorem one_lt_cast : 1 < (n : α) ↔ 1 < n := by rw [← cast_one, cast_lt]\n\n"}
{"name":"Nat.one_le_cast","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : AddMonoidWithOne α\ninst✝³ : PartialOrder α\ninst✝² : AddLeftMono α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : CharZero α\nn : Nat\n⊢ Iff (LE.le 1 ↑n) (LE.le 1 n)","decl":"@[simp, norm_cast]\ntheorem one_le_cast : 1 ≤ (n : α) ↔ 1 ≤ n := by rw [← cast_one, cast_le]\n\n"}
{"name":"Nat.cast_lt_one","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : AddMonoidWithOne α\ninst✝³ : PartialOrder α\ninst✝² : AddLeftMono α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : CharZero α\nn : Nat\n⊢ Iff (LT.lt (↑n) 1) (Eq n 0)","decl":"@[simp, norm_cast]\ntheorem cast_lt_one : (n : α) < 1 ↔ n = 0 := by\n  rw [← cast_one, cast_lt, Nat.lt_succ_iff, le_zero]\n\n"}
{"name":"Nat.cast_le_one","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : AddMonoidWithOne α\ninst✝³ : PartialOrder α\ninst✝² : AddLeftMono α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : CharZero α\nn : Nat\n⊢ Iff (LE.le (↑n) 1) (LE.le n 1)","decl":"@[simp, norm_cast]\ntheorem cast_le_one : (n : α) ≤ 1 ↔ n ≤ 1 := by rw [← cast_one, cast_le]\n\n"}
{"name":"Nat.cast_nonpos","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁴ : AddMonoidWithOne α\ninst✝³ : PartialOrder α\ninst✝² : AddLeftMono α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : CharZero α\nn : Nat\n⊢ Iff (LE.le (↑n) 0) (Eq n 0)","decl":"@[simp] lemma cast_nonpos : (n : α) ≤ 0 ↔ n = 0 := by norm_cast; omega\n\n"}
{"name":"Nat.ofNat_le_cast","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁵ : AddMonoidWithOne α\ninst✝⁴ : PartialOrder α\ninst✝³ : AddLeftMono α\ninst✝² : ZeroLEOneClass α\ninst✝¹ : CharZero α\nm n : Nat\ninst✝ : m.AtLeastTwo\n⊢ Iff (LE.le (OfNat.ofNat m) ↑n) (LE.le (OfNat.ofNat m) n)","decl":"@[simp]\ntheorem ofNat_le_cast : (ofNat(m) : α) ≤ n ↔ (OfNat.ofNat m : ℕ) ≤ n :=\n  cast_le\n\n"}
{"name":"Nat.ofNat_lt_cast","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁵ : AddMonoidWithOne α\ninst✝⁴ : PartialOrder α\ninst✝³ : AddLeftMono α\ninst✝² : ZeroLEOneClass α\ninst✝¹ : CharZero α\nm n : Nat\ninst✝ : m.AtLeastTwo\n⊢ Iff (LT.lt (OfNat.ofNat m) ↑n) (LT.lt (OfNat.ofNat m) n)","decl":"@[simp]\ntheorem ofNat_lt_cast : (ofNat(m) : α) < n ↔ (OfNat.ofNat m : ℕ) < n :=\n  cast_lt\n\n"}
{"name":"Nat.cast_le_ofNat","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁵ : AddMonoidWithOne α\ninst✝⁴ : PartialOrder α\ninst✝³ : AddLeftMono α\ninst✝² : ZeroLEOneClass α\ninst✝¹ : CharZero α\nm n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LE.le (↑m) (OfNat.ofNat n)) (LE.le m (OfNat.ofNat n))","decl":"@[simp]\ntheorem cast_le_ofNat : (m : α) ≤ (ofNat(n) : α) ↔ m ≤ OfNat.ofNat n :=\n  cast_le\n\n"}
{"name":"Nat.cast_lt_ofNat","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁵ : AddMonoidWithOne α\ninst✝⁴ : PartialOrder α\ninst✝³ : AddLeftMono α\ninst✝² : ZeroLEOneClass α\ninst✝¹ : CharZero α\nm n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LT.lt (↑m) (OfNat.ofNat n)) (LT.lt m (OfNat.ofNat n))","decl":"@[simp]\ntheorem cast_lt_ofNat : (m : α) < (ofNat(n) : α) ↔ m < OfNat.ofNat n :=\n  cast_lt\n\n"}
{"name":"Nat.one_lt_ofNat","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁵ : AddMonoidWithOne α\ninst✝⁴ : PartialOrder α\ninst✝³ : AddLeftMono α\ninst✝² : ZeroLEOneClass α\ninst✝¹ : CharZero α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ LT.lt 1 (OfNat.ofNat n)","decl":"@[simp]\ntheorem one_lt_ofNat : 1 < (ofNat(n) : α) :=\n  one_lt_cast.mpr AtLeastTwo.one_lt\n\n"}
{"name":"Nat.one_le_ofNat","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁵ : AddMonoidWithOne α\ninst✝⁴ : PartialOrder α\ninst✝³ : AddLeftMono α\ninst✝² : ZeroLEOneClass α\ninst✝¹ : CharZero α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ LE.le 1 (OfNat.ofNat n)","decl":"@[simp]\ntheorem one_le_ofNat : 1 ≤ (ofNat(n) : α) :=\n  one_le_cast.mpr NeZero.one_le\n\n"}
{"name":"Nat.not_ofNat_le_one","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁵ : AddMonoidWithOne α\ninst✝⁴ : PartialOrder α\ninst✝³ : AddLeftMono α\ninst✝² : ZeroLEOneClass α\ninst✝¹ : CharZero α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Not (LE.le (OfNat.ofNat n) 1)","decl":"@[simp]\ntheorem not_ofNat_le_one : ¬(ofNat(n) : α) ≤ 1 :=\n  (cast_le_one.not.trans not_le).mpr AtLeastTwo.one_lt\n\n"}
{"name":"Nat.not_ofNat_lt_one","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁵ : AddMonoidWithOne α\ninst✝⁴ : PartialOrder α\ninst✝³ : AddLeftMono α\ninst✝² : ZeroLEOneClass α\ninst✝¹ : CharZero α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Not (LT.lt (OfNat.ofNat n) 1)","decl":"@[simp]\ntheorem not_ofNat_lt_one : ¬(ofNat(n) : α) < 1 :=\n  mt le_of_lt not_ofNat_le_one\n\n"}
{"name":"Nat.ofNat_le","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁶ : AddMonoidWithOne α\ninst✝⁵ : PartialOrder α\ninst✝⁴ : AddLeftMono α\ninst✝³ : ZeroLEOneClass α\ninst✝² : CharZero α\nm n : Nat\ninst✝¹ : n.AtLeastTwo\ninst✝ : m.AtLeastTwo\n⊢ Iff (LE.le (OfNat.ofNat m) (OfNat.ofNat n)) (LE.le (OfNat.ofNat m) (OfNat.ofNat n))","decl":"theorem ofNat_le :\n    (ofNat(m) : α) ≤ (ofNat(n) : α) ↔ (OfNat.ofNat m : ℕ) ≤ OfNat.ofNat n :=\n  cast_le\n\n-- @[simp]\n"}
{"name":"Nat.ofNat_lt","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝⁶ : AddMonoidWithOne α\ninst✝⁵ : PartialOrder α\ninst✝⁴ : AddLeftMono α\ninst✝³ : ZeroLEOneClass α\ninst✝² : CharZero α\nm n : Nat\ninst✝¹ : n.AtLeastTwo\ninst✝ : m.AtLeastTwo\n⊢ Iff (LT.lt (OfNat.ofNat m) (OfNat.ofNat n)) (LT.lt (OfNat.ofNat m) (OfNat.ofNat n))","decl":"theorem ofNat_lt :\n    (ofNat(m) : α) < (ofNat(n) : α) ↔ (OfNat.ofNat m : ℕ) < OfNat.ofNat n :=\n  cast_lt\n\n"}
{"name":"instNontrivialOfCharZero","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"α : Type u_1\ninst✝¹ : AddMonoidWithOne α\ninst✝ : CharZero α\n⊢ Nontrivial α","decl":"instance [AddMonoidWithOne α] [CharZero α] : Nontrivial α where exists_pair_ne :=\n  ⟨1, 0, (Nat.cast_one (R := α) ▸ Nat.cast_ne_zero.2 (by decide))⟩\n\n"}
{"name":"NeZero.nat_of_injective","module":"Mathlib.Data.Nat.Cast.Order.Basic","initialProofState":"R : Type u_2\nS : Type u_3\nF : Type u_4\ninst✝⁴ : NonAssocSemiring R\ninst✝³ : NonAssocSemiring S\ninst✝² : FunLike F R S\nn : Nat\ninst✝¹ : NeZero ↑n\ninst✝ : RingHomClass F R S\nf : F\nhf : Function.Injective ⇑f\n⊢ NeZero ↑n","decl":"theorem NeZero.nat_of_injective {n : ℕ} [NeZero (n : R)] [RingHomClass F R S] {f : F}\n    (hf : Function.Injective f) : NeZero (n : S) :=\n  ⟨fun h ↦ NeZero.natCast_ne n R <| hf <| by simpa only [map_natCast, map_zero f]⟩\n\n"}
