{"name":"ContinuousMap.val_addUnitsLift_symm_apply_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : AddMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nf : AddUnits (ContinuousMap X M)\nx : X\nâŠ¢ Eq (â†‘((ContinuousMap.addUnitsLift.symm f) x)) (â†‘f x)","decl":"/-- Equivalence between continuous maps into the units of a monoid with continuous multiplication\nand the units of the monoid of continuous maps. -/\n-- `simps` generates some lemmas here with LHS not in simp normal form,\n-- so we write them out manually below.\n@[to_additive (attr := simps apply_val_apply symm_apply_apply_val)\n\"Equivalence between continuous maps into the additive units of an additive monoid with continuous\naddition and the additive units of the additive monoid of continuous maps.\"]\ndef unitsLift : C(X, MË£) â‰ƒ C(X, M)Ë£ where\n  toFun f :=\n    { val := âŸ¨fun x => f x, Units.continuous_val.comp f.continuousâŸ©\n      inv := âŸ¨fun x => â†‘(f x)â»Â¹, Units.continuous_val.comp (continuous_inv.comp f.continuous)âŸ©\n      val_inv := ext fun _ => Units.mul_inv _\n      inv_val := ext fun _ => Units.inv_mul _ }\n  invFun f :=\n    { toFun := fun x =>\n        âŸ¨(f : C(X, M)) x, (â†‘fâ»Â¹ : C(X, M)) x,\n          ContinuousMap.congr_fun f.mul_inv x, ContinuousMap.congr_fun f.inv_mul xâŸ©\n      continuous_toFun := continuous_induced_rng.2 <|\n        (f : C(X, M)).continuous.prod_mk <|\n        MulOpposite.continuous_op.comp (â†‘fâ»Â¹ : C(X, M)).continuous }\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl\n\n"}
{"name":"ContinuousMap.val_addUnitsLift_apply_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : AddMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nf : ContinuousMap X (AddUnits M)\nx : X\nâŠ¢ Eq (â†‘(ContinuousMap.addUnitsLift f) x) â†‘(f x)","decl":"/-- Equivalence between continuous maps into the units of a monoid with continuous multiplication\nand the units of the monoid of continuous maps. -/\n-- `simps` generates some lemmas here with LHS not in simp normal form,\n-- so we write them out manually below.\n@[to_additive (attr := simps apply_val_apply symm_apply_apply_val)\n\"Equivalence between continuous maps into the additive units of an additive monoid with continuous\naddition and the additive units of the additive monoid of continuous maps.\"]\ndef unitsLift : C(X, MË£) â‰ƒ C(X, M)Ë£ where\n  toFun f :=\n    { val := âŸ¨fun x => f x, Units.continuous_val.comp f.continuousâŸ©\n      inv := âŸ¨fun x => â†‘(f x)â»Â¹, Units.continuous_val.comp (continuous_inv.comp f.continuous)âŸ©\n      val_inv := ext fun _ => Units.mul_inv _\n      inv_val := ext fun _ => Units.inv_mul _ }\n  invFun f :=\n    { toFun := fun x =>\n        âŸ¨(f : C(X, M)) x, (â†‘fâ»Â¹ : C(X, M)) x,\n          ContinuousMap.congr_fun f.mul_inv x, ContinuousMap.congr_fun f.inv_mul xâŸ©\n      continuous_toFun := continuous_induced_rng.2 <|\n        (f : C(X, M)).continuous.prod_mk <|\n        MulOpposite.continuous_op.comp (â†‘fâ»Â¹ : C(X, M)).continuous }\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl\n\n"}
{"name":"ContinuousMap.val_unitsLift_apply_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : Monoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nf : ContinuousMap X (Units M)\nx : X\nâŠ¢ Eq (â†‘(ContinuousMap.unitsLift f) x) â†‘(f x)","decl":"/-- Equivalence between continuous maps into the units of a monoid with continuous multiplication\nand the units of the monoid of continuous maps. -/\n-- `simps` generates some lemmas here with LHS not in simp normal form,\n-- so we write them out manually below.\n@[to_additive (attr := simps apply_val_apply symm_apply_apply_val)\n\"Equivalence between continuous maps into the additive units of an additive monoid with continuous\naddition and the additive units of the additive monoid of continuous maps.\"]\ndef unitsLift : C(X, MË£) â‰ƒ C(X, M)Ë£ where\n  toFun f :=\n    { val := âŸ¨fun x => f x, Units.continuous_val.comp f.continuousâŸ©\n      inv := âŸ¨fun x => â†‘(f x)â»Â¹, Units.continuous_val.comp (continuous_inv.comp f.continuous)âŸ©\n      val_inv := ext fun _ => Units.mul_inv _\n      inv_val := ext fun _ => Units.inv_mul _ }\n  invFun f :=\n    { toFun := fun x =>\n        âŸ¨(f : C(X, M)) x, (â†‘fâ»Â¹ : C(X, M)) x,\n          ContinuousMap.congr_fun f.mul_inv x, ContinuousMap.congr_fun f.inv_mul xâŸ©\n      continuous_toFun := continuous_induced_rng.2 <|\n        (f : C(X, M)).continuous.prod_mk <|\n        MulOpposite.continuous_op.comp (â†‘fâ»Â¹ : C(X, M)).continuous }\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl\n\n"}
{"name":"ContinuousMap.val_unitsLift_symm_apply_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : Monoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nf : Units (ContinuousMap X M)\nx : X\nâŠ¢ Eq (â†‘((ContinuousMap.unitsLift.symm f) x)) (â†‘f x)","decl":"/-- Equivalence between continuous maps into the units of a monoid with continuous multiplication\nand the units of the monoid of continuous maps. -/\n-- `simps` generates some lemmas here with LHS not in simp normal form,\n-- so we write them out manually below.\n@[to_additive (attr := simps apply_val_apply symm_apply_apply_val)\n\"Equivalence between continuous maps into the additive units of an additive monoid with continuous\naddition and the additive units of the additive monoid of continuous maps.\"]\ndef unitsLift : C(X, MË£) â‰ƒ C(X, M)Ë£ where\n  toFun f :=\n    { val := âŸ¨fun x => f x, Units.continuous_val.comp f.continuousâŸ©\n      inv := âŸ¨fun x => â†‘(f x)â»Â¹, Units.continuous_val.comp (continuous_inv.comp f.continuous)âŸ©\n      val_inv := ext fun _ => Units.mul_inv _\n      inv_val := ext fun _ => Units.inv_mul _ }\n  invFun f :=\n    { toFun := fun x =>\n        âŸ¨(f : C(X, M)) x, (â†‘fâ»Â¹ : C(X, M)) x,\n          ContinuousMap.congr_fun f.mul_inv x, ContinuousMap.congr_fun f.inv_mul xâŸ©\n      continuous_toFun := continuous_induced_rng.2 <|\n        (f : C(X, M)).continuous.prod_mk <|\n        MulOpposite.continuous_op.comp (â†‘fâ»Â¹ : C(X, M)).continuous }\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl\n\n"}
{"name":"ContinuousMap.addUnitsLift_apply_neg_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : AddMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nf : ContinuousMap X (AddUnits M)\nx : X\nâŠ¢ Eq (â†‘(Neg.neg (ContinuousMap.addUnitsLift f)) x) â†‘(Neg.neg (f x))","decl":"@[to_additive (attr := simp)]\nlemma unitsLift_apply_inv_apply (f : C(X, MË£)) (x : X) :\n    (â†‘(ContinuousMap.unitsLift f)â»Â¹ : C(X, M)) x = (f x)â»Â¹ :=\n  rfl\n\n"}
{"name":"ContinuousMap.unitsLift_apply_inv_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : Monoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nf : ContinuousMap X (Units M)\nx : X\nâŠ¢ Eq (â†‘(Inv.inv (ContinuousMap.unitsLift f)) x) â†‘(Inv.inv (f x))","decl":"@[to_additive (attr := simp)]\nlemma unitsLift_apply_inv_apply (f : C(X, MË£)) (x : X) :\n    (â†‘(ContinuousMap.unitsLift f)â»Â¹ : C(X, M)) x = (f x)â»Â¹ :=\n  rfl\n\n"}
{"name":"ContinuousMap.unitsLift_symm_apply_apply_inv'","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : Monoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nf : Units (ContinuousMap X M)\nx : X\nâŠ¢ Eq (â†‘(Inv.inv ((ContinuousMap.unitsLift.symm f) x))) (â†‘(Inv.inv f) x)","decl":"@[to_additive (attr := simp)]\nlemma unitsLift_symm_apply_apply_inv' (f : C(X, M)Ë£) (x : X) :\n    (ContinuousMap.unitsLift.symm f x)â»Â¹ = (â†‘fâ»Â¹ : C(X, M)) x := by\n  rfl\n\n"}
{"name":"ContinuousMap.addUnitsLift_symm_apply_apply_neg'","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : AddMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nf : AddUnits (ContinuousMap X M)\nx : X\nâŠ¢ Eq (â†‘(Neg.neg ((ContinuousMap.addUnitsLift.symm f) x))) (â†‘(Neg.neg f) x)","decl":"@[to_additive (attr := simp)]\nlemma unitsLift_symm_apply_apply_inv' (f : C(X, M)Ë£) (x : X) :\n    (ContinuousMap.unitsLift.symm f x)â»Â¹ = (â†‘fâ»Â¹ : C(X, M)) x := by\n  rfl\n\n"}
{"name":"ContinuousMap.continuous_isUnit_unit","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nR : Type u_3\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : NormedRing R\ninstâœ : CompleteSpace R\nf : ContinuousMap X R\nh : âˆ€ (x : X), IsUnit (f x)\nâŠ¢ Continuous fun x => â‹¯.unit","decl":"theorem continuous_isUnit_unit {f : C(X, R)} (h : âˆ€ x, IsUnit (f x)) :\n    Continuous fun x => (h x).unit := by\n  refine\n    continuous_induced_rng.2\n      (Continuous.prod_mk f.continuous\n        (MulOpposite.continuous_op.comp (continuous_iff_continuousAt.mpr fun x => ?_)))\n  have := NormedRing.inverse_continuousAt (h x).unit\n  simp only\n  simp only [â† Ring.inverse_unit, IsUnit.unit_spec] at this âŠ¢\n  exact this.comp (f.continuousAt x)\n-- Porting note: this had the worst namespace: `NormedRing`\n\n"}
{"name":"ContinuousMap.unitsOfForallIsUnit_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nR : Type u_3\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : NormedRing R\ninstâœ : CompleteSpace R\nf : ContinuousMap X R\nh : âˆ€ (x : X), IsUnit (f x)\nx : X\nâŠ¢ Eq ((ContinuousMap.unitsOfForallIsUnit h) x) â‹¯.unit","decl":"/-- Construct a continuous map into the group of units of a normed ring from a function into the\nnormed ring and a proof that every element of the range is a unit. -/\n@[simps]\nnoncomputable def unitsOfForallIsUnit {f : C(X, R)} (h : âˆ€ x, IsUnit (f x)) : C(X, RË£) where\n  toFun x := (h x).unit\n  continuous_toFun := continuous_isUnit_unit h\n\n"}
{"name":"ContinuousMap.canLift","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nR : Type u_3\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : NormedRing R\ninstâœ : CompleteSpace R\nâŠ¢ CanLift (ContinuousMap X R) (ContinuousMap X (Units R)) (fun f => { toFun := fun x => â†‘(f x), continuous_toFun := â‹¯ }) fun f => âˆ€ (x : X), IsUnit (f x)","decl":"instance canLift :\n    CanLift C(X, R) C(X, RË£) (fun f => âŸ¨fun x => f x, Units.continuous_val.comp f.continuousâŸ©)\n      fun f => âˆ€ x, IsUnit (f x) where\n  prf f h := âŸ¨unitsOfForallIsUnit h, by ext; rflâŸ©\n\n"}
{"name":"ContinuousMap.isUnit_iff_forall_isUnit","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nR : Type u_3\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : NormedRing R\ninstâœ : CompleteSpace R\nf : ContinuousMap X R\nâŠ¢ Iff (IsUnit f) (âˆ€ (x : X), IsUnit (f x))","decl":"theorem isUnit_iff_forall_isUnit (f : C(X, R)) : IsUnit f â†” âˆ€ x, IsUnit (f x) :=\n  Iff.intro (fun h => fun x => âŸ¨unitsLift.symm h.unit x, rflâŸ©) fun h =>\n    âŸ¨ContinuousMap.unitsLift (unitsOfForallIsUnit h), by ext; rflâŸ©\n\n"}
{"name":"ContinuousMap.isUnit_iff_forall_ne_zero","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nR : Type u_3\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : NormedDivisionRing R\ninstâœ : CompleteSpace R\nf : ContinuousMap X R\nâŠ¢ Iff (IsUnit f) (âˆ€ (x : X), Ne (f x) 0)","decl":"theorem isUnit_iff_forall_ne_zero (f : C(X, R)) : IsUnit f â†” âˆ€ x, f x â‰  0 := by\n  simp_rw [f.isUnit_iff_forall_isUnit, isUnit_iff_ne_zero]\n\n"}
{"name":"ContinuousMap.spectrum_eq_preimage_range","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nR : Type u_3\nğ•œ : Type u_4\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedDivisionRing R\ninstâœÂ¹ : Algebra ğ•œ R\ninstâœ : CompleteSpace R\nf : ContinuousMap X R\nâŠ¢ Eq (spectrum ğ•œ f) (Set.preimage (â‡‘(algebraMap ğ•œ R)) (Set.range â‡‘f))","decl":"theorem spectrum_eq_preimage_range (f : C(X, R)) :\n    spectrum ğ•œ f = algebraMap _ _ â»Â¹' Set.range f := by\n  ext x\n  simp only [spectrum.mem_iff, isUnit_iff_forall_ne_zero, not_forall, sub_apply,\n    algebraMap_apply, mul_one, Classical.not_not, Set.mem_range,\n    sub_eq_zero, @eq_comm _ (x â€¢ 1 : R) _, Set.mem_preimage, Algebra.algebraMap_eq_smul_one,\n    smul_apply, one_apply]\n\n"}
{"name":"ContinuousMap.spectrum_eq_range","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nğ•œ : Type u_4\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : CompleteSpace ğ•œ\nf : ContinuousMap X ğ•œ\nâŠ¢ Eq (spectrum ğ•œ f) (Set.range â‡‘f)","decl":"theorem spectrum_eq_range [CompleteSpace ğ•œ] (f : C(X, ğ•œ)) : spectrum ğ•œ f = Set.range f := by\n  rw [spectrum_eq_preimage_range, Algebra.id.map_eq_id]\n  exact Set.preimage_id\n\n"}
