{"name":"ContinuousMap.val_addUnitsLift_symm_apply_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : AddMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nf : AddUnits (ContinuousMap X M)\nx : X\n⊢ Eq (↑((ContinuousMap.addUnitsLift.symm f) x)) (↑f x)","decl":"/-- Equivalence between continuous maps into the units of a monoid with continuous multiplication\nand the units of the monoid of continuous maps. -/\n-- `simps` generates some lemmas here with LHS not in simp normal form,\n-- so we write them out manually below.\n@[to_additive (attr := simps apply_val_apply symm_apply_apply_val)\n\"Equivalence between continuous maps into the additive units of an additive monoid with continuous\naddition and the additive units of the additive monoid of continuous maps.\"]\ndef unitsLift : C(X, Mˣ) ≃ C(X, M)ˣ where\n  toFun f :=\n    { val := ⟨fun x => f x, Units.continuous_val.comp f.continuous⟩\n      inv := ⟨fun x => ↑(f x)⁻¹, Units.continuous_val.comp (continuous_inv.comp f.continuous)⟩\n      val_inv := ext fun _ => Units.mul_inv _\n      inv_val := ext fun _ => Units.inv_mul _ }\n  invFun f :=\n    { toFun := fun x =>\n        ⟨(f : C(X, M)) x, (↑f⁻¹ : C(X, M)) x,\n          ContinuousMap.congr_fun f.mul_inv x, ContinuousMap.congr_fun f.inv_mul x⟩\n      continuous_toFun := continuous_induced_rng.2 <|\n        (f : C(X, M)).continuous.prod_mk <|\n        MulOpposite.continuous_op.comp (↑f⁻¹ : C(X, M)).continuous }\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl\n\n"}
{"name":"ContinuousMap.val_addUnitsLift_apply_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : AddMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nf : ContinuousMap X (AddUnits M)\nx : X\n⊢ Eq (↑(ContinuousMap.addUnitsLift f) x) ↑(f x)","decl":"/-- Equivalence between continuous maps into the units of a monoid with continuous multiplication\nand the units of the monoid of continuous maps. -/\n-- `simps` generates some lemmas here with LHS not in simp normal form,\n-- so we write them out manually below.\n@[to_additive (attr := simps apply_val_apply symm_apply_apply_val)\n\"Equivalence between continuous maps into the additive units of an additive monoid with continuous\naddition and the additive units of the additive monoid of continuous maps.\"]\ndef unitsLift : C(X, Mˣ) ≃ C(X, M)ˣ where\n  toFun f :=\n    { val := ⟨fun x => f x, Units.continuous_val.comp f.continuous⟩\n      inv := ⟨fun x => ↑(f x)⁻¹, Units.continuous_val.comp (continuous_inv.comp f.continuous)⟩\n      val_inv := ext fun _ => Units.mul_inv _\n      inv_val := ext fun _ => Units.inv_mul _ }\n  invFun f :=\n    { toFun := fun x =>\n        ⟨(f : C(X, M)) x, (↑f⁻¹ : C(X, M)) x,\n          ContinuousMap.congr_fun f.mul_inv x, ContinuousMap.congr_fun f.inv_mul x⟩\n      continuous_toFun := continuous_induced_rng.2 <|\n        (f : C(X, M)).continuous.prod_mk <|\n        MulOpposite.continuous_op.comp (↑f⁻¹ : C(X, M)).continuous }\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl\n\n"}
{"name":"ContinuousMap.val_unitsLift_apply_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : Monoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nf : ContinuousMap X (Units M)\nx : X\n⊢ Eq (↑(ContinuousMap.unitsLift f) x) ↑(f x)","decl":"/-- Equivalence between continuous maps into the units of a monoid with continuous multiplication\nand the units of the monoid of continuous maps. -/\n-- `simps` generates some lemmas here with LHS not in simp normal form,\n-- so we write them out manually below.\n@[to_additive (attr := simps apply_val_apply symm_apply_apply_val)\n\"Equivalence between continuous maps into the additive units of an additive monoid with continuous\naddition and the additive units of the additive monoid of continuous maps.\"]\ndef unitsLift : C(X, Mˣ) ≃ C(X, M)ˣ where\n  toFun f :=\n    { val := ⟨fun x => f x, Units.continuous_val.comp f.continuous⟩\n      inv := ⟨fun x => ↑(f x)⁻¹, Units.continuous_val.comp (continuous_inv.comp f.continuous)⟩\n      val_inv := ext fun _ => Units.mul_inv _\n      inv_val := ext fun _ => Units.inv_mul _ }\n  invFun f :=\n    { toFun := fun x =>\n        ⟨(f : C(X, M)) x, (↑f⁻¹ : C(X, M)) x,\n          ContinuousMap.congr_fun f.mul_inv x, ContinuousMap.congr_fun f.inv_mul x⟩\n      continuous_toFun := continuous_induced_rng.2 <|\n        (f : C(X, M)).continuous.prod_mk <|\n        MulOpposite.continuous_op.comp (↑f⁻¹ : C(X, M)).continuous }\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl\n\n"}
{"name":"ContinuousMap.val_unitsLift_symm_apply_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : Monoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nf : Units (ContinuousMap X M)\nx : X\n⊢ Eq (↑((ContinuousMap.unitsLift.symm f) x)) (↑f x)","decl":"/-- Equivalence between continuous maps into the units of a monoid with continuous multiplication\nand the units of the monoid of continuous maps. -/\n-- `simps` generates some lemmas here with LHS not in simp normal form,\n-- so we write them out manually below.\n@[to_additive (attr := simps apply_val_apply symm_apply_apply_val)\n\"Equivalence between continuous maps into the additive units of an additive monoid with continuous\naddition and the additive units of the additive monoid of continuous maps.\"]\ndef unitsLift : C(X, Mˣ) ≃ C(X, M)ˣ where\n  toFun f :=\n    { val := ⟨fun x => f x, Units.continuous_val.comp f.continuous⟩\n      inv := ⟨fun x => ↑(f x)⁻¹, Units.continuous_val.comp (continuous_inv.comp f.continuous)⟩\n      val_inv := ext fun _ => Units.mul_inv _\n      inv_val := ext fun _ => Units.inv_mul _ }\n  invFun f :=\n    { toFun := fun x =>\n        ⟨(f : C(X, M)) x, (↑f⁻¹ : C(X, M)) x,\n          ContinuousMap.congr_fun f.mul_inv x, ContinuousMap.congr_fun f.inv_mul x⟩\n      continuous_toFun := continuous_induced_rng.2 <|\n        (f : C(X, M)).continuous.prod_mk <|\n        MulOpposite.continuous_op.comp (↑f⁻¹ : C(X, M)).continuous }\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl\n\n"}
{"name":"ContinuousMap.addUnitsLift_apply_neg_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : AddMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nf : ContinuousMap X (AddUnits M)\nx : X\n⊢ Eq (↑(Neg.neg (ContinuousMap.addUnitsLift f)) x) ↑(Neg.neg (f x))","decl":"@[to_additive (attr := simp)]\nlemma unitsLift_apply_inv_apply (f : C(X, Mˣ)) (x : X) :\n    (↑(ContinuousMap.unitsLift f)⁻¹ : C(X, M)) x = (f x)⁻¹ :=\n  rfl\n\n"}
{"name":"ContinuousMap.unitsLift_apply_inv_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : Monoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nf : ContinuousMap X (Units M)\nx : X\n⊢ Eq (↑(Inv.inv (ContinuousMap.unitsLift f)) x) ↑(Inv.inv (f x))","decl":"@[to_additive (attr := simp)]\nlemma unitsLift_apply_inv_apply (f : C(X, Mˣ)) (x : X) :\n    (↑(ContinuousMap.unitsLift f)⁻¹ : C(X, M)) x = (f x)⁻¹ :=\n  rfl\n\n"}
{"name":"ContinuousMap.unitsLift_symm_apply_apply_inv'","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : Monoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nf : Units (ContinuousMap X M)\nx : X\n⊢ Eq (↑(Inv.inv ((ContinuousMap.unitsLift.symm f) x))) (↑(Inv.inv f) x)","decl":"@[to_additive (attr := simp)]\nlemma unitsLift_symm_apply_apply_inv' (f : C(X, M)ˣ) (x : X) :\n    (ContinuousMap.unitsLift.symm f x)⁻¹ = (↑f⁻¹ : C(X, M)) x := by\n  rfl\n\n"}
{"name":"ContinuousMap.addUnitsLift_symm_apply_apply_neg'","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nM : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : AddMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nf : AddUnits (ContinuousMap X M)\nx : X\n⊢ Eq (↑(Neg.neg ((ContinuousMap.addUnitsLift.symm f) x))) (↑(Neg.neg f) x)","decl":"@[to_additive (attr := simp)]\nlemma unitsLift_symm_apply_apply_inv' (f : C(X, M)ˣ) (x : X) :\n    (ContinuousMap.unitsLift.symm f x)⁻¹ = (↑f⁻¹ : C(X, M)) x := by\n  rfl\n\n"}
{"name":"ContinuousMap.continuous_isUnit_unit","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nR : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : NormedRing R\ninst✝ : CompleteSpace R\nf : ContinuousMap X R\nh : ∀ (x : X), IsUnit (f x)\n⊢ Continuous fun x => ⋯.unit","decl":"theorem continuous_isUnit_unit {f : C(X, R)} (h : ∀ x, IsUnit (f x)) :\n    Continuous fun x => (h x).unit := by\n  refine\n    continuous_induced_rng.2\n      (Continuous.prod_mk f.continuous\n        (MulOpposite.continuous_op.comp (continuous_iff_continuousAt.mpr fun x => ?_)))\n  have := NormedRing.inverse_continuousAt (h x).unit\n  simp only\n  simp only [← Ring.inverse_unit, IsUnit.unit_spec] at this ⊢\n  exact this.comp (f.continuousAt x)\n-- Porting note: this had the worst namespace: `NormedRing`\n\n"}
{"name":"ContinuousMap.unitsOfForallIsUnit_apply","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nR : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : NormedRing R\ninst✝ : CompleteSpace R\nf : ContinuousMap X R\nh : ∀ (x : X), IsUnit (f x)\nx : X\n⊢ Eq ((ContinuousMap.unitsOfForallIsUnit h) x) ⋯.unit","decl":"/-- Construct a continuous map into the group of units of a normed ring from a function into the\nnormed ring and a proof that every element of the range is a unit. -/\n@[simps]\nnoncomputable def unitsOfForallIsUnit {f : C(X, R)} (h : ∀ x, IsUnit (f x)) : C(X, Rˣ) where\n  toFun x := (h x).unit\n  continuous_toFun := continuous_isUnit_unit h\n\n"}
{"name":"ContinuousMap.canLift","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nR : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : NormedRing R\ninst✝ : CompleteSpace R\n⊢ CanLift (ContinuousMap X R) (ContinuousMap X (Units R)) (fun f => { toFun := fun x => ↑(f x), continuous_toFun := ⋯ }) fun f => ∀ (x : X), IsUnit (f x)","decl":"instance canLift :\n    CanLift C(X, R) C(X, Rˣ) (fun f => ⟨fun x => f x, Units.continuous_val.comp f.continuous⟩)\n      fun f => ∀ x, IsUnit (f x) where\n  prf f h := ⟨unitsOfForallIsUnit h, by ext; rfl⟩\n\n"}
{"name":"ContinuousMap.isUnit_iff_forall_isUnit","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nR : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : NormedRing R\ninst✝ : CompleteSpace R\nf : ContinuousMap X R\n⊢ Iff (IsUnit f) (∀ (x : X), IsUnit (f x))","decl":"theorem isUnit_iff_forall_isUnit (f : C(X, R)) : IsUnit f ↔ ∀ x, IsUnit (f x) :=\n  Iff.intro (fun h => fun x => ⟨unitsLift.symm h.unit x, rfl⟩) fun h =>\n    ⟨ContinuousMap.unitsLift (unitsOfForallIsUnit h), by ext; rfl⟩\n\n"}
{"name":"ContinuousMap.isUnit_iff_forall_ne_zero","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nR : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : NormedDivisionRing R\ninst✝ : CompleteSpace R\nf : ContinuousMap X R\n⊢ Iff (IsUnit f) (∀ (x : X), Ne (f x) 0)","decl":"theorem isUnit_iff_forall_ne_zero (f : C(X, R)) : IsUnit f ↔ ∀ x, f x ≠ 0 := by\n  simp_rw [f.isUnit_iff_forall_isUnit, isUnit_iff_ne_zero]\n\n"}
{"name":"ContinuousMap.spectrum_eq_preimage_range","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\nR : Type u_3\n𝕜 : Type u_4\ninst✝⁴ : TopologicalSpace X\ninst✝³ : NormedField 𝕜\ninst✝² : NormedDivisionRing R\ninst✝¹ : Algebra 𝕜 R\ninst✝ : CompleteSpace R\nf : ContinuousMap X R\n⊢ Eq (spectrum 𝕜 f) (Set.preimage (⇑(algebraMap 𝕜 R)) (Set.range ⇑f))","decl":"theorem spectrum_eq_preimage_range (f : C(X, R)) :\n    spectrum 𝕜 f = algebraMap _ _ ⁻¹' Set.range f := by\n  ext x\n  simp only [spectrum.mem_iff, isUnit_iff_forall_ne_zero, not_forall, sub_apply,\n    algebraMap_apply, mul_one, Classical.not_not, Set.mem_range,\n    sub_eq_zero, @eq_comm _ (x • 1 : R) _, Set.mem_preimage, Algebra.algebraMap_eq_smul_one,\n    smul_apply, one_apply]\n\n"}
{"name":"ContinuousMap.spectrum_eq_range","module":"Mathlib.Topology.ContinuousMap.Units","initialProofState":"X : Type u_1\n𝕜 : Type u_4\ninst✝² : TopologicalSpace X\ninst✝¹ : NormedField 𝕜\ninst✝ : CompleteSpace 𝕜\nf : ContinuousMap X 𝕜\n⊢ Eq (spectrum 𝕜 f) (Set.range ⇑f)","decl":"theorem spectrum_eq_range [CompleteSpace 𝕜] (f : C(X, 𝕜)) : spectrum 𝕜 f = Set.range f := by\n  rw [spectrum_eq_preimage_range, Algebra.id.map_eq_id]\n  exact Set.preimage_id\n\n"}
