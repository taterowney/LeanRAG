{"name":"SSet.StrictSegal.quasicategory","module":"Mathlib.AlgebraicTopology.Quasicategory.StrictSegal","initialProofState":"X : SSet\ninst✝ : X.StrictSegal\n⊢ X.Quasicategory","decl":"/-- Any `StrictSegal` simplicial set is a `Quasicategory`. -/\ninstance quasicategory {X : SSet.{u}} [StrictSegal X] : Quasicategory X := by\n  apply quasicategory_of_filler X\n  intro n i σ₀ h₀ hₙ\n  use spineToSimplex <| Path.map (horn.spineId i h₀ hₙ) σ₀\n  intro j hj\n  apply spineInjective\n  ext k\n  dsimp only [spineEquiv, spine_arrow, Function.comp_apply, Equiv.coe_fn_mk]\n  rw [← types_comp_apply (σ₀.app _) (X.map _), ← σ₀.naturality]\n  let ksucc := k.succ.castSucc\n  obtain hlt | hgt | heq : ksucc < j ∨ j < ksucc ∨ j = ksucc := by omega\n  · rw [← spine_arrow, spine_δ_arrow_lt _ hlt]\n    dsimp only [Path.map, spine_arrow, Fin.coe_eq_castSucc]\n    apply congr_arg\n    simp only [horn, horn.spineId, stdSimplex, uliftFunctor, Functor.comp_obj,\n      yoneda_obj_obj, whiskering_obj_obj_map, uliftFunctor_map, yoneda_obj_map,\n      stdSimplex.objEquiv, Equiv.ulift, Equiv.coe_fn_symm_mk,\n      Quiver.Hom.unop_op, horn.face_coe, Subtype.mk.injEq]\n    rw [mkOfSucc_δ_lt hlt]\n    rfl\n  · rw [← spine_arrow, spine_δ_arrow_gt _ hgt]\n    dsimp only [Path.map, spine_arrow, Fin.coe_eq_castSucc]\n    apply congr_arg\n    simp only [horn, horn.spineId, stdSimplex, uliftFunctor, Functor.comp_obj,\n      yoneda_obj_obj, whiskering_obj_obj_map, uliftFunctor_map, yoneda_obj_map,\n      stdSimplex.objEquiv, Equiv.ulift, Equiv.coe_fn_symm_mk,\n      Quiver.Hom.unop_op, horn.face_coe, Subtype.mk.injEq]\n    rw [mkOfSucc_δ_gt hgt]\n    rfl\n  · /- The only inner horn of `Δ[2]` does not contain the diagonal edge. -/\n    have hn0 : n ≠ 0 := by\n      rintro rfl\n      obtain rfl : k = 0 := by omega\n      fin_cases i <;> contradiction\n    /- We construct the triangle in the standard simplex as a 2-simplex in\n    the horn. While the triangle is not contained in the inner horn `Λ[2, 1]`,\n    we can inhabit `Λ[n + 2, i] _[2]` by induction on `n`. -/\n    let triangle : Λ[n + 2, i] _[2] := by\n      cases n with\n      | zero => contradiction\n      | succ _ => exact horn.primitiveTriangle i h₀ hₙ k (by omega)\n    /- The interval spanning from `k` to `k + 2` is equivalently the spine\n    of the triangle with vertices `k`, `k + 1`, and `k + 2`. -/\n    have hi : ((horn.spineId i h₀ hₙ).map σ₀).interval k 2 (by omega) =\n        X.spine 2 (σ₀.app _ triangle) := by\n      ext m\n      dsimp [spine_arrow, Path.interval, Path.map]\n      rw [← types_comp_apply (σ₀.app _) (X.map _), ← σ₀.naturality]\n      apply congr_arg\n      simp only [horn, stdSimplex, uliftFunctor, Functor.comp_obj,\n        whiskering_obj_obj_obj, yoneda_obj_obj, uliftFunctor_obj, ne_eq,\n        whiskering_obj_obj_map, uliftFunctor_map, yoneda_obj_map, len_mk,\n        Nat.reduceAdd, Quiver.Hom.unop_op]\n      cases n with\n      | zero => contradiction\n      | succ _ => ext x; fin_cases x <;> fin_cases m <;> rfl\n    rw [← spine_arrow, spine_δ_arrow_eq _ heq, hi]\n    simp only [spineToDiagonal, diagonal, spineToSimplex_spine]\n    rw [← types_comp_apply (σ₀.app _) (X.map _), ← σ₀.naturality, types_comp_apply]\n    apply congr_arg\n    simp only [horn, stdSimplex, uliftFunctor, Functor.comp_obj,\n      whiskering_obj_obj_obj, yoneda_obj_obj, uliftFunctor_obj,\n      uliftFunctor_map, whiskering_obj_obj_map, yoneda_obj_map, horn.face_coe,\n      len_mk, Nat.reduceAdd, Quiver.Hom.unop_op, Subtype.mk.injEq, ULift.up_inj]\n    ext z\n    cases n with\n    | zero => contradiction\n    | succ _ =>\n      fin_cases z <;>\n      · simp only [stdSimplex.objEquiv, uliftFunctor_map, yoneda_obj_map,\n          Quiver.Hom.unop_op, Equiv.ulift_symm_down]\n        rw [mkOfSucc_δ_eq heq]\n        rfl\n\n"}
