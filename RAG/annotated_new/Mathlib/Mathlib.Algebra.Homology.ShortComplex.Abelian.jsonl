{"name":"CategoryTheory.ShortComplex.abelianImageToKernel_comp_kernel_ι","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.abelianImageToKernel (CategoryTheory.Limits.kernel.ι S.g)) (CategoryTheory.Abelian.image.ι S.f)","decl":"@[reassoc (attr := simp)]\nlemma abelianImageToKernel_comp_kernel_ι :\n    S.abelianImageToKernel ≫ kernel.ι S.g = Abelian.image.ι S.f :=\n  kernel.lift_ι _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.abelianImageToKernel_comp_kernel_ι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nZ : C\nh : Quiver.Hom S.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.abelianImageToKernel (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι S.g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.image.ι S.f) h)","decl":"@[reassoc (attr := simp)]\nlemma abelianImageToKernel_comp_kernel_ι :\n    S.abelianImageToKernel ≫ kernel.ι S.g = Abelian.image.ι S.f :=\n  kernel.lift_ι _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.instMonoAbelianImageToKernel","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ CategoryTheory.Mono S.abelianImageToKernel","decl":"instance : Mono S.abelianImageToKernel :=\n  mono_of_mono_fac S.abelianImageToKernel_comp_kernel_ι\n\n"}
{"name":"CategoryTheory.ShortComplex.abelianImageToKernel_comp_kernel_ι_comp_cokernel_π","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.abelianImageToKernel (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι S.g) (CategoryTheory.Limits.cokernel.π S.f))) 0","decl":"@[reassoc]\nlemma abelianImageToKernel_comp_kernel_ι_comp_cokernel_π :\n    S.abelianImageToKernel ≫ kernel.ι S.g ≫ cokernel.π S.f = 0 := by\n  simp\n\n"}
{"name":"CategoryTheory.ShortComplex.abelianImageToKernel_comp_kernel_ι_comp_cokernel_π_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.cokernel S.f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.abelianImageToKernel (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι S.g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.π S.f) h))) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma abelianImageToKernel_comp_kernel_ι_comp_cokernel_π :\n    S.abelianImageToKernel ≫ kernel.ι S.g ≫ cokernel.π S.f = 0 := by\n  simp\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian_π","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian S).π (CategoryTheory.Limits.cokernel.π (CategoryTheory.Limits.kernel.ι (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι S.g) (CategoryTheory.Limits.cokernel.π S.f))))","decl":"/-- The canonical `LeftHomologyData` of a short complex `S` in an abelian category, for\nwhich the `H` field is `Abelian.coimage (kernel.ι S.g ≫ cokernel.π S.f)`. -/\n@[simps]\nnoncomputable def ofAbelian : S.LeftHomologyData := by\n  let γ := kernel.ι S.g ≫ cokernel.π S.f\n  let f' := kernel.lift S.g S.f S.zero\n  have hf' : f' = kernel.lift γ f' (by simp [γ, f']) ≫ kernel.ι γ := by rw [kernel.lift_ι]\n  have wπ : f' ≫ cokernel.π (kernel.ι γ) = 0 := by\n    rw [hf']\n    simp only [assoc, cokernel.condition, comp_zero]\n  let e : Abelian.image S.f ≅ kernel γ :=\n    IsLimit.conePointUniqueUpToIso S.abelianImageToKernelIsKernel (limit.isLimit _)\n  have he : e.hom ≫ kernel.ι γ = S.abelianImageToKernel :=\n    IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingParallelPair.zero\n  have fac : f' = Abelian.factorThruImage S.f ≫ e.hom ≫ kernel.ι γ := by\n    rw [hf', he]\n    simp only [γ, f', kernel.lift_ι, abelianImageToKernel, ← cancel_mono (kernel.ι S.g),\n      assoc]\n  have hπ : IsColimit (CokernelCofork.ofπ _ wπ) :=\n    CokernelCofork.IsColimit.ofπ _ _\n    (fun x hx => cokernel.desc _ x (by\n      simpa only [← cancel_epi e.hom, ← cancel_epi (Abelian.factorThruImage S.f),\n        comp_zero, fac, assoc] using hx))\n    (fun x hx => cokernel.π_desc _ _ _)\n    (fun x hx b hb => coequalizer.hom_ext (by simp only [hb, cokernel.π_desc]))\n  exact\n    { K := kernel S.g,\n      H := Abelian.coimage (kernel.ι S.g ≫ cokernel.π S.f)\n      i := kernel.ι _,\n      π := cokernel.π _\n      wi := kernel.condition _\n      hi := kernelIsKernel _\n      wπ := wπ\n      hπ := hπ }\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian_H","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian S).H (CategoryTheory.Abelian.coimage (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι S.g) (CategoryTheory.Limits.cokernel.π S.f)))","decl":"/-- The canonical `LeftHomologyData` of a short complex `S` in an abelian category, for\nwhich the `H` field is `Abelian.coimage (kernel.ι S.g ≫ cokernel.π S.f)`. -/\n@[simps]\nnoncomputable def ofAbelian : S.LeftHomologyData := by\n  let γ := kernel.ι S.g ≫ cokernel.π S.f\n  let f' := kernel.lift S.g S.f S.zero\n  have hf' : f' = kernel.lift γ f' (by simp [γ, f']) ≫ kernel.ι γ := by rw [kernel.lift_ι]\n  have wπ : f' ≫ cokernel.π (kernel.ι γ) = 0 := by\n    rw [hf']\n    simp only [assoc, cokernel.condition, comp_zero]\n  let e : Abelian.image S.f ≅ kernel γ :=\n    IsLimit.conePointUniqueUpToIso S.abelianImageToKernelIsKernel (limit.isLimit _)\n  have he : e.hom ≫ kernel.ι γ = S.abelianImageToKernel :=\n    IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingParallelPair.zero\n  have fac : f' = Abelian.factorThruImage S.f ≫ e.hom ≫ kernel.ι γ := by\n    rw [hf', he]\n    simp only [γ, f', kernel.lift_ι, abelianImageToKernel, ← cancel_mono (kernel.ι S.g),\n      assoc]\n  have hπ : IsColimit (CokernelCofork.ofπ _ wπ) :=\n    CokernelCofork.IsColimit.ofπ _ _\n    (fun x hx => cokernel.desc _ x (by\n      simpa only [← cancel_epi e.hom, ← cancel_epi (Abelian.factorThruImage S.f),\n        comp_zero, fac, assoc] using hx))\n    (fun x hx => cokernel.π_desc _ _ _)\n    (fun x hx b hb => coequalizer.hom_ext (by simp only [hb, cokernel.π_desc]))\n  exact\n    { K := kernel S.g,\n      H := Abelian.coimage (kernel.ι S.g ≫ cokernel.π S.f)\n      i := kernel.ι _,\n      π := cokernel.π _\n      wi := kernel.condition _\n      hi := kernelIsKernel _\n      wπ := wπ\n      hπ := hπ }\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian_i","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian S).i (CategoryTheory.Limits.kernel.ι S.g)","decl":"/-- The canonical `LeftHomologyData` of a short complex `S` in an abelian category, for\nwhich the `H` field is `Abelian.coimage (kernel.ι S.g ≫ cokernel.π S.f)`. -/\n@[simps]\nnoncomputable def ofAbelian : S.LeftHomologyData := by\n  let γ := kernel.ι S.g ≫ cokernel.π S.f\n  let f' := kernel.lift S.g S.f S.zero\n  have hf' : f' = kernel.lift γ f' (by simp [γ, f']) ≫ kernel.ι γ := by rw [kernel.lift_ι]\n  have wπ : f' ≫ cokernel.π (kernel.ι γ) = 0 := by\n    rw [hf']\n    simp only [assoc, cokernel.condition, comp_zero]\n  let e : Abelian.image S.f ≅ kernel γ :=\n    IsLimit.conePointUniqueUpToIso S.abelianImageToKernelIsKernel (limit.isLimit _)\n  have he : e.hom ≫ kernel.ι γ = S.abelianImageToKernel :=\n    IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingParallelPair.zero\n  have fac : f' = Abelian.factorThruImage S.f ≫ e.hom ≫ kernel.ι γ := by\n    rw [hf', he]\n    simp only [γ, f', kernel.lift_ι, abelianImageToKernel, ← cancel_mono (kernel.ι S.g),\n      assoc]\n  have hπ : IsColimit (CokernelCofork.ofπ _ wπ) :=\n    CokernelCofork.IsColimit.ofπ _ _\n    (fun x hx => cokernel.desc _ x (by\n      simpa only [← cancel_epi e.hom, ← cancel_epi (Abelian.factorThruImage S.f),\n        comp_zero, fac, assoc] using hx))\n    (fun x hx => cokernel.π_desc _ _ _)\n    (fun x hx b hb => coequalizer.hom_ext (by simp only [hb, cokernel.π_desc]))\n  exact\n    { K := kernel S.g,\n      H := Abelian.coimage (kernel.ι S.g ≫ cokernel.π S.f)\n      i := kernel.ι _,\n      π := cokernel.π _\n      wi := kernel.condition _\n      hi := kernelIsKernel _\n      wπ := wπ\n      hπ := hπ }\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian_K","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian S).K (CategoryTheory.Limits.kernel S.g)","decl":"/-- The canonical `LeftHomologyData` of a short complex `S` in an abelian category, for\nwhich the `H` field is `Abelian.coimage (kernel.ι S.g ≫ cokernel.π S.f)`. -/\n@[simps]\nnoncomputable def ofAbelian : S.LeftHomologyData := by\n  let γ := kernel.ι S.g ≫ cokernel.π S.f\n  let f' := kernel.lift S.g S.f S.zero\n  have hf' : f' = kernel.lift γ f' (by simp [γ, f']) ≫ kernel.ι γ := by rw [kernel.lift_ι]\n  have wπ : f' ≫ cokernel.π (kernel.ι γ) = 0 := by\n    rw [hf']\n    simp only [assoc, cokernel.condition, comp_zero]\n  let e : Abelian.image S.f ≅ kernel γ :=\n    IsLimit.conePointUniqueUpToIso S.abelianImageToKernelIsKernel (limit.isLimit _)\n  have he : e.hom ≫ kernel.ι γ = S.abelianImageToKernel :=\n    IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingParallelPair.zero\n  have fac : f' = Abelian.factorThruImage S.f ≫ e.hom ≫ kernel.ι γ := by\n    rw [hf', he]\n    simp only [γ, f', kernel.lift_ι, abelianImageToKernel, ← cancel_mono (kernel.ι S.g),\n      assoc]\n  have hπ : IsColimit (CokernelCofork.ofπ _ wπ) :=\n    CokernelCofork.IsColimit.ofπ _ _\n    (fun x hx => cokernel.desc _ x (by\n      simpa only [← cancel_epi e.hom, ← cancel_epi (Abelian.factorThruImage S.f),\n        comp_zero, fac, assoc] using hx))\n    (fun x hx => cokernel.π_desc _ _ _)\n    (fun x hx b hb => coequalizer.hom_ext (by simp only [hb, cokernel.π_desc]))\n  exact\n    { K := kernel S.g,\n      H := Abelian.coimage (kernel.ι S.g ≫ cokernel.π S.f)\n      i := kernel.ι _,\n      π := cokernel.π _\n      wi := kernel.condition _\n      hi := kernelIsKernel _\n      wπ := wπ\n      hπ := hπ }\n\n"}
{"name":"CategoryTheory.ShortComplex.cokernel_π_comp_cokernelToAbelianCoimage","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.π S.f) S.cokernelToAbelianCoimage) (CategoryTheory.Abelian.coimage.π S.g)","decl":"@[reassoc (attr := simp)]\nlemma cokernel_π_comp_cokernelToAbelianCoimage :\n    cokernel.π S.f ≫ S.cokernelToAbelianCoimage = Abelian.coimage.π S.g :=\n  cokernel.π_desc _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.cokernel_π_comp_cokernelToAbelianCoimage_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\nZ : C\nh : Quiver.Hom (CategoryTheory.Abelian.coimage S.g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.π S.f) (CategoryTheory.CategoryStruct.comp S.cokernelToAbelianCoimage h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.coimage.π S.g) h)","decl":"@[reassoc (attr := simp)]\nlemma cokernel_π_comp_cokernelToAbelianCoimage :\n    cokernel.π S.f ≫ S.cokernelToAbelianCoimage = Abelian.coimage.π S.g :=\n  cokernel.π_desc _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.instEpiCokernelToAbelianCoimage","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ CategoryTheory.Epi S.cokernelToAbelianCoimage","decl":"instance : Epi S.cokernelToAbelianCoimage :=\n  epi_of_epi_fac S.cokernel_π_comp_cokernelToAbelianCoimage\n\n"}
{"name":"CategoryTheory.ShortComplex.kernel_ι_comp_cokernel_π_comp_cokernelToAbelianCoimage","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι S.g) (CategoryTheory.Limits.cokernel.π S.f)) S.cokernelToAbelianCoimage) 0","decl":"lemma kernel_ι_comp_cokernel_π_comp_cokernelToAbelianCoimage :\n    (kernel.ι S.g ≫ cokernel.π S.f) ≫ S.cokernelToAbelianCoimage = 0 := by simp\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofAbelian_H","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofAbelian S).H (CategoryTheory.Abelian.image (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι S.g) (CategoryTheory.Limits.cokernel.π S.f)))","decl":"/-- The canonical `RightHomologyData` of a short complex `S` in an abelian category, for\nwhich the `H` field is `Abelian.image (kernel.ι S.g ≫ cokernel.π S.f)`. -/\n@[simps]\nnoncomputable def ofAbelian : S.RightHomologyData := by\n  let γ := kernel.ι S.g ≫ cokernel.π S.f\n  let g' := cokernel.desc S.f S.g S.zero\n  have hg' : g' = cokernel.π γ ≫ cokernel.desc γ g' (by simp [γ, g']) := by rw [cokernel.π_desc]\n  have wι : kernel.ι (cokernel.π γ) ≫ g' = 0 := by rw [hg', kernel.condition_assoc, zero_comp]\n  let e : cokernel γ ≅ Abelian.coimage S.g :=\n    IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) S.cokernelToAbelianCoimageIsCokernel\n  have he : cokernel.π γ ≫ e.hom = S.cokernelToAbelianCoimage :=\n    IsColimit.comp_coconePointUniqueUpToIso_hom _ _ WalkingParallelPair.one\n  have fac : g' = cokernel.π γ ≫ e.hom ≫ Abelian.factorThruCoimage S.g := by\n    rw [hg', reassoc_of% he]\n    simp only [γ, g', cokernel.π_desc, ← cancel_epi (cokernel.π S.f),\n      cokernel_π_comp_cokernelToAbelianCoimage_assoc]\n  have hι : IsLimit (KernelFork.ofι _ wι) :=\n    KernelFork.IsLimit.ofι _ _\n      (fun x hx => kernel.lift _ x (by\n        simpa only [← cancel_mono e.hom, ← cancel_mono (Abelian.factorThruCoimage S.g), assoc,\n          zero_comp, fac] using hx))\n      (fun x hx => kernel.lift_ι _ _ _)\n      (fun x hx b hb => equalizer.hom_ext (by simp only [hb, kernel.lift_ι]))\n  exact\n    { Q := cokernel S.f,\n      H := Abelian.image (kernel.ι S.g ≫ cokernel.π S.f)\n      p := cokernel.π _\n      ι := kernel.ι _\n      wp := cokernel.condition _\n      hp := cokernelIsCokernel _\n      wι := wι\n      hι := hι }\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofAbelian_ι","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofAbelian S).ι (CategoryTheory.Limits.kernel.ι (CategoryTheory.Limits.cokernel.π (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι S.g) (CategoryTheory.Limits.cokernel.π S.f))))","decl":"/-- The canonical `RightHomologyData` of a short complex `S` in an abelian category, for\nwhich the `H` field is `Abelian.image (kernel.ι S.g ≫ cokernel.π S.f)`. -/\n@[simps]\nnoncomputable def ofAbelian : S.RightHomologyData := by\n  let γ := kernel.ι S.g ≫ cokernel.π S.f\n  let g' := cokernel.desc S.f S.g S.zero\n  have hg' : g' = cokernel.π γ ≫ cokernel.desc γ g' (by simp [γ, g']) := by rw [cokernel.π_desc]\n  have wι : kernel.ι (cokernel.π γ) ≫ g' = 0 := by rw [hg', kernel.condition_assoc, zero_comp]\n  let e : cokernel γ ≅ Abelian.coimage S.g :=\n    IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) S.cokernelToAbelianCoimageIsCokernel\n  have he : cokernel.π γ ≫ e.hom = S.cokernelToAbelianCoimage :=\n    IsColimit.comp_coconePointUniqueUpToIso_hom _ _ WalkingParallelPair.one\n  have fac : g' = cokernel.π γ ≫ e.hom ≫ Abelian.factorThruCoimage S.g := by\n    rw [hg', reassoc_of% he]\n    simp only [γ, g', cokernel.π_desc, ← cancel_epi (cokernel.π S.f),\n      cokernel_π_comp_cokernelToAbelianCoimage_assoc]\n  have hι : IsLimit (KernelFork.ofι _ wι) :=\n    KernelFork.IsLimit.ofι _ _\n      (fun x hx => kernel.lift _ x (by\n        simpa only [← cancel_mono e.hom, ← cancel_mono (Abelian.factorThruCoimage S.g), assoc,\n          zero_comp, fac] using hx))\n      (fun x hx => kernel.lift_ι _ _ _)\n      (fun x hx b hb => equalizer.hom_ext (by simp only [hb, kernel.lift_ι]))\n  exact\n    { Q := cokernel S.f,\n      H := Abelian.image (kernel.ι S.g ≫ cokernel.π S.f)\n      p := cokernel.π _\n      ι := kernel.ι _\n      wp := cokernel.condition _\n      hp := cokernelIsCokernel _\n      wι := wι\n      hι := hι }\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofAbelian_p","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofAbelian S).p (CategoryTheory.Limits.cokernel.π S.f)","decl":"/-- The canonical `RightHomologyData` of a short complex `S` in an abelian category, for\nwhich the `H` field is `Abelian.image (kernel.ι S.g ≫ cokernel.π S.f)`. -/\n@[simps]\nnoncomputable def ofAbelian : S.RightHomologyData := by\n  let γ := kernel.ι S.g ≫ cokernel.π S.f\n  let g' := cokernel.desc S.f S.g S.zero\n  have hg' : g' = cokernel.π γ ≫ cokernel.desc γ g' (by simp [γ, g']) := by rw [cokernel.π_desc]\n  have wι : kernel.ι (cokernel.π γ) ≫ g' = 0 := by rw [hg', kernel.condition_assoc, zero_comp]\n  let e : cokernel γ ≅ Abelian.coimage S.g :=\n    IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) S.cokernelToAbelianCoimageIsCokernel\n  have he : cokernel.π γ ≫ e.hom = S.cokernelToAbelianCoimage :=\n    IsColimit.comp_coconePointUniqueUpToIso_hom _ _ WalkingParallelPair.one\n  have fac : g' = cokernel.π γ ≫ e.hom ≫ Abelian.factorThruCoimage S.g := by\n    rw [hg', reassoc_of% he]\n    simp only [γ, g', cokernel.π_desc, ← cancel_epi (cokernel.π S.f),\n      cokernel_π_comp_cokernelToAbelianCoimage_assoc]\n  have hι : IsLimit (KernelFork.ofι _ wι) :=\n    KernelFork.IsLimit.ofι _ _\n      (fun x hx => kernel.lift _ x (by\n        simpa only [← cancel_mono e.hom, ← cancel_mono (Abelian.factorThruCoimage S.g), assoc,\n          zero_comp, fac] using hx))\n      (fun x hx => kernel.lift_ι _ _ _)\n      (fun x hx b hb => equalizer.hom_ext (by simp only [hb, kernel.lift_ι]))\n  exact\n    { Q := cokernel S.f,\n      H := Abelian.image (kernel.ι S.g ≫ cokernel.π S.f)\n      p := cokernel.π _\n      ι := kernel.ι _\n      wp := cokernel.condition _\n      hp := cokernelIsCokernel _\n      wι := wι\n      hι := hι }\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.ofAbelian_Q","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex C\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.ofAbelian S).Q (CategoryTheory.Limits.cokernel S.f)","decl":"/-- The canonical `RightHomologyData` of a short complex `S` in an abelian category, for\nwhich the `H` field is `Abelian.image (kernel.ι S.g ≫ cokernel.π S.f)`. -/\n@[simps]\nnoncomputable def ofAbelian : S.RightHomologyData := by\n  let γ := kernel.ι S.g ≫ cokernel.π S.f\n  let g' := cokernel.desc S.f S.g S.zero\n  have hg' : g' = cokernel.π γ ≫ cokernel.desc γ g' (by simp [γ, g']) := by rw [cokernel.π_desc]\n  have wι : kernel.ι (cokernel.π γ) ≫ g' = 0 := by rw [hg', kernel.condition_assoc, zero_comp]\n  let e : cokernel γ ≅ Abelian.coimage S.g :=\n    IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) S.cokernelToAbelianCoimageIsCokernel\n  have he : cokernel.π γ ≫ e.hom = S.cokernelToAbelianCoimage :=\n    IsColimit.comp_coconePointUniqueUpToIso_hom _ _ WalkingParallelPair.one\n  have fac : g' = cokernel.π γ ≫ e.hom ≫ Abelian.factorThruCoimage S.g := by\n    rw [hg', reassoc_of% he]\n    simp only [γ, g', cokernel.π_desc, ← cancel_epi (cokernel.π S.f),\n      cokernel_π_comp_cokernelToAbelianCoimage_assoc]\n  have hι : IsLimit (KernelFork.ofι _ wι) :=\n    KernelFork.IsLimit.ofι _ _\n      (fun x hx => kernel.lift _ x (by\n        simpa only [← cancel_mono e.hom, ← cancel_mono (Abelian.factorThruCoimage S.g), assoc,\n          zero_comp, fac] using hx))\n      (fun x hx => kernel.lift_ι _ _ _)\n      (fun x hx b hb => equalizer.hom_ext (by simp only [hb, kernel.lift_ι]))\n  exact\n    { Q := cokernel S.f,\n      H := Abelian.image (kernel.ι S.g ≫ cokernel.π S.f)\n      p := cokernel.π _\n      ι := kernel.ι _\n      wp := cokernel.condition _\n      hp := cokernelIsCokernel _\n      wι := wι\n      hι := hι }\n\n"}
{"name":"CategoryTheory.categoryWithHomology_of_abelian","module":"Mathlib.Algebra.Homology.ShortComplex.Abelian","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\n⊢ CategoryTheory.CategoryWithHomology C","decl":"instance _root_.CategoryTheory.categoryWithHomology_of_abelian :\n    CategoryWithHomology C where\n  hasHomology S := HasHomology.mk' (HomologyData.ofAbelian S)\n\n"}
