{"name":"Basis.coe_sumCoords_eq_finsum","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\n⊢ Eq ⇑b.sumCoords fun m => finsum fun i => (b.coord i) m","decl":"theorem coe_sumCoords_eq_finsum : (b.sumCoords : M → R) = fun m => ∑ᶠ i, b.coord i m := by\n  ext m\n  simp only [Basis.sumCoords, Basis.coord, Finsupp.lapply_apply, LinearMap.id_coe,\n    LinearEquiv.coe_coe, Function.comp_apply, Finsupp.coe_lsum, LinearMap.coe_comp,\n    finsum_eq_sum _ (b.repr m).finite_support, Finsupp.sum, Finset.finite_toSet_toFinset, id,\n    Finsupp.fun_support_eq]\n\n"}
{"name":"Basis.linearIndependent","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\n⊢ LinearIndependent R ⇑b","decl":"protected theorem linearIndependent : LinearIndependent R b :=\n  fun x y hxy => by\n    rw [← b.repr_linearCombination x, hxy, b.repr_linearCombination y]\n\n"}
{"name":"Basis.ne_zero","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nb : Basis ι R M\ninst✝ : Nontrivial R\ni : ι\n⊢ Ne (b i) 0","decl":"protected theorem ne_zero [Nontrivial R] (i) : b i ≠ 0 :=\n  b.linearIndependent.ne_zero i\n\n"}
{"name":"Basis.prod_repr_inl","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_5\nM' : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nb' : Basis ι' R M'\nx : Prod M M'\ni : ι\n⊢ Eq (((b.prod b').repr x) (Sum.inl i)) ((b.repr x.1) i)","decl":"@[simp]\ntheorem prod_repr_inl (x) (i) : (b.prod b').repr x (Sum.inl i) = b.repr x.1 i :=\n  rfl\n\n"}
{"name":"Basis.prod_repr_inr","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_5\nM' : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nb' : Basis ι' R M'\nx : Prod M M'\ni : ι'\n⊢ Eq (((b.prod b').repr x) (Sum.inr i)) ((b'.repr x.2) i)","decl":"@[simp]\ntheorem prod_repr_inr (x) (i) : (b.prod b').repr x (Sum.inr i) = b'.repr x.2 i :=\n  rfl\n\n"}
{"name":"Basis.prod_apply_inl_fst","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_5\nM' : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nb' : Basis ι' R M'\ni : ι\n⊢ Eq ((b.prod b') (Sum.inl i)).1 (b i)","decl":"theorem prod_apply_inl_fst (i) : (b.prod b' (Sum.inl i)).1 = b i :=\n  b.repr.injective <| by\n    ext j\n    simp only [Basis.prod, Basis.coe_ofRepr, LinearEquiv.symm_trans_apply, LinearEquiv.prod_symm,\n      LinearEquiv.prod_apply, b.repr.apply_symm_apply, LinearEquiv.symm_symm, repr_self,\n      Equiv.toFun_as_coe, Finsupp.fst_sumFinsuppLEquivProdFinsupp]\n    apply Finsupp.single_apply_left Sum.inl_injective\n\n"}
{"name":"Basis.prod_apply_inr_fst","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_5\nM' : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nb' : Basis ι' R M'\ni : ι'\n⊢ Eq ((b.prod b') (Sum.inr i)).1 0","decl":"theorem prod_apply_inr_fst (i) : (b.prod b' (Sum.inr i)).1 = 0 :=\n  b.repr.injective <| by\n    ext i\n    simp only [Basis.prod, Basis.coe_ofRepr, LinearEquiv.symm_trans_apply, LinearEquiv.prod_symm,\n      LinearEquiv.prod_apply, b.repr.apply_symm_apply, LinearEquiv.symm_symm, repr_self,\n      Equiv.toFun_as_coe, Finsupp.fst_sumFinsuppLEquivProdFinsupp, LinearEquiv.map_zero,\n      Finsupp.zero_apply]\n    apply Finsupp.single_eq_of_ne Sum.inr_ne_inl\n\n"}
{"name":"Basis.prod_apply_inl_snd","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_5\nM' : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nb' : Basis ι' R M'\ni : ι\n⊢ Eq ((b.prod b') (Sum.inl i)).2 0","decl":"theorem prod_apply_inl_snd (i) : (b.prod b' (Sum.inl i)).2 = 0 :=\n  b'.repr.injective <| by\n    ext j\n    simp only [Basis.prod, Basis.coe_ofRepr, LinearEquiv.symm_trans_apply, LinearEquiv.prod_symm,\n      LinearEquiv.prod_apply, b'.repr.apply_symm_apply, LinearEquiv.symm_symm, repr_self,\n      Equiv.toFun_as_coe, Finsupp.snd_sumFinsuppLEquivProdFinsupp, LinearEquiv.map_zero,\n      Finsupp.zero_apply]\n    apply Finsupp.single_eq_of_ne Sum.inl_ne_inr\n\n"}
{"name":"Basis.prod_apply_inr_snd","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_5\nM' : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nb' : Basis ι' R M'\ni : ι'\n⊢ Eq ((b.prod b') (Sum.inr i)).2 (b' i)","decl":"theorem prod_apply_inr_snd (i) : (b.prod b' (Sum.inr i)).2 = b' i :=\n  b'.repr.injective <| by\n    ext i\n    simp only [Basis.prod, Basis.coe_ofRepr, LinearEquiv.symm_trans_apply, LinearEquiv.prod_symm,\n      LinearEquiv.prod_apply, b'.repr.apply_symm_apply, LinearEquiv.symm_symm, repr_self,\n      Equiv.toFun_as_coe, Finsupp.snd_sumFinsuppLEquivProdFinsupp]\n    apply Finsupp.single_apply_left Sum.inr_injective\n\n"}
{"name":"Basis.prod_apply","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_5\nM' : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nb' : Basis ι' R M'\ni : Sum ι ι'\n⊢ Eq ((b.prod b') i) (Sum.elim (Function.comp ⇑(LinearMap.inl R M M') ⇑b) (Function.comp ⇑(LinearMap.inr R M M') ⇑b') i)","decl":"@[simp]\ntheorem prod_apply (i) :\n    b.prod b' i = Sum.elim (LinearMap.inl R M M' ∘ b) (LinearMap.inr R M M' ∘ b') i := by\n  ext <;> cases i <;>\n    simp only [prod_apply_inl_fst, Sum.elim_inl, LinearMap.inl_apply, prod_apply_inr_fst,\n      Sum.elim_inr, LinearMap.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, Function.comp]\n\n"}
{"name":"Basis.noZeroSMulDivisors","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : NoZeroDivisors R\nb : Basis ι R M\n⊢ NoZeroSMulDivisors R M","decl":"protected theorem noZeroSMulDivisors [NoZeroDivisors R] (b : Basis ι R M) :\n    NoZeroSMulDivisors R M :=\n  ⟨fun {c x} hcx => by\n    exact or_iff_not_imp_right.mpr fun hx => by\n      rw [← b.linearCombination_repr x, ← LinearMap.map_smul,\n        ← map_zero (linearCombination R b)] at hcx\n      have := b.linearIndependent hcx\n      rw [smul_eq_zero] at this\n      exact this.resolve_right fun hr => hx (b.repr.map_eq_zero_iff.mp hr)⟩\n\n"}
{"name":"Basis.smul_eq_zero","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : NoZeroDivisors R\nb : Basis ι R M\nc : R\nx : M\n⊢ Iff (Eq (HSMul.hSMul c x) 0) (Or (Eq c 0) (Eq x 0))","decl":"protected theorem smul_eq_zero [NoZeroDivisors R] (b : Basis ι R M) {c : R} {x : M} :\n    c • x = 0 ↔ c = 0 ∨ x = 0 :=\n  @smul_eq_zero _ _ _ _ _ b.noZeroSMulDivisors _ _\n\n"}
{"name":"Basis.basis_singleton_iff","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"R : Type u_7\nM : Type u_8\ninst✝⁵ : Ring R\ninst✝⁴ : Nontrivial R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : NoZeroSMulDivisors R M\nι : Type u_9\ninst✝ : Unique ι\n⊢ Iff (Nonempty (Basis ι R M)) (Exists fun x => And (Ne x 0) (∀ (y : M), Exists fun r => Eq (HSMul.hSMul r x) y))","decl":"theorem basis_singleton_iff {R M : Type*} [Ring R] [Nontrivial R] [AddCommGroup M] [Module R M]\n    [NoZeroSMulDivisors R M] (ι : Type*) [Unique ι] :\n    Nonempty (Basis ι R M) ↔ ∃ x ≠ 0, ∀ y : M, ∃ r : R, r • x = y := by\n  constructor\n  · rintro ⟨b⟩\n    refine ⟨b default, b.linearIndependent.ne_zero _, ?_⟩\n    simpa [span_singleton_eq_top_iff, Set.range_unique] using b.span_eq\n  · rintro ⟨x, nz, w⟩\n    refine ⟨ofRepr <| LinearEquiv.symm\n      { toFun := fun f => f default • x\n        invFun := fun y => Finsupp.single default (w y).choose\n        left_inv := fun f => Finsupp.unique_ext ?_\n        right_inv := fun y => ?_\n        map_add' := fun y z => ?_\n        map_smul' := fun c y => ?_ }⟩\n    · simp [Finsupp.add_apply, add_smul]\n    · simp only [Finsupp.coe_smul, Pi.smul_apply, RingHom.id_apply]\n      rw [← smul_assoc]\n    · refine smul_left_injective _ nz ?_\n      simp only [Finsupp.single_eq_same]\n      exact (w (f default • x)).choose_spec\n    · simp only [Finsupp.single_eq_same]\n      exact (w y).choose_spec\n\n"}
{"name":"Basis.mk_repr","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : ι → M\nx : M\nhli : LinearIndependent R v\nhsp : LE.le Top.top (Submodule.span R (Set.range v))\n⊢ Eq ((Basis.mk hli hsp).repr x) (hli.repr ⟨x, ⋯⟩)","decl":"@[simp]\ntheorem mk_repr : (Basis.mk hli hsp).repr x = hli.repr ⟨x, hsp Submodule.mem_top⟩ :=\n  rfl\n\n"}
{"name":"Basis.mk_apply","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : ι → M\nhli : LinearIndependent R v\nhsp : LE.le Top.top (Submodule.span R (Set.range v))\ni : ι\n⊢ Eq ((Basis.mk hli hsp) i) (v i)","decl":"theorem mk_apply (i : ι) : Basis.mk hli hsp i = v i :=\n  show Finsupp.linearCombination _ v _ = v i by simp\n\n"}
{"name":"Basis.coe_mk","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : ι → M\nhli : LinearIndependent R v\nhsp : LE.le Top.top (Submodule.span R (Set.range v))\n⊢ Eq (⇑(Basis.mk hli hsp)) v","decl":"@[simp]\ntheorem coe_mk : ⇑(Basis.mk hli hsp) = v :=\n  funext (mk_apply _ _)\n\n"}
{"name":"Basis.mk_coord_apply_eq","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : ι → M\nhli : LinearIndependent R v\nhsp : LE.le Top.top (Submodule.span R (Set.range v))\ni : ι\n⊢ Eq (((Basis.mk hli hsp).coord i) (v i)) 1","decl":"/-- Given a basis, the `i`th element of the dual basis evaluates to 1 on the `i`th element of the\nbasis. -/\ntheorem mk_coord_apply_eq (i : ι) : (Basis.mk hli hsp).coord i (v i) = 1 :=\n  show hli.repr ⟨v i, Submodule.subset_span (mem_range_self i)⟩ i = 1 by simp [hli.repr_eq_single i]\n\n"}
{"name":"Basis.mk_coord_apply_ne","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : ι → M\nhli : LinearIndependent R v\nhsp : LE.le Top.top (Submodule.span R (Set.range v))\ni j : ι\nh : Ne j i\n⊢ Eq (((Basis.mk hli hsp).coord i) (v j)) 0","decl":"/-- Given a basis, the `i`th element of the dual basis evaluates to 0 on the `j`th element of the\nbasis if `j ≠ i`. -/\ntheorem mk_coord_apply_ne {i j : ι} (h : j ≠ i) : (Basis.mk hli hsp).coord i (v j) = 0 :=\n  show hli.repr ⟨v j, Submodule.subset_span (mem_range_self j)⟩ i = 0 by\n    simp [hli.repr_eq_single j, h]\n\n"}
{"name":"Basis.mk_coord_apply","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nv : ι → M\nhli : LinearIndependent R v\nhsp : LE.le Top.top (Submodule.span R (Set.range v))\ninst✝ : DecidableEq ι\ni j : ι\n⊢ Eq (((Basis.mk hli hsp).coord i) (v j)) (ite (Eq j i) 1 0)","decl":"/-- Given a basis, the `i`th element of the dual basis evaluates to the Kronecker delta on the\n`j`th element of the basis. -/\ntheorem mk_coord_apply [DecidableEq ι] {i j : ι} :\n    (Basis.mk hli hsp).coord i (v j) = if j = i then 1 else 0 := by\n  rcases eq_or_ne j i with h | h\n  · simp only [h, if_true, eq_self_iff_true, mk_coord_apply_eq i]\n  · simp only [h, if_false, mk_coord_apply_ne h]\n\n"}
{"name":"Basis.span_apply","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : ι → M\nhli : LinearIndependent R v\ni : ι\n⊢ Eq (↑((Basis.span hli) i)) (v i)","decl":"protected theorem span_apply (i : ι) : (Basis.span hli i : M) = v i :=\n  congr_arg ((↑) : span R (range v) → M) <| Basis.mk_apply _ _ _\n\n"}
{"name":"Basis.groupSMul_span_eq_top","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nG : Type u_7\ninst✝³ : Group G\ninst✝² : DistribMulAction G R\ninst✝¹ : DistribMulAction G M\ninst✝ : IsScalarTower G R M\nv : ι → M\nhv : Eq (Submodule.span R (Set.range v)) Top.top\nw : ι → G\n⊢ Eq (Submodule.span R (Set.range (HSMul.hSMul w v))) Top.top","decl":"theorem groupSMul_span_eq_top {G : Type*} [Group G] [DistribMulAction G R] [DistribMulAction G M]\n    [IsScalarTower G R M] {v : ι → M} (hv : Submodule.span R (Set.range v) = ⊤) {w : ι → G} :\n    Submodule.span R (Set.range (w • v)) = ⊤ := by\n  rw [eq_top_iff]\n  intro j hj\n  rw [← hv] at hj\n  rw [Submodule.mem_span] at hj ⊢\n  refine fun p hp => hj p fun u hu => ?_\n  obtain ⟨i, rfl⟩ := hu\n  have : ((w i)⁻¹ • (1 : R)) • w i • v i ∈ p := p.smul_mem ((w i)⁻¹ • (1 : R)) (hp ⟨i, rfl⟩)\n  rwa [smul_one_smul, inv_smul_smul] at this\n\n"}
{"name":"Basis.groupSMul_apply","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nG : Type u_7\ninst✝⁴ : Group G\ninst✝³ : DistribMulAction G R\ninst✝² : DistribMulAction G M\ninst✝¹ : IsScalarTower G R M\ninst✝ : SMulCommClass G R M\nv : Basis ι R M\nw : ι → G\ni : ι\n⊢ Eq ((v.groupSMul w) i) (HSMul.hSMul w (⇑v) i)","decl":"theorem groupSMul_apply {G : Type*} [Group G] [DistribMulAction G R] [DistribMulAction G M]\n    [IsScalarTower G R M] [SMulCommClass G R M] {v : Basis ι R M} {w : ι → G} (i : ι) :\n    v.groupSMul w i = (w • (v : ι → M)) i :=\n  mk_apply (LinearIndependent.group_smul v.linearIndependent w)\n    (groupSMul_span_eq_top v.span_eq).ge i\n\n"}
{"name":"Basis.units_smul_span_eq_top","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : ι → M\nhv : Eq (Submodule.span R (Set.range v)) Top.top\nw : ι → Units R\n⊢ Eq (Submodule.span R (Set.range (HSMul.hSMul w v))) Top.top","decl":"theorem units_smul_span_eq_top {v : ι → M} (hv : Submodule.span R (Set.range v) = ⊤) {w : ι → Rˣ} :\n    Submodule.span R (Set.range (w • v)) = ⊤ :=\n  groupSMul_span_eq_top hv\n\n"}
{"name":"Basis.unitsSMul_apply","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : Basis ι R M\nw : ι → Units R\ni : ι\n⊢ Eq ((v.unitsSMul w) i) (HSMul.hSMul (w i) (v i))","decl":"theorem unitsSMul_apply {v : Basis ι R M} {w : ι → Rˣ} (i : ι) : unitsSMul v w i = w i • v i :=\n  mk_apply (LinearIndependent.units_smul v.linearIndependent w)\n    (units_smul_span_eq_top v.span_eq).ge i\n\n"}
{"name":"Basis.coord_unitsSMul","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR₂ : Type u_4\nM : Type u_5\ninst✝² : AddCommMonoid M\ninst✝¹ : CommSemiring R₂\ninst✝ : Module R₂ M\ne : Basis ι R₂ M\nw : ι → Units R₂\ni : ι\n⊢ Eq ((e.unitsSMul w).coord i) (HSMul.hSMul (Inv.inv (w i)) (e.coord i))","decl":"@[simp]\ntheorem coord_unitsSMul (e : Basis ι R₂ M) (w : ι → R₂ˣ) (i : ι) :\n    (unitsSMul e w).coord i = (w i)⁻¹ • e.coord i := by\n  classical\n    apply e.ext\n    intro j\n    trans ((unitsSMul e w).coord i) ((w j)⁻¹ • (unitsSMul e w) j)\n    · congr\n      simp [Basis.unitsSMul, ← mul_smul]\n    simp only [Basis.coord_apply, LinearMap.smul_apply, Basis.repr_self, Units.smul_def,\n      map_smul, Finsupp.single_apply]\n    split_ifs with h <;> simp [h]\n\n"}
{"name":"Basis.repr_unitsSMul","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR₂ : Type u_4\nM : Type u_5\ninst✝² : AddCommMonoid M\ninst✝¹ : CommSemiring R₂\ninst✝ : Module R₂ M\ne : Basis ι R₂ M\nw : ι → Units R₂\nv : M\ni : ι\n⊢ Eq (((e.unitsSMul w).repr v) i) (HSMul.hSMul (Inv.inv (w i)) ((e.repr v) i))","decl":"@[simp]\ntheorem repr_unitsSMul (e : Basis ι R₂ M) (w : ι → R₂ˣ) (v : M) (i : ι) :\n    (e.unitsSMul w).repr v i = (w i)⁻¹ • e.repr v i :=\n  congr_arg (fun f : M →ₗ[R₂] R₂ => f v) (e.coord_unitsSMul w i)\n\n"}
{"name":"Basis.isUnitSMul_apply","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nv : Basis ι R M\nw : ι → R\nhw : ∀ (i : ι), IsUnit (w i)\ni : ι\n⊢ Eq ((v.isUnitSMul hw) i) (HSMul.hSMul (w i) (v i))","decl":"theorem isUnitSMul_apply {v : Basis ι R M} {w : ι → R} (hw : ∀ i, IsUnit (w i)) (i : ι) :\n    v.isUnitSMul hw i = w i • v i :=\n  unitsSMul_apply i\n\n"}
{"name":"Basis.repr_isUnitSMul","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR₂ : Type u_4\nM : Type u_5\ninst✝² : AddCommMonoid M\ninst✝¹ : CommSemiring R₂\ninst✝ : Module R₂ M\nv : Basis ι R₂ M\nw : ι → R₂\nhw : ∀ (i : ι), IsUnit (w i)\nx : M\ni : ι\n⊢ Eq (((v.isUnitSMul hw).repr x) i) (HSMul.hSMul (Inv.inv ⋯.unit) ((v.repr x) i))","decl":"theorem repr_isUnitSMul {v : Basis ι R₂ M} {w : ι → R₂} (hw : ∀ i, IsUnit (w i)) (x : M) (i : ι) :\n    (v.isUnitSMul hw).repr x i = (hw i).unit⁻¹ • v.repr x i :=\n  repr_unitsSMul _ _ _ _\n\n"}
{"name":"Basis.maximal","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial R\nb : Basis ι R M\n⊢ ⋯.Maximal","decl":"/-- Any basis is a maximal linear independent set.\n-/\ntheorem maximal [Nontrivial R] (b : Basis ι R M) : b.linearIndependent.Maximal := fun w hi h => by\n  -- If `w` is strictly bigger than `range b`,\n  apply le_antisymm h\n  -- then choose some `x ∈ w \\ range b`,\n  intro x p\n  by_contra q\n  -- and write it in terms of the basis.\n  have e := b.linearCombination_repr x\n  -- This then expresses `x` as a linear combination\n  -- of elements of `w` which are in the range of `b`,\n  let u : ι ↪ w :=\n    ⟨fun i => ⟨b i, h ⟨i, rfl⟩⟩, fun i i' r =>\n      b.injective (by simpa only [Subtype.mk_eq_mk] using r)⟩\n  simp_rw [Finsupp.linearCombination_apply] at e\n  change ((b.repr x).sum fun (i : ι) (a : R) ↦ a • (u i : M)) = ((⟨x, p⟩ : w) : M) at e\n  rw [← Finsupp.sum_embDomain (f := u) (g := fun x r ↦ r • (x : M)),\n      ← Finsupp.linearCombination_apply] at e\n  -- Now we can contradict the linear independence of `hi`\n  refine hi.linearCombination_ne_of_not_mem_support _ ?_ e\n  simp only [Finset.mem_map, Finsupp.support_embDomain]\n  rintro ⟨j, -, W⟩\n  simp only [u, Embedding.coeFn_mk, Subtype.mk_eq_mk] at W\n  apply q ⟨j, W⟩\n\n"}
{"name":"Basis.eq_bot_of_rank_eq_zero","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroDivisors R\nb : Basis ι R M\nN : Submodule R M\nrank_eq : ∀ {m : Nat} (v : Fin m → Subtype fun x => Membership.mem N x), LinearIndependent R (Function.comp Subtype.val v) → Eq m 0\n⊢ Eq N Bot.bot","decl":"theorem Basis.eq_bot_of_rank_eq_zero [NoZeroDivisors R] (b : Basis ι R M) (N : Submodule R M)\n    (rank_eq : ∀ {m : ℕ} (v : Fin m → N), LinearIndependent R ((↑) ∘ v : Fin m → M) → m = 0) :\n    N = ⊥ := by\n  rw [Submodule.eq_bot_iff]\n  intro x hx\n  contrapose! rank_eq with x_ne\n  refine ⟨1, fun _ => ⟨x, hx⟩, ?_, one_ne_zero⟩\n  rw [Fintype.linearIndependent_iff]\n  rintro g sum_eq i\n  cases' i with _ hi\n  simp only [Function.const_apply, Fin.default_eq_zero, Submodule.coe_mk, Finset.univ_unique,\n    Function.comp_const, Finset.sum_singleton] at sum_eq\n  convert (b.smul_eq_zero.mp sum_eq).resolve_right x_ne\n\n"}
{"name":"Basis.coe_mkFinCons","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"R : Type u_3\nM : Type u_5\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nN : Submodule R M\ny : M\nb : Basis (Fin n) R (Subtype fun x => Membership.mem N x)\nhli : ∀ (c : R) (x : M), Membership.mem N x → Eq (HAdd.hAdd (HSMul.hSMul c y) x) 0 → Eq c 0\nhsp : ∀ (z : M), Exists fun c => Membership.mem N (HAdd.hAdd z (HSMul.hSMul c y))\n⊢ Eq (⇑(Basis.mkFinCons y b hli hsp)) (Fin.cons y (Function.comp Subtype.val ⇑b))","decl":"@[simp]\ntheorem coe_mkFinCons {n : ℕ} {N : Submodule R M} (y : M) (b : Basis (Fin n) R N)\n    (hli : ∀ (c : R), ∀ x ∈ N, c • y + x = 0 → c = 0) (hsp : ∀ z : M, ∃ c : R, z + c • y ∈ N) :\n    (mkFinCons y b hli hsp : Fin (n + 1) → M) = Fin.cons y ((↑) ∘ b) := by\n  -- Porting note: without `unfold`, Lean can't reuse the proofs included in the definition\n  -- `mkFinCons`\n  unfold mkFinCons\n  exact coe_mk (v := Fin.cons y (N.subtype ∘ b)) _ _\n\n"}
{"name":"Basis.coe_mkFinConsOfLE","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"R : Type u_3\nM : Type u_5\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nN O : Submodule R M\ny : M\nyO : Membership.mem O y\nb : Basis (Fin n) R (Subtype fun x => Membership.mem N x)\nhNO : LE.le N O\nhli : ∀ (c : R) (x : M), Membership.mem N x → Eq (HAdd.hAdd (HSMul.hSMul c y) x) 0 → Eq c 0\nhsp : ∀ (z : M), Membership.mem O z → Exists fun c => Membership.mem N (HAdd.hAdd z (HSMul.hSMul c y))\n⊢ Eq (⇑(Basis.mkFinConsOfLE y yO b hNO hli hsp)) (Fin.cons ⟨y, yO⟩ (Function.comp ⇑(Submodule.inclusion hNO) ⇑b))","decl":"@[simp]\ntheorem coe_mkFinConsOfLE {n : ℕ} {N O : Submodule R M} (y : M) (yO : y ∈ O) (b : Basis (Fin n) R N)\n    (hNO : N ≤ O) (hli : ∀ (c : R), ∀ x ∈ N, c • y + x = 0 → c = 0)\n    (hsp : ∀ z ∈ O, ∃ c : R, z + c • y ∈ N) :\n    (mkFinConsOfLE y yO b hNO hli hsp : Fin (n + 1) → O) =\n      Fin.cons ⟨y, yO⟩ (Submodule.inclusion hNO ∘ b) :=\n  coe_mkFinCons _ _ _ _\n\n"}
{"name":"Basis.finTwoProd_zero","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"R : Type u_7\ninst✝ : Semiring R\n⊢ Eq ((Basis.finTwoProd R) 0) { fst := 1, snd := 0 }","decl":"@[simp]\ntheorem finTwoProd_zero (R : Type*) [Semiring R] : Basis.finTwoProd R 0 = (1, 0) := by\n  simp [Basis.finTwoProd, LinearEquiv.finTwoArrow]\n\n"}
{"name":"Basis.finTwoProd_one","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"R : Type u_7\ninst✝ : Semiring R\n⊢ Eq ((Basis.finTwoProd R) 1) { fst := 0, snd := 1 }","decl":"@[simp]\ntheorem finTwoProd_one (R : Type*) [Semiring R] : Basis.finTwoProd R 1 = (0, 1) := by\n  simp [Basis.finTwoProd, LinearEquiv.finTwoArrow]\n\n"}
{"name":"Basis.coe_finTwoProd_repr","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"R : Type u_7\ninst✝ : Semiring R\nx : Prod R R\n⊢ Eq (⇑((Basis.finTwoProd R).repr x)) (Matrix.vecCons x.1 (Matrix.vecCons x.2 Matrix.vecEmpty))","decl":"@[simp]\ntheorem coe_finTwoProd_repr {R : Type*} [Semiring R] (x : R × R) :\n    ⇑((Basis.finTwoProd R).repr x) = ![x.fst, x.snd] :=\n  rfl\n\n"}
{"name":"Basis.mem_center_iff","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nA : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : NonUnitalNonAssocSemiring A\ninst✝³ : Module R A\ninst✝² : SMulCommClass R A A\ninst✝¹ : SMulCommClass R R A\ninst✝ : IsScalarTower R A A\nb : Basis ι R A\nz : A\n⊢ Iff (Membership.mem (Set.center A) z) (And (∀ (i : ι), Commute (b i) z) (∀ (i j : ι), And (Eq (HMul.hMul z (HMul.hMul (b i) (b j))) (HMul.hMul (HMul.hMul z (b i)) (b j))) (And (Eq (HMul.hMul (HMul.hMul (b i) z) (b j)) (HMul.hMul (b i) (HMul.hMul z (b j)))) (Eq (HMul.hMul (HMul.hMul (b i) (b j)) z) (HMul.hMul (b i) (HMul.hMul (b j) z))))))","decl":"/-- An element of a non-unital-non-associative algebra is in the center exactly when it commutes\nwith the basis elements. -/\nlemma Basis.mem_center_iff {A}\n    [Semiring R] [NonUnitalNonAssocSemiring A]\n    [Module R A] [SMulCommClass R A A] [SMulCommClass R R A] [IsScalarTower R A A]\n    (b : Basis ι R A) {z : A} :\n    z ∈ Set.center A ↔\n      (∀ i, Commute (b i) z) ∧ ∀ i j,\n        z * (b i * b j) = (z * b i) * b j\n          ∧ (b i * z) * b j = b i * (z * b j)\n          ∧ (b i * b j) * z = b i * (b j * z) := by\n  constructor\n  · intro h\n    constructor\n    · intro i\n      apply (h.1 (b i)).symm\n    · intros\n      exact ⟨h.2 _ _, ⟨h.3 _ _, h.4 _ _⟩⟩\n  · intro h\n    rw [center, mem_setOf_eq]\n    constructor\n    case comm =>\n      intro y\n      rw [← b.linearCombination_repr y, linearCombination_apply, sum, Finset.sum_mul,\n          Finset.mul_sum]\n      simp_rw [mul_smul_comm, smul_mul_assoc, (h.1 _).eq]\n    case left_assoc =>\n      intro c d\n      rw [← b.linearCombination_repr c, ← b.linearCombination_repr d, linearCombination_apply,\n          linearCombination_apply, sum, sum, Finset.sum_mul, Finset.mul_sum, Finset.mul_sum,\n          Finset.mul_sum]\n      simp_rw [smul_mul_assoc, Finset.mul_sum, Finset.sum_mul, mul_smul_comm, Finset.mul_sum,\n        Finset.smul_sum, smul_mul_assoc, mul_smul_comm, (h.2 _ _).1,\n        (@SMulCommClass.smul_comm R R A)]\n      rw [Finset.sum_comm]\n    case mid_assoc =>\n      intro c d\n      rw [← b.linearCombination_repr c, ← b.linearCombination_repr d, linearCombination_apply,\n          linearCombination_apply, sum, sum, Finset.sum_mul, Finset.mul_sum, Finset.mul_sum,\n          Finset.mul_sum]\n      simp_rw [smul_mul_assoc, Finset.sum_mul, mul_smul_comm, smul_mul_assoc, (h.2 _ _).2.1]\n    case right_assoc =>\n      intro c d\n      rw [← b.linearCombination_repr c, ← b.linearCombination_repr d, linearCombination_apply,\n          linearCombination_apply, sum, Finsupp.sum, Finset.sum_mul]\n      simp_rw [smul_mul_assoc, Finset.mul_sum, Finset.sum_mul, mul_smul_comm, Finset.mul_sum,\n               Finset.smul_sum, smul_mul_assoc, mul_smul_comm, Finset.sum_mul, smul_mul_assoc,\n               (h.2 _ _).2.2]\n\n"}
{"name":"Basis.restrictScalars_apply","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\nS : Type u_7\ninst✝⁸ : CommRing R\ninst✝⁷ : Ring S\ninst✝⁶ : Nontrivial S\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Algebra R S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : IsScalarTower R S M\ninst✝ : NoZeroSMulDivisors R S\nb : Basis ι S M\ni : ι\n⊢ Eq (↑((Basis.restrictScalars R b) i)) (b i)","decl":"@[simp]\ntheorem Basis.restrictScalars_apply (i : ι) : (b.restrictScalars R i : M) = b i := by\n  simp only [Basis.restrictScalars, Basis.span_apply]\n\n"}
{"name":"Basis.restrictScalars_repr_apply","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\nS : Type u_7\ninst✝⁸ : CommRing R\ninst✝⁷ : Ring S\ninst✝⁶ : Nontrivial S\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Algebra R S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : IsScalarTower R S M\ninst✝ : NoZeroSMulDivisors R S\nb : Basis ι S M\nm : Subtype fun x => Membership.mem (Submodule.span R (Set.range ⇑b)) x\ni : ι\n⊢ Eq ((algebraMap R S) (((Basis.restrictScalars R b).repr m) i)) ((b.repr ↑m) i)","decl":"@[simp]\ntheorem Basis.restrictScalars_repr_apply (m : span R (Set.range b)) (i : ι) :\n    algebraMap R S ((b.restrictScalars R).repr m i) = b.repr m i := by\n  suffices\n    Finsupp.mapRange.linearMap (Algebra.linearMap R S) ∘ₗ (b.restrictScalars R).repr.toLinearMap =\n      ((b.repr : M →ₗ[S] ι →₀ S).restrictScalars R).domRestrict _\n    by exact DFunLike.congr_fun (LinearMap.congr_fun this m) i\n  refine Basis.ext (b.restrictScalars R) fun _ => ?_\n  simp only [LinearMap.coe_comp, LinearEquiv.coe_toLinearMap, Function.comp_apply, map_one,\n    Basis.repr_self, Finsupp.mapRange.linearMap_apply, Finsupp.mapRange_single,\n    Algebra.linearMap_apply, LinearMap.domRestrict_apply, LinearEquiv.coe_coe,\n    Basis.restrictScalars_apply, LinearMap.coe_restrictScalars]\n\n"}
{"name":"Basis.mem_span_iff_repr_mem","module":"Mathlib.LinearAlgebra.Basis.Basic","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_5\nS : Type u_7\ninst✝⁸ : CommRing R\ninst✝⁷ : Ring S\ninst✝⁶ : Nontrivial S\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Algebra R S\ninst✝³ : Module S M\ninst✝² : Module R M\ninst✝¹ : IsScalarTower R S M\ninst✝ : NoZeroSMulDivisors R S\nb : Basis ι S M\nm : M\n⊢ Iff (Membership.mem (Submodule.span R (Set.range ⇑b)) m) (∀ (i : ι), Membership.mem (Set.range ⇑(algebraMap R S)) ((b.repr m) i))","decl":"/-- Let `b` be an `S`-basis of `M`. Then `m : M` lies in the `R`-module spanned by `b` iff all the\ncoordinates of `m` on the basis `b` are in `R` (see `Basis.mem_span` for the case `R = S`). -/\ntheorem Basis.mem_span_iff_repr_mem (m : M) :\n    m ∈ span R (Set.range b) ↔ ∀ i, b.repr m i ∈ Set.range (algebraMap R S) := by\n  refine\n    ⟨fun hm i => ⟨(b.restrictScalars R).repr ⟨m, hm⟩ i, b.restrictScalars_repr_apply R ⟨m, hm⟩ i⟩,\n      fun h => ?_⟩\n  rw [← b.linearCombination_repr m, Finsupp.linearCombination_apply S _]\n  refine sum_mem fun i _ => ?_\n  obtain ⟨_, h⟩ := h i\n  simp_rw [← h, algebraMap_smul]\n  exact smul_mem _ _ (subset_span (Set.mem_range_self i))\n\n"}
