{"name":"LinOrd.instParentProjectionPartialOrderLinearOrderToPartialOrder","module":"Mathlib.Order.Category.LinOrd","initialProofState":"⊢ CategoryTheory.BundledHom.ParentProjection @LinearOrder.toPartialOrder","decl":"instance : BundledHom.ParentProjection @LinearOrder.toPartialOrder :=\n  ⟨⟩\n\n"}
{"name":"LinOrd.coe_of","module":"Mathlib.Order.Category.LinOrd","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ Eq (↑(LinOrd.of α)) α","decl":"@[simp]\ntheorem coe_of (α : Type*) [LinearOrder α] : ↥(of α) = α :=\n  rfl\n\n"}
{"name":"LinOrd.Iso.mk_hom","module":"Mathlib.Order.Category.LinOrd","initialProofState":"α β : LinOrd\ne : OrderIso ↑α ↑β\n⊢ Eq (LinOrd.Iso.mk e).hom ↑e","decl":"/-- Constructs an equivalence between linear orders from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : LinOrd.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : OrderHom _ _)\n  inv := (e.symm : OrderHom _ _)\n  hom_inv_id := by\n    ext x\n    exact e.symm_apply_apply x\n  inv_hom_id := by\n    ext x\n    exact e.apply_symm_apply x\n\n"}
{"name":"LinOrd.Iso.mk_inv","module":"Mathlib.Order.Category.LinOrd","initialProofState":"α β : LinOrd\ne : OrderIso ↑α ↑β\n⊢ Eq (LinOrd.Iso.mk e).inv ↑e.symm","decl":"/-- Constructs an equivalence between linear orders from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : LinOrd.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : OrderHom _ _)\n  inv := (e.symm : OrderHom _ _)\n  hom_inv_id := by\n    ext x\n    exact e.symm_apply_apply x\n  inv_hom_id := by\n    ext x\n    exact e.apply_symm_apply x\n\n"}
{"name":"LinOrd.dual_obj","module":"Mathlib.Order.Category.LinOrd","initialProofState":"X : LinOrd\n⊢ Eq (LinOrd.dual.obj X) (LinOrd.of (OrderDual ↑X))","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : LinOrd ⥤ LinOrd where\n  obj X := of Xᵒᵈ\n  map := OrderHom.dual\n\n"}
{"name":"LinOrd.dual_map","module":"Mathlib.Order.Category.LinOrd","initialProofState":"X✝ Y✝ : LinOrd\na : OrderHom ↑X✝ ↑Y✝\n⊢ Eq (LinOrd.dual.map a) (OrderHom.dual a)","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : LinOrd ⥤ LinOrd where\n  obj X := of Xᵒᵈ\n  map := OrderHom.dual\n\n"}
{"name":"LinOrd.dualEquiv_inverse","module":"Mathlib.Order.Category.LinOrd","initialProofState":"⊢ Eq LinOrd.dualEquiv.inverse LinOrd.dual","decl":"/-- The equivalence between `LinOrd` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : LinOrd ≌ LinOrd where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"LinOrd.dualEquiv_functor","module":"Mathlib.Order.Category.LinOrd","initialProofState":"⊢ Eq LinOrd.dualEquiv.functor LinOrd.dual","decl":"/-- The equivalence between `LinOrd` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : LinOrd ≌ LinOrd where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"linOrd_dual_comp_forget_to_Lat","module":"Mathlib.Order.Category.LinOrd","initialProofState":"⊢ Eq (LinOrd.dual.comp (CategoryTheory.forget₂ LinOrd Lat)) ((CategoryTheory.forget₂ LinOrd Lat).comp Lat.dual)","decl":"theorem linOrd_dual_comp_forget_to_Lat :\n    LinOrd.dual ⋙ forget₂ LinOrd Lat = forget₂ LinOrd Lat ⋙ Lat.dual :=\n  rfl\n"}
