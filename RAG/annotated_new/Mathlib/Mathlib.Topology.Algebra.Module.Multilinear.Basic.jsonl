{"name":"ContinuousMultilinearMap.mk.injEq","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\ntoMultilinearMap✝ : MultilinearMap R M₁ M₂\ncont✝ : Continuous toMultilinearMap✝.toFun\ntoMultilinearMap : MultilinearMap R M₁ M₂\ncont : Continuous toMultilinearMap.toFun\n⊢ Eq (Eq { toMultilinearMap := toMultilinearMap✝, cont := cont✝ } { toMultilinearMap := toMultilinearMap, cont := cont }) (Eq toMultilinearMap✝ toMultilinearMap)","decl":"/-- Continuous multilinear maps over the ring `R`, from `∀ i, M₁ i` to `M₂` where `M₁ i` and `M₂`\nare modules over `R` with a topological structure. In applications, there will be compatibility\nconditions between the algebraic and the topological structures, but this is not needed for the\ndefinition. -/\nstructure ContinuousMultilinearMap (R : Type u) {ι : Type v} (M₁ : ι → Type w₁) (M₂ : Type w₂)\n  [Semiring R] [∀ i, AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [∀ i, Module R (M₁ i)] [Module R M₂]\n  [∀ i, TopologicalSpace (M₁ i)] [TopologicalSpace M₂] extends MultilinearMap R M₁ M₂ where\n  cont : Continuous toFun\n\n"}
{"name":"ContinuousMultilinearMap.mk.inj","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\ntoMultilinearMap✝ : MultilinearMap R M₁ M₂\ncont✝ : Continuous toMultilinearMap✝.toFun\ntoMultilinearMap : MultilinearMap R M₁ M₂\ncont : Continuous toMultilinearMap.toFun\nx✝ : Eq { toMultilinearMap := toMultilinearMap✝, cont := cont✝ } { toMultilinearMap := toMultilinearMap, cont := cont }\n⊢ Eq toMultilinearMap✝ toMultilinearMap","decl":"/-- Continuous multilinear maps over the ring `R`, from `∀ i, M₁ i` to `M₂` where `M₁ i` and `M₂`\nare modules over `R` with a topological structure. In applications, there will be compatibility\nconditions between the algebraic and the topological structures, but this is not needed for the\ndefinition. -/\nstructure ContinuousMultilinearMap (R : Type u) {ι : Type v} (M₁ : ι → Type w₁) (M₂ : Type w₂)\n  [Semiring R] [∀ i, AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [∀ i, Module R (M₁ i)] [Module R M₂]\n  [∀ i, TopologicalSpace (M₁ i)] [TopologicalSpace M₂] extends MultilinearMap R M₁ M₂ where\n  cont : Continuous toFun\n\n"}
{"name":"ContinuousMultilinearMap.mk.sizeOf_spec","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝¹⁰ : Semiring R\ninst✝⁹ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : (i : ι) → Module R (M₁ i)\ninst✝⁶ : Module R M₂\ninst✝⁵ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : SizeOf R\ninst✝² : SizeOf ι\ninst✝¹ : (a : ι) → SizeOf (M₁ a)\ninst✝ : SizeOf M₂\ntoMultilinearMap : MultilinearMap R M₁ M₂\ncont : Continuous toMultilinearMap.toFun\n⊢ Eq (SizeOf.sizeOf { toMultilinearMap := toMultilinearMap, cont := cont }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toMultilinearMap)) (SizeOf.sizeOf cont))","decl":"/-- Continuous multilinear maps over the ring `R`, from `∀ i, M₁ i` to `M₂` where `M₁ i` and `M₂`\nare modules over `R` with a topological structure. In applications, there will be compatibility\nconditions between the algebraic and the topological structures, but this is not needed for the\ndefinition. -/\nstructure ContinuousMultilinearMap (R : Type u) {ι : Type v} (M₁ : ι → Type w₁) (M₂ : Type w₂)\n  [Semiring R] [∀ i, AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [∀ i, Module R (M₁ i)] [Module R M₂]\n  [∀ i, TopologicalSpace (M₁ i)] [TopologicalSpace M₂] extends MultilinearMap R M₁ M₂ where\n  cont : Continuous toFun\n\n"}
{"name":"ContinuousMultilinearMap.cont","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\nself : ContinuousMultilinearMap R M₁ M₂\n⊢ Continuous self.toFun","decl":"/-- Continuous multilinear maps over the ring `R`, from `∀ i, M₁ i` to `M₂` where `M₁ i` and `M₂`\nare modules over `R` with a topological structure. In applications, there will be compatibility\nconditions between the algebraic and the topological structures, but this is not needed for the\ndefinition. -/\nstructure ContinuousMultilinearMap (R : Type u) {ι : Type v} (M₁ : ι → Type w₁) (M₂ : Type w₂)\n  [Semiring R] [∀ i, AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [∀ i, Module R (M₁ i)] [Module R M₂]\n  [∀ i, TopologicalSpace (M₁ i)] [TopologicalSpace M₂] extends MultilinearMap R M₁ M₂ where\n  cont : Continuous toFun\n\n"}
{"name":"ContinuousMultilinearMap.toMultilinearMap_injective","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\n⊢ Function.Injective ContinuousMultilinearMap.toMultilinearMap","decl":"theorem toMultilinearMap_injective :\n    Function.Injective\n      (ContinuousMultilinearMap.toMultilinearMap :\n        ContinuousMultilinearMap R M₁ M₂ → MultilinearMap R M₁ M₂)\n  | ⟨f, hf⟩, ⟨g, hg⟩, h => by subst h; rfl\n\n"}
{"name":"ContinuousMultilinearMap.continuousMapClass","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\n⊢ ContinuousMapClass (ContinuousMultilinearMap R M₁ M₂) ((i : ι) → M₁ i) M₂","decl":"instance continuousMapClass :\n    ContinuousMapClass (ContinuousMultilinearMap R M₁ M₂) (∀ i, M₁ i) M₂ where\n  map_continuous := ContinuousMultilinearMap.cont\n\n"}
{"name":"ContinuousMultilinearMap.coe_continuous","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\n⊢ Continuous ⇑f","decl":"@[continuity]\ntheorem coe_continuous : Continuous (f : (∀ i, M₁ i) → M₂) :=\n  f.cont\n\n"}
{"name":"ContinuousMultilinearMap.coe_coe","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\n⊢ Eq ⇑f.toMultilinearMap ⇑f","decl":"@[simp]\ntheorem coe_coe : (f.toMultilinearMap : (∀ i, M₁ i) → M₂) = f :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.ext_iff","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\nf f' : ContinuousMultilinearMap R M₁ M₂\n⊢ Iff (Eq f f') (∀ (x : (i : ι) → M₁ i), Eq (f x) (f' x))","decl":"@[ext]\ntheorem ext {f f' : ContinuousMultilinearMap R M₁ M₂} (H : ∀ x, f x = f' x) : f = f' :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"ContinuousMultilinearMap.ext","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\nf f' : ContinuousMultilinearMap R M₁ M₂\nH : ∀ (x : (i : ι) → M₁ i), Eq (f x) (f' x)\n⊢ Eq f f'","decl":"@[ext]\ntheorem ext {f f' : ContinuousMultilinearMap R M₁ M₂} (H : ∀ x, f x = f' x) : f = f' :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"ContinuousMultilinearMap.map_update_add","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx y : M₁ i\n⊢ Eq (f (Function.update m i (HAdd.hAdd x y))) (HAdd.hAdd (f (Function.update m i x)) (f (Function.update m i y)))","decl":"@[simp]\ntheorem map_update_add [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x y : M₁ i) :\n    f (update m i (x + y)) = f (update m i x) + f (update m i y) :=\n  f.map_update_add' m i x y\n\n"}
{"name":"ContinuousMultilinearMap.map_add","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx y : M₁ i\n⊢ Eq (f (Function.update m i (HAdd.hAdd x y))) (HAdd.hAdd (f (Function.update m i x)) (f (Function.update m i y)))","decl":"@[deprecated (since := \"2024-11-03\")]\nprotected alias map_add := ContinuousMultilinearMap.map_update_add\n\n"}
{"name":"ContinuousMultilinearMap.map_update_smul","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nc : R\nx : M₁ i\n⊢ Eq (f (Function.update m i (HSMul.hSMul c x))) (HSMul.hSMul c (f (Function.update m i x)))","decl":"@[simp]\ntheorem map_update_smul [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (c : R) (x : M₁ i) :\n    f (update m i (c • x)) = c • f (update m i x) :=\n  f.map_update_smul' m i c x\n\n"}
{"name":"ContinuousMultilinearMap.map_smul","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nc : R\nx : M₁ i\n⊢ Eq (f (Function.update m i (HSMul.hSMul c x))) (HSMul.hSMul c (f (Function.update m i x)))","decl":"@[deprecated (since := \"2024-11-03\")]\nprotected alias map_smul := ContinuousMultilinearMap.map_update_smul\n\n"}
{"name":"ContinuousMultilinearMap.map_coord_zero","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\nm : (i : ι) → M₁ i\ni : ι\nh : Eq (m i) 0\n⊢ Eq (f m) 0","decl":"theorem map_coord_zero {m : ∀ i, M₁ i} (i : ι) (h : m i = 0) : f m = 0 :=\n  f.toMultilinearMap.map_coord_zero i h\n\n"}
{"name":"ContinuousMultilinearMap.map_zero","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝ : Nonempty ι\n⊢ Eq (f 0) 0","decl":"@[simp]\ntheorem map_zero [Nonempty ι] : f 0 = 0 :=\n  f.toMultilinearMap.map_zero\n\n"}
{"name":"ContinuousMultilinearMap.zero_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\nm : (i : ι) → M₁ i\n⊢ Eq (0 m) 0","decl":"@[simp]\ntheorem zero_apply (m : ∀ i, M₁ i) : (0 : ContinuousMultilinearMap R M₁ M₂) m = 0 :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.toMultilinearMap_zero","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\n⊢ Eq (ContinuousMultilinearMap.toMultilinearMap 0) 0","decl":"@[simp]\ntheorem toMultilinearMap_zero : (0 : ContinuousMultilinearMap R M₁ M₂).toMultilinearMap = 0 :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.smul_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"ι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝¹⁰ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁹ : AddCommMonoid M₂\ninst✝⁸ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝⁷ : TopologicalSpace M₂\nR' : Type u_1\nA : Type u_3\ninst✝⁶ : Monoid R'\ninst✝⁵ : Semiring A\ninst✝⁴ : (i : ι) → Module A (M₁ i)\ninst✝³ : Module A M₂\ninst✝² : DistribMulAction R' M₂\ninst✝¹ : ContinuousConstSMul R' M₂\ninst✝ : SMulCommClass A R' M₂\nf : ContinuousMultilinearMap A M₁ M₂\nc : R'\nm : (i : ι) → M₁ i\n⊢ Eq ((HSMul.hSMul c f) m) (HSMul.hSMul c (f m))","decl":"@[simp]\ntheorem smul_apply (f : ContinuousMultilinearMap A M₁ M₂) (c : R') (m : ∀ i, M₁ i) :\n    (c • f) m = c • f m :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.toMultilinearMap_smul","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"ι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝¹⁰ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁹ : AddCommMonoid M₂\ninst✝⁸ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝⁷ : TopologicalSpace M₂\nR' : Type u_1\nA : Type u_3\ninst✝⁶ : Monoid R'\ninst✝⁵ : Semiring A\ninst✝⁴ : (i : ι) → Module A (M₁ i)\ninst✝³ : Module A M₂\ninst✝² : DistribMulAction R' M₂\ninst✝¹ : ContinuousConstSMul R' M₂\ninst✝ : SMulCommClass A R' M₂\nc : R'\nf : ContinuousMultilinearMap A M₁ M₂\n⊢ Eq (HSMul.hSMul c f).toMultilinearMap (HSMul.hSMul c f.toMultilinearMap)","decl":"@[simp]\ntheorem toMultilinearMap_smul (c : R') (f : ContinuousMultilinearMap A M₁ M₂) :\n    (c • f).toMultilinearMap = c • f.toMultilinearMap :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.instSMulCommClass","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"ι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝¹⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝¹⁴ : AddCommMonoid M₂\ninst✝¹³ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹² : TopologicalSpace M₂\nR' : Type u_1\nR'' : Type u_2\nA : Type u_3\ninst✝¹¹ : Monoid R'\ninst✝¹⁰ : Monoid R''\ninst✝⁹ : Semiring A\ninst✝⁸ : (i : ι) → Module A (M₁ i)\ninst✝⁷ : Module A M₂\ninst✝⁶ : DistribMulAction R' M₂\ninst✝⁵ : ContinuousConstSMul R' M₂\ninst✝⁴ : SMulCommClass A R' M₂\ninst✝³ : DistribMulAction R'' M₂\ninst✝² : ContinuousConstSMul R'' M₂\ninst✝¹ : SMulCommClass A R'' M₂\ninst✝ : SMulCommClass R' R'' M₂\n⊢ SMulCommClass R' R'' (ContinuousMultilinearMap A M₁ M₂)","decl":"instance [SMulCommClass R' R'' M₂] : SMulCommClass R' R'' (ContinuousMultilinearMap A M₁ M₂) :=\n  ⟨fun _ _ _ => ext fun _ => smul_comm _ _ _⟩\n\n"}
{"name":"ContinuousMultilinearMap.instIsScalarTower","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"ι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝¹⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝¹⁵ : AddCommMonoid M₂\ninst✝¹⁴ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹³ : TopologicalSpace M₂\nR' : Type u_1\nR'' : Type u_2\nA : Type u_3\ninst✝¹² : Monoid R'\ninst✝¹¹ : Monoid R''\ninst✝¹⁰ : Semiring A\ninst✝⁹ : (i : ι) → Module A (M₁ i)\ninst✝⁸ : Module A M₂\ninst✝⁷ : DistribMulAction R' M₂\ninst✝⁶ : ContinuousConstSMul R' M₂\ninst✝⁵ : SMulCommClass A R' M₂\ninst✝⁴ : DistribMulAction R'' M₂\ninst✝³ : ContinuousConstSMul R'' M₂\ninst✝² : SMulCommClass A R'' M₂\ninst✝¹ : SMul R' R''\ninst✝ : IsScalarTower R' R'' M₂\n⊢ IsScalarTower R' R'' (ContinuousMultilinearMap A M₁ M₂)","decl":"instance [SMul R' R''] [IsScalarTower R' R'' M₂] :\n    IsScalarTower R' R'' (ContinuousMultilinearMap A M₁ M₂) :=\n  ⟨fun _ _ _ => ext fun _ => smul_assoc _ _ _⟩\n\n"}
{"name":"ContinuousMultilinearMap.instIsCentralScalar","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"ι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝¹² : (i : ι) → AddCommMonoid (M₁ i)\ninst✝¹¹ : AddCommMonoid M₂\ninst✝¹⁰ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝⁹ : TopologicalSpace M₂\nR' : Type u_1\nA : Type u_3\ninst✝⁸ : Monoid R'\ninst✝⁷ : Semiring A\ninst✝⁶ : (i : ι) → Module A (M₁ i)\ninst✝⁵ : Module A M₂\ninst✝⁴ : DistribMulAction R' M₂\ninst✝³ : ContinuousConstSMul R' M₂\ninst✝² : SMulCommClass A R' M₂\ninst✝¹ : DistribMulAction (MulOpposite R') M₂\ninst✝ : IsCentralScalar R' M₂\n⊢ IsCentralScalar R' (ContinuousMultilinearMap A M₁ M₂)","decl":"instance [DistribMulAction R'ᵐᵒᵖ M₂] [IsCentralScalar R' M₂] :\n    IsCentralScalar R' (ContinuousMultilinearMap A M₁ M₂) :=\n  ⟨fun _ _ => ext fun _ => op_smul_eq_smul _ _⟩\n\n"}
{"name":"ContinuousMultilinearMap.add_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf f' : ContinuousMultilinearMap R M₁ M₂\ninst✝ : ContinuousAdd M₂\nm : (i : ι) → M₁ i\n⊢ Eq ((HAdd.hAdd f f') m) (HAdd.hAdd (f m) (f' m))","decl":"@[simp]\ntheorem add_apply (m : ∀ i, M₁ i) : (f + f') m = f m + f' m :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.toMultilinearMap_add","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : ContinuousAdd M₂\nf g : ContinuousMultilinearMap R M₁ M₂\n⊢ Eq (HAdd.hAdd f g).toMultilinearMap (HAdd.hAdd f.toMultilinearMap g.toMultilinearMap)","decl":"@[simp]\ntheorem toMultilinearMap_add (f g : ContinuousMultilinearMap R M₁ M₂) :\n    (f + g).toMultilinearMap = f.toMultilinearMap + g.toMultilinearMap :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.sum_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : ContinuousAdd M₂\nα : Type u_1\nf : α → ContinuousMultilinearMap R M₁ M₂\nm : (i : ι) → M₁ i\ns : Finset α\n⊢ Eq ((s.sum fun a => f a) m) (s.sum fun a => (f a) m)","decl":"@[simp]\ntheorem sum_apply {α : Type*} (f : α → ContinuousMultilinearMap R M₁ M₂) (m : ∀ i, M₁ i)\n    {s : Finset α} : (∑ a ∈ s, f a) m = ∑ a ∈ s, f a m :=\n  map_sum (applyAddHom m) f s\n\n"}
{"name":"ContinuousMultilinearMap.toContinuousLinearMap_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx : M₁ i\n⊢ Eq ((f.toContinuousLinearMap m i) x) (f (Function.update m i x))","decl":"/-- If `f` is a continuous multilinear map, then `f.toContinuousLinearMap m i` is the continuous\nlinear map obtained by fixing all coordinates but `i` equal to those of `m`, and varying the\n`i`-th coordinate. -/\n@[simps!] def toContinuousLinearMap [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) : M₁ i →L[R] M₂ :=\n  { f.toMultilinearMap.toLinearMap m i with\n    cont := f.cont.comp (continuous_const.update i continuous_id) }\n\n"}
{"name":"ContinuousMultilinearMap.prod_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : AddCommMonoid M₃\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\nf : ContinuousMultilinearMap R M₁ M₂\ng : ContinuousMultilinearMap R M₁ M₃\nm : (i : ι) → M₁ i\n⊢ Eq ((f.prod g) m) { fst := f m, snd := g m }","decl":"@[simp]\ntheorem prod_apply (f : ContinuousMultilinearMap R M₁ M₂) (g : ContinuousMultilinearMap R M₁ M₃)\n    (m : ∀ i, M₁ i) : (f.prod g) m = (f m, g m) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.coe_pi","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : (i : ι) → TopologicalSpace (M₁ i)\nι' : Type u_1\nM' : ι' → Type u_2\ninst✝² : (i : ι') → AddCommMonoid (M' i)\ninst✝¹ : (i : ι') → TopologicalSpace (M' i)\ninst✝ : (i : ι') → Module R (M' i)\nf : (i : ι') → ContinuousMultilinearMap R M₁ (M' i)\n⊢ Eq ⇑(ContinuousMultilinearMap.pi f) fun m j => (f j) m","decl":"@[simp]\ntheorem coe_pi {ι' : Type*} {M' : ι' → Type*} [∀ i, AddCommMonoid (M' i)]\n    [∀ i, TopologicalSpace (M' i)] [∀ i, Module R (M' i)]\n    (f : ∀ i, ContinuousMultilinearMap R M₁ (M' i)) : ⇑(pi f) = fun m j => f j m :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.pi_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : (i : ι) → TopologicalSpace (M₁ i)\nι' : Type u_1\nM' : ι' → Type u_2\ninst✝² : (i : ι') → AddCommMonoid (M' i)\ninst✝¹ : (i : ι') → TopologicalSpace (M' i)\ninst✝ : (i : ι') → Module R (M' i)\nf : (i : ι') → ContinuousMultilinearMap R M₁ (M' i)\nm : (i : ι) → M₁ i\nj : ι'\n⊢ Eq ((ContinuousMultilinearMap.pi f) m j) ((f j) m)","decl":"theorem pi_apply {ι' : Type*} {M' : ι' → Type*} [∀ i, AddCommMonoid (M' i)]\n    [∀ i, TopologicalSpace (M' i)] [∀ i, Module R (M' i)]\n    (f : ∀ i, ContinuousMultilinearMap R M₁ (M' i)) (m : ∀ i, M₁ i) (j : ι') : pi f m j = f j m :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.codRestrict_apply_coe","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\np : Submodule R M₂\nh : ∀ (v : (i : ι) → M₁ i), Membership.mem p (f v)\nv : (i : ι) → M₁ i\n⊢ Eq (↑((f.codRestrict p h) v)) (f v)","decl":"/-- Restrict the codomain of a continuous multilinear map to a submodule. -/\n@[simps! toMultilinearMap apply_coe]\ndef codRestrict (f : ContinuousMultilinearMap R M₁ M₂) (p : Submodule R M₂) (h : ∀ v, f v ∈ p) :\n    ContinuousMultilinearMap R M₁ p :=\n  ⟨f.1.codRestrict p h, f.cont.subtype_mk _⟩\n\n"}
{"name":"ContinuousMultilinearMap.codRestrict_toMultilinearMap","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\np : Submodule R M₂\nh : ∀ (v : (i : ι) → M₁ i), Membership.mem p (f v)\n⊢ Eq (f.codRestrict p h).toMultilinearMap (f.codRestrict p h)","decl":"/-- Restrict the codomain of a continuous multilinear map to a submodule. -/\n@[simps! toMultilinearMap apply_coe]\ndef codRestrict (f : ContinuousMultilinearMap R M₁ M₂) (p : Submodule R M₂) (h : ∀ v, f v ∈ p) :\n    ContinuousMultilinearMap R M₁ p :=\n  ⟨f.1.codRestrict p h, f.cont.subtype_mk _⟩\n\n"}
{"name":"ContinuousMultilinearMap.ofSubsingleton_apply_toMultilinearMap","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : TopologicalSpace M₂\ninst✝¹ : TopologicalSpace M₃\ninst✝ : Subsingleton ι\ni : ι\nf : ContinuousLinearMap (RingHom.id R) M₂ M₃\n⊢ Eq ((ContinuousMultilinearMap.ofSubsingleton R M₂ M₃ i) f).toMultilinearMap ((MultilinearMap.ofSubsingleton R M₂ M₃ i) ↑f)","decl":"/-- The natural equivalence between continuous linear maps from `M₂` to `M₃`\nand continuous 1-multilinear maps from `M₂` to `M₃`. -/\n@[simps! apply_toMultilinearMap apply_apply symm_apply_apply]\ndef ofSubsingleton [Subsingleton ι] (i : ι) :\n    (M₂ →L[R] M₃) ≃ ContinuousMultilinearMap R (fun _ : ι => M₂) M₃ where\n  toFun f := ⟨MultilinearMap.ofSubsingleton R M₂ M₃ i f,\n    (map_continuous f).comp (continuous_apply i)⟩\n  invFun f := ⟨(MultilinearMap.ofSubsingleton R M₂ M₃ i).symm f.toMultilinearMap,\n    (map_continuous f).comp <| continuous_pi fun _ ↦ continuous_id⟩\n  left_inv _ := rfl\n  right_inv f := toMultilinearMap_injective <|\n    (MultilinearMap.ofSubsingleton R M₂ M₃ i).apply_symm_apply f.toMultilinearMap\n\n"}
{"name":"ContinuousMultilinearMap.ofSubsingleton_apply_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : TopologicalSpace M₂\ninst✝¹ : TopologicalSpace M₃\ninst✝ : Subsingleton ι\ni : ι\nf : ContinuousLinearMap (RingHom.id R) M₂ M₃\nx : ι → M₂\n⊢ Eq (((ContinuousMultilinearMap.ofSubsingleton R M₂ M₃ i) f) x) (f (x i))","decl":"/-- The natural equivalence between continuous linear maps from `M₂` to `M₃`\nand continuous 1-multilinear maps from `M₂` to `M₃`. -/\n@[simps! apply_toMultilinearMap apply_apply symm_apply_apply]\ndef ofSubsingleton [Subsingleton ι] (i : ι) :\n    (M₂ →L[R] M₃) ≃ ContinuousMultilinearMap R (fun _ : ι => M₂) M₃ where\n  toFun f := ⟨MultilinearMap.ofSubsingleton R M₂ M₃ i f,\n    (map_continuous f).comp (continuous_apply i)⟩\n  invFun f := ⟨(MultilinearMap.ofSubsingleton R M₂ M₃ i).symm f.toMultilinearMap,\n    (map_continuous f).comp <| continuous_pi fun _ ↦ continuous_id⟩\n  left_inv _ := rfl\n  right_inv f := toMultilinearMap_injective <|\n    (MultilinearMap.ofSubsingleton R M₂ M₃ i).apply_symm_apply f.toMultilinearMap\n\n"}
{"name":"ContinuousMultilinearMap.ofSubsingleton_symm_apply_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₃\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : TopologicalSpace M₂\ninst✝¹ : TopologicalSpace M₃\ninst✝ : Subsingleton ι\ni : ι\nf : ContinuousMultilinearMap R (fun x => M₂) M₃\nx : M₂\n⊢ Eq (((ContinuousMultilinearMap.ofSubsingleton R M₂ M₃ i).symm f) x) (f fun x_1 => x)","decl":"/-- The natural equivalence between continuous linear maps from `M₂` to `M₃`\nand continuous 1-multilinear maps from `M₂` to `M₃`. -/\n@[simps! apply_toMultilinearMap apply_apply symm_apply_apply]\ndef ofSubsingleton [Subsingleton ι] (i : ι) :\n    (M₂ →L[R] M₃) ≃ ContinuousMultilinearMap R (fun _ : ι => M₂) M₃ where\n  toFun f := ⟨MultilinearMap.ofSubsingleton R M₂ M₃ i f,\n    (map_continuous f).comp (continuous_apply i)⟩\n  invFun f := ⟨(MultilinearMap.ofSubsingleton R M₂ M₃ i).symm f.toMultilinearMap,\n    (map_continuous f).comp <| continuous_pi fun _ ↦ continuous_id⟩\n  left_inv _ := rfl\n  right_inv f := toMultilinearMap_injective <|\n    (MultilinearMap.ofSubsingleton R M₂ M₃ i).apply_symm_apply f.toMultilinearMap\n\n"}
{"name":"ContinuousMultilinearMap.constOfIsEmpty_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : IsEmpty ι\nm : M₂\na✝ : (i : ι) → M₁ i\n⊢ Eq ((ContinuousMultilinearMap.constOfIsEmpty R M₁ m) a✝) m","decl":"/-- The constant map is multilinear when `ι` is empty. -/\n@[simps! toMultilinearMap apply]\ndef constOfIsEmpty [IsEmpty ι] (m : M₂) : ContinuousMultilinearMap R M₁ M₂ where\n  toMultilinearMap := MultilinearMap.constOfIsEmpty R _ m\n  cont := continuous_const\n\n"}
{"name":"ContinuousMultilinearMap.constOfIsEmpty_toMultilinearMap","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : IsEmpty ι\nm : M₂\n⊢ Eq (ContinuousMultilinearMap.constOfIsEmpty R M₁ m).toMultilinearMap (MultilinearMap.constOfIsEmpty R M₁ m)","decl":"/-- The constant map is multilinear when `ι` is empty. -/\n@[simps! toMultilinearMap apply]\ndef constOfIsEmpty [IsEmpty ι] (m : M₂) : ContinuousMultilinearMap R M₁ M₂ where\n  toMultilinearMap := MultilinearMap.constOfIsEmpty R _ m\n  cont := continuous_const\n\n"}
{"name":"ContinuousMultilinearMap.compContinuousLinearMap_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₁' : ι → Type w₁'\nM₄ : Type w₄\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : (i : ι) → AddCommMonoid (M₁' i)\ninst✝⁶ : AddCommMonoid M₄\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : (i : ι) → Module R (M₁' i)\ninst✝³ : Module R M₄\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : (i : ι) → TopologicalSpace (M₁' i)\ninst✝ : TopologicalSpace M₄\ng : ContinuousMultilinearMap R M₁' M₄\nf : (i : ι) → ContinuousLinearMap (RingHom.id R) (M₁ i) (M₁' i)\nm : (i : ι) → M₁ i\n⊢ Eq ((g.compContinuousLinearMap f) m) (g fun i => (f i) (m i))","decl":"@[simp]\ntheorem compContinuousLinearMap_apply (g : ContinuousMultilinearMap R M₁' M₄)\n    (f : ∀ i : ι, M₁ i →L[R] M₁' i) (m : ∀ i, M₁ i) :\n    g.compContinuousLinearMap f m = g fun i => f i <| m i :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.compContinuousMultilinearMap_coe","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : AddCommMonoid M₃\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\ng : ContinuousLinearMap (RingHom.id R) M₂ M₃\nf : ContinuousMultilinearMap R M₁ M₂\n⊢ Eq (⇑(g.compContinuousMultilinearMap f)) (Function.comp ⇑g ⇑f)","decl":"@[simp]\ntheorem _root_.ContinuousLinearMap.compContinuousMultilinearMap_coe (g : M₂ →L[R] M₃)\n    (f : ContinuousMultilinearMap R M₁ M₂) :\n    (g.compContinuousMultilinearMap f : (∀ i, M₁ i) → M₃) =\n      (g : M₂ → M₃) ∘ (f : (∀ i, M₁ i) → M₂) := by\n  ext m\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.prodEquiv_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : AddCommMonoid M₃\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\nf : Prod (ContinuousMultilinearMap R M₁ M₂) (ContinuousMultilinearMap R M₁ M₃)\n⊢ Eq (ContinuousMultilinearMap.prodEquiv f) (f.1.prod f.2)","decl":"/-- `ContinuousMultilinearMap.prod` as an `Equiv`. -/\n@[simps apply symm_apply_fst symm_apply_snd, simps (config := .lemmasOnly) symm_apply]\ndef prodEquiv :\n    (ContinuousMultilinearMap R M₁ M₂ × ContinuousMultilinearMap R M₁ M₃) ≃\n      ContinuousMultilinearMap R M₁ (M₂ × M₃) where\n  toFun f := f.1.prod f.2\n  invFun f := ((ContinuousLinearMap.fst _ _ _).compContinuousMultilinearMap f,\n    (ContinuousLinearMap.snd _ _ _).compContinuousMultilinearMap f)\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"ContinuousMultilinearMap.prodEquiv_symm_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : AddCommMonoid M₃\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\nf : ContinuousMultilinearMap R M₁ (Prod M₂ M₃)\n⊢ Eq (ContinuousMultilinearMap.prodEquiv.symm f) { fst := (ContinuousLinearMap.fst R M₂ M₃).compContinuousMultilinearMap f, snd := (ContinuousLinearMap.snd R M₂ M₃).compContinuousMultilinearMap f }","decl":"/-- `ContinuousMultilinearMap.prod` as an `Equiv`. -/\n@[simps apply symm_apply_fst symm_apply_snd, simps (config := .lemmasOnly) symm_apply]\ndef prodEquiv :\n    (ContinuousMultilinearMap R M₁ M₂ × ContinuousMultilinearMap R M₁ M₃) ≃\n      ContinuousMultilinearMap R M₁ (M₂ × M₃) where\n  toFun f := f.1.prod f.2\n  invFun f := ((ContinuousLinearMap.fst _ _ _).compContinuousMultilinearMap f,\n    (ContinuousLinearMap.snd _ _ _).compContinuousMultilinearMap f)\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"ContinuousMultilinearMap.prodEquiv_symm_apply_fst","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : AddCommMonoid M₃\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\nf : ContinuousMultilinearMap R M₁ (Prod M₂ M₃)\n⊢ Eq (ContinuousMultilinearMap.prodEquiv.symm f).1 ((ContinuousLinearMap.fst R M₂ M₃).compContinuousMultilinearMap f)","decl":"/-- `ContinuousMultilinearMap.prod` as an `Equiv`. -/\n@[simps apply symm_apply_fst symm_apply_snd, simps (config := .lemmasOnly) symm_apply]\ndef prodEquiv :\n    (ContinuousMultilinearMap R M₁ M₂ × ContinuousMultilinearMap R M₁ M₃) ≃\n      ContinuousMultilinearMap R M₁ (M₂ × M₃) where\n  toFun f := f.1.prod f.2\n  invFun f := ((ContinuousLinearMap.fst _ _ _).compContinuousMultilinearMap f,\n    (ContinuousLinearMap.snd _ _ _).compContinuousMultilinearMap f)\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"ContinuousMultilinearMap.prodEquiv_symm_apply_snd","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : AddCommMonoid M₃\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\nf : ContinuousMultilinearMap R M₁ (Prod M₂ M₃)\n⊢ Eq (ContinuousMultilinearMap.prodEquiv.symm f).2 ((ContinuousLinearMap.snd R M₂ M₃).compContinuousMultilinearMap f)","decl":"/-- `ContinuousMultilinearMap.prod` as an `Equiv`. -/\n@[simps apply symm_apply_fst symm_apply_snd, simps (config := .lemmasOnly) symm_apply]\ndef prodEquiv :\n    (ContinuousMultilinearMap R M₁ M₂ × ContinuousMultilinearMap R M₁ M₃) ≃\n      ContinuousMultilinearMap R M₁ (M₂ × M₃) where\n  toFun f := f.1.prod f.2\n  invFun f := ((ContinuousLinearMap.fst _ _ _).compContinuousMultilinearMap f,\n    (ContinuousLinearMap.snd _ _ _).compContinuousMultilinearMap f)\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"ContinuousMultilinearMap.prod_ext_iff","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : AddCommMonoid M₃\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\nf g : ContinuousMultilinearMap R M₁ (Prod M₂ M₃)\n⊢ Iff (Eq f g) (And (Eq ((ContinuousLinearMap.fst R M₂ M₃).compContinuousMultilinearMap f) ((ContinuousLinearMap.fst R M₂ M₃).compContinuousMultilinearMap g)) (Eq ((ContinuousLinearMap.snd R M₂ M₃).compContinuousMultilinearMap f) ((ContinuousLinearMap.snd R M₂ M₃).compContinuousMultilinearMap g)))","decl":"theorem prod_ext_iff {f g : ContinuousMultilinearMap R M₁ (M₂ × M₃)} :\n    f = g ↔ (ContinuousLinearMap.fst _ _ _).compContinuousMultilinearMap f =\n      (ContinuousLinearMap.fst _ _ _).compContinuousMultilinearMap g ∧\n      (ContinuousLinearMap.snd _ _ _).compContinuousMultilinearMap f =\n      (ContinuousLinearMap.snd _ _ _).compContinuousMultilinearMap g := by\n  rw [← Prod.mk.inj_iff, ← prodEquiv_symm_apply, ← prodEquiv_symm_apply, Equiv.apply_eq_iff_eq]\n\n"}
{"name":"ContinuousMultilinearMap.prod_ext","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : AddCommMonoid M₃\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\nf g : ContinuousMultilinearMap R M₁ (Prod M₂ M₃)\nh₁ : Eq ((ContinuousLinearMap.fst R M₂ M₃).compContinuousMultilinearMap f) ((ContinuousLinearMap.fst R M₂ M₃).compContinuousMultilinearMap g)\nh₂ : Eq ((ContinuousLinearMap.snd R M₂ M₃).compContinuousMultilinearMap f) ((ContinuousLinearMap.snd R M₂ M₃).compContinuousMultilinearMap g)\n⊢ Eq f g","decl":"@[ext]\ntheorem prod_ext {f g : ContinuousMultilinearMap R M₁ (M₂ × M₃)}\n    (h₁ : (ContinuousLinearMap.fst _ _ _).compContinuousMultilinearMap f =\n      (ContinuousLinearMap.fst _ _ _).compContinuousMultilinearMap g)\n    (h₂ : (ContinuousLinearMap.snd _ _ _).compContinuousMultilinearMap f =\n      (ContinuousLinearMap.snd _ _ _).compContinuousMultilinearMap g) : f = g :=\n  prod_ext_iff.mpr ⟨h₁, h₂⟩\n\n"}
{"name":"ContinuousMultilinearMap.eq_prod_iff","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : AddCommMonoid M₃\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\nf : ContinuousMultilinearMap R M₁ (Prod M₂ M₃)\ng : ContinuousMultilinearMap R M₁ M₂\nh : ContinuousMultilinearMap R M₁ M₃\n⊢ Iff (Eq f (g.prod h)) (And (Eq ((ContinuousLinearMap.fst R M₂ M₃).compContinuousMultilinearMap f) g) (Eq ((ContinuousLinearMap.snd R M₂ M₃).compContinuousMultilinearMap f) h))","decl":"theorem eq_prod_iff {f : ContinuousMultilinearMap R M₁ (M₂ × M₃)}\n    {g : ContinuousMultilinearMap R M₁ M₂} {h : ContinuousMultilinearMap R M₁ M₃} :\n    f = g.prod h ↔ (ContinuousLinearMap.fst _ _ _).compContinuousMultilinearMap f = g ∧\n      (ContinuousLinearMap.snd _ _ _).compContinuousMultilinearMap f = h :=\n  prod_ext_iff\n\n"}
{"name":"ContinuousMultilinearMap.add_prod_add","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁹ : AddCommMonoid M₂\ninst✝⁸ : AddCommMonoid M₃\ninst✝⁷ : (i : ι) → Module R (M₁ i)\ninst✝⁶ : Module R M₂\ninst✝⁵ : Module R M₃\ninst✝⁴ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝³ : TopologicalSpace M₂\ninst✝² : TopologicalSpace M₃\ninst✝¹ : ContinuousAdd M₂\ninst✝ : ContinuousAdd M₃\nf₁ f₂ : ContinuousMultilinearMap R M₁ M₂\ng₁ g₂ : ContinuousMultilinearMap R M₁ M₃\n⊢ Eq ((HAdd.hAdd f₁ f₂).prod (HAdd.hAdd g₁ g₂)) (HAdd.hAdd (f₁.prod g₁) (f₂.prod g₂))","decl":"theorem add_prod_add [ContinuousAdd M₂] [ContinuousAdd M₃]\n    (f₁ f₂ : ContinuousMultilinearMap R M₁ M₂) (g₁ g₂ : ContinuousMultilinearMap R M₁ M₃) :\n    (f₁ + f₂).prod (g₁ + g₂) = f₁.prod g₁ + f₂.prod g₂ :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.smul_prod_smul","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝¹⁶ : Semiring R\ninst✝¹⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝¹⁴ : AddCommMonoid M₂\ninst✝¹³ : AddCommMonoid M₃\ninst✝¹² : (i : ι) → Module R (M₁ i)\ninst✝¹¹ : Module R M₂\ninst✝¹⁰ : Module R M₃\ninst✝⁹ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝⁸ : TopologicalSpace M₂\ninst✝⁷ : TopologicalSpace M₃\nS : Type u_1\ninst✝⁶ : Monoid S\ninst✝⁵ : DistribMulAction S M₂\ninst✝⁴ : DistribMulAction S M₃\ninst✝³ : ContinuousConstSMul S M₂\ninst✝² : SMulCommClass R S M₂\ninst✝¹ : ContinuousConstSMul S M₃\ninst✝ : SMulCommClass R S M₃\nc : S\nf : ContinuousMultilinearMap R M₁ M₂\ng : ContinuousMultilinearMap R M₁ M₃\n⊢ Eq ((HSMul.hSMul c f).prod (HSMul.hSMul c g)) (HSMul.hSMul c (f.prod g))","decl":"theorem smul_prod_smul {S : Type*} [Monoid S] [DistribMulAction S M₂] [DistribMulAction S M₃]\n    [ContinuousConstSMul S M₂] [SMulCommClass R S M₂]\n    [ContinuousConstSMul S M₃] [SMulCommClass R S M₃]\n    (c : S) (f : ContinuousMultilinearMap R M₁ M₂) (g : ContinuousMultilinearMap R M₁ M₃) :\n    (c • f).prod (c • g) = c • f.prod g :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.zero_prod_zero","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : AddCommMonoid M₃\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\n⊢ Eq (ContinuousMultilinearMap.prod 0 0) 0","decl":"@[simp]\ntheorem zero_prod_zero :\n    (0 : ContinuousMultilinearMap R M₁ M₂).prod (0 : ContinuousMultilinearMap R M₁ M₃) = 0 :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.piEquiv_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : (i : ι) → TopologicalSpace (M₁ i)\nι' : Type u_1\nM' : ι' → Type u_2\ninst✝² : (i : ι') → AddCommMonoid (M' i)\ninst✝¹ : (i : ι') → TopologicalSpace (M' i)\ninst✝ : (i : ι') → Module R (M' i)\nf : (i : ι') → ContinuousMultilinearMap R M₁ (M' i)\n⊢ Eq (ContinuousMultilinearMap.piEquiv f) (ContinuousMultilinearMap.pi f)","decl":"/-- `ContinuousMultilinearMap.pi` as an `Equiv`. -/\n@[simps]\ndef piEquiv {ι' : Type*} {M' : ι' → Type*} [∀ i, AddCommMonoid (M' i)]\n    [∀ i, TopologicalSpace (M' i)] [∀ i, Module R (M' i)] :\n    (∀ i, ContinuousMultilinearMap R M₁ (M' i)) ≃ ContinuousMultilinearMap R M₁ (∀ i, M' i) where\n  toFun := ContinuousMultilinearMap.pi\n  invFun f i := (ContinuousLinearMap.proj i : _ →L[R] M' i).compContinuousMultilinearMap f\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"ContinuousMultilinearMap.piEquiv_symm_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : (i : ι) → TopologicalSpace (M₁ i)\nι' : Type u_1\nM' : ι' → Type u_2\ninst✝² : (i : ι') → AddCommMonoid (M' i)\ninst✝¹ : (i : ι') → TopologicalSpace (M' i)\ninst✝ : (i : ι') → Module R (M' i)\nf : ContinuousMultilinearMap R M₁ ((i : ι') → M' i)\ni : ι'\n⊢ Eq (ContinuousMultilinearMap.piEquiv.symm f i) ((ContinuousLinearMap.proj i).compContinuousMultilinearMap f)","decl":"/-- `ContinuousMultilinearMap.pi` as an `Equiv`. -/\n@[simps]\ndef piEquiv {ι' : Type*} {M' : ι' → Type*} [∀ i, AddCommMonoid (M' i)]\n    [∀ i, TopologicalSpace (M' i)] [∀ i, Module R (M' i)] :\n    (∀ i, ContinuousMultilinearMap R M₁ (M' i)) ≃ ContinuousMultilinearMap R M₁ (∀ i, M' i) where\n  toFun := ContinuousMultilinearMap.pi\n  invFun f i := (ContinuousLinearMap.proj i : _ →L[R] M' i).compContinuousMultilinearMap f\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"ContinuousMultilinearMap.domDomCongr_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M₂\ninst✝² : Module R M₃\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\nι' : Type u_1\ne : Equiv ι ι'\nf : ContinuousMultilinearMap R (fun x => M₂) M₃\nv : ι' → M₂\n⊢ Eq ((ContinuousMultilinearMap.domDomCongr e f) v) (f fun i => v (e i))","decl":"/-- An equivalence of the index set defines an equivalence between the spaces of continuous\nmultilinear maps. This is the forward map of this equivalence. -/\n@[simps! toMultilinearMap apply]\nnonrec def domDomCongr {ι' : Type*} (e : ι ≃ ι')\n    (f : ContinuousMultilinearMap R (fun _ : ι => M₂) M₃) :\n    ContinuousMultilinearMap R (fun _ : ι' => M₂) M₃ where\n  toMultilinearMap := f.domDomCongr e\n  cont := f.cont.comp <| continuous_pi fun _ => continuous_apply _\n\n"}
{"name":"ContinuousMultilinearMap.domDomCongr_toMultilinearMap","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M₂\ninst✝² : Module R M₃\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\nι' : Type u_1\ne : Equiv ι ι'\nf : ContinuousMultilinearMap R (fun x => M₂) M₃\n⊢ Eq (ContinuousMultilinearMap.domDomCongr e f).toMultilinearMap (MultilinearMap.domDomCongr e f.toMultilinearMap)","decl":"/-- An equivalence of the index set defines an equivalence between the spaces of continuous\nmultilinear maps. This is the forward map of this equivalence. -/\n@[simps! toMultilinearMap apply]\nnonrec def domDomCongr {ι' : Type*} (e : ι ≃ ι')\n    (f : ContinuousMultilinearMap R (fun _ : ι => M₂) M₃) :\n    ContinuousMultilinearMap R (fun _ : ι' => M₂) M₃ where\n  toMultilinearMap := f.domDomCongr e\n  cont := f.cont.comp <| continuous_pi fun _ => continuous_apply _\n\n"}
{"name":"ContinuousMultilinearMap.domDomCongrEquiv_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M₂\ninst✝² : Module R M₃\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\nι' : Type u_1\ne : Equiv ι ι'\nf : ContinuousMultilinearMap R (fun x => M₂) M₃\n⊢ Eq ((ContinuousMultilinearMap.domDomCongrEquiv e) f) (ContinuousMultilinearMap.domDomCongr e f)","decl":"/-- An equivalence of the index set defines an equivalence between the spaces of continuous\nmultilinear maps. In case of normed spaces, this is a linear isometric equivalence, see\n`ContinuousMultilinearMap.domDomCongrₗᵢ`. -/\n@[simps]\ndef domDomCongrEquiv {ι' : Type*} (e : ι ≃ ι') :\n    ContinuousMultilinearMap R (fun _ : ι => M₂) M₃ ≃\n      ContinuousMultilinearMap R (fun _ : ι' => M₂) M₃ where\n  toFun := domDomCongr e\n  invFun := domDomCongr e.symm\n  left_inv _ := ext fun _ => by simp\n  right_inv _ := ext fun _ => by simp\n\n"}
{"name":"ContinuousMultilinearMap.domDomCongrEquiv_symm_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M₂\ninst✝² : Module R M₃\ninst✝¹ : TopologicalSpace M₂\ninst✝ : TopologicalSpace M₃\nι' : Type u_1\ne : Equiv ι ι'\nf : ContinuousMultilinearMap R (fun x => M₂) M₃\n⊢ Eq ((ContinuousMultilinearMap.domDomCongrEquiv e).symm f) (ContinuousMultilinearMap.domDomCongr e.symm f)","decl":"/-- An equivalence of the index set defines an equivalence between the spaces of continuous\nmultilinear maps. In case of normed spaces, this is a linear isometric equivalence, see\n`ContinuousMultilinearMap.domDomCongrₗᵢ`. -/\n@[simps]\ndef domDomCongrEquiv {ι' : Type*} (e : ι ≃ ι') :\n    ContinuousMultilinearMap R (fun _ : ι => M₂) M₃ ≃\n      ContinuousMultilinearMap R (fun _ : ι' => M₂) M₃ where\n  toFun := domDomCongr e\n  invFun := domDomCongr e.symm\n  left_inv _ := ext fun _ => by simp\n  right_inv _ := ext fun _ => by simp\n\n"}
{"name":"ContinuousMultilinearMap.linearDeriv_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : (i : ι) → Module R (M₁ i)\ninst✝⁵ : Module R M₂\ninst✝⁴ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝³ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝² : ContinuousAdd M₂\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nx y : (i : ι) → M₁ i\n⊢ Eq ((f.linearDeriv x) y) (Finset.univ.sum fun i => f (Function.update x i (y i)))","decl":"@[simp]\nlemma linearDeriv_apply : f.linearDeriv x y = ∑ i, f (Function.update x i (y i)) := by\n  unfold linearDeriv toContinuousLinearMap\n  simp only [ContinuousLinearMap.coe_sum', ContinuousLinearMap.coe_comp',\n    ContinuousLinearMap.coe_mk', LinearMap.coe_mk, LinearMap.coe_toAddHom, Finset.sum_apply]\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.cons_add","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nn : Nat\nM : Fin n.succ → Type w\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : Fin n.succ) → Module R (M i)\ninst✝² : Module R M₂\ninst✝¹ : (i : Fin n.succ) → TopologicalSpace (M i)\ninst✝ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M M₂\nm : (i : Fin n) → M i.succ\nx y : M 0\n⊢ Eq (f (Fin.cons (HAdd.hAdd x y) m)) (HAdd.hAdd (f (Fin.cons x m)) (f (Fin.cons y m)))","decl":"/-- In the specific case of continuous multilinear maps on spaces indexed by `Fin (n+1)`, where one\ncan build an element of `(i : Fin (n+1)) → M i` using `cons`, one can express directly the\nadditivity of a multilinear map along the first variable. -/\ntheorem cons_add (f : ContinuousMultilinearMap R M M₂) (m : ∀ i : Fin n, M i.succ) (x y : M 0) :\n    f (cons (x + y) m) = f (cons x m) + f (cons y m) :=\n  f.toMultilinearMap.cons_add m x y\n\n"}
{"name":"ContinuousMultilinearMap.cons_smul","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nn : Nat\nM : Fin n.succ → Type w\nM₂ : Type w₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : Fin n.succ) → Module R (M i)\ninst✝² : Module R M₂\ninst✝¹ : (i : Fin n.succ) → TopologicalSpace (M i)\ninst✝ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M M₂\nm : (i : Fin n) → M i.succ\nc : R\nx : M 0\n⊢ Eq (f (Fin.cons (HSMul.hSMul c x) m)) (HSMul.hSMul c (f (Fin.cons x m)))","decl":"/-- In the specific case of continuous multilinear maps on spaces indexed by `Fin (n+1)`, where one\ncan build an element of `(i : Fin (n+1)) → M i` using `cons`, one can express directly the\nmultiplicativity of a multilinear map along the first variable. -/\ntheorem cons_smul (f : ContinuousMultilinearMap R M M₂) (m : ∀ i : Fin n, M i.succ) (c : R)\n    (x : M 0) : f (cons (c • x) m) = c • f (cons x m) :=\n  f.toMultilinearMap.cons_smul m c x\n\n"}
{"name":"ContinuousMultilinearMap.map_piecewise_add","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm m' : (i : ι) → M₁ i\nt : Finset ι\n⊢ Eq (f (t.piecewise (HAdd.hAdd m m') m')) (t.powerset.sum fun s => f (s.piecewise m m'))","decl":"theorem map_piecewise_add [DecidableEq ι] (m m' : ∀ i, M₁ i) (t : Finset ι) :\n    f (t.piecewise (m + m') m') = ∑ s ∈ t.powerset, f (s.piecewise m m') :=\n  f.toMultilinearMap.map_piecewise_add _ _ _\n\n"}
{"name":"ContinuousMultilinearMap.map_add_univ","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁸ : Semiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝² : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nm m' : (i : ι) → M₁ i\n⊢ Eq (f (HAdd.hAdd m m')) (Finset.univ.sum fun s => f (s.piecewise m m'))","decl":"/-- Additivity of a continuous multilinear map along all coordinates at the same time,\nwriting `f (m + m')` as the sum of `f (s.piecewise m m')` over all sets `s`. -/\ntheorem map_add_univ [DecidableEq ι] [Fintype ι] (m m' : ∀ i, M₁ i) :\n    f (m + m') = ∑ s : Finset ι, f (s.piecewise m m') :=\n  f.toMultilinearMap.map_add_univ _ _\n\n"}
{"name":"ContinuousMultilinearMap.map_sum_finset","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁸ : Semiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝² : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\nα : ι → Type u_1\ninst✝¹ : Fintype ι\ng : (i : ι) → α i → M₁ i\nA : (i : ι) → Finset (α i)\ninst✝ : DecidableEq ι\n⊢ Eq (f fun i => (A i).sum fun j => g i j) ((Fintype.piFinset A).sum fun r => f fun i => g i (r i))","decl":"/-- If `f` is continuous multilinear, then `f (Σ_{j₁ ∈ A₁} g₁ j₁, ..., Σ_{jₙ ∈ Aₙ} gₙ jₙ)` is the\nsum of `f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions with `r 1 ∈ A₁`, ...,\n`r n ∈ Aₙ`. This follows from multilinearity by expanding successively with respect to each\ncoordinate. -/\ntheorem map_sum_finset [DecidableEq ι] :\n    (f fun i => ∑ j ∈ A i, g i j) = ∑ r ∈ piFinset A, f fun i => g i (r i) :=\n  f.toMultilinearMap.map_sum_finset _ _\n\n"}
{"name":"ContinuousMultilinearMap.map_sum","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : (i : ι) → Module R (M₁ i)\ninst✝⁵ : Module R M₂\ninst✝⁴ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝³ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\nα : ι → Type u_1\ninst✝² : Fintype ι\ng : (i : ι) → α i → M₁ i\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Fintype (α i)\n⊢ Eq (f fun i => Finset.univ.sum fun j => g i j) (Finset.univ.sum fun r => f fun i => g i (r i))","decl":"/-- If `f` is continuous multilinear, then `f (Σ_{j₁} g₁ j₁, ..., Σ_{jₙ} gₙ jₙ)` is the sum of\n`f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions `r`. This follows from\nmultilinearity by expanding successively with respect to each coordinate. -/\ntheorem map_sum [DecidableEq ι] [∀ i, Fintype (α i)] :\n    (f fun i => ∑ j, g i j) = ∑ r : ∀ i, α i, f fun i => g i (r i) :=\n  f.toMultilinearMap.map_sum _\n\n"}
{"name":"ContinuousMultilinearMap.coe_restrictScalars","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝¹² : Semiring R\ninst✝¹¹ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝¹⁰ : AddCommMonoid M₂\ninst✝⁹ : (i : ι) → Module R (M₁ i)\ninst✝⁸ : Module R M₂\ninst✝⁷ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝⁶ : TopologicalSpace M₂\nA : Type u_1\ninst✝⁵ : Semiring A\ninst✝⁴ : SMul R A\ninst✝³ : (i : ι) → Module A (M₁ i)\ninst✝² : Module A M₂\ninst✝¹ : ∀ (i : ι), IsScalarTower R A (M₁ i)\ninst✝ : IsScalarTower R A M₂\nf : ContinuousMultilinearMap A M₁ M₂\n⊢ Eq ⇑(ContinuousMultilinearMap.restrictScalars R f) ⇑f","decl":"@[simp]\ntheorem coe_restrictScalars (f : ContinuousMultilinearMap A M₁ M₂) : ⇑(f.restrictScalars R) = f :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.map_update_sub","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Ring R\ninst✝⁶ : (i : ι) → AddCommGroup (M₁ i)\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx y : M₁ i\n⊢ Eq (f (Function.update m i (HSub.hSub x y))) (HSub.hSub (f (Function.update m i x)) (f (Function.update m i y)))","decl":"@[simp]\ntheorem map_update_sub [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x y : M₁ i) :\n    f (update m i (x - y)) = f (update m i x) - f (update m i y) :=\n  f.toMultilinearMap.map_update_sub _ _ _ _\n\n"}
{"name":"ContinuousMultilinearMap.map_sub","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Ring R\ninst✝⁶ : (i : ι) → AddCommGroup (M₁ i)\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx y : M₁ i\n⊢ Eq (f (Function.update m i (HSub.hSub x y))) (HSub.hSub (f (Function.update m i x)) (f (Function.update m i y)))","decl":"@[deprecated (since := \"2024-11-03\")]\nprotected alias map_sub := ContinuousMultilinearMap.map_update_sub\n\n"}
{"name":"ContinuousMultilinearMap.neg_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Ring R\ninst✝⁶ : (i : ι) → AddCommGroup (M₁ i)\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝ : TopologicalAddGroup M₂\nm : (i : ι) → M₁ i\n⊢ Eq ((Neg.neg f) m) (Neg.neg (f m))","decl":"@[simp]\ntheorem neg_apply (m : ∀ i, M₁ i) : (-f) m = -f m :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.sub_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : Ring R\ninst✝⁶ : (i : ι) → AddCommGroup (M₁ i)\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf f' : ContinuousMultilinearMap R M₁ M₂\ninst✝ : TopologicalAddGroup M₂\nm : (i : ι) → M₁ i\n⊢ Eq ((HSub.hSub f f') m) (HSub.hSub (f m) (f' m))","decl":"@[simp]\ntheorem sub_apply (m : ∀ i, M₁ i) : (f - f') m = f m - f' m :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.neg_prod_neg","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝¹¹ : Ring R\ninst✝¹⁰ : (i : ι) → AddCommGroup (M₁ i)\ninst✝⁹ : AddCommGroup M₂\ninst✝⁸ : (i : ι) → Module R (M₁ i)\ninst✝⁷ : Module R M₂\ninst✝⁶ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : TopologicalAddGroup M₂\ninst✝³ : AddCommGroup M₃\ninst✝² : Module R M₃\ninst✝¹ : TopologicalSpace M₃\ninst✝ : TopologicalAddGroup M₃\nf : ContinuousMultilinearMap R M₁ M₂\ng : ContinuousMultilinearMap R M₁ M₃\n⊢ Eq ((Neg.neg f).prod (Neg.neg g)) (Neg.neg (f.prod g))","decl":"theorem neg_prod_neg [AddCommGroup M₃] [Module R M₃] [TopologicalSpace M₃] [TopologicalAddGroup M₃]\n    (f : ContinuousMultilinearMap R M₁ M₂) (g : ContinuousMultilinearMap R M₁ M₃) :\n    (-f).prod (-g) = - f.prod g :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.sub_prod_sub","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nM₃ : Type w₃\ninst✝¹¹ : Ring R\ninst✝¹⁰ : (i : ι) → AddCommGroup (M₁ i)\ninst✝⁹ : AddCommGroup M₂\ninst✝⁸ : (i : ι) → Module R (M₁ i)\ninst✝⁷ : Module R M₂\ninst✝⁶ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : TopologicalAddGroup M₂\ninst✝³ : AddCommGroup M₃\ninst✝² : Module R M₃\ninst✝¹ : TopologicalSpace M₃\ninst✝ : TopologicalAddGroup M₃\nf₁ f₂ : ContinuousMultilinearMap R M₁ M₂\ng₁ g₂ : ContinuousMultilinearMap R M₁ M₃\n⊢ Eq ((HSub.hSub f₁ f₂).prod (HSub.hSub g₁ g₂)) (HSub.hSub (f₁.prod g₁) (f₂.prod g₂))","decl":"theorem sub_prod_sub [AddCommGroup M₃] [Module R M₃] [TopologicalSpace M₃] [TopologicalAddGroup M₃]\n    (f₁ f₂ : ContinuousMultilinearMap R M₁ M₂) (g₁ g₂ : ContinuousMultilinearMap R M₁ M₃) :\n    (f₁ - f₂).prod (g₁ - g₂) = f₁.prod g₁ - f₂.prod g₂ :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.map_piecewise_smul","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : CommSemiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nc : ι → R\nm : (i : ι) → M₁ i\ns : Finset ι\n⊢ Eq (f (s.piecewise (fun i => HSMul.hSMul (c i) (m i)) m)) (HSMul.hSMul (s.prod fun i => c i) (f m))","decl":"theorem map_piecewise_smul [DecidableEq ι] (c : ι → R) (m : ∀ i, M₁ i) (s : Finset ι) :\n    f (s.piecewise (fun i => c i • m i) m) = (∏ i ∈ s, c i) • f m :=\n  f.toMultilinearMap.map_piecewise_smul _ _ _\n\n"}
{"name":"ContinuousMultilinearMap.map_smul_univ","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁷ : CommSemiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\nf : ContinuousMultilinearMap R M₁ M₂\ninst✝ : Fintype ι\nc : ι → R\nm : (i : ι) → M₁ i\n⊢ Eq (f fun i => HSMul.hSMul (c i) (m i)) (HSMul.hSMul (Finset.univ.prod fun i => c i) (f m))","decl":"/-- Multiplicativity of a continuous multilinear map along all coordinates at the same time,\nwriting `f (fun i ↦ c i • m i)` as `(∏ i, c i) • f m`. -/\ntheorem map_smul_univ [Fintype ι] (c : ι → R) (m : ∀ i, M₁ i) :\n    (f fun i => c i • m i) = (∏ i, c i) • f m :=\n  f.toMultilinearMap.map_smul_univ _ _\n\n"}
{"name":"ContinuousMultilinearMap.toMultilinearMapLinear_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"ι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\nR' : Type u_1\nA : Type u_2\ninst✝¹¹ : Semiring R'\ninst✝¹⁰ : Semiring A\ninst✝⁹ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝⁶ : TopologicalSpace M₂\ninst✝⁵ : ContinuousAdd M₂\ninst✝⁴ : (i : ι) → Module A (M₁ i)\ninst✝³ : Module A M₂\ninst✝² : Module R' M₂\ninst✝¹ : ContinuousConstSMul R' M₂\ninst✝ : SMulCommClass A R' M₂\nself : ContinuousMultilinearMap A M₁ M₂\n⊢ Eq (ContinuousMultilinearMap.toMultilinearMapLinear self) self.toMultilinearMap","decl":"/-- Linear map version of the map `toMultilinearMap` associating to a continuous multilinear map\nthe corresponding multilinear map. -/\n@[simps]\ndef toMultilinearMapLinear : ContinuousMultilinearMap A M₁ M₂ →ₗ[R'] MultilinearMap A M₁ M₂ where\n  toFun := toMultilinearMap\n  map_add' := toMultilinearMap_add\n  map_smul' := toMultilinearMap_smul\n\n"}
{"name":"ContinuousMultilinearMap.piLinearEquiv_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"ι : Type v\nM₁ : ι → Type w₁\nR' : Type u_1\nA : Type u_2\ninst✝¹¹ : Semiring R'\ninst✝¹⁰ : Semiring A\ninst✝⁹ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁸ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝⁷ : (i : ι) → Module A (M₁ i)\nι' : Type u_3\nM' : ι' → Type u_4\ninst✝⁶ : (i : ι') → AddCommMonoid (M' i)\ninst✝⁵ : (i : ι') → TopologicalSpace (M' i)\ninst✝⁴ : ∀ (i : ι'), ContinuousAdd (M' i)\ninst✝³ : (i : ι') → Module R' (M' i)\ninst✝² : (i : ι') → Module A (M' i)\ninst✝¹ : ∀ (i : ι'), SMulCommClass A R' (M' i)\ninst✝ : ∀ (i : ι'), ContinuousConstSMul R' (M' i)\na✝ : (i : ι') → ContinuousMultilinearMap A M₁ (M' i)\n⊢ Eq (ContinuousMultilinearMap.piLinearEquiv a✝) (ContinuousMultilinearMap.pi a✝)","decl":"/-- `ContinuousMultilinearMap.pi` as a `LinearEquiv`. -/\n@[simps (config := { simpRhs := true })]\ndef piLinearEquiv {ι' : Type*} {M' : ι' → Type*} [∀ i, AddCommMonoid (M' i)]\n    [∀ i, TopologicalSpace (M' i)] [∀ i, ContinuousAdd (M' i)] [∀ i, Module R' (M' i)]\n    [∀ i, Module A (M' i)] [∀ i, SMulCommClass A R' (M' i)] [∀ i, ContinuousConstSMul R' (M' i)] :\n    (∀ i, ContinuousMultilinearMap A M₁ (M' i)) ≃ₗ[R'] ContinuousMultilinearMap A M₁ (∀ i, M' i) :=\n  { piEquiv with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }\n\n"}
{"name":"ContinuousMultilinearMap.piLinearEquiv_symm_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"ι : Type v\nM₁ : ι → Type w₁\nR' : Type u_1\nA : Type u_2\ninst✝¹¹ : Semiring R'\ninst✝¹⁰ : Semiring A\ninst✝⁹ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁸ : (i : ι) → TopologicalSpace (M₁ i)\ninst✝⁷ : (i : ι) → Module A (M₁ i)\nι' : Type u_3\nM' : ι' → Type u_4\ninst✝⁶ : (i : ι') → AddCommMonoid (M' i)\ninst✝⁵ : (i : ι') → TopologicalSpace (M' i)\ninst✝⁴ : ∀ (i : ι'), ContinuousAdd (M' i)\ninst✝³ : (i : ι') → Module R' (M' i)\ninst✝² : (i : ι') → Module A (M' i)\ninst✝¹ : ∀ (i : ι'), SMulCommClass A R' (M' i)\ninst✝ : ∀ (i : ι'), ContinuousConstSMul R' (M' i)\na✝ : ContinuousMultilinearMap A M₁ ((i : ι') → M' i)\ni : ι'\n⊢ Eq (ContinuousMultilinearMap.piLinearEquiv.symm a✝ i) ((ContinuousLinearMap.proj i).compContinuousMultilinearMap a✝)","decl":"/-- `ContinuousMultilinearMap.pi` as a `LinearEquiv`. -/\n@[simps (config := { simpRhs := true })]\ndef piLinearEquiv {ι' : Type*} {M' : ι' → Type*} [∀ i, AddCommMonoid (M' i)]\n    [∀ i, TopologicalSpace (M' i)] [∀ i, ContinuousAdd (M' i)] [∀ i, Module R' (M' i)]\n    [∀ i, Module A (M' i)] [∀ i, SMulCommClass A R' (M' i)] [∀ i, ContinuousConstSMul R' (M' i)] :\n    (∀ i, ContinuousMultilinearMap A M₁ (M' i)) ≃ₗ[R'] ContinuousMultilinearMap A M₁ (∀ i, M' i) :=\n  { piEquiv with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }\n\n"}
{"name":"ContinuousMultilinearMap.mkPiAlgebra_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nA : Type u_1\ninst✝⁵ : Fintype ι\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring A\ninst✝² : Algebra R A\ninst✝¹ : TopologicalSpace A\ninst✝ : ContinuousMul A\nm : ι → A\n⊢ Eq ((ContinuousMultilinearMap.mkPiAlgebra R ι A) m) (Finset.univ.prod fun i => m i)","decl":"@[simp]\ntheorem mkPiAlgebra_apply (m : ι → A) : ContinuousMultilinearMap.mkPiAlgebra R ι A m = ∏ i, m i :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.mkPiAlgebraFin_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nn : Nat\nA : Type u_1\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : TopologicalSpace A\ninst✝ : ContinuousMul A\nm : Fin n → A\n⊢ Eq ((ContinuousMultilinearMap.mkPiAlgebraFin R n A) m) (List.ofFn m).prod","decl":"@[simp]\ntheorem mkPiAlgebraFin_apply (m : Fin n → A) :\n    ContinuousMultilinearMap.mkPiAlgebraFin R n A m = (List.ofFn m).prod :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.smulRight_toMultilinearMap","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁸ : CommSemiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : TopologicalSpace R\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : ContinuousSMul R M₂\nf : ContinuousMultilinearMap R M₁ R\nz : M₂\n⊢ Eq (f.smulRight z).toMultilinearMap (f.smulRight z)","decl":"/-- Given a continuous `R`-multilinear map `f` taking values in `R`, `f.smulRight z` is the\ncontinuous multilinear map sending `m` to `f m • z`. -/\n@[simps! toMultilinearMap apply]\ndef smulRight : ContinuousMultilinearMap R M₁ M₂ where\n  toMultilinearMap := f.toMultilinearMap.smulRight z\n  cont := f.cont.smul continuous_const\n\n"}
{"name":"ContinuousMultilinearMap.smulRight_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM₁ : ι → Type w₁\nM₂ : Type w₂\ninst✝⁸ : CommSemiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : TopologicalSpace R\ninst✝² : (i : ι) → TopologicalSpace (M₁ i)\ninst✝¹ : TopologicalSpace M₂\ninst✝ : ContinuousSMul R M₂\nf : ContinuousMultilinearMap R M₁ R\nz : M₂\na✝ : (i : ι) → M₁ i\n⊢ Eq ((f.smulRight z) a✝) (HSMul.hSMul (f a✝) z)","decl":"/-- Given a continuous `R`-multilinear map `f` taking values in `R`, `f.smulRight z` is the\ncontinuous multilinear map sending `m` to `f m • z`. -/\n@[simps! toMultilinearMap apply]\ndef smulRight : ContinuousMultilinearMap R M₁ M₂ where\n  toMultilinearMap := f.toMultilinearMap.smulRight z\n  cont := f.cont.smul continuous_const\n\n"}
{"name":"ContinuousMultilinearMap.mkPiRing_apply","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM : Type u_1\ninst✝⁷ : Fintype ι\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace R\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousMul R\ninst✝ : ContinuousSMul R M\nz : M\nm : ι → R\n⊢ Eq ((ContinuousMultilinearMap.mkPiRing R ι z) m) (HSMul.hSMul (Finset.univ.prod fun i => m i) z)","decl":"@[simp]\ntheorem mkPiRing_apply (z : M) (m : ι → R) :\n    (ContinuousMultilinearMap.mkPiRing R ι z : (ι → R) → M) m = (∏ i, m i) • z :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.mkPiRing_apply_one_eq_self","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM : Type u_1\ninst✝⁷ : Fintype ι\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace R\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousMul R\ninst✝ : ContinuousSMul R M\nf : ContinuousMultilinearMap R (fun x => R) M\n⊢ Eq (ContinuousMultilinearMap.mkPiRing R ι (f fun x => 1)) f","decl":"theorem mkPiRing_apply_one_eq_self (f : ContinuousMultilinearMap R (fun _ : ι => R) M) :\n    ContinuousMultilinearMap.mkPiRing R ι (f fun _ => 1) = f :=\n  toMultilinearMap_injective f.toMultilinearMap.mkPiRing_apply_one_eq_self\n\n"}
{"name":"ContinuousMultilinearMap.mkPiRing_eq_iff","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM : Type u_1\ninst✝⁷ : Fintype ι\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace R\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousMul R\ninst✝ : ContinuousSMul R M\nz₁ z₂ : M\n⊢ Iff (Eq (ContinuousMultilinearMap.mkPiRing R ι z₁) (ContinuousMultilinearMap.mkPiRing R ι z₂)) (Eq z₁ z₂)","decl":"theorem mkPiRing_eq_iff {z₁ z₂ : M} :\n    ContinuousMultilinearMap.mkPiRing R ι z₁ = ContinuousMultilinearMap.mkPiRing R ι z₂ ↔\n      z₁ = z₂ := by\n  rw [← toMultilinearMap_injective.eq_iff]\n  exact MultilinearMap.mkPiRing_eq_iff\n\n"}
{"name":"ContinuousMultilinearMap.mkPiRing_zero","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM : Type u_1\ninst✝⁷ : Fintype ι\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace R\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousMul R\ninst✝ : ContinuousSMul R M\n⊢ Eq (ContinuousMultilinearMap.mkPiRing R ι 0) 0","decl":"theorem mkPiRing_zero : ContinuousMultilinearMap.mkPiRing R ι (0 : M) = 0 := by\n  ext; rw [mkPiRing_apply, smul_zero, ContinuousMultilinearMap.zero_apply]\n\n"}
{"name":"ContinuousMultilinearMap.mkPiRing_eq_zero_iff","module":"Mathlib.Topology.Algebra.Module.Multilinear.Basic","initialProofState":"R : Type u\nι : Type v\nM : Type u_1\ninst✝⁷ : Fintype ι\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : TopologicalSpace R\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousMul R\ninst✝ : ContinuousSMul R M\nz : M\n⊢ Iff (Eq (ContinuousMultilinearMap.mkPiRing R ι z) 0) (Eq z 0)","decl":"theorem mkPiRing_eq_zero_iff (z : M) : ContinuousMultilinearMap.mkPiRing R ι z = 0 ↔ z = 0 := by\n  rw [← mkPiRing_zero, mkPiRing_eq_iff]\n\n"}
