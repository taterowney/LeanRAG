{"name":"card_dvd_exponent_pow_rank","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝¹ : CommGroup G\ninst✝ : Group.FG G\n⊢ Dvd.dvd (Nat.card G) (HPow.hPow (Monoid.exponent G) (Group.rank G))","decl":"@[to_additive]\ntheorem card_dvd_exponent_pow_rank : Nat.card G ∣ Monoid.exponent G ^ Group.rank G := by\n  classical\n  obtain ⟨S, hS1, hS2⟩ := Group.rank_spec G\n  rw [← hS1, ← Fintype.card_coe, ← Finset.card_univ, ← Finset.prod_const]\n  let f : (∀ g : S, zpowers (g : G)) →* G := noncommPiCoprod fun s t _ x y _ _ => mul_comm x _\n  have hf : Function.Surjective f := by\n    rw [← MonoidHom.range_eq_top, eq_top_iff, ← hS2, closure_le]\n    exact fun g hg => ⟨Pi.mulSingle ⟨g, hg⟩ ⟨g, mem_zpowers g⟩, noncommPiCoprod_mulSingle _ _⟩\n  replace hf := card_dvd_of_surjective f hf\n  rw [Nat.card_pi] at hf\n  refine hf.trans (Finset.prod_dvd_prod_of_dvd _ _ fun g _ => ?_)\n  rw [Nat.card_zpowers]\n  exact Monoid.order_dvd_exponent (g : G)\n\n"}
{"name":"card_dvd_exponent_nsmul_rank","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝¹ : AddCommGroup G\ninst✝ : AddGroup.FG G\n⊢ Dvd.dvd (Nat.card G) (HPow.hPow (AddMonoid.exponent G) (AddGroup.rank G))","decl":"@[to_additive]\ntheorem card_dvd_exponent_pow_rank : Nat.card G ∣ Monoid.exponent G ^ Group.rank G := by\n  classical\n  obtain ⟨S, hS1, hS2⟩ := Group.rank_spec G\n  rw [← hS1, ← Fintype.card_coe, ← Finset.card_univ, ← Finset.prod_const]\n  let f : (∀ g : S, zpowers (g : G)) →* G := noncommPiCoprod fun s t _ x y _ _ => mul_comm x _\n  have hf : Function.Surjective f := by\n    rw [← MonoidHom.range_eq_top, eq_top_iff, ← hS2, closure_le]\n    exact fun g hg => ⟨Pi.mulSingle ⟨g, hg⟩ ⟨g, mem_zpowers g⟩, noncommPiCoprod_mulSingle _ _⟩\n  replace hf := card_dvd_of_surjective f hf\n  rw [Nat.card_pi] at hf\n  refine hf.trans (Finset.prod_dvd_prod_of_dvd _ _ fun g _ => ?_)\n  rw [Nat.card_zpowers]\n  exact Monoid.order_dvd_exponent (g : G)\n\n"}
{"name":"card_dvd_exponent_nsmul_rank'","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝¹ : AddCommGroup G\ninst✝ : AddGroup.FG G\nn : Nat\nhG : ∀ (g : G), Eq (HSMul.hSMul n g) 0\n⊢ Dvd.dvd (Nat.card G) (HPow.hPow n (AddGroup.rank G))","decl":"@[to_additive]\ntheorem card_dvd_exponent_pow_rank' {n : ℕ} (hG : ∀ g : G, g ^ n = 1) :\n    Nat.card G ∣ n ^ Group.rank G :=\n  (card_dvd_exponent_pow_rank G).trans\n    (pow_dvd_pow_of_dvd (Monoid.exponent_dvd_of_forall_pow_eq_one hG) (Group.rank G))\n\n"}
{"name":"card_dvd_exponent_pow_rank'","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝¹ : CommGroup G\ninst✝ : Group.FG G\nn : Nat\nhG : ∀ (g : G), Eq (HPow.hPow g n) 1\n⊢ Dvd.dvd (Nat.card G) (HPow.hPow n (Group.rank G))","decl":"@[to_additive]\ntheorem card_dvd_exponent_pow_rank' {n : ℕ} (hG : ∀ g : G, g ^ n = 1) :\n    Nat.card G ∣ n ^ Group.rank G :=\n  (card_dvd_exponent_pow_rank G).trans\n    (pow_dvd_pow_of_dvd (Monoid.exponent_dvd_of_forall_pow_eq_one hG) (Group.rank G))\n\n"}
{"name":"Subgroup.closure_mul_image_mul_eq_top","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nR S : Set G\nhR : Subgroup.IsComplement (↑H) R\nhR1 : Membership.mem R 1\nhS : Eq (Subgroup.closure S) Top.top\n⊢ Eq (HMul.hMul (↑(Subgroup.closure (Set.image (fun g => HMul.hMul g (Inv.inv ↑(hR.toRightFun g))) (HMul.hMul R S)))) R) Top.top","decl":"theorem closure_mul_image_mul_eq_top\n    (hR : IsComplement H R) (hR1 : (1 : G) ∈ R) (hS : closure S = ⊤) :\n    (closure ((R * S).image fun g => g * (hR.toRightFun g : G)⁻¹)) * R = ⊤ := by\n  let f : G → R := hR.toRightFun\n  let U : Set G := (R * S).image fun g => g * (f g : G)⁻¹\n  change (closure U : Set G) * R = ⊤\n  refine top_le_iff.mp fun g _ => ?_\n  refine closure_induction_right ?_ ?_ ?_ (eq_top_iff.mp hS (mem_top g))\n  · exact ⟨1, (closure U).one_mem, 1, hR1, one_mul 1⟩\n  · rintro - - s hs ⟨u, hu, r, hr, rfl⟩\n    rw [show u * r * s = u * (r * s * (f (r * s) : G)⁻¹) * f (r * s) by group]\n    refine Set.mul_mem_mul ((closure U).mul_mem hu ?_) (f (r * s)).coe_prop\n    exact subset_closure ⟨r * s, Set.mul_mem_mul hr hs, rfl⟩\n  · rintro - - s hs ⟨u, hu, r, hr, rfl⟩\n    rw [show u * r * s⁻¹ = u * (f (r * s⁻¹) * s * r⁻¹)⁻¹ * f (r * s⁻¹) by group]\n    refine Set.mul_mem_mul ((closure U).mul_mem hu ((closure U).inv_mem ?_)) (f (r * s⁻¹)).2\n    refine subset_closure ⟨f (r * s⁻¹) * s, Set.mul_mem_mul (f (r * s⁻¹)).2 hs, ?_⟩\n    rw [mul_right_inj, inv_inj, ← Subtype.coe_mk r hr, ← Subtype.ext_iff, Subtype.coe_mk]\n    apply (isComplement_iff_existsUnique_mul_inv_mem.mp hR (f (r * s⁻¹) * s)).unique\n      (hR.mul_inv_toRightFun_mem (f (r * s⁻¹) * s))\n    rw [mul_assoc, ← inv_inv s, ← mul_inv_rev, inv_inv]\n    exact hR.toRightFun_mul_inv_mem (r * s⁻¹)\n\n"}
{"name":"Subgroup.closure_mul_image_eq","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nR S : Set G\nhR : Subgroup.IsComplement (↑H) R\nhR1 : Membership.mem R 1\nhS : Eq (Subgroup.closure S) Top.top\n⊢ Eq (Subgroup.closure (Set.image (fun g => HMul.hMul g (Inv.inv ↑(hR.toRightFun g))) (HMul.hMul R S))) H","decl":"/-- **Schreier's Lemma**: If `R : Set G` is a `rightTransversal` of `H : Subgroup G`\n  with `1 ∈ R`, and if `G` is generated by `S : Set G`, then `H` is generated by the `Set`\n  `(R * S).image (fun g ↦ g * (hR.toRightFun g)⁻¹)`. -/\ntheorem closure_mul_image_eq (hR : IsComplement H R) (hR1 : (1 : G) ∈ R)\n    (hS : closure S = ⊤) : closure ((R * S).image fun g => g * (hR.toRightFun g : G)⁻¹) = H := by\n  have hU : closure ((R * S).image fun g => g * (hR.toRightFun g : G)⁻¹) ≤ H := by\n    rw [closure_le]\n    rintro - ⟨g, -, rfl⟩\n    exact hR.mul_inv_toRightFun_mem g\n  refine le_antisymm hU fun h hh => ?_\n  obtain ⟨g, hg, r, hr, rfl⟩ :=\n    show h ∈ _ from eq_top_iff.mp (closure_mul_image_mul_eq_top hR hR1 hS) (mem_top h)\n  suffices (⟨r, hr⟩ : R) = (⟨1, hR1⟩ : R) by\n    simpa only [show r = 1 from Subtype.ext_iff.mp this, mul_one]\n  apply (isComplement_iff_existsUnique_mul_inv_mem.mp hR r).unique\n  · rw [Subtype.coe_mk, mul_inv_cancel]\n    exact H.one_mem\n  · rw [Subtype.coe_mk, inv_one, mul_one]\n    exact (H.mul_mem_cancel_left (hU hg)).mp hh\n\n"}
{"name":"Subgroup.closure_mul_image_eq_top","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nR S : Set G\nhR : Subgroup.IsComplement (↑H) R\nhR1 : Membership.mem R 1\nhS : Eq (Subgroup.closure S) Top.top\n⊢ Eq (Subgroup.closure (Set.image (fun g => ⟨HMul.hMul g (Inv.inv ↑(hR.toRightFun g)), ⋯⟩) (HMul.hMul R S))) Top.top","decl":"/-- **Schreier's Lemma**: If `R : Set G` is a `rightTransversal` of `H : Subgroup G`\n  with `1 ∈ R`, and if `G` is generated by `S : Set G`, then `H` is generated by the `Set`\n  `(R * S).image (fun g ↦ g * (hR.toRightFun g)⁻¹)`. -/\ntheorem closure_mul_image_eq_top (hR : IsComplement H R) (hR1 : (1 : G) ∈ R)\n    (hS : closure S = ⊤) : closure ((R * S).image fun g =>\n      ⟨g * (hR.toRightFun g : G)⁻¹, hR.mul_inv_toRightFun_mem g⟩ : Set H) = ⊤ := by\n  rw [eq_top_iff, ← map_subtype_le_map_subtype, MonoidHom.map_closure, Set.image_image]\n  exact (map_subtype_le ⊤).trans (ge_of_eq (closure_mul_image_eq hR hR1 hS))\n\n"}
{"name":"Subgroup.closure_mul_image_eq_top'","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : DecidableEq G\nR S : Finset G\nhR : Subgroup.IsComplement ↑H ↑R\nhR1 : Membership.mem R 1\nhS : Eq (Subgroup.closure ↑S) Top.top\n⊢ Eq (Subgroup.closure ↑(Finset.image (fun g => ⟨HMul.hMul g (Inv.inv ↑(hR.toRightFun g)), ⋯⟩) (HMul.hMul R S))) Top.top","decl":"/-- **Schreier's Lemma**: If `R : Finset G` is a `rightTransversal` of `H : Subgroup G`\n  with `1 ∈ R`, and if `G` is generated by `S : Finset G`, then `H` is generated by the `Finset`\n  `(R * S).image (fun g ↦ g * (hR.toRightFun g)⁻¹)`. -/\ntheorem closure_mul_image_eq_top' [DecidableEq G] {R S : Finset G}\n    (hR : IsComplement (H : Set G) R) (hR1 : (1 : G) ∈ R)\n    (hS : closure (S : Set G) = ⊤) :\n    closure (((R * S).image fun g => ⟨_, hR.mul_inv_toRightFun_mem g⟩ : Finset H) : Set H) = ⊤ := by\n  rw [Finset.coe_image, Finset.coe_mul]\n  exact closure_mul_image_eq_top hR hR1 hS\n\n"}
{"name":"Subgroup.exists_finset_card_le_mul","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.FiniteIndex\nS : Finset G\nhS : Eq (Subgroup.closure ↑S) Top.top\n⊢ Exists fun T => And (LE.le T.card (HMul.hMul H.index S.card)) (Eq (Subgroup.closure ↑T) Top.top)","decl":"theorem exists_finset_card_le_mul [FiniteIndex H] {S : Finset G} (hS : closure (S : Set G) = ⊤) :\n    ∃ T : Finset H, T.card ≤ H.index * S.card ∧ closure (T : Set H) = ⊤ := by\n  letI := H.fintypeQuotientOfFiniteIndex\n  haveI : DecidableEq G := Classical.decEq G\n  obtain ⟨R₀, hR, hR1⟩ := H.exists_isComplement_right 1\n  haveI : Fintype R₀ := Fintype.ofEquiv _ hR.rightQuotientEquiv\n  let R : Finset G := Set.toFinset R₀\n  replace hR : IsComplement (H : Set G) R := by rwa [Set.coe_toFinset]\n  replace hR1 : (1 : G) ∈ R := by rwa [Set.mem_toFinset]\n  refine ⟨_, ?_, closure_mul_image_eq_top' hR hR1 hS⟩\n  calc\n    _ ≤ (R * S).card := Finset.card_image_le\n    _ ≤ (R ×ˢ S).card := Finset.card_image_le\n    _ = R.card * S.card := R.card_product S\n    _ = H.index * S.card := congr_arg (· * S.card) ?_\n  calc\n    R.card = Fintype.card R := (Fintype.card_coe R).symm\n    _ = _ := (Fintype.card_congr hR.rightQuotientEquiv).symm\n    _ = Fintype.card (G ⧸ H) := QuotientGroup.card_quotient_rightRel H\n    _ = H.index := by rw [index_eq_card, Nat.card_eq_fintype_card]\n\n"}
{"name":"Subgroup.fg_of_index_ne_zero","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\nhG : Group.FG G\ninst✝ : H.FiniteIndex\n⊢ Group.FG (Subtype fun x => Membership.mem H x)","decl":"/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\n  group is finitely generated. -/\ninstance fg_of_index_ne_zero [hG : Group.FG G] [FiniteIndex H] : Group.FG H := by\n  obtain ⟨S, hS⟩ := hG.1\n  obtain ⟨T, -, hT⟩ := exists_finset_card_le_mul H hS\n  exact ⟨⟨T, hT⟩⟩\n\n"}
{"name":"Subgroup.rank_le_index_mul_rank","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\nhG : Group.FG G\ninst✝ : H.FiniteIndex\n⊢ LE.le (Group.rank (Subtype fun x => Membership.mem H x)) (HMul.hMul H.index (Group.rank G))","decl":"theorem rank_le_index_mul_rank [hG : Group.FG G] [FiniteIndex H] :\n    Group.rank H ≤ H.index * Group.rank G := by\n  haveI := H.fg_of_index_ne_zero\n  obtain ⟨S, hS₀, hS⟩ := Group.rank_spec G\n  obtain ⟨T, hT₀, hT⟩ := exists_finset_card_le_mul H hS\n  calc\n    Group.rank H ≤ T.card := Group.rank_le H hT\n    _ ≤ H.index * S.card := hT₀\n    _ = H.index * Group.rank G := congr_arg (H.index * ·) hS₀\n\n"}
{"name":"Subgroup.card_commutator_dvd_index_center_pow","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Finite ↑(commutatorSet G)\n⊢ Dvd.dvd (Nat.card (Subtype fun x => Membership.mem (commutator G) x)) (HPow.hPow (Subgroup.center G).index (HAdd.hAdd (HMul.hMul (Subgroup.center G).index (Nat.card ↑(commutatorSet G))) 1))","decl":"/-- If `G` has `n` commutators `[g₁, g₂]`, then `|G'| ∣ [G : Z(G)] ^ ([G : Z(G)] * n + 1)`,\nwhere `G'` denotes the commutator of `G`. -/\ntheorem card_commutator_dvd_index_center_pow [Finite (commutatorSet G)] :\n    Nat.card (_root_.commutator G) ∣\n      (center G).index ^ ((center G).index * Nat.card (commutatorSet G) + 1) := by\n  -- First handle the case when `Z(G)` has infinite index and `[G : Z(G)]` is defined to be `0`\n  by_cases hG : (center G).index = 0\n  · simp_rw [hG, zero_mul, zero_add, pow_one, dvd_zero]\n  haveI : FiniteIndex (center G) := ⟨hG⟩\n  -- Rewrite as `|Z(G) ∩ G'| * [G' : Z(G) ∩ G'] ∣ [G : Z(G)] ^ ([G : Z(G)] * n) * [G : Z(G)]`\n  rw [← ((center G).subgroupOf (_root_.commutator G)).card_mul_index, pow_succ]\n  -- We have `h1 : [G' : Z(G) ∩ G'] ∣ [G : Z(G)]`\n  have h1 := relindex_dvd_index_of_normal (center G) (_root_.commutator G)\n  -- So we can reduce to proving `|Z(G) ∩ G'| ∣ [G : Z(G)] ^ ([G : Z(G)] * n)`\n  refine mul_dvd_mul ?_ h1\n  -- We know that `[G' : Z(G) ∩ G'] < ∞` by `h1` and `hG`\n  haveI : FiniteIndex ((center G).subgroupOf (_root_.commutator G)) :=\n    ⟨ne_zero_of_dvd_ne_zero hG h1⟩\n  -- We have `h2 : rank (Z(G) ∩ G') ≤ [G' : Z(G) ∩ G'] * rank G'` by Schreier's lemma\n  have h2 := rank_le_index_mul_rank ((center G).subgroupOf (_root_.commutator G))\n  -- We have `h3 : [G' : Z(G) ∩ G'] * rank G' ≤ [G : Z(G)] * n` by `h1` and `rank G' ≤ n`\n  have h3 := Nat.mul_le_mul (Nat.le_of_dvd (Nat.pos_of_ne_zero hG) h1) (rank_commutator_le_card G)\n  -- So we can reduce to proving `|Z(G) ∩ G'| ∣ [G : Z(G)] ^ rank (Z(G) ∩ G')`\n  refine dvd_trans ?_ (pow_dvd_pow (center G).index (h2.trans h3))\n  -- `Z(G) ∩ G'` is abelian, so it enough to prove that `g ^ [G : Z(G)] = 1` for `g ∈ Z(G) ∩ G'`\n  apply card_dvd_exponent_pow_rank'\n  intro g\n  -- `Z(G)` is abelian, so `g ∈ Z(G) ∩ G' ≤ G' ≤ ker (transfer : G → Z(G))`\n  have := Abelianization.commutator_subset_ker (MonoidHom.transferCenterPow G) g.1.2\n  -- `transfer g` is defeq to `g ^ [G : Z(G)]`, so we are done\n  simpa only [MonoidHom.mem_ker, Subtype.ext_iff] using this\n\n"}
{"name":"Subgroup.card_commutator_le_of_finite_commutatorSet","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Finite ↑(commutatorSet G)\n⊢ LE.le (Nat.card (Subtype fun x => Membership.mem (commutator G) x)) (Subgroup.cardCommutatorBound (Nat.card ↑(commutatorSet G)))","decl":"/-- A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\n  commutators. -/\ntheorem card_commutator_le_of_finite_commutatorSet [Finite (commutatorSet G)] :\n    Nat.card (_root_.commutator G) ≤ cardCommutatorBound (Nat.card (commutatorSet G)) := by\n  have h1 := index_center_le_pow (closureCommutatorRepresentatives G)\n  have h2 := card_commutator_dvd_index_center_pow (closureCommutatorRepresentatives G)\n  rw [card_commutatorSet_closureCommutatorRepresentatives] at h1 h2\n  rw [card_commutator_closureCommutatorRepresentatives] at h2\n  replace h1 :=\n    h1.trans\n      (Nat.pow_le_pow_of_le_right Finite.card_pos (rank_closureCommutatorRepresentatives_le G))\n  replace h2 := h2.trans (pow_dvd_pow _ (add_le_add_right (mul_le_mul_right' h1 _) 1))\n  rw [← pow_succ] at h2\n  refine (Nat.le_of_dvd ?_ h2).trans (Nat.pow_le_pow_left h1 _)\n  exact pow_pos (Nat.pos_of_ne_zero FiniteIndex.finiteIndex) _\n\n"}
{"name":"Subgroup.instFiniteSubtypeMemCommutatorOfElemCommutatorSet","module":"Mathlib.GroupTheory.Schreier","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Finite ↑(commutatorSet G)\n⊢ Finite (Subtype fun x => Membership.mem (commutator G) x)","decl":"/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ninstance [Finite (commutatorSet G)] : Finite (_root_.commutator G) := by\n  have h2 := card_commutator_dvd_index_center_pow (closureCommutatorRepresentatives G)\n  refine Nat.finite_of_card_ne_zero fun h => ?_\n  rw [card_commutator_closureCommutatorRepresentatives, h, zero_dvd_iff] at h2\n  exact FiniteIndex.finiteIndex (pow_eq_zero h2)\n\n"}
