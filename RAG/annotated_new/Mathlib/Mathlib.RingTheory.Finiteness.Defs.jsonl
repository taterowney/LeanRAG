{"name":"Submodule.fg_def","module":"Mathlib.RingTheory.Finiteness.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Iff N.FG (Exists fun S => And S.Finite (Eq (Submodule.span R S) N))","decl":"theorem fg_def {N : Submodule R M} : N.FG ↔ ∃ S : Set M, S.Finite ∧ span R S = N :=\n  ⟨fun ⟨t, h⟩ => ⟨_, Finset.finite_toSet t, h⟩, by\n    rintro ⟨t', h, rfl⟩\n    rcases Finite.exists_finset_coe h with ⟨t, rfl⟩\n    exact ⟨t, rfl⟩⟩\n\n"}
{"name":"Submodule.fg_iff_addSubmonoid_fg","module":"Mathlib.RingTheory.Finiteness.Defs","initialProofState":"M : Type u_2\ninst✝ : AddCommMonoid M\nP : Submodule Nat M\n⊢ Iff P.FG P.FG","decl":"theorem fg_iff_addSubmonoid_fg (P : Submodule ℕ M) : P.FG ↔ P.toAddSubmonoid.FG :=\n  ⟨fun ⟨S, hS⟩ => ⟨S, by simpa [← span_nat_eq_addSubmonoid_closure] using hS⟩, fun ⟨S, hS⟩ =>\n    ⟨S, by simpa [← span_nat_eq_addSubmonoid_closure] using hS⟩⟩\n\n"}
{"name":"Submodule.fg_iff_add_subgroup_fg","module":"Mathlib.RingTheory.Finiteness.Defs","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\nP : Submodule Int G\n⊢ Iff P.FG P.toAddSubgroup.FG","decl":"theorem fg_iff_add_subgroup_fg {G : Type*} [AddCommGroup G] (P : Submodule ℤ G) :\n    P.FG ↔ P.toAddSubgroup.FG :=\n  ⟨fun ⟨S, hS⟩ => ⟨S, by simpa [← span_int_eq_addSubgroup_closure] using hS⟩, fun ⟨S, hS⟩ =>\n    ⟨S, by simpa [← span_int_eq_addSubgroup_closure] using hS⟩⟩\n\n"}
{"name":"Submodule.fg_iff_exists_fin_generating_family","module":"Mathlib.RingTheory.Finiteness.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Iff N.FG (Exists fun n => Exists fun s => Eq (Submodule.span R (Set.range s)) N)","decl":"theorem fg_iff_exists_fin_generating_family {N : Submodule R M} :\n    N.FG ↔ ∃ (n : ℕ) (s : Fin n → M), span R (range s) = N := by\n  rw [fg_def]\n  constructor\n  · rintro ⟨S, Sfin, hS⟩\n    obtain ⟨n, f, rfl⟩ := Sfin.fin_embedding\n    exact ⟨n, f, hS⟩\n  · rintro ⟨n, s, hs⟩\n    exact ⟨range s, finite_range s, hs⟩\n\n"}
{"name":"Submodule.fg_iff_exists_finite_generating_family","module":"Mathlib.RingTheory.Finiteness.Defs","initialProofState":"A : Type u\ninst✝² : Semiring A\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module A M\nN : Submodule A M\n⊢ Iff N.FG (Exists fun G => Exists fun x => Exists fun g => Eq (Submodule.span A (Set.range g)) N)","decl":"universe w v u in\nlemma fg_iff_exists_finite_generating_family {A : Type u} [Semiring A] {M : Type v}\n    [AddCommMonoid M] [Module A M] {N : Submodule A M} :\n    N.FG ↔ ∃ (G : Type w) (_ : Finite G) (g : G → M), Submodule.span A (Set.range g) = N := by\n  constructor\n  · intro hN\n    obtain ⟨n, f, h⟩ := Submodule.fg_iff_exists_fin_generating_family.1 hN\n    refine ⟨ULift (Fin n), inferInstance, f ∘ ULift.down, ?_⟩\n    convert h\n    ext x\n    simp only [Set.mem_range, Function.comp_apply, ULift.exists]\n  · rintro ⟨G, _, g, hg⟩\n    have := Fintype.ofFinite (range g)\n    exact ⟨(range g).toFinset, by simpa using hg⟩\n\n"}
{"name":"Module.Finite.fg_top","module":"Mathlib.RingTheory.Finiteness.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nself : Module.Finite R M\n⊢ Top.top.FG","decl":"/-- A module over a semiring is `Module.Finite` if it is finitely generated as a module. -/\nprotected class Module.Finite [Semiring R] [AddCommMonoid M] [Module R M] : Prop where\n  fg_top : (⊤ : Submodule R M).FG\n\n"}
{"name":"Module.finite_def","module":"Mathlib.RingTheory.Finiteness.Defs","initialProofState":"R : Type u_6\nM : Type u_7\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (Module.Finite R M) Top.top.FG","decl":"theorem finite_def {R M} [Semiring R] [AddCommMonoid M] [Module R M] :\n    Module.Finite R M ↔ (⊤ : Submodule R M).FG :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"Module.Finite.iff_addMonoid_fg","module":"Mathlib.RingTheory.Finiteness.Defs","initialProofState":"M : Type u_6\ninst✝ : AddCommMonoid M\n⊢ Iff (Module.Finite Nat M) (AddMonoid.FG M)","decl":"theorem iff_addMonoid_fg {M : Type*} [AddCommMonoid M] : Module.Finite ℕ M ↔ AddMonoid.FG M :=\n  ⟨fun h => AddMonoid.fg_def.2 <| (Submodule.fg_iff_addSubmonoid_fg ⊤).1 (finite_def.1 h), fun h =>\n    finite_def.2 <| (Submodule.fg_iff_addSubmonoid_fg ⊤).2 (AddMonoid.fg_def.1 h)⟩\n\n"}
{"name":"Module.Finite.iff_addGroup_fg","module":"Mathlib.RingTheory.Finiteness.Defs","initialProofState":"G : Type u_6\ninst✝ : AddCommGroup G\n⊢ Iff (Module.Finite Int G) (AddGroup.FG G)","decl":"theorem iff_addGroup_fg {G : Type*} [AddCommGroup G] : Module.Finite ℤ G ↔ AddGroup.FG G :=\n  ⟨fun h => AddGroup.fg_def.2 <| (Submodule.fg_iff_add_subgroup_fg ⊤).1 (finite_def.1 h), fun h =>\n    finite_def.2 <| (Submodule.fg_iff_add_subgroup_fg ⊤).2 (AddGroup.fg_def.1 h)⟩\n\n"}
{"name":"Module.Finite.exists_fin","module":"Mathlib.RingTheory.Finiteness.Defs","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Finite R M\n⊢ Exists fun n => Exists fun s => Eq (Submodule.span R (Set.range s)) Top.top","decl":"/-- See also `Module.Finite.exists_fin'`. -/\nlemma exists_fin [Module.Finite R M] : ∃ (n : ℕ) (s : Fin n → M), Submodule.span R (range s) = ⊤ :=\n  Submodule.fg_iff_exists_fin_generating_family.mp fg_top\n\n"}
