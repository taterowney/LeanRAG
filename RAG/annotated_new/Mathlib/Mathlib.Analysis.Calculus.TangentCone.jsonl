{"name":"UniqueDiffWithinAt.dense_tangentCone","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : AddCommMonoid E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\ns : Set E\nx : E\nself : UniqueDiffWithinAt 𝕜 s x\n⊢ Dense ↑(Submodule.span 𝕜 (tangentConeAt 𝕜 s x))","decl":"/-- A property ensuring that the tangent cone to `s` at `x` spans a dense subset of the whole space.\nThe main role of this property is to ensure that the differential within `s` at `x` is unique,\nhence this name. The uniqueness it asserts is proved in `UniqueDiffWithinAt.eq` in\n`Mathlib.Analysis.Calculus.FDeriv.Basic`.\nTo avoid pathologies in dimension 0, we also require that `x` belongs to the closure of `s` (which\nis automatic when `E` is not `0`-dimensional). -/\n@[mk_iff]\nstructure UniqueDiffWithinAt (s : Set E) (x : E) : Prop where\n  dense_tangentCone : Dense (Submodule.span 𝕜 (tangentConeAt 𝕜 s x) : Set E)\n  mem_closure : x ∈ closure s\n\n"}
{"name":"UniqueDiffWithinAt.mem_closure","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : AddCommMonoid E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\ns : Set E\nx : E\nself : UniqueDiffWithinAt 𝕜 s x\n⊢ Membership.mem (closure s) x","decl":"/-- A property ensuring that the tangent cone to `s` at `x` spans a dense subset of the whole space.\nThe main role of this property is to ensure that the differential within `s` at `x` is unique,\nhence this name. The uniqueness it asserts is proved in `UniqueDiffWithinAt.eq` in\n`Mathlib.Analysis.Calculus.FDeriv.Basic`.\nTo avoid pathologies in dimension 0, we also require that `x` belongs to the closure of `s` (which\nis automatic when `E` is not `0`-dimensional). -/\n@[mk_iff]\nstructure UniqueDiffWithinAt (s : Set E) (x : E) : Prop where\n  dense_tangentCone : Dense (Submodule.span 𝕜 (tangentConeAt 𝕜 s x) : Set E)\n  mem_closure : x ∈ closure s\n\n"}
{"name":"uniqueDiffWithinAt_iff","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : AddCommMonoid E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\ns : Set E\nx : E\n⊢ Iff (UniqueDiffWithinAt 𝕜 s x) (And (Dense ↑(Submodule.span 𝕜 (tangentConeAt 𝕜 s x))) (Membership.mem (closure s) x))","decl":"/-- A property ensuring that the tangent cone to `s` at `x` spans a dense subset of the whole space.\nThe main role of this property is to ensure that the differential within `s` at `x` is unique,\nhence this name. The uniqueness it asserts is proved in `UniqueDiffWithinAt.eq` in\n`Mathlib.Analysis.Calculus.FDeriv.Basic`.\nTo avoid pathologies in dimension 0, we also require that `x` belongs to the closure of `s` (which\nis automatic when `E` is not `0`-dimensional). -/\n@[mk_iff]\nstructure UniqueDiffWithinAt (s : Set E) (x : E) : Prop where\n  dense_tangentCone : Dense (Submodule.span 𝕜 (tangentConeAt 𝕜 s x) : Set E)\n  mem_closure : x ∈ closure s\n\n"}
{"name":"mem_tangentConeAt_of_pow_smul","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\nx y : E\ns : Set E\nr : 𝕜\nhr₀ : Ne r 0\nhr : LT.lt (Norm.norm r) 1\nhs : Filter.Eventually (fun n => Membership.mem s (HAdd.hAdd x (HSMul.hSMul (HPow.hPow r n) y))) Filter.atTop\n⊢ Membership.mem (tangentConeAt 𝕜 s x) y","decl":"theorem mem_tangentConeAt_of_pow_smul {r : 𝕜} (hr₀ : r ≠ 0) (hr : ‖r‖ < 1)\n    (hs : ∀ᶠ n : ℕ in atTop, x + r ^ n • y ∈ s) : y ∈ tangentConeAt 𝕜 s x := by\n  refine ⟨fun n ↦ (r ^ n)⁻¹, fun n ↦ r ^ n • y, hs, ?_, ?_⟩\n  · simp only [norm_inv, norm_pow, ← inv_pow]\n    exact tendsto_pow_atTop_atTop_of_one_lt <| (one_lt_inv₀ (norm_pos_iff.2 hr₀)).2 hr\n  · simp only [inv_smul_smul₀ (pow_ne_zero _ hr₀), tendsto_const_nhds]\n\n"}
{"name":"tangentCone_univ","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\nx : E\n⊢ Eq (tangentConeAt 𝕜 Set.univ x) Set.univ","decl":"theorem tangentCone_univ : tangentConeAt 𝕜 univ x = univ :=\n  let ⟨_r, hr₀, hr⟩ := exists_norm_lt_one 𝕜\n  eq_univ_of_forall fun _ ↦ mem_tangentConeAt_of_pow_smul (norm_pos_iff.1 hr₀) hr <|\n    Eventually.of_forall fun _ ↦ mem_univ _\n\n"}
{"name":"tangentCone_mono","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\nx : E\ns t : Set E\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (tangentConeAt 𝕜 s x) (tangentConeAt 𝕜 t x)","decl":"theorem tangentCone_mono (h : s ⊆ t) : tangentConeAt 𝕜 s x ⊆ tangentConeAt 𝕜 t x := by\n  rintro y ⟨c, d, ds, ctop, clim⟩\n  exact ⟨c, d, mem_of_superset ds fun n hn => h hn, ctop, clim⟩\n\n"}
{"name":"tangentConeAt.lim_zero","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ny : E\nα : Type u_5\nl : Filter α\nc : α → 𝕜\nd : α → E\nhc : Filter.Tendsto (fun n => Norm.norm (c n)) l Filter.atTop\nhd : Filter.Tendsto (fun n => HSMul.hSMul (c n) (d n)) l (nhds y)\n⊢ Filter.Tendsto d l (nhds 0)","decl":"/-- Auxiliary lemma ensuring that, under the assumptions defining the tangent cone,\nthe sequence `d` tends to 0 at infinity. -/\ntheorem tangentConeAt.lim_zero {α : Type*} (l : Filter α) {c : α → 𝕜} {d : α → E}\n    (hc : Tendsto (fun n => ‖c n‖) l atTop) (hd : Tendsto (fun n => c n • d n) l (𝓝 y)) :\n    Tendsto d l (𝓝 0) := by\n  have A : Tendsto (fun n => ‖c n‖⁻¹) l (𝓝 0) := tendsto_inv_atTop_zero.comp hc\n  have B : Tendsto (fun n => ‖c n • d n‖) l (𝓝 ‖y‖) := (continuous_norm.tendsto _).comp hd\n  have C : Tendsto (fun n => ‖c n‖⁻¹ * ‖c n • d n‖) l (𝓝 (0 * ‖y‖)) := A.mul B\n  rw [zero_mul] at C\n  have : ∀ᶠ n in l, ‖c n‖⁻¹ * ‖c n • d n‖ = ‖d n‖ := by\n    refine (eventually_ne_of_tendsto_norm_atTop hc 0).mono fun n hn => ?_\n    rw [norm_smul, ← mul_assoc, inv_mul_cancel₀, one_mul]\n    rwa [Ne, norm_eq_zero]\n  have D : Tendsto (fun n => ‖d n‖) l (𝓝 0) := Tendsto.congr' this C\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  exact D\n\n"}
{"name":"tangentCone_mono_nhds","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns t : Set E\nh : LE.le (nhdsWithin x s) (nhdsWithin x t)\n⊢ HasSubset.Subset (tangentConeAt 𝕜 s x) (tangentConeAt 𝕜 t x)","decl":"theorem tangentCone_mono_nhds (h : 𝓝[s] x ≤ 𝓝[t] x) :\n    tangentConeAt 𝕜 s x ⊆ tangentConeAt 𝕜 t x := by\n  rintro y ⟨c, d, ds, ctop, clim⟩\n  refine ⟨c, d, ?_, ctop, clim⟩\n  suffices Tendsto (fun n => x + d n) atTop (𝓝[t] x) from\n    tendsto_principal.1 (tendsto_inf.1 this).2\n  refine (tendsto_inf.2 ⟨?_, tendsto_principal.2 ds⟩).mono_right h\n  simpa only [add_zero] using tendsto_const_nhds.add (tangentConeAt.lim_zero atTop ctop clim)\n\n"}
{"name":"tangentCone_congr","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns t : Set E\nh : Eq (nhdsWithin x s) (nhdsWithin x t)\n⊢ Eq (tangentConeAt 𝕜 s x) (tangentConeAt 𝕜 t x)","decl":"/-- Tangent cone of `s` at `x` depends only on `𝓝[s] x`. -/\ntheorem tangentCone_congr (h : 𝓝[s] x = 𝓝[t] x) : tangentConeAt 𝕜 s x = tangentConeAt 𝕜 t x :=\n  Subset.antisymm (tangentCone_mono_nhds <| le_of_eq h) (tangentCone_mono_nhds <| le_of_eq h.symm)\n\n"}
{"name":"tangentCone_inter_nhds","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns t : Set E\nht : Membership.mem (nhds x) t\n⊢ Eq (tangentConeAt 𝕜 (Inter.inter s t) x) (tangentConeAt 𝕜 s x)","decl":"/-- Intersecting with a neighborhood of the point does not change the tangent cone. -/\ntheorem tangentCone_inter_nhds (ht : t ∈ 𝓝 x) : tangentConeAt 𝕜 (s ∩ t) x = tangentConeAt 𝕜 s x :=\n  tangentCone_congr (nhdsWithin_restrict' _ ht).symm\n\n"}
{"name":"subset_tangentCone_prod_left","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ns : Set E\nt : Set F\ny : F\nht : Membership.mem (closure t) y\n⊢ HasSubset.Subset (Set.image (⇑(LinearMap.inl 𝕜 E F)) (tangentConeAt 𝕜 s x)) (tangentConeAt 𝕜 (SProd.sprod s t) { fst := x, snd := y })","decl":"/-- The tangent cone of a product contains the tangent cone of its left factor. -/\ntheorem subset_tangentCone_prod_left {t : Set F} {y : F} (ht : y ∈ closure t) :\n    LinearMap.inl 𝕜 E F '' tangentConeAt 𝕜 s x ⊆ tangentConeAt 𝕜 (s ×ˢ t) (x, y) := by\n  rintro _ ⟨v, ⟨c, d, hd, hc, hy⟩, rfl⟩\n  have : ∀ n, ∃ d', y + d' ∈ t ∧ ‖c n • d'‖ < ((1 : ℝ) / 2) ^ n := by\n    intro n\n    rcases mem_closure_iff_nhds.1 ht _\n        (eventually_nhds_norm_smul_sub_lt (c n) y (pow_pos one_half_pos n)) with\n      ⟨z, hz, hzt⟩\n    exact ⟨z - y, by simpa using hzt, by simpa using hz⟩\n  choose d' hd' using this\n  refine ⟨c, fun n => (d n, d' n), ?_, hc, ?_⟩\n  · show ∀ᶠ n in atTop, (x, y) + (d n, d' n) ∈ s ×ˢ t\n    filter_upwards [hd] with n hn\n    simp [hn, (hd' n).1]\n  · apply Tendsto.prod_mk_nhds hy _\n    refine squeeze_zero_norm (fun n => (hd' n).2.le) ?_\n    exact tendsto_pow_atTop_nhds_zero_of_lt_one one_half_pos.le one_half_lt_one\n\n"}
{"name":"subset_tangentCone_prod_right","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ns : Set E\nt : Set F\ny : F\nhs : Membership.mem (closure s) x\n⊢ HasSubset.Subset (Set.image (⇑(LinearMap.inr 𝕜 E F)) (tangentConeAt 𝕜 t y)) (tangentConeAt 𝕜 (SProd.sprod s t) { fst := x, snd := y })","decl":"/-- The tangent cone of a product contains the tangent cone of its right factor. -/\ntheorem subset_tangentCone_prod_right {t : Set F} {y : F} (hs : x ∈ closure s) :\n    LinearMap.inr 𝕜 E F '' tangentConeAt 𝕜 t y ⊆ tangentConeAt 𝕜 (s ×ˢ t) (x, y) := by\n  rintro _ ⟨w, ⟨c, d, hd, hc, hy⟩, rfl⟩\n  have : ∀ n, ∃ d', x + d' ∈ s ∧ ‖c n • d'‖ < ((1 : ℝ) / 2) ^ n := by\n    intro n\n    rcases mem_closure_iff_nhds.1 hs _\n        (eventually_nhds_norm_smul_sub_lt (c n) x (pow_pos one_half_pos n)) with\n      ⟨z, hz, hzs⟩\n    exact ⟨z - x, by simpa using hzs, by simpa using hz⟩\n  choose d' hd' using this\n  refine ⟨c, fun n => (d' n, d n), ?_, hc, ?_⟩\n  · show ∀ᶠ n in atTop, (x, y) + (d' n, d n) ∈ s ×ˢ t\n    filter_upwards [hd] with n hn\n    simp [hn, (hd' n).1]\n  · apply Tendsto.prod_mk_nhds _ hy\n    refine squeeze_zero_norm (fun n => (hd' n).2.le) ?_\n    exact tendsto_pow_atTop_nhds_zero_of_lt_one one_half_pos.le one_half_lt_one\n\n"}
{"name":"mapsTo_tangentCone_pi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_5\ninst✝² : DecidableEq ι\nE : ι → Type u_6\ninst✝¹ : (i : ι) → NormedAddCommGroup (E i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (E i)\ns : (i : ι) → Set (E i)\nx : (i : ι) → E i\ni : ι\nhi : ∀ (j : ι), Ne j i → Membership.mem (closure (s j)) (x j)\n⊢ Set.MapsTo (⇑(LinearMap.single 𝕜 E i)) (tangentConeAt 𝕜 (s i) (x i)) (tangentConeAt 𝕜 (Set.univ.pi s) x)","decl":"/-- The tangent cone of a product contains the tangent cone of each factor. -/\ntheorem mapsTo_tangentCone_pi {ι : Type*} [DecidableEq ι] {E : ι → Type*}\n    [∀ i, NormedAddCommGroup (E i)] [∀ i, NormedSpace 𝕜 (E i)] {s : ∀ i, Set (E i)} {x : ∀ i, E i}\n    {i : ι} (hi : ∀ j ≠ i, x j ∈ closure (s j)) :\n    MapsTo (LinearMap.single 𝕜 E i) (tangentConeAt 𝕜 (s i) (x i))\n      (tangentConeAt 𝕜 (Set.pi univ s) x) := by\n  rintro w ⟨c, d, hd, hc, hy⟩\n  have : ∀ n, ∀ j ≠ i, ∃ d', x j + d' ∈ s j ∧ ‖c n • d'‖ < (1 / 2 : ℝ) ^ n := fun n j hj ↦ by\n    rcases mem_closure_iff_nhds.1 (hi j hj) _\n        (eventually_nhds_norm_smul_sub_lt (c n) (x j) (pow_pos one_half_pos n)) with\n      ⟨z, hz, hzs⟩\n    exact ⟨z - x j, by simpa using hzs, by simpa using hz⟩\n  choose! d' hd's hcd' using this\n  refine ⟨c, fun n => Function.update (d' n) i (d n), hd.mono fun n hn j _ => ?_, hc,\n      tendsto_pi_nhds.2 fun j => ?_⟩\n  · rcases em (j = i) with (rfl | hj) <;> simp [*]\n  · rcases em (j = i) with (rfl | hj)\n    · simp [hy]\n    · suffices Tendsto (fun n => c n • d' n j) atTop (𝓝 0) by simpa [hj]\n      refine squeeze_zero_norm (fun n => (hcd' n j hj).le) ?_\n      exact tendsto_pow_atTop_nhds_zero_of_lt_one one_half_pos.le one_half_lt_one\n\n"}
{"name":"mem_tangentCone_of_openSegment_subset","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"G : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace Real G\ns : Set G\nx y : G\nh : HasSubset.Subset (openSegment Real x y) s\n⊢ Membership.mem (tangentConeAt Real s x) (HSub.hSub y x)","decl":"/-- If a subset of a real vector space contains an open segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. -/\ntheorem mem_tangentCone_of_openSegment_subset {s : Set G} {x y : G} (h : openSegment ℝ x y ⊆ s) :\n    y - x ∈ tangentConeAt ℝ s x := by\n  refine mem_tangentConeAt_of_pow_smul one_half_pos.ne' (by norm_num) ?_\n  refine (eventually_ne_atTop 0).mono fun n hn ↦ (h ?_)\n  rw [openSegment_eq_image]\n  refine ⟨(1 / 2) ^ n, ⟨?_, ?_⟩, ?_⟩\n  · exact pow_pos one_half_pos _\n  · exact pow_lt_one₀ one_half_pos.le one_half_lt_one hn\n  · simp only [sub_smul, one_smul, smul_sub]; abel\n\n"}
{"name":"mem_tangentCone_of_segment_subset","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"G : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace Real G\ns : Set G\nx y : G\nh : HasSubset.Subset (segment Real x y) s\n⊢ Membership.mem (tangentConeAt Real s x) (HSub.hSub y x)","decl":"/-- If a subset of a real vector space contains a segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. -/\ntheorem mem_tangentCone_of_segment_subset {s : Set G} {x y : G} (h : segment ℝ x y ⊆ s) :\n    y - x ∈ tangentConeAt ℝ s x :=\n  mem_tangentCone_of_openSegment_subset ((openSegment_subset_segment ℝ x y).trans h)\n\n"}
{"name":"zero_mem_tangentCone","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\nx : E\nhx : (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))).NeBot\n⊢ Membership.mem (tangentConeAt 𝕜 s x) 0","decl":"/-- The tangent cone at a non-isolated point contains `0`. -/\ntheorem zero_mem_tangentCone {s : Set E} {x : E} (hx : (𝓝[s \\ {x}] x).NeBot) :\n    0 ∈ tangentConeAt 𝕜 s x := by\n  /- Take a sequence `d n` tending to `0` such that `x + d n ∈ s`. Taking `c n` of the order\n  of `1 / (d n) ^ (1/2)`, then `c n` tends to infinity, but `c n • d n` tends to `0`. By definition,\n  this shows that `0` belongs to the tangent cone. -/\n  obtain ⟨u, -, u_pos, u_lim⟩ :\n      ∃ u, StrictAnti u ∧ (∀ (n : ℕ), 0 < u n) ∧ Tendsto u atTop (𝓝 (0 : ℝ)) :=\n    exists_seq_strictAnti_tendsto (0 : ℝ)\n  have A n : ((s \\ {x}) ∩ Metric.ball x (u n * u n)).Nonempty :=\n    NeBot.nonempty_of_mem hx (inter_mem_nhdsWithin _\n      (Metric.ball_mem_nhds _ (mul_pos (u_pos n) (u_pos n))))\n  choose v hv using A\n  let d n := v n - x\n  have M n : x + d n ∈ s \\ {x} := by simpa [d] using (hv n).1\n  let ⟨r, hr⟩ := exists_one_lt_norm 𝕜\n  have W n := rescale_to_shell hr (u_pos n) (x := d n) (by simpa using (M n).2)\n  choose c c_ne c_le le_c hc using W\n  have c_lim : Tendsto (fun n ↦ ‖c n‖) atTop atTop := by\n    suffices Tendsto (fun n ↦ ‖c n‖⁻¹ ⁻¹) atTop atTop by simpa\n    apply tendsto_inv_nhdsGT_zero.comp\n    simp only [nhdsWithin, tendsto_inf, tendsto_principal, mem_Ioi, norm_pos_iff, ne_eq,\n      eventually_atTop, ge_iff_le]\n    have B (n : ℕ) : ‖c n‖⁻¹ ≤ ‖r‖ * u n := calc\n      ‖c n‖⁻¹\n      _ ≤ (u n)⁻¹ * ‖r‖ * ‖d n‖ := hc n\n      _ ≤ (u n)⁻¹ * ‖r‖ * (u n * u n) := by\n        gcongr\n        · exact mul_nonneg (by simp [(u_pos n).le]) (norm_nonneg _)\n        · specialize hv n\n          simp only [mem_inter_iff, mem_diff, mem_singleton_iff, Metric.mem_ball, dist_eq_norm]\n            at hv\n          simpa using hv.2.le\n      _ = ‖r‖ * u n := by field_simp [(u_pos n).ne']; ring\n    refine ⟨?_, 0, fun n hn ↦ by simpa using c_ne n⟩\n    apply squeeze_zero (fun n ↦ by positivity) B\n    simpa using u_lim.const_mul _\n  refine ⟨c, d, Eventually.of_forall (fun n ↦ by simpa [d] using (hv n).1.1), c_lim, ?_⟩\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  exact squeeze_zero (fun n ↦ by positivity) (fun n ↦ (c_le n).le) u_lim\n\n"}
{"name":"tangentCone_nonempty_of_properSpace","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : ProperSpace E\ns : Set E\nx : E\nhx : (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))).NeBot\n⊢ (Inter.inter (tangentConeAt 𝕜 s x) (HasCompl.compl (Singleton.singleton 0))).Nonempty","decl":"/-- In a proper space, the tangent cone at a non-isolated point is nontrivial. -/\ntheorem tangentCone_nonempty_of_properSpace [ProperSpace E]\n    {s : Set E} {x : E} (hx : (𝓝[s \\ {x}] x).NeBot) :\n    (tangentConeAt 𝕜 s x ∩ {0}ᶜ).Nonempty := by\n  /- Take a sequence `d n` tending to `0` such that `x + d n ∈ s`. Taking `c n` of the order\n  of `1 / d n`. Then `c n • d n` belongs to a fixed annulus. By compactness, one can extract\n  a subsequence converging to a limit `l`. Then `l` is nonzero, and by definition it belongs to\n  the tangent cone. -/\n  obtain ⟨u, -, u_pos, u_lim⟩ :\n      ∃ u, StrictAnti u ∧ (∀ (n : ℕ), 0 < u n) ∧ Tendsto u atTop (𝓝 (0 : ℝ)) :=\n    exists_seq_strictAnti_tendsto (0 : ℝ)\n  have A n : ((s \\ {x}) ∩ Metric.ball x (u n)).Nonempty := by\n    apply NeBot.nonempty_of_mem hx (inter_mem_nhdsWithin _ (Metric.ball_mem_nhds _ (u_pos n)))\n  choose v hv using A\n  let d := fun n ↦ v n - x\n  have M n : x + d n ∈ s \\ {x} := by simpa [d] using (hv n).1\n  let ⟨r, hr⟩ := exists_one_lt_norm 𝕜\n  have W n := rescale_to_shell hr zero_lt_one (x := d n) (by simpa using (M n).2)\n  choose c c_ne c_le le_c hc using W\n  have c_lim : Tendsto (fun n ↦ ‖c n‖) atTop atTop := by\n    suffices Tendsto (fun n ↦ ‖c n‖⁻¹ ⁻¹ ) atTop atTop by simpa\n    apply tendsto_inv_nhdsGT_zero.comp\n    simp only [nhdsWithin, tendsto_inf, tendsto_principal, mem_Ioi, norm_pos_iff, ne_eq,\n      eventually_atTop, ge_iff_le]\n    have B (n : ℕ) : ‖c n‖⁻¹ ≤ 1⁻¹ * ‖r‖ * u n := by\n      apply (hc n).trans\n      gcongr\n      specialize hv n\n      simp only [mem_inter_iff, mem_diff, mem_singleton_iff, Metric.mem_ball, dist_eq_norm] at hv\n      simpa using hv.2.le\n    refine ⟨?_, 0, fun n hn ↦ by simpa using c_ne n⟩\n    apply squeeze_zero (fun n ↦ by positivity) B\n    simpa using u_lim.const_mul _\n  obtain ⟨l, l_mem, φ, φ_strict, hφ⟩ :\n      ∃ l ∈ Metric.closedBall (0 : E) 1 \\ Metric.ball (0 : E) (1 / ‖r‖),\n      ∃ (φ : ℕ → ℕ), StrictMono φ ∧ Tendsto ((fun n ↦ c n • d n) ∘ φ) atTop (𝓝 l) := by\n    apply IsCompact.tendsto_subseq _ (fun n ↦ ?_)\n    · exact (isCompact_closedBall 0 1).diff Metric.isOpen_ball\n    simp only [mem_diff, Metric.mem_closedBall, dist_zero_right, (c_le n).le,\n      Metric.mem_ball, not_lt, true_and, le_c n]\n  refine ⟨l, ?_, ?_⟩; swap\n  · simp only [mem_compl_iff, mem_singleton_iff]\n    contrapose! l_mem\n    simp only [one_div, l_mem, mem_diff, Metric.mem_closedBall, dist_self, zero_le_one,\n      Metric.mem_ball, inv_pos, norm_pos_iff, ne_eq, not_not, true_and]\n    contrapose! hr\n    simp [hr]\n  refine ⟨c ∘ φ, d ∘ φ, ?_, ?_, hφ⟩\n  · exact Eventually.of_forall (fun n ↦ by simpa [d] using (hv (φ n)).1.1)\n  · exact c_lim.comp φ_strict.tendsto_atTop\n\n"}
{"name":"tangentCone_eq_univ","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\ns : Set 𝕜\nx : 𝕜\nhx : (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))).NeBot\n⊢ Eq (tangentConeAt 𝕜 s x) Set.univ","decl":"/-- The tangent cone at a non-isolated point in dimension 1 is the whole space. -/\ntheorem tangentCone_eq_univ {s : Set 𝕜} {x : 𝕜} (hx : (𝓝[s \\ {x}] x).NeBot) :\n    tangentConeAt 𝕜 s x = univ := by\n  apply eq_univ_iff_forall.2 (fun y ↦ ?_)\n  -- first deal with the case of `0`, which has to be handled separately.\n  rcases eq_or_ne y 0 with rfl | hy\n  · exact zero_mem_tangentCone hx\n  /- Assume now `y` is a fixed nonzero scalar. Take a sequence `d n` tending to `0` such\n  that `x + d n ∈ s`. Let `c n = y / d n`. Then `‖c n‖` tends to infinity, and `c n • d n`\n  converges to `y` (as it is equal to `y`). By definition, this shows that `y` belongs to the\n  tangent cone. -/\n  obtain ⟨u, -, u_pos, u_lim⟩ :\n      ∃ u, StrictAnti u ∧ (∀ (n : ℕ), 0 < u n) ∧ Tendsto u atTop (𝓝 (0 : ℝ)) :=\n    exists_seq_strictAnti_tendsto (0 : ℝ)\n  have A n : ((s \\ {x}) ∩ Metric.ball x (u n)).Nonempty := by\n    apply NeBot.nonempty_of_mem hx (inter_mem_nhdsWithin _ (Metric.ball_mem_nhds _ (u_pos n)))\n  choose v hv using A\n  let d := fun n ↦ v n - x\n  have d_ne n : d n ≠ 0 := by\n    simp only [mem_inter_iff, mem_diff, mem_singleton_iff, Metric.mem_ball, d] at hv\n    simpa [d, sub_ne_zero] using (hv n).1.2\n  refine ⟨fun n ↦ y * (d n)⁻¹, d, ?_, ?_, ?_⟩\n  · exact Eventually.of_forall (fun n ↦ by simpa [d] using (hv n).1.1)\n  · simp only [norm_mul, norm_inv]\n    apply (tendsto_const_mul_atTop_of_pos (by simpa using hy)).2\n    apply tendsto_inv_nhdsGT_zero.comp\n    simp only [nhdsWithin, tendsto_inf, tendsto_principal, mem_Ioi, norm_pos_iff, ne_eq,\n      eventually_atTop, ge_iff_le]\n    have B (n : ℕ) : ‖d n‖ ≤ u n := by\n      specialize hv n\n      simp only [mem_inter_iff, mem_diff, mem_singleton_iff, Metric.mem_ball, dist_eq_norm] at hv\n      simpa using hv.2.le\n    refine ⟨?_, 0, fun n hn ↦ by simpa using d_ne n⟩\n    exact squeeze_zero (fun n ↦ by positivity) B u_lim\n  · convert tendsto_const_nhds (α := ℕ) (x := y) with n\n    simp [mul_assoc, inv_mul_cancel₀ (d_ne n)]\n\n"}
{"name":"UniqueDiffOn.uniqueDiffWithinAt","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\ns : Set E\nx : E\nhs : UniqueDiffOn 𝕜 s\nh : Membership.mem s x\n⊢ UniqueDiffWithinAt 𝕜 s x","decl":"theorem UniqueDiffOn.uniqueDiffWithinAt {s : Set E} {x} (hs : UniqueDiffOn 𝕜 s) (h : x ∈ s) :\n    UniqueDiffWithinAt 𝕜 s x :=\n  hs x h\n\n"}
{"name":"uniqueDiffWithinAt_univ","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\nx : E\n⊢ UniqueDiffWithinAt 𝕜 Set.univ x","decl":"theorem uniqueDiffWithinAt_univ : UniqueDiffWithinAt 𝕜 univ x := by\n  rw [uniqueDiffWithinAt_iff, tangentCone_univ]\n  simp\n\n"}
{"name":"uniqueDiffOn_univ","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\n⊢ UniqueDiffOn 𝕜 Set.univ","decl":"theorem uniqueDiffOn_univ : UniqueDiffOn 𝕜 (univ : Set E) :=\n  fun _ _ => uniqueDiffWithinAt_univ\n\n"}
{"name":"uniqueDiffOn_empty","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\n⊢ UniqueDiffOn 𝕜 EmptyCollection.emptyCollection","decl":"theorem uniqueDiffOn_empty : UniqueDiffOn 𝕜 (∅ : Set E) :=\n  fun _ hx => hx.elim\n\n"}
{"name":"UniqueDiffWithinAt.congr_pt","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : TopologicalSpace E\nx y : E\ns : Set E\nh : UniqueDiffWithinAt 𝕜 s x\nhy : Eq x y\n⊢ UniqueDiffWithinAt 𝕜 s y","decl":"theorem UniqueDiffWithinAt.congr_pt (h : UniqueDiffWithinAt 𝕜 s x) (hy : x = y) :\n    UniqueDiffWithinAt 𝕜 s y := hy ▸ h\n\n"}
{"name":"UniqueDiffWithinAt.mono_nhds","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns t : Set E\nh : UniqueDiffWithinAt 𝕜 s x\nst : LE.le (nhdsWithin x s) (nhdsWithin x t)\n⊢ UniqueDiffWithinAt 𝕜 t x","decl":"theorem UniqueDiffWithinAt.mono_nhds (h : UniqueDiffWithinAt 𝕜 s x) (st : 𝓝[s] x ≤ 𝓝[t] x) :\n    UniqueDiffWithinAt 𝕜 t x := by\n  simp only [uniqueDiffWithinAt_iff] at *\n  rw [mem_closure_iff_nhdsWithin_neBot] at h ⊢\n  exact ⟨h.1.mono <| Submodule.span_mono <| tangentCone_mono_nhds st, h.2.mono st⟩\n\n"}
{"name":"UniqueDiffWithinAt.mono","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns t : Set E\nh : UniqueDiffWithinAt 𝕜 s x\nst : HasSubset.Subset s t\n⊢ UniqueDiffWithinAt 𝕜 t x","decl":"theorem UniqueDiffWithinAt.mono (h : UniqueDiffWithinAt 𝕜 s x) (st : s ⊆ t) :\n    UniqueDiffWithinAt 𝕜 t x :=\n  h.mono_nhds <| nhdsWithin_mono _ st\n\n"}
{"name":"uniqueDiffWithinAt_congr","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns t : Set E\nst : Eq (nhdsWithin x s) (nhdsWithin x t)\n⊢ Iff (UniqueDiffWithinAt 𝕜 s x) (UniqueDiffWithinAt 𝕜 t x)","decl":"theorem uniqueDiffWithinAt_congr (st : 𝓝[s] x = 𝓝[t] x) :\n    UniqueDiffWithinAt 𝕜 s x ↔ UniqueDiffWithinAt 𝕜 t x :=\n  ⟨fun h => h.mono_nhds <| le_of_eq st, fun h => h.mono_nhds <| le_of_eq st.symm⟩\n\n"}
{"name":"uniqueDiffWithinAt_inter","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns t : Set E\nht : Membership.mem (nhds x) t\n⊢ Iff (UniqueDiffWithinAt 𝕜 (Inter.inter s t) x) (UniqueDiffWithinAt 𝕜 s x)","decl":"theorem uniqueDiffWithinAt_inter (ht : t ∈ 𝓝 x) :\n    UniqueDiffWithinAt 𝕜 (s ∩ t) x ↔ UniqueDiffWithinAt 𝕜 s x :=\n  uniqueDiffWithinAt_congr <| (nhdsWithin_restrict' _ ht).symm\n\n"}
{"name":"UniqueDiffWithinAt.inter","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns t : Set E\nhs : UniqueDiffWithinAt 𝕜 s x\nht : Membership.mem (nhds x) t\n⊢ UniqueDiffWithinAt 𝕜 (Inter.inter s t) x","decl":"theorem UniqueDiffWithinAt.inter (hs : UniqueDiffWithinAt 𝕜 s x) (ht : t ∈ 𝓝 x) :\n    UniqueDiffWithinAt 𝕜 (s ∩ t) x :=\n  (uniqueDiffWithinAt_inter ht).2 hs\n\n"}
{"name":"uniqueDiffWithinAt_inter'","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns t : Set E\nht : Membership.mem (nhdsWithin x s) t\n⊢ Iff (UniqueDiffWithinAt 𝕜 (Inter.inter s t) x) (UniqueDiffWithinAt 𝕜 s x)","decl":"theorem uniqueDiffWithinAt_inter' (ht : t ∈ 𝓝[s] x) :\n    UniqueDiffWithinAt 𝕜 (s ∩ t) x ↔ UniqueDiffWithinAt 𝕜 s x :=\n  uniqueDiffWithinAt_congr <| (nhdsWithin_restrict'' _ ht).symm\n\n"}
{"name":"UniqueDiffWithinAt.inter'","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns t : Set E\nhs : UniqueDiffWithinAt 𝕜 s x\nht : Membership.mem (nhdsWithin x s) t\n⊢ UniqueDiffWithinAt 𝕜 (Inter.inter s t) x","decl":"theorem UniqueDiffWithinAt.inter' (hs : UniqueDiffWithinAt 𝕜 s x) (ht : t ∈ 𝓝[s] x) :\n    UniqueDiffWithinAt 𝕜 (s ∩ t) x :=\n  (uniqueDiffWithinAt_inter' ht).2 hs\n\n"}
{"name":"uniqueDiffWithinAt_of_mem_nhds","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns : Set E\nh : Membership.mem (nhds x) s\n⊢ UniqueDiffWithinAt 𝕜 s x","decl":"theorem uniqueDiffWithinAt_of_mem_nhds (h : s ∈ 𝓝 x) : UniqueDiffWithinAt 𝕜 s x := by\n  simpa only [univ_inter] using uniqueDiffWithinAt_univ.inter h\n\n"}
{"name":"IsOpen.uniqueDiffWithinAt","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\ns : Set E\nhs : IsOpen s\nxs : Membership.mem s x\n⊢ UniqueDiffWithinAt 𝕜 s x","decl":"theorem IsOpen.uniqueDiffWithinAt (hs : IsOpen s) (xs : x ∈ s) : UniqueDiffWithinAt 𝕜 s x :=\n  uniqueDiffWithinAt_of_mem_nhds (IsOpen.mem_nhds hs xs)\n\n"}
{"name":"UniqueDiffOn.inter","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns t : Set E\nhs : UniqueDiffOn 𝕜 s\nht : IsOpen t\n⊢ UniqueDiffOn 𝕜 (Inter.inter s t)","decl":"theorem UniqueDiffOn.inter (hs : UniqueDiffOn 𝕜 s) (ht : IsOpen t) : UniqueDiffOn 𝕜 (s ∩ t) :=\n  fun x hx => (hs x hx.1).inter (IsOpen.mem_nhds ht hx.2)\n\n"}
{"name":"IsOpen.uniqueDiffOn","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\nhs : IsOpen s\n⊢ UniqueDiffOn 𝕜 s","decl":"theorem IsOpen.uniqueDiffOn (hs : IsOpen s) : UniqueDiffOn 𝕜 s :=\n  fun _ hx => IsOpen.uniqueDiffWithinAt hs hx\n\n"}
{"name":"UniqueDiffWithinAt.prod","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ns : Set E\nt : Set F\ny : F\nhs : UniqueDiffWithinAt 𝕜 s x\nht : UniqueDiffWithinAt 𝕜 t y\n⊢ UniqueDiffWithinAt 𝕜 (SProd.sprod s t) { fst := x, snd := y }","decl":"/-- The product of two sets of unique differentiability at points `x` and `y` has unique\ndifferentiability at `(x, y)`. -/\ntheorem UniqueDiffWithinAt.prod {t : Set F} {y : F} (hs : UniqueDiffWithinAt 𝕜 s x)\n    (ht : UniqueDiffWithinAt 𝕜 t y) : UniqueDiffWithinAt 𝕜 (s ×ˢ t) (x, y) := by\n  rw [uniqueDiffWithinAt_iff] at hs ht ⊢\n  rw [closure_prod_eq]\n  refine ⟨?_, hs.2, ht.2⟩\n  have : _ ≤ Submodule.span 𝕜 (tangentConeAt 𝕜 (s ×ˢ t) (x, y)) := Submodule.span_mono\n    (union_subset (subset_tangentCone_prod_left ht.2) (subset_tangentCone_prod_right hs.2))\n  rw [LinearMap.span_inl_union_inr, SetLike.le_def] at this\n  exact (hs.1.prod ht.1).mono this\n\n"}
{"name":"UniqueDiffWithinAt.univ_pi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_5\ninst✝² : Finite ι\nE : ι → Type u_6\ninst✝¹ : (i : ι) → NormedAddCommGroup (E i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (E i)\ns : (i : ι) → Set (E i)\nx : (i : ι) → E i\nh : ∀ (i : ι), UniqueDiffWithinAt 𝕜 (s i) (x i)\n⊢ UniqueDiffWithinAt 𝕜 (Set.univ.pi s) x","decl":"theorem UniqueDiffWithinAt.univ_pi (ι : Type*) [Finite ι] (E : ι → Type*)\n    [∀ i, NormedAddCommGroup (E i)] [∀ i, NormedSpace 𝕜 (E i)] (s : ∀ i, Set (E i)) (x : ∀ i, E i)\n    (h : ∀ i, UniqueDiffWithinAt 𝕜 (s i) (x i)) : UniqueDiffWithinAt 𝕜 (Set.pi univ s) x := by\n  classical\n  simp only [uniqueDiffWithinAt_iff, closure_pi_set] at h ⊢\n  refine ⟨(dense_pi univ fun i _ => (h i).1).mono ?_, fun i _ => (h i).2⟩\n  norm_cast\n  simp only [← Submodule.iSup_map_single, iSup_le_iff, LinearMap.map_span, Submodule.span_le,\n    ← mapsTo']\n  exact fun i => (mapsTo_tangentCone_pi fun j _ => (h j).2).mono Subset.rfl Submodule.subset_span\n\n"}
{"name":"UniqueDiffWithinAt.pi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_5\ninst✝² : Finite ι\nE : ι → Type u_6\ninst✝¹ : (i : ι) → NormedAddCommGroup (E i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (E i)\ns : (i : ι) → Set (E i)\nx : (i : ι) → E i\nI : Set ι\nh : ∀ (i : ι), Membership.mem I i → UniqueDiffWithinAt 𝕜 (s i) (x i)\n⊢ UniqueDiffWithinAt 𝕜 (I.pi s) x","decl":"theorem UniqueDiffWithinAt.pi (ι : Type*) [Finite ι] (E : ι → Type*)\n    [∀ i, NormedAddCommGroup (E i)] [∀ i, NormedSpace 𝕜 (E i)] (s : ∀ i, Set (E i)) (x : ∀ i, E i)\n    (I : Set ι) (h : ∀ i ∈ I, UniqueDiffWithinAt 𝕜 (s i) (x i)) :\n    UniqueDiffWithinAt 𝕜 (Set.pi I s) x := by\n  classical\n  rw [← Set.univ_pi_piecewise_univ]\n  refine UniqueDiffWithinAt.univ_pi ι E _ _ fun i => ?_\n  by_cases hi : i ∈ I <;> simp [*, uniqueDiffWithinAt_univ]\n\n"}
{"name":"UniqueDiffOn.prod","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nt : Set F\nhs : UniqueDiffOn 𝕜 s\nht : UniqueDiffOn 𝕜 t\n⊢ UniqueDiffOn 𝕜 (SProd.sprod s t)","decl":"/-- The product of two sets of unique differentiability is a set of unique differentiability. -/\ntheorem UniqueDiffOn.prod {t : Set F} (hs : UniqueDiffOn 𝕜 s) (ht : UniqueDiffOn 𝕜 t) :\n    UniqueDiffOn 𝕜 (s ×ˢ t) :=\n  fun ⟨x, y⟩ h => UniqueDiffWithinAt.prod (hs x h.1) (ht y h.2)\n\n"}
{"name":"UniqueDiffOn.pi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_5\ninst✝² : Finite ι\nE : ι → Type u_6\ninst✝¹ : (i : ι) → NormedAddCommGroup (E i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (E i)\ns : (i : ι) → Set (E i)\nI : Set ι\nh : ∀ (i : ι), Membership.mem I i → UniqueDiffOn 𝕜 (s i)\n⊢ UniqueDiffOn 𝕜 (I.pi s)","decl":"/-- The finite product of a family of sets of unique differentiability is a set of unique\ndifferentiability. -/\ntheorem UniqueDiffOn.pi (ι : Type*) [Finite ι] (E : ι → Type*) [∀ i, NormedAddCommGroup (E i)]\n    [∀ i, NormedSpace 𝕜 (E i)] (s : ∀ i, Set (E i)) (I : Set ι)\n    (h : ∀ i ∈ I, UniqueDiffOn 𝕜 (s i)) : UniqueDiffOn 𝕜 (Set.pi I s) :=\n  fun x hx => UniqueDiffWithinAt.pi _ _ _ _ _ fun i hi => h i hi (x i) (hx i hi)\n\n"}
{"name":"UniqueDiffOn.univ_pi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_5\ninst✝² : Finite ι\nE : ι → Type u_6\ninst✝¹ : (i : ι) → NormedAddCommGroup (E i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (E i)\ns : (i : ι) → Set (E i)\nh : ∀ (i : ι), UniqueDiffOn 𝕜 (s i)\n⊢ UniqueDiffOn 𝕜 (Set.univ.pi s)","decl":"/-- The finite product of a family of sets of unique differentiability is a set of unique\ndifferentiability. -/\ntheorem UniqueDiffOn.univ_pi (ι : Type*) [Finite ι] (E : ι → Type*)\n    [∀ i, NormedAddCommGroup (E i)] [∀ i, NormedSpace 𝕜 (E i)] (s : ∀ i, Set (E i))\n    (h : ∀ i, UniqueDiffOn 𝕜 (s i)) : UniqueDiffOn 𝕜 (Set.pi univ s) :=\n  UniqueDiffOn.pi _ _ _ _ fun i _ => h i\n\n"}
{"name":"uniqueDiffWithinAt_convex","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"G : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace Real G\ns : Set G\nconv : Convex Real s\nhs : (interior s).Nonempty\nx : G\nhx : Membership.mem (closure s) x\n⊢ UniqueDiffWithinAt Real s x","decl":"/-- In a real vector space, a convex set with nonempty interior is a set of unique\ndifferentiability at every point of its closure. -/\ntheorem uniqueDiffWithinAt_convex {s : Set G} (conv : Convex ℝ s) (hs : (interior s).Nonempty)\n    {x : G} (hx : x ∈ closure s) : UniqueDiffWithinAt ℝ s x := by\n  rcases hs with ⟨y, hy⟩\n  suffices y - x ∈ interior (tangentConeAt ℝ s x) by\n    refine ⟨Dense.of_closure ?_, hx⟩\n    simp [(Submodule.span ℝ (tangentConeAt ℝ s x)).eq_top_of_nonempty_interior'\n        ⟨y - x, interior_mono Submodule.subset_span this⟩]\n  rw [mem_interior_iff_mem_nhds]\n  replace hy : interior s ∈ 𝓝 y := IsOpen.mem_nhds isOpen_interior hy\n  apply mem_of_superset ((isOpenMap_sub_right x).image_mem_nhds hy)\n  rintro _ ⟨z, zs, rfl⟩\n  refine mem_tangentCone_of_openSegment_subset (Subset.trans ?_ interior_subset)\n  exact conv.openSegment_closure_interior_subset_interior hx zs\n\n"}
{"name":"uniqueDiffOn_convex","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"G : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace Real G\ns : Set G\nconv : Convex Real s\nhs : (interior s).Nonempty\n⊢ UniqueDiffOn Real s","decl":"/-- In a real vector space, a convex set with nonempty interior is a set of unique\ndifferentiability. -/\ntheorem uniqueDiffOn_convex {s : Set G} (conv : Convex ℝ s) (hs : (interior s).Nonempty) :\n    UniqueDiffOn ℝ s :=\n  fun _ xs => uniqueDiffWithinAt_convex conv hs (subset_closure xs)\n\n"}
{"name":"uniqueDiffOn_Ici","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a : Real\n⊢ UniqueDiffOn Real (Set.Ici a)","decl":"theorem uniqueDiffOn_Ici (a : ℝ) : UniqueDiffOn ℝ (Ici a) :=\n  uniqueDiffOn_convex (convex_Ici a) <| by simp only [interior_Ici, nonempty_Ioi]\n\n"}
{"name":"uniqueDiffOn_Iic","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a : Real\n⊢ UniqueDiffOn Real (Set.Iic a)","decl":"theorem uniqueDiffOn_Iic (a : ℝ) : UniqueDiffOn ℝ (Iic a) :=\n  uniqueDiffOn_convex (convex_Iic a) <| by simp only [interior_Iic, nonempty_Iio]\n\n"}
{"name":"uniqueDiffOn_Ioi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a : Real\n⊢ UniqueDiffOn Real (Set.Ioi a)","decl":"theorem uniqueDiffOn_Ioi (a : ℝ) : UniqueDiffOn ℝ (Ioi a) :=\n  isOpen_Ioi.uniqueDiffOn\n\n"}
{"name":"uniqueDiffOn_Iio","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a : Real\n⊢ UniqueDiffOn Real (Set.Iio a)","decl":"theorem uniqueDiffOn_Iio (a : ℝ) : UniqueDiffOn ℝ (Iio a) :=\n  isOpen_Iio.uniqueDiffOn\n\n"}
{"name":"uniqueDiffOn_Icc","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a b : Real\nhab : LT.lt a b\n⊢ UniqueDiffOn Real (Set.Icc a b)","decl":"theorem uniqueDiffOn_Icc {a b : ℝ} (hab : a < b) : UniqueDiffOn ℝ (Icc a b) :=\n  uniqueDiffOn_convex (convex_Icc a b) <| by simp only [interior_Icc, nonempty_Ioo, hab]\n\n"}
{"name":"uniqueDiffOn_Ico","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a b : Real\n⊢ UniqueDiffOn Real (Set.Ico a b)","decl":"theorem uniqueDiffOn_Ico (a b : ℝ) : UniqueDiffOn ℝ (Ico a b) :=\n  if hab : a < b then\n    uniqueDiffOn_convex (convex_Ico a b) <| by simp only [interior_Ico, nonempty_Ioo, hab]\n  else by simp only [Ico_eq_empty hab, uniqueDiffOn_empty]\n\n"}
{"name":"uniqueDiffOn_Ioc","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a b : Real\n⊢ UniqueDiffOn Real (Set.Ioc a b)","decl":"theorem uniqueDiffOn_Ioc (a b : ℝ) : UniqueDiffOn ℝ (Ioc a b) :=\n  if hab : a < b then\n    uniqueDiffOn_convex (convex_Ioc a b) <| by simp only [interior_Ioc, nonempty_Ioo, hab]\n  else by simp only [Ioc_eq_empty hab, uniqueDiffOn_empty]\n\n"}
{"name":"uniqueDiffOn_Ioo","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a b : Real\n⊢ UniqueDiffOn Real (Set.Ioo a b)","decl":"theorem uniqueDiffOn_Ioo (a b : ℝ) : UniqueDiffOn ℝ (Ioo a b) :=\n  isOpen_Ioo.uniqueDiffOn\n\n"}
{"name":"uniqueDiffOn_Icc_zero_one","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"⊢ UniqueDiffOn Real (Set.Icc 0 1)","decl":"/-- The real interval `[0, 1]` is a set of unique differentiability. -/\ntheorem uniqueDiffOn_Icc_zero_one : UniqueDiffOn ℝ (Icc (0 : ℝ) 1) :=\n  uniqueDiffOn_Icc zero_lt_one\n\n"}
{"name":"uniqueDiffWithinAt_Ioo","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a b t : Real\nht : Membership.mem (Set.Ioo a b) t\n⊢ UniqueDiffWithinAt Real (Set.Ioo a b) t","decl":"theorem uniqueDiffWithinAt_Ioo {a b t : ℝ} (ht : t ∈ Set.Ioo a b) :\n    UniqueDiffWithinAt ℝ (Set.Ioo a b) t :=\n  IsOpen.uniqueDiffWithinAt isOpen_Ioo ht\n\n"}
{"name":"uniqueDiffWithinAt_Ioi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a : Real\n⊢ UniqueDiffWithinAt Real (Set.Ioi a) a","decl":"theorem uniqueDiffWithinAt_Ioi (a : ℝ) : UniqueDiffWithinAt ℝ (Ioi a) a :=\n  uniqueDiffWithinAt_convex (convex_Ioi a) (by simp) (by simp)\n\n"}
{"name":"uniqueDiffWithinAt_Iio","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a : Real\n⊢ UniqueDiffWithinAt Real (Set.Iio a) a","decl":"theorem uniqueDiffWithinAt_Iio (a : ℝ) : UniqueDiffWithinAt ℝ (Iio a) a :=\n  uniqueDiffWithinAt_convex (convex_Iio a) (by simp) (by simp)\n\n"}
{"name":"uniqueDiffWithinAt_or_nhdsWithin_eq_bot","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\ns : Set 𝕜\nx : 𝕜\n⊢ Or (UniqueDiffWithinAt 𝕜 s x) (Eq (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))) Bot.bot)","decl":"/-- In one dimension, every point is either a point of unique differentiability, or isolated. -/\ntheorem uniqueDiffWithinAt_or_nhdsWithin_eq_bot (s : Set 𝕜) (x : 𝕜) :\n    UniqueDiffWithinAt 𝕜 s x ∨ 𝓝[s \\ {x}] x = ⊥ := by\n  rcases eq_or_neBot (𝓝[s \\ {x}] x) with h | h\n  · exact Or.inr h\n  refine Or.inl ⟨?_, ?_⟩\n  · simp [tangentCone_eq_univ h]\n  · simp only [mem_closure_iff_nhdsWithin_neBot]\n    apply neBot_of_le (hf := h)\n    exact nhdsWithin_mono _ diff_subset\n\n"}
