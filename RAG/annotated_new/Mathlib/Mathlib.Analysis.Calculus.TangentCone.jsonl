{"name":"UniqueDiffWithinAt.dense_tangentCone","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\ns : Set E\nx : E\nself : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Dense â†‘(Submodule.span ğ•œ (tangentConeAt ğ•œ s x))","decl":"/-- A property ensuring that the tangent cone to `s` at `x` spans a dense subset of the whole space.\nThe main role of this property is to ensure that the differential within `s` at `x` is unique,\nhence this name. The uniqueness it asserts is proved in `UniqueDiffWithinAt.eq` in\n`Mathlib.Analysis.Calculus.FDeriv.Basic`.\nTo avoid pathologies in dimension 0, we also require that `x` belongs to the closure of `s` (which\nis automatic when `E` is not `0`-dimensional). -/\n@[mk_iff]\nstructure UniqueDiffWithinAt (s : Set E) (x : E) : Prop where\n  dense_tangentCone : Dense (Submodule.span ğ•œ (tangentConeAt ğ•œ s x) : Set E)\n  mem_closure : x âˆˆ closure s\n\n"}
{"name":"UniqueDiffWithinAt.mem_closure","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\ns : Set E\nx : E\nself : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Membership.mem (closure s) x","decl":"/-- A property ensuring that the tangent cone to `s` at `x` spans a dense subset of the whole space.\nThe main role of this property is to ensure that the differential within `s` at `x` is unique,\nhence this name. The uniqueness it asserts is proved in `UniqueDiffWithinAt.eq` in\n`Mathlib.Analysis.Calculus.FDeriv.Basic`.\nTo avoid pathologies in dimension 0, we also require that `x` belongs to the closure of `s` (which\nis automatic when `E` is not `0`-dimensional). -/\n@[mk_iff]\nstructure UniqueDiffWithinAt (s : Set E) (x : E) : Prop where\n  dense_tangentCone : Dense (Submodule.span ğ•œ (tangentConeAt ğ•œ s x) : Set E)\n  mem_closure : x âˆˆ closure s\n\n"}
{"name":"uniqueDiffWithinAt_iff","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommMonoid E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\ns : Set E\nx : E\nâŠ¢ Iff (UniqueDiffWithinAt ğ•œ s x) (And (Dense â†‘(Submodule.span ğ•œ (tangentConeAt ğ•œ s x))) (Membership.mem (closure s) x))","decl":"/-- A property ensuring that the tangent cone to `s` at `x` spans a dense subset of the whole space.\nThe main role of this property is to ensure that the differential within `s` at `x` is unique,\nhence this name. The uniqueness it asserts is proved in `UniqueDiffWithinAt.eq` in\n`Mathlib.Analysis.Calculus.FDeriv.Basic`.\nTo avoid pathologies in dimension 0, we also require that `x` belongs to the closure of `s` (which\nis automatic when `E` is not `0`-dimensional). -/\n@[mk_iff]\nstructure UniqueDiffWithinAt (s : Set E) (x : E) : Prop where\n  dense_tangentCone : Dense (Submodule.span ğ•œ (tangentConeAt ğ•œ s x) : Set E)\n  mem_closure : x âˆˆ closure s\n\n"}
{"name":"mem_tangentConeAt_of_pow_smul","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\nx y : E\ns : Set E\nr : ğ•œ\nhrâ‚€ : Ne r 0\nhr : LT.lt (Norm.norm r) 1\nhs : Filter.Eventually (fun n => Membership.mem s (HAdd.hAdd x (HSMul.hSMul (HPow.hPow r n) y))) Filter.atTop\nâŠ¢ Membership.mem (tangentConeAt ğ•œ s x) y","decl":"theorem mem_tangentConeAt_of_pow_smul {r : ğ•œ} (hrâ‚€ : r â‰  0) (hr : â€–râ€– < 1)\n    (hs : âˆ€á¶  n : â„• in atTop, x + r ^ n â€¢ y âˆˆ s) : y âˆˆ tangentConeAt ğ•œ s x := by\n  refine âŸ¨fun n â†¦ (r ^ n)â»Â¹, fun n â†¦ r ^ n â€¢ y, hs, ?_, ?_âŸ©\n  Â· simp only [norm_inv, norm_pow, â† inv_pow]\n    exact tendsto_pow_atTop_atTop_of_one_lt <| (one_lt_invâ‚€ (norm_pos_iff.2 hrâ‚€)).2 hr\n  Â· simp only [inv_smul_smulâ‚€ (pow_ne_zero _ hrâ‚€), tendsto_const_nhds]\n\n"}
{"name":"tangentCone_univ","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\nx : E\nâŠ¢ Eq (tangentConeAt ğ•œ Set.univ x) Set.univ","decl":"theorem tangentCone_univ : tangentConeAt ğ•œ univ x = univ :=\n  let âŸ¨_r, hrâ‚€, hrâŸ© := exists_norm_lt_one ğ•œ\n  eq_univ_of_forall fun _ â†¦ mem_tangentConeAt_of_pow_smul (norm_pos_iff.1 hrâ‚€) hr <|\n    Eventually.of_forall fun _ â†¦ mem_univ _\n\n"}
{"name":"tangentCone_mono","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\nx : E\ns t : Set E\nh : HasSubset.Subset s t\nâŠ¢ HasSubset.Subset (tangentConeAt ğ•œ s x) (tangentConeAt ğ•œ t x)","decl":"theorem tangentCone_mono (h : s âŠ† t) : tangentConeAt ğ•œ s x âŠ† tangentConeAt ğ•œ t x := by\n  rintro y âŸ¨c, d, ds, ctop, climâŸ©\n  exact âŸ¨c, d, mem_of_superset ds fun n hn => h hn, ctop, climâŸ©\n\n"}
{"name":"tangentConeAt.lim_zero","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ny : E\nÎ± : Type u_5\nl : Filter Î±\nc : Î± â†’ ğ•œ\nd : Î± â†’ E\nhc : Filter.Tendsto (fun n => Norm.norm (c n)) l Filter.atTop\nhd : Filter.Tendsto (fun n => HSMul.hSMul (c n) (d n)) l (nhds y)\nâŠ¢ Filter.Tendsto d l (nhds 0)","decl":"/-- Auxiliary lemma ensuring that, under the assumptions defining the tangent cone,\nthe sequence `d` tends to 0 at infinity. -/\ntheorem tangentConeAt.lim_zero {Î± : Type*} (l : Filter Î±) {c : Î± â†’ ğ•œ} {d : Î± â†’ E}\n    (hc : Tendsto (fun n => â€–c nâ€–) l atTop) (hd : Tendsto (fun n => c n â€¢ d n) l (ğ“ y)) :\n    Tendsto d l (ğ“ 0) := by\n  have A : Tendsto (fun n => â€–c nâ€–â»Â¹) l (ğ“ 0) := tendsto_inv_atTop_zero.comp hc\n  have B : Tendsto (fun n => â€–c n â€¢ d nâ€–) l (ğ“ â€–yâ€–) := (continuous_norm.tendsto _).comp hd\n  have C : Tendsto (fun n => â€–c nâ€–â»Â¹ * â€–c n â€¢ d nâ€–) l (ğ“ (0 * â€–yâ€–)) := A.mul B\n  rw [zero_mul] at C\n  have : âˆ€á¶  n in l, â€–c nâ€–â»Â¹ * â€–c n â€¢ d nâ€– = â€–d nâ€– := by\n    refine (eventually_ne_of_tendsto_norm_atTop hc 0).mono fun n hn => ?_\n    rw [norm_smul, â† mul_assoc, inv_mul_cancelâ‚€, one_mul]\n    rwa [Ne, norm_eq_zero]\n  have D : Tendsto (fun n => â€–d nâ€–) l (ğ“ 0) := Tendsto.congr' this C\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  exact D\n\n"}
{"name":"tangentCone_mono_nhds","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns t : Set E\nh : LE.le (nhdsWithin x s) (nhdsWithin x t)\nâŠ¢ HasSubset.Subset (tangentConeAt ğ•œ s x) (tangentConeAt ğ•œ t x)","decl":"theorem tangentCone_mono_nhds (h : ğ“[s] x â‰¤ ğ“[t] x) :\n    tangentConeAt ğ•œ s x âŠ† tangentConeAt ğ•œ t x := by\n  rintro y âŸ¨c, d, ds, ctop, climâŸ©\n  refine âŸ¨c, d, ?_, ctop, climâŸ©\n  suffices Tendsto (fun n => x + d n) atTop (ğ“[t] x) from\n    tendsto_principal.1 (tendsto_inf.1 this).2\n  refine (tendsto_inf.2 âŸ¨?_, tendsto_principal.2 dsâŸ©).mono_right h\n  simpa only [add_zero] using tendsto_const_nhds.add (tangentConeAt.lim_zero atTop ctop clim)\n\n"}
{"name":"tangentCone_congr","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns t : Set E\nh : Eq (nhdsWithin x s) (nhdsWithin x t)\nâŠ¢ Eq (tangentConeAt ğ•œ s x) (tangentConeAt ğ•œ t x)","decl":"/-- Tangent cone of `s` at `x` depends only on `ğ“[s] x`. -/\ntheorem tangentCone_congr (h : ğ“[s] x = ğ“[t] x) : tangentConeAt ğ•œ s x = tangentConeAt ğ•œ t x :=\n  Subset.antisymm (tangentCone_mono_nhds <| le_of_eq h) (tangentCone_mono_nhds <| le_of_eq h.symm)\n\n"}
{"name":"tangentCone_inter_nhds","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns t : Set E\nht : Membership.mem (nhds x) t\nâŠ¢ Eq (tangentConeAt ğ•œ (Inter.inter s t) x) (tangentConeAt ğ•œ s x)","decl":"/-- Intersecting with a neighborhood of the point does not change the tangent cone. -/\ntheorem tangentCone_inter_nhds (ht : t âˆˆ ğ“ x) : tangentConeAt ğ•œ (s âˆ© t) x = tangentConeAt ğ•œ s x :=\n  tangentCone_congr (nhdsWithin_restrict' _ ht).symm\n\n"}
{"name":"subset_tangentCone_prod_left","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ns : Set E\nt : Set F\ny : F\nht : Membership.mem (closure t) y\nâŠ¢ HasSubset.Subset (Set.image (â‡‘(LinearMap.inl ğ•œ E F)) (tangentConeAt ğ•œ s x)) (tangentConeAt ğ•œ (SProd.sprod s t) { fst := x, snd := y })","decl":"/-- The tangent cone of a product contains the tangent cone of its left factor. -/\ntheorem subset_tangentCone_prod_left {t : Set F} {y : F} (ht : y âˆˆ closure t) :\n    LinearMap.inl ğ•œ E F '' tangentConeAt ğ•œ s x âŠ† tangentConeAt ğ•œ (s Ã—Ë¢ t) (x, y) := by\n  rintro _ âŸ¨v, âŸ¨c, d, hd, hc, hyâŸ©, rflâŸ©\n  have : âˆ€ n, âˆƒ d', y + d' âˆˆ t âˆ§ â€–c n â€¢ d'â€– < ((1 : â„) / 2) ^ n := by\n    intro n\n    rcases mem_closure_iff_nhds.1 ht _\n        (eventually_nhds_norm_smul_sub_lt (c n) y (pow_pos one_half_pos n)) with\n      âŸ¨z, hz, hztâŸ©\n    exact âŸ¨z - y, by simpa using hzt, by simpa using hzâŸ©\n  choose d' hd' using this\n  refine âŸ¨c, fun n => (d n, d' n), ?_, hc, ?_âŸ©\n  Â· show âˆ€á¶  n in atTop, (x, y) + (d n, d' n) âˆˆ s Ã—Ë¢ t\n    filter_upwards [hd] with n hn\n    simp [hn, (hd' n).1]\n  Â· apply Tendsto.prod_mk_nhds hy _\n    refine squeeze_zero_norm (fun n => (hd' n).2.le) ?_\n    exact tendsto_pow_atTop_nhds_zero_of_lt_one one_half_pos.le one_half_lt_one\n\n"}
{"name":"subset_tangentCone_prod_right","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ns : Set E\nt : Set F\ny : F\nhs : Membership.mem (closure s) x\nâŠ¢ HasSubset.Subset (Set.image (â‡‘(LinearMap.inr ğ•œ E F)) (tangentConeAt ğ•œ t y)) (tangentConeAt ğ•œ (SProd.sprod s t) { fst := x, snd := y })","decl":"/-- The tangent cone of a product contains the tangent cone of its right factor. -/\ntheorem subset_tangentCone_prod_right {t : Set F} {y : F} (hs : x âˆˆ closure s) :\n    LinearMap.inr ğ•œ E F '' tangentConeAt ğ•œ t y âŠ† tangentConeAt ğ•œ (s Ã—Ë¢ t) (x, y) := by\n  rintro _ âŸ¨w, âŸ¨c, d, hd, hc, hyâŸ©, rflâŸ©\n  have : âˆ€ n, âˆƒ d', x + d' âˆˆ s âˆ§ â€–c n â€¢ d'â€– < ((1 : â„) / 2) ^ n := by\n    intro n\n    rcases mem_closure_iff_nhds.1 hs _\n        (eventually_nhds_norm_smul_sub_lt (c n) x (pow_pos one_half_pos n)) with\n      âŸ¨z, hz, hzsâŸ©\n    exact âŸ¨z - x, by simpa using hzs, by simpa using hzâŸ©\n  choose d' hd' using this\n  refine âŸ¨c, fun n => (d' n, d n), ?_, hc, ?_âŸ©\n  Â· show âˆ€á¶  n in atTop, (x, y) + (d' n, d n) âˆˆ s Ã—Ë¢ t\n    filter_upwards [hd] with n hn\n    simp [hn, (hd' n).1]\n  Â· apply Tendsto.prod_mk_nhds _ hy\n    refine squeeze_zero_norm (fun n => (hd' n).2.le) ?_\n    exact tendsto_pow_atTop_nhds_zero_of_lt_one one_half_pos.le one_half_lt_one\n\n"}
{"name":"mapsTo_tangentCone_pi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\ninstâœÂ² : DecidableEq Î¹\nE : Î¹ â†’ Type u_6\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ns : (i : Î¹) â†’ Set (E i)\nx : (i : Î¹) â†’ E i\ni : Î¹\nhi : âˆ€ (j : Î¹), Ne j i â†’ Membership.mem (closure (s j)) (x j)\nâŠ¢ Set.MapsTo (â‡‘(LinearMap.single ğ•œ E i)) (tangentConeAt ğ•œ (s i) (x i)) (tangentConeAt ğ•œ (Set.univ.pi s) x)","decl":"/-- The tangent cone of a product contains the tangent cone of each factor. -/\ntheorem mapsTo_tangentCone_pi {Î¹ : Type*} [DecidableEq Î¹] {E : Î¹ â†’ Type*}\n    [âˆ€ i, NormedAddCommGroup (E i)] [âˆ€ i, NormedSpace ğ•œ (E i)] {s : âˆ€ i, Set (E i)} {x : âˆ€ i, E i}\n    {i : Î¹} (hi : âˆ€ j â‰  i, x j âˆˆ closure (s j)) :\n    MapsTo (LinearMap.single ğ•œ E i) (tangentConeAt ğ•œ (s i) (x i))\n      (tangentConeAt ğ•œ (Set.pi univ s) x) := by\n  rintro w âŸ¨c, d, hd, hc, hyâŸ©\n  have : âˆ€ n, âˆ€ j â‰  i, âˆƒ d', x j + d' âˆˆ s j âˆ§ â€–c n â€¢ d'â€– < (1 / 2 : â„) ^ n := fun n j hj â†¦ by\n    rcases mem_closure_iff_nhds.1 (hi j hj) _\n        (eventually_nhds_norm_smul_sub_lt (c n) (x j) (pow_pos one_half_pos n)) with\n      âŸ¨z, hz, hzsâŸ©\n    exact âŸ¨z - x j, by simpa using hzs, by simpa using hzâŸ©\n  choose! d' hd's hcd' using this\n  refine âŸ¨c, fun n => Function.update (d' n) i (d n), hd.mono fun n hn j _ => ?_, hc,\n      tendsto_pi_nhds.2 fun j => ?_âŸ©\n  Â· rcases em (j = i) with (rfl | hj) <;> simp [*]\n  Â· rcases em (j = i) with (rfl | hj)\n    Â· simp [hy]\n    Â· suffices Tendsto (fun n => c n â€¢ d' n j) atTop (ğ“ 0) by simpa [hj]\n      refine squeeze_zero_norm (fun n => (hcd' n j hj).le) ?_\n      exact tendsto_pow_atTop_nhds_zero_of_lt_one one_half_pos.le one_half_lt_one\n\n"}
{"name":"mem_tangentCone_of_openSegment_subset","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"G : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\ns : Set G\nx y : G\nh : HasSubset.Subset (openSegment Real x y) s\nâŠ¢ Membership.mem (tangentConeAt Real s x) (HSub.hSub y x)","decl":"/-- If a subset of a real vector space contains an open segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. -/\ntheorem mem_tangentCone_of_openSegment_subset {s : Set G} {x y : G} (h : openSegment â„ x y âŠ† s) :\n    y - x âˆˆ tangentConeAt â„ s x := by\n  refine mem_tangentConeAt_of_pow_smul one_half_pos.ne' (by norm_num) ?_\n  refine (eventually_ne_atTop 0).mono fun n hn â†¦ (h ?_)\n  rw [openSegment_eq_image]\n  refine âŸ¨(1 / 2) ^ n, âŸ¨?_, ?_âŸ©, ?_âŸ©\n  Â· exact pow_pos one_half_pos _\n  Â· exact pow_lt_oneâ‚€ one_half_pos.le one_half_lt_one hn\n  Â· simp only [sub_smul, one_smul, smul_sub]; abel\n\n"}
{"name":"mem_tangentCone_of_segment_subset","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"G : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\ns : Set G\nx y : G\nh : HasSubset.Subset (segment Real x y) s\nâŠ¢ Membership.mem (tangentConeAt Real s x) (HSub.hSub y x)","decl":"/-- If a subset of a real vector space contains a segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. -/\ntheorem mem_tangentCone_of_segment_subset {s : Set G} {x y : G} (h : segment â„ x y âŠ† s) :\n    y - x âˆˆ tangentConeAt â„ s x :=\n  mem_tangentCone_of_openSegment_subset ((openSegment_subset_segment â„ x y).trans h)\n\n"}
{"name":"zero_mem_tangentCone","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nx : E\nhx : (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))).NeBot\nâŠ¢ Membership.mem (tangentConeAt ğ•œ s x) 0","decl":"/-- The tangent cone at a non-isolated point contains `0`. -/\ntheorem zero_mem_tangentCone {s : Set E} {x : E} (hx : (ğ“[s \\ {x}] x).NeBot) :\n    0 âˆˆ tangentConeAt ğ•œ s x := by\n  /- Take a sequence `d n` tending to `0` such that `x + d n âˆˆ s`. Taking `c n` of the order\n  of `1 / (d n) ^ (1/2)`, then `c n` tends to infinity, but `c n â€¢ d n` tends to `0`. By definition,\n  this shows that `0` belongs to the tangent cone. -/\n  obtain âŸ¨u, -, u_pos, u_limâŸ© :\n      âˆƒ u, StrictAnti u âˆ§ (âˆ€ (n : â„•), 0 < u n) âˆ§ Tendsto u atTop (ğ“ (0 : â„)) :=\n    exists_seq_strictAnti_tendsto (0 : â„)\n  have A n : ((s \\ {x}) âˆ© Metric.ball x (u n * u n)).Nonempty :=\n    NeBot.nonempty_of_mem hx (inter_mem_nhdsWithin _\n      (Metric.ball_mem_nhds _ (mul_pos (u_pos n) (u_pos n))))\n  choose v hv using A\n  let d n := v n - x\n  have M n : x + d n âˆˆ s \\ {x} := by simpa [d] using (hv n).1\n  let âŸ¨r, hrâŸ© := exists_one_lt_norm ğ•œ\n  have W n := rescale_to_shell hr (u_pos n) (x := d n) (by simpa using (M n).2)\n  choose c c_ne c_le le_c hc using W\n  have c_lim : Tendsto (fun n â†¦ â€–c nâ€–) atTop atTop := by\n    suffices Tendsto (fun n â†¦ â€–c nâ€–â»Â¹ â»Â¹) atTop atTop by simpa\n    apply tendsto_inv_nhdsGT_zero.comp\n    simp only [nhdsWithin, tendsto_inf, tendsto_principal, mem_Ioi, norm_pos_iff, ne_eq,\n      eventually_atTop, ge_iff_le]\n    have B (n : â„•) : â€–c nâ€–â»Â¹ â‰¤ â€–râ€– * u n := calc\n      â€–c nâ€–â»Â¹\n      _ â‰¤ (u n)â»Â¹ * â€–râ€– * â€–d nâ€– := hc n\n      _ â‰¤ (u n)â»Â¹ * â€–râ€– * (u n * u n) := by\n        gcongr\n        Â· exact mul_nonneg (by simp [(u_pos n).le]) (norm_nonneg _)\n        Â· specialize hv n\n          simp only [mem_inter_iff, mem_diff, mem_singleton_iff, Metric.mem_ball, dist_eq_norm]\n            at hv\n          simpa using hv.2.le\n      _ = â€–râ€– * u n := by field_simp [(u_pos n).ne']; ring\n    refine âŸ¨?_, 0, fun n hn â†¦ by simpa using c_ne nâŸ©\n    apply squeeze_zero (fun n â†¦ by positivity) B\n    simpa using u_lim.const_mul _\n  refine âŸ¨c, d, Eventually.of_forall (fun n â†¦ by simpa [d] using (hv n).1.1), c_lim, ?_âŸ©\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  exact squeeze_zero (fun n â†¦ by positivity) (fun n â†¦ (c_le n).le) u_lim\n\n"}
{"name":"tangentCone_nonempty_of_properSpace","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : ProperSpace E\ns : Set E\nx : E\nhx : (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))).NeBot\nâŠ¢ (Inter.inter (tangentConeAt ğ•œ s x) (HasCompl.compl (Singleton.singleton 0))).Nonempty","decl":"/-- In a proper space, the tangent cone at a non-isolated point is nontrivial. -/\ntheorem tangentCone_nonempty_of_properSpace [ProperSpace E]\n    {s : Set E} {x : E} (hx : (ğ“[s \\ {x}] x).NeBot) :\n    (tangentConeAt ğ•œ s x âˆ© {0}á¶œ).Nonempty := by\n  /- Take a sequence `d n` tending to `0` such that `x + d n âˆˆ s`. Taking `c n` of the order\n  of `1 / d n`. Then `c n â€¢ d n` belongs to a fixed annulus. By compactness, one can extract\n  a subsequence converging to a limit `l`. Then `l` is nonzero, and by definition it belongs to\n  the tangent cone. -/\n  obtain âŸ¨u, -, u_pos, u_limâŸ© :\n      âˆƒ u, StrictAnti u âˆ§ (âˆ€ (n : â„•), 0 < u n) âˆ§ Tendsto u atTop (ğ“ (0 : â„)) :=\n    exists_seq_strictAnti_tendsto (0 : â„)\n  have A n : ((s \\ {x}) âˆ© Metric.ball x (u n)).Nonempty := by\n    apply NeBot.nonempty_of_mem hx (inter_mem_nhdsWithin _ (Metric.ball_mem_nhds _ (u_pos n)))\n  choose v hv using A\n  let d := fun n â†¦ v n - x\n  have M n : x + d n âˆˆ s \\ {x} := by simpa [d] using (hv n).1\n  let âŸ¨r, hrâŸ© := exists_one_lt_norm ğ•œ\n  have W n := rescale_to_shell hr zero_lt_one (x := d n) (by simpa using (M n).2)\n  choose c c_ne c_le le_c hc using W\n  have c_lim : Tendsto (fun n â†¦ â€–c nâ€–) atTop atTop := by\n    suffices Tendsto (fun n â†¦ â€–c nâ€–â»Â¹ â»Â¹ ) atTop atTop by simpa\n    apply tendsto_inv_nhdsGT_zero.comp\n    simp only [nhdsWithin, tendsto_inf, tendsto_principal, mem_Ioi, norm_pos_iff, ne_eq,\n      eventually_atTop, ge_iff_le]\n    have B (n : â„•) : â€–c nâ€–â»Â¹ â‰¤ 1â»Â¹ * â€–râ€– * u n := by\n      apply (hc n).trans\n      gcongr\n      specialize hv n\n      simp only [mem_inter_iff, mem_diff, mem_singleton_iff, Metric.mem_ball, dist_eq_norm] at hv\n      simpa using hv.2.le\n    refine âŸ¨?_, 0, fun n hn â†¦ by simpa using c_ne nâŸ©\n    apply squeeze_zero (fun n â†¦ by positivity) B\n    simpa using u_lim.const_mul _\n  obtain âŸ¨l, l_mem, Ï†, Ï†_strict, hÏ†âŸ© :\n      âˆƒ l âˆˆ Metric.closedBall (0 : E) 1 \\ Metric.ball (0 : E) (1 / â€–râ€–),\n      âˆƒ (Ï† : â„• â†’ â„•), StrictMono Ï† âˆ§ Tendsto ((fun n â†¦ c n â€¢ d n) âˆ˜ Ï†) atTop (ğ“ l) := by\n    apply IsCompact.tendsto_subseq _ (fun n â†¦ ?_)\n    Â· exact (isCompact_closedBall 0 1).diff Metric.isOpen_ball\n    simp only [mem_diff, Metric.mem_closedBall, dist_zero_right, (c_le n).le,\n      Metric.mem_ball, not_lt, true_and, le_c n]\n  refine âŸ¨l, ?_, ?_âŸ©; swap\n  Â· simp only [mem_compl_iff, mem_singleton_iff]\n    contrapose! l_mem\n    simp only [one_div, l_mem, mem_diff, Metric.mem_closedBall, dist_self, zero_le_one,\n      Metric.mem_ball, inv_pos, norm_pos_iff, ne_eq, not_not, true_and]\n    contrapose! hr\n    simp [hr]\n  refine âŸ¨c âˆ˜ Ï†, d âˆ˜ Ï†, ?_, ?_, hÏ†âŸ©\n  Â· exact Eventually.of_forall (fun n â†¦ by simpa [d] using (hv (Ï† n)).1.1)\n  Â· exact c_lim.comp Ï†_strict.tendsto_atTop\n\n"}
{"name":"tangentCone_eq_univ","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\ns : Set ğ•œ\nx : ğ•œ\nhx : (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))).NeBot\nâŠ¢ Eq (tangentConeAt ğ•œ s x) Set.univ","decl":"/-- The tangent cone at a non-isolated point in dimension 1 is the whole space. -/\ntheorem tangentCone_eq_univ {s : Set ğ•œ} {x : ğ•œ} (hx : (ğ“[s \\ {x}] x).NeBot) :\n    tangentConeAt ğ•œ s x = univ := by\n  apply eq_univ_iff_forall.2 (fun y â†¦ ?_)\n  -- first deal with the case of `0`, which has to be handled separately.\n  rcases eq_or_ne y 0 with rfl | hy\n  Â· exact zero_mem_tangentCone hx\n  /- Assume now `y` is a fixed nonzero scalar. Take a sequence `d n` tending to `0` such\n  that `x + d n âˆˆ s`. Let `c n = y / d n`. Then `â€–c nâ€–` tends to infinity, and `c n â€¢ d n`\n  converges to `y` (as it is equal to `y`). By definition, this shows that `y` belongs to the\n  tangent cone. -/\n  obtain âŸ¨u, -, u_pos, u_limâŸ© :\n      âˆƒ u, StrictAnti u âˆ§ (âˆ€ (n : â„•), 0 < u n) âˆ§ Tendsto u atTop (ğ“ (0 : â„)) :=\n    exists_seq_strictAnti_tendsto (0 : â„)\n  have A n : ((s \\ {x}) âˆ© Metric.ball x (u n)).Nonempty := by\n    apply NeBot.nonempty_of_mem hx (inter_mem_nhdsWithin _ (Metric.ball_mem_nhds _ (u_pos n)))\n  choose v hv using A\n  let d := fun n â†¦ v n - x\n  have d_ne n : d n â‰  0 := by\n    simp only [mem_inter_iff, mem_diff, mem_singleton_iff, Metric.mem_ball, d] at hv\n    simpa [d, sub_ne_zero] using (hv n).1.2\n  refine âŸ¨fun n â†¦ y * (d n)â»Â¹, d, ?_, ?_, ?_âŸ©\n  Â· exact Eventually.of_forall (fun n â†¦ by simpa [d] using (hv n).1.1)\n  Â· simp only [norm_mul, norm_inv]\n    apply (tendsto_const_mul_atTop_of_pos (by simpa using hy)).2\n    apply tendsto_inv_nhdsGT_zero.comp\n    simp only [nhdsWithin, tendsto_inf, tendsto_principal, mem_Ioi, norm_pos_iff, ne_eq,\n      eventually_atTop, ge_iff_le]\n    have B (n : â„•) : â€–d nâ€– â‰¤ u n := by\n      specialize hv n\n      simp only [mem_inter_iff, mem_diff, mem_singleton_iff, Metric.mem_ball, dist_eq_norm] at hv\n      simpa using hv.2.le\n    refine âŸ¨?_, 0, fun n hn â†¦ by simpa using d_ne nâŸ©\n    exact squeeze_zero (fun n â†¦ by positivity) B u_lim\n  Â· convert tendsto_const_nhds (Î± := â„•) (x := y) with n\n    simp [mul_assoc, inv_mul_cancelâ‚€ (d_ne n)]\n\n"}
{"name":"UniqueDiffOn.uniqueDiffWithinAt","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\ns : Set E\nx : E\nhs : UniqueDiffOn ğ•œ s\nh : Membership.mem s x\nâŠ¢ UniqueDiffWithinAt ğ•œ s x","decl":"theorem UniqueDiffOn.uniqueDiffWithinAt {s : Set E} {x} (hs : UniqueDiffOn ğ•œ s) (h : x âˆˆ s) :\n    UniqueDiffWithinAt ğ•œ s x :=\n  hs x h\n\n"}
{"name":"uniqueDiffWithinAt_univ","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\nx : E\nâŠ¢ UniqueDiffWithinAt ğ•œ Set.univ x","decl":"theorem uniqueDiffWithinAt_univ : UniqueDiffWithinAt ğ•œ univ x := by\n  rw [uniqueDiffWithinAt_iff, tangentCone_univ]\n  simp\n\n"}
{"name":"uniqueDiffOn_univ","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\nâŠ¢ UniqueDiffOn ğ•œ Set.univ","decl":"theorem uniqueDiffOn_univ : UniqueDiffOn ğ•œ (univ : Set E) :=\n  fun _ _ => uniqueDiffWithinAt_univ\n\n"}
{"name":"uniqueDiffOn_empty","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\nâŠ¢ UniqueDiffOn ğ•œ EmptyCollection.emptyCollection","decl":"theorem uniqueDiffOn_empty : UniqueDiffOn ğ•œ (âˆ… : Set E) :=\n  fun _ hx => hx.elim\n\n"}
{"name":"UniqueDiffWithinAt.congr_pt","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : TopologicalSpace E\nx y : E\ns : Set E\nh : UniqueDiffWithinAt ğ•œ s x\nhy : Eq x y\nâŠ¢ UniqueDiffWithinAt ğ•œ s y","decl":"theorem UniqueDiffWithinAt.congr_pt (h : UniqueDiffWithinAt ğ•œ s x) (hy : x = y) :\n    UniqueDiffWithinAt ğ•œ s y := hy â–¸ h\n\n"}
{"name":"UniqueDiffWithinAt.mono_nhds","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns t : Set E\nh : UniqueDiffWithinAt ğ•œ s x\nst : LE.le (nhdsWithin x s) (nhdsWithin x t)\nâŠ¢ UniqueDiffWithinAt ğ•œ t x","decl":"theorem UniqueDiffWithinAt.mono_nhds (h : UniqueDiffWithinAt ğ•œ s x) (st : ğ“[s] x â‰¤ ğ“[t] x) :\n    UniqueDiffWithinAt ğ•œ t x := by\n  simp only [uniqueDiffWithinAt_iff] at *\n  rw [mem_closure_iff_nhdsWithin_neBot] at h âŠ¢\n  exact âŸ¨h.1.mono <| Submodule.span_mono <| tangentCone_mono_nhds st, h.2.mono stâŸ©\n\n"}
{"name":"UniqueDiffWithinAt.mono","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns t : Set E\nh : UniqueDiffWithinAt ğ•œ s x\nst : HasSubset.Subset s t\nâŠ¢ UniqueDiffWithinAt ğ•œ t x","decl":"theorem UniqueDiffWithinAt.mono (h : UniqueDiffWithinAt ğ•œ s x) (st : s âŠ† t) :\n    UniqueDiffWithinAt ğ•œ t x :=\n  h.mono_nhds <| nhdsWithin_mono _ st\n\n"}
{"name":"uniqueDiffWithinAt_congr","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns t : Set E\nst : Eq (nhdsWithin x s) (nhdsWithin x t)\nâŠ¢ Iff (UniqueDiffWithinAt ğ•œ s x) (UniqueDiffWithinAt ğ•œ t x)","decl":"theorem uniqueDiffWithinAt_congr (st : ğ“[s] x = ğ“[t] x) :\n    UniqueDiffWithinAt ğ•œ s x â†” UniqueDiffWithinAt ğ•œ t x :=\n  âŸ¨fun h => h.mono_nhds <| le_of_eq st, fun h => h.mono_nhds <| le_of_eq st.symmâŸ©\n\n"}
{"name":"uniqueDiffWithinAt_inter","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns t : Set E\nht : Membership.mem (nhds x) t\nâŠ¢ Iff (UniqueDiffWithinAt ğ•œ (Inter.inter s t) x) (UniqueDiffWithinAt ğ•œ s x)","decl":"theorem uniqueDiffWithinAt_inter (ht : t âˆˆ ğ“ x) :\n    UniqueDiffWithinAt ğ•œ (s âˆ© t) x â†” UniqueDiffWithinAt ğ•œ s x :=\n  uniqueDiffWithinAt_congr <| (nhdsWithin_restrict' _ ht).symm\n\n"}
{"name":"UniqueDiffWithinAt.inter","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns t : Set E\nhs : UniqueDiffWithinAt ğ•œ s x\nht : Membership.mem (nhds x) t\nâŠ¢ UniqueDiffWithinAt ğ•œ (Inter.inter s t) x","decl":"theorem UniqueDiffWithinAt.inter (hs : UniqueDiffWithinAt ğ•œ s x) (ht : t âˆˆ ğ“ x) :\n    UniqueDiffWithinAt ğ•œ (s âˆ© t) x :=\n  (uniqueDiffWithinAt_inter ht).2 hs\n\n"}
{"name":"uniqueDiffWithinAt_inter'","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns t : Set E\nht : Membership.mem (nhdsWithin x s) t\nâŠ¢ Iff (UniqueDiffWithinAt ğ•œ (Inter.inter s t) x) (UniqueDiffWithinAt ğ•œ s x)","decl":"theorem uniqueDiffWithinAt_inter' (ht : t âˆˆ ğ“[s] x) :\n    UniqueDiffWithinAt ğ•œ (s âˆ© t) x â†” UniqueDiffWithinAt ğ•œ s x :=\n  uniqueDiffWithinAt_congr <| (nhdsWithin_restrict'' _ ht).symm\n\n"}
{"name":"UniqueDiffWithinAt.inter'","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns t : Set E\nhs : UniqueDiffWithinAt ğ•œ s x\nht : Membership.mem (nhdsWithin x s) t\nâŠ¢ UniqueDiffWithinAt ğ•œ (Inter.inter s t) x","decl":"theorem UniqueDiffWithinAt.inter' (hs : UniqueDiffWithinAt ğ•œ s x) (ht : t âˆˆ ğ“[s] x) :\n    UniqueDiffWithinAt ğ•œ (s âˆ© t) x :=\n  (uniqueDiffWithinAt_inter' ht).2 hs\n\n"}
{"name":"uniqueDiffWithinAt_of_mem_nhds","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns : Set E\nh : Membership.mem (nhds x) s\nâŠ¢ UniqueDiffWithinAt ğ•œ s x","decl":"theorem uniqueDiffWithinAt_of_mem_nhds (h : s âˆˆ ğ“ x) : UniqueDiffWithinAt ğ•œ s x := by\n  simpa only [univ_inter] using uniqueDiffWithinAt_univ.inter h\n\n"}
{"name":"IsOpen.uniqueDiffWithinAt","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\ns : Set E\nhs : IsOpen s\nxs : Membership.mem s x\nâŠ¢ UniqueDiffWithinAt ğ•œ s x","decl":"theorem IsOpen.uniqueDiffWithinAt (hs : IsOpen s) (xs : x âˆˆ s) : UniqueDiffWithinAt ğ•œ s x :=\n  uniqueDiffWithinAt_of_mem_nhds (IsOpen.mem_nhds hs xs)\n\n"}
{"name":"UniqueDiffOn.inter","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns t : Set E\nhs : UniqueDiffOn ğ•œ s\nht : IsOpen t\nâŠ¢ UniqueDiffOn ğ•œ (Inter.inter s t)","decl":"theorem UniqueDiffOn.inter (hs : UniqueDiffOn ğ•œ s) (ht : IsOpen t) : UniqueDiffOn ğ•œ (s âˆ© t) :=\n  fun x hx => (hs x hx.1).inter (IsOpen.mem_nhds ht hx.2)\n\n"}
{"name":"IsOpen.uniqueDiffOn","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nhs : IsOpen s\nâŠ¢ UniqueDiffOn ğ•œ s","decl":"theorem IsOpen.uniqueDiffOn (hs : IsOpen s) : UniqueDiffOn ğ•œ s :=\n  fun _ hx => IsOpen.uniqueDiffWithinAt hs hx\n\n"}
{"name":"UniqueDiffWithinAt.prod","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ns : Set E\nt : Set F\ny : F\nhs : UniqueDiffWithinAt ğ•œ s x\nht : UniqueDiffWithinAt ğ•œ t y\nâŠ¢ UniqueDiffWithinAt ğ•œ (SProd.sprod s t) { fst := x, snd := y }","decl":"/-- The product of two sets of unique differentiability at points `x` and `y` has unique\ndifferentiability at `(x, y)`. -/\ntheorem UniqueDiffWithinAt.prod {t : Set F} {y : F} (hs : UniqueDiffWithinAt ğ•œ s x)\n    (ht : UniqueDiffWithinAt ğ•œ t y) : UniqueDiffWithinAt ğ•œ (s Ã—Ë¢ t) (x, y) := by\n  rw [uniqueDiffWithinAt_iff] at hs ht âŠ¢\n  rw [closure_prod_eq]\n  refine âŸ¨?_, hs.2, ht.2âŸ©\n  have : _ â‰¤ Submodule.span ğ•œ (tangentConeAt ğ•œ (s Ã—Ë¢ t) (x, y)) := Submodule.span_mono\n    (union_subset (subset_tangentCone_prod_left ht.2) (subset_tangentCone_prod_right hs.2))\n  rw [LinearMap.span_inl_union_inr, SetLike.le_def] at this\n  exact (hs.1.prod ht.1).mono this\n\n"}
{"name":"UniqueDiffWithinAt.univ_pi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\ninstâœÂ² : Finite Î¹\nE : Î¹ â†’ Type u_6\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ns : (i : Î¹) â†’ Set (E i)\nx : (i : Î¹) â†’ E i\nh : âˆ€ (i : Î¹), UniqueDiffWithinAt ğ•œ (s i) (x i)\nâŠ¢ UniqueDiffWithinAt ğ•œ (Set.univ.pi s) x","decl":"theorem UniqueDiffWithinAt.univ_pi (Î¹ : Type*) [Finite Î¹] (E : Î¹ â†’ Type*)\n    [âˆ€ i, NormedAddCommGroup (E i)] [âˆ€ i, NormedSpace ğ•œ (E i)] (s : âˆ€ i, Set (E i)) (x : âˆ€ i, E i)\n    (h : âˆ€ i, UniqueDiffWithinAt ğ•œ (s i) (x i)) : UniqueDiffWithinAt ğ•œ (Set.pi univ s) x := by\n  classical\n  simp only [uniqueDiffWithinAt_iff, closure_pi_set] at h âŠ¢\n  refine âŸ¨(dense_pi univ fun i _ => (h i).1).mono ?_, fun i _ => (h i).2âŸ©\n  norm_cast\n  simp only [â† Submodule.iSup_map_single, iSup_le_iff, LinearMap.map_span, Submodule.span_le,\n    â† mapsTo']\n  exact fun i => (mapsTo_tangentCone_pi fun j _ => (h j).2).mono Subset.rfl Submodule.subset_span\n\n"}
{"name":"UniqueDiffWithinAt.pi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\ninstâœÂ² : Finite Î¹\nE : Î¹ â†’ Type u_6\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ns : (i : Î¹) â†’ Set (E i)\nx : (i : Î¹) â†’ E i\nI : Set Î¹\nh : âˆ€ (i : Î¹), Membership.mem I i â†’ UniqueDiffWithinAt ğ•œ (s i) (x i)\nâŠ¢ UniqueDiffWithinAt ğ•œ (I.pi s) x","decl":"theorem UniqueDiffWithinAt.pi (Î¹ : Type*) [Finite Î¹] (E : Î¹ â†’ Type*)\n    [âˆ€ i, NormedAddCommGroup (E i)] [âˆ€ i, NormedSpace ğ•œ (E i)] (s : âˆ€ i, Set (E i)) (x : âˆ€ i, E i)\n    (I : Set Î¹) (h : âˆ€ i âˆˆ I, UniqueDiffWithinAt ğ•œ (s i) (x i)) :\n    UniqueDiffWithinAt ğ•œ (Set.pi I s) x := by\n  classical\n  rw [â† Set.univ_pi_piecewise_univ]\n  refine UniqueDiffWithinAt.univ_pi Î¹ E _ _ fun i => ?_\n  by_cases hi : i âˆˆ I <;> simp [*, uniqueDiffWithinAt_univ]\n\n"}
{"name":"UniqueDiffOn.prod","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nt : Set F\nhs : UniqueDiffOn ğ•œ s\nht : UniqueDiffOn ğ•œ t\nâŠ¢ UniqueDiffOn ğ•œ (SProd.sprod s t)","decl":"/-- The product of two sets of unique differentiability is a set of unique differentiability. -/\ntheorem UniqueDiffOn.prod {t : Set F} (hs : UniqueDiffOn ğ•œ s) (ht : UniqueDiffOn ğ•œ t) :\n    UniqueDiffOn ğ•œ (s Ã—Ë¢ t) :=\n  fun âŸ¨x, yâŸ© h => UniqueDiffWithinAt.prod (hs x h.1) (ht y h.2)\n\n"}
{"name":"UniqueDiffOn.pi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\ninstâœÂ² : Finite Î¹\nE : Î¹ â†’ Type u_6\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ns : (i : Î¹) â†’ Set (E i)\nI : Set Î¹\nh : âˆ€ (i : Î¹), Membership.mem I i â†’ UniqueDiffOn ğ•œ (s i)\nâŠ¢ UniqueDiffOn ğ•œ (I.pi s)","decl":"/-- The finite product of a family of sets of unique differentiability is a set of unique\ndifferentiability. -/\ntheorem UniqueDiffOn.pi (Î¹ : Type*) [Finite Î¹] (E : Î¹ â†’ Type*) [âˆ€ i, NormedAddCommGroup (E i)]\n    [âˆ€ i, NormedSpace ğ•œ (E i)] (s : âˆ€ i, Set (E i)) (I : Set Î¹)\n    (h : âˆ€ i âˆˆ I, UniqueDiffOn ğ•œ (s i)) : UniqueDiffOn ğ•œ (Set.pi I s) :=\n  fun x hx => UniqueDiffWithinAt.pi _ _ _ _ _ fun i hi => h i hi (x i) (hx i hi)\n\n"}
{"name":"UniqueDiffOn.univ_pi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_5\ninstâœÂ² : Finite Î¹\nE : Î¹ â†’ Type u_6\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\ns : (i : Î¹) â†’ Set (E i)\nh : âˆ€ (i : Î¹), UniqueDiffOn ğ•œ (s i)\nâŠ¢ UniqueDiffOn ğ•œ (Set.univ.pi s)","decl":"/-- The finite product of a family of sets of unique differentiability is a set of unique\ndifferentiability. -/\ntheorem UniqueDiffOn.univ_pi (Î¹ : Type*) [Finite Î¹] (E : Î¹ â†’ Type*)\n    [âˆ€ i, NormedAddCommGroup (E i)] [âˆ€ i, NormedSpace ğ•œ (E i)] (s : âˆ€ i, Set (E i))\n    (h : âˆ€ i, UniqueDiffOn ğ•œ (s i)) : UniqueDiffOn ğ•œ (Set.pi univ s) :=\n  UniqueDiffOn.pi _ _ _ _ fun i _ => h i\n\n"}
{"name":"uniqueDiffWithinAt_convex","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"G : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\ns : Set G\nconv : Convex Real s\nhs : (interior s).Nonempty\nx : G\nhx : Membership.mem (closure s) x\nâŠ¢ UniqueDiffWithinAt Real s x","decl":"/-- In a real vector space, a convex set with nonempty interior is a set of unique\ndifferentiability at every point of its closure. -/\ntheorem uniqueDiffWithinAt_convex {s : Set G} (conv : Convex â„ s) (hs : (interior s).Nonempty)\n    {x : G} (hx : x âˆˆ closure s) : UniqueDiffWithinAt â„ s x := by\n  rcases hs with âŸ¨y, hyâŸ©\n  suffices y - x âˆˆ interior (tangentConeAt â„ s x) by\n    refine âŸ¨Dense.of_closure ?_, hxâŸ©\n    simp [(Submodule.span â„ (tangentConeAt â„ s x)).eq_top_of_nonempty_interior'\n        âŸ¨y - x, interior_mono Submodule.subset_span thisâŸ©]\n  rw [mem_interior_iff_mem_nhds]\n  replace hy : interior s âˆˆ ğ“ y := IsOpen.mem_nhds isOpen_interior hy\n  apply mem_of_superset ((isOpenMap_sub_right x).image_mem_nhds hy)\n  rintro _ âŸ¨z, zs, rflâŸ©\n  refine mem_tangentCone_of_openSegment_subset (Subset.trans ?_ interior_subset)\n  exact conv.openSegment_closure_interior_subset_interior hx zs\n\n"}
{"name":"uniqueDiffOn_convex","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"G : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\ns : Set G\nconv : Convex Real s\nhs : (interior s).Nonempty\nâŠ¢ UniqueDiffOn Real s","decl":"/-- In a real vector space, a convex set with nonempty interior is a set of unique\ndifferentiability. -/\ntheorem uniqueDiffOn_convex {s : Set G} (conv : Convex â„ s) (hs : (interior s).Nonempty) :\n    UniqueDiffOn â„ s :=\n  fun _ xs => uniqueDiffWithinAt_convex conv hs (subset_closure xs)\n\n"}
{"name":"uniqueDiffOn_Ici","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a : Real\nâŠ¢ UniqueDiffOn Real (Set.Ici a)","decl":"theorem uniqueDiffOn_Ici (a : â„) : UniqueDiffOn â„ (Ici a) :=\n  uniqueDiffOn_convex (convex_Ici a) <| by simp only [interior_Ici, nonempty_Ioi]\n\n"}
{"name":"uniqueDiffOn_Iic","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a : Real\nâŠ¢ UniqueDiffOn Real (Set.Iic a)","decl":"theorem uniqueDiffOn_Iic (a : â„) : UniqueDiffOn â„ (Iic a) :=\n  uniqueDiffOn_convex (convex_Iic a) <| by simp only [interior_Iic, nonempty_Iio]\n\n"}
{"name":"uniqueDiffOn_Ioi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a : Real\nâŠ¢ UniqueDiffOn Real (Set.Ioi a)","decl":"theorem uniqueDiffOn_Ioi (a : â„) : UniqueDiffOn â„ (Ioi a) :=\n  isOpen_Ioi.uniqueDiffOn\n\n"}
{"name":"uniqueDiffOn_Iio","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a : Real\nâŠ¢ UniqueDiffOn Real (Set.Iio a)","decl":"theorem uniqueDiffOn_Iio (a : â„) : UniqueDiffOn â„ (Iio a) :=\n  isOpen_Iio.uniqueDiffOn\n\n"}
{"name":"uniqueDiffOn_Icc","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a b : Real\nhab : LT.lt a b\nâŠ¢ UniqueDiffOn Real (Set.Icc a b)","decl":"theorem uniqueDiffOn_Icc {a b : â„} (hab : a < b) : UniqueDiffOn â„ (Icc a b) :=\n  uniqueDiffOn_convex (convex_Icc a b) <| by simp only [interior_Icc, nonempty_Ioo, hab]\n\n"}
{"name":"uniqueDiffOn_Ico","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a b : Real\nâŠ¢ UniqueDiffOn Real (Set.Ico a b)","decl":"theorem uniqueDiffOn_Ico (a b : â„) : UniqueDiffOn â„ (Ico a b) :=\n  if hab : a < b then\n    uniqueDiffOn_convex (convex_Ico a b) <| by simp only [interior_Ico, nonempty_Ioo, hab]\n  else by simp only [Ico_eq_empty hab, uniqueDiffOn_empty]\n\n"}
{"name":"uniqueDiffOn_Ioc","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a b : Real\nâŠ¢ UniqueDiffOn Real (Set.Ioc a b)","decl":"theorem uniqueDiffOn_Ioc (a b : â„) : UniqueDiffOn â„ (Ioc a b) :=\n  if hab : a < b then\n    uniqueDiffOn_convex (convex_Ioc a b) <| by simp only [interior_Ioc, nonempty_Ioo, hab]\n  else by simp only [Ioc_eq_empty hab, uniqueDiffOn_empty]\n\n"}
{"name":"uniqueDiffOn_Ioo","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a b : Real\nâŠ¢ UniqueDiffOn Real (Set.Ioo a b)","decl":"theorem uniqueDiffOn_Ioo (a b : â„) : UniqueDiffOn â„ (Ioo a b) :=\n  isOpen_Ioo.uniqueDiffOn\n\n"}
{"name":"uniqueDiffOn_Icc_zero_one","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"âŠ¢ UniqueDiffOn Real (Set.Icc 0 1)","decl":"/-- The real interval `[0, 1]` is a set of unique differentiability. -/\ntheorem uniqueDiffOn_Icc_zero_one : UniqueDiffOn â„ (Icc (0 : â„) 1) :=\n  uniqueDiffOn_Icc zero_lt_one\n\n"}
{"name":"uniqueDiffWithinAt_Ioo","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a b t : Real\nht : Membership.mem (Set.Ioo a b) t\nâŠ¢ UniqueDiffWithinAt Real (Set.Ioo a b) t","decl":"theorem uniqueDiffWithinAt_Ioo {a b t : â„} (ht : t âˆˆ Set.Ioo a b) :\n    UniqueDiffWithinAt â„ (Set.Ioo a b) t :=\n  IsOpen.uniqueDiffWithinAt isOpen_Ioo ht\n\n"}
{"name":"uniqueDiffWithinAt_Ioi","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a : Real\nâŠ¢ UniqueDiffWithinAt Real (Set.Ioi a) a","decl":"theorem uniqueDiffWithinAt_Ioi (a : â„) : UniqueDiffWithinAt â„ (Ioi a) a :=\n  uniqueDiffWithinAt_convex (convex_Ioi a) (by simp) (by simp)\n\n"}
{"name":"uniqueDiffWithinAt_Iio","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"a : Real\nâŠ¢ UniqueDiffWithinAt Real (Set.Iio a) a","decl":"theorem uniqueDiffWithinAt_Iio (a : â„) : UniqueDiffWithinAt â„ (Iio a) a :=\n  uniqueDiffWithinAt_convex (convex_Iio a) (by simp) (by simp)\n\n"}
{"name":"uniqueDiffWithinAt_or_nhdsWithin_eq_bot","module":"Mathlib.Analysis.Calculus.TangentCone","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\ns : Set ğ•œ\nx : ğ•œ\nâŠ¢ Or (UniqueDiffWithinAt ğ•œ s x) (Eq (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x))) Bot.bot)","decl":"/-- In one dimension, every point is either a point of unique differentiability, or isolated. -/\ntheorem uniqueDiffWithinAt_or_nhdsWithin_eq_bot (s : Set ğ•œ) (x : ğ•œ) :\n    UniqueDiffWithinAt ğ•œ s x âˆ¨ ğ“[s \\ {x}] x = âŠ¥ := by\n  rcases eq_or_neBot (ğ“[s \\ {x}] x) with h | h\n  Â· exact Or.inr h\n  refine Or.inl âŸ¨?_, ?_âŸ©\n  Â· simp [tangentCone_eq_univ h]\n  Â· simp only [mem_closure_iff_nhdsWithin_neBot]\n    apply neBot_of_le (hf := h)\n    exact nhdsWithin_mono _ diff_subset\n\n"}
