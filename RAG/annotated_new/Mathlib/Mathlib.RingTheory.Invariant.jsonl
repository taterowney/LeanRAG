{"name":"Algebra.IsInvariant.isInvariant","module":"Mathlib.RingTheory.Invariant","initialProofState":"A : Type u_1\nB : Type u_2\nG : Type u_3\ninst✝⁴ : CommSemiring A\ninst✝³ : Semiring B\ninst✝² : Algebra A B\ninst✝¹ : Group G\ninst✝ : MulSemiringAction G B\nself : Algebra.IsInvariant A B G\nb : B\na✝ : ∀ (g : G), Eq (HSMul.hSMul g b) b\n⊢ Exists fun a => Eq ((algebraMap A B) a) b","decl":"/-- An action of a group `G` on an extension of rings `B/A` is invariant if every fixed point of\n`B` lies in the image of `A`. The converse statement that every point in the image of `A` is fixed\nby `G` is `smul_algebraMap` (assuming `SMulCommClass A B G`). -/\n@[mk_iff] class IsInvariant : Prop where\n  isInvariant : ∀ b : B, (∀ g : G, g • b = b) → ∃ a : A, algebraMap A B a = b\n\n"}
{"name":"Algebra.isInvariant_iff","module":"Mathlib.RingTheory.Invariant","initialProofState":"A : Type u_1\nB : Type u_2\nG : Type u_3\ninst✝⁴ : CommSemiring A\ninst✝³ : Semiring B\ninst✝² : Algebra A B\ninst✝¹ : Group G\ninst✝ : MulSemiringAction G B\n⊢ Iff (Algebra.IsInvariant A B G) (∀ (b : B), (∀ (g : G), Eq (HSMul.hSMul g b) b) → Exists fun a => Eq ((algebraMap A B) a) b)","decl":"/-- An action of a group `G` on an extension of rings `B/A` is invariant if every fixed point of\n`B` lies in the image of `A`. The converse statement that every point in the image of `A` is fixed\nby `G` is `smul_algebraMap` (assuming `SMulCommClass A B G`). -/\n@[mk_iff] class IsInvariant : Prop where\n  isInvariant : ∀ b : B, (∀ g : G, g • b = b) → ∃ a : A, algebraMap A B a = b\n\n"}
{"name":"Algebra.isInvariant_of_isGalois","module":"Mathlib.RingTheory.Invariant","initialProofState":"A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst✝¹⁵ : CommRing A\ninst✝¹⁴ : CommRing B\ninst✝¹³ : Field K\ninst✝¹² : Field L\ninst✝¹¹ : Algebra A K\ninst✝¹⁰ : Algebra B L\ninst✝⁹ : IsFractionRing A K\ninst✝⁸ : IsFractionRing B L\ninst✝⁷ : Algebra A B\ninst✝⁶ : Algebra K L\ninst✝⁵ : Algebra A L\ninst✝⁴ : IsScalarTower A K L\ninst✝³ : IsScalarTower A B L\ninst✝² : IsIntegrallyClosed A\ninst✝¹ : IsIntegralClosure B A L\ninst✝ : FiniteDimensional K L\nh : IsGalois K L\n⊢ Algebra.IsInvariant A B (AlgEquiv K L L)","decl":"/-- In the AKLB setup, every fixed point of `B` lies in the image of `A`. -/\ntheorem Algebra.isInvariant_of_isGalois [FiniteDimensional K L] [h : IsGalois K L] :\n    letI := IsIntegralClosure.MulSemiringAction A K L B\n    Algebra.IsInvariant A B (L ≃ₐ[K] L) := by\n  replace h := ((IsGalois.tfae (F := K) (E := L)).out 0 1).mp h\n  letI := IsIntegralClosure.MulSemiringAction A K L B\n  refine ⟨fun b hb ↦ ?_⟩\n  replace hb : algebraMap B L b ∈ IntermediateField.fixedField (⊤ : Subgroup (L ≃ₐ[K] L)) := by\n    rintro ⟨g, -⟩\n    exact (algebraMap_galRestrict_apply A g b).symm.trans (congrArg (algebraMap B L) (hb g))\n  rw [h, IntermediateField.mem_bot] at hb\n  obtain ⟨k, hk⟩ := hb\n  have hb : IsIntegral A b := IsIntegralClosure.isIntegral A L b\n  rw [← isIntegral_algebraMap_iff (NoZeroSMulDivisors.algebraMap_injective B L), ← hk,\n    isIntegral_algebraMap_iff (NoZeroSMulDivisors.algebraMap_injective K L)] at hb\n  obtain ⟨a, rfl⟩ := IsIntegrallyClosed.algebraMap_eq_of_integral hb\n  rw [← IsScalarTower.algebraMap_apply, IsScalarTower.algebraMap_apply A B L,\n    (NoZeroSMulDivisors.algebraMap_injective B L).eq_iff] at hk\n  exact ⟨a, hk⟩\n\n"}
{"name":"MulSemiringAction.charpoly_eq","module":"Mathlib.RingTheory.Invariant","initialProofState":"B : Type u_2\nG : Type u_3\ninst✝³ : CommRing B\ninst✝² : Group G\ninst✝¹ : MulSemiringAction G B\ninst✝ : Fintype G\nb : B\n⊢ Eq (MulSemiringAction.charpoly G b) (Finset.univ.prod fun g => HSub.hSub Polynomial.X (Polynomial.C (HSMul.hSMul g b)))","decl":"theorem charpoly_eq (b : B) : charpoly G b = ∏ g : G, (X - C (g • b)) := rfl\n\n"}
{"name":"MulSemiringAction.charpoly_eq_prod_smul","module":"Mathlib.RingTheory.Invariant","initialProofState":"B : Type u_2\nG : Type u_3\ninst✝³ : CommRing B\ninst✝² : Group G\ninst✝¹ : MulSemiringAction G B\ninst✝ : Fintype G\nb : B\n⊢ Eq (MulSemiringAction.charpoly G b) (Finset.univ.prod fun g => HSMul.hSMul g (HSub.hSub Polynomial.X (Polynomial.C b)))","decl":"theorem charpoly_eq_prod_smul (b : B) : charpoly G b = ∏ g : G, g • (X - C b) := by\n  simp only [smul_sub, smul_C, smul_X, charpoly_eq]\n\n"}
{"name":"MulSemiringAction.monic_charpoly","module":"Mathlib.RingTheory.Invariant","initialProofState":"B : Type u_2\nG : Type u_3\ninst✝³ : CommRing B\ninst✝² : Group G\ninst✝¹ : MulSemiringAction G B\ninst✝ : Fintype G\nb : B\n⊢ (MulSemiringAction.charpoly G b).Monic","decl":"theorem monic_charpoly (b : B) : (charpoly G b).Monic :=\n  monic_prod_of_monic _ _ (fun _ _ ↦ monic_X_sub_C _)\n\n"}
{"name":"MulSemiringAction.eval_charpoly","module":"Mathlib.RingTheory.Invariant","initialProofState":"B : Type u_2\nG : Type u_3\ninst✝³ : CommRing B\ninst✝² : Group G\ninst✝¹ : MulSemiringAction G B\ninst✝ : Fintype G\nb : B\n⊢ Eq (Polynomial.eval b (MulSemiringAction.charpoly G b)) 0","decl":"theorem eval_charpoly (b : B) : (charpoly G b).eval b = 0 := by\n  rw [charpoly_eq, eval_prod]\n  apply Finset.prod_eq_zero (Finset.mem_univ (1 : G))\n  rw [one_smul, eval_sub, eval_C, eval_X, sub_self]\n\n"}
{"name":"MulSemiringAction.smul_charpoly","module":"Mathlib.RingTheory.Invariant","initialProofState":"B : Type u_2\nG : Type u_3\ninst✝³ : CommRing B\ninst✝² : Group G\ninst✝¹ : MulSemiringAction G B\ninst✝ : Fintype G\nb : B\ng : G\n⊢ Eq (HSMul.hSMul g (MulSemiringAction.charpoly G b)) (MulSemiringAction.charpoly G b)","decl":"theorem smul_charpoly (b : B) (g : G) : g • (charpoly G b) = charpoly G b := by\n  rw [charpoly_eq_prod_smul, Finset.smul_prod_perm]\n\n"}
{"name":"MulSemiringAction.smul_coeff_charpoly","module":"Mathlib.RingTheory.Invariant","initialProofState":"B : Type u_2\nG : Type u_3\ninst✝³ : CommRing B\ninst✝² : Group G\ninst✝¹ : MulSemiringAction G B\ninst✝ : Fintype G\nb : B\nn : Nat\ng : G\n⊢ Eq (HSMul.hSMul g ((MulSemiringAction.charpoly G b).coeff n)) ((MulSemiringAction.charpoly G b).coeff n)","decl":"theorem smul_coeff_charpoly (b : B) (n : ℕ) (g : G) :\n    g • (charpoly G b).coeff n = (charpoly G b).coeff n := by\n  rw [← coeff_smul, smul_charpoly]\n\n"}
{"name":"Algebra.IsInvariant.charpoly_mem_lifts","module":"Mathlib.RingTheory.Invariant","initialProofState":"A : Type u_1\nB : Type u_2\nG : Type u_3\ninst✝⁶ : CommRing A\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra A B\ninst✝³ : Group G\ninst✝² : MulSemiringAction G B\ninst✝¹ : Algebra.IsInvariant A B G\ninst✝ : Fintype G\nb : B\n⊢ Membership.mem (Polynomial.lifts (algebraMap A B)) (MulSemiringAction.charpoly G b)","decl":"theorem charpoly_mem_lifts [Fintype G] (b : B) :\n    charpoly G b ∈ Polynomial.lifts (algebraMap A B) :=\n  (charpoly G b).lifts_iff_coeff_lifts.mpr fun n ↦ isInvariant _ (smul_coeff_charpoly b n)\n\n"}
{"name":"Algebra.IsInvariant.isIntegral","module":"Mathlib.RingTheory.Invariant","initialProofState":"A : Type u_1\nB : Type u_2\nG : Type u_3\ninst✝⁶ : CommRing A\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra A B\ninst✝³ : Group G\ninst✝² : MulSemiringAction G B\ninst✝¹ : Algebra.IsInvariant A B G\ninst✝ : Finite G\n⊢ Algebra.IsIntegral A B","decl":"theorem isIntegral [Finite G] : Algebra.IsIntegral A B := by\n  cases nonempty_fintype G\n  refine ⟨fun b ↦ ?_⟩\n  obtain ⟨p, hp1, -, hp2⟩ := Polynomial.lifts_and_natDegree_eq_and_monic\n    (charpoly_mem_lifts A B G b) (monic_charpoly G b)\n  exact ⟨p, hp2, by rw [← eval_map, hp1, eval_charpoly]⟩\n\n"}
{"name":"Algebra.IsInvariant.exists_smul_of_under_eq","module":"Mathlib.RingTheory.Invariant","initialProofState":"A : Type u_1\nB : Type u_2\nG : Type u_3\ninst✝⁷ : CommRing A\ninst✝⁶ : CommRing B\ninst✝⁵ : Algebra A B\ninst✝⁴ : Group G\ninst✝³ : MulSemiringAction G B\ninst✝² : Algebra.IsInvariant A B G\ninst✝¹ : Finite G\ninst✝ : SMulCommClass G A B\nP Q : Ideal B\nhP : P.IsPrime\nhQ : Q.IsPrime\nhPQ : Eq (Ideal.under A P) (Ideal.under A Q)\n⊢ Exists fun g => Eq Q (HSMul.hSMul g P)","decl":"/-- `G` acts transitively on the prime ideals of `B` above a given prime ideal of `A`. -/\ntheorem exists_smul_of_under_eq [Finite G] [SMulCommClass G A B]\n    (P Q : Ideal B) [hP : P.IsPrime] [hQ : Q.IsPrime]\n    (hPQ : P.under A = Q.under A) :\n    ∃ g : G, Q = g • P := by\n  cases nonempty_fintype G\n  have : ∀ (P Q : Ideal B) [P.IsPrime] [Q.IsPrime], P.under A = Q.under A →\n      ∃ g ∈ (⊤ : Finset G), Q ≤ g • P := by\n    intro P Q hP hQ hPQ\n    rw [← Ideal.subset_union_prime 1 1 (fun _ _ _ _ ↦ hP.smul _)]\n    intro b hb\n    suffices h : ∃ g ∈ Finset.univ, g • b ∈ P by\n      obtain ⟨g, -, hg⟩ := h\n      apply Set.mem_biUnion (Finset.mem_univ g⁻¹) (Ideal.mem_inv_pointwise_smul_iff.mpr hg)\n    obtain ⟨a, ha⟩ := isInvariant (A := A) (∏ g : G, g • b) (Finset.smul_prod_perm b)\n    rw [← hP.prod_mem_iff, ← ha, ← P.mem_comap, ← P.under_def A,\n      hPQ, Q.mem_comap, ha, hQ.prod_mem_iff]\n    exact ⟨1, Finset.mem_univ 1, (one_smul G b).symm ▸ hb⟩\n  obtain ⟨g, -, hg⟩ := this P Q hPQ\n  obtain ⟨g', -, hg'⟩ := this Q (g • P) ((P.under_smul A g).trans hPQ).symm\n  exact ⟨g, le_antisymm hg (smul_eq_of_le_smul (hg.trans hg') ▸ hg')⟩\n\n"}
{"name":"IsFractionRing.stabilizerHom_surjective","module":"Mathlib.RingTheory.Invariant","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹⁹ : CommRing A\ninst✝¹⁸ : CommRing B\ninst✝¹⁷ : Algebra A B\nG : Type u_3\ninst✝¹⁶ : Group G\ninst✝¹⁵ : Finite G\ninst✝¹⁴ : MulSemiringAction G B\ninst✝¹³ : SMulCommClass G A B\nP : Ideal A\nQ : Ideal B\ninst✝¹² : Q.IsPrime\ninst✝¹¹ : Q.LiesOver P\nK : Type u_4\nL : Type u_5\ninst✝¹⁰ : Field K\ninst✝⁹ : Field L\ninst✝⁸ : Algebra (HasQuotient.Quotient A P) K\ninst✝⁷ : Algebra (HasQuotient.Quotient B Q) L\ninst✝⁶ : Algebra (HasQuotient.Quotient A P) L\ninst✝⁵ : IsScalarTower (HasQuotient.Quotient A P) (HasQuotient.Quotient B Q) L\ninst✝⁴ : Algebra K L\ninst✝³ : IsScalarTower (HasQuotient.Quotient A P) K L\ninst✝² : Algebra.IsInvariant A B G\ninst✝¹ : IsFractionRing (HasQuotient.Quotient A P) K\ninst✝ : IsFractionRing (HasQuotient.Quotient B Q) L\n⊢ Function.Surjective ⇑(IsFractionRing.stabilizerHom G P Q K L)","decl":"/-- The stabilizer subgroup of `Q` surjects onto `Aut(Frac(B/Q)/Frac(A/P))`. -/\ntheorem IsFractionRing.stabilizerHom_surjective :\n    Function.Surjective (stabilizerHom G P Q K L) := by\n  let _ := MulSemiringAction.compHom L (stabilizerHom G P Q K L)\n  intro f\n  obtain ⟨g, hg⟩ := FixedPoints.toAlgAut_surjective (MulAction.stabilizer G Q) L\n    (AlgEquiv.ofRingEquiv (f := f) (fun x ↦ fixed_of_fixed2 G P Q K L f x x.2))\n  exact ⟨g, by rwa [AlgEquiv.ext_iff] at hg ⊢⟩\n\n"}
{"name":"Ideal.Quotient.stabilizerHom_surjective","module":"Mathlib.RingTheory.Invariant","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁹ : CommRing A\ninst✝⁸ : CommRing B\ninst✝⁷ : Algebra A B\nG : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : Finite G\ninst✝⁴ : MulSemiringAction G B\ninst✝³ : SMulCommClass G A B\nP : Ideal A\nQ : Ideal B\ninst✝² : Q.IsPrime\ninst✝¹ : Q.LiesOver P\ninst✝ : Algebra.IsInvariant A B G\n⊢ Function.Surjective ⇑(Ideal.Quotient.stabilizerHom Q P G)","decl":"/-- The stabilizer subgroup of `Q` surjects onto `Aut((B/Q)/(A/P))`. -/\ntheorem Ideal.Quotient.stabilizerHom_surjective :\n    Function.Surjective (Ideal.Quotient.stabilizerHom Q P G) := by\n  have : P.IsPrime := Ideal.over_def Q P ▸ Ideal.IsPrime.under A Q\n  let _ := FractionRing.liftAlgebra (A ⧸ P) (FractionRing (B ⧸ Q))\n  have key := IsFractionRing.stabilizerHom_surjective G P Q\n    (FractionRing (A ⧸ P)) (FractionRing (B ⧸ Q))\n  rw [IsFractionRing.stabilizerHom, MonoidHom.coe_comp] at key\n  exact key.of_comp_left (IsFractionRing.fieldEquivOfAlgEquivHom_injective (A ⧸ P) (B ⧸ Q)\n    (FractionRing (A ⧸ P)) (FractionRing (B ⧸ Q)))\n\n"}
