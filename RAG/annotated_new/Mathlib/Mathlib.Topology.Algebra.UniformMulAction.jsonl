{"name":"UniformContinuousConstVAdd.uniformContinuous_const_vadd","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝¹ : UniformSpace X\ninst✝ : VAdd M X\nself : UniformContinuousConstVAdd M X\nc : M\n⊢ UniformContinuous fun x => HVAdd.hVAdd c x","decl":"/-- An additive action such that for all `c`, the map `fun x ↦ c +ᵥ x` is uniformly continuous. -/\nclass UniformContinuousConstVAdd [VAdd M X] : Prop where\n  uniformContinuous_const_vadd : ∀ c : M, UniformContinuous (c +ᵥ · : X → X)\n\n"}
{"name":"UniformContinuousConstSMul.uniformContinuous_const_smul","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝¹ : UniformSpace X\ninst✝ : SMul M X\nself : UniformContinuousConstSMul M X\nc : M\n⊢ UniformContinuous fun x => HSMul.hSMul c x","decl":"/-- A multiplicative action such that for all `c`,\nthe map `fun x ↦ c • x` is uniformly continuous. -/\n@[to_additive]\nclass UniformContinuousConstSMul [SMul M X] : Prop where\n  uniformContinuous_const_smul : ∀ c : M, UniformContinuous (c • · : X → X)\n\n"}
{"name":"AddMonoid.uniformContinuousConstSMul_nat","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"X : Type x\ninst✝² : UniformSpace X\ninst✝¹ : AddGroup X\ninst✝ : UniformAddGroup X\n⊢ UniformContinuousConstSMul Nat X","decl":"instance AddMonoid.uniformContinuousConstSMul_nat [AddGroup X] [UniformAddGroup X] :\n    UniformContinuousConstSMul ℕ X :=\n  ⟨uniformContinuous_const_nsmul⟩\n\n"}
{"name":"AddGroup.uniformContinuousConstSMul_int","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"X : Type x\ninst✝² : UniformSpace X\ninst✝¹ : AddGroup X\ninst✝ : UniformAddGroup X\n⊢ UniformContinuousConstSMul Int X","decl":"instance AddGroup.uniformContinuousConstSMul_int [AddGroup X] [UniformAddGroup X] :\n    UniformContinuousConstSMul ℤ X :=\n  ⟨uniformContinuous_const_zsmul⟩\n\n"}
{"name":"uniformContinuousConstSMul_of_continuousConstSMul","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Monoid R\ninst✝⁴ : AddCommGroup M\ninst✝³ : DistribMulAction R M\ninst✝² : UniformSpace M\ninst✝¹ : UniformAddGroup M\ninst✝ : ContinuousConstSMul R M\n⊢ UniformContinuousConstSMul R M","decl":"/-- A `DistribMulAction` that is continuous on a uniform group is uniformly continuous.\nThis can't be an instance due to it forming a loop with\n`UniformContinuousConstSMul.to_continuousConstSMul` -/\ntheorem uniformContinuousConstSMul_of_continuousConstSMul [Monoid R] [AddCommGroup M]\n    [DistribMulAction R M] [UniformSpace M] [UniformAddGroup M] [ContinuousConstSMul R M] :\n    UniformContinuousConstSMul R M :=\n  ⟨fun r =>\n    uniformContinuous_of_continuousAt_zero (DistribMulAction.toAddMonoidHom M r)\n      (Continuous.continuousAt (continuous_const_smul r))⟩\n\n"}
{"name":"Ring.uniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"R : Type u\ninst✝³ : Ring R\ninst✝² : UniformSpace R\ninst✝¹ : UniformAddGroup R\ninst✝ : ContinuousMul R\n⊢ UniformContinuousConstSMul R R","decl":"/-- The action of `Semiring.toModule` is uniformly continuous. -/\ninstance Ring.uniformContinuousConstSMul [Ring R] [UniformSpace R] [UniformAddGroup R]\n    [ContinuousMul R] : UniformContinuousConstSMul R R :=\n  uniformContinuousConstSMul_of_continuousConstSMul _ _\n\n"}
{"name":"Ring.uniformContinuousConstSMul_op","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"R : Type u\ninst✝³ : Ring R\ninst✝² : UniformSpace R\ninst✝¹ : UniformAddGroup R\ninst✝ : ContinuousMul R\n⊢ UniformContinuousConstSMul (MulOpposite R) R","decl":"/-- The action of `Semiring.toOppositeModule` is uniformly continuous. -/\ninstance Ring.uniformContinuousConstSMul_op [Ring R] [UniformSpace R] [UniformAddGroup R]\n    [ContinuousMul R] : UniformContinuousConstSMul Rᵐᵒᵖ R :=\n  uniformContinuousConstSMul_of_continuousConstSMul _ _\n\n"}
{"name":"UniformContinuousConstSMul.to_continuousConstSMul","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝² : UniformSpace X\ninst✝¹ : SMul M X\ninst✝ : UniformContinuousConstSMul M X\n⊢ ContinuousConstSMul M X","decl":"@[to_additive]\ninstance (priority := 100) UniformContinuousConstSMul.to_continuousConstSMul\n    [UniformContinuousConstSMul M X] : ContinuousConstSMul M X :=\n  ⟨fun c => (uniformContinuous_const_smul c).continuous⟩\n\n"}
{"name":"UniformContinuousConstVAdd.to_continuousConstVAdd","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝² : UniformSpace X\ninst✝¹ : VAdd M X\ninst✝ : UniformContinuousConstVAdd M X\n⊢ ContinuousConstVAdd M X","decl":"@[to_additive]\ninstance (priority := 100) UniformContinuousConstSMul.to_continuousConstSMul\n    [UniformContinuousConstSMul M X] : ContinuousConstSMul M X :=\n  ⟨fun c => (uniformContinuous_const_smul c).continuous⟩\n\n"}
{"name":"UniformContinuous.const_vadd","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\nY : Type y\ninst✝³ : UniformSpace X\ninst✝² : UniformSpace Y\ninst✝¹ : VAdd M X\ninst✝ : UniformContinuousConstVAdd M X\nf : Y → X\nhf : UniformContinuous f\nc : M\n⊢ UniformContinuous (HVAdd.hVAdd c f)","decl":"@[to_additive]\ntheorem UniformContinuous.const_smul [UniformContinuousConstSMul M X] {f : Y → X}\n    (hf : UniformContinuous f) (c : M) : UniformContinuous (c • f) :=\n  (uniformContinuous_const_smul c).comp hf\n\n"}
{"name":"UniformContinuous.const_smul","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\nY : Type y\ninst✝³ : UniformSpace X\ninst✝² : UniformSpace Y\ninst✝¹ : SMul M X\ninst✝ : UniformContinuousConstSMul M X\nf : Y → X\nhf : UniformContinuous f\nc : M\n⊢ UniformContinuous (HSMul.hSMul c f)","decl":"@[to_additive]\ntheorem UniformContinuous.const_smul [UniformContinuousConstSMul M X] {f : Y → X}\n    (hf : UniformContinuous f) (c : M) : UniformContinuous (c • f) :=\n  (uniformContinuous_const_smul c).comp hf\n\n"}
{"name":"IsUniformInducing.uniformContinuousConstVAdd","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\nY : Type y\ninst✝⁴ : UniformSpace X\ninst✝³ : UniformSpace Y\ninst✝² : VAdd M X\ninst✝¹ : VAdd M Y\ninst✝ : UniformContinuousConstVAdd M Y\nf : X → Y\nhf : IsUniformInducing f\nhsmul : ∀ (c : M) (x : X), Eq (f (HVAdd.hVAdd c x)) (HVAdd.hVAdd c (f x))\n⊢ UniformContinuousConstVAdd M X","decl":"@[to_additive]\nlemma IsUniformInducing.uniformContinuousConstSMul [SMul M Y] [UniformContinuousConstSMul M Y]\n    {f : X → Y} (hf : IsUniformInducing f) (hsmul : ∀ (c : M) x, f (c • x) = c • f x) :\n    UniformContinuousConstSMul M X where\n  uniformContinuous_const_smul c := by\n    simpa only [hf.uniformContinuous_iff, Function.comp_def, hsmul]\n      using hf.uniformContinuous.const_smul c\n\n"}
{"name":"IsUniformInducing.uniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\nY : Type y\ninst✝⁴ : UniformSpace X\ninst✝³ : UniformSpace Y\ninst✝² : SMul M X\ninst✝¹ : SMul M Y\ninst✝ : UniformContinuousConstSMul M Y\nf : X → Y\nhf : IsUniformInducing f\nhsmul : ∀ (c : M) (x : X), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))\n⊢ UniformContinuousConstSMul M X","decl":"@[to_additive]\nlemma IsUniformInducing.uniformContinuousConstSMul [SMul M Y] [UniformContinuousConstSMul M Y]\n    {f : X → Y} (hf : IsUniformInducing f) (hsmul : ∀ (c : M) x, f (c • x) = c • f x) :\n    UniformContinuousConstSMul M X where\n  uniformContinuous_const_smul c := by\n    simpa only [hf.uniformContinuous_iff, Function.comp_def, hsmul]\n      using hf.uniformContinuous.const_smul c\n\n"}
{"name":"UniformInducing.uniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\nY : Type y\ninst✝⁴ : UniformSpace X\ninst✝³ : UniformSpace Y\ninst✝² : SMul M X\ninst✝¹ : SMul M Y\ninst✝ : UniformContinuousConstSMul M Y\nf : X → Y\nhf : IsUniformInducing f\nhsmul : ∀ (c : M) (x : X), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))\n⊢ UniformContinuousConstSMul M X","decl":"@[deprecated (since := \"2024-10-05\")]\nalias UniformInducing.uniformContinuousConstSMul := IsUniformInducing.uniformContinuousConstSMul\n\n"}
{"name":"UniformContinuousConstVAdd.op","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝⁴ : UniformSpace X\ninst✝³ : VAdd M X\ninst✝² : VAdd (AddOpposite M) X\ninst✝¹ : IsCentralVAdd M X\ninst✝ : UniformContinuousConstVAdd M X\n⊢ UniformContinuousConstVAdd (AddOpposite M) X","decl":"/-- If a scalar action is central, then its right action is uniform continuous when its left action\nis. -/\n@[to_additive \"If an additive action is central, then its right action is uniform\ncontinuous when its left action is.\"]\ninstance (priority := 100) UniformContinuousConstSMul.op [SMul Mᵐᵒᵖ X] [IsCentralScalar M X]\n    [UniformContinuousConstSMul M X] : UniformContinuousConstSMul Mᵐᵒᵖ X :=\n  ⟨MulOpposite.rec' fun c ↦ by simpa only [op_smul_eq_smul] using uniformContinuous_const_smul c⟩\n\n"}
{"name":"UniformContinuousConstSMul.op","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝⁴ : UniformSpace X\ninst✝³ : SMul M X\ninst✝² : SMul (MulOpposite M) X\ninst✝¹ : IsCentralScalar M X\ninst✝ : UniformContinuousConstSMul M X\n⊢ UniformContinuousConstSMul (MulOpposite M) X","decl":"/-- If a scalar action is central, then its right action is uniform continuous when its left action\nis. -/\n@[to_additive \"If an additive action is central, then its right action is uniform\ncontinuous when its left action is.\"]\ninstance (priority := 100) UniformContinuousConstSMul.op [SMul Mᵐᵒᵖ X] [IsCentralScalar M X]\n    [UniformContinuousConstSMul M X] : UniformContinuousConstSMul Mᵐᵒᵖ X :=\n  ⟨MulOpposite.rec' fun c ↦ by simpa only [op_smul_eq_smul] using uniformContinuous_const_smul c⟩\n\n"}
{"name":"AddOpposite.uniformContinuousConstVAdd","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝² : UniformSpace X\ninst✝¹ : VAdd M X\ninst✝ : UniformContinuousConstVAdd M X\n⊢ UniformContinuousConstVAdd M (AddOpposite X)","decl":"@[to_additive]\ninstance MulOpposite.uniformContinuousConstSMul [UniformContinuousConstSMul M X] :\n    UniformContinuousConstSMul M Xᵐᵒᵖ :=\n  ⟨fun c =>\n    MulOpposite.uniformContinuous_op.comp <| MulOpposite.uniformContinuous_unop.const_smul c⟩\n\n"}
{"name":"MulOpposite.uniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝² : UniformSpace X\ninst✝¹ : SMul M X\ninst✝ : UniformContinuousConstSMul M X\n⊢ UniformContinuousConstSMul M (MulOpposite X)","decl":"@[to_additive]\ninstance MulOpposite.uniformContinuousConstSMul [UniformContinuousConstSMul M X] :\n    UniformContinuousConstSMul M Xᵐᵒᵖ :=\n  ⟨fun c =>\n    MulOpposite.uniformContinuous_op.comp <| MulOpposite.uniformContinuous_unop.const_smul c⟩\n\n"}
{"name":"UniformAddGroup.to_uniformContinuousConstVAdd","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"G : Type u\ninst✝² : AddGroup G\ninst✝¹ : UniformSpace G\ninst✝ : UniformAddGroup G\n⊢ UniformContinuousConstVAdd G G","decl":"@[to_additive]\ninstance UniformGroup.to_uniformContinuousConstSMul {G : Type u} [Group G] [UniformSpace G]\n    [UniformGroup G] : UniformContinuousConstSMul G G :=\n  ⟨fun _ => uniformContinuous_const.mul uniformContinuous_id⟩\n\n"}
{"name":"UniformGroup.to_uniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"G : Type u\ninst✝² : Group G\ninst✝¹ : UniformSpace G\ninst✝ : UniformGroup G\n⊢ UniformContinuousConstSMul G G","decl":"@[to_additive]\ninstance UniformGroup.to_uniformContinuousConstSMul {G : Type u} [Group G] [UniformSpace G]\n    [UniformGroup G] : UniformContinuousConstSMul G G :=\n  ⟨fun _ => uniformContinuous_const.mul uniformContinuous_id⟩\n\n"}
{"name":"UniformContinuous.const_mul'","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"R : Type u_1\nβ : Type u_2\ninst✝³ : Ring R\ninst✝² : UniformSpace R\ninst✝¹ : UniformSpace β\ninst✝ : UniformContinuousConstSMul R R\nf : β → R\nhf : UniformContinuous f\na : R\n⊢ UniformContinuous fun x => HMul.hMul a (f x)","decl":"theorem UniformContinuous.const_mul' [UniformContinuousConstSMul R R] {f : β → R}\n    (hf : UniformContinuous f) (a : R) : UniformContinuous fun x ↦ a * f x :=\n  hf.const_smul a\n\n"}
{"name":"UniformContinuous.mul_const'","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"R : Type u_1\nβ : Type u_2\ninst✝³ : Ring R\ninst✝² : UniformSpace R\ninst✝¹ : UniformSpace β\ninst✝ : UniformContinuousConstSMul (MulOpposite R) R\nf : β → R\nhf : UniformContinuous f\na : R\n⊢ UniformContinuous fun x => HMul.hMul (f x) a","decl":"theorem UniformContinuous.mul_const' [UniformContinuousConstSMul Rᵐᵒᵖ R] {f : β → R}\n    (hf : UniformContinuous f) (a : R) : UniformContinuous fun x ↦ f x * a :=\n  hf.const_smul (MulOpposite.op a)\n\n"}
{"name":"uniformContinuous_mul_left'","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : UniformSpace R\ninst✝ : UniformContinuousConstSMul R R\na : R\n⊢ UniformContinuous fun b => HMul.hMul a b","decl":"theorem uniformContinuous_mul_left' [UniformContinuousConstSMul R R] (a : R) :\n    UniformContinuous fun b : R => a * b :=\n  uniformContinuous_id.const_mul' _\n\n"}
{"name":"uniformContinuous_mul_right'","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : UniformSpace R\ninst✝ : UniformContinuousConstSMul (MulOpposite R) R\na : R\n⊢ UniformContinuous fun b => HMul.hMul b a","decl":"theorem uniformContinuous_mul_right' [UniformContinuousConstSMul Rᵐᵒᵖ R] (a : R) :\n    UniformContinuous fun b : R => b * a :=\n  uniformContinuous_id.mul_const' _\n\n"}
{"name":"UniformContinuous.div_const'","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"R : Type u_3\nβ : Type u_4\ninst✝³ : DivisionRing R\ninst✝² : UniformSpace R\ninst✝¹ : UniformContinuousConstSMul (MulOpposite R) R\ninst✝ : UniformSpace β\nf : β → R\nhf : UniformContinuous f\na : R\n⊢ UniformContinuous fun x => HDiv.hDiv (f x) a","decl":"theorem UniformContinuous.div_const' {R β : Type*} [DivisionRing R] [UniformSpace R]\n    [UniformContinuousConstSMul Rᵐᵒᵖ R] [UniformSpace β] {f : β → R}\n    (hf : UniformContinuous f) (a : R) :\n    UniformContinuous fun x ↦ f x / a := by\n  simpa [div_eq_mul_inv] using hf.mul_const' a⁻¹\n\n"}
{"name":"uniformContinuous_div_const'","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"R : Type u_3\ninst✝² : DivisionRing R\ninst✝¹ : UniformSpace R\ninst✝ : UniformContinuousConstSMul (MulOpposite R) R\na : R\n⊢ UniformContinuous fun b => HDiv.hDiv b a","decl":"theorem uniformContinuous_div_const' {R : Type*} [DivisionRing R] [UniformSpace R]\n    [UniformContinuousConstSMul Rᵐᵒᵖ R] (a : R) :\n    UniformContinuous fun b : R => b / a :=\n  uniformContinuous_id.div_const' _\n\n"}
{"name":"UniformSpace.Completion.vadd_def","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝¹ : UniformSpace X\ninst✝ : VAdd M X\nc : M\nx : UniformSpace.Completion X\n⊢ Eq (HVAdd.hVAdd c x) (UniformSpace.Completion.map (fun x => HVAdd.hVAdd c x) x)","decl":"@[to_additive]\ntheorem smul_def (c : M) (x : Completion X) : c • x = Completion.map (c • ·) x :=\n  rfl\n\n"}
{"name":"UniformSpace.Completion.smul_def","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝¹ : UniformSpace X\ninst✝ : SMul M X\nc : M\nx : UniformSpace.Completion X\n⊢ Eq (HSMul.hSMul c x) (UniformSpace.Completion.map (fun x => HSMul.hSMul c x) x)","decl":"@[to_additive]\ntheorem smul_def (c : M) (x : Completion X) : c • x = Completion.map (c • ·) x :=\n  rfl\n\n"}
{"name":"UniformSpace.Completion.instUniformContinuousConstVAdd","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝¹ : UniformSpace X\ninst✝ : VAdd M X\n⊢ UniformContinuousConstVAdd M (UniformSpace.Completion X)","decl":"@[to_additive]\ninstance : UniformContinuousConstSMul M (Completion X) :=\n  ⟨fun _ => uniformContinuous_map⟩\n\n"}
{"name":"UniformSpace.Completion.instUniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝¹ : UniformSpace X\ninst✝ : SMul M X\n⊢ UniformContinuousConstSMul M (UniformSpace.Completion X)","decl":"@[to_additive]\ninstance : UniformContinuousConstSMul M (Completion X) :=\n  ⟨fun _ => uniformContinuous_map⟩\n\n"}
{"name":"UniformSpace.Completion.instVAddAssocClass","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nN : Type w\nX : Type x\ninst✝⁶ : UniformSpace X\ninst✝⁵ : VAdd M X\ninst✝⁴ : VAdd N X\ninst✝³ : VAdd M N\ninst✝² : UniformContinuousConstVAdd M X\ninst✝¹ : UniformContinuousConstVAdd N X\ninst✝ : VAddAssocClass M N X\n⊢ VAddAssocClass M N (UniformSpace.Completion X)","decl":"@[to_additive instVAddAssocClass]\ninstance instIsScalarTower [SMul N X] [SMul M N] [UniformContinuousConstSMul M X]\n    [UniformContinuousConstSMul N X] [IsScalarTower M N X] : IsScalarTower M N (Completion X) :=\n  ⟨fun m n x => by\n    have : _ = (_ : Completion X → Completion X) :=\n      map_comp (uniformContinuous_const_smul m) (uniformContinuous_const_smul n)\n    refine Eq.trans ?_ (congr_fun this.symm x)\n    exact congr_arg (fun f => Completion.map f x) (funext (smul_assoc _ _))⟩\n\n"}
{"name":"UniformSpace.Completion.instIsScalarTower","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nN : Type w\nX : Type x\ninst✝⁶ : UniformSpace X\ninst✝⁵ : SMul M X\ninst✝⁴ : SMul N X\ninst✝³ : SMul M N\ninst✝² : UniformContinuousConstSMul M X\ninst✝¹ : UniformContinuousConstSMul N X\ninst✝ : IsScalarTower M N X\n⊢ IsScalarTower M N (UniformSpace.Completion X)","decl":"@[to_additive instVAddAssocClass]\ninstance instIsScalarTower [SMul N X] [SMul M N] [UniformContinuousConstSMul M X]\n    [UniformContinuousConstSMul N X] [IsScalarTower M N X] : IsScalarTower M N (Completion X) :=\n  ⟨fun m n x => by\n    have : _ = (_ : Completion X → Completion X) :=\n      map_comp (uniformContinuous_const_smul m) (uniformContinuous_const_smul n)\n    refine Eq.trans ?_ (congr_fun this.symm x)\n    exact congr_arg (fun f => Completion.map f x) (funext (smul_assoc _ _))⟩\n\n"}
{"name":"UniformSpace.Completion.instSMulCommClassOfUniformContinuousConstSMul","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nN : Type w\nX : Type x\ninst✝⁵ : UniformSpace X\ninst✝⁴ : SMul M X\ninst✝³ : SMul N X\ninst✝² : SMulCommClass M N X\ninst✝¹ : UniformContinuousConstSMul M X\ninst✝ : UniformContinuousConstSMul N X\n⊢ SMulCommClass M N (UniformSpace.Completion X)","decl":"@[to_additive]\ninstance [SMul N X] [SMulCommClass M N X] [UniformContinuousConstSMul M X]\n    [UniformContinuousConstSMul N X] : SMulCommClass M N (Completion X) :=\n  ⟨fun m n x => by\n    have hmn : m • n • x = (Completion.map (SMul.smul m) ∘ Completion.map (SMul.smul n)) x := rfl\n    have hnm : n • m • x = (Completion.map (SMul.smul n) ∘ Completion.map (SMul.smul m)) x := rfl\n    rw [hmn, hnm, map_comp, map_comp]\n    · exact congr_arg (fun f => Completion.map f x) (funext (smul_comm _ _))\n    repeat' exact uniformContinuous_const_smul _⟩\n\n"}
{"name":"UniformSpace.Completion.instVAddCommClassOfUniformContinuousConstVAdd","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nN : Type w\nX : Type x\ninst✝⁵ : UniformSpace X\ninst✝⁴ : VAdd M X\ninst✝³ : VAdd N X\ninst✝² : VAddCommClass M N X\ninst✝¹ : UniformContinuousConstVAdd M X\ninst✝ : UniformContinuousConstVAdd N X\n⊢ VAddCommClass M N (UniformSpace.Completion X)","decl":"@[to_additive]\ninstance [SMul N X] [SMulCommClass M N X] [UniformContinuousConstSMul M X]\n    [UniformContinuousConstSMul N X] : SMulCommClass M N (Completion X) :=\n  ⟨fun m n x => by\n    have hmn : m • n • x = (Completion.map (SMul.smul m) ∘ Completion.map (SMul.smul n)) x := rfl\n    have hnm : n • m • x = (Completion.map (SMul.smul n) ∘ Completion.map (SMul.smul m)) x := rfl\n    rw [hmn, hnm, map_comp, map_comp]\n    · exact congr_arg (fun f => Completion.map f x) (funext (smul_comm _ _))\n    repeat' exact uniformContinuous_const_smul _⟩\n\n"}
{"name":"UniformSpace.Completion.instIsCentralScalar","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝³ : UniformSpace X\ninst✝² : SMul M X\ninst✝¹ : SMul (MulOpposite M) X\ninst✝ : IsCentralScalar M X\n⊢ IsCentralScalar M (UniformSpace.Completion X)","decl":"@[to_additive]\ninstance [SMul Mᵐᵒᵖ X] [IsCentralScalar M X] : IsCentralScalar M (Completion X) :=\n  ⟨fun c a => (congr_arg fun f => Completion.map f a) <| funext (op_smul_eq_smul c)⟩\n\n"}
{"name":"UniformSpace.Completion.instIsCentralVAdd","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝³ : UniformSpace X\ninst✝² : VAdd M X\ninst✝¹ : VAdd (AddOpposite M) X\ninst✝ : IsCentralVAdd M X\n⊢ IsCentralVAdd M (UniformSpace.Completion X)","decl":"@[to_additive]\ninstance [SMul Mᵐᵒᵖ X] [IsCentralScalar M X] : IsCentralScalar M (Completion X) :=\n  ⟨fun c a => (congr_arg fun f => Completion.map f a) <| funext (op_smul_eq_smul c)⟩\n\n"}
{"name":"UniformSpace.Completion.coe_smul","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝² : UniformSpace X\ninst✝¹ : SMul M X\ninst✝ : UniformContinuousConstSMul M X\nc : M\nx : X\n⊢ Eq (↑(HSMul.hSMul c x)) (HSMul.hSMul c ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul (c : M) (x : X) : (↑(c • x) : Completion X) = c • (x : Completion X) :=\n  (map_coe (uniformContinuous_const_smul c) x).symm\n\n"}
{"name":"UniformSpace.Completion.coe_vadd","module":"Mathlib.Topology.Algebra.UniformMulAction","initialProofState":"M : Type v\nX : Type x\ninst✝² : UniformSpace X\ninst✝¹ : VAdd M X\ninst✝ : UniformContinuousConstVAdd M X\nc : M\nx : X\n⊢ Eq (↑(HVAdd.hVAdd c x)) (HVAdd.hVAdd c ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul (c : M) (x : X) : (↑(c • x) : Completion X) = c • (x : Completion X) :=\n  (map_coe (uniformContinuous_const_smul c) x).symm\n\n"}
