{"name":"span_eq_top_of_isLocalizedModule","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\nRₛ : Type u_2\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\ninst✝⁹ : CommSemiring Rₛ\ninst✝⁸ : Algebra R Rₛ\ninst✝⁷ : IsLocalization S Rₛ\nM : Type u_3\nMₛ : Type u_4\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid Mₛ\ninst✝³ : Module R Mₛ\ninst✝² : Module Rₛ Mₛ\ninst✝¹ : IsScalarTower R Rₛ Mₛ\nf : LinearMap (RingHom.id R) M Mₛ\ninst✝ : IsLocalizedModule S f\nv : Set M\nhv : Eq (Submodule.span R v) Top.top\n⊢ Eq (Submodule.span Rₛ (Set.image (⇑f) v)) Top.top","decl":"theorem span_eq_top_of_isLocalizedModule {v : Set M} (hv : span R v = ⊤) :\n    span Rₛ (f '' v) = ⊤ := top_unique fun x _ ↦ by\n  obtain ⟨⟨m, s⟩, h⟩ := IsLocalizedModule.surj S f x\n  rw [Submonoid.smul_def, ← algebraMap_smul Rₛ, ← Units.smul_isUnit (IsLocalization.map_units Rₛ s),\n    eq_comm, ← inv_smul_eq_iff] at h\n  refine h ▸ smul_mem _ _  (span_subset_span R Rₛ _ ?_)\n  rw [← LinearMap.coe_restrictScalars R, ← LinearMap.map_span, hv]\n  exact mem_map_of_mem mem_top\n\n"}
{"name":"LinearIndependent.of_isLocalizedModule","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\nRₛ : Type u_2\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\ninst✝⁹ : CommSemiring Rₛ\ninst✝⁸ : Algebra R Rₛ\ninst✝⁷ : IsLocalization S Rₛ\nM : Type u_3\nMₛ : Type u_4\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid Mₛ\ninst✝³ : Module R Mₛ\ninst✝² : Module Rₛ Mₛ\ninst✝¹ : IsScalarTower R Rₛ Mₛ\nf : LinearMap (RingHom.id R) M Mₛ\ninst✝ : IsLocalizedModule S f\nι : Type u_5\nv : ι → M\nhv : LinearIndependent R v\n⊢ LinearIndependent Rₛ (Function.comp (⇑f) v)","decl":"theorem LinearIndependent.of_isLocalizedModule {ι : Type*} {v : ι → M}\n    (hv : LinearIndependent R v) : LinearIndependent Rₛ (f ∘ v) := by\n  rw [linearIndependent_iff'ₛ] at hv ⊢\n  intro t g₁ g₂ eq i hi\n  choose! a fg hfg using IsLocalization.exist_integer_multiples S (t.disjSum t) (Sum.elim g₁ g₂)\n  simp_rw [Sum.forall, Finset.inl_mem_disjSum, Sum.elim_inl, Finset.inr_mem_disjSum, Sum.elim_inr,\n    Subtype.forall'] at hfg\n  apply_fun ((a : R) • ·) at eq\n  simp_rw [← t.sum_coe_sort, Finset.smul_sum, ← smul_assoc, ← hfg,\n    algebraMap_smul, Function.comp_def, ← map_smul, ← map_sum,\n    t.sum_coe_sort (f := fun x ↦ fg (Sum.inl x) • v x),\n    t.sum_coe_sort (f := fun x ↦ fg (Sum.inr x) • v x)] at eq\n  have ⟨s, eq⟩ := IsLocalizedModule.exists_of_eq (S := S) eq\n  simp_rw [Finset.smul_sum, Submonoid.smul_def, smul_smul] at eq\n  have := congr(algebraMap R Rₛ $(hv t _ _ eq i hi))\n  simpa only [map_mul, (IsLocalization.map_units Rₛ s).mul_right_inj, hfg.1 ⟨i, hi⟩, hfg.2 ⟨i, hi⟩,\n    Algebra.smul_def, (IsLocalization.map_units Rₛ a).mul_right_inj] using this\n\n"}
{"name":"LinearIndependent.localization","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\nRₛ : Type u_2\ninst✝⁷ : CommSemiring R\nS : Submonoid R\ninst✝⁶ : CommSemiring Rₛ\ninst✝⁵ : Algebra R Rₛ\ninst✝⁴ : IsLocalization S Rₛ\nM : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module Rₛ M\ninst✝ : IsScalarTower R Rₛ M\nι : Type u_5\nb : ι → M\nhli : LinearIndependent R b\n⊢ LinearIndependent Rₛ b","decl":"theorem LinearIndependent.localization [Module Rₛ M] [IsScalarTower R Rₛ M]\n    {ι : Type*} {b : ι → M} (hli : LinearIndependent R b) :\n    LinearIndependent Rₛ b := by\n  have := isLocalizedModule_id S M Rₛ\n  exact hli.of_isLocalizedModule Rₛ S .id\n\n"}
{"name":"Basis.ofIsLocalizedModule_apply","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\nRₛ : Type u_2\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\ninst✝⁹ : CommSemiring Rₛ\ninst✝⁸ : Algebra R Rₛ\ninst✝⁷ : IsLocalization S Rₛ\nM : Type u_3\nMₛ : Type u_4\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid Mₛ\ninst✝³ : Module R Mₛ\ninst✝² : Module Rₛ Mₛ\ninst✝¹ : IsScalarTower R Rₛ Mₛ\nf : LinearMap (RingHom.id R) M Mₛ\ninst✝ : IsLocalizedModule S f\nι : Type u_5\nb : Basis ι R M\ni : ι\n⊢ Eq ((Basis.ofIsLocalizedModule Rₛ S f b) i) (f (b i))","decl":"@[simp]\ntheorem Basis.ofIsLocalizedModule_apply (i : ι) : b.ofIsLocalizedModule Rₛ S f i = f (b i) := by\n  rw [ofIsLocalizedModule, coe_mk, Function.comp_apply]\n\n"}
{"name":"Basis.ofIsLocalizedModule_repr_apply","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\nRₛ : Type u_2\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\ninst✝⁹ : CommSemiring Rₛ\ninst✝⁸ : Algebra R Rₛ\ninst✝⁷ : IsLocalization S Rₛ\nM : Type u_3\nMₛ : Type u_4\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid Mₛ\ninst✝³ : Module R Mₛ\ninst✝² : Module Rₛ Mₛ\ninst✝¹ : IsScalarTower R Rₛ Mₛ\nf : LinearMap (RingHom.id R) M Mₛ\ninst✝ : IsLocalizedModule S f\nι : Type u_5\nb : Basis ι R M\nm : M\ni : ι\n⊢ Eq (((Basis.ofIsLocalizedModule Rₛ S f b).repr (f m)) i) ((algebraMap R Rₛ) ((b.repr m) i))","decl":"@[simp]\ntheorem Basis.ofIsLocalizedModule_repr_apply (m : M) (i : ι) :\n    ((b.ofIsLocalizedModule Rₛ S f).repr (f m)) i = algebraMap R Rₛ (b.repr m i) := by\n  suffices ((b.ofIsLocalizedModule Rₛ S f).repr.toLinearMap.restrictScalars R) ∘ₗ f =\n      Finsupp.mapRange.linearMap (Algebra.linearMap R Rₛ) ∘ₗ b.repr.toLinearMap by\n    exact DFunLike.congr_fun (LinearMap.congr_fun this m) i\n  refine Basis.ext b fun i ↦ ?_\n  rw [LinearMap.coe_comp, Function.comp_apply, LinearMap.coe_restrictScalars,\n    LinearEquiv.coe_coe, ← b.ofIsLocalizedModule_apply Rₛ S f, repr_self, LinearMap.coe_comp,\n    Function.comp_apply, LinearEquiv.coe_coe, repr_self, Finsupp.mapRange.linearMap_apply,\n    Finsupp.mapRange_single, Algebra.linearMap_apply, map_one]\n\n"}
{"name":"Basis.ofIsLocalizedModule_span","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\nRₛ : Type u_2\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\ninst✝⁹ : CommSemiring Rₛ\ninst✝⁸ : Algebra R Rₛ\ninst✝⁷ : IsLocalization S Rₛ\nM : Type u_3\nMₛ : Type u_4\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid Mₛ\ninst✝³ : Module R Mₛ\ninst✝² : Module Rₛ Mₛ\ninst✝¹ : IsScalarTower R Rₛ Mₛ\nf : LinearMap (RingHom.id R) M Mₛ\ninst✝ : IsLocalizedModule S f\nι : Type u_5\nb : Basis ι R M\n⊢ Eq (Submodule.span R (Set.range ⇑(Basis.ofIsLocalizedModule Rₛ S f b))) (LinearMap.range f)","decl":"theorem Basis.ofIsLocalizedModule_span :\n    span R (Set.range (b.ofIsLocalizedModule Rₛ S f)) = LinearMap.range f := by\n  calc span R (Set.range (b.ofIsLocalizedModule Rₛ S f))\n    _ = span R (f '' (Set.range b)) := by congr; ext; simp\n    _ = map f (span R (Set.range b)) := by rw [Submodule.map_span]\n    _ = LinearMap.range f := by rw [b.span_eq, Submodule.map_top]\n\n"}
{"name":"LinearIndependent.localization_localization","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\nRₛ : Type u_2\ninst✝¹² : CommSemiring R\nS : Submonoid R\ninst✝¹¹ : CommSemiring Rₛ\ninst✝¹⁰ : Algebra R Rₛ\ninst✝⁹ : IsLocalization S Rₛ\nA : Type u_3\ninst✝⁸ : CommSemiring A\ninst✝⁷ : Algebra R A\nAₛ : Type u_4\ninst✝⁶ : CommSemiring Aₛ\ninst✝⁵ : Algebra A Aₛ\ninst✝⁴ : Algebra Rₛ Aₛ\ninst✝³ : Algebra R Aₛ\ninst✝² : IsScalarTower R Rₛ Aₛ\ninst✝¹ : IsScalarTower R A Aₛ\ninst✝ : IsLocalization (Algebra.algebraMapSubmonoid A S) Aₛ\nι : Type u_5\nv : ι → A\nhv : LinearIndependent R v\n⊢ LinearIndependent Rₛ (Function.comp (⇑(algebraMap A Aₛ)) v)","decl":"theorem LinearIndependent.localization_localization {ι : Type*} {v : ι → A}\n    (hv : LinearIndependent R v) : LinearIndependent Rₛ ((algebraMap A Aₛ) ∘ v) :=\n  hv.of_isLocalizedModule Rₛ S (IsScalarTower.toAlgHom R A Aₛ).toLinearMap\n\n"}
{"name":"span_eq_top_localization_localization","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\nRₛ : Type u_2\ninst✝¹² : CommSemiring R\nS : Submonoid R\ninst✝¹¹ : CommSemiring Rₛ\ninst✝¹⁰ : Algebra R Rₛ\ninst✝⁹ : IsLocalization S Rₛ\nA : Type u_3\ninst✝⁸ : CommSemiring A\ninst✝⁷ : Algebra R A\nAₛ : Type u_4\ninst✝⁶ : CommSemiring Aₛ\ninst✝⁵ : Algebra A Aₛ\ninst✝⁴ : Algebra Rₛ Aₛ\ninst✝³ : Algebra R Aₛ\ninst✝² : IsScalarTower R Rₛ Aₛ\ninst✝¹ : IsScalarTower R A Aₛ\ninst✝ : IsLocalization (Algebra.algebraMapSubmonoid A S) Aₛ\nv : Set A\nhv : Eq (Submodule.span R v) Top.top\n⊢ Eq (Submodule.span Rₛ (Set.image (⇑(algebraMap A Aₛ)) v)) Top.top","decl":"theorem span_eq_top_localization_localization {v : Set A} (hv : span R v = ⊤) :\n    span Rₛ (algebraMap A Aₛ '' v) = ⊤ :=\n  span_eq_top_of_isLocalizedModule Rₛ S (IsScalarTower.toAlgHom R A Aₛ).toLinearMap hv\n\n"}
{"name":"Basis.localizationLocalization_apply","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\nRₛ : Type u_2\ninst✝¹² : CommSemiring R\nS : Submonoid R\ninst✝¹¹ : CommSemiring Rₛ\ninst✝¹⁰ : Algebra R Rₛ\ninst✝⁹ : IsLocalization S Rₛ\nA : Type u_3\ninst✝⁸ : CommSemiring A\ninst✝⁷ : Algebra R A\nAₛ : Type u_4\ninst✝⁶ : CommSemiring Aₛ\ninst✝⁵ : Algebra A Aₛ\ninst✝⁴ : Algebra Rₛ Aₛ\ninst✝³ : Algebra R Aₛ\ninst✝² : IsScalarTower R Rₛ Aₛ\ninst✝¹ : IsScalarTower R A Aₛ\ninst✝ : IsLocalization (Algebra.algebraMapSubmonoid A S) Aₛ\nι : Type u_5\nb : Basis ι R A\ni : ι\n⊢ Eq ((Basis.localizationLocalization Rₛ S Aₛ b) i) ((algebraMap A Aₛ) (b i))","decl":"@[simp]\ntheorem Basis.localizationLocalization_apply {ι : Type*} (b : Basis ι R A) (i) :\n    b.localizationLocalization Rₛ S Aₛ i = algebraMap A Aₛ (b i) :=\n  b.ofIsLocalizedModule_apply Rₛ S _ i\n\n"}
{"name":"Basis.localizationLocalization_repr_algebraMap","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\nRₛ : Type u_2\ninst✝¹² : CommSemiring R\nS : Submonoid R\ninst✝¹¹ : CommSemiring Rₛ\ninst✝¹⁰ : Algebra R Rₛ\ninst✝⁹ : IsLocalization S Rₛ\nA : Type u_3\ninst✝⁸ : CommSemiring A\ninst✝⁷ : Algebra R A\nAₛ : Type u_4\ninst✝⁶ : CommSemiring Aₛ\ninst✝⁵ : Algebra A Aₛ\ninst✝⁴ : Algebra Rₛ Aₛ\ninst✝³ : Algebra R Aₛ\ninst✝² : IsScalarTower R Rₛ Aₛ\ninst✝¹ : IsScalarTower R A Aₛ\ninst✝ : IsLocalization (Algebra.algebraMapSubmonoid A S) Aₛ\nι : Type u_5\nb : Basis ι R A\nx : A\ni : ι\n⊢ Eq (((Basis.localizationLocalization Rₛ S Aₛ b).repr ((algebraMap A Aₛ) x)) i) ((algebraMap R Rₛ) ((b.repr x) i))","decl":"@[simp]\ntheorem Basis.localizationLocalization_repr_algebraMap {ι : Type*} (b : Basis ι R A) (x i) :\n    (b.localizationLocalization Rₛ S Aₛ).repr (algebraMap A Aₛ x) i =\n      algebraMap R Rₛ (b.repr x i) := b.ofIsLocalizedModule_repr_apply Rₛ S _ _ i\n\n"}
{"name":"Basis.localizationLocalization_span","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\nRₛ : Type u_2\ninst✝¹² : CommSemiring R\nS : Submonoid R\ninst✝¹¹ : CommSemiring Rₛ\ninst✝¹⁰ : Algebra R Rₛ\ninst✝⁹ : IsLocalization S Rₛ\nA : Type u_3\ninst✝⁸ : CommSemiring A\ninst✝⁷ : Algebra R A\nAₛ : Type u_4\ninst✝⁶ : CommSemiring Aₛ\ninst✝⁵ : Algebra A Aₛ\ninst✝⁴ : Algebra Rₛ Aₛ\ninst✝³ : Algebra R Aₛ\ninst✝² : IsScalarTower R Rₛ Aₛ\ninst✝¹ : IsScalarTower R A Aₛ\ninst✝ : IsLocalization (Algebra.algebraMapSubmonoid A S) Aₛ\nι : Type u_5\nb : Basis ι R A\n⊢ Eq (Submodule.span R (Set.range ⇑(Basis.localizationLocalization Rₛ S Aₛ b))) (LinearMap.range (IsScalarTower.toAlgHom R A Aₛ))","decl":"theorem Basis.localizationLocalization_span {ι : Type*} (b : Basis ι R A) :\n    Submodule.span R (Set.range (b.localizationLocalization Rₛ S Aₛ)) =\n      LinearMap.range (IsScalarTower.toAlgHom R A Aₛ) := b.ofIsLocalizedModule_span Rₛ S _\n\n"}
{"name":"LinearIndependent.iff_fractionRing","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_3\nK : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : Field K\ninst✝⁵ : Algebra R K\ninst✝⁴ : IsFractionRing R K\nV : Type u_5\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\ninst✝¹ : Module K V\ninst✝ : IsScalarTower R K V\nι : Type u_6\nb : ι → V\n⊢ Iff (LinearIndependent R b) (LinearIndependent K b)","decl":"theorem LinearIndependent.iff_fractionRing {ι : Type*} {b : ι → V} :\n    LinearIndependent R b ↔ LinearIndependent K b :=\n  ⟨LinearIndependent.localization K R⁰,\n    LinearIndependent.restrict_scalars (smul_left_injective R one_ne_zero)⟩\n\n"}
{"name":"LinearMap.restrictScalars_extendScalarsOfIsLocalization","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_3\ninst✝¹¹ : CommSemiring R\nS : Submonoid R\nA : Type u_4\ninst✝¹⁰ : CommSemiring A\ninst✝⁹ : Algebra R A\ninst✝⁸ : IsLocalization S A\nM : Type u_5\nN : Type u_6\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module A M\ninst✝⁴ : IsScalarTower R A M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module A N\ninst✝ : IsScalarTower R A N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq (↑R (LinearMap.extendScalarsOfIsLocalization S A f)) f","decl":"@[simp] lemma LinearMap.restrictScalars_extendScalarsOfIsLocalization (f : M →ₗ[R] N) :\n    (f.extendScalarsOfIsLocalization S A).restrictScalars R = f := rfl\n\n"}
{"name":"LinearMap.extendScalarsOfIsLocalization_apply","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_3\ninst✝¹¹ : CommSemiring R\nS : Submonoid R\nA : Type u_4\ninst✝¹⁰ : CommSemiring A\ninst✝⁹ : Algebra R A\ninst✝⁸ : IsLocalization S A\nM : Type u_5\nN : Type u_6\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module A M\ninst✝⁴ : IsScalarTower R A M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module A N\ninst✝ : IsScalarTower R A N\nf : LinearMap (RingHom.id A) M N\n⊢ Eq (LinearMap.extendScalarsOfIsLocalization S A (↑R f)) f","decl":"@[simp] lemma LinearMap.extendScalarsOfIsLocalization_apply (f : M →ₗ[A] N) :\n    f.extendScalarsOfIsLocalization S A = f := rfl\n\n"}
{"name":"LinearMap.extendScalarsOfIsLocalization_apply'","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_3\ninst✝¹¹ : CommSemiring R\nS : Submonoid R\nA : Type u_4\ninst✝¹⁰ : CommSemiring A\ninst✝⁹ : Algebra R A\ninst✝⁸ : IsLocalization S A\nM : Type u_5\nN : Type u_6\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module A M\ninst✝⁴ : IsScalarTower R A M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module A N\ninst✝ : IsScalarTower R A N\nf : LinearMap (RingHom.id R) M N\nx : M\n⊢ Eq ((LinearMap.extendScalarsOfIsLocalization S A f) x) (f x)","decl":"@[simp] lemma LinearMap.extendScalarsOfIsLocalization_apply' (f : M →ₗ[R] N) (x : M) :\n    (f.extendScalarsOfIsLocalization S A) x = f x := rfl\n\n"}
{"name":"LinearMap.extendScalarsOfIsLocalizationEquiv_symm_apply","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_3\ninst✝¹¹ : CommSemiring R\nS : Submonoid R\nA : Type u_4\ninst✝¹⁰ : CommSemiring A\ninst✝⁹ : Algebra R A\ninst✝⁸ : IsLocalization S A\nM : Type u_5\nN : Type u_6\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module A M\ninst✝⁴ : IsScalarTower R A M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module A N\ninst✝ : IsScalarTower R A N\nfₗ : LinearMap (RingHom.id A) M N\n⊢ Eq ((LinearMap.extendScalarsOfIsLocalizationEquiv S A).symm fₗ) (↑R fₗ)","decl":"/-- The `S⁻¹R`-linear maps between two `S⁻¹R`-modules are exactly the `R`-linear maps. -/\n@[simps]\ndef LinearMap.extendScalarsOfIsLocalizationEquiv : (M →ₗ[R] N) ≃ₗ[A] (M →ₗ[A] N) where\n  toFun := LinearMap.extendScalarsOfIsLocalization S A\n  invFun := LinearMap.restrictScalars R\n  map_add' := by intros; ext; simp\n  map_smul' := by intros; ext; simp\n  left_inv := by intros _; ext; simp\n  right_inv := by intros _; ext; simp\n\n"}
{"name":"LinearMap.extendScalarsOfIsLocalizationEquiv_apply","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_3\ninst✝¹¹ : CommSemiring R\nS : Submonoid R\nA : Type u_4\ninst✝¹⁰ : CommSemiring A\ninst✝⁹ : Algebra R A\ninst✝⁸ : IsLocalization S A\nM : Type u_5\nN : Type u_6\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module A M\ninst✝⁴ : IsScalarTower R A M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module A N\ninst✝ : IsScalarTower R A N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq ((LinearMap.extendScalarsOfIsLocalizationEquiv S A) f) (LinearMap.extendScalarsOfIsLocalization S A f)","decl":"/-- The `S⁻¹R`-linear maps between two `S⁻¹R`-modules are exactly the `R`-linear maps. -/\n@[simps]\ndef LinearMap.extendScalarsOfIsLocalizationEquiv : (M →ₗ[R] N) ≃ₗ[A] (M →ₗ[A] N) where\n  toFun := LinearMap.extendScalarsOfIsLocalization S A\n  invFun := LinearMap.restrictScalars R\n  map_add' := by intros; ext; simp\n  map_smul' := by intros; ext; simp\n  left_inv := by intros _; ext; simp\n  right_inv := by intros _; ext; simp\n\n"}
{"name":"IsLocalizedModule.mapExtendScalars_apply_apply","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\ninst✝¹⁷ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝¹⁶ : AddCommMonoid M\ninst✝¹⁵ : AddCommMonoid M'\ninst✝¹⁴ : Module R M\ninst✝¹³ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝¹² : IsLocalizedModule S f\nN : Type u_4\nN' : Type u_5\ninst✝¹¹ : AddCommMonoid N\ninst✝¹⁰ : AddCommMonoid N'\ninst✝⁹ : Module R N\ninst✝⁸ : Module R N'\ng : LinearMap (RingHom.id R) N N'\ninst✝⁷ : IsLocalizedModule S g\nRₛ : Type u_6\ninst✝⁶ : CommSemiring Rₛ\ninst✝⁵ : Algebra R Rₛ\ninst✝⁴ : Module Rₛ M'\ninst✝³ : Module Rₛ N'\ninst✝² : IsScalarTower R Rₛ M'\ninst✝¹ : IsScalarTower R Rₛ N'\ninst✝ : IsLocalization S Rₛ\na✝ : LinearMap (RingHom.id R) M N\na : M'\n⊢ Eq (((IsLocalizedModule.mapExtendScalars S f g Rₛ) a✝) a) (((IsLocalizedModule.map S f g) a✝) a)","decl":"/-- A linear map `M →ₗ[R] N` gives a map between localized modules `Mₛ →ₗ[Rₛ] Nₛ`. -/\n@[simps!]\nnoncomputable\ndef mapExtendScalars : (M →ₗ[R] N) →ₗ[R] (M' →ₗ[Rₛ] N') :=\n  ((LinearMap.extendScalarsOfIsLocalizationEquiv S Rₛ).restrictScalars R).toLinearMap ∘ₗ map S f g\n\n"}
{"name":"LocalizedModule.map_mk","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\nx : M\ny : Subtype fun x => Membership.mem S x\n⊢ Eq (((LocalizedModule.map S) f) (LocalizedModule.mk x y)) (LocalizedModule.mk (f x) y)","decl":"@[simp]\nlemma LocalizedModule.map_mk (f : M →ₗ[R] N) (x y) :\n    map S f (.mk x y) = LocalizedModule.mk (f x) y := by\n  rw [IsLocalizedModule.mk_eq_mk', IsLocalizedModule.mk_eq_mk']\n  exact IsLocalizedModule.map_mk' _ _ _ _ _ _\n\n"}
{"name":"LocalizedModule.map_id","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq ((LocalizedModule.map S) LinearMap.id) LinearMap.id","decl":"@[simp]\nlemma LocalizedModule.map_id :\n    LocalizedModule.map S (.id (R := R) (M := M)) = LinearMap.id :=\n  LinearMap.ext fun x ↦ LinearMap.congr_fun (IsLocalizedModule.map_id S (mkLinearMap S M)) x\n\n"}
{"name":"LocalizedModule.map_injective","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nl : LinearMap (RingHom.id R) M N\nhl : Function.Injective ⇑l\n⊢ Function.Injective ⇑((LocalizedModule.map S) l)","decl":"lemma LocalizedModule.map_injective (l : M →ₗ[R] N) (hl : Function.Injective l) :\n    Function.Injective (map S l) :=\n  IsLocalizedModule.map_injective S (mkLinearMap S M) (mkLinearMap S N) l hl\n\n"}
{"name":"LocalizedModule.map_surjective","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_3\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nl : LinearMap (RingHom.id R) M N\nhl : Function.Surjective ⇑l\n⊢ Function.Surjective ⇑((LocalizedModule.map S) l)","decl":"lemma LocalizedModule.map_surjective (l : M →ₗ[R] N) (hl : Function.Surjective l) :\n    Function.Surjective (map S l) :=\n  IsLocalizedModule.map_surjective S (mkLinearMap S M) (mkLinearMap S N) l hl\n\n"}
{"name":"LocalizedModule.restrictScalars_map_eq","module":"Mathlib.RingTheory.Localization.Module","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\nN : Type u_5\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R N\nM' : Type u_3\nN' : Type u_4\ninst✝⁵ : AddCommMonoid M'\ninst✝⁴ : AddCommMonoid N'\ninst✝³ : Module R M'\ninst✝² : Module R N'\ng₁ : LinearMap (RingHom.id R) M M'\ng₂ : LinearMap (RingHom.id R) N N'\ninst✝¹ : IsLocalizedModule S g₁\ninst✝ : IsLocalizedModule S g₂\nl : LinearMap (RingHom.id R) M N\n⊢ Eq (↑R ((LocalizedModule.map S) l)) ((↑(IsLocalizedModule.iso S g₂).symm).comp (((IsLocalizedModule.map S g₁ g₂) l).comp ↑(IsLocalizedModule.iso S g₁)))","decl":"lemma LocalizedModule.restrictScalars_map_eq {M' N' : Type*} [AddCommMonoid M'] [AddCommMonoid N']\n    [Module R M'] [Module R N'] (g₁ : M →ₗ[R] M') (g₂ : N →ₗ[R] N')\n    [IsLocalizedModule S g₁] [IsLocalizedModule S g₂]\n    (l : M →ₗ[R] N) :\n    (map S l).restrictScalars R = (IsLocalizedModule.iso S g₂).symm ∘ₗ\n      IsLocalizedModule.map S g₁ g₂ l ∘ₗ IsLocalizedModule.iso S g₁ := by\n  rw [LinearEquiv.eq_toLinearMap_symm_comp, ← LinearEquiv.comp_toLinearMap_symm_eq]\n  apply IsLocalizedModule.linearMap_ext S g₁ g₂\n  rw [LinearMap.comp_assoc, IsLocalizedModule.iso_symm_comp]\n  ext\n  simp\n\n"}
