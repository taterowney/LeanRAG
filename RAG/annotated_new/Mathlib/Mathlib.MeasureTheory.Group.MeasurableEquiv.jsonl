{"name":"MeasurableEquiv.smul_apply","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSMul G α\nc : G\n⊢ Eq ⇑(MeasurableEquiv.smul c) fun x => HSMul.hSMul c x","decl":"/-- If a group `G` acts on `α` by measurable maps, then each element `c : G` defines a measurable\nautomorphism of `α`. -/\n@[to_additive (attr := simps! (config := .asFn) toEquiv apply)\n      \"If an additive group `G` acts on `α` by measurable maps, then each element `c : G`\n      defines a measurable automorphism of `α`.\" ]\ndef smul (c : G) : α ≃ᵐ α where\n  toEquiv := MulAction.toPerm c\n  measurable_toFun := measurable_const_smul c\n  measurable_invFun := measurable_const_smul c⁻¹\n\n"}
{"name":"MeasurableEquiv.smul_toEquiv","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSMul G α\nc : G\n⊢ Eq (MeasurableEquiv.smul c).toEquiv (MulAction.toPerm c)","decl":"/-- If a group `G` acts on `α` by measurable maps, then each element `c : G` defines a measurable\nautomorphism of `α`. -/\n@[to_additive (attr := simps! (config := .asFn) toEquiv apply)\n      \"If an additive group `G` acts on `α` by measurable maps, then each element `c : G`\n      defines a measurable automorphism of `α`.\" ]\ndef smul (c : G) : α ≃ᵐ α where\n  toEquiv := MulAction.toPerm c\n  measurable_toFun := measurable_const_smul c\n  measurable_invFun := measurable_const_smul c⁻¹\n\n"}
{"name":"MeasurableEquiv.vadd_toEquiv","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableVAdd G α\nc : G\n⊢ Eq (MeasurableEquiv.vadd c).toEquiv (AddAction.toPerm c)","decl":"/-- If a group `G` acts on `α` by measurable maps, then each element `c : G` defines a measurable\nautomorphism of `α`. -/\n@[to_additive (attr := simps! (config := .asFn) toEquiv apply)\n      \"If an additive group `G` acts on `α` by measurable maps, then each element `c : G`\n      defines a measurable automorphism of `α`.\" ]\ndef smul (c : G) : α ≃ᵐ α where\n  toEquiv := MulAction.toPerm c\n  measurable_toFun := measurable_const_smul c\n  measurable_invFun := measurable_const_smul c⁻¹\n\n"}
{"name":"MeasurableEquiv.vadd_apply","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableVAdd G α\nc : G\n⊢ Eq ⇑(MeasurableEquiv.vadd c) fun x => HVAdd.hVAdd c x","decl":"/-- If a group `G` acts on `α` by measurable maps, then each element `c : G` defines a measurable\nautomorphism of `α`. -/\n@[to_additive (attr := simps! (config := .asFn) toEquiv apply)\n      \"If an additive group `G` acts on `α` by measurable maps, then each element `c : G`\n      defines a measurable automorphism of `α`.\" ]\ndef smul (c : G) : α ≃ᵐ α where\n  toEquiv := MulAction.toPerm c\n  measurable_toFun := measurable_const_smul c\n  measurable_invFun := measurable_const_smul c⁻¹\n\n"}
{"name":"measurableEmbedding_const_vadd","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableVAdd G α\nc : G\n⊢ MeasurableEmbedding fun x => HVAdd.hVAdd c x","decl":"@[to_additive]\ntheorem _root_.measurableEmbedding_const_smul (c : G) : MeasurableEmbedding (c • · : α → α) :=\n  (smul c).measurableEmbedding\n\n"}
{"name":"measurableEmbedding_const_smul","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSMul G α\nc : G\n⊢ MeasurableEmbedding fun x => HSMul.hSMul c x","decl":"@[to_additive]\ntheorem _root_.measurableEmbedding_const_smul (c : G) : MeasurableEmbedding (c • · : α → α) :=\n  (smul c).measurableEmbedding\n\n"}
{"name":"MeasurableEquiv.symm_smul","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSMul G α\nc : G\n⊢ Eq (MeasurableEquiv.smul c).symm (MeasurableEquiv.smul (Inv.inv c))","decl":"@[to_additive (attr := simp)]\ntheorem symm_smul (c : G) : (smul c : α ≃ᵐ α).symm = smul c⁻¹ :=\n  ext rfl\n\n"}
{"name":"MeasurableEquiv.symm_vadd","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableVAdd G α\nc : G\n⊢ Eq (MeasurableEquiv.vadd c).symm (MeasurableEquiv.vadd (Neg.neg c))","decl":"@[to_additive (attr := simp)]\ntheorem symm_smul (c : G) : (smul c : α ≃ᵐ α).symm = smul c⁻¹ :=\n  ext rfl\n\n"}
{"name":"MeasurableEquiv.coe_smul₀","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G₀ : Type u_2\nα : Type u_3\ninst✝⁴ : MeasurableSpace G₀\ninst✝³ : MeasurableSpace α\ninst✝² : GroupWithZero G₀\ninst✝¹ : MulAction G₀ α\ninst✝ : MeasurableSMul G₀ α\nc : G₀\nhc : Ne c 0\n⊢ Eq ⇑(MeasurableEquiv.smul₀ c hc) fun x => HSMul.hSMul c x","decl":"@[simp] lemma coe_smul₀ {c : G₀} (hc : c ≠ 0) : ⇑(smul₀ c hc : α ≃ᵐ α) = (c • ·) := rfl\n\n"}
{"name":"MeasurableEquiv.symm_smul₀","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G₀ : Type u_2\nα : Type u_3\ninst✝⁴ : MeasurableSpace G₀\ninst✝³ : MeasurableSpace α\ninst✝² : GroupWithZero G₀\ninst✝¹ : MulAction G₀ α\ninst✝ : MeasurableSMul G₀ α\nc : G₀\nhc : Ne c 0\n⊢ Eq (MeasurableEquiv.smul₀ c hc).symm (MeasurableEquiv.smul₀ (Inv.inv c) ⋯)","decl":"@[simp]\ntheorem symm_smul₀ {c : G₀} (hc : c ≠ 0) :\n    (smul₀ c hc : α ≃ᵐ α).symm = smul₀ c⁻¹ (inv_ne_zero hc) :=\n  ext rfl\n\n"}
{"name":"measurableEmbedding_const_smul₀","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G₀ : Type u_2\nα : Type u_3\ninst✝⁴ : MeasurableSpace G₀\ninst✝³ : MeasurableSpace α\ninst✝² : GroupWithZero G₀\ninst✝¹ : MulAction G₀ α\ninst✝ : MeasurableSMul G₀ α\nc : G₀\nhc : Ne c 0\n⊢ MeasurableEmbedding fun x => HSMul.hSMul c x","decl":"theorem _root_.measurableEmbedding_const_smul₀ {c : G₀} (hc : c ≠ 0) :\n    MeasurableEmbedding (c • · : α → α) :=\n  (smul₀ c hc).measurableEmbedding\n\n"}
{"name":"MeasurableEquiv.coe_mulLeft","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Group G\ninst✝ : MeasurableMul G\ng : G\n⊢ Eq ⇑(MeasurableEquiv.mulLeft g) fun x => HMul.hMul g x","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulLeft (g : G) : ⇑(mulLeft g) = (g * ·) :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.coe_addLeft","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : AddGroup G\ninst✝ : MeasurableAdd G\ng : G\n⊢ Eq ⇑(MeasurableEquiv.addLeft g) fun x => HAdd.hAdd g x","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulLeft (g : G) : ⇑(mulLeft g) = (g * ·) :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.symm_addLeft","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : AddGroup G\ninst✝ : MeasurableAdd G\ng : G\n⊢ Eq (MeasurableEquiv.addLeft g).symm (MeasurableEquiv.addLeft (Neg.neg g))","decl":"@[to_additive (attr := simp)]\ntheorem symm_mulLeft (g : G) : (mulLeft g).symm = mulLeft g⁻¹ :=\n  ext rfl\n\n"}
{"name":"MeasurableEquiv.symm_mulLeft","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Group G\ninst✝ : MeasurableMul G\ng : G\n⊢ Eq (MeasurableEquiv.mulLeft g).symm (MeasurableEquiv.mulLeft (Inv.inv g))","decl":"@[to_additive (attr := simp)]\ntheorem symm_mulLeft (g : G) : (mulLeft g).symm = mulLeft g⁻¹ :=\n  ext rfl\n\n"}
{"name":"MeasurableEquiv.toEquiv_mulLeft","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Group G\ninst✝ : MeasurableMul G\ng : G\n⊢ Eq (MeasurableEquiv.mulLeft g).toEquiv (Equiv.mulLeft g)","decl":"@[to_additive (attr := simp)]\ntheorem toEquiv_mulLeft (g : G) : (mulLeft g).toEquiv = Equiv.mulLeft g :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.toEquiv_addLeft","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : AddGroup G\ninst✝ : MeasurableAdd G\ng : G\n⊢ Eq (MeasurableEquiv.addLeft g).toEquiv (Equiv.addLeft g)","decl":"@[to_additive (attr := simp)]\ntheorem toEquiv_mulLeft (g : G) : (mulLeft g).toEquiv = Equiv.mulLeft g :=\n  rfl\n\n"}
{"name":"measurableEmbedding_addLeft","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : AddGroup G\ninst✝ : MeasurableAdd G\ng : G\n⊢ MeasurableEmbedding fun x => HAdd.hAdd g x","decl":"@[to_additive]\ntheorem _root_.measurableEmbedding_mulLeft (g : G) : MeasurableEmbedding (g * ·) :=\n  (mulLeft g).measurableEmbedding\n\n"}
{"name":"measurableEmbedding_mulLeft","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Group G\ninst✝ : MeasurableMul G\ng : G\n⊢ MeasurableEmbedding fun x => HMul.hMul g x","decl":"@[to_additive]\ntheorem _root_.measurableEmbedding_mulLeft (g : G) : MeasurableEmbedding (g * ·) :=\n  (mulLeft g).measurableEmbedding\n\n"}
{"name":"measurableEmbedding_addRight","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : AddGroup G\ninst✝ : MeasurableAdd G\ng : G\n⊢ MeasurableEmbedding fun x => HAdd.hAdd x g","decl":"@[to_additive]\ntheorem _root_.measurableEmbedding_mulRight (g : G) : MeasurableEmbedding fun x => x * g :=\n  (mulRight g).measurableEmbedding\n\n"}
{"name":"measurableEmbedding_mulRight","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Group G\ninst✝ : MeasurableMul G\ng : G\n⊢ MeasurableEmbedding fun x => HMul.hMul x g","decl":"@[to_additive]\ntheorem _root_.measurableEmbedding_mulRight (g : G) : MeasurableEmbedding fun x => x * g :=\n  (mulRight g).measurableEmbedding\n\n"}
{"name":"MeasurableEquiv.coe_addRight","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : AddGroup G\ninst✝ : MeasurableAdd G\ng : G\n⊢ Eq ⇑(MeasurableEquiv.addRight g) fun x => HAdd.hAdd x g","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulRight (g : G) : ⇑(mulRight g) = fun x => x * g :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.coe_mulRight","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Group G\ninst✝ : MeasurableMul G\ng : G\n⊢ Eq ⇑(MeasurableEquiv.mulRight g) fun x => HMul.hMul x g","decl":"@[to_additive (attr := simp)]\ntheorem coe_mulRight (g : G) : ⇑(mulRight g) = fun x => x * g :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.symm_addRight","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : AddGroup G\ninst✝ : MeasurableAdd G\ng : G\n⊢ Eq (MeasurableEquiv.addRight g).symm (MeasurableEquiv.addRight (Neg.neg g))","decl":"@[to_additive (attr := simp)]\ntheorem symm_mulRight (g : G) : (mulRight g).symm = mulRight g⁻¹ :=\n  ext rfl\n\n"}
{"name":"MeasurableEquiv.symm_mulRight","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Group G\ninst✝ : MeasurableMul G\ng : G\n⊢ Eq (MeasurableEquiv.mulRight g).symm (MeasurableEquiv.mulRight (Inv.inv g))","decl":"@[to_additive (attr := simp)]\ntheorem symm_mulRight (g : G) : (mulRight g).symm = mulRight g⁻¹ :=\n  ext rfl\n\n"}
{"name":"MeasurableEquiv.toEquiv_mulRight","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : Group G\ninst✝ : MeasurableMul G\ng : G\n⊢ Eq (MeasurableEquiv.mulRight g).toEquiv (Equiv.mulRight g)","decl":"@[to_additive (attr := simp)]\ntheorem toEquiv_mulRight (g : G) : (mulRight g).toEquiv = Equiv.mulRight g :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.toEquiv_addRight","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\ninst✝² : MeasurableSpace G\ninst✝¹ : AddGroup G\ninst✝ : MeasurableAdd G\ng : G\n⊢ Eq (MeasurableEquiv.addRight g).toEquiv (Equiv.addRight g)","decl":"@[to_additive (attr := simp)]\ntheorem toEquiv_mulRight (g : G) : (mulRight g).toEquiv = Equiv.mulRight g :=\n  rfl\n\n"}
{"name":"measurableEmbedding_mulLeft₀","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G₀ : Type u_2\ninst✝² : MeasurableSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : MeasurableMul G₀\ng : G₀\nhg : Ne g 0\n⊢ MeasurableEmbedding fun x => HMul.hMul g x","decl":"theorem _root_.measurableEmbedding_mulLeft₀ {g : G₀} (hg : g ≠ 0) :\n    MeasurableEmbedding (g * ·) :=\n  (mulLeft₀ g hg).measurableEmbedding\n\n"}
{"name":"MeasurableEquiv.coe_mulLeft₀","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G₀ : Type u_2\ninst✝² : MeasurableSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : MeasurableMul G₀\ng : G₀\nhg : Ne g 0\n⊢ Eq ⇑(MeasurableEquiv.mulLeft₀ g hg) fun x => HMul.hMul g x","decl":"@[simp] lemma coe_mulLeft₀ {g : G₀} (hg : g ≠ 0) : ⇑(mulLeft₀ g hg) = (g * ·) := rfl\n\n"}
{"name":"MeasurableEquiv.symm_mulLeft₀","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G₀ : Type u_2\ninst✝² : MeasurableSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : MeasurableMul G₀\ng : G₀\nhg : Ne g 0\n⊢ Eq (MeasurableEquiv.mulLeft₀ g hg).symm (MeasurableEquiv.mulLeft₀ (Inv.inv g) ⋯)","decl":"@[simp]\ntheorem symm_mulLeft₀ {g : G₀} (hg : g ≠ 0) :\n    (mulLeft₀ g hg).symm = mulLeft₀ g⁻¹ (inv_ne_zero hg) :=\n  ext rfl\n\n"}
{"name":"MeasurableEquiv.toEquiv_mulLeft₀","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G₀ : Type u_2\ninst✝² : MeasurableSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : MeasurableMul G₀\ng : G₀\nhg : Ne g 0\n⊢ Eq (MeasurableEquiv.mulLeft₀ g hg).toEquiv (Equiv.mulLeft₀ g hg)","decl":"@[simp]\ntheorem toEquiv_mulLeft₀ {g : G₀} (hg : g ≠ 0) : (mulLeft₀ g hg).toEquiv = Equiv.mulLeft₀ g hg :=\n  rfl\n\n"}
{"name":"measurableEmbedding_mulRight₀","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G₀ : Type u_2\ninst✝² : MeasurableSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : MeasurableMul G₀\ng : G₀\nhg : Ne g 0\n⊢ MeasurableEmbedding fun x => HMul.hMul x g","decl":"theorem _root_.measurableEmbedding_mulRight₀ {g : G₀} (hg : g ≠ 0) :\n    MeasurableEmbedding fun x => x * g :=\n  (mulRight₀ g hg).measurableEmbedding\n\n"}
{"name":"MeasurableEquiv.coe_mulRight₀","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G₀ : Type u_2\ninst✝² : MeasurableSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : MeasurableMul G₀\ng : G₀\nhg : Ne g 0\n⊢ Eq ⇑(MeasurableEquiv.mulRight₀ g hg) fun x => HMul.hMul x g","decl":"@[simp]\ntheorem coe_mulRight₀ {g : G₀} (hg : g ≠ 0) : ⇑(mulRight₀ g hg) = fun x => x * g :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.symm_mulRight₀","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G₀ : Type u_2\ninst✝² : MeasurableSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : MeasurableMul G₀\ng : G₀\nhg : Ne g 0\n⊢ Eq (MeasurableEquiv.mulRight₀ g hg).symm (MeasurableEquiv.mulRight₀ (Inv.inv g) ⋯)","decl":"@[simp]\ntheorem symm_mulRight₀ {g : G₀} (hg : g ≠ 0) :\n    (mulRight₀ g hg).symm = mulRight₀ g⁻¹ (inv_ne_zero hg) :=\n  ext rfl\n\n"}
{"name":"MeasurableEquiv.toEquiv_mulRight₀","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G₀ : Type u_2\ninst✝² : MeasurableSpace G₀\ninst✝¹ : GroupWithZero G₀\ninst✝ : MeasurableMul G₀\ng : G₀\nhg : Ne g 0\n⊢ Eq (MeasurableEquiv.mulRight₀ g hg).toEquiv (Equiv.mulRight₀ g hg)","decl":"@[simp]\ntheorem toEquiv_mulRight₀ {g : G₀} (hg : g ≠ 0) : (mulRight₀ g hg).toEquiv = Equiv.mulRight₀ g hg :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.inv_apply","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_4\ninst✝² : MeasurableSpace G\ninst✝¹ : InvolutiveInv G\ninst✝ : MeasurableInv G\n⊢ Eq (⇑(MeasurableEquiv.inv G)) Inv.inv","decl":"/-- Inversion as a measurable automorphism of a group or group with zero. -/\n@[to_additive (attr := simps! (config := .asFn) toEquiv apply)\n    \"Negation as a measurable automorphism of an additive group.\"]\ndef inv (G) [MeasurableSpace G] [InvolutiveInv G] [MeasurableInv G] : G ≃ᵐ G where\n  toEquiv := Equiv.inv G\n  measurable_toFun := measurable_inv\n  measurable_invFun := measurable_inv\n\n"}
{"name":"MeasurableEquiv.neg_toEquiv","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_4\ninst✝² : MeasurableSpace G\ninst✝¹ : InvolutiveNeg G\ninst✝ : MeasurableNeg G\n⊢ Eq (MeasurableEquiv.neg G).toEquiv (Equiv.neg G)","decl":"/-- Inversion as a measurable automorphism of a group or group with zero. -/\n@[to_additive (attr := simps! (config := .asFn) toEquiv apply)\n    \"Negation as a measurable automorphism of an additive group.\"]\ndef inv (G) [MeasurableSpace G] [InvolutiveInv G] [MeasurableInv G] : G ≃ᵐ G where\n  toEquiv := Equiv.inv G\n  measurable_toFun := measurable_inv\n  measurable_invFun := measurable_inv\n\n"}
{"name":"MeasurableEquiv.inv_toEquiv","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_4\ninst✝² : MeasurableSpace G\ninst✝¹ : InvolutiveInv G\ninst✝ : MeasurableInv G\n⊢ Eq (MeasurableEquiv.inv G).toEquiv (Equiv.inv G)","decl":"/-- Inversion as a measurable automorphism of a group or group with zero. -/\n@[to_additive (attr := simps! (config := .asFn) toEquiv apply)\n    \"Negation as a measurable automorphism of an additive group.\"]\ndef inv (G) [MeasurableSpace G] [InvolutiveInv G] [MeasurableInv G] : G ≃ᵐ G where\n  toEquiv := Equiv.inv G\n  measurable_toFun := measurable_inv\n  measurable_invFun := measurable_inv\n\n"}
{"name":"MeasurableEquiv.neg_apply","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_4\ninst✝² : MeasurableSpace G\ninst✝¹ : InvolutiveNeg G\ninst✝ : MeasurableNeg G\n⊢ Eq (⇑(MeasurableEquiv.neg G)) Neg.neg","decl":"/-- Inversion as a measurable automorphism of a group or group with zero. -/\n@[to_additive (attr := simps! (config := .asFn) toEquiv apply)\n    \"Negation as a measurable automorphism of an additive group.\"]\ndef inv (G) [MeasurableSpace G] [InvolutiveInv G] [MeasurableInv G] : G ≃ᵐ G where\n  toEquiv := Equiv.inv G\n  measurable_toFun := measurable_inv\n  measurable_invFun := measurable_inv\n\n"}
{"name":"MeasurableEquiv.symm_inv","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_4\ninst✝² : MeasurableSpace G\ninst✝¹ : InvolutiveInv G\ninst✝ : MeasurableInv G\n⊢ Eq (MeasurableEquiv.inv G).symm (MeasurableEquiv.inv G)","decl":"@[to_additive (attr := simp)]\ntheorem symm_inv {G} [MeasurableSpace G] [InvolutiveInv G] [MeasurableInv G] :\n    (inv G).symm = inv G :=\n  rfl\n\n"}
{"name":"MeasurableEquiv.symm_neg","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_4\ninst✝² : MeasurableSpace G\ninst✝¹ : InvolutiveNeg G\ninst✝ : MeasurableNeg G\n⊢ Eq (MeasurableEquiv.neg G).symm (MeasurableEquiv.neg G)","decl":"@[to_additive (attr := simp)]\ntheorem symm_inv {G} [MeasurableSpace G] [InvolutiveInv G] [MeasurableInv G] :\n    (inv G).symm = inv G :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.dmaSMul_apply","module":"Mathlib.MeasureTheory.Group.MeasurableEquiv","initialProofState":"G : Type u_1\nA : Type u_2\ninst✝⁵ : Group G\ninst✝⁴ : AddCommGroup A\ninst✝³ : DistribMulAction G A\ninst✝² : MeasurableSpace A\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableSMul G A\nμ : MeasureTheory.Measure A\ng : DomMulAct G\ns : Set A\n⊢ Eq ((HSMul.hSMul g μ) s) (μ (HSMul.hSMul (DomMulAct.mk.symm g) s))","decl":"lemma dmaSMul_apply (μ : Measure A) (g : Gᵈᵐᵃ) (s : Set A) :\n    (g • μ) s = μ (DomMulAct.mk.symm g • s) := by\n  refine ((MeasurableEquiv.smul ((DomMulAct.mk.symm g : G)⁻¹)).map_apply _).trans ?_\n  congr 1\n  exact Set.preimage_smul_inv (DomMulAct.mk.symm g) s\n\n"}
