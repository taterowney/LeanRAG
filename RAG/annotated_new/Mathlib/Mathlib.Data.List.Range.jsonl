{"name":"List.getElem_range'_1","module":"Mathlib.Data.List.Range","initialProofState":"n m i : Nat\nH : LT.lt i (List.range' n m).length\n⊢ Eq (GetElem.getElem (List.range' n m) i ⋯) (HAdd.hAdd n i)","decl":"theorem getElem_range'_1 {n m} (i) (H : i < (range' n m).length) :\n    (range' n m)[i] = n + i := by simp\n\n"}
{"name":"List.chain'_range_succ","module":"Mathlib.Data.List.Range","initialProofState":"r : Nat → Nat → Prop\nn : Nat\n⊢ Iff (List.Chain' r (List.range n.succ)) (∀ (m : Nat), LT.lt m n → r m m.succ)","decl":"theorem chain'_range_succ (r : ℕ → ℕ → Prop) (n : ℕ) :\n    Chain' r (range n.succ) ↔ ∀ m < n, r m m.succ := by\n  rw [range_succ]\n  induction' n with n hn\n  · simp\n  · rw [range_succ]\n    simp only [append_assoc, singleton_append, chain'_append_cons_cons, chain'_singleton, and_true]\n    rw [hn, forall_lt_succ]\n\n"}
{"name":"List.chain_range_succ","module":"Mathlib.Data.List.Range","initialProofState":"r : Nat → Nat → Prop\nn a : Nat\n⊢ Iff (List.Chain r a (List.range n.succ)) (And (r a 0) (∀ (m : Nat), LT.lt m n → r m m.succ))","decl":"theorem chain_range_succ (r : ℕ → ℕ → Prop) (n a : ℕ) :\n    Chain r a (range n.succ) ↔ r a 0 ∧ ∀ m < n, r m m.succ := by\n  rw [range_succ_eq_map, chain_cons, and_congr_right_iff, ← chain'_range_succ, range_succ_eq_map]\n  exact fun _ => Iff.rfl\n\n"}
{"name":"List.nthLe_range'","module":"Mathlib.Data.List.Range","initialProofState":"n m step i : Nat\nH : LT.lt i (List.range' n m step).length\n⊢ Eq ((List.range' n m step).get ⟨i, H⟩) (HAdd.hAdd n (HMul.hMul step i))","decl":"@[deprecated (since := \"2024-08-19\")] alias nthLe_range' := get_range'\n"}
{"name":"List.nthLe_range'_1","module":"Mathlib.Data.List.Range","initialProofState":"n m i : Nat\nH : LT.lt i (List.range' n m).length\n⊢ Eq (GetElem.getElem (List.range' n m) i ⋯) (HAdd.hAdd n i)","decl":"@[deprecated (since := \"2024-08-19\")] alias nthLe_range'_1 := getElem_range'_1\n"}
{"name":"List.nthLe_range","module":"Mathlib.Data.List.Range","initialProofState":"n i : Nat\nH : LT.lt i (List.range n).length\n⊢ Eq ((List.range n).get ⟨i, H⟩) i","decl":"@[deprecated (since := \"2024-08-19\")] alias nthLe_range := get_range\n\n\n"}
{"name":"List.ranges_disjoint","module":"Mathlib.Data.List.Range","initialProofState":"l : List Nat\n⊢ List.Pairwise List.Disjoint l.ranges","decl":"/-- The members of `l.ranges` are pairwise disjoint -/\ntheorem ranges_disjoint (l : List ℕ) :\n    Pairwise Disjoint (ranges l) := by\n  induction l with\n  | nil => exact Pairwise.nil\n  | cons a l hl =>\n    simp only [ranges, pairwise_cons]\n    constructor\n    · intro s hs\n      obtain ⟨s', _, rfl⟩ := mem_map.mp hs\n      intro u hu\n      rw [mem_map]\n      rintro ⟨v, _, rfl⟩\n      rw [mem_range] at hu\n      omega\n    · rw [pairwise_map]\n      apply Pairwise.imp _ hl\n      intro u v\n      apply disjoint_map\n      exact fun u v => Nat.add_left_cancel\n\n"}
{"name":"List.ranges_length","module":"Mathlib.Data.List.Range","initialProofState":"l : List Nat\n⊢ Eq (List.map List.length l.ranges) l","decl":"/-- The lengths of the members of `l.ranges` are those given by `l` -/\ntheorem ranges_length (l : List ℕ) :\n    l.ranges.map length = l := by\n  induction l with\n  | nil => simp only [ranges, map_nil]\n  | cons a l hl => -- (a :: l)\n    simp only [ranges, map_cons, length_range, map_map, cons.injEq, true_and]\n    conv_rhs => rw [← hl]\n    apply map_congr_left\n    intro s _\n    simp only [Function.comp_apply, length_map]\n\n"}
{"name":"List.ranges_flatten'","module":"Mathlib.Data.List.Range","initialProofState":"l : List Nat\n⊢ Eq l.ranges.flatten (List.range (Nat.sum l))","decl":"set_option linter.deprecated false in\n/-- See `List.ranges_flatten` for the version about `List.sum`. -/\n@[deprecated \"Use `List.ranges_flatten`.\" (since := \"2024-10-17\")]\nlemma ranges_flatten' : ∀ l : List ℕ, l.ranges.flatten = range (Nat.sum l)\n  | [] => rfl\n  | a :: l => by\n    simp only [ranges, flatten_cons, ← map_flatten, ranges_flatten', Nat.sum_cons, range_add]\n\n"}
{"name":"List.ranges_join'","module":"Mathlib.Data.List.Range","initialProofState":"l : List Nat\n⊢ Eq l.ranges.flatten (List.range (Nat.sum l))","decl":"@[deprecated (since := \"2024-10-15\")] alias ranges_join' := ranges_flatten'\n\n"}
{"name":"List.mem_mem_ranges_iff_lt_natSum","module":"Mathlib.Data.List.Range","initialProofState":"l : List Nat\nn : Nat\n⊢ Iff (Exists fun s => And (Membership.mem l.ranges s) (Membership.mem s n)) (LT.lt n (Nat.sum l))","decl":"set_option linter.deprecated false in\n/-- Any entry of any member of `l.ranges` is strictly smaller than `Nat.sum l`.\nSee `List.mem_mem_ranges_iff_lt_sum` for the version about `List.sum`. -/\n@[deprecated \"Use `List.mem_mem_ranges_iff_lt_sum`.\" (since := \"2024-11-18\")]\nlemma mem_mem_ranges_iff_lt_natSum (l : List ℕ) {n : ℕ} :\n    (∃ s ∈ l.ranges, n ∈ s) ↔ n < Nat.sum l := by\n  rw [← mem_range, ← ranges_flatten', mem_flatten]\n\n"}
