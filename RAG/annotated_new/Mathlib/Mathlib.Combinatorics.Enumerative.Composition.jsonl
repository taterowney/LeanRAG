{"name":"Composition.mk.inj","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nblocks✝ : List Nat\nblocks_pos✝ : ∀ {i : Nat}, Membership.mem blocks✝ i → LT.lt 0 i\nblocks_sum✝ : Eq blocks✝.sum n\nblocks : List Nat\nblocks_pos : ∀ {i : Nat}, Membership.mem blocks i → LT.lt 0 i\nblocks_sum : Eq blocks.sum n\nx✝ : Eq { blocks := blocks✝, blocks_pos := blocks_pos✝, blocks_sum := blocks_sum✝ } { blocks := blocks, blocks_pos := blocks_pos, blocks_sum := blocks_sum }\n⊢ Eq blocks✝ blocks","decl":"/-- A composition of `n` is a list of positive integers summing to `n`. -/\n@[ext]\nstructure Composition (n : ℕ) where\n  /-- List of positive integers summing to `n`-/\n  blocks : List ℕ\n  /-- Proof of positivity for `blocks`-/\n  blocks_pos : ∀ {i}, i ∈ blocks → 0 < i\n  /-- Proof that `blocks` sums to `n`-/\n  blocks_sum : blocks.sum = n\n\n"}
{"name":"Composition.mk.sizeOf_spec","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nblocks : List Nat\nblocks_pos : ∀ {i : Nat}, Membership.mem blocks i → LT.lt 0 i\nblocks_sum : Eq blocks.sum n\n⊢ Eq (SizeOf.sizeOf { blocks := blocks, blocks_pos := blocks_pos, blocks_sum := blocks_sum }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf blocks)) (SizeOf.sizeOf blocks_sum))","decl":"/-- A composition of `n` is a list of positive integers summing to `n`. -/\n@[ext]\nstructure Composition (n : ℕ) where\n  /-- List of positive integers summing to `n`-/\n  blocks : List ℕ\n  /-- Proof of positivity for `blocks`-/\n  blocks_pos : ∀ {i}, i ∈ blocks → 0 < i\n  /-- Proof that `blocks` sums to `n`-/\n  blocks_sum : blocks.sum = n\n\n"}
{"name":"Composition.mk.injEq","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nblocks✝ : List Nat\nblocks_pos✝ : ∀ {i : Nat}, Membership.mem blocks✝ i → LT.lt 0 i\nblocks_sum✝ : Eq blocks✝.sum n\nblocks : List Nat\nblocks_pos : ∀ {i : Nat}, Membership.mem blocks i → LT.lt 0 i\nblocks_sum : Eq blocks.sum n\n⊢ Eq (Eq { blocks := blocks✝, blocks_pos := blocks_pos✝, blocks_sum := blocks_sum✝ } { blocks := blocks, blocks_pos := blocks_pos, blocks_sum := blocks_sum }) (Eq blocks✝ blocks)","decl":"/-- A composition of `n` is a list of positive integers summing to `n`. -/\n@[ext]\nstructure Composition (n : ℕ) where\n  /-- List of positive integers summing to `n`-/\n  blocks : List ℕ\n  /-- Proof of positivity for `blocks`-/\n  blocks_pos : ∀ {i}, i ∈ blocks → 0 < i\n  /-- Proof that `blocks` sums to `n`-/\n  blocks_sum : blocks.sum = n\n\n"}
{"name":"Composition.ext_iff","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nx y : Composition n\n⊢ Iff (Eq x y) (Eq x.blocks y.blocks)","decl":"/-- A composition of `n` is a list of positive integers summing to `n`. -/\n@[ext]\nstructure Composition (n : ℕ) where\n  /-- List of positive integers summing to `n`-/\n  blocks : List ℕ\n  /-- Proof of positivity for `blocks`-/\n  blocks_pos : ∀ {i}, i ∈ blocks → 0 < i\n  /-- Proof that `blocks` sums to `n`-/\n  blocks_sum : blocks.sum = n\n\n"}
{"name":"Composition.blocks_pos","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nself : Composition n\ni : Nat\na✝ : Membership.mem self.blocks i\n⊢ LT.lt 0 i","decl":"/-- A composition of `n` is a list of positive integers summing to `n`. -/\n@[ext]\nstructure Composition (n : ℕ) where\n  /-- List of positive integers summing to `n`-/\n  blocks : List ℕ\n  /-- Proof of positivity for `blocks`-/\n  blocks_pos : ∀ {i}, i ∈ blocks → 0 < i\n  /-- Proof that `blocks` sums to `n`-/\n  blocks_sum : blocks.sum = n\n\n"}
{"name":"Composition.blocks_sum","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nself : Composition n\n⊢ Eq self.blocks.sum n","decl":"/-- A composition of `n` is a list of positive integers summing to `n`. -/\n@[ext]\nstructure Composition (n : ℕ) where\n  /-- List of positive integers summing to `n`-/\n  blocks : List ℕ\n  /-- Proof of positivity for `blocks`-/\n  blocks_pos : ∀ {i}, i ∈ blocks → 0 < i\n  /-- Proof that `blocks` sums to `n`-/\n  blocks_sum : blocks.sum = n\n\n"}
{"name":"Composition.ext","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nx y : Composition n\nblocks : Eq x.blocks y.blocks\n⊢ Eq x y","decl":"/-- A composition of `n` is a list of positive integers summing to `n`. -/\n@[ext]\nstructure Composition (n : ℕ) where\n  /-- List of positive integers summing to `n`-/\n  blocks : List ℕ\n  /-- Proof of positivity for `blocks`-/\n  blocks_pos : ∀ {i}, i ∈ blocks → 0 < i\n  /-- Proof that `blocks` sums to `n`-/\n  blocks_sum : blocks.sum = n\n\n"}
{"name":"CompositionAsSet.ext","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nx y : CompositionAsSet n\nboundaries : Eq x.boundaries y.boundaries\n⊢ Eq x y","decl":"/-- Combinatorial viewpoint on a composition of `n`, by seeing it as non-empty blocks of\nconsecutive integers in `{0, ..., n-1}`. We register every block by its left end-point, yielding\na finset containing `0`. As this does not make sense for `n = 0`, we add `n` to this finset, and\nget a finset of `{0, ..., n}` containing `0` and `n`. This is the data in the structure\n`CompositionAsSet n`. -/\n@[ext]\nstructure CompositionAsSet (n : ℕ) where\n  /-- Combinatorial viewpoint on a composition of `n` as consecutive integers `{0, ..., n-1}`-/\n  boundaries : Finset (Fin n.succ)\n  /-- Proof that `0` is a member of `boundaries`-/\n  zero_mem : (0 : Fin n.succ) ∈ boundaries\n  /-- Last element of the composition -/\n  getLast_mem : Fin.last n ∈ boundaries\n\n"}
{"name":"CompositionAsSet.mk.sizeOf_spec","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nboundaries : Finset (Fin n.succ)\nzero_mem : Membership.mem boundaries 0\ngetLast_mem : Membership.mem boundaries (Fin.last n)\n⊢ Eq (SizeOf.sizeOf { boundaries := boundaries, zero_mem := zero_mem, getLast_mem := getLast_mem }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf boundaries)) (SizeOf.sizeOf zero_mem)) (SizeOf.sizeOf getLast_mem))","decl":"/-- Combinatorial viewpoint on a composition of `n`, by seeing it as non-empty blocks of\nconsecutive integers in `{0, ..., n-1}`. We register every block by its left end-point, yielding\na finset containing `0`. As this does not make sense for `n = 0`, we add `n` to this finset, and\nget a finset of `{0, ..., n}` containing `0` and `n`. This is the data in the structure\n`CompositionAsSet n`. -/\n@[ext]\nstructure CompositionAsSet (n : ℕ) where\n  /-- Combinatorial viewpoint on a composition of `n` as consecutive integers `{0, ..., n-1}`-/\n  boundaries : Finset (Fin n.succ)\n  /-- Proof that `0` is a member of `boundaries`-/\n  zero_mem : (0 : Fin n.succ) ∈ boundaries\n  /-- Last element of the composition -/\n  getLast_mem : Fin.last n ∈ boundaries\n\n"}
{"name":"CompositionAsSet.ext_iff","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nx y : CompositionAsSet n\n⊢ Iff (Eq x y) (Eq x.boundaries y.boundaries)","decl":"/-- Combinatorial viewpoint on a composition of `n`, by seeing it as non-empty blocks of\nconsecutive integers in `{0, ..., n-1}`. We register every block by its left end-point, yielding\na finset containing `0`. As this does not make sense for `n = 0`, we add `n` to this finset, and\nget a finset of `{0, ..., n}` containing `0` and `n`. This is the data in the structure\n`CompositionAsSet n`. -/\n@[ext]\nstructure CompositionAsSet (n : ℕ) where\n  /-- Combinatorial viewpoint on a composition of `n` as consecutive integers `{0, ..., n-1}`-/\n  boundaries : Finset (Fin n.succ)\n  /-- Proof that `0` is a member of `boundaries`-/\n  zero_mem : (0 : Fin n.succ) ∈ boundaries\n  /-- Last element of the composition -/\n  getLast_mem : Fin.last n ∈ boundaries\n\n"}
{"name":"CompositionAsSet.mk.inj","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nboundaries✝ : Finset (Fin n.succ)\nzero_mem✝ : Membership.mem boundaries✝ 0\ngetLast_mem✝ : Membership.mem boundaries✝ (Fin.last n)\nboundaries : Finset (Fin n.succ)\nzero_mem : Membership.mem boundaries 0\ngetLast_mem : Membership.mem boundaries (Fin.last n)\nx✝ : Eq { boundaries := boundaries✝, zero_mem := zero_mem✝, getLast_mem := getLast_mem✝ } { boundaries := boundaries, zero_mem := zero_mem, getLast_mem := getLast_mem }\n⊢ Eq boundaries✝ boundaries","decl":"/-- Combinatorial viewpoint on a composition of `n`, by seeing it as non-empty blocks of\nconsecutive integers in `{0, ..., n-1}`. We register every block by its left end-point, yielding\na finset containing `0`. As this does not make sense for `n = 0`, we add `n` to this finset, and\nget a finset of `{0, ..., n}` containing `0` and `n`. This is the data in the structure\n`CompositionAsSet n`. -/\n@[ext]\nstructure CompositionAsSet (n : ℕ) where\n  /-- Combinatorial viewpoint on a composition of `n` as consecutive integers `{0, ..., n-1}`-/\n  boundaries : Finset (Fin n.succ)\n  /-- Proof that `0` is a member of `boundaries`-/\n  zero_mem : (0 : Fin n.succ) ∈ boundaries\n  /-- Last element of the composition -/\n  getLast_mem : Fin.last n ∈ boundaries\n\n"}
{"name":"CompositionAsSet.zero_mem","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nself : CompositionAsSet n\n⊢ Membership.mem self.boundaries 0","decl":"/-- Combinatorial viewpoint on a composition of `n`, by seeing it as non-empty blocks of\nconsecutive integers in `{0, ..., n-1}`. We register every block by its left end-point, yielding\na finset containing `0`. As this does not make sense for `n = 0`, we add `n` to this finset, and\nget a finset of `{0, ..., n}` containing `0` and `n`. This is the data in the structure\n`CompositionAsSet n`. -/\n@[ext]\nstructure CompositionAsSet (n : ℕ) where\n  /-- Combinatorial viewpoint on a composition of `n` as consecutive integers `{0, ..., n-1}`-/\n  boundaries : Finset (Fin n.succ)\n  /-- Proof that `0` is a member of `boundaries`-/\n  zero_mem : (0 : Fin n.succ) ∈ boundaries\n  /-- Last element of the composition -/\n  getLast_mem : Fin.last n ∈ boundaries\n\n"}
{"name":"CompositionAsSet.mk.injEq","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nboundaries✝ : Finset (Fin n.succ)\nzero_mem✝ : Membership.mem boundaries✝ 0\ngetLast_mem✝ : Membership.mem boundaries✝ (Fin.last n)\nboundaries : Finset (Fin n.succ)\nzero_mem : Membership.mem boundaries 0\ngetLast_mem : Membership.mem boundaries (Fin.last n)\n⊢ Eq (Eq { boundaries := boundaries✝, zero_mem := zero_mem✝, getLast_mem := getLast_mem✝ } { boundaries := boundaries, zero_mem := zero_mem, getLast_mem := getLast_mem }) (Eq boundaries✝ boundaries)","decl":"/-- Combinatorial viewpoint on a composition of `n`, by seeing it as non-empty blocks of\nconsecutive integers in `{0, ..., n-1}`. We register every block by its left end-point, yielding\na finset containing `0`. As this does not make sense for `n = 0`, we add `n` to this finset, and\nget a finset of `{0, ..., n}` containing `0` and `n`. This is the data in the structure\n`CompositionAsSet n`. -/\n@[ext]\nstructure CompositionAsSet (n : ℕ) where\n  /-- Combinatorial viewpoint on a composition of `n` as consecutive integers `{0, ..., n-1}`-/\n  boundaries : Finset (Fin n.succ)\n  /-- Proof that `0` is a member of `boundaries`-/\n  zero_mem : (0 : Fin n.succ) ∈ boundaries\n  /-- Last element of the composition -/\n  getLast_mem : Fin.last n ∈ boundaries\n\n"}
{"name":"CompositionAsSet.getLast_mem","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nself : CompositionAsSet n\n⊢ Membership.mem self.boundaries (Fin.last n)","decl":"/-- Combinatorial viewpoint on a composition of `n`, by seeing it as non-empty blocks of\nconsecutive integers in `{0, ..., n-1}`. We register every block by its left end-point, yielding\na finset containing `0`. As this does not make sense for `n = 0`, we add `n` to this finset, and\nget a finset of `{0, ..., n}` containing `0` and `n`. This is the data in the structure\n`CompositionAsSet n`. -/\n@[ext]\nstructure CompositionAsSet (n : ℕ) where\n  /-- Combinatorial viewpoint on a composition of `n` as consecutive integers `{0, ..., n-1}`-/\n  boundaries : Finset (Fin n.succ)\n  /-- Proof that `0` is a member of `boundaries`-/\n  zero_mem : (0 : Fin n.succ) ∈ boundaries\n  /-- Last element of the composition -/\n  getLast_mem : Fin.last n ∈ boundaries\n\n"}
{"name":"Composition.blocks_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Eq c.blocks.length c.length","decl":"theorem blocks_length : c.blocks.length = c.length :=\n  rfl\n\n"}
{"name":"Composition.ofFn_blocksFun","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Eq (List.ofFn c.blocksFun) c.blocks","decl":"theorem ofFn_blocksFun : ofFn c.blocksFun = c.blocks :=\n  ofFn_get _\n\n"}
{"name":"Composition.sum_blocksFun","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Eq (Finset.univ.sum fun i => c.blocksFun i) n","decl":"theorem sum_blocksFun : ∑ i, c.blocksFun i = n := by\n  conv_rhs => rw [← c.blocks_sum, ← ofFn_blocksFun, sum_ofFn]\n\n"}
{"name":"Composition.blocksFun_mem_blocks","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Fin c.length\n⊢ Membership.mem c.blocks (c.blocksFun i)","decl":"theorem blocksFun_mem_blocks (i : Fin c.length) : c.blocksFun i ∈ c.blocks :=\n  get_mem _ _\n\n"}
{"name":"Composition.one_le_blocks","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Nat\nh : Membership.mem c.blocks i\n⊢ LE.le 1 i","decl":"@[simp]\ntheorem one_le_blocks {i : ℕ} (h : i ∈ c.blocks) : 1 ≤ i :=\n  c.blocks_pos h\n\n"}
{"name":"Composition.one_le_blocks'","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Nat\nh : LT.lt i c.length\n⊢ LE.le 1 (GetElem.getElem c.blocks i ⋯)","decl":"@[simp]\ntheorem one_le_blocks' {i : ℕ} (h : i < c.length) : 1 ≤ c.blocks[i] :=\n  c.one_le_blocks (get_mem (blocks c) _)\n\n"}
{"name":"Composition.blocks_pos'","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Nat\nh : LT.lt i c.length\n⊢ LT.lt 0 (GetElem.getElem c.blocks i ⋯)","decl":"@[simp]\ntheorem blocks_pos' (i : ℕ) (h : i < c.length) : 0 < c.blocks[i] :=\n  c.one_le_blocks' h\n\n"}
{"name":"Composition.one_le_blocksFun","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Fin c.length\n⊢ LE.le 1 (c.blocksFun i)","decl":"theorem one_le_blocksFun (i : Fin c.length) : 1 ≤ c.blocksFun i :=\n  c.one_le_blocks (c.blocksFun_mem_blocks i)\n\n"}
{"name":"Composition.blocksFun_le","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Fin c.length\n⊢ LE.le (c.blocksFun i) n","decl":"theorem blocksFun_le {n} (c : Composition n) (i : Fin c.length) :\n    c.blocksFun i ≤ n := by\n  have := c.blocks_sum\n  have := List.le_sum_of_mem (c.blocksFun_mem_blocks i)\n  simp_all\n\n"}
{"name":"Composition.length_le","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ LE.le c.length n","decl":"theorem length_le : c.length ≤ n := by\n  conv_rhs => rw [← c.blocks_sum]\n  exact length_le_sum_of_one_le _ fun i hi => c.one_le_blocks hi\n\n"}
{"name":"Composition.length_pos_of_pos","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\nh : LT.lt 0 n\n⊢ LT.lt 0 c.length","decl":"theorem length_pos_of_pos (h : 0 < n) : 0 < c.length := by\n  apply length_pos_of_sum_pos\n  convert h\n  exact c.blocks_sum\n\n"}
{"name":"Composition.sizeUpTo_zero","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Eq (c.sizeUpTo 0) 0","decl":"@[simp]\ntheorem sizeUpTo_zero : c.sizeUpTo 0 = 0 := by simp [sizeUpTo]\n\n"}
{"name":"Composition.sizeUpTo_ofLength_le","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Nat\nh : LE.le c.length i\n⊢ Eq (c.sizeUpTo i) n","decl":"theorem sizeUpTo_ofLength_le (i : ℕ) (h : c.length ≤ i) : c.sizeUpTo i = n := by\n  dsimp [sizeUpTo]\n  convert c.blocks_sum\n  exact take_of_length_le h\n\n"}
{"name":"Composition.sizeUpTo_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Eq (c.sizeUpTo c.length) n","decl":"@[simp]\ntheorem sizeUpTo_length : c.sizeUpTo c.length = n :=\n  c.sizeUpTo_ofLength_le c.length le_rfl\n\n"}
{"name":"Composition.sizeUpTo_le","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Nat\n⊢ LE.le (c.sizeUpTo i) n","decl":"theorem sizeUpTo_le (i : ℕ) : c.sizeUpTo i ≤ n := by\n  conv_rhs => rw [← c.blocks_sum, ← sum_take_add_sum_drop _ i]\n  exact Nat.le_add_right _ _\n\n"}
{"name":"Composition.sizeUpTo_succ","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Nat\nh : LT.lt i c.length\n⊢ Eq (c.sizeUpTo (HAdd.hAdd i 1)) (HAdd.hAdd (c.sizeUpTo i) (GetElem.getElem c.blocks i ⋯))","decl":"theorem sizeUpTo_succ {i : ℕ} (h : i < c.length) :\n    c.sizeUpTo (i + 1) = c.sizeUpTo i + c.blocks[i] := by\n  simp only [sizeUpTo]\n  rw [sum_take_succ _ _ h]\n\n"}
{"name":"Composition.sizeUpTo_succ'","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Fin c.length\n⊢ Eq (c.sizeUpTo (HAdd.hAdd (↑i) 1)) (HAdd.hAdd (c.sizeUpTo ↑i) (c.blocksFun i))","decl":"theorem sizeUpTo_succ' (i : Fin c.length) :\n    c.sizeUpTo ((i : ℕ) + 1) = c.sizeUpTo i + c.blocksFun i :=\n  c.sizeUpTo_succ i.2\n\n"}
{"name":"Composition.sizeUpTo_strict_mono","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Nat\nh : LT.lt i c.length\n⊢ LT.lt (c.sizeUpTo i) (c.sizeUpTo (HAdd.hAdd i 1))","decl":"theorem sizeUpTo_strict_mono {i : ℕ} (h : i < c.length) : c.sizeUpTo i < c.sizeUpTo (i + 1) := by\n  rw [c.sizeUpTo_succ h]\n  simp\n\n"}
{"name":"Composition.monotone_sizeUpTo","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Monotone c.sizeUpTo","decl":"theorem monotone_sizeUpTo : Monotone c.sizeUpTo :=\n  monotone_sum_take _\n\n"}
{"name":"Composition.boundary_zero","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Eq (c.boundary 0) 0","decl":"@[simp]\ntheorem boundary_zero : c.boundary 0 = 0 := by simp [boundary, Fin.ext_iff]\n\n"}
{"name":"Composition.boundary_last","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Eq (c.boundary (Fin.last c.length)) (Fin.last n)","decl":"@[simp]\ntheorem boundary_last : c.boundary (Fin.last c.length) = Fin.last n := by\n  simp [boundary, Fin.ext_iff]\n\n"}
{"name":"Composition.card_boundaries_eq_succ_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Eq c.boundaries.card (HAdd.hAdd c.length 1)","decl":"theorem card_boundaries_eq_succ_length : c.boundaries.card = c.length + 1 := by simp [boundaries]\n\n"}
{"name":"Composition.orderEmbOfFin_boundaries","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Eq (c.boundaries.orderEmbOfFin ⋯) c.boundary","decl":"/-- The canonical increasing bijection between `Fin (c.length + 1)` and `c.boundaries` is\nexactly `c.boundary`. -/\ntheorem orderEmbOfFin_boundaries :\n    c.boundaries.orderEmbOfFin c.card_boundaries_eq_succ_length = c.boundary := by\n  refine (Finset.orderEmbOfFin_unique' _ ?_).symm\n  exact fun i => (Finset.mem_map' _).2 (Finset.mem_univ _)\n\n"}
{"name":"Composition.coe_embedding","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Fin c.length\nj : Fin (c.blocksFun i)\n⊢ Eq (↑((c.embedding i) j)) (HAdd.hAdd (c.sizeUpTo ↑i) ↑j)","decl":"@[simp]\ntheorem coe_embedding (i : Fin c.length) (j : Fin (c.blocksFun i)) :\n    (c.embedding i j : ℕ) = c.sizeUpTo i + j :=\n  rfl\n\n"}
{"name":"Composition.index_exists","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\nj : Nat\nh : LT.lt j n\n⊢ Exists fun i => And (LT.lt j (c.sizeUpTo (HAdd.hAdd i 1))) (LT.lt i c.length)","decl":"/-- `index_exists` asserts there is some `i` with `j < c.sizeUpTo (i+1)`.\nIn the next definition `index` we use `Nat.find` to produce the minimal such index.\n-/\ntheorem index_exists {j : ℕ} (h : j < n) : ∃ i : ℕ, j < c.sizeUpTo (i + 1) ∧ i < c.length := by\n  have n_pos : 0 < n := lt_of_le_of_lt (zero_le j) h\n  have : 0 < c.blocks.sum := by rwa [← c.blocks_sum] at n_pos\n  have length_pos : 0 < c.blocks.length := length_pos_of_sum_pos (blocks c) this\n  refine ⟨c.length - 1, ?_, Nat.pred_lt (ne_of_gt length_pos)⟩\n  have : c.length - 1 + 1 = c.length := Nat.succ_pred_eq_of_pos length_pos\n  simp [this, h]\n\n"}
{"name":"Composition.lt_sizeUpTo_index_succ","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\nj : Fin n\n⊢ LT.lt (↑j) (c.sizeUpTo ↑(c.index j).succ)","decl":"theorem lt_sizeUpTo_index_succ (j : Fin n) : (j : ℕ) < c.sizeUpTo (c.index j).succ :=\n  (Nat.find_spec (c.index_exists j.2)).1\n\n"}
{"name":"Composition.sizeUpTo_index_le","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\nj : Fin n\n⊢ LE.le (c.sizeUpTo ↑(c.index j)) ↑j","decl":"theorem sizeUpTo_index_le (j : Fin n) : c.sizeUpTo (c.index j) ≤ j := by\n  by_contra H\n  set i := c.index j\n  push_neg at H\n  have i_pos : (0 : ℕ) < i := by\n    by_contra! i_pos\n    revert H\n    simp [nonpos_iff_eq_zero.1 i_pos, c.sizeUpTo_zero]\n  let i₁ := (i : ℕ).pred\n  have i₁_lt_i : i₁ < i := Nat.pred_lt (ne_of_gt i_pos)\n  have i₁_succ : i₁ + 1 = i := Nat.succ_pred_eq_of_pos i_pos\n  have := Nat.find_min (c.index_exists j.2) i₁_lt_i\n  simp [lt_trans i₁_lt_i (c.index j).2, i₁_succ] at this\n  exact Nat.lt_le_asymm H this\n\n"}
{"name":"Composition.coe_invEmbedding","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\nj : Fin n\n⊢ Eq (↑(c.invEmbedding j)) (HSub.hSub (↑j) (c.sizeUpTo ↑(c.index j)))","decl":"@[simp]\ntheorem coe_invEmbedding (j : Fin n) : (c.invEmbedding j : ℕ) = j - c.sizeUpTo (c.index j) :=\n  rfl\n\n"}
{"name":"Composition.embedding_comp_inv","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\nj : Fin n\n⊢ Eq ((c.embedding (c.index j)) (c.invEmbedding j)) j","decl":"theorem embedding_comp_inv (j : Fin n) : c.embedding (c.index j) (c.invEmbedding j) = j := by\n  rw [Fin.ext_iff]\n  apply add_tsub_cancel_of_le (c.sizeUpTo_index_le j)\n\n"}
{"name":"Composition.mem_range_embedding_iff","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\nj : Fin n\ni : Fin c.length\n⊢ Iff (Membership.mem (Set.range ⇑(c.embedding i)) j) (And (LE.le (c.sizeUpTo ↑i) ↑j) (LT.lt (↑j) (c.sizeUpTo (↑i).succ)))","decl":"theorem mem_range_embedding_iff {j : Fin n} {i : Fin c.length} :\n    j ∈ Set.range (c.embedding i) ↔ c.sizeUpTo i ≤ j ∧ (j : ℕ) < c.sizeUpTo (i : ℕ).succ := by\n  constructor\n  · intro h\n    rcases Set.mem_range.2 h with ⟨k, hk⟩\n    rw [Fin.ext_iff] at hk\n    dsimp at hk\n    rw [← hk]\n    simp [sizeUpTo_succ', k.is_lt]\n  · intro h\n    apply Set.mem_range.2\n    refine ⟨⟨j - c.sizeUpTo i, ?_⟩, ?_⟩\n    · rw [tsub_lt_iff_left, ← sizeUpTo_succ']\n      · exact h.2\n      · exact h.1\n    · rw [Fin.ext_iff]\n      exact add_tsub_cancel_of_le h.1\n\n"}
{"name":"Composition.disjoint_range","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni₁ i₂ : Fin c.length\nh : Ne i₁ i₂\n⊢ Disjoint (Set.range ⇑(c.embedding i₁)) (Set.range ⇑(c.embedding i₂))","decl":"/-- The embeddings of different blocks of a composition are disjoint. -/\ntheorem disjoint_range {i₁ i₂ : Fin c.length} (h : i₁ ≠ i₂) :\n    Disjoint (Set.range (c.embedding i₁)) (Set.range (c.embedding i₂)) := by\n  classical\n    wlog h' : i₁ < i₂\n    · exact (this c h.symm (h.lt_or_lt.resolve_left h')).symm\n    by_contra d\n    obtain ⟨x, hx₁, hx₂⟩ :\n      ∃ x : Fin n, x ∈ Set.range (c.embedding i₁) ∧ x ∈ Set.range (c.embedding i₂) :=\n      Set.not_disjoint_iff.1 d\n    have A : (i₁ : ℕ).succ ≤ i₂ := Nat.succ_le_of_lt h'\n    apply lt_irrefl (x : ℕ)\n    calc\n      (x : ℕ) < c.sizeUpTo (i₁ : ℕ).succ := (c.mem_range_embedding_iff.1 hx₁).2\n      _ ≤ c.sizeUpTo (i₂ : ℕ) := monotone_sum_take _ A\n      _ ≤ x := (c.mem_range_embedding_iff.1 hx₂).1\n\n"}
{"name":"Composition.mem_range_embedding","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\nj : Fin n\n⊢ Membership.mem (Set.range ⇑(c.embedding (c.index j))) j","decl":"theorem mem_range_embedding (j : Fin n) : j ∈ Set.range (c.embedding (c.index j)) := by\n  have : c.embedding (c.index j) (c.invEmbedding j) ∈ Set.range (c.embedding (c.index j)) :=\n    Set.mem_range_self _\n  rwa [c.embedding_comp_inv j] at this\n\n"}
{"name":"Composition.mem_range_embedding_iff'","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\nj : Fin n\ni : Fin c.length\n⊢ Iff (Membership.mem (Set.range ⇑(c.embedding i)) j) (Eq i (c.index j))","decl":"theorem mem_range_embedding_iff' {j : Fin n} {i : Fin c.length} :\n    j ∈ Set.range (c.embedding i) ↔ i = c.index j := by\n  constructor\n  · rw [← not_imp_not]\n    intro h\n    exact Set.disjoint_right.1 (c.disjoint_range h) (c.mem_range_embedding j)\n  · intro h\n    rw [h]\n    exact c.mem_range_embedding j\n\n"}
{"name":"Composition.index_embedding","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Fin c.length\nj : Fin (c.blocksFun i)\n⊢ Eq (c.index ((c.embedding i) j)) i","decl":"theorem index_embedding (i : Fin c.length) (j : Fin (c.blocksFun i)) :\n    c.index (c.embedding i j) = i := by\n  symm\n  rw [← mem_range_embedding_iff']\n  apply Set.mem_range_self\n\n"}
{"name":"Composition.invEmbedding_comp","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\ni : Fin c.length\nj : Fin (c.blocksFun i)\n⊢ Eq ↑(c.invEmbedding ((c.embedding i) j)) ↑j","decl":"theorem invEmbedding_comp (i : Fin c.length) (j : Fin (c.blocksFun i)) :\n    (c.invEmbedding (c.embedding i j) : ℕ) = j := by\n  simp_rw [coe_invEmbedding, index_embedding, coe_embedding, add_tsub_cancel_left]\n\n"}
{"name":"Composition.blocksFun_congr","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n₁ n₂ : Nat\nc₁ : Composition n₁\nc₂ : Composition n₂\ni₁ : Fin c₁.length\ni₂ : Fin c₂.length\nhn : Eq n₁ n₂\nhc : Eq c₁.blocks c₂.blocks\nhi : Eq ↑i₁ ↑i₂\n⊢ Eq (c₁.blocksFun i₁) (c₂.blocksFun i₂)","decl":"theorem blocksFun_congr {n₁ n₂ : ℕ} (c₁ : Composition n₁) (c₂ : Composition n₂) (i₁ : Fin c₁.length)\n    (i₂ : Fin c₂.length) (hn : n₁ = n₂) (hc : c₁.blocks = c₂.blocks) (hi : (i₁ : ℕ) = i₂) :\n    c₁.blocksFun i₁ = c₂.blocksFun i₂ := by\n  cases hn\n  rw [← Composition.ext_iff] at hc\n  cases hc\n  congr\n  rwa [Fin.ext_iff]\n\n"}
{"name":"Composition.sigma_eq_iff_blocks_eq","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"c c' : Sigma fun n => Composition n\n⊢ Iff (Eq c c') (Eq c.snd.blocks c'.snd.blocks)","decl":"/-- Two compositions (possibly of different integers) coincide if and only if they have the\nsame sequence of blocks. -/\ntheorem sigma_eq_iff_blocks_eq {c : Σn, Composition n} {c' : Σn, Composition n} :\n    c = c' ↔ c.2.blocks = c'.2.blocks := by\n  refine ⟨fun H => by rw [H], fun H => ?_⟩\n  rcases c with ⟨n, c⟩\n  rcases c' with ⟨n', c'⟩\n  have : n = n' := by rw [← c.blocks_sum, ← c'.blocks_sum, H]\n  induction this\n  congr\n  ext1\n  exact H\n\n"}
{"name":"Composition.ones_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\n⊢ Eq (Composition.ones n).length n","decl":"@[simp]\ntheorem ones_length (n : ℕ) : (ones n).length = n :=\n  List.length_replicate n 1\n\n"}
{"name":"Composition.ones_blocks","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\n⊢ Eq (Composition.ones n).blocks (List.replicate n 1)","decl":"@[simp]\ntheorem ones_blocks (n : ℕ) : (ones n).blocks = replicate n (1 : ℕ) :=\n  rfl\n\n"}
{"name":"Composition.ones_blocksFun","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\ni : Fin (Composition.ones n).length\n⊢ Eq ((Composition.ones n).blocksFun i) 1","decl":"@[simp]\ntheorem ones_blocksFun (n : ℕ) (i : Fin (ones n).length) : (ones n).blocksFun i = 1 := by\n  simp only [blocksFun, ones, get_eq_getElem, getElem_replicate]\n\n"}
{"name":"Composition.ones_sizeUpTo","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n i : Nat\n⊢ Eq ((Composition.ones n).sizeUpTo i) (Min.min i n)","decl":"@[simp]\ntheorem ones_sizeUpTo (n : ℕ) (i : ℕ) : (ones n).sizeUpTo i = min i n := by\n  simp [sizeUpTo, ones_blocks, take_replicate]\n\n"}
{"name":"Composition.ones_embedding","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\ni : Fin (Composition.ones n).length\nh : LT.lt 0 ((Composition.ones n).blocksFun i)\n⊢ Eq (((Composition.ones n).embedding i) ⟨0, h⟩) ⟨↑i, ⋯⟩","decl":"@[simp]\ntheorem ones_embedding (i : Fin (ones n).length) (h : 0 < (ones n).blocksFun i) :\n    (ones n).embedding i ⟨0, h⟩ = ⟨i, lt_of_lt_of_le i.2 (ones n).length_le⟩ := by\n  ext\n  simpa using i.2.le\n\n"}
{"name":"Composition.eq_ones_iff","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Iff (Eq c (Composition.ones n)) (∀ (i : Nat), Membership.mem c.blocks i → Eq i 1)","decl":"theorem eq_ones_iff {c : Composition n} : c = ones n ↔ ∀ i ∈ c.blocks, i = 1 := by\n  constructor\n  · rintro rfl\n    exact fun i => eq_of_mem_replicate\n  · intro H\n    ext1\n    have A : c.blocks = replicate c.blocks.length 1 := eq_replicate_of_mem H\n    have : c.blocks.length = n := by\n      conv_rhs => rw [← c.blocks_sum, A]\n      simp\n    rw [A, this, ones_blocks]\n\n"}
{"name":"Composition.ne_ones_iff","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Iff (Ne c (Composition.ones n)) (Exists fun i => And (Membership.mem c.blocks i) (LT.lt 1 i))","decl":"theorem ne_ones_iff {c : Composition n} : c ≠ ones n ↔ ∃ i ∈ c.blocks, 1 < i := by\n  refine (not_congr eq_ones_iff).trans ?_\n  have : ∀ j ∈ c.blocks, j = 1 ↔ j ≤ 1 := fun j hj => by simp [le_antisymm_iff, c.one_le_blocks hj]\n  simp +contextual [this]\n\n"}
{"name":"Composition.eq_ones_iff_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Iff (Eq c (Composition.ones n)) (Eq c.length n)","decl":"theorem eq_ones_iff_length {c : Composition n} : c = ones n ↔ c.length = n := by\n  constructor\n  · rintro rfl\n    exact ones_length n\n  · contrapose\n    intro H length_n\n    apply lt_irrefl n\n    calc\n      n = ∑ i : Fin c.length, 1 := by simp [length_n]\n      _ < ∑ i : Fin c.length, c.blocksFun i := by\n        {\n        obtain ⟨i, hi, i_blocks⟩ : ∃ i ∈ c.blocks, 1 < i := ne_ones_iff.1 H\n        rw [← ofFn_blocksFun, mem_ofFn c.blocksFun, Set.mem_range] at hi\n        obtain ⟨j : Fin c.length, hj : c.blocksFun j = i⟩ := hi\n        rw [← hj] at i_blocks\n        exact Finset.sum_lt_sum (fun i _ => one_le_blocksFun c i) ⟨j, Finset.mem_univ _, i_blocks⟩\n        }\n      _ = n := c.sum_blocksFun\n\n"}
{"name":"Composition.eq_ones_iff_le_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Iff (Eq c (Composition.ones n)) (LE.le n c.length)","decl":"theorem eq_ones_iff_le_length {c : Composition n} : c = ones n ↔ n ≤ c.length := by\n  simp [eq_ones_iff_length, le_antisymm_iff, c.length_le]\n\n"}
{"name":"Composition.single_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nh : LT.lt 0 n\n⊢ Eq (Composition.single n h).length 1","decl":"@[simp]\ntheorem single_length {n : ℕ} (h : 0 < n) : (single n h).length = 1 :=\n  rfl\n\n"}
{"name":"Composition.single_blocks","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nh : LT.lt 0 n\n⊢ Eq (Composition.single n h).blocks (List.cons n List.nil)","decl":"@[simp]\ntheorem single_blocks {n : ℕ} (h : 0 < n) : (single n h).blocks = [n] :=\n  rfl\n\n"}
{"name":"Composition.single_blocksFun","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nh : LT.lt 0 n\ni : Fin (Composition.single n h).length\n⊢ Eq ((Composition.single n h).blocksFun i) n","decl":"@[simp]\ntheorem single_blocksFun {n : ℕ} (h : 0 < n) (i : Fin (single n h).length) :\n    (single n h).blocksFun i = n := by simp [blocksFun, single, blocks, i.2]\n\n"}
{"name":"Composition.single_embedding","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nh : LT.lt 0 n\ni : Fin n\n⊢ Eq (((Composition.single n h).embedding 0) i) i","decl":"@[simp]\ntheorem single_embedding {n : ℕ} (h : 0 < n) (i : Fin n) :\n    ((single n h).embedding (0 : Fin 1)) i = i := by\n  ext\n  simp\n\n"}
{"name":"Composition.eq_single_iff_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nh : LT.lt 0 n\nc : Composition n\n⊢ Iff (Eq c (Composition.single n h)) (Eq c.length 1)","decl":"theorem eq_single_iff_length {n : ℕ} (h : 0 < n) {c : Composition n} :\n    c = single n h ↔ c.length = 1 := by\n  constructor\n  · intro H\n    rw [H]\n    exact single_length h\n  · intro H\n    ext1\n    have A : c.blocks.length = 1 := H ▸ c.blocks_length\n    have B : c.blocks.sum = n := c.blocks_sum\n    rw [eq_cons_of_length_one A] at B ⊢\n    simpa [single_blocks] using B\n\n"}
{"name":"Composition.ne_single_iff","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nhn : LT.lt 0 n\nc : Composition n\n⊢ Iff (Ne c (Composition.single n hn)) (∀ (i : Fin c.length), LT.lt (c.blocksFun i) n)","decl":"theorem ne_single_iff {n : ℕ} (hn : 0 < n) {c : Composition n} :\n    c ≠ single n hn ↔ ∀ i, c.blocksFun i < n := by\n  rw [← not_iff_not]\n  push_neg\n  constructor\n  · rintro rfl\n    exact ⟨⟨0, by simp⟩, by simp⟩\n  · rintro ⟨i, hi⟩\n    rw [eq_single_iff_length]\n    have : ∀ j : Fin c.length, j = i := by\n      intro j\n      by_contra ji\n      apply lt_irrefl (∑ k, c.blocksFun k)\n      calc\n        ∑ k, c.blocksFun k ≤ c.blocksFun i := by simp only [c.sum_blocksFun, hi]\n        _ < ∑ k, c.blocksFun k :=\n          Finset.single_lt_sum ji (Finset.mem_univ _) (Finset.mem_univ _) (c.one_le_blocksFun j)\n            fun _ _ _ => zero_le _\n\n    simpa using Fintype.card_eq_one_of_forall_eq this\n\n"}
{"name":"List.splitWrtCompositionAux_cons","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"α : Type u_1\nl : List α\nn : Nat\nns : List Nat\n⊢ Eq (l.splitWrtCompositionAux (List.cons n ns)) (List.cons (List.take n l) ((List.drop n l).splitWrtCompositionAux ns))","decl":"@[local simp]\ntheorem splitWrtCompositionAux_cons (l : List α) (n ns) :\n    l.splitWrtCompositionAux (n::ns) = take n l::(drop n l).splitWrtCompositionAux ns := by\n  simp [splitWrtCompositionAux]\n\n"}
{"name":"List.length_splitWrtCompositionAux","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"α : Type u_1\nl : List α\nns : List Nat\n⊢ Eq (l.splitWrtCompositionAux ns).length ns.length","decl":"theorem length_splitWrtCompositionAux (l : List α) (ns) :\n    length (l.splitWrtCompositionAux ns) = ns.length := by\n    induction ns generalizing l\n    · simp [splitWrtCompositionAux, *]\n    · simp [*]\n\n"}
{"name":"List.length_splitWrtComposition","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nα : Type u_1\nl : List α\nc : Composition n\n⊢ Eq (l.splitWrtComposition c).length c.length","decl":"/-- When one splits a list along a composition `c`, the number of sublists thus created is\n`c.length`. -/\n@[simp]\ntheorem length_splitWrtComposition (l : List α) (c : Composition n) :\n    length (l.splitWrtComposition c) = c.length :=\n  length_splitWrtCompositionAux _ _\n\n\n"}
{"name":"List.map_length_splitWrtCompositionAux","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"α : Type u_1\nns : List Nat\nl : List α\na✝ : LE.le ns.sum l.length\n⊢ Eq (List.map List.length (l.splitWrtCompositionAux ns)) ns","decl":"theorem map_length_splitWrtCompositionAux {ns : List ℕ} :\n    ∀ {l : List α}, ns.sum ≤ l.length → map length (l.splitWrtCompositionAux ns) = ns := by\n  induction' ns with n ns IH <;> intro l h <;> simp at h\n  · simp [splitWrtCompositionAux]\n  have := le_trans (Nat.le_add_right _ _) h\n  simp only [splitWrtCompositionAux_cons, this]; dsimp\n  rw [length_take, IH] <;> simp [length_drop]\n  · assumption\n  · exact le_tsub_of_add_le_left h\n\n"}
{"name":"List.map_length_splitWrtComposition","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"α : Type u_1\nl : List α\nc : Composition l.length\n⊢ Eq (List.map List.length (l.splitWrtComposition c)) c.blocks","decl":"/-- When one splits a list along a composition `c`, the lengths of the sublists thus created are\ngiven by the block sizes in `c`. -/\ntheorem map_length_splitWrtComposition (l : List α) (c : Composition l.length) :\n    map length (l.splitWrtComposition c) = c.blocks :=\n  map_length_splitWrtCompositionAux (le_of_eq c.blocks_sum)\n\n"}
{"name":"List.length_pos_of_mem_splitWrtComposition","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"α : Type u_1\nl l' : List α\nc : Composition l.length\nh : Membership.mem (l.splitWrtComposition c) l'\n⊢ LT.lt 0 l'.length","decl":"theorem length_pos_of_mem_splitWrtComposition {l l' : List α} {c : Composition l.length}\n    (h : l' ∈ l.splitWrtComposition c) : 0 < length l' := by\n  have : l'.length ∈ (l.splitWrtComposition c).map List.length :=\n    List.mem_map_of_mem List.length h\n  rw [map_length_splitWrtComposition] at this\n  exact c.blocks_pos this\n\n"}
{"name":"List.sum_take_map_length_splitWrtComposition","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"α : Type u_1\nl : List α\nc : Composition l.length\ni : Nat\n⊢ Eq (List.take i (List.map List.length (l.splitWrtComposition c))).sum (c.sizeUpTo i)","decl":"theorem sum_take_map_length_splitWrtComposition (l : List α) (c : Composition l.length) (i : ℕ) :\n    (((l.splitWrtComposition c).map length).take i).sum = c.sizeUpTo i := by\n  congr\n  exact map_length_splitWrtComposition l c\n\n"}
{"name":"List.getElem_splitWrtCompositionAux","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"α : Type u_1\nl : List α\nns : List Nat\ni : Nat\nhi : LT.lt i (l.splitWrtCompositionAux ns).length\n⊢ Eq (GetElem.getElem (l.splitWrtCompositionAux ns) i ⋯) (List.drop (List.take i ns).sum (List.take (List.take (HAdd.hAdd i 1) ns).sum l))","decl":"theorem getElem_splitWrtCompositionAux (l : List α) (ns : List ℕ) {i : ℕ}\n    (hi : i < (l.splitWrtCompositionAux ns).length) :\n    (l.splitWrtCompositionAux ns)[i] =\n      (l.take (ns.take (i + 1)).sum).drop (ns.take i).sum := by\n  induction' ns with n ns IH generalizing l i\n  · cases hi\n  cases' i with i\n  · rw [Nat.add_zero, List.take_zero, sum_nil]\n    simp\n  · simp only [splitWrtCompositionAux, getElem_cons_succ, IH, take,\n        sum_cons, Nat.add_eq, add_zero, splitAt_eq, drop_take, drop_drop]\n    rw [Nat.add_sub_add_left]\n\n"}
{"name":"List.getElem_splitWrtComposition'","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nα : Type u_1\nl : List α\nc : Composition n\ni : Nat\nhi : LT.lt i (l.splitWrtComposition c).length\n⊢ Eq (GetElem.getElem (l.splitWrtComposition c) i ⋯) (List.drop (c.sizeUpTo i) (List.take (c.sizeUpTo (HAdd.hAdd i 1)) l))","decl":"/-- The `i`-th sublist in the splitting of a list `l` along a composition `c`, is the slice of `l`\nbetween the indices `c.sizeUpTo i` and `c.sizeUpTo (i+1)`, i.e., the indices in the `i`-th\nblock of the composition. -/\ntheorem getElem_splitWrtComposition' (l : List α) (c : Composition n) {i : ℕ}\n    (hi : i < (l.splitWrtComposition c).length) :\n    (l.splitWrtComposition c)[i] = (l.take (c.sizeUpTo (i + 1))).drop (c.sizeUpTo i) :=\n  getElem_splitWrtCompositionAux _ _ hi\n\n"}
{"name":"List.getElem_splitWrtComposition","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nα : Type u_1\nl : List α\nc : Composition n\ni : Nat\nh : LT.lt i (l.splitWrtComposition c).length\n⊢ Eq (GetElem.getElem (l.splitWrtComposition c) i ⋯) (List.drop (c.sizeUpTo i) (List.take (c.sizeUpTo (HAdd.hAdd i 1)) l))","decl":"theorem getElem_splitWrtComposition (l : List α) (c : Composition n)\n    (i : Nat) (h : i < (l.splitWrtComposition c).length) :\n    (l.splitWrtComposition c)[i] = (l.take (c.sizeUpTo (i + 1))).drop (c.sizeUpTo i) :=\n  getElem_splitWrtComposition' _ _ h\n\n"}
{"name":"List.flatten_splitWrtCompositionAux","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"α : Type u_1\nns : List Nat\nl : List α\na✝ : Eq ns.sum l.length\n⊢ Eq (l.splitWrtCompositionAux ns).flatten l","decl":"theorem flatten_splitWrtCompositionAux {ns : List ℕ} :\n    ∀ {l : List α}, ns.sum = l.length → (l.splitWrtCompositionAux ns).flatten = l := by\n  induction' ns with n ns IH <;> intro l h <;> simp at h\n  · exact (length_eq_zero.1 h.symm).symm\n  simp only [splitWrtCompositionAux_cons]; dsimp\n  rw [IH]\n  · simp\n  · rw [length_drop, ← h, add_tsub_cancel_left]\n\n"}
{"name":"List.join_splitWrtCompositionAux","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"α : Type u_1\nns : List Nat\nl : List α\na✝ : Eq ns.sum l.length\n⊢ Eq (l.splitWrtCompositionAux ns).flatten l","decl":"@[deprecated (since := \"2024-10-15\")]\nalias join_splitWrtCompositionAux := flatten_splitWrtCompositionAux\n\n"}
{"name":"List.flatten_splitWrtComposition","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"α : Type u_1\nl : List α\nc : Composition l.length\n⊢ Eq (l.splitWrtComposition c).flatten l","decl":"/-- If one splits a list along a composition, and then flattens the sublists, one gets back the\noriginal list. -/\n@[simp]\ntheorem flatten_splitWrtComposition (l : List α) (c : Composition l.length) :\n    (l.splitWrtComposition c).flatten = l :=\n  flatten_splitWrtCompositionAux c.blocks_sum\n\n"}
{"name":"List.join_splitWrtComposition","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"α : Type u_1\nl : List α\nc : Composition l.length\n⊢ Eq (l.splitWrtComposition c).flatten l","decl":"@[deprecated (since := \"2024-10-15\")] alias join_splitWrtComposition := flatten_splitWrtComposition\n\n"}
{"name":"List.splitWrtComposition_flatten","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"α : Type u_1\nL : List (List α)\nc : Composition L.flatten.length\nh : Eq (List.map List.length L) c.blocks\n⊢ Eq (L.flatten.splitWrtComposition c) L","decl":"/-- If one joins a list of lists and then splits the flattening along the right composition,\none gets back the original list of lists. -/\n@[simp]\ntheorem splitWrtComposition_flatten (L : List (List α)) (c : Composition L.flatten.length)\n    (h : map length L = c.blocks) : splitWrtComposition (flatten L) c = L := by\n  simp only [eq_self_iff_true, and_self_iff, eq_iff_flatten_eq, flatten_splitWrtComposition,\n    map_length_splitWrtComposition, h]\n\n"}
{"name":"List.splitWrtComposition_join","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"α : Type u_1\nL : List (List α)\nc : Composition L.flatten.length\nh : Eq (List.map List.length L) c.blocks\n⊢ Eq (L.flatten.splitWrtComposition c) L","decl":"@[deprecated (since := \"2024-10-15\")]\nalias splitWrtComposition_join := splitWrtComposition_flatten\n\n"}
{"name":"compositionAsSet_card","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\n⊢ Eq (Fintype.card (CompositionAsSet n)) (HPow.hPow 2 (HSub.hSub n 1))","decl":"theorem compositionAsSet_card (n : ℕ) : Fintype.card (CompositionAsSet n) = 2 ^ (n - 1) := by\n  have : Fintype.card (Finset (Fin (n - 1))) = 2 ^ (n - 1) := by simp\n  rw [← this]\n  exact Fintype.card_congr (compositionAsSetEquiv n)\n\n"}
{"name":"CompositionAsSet.boundaries_nonempty","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\n⊢ c.boundaries.Nonempty","decl":"theorem boundaries_nonempty : c.boundaries.Nonempty :=\n  ⟨0, c.zero_mem⟩\n\n"}
{"name":"CompositionAsSet.card_boundaries_pos","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\n⊢ LT.lt 0 c.boundaries.card","decl":"theorem card_boundaries_pos : 0 < Finset.card c.boundaries :=\n  Finset.card_pos.mpr c.boundaries_nonempty\n\n"}
{"name":"CompositionAsSet.card_boundaries_eq_succ_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\n⊢ Eq c.boundaries.card (HAdd.hAdd c.length 1)","decl":"theorem card_boundaries_eq_succ_length : c.boundaries.card = c.length + 1 :=\n  (tsub_eq_iff_eq_add_of_le (Nat.succ_le_of_lt c.card_boundaries_pos)).mp rfl\n\n"}
{"name":"CompositionAsSet.length_lt_card_boundaries","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\n⊢ LT.lt c.length c.boundaries.card","decl":"theorem length_lt_card_boundaries : c.length < c.boundaries.card := by\n  rw [c.card_boundaries_eq_succ_length]\n  exact Nat.lt_add_one _\n\n"}
{"name":"CompositionAsSet.lt_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\ni : Fin c.length\n⊢ LT.lt (HAdd.hAdd (↑i) 1) c.boundaries.card","decl":"theorem lt_length (i : Fin c.length) : (i : ℕ) + 1 < c.boundaries.card :=\n  lt_tsub_iff_right.mp i.2\n\n"}
{"name":"CompositionAsSet.lt_length'","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\ni : Fin c.length\n⊢ LT.lt (↑i) c.boundaries.card","decl":"theorem lt_length' (i : Fin c.length) : (i : ℕ) < c.boundaries.card :=\n  lt_of_le_of_lt (Nat.le_succ i) (c.lt_length i)\n\n"}
{"name":"CompositionAsSet.boundary_zero","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\n⊢ Eq (c.boundary ⟨0, ⋯⟩) 0","decl":"@[simp]\ntheorem boundary_zero : (c.boundary ⟨0, c.card_boundaries_pos⟩ : Fin (n + 1)) = 0 := by\n  rw [boundary, Finset.orderEmbOfFin_zero rfl c.card_boundaries_pos]\n  exact le_antisymm (Finset.min'_le _ _ c.zero_mem) (Fin.zero_le _)\n\n"}
{"name":"CompositionAsSet.boundary_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\n⊢ Eq (c.boundary ⟨c.length, ⋯⟩) (Fin.last n)","decl":"@[simp]\ntheorem boundary_length : c.boundary ⟨c.length, c.length_lt_card_boundaries⟩ = Fin.last n := by\n  convert Finset.orderEmbOfFin_last rfl c.card_boundaries_pos\n  exact le_antisymm (Finset.le_max' _ _ c.getLast_mem) (Fin.le_last _)\n\n"}
{"name":"CompositionAsSet.blocksFun_pos","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\ni : Fin c.length\n⊢ LT.lt 0 (c.blocksFun i)","decl":"theorem blocksFun_pos (i : Fin c.length) : 0 < c.blocksFun i :=\n  haveI : (⟨i, c.lt_length' i⟩ : Fin c.boundaries.card) < ⟨i + 1, c.lt_length i⟩ :=\n    Nat.lt_succ_self _\n  lt_tsub_iff_left.mpr ((c.boundaries.orderEmbOfFin rfl).strictMono this)\n\n"}
{"name":"CompositionAsSet.blocks_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\n⊢ Eq c.blocks.length c.length","decl":"@[simp]\ntheorem blocks_length : c.blocks.length = c.length :=\n  length_ofFn _\n\n"}
{"name":"CompositionAsSet.blocks_partial_sum","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\ni : Nat\nh : LT.lt i c.boundaries.card\n⊢ Eq (List.take i c.blocks).sum ↑(c.boundary ⟨i, h⟩)","decl":"theorem blocks_partial_sum {i : ℕ} (h : i < c.boundaries.card) :\n    (c.blocks.take i).sum = c.boundary ⟨i, h⟩ := by\n  induction' i with i IH\n  · simp\n  have A : i < c.blocks.length := by\n    rw [c.card_boundaries_eq_succ_length] at h\n    simp [blocks, Nat.lt_of_succ_lt_succ h]\n  have B : i < c.boundaries.card := lt_of_lt_of_le A (by simp [blocks, length, Nat.sub_le])\n  rw [sum_take_succ _ _ A, IH B]\n  simp [blocks, blocksFun, get_ofFn]\n\n"}
{"name":"CompositionAsSet.mem_boundaries_iff_exists_blocks_sum_take_eq","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\nj : Fin (HAdd.hAdd n 1)\n⊢ Iff (Membership.mem c.boundaries j) (Exists fun i => And (LT.lt i c.boundaries.card) (Eq (List.take i c.blocks).sum ↑j))","decl":"theorem mem_boundaries_iff_exists_blocks_sum_take_eq {j : Fin (n + 1)} :\n    j ∈ c.boundaries ↔ ∃ i < c.boundaries.card, (c.blocks.take i).sum = j := by\n  constructor\n  · intro hj\n    rcases (c.boundaries.orderIsoOfFin rfl).surjective ⟨j, hj⟩ with ⟨i, hi⟩\n    rw [Subtype.ext_iff, Subtype.coe_mk] at hi\n    refine ⟨i.1, i.2, ?_⟩\n    dsimp at hi\n    rw [← hi, c.blocks_partial_sum i.2]\n    rfl\n  · rintro ⟨i, hi, H⟩\n    convert (c.boundaries.orderIsoOfFin rfl ⟨i, hi⟩).2\n    have : c.boundary ⟨i, hi⟩ = j := by rwa [Fin.ext_iff, ← c.blocks_partial_sum hi]\n    exact this.symm\n\n"}
{"name":"CompositionAsSet.blocks_sum","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\n⊢ Eq c.blocks.sum n","decl":"theorem blocks_sum : c.blocks.sum = n := by\n  have : c.blocks.take c.length = c.blocks := take_of_length_le (by simp [blocks])\n  rw [← this, c.blocks_partial_sum c.length_lt_card_boundaries, c.boundary_length]\n  rfl\n\n"}
{"name":"Composition.toCompositionAsSet_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Eq c.toCompositionAsSet.length c.length","decl":"@[simp]\ntheorem Composition.toCompositionAsSet_length (c : Composition n) :\n    c.toCompositionAsSet.length = c.length := by\n  simp [Composition.toCompositionAsSet, CompositionAsSet.length, c.card_boundaries_eq_succ_length]\n\n"}
{"name":"CompositionAsSet.toComposition_length","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\n⊢ Eq c.toComposition.length c.length","decl":"@[simp]\ntheorem CompositionAsSet.toComposition_length (c : CompositionAsSet n) :\n    c.toComposition.length = c.length := by\n  simp [CompositionAsSet.toComposition, Composition.length, Composition.blocks]\n\n"}
{"name":"Composition.toCompositionAsSet_blocks","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Eq c.toCompositionAsSet.blocks c.blocks","decl":"@[simp]\ntheorem Composition.toCompositionAsSet_blocks (c : Composition n) :\n    c.toCompositionAsSet.blocks = c.blocks := by\n  let d := c.toCompositionAsSet\n  change d.blocks = c.blocks\n  have length_eq : d.blocks.length = c.blocks.length := by simp [d, blocks_length]\n  suffices H : ∀ i ≤ d.blocks.length, (d.blocks.take i).sum = (c.blocks.take i).sum from\n    eq_of_sum_take_eq length_eq H\n  intro i hi\n  have i_lt : i < d.boundaries.card := by\n    simpa [CompositionAsSet.blocks, length_ofFn,\n      d.card_boundaries_eq_succ_length] using Nat.lt_succ_iff.2 hi\n  have i_lt' : i < c.boundaries.card := i_lt\n  have i_lt'' : i < c.length + 1 := by rwa [c.card_boundaries_eq_succ_length] at i_lt'\n  have A :\n    d.boundaries.orderEmbOfFin rfl ⟨i, i_lt⟩ =\n      c.boundaries.orderEmbOfFin c.card_boundaries_eq_succ_length ⟨i, i_lt''⟩ :=\n    rfl\n  have B : c.sizeUpTo i = c.boundary ⟨i, i_lt''⟩ := rfl\n  rw [d.blocks_partial_sum i_lt, CompositionAsSet.boundary, ← Composition.sizeUpTo, B, A,\n    c.orderEmbOfFin_boundaries]\n\n"}
{"name":"CompositionAsSet.toComposition_blocks","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\n⊢ Eq c.toComposition.blocks c.blocks","decl":"@[simp]\ntheorem CompositionAsSet.toComposition_blocks (c : CompositionAsSet n) :\n    c.toComposition.blocks = c.blocks :=\n  rfl\n\n"}
{"name":"CompositionAsSet.toComposition_boundaries","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : CompositionAsSet n\n⊢ Eq c.toComposition.boundaries c.boundaries","decl":"@[simp]\ntheorem CompositionAsSet.toComposition_boundaries (c : CompositionAsSet n) :\n    c.toComposition.boundaries = c.boundaries := by\n  ext j\n  simp only [c.mem_boundaries_iff_exists_blocks_sum_take_eq, Composition.boundaries, Finset.mem_map]\n  constructor\n  · rintro ⟨i, _, hi⟩\n    refine ⟨i.1, ?_, ?_⟩\n    · simpa [c.card_boundaries_eq_succ_length] using i.2\n    · simp [Composition.boundary, Composition.sizeUpTo, ← hi]\n  · rintro ⟨i, i_lt, hi⟩\n    refine ⟨i, by simp, ?_⟩\n    rw [c.card_boundaries_eq_succ_length] at i_lt\n    simp [Composition.boundary, Nat.mod_eq_of_lt i_lt, Composition.sizeUpTo, hi]\n\n"}
{"name":"Composition.toCompositionAsSet_boundaries","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\nc : Composition n\n⊢ Eq c.toCompositionAsSet.boundaries c.boundaries","decl":"@[simp]\ntheorem Composition.toCompositionAsSet_boundaries (c : Composition n) :\n    c.toCompositionAsSet.boundaries = c.boundaries :=\n  rfl\n\n"}
{"name":"composition_card","module":"Mathlib.Combinatorics.Enumerative.Composition","initialProofState":"n : Nat\n⊢ Eq (Fintype.card (Composition n)) (HPow.hPow 2 (HSub.hSub n 1))","decl":"theorem composition_card (n : ℕ) : Fintype.card (Composition n) = 2 ^ (n - 1) := by\n  rw [← compositionAsSet_card n]\n  exact Fintype.card_congr (compositionEquiv n)\n"}
