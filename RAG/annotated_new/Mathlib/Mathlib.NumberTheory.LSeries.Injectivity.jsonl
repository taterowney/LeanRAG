{"name":"LSeries.abscissaOfAbsConv_add_le","module":"Mathlib.NumberTheory.LSeries.Injectivity","initialProofState":"f g : Nat → Complex\n⊢ LE.le (LSeries.abscissaOfAbsConv (HAdd.hAdd f g)) (Max.max (LSeries.abscissaOfAbsConv f) (LSeries.abscissaOfAbsConv g))","decl":"/-- The abscissa of absolute convergence of `f + g` is at most the maximum of those\nof `f` and `g`. -/\nlemma LSeries.abscissaOfAbsConv_add_le (f g : ℕ → ℂ) :\n    abscissaOfAbsConv (f + g) ≤ max (abscissaOfAbsConv f) (abscissaOfAbsConv g) :=\n  abscissaOfAbsConv_binop_le LSeriesSummable.add f g\n\n"}
{"name":"LSeries.abscissaOfAbsConv_sub_le","module":"Mathlib.NumberTheory.LSeries.Injectivity","initialProofState":"f g : Nat → Complex\n⊢ LE.le (LSeries.abscissaOfAbsConv (HSub.hSub f g)) (Max.max (LSeries.abscissaOfAbsConv f) (LSeries.abscissaOfAbsConv g))","decl":"/-- The abscissa of absolute convergence of `f - g` is at most the maximum of those\nof `f` and `g`. -/\nlemma LSeries.abscissaOfAbsConv_sub_le (f g : ℕ → ℂ) :\n    abscissaOfAbsConv (f - g) ≤ max (abscissaOfAbsConv f) (abscissaOfAbsConv g) :=\n  abscissaOfAbsConv_binop_le LSeriesSummable.sub f g\n\n"}
{"name":"LSeries.tendsto_cpow_mul_atTop","module":"Mathlib.NumberTheory.LSeries.Injectivity","initialProofState":"f : Nat → Complex\nn : Nat\nh : ∀ (m : Nat), LE.le m n → Eq (f m) 0\nha : LT.lt (LSeries.abscissaOfAbsConv f) Top.top\n⊢ Filter.Tendsto (fun x => HMul.hMul (HPow.hPow (HAdd.hAdd (↑n) 1) ↑x) (LSeries f ↑x)) Filter.atTop (nhds (f (HAdd.hAdd n 1)))","decl":"open Filter Real in\n/-- If the coefficients `f m` of an L-series are zero for `m ≤ n` and the L-series converges\nat some point, then `f (n+1)` is the limit of `(n+1)^x * LSeries f x` as `x → ∞`. -/\nlemma LSeries.tendsto_cpow_mul_atTop {f : ℕ → ℂ} {n : ℕ} (h : ∀ m ≤ n, f m = 0)\n    (ha : abscissaOfAbsConv f < ⊤):\n    Tendsto (fun x : ℝ ↦ (n + 1) ^ (x : ℂ) * LSeries f x) atTop (nhds (f (n + 1))) := by\n  obtain ⟨y, hay, hyt⟩ := exists_between ha\n  lift y to ℝ using ⟨hyt.ne, ((OrderBot.bot_le _).trans_lt hay).ne'⟩\n  -- `F x m` is the `m`th term of `(n+1)^x * LSeries f x`, except that `F x (n+1) = 0`\n  let F := fun (x : ℝ) ↦ {m | n + 1 < m}.indicator (fun m ↦ f m / (m / (n + 1) : ℂ) ^ (x : ℂ))\n  have hF₀ (x : ℝ) {m : ℕ} (hm : m ≤ n + 1) : F x m = 0 := by simp [F, not_lt_of_le hm]\n  have hF (x : ℝ) {m : ℕ} (hm : m ≠ n + 1) : F x m = ((n + 1) ^ (x : ℂ)) * term f x m := by\n    rcases lt_trichotomy m (n + 1) with H | rfl | H\n    · simp [Nat.not_lt_of_gt H, term, h m <| Nat.lt_succ_iff.mp H, F]\n    · exact (hm rfl).elim\n    · simp [H, term, (n.zero_lt_succ.trans H).ne', F, cpow_mul_div_cpow_eq_div_div_cpow]\n  have hs {x : ℝ} (hx : x ≥ y) : Summable fun m ↦ (n + 1) ^ (x : ℂ) * term f x m := by\n    refine (summable_mul_left_iff <| natCast_add_one_cpow_ne_zero n _).mpr <|\n       LSeriesSummable_of_abscissaOfAbsConv_lt_re ?_\n    simpa only [ofReal_re] using hay.trans_le <| EReal.coe_le_coe_iff.mpr hx\n  -- we can write `(n+1)^x * LSeries f x` as `f (n+1)` plus the series over `F x`\n  have key : ∀ x ≥ y, (n + 1) ^ (x : ℂ) * LSeries f x = f (n + 1) + ∑' m : ℕ, F x m := by\n    intro x hx\n    rw [LSeries, ← tsum_mul_left, tsum_eq_add_tsum_ite (hs hx) (n + 1), pow_mul_term_eq f x n]\n    congr\n    ext1 m\n    rcases eq_or_ne m (n + 1) with rfl | hm\n    · simp [hF₀ x le_rfl]\n    · simp [hm, hF]\n  -- reduce to showing that `∑' m, F x m → 0` as `x → ∞`\n  conv => enter [3, 1]; rw [← add_zero (f _)]\n  refine Tendsto.congr'\n    (eventuallyEq_of_mem (s := {x | y ≤ x}) (mem_atTop y) key).symm <| tendsto_const_nhds.add ?_\n  -- get the prerequisites for applying dominated convergence\n  have hys : Summable (F y) := by\n    refine ((hs le_rfl).indicator {m | n + 1 < m}).congr fun m ↦ ?_\n    by_cases hm : n + 1 < m\n    · simp [hF, hm, hm.ne']\n    · simp [hm, hF₀ _ (le_of_not_lt hm)]\n  have hc (k : ℕ) : Tendsto (F · k) atTop (nhds 0) := by\n    rcases lt_or_le (n + 1) k with H | H\n    · have H₀ : (0 : ℝ) ≤ k / (n + 1) := by positivity\n      have H₀' : (0 : ℝ) ≤ (n + 1) / k := by positivity\n      have H₁ : (k / (n + 1) : ℂ) = (k / (n + 1) : ℝ) := by push_cast; rfl\n      have H₂ : (n + 1) / k < (1 : ℝ) :=\n        (div_lt_one <| mod_cast n.succ_pos.trans H).mpr <| mod_cast H\n      simp only [Set.mem_setOf_eq, H, Set.indicator_of_mem, F]\n      conv =>\n        enter [1, x]\n        rw [div_eq_mul_inv, H₁, ← ofReal_cpow H₀, ← ofReal_inv, ← Real.inv_rpow H₀, inv_div]\n      conv => enter [3, 1]; rw [← mul_zero (f k)]\n      exact\n        (tendsto_rpow_atTop_of_base_lt_one _ (neg_one_lt_zero.trans_le H₀') H₂).ofReal.const_mul _\n    · simp [hF₀ _ H]\n  rw [show (0 : ℂ) = tsum (fun _ : ℕ ↦ 0) from tsum_zero.symm]\n  refine tendsto_tsum_of_dominated_convergence hys.norm hc <| eventually_iff.mpr ?_\n  filter_upwards [mem_atTop y] with y' hy' k\n  -- it remains to show that `‖F y' k‖ ≤ ‖F y k‖` (for `y' ≥ y`)\n  rcases lt_or_le (n + 1) k with H | H\n  · simp only [Set.mem_setOf_eq, H, Set.indicator_of_mem, norm_div, Complex.norm_eq_abs,\n      abs_cpow_real, map_div₀, abs_natCast, F]\n    rw [← Nat.cast_one, ← Nat.cast_add, abs_natCast]\n    have hkn : 1 ≤ (k / (n + 1 :) : ℝ) :=\n      (one_le_div (by positivity)).mpr <| mod_cast Nat.le_of_succ_le H\n    exact div_le_div_of_nonneg_left (Complex.abs.nonneg _)\n      (rpow_pos_of_pos (zero_lt_one.trans_le hkn) _) <| rpow_le_rpow_of_exponent_le hkn hy'\n  · simp [hF₀ _ H]\n\n"}
{"name":"LSeries.tendsto_atTop","module":"Mathlib.NumberTheory.LSeries.Injectivity","initialProofState":"f : Nat → Complex\nha : LT.lt (LSeries.abscissaOfAbsConv f) Top.top\n⊢ Filter.Tendsto (fun x => LSeries f ↑x) Filter.atTop (nhds (f 1))","decl":"open Filter in\n/-- If the L-series of `f` converges at some point, then `f 1` is the limit of `LSeries f x`\nas `x → ∞`. -/\nlemma LSeries.tendsto_atTop {f : ℕ → ℂ} (ha : abscissaOfAbsConv f < ⊤):\n    Tendsto (fun x : ℝ ↦ LSeries f x) atTop (nhds (f 1)) := by\n  let F (n : ℕ) : ℂ := if n = 0 then 0 else f n\n  have hF₀ : F 0 = 0 := rfl\n  have hF {n : ℕ} (hn : n ≠ 0) : F n = f n := if_neg hn\n  have ha' : abscissaOfAbsConv F < ⊤ := (abscissaOfAbsConv_congr hF).symm ▸ ha\n  simp_rw [← LSeries_congr _ hF]\n  convert LSeries.tendsto_cpow_mul_atTop (n := 0) (fun _ hm ↦ Nat.le_zero.mp hm ▸ hF₀) ha' using 1\n  simp\n\n"}
{"name":"LSeries_eq_zero_of_abscissaOfAbsConv_eq_top","module":"Mathlib.NumberTheory.LSeries.Injectivity","initialProofState":"f : Nat → Complex\nh : Eq (LSeries.abscissaOfAbsConv f) Top.top\n⊢ Eq (LSeries f) 0","decl":"lemma LSeries_eq_zero_of_abscissaOfAbsConv_eq_top {f : ℕ → ℂ} (h : abscissaOfAbsConv f = ⊤) :\n    LSeries f = 0 := by\n  ext1 s\n  exact LSeries.eq_zero_of_not_LSeriesSummable f s <| mt LSeriesSummable.abscissaOfAbsConv_le <|\n    h ▸ fun H ↦ (H.trans_lt <| EReal.coe_lt_top _).false\n\n"}
{"name":"LSeries_eventually_eq_zero_iff'","module":"Mathlib.NumberTheory.LSeries.Injectivity","initialProofState":"f : Nat → Complex\n⊢ Iff (Filter.atTop.EventuallyEq (fun x => LSeries f ↑x) 0) (Or (∀ (n : Nat), Ne n 0 → Eq (f n) 0) (Eq (LSeries.abscissaOfAbsConv f) Top.top))","decl":"open Filter Nat in\n/-- The `LSeries` of `f` is zero for large real arguments if and only if either `f n = 0`\nfor all `n ≠ 0` or the L-series converges nowhere. -/\nlemma LSeries_eventually_eq_zero_iff' {f : ℕ → ℂ} :\n    (fun x : ℝ ↦ LSeries f x) =ᶠ[atTop] 0 ↔ (∀ n ≠ 0, f n = 0) ∨ abscissaOfAbsConv f = ⊤ := by\n  by_cases h : abscissaOfAbsConv f = ⊤ <;> simp [h]\n  · exact Eventually.of_forall <| by simp [LSeries_eq_zero_of_abscissaOfAbsConv_eq_top h]\n  · refine ⟨fun H ↦ ?_, fun H ↦ Eventually.of_forall fun x ↦ ?_⟩\n    · let F (n : ℕ) : ℂ := if n = 0 then 0 else f n\n      have hF₀ : F 0 = 0 := rfl\n      have hF {n : ℕ} (hn : n ≠ 0) : F n = f n := if_neg hn\n      suffices ∀ n, F n = 0 from fun n hn ↦ (hF hn).symm.trans (this n)\n      have ha : ¬ abscissaOfAbsConv F = ⊤ := abscissaOfAbsConv_congr hF ▸ h\n      have h' (x : ℝ) : LSeries F x = LSeries f x := LSeries_congr x hF\n      have H' (n : ℕ) : (fun x : ℝ ↦ n ^ (x : ℂ) * LSeries F x) =ᶠ[atTop] fun _ ↦ 0 := by\n        simp only [h']\n        rw [eventuallyEq_iff_exists_mem] at H ⊢\n        obtain ⟨s, hs⟩ := H\n        exact ⟨s, hs.1, fun x hx ↦ by simp [hs.2 hx]⟩\n      intro n\n      induction' n using Nat.strongRecOn with n ih\n      -- it suffices to show that `n ^ x * LSeries F x` tends to `F n` as `x` tends to `∞`\n      suffices Tendsto (fun x : ℝ ↦ n ^ (x : ℂ) * LSeries F x) atTop (nhds (F n)) by\n        replace this := this.congr' <| H' n\n        simp only [tendsto_const_nhds_iff] at this\n        exact this.symm\n      cases n with\n      | zero => exact Tendsto.congr' (H' 0).symm <| by simp [hF₀]\n      | succ n =>\n          simpa using LSeries.tendsto_cpow_mul_atTop (fun m hm ↦ ih m <| lt_succ_of_le hm) <|\n            Ne.lt_top ha\n    · simp [LSeries_congr x fun {n} ↦ H n, show (fun _ : ℕ ↦ (0 : ℂ)) = 0 from rfl]\n\n"}
{"name":"LSeries_eq_zero_iff","module":"Mathlib.NumberTheory.LSeries.Injectivity","initialProofState":"f : Nat → Complex\nhf : Eq (f 0) 0\n⊢ Iff (Eq (LSeries f) 0) (Or (Eq f 0) (Eq (LSeries.abscissaOfAbsConv f) Top.top))","decl":"open Nat in\n/-- Assuming `f 0 = 0`, the `LSeries` of `f` is zero if and only if either `f = 0` or the\nL-series converges nowhere. -/\nlemma LSeries_eq_zero_iff {f : ℕ → ℂ} (hf : f 0 = 0) :\n    LSeries f = 0 ↔ f = 0 ∨ abscissaOfAbsConv f = ⊤ := by\n  by_cases h : abscissaOfAbsConv f = ⊤ <;> simp [h]\n  · exact LSeries_eq_zero_of_abscissaOfAbsConv_eq_top h\n  · refine ⟨fun H ↦ ?_, fun H ↦ H ▸ LSeries_zero⟩\n    convert (LSeries_eventually_eq_zero_iff'.mp ?_).resolve_right h\n    · refine ⟨fun H' _ _ ↦ by rw [H', Pi.zero_apply], fun H' ↦ ?_⟩\n      ext (- | m)\n      · simp [hf]\n      · simp [H']\n    · simpa only [H] using Filter.EventuallyEq.rfl\n\n"}
{"name":"LSeries_sub_eventuallyEq_zero_of_LSeries_eventually_eq","module":"Mathlib.NumberTheory.LSeries.Injectivity","initialProofState":"f g : Nat → Complex\nhf : LT.lt (LSeries.abscissaOfAbsConv f) Top.top\nhg : LT.lt (LSeries.abscissaOfAbsConv g) Top.top\nh : Filter.atTop.EventuallyEq (fun x => LSeries f ↑x) fun x => LSeries g ↑x\n⊢ Filter.atTop.EventuallyEq (fun x => LSeries (HSub.hSub f g) ↑x) 0","decl":"open Filter in\n/-- If the `LSeries` of `f` and of `g` converge somewhere and agree on large real arguments,\nthen the L-series of `f - g` is zero for large real arguments. -/\nlemma LSeries_sub_eventuallyEq_zero_of_LSeries_eventually_eq {f g : ℕ → ℂ}\n    (hf : abscissaOfAbsConv f < ⊤) (hg : abscissaOfAbsConv g < ⊤)\n    (h : (fun x : ℝ ↦ LSeries f x) =ᶠ[atTop] fun x ↦ LSeries g x) :\n    (fun x : ℝ ↦ LSeries (f - g) x) =ᶠ[atTop] (0 : ℝ → ℂ) := by\n  rw [EventuallyEq, eventually_atTop] at h ⊢\n  obtain ⟨x₀, hx₀⟩ := h\n  obtain ⟨yf, hyf₁, hyf₂⟩ := exists_between hf\n  obtain ⟨yg, hyg₁, hyg₂⟩ := exists_between hg\n  lift yf to ℝ using ⟨hyf₂.ne, ((OrderBot.bot_le _).trans_lt hyf₁).ne'⟩\n  lift yg to ℝ using ⟨hyg₂.ne, ((OrderBot.bot_le _).trans_lt hyg₁).ne'⟩\n  refine ⟨max x₀ (max yf yg), fun x hx ↦ ?_⟩\n  have Hf : LSeriesSummable f x := by\n    refine LSeriesSummable_of_abscissaOfAbsConv_lt_re <|\n      (ofReal_re x).symm ▸ hyf₁.trans_le (EReal.coe_le_coe_iff.mpr ?_)\n    exact (le_max_left _ yg).trans <| (le_max_right x₀ _).trans hx\n  have Hg : LSeriesSummable g x := by\n    refine LSeriesSummable_of_abscissaOfAbsConv_lt_re <|\n      (ofReal_re x).symm ▸ hyg₁.trans_le (EReal.coe_le_coe_iff.mpr ?_)\n    exact (le_max_right yf _).trans <| (le_max_right x₀ _).trans hx\n  rw [LSeries_sub Hf Hg, hx₀ x <| (le_max_left ..).trans hx, sub_self, Pi.zero_apply]\n\n"}
{"name":"LSeries.eq_of_LSeries_eventually_eq","module":"Mathlib.NumberTheory.LSeries.Injectivity","initialProofState":"f g : Nat → Complex\nhf : LT.lt (LSeries.abscissaOfAbsConv f) Top.top\nhg : LT.lt (LSeries.abscissaOfAbsConv g) Top.top\nh : Filter.atTop.EventuallyEq (fun x => LSeries f ↑x) fun x => LSeries g ↑x\nn : Nat\nhn : Ne n 0\n⊢ Eq (f n) (g n)","decl":"open Filter in\n/-- If the `LSeries` of `f` and of `g` converge somewhere and agree on large real arguments,\nthen `f n = g n` whenever `n ≠ 0`. -/\nlemma LSeries.eq_of_LSeries_eventually_eq {f g : ℕ → ℂ} (hf : abscissaOfAbsConv f < ⊤)\n    (hg : abscissaOfAbsConv g < ⊤) (h : (fun x : ℝ ↦ LSeries f x) =ᶠ[atTop] fun x ↦ LSeries g x)\n    {n : ℕ} (hn : n ≠ 0) :\n    f n = g n := by\n  have hsub : (fun x : ℝ ↦ LSeries (f - g) x) =ᶠ[atTop] (0 : ℝ → ℂ) :=\n    LSeries_sub_eventuallyEq_zero_of_LSeries_eventually_eq hf hg h\n  have ha : abscissaOfAbsConv (f - g) ≠ ⊤ :=\n    lt_top_iff_ne_top.mp <| (abscissaOfAbsConv_sub_le f g).trans_lt <| max_lt hf hg\n  simpa only [Pi.sub_apply, sub_eq_zero]\n    using (LSeries_eventually_eq_zero_iff'.mp hsub).resolve_right ha n hn\n\n"}
{"name":"LSeries_eq_iff_of_abscissaOfAbsConv_lt_top","module":"Mathlib.NumberTheory.LSeries.Injectivity","initialProofState":"f g : Nat → Complex\nhf : LT.lt (LSeries.abscissaOfAbsConv f) Top.top\nhg : LT.lt (LSeries.abscissaOfAbsConv g) Top.top\n⊢ Iff (Eq (LSeries f) (LSeries g)) (∀ (n : Nat), Ne n 0 → Eq (f n) (g n))","decl":"/-- If the `LSeries` of `f` and of `g` both converge somewhere, then they are equal if and only\nif `f n = g n` whenever `n ≠ 0`. -/\nlemma LSeries_eq_iff_of_abscissaOfAbsConv_lt_top {f g : ℕ → ℂ} (hf : abscissaOfAbsConv f < ⊤)\n    (hg : abscissaOfAbsConv g < ⊤) :\n    LSeries f = LSeries g ↔ ∀ n ≠ 0, f n = g n := by\n  refine ⟨fun H n hn ↦ ?_, fun H ↦ funext (LSeries_congr · fun {n} ↦ H n)⟩\n  refine eq_of_LSeries_eventually_eq hf hg ?_ hn\n  exact Filter.Eventually.of_forall fun x ↦ congr_fun H x\n\n"}
{"name":"LSeries_injOn","module":"Mathlib.NumberTheory.LSeries.Injectivity","initialProofState":"⊢ Set.InjOn LSeries (setOf fun f => And (Eq (f 0) 0) (LT.lt (LSeries.abscissaOfAbsConv f) Top.top))","decl":"/-- The map `f ↦ LSeries f` is injective on functions `f` such that `f 0 = 0` and the L-series\nof `f` converges somewhere. -/\nlemma LSeries_injOn : Set.InjOn LSeries {f | f 0 = 0 ∧ abscissaOfAbsConv f < ⊤} := by\n  intro f hf g hg h\n  simp only [Set.mem_setOf] at hf hg\n  replace h := (LSeries_eq_iff_of_abscissaOfAbsConv_lt_top hf.2 hg.2).mp h\n  ext1 n\n  cases n with\n  | zero => exact hf.1.trans hg.1.symm\n  | succ n => exact h _ n.zero_ne_add_one.symm\n"}
