{"name":"PLift.instSubsingleton","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\ninst✝ : Subsingleton α\n⊢ Subsingleton (PLift α)","decl":"instance [Subsingleton α] : Subsingleton (PLift α) :=\n  Equiv.plift.subsingleton\n\n"}
{"name":"PLift.instNonempty","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\ninst✝ : Nonempty α\n⊢ Nonempty (PLift α)","decl":"instance [Nonempty α] : Nonempty (PLift α) :=\n  Equiv.plift.nonempty\n\n"}
{"name":"PLift.instIsEmpty","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\ninst✝ : IsEmpty α\n⊢ IsEmpty (PLift α)","decl":"instance [IsEmpty α] : IsEmpty (PLift α) :=\n  Equiv.plift.isEmpty\n\n"}
{"name":"PLift.up_injective","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\n⊢ Function.Injective PLift.up","decl":"theorem up_injective : Injective (@up α) :=\n  Equiv.plift.symm.injective\n\n"}
{"name":"PLift.up_surjective","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\n⊢ Function.Surjective PLift.up","decl":"theorem up_surjective : Surjective (@up α) :=\n  Equiv.plift.symm.surjective\n\n"}
{"name":"PLift.up_bijective","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\n⊢ Function.Bijective PLift.up","decl":"theorem up_bijective : Bijective (@up α) :=\n  Equiv.plift.symm.bijective\n\n"}
{"name":"PLift.up_inj","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\nx y : α\n⊢ Iff (Eq { down := x } { down := y }) (Eq x y)","decl":"@[simp]\ntheorem up_inj {x y : α} : up x = up y ↔ x = y :=\n  up_injective.eq_iff\n\n"}
{"name":"PLift.down_surjective","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\n⊢ Function.Surjective PLift.down","decl":"theorem down_surjective : Surjective (@down α) :=\n  Equiv.plift.surjective\n\n"}
{"name":"PLift.down_bijective","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\n⊢ Function.Bijective PLift.down","decl":"theorem down_bijective : Bijective (@down α) :=\n  Equiv.plift.bijective\n\n-- This is not a good simp lemma, as its discrimination tree key is just an arrow.\n"}
{"name":"PLift.forall","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\np : PLift α → Prop\n⊢ Iff (∀ (x : PLift α), p x) (∀ (x : α), p { down := x })","decl":"theorem «forall» {p : PLift α → Prop} : (∀ x, p x) ↔ ∀ x : α, p (PLift.up x) :=\n  up_surjective.forall\n\n"}
{"name":"PLift.exists","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\np : PLift α → Prop\n⊢ Iff (Exists fun x => p x) (Exists fun x => p { down := x })","decl":"@[simp]\ntheorem «exists» {p : PLift α → Prop} : (∃ x, p x) ↔ ∃ x : α, p (PLift.up x) :=\n  up_surjective.exists\n\n"}
{"name":"PLift.map_injective","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\n⊢ Iff (Function.Injective (PLift.map f)) (Function.Injective f)","decl":"@[simp] lemma map_injective : Injective (PLift.map f) ↔ Injective f :=\n  (Injective.of_comp_iff' _ down_bijective).trans <| up_injective.of_comp_iff _\n\n"}
{"name":"PLift.map_surjective","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\n⊢ Iff (Function.Surjective (PLift.map f)) (Function.Surjective f)","decl":"@[simp] lemma map_surjective : Surjective (PLift.map f) ↔ Surjective f :=\n  (down_surjective.of_comp_iff _).trans <| Surjective.of_comp_iff' up_bijective _\n\n"}
{"name":"PLift.map_bijective","module":"Mathlib.Data.ULift","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\n⊢ Iff (Function.Bijective (PLift.map f)) (Function.Bijective f)","decl":"@[simp] lemma map_bijective : Bijective (PLift.map f) ↔ Bijective f :=\n  (down_bijective.of_comp_iff _).trans <| Bijective.of_comp_iff' up_bijective _\n\n"}
{"name":"ULift.instSubsingleton","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\ninst✝ : Subsingleton α\n⊢ Subsingleton (ULift.{u_1, u} α)","decl":"instance [Subsingleton α] : Subsingleton (ULift α) :=\n  Equiv.ulift.subsingleton\n\n"}
{"name":"ULift.instNonempty","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Nonempty (ULift.{u_1, u} α)","decl":"instance [Nonempty α] : Nonempty (ULift α) :=\n  Equiv.ulift.nonempty\n\n"}
{"name":"ULift.instIsEmpty","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\ninst✝ : IsEmpty α\n⊢ IsEmpty (ULift.{u_1, u} α)","decl":"instance [IsEmpty α] : IsEmpty (ULift α) :=\n  Equiv.ulift.isEmpty\n\n"}
{"name":"ULift.up_injective","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\n⊢ Function.Injective ULift.up","decl":"theorem up_injective : Injective (@up α) :=\n  Equiv.ulift.symm.injective\n\n"}
{"name":"ULift.up_surjective","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\n⊢ Function.Surjective ULift.up","decl":"theorem up_surjective : Surjective (@up α) :=\n  Equiv.ulift.symm.surjective\n\n"}
{"name":"ULift.up_bijective","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\n⊢ Function.Bijective ULift.up","decl":"theorem up_bijective : Bijective (@up α) :=\n  Equiv.ulift.symm.bijective\n\n"}
{"name":"ULift.up_inj","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\nx y : α\n⊢ Iff (Eq { down := x } { down := y }) (Eq x y)","decl":"@[simp]\ntheorem up_inj {x y : α} : up x = up y ↔ x = y :=\n  up_injective.eq_iff\n\n"}
{"name":"ULift.down_surjective","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\n⊢ Function.Surjective ULift.down","decl":"theorem down_surjective : Surjective (@down α) :=\n  Equiv.ulift.surjective\n\n"}
{"name":"ULift.down_bijective","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\n⊢ Function.Bijective ULift.down","decl":"theorem down_bijective : Bijective (@down α) :=\n  Equiv.ulift.bijective\n\n"}
{"name":"ULift.forall","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\np : ULift.{u_1, u} α → Prop\n⊢ Iff (∀ (x : ULift.{u_1, u} α), p x) (∀ (x : α), p { down := x })","decl":"@[simp]\ntheorem «forall» {p : ULift α → Prop} : (∀ x, p x) ↔ ∀ x : α, p (ULift.up x) :=\n  up_surjective.forall\n\n"}
{"name":"ULift.exists","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\np : ULift.{u_1, u} α → Prop\n⊢ Iff (Exists fun x => p x) (Exists fun x => p { down := x })","decl":"@[simp]\ntheorem «exists» {p : ULift α → Prop} : (∃ x, p x) ↔ ∃ x : α, p (ULift.up x) :=\n  up_surjective.exists\n\n"}
{"name":"ULift.map_injective","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Iff (Function.Injective (ULift.map f)) (Function.Injective f)","decl":"@[simp] lemma map_injective : Injective (ULift.map f : ULift.{u'} α → ULift.{v'} β) ↔ Injective f :=\n  (Injective.of_comp_iff' _ down_bijective).trans <| up_injective.of_comp_iff _\n\n"}
{"name":"ULift.map_surjective","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Iff (Function.Surjective (ULift.map f)) (Function.Surjective f)","decl":"@[simp] lemma map_surjective :\n    Surjective (ULift.map f : ULift.{u'} α → ULift.{v'} β) ↔ Surjective f :=\n  (down_surjective.of_comp_iff _).trans <| Surjective.of_comp_iff' up_bijective _\n\n"}
{"name":"ULift.map_bijective","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Iff (Function.Bijective (ULift.map f)) (Function.Bijective f)","decl":"@[simp] lemma map_bijective : Bijective (ULift.map f : ULift.{u'} α → ULift.{v'} β) ↔ Bijective f :=\n  (down_bijective.of_comp_iff _).trans <| Bijective.of_comp_iff' up_bijective _\n\n"}
{"name":"ULift.ext","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\nx y : ULift.{u_1, u} α\nh : Eq x.down y.down\n⊢ Eq x y","decl":"@[ext]\ntheorem ext (x y : ULift α) (h : x.down = y.down) : x = y :=\n  congrArg up h\n\n"}
{"name":"ULift.ext_iff","module":"Mathlib.Data.ULift","initialProofState":"α : Type u\nx y : ULift.{u_1, u} α\n⊢ Iff (Eq x y) (Eq x.down y.down)","decl":"@[ext]\ntheorem ext (x y : ULift α) (h : x.down = y.down) : x = y :=\n  congrArg up h\n\n"}
