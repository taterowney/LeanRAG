{"name":"MeasureTheory.IsAddFundamentalDomain.ae_covers","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝² : Zero G\ninst✝¹ : VAdd G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : autoParam (MeasureTheory.Measure α) _auto✝\nself : MeasureTheory.IsAddFundamentalDomain G s μ\n⊢ Filter.Eventually (fun x => Exists fun g => Membership.mem s (HVAdd.hVAdd g x)) (MeasureTheory.ae μ)","decl":"/-- A measurable set `s` is a *fundamental domain* for an additive action of an additive group `G`\non a measurable space `α` with respect to a measure `α` if the sets `g +ᵥ s`, `g : G`, are pairwise\na.e. disjoint and cover the whole space. -/\nstructure IsAddFundamentalDomain (G : Type*) {α : Type*} [Zero G] [VAdd G α] [MeasurableSpace α]\n    (s : Set α) (μ : Measure α := by volume_tac) : Prop where\n  protected nullMeasurableSet : NullMeasurableSet s μ\n  protected ae_covers : ∀ᵐ x ∂μ, ∃ g : G, g +ᵥ x ∈ s\n  protected aedisjoint : Pairwise <| (AEDisjoint μ on fun g : G => g +ᵥ s)\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.nullMeasurableSet","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝² : Zero G\ninst✝¹ : VAdd G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : autoParam (MeasureTheory.Measure α) _auto✝\nself : MeasureTheory.IsAddFundamentalDomain G s μ\n⊢ MeasureTheory.NullMeasurableSet s μ","decl":"/-- A measurable set `s` is a *fundamental domain* for an additive action of an additive group `G`\non a measurable space `α` with respect to a measure `α` if the sets `g +ᵥ s`, `g : G`, are pairwise\na.e. disjoint and cover the whole space. -/\nstructure IsAddFundamentalDomain (G : Type*) {α : Type*} [Zero G] [VAdd G α] [MeasurableSpace α]\n    (s : Set α) (μ : Measure α := by volume_tac) : Prop where\n  protected nullMeasurableSet : NullMeasurableSet s μ\n  protected ae_covers : ∀ᵐ x ∂μ, ∃ g : G, g +ᵥ x ∈ s\n  protected aedisjoint : Pairwise <| (AEDisjoint μ on fun g : G => g +ᵥ s)\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.aedisjoint","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝² : Zero G\ninst✝¹ : VAdd G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : autoParam (MeasureTheory.Measure α) _auto✝\nself : MeasureTheory.IsAddFundamentalDomain G s μ\n⊢ Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) fun g => HVAdd.hVAdd g s)","decl":"/-- A measurable set `s` is a *fundamental domain* for an additive action of an additive group `G`\non a measurable space `α` with respect to a measure `α` if the sets `g +ᵥ s`, `g : G`, are pairwise\na.e. disjoint and cover the whole space. -/\nstructure IsAddFundamentalDomain (G : Type*) {α : Type*} [Zero G] [VAdd G α] [MeasurableSpace α]\n    (s : Set α) (μ : Measure α := by volume_tac) : Prop where\n  protected nullMeasurableSet : NullMeasurableSet s μ\n  protected ae_covers : ∀ᵐ x ∂μ, ∃ g : G, g +ᵥ x ∈ s\n  protected aedisjoint : Pairwise <| (AEDisjoint μ on fun g : G => g +ᵥ s)\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.ae_covers","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝² : One G\ninst✝¹ : SMul G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : autoParam (MeasureTheory.Measure α) _auto✝\nself : MeasureTheory.IsFundamentalDomain G s μ\n⊢ Filter.Eventually (fun x => Exists fun g => Membership.mem s (HSMul.hSMul g x)) (MeasureTheory.ae μ)","decl":"/-- A measurable set `s` is a *fundamental domain* for an action of a group `G` on a measurable\nspace `α` with respect to a measure `α` if the sets `g • s`, `g : G`, are pairwise a.e. disjoint and\ncover the whole space. -/\n@[to_additive IsAddFundamentalDomain]\nstructure IsFundamentalDomain (G : Type*) {α : Type*} [One G] [SMul G α] [MeasurableSpace α]\n    (s : Set α) (μ : Measure α := by volume_tac) : Prop where\n  protected nullMeasurableSet : NullMeasurableSet s μ\n  protected ae_covers : ∀ᵐ x ∂μ, ∃ g : G, g • x ∈ s\n  protected aedisjoint : Pairwise <| (AEDisjoint μ on fun g : G => g • s)\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.nullMeasurableSet","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝² : One G\ninst✝¹ : SMul G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : autoParam (MeasureTheory.Measure α) _auto✝\nself : MeasureTheory.IsFundamentalDomain G s μ\n⊢ MeasureTheory.NullMeasurableSet s μ","decl":"/-- A measurable set `s` is a *fundamental domain* for an action of a group `G` on a measurable\nspace `α` with respect to a measure `α` if the sets `g • s`, `g : G`, are pairwise a.e. disjoint and\ncover the whole space. -/\n@[to_additive IsAddFundamentalDomain]\nstructure IsFundamentalDomain (G : Type*) {α : Type*} [One G] [SMul G α] [MeasurableSpace α]\n    (s : Set α) (μ : Measure α := by volume_tac) : Prop where\n  protected nullMeasurableSet : NullMeasurableSet s μ\n  protected ae_covers : ∀ᵐ x ∂μ, ∃ g : G, g • x ∈ s\n  protected aedisjoint : Pairwise <| (AEDisjoint μ on fun g : G => g • s)\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.aedisjoint","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝² : One G\ninst✝¹ : SMul G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : autoParam (MeasureTheory.Measure α) _auto✝\nself : MeasureTheory.IsFundamentalDomain G s μ\n⊢ Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) fun g => HSMul.hSMul g s)","decl":"/-- A measurable set `s` is a *fundamental domain* for an action of a group `G` on a measurable\nspace `α` with respect to a measure `α` if the sets `g • s`, `g : G`, are pairwise a.e. disjoint and\ncover the whole space. -/\n@[to_additive IsAddFundamentalDomain]\nstructure IsFundamentalDomain (G : Type*) {α : Type*} [One G] [SMul G α] [MeasurableSpace α]\n    (s : Set α) (μ : Measure α := by volume_tac) : Prop where\n  protected nullMeasurableSet : NullMeasurableSet s μ\n  protected ae_covers : ∀ᵐ x ∂μ, ∃ g : G, g • x ∈ s\n  protected aedisjoint : Pairwise <| (AEDisjoint μ on fun g : G => g • s)\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.mk'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\nh_meas : MeasureTheory.NullMeasurableSet s μ\nh_exists : ∀ (x : α), ExistsUnique fun g => Membership.mem s (HVAdd.hVAdd g x)\n⊢ MeasureTheory.IsAddFundamentalDomain G s μ","decl":"/-- If for each `x : α`, exactly one of `g • x`, `g : G`, belongs to a measurable set `s`, then `s`\nis a fundamental domain for the action of `G` on `α`. -/\n@[to_additive \"If for each `x : α`, exactly one of `g +ᵥ x`, `g : G`, belongs to a measurable set\n`s`, then `s` is a fundamental domain for the additive action of `G` on `α`.\"]\ntheorem mk' (h_meas : NullMeasurableSet s μ) (h_exists : ∀ x : α, ∃! g : G, g • x ∈ s) :\n    IsFundamentalDomain G s μ where\n  nullMeasurableSet := h_meas\n  ae_covers := Eventually.of_forall fun x => (h_exists x).exists\n  aedisjoint a b hab := Disjoint.aedisjoint <| disjoint_left.2 fun x hxa hxb => by\n    rw [mem_smul_set_iff_inv_smul_mem] at hxa hxb\n    exact hab (inv_injective <| (h_exists x).unique hxa hxb)\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.mk'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\nh_meas : MeasureTheory.NullMeasurableSet s μ\nh_exists : ∀ (x : α), ExistsUnique fun g => Membership.mem s (HSMul.hSMul g x)\n⊢ MeasureTheory.IsFundamentalDomain G s μ","decl":"/-- If for each `x : α`, exactly one of `g • x`, `g : G`, belongs to a measurable set `s`, then `s`\nis a fundamental domain for the action of `G` on `α`. -/\n@[to_additive \"If for each `x : α`, exactly one of `g +ᵥ x`, `g : G`, belongs to a measurable set\n`s`, then `s` is a fundamental domain for the additive action of `G` on `α`.\"]\ntheorem mk' (h_meas : NullMeasurableSet s μ) (h_exists : ∀ x : α, ∃! g : G, g • x ∈ s) :\n    IsFundamentalDomain G s μ where\n  nullMeasurableSet := h_meas\n  ae_covers := Eventually.of_forall fun x => (h_exists x).exists\n  aedisjoint a b hab := Disjoint.aedisjoint <| disjoint_left.2 fun x hxa hxb => by\n    rw [mem_smul_set_iff_inv_smul_mem] at hxa hxb\n    exact hab (inv_injective <| (h_exists x).unique hxa hxb)\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.mk''","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\nh_meas : MeasureTheory.NullMeasurableSet s μ\nh_ae_covers : Filter.Eventually (fun x => Exists fun g => Membership.mem s (HVAdd.hVAdd g x)) (MeasureTheory.ae μ)\nh_ae_disjoint : ∀ (g : G), Ne g 0 → MeasureTheory.AEDisjoint μ (HVAdd.hVAdd g s) s\nh_qmp : ∀ (g : G), MeasureTheory.Measure.QuasiMeasurePreserving (fun x => HVAdd.hVAdd g x) μ μ\n⊢ MeasureTheory.IsAddFundamentalDomain G s μ","decl":"/-- For `s` to be a fundamental domain, it's enough to check\n`MeasureTheory.AEDisjoint (g • s) s` for `g ≠ 1`. -/\n@[to_additive \"For `s` to be a fundamental domain, it's enough to check\n  `MeasureTheory.AEDisjoint (g +ᵥ s) s` for `g ≠ 0`.\"]\ntheorem mk'' (h_meas : NullMeasurableSet s μ) (h_ae_covers : ∀ᵐ x ∂μ, ∃ g : G, g • x ∈ s)\n    (h_ae_disjoint : ∀ g, g ≠ (1 : G) → AEDisjoint μ (g • s) s)\n    (h_qmp : ∀ g : G, QuasiMeasurePreserving ((g • ·) : α → α) μ μ) :\n    IsFundamentalDomain G s μ where\n  nullMeasurableSet := h_meas\n  ae_covers := h_ae_covers\n  aedisjoint := pairwise_aedisjoint_of_aedisjoint_forall_ne_one h_ae_disjoint h_qmp\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.mk''","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\nh_meas : MeasureTheory.NullMeasurableSet s μ\nh_ae_covers : Filter.Eventually (fun x => Exists fun g => Membership.mem s (HSMul.hSMul g x)) (MeasureTheory.ae μ)\nh_ae_disjoint : ∀ (g : G), Ne g 1 → MeasureTheory.AEDisjoint μ (HSMul.hSMul g s) s\nh_qmp : ∀ (g : G), MeasureTheory.Measure.QuasiMeasurePreserving (fun x => HSMul.hSMul g x) μ μ\n⊢ MeasureTheory.IsFundamentalDomain G s μ","decl":"/-- For `s` to be a fundamental domain, it's enough to check\n`MeasureTheory.AEDisjoint (g • s) s` for `g ≠ 1`. -/\n@[to_additive \"For `s` to be a fundamental domain, it's enough to check\n  `MeasureTheory.AEDisjoint (g +ᵥ s) s` for `g ≠ 0`.\"]\ntheorem mk'' (h_meas : NullMeasurableSet s μ) (h_ae_covers : ∀ᵐ x ∂μ, ∃ g : G, g • x ∈ s)\n    (h_ae_disjoint : ∀ g, g ≠ (1 : G) → AEDisjoint μ (g • s) s)\n    (h_qmp : ∀ g : G, QuasiMeasurePreserving ((g • ·) : α → α) μ μ) :\n    IsFundamentalDomain G s μ where\n  nullMeasurableSet := h_meas\n  ae_covers := h_ae_covers\n  aedisjoint := pairwise_aedisjoint_of_aedisjoint_forall_ne_one h_ae_disjoint h_qmp\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.mk_of_measure_univ_le","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : Group G\ninst✝³ : MulAction G α\ninst✝² : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : Countable G\nh_meas : MeasureTheory.NullMeasurableSet s μ\nh_ae_disjoint : ∀ (g : G), Ne g 1 → MeasureTheory.AEDisjoint μ (HSMul.hSMul g s) s\nh_qmp : ∀ (g : G), MeasureTheory.Measure.QuasiMeasurePreserving (fun x => HSMul.hSMul g x) μ μ\nh_measure_univ_le : LE.le (μ Set.univ) (tsum fun g => μ (HSMul.hSMul g s))\n⊢ MeasureTheory.IsFundamentalDomain G s μ","decl":"/-- If a measurable space has a finite measure `μ` and a countable group `G` acts\nquasi-measure-preservingly, then to show that a set `s` is a fundamental domain, it is sufficient\nto check that its translates `g • s` are (almost) disjoint and that the sum `∑' g, μ (g • s)` is\nsufficiently large. -/\n@[to_additive\n  \"If a measurable space has a finite measure `μ` and a countable additive group `G` acts\n  quasi-measure-preservingly, then to show that a set `s` is a fundamental domain, it is sufficient\n  to check that its translates `g +ᵥ s` are (almost) disjoint and that the sum `∑' g, μ (g +ᵥ s)` is\n  sufficiently large.\"]\ntheorem mk_of_measure_univ_le [IsFiniteMeasure μ] [Countable G] (h_meas : NullMeasurableSet s μ)\n    (h_ae_disjoint : ∀ g ≠ (1 : G), AEDisjoint μ (g • s) s)\n    (h_qmp : ∀ g : G, QuasiMeasurePreserving (g • · : α → α) μ μ)\n    (h_measure_univ_le : μ (univ : Set α) ≤ ∑' g : G, μ (g • s)) : IsFundamentalDomain G s μ :=\n  have aedisjoint : Pairwise (AEDisjoint μ on fun g : G => g • s) :=\n    pairwise_aedisjoint_of_aedisjoint_forall_ne_one h_ae_disjoint h_qmp\n  { nullMeasurableSet := h_meas\n    aedisjoint\n    ae_covers := by\n      replace h_meas : ∀ g : G, NullMeasurableSet (g • s) μ := fun g => by\n        rw [← inv_inv g, ← preimage_smul]; exact h_meas.preimage (h_qmp g⁻¹)\n      have h_meas' : NullMeasurableSet {a | ∃ g : G, g • a ∈ s} μ := by\n        rw [← iUnion_smul_eq_setOf_exists]; exact .iUnion h_meas\n      rw [ae_iff_measure_eq h_meas', ← iUnion_smul_eq_setOf_exists]\n      refine le_antisymm (measure_mono <| subset_univ _) ?_\n      rw [measure_iUnion₀ aedisjoint h_meas]\n      exact h_measure_univ_le }\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.mk_of_measure_univ_le","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : AddGroup G\ninst✝³ : AddAction G α\ninst✝² : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : Countable G\nh_meas : MeasureTheory.NullMeasurableSet s μ\nh_ae_disjoint : ∀ (g : G), Ne g 0 → MeasureTheory.AEDisjoint μ (HVAdd.hVAdd g s) s\nh_qmp : ∀ (g : G), MeasureTheory.Measure.QuasiMeasurePreserving (fun x => HVAdd.hVAdd g x) μ μ\nh_measure_univ_le : LE.le (μ Set.univ) (tsum fun g => μ (HVAdd.hVAdd g s))\n⊢ MeasureTheory.IsAddFundamentalDomain G s μ","decl":"/-- If a measurable space has a finite measure `μ` and a countable group `G` acts\nquasi-measure-preservingly, then to show that a set `s` is a fundamental domain, it is sufficient\nto check that its translates `g • s` are (almost) disjoint and that the sum `∑' g, μ (g • s)` is\nsufficiently large. -/\n@[to_additive\n  \"If a measurable space has a finite measure `μ` and a countable additive group `G` acts\n  quasi-measure-preservingly, then to show that a set `s` is a fundamental domain, it is sufficient\n  to check that its translates `g +ᵥ s` are (almost) disjoint and that the sum `∑' g, μ (g +ᵥ s)` is\n  sufficiently large.\"]\ntheorem mk_of_measure_univ_le [IsFiniteMeasure μ] [Countable G] (h_meas : NullMeasurableSet s μ)\n    (h_ae_disjoint : ∀ g ≠ (1 : G), AEDisjoint μ (g • s) s)\n    (h_qmp : ∀ g : G, QuasiMeasurePreserving (g • · : α → α) μ μ)\n    (h_measure_univ_le : μ (univ : Set α) ≤ ∑' g : G, μ (g • s)) : IsFundamentalDomain G s μ :=\n  have aedisjoint : Pairwise (AEDisjoint μ on fun g : G => g • s) :=\n    pairwise_aedisjoint_of_aedisjoint_forall_ne_one h_ae_disjoint h_qmp\n  { nullMeasurableSet := h_meas\n    aedisjoint\n    ae_covers := by\n      replace h_meas : ∀ g : G, NullMeasurableSet (g • s) μ := fun g => by\n        rw [← inv_inv g, ← preimage_smul]; exact h_meas.preimage (h_qmp g⁻¹)\n      have h_meas' : NullMeasurableSet {a | ∃ g : G, g • a ∈ s} μ := by\n        rw [← iUnion_smul_eq_setOf_exists]; exact .iUnion h_meas\n      rw [ae_iff_measure_eq h_meas', ← iUnion_smul_eq_setOf_exists]\n      refine le_antisymm (measure_mono <| subset_univ _) ?_\n      rw [measure_iUnion₀ aedisjoint h_meas]\n      exact h_measure_univ_le }\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.iUnion_smul_ae_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\nh : MeasureTheory.IsFundamentalDomain G s μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.iUnion fun g => HSMul.hSMul g s) Set.univ","decl":"@[to_additive]\ntheorem iUnion_smul_ae_eq (h : IsFundamentalDomain G s μ) : ⋃ g : G, g • s =ᵐ[μ] univ :=\n  eventuallyEq_univ.2 <| h.ae_covers.mono fun _ ⟨g, hg⟩ =>\n    mem_iUnion.2 ⟨g⁻¹, _, hg, inv_smul_smul _ _⟩\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.iUnion_vadd_ae_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\nh : MeasureTheory.IsAddFundamentalDomain G s μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.iUnion fun g => HVAdd.hVAdd g s) Set.univ","decl":"@[to_additive]\ntheorem iUnion_smul_ae_eq (h : IsFundamentalDomain G s μ) : ⋃ g : G, g • s =ᵐ[μ] univ :=\n  eventuallyEq_univ.2 <| h.ae_covers.mono fun _ ⟨g, hg⟩ =>\n    mem_iUnion.2 ⟨g⁻¹, _, hg, inv_smul_smul _ _⟩\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.measure_ne_zero","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : AddGroup G\ninst✝³ : AddAction G α\ninst✝² : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝¹ : Countable G\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nhμ : Ne μ 0\nh : MeasureTheory.IsAddFundamentalDomain G s μ\n⊢ Ne (μ s) 0","decl":"@[to_additive]\ntheorem measure_ne_zero [Countable G] [SMulInvariantMeasure G α μ]\n    (hμ : μ ≠ 0) (h : IsFundamentalDomain G s μ) : μ s ≠ 0 := by\n  have hc := measure_univ_pos.mpr hμ\n  contrapose! hc\n  rw [← measure_congr h.iUnion_smul_ae_eq]\n  refine le_trans (measure_iUnion_le _) ?_\n  simp_rw [measure_smul, hc, tsum_zero, le_refl]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.measure_ne_zero","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : Group G\ninst✝³ : MulAction G α\ninst✝² : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝¹ : Countable G\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nhμ : Ne μ 0\nh : MeasureTheory.IsFundamentalDomain G s μ\n⊢ Ne (μ s) 0","decl":"@[to_additive]\ntheorem measure_ne_zero [Countable G] [SMulInvariantMeasure G α μ]\n    (hμ : μ ≠ 0) (h : IsFundamentalDomain G s μ) : μ s ≠ 0 := by\n  have hc := measure_univ_pos.mpr hμ\n  contrapose! hc\n  rw [← measure_congr h.iUnion_smul_ae_eq]\n  refine le_trans (measure_iUnion_le _) ?_\n  simp_rw [measure_smul, hc, tsum_zero, le_refl]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.mono","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nν : MeasureTheory.Measure α\nhle : ν.AbsolutelyContinuous μ\n⊢ MeasureTheory.IsAddFundamentalDomain G s ν","decl":"@[to_additive]\ntheorem mono (h : IsFundamentalDomain G s μ) {ν : Measure α} (hle : ν ≪ μ) :\n    IsFundamentalDomain G s ν :=\n  ⟨h.1.mono_ac hle, hle h.2, h.aedisjoint.mono fun _ _ h => hle h⟩\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.mono","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\nh : MeasureTheory.IsFundamentalDomain G s μ\nν : MeasureTheory.Measure α\nhle : ν.AbsolutelyContinuous μ\n⊢ MeasureTheory.IsFundamentalDomain G s ν","decl":"@[to_additive]\ntheorem mono (h : IsFundamentalDomain G s μ) {ν : Measure α} (hle : ν ≪ μ) :\n    IsFundamentalDomain G s ν :=\n  ⟨h.1.mono_ac hle, hle h.2, h.aedisjoint.mono fun _ _ h => hle h⟩\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.preimage_of_equiv","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nH : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝⁵ : AddGroup G\ninst✝⁴ : AddGroup H\ninst✝³ : AddAction G α\ninst✝² : MeasurableSpace α\ninst✝¹ : AddAction H β\ninst✝ : MeasurableSpace β\ns : Set α\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nf : β → α\nhf : MeasureTheory.Measure.QuasiMeasurePreserving f ν μ\ne : G → H\nhe : Function.Bijective e\nhef : ∀ (g : G), Function.Semiconj f (fun x => HVAdd.hVAdd (e g) x) fun x => HVAdd.hVAdd g x\n⊢ MeasureTheory.IsAddFundamentalDomain H (Set.preimage f s) ν","decl":"@[to_additive]\ntheorem preimage_of_equiv {ν : Measure β} (h : IsFundamentalDomain G s μ) {f : β → α}\n    (hf : QuasiMeasurePreserving f ν μ) {e : G → H} (he : Bijective e)\n    (hef : ∀ g, Semiconj f (e g • ·) (g • ·)) : IsFundamentalDomain H (f ⁻¹' s) ν where\n  nullMeasurableSet := h.nullMeasurableSet.preimage hf\n  ae_covers := (hf.ae h.ae_covers).mono fun x ⟨g, hg⟩ => ⟨e g, by rwa [mem_preimage, hef g x]⟩\n  aedisjoint a b hab := by\n    lift e to G ≃ H using he\n    have : (e.symm a⁻¹)⁻¹ ≠ (e.symm b⁻¹)⁻¹ := by simp [hab]\n    have := (h.aedisjoint this).preimage hf\n    simp only [Semiconj] at hef\n    simpa only [onFun, ← preimage_smul_inv, preimage_preimage, ← hef, e.apply_symm_apply, inv_inv]\n      using this\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.preimage_of_equiv","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nH : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝⁵ : Group G\ninst✝⁴ : Group H\ninst✝³ : MulAction G α\ninst✝² : MeasurableSpace α\ninst✝¹ : MulAction H β\ninst✝ : MeasurableSpace β\ns : Set α\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\nh : MeasureTheory.IsFundamentalDomain G s μ\nf : β → α\nhf : MeasureTheory.Measure.QuasiMeasurePreserving f ν μ\ne : G → H\nhe : Function.Bijective e\nhef : ∀ (g : G), Function.Semiconj f (fun x => HSMul.hSMul (e g) x) fun x => HSMul.hSMul g x\n⊢ MeasureTheory.IsFundamentalDomain H (Set.preimage f s) ν","decl":"@[to_additive]\ntheorem preimage_of_equiv {ν : Measure β} (h : IsFundamentalDomain G s μ) {f : β → α}\n    (hf : QuasiMeasurePreserving f ν μ) {e : G → H} (he : Bijective e)\n    (hef : ∀ g, Semiconj f (e g • ·) (g • ·)) : IsFundamentalDomain H (f ⁻¹' s) ν where\n  nullMeasurableSet := h.nullMeasurableSet.preimage hf\n  ae_covers := (hf.ae h.ae_covers).mono fun x ⟨g, hg⟩ => ⟨e g, by rwa [mem_preimage, hef g x]⟩\n  aedisjoint a b hab := by\n    lift e to G ≃ H using he\n    have : (e.symm a⁻¹)⁻¹ ≠ (e.symm b⁻¹)⁻¹ := by simp [hab]\n    have := (h.aedisjoint this).preimage hf\n    simp only [Semiconj] at hef\n    simpa only [onFun, ← preimage_smul_inv, preimage_preimage, ← hef, e.apply_symm_apply, inv_inv]\n      using this\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.image_of_equiv","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nH : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝⁵ : AddGroup G\ninst✝⁴ : AddGroup H\ninst✝³ : AddAction G α\ninst✝² : MeasurableSpace α\ninst✝¹ : AddAction H β\ninst✝ : MeasurableSpace β\ns : Set α\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nf : Equiv α β\nhf : MeasureTheory.Measure.QuasiMeasurePreserving (⇑f.symm) ν μ\ne : Equiv H G\nhef : ∀ (g : H), Function.Semiconj (⇑f) (fun x => HVAdd.hVAdd (e g) x) fun x => HVAdd.hVAdd g x\n⊢ MeasureTheory.IsAddFundamentalDomain H (Set.image (⇑f) s) ν","decl":"@[to_additive]\ntheorem image_of_equiv {ν : Measure β} (h : IsFundamentalDomain G s μ) (f : α ≃ β)\n    (hf : QuasiMeasurePreserving f.symm ν μ) (e : H ≃ G)\n    (hef : ∀ g, Semiconj f (e g • ·) (g • ·)) : IsFundamentalDomain H (f '' s) ν := by\n  rw [f.image_eq_preimage]\n  refine h.preimage_of_equiv hf e.symm.bijective fun g x => ?_\n  rcases f.surjective x with ⟨x, rfl⟩\n  rw [← hef _ _, f.symm_apply_apply, f.symm_apply_apply, e.apply_symm_apply]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.image_of_equiv","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nH : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝⁵ : Group G\ninst✝⁴ : Group H\ninst✝³ : MulAction G α\ninst✝² : MeasurableSpace α\ninst✝¹ : MulAction H β\ninst✝ : MeasurableSpace β\ns : Set α\nμ : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\nh : MeasureTheory.IsFundamentalDomain G s μ\nf : Equiv α β\nhf : MeasureTheory.Measure.QuasiMeasurePreserving (⇑f.symm) ν μ\ne : Equiv H G\nhef : ∀ (g : H), Function.Semiconj (⇑f) (fun x => HSMul.hSMul (e g) x) fun x => HSMul.hSMul g x\n⊢ MeasureTheory.IsFundamentalDomain H (Set.image (⇑f) s) ν","decl":"@[to_additive]\ntheorem image_of_equiv {ν : Measure β} (h : IsFundamentalDomain G s μ) (f : α ≃ β)\n    (hf : QuasiMeasurePreserving f.symm ν μ) (e : H ≃ G)\n    (hef : ∀ g, Semiconj f (e g • ·) (g • ·)) : IsFundamentalDomain H (f '' s) ν := by\n  rw [f.image_eq_preimage]\n  refine h.preimage_of_equiv hf e.symm.bijective fun g x => ?_\n  rcases f.surjective x with ⟨x, rfl⟩\n  rw [← hef _ _, f.symm_apply_apply, f.symm_apply_apply, e.apply_symm_apply]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.pairwise_aedisjoint_of_ac","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ ν : MeasureTheory.Measure α\nh : MeasureTheory.IsFundamentalDomain G s μ\nhν : ν.AbsolutelyContinuous μ\n⊢ Pairwise fun g₁ g₂ => MeasureTheory.AEDisjoint ν (HSMul.hSMul g₁ s) (HSMul.hSMul g₂ s)","decl":"@[to_additive]\ntheorem pairwise_aedisjoint_of_ac {ν} (h : IsFundamentalDomain G s μ) (hν : ν ≪ μ) :\n    Pairwise fun g₁ g₂ : G => AEDisjoint ν (g₁ • s) (g₂ • s) :=\n  h.aedisjoint.mono fun _ _ H => hν H\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.pairwise_aedisjoint_of_ac","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableSpace α\ns : Set α\nμ ν : MeasureTheory.Measure α\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nhν : ν.AbsolutelyContinuous μ\n⊢ Pairwise fun g₁ g₂ => MeasureTheory.AEDisjoint ν (HVAdd.hVAdd g₁ s) (HVAdd.hVAdd g₂ s)","decl":"@[to_additive]\ntheorem pairwise_aedisjoint_of_ac {ν} (h : IsFundamentalDomain G s μ) (hν : ν ≪ μ) :\n    Pairwise fun g₁ g₂ : G => AEDisjoint ν (g₁ • s) (g₂ • s) :=\n  h.aedisjoint.mono fun _ _ H => hν H\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.smul_of_comm","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁸ : Group G\ninst✝⁷ : MulAction G α\ninst✝⁶ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\nG' : Type u_6\ninst✝⁵ : Group G'\ninst✝⁴ : MulAction G' α\ninst✝³ : MeasurableSpace G'\ninst✝² : MeasurableSMul G' α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G' α μ\ninst✝ : SMulCommClass G' G α\nh : MeasureTheory.IsFundamentalDomain G s μ\ng : G'\n⊢ MeasureTheory.IsFundamentalDomain G (HSMul.hSMul g s) μ","decl":"@[to_additive]\ntheorem smul_of_comm {G' : Type*} [Group G'] [MulAction G' α] [MeasurableSpace G']\n    [MeasurableSMul G' α] [SMulInvariantMeasure G' α μ] [SMulCommClass G' G α]\n    (h : IsFundamentalDomain G s μ) (g : G') : IsFundamentalDomain G (g • s) μ :=\n  h.image_of_equiv (MulAction.toPerm g) (measurePreserving_smul _ _).quasiMeasurePreserving\n    (Equiv.refl _) <| smul_comm g\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.vadd_of_comm","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁸ : AddGroup G\ninst✝⁷ : AddAction G α\ninst✝⁶ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\nG' : Type u_6\ninst✝⁵ : AddGroup G'\ninst✝⁴ : AddAction G' α\ninst✝³ : MeasurableSpace G'\ninst✝² : MeasurableVAdd G' α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G' α μ\ninst✝ : VAddCommClass G' G α\nh : MeasureTheory.IsAddFundamentalDomain G s μ\ng : G'\n⊢ MeasureTheory.IsAddFundamentalDomain G (HVAdd.hVAdd g s) μ","decl":"@[to_additive]\ntheorem smul_of_comm {G' : Type*} [Group G'] [MulAction G' α] [MeasurableSpace G']\n    [MeasurableSMul G' α] [SMulInvariantMeasure G' α μ] [SMulCommClass G' G α]\n    (h : IsFundamentalDomain G s μ) (g : G') : IsFundamentalDomain G (g • s) μ :=\n  h.image_of_equiv (MulAction.toPerm g) (measurePreserving_smul _ _).quasiMeasurePreserving\n    (Equiv.refl _) <| smul_comm g\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.nullMeasurableSet_smul","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁵ : Group G\ninst✝⁴ : MulAction G α\ninst✝³ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableSMul G α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nh : MeasureTheory.IsFundamentalDomain G s μ\ng : G\n⊢ MeasureTheory.NullMeasurableSet (HSMul.hSMul g s) μ","decl":"@[to_additive]\ntheorem nullMeasurableSet_smul (h : IsFundamentalDomain G s μ) (g : G) :\n    NullMeasurableSet (g • s) μ :=\n  h.nullMeasurableSet.smul g\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.nullMeasurableSet_vadd","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁵ : AddGroup G\ninst✝⁴ : AddAction G α\ninst✝³ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableVAdd G α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nh : MeasureTheory.IsAddFundamentalDomain G s μ\ng : G\n⊢ MeasureTheory.NullMeasurableSet (HVAdd.hVAdd g s) μ","decl":"@[to_additive]\ntheorem nullMeasurableSet_smul (h : IsFundamentalDomain G s μ) (g : G) :\n    NullMeasurableSet (g • s) μ :=\n  h.nullMeasurableSet.smul g\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.restrict_restrict","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁵ : Group G\ninst✝⁴ : MulAction G α\ninst✝³ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableSMul G α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nh : MeasureTheory.IsFundamentalDomain G s μ\ng : G\nt : Set α\n⊢ Eq ((μ.restrict t).restrict (HSMul.hSMul g s)) (μ.restrict (Inter.inter (HSMul.hSMul g s) t))","decl":"@[to_additive]\ntheorem restrict_restrict (h : IsFundamentalDomain G s μ) (g : G) (t : Set α) :\n    (μ.restrict t).restrict (g • s) = μ.restrict (g • s ∩ t) :=\n  restrict_restrict₀ ((h.nullMeasurableSet_smul g).mono restrict_le_self)\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.restrict_restrict","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁵ : AddGroup G\ninst✝⁴ : AddAction G α\ninst✝³ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableVAdd G α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nh : MeasureTheory.IsAddFundamentalDomain G s μ\ng : G\nt : Set α\n⊢ Eq ((μ.restrict t).restrict (HVAdd.hVAdd g s)) (μ.restrict (Inter.inter (HVAdd.hVAdd g s) t))","decl":"@[to_additive]\ntheorem restrict_restrict (h : IsFundamentalDomain G s μ) (g : G) (t : Set α) :\n    (μ.restrict t).restrict (g • s) = μ.restrict (g • s ∩ t) :=\n  restrict_restrict₀ ((h.nullMeasurableSet_smul g).mono restrict_le_self)\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.vadd","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁵ : AddGroup G\ninst✝⁴ : AddAction G α\ninst✝³ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableVAdd G α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nh : MeasureTheory.IsAddFundamentalDomain G s μ\ng : G\n⊢ MeasureTheory.IsAddFundamentalDomain G (HVAdd.hVAdd g s) μ","decl":"@[to_additive]\ntheorem smul (h : IsFundamentalDomain G s μ) (g : G) : IsFundamentalDomain G (g • s) μ :=\n  h.image_of_equiv (MulAction.toPerm g) (measurePreserving_smul _ _).quasiMeasurePreserving\n    ⟨fun g' => g⁻¹ * g' * g, fun g' => g * g' * g⁻¹, fun g' => by simp [mul_assoc], fun g' => by\n      simp [mul_assoc]⟩\n    fun g' x => by simp [smul_smul, mul_assoc]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.smul","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁵ : Group G\ninst✝⁴ : MulAction G α\ninst✝³ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableSMul G α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nh : MeasureTheory.IsFundamentalDomain G s μ\ng : G\n⊢ MeasureTheory.IsFundamentalDomain G (HSMul.hSMul g s) μ","decl":"@[to_additive]\ntheorem smul (h : IsFundamentalDomain G s μ) (g : G) : IsFundamentalDomain G (g • s) μ :=\n  h.image_of_equiv (MulAction.toPerm g) (measurePreserving_smul _ _).quasiMeasurePreserving\n    ⟨fun g' => g⁻¹ * g' * g, fun g' => g * g' * g⁻¹, fun g' => by simp [mul_assoc], fun g' => by\n      simp [mul_assoc]⟩\n    fun g' x => by simp [smul_smul, mul_assoc]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.sum_restrict_of_ac","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nν : MeasureTheory.Measure α\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nhν : ν.AbsolutelyContinuous μ\n⊢ Eq (MeasureTheory.Measure.sum fun g => ν.restrict (HVAdd.hVAdd g s)) ν","decl":"@[to_additive]\ntheorem sum_restrict_of_ac (h : IsFundamentalDomain G s μ) (hν : ν ≪ μ) :\n    (sum fun g : G => ν.restrict (g • s)) = ν := by\n  rw [← restrict_iUnion_ae (h.aedisjoint.mono fun i j h => hν h) fun g =>\n      (h.nullMeasurableSet_smul g).mono_ac hν,\n    restrict_congr_set (hν h.iUnion_smul_ae_eq), restrict_univ]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.sum_restrict_of_ac","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nν : MeasureTheory.Measure α\nh : MeasureTheory.IsFundamentalDomain G s μ\nhν : ν.AbsolutelyContinuous μ\n⊢ Eq (MeasureTheory.Measure.sum fun g => ν.restrict (HSMul.hSMul g s)) ν","decl":"@[to_additive]\ntheorem sum_restrict_of_ac (h : IsFundamentalDomain G s μ) (hν : ν ≪ μ) :\n    (sum fun g : G => ν.restrict (g • s)) = ν := by\n  rw [← restrict_iUnion_ae (h.aedisjoint.mono fun i j h => hν h) fun g =>\n      (h.nullMeasurableSet_smul g).mono_ac hν,\n    restrict_congr_set (hν h.iUnion_smul_ae_eq), restrict_univ]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.lintegral_eq_tsum_of_ac","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nν : MeasureTheory.Measure α\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nhν : ν.AbsolutelyContinuous μ\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral ν fun x => f x) (tsum fun g => MeasureTheory.lintegral (ν.restrict (HVAdd.hVAdd g s)) fun x => f x)","decl":"@[to_additive]\ntheorem lintegral_eq_tsum_of_ac (h : IsFundamentalDomain G s μ) (hν : ν ≪ μ) (f : α → ℝ≥0∞) :\n    ∫⁻ x, f x ∂ν = ∑' g : G, ∫⁻ x in g • s, f x ∂ν := by\n  rw [← lintegral_sum_measure, h.sum_restrict_of_ac hν]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.lintegral_eq_tsum_of_ac","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nν : MeasureTheory.Measure α\nh : MeasureTheory.IsFundamentalDomain G s μ\nhν : ν.AbsolutelyContinuous μ\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral ν fun x => f x) (tsum fun g => MeasureTheory.lintegral (ν.restrict (HSMul.hSMul g s)) fun x => f x)","decl":"@[to_additive]\ntheorem lintegral_eq_tsum_of_ac (h : IsFundamentalDomain G s μ) (hν : ν ≪ μ) (f : α → ℝ≥0∞) :\n    ∫⁻ x, f x ∂ν = ∑' g : G, ∫⁻ x in g • s, f x ∂ν := by\n  rw [← lintegral_sum_measure, h.sum_restrict_of_ac hν]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.sum_restrict","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsAddFundamentalDomain G s μ\n⊢ Eq (MeasureTheory.Measure.sum fun g => μ.restrict (HVAdd.hVAdd g s)) μ","decl":"@[to_additive]\ntheorem sum_restrict (h : IsFundamentalDomain G s μ) : (sum fun g : G => μ.restrict (g • s)) = μ :=\n  h.sum_restrict_of_ac (refl _)\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.sum_restrict","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsFundamentalDomain G s μ\n⊢ Eq (MeasureTheory.Measure.sum fun g => μ.restrict (HSMul.hSMul g s)) μ","decl":"@[to_additive]\ntheorem sum_restrict (h : IsFundamentalDomain G s μ) : (sum fun g : G => μ.restrict (g • s)) = μ :=\n  h.sum_restrict_of_ac (refl _)\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.lintegral_eq_tsum","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun x => f x) (tsum fun g => MeasureTheory.lintegral (μ.restrict (HVAdd.hVAdd g s)) fun x => f x)","decl":"@[to_additive]\ntheorem lintegral_eq_tsum (h : IsFundamentalDomain G s μ) (f : α → ℝ≥0∞) :\n    ∫⁻ x, f x ∂μ = ∑' g : G, ∫⁻ x in g • s, f x ∂μ :=\n  h.lintegral_eq_tsum_of_ac (refl _) f\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.lintegral_eq_tsum","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsFundamentalDomain G s μ\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun x => f x) (tsum fun g => MeasureTheory.lintegral (μ.restrict (HSMul.hSMul g s)) fun x => f x)","decl":"@[to_additive]\ntheorem lintegral_eq_tsum (h : IsFundamentalDomain G s μ) (f : α → ℝ≥0∞) :\n    ∫⁻ x, f x ∂μ = ∑' g : G, ∫⁻ x in g • s, f x ∂μ :=\n  h.lintegral_eq_tsum_of_ac (refl _) f\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.lintegral_eq_tsum'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsFundamentalDomain G s μ\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun x => f x) (tsum fun g => MeasureTheory.lintegral (μ.restrict s) fun x => f (HSMul.hSMul (Inv.inv g) x))","decl":"@[to_additive]\ntheorem lintegral_eq_tsum' (h : IsFundamentalDomain G s μ) (f : α → ℝ≥0∞) :\n    ∫⁻ x, f x ∂μ = ∑' g : G, ∫⁻ x in s, f (g⁻¹ • x) ∂μ :=\n  calc\n    ∫⁻ x, f x ∂μ = ∑' g : G, ∫⁻ x in g • s, f x ∂μ := h.lintegral_eq_tsum f\n    _ = ∑' g : G, ∫⁻ x in g⁻¹ • s, f x ∂μ := ((Equiv.inv G).tsum_eq _).symm\n    _ = ∑' g : G, ∫⁻ x in s, f (g⁻¹ • x) ∂μ := tsum_congr fun g => Eq.symm <|\n      (measurePreserving_smul g⁻¹ μ).setLIntegral_comp_emb (measurableEmbedding_const_smul _) _ _\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.lintegral_eq_tsum'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun x => f x) (tsum fun g => MeasureTheory.lintegral (μ.restrict s) fun x => f (HVAdd.hVAdd (Neg.neg g) x))","decl":"@[to_additive]\ntheorem lintegral_eq_tsum' (h : IsFundamentalDomain G s μ) (f : α → ℝ≥0∞) :\n    ∫⁻ x, f x ∂μ = ∑' g : G, ∫⁻ x in s, f (g⁻¹ • x) ∂μ :=\n  calc\n    ∫⁻ x, f x ∂μ = ∑' g : G, ∫⁻ x in g • s, f x ∂μ := h.lintegral_eq_tsum f\n    _ = ∑' g : G, ∫⁻ x in g⁻¹ • s, f x ∂μ := ((Equiv.inv G).tsum_eq _).symm\n    _ = ∑' g : G, ∫⁻ x in s, f (g⁻¹ • x) ∂μ := tsum_congr fun g => Eq.symm <|\n      (measurePreserving_smul g⁻¹ μ).setLIntegral_comp_emb (measurableEmbedding_const_smul _) _ _\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.lintegral_eq_tsum''","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsFundamentalDomain G s μ\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun x => f x) (tsum fun g => MeasureTheory.lintegral (μ.restrict s) fun x => f (HSMul.hSMul g x))","decl":"@[to_additive] lemma lintegral_eq_tsum'' (h : IsFundamentalDomain G s μ) (f : α → ℝ≥0∞) :\n    ∫⁻ x, f x ∂μ = ∑' g : G, ∫⁻ x in s, f (g • x) ∂μ :=\n  (lintegral_eq_tsum' h f).trans ((Equiv.inv G).tsum_eq (fun g ↦ ∫⁻ (x : α) in s, f (g • x) ∂μ))\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.lintegral_eq_tsum''","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nf : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral μ fun x => f x) (tsum fun g => MeasureTheory.lintegral (μ.restrict s) fun x => f (HVAdd.hVAdd g x))","decl":"@[to_additive] lemma lintegral_eq_tsum'' (h : IsFundamentalDomain G s μ) (f : α → ℝ≥0∞) :\n    ∫⁻ x, f x ∂μ = ∑' g : G, ∫⁻ x in s, f (g • x) ∂μ :=\n  (lintegral_eq_tsum' h f).trans ((Equiv.inv G).tsum_eq (fun g ↦ ∫⁻ (x : α) in s, f (g • x) ∂μ))\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.setLIntegral_eq_tsum","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsFundamentalDomain G s μ\nf : α → ENNReal\nt : Set α\n⊢ Eq (MeasureTheory.lintegral (μ.restrict t) fun x => f x) (tsum fun g => MeasureTheory.lintegral (μ.restrict (Inter.inter t (HSMul.hSMul g s))) fun x => f x)","decl":"@[to_additive]\ntheorem setLIntegral_eq_tsum (h : IsFundamentalDomain G s μ) (f : α → ℝ≥0∞) (t : Set α) :\n    ∫⁻ x in t, f x ∂μ = ∑' g : G, ∫⁻ x in t ∩ g • s, f x ∂μ :=\n  calc\n    ∫⁻ x in t, f x ∂μ = ∑' g : G, ∫⁻ x in g • s, f x ∂μ.restrict t :=\n      h.lintegral_eq_tsum_of_ac restrict_le_self.absolutelyContinuous _\n    _ = ∑' g : G, ∫⁻ x in t ∩ g • s, f x ∂μ := by simp only [h.restrict_restrict, inter_comm]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.setLIntegral_eq_tsum","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nf : α → ENNReal\nt : Set α\n⊢ Eq (MeasureTheory.lintegral (μ.restrict t) fun x => f x) (tsum fun g => MeasureTheory.lintegral (μ.restrict (Inter.inter t (HVAdd.hVAdd g s))) fun x => f x)","decl":"@[to_additive]\ntheorem setLIntegral_eq_tsum (h : IsFundamentalDomain G s μ) (f : α → ℝ≥0∞) (t : Set α) :\n    ∫⁻ x in t, f x ∂μ = ∑' g : G, ∫⁻ x in t ∩ g • s, f x ∂μ :=\n  calc\n    ∫⁻ x in t, f x ∂μ = ∑' g : G, ∫⁻ x in g • s, f x ∂μ.restrict t :=\n      h.lintegral_eq_tsum_of_ac restrict_le_self.absolutelyContinuous _\n    _ = ∑' g : G, ∫⁻ x in t ∩ g • s, f x ∂μ := by simp only [h.restrict_restrict, inter_comm]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.setLIntegral_eq_tsum'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsFundamentalDomain G s μ\nf : α → ENNReal\nt : Set α\n⊢ Eq (MeasureTheory.lintegral (μ.restrict t) fun x => f x) (tsum fun g => MeasureTheory.lintegral (μ.restrict (Inter.inter (HSMul.hSMul g t) s)) fun x => f (HSMul.hSMul (Inv.inv g) x))","decl":"@[to_additive]\ntheorem setLIntegral_eq_tsum' (h : IsFundamentalDomain G s μ) (f : α → ℝ≥0∞) (t : Set α) :\n    ∫⁻ x in t, f x ∂μ = ∑' g : G, ∫⁻ x in g • t ∩ s, f (g⁻¹ • x) ∂μ :=\n  calc\n    ∫⁻ x in t, f x ∂μ = ∑' g : G, ∫⁻ x in t ∩ g • s, f x ∂μ := h.setLIntegral_eq_tsum f t\n    _ = ∑' g : G, ∫⁻ x in t ∩ g⁻¹ • s, f x ∂μ := ((Equiv.inv G).tsum_eq _).symm\n    _ = ∑' g : G, ∫⁻ x in g⁻¹ • (g • t ∩ s), f x ∂μ := by simp only [smul_set_inter, inv_smul_smul]\n    _ = ∑' g : G, ∫⁻ x in g • t ∩ s, f (g⁻¹ • x) ∂μ := tsum_congr fun g => Eq.symm <|\n      (measurePreserving_smul g⁻¹ μ).setLIntegral_comp_emb (measurableEmbedding_const_smul _) _ _\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.setLIntegral_eq_tsum'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nf : α → ENNReal\nt : Set α\n⊢ Eq (MeasureTheory.lintegral (μ.restrict t) fun x => f x) (tsum fun g => MeasureTheory.lintegral (μ.restrict (Inter.inter (HVAdd.hVAdd g t) s)) fun x => f (HVAdd.hVAdd (Neg.neg g) x))","decl":"@[to_additive]\ntheorem setLIntegral_eq_tsum' (h : IsFundamentalDomain G s μ) (f : α → ℝ≥0∞) (t : Set α) :\n    ∫⁻ x in t, f x ∂μ = ∑' g : G, ∫⁻ x in g • t ∩ s, f (g⁻¹ • x) ∂μ :=\n  calc\n    ∫⁻ x in t, f x ∂μ = ∑' g : G, ∫⁻ x in t ∩ g • s, f x ∂μ := h.setLIntegral_eq_tsum f t\n    _ = ∑' g : G, ∫⁻ x in t ∩ g⁻¹ • s, f x ∂μ := ((Equiv.inv G).tsum_eq _).symm\n    _ = ∑' g : G, ∫⁻ x in g⁻¹ • (g • t ∩ s), f x ∂μ := by simp only [smul_set_inter, inv_smul_smul]\n    _ = ∑' g : G, ∫⁻ x in g • t ∩ s, f (g⁻¹ • x) ∂μ := tsum_congr fun g => Eq.symm <|\n      (measurePreserving_smul g⁻¹ μ).setLIntegral_comp_emb (measurableEmbedding_const_smul _) _ _\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.measure_eq_tsum_of_ac","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nν : MeasureTheory.Measure α\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nhν : ν.AbsolutelyContinuous μ\nt : Set α\n⊢ Eq (ν t) (tsum fun g => ν (Inter.inter t (HVAdd.hVAdd g s)))","decl":"@[to_additive]\ntheorem measure_eq_tsum_of_ac (h : IsFundamentalDomain G s μ) (hν : ν ≪ μ) (t : Set α) :\n    ν t = ∑' g : G, ν (t ∩ g • s) := by\n  have H : ν.restrict t ≪ μ := Measure.restrict_le_self.absolutelyContinuous.trans hν\n  simpa only [setLIntegral_one, Pi.one_def,\n    Measure.restrict_apply₀ ((h.nullMeasurableSet_smul _).mono_ac H), inter_comm] using\n    h.lintegral_eq_tsum_of_ac H 1\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.measure_eq_tsum_of_ac","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nν : MeasureTheory.Measure α\nh : MeasureTheory.IsFundamentalDomain G s μ\nhν : ν.AbsolutelyContinuous μ\nt : Set α\n⊢ Eq (ν t) (tsum fun g => ν (Inter.inter t (HSMul.hSMul g s)))","decl":"@[to_additive]\ntheorem measure_eq_tsum_of_ac (h : IsFundamentalDomain G s μ) (hν : ν ≪ μ) (t : Set α) :\n    ν t = ∑' g : G, ν (t ∩ g • s) := by\n  have H : ν.restrict t ≪ μ := Measure.restrict_le_self.absolutelyContinuous.trans hν\n  simpa only [setLIntegral_one, Pi.one_def,\n    Measure.restrict_apply₀ ((h.nullMeasurableSet_smul _).mono_ac H), inter_comm] using\n    h.lintegral_eq_tsum_of_ac H 1\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.measure_eq_tsum'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsFundamentalDomain G s μ\nt : Set α\n⊢ Eq (μ t) (tsum fun g => μ (Inter.inter t (HSMul.hSMul g s)))","decl":"@[to_additive]\ntheorem measure_eq_tsum' (h : IsFundamentalDomain G s μ) (t : Set α) :\n    μ t = ∑' g : G, μ (t ∩ g • s) :=\n  h.measure_eq_tsum_of_ac AbsolutelyContinuous.rfl t\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.measure_eq_tsum'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nt : Set α\n⊢ Eq (μ t) (tsum fun g => μ (Inter.inter t (HVAdd.hVAdd g s)))","decl":"@[to_additive]\ntheorem measure_eq_tsum' (h : IsFundamentalDomain G s μ) (t : Set α) :\n    μ t = ∑' g : G, μ (t ∩ g • s) :=\n  h.measure_eq_tsum_of_ac AbsolutelyContinuous.rfl t\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.measure_eq_tsum","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsFundamentalDomain G s μ\nt : Set α\n⊢ Eq (μ t) (tsum fun g => μ (Inter.inter (HSMul.hSMul g t) s))","decl":"@[to_additive]\ntheorem measure_eq_tsum (h : IsFundamentalDomain G s μ) (t : Set α) :\n    μ t = ∑' g : G, μ (g • t ∩ s) := by\n  simpa only [setLIntegral_one] using h.setLIntegral_eq_tsum' (fun _ => 1) t\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.measure_eq_tsum","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nt : Set α\n⊢ Eq (μ t) (tsum fun g => μ (Inter.inter (HVAdd.hVAdd g t) s))","decl":"@[to_additive]\ntheorem measure_eq_tsum (h : IsFundamentalDomain G s μ) (t : Set α) :\n    μ t = ∑' g : G, μ (g • t ∩ s) := by\n  simpa only [setLIntegral_one] using h.setLIntegral_eq_tsum' (fun _ => 1) t\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.measure_zero_of_invariant","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsFundamentalDomain G s μ\nt : Set α\nht : ∀ (g : G), Eq (HSMul.hSMul g t) t\nhts : Eq (μ (Inter.inter t s)) 0\n⊢ Eq (μ t) 0","decl":"@[to_additive]\ntheorem measure_zero_of_invariant (h : IsFundamentalDomain G s μ) (t : Set α)\n    (ht : ∀ g : G, g • t = t) (hts : μ (t ∩ s) = 0) : μ t = 0 := by\n  rw [measure_eq_tsum h]; simp [ht, hts]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.measure_zero_of_invariant","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nt : Set α\nht : ∀ (g : G), Eq (HVAdd.hVAdd g t) t\nhts : Eq (μ (Inter.inter t s)) 0\n⊢ Eq (μ t) 0","decl":"@[to_additive]\ntheorem measure_zero_of_invariant (h : IsFundamentalDomain G s μ) (t : Set α)\n    (ht : ∀ g : G, g • t = t) (hts : μ (t ∩ s) = 0) : μ t = 0 := by\n  rw [measure_eq_tsum h]; simp [ht, hts]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.measure_eq_card_smul_of_smul_ae_eq_self","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁷ : Group G\ninst✝⁶ : MulAction G α\ninst✝⁵ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSMul G α\ninst✝² : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : Finite G\nh : MeasureTheory.IsFundamentalDomain G s μ\nt : Set α\nht : ∀ (g : G), (MeasureTheory.ae μ).EventuallyEq (HSMul.hSMul g t) t\n⊢ Eq (μ t) (HSMul.hSMul (Nat.card G) (μ (Inter.inter t s)))","decl":"/-- Given a measure space with an action of a finite group `G`, the measure of any `G`-invariant set\nis determined by the measure of its intersection with a fundamental domain for the action of `G`. -/\n@[to_additive measure_eq_card_smul_of_vadd_ae_eq_self \"Given a measure space with an action of a\n  finite additive group `G`, the measure of any `G`-invariant set is determined by the measure of\n  its intersection with a fundamental domain for the action of `G`.\"]\ntheorem measure_eq_card_smul_of_smul_ae_eq_self [Finite G] (h : IsFundamentalDomain G s μ)\n    (t : Set α) (ht : ∀ g : G, (g • t : Set α) =ᵐ[μ] t) : μ t = Nat.card G • μ (t ∩ s) := by\n  haveI : Fintype G := Fintype.ofFinite G\n  rw [h.measure_eq_tsum]\n  replace ht : ∀ g : G, (g • t ∩ s : Set α) =ᵐ[μ] (t ∩ s : Set α) := fun g =>\n    ae_eq_set_inter (ht g) (ae_eq_refl s)\n  simp_rw [measure_congr (ht _), tsum_fintype, Finset.sum_const, Nat.card_eq_fintype_card,\n    Finset.card_univ]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.measure_eq_card_smul_of_vadd_ae_eq_self","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁷ : AddGroup G\ninst✝⁶ : AddAction G α\ninst✝⁵ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableVAdd G α\ninst✝² : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : Finite G\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nt : Set α\nht : ∀ (g : G), (MeasureTheory.ae μ).EventuallyEq (HVAdd.hVAdd g t) t\n⊢ Eq (μ t) (HSMul.hSMul (Nat.card G) (μ (Inter.inter t s)))","decl":"/-- Given a measure space with an action of a finite group `G`, the measure of any `G`-invariant set\nis determined by the measure of its intersection with a fundamental domain for the action of `G`. -/\n@[to_additive measure_eq_card_smul_of_vadd_ae_eq_self \"Given a measure space with an action of a\n  finite additive group `G`, the measure of any `G`-invariant set is determined by the measure of\n  its intersection with a fundamental domain for the action of `G`.\"]\ntheorem measure_eq_card_smul_of_smul_ae_eq_self [Finite G] (h : IsFundamentalDomain G s μ)\n    (t : Set α) (ht : ∀ g : G, (g • t : Set α) =ᵐ[μ] t) : μ t = Nat.card G • μ (t ∩ s) := by\n  haveI : Fintype G := Fintype.ofFinite G\n  rw [h.measure_eq_tsum]\n  replace ht : ∀ g : G, (g • t ∩ s : Set α) =ᵐ[μ] (t ∩ s : Set α) := fun g =>\n    ae_eq_set_inter (ht g) (ae_eq_refl s)\n  simp_rw [measure_congr (ht _), tsum_fintype, Finset.sum_const, Nat.card_eq_fintype_card,\n    Finset.card_univ]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.setLIntegral_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsAddFundamentalDomain G s μ\nht : MeasureTheory.IsAddFundamentalDomain G t μ\nf : α → ENNReal\nhf : ∀ (g : G) (x : α), Eq (f (HVAdd.hVAdd g x)) (f x)\n⊢ Eq (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict t) fun x => f x)","decl":"@[to_additive]\nprotected theorem setLIntegral_eq (hs : IsFundamentalDomain G s μ) (ht : IsFundamentalDomain G t μ)\n    (f : α → ℝ≥0∞) (hf : ∀ (g : G) (x), f (g • x) = f x) :\n    ∫⁻ x in s, f x ∂μ = ∫⁻ x in t, f x ∂μ :=\n  calc\n    ∫⁻ x in s, f x ∂μ = ∑' g : G, ∫⁻ x in s ∩ g • t, f x ∂μ := ht.setLIntegral_eq_tsum _ _\n    _ = ∑' g : G, ∫⁻ x in g • t ∩ s, f (g⁻¹ • x) ∂μ := by simp only [hf, inter_comm]\n    _ = ∫⁻ x in t, f x ∂μ := (hs.setLIntegral_eq_tsum' _ _).symm\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.setLIntegral_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsFundamentalDomain G s μ\nht : MeasureTheory.IsFundamentalDomain G t μ\nf : α → ENNReal\nhf : ∀ (g : G) (x : α), Eq (f (HSMul.hSMul g x)) (f x)\n⊢ Eq (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict t) fun x => f x)","decl":"@[to_additive]\nprotected theorem setLIntegral_eq (hs : IsFundamentalDomain G s μ) (ht : IsFundamentalDomain G t μ)\n    (f : α → ℝ≥0∞) (hf : ∀ (g : G) (x), f (g • x) = f x) :\n    ∫⁻ x in s, f x ∂μ = ∫⁻ x in t, f x ∂μ :=\n  calc\n    ∫⁻ x in s, f x ∂μ = ∑' g : G, ∫⁻ x in s ∩ g • t, f x ∂μ := ht.setLIntegral_eq_tsum _ _\n    _ = ∑' g : G, ∫⁻ x in g • t ∩ s, f (g⁻¹ • x) ∂μ := by simp only [hf, inter_comm]\n    _ = ∫⁻ x in t, f x ∂μ := (hs.setLIntegral_eq_tsum' _ _).symm\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.measure_set_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsAddFundamentalDomain G s μ\nht : MeasureTheory.IsAddFundamentalDomain G t μ\nA : Set α\nhA₀ : MeasurableSet A\nhA : ∀ (g : G), Eq (Set.preimage (fun x => HVAdd.hVAdd g x) A) A\n⊢ Eq (μ (Inter.inter A s)) (μ (Inter.inter A t))","decl":"@[to_additive]\ntheorem measure_set_eq (hs : IsFundamentalDomain G s μ) (ht : IsFundamentalDomain G t μ) {A : Set α}\n    (hA₀ : MeasurableSet A) (hA : ∀ g : G, (fun x => g • x) ⁻¹' A = A) : μ (A ∩ s) = μ (A ∩ t) := by\n  have : ∫⁻ x in s, A.indicator 1 x ∂μ = ∫⁻ x in t, A.indicator 1 x ∂μ := by\n    refine hs.setLIntegral_eq ht (Set.indicator A fun _ => 1) fun g x ↦ ?_\n    convert (Set.indicator_comp_right (g • · : α → α) (g := fun _ ↦ (1 : ℝ≥0∞))).symm\n    rw [hA g]\n  simpa [Measure.restrict_apply hA₀, lintegral_indicator hA₀] using this\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.measure_set_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsFundamentalDomain G s μ\nht : MeasureTheory.IsFundamentalDomain G t μ\nA : Set α\nhA₀ : MeasurableSet A\nhA : ∀ (g : G), Eq (Set.preimage (fun x => HSMul.hSMul g x) A) A\n⊢ Eq (μ (Inter.inter A s)) (μ (Inter.inter A t))","decl":"@[to_additive]\ntheorem measure_set_eq (hs : IsFundamentalDomain G s μ) (ht : IsFundamentalDomain G t μ) {A : Set α}\n    (hA₀ : MeasurableSet A) (hA : ∀ g : G, (fun x => g • x) ⁻¹' A = A) : μ (A ∩ s) = μ (A ∩ t) := by\n  have : ∫⁻ x in s, A.indicator 1 x ∂μ = ∫⁻ x in t, A.indicator 1 x ∂μ := by\n    refine hs.setLIntegral_eq ht (Set.indicator A fun _ => 1) fun g x ↦ ?_\n    convert (Set.indicator_comp_right (g • · : α → α) (g := fun _ ↦ (1 : ℝ≥0∞))).symm\n    rw [hA g]\n  simpa [Measure.restrict_apply hA₀, lintegral_indicator hA₀] using this\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.measure_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsAddFundamentalDomain G s μ\nht : MeasureTheory.IsAddFundamentalDomain G t μ\n⊢ Eq (μ s) (μ t)","decl":"/-- If `s` and `t` are two fundamental domains of the same action, then their measures are equal. -/\n@[to_additive \"If `s` and `t` are two fundamental domains of the same action, then their measures\n  are equal.\"]\nprotected theorem measure_eq (hs : IsFundamentalDomain G s μ) (ht : IsFundamentalDomain G t μ) :\n    μ s = μ t := by\n  simpa only [setLIntegral_one] using hs.setLIntegral_eq ht (fun _ => 1) fun _ _ => rfl\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.measure_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsFundamentalDomain G s μ\nht : MeasureTheory.IsFundamentalDomain G t μ\n⊢ Eq (μ s) (μ t)","decl":"/-- If `s` and `t` are two fundamental domains of the same action, then their measures are equal. -/\n@[to_additive \"If `s` and `t` are two fundamental domains of the same action, then their measures\n  are equal.\"]\nprotected theorem measure_eq (hs : IsFundamentalDomain G s μ) (ht : IsFundamentalDomain G t μ) :\n    μ s = μ t := by\n  simpa only [setLIntegral_one] using hs.setLIntegral_eq ht (fun _ => 1) fun _ _ => rfl\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.aEStronglyMeasurable_on_iff","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁸ : Group G\ninst✝⁷ : MulAction G α\ninst✝⁶ : MeasurableSpace α\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : MeasurableSMul G α\ninst✝³ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝² : Countable G\nβ : Type u_6\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace.PseudoMetrizableSpace β\nhs : MeasureTheory.IsFundamentalDomain G s μ\nht : MeasureTheory.IsFundamentalDomain G t μ\nf : α → β\nhf : ∀ (g : G) (x : α), Eq (f (HSMul.hSMul g x)) (f x)\n⊢ Iff (MeasureTheory.AEStronglyMeasurable f (μ.restrict s)) (MeasureTheory.AEStronglyMeasurable f (μ.restrict t))","decl":"@[to_additive]\nprotected theorem aEStronglyMeasurable_on_iff {β : Type*} [TopologicalSpace β]\n    [PseudoMetrizableSpace β] (hs : IsFundamentalDomain G s μ) (ht : IsFundamentalDomain G t μ)\n    {f : α → β} (hf : ∀ (g : G) (x), f (g • x) = f x) :\n    AEStronglyMeasurable f (μ.restrict s) ↔ AEStronglyMeasurable f (μ.restrict t) :=\n  calc\n    AEStronglyMeasurable f (μ.restrict s) ↔\n        AEStronglyMeasurable f (Measure.sum fun g : G => μ.restrict (g • t ∩ s)) := by\n      simp only [← ht.restrict_restrict,\n        ht.sum_restrict_of_ac restrict_le_self.absolutelyContinuous]\n    _ ↔ ∀ g : G, AEStronglyMeasurable f (μ.restrict (g • (g⁻¹ • s ∩ t))) := by\n      simp only [smul_set_inter, inter_comm, smul_inv_smul, aestronglyMeasurable_sum_measure_iff]\n    _ ↔ ∀ g : G, AEStronglyMeasurable f (μ.restrict (g⁻¹ • (g⁻¹⁻¹ • s ∩ t))) :=\n      inv_surjective.forall\n    _ ↔ ∀ g : G, AEStronglyMeasurable f (μ.restrict (g⁻¹ • (g • s ∩ t))) := by simp only [inv_inv]\n    _ ↔ ∀ g : G, AEStronglyMeasurable f (μ.restrict (g • s ∩ t)) := by\n      refine forall_congr' fun g => ?_\n      have he : MeasurableEmbedding (g⁻¹ • · : α → α) := measurableEmbedding_const_smul _\n      rw [← image_smul, ← ((measurePreserving_smul g⁻¹ μ).restrict_image_emb he\n        _).aestronglyMeasurable_comp_iff he]\n      simp only [Function.comp_def, hf]\n    _ ↔ AEStronglyMeasurable f (μ.restrict t) := by\n      simp only [← aestronglyMeasurable_sum_measure_iff, ← hs.restrict_restrict,\n        hs.sum_restrict_of_ac restrict_le_self.absolutelyContinuous]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.aEStronglyMeasurable_on_iff","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁸ : AddGroup G\ninst✝⁷ : AddAction G α\ninst✝⁶ : MeasurableSpace α\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : MeasurableVAdd G α\ninst✝³ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝² : Countable G\nβ : Type u_6\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace.PseudoMetrizableSpace β\nhs : MeasureTheory.IsAddFundamentalDomain G s μ\nht : MeasureTheory.IsAddFundamentalDomain G t μ\nf : α → β\nhf : ∀ (g : G) (x : α), Eq (f (HVAdd.hVAdd g x)) (f x)\n⊢ Iff (MeasureTheory.AEStronglyMeasurable f (μ.restrict s)) (MeasureTheory.AEStronglyMeasurable f (μ.restrict t))","decl":"@[to_additive]\nprotected theorem aEStronglyMeasurable_on_iff {β : Type*} [TopologicalSpace β]\n    [PseudoMetrizableSpace β] (hs : IsFundamentalDomain G s μ) (ht : IsFundamentalDomain G t μ)\n    {f : α → β} (hf : ∀ (g : G) (x), f (g • x) = f x) :\n    AEStronglyMeasurable f (μ.restrict s) ↔ AEStronglyMeasurable f (μ.restrict t) :=\n  calc\n    AEStronglyMeasurable f (μ.restrict s) ↔\n        AEStronglyMeasurable f (Measure.sum fun g : G => μ.restrict (g • t ∩ s)) := by\n      simp only [← ht.restrict_restrict,\n        ht.sum_restrict_of_ac restrict_le_self.absolutelyContinuous]\n    _ ↔ ∀ g : G, AEStronglyMeasurable f (μ.restrict (g • (g⁻¹ • s ∩ t))) := by\n      simp only [smul_set_inter, inter_comm, smul_inv_smul, aestronglyMeasurable_sum_measure_iff]\n    _ ↔ ∀ g : G, AEStronglyMeasurable f (μ.restrict (g⁻¹ • (g⁻¹⁻¹ • s ∩ t))) :=\n      inv_surjective.forall\n    _ ↔ ∀ g : G, AEStronglyMeasurable f (μ.restrict (g⁻¹ • (g • s ∩ t))) := by simp only [inv_inv]\n    _ ↔ ∀ g : G, AEStronglyMeasurable f (μ.restrict (g • s ∩ t)) := by\n      refine forall_congr' fun g => ?_\n      have he : MeasurableEmbedding (g⁻¹ • · : α → α) := measurableEmbedding_const_smul _\n      rw [← image_smul, ← ((measurePreserving_smul g⁻¹ μ).restrict_image_emb he\n        _).aestronglyMeasurable_comp_iff he]\n      simp only [Function.comp_def, hf]\n    _ ↔ AEStronglyMeasurable f (μ.restrict t) := by\n      simp only [← aestronglyMeasurable_sum_measure_iff, ← hs.restrict_restrict,\n        hs.sum_restrict_of_ac restrict_le_self.absolutelyContinuous]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.hasFiniteIntegral_on_iff","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁷ : Group G\ninst✝⁶ : MulAction G α\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : NormedAddCommGroup E\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsFundamentalDomain G s μ\nht : MeasureTheory.IsFundamentalDomain G t μ\nf : α → E\nhf : ∀ (g : G) (x : α), Eq (f (HSMul.hSMul g x)) (f x)\n⊢ Iff (MeasureTheory.HasFiniteIntegral f (μ.restrict s)) (MeasureTheory.HasFiniteIntegral f (μ.restrict t))","decl":"@[to_additive]\nprotected theorem hasFiniteIntegral_on_iff (hs : IsFundamentalDomain G s μ)\n    (ht : IsFundamentalDomain G t μ) {f : α → E} (hf : ∀ (g : G) (x), f (g • x) = f x) :\n    HasFiniteIntegral f (μ.restrict s) ↔ HasFiniteIntegral f (μ.restrict t) := by\n  dsimp only [HasFiniteIntegral]\n  rw [hs.setLIntegral_eq ht]\n  intro g x; rw [hf]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.hasFiniteIntegral_on_iff","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁷ : AddGroup G\ninst✝⁶ : AddAction G α\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : NormedAddCommGroup E\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsAddFundamentalDomain G s μ\nht : MeasureTheory.IsAddFundamentalDomain G t μ\nf : α → E\nhf : ∀ (g : G) (x : α), Eq (f (HVAdd.hVAdd g x)) (f x)\n⊢ Iff (MeasureTheory.HasFiniteIntegral f (μ.restrict s)) (MeasureTheory.HasFiniteIntegral f (μ.restrict t))","decl":"@[to_additive]\nprotected theorem hasFiniteIntegral_on_iff (hs : IsFundamentalDomain G s μ)\n    (ht : IsFundamentalDomain G t μ) {f : α → E} (hf : ∀ (g : G) (x), f (g • x) = f x) :\n    HasFiniteIntegral f (μ.restrict s) ↔ HasFiniteIntegral f (μ.restrict t) := by\n  dsimp only [HasFiniteIntegral]\n  rw [hs.setLIntegral_eq ht]\n  intro g x; rw [hf]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.integrableOn_iff","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁷ : Group G\ninst✝⁶ : MulAction G α\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : NormedAddCommGroup E\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsFundamentalDomain G s μ\nht : MeasureTheory.IsFundamentalDomain G t μ\nf : α → E\nhf : ∀ (g : G) (x : α), Eq (f (HSMul.hSMul g x)) (f x)\n⊢ Iff (MeasureTheory.IntegrableOn f s μ) (MeasureTheory.IntegrableOn f t μ)","decl":"@[to_additive]\nprotected theorem integrableOn_iff (hs : IsFundamentalDomain G s μ) (ht : IsFundamentalDomain G t μ)\n    {f : α → E} (hf : ∀ (g : G) (x), f (g • x) = f x) : IntegrableOn f s μ ↔ IntegrableOn f t μ :=\n  and_congr (hs.aEStronglyMeasurable_on_iff ht hf) (hs.hasFiniteIntegral_on_iff ht hf)\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.integrableOn_iff","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁷ : AddGroup G\ninst✝⁶ : AddAction G α\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : NormedAddCommGroup E\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsAddFundamentalDomain G s μ\nht : MeasureTheory.IsAddFundamentalDomain G t μ\nf : α → E\nhf : ∀ (g : G) (x : α), Eq (f (HVAdd.hVAdd g x)) (f x)\n⊢ Iff (MeasureTheory.IntegrableOn f s μ) (MeasureTheory.IntegrableOn f t μ)","decl":"@[to_additive]\nprotected theorem integrableOn_iff (hs : IsFundamentalDomain G s μ) (ht : IsFundamentalDomain G t μ)\n    {f : α → E} (hf : ∀ (g : G) (x), f (g • x) = f x) : IntegrableOn f s μ ↔ IntegrableOn f t μ :=\n  and_congr (hs.aEStronglyMeasurable_on_iff ht hf) (hs.hasFiniteIntegral_on_iff ht hf)\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.integral_eq_tsum_of_ac","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : AddGroup G\ninst✝⁷ : AddAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableVAdd G α\ninst✝² : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝¹ : Countable G\nν : MeasureTheory.Measure α\ninst✝ : NormedSpace Real E\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nhν : ν.AbsolutelyContinuous μ\nf : α → E\nhf : MeasureTheory.Integrable f ν\n⊢ Eq (MeasureTheory.integral ν fun x => f x) (tsum fun g => MeasureTheory.integral (ν.restrict (HVAdd.hVAdd g s)) fun x => f x)","decl":"@[to_additive]\ntheorem integral_eq_tsum_of_ac (h : IsFundamentalDomain G s μ) (hν : ν ≪ μ) (f : α → E)\n    (hf : Integrable f ν) : ∫ x, f x ∂ν = ∑' g : G, ∫ x in g • s, f x ∂ν := by\n  rw [← MeasureTheory.integral_sum_measure, h.sum_restrict_of_ac hν]\n  rw [h.sum_restrict_of_ac hν]\n  exact hf\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.integral_eq_tsum_of_ac","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : Group G\ninst✝⁷ : MulAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSMul G α\ninst✝² : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝¹ : Countable G\nν : MeasureTheory.Measure α\ninst✝ : NormedSpace Real E\nh : MeasureTheory.IsFundamentalDomain G s μ\nhν : ν.AbsolutelyContinuous μ\nf : α → E\nhf : MeasureTheory.Integrable f ν\n⊢ Eq (MeasureTheory.integral ν fun x => f x) (tsum fun g => MeasureTheory.integral (ν.restrict (HSMul.hSMul g s)) fun x => f x)","decl":"@[to_additive]\ntheorem integral_eq_tsum_of_ac (h : IsFundamentalDomain G s μ) (hν : ν ≪ μ) (f : α → E)\n    (hf : Integrable f ν) : ∫ x, f x ∂ν = ∑' g : G, ∫ x in g • s, f x ∂ν := by\n  rw [← MeasureTheory.integral_sum_measure, h.sum_restrict_of_ac hν]\n  rw [h.sum_restrict_of_ac hν]\n  exact hf\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.integral_eq_tsum","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : Group G\ninst✝⁷ : MulAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSMul G α\ninst✝² : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : NormedSpace Real E\nh : MeasureTheory.IsFundamentalDomain G s μ\nf : α → E\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (MeasureTheory.integral μ fun x => f x) (tsum fun g => MeasureTheory.integral (μ.restrict (HSMul.hSMul g s)) fun x => f x)","decl":"@[to_additive]\ntheorem integral_eq_tsum (h : IsFundamentalDomain G s μ) (f : α → E) (hf : Integrable f μ) :\n    ∫ x, f x ∂μ = ∑' g : G, ∫ x in g • s, f x ∂μ :=\n  integral_eq_tsum_of_ac h (by rfl) f hf\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.integral_eq_tsum","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : AddGroup G\ninst✝⁷ : AddAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableVAdd G α\ninst✝² : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : NormedSpace Real E\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nf : α → E\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (MeasureTheory.integral μ fun x => f x) (tsum fun g => MeasureTheory.integral (μ.restrict (HVAdd.hVAdd g s)) fun x => f x)","decl":"@[to_additive]\ntheorem integral_eq_tsum (h : IsFundamentalDomain G s μ) (f : α → E) (hf : Integrable f μ) :\n    ∫ x, f x ∂μ = ∑' g : G, ∫ x in g • s, f x ∂μ :=\n  integral_eq_tsum_of_ac h (by rfl) f hf\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.integral_eq_tsum'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : Group G\ninst✝⁷ : MulAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSMul G α\ninst✝² : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : NormedSpace Real E\nh : MeasureTheory.IsFundamentalDomain G s μ\nf : α → E\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (MeasureTheory.integral μ fun x => f x) (tsum fun g => MeasureTheory.integral (μ.restrict s) fun x => f (HSMul.hSMul (Inv.inv g) x))","decl":"@[to_additive]\ntheorem integral_eq_tsum' (h : IsFundamentalDomain G s μ) (f : α → E) (hf : Integrable f μ) :\n    ∫ x, f x ∂μ = ∑' g : G, ∫ x in s, f (g⁻¹ • x) ∂μ :=\n  calc\n    ∫ x, f x ∂μ = ∑' g : G, ∫ x in g • s, f x ∂μ := h.integral_eq_tsum f hf\n    _ = ∑' g : G, ∫ x in g⁻¹ • s, f x ∂μ := ((Equiv.inv G).tsum_eq _).symm\n    _ = ∑' g : G, ∫ x in s, f (g⁻¹ • x) ∂μ := tsum_congr fun g =>\n      (measurePreserving_smul g⁻¹ μ).setIntegral_image_emb (measurableEmbedding_const_smul _) _ _\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.integral_eq_tsum'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : AddGroup G\ninst✝⁷ : AddAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableVAdd G α\ninst✝² : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : NormedSpace Real E\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nf : α → E\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (MeasureTheory.integral μ fun x => f x) (tsum fun g => MeasureTheory.integral (μ.restrict s) fun x => f (HVAdd.hVAdd (Neg.neg g) x))","decl":"@[to_additive]\ntheorem integral_eq_tsum' (h : IsFundamentalDomain G s μ) (f : α → E) (hf : Integrable f μ) :\n    ∫ x, f x ∂μ = ∑' g : G, ∫ x in s, f (g⁻¹ • x) ∂μ :=\n  calc\n    ∫ x, f x ∂μ = ∑' g : G, ∫ x in g • s, f x ∂μ := h.integral_eq_tsum f hf\n    _ = ∑' g : G, ∫ x in g⁻¹ • s, f x ∂μ := ((Equiv.inv G).tsum_eq _).symm\n    _ = ∑' g : G, ∫ x in s, f (g⁻¹ • x) ∂μ := tsum_congr fun g =>\n      (measurePreserving_smul g⁻¹ μ).setIntegral_image_emb (measurableEmbedding_const_smul _) _ _\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.integral_eq_tsum''","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : Group G\ninst✝⁷ : MulAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSMul G α\ninst✝² : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : NormedSpace Real E\nh : MeasureTheory.IsFundamentalDomain G s μ\nf : α → E\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (MeasureTheory.integral μ fun x => f x) (tsum fun g => MeasureTheory.integral (μ.restrict s) fun x => f (HSMul.hSMul g x))","decl":"@[to_additive] lemma integral_eq_tsum'' (h : IsFundamentalDomain G s μ)\n    (f : α → E) (hf : Integrable f μ) : ∫ x, f x ∂μ = ∑' g : G, ∫ x in s, f (g • x) ∂μ :=\n  (integral_eq_tsum' h f hf).trans ((Equiv.inv G).tsum_eq (fun g ↦ ∫ (x : α) in s, f (g • x) ∂μ))\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.integral_eq_tsum''","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : AddGroup G\ninst✝⁷ : AddAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableVAdd G α\ninst✝² : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : NormedSpace Real E\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nf : α → E\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (MeasureTheory.integral μ fun x => f x) (tsum fun g => MeasureTheory.integral (μ.restrict s) fun x => f (HVAdd.hVAdd g x))","decl":"@[to_additive] lemma integral_eq_tsum'' (h : IsFundamentalDomain G s μ)\n    (f : α → E) (hf : Integrable f μ) : ∫ x, f x ∂μ = ∑' g : G, ∫ x in s, f (g • x) ∂μ :=\n  (integral_eq_tsum' h f hf).trans ((Equiv.inv G).tsum_eq (fun g ↦ ∫ (x : α) in s, f (g • x) ∂μ))\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.setIntegral_eq_tsum","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : Group G\ninst✝⁷ : MulAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSMul G α\ninst✝² : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : NormedSpace Real E\nh : MeasureTheory.IsFundamentalDomain G s μ\nf : α → E\nt : Set α\nhf : MeasureTheory.IntegrableOn f t μ\n⊢ Eq (MeasureTheory.integral (μ.restrict t) fun x => f x) (tsum fun g => MeasureTheory.integral (μ.restrict (Inter.inter t (HSMul.hSMul g s))) fun x => f x)","decl":"@[to_additive]\ntheorem setIntegral_eq_tsum (h : IsFundamentalDomain G s μ) {f : α → E} {t : Set α}\n    (hf : IntegrableOn f t μ) : ∫ x in t, f x ∂μ = ∑' g : G, ∫ x in t ∩ g • s, f x ∂μ :=\n  calc\n    ∫ x in t, f x ∂μ = ∑' g : G, ∫ x in g • s, f x ∂μ.restrict t :=\n      h.integral_eq_tsum_of_ac restrict_le_self.absolutelyContinuous f hf\n    _ = ∑' g : G, ∫ x in t ∩ g • s, f x ∂μ := by\n      simp only [h.restrict_restrict, measure_smul, inter_comm]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.setIntegral_eq_tsum","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : AddGroup G\ninst✝⁷ : AddAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableVAdd G α\ninst✝² : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : NormedSpace Real E\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nf : α → E\nt : Set α\nhf : MeasureTheory.IntegrableOn f t μ\n⊢ Eq (MeasureTheory.integral (μ.restrict t) fun x => f x) (tsum fun g => MeasureTheory.integral (μ.restrict (Inter.inter t (HVAdd.hVAdd g s))) fun x => f x)","decl":"@[to_additive]\ntheorem setIntegral_eq_tsum (h : IsFundamentalDomain G s μ) {f : α → E} {t : Set α}\n    (hf : IntegrableOn f t μ) : ∫ x in t, f x ∂μ = ∑' g : G, ∫ x in t ∩ g • s, f x ∂μ :=\n  calc\n    ∫ x in t, f x ∂μ = ∑' g : G, ∫ x in g • s, f x ∂μ.restrict t :=\n      h.integral_eq_tsum_of_ac restrict_le_self.absolutelyContinuous f hf\n    _ = ∑' g : G, ∫ x in t ∩ g • s, f x ∂μ := by\n      simp only [h.restrict_restrict, measure_smul, inter_comm]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.setIntegral_eq_tsum'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : AddGroup G\ninst✝⁷ : AddAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableVAdd G α\ninst✝² : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : NormedSpace Real E\nh : MeasureTheory.IsAddFundamentalDomain G s μ\nf : α → E\nt : Set α\nhf : MeasureTheory.IntegrableOn f t μ\n⊢ Eq (MeasureTheory.integral (μ.restrict t) fun x => f x) (tsum fun g => MeasureTheory.integral (μ.restrict (Inter.inter (HVAdd.hVAdd g t) s)) fun x => f (HVAdd.hVAdd (Neg.neg g) x))","decl":"@[to_additive]\ntheorem setIntegral_eq_tsum' (h : IsFundamentalDomain G s μ) {f : α → E} {t : Set α}\n    (hf : IntegrableOn f t μ) : ∫ x in t, f x ∂μ = ∑' g : G, ∫ x in g • t ∩ s, f (g⁻¹ • x) ∂μ :=\n  calc\n    ∫ x in t, f x ∂μ = ∑' g : G, ∫ x in t ∩ g • s, f x ∂μ := h.setIntegral_eq_tsum hf\n    _ = ∑' g : G, ∫ x in t ∩ g⁻¹ • s, f x ∂μ := ((Equiv.inv G).tsum_eq _).symm\n    _ = ∑' g : G, ∫ x in g⁻¹ • (g • t ∩ s), f x ∂μ := by simp only [smul_set_inter, inv_smul_smul]\n    _ = ∑' g : G, ∫ x in g • t ∩ s, f (g⁻¹ • x) ∂μ :=\n      tsum_congr fun g =>\n        (measurePreserving_smul g⁻¹ μ).setIntegral_image_emb (measurableEmbedding_const_smul _) _ _\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.setIntegral_eq_tsum'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : Group G\ninst✝⁷ : MulAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSMul G α\ninst✝² : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : NormedSpace Real E\nh : MeasureTheory.IsFundamentalDomain G s μ\nf : α → E\nt : Set α\nhf : MeasureTheory.IntegrableOn f t μ\n⊢ Eq (MeasureTheory.integral (μ.restrict t) fun x => f x) (tsum fun g => MeasureTheory.integral (μ.restrict (Inter.inter (HSMul.hSMul g t) s)) fun x => f (HSMul.hSMul (Inv.inv g) x))","decl":"@[to_additive]\ntheorem setIntegral_eq_tsum' (h : IsFundamentalDomain G s μ) {f : α → E} {t : Set α}\n    (hf : IntegrableOn f t μ) : ∫ x in t, f x ∂μ = ∑' g : G, ∫ x in g • t ∩ s, f (g⁻¹ • x) ∂μ :=\n  calc\n    ∫ x in t, f x ∂μ = ∑' g : G, ∫ x in t ∩ g • s, f x ∂μ := h.setIntegral_eq_tsum hf\n    _ = ∑' g : G, ∫ x in t ∩ g⁻¹ • s, f x ∂μ := ((Equiv.inv G).tsum_eq _).symm\n    _ = ∑' g : G, ∫ x in g⁻¹ • (g • t ∩ s), f x ∂μ := by simp only [smul_set_inter, inv_smul_smul]\n    _ = ∑' g : G, ∫ x in g • t ∩ s, f (g⁻¹ • x) ∂μ :=\n      tsum_congr fun g =>\n        (measurePreserving_smul g⁻¹ μ).setIntegral_image_emb (measurableEmbedding_const_smul _) _ _\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.setIntegral_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : Group G\ninst✝⁷ : MulAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableSMul G α\ninst✝² : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : NormedSpace Real E\nhs : MeasureTheory.IsFundamentalDomain G s μ\nht : MeasureTheory.IsFundamentalDomain G t μ\nf : α → E\nhf : ∀ (g : G) (x : α), Eq (f (HSMul.hSMul g x)) (f x)\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict t) fun x => f x)","decl":"@[to_additive]\nprotected theorem setIntegral_eq (hs : IsFundamentalDomain G s μ) (ht : IsFundamentalDomain G t μ)\n    {f : α → E} (hf : ∀ (g : G) (x), f (g • x) = f x) : ∫ x in s, f x ∂μ = ∫ x in t, f x ∂μ := by\n  by_cases hfs : IntegrableOn f s μ\n  · have hft : IntegrableOn f t μ := by rwa [ht.integrableOn_iff hs hf]\n    calc\n      ∫ x in s, f x ∂μ = ∑' g : G, ∫ x in s ∩ g • t, f x ∂μ := ht.setIntegral_eq_tsum hfs\n      _ = ∑' g : G, ∫ x in g • t ∩ s, f (g⁻¹ • x) ∂μ := by simp only [hf, inter_comm]\n      _ = ∫ x in t, f x ∂μ := (hs.setIntegral_eq_tsum' hft).symm\n  · rw [integral_undef hfs, integral_undef]\n    rwa [hs.integrableOn_iff ht hf] at hfs\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.setIntegral_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\nE : Type u_5\ninst✝⁸ : AddGroup G\ninst✝⁷ : AddAction G α\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : NormedAddCommGroup E\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasurableSpace G\ninst✝³ : MeasurableVAdd G α\ninst✝² : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝¹ : Countable G\ninst✝ : NormedSpace Real E\nhs : MeasureTheory.IsAddFundamentalDomain G s μ\nht : MeasureTheory.IsAddFundamentalDomain G t μ\nf : α → E\nhf : ∀ (g : G) (x : α), Eq (f (HVAdd.hVAdd g x)) (f x)\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict t) fun x => f x)","decl":"@[to_additive]\nprotected theorem setIntegral_eq (hs : IsFundamentalDomain G s μ) (ht : IsFundamentalDomain G t μ)\n    {f : α → E} (hf : ∀ (g : G) (x), f (g • x) = f x) : ∫ x in s, f x ∂μ = ∫ x in t, f x ∂μ := by\n  by_cases hfs : IntegrableOn f s μ\n  · have hft : IntegrableOn f t μ := by rwa [ht.integrableOn_iff hs hf]\n    calc\n      ∫ x in s, f x ∂μ = ∑' g : G, ∫ x in s ∩ g • t, f x ∂μ := ht.setIntegral_eq_tsum hfs\n      _ = ∑' g : G, ∫ x in g • t ∩ s, f (g⁻¹ • x) ∂μ := by simp only [hf, inter_comm]\n      _ = ∫ x in t, f x ∂μ := (hs.setIntegral_eq_tsum' hft).symm\n  · rw [integral_undef hfs, integral_undef]\n    rwa [hs.integrableOn_iff ht hf] at hfs\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.measure_le_of_pairwise_disjoint","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsFundamentalDomain G s μ\nht : MeasureTheory.NullMeasurableSet t μ\nhd : Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) fun g => Inter.inter (HSMul.hSMul g t) s)\n⊢ LE.le (μ t) (μ s)","decl":"/-- If the action of a countable group `G` admits an invariant measure `μ` with a fundamental domain\n`s`, then every null-measurable set `t` such that the sets `g • t ∩ s` are pairwise a.e.-disjoint\nhas measure at most `μ s`. -/\n@[to_additive \"If the additive action of a countable group `G` admits an invariant measure `μ` with\n  a fundamental domain `s`, then every null-measurable set `t` such that the sets `g +ᵥ t ∩ s` are\n  pairwise a.e.-disjoint has measure at most `μ s`.\"]\ntheorem measure_le_of_pairwise_disjoint (hs : IsFundamentalDomain G s μ)\n    (ht : NullMeasurableSet t μ) (hd : Pairwise (AEDisjoint μ on fun g : G => g • t ∩ s)) :\n    μ t ≤ μ s :=\n  calc\n    μ t = ∑' g : G, μ (g • t ∩ s) := hs.measure_eq_tsum t\n    _ = μ (⋃ g : G, g • t ∩ s) := Eq.symm <| measure_iUnion₀ hd fun _ =>\n      (ht.smul _).inter hs.nullMeasurableSet\n    _ ≤ μ s := measure_mono (iUnion_subset fun _ => inter_subset_right)\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.measure_le_of_pairwise_disjoint","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsAddFundamentalDomain G s μ\nht : MeasureTheory.NullMeasurableSet t μ\nhd : Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) fun g => Inter.inter (HVAdd.hVAdd g t) s)\n⊢ LE.le (μ t) (μ s)","decl":"/-- If the action of a countable group `G` admits an invariant measure `μ` with a fundamental domain\n`s`, then every null-measurable set `t` such that the sets `g • t ∩ s` are pairwise a.e.-disjoint\nhas measure at most `μ s`. -/\n@[to_additive \"If the additive action of a countable group `G` admits an invariant measure `μ` with\n  a fundamental domain `s`, then every null-measurable set `t` such that the sets `g +ᵥ t ∩ s` are\n  pairwise a.e.-disjoint has measure at most `μ s`.\"]\ntheorem measure_le_of_pairwise_disjoint (hs : IsFundamentalDomain G s μ)\n    (ht : NullMeasurableSet t μ) (hd : Pairwise (AEDisjoint μ on fun g : G => g • t ∩ s)) :\n    μ t ≤ μ s :=\n  calc\n    μ t = ∑' g : G, μ (g • t ∩ s) := hs.measure_eq_tsum t\n    _ = μ (⋃ g : G, g • t ∩ s) := Eq.symm <| measure_iUnion₀ hd fun _ =>\n      (ht.smul _).inter hs.nullMeasurableSet\n    _ ≤ μ s := measure_mono (iUnion_subset fun _ => inter_subset_right)\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.exists_ne_one_smul_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsFundamentalDomain G s μ\nhtm : MeasureTheory.NullMeasurableSet t μ\nht : LT.lt (μ s) (μ t)\n⊢ Exists fun x => And (Membership.mem t x) (Exists fun y => And (Membership.mem t y) (Exists fun g => And (Ne g 1) (Eq (HSMul.hSMul g x) y)))","decl":"/-- If the action of a countable group `G` admits an invariant measure `μ` with a fundamental domain\n`s`, then every null-measurable set `t` of measure strictly greater than `μ s` contains two\npoints `x y` such that `g • x = y` for some `g ≠ 1`. -/\n@[to_additive \"If the additive action of a countable group `G` admits an invariant measure `μ` with\n  a fundamental domain `s`, then every null-measurable set `t` of measure strictly greater than\n  `μ s` contains two points `x y` such that `g +ᵥ x = y` for some `g ≠ 0`.\"]\ntheorem exists_ne_one_smul_eq (hs : IsFundamentalDomain G s μ) (htm : NullMeasurableSet t μ)\n    (ht : μ s < μ t) : ∃ x ∈ t, ∃ y ∈ t, ∃ g, g ≠ (1 : G) ∧ g • x = y := by\n  contrapose! ht\n  refine hs.measure_le_of_pairwise_disjoint htm (Pairwise.aedisjoint fun g₁ g₂ hne => ?_)\n  dsimp [Function.onFun]\n  refine (Disjoint.inf_left _ ?_).inf_right _\n  rw [Set.disjoint_left]\n  rintro _ ⟨x, hx, rfl⟩ ⟨y, hy, hxy : g₂ • y = g₁ • x⟩\n  refine ht x hx y hy (g₂⁻¹ * g₁) (mt inv_mul_eq_one.1 hne.symm) ?_\n  rw [mul_smul, ← hxy, inv_smul_smul]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.exists_ne_zero_vadd_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns t : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsAddFundamentalDomain G s μ\nhtm : MeasureTheory.NullMeasurableSet t μ\nht : LT.lt (μ s) (μ t)\n⊢ Exists fun x => And (Membership.mem t x) (Exists fun y => And (Membership.mem t y) (Exists fun g => And (Ne g 0) (Eq (HVAdd.hVAdd g x) y)))","decl":"/-- If the action of a countable group `G` admits an invariant measure `μ` with a fundamental domain\n`s`, then every null-measurable set `t` of measure strictly greater than `μ s` contains two\npoints `x y` such that `g • x = y` for some `g ≠ 1`. -/\n@[to_additive \"If the additive action of a countable group `G` admits an invariant measure `μ` with\n  a fundamental domain `s`, then every null-measurable set `t` of measure strictly greater than\n  `μ s` contains two points `x y` such that `g +ᵥ x = y` for some `g ≠ 0`.\"]\ntheorem exists_ne_one_smul_eq (hs : IsFundamentalDomain G s μ) (htm : NullMeasurableSet t μ)\n    (ht : μ s < μ t) : ∃ x ∈ t, ∃ y ∈ t, ∃ g, g ≠ (1 : G) ∧ g • x = y := by\n  contrapose! ht\n  refine hs.measure_le_of_pairwise_disjoint htm (Pairwise.aedisjoint fun g₁ g₂ hne => ?_)\n  dsimp [Function.onFun]\n  refine (Disjoint.inf_left _ ?_).inf_right _\n  rw [Set.disjoint_left]\n  rintro _ ⟨x, hx, rfl⟩ ⟨y, hy, hxy : g₂ • y = g₁ • x⟩\n  refine ht x hx y hy (g₂⁻¹ * g₁) (mt inv_mul_eq_one.1 hne.symm) ?_\n  rw [mul_smul, ← hxy, inv_smul_smul]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.essSup_measure_restrict","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsFundamentalDomain G s μ\nf : α → ENNReal\nhf : ∀ (γ : G) (x : α), Eq (f (HSMul.hSMul γ x)) (f x)\n⊢ Eq (essSup f (μ.restrict s)) (essSup f μ)","decl":"/-- If `f` is invariant under the action of a countable group `G`, and `μ` is a `G`-invariant\n  measure with a fundamental domain `s`, then the `essSup` of `f` restricted to `s` is the same as\n  that of `f` on all of its domain. -/\n@[to_additive \"If `f` is invariant under the action of a countable additive group `G`, and `μ` is a\n  `G`-invariant measure with a fundamental domain `s`, then the `essSup` of `f` restricted to `s`\n  is the same as that of `f` on all of its domain.\"]\ntheorem essSup_measure_restrict (hs : IsFundamentalDomain G s μ) {f : α → ℝ≥0∞}\n    (hf : ∀ γ : G, ∀ x : α, f (γ • x) = f x) : essSup f (μ.restrict s) = essSup f μ := by\n  refine le_antisymm (essSup_mono_measure' Measure.restrict_le_self) ?_\n  rw [essSup_eq_sInf (μ.restrict s) f, essSup_eq_sInf μ f]\n  refine sInf_le_sInf ?_\n  rintro a (ha : (μ.restrict s) {x : α | a < f x} = 0)\n  rw [Measure.restrict_apply₀' hs.nullMeasurableSet] at ha\n  refine measure_zero_of_invariant hs _ ?_ ha\n  intro γ\n  ext x\n  rw [mem_smul_set_iff_inv_smul_mem]\n  simp only [mem_setOf_eq, hf γ⁻¹ x]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.essSup_measure_restrict","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\ns : Set α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : Countable G\nhs : MeasureTheory.IsAddFundamentalDomain G s μ\nf : α → ENNReal\nhf : ∀ (γ : G) (x : α), Eq (f (HVAdd.hVAdd γ x)) (f x)\n⊢ Eq (essSup f (μ.restrict s)) (essSup f μ)","decl":"/-- If `f` is invariant under the action of a countable group `G`, and `μ` is a `G`-invariant\n  measure with a fundamental domain `s`, then the `essSup` of `f` restricted to `s` is the same as\n  that of `f` on all of its domain. -/\n@[to_additive \"If `f` is invariant under the action of a countable additive group `G`, and `μ` is a\n  `G`-invariant measure with a fundamental domain `s`, then the `essSup` of `f` restricted to `s`\n  is the same as that of `f` on all of its domain.\"]\ntheorem essSup_measure_restrict (hs : IsFundamentalDomain G s μ) {f : α → ℝ≥0∞}\n    (hf : ∀ γ : G, ∀ x : α, f (γ • x) = f x) : essSup f (μ.restrict s) = essSup f μ := by\n  refine le_antisymm (essSup_mono_measure' Measure.restrict_le_self) ?_\n  rw [essSup_eq_sInf (μ.restrict s) f, essSup_eq_sInf μ f]\n  refine sInf_le_sInf ?_\n  rintro a (ha : (μ.restrict s) {x : α | a < f x} = 0)\n  rw [Measure.restrict_apply₀' hs.nullMeasurableSet] at ha\n  refine measure_zero_of_invariant hs _ ?_ ha\n  intro γ\n  ext x\n  rw [mem_smul_set_iff_inv_smul_mem]\n  simp only [mem_setOf_eq, hf γ⁻¹ x]\n\n"}
{"name":"MeasureTheory.mem_fundamentalFrontier","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\nx : α\n⊢ Iff (Membership.mem (MeasureTheory.fundamentalFrontier G s) x) (And (Membership.mem s x) (Exists fun g => And (Ne g 1) (Membership.mem (HSMul.hSMul g s) x)))","decl":"@[to_additive (attr := simp) MeasureTheory.mem_addFundamentalFrontier]\ntheorem mem_fundamentalFrontier :\n    x ∈ fundamentalFrontier G s ↔ x ∈ s ∧ ∃ g : G, g ≠ 1 ∧ x ∈ g • s := by\n  simp [fundamentalFrontier]\n\n"}
{"name":"MeasureTheory.mem_addFundamentalFrontier","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ns : Set α\nx : α\n⊢ Iff (Membership.mem (MeasureTheory.addFundamentalFrontier G s) x) (And (Membership.mem s x) (Exists fun g => And (Ne g 0) (Membership.mem (HVAdd.hVAdd g s) x)))","decl":"@[to_additive (attr := simp) MeasureTheory.mem_addFundamentalFrontier]\ntheorem mem_fundamentalFrontier :\n    x ∈ fundamentalFrontier G s ↔ x ∈ s ∧ ∃ g : G, g ≠ 1 ∧ x ∈ g • s := by\n  simp [fundamentalFrontier]\n\n"}
{"name":"MeasureTheory.mem_addFundamentalInterior","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ns : Set α\nx : α\n⊢ Iff (Membership.mem (MeasureTheory.addFundamentalInterior G s) x) (And (Membership.mem s x) (∀ (g : G), Ne g 0 → Not (Membership.mem (HVAdd.hVAdd g s) x)))","decl":"@[to_additive (attr := simp) MeasureTheory.mem_addFundamentalInterior]\ntheorem mem_fundamentalInterior :\n    x ∈ fundamentalInterior G s ↔ x ∈ s ∧ ∀ g : G, g ≠ 1 → x ∉ g • s := by\n  simp [fundamentalInterior]\n\n"}
{"name":"MeasureTheory.mem_fundamentalInterior","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\nx : α\n⊢ Iff (Membership.mem (MeasureTheory.fundamentalInterior G s) x) (And (Membership.mem s x) (∀ (g : G), Ne g 1 → Not (Membership.mem (HSMul.hSMul g s) x)))","decl":"@[to_additive (attr := simp) MeasureTheory.mem_addFundamentalInterior]\ntheorem mem_fundamentalInterior :\n    x ∈ fundamentalInterior G s ↔ x ∈ s ∧ ∀ g : G, g ≠ 1 → x ∉ g • s := by\n  simp [fundamentalInterior]\n\n"}
{"name":"MeasureTheory.fundamentalFrontier_subset","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\n⊢ HasSubset.Subset (MeasureTheory.fundamentalFrontier G s) s","decl":"@[to_additive MeasureTheory.addFundamentalFrontier_subset]\ntheorem fundamentalFrontier_subset : fundamentalFrontier G s ⊆ s :=\n  inter_subset_left\n\n"}
{"name":"MeasureTheory.addFundamentalFrontier_subset","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ns : Set α\n⊢ HasSubset.Subset (MeasureTheory.addFundamentalFrontier G s) s","decl":"@[to_additive MeasureTheory.addFundamentalFrontier_subset]\ntheorem fundamentalFrontier_subset : fundamentalFrontier G s ⊆ s :=\n  inter_subset_left\n\n"}
{"name":"MeasureTheory.addFundamentalInterior_subset","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ns : Set α\n⊢ HasSubset.Subset (MeasureTheory.addFundamentalInterior G s) s","decl":"@[to_additive MeasureTheory.addFundamentalInterior_subset]\ntheorem fundamentalInterior_subset : fundamentalInterior G s ⊆ s :=\n  diff_subset\n\n"}
{"name":"MeasureTheory.fundamentalInterior_subset","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\n⊢ HasSubset.Subset (MeasureTheory.fundamentalInterior G s) s","decl":"@[to_additive MeasureTheory.addFundamentalInterior_subset]\ntheorem fundamentalInterior_subset : fundamentalInterior G s ⊆ s :=\n  diff_subset\n\n"}
{"name":"MeasureTheory.disjoint_addFundamentalInterior_addFundamentalFrontier","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ns : Set α\n⊢ Disjoint (MeasureTheory.addFundamentalInterior G s) (MeasureTheory.addFundamentalFrontier G s)","decl":"@[to_additive MeasureTheory.disjoint_addFundamentalInterior_addFundamentalFrontier]\ntheorem disjoint_fundamentalInterior_fundamentalFrontier :\n    Disjoint (fundamentalInterior G s) (fundamentalFrontier G s) :=\n  disjoint_sdiff_self_left.mono_right inf_le_right\n\n"}
{"name":"MeasureTheory.disjoint_fundamentalInterior_fundamentalFrontier","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\n⊢ Disjoint (MeasureTheory.fundamentalInterior G s) (MeasureTheory.fundamentalFrontier G s)","decl":"@[to_additive MeasureTheory.disjoint_addFundamentalInterior_addFundamentalFrontier]\ntheorem disjoint_fundamentalInterior_fundamentalFrontier :\n    Disjoint (fundamentalInterior G s) (fundamentalFrontier G s) :=\n  disjoint_sdiff_self_left.mono_right inf_le_right\n\n"}
{"name":"MeasureTheory.fundamentalInterior_union_fundamentalFrontier","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\n⊢ Eq (Union.union (MeasureTheory.fundamentalInterior G s) (MeasureTheory.fundamentalFrontier G s)) s","decl":"@[to_additive (attr := simp) MeasureTheory.addFundamentalInterior_union_addFundamentalFrontier]\ntheorem fundamentalInterior_union_fundamentalFrontier :\n    fundamentalInterior G s ∪ fundamentalFrontier G s = s :=\n  diff_union_inter _ _\n\n"}
{"name":"MeasureTheory.addFundamentalInterior_union_addFundamentalFrontier","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ns : Set α\n⊢ Eq (Union.union (MeasureTheory.addFundamentalInterior G s) (MeasureTheory.addFundamentalFrontier G s)) s","decl":"@[to_additive (attr := simp) MeasureTheory.addFundamentalInterior_union_addFundamentalFrontier]\ntheorem fundamentalInterior_union_fundamentalFrontier :\n    fundamentalInterior G s ∪ fundamentalFrontier G s = s :=\n  diff_union_inter _ _\n\n"}
{"name":"MeasureTheory.addFundamentalFrontier_union_addFundamentalInterior","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ns : Set α\n⊢ Eq (Union.union (MeasureTheory.addFundamentalFrontier G s) (MeasureTheory.addFundamentalInterior G s)) s","decl":"@[to_additive (attr := simp) MeasureTheory.addFundamentalFrontier_union_addFundamentalInterior]\ntheorem fundamentalFrontier_union_fundamentalInterior :\n    fundamentalFrontier G s ∪ fundamentalInterior G s = s :=\n  inter_union_diff _ _\n\n"}
{"name":"MeasureTheory.fundamentalFrontier_union_fundamentalInterior","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\n⊢ Eq (Union.union (MeasureTheory.fundamentalFrontier G s) (MeasureTheory.fundamentalInterior G s)) s","decl":"@[to_additive (attr := simp) MeasureTheory.addFundamentalFrontier_union_addFundamentalInterior]\ntheorem fundamentalFrontier_union_fundamentalInterior :\n    fundamentalFrontier G s ∪ fundamentalInterior G s = s :=\n  inter_union_diff _ _\n\n"}
{"name":"MeasureTheory.sdiff_fundamentalInterior","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\n⊢ Eq (SDiff.sdiff s (MeasureTheory.fundamentalInterior G s)) (MeasureTheory.fundamentalFrontier G s)","decl":"@[to_additive (attr := simp) MeasureTheory.sdiff_addFundamentalInterior]\ntheorem sdiff_fundamentalInterior : s \\ fundamentalInterior G s = fundamentalFrontier G s :=\n  sdiff_sdiff_right_self\n\n"}
{"name":"MeasureTheory.sdiff_addFundamentalInterior","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ns : Set α\n⊢ Eq (SDiff.sdiff s (MeasureTheory.addFundamentalInterior G s)) (MeasureTheory.addFundamentalFrontier G s)","decl":"@[to_additive (attr := simp) MeasureTheory.sdiff_addFundamentalInterior]\ntheorem sdiff_fundamentalInterior : s \\ fundamentalInterior G s = fundamentalFrontier G s :=\n  sdiff_sdiff_right_self\n\n"}
{"name":"MeasureTheory.sdiff_addFundamentalFrontier","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ns : Set α\n⊢ Eq (SDiff.sdiff s (MeasureTheory.addFundamentalFrontier G s)) (MeasureTheory.addFundamentalInterior G s)","decl":"@[to_additive (attr := simp) MeasureTheory.sdiff_addFundamentalFrontier]\ntheorem sdiff_fundamentalFrontier : s \\ fundamentalFrontier G s = fundamentalInterior G s :=\n  diff_self_inter\n\n"}
{"name":"MeasureTheory.sdiff_fundamentalFrontier","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\n⊢ Eq (SDiff.sdiff s (MeasureTheory.fundamentalFrontier G s)) (MeasureTheory.fundamentalInterior G s)","decl":"@[to_additive (attr := simp) MeasureTheory.sdiff_addFundamentalFrontier]\ntheorem sdiff_fundamentalFrontier : s \\ fundamentalFrontier G s = fundamentalInterior G s :=\n  diff_self_inter\n\n"}
{"name":"MeasureTheory.addFundamentalFrontier_vadd","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nH : Type u_2\nα : Type u_3\ninst✝⁴ : AddGroup G\ninst✝³ : AddAction G α\ns : Set α\ninst✝² : AddGroup H\ninst✝¹ : AddAction H α\ninst✝ : VAddCommClass H G α\ng : H\n⊢ Eq (MeasureTheory.addFundamentalFrontier G (HVAdd.hVAdd g s)) (HVAdd.hVAdd g (MeasureTheory.addFundamentalFrontier G s))","decl":"@[to_additive (attr := simp) MeasureTheory.addFundamentalFrontier_vadd]\ntheorem fundamentalFrontier_smul [Group H] [MulAction H α] [SMulCommClass H G α] (g : H) :\n    fundamentalFrontier G (g • s) = g • fundamentalFrontier G s := by\n  simp_rw [fundamentalFrontier, smul_set_inter, smul_set_iUnion, smul_comm g (_ : G) (_ : Set α)]\n\n"}
{"name":"MeasureTheory.fundamentalFrontier_smul","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nH : Type u_2\nα : Type u_3\ninst✝⁴ : Group G\ninst✝³ : MulAction G α\ns : Set α\ninst✝² : Group H\ninst✝¹ : MulAction H α\ninst✝ : SMulCommClass H G α\ng : H\n⊢ Eq (MeasureTheory.fundamentalFrontier G (HSMul.hSMul g s)) (HSMul.hSMul g (MeasureTheory.fundamentalFrontier G s))","decl":"@[to_additive (attr := simp) MeasureTheory.addFundamentalFrontier_vadd]\ntheorem fundamentalFrontier_smul [Group H] [MulAction H α] [SMulCommClass H G α] (g : H) :\n    fundamentalFrontier G (g • s) = g • fundamentalFrontier G s := by\n  simp_rw [fundamentalFrontier, smul_set_inter, smul_set_iUnion, smul_comm g (_ : G) (_ : Set α)]\n\n"}
{"name":"MeasureTheory.fundamentalInterior_smul","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nH : Type u_2\nα : Type u_3\ninst✝⁴ : Group G\ninst✝³ : MulAction G α\ns : Set α\ninst✝² : Group H\ninst✝¹ : MulAction H α\ninst✝ : SMulCommClass H G α\ng : H\n⊢ Eq (MeasureTheory.fundamentalInterior G (HSMul.hSMul g s)) (HSMul.hSMul g (MeasureTheory.fundamentalInterior G s))","decl":"@[to_additive (attr := simp) MeasureTheory.addFundamentalInterior_vadd]\ntheorem fundamentalInterior_smul [Group H] [MulAction H α] [SMulCommClass H G α] (g : H) :\n    fundamentalInterior G (g • s) = g • fundamentalInterior G s := by\n  simp_rw [fundamentalInterior, smul_set_sdiff, smul_set_iUnion, smul_comm g (_ : G) (_ : Set α)]\n\n"}
{"name":"MeasureTheory.addFundamentalInterior_vadd","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nH : Type u_2\nα : Type u_3\ninst✝⁴ : AddGroup G\ninst✝³ : AddAction G α\ns : Set α\ninst✝² : AddGroup H\ninst✝¹ : AddAction H α\ninst✝ : VAddCommClass H G α\ng : H\n⊢ Eq (MeasureTheory.addFundamentalInterior G (HVAdd.hVAdd g s)) (HVAdd.hVAdd g (MeasureTheory.addFundamentalInterior G s))","decl":"@[to_additive (attr := simp) MeasureTheory.addFundamentalInterior_vadd]\ntheorem fundamentalInterior_smul [Group H] [MulAction H α] [SMulCommClass H G α] (g : H) :\n    fundamentalInterior G (g • s) = g • fundamentalInterior G s := by\n  simp_rw [fundamentalInterior, smul_set_sdiff, smul_set_iUnion, smul_comm g (_ : G) (_ : Set α)]\n\n"}
{"name":"MeasureTheory.pairwise_disjoint_addFundamentalInterior","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ns : Set α\n⊢ Pairwise (Function.onFun Disjoint fun g => HVAdd.hVAdd g (MeasureTheory.addFundamentalInterior G s))","decl":"@[to_additive MeasureTheory.pairwise_disjoint_addFundamentalInterior]\ntheorem pairwise_disjoint_fundamentalInterior :\n    Pairwise (Disjoint on fun g : G => g • fundamentalInterior G s) := by\n  refine fun a b hab => disjoint_left.2 ?_\n  rintro _ ⟨x, hx, rfl⟩ ⟨y, hy, hxy⟩\n  rw [mem_fundamentalInterior] at hx hy\n  refine hx.2 (a⁻¹ * b) ?_ ?_\n  · rwa [Ne, inv_mul_eq_iff_eq_mul, mul_one, eq_comm]\n  · simpa [mul_smul, ← hxy, mem_inv_smul_set_iff] using hy.1\n\n"}
{"name":"MeasureTheory.pairwise_disjoint_fundamentalInterior","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\ns : Set α\n⊢ Pairwise (Function.onFun Disjoint fun g => HSMul.hSMul g (MeasureTheory.fundamentalInterior G s))","decl":"@[to_additive MeasureTheory.pairwise_disjoint_addFundamentalInterior]\ntheorem pairwise_disjoint_fundamentalInterior :\n    Pairwise (Disjoint on fun g : G => g • fundamentalInterior G s) := by\n  refine fun a b hab => disjoint_left.2 ?_\n  rintro _ ⟨x, hx, rfl⟩ ⟨y, hy, hxy⟩\n  rw [mem_fundamentalInterior] at hx hy\n  refine hx.2 (a⁻¹ * b) ?_ ?_\n  · rwa [Ne, inv_mul_eq_iff_eq_mul, mul_one, eq_comm]\n  · simpa [mul_smul, ← hxy, mem_inv_smul_set_iff] using hy.1\n\n"}
{"name":"MeasureTheory.NullMeasurableSet.fundamentalFrontier","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ns : Set α\ninst✝⁴ : Countable G\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSMul G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ MeasureTheory.NullMeasurableSet (MeasureTheory.fundamentalFrontier G s) μ","decl":"@[to_additive MeasureTheory.NullMeasurableSet.addFundamentalFrontier]\nprotected theorem NullMeasurableSet.fundamentalFrontier (hs : NullMeasurableSet s μ) :\n    NullMeasurableSet (fundamentalFrontier G s) μ :=\n  hs.inter <| .iUnion fun _ => .iUnion fun _ => hs.smul _\n\n"}
{"name":"MeasureTheory.NullMeasurableSet.addFundamentalFrontier","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ns : Set α\ninst✝⁴ : Countable G\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableVAdd G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ MeasureTheory.NullMeasurableSet (MeasureTheory.addFundamentalFrontier G s) μ","decl":"@[to_additive MeasureTheory.NullMeasurableSet.addFundamentalFrontier]\nprotected theorem NullMeasurableSet.fundamentalFrontier (hs : NullMeasurableSet s μ) :\n    NullMeasurableSet (fundamentalFrontier G s) μ :=\n  hs.inter <| .iUnion fun _ => .iUnion fun _ => hs.smul _\n\n"}
{"name":"MeasureTheory.NullMeasurableSet.addFundamentalInterior","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ns : Set α\ninst✝⁴ : Countable G\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableVAdd G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ MeasureTheory.NullMeasurableSet (MeasureTheory.addFundamentalInterior G s) μ","decl":"@[to_additive MeasureTheory.NullMeasurableSet.addFundamentalInterior]\nprotected theorem NullMeasurableSet.fundamentalInterior (hs : NullMeasurableSet s μ) :\n    NullMeasurableSet (fundamentalInterior G s) μ :=\n  hs.diff <| .iUnion fun _ => .iUnion fun _ => hs.smul _\n\n"}
{"name":"MeasureTheory.NullMeasurableSet.fundamentalInterior","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ns : Set α\ninst✝⁴ : Countable G\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSMul G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ MeasureTheory.NullMeasurableSet (MeasureTheory.fundamentalInterior G s) μ","decl":"@[to_additive MeasureTheory.NullMeasurableSet.addFundamentalInterior]\nprotected theorem NullMeasurableSet.fundamentalInterior (hs : NullMeasurableSet s μ) :\n    NullMeasurableSet (fundamentalInterior G s) μ :=\n  hs.diff <| .iUnion fun _ => .iUnion fun _ => hs.smul _\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.measure_fundamentalFrontier","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝³ : Countable G\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasureTheory.IsFundamentalDomain G s μ\n⊢ Eq (μ (MeasureTheory.fundamentalFrontier G s)) 0","decl":"@[to_additive MeasureTheory.IsAddFundamentalDomain.measure_addFundamentalFrontier]\ntheorem measure_fundamentalFrontier : μ (fundamentalFrontier G s) = 0 := by\n  simpa only [fundamentalFrontier, iUnion₂_inter, one_smul, measure_iUnion_null_iff, inter_comm s,\n    Function.onFun] using fun g (hg : g ≠ 1) => hs.aedisjoint hg\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.measure_addFundamentalFrontier","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝³ : Countable G\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasureTheory.IsAddFundamentalDomain G s μ\n⊢ Eq (μ (MeasureTheory.addFundamentalFrontier G s)) 0","decl":"@[to_additive MeasureTheory.IsAddFundamentalDomain.measure_addFundamentalFrontier]\ntheorem measure_fundamentalFrontier : μ (fundamentalFrontier G s) = 0 := by\n  simpa only [fundamentalFrontier, iUnion₂_inter, one_smul, measure_iUnion_null_iff, inter_comm s,\n    Function.onFun] using fun g (hg : g ≠ 1) => hs.aedisjoint hg\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.measure_fundamentalInterior","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝³ : Countable G\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasureTheory.IsFundamentalDomain G s μ\n⊢ Eq (μ (MeasureTheory.fundamentalInterior G s)) (μ s)","decl":"@[to_additive MeasureTheory.IsAddFundamentalDomain.measure_addFundamentalInterior]\ntheorem measure_fundamentalInterior : μ (fundamentalInterior G s) = μ s :=\n  measure_diff_null' hs.measure_fundamentalFrontier\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.measure_addFundamentalInterior","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝³ : Countable G\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasureTheory.IsAddFundamentalDomain G s μ\n⊢ Eq (μ (MeasureTheory.addFundamentalInterior G s)) (μ s)","decl":"@[to_additive MeasureTheory.IsAddFundamentalDomain.measure_addFundamentalInterior]\ntheorem measure_fundamentalInterior : μ (fundamentalInterior G s) = μ s :=\n  measure_diff_null' hs.measure_fundamentalFrontier\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.fundamentalInterior","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Countable G\ninst✝⁵ : Group G\ninst✝⁴ : MulAction G α\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasureTheory.IsFundamentalDomain G s μ\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableSMul G α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\n⊢ MeasureTheory.IsFundamentalDomain G (MeasureTheory.fundamentalInterior G s) μ","decl":"protected theorem fundamentalInterior : IsFundamentalDomain G (fundamentalInterior G s) μ where\n  nullMeasurableSet := hs.nullMeasurableSet.fundamentalInterior _ _\n  ae_covers := by\n    simp_rw [ae_iff, not_exists, ← mem_inv_smul_set_iff, setOf_forall, ← compl_setOf,\n      setOf_mem_eq, ← compl_iUnion]\n    have :\n      ((⋃ g : G, g⁻¹ • s) \\ ⋃ g : G, g⁻¹ • fundamentalFrontier G s) ⊆\n        ⋃ g : G, g⁻¹ • fundamentalInterior G s := by\n      simp_rw [diff_subset_iff, ← iUnion_union_distrib, ← smul_set_union (α := G) (β := α),\n        fundamentalFrontier_union_fundamentalInterior]; rfl\n    refine eq_bot_mono (μ.mono <| compl_subset_compl.2 this) ?_\n    simp only [iUnion_inv_smul, compl_sdiff, ENNReal.bot_eq_zero, himp_eq, sup_eq_union,\n      @iUnion_smul_eq_setOf_exists _ _ _ _ s]\n    exact measure_union_null\n      (measure_iUnion_null fun _ => measure_smul_null hs.measure_fundamentalFrontier _) hs.ae_covers\n  aedisjoint := (pairwise_disjoint_fundamentalInterior _ _).mono fun _ _ => Disjoint.aedisjoint\n\n"}
{"name":"MeasureTheory.measure_map_restrict_apply","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nU : Set (Quotient (MulAction.orbitRel G α))\nmeas_U : MeasurableSet U\n⊢ Eq ((MeasureTheory.Measure.map (Quotient.mk (MulAction.orbitRel G α)) (μ.restrict s)) U) (μ (Inter.inter (Set.preimage (Quotient.mk (MulAction.orbitRel G α)) U) s))","decl":"@[to_additive addMeasure_map_restrict_apply]\nlemma measure_map_restrict_apply (s : Set α) {U : Set (Quotient α_mod_G)}\n    (meas_U : MeasurableSet U) :\n    (μ.restrict s).map π U = μ ((π ⁻¹' U) ∩ s) := by\n  rw [map_apply (f := π) (fun V hV ↦ measurableSet_quotient.mp hV) meas_U,\n    Measure.restrict_apply (t := (Quotient.mk α_mod_G ⁻¹' U)) (measurableSet_quotient.mp meas_U)]\n\n"}
{"name":"MeasureTheory.addMeasure_map_restrict_apply","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nU : Set (Quotient (AddAction.orbitRel G α))\nmeas_U : MeasurableSet U\n⊢ Eq ((MeasureTheory.Measure.map (Quotient.mk (AddAction.orbitRel G α)) (μ.restrict s)) U) (μ (Inter.inter (Set.preimage (Quotient.mk (AddAction.orbitRel G α)) U) s))","decl":"@[to_additive addMeasure_map_restrict_apply]\nlemma measure_map_restrict_apply (s : Set α) {U : Set (Quotient α_mod_G)}\n    (meas_U : MeasurableSet U) :\n    (μ.restrict s).map π U = μ ((π ⁻¹' U) ∩ s) := by\n  rw [map_apply (f := π) (fun V hV ↦ measurableSet_quotient.mp hV) meas_U,\n    Measure.restrict_apply (t := (Quotient.mk α_mod_G ⁻¹' U)) (measurableSet_quotient.mp meas_U)]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.addQuotientMeasure_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : Countable G\ninst✝² : MeasurableSpace G\ns t : Set α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝ : MeasurableVAdd G α\nfund_dom_s : MeasureTheory.IsAddFundamentalDomain G s μ\nfund_dom_t : MeasureTheory.IsAddFundamentalDomain G t μ\n⊢ Eq (MeasureTheory.Measure.map (Quotient.mk (AddAction.orbitRel G α)) (μ.restrict s)) (MeasureTheory.Measure.map (Quotient.mk (AddAction.orbitRel G α)) (μ.restrict t))","decl":"@[to_additive]\nlemma IsFundamentalDomain.quotientMeasure_eq [Countable G] [MeasurableSpace G] {s t : Set α}\n    [SMulInvariantMeasure G α μ] [MeasurableSMul G α] (fund_dom_s : IsFundamentalDomain G s μ)\n    (fund_dom_t : IsFundamentalDomain G t μ) :\n    (μ.restrict s).map π = (μ.restrict t).map π := by\n  ext U meas_U\n  rw [measure_map_restrict_apply (meas_U := meas_U), measure_map_restrict_apply (meas_U := meas_U)]\n  apply MeasureTheory.IsFundamentalDomain.measure_set_eq fund_dom_s fund_dom_t\n  · exact measurableSet_quotient.mp meas_U\n  · intro g\n    ext x\n    have : Quotient.mk α_mod_G (g • x) = Quotient.mk α_mod_G x := by\n      apply Quotient.sound\n      use g\n    simp only [mem_preimage, this]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.quotientMeasure_eq","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : Countable G\ninst✝² : MeasurableSpace G\ns t : Set α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝ : MeasurableSMul G α\nfund_dom_s : MeasureTheory.IsFundamentalDomain G s μ\nfund_dom_t : MeasureTheory.IsFundamentalDomain G t μ\n⊢ Eq (MeasureTheory.Measure.map (Quotient.mk (MulAction.orbitRel G α)) (μ.restrict s)) (MeasureTheory.Measure.map (Quotient.mk (MulAction.orbitRel G α)) (μ.restrict t))","decl":"@[to_additive]\nlemma IsFundamentalDomain.quotientMeasure_eq [Countable G] [MeasurableSpace G] {s t : Set α}\n    [SMulInvariantMeasure G α μ] [MeasurableSMul G α] (fund_dom_s : IsFundamentalDomain G s μ)\n    (fund_dom_t : IsFundamentalDomain G t μ) :\n    (μ.restrict s).map π = (μ.restrict t).map π := by\n  ext U meas_U\n  rw [measure_map_restrict_apply (meas_U := meas_U), measure_map_restrict_apply (meas_U := meas_U)]\n  apply MeasureTheory.IsFundamentalDomain.measure_set_eq fund_dom_s fund_dom_t\n  · exact measurableSet_quotient.mp meas_U\n  · intro g\n    ext x\n    have : Quotient.mk α_mod_G (g • x) = Quotient.mk α_mod_G x := by\n      apply Quotient.sound\n      use g\n    simp only [mem_preimage, this]\n\n"}
{"name":"MeasureTheory.HasAddFundamentalDomain.ExistsIsAddFundamentalDomain","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_6\nα : Type u_7\ninst✝² : Zero G\ninst✝¹ : VAdd G α\ninst✝ : MeasurableSpace α\nν : autoParam (MeasureTheory.Measure α) _auto✝\nself : MeasureTheory.HasAddFundamentalDomain G α ν\n⊢ Exists fun s => MeasureTheory.IsAddFundamentalDomain G s ν","decl":"/-- We say a quotient of `α` by `G` `HasAddFundamentalDomain` if there is a measurable set\n  `s` for which `IsAddFundamentalDomain G s` holds. -/\nclass HasAddFundamentalDomain (G α : Type*) [Zero G] [VAdd G α] [MeasurableSpace α]\n    (ν : Measure α := by volume_tac) : Prop where\n  ExistsIsAddFundamentalDomain : ∃ s : Set α, IsAddFundamentalDomain G s ν\n\n"}
{"name":"MeasureTheory.HasFundamentalDomain.ExistsIsFundamentalDomain","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_6\nα : Type u_7\ninst✝² : One G\ninst✝¹ : SMul G α\ninst✝ : MeasurableSpace α\nν : autoParam (MeasureTheory.Measure α) _auto✝\nself : MeasureTheory.HasFundamentalDomain G α ν\n⊢ Exists fun s => MeasureTheory.IsFundamentalDomain G s ν","decl":"/-- We say a quotient of `α` by `G` `HasFundamentalDomain` if there is a measurable set `s` for\n  which `IsFundamentalDomain G s` holds. -/\nclass HasFundamentalDomain (G : Type*) (α : Type*) [One G] [SMul G α] [MeasurableSpace α]\n    (ν : Measure α := by volume_tac) : Prop where\n  ExistsIsFundamentalDomain : ∃ (s : Set α), IsFundamentalDomain G s ν\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.hasFundamentalDomain","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSpace α\nν : MeasureTheory.Measure α\ns : Set α\nfund_dom_s : MeasureTheory.IsFundamentalDomain G s ν\n⊢ MeasureTheory.HasFundamentalDomain G α ν","decl":"/-- If there is a fundamental domain `s`, then `HasFundamentalDomain` holds. -/\n@[to_additive]\nlemma IsFundamentalDomain.hasFundamentalDomain (ν : Measure α) {s : Set α}\n    (fund_dom_s : IsFundamentalDomain G s ν) :\n    HasFundamentalDomain G α ν := ⟨⟨s, fund_dom_s⟩⟩\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.hasAddFundamentalDomain","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableSpace α\nν : MeasureTheory.Measure α\ns : Set α\nfund_dom_s : MeasureTheory.IsAddFundamentalDomain G s ν\n⊢ MeasureTheory.HasAddFundamentalDomain G α ν","decl":"/-- If there is a fundamental domain `s`, then `HasFundamentalDomain` holds. -/\n@[to_additive]\nlemma IsFundamentalDomain.hasFundamentalDomain (ν : Measure α) {s : Set α}\n    (fund_dom_s : IsFundamentalDomain G s ν) :\n    HasFundamentalDomain G α ν := ⟨⟨s, fund_dom_s⟩⟩\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.covolume_eq_volume","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝³ : Countable G\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableSMul G α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α ν\ns : Set α\nfund_dom_s : MeasureTheory.IsFundamentalDomain G s ν\n⊢ Eq (MeasureTheory.covolume G α ν) (ν s)","decl":"/-- The `covolume` can be computed by taking the `volume` of any given fundamental domain `s`. -/\n@[to_additive]\nlemma IsFundamentalDomain.covolume_eq_volume (ν : Measure α) [Countable G]\n    [MeasurableSpace G] [MeasurableSMul G α] [SMulInvariantMeasure G α ν] {s : Set α}\n    (fund_dom_s : IsFundamentalDomain G s ν) : covolume G α ν = ν s := by\n  dsimp [covolume]\n  simp only [(fund_dom_s.hasFundamentalDomain ν), ↓reduceDIte]\n  rw [fund_dom_s.measure_eq]\n  exact (fund_dom_s.hasFundamentalDomain ν).ExistsIsFundamentalDomain.choose_spec\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.covolume_eq_volume","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝³ : Countable G\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableVAdd G α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α ν\ns : Set α\nfund_dom_s : MeasureTheory.IsAddFundamentalDomain G s ν\n⊢ Eq (MeasureTheory.addCovolume G α ν) (ν s)","decl":"/-- The `covolume` can be computed by taking the `volume` of any given fundamental domain `s`. -/\n@[to_additive]\nlemma IsFundamentalDomain.covolume_eq_volume (ν : Measure α) [Countable G]\n    [MeasurableSpace G] [MeasurableSMul G α] [SMulInvariantMeasure G α ν] {s : Set α}\n    (fund_dom_s : IsFundamentalDomain G s ν) : covolume G α ν = ν s := by\n  dsimp [covolume]\n  simp only [(fund_dom_s.hasFundamentalDomain ν), ↓reduceDIte]\n  rw [fund_dom_s.measure_eq]\n  exact (fund_dom_s.hasFundamentalDomain ν).ExistsIsFundamentalDomain.choose_spec\n\n"}
{"name":"MeasureTheory.AddQuotientMeasureEqMeasurePreimage.addProjection_respects_measure'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableSpace α\nν : autoParam (MeasureTheory.Measure α) _auto✝\nμ : MeasureTheory.Measure (Quotient (AddAction.orbitRel G α))\nself : MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ\nt : Set α\nx✝ : MeasureTheory.IsAddFundamentalDomain G t ν\n⊢ Eq μ (MeasureTheory.Measure.map (Quotient.mk (AddAction.orbitRel G α)) (MeasureTheory.Measure.restrict ν t))","decl":"/-- A measure `μ` on the `AddQuotient` of `α` mod `G` satisfies\n  `AddQuotientMeasureEqMeasurePreimage` if: for any fundamental domain `t`, and any measurable\n  subset `U` of the quotient, `μ U = volume ((π ⁻¹' U) ∩ t)`. -/\nclass AddQuotientMeasureEqMeasurePreimage (ν : Measure α := by volume_tac)\n    (μ : Measure (Quotient α_mod_G)) : Prop where\n  addProjection_respects_measure' : ∀ (t : Set α) (_ : IsAddFundamentalDomain G t ν),\n    μ = (ν.restrict t).map π\n\n"}
{"name":"MeasureTheory.QuotientMeasureEqMeasurePreimage.projection_respects_measure'","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSpace α\nν : autoParam (MeasureTheory.Measure α) _auto✝\nμ : MeasureTheory.Measure (Quotient (MulAction.orbitRel G α))\nself : MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ\nt : Set α\na✝ : MeasureTheory.IsFundamentalDomain G t ν\n⊢ Eq μ (MeasureTheory.Measure.map (Quotient.mk (MulAction.orbitRel G α)) (MeasureTheory.Measure.restrict ν t))","decl":"/-- Measures `ν` on `α` and `μ` on the `Quotient` of `α` mod `G` satisfy\n  `QuotientMeasureEqMeasurePreimage` if: for any fundamental domain `t`, and any measurable subset\n  `U` of the quotient, `μ U = ν ((π ⁻¹' U) ∩ t)`. -/\nclass QuotientMeasureEqMeasurePreimage (ν : Measure α := by volume_tac)\n    (μ : Measure (Quotient α_mod_G)) : Prop where\n  projection_respects_measure' (t : Set α) : IsFundamentalDomain G t ν → μ = (ν.restrict t).map π\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.projection_respects_measure","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSpace α\nν : MeasureTheory.Measure α\nμ : MeasureTheory.Measure (Quotient (MulAction.orbitRel G α))\ni : MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ\nt : Set α\nfund_dom_t : MeasureTheory.IsFundamentalDomain G t ν\n⊢ Eq μ (MeasureTheory.Measure.map (Quotient.mk (MulAction.orbitRel G α)) (ν.restrict t))","decl":"@[to_additive addProjection_respects_measure]\nlemma IsFundamentalDomain.projection_respects_measure {ν : Measure α}\n    (μ : Measure (Quotient α_mod_G)) [i : QuotientMeasureEqMeasurePreimage ν μ] {t : Set α}\n    (fund_dom_t : IsFundamentalDomain G t ν) : μ = (ν.restrict t).map π :=\n  i.projection_respects_measure' t fund_dom_t\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.addProjection_respects_measure","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableSpace α\nν : MeasureTheory.Measure α\nμ : MeasureTheory.Measure (Quotient (AddAction.orbitRel G α))\ni : MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ\nt : Set α\nfund_dom_t : MeasureTheory.IsAddFundamentalDomain G t ν\n⊢ Eq μ (MeasureTheory.Measure.map (Quotient.mk (AddAction.orbitRel G α)) (ν.restrict t))","decl":"@[to_additive addProjection_respects_measure]\nlemma IsFundamentalDomain.projection_respects_measure {ν : Measure α}\n    (μ : Measure (Quotient α_mod_G)) [i : QuotientMeasureEqMeasurePreimage ν μ] {t : Set α}\n    (fund_dom_t : IsFundamentalDomain G t ν) : μ = (ν.restrict t).map π :=\n  i.projection_respects_measure' t fund_dom_t\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.projection_respects_measure_apply","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MeasurableSpace α\nν : MeasureTheory.Measure α\nμ : MeasureTheory.Measure (Quotient (MulAction.orbitRel G α))\ni : MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ\nt : Set α\nfund_dom_t : MeasureTheory.IsFundamentalDomain G t ν\nU : Set (Quotient (MulAction.orbitRel G α))\nmeas_U : MeasurableSet U\n⊢ Eq (μ U) (ν (Inter.inter (Set.preimage (Quotient.mk (MulAction.orbitRel G α)) U) t))","decl":"@[to_additive addProjection_respects_measure_apply]\nlemma IsFundamentalDomain.projection_respects_measure_apply {ν : Measure α}\n    (μ : Measure (Quotient α_mod_G)) [i : QuotientMeasureEqMeasurePreimage ν μ] {t : Set α}\n    (fund_dom_t : IsFundamentalDomain G t ν) {U : Set (Quotient α_mod_G)}\n    (meas_U : MeasurableSet U) : μ U = ν (π ⁻¹' U ∩ t) := by\n  rw [fund_dom_t.projection_respects_measure (μ := μ), measure_map_restrict_apply ν t meas_U]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.addProjection_respects_measure_apply","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : MeasurableSpace α\nν : MeasureTheory.Measure α\nμ : MeasureTheory.Measure (Quotient (AddAction.orbitRel G α))\ni : MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ\nt : Set α\nfund_dom_t : MeasureTheory.IsAddFundamentalDomain G t ν\nU : Set (Quotient (AddAction.orbitRel G α))\nmeas_U : MeasurableSet U\n⊢ Eq (μ U) (ν (Inter.inter (Set.preimage (Quotient.mk (AddAction.orbitRel G α)) U) t))","decl":"@[to_additive addProjection_respects_measure_apply]\nlemma IsFundamentalDomain.projection_respects_measure_apply {ν : Measure α}\n    (μ : Measure (Quotient α_mod_G)) [i : QuotientMeasureEqMeasurePreimage ν μ] {t : Set α}\n    (fund_dom_t : IsFundamentalDomain G t ν) {U : Set (Quotient α_mod_G)}\n    (meas_U : MeasurableSet U) : μ U = ν (π ⁻¹' U ∩ t) := by\n  rw [fund_dom_t.projection_respects_measure (μ := μ), measure_map_restrict_apply ν t meas_U]\n\n"}
{"name":"MeasureTheory.QuotientMeasureEqMeasurePreimage.unique","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : Group G\ninst✝³ : MulAction G α\ninst✝² : MeasurableSpace α\nν : MeasureTheory.Measure α\nhasFun : MeasureTheory.HasFundamentalDomain G α ν\nμ μ' : MeasureTheory.Measure (Quotient (MulAction.orbitRel G α))\ninst✝¹ : MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ\ninst✝ : MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ'\n⊢ Eq μ μ'","decl":"/-- Any two measures satisfying `QuotientMeasureEqMeasurePreimage` are equal. -/\n@[to_additive]\nlemma QuotientMeasureEqMeasurePreimage.unique\n    [hasFun : HasFundamentalDomain G α ν] (μ μ' : Measure (Quotient α_mod_G))\n    [QuotientMeasureEqMeasurePreimage ν μ] [QuotientMeasureEqMeasurePreimage ν μ'] :\n    μ = μ' := by\n  obtain ⟨𝓕, h𝓕⟩ := hasFun.ExistsIsFundamentalDomain\n  rw [h𝓕.projection_respects_measure (μ := μ), h𝓕.projection_respects_measure (μ := μ')]\n\n"}
{"name":"MeasureTheory.AddQuotientMeasureEqMeasurePreimage.unique","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁴ : AddGroup G\ninst✝³ : AddAction G α\ninst✝² : MeasurableSpace α\nν : MeasureTheory.Measure α\nhasFun : MeasureTheory.HasAddFundamentalDomain G α ν\nμ μ' : MeasureTheory.Measure (Quotient (AddAction.orbitRel G α))\ninst✝¹ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ\ninst✝ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ'\n⊢ Eq μ μ'","decl":"/-- Any two measures satisfying `QuotientMeasureEqMeasurePreimage` are equal. -/\n@[to_additive]\nlemma QuotientMeasureEqMeasurePreimage.unique\n    [hasFun : HasFundamentalDomain G α ν] (μ μ' : Measure (Quotient α_mod_G))\n    [QuotientMeasureEqMeasurePreimage ν μ] [QuotientMeasureEqMeasurePreimage ν μ'] :\n    μ = μ' := by\n  obtain ⟨𝓕, h𝓕⟩ := hasFun.ExistsIsFundamentalDomain\n  rw [h𝓕.projection_respects_measure (μ := μ), h𝓕.projection_respects_measure (μ := μ')]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.measurePreserving_add_quotient_mk","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝³ : AddGroup G\ninst✝² : AddAction G α\ninst✝¹ : MeasurableSpace α\nν : MeasureTheory.Measure α\n𝓕 : Set α\nh𝓕 : MeasureTheory.IsAddFundamentalDomain G 𝓕 ν\nμ : MeasureTheory.Measure (Quotient (AddAction.orbitRel G α))\ninst✝ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ\n⊢ MeasureTheory.MeasurePreserving (Quotient.mk (AddAction.orbitRel G α)) (ν.restrict 𝓕) μ","decl":"/-- The quotient map to `α ⧸ G` is measure-preserving between the restriction of `volume` to a\n  fundamental domain in `α` and a related measure satisfying `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive IsAddFundamentalDomain.measurePreserving_add_quotient_mk]\ntheorem IsFundamentalDomain.measurePreserving_quotient_mk\n    {𝓕 : Set α} (h𝓕 : IsFundamentalDomain G 𝓕 ν)\n    (μ : Measure (Quotient α_mod_G)) [QuotientMeasureEqMeasurePreimage ν μ] :\n    MeasurePreserving π (ν.restrict 𝓕) μ where\n  measurable := measurable_quotient_mk' (s := α_mod_G)\n  map_eq := by\n    haveI : HasFundamentalDomain G α ν := ⟨𝓕, h𝓕⟩\n    rw [h𝓕.projection_respects_measure (μ := μ)]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.measurePreserving_quotient_mk","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝³ : Group G\ninst✝² : MulAction G α\ninst✝¹ : MeasurableSpace α\nν : MeasureTheory.Measure α\n𝓕 : Set α\nh𝓕 : MeasureTheory.IsFundamentalDomain G 𝓕 ν\nμ : MeasureTheory.Measure (Quotient (MulAction.orbitRel G α))\ninst✝ : MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ\n⊢ MeasureTheory.MeasurePreserving (Quotient.mk (MulAction.orbitRel G α)) (ν.restrict 𝓕) μ","decl":"/-- The quotient map to `α ⧸ G` is measure-preserving between the restriction of `volume` to a\n  fundamental domain in `α` and a related measure satisfying `QuotientMeasureEqMeasurePreimage`. -/\n@[to_additive IsAddFundamentalDomain.measurePreserving_add_quotient_mk]\ntheorem IsFundamentalDomain.measurePreserving_quotient_mk\n    {𝓕 : Set α} (h𝓕 : IsFundamentalDomain G 𝓕 ν)\n    (μ : Measure (Quotient α_mod_G)) [QuotientMeasureEqMeasurePreimage ν μ] :\n    MeasurePreserving π (ν.restrict 𝓕) μ where\n  measurable := measurable_quotient_mk' (s := α_mod_G)\n  map_eq := by\n    haveI : HasFundamentalDomain G α ν := ⟨𝓕, h𝓕⟩\n    rw [h𝓕.projection_respects_measure (μ := μ)]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.quotientMeasureEqMeasurePreimage_quotientMeasure","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝³ : MeasureTheory.SMulInvariantMeasure G α ν\ninst✝² : Countable G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableSMul G α\ns : Set α\nfund_dom_s : MeasureTheory.IsFundamentalDomain G s ν\n⊢ MeasureTheory.QuotientMeasureEqMeasurePreimage ν (MeasureTheory.Measure.map (Quotient.mk (MulAction.orbitRel G α)) (ν.restrict s))","decl":"/-- Given a measure upstairs (i.e., on `α`), and a choice `s` of fundamental domain, there's always\nan artificial way to generate a measure downstairs such that the pair satisfies the\n`QuotientMeasureEqMeasurePreimage` typeclass. -/\n@[to_additive]\nlemma IsFundamentalDomain.quotientMeasureEqMeasurePreimage_quotientMeasure\n    {s : Set α} (fund_dom_s : IsFundamentalDomain G s ν) :\n    QuotientMeasureEqMeasurePreimage ν ((ν.restrict s).map π) where\n  projection_respects_measure' t fund_dom_t := by rw [fund_dom_s.quotientMeasure_eq _ fund_dom_t]\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.addQuotientMeasureEqMeasurePreimage_addQuotientMeasure","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝³ : MeasureTheory.VAddInvariantMeasure G α ν\ninst✝² : Countable G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableVAdd G α\ns : Set α\nfund_dom_s : MeasureTheory.IsAddFundamentalDomain G s ν\n⊢ MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν (MeasureTheory.Measure.map (Quotient.mk (AddAction.orbitRel G α)) (ν.restrict s))","decl":"/-- Given a measure upstairs (i.e., on `α`), and a choice `s` of fundamental domain, there's always\nan artificial way to generate a measure downstairs such that the pair satisfies the\n`QuotientMeasureEqMeasurePreimage` typeclass. -/\n@[to_additive]\nlemma IsFundamentalDomain.quotientMeasureEqMeasurePreimage_quotientMeasure\n    {s : Set α} (fund_dom_s : IsFundamentalDomain G s ν) :\n    QuotientMeasureEqMeasurePreimage ν ((ν.restrict s).map π) where\n  projection_respects_measure' t fund_dom_t := by rw [fund_dom_s.quotientMeasure_eq _ fund_dom_t]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.quotientMeasureEqMeasurePreimage","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝³ : MeasureTheory.SMulInvariantMeasure G α ν\ninst✝² : Countable G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableSMul G α\nμ : MeasureTheory.Measure (Quotient (MulAction.orbitRel G α))\ns : Set α\nfund_dom_s : MeasureTheory.IsFundamentalDomain G s ν\nh : Eq μ (MeasureTheory.Measure.map (Quotient.mk (MulAction.orbitRel G α)) (ν.restrict s))\n⊢ MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ","decl":"/-- One can prove `QuotientMeasureEqMeasurePreimage` by checking behavior with respect to a single\nfundamental domain. -/\n@[to_additive]\nlemma IsFundamentalDomain.quotientMeasureEqMeasurePreimage {μ : Measure (Quotient α_mod_G)}\n    {s : Set α} (fund_dom_s : IsFundamentalDomain G s ν) (h : μ = (ν.restrict s).map π) :\n    QuotientMeasureEqMeasurePreimage ν μ := by\n  simpa [h] using fund_dom_s.quotientMeasureEqMeasurePreimage_quotientMeasure\n\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.addQuotientMeasureEqMeasurePreimage","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝³ : MeasureTheory.VAddInvariantMeasure G α ν\ninst✝² : Countable G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableVAdd G α\nμ : MeasureTheory.Measure (Quotient (AddAction.orbitRel G α))\ns : Set α\nfund_dom_s : MeasureTheory.IsAddFundamentalDomain G s ν\nh : Eq μ (MeasureTheory.Measure.map (Quotient.mk (AddAction.orbitRel G α)) (ν.restrict s))\n⊢ MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ","decl":"/-- One can prove `QuotientMeasureEqMeasurePreimage` by checking behavior with respect to a single\nfundamental domain. -/\n@[to_additive]\nlemma IsFundamentalDomain.quotientMeasureEqMeasurePreimage {μ : Measure (Quotient α_mod_G)}\n    {s : Set α} (fund_dom_s : IsFundamentalDomain G s ν) (h : μ = (ν.restrict s).map π) :\n    QuotientMeasureEqMeasurePreimage ν μ := by\n  simpa [h] using fund_dom_s.quotientMeasureEqMeasurePreimage_quotientMeasure\n\n\n"}
{"name":"MeasureTheory.IsAddFundamentalDomain.addQuotientMeasureEqMeasurePreimage_of_zero","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\ninst✝⁴ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝³ : MeasureTheory.VAddInvariantMeasure G α ν\ninst✝² : Countable G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableVAdd G α\ns : Set α\nfund_dom_s : MeasureTheory.IsAddFundamentalDomain G s ν\nvol_s : Eq (ν s) 0\n⊢ MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν 0","decl":"/-- If a fundamental domain has volume 0, then `QuotientMeasureEqMeasurePreimage` holds. -/\n@[to_additive]\ntheorem IsFundamentalDomain.quotientMeasureEqMeasurePreimage_of_zero\n    {s : Set α} (fund_dom_s : IsFundamentalDomain G s ν)\n    (vol_s : ν s = 0) :\n    QuotientMeasureEqMeasurePreimage ν (0 : Measure (Quotient α_mod_G)) := by\n  apply fund_dom_s.quotientMeasureEqMeasurePreimage\n  ext U meas_U\n  simp only [Measure.coe_zero, Pi.zero_apply]\n  convert (measure_inter_null_of_null_right (h := vol_s) (Quotient.mk α_mod_G ⁻¹' U)).symm\n  rw [measure_map_restrict_apply (meas_U := meas_U)]\n\n"}
{"name":"MeasureTheory.IsFundamentalDomain.quotientMeasureEqMeasurePreimage_of_zero","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\ninst✝⁴ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝³ : MeasureTheory.SMulInvariantMeasure G α ν\ninst✝² : Countable G\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableSMul G α\ns : Set α\nfund_dom_s : MeasureTheory.IsFundamentalDomain G s ν\nvol_s : Eq (ν s) 0\n⊢ MeasureTheory.QuotientMeasureEqMeasurePreimage ν 0","decl":"/-- If a fundamental domain has volume 0, then `QuotientMeasureEqMeasurePreimage` holds. -/\n@[to_additive]\ntheorem IsFundamentalDomain.quotientMeasureEqMeasurePreimage_of_zero\n    {s : Set α} (fund_dom_s : IsFundamentalDomain G s ν)\n    (vol_s : ν s = 0) :\n    QuotientMeasureEqMeasurePreimage ν (0 : Measure (Quotient α_mod_G)) := by\n  apply fund_dom_s.quotientMeasureEqMeasurePreimage\n  ext U meas_U\n  simp only [Measure.coe_zero, Pi.zero_apply]\n  convert (measure_inter_null_of_null_right (h := vol_s) (Quotient.mk α_mod_G ⁻¹' U)).symm\n  rw [measure_map_restrict_apply (meas_U := meas_U)]\n\n"}
{"name":"MeasureTheory.QuotientMeasureEqMeasurePreimage.sigmaFiniteQuotient","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁷ : Group G\ninst✝⁶ : MulAction G α\ninst✝⁵ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝⁴ : MeasureTheory.SMulInvariantMeasure G α ν\ninst✝³ : Countable G\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableSMul G α\ni : MeasureTheory.SigmaFinite ν\ni' : MeasureTheory.HasFundamentalDomain G α ν\nμ : MeasureTheory.Measure (Quotient (MulAction.orbitRel G α))\ninst✝ : MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ\n⊢ MeasureTheory.SigmaFinite μ","decl":"/-- If a measure `μ` on a quotient satisfies `QuotientMeasureEqMeasurePreimage` with respect to a\nsigma-finite measure `ν`, then it is itself `SigmaFinite`. -/\n@[to_additive]\nlemma QuotientMeasureEqMeasurePreimage.sigmaFiniteQuotient\n    [i : SigmaFinite ν] [i' : HasFundamentalDomain G α ν]\n    (μ : Measure (Quotient α_mod_G)) [QuotientMeasureEqMeasurePreimage ν μ] :\n    SigmaFinite μ := by\n  rw [sigmaFinite_iff]\n  obtain ⟨A, hA_meas, hA, hA'⟩ := Measure.toFiniteSpanningSetsIn (h := i)\n  simp only [mem_setOf_eq] at hA_meas\n  refine ⟨⟨fun n ↦ π '' (A n), by simp, fun n ↦ ?_, ?_⟩⟩\n  · obtain ⟨s, fund_dom_s⟩ := i'\n    have : π ⁻¹' (π '' (A n)) = _ := MulAction.quotient_preimage_image_eq_union_mul (A n) (G := G)\n    have measπAn : MeasurableSet (π '' A n) := by\n      let _ : Setoid α := α_mod_G\n      rw [measurableSet_quotient, Quotient.mk''_eq_mk, this]\n      apply MeasurableSet.iUnion\n      exact fun g ↦ MeasurableSet.const_smul (hA_meas n) g\n    rw [fund_dom_s.projection_respects_measure_apply (μ := μ) measπAn, this, iUnion_inter]\n    refine lt_of_le_of_lt ?_ (hA n)\n    rw [fund_dom_s.measure_eq_tsum (A n)]\n    exact measure_iUnion_le _\n  · rw [← image_iUnion, hA']\n    refine image_univ_of_surjective (by convert Quotient.mk'_surjective)\n\n"}
{"name":"MeasureTheory.AddQuotientMeasureEqMeasurePreimage.sigmaFiniteQuotient","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁷ : AddGroup G\ninst✝⁶ : AddAction G α\ninst✝⁵ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝⁴ : MeasureTheory.VAddInvariantMeasure G α ν\ninst✝³ : Countable G\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableVAdd G α\ni : MeasureTheory.SigmaFinite ν\ni' : MeasureTheory.HasAddFundamentalDomain G α ν\nμ : MeasureTheory.Measure (Quotient (AddAction.orbitRel G α))\ninst✝ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ\n⊢ MeasureTheory.SigmaFinite μ","decl":"/-- If a measure `μ` on a quotient satisfies `QuotientMeasureEqMeasurePreimage` with respect to a\nsigma-finite measure `ν`, then it is itself `SigmaFinite`. -/\n@[to_additive]\nlemma QuotientMeasureEqMeasurePreimage.sigmaFiniteQuotient\n    [i : SigmaFinite ν] [i' : HasFundamentalDomain G α ν]\n    (μ : Measure (Quotient α_mod_G)) [QuotientMeasureEqMeasurePreimage ν μ] :\n    SigmaFinite μ := by\n  rw [sigmaFinite_iff]\n  obtain ⟨A, hA_meas, hA, hA'⟩ := Measure.toFiniteSpanningSetsIn (h := i)\n  simp only [mem_setOf_eq] at hA_meas\n  refine ⟨⟨fun n ↦ π '' (A n), by simp, fun n ↦ ?_, ?_⟩⟩\n  · obtain ⟨s, fund_dom_s⟩ := i'\n    have : π ⁻¹' (π '' (A n)) = _ := MulAction.quotient_preimage_image_eq_union_mul (A n) (G := G)\n    have measπAn : MeasurableSet (π '' A n) := by\n      let _ : Setoid α := α_mod_G\n      rw [measurableSet_quotient, Quotient.mk''_eq_mk, this]\n      apply MeasurableSet.iUnion\n      exact fun g ↦ MeasurableSet.const_smul (hA_meas n) g\n    rw [fund_dom_s.projection_respects_measure_apply (μ := μ) measπAn, this, iUnion_inter]\n    refine lt_of_le_of_lt ?_ (hA n)\n    rw [fund_dom_s.measure_eq_tsum (A n)]\n    exact measure_iUnion_le _\n  · rw [← image_iUnion, hA']\n    refine image_univ_of_surjective (by convert Quotient.mk'_surjective)\n\n"}
{"name":"MeasureTheory.AddQuotientMeasureEqMeasurePreimage.isFiniteMeasure_quotient","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁷ : AddGroup G\ninst✝⁶ : AddAction G α\ninst✝⁵ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝⁴ : MeasureTheory.VAddInvariantMeasure G α ν\ninst✝³ : Countable G\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableVAdd G α\nμ : MeasureTheory.Measure (Quotient (AddAction.orbitRel G α))\ninst✝ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ\nhasFun : MeasureTheory.HasAddFundamentalDomain G α ν\nh : Ne (MeasureTheory.addCovolume G α ν) Top.top\n⊢ MeasureTheory.IsFiniteMeasure μ","decl":"/-- A measure `μ` on `α ⧸ G` satisfying `QuotientMeasureEqMeasurePreimage` and having finite\ncovolume is a finite measure. -/\n@[to_additive]\ntheorem QuotientMeasureEqMeasurePreimage.isFiniteMeasure_quotient\n    (μ : Measure (Quotient α_mod_G)) [QuotientMeasureEqMeasurePreimage ν μ]\n    [hasFun : HasFundamentalDomain G α ν] (h : covolume G α ν ≠ ∞) :\n    IsFiniteMeasure μ := by\n  obtain ⟨𝓕, h𝓕⟩ := hasFun.ExistsIsFundamentalDomain\n  rw [h𝓕.projection_respects_measure (μ := μ)]\n  have : Fact (ν 𝓕 < ∞) := by\n    apply Fact.mk\n    convert Ne.lt_top h\n    exact (h𝓕.covolume_eq_volume ν).symm\n  infer_instance\n\n"}
{"name":"MeasureTheory.QuotientMeasureEqMeasurePreimage.isFiniteMeasure_quotient","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁷ : Group G\ninst✝⁶ : MulAction G α\ninst✝⁵ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝⁴ : MeasureTheory.SMulInvariantMeasure G α ν\ninst✝³ : Countable G\ninst✝² : MeasurableSpace G\ninst✝¹ : MeasurableSMul G α\nμ : MeasureTheory.Measure (Quotient (MulAction.orbitRel G α))\ninst✝ : MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ\nhasFun : MeasureTheory.HasFundamentalDomain G α ν\nh : Ne (MeasureTheory.covolume G α ν) Top.top\n⊢ MeasureTheory.IsFiniteMeasure μ","decl":"/-- A measure `μ` on `α ⧸ G` satisfying `QuotientMeasureEqMeasurePreimage` and having finite\ncovolume is a finite measure. -/\n@[to_additive]\ntheorem QuotientMeasureEqMeasurePreimage.isFiniteMeasure_quotient\n    (μ : Measure (Quotient α_mod_G)) [QuotientMeasureEqMeasurePreimage ν μ]\n    [hasFun : HasFundamentalDomain G α ν] (h : covolume G α ν ≠ ∞) :\n    IsFiniteMeasure μ := by\n  obtain ⟨𝓕, h𝓕⟩ := hasFun.ExistsIsFundamentalDomain\n  rw [h𝓕.projection_respects_measure (μ := μ)]\n  have : Fact (ν 𝓕 < ∞) := by\n    apply Fact.mk\n    convert Ne.lt_top h\n    exact (h𝓕.covolume_eq_volume ν).symm\n  infer_instance\n\n"}
{"name":"MeasureTheory.QuotientMeasureEqMeasurePreimage.covolume_ne_top","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁸ : Group G\ninst✝⁷ : MulAction G α\ninst✝⁶ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝⁵ : MeasureTheory.SMulInvariantMeasure G α ν\ninst✝⁴ : Countable G\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableSMul G α\nμ : MeasureTheory.Measure (Quotient (MulAction.orbitRel G α))\ninst✝¹ : MeasureTheory.QuotientMeasureEqMeasurePreimage ν μ\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ LT.lt (MeasureTheory.covolume G α ν) Top.top","decl":"/-- A finite measure `μ` on `α ⧸ G` satisfying `QuotientMeasureEqMeasurePreimage` has finite\ncovolume. -/\n@[to_additive]\ntheorem QuotientMeasureEqMeasurePreimage.covolume_ne_top\n    (μ : Measure (Quotient α_mod_G)) [QuotientMeasureEqMeasurePreimage ν μ] [IsFiniteMeasure μ] :\n    covolume G α ν < ∞ := by\n  by_cases hasFun : HasFundamentalDomain G α ν\n  · obtain ⟨𝓕, h𝓕⟩ := hasFun.ExistsIsFundamentalDomain\n    have H : μ univ < ∞ := IsFiniteMeasure.measure_univ_lt_top\n    rw [h𝓕.projection_respects_measure_apply (μ := μ) MeasurableSet.univ] at H\n    simpa [h𝓕.covolume_eq_volume ν] using H\n  · simp [covolume, hasFun]\n\n"}
{"name":"MeasureTheory.AddQuotientMeasureEqMeasurePreimage.covolume_ne_top","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁸ : AddGroup G\ninst✝⁷ : AddAction G α\ninst✝⁶ : MeasurableSpace α\nν : MeasureTheory.Measure α\ninst✝⁵ : MeasureTheory.VAddInvariantMeasure G α ν\ninst✝⁴ : Countable G\ninst✝³ : MeasurableSpace G\ninst✝² : MeasurableVAdd G α\nμ : MeasureTheory.Measure (Quotient (AddAction.orbitRel G α))\ninst✝¹ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage ν μ\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ LT.lt (MeasureTheory.addCovolume G α ν) Top.top","decl":"/-- A finite measure `μ` on `α ⧸ G` satisfying `QuotientMeasureEqMeasurePreimage` has finite\ncovolume. -/\n@[to_additive]\ntheorem QuotientMeasureEqMeasurePreimage.covolume_ne_top\n    (μ : Measure (Quotient α_mod_G)) [QuotientMeasureEqMeasurePreimage ν μ] [IsFiniteMeasure μ] :\n    covolume G α ν < ∞ := by\n  by_cases hasFun : HasFundamentalDomain G α ν\n  · obtain ⟨𝓕, h𝓕⟩ := hasFun.ExistsIsFundamentalDomain\n    have H : μ univ < ∞ := IsFiniteMeasure.measure_univ_lt_top\n    rw [h𝓕.projection_respects_measure_apply (μ := μ) MeasurableSet.univ] at H\n    simpa [h𝓕.covolume_eq_volume ν] using H\n  · simp [covolume, hasFun]\n\n"}
{"name":"MeasureTheory.instSigmaFiniteAddQuotientOrbitRelInstMeasurableSpaceToMeasurableSpace","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁹ : AddGroup G\ninst✝⁸ : AddAction G α\ninst✝⁷ : MeasureTheory.MeasureSpace α\ninst✝⁶ : Countable G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : MeasureTheory.VAddInvariantMeasure G α MeasureTheory.MeasureSpace.volume\ninst✝³ : MeasurableVAdd G α\ninst✝² : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝¹ : MeasureTheory.HasAddFundamentalDomain G α MeasureTheory.MeasureSpace.volume\nμ : MeasureTheory.Measure (Quotient (AddAction.orbitRel G α))\ninst✝ : MeasureTheory.AddQuotientMeasureEqMeasurePreimage MeasureTheory.MeasureSpace.volume μ\n⊢ MeasureTheory.SigmaFinite μ","decl":"/-- If a measure `μ` on a quotient satisfies `QuotientVolumeEqVolumePreimage` with respect to a\nsigma-finite measure, then it is itself `SigmaFinite`. -/\n@[to_additive MeasureTheory.instSigmaFiniteAddQuotientOrbitRelInstMeasurableSpaceToMeasurableSpace]\ninstance [SigmaFinite (volume : Measure α)] [HasFundamentalDomain G α]\n    (μ : Measure (Quotient α_mod_G)) [QuotientMeasureEqMeasurePreimage volume μ] :\n    SigmaFinite μ :=\n  QuotientMeasureEqMeasurePreimage.sigmaFiniteQuotient (ν := (volume : Measure α)) (μ := μ)\n\n"}
{"name":"MeasureTheory.instSigmaFiniteQuotientOrbitRelOfHasFundamentalDomainOfQuotientMeasureEqMeasurePreimageVolume","module":"Mathlib.MeasureTheory.Group.FundamentalDomain","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝⁹ : Group G\ninst✝⁸ : MulAction G α\ninst✝⁷ : MeasureTheory.MeasureSpace α\ninst✝⁶ : Countable G\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : MeasureTheory.SMulInvariantMeasure G α MeasureTheory.MeasureSpace.volume\ninst✝³ : MeasurableSMul G α\ninst✝² : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝¹ : MeasureTheory.HasFundamentalDomain G α MeasureTheory.MeasureSpace.volume\nμ : MeasureTheory.Measure (Quotient (MulAction.orbitRel G α))\ninst✝ : MeasureTheory.QuotientMeasureEqMeasurePreimage MeasureTheory.MeasureSpace.volume μ\n⊢ MeasureTheory.SigmaFinite μ","decl":"/-- If a measure `μ` on a quotient satisfies `QuotientVolumeEqVolumePreimage` with respect to a\nsigma-finite measure, then it is itself `SigmaFinite`. -/\n@[to_additive MeasureTheory.instSigmaFiniteAddQuotientOrbitRelInstMeasurableSpaceToMeasurableSpace]\ninstance [SigmaFinite (volume : Measure α)] [HasFundamentalDomain G α]\n    (μ : Measure (Quotient α_mod_G)) [QuotientMeasureEqMeasurePreimage volume μ] :\n    SigmaFinite μ :=\n  QuotientMeasureEqMeasurePreimage.sigmaFiniteQuotient (ν := (volume : Measure α)) (μ := μ)\n\n"}
