{"name":"CategoryTheory.Limits.IsLimit.uniq","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nself : CategoryTheory.Limits.IsLimit t\ns : CategoryTheory.Limits.Cone F\nm : Quiver.Hom s.pt t.pt\nx✝ : ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp m (t.π.app j)) (s.π.app j)\n⊢ Eq m (self.lift s)","decl":"/-- A cone `t` on `F` is a limit cone if each cone on `F` admits a unique\ncone morphism to `t`. -/\n@[stacks 002E]\nstructure IsLimit (t : Cone F) where\n  /-- There is a morphism from any cone point to `t.pt` -/\n  lift : ∀ s : Cone F, s.pt ⟶ t.pt\n  /-- The map makes the triangle with the two natural transformations commute -/\n  fac : ∀ (s : Cone F) (j : J), lift s ≫ t.π.app j = s.π.app j := by aesop_cat\n  /-- It is the unique such map to do this -/\n  uniq : ∀ (s : Cone F) (m : s.pt ⟶ t.pt) (_ : ∀ j : J, m ≫ t.π.app j = s.π.app j), m = lift s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.fac","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nself : CategoryTheory.Limits.IsLimit t\ns : CategoryTheory.Limits.Cone F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.lift s) (t.π.app j)) (s.π.app j)","decl":"/-- A cone `t` on `F` is a limit cone if each cone on `F` admits a unique\ncone morphism to `t`. -/\n@[stacks 002E]\nstructure IsLimit (t : Cone F) where\n  /-- There is a morphism from any cone point to `t.pt` -/\n  lift : ∀ s : Cone F, s.pt ⟶ t.pt\n  /-- The map makes the triangle with the two natural transformations commute -/\n  fac : ∀ (s : Cone F) (j : J), lift s ≫ t.π.app j = s.π.app j := by aesop_cat\n  /-- It is the unique such map to do this -/\n  uniq : ∀ (s : Cone F) (m : s.pt ⟶ t.pt) (_ : ∀ j : J, m ≫ t.π.app j = s.π.app j), m = lift s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.mk.inj","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nlift✝ : (s : CategoryTheory.Limits.Cone F) → Quiver.Hom s.pt t.pt\nfac✝ : autoParam (∀ (s : CategoryTheory.Limits.Cone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (lift✝ s) (t.π.app j)) (s.π.app j)) _auto✝\nuniq✝ : autoParam (∀ (s : CategoryTheory.Limits.Cone F) (m : Quiver.Hom s.pt t.pt), (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp m (t.π.app j)) (s.π.app j)) → Eq m (lift✝ s)) _auto✝\nlift : (s : CategoryTheory.Limits.Cone F) → Quiver.Hom s.pt t.pt\nfac : autoParam (∀ (s : CategoryTheory.Limits.Cone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (lift s) (t.π.app j)) (s.π.app j)) _auto✝\nuniq : autoParam (∀ (s : CategoryTheory.Limits.Cone F) (m : Quiver.Hom s.pt t.pt), (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp m (t.π.app j)) (s.π.app j)) → Eq m (lift s)) _auto✝\nx✝ : Eq { lift := lift✝, fac := fac✝, uniq := uniq✝ } { lift := lift, fac := fac, uniq := uniq }\n⊢ Eq lift✝ lift","decl":"/-- A cone `t` on `F` is a limit cone if each cone on `F` admits a unique\ncone morphism to `t`. -/\n@[stacks 002E]\nstructure IsLimit (t : Cone F) where\n  /-- There is a morphism from any cone point to `t.pt` -/\n  lift : ∀ s : Cone F, s.pt ⟶ t.pt\n  /-- The map makes the triangle with the two natural transformations commute -/\n  fac : ∀ (s : Cone F) (j : J), lift s ≫ t.π.app j = s.π.app j := by aesop_cat\n  /-- It is the unique such map to do this -/\n  uniq : ∀ (s : Cone F) (m : s.pt ⟶ t.pt) (_ : ∀ j : J, m ≫ t.π.app j = s.π.app j), m = lift s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.mk.injEq","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nlift✝ : (s : CategoryTheory.Limits.Cone F) → Quiver.Hom s.pt t.pt\nfac✝ : autoParam (∀ (s : CategoryTheory.Limits.Cone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (lift✝ s) (t.π.app j)) (s.π.app j)) _auto✝\nuniq✝ : autoParam (∀ (s : CategoryTheory.Limits.Cone F) (m : Quiver.Hom s.pt t.pt), (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp m (t.π.app j)) (s.π.app j)) → Eq m (lift✝ s)) _auto✝\nlift : (s : CategoryTheory.Limits.Cone F) → Quiver.Hom s.pt t.pt\nfac : autoParam (∀ (s : CategoryTheory.Limits.Cone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (lift s) (t.π.app j)) (s.π.app j)) _auto✝\nuniq : autoParam (∀ (s : CategoryTheory.Limits.Cone F) (m : Quiver.Hom s.pt t.pt), (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp m (t.π.app j)) (s.π.app j)) → Eq m (lift s)) _auto✝\n⊢ Eq (Eq { lift := lift✝, fac := fac✝, uniq := uniq✝ } { lift := lift, fac := fac, uniq := uniq }) (Eq lift✝ lift)","decl":"/-- A cone `t` on `F` is a limit cone if each cone on `F` admits a unique\ncone morphism to `t`. -/\n@[stacks 002E]\nstructure IsLimit (t : Cone F) where\n  /-- There is a morphism from any cone point to `t.pt` -/\n  lift : ∀ s : Cone F, s.pt ⟶ t.pt\n  /-- The map makes the triangle with the two natural transformations commute -/\n  fac : ∀ (s : Cone F) (j : J), lift s ≫ t.π.app j = s.π.app j := by aesop_cat\n  /-- It is the unique such map to do this -/\n  uniq : ∀ (s : Cone F) (m : s.pt ⟶ t.pt) (_ : ∀ j : J, m ≫ t.π.app j = s.π.app j), m = lift s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\ninst✝¹ : SizeOf J\ninst✝ : SizeOf C\nlift : (s : CategoryTheory.Limits.Cone F) → Quiver.Hom s.pt t.pt\nfac : autoParam (∀ (s : CategoryTheory.Limits.Cone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (lift s) (t.π.app j)) (s.π.app j)) _auto✝\nuniq : autoParam (∀ (s : CategoryTheory.Limits.Cone F) (m : Quiver.Hom s.pt t.pt), (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp m (t.π.app j)) (s.π.app j)) → Eq m (lift s)) _auto✝\n⊢ Eq (SizeOf.sizeOf { lift := lift, fac := fac, uniq := uniq }) 1","decl":"/-- A cone `t` on `F` is a limit cone if each cone on `F` admits a unique\ncone morphism to `t`. -/\n@[stacks 002E]\nstructure IsLimit (t : Cone F) where\n  /-- There is a morphism from any cone point to `t.pt` -/\n  lift : ∀ s : Cone F, s.pt ⟶ t.pt\n  /-- The map makes the triangle with the two natural transformations commute -/\n  fac : ∀ (s : Cone F) (j : J), lift s ≫ t.π.app j = s.π.app j := by aesop_cat\n  /-- It is the unique such map to do this -/\n  uniq : ∀ (s : Cone F) (m : s.pt ⟶ t.pt) (_ : ∀ j : J, m ≫ t.π.app j = s.π.app j), m = lift s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.fac_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nself : CategoryTheory.Limits.IsLimit t\ns : CategoryTheory.Limits.Cone F\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.lift s) (CategoryTheory.CategoryStruct.comp (t.π.app j) h)) (CategoryTheory.CategoryStruct.comp (s.π.app j) h)","decl":"attribute [reassoc (attr := simp)] IsLimit.fac\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.subsingleton","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\n⊢ Subsingleton (CategoryTheory.Limits.IsLimit t)","decl":"instance subsingleton {t : Cone F} : Subsingleton (IsLimit t) :=\n  ⟨by intro P Q; cases P; cases Q; congr; aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.map_π","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nd : CategoryTheory.Limits.Cone G\nhd : CategoryTheory.Limits.IsLimit d\nα : Quiver.Hom F G\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.IsLimit.map c hd α) (d.π.app j)) (CategoryTheory.CategoryStruct.comp (c.π.app j) (α.app j))","decl":"@[reassoc (attr := simp)]\ntheorem map_π {F G : J ⥤ C} (c : Cone F) {d : Cone G} (hd : IsLimit d) (α : F ⟶ G) (j : J) :\n    hd.map c α ≫ d.π.app j = c.π.app j ≫ α.app j :=\n  fac _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.map_π_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nd : CategoryTheory.Limits.Cone G\nhd : CategoryTheory.Limits.IsLimit d\nα : Quiver.Hom F G\nj : J\nZ : C\nh : Quiver.Hom (G.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.IsLimit.map c hd α) (CategoryTheory.CategoryStruct.comp (d.π.app j) h)) (CategoryTheory.CategoryStruct.comp (c.π.app j) (CategoryTheory.CategoryStruct.comp (α.app j) h))","decl":"@[reassoc (attr := simp)]\ntheorem map_π {F G : J ⥤ C} (c : Cone F) {d : Cone G} (hd : IsLimit d) (α : F ⟶ G) (j : J) :\n    hd.map c α ≫ d.π.app j = c.π.app j ≫ α.app j :=\n  fac _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_self","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.IsLimit c\n⊢ Eq (t.lift c) (CategoryTheory.CategoryStruct.id c.pt)","decl":"@[simp]\ntheorem lift_self {c : Cone F} (t : IsLimit c) : t.lift c = 𝟙 c.pt :=\n  (t.uniq _ _ fun _ => id_comp _).symm\n\n-- Repackaging the definition in terms of cone morphisms.\n"}
{"name":"CategoryTheory.Limits.IsLimit.liftConeMorphism_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nh : CategoryTheory.Limits.IsLimit t\ns : CategoryTheory.Limits.Cone F\n⊢ Eq (h.liftConeMorphism s).hom (h.lift s)","decl":"/-- The universal morphism from any other cone to a limit cone. -/\n@[simps]\ndef liftConeMorphism {t : Cone F} (h : IsLimit t) (s : Cone F) : s ⟶ t where hom := h.lift s\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.uniq_cone_morphism","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nh : CategoryTheory.Limits.IsLimit t\nf f' : Quiver.Hom s t\n⊢ Eq f f'","decl":"theorem uniq_cone_morphism {s t : Cone F} (h : IsLimit t) {f f' : s ⟶ t} : f = f' :=\n  have : ∀ {g : s ⟶ t}, g = h.liftConeMorphism s := by\n    intro g; apply ConeMorphism.ext; exact h.uniq _ _ g.w\n  this.trans this.symm\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.existsUnique","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nh : CategoryTheory.Limits.IsLimit t\ns : CategoryTheory.Limits.Cone F\n⊢ ExistsUnique fun l => ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp l (t.π.app j)) (s.π.app j)","decl":"/-- Restating the definition of a limit cone in terms of the ∃! operator. -/\ntheorem existsUnique {t : Cone F} (h : IsLimit t) (s : Cone F) :\n    ∃! l : s.pt ⟶ t.pt, ∀ j, l ≫ t.π.app j = s.π.app j :=\n  ⟨h.lift s, h.fac s, h.uniq s⟩\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.mkConeMorphism_lift","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nlift : (s : CategoryTheory.Limits.Cone F) → Quiver.Hom s t\nuniq : ∀ (s : CategoryTheory.Limits.Cone F) (m : Quiver.Hom s t), Eq m (lift s)\ns : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.IsLimit.mkConeMorphism lift uniq).lift s) (lift s).hom","decl":"/-- Alternative constructor for `isLimit`,\nproviding a morphism of cones rather than a morphism between the cone points\nand separately the factorisation condition.\n-/\n@[simps]\ndef mkConeMorphism {t : Cone F} (lift : ∀ s : Cone F, s ⟶ t)\n    (uniq : ∀ (s : Cone F) (m : s ⟶ t), m = lift s) : IsLimit t where\n  lift s := (lift s).hom\n  uniq s m w :=\n    have : ConeMorphism.mk m w = lift s := by apply uniq\n    congrArg ConeMorphism.hom this\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.uniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\n⊢ Eq (P.uniqueUpToIso Q).hom (Q.liftConeMorphism s)","decl":"/-- Limit cones on `F` are unique up to isomorphism. -/\n@[simps]\ndef uniqueUpToIso {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) : s ≅ t where\n  hom := Q.liftConeMorphism s\n  inv := P.liftConeMorphism t\n  hom_inv_id := P.uniq_cone_morphism\n  inv_hom_id := Q.uniq_cone_morphism\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.uniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\n⊢ Eq (P.uniqueUpToIso Q).inv (P.liftConeMorphism t)","decl":"/-- Limit cones on `F` are unique up to isomorphism. -/\n@[simps]\ndef uniqueUpToIso {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) : s ≅ t where\n  hom := Q.liftConeMorphism s\n  inv := P.liftConeMorphism t\n  hom_inv_id := P.uniq_cone_morphism\n  inv_hom_id := Q.uniq_cone_morphism\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.hom_isIso","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nf : Quiver.Hom s t\n⊢ CategoryTheory.IsIso f","decl":"/-- Any cone morphism between limit cones is an isomorphism. -/\ntheorem hom_isIso {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (f : s ⟶ t) : IsIso f :=\n  ⟨⟨P.liftConeMorphism t, ⟨P.uniq_cone_morphism, Q.uniq_cone_morphism⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso_hom_comp_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointUniqueUpToIso Q).hom (CategoryTheory.CategoryStruct.comp (t.π.app j) h)) (CategoryTheory.CategoryStruct.comp (s.π.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem conePointUniqueUpToIso_hom_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    (conePointUniqueUpToIso P Q).hom ≫ t.π.app j = s.π.app j :=\n  (uniqueUpToIso P Q).hom.w _\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso_hom_comp","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointUniqueUpToIso Q).hom (t.π.app j)) (s.π.app j)","decl":"@[reassoc (attr := simp)]\ntheorem conePointUniqueUpToIso_hom_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    (conePointUniqueUpToIso P Q).hom ≫ t.π.app j = s.π.app j :=\n  (uniqueUpToIso P Q).hom.w _\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso_inv_comp_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointUniqueUpToIso Q).inv (CategoryTheory.CategoryStruct.comp (s.π.app j) h)) (CategoryTheory.CategoryStruct.comp (t.π.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem conePointUniqueUpToIso_inv_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    (conePointUniqueUpToIso P Q).inv ≫ s.π.app j = t.π.app j :=\n  (uniqueUpToIso P Q).inv.w _\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso_inv_comp","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointUniqueUpToIso Q).inv (s.π.app j)) (t.π.app j)","decl":"@[reassoc (attr := simp)]\ntheorem conePointUniqueUpToIso_inv_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    (conePointUniqueUpToIso P Q).inv ≫ s.π.app j = t.π.app j :=\n  (uniqueUpToIso P Q).inv.w _\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointUniqueUpToIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nZ : C\nh : Quiver.Hom t.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.lift r) (CategoryTheory.CategoryStruct.comp (P.conePointUniqueUpToIso Q).hom h)) (CategoryTheory.CategoryStruct.comp (Q.lift r) h)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_conePointUniqueUpToIso_hom {r s t : Cone F} (P : IsLimit s) (Q : IsLimit t) :\n    P.lift r ≫ (conePointUniqueUpToIso P Q).hom = Q.lift r :=\n  Q.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointUniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.lift r) (P.conePointUniqueUpToIso Q).hom) (Q.lift r)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_conePointUniqueUpToIso_hom {r s t : Cone F} (P : IsLimit s) (Q : IsLimit t) :\n    P.lift r ≫ (conePointUniqueUpToIso P Q).hom = Q.lift r :=\n  Q.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointUniqueUpToIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nZ : C\nh : Quiver.Hom s.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Q.lift r) (CategoryTheory.CategoryStruct.comp (P.conePointUniqueUpToIso Q).inv h)) (CategoryTheory.CategoryStruct.comp (P.lift r) h)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_conePointUniqueUpToIso_inv {r s t : Cone F} (P : IsLimit s) (Q : IsLimit t) :\n    Q.lift r ≫ (conePointUniqueUpToIso P Q).inv = P.lift r :=\n  P.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointUniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Q.lift r) (P.conePointUniqueUpToIso Q).inv) (P.lift r)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_conePointUniqueUpToIso_inv {r s t : Cone F} (P : IsLimit s) (Q : IsLimit t) :\n    Q.lift r ≫ (conePointUniqueUpToIso P Q).inv = P.lift r :=\n  P.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.ofIsoLimit_lift","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit r\ni : CategoryTheory.Iso r t\ns : CategoryTheory.Limits.Cone F\n⊢ Eq ((P.ofIsoLimit i).lift s) (CategoryTheory.CategoryStruct.comp (P.lift s) i.hom.hom)","decl":"@[simp]\ntheorem ofIsoLimit_lift {r t : Cone F} (P : IsLimit r) (i : r ≅ t) (s) :\n    (P.ofIsoLimit i).lift s = P.lift s ≫ i.hom.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.equivIsoLimit_apply","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr t : CategoryTheory.Limits.Cone F\ni : CategoryTheory.Iso r t\nP : CategoryTheory.Limits.IsLimit r\n⊢ Eq ((CategoryTheory.Limits.IsLimit.equivIsoLimit i) P) (P.ofIsoLimit i)","decl":"@[simp]\ntheorem equivIsoLimit_apply {r t : Cone F} (i : r ≅ t) (P : IsLimit r) :\n    equivIsoLimit i P = P.ofIsoLimit i :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.equivIsoLimit_symm_apply","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr t : CategoryTheory.Limits.Cone F\ni : CategoryTheory.Iso r t\nP : CategoryTheory.Limits.IsLimit t\n⊢ Eq ((CategoryTheory.Limits.IsLimit.equivIsoLimit i).symm P) (P.ofIsoLimit i.symm)","decl":"@[simp]\ntheorem equivIsoLimit_symm_apply {r t : Cone F} (i : r ≅ t) (P : IsLimit t) :\n    (equivIsoLimit i).symm P = P.ofIsoLimit i.symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.hom_lift","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nh : CategoryTheory.Limits.IsLimit t\nW : C\nm : Quiver.Hom W t.pt\n⊢ Eq m (h.lift { pt := W, π := { app := fun b => CategoryTheory.CategoryStruct.comp m (t.π.app b), naturality := ⋯ } })","decl":"theorem hom_lift (h : IsLimit t) {W : C} (m : W ⟶ t.pt) :\n    m = h.lift { pt := W, π := { app := fun b => m ≫ t.π.app b } } :=\n  h.uniq { pt := W, π := { app := fun b => m ≫ t.π.app b } } m fun _ => rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nh : CategoryTheory.Limits.IsLimit t\nW : C\nf f' : Quiver.Hom W t.pt\nw : ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp f (t.π.app j)) (CategoryTheory.CategoryStruct.comp f' (t.π.app j))\n⊢ Eq f f'","decl":"/-- Two morphisms into a limit are equal if their compositions with\n  each cone morphism are equal. -/\ntheorem hom_ext (h : IsLimit t) {W : C} {f f' : W ⟶ t.pt}\n    (w : ∀ j, f ≫ t.π.app j = f' ≫ t.π.app j) :\n    f = f' := by\n  rw [h.hom_lift f, h.hom_lift f']; congr; exact funext w\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.ofConeEquiv_apply_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nG : CategoryTheory.Functor K D\nh : CategoryTheory.Equivalence (CategoryTheory.Limits.Cone G) (CategoryTheory.Limits.Cone F)\nc : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit (h.functor.obj c)\ns : CategoryTheory.Limits.Cone G\n⊢ Eq (((CategoryTheory.Limits.IsLimit.ofConeEquiv h) P).lift s) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (h.unitIso.hom.app s).hom (h.inverse.map (P.liftConeMorphism (h.functor.obj s))).hom) (h.unitIso.inv.app c).hom)","decl":"@[simp]\ntheorem ofConeEquiv_apply_desc {D : Type u₄} [Category.{v₄} D] {G : K ⥤ D} (h : Cone G ≌ Cone F)\n    {c : Cone G} (P : IsLimit (h.functor.obj c)) (s) :\n    (ofConeEquiv h P).lift s =\n      ((h.unitIso.hom.app s).hom ≫ (h.inverse.map (P.liftConeMorphism (h.functor.obj s))).hom) ≫\n        (h.unitIso.inv.app c).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.ofConeEquiv_symm_apply_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nG : CategoryTheory.Functor K D\nh : CategoryTheory.Equivalence (CategoryTheory.Limits.Cone G) (CategoryTheory.Limits.Cone F)\nc : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cone F\n⊢ Eq (((CategoryTheory.Limits.IsLimit.ofConeEquiv h).symm P).lift s) (CategoryTheory.CategoryStruct.comp (h.counitIso.inv.app s).hom (h.functor.map (P.liftConeMorphism (h.inverse.obj s))).hom)","decl":"@[simp]\ntheorem ofConeEquiv_symm_apply_desc {D : Type u₄} [Category.{v₄} D] {G : K ⥤ D}\n    (h : Cone G ≌ Cone F) {c : Cone G} (P : IsLimit c) (s) :\n    ((ofConeEquiv h).symm P).lift s =\n      (h.counitIso.inv.app s).hom ≫ (h.functor.map (P.liftConeMorphism (h.inverse.obj s))).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\n⊢ Eq (P.conePointsIsoOfNatIso Q w).hom (CategoryTheory.Limits.IsLimit.map s Q w.hom)","decl":"/-- The cone points of two limit cones for naturally isomorphic functors\nare themselves isomorphic.\n-/\n@[simps]\ndef conePointsIsoOfNatIso {F G : J ⥤ C} {s : Cone F} {t : Cone G} (P : IsLimit s) (Q : IsLimit t)\n    (w : F ≅ G) : s.pt ≅ t.pt where\n  hom := Q.map s w.hom\n  inv := P.map t w.inv\n  hom_inv_id := P.hom_ext (by simp)\n  inv_hom_id := Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\n⊢ Eq (P.conePointsIsoOfNatIso Q w).inv (CategoryTheory.Limits.IsLimit.map t P w.inv)","decl":"/-- The cone points of two limit cones for naturally isomorphic functors\nare themselves isomorphic.\n-/\n@[simps]\ndef conePointsIsoOfNatIso {F G : J ⥤ C} {s : Cone F} {t : Cone G} (P : IsLimit s) (Q : IsLimit t)\n    (w : F ≅ G) : s.pt ≅ t.pt where\n  hom := Q.map s w.hom\n  inv := P.map t w.inv\n  hom_inv_id := P.hom_ext (by simp)\n  inv_hom_id := Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_hom_comp","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointsIsoOfNatIso Q w).hom (t.π.app j)) (CategoryTheory.CategoryStruct.comp (s.π.app j) (w.hom.app j))","decl":"@[reassoc]\ntheorem conePointsIsoOfNatIso_hom_comp {F G : J ⥤ C} {s : Cone F} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (w : F ≅ G) (j : J) :\n    (conePointsIsoOfNatIso P Q w).hom ≫ t.π.app j = s.π.app j ≫ w.hom.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_hom_comp_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom (G.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointsIsoOfNatIso Q w).hom (CategoryTheory.CategoryStruct.comp (t.π.app j) h)) (CategoryTheory.CategoryStruct.comp (s.π.app j) (CategoryTheory.CategoryStruct.comp (w.hom.app j) h))","decl":"@[reassoc]\ntheorem conePointsIsoOfNatIso_hom_comp {F G : J ⥤ C} {s : Cone F} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (w : F ≅ G) (j : J) :\n    (conePointsIsoOfNatIso P Q w).hom ≫ t.π.app j = s.π.app j ≫ w.hom.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_inv_comp","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointsIsoOfNatIso Q w).inv (s.π.app j)) (CategoryTheory.CategoryStruct.comp (t.π.app j) (w.inv.app j))","decl":"@[reassoc]\ntheorem conePointsIsoOfNatIso_inv_comp {F G : J ⥤ C} {s : Cone F} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (w : F ≅ G) (j : J) :\n    (conePointsIsoOfNatIso P Q w).inv ≫ s.π.app j = t.π.app j ≫ w.inv.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_inv_comp_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointsIsoOfNatIso Q w).inv (CategoryTheory.CategoryStruct.comp (s.π.app j) h)) (CategoryTheory.CategoryStruct.comp (t.π.app j) (CategoryTheory.CategoryStruct.comp (w.inv.app j) h))","decl":"@[reassoc]\ntheorem conePointsIsoOfNatIso_inv_comp {F G : J ⥤ C} {s : Cone F} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (w : F ≅ G) (j : J) :\n    (conePointsIsoOfNatIso P Q w).inv ≫ s.π.app j = t.π.app j ≫ w.inv.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointsIsoOfNatIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nr s : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.lift r) (P.conePointsIsoOfNatIso Q w).hom) (CategoryTheory.Limits.IsLimit.map r Q w.hom)","decl":"@[reassoc]\ntheorem lift_comp_conePointsIsoOfNatIso_hom {F G : J ⥤ C} {r s : Cone F} {t : Cone G}\n    (P : IsLimit s) (Q : IsLimit t) (w : F ≅ G) :\n    P.lift r ≫ (conePointsIsoOfNatIso P Q w).hom = Q.map r w.hom :=\n  Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointsIsoOfNatIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nr s : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom t.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.lift r) (CategoryTheory.CategoryStruct.comp (P.conePointsIsoOfNatIso Q w).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.IsLimit.map r Q w.hom) h)","decl":"@[reassoc]\ntheorem lift_comp_conePointsIsoOfNatIso_hom {F G : J ⥤ C} {r s : Cone F} {t : Cone G}\n    (P : IsLimit s) (Q : IsLimit t) (w : F ≅ G) :\n    P.lift r ≫ (conePointsIsoOfNatIso P Q w).hom = Q.map r w.hom :=\n  Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointsIsoOfNatIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nr s : CategoryTheory.Limits.Cone G\nt : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit t\nQ : CategoryTheory.Limits.IsLimit s\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom t.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Q.lift r) (CategoryTheory.CategoryStruct.comp (P.conePointsIsoOfNatIso Q w).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.IsLimit.map r P w.inv) h)","decl":"@[reassoc]\ntheorem lift_comp_conePointsIsoOfNatIso_inv {F G : J ⥤ C} {r s : Cone G} {t : Cone F}\n    (P : IsLimit t) (Q : IsLimit s) (w : F ≅ G) :\n    Q.lift r ≫ (conePointsIsoOfNatIso P Q w).inv = P.map r w.inv :=\n  P.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointsIsoOfNatIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nr s : CategoryTheory.Limits.Cone G\nt : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit t\nQ : CategoryTheory.Limits.IsLimit s\nw : CategoryTheory.Iso F G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Q.lift r) (P.conePointsIsoOfNatIso Q w).inv) (CategoryTheory.Limits.IsLimit.map r P w.inv)","decl":"@[reassoc]\ntheorem lift_comp_conePointsIsoOfNatIso_inv {F G : J ⥤ C} {r s : Cone G} {t : Cone F}\n    (P : IsLimit t) (Q : IsLimit s) (w : F ≅ G) :\n    Q.lift r ≫ (conePointsIsoOfNatIso P Q w).inv = P.map r w.inv :=\n  P.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfEquivalence_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nG : CategoryTheory.Functor K C\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\n⊢ Eq (P.conePointsIsoOfEquivalence Q e w).inv (P.lift ((CategoryTheory.Limits.Cones.equivalenceOfReindexing e w).functor.obj t))","decl":"/-- We can prove two cone points `(s : Cone F).pt` and `(t : Cone G).pt` are isomorphic if\n* both cones are limit cones\n* their indexing categories are equivalent via some `e : J ≌ K`,\n* the triangle of functors commutes up to a natural isomorphism: `e.functor ⋙ G ≅ F`.\n\nThis is the most general form of uniqueness of cone points,\nallowing relabelling of both the indexing category (up to equivalence)\nand the functor (up to natural isomorphism).\n-/\n@[simps]\ndef conePointsIsoOfEquivalence {F : J ⥤ C} {s : Cone F} {G : K ⥤ C} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (e : J ≌ K) (w : e.functor ⋙ G ≅ F) : s.pt ≅ t.pt :=\n  let w' : e.inverse ⋙ F ≅ G := (isoWhiskerLeft e.inverse w).symm ≪≫ invFunIdAssoc e G\n  { hom := Q.lift ((Cones.equivalenceOfReindexing e.symm w').functor.obj s)\n    inv := P.lift ((Cones.equivalenceOfReindexing e w).functor.obj t)\n    hom_inv_id := by\n      apply hom_ext P; intro j\n      dsimp [w']\n      simp only [Limits.Cone.whisker_π, Limits.Cones.postcompose_obj_π, fac, whiskerLeft_app,\n        assoc, id_comp, invFunIdAssoc_hom_app, fac_assoc, NatTrans.comp_app]\n      rw [counit_app_functor, ← Functor.comp_map]\n      have l :\n        NatTrans.app w.hom j = NatTrans.app w.hom (Prefunctor.obj (𝟭 J).toPrefunctor j) := by dsimp\n      rw [l,w.hom.naturality]\n      simp\n    inv_hom_id := by\n      apply hom_ext Q\n      aesop_cat }\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfEquivalence_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nG : CategoryTheory.Functor K C\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\n⊢ Eq (P.conePointsIsoOfEquivalence Q e w).hom (Q.lift ((CategoryTheory.Limits.Cones.equivalenceOfReindexing e.symm ((CategoryTheory.isoWhiskerLeft e.inverse w).symm.trans (e.invFunIdAssoc G))).functor.obj s))","decl":"/-- We can prove two cone points `(s : Cone F).pt` and `(t : Cone G).pt` are isomorphic if\n* both cones are limit cones\n* their indexing categories are equivalent via some `e : J ≌ K`,\n* the triangle of functors commutes up to a natural isomorphism: `e.functor ⋙ G ≅ F`.\n\nThis is the most general form of uniqueness of cone points,\nallowing relabelling of both the indexing category (up to equivalence)\nand the functor (up to natural isomorphism).\n-/\n@[simps]\ndef conePointsIsoOfEquivalence {F : J ⥤ C} {s : Cone F} {G : K ⥤ C} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (e : J ≌ K) (w : e.functor ⋙ G ≅ F) : s.pt ≅ t.pt :=\n  let w' : e.inverse ⋙ F ≅ G := (isoWhiskerLeft e.inverse w).symm ≪≫ invFunIdAssoc e G\n  { hom := Q.lift ((Cones.equivalenceOfReindexing e.symm w').functor.obj s)\n    inv := P.lift ((Cones.equivalenceOfReindexing e w).functor.obj t)\n    hom_inv_id := by\n      apply hom_ext P; intro j\n      dsimp [w']\n      simp only [Limits.Cone.whisker_π, Limits.Cones.postcompose_obj_π, fac, whiskerLeft_app,\n        assoc, id_comp, invFunIdAssoc_hom_app, fac_assoc, NatTrans.comp_app]\n      rw [counit_app_functor, ← Functor.comp_map]\n      have l :\n        NatTrans.app w.hom j = NatTrans.app w.hom (Prefunctor.obj (𝟭 J).toPrefunctor j) := by dsimp\n      rw [l,w.hom.naturality]\n      simp\n    inv_hom_id := by\n      apply hom_ext Q\n      aesop_cat }\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.homIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nh : CategoryTheory.Limits.IsLimit t\nW : C\nf : ULift.{u₁, v₃} (Quiver.Hom W t.pt)\n⊢ Eq ((h.homIso W).hom f) (t.extend f.down).π","decl":"@[simp]\ntheorem homIso_hom (h : IsLimit t) {W : C} (f : ULift.{u₁} (W ⟶ t.pt)) :\n    (IsLimit.homIso h W).hom f = (t.extend f.down).π :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom_homOfCone","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.yoneda.obj X).comp CategoryTheory.uliftFunctor.{u₁, v₃}) F.cones\ns : CategoryTheory.Limits.Cone F\n⊢ Eq (CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom h (CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone h s)) s","decl":"@[simp]\ntheorem coneOfHom_homOfCone (s : Cone F) : coneOfHom h (homOfCone h s) = s := by\n  dsimp [coneOfHom, homOfCone]\n  match s with\n  | .mk s_pt s_π =>\n    congr; dsimp\n    convert congrFun (congrFun (congrArg NatTrans.app h.inv_hom_id) (op s_pt)) s_π using 1\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone_coneOfHom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.yoneda.obj X).comp CategoryTheory.uliftFunctor.{u₁, v₃}) F.cones\nY : C\nf : Quiver.Hom Y X\n⊢ Eq (CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone h (CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom h f)) f","decl":"@[simp]\ntheorem homOfCone_coneOfHom {Y : C} (f : Y ⟶ X) : homOfCone h (coneOfHom h f) = f :=\n  congrArg ULift.down (congrFun (congrFun (congrArg NatTrans.app h.hom_inv_id) (op Y)) ⟨f⟩ :)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom_fac","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.yoneda.obj X).comp CategoryTheory.uliftFunctor.{u₁, v₃}) F.cones\nY : C\nf : Quiver.Hom Y X\n⊢ Eq (CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom h f) ((CategoryTheory.Limits.IsLimit.OfNatIso.limitCone h).extend f)","decl":"/-- If `F.cones` is represented by `X`, the cone corresponding to a morphism `f : Y ⟶ X` is\nthe limit cone extended by `f`. -/\ntheorem coneOfHom_fac {Y : C} (f : Y ⟶ X) : coneOfHom h f = (limitCone h).extend f := by\n  dsimp [coneOfHom, limitCone, Cone.extend]\n  congr with j\n  have t := congrFun (h.hom.naturality f.op) ⟨𝟙 X⟩\n  dsimp at t\n  simp only [comp_id] at t\n  rw [congrFun (congrArg NatTrans.app t) j]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.OfNatIso.cone_fac","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.yoneda.obj X).comp CategoryTheory.uliftFunctor.{u₁, v₃}) F.cones\ns : CategoryTheory.Limits.Cone F\n⊢ Eq ((CategoryTheory.Limits.IsLimit.OfNatIso.limitCone h).extend (CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone h s)) s","decl":"/-- If `F.cones` is represented by `X`, any cone is the extension of the limit cone by the\ncorresponding morphism. -/\ntheorem cone_fac (s : Cone F) : (limitCone h).extend (homOfCone h s) = s := by\n  rw [← coneOfHom_homOfCone h s]\n  conv_lhs => simp only [homOfCone_coneOfHom]\n  apply (coneOfHom_fac _ _).symm\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.uniq","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nself : CategoryTheory.Limits.IsColimit t\ns : CategoryTheory.Limits.Cocone F\nm : Quiver.Hom t.pt s.pt\nx✝ : ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) m) (s.ι.app j)\n⊢ Eq m (self.desc s)","decl":"/-- A cocone `t` on `F` is a colimit cocone if each cocone on `F` admits a unique\ncocone morphism from `t`. -/\n@[stacks 002F]\nstructure IsColimit (t : Cocone F) where\n  /-- `t.pt` maps to all other cocone covertices -/\n  desc : ∀ s : Cocone F, t.pt ⟶ s.pt\n  /-- The map `desc` makes the diagram with the natural transformations commute -/\n  fac : ∀ (s : Cocone F) (j : J), t.ι.app j ≫ desc s = s.ι.app j := by aesop_cat\n  /-- `desc` is the unique such map -/\n  uniq :\n    ∀ (s : Cocone F) (m : t.pt ⟶ s.pt) (_ : ∀ j : J, t.ι.app j ≫ m = s.ι.app j), m = desc s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.mk.injEq","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\ndesc✝ : (s : CategoryTheory.Limits.Cocone F) → Quiver.Hom t.pt s.pt\nfac✝ : autoParam (∀ (s : CategoryTheory.Limits.Cocone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) (desc✝ s)) (s.ι.app j)) _auto✝\nuniq✝ : autoParam (∀ (s : CategoryTheory.Limits.Cocone F) (m : Quiver.Hom t.pt s.pt), (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) m) (s.ι.app j)) → Eq m (desc✝ s)) _auto✝\ndesc : (s : CategoryTheory.Limits.Cocone F) → Quiver.Hom t.pt s.pt\nfac : autoParam (∀ (s : CategoryTheory.Limits.Cocone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) (desc s)) (s.ι.app j)) _auto✝\nuniq : autoParam (∀ (s : CategoryTheory.Limits.Cocone F) (m : Quiver.Hom t.pt s.pt), (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) m) (s.ι.app j)) → Eq m (desc s)) _auto✝\n⊢ Eq (Eq { desc := desc✝, fac := fac✝, uniq := uniq✝ } { desc := desc, fac := fac, uniq := uniq }) (Eq desc✝ desc)","decl":"/-- A cocone `t` on `F` is a colimit cocone if each cocone on `F` admits a unique\ncocone morphism from `t`. -/\n@[stacks 002F]\nstructure IsColimit (t : Cocone F) where\n  /-- `t.pt` maps to all other cocone covertices -/\n  desc : ∀ s : Cocone F, t.pt ⟶ s.pt\n  /-- The map `desc` makes the diagram with the natural transformations commute -/\n  fac : ∀ (s : Cocone F) (j : J), t.ι.app j ≫ desc s = s.ι.app j := by aesop_cat\n  /-- `desc` is the unique such map -/\n  uniq :\n    ∀ (s : Cocone F) (m : t.pt ⟶ s.pt) (_ : ∀ j : J, t.ι.app j ≫ m = s.ι.app j), m = desc s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.mk.inj","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\ndesc✝ : (s : CategoryTheory.Limits.Cocone F) → Quiver.Hom t.pt s.pt\nfac✝ : autoParam (∀ (s : CategoryTheory.Limits.Cocone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) (desc✝ s)) (s.ι.app j)) _auto✝\nuniq✝ : autoParam (∀ (s : CategoryTheory.Limits.Cocone F) (m : Quiver.Hom t.pt s.pt), (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) m) (s.ι.app j)) → Eq m (desc✝ s)) _auto✝\ndesc : (s : CategoryTheory.Limits.Cocone F) → Quiver.Hom t.pt s.pt\nfac : autoParam (∀ (s : CategoryTheory.Limits.Cocone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) (desc s)) (s.ι.app j)) _auto✝\nuniq : autoParam (∀ (s : CategoryTheory.Limits.Cocone F) (m : Quiver.Hom t.pt s.pt), (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) m) (s.ι.app j)) → Eq m (desc s)) _auto✝\nx✝ : Eq { desc := desc✝, fac := fac✝, uniq := uniq✝ } { desc := desc, fac := fac, uniq := uniq }\n⊢ Eq desc✝ desc","decl":"/-- A cocone `t` on `F` is a colimit cocone if each cocone on `F` admits a unique\ncocone morphism from `t`. -/\n@[stacks 002F]\nstructure IsColimit (t : Cocone F) where\n  /-- `t.pt` maps to all other cocone covertices -/\n  desc : ∀ s : Cocone F, t.pt ⟶ s.pt\n  /-- The map `desc` makes the diagram with the natural transformations commute -/\n  fac : ∀ (s : Cocone F) (j : J), t.ι.app j ≫ desc s = s.ι.app j := by aesop_cat\n  /-- `desc` is the unique such map -/\n  uniq :\n    ∀ (s : Cocone F) (m : t.pt ⟶ s.pt) (_ : ∀ j : J, t.ι.app j ≫ m = s.ι.app j), m = desc s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\ninst✝¹ : SizeOf J\ninst✝ : SizeOf C\ndesc : (s : CategoryTheory.Limits.Cocone F) → Quiver.Hom t.pt s.pt\nfac : autoParam (∀ (s : CategoryTheory.Limits.Cocone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) (desc s)) (s.ι.app j)) _auto✝\nuniq : autoParam (∀ (s : CategoryTheory.Limits.Cocone F) (m : Quiver.Hom t.pt s.pt), (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) m) (s.ι.app j)) → Eq m (desc s)) _auto✝\n⊢ Eq (SizeOf.sizeOf { desc := desc, fac := fac, uniq := uniq }) 1","decl":"/-- A cocone `t` on `F` is a colimit cocone if each cocone on `F` admits a unique\ncocone morphism from `t`. -/\n@[stacks 002F]\nstructure IsColimit (t : Cocone F) where\n  /-- `t.pt` maps to all other cocone covertices -/\n  desc : ∀ s : Cocone F, t.pt ⟶ s.pt\n  /-- The map `desc` makes the diagram with the natural transformations commute -/\n  fac : ∀ (s : Cocone F) (j : J), t.ι.app j ≫ desc s = s.ι.app j := by aesop_cat\n  /-- `desc` is the unique such map -/\n  uniq :\n    ∀ (s : Cocone F) (m : t.pt ⟶ s.pt) (_ : ∀ j : J, t.ι.app j ≫ m = s.ι.app j), m = desc s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.fac","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nself : CategoryTheory.Limits.IsColimit t\ns : CategoryTheory.Limits.Cocone F\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) (self.desc s)) (s.ι.app j)","decl":"/-- A cocone `t` on `F` is a colimit cocone if each cocone on `F` admits a unique\ncocone morphism from `t`. -/\n@[stacks 002F]\nstructure IsColimit (t : Cocone F) where\n  /-- `t.pt` maps to all other cocone covertices -/\n  desc : ∀ s : Cocone F, t.pt ⟶ s.pt\n  /-- The map `desc` makes the diagram with the natural transformations commute -/\n  fac : ∀ (s : Cocone F) (j : J), t.ι.app j ≫ desc s = s.ι.app j := by aesop_cat\n  /-- `desc` is the unique such map -/\n  uniq :\n    ∀ (s : Cocone F) (m : t.pt ⟶ s.pt) (_ : ∀ j : J, t.ι.app j ≫ m = s.ι.app j), m = desc s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.fac_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nself : CategoryTheory.Limits.IsColimit t\ns : CategoryTheory.Limits.Cocone F\nj : J\nZ : C\nh : Quiver.Hom s.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) (CategoryTheory.CategoryStruct.comp (self.desc s) h)) (CategoryTheory.CategoryStruct.comp (s.ι.app j) h)","decl":"attribute [reassoc (attr := simp)] IsColimit.fac\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.subsingleton","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\n⊢ Subsingleton (CategoryTheory.Limits.IsColimit t)","decl":"instance subsingleton {t : Cocone F} : Subsingleton (IsColimit t) :=\n  ⟨by intro P Q; cases P; cases Q; congr; aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.ι_map_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nd : CategoryTheory.Limits.Cocone G\nα : Quiver.Hom F G\nj : J\nZ : C\nh : Quiver.Hom d.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (c.ι.app j) (CategoryTheory.CategoryStruct.comp (hc.map d α) h)) (CategoryTheory.CategoryStruct.comp (α.app j) (CategoryTheory.CategoryStruct.comp (d.ι.app j) h))","decl":"@[reassoc (attr := simp)]\ntheorem ι_map {F G : J ⥤ C} {c : Cocone F} (hc : IsColimit c) (d : Cocone G) (α : F ⟶ G) (j : J) :\n    c.ι.app j ≫ IsColimit.map hc d α = α.app j ≫ d.ι.app j :=\n  fac _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.ι_map","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nd : CategoryTheory.Limits.Cocone G\nα : Quiver.Hom F G\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (c.ι.app j) (hc.map d α)) (CategoryTheory.CategoryStruct.comp (α.app j) (d.ι.app j))","decl":"@[reassoc (attr := simp)]\ntheorem ι_map {F G : J ⥤ C} {c : Cocone F} (hc : IsColimit c) (d : Cocone G) (α : F ⟶ G) (j : J) :\n    c.ι.app j ≫ IsColimit.map hc d α = α.app j ≫ d.ι.app j :=\n  fac _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.desc_self","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\n⊢ Eq (h.desc t) (CategoryTheory.CategoryStruct.id t.pt)","decl":"@[simp]\ntheorem desc_self {t : Cocone F} (h : IsColimit t) : h.desc t = 𝟙 t.pt :=\n  (h.uniq _ _ fun _ => comp_id _).symm\n\n-- Repackaging the definition in terms of cocone morphisms.\n"}
{"name":"CategoryTheory.Limits.IsColimit.descCoconeMorphism_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq (h.descCoconeMorphism s).hom (h.desc s)","decl":"/-- The universal morphism from a colimit cocone to any other cocone. -/\n@[simps]\ndef descCoconeMorphism {t : Cocone F} (h : IsColimit t) (s : Cocone F) : t ⟶ s where hom := h.desc s\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.uniq_cocone_morphism","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nf f' : Quiver.Hom t s\n⊢ Eq f f'","decl":"theorem uniq_cocone_morphism {s t : Cocone F} (h : IsColimit t) {f f' : t ⟶ s} : f = f' :=\n  have : ∀ {g : t ⟶ s}, g = h.descCoconeMorphism s := by\n    intro g; ext; exact h.uniq _ _ g.w\n  this.trans this.symm\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.existsUnique","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\ns : CategoryTheory.Limits.Cocone F\n⊢ ExistsUnique fun d => ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) d) (s.ι.app j)","decl":"/-- Restating the definition of a colimit cocone in terms of the ∃! operator. -/\ntheorem existsUnique {t : Cocone F} (h : IsColimit t) (s : Cocone F) :\n    ∃! d : t.pt ⟶ s.pt, ∀ j, t.ι.app j ≫ d = s.ι.app j :=\n  ⟨h.desc s, h.fac s, h.uniq s⟩\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.mkCoconeMorphism_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\ndesc : (s : CategoryTheory.Limits.Cocone F) → Quiver.Hom t s\nuniq' : ∀ (s : CategoryTheory.Limits.Cocone F) (m : Quiver.Hom t s), Eq m (desc s)\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.IsColimit.mkCoconeMorphism desc uniq').desc s) (desc s).hom","decl":"/-- Alternative constructor for `IsColimit`,\nproviding a morphism of cocones rather than a morphism between the cocone points\nand separately the factorisation condition.\n-/\n@[simps]\ndef mkCoconeMorphism {t : Cocone F} (desc : ∀ s : Cocone F, t ⟶ s)\n    (uniq' : ∀ (s : Cocone F) (m : t ⟶ s), m = desc s) : IsColimit t where\n  desc s := (desc s).hom\n  uniq s m w :=\n    have : CoconeMorphism.mk m w = desc s := by apply uniq'\n    congrArg CoconeMorphism.hom this\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.uniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\n⊢ Eq (P.uniqueUpToIso Q).hom (P.descCoconeMorphism t)","decl":"/-- Colimit cocones on `F` are unique up to isomorphism. -/\n@[simps]\ndef uniqueUpToIso {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) : s ≅ t where\n  hom := P.descCoconeMorphism t\n  inv := Q.descCoconeMorphism s\n  hom_inv_id := P.uniq_cocone_morphism\n  inv_hom_id := Q.uniq_cocone_morphism\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.uniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\n⊢ Eq (P.uniqueUpToIso Q).inv (Q.descCoconeMorphism s)","decl":"/-- Colimit cocones on `F` are unique up to isomorphism. -/\n@[simps]\ndef uniqueUpToIso {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) : s ≅ t where\n  hom := P.descCoconeMorphism t\n  inv := Q.descCoconeMorphism s\n  hom_inv_id := P.uniq_cocone_morphism\n  inv_hom_id := Q.uniq_cocone_morphism\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.hom_isIso","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nf : Quiver.Hom s t\n⊢ CategoryTheory.IsIso f","decl":"/-- Any cocone morphism between colimit cocones is an isomorphism. -/\ntheorem hom_isIso {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) (f : s ⟶ t) : IsIso f :=\n  ⟨⟨Q.descCoconeMorphism s, ⟨P.uniq_cocone_morphism, Q.uniq_cocone_morphism⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointUniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (s.ι.app j) (P.coconePointUniqueUpToIso Q).hom) (t.ι.app j)","decl":"@[reassoc (attr := simp)]\ntheorem comp_coconePointUniqueUpToIso_hom {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t)\n    (j : J) : s.ι.app j ≫ (coconePointUniqueUpToIso P Q).hom = t.ι.app j :=\n  (uniqueUpToIso P Q).hom.w _\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointUniqueUpToIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nj : J\nZ : C\nh : Quiver.Hom t.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (s.ι.app j) (CategoryTheory.CategoryStruct.comp (P.coconePointUniqueUpToIso Q).hom h)) (CategoryTheory.CategoryStruct.comp (t.ι.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem comp_coconePointUniqueUpToIso_hom {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t)\n    (j : J) : s.ι.app j ≫ (coconePointUniqueUpToIso P Q).hom = t.ι.app j :=\n  (uniqueUpToIso P Q).hom.w _\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointUniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) (P.coconePointUniqueUpToIso Q).inv) (s.ι.app j)","decl":"@[reassoc (attr := simp)]\ntheorem comp_coconePointUniqueUpToIso_inv {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t)\n    (j : J) : t.ι.app j ≫ (coconePointUniqueUpToIso P Q).inv = s.ι.app j :=\n  (uniqueUpToIso P Q).inv.w _\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointUniqueUpToIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nj : J\nZ : C\nh : Quiver.Hom s.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) (CategoryTheory.CategoryStruct.comp (P.coconePointUniqueUpToIso Q).inv h)) (CategoryTheory.CategoryStruct.comp (s.ι.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem comp_coconePointUniqueUpToIso_inv {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t)\n    (j : J) : t.ι.app j ≫ (coconePointUniqueUpToIso P Q).inv = s.ι.app j :=\n  (uniqueUpToIso P Q).inv.w _\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso_hom_desc_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nZ : C\nh : Quiver.Hom r.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointUniqueUpToIso Q).hom (CategoryTheory.CategoryStruct.comp (Q.desc r) h)) (CategoryTheory.CategoryStruct.comp (P.desc r) h)","decl":"@[reassoc (attr := simp)]\ntheorem coconePointUniqueUpToIso_hom_desc {r s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) :\n    (coconePointUniqueUpToIso P Q).hom ≫ Q.desc r = P.desc r :=\n  P.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso_hom_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointUniqueUpToIso Q).hom (Q.desc r)) (P.desc r)","decl":"@[reassoc (attr := simp)]\ntheorem coconePointUniqueUpToIso_hom_desc {r s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) :\n    (coconePointUniqueUpToIso P Q).hom ≫ Q.desc r = P.desc r :=\n  P.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso_inv_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointUniqueUpToIso Q).inv (P.desc r)) (Q.desc r)","decl":"@[reassoc (attr := simp)]\ntheorem coconePointUniqueUpToIso_inv_desc {r s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) :\n    (coconePointUniqueUpToIso P Q).inv ≫ P.desc r = Q.desc r :=\n  Q.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso_inv_desc_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nZ : C\nh : Quiver.Hom r.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointUniqueUpToIso Q).inv (CategoryTheory.CategoryStruct.comp (P.desc r) h)) (CategoryTheory.CategoryStruct.comp (Q.desc r) h)","decl":"@[reassoc (attr := simp)]\ntheorem coconePointUniqueUpToIso_inv_desc {r s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) :\n    (coconePointUniqueUpToIso P Q).inv ≫ P.desc r = Q.desc r :=\n  Q.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.ofIsoColimit_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit r\ni : CategoryTheory.Iso r t\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq ((P.ofIsoColimit i).desc s) (CategoryTheory.CategoryStruct.comp i.inv.hom (P.desc s))","decl":"@[simp]\ntheorem ofIsoColimit_desc {r t : Cocone F} (P : IsColimit r) (i : r ≅ t) (s) :\n    (P.ofIsoColimit i).desc s = i.inv.hom ≫ P.desc s :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.equivIsoColimit_apply","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr t : CategoryTheory.Limits.Cocone F\ni : CategoryTheory.Iso r t\nP : CategoryTheory.Limits.IsColimit r\n⊢ Eq ((CategoryTheory.Limits.IsColimit.equivIsoColimit i) P) (P.ofIsoColimit i)","decl":"@[simp]\ntheorem equivIsoColimit_apply {r t : Cocone F} (i : r ≅ t) (P : IsColimit r) :\n    equivIsoColimit i P = P.ofIsoColimit i :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.equivIsoColimit_symm_apply","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nr t : CategoryTheory.Limits.Cocone F\ni : CategoryTheory.Iso r t\nP : CategoryTheory.Limits.IsColimit t\n⊢ Eq ((CategoryTheory.Limits.IsColimit.equivIsoColimit i).symm P) (P.ofIsoColimit i.symm)","decl":"@[simp]\ntheorem equivIsoColimit_symm_apply {r t : Cocone F} (i : r ≅ t) (P : IsColimit t) :\n    (equivIsoColimit i).symm P = P.ofIsoColimit i.symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.hom_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nW : C\nm : Quiver.Hom t.pt W\n⊢ Eq m (h.desc { pt := W, ι := { app := fun b => CategoryTheory.CategoryStruct.comp (t.ι.app b) m, naturality := ⋯ } })","decl":"theorem hom_desc (h : IsColimit t) {W : C} (m : t.pt ⟶ W) :\n    m =\n      h.desc\n        { pt := W\n          ι := { app := fun b => t.ι.app b ≫ m } } :=\n  h.uniq\n    { pt := W\n      ι := { app := fun b => t.ι.app b ≫ m } }\n    m fun _ => rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nW : C\nf f' : Quiver.Hom t.pt W\nw : ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) f) (CategoryTheory.CategoryStruct.comp (t.ι.app j) f')\n⊢ Eq f f'","decl":"/-- Two morphisms out of a colimit are equal if their compositions with\n  each cocone morphism are equal. -/\ntheorem hom_ext (h : IsColimit t) {W : C} {f f' : t.pt ⟶ W}\n    (w : ∀ j, t.ι.app j ≫ f = t.ι.app j ≫ f') : f = f' := by\n  rw [h.hom_desc f, h.hom_desc f']; congr; exact funext w\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.ofCoconeEquiv_apply_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nG : CategoryTheory.Functor K D\nh : CategoryTheory.Equivalence (CategoryTheory.Limits.Cocone G) (CategoryTheory.Limits.Cocone F)\nc : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit (h.functor.obj c)\ns : CategoryTheory.Limits.Cocone G\n⊢ Eq (((CategoryTheory.Limits.IsColimit.ofCoconeEquiv h) P).desc s) (CategoryTheory.CategoryStruct.comp (h.unit.app c).hom (CategoryTheory.CategoryStruct.comp (h.inverse.map (P.descCoconeMorphism (h.functor.obj s))).hom (h.unitInv.app s).hom))","decl":"@[simp]\ntheorem ofCoconeEquiv_apply_desc {D : Type u₄} [Category.{v₄} D] {G : K ⥤ D}\n    (h : Cocone G ≌ Cocone F) {c : Cocone G} (P : IsColimit (h.functor.obj c)) (s) :\n    (ofCoconeEquiv h P).desc s =\n      (h.unit.app c).hom ≫\n        (h.inverse.map (P.descCoconeMorphism (h.functor.obj s))).hom ≫ (h.unitInv.app s).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.ofCoconeEquiv_symm_apply_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nG : CategoryTheory.Functor K D\nh : CategoryTheory.Equivalence (CategoryTheory.Limits.Cocone G) (CategoryTheory.Limits.Cocone F)\nc : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit c\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq (((CategoryTheory.Limits.IsColimit.ofCoconeEquiv h).symm P).desc s) (CategoryTheory.CategoryStruct.comp (h.functor.map (P.descCoconeMorphism (h.inverse.obj s))).hom (h.counit.app s).hom)","decl":"@[simp]\ntheorem ofCoconeEquiv_symm_apply_desc {D : Type u₄} [Category.{v₄} D] {G : K ⥤ D}\n    (h : Cocone G ≌ Cocone F) {c : Cocone G} (P : IsColimit c) (s) :\n    ((ofCoconeEquiv h).symm P).desc s =\n      (h.functor.map (P.descCoconeMorphism (h.inverse.obj s))).hom ≫ (h.counit.app s).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\n⊢ Eq (P.coconePointsIsoOfNatIso Q w).hom (P.map t w.hom)","decl":"/-- The cocone points of two colimit cocones for naturally isomorphic functors\nare themselves isomorphic.\n-/\n@[simps]\ndef coconePointsIsoOfNatIso {F G : J ⥤ C} {s : Cocone F} {t : Cocone G} (P : IsColimit s)\n    (Q : IsColimit t) (w : F ≅ G) : s.pt ≅ t.pt where\n  hom := P.map t w.hom\n  inv := Q.map s w.inv\n  hom_inv_id := P.hom_ext (by simp)\n  inv_hom_id := Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\n⊢ Eq (P.coconePointsIsoOfNatIso Q w).inv (Q.map s w.inv)","decl":"/-- The cocone points of two colimit cocones for naturally isomorphic functors\nare themselves isomorphic.\n-/\n@[simps]\ndef coconePointsIsoOfNatIso {F G : J ⥤ C} {s : Cocone F} {t : Cocone G} (P : IsColimit s)\n    (Q : IsColimit t) (w : F ≅ G) : s.pt ≅ t.pt where\n  hom := P.map t w.hom\n  inv := Q.map s w.inv\n  hom_inv_id := P.hom_ext (by simp)\n  inv_hom_id := Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointsIsoOfNatIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom t.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (s.ι.app j) (CategoryTheory.CategoryStruct.comp (P.coconePointsIsoOfNatIso Q w).hom h)) (CategoryTheory.CategoryStruct.comp (w.hom.app j) (CategoryTheory.CategoryStruct.comp (t.ι.app j) h))","decl":"@[reassoc]\ntheorem comp_coconePointsIsoOfNatIso_hom {F G : J ⥤ C} {s : Cocone F} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F ≅ G) (j : J) :\n    s.ι.app j ≫ (coconePointsIsoOfNatIso P Q w).hom = w.hom.app j ≫ t.ι.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointsIsoOfNatIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (s.ι.app j) (P.coconePointsIsoOfNatIso Q w).hom) (CategoryTheory.CategoryStruct.comp (w.hom.app j) (t.ι.app j))","decl":"@[reassoc]\ntheorem comp_coconePointsIsoOfNatIso_hom {F G : J ⥤ C} {s : Cocone F} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F ≅ G) (j : J) :\n    s.ι.app j ≫ (coconePointsIsoOfNatIso P Q w).hom = w.hom.app j ≫ t.ι.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointsIsoOfNatIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) (P.coconePointsIsoOfNatIso Q w).inv) (CategoryTheory.CategoryStruct.comp (w.inv.app j) (s.ι.app j))","decl":"@[reassoc]\ntheorem comp_coconePointsIsoOfNatIso_inv {F G : J ⥤ C} {s : Cocone F} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F ≅ G) (j : J) :\n    t.ι.app j ≫ (coconePointsIsoOfNatIso P Q w).inv = w.inv.app j ≫ s.ι.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointsIsoOfNatIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom s.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (t.ι.app j) (CategoryTheory.CategoryStruct.comp (P.coconePointsIsoOfNatIso Q w).inv h)) (CategoryTheory.CategoryStruct.comp (w.inv.app j) (CategoryTheory.CategoryStruct.comp (s.ι.app j) h))","decl":"@[reassoc]\ntheorem comp_coconePointsIsoOfNatIso_inv {F G : J ⥤ C} {s : Cocone F} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F ≅ G) (j : J) :\n    t.ι.app j ≫ (coconePointsIsoOfNatIso P Q w).inv = w.inv.app j ≫ s.ι.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_hom_desc_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nr t : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom r.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointsIsoOfNatIso Q w).hom (CategoryTheory.CategoryStruct.comp (Q.desc r) h)) (CategoryTheory.CategoryStruct.comp (P.map r w.hom) h)","decl":"@[reassoc]\ntheorem coconePointsIsoOfNatIso_hom_desc {F G : J ⥤ C} {s : Cocone F} {r t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F ≅ G) :\n    (coconePointsIsoOfNatIso P Q w).hom ≫ Q.desc r = P.map _ w.hom :=\n  P.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_hom_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nr t : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointsIsoOfNatIso Q w).hom (Q.desc r)) (P.map r w.hom)","decl":"@[reassoc]\ntheorem coconePointsIsoOfNatIso_hom_desc {F G : J ⥤ C} {s : Cocone F} {r t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F ≅ G) :\n    (coconePointsIsoOfNatIso P Q w).hom ≫ Q.desc r = P.map _ w.hom :=\n  P.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_inv_desc_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone G\nr t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit t\nQ : CategoryTheory.Limits.IsColimit s\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom r.pt Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointsIsoOfNatIso Q w).inv (CategoryTheory.CategoryStruct.comp (P.desc r) h)) (CategoryTheory.CategoryStruct.comp (Q.map r w.inv) h)","decl":"@[reassoc]\ntheorem coconePointsIsoOfNatIso_inv_desc {F G : J ⥤ C} {s : Cocone G} {r t : Cocone F}\n    (P : IsColimit t) (Q : IsColimit s) (w : F ≅ G) :\n    (coconePointsIsoOfNatIso P Q w).inv ≫ P.desc r = Q.map _ w.inv :=\n  Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_inv_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone G\nr t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit t\nQ : CategoryTheory.Limits.IsColimit s\nw : CategoryTheory.Iso F G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointsIsoOfNatIso Q w).inv (P.desc r)) (Q.map r w.inv)","decl":"@[reassoc]\ntheorem coconePointsIsoOfNatIso_inv_desc {F G : J ⥤ C} {s : Cocone G} {r t : Cocone F}\n    (P : IsColimit t) (Q : IsColimit s) (w : F ≅ G) :\n    (coconePointsIsoOfNatIso P Q w).inv ≫ P.desc r = Q.map _ w.inv :=\n  Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfEquivalence_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nG : CategoryTheory.Functor K C\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\n⊢ Eq (P.coconePointsIsoOfEquivalence Q e w).hom (P.desc ((CategoryTheory.Limits.Cocones.equivalenceOfReindexing e w).functor.obj t))","decl":"/-- We can prove two cocone points `(s : Cocone F).pt` and `(t : Cocone G).pt` are isomorphic if\n* both cocones are colimit cocones\n* their indexing categories are equivalent via some `e : J ≌ K`,\n* the triangle of functors commutes up to a natural isomorphism: `e.functor ⋙ G ≅ F`.\n\nThis is the most general form of uniqueness of cocone points,\nallowing relabelling of both the indexing category (up to equivalence)\nand the functor (up to natural isomorphism).\n-/\n@[simps]\ndef coconePointsIsoOfEquivalence {F : J ⥤ C} {s : Cocone F} {G : K ⥤ C} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (e : J ≌ K) (w : e.functor ⋙ G ≅ F) : s.pt ≅ t.pt :=\n  let w' : e.inverse ⋙ F ≅ G := (isoWhiskerLeft e.inverse w).symm ≪≫ invFunIdAssoc e G\n  { hom := P.desc ((Cocones.equivalenceOfReindexing e w).functor.obj t)\n    inv := Q.desc ((Cocones.equivalenceOfReindexing e.symm w').functor.obj s)\n    hom_inv_id := by\n      apply hom_ext P; intro j\n      dsimp [w']\n      simp only [Limits.Cocone.whisker_ι, fac, invFunIdAssoc_inv_app, whiskerLeft_app, assoc,\n        comp_id, Limits.Cocones.precompose_obj_ι, fac_assoc, NatTrans.comp_app]\n      rw [counitInv_app_functor, ← Functor.comp_map, ← w.inv.naturality_assoc]\n      dsimp\n      simp\n    inv_hom_id := by\n      apply hom_ext Q\n      aesop_cat }\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfEquivalence_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nG : CategoryTheory.Functor K C\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\n⊢ Eq (P.coconePointsIsoOfEquivalence Q e w).inv (Q.desc ((CategoryTheory.Limits.Cocones.equivalenceOfReindexing e.symm ((CategoryTheory.isoWhiskerLeft e.inverse w).symm.trans (e.invFunIdAssoc G))).functor.obj s))","decl":"/-- We can prove two cocone points `(s : Cocone F).pt` and `(t : Cocone G).pt` are isomorphic if\n* both cocones are colimit cocones\n* their indexing categories are equivalent via some `e : J ≌ K`,\n* the triangle of functors commutes up to a natural isomorphism: `e.functor ⋙ G ≅ F`.\n\nThis is the most general form of uniqueness of cocone points,\nallowing relabelling of both the indexing category (up to equivalence)\nand the functor (up to natural isomorphism).\n-/\n@[simps]\ndef coconePointsIsoOfEquivalence {F : J ⥤ C} {s : Cocone F} {G : K ⥤ C} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (e : J ≌ K) (w : e.functor ⋙ G ≅ F) : s.pt ≅ t.pt :=\n  let w' : e.inverse ⋙ F ≅ G := (isoWhiskerLeft e.inverse w).symm ≪≫ invFunIdAssoc e G\n  { hom := P.desc ((Cocones.equivalenceOfReindexing e w).functor.obj t)\n    inv := Q.desc ((Cocones.equivalenceOfReindexing e.symm w').functor.obj s)\n    hom_inv_id := by\n      apply hom_ext P; intro j\n      dsimp [w']\n      simp only [Limits.Cocone.whisker_ι, fac, invFunIdAssoc_inv_app, whiskerLeft_app, assoc,\n        comp_id, Limits.Cocones.precompose_obj_ι, fac_assoc, NatTrans.comp_app]\n      rw [counitInv_app_functor, ← Functor.comp_map, ← w.inv.naturality_assoc]\n      dsimp\n      simp\n    inv_hom_id := by\n      apply hom_ext Q\n      aesop_cat }\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.homEquiv_apply","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nW : C\nf : Quiver.Hom t.pt W\n⊢ Eq ((h.homEquiv W) f) (t.extend f).ι","decl":"@[simp]\nlemma homEquiv_apply (h : IsColimit t) {W : C} (f : t.pt ⟶ W) :\n    h.homEquiv W f = (t.extend f).ι := rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.homIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nW : C\nf : ULift.{u₁, v₃} (Quiver.Hom t.pt W)\n⊢ Eq ((h.homIso W).hom f) (t.extend f.down).ι","decl":"@[simp]\ntheorem homIso_hom (h : IsColimit t) {W : C} (f : ULift (t.pt ⟶ W)) :\n    (IsColimit.homIso h W).hom f = (t.extend f.down).ι :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom_homOfCocone","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.coyoneda.obj { unop := X }).comp CategoryTheory.uliftFunctor.{u₁, v₃}) F.cocones\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq (CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom h (CategoryTheory.Limits.IsColimit.OfNatIso.homOfCocone h s)) s","decl":"@[simp]\ntheorem coconeOfHom_homOfCocone (s : Cocone F) : coconeOfHom h (homOfCocone h s) = s := by\n  dsimp [coconeOfHom, homOfCocone]\n  have ⟨s_pt,s_ι⟩ := s\n  congr; dsimp\n  convert congrFun (congrFun (congrArg NatTrans.app h.inv_hom_id) s_pt) s_ι using 1\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.OfNatIso.homOfCocone_cooneOfHom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.coyoneda.obj { unop := X }).comp CategoryTheory.uliftFunctor.{u₁, v₃}) F.cocones\nY : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Limits.IsColimit.OfNatIso.homOfCocone h (CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom h f)) f","decl":"@[simp]\ntheorem homOfCocone_cooneOfHom {Y : C} (f : X ⟶ Y) : homOfCocone h (coconeOfHom h f) = f :=\n  congrArg ULift.down (congrFun (congrFun (congrArg NatTrans.app h.hom_inv_id) Y) ⟨f⟩ :)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom_fac","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.coyoneda.obj { unop := X }).comp CategoryTheory.uliftFunctor.{u₁, v₃}) F.cocones\nY : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom h f) ((CategoryTheory.Limits.IsColimit.OfNatIso.colimitCocone h).extend f)","decl":"/-- If `F.cocones` is corepresented by `X`, the cocone corresponding to a morphism `f : Y ⟶ X` is\nthe colimit cocone extended by `f`. -/\ntheorem coconeOfHom_fac {Y : C} (f : X ⟶ Y) : coconeOfHom h f = (colimitCocone h).extend f := by\n  dsimp [coconeOfHom, colimitCocone, Cocone.extend]\n  congr with j\n  have t := congrFun (h.hom.naturality f) ⟨𝟙 X⟩\n  dsimp at t\n  simp only [id_comp] at t\n  rw [congrFun (congrArg NatTrans.app t) j]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.OfNatIso.cocone_fac","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.coyoneda.obj { unop := X }).comp CategoryTheory.uliftFunctor.{u₁, v₃}) F.cocones\ns : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.IsColimit.OfNatIso.colimitCocone h).extend (CategoryTheory.Limits.IsColimit.OfNatIso.homOfCocone h s)) s","decl":"/-- If `F.cocones` is corepresented by `X`, any cocone is the extension of the colimit cocone by the\ncorresponding morphism. -/\ntheorem cocone_fac (s : Cocone F) : (colimitCocone h).extend (homOfCocone h s) = s := by\n  rw [← coconeOfHom_homOfCocone h s]\n  conv_lhs => simp only [homOfCocone_cooneOfHom]\n  apply (coconeOfHom_fac _ _).symm\n\n"}
