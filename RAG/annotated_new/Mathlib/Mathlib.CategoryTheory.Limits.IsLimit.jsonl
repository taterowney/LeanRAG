{"name":"CategoryTheory.Limits.IsLimit.uniq","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nself : CategoryTheory.Limits.IsLimit t\ns : CategoryTheory.Limits.Cone F\nm : Quiver.Hom s.pt t.pt\nx‚úù : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp m (t.œÄ.app j)) (s.œÄ.app j)\n‚ä¢ Eq m (self.lift s)","decl":"/-- A cone `t` on `F` is a limit cone if each cone on `F` admits a unique\ncone morphism to `t`. -/\n@[stacks 002E]\nstructure IsLimit (t : Cone F) where\n  /-- There is a morphism from any cone point to `t.pt` -/\n  lift : ‚àÄ s : Cone F, s.pt ‚ü∂ t.pt\n  /-- The map makes the triangle with the two natural transformations commute -/\n  fac : ‚àÄ (s : Cone F) (j : J), lift s ‚â´ t.œÄ.app j = s.œÄ.app j := by aesop_cat\n  /-- It is the unique such map to do this -/\n  uniq : ‚àÄ (s : Cone F) (m : s.pt ‚ü∂ t.pt) (_ : ‚àÄ j : J, m ‚â´ t.œÄ.app j = s.œÄ.app j), m = lift s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.fac","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nself : CategoryTheory.Limits.IsLimit t\ns : CategoryTheory.Limits.Cone F\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.lift s) (t.œÄ.app j)) (s.œÄ.app j)","decl":"/-- A cone `t` on `F` is a limit cone if each cone on `F` admits a unique\ncone morphism to `t`. -/\n@[stacks 002E]\nstructure IsLimit (t : Cone F) where\n  /-- There is a morphism from any cone point to `t.pt` -/\n  lift : ‚àÄ s : Cone F, s.pt ‚ü∂ t.pt\n  /-- The map makes the triangle with the two natural transformations commute -/\n  fac : ‚àÄ (s : Cone F) (j : J), lift s ‚â´ t.œÄ.app j = s.œÄ.app j := by aesop_cat\n  /-- It is the unique such map to do this -/\n  uniq : ‚àÄ (s : Cone F) (m : s.pt ‚ü∂ t.pt) (_ : ‚àÄ j : J, m ‚â´ t.œÄ.app j = s.œÄ.app j), m = lift s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.mk.inj","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nlift‚úù : (s : CategoryTheory.Limits.Cone F) ‚Üí Quiver.Hom s.pt t.pt\nfac‚úù : autoParam (‚àÄ (s : CategoryTheory.Limits.Cone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (lift‚úù s) (t.œÄ.app j)) (s.œÄ.app j)) _auto‚úù\nuniq‚úù : autoParam (‚àÄ (s : CategoryTheory.Limits.Cone F) (m : Quiver.Hom s.pt t.pt), (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp m (t.œÄ.app j)) (s.œÄ.app j)) ‚Üí Eq m (lift‚úù s)) _auto‚úù\nlift : (s : CategoryTheory.Limits.Cone F) ‚Üí Quiver.Hom s.pt t.pt\nfac : autoParam (‚àÄ (s : CategoryTheory.Limits.Cone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (lift s) (t.œÄ.app j)) (s.œÄ.app j)) _auto‚úù\nuniq : autoParam (‚àÄ (s : CategoryTheory.Limits.Cone F) (m : Quiver.Hom s.pt t.pt), (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp m (t.œÄ.app j)) (s.œÄ.app j)) ‚Üí Eq m (lift s)) _auto‚úù\nx‚úù : Eq { lift := lift‚úù, fac := fac‚úù, uniq := uniq‚úù } { lift := lift, fac := fac, uniq := uniq }\n‚ä¢ Eq lift‚úù lift","decl":"/-- A cone `t` on `F` is a limit cone if each cone on `F` admits a unique\ncone morphism to `t`. -/\n@[stacks 002E]\nstructure IsLimit (t : Cone F) where\n  /-- There is a morphism from any cone point to `t.pt` -/\n  lift : ‚àÄ s : Cone F, s.pt ‚ü∂ t.pt\n  /-- The map makes the triangle with the two natural transformations commute -/\n  fac : ‚àÄ (s : Cone F) (j : J), lift s ‚â´ t.œÄ.app j = s.œÄ.app j := by aesop_cat\n  /-- It is the unique such map to do this -/\n  uniq : ‚àÄ (s : Cone F) (m : s.pt ‚ü∂ t.pt) (_ : ‚àÄ j : J, m ‚â´ t.œÄ.app j = s.œÄ.app j), m = lift s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.mk.injEq","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nlift‚úù : (s : CategoryTheory.Limits.Cone F) ‚Üí Quiver.Hom s.pt t.pt\nfac‚úù : autoParam (‚àÄ (s : CategoryTheory.Limits.Cone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (lift‚úù s) (t.œÄ.app j)) (s.œÄ.app j)) _auto‚úù\nuniq‚úù : autoParam (‚àÄ (s : CategoryTheory.Limits.Cone F) (m : Quiver.Hom s.pt t.pt), (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp m (t.œÄ.app j)) (s.œÄ.app j)) ‚Üí Eq m (lift‚úù s)) _auto‚úù\nlift : (s : CategoryTheory.Limits.Cone F) ‚Üí Quiver.Hom s.pt t.pt\nfac : autoParam (‚àÄ (s : CategoryTheory.Limits.Cone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (lift s) (t.œÄ.app j)) (s.œÄ.app j)) _auto‚úù\nuniq : autoParam (‚àÄ (s : CategoryTheory.Limits.Cone F) (m : Quiver.Hom s.pt t.pt), (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp m (t.œÄ.app j)) (s.œÄ.app j)) ‚Üí Eq m (lift s)) _auto‚úù\n‚ä¢ Eq (Eq { lift := lift‚úù, fac := fac‚úù, uniq := uniq‚úù } { lift := lift, fac := fac, uniq := uniq }) (Eq lift‚úù lift)","decl":"/-- A cone `t` on `F` is a limit cone if each cone on `F` admits a unique\ncone morphism to `t`. -/\n@[stacks 002E]\nstructure IsLimit (t : Cone F) where\n  /-- There is a morphism from any cone point to `t.pt` -/\n  lift : ‚àÄ s : Cone F, s.pt ‚ü∂ t.pt\n  /-- The map makes the triangle with the two natural transformations commute -/\n  fac : ‚àÄ (s : Cone F) (j : J), lift s ‚â´ t.œÄ.app j = s.œÄ.app j := by aesop_cat\n  /-- It is the unique such map to do this -/\n  uniq : ‚àÄ (s : Cone F) (m : s.pt ‚ü∂ t.pt) (_ : ‚àÄ j : J, m ‚â´ t.œÄ.app j = s.œÄ.app j), m = lift s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\ninst‚úù¬π : SizeOf J\ninst‚úù : SizeOf C\nlift : (s : CategoryTheory.Limits.Cone F) ‚Üí Quiver.Hom s.pt t.pt\nfac : autoParam (‚àÄ (s : CategoryTheory.Limits.Cone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (lift s) (t.œÄ.app j)) (s.œÄ.app j)) _auto‚úù\nuniq : autoParam (‚àÄ (s : CategoryTheory.Limits.Cone F) (m : Quiver.Hom s.pt t.pt), (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp m (t.œÄ.app j)) (s.œÄ.app j)) ‚Üí Eq m (lift s)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { lift := lift, fac := fac, uniq := uniq }) 1","decl":"/-- A cone `t` on `F` is a limit cone if each cone on `F` admits a unique\ncone morphism to `t`. -/\n@[stacks 002E]\nstructure IsLimit (t : Cone F) where\n  /-- There is a morphism from any cone point to `t.pt` -/\n  lift : ‚àÄ s : Cone F, s.pt ‚ü∂ t.pt\n  /-- The map makes the triangle with the two natural transformations commute -/\n  fac : ‚àÄ (s : Cone F) (j : J), lift s ‚â´ t.œÄ.app j = s.œÄ.app j := by aesop_cat\n  /-- It is the unique such map to do this -/\n  uniq : ‚àÄ (s : Cone F) (m : s.pt ‚ü∂ t.pt) (_ : ‚àÄ j : J, m ‚â´ t.œÄ.app j = s.œÄ.app j), m = lift s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.fac_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nself : CategoryTheory.Limits.IsLimit t\ns : CategoryTheory.Limits.Cone F\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.lift s) (CategoryTheory.CategoryStruct.comp (t.œÄ.app j) h)) (CategoryTheory.CategoryStruct.comp (s.œÄ.app j) h)","decl":"attribute [reassoc (attr := simp)] IsLimit.fac\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.subsingleton","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\n‚ä¢ Subsingleton (CategoryTheory.Limits.IsLimit t)","decl":"instance subsingleton {t : Cone F} : Subsingleton (IsLimit t) :=\n  ‚ü®by intro P Q; cases P; cases Q; congr; aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.map_œÄ","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nd : CategoryTheory.Limits.Cone G\nhd : CategoryTheory.Limits.IsLimit d\nŒ± : Quiver.Hom F G\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.IsLimit.map c hd Œ±) (d.œÄ.app j)) (CategoryTheory.CategoryStruct.comp (c.œÄ.app j) (Œ±.app j))","decl":"@[reassoc (attr := simp)]\ntheorem map_œÄ {F G : J ‚•§ C} (c : Cone F) {d : Cone G} (hd : IsLimit d) (Œ± : F ‚ü∂ G) (j : J) :\n    hd.map c Œ± ‚â´ d.œÄ.app j = c.œÄ.app j ‚â´ Œ±.app j :=\n  fac _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.map_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nd : CategoryTheory.Limits.Cone G\nhd : CategoryTheory.Limits.IsLimit d\nŒ± : Quiver.Hom F G\nj : J\nZ : C\nh : Quiver.Hom (G.obj j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.IsLimit.map c hd Œ±) (CategoryTheory.CategoryStruct.comp (d.œÄ.app j) h)) (CategoryTheory.CategoryStruct.comp (c.œÄ.app j) (CategoryTheory.CategoryStruct.comp (Œ±.app j) h))","decl":"@[reassoc (attr := simp)]\ntheorem map_œÄ {F G : J ‚•§ C} (c : Cone F) {d : Cone G} (hd : IsLimit d) (Œ± : F ‚ü∂ G) (j : J) :\n    hd.map c Œ± ‚â´ d.œÄ.app j = c.œÄ.app j ‚â´ Œ±.app j :=\n  fac _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_self","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.IsLimit c\n‚ä¢ Eq (t.lift c) (CategoryTheory.CategoryStruct.id c.pt)","decl":"@[simp]\ntheorem lift_self {c : Cone F} (t : IsLimit c) : t.lift c = ùüô c.pt :=\n  (t.uniq _ _ fun _ => id_comp _).symm\n\n-- Repackaging the definition in terms of cone morphisms.\n"}
{"name":"CategoryTheory.Limits.IsLimit.liftConeMorphism_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nh : CategoryTheory.Limits.IsLimit t\ns : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (h.liftConeMorphism s).hom (h.lift s)","decl":"/-- The universal morphism from any other cone to a limit cone. -/\n@[simps]\ndef liftConeMorphism {t : Cone F} (h : IsLimit t) (s : Cone F) : s ‚ü∂ t where hom := h.lift s\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.uniq_cone_morphism","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nh : CategoryTheory.Limits.IsLimit t\nf f' : Quiver.Hom s t\n‚ä¢ Eq f f'","decl":"theorem uniq_cone_morphism {s t : Cone F} (h : IsLimit t) {f f' : s ‚ü∂ t} : f = f' :=\n  have : ‚àÄ {g : s ‚ü∂ t}, g = h.liftConeMorphism s := by\n    intro g; apply ConeMorphism.ext; exact h.uniq _ _ g.w\n  this.trans this.symm\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.existsUnique","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nh : CategoryTheory.Limits.IsLimit t\ns : CategoryTheory.Limits.Cone F\n‚ä¢ ExistsUnique fun l => ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp l (t.œÄ.app j)) (s.œÄ.app j)","decl":"/-- Restating the definition of a limit cone in terms of the ‚àÉ! operator. -/\ntheorem existsUnique {t : Cone F} (h : IsLimit t) (s : Cone F) :\n    ‚àÉ! l : s.pt ‚ü∂ t.pt, ‚àÄ j, l ‚â´ t.œÄ.app j = s.œÄ.app j :=\n  ‚ü®h.lift s, h.fac s, h.uniq s‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.mkConeMorphism_lift","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nlift : (s : CategoryTheory.Limits.Cone F) ‚Üí Quiver.Hom s t\nuniq : ‚àÄ (s : CategoryTheory.Limits.Cone F) (m : Quiver.Hom s t), Eq m (lift s)\ns : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Limits.IsLimit.mkConeMorphism lift uniq).lift s) (lift s).hom","decl":"/-- Alternative constructor for `isLimit`,\nproviding a morphism of cones rather than a morphism between the cone points\nand separately the factorisation condition.\n-/\n@[simps]\ndef mkConeMorphism {t : Cone F} (lift : ‚àÄ s : Cone F, s ‚ü∂ t)\n    (uniq : ‚àÄ (s : Cone F) (m : s ‚ü∂ t), m = lift s) : IsLimit t where\n  lift s := (lift s).hom\n  uniq s m w :=\n    have : ConeMorphism.mk m w = lift s := by apply uniq\n    congrArg ConeMorphism.hom this\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.uniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\n‚ä¢ Eq (P.uniqueUpToIso Q).hom (Q.liftConeMorphism s)","decl":"/-- Limit cones on `F` are unique up to isomorphism. -/\n@[simps]\ndef uniqueUpToIso {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) : s ‚âÖ t where\n  hom := Q.liftConeMorphism s\n  inv := P.liftConeMorphism t\n  hom_inv_id := P.uniq_cone_morphism\n  inv_hom_id := Q.uniq_cone_morphism\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.uniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\n‚ä¢ Eq (P.uniqueUpToIso Q).inv (P.liftConeMorphism t)","decl":"/-- Limit cones on `F` are unique up to isomorphism. -/\n@[simps]\ndef uniqueUpToIso {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) : s ‚âÖ t where\n  hom := Q.liftConeMorphism s\n  inv := P.liftConeMorphism t\n  hom_inv_id := P.uniq_cone_morphism\n  inv_hom_id := Q.uniq_cone_morphism\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.hom_isIso","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nf : Quiver.Hom s t\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Any cone morphism between limit cones is an isomorphism. -/\ntheorem hom_isIso {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (f : s ‚ü∂ t) : IsIso f :=\n  ‚ü®‚ü®P.liftConeMorphism t, ‚ü®P.uniq_cone_morphism, Q.uniq_cone_morphism‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso_hom_comp_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointUniqueUpToIso Q).hom (CategoryTheory.CategoryStruct.comp (t.œÄ.app j) h)) (CategoryTheory.CategoryStruct.comp (s.œÄ.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem conePointUniqueUpToIso_hom_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    (conePointUniqueUpToIso P Q).hom ‚â´ t.œÄ.app j = s.œÄ.app j :=\n  (uniqueUpToIso P Q).hom.w _\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso_hom_comp","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointUniqueUpToIso Q).hom (t.œÄ.app j)) (s.œÄ.app j)","decl":"@[reassoc (attr := simp)]\ntheorem conePointUniqueUpToIso_hom_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    (conePointUniqueUpToIso P Q).hom ‚â´ t.œÄ.app j = s.œÄ.app j :=\n  (uniqueUpToIso P Q).hom.w _\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso_inv_comp_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointUniqueUpToIso Q).inv (CategoryTheory.CategoryStruct.comp (s.œÄ.app j) h)) (CategoryTheory.CategoryStruct.comp (t.œÄ.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem conePointUniqueUpToIso_inv_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    (conePointUniqueUpToIso P Q).inv ‚â´ s.œÄ.app j = t.œÄ.app j :=\n  (uniqueUpToIso P Q).inv.w _\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso_inv_comp","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointUniqueUpToIso Q).inv (s.œÄ.app j)) (t.œÄ.app j)","decl":"@[reassoc (attr := simp)]\ntheorem conePointUniqueUpToIso_inv_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    (conePointUniqueUpToIso P Q).inv ‚â´ s.œÄ.app j = t.œÄ.app j :=\n  (uniqueUpToIso P Q).inv.w _\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointUniqueUpToIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nZ : C\nh : Quiver.Hom t.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.lift r) (CategoryTheory.CategoryStruct.comp (P.conePointUniqueUpToIso Q).hom h)) (CategoryTheory.CategoryStruct.comp (Q.lift r) h)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_conePointUniqueUpToIso_hom {r s t : Cone F} (P : IsLimit s) (Q : IsLimit t) :\n    P.lift r ‚â´ (conePointUniqueUpToIso P Q).hom = Q.lift r :=\n  Q.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointUniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.lift r) (P.conePointUniqueUpToIso Q).hom) (Q.lift r)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_conePointUniqueUpToIso_hom {r s t : Cone F} (P : IsLimit s) (Q : IsLimit t) :\n    P.lift r ‚â´ (conePointUniqueUpToIso P Q).hom = Q.lift r :=\n  Q.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointUniqueUpToIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nZ : C\nh : Quiver.Hom s.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Q.lift r) (CategoryTheory.CategoryStruct.comp (P.conePointUniqueUpToIso Q).inv h)) (CategoryTheory.CategoryStruct.comp (P.lift r) h)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_conePointUniqueUpToIso_inv {r s t : Cone F} (P : IsLimit s) (Q : IsLimit t) :\n    Q.lift r ‚â´ (conePointUniqueUpToIso P Q).inv = P.lift r :=\n  P.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointUniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Q.lift r) (P.conePointUniqueUpToIso Q).inv) (P.lift r)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_conePointUniqueUpToIso_inv {r s t : Cone F} (P : IsLimit s) (Q : IsLimit t) :\n    Q.lift r ‚â´ (conePointUniqueUpToIso P Q).inv = P.lift r :=\n  P.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.ofIsoLimit_lift","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr t : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit r\ni : CategoryTheory.Iso r t\ns : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((P.ofIsoLimit i).lift s) (CategoryTheory.CategoryStruct.comp (P.lift s) i.hom.hom)","decl":"@[simp]\ntheorem ofIsoLimit_lift {r t : Cone F} (P : IsLimit r) (i : r ‚âÖ t) (s) :\n    (P.ofIsoLimit i).lift s = P.lift s ‚â´ i.hom.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.equivIsoLimit_apply","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr t : CategoryTheory.Limits.Cone F\ni : CategoryTheory.Iso r t\nP : CategoryTheory.Limits.IsLimit r\n‚ä¢ Eq ((CategoryTheory.Limits.IsLimit.equivIsoLimit i) P) (P.ofIsoLimit i)","decl":"@[simp]\ntheorem equivIsoLimit_apply {r t : Cone F} (i : r ‚âÖ t) (P : IsLimit r) :\n    equivIsoLimit i P = P.ofIsoLimit i :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.equivIsoLimit_symm_apply","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr t : CategoryTheory.Limits.Cone F\ni : CategoryTheory.Iso r t\nP : CategoryTheory.Limits.IsLimit t\n‚ä¢ Eq ((CategoryTheory.Limits.IsLimit.equivIsoLimit i).symm P) (P.ofIsoLimit i.symm)","decl":"@[simp]\ntheorem equivIsoLimit_symm_apply {r t : Cone F} (i : r ‚âÖ t) (P : IsLimit t) :\n    (equivIsoLimit i).symm P = P.ofIsoLimit i.symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.hom_lift","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nh : CategoryTheory.Limits.IsLimit t\nW : C\nm : Quiver.Hom W t.pt\n‚ä¢ Eq m (h.lift { pt := W, œÄ := { app := fun b => CategoryTheory.CategoryStruct.comp m (t.œÄ.app b), naturality := ‚ãØ } })","decl":"theorem hom_lift (h : IsLimit t) {W : C} (m : W ‚ü∂ t.pt) :\n    m = h.lift { pt := W, œÄ := { app := fun b => m ‚â´ t.œÄ.app b } } :=\n  h.uniq { pt := W, œÄ := { app := fun b => m ‚â´ t.œÄ.app b } } m fun _ => rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nh : CategoryTheory.Limits.IsLimit t\nW : C\nf f' : Quiver.Hom W t.pt\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp f (t.œÄ.app j)) (CategoryTheory.CategoryStruct.comp f' (t.œÄ.app j))\n‚ä¢ Eq f f'","decl":"/-- Two morphisms into a limit are equal if their compositions with\n  each cone morphism are equal. -/\ntheorem hom_ext (h : IsLimit t) {W : C} {f f' : W ‚ü∂ t.pt}\n    (w : ‚àÄ j, f ‚â´ t.œÄ.app j = f' ‚â´ t.œÄ.app j) :\n    f = f' := by\n  rw [h.hom_lift f, h.hom_lift f']; congr; exact funext w\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.ofConeEquiv_apply_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nG : CategoryTheory.Functor K D\nh : CategoryTheory.Equivalence (CategoryTheory.Limits.Cone G) (CategoryTheory.Limits.Cone F)\nc : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit (h.functor.obj c)\ns : CategoryTheory.Limits.Cone G\n‚ä¢ Eq (((CategoryTheory.Limits.IsLimit.ofConeEquiv h) P).lift s) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (h.unitIso.hom.app s).hom (h.inverse.map (P.liftConeMorphism (h.functor.obj s))).hom) (h.unitIso.inv.app c).hom)","decl":"@[simp]\ntheorem ofConeEquiv_apply_desc {D : Type u‚ÇÑ} [Category.{v‚ÇÑ} D] {G : K ‚•§ D} (h : Cone G ‚âå Cone F)\n    {c : Cone G} (P : IsLimit (h.functor.obj c)) (s) :\n    (ofConeEquiv h P).lift s =\n      ((h.unitIso.hom.app s).hom ‚â´ (h.inverse.map (P.liftConeMorphism (h.functor.obj s))).hom) ‚â´\n        (h.unitIso.inv.app c).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.ofConeEquiv_symm_apply_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nG : CategoryTheory.Functor K D\nh : CategoryTheory.Equivalence (CategoryTheory.Limits.Cone G) (CategoryTheory.Limits.Cone F)\nc : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (((CategoryTheory.Limits.IsLimit.ofConeEquiv h).symm P).lift s) (CategoryTheory.CategoryStruct.comp (h.counitIso.inv.app s).hom (h.functor.map (P.liftConeMorphism (h.inverse.obj s))).hom)","decl":"@[simp]\ntheorem ofConeEquiv_symm_apply_desc {D : Type u‚ÇÑ} [Category.{v‚ÇÑ} D] {G : K ‚•§ D}\n    (h : Cone G ‚âå Cone F) {c : Cone G} (P : IsLimit c) (s) :\n    ((ofConeEquiv h).symm P).lift s =\n      (h.counitIso.inv.app s).hom ‚â´ (h.functor.map (P.liftConeMorphism (h.inverse.obj s))).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\n‚ä¢ Eq (P.conePointsIsoOfNatIso Q w).hom (CategoryTheory.Limits.IsLimit.map s Q w.hom)","decl":"/-- The cone points of two limit cones for naturally isomorphic functors\nare themselves isomorphic.\n-/\n@[simps]\ndef conePointsIsoOfNatIso {F G : J ‚•§ C} {s : Cone F} {t : Cone G} (P : IsLimit s) (Q : IsLimit t)\n    (w : F ‚âÖ G) : s.pt ‚âÖ t.pt where\n  hom := Q.map s w.hom\n  inv := P.map t w.inv\n  hom_inv_id := P.hom_ext (by simp)\n  inv_hom_id := Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\n‚ä¢ Eq (P.conePointsIsoOfNatIso Q w).inv (CategoryTheory.Limits.IsLimit.map t P w.inv)","decl":"/-- The cone points of two limit cones for naturally isomorphic functors\nare themselves isomorphic.\n-/\n@[simps]\ndef conePointsIsoOfNatIso {F G : J ‚•§ C} {s : Cone F} {t : Cone G} (P : IsLimit s) (Q : IsLimit t)\n    (w : F ‚âÖ G) : s.pt ‚âÖ t.pt where\n  hom := Q.map s w.hom\n  inv := P.map t w.inv\n  hom_inv_id := P.hom_ext (by simp)\n  inv_hom_id := Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_hom_comp","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointsIsoOfNatIso Q w).hom (t.œÄ.app j)) (CategoryTheory.CategoryStruct.comp (s.œÄ.app j) (w.hom.app j))","decl":"@[reassoc]\ntheorem conePointsIsoOfNatIso_hom_comp {F G : J ‚•§ C} {s : Cone F} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (w : F ‚âÖ G) (j : J) :\n    (conePointsIsoOfNatIso P Q w).hom ‚â´ t.œÄ.app j = s.œÄ.app j ‚â´ w.hom.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_hom_comp_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom (G.obj j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointsIsoOfNatIso Q w).hom (CategoryTheory.CategoryStruct.comp (t.œÄ.app j) h)) (CategoryTheory.CategoryStruct.comp (s.œÄ.app j) (CategoryTheory.CategoryStruct.comp (w.hom.app j) h))","decl":"@[reassoc]\ntheorem conePointsIsoOfNatIso_hom_comp {F G : J ‚•§ C} {s : Cone F} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (w : F ‚âÖ G) (j : J) :\n    (conePointsIsoOfNatIso P Q w).hom ‚â´ t.œÄ.app j = s.œÄ.app j ‚â´ w.hom.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_inv_comp","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointsIsoOfNatIso Q w).inv (s.œÄ.app j)) (CategoryTheory.CategoryStruct.comp (t.œÄ.app j) (w.inv.app j))","decl":"@[reassoc]\ntheorem conePointsIsoOfNatIso_inv_comp {F G : J ‚•§ C} {s : Cone F} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (w : F ‚âÖ G) (j : J) :\n    (conePointsIsoOfNatIso P Q w).inv ‚â´ s.œÄ.app j = t.œÄ.app j ‚â´ w.inv.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_inv_comp_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom (F.obj j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.conePointsIsoOfNatIso Q w).inv (CategoryTheory.CategoryStruct.comp (s.œÄ.app j) h)) (CategoryTheory.CategoryStruct.comp (t.œÄ.app j) (CategoryTheory.CategoryStruct.comp (w.inv.app j) h))","decl":"@[reassoc]\ntheorem conePointsIsoOfNatIso_inv_comp {F G : J ‚•§ C} {s : Cone F} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (w : F ‚âÖ G) (j : J) :\n    (conePointsIsoOfNatIso P Q w).inv ‚â´ s.œÄ.app j = t.œÄ.app j ‚â´ w.inv.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointsIsoOfNatIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nr s : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.lift r) (P.conePointsIsoOfNatIso Q w).hom) (CategoryTheory.Limits.IsLimit.map r Q w.hom)","decl":"@[reassoc]\ntheorem lift_comp_conePointsIsoOfNatIso_hom {F G : J ‚•§ C} {r s : Cone F} {t : Cone G}\n    (P : IsLimit s) (Q : IsLimit t) (w : F ‚âÖ G) :\n    P.lift r ‚â´ (conePointsIsoOfNatIso P Q w).hom = Q.map r w.hom :=\n  Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointsIsoOfNatIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nr s : CategoryTheory.Limits.Cone F\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom t.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.lift r) (CategoryTheory.CategoryStruct.comp (P.conePointsIsoOfNatIso Q w).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.IsLimit.map r Q w.hom) h)","decl":"@[reassoc]\ntheorem lift_comp_conePointsIsoOfNatIso_hom {F G : J ‚•§ C} {r s : Cone F} {t : Cone G}\n    (P : IsLimit s) (Q : IsLimit t) (w : F ‚âÖ G) :\n    P.lift r ‚â´ (conePointsIsoOfNatIso P Q w).hom = Q.map r w.hom :=\n  Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointsIsoOfNatIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nr s : CategoryTheory.Limits.Cone G\nt : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit t\nQ : CategoryTheory.Limits.IsLimit s\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom t.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Q.lift r) (CategoryTheory.CategoryStruct.comp (P.conePointsIsoOfNatIso Q w).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.IsLimit.map r P w.inv) h)","decl":"@[reassoc]\ntheorem lift_comp_conePointsIsoOfNatIso_inv {F G : J ‚•§ C} {r s : Cone G} {t : Cone F}\n    (P : IsLimit t) (Q : IsLimit s) (w : F ‚âÖ G) :\n    Q.lift r ‚â´ (conePointsIsoOfNatIso P Q w).inv = P.map r w.inv :=\n  P.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.lift_comp_conePointsIsoOfNatIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nr s : CategoryTheory.Limits.Cone G\nt : CategoryTheory.Limits.Cone F\nP : CategoryTheory.Limits.IsLimit t\nQ : CategoryTheory.Limits.IsLimit s\nw : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Q.lift r) (P.conePointsIsoOfNatIso Q w).inv) (CategoryTheory.Limits.IsLimit.map r P w.inv)","decl":"@[reassoc]\ntheorem lift_comp_conePointsIsoOfNatIso_inv {F G : J ‚•§ C} {r s : Cone G} {t : Cone F}\n    (P : IsLimit t) (Q : IsLimit s) (w : F ‚âÖ G) :\n    Q.lift r ‚â´ (conePointsIsoOfNatIso P Q w).inv = P.map r w.inv :=\n  P.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfEquivalence_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nG : CategoryTheory.Functor K C\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\n‚ä¢ Eq (P.conePointsIsoOfEquivalence Q e w).inv (P.lift ((CategoryTheory.Limits.Cones.equivalenceOfReindexing e w).functor.obj t))","decl":"/-- We can prove two cone points `(s : Cone F).pt` and `(t : Cone G).pt` are isomorphic if\n* both cones are limit cones\n* their indexing categories are equivalent via some `e : J ‚âå K`,\n* the triangle of functors commutes up to a natural isomorphism: `e.functor ‚ãô G ‚âÖ F`.\n\nThis is the most general form of uniqueness of cone points,\nallowing relabelling of both the indexing category (up to equivalence)\nand the functor (up to natural isomorphism).\n-/\n@[simps]\ndef conePointsIsoOfEquivalence {F : J ‚•§ C} {s : Cone F} {G : K ‚•§ C} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (e : J ‚âå K) (w : e.functor ‚ãô G ‚âÖ F) : s.pt ‚âÖ t.pt :=\n  let w' : e.inverse ‚ãô F ‚âÖ G := (isoWhiskerLeft e.inverse w).symm ‚â™‚â´ invFunIdAssoc e G\n  { hom := Q.lift ((Cones.equivalenceOfReindexing e.symm w').functor.obj s)\n    inv := P.lift ((Cones.equivalenceOfReindexing e w).functor.obj t)\n    hom_inv_id := by\n      apply hom_ext P; intro j\n      dsimp [w']\n      simp only [Limits.Cone.whisker_œÄ, Limits.Cones.postcompose_obj_œÄ, fac, whiskerLeft_app,\n        assoc, id_comp, invFunIdAssoc_hom_app, fac_assoc, NatTrans.comp_app]\n      rw [counit_app_functor, ‚Üê Functor.comp_map]\n      have l :\n        NatTrans.app w.hom j = NatTrans.app w.hom (Prefunctor.obj (ùü≠ J).toPrefunctor j) := by dsimp\n      rw [l,w.hom.naturality]\n      simp\n    inv_hom_id := by\n      apply hom_ext Q\n      aesop_cat }\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.conePointsIsoOfEquivalence_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cone F\nG : CategoryTheory.Functor K C\nt : CategoryTheory.Limits.Cone G\nP : CategoryTheory.Limits.IsLimit s\nQ : CategoryTheory.Limits.IsLimit t\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\n‚ä¢ Eq (P.conePointsIsoOfEquivalence Q e w).hom (Q.lift ((CategoryTheory.Limits.Cones.equivalenceOfReindexing e.symm ((CategoryTheory.isoWhiskerLeft e.inverse w).symm.trans (e.invFunIdAssoc G))).functor.obj s))","decl":"/-- We can prove two cone points `(s : Cone F).pt` and `(t : Cone G).pt` are isomorphic if\n* both cones are limit cones\n* their indexing categories are equivalent via some `e : J ‚âå K`,\n* the triangle of functors commutes up to a natural isomorphism: `e.functor ‚ãô G ‚âÖ F`.\n\nThis is the most general form of uniqueness of cone points,\nallowing relabelling of both the indexing category (up to equivalence)\nand the functor (up to natural isomorphism).\n-/\n@[simps]\ndef conePointsIsoOfEquivalence {F : J ‚•§ C} {s : Cone F} {G : K ‚•§ C} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (e : J ‚âå K) (w : e.functor ‚ãô G ‚âÖ F) : s.pt ‚âÖ t.pt :=\n  let w' : e.inverse ‚ãô F ‚âÖ G := (isoWhiskerLeft e.inverse w).symm ‚â™‚â´ invFunIdAssoc e G\n  { hom := Q.lift ((Cones.equivalenceOfReindexing e.symm w').functor.obj s)\n    inv := P.lift ((Cones.equivalenceOfReindexing e w).functor.obj t)\n    hom_inv_id := by\n      apply hom_ext P; intro j\n      dsimp [w']\n      simp only [Limits.Cone.whisker_œÄ, Limits.Cones.postcompose_obj_œÄ, fac, whiskerLeft_app,\n        assoc, id_comp, invFunIdAssoc_hom_app, fac_assoc, NatTrans.comp_app]\n      rw [counit_app_functor, ‚Üê Functor.comp_map]\n      have l :\n        NatTrans.app w.hom j = NatTrans.app w.hom (Prefunctor.obj (ùü≠ J).toPrefunctor j) := by dsimp\n      rw [l,w.hom.naturality]\n      simp\n    inv_hom_id := by\n      apply hom_ext Q\n      aesop_cat }\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.homIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cone F\nh : CategoryTheory.Limits.IsLimit t\nW : C\nf : ULift.{u‚ÇÅ, v‚ÇÉ} (Quiver.Hom W t.pt)\n‚ä¢ Eq ((h.homIso W).hom f) (t.extend f.down).œÄ","decl":"@[simp]\ntheorem homIso_hom (h : IsLimit t) {W : C} (f : ULift.{u‚ÇÅ} (W ‚ü∂ t.pt)) :\n    (IsLimit.homIso h W).hom f = (t.extend f.down).œÄ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom_homOfCone","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.yoneda.obj X).comp CategoryTheory.uliftFunctor.{u‚ÇÅ, v‚ÇÉ}) F.cones\ns : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom h (CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone h s)) s","decl":"@[simp]\ntheorem coneOfHom_homOfCone (s : Cone F) : coneOfHom h (homOfCone h s) = s := by\n  dsimp [coneOfHom, homOfCone]\n  match s with\n  | .mk s_pt s_œÄ =>\n    congr; dsimp\n    convert congrFun (congrFun (congrArg NatTrans.app h.inv_hom_id) (op s_pt)) s_œÄ using 1\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone_coneOfHom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.yoneda.obj X).comp CategoryTheory.uliftFunctor.{u‚ÇÅ, v‚ÇÉ}) F.cones\nY : C\nf : Quiver.Hom Y X\n‚ä¢ Eq (CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone h (CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom h f)) f","decl":"@[simp]\ntheorem homOfCone_coneOfHom {Y : C} (f : Y ‚ü∂ X) : homOfCone h (coneOfHom h f) = f :=\n  congrArg ULift.down (congrFun (congrFun (congrArg NatTrans.app h.hom_inv_id) (op Y)) ‚ü®f‚ü© :)\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom_fac","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.yoneda.obj X).comp CategoryTheory.uliftFunctor.{u‚ÇÅ, v‚ÇÉ}) F.cones\nY : C\nf : Quiver.Hom Y X\n‚ä¢ Eq (CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom h f) ((CategoryTheory.Limits.IsLimit.OfNatIso.limitCone h).extend f)","decl":"/-- If `F.cones` is represented by `X`, the cone corresponding to a morphism `f : Y ‚ü∂ X` is\nthe limit cone extended by `f`. -/\ntheorem coneOfHom_fac {Y : C} (f : Y ‚ü∂ X) : coneOfHom h f = (limitCone h).extend f := by\n  dsimp [coneOfHom, limitCone, Cone.extend]\n  congr with j\n  have t := congrFun (h.hom.naturality f.op) ‚ü®ùüô X‚ü©\n  dsimp at t\n  simp only [comp_id] at t\n  rw [congrFun (congrArg NatTrans.app t) j]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.OfNatIso.cone_fac","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.yoneda.obj X).comp CategoryTheory.uliftFunctor.{u‚ÇÅ, v‚ÇÉ}) F.cones\ns : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Limits.IsLimit.OfNatIso.limitCone h).extend (CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone h s)) s","decl":"/-- If `F.cones` is represented by `X`, any cone is the extension of the limit cone by the\ncorresponding morphism. -/\ntheorem cone_fac (s : Cone F) : (limitCone h).extend (homOfCone h s) = s := by\n  rw [‚Üê coneOfHom_homOfCone h s]\n  conv_lhs => simp only [homOfCone_coneOfHom]\n  apply (coneOfHom_fac _ _).symm\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.uniq","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nself : CategoryTheory.Limits.IsColimit t\ns : CategoryTheory.Limits.Cocone F\nm : Quiver.Hom t.pt s.pt\nx‚úù : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) m) (s.Œπ.app j)\n‚ä¢ Eq m (self.desc s)","decl":"/-- A cocone `t` on `F` is a colimit cocone if each cocone on `F` admits a unique\ncocone morphism from `t`. -/\n@[stacks 002F]\nstructure IsColimit (t : Cocone F) where\n  /-- `t.pt` maps to all other cocone covertices -/\n  desc : ‚àÄ s : Cocone F, t.pt ‚ü∂ s.pt\n  /-- The map `desc` makes the diagram with the natural transformations commute -/\n  fac : ‚àÄ (s : Cocone F) (j : J), t.Œπ.app j ‚â´ desc s = s.Œπ.app j := by aesop_cat\n  /-- `desc` is the unique such map -/\n  uniq :\n    ‚àÄ (s : Cocone F) (m : t.pt ‚ü∂ s.pt) (_ : ‚àÄ j : J, t.Œπ.app j ‚â´ m = s.Œπ.app j), m = desc s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.mk.injEq","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\ndesc‚úù : (s : CategoryTheory.Limits.Cocone F) ‚Üí Quiver.Hom t.pt s.pt\nfac‚úù : autoParam (‚àÄ (s : CategoryTheory.Limits.Cocone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) (desc‚úù s)) (s.Œπ.app j)) _auto‚úù\nuniq‚úù : autoParam (‚àÄ (s : CategoryTheory.Limits.Cocone F) (m : Quiver.Hom t.pt s.pt), (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) m) (s.Œπ.app j)) ‚Üí Eq m (desc‚úù s)) _auto‚úù\ndesc : (s : CategoryTheory.Limits.Cocone F) ‚Üí Quiver.Hom t.pt s.pt\nfac : autoParam (‚àÄ (s : CategoryTheory.Limits.Cocone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) (desc s)) (s.Œπ.app j)) _auto‚úù\nuniq : autoParam (‚àÄ (s : CategoryTheory.Limits.Cocone F) (m : Quiver.Hom t.pt s.pt), (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) m) (s.Œπ.app j)) ‚Üí Eq m (desc s)) _auto‚úù\n‚ä¢ Eq (Eq { desc := desc‚úù, fac := fac‚úù, uniq := uniq‚úù } { desc := desc, fac := fac, uniq := uniq }) (Eq desc‚úù desc)","decl":"/-- A cocone `t` on `F` is a colimit cocone if each cocone on `F` admits a unique\ncocone morphism from `t`. -/\n@[stacks 002F]\nstructure IsColimit (t : Cocone F) where\n  /-- `t.pt` maps to all other cocone covertices -/\n  desc : ‚àÄ s : Cocone F, t.pt ‚ü∂ s.pt\n  /-- The map `desc` makes the diagram with the natural transformations commute -/\n  fac : ‚àÄ (s : Cocone F) (j : J), t.Œπ.app j ‚â´ desc s = s.Œπ.app j := by aesop_cat\n  /-- `desc` is the unique such map -/\n  uniq :\n    ‚àÄ (s : Cocone F) (m : t.pt ‚ü∂ s.pt) (_ : ‚àÄ j : J, t.Œπ.app j ‚â´ m = s.Œπ.app j), m = desc s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.mk.inj","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\ndesc‚úù : (s : CategoryTheory.Limits.Cocone F) ‚Üí Quiver.Hom t.pt s.pt\nfac‚úù : autoParam (‚àÄ (s : CategoryTheory.Limits.Cocone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) (desc‚úù s)) (s.Œπ.app j)) _auto‚úù\nuniq‚úù : autoParam (‚àÄ (s : CategoryTheory.Limits.Cocone F) (m : Quiver.Hom t.pt s.pt), (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) m) (s.Œπ.app j)) ‚Üí Eq m (desc‚úù s)) _auto‚úù\ndesc : (s : CategoryTheory.Limits.Cocone F) ‚Üí Quiver.Hom t.pt s.pt\nfac : autoParam (‚àÄ (s : CategoryTheory.Limits.Cocone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) (desc s)) (s.Œπ.app j)) _auto‚úù\nuniq : autoParam (‚àÄ (s : CategoryTheory.Limits.Cocone F) (m : Quiver.Hom t.pt s.pt), (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) m) (s.Œπ.app j)) ‚Üí Eq m (desc s)) _auto‚úù\nx‚úù : Eq { desc := desc‚úù, fac := fac‚úù, uniq := uniq‚úù } { desc := desc, fac := fac, uniq := uniq }\n‚ä¢ Eq desc‚úù desc","decl":"/-- A cocone `t` on `F` is a colimit cocone if each cocone on `F` admits a unique\ncocone morphism from `t`. -/\n@[stacks 002F]\nstructure IsColimit (t : Cocone F) where\n  /-- `t.pt` maps to all other cocone covertices -/\n  desc : ‚àÄ s : Cocone F, t.pt ‚ü∂ s.pt\n  /-- The map `desc` makes the diagram with the natural transformations commute -/\n  fac : ‚àÄ (s : Cocone F) (j : J), t.Œπ.app j ‚â´ desc s = s.Œπ.app j := by aesop_cat\n  /-- `desc` is the unique such map -/\n  uniq :\n    ‚àÄ (s : Cocone F) (m : t.pt ‚ü∂ s.pt) (_ : ‚àÄ j : J, t.Œπ.app j ‚â´ m = s.Œπ.app j), m = desc s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\ninst‚úù¬π : SizeOf J\ninst‚úù : SizeOf C\ndesc : (s : CategoryTheory.Limits.Cocone F) ‚Üí Quiver.Hom t.pt s.pt\nfac : autoParam (‚àÄ (s : CategoryTheory.Limits.Cocone F) (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) (desc s)) (s.Œπ.app j)) _auto‚úù\nuniq : autoParam (‚àÄ (s : CategoryTheory.Limits.Cocone F) (m : Quiver.Hom t.pt s.pt), (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) m) (s.Œπ.app j)) ‚Üí Eq m (desc s)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { desc := desc, fac := fac, uniq := uniq }) 1","decl":"/-- A cocone `t` on `F` is a colimit cocone if each cocone on `F` admits a unique\ncocone morphism from `t`. -/\n@[stacks 002F]\nstructure IsColimit (t : Cocone F) where\n  /-- `t.pt` maps to all other cocone covertices -/\n  desc : ‚àÄ s : Cocone F, t.pt ‚ü∂ s.pt\n  /-- The map `desc` makes the diagram with the natural transformations commute -/\n  fac : ‚àÄ (s : Cocone F) (j : J), t.Œπ.app j ‚â´ desc s = s.Œπ.app j := by aesop_cat\n  /-- `desc` is the unique such map -/\n  uniq :\n    ‚àÄ (s : Cocone F) (m : t.pt ‚ü∂ s.pt) (_ : ‚àÄ j : J, t.Œπ.app j ‚â´ m = s.Œπ.app j), m = desc s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.fac","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nself : CategoryTheory.Limits.IsColimit t\ns : CategoryTheory.Limits.Cocone F\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) (self.desc s)) (s.Œπ.app j)","decl":"/-- A cocone `t` on `F` is a colimit cocone if each cocone on `F` admits a unique\ncocone morphism from `t`. -/\n@[stacks 002F]\nstructure IsColimit (t : Cocone F) where\n  /-- `t.pt` maps to all other cocone covertices -/\n  desc : ‚àÄ s : Cocone F, t.pt ‚ü∂ s.pt\n  /-- The map `desc` makes the diagram with the natural transformations commute -/\n  fac : ‚àÄ (s : Cocone F) (j : J), t.Œπ.app j ‚â´ desc s = s.Œπ.app j := by aesop_cat\n  /-- `desc` is the unique such map -/\n  uniq :\n    ‚àÄ (s : Cocone F) (m : t.pt ‚ü∂ s.pt) (_ : ‚àÄ j : J, t.Œπ.app j ‚â´ m = s.Œπ.app j), m = desc s := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.fac_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nself : CategoryTheory.Limits.IsColimit t\ns : CategoryTheory.Limits.Cocone F\nj : J\nZ : C\nh : Quiver.Hom s.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) (CategoryTheory.CategoryStruct.comp (self.desc s) h)) (CategoryTheory.CategoryStruct.comp (s.Œπ.app j) h)","decl":"attribute [reassoc (attr := simp)] IsColimit.fac\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.subsingleton","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\n‚ä¢ Subsingleton (CategoryTheory.Limits.IsColimit t)","decl":"instance subsingleton {t : Cocone F} : Subsingleton (IsColimit t) :=\n  ‚ü®by intro P Q; cases P; cases Q; congr; aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.Œπ_map_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nd : CategoryTheory.Limits.Cocone G\nŒ± : Quiver.Hom F G\nj : J\nZ : C\nh : Quiver.Hom d.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (c.Œπ.app j) (CategoryTheory.CategoryStruct.comp (hc.map d Œ±) h)) (CategoryTheory.CategoryStruct.comp (Œ±.app j) (CategoryTheory.CategoryStruct.comp (d.Œπ.app j) h))","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_map {F G : J ‚•§ C} {c : Cocone F} (hc : IsColimit c) (d : Cocone G) (Œ± : F ‚ü∂ G) (j : J) :\n    c.Œπ.app j ‚â´ IsColimit.map hc d Œ± = Œ±.app j ‚â´ d.Œπ.app j :=\n  fac _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.Œπ_map","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nd : CategoryTheory.Limits.Cocone G\nŒ± : Quiver.Hom F G\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (c.Œπ.app j) (hc.map d Œ±)) (CategoryTheory.CategoryStruct.comp (Œ±.app j) (d.Œπ.app j))","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_map {F G : J ‚•§ C} {c : Cocone F} (hc : IsColimit c) (d : Cocone G) (Œ± : F ‚ü∂ G) (j : J) :\n    c.Œπ.app j ‚â´ IsColimit.map hc d Œ± = Œ±.app j ‚â´ d.Œπ.app j :=\n  fac _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.desc_self","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\n‚ä¢ Eq (h.desc t) (CategoryTheory.CategoryStruct.id t.pt)","decl":"@[simp]\ntheorem desc_self {t : Cocone F} (h : IsColimit t) : h.desc t = ùüô t.pt :=\n  (h.uniq _ _ fun _ => comp_id _).symm\n\n-- Repackaging the definition in terms of cocone morphisms.\n"}
{"name":"CategoryTheory.Limits.IsColimit.descCoconeMorphism_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\ns : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (h.descCoconeMorphism s).hom (h.desc s)","decl":"/-- The universal morphism from a colimit cocone to any other cocone. -/\n@[simps]\ndef descCoconeMorphism {t : Cocone F} (h : IsColimit t) (s : Cocone F) : t ‚ü∂ s where hom := h.desc s\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.uniq_cocone_morphism","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nf f' : Quiver.Hom t s\n‚ä¢ Eq f f'","decl":"theorem uniq_cocone_morphism {s t : Cocone F} (h : IsColimit t) {f f' : t ‚ü∂ s} : f = f' :=\n  have : ‚àÄ {g : t ‚ü∂ s}, g = h.descCoconeMorphism s := by\n    intro g; ext; exact h.uniq _ _ g.w\n  this.trans this.symm\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.existsUnique","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\ns : CategoryTheory.Limits.Cocone F\n‚ä¢ ExistsUnique fun d => ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) d) (s.Œπ.app j)","decl":"/-- Restating the definition of a colimit cocone in terms of the ‚àÉ! operator. -/\ntheorem existsUnique {t : Cocone F} (h : IsColimit t) (s : Cocone F) :\n    ‚àÉ! d : t.pt ‚ü∂ s.pt, ‚àÄ j, t.Œπ.app j ‚â´ d = s.Œπ.app j :=\n  ‚ü®h.desc s, h.fac s, h.uniq s‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.mkCoconeMorphism_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\ndesc : (s : CategoryTheory.Limits.Cocone F) ‚Üí Quiver.Hom t s\nuniq' : ‚àÄ (s : CategoryTheory.Limits.Cocone F) (m : Quiver.Hom t s), Eq m (desc s)\ns : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((CategoryTheory.Limits.IsColimit.mkCoconeMorphism desc uniq').desc s) (desc s).hom","decl":"/-- Alternative constructor for `IsColimit`,\nproviding a morphism of cocones rather than a morphism between the cocone points\nand separately the factorisation condition.\n-/\n@[simps]\ndef mkCoconeMorphism {t : Cocone F} (desc : ‚àÄ s : Cocone F, t ‚ü∂ s)\n    (uniq' : ‚àÄ (s : Cocone F) (m : t ‚ü∂ s), m = desc s) : IsColimit t where\n  desc s := (desc s).hom\n  uniq s m w :=\n    have : CoconeMorphism.mk m w = desc s := by apply uniq'\n    congrArg CoconeMorphism.hom this\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.uniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\n‚ä¢ Eq (P.uniqueUpToIso Q).hom (P.descCoconeMorphism t)","decl":"/-- Colimit cocones on `F` are unique up to isomorphism. -/\n@[simps]\ndef uniqueUpToIso {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) : s ‚âÖ t where\n  hom := P.descCoconeMorphism t\n  inv := Q.descCoconeMorphism s\n  hom_inv_id := P.uniq_cocone_morphism\n  inv_hom_id := Q.uniq_cocone_morphism\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.uniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\n‚ä¢ Eq (P.uniqueUpToIso Q).inv (Q.descCoconeMorphism s)","decl":"/-- Colimit cocones on `F` are unique up to isomorphism. -/\n@[simps]\ndef uniqueUpToIso {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) : s ‚âÖ t where\n  hom := P.descCoconeMorphism t\n  inv := Q.descCoconeMorphism s\n  hom_inv_id := P.uniq_cocone_morphism\n  inv_hom_id := Q.uniq_cocone_morphism\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.hom_isIso","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nf : Quiver.Hom s t\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Any cocone morphism between colimit cocones is an isomorphism. -/\ntheorem hom_isIso {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) (f : s ‚ü∂ t) : IsIso f :=\n  ‚ü®‚ü®Q.descCoconeMorphism s, ‚ü®P.uniq_cocone_morphism, Q.uniq_cocone_morphism‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointUniqueUpToIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (s.Œπ.app j) (P.coconePointUniqueUpToIso Q).hom) (t.Œπ.app j)","decl":"@[reassoc (attr := simp)]\ntheorem comp_coconePointUniqueUpToIso_hom {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t)\n    (j : J) : s.Œπ.app j ‚â´ (coconePointUniqueUpToIso P Q).hom = t.Œπ.app j :=\n  (uniqueUpToIso P Q).hom.w _\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointUniqueUpToIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nj : J\nZ : C\nh : Quiver.Hom t.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (s.Œπ.app j) (CategoryTheory.CategoryStruct.comp (P.coconePointUniqueUpToIso Q).hom h)) (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem comp_coconePointUniqueUpToIso_hom {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t)\n    (j : J) : s.Œπ.app j ‚â´ (coconePointUniqueUpToIso P Q).hom = t.Œπ.app j :=\n  (uniqueUpToIso P Q).hom.w _\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointUniqueUpToIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) (P.coconePointUniqueUpToIso Q).inv) (s.Œπ.app j)","decl":"@[reassoc (attr := simp)]\ntheorem comp_coconePointUniqueUpToIso_inv {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t)\n    (j : J) : t.Œπ.app j ‚â´ (coconePointUniqueUpToIso P Q).inv = s.Œπ.app j :=\n  (uniqueUpToIso P Q).inv.w _\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointUniqueUpToIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nj : J\nZ : C\nh : Quiver.Hom s.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) (CategoryTheory.CategoryStruct.comp (P.coconePointUniqueUpToIso Q).inv h)) (CategoryTheory.CategoryStruct.comp (s.Œπ.app j) h)","decl":"@[reassoc (attr := simp)]\ntheorem comp_coconePointUniqueUpToIso_inv {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t)\n    (j : J) : t.Œπ.app j ‚â´ (coconePointUniqueUpToIso P Q).inv = s.Œπ.app j :=\n  (uniqueUpToIso P Q).inv.w _\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso_hom_desc_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nZ : C\nh : Quiver.Hom r.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointUniqueUpToIso Q).hom (CategoryTheory.CategoryStruct.comp (Q.desc r) h)) (CategoryTheory.CategoryStruct.comp (P.desc r) h)","decl":"@[reassoc (attr := simp)]\ntheorem coconePointUniqueUpToIso_hom_desc {r s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) :\n    (coconePointUniqueUpToIso P Q).hom ‚â´ Q.desc r = P.desc r :=\n  P.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso_hom_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointUniqueUpToIso Q).hom (Q.desc r)) (P.desc r)","decl":"@[reassoc (attr := simp)]\ntheorem coconePointUniqueUpToIso_hom_desc {r s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) :\n    (coconePointUniqueUpToIso P Q).hom ‚â´ Q.desc r = P.desc r :=\n  P.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso_inv_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointUniqueUpToIso Q).inv (P.desc r)) (Q.desc r)","decl":"@[reassoc (attr := simp)]\ntheorem coconePointUniqueUpToIso_inv_desc {r s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) :\n    (coconePointUniqueUpToIso P Q).inv ‚â´ P.desc r = Q.desc r :=\n  Q.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso_inv_desc_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr s t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nZ : C\nh : Quiver.Hom r.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointUniqueUpToIso Q).inv (CategoryTheory.CategoryStruct.comp (P.desc r) h)) (CategoryTheory.CategoryStruct.comp (Q.desc r) h)","decl":"@[reassoc (attr := simp)]\ntheorem coconePointUniqueUpToIso_inv_desc {r s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) :\n    (coconePointUniqueUpToIso P Q).inv ‚â´ P.desc r = Q.desc r :=\n  Q.uniq _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.ofIsoColimit_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit r\ni : CategoryTheory.Iso r t\ns : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((P.ofIsoColimit i).desc s) (CategoryTheory.CategoryStruct.comp i.inv.hom (P.desc s))","decl":"@[simp]\ntheorem ofIsoColimit_desc {r t : Cocone F} (P : IsColimit r) (i : r ‚âÖ t) (s) :\n    (P.ofIsoColimit i).desc s = i.inv.hom ‚â´ P.desc s :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.equivIsoColimit_apply","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr t : CategoryTheory.Limits.Cocone F\ni : CategoryTheory.Iso r t\nP : CategoryTheory.Limits.IsColimit r\n‚ä¢ Eq ((CategoryTheory.Limits.IsColimit.equivIsoColimit i) P) (P.ofIsoColimit i)","decl":"@[simp]\ntheorem equivIsoColimit_apply {r t : Cocone F} (i : r ‚âÖ t) (P : IsColimit r) :\n    equivIsoColimit i P = P.ofIsoColimit i :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.equivIsoColimit_symm_apply","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nr t : CategoryTheory.Limits.Cocone F\ni : CategoryTheory.Iso r t\nP : CategoryTheory.Limits.IsColimit t\n‚ä¢ Eq ((CategoryTheory.Limits.IsColimit.equivIsoColimit i).symm P) (P.ofIsoColimit i.symm)","decl":"@[simp]\ntheorem equivIsoColimit_symm_apply {r t : Cocone F} (i : r ‚âÖ t) (P : IsColimit t) :\n    (equivIsoColimit i).symm P = P.ofIsoColimit i.symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.hom_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nW : C\nm : Quiver.Hom t.pt W\n‚ä¢ Eq m (h.desc { pt := W, Œπ := { app := fun b => CategoryTheory.CategoryStruct.comp (t.Œπ.app b) m, naturality := ‚ãØ } })","decl":"theorem hom_desc (h : IsColimit t) {W : C} (m : t.pt ‚ü∂ W) :\n    m =\n      h.desc\n        { pt := W\n          Œπ := { app := fun b => t.Œπ.app b ‚â´ m } } :=\n  h.uniq\n    { pt := W\n      Œπ := { app := fun b => t.Œπ.app b ‚â´ m } }\n    m fun _ => rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nW : C\nf f' : Quiver.Hom t.pt W\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) f) (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) f')\n‚ä¢ Eq f f'","decl":"/-- Two morphisms out of a colimit are equal if their compositions with\n  each cocone morphism are equal. -/\ntheorem hom_ext (h : IsColimit t) {W : C} {f f' : t.pt ‚ü∂ W}\n    (w : ‚àÄ j, t.Œπ.app j ‚â´ f = t.Œπ.app j ‚â´ f') : f = f' := by\n  rw [h.hom_desc f, h.hom_desc f']; congr; exact funext w\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.ofCoconeEquiv_apply_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nG : CategoryTheory.Functor K D\nh : CategoryTheory.Equivalence (CategoryTheory.Limits.Cocone G) (CategoryTheory.Limits.Cocone F)\nc : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit (h.functor.obj c)\ns : CategoryTheory.Limits.Cocone G\n‚ä¢ Eq (((CategoryTheory.Limits.IsColimit.ofCoconeEquiv h) P).desc s) (CategoryTheory.CategoryStruct.comp (h.unit.app c).hom (CategoryTheory.CategoryStruct.comp (h.inverse.map (P.descCoconeMorphism (h.functor.obj s))).hom (h.unitInv.app s).hom))","decl":"@[simp]\ntheorem ofCoconeEquiv_apply_desc {D : Type u‚ÇÑ} [Category.{v‚ÇÑ} D] {G : K ‚•§ D}\n    (h : Cocone G ‚âå Cocone F) {c : Cocone G} (P : IsColimit (h.functor.obj c)) (s) :\n    (ofCoconeEquiv h P).desc s =\n      (h.unit.app c).hom ‚â´\n        (h.inverse.map (P.descCoconeMorphism (h.functor.obj s))).hom ‚â´ (h.unitInv.app s).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.ofCoconeEquiv_symm_apply_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nG : CategoryTheory.Functor K D\nh : CategoryTheory.Equivalence (CategoryTheory.Limits.Cocone G) (CategoryTheory.Limits.Cocone F)\nc : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit c\ns : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (((CategoryTheory.Limits.IsColimit.ofCoconeEquiv h).symm P).desc s) (CategoryTheory.CategoryStruct.comp (h.functor.map (P.descCoconeMorphism (h.inverse.obj s))).hom (h.counit.app s).hom)","decl":"@[simp]\ntheorem ofCoconeEquiv_symm_apply_desc {D : Type u‚ÇÑ} [Category.{v‚ÇÑ} D] {G : K ‚•§ D}\n    (h : Cocone G ‚âå Cocone F) {c : Cocone G} (P : IsColimit c) (s) :\n    ((ofCoconeEquiv h).symm P).desc s =\n      (h.functor.map (P.descCoconeMorphism (h.inverse.obj s))).hom ‚â´ (h.counit.app s).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\n‚ä¢ Eq (P.coconePointsIsoOfNatIso Q w).hom (P.map t w.hom)","decl":"/-- The cocone points of two colimit cocones for naturally isomorphic functors\nare themselves isomorphic.\n-/\n@[simps]\ndef coconePointsIsoOfNatIso {F G : J ‚•§ C} {s : Cocone F} {t : Cocone G} (P : IsColimit s)\n    (Q : IsColimit t) (w : F ‚âÖ G) : s.pt ‚âÖ t.pt where\n  hom := P.map t w.hom\n  inv := Q.map s w.inv\n  hom_inv_id := P.hom_ext (by simp)\n  inv_hom_id := Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\n‚ä¢ Eq (P.coconePointsIsoOfNatIso Q w).inv (Q.map s w.inv)","decl":"/-- The cocone points of two colimit cocones for naturally isomorphic functors\nare themselves isomorphic.\n-/\n@[simps]\ndef coconePointsIsoOfNatIso {F G : J ‚•§ C} {s : Cocone F} {t : Cocone G} (P : IsColimit s)\n    (Q : IsColimit t) (w : F ‚âÖ G) : s.pt ‚âÖ t.pt where\n  hom := P.map t w.hom\n  inv := Q.map s w.inv\n  hom_inv_id := P.hom_ext (by simp)\n  inv_hom_id := Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointsIsoOfNatIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom t.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (s.Œπ.app j) (CategoryTheory.CategoryStruct.comp (P.coconePointsIsoOfNatIso Q w).hom h)) (CategoryTheory.CategoryStruct.comp (w.hom.app j) (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) h))","decl":"@[reassoc]\ntheorem comp_coconePointsIsoOfNatIso_hom {F G : J ‚•§ C} {s : Cocone F} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F ‚âÖ G) (j : J) :\n    s.Œπ.app j ‚â´ (coconePointsIsoOfNatIso P Q w).hom = w.hom.app j ‚â´ t.Œπ.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointsIsoOfNatIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (s.Œπ.app j) (P.coconePointsIsoOfNatIso Q w).hom) (CategoryTheory.CategoryStruct.comp (w.hom.app j) (t.Œπ.app j))","decl":"@[reassoc]\ntheorem comp_coconePointsIsoOfNatIso_hom {F G : J ‚•§ C} {s : Cocone F} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F ‚âÖ G) (j : J) :\n    s.Œπ.app j ‚â´ (coconePointsIsoOfNatIso P Q w).hom = w.hom.app j ‚â´ t.Œπ.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointsIsoOfNatIso_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) (P.coconePointsIsoOfNatIso Q w).inv) (CategoryTheory.CategoryStruct.comp (w.inv.app j) (s.Œπ.app j))","decl":"@[reassoc]\ntheorem comp_coconePointsIsoOfNatIso_inv {F G : J ‚•§ C} {s : Cocone F} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F ‚âÖ G) (j : J) :\n    t.Œπ.app j ‚â´ (coconePointsIsoOfNatIso P Q w).inv = w.inv.app j ‚â´ s.Œπ.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.comp_coconePointsIsoOfNatIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\nj : J\nZ : C\nh : Quiver.Hom s.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (t.Œπ.app j) (CategoryTheory.CategoryStruct.comp (P.coconePointsIsoOfNatIso Q w).inv h)) (CategoryTheory.CategoryStruct.comp (w.inv.app j) (CategoryTheory.CategoryStruct.comp (s.Œπ.app j) h))","decl":"@[reassoc]\ntheorem comp_coconePointsIsoOfNatIso_inv {F G : J ‚•§ C} {s : Cocone F} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F ‚âÖ G) (j : J) :\n    t.Œπ.app j ‚â´ (coconePointsIsoOfNatIso P Q w).inv = w.inv.app j ‚â´ s.Œπ.app j := by simp\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_hom_desc_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nr t : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom r.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointsIsoOfNatIso Q w).hom (CategoryTheory.CategoryStruct.comp (Q.desc r) h)) (CategoryTheory.CategoryStruct.comp (P.map r w.hom) h)","decl":"@[reassoc]\ntheorem coconePointsIsoOfNatIso_hom_desc {F G : J ‚•§ C} {s : Cocone F} {r t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F ‚âÖ G) :\n    (coconePointsIsoOfNatIso P Q w).hom ‚â´ Q.desc r = P.map _ w.hom :=\n  P.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_hom_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nr t : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\nw : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointsIsoOfNatIso Q w).hom (Q.desc r)) (P.map r w.hom)","decl":"@[reassoc]\ntheorem coconePointsIsoOfNatIso_hom_desc {F G : J ‚•§ C} {s : Cocone F} {r t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F ‚âÖ G) :\n    (coconePointsIsoOfNatIso P Q w).hom ‚â´ Q.desc r = P.map _ w.hom :=\n  P.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_inv_desc_assoc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone G\nr t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit t\nQ : CategoryTheory.Limits.IsColimit s\nw : CategoryTheory.Iso F G\nZ : C\nh : Quiver.Hom r.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointsIsoOfNatIso Q w).inv (CategoryTheory.CategoryStruct.comp (P.desc r) h)) (CategoryTheory.CategoryStruct.comp (Q.map r w.inv) h)","decl":"@[reassoc]\ntheorem coconePointsIsoOfNatIso_inv_desc {F G : J ‚•§ C} {s : Cocone G} {r t : Cocone F}\n    (P : IsColimit t) (Q : IsColimit s) (w : F ‚âÖ G) :\n    (coconePointsIsoOfNatIso P Q w).inv ‚â´ P.desc r = Q.map _ w.inv :=\n  Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_inv_desc","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF G : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone G\nr t : CategoryTheory.Limits.Cocone F\nP : CategoryTheory.Limits.IsColimit t\nQ : CategoryTheory.Limits.IsColimit s\nw : CategoryTheory.Iso F G\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.coconePointsIsoOfNatIso Q w).inv (P.desc r)) (Q.map r w.inv)","decl":"@[reassoc]\ntheorem coconePointsIsoOfNatIso_inv_desc {F G : J ‚•§ C} {s : Cocone G} {r t : Cocone F}\n    (P : IsColimit t) (Q : IsColimit s) (w : F ‚âÖ G) :\n    (coconePointsIsoOfNatIso P Q w).inv ‚â´ P.desc r = Q.map _ w.inv :=\n  Q.hom_ext (by simp)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfEquivalence_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nG : CategoryTheory.Functor K C\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\n‚ä¢ Eq (P.coconePointsIsoOfEquivalence Q e w).hom (P.desc ((CategoryTheory.Limits.Cocones.equivalenceOfReindexing e w).functor.obj t))","decl":"/-- We can prove two cocone points `(s : Cocone F).pt` and `(t : Cocone G).pt` are isomorphic if\n* both cocones are colimit cocones\n* their indexing categories are equivalent via some `e : J ‚âå K`,\n* the triangle of functors commutes up to a natural isomorphism: `e.functor ‚ãô G ‚âÖ F`.\n\nThis is the most general form of uniqueness of cocone points,\nallowing relabelling of both the indexing category (up to equivalence)\nand the functor (up to natural isomorphism).\n-/\n@[simps]\ndef coconePointsIsoOfEquivalence {F : J ‚•§ C} {s : Cocone F} {G : K ‚•§ C} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (e : J ‚âå K) (w : e.functor ‚ãô G ‚âÖ F) : s.pt ‚âÖ t.pt :=\n  let w' : e.inverse ‚ãô F ‚âÖ G := (isoWhiskerLeft e.inverse w).symm ‚â™‚â´ invFunIdAssoc e G\n  { hom := P.desc ((Cocones.equivalenceOfReindexing e w).functor.obj t)\n    inv := Q.desc ((Cocones.equivalenceOfReindexing e.symm w').functor.obj s)\n    hom_inv_id := by\n      apply hom_ext P; intro j\n      dsimp [w']\n      simp only [Limits.Cocone.whisker_Œπ, fac, invFunIdAssoc_inv_app, whiskerLeft_app, assoc,\n        comp_id, Limits.Cocones.precompose_obj_Œπ, fac_assoc, NatTrans.comp_app]\n      rw [counitInv_app_functor, ‚Üê Functor.comp_map, ‚Üê w.inv.naturality_assoc]\n      dsimp\n      simp\n    inv_hom_id := by\n      apply hom_ext Q\n      aesop_cat }\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.coconePointsIsoOfEquivalence_inv","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ns : CategoryTheory.Limits.Cocone F\nG : CategoryTheory.Functor K C\nt : CategoryTheory.Limits.Cocone G\nP : CategoryTheory.Limits.IsColimit s\nQ : CategoryTheory.Limits.IsColimit t\ne : CategoryTheory.Equivalence J K\nw : CategoryTheory.Iso (e.functor.comp G) F\n‚ä¢ Eq (P.coconePointsIsoOfEquivalence Q e w).inv (Q.desc ((CategoryTheory.Limits.Cocones.equivalenceOfReindexing e.symm ((CategoryTheory.isoWhiskerLeft e.inverse w).symm.trans (e.invFunIdAssoc G))).functor.obj s))","decl":"/-- We can prove two cocone points `(s : Cocone F).pt` and `(t : Cocone G).pt` are isomorphic if\n* both cocones are colimit cocones\n* their indexing categories are equivalent via some `e : J ‚âå K`,\n* the triangle of functors commutes up to a natural isomorphism: `e.functor ‚ãô G ‚âÖ F`.\n\nThis is the most general form of uniqueness of cocone points,\nallowing relabelling of both the indexing category (up to equivalence)\nand the functor (up to natural isomorphism).\n-/\n@[simps]\ndef coconePointsIsoOfEquivalence {F : J ‚•§ C} {s : Cocone F} {G : K ‚•§ C} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (e : J ‚âå K) (w : e.functor ‚ãô G ‚âÖ F) : s.pt ‚âÖ t.pt :=\n  let w' : e.inverse ‚ãô F ‚âÖ G := (isoWhiskerLeft e.inverse w).symm ‚â™‚â´ invFunIdAssoc e G\n  { hom := P.desc ((Cocones.equivalenceOfReindexing e w).functor.obj t)\n    inv := Q.desc ((Cocones.equivalenceOfReindexing e.symm w').functor.obj s)\n    hom_inv_id := by\n      apply hom_ext P; intro j\n      dsimp [w']\n      simp only [Limits.Cocone.whisker_Œπ, fac, invFunIdAssoc_inv_app, whiskerLeft_app, assoc,\n        comp_id, Limits.Cocones.precompose_obj_Œπ, fac_assoc, NatTrans.comp_app]\n      rw [counitInv_app_functor, ‚Üê Functor.comp_map, ‚Üê w.inv.naturality_assoc]\n      dsimp\n      simp\n    inv_hom_id := by\n      apply hom_ext Q\n      aesop_cat }\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.homEquiv_apply","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nW : C\nf : Quiver.Hom t.pt W\n‚ä¢ Eq ((h.homEquiv W) f) (t.extend f).Œπ","decl":"@[simp]\nlemma homEquiv_apply (h : IsColimit t) {W : C} (f : t.pt ‚ü∂ W) :\n    h.homEquiv W f = (t.extend f).Œπ := rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.homIso_hom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nW : C\nf : ULift.{u‚ÇÅ, v‚ÇÉ} (Quiver.Hom t.pt W)\n‚ä¢ Eq ((h.homIso W).hom f) (t.extend f.down).Œπ","decl":"@[simp]\ntheorem homIso_hom (h : IsColimit t) {W : C} (f : ULift (t.pt ‚ü∂ W)) :\n    (IsColimit.homIso h W).hom f = (t.extend f.down).Œπ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom_homOfCocone","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.coyoneda.obj { unop := X }).comp CategoryTheory.uliftFunctor.{u‚ÇÅ, v‚ÇÉ}) F.cocones\ns : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom h (CategoryTheory.Limits.IsColimit.OfNatIso.homOfCocone h s)) s","decl":"@[simp]\ntheorem coconeOfHom_homOfCocone (s : Cocone F) : coconeOfHom h (homOfCocone h s) = s := by\n  dsimp [coconeOfHom, homOfCocone]\n  have ‚ü®s_pt,s_Œπ‚ü© := s\n  congr; dsimp\n  convert congrFun (congrFun (congrArg NatTrans.app h.inv_hom_id) s_pt) s_Œπ using 1\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.OfNatIso.homOfCocone_cooneOfHom","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.coyoneda.obj { unop := X }).comp CategoryTheory.uliftFunctor.{u‚ÇÅ, v‚ÇÉ}) F.cocones\nY : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Limits.IsColimit.OfNatIso.homOfCocone h (CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom h f)) f","decl":"@[simp]\ntheorem homOfCocone_cooneOfHom {Y : C} (f : X ‚ü∂ Y) : homOfCocone h (coconeOfHom h f) = f :=\n  congrArg ULift.down (congrFun (congrFun (congrArg NatTrans.app h.hom_inv_id) Y) ‚ü®f‚ü© :)\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom_fac","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.coyoneda.obj { unop := X }).comp CategoryTheory.uliftFunctor.{u‚ÇÅ, v‚ÇÉ}) F.cocones\nY : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom h f) ((CategoryTheory.Limits.IsColimit.OfNatIso.colimitCocone h).extend f)","decl":"/-- If `F.cocones` is corepresented by `X`, the cocone corresponding to a morphism `f : Y ‚ü∂ X` is\nthe colimit cocone extended by `f`. -/\ntheorem coconeOfHom_fac {Y : C} (f : X ‚ü∂ Y) : coconeOfHom h f = (colimitCocone h).extend f := by\n  dsimp [coconeOfHom, colimitCocone, Cocone.extend]\n  congr with j\n  have t := congrFun (h.hom.naturality f) ‚ü®ùüô X‚ü©\n  dsimp at t\n  simp only [id_comp] at t\n  rw [congrFun (congrArg NatTrans.app t) j]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.OfNatIso.cocone_fac","module":"Mathlib.CategoryTheory.Limits.IsLimit","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX : C\nh : CategoryTheory.Iso ((CategoryTheory.coyoneda.obj { unop := X }).comp CategoryTheory.uliftFunctor.{u‚ÇÅ, v‚ÇÉ}) F.cocones\ns : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((CategoryTheory.Limits.IsColimit.OfNatIso.colimitCocone h).extend (CategoryTheory.Limits.IsColimit.OfNatIso.homOfCocone h s)) s","decl":"/-- If `F.cocones` is corepresented by `X`, any cocone is the extension of the colimit cocone by the\ncorresponding morphism. -/\ntheorem cocone_fac (s : Cocone F) : (colimitCocone h).extend (homOfCocone h s) = s := by\n  rw [‚Üê coconeOfHom_homOfCocone h s]\n  conv_lhs => simp only [homOfCocone_cooneOfHom]\n  apply (coconeOfHom_fac _ _).symm\n\n"}
