{"name":"MvQPF.recF_eq","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nβ : Type u\ng : F (α.append1 β) → β\na : (MvQPF.P F).A\nf' : ((MvQPF.P F).drop.B a).Arrow α\nf : (MvQPF.P F).last.B a → (MvQPF.P F).W α\n⊢ Eq (MvQPF.recF g ((MvQPF.P F).wMk a f' f)) (g (MvQPF.abs ⟨a, TypeVec.splitFun f' (Function.comp (MvQPF.recF g) f)⟩))","decl":"theorem recF_eq {α : TypeVec n} {β : Type u} (g : F (α.append1 β) → β) (a : q.P.A)\n    (f' : q.P.drop.B a ⟹ α) (f : q.P.last.B a → q.P.W α) :\n    recF g (q.P.wMk a f' f) = g (abs ⟨a, splitFun f' (recF g ∘ f)⟩) := by\n  rw [recF, MvPFunctor.wRec_eq]; rfl\n\n"}
{"name":"MvQPF.recF_eq'","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nβ : Type u\ng : F (α.append1 β) → β\nx : (MvQPF.P F).W α\n⊢ Eq (MvQPF.recF g x) (g (MvQPF.abs (MvFunctor.map (TypeVec.appendFun TypeVec.id (MvQPF.recF g)) ((MvQPF.P F).wDest' x))))","decl":"theorem recF_eq' {α : TypeVec n} {β : Type u} (g : F (α.append1 β) → β) (x : q.P.W α) :\n    recF g x = g (abs (appendFun id (recF g) <$$> q.P.wDest' x)) := by\n  apply q.P.w_cases _ x\n  intro a f' f\n  rw [recF_eq, q.P.wDest'_wMk, MvPFunctor.map_eq, appendFun_comp_splitFun, TypeVec.id_comp]\n\n"}
{"name":"MvQPF.recF_eq_of_wEquiv","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nβ : Type u\nu : F (α.append1 β) → β\nx y : (MvQPF.P F).W α\na✝ : MvQPF.WEquiv x y\n⊢ Eq (MvQPF.recF u x) (MvQPF.recF u y)","decl":"theorem recF_eq_of_wEquiv (α : TypeVec n) {β : Type u} (u : F (α.append1 β) → β) (x y : q.P.W α) :\n    WEquiv x y → recF u x = recF u y := by\n  apply q.P.w_cases _ x\n  intro a₀ f'₀ f₀\n  apply q.P.w_cases _ y\n  intro a₁ f'₁ f₁\n  intro h\n  -- Porting note: induction on h doesn't work.\n  refine @WEquiv.recOn _ _ _ _ (fun a a' _ ↦ recF u a = recF u a') _ _ h ?_ ?_ ?_\n  · intros a f' f₀ f₁ _h ih; simp only [recF_eq, Function.comp]\n    congr; funext; congr; funext; apply ih\n  · intros a₀ f'₀ f₀ a₁ f'₁ f₁ h; simp only [recF_eq', abs_map, MvPFunctor.wDest'_wMk, h]\n  · intros x y z _e₁ _e₂ ih₁ ih₂; exact Eq.trans ih₁ ih₂\n\n"}
{"name":"MvQPF.wEquiv.abs'","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nx y : (MvQPF.P F).W α\nh : Eq (MvQPF.abs ((MvQPF.P F).wDest' x)) (MvQPF.abs ((MvQPF.P F).wDest' y))\n⊢ MvQPF.WEquiv x y","decl":"theorem wEquiv.abs' {α : TypeVec n} (x y : q.P.W α)\n    (h : MvQPF.abs (q.P.wDest' x) = MvQPF.abs (q.P.wDest' y)) :\n    WEquiv x y := by\n  revert h\n  apply q.P.w_cases _ x\n  intro a₀ f'₀ f₀\n  apply q.P.w_cases _ y\n  intro a₁ f'₁ f₁\n  apply WEquiv.abs\n\n"}
{"name":"MvQPF.wEquiv.refl","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nx : (MvQPF.P F).W α\n⊢ MvQPF.WEquiv x x","decl":"theorem wEquiv.refl {α : TypeVec n} (x : q.P.W α) : WEquiv x x := by\n  apply q.P.w_cases _ x; intro a f' f; exact WEquiv.abs a f' f a f' f rfl\n\n"}
{"name":"MvQPF.wEquiv.symm","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nx y : (MvQPF.P F).W α\na✝ : MvQPF.WEquiv x y\n⊢ MvQPF.WEquiv y x","decl":"theorem wEquiv.symm {α : TypeVec n} (x y : q.P.W α) : WEquiv x y → WEquiv y x := by\n  intro h; induction h with\n  | ind a f' f₀ f₁ _h ih => exact WEquiv.ind _ _ _ _ ih\n  | abs a₀ f'₀ f₀ a₁ f'₁ f₁ h => exact WEquiv.abs _ _ _ _ _ _ h.symm\n  | trans x y z _e₁ _e₂ ih₁ ih₂ => exact MvQPF.WEquiv.trans _ _ _ ih₂ ih₁\n\n"}
{"name":"MvQPF.wrepr_wMk","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\na : (MvQPF.P F).A\nf' : ((MvQPF.P F).drop.B a).Arrow α\nf : (MvQPF.P F).last.B a → (MvQPF.P F).W α\n⊢ Eq (MvQPF.wrepr ((MvQPF.P F).wMk a f' f)) ((MvQPF.P F).wMk' (MvQPF.repr (MvQPF.abs (MvFunctor.map (TypeVec.appendFun TypeVec.id MvQPF.wrepr) ⟨a, (MvQPF.P F).appendContents f' f⟩))))","decl":"theorem wrepr_wMk {α : TypeVec n} (a : q.P.A) (f' : q.P.drop.B a ⟹ α)\n    (f : q.P.last.B a → q.P.W α) :\n    wrepr (q.P.wMk a f' f) =\n      q.P.wMk' (repr (abs (appendFun id wrepr <$$> ⟨a, q.P.appendContents f' f⟩))) := by\n  rw [wrepr, recF_eq', q.P.wDest'_wMk]; rfl\n\n"}
{"name":"MvQPF.wrepr_equiv","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nx : (MvQPF.P F).W α\n⊢ MvQPF.WEquiv (MvQPF.wrepr x) x","decl":"theorem wrepr_equiv {α : TypeVec n} (x : q.P.W α) : WEquiv (wrepr x) x := by\n  apply q.P.w_ind _ x; intro a f' f ih\n  apply WEquiv.trans _ (q.P.wMk' (appendFun id wrepr <$$> ⟨a, q.P.appendContents f' f⟩))\n  · apply wEquiv.abs'\n    rw [wrepr_wMk, q.P.wDest'_wMk', q.P.wDest'_wMk', abs_repr]\n  rw [q.P.map_eq, MvPFunctor.wMk', appendFun_comp_splitFun, id_comp]\n  apply WEquiv.ind; exact ih\n\n"}
{"name":"MvQPF.wEquiv_map","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα β : TypeVec.{u} n\ng : α.Arrow β\nx y : (MvQPF.P F).W α\na✝ : MvQPF.WEquiv x y\n⊢ MvQPF.WEquiv (MvFunctor.map g x) (MvFunctor.map g y)","decl":"theorem wEquiv_map {α β : TypeVec n} (g : α ⟹ β) (x y : q.P.W α) :\n    WEquiv x y → WEquiv (g <$$> x) (g <$$> y) := by\n  intro h; induction h with\n  | ind a f' f₀ f₁ h ih => rw [q.P.w_map_wMk, q.P.w_map_wMk]; apply WEquiv.ind; exact ih\n  | abs a₀ f'₀ f₀ a₁ f'₁ f₁ h =>\n    rw [q.P.w_map_wMk, q.P.w_map_wMk]; apply WEquiv.abs\n    show\n      abs (q.P.objAppend1 a₀ (g ⊚ f'₀) fun x => q.P.wMap g (f₀ x)) =\n        abs (q.P.objAppend1 a₁ (g ⊚ f'₁) fun x => q.P.wMap g (f₁ x))\n    rw [← q.P.map_objAppend1, ← q.P.map_objAppend1, abs_map, abs_map, h]\n  | trans x y z _ _ ih₁ ih₂ =>\n    apply MvQPF.WEquiv.trans\n    · apply ih₁\n    · apply ih₂\n\n"}
{"name":"MvQPF.Fix.rec_eq","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nβ : Type u\ng : F (α.append1 β) → β\nx : F (α.append1 (MvQPF.Fix F α))\n⊢ Eq (MvQPF.Fix.rec g (MvQPF.Fix.mk x)) (g (MvFunctor.map (TypeVec.appendFun TypeVec.id (MvQPF.Fix.rec g)) x))","decl":"theorem Fix.rec_eq {β : Type u} (g : F (append1 α β) → β) (x : F (append1 α (Fix F α))) :\n    Fix.rec g (Fix.mk x) = g (appendFun id (Fix.rec g) <$$> x) := by\n  have : recF g ∘ fixToW = Fix.rec g := by\n    apply funext\n    apply Quotient.ind\n    intro x\n    apply recF_eq_of_wEquiv\n    apply wrepr_equiv\n  conv =>\n    lhs\n    rw [Fix.rec, Fix.mk]\n    dsimp\n  cases' h : repr x with a f\n  rw [MvPFunctor.map_eq, recF_eq', ← MvPFunctor.map_eq, MvPFunctor.wDest'_wMk']\n  rw [← MvPFunctor.comp_map, abs_map, ← h, abs_repr, ← appendFun_comp, id_comp, this]\n\n"}
{"name":"MvQPF.Fix.ind_aux","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\na : (MvQPF.P F).A\nf' : ((MvQPF.P F).drop.B a).Arrow α\nf : (MvQPF.P F).last.B a → (MvQPF.P F).W α\n⊢ Eq (MvQPF.Fix.mk (MvQPF.abs ⟨a, (MvQPF.P F).appendContents f' fun x => Quotient.mk (MvQPF.wSetoid α) (f x)⟩)) (Quotient.mk (MvQPF.wSetoid α) ((MvQPF.P F).wMk a f' f))","decl":"theorem Fix.ind_aux (a : q.P.A) (f' : q.P.drop.B a ⟹ α) (f : q.P.last.B a → q.P.W α) :\n    Fix.mk (abs ⟨a, q.P.appendContents f' fun x => ⟦f x⟧⟩) = ⟦q.P.wMk a f' f⟧ := by\n  have : Fix.mk (abs ⟨a, q.P.appendContents f' fun x => ⟦f x⟧⟩) = ⟦wrepr (q.P.wMk a f' f)⟧ := by\n    apply Quot.sound; apply wEquiv.abs'\n    rw [MvPFunctor.wDest'_wMk', abs_map, abs_repr, ← abs_map, MvPFunctor.map_eq]\n    conv =>\n      rhs\n      rw [wrepr_wMk, q.P.wDest'_wMk', abs_repr, MvPFunctor.map_eq]\n    congr 2; rw [MvPFunctor.appendContents, MvPFunctor.appendContents]\n    rw [appendFun, appendFun, ← splitFun_comp, ← splitFun_comp]\n    rfl\n  rw [this]\n  apply Quot.sound\n  apply wrepr_equiv\n\n"}
{"name":"MvQPF.Fix.ind_rec","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nβ : Type u\ng₁ g₂ : MvQPF.Fix F α → β\nh : ∀ (x : F (α.append1 (MvQPF.Fix F α))), Eq (MvFunctor.map (TypeVec.appendFun TypeVec.id g₁) x) (MvFunctor.map (TypeVec.appendFun TypeVec.id g₂) x) → Eq (g₁ (MvQPF.Fix.mk x)) (g₂ (MvQPF.Fix.mk x))\nx : MvQPF.Fix F α\n⊢ Eq (g₁ x) (g₂ x)","decl":"theorem Fix.ind_rec {β : Type u} (g₁ g₂ : Fix F α → β)\n    (h :\n      ∀ x : F (append1 α (Fix F α)),\n        appendFun id g₁ <$$> x = appendFun id g₂ <$$> x → g₁ (Fix.mk x) = g₂ (Fix.mk x)) :\n    ∀ x, g₁ x = g₂ x := by\n  apply Quot.ind\n  intro x\n  apply q.P.w_ind _ x\n  intro a f' f ih\n  show g₁ ⟦q.P.wMk a f' f⟧ = g₂ ⟦q.P.wMk a f' f⟧\n  rw [← Fix.ind_aux a f' f]\n  apply h\n  rw [← abs_map, ← abs_map, MvPFunctor.map_eq, MvPFunctor.map_eq]\n  congr 2\n  rw [MvPFunctor.appendContents, appendFun, appendFun, ← splitFun_comp, ← splitFun_comp]\n  have : (g₁ ∘ fun x => ⟦f x⟧) = g₂ ∘ fun x => ⟦f x⟧ := by\n    ext x\n    exact ih x\n  rw [this]\n\n"}
{"name":"MvQPF.Fix.rec_unique","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nβ : Type u\ng : F (α.append1 β) → β\nh : MvQPF.Fix F α → β\nhyp : ∀ (x : F (α.append1 (MvQPF.Fix F α))), Eq (h (MvQPF.Fix.mk x)) (g (MvFunctor.map (TypeVec.appendFun TypeVec.id h) x))\n⊢ Eq (MvQPF.Fix.rec g) h","decl":"theorem Fix.rec_unique {β : Type u} (g : F (append1 α β) → β) (h : Fix F α → β)\n    (hyp : ∀ x, h (Fix.mk x) = g (appendFun id h <$$> x)) : Fix.rec g = h := by\n  ext x\n  apply Fix.ind_rec\n  intro x hyp'\n  rw [hyp, ← hyp', Fix.rec_eq]\n\n"}
{"name":"MvQPF.Fix.mk_dest","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nx : MvQPF.Fix F α\n⊢ Eq (MvQPF.Fix.mk x.dest) x","decl":"theorem Fix.mk_dest (x : Fix F α) : Fix.mk (Fix.dest x) = x := by\n  change (Fix.mk ∘ Fix.dest) x = x\n  apply Fix.ind_rec\n  intro x; dsimp\n  rw [Fix.dest, Fix.rec_eq, ← comp_map, ← appendFun_comp, id_comp]\n  intro h; rw [h]\n  show Fix.mk (appendFun id id <$$> x) = Fix.mk x\n  rw [appendFun_id_id, MvFunctor.id_map]\n\n"}
{"name":"MvQPF.Fix.dest_mk","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\nx : F (α.append1 (MvQPF.Fix F α))\n⊢ Eq (MvQPF.Fix.mk x).dest x","decl":"theorem Fix.dest_mk (x : F (append1 α (Fix F α))) : Fix.dest (Fix.mk x) = x := by\n  unfold Fix.dest\n  rw [Fix.rec_eq, ← Fix.dest, ← comp_map]\n  conv =>\n    rhs\n    rw [← MvFunctor.id_map x]\n  rw [← appendFun_comp, id_comp]\n  have : Fix.mk ∘ Fix.dest (F := F) (α := α) = _root_.id := by\n    ext (x : Fix F α)\n    apply Fix.mk_dest\n  rw [this, appendFun_id_id]\n\n"}
{"name":"MvQPF.Fix.ind","module":"Mathlib.Data.QPF.Multivariate.Constructions.Fix","initialProofState":"n : Nat\nF : TypeVec.{u} (HAdd.hAdd n 1) → Type u\nq : MvQPF F\nα : TypeVec.{u} n\np : MvQPF.Fix F α → Prop\nh : ∀ (x : F (α.append1 (MvQPF.Fix F α))), MvFunctor.LiftP (α.PredLast p) x → p (MvQPF.Fix.mk x)\nx : MvQPF.Fix F α\n⊢ p x","decl":"theorem Fix.ind {α : TypeVec n} (p : Fix F α → Prop)\n    (h : ∀ x : F (α.append1 (Fix F α)), LiftP (PredLast α p) x → p (Fix.mk x)) : ∀ x, p x := by\n  apply Quot.ind\n  intro x\n  apply q.P.w_ind _ x; intro a f' f ih\n  change p ⟦q.P.wMk a f' f⟧\n  rw [← Fix.ind_aux a f' f]\n  apply h\n  rw [MvQPF.liftP_iff]\n  refine ⟨_, _, rfl, ?_⟩\n  intro i j\n  cases i\n  · apply ih\n  · trivial\n\n"}
