{"name":"ConditionallyCompleteLattice.csInf_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Defs","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLattice α\ns : Set α\na : α\na✝¹ : BddBelow s\na✝ : Membership.mem s a\n⊢ LE.le (InfSet.sInf s) a","decl":"/-- A conditionally complete lattice is a lattice in which\nevery nonempty subset which is bounded above has a supremum, and\nevery nonempty subset which is bounded below has an infimum.\nTypical examples are real numbers or natural numbers.\n\nTo differentiate the statements from the corresponding statements in (unconditional)\ncomplete lattices, we prefix `sInf` and `sSup` by a `c` everywhere. The same statements should\nhold in both worlds, sometimes with additional assumptions of nonemptiness or\nboundedness. -/\nclass ConditionallyCompleteLattice (α : Type*) extends Lattice α, SupSet α, InfSet α where\n  /-- `a ≤ sSup s` for all `a ∈ s`. -/\n  le_csSup : ∀ s a, BddAbove s → a ∈ s → a ≤ sSup s\n  /-- `sSup s ≤ a` for all `a ∈ upperBounds s`. -/\n  csSup_le : ∀ s a, Set.Nonempty s → a ∈ upperBounds s → sSup s ≤ a\n  /-- `sInf s ≤ a` for all `a ∈ s`. -/\n  csInf_le : ∀ s a, BddBelow s → a ∈ s → sInf s ≤ a\n  /-- `a ≤ sInf s` for all `a ∈ lowerBounds s`. -/\n  le_csInf : ∀ s a, Set.Nonempty s → a ∈ lowerBounds s → a ≤ sInf s\n\n-- Porting note: mathlib3 used `renaming`\n"}
{"name":"ConditionallyCompleteLattice.le_csInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Defs","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLattice α\ns : Set α\na : α\na✝¹ : s.Nonempty\na✝ : Membership.mem (lowerBounds s) a\n⊢ LE.le a (InfSet.sInf s)","decl":"/-- A conditionally complete lattice is a lattice in which\nevery nonempty subset which is bounded above has a supremum, and\nevery nonempty subset which is bounded below has an infimum.\nTypical examples are real numbers or natural numbers.\n\nTo differentiate the statements from the corresponding statements in (unconditional)\ncomplete lattices, we prefix `sInf` and `sSup` by a `c` everywhere. The same statements should\nhold in both worlds, sometimes with additional assumptions of nonemptiness or\nboundedness. -/\nclass ConditionallyCompleteLattice (α : Type*) extends Lattice α, SupSet α, InfSet α where\n  /-- `a ≤ sSup s` for all `a ∈ s`. -/\n  le_csSup : ∀ s a, BddAbove s → a ∈ s → a ≤ sSup s\n  /-- `sSup s ≤ a` for all `a ∈ upperBounds s`. -/\n  csSup_le : ∀ s a, Set.Nonempty s → a ∈ upperBounds s → sSup s ≤ a\n  /-- `sInf s ≤ a` for all `a ∈ s`. -/\n  csInf_le : ∀ s a, BddBelow s → a ∈ s → sInf s ≤ a\n  /-- `a ≤ sInf s` for all `a ∈ lowerBounds s`. -/\n  le_csInf : ∀ s a, Set.Nonempty s → a ∈ lowerBounds s → a ≤ sInf s\n\n-- Porting note: mathlib3 used `renaming`\n"}
{"name":"ConditionallyCompleteLattice.csSup_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Defs","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLattice α\ns : Set α\na : α\na✝¹ : s.Nonempty\na✝ : Membership.mem (upperBounds s) a\n⊢ LE.le (SupSet.sSup s) a","decl":"/-- A conditionally complete lattice is a lattice in which\nevery nonempty subset which is bounded above has a supremum, and\nevery nonempty subset which is bounded below has an infimum.\nTypical examples are real numbers or natural numbers.\n\nTo differentiate the statements from the corresponding statements in (unconditional)\ncomplete lattices, we prefix `sInf` and `sSup` by a `c` everywhere. The same statements should\nhold in both worlds, sometimes with additional assumptions of nonemptiness or\nboundedness. -/\nclass ConditionallyCompleteLattice (α : Type*) extends Lattice α, SupSet α, InfSet α where\n  /-- `a ≤ sSup s` for all `a ∈ s`. -/\n  le_csSup : ∀ s a, BddAbove s → a ∈ s → a ≤ sSup s\n  /-- `sSup s ≤ a` for all `a ∈ upperBounds s`. -/\n  csSup_le : ∀ s a, Set.Nonempty s → a ∈ upperBounds s → sSup s ≤ a\n  /-- `sInf s ≤ a` for all `a ∈ s`. -/\n  csInf_le : ∀ s a, BddBelow s → a ∈ s → sInf s ≤ a\n  /-- `a ≤ sInf s` for all `a ∈ lowerBounds s`. -/\n  le_csInf : ∀ s a, Set.Nonempty s → a ∈ lowerBounds s → a ≤ sInf s\n\n-- Porting note: mathlib3 used `renaming`\n"}
{"name":"ConditionallyCompleteLattice.le_csSup","module":"Mathlib.Order.ConditionallyCompleteLattice.Defs","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLattice α\ns : Set α\na : α\na✝¹ : BddAbove s\na✝ : Membership.mem s a\n⊢ LE.le a (SupSet.sSup s)","decl":"/-- A conditionally complete lattice is a lattice in which\nevery nonempty subset which is bounded above has a supremum, and\nevery nonempty subset which is bounded below has an infimum.\nTypical examples are real numbers or natural numbers.\n\nTo differentiate the statements from the corresponding statements in (unconditional)\ncomplete lattices, we prefix `sInf` and `sSup` by a `c` everywhere. The same statements should\nhold in both worlds, sometimes with additional assumptions of nonemptiness or\nboundedness. -/\nclass ConditionallyCompleteLattice (α : Type*) extends Lattice α, SupSet α, InfSet α where\n  /-- `a ≤ sSup s` for all `a ∈ s`. -/\n  le_csSup : ∀ s a, BddAbove s → a ∈ s → a ≤ sSup s\n  /-- `sSup s ≤ a` for all `a ∈ upperBounds s`. -/\n  csSup_le : ∀ s a, Set.Nonempty s → a ∈ upperBounds s → sSup s ≤ a\n  /-- `sInf s ≤ a` for all `a ∈ s`. -/\n  csInf_le : ∀ s a, BddBelow s → a ∈ s → sInf s ≤ a\n  /-- `a ≤ sInf s` for all `a ∈ lowerBounds s`. -/\n  le_csInf : ∀ s a, Set.Nonempty s → a ∈ lowerBounds s → a ≤ sInf s\n\n-- Porting note: mathlib3 used `renaming`\n"}
{"name":"ConditionallyCompleteLinearOrder.csInf_of_not_bddBelow","module":"Mathlib.Order.ConditionallyCompleteLattice.Defs","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrder α\ns : Set α\na✝ : Not (BddBelow s)\n⊢ Eq (InfSet.sInf s) (InfSet.sInf EmptyCollection.emptyCollection)","decl":"/-- A conditionally complete linear order is a linear order in which\nevery nonempty subset which is bounded above has a supremum, and\nevery nonempty subset which is bounded below has an infimum.\nTypical examples are real numbers or natural numbers.\n\nTo differentiate the statements from the corresponding statements in (unconditional)\ncomplete linear orders, we prefix `sInf` and `sSup` by a `c` everywhere. The same statements should\nhold in both worlds, sometimes with additional assumptions of nonemptiness or\nboundedness. -/\nclass ConditionallyCompleteLinearOrder (α : Type*) extends ConditionallyCompleteLattice α where\n  /-- A `ConditionallyCompleteLinearOrder` is total. -/\n  le_total (a b : α) : a ≤ b ∨ b ≤ a\n  /-- In a `ConditionallyCompleteLinearOrder`, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (· ≤ · : α → α → Prop)\n  /-- In a `ConditionallyCompleteLinearOrder`, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq α := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a `ConditionallyCompleteLinearOrder`, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (· < · : α → α → Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n  /-- If a set is not bounded above, its supremum is by convention `sSup ∅`. -/\n  csSup_of_not_bddAbove : ∀ s, ¬BddAbove s → sSup s = sSup (∅ : Set α)\n  /-- If a set is not bounded below, its infimum is by convention `sInf ∅`. -/\n  csInf_of_not_bddBelow : ∀ s, ¬BddBelow s → sInf s = sInf (∅ : Set α)\n\n"}
{"name":"ConditionallyCompleteLinearOrder.csSup_of_not_bddAbove","module":"Mathlib.Order.ConditionallyCompleteLattice.Defs","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrder α\ns : Set α\na✝ : Not (BddAbove s)\n⊢ Eq (SupSet.sSup s) (SupSet.sSup EmptyCollection.emptyCollection)","decl":"/-- A conditionally complete linear order is a linear order in which\nevery nonempty subset which is bounded above has a supremum, and\nevery nonempty subset which is bounded below has an infimum.\nTypical examples are real numbers or natural numbers.\n\nTo differentiate the statements from the corresponding statements in (unconditional)\ncomplete linear orders, we prefix `sInf` and `sSup` by a `c` everywhere. The same statements should\nhold in both worlds, sometimes with additional assumptions of nonemptiness or\nboundedness. -/\nclass ConditionallyCompleteLinearOrder (α : Type*) extends ConditionallyCompleteLattice α where\n  /-- A `ConditionallyCompleteLinearOrder` is total. -/\n  le_total (a b : α) : a ≤ b ∨ b ≤ a\n  /-- In a `ConditionallyCompleteLinearOrder`, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (· ≤ · : α → α → Prop)\n  /-- In a `ConditionallyCompleteLinearOrder`, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq α := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a `ConditionallyCompleteLinearOrder`, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (· < · : α → α → Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n  /-- If a set is not bounded above, its supremum is by convention `sSup ∅`. -/\n  csSup_of_not_bddAbove : ∀ s, ¬BddAbove s → sSup s = sSup (∅ : Set α)\n  /-- If a set is not bounded below, its infimum is by convention `sInf ∅`. -/\n  csInf_of_not_bddBelow : ∀ s, ¬BddBelow s → sInf s = sInf (∅ : Set α)\n\n"}
{"name":"ConditionallyCompleteLinearOrder.le_total","module":"Mathlib.Order.ConditionallyCompleteLattice.Defs","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrder α\na b : α\n⊢ Or (LE.le a b) (LE.le b a)","decl":"/-- A conditionally complete linear order is a linear order in which\nevery nonempty subset which is bounded above has a supremum, and\nevery nonempty subset which is bounded below has an infimum.\nTypical examples are real numbers or natural numbers.\n\nTo differentiate the statements from the corresponding statements in (unconditional)\ncomplete linear orders, we prefix `sInf` and `sSup` by a `c` everywhere. The same statements should\nhold in both worlds, sometimes with additional assumptions of nonemptiness or\nboundedness. -/\nclass ConditionallyCompleteLinearOrder (α : Type*) extends ConditionallyCompleteLattice α where\n  /-- A `ConditionallyCompleteLinearOrder` is total. -/\n  le_total (a b : α) : a ≤ b ∨ b ≤ a\n  /-- In a `ConditionallyCompleteLinearOrder`, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (· ≤ · : α → α → Prop)\n  /-- In a `ConditionallyCompleteLinearOrder`, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq α := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a `ConditionallyCompleteLinearOrder`, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (· < · : α → α → Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n  /-- If a set is not bounded above, its supremum is by convention `sSup ∅`. -/\n  csSup_of_not_bddAbove : ∀ s, ¬BddAbove s → sSup s = sSup (∅ : Set α)\n  /-- If a set is not bounded below, its infimum is by convention `sInf ∅`. -/\n  csInf_of_not_bddBelow : ∀ s, ¬BddBelow s → sInf s = sInf (∅ : Set α)\n\n"}
{"name":"ConditionallyCompleteLinearOrderBot.csSup_empty","module":"Mathlib.Order.ConditionallyCompleteLattice.Defs","initialProofState":"α : Type u_5\nself : ConditionallyCompleteLinearOrderBot α\n⊢ Eq (SupSet.sSup EmptyCollection.emptyCollection) Bot.bot","decl":"/-- A conditionally complete linear order with `Bot` is a linear order with least element, in which\nevery nonempty subset which is bounded above has a supremum, and every nonempty subset (necessarily\nbounded below) has an infimum.  A typical example is the natural numbers.\n\nTo differentiate the statements from the corresponding statements in (unconditional)\ncomplete linear orders, we prefix `sInf` and `sSup` by a `c` everywhere. The same statements should\nhold in both worlds, sometimes with additional assumptions of nonemptiness or\nboundedness. -/\nclass ConditionallyCompleteLinearOrderBot (α : Type*) extends ConditionallyCompleteLinearOrder α,\n    OrderBot α where\n  /-- The supremum of the empty set is special-cased to `⊥` -/\n  csSup_empty : sSup ∅ = ⊥\n\n-- see Note [lower instance priority]\n"}
