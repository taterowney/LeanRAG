{"name":"PNatPowAssoc.ppow_add","module":"Mathlib.Algebra.Group.PNatPowAssoc","initialProofState":"M : Type u_2\ninst✝¹ : Mul M\ninst✝ : Pow M PNat\nself : PNatPowAssoc M\nk n : PNat\nx : M\n⊢ Eq (HPow.hPow x (HAdd.hAdd k n)) (HMul.hMul (HPow.hPow x k) (HPow.hPow x n))","decl":"/-- A `Prop`-valued mixin for power-associative multiplication in the non-unital setting. -/\nclass PNatPowAssoc (M : Type*) [Mul M] [Pow M ℕ+] : Prop where\n  /-- Multiplication is power-associative. -/\n  protected ppow_add : ∀ (k n : ℕ+) (x : M), x ^ (k + n) = x ^ k * x ^ n\n  /-- Exponent one is identity. -/\n  protected ppow_one : ∀ (x : M), x ^ (1 : ℕ+) = x\n\n"}
{"name":"PNatPowAssoc.ppow_one","module":"Mathlib.Algebra.Group.PNatPowAssoc","initialProofState":"M : Type u_2\ninst✝¹ : Mul M\ninst✝ : Pow M PNat\nself : PNatPowAssoc M\nx : M\n⊢ Eq (HPow.hPow x 1) x","decl":"/-- A `Prop`-valued mixin for power-associative multiplication in the non-unital setting. -/\nclass PNatPowAssoc (M : Type*) [Mul M] [Pow M ℕ+] : Prop where\n  /-- Multiplication is power-associative. -/\n  protected ppow_add : ∀ (k n : ℕ+) (x : M), x ^ (k + n) = x ^ k * x ^ n\n  /-- Exponent one is identity. -/\n  protected ppow_one : ∀ (x : M), x ^ (1 : ℕ+) = x\n\n"}
{"name":"ppow_add","module":"Mathlib.Algebra.Group.PNatPowAssoc","initialProofState":"M : Type u_1\ninst✝² : Mul M\ninst✝¹ : Pow M PNat\ninst✝ : PNatPowAssoc M\nk n : PNat\nx : M\n⊢ Eq (HPow.hPow x (HAdd.hAdd k n)) (HMul.hMul (HPow.hPow x k) (HPow.hPow x n))","decl":"theorem ppow_add (k n : ℕ+) (x : M) : x ^ (k + n) = x ^ k * x ^ n :=\n  PNatPowAssoc.ppow_add k n x\n\n"}
{"name":"ppow_one","module":"Mathlib.Algebra.Group.PNatPowAssoc","initialProofState":"M : Type u_1\ninst✝² : Mul M\ninst✝¹ : Pow M PNat\ninst✝ : PNatPowAssoc M\nx : M\n⊢ Eq (HPow.hPow x 1) x","decl":"@[simp]\ntheorem ppow_one (x : M) : x ^ (1 : ℕ+) = x :=\n  PNatPowAssoc.ppow_one x\n\n"}
{"name":"ppow_mul_assoc","module":"Mathlib.Algebra.Group.PNatPowAssoc","initialProofState":"M : Type u_1\ninst✝² : Mul M\ninst✝¹ : Pow M PNat\ninst✝ : PNatPowAssoc M\nk m n : PNat\nx : M\n⊢ Eq (HMul.hMul (HMul.hMul (HPow.hPow x k) (HPow.hPow x m)) (HPow.hPow x n)) (HMul.hMul (HPow.hPow x k) (HMul.hMul (HPow.hPow x m) (HPow.hPow x n)))","decl":"theorem ppow_mul_assoc (k m n : ℕ+) (x : M) :\n    (x ^ k * x ^ m) * x ^ n = x ^ k * (x ^ m * x ^ n) := by\n  simp only [← ppow_add, add_assoc]\n\n"}
{"name":"ppow_mul_comm","module":"Mathlib.Algebra.Group.PNatPowAssoc","initialProofState":"M : Type u_1\ninst✝² : Mul M\ninst✝¹ : Pow M PNat\ninst✝ : PNatPowAssoc M\nm n : PNat\nx : M\n⊢ Eq (HMul.hMul (HPow.hPow x m) (HPow.hPow x n)) (HMul.hMul (HPow.hPow x n) (HPow.hPow x m))","decl":"theorem ppow_mul_comm (m n : ℕ+) (x : M) :\n    x ^ m * x ^ n = x ^ n * x ^ m := by simp only [← ppow_add, add_comm]\n\n"}
{"name":"ppow_mul","module":"Mathlib.Algebra.Group.PNatPowAssoc","initialProofState":"M : Type u_1\ninst✝² : Mul M\ninst✝¹ : Pow M PNat\ninst✝ : PNatPowAssoc M\nx : M\nm n : PNat\n⊢ Eq (HPow.hPow x (HMul.hMul m n)) (HPow.hPow (HPow.hPow x m) n)","decl":"theorem ppow_mul (x : M) (m n : ℕ+) : x ^ (m * n) = (x ^ m) ^ n := by\n  induction n with\n  | one => rw [ppow_one, mul_one]\n  | succ k hk => rw [ppow_add, ppow_one, mul_add, ppow_add, mul_one, hk]\n\n"}
{"name":"ppow_mul'","module":"Mathlib.Algebra.Group.PNatPowAssoc","initialProofState":"M : Type u_1\ninst✝² : Mul M\ninst✝¹ : Pow M PNat\ninst✝ : PNatPowAssoc M\nx : M\nm n : PNat\n⊢ Eq (HPow.hPow x (HMul.hMul m n)) (HPow.hPow (HPow.hPow x n) m)","decl":"theorem ppow_mul' (x : M) (m n : ℕ+) : x ^ (m * n) = (x ^ n) ^ m := by\n  rw [mul_comm]\n  exact ppow_mul x n m\n\n"}
{"name":"Pi.instPNatPowAssoc","module":"Mathlib.Algebra.Group.PNatPowAssoc","initialProofState":"ι : Type u_2\nα : ι → Type u_3\ninst✝² : (i : ι) → Mul (α i)\ninst✝¹ : (i : ι) → Pow (α i) PNat\ninst✝ : ∀ (i : ι), PNatPowAssoc (α i)\n⊢ PNatPowAssoc ((i : ι) → α i)","decl":"instance Pi.instPNatPowAssoc {ι : Type*} {α : ι → Type*} [∀ i, Mul <| α i] [∀ i, Pow (α i) ℕ+]\n    [∀ i, PNatPowAssoc <| α i] : PNatPowAssoc (∀ i, α i) where\n  ppow_add _ _ _ := by ext; simp [ppow_add]\n  ppow_one _ := by ext; simp\n\n"}
{"name":"Prod.instPNatPowAssoc","module":"Mathlib.Algebra.Group.PNatPowAssoc","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝⁵ : Mul M\ninst✝⁴ : Pow M PNat\ninst✝³ : PNatPowAssoc M\ninst✝² : Mul N\ninst✝¹ : Pow N PNat\ninst✝ : PNatPowAssoc N\n⊢ PNatPowAssoc (Prod M N)","decl":"instance Prod.instPNatPowAssoc {N : Type*} [Mul M] [Pow M ℕ+] [PNatPowAssoc M] [Mul N] [Pow N ℕ+]\n    [PNatPowAssoc N] : PNatPowAssoc (M × N) where\n  ppow_add _ _ _ := by ext <;> simp [ppow_add]\n  ppow_one _ := by ext <;> simp\n\n"}
{"name":"ppow_eq_pow","module":"Mathlib.Algebra.Group.PNatPowAssoc","initialProofState":"M : Type u_1\ninst✝² : Monoid M\ninst✝¹ : Pow M PNat\ninst✝ : PNatPowAssoc M\nx : M\nn : PNat\n⊢ Eq (HPow.hPow x n) (HPow.hPow x ↑n)","decl":"theorem ppow_eq_pow [Monoid M] [Pow M ℕ+] [PNatPowAssoc M] (x : M) (n : ℕ+) :\n    x ^ n = x ^ (n : ℕ) := by\n  induction n with\n  | one => rw [ppow_one, PNat.one_coe, pow_one]\n  | succ k hk => rw [ppow_add, ppow_one, PNat.add_coe, pow_add, PNat.one_coe, pow_one, ← hk]\n"}
