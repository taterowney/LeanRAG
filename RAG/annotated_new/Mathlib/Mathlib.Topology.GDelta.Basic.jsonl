{"name":"IsOpen.isGδ","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nh : IsOpen s\n⊢ IsGδ s","decl":"/-- An open set is a Gδ set. -/\ntheorem IsOpen.isGδ {s : Set X} (h : IsOpen s) : IsGδ s :=\n  ⟨{s}, by simp [h], countable_singleton _, (Set.sInter_singleton _).symm⟩\n\n"}
{"name":"IsGδ.empty","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ IsGδ EmptyCollection.emptyCollection","decl":"@[simp]\nprotected theorem IsGδ.empty : IsGδ (∅ : Set X) :=\n  isOpen_empty.isGδ\n\n\n"}
{"name":"IsGδ.univ","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ IsGδ Set.univ","decl":"@[simp]\nprotected theorem IsGδ.univ : IsGδ (univ : Set X) :=\n  isOpen_univ.isGδ\n\n\n"}
{"name":"IsGδ.biInter_of_isOpen","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\nι : Type u_3\ninst✝ : TopologicalSpace X\nI : Set ι\nhI : I.Countable\nf : ι → Set X\nhf : ∀ (i : ι), Membership.mem I i → IsOpen (f i)\n⊢ IsGδ (Set.iInter fun i => Set.iInter fun h => f i)","decl":"theorem IsGδ.biInter_of_isOpen {I : Set ι} (hI : I.Countable) {f : ι → Set X}\n    (hf : ∀ i ∈ I, IsOpen (f i)) : IsGδ (⋂ i ∈ I, f i) :=\n  ⟨f '' I, by rwa [forall_mem_image], hI.image _, by rw [sInter_image]⟩\n\n\n"}
{"name":"IsGδ.iInter_of_isOpen","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\nι' : Sort u_4\ninst✝¹ : TopologicalSpace X\ninst✝ : Countable ι'\nf : ι' → Set X\nhf : ∀ (i : ι'), IsOpen (f i)\n⊢ IsGδ (Set.iInter fun i => f i)","decl":"theorem IsGδ.iInter_of_isOpen [Countable ι'] {f : ι' → Set X} (hf : ∀ i, IsOpen (f i)) :\n    IsGδ (⋂ i, f i) :=\n  ⟨range f, by rwa [forall_mem_range], countable_range _, by rw [sInter_range]⟩\n\n\n"}
{"name":"isGδ_iff_eq_iInter_nat","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsGδ s) (Exists fun f => And (∀ (n : Nat), IsOpen (f n)) (Eq s (Set.iInter fun n => f n)))","decl":"lemma isGδ_iff_eq_iInter_nat {s : Set X} :\n    IsGδ s ↔ ∃ (f : ℕ → Set X), (∀ n, IsOpen (f n)) ∧ s = ⋂ n, f n := by\n  refine ⟨?_, ?_⟩\n  · rintro ⟨T, hT, T_count, rfl⟩\n    rcases Set.eq_empty_or_nonempty T with rfl|hT\n    · exact ⟨fun _n ↦ univ, fun _n ↦ isOpen_univ, by simp⟩\n    · obtain ⟨f, hf⟩ : ∃ (f : ℕ → Set X), T = range f := Countable.exists_eq_range T_count hT\n      exact ⟨f, by aesop, by simp [hf]⟩\n  · rintro ⟨f, hf, rfl⟩\n    exact .iInter_of_isOpen hf\n\n"}
{"name":"IsGδ.eq_iInter_nat","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\na✝ : IsGδ s\n⊢ Exists fun f => And (∀ (n : Nat), IsOpen (f n)) (Eq s (Set.iInter fun n => f n))","decl":"alias ⟨IsGδ.eq_iInter_nat, _⟩ := isGδ_iff_eq_iInter_nat\n\n"}
{"name":"IsGδ.iInter","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\nι' : Sort u_4\ninst✝¹ : TopologicalSpace X\ninst✝ : Countable ι'\ns : ι' → Set X\nhs : ∀ (i : ι'), IsGδ (s i)\n⊢ IsGδ (Set.iInter fun i => s i)","decl":"/-- The intersection of an encodable family of Gδ sets is a Gδ set. -/\nprotected theorem IsGδ.iInter [Countable ι'] {s : ι' → Set X} (hs : ∀ i, IsGδ (s i)) :\n    IsGδ (⋂ i, s i) := by\n  choose T hTo hTc hTs using hs\n  obtain rfl : s = fun i => ⋂₀ T i := funext hTs\n  refine ⟨⋃ i, T i, ?_, countable_iUnion hTc, (sInter_iUnion _).symm⟩\n  simpa [@forall_swap ι'] using hTo\n\n"}
{"name":"isGδ_iInter","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\nι' : Sort u_4\ninst✝¹ : TopologicalSpace X\ninst✝ : Countable ι'\ns : ι' → Set X\nhs : ∀ (i : ι'), IsGδ (s i)\n⊢ IsGδ (Set.iInter fun i => s i)","decl":"@[deprecated (since := \"2024.02.15\")] alias isGδ_iInter := IsGδ.iInter\n\n"}
{"name":"IsGδ.biInter","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\nι : Type u_3\ninst✝ : TopologicalSpace X\ns : Set ι\nhs : s.Countable\nt : (i : ι) → Membership.mem s i → Set X\nht : ∀ (i : ι) (hi : Membership.mem s i), IsGδ (t i hi)\n⊢ IsGδ (Set.iInter fun i => Set.iInter fun h => t i h)","decl":"theorem IsGδ.biInter {s : Set ι} (hs : s.Countable) {t : ∀ i ∈ s, Set X}\n    (ht : ∀ (i) (hi : i ∈ s), IsGδ (t i hi)) : IsGδ (⋂ i ∈ s, t i ‹_›) := by\n  rw [biInter_eq_iInter]\n  haveI := hs.to_subtype\n  exact .iInter fun x => ht x x.2\n\n\n"}
{"name":"IsGδ.sInter","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nh : ∀ (s : Set X), Membership.mem S s → IsGδ s\nhS : S.Countable\n⊢ IsGδ S.sInter","decl":"/-- A countable intersection of Gδ sets is a Gδ set. -/\ntheorem IsGδ.sInter {S : Set (Set X)} (h : ∀ s ∈ S, IsGδ s) (hS : S.Countable) : IsGδ (⋂₀ S) := by\n  simpa only [sInter_eq_biInter] using IsGδ.biInter hS h\n\n\n"}
{"name":"IsGδ.inter","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsGδ s\nht : IsGδ t\n⊢ IsGδ (Inter.inter s t)","decl":"theorem IsGδ.inter {s t : Set X} (hs : IsGδ s) (ht : IsGδ t) : IsGδ (s ∩ t) := by\n  rw [inter_eq_iInter]\n  exact .iInter (Bool.forall_bool.2 ⟨ht, hs⟩)\n\n"}
{"name":"IsGδ.union","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsGδ s\nht : IsGδ t\n⊢ IsGδ (Union.union s t)","decl":"/-- The union of two Gδ sets is a Gδ set. -/\ntheorem IsGδ.union {s t : Set X} (hs : IsGδ s) (ht : IsGδ t) : IsGδ (s ∪ t) := by\n  rcases hs with ⟨S, Sopen, Scount, rfl⟩\n  rcases ht with ⟨T, Topen, Tcount, rfl⟩\n  rw [sInter_union_sInter]\n  refine .biInter_of_isOpen (Scount.prod Tcount) ?_\n  rintro ⟨a, b⟩ ⟨ha, hb⟩\n  exact (Sopen a ha).union (Topen b hb)\n\n"}
{"name":"IsGδ.sUnion","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nhS : S.Finite\nh : ∀ (s : Set X), Membership.mem S s → IsGδ s\n⊢ IsGδ S.sUnion","decl":"/-- The union of finitely many Gδ sets is a Gδ set, `Set.sUnion` version. -/\ntheorem IsGδ.sUnion {S : Set (Set X)} (hS : S.Finite) (h : ∀ s ∈ S, IsGδ s) : IsGδ (⋃₀ S) := by\n  induction S, hS using Set.Finite.induction_on with\n  | empty => simp\n  | insert _ _ ih =>\n    simp only [forall_mem_insert, sUnion_insert] at *\n    exact h.1.union (ih h.2)\n\n"}
{"name":"IsGδ.biUnion","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\nι : Type u_3\ninst✝ : TopologicalSpace X\ns : Set ι\nhs : s.Finite\nf : ι → Set X\nh : ∀ (i : ι), Membership.mem s i → IsGδ (f i)\n⊢ IsGδ (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"/-- The union of finitely many Gδ sets is a Gδ set, bounded indexed union version. -/\ntheorem IsGδ.biUnion {s : Set ι} (hs : s.Finite) {f : ι → Set X} (h : ∀ i ∈ s, IsGδ (f i)) :\n    IsGδ (⋃ i ∈ s, f i) := by\n  rw [← sUnion_image]\n  exact .sUnion (hs.image _) (forall_mem_image.2 h)\n\n"}
{"name":"IsGδ.iUnion","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\nι' : Sort u_4\ninst✝¹ : TopologicalSpace X\ninst✝ : Finite ι'\nf : ι' → Set X\nh : ∀ (i : ι'), IsGδ (f i)\n⊢ IsGδ (Set.iUnion fun i => f i)","decl":"/-- The union of finitely many Gδ sets is a Gδ set, bounded indexed union version. -/\ntheorem IsGδ.iUnion [Finite ι'] {f : ι' → Set X} (h : ∀ i, IsGδ (f i)) : IsGδ (⋃ i, f i) :=\n  .sUnion (finite_range _) <| forall_mem_range.2 h\n\n"}
{"name":"countableInterFilter_residual","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ CountableInterFilter (residual X)","decl":"instance countableInterFilter_residual : CountableInterFilter (residual X) := by\n  rw [residual]; infer_instance\n\n"}
{"name":"residual_of_dense_open","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nho : IsOpen s\nhd : Dense s\n⊢ Membership.mem (residual X) s","decl":"/-- Dense open sets are residual. -/\ntheorem residual_of_dense_open {s : Set X} (ho : IsOpen s) (hd : Dense s) : s ∈ residual X :=\n  CountableGenerateSets.basic ⟨ho, hd⟩\n\n"}
{"name":"residual_of_dense_Gδ","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nho : IsGδ s\nhd : Dense s\n⊢ Membership.mem (residual X) s","decl":"/-- Dense Gδ sets are residual. -/\ntheorem residual_of_dense_Gδ {s : Set X} (ho : IsGδ s) (hd : Dense s) : s ∈ residual X := by\n  rcases ho with ⟨T, To, Tct, rfl⟩\n  exact\n    (countable_sInter_mem Tct).mpr fun t tT =>\n      residual_of_dense_open (To t tT) (hd.mono (sInter_subset_of_mem tT))\n\n"}
{"name":"mem_residual_iff","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Membership.mem (residual X) s) (Exists fun S => And (∀ (t : Set X), Membership.mem S t → IsOpen t) (And (∀ (t : Set X), Membership.mem S t → Dense t) (And S.Countable (HasSubset.Subset S.sInter s))))","decl":"/-- A set is residual iff it includes a countable intersection of dense open sets. -/\ntheorem mem_residual_iff {s : Set X} :\n    s ∈ residual X ↔\n      ∃ S : Set (Set X), (∀ t ∈ S, IsOpen t) ∧ (∀ t ∈ S, Dense t) ∧ S.Countable ∧ ⋂₀ S ⊆ s :=\n  mem_countableGenerate_iff.trans <| by simp_rw [subset_def, mem_setOf, forall_and, and_assoc]\n\n"}
{"name":"isNowhereDense_empty","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\n⊢ IsNowhereDense EmptyCollection.emptyCollection","decl":"/-- The empty set is nowhere dense. -/\n@[simp]\nlemma isNowhereDense_empty : IsNowhereDense (∅ : Set X) := by\n  rw [IsNowhereDense, closure_empty, interior_empty]\n\n"}
{"name":"IsClosed.isNowhereDense_iff","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsClosed s\n⊢ Iff (IsNowhereDense s) (Eq (interior s) EmptyCollection.emptyCollection)","decl":"/-- A closed set is nowhere dense iff its interior is empty. -/\nlemma IsClosed.isNowhereDense_iff {s : Set X} (hs : IsClosed s) :\n    IsNowhereDense s ↔ interior s = ∅ := by\n  rw [IsNowhereDense, IsClosed.closure_eq hs]\n\n"}
{"name":"IsNowhereDense.closure","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsNowhereDense s\n⊢ IsNowhereDense (closure s)","decl":"/-- If a set `s` is nowhere dense, so is its closure. -/\nprotected lemma IsNowhereDense.closure {s : Set X} (hs : IsNowhereDense s) :\n    IsNowhereDense (closure s) := by\n  rwa [IsNowhereDense, closure_closure]\n\n"}
{"name":"IsNowhereDense.subset_of_closed_isNowhereDense","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsNowhereDense s\n⊢ Exists fun t => And (HasSubset.Subset s t) (And (IsNowhereDense t) (IsClosed t))","decl":"/-- A nowhere dense set `s` is contained in a closed nowhere dense set (namely, its closure). -/\nlemma IsNowhereDense.subset_of_closed_isNowhereDense {s : Set X} (hs : IsNowhereDense s) :\n    ∃ t : Set X, s ⊆ t ∧ IsNowhereDense t ∧ IsClosed t :=\n  ⟨closure s, subset_closure, ⟨hs.closure, isClosed_closure⟩⟩\n\n"}
{"name":"isClosed_isNowhereDense_iff_compl","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (And (IsClosed s) (IsNowhereDense s)) (And (IsOpen (HasCompl.compl s)) (Dense (HasCompl.compl s)))","decl":"/-- A set `s` is closed and nowhere dense iff its complement `sᶜ` is open and dense. -/\nlemma isClosed_isNowhereDense_iff_compl {s : Set X} :\n    IsClosed s ∧ IsNowhereDense s ↔ IsOpen sᶜ ∧ Dense sᶜ := by\n  rw [and_congr_right IsClosed.isNowhereDense_iff,\n    isOpen_compl_iff, interior_eq_empty_iff_dense_compl]\n\n"}
{"name":"meagre_empty","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\n⊢ IsMeagre EmptyCollection.emptyCollection","decl":"/-- The empty set is meagre. -/\nlemma meagre_empty : IsMeagre (∅ : Set X) := by\n  rw [IsMeagre, compl_empty]\n  exact Filter.univ_mem\n\n"}
{"name":"IsMeagre.mono","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsMeagre s\nhts : HasSubset.Subset t s\n⊢ IsMeagre t","decl":"/-- Subsets of meagre sets are meagre. -/\nlemma IsMeagre.mono {s t : Set X} (hs : IsMeagre s) (hts : t ⊆ s) : IsMeagre t :=\n  Filter.mem_of_superset hs (compl_subset_compl.mpr hts)\n\n"}
{"name":"IsMeagre.inter","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\ns t : Set X\nhs : IsMeagre s\n⊢ IsMeagre (Inter.inter s t)","decl":"/-- An intersection with a meagre set is meagre. -/\nlemma IsMeagre.inter {s t : Set X} (hs : IsMeagre s) : IsMeagre (s ∩ t) :=\n  hs.mono inter_subset_left\n\n"}
{"name":"isMeagre_iUnion","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\ns : Nat → Set X\nhs : ∀ (n : Nat), IsMeagre (s n)\n⊢ IsMeagre (Set.iUnion fun n => s n)","decl":"/-- A countable union of meagre sets is meagre. -/\nlemma isMeagre_iUnion {s : ℕ → Set X} (hs : ∀ n, IsMeagre (s n)) : IsMeagre (⋃ n, s n) := by\n  rw [IsMeagre, compl_iUnion]\n  exact countable_iInter_mem.mpr hs\n\n"}
{"name":"isMeagre_iff_countable_union_isNowhereDense","module":"Mathlib.Topology.GDelta.Basic","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsMeagre s) (Exists fun S => And (∀ (t : Set X), Membership.mem S t → IsNowhereDense t) (And S.Countable (HasSubset.Subset s S.sUnion)))","decl":"/-- A set is meagre iff it is contained in a countable union of nowhere dense sets. -/\nlemma isMeagre_iff_countable_union_isNowhereDense {s : Set X} :\n    IsMeagre s ↔ ∃ S : Set (Set X), (∀ t ∈ S, IsNowhereDense t) ∧ S.Countable ∧ s ⊆ ⋃₀ S := by\n  rw [IsMeagre, mem_residual_iff, compl_bijective.surjective.image_surjective.exists]\n  simp_rw [← and_assoc, ← forall_and, forall_mem_image, ← isClosed_isNowhereDense_iff_compl,\n    sInter_image, ← compl_iUnion₂, compl_subset_compl, ← sUnion_eq_biUnion, and_assoc]\n  refine ⟨fun ⟨S, hS, hc, hsub⟩ ↦ ⟨S, fun s hs ↦ (hS hs).2, ?_, hsub⟩, ?_⟩\n  · rw [← compl_compl_image S]; exact hc.image _\n  · intro ⟨S, hS, hc, hsub⟩\n    use closure '' S\n    rw [forall_mem_image]\n    exact ⟨fun s hs ↦ ⟨isClosed_closure, (hS s hs).closure⟩,\n      (hc.image _).image _, hsub.trans (sUnion_mono_subsets fun s ↦ subset_closure)⟩\n\n"}
