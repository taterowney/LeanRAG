{"name":"Comon_Class.comul_assoc'","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\nself : Comon_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Comon_Class.comul)) (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Comon_Class.comul X) (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom))","decl":"/-- A comonoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called a \"coalgebra object\".\n-/\nclass Comon_Class (X : C) where\n  /-- The counit morphism of a comonoid object. -/\n  counit : X ‚ü∂ ùüô_ C\n  /-- The comultiplication morphism of a comonoid object. -/\n  comul : X ‚ü∂ X ‚äó X\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `X` is explicit. -/\n  counit_comul' : comul ‚â´ counit ‚ñ∑ X = (Œª_ X).inv := by aesop_cat\n  comul_counit' : comul ‚â´ X ‚óÅ counit = (œÅ_ X).inv := by aesop_cat\n  comul_assoc' : comul ‚â´ X ‚óÅ comul = comul ‚â´ (comul ‚ñ∑ X) ‚â´ (Œ±_ X X X).hom := by aesop_cat\n\n"}
{"name":"Comon_Class.counit_comul'","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\nself : Comon_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.MonoidalCategoryStruct.whiskerRight Comon_Class.counit X)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv","decl":"/-- A comonoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called a \"coalgebra object\".\n-/\nclass Comon_Class (X : C) where\n  /-- The counit morphism of a comonoid object. -/\n  counit : X ‚ü∂ ùüô_ C\n  /-- The comultiplication morphism of a comonoid object. -/\n  comul : X ‚ü∂ X ‚äó X\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `X` is explicit. -/\n  counit_comul' : comul ‚â´ counit ‚ñ∑ X = (Œª_ X).inv := by aesop_cat\n  comul_counit' : comul ‚â´ X ‚óÅ counit = (œÅ_ X).inv := by aesop_cat\n  comul_assoc' : comul ‚â´ X ‚óÅ comul = comul ‚â´ (comul ‚ñ∑ X) ‚â´ (Œ±_ X X X).hom := by aesop_cat\n\n"}
{"name":"Comon_Class.comul_counit'","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\nself : Comon_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Comon_Class.counit)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv","decl":"/-- A comonoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called a \"coalgebra object\".\n-/\nclass Comon_Class (X : C) where\n  /-- The counit morphism of a comonoid object. -/\n  counit : X ‚ü∂ ùüô_ C\n  /-- The comultiplication morphism of a comonoid object. -/\n  comul : X ‚ü∂ X ‚äó X\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `X` is explicit. -/\n  counit_comul' : comul ‚â´ counit ‚ñ∑ X = (Œª_ X).inv := by aesop_cat\n  comul_counit' : comul ‚â´ X ‚óÅ counit = (œÅ_ X).inv := by aesop_cat\n  comul_assoc' : comul ‚â´ X ‚óÅ comul = comul ‚â´ (comul ‚ñ∑ X) ‚â´ (Œ±_ X X X).hom := by aesop_cat\n\n"}
{"name":"Comon_Class.comul_assoc'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\nself : Comon_Class X\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj X X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Comon_Class.comul) h)) (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Comon_Class.comul X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom h)))","decl":"attribute [reassoc] counit_comul' comul_counit' comul_assoc'\n\n"}
{"name":"Comon_Class.counit_comul'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\nself : Comon_Class X\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Comon_Class.counit X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv h)","decl":"attribute [reassoc] counit_comul' comul_counit' comul_assoc'\n\n"}
{"name":"Comon_Class.comul_counit'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\nself : Comon_Class X\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Comon_Class.counit) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv h)","decl":"attribute [reassoc] counit_comul' comul_counit' comul_assoc'\n\n"}
{"name":"Comon_Class.counit_comul","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Comon_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.MonoidalCategoryStruct.whiskerRight Comon_Class.counit X)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv","decl":"@[reassoc (attr := simp)]\ntheorem counit_comul (X : C) [Comon_Class X] : Œî ‚â´ Œµ ‚ñ∑ X = (Œª_ X).inv := counit_comul'\n\n"}
{"name":"Comon_Class.counit_comul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Comon_Class X\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Comon_Class.counit X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv h)","decl":"@[reassoc (attr := simp)]\ntheorem counit_comul (X : C) [Comon_Class X] : Œî ‚â´ Œµ ‚ñ∑ X = (Œª_ X).inv := counit_comul'\n\n"}
{"name":"Comon_Class.comul_counit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Comon_Class X\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Comon_Class.counit) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv h)","decl":"@[reassoc (attr := simp)]\ntheorem comul_counit (X : C) [Comon_Class X] : Œî ‚â´ X ‚óÅ Œµ = (œÅ_ X).inv := comul_counit'\n\n"}
{"name":"Comon_Class.comul_counit","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Comon_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Comon_Class.counit)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv","decl":"@[reassoc (attr := simp)]\ntheorem comul_counit (X : C) [Comon_Class X] : Œî ‚â´ X ‚óÅ Œµ = (œÅ_ X).inv := comul_counit'\n\n"}
{"name":"Comon_Class.comul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Comon_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Comon_Class.comul)) (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Comon_Class.comul X) (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom))","decl":"@[reassoc (attr := simp)]\ntheorem comul_assoc (X : C) [Comon_Class X] :\n    Œî ‚â´ X ‚óÅ Œî = Œî ‚â´ Œî ‚ñ∑ X ‚â´ (Œ±_ X X X).hom :=\n  comul_assoc'\n\n"}
{"name":"Comon_Class.comul_assoc_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Comon_Class X\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj X X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Comon_Class.comul) h)) (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Comon_Class.comul X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom h)))","decl":"@[reassoc (attr := simp)]\ntheorem comul_assoc (X : C) [Comon_Class X] :\n    Œî ‚â´ X ‚óÅ Œî = Œî ‚â´ Œî ‚ñ∑ X ‚â´ (Œ±_ X X X).hom :=\n  comul_assoc'\n\n"}
{"name":"IsComon_Hom.hom_comul","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nM N : C\ninst‚úù¬π : Comon_Class M\ninst‚úù : Comon_Class N\nf : Quiver.Hom M N\nself : IsComon_Hom f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f Comon_Class.comul) (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.MonoidalCategoryStruct.tensorHom f f))","decl":"/-- The property that a morphism between comonoid objects is a comonoid morphism. -/\nclass IsComon_Hom (f : M ‚ü∂ N) : Prop where\n  hom_counit : f ‚â´ Œµ = Œµ := by aesop_cat\n  hom_comul : f ‚â´ Œî = Œî ‚â´ (f ‚äó f) := by aesop_cat\n\n"}
{"name":"IsComon_Hom.hom_counit","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nM N : C\ninst‚úù¬π : Comon_Class M\ninst‚úù : Comon_Class N\nf : Quiver.Hom M N\nself : IsComon_Hom f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f Comon_Class.counit) Comon_Class.counit","decl":"/-- The property that a morphism between comonoid objects is a comonoid morphism. -/\nclass IsComon_Hom (f : M ‚ü∂ N) : Prop where\n  hom_counit : f ‚â´ Œµ = Œµ := by aesop_cat\n  hom_comul : f ‚â´ Œî = Œî ‚â´ (f ‚äó f) := by aesop_cat\n\n"}
{"name":"IsComon_Hom.hom_comul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nM N : C\ninst‚úù¬π : Comon_Class M\ninst‚úù : Comon_Class N\nf : Quiver.Hom M N\nself : IsComon_Hom f\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj N N) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp Comon_Class.comul h)) (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f f) h))","decl":"attribute [reassoc (attr := simp)] IsComon_Hom.hom_counit IsComon_Hom.hom_comul\n\n"}
{"name":"IsComon_Hom.hom_counit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\nM N : C\ninst‚úù¬π : Comon_Class M\ninst‚úù : Comon_Class N\nf : Quiver.Hom M N\nself : IsComon_Hom f\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)) (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)","decl":"attribute [reassoc (attr := simp)] IsComon_Hom.hom_counit IsComon_Hom.hom_comul\n\n"}
{"name":"Comon_.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : C\ncounit‚úù : Quiver.Hom X‚úù CategoryTheory.MonoidalCategoryStruct.tensorUnit\ncomul‚úù : Quiver.Hom X‚úù (CategoryTheory.MonoidalCategoryStruct.tensorObj X‚úù X‚úù)\ncounit_comul‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul‚úù (CategoryTheory.MonoidalCategoryStruct.whiskerRight counit‚úù X‚úù)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X‚úù).inv) _auto‚úù\ncomul_counit‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul‚úù (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X‚úù counit‚úù)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X‚úù).inv) _auto‚úù\ncomul_assoc‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul‚úù (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X‚úù comul‚úù)) (CategoryTheory.CategoryStruct.comp comul‚úù (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight comul‚úù X‚úù) (CategoryTheory.MonoidalCategoryStruct.associator X‚úù X‚úù X‚úù).hom))) _auto‚úù\nX : C\ncounit : Quiver.Hom X CategoryTheory.MonoidalCategoryStruct.tensorUnit\ncomul : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj X X)\ncounit_comul : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul (CategoryTheory.MonoidalCategoryStruct.whiskerRight counit X)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) _auto‚úù\ncomul_counit : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X counit)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) _auto‚úù\ncomul_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X comul)) (CategoryTheory.CategoryStruct.comp comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight comul X) (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom))) _auto‚úù\n‚ä¢ Eq (Eq { X := X‚úù, counit := counit‚úù, comul := comul‚úù, counit_comul := counit_comul‚úù, comul_counit := comul_counit‚úù, comul_assoc := comul_assoc‚úù } { X := X, counit := counit, comul := comul, counit_comul := counit_comul, comul_counit := comul_counit, comul_assoc := comul_assoc }) (And (Eq X‚úù X) (And (HEq counit‚úù counit) (HEq comul‚úù comul)))","decl":"/-- A comonoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called a \"coalgebra object\".\n-/\nstructure Comon_ where\n  /-- The underlying object of a comonoid object. -/\n  X : C\n  /-- The counit of a comonoid object. -/\n  counit : X ‚ü∂ ùüô_ C\n  /-- The comultiplication morphism of a comonoid object. -/\n  comul : X ‚ü∂ X ‚äó X\n  counit_comul : comul ‚â´ (counit ‚ñ∑ X) = (Œª_ X).inv := by aesop_cat\n  comul_counit : comul ‚â´ (X ‚óÅ counit) = (œÅ_ X).inv := by aesop_cat\n  comul_assoc : comul ‚â´ (X ‚óÅ comul) = comul ‚â´ (comul ‚ñ∑ X) ‚â´ (Œ±_ X X X).hom := by aesop_cat\n\n"}
{"name":"Comon_.comul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : Comon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.comul (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X self.comul)) (CategoryTheory.CategoryStruct.comp self.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.comul self.X) (CategoryTheory.MonoidalCategoryStruct.associator self.X self.X self.X).hom))","decl":"/-- A comonoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called a \"coalgebra object\".\n-/\nstructure Comon_ where\n  /-- The underlying object of a comonoid object. -/\n  X : C\n  /-- The counit of a comonoid object. -/\n  counit : X ‚ü∂ ùüô_ C\n  /-- The comultiplication morphism of a comonoid object. -/\n  comul : X ‚ü∂ X ‚äó X\n  counit_comul : comul ‚â´ (counit ‚ñ∑ X) = (Œª_ X).inv := by aesop_cat\n  comul_counit : comul ‚â´ (X ‚óÅ counit) = (œÅ_ X).inv := by aesop_cat\n  comul_assoc : comul ‚â´ (X ‚óÅ comul) = comul ‚â´ (comul ‚ñ∑ X) ‚â´ (Œ±_ X X X).hom := by aesop_cat\n\n"}
{"name":"Comon_.counit_comul","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : Comon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.comul (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.counit self.X)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor self.X).inv","decl":"/-- A comonoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called a \"coalgebra object\".\n-/\nstructure Comon_ where\n  /-- The underlying object of a comonoid object. -/\n  X : C\n  /-- The counit of a comonoid object. -/\n  counit : X ‚ü∂ ùüô_ C\n  /-- The comultiplication morphism of a comonoid object. -/\n  comul : X ‚ü∂ X ‚äó X\n  counit_comul : comul ‚â´ (counit ‚ñ∑ X) = (Œª_ X).inv := by aesop_cat\n  comul_counit : comul ‚â´ (X ‚óÅ counit) = (œÅ_ X).inv := by aesop_cat\n  comul_assoc : comul ‚â´ (X ‚óÅ comul) = comul ‚â´ (comul ‚ñ∑ X) ‚â´ (Œ±_ X X X).hom := by aesop_cat\n\n"}
{"name":"Comon_.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : SizeOf C\nX : C\ncounit : Quiver.Hom X CategoryTheory.MonoidalCategoryStruct.tensorUnit\ncomul : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj X X)\ncounit_comul : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul (CategoryTheory.MonoidalCategoryStruct.whiskerRight counit X)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) _auto‚úù\ncomul_counit : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X counit)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) _auto‚úù\ncomul_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X comul)) (CategoryTheory.CategoryStruct.comp comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight comul X) (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { X := X, counit := counit, comul := comul, counit_comul := counit_comul, comul_counit := comul_counit, comul_assoc := comul_assoc }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf counit)) (SizeOf.sizeOf comul)) (SizeOf.sizeOf counit_comul)) (SizeOf.sizeOf comul_counit)) (SizeOf.sizeOf comul_assoc))","decl":"/-- A comonoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called a \"coalgebra object\".\n-/\nstructure Comon_ where\n  /-- The underlying object of a comonoid object. -/\n  X : C\n  /-- The counit of a comonoid object. -/\n  counit : X ‚ü∂ ùüô_ C\n  /-- The comultiplication morphism of a comonoid object. -/\n  comul : X ‚ü∂ X ‚äó X\n  counit_comul : comul ‚â´ (counit ‚ñ∑ X) = (Œª_ X).inv := by aesop_cat\n  comul_counit : comul ‚â´ (X ‚óÅ counit) = (œÅ_ X).inv := by aesop_cat\n  comul_assoc : comul ‚â´ (X ‚óÅ comul) = comul ‚â´ (comul ‚ñ∑ X) ‚â´ (Œ±_ X X X).hom := by aesop_cat\n\n"}
{"name":"Comon_.comul_counit","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : Comon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.comul (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X self.counit)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor self.X).inv","decl":"/-- A comonoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called a \"coalgebra object\".\n-/\nstructure Comon_ where\n  /-- The underlying object of a comonoid object. -/\n  X : C\n  /-- The counit of a comonoid object. -/\n  counit : X ‚ü∂ ùüô_ C\n  /-- The comultiplication morphism of a comonoid object. -/\n  comul : X ‚ü∂ X ‚äó X\n  counit_comul : comul ‚â´ (counit ‚ñ∑ X) = (Œª_ X).inv := by aesop_cat\n  comul_counit : comul ‚â´ (X ‚óÅ counit) = (œÅ_ X).inv := by aesop_cat\n  comul_assoc : comul ‚â´ (X ‚óÅ comul) = comul ‚â´ (comul ‚ñ∑ X) ‚â´ (Œ±_ X X X).hom := by aesop_cat\n\n"}
{"name":"Comon_.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù : C\ncounit‚úù : Quiver.Hom X‚úù CategoryTheory.MonoidalCategoryStruct.tensorUnit\ncomul‚úù : Quiver.Hom X‚úù (CategoryTheory.MonoidalCategoryStruct.tensorObj X‚úù X‚úù)\ncounit_comul‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul‚úù (CategoryTheory.MonoidalCategoryStruct.whiskerRight counit‚úù X‚úù)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X‚úù).inv) _auto‚úù\ncomul_counit‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul‚úù (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X‚úù counit‚úù)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X‚úù).inv) _auto‚úù\ncomul_assoc‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul‚úù (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X‚úù comul‚úù)) (CategoryTheory.CategoryStruct.comp comul‚úù (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight comul‚úù X‚úù) (CategoryTheory.MonoidalCategoryStruct.associator X‚úù X‚úù X‚úù).hom))) _auto‚úù\nX : C\ncounit : Quiver.Hom X CategoryTheory.MonoidalCategoryStruct.tensorUnit\ncomul : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj X X)\ncounit_comul : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul (CategoryTheory.MonoidalCategoryStruct.whiskerRight counit X)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv) _auto‚úù\ncomul_counit : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X counit)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv) _auto‚úù\ncomul_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp comul (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X comul)) (CategoryTheory.CategoryStruct.comp comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight comul X) (CategoryTheory.MonoidalCategoryStruct.associator X X X).hom))) _auto‚úù\nx‚úù : Eq { X := X‚úù, counit := counit‚úù, comul := comul‚úù, counit_comul := counit_comul‚úù, comul_counit := comul_counit‚úù, comul_assoc := comul_assoc‚úù } { X := X, counit := counit, comul := comul, counit_comul := counit_comul, comul_counit := comul_counit, comul_assoc := comul_assoc }\n‚ä¢ And (Eq X‚úù X) (And (HEq counit‚úù counit) (HEq comul‚úù comul))","decl":"/-- A comonoid object internal to a monoidal category.\n\nWhen the monoidal category is preadditive, this is also sometimes called a \"coalgebra object\".\n-/\nstructure Comon_ where\n  /-- The underlying object of a comonoid object. -/\n  X : C\n  /-- The counit of a comonoid object. -/\n  counit : X ‚ü∂ ùüô_ C\n  /-- The comultiplication morphism of a comonoid object. -/\n  comul : X ‚ü∂ X ‚äó X\n  counit_comul : comul ‚â´ (counit ‚ñ∑ X) = (Œª_ X).inv := by aesop_cat\n  comul_counit : comul ‚â´ (X ‚óÅ counit) = (œÅ_ X).inv := by aesop_cat\n  comul_assoc : comul ‚â´ (X ‚óÅ comul) = comul ‚â´ (comul ‚ñ∑ X) ‚â´ (Œ±_ X X X).hom := by aesop_cat\n\n"}
{"name":"Comon_.counit_comul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : Comon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit self.X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.counit self.X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor self.X).inv h)","decl":"attribute [reassoc (attr := simp)] Comon_.counit_comul Comon_.comul_counit\n\n"}
{"name":"Comon_.comul_counit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : Comon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj self.X CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X self.counit) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor self.X).inv h)","decl":"attribute [reassoc (attr := simp)] Comon_.counit_comul Comon_.comul_counit\n\n"}
{"name":"Comon_.comul_assoc_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : Comon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj self.X (CategoryTheory.MonoidalCategoryStruct.tensorObj self.X self.X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X self.comul) h)) (CategoryTheory.CategoryStruct.comp self.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.comul self.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator self.X self.X self.X).hom h)))","decl":"attribute [reassoc (attr := simp)] Comon_.comul_assoc\n\n"}
{"name":"Comon_.mk'_X","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Comon_Class X\n‚ä¢ Eq (Comon_.mk' X).X X","decl":"/-- Construct an object of `Comon_ C` from an object `X : C` and `Comon_Class X` instance. -/\n@[simps]\ndef mk' (X : C) [Comon_Class X] : Comon_ C where\n  X := X\n  counit := Œµ\n  comul := Œî\n\n"}
{"name":"Comon_.mk'_comul","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Comon_Class X\n‚ä¢ Eq (Comon_.mk' X).comul Comon_Class.comul","decl":"/-- Construct an object of `Comon_ C` from an object `X : C` and `Comon_Class X` instance. -/\n@[simps]\ndef mk' (X : C) [Comon_Class X] : Comon_ C where\n  X := X\n  counit := Œµ\n  comul := Œî\n\n"}
{"name":"Comon_.mk'_counit","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nX : C\ninst‚úù : Comon_Class X\n‚ä¢ Eq (Comon_.mk' X).counit Comon_Class.counit","decl":"/-- Construct an object of `Comon_ C` from an object `X : C` and `Comon_Class X` instance. -/\n@[simps]\ndef mk' (X : C) [Comon_Class X] : Comon_ C where\n  X := X\n  counit := Œµ\n  comul := Œî\n\n"}
{"name":"Comon_.trivial_counit","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Comon_.trivial C).counit (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/-- The trivial comonoid object. We later show this is terminal in `Comon_ C`.\n-/\n@[simps]\ndef trivial : Comon_ C where\n  X := ùüô_ C\n  counit := ùüô _\n  comul := (Œª_ _).inv\n  comul_assoc := by monoidal_coherence\n  counit_comul := by monoidal_coherence\n  comul_counit := by monoidal_coherence\n\n"}
{"name":"Comon_.trivial_comul","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Comon_.trivial C).comul (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv","decl":"/-- The trivial comonoid object. We later show this is terminal in `Comon_ C`.\n-/\n@[simps]\ndef trivial : Comon_ C where\n  X := ùüô_ C\n  counit := ùüô _\n  comul := (Œª_ _).inv\n  comul_assoc := by monoidal_coherence\n  counit_comul := by monoidal_coherence\n  comul_counit := by monoidal_coherence\n\n"}
{"name":"Comon_.trivial_X","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Comon_.trivial C).X CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"/-- The trivial comonoid object. We later show this is terminal in `Comon_ C`.\n-/\n@[simps]\ndef trivial : Comon_ C where\n  X := ùüô_ C\n  counit := ùüô _\n  comul := (Œª_ _).inv\n  comul_assoc := by monoidal_coherence\n  counit_comul := by monoidal_coherence\n  comul_counit := by monoidal_coherence\n\n"}
{"name":"Comon_.counit_comul_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Comon_ C\nZ : C\nf : Quiver.Hom M.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.MonoidalCategoryStruct.tensorHom M.counit f)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.MonoidalCategoryStruct.leftUnitor Z).inv)","decl":"@[reassoc (attr := simp)]\ntheorem counit_comul_hom {Z : C} (f : M.X ‚ü∂ Z) : M.comul ‚â´ (M.counit ‚äó f) = f ‚â´ (Œª_ Z).inv := by\n  rw [leftUnitor_inv_naturality, tensorHom_def, counit_comul_assoc]\n\n"}
{"name":"Comon_.counit_comul_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Comon_ C\nZ‚úù : C\nf : Quiver.Hom M.X Z‚úù\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.counit f) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor Z‚úù).inv h))","decl":"@[reassoc (attr := simp)]\ntheorem counit_comul_hom {Z : C} (f : M.X ‚ü∂ Z) : M.comul ‚â´ (M.counit ‚äó f) = f ‚â´ (Œª_ Z).inv := by\n  rw [leftUnitor_inv_naturality, tensorHom_def, counit_comul_assoc]\n\n"}
{"name":"Comon_.comul_counit_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Comon_ C\nZ : C\nf : Quiver.Hom M.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.MonoidalCategoryStruct.tensorHom f M.counit)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.MonoidalCategoryStruct.rightUnitor Z).inv)","decl":"@[reassoc (attr := simp)]\ntheorem comul_counit_hom {Z : C} (f : M.X ‚ü∂ Z) : M.comul ‚â´ (f ‚äó M.counit) = f ‚â´ (œÅ_ Z).inv := by\n  rw [rightUnitor_inv_naturality, tensorHom_def', comul_counit_assoc]\n\n"}
{"name":"Comon_.comul_counit_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Comon_ C\nZ‚úù : C\nf : Quiver.Hom M.X Z‚úù\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z‚úù CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f M.counit) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor Z‚úù).inv h))","decl":"@[reassoc (attr := simp)]\ntheorem comul_counit_hom {Z : C} (f : M.X ‚ü∂ Z) : M.comul ‚â´ (f ‚äó M.counit) = f ‚â´ (œÅ_ Z).inv := by\n  rw [rightUnitor_inv_naturality, tensorHom_def', comul_counit_assoc]\n\n"}
{"name":"Comon_.comul_assoc_flip_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Comon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X M.X) M.X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.comul M.X) h)) (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X M.comul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X M.X M.X).inv h)))","decl":"@[reassoc] theorem comul_assoc_flip :\n    M.comul ‚â´ (M.comul ‚ñ∑ M.X) = M.comul ‚â´ (M.X ‚óÅ M.comul) ‚â´ (Œ±_ M.X M.X M.X).inv := by\n  simp\n\n"}
{"name":"Comon_.comul_assoc_flip","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Comon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.comul M.X)) (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X M.comul) (CategoryTheory.MonoidalCategoryStruct.associator M.X M.X M.X).inv))","decl":"@[reassoc] theorem comul_assoc_flip :\n    M.comul ‚â´ (M.comul ‚ñ∑ M.X) = M.comul ‚â´ (M.X ‚óÅ M.comul) ‚â´ (Œ±_ M.X M.X M.X).inv := by\n  simp\n\n"}
{"name":"Comon_.Hom.ext","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Comon_ C\nx y : M.Hom N\nhom : Eq x.hom y.hom\n‚ä¢ Eq x y","decl":"/-- A morphism of comonoid objects. -/\n@[ext]\nstructure Hom (M N : Comon_ C) where\n  /-- The underlying morphism of a morphism of comonoid objects. -/\n  hom : M.X ‚ü∂ N.X\n  hom_counit : hom ‚â´ N.counit = M.counit := by aesop_cat\n  hom_comul : hom ‚â´ N.comul = M.comul ‚â´ (hom ‚äó hom) := by aesop_cat\n\n"}
{"name":"Comon_.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Comon_ C\nhom‚úù : Quiver.Hom M.X N.X\nhom_counit‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom‚úù N.counit) M.counit) _auto‚úù\nhom_comul‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom‚úù N.comul) (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.MonoidalCategoryStruct.tensorHom hom‚úù hom‚úù))) _auto‚úù\nhom : Quiver.Hom M.X N.X\nhom_counit : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom N.counit) M.counit) _auto‚úù\nhom_comul : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom N.comul) (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.MonoidalCategoryStruct.tensorHom hom hom))) _auto‚úù\n‚ä¢ Eq (Eq { hom := hom‚úù, hom_counit := hom_counit‚úù, hom_comul := hom_comul‚úù } { hom := hom, hom_counit := hom_counit, hom_comul := hom_comul }) (Eq hom‚úù hom)","decl":"/-- A morphism of comonoid objects. -/\n@[ext]\nstructure Hom (M N : Comon_ C) where\n  /-- The underlying morphism of a morphism of comonoid objects. -/\n  hom : M.X ‚ü∂ N.X\n  hom_counit : hom ‚â´ N.counit = M.counit := by aesop_cat\n  hom_comul : hom ‚â´ N.comul = M.comul ‚â´ (hom ‚äó hom) := by aesop_cat\n\n"}
{"name":"Comon_.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\nM N : Comon_ C\ninst‚úù : SizeOf C\nhom : Quiver.Hom M.X N.X\nhom_counit : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom N.counit) M.counit) _auto‚úù\nhom_comul : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom N.comul) (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.MonoidalCategoryStruct.tensorHom hom hom))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { hom := hom, hom_counit := hom_counit, hom_comul := hom_comul }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf hom)) (SizeOf.sizeOf hom_counit)) (SizeOf.sizeOf hom_comul))","decl":"/-- A morphism of comonoid objects. -/\n@[ext]\nstructure Hom (M N : Comon_ C) where\n  /-- The underlying morphism of a morphism of comonoid objects. -/\n  hom : M.X ‚ü∂ N.X\n  hom_counit : hom ‚â´ N.counit = M.counit := by aesop_cat\n  hom_comul : hom ‚â´ N.comul = M.comul ‚â´ (hom ‚äó hom) := by aesop_cat\n\n"}
{"name":"Comon_.Hom.hom_counit","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Comon_ C\nself : M.Hom N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.hom N.counit) M.counit","decl":"/-- A morphism of comonoid objects. -/\n@[ext]\nstructure Hom (M N : Comon_ C) where\n  /-- The underlying morphism of a morphism of comonoid objects. -/\n  hom : M.X ‚ü∂ N.X\n  hom_counit : hom ‚â´ N.counit = M.counit := by aesop_cat\n  hom_comul : hom ‚â´ N.comul = M.comul ‚â´ (hom ‚äó hom) := by aesop_cat\n\n"}
{"name":"Comon_.Hom.hom_comul","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Comon_ C\nself : M.Hom N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.hom N.comul) (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.MonoidalCategoryStruct.tensorHom self.hom self.hom))","decl":"/-- A morphism of comonoid objects. -/\n@[ext]\nstructure Hom (M N : Comon_ C) where\n  /-- The underlying morphism of a morphism of comonoid objects. -/\n  hom : M.X ‚ü∂ N.X\n  hom_counit : hom ‚â´ N.counit = M.counit := by aesop_cat\n  hom_comul : hom ‚â´ N.comul = M.comul ‚â´ (hom ‚äó hom) := by aesop_cat\n\n"}
{"name":"Comon_.Hom.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Comon_ C\nx y : M.Hom N\n‚ä¢ Iff (Eq x y) (Eq x.hom y.hom)","decl":"/-- A morphism of comonoid objects. -/\n@[ext]\nstructure Hom (M N : Comon_ C) where\n  /-- The underlying morphism of a morphism of comonoid objects. -/\n  hom : M.X ‚ü∂ N.X\n  hom_counit : hom ‚â´ N.counit = M.counit := by aesop_cat\n  hom_comul : hom ‚â´ N.comul = M.comul ‚â´ (hom ‚äó hom) := by aesop_cat\n\n"}
{"name":"Comon_.Hom.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Comon_ C\nhom‚úù : Quiver.Hom M.X N.X\nhom_counit‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom‚úù N.counit) M.counit) _auto‚úù\nhom_comul‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom‚úù N.comul) (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.MonoidalCategoryStruct.tensorHom hom‚úù hom‚úù))) _auto‚úù\nhom : Quiver.Hom M.X N.X\nhom_counit : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom N.counit) M.counit) _auto‚úù\nhom_comul : autoParam (Eq (CategoryTheory.CategoryStruct.comp hom N.comul) (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.MonoidalCategoryStruct.tensorHom hom hom))) _auto‚úù\nx‚úù : Eq { hom := hom‚úù, hom_counit := hom_counit‚úù, hom_comul := hom_comul‚úù } { hom := hom, hom_counit := hom_counit, hom_comul := hom_comul }\n‚ä¢ Eq hom‚úù hom","decl":"/-- A morphism of comonoid objects. -/\n@[ext]\nstructure Hom (M N : Comon_ C) where\n  /-- The underlying morphism of a morphism of comonoid objects. -/\n  hom : M.X ‚ü∂ N.X\n  hom_counit : hom ‚â´ N.counit = M.counit := by aesop_cat\n  hom_comul : hom ‚â´ N.comul = M.comul ‚â´ (hom ‚äó hom) := by aesop_cat\n\n"}
{"name":"Comon_.Hom.hom_counit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Comon_ C\nself : M.Hom N\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp N.counit h)) (CategoryTheory.CategoryStruct.comp M.counit h)","decl":"attribute [reassoc (attr := simp)] Hom.hom_counit Hom.hom_comul\n\n"}
{"name":"Comon_.Hom.hom_comul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Comon_ C\nself : M.Hom N\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj N.X N.X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp N.comul h)) (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom self.hom self.hom) h))","decl":"attribute [reassoc (attr := simp)] Hom.hom_counit Hom.hom_comul\n\n"}
{"name":"Comon_.id_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Comon_ C\n‚ä¢ Eq M.id.hom (CategoryTheory.CategoryStruct.id M.X)","decl":"/-- The identity morphism on a comonoid object. -/\n@[simps]\ndef id (M : Comon_ C) : Hom M M where\n  hom := ùüô M.X\n\n"}
{"name":"Comon_.comp_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N O : Comon_ C\nf : M.Hom N\ng : N.Hom O\n‚ä¢ Eq (Comon_.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"/-- Composition of morphisms of monoid objects. -/\n@[simps]\ndef comp {M N O : Comon_ C} (f : Hom M N) (g : Hom N O) : Hom M O where\n  hom := f.hom ‚â´ g.hom\n\n"}
{"name":"Comon_.ext","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : Comon_ C\nf g : Quiver.Hom X Y\nw : Eq f.hom g.hom\n‚ä¢ Eq f g","decl":"@[ext] lemma ext {X Y : Comon_ C} {f g : X ‚ü∂ Y} (w : f.hom = g.hom) : f = g := Hom.ext w\n\n"}
{"name":"Comon_.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX Y : Comon_ C\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext] lemma ext {X Y : Comon_ C} {f g : X ‚ü∂ Y} (w : f.hom = g.hom) : f = g := Hom.ext w\n\n"}
{"name":"Comon_.id_hom'","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM : Comon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id M).hom (CategoryTheory.CategoryStruct.id M.X)","decl":"@[simp] theorem id_hom' (M : Comon_ C) : (ùüô M : Hom M M).hom = ùüô M.X := rfl\n\n"}
{"name":"Comon_.comp_hom'","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N K : Comon_ C\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simp]\ntheorem comp_hom' {M N K : Comon_ C} (f : M ‚ü∂ N) (g : N ‚ü∂ K) : (f ‚â´ g).hom = f.hom ‚â´ g.hom :=\n  rfl\n\n"}
{"name":"Comon_.forget_map","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù Y‚úù : Comon_ C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Comon_.forget C).map f) f.hom","decl":"/-- The forgetful functor from comonoid objects to the ambient category. -/\n@[simps]\ndef forget : Comon_ C ‚•§ C where\n  obj A := A.X\n  map f := f.hom\n\n"}
{"name":"Comon_.forget_obj","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Comon_ C\n‚ä¢ Eq ((Comon_.forget C).obj A) A.X","decl":"/-- The forgetful functor from comonoid objects to the ambient category. -/\n@[simps]\ndef forget : Comon_ C ‚•§ C where\n  obj A := A.X\n  map f := f.hom\n\n"}
{"name":"Comon_.forget_faithful","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ (Comon_.forget C).Faithful","decl":"instance forget_faithful : (@forget C _ _).Faithful where\n\n"}
{"name":"Comon_.instIsIsoHomOfMapForget","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA B : Comon_ C\nf : Quiver.Hom A B\ne : CategoryTheory.IsIso ((Comon_.forget C).map f)\n‚ä¢ CategoryTheory.IsIso f.hom","decl":"instance {A B : Comon_ C} (f : A ‚ü∂ B) [e : IsIso ((forget C).map f)] : IsIso f.hom := e\n\n"}
{"name":"Comon_.instReflectsIsomorphismsForget","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ (Comon_.forget C).ReflectsIsomorphisms","decl":"/-- The forgetful functor from comonoid objects to the ambient category reflects isomorphisms. -/\ninstance : (forget C).ReflectsIsomorphisms where\n  reflects f e :=\n    ‚ü®‚ü®{ hom := inv f.hom }, by aesop_cat‚ü©‚ü©\n\n"}
{"name":"Comon_.mkIso_hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Comon_ C\nf : CategoryTheory.Iso M.X N.X\nf_counit : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom N.counit) M.counit) _auto‚úù\nf_comul : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom N.comul) (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom f.hom))) _auto‚úù\n‚ä¢ Eq (Comon_.mkIso f f_counit f_comul).hom.hom f.hom","decl":"/-- Construct an isomorphism of comonoids by giving an isomorphism between the underlying objects\nand checking compatibility with counit and comultiplication only in the forward direction.\n-/\n@[simps]\ndef mkIso {M N : Comon_ C} (f : M.X ‚âÖ N.X) (f_counit : f.hom ‚â´ N.counit = M.counit := by aesop_cat)\n    (f_comul : f.hom ‚â´ N.comul = M.comul ‚â´ (f.hom ‚äó f.hom) := by aesop_cat) : M ‚âÖ N where\n  hom :=\n    { hom := f.hom\n      hom_counit := f_counit\n      hom_comul := f_comul }\n  inv :=\n    { hom := f.inv\n      hom_counit := by rw [‚Üê f_counit]; simp\n      hom_comul := by\n        rw [‚Üê cancel_epi f.hom]\n        slice_rhs 1 2 => rw [f_comul]\n        simp }\n\n"}
{"name":"Comon_.mkIso_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nM N : Comon_ C\nf : CategoryTheory.Iso M.X N.X\nf_counit : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom N.counit) M.counit) _auto‚úù\nf_comul : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom N.comul) (CategoryTheory.CategoryStruct.comp M.comul (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom f.hom))) _auto‚úù\n‚ä¢ Eq (Comon_.mkIso f f_counit f_comul).inv.hom f.inv","decl":"/-- Construct an isomorphism of comonoids by giving an isomorphism between the underlying objects\nand checking compatibility with counit and comultiplication only in the forward direction.\n-/\n@[simps]\ndef mkIso {M N : Comon_ C} (f : M.X ‚âÖ N.X) (f_counit : f.hom ‚â´ N.counit = M.counit := by aesop_cat)\n    (f_comul : f.hom ‚â´ N.comul = M.comul ‚â´ (f.hom ‚äó f.hom) := by aesop_cat) : M ‚âÖ N where\n  hom :=\n    { hom := f.hom\n      hom_counit := f_counit\n      hom_comul := f_comul }\n  inv :=\n    { hom := f.inv\n      hom_counit := by rw [‚Üê f_counit]; simp\n      hom_comul := by\n        rw [‚Üê cancel_epi f.hom]\n        slice_rhs 1 2 => rw [f_comul]\n        simp }\n\n"}
{"name":"Comon_.uniqueHomToTrivial_default_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Comon_ C\n‚ä¢ Eq Inhabited.default.hom A.counit","decl":"@[simps]\ninstance uniqueHomToTrivial (A : Comon_ C) : Unique (A ‚ü∂ trivial C) where\n  default :=\n    { hom := A.counit\n      hom_comul := by simp [A.comul_counit, unitors_inv_equal] }\n  uniq f := by\n    ext; simp\n    rw [‚Üê Category.comp_id f.hom]\n    erw [f.hom_counit]\n\n"}
{"name":"Comon_.instHasTerminal","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ CategoryTheory.Limits.HasTerminal (Comon_ C)","decl":"instance : HasTerminal (Comon_ C) :=\n  hasTerminal_of_unique (trivial C)\n\n"}
{"name":"Comon_.Comon_ToMon_OpOp_obj'_one","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Comon_ C\n‚ä¢ Eq (Comon_.Comon_ToMon_OpOp_obj' C A).one A.counit.op","decl":"/--\nTurn a comonoid object into a monoid object in the opposite category.\n-/\n@[simps] def Comon_ToMon_OpOp_obj' (A : Comon_ C) : Mon_ (C·µí·µñ) where\n  X := op A.X\n  one := A.counit.op\n  mul := A.comul.op\n  one_mul := by\n    rw [‚Üê op_whiskerRight, ‚Üê op_comp, counit_comul]\n    rfl\n  mul_one := by\n    rw [‚Üê op_whiskerLeft, ‚Üê op_comp, comul_counit]\n    rfl\n  mul_assoc := by\n    rw [‚Üê op_inv_associator, ‚Üê op_whiskerRight, ‚Üê op_comp, ‚Üê op_whiskerLeft, ‚Üê op_comp,\n      comul_assoc_flip, op_comp, op_comp_assoc]\n    rfl\n\n"}
{"name":"Comon_.Comon_ToMon_OpOp_obj'_X","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Comon_ C\n‚ä¢ Eq (Comon_.Comon_ToMon_OpOp_obj' C A).X { unop := A.X }","decl":"/--\nTurn a comonoid object into a monoid object in the opposite category.\n-/\n@[simps] def Comon_ToMon_OpOp_obj' (A : Comon_ C) : Mon_ (C·µí·µñ) where\n  X := op A.X\n  one := A.counit.op\n  mul := A.comul.op\n  one_mul := by\n    rw [‚Üê op_whiskerRight, ‚Üê op_comp, counit_comul]\n    rfl\n  mul_one := by\n    rw [‚Üê op_whiskerLeft, ‚Üê op_comp, comul_counit]\n    rfl\n  mul_assoc := by\n    rw [‚Üê op_inv_associator, ‚Üê op_whiskerRight, ‚Üê op_comp, ‚Üê op_whiskerLeft, ‚Üê op_comp,\n      comul_assoc_flip, op_comp, op_comp_assoc]\n    rfl\n\n"}
{"name":"Comon_.Comon_ToMon_OpOp_obj'_mul","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Comon_ C\n‚ä¢ Eq (Comon_.Comon_ToMon_OpOp_obj' C A).mul A.comul.op","decl":"/--\nTurn a comonoid object into a monoid object in the opposite category.\n-/\n@[simps] def Comon_ToMon_OpOp_obj' (A : Comon_ C) : Mon_ (C·µí·µñ) where\n  X := op A.X\n  one := A.counit.op\n  mul := A.comul.op\n  one_mul := by\n    rw [‚Üê op_whiskerRight, ‚Üê op_comp, counit_comul]\n    rfl\n  mul_one := by\n    rw [‚Üê op_whiskerLeft, ‚Üê op_comp, comul_counit]\n    rfl\n  mul_assoc := by\n    rw [‚Üê op_inv_associator, ‚Üê op_whiskerRight, ‚Üê op_comp, ‚Üê op_whiskerLeft, ‚Üê op_comp,\n      comul_assoc_flip, op_comp, op_comp_assoc]\n    rfl\n\n"}
{"name":"Comon_.Comon_ToMon_OpOp_obj","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Comon_ C\n‚ä¢ Eq ((Comon_.Comon_ToMon_OpOp C).obj A) { unop := Comon_.Comon_ToMon_OpOp_obj' C A }","decl":"/--\nThe contravariant functor turning comonoid objects into monoid objects in the opposite category.\n-/\n@[simps] def Comon_ToMon_OpOp : Comon_ C ‚•§ (Mon_ (C·µí·µñ))·µí·µñ where\n  obj A := op (Comon_ToMon_OpOp_obj' C A)\n  map := fun f => op <|\n    { hom := f.hom.op\n      one_hom := by apply Quiver.Hom.unop_inj; simp\n      mul_hom := by apply Quiver.Hom.unop_inj; simp [op_tensorHom] }\n\n"}
{"name":"Comon_.Comon_ToMon_OpOp_map","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù Y‚úù : Comon_ C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Comon_.Comon_ToMon_OpOp C).map f) { unop := { hom := f.hom.op, one_hom := ‚ãØ, mul_hom := ‚ãØ } }","decl":"/--\nThe contravariant functor turning comonoid objects into monoid objects in the opposite category.\n-/\n@[simps] def Comon_ToMon_OpOp : Comon_ C ‚•§ (Mon_ (C·µí·µñ))·µí·µñ where\n  obj A := op (Comon_ToMon_OpOp_obj' C A)\n  map := fun f => op <|\n    { hom := f.hom.op\n      one_hom := by apply Quiver.Hom.unop_inj; simp\n      mul_hom := by apply Quiver.Hom.unop_inj; simp [op_tensorHom] }\n\n"}
{"name":"Comon_.Mon_OpOpToComon_obj'_comul","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ (Opposite C)\n‚ä¢ Eq (Comon_.Mon_OpOpToComon_obj' C A).comul A.mul.unop","decl":"/--\nTurn a monoid object in the opposite category into a comonoid object.\n-/\n@[simps] def Mon_OpOpToComon_obj' (A : (Mon_ (C·µí·µñ))) : Comon_ C where\n  X := unop A.X\n  counit := A.one.unop\n  comul := A.mul.unop\n  counit_comul := by rw [‚Üê unop_whiskerRight, ‚Üê unop_comp, Mon_.one_mul]; rfl\n  comul_counit := by rw [‚Üê unop_whiskerLeft, ‚Üê unop_comp, Mon_.mul_one]; rfl\n  comul_assoc := by\n    rw [‚Üê unop_whiskerRight, ‚Üê unop_whiskerLeft, ‚Üê unop_comp_assoc, ‚Üê unop_comp,\n      Mon_.mul_assoc_flip]\n    rfl\n\n"}
{"name":"Comon_.Mon_OpOpToComon_obj'_counit","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ (Opposite C)\n‚ä¢ Eq (Comon_.Mon_OpOpToComon_obj' C A).counit A.one.unop","decl":"/--\nTurn a monoid object in the opposite category into a comonoid object.\n-/\n@[simps] def Mon_OpOpToComon_obj' (A : (Mon_ (C·µí·µñ))) : Comon_ C where\n  X := unop A.X\n  counit := A.one.unop\n  comul := A.mul.unop\n  counit_comul := by rw [‚Üê unop_whiskerRight, ‚Üê unop_comp, Mon_.one_mul]; rfl\n  comul_counit := by rw [‚Üê unop_whiskerLeft, ‚Üê unop_comp, Mon_.mul_one]; rfl\n  comul_assoc := by\n    rw [‚Üê unop_whiskerRight, ‚Üê unop_whiskerLeft, ‚Üê unop_comp_assoc, ‚Üê unop_comp,\n      Mon_.mul_assoc_flip]\n    rfl\n\n"}
{"name":"Comon_.Mon_OpOpToComon_obj'_X","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Mon_ (Opposite C)\n‚ä¢ Eq (Comon_.Mon_OpOpToComon_obj' C A).X (Opposite.unop A.X)","decl":"/--\nTurn a monoid object in the opposite category into a comonoid object.\n-/\n@[simps] def Mon_OpOpToComon_obj' (A : (Mon_ (C·µí·µñ))) : Comon_ C where\n  X := unop A.X\n  counit := A.one.unop\n  comul := A.mul.unop\n  counit_comul := by rw [‚Üê unop_whiskerRight, ‚Üê unop_comp, Mon_.one_mul]; rfl\n  comul_counit := by rw [‚Üê unop_whiskerLeft, ‚Üê unop_comp, Mon_.mul_one]; rfl\n  comul_assoc := by\n    rw [‚Üê unop_whiskerRight, ‚Üê unop_whiskerLeft, ‚Üê unop_comp_assoc, ‚Üê unop_comp,\n      Mon_.mul_assoc_flip]\n    rfl\n\n"}
{"name":"Comon_.Mon_OpOpToComon__obj","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nA : Opposite (Mon_ (Opposite C))\n‚ä¢ Eq ((Comon_.Mon_OpOpToComon_ C).obj A) (Comon_.Mon_OpOpToComon_obj' C (Opposite.unop A))","decl":"/--\nThe contravariant functor turning monoid objects in the opposite category into comonoid objects.\n-/\n@[simps]\ndef Mon_OpOpToComon_ : (Mon_ (C·µí·µñ))·µí·µñ ‚•§ Comon_ C where\n  obj A := Mon_OpOpToComon_obj' C (unop A)\n  map := fun f =>\n    { hom := f.unop.hom.unop\n      hom_counit := by apply Quiver.Hom.op_inj; simp\n      hom_comul := by apply Quiver.Hom.op_inj; simp [op_tensorHom] }\n\n"}
{"name":"Comon_.Mon_OpOpToComon__map_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX‚úù Y‚úù : Opposite (Mon_ (Opposite C))\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Comon_.Mon_OpOpToComon_ C).map f).hom f.unop.hom.unop","decl":"/--\nThe contravariant functor turning monoid objects in the opposite category into comonoid objects.\n-/\n@[simps]\ndef Mon_OpOpToComon_ : (Mon_ (C·µí·µñ))·µí·µñ ‚•§ Comon_ C where\n  obj A := Mon_OpOpToComon_obj' C (unop A)\n  map := fun f =>\n    { hom := f.unop.hom.unop\n      hom_counit := by apply Quiver.Hom.op_inj; simp\n      hom_comul := by apply Quiver.Hom.op_inj; simp [op_tensorHom] }\n\n"}
{"name":"Comon_.Comon_EquivMon_OpOp_unitIso","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Comon_.Comon_EquivMon_OpOp C).unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (Comon_ C)).obj x)) ‚ãØ)","decl":"/--\nComonoid objects are contravariantly equivalent to monoid objects in the opposite category.\n-/\n@[simps]\ndef Comon_EquivMon_OpOp : Comon_ C ‚âå (Mon_ (C·µí·µñ))·µí·µñ :=\n  { functor := Comon_ToMon_OpOp C\n    inverse := Mon_OpOpToComon_ C\n    unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n    counitIso := NatIso.ofComponents (fun _ => Iso.refl _) }\n\n"}
{"name":"Comon_.Comon_EquivMon_OpOp_functor","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Comon_.Comon_EquivMon_OpOp C).functor (Comon_.Comon_ToMon_OpOp C)","decl":"/--\nComonoid objects are contravariantly equivalent to monoid objects in the opposite category.\n-/\n@[simps]\ndef Comon_EquivMon_OpOp : Comon_ C ‚âå (Mon_ (C·µí·µñ))·µí·µñ :=\n  { functor := Comon_ToMon_OpOp C\n    inverse := Mon_OpOpToComon_ C\n    unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n    counitIso := NatIso.ofComponents (fun _ => Iso.refl _) }\n\n"}
{"name":"Comon_.Comon_EquivMon_OpOp_inverse","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Comon_.Comon_EquivMon_OpOp C).inverse (Comon_.Mon_OpOpToComon_ C)","decl":"/--\nComonoid objects are contravariantly equivalent to monoid objects in the opposite category.\n-/\n@[simps]\ndef Comon_EquivMon_OpOp : Comon_ C ‚âå (Mon_ (C·µí·µñ))·µí·µñ :=\n  { functor := Comon_ToMon_OpOp C\n    inverse := Mon_OpOpToComon_ C\n    unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n    counitIso := NatIso.ofComponents (fun _ => Iso.refl _) }\n\n"}
{"name":"Comon_.Comon_EquivMon_OpOp_counitIso","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.MonoidalCategory C\n‚ä¢ Eq (Comon_.Comon_EquivMon_OpOp C).counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl (((Comon_.Mon_OpOpToComon_ C).comp (Comon_.Comon_ToMon_OpOp C)).obj x)) ‚ãØ)","decl":"/--\nComonoid objects are contravariantly equivalent to monoid objects in the opposite category.\n-/\n@[simps]\ndef Comon_EquivMon_OpOp : Comon_ C ‚âå (Mon_ (C·µí·µñ))·µí·µñ :=\n  { functor := Comon_ToMon_OpOp C\n    inverse := Mon_OpOpToComon_ C\n    unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n    counitIso := NatIso.ofComponents (fun _ => Iso.refl _) }\n\n"}
{"name":"Comon_.monoidal_tensorObj_counit","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).counit (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom X.counit Y.counit) (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom)","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_rightUnitor_hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.X).hom","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_tensorHom_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX‚ÇÅ‚úù Y‚ÇÅ‚úù X‚ÇÇ‚úù Y‚ÇÇ‚úù : Comon_ C\nf : Quiver.Hom X‚ÇÅ‚úù Y‚ÇÅ‚úù\ng : Quiver.Hom X‚ÇÇ‚úù Y‚ÇÇ‚úù\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).hom (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom g.hom)","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_whiskerRight_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX‚ÇÅ‚úù X‚ÇÇ‚úù : Comon_ C\nf : Quiver.Hom X‚ÇÅ‚úù X‚ÇÇ‚úù\nX : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom X.X)","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_tensorObj_comul","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom X.comul Y.comul) (CategoryTheory.MonoidalCategory.tensorŒº X.X X.X Y.X Y.X))","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_associator_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y Z : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv.hom (CategoryTheory.MonoidalCategoryStruct.associator X.X Y.X Z.X).inv","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_whiskerLeft_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX x‚úù¬π x‚úù : Comon_ C\nf : Quiver.Hom x‚úù¬π x‚úù\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.X f.hom)","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_tensorUnit_X","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.X CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_leftUnitor_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.X).inv","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_tensorObj_X","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).X (CategoryTheory.MonoidalCategoryStruct.tensorObj X.X Y.X)","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_tensorUnit_comul","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.comul (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_leftUnitor_hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.X).hom","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_tensorUnit_counit","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.counit (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_associator_hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y Z : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom.hom (CategoryTheory.MonoidalCategoryStruct.associator X.X Y.X Z.X).hom","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.monoidal_rightUnitor_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.hom (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.X).inv","decl":"/--\nComonoid objects in a braided category form a monoidal category.\n\nThis definition is via transporting back and forth to monoids in the opposite category,\n-/\n@[simps!]\ninstance monoidal [BraidedCategory C] : MonoidalCategory (Comon_ C) :=\n  Monoidal.transport (Comon_EquivMon_OpOp C).symm\n\n"}
{"name":"Comon_.tensorObj_X","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA B : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj A B).X (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X B.X)","decl":"theorem tensorObj_X (A B : Comon_ C) : (A ‚äó B).X = A.X ‚äó B.X := rfl\n\n"}
{"name":"Comon_.tensorObj_counit","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA B : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj A B).counit (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom A.counit B.counit) (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom)","decl":"theorem tensorObj_counit (A B : Comon_ C) : (A ‚äó B).counit = (A.counit ‚äó B.counit) ‚â´ (Œª_ _).hom :=\n  rfl\n\n"}
{"name":"Comon_.tensorObj_comul'","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA B : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj A B).comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom A.comul B.comul) (CategoryTheory.MonoidalCategory.tensorŒº { unop := A.X } { unop := B.X } { unop := A.X } { unop := B.X }).unop)","decl":"/--\nPreliminary statement of the comultiplication for a tensor product of comonoids.\nThis version is the definitional equality provided by transport, and not quite as good as\nthe version provided in `tensorObj_comul` below.\n-/\ntheorem tensorObj_comul' (A B : Comon_ C) :\n    (A ‚äó B).comul =\n      (A.comul ‚äó B.comul) ‚â´ (tensorŒº (op A.X) (op B.X) (op A.X) (op B.X)).unop := by\n  rfl\n\n"}
{"name":"Comon_.tensorObj_comul","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA B : Comon_ C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj A B).comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom A.comul B.comul) (CategoryTheory.MonoidalCategory.tensorŒº A.X A.X B.X B.X))","decl":"/--\nThe comultiplication on the tensor product of two comonoids is\nthe tensor product of the comultiplications followed by the tensor strength\n(to shuffle the factors back into order).\n-/\ntheorem tensorObj_comul (A B : Comon_ C) :\n    (A ‚äó B).comul = (A.comul ‚äó B.comul) ‚â´ tensorŒº A.X A.X B.X B.X := by\n  rw [tensorObj_comul']\n  congr\n  simp only [tensorŒº, unop_tensorObj, unop_op]\n  apply Quiver.Hom.unop_inj\n  dsimp [op_tensorObj, op_associator]\n  rw [Category.assoc, Category.assoc, Category.assoc]\n\n"}
{"name":"Comon_.forget_Œµ","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œµ (Comon_.forget C)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp] theorem forget_Œµ : ¬´Œµ¬ª (forget C) = ùüô (ùüô_ C) := rfl\n"}
{"name":"Comon_.forget_Œ∑","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ∑ (Comon_.forget C)) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[simp] theorem forget_Œ∑ : Œ∑ (forget C) = ùüô (ùüô_ C) := rfl\n"}
{"name":"Comon_.forget_Œº","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y : Comon_ C\n‚ä¢ Eq (CategoryTheory.Functor.LaxMonoidal.Œº (Comon_.forget C) X Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X.X Y.X))","decl":"@[simp] theorem forget_Œº (X Y : Comon_ C) : Œº (forget C) X Y = ùüô (X.X ‚äó Y.X) := rfl\n"}
{"name":"Comon_.forget_Œ¥","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y : Comon_ C\n‚ä¢ Eq (CategoryTheory.Functor.OplaxMonoidal.Œ¥ (Comon_.forget C) X Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X.X Y.X))","decl":"@[simp] theorem forget_Œ¥ (X Y : Comon_ C) : Œ¥ (forget C) X Y = ùüô (X.X ‚äó Y.X) := rfl\n\n"}
{"name":"CategoryTheory.Functor.mapComon_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst‚úù : F.OplaxMonoidal\nA : Comon_ C\n‚ä¢ Eq (F.mapComon.obj A).X (F.obj A.X)","decl":"/-- A oplax monoidal functor takes comonoid objects to comonoid objects.\n\nThat is, a oplax monoidal functor `F : C ‚•§ D` induces a functor `Comon_ C ‚•§ Comon_ D`.\n-/\n@[simps]\ndef mapComon (F : C ‚•§ D) [F.OplaxMonoidal] : Comon_ C ‚•§ Comon_ D where\n  obj A :=\n    { X := F.obj A.X\n      counit := F.map A.counit ‚â´ Œ∑ F\n      comul := F.map A.comul ‚â´ Œ¥ F _ _\n      counit_comul := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œ¥_natural_left_assoc, left_unitality,\n          ‚Üê F.map_comp_assoc, A.counit_comul]\n      comul_counit := by\n        simp_rw [MonoidalCategory.whiskerLeft_comp, Category.assoc, Œ¥_natural_right_assoc,\n          right_unitality, ‚Üê F.map_comp_assoc, A.comul_counit]\n      comul_assoc := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œ¥_natural_left_assoc,\n          MonoidalCategory.whiskerLeft_comp, Œ¥_natural_right_assoc,\n          ‚Üê F.map_comp_assoc, A.comul_assoc, F.map_comp, Category.assoc, associativity] }\n  map f :=\n    { hom := F.map f.hom\n      hom_counit := by dsimp; rw [‚Üê F.map_comp_assoc, f.hom_counit]\n      hom_comul := by\n        dsimp\n        rw [Category.assoc, Œ¥_natural, ‚Üê F.map_comp_assoc, ‚Üê F.map_comp_assoc, f.hom_comul] }\n  map_id A := by ext; simp\n  map_comp f g := by ext; simp\n\n-- TODO We haven't yet set up the category structure on `OplaxMonoidalFunctor C D`\n-- and so can't state `mapComonFunctor : OplaxMonoidalFunctor C D ‚•§ Comon_ C ‚•§ Comon_ D`.\n\n"}
{"name":"CategoryTheory.Functor.mapComon_map_hom","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst‚úù : F.OplaxMonoidal\nX‚úù Y‚úù : Comon_ C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.mapComon.map f).hom (F.map f.hom)","decl":"/-- A oplax monoidal functor takes comonoid objects to comonoid objects.\n\nThat is, a oplax monoidal functor `F : C ‚•§ D` induces a functor `Comon_ C ‚•§ Comon_ D`.\n-/\n@[simps]\ndef mapComon (F : C ‚•§ D) [F.OplaxMonoidal] : Comon_ C ‚•§ Comon_ D where\n  obj A :=\n    { X := F.obj A.X\n      counit := F.map A.counit ‚â´ Œ∑ F\n      comul := F.map A.comul ‚â´ Œ¥ F _ _\n      counit_comul := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œ¥_natural_left_assoc, left_unitality,\n          ‚Üê F.map_comp_assoc, A.counit_comul]\n      comul_counit := by\n        simp_rw [MonoidalCategory.whiskerLeft_comp, Category.assoc, Œ¥_natural_right_assoc,\n          right_unitality, ‚Üê F.map_comp_assoc, A.comul_counit]\n      comul_assoc := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œ¥_natural_left_assoc,\n          MonoidalCategory.whiskerLeft_comp, Œ¥_natural_right_assoc,\n          ‚Üê F.map_comp_assoc, A.comul_assoc, F.map_comp, Category.assoc, associativity] }\n  map f :=\n    { hom := F.map f.hom\n      hom_counit := by dsimp; rw [‚Üê F.map_comp_assoc, f.hom_counit]\n      hom_comul := by\n        dsimp\n        rw [Category.assoc, Œ¥_natural, ‚Üê F.map_comp_assoc, ‚Üê F.map_comp_assoc, f.hom_comul] }\n  map_id A := by ext; simp\n  map_comp f g := by ext; simp\n\n-- TODO We haven't yet set up the category structure on `OplaxMonoidalFunctor C D`\n-- and so can't state `mapComonFunctor : OplaxMonoidalFunctor C D ‚•§ Comon_ C ‚•§ Comon_ D`.\n\n"}
{"name":"CategoryTheory.Functor.mapComon_obj_comul","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst‚úù : F.OplaxMonoidal\nA : Comon_ C\n‚ä¢ Eq (F.mapComon.obj A).comul (CategoryTheory.CategoryStruct.comp (F.map A.comul) (CategoryTheory.Functor.OplaxMonoidal.Œ¥ F A.X A.X))","decl":"/-- A oplax monoidal functor takes comonoid objects to comonoid objects.\n\nThat is, a oplax monoidal functor `F : C ‚•§ D` induces a functor `Comon_ C ‚•§ Comon_ D`.\n-/\n@[simps]\ndef mapComon (F : C ‚•§ D) [F.OplaxMonoidal] : Comon_ C ‚•§ Comon_ D where\n  obj A :=\n    { X := F.obj A.X\n      counit := F.map A.counit ‚â´ Œ∑ F\n      comul := F.map A.comul ‚â´ Œ¥ F _ _\n      counit_comul := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œ¥_natural_left_assoc, left_unitality,\n          ‚Üê F.map_comp_assoc, A.counit_comul]\n      comul_counit := by\n        simp_rw [MonoidalCategory.whiskerLeft_comp, Category.assoc, Œ¥_natural_right_assoc,\n          right_unitality, ‚Üê F.map_comp_assoc, A.comul_counit]\n      comul_assoc := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œ¥_natural_left_assoc,\n          MonoidalCategory.whiskerLeft_comp, Œ¥_natural_right_assoc,\n          ‚Üê F.map_comp_assoc, A.comul_assoc, F.map_comp, Category.assoc, associativity] }\n  map f :=\n    { hom := F.map f.hom\n      hom_counit := by dsimp; rw [‚Üê F.map_comp_assoc, f.hom_counit]\n      hom_comul := by\n        dsimp\n        rw [Category.assoc, Œ¥_natural, ‚Üê F.map_comp_assoc, ‚Üê F.map_comp_assoc, f.hom_comul] }\n  map_id A := by ext; simp\n  map_comp f g := by ext; simp\n\n-- TODO We haven't yet set up the category structure on `OplaxMonoidalFunctor C D`\n-- and so can't state `mapComonFunctor : OplaxMonoidalFunctor C D ‚•§ Comon_ C ‚•§ Comon_ D`.\n\n"}
{"name":"CategoryTheory.Functor.mapComon_obj_counit","module":"Mathlib.CategoryTheory.Monoidal.Comon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor C D\ninst‚úù : F.OplaxMonoidal\nA : Comon_ C\n‚ä¢ Eq (F.mapComon.obj A).counit (CategoryTheory.CategoryStruct.comp (F.map A.counit) (CategoryTheory.Functor.OplaxMonoidal.Œ∑ F))","decl":"/-- A oplax monoidal functor takes comonoid objects to comonoid objects.\n\nThat is, a oplax monoidal functor `F : C ‚•§ D` induces a functor `Comon_ C ‚•§ Comon_ D`.\n-/\n@[simps]\ndef mapComon (F : C ‚•§ D) [F.OplaxMonoidal] : Comon_ C ‚•§ Comon_ D where\n  obj A :=\n    { X := F.obj A.X\n      counit := F.map A.counit ‚â´ Œ∑ F\n      comul := F.map A.comul ‚â´ Œ¥ F _ _\n      counit_comul := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œ¥_natural_left_assoc, left_unitality,\n          ‚Üê F.map_comp_assoc, A.counit_comul]\n      comul_counit := by\n        simp_rw [MonoidalCategory.whiskerLeft_comp, Category.assoc, Œ¥_natural_right_assoc,\n          right_unitality, ‚Üê F.map_comp_assoc, A.comul_counit]\n      comul_assoc := by\n        simp_rw [comp_whiskerRight, Category.assoc, Œ¥_natural_left_assoc,\n          MonoidalCategory.whiskerLeft_comp, Œ¥_natural_right_assoc,\n          ‚Üê F.map_comp_assoc, A.comul_assoc, F.map_comp, Category.assoc, associativity] }\n  map f :=\n    { hom := F.map f.hom\n      hom_counit := by dsimp; rw [‚Üê F.map_comp_assoc, f.hom_counit]\n      hom_comul := by\n        dsimp\n        rw [Category.assoc, Œ¥_natural, ‚Üê F.map_comp_assoc, ‚Üê F.map_comp_assoc, f.hom_comul] }\n  map_id A := by ext; simp\n  map_comp f g := by ext; simp\n\n-- TODO We haven't yet set up the category structure on `OplaxMonoidalFunctor C D`\n-- and so can't state `mapComonFunctor : OplaxMonoidalFunctor C D ‚•§ Comon_ C ‚•§ Comon_ D`.\n\n"}
