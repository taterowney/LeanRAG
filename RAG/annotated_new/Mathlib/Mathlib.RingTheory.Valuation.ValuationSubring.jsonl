{"name":"ValuationSubring.mk.injEq","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\ntoSubring✝ : Subring K\nmem_or_inv_mem'✝ : ∀ (x : K), Or (Membership.mem toSubring✝.carrier x) (Membership.mem toSubring✝.carrier (Inv.inv x))\ntoSubring : Subring K\nmem_or_inv_mem' : ∀ (x : K), Or (Membership.mem toSubring.carrier x) (Membership.mem toSubring.carrier (Inv.inv x))\n⊢ Eq (Eq { toSubring := toSubring✝, mem_or_inv_mem' := mem_or_inv_mem'✝ } { toSubring := toSubring, mem_or_inv_mem' := mem_or_inv_mem' }) (Eq toSubring✝ toSubring)","decl":"/-- A valuation subring of a field `K` is a subring `A` such that for every `x : K`,\neither `x ∈ A` or `x⁻¹ ∈ A`.\n\nThis is equivalent to being maximal in the domination order\nof local subrings (the stacks project definition). See `LocalSubring.isMax_iff`.\n-/\nstructure ValuationSubring extends Subring K where\n  mem_or_inv_mem' : ∀ x : K, x ∈ carrier ∨ x⁻¹ ∈ carrier\n\n"}
{"name":"ValuationSubring.mem_or_inv_mem'","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nself : ValuationSubring K\nx : K\n⊢ Or (Membership.mem self.carrier x) (Membership.mem self.carrier (Inv.inv x))","decl":"/-- A valuation subring of a field `K` is a subring `A` such that for every `x : K`,\neither `x ∈ A` or `x⁻¹ ∈ A`.\n\nThis is equivalent to being maximal in the domination order\nof local subrings (the stacks project definition). See `LocalSubring.isMax_iff`.\n-/\nstructure ValuationSubring extends Subring K where\n  mem_or_inv_mem' : ∀ x : K, x ∈ carrier ∨ x⁻¹ ∈ carrier\n\n"}
{"name":"ValuationSubring.mk.sizeOf_spec","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝¹ : Field K\ninst✝ : SizeOf K\ntoSubring : Subring K\nmem_or_inv_mem' : ∀ (x : K), Or (Membership.mem toSubring.carrier x) (Membership.mem toSubring.carrier (Inv.inv x))\n⊢ Eq (SizeOf.sizeOf { toSubring := toSubring, mem_or_inv_mem' := mem_or_inv_mem' }) (HAdd.hAdd 1 (SizeOf.sizeOf toSubring))","decl":"/-- A valuation subring of a field `K` is a subring `A` such that for every `x : K`,\neither `x ∈ A` or `x⁻¹ ∈ A`.\n\nThis is equivalent to being maximal in the domination order\nof local subrings (the stacks project definition). See `LocalSubring.isMax_iff`.\n-/\nstructure ValuationSubring extends Subring K where\n  mem_or_inv_mem' : ∀ x : K, x ∈ carrier ∨ x⁻¹ ∈ carrier\n\n"}
{"name":"ValuationSubring.mk.inj","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\ntoSubring✝ : Subring K\nmem_or_inv_mem'✝ : ∀ (x : K), Or (Membership.mem toSubring✝.carrier x) (Membership.mem toSubring✝.carrier (Inv.inv x))\ntoSubring : Subring K\nmem_or_inv_mem' : ∀ (x : K), Or (Membership.mem toSubring.carrier x) (Membership.mem toSubring.carrier (Inv.inv x))\nx✝ : Eq { toSubring := toSubring✝, mem_or_inv_mem' := mem_or_inv_mem'✝ } { toSubring := toSubring, mem_or_inv_mem' := mem_or_inv_mem' }\n⊢ Eq toSubring✝ toSubring","decl":"/-- A valuation subring of a field `K` is a subring `A` such that for every `x : K`,\neither `x ∈ A` or `x⁻¹ ∈ A`.\n\nThis is equivalent to being maximal in the domination order\nof local subrings (the stacks project definition). See `LocalSubring.isMax_iff`.\n-/\nstructure ValuationSubring extends Subring K where\n  mem_or_inv_mem' : ∀ x : K, x ∈ carrier ∨ x⁻¹ ∈ carrier\n\n"}
{"name":"ValuationSubring.mem_carrier","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx : K\n⊢ Iff (Membership.mem A.carrier x) (Membership.mem A x)","decl":"theorem mem_carrier (x : K) : x ∈ A.carrier ↔ x ∈ A := Iff.refl _\n\n"}
{"name":"ValuationSubring.mem_toSubring","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx : K\n⊢ Iff (Membership.mem A.toSubring x) (Membership.mem A x)","decl":"@[simp]\ntheorem mem_toSubring (x : K) : x ∈ A.toSubring ↔ x ∈ A := Iff.refl _\n\n"}
{"name":"ValuationSubring.ext","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA B : ValuationSubring K\nh : ∀ (x : K), Iff (Membership.mem A x) (Membership.mem B x)\n⊢ Eq A B","decl":"@[ext]\ntheorem ext (A B : ValuationSubring K) (h : ∀ x, x ∈ A ↔ x ∈ B) : A = B := SetLike.ext h\n\n"}
{"name":"ValuationSubring.ext_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA B : ValuationSubring K\n⊢ Iff (Eq A B) (∀ (x : K), Iff (Membership.mem A x) (Membership.mem B x))","decl":"@[ext]\ntheorem ext (A B : ValuationSubring K) (h : ∀ x, x ∈ A ↔ x ∈ B) : A = B := SetLike.ext h\n\n"}
{"name":"ValuationSubring.zero_mem","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ Membership.mem A 0","decl":"theorem zero_mem : (0 : K) ∈ A := A.toSubring.zero_mem\n\n"}
{"name":"ValuationSubring.one_mem","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ Membership.mem A 1","decl":"theorem one_mem : (1 : K) ∈ A := A.toSubring.one_mem\n\n"}
{"name":"ValuationSubring.add_mem","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx y : K\na✝¹ : Membership.mem A x\na✝ : Membership.mem A y\n⊢ Membership.mem A (HAdd.hAdd x y)","decl":"theorem add_mem (x y : K) : x ∈ A → y ∈ A → x + y ∈ A := A.toSubring.add_mem\n\n"}
{"name":"ValuationSubring.mul_mem","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx y : K\na✝¹ : Membership.mem A x\na✝ : Membership.mem A y\n⊢ Membership.mem A (HMul.hMul x y)","decl":"theorem mul_mem (x y : K) : x ∈ A → y ∈ A → x * y ∈ A := A.toSubring.mul_mem\n\n"}
{"name":"ValuationSubring.neg_mem","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx : K\na✝ : Membership.mem A x\n⊢ Membership.mem A (Neg.neg x)","decl":"theorem neg_mem (x : K) : x ∈ A → -x ∈ A := A.toSubring.neg_mem\n\n"}
{"name":"ValuationSubring.mem_or_inv_mem","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx : K\n⊢ Or (Membership.mem A x) (Membership.mem A (Inv.inv x))","decl":"theorem mem_or_inv_mem (x : K) : x ∈ A ∨ x⁻¹ ∈ A := A.mem_or_inv_mem' _\n\n"}
{"name":"ValuationSubring.instSubringClass","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ SubringClass (ValuationSubring K) K","decl":"instance : SubringClass (ValuationSubring K) K where\n  zero_mem := zero_mem\n  add_mem {_} a b := add_mem _ a b\n  one_mem := one_mem\n  mul_mem {_} a b := mul_mem _ a b\n  neg_mem {_} x := neg_mem _ x\n\n"}
{"name":"ValuationSubring.toSubring_injective","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Function.Injective ValuationSubring.toSubring","decl":"theorem toSubring_injective : Function.Injective (toSubring : ValuationSubring K → Subring K) :=\n  fun x y h => by cases x; cases y; congr\n\n"}
{"name":"ValuationSubring.instIsDomainSubtypeMem","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ IsDomain (Subtype fun x => Membership.mem A x)","decl":"instance : IsDomain A :=\n  show IsDomain A.toSubring by infer_instance\n\n"}
{"name":"ValuationSubring.mem_top","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nx : K\n⊢ Membership.mem Top.top x","decl":"theorem mem_top (x : K) : x ∈ (⊤ : ValuationSubring K) :=\n  trivial\n\n"}
{"name":"ValuationSubring.le_top","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ LE.le A Top.top","decl":"theorem le_top : A ≤ ⊤ := fun _a _ha => mem_top _\n\n"}
{"name":"ValuationSubring.instValuationRingSubtypeMem","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ ValuationRing (Subtype fun x => Membership.mem A x)","decl":"instance : ValuationRing A where\n  cond' a b := by\n    by_cases h : (b : K) = 0\n    · use 0\n      left\n      ext\n      simp [h]\n    by_cases h : (a : K) = 0\n    · use 0; right\n      ext\n      simp [h]\n    cases' A.mem_or_inv_mem (a / b) with hh hh\n    · use ⟨a / b, hh⟩\n      right\n      ext\n      field_simp\n    · rw [show (a / b : K)⁻¹ = b / a by field_simp] at hh\n      use ⟨b / a, hh⟩\n      left\n      ext\n      field_simp\n\n"}
{"name":"ValuationSubring.isLocalRing","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ IsLocalRing (Subtype fun x => Membership.mem A x)","decl":"instance isLocalRing : IsLocalRing A := ValuationRing.isLocalRing A\n\n"}
{"name":"ValuationSubring.algebraMap_apply","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\na : Subtype fun x => Membership.mem A x\n⊢ Eq ((algebraMap (Subtype fun x => Membership.mem A x) K) a) ↑a","decl":"@[simp]\ntheorem algebraMap_apply (a : A) : algebraMap A K a = a := rfl\n\n"}
{"name":"ValuationSubring.instIsFractionRingSubtypeMem","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ IsFractionRing (Subtype fun x => Membership.mem A x) K","decl":"instance : IsFractionRing A K where\n  map_units' := fun ⟨y, hy⟩ =>\n    (Units.mk0 (y : K) fun c => nonZeroDivisors.ne_zero hy <| Subtype.ext c).isUnit\n  surj' z := by\n    by_cases h : z = 0; · use (0, 1); simp [h]\n    cases' A.mem_or_inv_mem z with hh hh\n    · use (⟨z, hh⟩, 1); simp\n    · refine ⟨⟨1, ⟨⟨_, hh⟩, ?_⟩⟩, mul_inv_cancel₀ h⟩\n      exact mem_nonZeroDivisors_iff_ne_zero.2 fun c => h (inv_eq_zero.mp (congr_arg Subtype.val c))\n  exists_of_eq {a b} h := ⟨1, by ext; simpa using h⟩\n\n"}
{"name":"ValuationSubring.valuation_le_one","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\na : Subtype fun x => Membership.mem A x\n⊢ LE.le (A.valuation ↑a) 1","decl":"theorem valuation_le_one (a : A) : A.valuation a ≤ 1 :=\n  (ValuationRing.mem_integer_iff A K _).2 ⟨a, rfl⟩\n\n"}
{"name":"ValuationSubring.mem_of_valuation_le_one","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx : K\nh : LE.le (A.valuation x) 1\n⊢ Membership.mem A x","decl":"theorem mem_of_valuation_le_one (x : K) (h : A.valuation x ≤ 1) : x ∈ A :=\n  let ⟨a, ha⟩ := (ValuationRing.mem_integer_iff A K x).1 h\n  ha ▸ a.2\n\n"}
{"name":"ValuationSubring.valuation_le_one_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx : K\n⊢ Iff (LE.le (A.valuation x) 1) (Membership.mem A x)","decl":"theorem valuation_le_one_iff (x : K) : A.valuation x ≤ 1 ↔ x ∈ A :=\n  ⟨mem_of_valuation_le_one _ _, fun ha => A.valuation_le_one ⟨x, ha⟩⟩\n\n"}
{"name":"ValuationSubring.valuation_eq_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx y : K\n⊢ Iff (Eq (A.valuation x) (A.valuation y)) (Exists fun a => Eq (HMul.hMul (↑↑a) y) x)","decl":"theorem valuation_eq_iff (x y : K) : A.valuation x = A.valuation y ↔ ∃ a : Aˣ, (a : K) * y = x :=\n  Quotient.eq''\n\n"}
{"name":"ValuationSubring.valuation_le_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx y : K\n⊢ Iff (LE.le (A.valuation x) (A.valuation y)) (Exists fun a => Eq (HMul.hMul (↑a) y) x)","decl":"theorem valuation_le_iff (x y : K) : A.valuation x ≤ A.valuation y ↔ ∃ a : A, (a : K) * y = x :=\n  Iff.rfl\n\n"}
{"name":"ValuationSubring.valuation_surjective","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ Function.Surjective ⇑A.valuation","decl":"theorem valuation_surjective : Function.Surjective A.valuation := Quot.mk_surjective\n\n"}
{"name":"ValuationSubring.valuation_unit","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\na : Units (Subtype fun x => Membership.mem A x)\n⊢ Eq (A.valuation ↑↑a) 1","decl":"theorem valuation_unit (a : Aˣ) : A.valuation a = 1 := by\n  rw [← A.valuation.map_one, valuation_eq_iff]; use a; simp\n\n"}
{"name":"ValuationSubring.valuation_eq_one_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\na : Subtype fun x => Membership.mem A x\n⊢ Iff (IsUnit a) (Eq (A.valuation ↑a) 1)","decl":"theorem valuation_eq_one_iff (a : A) : IsUnit a ↔ A.valuation a = 1 :=\n  ⟨fun h => A.valuation_unit h.unit, fun h => by\n    have ha : (a : K) ≠ 0 := by\n      intro c\n      rw [c, A.valuation.map_zero] at h\n      exact zero_ne_one h\n    have ha' : (a : K)⁻¹ ∈ A := by rw [← valuation_le_one_iff, map_inv₀, h, inv_one]\n    apply isUnit_of_mul_eq_one a ⟨a⁻¹, ha'⟩; ext; field_simp⟩\n\n"}
{"name":"ValuationSubring.valuation_lt_one_or_eq_one","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\na : Subtype fun x => Membership.mem A x\n⊢ Or (LT.lt (A.valuation ↑a) 1) (Eq (A.valuation ↑a) 1)","decl":"theorem valuation_lt_one_or_eq_one (a : A) : A.valuation a < 1 ∨ A.valuation a = 1 :=\n  lt_or_eq_of_le (A.valuation_le_one a)\n\n"}
{"name":"ValuationSubring.valuation_lt_one_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\na : Subtype fun x => Membership.mem A x\n⊢ Iff (Membership.mem (IsLocalRing.maximalIdeal (Subtype fun x => Membership.mem A x)) a) (LT.lt (A.valuation ↑a) 1)","decl":"theorem valuation_lt_one_iff (a : A) : a ∈ IsLocalRing.maximalIdeal A ↔ A.valuation a < 1 := by\n  rw [IsLocalRing.mem_maximalIdeal]\n  dsimp [nonunits]; rw [valuation_eq_one_iff]\n  exact (A.valuation_le_one a).lt_iff_ne.symm\n\n"}
{"name":"ValuationSubring.mem_ofSubring","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nR : Subring K\nhR : ∀ (x : K), Or (Membership.mem R x) (Membership.mem R (Inv.inv x))\nx : K\n⊢ Iff (Membership.mem (ValuationSubring.ofSubring R hR) x) (Membership.mem R x)","decl":"@[simp]\ntheorem mem_ofSubring (R : Subring K) (hR : ∀ x : K, x ∈ R ∨ x⁻¹ ∈ R) (x : K) :\n    x ∈ ofSubring R hR ↔ x ∈ R :=\n  Iff.refl _\n\n"}
{"name":"ValuationSubring.monotone_mapOfLE","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nR S : ValuationSubring K\nh : LE.le R S\n⊢ Monotone ⇑(R.mapOfLE S h)","decl":"@[mono]\ntheorem monotone_mapOfLE (R S : ValuationSubring K) (h : R ≤ S) : Monotone (R.mapOfLE S h) := by\n  rintro ⟨⟩ ⟨⟩ ⟨a, ha⟩; exact ⟨R.inclusion S h a, ha⟩\n\n"}
{"name":"ValuationSubring.mapOfLE_comp_valuation","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nR S : ValuationSubring K\nh : LE.le R S\n⊢ Eq (Function.comp ⇑(R.mapOfLE S h) ⇑R.valuation) ⇑S.valuation","decl":"@[simp]\ntheorem mapOfLE_comp_valuation (R S : ValuationSubring K) (h : R ≤ S) :\n    R.mapOfLE S h ∘ R.valuation = S.valuation := by ext; rfl\n\n"}
{"name":"ValuationSubring.mapOfLE_valuation_apply","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nR S : ValuationSubring K\nh : LE.le R S\nx : K\n⊢ Eq ((R.mapOfLE S h) (R.valuation x)) (S.valuation x)","decl":"@[simp]\ntheorem mapOfLE_valuation_apply (R S : ValuationSubring K) (h : R ≤ S) (x : K) :\n    R.mapOfLE S h (R.valuation x) = S.valuation x := rfl\n\n"}
{"name":"ValuationSubring.prime_idealOfLE","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nR S : ValuationSubring K\nh : LE.le R S\n⊢ (R.idealOfLE S h).IsPrime","decl":"instance prime_idealOfLE (R S : ValuationSubring K) (h : R ≤ S) : (idealOfLE R S h).IsPrime :=\n  (IsLocalRing.maximalIdeal S).comap_isPrime _\n\n"}
{"name":"ValuationSubring.ofPrime_scalar_tower","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝¹ : Field K\nA : ValuationSubring K\nP : Ideal (Subtype fun x => Membership.mem A x)\ninst✝ : P.IsPrime\n⊢ IsScalarTower (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem (A.ofPrime P) x) K","decl":"instance ofPrime_scalar_tower (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10754): added instance\n    letI : SMul A (A.ofPrime P) := SMulZeroClass.toSMul\n    IsScalarTower A (A.ofPrime P) K :=\n  IsScalarTower.subalgebra' A K K\n    -- Porting note: filled in the argument\n    (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors)\n\n"}
{"name":"ValuationSubring.ofPrime_localization","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝¹ : Field K\nA : ValuationSubring K\nP : Ideal (Subtype fun x => Membership.mem A x)\ninst✝ : P.IsPrime\n⊢ IsLocalization.AtPrime (Subtype fun x => Membership.mem (A.ofPrime P) x) P","decl":"instance ofPrime_localization (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    IsLocalization.AtPrime (A.ofPrime P) P := by\n  apply\n    Localization.subalgebra.isLocalization_ofField K P.primeCompl\n      P.primeCompl_le_nonZeroDivisors\n\n"}
{"name":"ValuationSubring.le_ofPrime","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝¹ : Field K\nA : ValuationSubring K\nP : Ideal (Subtype fun x => Membership.mem A x)\ninst✝ : P.IsPrime\n⊢ LE.le A (A.ofPrime P)","decl":"theorem le_ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] : A ≤ ofPrime A P :=\n  -- Porting note: added `Subalgebra.mem_toSubring.mpr`\n  fun a ha => Subalgebra.mem_toSubring.mpr <| Subalgebra.algebraMap_mem _ (⟨a, ha⟩ : A)\n\n"}
{"name":"ValuationSubring.ofPrime_valuation_eq_one_iff_mem_primeCompl","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝¹ : Field K\nA : ValuationSubring K\nP : Ideal (Subtype fun x => Membership.mem A x)\ninst✝ : P.IsPrime\nx : Subtype fun x => Membership.mem A x\n⊢ Iff (Eq ((A.ofPrime P).valuation ↑x) 1) (Membership.mem P.primeCompl x)","decl":"theorem ofPrime_valuation_eq_one_iff_mem_primeCompl (A : ValuationSubring K) (P : Ideal A)\n    [P.IsPrime] (x : A) : (ofPrime A P).valuation x = 1 ↔ x ∈ P.primeCompl := by\n  rw [← IsLocalization.AtPrime.isUnit_to_map_iff (A.ofPrime P) P x, valuation_eq_one_iff]; rfl\n\n"}
{"name":"ValuationSubring.idealOfLE_ofPrime","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝¹ : Field K\nA : ValuationSubring K\nP : Ideal (Subtype fun x => Membership.mem A x)\ninst✝ : P.IsPrime\n⊢ Eq (A.idealOfLE (A.ofPrime P) ⋯) P","decl":"@[simp]\ntheorem idealOfLE_ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    idealOfLE A (ofPrime A P) (le_ofPrime A P) = P := by\n  refine Ideal.ext (fun x => ?_)\n  apply IsLocalization.AtPrime.to_map_mem_maximal_iff\n  exact isLocalRing (ofPrime A P)\n\n"}
{"name":"ValuationSubring.ofPrime_idealOfLE","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nR S : ValuationSubring K\nh : LE.le R S\n⊢ Eq (R.ofPrime (R.idealOfLE S h)) S","decl":"@[simp]\ntheorem ofPrime_idealOfLE (R S : ValuationSubring K) (h : R ≤ S) :\n    ofPrime R (idealOfLE R S h) = S := by\n  ext x; constructor\n  · rintro ⟨a, r, hr, rfl⟩; apply mul_mem; · exact h a.2\n    · rw [← valuation_le_one_iff, map_inv₀, ← inv_one, inv_le_inv₀]\n      · exact not_lt.1 ((not_iff_not.2 <| valuation_lt_one_iff S _).1 hr)\n      · simpa [Valuation.pos_iff] using fun hr₀ ↦ hr₀ ▸ hr <| Ideal.zero_mem (R.idealOfLE S h)\n      · exact zero_lt_one\n  · intro hx; by_cases hr : x ∈ R; · exact R.le_ofPrime _ hr\n    have : x ≠ 0 := fun h => hr (by rw [h]; exact R.zero_mem)\n    replace hr := (R.mem_or_inv_mem x).resolve_left hr\n    refine ⟨1, ⟨x⁻¹, hr⟩, ?_, ?_⟩\n    · simp only [Ideal.primeCompl, Submonoid.mem_mk, Subsemigroup.mem_mk, Set.mem_compl_iff,\n        SetLike.mem_coe, idealOfLE, Ideal.mem_comap, IsLocalRing.mem_maximalIdeal, mem_nonunits_iff,\n        not_not]\n      change IsUnit (⟨x⁻¹, h hr⟩ : S)\n      apply isUnit_of_mul_eq_one _ (⟨x, hx⟩ : S)\n      ext; field_simp\n    · field_simp\n\n"}
{"name":"ValuationSubring.ofPrime_le_of_le","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nA : ValuationSubring K\nP Q : Ideal (Subtype fun x => Membership.mem A x)\ninst✝¹ : P.IsPrime\ninst✝ : Q.IsPrime\nh : LE.le P Q\n⊢ LE.le (A.ofPrime Q) (A.ofPrime P)","decl":"theorem ofPrime_le_of_le (P Q : Ideal A) [P.IsPrime] [Q.IsPrime] (h : P ≤ Q) :\n    ofPrime A Q ≤ ofPrime A P := fun _x ⟨a, s, hs, he⟩ => ⟨a, s, fun c => hs (h c), he⟩\n\n"}
{"name":"ValuationSubring.idealOfLE_le_of_le","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA R S : ValuationSubring K\nhR : LE.le A R\nhS : LE.le A S\nh : LE.le R S\n⊢ LE.le (A.idealOfLE S hS) (A.idealOfLE R hR)","decl":"theorem idealOfLE_le_of_le (R S : ValuationSubring K) (hR : A ≤ R) (hS : A ≤ S) (h : R ≤ S) :\n    idealOfLE A S hS ≤ idealOfLE A R hR := fun x hx =>\n  (valuation_lt_one_iff R _).2\n    (by\n      by_contra c; push_neg at c; replace c := monotone_mapOfLE R S h c\n      rw [(mapOfLE _ _ _).map_one, mapOfLE_valuation_apply] at c\n      apply not_le_of_lt ((valuation_lt_one_iff S _).1 hx) c)\n\n"}
{"name":"ValuationSubring.primeSpectrumEquiv_apply_coe","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nP : PrimeSpectrum (Subtype fun x => Membership.mem A x)\n⊢ Eq (↑(A.primeSpectrumEquiv P)) (A.ofPrime P.asIdeal)","decl":"/-- The equivalence between coarsenings of a valuation ring and its prime ideals. -/\n@[simps]\ndef primeSpectrumEquiv : PrimeSpectrum A ≃ {S // A ≤ S} where\n  toFun P := ⟨ofPrime A P.asIdeal, le_ofPrime _ _⟩\n  invFun S := ⟨idealOfLE _ S S.2, inferInstance⟩\n  left_inv P := by ext1; simp\n  right_inv S := by ext1; simp\n\n"}
{"name":"ValuationSubring.primeSpectrumEquiv_symm_apply_asIdeal","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nS : Subtype fun S => LE.le A S\n⊢ Eq (A.primeSpectrumEquiv.symm S).asIdeal (A.idealOfLE ↑S ⋯)","decl":"/-- The equivalence between coarsenings of a valuation ring and its prime ideals. -/\n@[simps]\ndef primeSpectrumEquiv : PrimeSpectrum A ≃ {S // A ≤ S} where\n  toFun P := ⟨ofPrime A P.asIdeal, le_ofPrime _ _⟩\n  invFun S := ⟨idealOfLE _ S S.2, inferInstance⟩\n  left_inv P := by ext1; simp\n  right_inv S := by ext1; simp\n\n"}
{"name":"ValuationSubring.primeSpectrumOrderEquiv_apply_coe_carrier","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nP : PrimeSpectrum (Subtype fun x => Membership.mem A x)\n⊢ Eq (↑↑(A.primeSpectrumOrderEquiv P)) (setOf fun x => Exists fun a => And (Membership.mem A a) (Exists fun a_1 => And (Exists fun x => Membership.mem P.asIdeal.primeCompl ⟨a_1, ⋯⟩) (Eq x (HMul.hMul a (Inv.inv a_1)))))","decl":"/-- An ordered variant of `primeSpectrumEquiv`. -/\n@[simps!]\ndef primeSpectrumOrderEquiv : (PrimeSpectrum A)ᵒᵈ ≃o {S // A ≤ S} :=\n  { primeSpectrumEquiv A with\n    map_rel_iff' :=\n      ⟨fun h => by\n        dsimp at h\n        have := idealOfLE_le_of_le A _ _ ?_ ?_ h\n        iterate 2 erw [idealOfLE_ofPrime] at this\n        · exact this\n        all_goals exact le_ofPrime A (PrimeSpectrum.asIdeal _),\n      fun h => by apply ofPrime_le_of_le; exact h⟩ }\n\n"}
{"name":"ValuationSubring.coe_primeSpectrumOrderEquiv_symm_apply_asIdeal","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nS : Subtype fun S => LE.le A S\n⊢ Eq (↑((RelIso.symm A.primeSpectrumOrderEquiv) S).asIdeal) (Set.preimage ⇑(A.inclusion ↑S ⋯) ↑(IsLocalRing.maximalIdeal (Subtype fun x => Membership.mem (↑S) x)))","decl":"/-- An ordered variant of `primeSpectrumEquiv`. -/\n@[simps!]\ndef primeSpectrumOrderEquiv : (PrimeSpectrum A)ᵒᵈ ≃o {S // A ≤ S} :=\n  { primeSpectrumEquiv A with\n    map_rel_iff' :=\n      ⟨fun h => by\n        dsimp at h\n        have := idealOfLE_le_of_le A _ _ ?_ ?_ h\n        iterate 2 erw [idealOfLE_ofPrime] at this\n        · exact this\n        all_goals exact le_ofPrime A (PrimeSpectrum.asIdeal _),\n      fun h => by apply ofPrime_le_of_le; exact h⟩ }\n\n"}
{"name":"ValuationSubring.le_total_ideal","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ IsTotal (Subtype fun S => LE.le A S) LE.le","decl":"instance le_total_ideal : IsTotal {S // A ≤ S} LE.le := by\n  classical\n  let _ : IsTotal (PrimeSpectrum A) (· ≤ ·) := ⟨fun ⟨x, _⟩ ⟨y, _⟩ => LE.isTotal.total x y⟩\n  exact ⟨(primeSpectrumOrderEquiv A).symm.toRelEmbedding.isTotal.total⟩\n\n"}
{"name":"Valuation.mem_valuationSubring_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝¹ : Field K\nΓ : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero Γ\nv : Valuation K Γ\nx : K\n⊢ Iff (Membership.mem v.valuationSubring x) (LE.le (v x) 1)","decl":"@[simp]\ntheorem mem_valuationSubring_iff (x : K) : x ∈ v.valuationSubring ↔ v x ≤ 1 := Iff.refl _\n\n"}
{"name":"Valuation.isEquiv_iff_valuationSubring","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nΓ₁ : Type u_2\nΓ₂ : Type u_3\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₁\ninst✝ : LinearOrderedCommGroupWithZero Γ₂\nv₁ : Valuation K Γ₁\nv₂ : Valuation K Γ₂\n⊢ Iff (v₁.IsEquiv v₂) (Eq v₁.valuationSubring v₂.valuationSubring)","decl":"theorem isEquiv_iff_valuationSubring :\n    v₁.IsEquiv v₂ ↔ v₁.valuationSubring = v₂.valuationSubring := by\n  constructor\n  · intro h; ext x; specialize h x 1; simpa using h\n  · intro h; apply isEquiv_of_val_le_one\n    intro x\n    have : x ∈ v₁.valuationSubring ↔ x ∈ v₂.valuationSubring := by rw [h]\n    simpa using this\n\n"}
{"name":"Valuation.isEquiv_valuation_valuationSubring","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝¹ : Field K\nΓ : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero Γ\nv : Valuation K Γ\n⊢ v.IsEquiv v.valuationSubring.valuation","decl":"theorem isEquiv_valuation_valuationSubring : v.IsEquiv v.valuationSubring.valuation := by\n  rw [isEquiv_iff_val_le_one]\n  intro x\n  rw [ValuationSubring.valuation_le_one_iff]\n  rfl\n\n"}
{"name":"ValuationSubring.valuationSubring_valuation","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ Eq A.valuation.valuationSubring A","decl":"@[simp]\ntheorem valuationSubring_valuation : A.valuation.valuationSubring = A := by\n  ext; rw [← A.valuation_le_one_iff]; rfl\n\n"}
{"name":"ValuationSubring.mem_unitGroup_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx : Units K\n⊢ Iff (Membership.mem A.unitGroup x) (Eq (A.valuation ↑x) 1)","decl":"@[simp]\ntheorem mem_unitGroup_iff (x : Kˣ) : x ∈ A.unitGroup ↔ A.valuation x = 1 := Iff.rfl\n\n"}
{"name":"ValuationSubring.coe_unitGroupMulEquiv_apply","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\na : Subtype fun x => Membership.mem A.unitGroup x\n⊢ Eq ↑↑(A.unitGroupMulEquiv a) ↑↑a","decl":"@[simp]\ntheorem coe_unitGroupMulEquiv_apply (a : A.unitGroup) :\n    ((A.unitGroupMulEquiv a : A) : K) = ((a : Kˣ) : K) := rfl\n\n"}
{"name":"ValuationSubring.coe_unitGroupMulEquiv_symm_apply","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\na : Units (Subtype fun x => Membership.mem A x)\n⊢ Eq ↑↑(A.unitGroupMulEquiv.symm a) ↑↑a","decl":"@[simp]\ntheorem coe_unitGroupMulEquiv_symm_apply (a : Aˣ) : ((A.unitGroupMulEquiv.symm a : Kˣ) : K) = a :=\n  rfl\n\n"}
{"name":"ValuationSubring.unitGroup_le_unitGroup","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA B : ValuationSubring K\n⊢ Iff (LE.le A.unitGroup B.unitGroup) (LE.le A B)","decl":"theorem unitGroup_le_unitGroup {A B : ValuationSubring K} : A.unitGroup ≤ B.unitGroup ↔ A ≤ B := by\n  constructor\n  · intro h x hx\n    rw [← A.valuation_le_one_iff x, le_iff_lt_or_eq] at hx\n    by_cases h_1 : x = 0; · simp only [h_1, zero_mem]\n    by_cases h_2 : 1 + x = 0\n    · simp only [← add_eq_zero_iff_neg_eq.1 h_2, neg_mem _ _ (one_mem _)]\n    cases' hx with hx hx\n    · have := h (show Units.mk0 _ h_2 ∈ A.unitGroup from A.valuation.map_one_add_of_lt hx)\n      simpa using\n        B.add_mem _ _ (show 1 + x ∈ B from SetLike.coe_mem (B.unitGroupMulEquiv ⟨_, this⟩ : B))\n          (B.neg_mem _ B.one_mem)\n    · have := h (show Units.mk0 x h_1 ∈ A.unitGroup from hx)\n      exact SetLike.coe_mem (B.unitGroupMulEquiv ⟨_, this⟩ : B)\n  · rintro h x (hx : A.valuation x = 1)\n    apply_fun A.mapOfLE B h at hx\n    simpa using hx\n\n"}
{"name":"ValuationSubring.unitGroup_injective","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Function.Injective ValuationSubring.unitGroup","decl":"theorem unitGroup_injective : Function.Injective (unitGroup : ValuationSubring K → Subgroup _) :=\n  fun A B h => by simpa only [le_antisymm_iff, unitGroup_le_unitGroup] using h\n\n"}
{"name":"ValuationSubring.eq_iff_unitGroup","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA B : ValuationSubring K\n⊢ Iff (Eq A B) (Eq A.unitGroup B.unitGroup)","decl":"theorem eq_iff_unitGroup {A B : ValuationSubring K} : A = B ↔ A.unitGroup = B.unitGroup :=\n  unitGroup_injective.eq_iff.symm\n\n"}
{"name":"ValuationSubring.unitGroup_strictMono","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ StrictMono ValuationSubring.unitGroup","decl":"theorem unitGroup_strictMono : StrictMono (unitGroup : ValuationSubring K → Subgroup _) :=\n  unitGroupOrderEmbedding.strictMono\n\n"}
{"name":"ValuationSubring.mem_nonunits_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx : K\n⊢ Iff (Membership.mem A.nonunits x) (LT.lt (A.valuation x) 1)","decl":"theorem mem_nonunits_iff {x : K} : x ∈ A.nonunits ↔ A.valuation x < 1 :=\n  Iff.rfl\n\n"}
{"name":"ValuationSubring.nonunits_le_nonunits","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA B : ValuationSubring K\n⊢ Iff (LE.le B.nonunits A.nonunits) (LE.le A B)","decl":"theorem nonunits_le_nonunits {A B : ValuationSubring K} : B.nonunits ≤ A.nonunits ↔ A ≤ B := by\n  constructor\n  · intro h x hx\n    by_cases h_1 : x = 0; · simp only [h_1, zero_mem]\n    rw [← valuation_le_one_iff, ← not_lt, Valuation.one_lt_val_iff _ h_1] at hx ⊢\n    by_contra h_2; exact hx (h h_2)\n  · intro h x hx\n    by_contra h_1; exact not_lt.2 (monotone_mapOfLE _ _ h (not_lt.1 h_1)) hx\n\n"}
{"name":"ValuationSubring.nonunits_injective","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Function.Injective ValuationSubring.nonunits","decl":"theorem nonunits_injective : Function.Injective (nonunits : ValuationSubring K → Subsemigroup _) :=\n  fun A B h => by simpa only [le_antisymm_iff, nonunits_le_nonunits] using h.symm\n\n"}
{"name":"ValuationSubring.nonunits_inj","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA B : ValuationSubring K\n⊢ Iff (Eq A.nonunits B.nonunits) (Eq A B)","decl":"theorem nonunits_inj {A B : ValuationSubring K} : A.nonunits = B.nonunits ↔ A = B :=\n  nonunits_injective.eq_iff\n\n"}
{"name":"ValuationSubring.coe_mem_nonunits_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\na : Subtype fun x => Membership.mem A x\n⊢ Iff (Membership.mem A.nonunits ↑a) (Membership.mem (IsLocalRing.maximalIdeal (Subtype fun x => Membership.mem A x)) a)","decl":"/-- The elements of `A.nonunits` are those of the maximal ideal of `A` after coercion to `K`.\n\nSee also `mem_nonunits_iff_exists_mem_maximalIdeal`, which gets rid of the coercion to `K`,\nat the expense of a more complicated right hand side.\n -/\ntheorem coe_mem_nonunits_iff {a : A} : (a : K) ∈ A.nonunits ↔ a ∈ IsLocalRing.maximalIdeal A :=\n  (valuation_lt_one_iff _ _).symm\n\n"}
{"name":"ValuationSubring.nonunits_le","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ LE.le A.nonunits A.toSubsemigroup","decl":"theorem nonunits_le : A.nonunits ≤ A.toSubring.toSubmonoid.toSubsemigroup := fun _a ha =>\n  (A.valuation_le_one_iff _).mp (A.mem_nonunits_iff.mp ha).le\n\n"}
{"name":"ValuationSubring.nonunits_subset","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ HasSubset.Subset ↑A.nonunits ↑A","decl":"theorem nonunits_subset : (A.nonunits : Set K) ⊆ A :=\n  nonunits_le\n\n"}
{"name":"ValuationSubring.mem_nonunits_iff_exists_mem_maximalIdeal","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\na : K\n⊢ Iff (Membership.mem A.nonunits a) (Exists fun ha => Membership.mem (IsLocalRing.maximalIdeal (Subtype fun x => Membership.mem A x)) ⟨a, ha⟩)","decl":"/-- The elements of `A.nonunits` are those of the maximal ideal of `A`.\n\nSee also `coe_mem_nonunits_iff`, which has a simpler right hand side but requires the element\nto be in `A` already.\n -/\ntheorem mem_nonunits_iff_exists_mem_maximalIdeal {a : K} :\n    a ∈ A.nonunits ↔ ∃ ha, (⟨a, ha⟩ : A) ∈ IsLocalRing.maximalIdeal A :=\n  ⟨fun h => ⟨nonunits_subset h, coe_mem_nonunits_iff.mp h⟩, fun ⟨_, h⟩ =>\n    coe_mem_nonunits_iff.mpr h⟩\n\n"}
{"name":"ValuationSubring.image_maximalIdeal","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ Eq (Set.image Subtype.val ↑(IsLocalRing.maximalIdeal (Subtype fun x => Membership.mem A x))) ↑A.nonunits","decl":"/-- `A.nonunits` agrees with the maximal ideal of `A`, after taking its image in `K`. -/\ntheorem image_maximalIdeal : ((↑) : A → K) '' IsLocalRing.maximalIdeal A = A.nonunits := by\n  ext a\n  simp only [Set.mem_image, SetLike.mem_coe, mem_nonunits_iff_exists_mem_maximalIdeal]\n  rw [Subtype.exists]\n  simp_rw [exists_and_right, exists_eq_right]\n\n"}
{"name":"ValuationSubring.principal_units_le_units","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ LE.le A.principalUnitGroup A.unitGroup","decl":"theorem principal_units_le_units : A.principalUnitGroup ≤ A.unitGroup := fun a h => by\n  simpa only [add_sub_cancel] using A.valuation.map_one_add_of_lt h\n\n"}
{"name":"ValuationSubring.mem_principalUnitGroup_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx : Units K\n⊢ Iff (Membership.mem A.principalUnitGroup x) (LT.lt (A.valuation (HSub.hSub (↑x) 1)) 1)","decl":"theorem mem_principalUnitGroup_iff (x : Kˣ) :\n    x ∈ A.principalUnitGroup ↔ A.valuation ((x : K) - 1) < 1 :=\n  Iff.rfl\n\n"}
{"name":"ValuationSubring.principalUnitGroup_le_principalUnitGroup","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA B : ValuationSubring K\n⊢ Iff (LE.le B.principalUnitGroup A.principalUnitGroup) (LE.le A B)","decl":"theorem principalUnitGroup_le_principalUnitGroup {A B : ValuationSubring K} :\n    B.principalUnitGroup ≤ A.principalUnitGroup ↔ A ≤ B := by\n  constructor\n  · intro h x hx\n    by_cases h_1 : x = 0; · simp only [h_1, zero_mem]\n    by_cases h_2 : x⁻¹ + 1 = 0\n    · rw [add_eq_zero_iff_eq_neg, inv_eq_iff_eq_inv, inv_neg, inv_one] at h_2\n      simpa only [h_2] using B.neg_mem _ B.one_mem\n    · rw [← valuation_le_one_iff, ← not_lt, Valuation.one_lt_val_iff _ h_1,\n        ← add_sub_cancel_right x⁻¹, ← Units.val_mk0 h_2, ← mem_principalUnitGroup_iff] at hx ⊢\n      simpa only [hx] using @h (Units.mk0 (x⁻¹ + 1) h_2)\n  · intro h x hx\n    by_contra h_1; exact not_lt.2 (monotone_mapOfLE _ _ h (not_lt.1 h_1)) hx\n\n"}
{"name":"ValuationSubring.principalUnitGroup_injective","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\n⊢ Function.Injective ValuationSubring.principalUnitGroup","decl":"theorem principalUnitGroup_injective :\n    Function.Injective (principalUnitGroup : ValuationSubring K → Subgroup _) := fun A B h => by\n  simpa [le_antisymm_iff, principalUnitGroup_le_principalUnitGroup] using h.symm\n\n"}
{"name":"ValuationSubring.eq_iff_principalUnitGroup","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA B : ValuationSubring K\n⊢ Iff (Eq A B) (Eq A.principalUnitGroup B.principalUnitGroup)","decl":"theorem eq_iff_principalUnitGroup {A B : ValuationSubring K} :\n    A = B ↔ A.principalUnitGroup = B.principalUnitGroup :=\n  principalUnitGroup_injective.eq_iff.symm\n\n"}
{"name":"ValuationSubring.coe_mem_principalUnitGroup_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx : Subtype fun x => Membership.mem A.unitGroup x\n⊢ Iff (Membership.mem A.principalUnitGroup ↑x) (Membership.mem (Units.map ↑(IsLocalRing.residue (Subtype fun x => Membership.mem A x))).ker (A.unitGroupMulEquiv x))","decl":"theorem coe_mem_principalUnitGroup_iff {x : A.unitGroup} :\n    (x : Kˣ) ∈ A.principalUnitGroup ↔\n      A.unitGroupMulEquiv x ∈ (Units.map (IsLocalRing.residue A).toMonoidHom).ker := by\n  rw [MonoidHom.mem_ker, Units.ext_iff]\n  let π := Ideal.Quotient.mk (IsLocalRing.maximalIdeal A); convert_to _ ↔ π _ = 1\n  rw [← π.map_one, ← sub_eq_zero, ← π.map_sub, Ideal.Quotient.eq_zero_iff_mem, valuation_lt_one_iff]\n  simp [mem_principalUnitGroup_iff]\n\n"}
{"name":"ValuationSubring.principalUnitGroupEquiv_apply","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\na : Subtype fun x => Membership.mem A.principalUnitGroup x\n⊢ Eq ↑↑↑(A.principalUnitGroupEquiv a) ↑↑a","decl":"theorem principalUnitGroupEquiv_apply (a : A.principalUnitGroup) :\n    (((principalUnitGroupEquiv A a : Aˣ) : A) : K) = (a : Kˣ) :=\n  rfl\n\n"}
{"name":"ValuationSubring.principalUnitGroup_symm_apply","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\na : Subtype fun x => Membership.mem (Units.map ↑(IsLocalRing.residue (Subtype fun x => Membership.mem A x))).ker x\n⊢ Eq ↑↑(A.principalUnitGroupEquiv.symm a) ↑↑↑a","decl":"theorem principalUnitGroup_symm_apply (a : (Units.map (IsLocalRing.residue A).toMonoidHom).ker) :\n    ((A.principalUnitGroupEquiv.symm a : Kˣ) : K) = ((a : Aˣ) : A) :=\n  rfl\n\n"}
{"name":"ValuationSubring.coe_unitGroupToResidueFieldUnits_apply","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx : Subtype fun x => Membership.mem A.unitGroup x\n⊢ Eq (↑(A.unitGroupToResidueFieldUnits x)) ((Ideal.Quotient.mk (IsLocalRing.maximalIdeal (Subtype fun x => Membership.mem A x))) ↑(A.unitGroupMulEquiv x))","decl":"@[simp]\ntheorem coe_unitGroupToResidueFieldUnits_apply (x : A.unitGroup) :\n    (A.unitGroupToResidueFieldUnits x : IsLocalRing.ResidueField A) =\n      Ideal.Quotient.mk _ (A.unitGroupMulEquiv x : A) :=\n  rfl\n\n"}
{"name":"ValuationSubring.ker_unitGroupToResidueFieldUnits","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ Eq A.unitGroupToResidueFieldUnits.ker (Subgroup.comap A.unitGroup.subtype A.principalUnitGroup)","decl":"theorem ker_unitGroupToResidueFieldUnits :\n    A.unitGroupToResidueFieldUnits.ker = A.principalUnitGroup.comap A.unitGroup.subtype := by\n  ext\n  -- Porting note: simp fails but rw works\n  -- See https://github.com/leanprover-community/mathlib4/issues/5026\n  -- simp [Subgroup.mem_comap, Subgroup.coeSubtype, coe_mem_principalUnitGroup_iff]\n  rw [Subgroup.mem_comap, Subgroup.coeSubtype, coe_mem_principalUnitGroup_iff]\n  rfl\n  -- simp [Subgroup.mem_comap, Subgroup.coeSubtype, coe_mem_principalUnitGroup_iff]\n\n"}
{"name":"ValuationSubring.surjective_unitGroupToResidueFieldUnits","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ Function.Surjective ⇑A.unitGroupToResidueFieldUnits","decl":"theorem surjective_unitGroupToResidueFieldUnits :\n    Function.Surjective A.unitGroupToResidueFieldUnits :=\n  (IsLocalRing.surjective_units_map_of_local_ringHom _ Ideal.Quotient.mk_surjective\n        IsLocalRing.isLocalHom_residue).comp\n    (MulEquiv.surjective _)\n\n"}
{"name":"ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\n⊢ Eq ((↑A.unitsModPrincipalUnitsEquivResidueFieldUnits).comp (QuotientGroup.mk' (A.principalUnitGroup.subgroupOf A.unitGroup))) A.unitGroupToResidueFieldUnits","decl":"theorem unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk :\n    (A.unitsModPrincipalUnitsEquivResidueFieldUnits : _ ⧸ Subgroup.comap _ _ →* _).comp\n        (QuotientGroup.mk' (A.principalUnitGroup.subgroupOf A.unitGroup)) =\n      A.unitGroupToResidueFieldUnits := rfl\n\n"}
{"name":"ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk_apply","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝ : Field K\nA : ValuationSubring K\nx : Subtype fun x => Membership.mem A.unitGroup x\n⊢ Eq (A.unitsModPrincipalUnitsEquivResidueFieldUnits.toMonoidHom ↑x) (A.unitGroupToResidueFieldUnits x)","decl":"theorem unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk_apply\n    (x : A.unitGroup) :\n    A.unitsModPrincipalUnitsEquivResidueFieldUnits.toMonoidHom (QuotientGroup.mk x) =\n      A.unitGroupToResidueFieldUnits x := rfl\n\n"}
{"name":"ValuationSubring.coe_pointwise_smul","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : MulSemiringAction G K\ng : G\nS : ValuationSubring K\n⊢ Eq (↑(HSMul.hSMul g S)) (HSMul.hSMul g ↑S)","decl":"@[simp]\ntheorem coe_pointwise_smul (g : G) (S : ValuationSubring K) : ↑(g • S) = g • (S : Set K) := rfl\n\n"}
{"name":"ValuationSubring.pointwise_smul_toSubring","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : MulSemiringAction G K\ng : G\nS : ValuationSubring K\n⊢ Eq (HSMul.hSMul g S).toSubring (HSMul.hSMul g S.toSubring)","decl":"@[simp]\ntheorem pointwise_smul_toSubring (g : G) (S : ValuationSubring K) :\n    (g • S).toSubring = g • S.toSubring := rfl\n\n"}
{"name":"ValuationSubring.smul_mem_pointwise_smul","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : MulSemiringAction G K\ng : G\nx : K\nS : ValuationSubring K\na✝ : Membership.mem S x\n⊢ Membership.mem (HSMul.hSMul g S) (HSMul.hSMul g x)","decl":"theorem smul_mem_pointwise_smul (g : G) (x : K) (S : ValuationSubring K) : x ∈ S → g • x ∈ g • S :=\n  (Set.smul_mem_smul_set : _ → _ ∈ g • (S : Set K))\n\n"}
{"name":"ValuationSubring.instCovariantClassHSMulLe","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : MulSemiringAction G K\n⊢ CovariantClass G (ValuationSubring K) HSMul.hSMul LE.le","decl":"instance : CovariantClass G (ValuationSubring K) HSMul.hSMul LE.le :=\n  ⟨fun _ _ _ => Set.image_subset _⟩\n\n"}
{"name":"ValuationSubring.mem_smul_pointwise_iff_exists","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : MulSemiringAction G K\ng : G\nx : K\nS : ValuationSubring K\n⊢ Iff (Membership.mem (HSMul.hSMul g S) x) (Exists fun s => And (Membership.mem S s) (Eq (HSMul.hSMul g s) x))","decl":"theorem mem_smul_pointwise_iff_exists (g : G) (x : K) (S : ValuationSubring K) :\n    x ∈ g • S ↔ ∃ s : K, s ∈ S ∧ g • s = x :=\n  (Set.mem_smul_set : x ∈ g • (S : Set K) ↔ _)\n\n"}
{"name":"ValuationSubring.pointwise_central_scalar","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝⁴ : Field K\nG : Type u_1\ninst✝³ : Group G\ninst✝² : MulSemiringAction G K\ninst✝¹ : MulSemiringAction (MulOpposite G) K\ninst✝ : IsCentralScalar G K\n⊢ IsCentralScalar G (ValuationSubring K)","decl":"instance pointwise_central_scalar [MulSemiringAction Gᵐᵒᵖ K] [IsCentralScalar G K] :\n    IsCentralScalar G (ValuationSubring K) :=\n  ⟨fun g S => toSubring_injective <| op_smul_eq_smul g S.toSubring⟩\n\n"}
{"name":"ValuationSubring.smul_mem_pointwise_smul_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : MulSemiringAction G K\ng : G\nS : ValuationSubring K\nx : K\n⊢ Iff (Membership.mem (HSMul.hSMul g S) (HSMul.hSMul g x)) (Membership.mem S x)","decl":"@[simp]\ntheorem smul_mem_pointwise_smul_iff {g : G} {S : ValuationSubring K} {x : K} :\n    g • x ∈ g • S ↔ x ∈ S := Set.smul_mem_smul_set_iff\n\n"}
{"name":"ValuationSubring.mem_pointwise_smul_iff_inv_smul_mem","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : MulSemiringAction G K\ng : G\nS : ValuationSubring K\nx : K\n⊢ Iff (Membership.mem (HSMul.hSMul g S) x) (Membership.mem S (HSMul.hSMul (Inv.inv g) x))","decl":"theorem mem_pointwise_smul_iff_inv_smul_mem {g : G} {S : ValuationSubring K} {x : K} :\n    x ∈ g • S ↔ g⁻¹ • x ∈ S := Set.mem_smul_set_iff_inv_smul_mem\n\n"}
{"name":"ValuationSubring.mem_inv_pointwise_smul_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : MulSemiringAction G K\ng : G\nS : ValuationSubring K\nx : K\n⊢ Iff (Membership.mem (HSMul.hSMul (Inv.inv g) S) x) (Membership.mem S (HSMul.hSMul g x))","decl":"theorem mem_inv_pointwise_smul_iff {g : G} {S : ValuationSubring K} {x : K} :\n    x ∈ g⁻¹ • S ↔ g • x ∈ S := Set.mem_inv_smul_set_iff\n\n"}
{"name":"ValuationSubring.pointwise_smul_le_pointwise_smul_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : MulSemiringAction G K\ng : G\nS T : ValuationSubring K\n⊢ Iff (LE.le (HSMul.hSMul g S) (HSMul.hSMul g T)) (LE.le S T)","decl":"@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {g : G} {S T : ValuationSubring K} :\n    g • S ≤ g • T ↔ S ≤ T := Set.smul_set_subset_smul_set_iff\n\n"}
{"name":"ValuationSubring.pointwise_smul_subset_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : MulSemiringAction G K\ng : G\nS T : ValuationSubring K\n⊢ Iff (LE.le (HSMul.hSMul g S) T) (LE.le S (HSMul.hSMul (Inv.inv g) T))","decl":"theorem pointwise_smul_subset_iff {g : G} {S T : ValuationSubring K} : g • S ≤ T ↔ S ≤ g⁻¹ • T :=\n  Set.smul_set_subset_iff_subset_inv_smul_set\n\n"}
{"name":"ValuationSubring.subset_pointwise_smul_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nG : Type u_1\ninst✝¹ : Group G\ninst✝ : MulSemiringAction G K\ng : G\nS T : ValuationSubring K\n⊢ Iff (LE.le S (HSMul.hSMul g T)) (LE.le (HSMul.hSMul (Inv.inv g) S) T)","decl":"theorem subset_pointwise_smul_iff {g : G} {S T : ValuationSubring K} : S ≤ g • T ↔ g⁻¹ • S ≤ T :=\n  Set.subset_smul_set_iff\n\n"}
{"name":"ValuationSubring.coe_comap","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝¹ : Field K\nL : Type u_1\ninst✝ : Field L\nA : ValuationSubring L\nf : RingHom K L\n⊢ Eq (↑(A.comap f)) (Set.preimage ⇑f ↑A)","decl":"@[simp]\ntheorem coe_comap (A : ValuationSubring L) (f : K →+* L) : (A.comap f : Set K) = f ⁻¹' A := rfl\n\n"}
{"name":"ValuationSubring.mem_comap","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝¹ : Field K\nL : Type u_1\ninst✝ : Field L\nA : ValuationSubring L\nf : RingHom K L\nx : K\n⊢ Iff (Membership.mem (A.comap f) x) (Membership.mem A (f x))","decl":"@[simp]\ntheorem mem_comap {A : ValuationSubring L} {f : K →+* L} {x : K} : x ∈ A.comap f ↔ f x ∈ A :=\n  Iff.rfl\n\n"}
{"name":"ValuationSubring.comap_comap","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝² : Field K\nL : Type u_1\nJ : Type u_2\ninst✝¹ : Field L\ninst✝ : Field J\nA : ValuationSubring J\ng : RingHom L J\nf : RingHom K L\n⊢ Eq ((A.comap g).comap f) (A.comap (g.comp f))","decl":"theorem comap_comap (A : ValuationSubring J) (g : L →+* J) (f : K →+* L) :\n    (A.comap g).comap f = A.comap (g.comp f) := rfl\n\n"}
{"name":"Valuation.mem_unitGroup_iff","module":"Mathlib.RingTheory.Valuation.ValuationSubring","initialProofState":"K : Type u\ninst✝¹ : Field K\nΓ : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero Γ\nv : Valuation K Γ\nx : Units K\n⊢ Iff (Membership.mem v.valuationSubring.unitGroup x) (Eq (v ↑x) 1)","decl":"theorem mem_unitGroup_iff : x ∈ v.valuationSubring.unitGroup ↔ v x = 1 :=\n  IsEquiv.eq_one_iff_eq_one (Valuation.isEquiv_valuation_valuationSubring _).symm\n\n"}
