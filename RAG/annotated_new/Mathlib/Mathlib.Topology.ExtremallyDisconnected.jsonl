{"name":"ExtremallyDisconnected.open_closure","module":"Mathlib.Topology.ExtremallyDisconnected","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nself : ExtremallyDisconnected X\nU : Set X\na✝ : IsOpen U\n⊢ IsOpen (closure U)","decl":"/-- An extremally disconnected topological space is a space\nin which the closure of every open set is open. -/\nclass ExtremallyDisconnected : Prop where\n  /-- The closure of every open set is open. -/\n  open_closure : ∀ U : Set X, IsOpen U → IsOpen (closure U)\n\n"}
{"name":"extremallyDisconnected_of_homeo","module":"Mathlib.Topology.ExtremallyDisconnected","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : ExtremallyDisconnected X\ne : Homeomorph X Y\n⊢ ExtremallyDisconnected Y","decl":"theorem extremallyDisconnected_of_homeo {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [ExtremallyDisconnected X] (e : X ≃ₜ Y) : ExtremallyDisconnected Y where\n  open_closure U hU := by\n    rw [e.symm.isInducing.closure_eq_preimage_closure_image, Homeomorph.isOpen_preimage]\n    exact ExtremallyDisconnected.open_closure _ (e.symm.isOpen_image.mpr hU)\n\n"}
{"name":"instTotallySeparatedSpaceOfExtremallyDisconnectedOfT2Space","module":"Mathlib.Topology.ExtremallyDisconnected","initialProofState":"X : Type u\ninst✝² : TopologicalSpace X\ninst✝¹ : ExtremallyDisconnected X\ninst✝ : T2Space X\n⊢ TotallySeparatedSpace X","decl":"/-- Extremally disconnected spaces are totally separated. -/\ninstance [ExtremallyDisconnected X] [T2Space X] : TotallySeparatedSpace X :=\n{ isTotallySeparated_univ := by\n    intro x _ y _ hxy\n    obtain ⟨U, V, hUV⟩ := T2Space.t2 hxy\n    refine ⟨closure U, (closure U)ᶜ, ExtremallyDisconnected.open_closure U hUV.1,\n      by simp only [isOpen_compl_iff, isClosed_closure], subset_closure hUV.2.2.1, ?_,\n      by simp only [Set.union_compl_self, Set.subset_univ], disjoint_compl_right⟩\n    rw [Set.mem_compl_iff, mem_closure_iff]\n    push_neg\n    refine ⟨V, ⟨hUV.2.1, hUV.2.2.2.1, ?_⟩⟩\n    rw [← Set.disjoint_iff_inter_eq_empty, disjoint_comm]\n    exact hUV.2.2.2.2 }\n\n"}
{"name":"StoneCech.projective","module":"Mathlib.Topology.ExtremallyDisconnected","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\n⊢ CompactT2.Projective (StoneCech X)","decl":"theorem StoneCech.projective [DiscreteTopology X] : CompactT2.Projective (StoneCech X) := by\n  intro Y Z _tsY _tsZ _csY _t2Y _csZ _csZ f g hf hg g_sur\n  let s : Z → Y := fun z => Classical.choose <| g_sur z\n  have hs : g ∘ s = id := funext fun z => Classical.choose_spec (g_sur z)\n  let t := s ∘ f ∘ stoneCechUnit\n  have ht : Continuous t := continuous_of_discreteTopology\n  let h : StoneCech X → Y := stoneCechExtend ht\n  have hh : Continuous h := continuous_stoneCechExtend ht\n  refine ⟨h, hh, denseRange_stoneCechUnit.equalizer (hg.comp hh) hf ?_⟩\n  rw [comp_assoc, stoneCechExtend_extends ht, ← comp_assoc, hs, id_comp]\n\n"}
{"name":"CompactT2.Projective.extremallyDisconnected","module":"Mathlib.Topology.ExtremallyDisconnected","initialProofState":"X : Type u\ninst✝² : TopologicalSpace X\ninst✝¹ : CompactSpace X\ninst✝ : T2Space X\nh : CompactT2.Projective X\n⊢ ExtremallyDisconnected X","decl":"protected theorem CompactT2.Projective.extremallyDisconnected [CompactSpace X] [T2Space X]\n    (h : CompactT2.Projective X) : ExtremallyDisconnected X := by\n  refine { open_closure := fun U hU => ?_ }\n  let Z₁ : Set (X × Bool) := Uᶜ ×ˢ {true}\n  let Z₂ : Set (X × Bool) := closure U ×ˢ {false}\n  let Z : Set (X × Bool) := Z₁ ∪ Z₂\n  have hZ₁₂ : Disjoint Z₁ Z₂ := disjoint_left.2 fun x hx₁ hx₂ => by cases hx₁.2.symm.trans hx₂.2\n  have hZ₁ : IsClosed Z₁ := hU.isClosed_compl.prod (T1Space.t1 _)\n  have hZ₂ : IsClosed Z₂ := isClosed_closure.prod (T1Space.t1 false)\n  have hZ : IsClosed Z := hZ₁.union hZ₂\n  let f : Z → X := Prod.fst ∘ Subtype.val\n  have f_cont : Continuous f := continuous_fst.comp continuous_subtype_val\n  have f_sur : Surjective f := by\n    intro x\n    by_cases hx : x ∈ U\n    · exact ⟨⟨(x, false), Or.inr ⟨subset_closure hx, mem_singleton _⟩⟩, rfl⟩\n    · exact ⟨⟨(x, true), Or.inl ⟨hx, mem_singleton _⟩⟩, rfl⟩\n  haveI : CompactSpace Z := isCompact_iff_compactSpace.mp hZ.isCompact\n  obtain ⟨g, hg, g_sec⟩ := h continuous_id f_cont f_sur\n  let φ := Subtype.val ∘ g\n  have hφ : Continuous φ := continuous_subtype_val.comp hg\n  have hφ₁ : ∀ x, (φ x).1 = x := congr_fun g_sec\n  suffices closure U = φ ⁻¹' Z₂ by\n    rw [this, preimage_comp, ← isClosed_compl_iff, ← preimage_compl,\n      ← preimage_subtype_coe_eq_compl Subset.rfl]\n    · exact hZ₁.preimage hφ\n    · rw [hZ₁₂.inter_eq, inter_empty]\n  refine (closure_minimal ?_ <| hZ₂.preimage hφ).antisymm fun x hx => ?_\n  · intro x hx\n    have : φ x ∈ Z₁ ∪ Z₂ := (g x).2\n    -- Porting note: Originally `simpa [hx, hφ₁] using this`\n    cases' this with hφ hφ\n    · exact ((hφ₁ x ▸ hφ.1) hx).elim\n    · exact hφ\n  · rw [← hφ₁ x]\n    exact hx.1\n\n"}
{"name":"exists_compact_surjective_zorn_subset","module":"Mathlib.Topology.ExtremallyDisconnected","initialProofState":"A D : Type u\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalSpace D\ninst✝¹ : T1Space A\ninst✝ : CompactSpace D\nπ : D → A\nπ_cont : Continuous π\nπ_surj : Function.Surjective π\n⊢ Exists fun E => And (CompactSpace ↑E) (And (Eq (Set.image π E) Set.univ) (∀ (E₀ : Set ↑E), Ne E₀ Set.univ → IsClosed E₀ → Ne (Set.image (E.restrict π) E₀) Set.univ))","decl":"/-- Lemma 2.4 in [Gleason, *Projective topological spaces*][gleason1958]:\na continuous surjection $\\pi$ from a compact space $D$ to a Fréchet space $A$ restricts to\na compact subset $E$ of $D$, such that $\\pi$ maps $E$ onto $A$ and satisfies the\n\"Zorn subset condition\", where $\\pi(E_0) \\ne A$ for any proper closed subset $E_0 \\subsetneq E$. -/\nlemma exists_compact_surjective_zorn_subset [T1Space A] [CompactSpace D] {π : D → A}\n    (π_cont : Continuous π) (π_surj : π.Surjective) : ∃ E : Set D, CompactSpace E ∧ π '' E = univ ∧\n    ∀ E₀ : Set E, E₀ ≠ univ → IsClosed E₀ → E.restrict π '' E₀ ≠ univ := by\n  -- suffices to apply Zorn's lemma on the subsets of $D$ that are closed and mapped onto $A$\n  let S : Set <| Set D := {E : Set D | IsClosed E ∧ π '' E = univ}\n  suffices ∀ (C : Set <| Set D) (_ : C ⊆ S) (_ : IsChain (· ⊆ ·) C), ∃ s ∈ S, ∀ c ∈ C, s ⊆ c by\n    rcases zorn_superset S this with ⟨E, E_min⟩\n    obtain ⟨E_closed, E_surj⟩ := E_min.prop\n    refine ⟨E, isCompact_iff_compactSpace.mp E_closed.isCompact, E_surj, ?_⟩\n    intro E₀ E₀_min E₀_closed\n    contrapose! E₀_min\n    exact eq_univ_of_image_val_eq <|\n      E_min.eq_of_subset ⟨E₀_closed.trans E_closed, image_image_val_eq_restrict_image ▸ E₀_min⟩\n        image_val_subset\n  -- suffices to prove intersection of chain is minimal\n  intro C C_sub C_chain\n  -- prove intersection of chain is closed\n  refine ⟨iInter (fun c : C => c), ⟨isClosed_iInter fun ⟨_, h⟩ => (C_sub h).left, ?_⟩,\n    fun c hc _ h => mem_iInter.mp h ⟨c, hc⟩⟩\n  -- prove intersection of chain is mapped onto $A$\n  by_cases hC : Nonempty C\n  · refine eq_univ_of_forall fun a => inter_nonempty_iff_exists_left.mp ?_\n    -- apply Cantor's intersection theorem\n    refine iInter_inter (ι := C) (π ⁻¹' {a}) _ ▸\n      IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed _\n      ?_ (fun c => ?_) (fun c => IsClosed.isCompact ?_) (fun c => ?_)\n    · replace C_chain : IsChain (· ⊇ ·) C := C_chain.symm\n      have : ∀ s t : Set D, s ⊇ t → _ ⊇ _ := fun _ _ => inter_subset_inter_left <| π ⁻¹' {a}\n      exact (directedOn_iff_directed.mp C_chain.directedOn).mono_comp (· ⊇ ·) this\n    · rw [← image_inter_nonempty_iff, (C_sub c.mem).right, univ_inter]\n      exact singleton_nonempty a\n    all_goals exact (C_sub c.mem).left.inter <| (T1Space.t1 a).preimage π_cont\n  · rw [@iInter_of_empty _ _ <| not_nonempty_iff.mp hC, image_univ_of_surjective π_surj]\n\n"}
{"name":"image_subset_closure_compl_image_compl_of_isOpen","module":"Mathlib.Topology.ExtremallyDisconnected","initialProofState":"A E : Type u\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace E\nρ : E → A\nρ_cont : Continuous ρ\nρ_surj : Function.Surjective ρ\nzorn_subset : ∀ (E₀ : Set E), Ne E₀ Set.univ → IsClosed E₀ → Ne (Set.image ρ E₀) Set.univ\nG : Set E\nhG : IsOpen G\n⊢ HasSubset.Subset (Set.image ρ G) (closure (HasCompl.compl (Set.image ρ (HasCompl.compl G))))","decl":"/-- Lemma 2.1 in [Gleason, *Projective topological spaces*][gleason1958]:\nif $\\rho$ is a continuous surjection from a topological space $E$ to a topological space $A$\nsatisfying the \"Zorn subset condition\", then $\\rho(G)$ is contained in\nthe closure of $A \\setminus \\rho(E \\setminus G)$ for any open set $G$ of $E$. -/\nlemma image_subset_closure_compl_image_compl_of_isOpen {ρ : E → A} (ρ_cont : Continuous ρ)\n    (ρ_surj : ρ.Surjective) (zorn_subset : ∀ E₀ : Set E, E₀ ≠ univ → IsClosed E₀ → ρ '' E₀ ≠ univ)\n    {G : Set E} (hG : IsOpen G) : ρ '' G ⊆ closure ((ρ '' Gᶜ)ᶜ) := by\n  -- suffices to prove for nonempty $G$\n  by_cases G_empty : G = ∅\n  · simpa only [G_empty, image_empty] using empty_subset _\n  · -- let $a \\in \\rho(G)$\n    intro a ha\n    rw [mem_closure_iff]\n    -- let $N$ be a neighbourhood of $a$\n    intro N N_open hN\n    -- get $x \\in A$ from nonempty open $G \\cap \\rho^{-1}(N)$\n    rcases (G.mem_image ρ a).mp ha with ⟨e, he, rfl⟩\n    have nonempty : (G ∩ ρ⁻¹' N).Nonempty := ⟨e, mem_inter he <| mem_preimage.mpr hN⟩\n    have is_open : IsOpen <| G ∩ ρ⁻¹' N := hG.inter <| N_open.preimage ρ_cont\n    have ne_univ : ρ '' (G ∩ ρ⁻¹' N)ᶜ ≠ univ :=\n      zorn_subset _ (compl_ne_univ.mpr nonempty) is_open.isClosed_compl\n    rcases nonempty_compl.mpr ne_univ with ⟨x, hx⟩\n    -- prove $x \\in N \\cap (A \\setminus \\rho(E \\setminus G))$\n    have hx' : x ∈ (ρ '' Gᶜ)ᶜ := fun h => hx <| image_subset ρ (by simp) h\n    rcases ρ_surj x with ⟨y, rfl⟩\n    have hy : y ∈ G ∩ ρ⁻¹' N := by simpa using mt (mem_image_of_mem ρ) <| mem_compl hx\n    exact ⟨ρ y, mem_inter (mem_preimage.mp <| mem_of_mem_inter_right hy) hx'⟩\n\n"}
{"name":"ExtremallyDisconnected.disjoint_closure_of_disjoint_isOpen","module":"Mathlib.Topology.ExtremallyDisconnected","initialProofState":"A : Type u\ninst✝¹ : TopologicalSpace A\ninst✝ : ExtremallyDisconnected A\nU₁ U₂ : Set A\nh : Disjoint U₁ U₂\nhU₁ : IsOpen U₁\nhU₂ : IsOpen U₂\n⊢ Disjoint (closure U₁) (closure U₂)","decl":"/-- Lemma 2.2 in [Gleason, *Projective topological spaces*][gleason1958]:\nin an extremally disconnected space, if $U_1$ and $U_2$ are disjoint open sets,\nthen $\\overline{U_1}$ and $\\overline{U_2}$ are also disjoint. -/\nlemma ExtremallyDisconnected.disjoint_closure_of_disjoint_isOpen [ExtremallyDisconnected A]\n    {U₁ U₂ : Set A} (h : Disjoint U₁ U₂) (hU₁ : IsOpen U₁) (hU₂ : IsOpen U₂) :\n    Disjoint (closure U₁) (closure U₂) :=\n  (h.closure_right hU₁).closure_left <| open_closure U₂ hU₂\n\n"}
{"name":"CompactT2.ExtremallyDisconnected.projective","module":"Mathlib.Topology.ExtremallyDisconnected","initialProofState":"A : Type u\ninst✝³ : TopologicalSpace A\ninst✝² : ExtremallyDisconnected A\ninst✝¹ : CompactSpace A\ninst✝ : T2Space A\n⊢ CompactT2.Projective A","decl":"/-- Theorem 2.5 in [Gleason, *Projective topological spaces*][gleason1958]:\nin the category of compact spaces and continuous maps,\nthe projective spaces are precisely the extremally disconnected spaces. -/\nprotected theorem CompactT2.ExtremallyDisconnected.projective [ExtremallyDisconnected A]\n    [CompactSpace A] [T2Space A] : CompactT2.Projective A := by\n  -- let $B$ and $C$ be compact; let $f : B \\twoheadrightarrow C$ and $\\phi : A \\to C$ be continuous\n  intro B C _ _ _ _ _ _ φ f φ_cont f_cont f_surj\n  -- let $D := \\{(a, b) : \\phi(a) = f(b)\\}$ with projections $\\pi_1 : D \\to A$ and $\\pi_2 : D \\to B$\n  let D : Set <| A × B := {x | φ x.fst = f x.snd}\n  have D_comp : CompactSpace D := isCompact_iff_compactSpace.mp\n    (isClosed_eq (φ_cont.comp continuous_fst) (f_cont.comp continuous_snd)).isCompact\n  -- apply Lemma 2.4 to get closed $E$ satisfying \"Zorn subset condition\"\n  let π₁ : D → A := Prod.fst ∘ Subtype.val\n  have π₁_cont : Continuous π₁ := continuous_fst.comp continuous_subtype_val\n  have π₁_surj : π₁.Surjective := fun a => ⟨⟨⟨a, _⟩, (f_surj <| φ a).choose_spec.symm⟩, rfl⟩\n  rcases exists_compact_surjective_zorn_subset π₁_cont π₁_surj with ⟨E, _, E_onto, E_min⟩\n  -- apply Lemma 2.3 to get homeomorphism $\\pi_1|_E : E \\to A$\n  let ρ : E → A := E.restrict π₁\n  have ρ_cont : Continuous ρ := π₁_cont.continuousOn.restrict\n  have ρ_surj : ρ.Surjective := fun a => by\n    rcases (E_onto ▸ mem_univ a : a ∈ π₁ '' E) with ⟨d, ⟨hd, rfl⟩⟩; exact ⟨⟨d, hd⟩, rfl⟩\n  let ρ' := ExtremallyDisconnected.homeoCompactToT2 ρ_cont ρ_surj E_min\n  -- prove $\\rho := \\pi_2|_E \\circ \\pi_1|_E^{-1}$ satisfies $\\phi = f \\circ \\rho$\n  let π₂ : D → B := Prod.snd ∘ Subtype.val\n  have π₂_cont : Continuous π₂ := continuous_snd.comp continuous_subtype_val\n  refine ⟨E.restrict π₂ ∘ ρ'.symm, ⟨π₂_cont.continuousOn.restrict.comp ρ'.symm.continuous, ?_⟩⟩\n  suffices f ∘ E.restrict π₂ = φ ∘ ρ' by\n    rw [← comp_assoc, this, comp_assoc, Homeomorph.self_comp_symm, comp_id]\n  ext x\n  exact x.val.mem.symm\n\n"}
{"name":"CompactT2.projective_iff_extremallyDisconnected","module":"Mathlib.Topology.ExtremallyDisconnected","initialProofState":"A : Type u\ninst✝² : TopologicalSpace A\ninst✝¹ : CompactSpace A\ninst✝ : T2Space A\n⊢ Iff (CompactT2.Projective A) (ExtremallyDisconnected A)","decl":"protected theorem CompactT2.projective_iff_extremallyDisconnected [CompactSpace A] [T2Space A] :\n    Projective A ↔ ExtremallyDisconnected A :=\n  ⟨Projective.extremallyDisconnected, fun _ => ExtremallyDisconnected.projective⟩\n\n"}
{"name":"instExtremallyDisconnected","module":"Mathlib.Topology.ExtremallyDisconnected","initialProofState":"ι : Type u_1\nπ : ι → Type u_2\ninst✝ : (i : ι) → TopologicalSpace (π i)\nh₀ : ∀ (i : ι), ExtremallyDisconnected (π i)\n⊢ ExtremallyDisconnected (Sigma fun i => π i)","decl":"/-- The sigma-type of extremally disconnected spaces is extremally disconnected. -/\ninstance instExtremallyDisconnected {ι : Type*} {π : ι → Type*} [∀ i, TopologicalSpace (π i)]\n    [h₀ : ∀ i, ExtremallyDisconnected (π i)] : ExtremallyDisconnected (Σ i, π i) := by\n  constructor\n  intro s hs\n  rw [isOpen_sigma_iff] at hs ⊢\n  intro i\n  rcases h₀ i with ⟨h₀⟩\n  suffices h : Sigma.mk i ⁻¹' closure s = closure (Sigma.mk i ⁻¹' s) by\n    rw [h]\n    exact h₀ _ (hs i)\n  apply IsOpenMap.preimage_closure_eq_closure_preimage\n  · intro U _\n    rw [isOpen_sigma_iff]\n    intro j\n    by_cases ij : i = j\n    · rwa [← ij, sigma_mk_preimage_image_eq_self]\n    · rw [sigma_mk_preimage_image' ij]\n      exact isOpen_empty\n  · continuity\n\n"}
