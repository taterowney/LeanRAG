{"name":"IsLocalization.mem_coeSubmodule","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nI : Ideal R\nx : S\n⊢ Iff (Membership.mem (IsLocalization.coeSubmodule S I) x) (Exists fun y => And (Membership.mem I y) (Eq ((algebraMap R S) y) x))","decl":"theorem mem_coeSubmodule (I : Ideal R) {x : S} :\n    x ∈ coeSubmodule S I ↔ ∃ y : R, y ∈ I ∧ algebraMap R S y = x :=\n  Iff.rfl\n\n"}
{"name":"IsLocalization.coeSubmodule_mono","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nI J : Ideal R\nh : LE.le I J\n⊢ LE.le (IsLocalization.coeSubmodule S I) (IsLocalization.coeSubmodule S J)","decl":"theorem coeSubmodule_mono {I J : Ideal R} (h : I ≤ J) : coeSubmodule S I ≤ coeSubmodule S J :=\n  Submodule.map_mono h\n\n"}
{"name":"IsLocalization.coeSubmodule_bot","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ Eq (IsLocalization.coeSubmodule S Bot.bot) Bot.bot","decl":"@[simp]\ntheorem coeSubmodule_bot : coeSubmodule S (⊥ : Ideal R) = ⊥ := by\n  rw [coeSubmodule, Submodule.map_bot]\n\n"}
{"name":"IsLocalization.coeSubmodule_top","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ Eq (IsLocalization.coeSubmodule S Top.top) 1","decl":"@[simp]\ntheorem coeSubmodule_top : coeSubmodule S (⊤ : Ideal R) = 1 := by\n  rw [coeSubmodule, Submodule.map_top, Submodule.one_eq_range]\n\n"}
{"name":"IsLocalization.coeSubmodule_sup","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nI J : Ideal R\n⊢ Eq (IsLocalization.coeSubmodule S (Max.max I J)) (Max.max (IsLocalization.coeSubmodule S I) (IsLocalization.coeSubmodule S J))","decl":"@[simp]\ntheorem coeSubmodule_sup (I J : Ideal R) :\n    coeSubmodule S (I ⊔ J) = coeSubmodule S I ⊔ coeSubmodule S J :=\n  Submodule.map_sup _ _ _\n\n"}
{"name":"IsLocalization.coeSubmodule_mul","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nI J : Ideal R\n⊢ Eq (IsLocalization.coeSubmodule S (HMul.hMul I J)) (HMul.hMul (IsLocalization.coeSubmodule S I) (IsLocalization.coeSubmodule S J))","decl":"@[simp]\ntheorem coeSubmodule_mul (I J : Ideal R) :\n    coeSubmodule S (I * J) = coeSubmodule S I * coeSubmodule S J :=\n  Submodule.map_mul _ _ (Algebra.ofId R S)\n\n"}
{"name":"IsLocalization.coeSubmodule_fg","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nhS : Function.Injective ⇑(algebraMap R S)\nI : Ideal R\n⊢ Iff (IsLocalization.coeSubmodule S I).FG (Submodule.FG I)","decl":"theorem coeSubmodule_fg (hS : Function.Injective (algebraMap R S)) (I : Ideal R) :\n    Submodule.FG (coeSubmodule S I) ↔ Submodule.FG I :=\n  ⟨Submodule.fg_of_fg_map_injective _ hS, Submodule.FG.map _⟩\n\n"}
{"name":"IsLocalization.coeSubmodule_span","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\ns : Set R\n⊢ Eq (IsLocalization.coeSubmodule S (Ideal.span s)) (Submodule.span R (Set.image (⇑(algebraMap R S)) s))","decl":"@[simp]\ntheorem coeSubmodule_span (s : Set R) :\n    coeSubmodule S (Ideal.span s) = Submodule.span R (algebraMap R S '' s) := by\n  rw [IsLocalization.coeSubmodule, Ideal.span, Submodule.map_span]\n  rfl\n\n"}
{"name":"IsLocalization.coeSubmodule_span_singleton","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nx : R\n⊢ Eq (IsLocalization.coeSubmodule S (Ideal.span (Singleton.singleton x))) (Submodule.span R (Singleton.singleton ((algebraMap R S) x)))","decl":"theorem coeSubmodule_span_singleton (x : R) :\n    coeSubmodule S (Ideal.span {x}) = Submodule.span R {(algebraMap R S) x} := by\n  rw [coeSubmodule_span, Set.image_singleton]\n\n"}
{"name":"IsLocalization.isNoetherianRing","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nh : IsNoetherianRing R\n⊢ IsNoetherianRing S","decl":"include M in\ntheorem isNoetherianRing (h : IsNoetherianRing R) : IsNoetherianRing S := by\n  rw [isNoetherianRing_iff, isNoetherian_iff] at h ⊢\n  exact OrderEmbedding.wellFounded (IsLocalization.orderEmbedding M S).dual h\n\n"}
{"name":"IsLocalization.coeSubmodule_le_coeSubmodule","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_3\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_4\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nh : LE.le M (nonZeroDivisors R)\nI J : Ideal R\n⊢ Iff (LE.le (IsLocalization.coeSubmodule S I) (IsLocalization.coeSubmodule S J)) (LE.le I J)","decl":"@[mono]\ntheorem coeSubmodule_le_coeSubmodule (h : M ≤ nonZeroDivisors R) {I J : Ideal R} :\n    coeSubmodule S I ≤ coeSubmodule S J ↔ I ≤ J :=\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specify the value of `f` here:\n  Submodule.map_le_map_iff_of_injective (f := Algebra.linearMap R S) (IsLocalization.injective _ h)\n    _ _\n\n"}
{"name":"IsLocalization.coeSubmodule_strictMono","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_3\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_4\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nh : LE.le M (nonZeroDivisors R)\n⊢ StrictMono (IsLocalization.coeSubmodule S)","decl":"@[mono]\ntheorem coeSubmodule_strictMono (h : M ≤ nonZeroDivisors R) :\n    StrictMono (coeSubmodule S : Ideal R → Submodule R S) :=\n  strictMono_of_le_iff_le fun _ _ => (coeSubmodule_le_coeSubmodule h).symm\n\n"}
{"name":"IsLocalization.coeSubmodule_injective","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_3\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_4\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nh : LE.le M (nonZeroDivisors R)\n⊢ Function.Injective (IsLocalization.coeSubmodule S)","decl":"theorem coeSubmodule_injective (h : M ≤ nonZeroDivisors R) :\n    Function.Injective (coeSubmodule S : Ideal R → Submodule R S) :=\n  injective_of_le_imp_le _ fun hl => (coeSubmodule_le_coeSubmodule h).mp hl\n\n"}
{"name":"IsLocalization.coeSubmodule_isPrincipal","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_3\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_4\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nI : Ideal R\nh : LE.le M (nonZeroDivisors R)\n⊢ Iff (IsLocalization.coeSubmodule S I).IsPrincipal (Submodule.IsPrincipal I)","decl":"theorem coeSubmodule_isPrincipal {I : Ideal R} (h : M ≤ nonZeroDivisors R) :\n    (coeSubmodule S I).IsPrincipal ↔ I.IsPrincipal := by\n  constructor <;> rintro ⟨⟨x, hx⟩⟩\n  · have x_mem : x ∈ coeSubmodule S I := hx.symm ▸ Submodule.mem_span_singleton_self x\n    obtain ⟨x, _, rfl⟩ := (mem_coeSubmodule _ _).mp x_mem\n    refine ⟨⟨x, coeSubmodule_injective S h ?_⟩⟩\n    rw [Ideal.submodule_span_eq, hx, coeSubmodule_span_singleton]\n  · refine ⟨⟨algebraMap R S x, ?_⟩⟩\n    rw [hx, Ideal.submodule_span_eq, coeSubmodule_span_singleton]\n\n"}
{"name":"IsLocalization.mem_span_iff","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\ninst✝⁴ : IsLocalization M S\nN : Type u_3\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : IsScalarTower R S N\nx : N\na : Set N\n⊢ Iff (Membership.mem (Submodule.span S a) x) (Exists fun y => And (Membership.mem (Submodule.span R a) y) (Exists fun z => Eq x (HSMul.hSMul (IsLocalization.mk' S 1 z) y)))","decl":"theorem mem_span_iff {N : Type*} [AddCommMonoid N] [Module R N] [Module S N] [IsScalarTower R S N]\n    {x : N} {a : Set N} :\n    x ∈ Submodule.span S a ↔ ∃ y ∈ Submodule.span R a, ∃ z : M, x = mk' S 1 z • y := by\n  constructor\n  · intro h\n    refine Submodule.span_induction ?_ ?_ ?_ ?_ h\n    · rintro x hx\n      exact ⟨x, Submodule.subset_span hx, 1, by rw [mk'_one, map_one, one_smul]⟩\n    · exact ⟨0, Submodule.zero_mem _, 1, by rw [mk'_one, map_one, one_smul]⟩\n    · rintro _ _ _ _ ⟨y, hy, z, rfl⟩ ⟨y', hy', z', rfl⟩\n      refine\n        ⟨(z' : R) • y + (z : R) • y',\n          Submodule.add_mem _ (Submodule.smul_mem _ _ hy) (Submodule.smul_mem _ _ hy'), z * z', ?_⟩\n      rw [smul_add, ← IsScalarTower.algebraMap_smul S (z : R), ←\n        IsScalarTower.algebraMap_smul S (z' : R), smul_smul, smul_smul]\n      congr 1\n      · rw [← mul_one (1 : R), mk'_mul, mul_assoc, mk'_spec, map_one, mul_one, mul_one]\n      · rw [← mul_one (1 : R), mk'_mul, mul_right_comm, mk'_spec, map_one, mul_one, one_mul]\n    · rintro a _ _ ⟨y, hy, z, rfl⟩\n      obtain ⟨y', z', rfl⟩ := mk'_surjective M a\n      refine ⟨y' • y, Submodule.smul_mem _ _ hy, z' * z, ?_⟩\n      rw [← IsScalarTower.algebraMap_smul S y', smul_smul, ← mk'_mul, smul_smul,\n        mul_comm (mk' S _ _), mul_mk'_eq_mk'_of_mul]\n  · rintro ⟨y, hy, z, rfl⟩\n    exact Submodule.smul_mem _ _ (Submodule.span_subset_span R S _ hy)\n\n"}
{"name":"IsLocalization.mem_span_map","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : S\na : Set R\n⊢ Iff (Membership.mem (Ideal.span (Set.image (⇑(algebraMap R S)) a)) x) (Exists fun y => And (Membership.mem (Ideal.span a) y) (Exists fun z => Eq x (IsLocalization.mk' S y z)))","decl":"theorem mem_span_map {x : S} {a : Set R} :\n    x ∈ Ideal.span (algebraMap R S '' a) ↔ ∃ y ∈ Ideal.span a, ∃ z : M, x = mk' S y z := by\n  refine (mem_span_iff M).trans ?_\n  constructor\n  · rw [← coeSubmodule_span]\n    rintro ⟨_, ⟨y, hy, rfl⟩, z, hz⟩\n    refine ⟨y, hy, z, ?_⟩\n    rw [hz, Algebra.linearMap_apply, smul_eq_mul, mul_comm, mul_mk'_eq_mk'_of_mul, mul_one]\n  · rintro ⟨y, hy, z, hz⟩\n    refine ⟨algebraMap R S y, Submodule.map_mem_span_algebraMap_image _ _ hy, z, ?_⟩\n    rw [hz, smul_eq_mul, mul_comm, mul_mk'_eq_mk'_of_mul, mul_one]\n\n"}
{"name":"IsFractionRing.coeSubmodule_le_coeSubmodule","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_3\nK : Type u_4\ninst✝³ : CommRing R\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI J : Ideal R\n⊢ Iff (LE.le (IsLocalization.coeSubmodule K I) (IsLocalization.coeSubmodule K J)) (LE.le I J)","decl":"@[simp, mono]\ntheorem coeSubmodule_le_coeSubmodule {I J : Ideal R} :\n    coeSubmodule K I ≤ coeSubmodule K J ↔ I ≤ J :=\n  IsLocalization.coeSubmodule_le_coeSubmodule le_rfl\n\n"}
{"name":"IsFractionRing.coeSubmodule_strictMono","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_3\nK : Type u_4\ninst✝³ : CommRing R\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ StrictMono (IsLocalization.coeSubmodule K)","decl":"@[mono]\ntheorem coeSubmodule_strictMono : StrictMono (coeSubmodule K : Ideal R → Submodule R K) :=\n  strictMono_of_le_iff_le fun _ _ => coeSubmodule_le_coeSubmodule.symm\n\n"}
{"name":"IsFractionRing.coeSubmodule_injective","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_3\nK : Type u_4\ninst✝³ : CommRing R\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Function.Injective (IsLocalization.coeSubmodule K)","decl":"theorem coeSubmodule_injective : Function.Injective (coeSubmodule K : Ideal R → Submodule R K) :=\n  injective_of_le_imp_le _ fun hl => coeSubmodule_le_coeSubmodule.mp hl\n\n"}
{"name":"IsFractionRing.coeSubmodule_isPrincipal","module":"Mathlib.RingTheory.Localization.Submodule","initialProofState":"R : Type u_3\nK : Type u_4\ninst✝³ : CommRing R\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\nI : Ideal R\n⊢ Iff (IsLocalization.coeSubmodule K I).IsPrincipal (Submodule.IsPrincipal I)","decl":"@[simp]\ntheorem coeSubmodule_isPrincipal {I : Ideal R} : (coeSubmodule K I).IsPrincipal ↔ I.IsPrincipal :=\n  IsLocalization.coeSubmodule_isPrincipal _ le_rfl\n\n"}
