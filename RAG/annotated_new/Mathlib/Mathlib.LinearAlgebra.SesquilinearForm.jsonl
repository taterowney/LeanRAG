{"name":"LinearMap.isOrtho_def","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nR₂ : Type u_3\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring R₁\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : Module R₁ M₁\ninst✝⁴ : CommSemiring R₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI₁ : RingHom R₁ R\nI₂ : RingHom R₂ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₂ M)\nx : M₁\ny : M₂\n⊢ Iff (B.IsOrtho x y) (Eq ((B x) y) 0)","decl":"theorem isOrtho_def {B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M} {x y} : B.IsOrtho x y ↔ B x y = 0 :=\n  Iff.rfl\n\n"}
{"name":"LinearMap.isOrtho_zero_left","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nR₂ : Type u_3\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring R₁\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : Module R₁ M₁\ninst✝⁴ : CommSemiring R₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI₁ : RingHom R₁ R\nI₂ : RingHom R₂ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₂ M)\nx : M₂\n⊢ B.IsOrtho 0 x","decl":"theorem isOrtho_zero_left (B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M) (x) : IsOrtho B (0 : M₁) x := by\n  dsimp only [IsOrtho]\n  rw [map_zero B, zero_apply]\n\n"}
{"name":"LinearMap.isOrtho_zero_right","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nR₂ : Type u_3\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring R₁\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : Module R₁ M₁\ninst✝⁴ : CommSemiring R₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI₁ : RingHom R₁ R\nI₂ : RingHom R₂ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₂ M)\nx : M₁\n⊢ B.IsOrtho x 0","decl":"theorem isOrtho_zero_right (B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M) (x) : IsOrtho B x (0 : M₂) :=\n  map_zero (B x)\n\n"}
{"name":"LinearMap.isOrtho_flip","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI₁ I₁' : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₁' M₁ M)\nx y : M₁\n⊢ Iff (B.IsOrtho x y) (B.flip.IsOrtho y x)","decl":"theorem isOrtho_flip {B : M₁ →ₛₗ[I₁] M₁ →ₛₗ[I₁'] M} {x y} : B.IsOrtho x y ↔ B.flip.IsOrtho y x := by\n  simp_rw [isOrtho_def, flip_apply]\n\n"}
{"name":"LinearMap.isOrthoᵢ_def","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\nn : Type u_19\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI₁ I₁' : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₁' M₁ M)\nv : n → M₁\n⊢ Iff (B.IsOrthoᵢ v) (∀ (i j : n), Ne i j → Eq ((B (v i)) (v j)) 0)","decl":"theorem isOrthoᵢ_def {B : M₁ →ₛₗ[I₁] M₁ →ₛₗ[I₁'] M} {v : n → M₁} :\n    B.IsOrthoᵢ v ↔ ∀ i j : n, i ≠ j → B (v i) (v j) = 0 :=\n  Iff.rfl\n\n"}
{"name":"LinearMap.isOrthoᵢ_flip","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\nn : Type u_19\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI₁ I₁' : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₁' M₁ M)\nv : n → M₁\n⊢ Iff (B.IsOrthoᵢ v) (B.flip.IsOrthoᵢ v)","decl":"theorem isOrthoᵢ_flip (B : M₁ →ₛₗ[I₁] M₁ →ₛₗ[I₁'] M) {v : n → M₁} :\n    B.IsOrthoᵢ v ↔ B.flip.IsOrthoᵢ v := by\n  simp_rw [isOrthoᵢ_def]\n  constructor <;> exact fun h i j hij ↦ h j i hij.symm\n\n"}
{"name":"LinearMap.ortho_smul_left","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"K : Type u_13\nK₁ : Type u_14\nK₂ : Type u_15\nV : Type u_16\nV₁ : Type u_17\nV₂ : Type u_18\ninst✝⁸ : Field K\ninst✝⁷ : AddCommGroup V\ninst✝⁶ : Module K V\ninst✝⁵ : Field K₁\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module K₁ V₁\ninst✝² : Field K₂\ninst✝¹ : AddCommGroup V₂\ninst✝ : Module K₂ V₂\nI₁ : RingHom K₁ K\nI₂ : RingHom K₂ K\nB : LinearMap I₁ V₁ (LinearMap I₂ V₂ V)\nx : V₁\ny : V₂\na : K₁\nha : Ne a 0\n⊢ Iff (B.IsOrtho x y) (B.IsOrtho (HSMul.hSMul a x) y)","decl":"theorem ortho_smul_left {B : V₁ →ₛₗ[I₁] V₂ →ₛₗ[I₂] V} {x y} {a : K₁} (ha : a ≠ 0) :\n    IsOrtho B x y ↔ IsOrtho B (a • x) y := by\n  dsimp only [IsOrtho]\n  constructor <;> intro H\n  · rw [map_smulₛₗ₂, H, smul_zero]\n  · rw [map_smulₛₗ₂, smul_eq_zero] at H\n    cases' H with H H\n    · rw [map_eq_zero I₁] at H\n      trivial\n    · exact H\n\n-- todo: this also holds for [CommRing R] [IsDomain R] when J₂ is invertible\n"}
{"name":"LinearMap.ortho_smul_right","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"K : Type u_13\nK₁ : Type u_14\nK₂ : Type u_15\nV : Type u_16\nV₁ : Type u_17\nV₂ : Type u_18\ninst✝⁸ : Field K\ninst✝⁷ : AddCommGroup V\ninst✝⁶ : Module K V\ninst✝⁵ : Field K₁\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module K₁ V₁\ninst✝² : Field K₂\ninst✝¹ : AddCommGroup V₂\ninst✝ : Module K₂ V₂\nI₁ : RingHom K₁ K\nI₂ : RingHom K₂ K\nB : LinearMap I₁ V₁ (LinearMap I₂ V₂ V)\nx : V₁\ny : V₂\na : K₂\nha : Ne a 0\n⊢ Iff (B.IsOrtho x y) (B.IsOrtho x (HSMul.hSMul a y))","decl":"theorem ortho_smul_right {B : V₁ →ₛₗ[I₁] V₂ →ₛₗ[I₂] V} {x y} {a : K₂} {ha : a ≠ 0} :\n    IsOrtho B x y ↔ IsOrtho B x (a • y) := by\n  dsimp only [IsOrtho]\n  constructor <;> intro H\n  · rw [map_smulₛₗ, H, smul_zero]\n  · rw [map_smulₛₗ, smul_eq_zero] at H\n    cases' H with H H\n    · simp only [map_eq_zero] at H\n      exfalso\n      exact ha H\n    · exact H\n\n"}
{"name":"LinearMap.linearIndependent_of_isOrthoᵢ","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"K : Type u_13\nK₁ : Type u_14\nV : Type u_16\nV₁ : Type u_17\nn : Type u_19\ninst✝⁵ : Field K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\ninst✝² : Field K₁\ninst✝¹ : AddCommGroup V₁\ninst✝ : Module K₁ V₁\nI₁ I₁' : RingHom K₁ K\nB : LinearMap I₁ V₁ (LinearMap I₁' V₁ V)\nv : n → V₁\nhv₁ : B.IsOrthoᵢ v\nhv₂ : ∀ (i : n), Not (B.IsOrtho (v i) (v i))\n⊢ LinearIndependent K₁ v","decl":"/-- A set of orthogonal vectors `v` with respect to some sesquilinear map `B` is linearly\n  independent if for all `i`, `B (v i) (v i) ≠ 0`. -/\ntheorem linearIndependent_of_isOrthoᵢ {B : V₁ →ₛₗ[I₁] V₁ →ₛₗ[I₁'] V} {v : n → V₁}\n    (hv₁ : B.IsOrthoᵢ v) (hv₂ : ∀ i, ¬B.IsOrtho (v i) (v i)) : LinearIndependent K₁ v := by\n  classical\n    rw [linearIndependent_iff']\n    intro s w hs i hi\n    have : B (s.sum fun i : n ↦ w i • v i) (v i) = 0 := by rw [hs, map_zero, zero_apply]\n    have hsum : (s.sum fun j : n ↦ I₁ (w j) • B (v j) (v i)) = I₁ (w i) • B (v i) (v i) := by\n      apply Finset.sum_eq_single_of_mem i hi\n      intro j _hj hij\n      rw [isOrthoᵢ_def.1 hv₁ _ _ hij, smul_zero]\n    simp_rw [B.map_sum₂, map_smulₛₗ₂, hsum] at this\n    apply (map_eq_zero I₁).mp\n    exact (smul_eq_zero.mp this).elim _root_.id (hv₂ i · |>.elim)\n\n"}
{"name":"LinearMap.IsRefl.eq_zero","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : CommSemiring R₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nH : B.IsRefl\nx y : M₁\na✝ : Eq ((B x) y) 0\n⊢ Eq ((B y) x) 0","decl":"theorem eq_zero : ∀ {x y}, B x y = 0 → B y x = 0 := fun {x y} ↦ H x y\n\n"}
{"name":"LinearMap.IsRefl.eq_iff","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : CommSemiring R₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nH : B.IsRefl\nx y : M₁\n⊢ Iff (Eq ((B x) y) 0) (Eq ((B y) x) 0)","decl":"theorem eq_iff {x y} : B x y = 0 ↔ B y x = 0 := ⟨H x y, H y x⟩\n\n"}
{"name":"LinearMap.IsRefl.ortho_comm","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : CommSemiring R₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nH : B.IsRefl\nx y : M₁\n⊢ Iff (B.IsOrtho x y) (B.IsOrtho y x)","decl":"theorem ortho_comm {x y} : IsOrtho B x y ↔ IsOrtho B y x :=\n  ⟨eq_zero H, eq_zero H⟩\n\n"}
{"name":"LinearMap.IsRefl.domRestrict","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : CommSemiring R₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nH : B.IsRefl\np : Submodule R₁ M₁\n⊢ (B.domRestrict₁₂ p p).IsRefl","decl":"theorem domRestrict (p : Submodule R₁ M₁) : (B.domRestrict₁₂ p p).IsRefl :=\n  fun _ _ ↦ by\n  simp_rw [domRestrict₁₂_apply]\n  exact H _ _\n"}
{"name":"LinearMap.IsRefl.flip_isRefl_iff","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : CommSemiring R₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\n⊢ Iff B.flip.IsRefl B.IsRefl","decl":"@[simp]\ntheorem flip_isRefl_iff : B.flip.IsRefl ↔ B.IsRefl :=\n  ⟨fun h x y H ↦ h y x ((B.flip_apply _ _).trans H), fun h x y ↦ h y x⟩\n\n"}
{"name":"LinearMap.IsRefl.ker_flip_eq_bot","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : CommSemiring R₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nH : B.IsRefl\nh : Eq (LinearMap.ker B) Bot.bot\n⊢ Eq (LinearMap.ker B.flip) Bot.bot","decl":"theorem ker_flip_eq_bot (H : B.IsRefl) (h : LinearMap.ker B = ⊥) : LinearMap.ker B.flip = ⊥ := by\n  refine ker_eq_bot'.mpr fun _ hx ↦ ker_eq_bot'.mp h _ ?_\n  ext\n  exact H _ _ (LinearMap.congr_fun hx _)\n\n"}
{"name":"LinearMap.IsRefl.ker_eq_bot_iff_ker_flip_eq_bot","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : CommSemiring R₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nH : B.IsRefl\n⊢ Iff (Eq (LinearMap.ker B) Bot.bot) (Eq (LinearMap.ker B.flip) Bot.bot)","decl":"theorem ker_eq_bot_iff_ker_flip_eq_bot (H : B.IsRefl) :\n    LinearMap.ker B = ⊥ ↔ LinearMap.ker B.flip = ⊥ := by\n  refine ⟨ker_flip_eq_bot H, fun h ↦ ?_⟩\n  exact (congr_arg _ B.flip_flip.symm).trans (ker_flip_eq_bot (flip_isRefl_iff.mpr H) h)\n\n"}
{"name":"LinearMap.IsSymm.eq","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : RingHom R R\nB : LinearMap I M (LinearMap (RingHom.id R) M R)\nH : B.IsSymm\nx y : M\n⊢ Eq (I ((B x) y)) ((B y) x)","decl":"protected theorem eq (H : B.IsSymm) (x y) : I (B x y) = B y x :=\n  H x y\n\n"}
{"name":"LinearMap.IsSymm.isRefl","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : RingHom R R\nB : LinearMap I M (LinearMap (RingHom.id R) M R)\nH : B.IsSymm\n⊢ B.IsRefl","decl":"theorem isRefl (H : B.IsSymm) : B.IsRefl := fun x y H1 ↦ by\n  rw [← H.eq]\n  simp [H1]\n\n"}
{"name":"LinearMap.IsSymm.ortho_comm","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : RingHom R R\nB : LinearMap I M (LinearMap (RingHom.id R) M R)\nH : B.IsSymm\nx y : M\n⊢ Iff (B.IsOrtho x y) (B.IsOrtho y x)","decl":"theorem ortho_comm (H : B.IsSymm) {x y} : IsOrtho B x y ↔ IsOrtho B y x :=\n  H.isRefl.ortho_comm\n\n"}
{"name":"LinearMap.IsSymm.domRestrict","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : RingHom R R\nB : LinearMap I M (LinearMap (RingHom.id R) M R)\nH : B.IsSymm\np : Submodule R M\n⊢ (B.domRestrict₁₂ p p).IsSymm","decl":"theorem domRestrict (H : B.IsSymm) (p : Submodule R M) : (B.domRestrict₁₂ p p).IsSymm :=\n  fun _ _ ↦ by\n  simp_rw [domRestrict₁₂_apply]\n  exact H _ _\n\n"}
{"name":"LinearMap.isSymm_zero","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nI : RingHom R R\n⊢ LinearMap.IsSymm 0","decl":"@[simp]\ntheorem isSymm_zero : (0 : M →ₛₗ[I] M →ₗ[R] R).IsSymm := fun _ _ => map_zero _\n\n"}
{"name":"LinearMap.BilinMap.isSymm_iff_eq_flip","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_20\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nB : LinearMap.BilinMap R M N\n⊢ Iff (∀ (x y : M), Eq ((B x) y) ((B y) x)) (Eq B (LinearMap.flip B))","decl":"theorem BilinMap.isSymm_iff_eq_flip {N : Type*} [AddCommMonoid N] [Module R N]\n    {B : LinearMap.BilinMap R M N} : (∀ x y, B x y = B y x) ↔ B = B.flip := by\n  simp [LinearMap.ext_iff₂]\n\n"}
{"name":"LinearMap.isSymm_iff_eq_flip","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\n⊢ Iff (LinearMap.IsSymm B) (Eq B (LinearMap.flip B))","decl":"theorem isSymm_iff_eq_flip {B : LinearMap.BilinForm R M} : B.IsSymm ↔ B = B.flip :=\n  BilinMap.isSymm_iff_eq_flip\n\n"}
{"name":"LinearMap.IsAlt.self_eq_zero","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : CommSemiring R₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nH : B.IsAlt\nx : M₁\n⊢ Eq ((B x) x) 0","decl":"theorem IsAlt.self_eq_zero (x : M₁) : B x x = 0 :=\n  H x\n\n"}
{"name":"LinearMap.IsAlt.eq_of_add_add_eq_zero","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : CommSemiring R₁\ninst✝² : AddCommMonoid M₁\ninst✝¹ : Module R₁ M₁\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nH : B.IsAlt\ninst✝ : IsCancelAdd M\na b c : M₁\nhAdd : Eq (HAdd.hAdd (HAdd.hAdd a b) c) 0\n⊢ Eq ((B a) b) ((B b) c)","decl":"theorem IsAlt.eq_of_add_add_eq_zero [IsCancelAdd M] {a b c : M₁} (hAdd : a + b + c = 0) :\n    B a b = B b c := by\n  have : B a a + B a b + B a c = B a c + B b c + B c c := by\n    simp_rw [← map_add, ← map_add₂, hAdd, map_zero, LinearMap.zero_apply]\n  rw [H, H, zero_add, add_zero, add_comm] at this\n  exact add_left_cancel this\n\n"}
{"name":"LinearMap.IsAlt.neg","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : CommSemiring R₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nH : B.IsAlt\nx y : M₁\n⊢ Eq (Neg.neg ((B x) y)) ((B y) x)","decl":"theorem neg (H : B.IsAlt) (x y : M₁) : -B x y = B y x := by\n  have H1 : B (y + x) (y + x) = 0 := self_eq_zero H (y + x)\n  simp? [map_add, self_eq_zero H] at H1 says\n    simp only [map_add, add_apply, self_eq_zero H, zero_add, add_zero] at H1\n  rw [add_eq_zero_iff_neg_eq] at H1\n  exact H1\n\n"}
{"name":"LinearMap.IsAlt.isRefl","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : CommSemiring R₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nH : B.IsAlt\n⊢ B.IsRefl","decl":"theorem isRefl (H : B.IsAlt) : B.IsRefl := by\n  intro x y h\n  rw [← neg H, h, neg_zero]\n\n"}
{"name":"LinearMap.IsAlt.ortho_comm","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : CommSemiring R₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nH : B.IsAlt\nx y : M₁\n⊢ Iff (B.IsOrtho x y) (B.IsOrtho y x)","decl":"theorem ortho_comm (H : B.IsAlt) {x y} : IsOrtho B x y ↔ IsOrtho B y x :=\n  H.isRefl.ortho_comm\n\n"}
{"name":"LinearMap.isAlt_iff_eq_neg_flip","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM₁ : Type u_6\ninst✝⁵ : CommRing R\ninst✝⁴ : CommSemiring R₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\nI : RingHom R₁ R\ninst✝¹ : NoZeroDivisors R\ninst✝ : CharZero R\nB : LinearMap I M₁ (LinearMap I M₁ R)\n⊢ Iff B.IsAlt (Eq B (Neg.neg B.flip))","decl":"theorem isAlt_iff_eq_neg_flip [NoZeroDivisors R] [CharZero R] {B : M₁ →ₛₗ[I] M₁ →ₛₗ[I] R} :\n    B.IsAlt ↔ B = -B.flip := by\n  constructor <;> intro h\n  · ext\n    simp_rw [neg_apply, flip_apply]\n    exact (h.neg _ _).symm\n  intro x\n  let h' := congr_fun₂ h x x\n  simp only [neg_apply, flip_apply, ← add_eq_zero_iff_eq_neg] at h'\n  exact add_self_eq_zero.mp h'\n\n"}
{"name":"Submodule.mem_orthogonalBilin_iff","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing R₁\ninst✝³ : AddCommGroup M₁\ninst✝² : Module R₁ M₁\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nN : Submodule R₁ M₁\nm : M₁\n⊢ Iff (Membership.mem (N.orthogonalBilin B) m) (∀ (n : M₁), Membership.mem N n → B.IsOrtho n m)","decl":"@[simp]\ntheorem mem_orthogonalBilin_iff {m : M₁} : m ∈ N.orthogonalBilin B ↔ ∀ n ∈ N, B.IsOrtho n m :=\n  Iff.rfl\n\n"}
{"name":"Submodule.orthogonalBilin_le","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing R₁\ninst✝³ : AddCommGroup M₁\ninst✝² : Module R₁ M₁\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nN L : Submodule R₁ M₁\nh : LE.le N L\n⊢ LE.le (L.orthogonalBilin B) (N.orthogonalBilin B)","decl":"theorem orthogonalBilin_le (h : N ≤ L) : L.orthogonalBilin B ≤ N.orthogonalBilin B :=\n  fun _ hn l hl ↦ hn l (h hl)\n\n"}
{"name":"Submodule.le_orthogonalBilin_orthogonalBilin","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nM : Type u_5\nM₁ : Type u_6\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing R₁\ninst✝³ : AddCommGroup M₁\ninst✝² : Module R₁ M₁\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI₁ I₂ : RingHom R₁ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₁ M)\nN : Submodule R₁ M₁\nb : B.IsRefl\n⊢ LE.le N ((N.orthogonalBilin B).orthogonalBilin B)","decl":"theorem le_orthogonalBilin_orthogonalBilin (b : B.IsRefl) :\n    N ≤ (N.orthogonalBilin B).orthogonalBilin B := fun n hn _m hm ↦ b _ _ (hm n hn)\n\n"}
{"name":"LinearMap.span_singleton_inf_orthogonal_eq_bot","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"K : Type u_13\nK₁ : Type u_14\nV₁ : Type u_17\nV₂ : Type u_18\ninst✝⁵ : Field K\ninst✝⁴ : Field K₁\ninst✝³ : AddCommGroup V₁\ninst✝² : Module K₁ V₁\ninst✝¹ : AddCommGroup V₂\ninst✝ : Module K V₂\nJ₁ J₁' : RingHom K₁ K\nB : LinearMap J₁ V₁ (LinearMap J₁' V₁ V₂)\nx : V₁\nhx : Not (B.IsOrtho x x)\n⊢ Eq (Min.min (Submodule.span K₁ (Singleton.singleton x)) ((Submodule.span K₁ (Singleton.singleton x)).orthogonalBilin B)) Bot.bot","decl":"theorem span_singleton_inf_orthogonal_eq_bot (B : V₁ →ₛₗ[J₁] V₁ →ₛₗ[J₁'] V₂) (x : V₁)\n    (hx : ¬B.IsOrtho x x) : (K₁ ∙ x) ⊓ Submodule.orthogonalBilin (K₁ ∙ x) B = ⊥ := by\n  rw [← Finset.coe_singleton]\n  refine eq_bot_iff.2 fun y h ↦ ?_\n  rcases mem_span_finset.1 h.1 with ⟨μ, rfl⟩\n  replace h := h.2 x (by simp [Submodule.mem_span] : x ∈ Submodule.span K₁ ({x} : Finset V₁))\n  rw [Finset.sum_singleton] at h ⊢\n  suffices hμzero : μ x = 0 by rw [hμzero, zero_smul, Submodule.mem_bot]\n  rw [isOrtho_def, map_smulₛₗ] at h\n  exact Or.elim (smul_eq_zero.mp h)\n      (fun y ↦ by simpa using y)\n      (fun hfalse ↦ False.elim <| hx hfalse)\n\n-- ↓ This lemma only applies in fields since we use the `mul_eq_zero`\n"}
{"name":"LinearMap.orthogonal_span_singleton_eq_to_lin_ker","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"K : Type u_13\nV : Type u_16\nV₂ : Type u_18\ninst✝⁴ : Field K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\ninst✝¹ : AddCommGroup V₂\ninst✝ : Module K V₂\nJ : RingHom K K\nB : LinearMap (RingHom.id K) V (LinearMap J V V₂)\nx : V\n⊢ Eq ((Submodule.span K (Singleton.singleton x)).orthogonalBilin B) (LinearMap.ker (B x))","decl":"theorem orthogonal_span_singleton_eq_to_lin_ker {B : V →ₗ[K] V →ₛₗ[J] V₂} (x : V) :\n    Submodule.orthogonalBilin (K ∙ x) B = LinearMap.ker (B x) := by\n  ext y\n  simp_rw [Submodule.mem_orthogonalBilin_iff, LinearMap.mem_ker, Submodule.mem_span_singleton]\n  constructor\n  · exact fun h ↦ h x ⟨1, one_smul _ _⟩\n  · rintro h _ ⟨z, rfl⟩\n    rw [isOrtho_def, map_smulₛₗ₂, smul_eq_zero]\n    exact Or.intro_right _ h\n\n-- todo: Generalize this to sesquilinear maps\n"}
{"name":"LinearMap.span_singleton_sup_orthogonal_eq_top","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"K : Type u_13\nV : Type u_16\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nB : LinearMap (RingHom.id K) V (LinearMap (RingHom.id K) V K)\nx : V\nhx : Not (B.IsOrtho x x)\n⊢ Eq (Max.max (Submodule.span K (Singleton.singleton x)) ((Submodule.span K (Singleton.singleton x)).orthogonalBilin B)) Top.top","decl":"theorem span_singleton_sup_orthogonal_eq_top {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :\n    (K ∙ x) ⊔ Submodule.orthogonalBilin (N := K ∙ x) (B := B) = ⊤ := by\n  rw [orthogonal_span_singleton_eq_to_lin_ker]\n  exact (B x).span_singleton_sup_ker_eq_top hx\n\n-- todo: Generalize this to sesquilinear maps\n"}
{"name":"LinearMap.isCompl_span_singleton_orthogonal","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"K : Type u_13\nV : Type u_16\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nB : LinearMap (RingHom.id K) V (LinearMap (RingHom.id K) V K)\nx : V\nhx : Not (B.IsOrtho x x)\n⊢ IsCompl (Submodule.span K (Singleton.singleton x)) ((Submodule.span K (Singleton.singleton x)).orthogonalBilin B)","decl":"/-- Given a bilinear form `B` and some `x` such that `B x x ≠ 0`, the span of the singleton of `x`\n  is complement to its orthogonal complement. -/\ntheorem isCompl_span_singleton_orthogonal {B : V →ₗ[K] V →ₗ[K] K} {x : V} (hx : ¬B.IsOrtho x x) :\n    IsCompl (K ∙ x) (Submodule.orthogonalBilin (N := K ∙ x) (B := B)) :=\n  { disjoint := disjoint_iff.2 <| span_singleton_inf_orthogonal_eq_bot B x hx\n    codisjoint := codisjoint_iff.2 <| span_singleton_sup_orthogonal_eq_top hx }\n\n"}
{"name":"LinearMap.isAdjointPair_iff_comp_eq_compl₂","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\nM₃ : Type u_8\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nI : RingHom R R\nB : LinearMap (RingHom.id R) M (LinearMap I M M₃)\nB' : LinearMap (RingHom.id R) M₁ (LinearMap I M₁ M₃)\nf : LinearMap (RingHom.id R) M M₁\ng : LinearMap (RingHom.id R) M₁ M\n⊢ Iff (B.IsAdjointPair B' ⇑f ⇑g) (Eq (B'.comp f) (B.compl₂ g))","decl":"theorem isAdjointPair_iff_comp_eq_compl₂ : IsAdjointPair B B' f g ↔ B'.comp f = B.compl₂ g := by\n  constructor <;> intro h\n  · ext x y\n    rw [comp_apply, compl₂_apply]\n    exact h x y\n  · intro _ _\n    rw [← compl₂_apply, ← comp_apply, h]\n\n"}
{"name":"LinearMap.isAdjointPair_zero","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\nM₃ : Type u_8\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nI : RingHom R R\nB : LinearMap (RingHom.id R) M (LinearMap I M M₃)\nB' : LinearMap (RingHom.id R) M₁ (LinearMap I M₁ M₃)\n⊢ B.IsAdjointPair B' 0 0","decl":"theorem isAdjointPair_zero : IsAdjointPair B B' 0 0 := fun _ _ ↦ by\n  simp only [Pi.zero_apply, map_zero, zero_apply]\n\n"}
{"name":"LinearMap.isAdjointPair_id","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₃ : Type u_8\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nI : RingHom R R\nB : LinearMap (RingHom.id R) M (LinearMap I M M₃)\n⊢ B.IsAdjointPair B id id","decl":"theorem isAdjointPair_id : IsAdjointPair B B (_root_.id : M → M) (_root_.id : M → M) :=\n  fun _ _ ↦ rfl\n\n"}
{"name":"LinearMap.isAdjointPair_one","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₃ : Type u_8\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nI : RingHom R R\nB : LinearMap (RingHom.id R) M (LinearMap I M M₃)\n⊢ B.IsAdjointPair B ⇑1 ⇑1","decl":"theorem isAdjointPair_one : IsAdjointPair B B (1 : Module.End R M) (1 : Module.End R M) :=\n  isAdjointPair_id\n\n"}
{"name":"LinearMap.IsAdjointPair.add","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\nM₃ : Type u_8\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nI : RingHom R R\nB : LinearMap (RingHom.id R) M (LinearMap I M M₃)\nB' : LinearMap (RingHom.id R) M₁ (LinearMap I M₁ M₃)\nf f' : M → M₁\ng g' : M₁ → M\nh : B.IsAdjointPair B' f g\nh' : B.IsAdjointPair B' f' g'\n⊢ B.IsAdjointPair B' (HAdd.hAdd f f') (HAdd.hAdd g g')","decl":"theorem IsAdjointPair.add {f f' : M → M₁} {g g' : M₁ → M} (h : IsAdjointPair B B' f g)\n    (h' : IsAdjointPair B B' f' g') :\n    IsAdjointPair B B' (f + f') (g + g') := fun x _ ↦ by\n  rw [Pi.add_apply, Pi.add_apply, B'.map_add₂, (B x).map_add, h, h']\n\n"}
{"name":"LinearMap.IsAdjointPair.comp","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : Module R M₁\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nI : RingHom R R\nB : LinearMap (RingHom.id R) M (LinearMap I M M₃)\nB' : LinearMap (RingHom.id R) M₁ (LinearMap I M₁ M₃)\nB'' : LinearMap (RingHom.id R) M₂ (LinearMap I M₂ M₃)\nf : M → M₁\ng : M₁ → M\nf' : M₁ → M₂\ng' : M₂ → M₁\nh : B.IsAdjointPair B' f g\nh' : B'.IsAdjointPair B'' f' g'\n⊢ B.IsAdjointPair B'' (Function.comp f' f) (Function.comp g g')","decl":"theorem IsAdjointPair.comp {f : M → M₁} {g : M₁ → M} {f' : M₁ → M₂} {g' : M₂ → M₁}\n    (h : IsAdjointPair B B' f g) (h' : IsAdjointPair B' B'' f' g') :\n    IsAdjointPair B B'' (f' ∘ f) (g ∘ g') := fun _ _ ↦ by\n  rw [Function.comp_def, Function.comp_def, h', h]\n\n"}
{"name":"LinearMap.IsAdjointPair.mul","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₃ : Type u_8\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R M₃\nI : RingHom R R\nB : LinearMap (RingHom.id R) M (LinearMap I M M₃)\nf g f' g' : Module.End R M\nh : B.IsAdjointPair B ⇑f ⇑g\nh' : B.IsAdjointPair B ⇑f' ⇑g'\n⊢ B.IsAdjointPair B ⇑(HMul.hMul f f') ⇑(HMul.hMul g' g)","decl":"theorem IsAdjointPair.mul {f g f' g' : Module.End R M} (h : IsAdjointPair B B f g)\n    (h' : IsAdjointPair B B f' g') : IsAdjointPair B B (f * f') (g' * g) :=\n  h'.comp h\n\n"}
{"name":"LinearMap.IsAdjointPair.sub","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₂)\nB' : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₁ M₂)\nf f' : M → M₁\ng g' : M₁ → M\nh : B.IsAdjointPair B' f g\nh' : B.IsAdjointPair B' f' g'\n⊢ B.IsAdjointPair B' (HSub.hSub f f') (HSub.hSub g g')","decl":"theorem IsAdjointPair.sub (h : IsAdjointPair B B' f g) (h' : IsAdjointPair B B' f' g') :\n    IsAdjointPair B B' (f - f') (g - g') := fun x _ ↦ by\n  rw [Pi.sub_apply, Pi.sub_apply, B'.map_sub₂, (B x).map_sub, h, h']\n\n"}
{"name":"LinearMap.IsAdjointPair.smul","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₂)\nB' : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₁ M₂)\nf : M → M₁\ng : M₁ → M\nc : R\nh : B.IsAdjointPair B' f g\n⊢ B.IsAdjointPair B' (HSMul.hSMul c f) (HSMul.hSMul c g)","decl":"theorem IsAdjointPair.smul (c : R) (h : IsAdjointPair B B' f g) :\n    IsAdjointPair B B' (c • f) (c • g) := fun _ _ ↦ by\n  simp [h _]\n\n"}
{"name":"LinearEquiv.isAdjointPair_symm_iff","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_20\nM : Type u_21\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nf : Equiv M M\n⊢ Iff (LinearMap.IsAdjointPair B B ⇑f ⇑f.symm) (LinearMap.IsOrthogonal B ⇑f)","decl":"@[simp]\nlemma _root_.LinearEquiv.isAdjointPair_symm_iff {f : M ≃ M} :\n    LinearMap.IsAdjointPair B B f f.symm ↔ B.IsOrthogonal f :=\n  ⟨fun hf x y ↦ by simpa using hf x (f y), fun hf x y ↦ by simpa using hf x (f.symm y)⟩\n\n"}
{"name":"LinearMap.isOrthogonal_of_forall_apply_same","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_20\nM : Type u_21\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nB : LinearMap.BilinForm R M\nF : Type u_22\ninst✝¹ : FunLike F M M\ninst✝ : LinearMapClass F R M M\nf : F\nh : IsLeftRegular 2\nhB : LinearMap.IsSymm B\nhf : ∀ (x : M), Eq ((B (f x)) (f x)) ((B x) x)\n⊢ LinearMap.IsOrthogonal B ⇑f","decl":"lemma isOrthogonal_of_forall_apply_same {F : Type*} [FunLike F M M] [LinearMapClass F R M M]\n    (f : F) (h : IsLeftRegular (2 : R)) (hB : B.IsSymm) (hf : ∀ x, B (f x) (f x) = B x x) :\n    B.IsOrthogonal f := by\n  intro x y\n  suffices 2 * B (f x) (f y) = 2 * B x y from h this\n  have := hf (x + y)\n  simp only [map_add, LinearMap.add_apply, hf x, hf y, show B y x = B x y from hB.eq y x] at this\n  rw [show B (f y) (f x) = B (f x) (f y) from hB.eq (f y) (f x)] at this\n  simp only [add_assoc, add_right_inj] at this\n  simp only [← add_assoc, add_left_inj] at this\n  simpa only [← two_mul] using this\n\n"}
{"name":"LinearMap.mem_isPairSelfAdjointSubmodule","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\nB F : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₂)\nf : Module.End R M\n⊢ Iff (Membership.mem (B.isPairSelfAdjointSubmodule F) f) (B.IsPairSelfAdjoint F ⇑f)","decl":"@[simp]\ntheorem mem_isPairSelfAdjointSubmodule (f : Module.End R M) :\n    f ∈ isPairSelfAdjointSubmodule B F ↔ IsPairSelfAdjoint B F f :=\n  Iff.rfl\n\n"}
{"name":"LinearMap.isPairSelfAdjoint_equiv","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup M₁\ninst✝² : Module R M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\nB F : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₂)\ne : LinearEquiv (RingHom.id R) M₁ M\nf : Module.End R M\n⊢ Iff (B.IsPairSelfAdjoint F ⇑f) ((B.compl₁₂ ↑e ↑e).IsPairSelfAdjoint (F.compl₁₂ ↑e ↑e) ⇑(e.symm.conj f))","decl":"theorem isPairSelfAdjoint_equiv (e : M₁ ≃ₗ[R] M) (f : Module.End R M) :\n    IsPairSelfAdjoint B F f ↔\n      IsPairSelfAdjoint (B.compl₁₂ e e) (F.compl₁₂ e e) (e.symm.conj f) := by\n  have hₗ :\n    (F.compl₁₂ (↑e : M₁ →ₗ[R] M) (↑e : M₁ →ₗ[R] M)).comp (e.symm.conj f) =\n      (F.comp f).compl₁₂ (↑e : M₁ →ₗ[R] M) (↑e : M₁ →ₗ[R] M) := by\n    ext\n    simp only [LinearEquiv.symm_conj_apply, coe_comp, LinearEquiv.coe_coe, compl₁₂_apply,\n      LinearEquiv.apply_symm_apply, Function.comp_apply]\n  have hᵣ :\n    (B.compl₁₂ (↑e : M₁ →ₗ[R] M) (↑e : M₁ →ₗ[R] M)).compl₂ (e.symm.conj f) =\n      (B.compl₂ f).compl₁₂ (↑e : M₁ →ₗ[R] M) (↑e : M₁ →ₗ[R] M) := by\n    ext\n    simp only [LinearEquiv.symm_conj_apply, compl₂_apply, coe_comp, LinearEquiv.coe_coe,\n      compl₁₂_apply, LinearEquiv.apply_symm_apply, Function.comp_apply]\n  have he : Function.Surjective (⇑(↑e : M₁ →ₗ[R] M) : M₁ → M) := e.surjective\n  simp_rw [IsPairSelfAdjoint, isAdjointPair_iff_comp_eq_compl₂, hₗ, hᵣ, compl₁₂_inj he he]\n\n"}
{"name":"LinearMap.isSkewAdjoint_iff_neg_self_adjoint","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₂)\nf : M → M\n⊢ Iff (B.IsSkewAdjoint f) ((Neg.neg B).IsAdjointPair B f f)","decl":"theorem isSkewAdjoint_iff_neg_self_adjoint (f : M → M) :\n    B.IsSkewAdjoint f ↔ IsAdjointPair (-B) B f f :=\n  show (∀ x y, B (f x) y = B x ((-f) y)) ↔ ∀ x y, B (f x) y = (-B) x (f y) by simp\n\n"}
{"name":"LinearMap.mem_selfAdjointSubmodule","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₂)\nf : Module.End R M\n⊢ Iff (Membership.mem B.selfAdjointSubmodule f) (B.IsSelfAdjoint ⇑f)","decl":"@[simp]\ntheorem mem_selfAdjointSubmodule (f : Module.End R M) :\n    f ∈ B.selfAdjointSubmodule ↔ B.IsSelfAdjoint f :=\n  Iff.rfl\n\n"}
{"name":"LinearMap.mem_skewAdjointSubmodule","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₂)\nf : Module.End R M\n⊢ Iff (Membership.mem B.skewAdjointSubmodule f) (B.IsSkewAdjoint ⇑f)","decl":"@[simp]\ntheorem mem_skewAdjointSubmodule (f : Module.End R M) :\n    f ∈ B.skewAdjointSubmodule ↔ B.IsSkewAdjoint f := by\n  rw [isSkewAdjoint_iff_neg_self_adjoint]\n  exact Iff.rfl\n\n"}
{"name":"LinearMap.not_separatingLeft_zero","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nR₂ : Type u_3\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁹ : CommSemiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : CommSemiring R₁\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : Module R₁ M₁\ninst✝³ : CommSemiring R₂\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R₂ M₂\nI₁ : RingHom R₁ R\nI₂ : RingHom R₂ R\ninst✝ : Nontrivial M₁\n⊢ Not (LinearMap.SeparatingLeft 0)","decl":"/-- In a non-trivial module, zero is not non-degenerate. -/\ntheorem not_separatingLeft_zero [Nontrivial M₁] : ¬(0 : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M).SeparatingLeft :=\n  let ⟨m, hm⟩ := exists_ne (0 : M₁)\n  fun h ↦ hm (h m fun _n ↦ rfl)\n\n"}
{"name":"LinearMap.SeparatingLeft.ne_zero","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nR₂ : Type u_3\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁹ : CommSemiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\ninst✝⁶ : CommSemiring R₁\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : Module R₁ M₁\ninst✝³ : CommSemiring R₂\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R₂ M₂\nI₁ : RingHom R₁ R\nI₂ : RingHom R₂ R\ninst✝ : Nontrivial M₁\nB : LinearMap I₁ M₁ (LinearMap I₂ M₂ M)\nh : B.SeparatingLeft\n⊢ Ne B 0","decl":"theorem SeparatingLeft.ne_zero [Nontrivial M₁] {B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M}\n    (h : B.SeparatingLeft) : B ≠ 0 := fun h0 ↦ not_separatingLeft_zero M₁ M₂ I₁ I₂ <| h0 ▸ h\n\n"}
{"name":"LinearMap.SeparatingLeft.congr","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nMₗ₁ : Type u_9\nMₗ₁' : Type u_10\nMₗ₂ : Type u_11\nMₗ₂' : Type u_12\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : AddCommMonoid Mₗ₁\ninst✝⁶ : AddCommMonoid Mₗ₂\ninst✝⁵ : AddCommMonoid Mₗ₁'\ninst✝⁴ : AddCommMonoid Mₗ₂'\ninst✝³ : Module R Mₗ₁\ninst✝² : Module R Mₗ₂\ninst✝¹ : Module R Mₗ₁'\ninst✝ : Module R Mₗ₂'\nB : LinearMap (RingHom.id R) Mₗ₁ (LinearMap (RingHom.id R) Mₗ₂ M)\ne₁ : LinearEquiv (RingHom.id R) Mₗ₁ Mₗ₁'\ne₂ : LinearEquiv (RingHom.id R) Mₗ₂ Mₗ₂'\nh : B.SeparatingLeft\n⊢ ((e₁.arrowCongr (e₂.arrowCongr (LinearEquiv.refl R M))) B).SeparatingLeft","decl":"theorem SeparatingLeft.congr (h : B.SeparatingLeft) :\n    (e₁.arrowCongr (e₂.arrowCongr (LinearEquiv.refl R M)) B).SeparatingLeft := by\n  intro x hx\n  rw [← e₁.symm.map_eq_zero_iff]\n  refine h (e₁.symm x) fun y ↦ ?_\n  specialize hx (e₂ y)\n  simp only [LinearEquiv.arrowCongr_apply, LinearEquiv.symm_apply_apply,\n    LinearEquiv.map_eq_zero_iff] at hx\n  exact hx\n\n"}
{"name":"LinearMap.separatingLeft_congr_iff","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nMₗ₁ : Type u_9\nMₗ₁' : Type u_10\nMₗ₂ : Type u_11\nMₗ₂' : Type u_12\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : AddCommMonoid Mₗ₁\ninst✝⁶ : AddCommMonoid Mₗ₂\ninst✝⁵ : AddCommMonoid Mₗ₁'\ninst✝⁴ : AddCommMonoid Mₗ₂'\ninst✝³ : Module R Mₗ₁\ninst✝² : Module R Mₗ₂\ninst✝¹ : Module R Mₗ₁'\ninst✝ : Module R Mₗ₂'\nB : LinearMap (RingHom.id R) Mₗ₁ (LinearMap (RingHom.id R) Mₗ₂ M)\ne₁ : LinearEquiv (RingHom.id R) Mₗ₁ Mₗ₁'\ne₂ : LinearEquiv (RingHom.id R) Mₗ₂ Mₗ₂'\n⊢ Iff ((e₁.arrowCongr (e₂.arrowCongr (LinearEquiv.refl R M))) B).SeparatingLeft B.SeparatingLeft","decl":"@[simp]\ntheorem separatingLeft_congr_iff :\n    (e₁.arrowCongr (e₂.arrowCongr (LinearEquiv.refl R M)) B).SeparatingLeft ↔ B.SeparatingLeft :=\n  ⟨fun h ↦ by\n    convert h.congr e₁.symm e₂.symm\n    ext x y\n    simp,\n   SeparatingLeft.congr e₁ e₂⟩\n\n"}
{"name":"LinearMap.flip_separatingRight","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nR₂ : Type u_3\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : CommSemiring R₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R₁ M₁\ninst✝² : CommSemiring R₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R₂ M₂\nI₁ : RingHom R₁ R\nI₂ : RingHom R₂ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₂ M)\n⊢ Iff B.flip.SeparatingRight B.SeparatingLeft","decl":"@[simp]\ntheorem flip_separatingRight {B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M} :\n    B.flip.SeparatingRight ↔ B.SeparatingLeft :=\n  ⟨fun hB x hy ↦ hB x hy, fun hB x hy ↦ hB x hy⟩\n\n"}
{"name":"LinearMap.flip_separatingLeft","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nR₂ : Type u_3\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : CommSemiring R₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R₁ M₁\ninst✝² : CommSemiring R₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R₂ M₂\nI₁ : RingHom R₁ R\nI₂ : RingHom R₂ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₂ M)\n⊢ Iff B.flip.SeparatingLeft B.SeparatingRight","decl":"@[simp]\ntheorem flip_separatingLeft {B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M} :\n    B.flip.SeparatingLeft ↔ SeparatingRight B := by rw [← flip_separatingRight, flip_flip]\n\n"}
{"name":"LinearMap.flip_nondegenerate","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nR₂ : Type u_3\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : CommSemiring R₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R₁ M₁\ninst✝² : CommSemiring R₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R₂ M₂\nI₁ : RingHom R₁ R\nI₂ : RingHom R₂ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₂ M)\n⊢ Iff B.flip.Nondegenerate B.Nondegenerate","decl":"@[simp]\ntheorem flip_nondegenerate {B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M} : B.flip.Nondegenerate ↔ B.Nondegenerate :=\n  Iff.trans and_comm (and_congr flip_separatingRight flip_separatingLeft)\n\n"}
{"name":"LinearMap.separatingLeft_iff_linear_nontrivial","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nR₂ : Type u_3\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : CommSemiring R₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R₁ M₁\ninst✝² : CommSemiring R₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R₂ M₂\nI₁ : RingHom R₁ R\nI₂ : RingHom R₂ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₂ M)\n⊢ Iff B.SeparatingLeft (∀ (x : M₁), Eq (B x) 0 → Eq x 0)","decl":"theorem separatingLeft_iff_linear_nontrivial {B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M} :\n    B.SeparatingLeft ↔ ∀ x : M₁, B x = 0 → x = 0 := by\n  constructor <;> intro h x hB\n  · simpa only [hB, zero_apply, eq_self_iff_true, forall_const] using h x\n  have h' : B x = 0 := by\n    ext\n    rw [zero_apply]\n    exact hB _\n  exact h x h'\n\n"}
{"name":"LinearMap.separatingRight_iff_linear_flip_nontrivial","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nR₂ : Type u_3\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : CommSemiring R₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R₁ M₁\ninst✝² : CommSemiring R₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R₂ M₂\nI₁ : RingHom R₁ R\nI₂ : RingHom R₂ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₂ M)\n⊢ Iff B.SeparatingRight (∀ (y : M₂), Eq (B.flip y) 0 → Eq y 0)","decl":"theorem separatingRight_iff_linear_flip_nontrivial {B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M} :\n    B.SeparatingRight ↔ ∀ y : M₂, B.flip y = 0 → y = 0 := by\n  rw [← flip_separatingLeft, separatingLeft_iff_linear_nontrivial]\n\n"}
{"name":"LinearMap.separatingLeft_iff_ker_eq_bot","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nR₂ : Type u_3\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : CommSemiring R₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R₁ M₁\ninst✝² : CommSemiring R₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R₂ M₂\nI₁ : RingHom R₁ R\nI₂ : RingHom R₂ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₂ M)\n⊢ Iff B.SeparatingLeft (Eq (LinearMap.ker B) Bot.bot)","decl":"/-- A bilinear map is left-separating if and only if it has a trivial kernel. -/\ntheorem separatingLeft_iff_ker_eq_bot {B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M} :\n    B.SeparatingLeft ↔ LinearMap.ker B = ⊥ :=\n  Iff.trans separatingLeft_iff_linear_nontrivial LinearMap.ker_eq_bot'.symm\n\n"}
{"name":"LinearMap.separatingRight_iff_flip_ker_eq_bot","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nR₁ : Type u_2\nR₂ : Type u_3\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : CommSemiring R₁\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : Module R₁ M₁\ninst✝² : CommSemiring R₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R₂ M₂\nI₁ : RingHom R₁ R\nI₂ : RingHom R₂ R\nB : LinearMap I₁ M₁ (LinearMap I₂ M₂ M)\n⊢ Iff B.SeparatingRight (Eq (LinearMap.ker B.flip) Bot.bot)","decl":"/-- A bilinear map is right-separating if and only if its flip has a trivial kernel. -/\ntheorem separatingRight_iff_flip_ker_eq_bot {B : M₁ →ₛₗ[I₁] M₂ →ₛₗ[I₂] M} :\n    B.SeparatingRight ↔ LinearMap.ker B.flip = ⊥ := by\n  rw [← flip_separatingLeft, separatingLeft_iff_ker_eq_bot]\n\n"}
{"name":"LinearMap.IsRefl.nondegenerate_iff_separatingLeft","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R M₁\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₁)\nhB : B.IsRefl\n⊢ Iff B.Nondegenerate B.SeparatingLeft","decl":"theorem IsRefl.nondegenerate_iff_separatingLeft {B : M →ₗ[R] M →ₗ[R] M₁} (hB : B.IsRefl) :\n    B.Nondegenerate ↔ B.SeparatingLeft := by\n  refine ⟨fun h ↦ h.1, fun hB' ↦ ⟨hB', ?_⟩⟩\n  rw [separatingRight_iff_flip_ker_eq_bot, hB.ker_eq_bot_iff_ker_flip_eq_bot.mp]\n  rwa [← separatingLeft_iff_ker_eq_bot]\n\n"}
{"name":"LinearMap.IsRefl.nondegenerate_iff_separatingRight","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R M₁\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₁)\nhB : B.IsRefl\n⊢ Iff B.Nondegenerate B.SeparatingRight","decl":"theorem IsRefl.nondegenerate_iff_separatingRight {B : M →ₗ[R] M →ₗ[R] M₁} (hB : B.IsRefl) :\n    B.Nondegenerate ↔ B.SeparatingRight := by\n  refine ⟨fun h ↦ h.2, fun hB' ↦ ⟨?_, hB'⟩⟩\n  rw [separatingLeft_iff_ker_eq_bot, hB.ker_eq_bot_iff_ker_flip_eq_bot.mpr]\n  rwa [← separatingRight_iff_flip_ker_eq_bot]\n\n"}
{"name":"LinearMap.disjoint_ker_of_nondegenerate_restrict","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R M₁\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₁)\nW : Submodule R M\nhW : (B.domRestrict₁₂ W W).Nondegenerate\n⊢ Disjoint W (LinearMap.ker B)","decl":"lemma disjoint_ker_of_nondegenerate_restrict {B : M →ₗ[R] M →ₗ[R] M₁} {W : Submodule R M}\n    (hW : (B.domRestrict₁₂ W W).Nondegenerate) :\n    Disjoint W (LinearMap.ker B) := by\n  refine Submodule.disjoint_def.mpr fun x hx hx' ↦ ?_\n  let x' : W := ⟨x, hx⟩\n  suffices x' = 0 by simpa [x']\n  apply hW.1 x'\n  simp_rw [Subtype.forall, domRestrict₁₂_apply]\n  intro y hy\n  rw [mem_ker] at hx'\n  simp [x', hx']\n\n"}
{"name":"LinearMap.IsSymm.nondegenerate_restrict_of_isCompl_ker","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M R)\nhB : B.IsSymm\nW : Submodule R M\nhW : IsCompl W (LinearMap.ker B)\n⊢ (B.domRestrict₁₂ W W).Nondegenerate","decl":"lemma IsSymm.nondegenerate_restrict_of_isCompl_ker {B : M →ₗ[R] M →ₗ[R] R} (hB : B.IsSymm)\n    {W : Submodule R M} (hW : IsCompl W (LinearMap.ker B)) :\n    (B.domRestrict₁₂ W W).Nondegenerate := by\n  have hB' : (B.domRestrict₁₂ W W).IsRefl := fun x y ↦ hB.isRefl (W.subtype x) (W.subtype y)\n  rw [LinearMap.IsRefl.nondegenerate_iff_separatingLeft hB']\n  intro ⟨x, hx⟩ hx'\n  simp only [Submodule.mk_eq_zero]\n  replace hx' : ∀ y ∈ W, B x y = 0 := by simpa [Subtype.forall] using hx'\n  replace hx' : x ∈ W ⊓ ker B := by\n    refine ⟨hx, ?_⟩\n    ext y\n    obtain ⟨u, hu, v, hv, rfl⟩ : ∃ u ∈ W, ∃ v ∈ ker B, u + v = y := by\n      rw [← Submodule.mem_sup, hW.sup_eq_top]; exact Submodule.mem_top\n    suffices B x u = 0 by rw [mem_ker] at hv; simpa [← hB.eq v, hv]\n    exact hx' u hu\n  simpa [hW.inf_eq_bot] using hx'\n\n"}
{"name":"LinearMap.nondegenerate_restrict_of_disjoint_orthogonal","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R M₁\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₁)\nhB : B.IsRefl\nW : Submodule R M\nhW : Disjoint W (W.orthogonalBilin B)\n⊢ (B.domRestrict₁₂ W W).Nondegenerate","decl":"/-- The restriction of a reflexive bilinear map `B` onto a submodule `W` is\nnondegenerate if `W` has trivial intersection with its orthogonal complement,\nthat is `Disjoint W (W.orthogonalBilin B)`. -/\ntheorem nondegenerate_restrict_of_disjoint_orthogonal {B : M →ₗ[R] M →ₗ[R] M₁} (hB : B.IsRefl)\n    {W : Submodule R M} (hW : Disjoint W (W.orthogonalBilin B)) :\n    (B.domRestrict₁₂ W W).Nondegenerate := by\n  rw [(hB.domRestrict W).nondegenerate_iff_separatingLeft]\n  rintro ⟨x, hx⟩ b₁\n  rw [Submodule.mk_eq_zero, ← Submodule.mem_bot R]\n  refine hW.le_bot ⟨hx, fun y hy ↦ ?_⟩\n  specialize b₁ ⟨y, hy⟩\n  simp_rw [domRestrict₁₂_apply] at b₁\n  rw [hB.ortho_comm]\n  exact b₁\n\n"}
{"name":"LinearMap.IsOrthoᵢ.not_isOrtho_basis_self_of_separatingLeft","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\nn : Type u_19\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup M₁\ninst✝¹ : Module R M₁\nI I' : RingHom R R\ninst✝ : Nontrivial R\nB : LinearMap I M (LinearMap I' M M₁)\nv : Basis n R M\nh : B.IsOrthoᵢ ⇑v\nhB : B.SeparatingLeft\ni : n\n⊢ Not (B.IsOrtho (v i) (v i))","decl":"/-- An orthogonal basis with respect to a left-separating bilinear map has no self-orthogonal\nelements. -/\ntheorem IsOrthoᵢ.not_isOrtho_basis_self_of_separatingLeft [Nontrivial R]\n    {B : M →ₛₗ[I] M →ₛₗ[I'] M₁} {v : Basis n R M} (h : B.IsOrthoᵢ v) (hB : B.SeparatingLeft)\n    (i : n) : ¬B.IsOrtho (v i) (v i) := by\n  intro ho\n  refine v.ne_zero i (hB (v i) fun m ↦ ?_)\n  obtain ⟨vi, rfl⟩ := v.repr.symm.surjective m\n  rw [Basis.repr_symm_apply, Finsupp.linearCombination_apply, Finsupp.sum, map_sum]\n  apply Finset.sum_eq_zero\n  rintro j -\n  rw [map_smulₛₗ]\n  suffices B (v i) (v j) = 0 by rw [this, smul_zero]\n  obtain rfl | hij := eq_or_ne i j\n  · exact ho\n  · exact h hij\n\n"}
{"name":"LinearMap.IsOrthoᵢ.not_isOrtho_basis_self_of_separatingRight","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\nn : Type u_19\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup M₁\ninst✝¹ : Module R M₁\nI I' : RingHom R R\ninst✝ : Nontrivial R\nB : LinearMap I M (LinearMap I' M M₁)\nv : Basis n R M\nh : B.IsOrthoᵢ ⇑v\nhB : B.SeparatingRight\ni : n\n⊢ Not (B.IsOrtho (v i) (v i))","decl":"/-- An orthogonal basis with respect to a right-separating bilinear map has no self-orthogonal\nelements. -/\ntheorem IsOrthoᵢ.not_isOrtho_basis_self_of_separatingRight [Nontrivial R]\n    {B : M →ₛₗ[I] M →ₛₗ[I'] M₁} {v : Basis n R M} (h : B.IsOrthoᵢ v) (hB : B.SeparatingRight)\n    (i : n) : ¬B.IsOrtho (v i) (v i) := by\n  rw [isOrthoᵢ_flip] at h\n  rw [isOrtho_flip]\n  exact h.not_isOrtho_basis_self_of_separatingLeft (flip_separatingLeft.mpr hB) i\n\n"}
{"name":"LinearMap.IsOrthoᵢ.separatingLeft_of_not_isOrtho_basis_self","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\nn : Type u_19\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup M₁\ninst✝¹ : Module R M₁\ninst✝ : NoZeroSMulDivisors R M₁\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₁)\nv : Basis n R M\nhO : B.IsOrthoᵢ ⇑v\nh : ∀ (i : n), Not (B.IsOrtho (v i) (v i))\n⊢ B.SeparatingLeft","decl":"/-- Given an orthogonal basis with respect to a bilinear map, the bilinear map is left-separating if\nthe basis has no elements which are self-orthogonal. -/\ntheorem IsOrthoᵢ.separatingLeft_of_not_isOrtho_basis_self [NoZeroSMulDivisors R M₁]\n    {B : M →ₗ[R] M →ₗ[R] M₁} (v : Basis n R M) (hO : B.IsOrthoᵢ v)\n    (h : ∀ i, ¬B.IsOrtho (v i) (v i)) : B.SeparatingLeft := by\n  intro m hB\n  obtain ⟨vi, rfl⟩ := v.repr.symm.surjective m\n  rw [LinearEquiv.map_eq_zero_iff]\n  ext i\n  rw [Finsupp.zero_apply]\n  specialize hB (v i)\n  simp_rw [Basis.repr_symm_apply, Finsupp.linearCombination_apply, Finsupp.sum, map_sum₂,\n           map_smulₛₗ₂] at hB\n  rw [Finset.sum_eq_single i] at hB\n  · exact (smul_eq_zero.mp hB).elim _root_.id (h i).elim\n  · intro j _hj hij\n    replace hij : B (v j) (v i) = 0 := hO hij\n    rw [hij, RingHom.id_apply, smul_zero]\n  · intro hi\n    replace hi : vi i = 0 := Finsupp.not_mem_support_iff.mp hi\n    rw [hi, RingHom.id_apply, zero_smul]\n\n"}
{"name":"LinearMap.IsOrthoᵢ.separatingRight_iff_not_isOrtho_basis_self","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\nn : Type u_19\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup M₁\ninst✝¹ : Module R M₁\ninst✝ : NoZeroSMulDivisors R M₁\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₁)\nv : Basis n R M\nhO : B.IsOrthoᵢ ⇑v\nh : ∀ (i : n), Not (B.IsOrtho (v i) (v i))\n⊢ B.SeparatingRight","decl":"/-- Given an orthogonal basis with respect to a bilinear map, the bilinear map is right-separating\nif the basis has no elements which are self-orthogonal. -/\ntheorem IsOrthoᵢ.separatingRight_iff_not_isOrtho_basis_self [NoZeroSMulDivisors R M₁]\n    {B : M →ₗ[R] M →ₗ[R] M₁} (v : Basis n R M) (hO : B.IsOrthoᵢ v)\n    (h : ∀ i, ¬B.IsOrtho (v i) (v i)) : B.SeparatingRight := by\n  rw [isOrthoᵢ_flip] at hO\n  rw [← flip_separatingLeft]\n  refine IsOrthoᵢ.separatingLeft_of_not_isOrtho_basis_self v hO fun i ↦ ?_\n  rw [isOrtho_flip]\n  exact h i\n\n"}
{"name":"LinearMap.IsOrthoᵢ.nondegenerate_of_not_isOrtho_basis_self","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\nn : Type u_19\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup M₁\ninst✝¹ : Module R M₁\ninst✝ : NoZeroSMulDivisors R M₁\nB : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) M M₁)\nv : Basis n R M\nhO : B.IsOrthoᵢ ⇑v\nh : ∀ (i : n), Not (B.IsOrtho (v i) (v i))\n⊢ B.Nondegenerate","decl":"/-- Given an orthogonal basis with respect to a bilinear map, the bilinear map is nondegenerate\nif the basis has no elements which are self-orthogonal. -/\ntheorem IsOrthoᵢ.nondegenerate_of_not_isOrtho_basis_self [NoZeroSMulDivisors R M₁]\n    {B : M →ₗ[R] M →ₗ[R] M₁} (v : Basis n R M) (hO : B.IsOrthoᵢ v)\n    (h : ∀ i, ¬B.IsOrtho (v i) (v i)) : B.Nondegenerate :=\n  ⟨IsOrthoᵢ.separatingLeft_of_not_isOrtho_basis_self v hO h,\n    IsOrthoᵢ.separatingRight_iff_not_isOrtho_basis_self v hO h⟩\n\n"}
{"name":"LinearMap.BilinForm.apply_smul_sub_smul_sub_eq","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nx y : M\n⊢ Eq ((B (HSub.hSub (HSMul.hSMul ((B x) y) x) (HSMul.hSMul ((B x) x) y))) (HSub.hSub (HSMul.hSMul ((B x) y) x) (HSMul.hSMul ((B x) x) y))) (HMul.hMul ((B x) x) (HSub.hSub (HMul.hMul ((B x) x) ((B y) y)) (HMul.hMul ((B x) y) ((B y) x))))","decl":"lemma apply_smul_sub_smul_sub_eq [CommRing R] [AddCommGroup M] [Module R M]\n    (B : LinearMap.BilinForm R M) (x y : M) :\n    B ((B x y) • x - (B x x) • y) ((B x y) • x - (B x x) • y) =\n      (B x x) * ((B x x) * (B y y) - (B x y) * (B y x)) := by\n  simp only [map_sub, map_smul, sub_apply, smul_apply, smul_eq_mul, mul_sub,\n    mul_comm (B x y) (B x x), mul_left_comm (B x y) (B x x)]\n  abel\n\n"}
{"name":"LinearMap.BilinForm.apply_mul_apply_le_of_forall_zero_le","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : LinearOrderedCommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nhs : ∀ (x : M), LE.le 0 ((B x) x)\nx y : M\n⊢ LE.le (HMul.hMul ((B x) y) ((B y) x)) (HMul.hMul ((B x) x) ((B y) y))","decl":"/-- The **Cauchy-Schwarz inequality** for positive semidefinite forms. -/\nlemma apply_mul_apply_le_of_forall_zero_le (hs : ∀ x, 0 ≤ B x x) (x y : M) :\n    (B x y) * (B y x) ≤ (B x x) * (B y y) := by\n  have aux (x y : M) : 0 ≤ (B x x) * ((B x x) * (B y y) - (B x y) * (B y x)) := by\n    rw [← apply_smul_sub_smul_sub_eq B x y]\n    exact hs (B x y • x - B x x • y)\n  rcases lt_or_le 0 (B x x) with hx | hx\n  · exact sub_nonneg.mp <| nonneg_of_mul_nonneg_right (aux x y) hx\n  · replace hx : B x x = 0 := le_antisymm hx (hs x)\n    rcases lt_or_le 0 (B y y) with hy | hy\n    · rw [mul_comm (B x y), mul_comm (B x x)]\n      exact sub_nonneg.mp <| nonneg_of_mul_nonneg_right (aux y x) hy\n    · replace hy : B y y = 0 := le_antisymm hy (hs y)\n      suffices B x y = - B y x by simpa [this, hx, hy] using mul_self_nonneg (B y x)\n      rw [eq_neg_iff_add_eq_zero]\n      apply le_antisymm\n      · simpa [hx, hy, le_neg_iff_add_nonpos_left] using hs (x - y)\n      · simpa [hx, hy] using hs (x + y)\n\n"}
{"name":"LinearMap.BilinForm.apply_sq_le_of_symm","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : LinearOrderedCommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nhs : ∀ (x : M), LE.le 0 ((B x) x)\nhB : LinearMap.IsSymm B\nx y : M\n⊢ LE.le (HPow.hPow ((B x) y) 2) (HMul.hMul ((B x) x) ((B y) y))","decl":"/-- The **Cauchy-Schwarz inequality** for positive semidefinite symmetric forms. -/\nlemma apply_sq_le_of_symm (hs : ∀ x, 0 ≤ B x x) (hB : B.IsSymm) (x y : M) :\n    (B x y) ^ 2 ≤ (B x x) * (B y y) := by\n  rw [show (B x y) ^ 2 = (B x y) * (B y x) by rw [sq, ← hB, RingHom.id_apply]]\n  exact apply_mul_apply_le_of_forall_zero_le B hs x y\n\n"}
{"name":"LinearMap.BilinForm.not_linearIndependent_of_apply_mul_apply_eq","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : LinearOrderedCommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nhp : ∀ (x : M), Ne x 0 → LT.lt 0 ((B x) x)\nx y : M\nhe : Eq (HMul.hMul ((B x) y) ((B y) x)) (HMul.hMul ((B x) x) ((B y) y))\n⊢ Not (LinearIndependent R (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty)))","decl":"/-- The equality case of **Cauchy-Schwarz**. -/\nlemma not_linearIndependent_of_apply_mul_apply_eq (hp : ∀ x, x ≠ 0 → 0 < B x x)\n    (x y : M) (he : (B x y) * (B y x) = (B x x) * (B y y)) :\n    ¬ LinearIndependent R ![x, y] := by\n  have hz : (B x y) • x - (B x x) • y = 0 := by\n    by_contra hc\n    exact (ne_of_lt (hp ((B x) y • x - (B x) x • y) hc)).symm <|\n      (apply_smul_sub_smul_sub_eq B x y).symm ▸ (mul_eq_zero_of_right ((B x) x)\n      (sub_eq_zero_of_eq he.symm))\n  by_contra hL\n  by_cases hx : x = 0\n  · simpa [hx] using LinearIndependent.ne_zero 0 hL\n  · have h := sub_eq_zero.mpr (sub_eq_zero.mp hz).symm\n    rw [sub_eq_add_neg, ← neg_smul, add_comm] at h\n    exact (Ne.symm (ne_of_lt (hp x hx))) (LinearIndependent.eq_zero_of_pair hL h).2\n\n"}
{"name":"LinearMap.BilinForm.apply_mul_apply_lt_iff_linearIndependent","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝³ : LinearOrderedCommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nB : LinearMap.BilinForm R M\ninst✝ : NoZeroSMulDivisors R M\nhp : ∀ (x : M), Ne x 0 → LT.lt 0 ((B x) x)\nx y : M\n⊢ Iff (LT.lt (HMul.hMul ((B x) y) ((B y) x)) (HMul.hMul ((B x) x) ((B y) y))) (LinearIndependent R (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty)))","decl":"/-- Strict **Cauchy-Schwarz** is equivalent to linear independence for positive definite forms. -/\nlemma apply_mul_apply_lt_iff_linearIndependent [NoZeroSMulDivisors R M]\n    (hp : ∀ x, x ≠ 0 → 0 < B x x) (x y : M) :\n    (B x y) * (B y x) < (B x x) * (B y y) ↔ LinearIndependent R ![x, y] := by\n  have hle : ∀ z, 0 ≤ B z z := by\n    intro z\n    by_cases hz : z = 0; simp [hz]\n    exact le_of_lt (hp z hz)\n  constructor\n  · contrapose!\n    intro h\n    rw [LinearIndependent.pair_iff] at h\n    push_neg at h\n    obtain ⟨r, s, hl, h0⟩ := h\n    by_cases hr : r = 0; · simp_all\n    by_cases hs : s = 0; · simp_all\n    suffices\n        (B (r • x) (r • x)) * (B (s • y) (s • y)) = (B (r • x) (s • y)) * (B (s • y) (r • x)) by\n      simp only [map_smul, smul_apply, smul_eq_mul] at this\n      rw [show r * (r * (B x) x) * (s * (s * (B y) y)) = (r * r * s * s) * ((B x) x * (B y) y) by\n        ring, show s * (r * (B x) y) * (r * (s * (B y) x)) = (r * r * s * s) * ((B x) y * (B y) x)\n        by ring] at this\n      have hrs : r * r * s * s ≠ 0 := by simp [hr, hs]\n      exact le_of_eq <| mul_right_injective₀ hrs this\n    simp [show s • y = - r • x by rwa [neg_smul, ← add_eq_zero_iff_eq_neg']]\n  · contrapose!\n    intro h\n    refine not_linearIndependent_of_apply_mul_apply_eq B hp x y (le_antisymm\n      (apply_mul_apply_le_of_forall_zero_le B hle x y) h)\n\n"}
{"name":"LinearMap.BilinForm.apply_sq_lt_iff_linearIndependent_of_symm","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝³ : LinearOrderedCommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nB : LinearMap.BilinForm R M\ninst✝ : NoZeroSMulDivisors R M\nhp : ∀ (x : M), Ne x 0 → LT.lt 0 ((B x) x)\nhB : LinearMap.IsSymm B\nx y : M\n⊢ Iff (LT.lt (HPow.hPow ((B x) y) 2) (HMul.hMul ((B x) x) ((B y) y))) (LinearIndependent R (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty)))","decl":"/-- Strict **Cauchy-Schwarz** is equivalent to linear independence for positive definite symmetric\nforms. -/\nlemma apply_sq_lt_iff_linearIndependent_of_symm [NoZeroSMulDivisors R M]\n    (hp : ∀ x, x ≠ 0 → 0 < B x x) (hB: B.IsSymm) (x y : M) :\n    (B x y) ^ 2 < (B x x) * (B y y) ↔ LinearIndependent R ![x, y] := by\n  rw [show (B x y) ^ 2 = (B x y) * (B y x) by rw [sq, ← hB, RingHom.id_apply]]\n  exact apply_mul_apply_lt_iff_linearIndependent B hp x y\n\n"}
{"name":"LinearMap.BilinForm.apply_apply_same_eq_zero_iff","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : LinearOrderedCommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nhs : ∀ (x : M), LE.le 0 ((B x) x)\nhB : LinearMap.IsSymm B\nx : M\n⊢ Iff (Eq ((B x) x) 0) (Membership.mem (LinearMap.ker B) x)","decl":"lemma apply_apply_same_eq_zero_iff (hs : ∀ x, 0 ≤ B x x) (hB : B.IsSymm) {x : M} :\n    B x x = 0 ↔ x ∈ LinearMap.ker B := by\n  rw [LinearMap.mem_ker]\n  refine ⟨fun h ↦ ?_, fun h ↦ by simp [h]⟩\n  ext y\n  have := B.apply_sq_le_of_symm hs hB x y\n  simp only [h, zero_mul] at this\n  exact pow_eq_zero <| le_antisymm this (sq_nonneg (B x y))\n\n"}
{"name":"LinearMap.BilinForm.nondegenerate_iff","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : LinearOrderedCommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nhs : ∀ (x : M), LE.le 0 ((B x) x)\nhB : LinearMap.IsSymm B\n⊢ Iff (LinearMap.Nondegenerate B) (∀ (x : M), Iff (Eq ((B x) x) 0) (Eq x 0))","decl":"lemma nondegenerate_iff (hs : ∀ x, 0 ≤ B x x) (hB : B.IsSymm) :\n    B.Nondegenerate ↔ ∀ x, B x x = 0 ↔ x = 0 := by\n  simp_rw [hB.isRefl.nondegenerate_iff_separatingLeft, separatingLeft_iff_ker_eq_bot,\n    Submodule.eq_bot_iff, B.apply_apply_same_eq_zero_iff hs hB, mem_ker]\n  exact forall_congr' fun x ↦ by aesop\n\n"}
{"name":"LinearMap.BilinForm.nondegenerate_iff'","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : LinearOrderedCommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nhs : ∀ (x : M), LE.le 0 ((B x) x)\nhB : LinearMap.IsSymm B\n⊢ Iff (LinearMap.Nondegenerate B) (∀ (x : M), Ne x 0 → LT.lt 0 ((B x) x))","decl":"/-- A convenience variant of `LinearMap.BilinForm.nondegenerate_iff` characterising nondegeneracy as\npositive definiteness. -/\nlemma nondegenerate_iff' (hs : ∀ x, 0 ≤ B x x) (hB : B.IsSymm) :\n    B.Nondegenerate ↔ ∀ x, x ≠ 0 → 0 < B x x := by\n  rw [B.nondegenerate_iff hs hB, ← not_iff_not]\n  push_neg\n  exact exists_congr fun x ↦ ⟨by aesop, fun ⟨h₀, h⟩ ↦ Or.inl ⟨le_antisymm h (hs x), h₀⟩⟩\n\n"}
{"name":"LinearMap.BilinForm.nondegenerate_restrict_iff_disjoint_ker","module":"Mathlib.LinearAlgebra.SesquilinearForm","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : LinearOrderedCommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nhs : ∀ (x : M), LE.le 0 ((B x) x)\nhB : LinearMap.IsSymm B\nW : Submodule R M\n⊢ Iff (LinearMap.domRestrict₁₂ B W W).Nondegenerate (Disjoint W (LinearMap.ker B))","decl":"lemma nondegenerate_restrict_iff_disjoint_ker (hs : ∀ x, 0 ≤ B x x) (hB : B.IsSymm)\n    {W : Submodule R M} :\n    (B.domRestrict₁₂ W W).Nondegenerate ↔ Disjoint W (LinearMap.ker B) := by\n  refine ⟨disjoint_ker_of_nondegenerate_restrict, fun hW ↦ ?_⟩\n  have hB' : (B.domRestrict₁₂ W W).IsRefl := fun x y ↦ hB.isRefl (W.subtype x) (W.subtype y)\n  rw [IsRefl.nondegenerate_iff_separatingLeft hB']\n  intro ⟨x, hx⟩ h\n  simp_rw [Subtype.forall, domRestrict₁₂_apply] at h\n  specialize h x hx\n  rw [B.apply_apply_same_eq_zero_iff hs hB] at h\n  have key : x ∈ W ⊓ LinearMap.ker B := ⟨hx, h⟩\n  simpa [hW.eq_bot] using key\n\n"}
