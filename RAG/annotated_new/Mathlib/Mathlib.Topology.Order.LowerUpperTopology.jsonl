{"name":"Topology.WithLower.toLower_symm","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\n‚ä¢ Eq Topology.WithLower.toLower.symm Topology.WithLower.ofLower","decl":"@[simp] lemma toLower_symm : (@toLower Œ±).symm = ofLower := rfl\n"}
{"name":"Topology.WithLower.to_WithLower_symm_eq","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\n‚ä¢ Eq Topology.WithLower.toLower.symm Topology.WithLower.ofLower","decl":"@[deprecated (since := \"2024-12-16\")] alias to_WithLower_symm_eq := toLower_symm\n\n"}
{"name":"Topology.WithLower.ofLower_symm","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\n‚ä¢ Eq Topology.WithLower.ofLower.symm Topology.WithLower.toLower","decl":"@[simp] lemma ofLower_symm : (@ofLower Œ±).symm = toLower := rfl\n"}
{"name":"Topology.WithLower.of_WithLower_symm_eq","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\n‚ä¢ Eq Topology.WithLower.ofLower.symm Topology.WithLower.toLower","decl":"@[deprecated (since := \"2024-12-16\")] alias of_WithLower_symm_eq := ofLower_symm\n\n"}
{"name":"Topology.WithLower.toLower_ofLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\na : Topology.WithLower Œ±\n‚ä¢ Eq (Topology.WithLower.toLower (Topology.WithLower.ofLower a)) a","decl":"@[simp] lemma toLower_ofLower (a : WithLower Œ±) : toLower (ofLower a) = a := rfl\n\n"}
{"name":"Topology.WithLower.ofLower_toLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\na : Œ±\n‚ä¢ Eq (Topology.WithLower.ofLower (Topology.WithLower.toLower a)) a","decl":"@[simp] lemma ofLower_toLower (a : Œ±) : ofLower (toLower a) = a := rfl\n\n"}
{"name":"Topology.WithLower.toLower_inj","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\na b : Œ±\n‚ä¢ Iff (Eq (Topology.WithLower.toLower a) (Topology.WithLower.toLower b)) (Eq a b)","decl":"lemma toLower_inj {a b : Œ±} : toLower a = toLower b ‚Üî a = b := Iff.rfl\n\n-- Porting note: removed @[simp] to make linter happy\n"}
{"name":"Topology.WithLower.ofLower_inj","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\na b : Topology.WithLower Œ±\n‚ä¢ Iff (Eq (Topology.WithLower.ofLower a) (Topology.WithLower.ofLower b)) (Eq a b)","decl":"theorem ofLower_inj {a b : WithLower Œ±} : ofLower a = ofLower b ‚Üî a = b :=\n  Iff.rfl\n\n"}
{"name":"Topology.WithLower.instNonempty","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Nonempty Œ±\n‚ä¢ Nonempty (Topology.WithLower Œ±)","decl":"instance [Nonempty Œ±] : Nonempty (WithLower Œ±) := ‚ÄπNonempty Œ±‚Ä∫\n"}
{"name":"Topology.WithLower.toLower_le_toLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\nx y : Œ±\n‚ä¢ Iff (LE.le (Topology.WithLower.toLower x) (Topology.WithLower.toLower y)) (LE.le x y)","decl":"@[simp] lemma toLower_le_toLower {x y : Œ±} : toLower x ‚â§ toLower y ‚Üî x ‚â§ y := .rfl\n"}
{"name":"Topology.WithLower.toLower_lt_toLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\nx y : Œ±\n‚ä¢ Iff (LT.lt (Topology.WithLower.toLower x) (Topology.WithLower.toLower y)) (LT.lt x y)","decl":"@[simp] lemma toLower_lt_toLower {x y : Œ±} : toLower x < toLower y ‚Üî x < y := .rfl\n"}
{"name":"Topology.WithLower.ofLower_le_ofLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\nx y : Topology.WithLower Œ±\n‚ä¢ Iff (LE.le (Topology.WithLower.ofLower x) (Topology.WithLower.ofLower y)) (LE.le x y)","decl":"@[simp] lemma ofLower_le_ofLower {x y : WithLower Œ±} : ofLower x ‚â§ ofLower y ‚Üî x ‚â§ y := .rfl\n"}
{"name":"Topology.WithLower.ofLower_lt_ofLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\nx y : Topology.WithLower Œ±\n‚ä¢ Iff (LT.lt (Topology.WithLower.ofLower x) (Topology.WithLower.ofLower y)) (LT.lt x y)","decl":"@[simp] lemma ofLower_lt_ofLower {x y : WithLower Œ±} : ofLower x < ofLower y ‚Üî x < y := .rfl\n\n"}
{"name":"Topology.WithLower.isOpen_preimage_ofLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen (Set.preimage (‚áëTopology.WithLower.ofLower) s)) (IsOpen s)","decl":"lemma isOpen_preimage_ofLower : IsOpen (ofLower ‚Åª¬π' s) ‚Üî IsOpen[lower Œ±] s := Iff.rfl\n\n"}
{"name":"Topology.WithLower.isOpen_def","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\nT : Set (Topology.WithLower Œ±)\n‚ä¢ Iff (IsOpen T) (IsOpen (Set.preimage (‚áëTopology.WithLower.toLower) T))","decl":"lemma isOpen_def (T : Set (WithLower Œ±)) : IsOpen T ‚Üî IsOpen[lower Œ±] (WithLower.toLower ‚Åª¬π' T) :=\n  Iff.rfl\n\n"}
{"name":"Topology.WithLower.continuous_toLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : ClosedIciTopology Œ±\n‚ä¢ Continuous ‚áëTopology.WithLower.toLower","decl":"theorem continuous_toLower [TopologicalSpace Œ±] [ClosedIciTopology Œ±] :\n    Continuous (toLower : Œ± ‚Üí WithLower Œ±) :=\n  continuous_generateFrom_iff.mpr <| by rintro _ ‚ü®a, rfl‚ü©; exact isClosed_Ici.isOpen_compl\n\n"}
{"name":"Topology.WithUpper.toUpper_symm","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_3\n‚ä¢ Eq Topology.WithUpper.toUpper.symm Topology.WithUpper.ofUpper","decl":"@[simp] lemma toUpper_symm {Œ±} : (@toUpper Œ±).symm = ofUpper := rfl\n"}
{"name":"Topology.WithUpper.to_WithUpper_symm_eq","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_3\n‚ä¢ Eq Topology.WithUpper.toUpper.symm Topology.WithUpper.ofUpper","decl":"@[deprecated (since := \"2024-12-16\")] alias to_WithUpper_symm_eq := toUpper_symm\n"}
{"name":"Topology.WithUpper.ofUpper_symm","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\n‚ä¢ Eq Topology.WithUpper.ofUpper.symm Topology.WithUpper.toUpper","decl":"@[simp] lemma ofUpper_symm : (@ofUpper Œ±).symm = toUpper := rfl\n"}
{"name":"Topology.WithUpper.of_WithUpper_symm_eq","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\n‚ä¢ Eq Topology.WithUpper.ofUpper.symm Topology.WithUpper.toUpper","decl":"@[deprecated (since := \"2024-12-16\")] alias of_WithUpper_symm_eq := ofUpper_symm\n"}
{"name":"Topology.WithUpper.toUpper_ofUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\na : Topology.WithUpper Œ±\n‚ä¢ Eq (Topology.WithUpper.toUpper (Topology.WithUpper.ofUpper a)) a","decl":"@[simp] lemma toUpper_ofUpper (a : WithUpper Œ±) : toUpper (ofUpper a) = a := rfl\n"}
{"name":"Topology.WithUpper.ofUpper_toUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\na : Œ±\n‚ä¢ Eq (Topology.WithUpper.ofUpper (Topology.WithUpper.toUpper a)) a","decl":"@[simp] lemma ofUpper_toUpper (a : Œ±) : ofUpper (toUpper a) = a := rfl\n"}
{"name":"Topology.WithUpper.toUpper_inj","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\na b : Œ±\n‚ä¢ Iff (Eq (Topology.WithUpper.toUpper a) (Topology.WithUpper.toUpper b)) (Eq a b)","decl":"lemma toUpper_inj {a b : Œ±} : toUpper a = toUpper b ‚Üî a = b := Iff.rfl\n"}
{"name":"Topology.WithUpper.ofUpper_inj","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\na b : Topology.WithUpper Œ±\n‚ä¢ Iff (Eq (Topology.WithUpper.ofUpper a) (Topology.WithUpper.ofUpper b)) (Eq a b)","decl":"lemma ofUpper_inj {a b : WithUpper Œ±} : ofUpper a = ofUpper b ‚Üî a = b := Iff.rfl\n\n"}
{"name":"Topology.WithUpper.instNonempty","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Nonempty Œ±\n‚ä¢ Nonempty (Topology.WithUpper Œ±)","decl":"instance [Nonempty Œ±] : Nonempty (WithUpper Œ±) := ‚ÄπNonempty Œ±‚Ä∫\n"}
{"name":"Topology.WithUpper.toUpper_le_toUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\nx y : Œ±\n‚ä¢ Iff (LE.le (Topology.WithUpper.toUpper x) (Topology.WithUpper.toUpper y)) (LE.le x y)","decl":"@[simp] lemma toUpper_le_toUpper {x y : Œ±} : toUpper x ‚â§ toUpper y ‚Üî x ‚â§ y := .rfl\n"}
{"name":"Topology.WithUpper.toUpper_lt_toUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\nx y : Œ±\n‚ä¢ Iff (LT.lt (Topology.WithUpper.toUpper x) (Topology.WithUpper.toUpper y)) (LT.lt x y)","decl":"@[simp] lemma toUpper_lt_toUpper {x y : Œ±} : toUpper x < toUpper y ‚Üî x < y := .rfl\n"}
{"name":"Topology.WithUpper.ofUpper_le_ofUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\nx y : Topology.WithUpper Œ±\n‚ä¢ Iff (LE.le (Topology.WithUpper.ofUpper x) (Topology.WithUpper.ofUpper y)) (LE.le x y)","decl":"@[simp] lemma ofUpper_le_ofUpper {x y : WithUpper Œ±} : ofUpper x ‚â§ ofUpper y ‚Üî x ‚â§ y := .rfl\n"}
{"name":"Topology.WithUpper.ofUpper_lt_ofUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\nx y : Topology.WithUpper Œ±\n‚ä¢ Iff (LT.lt (Topology.WithUpper.ofUpper x) (Topology.WithUpper.ofUpper y)) (LT.lt x y)","decl":"@[simp] lemma ofUpper_lt_ofUpper {x y : WithUpper Œ±} : ofUpper x < ofUpper y ‚Üî x < y := .rfl\n\n"}
{"name":"Topology.WithUpper.isOpen_preimage_ofUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen (Set.preimage (‚áëTopology.WithUpper.ofUpper) s)) (TopologicalSpace.IsOpen s)","decl":"lemma isOpen_preimage_ofUpper : IsOpen (ofUpper ‚Åª¬π' s) ‚Üî (upper Œ±).IsOpen s := Iff.rfl\n\n"}
{"name":"Topology.WithUpper.isOpen_def","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\ns : Set (Topology.WithUpper Œ±)\n‚ä¢ Iff (IsOpen s) (TopologicalSpace.IsOpen (Set.preimage (‚áëTopology.WithUpper.toUpper) s))","decl":"lemma isOpen_def {s : Set (WithUpper Œ±)} : IsOpen s ‚Üî (upper Œ±).IsOpen (toUpper ‚Åª¬π' s) := Iff.rfl\n\n"}
{"name":"Topology.WithUpper.continuous_toUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : ClosedIicTopology Œ±\n‚ä¢ Continuous ‚áëTopology.WithUpper.toUpper","decl":"theorem continuous_toUpper [TopologicalSpace Œ±] [ClosedIicTopology Œ±] :\n    Continuous (toUpper : Œ± ‚Üí WithUpper Œ±) :=\n  continuous_generateFrom_iff.mpr <| by rintro _ ‚ü®a, rfl‚ü©; exact isClosed_Iic.isOpen_compl\n\n"}
{"name":"Topology.IsLower.topology_eq_lowerTopology","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_3\nt : TopologicalSpace Œ±\ninst‚úù : Preorder Œ±\nself : Topology.IsLower Œ±\n‚ä¢ Eq t (Topology.lower Œ±)","decl":"/--\nThe lower topology is the topology generated by the complements of the left-closed right-infinite\nintervals.\n-/\nclass IsLower (Œ± : Type*) [t : TopologicalSpace Œ±] [Preorder Œ±] : Prop where\n  topology_eq_lowerTopology : t = lower Œ±\n\n"}
{"name":"Topology.IsUpper.topology_eq_upperTopology","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_3\nt : TopologicalSpace Œ±\ninst‚úù : Preorder Œ±\nself : Topology.IsUpper Œ±\n‚ä¢ Eq t (Topology.upper Œ±)","decl":"/--\nThe upper topology is the topology generated by the complements of the right-closed left-infinite\nintervals.\n-/\nclass IsUpper (Œ± : Type*) [t : TopologicalSpace Œ±] [Preorder Œ±] : Prop where\n  topology_eq_upperTopology : t = upper Œ±\n"}
{"name":"Topology.instIsLowerWithLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\n‚ä¢ Topology.IsLower (Topology.WithLower Œ±)","decl":"instance [Preorder Œ±] : IsLower (WithLower Œ±) := ‚ü®rfl‚ü©\n"}
{"name":"Topology.instIsUpperWithUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù : Preorder Œ±\n‚ä¢ Topology.IsUpper (Topology.WithUpper Œ±)","decl":"instance [Preorder Œ±] : IsUpper (WithUpper Œ±) := ‚ü®rfl‚ü©\n\n"}
{"name":"Topology.IsLower.topology_eq","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\n‚ä¢ Eq inst‚úù¬π (Topology.lower Œ±)","decl":"lemma topology_eq : ‚Äπ_‚Ä∫ = lower Œ± := topology_eq_lowerTopology\n\n"}
{"name":"Topology.IsLower.isOpen_iff_generate_Ici_compl","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen s) (TopologicalSpace.GenerateOpen (setOf fun t => Exists fun a => Eq (HasCompl.compl (Set.Ici a)) t) s)","decl":"theorem isOpen_iff_generate_Ici_compl : IsOpen s ‚Üî GenerateOpen { t | ‚àÉ a, (Ici a)·∂ú = t } s := by\n  rw [topology_eq Œ±]; rfl\n\n"}
{"name":"OrderDual.instIsUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\n‚ä¢ Topology.IsUpper (OrderDual Œ±)","decl":"instance _root_.OrderDual.instIsUpper [Preorder Œ±] [TopologicalSpace Œ±] [IsLower Œ±] :\n    IsUpper Œ±·µí·µà where\n  topology_eq_upperTopology := topology_eq_lowerTopology (Œ± := Œ±)\n\n"}
{"name":"Topology.IsLower.instClosedIciTopology","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\n‚ä¢ ClosedIciTopology Œ±","decl":"/-- Left-closed right-infinite intervals [a, ‚àû) are closed in the lower topology. -/\ninstance : ClosedIciTopology Œ± :=\n  ‚ü®fun a ‚Ü¶ isOpen_compl_iff.1 <| isOpen_iff_generate_Ici_compl.2 <| GenerateOpen.basic _ ‚ü®a, rfl‚ü©‚ü©\n\n-- Porting note: The old `IsLower.isClosed_Ici` was removed, since one can now use\n-- the general `isClosed_Ici` lemma thanks to the instance above.\n\n"}
{"name":"Topology.IsLower.isClosed_upperClosure","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\ns : Set Œ±\nh : s.Finite\n‚ä¢ IsClosed ‚Üë(upperClosure s)","decl":"/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem isClosed_upperClosure (h : s.Finite) : IsClosed (upperClosure s : Set Œ±) := by\n  simp only [‚Üê UpperSet.iInf_Ici, UpperSet.coe_iInf]\n  exact h.isClosed_biUnion fun _ _ => isClosed_Ici\n\n"}
{"name":"Topology.IsLower.isLowerSet_of_isOpen","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\ns : Set Œ±\nh : IsOpen s\n‚ä¢ IsLowerSet s","decl":"/-- Every set open in the lower topology is a lower set. -/\ntheorem isLowerSet_of_isOpen (h : IsOpen s) : IsLowerSet s := by\n  -- Porting note: `rw` leaves a shadowed assumption\n  replace h := isOpen_iff_generate_Ici_compl.1 h\n  induction h with\n  | basic u h' => obtain ‚ü®a, rfl‚ü© := h'; exact (isUpperSet_Ici a).compl\n  | univ => exact isLowerSet_univ\n  | inter u v _ _ hu2 hv2 => exact hu2.inter hv2\n  | sUnion _ _ ih => exact isLowerSet_sUnion ih\n\n"}
{"name":"Topology.IsLower.isUpperSet_of_isClosed","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\ns : Set Œ±\nh : IsClosed s\n‚ä¢ IsUpperSet s","decl":"theorem isUpperSet_of_isClosed (h : IsClosed s) : IsUpperSet s :=\n  isLowerSet_compl.1 <| isLowerSet_of_isOpen h.isOpen_compl\n\n"}
{"name":"Topology.IsLower.tendsto_nhds_iff_not_le","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\nŒ≤ : Type u_3\nf : Œ≤ ‚Üí Œ±\nl : Filter Œ≤\nx : Œ±\n‚ä¢ Iff (Filter.Tendsto f l (nhds x)) (‚àÄ (y : Œ±), Not (LE.le y x) ‚Üí Filter.Eventually (fun z => Not (LE.le y (f z))) l)","decl":"theorem tendsto_nhds_iff_not_le {Œ≤ : Type*} {f : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {x : Œ±} :\n    Filter.Tendsto f l (ùìù x) ‚Üî ‚àÄ y, ¬¨y ‚â§ x ‚Üí ‚àÄ·∂† z in l, ¬¨y ‚â§ f z := by\n  simp [topology_eq_lowerTopology, tendsto_nhds_generateFrom_iff, Filter.Eventually, Ici,\n    compl_setOf]\n\n"}
{"name":"Topology.IsLower.closure_singleton","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\na : Œ±\n‚ä¢ Eq (closure (Singleton.singleton a)) (Set.Ici a)","decl":"/--\nThe closure of a singleton `{a}` in the lower topology is the left-closed right-infinite interval\n[a, ‚àû).\n-/\n@[simp]\ntheorem closure_singleton (a : Œ±) : closure {a} = Ici a :=\n  Subset.antisymm ((closure_minimal fun _ h => h.ge) <| isClosed_Ici) <|\n    (isUpperSet_of_isClosed isClosed_closure).Ici_subset <| subset_closure rfl\n\n"}
{"name":"Topology.IsLower.isTopologicalBasis","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Topology.IsLower.lowerBasis Œ±)","decl":"protected theorem isTopologicalBasis : IsTopologicalBasis (lowerBasis Œ±) := by\n  convert isTopologicalBasis_of_subbasis (topology_eq Œ±)\n  simp_rw [lowerBasis, coe_upperClosure, compl_iUnion]\n  ext s\n  constructor\n  ¬∑ rintro ‚ü®F, hF, rfl‚ü©\n    refine ‚ü®(fun a => (Ici a)·∂ú) '' F, ‚ü®hF.image _, image_subset_iff.2 fun _ _ => ‚ü®_, rfl‚ü©‚ü©, ?_‚ü©\n    simp only [sInter_image]\n  ¬∑ rintro ‚ü®F, ‚ü®hF, hs‚ü©, rfl‚ü©\n    haveI := hF.to_subtype\n    rw [subset_def, Subtype.forall'] at hs\n    choose f hf using hs\n    exact ‚ü®_, finite_range f, by simp_rw [biInter_range, hf, sInter_eq_iInter]‚ü©\n\n"}
{"name":"Topology.IsLower.continuous_iff_Ici","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Topology.IsLower Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Continuous f) (‚àÄ (a : Œ±), IsClosed (Set.preimage f (Set.Ici a)))","decl":"/-- A function `f : Œ≤ ‚Üí Œ±` with lower topology in the codomain is continuous\nif and only if the preimage of every interval `Set.Ici a` is a closed set.\n-/\nlemma continuous_iff_Ici [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} :\n    Continuous f ‚Üî ‚àÄ a, IsClosed (f ‚Åª¬π' (Ici a)) := by\n  obtain rfl := IsLower.topology_eq Œ±\n  simp [continuous_generateFrom_iff]\n\n"}
{"name":"Topology.IsLower.t0Space","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : PartialOrder Œ±\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ T0Space Œ±","decl":"/-- The lower topology on a partial order is T‚ÇÄ. -/\ninstance (priority := 90) t0Space : T0Space Œ± :=\n  (t0Space_iff_inseparable Œ±).2 fun x y h =>\n    Ici_injective <| by simpa only [inseparable_iff_closure_eq, closure_singleton] using h\n\n"}
{"name":"Topology.IsLower.isTopologicalBasis_insert_univ_subbasis","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Insert.insert Set.univ (setOf fun s => Exists fun a => Eq (HasCompl.compl (Set.Ici a)) s))","decl":"lemma isTopologicalBasis_insert_univ_subbasis :\n    IsTopologicalBasis (insert univ {s : Set Œ± | ‚àÉ a, (Ici a)·∂ú = s}) :=\n  isTopologicalBasis_of_subbasis_of_inter (by rw [topology_eq Œ±, lower]) (by\n    rintro _ ‚ü®b, rfl‚ü© _ ‚ü®c, rfl‚ü©\n    use b ‚äì c\n    rw [compl_Ici, compl_Ici, compl_Ici, Iio_inter_Iio])\n\n"}
{"name":"Topology.IsLower.tendsto_nhds_iff_lt","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\nŒ≤ : Type u_3\nf : Œ≤ ‚Üí Œ±\nl : Filter Œ≤\nx : Œ±\n‚ä¢ Iff (Filter.Tendsto f l (nhds x)) (‚àÄ (y : Œ±), LT.lt x y ‚Üí Filter.Eventually (fun z => LT.lt (f z) y) l)","decl":"theorem tendsto_nhds_iff_lt {Œ≤ : Type*} {f : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {x : Œ±} :\n    Filter.Tendsto f l (ùìù x) ‚Üî ‚àÄ y, x < y ‚Üí ‚àÄ·∂† z in l, f z < y := by\n  simp only [tendsto_nhds_iff_not_le, not_le]\n\n"}
{"name":"Topology.IsLower.isTopologicalSpace_basis","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : CompleteLinearOrder Œ±\nt : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\nU : Set Œ±\n‚ä¢ Iff (IsOpen U) (Or (Eq U Set.univ) (Exists fun a => Eq (HasCompl.compl (Set.Ici a)) U))","decl":"lemma isTopologicalSpace_basis (U : Set Œ±) : IsOpen U ‚Üî U = univ ‚à® ‚àÉ a, (Ici a)·∂ú = U := by\n  by_cases hU : U = univ\n  ¬∑ simp only [hU, isOpen_univ, compl_Ici, true_or]\n  refine ‚ü®?_, isTopologicalBasis_insert_univ_subbasis.isOpen‚ü©\n  intro hO\n  apply Or.inr\n  convert IsTopologicalBasis.open_eq_sUnion isTopologicalBasis_insert_univ_subbasis hO\n  constructor\n  ¬∑ intro ‚ü®a, ha‚ü©\n    use {U}\n    constructor\n    ¬∑ apply subset_trans (singleton_subset_iff.mpr _) (subset_insert _ _)\n      use a\n    ¬∑ rw [sUnion_singleton]\n  ¬∑ intro ‚ü®S, hS1, hS2‚ü©\n    have hUS : univ ‚àâ S := by\n      by_contra hUS'\n      apply hU\n      rw [hS2]\n      exact sUnion_eq_univ_iff.mpr (fun a => ‚ü®univ, hUS', trivial‚ü©)\n    use sSup {a | (Ici a)·∂ú ‚àà S}\n    rw [hS2, sUnion_eq_compl_sInter_compl, compl_inj_iff]\n    apply le_antisymm\n    ¬∑ intro b hb\n      simp only [sInter_image, mem_iInter, mem_compl_iff]\n      intro s hs\n      obtain ‚ü®a,ha‚ü© := (subset_insert_iff_of_not_mem hUS).mp hS1 hs\n      subst hS2 ha\n      simp_all only [compl_Ici, mem_Ici, sSup_le_iff, mem_setOf_eq, mem_Iio, not_lt]\n    ¬∑ intro b hb\n      rw [mem_Ici, sSup_le_iff]\n      intro c hc\n      simp only [sInter_image, mem_iInter] at hb\n      rw [‚Üê not_lt, ‚Üê mem_Iio, ‚Üê compl_Ici]\n      exact hb _ hc\n\n"}
{"name":"Topology.IsUpper.topology_eq","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\n‚ä¢ Eq inst‚úù¬π (Topology.upper Œ±)","decl":"lemma topology_eq : ‚Äπ_‚Ä∫ = upper Œ± := topology_eq_upperTopology\n\n"}
{"name":"Topology.IsUpper.isOpen_iff_generate_Iic_compl","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen s) (TopologicalSpace.GenerateOpen (setOf fun t => Exists fun a => Eq (HasCompl.compl (Set.Iic a)) t) s)","decl":"theorem isOpen_iff_generate_Iic_compl : IsOpen s ‚Üî GenerateOpen { t | ‚àÉ a, (Iic a)·∂ú = t } s := by\n  rw [topology_eq Œ±]; rfl\n\n"}
{"name":"OrderDual.instIsLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\n‚ä¢ Topology.IsLower (OrderDual Œ±)","decl":"instance _root_.OrderDual.instIsLower [Preorder Œ±] [TopologicalSpace Œ±] [IsUpper Œ±] :\n    IsLower Œ±·µí·µà where\n  topology_eq_lowerTopology := topology_eq_upperTopology (Œ± := Œ±)\n\n"}
{"name":"Topology.IsUpper.instClosedIicTopology","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\n‚ä¢ ClosedIicTopology Œ±","decl":"/-- Left-infinite right-closed intervals (-‚àû,a] are closed in the upper topology. -/\ninstance : ClosedIicTopology Œ± :=\n  ‚ü®fun a ‚Ü¶ isOpen_compl_iff.1 <| isOpen_iff_generate_Iic_compl.2 <| GenerateOpen.basic _ ‚ü®a, rfl‚ü©‚ü©\n\n"}
{"name":"Topology.IsUpper.isClosed_lowerClosure","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\ns : Set Œ±\nh : s.Finite\n‚ä¢ IsClosed ‚Üë(lowerClosure s)","decl":"/-- The lower closure of a finite set is closed in the upper topology. -/\ntheorem isClosed_lowerClosure (h : s.Finite) : IsClosed (lowerClosure s : Set Œ±) :=\n  IsLower.isClosed_upperClosure (Œ± := Œ±·µí·µà) h\n\n"}
{"name":"Topology.IsUpper.isUpperSet_of_isOpen","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\ns : Set Œ±\nh : IsOpen s\n‚ä¢ IsUpperSet s","decl":"/-- Every set open in the upper topology is a upper set. -/\ntheorem isUpperSet_of_isOpen (h : IsOpen s) : IsUpperSet s :=\n  IsLower.isLowerSet_of_isOpen (Œ± := Œ±·µí·µà) h\n\n"}
{"name":"Topology.IsUpper.isLowerSet_of_isClosed","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\ns : Set Œ±\nh : IsClosed s\n‚ä¢ IsLowerSet s","decl":"theorem isLowerSet_of_isClosed (h : IsClosed s) : IsLowerSet s :=\n  isUpperSet_compl.1 <| isUpperSet_of_isOpen h.isOpen_compl\n\n"}
{"name":"Topology.IsUpper.tendsto_nhds_iff_not_le","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\nŒ≤ : Type u_3\nf : Œ≤ ‚Üí Œ±\nl : Filter Œ≤\nx : Œ±\n‚ä¢ Iff (Filter.Tendsto f l (nhds x)) (‚àÄ (y : Œ±), Not (LE.le x y) ‚Üí Filter.Eventually (fun z => Not (LE.le (f z) y)) l)","decl":"theorem tendsto_nhds_iff_not_le {Œ≤ : Type*} {f : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {x : Œ±} :\n    Filter.Tendsto f l (ùìù x) ‚Üî ‚àÄ y, ¬¨x ‚â§ y ‚Üí ‚àÄ·∂† z in l, ¬¨f z ‚â§ y :=\n  IsLower.tendsto_nhds_iff_not_le (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Topology.IsUpper.closure_singleton","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\na : Œ±\n‚ä¢ Eq (closure (Singleton.singleton a)) (Set.Iic a)","decl":"/--\nThe closure of a singleton `{a}` in the upper topology is the left-infinite right-closed interval\n(-‚àû,a].\n-/\n@[simp]\ntheorem closure_singleton (a : Œ±) : closure {a} = Iic a :=\n  IsLower.closure_singleton (Œ± := Œ±·µí·µà) _\n\n"}
{"name":"Topology.IsUpper.isTopologicalBasis","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Topology.IsUpper.upperBasis Œ±)","decl":"protected theorem isTopologicalBasis : IsTopologicalBasis (upperBasis Œ±) :=\n  IsLower.isTopologicalBasis (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Topology.IsUpper.continuous_iff_Iic","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Topology.IsUpper Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Continuous f) (‚àÄ (a : Œ±), IsClosed (Set.preimage f (Set.Iic a)))","decl":"/-- A function `f : Œ≤ ‚Üí Œ±` with upper topology in the codomain is continuous\nif and only if the preimage of every interval `Set.Iic a` is a closed set. -/\nlemma continuous_iff_Iic [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} :\n    Continuous f ‚Üî ‚àÄ a, IsClosed (f ‚Åª¬π' (Iic a)) :=\n  IsLower.continuous_iff_Ici (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Topology.IsUpper.t0Space","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : PartialOrder Œ±\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ T0Space Œ±","decl":"/-- The upper topology on a partial order is T‚ÇÄ. -/\ninstance (priority := 90) t0Space : T0Space Œ± :=\n  IsLower.t0Space (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Topology.IsUpper.isTopologicalBasis_insert_univ_subbasis","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\n‚ä¢ TopologicalSpace.IsTopologicalBasis (Insert.insert Set.univ (setOf fun s => Exists fun a => Eq (HasCompl.compl (Set.Iic a)) s))","decl":"lemma isTopologicalBasis_insert_univ_subbasis :\n    IsTopologicalBasis (insert univ {s : Set Œ± | ‚àÉ a, (Iic a)·∂ú = s}) :=\n  IsLower.isTopologicalBasis_insert_univ_subbasis (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Topology.IsUpper.tendsto_nhds_iff_lt","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\nŒ≤ : Type u_3\nf : Œ≤ ‚Üí Œ±\nl : Filter Œ≤\nx : Œ±\n‚ä¢ Iff (Filter.Tendsto f l (nhds x)) (‚àÄ (y : Œ±), LT.lt y x ‚Üí Filter.Eventually (fun z => LT.lt y (f z)) l)","decl":"theorem tendsto_nhds_iff_lt {Œ≤ : Type*} {f : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {x : Œ±} :\n    Filter.Tendsto f l (ùìù x) ‚Üî ‚àÄ y < x, ‚àÄ·∂† z in l, y < f z :=\n  IsLower.tendsto_nhds_iff_lt (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Topology.IsUpper.isTopologicalSpace_basis","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : CompleteLinearOrder Œ±\nt : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\nU : Set Œ±\n‚ä¢ Iff (IsOpen U) (Or (Eq U Set.univ) (Exists fun a => Eq (HasCompl.compl (Set.Iic a)) U))","decl":"lemma isTopologicalSpace_basis (U : Set Œ±) : IsOpen U ‚Üî U = univ ‚à® ‚àÉ a, (Iic a)·∂ú = U :=\n  IsLower.isTopologicalSpace_basis (Œ± := Œ±·µí·µà) U\n\n"}
{"name":"Topology.instIsLowerProd","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å∑ : Preorder Œ±\ninst‚úù‚Å∂ : TopologicalSpace Œ±\ninst‚úù‚Åµ : Topology.IsLower Œ±\ninst‚úù‚Å¥ : OrderBot Œ±\ninst‚úù¬≥ : Preorder Œ≤\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : Topology.IsLower Œ≤\ninst‚úù : OrderBot Œ≤\n‚ä¢ Topology.IsLower (Prod Œ± Œ≤)","decl":"instance instIsLowerProd [Preorder Œ±] [TopologicalSpace Œ±] [IsLower Œ±]\n    [OrderBot Œ±] [Preorder Œ≤] [TopologicalSpace Œ≤] [IsLower Œ≤] [OrderBot Œ≤] :\n    IsLower (Œ± √ó Œ≤) where\n  topology_eq_lowerTopology := by\n    refine le_antisymm (le_generateFrom ?_) ?_\n    ¬∑ rintro _ ‚ü®x, rfl‚ü©\n      exact (isClosed_Ici.prod isClosed_Ici).isOpen_compl\n    rw [(IsLower.isTopologicalBasis.prod\n      IsLower.isTopologicalBasis).eq_generateFrom, le_generateFrom_iff_subset_isOpen,\n      image2_subset_iff]\n    rintro _ ‚ü®s, hs, rfl‚ü© _ ‚ü®t, ht, rfl‚ü©\n    dsimp\n    simp_rw [coe_upperClosure, compl_iUnion, prod_eq, preimage_iInter, preimage_compl]\n    -- without `let`, `refine` tries to use the product topology and fails\n    let _ : TopologicalSpace (Œ± √ó Œ≤) := lower (Œ± √ó Œ≤)\n    refine (hs.isOpen_biInter fun a _ => ?_).inter (ht.isOpen_biInter fun b _ => ?_)\n    ¬∑ exact GenerateOpen.basic _ ‚ü®(a, ‚ä•), by simp [Ici_prod_eq, prod_univ]‚ü©\n    ¬∑ exact GenerateOpen.basic _ ‚ü®(‚ä•, b), by simp [Ici_prod_eq, univ_prod]‚ü©\n\n"}
{"name":"Topology.instIsUpperProd","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å∑ : Preorder Œ±\ninst‚úù‚Å∂ : TopologicalSpace Œ±\ninst‚úù‚Åµ : Topology.IsUpper Œ±\ninst‚úù‚Å¥ : OrderTop Œ±\ninst‚úù¬≥ : Preorder Œ≤\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : Topology.IsUpper Œ≤\ninst‚úù : OrderTop Œ≤\n‚ä¢ Topology.IsUpper (Prod Œ± Œ≤)","decl":"instance instIsUpperProd [Preorder Œ±] [TopologicalSpace Œ±] [IsUpper Œ±]\n    [OrderTop Œ±] [Preorder Œ≤] [TopologicalSpace Œ≤] [IsUpper Œ≤] [OrderTop Œ≤] :\n    IsUpper (Œ± √ó Œ≤) where\n  topology_eq_upperTopology := by\n    suffices IsLower (Œ± √ó Œ≤)·µí·µà from IsLower.topology_eq_lowerTopology (Œ± := (Œ± √ó Œ≤)·µí·µà)\n    exact instIsLowerProd (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà)\n\n"}
{"name":"sInfHom.continuous","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Åµ : CompleteLattice Œ±\ninst‚úù‚Å¥ : CompleteLattice Œ≤\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : Topology.IsLower Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : Topology.IsLower Œ≤\nf : sInfHom Œ± Œ≤\n‚ä¢ Continuous ‚áëf","decl":"protected lemma _root_.sInfHom.continuous (f : sInfHom Œ± Œ≤) : Continuous f := by\n  refine IsLower.continuous_iff_Ici.2 fun b => ?_\n  convert isClosed_Ici (a := sInf <| f ‚Åª¬π' Ici b)\n  refine Subset.antisymm (fun a => sInf_le) fun a ha => le_trans ?_ <|\n    OrderHomClass.mono (f : Œ± ‚Üío Œ≤) ha\n  refine LE.le.trans ?_ (map_sInf f _).ge\n  simp\n\n-- see Note [lower instance priority]\n"}
{"name":"Topology.IsLower.toContinuousInf","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : CompleteLattice Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsLower Œ±\n‚ä¢ ContinuousInf Œ±","decl":"instance (priority := 90) IsLower.toContinuousInf : ContinuousInf Œ± :=\n  ‚ü®(infsInfHom : sInfHom (Œ± √ó Œ±) Œ±).continuous‚ü©\n\n"}
{"name":"sSupHom.continuous","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Åµ : CompleteLattice Œ±\ninst‚úù‚Å¥ : CompleteLattice Œ≤\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : Topology.IsUpper Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : Topology.IsUpper Œ≤\nf : sSupHom Œ± Œ≤\n‚ä¢ Continuous ‚áëf","decl":"protected lemma _root_.sSupHom.continuous (f : sSupHom Œ± Œ≤) : Continuous f :=\n  sInfHom.continuous (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) (sSupHom.dual.toFun f)\n\n-- see Note [lower instance priority]\n"}
{"name":"Topology.IsUpper.toContinuousInf","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : CompleteLattice Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Topology.IsUpper Œ±\n‚ä¢ ContinuousSup Œ±","decl":"instance (priority := 90) IsUpper.toContinuousInf : ContinuousSup Œ± :=\n  ‚ü®(supsSupHom : sSupHom (Œ± √ó Œ±) Œ±).continuous‚ü©\n\n"}
{"name":"Topology.isUpper_orderDual","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Preorder Œ±\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Iff (Topology.IsUpper (OrderDual Œ±)) (Topology.IsLower Œ±)","decl":"lemma isUpper_orderDual [Preorder Œ±] [TopologicalSpace Œ±] : IsUpper Œ±·µí·µà ‚Üî IsLower Œ± := by\n  constructor\n  ¬∑ apply OrderDual.instIsLower\n  ¬∑ apply OrderDual.instIsUpper\n\n"}
{"name":"Topology.isLower_orderDual","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Preorder Œ±\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Iff (Topology.IsLower (OrderDual Œ±)) (Topology.IsUpper Œ±)","decl":"lemma isLower_orderDual [Preorder Œ±] [TopologicalSpace Œ±] : IsLower Œ±·µí·µà ‚Üî IsUpper Œ± :=\n  isUpper_orderDual.symm\n\n"}
{"name":"instIsUpperProp","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"‚ä¢ Topology.IsUpper Prop","decl":"/-- The Sierpi≈Ñski topology on `Prop` is the upper topology -/\ninstance : IsUpper Prop where\n  topology_eq_upperTopology := by\n    rw [Topology.upper, sierpinskiSpace, ‚Üê generateFrom_insert_empty]\n    congr\n    exact le_antisymm\n      (fun h hs => by\n        simp only [compl_Iic, mem_setOf_eq]\n        rw [‚Üê Ioi_True, ‚Üê Ioi_False] at hs\n        rcases hs with (rfl | rfl)\n        ¬∑ use True\n        ¬∑ use False)\n      (by rintro _ ‚ü®a, rfl‚ü©; by_cases a <;> aesop (add simp [Ioi, lt_iff_le_not_le]))\n"}
