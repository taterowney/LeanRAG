{"name":"Topology.WithLower.toLower_symm","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\n⊢ Eq Topology.WithLower.toLower.symm Topology.WithLower.ofLower","decl":"@[simp] lemma toLower_symm : (@toLower α).symm = ofLower := rfl\n"}
{"name":"Topology.WithLower.to_WithLower_symm_eq","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\n⊢ Eq Topology.WithLower.toLower.symm Topology.WithLower.ofLower","decl":"@[deprecated (since := \"2024-12-16\")] alias to_WithLower_symm_eq := toLower_symm\n\n"}
{"name":"Topology.WithLower.ofLower_symm","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\n⊢ Eq Topology.WithLower.ofLower.symm Topology.WithLower.toLower","decl":"@[simp] lemma ofLower_symm : (@ofLower α).symm = toLower := rfl\n"}
{"name":"Topology.WithLower.of_WithLower_symm_eq","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\n⊢ Eq Topology.WithLower.ofLower.symm Topology.WithLower.toLower","decl":"@[deprecated (since := \"2024-12-16\")] alias of_WithLower_symm_eq := ofLower_symm\n\n"}
{"name":"Topology.WithLower.toLower_ofLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\na : Topology.WithLower α\n⊢ Eq (Topology.WithLower.toLower (Topology.WithLower.ofLower a)) a","decl":"@[simp] lemma toLower_ofLower (a : WithLower α) : toLower (ofLower a) = a := rfl\n\n"}
{"name":"Topology.WithLower.ofLower_toLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Topology.WithLower.ofLower (Topology.WithLower.toLower a)) a","decl":"@[simp] lemma ofLower_toLower (a : α) : ofLower (toLower a) = a := rfl\n\n"}
{"name":"Topology.WithLower.toLower_inj","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Eq (Topology.WithLower.toLower a) (Topology.WithLower.toLower b)) (Eq a b)","decl":"lemma toLower_inj {a b : α} : toLower a = toLower b ↔ a = b := Iff.rfl\n\n-- Porting note: removed @[simp] to make linter happy\n"}
{"name":"Topology.WithLower.ofLower_inj","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\na b : Topology.WithLower α\n⊢ Iff (Eq (Topology.WithLower.ofLower a) (Topology.WithLower.ofLower b)) (Eq a b)","decl":"theorem ofLower_inj {a b : WithLower α} : ofLower a = ofLower b ↔ a = b :=\n  Iff.rfl\n\n"}
{"name":"Topology.WithLower.instNonempty","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ Nonempty (Topology.WithLower α)","decl":"instance [Nonempty α] : Nonempty (WithLower α) := ‹Nonempty α›\n"}
{"name":"Topology.WithLower.toLower_le_toLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\n⊢ Iff (LE.le (Topology.WithLower.toLower x) (Topology.WithLower.toLower y)) (LE.le x y)","decl":"@[simp] lemma toLower_le_toLower {x y : α} : toLower x ≤ toLower y ↔ x ≤ y := .rfl\n"}
{"name":"Topology.WithLower.toLower_lt_toLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\n⊢ Iff (LT.lt (Topology.WithLower.toLower x) (Topology.WithLower.toLower y)) (LT.lt x y)","decl":"@[simp] lemma toLower_lt_toLower {x y : α} : toLower x < toLower y ↔ x < y := .rfl\n"}
{"name":"Topology.WithLower.ofLower_le_ofLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : Topology.WithLower α\n⊢ Iff (LE.le (Topology.WithLower.ofLower x) (Topology.WithLower.ofLower y)) (LE.le x y)","decl":"@[simp] lemma ofLower_le_ofLower {x y : WithLower α} : ofLower x ≤ ofLower y ↔ x ≤ y := .rfl\n"}
{"name":"Topology.WithLower.ofLower_lt_ofLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : Topology.WithLower α\n⊢ Iff (LT.lt (Topology.WithLower.ofLower x) (Topology.WithLower.ofLower y)) (LT.lt x y)","decl":"@[simp] lemma ofLower_lt_ofLower {x y : WithLower α} : ofLower x < ofLower y ↔ x < y := .rfl\n\n"}
{"name":"Topology.WithLower.isOpen_preimage_ofLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (IsOpen (Set.preimage (⇑Topology.WithLower.ofLower) s)) (IsOpen s)","decl":"lemma isOpen_preimage_ofLower : IsOpen (ofLower ⁻¹' s) ↔ IsOpen[lower α] s := Iff.rfl\n\n"}
{"name":"Topology.WithLower.isOpen_def","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nT : Set (Topology.WithLower α)\n⊢ Iff (IsOpen T) (IsOpen (Set.preimage (⇑Topology.WithLower.toLower) T))","decl":"lemma isOpen_def (T : Set (WithLower α)) : IsOpen T ↔ IsOpen[lower α] (WithLower.toLower ⁻¹' T) :=\n  Iff.rfl\n\n"}
{"name":"Topology.WithLower.continuous_toLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : ClosedIciTopology α\n⊢ Continuous ⇑Topology.WithLower.toLower","decl":"theorem continuous_toLower [TopologicalSpace α] [ClosedIciTopology α] :\n    Continuous (toLower : α → WithLower α) :=\n  continuous_generateFrom_iff.mpr <| by rintro _ ⟨a, rfl⟩; exact isClosed_Ici.isOpen_compl\n\n"}
{"name":"Topology.WithUpper.toUpper_symm","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_3\n⊢ Eq Topology.WithUpper.toUpper.symm Topology.WithUpper.ofUpper","decl":"@[simp] lemma toUpper_symm {α} : (@toUpper α).symm = ofUpper := rfl\n"}
{"name":"Topology.WithUpper.to_WithUpper_symm_eq","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_3\n⊢ Eq Topology.WithUpper.toUpper.symm Topology.WithUpper.ofUpper","decl":"@[deprecated (since := \"2024-12-16\")] alias to_WithUpper_symm_eq := toUpper_symm\n"}
{"name":"Topology.WithUpper.ofUpper_symm","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\n⊢ Eq Topology.WithUpper.ofUpper.symm Topology.WithUpper.toUpper","decl":"@[simp] lemma ofUpper_symm : (@ofUpper α).symm = toUpper := rfl\n"}
{"name":"Topology.WithUpper.of_WithUpper_symm_eq","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\n⊢ Eq Topology.WithUpper.ofUpper.symm Topology.WithUpper.toUpper","decl":"@[deprecated (since := \"2024-12-16\")] alias of_WithUpper_symm_eq := ofUpper_symm\n"}
{"name":"Topology.WithUpper.toUpper_ofUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\na : Topology.WithUpper α\n⊢ Eq (Topology.WithUpper.toUpper (Topology.WithUpper.ofUpper a)) a","decl":"@[simp] lemma toUpper_ofUpper (a : WithUpper α) : toUpper (ofUpper a) = a := rfl\n"}
{"name":"Topology.WithUpper.ofUpper_toUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Topology.WithUpper.ofUpper (Topology.WithUpper.toUpper a)) a","decl":"@[simp] lemma ofUpper_toUpper (a : α) : ofUpper (toUpper a) = a := rfl\n"}
{"name":"Topology.WithUpper.toUpper_inj","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Eq (Topology.WithUpper.toUpper a) (Topology.WithUpper.toUpper b)) (Eq a b)","decl":"lemma toUpper_inj {a b : α} : toUpper a = toUpper b ↔ a = b := Iff.rfl\n"}
{"name":"Topology.WithUpper.ofUpper_inj","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\na b : Topology.WithUpper α\n⊢ Iff (Eq (Topology.WithUpper.ofUpper a) (Topology.WithUpper.ofUpper b)) (Eq a b)","decl":"lemma ofUpper_inj {a b : WithUpper α} : ofUpper a = ofUpper b ↔ a = b := Iff.rfl\n\n"}
{"name":"Topology.WithUpper.instNonempty","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ Nonempty (Topology.WithUpper α)","decl":"instance [Nonempty α] : Nonempty (WithUpper α) := ‹Nonempty α›\n"}
{"name":"Topology.WithUpper.toUpper_le_toUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\n⊢ Iff (LE.le (Topology.WithUpper.toUpper x) (Topology.WithUpper.toUpper y)) (LE.le x y)","decl":"@[simp] lemma toUpper_le_toUpper {x y : α} : toUpper x ≤ toUpper y ↔ x ≤ y := .rfl\n"}
{"name":"Topology.WithUpper.toUpper_lt_toUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\n⊢ Iff (LT.lt (Topology.WithUpper.toUpper x) (Topology.WithUpper.toUpper y)) (LT.lt x y)","decl":"@[simp] lemma toUpper_lt_toUpper {x y : α} : toUpper x < toUpper y ↔ x < y := .rfl\n"}
{"name":"Topology.WithUpper.ofUpper_le_ofUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : Topology.WithUpper α\n⊢ Iff (LE.le (Topology.WithUpper.ofUpper x) (Topology.WithUpper.ofUpper y)) (LE.le x y)","decl":"@[simp] lemma ofUpper_le_ofUpper {x y : WithUpper α} : ofUpper x ≤ ofUpper y ↔ x ≤ y := .rfl\n"}
{"name":"Topology.WithUpper.ofUpper_lt_ofUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : Topology.WithUpper α\n⊢ Iff (LT.lt (Topology.WithUpper.ofUpper x) (Topology.WithUpper.ofUpper y)) (LT.lt x y)","decl":"@[simp] lemma ofUpper_lt_ofUpper {x y : WithUpper α} : ofUpper x < ofUpper y ↔ x < y := .rfl\n\n"}
{"name":"Topology.WithUpper.isOpen_preimage_ofUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (IsOpen (Set.preimage (⇑Topology.WithUpper.ofUpper) s)) (TopologicalSpace.IsOpen s)","decl":"lemma isOpen_preimage_ofUpper : IsOpen (ofUpper ⁻¹' s) ↔ (upper α).IsOpen s := Iff.rfl\n\n"}
{"name":"Topology.WithUpper.isOpen_def","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set (Topology.WithUpper α)\n⊢ Iff (IsOpen s) (TopologicalSpace.IsOpen (Set.preimage (⇑Topology.WithUpper.toUpper) s))","decl":"lemma isOpen_def {s : Set (WithUpper α)} : IsOpen s ↔ (upper α).IsOpen (toUpper ⁻¹' s) := Iff.rfl\n\n"}
{"name":"Topology.WithUpper.continuous_toUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : ClosedIicTopology α\n⊢ Continuous ⇑Topology.WithUpper.toUpper","decl":"theorem continuous_toUpper [TopologicalSpace α] [ClosedIicTopology α] :\n    Continuous (toUpper : α → WithUpper α) :=\n  continuous_generateFrom_iff.mpr <| by rintro _ ⟨a, rfl⟩; exact isClosed_Iic.isOpen_compl\n\n"}
{"name":"Topology.IsLower.topology_eq_lowerTopology","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_3\nt : TopologicalSpace α\ninst✝ : Preorder α\nself : Topology.IsLower α\n⊢ Eq t (Topology.lower α)","decl":"/--\nThe lower topology is the topology generated by the complements of the left-closed right-infinite\nintervals.\n-/\nclass IsLower (α : Type*) [t : TopologicalSpace α] [Preorder α] : Prop where\n  topology_eq_lowerTopology : t = lower α\n\n"}
{"name":"Topology.IsUpper.topology_eq_upperTopology","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_3\nt : TopologicalSpace α\ninst✝ : Preorder α\nself : Topology.IsUpper α\n⊢ Eq t (Topology.upper α)","decl":"/--\nThe upper topology is the topology generated by the complements of the right-closed left-infinite\nintervals.\n-/\nclass IsUpper (α : Type*) [t : TopologicalSpace α] [Preorder α] : Prop where\n  topology_eq_upperTopology : t = upper α\n"}
{"name":"Topology.instIsLowerWithLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Topology.IsLower (Topology.WithLower α)","decl":"instance [Preorder α] : IsLower (WithLower α) := ⟨rfl⟩\n"}
{"name":"Topology.instIsUpperWithUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Topology.IsUpper (Topology.WithUpper α)","decl":"instance [Preorder α] : IsUpper (WithUpper α) := ⟨rfl⟩\n\n"}
{"name":"Topology.IsLower.topology_eq","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\n⊢ Eq inst✝¹ (Topology.lower α)","decl":"lemma topology_eq : ‹_› = lower α := topology_eq_lowerTopology\n\n"}
{"name":"Topology.IsLower.isOpen_iff_generate_Ici_compl","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\ns : Set α\n⊢ Iff (IsOpen s) (TopologicalSpace.GenerateOpen (setOf fun t => Exists fun a => Eq (HasCompl.compl (Set.Ici a)) t) s)","decl":"theorem isOpen_iff_generate_Ici_compl : IsOpen s ↔ GenerateOpen { t | ∃ a, (Ici a)ᶜ = t } s := by\n  rw [topology_eq α]; rfl\n\n"}
{"name":"OrderDual.instIsUpper","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\n⊢ Topology.IsUpper (OrderDual α)","decl":"instance _root_.OrderDual.instIsUpper [Preorder α] [TopologicalSpace α] [IsLower α] :\n    IsUpper αᵒᵈ where\n  topology_eq_upperTopology := topology_eq_lowerTopology (α := α)\n\n"}
{"name":"Topology.IsLower.instClosedIciTopology","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\n⊢ ClosedIciTopology α","decl":"/-- Left-closed right-infinite intervals [a, ∞) are closed in the lower topology. -/\ninstance : ClosedIciTopology α :=\n  ⟨fun a ↦ isOpen_compl_iff.1 <| isOpen_iff_generate_Ici_compl.2 <| GenerateOpen.basic _ ⟨a, rfl⟩⟩\n\n-- Porting note: The old `IsLower.isClosed_Ici` was removed, since one can now use\n-- the general `isClosed_Ici` lemma thanks to the instance above.\n\n"}
{"name":"Topology.IsLower.isClosed_upperClosure","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\ns : Set α\nh : s.Finite\n⊢ IsClosed ↑(upperClosure s)","decl":"/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem isClosed_upperClosure (h : s.Finite) : IsClosed (upperClosure s : Set α) := by\n  simp only [← UpperSet.iInf_Ici, UpperSet.coe_iInf]\n  exact h.isClosed_biUnion fun _ _ => isClosed_Ici\n\n"}
{"name":"Topology.IsLower.isLowerSet_of_isOpen","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\ns : Set α\nh : IsOpen s\n⊢ IsLowerSet s","decl":"/-- Every set open in the lower topology is a lower set. -/\ntheorem isLowerSet_of_isOpen (h : IsOpen s) : IsLowerSet s := by\n  -- Porting note: `rw` leaves a shadowed assumption\n  replace h := isOpen_iff_generate_Ici_compl.1 h\n  induction h with\n  | basic u h' => obtain ⟨a, rfl⟩ := h'; exact (isUpperSet_Ici a).compl\n  | univ => exact isLowerSet_univ\n  | inter u v _ _ hu2 hv2 => exact hu2.inter hv2\n  | sUnion _ _ ih => exact isLowerSet_sUnion ih\n\n"}
{"name":"Topology.IsLower.isUpperSet_of_isClosed","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\ns : Set α\nh : IsClosed s\n⊢ IsUpperSet s","decl":"theorem isUpperSet_of_isClosed (h : IsClosed s) : IsUpperSet s :=\n  isLowerSet_compl.1 <| isLowerSet_of_isOpen h.isOpen_compl\n\n"}
{"name":"Topology.IsLower.tendsto_nhds_iff_not_le","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\nβ : Type u_3\nf : β → α\nl : Filter β\nx : α\n⊢ Iff (Filter.Tendsto f l (nhds x)) (∀ (y : α), Not (LE.le y x) → Filter.Eventually (fun z => Not (LE.le y (f z))) l)","decl":"theorem tendsto_nhds_iff_not_le {β : Type*} {f : β → α} {l : Filter β} {x : α} :\n    Filter.Tendsto f l (𝓝 x) ↔ ∀ y, ¬y ≤ x → ∀ᶠ z in l, ¬y ≤ f z := by\n  simp [topology_eq_lowerTopology, tendsto_nhds_generateFrom_iff, Filter.Eventually, Ici,\n    compl_setOf]\n\n"}
{"name":"Topology.IsLower.closure_singleton","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\na : α\n⊢ Eq (closure (Singleton.singleton a)) (Set.Ici a)","decl":"/--\nThe closure of a singleton `{a}` in the lower topology is the left-closed right-infinite interval\n[a, ∞).\n-/\n@[simp]\ntheorem closure_singleton (a : α) : closure {a} = Ici a :=\n  Subset.antisymm ((closure_minimal fun _ h => h.ge) <| isClosed_Ici) <|\n    (isUpperSet_of_isClosed isClosed_closure).Ici_subset <| subset_closure rfl\n\n"}
{"name":"Topology.IsLower.isTopologicalBasis","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\n⊢ TopologicalSpace.IsTopologicalBasis (Topology.IsLower.lowerBasis α)","decl":"protected theorem isTopologicalBasis : IsTopologicalBasis (lowerBasis α) := by\n  convert isTopologicalBasis_of_subbasis (topology_eq α)\n  simp_rw [lowerBasis, coe_upperClosure, compl_iUnion]\n  ext s\n  constructor\n  · rintro ⟨F, hF, rfl⟩\n    refine ⟨(fun a => (Ici a)ᶜ) '' F, ⟨hF.image _, image_subset_iff.2 fun _ _ => ⟨_, rfl⟩⟩, ?_⟩\n    simp only [sInter_image]\n  · rintro ⟨F, ⟨hF, hs⟩, rfl⟩\n    haveI := hF.to_subtype\n    rw [subset_def, Subtype.forall'] at hs\n    choose f hf using hs\n    exact ⟨_, finite_range f, by simp_rw [biInter_range, hf, sInter_eq_iInter]⟩\n\n"}
{"name":"Topology.IsLower.continuous_iff_Ici","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : Topology.IsLower α\ninst✝ : TopologicalSpace β\nf : β → α\n⊢ Iff (Continuous f) (∀ (a : α), IsClosed (Set.preimage f (Set.Ici a)))","decl":"/-- A function `f : β → α` with lower topology in the codomain is continuous\nif and only if the preimage of every interval `Set.Ici a` is a closed set.\n-/\nlemma continuous_iff_Ici [TopologicalSpace β] {f : β → α} :\n    Continuous f ↔ ∀ a, IsClosed (f ⁻¹' (Ici a)) := by\n  obtain rfl := IsLower.topology_eq α\n  simp [continuous_generateFrom_iff]\n\n"}
{"name":"Topology.IsLower.t0Space","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : TopologicalSpace α\n⊢ T0Space α","decl":"/-- The lower topology on a partial order is T₀. -/\ninstance (priority := 90) t0Space : T0Space α :=\n  (t0Space_iff_inseparable α).2 fun x y h =>\n    Ici_injective <| by simpa only [inseparable_iff_closure_eq, closure_singleton] using h\n\n"}
{"name":"Topology.IsLower.isTopologicalBasis_insert_univ_subbasis","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\n⊢ TopologicalSpace.IsTopologicalBasis (Insert.insert Set.univ (setOf fun s => Exists fun a => Eq (HasCompl.compl (Set.Ici a)) s))","decl":"lemma isTopologicalBasis_insert_univ_subbasis :\n    IsTopologicalBasis (insert univ {s : Set α | ∃ a, (Ici a)ᶜ = s}) :=\n  isTopologicalBasis_of_subbasis_of_inter (by rw [topology_eq α, lower]) (by\n    rintro _ ⟨b, rfl⟩ _ ⟨c, rfl⟩\n    use b ⊓ c\n    rw [compl_Ici, compl_Ici, compl_Ici, Iio_inter_Iio])\n\n"}
{"name":"Topology.IsLower.tendsto_nhds_iff_lt","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\nβ : Type u_3\nf : β → α\nl : Filter β\nx : α\n⊢ Iff (Filter.Tendsto f l (nhds x)) (∀ (y : α), LT.lt x y → Filter.Eventually (fun z => LT.lt (f z) y) l)","decl":"theorem tendsto_nhds_iff_lt {β : Type*} {f : β → α} {l : Filter β} {x : α} :\n    Filter.Tendsto f l (𝓝 x) ↔ ∀ y, x < y → ∀ᶠ z in l, f z < y := by\n  simp only [tendsto_nhds_iff_not_le, not_le]\n\n"}
{"name":"Topology.IsLower.isTopologicalSpace_basis","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLinearOrder α\nt : TopologicalSpace α\ninst✝ : Topology.IsLower α\nU : Set α\n⊢ Iff (IsOpen U) (Or (Eq U Set.univ) (Exists fun a => Eq (HasCompl.compl (Set.Ici a)) U))","decl":"lemma isTopologicalSpace_basis (U : Set α) : IsOpen U ↔ U = univ ∨ ∃ a, (Ici a)ᶜ = U := by\n  by_cases hU : U = univ\n  · simp only [hU, isOpen_univ, compl_Ici, true_or]\n  refine ⟨?_, isTopologicalBasis_insert_univ_subbasis.isOpen⟩\n  intro hO\n  apply Or.inr\n  convert IsTopologicalBasis.open_eq_sUnion isTopologicalBasis_insert_univ_subbasis hO\n  constructor\n  · intro ⟨a, ha⟩\n    use {U}\n    constructor\n    · apply subset_trans (singleton_subset_iff.mpr _) (subset_insert _ _)\n      use a\n    · rw [sUnion_singleton]\n  · intro ⟨S, hS1, hS2⟩\n    have hUS : univ ∉ S := by\n      by_contra hUS'\n      apply hU\n      rw [hS2]\n      exact sUnion_eq_univ_iff.mpr (fun a => ⟨univ, hUS', trivial⟩)\n    use sSup {a | (Ici a)ᶜ ∈ S}\n    rw [hS2, sUnion_eq_compl_sInter_compl, compl_inj_iff]\n    apply le_antisymm\n    · intro b hb\n      simp only [sInter_image, mem_iInter, mem_compl_iff]\n      intro s hs\n      obtain ⟨a,ha⟩ := (subset_insert_iff_of_not_mem hUS).mp hS1 hs\n      subst hS2 ha\n      simp_all only [compl_Ici, mem_Ici, sSup_le_iff, mem_setOf_eq, mem_Iio, not_lt]\n    · intro b hb\n      rw [mem_Ici, sSup_le_iff]\n      intro c hc\n      simp only [sInter_image, mem_iInter] at hb\n      rw [← not_lt, ← mem_Iio, ← compl_Ici]\n      exact hb _ hc\n\n"}
{"name":"Topology.IsUpper.topology_eq","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\n⊢ Eq inst✝¹ (Topology.upper α)","decl":"lemma topology_eq : ‹_› = upper α := topology_eq_upperTopology\n\n"}
{"name":"Topology.IsUpper.isOpen_iff_generate_Iic_compl","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\ns : Set α\n⊢ Iff (IsOpen s) (TopologicalSpace.GenerateOpen (setOf fun t => Exists fun a => Eq (HasCompl.compl (Set.Iic a)) t) s)","decl":"theorem isOpen_iff_generate_Iic_compl : IsOpen s ↔ GenerateOpen { t | ∃ a, (Iic a)ᶜ = t } s := by\n  rw [topology_eq α]; rfl\n\n"}
{"name":"OrderDual.instIsLower","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\n⊢ Topology.IsLower (OrderDual α)","decl":"instance _root_.OrderDual.instIsLower [Preorder α] [TopologicalSpace α] [IsUpper α] :\n    IsLower αᵒᵈ where\n  topology_eq_lowerTopology := topology_eq_upperTopology (α := α)\n\n"}
{"name":"Topology.IsUpper.instClosedIicTopology","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\n⊢ ClosedIicTopology α","decl":"/-- Left-infinite right-closed intervals (-∞,a] are closed in the upper topology. -/\ninstance : ClosedIicTopology α :=\n  ⟨fun a ↦ isOpen_compl_iff.1 <| isOpen_iff_generate_Iic_compl.2 <| GenerateOpen.basic _ ⟨a, rfl⟩⟩\n\n"}
{"name":"Topology.IsUpper.isClosed_lowerClosure","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\ns : Set α\nh : s.Finite\n⊢ IsClosed ↑(lowerClosure s)","decl":"/-- The lower closure of a finite set is closed in the upper topology. -/\ntheorem isClosed_lowerClosure (h : s.Finite) : IsClosed (lowerClosure s : Set α) :=\n  IsLower.isClosed_upperClosure (α := αᵒᵈ) h\n\n"}
{"name":"Topology.IsUpper.isUpperSet_of_isOpen","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\ns : Set α\nh : IsOpen s\n⊢ IsUpperSet s","decl":"/-- Every set open in the upper topology is a upper set. -/\ntheorem isUpperSet_of_isOpen (h : IsOpen s) : IsUpperSet s :=\n  IsLower.isLowerSet_of_isOpen (α := αᵒᵈ) h\n\n"}
{"name":"Topology.IsUpper.isLowerSet_of_isClosed","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\ns : Set α\nh : IsClosed s\n⊢ IsLowerSet s","decl":"theorem isLowerSet_of_isClosed (h : IsClosed s) : IsLowerSet s :=\n  isUpperSet_compl.1 <| isUpperSet_of_isOpen h.isOpen_compl\n\n"}
{"name":"Topology.IsUpper.tendsto_nhds_iff_not_le","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\nβ : Type u_3\nf : β → α\nl : Filter β\nx : α\n⊢ Iff (Filter.Tendsto f l (nhds x)) (∀ (y : α), Not (LE.le x y) → Filter.Eventually (fun z => Not (LE.le (f z) y)) l)","decl":"theorem tendsto_nhds_iff_not_le {β : Type*} {f : β → α} {l : Filter β} {x : α} :\n    Filter.Tendsto f l (𝓝 x) ↔ ∀ y, ¬x ≤ y → ∀ᶠ z in l, ¬f z ≤ y :=\n  IsLower.tendsto_nhds_iff_not_le (α := αᵒᵈ)\n\n"}
{"name":"Topology.IsUpper.closure_singleton","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\na : α\n⊢ Eq (closure (Singleton.singleton a)) (Set.Iic a)","decl":"/--\nThe closure of a singleton `{a}` in the upper topology is the left-infinite right-closed interval\n(-∞,a].\n-/\n@[simp]\ntheorem closure_singleton (a : α) : closure {a} = Iic a :=\n  IsLower.closure_singleton (α := αᵒᵈ) _\n\n"}
{"name":"Topology.IsUpper.isTopologicalBasis","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\n⊢ TopologicalSpace.IsTopologicalBasis (Topology.IsUpper.upperBasis α)","decl":"protected theorem isTopologicalBasis : IsTopologicalBasis (upperBasis α) :=\n  IsLower.isTopologicalBasis (α := αᵒᵈ)\n\n"}
{"name":"Topology.IsUpper.continuous_iff_Iic","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : Topology.IsUpper α\ninst✝ : TopologicalSpace β\nf : β → α\n⊢ Iff (Continuous f) (∀ (a : α), IsClosed (Set.preimage f (Set.Iic a)))","decl":"/-- A function `f : β → α` with upper topology in the codomain is continuous\nif and only if the preimage of every interval `Set.Iic a` is a closed set. -/\nlemma continuous_iff_Iic [TopologicalSpace β] {f : β → α} :\n    Continuous f ↔ ∀ a, IsClosed (f ⁻¹' (Iic a)) :=\n  IsLower.continuous_iff_Ici (α := αᵒᵈ)\n\n"}
{"name":"Topology.IsUpper.t0Space","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : TopologicalSpace α\n⊢ T0Space α","decl":"/-- The upper topology on a partial order is T₀. -/\ninstance (priority := 90) t0Space : T0Space α :=\n  IsLower.t0Space (α := αᵒᵈ)\n\n"}
{"name":"Topology.IsUpper.isTopologicalBasis_insert_univ_subbasis","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\n⊢ TopologicalSpace.IsTopologicalBasis (Insert.insert Set.univ (setOf fun s => Exists fun a => Eq (HasCompl.compl (Set.Iic a)) s))","decl":"lemma isTopologicalBasis_insert_univ_subbasis :\n    IsTopologicalBasis (insert univ {s : Set α | ∃ a, (Iic a)ᶜ = s}) :=\n  IsLower.isTopologicalBasis_insert_univ_subbasis (α := αᵒᵈ)\n\n"}
{"name":"Topology.IsUpper.tendsto_nhds_iff_lt","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\nβ : Type u_3\nf : β → α\nl : Filter β\nx : α\n⊢ Iff (Filter.Tendsto f l (nhds x)) (∀ (y : α), LT.lt y x → Filter.Eventually (fun z => LT.lt y (f z)) l)","decl":"theorem tendsto_nhds_iff_lt {β : Type*} {f : β → α} {l : Filter β} {x : α} :\n    Filter.Tendsto f l (𝓝 x) ↔ ∀ y < x, ∀ᶠ z in l, y < f z :=\n  IsLower.tendsto_nhds_iff_lt (α := αᵒᵈ)\n\n"}
{"name":"Topology.IsUpper.isTopologicalSpace_basis","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLinearOrder α\nt : TopologicalSpace α\ninst✝ : Topology.IsUpper α\nU : Set α\n⊢ Iff (IsOpen U) (Or (Eq U Set.univ) (Exists fun a => Eq (HasCompl.compl (Set.Iic a)) U))","decl":"lemma isTopologicalSpace_basis (U : Set α) : IsOpen U ↔ U = univ ∨ ∃ a, (Iic a)ᶜ = U :=\n  IsLower.isTopologicalSpace_basis (α := αᵒᵈ) U\n\n"}
{"name":"Topology.instIsLowerProd","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁷ : Preorder α\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : Topology.IsLower α\ninst✝⁴ : OrderBot α\ninst✝³ : Preorder β\ninst✝² : TopologicalSpace β\ninst✝¹ : Topology.IsLower β\ninst✝ : OrderBot β\n⊢ Topology.IsLower (Prod α β)","decl":"instance instIsLowerProd [Preorder α] [TopologicalSpace α] [IsLower α]\n    [OrderBot α] [Preorder β] [TopologicalSpace β] [IsLower β] [OrderBot β] :\n    IsLower (α × β) where\n  topology_eq_lowerTopology := by\n    refine le_antisymm (le_generateFrom ?_) ?_\n    · rintro _ ⟨x, rfl⟩\n      exact (isClosed_Ici.prod isClosed_Ici).isOpen_compl\n    rw [(IsLower.isTopologicalBasis.prod\n      IsLower.isTopologicalBasis).eq_generateFrom, le_generateFrom_iff_subset_isOpen,\n      image2_subset_iff]\n    rintro _ ⟨s, hs, rfl⟩ _ ⟨t, ht, rfl⟩\n    dsimp\n    simp_rw [coe_upperClosure, compl_iUnion, prod_eq, preimage_iInter, preimage_compl]\n    -- without `let`, `refine` tries to use the product topology and fails\n    let _ : TopologicalSpace (α × β) := lower (α × β)\n    refine (hs.isOpen_biInter fun a _ => ?_).inter (ht.isOpen_biInter fun b _ => ?_)\n    · exact GenerateOpen.basic _ ⟨(a, ⊥), by simp [Ici_prod_eq, prod_univ]⟩\n    · exact GenerateOpen.basic _ ⟨(⊥, b), by simp [Ici_prod_eq, univ_prod]⟩\n\n"}
{"name":"Topology.instIsUpperProd","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁷ : Preorder α\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : Topology.IsUpper α\ninst✝⁴ : OrderTop α\ninst✝³ : Preorder β\ninst✝² : TopologicalSpace β\ninst✝¹ : Topology.IsUpper β\ninst✝ : OrderTop β\n⊢ Topology.IsUpper (Prod α β)","decl":"instance instIsUpperProd [Preorder α] [TopologicalSpace α] [IsUpper α]\n    [OrderTop α] [Preorder β] [TopologicalSpace β] [IsUpper β] [OrderTop β] :\n    IsUpper (α × β) where\n  topology_eq_upperTopology := by\n    suffices IsLower (α × β)ᵒᵈ from IsLower.topology_eq_lowerTopology (α := (α × β)ᵒᵈ)\n    exact instIsLowerProd (α := αᵒᵈ) (β := βᵒᵈ)\n\n"}
{"name":"sInfHom.continuous","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : CompleteLattice α\ninst✝⁴ : CompleteLattice β\ninst✝³ : TopologicalSpace α\ninst✝² : Topology.IsLower α\ninst✝¹ : TopologicalSpace β\ninst✝ : Topology.IsLower β\nf : sInfHom α β\n⊢ Continuous ⇑f","decl":"protected lemma _root_.sInfHom.continuous (f : sInfHom α β) : Continuous f := by\n  refine IsLower.continuous_iff_Ici.2 fun b => ?_\n  convert isClosed_Ici (a := sInf <| f ⁻¹' Ici b)\n  refine Subset.antisymm (fun a => sInf_le) fun a ha => le_trans ?_ <|\n    OrderHomClass.mono (f : α →o β) ha\n  refine LE.le.trans ?_ (map_sInf f _).ge\n  simp\n\n-- see Note [lower instance priority]\n"}
{"name":"Topology.IsLower.toContinuousInf","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : CompleteLattice α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsLower α\n⊢ ContinuousInf α","decl":"instance (priority := 90) IsLower.toContinuousInf : ContinuousInf α :=\n  ⟨(infsInfHom : sInfHom (α × α) α).continuous⟩\n\n"}
{"name":"sSupHom.continuous","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : CompleteLattice α\ninst✝⁴ : CompleteLattice β\ninst✝³ : TopologicalSpace α\ninst✝² : Topology.IsUpper α\ninst✝¹ : TopologicalSpace β\ninst✝ : Topology.IsUpper β\nf : sSupHom α β\n⊢ Continuous ⇑f","decl":"protected lemma _root_.sSupHom.continuous (f : sSupHom α β) : Continuous f :=\n  sInfHom.continuous (α := αᵒᵈ) (β := βᵒᵈ) (sSupHom.dual.toFun f)\n\n-- see Note [lower instance priority]\n"}
{"name":"Topology.IsUpper.toContinuousInf","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝² : CompleteLattice α\ninst✝¹ : TopologicalSpace α\ninst✝ : Topology.IsUpper α\n⊢ ContinuousSup α","decl":"instance (priority := 90) IsUpper.toContinuousInf : ContinuousSup α :=\n  ⟨(supsSupHom : sSupHom (α × α) α).continuous⟩\n\n"}
{"name":"Topology.isUpper_orderDual","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : TopologicalSpace α\n⊢ Iff (Topology.IsUpper (OrderDual α)) (Topology.IsLower α)","decl":"lemma isUpper_orderDual [Preorder α] [TopologicalSpace α] : IsUpper αᵒᵈ ↔ IsLower α := by\n  constructor\n  · apply OrderDual.instIsLower\n  · apply OrderDual.instIsUpper\n\n"}
{"name":"Topology.isLower_orderDual","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : TopologicalSpace α\n⊢ Iff (Topology.IsLower (OrderDual α)) (Topology.IsUpper α)","decl":"lemma isLower_orderDual [Preorder α] [TopologicalSpace α] : IsLower αᵒᵈ ↔ IsUpper α :=\n  isUpper_orderDual.symm\n\n"}
{"name":"instIsUpperProp","module":"Mathlib.Topology.Order.LowerUpperTopology","initialProofState":"⊢ Topology.IsUpper Prop","decl":"/-- The Sierpiński topology on `Prop` is the upper topology -/\ninstance : IsUpper Prop where\n  topology_eq_upperTopology := by\n    rw [Topology.upper, sierpinskiSpace, ← generateFrom_insert_empty]\n    congr\n    exact le_antisymm\n      (fun h hs => by\n        simp only [compl_Iic, mem_setOf_eq]\n        rw [← Ioi_True, ← Ioi_False] at hs\n        rcases hs with (rfl | rfl)\n        · use True\n        · use False)\n      (by rintro _ ⟨a, rfl⟩; by_cases a <;> aesop (add simp [Ioi, lt_iff_le_not_le]))\n"}
