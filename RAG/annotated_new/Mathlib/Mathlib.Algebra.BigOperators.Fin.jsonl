{"name":"Finset.sum_range","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nn : Nat\nf : Nat → β\n⊢ Eq ((Finset.range n).sum fun i => f i) (Finset.univ.sum fun i => f ↑i)","decl":"@[to_additive]\ntheorem prod_range [CommMonoid β] {n : ℕ} (f : ℕ → β) :\n    ∏ i ∈ Finset.range n, f i = ∏ i : Fin n, f i :=\n  (Fin.prod_univ_eq_prod_range _ _).symm\n\n"}
{"name":"Finset.prod_range","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nn : Nat\nf : Nat → β\n⊢ Eq ((Finset.range n).prod fun i => f i) (Finset.univ.prod fun i => f ↑i)","decl":"@[to_additive]\ntheorem prod_range [CommMonoid β] {n : ℕ} (f : ℕ → β) :\n    ∏ i ∈ Finset.range n, f i = ∏ i : Fin n, f i :=\n  (Fin.prod_univ_eq_prod_range _ _).symm\n\n"}
{"name":"Fin.prod_ofFn","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nn : Nat\nf : Fin n → β\n⊢ Eq (List.ofFn f).prod (Finset.univ.prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_ofFn [CommMonoid β] {n : ℕ} (f : Fin n → β) : (List.ofFn f).prod = ∏ i, f i := by\n  simp [prod_eq_multiset_prod]\n\n"}
{"name":"Fin.sum_ofFn","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nn : Nat\nf : Fin n → β\n⊢ Eq (List.ofFn f).sum (Finset.univ.sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_ofFn [CommMonoid β] {n : ℕ} (f : Fin n → β) : (List.ofFn f).prod = ∏ i, f i := by\n  simp [prod_eq_multiset_prod]\n\n"}
{"name":"Fin.prod_univ_def","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nn : Nat\nf : Fin n → β\n⊢ Eq (Finset.univ.prod fun i => f i) (List.map f (List.finRange n)).prod","decl":"@[to_additive]\ntheorem prod_univ_def [CommMonoid β] {n : ℕ} (f : Fin n → β) :\n    ∏ i, f i = ((List.finRange n).map f).prod := by\n  rw [← List.ofFn_eq_map, prod_ofFn]\n\n"}
{"name":"Fin.sum_univ_def","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nn : Nat\nf : Fin n → β\n⊢ Eq (Finset.univ.sum fun i => f i) (List.map f (List.finRange n)).sum","decl":"@[to_additive]\ntheorem prod_univ_def [CommMonoid β] {n : ℕ} (f : Fin n → β) :\n    ∏ i, f i = ((List.finRange n).map f).prod := by\n  rw [← List.ofFn_eq_map, prod_ofFn]\n\n"}
{"name":"Fin.prod_univ_zero","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nf : Fin 0 → β\n⊢ Eq (Finset.univ.prod fun i => f i) 1","decl":"/-- A product of a function `f : Fin 0 → β` is `1` because `Fin 0` is empty -/\n@[to_additive \"A sum of a function `f : Fin 0 → β` is `0` because `Fin 0` is empty\"]\ntheorem prod_univ_zero [CommMonoid β] (f : Fin 0 → β) : ∏ i, f i = 1 :=\n  rfl\n\n"}
{"name":"Fin.sum_univ_zero","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nf : Fin 0 → β\n⊢ Eq (Finset.univ.sum fun i => f i) 0","decl":"/-- A product of a function `f : Fin 0 → β` is `1` because `Fin 0` is empty -/\n@[to_additive \"A sum of a function `f : Fin 0 → β` is `0` because `Fin 0` is empty\"]\ntheorem prod_univ_zero [CommMonoid β] (f : Fin 0 → β) : ∏ i, f i = 1 :=\n  rfl\n\n"}
{"name":"Fin.prod_univ_succAbove","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nn : Nat\nf : Fin (HAdd.hAdd n 1) → β\nx : Fin (HAdd.hAdd n 1)\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul (f x) (Finset.univ.prod fun i => f (x.succAbove i)))","decl":"/-- A product of a function `f : Fin (n + 1) → β` over all `Fin (n + 1)`\nis the product of `f x`, for some `x : Fin (n + 1)` times the remaining product -/\n@[to_additive \"A sum of a function `f : Fin (n + 1) → β` over all `Fin (n + 1)` is the sum of\n`f x`, for some `x : Fin (n + 1)` plus the remaining sum\"]\ntheorem prod_univ_succAbove [CommMonoid β] {n : ℕ} (f : Fin (n + 1) → β) (x : Fin (n + 1)) :\n    ∏ i, f i = f x * ∏ i : Fin n, f (x.succAbove i) := by\n  rw [univ_succAbove, prod_cons, Finset.prod_map _ x.succAboveEmb]\n  rfl\n\n"}
{"name":"Fin.sum_univ_succAbove","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nn : Nat\nf : Fin (HAdd.hAdd n 1) → β\nx : Fin (HAdd.hAdd n 1)\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (f x) (Finset.univ.sum fun i => f (x.succAbove i)))","decl":"/-- A product of a function `f : Fin (n + 1) → β` over all `Fin (n + 1)`\nis the product of `f x`, for some `x : Fin (n + 1)` times the remaining product -/\n@[to_additive \"A sum of a function `f : Fin (n + 1) → β` over all `Fin (n + 1)` is the sum of\n`f x`, for some `x : Fin (n + 1)` plus the remaining sum\"]\ntheorem prod_univ_succAbove [CommMonoid β] {n : ℕ} (f : Fin (n + 1) → β) (x : Fin (n + 1)) :\n    ∏ i, f i = f x * ∏ i : Fin n, f (x.succAbove i) := by\n  rw [univ_succAbove, prod_cons, Finset.prod_map _ x.succAboveEmb]\n  rfl\n\n"}
{"name":"Fin.prod_univ_succ","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nn : Nat\nf : Fin (HAdd.hAdd n 1) → β\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul (f 0) (Finset.univ.prod fun i => f i.succ))","decl":"/-- A product of a function `f : Fin (n + 1) → β` over all `Fin (n + 1)`\nis the product of `f 0` plus the remaining product -/\n@[to_additive \"A sum of a function `f : Fin (n + 1) → β` over all `Fin (n + 1)` is the sum of\n`f 0` plus the remaining sum\"]\ntheorem prod_univ_succ [CommMonoid β] {n : ℕ} (f : Fin (n + 1) → β) :\n    ∏ i, f i = f 0 * ∏ i : Fin n, f i.succ :=\n  prod_univ_succAbove f 0\n\n"}
{"name":"Fin.sum_univ_succ","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nn : Nat\nf : Fin (HAdd.hAdd n 1) → β\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (f 0) (Finset.univ.sum fun i => f i.succ))","decl":"/-- A product of a function `f : Fin (n + 1) → β` over all `Fin (n + 1)`\nis the product of `f 0` plus the remaining product -/\n@[to_additive \"A sum of a function `f : Fin (n + 1) → β` over all `Fin (n + 1)` is the sum of\n`f 0` plus the remaining sum\"]\ntheorem prod_univ_succ [CommMonoid β] {n : ℕ} (f : Fin (n + 1) → β) :\n    ∏ i, f i = f 0 * ∏ i : Fin n, f i.succ :=\n  prod_univ_succAbove f 0\n\n"}
{"name":"Fin.prod_univ_castSucc","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nn : Nat\nf : Fin (HAdd.hAdd n 1) → β\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul (Finset.univ.prod fun i => f i.castSucc) (f (Fin.last n)))","decl":"/-- A product of a function `f : Fin (n + 1) → β` over all `Fin (n + 1)`\nis the product of `f (Fin.last n)` plus the remaining product -/\n@[to_additive \"A sum of a function `f : Fin (n + 1) → β` over all `Fin (n + 1)` is the sum of\n`f (Fin.last n)` plus the remaining sum\"]\ntheorem prod_univ_castSucc [CommMonoid β] {n : ℕ} (f : Fin (n + 1) → β) :\n    ∏ i, f i = (∏ i : Fin n, f (Fin.castSucc i)) * f (last n) := by\n  simpa [mul_comm] using prod_univ_succAbove f (last n)\n\n"}
{"name":"Fin.sum_univ_castSucc","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nn : Nat\nf : Fin (HAdd.hAdd n 1) → β\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (Finset.univ.sum fun i => f i.castSucc) (f (Fin.last n)))","decl":"/-- A product of a function `f : Fin (n + 1) → β` over all `Fin (n + 1)`\nis the product of `f (Fin.last n)` plus the remaining product -/\n@[to_additive \"A sum of a function `f : Fin (n + 1) → β` over all `Fin (n + 1)` is the sum of\n`f (Fin.last n)` plus the remaining sum\"]\ntheorem prod_univ_castSucc [CommMonoid β] {n : ℕ} (f : Fin (n + 1) → β) :\n    ∏ i, f i = (∏ i : Fin n, f (Fin.castSucc i)) * f (last n) := by\n  simpa [mul_comm] using prod_univ_succAbove f (last n)\n\n"}
{"name":"Fin.sum_univ_get","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\nl : List α\n⊢ Eq (Finset.univ.sum fun i => GetElem.getElem l ↑i ⋯) l.sum","decl":"@[to_additive (attr := simp)]\ntheorem prod_univ_get [CommMonoid α] (l : List α) : ∏ i : Fin l.length, l[i.1] = l.prod := by\n  simp [Finset.prod_eq_multiset_prod]\n\n"}
{"name":"Fin.prod_univ_get","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\nl : List α\n⊢ Eq (Finset.univ.prod fun i => GetElem.getElem l ↑i ⋯) l.prod","decl":"@[to_additive (attr := simp)]\ntheorem prod_univ_get [CommMonoid α] (l : List α) : ∏ i : Fin l.length, l[i.1] = l.prod := by\n  simp [Finset.prod_eq_multiset_prod]\n\n"}
{"name":"Fin.sum_univ_get'","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : AddCommMonoid β\nl : List α\nf : α → β\n⊢ Eq (Finset.univ.sum fun i => f (GetElem.getElem l ↑i ⋯)) (List.map f l).sum","decl":"@[to_additive (attr := simp)]\ntheorem prod_univ_get' [CommMonoid β] (l : List α) (f : α → β) :\n    ∏ i : Fin l.length, f l[i.1] = (l.map f).prod := by\n  simp [Finset.prod_eq_multiset_prod]\n\n"}
{"name":"Fin.prod_univ_get'","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CommMonoid β\nl : List α\nf : α → β\n⊢ Eq (Finset.univ.prod fun i => f (GetElem.getElem l ↑i ⋯)) (List.map f l).prod","decl":"@[to_additive (attr := simp)]\ntheorem prod_univ_get' [CommMonoid β] (l : List α) (f : α → β) :\n    ∏ i : Fin l.length, f l[i.1] = (l.map f).prod := by\n  simp [Finset.prod_eq_multiset_prod]\n\n"}
{"name":"Fin.prod_cons","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nn : Nat\nx : β\nf : Fin n → β\n⊢ Eq (Finset.univ.prod fun i => Fin.cons x f i) (HMul.hMul x (Finset.univ.prod fun i => f i))","decl":"@[to_additive (attr := simp)]\ntheorem prod_cons [CommMonoid β] {n : ℕ} (x : β) (f : Fin n → β) :\n    (∏ i : Fin n.succ, (cons x f : Fin n.succ → β) i) = x * ∏ i : Fin n, f i := by\n  simp_rw [prod_univ_succ, cons_zero, cons_succ]\n\n"}
{"name":"Fin.sum_cons","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nn : Nat\nx : β\nf : Fin n → β\n⊢ Eq (Finset.univ.sum fun i => Fin.cons x f i) (HAdd.hAdd x (Finset.univ.sum fun i => f i))","decl":"@[to_additive (attr := simp)]\ntheorem prod_cons [CommMonoid β] {n : ℕ} (x : β) (f : Fin n → β) :\n    (∏ i : Fin n.succ, (cons x f : Fin n.succ → β) i) = x * ∏ i : Fin n, f i := by\n  simp_rw [prod_univ_succ, cons_zero, cons_succ]\n\n"}
{"name":"Fin.prod_snoc","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nn : Nat\nx : β\nf : Fin n → β\n⊢ Eq (Finset.univ.prod fun i => Fin.snoc f x i) (HMul.hMul (Finset.univ.prod fun i => f i) x)","decl":"@[to_additive (attr := simp)]\ntheorem prod_snoc [CommMonoid β] {n : ℕ} (x : β) (f : Fin n → β) :\n    (∏ i : Fin n.succ, (snoc f x : Fin n.succ → β) i) = (∏ i : Fin n, f i) * x := by\n  simp [prod_univ_castSucc]\n\n"}
{"name":"Fin.sum_snoc","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nn : Nat\nx : β\nf : Fin n → β\n⊢ Eq (Finset.univ.sum fun i => Fin.snoc f x i) (HAdd.hAdd (Finset.univ.sum fun i => f i) x)","decl":"@[to_additive (attr := simp)]\ntheorem prod_snoc [CommMonoid β] {n : ℕ} (x : β) (f : Fin n → β) :\n    (∏ i : Fin n.succ, (snoc f x : Fin n.succ → β) i) = (∏ i : Fin n, f i) * x := by\n  simp [prod_univ_castSucc]\n\n"}
{"name":"Fin.sum_univ_one","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nf : Fin 1 → β\n⊢ Eq (Finset.univ.sum fun i => f i) (f 0)","decl":"@[to_additive sum_univ_one]\ntheorem prod_univ_one [CommMonoid β] (f : Fin 1 → β) : ∏ i, f i = f 0 := by simp\n\n"}
{"name":"Fin.prod_univ_one","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nf : Fin 1 → β\n⊢ Eq (Finset.univ.prod fun i => f i) (f 0)","decl":"@[to_additive sum_univ_one]\ntheorem prod_univ_one [CommMonoid β] (f : Fin 1 → β) : ∏ i, f i = f 0 := by simp\n\n"}
{"name":"Fin.prod_univ_two","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nf : Fin 2 → β\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul (f 0) (f 1))","decl":"@[to_additive (attr := simp)]\ntheorem prod_univ_two [CommMonoid β] (f : Fin 2 → β) : ∏ i, f i = f 0 * f 1 := by\n  simp [prod_univ_succ]\n\n"}
{"name":"Fin.sum_univ_two","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nf : Fin 2 → β\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (f 0) (f 1))","decl":"@[to_additive (attr := simp)]\ntheorem prod_univ_two [CommMonoid β] (f : Fin 2 → β) : ∏ i, f i = f 0 * f 1 := by\n  simp [prod_univ_succ]\n\n"}
{"name":"Fin.sum_univ_two'","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : AddCommMonoid β\nf : α → β\na b : α\n⊢ Eq (Finset.univ.sum fun i => f (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty) i)) (HAdd.hAdd (f a) (f b))","decl":"@[to_additive]\ntheorem prod_univ_two' [CommMonoid β] (f : α → β) (a b : α) :\n    ∏ i, f (![a, b] i) = f a * f b :=\n  prod_univ_two _\n\n"}
{"name":"Fin.prod_univ_two'","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CommMonoid β\nf : α → β\na b : α\n⊢ Eq (Finset.univ.prod fun i => f (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty) i)) (HMul.hMul (f a) (f b))","decl":"@[to_additive]\ntheorem prod_univ_two' [CommMonoid β] (f : α → β) (a b : α) :\n    ∏ i, f (![a, b] i) = f a * f b :=\n  prod_univ_two _\n\n"}
{"name":"Fin.prod_univ_three","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nf : Fin 3 → β\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul (HMul.hMul (f 0) (f 1)) (f 2))","decl":"@[to_additive]\ntheorem prod_univ_three [CommMonoid β] (f : Fin 3 → β) : ∏ i, f i = f 0 * f 1 * f 2 := by\n  rw [prod_univ_castSucc, prod_univ_two]\n  rfl\n\n"}
{"name":"Fin.sum_univ_three","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nf : Fin 3 → β\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (HAdd.hAdd (f 0) (f 1)) (f 2))","decl":"@[to_additive]\ntheorem prod_univ_three [CommMonoid β] (f : Fin 3 → β) : ∏ i, f i = f 0 * f 1 * f 2 := by\n  rw [prod_univ_castSucc, prod_univ_two]\n  rfl\n\n"}
{"name":"Fin.prod_univ_four","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nf : Fin 4 → β\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul (HMul.hMul (HMul.hMul (f 0) (f 1)) (f 2)) (f 3))","decl":"@[to_additive]\ntheorem prod_univ_four [CommMonoid β] (f : Fin 4 → β) : ∏ i, f i = f 0 * f 1 * f 2 * f 3 := by\n  rw [prod_univ_castSucc, prod_univ_three]\n  rfl\n\n"}
{"name":"Fin.sum_univ_four","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nf : Fin 4 → β\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (f 0) (f 1)) (f 2)) (f 3))","decl":"@[to_additive]\ntheorem prod_univ_four [CommMonoid β] (f : Fin 4 → β) : ∏ i, f i = f 0 * f 1 * f 2 * f 3 := by\n  rw [prod_univ_castSucc, prod_univ_three]\n  rfl\n\n"}
{"name":"Fin.prod_univ_five","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nf : Fin 5 → β\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (f 0) (f 1)) (f 2)) (f 3)) (f 4))","decl":"@[to_additive]\ntheorem prod_univ_five [CommMonoid β] (f : Fin 5 → β) :\n    ∏ i, f i = f 0 * f 1 * f 2 * f 3 * f 4 := by\n  rw [prod_univ_castSucc, prod_univ_four]\n  rfl\n\n"}
{"name":"Fin.sum_univ_five","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nf : Fin 5 → β\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (f 0) (f 1)) (f 2)) (f 3)) (f 4))","decl":"@[to_additive]\ntheorem prod_univ_five [CommMonoid β] (f : Fin 5 → β) :\n    ∏ i, f i = f 0 * f 1 * f 2 * f 3 * f 4 := by\n  rw [prod_univ_castSucc, prod_univ_four]\n  rfl\n\n"}
{"name":"Fin.prod_univ_six","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nf : Fin 6 → β\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (f 0) (f 1)) (f 2)) (f 3)) (f 4)) (f 5))","decl":"@[to_additive]\ntheorem prod_univ_six [CommMonoid β] (f : Fin 6 → β) :\n    ∏ i, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5 := by\n  rw [prod_univ_castSucc, prod_univ_five]\n  rfl\n\n"}
{"name":"Fin.sum_univ_six","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nf : Fin 6 → β\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (f 0) (f 1)) (f 2)) (f 3)) (f 4)) (f 5))","decl":"@[to_additive]\ntheorem prod_univ_six [CommMonoid β] (f : Fin 6 → β) :\n    ∏ i, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5 := by\n  rw [prod_univ_castSucc, prod_univ_five]\n  rfl\n\n"}
{"name":"Fin.prod_univ_seven","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nf : Fin 7 → β\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (f 0) (f 1)) (f 2)) (f 3)) (f 4)) (f 5)) (f 6))","decl":"@[to_additive]\ntheorem prod_univ_seven [CommMonoid β] (f : Fin 7 → β) :\n    ∏ i, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6 := by\n  rw [prod_univ_castSucc, prod_univ_six]\n  rfl\n\n"}
{"name":"Fin.sum_univ_seven","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nf : Fin 7 → β\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (f 0) (f 1)) (f 2)) (f 3)) (f 4)) (f 5)) (f 6))","decl":"@[to_additive]\ntheorem prod_univ_seven [CommMonoid β] (f : Fin 7 → β) :\n    ∏ i, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6 := by\n  rw [prod_univ_castSucc, prod_univ_six]\n  rfl\n\n"}
{"name":"Fin.sum_univ_eight","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nf : Fin 8 → β\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (f 0) (f 1)) (f 2)) (f 3)) (f 4)) (f 5)) (f 6)) (f 7))","decl":"@[to_additive]\ntheorem prod_univ_eight [CommMonoid β] (f : Fin 8 → β) :\n    ∏ i, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6 * f 7 := by\n  rw [prod_univ_castSucc, prod_univ_seven]\n  rfl\n\n"}
{"name":"Fin.prod_univ_eight","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nf : Fin 8 → β\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul (f 0) (f 1)) (f 2)) (f 3)) (f 4)) (f 5)) (f 6)) (f 7))","decl":"@[to_additive]\ntheorem prod_univ_eight [CommMonoid β] (f : Fin 8 → β) :\n    ∏ i, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6 * f 7 := by\n  rw [prod_univ_castSucc, prod_univ_seven]\n  rfl\n\n"}
{"name":"Fin.sum_pow_mul_eq_add_pow","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"n : Nat\nR : Type u_3\ninst✝ : CommSemiring R\na b : R\n⊢ Eq (Finset.univ.sum fun s => HMul.hMul (HPow.hPow a s.card) (HPow.hPow b (HSub.hSub n s.card))) (HPow.hPow (HAdd.hAdd a b) n)","decl":"theorem sum_pow_mul_eq_add_pow {n : ℕ} {R : Type*} [CommSemiring R] (a b : R) :\n    (∑ s : Finset (Fin n), a ^ s.card * b ^ (n - s.card)) = (a + b) ^ n := by\n  simpa using Fintype.sum_pow_mul_eq_add_pow (Fin n) a b\n\n"}
{"name":"Fin.prod_const","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\nn : Nat\nx : α\n⊢ Eq (Finset.univ.prod fun _i => x) (HPow.hPow x n)","decl":"theorem prod_const [CommMonoid α] (n : ℕ) (x : α) : ∏ _i : Fin n, x = x ^ n := by simp\n\n"}
{"name":"Fin.sum_const","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\nn : Nat\nx : α\n⊢ Eq (Finset.univ.sum fun _i => x) (HSMul.hSMul n x)","decl":"theorem sum_const [AddCommMonoid α] (n : ℕ) (x : α) : ∑ _i : Fin n, x = n • x := by simp\n\n"}
{"name":"Fin.prod_Ioi_zero","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"M : Type u_3\ninst✝ : CommMonoid M\nn : Nat\nv : Fin n.succ → M\n⊢ Eq ((Finset.Ioi 0).prod fun i => v i) (Finset.univ.prod fun j => v j.succ)","decl":"@[to_additive]\ntheorem prod_Ioi_zero {M : Type*} [CommMonoid M] {n : ℕ} {v : Fin n.succ → M} :\n    ∏ i ∈ Ioi 0, v i = ∏ j : Fin n, v j.succ := by\n  rw [Ioi_zero_eq_map, Finset.prod_map, val_succEmb]\n\n"}
{"name":"Fin.sum_Ioi_zero","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\nn : Nat\nv : Fin n.succ → M\n⊢ Eq ((Finset.Ioi 0).sum fun i => v i) (Finset.univ.sum fun j => v j.succ)","decl":"@[to_additive]\ntheorem prod_Ioi_zero {M : Type*} [CommMonoid M] {n : ℕ} {v : Fin n.succ → M} :\n    ∏ i ∈ Ioi 0, v i = ∏ j : Fin n, v j.succ := by\n  rw [Ioi_zero_eq_map, Finset.prod_map, val_succEmb]\n\n"}
{"name":"Fin.prod_Ioi_succ","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"M : Type u_3\ninst✝ : CommMonoid M\nn : Nat\ni : Fin n\nv : Fin n.succ → M\n⊢ Eq ((Finset.Ioi i.succ).prod fun j => v j) ((Finset.Ioi i).prod fun j => v j.succ)","decl":"@[to_additive]\ntheorem prod_Ioi_succ {M : Type*} [CommMonoid M] {n : ℕ} (i : Fin n) (v : Fin n.succ → M) :\n    ∏ j ∈ Ioi i.succ, v j = ∏ j ∈ Ioi i, v j.succ := by\n  rw [Ioi_succ, Finset.prod_map, val_succEmb]\n\n"}
{"name":"Fin.sum_Ioi_succ","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\nn : Nat\ni : Fin n\nv : Fin n.succ → M\n⊢ Eq ((Finset.Ioi i.succ).sum fun j => v j) ((Finset.Ioi i).sum fun j => v j.succ)","decl":"@[to_additive]\ntheorem prod_Ioi_succ {M : Type*} [CommMonoid M] {n : ℕ} (i : Fin n) (v : Fin n.succ → M) :\n    ∏ j ∈ Ioi i.succ, v j = ∏ j ∈ Ioi i, v j.succ := by\n  rw [Ioi_succ, Finset.prod_map, val_succEmb]\n\n"}
{"name":"Fin.sum_congr'","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\na b : Nat\nf : Fin b → M\nh : Eq a b\n⊢ Eq (Finset.univ.sum fun i => f (Fin.cast h i)) (Finset.univ.sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_congr' {M : Type*} [CommMonoid M] {a b : ℕ} (f : Fin b → M) (h : a = b) :\n    (∏ i : Fin a, f (i.cast h)) = ∏ i : Fin b, f i := by\n  subst h\n  congr\n\n"}
{"name":"Fin.prod_congr'","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"M : Type u_3\ninst✝ : CommMonoid M\na b : Nat\nf : Fin b → M\nh : Eq a b\n⊢ Eq (Finset.univ.prod fun i => f (Fin.cast h i)) (Finset.univ.prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_congr' {M : Type*} [CommMonoid M] {a b : ℕ} (f : Fin b → M) (h : a = b) :\n    (∏ i : Fin a, f (i.cast h)) = ∏ i : Fin b, f i := by\n  subst h\n  congr\n\n"}
{"name":"Fin.sum_univ_add","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\na b : Nat\nf : Fin (HAdd.hAdd a b) → M\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (Finset.univ.sum fun i => f (Fin.castAdd b i)) (Finset.univ.sum fun i => f (Fin.natAdd a i)))","decl":"@[to_additive]\ntheorem prod_univ_add {M : Type*} [CommMonoid M] {a b : ℕ} (f : Fin (a + b) → M) :\n    (∏ i : Fin (a + b), f i) = (∏ i : Fin a, f (castAdd b i)) * ∏ i : Fin b, f (natAdd a i) := by\n  rw [Fintype.prod_equiv finSumFinEquiv.symm f fun i => f (finSumFinEquiv.toFun i)]\n  · apply Fintype.prod_sum_type\n  · intro x\n    simp only [Equiv.toFun_as_coe, Equiv.apply_symm_apply]\n\n"}
{"name":"Fin.prod_univ_add","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"M : Type u_3\ninst✝ : CommMonoid M\na b : Nat\nf : Fin (HAdd.hAdd a b) → M\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul (Finset.univ.prod fun i => f (Fin.castAdd b i)) (Finset.univ.prod fun i => f (Fin.natAdd a i)))","decl":"@[to_additive]\ntheorem prod_univ_add {M : Type*} [CommMonoid M] {a b : ℕ} (f : Fin (a + b) → M) :\n    (∏ i : Fin (a + b), f i) = (∏ i : Fin a, f (castAdd b i)) * ∏ i : Fin b, f (natAdd a i) := by\n  rw [Fintype.prod_equiv finSumFinEquiv.symm f fun i => f (finSumFinEquiv.toFun i)]\n  · apply Fintype.prod_sum_type\n  · intro x\n    simp only [Equiv.toFun_as_coe, Equiv.apply_symm_apply]\n\n"}
{"name":"Fin.prod_trunc","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"M : Type u_3\ninst✝ : CommMonoid M\na b : Nat\nf : Fin (HAdd.hAdd a b) → M\nhf : ∀ (j : Fin b), Eq (f (Fin.natAdd a j)) 1\n⊢ Eq (Finset.univ.prod fun i => f i) (Finset.univ.prod fun i => f (Fin.castLE ⋯ i))","decl":"@[to_additive]\ntheorem prod_trunc {M : Type*} [CommMonoid M] {a b : ℕ} (f : Fin (a + b) → M)\n    (hf : ∀ j : Fin b, f (natAdd a j) = 1) :\n    (∏ i : Fin (a + b), f i) = ∏ i : Fin a, f (castLE (Nat.le.intro rfl) i) := by\n  rw [prod_univ_add, Fintype.prod_eq_one _ hf, mul_one]\n  rfl\n\n"}
{"name":"Fin.sum_trunc","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\na b : Nat\nf : Fin (HAdd.hAdd a b) → M\nhf : ∀ (j : Fin b), Eq (f (Fin.natAdd a j)) 0\n⊢ Eq (Finset.univ.sum fun i => f i) (Finset.univ.sum fun i => f (Fin.castLE ⋯ i))","decl":"@[to_additive]\ntheorem prod_trunc {M : Type*} [CommMonoid M] {a b : ℕ} (f : Fin (a + b) → M)\n    (hf : ∀ j : Fin b, f (natAdd a j) = 1) :\n    (∏ i : Fin (a + b), f i) = ∏ i : Fin a, f (castLE (Nat.le.intro rfl) i) := by\n  rw [prod_univ_add, Fintype.prod_eq_one _ hf, mul_one]\n  rfl\n\n"}
{"name":"Fin.partialSum_zero","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\nn : Nat\nf : Fin n → α\n⊢ Eq (Fin.partialSum f 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem partialProd_zero (f : Fin n → α) : partialProd f 0 = 1 := by simp [partialProd]\n\n"}
{"name":"Fin.partialProd_zero","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : Monoid α\nn : Nat\nf : Fin n → α\n⊢ Eq (Fin.partialProd f 0) 1","decl":"@[to_additive (attr := simp)]\ntheorem partialProd_zero (f : Fin n → α) : partialProd f 0 = 1 := by simp [partialProd]\n\n"}
{"name":"Fin.partialSum_succ","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\nn : Nat\nf : Fin n → α\nj : Fin n\n⊢ Eq (Fin.partialSum f j.succ) (HAdd.hAdd (Fin.partialSum f j.castSucc) (f j))","decl":"@[to_additive]\ntheorem partialProd_succ (f : Fin n → α) (j : Fin n) :\n    partialProd f j.succ = partialProd f (Fin.castSucc j) * f j := by\n  simp [partialProd, List.take_succ, List.ofFnNthVal, dif_pos j.is_lt]\n\n"}
{"name":"Fin.partialProd_succ","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : Monoid α\nn : Nat\nf : Fin n → α\nj : Fin n\n⊢ Eq (Fin.partialProd f j.succ) (HMul.hMul (Fin.partialProd f j.castSucc) (f j))","decl":"@[to_additive]\ntheorem partialProd_succ (f : Fin n → α) (j : Fin n) :\n    partialProd f j.succ = partialProd f (Fin.castSucc j) * f j := by\n  simp [partialProd, List.take_succ, List.ofFnNthVal, dif_pos j.is_lt]\n\n"}
{"name":"Fin.partialProd_succ'","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : Monoid α\nn : Nat\nf : Fin (HAdd.hAdd n 1) → α\nj : Fin (HAdd.hAdd n 1)\n⊢ Eq (Fin.partialProd f j.succ) (HMul.hMul (f 0) (Fin.partialProd (Fin.tail f) j))","decl":"@[to_additive]\ntheorem partialProd_succ' (f : Fin (n + 1) → α) (j : Fin (n + 1)) :\n    partialProd f j.succ = f 0 * partialProd (Fin.tail f) j := by\n  simp [partialProd]\n  rfl\n\n"}
{"name":"Fin.partialSum_succ'","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\nn : Nat\nf : Fin (HAdd.hAdd n 1) → α\nj : Fin (HAdd.hAdd n 1)\n⊢ Eq (Fin.partialSum f j.succ) (HAdd.hAdd (f 0) (Fin.partialSum (Fin.tail f) j))","decl":"@[to_additive]\ntheorem partialProd_succ' (f : Fin (n + 1) → α) (j : Fin (n + 1)) :\n    partialProd f j.succ = f 0 * partialProd (Fin.tail f) j := by\n  simp [partialProd]\n  rfl\n\n"}
{"name":"Fin.partialSum_left_neg","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"n : Nat\nG : Type u_3\ninst✝ : AddGroup G\nf : Fin (HAdd.hAdd n 1) → G\n⊢ Eq (HVAdd.hVAdd (f 0) (Fin.partialSum fun i => HAdd.hAdd (Neg.neg (f ↑↑i)) (f i.succ))) f","decl":"@[to_additive]\ntheorem partialProd_left_inv {G : Type*} [Group G] (f : Fin (n + 1) → G) :\n    (f 0 • partialProd fun i : Fin n => (f i)⁻¹ * f i.succ) = f :=\n  funext fun x => Fin.inductionOn x (by simp) fun x hx => by\n    simp only [coe_eq_castSucc, Pi.smul_apply, smul_eq_mul] at hx ⊢\n    rw [partialProd_succ, ← mul_assoc, hx, mul_inv_cancel_left]\n\n"}
{"name":"Fin.partialProd_left_inv","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"n : Nat\nG : Type u_3\ninst✝ : Group G\nf : Fin (HAdd.hAdd n 1) → G\n⊢ Eq (HSMul.hSMul (f 0) (Fin.partialProd fun i => HMul.hMul (Inv.inv (f ↑↑i)) (f i.succ))) f","decl":"@[to_additive]\ntheorem partialProd_left_inv {G : Type*} [Group G] (f : Fin (n + 1) → G) :\n    (f 0 • partialProd fun i : Fin n => (f i)⁻¹ * f i.succ) = f :=\n  funext fun x => Fin.inductionOn x (by simp) fun x hx => by\n    simp only [coe_eq_castSucc, Pi.smul_apply, smul_eq_mul] at hx ⊢\n    rw [partialProd_succ, ← mul_assoc, hx, mul_inv_cancel_left]\n\n"}
{"name":"Fin.partialSum_right_neg","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"n : Nat\nG : Type u_3\ninst✝ : AddGroup G\nf : Fin n → G\ni : Fin n\n⊢ Eq (HAdd.hAdd (Neg.neg (Fin.partialSum f i.castSucc)) (Fin.partialSum f i.succ)) (f i)","decl":"@[to_additive]\ntheorem partialProd_right_inv {G : Type*} [Group G] (f : Fin n → G) (i : Fin n) :\n    (partialProd f (Fin.castSucc i))⁻¹ * partialProd f i.succ = f i := by\n  rw [partialProd_succ, inv_mul_cancel_left]\n\n"}
{"name":"Fin.partialProd_right_inv","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"n : Nat\nG : Type u_3\ninst✝ : Group G\nf : Fin n → G\ni : Fin n\n⊢ Eq (HMul.hMul (Inv.inv (Fin.partialProd f i.castSucc)) (Fin.partialProd f i.succ)) (f i)","decl":"@[to_additive]\ntheorem partialProd_right_inv {G : Type*} [Group G] (f : Fin n → G) (i : Fin n) :\n    (partialProd f (Fin.castSucc i))⁻¹ * partialProd f i.succ = f i := by\n  rw [partialProd_succ, inv_mul_cancel_left]\n\n"}
{"name":"Fin.inv_partialProd_mul_eq_contractNth","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"n : Nat\nG : Type u_3\ninst✝ : Group G\ng : Fin (HAdd.hAdd n 1) → G\nj : Fin (HAdd.hAdd n 1)\nk : Fin n\n⊢ Eq (HMul.hMul (Inv.inv (Fin.partialProd g (j.succ.succAbove k.castSucc))) (Fin.partialProd g (j.succAbove k).succ)) (j.contractNth (fun x1 x2 => HMul.hMul x1 x2) g k)","decl":"/-- Let `(g₀, g₁, ..., gₙ)` be a tuple of elements in `Gⁿ⁺¹`.\nThen if `k < j`, this says `(g₀g₁...gₖ₋₁)⁻¹ * g₀g₁...gₖ = gₖ`.\nIf `k = j`, it says `(g₀g₁...gₖ₋₁)⁻¹ * g₀g₁...gₖ₊₁ = gₖgₖ₊₁`.\nIf `k > j`, it says `(g₀g₁...gₖ)⁻¹ * g₀g₁...gₖ₊₁ = gₖ₊₁.`\nUseful for defining group cohomology. -/\n@[to_additive\n      \"Let `(g₀, g₁, ..., gₙ)` be a tuple of elements in `Gⁿ⁺¹`.\n      Then if `k < j`, this says `-(g₀ + g₁ + ... + gₖ₋₁) + (g₀ + g₁ + ... + gₖ) = gₖ`.\n      If `k = j`, it says `-(g₀ + g₁ + ... + gₖ₋₁) + (g₀ + g₁ + ... + gₖ₊₁) = gₖ + gₖ₊₁`.\n      If `k > j`, it says `-(g₀ + g₁ + ... + gₖ) + (g₀ + g₁ + ... + gₖ₊₁) = gₖ₊₁.`\n      Useful for defining group cohomology.\"]\ntheorem inv_partialProd_mul_eq_contractNth {G : Type*} [Group G] (g : Fin (n + 1) → G)\n    (j : Fin (n + 1)) (k : Fin n) :\n    (partialProd g (j.succ.succAbove (Fin.castSucc k)))⁻¹ * partialProd g (j.succAbove k).succ =\n      j.contractNth (· * ·) g k := by\n  rcases lt_trichotomy (k : ℕ) j with (h | h | h)\n  · rwa [succAbove_of_castSucc_lt, succAbove_of_castSucc_lt, partialProd_right_inv,\n    contractNth_apply_of_lt]\n    · assumption\n    · rw [castSucc_lt_iff_succ_le, succ_le_succ_iff, le_iff_val_le_val]\n      exact le_of_lt h\n  · rwa [succAbove_of_castSucc_lt, succAbove_of_le_castSucc, partialProd_succ,\n    castSucc_fin_succ, ← mul_assoc,\n      partialProd_right_inv, contractNth_apply_of_eq]\n    · simp [le_iff_val_le_val, ← h]\n    · rw [castSucc_lt_iff_succ_le, succ_le_succ_iff, le_iff_val_le_val]\n      exact le_of_eq h\n  · rwa [succAbove_of_le_castSucc, succAbove_of_le_castSucc, partialProd_succ, partialProd_succ,\n      castSucc_fin_succ, partialProd_succ, inv_mul_cancel_left, contractNth_apply_of_gt]\n    · exact le_iff_val_le_val.2 (le_of_lt h)\n    · rw [le_iff_val_le_val, val_succ]\n      exact Nat.succ_le_of_lt h\n\n"}
{"name":"Fin.neg_partialSum_add_eq_contractNth","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"n : Nat\nG : Type u_3\ninst✝ : AddGroup G\ng : Fin (HAdd.hAdd n 1) → G\nj : Fin (HAdd.hAdd n 1)\nk : Fin n\n⊢ Eq (HAdd.hAdd (Neg.neg (Fin.partialSum g (j.succ.succAbove k.castSucc))) (Fin.partialSum g (j.succAbove k).succ)) (j.contractNth (fun x1 x2 => HAdd.hAdd x1 x2) g k)","decl":"/-- Let `(g₀, g₁, ..., gₙ)` be a tuple of elements in `Gⁿ⁺¹`.\nThen if `k < j`, this says `(g₀g₁...gₖ₋₁)⁻¹ * g₀g₁...gₖ = gₖ`.\nIf `k = j`, it says `(g₀g₁...gₖ₋₁)⁻¹ * g₀g₁...gₖ₊₁ = gₖgₖ₊₁`.\nIf `k > j`, it says `(g₀g₁...gₖ)⁻¹ * g₀g₁...gₖ₊₁ = gₖ₊₁.`\nUseful for defining group cohomology. -/\n@[to_additive\n      \"Let `(g₀, g₁, ..., gₙ)` be a tuple of elements in `Gⁿ⁺¹`.\n      Then if `k < j`, this says `-(g₀ + g₁ + ... + gₖ₋₁) + (g₀ + g₁ + ... + gₖ) = gₖ`.\n      If `k = j`, it says `-(g₀ + g₁ + ... + gₖ₋₁) + (g₀ + g₁ + ... + gₖ₊₁) = gₖ + gₖ₊₁`.\n      If `k > j`, it says `-(g₀ + g₁ + ... + gₖ) + (g₀ + g₁ + ... + gₖ₊₁) = gₖ₊₁.`\n      Useful for defining group cohomology.\"]\ntheorem inv_partialProd_mul_eq_contractNth {G : Type*} [Group G] (g : Fin (n + 1) → G)\n    (j : Fin (n + 1)) (k : Fin n) :\n    (partialProd g (j.succ.succAbove (Fin.castSucc k)))⁻¹ * partialProd g (j.succAbove k).succ =\n      j.contractNth (· * ·) g k := by\n  rcases lt_trichotomy (k : ℕ) j with (h | h | h)\n  · rwa [succAbove_of_castSucc_lt, succAbove_of_castSucc_lt, partialProd_right_inv,\n    contractNth_apply_of_lt]\n    · assumption\n    · rw [castSucc_lt_iff_succ_le, succ_le_succ_iff, le_iff_val_le_val]\n      exact le_of_lt h\n  · rwa [succAbove_of_castSucc_lt, succAbove_of_le_castSucc, partialProd_succ,\n    castSucc_fin_succ, ← mul_assoc,\n      partialProd_right_inv, contractNth_apply_of_eq]\n    · simp [le_iff_val_le_val, ← h]\n    · rw [castSucc_lt_iff_succ_le, succ_le_succ_iff, le_iff_val_le_val]\n      exact le_of_eq h\n  · rwa [succAbove_of_le_castSucc, succAbove_of_le_castSucc, partialProd_succ, partialProd_succ,\n      castSucc_fin_succ, partialProd_succ, inv_mul_cancel_left, contractNth_apply_of_gt]\n    · exact le_iff_val_le_val.2 (le_of_lt h)\n    · rw [le_iff_val_le_val, val_succ]\n      exact Nat.succ_le_of_lt h\n\n"}
{"name":"finFunctionFinEquiv_apply_val","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"m n : Nat\nf : Fin n → Fin m\n⊢ Eq (↑(finFunctionFinEquiv f)) (Finset.univ.sum fun i => HMul.hMul (↑(f i)) (HPow.hPow m ↑i))","decl":"/-- Equivalence between `Fin n → Fin m` and `Fin (m ^ n)`. -/\n@[simps!]\ndef finFunctionFinEquiv {m n : ℕ} : (Fin n → Fin m) ≃ Fin (m ^ n) :=\n  Equiv.ofRightInverseOfCardLE (le_of_eq <| by simp_rw [Fintype.card_fun, Fintype.card_fin])\n    (fun f => ⟨∑ i, f i * m ^ (i : ℕ), by\n      induction n with\n      | zero => simp\n      | succ n ih =>\n        cases m\n        · exact isEmptyElim (f <| Fin.last _)\n        simp_rw [Fin.sum_univ_castSucc, Fin.coe_castSucc, Fin.val_last]\n        refine (Nat.add_lt_add_of_lt_of_le (ih _) <| Nat.mul_le_mul_right _\n          (Fin.is_le _)).trans_eq ?_\n        rw [← one_add_mul (_ : ℕ), add_comm, pow_succ']⟩)\n    (fun a b => ⟨a / m ^ (b : ℕ) % m, by\n      rcases n with - | n\n      · exact b.elim0\n      rcases m with - | m\n      · rw [zero_pow n.succ_ne_zero] at a\n        exact a.elim0\n      · exact Nat.mod_lt _ m.succ_pos⟩)\n    fun a => by\n      dsimp\n      induction n with\n      | zero => subsingleton [(finCongr <| pow_zero _).subsingleton]\n      | succ n ih =>\n        simp_rw [Fin.forall_iff, Fin.ext_iff] at ih\n        ext\n        simp_rw [Fin.sum_univ_succ, Fin.val_zero, Fin.val_succ, pow_zero, Nat.div_one,\n          mul_one, pow_succ', ← Nat.div_div_eq_div_mul, mul_left_comm _ m, ← mul_sum]\n        rw [ih _ (Nat.div_lt_of_lt_mul ?_), Nat.mod_add_div]\n        -- Porting note: replaces `a.is_lt` in the wildcard above.\n        -- Caused by a refactor of the `npow` instance for `Fin`.\n        exact a.is_lt.trans_eq (pow_succ' _ _)\n\n"}
{"name":"finFunctionFinEquiv_symm_apply_val","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"m n : Nat\na : Fin (HPow.hPow m n)\nb : Fin n\n⊢ Eq (↑(finFunctionFinEquiv.symm a b)) (HMod.hMod (HDiv.hDiv (↑a) (HPow.hPow m ↑b)) m)","decl":"/-- Equivalence between `Fin n → Fin m` and `Fin (m ^ n)`. -/\n@[simps!]\ndef finFunctionFinEquiv {m n : ℕ} : (Fin n → Fin m) ≃ Fin (m ^ n) :=\n  Equiv.ofRightInverseOfCardLE (le_of_eq <| by simp_rw [Fintype.card_fun, Fintype.card_fin])\n    (fun f => ⟨∑ i, f i * m ^ (i : ℕ), by\n      induction n with\n      | zero => simp\n      | succ n ih =>\n        cases m\n        · exact isEmptyElim (f <| Fin.last _)\n        simp_rw [Fin.sum_univ_castSucc, Fin.coe_castSucc, Fin.val_last]\n        refine (Nat.add_lt_add_of_lt_of_le (ih _) <| Nat.mul_le_mul_right _\n          (Fin.is_le _)).trans_eq ?_\n        rw [← one_add_mul (_ : ℕ), add_comm, pow_succ']⟩)\n    (fun a b => ⟨a / m ^ (b : ℕ) % m, by\n      rcases n with - | n\n      · exact b.elim0\n      rcases m with - | m\n      · rw [zero_pow n.succ_ne_zero] at a\n        exact a.elim0\n      · exact Nat.mod_lt _ m.succ_pos⟩)\n    fun a => by\n      dsimp\n      induction n with\n      | zero => subsingleton [(finCongr <| pow_zero _).subsingleton]\n      | succ n ih =>\n        simp_rw [Fin.forall_iff, Fin.ext_iff] at ih\n        ext\n        simp_rw [Fin.sum_univ_succ, Fin.val_zero, Fin.val_succ, pow_zero, Nat.div_one,\n          mul_one, pow_succ', ← Nat.div_div_eq_div_mul, mul_left_comm _ m, ← mul_sum]\n        rw [ih _ (Nat.div_lt_of_lt_mul ?_), Nat.mod_add_div]\n        -- Porting note: replaces `a.is_lt` in the wildcard above.\n        -- Caused by a refactor of the `npow` instance for `Fin`.\n        exact a.is_lt.trans_eq (pow_succ' _ _)\n\n"}
{"name":"finFunctionFinEquiv_apply","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"m n : Nat\nf : Fin n → Fin m\n⊢ Eq (↑(finFunctionFinEquiv f)) (Finset.univ.sum fun i => HMul.hMul (↑(f i)) (HPow.hPow m ↑i))","decl":"theorem finFunctionFinEquiv_apply {m n : ℕ} (f : Fin n → Fin m) :\n    (finFunctionFinEquiv f : ℕ) = ∑ i : Fin n, ↑(f i) * m ^ (i : ℕ) :=\n  rfl\n\n"}
{"name":"finFunctionFinEquiv_single","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"m n : Nat\ninst✝ : NeZero m\ni : Fin n\nj : Fin m\n⊢ Eq (↑(finFunctionFinEquiv (Pi.single i j))) (HMul.hMul (↑j) (HPow.hPow m ↑i))","decl":"theorem finFunctionFinEquiv_single {m n : ℕ} [NeZero m] (i : Fin n) (j : Fin m) :\n    (finFunctionFinEquiv (Pi.single i j) : ℕ) = j * m ^ (i : ℕ) := by\n  rw [finFunctionFinEquiv_apply, Fintype.sum_eq_single i, Pi.single_eq_same]\n  rintro x hx\n  rw [Pi.single_eq_of_ne hx, Fin.val_zero', zero_mul]\n\n"}
{"name":"finPiFinEquiv_apply","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"m : Nat\nn : Fin m → Nat\nf : (i : Fin m) → Fin (n i)\n⊢ Eq (↑(finPiFinEquiv f)) (Finset.univ.sum fun i => HMul.hMul (↑(f i)) (Finset.univ.prod fun j => n (Fin.castLE ⋯ j)))","decl":"theorem finPiFinEquiv_apply {m : ℕ} {n : Fin m → ℕ} (f : ∀ i : Fin m, Fin (n i)) :\n    (finPiFinEquiv f : ℕ) = ∑ i, f i * ∏ j, n (Fin.castLE i.is_lt.le j) := rfl\n\n"}
{"name":"finPiFinEquiv_single","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"m : Nat\nn : Fin m → Nat\ninst✝ : ∀ (i : Fin m), NeZero (n i)\ni : Fin m\nj : Fin (n i)\n⊢ Eq (↑(finPiFinEquiv (Pi.single i j))) (HMul.hMul (↑j) (Finset.univ.prod fun j => n (Fin.castLE ⋯ j)))","decl":"theorem finPiFinEquiv_single {m : ℕ} {n : Fin m → ℕ} [∀ i, NeZero (n i)] (i : Fin m)\n    (j : Fin (n i)) :\n    (finPiFinEquiv (Pi.single i j : ∀ i : Fin m, Fin (n i)) : ℕ) =\n      j * ∏ j, n (Fin.castLE i.is_lt.le j) := by\n  rw [finPiFinEquiv_apply, Fintype.sum_eq_single i, Pi.single_eq_same]\n  rintro x hx\n  rw [Pi.single_eq_of_ne hx, Fin.val_zero', zero_mul]\n\n"}
{"name":"finSigmaFinEquiv_apply","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"m : Nat\nn : Fin m → Nat\nk : Sigma fun i => Fin (n i)\n⊢ Eq (↑(finSigmaFinEquiv k)) (HAdd.hAdd (Finset.univ.sum fun i => n (Fin.castLE ⋯ i)) ↑k.snd)","decl":"@[simp]\ntheorem finSigmaFinEquiv_apply {m : ℕ} {n : Fin m → ℕ} (k : (i : Fin m) × Fin (n i)) :\n    (finSigmaFinEquiv k : ℕ) = ∑ i : Fin k.1, n (Fin.castLE k.1.2.le i) + k.2 := by\n  induction m\n  · exact k.fst.elim0\n  rename_i m ih\n  rcases k with ⟨⟨iv,hi⟩,j⟩\n  rw [finSigmaFinEquiv]\n  unfold finSumFinEquiv\n  simp only [Equiv.coe_fn_mk, Equiv.sigmaCongrLeft, Equiv.coe_fn_symm_mk, Equiv.instTrans_trans,\n    Equiv.trans_apply, finCongr_apply, Fin.coe_cast]\n  conv  =>\n    enter [1,1,3]\n    apply Equiv.sumCongr_apply\n  by_cases him : iv < m\n  · conv in Sigma.mk _ _ =>\n      equals ⟨Sum.inl ⟨iv, him⟩, j⟩ => simp [Fin.addCases, him]\n    simpa using ih _\n  · replace him := Nat.eq_of_lt_succ_of_not_lt hi him\n    subst him\n    conv in Sigma.mk _ _ =>\n      equals ⟨Sum.inr 0, j⟩ => simp [Fin.addCases, Fin.natAdd]\n    simp\n    rfl\n\n"}
{"name":"finSigmaFinEquiv_one","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"n : Fin 1 → Nat\nij : Sigma fun i => Fin (n i)\n⊢ Eq ↑(finSigmaFinEquiv ij) ↑ij.snd","decl":"/-- `finSigmaFinEquiv` on `Fin 1 × f` is just `f`-/\ntheorem finSigmaFinEquiv_one {n : Fin 1 → ℕ} (ij : (i : Fin 1) × Fin (n i)) :\n    (finSigmaFinEquiv ij : ℕ) = ij.2 := by\n  rw [finSigmaFinEquiv_apply, add_left_eq_self]\n  apply @Finset.sum_of_isEmpty _ _ _ _ (by simpa using Fin.isEmpty')\n\n"}
{"name":"List.prod_take_ofFn","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\nn : Nat\nf : Fin n → α\ni : Nat\n⊢ Eq (List.take i (List.ofFn f)).prod ((Finset.filter (fun j => LT.lt (↑j) i) Finset.univ).prod fun j => f j)","decl":"@[to_additive]\ntheorem prod_take_ofFn {n : ℕ} (f : Fin n → α) (i : ℕ) :\n    ((ofFn f).take i).prod = ∏ j ∈ Finset.univ.filter fun j : Fin n => j.val < i, f j := by\n  induction i with\n  | zero =>\n    simp\n  | succ i IH =>\n    by_cases h : i < n\n    · have : i < length (ofFn f) := by rwa [length_ofFn f]\n      rw [prod_take_succ _ _ this]\n      have A : ((Finset.univ : Finset (Fin n)).filter fun j => j.val < i + 1) =\n          ((Finset.univ : Finset (Fin n)).filter fun j => j.val < i) ∪ {(⟨i, h⟩ : Fin n)} := by\n        ext ⟨_, _⟩\n        simp [Nat.lt_succ_iff_lt_or_eq]\n      have B : _root_.Disjoint (Finset.filter (fun j : Fin n => j.val < i) Finset.univ)\n          (singleton (⟨i, h⟩ : Fin n)) := by simp\n      rw [A, Finset.prod_union B, IH]\n      simp\n    · have A : (ofFn f).take i = (ofFn f).take i.succ := by\n        rw [← length_ofFn f] at h\n        have : length (ofFn f) ≤ i := not_lt.mp h\n        rw [take_of_length_le this, take_of_length_le (le_trans this (Nat.le_succ _))]\n      have B : ∀ j : Fin n, ((j : ℕ) < i.succ) = ((j : ℕ) < i) := by\n        intro j\n        have : (j : ℕ) < i := lt_of_lt_of_le j.2 (not_lt.mp h)\n        simp [this, lt_trans this (Nat.lt_succ_self _)]\n      simp [← A, B, IH]\n\n"}
{"name":"List.sum_take_ofFn","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\nn : Nat\nf : Fin n → α\ni : Nat\n⊢ Eq (List.take i (List.ofFn f)).sum ((Finset.filter (fun j => LT.lt (↑j) i) Finset.univ).sum fun j => f j)","decl":"@[to_additive]\ntheorem prod_take_ofFn {n : ℕ} (f : Fin n → α) (i : ℕ) :\n    ((ofFn f).take i).prod = ∏ j ∈ Finset.univ.filter fun j : Fin n => j.val < i, f j := by\n  induction i with\n  | zero =>\n    simp\n  | succ i IH =>\n    by_cases h : i < n\n    · have : i < length (ofFn f) := by rwa [length_ofFn f]\n      rw [prod_take_succ _ _ this]\n      have A : ((Finset.univ : Finset (Fin n)).filter fun j => j.val < i + 1) =\n          ((Finset.univ : Finset (Fin n)).filter fun j => j.val < i) ∪ {(⟨i, h⟩ : Fin n)} := by\n        ext ⟨_, _⟩\n        simp [Nat.lt_succ_iff_lt_or_eq]\n      have B : _root_.Disjoint (Finset.filter (fun j : Fin n => j.val < i) Finset.univ)\n          (singleton (⟨i, h⟩ : Fin n)) := by simp\n      rw [A, Finset.prod_union B, IH]\n      simp\n    · have A : (ofFn f).take i = (ofFn f).take i.succ := by\n        rw [← length_ofFn f] at h\n        have : length (ofFn f) ≤ i := not_lt.mp h\n        rw [take_of_length_le this, take_of_length_le (le_trans this (Nat.le_succ _))]\n      have B : ∀ j : Fin n, ((j : ℕ) < i.succ) = ((j : ℕ) < i) := by\n        intro j\n        have : (j : ℕ) < i := lt_of_lt_of_le j.2 (not_lt.mp h)\n        simp [this, lt_trans this (Nat.lt_succ_self _)]\n      simp [← A, B, IH]\n\n"}
{"name":"List.sum_ofFn","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\nn : Nat\nf : Fin n → α\n⊢ Eq (List.ofFn f).sum (Finset.univ.sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_ofFn {n : ℕ} {f : Fin n → α} : (ofFn f).prod = ∏ i, f i :=\n  Fin.prod_ofFn f\n\n"}
{"name":"List.prod_ofFn","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\nn : Nat\nf : Fin n → α\n⊢ Eq (List.ofFn f).prod (Finset.univ.prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_ofFn {n : ℕ} {f : Fin n → α} : (ofFn f).prod = ∏ i, f i :=\n  Fin.prod_ofFn f\n\n"}
{"name":"List.alternatingSum_eq_finset_sum","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\nL : List G\n⊢ Eq L.alternatingSum (Finset.univ.sum fun i => HSMul.hSMul (HPow.hPow (-1) ↑i) (GetElem.getElem L i ⋯))","decl":"@[to_additive]\ntheorem alternatingProd_eq_finset_prod {G : Type*} [CommGroup G] :\n    ∀ (L : List G), alternatingProd L = ∏ i : Fin L.length, L[i] ^ (-1 : ℤ) ^ (i : ℕ)\n  | [] => by\n    rw [alternatingProd, Finset.prod_eq_one]\n    rintro ⟨i, ⟨⟩⟩\n  | g::[] => by\n    show g = ∏ i : Fin 1, [g][i] ^ (-1 : ℤ) ^ (i : ℕ)\n    rw [Fin.prod_univ_succ]; simp\n  | g::h::L =>\n    calc g * h⁻¹ * L.alternatingProd\n      = g * h⁻¹ * ∏ i : Fin L.length, L[i] ^ (-1 : ℤ) ^ (i : ℕ) :=\n        congr_arg _ (alternatingProd_eq_finset_prod _)\n    _ = ∏ i : Fin (L.length + 2), (g::h::L)[i] ^ (-1 : ℤ) ^ (i : ℕ) := by\n        { rw [Fin.prod_univ_succ, Fin.prod_univ_succ, mul_assoc]\n          simp [pow_add]}\n\n"}
{"name":"List.alternatingProd_eq_finset_prod","module":"Mathlib.Algebra.BigOperators.Fin","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\nL : List G\n⊢ Eq L.alternatingProd (Finset.univ.prod fun i => HPow.hPow (GetElem.getElem L i ⋯) (HPow.hPow (-1) ↑i))","decl":"@[to_additive]\ntheorem alternatingProd_eq_finset_prod {G : Type*} [CommGroup G] :\n    ∀ (L : List G), alternatingProd L = ∏ i : Fin L.length, L[i] ^ (-1 : ℤ) ^ (i : ℕ)\n  | [] => by\n    rw [alternatingProd, Finset.prod_eq_one]\n    rintro ⟨i, ⟨⟩⟩\n  | g::[] => by\n    show g = ∏ i : Fin 1, [g][i] ^ (-1 : ℤ) ^ (i : ℕ)\n    rw [Fin.prod_univ_succ]; simp\n  | g::h::L =>\n    calc g * h⁻¹ * L.alternatingProd\n      = g * h⁻¹ * ∏ i : Fin L.length, L[i] ^ (-1 : ℤ) ^ (i : ℕ) :=\n        congr_arg _ (alternatingProd_eq_finset_prod _)\n    _ = ∏ i : Fin (L.length + 2), (g::h::L)[i] ^ (-1 : ℤ) ^ (i : ℕ) := by\n        { rw [Fin.prod_univ_succ, Fin.prod_univ_succ, mul_assoc]\n          simp [pow_add]}\n\n"}
