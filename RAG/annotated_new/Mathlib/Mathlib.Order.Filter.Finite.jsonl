{"name":"Filter.biInter_mem","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nf : Filter Î±\nÎ² : Type v\ns : Î² â†’ Set Î±\nis : Set Î²\nhf : is.Finite\nâŠ¢ Iff (Membership.mem f (Set.iInter fun i => Set.iInter fun h => s i)) (âˆ€ (i : Î²), Membership.mem is i â†’ Membership.mem f (s i))","decl":"@[simp]\ntheorem biInter_mem {Î² : Type v} {s : Î² â†’ Set Î±} {is : Set Î²} (hf : is.Finite) :\n    (â‹‚ i âˆˆ is, s i) âˆˆ f â†” âˆ€ i âˆˆ is, s i âˆˆ f :=\n  Finite.induction_on _ hf (by simp) fun _ _ hs => by simp [hs]\n\n"}
{"name":"Filter.biInter_finset_mem","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nf : Filter Î±\nÎ² : Type v\ns : Î² â†’ Set Î±\nis : Finset Î²\nâŠ¢ Iff (Membership.mem f (Set.iInter fun i => Set.iInter fun h => s i)) (âˆ€ (i : Î²), Membership.mem is i â†’ Membership.mem f (s i))","decl":"@[simp]\ntheorem biInter_finset_mem {Î² : Type v} {s : Î² â†’ Set Î±} (is : Finset Î²) :\n    (â‹‚ i âˆˆ is, s i) âˆˆ f â†” âˆ€ i âˆˆ is, s i âˆˆ f :=\n  biInter_mem is.finite_toSet\n\n"}
{"name":"Finset.iInter_mem_sets","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nf : Filter Î±\nÎ² : Type v\ns : Î² â†’ Set Î±\nis : Finset Î²\nâŠ¢ Iff (Membership.mem f (Set.iInter fun i => Set.iInter fun h => s i)) (âˆ€ (i : Î²), Membership.mem is i â†’ Membership.mem f (s i))","decl":"alias _root_.Finset.iInter_mem_sets := biInter_finset_mem\n\n-- attribute [protected] Finset.iInter_mem_sets porting note: doesn't work\n\n"}
{"name":"Filter.sInter_mem","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nf : Filter Î±\ns : Set (Set Î±)\nhfin : s.Finite\nâŠ¢ Iff (Membership.mem f s.sInter) (âˆ€ (U : Set Î±), Membership.mem s U â†’ Membership.mem f U)","decl":"@[simp]\ntheorem sInter_mem {s : Set (Set Î±)} (hfin : s.Finite) : â‹‚â‚€ s âˆˆ f â†” âˆ€ U âˆˆ s, U âˆˆ f := by\n  rw [sInter_eq_biInter, biInter_mem hfin]\n\n"}
{"name":"Filter.iInter_mem","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nf : Filter Î±\nÎ² : Sort v\ns : Î² â†’ Set Î±\ninstâœ : Finite Î²\nâŠ¢ Iff (Membership.mem f (Set.iInter fun i => s i)) (âˆ€ (i : Î²), Membership.mem f (s i))","decl":"@[simp]\ntheorem iInter_mem {Î² : Sort v} {s : Î² â†’ Set Î±} [Finite Î²] : (â‹‚ i, s i) âˆˆ f â†” âˆ€ i, s i âˆˆ f :=\n  (sInter_mem (finite_range _)).trans forall_mem_range\n\n"}
{"name":"Filter.mem_generate_iff","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\ns : Set (Set Î±)\nU : Set Î±\nâŠ¢ Iff (Membership.mem (Filter.generate s) U) (Exists fun t => And (HasSubset.Subset t s) (And t.Finite (HasSubset.Subset t.sInter U)))","decl":"theorem mem_generate_iff {s : Set <| Set Î±} {U : Set Î±} :\n    U âˆˆ generate s â†” âˆƒ t âŠ† s, Set.Finite t âˆ§ â‹‚â‚€ t âŠ† U := by\n  constructor <;> intro h\n  Â· induction h with\n    | @basic V V_in =>\n      exact âŸ¨{V}, singleton_subset_iff.2 V_in, finite_singleton _, (sInter_singleton _).subsetâŸ©\n    | univ => exact âŸ¨âˆ…, empty_subset _, finite_empty, subset_univ _âŸ©\n    | superset _ hVW hV =>\n      rcases hV with âŸ¨t, hts, ht, htVâŸ©\n      exact âŸ¨t, hts, ht, htV.trans hVWâŸ©\n    | inter _ _ hV hW =>\n      rcases hV, hW with âŸ¨âŸ¨t, hts, ht, htVâŸ©, u, hus, hu, huWâŸ©\n      exact\n        âŸ¨t âˆª u, union_subset hts hus, ht.union hu,\n          (sInter_union _ _).subset.trans <| inter_subset_inter htV huWâŸ©\n  Â· rcases h with âŸ¨t, hts, tfin, hâŸ©\n    exact mem_of_superset ((sInter_mem tfin).2 fun V hV => GenerateSets.basic <| hts hV) h\n\n"}
{"name":"Filter.mem_iInf_of_iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type u_2\ns : Î¹ â†’ Filter Î±\nU : Set Î±\nI : Set Î¹\nI_fin : I.Finite\nV : â†‘I â†’ Set Î±\nhV : âˆ€ (i : â†‘I), Membership.mem (s â†‘i) (V i)\nhU : HasSubset.Subset (Set.iInter fun i => V i) U\nâŠ¢ Membership.mem (iInf fun i => s i) U","decl":"theorem mem_iInf_of_iInter {Î¹} {s : Î¹ â†’ Filter Î±} {U : Set Î±} {I : Set Î¹} (I_fin : I.Finite)\n    {V : I â†’ Set Î±} (hV : âˆ€ (i : I), V i âˆˆ s i) (hU : â‹‚ i, V i âŠ† U) : U âˆˆ â¨… i, s i := by\n  haveI := I_fin.fintype\n  refine mem_of_superset (iInter_mem.2 fun i => ?_) hU\n  exact mem_iInf_of_mem (i : Î¹) (hV _)\n\n"}
{"name":"Filter.mem_iInf","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type u_2\ns : Î¹ â†’ Filter Î±\nU : Set Î±\nâŠ¢ Iff (Membership.mem (iInf fun i => s i) U) (Exists fun I => And I.Finite (Exists fun V => And (âˆ€ (i : â†‘I), Membership.mem (s â†‘i) (V i)) (Eq U (Set.iInter fun i => V i))))","decl":"theorem mem_iInf {Î¹} {s : Î¹ â†’ Filter Î±} {U : Set Î±} :\n    (U âˆˆ â¨… i, s i) â†”\n      âˆƒ I : Set Î¹, I.Finite âˆ§ âˆƒ V : I â†’ Set Î±, (âˆ€ (i : I), V i âˆˆ s i) âˆ§ U = â‹‚ i, V i := by\n  constructor\n  Â· rw [iInf_eq_generate, mem_generate_iff]\n    rintro âŸ¨t, tsub, tfin, tinterâŸ©\n    rcases eq_finite_iUnion_of_finite_subset_iUnion tfin tsub with âŸ¨I, Ifin, Ïƒ, Ïƒfin, Ïƒsub, rflâŸ©\n    rw [sInter_iUnion] at tinter\n    set V := fun i => U âˆª â‹‚â‚€ Ïƒ i with hV\n    have V_in : âˆ€ (i : I), V i âˆˆ s i := by\n      rintro i\n      have : â‹‚â‚€ Ïƒ i âˆˆ s i := by\n        rw [sInter_mem (Ïƒfin _)]\n        apply Ïƒsub\n      exact mem_of_superset this subset_union_right\n    refine âŸ¨I, Ifin, V, V_in, ?_âŸ©\n    rwa [hV, â† union_iInter, union_eq_self_of_subset_right]\n  Â· rintro âŸ¨I, Ifin, V, V_in, rflâŸ©\n    exact mem_iInf_of_iInter Ifin V_in Subset.rfl\n\n"}
{"name":"Filter.mem_iInf'","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type u_2\ns : Î¹ â†’ Filter Î±\nU : Set Î±\nâŠ¢ Iff (Membership.mem (iInf fun i => s i) U) (Exists fun I => And I.Finite (Exists fun V => And (âˆ€ (i : Î¹), Membership.mem (s i) (V i)) (And (âˆ€ (i : Î¹), Not (Membership.mem I i) â†’ Eq (V i) Set.univ) (And (Eq U (Set.iInter fun i => Set.iInter fun h => V i)) (Eq U (Set.iInter fun i => V i))))))","decl":"theorem mem_iInf' {Î¹} {s : Î¹ â†’ Filter Î±} {U : Set Î±} :\n    (U âˆˆ â¨… i, s i) â†”\n      âˆƒ I : Set Î¹, I.Finite âˆ§ âˆƒ V : Î¹ â†’ Set Î±, (âˆ€ i, V i âˆˆ s i) âˆ§\n        (âˆ€ i âˆ‰ I, V i = univ) âˆ§ (U = â‹‚ i âˆˆ I, V i) âˆ§ U = â‹‚ i, V i := by\n  classical\n  simp only [mem_iInf, SetCoe.forall', biInter_eq_iInter]\n  refine âŸ¨?_, fun âŸ¨I, If, V, hVs, _, hVU, _âŸ© => âŸ¨I, If, fun i => V i, fun i => hVs i, hVUâŸ©âŸ©\n  rintro âŸ¨I, If, V, hV, rflâŸ©\n  refine âŸ¨I, If, fun i => if hi : i âˆˆ I then V âŸ¨i, hiâŸ© else univ, fun i => ?_, fun i hi => ?_, ?_âŸ©\n  Â· dsimp only\n    split_ifs\n    exacts [hV âŸ¨i,_âŸ©, univ_mem]\n  Â· exact dif_neg hi\n  Â· simp only [iInter_dite, biInter_eq_iInter, dif_pos (Subtype.coe_prop _), Subtype.coe_eta,\n      iInter_univ, inter_univ, eq_self_iff_true, true_and]\n\n"}
{"name":"Filter.exists_iInter_of_mem_iInf","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î¹ : Type u_2\nÎ± : Type u_3\nf : Î¹ â†’ Filter Î±\ns : Set Î±\nhs : Membership.mem (iInf fun i => f i) s\nâŠ¢ Exists fun t => And (âˆ€ (i : Î¹), Membership.mem (f i) (t i)) (Eq s (Set.iInter fun i => t i))","decl":"theorem exists_iInter_of_mem_iInf {Î¹ : Type*} {Î± : Type*} {f : Î¹ â†’ Filter Î±} {s}\n    (hs : s âˆˆ â¨… i, f i) : âˆƒ t : Î¹ â†’ Set Î±, (âˆ€ i, t i âˆˆ f i) âˆ§ s = â‹‚ i, t i :=\n  let âŸ¨_, _, V, hVs, _, _, hVU'âŸ© := mem_iInf'.1 hs; âŸ¨V, hVs, hVU'âŸ©\n\n"}
{"name":"Filter.mem_iInf_of_finite","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î¹ : Type u_2\ninstâœ : Finite Î¹\nÎ± : Type u_3\nf : Î¹ â†’ Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (iInf fun i => f i) s) (Exists fun t => And (âˆ€ (i : Î¹), Membership.mem (f i) (t i)) (Eq s (Set.iInter fun i => t i)))","decl":"theorem mem_iInf_of_finite {Î¹ : Type*} [Finite Î¹] {Î± : Type*} {f : Î¹ â†’ Filter Î±} (s) :\n    (s âˆˆ â¨… i, f i) â†” âˆƒ t : Î¹ â†’ Set Î±, (âˆ€ i, t i âˆˆ f i) âˆ§ s = â‹‚ i, t i := by\n  refine âŸ¨exists_iInter_of_mem_iInf, ?_âŸ©\n  rintro âŸ¨t, ht, rflâŸ©\n  exact iInter_mem.2 fun i => mem_iInf_of_mem i (ht i)\n\n"}
{"name":"Pairwise.exists_mem_filter_of_disjoint","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type u_2\ninstâœ : Finite Î¹\nl : Î¹ â†’ Filter Î±\nhd : Pairwise (Function.onFun Disjoint l)\nâŠ¢ Exists fun s => And (âˆ€ (i : Î¹), Membership.mem (l i) (s i)) (Pairwise (Function.onFun Disjoint s))","decl":"theorem _root_.Pairwise.exists_mem_filter_of_disjoint {Î¹ : Type*} [Finite Î¹] {l : Î¹ â†’ Filter Î±}\n    (hd : Pairwise (Disjoint on l)) :\n    âˆƒ s : Î¹ â†’ Set Î±, (âˆ€ i, s i âˆˆ l i) âˆ§ Pairwise (Disjoint on s) := by\n  have : Pairwise fun i j => âˆƒ (s : {s // s âˆˆ l i}) (t : {t // t âˆˆ l j}), Disjoint s.1 t.1 := by\n    simpa only [Pairwise, Function.onFun, Filter.disjoint_iff, exists_prop, Subtype.exists] using hd\n  choose! s t hst using this\n  refine âŸ¨fun i => â‹‚ j, @s i j âˆ© @t j i, fun i => ?_, fun i j hij => ?_âŸ©\n  exacts [iInter_mem.2 fun j => inter_mem (@s i j).2 (@t j i).2,\n    (hst hij).mono ((iInter_subset _ j).trans inter_subset_left)\n      ((iInter_subset _ i).trans inter_subset_right)]\n\n"}
{"name":"Set.PairwiseDisjoint.exists_mem_filter","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type u_2\nl : Î¹ â†’ Filter Î±\nt : Set Î¹\nhd : t.PairwiseDisjoint l\nht : t.Finite\nâŠ¢ Exists fun s => And (âˆ€ (i : Î¹), Membership.mem (l i) (s i)) (t.PairwiseDisjoint s)","decl":"theorem _root_.Set.PairwiseDisjoint.exists_mem_filter {Î¹ : Type*} {l : Î¹ â†’ Filter Î±} {t : Set Î¹}\n    (hd : t.PairwiseDisjoint l) (ht : t.Finite) :\n    âˆƒ s : Î¹ â†’ Set Î±, (âˆ€ i, s i âˆˆ l i) âˆ§ t.PairwiseDisjoint s := by\n  haveI := ht.to_subtype\n  rcases (hd.subtype _ _).exists_mem_filter_of_disjoint with âŸ¨s, hsl, hsdâŸ©\n  lift s to (i : t) â†’ {s // s âˆˆ l i} using hsl\n  rcases @Subtype.exists_pi_extension Î¹ (fun i => { s // s âˆˆ l i }) _ _ s with âŸ¨s, rflâŸ©\n  exact âŸ¨fun i => s i, fun i => (s i).2, hsd.set_of_subtype _ _âŸ©\n\n\n"}
{"name":"Filter.iInf_sets_eq_finite","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type u_2\nf : Î¹ â†’ Filter Î±\nâŠ¢ Eq (iInf fun i => f i).sets (Set.iUnion fun t => (iInf fun i => iInf fun h => f i).sets)","decl":"theorem iInf_sets_eq_finite {Î¹ : Type*} (f : Î¹ â†’ Filter Î±) :\n    (â¨… i, f i).sets = â‹ƒ t : Finset Î¹, (â¨… i âˆˆ t, f i).sets := by\n  rw [iInf_eq_iInf_finset, iInf_sets_eq]\n  exact directed_of_isDirected_le fun _ _ => biInf_mono\n\n"}
{"name":"Filter.iInf_sets_eq_finite'","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\nâŠ¢ Eq (iInf fun i => f i).sets (Set.iUnion fun t => (iInf fun i => iInf fun h => f i.down).sets)","decl":"theorem iInf_sets_eq_finite' (f : Î¹ â†’ Filter Î±) :\n    (â¨… i, f i).sets = â‹ƒ t : Finset (PLift Î¹), (â¨… i âˆˆ t, f (PLift.down i)).sets := by\n  rw [â† iInf_sets_eq_finite, â† Equiv.plift.surjective.iInf_comp, Equiv.plift_apply]\n\n"}
{"name":"Filter.mem_iInf_finite","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type u_2\nf : Î¹ â†’ Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (iInf f) s) (Exists fun t => Membership.mem (iInf fun i => iInf fun h => f i) s)","decl":"theorem mem_iInf_finite {Î¹ : Type*} {f : Î¹ â†’ Filter Î±} (s) :\n    s âˆˆ iInf f â†” âˆƒ t : Finset Î¹, s âˆˆ â¨… i âˆˆ t, f i :=\n  (Set.ext_iff.1 (iInf_sets_eq_finite f) s).trans mem_iUnion\n\n"}
{"name":"Filter.mem_iInf_finite'","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\ns : Set Î±\nâŠ¢ Iff (Membership.mem (iInf f) s) (Exists fun t => Membership.mem (iInf fun i => iInf fun h => f i.down) s)","decl":"theorem mem_iInf_finite' {f : Î¹ â†’ Filter Î±} (s) :\n    s âˆˆ iInf f â†” âˆƒ t : Finset (PLift Î¹), s âˆˆ â¨… i âˆˆ t, f (PLift.down i) :=\n  (Set.ext_iff.1 (iInf_sets_eq_finite' f) s).trans mem_iUnion\n\n"}
{"name":"Filter.mem_iInf_finset","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ² : Type v\ns : Finset Î±\nf : Î± â†’ Filter Î²\nt : Set Î²\nâŠ¢ Iff (Membership.mem (iInf fun a => iInf fun h => f a) t) (Exists fun p => And (âˆ€ (a : Î±), Membership.mem s a â†’ Membership.mem (f a) (p a)) (Eq t (Set.iInter fun a => Set.iInter fun h => p a)))","decl":"theorem mem_iInf_finset {s : Finset Î±} {f : Î± â†’ Filter Î²} {t : Set Î²} :\n    (t âˆˆ â¨… a âˆˆ s, f a) â†” âˆƒ p : Î± â†’ Set Î², (âˆ€ a âˆˆ s, p a âˆˆ f a) âˆ§ t = â‹‚ a âˆˆ s, p a := by\n  classical\n  simp only [â† Finset.set_biInter_coe, biInter_eq_iInter, iInf_subtype']\n  refine âŸ¨fun h => ?_, ?_âŸ©\n  Â· rcases (mem_iInf_of_finite _).1 h with âŸ¨p, hp, rflâŸ©\n    refine âŸ¨fun a => if h : a âˆˆ s then p âŸ¨a, hâŸ© else univ,\n            fun a ha => by simpa [ha] using hp âŸ¨a, haâŸ©, ?_âŸ©\n    refine iInter_congr_of_surjective id surjective_id ?_\n    rintro âŸ¨a, haâŸ©\n    simp [ha]\n  Â· rintro âŸ¨p, hpf, rflâŸ©\n    exact iInter_mem.2 fun a => mem_iInf_of_mem a (hpf a a.2)\n\n\n"}
{"name":"Filter.iInf_sets_induct","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nf : Î¹ â†’ Filter Î±\ns : Set Î±\nhs : Membership.mem (iInf f) s\np : Set Î± â†’ Prop\nuni : p Set.univ\nins : âˆ€ {i : Î¹} {sâ‚ sâ‚‚ : Set Î±}, Membership.mem (f i) sâ‚ â†’ p sâ‚‚ â†’ p (Inter.inter sâ‚ sâ‚‚)\nâŠ¢ p s","decl":"@[elab_as_elim]\ntheorem iInf_sets_induct {f : Î¹ â†’ Filter Î±} {s : Set Î±} (hs : s âˆˆ iInf f) {p : Set Î± â†’ Prop}\n    (uni : p univ) (ins : âˆ€ {i sâ‚ sâ‚‚}, sâ‚ âˆˆ f i â†’ p sâ‚‚ â†’ p (sâ‚ âˆ© sâ‚‚)) : p s := by\n  classical\n  rw [mem_iInf_finite'] at hs\n  simp only [â† Finset.inf_eq_iInf] at hs\n  rcases hs with âŸ¨is, hisâŸ©\n  induction is using Finset.induction_on generalizing s with\n  | empty => rwa [mem_top.1 his]\n  | insert _ ih =>\n    rw [Finset.inf_insert, mem_inf_iff] at his\n    rcases his with âŸ¨sâ‚, hsâ‚, sâ‚‚, hsâ‚‚, rflâŸ©\n    exact ins hsâ‚ (ih hsâ‚‚)\n\n"}
{"name":"Filter.iInf_principal_finset","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type w\ns : Finset Î¹\nf : Î¹ â†’ Set Î±\nâŠ¢ Eq (iInf fun i => iInf fun h => Filter.principal (f i)) (Filter.principal (Set.iInter fun i => Set.iInter fun h => f i))","decl":"@[simp]\ntheorem iInf_principal_finset {Î¹ : Type w} (s : Finset Î¹) (f : Î¹ â†’ Set Î±) :\n    â¨… i âˆˆ s, ğ“Ÿ (f i) = ğ“Ÿ (â‹‚ i âˆˆ s, f i) := by\n  classical\n  induction' s using Finset.induction_on with i s _ hs\n  Â· simp\n  Â· rw [Finset.iInf_insert, Finset.set_biInter_insert, hs, inf_principal]\n\n"}
{"name":"Filter.iInf_principal","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Sort w\ninstâœ : Finite Î¹\nf : Î¹ â†’ Set Î±\nâŠ¢ Eq (iInf fun i => Filter.principal (f i)) (Filter.principal (Set.iInter fun i => f i))","decl":"theorem iInf_principal {Î¹ : Sort w} [Finite Î¹] (f : Î¹ â†’ Set Î±) : â¨… i, ğ“Ÿ (f i) = ğ“Ÿ (â‹‚ i, f i) := by\n  cases nonempty_fintype (PLift Î¹)\n  rw [â† iInf_plift_down, â† iInter_plift_down]\n  simpa using iInf_principal_finset Finset.univ (f <| PLift.down Â·)\n\n"}
{"name":"Filter.iInf_principal'","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type w\ninstâœ : Finite Î¹\nf : Î¹ â†’ Set Î±\nâŠ¢ Eq (iInf fun i => Filter.principal (f i)) (Filter.principal (Set.iInter fun i => f i))","decl":"/-- A special case of `iInf_principal` that is safe to mark `simp`. -/\n@[simp]\ntheorem iInf_principal' {Î¹ : Type w} [Finite Î¹] (f : Î¹ â†’ Set Î±) : â¨… i, ğ“Ÿ (f i) = ğ“Ÿ (â‹‚ i, f i) :=\n  iInf_principal _\n\n"}
{"name":"Filter.iInf_principal_finite","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type w\ns : Set Î¹\nhs : s.Finite\nf : Î¹ â†’ Set Î±\nâŠ¢ Eq (iInf fun i => iInf fun h => Filter.principal (f i)) (Filter.principal (Set.iInter fun i => Set.iInter fun h => f i))","decl":"theorem iInf_principal_finite {Î¹ : Type w} {s : Set Î¹} (hs : s.Finite) (f : Î¹ â†’ Set Î±) :\n    â¨… i âˆˆ s, ğ“Ÿ (f i) = ğ“Ÿ (â‹‚ i âˆˆ s, f i) := by\n  lift s to Finset Î¹ using hs\n  exact mod_cast iInf_principal_finset s f\n\n"}
{"name":"Filter.eventually_all","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Sort u_2\ninstâœ : Finite Î¹\nl : Filter Î±\np : Î¹ â†’ Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => âˆ€ (i : Î¹), p i x) l) (âˆ€ (i : Î¹), Filter.Eventually (fun x => p i x) l)","decl":"@[simp]\ntheorem eventually_all {Î¹ : Sort*} [Finite Î¹] {l} {p : Î¹ â†’ Î± â†’ Prop} :\n    (âˆ€á¶  x in l, âˆ€ i, p i x) â†” âˆ€ i, âˆ€á¶  x in l, p i x := by\n  simpa only [Filter.Eventually, setOf_forall] using iInter_mem\n\n"}
{"name":"Filter.eventually_all_finite","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type u_2\nI : Set Î¹\nhI : I.Finite\nl : Filter Î±\np : Î¹ â†’ Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => âˆ€ (i : Î¹), Membership.mem I i â†’ p i x) l) (âˆ€ (i : Î¹), Membership.mem I i â†’ Filter.Eventually (fun x => p i x) l)","decl":"@[simp]\ntheorem eventually_all_finite {Î¹} {I : Set Î¹} (hI : I.Finite) {l} {p : Î¹ â†’ Î± â†’ Prop} :\n    (âˆ€á¶  x in l, âˆ€ i âˆˆ I, p i x) â†” âˆ€ i âˆˆ I, âˆ€á¶  x in l, p i x := by\n  simpa only [Filter.Eventually, setOf_forall] using biInter_mem hI\n\n"}
{"name":"Set.Finite.eventually_all","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type u_2\nI : Set Î¹\nhI : I.Finite\nl : Filter Î±\np : Î¹ â†’ Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => âˆ€ (i : Î¹), Membership.mem I i â†’ p i x) l) (âˆ€ (i : Î¹), Membership.mem I i â†’ Filter.Eventually (fun x => p i x) l)","decl":"alias _root_.Set.Finite.eventually_all := eventually_all_finite\n\n-- attribute [protected] Set.Finite.eventually_all\n\n"}
{"name":"Filter.eventually_all_finset","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type u_2\nI : Finset Î¹\nl : Filter Î±\np : Î¹ â†’ Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => âˆ€ (i : Î¹), Membership.mem I i â†’ p i x) l) (âˆ€ (i : Î¹), Membership.mem I i â†’ Filter.Eventually (fun x => p i x) l)","decl":"@[simp] theorem eventually_all_finset {Î¹} (I : Finset Î¹) {l} {p : Î¹ â†’ Î± â†’ Prop} :\n    (âˆ€á¶  x in l, âˆ€ i âˆˆ I, p i x) â†” âˆ€ i âˆˆ I, âˆ€á¶  x in l, p i x :=\n  I.finite_toSet.eventually_all\n\n"}
{"name":"Finset.eventually_all","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Type u_2\nI : Finset Î¹\nl : Filter Î±\np : Î¹ â†’ Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => âˆ€ (i : Î¹), Membership.mem I i â†’ p i x) l) (âˆ€ (i : Î¹), Membership.mem I i â†’ Filter.Eventually (fun x => p i x) l)","decl":"alias _root_.Finset.eventually_all := eventually_all_finset\n\n-- attribute [protected] Finset.eventually_all\n\n"}
{"name":"Filter.EventuallyLE.iUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nl : Filter Î±\ninstâœ : Finite Î¹\ns t : Î¹ â†’ Set Î±\nh : âˆ€ (i : Î¹), l.EventuallyLE (s i) (t i)\nâŠ¢ l.EventuallyLE (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"protected lemma EventuallyLE.iUnion [Finite Î¹] {s t : Î¹ â†’ Set Î±}\n    (h : âˆ€ i, s i â‰¤á¶ [l] t i) : (â‹ƒ i, s i) â‰¤á¶ [l] â‹ƒ i, t i :=\n  (eventually_all.2 h).mono fun _x hx hx' â†¦\n    let âŸ¨i, hiâŸ© := mem_iUnion.1 hx'; mem_iUnion.2 âŸ¨i, hx i hiâŸ©\n\n"}
{"name":"Filter.EventuallyEq.iUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nl : Filter Î±\ninstâœ : Finite Î¹\ns t : Î¹ â†’ Set Î±\nh : âˆ€ (i : Î¹), l.EventuallyEq (s i) (t i)\nâŠ¢ l.EventuallyEq (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"protected lemma EventuallyEq.iUnion [Finite Î¹] {s t : Î¹ â†’ Set Î±}\n    (h : âˆ€ i, s i =á¶ [l] t i) : (â‹ƒ i, s i) =á¶ [l] â‹ƒ i, t i :=\n  (EventuallyLE.iUnion fun i â†¦ (h i).le).antisymm <| .iUnion fun i â†¦ (h i).symm.le\n\n"}
{"name":"Filter.EventuallyLE.iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nl : Filter Î±\ninstâœ : Finite Î¹\ns t : Î¹ â†’ Set Î±\nh : âˆ€ (i : Î¹), l.EventuallyLE (s i) (t i)\nâŠ¢ l.EventuallyLE (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"protected lemma EventuallyLE.iInter [Finite Î¹] {s t : Î¹ â†’ Set Î±}\n    (h : âˆ€ i, s i â‰¤á¶ [l] t i) : (â‹‚ i, s i) â‰¤á¶ [l] â‹‚ i, t i :=\n  (eventually_all.2 h).mono fun _x hx hx' â†¦ mem_iInter.2 fun i â†¦ hx i (mem_iInter.1 hx' i)\n\n"}
{"name":"Filter.EventuallyEq.iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nÎ¹ : Sort x\nl : Filter Î±\ninstâœ : Finite Î¹\ns t : Î¹ â†’ Set Î±\nh : âˆ€ (i : Î¹), l.EventuallyEq (s i) (t i)\nâŠ¢ l.EventuallyEq (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"protected lemma EventuallyEq.iInter [Finite Î¹] {s t : Î¹ â†’ Set Î±}\n    (h : âˆ€ i, s i =á¶ [l] t i) : (â‹‚ i, s i) =á¶ [l] â‹‚ i, t i :=\n  (EventuallyLE.iInter fun i â†¦ (h i).le).antisymm <| .iInter fun i â†¦ (h i).symm.le\n\n"}
{"name":"Set.Finite.eventuallyLE_iUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nl : Filter Î±\nÎ¹ : Type u_2\ns : Set Î¹\nhs : s.Finite\nf g : Î¹ â†’ Set Î±\nhle : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyLE (f i) (g i)\nâŠ¢ l.EventuallyLE (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => g i)","decl":"lemma _root_.Set.Finite.eventuallyLE_iUnion {Î¹ : Type*} {s : Set Î¹} (hs : s.Finite)\n    {f g : Î¹ â†’ Set Î±} (hle : âˆ€ i âˆˆ s, f i â‰¤á¶ [l] g i) : (â‹ƒ i âˆˆ s, f i) â‰¤á¶ [l] (â‹ƒ i âˆˆ s, g i) := by\n  have := hs.to_subtype\n  rw [biUnion_eq_iUnion, biUnion_eq_iUnion]\n  exact .iUnion fun i â†¦ hle i.1 i.2\n\n"}
{"name":"Filter.EventuallyLE.biUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nl : Filter Î±\nÎ¹ : Type u_2\ns : Set Î¹\nhs : s.Finite\nf g : Î¹ â†’ Set Î±\nhle : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyLE (f i) (g i)\nâŠ¢ l.EventuallyLE (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => g i)","decl":"alias EventuallyLE.biUnion := Set.Finite.eventuallyLE_iUnion\n\n"}
{"name":"Set.Finite.eventuallyEq_iUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nl : Filter Î±\nÎ¹ : Type u_2\ns : Set Î¹\nhs : s.Finite\nf g : Î¹ â†’ Set Î±\nheq : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyEq (f i) (g i)\nâŠ¢ l.EventuallyEq (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => g i)","decl":"lemma _root_.Set.Finite.eventuallyEq_iUnion {Î¹ : Type*} {s : Set Î¹} (hs : s.Finite)\n    {f g : Î¹ â†’ Set Î±} (heq : âˆ€ i âˆˆ s, f i =á¶ [l] g i) : (â‹ƒ i âˆˆ s, f i) =á¶ [l] (â‹ƒ i âˆˆ s, g i) :=\n  (EventuallyLE.biUnion hs fun i hi â†¦ (heq i hi).le).antisymm <|\n    .biUnion hs fun i hi â†¦ (heq i hi).symm.le\n\n"}
{"name":"Filter.EventuallyEq.biUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nl : Filter Î±\nÎ¹ : Type u_2\ns : Set Î¹\nhs : s.Finite\nf g : Î¹ â†’ Set Î±\nheq : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyEq (f i) (g i)\nâŠ¢ l.EventuallyEq (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => g i)","decl":"alias EventuallyEq.biUnion := Set.Finite.eventuallyEq_iUnion\n\n"}
{"name":"Set.Finite.eventuallyLE_iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nl : Filter Î±\nÎ¹ : Type u_2\ns : Set Î¹\nhs : s.Finite\nf g : Î¹ â†’ Set Î±\nhle : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyLE (f i) (g i)\nâŠ¢ l.EventuallyLE (Set.iInter fun i => Set.iInter fun h => f i) (Set.iInter fun i => Set.iInter fun h => g i)","decl":"lemma _root_.Set.Finite.eventuallyLE_iInter {Î¹ : Type*} {s : Set Î¹} (hs : s.Finite)\n    {f g : Î¹ â†’ Set Î±} (hle : âˆ€ i âˆˆ s, f i â‰¤á¶ [l] g i) : (â‹‚ i âˆˆ s, f i) â‰¤á¶ [l] (â‹‚ i âˆˆ s, g i) := by\n  have := hs.to_subtype\n  rw [biInter_eq_iInter, biInter_eq_iInter]\n  exact .iInter fun i â†¦ hle i.1 i.2\n\n"}
{"name":"Filter.EventuallyLE.biInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nl : Filter Î±\nÎ¹ : Type u_2\ns : Set Î¹\nhs : s.Finite\nf g : Î¹ â†’ Set Î±\nhle : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyLE (f i) (g i)\nâŠ¢ l.EventuallyLE (Set.iInter fun i => Set.iInter fun h => f i) (Set.iInter fun i => Set.iInter fun h => g i)","decl":"alias EventuallyLE.biInter := Set.Finite.eventuallyLE_iInter\n\n"}
{"name":"Set.Finite.eventuallyEq_iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nl : Filter Î±\nÎ¹ : Type u_2\ns : Set Î¹\nhs : s.Finite\nf g : Î¹ â†’ Set Î±\nheq : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyEq (f i) (g i)\nâŠ¢ l.EventuallyEq (Set.iInter fun i => Set.iInter fun h => f i) (Set.iInter fun i => Set.iInter fun h => g i)","decl":"lemma _root_.Set.Finite.eventuallyEq_iInter {Î¹ : Type*} {s : Set Î¹} (hs : s.Finite)\n    {f g : Î¹ â†’ Set Î±} (heq : âˆ€ i âˆˆ s, f i =á¶ [l] g i) : (â‹‚ i âˆˆ s, f i) =á¶ [l] (â‹‚ i âˆˆ s, g i) :=\n  (EventuallyLE.biInter hs fun i hi â†¦ (heq i hi).le).antisymm <|\n    .biInter hs fun i hi â†¦ (heq i hi).symm.le\n\n"}
{"name":"Filter.EventuallyEq.biInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nl : Filter Î±\nÎ¹ : Type u_2\ns : Set Î¹\nhs : s.Finite\nf g : Î¹ â†’ Set Î±\nheq : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyEq (f i) (g i)\nâŠ¢ l.EventuallyEq (Set.iInter fun i => Set.iInter fun h => f i) (Set.iInter fun i => Set.iInter fun h => g i)","decl":"alias EventuallyEq.biInter := Set.Finite.eventuallyEq_iInter\n\n"}
{"name":"Finset.eventuallyLE_iUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nl : Filter Î±\nÎ¹ : Type u_2\ns : Finset Î¹\nf g : Î¹ â†’ Set Î±\nhle : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyLE (f i) (g i)\nâŠ¢ l.EventuallyLE (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => g i)","decl":"lemma _root_.Finset.eventuallyLE_iUnion {Î¹ : Type*} (s : Finset Î¹) {f g : Î¹ â†’ Set Î±}\n    (hle : âˆ€ i âˆˆ s, f i â‰¤á¶ [l] g i) : (â‹ƒ i âˆˆ s, f i) â‰¤á¶ [l] (â‹ƒ i âˆˆ s, g i) :=\n  .biUnion s.finite_toSet hle\n\n"}
{"name":"Finset.eventuallyEq_iUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nl : Filter Î±\nÎ¹ : Type u_2\ns : Finset Î¹\nf g : Î¹ â†’ Set Î±\nheq : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyEq (f i) (g i)\nâŠ¢ l.EventuallyEq (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => g i)","decl":"lemma _root_.Finset.eventuallyEq_iUnion {Î¹ : Type*} (s : Finset Î¹) {f g : Î¹ â†’ Set Î±}\n    (heq : âˆ€ i âˆˆ s, f i =á¶ [l] g i) : (â‹ƒ i âˆˆ s, f i) =á¶ [l] (â‹ƒ i âˆˆ s, g i) :=\n  .biUnion s.finite_toSet heq\n\n"}
{"name":"Finset.eventuallyLE_iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nl : Filter Î±\nÎ¹ : Type u_2\ns : Finset Î¹\nf g : Î¹ â†’ Set Î±\nhle : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyLE (f i) (g i)\nâŠ¢ l.EventuallyLE (Set.iInter fun i => Set.iInter fun h => f i) (Set.iInter fun i => Set.iInter fun h => g i)","decl":"lemma _root_.Finset.eventuallyLE_iInter {Î¹ : Type*} (s : Finset Î¹) {f g : Î¹ â†’ Set Î±}\n    (hle : âˆ€ i âˆˆ s, f i â‰¤á¶ [l] g i) : (â‹‚ i âˆˆ s, f i) â‰¤á¶ [l] (â‹‚ i âˆˆ s, g i) :=\n  .biInter s.finite_toSet hle\n\n"}
{"name":"Finset.eventuallyEq_iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"Î± : Type u\nl : Filter Î±\nÎ¹ : Type u_2\ns : Finset Î¹\nf g : Î¹ â†’ Set Î±\nheq : âˆ€ (i : Î¹), Membership.mem s i â†’ l.EventuallyEq (f i) (g i)\nâŠ¢ l.EventuallyEq (Set.iInter fun i => Set.iInter fun h => f i) (Set.iInter fun i => Set.iInter fun h => g i)","decl":"lemma _root_.Finset.eventuallyEq_iInter {Î¹ : Type*} (s : Finset Î¹) {f g : Î¹ â†’ Set Î±}\n    (heq : âˆ€ i âˆˆ s, f i =á¶ [l] g i) : (â‹‚ i âˆˆ s, f i) =á¶ [l] (â‹‚ i âˆˆ s, g i) :=\n  .biInter s.finite_toSet heq\n\n"}
