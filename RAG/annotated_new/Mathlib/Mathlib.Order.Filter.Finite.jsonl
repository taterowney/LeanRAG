{"name":"Filter.biInter_mem","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nf : Filter α\nβ : Type v\ns : β → Set α\nis : Set β\nhf : is.Finite\n⊢ Iff (Membership.mem f (Set.iInter fun i => Set.iInter fun h => s i)) (∀ (i : β), Membership.mem is i → Membership.mem f (s i))","decl":"@[simp]\ntheorem biInter_mem {β : Type v} {s : β → Set α} {is : Set β} (hf : is.Finite) :\n    (⋂ i ∈ is, s i) ∈ f ↔ ∀ i ∈ is, s i ∈ f :=\n  Finite.induction_on _ hf (by simp) fun _ _ hs => by simp [hs]\n\n"}
{"name":"Filter.biInter_finset_mem","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nf : Filter α\nβ : Type v\ns : β → Set α\nis : Finset β\n⊢ Iff (Membership.mem f (Set.iInter fun i => Set.iInter fun h => s i)) (∀ (i : β), Membership.mem is i → Membership.mem f (s i))","decl":"@[simp]\ntheorem biInter_finset_mem {β : Type v} {s : β → Set α} (is : Finset β) :\n    (⋂ i ∈ is, s i) ∈ f ↔ ∀ i ∈ is, s i ∈ f :=\n  biInter_mem is.finite_toSet\n\n"}
{"name":"Finset.iInter_mem_sets","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nf : Filter α\nβ : Type v\ns : β → Set α\nis : Finset β\n⊢ Iff (Membership.mem f (Set.iInter fun i => Set.iInter fun h => s i)) (∀ (i : β), Membership.mem is i → Membership.mem f (s i))","decl":"alias _root_.Finset.iInter_mem_sets := biInter_finset_mem\n\n-- attribute [protected] Finset.iInter_mem_sets porting note: doesn't work\n\n"}
{"name":"Filter.sInter_mem","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nf : Filter α\ns : Set (Set α)\nhfin : s.Finite\n⊢ Iff (Membership.mem f s.sInter) (∀ (U : Set α), Membership.mem s U → Membership.mem f U)","decl":"@[simp]\ntheorem sInter_mem {s : Set (Set α)} (hfin : s.Finite) : ⋂₀ s ∈ f ↔ ∀ U ∈ s, U ∈ f := by\n  rw [sInter_eq_biInter, biInter_mem hfin]\n\n"}
{"name":"Filter.iInter_mem","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nf : Filter α\nβ : Sort v\ns : β → Set α\ninst✝ : Finite β\n⊢ Iff (Membership.mem f (Set.iInter fun i => s i)) (∀ (i : β), Membership.mem f (s i))","decl":"@[simp]\ntheorem iInter_mem {β : Sort v} {s : β → Set α} [Finite β] : (⋂ i, s i) ∈ f ↔ ∀ i, s i ∈ f :=\n  (sInter_mem (finite_range _)).trans forall_mem_range\n\n"}
{"name":"Filter.mem_generate_iff","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\ns : Set (Set α)\nU : Set α\n⊢ Iff (Membership.mem (Filter.generate s) U) (Exists fun t => And (HasSubset.Subset t s) (And t.Finite (HasSubset.Subset t.sInter U)))","decl":"theorem mem_generate_iff {s : Set <| Set α} {U : Set α} :\n    U ∈ generate s ↔ ∃ t ⊆ s, Set.Finite t ∧ ⋂₀ t ⊆ U := by\n  constructor <;> intro h\n  · induction h with\n    | @basic V V_in =>\n      exact ⟨{V}, singleton_subset_iff.2 V_in, finite_singleton _, (sInter_singleton _).subset⟩\n    | univ => exact ⟨∅, empty_subset _, finite_empty, subset_univ _⟩\n    | superset _ hVW hV =>\n      rcases hV with ⟨t, hts, ht, htV⟩\n      exact ⟨t, hts, ht, htV.trans hVW⟩\n    | inter _ _ hV hW =>\n      rcases hV, hW with ⟨⟨t, hts, ht, htV⟩, u, hus, hu, huW⟩\n      exact\n        ⟨t ∪ u, union_subset hts hus, ht.union hu,\n          (sInter_union _ _).subset.trans <| inter_subset_inter htV huW⟩\n  · rcases h with ⟨t, hts, tfin, h⟩\n    exact mem_of_superset ((sInter_mem tfin).2 fun V hV => GenerateSets.basic <| hts hV) h\n\n"}
{"name":"Filter.mem_iInf_of_iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type u_2\ns : ι → Filter α\nU : Set α\nI : Set ι\nI_fin : I.Finite\nV : ↑I → Set α\nhV : ∀ (i : ↑I), Membership.mem (s ↑i) (V i)\nhU : HasSubset.Subset (Set.iInter fun i => V i) U\n⊢ Membership.mem (iInf fun i => s i) U","decl":"theorem mem_iInf_of_iInter {ι} {s : ι → Filter α} {U : Set α} {I : Set ι} (I_fin : I.Finite)\n    {V : I → Set α} (hV : ∀ (i : I), V i ∈ s i) (hU : ⋂ i, V i ⊆ U) : U ∈ ⨅ i, s i := by\n  haveI := I_fin.fintype\n  refine mem_of_superset (iInter_mem.2 fun i => ?_) hU\n  exact mem_iInf_of_mem (i : ι) (hV _)\n\n"}
{"name":"Filter.mem_iInf","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type u_2\ns : ι → Filter α\nU : Set α\n⊢ Iff (Membership.mem (iInf fun i => s i) U) (Exists fun I => And I.Finite (Exists fun V => And (∀ (i : ↑I), Membership.mem (s ↑i) (V i)) (Eq U (Set.iInter fun i => V i))))","decl":"theorem mem_iInf {ι} {s : ι → Filter α} {U : Set α} :\n    (U ∈ ⨅ i, s i) ↔\n      ∃ I : Set ι, I.Finite ∧ ∃ V : I → Set α, (∀ (i : I), V i ∈ s i) ∧ U = ⋂ i, V i := by\n  constructor\n  · rw [iInf_eq_generate, mem_generate_iff]\n    rintro ⟨t, tsub, tfin, tinter⟩\n    rcases eq_finite_iUnion_of_finite_subset_iUnion tfin tsub with ⟨I, Ifin, σ, σfin, σsub, rfl⟩\n    rw [sInter_iUnion] at tinter\n    set V := fun i => U ∪ ⋂₀ σ i with hV\n    have V_in : ∀ (i : I), V i ∈ s i := by\n      rintro i\n      have : ⋂₀ σ i ∈ s i := by\n        rw [sInter_mem (σfin _)]\n        apply σsub\n      exact mem_of_superset this subset_union_right\n    refine ⟨I, Ifin, V, V_in, ?_⟩\n    rwa [hV, ← union_iInter, union_eq_self_of_subset_right]\n  · rintro ⟨I, Ifin, V, V_in, rfl⟩\n    exact mem_iInf_of_iInter Ifin V_in Subset.rfl\n\n"}
{"name":"Filter.mem_iInf'","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type u_2\ns : ι → Filter α\nU : Set α\n⊢ Iff (Membership.mem (iInf fun i => s i) U) (Exists fun I => And I.Finite (Exists fun V => And (∀ (i : ι), Membership.mem (s i) (V i)) (And (∀ (i : ι), Not (Membership.mem I i) → Eq (V i) Set.univ) (And (Eq U (Set.iInter fun i => Set.iInter fun h => V i)) (Eq U (Set.iInter fun i => V i))))))","decl":"theorem mem_iInf' {ι} {s : ι → Filter α} {U : Set α} :\n    (U ∈ ⨅ i, s i) ↔\n      ∃ I : Set ι, I.Finite ∧ ∃ V : ι → Set α, (∀ i, V i ∈ s i) ∧\n        (∀ i ∉ I, V i = univ) ∧ (U = ⋂ i ∈ I, V i) ∧ U = ⋂ i, V i := by\n  classical\n  simp only [mem_iInf, SetCoe.forall', biInter_eq_iInter]\n  refine ⟨?_, fun ⟨I, If, V, hVs, _, hVU, _⟩ => ⟨I, If, fun i => V i, fun i => hVs i, hVU⟩⟩\n  rintro ⟨I, If, V, hV, rfl⟩\n  refine ⟨I, If, fun i => if hi : i ∈ I then V ⟨i, hi⟩ else univ, fun i => ?_, fun i hi => ?_, ?_⟩\n  · dsimp only\n    split_ifs\n    exacts [hV ⟨i,_⟩, univ_mem]\n  · exact dif_neg hi\n  · simp only [iInter_dite, biInter_eq_iInter, dif_pos (Subtype.coe_prop _), Subtype.coe_eta,\n      iInter_univ, inter_univ, eq_self_iff_true, true_and]\n\n"}
{"name":"Filter.exists_iInter_of_mem_iInf","module":"Mathlib.Order.Filter.Finite","initialProofState":"ι : Type u_2\nα : Type u_3\nf : ι → Filter α\ns : Set α\nhs : Membership.mem (iInf fun i => f i) s\n⊢ Exists fun t => And (∀ (i : ι), Membership.mem (f i) (t i)) (Eq s (Set.iInter fun i => t i))","decl":"theorem exists_iInter_of_mem_iInf {ι : Type*} {α : Type*} {f : ι → Filter α} {s}\n    (hs : s ∈ ⨅ i, f i) : ∃ t : ι → Set α, (∀ i, t i ∈ f i) ∧ s = ⋂ i, t i :=\n  let ⟨_, _, V, hVs, _, _, hVU'⟩ := mem_iInf'.1 hs; ⟨V, hVs, hVU'⟩\n\n"}
{"name":"Filter.mem_iInf_of_finite","module":"Mathlib.Order.Filter.Finite","initialProofState":"ι : Type u_2\ninst✝ : Finite ι\nα : Type u_3\nf : ι → Filter α\ns : Set α\n⊢ Iff (Membership.mem (iInf fun i => f i) s) (Exists fun t => And (∀ (i : ι), Membership.mem (f i) (t i)) (Eq s (Set.iInter fun i => t i)))","decl":"theorem mem_iInf_of_finite {ι : Type*} [Finite ι] {α : Type*} {f : ι → Filter α} (s) :\n    (s ∈ ⨅ i, f i) ↔ ∃ t : ι → Set α, (∀ i, t i ∈ f i) ∧ s = ⋂ i, t i := by\n  refine ⟨exists_iInter_of_mem_iInf, ?_⟩\n  rintro ⟨t, ht, rfl⟩\n  exact iInter_mem.2 fun i => mem_iInf_of_mem i (ht i)\n\n"}
{"name":"Pairwise.exists_mem_filter_of_disjoint","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type u_2\ninst✝ : Finite ι\nl : ι → Filter α\nhd : Pairwise (Function.onFun Disjoint l)\n⊢ Exists fun s => And (∀ (i : ι), Membership.mem (l i) (s i)) (Pairwise (Function.onFun Disjoint s))","decl":"theorem _root_.Pairwise.exists_mem_filter_of_disjoint {ι : Type*} [Finite ι] {l : ι → Filter α}\n    (hd : Pairwise (Disjoint on l)) :\n    ∃ s : ι → Set α, (∀ i, s i ∈ l i) ∧ Pairwise (Disjoint on s) := by\n  have : Pairwise fun i j => ∃ (s : {s // s ∈ l i}) (t : {t // t ∈ l j}), Disjoint s.1 t.1 := by\n    simpa only [Pairwise, Function.onFun, Filter.disjoint_iff, exists_prop, Subtype.exists] using hd\n  choose! s t hst using this\n  refine ⟨fun i => ⋂ j, @s i j ∩ @t j i, fun i => ?_, fun i j hij => ?_⟩\n  exacts [iInter_mem.2 fun j => inter_mem (@s i j).2 (@t j i).2,\n    (hst hij).mono ((iInter_subset _ j).trans inter_subset_left)\n      ((iInter_subset _ i).trans inter_subset_right)]\n\n"}
{"name":"Set.PairwiseDisjoint.exists_mem_filter","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type u_2\nl : ι → Filter α\nt : Set ι\nhd : t.PairwiseDisjoint l\nht : t.Finite\n⊢ Exists fun s => And (∀ (i : ι), Membership.mem (l i) (s i)) (t.PairwiseDisjoint s)","decl":"theorem _root_.Set.PairwiseDisjoint.exists_mem_filter {ι : Type*} {l : ι → Filter α} {t : Set ι}\n    (hd : t.PairwiseDisjoint l) (ht : t.Finite) :\n    ∃ s : ι → Set α, (∀ i, s i ∈ l i) ∧ t.PairwiseDisjoint s := by\n  haveI := ht.to_subtype\n  rcases (hd.subtype _ _).exists_mem_filter_of_disjoint with ⟨s, hsl, hsd⟩\n  lift s to (i : t) → {s // s ∈ l i} using hsl\n  rcases @Subtype.exists_pi_extension ι (fun i => { s // s ∈ l i }) _ _ s with ⟨s, rfl⟩\n  exact ⟨fun i => s i, fun i => (s i).2, hsd.set_of_subtype _ _⟩\n\n\n"}
{"name":"Filter.iInf_sets_eq_finite","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type u_2\nf : ι → Filter α\n⊢ Eq (iInf fun i => f i).sets (Set.iUnion fun t => (iInf fun i => iInf fun h => f i).sets)","decl":"theorem iInf_sets_eq_finite {ι : Type*} (f : ι → Filter α) :\n    (⨅ i, f i).sets = ⋃ t : Finset ι, (⨅ i ∈ t, f i).sets := by\n  rw [iInf_eq_iInf_finset, iInf_sets_eq]\n  exact directed_of_isDirected_le fun _ _ => biInf_mono\n\n"}
{"name":"Filter.iInf_sets_eq_finite'","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\n⊢ Eq (iInf fun i => f i).sets (Set.iUnion fun t => (iInf fun i => iInf fun h => f i.down).sets)","decl":"theorem iInf_sets_eq_finite' (f : ι → Filter α) :\n    (⨅ i, f i).sets = ⋃ t : Finset (PLift ι), (⨅ i ∈ t, f (PLift.down i)).sets := by\n  rw [← iInf_sets_eq_finite, ← Equiv.plift.surjective.iInf_comp, Equiv.plift_apply]\n\n"}
{"name":"Filter.mem_iInf_finite","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type u_2\nf : ι → Filter α\ns : Set α\n⊢ Iff (Membership.mem (iInf f) s) (Exists fun t => Membership.mem (iInf fun i => iInf fun h => f i) s)","decl":"theorem mem_iInf_finite {ι : Type*} {f : ι → Filter α} (s) :\n    s ∈ iInf f ↔ ∃ t : Finset ι, s ∈ ⨅ i ∈ t, f i :=\n  (Set.ext_iff.1 (iInf_sets_eq_finite f) s).trans mem_iUnion\n\n"}
{"name":"Filter.mem_iInf_finite'","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\ns : Set α\n⊢ Iff (Membership.mem (iInf f) s) (Exists fun t => Membership.mem (iInf fun i => iInf fun h => f i.down) s)","decl":"theorem mem_iInf_finite' {f : ι → Filter α} (s) :\n    s ∈ iInf f ↔ ∃ t : Finset (PLift ι), s ∈ ⨅ i ∈ t, f (PLift.down i) :=\n  (Set.ext_iff.1 (iInf_sets_eq_finite' f) s).trans mem_iUnion\n\n"}
{"name":"Filter.mem_iInf_finset","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nβ : Type v\ns : Finset α\nf : α → Filter β\nt : Set β\n⊢ Iff (Membership.mem (iInf fun a => iInf fun h => f a) t) (Exists fun p => And (∀ (a : α), Membership.mem s a → Membership.mem (f a) (p a)) (Eq t (Set.iInter fun a => Set.iInter fun h => p a)))","decl":"theorem mem_iInf_finset {s : Finset α} {f : α → Filter β} {t : Set β} :\n    (t ∈ ⨅ a ∈ s, f a) ↔ ∃ p : α → Set β, (∀ a ∈ s, p a ∈ f a) ∧ t = ⋂ a ∈ s, p a := by\n  classical\n  simp only [← Finset.set_biInter_coe, biInter_eq_iInter, iInf_subtype']\n  refine ⟨fun h => ?_, ?_⟩\n  · rcases (mem_iInf_of_finite _).1 h with ⟨p, hp, rfl⟩\n    refine ⟨fun a => if h : a ∈ s then p ⟨a, h⟩ else univ,\n            fun a ha => by simpa [ha] using hp ⟨a, ha⟩, ?_⟩\n    refine iInter_congr_of_surjective id surjective_id ?_\n    rintro ⟨a, ha⟩\n    simp [ha]\n  · rintro ⟨p, hpf, rfl⟩\n    exact iInter_mem.2 fun a => mem_iInf_of_mem a (hpf a a.2)\n\n\n"}
{"name":"Filter.iInf_sets_induct","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Sort x\nf : ι → Filter α\ns : Set α\nhs : Membership.mem (iInf f) s\np : Set α → Prop\nuni : p Set.univ\nins : ∀ {i : ι} {s₁ s₂ : Set α}, Membership.mem (f i) s₁ → p s₂ → p (Inter.inter s₁ s₂)\n⊢ p s","decl":"@[elab_as_elim]\ntheorem iInf_sets_induct {f : ι → Filter α} {s : Set α} (hs : s ∈ iInf f) {p : Set α → Prop}\n    (uni : p univ) (ins : ∀ {i s₁ s₂}, s₁ ∈ f i → p s₂ → p (s₁ ∩ s₂)) : p s := by\n  classical\n  rw [mem_iInf_finite'] at hs\n  simp only [← Finset.inf_eq_iInf] at hs\n  rcases hs with ⟨is, his⟩\n  induction is using Finset.induction_on generalizing s with\n  | empty => rwa [mem_top.1 his]\n  | insert _ ih =>\n    rw [Finset.inf_insert, mem_inf_iff] at his\n    rcases his with ⟨s₁, hs₁, s₂, hs₂, rfl⟩\n    exact ins hs₁ (ih hs₂)\n\n"}
{"name":"Filter.iInf_principal_finset","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type w\ns : Finset ι\nf : ι → Set α\n⊢ Eq (iInf fun i => iInf fun h => Filter.principal (f i)) (Filter.principal (Set.iInter fun i => Set.iInter fun h => f i))","decl":"@[simp]\ntheorem iInf_principal_finset {ι : Type w} (s : Finset ι) (f : ι → Set α) :\n    ⨅ i ∈ s, 𝓟 (f i) = 𝓟 (⋂ i ∈ s, f i) := by\n  classical\n  induction' s using Finset.induction_on with i s _ hs\n  · simp\n  · rw [Finset.iInf_insert, Finset.set_biInter_insert, hs, inf_principal]\n\n"}
{"name":"Filter.iInf_principal","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Sort w\ninst✝ : Finite ι\nf : ι → Set α\n⊢ Eq (iInf fun i => Filter.principal (f i)) (Filter.principal (Set.iInter fun i => f i))","decl":"theorem iInf_principal {ι : Sort w} [Finite ι] (f : ι → Set α) : ⨅ i, 𝓟 (f i) = 𝓟 (⋂ i, f i) := by\n  cases nonempty_fintype (PLift ι)\n  rw [← iInf_plift_down, ← iInter_plift_down]\n  simpa using iInf_principal_finset Finset.univ (f <| PLift.down ·)\n\n"}
{"name":"Filter.iInf_principal'","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type w\ninst✝ : Finite ι\nf : ι → Set α\n⊢ Eq (iInf fun i => Filter.principal (f i)) (Filter.principal (Set.iInter fun i => f i))","decl":"/-- A special case of `iInf_principal` that is safe to mark `simp`. -/\n@[simp]\ntheorem iInf_principal' {ι : Type w} [Finite ι] (f : ι → Set α) : ⨅ i, 𝓟 (f i) = 𝓟 (⋂ i, f i) :=\n  iInf_principal _\n\n"}
{"name":"Filter.iInf_principal_finite","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type w\ns : Set ι\nhs : s.Finite\nf : ι → Set α\n⊢ Eq (iInf fun i => iInf fun h => Filter.principal (f i)) (Filter.principal (Set.iInter fun i => Set.iInter fun h => f i))","decl":"theorem iInf_principal_finite {ι : Type w} {s : Set ι} (hs : s.Finite) (f : ι → Set α) :\n    ⨅ i ∈ s, 𝓟 (f i) = 𝓟 (⋂ i ∈ s, f i) := by\n  lift s to Finset ι using hs\n  exact mod_cast iInf_principal_finset s f\n\n"}
{"name":"Filter.eventually_all","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Sort u_2\ninst✝ : Finite ι\nl : Filter α\np : ι → α → Prop\n⊢ Iff (Filter.Eventually (fun x => ∀ (i : ι), p i x) l) (∀ (i : ι), Filter.Eventually (fun x => p i x) l)","decl":"@[simp]\ntheorem eventually_all {ι : Sort*} [Finite ι] {l} {p : ι → α → Prop} :\n    (∀ᶠ x in l, ∀ i, p i x) ↔ ∀ i, ∀ᶠ x in l, p i x := by\n  simpa only [Filter.Eventually, setOf_forall] using iInter_mem\n\n"}
{"name":"Filter.eventually_all_finite","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type u_2\nI : Set ι\nhI : I.Finite\nl : Filter α\np : ι → α → Prop\n⊢ Iff (Filter.Eventually (fun x => ∀ (i : ι), Membership.mem I i → p i x) l) (∀ (i : ι), Membership.mem I i → Filter.Eventually (fun x => p i x) l)","decl":"@[simp]\ntheorem eventually_all_finite {ι} {I : Set ι} (hI : I.Finite) {l} {p : ι → α → Prop} :\n    (∀ᶠ x in l, ∀ i ∈ I, p i x) ↔ ∀ i ∈ I, ∀ᶠ x in l, p i x := by\n  simpa only [Filter.Eventually, setOf_forall] using biInter_mem hI\n\n"}
{"name":"Set.Finite.eventually_all","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type u_2\nI : Set ι\nhI : I.Finite\nl : Filter α\np : ι → α → Prop\n⊢ Iff (Filter.Eventually (fun x => ∀ (i : ι), Membership.mem I i → p i x) l) (∀ (i : ι), Membership.mem I i → Filter.Eventually (fun x => p i x) l)","decl":"alias _root_.Set.Finite.eventually_all := eventually_all_finite\n\n-- attribute [protected] Set.Finite.eventually_all\n\n"}
{"name":"Filter.eventually_all_finset","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type u_2\nI : Finset ι\nl : Filter α\np : ι → α → Prop\n⊢ Iff (Filter.Eventually (fun x => ∀ (i : ι), Membership.mem I i → p i x) l) (∀ (i : ι), Membership.mem I i → Filter.Eventually (fun x => p i x) l)","decl":"@[simp] theorem eventually_all_finset {ι} (I : Finset ι) {l} {p : ι → α → Prop} :\n    (∀ᶠ x in l, ∀ i ∈ I, p i x) ↔ ∀ i ∈ I, ∀ᶠ x in l, p i x :=\n  I.finite_toSet.eventually_all\n\n"}
{"name":"Finset.eventually_all","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Type u_2\nI : Finset ι\nl : Filter α\np : ι → α → Prop\n⊢ Iff (Filter.Eventually (fun x => ∀ (i : ι), Membership.mem I i → p i x) l) (∀ (i : ι), Membership.mem I i → Filter.Eventually (fun x => p i x) l)","decl":"alias _root_.Finset.eventually_all := eventually_all_finset\n\n-- attribute [protected] Finset.eventually_all\n\n"}
{"name":"Filter.EventuallyLE.iUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Sort x\nl : Filter α\ninst✝ : Finite ι\ns t : ι → Set α\nh : ∀ (i : ι), l.EventuallyLE (s i) (t i)\n⊢ l.EventuallyLE (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"protected lemma EventuallyLE.iUnion [Finite ι] {s t : ι → Set α}\n    (h : ∀ i, s i ≤ᶠ[l] t i) : (⋃ i, s i) ≤ᶠ[l] ⋃ i, t i :=\n  (eventually_all.2 h).mono fun _x hx hx' ↦\n    let ⟨i, hi⟩ := mem_iUnion.1 hx'; mem_iUnion.2 ⟨i, hx i hi⟩\n\n"}
{"name":"Filter.EventuallyEq.iUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Sort x\nl : Filter α\ninst✝ : Finite ι\ns t : ι → Set α\nh : ∀ (i : ι), l.EventuallyEq (s i) (t i)\n⊢ l.EventuallyEq (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"protected lemma EventuallyEq.iUnion [Finite ι] {s t : ι → Set α}\n    (h : ∀ i, s i =ᶠ[l] t i) : (⋃ i, s i) =ᶠ[l] ⋃ i, t i :=\n  (EventuallyLE.iUnion fun i ↦ (h i).le).antisymm <| .iUnion fun i ↦ (h i).symm.le\n\n"}
{"name":"Filter.EventuallyLE.iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Sort x\nl : Filter α\ninst✝ : Finite ι\ns t : ι → Set α\nh : ∀ (i : ι), l.EventuallyLE (s i) (t i)\n⊢ l.EventuallyLE (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"protected lemma EventuallyLE.iInter [Finite ι] {s t : ι → Set α}\n    (h : ∀ i, s i ≤ᶠ[l] t i) : (⋂ i, s i) ≤ᶠ[l] ⋂ i, t i :=\n  (eventually_all.2 h).mono fun _x hx hx' ↦ mem_iInter.2 fun i ↦ hx i (mem_iInter.1 hx' i)\n\n"}
{"name":"Filter.EventuallyEq.iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nι : Sort x\nl : Filter α\ninst✝ : Finite ι\ns t : ι → Set α\nh : ∀ (i : ι), l.EventuallyEq (s i) (t i)\n⊢ l.EventuallyEq (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"protected lemma EventuallyEq.iInter [Finite ι] {s t : ι → Set α}\n    (h : ∀ i, s i =ᶠ[l] t i) : (⋂ i, s i) =ᶠ[l] ⋂ i, t i :=\n  (EventuallyLE.iInter fun i ↦ (h i).le).antisymm <| .iInter fun i ↦ (h i).symm.le\n\n"}
{"name":"Set.Finite.eventuallyLE_iUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nl : Filter α\nι : Type u_2\ns : Set ι\nhs : s.Finite\nf g : ι → Set α\nhle : ∀ (i : ι), Membership.mem s i → l.EventuallyLE (f i) (g i)\n⊢ l.EventuallyLE (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => g i)","decl":"lemma _root_.Set.Finite.eventuallyLE_iUnion {ι : Type*} {s : Set ι} (hs : s.Finite)\n    {f g : ι → Set α} (hle : ∀ i ∈ s, f i ≤ᶠ[l] g i) : (⋃ i ∈ s, f i) ≤ᶠ[l] (⋃ i ∈ s, g i) := by\n  have := hs.to_subtype\n  rw [biUnion_eq_iUnion, biUnion_eq_iUnion]\n  exact .iUnion fun i ↦ hle i.1 i.2\n\n"}
{"name":"Filter.EventuallyLE.biUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nl : Filter α\nι : Type u_2\ns : Set ι\nhs : s.Finite\nf g : ι → Set α\nhle : ∀ (i : ι), Membership.mem s i → l.EventuallyLE (f i) (g i)\n⊢ l.EventuallyLE (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => g i)","decl":"alias EventuallyLE.biUnion := Set.Finite.eventuallyLE_iUnion\n\n"}
{"name":"Set.Finite.eventuallyEq_iUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nl : Filter α\nι : Type u_2\ns : Set ι\nhs : s.Finite\nf g : ι → Set α\nheq : ∀ (i : ι), Membership.mem s i → l.EventuallyEq (f i) (g i)\n⊢ l.EventuallyEq (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => g i)","decl":"lemma _root_.Set.Finite.eventuallyEq_iUnion {ι : Type*} {s : Set ι} (hs : s.Finite)\n    {f g : ι → Set α} (heq : ∀ i ∈ s, f i =ᶠ[l] g i) : (⋃ i ∈ s, f i) =ᶠ[l] (⋃ i ∈ s, g i) :=\n  (EventuallyLE.biUnion hs fun i hi ↦ (heq i hi).le).antisymm <|\n    .biUnion hs fun i hi ↦ (heq i hi).symm.le\n\n"}
{"name":"Filter.EventuallyEq.biUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nl : Filter α\nι : Type u_2\ns : Set ι\nhs : s.Finite\nf g : ι → Set α\nheq : ∀ (i : ι), Membership.mem s i → l.EventuallyEq (f i) (g i)\n⊢ l.EventuallyEq (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => g i)","decl":"alias EventuallyEq.biUnion := Set.Finite.eventuallyEq_iUnion\n\n"}
{"name":"Set.Finite.eventuallyLE_iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nl : Filter α\nι : Type u_2\ns : Set ι\nhs : s.Finite\nf g : ι → Set α\nhle : ∀ (i : ι), Membership.mem s i → l.EventuallyLE (f i) (g i)\n⊢ l.EventuallyLE (Set.iInter fun i => Set.iInter fun h => f i) (Set.iInter fun i => Set.iInter fun h => g i)","decl":"lemma _root_.Set.Finite.eventuallyLE_iInter {ι : Type*} {s : Set ι} (hs : s.Finite)\n    {f g : ι → Set α} (hle : ∀ i ∈ s, f i ≤ᶠ[l] g i) : (⋂ i ∈ s, f i) ≤ᶠ[l] (⋂ i ∈ s, g i) := by\n  have := hs.to_subtype\n  rw [biInter_eq_iInter, biInter_eq_iInter]\n  exact .iInter fun i ↦ hle i.1 i.2\n\n"}
{"name":"Filter.EventuallyLE.biInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nl : Filter α\nι : Type u_2\ns : Set ι\nhs : s.Finite\nf g : ι → Set α\nhle : ∀ (i : ι), Membership.mem s i → l.EventuallyLE (f i) (g i)\n⊢ l.EventuallyLE (Set.iInter fun i => Set.iInter fun h => f i) (Set.iInter fun i => Set.iInter fun h => g i)","decl":"alias EventuallyLE.biInter := Set.Finite.eventuallyLE_iInter\n\n"}
{"name":"Set.Finite.eventuallyEq_iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nl : Filter α\nι : Type u_2\ns : Set ι\nhs : s.Finite\nf g : ι → Set α\nheq : ∀ (i : ι), Membership.mem s i → l.EventuallyEq (f i) (g i)\n⊢ l.EventuallyEq (Set.iInter fun i => Set.iInter fun h => f i) (Set.iInter fun i => Set.iInter fun h => g i)","decl":"lemma _root_.Set.Finite.eventuallyEq_iInter {ι : Type*} {s : Set ι} (hs : s.Finite)\n    {f g : ι → Set α} (heq : ∀ i ∈ s, f i =ᶠ[l] g i) : (⋂ i ∈ s, f i) =ᶠ[l] (⋂ i ∈ s, g i) :=\n  (EventuallyLE.biInter hs fun i hi ↦ (heq i hi).le).antisymm <|\n    .biInter hs fun i hi ↦ (heq i hi).symm.le\n\n"}
{"name":"Filter.EventuallyEq.biInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nl : Filter α\nι : Type u_2\ns : Set ι\nhs : s.Finite\nf g : ι → Set α\nheq : ∀ (i : ι), Membership.mem s i → l.EventuallyEq (f i) (g i)\n⊢ l.EventuallyEq (Set.iInter fun i => Set.iInter fun h => f i) (Set.iInter fun i => Set.iInter fun h => g i)","decl":"alias EventuallyEq.biInter := Set.Finite.eventuallyEq_iInter\n\n"}
{"name":"Finset.eventuallyLE_iUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nl : Filter α\nι : Type u_2\ns : Finset ι\nf g : ι → Set α\nhle : ∀ (i : ι), Membership.mem s i → l.EventuallyLE (f i) (g i)\n⊢ l.EventuallyLE (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => g i)","decl":"lemma _root_.Finset.eventuallyLE_iUnion {ι : Type*} (s : Finset ι) {f g : ι → Set α}\n    (hle : ∀ i ∈ s, f i ≤ᶠ[l] g i) : (⋃ i ∈ s, f i) ≤ᶠ[l] (⋃ i ∈ s, g i) :=\n  .biUnion s.finite_toSet hle\n\n"}
{"name":"Finset.eventuallyEq_iUnion","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nl : Filter α\nι : Type u_2\ns : Finset ι\nf g : ι → Set α\nheq : ∀ (i : ι), Membership.mem s i → l.EventuallyEq (f i) (g i)\n⊢ l.EventuallyEq (Set.iUnion fun i => Set.iUnion fun h => f i) (Set.iUnion fun i => Set.iUnion fun h => g i)","decl":"lemma _root_.Finset.eventuallyEq_iUnion {ι : Type*} (s : Finset ι) {f g : ι → Set α}\n    (heq : ∀ i ∈ s, f i =ᶠ[l] g i) : (⋃ i ∈ s, f i) =ᶠ[l] (⋃ i ∈ s, g i) :=\n  .biUnion s.finite_toSet heq\n\n"}
{"name":"Finset.eventuallyLE_iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nl : Filter α\nι : Type u_2\ns : Finset ι\nf g : ι → Set α\nhle : ∀ (i : ι), Membership.mem s i → l.EventuallyLE (f i) (g i)\n⊢ l.EventuallyLE (Set.iInter fun i => Set.iInter fun h => f i) (Set.iInter fun i => Set.iInter fun h => g i)","decl":"lemma _root_.Finset.eventuallyLE_iInter {ι : Type*} (s : Finset ι) {f g : ι → Set α}\n    (hle : ∀ i ∈ s, f i ≤ᶠ[l] g i) : (⋂ i ∈ s, f i) ≤ᶠ[l] (⋂ i ∈ s, g i) :=\n  .biInter s.finite_toSet hle\n\n"}
{"name":"Finset.eventuallyEq_iInter","module":"Mathlib.Order.Filter.Finite","initialProofState":"α : Type u\nl : Filter α\nι : Type u_2\ns : Finset ι\nf g : ι → Set α\nheq : ∀ (i : ι), Membership.mem s i → l.EventuallyEq (f i) (g i)\n⊢ l.EventuallyEq (Set.iInter fun i => Set.iInter fun h => f i) (Set.iInter fun i => Set.iInter fun h => g i)","decl":"lemma _root_.Finset.eventuallyEq_iInter {ι : Type*} (s : Finset ι) {f g : ι → Set α}\n    (heq : ∀ i ∈ s, f i =ᶠ[l] g i) : (⋂ i ∈ s, f i) =ᶠ[l] (⋂ i ∈ s, g i) :=\n  .biInter s.finite_toSet heq\n\n"}
