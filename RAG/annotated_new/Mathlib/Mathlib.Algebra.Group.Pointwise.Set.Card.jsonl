{"name":"Cardinal.mk_mul_le","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"M : Type u_2\ninst✝ : Mul M\ns t : Set M\n⊢ LE.le (Cardinal.mk ↑(HMul.hMul s t)) (HMul.hMul (Cardinal.mk ↑s) (Cardinal.mk ↑t))","decl":"@[to_additive]\nlemma _root_.Cardinal.mk_mul_le : #(s * t) ≤ #s * #t := by\n  rw [← image2_mul]; exact Cardinal.mk_image2_le\n\n"}
{"name":"Cardinal.mk_add_le","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"M : Type u_2\ninst✝ : Add M\ns t : Set M\n⊢ LE.le (Cardinal.mk ↑(HAdd.hAdd s t)) (HMul.hMul (Cardinal.mk ↑s) (Cardinal.mk ↑t))","decl":"@[to_additive]\nlemma _root_.Cardinal.mk_mul_le : #(s * t) ≤ #s * #t := by\n  rw [← image2_mul]; exact Cardinal.mk_image2_le\n\n"}
{"name":"Set.natCard_add_le","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"M : Type u_2\ninst✝¹ : Add M\ns t : Set M\ninst✝ : IsCancelAdd M\n⊢ LE.le (Nat.card ↑(HAdd.hAdd s t)) (HMul.hMul (Nat.card ↑s) (Nat.card ↑t))","decl":"@[to_additive]\nlemma natCard_mul_le : Nat.card (s * t) ≤ Nat.card s * Nat.card t := by\n  obtain h | h := (s * t).infinite_or_finite\n  · simp [Set.Infinite.card_eq_zero h]\n  simp only [Nat.card, ← Cardinal.toNat_mul]\n  refine Cardinal.toNat_le_toNat Cardinal.mk_mul_le ?_\n  aesop (add simp [Cardinal.mul_lt_aleph0_iff, finite_mul])\n\n"}
{"name":"Set.natCard_mul_le","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"M : Type u_2\ninst✝¹ : Mul M\ns t : Set M\ninst✝ : IsCancelMul M\n⊢ LE.le (Nat.card ↑(HMul.hMul s t)) (HMul.hMul (Nat.card ↑s) (Nat.card ↑t))","decl":"@[to_additive]\nlemma natCard_mul_le : Nat.card (s * t) ≤ Nat.card s * Nat.card t := by\n  obtain h | h := (s * t).infinite_or_finite\n  · simp [Set.Infinite.card_eq_zero h]\n  simp only [Nat.card, ← Cardinal.toNat_mul]\n  refine Cardinal.toNat_le_toNat Cardinal.mk_mul_le ?_\n  aesop (add simp [Cardinal.mul_lt_aleph0_iff, finite_mul])\n\n"}
{"name":"Set.card_add_le","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"M : Type u_2\ninst✝¹ : Add M\ns t : Set M\ninst✝ : IsCancelAdd M\n⊢ LE.le (Nat.card ↑(HAdd.hAdd s t)) (HMul.hMul (Nat.card ↑s) (Nat.card ↑t))","decl":"@[to_additive] alias card_mul_le := natCard_mul_le\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Set.card_mul_le","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"M : Type u_2\ninst✝¹ : Mul M\ns t : Set M\ninst✝ : IsCancelMul M\n⊢ LE.le (Nat.card ↑(HMul.hMul s t)) (HMul.hMul (Nat.card ↑s) (Nat.card ↑t))","decl":"@[to_additive] alias card_mul_le := natCard_mul_le\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Cardinal.mk_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : InvolutiveInv G\ns : Set G\n⊢ Eq (Cardinal.mk ↑(Inv.inv s)) (Cardinal.mk ↑s)","decl":"@[to_additive (attr := simp)]\nlemma _root_.Cardinal.mk_inv (s : Set G) : #↥(s⁻¹) = #s := by\n  rw [← image_inv_eq_inv, Cardinal.mk_image_eq_of_injOn _ _ inv_injective.injOn]\n\n"}
{"name":"Cardinal.mk_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : InvolutiveNeg G\ns : Set G\n⊢ Eq (Cardinal.mk ↑(Neg.neg s)) (Cardinal.mk ↑s)","decl":"@[to_additive (attr := simp)]\nlemma _root_.Cardinal.mk_inv (s : Set G) : #↥(s⁻¹) = #s := by\n  rw [← image_inv_eq_inv, Cardinal.mk_image_eq_of_injOn _ _ inv_injective.injOn]\n\n"}
{"name":"Set.natCard_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : InvolutiveInv G\ns : Set G\n⊢ Eq (Nat.card ↑(Inv.inv s)) (Nat.card ↑s)","decl":"@[to_additive (attr := simp)]\nlemma natCard_inv (s : Set G) : Nat.card ↥(s⁻¹) = Nat.card s := by\n  rw [← image_inv_eq_inv, Nat.card_image_of_injective inv_injective]\n\n"}
{"name":"Set.natCard_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : InvolutiveNeg G\ns : Set G\n⊢ Eq (Nat.card ↑(Neg.neg s)) (Nat.card ↑s)","decl":"@[to_additive (attr := simp)]\nlemma natCard_inv (s : Set G) : Nat.card ↥(s⁻¹) = Nat.card s := by\n  rw [← image_inv_eq_inv, Nat.card_image_of_injective inv_injective]\n\n"}
{"name":"Set.card_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : InvolutiveInv G\ns : Set G\n⊢ Eq (Nat.card ↑(Inv.inv s)) (Nat.card ↑s)","decl":"@[to_additive] alias card_inv := natCard_inv\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Set.card_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : InvolutiveNeg G\ns : Set G\n⊢ Eq (Nat.card ↑(Neg.neg s)) (Nat.card ↑s)","decl":"@[to_additive] alias card_inv := natCard_inv\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Set.encard_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : InvolutiveInv G\ns : Set G\n⊢ Eq (Inv.inv s).encard s.encard","decl":"@[to_additive (attr := simp)]\nlemma encard_inv (s : Set G) : s⁻¹.encard = s.encard := by simp [encard, ENat.card]\n\n"}
{"name":"Set.encard_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : InvolutiveNeg G\ns : Set G\n⊢ Eq (Neg.neg s).encard s.encard","decl":"@[to_additive (attr := simp)]\nlemma encard_inv (s : Set G) : s⁻¹.encard = s.encard := by simp [encard, ENat.card]\n\n"}
{"name":"Set.ncard_inv","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : InvolutiveInv G\ns : Set G\n⊢ Eq (Inv.inv s).ncard s.ncard","decl":"@[to_additive (attr := simp)]\nlemma ncard_inv (s : Set G) : s⁻¹.ncard = s.ncard := by simp [ncard]\n\n"}
{"name":"Set.ncard_neg","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : InvolutiveNeg G\ns : Set G\n⊢ Eq (Neg.neg s).ncard s.ncard","decl":"@[to_additive (attr := simp)]\nlemma ncard_inv (s : Set G) : s⁻¹.ncard = s.ncard := by simp [ncard]\n\n"}
{"name":"Cardinal.mk_div_le","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"M : Type u_2\ninst✝ : DivInvMonoid M\ns t : Set M\n⊢ LE.le (Cardinal.mk ↑(HDiv.hDiv s t)) (HMul.hMul (Cardinal.mk ↑s) (Cardinal.mk ↑t))","decl":"@[to_additive]\nlemma _root_.Cardinal.mk_div_le : #(s / t) ≤ #s * #t := by\n  rw [← image2_div]; exact Cardinal.mk_image2_le\n\n"}
{"name":"Cardinal.mk_sub_le","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"M : Type u_2\ninst✝ : SubNegMonoid M\ns t : Set M\n⊢ LE.le (Cardinal.mk ↑(HSub.hSub s t)) (HMul.hMul (Cardinal.mk ↑s) (Cardinal.mk ↑t))","decl":"@[to_additive]\nlemma _root_.Cardinal.mk_div_le : #(s / t) ≤ #s * #t := by\n  rw [← image2_div]; exact Cardinal.mk_image2_le\n\n"}
{"name":"Set.natCard_div_le","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : Group G\ns t : Set G\n⊢ LE.le (Nat.card ↑(HDiv.hDiv s t)) (HMul.hMul (Nat.card ↑s) (Nat.card ↑t))","decl":"@[to_additive]\nlemma natCard_div_le : Nat.card (s / t) ≤ Nat.card s * Nat.card t := by\n  rw [div_eq_mul_inv, ← natCard_inv t]; exact natCard_mul_le\n\n"}
{"name":"Set.natCard_sub_le","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ns t : Set G\n⊢ LE.le (Nat.card ↑(HSub.hSub s t)) (HMul.hMul (Nat.card ↑s) (Nat.card ↑t))","decl":"@[to_additive]\nlemma natCard_div_le : Nat.card (s / t) ≤ Nat.card s * Nat.card t := by\n  rw [div_eq_mul_inv, ← natCard_inv t]; exact natCard_mul_le\n\n"}
{"name":"Set.card_div_le","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : Group G\ns t : Set G\n⊢ LE.le (Nat.card ↑(HDiv.hDiv s t)) (HMul.hMul (Nat.card ↑s) (Nat.card ↑t))","decl":"@[to_additive] alias card_div_le := natCard_div_le\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Set.card_sub_le","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ns t : Set G\n⊢ LE.le (Nat.card ↑(HSub.hSub s t)) (HMul.hMul (Nat.card ↑s) (Nat.card ↑t))","decl":"@[to_additive] alias card_div_le := natCard_div_le\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Cardinal.mk_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : G\ns : Set α\n⊢ Eq (Cardinal.mk ↑(HSMul.hSMul a s)) (Cardinal.mk ↑s)","decl":"@[to_additive (attr := simp)]\nlemma _root_.Cardinal.mk_smul_set (a : G) (s : Set α) : #↥(a • s) = #s :=\n  Cardinal.mk_image_eq_of_injOn _ _ (MulAction.injective a).injOn\n\n"}
{"name":"Cardinal.mk_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : G\ns : Set α\n⊢ Eq (Cardinal.mk ↑(HVAdd.hVAdd a s)) (Cardinal.mk ↑s)","decl":"@[to_additive (attr := simp)]\nlemma _root_.Cardinal.mk_smul_set (a : G) (s : Set α) : #↥(a • s) = #s :=\n  Cardinal.mk_image_eq_of_injOn _ _ (MulAction.injective a).injOn\n\n"}
{"name":"Set.natCard_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : G\ns : Set α\n⊢ Eq (Nat.card ↑(HSMul.hSMul a s)) (Nat.card ↑s)","decl":"@[to_additive (attr := simp)]\nlemma natCard_smul_set (a : G) (s : Set α) : Nat.card ↥(a • s) = Nat.card s :=\n  Nat.card_image_of_injective (MulAction.injective a) _\n\n"}
{"name":"Set.natCard_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : G\ns : Set α\n⊢ Eq (Nat.card ↑(HVAdd.hVAdd a s)) (Nat.card ↑s)","decl":"@[to_additive (attr := simp)]\nlemma natCard_smul_set (a : G) (s : Set α) : Nat.card ↥(a • s) = Nat.card s :=\n  Nat.card_image_of_injective (MulAction.injective a) _\n\n"}
{"name":"Set.card_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : G\ns : Set α\n⊢ Eq (Cardinal.mk ↑(HSMul.hSMul a s)) (Cardinal.mk ↑s)","decl":"@[to_additive]\nalias card_smul_set := Cardinal.mk_smul_set\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Set.card_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : G\ns : Set α\n⊢ Eq (Cardinal.mk ↑(HVAdd.hVAdd a s)) (Cardinal.mk ↑s)","decl":"@[to_additive]\nalias card_smul_set := Cardinal.mk_smul_set\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Set.encard_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : G\ns : Set α\n⊢ Eq (HSMul.hSMul a s).encard s.encard","decl":"@[to_additive (attr := simp)]\nlemma encard_smul_set (a : G) (s : Set α) : (a • s).encard = s.encard := by\n  simp [encard, ENat.card]\n\n"}
{"name":"Set.encard_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : G\ns : Set α\n⊢ Eq (HVAdd.hVAdd a s).encard s.encard","decl":"@[to_additive (attr := simp)]\nlemma encard_smul_set (a : G) (s : Set α) : (a • s).encard = s.encard := by\n  simp [encard, ENat.card]\n\n"}
{"name":"Set.ncard_smul_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : G\ns : Set α\n⊢ Eq (HSMul.hSMul a s).ncard s.ncard","decl":"@[to_additive (attr := simp)]\nlemma ncard_smul_set (a : G) (s : Set α) : (a • s).ncard = s.ncard := by simp [ncard]\n\n"}
{"name":"Set.ncard_vadd_set","module":"Mathlib.Algebra.Group.Pointwise.Set.Card","initialProofState":"G : Type u_1\nα : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : G\ns : Set α\n⊢ Eq (HVAdd.hVAdd a s).ncard s.ncard","decl":"@[to_additive (attr := simp)]\nlemma ncard_smul_set (a : G) (s : Set α) : (a • s).ncard = s.ncard := by simp [ncard]\n\n"}
