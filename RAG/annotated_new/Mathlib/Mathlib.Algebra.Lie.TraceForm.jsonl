{"name":"LieModule.traceForm_apply_apply","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx y : L\n⊢ Eq (((LieModule.traceForm R L M) x) y) ((LinearMap.trace R M) (LinearMap.comp ((LieModule.toEnd R L M) x) ((LieModule.toEnd R L M) y)))","decl":"lemma traceForm_apply_apply (x y : L) :\n    traceForm R L M x y = trace R _ (φ x ∘ₗ φ y) :=\n  rfl\n\n"}
{"name":"LieModule.traceForm_comm","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx y : L\n⊢ Eq (((LieModule.traceForm R L M) x) y) (((LieModule.traceForm R L M) y) x)","decl":"lemma traceForm_comm (x y : L) : traceForm R L M x y = traceForm R L M y x :=\n  LinearMap.trace_mul_comm R (φ x) (φ y)\n\n"}
{"name":"LieModule.traceForm_isSymm","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ LinearMap.IsSymm (LieModule.traceForm R L M)","decl":"lemma traceForm_isSymm : LinearMap.IsSymm (traceForm R L M) := LieModule.traceForm_comm R L M\n\n"}
{"name":"LieModule.traceForm_flip","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Eq (LinearMap.flip (LieModule.traceForm R L M)) (LieModule.traceForm R L M)","decl":"@[simp] lemma traceForm_flip : LinearMap.flip (traceForm R L M) = traceForm R L M :=\n  Eq.symm <| LinearMap.ext₂ <| traceForm_comm R L M\n\n"}
{"name":"LieModule.traceForm_apply_lie_apply","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx y z : L\n⊢ Eq (((LieModule.traceForm R L M) (Bracket.bracket x y)) z) (((LieModule.traceForm R L M) x) (Bracket.bracket y z))","decl":"/-- The trace form of a Lie module is compatible with the action of the Lie algebra.\n\nSee also `LieModule.traceForm_apply_lie_apply'`. -/\nlemma traceForm_apply_lie_apply (x y z : L) :\n    traceForm R L M ⁅x, y⁆ z = traceForm R L M x ⁅y, z⁆ := by\n  calc traceForm R L M ⁅x, y⁆ z\n      = trace R _ (φ ⁅x, y⁆ ∘ₗ φ z) := by simp only [traceForm_apply_apply]\n    _ = trace R _ ((φ x * φ y - φ y * φ x) * φ z) := ?_\n    _ = trace R _ (φ x * (φ y * φ z)) - trace R _ (φ y * (φ x * φ z)) := ?_\n    _ = trace R _ (φ x * (φ y * φ z)) - trace R _ (φ x * (φ z * φ y)) := ?_\n    _ = traceForm R L M x ⁅y, z⁆ := ?_\n  · simp only [LieHom.map_lie, Ring.lie_def, ← LinearMap.mul_eq_comp]\n  · simp only [sub_mul, mul_sub, map_sub, mul_assoc]\n  · simp only [LinearMap.trace_mul_cycle' R (φ x) (φ z) (φ y)]\n  · simp only [traceForm_apply_apply, LieHom.map_lie, Ring.lie_def, mul_sub, map_sub,\n      ← LinearMap.mul_eq_comp]\n\n"}
{"name":"LieModule.traceForm_apply_lie_apply'","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx y z : L\n⊢ Eq (((LieModule.traceForm R L M) (Bracket.bracket x y)) z) (Neg.neg (((LieModule.traceForm R L M) y) (Bracket.bracket x z)))","decl":"/-- Given a representation `M` of a Lie algebra `L`, the action of any `x : L` is skew-adjoint wrt\nthe trace form. -/\nlemma traceForm_apply_lie_apply' (x y z : L) :\n    traceForm R L M ⁅x, y⁆ z = - traceForm R L M y ⁅x, z⁆ :=\n  calc traceForm R L M ⁅x, y⁆ z\n      = - traceForm R L M ⁅y, x⁆ z := by rw [← lie_skew x y, map_neg, LinearMap.neg_apply]\n    _ = - traceForm R L M y ⁅x, z⁆ := by rw [traceForm_apply_lie_apply]\n\n"}
{"name":"LieModule.traceForm_lieInvariant","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ LinearMap.BilinForm.lieInvariant L (LieModule.traceForm R L M)","decl":"lemma traceForm_lieInvariant : (traceForm R L M).lieInvariant L := by\n  intro x y z\n  rw [← lie_skew, map_neg, LinearMap.neg_apply, LieModule.traceForm_apply_lie_apply R L M]\n\n"}
{"name":"LieModule.lie_traceForm_eq_zero","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx : L\n⊢ Eq (Bracket.bracket x (LieModule.traceForm R L M)) 0","decl":"/-- This lemma justifies the terminology \"invariant\" for trace forms. -/\n@[simp] lemma lie_traceForm_eq_zero (x : L) : ⁅x, traceForm R L M⁆ = 0 := by\n  ext y z\n  rw [LieHom.lie_apply, LinearMap.sub_apply, Module.Dual.lie_apply, LinearMap.zero_apply,\n    LinearMap.zero_apply, traceForm_apply_lie_apply', sub_self]\n\n"}
{"name":"LieModule.traceForm_eq_zero_of_isNilpotent","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : IsReduced R\ninst✝ : LieModule.IsNilpotent L M\n⊢ Eq (LieModule.traceForm R L M) 0","decl":"@[simp] lemma traceForm_eq_zero_of_isNilpotent [IsReduced R] [IsNilpotent L M] :\n    traceForm R L M = 0 := by\n  ext x y\n  simp only [traceForm_apply_apply, LinearMap.zero_apply, ← isNilpotent_iff_eq_zero]\n  apply LinearMap.isNilpotent_trace_of_isNilpotent\n  exact isNilpotent_toEnd_of_isNilpotent₂ R L M x y\n\n"}
{"name":"LieModule.traceForm_genWeightSpace_eq","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : LieRing L\ninst✝¹⁰ : LieAlgebra R L\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : Module R M\ninst✝⁷ : LieRingModule L M\ninst✝⁶ : LieModule R L M\ninst✝⁵ : Module.Free R M\ninst✝⁴ : IsDomain R\ninst✝³ : IsPrincipalIdealRing R\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : IsNoetherian R M\ninst✝ : LieModule.LinearWeights R L M\nχ : L → R\nx y : L\n⊢ Eq (((LieModule.traceForm R L (Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x)) x) y) (HSMul.hSMul (Module.finrank R (Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x)) (HMul.hMul (χ x) (χ y)))","decl":"@[simp]\nlemma traceForm_genWeightSpace_eq [Module.Free R M]\n    [IsDomain R] [IsPrincipalIdealRing R]\n    [LieRing.IsNilpotent L] [IsNoetherian R M] [LinearWeights R L M] (χ : L → R) (x y : L) :\n    traceForm R L (genWeightSpace M χ) x y = finrank R (genWeightSpace M χ) • (χ x * χ y) := by\n  set d := finrank R (genWeightSpace M χ)\n  have h₁ : χ y • d • χ x - χ y • χ x • (d : R) = 0 := by simp [mul_comm (χ x)]\n  have h₂ : χ x • d • χ y = d • (χ x * χ y) := by\n    simpa [nsmul_eq_mul, smul_eq_mul] using mul_left_comm (χ x) d (χ y)\n  have := traceForm_eq_zero_of_isNilpotent R L (shiftedGenWeightSpace R L M χ)\n  replace this := LinearMap.congr_fun (LinearMap.congr_fun this x) y\n  rwa [LinearMap.zero_apply, LinearMap.zero_apply, traceForm_apply_apply,\n    shiftedGenWeightSpace.toEnd_eq, shiftedGenWeightSpace.toEnd_eq,\n    ← LinearEquiv.conj_comp, LinearMap.trace_conj', LinearMap.comp_sub, LinearMap.sub_comp,\n    LinearMap.sub_comp, map_sub, map_sub, map_sub, LinearMap.comp_smul, LinearMap.smul_comp,\n    LinearMap.comp_id, LinearMap.id_comp, LinearMap.map_smul, LinearMap.map_smul,\n    trace_toEnd_genWeightSpace, trace_toEnd_genWeightSpace,\n    LinearMap.comp_smul, LinearMap.smul_comp, LinearMap.id_comp, map_smul, map_smul,\n    LinearMap.trace_id, ← traceForm_apply_apply, h₁, h₂, sub_zero, sub_eq_zero] at this\n\n"}
{"name":"LieModule.traceForm_eq_zero_if_mem_lcs_of_mem_ucs","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx y : L\nk : Nat\nhx : Membership.mem (Top.top.lcs L k) x\nhy : Membership.mem (LieSubmodule.ucs k Bot.bot) y\n⊢ Eq (((LieModule.traceForm R L M) x) y) 0","decl":"/-- The upper and lower central series of `L` are orthogonal wrt the trace form of any Lie module\n`M`. -/\nlemma traceForm_eq_zero_if_mem_lcs_of_mem_ucs {x y : L} (k : ℕ)\n    (hx : x ∈ (⊤ : LieIdeal R L).lcs L k) (hy : y ∈ (⊥ : LieIdeal R L).ucs k) :\n    traceForm R L M x y = 0 := by\n  induction k generalizing x y with\n  | zero =>\n    replace hy : y = 0 := by simpa using hy\n    simp [hy]\n  | succ k ih =>\n    rw [LieSubmodule.ucs_succ, LieSubmodule.mem_normalizer] at hy\n    simp_rw [LieIdeal.lcs_succ, ← LieSubmodule.mem_toSubmodule,\n      LieSubmodule.lieIdeal_oper_eq_linear_span', LieSubmodule.mem_top, true_and] at hx\n    refine Submodule.span_induction ?_ ?_ (fun z w _ _ hz hw ↦ ?_) (fun t z _ hz ↦ ?_) hx\n    · rintro - ⟨z, w, hw, rfl⟩\n      rw [← lie_skew, map_neg, LinearMap.neg_apply, neg_eq_zero, traceForm_apply_lie_apply]\n      exact ih hw (hy _)\n    · simp\n    · simp [hz, hw]\n    · simp [hz]\n\n"}
{"name":"LieModule.traceForm_apply_eq_zero_of_mem_lcs_of_mem_center","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx y : L\nhx : Membership.mem (LieModule.lowerCentralSeries R L L 1) x\nhy : Membership.mem (LieAlgebra.center R L) y\n⊢ Eq (((LieModule.traceForm R L M) x) y) 0","decl":"lemma traceForm_apply_eq_zero_of_mem_lcs_of_mem_center {x y : L}\n    (hx : x ∈ lowerCentralSeries R L L 1) (hy : y ∈ LieAlgebra.center R L) :\n    traceForm R L M x y = 0 := by\n  apply traceForm_eq_zero_if_mem_lcs_of_mem_ucs R L M 1\n  · simpa using hx\n  · simpa using hy\n\n-- This is barely worth having: it usually follows from `LieModule.traceForm_eq_zero_of_isNilpotent`\n"}
{"name":"LieModule.traceForm_eq_zero_of_isTrivial","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieModule.IsTrivial L M\n⊢ Eq (LieModule.traceForm R L M) 0","decl":"@[simp] lemma traceForm_eq_zero_of_isTrivial [IsTrivial L M] :\n    traceForm R L M = 0 := by\n  ext x y\n  suffices φ x ∘ₗ φ y = 0 by simp [traceForm_apply_apply, this]\n  ext m\n  simp\n\n"}
{"name":"LieModule.eq_zero_of_mem_genWeightSpace_mem_posFitting","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nB : LinearMap.BilinForm R M\nhB : ∀ (x : L) (m n : M), Eq ((B (Bracket.bracket x m)) n) (Neg.neg ((B m) (Bracket.bracket x n)))\nm₀ m₁ : M\nhm₀ : Membership.mem (LieModule.genWeightSpace M 0) m₀\nhm₁ : Membership.mem (LieModule.posFittingComp R L M) m₁\n⊢ Eq ((B m₀) m₁) 0","decl":"/-- Given a bilinear form `B` on a representation `M` of a nilpotent Lie algebra `L`, if `B` is\ninvariant (in the sense that the action of `L` is skew-adjoint wrt `B`) then components of the\nFitting decomposition of `M` are orthogonal wrt `B`. -/\nlemma eq_zero_of_mem_genWeightSpace_mem_posFitting [LieRing.IsNilpotent L]\n    {B : LinearMap.BilinForm R M} (hB : ∀ (x : L) (m n : M), B ⁅x, m⁆ n = - B m ⁅x, n⁆)\n    {m₀ m₁ : M} (hm₀ : m₀ ∈ genWeightSpace M (0 : L → R)) (hm₁ : m₁ ∈ posFittingComp R L M) :\n    B m₀ m₁ = 0 := by\n  replace hB : ∀ x (k : ℕ) m n, B m ((φ x ^ k) n) = (- 1 : R) ^ k • B ((φ x ^ k) m) n := by\n    intro x k\n    induction k with\n    | zero => simp\n    | succ k ih =>\n    intro m n\n    replace hB : ∀ m, B m (φ x n) = (- 1 : R) • B (φ x m) n := by simp [hB]\n    have : (-1 : R) ^ k • (-1 : R) = (-1 : R) ^ (k + 1) := by rw [pow_succ (-1 : R), smul_eq_mul]\n    conv_lhs => rw [pow_succ, LinearMap.mul_eq_comp, LinearMap.comp_apply, ih, hB,\n      ← (φ x).comp_apply, ← LinearMap.mul_eq_comp, ← pow_succ', ← smul_assoc, this]\n  suffices ∀ (x : L) m, m ∈ posFittingCompOf R M x → B m₀ m = 0 by\n    apply LieSubmodule.iSup_induction _ hm₁ this (map_zero _)\n    aesop\n  clear hm₁ m₁; intro x m₁ hm₁\n  simp only [mem_genWeightSpace, Pi.zero_apply, zero_smul, sub_zero] at hm₀\n  obtain ⟨k, hk⟩ := hm₀ x\n  obtain ⟨m, rfl⟩ := (mem_posFittingCompOf R x m₁).mp hm₁ k\n  simp [hB, hk]\n\n"}
{"name":"LieModule.trace_toEnd_eq_zero_of_mem_lcs","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nk : Nat\nx : L\nhk : LE.le 1 k\nhx : Membership.mem (LieModule.lowerCentralSeries R L L k) x\n⊢ Eq ((LinearMap.trace R M) ((LieModule.toEnd R L M) x)) 0","decl":"lemma trace_toEnd_eq_zero_of_mem_lcs\n    {k : ℕ} {x : L} (hk : 1 ≤ k) (hx : x ∈ lowerCentralSeries R L L k) :\n    trace R _ (toEnd R L M x) = 0 := by\n  replace hx : x ∈ lowerCentralSeries R L L 1 := antitone_lowerCentralSeries _ _ _ hk hx\n  replace hx : x ∈ Submodule.span R {m | ∃ u v : L, ⁅u, v⁆ = m} := by\n    rw [lowerCentralSeries_succ, ← LieSubmodule.mem_toSubmodule,\n      LieSubmodule.lieIdeal_oper_eq_linear_span'] at hx\n    simpa using hx\n  refine Submodule.span_induction (p := fun x _ ↦ trace R _ (toEnd R L M x) = 0)\n    ?_ ?_ (fun u v _ _ hu hv ↦ ?_) (fun t u _ hu ↦ ?_) hx\n  · intro y ⟨u, v, huv⟩\n    simp [← huv]\n  · simp\n  · simp [hu, hv]\n  · simp [hu]\n\n"}
{"name":"LieModule.traceForm_lieSubalgebra_mk_left","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nL' : LieSubalgebra R L\nx : L\nhx : Membership.mem L' x\ny : Subtype fun x => Membership.mem L' x\n⊢ Eq (((LieModule.traceForm R (Subtype fun x => Membership.mem L' x) M) ⟨x, hx⟩) y) (((LieModule.traceForm R L M) x) ↑y)","decl":"@[simp]\nlemma traceForm_lieSubalgebra_mk_left (L' : LieSubalgebra R L) {x : L} (hx : x ∈ L') (y : L') :\n    traceForm R L' M ⟨x, hx⟩ y = traceForm R L M x y :=\n  rfl\n\n"}
{"name":"LieModule.traceForm_lieSubalgebra_mk_right","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nL' : LieSubalgebra R L\nx : Subtype fun x => Membership.mem L' x\ny : L\nhy : Membership.mem L' y\n⊢ Eq (((LieModule.traceForm R (Subtype fun x => Membership.mem L' x) M) x) ⟨y, hy⟩) (((LieModule.traceForm R L M) ↑x) y)","decl":"@[simp]\nlemma traceForm_lieSubalgebra_mk_right (L' : LieSubalgebra R L) {x : L'} {y : L} (hy : y ∈ L') :\n    traceForm R L' M x ⟨y, hy⟩ = traceForm R L M x y :=\n  rfl\n\n"}
{"name":"LieModule.traceForm_eq_sum_genWeightSpaceOf","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : LieRing L\ninst✝¹⁰ : LieAlgebra R L\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : Module R M\ninst✝⁷ : LieRingModule L M\ninst✝⁶ : LieModule R L M\ninst✝⁵ : LieRing.IsNilpotent L\ninst✝⁴ : IsDomain R\ninst✝³ : IsPrincipalIdealRing R\ninst✝² : NoZeroSMulDivisors R M\ninst✝¹ : IsNoetherian R M\ninst✝ : LieModule.IsTriangularizable R L M\nz : L\n⊢ Eq (LieModule.traceForm R L M) (⋯.toFinset.sum fun χ => LieModule.traceForm R L (Subtype fun x => Membership.mem (LieModule.genWeightSpaceOf M χ z) x))","decl":"lemma traceForm_eq_sum_genWeightSpaceOf\n    [NoZeroSMulDivisors R M] [IsNoetherian R M] [IsTriangularizable R L M] (z : L) :\n    traceForm R L M =\n    ∑ χ ∈ (finite_genWeightSpaceOf_ne_bot R L M z).toFinset,\n      traceForm R L (genWeightSpaceOf M χ z) := by\n  ext x y\n  have hxy : ∀ χ : R, MapsTo ((toEnd R L M x).comp (toEnd R L M y))\n      (genWeightSpaceOf M χ z) (genWeightSpaceOf M χ z) :=\n    fun χ m hm ↦ LieSubmodule.lie_mem _ <| LieSubmodule.lie_mem _ hm\n  have hfin : {χ : R | (genWeightSpaceOf M χ z : Submodule R M) ≠ ⊥}.Finite := by\n    convert finite_genWeightSpaceOf_ne_bot R L M z\n    exact LieSubmodule.toSubmodule_eq_bot (genWeightSpaceOf M _ _)\n  classical\n  have h := LieSubmodule.iSupIndep_iff_toSubmodule.mp <| iSupIndep_genWeightSpaceOf R L M z\n  have hds := DirectSum.isInternal_submodule_of_iSupIndep_of_iSup_eq_top h <| by\n    simp [← LieSubmodule.iSup_toSubmodule]\n  simp only [LinearMap.coeFn_sum, Finset.sum_apply, traceForm_apply_apply,\n    LinearMap.trace_eq_sum_trace_restrict' hds hfin hxy]\n  exact Finset.sum_congr (by simp) (fun χ _ ↦ rfl)\n\n-- In characteristic zero (or even just `LinearWeights R L M`) a stronger result holds (no\n-- `⊓ LieAlgebra.center R L`) TODO prove this using `LieModule.traceForm_eq_sum_finrank_nsmul_mul`.\n"}
{"name":"LieModule.lowerCentralSeries_one_inf_center_le_ker_traceForm","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : LieRing.IsNilpotent L\ninst✝³ : IsDomain R\ninst✝² : IsPrincipalIdealRing R\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\n⊢ LE.le (LieIdeal.toLieSubalgebra R L (Min.min (LieModule.lowerCentralSeries R L L 1) (LieAlgebra.center R L))).toSubmodule (LinearMap.ker (LieModule.traceForm R L M))","decl":"lemma lowerCentralSeries_one_inf_center_le_ker_traceForm [Module.Free R M] [Module.Finite R M] :\n    lowerCentralSeries R L L 1 ⊓ LieAlgebra.center R L ≤ LinearMap.ker (traceForm R L M) := by\n  /- Sketch of proof (due to Zassenhaus):\n\n  Let `z ∈ lowerCentralSeries R L L 1 ⊓ LieAlgebra.center R L` and `x : L`. We must show that\n  `trace (φ x ∘ φ z) = 0` where `φ z : End R M` indicates the action of `z` on `M` (and likewise\n  for `φ x`).\n\n  Because `z` belongs to the indicated intersection, it has two key properties:\n  (a) the trace of the action of `z` vanishes on any Lie module of `L`\n      (see `LieModule.trace_toEnd_eq_zero_of_mem_lcs`),\n  (b) `z` commutes with all elements of `L`.\n\n  If `φ x` were triangularizable, we could write `M` as a direct sum of generalized eigenspaces of\n  `φ x`. Because `L` is nilpotent these are all Lie submodules, thus Lie modules in their own right,\n  and thus by (a) above we learn that `trace (φ z) = 0` restricted to each generalized eigenspace.\n  Because `z` commutes with `x`, this forces `trace (φ x ∘ φ z) = 0` on each generalized eigenspace,\n  and so by summing the traces on each generalized eigenspace we learn the total trace is zero, as\n  required (see `LinearMap.trace_comp_eq_zero_of_commute_of_trace_restrict_eq_zero`).\n\n  To cater for the fact that `φ x` may not be triangularizable, we first extend the scalars from `R`\n  to `AlgebraicClosure (FractionRing R)` and argue using the action of `A ⊗ L` on `A ⊗ M`. -/\n  rintro z ⟨hz : z ∈ lowerCentralSeries R L L 1, hzc : z ∈ LieAlgebra.center R L⟩\n  ext x\n  rw [traceForm_apply_apply, LinearMap.zero_apply]\n  let A := AlgebraicClosure (FractionRing R)\n  suffices algebraMap R A (trace R _ ((φ z).comp (φ x))) = 0 by\n    have _i : NoZeroSMulDivisors R A := NoZeroSMulDivisors.trans R (FractionRing R) A\n    rw [← map_zero (algebraMap R A)] at this\n    exact NoZeroSMulDivisors.algebraMap_injective R A this\n  rw [← LinearMap.trace_baseChange, LinearMap.baseChange_comp, ← toEnd_baseChange,\n    ← toEnd_baseChange]\n  replace hz : 1 ⊗ₜ z ∈ lowerCentralSeries A (A ⊗[R] L) (A ⊗[R] L) 1 := by\n    simp only [lowerCentralSeries_succ, lowerCentralSeries_zero] at hz ⊢\n    rw [← LieSubmodule.baseChange_top, ← LieSubmodule.lie_baseChange]\n    exact Submodule.tmul_mem_baseChange_of_mem 1 hz\n  replace hzc : 1 ⊗ₜ[R] z ∈ LieAlgebra.center A (A ⊗[R] L) := by\n    simp only [mem_maxTrivSubmodule] at hzc ⊢\n    intro y\n    exact y.induction_on rfl (fun a u ↦ by simp [hzc u])\n      (fun u v hu hv ↦ by simp [A, hu, hv])\n  apply LinearMap.trace_comp_eq_zero_of_commute_of_trace_restrict_eq_zero\n  · exact IsTriangularizable.maxGenEigenspace_eq_top (1 ⊗ₜ[R] x)\n  · exact fun μ ↦ trace_toEnd_eq_zero_of_mem_lcs A (A ⊗[R] L)\n      (genWeightSpaceOf (A ⊗[R] M) μ ((1:A) ⊗ₜ[R] x)) (le_refl 1) hz\n  · exact commute_toEnd_of_mem_center_right (A ⊗[R] M) hzc (1 ⊗ₜ x)\n\n"}
{"name":"LieModule.isLieAbelian_of_ker_traceForm_eq_bot","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : LieRing.IsNilpotent L\ninst✝³ : IsDomain R\ninst✝² : IsPrincipalIdealRing R\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nh : Eq (LinearMap.ker (LieModule.traceForm R L M)) Bot.bot\n⊢ IsLieAbelian L","decl":"/-- A nilpotent Lie algebra with a representation whose trace form is non-singular is Abelian. -/\nlemma isLieAbelian_of_ker_traceForm_eq_bot [Module.Free R M] [Module.Finite R M]\n    (h : LinearMap.ker (traceForm R L M) = ⊥) : IsLieAbelian L := by\n  simpa only [← disjoint_lowerCentralSeries_maxTrivSubmodule_iff R L L, disjoint_iff_inf_le,\n    LieIdeal.toLieSubalgebra_toSubmodule, LieSubmodule.toSubmodule_eq_bot, h]\n    using lowerCentralSeries_one_inf_center_le_ker_traceForm R L M\n\n"}
{"name":"LieSubmodule.trace_eq_trace_restrict_of_le_idealizer","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\nN : LieSubmodule R L M\nI : LieIdeal R L\nh : LE.le I N.idealizer\nx y : L\nhy : Membership.mem I y\nhy' : optParam (∀ (m : M), Membership.mem N m → Membership.mem N ((LinearMap.comp ((LieModule.toEnd R L M) x) ((LieModule.toEnd R L M) y)) m)) ⋯\n⊢ Eq ((LinearMap.trace R M) (LinearMap.comp ((LieModule.toEnd R L M) x) ((LieModule.toEnd R L M) y))) ((LinearMap.trace R (Subtype fun x => Membership.mem N x)) ((LinearMap.comp ((LieModule.toEnd R L M) x) ((LieModule.toEnd R L M) y)).restrict hy'))","decl":"lemma trace_eq_trace_restrict_of_le_idealizer\n    (hy' : ∀ m ∈ N, (φ x ∘ₗ φ y) m ∈ N := fun m _ ↦ N.lie_mem (N.mem_idealizer.mp (h hy) m)) :\n    trace R M (φ x ∘ₗ φ y) = trace R N ((φ x ∘ₗ φ y).restrict hy') := by\n  suffices ∀ m, ⁅x, ⁅y, m⁆⁆ ∈ N by\n    have : (trace R { x // x ∈ N }) ((φ x ∘ₗ φ y).restrict _) = (trace R M) (φ x ∘ₗ φ y) :=\n      (φ x ∘ₗ φ y).trace_restrict_eq_of_forall_mem _ this\n    simp [this]\n  exact fun m ↦ N.lie_mem (h hy m)\n\n"}
{"name":"LieSubmodule.traceForm_eq_of_le_idealizer","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\nN : LieSubmodule R L M\nI : LieIdeal R L\nh : LE.le I N.idealizer\n⊢ Eq (LieModule.traceForm R (Subtype fun x => Membership.mem I x) (Subtype fun x => Membership.mem N x)) ((LieModule.traceForm R L M).restrict (LieIdeal.toLieSubalgebra R L I).toSubmodule)","decl":"include h in\nlemma traceForm_eq_of_le_idealizer :\n    traceForm R I N = (traceForm R L M).restrict I := by\n  ext ⟨x, hx⟩ ⟨y, hy⟩\n  change _ = trace R M (φ x ∘ₗ φ y)\n  rw [N.trace_eq_trace_restrict_of_le_idealizer I h x hy]\n  rfl\n\n"}
{"name":"LieSubmodule.traceForm_eq_zero_of_isTrivial","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : Module.Free R M\ninst✝³ : Module.Finite R M\ninst✝² : IsDomain R\ninst✝¹ : IsPrincipalIdealRing R\nN : LieSubmodule R L M\nI : LieIdeal R L\nh : LE.le I N.idealizer\nx y : L\nhy : Membership.mem I y\ninst✝ : LieModule.IsTrivial (Subtype fun x => Membership.mem I x) (Subtype fun x => Membership.mem N x)\n⊢ Eq ((LinearMap.trace R M) (LinearMap.comp ((LieModule.toEnd R L M) x) ((LieModule.toEnd R L M) y))) 0","decl":"include h hy in\n/-- Note that this result is slightly stronger than it might look at first glance: we only assume\nthat `N` is trivial over `I` rather than all of `L`. This means that it applies in the important\ncase of an Abelian ideal (which has `M = L` and `N = I`). -/\nlemma traceForm_eq_zero_of_isTrivial [LieModule.IsTrivial I N] :\n    trace R M (φ x ∘ₗ φ y) = 0 := by\n  let hy' : ∀ m ∈ N, (φ x ∘ₗ φ y) m ∈ N := fun m _ ↦ N.lie_mem (N.mem_idealizer.mp (h hy) m)\n  suffices (φ x ∘ₗ φ y).restrict hy' = 0 by\n    simp [this, N.trace_eq_trace_restrict_of_le_idealizer I h x hy]\n  ext (n : N)\n  suffices ⁅y, (n : M)⁆ = 0 by simp [this]\n  exact Submodule.coe_eq_zero.mpr (LieModule.IsTrivial.trivial (⟨y, hy⟩ : I) n)\n\n"}
{"name":"killingForm_apply_apply","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nx y : L\n⊢ Eq (((killingForm R L) x) y) ((LinearMap.trace R L) (LinearMap.comp ((LieAlgebra.ad R L) x) ((LieAlgebra.ad R L) y)))","decl":"open LieAlgebra in\nlemma killingForm_apply_apply (x y : L) : killingForm R L x y = trace R L (ad R L x ∘ₗ ad R L y) :=\n  LieModule.traceForm_apply_apply R L L x y\n\n"}
{"name":"killingForm_eq_zero_of_mem_zeroRoot_mem_posFitting","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nH : LieSubalgebra R L\ninst✝ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\nx₀ x₁ : L\nhx₀ : Membership.mem (LieAlgebra.zeroRootSubalgebra R L H) x₀\nhx₁ : Membership.mem (LieModule.posFittingComp R (Subtype fun x => Membership.mem H x) L) x₁\n⊢ Eq (((killingForm R L) x₀) x₁) 0","decl":"lemma killingForm_eq_zero_of_mem_zeroRoot_mem_posFitting\n    (H : LieSubalgebra R L) [LieRing.IsNilpotent H]\n    {x₀ x₁ : L}\n    (hx₀ : x₀ ∈ LieAlgebra.zeroRootSubalgebra R L H)\n    (hx₁ : x₁ ∈ LieModule.posFittingComp R H L) :\n    killingForm R L x₀ x₁ = 0 :=\n  LieModule.eq_zero_of_mem_genWeightSpace_mem_posFitting R H L\n    (fun x y z ↦ LieModule.traceForm_apply_lie_apply' R L L x y z) hx₀ hx₁\n\n"}
{"name":"LieIdeal.toSubmodule_killingCompl","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq (↑(LieIdeal.killingCompl R L I)) ((killingForm R L).orthogonal ↑I)","decl":"@[simp] lemma toSubmodule_killingCompl :\n    LieSubmodule.toSubmodule I.killingCompl = (killingForm R L).orthogonal I.toSubmodule :=\n  rfl\n\n"}
{"name":"LieIdeal.mem_killingCompl","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nx : L\n⊢ Iff (Membership.mem (LieIdeal.killingCompl R L I) x) (∀ (y : L), Membership.mem I y → Eq (((killingForm R L) y) x) 0)","decl":"@[simp] lemma mem_killingCompl {x : L} :\n    x ∈ I.killingCompl ↔ ∀ y ∈ I, killingForm R L y x = 0 := by\n  rfl\n\n"}
{"name":"LieIdeal.coe_killingCompl_top","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq (LieIdeal.toLieSubalgebra R L (LieIdeal.killingCompl R L Top.top)).toSubmodule (LinearMap.ker (killingForm R L))","decl":"lemma coe_killingCompl_top :\n    killingCompl R L ⊤ = LinearMap.ker (killingForm R L) := by\n  ext x\n  simp [LinearMap.ext_iff, LinearMap.BilinForm.IsOrtho, LieModule.traceForm_comm R L L x]\n\n"}
{"name":"LieIdeal.restrict_killingForm","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq ((killingForm R L).restrict (LieIdeal.toLieSubalgebra R L I).toSubmodule) (LieModule.traceForm R (Subtype fun x => Membership.mem I x) L)","decl":"lemma restrict_killingForm :\n    (killingForm R L).restrict I = LieModule.traceForm R I L :=\n  rfl\n\n"}
{"name":"LieIdeal.killingForm_eq","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\nI : LieIdeal R L\ninst✝³ : Module.Free R L\ninst✝² : Module.Finite R L\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\n⊢ Eq (killingForm R (Subtype fun x => Membership.mem I x)) ((killingForm R L).restrict (LieIdeal.toLieSubalgebra R L I).toSubmodule)","decl":"lemma killingForm_eq :\n    killingForm R I = (killingForm R L).restrict I :=\n  LieSubmodule.traceForm_eq_of_le_idealizer I I <| by simp\n\n"}
{"name":"LieIdeal.le_killingCompl_top_of_isLieAbelian","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"R : Type u_1\nL : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\nI : LieIdeal R L\ninst✝⁴ : Module.Free R L\ninst✝³ : Module.Finite R L\ninst✝² : IsDomain R\ninst✝¹ : IsPrincipalIdealRing R\ninst✝ : IsLieAbelian (Subtype fun x => Membership.mem I x)\n⊢ LE.le I (LieIdeal.killingCompl R L Top.top)","decl":"@[simp] lemma le_killingCompl_top_of_isLieAbelian [IsLieAbelian I] :\n    I ≤ LieIdeal.killingCompl R L ⊤ := by\n  intro x (hx : x ∈ I)\n  simp only [mem_killingCompl, LieSubmodule.mem_top, forall_true_left]\n  intro y\n  rw [LieModule.traceForm_apply_apply]\n  exact LieSubmodule.traceForm_eq_zero_of_isTrivial I I (by simp) _ hx\n\n"}
{"name":"LieModule.traceForm_eq_sum_finrank_nsmul_mul","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"K : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹⁰ : LieRing L\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : LieRingModule L M\ninst✝⁷ : Field K\ninst✝⁶ : LieAlgebra K L\ninst✝⁵ : Module K M\ninst✝⁴ : LieModule K L M\ninst✝³ : FiniteDimensional K M\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : LieModule.LinearWeights K L M\ninst✝ : LieModule.IsTriangularizable K L M\nx y : L\n⊢ Eq (((LieModule.traceForm K L M) x) y) (Finset.univ.sum fun χ => HSMul.hSMul (Module.finrank K (Subtype fun x => Membership.mem (LieModule.genWeightSpace M ⇑χ) x)) (HMul.hMul (χ x) (χ y)))","decl":"lemma traceForm_eq_sum_finrank_nsmul_mul (x y : L) :\n    traceForm K L M x y = ∑ χ : Weight K L M, finrank K (genWeightSpace M χ) • (χ x * χ y) := by\n  have hxy : ∀ χ : Weight K L M, MapsTo (toEnd K L M x ∘ₗ toEnd K L M y)\n      (genWeightSpace M χ) (genWeightSpace M χ) :=\n    fun χ m hm ↦ LieSubmodule.lie_mem _ <| LieSubmodule.lie_mem _ hm\n  classical\n  have hds := DirectSum.isInternal_submodule_of_iSupIndep_of_iSup_eq_top\n    (LieSubmodule.iSupIndep_iff_toSubmodule.mp <| iSupIndep_genWeightSpace' K L M)\n    (LieSubmodule.iSup_eq_top_iff_toSubmodule.mp <| iSup_genWeightSpace_eq_top' K L M)\n  simp_rw [traceForm_apply_apply, LinearMap.trace_eq_sum_trace_restrict hds hxy,\n    ← traceForm_genWeightSpace_eq K L M _ x y]\n  rfl\n\n"}
{"name":"LieModule.traceForm_eq_sum_finrank_nsmul","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"K : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹⁰ : LieRing L\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : LieRingModule L M\ninst✝⁷ : Field K\ninst✝⁶ : LieAlgebra K L\ninst✝⁵ : Module K M\ninst✝⁴ : LieModule K L M\ninst✝³ : FiniteDimensional K M\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : LieModule.LinearWeights K L M\ninst✝ : LieModule.IsTriangularizable K L M\n⊢ Eq (LieModule.traceForm K L M) (Finset.univ.sum fun χ => HSMul.hSMul (Module.finrank K (Subtype fun x => Membership.mem (LieModule.genWeightSpace M ⇑χ) x)) ((LieModule.Weight.toLinear K L M χ).smulRight (LieModule.Weight.toLinear K L M χ)))","decl":"/-- See also `LieModule.traceForm_eq_sum_finrank_nsmul'` for an expression omitting the zero\nweights. -/\nlemma traceForm_eq_sum_finrank_nsmul :\n    traceForm K L M = ∑ χ : Weight K L M, finrank K (genWeightSpace M χ) •\n      (χ : L →ₗ[K] K).smulRight (χ : L →ₗ[K] K) := by\n  ext\n  rw [traceForm_eq_sum_finrank_nsmul_mul, ← Finset.sum_attach]\n  simp\n\n"}
{"name":"LieModule.traceForm_eq_sum_finrank_nsmul'","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"K : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹⁰ : LieRing L\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : LieRingModule L M\ninst✝⁷ : Field K\ninst✝⁶ : LieAlgebra K L\ninst✝⁵ : Module K M\ninst✝⁴ : LieModule K L M\ninst✝³ : FiniteDimensional K M\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : LieModule.LinearWeights K L M\ninst✝ : LieModule.IsTriangularizable K L M\n⊢ Eq (LieModule.traceForm K L M) ((Finset.filter (fun χ => χ.IsNonZero) Finset.univ).sum fun χ => HSMul.hSMul (Module.finrank K (Subtype fun x => Membership.mem (LieModule.genWeightSpace M ⇑χ) x)) ((LieModule.Weight.toLinear K L M χ).smulRight (LieModule.Weight.toLinear K L M χ)))","decl":"/-- A variant of `LieModule.traceForm_eq_sum_finrank_nsmul` in which the sum is taken only over the\nnon-zero weights. -/\nlemma traceForm_eq_sum_finrank_nsmul' :\n    traceForm K L M = ∑ χ ∈ {χ : Weight K L M | χ.IsNonZero}, finrank K (genWeightSpace M χ) •\n      (χ : L →ₗ[K] K).smulRight (χ : L →ₗ[K] K) := by\n  classical\n  suffices ∑ χ ∈ {χ : Weight K L M | χ.IsZero}, finrank K (genWeightSpace M χ) •\n      (χ : L →ₗ[K] K).smulRight (χ : L →ₗ[K] K) = 0 by\n    rw [traceForm_eq_sum_finrank_nsmul,\n      ← Finset.sum_filter_add_sum_filter_not (p := fun χ : Weight K L M ↦ χ.IsNonZero)]\n    simp [this]\n  refine Finset.sum_eq_zero fun χ hχ ↦ ?_\n  replace hχ : (χ : L →ₗ[K] K) = 0 := by simpa [← Weight.coe_toLinear_eq_zero_iff] using hχ\n  simp [hχ]\n\n-- The reverse inclusion should also hold: TODO prove this!\n"}
{"name":"LieModule.range_traceForm_le_span_weight","module":"Mathlib.Algebra.Lie.TraceForm","initialProofState":"K : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹⁰ : LieRing L\ninst✝⁹ : AddCommGroup M\ninst✝⁸ : LieRingModule L M\ninst✝⁷ : Field K\ninst✝⁶ : LieAlgebra K L\ninst✝⁵ : Module K M\ninst✝⁴ : LieModule K L M\ninst✝³ : FiniteDimensional K M\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : LieModule.LinearWeights K L M\ninst✝ : LieModule.IsTriangularizable K L M\n⊢ LE.le (LinearMap.range (LieModule.traceForm K L M)) (Submodule.span K (Set.range (LieModule.Weight.toLinear K L M)))","decl":"lemma range_traceForm_le_span_weight :\n    LinearMap.range (traceForm K L M) ≤ span K (range (Weight.toLinear K L M)) := by\n  rintro - ⟨x, rfl⟩\n  rw [LieModule.traceForm_eq_sum_finrank_nsmul, LinearMap.coeFn_sum, Finset.sum_apply]\n  refine Submodule.sum_mem _ fun χ _ ↦ ?_\n  simp_rw [LinearMap.smul_apply, LinearMap.coe_smulRight, Weight.toLinear_apply,\n    ← Nat.cast_smul_eq_nsmul K]\n  exact Submodule.smul_mem _ _ <| Submodule.smul_mem _ _ <| subset_span <| mem_range_self χ\n\n"}
