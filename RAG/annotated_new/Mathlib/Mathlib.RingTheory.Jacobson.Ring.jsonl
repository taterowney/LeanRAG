{"name":"IsJacobsonRing.out'","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_3\ninst✝ : CommRing R\nself : IsJacobsonRing R\nI : Ideal R\na✝ : I.IsRadical\n⊢ Eq I.jacobson I","decl":"/-- A ring is a Jacobson ring if for every radical ideal `I`,\n the Jacobson radical of `I` is equal to `I`.\n See `isJacobsonRing_iff_prime_eq` and `isJacobsonRing_iff_sInf_maximal`\n for equivalent definitions. -/\nclass IsJacobsonRing (R : Type*) [CommRing R] : Prop where\n  out' : ∀ I : Ideal R, I.IsRadical → I.jacobson = I\n\n"}
{"name":"isJacobsonRing_iff","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Iff (IsJacobsonRing R) (∀ (I : Ideal R), I.IsRadical → Eq I.jacobson I)","decl":"theorem isJacobsonRing_iff {R} [CommRing R] :\n    IsJacobsonRing R ↔ ∀ I : Ideal R, I.IsRadical → I.jacobson = I :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"IsJacobsonRing.out","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na✝¹ : IsJacobsonRing R\nI : Ideal R\na✝ : I.IsRadical\n⊢ Eq I.jacobson I","decl":"theorem IsJacobsonRing.out {R} [CommRing R] :\n    IsJacobsonRing R → ∀ {I : Ideal R}, I.IsRadical → I.jacobson = I :=\n  isJacobsonRing_iff.1\n\n"}
{"name":"isJacobsonRing_iff_prime_eq","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Iff (IsJacobsonRing R) (∀ (P : Ideal R), P.IsPrime → Eq P.jacobson P)","decl":"/-- A ring is a Jacobson ring if and only if for all prime ideals `P`,\n the Jacobson radical of `P` is equal to `P`. -/\ntheorem isJacobsonRing_iff_prime_eq :\n    IsJacobsonRing R ↔ ∀ P : Ideal R, IsPrime P → P.jacobson = P := by\n  refine isJacobsonRing_iff.trans ⟨fun h I hI => h I hI.isRadical, ?_⟩\n  refine fun h I hI ↦ le_antisymm (fun x hx ↦ ?_) (fun x hx ↦ mem_sInf.mpr fun _ hJ ↦ hJ.left hx)\n  rw [← hI.radical, radical_eq_sInf I, mem_sInf]\n  intro P hP\n  rw [Set.mem_setOf_eq] at hP\n  erw [mem_sInf] at hx\n  erw [← h P hP.right, mem_sInf]\n  exact fun J hJ => hx ⟨le_trans hP.left hJ.left, hJ.right⟩\n\n"}
{"name":"isJacobsonRing_iff_sInf_maximal","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Iff (IsJacobsonRing R) (∀ {I : Ideal R}, I.IsPrime → Exists fun M => And (∀ (J : Ideal R), Membership.mem M J → Or J.IsMaximal (Eq J Top.top)) (Eq I (InfSet.sInf M)))","decl":"/-- A ring `R` is Jacobson if and only if for every prime ideal `I`,\n `I` can be written as the infimum of some collection of maximal ideals.\n Allowing ⊤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. -/\ntheorem isJacobsonRing_iff_sInf_maximal : IsJacobsonRing R ↔ ∀ {I : Ideal R}, I.IsPrime →\n    ∃ M : Set (Ideal R), (∀ J ∈ M, IsMaximal J ∨ J = ⊤) ∧ I = sInf M :=\n  ⟨fun H _I h => eq_jacobson_iff_sInf_maximal.1 (H.out h.isRadical), fun H =>\n    isJacobsonRing_iff_prime_eq.2 fun _P hP => eq_jacobson_iff_sInf_maximal.2 (H hP)⟩\n\n"}
{"name":"isJacobsonRing_iff_sInf_maximal'","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Iff (IsJacobsonRing R) (∀ {I : Ideal R}, I.IsPrime → Exists fun M => And (∀ (J : Ideal R), Membership.mem M J → ∀ (K : Ideal R), LT.lt J K → Eq K Top.top) (Eq I (InfSet.sInf M)))","decl":"/-- A variant of `isJacobsonRing_iff_sInf_maximal` with a different spelling of \"maximal or `⊤`\". -/\ntheorem isJacobsonRing_iff_sInf_maximal' : IsJacobsonRing R ↔ ∀ {I : Ideal R}, I.IsPrime →\n    ∃ M : Set (Ideal R), (∀ J ∈ M, ∀ (K : Ideal R), J < K → K = ⊤) ∧ I = sInf M :=\n  ⟨fun H _I h => eq_jacobson_iff_sInf_maximal'.1 (H.out h.isRadical), fun H =>\n    isJacobsonRing_iff_prime_eq.2 fun _P hP => eq_jacobson_iff_sInf_maximal'.2 (H hP)⟩\n\n"}
{"name":"Ideal.radical_eq_jacobson","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nH : IsJacobsonRing R\nI : Ideal R\n⊢ Eq I.radical I.jacobson","decl":"theorem Ideal.radical_eq_jacobson [H : IsJacobsonRing R] (I : Ideal R) : I.radical = I.jacobson :=\n  le_antisymm (le_sInf fun _J ⟨hJ, hJ_max⟩ => (IsPrime.radical_le_iff hJ_max.isPrime).mpr hJ)\n    (H.out (radical_isRadical I) ▸ jacobson_mono le_radical)\n\n"}
{"name":"instIsJacobsonRingOfIsArtinianRing","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\n⊢ IsJacobsonRing R","decl":"instance (priority := 100) [IsArtinianRing R] : IsJacobsonRing R :=\n  isJacobsonRing_iff_prime_eq.mpr fun P _ ↦\n    jacobson_eq_self_of_isMaximal (H := IsArtinianRing.isMaximal_of_isPrime P)\n\n"}
{"name":"isJacobsonRing_of_surjective","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nH : IsJacobsonRing R\na✝ : Exists fun f => Function.Surjective ⇑f\n⊢ IsJacobsonRing S","decl":"theorem isJacobsonRing_of_surjective [H : IsJacobsonRing R] :\n    (∃ f : R →+* S, Function.Surjective ↑f) → IsJacobsonRing S := by\n  rintro ⟨f, hf⟩\n  rw [isJacobsonRing_iff_sInf_maximal]\n  intro p hp\n  use map f '' { J : Ideal R | comap f p ≤ J ∧ J.IsMaximal }\n  use fun j ⟨J, hJ, hmap⟩ => hmap ▸ (map_eq_top_or_isMaximal_of_surjective f hf hJ.right).symm\n  have : p = map f (comap f p).jacobson :=\n    (IsJacobsonRing.out' _ <| hp.isRadical.comap f).symm ▸ (map_comap_of_surjective f hf p).symm\n  exact this.trans (map_sInf hf fun J ⟨hJ, _⟩ => le_trans (Ideal.ker_le_comap f) hJ)\n\n"}
{"name":"isJacobsonRing_quotient","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nI : Ideal R\ninst✝ : IsJacobsonRing R\n⊢ IsJacobsonRing (HasQuotient.Quotient R I)","decl":"instance (priority := 100) isJacobsonRing_quotient [IsJacobsonRing R] : IsJacobsonRing (R ⧸ I) :=\n  isJacobsonRing_of_surjective ⟨Ideal.Quotient.mk I, by\n    rintro ⟨x⟩\n    use x\n    rfl⟩\n\n"}
{"name":"isJacobsonRing_iso","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\ne : RingEquiv R S\n⊢ Iff (IsJacobsonRing R) (IsJacobsonRing S)","decl":"theorem isJacobsonRing_iso (e : R ≃+* S) : IsJacobsonRing R ↔ IsJacobsonRing S :=\n  ⟨fun h => @isJacobsonRing_of_surjective _ _ _ _ h ⟨(e : R →+* S), e.surjective⟩, fun h =>\n    @isJacobsonRing_of_surjective _ _ _ _ h ⟨(e.symm : S →+* R), e.symm.surjective⟩⟩\n\n"}
{"name":"isJacobsonRing_of_isIntegral","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : Algebra.IsIntegral R S\ninst✝ : IsJacobsonRing R\n⊢ IsJacobsonRing S","decl":"theorem isJacobsonRing_of_isIntegral [Algebra R S] [Algebra.IsIntegral R S] [IsJacobsonRing R] :\n    IsJacobsonRing S := by\n  rw [isJacobsonRing_iff_prime_eq]\n  intro P hP\n  by_cases hP_top : comap (algebraMap R S) P = ⊤\n  · simp [comap_eq_top_iff.1 hP_top]\n  · haveI : Nontrivial (R ⧸ comap (algebraMap R S) P) := Quotient.nontrivial hP_top\n    rw [jacobson_eq_iff_jacobson_quotient_eq_bot]\n    refine eq_bot_of_comap_eq_bot (R := R ⧸ comap (algebraMap R S) P) ?_\n    rw [eq_bot_iff, ← jacobson_eq_iff_jacobson_quotient_eq_bot.1\n      ((isJacobsonRing_iff_prime_eq.1 ‹_›) (comap (algebraMap R S) P) (comap_isPrime _ _)),\n      comap_jacobson]\n    refine sInf_le_sInf fun J hJ => ?_\n    simp only [true_and, Set.mem_image, bot_le, Set.mem_setOf_eq]\n    have : J.IsMaximal := by simpa using hJ\n    exact exists_ideal_over_maximal_of_isIntegral J\n      (comap_bot_le_of_injective _ algebraMap_quotient_injective)\n\n"}
{"name":"isJacobsonRing_of_isIntegral'","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\nf : RingHom R S\nhf : f.IsIntegral\ninst✝ : IsJacobsonRing R\n⊢ IsJacobsonRing S","decl":"/-- A variant of `isJacobsonRing_of_isIntegral` that takes `RingHom.IsIntegral` instead. -/\ntheorem isJacobsonRing_of_isIntegral' (f : R →+* S) (hf : f.IsIntegral) [IsJacobsonRing R] :\n    IsJacobsonRing S :=\n  let _ : Algebra R S := f.toAlgebra\n  have : Algebra.IsIntegral R S := ⟨hf⟩\n  isJacobsonRing_of_isIntegral (R := R)\n\n"}
{"name":"IsLocalization.isMaximal_iff_isMaximal_disjoint","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ny : R\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization.Away y S\nH : IsJacobsonRing R\nJ : Ideal S\n⊢ Iff J.IsMaximal (And (Ideal.comap (algebraMap R S) J).IsMaximal (Not (Membership.mem (Ideal.comap (algebraMap R S) J) y)))","decl":"/-- If `R` is a Jacobson ring, then maximal ideals in the localization at `y`\ncorrespond to maximal ideals in the original ring `R` that don't contain `y`.\nThis lemma gives the correspondence in the particular case of an ideal and its comap.\nSee `le_relIso_of_maximal` for the more general relation isomorphism -/\ntheorem IsLocalization.isMaximal_iff_isMaximal_disjoint [H : IsJacobsonRing R] (J : Ideal S) :\n    J.IsMaximal ↔ (comap (algebraMap R S) J).IsMaximal ∧ y ∉ Ideal.comap (algebraMap R S) J := by\n  constructor\n  · refine fun h => ⟨?_, fun hy =>\n      h.ne_top (Ideal.eq_top_of_isUnit_mem _ hy (map_units _ ⟨y, Submonoid.mem_powers _⟩))⟩\n    have hJ : J.IsPrime := IsMaximal.isPrime h\n    rw [isPrime_iff_isPrime_disjoint (Submonoid.powers y)] at hJ\n    have : y ∉ (comap (algebraMap R S) J).1 := Set.disjoint_left.1 hJ.right (Submonoid.mem_powers _)\n    erw [← H.out hJ.left.isRadical, Ideal.mem_sInf] at this\n    push_neg at this\n    rcases this with ⟨I, hI, hI'⟩\n    convert hI.right\n    by_cases hJ : J = I.map (algebraMap R S)\n    · rw [hJ, comap_map_of_isPrime_disjoint (powers y) S I (IsMaximal.isPrime hI.right)]\n      rwa [disjoint_powers_iff_not_mem y hI.right.isPrime.isRadical]\n    · have hI_p : (I.map (algebraMap R S)).IsPrime := by\n        refine isPrime_of_isPrime_disjoint (powers y) _ I hI.right.isPrime ?_\n        rwa [disjoint_powers_iff_not_mem y hI.right.isPrime.isRadical]\n      have : J ≤ I.map (algebraMap R S) := map_comap (Submonoid.powers y) S J ▸ map_mono hI.left\n      exact absurd (h.1.2 _ (lt_of_le_of_ne this hJ)) hI_p.1\n  · refine fun h => ⟨⟨fun hJ => h.1.ne_top (eq_top_iff.2 ?_), fun I hI => ?_⟩⟩\n    · rwa [eq_top_iff, ← (IsLocalization.orderEmbedding (powers y) S).le_iff_le] at hJ\n    · have := congr_arg (Ideal.map (algebraMap R S)) (h.1.1.2 _ ⟨comap_mono (le_of_lt hI), ?_⟩)\n      · rwa [map_comap (powers y) S I, Ideal.map_top] at this\n      refine fun hI' => hI.right ?_\n      rw [← map_comap (powers y) S I, ← map_comap (powers y) S J]\n      exact map_mono hI'\n\n"}
{"name":"IsLocalization.isMaximal_of_isMaximal_disjoint","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ny : R\ninst✝² : Algebra R S\ninst✝¹ : IsLocalization.Away y S\ninst✝ : IsJacobsonRing R\nI : Ideal R\nhI : I.IsMaximal\nhy : Not (Membership.mem I y)\n⊢ (Ideal.map (algebraMap R S) I).IsMaximal","decl":"/-- If `R` is a Jacobson ring, then maximal ideals in the localization at `y`\ncorrespond to maximal ideals in the original ring `R` that don't contain `y`.\nThis lemma gives the correspondence in the particular case of an ideal and its map.\nSee `le_relIso_of_maximal` for the more general statement, and the reverse of this implication -/\ntheorem IsLocalization.isMaximal_of_isMaximal_disjoint\n    [IsJacobsonRing R] (I : Ideal R) (hI : I.IsMaximal)\n    (hy : y ∉ I) : (I.map (algebraMap R S)).IsMaximal := by\n  rw [isMaximal_iff_isMaximal_disjoint S y,\n    comap_map_of_isPrime_disjoint (powers y) S I (IsMaximal.isPrime hI)\n      ((disjoint_powers_iff_not_mem y hI.isPrime.isRadical).2 hy)]\n  exact ⟨hI, hy⟩\n\n"}
{"name":"isJacobsonRing_localization","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ny : R\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization.Away y S\nH : IsJacobsonRing R\n⊢ IsJacobsonRing S","decl":"include y in\n/-- If `S` is the localization of the Jacobson ring `R` at the submonoid generated by `y : R`, then\n`S` is Jacobson. -/\ntheorem isJacobsonRing_localization [H : IsJacobsonRing R] : IsJacobsonRing S := by\n  rw [isJacobsonRing_iff_prime_eq]\n  refine fun P' hP' => le_antisymm ?_ le_jacobson\n  obtain ⟨hP', hPM⟩ := (IsLocalization.isPrime_iff_isPrime_disjoint (powers y) S P').mp hP'\n  have hP := H.out hP'.isRadical\n  refine (IsLocalization.map_comap (powers y) S P'.jacobson).ge.trans\n    ((map_mono ?_).trans (IsLocalization.map_comap (powers y) S P').le)\n  have : sInf { I : Ideal R | comap (algebraMap R S) P' ≤ I ∧ I.IsMaximal ∧ y ∉ I } ≤\n      comap (algebraMap R S) P' := by\n    intro x hx\n    have hxy : x * y ∈ (comap (algebraMap R S) P').jacobson := by\n      rw [Ideal.jacobson, Ideal.mem_sInf]\n      intro J hJ\n      by_cases h : y ∈ J\n      · exact J.mul_mem_left x h\n      · exact J.mul_mem_right y ((mem_sInf.1 hx) ⟨hJ.left, ⟨hJ.right, h⟩⟩)\n    rw [hP] at hxy\n    cases' hP'.mem_or_mem hxy with hxy hxy\n    · exact hxy\n    · exact (hPM.le_bot ⟨Submonoid.mem_powers _, hxy⟩).elim\n  refine le_trans ?_ this\n  rw [Ideal.jacobson, comap_sInf', sInf_eq_iInf]\n  refine iInf_le_iInf_of_subset fun I hI => ⟨map (algebraMap R S) I, ⟨?_, ?_⟩⟩\n  · exact ⟨le_trans (le_of_eq (IsLocalization.map_comap (powers y) S P').symm) (map_mono hI.1),\n      isMaximal_of_isMaximal_disjoint y _ hI.2.1 hI.2.2⟩\n  · exact IsLocalization.comap_map_of_isPrime_disjoint _ S I (IsMaximal.isPrime hI.2.1)\n      ((disjoint_powers_iff_not_mem y hI.2.1.isPrime.isRadical).2 hI.2.2)\n\n"}
{"name":"Polynomial.Subring.mem_closure_image_of","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"S : Type u_1\nT : Type u_2\ninst✝¹ : CommRing S\ninst✝ : CommRing T\ng : RingHom S T\nu : Set S\nx : S\nhx : Membership.mem (Subring.closure u) x\n⊢ Membership.mem (Subring.closure (Set.image (⇑g) u)) (g x)","decl":"lemma Subring.mem_closure_image_of {S T : Type*} [CommRing S] [CommRing T] (g : S →+* T)\n    (u : Set S) (x : S) (hx : x ∈ Subring.closure u) : g x ∈ Subring.closure (g '' u) := by\n  rw [Subring.mem_closure] at hx ⊢\n  intro T₁ h₁\n  rw [← Subring.mem_comap]\n  apply hx\n  simp only [Subring.coe_comap, ← Set.image_subset_iff, SetLike.mem_coe]\n  exact h₁\n\n-- Porting note: move to better place\n"}
{"name":"Polynomial.mem_closure_X_union_C","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝ : Ring R\np : Polynomial R\n⊢ Membership.mem (Subring.closure (Insert.insert Polynomial.X (setOf fun f => LE.le f.degree 0))) p","decl":"lemma mem_closure_X_union_C {R : Type*} [Ring R] (p : R[X]) :\n    p ∈ Subring.closure (insert X {f | f.degree ≤ 0} : Set R[X]) := by\n  refine Polynomial.induction_on p ?_ ?_ ?_\n  · intro r\n    apply Subring.subset_closure\n    apply Set.mem_insert_of_mem\n    exact degree_C_le\n  · intros p1 p2 h1 h2\n    exact Subring.add_mem _ h1 h2\n  · intros n r hr\n    rw [pow_succ, ← mul_assoc]\n    apply Subring.mul_mem _ hr\n    apply Subring.subset_closure\n    apply Set.mem_insert\n\n"}
{"name":"Polynomial.isIntegral_isLocalization_polynomial_quotient","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nRₘ : Type u_3\nSₘ : Type u_4\ninst✝⁵ : CommRing Rₘ\ninst✝⁴ : CommRing Sₘ\nP : Ideal (Polynomial R)\npX : Polynomial R\nhpX : Membership.mem P pX\ninst✝³ : Algebra (HasQuotient.Quotient R (Ideal.comap Polynomial.C P)) Rₘ\ninst✝² : IsLocalization.Away (Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)) pX).leadingCoeff Rₘ\ninst✝¹ : Algebra (HasQuotient.Quotient (Polynomial R) P) Sₘ\ninst✝ : IsLocalization (Submonoid.map (Ideal.quotientMap P Polynomial.C ⋯) (Submonoid.powers (Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)) pX).leadingCoeff)) Sₘ\n⊢ (IsLocalization.map Sₘ (Ideal.quotientMap P Polynomial.C ⋯) ⋯).IsIntegral","decl":"/-- If `I` is a prime ideal of `R[X]` and `pX ∈ I` is a non-constant polynomial,\n  then the map `R →+* R[x]/I` descends to an integral map when localizing at `pX.leadingCoeff`.\n  In particular `X` is integral because it satisfies `pX`, and constants are trivially integral,\n  so integrality of the entire extension follows by closure under addition and multiplication. -/\ntheorem isIntegral_isLocalization_polynomial_quotient\n    (P : Ideal R[X]) (pX : R[X]) (hpX : pX ∈ P) [Algebra (R ⧸ P.comap (C : R →+* R[X])) Rₘ]\n    [IsLocalization.Away (pX.map (Ideal.Quotient.mk (P.comap (C : R →+* R[X])))).leadingCoeff Rₘ]\n    [Algebra (R[X] ⧸ P) Sₘ] [IsLocalization ((Submonoid.powers (pX.map (Ideal.Quotient.mk (P.comap\n      (C : R →+* R[X])))).leadingCoeff).map (quotientMap P C le_rfl) : Submonoid (R[X] ⧸ P)) Sₘ] :\n    (IsLocalization.map Sₘ (quotientMap P C le_rfl) (Submonoid.powers (pX.map (Ideal.Quotient.mk\n      (P.comap (C : R →+* R[X])))).leadingCoeff).le_comap_map : Rₘ →+* Sₘ).IsIntegral := by\n  let P' : Ideal R := P.comap C\n  let M : Submonoid (R ⧸ P') :=\n    Submonoid.powers (pX.map (Ideal.Quotient.mk (P.comap (C : R →+* R[X])))).leadingCoeff\n  let M' : Submonoid (R[X] ⧸ P) :=\n    (Submonoid.powers (pX.map (Ideal.Quotient.mk (P.comap (C : R →+* R[X])))).leadingCoeff).map\n      (quotientMap P C le_rfl)\n  let φ : R ⧸ P' →+* R[X] ⧸ P := quotientMap P C le_rfl\n  let φ' : Rₘ →+* Sₘ := IsLocalization.map Sₘ φ M.le_comap_map\n  have hφ' : φ.comp (Ideal.Quotient.mk P') = (Ideal.Quotient.mk P).comp C := rfl\n  intro p\n  obtain ⟨⟨p', ⟨q, hq⟩⟩, hp⟩ := IsLocalization.surj M' p\n  suffices φ'.IsIntegralElem (algebraMap (R[X] ⧸ P) Sₘ p') by\n    obtain ⟨q', hq', rfl⟩ := hq\n    obtain ⟨q'', hq''⟩ := isUnit_iff_exists_inv'.1 (IsLocalization.map_units Rₘ (⟨q', hq'⟩ : M))\n    refine (hp.symm ▸ this).of_mul_unit φ' p (algebraMap (R[X] ⧸ P) Sₘ (φ q')) q'' ?_\n    rw [← φ'.map_one, ← congr_arg φ' hq'', φ'.map_mul, ← φ'.comp_apply]\n    simp only [φ', IsLocalization.map_comp _]\n    rw [RingHom.comp_apply]\n  dsimp at hp\n  refine @IsIntegral.of_mem_closure'' Rₘ _ Sₘ _ φ'\n    ((algebraMap (R[X] ⧸ P) Sₘ).comp (Ideal.Quotient.mk P) '' insert X { p | p.degree ≤ 0 }) ?_\n    ((algebraMap (R[X] ⧸ P) Sₘ) p') ?_\n  · rintro x ⟨p, hp, rfl⟩\n    simp only [Set.mem_insert_iff] at hp\n    cases' hp with hy hy\n    · rw [hy]\n      refine φ.isIntegralElem_localization_at_leadingCoeff ((Ideal.Quotient.mk P) X)\n        (pX.map (Ideal.Quotient.mk P')) ?_ M ?_\n      · rwa [eval₂_map, hφ', ← hom_eval₂, Quotient.eq_zero_iff_mem, eval₂_C_X]\n      · use 1\n        simp only [P', pow_one]\n    · rw [Set.mem_setOf_eq, degree_le_zero_iff] at hy\n      -- Porting note: was `refine' hy.symm ▸`\n      -- `⟨X - C (algebraMap _ _ ((Quotient.mk P') (p.coeff 0))), monic_X_sub_C _, _⟩`\n      rw [hy]\n      use X - C (algebraMap (R ⧸ P') Rₘ ((Ideal.Quotient.mk P') (p.coeff 0)))\n      constructor\n      · apply monic_X_sub_C\n      · simp only [eval₂_sub, eval₂_X, eval₂_C]\n        rw [sub_eq_zero, ← φ'.comp_apply]\n        simp only [φ', IsLocalization.map_comp _]\n        rfl\n  · obtain ⟨p, rfl⟩ := Ideal.Quotient.mk_surjective p'\n    rw [← RingHom.comp_apply]\n    apply Subring.mem_closure_image_of\n    apply Polynomial.mem_closure_X_union_C\n\n"}
{"name":"Polynomial.jacobson_bot_of_integral_localization","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"S : Type u_2\ninst✝¹⁰ : CommRing S\ninst✝⁹ : IsDomain S\nR : Type u_5\ninst✝⁸ : CommRing R\ninst✝⁷ : IsDomain R\ninst✝⁶ : IsJacobsonRing R\nRₘ : Type u_6\nSₘ : Type u_7\ninst✝⁵ : CommRing Rₘ\ninst✝⁴ : CommRing Sₘ\nφ : RingHom R S\nhφ : Function.Injective ⇑φ\nx : R\nhx : Ne x 0\ninst✝³ : Algebra R Rₘ\ninst✝² : IsLocalization.Away x Rₘ\ninst✝¹ : Algebra S Sₘ\ninst✝ : IsLocalization (Submonoid.map φ (Submonoid.powers x)) Sₘ\nhφ' : (IsLocalization.map Sₘ φ ⋯).IsIntegral\n⊢ Eq Bot.bot.jacobson Bot.bot","decl":"/-- If `f : R → S` descends to an integral map in the localization at `x`,\n  and `R` is a Jacobson ring, then the intersection of all maximal ideals in `S` is trivial -/\ntheorem jacobson_bot_of_integral_localization\n    {R : Type*} [CommRing R] [IsDomain R] [IsJacobsonRing R]\n    (Rₘ Sₘ : Type*) [CommRing Rₘ] [CommRing Sₘ] (φ : R →+* S) (hφ : Function.Injective ↑φ) (x : R)\n    (hx : x ≠ 0) [Algebra R Rₘ] [IsLocalization.Away x Rₘ] [Algebra S Sₘ]\n    [IsLocalization ((Submonoid.powers x).map φ : Submonoid S) Sₘ]\n    (hφ' :\n      RingHom.IsIntegral (IsLocalization.map Sₘ φ (Submonoid.powers x).le_comap_map : Rₘ →+* Sₘ)) :\n    (⊥ : Ideal S).jacobson = (⊥ : Ideal S) := by\n  have hM : ((Submonoid.powers x).map φ : Submonoid S) ≤ nonZeroDivisors S :=\n    map_le_nonZeroDivisors_of_injective φ hφ (powers_le_nonZeroDivisors_of_noZeroDivisors hx)\n  letI : IsDomain Sₘ := IsLocalization.isDomain_of_le_nonZeroDivisors _ hM\n  let φ' : Rₘ →+* Sₘ := IsLocalization.map _ φ (Submonoid.powers x).le_comap_map\n  suffices ∀ I : Ideal Sₘ, I.IsMaximal → (I.comap (algebraMap S Sₘ)).IsMaximal by\n    have hϕ' : comap (algebraMap S Sₘ) (⊥ : Ideal Sₘ) = (⊥ : Ideal S) := by\n      rw [← RingHom.ker_eq_comap_bot, ← RingHom.injective_iff_ker_eq_bot]\n      exact IsLocalization.injective Sₘ hM\n    have hRₘ : IsJacobsonRing Rₘ := isJacobsonRing_localization x\n    have hSₘ : IsJacobsonRing Sₘ := isJacobsonRing_of_isIntegral' φ' hφ'\n    refine eq_bot_iff.mpr (le_trans ?_ (le_of_eq hϕ'))\n    rw [← hSₘ.out isRadical_bot_of_noZeroDivisors, comap_jacobson]\n    exact sInf_le_sInf fun j hj => ⟨bot_le,\n      let ⟨J, hJ⟩ := hj\n      hJ.2 ▸ this J hJ.1.2⟩\n  intro I hI\n  -- Remainder of the proof is pulling and pushing ideals around the square and the quotient square\n  haveI : (I.comap (algebraMap S Sₘ)).IsPrime := comap_isPrime _ I\n  haveI : (I.comap φ').IsPrime := comap_isPrime φ' I\n  haveI : (⊥ : Ideal (S ⧸ I.comap (algebraMap S Sₘ))).IsPrime := bot_prime\n  have hcomm : φ'.comp (algebraMap R Rₘ) = (algebraMap S Sₘ).comp φ := IsLocalization.map_comp _\n  let f := quotientMap (I.comap (algebraMap S Sₘ)) φ le_rfl\n  let g := quotientMap I (algebraMap S Sₘ) le_rfl\n  have := isMaximal_comap_of_isIntegral_of_isMaximal' φ' hφ' I\n  have := ((IsLocalization.isMaximal_iff_isMaximal_disjoint Rₘ x _).1 this).left\n  have : ((I.comap (algebraMap S Sₘ)).comap φ).IsMaximal := by\n    rwa [comap_comap, hcomm, ← comap_comap] at this\n  rw [← bot_quotient_isMaximal_iff] at this ⊢\n  refine isMaximal_of_isIntegral_of_isMaximal_comap' f ?_ ⊥\n    ((eq_bot_iff.2 (comap_bot_le_of_injective f quotientMap_injective)).symm ▸ this)\n  exact RingHom.IsIntegral.tower_bot f g quotientMap_injective\n    ((comp_quotientMap_eq_of_comp_eq hcomm I).symm ▸\n      (RingHom.isIntegral_of_surjective _\n        (IsLocalization.surjective_quotientMap_of_maximal_of_localization (Submonoid.powers x) Rₘ\n          (by rwa [comap_comap, hcomm, ← bot_quotient_isMaximal_iff]))).trans _ _ (hφ'.quotient _))\n\n"}
{"name":"Polynomial.isJacobsonRing_polynomial_of_isJacobsonRing","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nhR : IsJacobsonRing R\n⊢ IsJacobsonRing (Polynomial R)","decl":"theorem isJacobsonRing_polynomial_of_isJacobsonRing (hR : IsJacobsonRing R) :\n    IsJacobsonRing R[X] := by\n  rw [isJacobsonRing_iff_prime_eq]\n  intro I hI\n  let R' : Subring (R[X] ⧸ I) := ((Ideal.Quotient.mk I).comp C).range\n  let i : R →+* R' := ((Ideal.Quotient.mk I).comp C).rangeRestrict\n  have hi : Function.Surjective ↑i := ((Ideal.Quotient.mk I).comp C).rangeRestrict_surjective\n  have hi' : RingHom.ker (mapRingHom i) ≤ I := by\n    intro f hf\n    apply polynomial_mem_ideal_of_coeff_mem_ideal I f\n    intro n\n    replace hf := congrArg (fun g : Polynomial ((Ideal.Quotient.mk I).comp C).range => g.coeff n) hf\n    change (Polynomial.map ((Ideal.Quotient.mk I).comp C).rangeRestrict f).coeff n = 0 at hf\n    rw [coeff_map, Subtype.ext_iff] at hf\n    rwa [mem_comap, ← Quotient.eq_zero_iff_mem, ← RingHom.comp_apply]\n  have R'_jacob : IsJacobsonRing R' := isJacobsonRing_of_surjective ⟨i, hi⟩\n  let J := I.map (mapRingHom i)\n  -- Porting note: moved ↓ this up a few lines, so that it can be used in the `have`\n  have h_surj : Function.Surjective (mapRingHom i) := Polynomial.map_surjective i hi\n  have : IsPrime J := map_isPrime_of_surjective h_surj hi'\n  suffices h : J.jacobson = J by\n    replace h := congrArg (comap (Polynomial.mapRingHom i)) h\n    rw [← map_jacobson_of_surjective h_surj hi', comap_map_of_surjective _ h_surj,\n      comap_map_of_surjective _ h_surj] at h\n    refine le_antisymm ?_ le_jacobson\n    exact le_trans (le_sup_of_le_left le_rfl) (le_trans (le_of_eq h) (sup_le le_rfl hi'))\n  apply isJacobsonRing_polynomial_of_domain R' J\n  exact eq_zero_of_polynomial_mem_map_range I\n\n"}
{"name":"Polynomial.isJacobsonRing_polynomial_iff_isJacobsonRing","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Iff (IsJacobsonRing (Polynomial R)) (IsJacobsonRing R)","decl":"theorem isJacobsonRing_polynomial_iff_isJacobsonRing : IsJacobsonRing R[X] ↔ IsJacobsonRing R := by\n  refine ⟨?_, isJacobsonRing_polynomial_of_isJacobsonRing⟩\n  intro H\n  exact isJacobsonRing_of_surjective ⟨eval₂RingHom (RingHom.id _) 1, fun x =>\n    ⟨C x, by simp only [coe_eval₂RingHom, RingHom.id_apply, eval₂_C]⟩⟩\n\n"}
{"name":"Polynomial.instIsJacobsonRing","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsJacobsonRing R\n⊢ IsJacobsonRing (Polynomial R)","decl":"instance [IsJacobsonRing R] : IsJacobsonRing R[X] :=\n  isJacobsonRing_polynomial_iff_isJacobsonRing.mpr ‹IsJacobsonRing R›\n\n"}
{"name":"Polynomial.isMaximal_comap_C_of_isMaximal","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nP : Ideal (Polynomial R)\nhP : P.IsMaximal\ninst✝¹ : IsJacobsonRing R\ninst✝ : Nontrivial R\nhP' : ∀ (x : R), Membership.mem P (Polynomial.C x) → Eq x 0\n⊢ (Ideal.comap Polynomial.C P).IsMaximal","decl":"theorem isMaximal_comap_C_of_isMaximal [IsJacobsonRing R] [Nontrivial R]\n    (hP' : ∀ x : R, C x ∈ P → x = 0) :\n    IsMaximal (comap (C : R →+* R[X]) P : Ideal R) := by\n  let P' := comap (C : R →+* R[X]) P\n  haveI hP'_prime : P'.IsPrime := comap_isPrime C P\n  obtain ⟨⟨m, hmem_P⟩, hm⟩ :=\n    Submodule.nonzero_mem_of_bot_lt (bot_lt_of_maximal P polynomial_not_isField)\n  have hm' : m ≠ 0 := by\n    simpa [Submodule.coe_eq_zero] using hm\n  let φ : R ⧸ P' →+* R[X] ⧸ P := quotientMap P (C : R →+* R[X]) le_rfl\n  let a : R ⧸ P' := (m.map (Ideal.Quotient.mk P')).leadingCoeff\n  let M : Submonoid (R ⧸ P') := Submonoid.powers a\n  rw [← bot_quotient_isMaximal_iff]\n  have hp0 : a ≠ 0 := fun hp0' =>\n    hm' <| map_injective (Ideal.Quotient.mk (P.comap (C : R →+* R[X]) : Ideal R))\n      ((injective_iff_map_eq_zero (Ideal.Quotient.mk (P.comap (C : R →+* R[X]) : Ideal R))).2\n        fun x hx => by\n          rwa [Quotient.eq_zero_iff_mem, (by rwa [eq_bot_iff] : (P.comap C : Ideal R) = ⊥)] at hx)\n        (by simpa only [a, leadingCoeff_eq_zero, Polynomial.map_zero] using hp0')\n  have hM : (0 : R ⧸ P') ∉ M := fun ⟨n, hn⟩ => hp0 (pow_eq_zero hn)\n  suffices (⊥ : Ideal (Localization M)).IsMaximal by\n    rw [← IsLocalization.comap_map_of_isPrime_disjoint M (Localization M) ⊥ bot_prime\n      (disjoint_iff_inf_le.mpr fun x hx => hM (hx.2 ▸ hx.1))]\n    exact ((IsLocalization.isMaximal_iff_isMaximal_disjoint (Localization M) a _).mp\n      (by rwa [Ideal.map_bot])).1\n  let M' : Submonoid (R[X] ⧸ P) := M.map φ\n  have hM' : (0 : R[X] ⧸ P) ∉ M' := fun ⟨z, hz⟩ =>\n    hM (quotientMap_injective (_root_.trans hz.2 φ.map_zero.symm) ▸ hz.1)\n  haveI : IsDomain (Localization M') :=\n    IsLocalization.isDomain_localization (le_nonZeroDivisors_of_noZeroDivisors hM')\n  suffices (⊥ : Ideal (Localization M')).IsMaximal by\n    rw [le_antisymm bot_le (comap_bot_le_of_injective _\n      (IsLocalization.map_injective_of_injective M (Localization M) (Localization M')\n        quotientMap_injective))]\n    refine isMaximal_comap_of_isIntegral_of_isMaximal' _ ?_ ⊥\n    have isloc : IsLocalization (Submonoid.map φ M) (Localization M') := by infer_instance\n    exact @isIntegral_isLocalization_polynomial_quotient R _\n      (Localization M) (Localization M') _ _ P m hmem_P _ _ _ isloc\n  rw [(map_bot.symm :\n    (⊥ : Ideal (Localization M')) = Ideal.map (algebraMap (R[X] ⧸ P) (Localization M')) ⊥)]\n  let bot_maximal := (bot_quotient_isMaximal_iff _).mpr hP\n  refine bot_maximal.map_bijective (algebraMap (R[X] ⧸ P) (Localization M')) ?_\n  apply IsField.localization_map_bijective hM'\n  rwa [← Quotient.maximal_ideal_iff_isField_quotient, ← bot_quotient_isMaximal_iff]\n\n"}
{"name":"Polynomial.quotient_mk_comp_C_isIntegral_of_isJacobsonRing","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nP : Ideal (Polynomial R)\nhP : P.IsMaximal\ninst✝ : IsJacobsonRing R\n⊢ ((Ideal.Quotient.mk P).comp Polynomial.C).IsIntegral","decl":"/-- If `R` is a Jacobson ring, and `P` is a maximal ideal of `R[X]`,\n  then `R → R[X]/P` is an integral map. -/\ntheorem quotient_mk_comp_C_isIntegral_of_isJacobsonRing :\n    ((Ideal.Quotient.mk P).comp C : R →+* R[X] ⧸ P).IsIntegral := by\n  let P' : Ideal R := P.comap C\n  haveI : P'.IsPrime := comap_isPrime C P\n  let f : R[X] →+* Polynomial (R ⧸ P') := Polynomial.mapRingHom (Ideal.Quotient.mk P')\n  have hf : Function.Surjective ↑f := map_surjective (Ideal.Quotient.mk P') Quotient.mk_surjective\n  have hPJ : P = (P.map f).comap f := by\n    rw [comap_map_of_surjective _ hf]\n    refine le_antisymm (le_sup_of_le_left le_rfl) (sup_le le_rfl ?_)\n    refine fun p hp =>\n      polynomial_mem_ideal_of_coeff_mem_ideal P p fun n => Quotient.eq_zero_iff_mem.mp ?_\n    simpa only [f, coeff_map, coe_mapRingHom] using (Polynomial.ext_iff.mp hp) n\n  refine RingHom.IsIntegral.tower_bot _ _ (injective_quotient_le_comap_map P) ?_\n  rw [← quotient_mk_maps_eq]\n  refine ((Ideal.Quotient.mk P').isIntegral_of_surjective Quotient.mk_surjective).trans _ _ ?_\n  have : IsMaximal (Ideal.map (mapRingHom (Ideal.Quotient.mk (comap C P))) P) :=\n    Or.recOn (map_eq_top_or_isMaximal_of_surjective f hf hP)\n      (fun h => absurd (_root_.trans (h ▸ hPJ : P = comap f ⊤) comap_top : P = ⊤) hP.ne_top) id\n  apply quotient_mk_comp_C_isIntegral_of_jacobson' _ ?_ (fun x hx => ?_)\n  any_goals exact isJacobsonRing_quotient\n  obtain ⟨z, rfl⟩ := Ideal.Quotient.mk_surjective x\n  rwa [Quotient.eq_zero_iff_mem, mem_comap, hPJ, mem_comap, coe_mapRingHom, map_C]\n\n"}
{"name":"Polynomial.isMaximal_comap_C_of_isJacobsonRing","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nP : Ideal (Polynomial R)\nhP : P.IsMaximal\ninst✝ : IsJacobsonRing R\n⊢ (Ideal.comap Polynomial.C P).IsMaximal","decl":"theorem isMaximal_comap_C_of_isJacobsonRing : (P.comap (C : R →+* R[X])).IsMaximal := by\n  rw [← @mk_ker _ _ P, RingHom.ker_eq_comap_bot, comap_comap]\n  have := (bot_quotient_isMaximal_iff _).mpr hP\n  exact isMaximal_comap_of_isIntegral_of_isMaximal' _\n    (quotient_mk_comp_C_isIntegral_of_isJacobsonRing P) ⊥\n\n"}
{"name":"Polynomial.comp_C_integral_of_surjective_of_isJacobsonRing","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsJacobsonRing R\nS : Type u_2\ninst✝ : Field S\nf : RingHom (Polynomial R) S\nhf : Function.Surjective ⇑f\n⊢ (f.comp Polynomial.C).IsIntegral","decl":"theorem comp_C_integral_of_surjective_of_isJacobsonRing {S : Type*} [Field S] (f : R[X] →+* S)\n    (hf : Function.Surjective ↑f) : (f.comp C).IsIntegral := by\n  haveI : f.ker.IsMaximal := RingHom.ker_isMaximal_of_surjective f hf\n  let g : R[X] ⧸ (RingHom.ker f) →+* S := Ideal.Quotient.lift (RingHom.ker f) f fun _ h => h\n  have hfg : g.comp (Ideal.Quotient.mk (RingHom.ker f)) = f := ringHom_ext' rfl rfl\n  rw [← hfg, RingHom.comp_assoc]\n  refine (quotient_mk_comp_C_isIntegral_of_isJacobsonRing (RingHom.ker f)).trans _ g\n    (g.isIntegral_of_surjective ?_)\n  rw [← hfg] at hf\n  norm_num at hf\n  exact Function.Surjective.of_comp hf\n\n"}
{"name":"MvPolynomial.isJacobsonRing_MvPolynomial_fin","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u\ninst✝ : CommRing R\nH : IsJacobsonRing R\nn : Nat\n⊢ IsJacobsonRing (MvPolynomial (Fin n) R)","decl":"theorem isJacobsonRing_MvPolynomial_fin {R : Type u} [CommRing R] [H : IsJacobsonRing R] :\n    ∀ n : ℕ, IsJacobsonRing (MvPolynomial (Fin n) R)\n  | 0 => (isJacobsonRing_iso ((renameEquiv R (Equiv.equivPEmpty (Fin 0))).toRingEquiv.trans\n    (isEmptyRingEquiv R PEmpty.{u+1}))).mpr H\n  | n + 1 => (isJacobsonRing_iso (finSuccEquiv R n).toRingEquiv).2\n    (Polynomial.isJacobsonRing_polynomial_iff_isJacobsonRing.2 (isJacobsonRing_MvPolynomial_fin n))\n\n"}
{"name":"MvPolynomial.isJacobsonRing","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nι : Type u_2\ninst✝¹ : Finite ι\ninst✝ : IsJacobsonRing R\n⊢ IsJacobsonRing (MvPolynomial ι R)","decl":"/-- General form of the Nullstellensatz for Jacobson rings, since in a Jacobson ring we have\n  `Inf {P maximal | P ≥ I} = Inf {P prime | P ≥ I} = I.radical`. Fields are always Jacobson,\n  and in that special case this is (most of) the classical Nullstellensatz,\n  since `I(V(I))` is the intersection of maximal ideals containing `I`, which is then `I.radical` -/\ninstance isJacobsonRing {R : Type*} [CommRing R] {ι : Type*} [Finite ι] [IsJacobsonRing R] :\n    IsJacobsonRing (MvPolynomial ι R) := by\n  cases nonempty_fintype ι\n  haveI := Classical.decEq ι\n  let e := Fintype.equivFin ι\n  rw [isJacobsonRing_iso (renameEquiv R e).toRingEquiv]\n  exact isJacobsonRing_MvPolynomial_fin _\n\n"}
{"name":"MvPolynomial.quotient_mk_comp_C_isIntegral_of_isJacobsonRing","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsJacobsonRing R\nP : Ideal (MvPolynomial (Fin n) R)\nhP : P.IsMaximal\n⊢ ((Ideal.Quotient.mk P).comp MvPolynomial.C).IsIntegral","decl":"theorem quotient_mk_comp_C_isIntegral_of_isJacobsonRing {R : Type*} [CommRing R] [IsJacobsonRing R]\n    (P : Ideal (MvPolynomial (Fin n) R)) [hP : P.IsMaximal] :\n    RingHom.IsIntegral (RingHom.comp (Ideal.Quotient.mk P) (MvPolynomial.C)) := by\n  change RingHom.IsIntegral (algebraMap R (MvPolynomial (Fin n) R ⧸ P))\n  apply quotient_mk_comp_C_isIntegral_of_isJacobsonRing'\n  infer_instance\n\n"}
{"name":"MvPolynomial.comp_C_integral_of_surjective_of_isJacobsonRing","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsJacobsonRing R\nσ : Type u_2\ninst✝¹ : Finite σ\nS : Type u_3\ninst✝ : Field S\nf : RingHom (MvPolynomial σ R) S\nhf : Function.Surjective ⇑f\n⊢ (f.comp MvPolynomial.C).IsIntegral","decl":"theorem comp_C_integral_of_surjective_of_isJacobsonRing {R : Type*} [CommRing R] [IsJacobsonRing R]\n    {σ : Type*} [Finite σ] {S : Type*} [Field S] (f : MvPolynomial σ R →+* S)\n    (hf : Function.Surjective ↑f) : (f.comp C).IsIntegral := by\n  cases nonempty_fintype σ\n  have e := (Fintype.equivFin σ).symm\n  let f' : MvPolynomial (Fin _) R →+* S := f.comp (renameEquiv R e).toRingEquiv.toRingHom\n  have hf' := Function.Surjective.comp hf (renameEquiv R e).surjective\n  change Function.Surjective ↑f' at hf'\n  have : (f'.comp C).IsIntegral := by\n    haveI : f'.ker.IsMaximal := ker_isMaximal_of_surjective f' hf'\n    let g : MvPolynomial _ R ⧸ (RingHom.ker f') →+* S :=\n      Ideal.Quotient.lift (RingHom.ker f') f' fun _ h => h\n    have hfg : g.comp (Ideal.Quotient.mk (RingHom.ker f')) = f' :=\n      ringHom_ext (fun r => rfl) fun i => rfl\n    rw [← hfg, RingHom.comp_assoc]\n    refine (quotient_mk_comp_C_isIntegral_of_isJacobsonRing (RingHom.ker f')).trans _ g\n      (g.isIntegral_of_surjective ?_)\n    rw [← hfg] at hf'\n    norm_num at hf'\n    exact Function.Surjective.of_comp hf'\n  rw [RingHom.comp_assoc] at this\n  convert this\n  refine RingHom.ext fun x => ?_\n  exact ((renameEquiv R e).commutes' x).symm\n\n"}
{"name":"isJacobsonRing_of_finiteType","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra A B\ninst✝¹ : IsJacobsonRing A\ninst✝ : Algebra.FiniteType A B\n⊢ IsJacobsonRing B","decl":"lemma isJacobsonRing_of_finiteType {A B : Type*} [CommRing A] [CommRing B]\n    [Algebra A B] [IsJacobsonRing A] [Algebra.FiniteType A B] : IsJacobsonRing B := by\n  obtain ⟨ι, hι, f, hf⟩ := Algebra.FiniteType.iff_quotient_mvPolynomial'.mp ‹_›\n  exact isJacobsonRing_of_surjective ⟨f.toRingHom, hf⟩\n\n"}
{"name":"RingHom.FiniteType.isJacobsonRing","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : CommRing A\ninst✝¹ : CommRing B\nf : RingHom A B\ninst✝ : IsJacobsonRing A\nH : f.FiniteType\n⊢ IsJacobsonRing B","decl":"lemma RingHom.FiniteType.isJacobsonRing {A B : Type*} [CommRing A] [CommRing B]\n    {f : A →+* B} [IsJacobsonRing A] (H : f.FiniteType) : IsJacobsonRing B :=\n  @isJacobsonRing_of_finiteType A B _ _ f.toAlgebra _ H\n\n"}
{"name":"finite_of_finite_type_of_isJacobsonRing","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Field S\ninst✝² : Algebra R S\ninst✝¹ : IsJacobsonRing R\ninst✝ : Algebra.FiniteType R S\n⊢ Module.Finite R S","decl":"lemma finite_of_finite_type_of_isJacobsonRing (R S : Type*) [CommRing R] [Field S]\n    [Algebra R S] [IsJacobsonRing R] [Algebra.FiniteType R S] :\n    Module.Finite R S := by\n  obtain ⟨ι, hι, f, hf⟩ := Algebra.FiniteType.iff_quotient_mvPolynomial'.mp ‹_›\n  have : (algebraMap R S).IsIntegral := by\n    rw [← f.comp_algebraMap]\n    #adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n    we needed to write `f.toRingHom` instead of just `f`, to avoid unification issues. -/\n    exact MvPolynomial.comp_C_integral_of_surjective_of_isJacobsonRing f.toRingHom hf\n  have : Algebra.IsIntegral R S := Algebra.isIntegral_def.mpr this\n  exact Algebra.IsIntegral.finite\n\n"}
{"name":"RingHom.finite_iff_finiteType_of_isJacobsonRing","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : IsJacobsonRing R\ninst✝ : Field S\nf : RingHom R S\n⊢ Iff f.Finite f.FiniteType","decl":"/--\nIf `f : R →+* S` is a ring homomorphism from a jacobson ring to a field,\nthen it is finite if and only if it is finite type.\n-/\nlemma RingHom.finite_iff_finiteType_of_isJacobsonRing\n    {R S : Type*} [CommRing R] [IsJacobsonRing R] [Field S]\n    {f : R →+* S} : f.Finite ↔ f.FiniteType :=\n  ⟨RingHom.FiniteType.of_finite,\n    by intro; algebraize [f]; exact finite_of_finite_type_of_isJacobsonRing R S⟩\n\n"}
{"name":"Ideal.isJacobson_iff","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_3\ninst✝ : CommRing R\n⊢ Iff (IsJacobsonRing R) (∀ (I : Ideal R), I.IsRadical → Eq I.jacobson I)","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isJacobson_iff := isJacobsonRing_iff\n"}
{"name":"Ideal.IsJacobson.out","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_3\ninst✝ : CommRing R\na✝¹ : IsJacobsonRing R\nI : Ideal R\na✝ : I.IsRadical\n⊢ Eq I.jacobson I","decl":"@[deprecated (since := \"2024-10-27\")]\nalias IsJacobson.out := IsJacobsonRing.out\n"}
{"name":"Ideal.isJacobson_iff_prime_eq","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Iff (IsJacobsonRing R) (∀ (P : Ideal R), P.IsPrime → Eq P.jacobson P)","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isJacobson_iff_prime_eq := isJacobsonRing_iff_prime_eq\n"}
{"name":"Ideal.isJacobson_iff_sInf_maximal","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Iff (IsJacobsonRing R) (∀ {I : Ideal R}, I.IsPrime → Exists fun M => And (∀ (J : Ideal R), Membership.mem M J → Or J.IsMaximal (Eq J Top.top)) (Eq I (InfSet.sInf M)))","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isJacobson_iff_sInf_maximal := isJacobsonRing_iff_sInf_maximal\n"}
{"name":"Ideal.isJacobson_iff_sInf_maximal'","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Iff (IsJacobsonRing R) (∀ {I : Ideal R}, I.IsPrime → Exists fun M => And (∀ (J : Ideal R), Membership.mem M J → ∀ (K : Ideal R), LT.lt J K → Eq K Top.top) (Eq I (InfSet.sInf M)))","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isJacobson_iff_sInf_maximal' := isJacobsonRing_iff_sInf_maximal'\n"}
{"name":"Ideal.isJacobson_of_surjective","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nH : IsJacobsonRing R\na✝ : Exists fun f => Function.Surjective ⇑f\n⊢ IsJacobsonRing S","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isJacobson_of_surjective := isJacobsonRing_of_surjective\n"}
{"name":"Ideal.isJacobson_iso","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\ne : RingEquiv R S\n⊢ Iff (IsJacobsonRing R) (IsJacobsonRing S)","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isJacobson_iso := isJacobsonRing_iso\n"}
{"name":"Ideal.isJacobson_of_isIntegral","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : Algebra.IsIntegral R S\ninst✝ : IsJacobsonRing R\n⊢ IsJacobsonRing S","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isJacobson_of_isIntegral := isJacobsonRing_of_isIntegral\n"}
{"name":"Ideal.isJacobson_of_isIntegral'","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing S\nf : RingHom R S\nhf : f.IsIntegral\ninst✝ : IsJacobsonRing R\n⊢ IsJacobsonRing S","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isJacobson_of_isIntegral' := isJacobsonRing_of_isIntegral'\n"}
{"name":"Ideal.isMaximal_iff_isMaximal_disjoint","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ny : R\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization.Away y S\nH : IsJacobsonRing R\nJ : Ideal S\n⊢ Iff J.IsMaximal (And (Ideal.comap (algebraMap R S) J).IsMaximal (Not (Membership.mem (Ideal.comap (algebraMap R S) J) y)))","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isMaximal_iff_isMaximal_disjoint := IsLocalization.isMaximal_iff_isMaximal_disjoint\n"}
{"name":"Ideal.isMaximal_of_isMaximal_disjoint","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ny : R\ninst✝² : Algebra R S\ninst✝¹ : IsLocalization.Away y S\ninst✝ : IsJacobsonRing R\nI : Ideal R\nhI : I.IsMaximal\nhy : Not (Membership.mem I y)\n⊢ (Ideal.map (algebraMap R S) I).IsMaximal","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isMaximal_of_isMaximal_disjoint := IsLocalization.isMaximal_of_isMaximal_disjoint\n"}
{"name":"Ideal.isJacobson_localization","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ny : R\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization.Away y S\nH : IsJacobsonRing R\n⊢ IsJacobsonRing S","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isJacobson_localization := isJacobsonRing_localization\n\n"}
{"name":"Ideal.Polynomial.isIntegral_isLocalization_polynomial_quotient","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\nRₘ : Type u_3\nSₘ : Type u_4\ninst✝⁵ : CommRing Rₘ\ninst✝⁴ : CommRing Sₘ\nP : Ideal (Polynomial R)\npX : Polynomial R\nhpX : Membership.mem P pX\ninst✝³ : Algebra (HasQuotient.Quotient R (Ideal.comap Polynomial.C P)) Rₘ\ninst✝² : IsLocalization.Away (Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)) pX).leadingCoeff Rₘ\ninst✝¹ : Algebra (HasQuotient.Quotient (Polynomial R) P) Sₘ\ninst✝ : IsLocalization (Submonoid.map (Ideal.quotientMap P Polynomial.C ⋯) (Submonoid.powers (Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)) pX).leadingCoeff)) Sₘ\n⊢ (IsLocalization.map Sₘ (Ideal.quotientMap P Polynomial.C ⋯) ⋯).IsIntegral","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isIntegral_isLocalization_polynomial_quotient := isIntegral_isLocalization_polynomial_quotient\n"}
{"name":"Ideal.Polynomial.jacobson_bot_of_integral_localization","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"S : Type u_2\ninst✝¹⁰ : CommRing S\ninst✝⁹ : IsDomain S\nR : Type u_5\ninst✝⁸ : CommRing R\ninst✝⁷ : IsDomain R\ninst✝⁶ : IsJacobsonRing R\nRₘ : Type u_6\nSₘ : Type u_7\ninst✝⁵ : CommRing Rₘ\ninst✝⁴ : CommRing Sₘ\nφ : RingHom R S\nhφ : Function.Injective ⇑φ\nx : R\nhx : Ne x 0\ninst✝³ : Algebra R Rₘ\ninst✝² : IsLocalization.Away x Rₘ\ninst✝¹ : Algebra S Sₘ\ninst✝ : IsLocalization (Submonoid.map φ (Submonoid.powers x)) Sₘ\nhφ' : (IsLocalization.map Sₘ φ ⋯).IsIntegral\n⊢ Eq Bot.bot.jacobson Bot.bot","decl":"@[deprecated (since := \"2024-10-27\")]\nalias jacobson_bot_of_integral_localization := jacobson_bot_of_integral_localization\n"}
{"name":"Ideal.Polynomial.isJacobson_polynomial_of_isJacobson","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nhR : IsJacobsonRing R\n⊢ IsJacobsonRing (Polynomial R)","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isJacobson_polynomial_of_isJacobson := isJacobsonRing_polynomial_of_isJacobsonRing\n"}
{"name":"Ideal.Polynomial.isJacobson_polynomial_iff_isJacobson","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Iff (IsJacobsonRing (Polynomial R)) (IsJacobsonRing R)","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isJacobson_polynomial_iff_isJacobson := isJacobsonRing_polynomial_iff_isJacobsonRing\n"}
{"name":"Ideal.Polynomial.isMaximal_comap_C_of_isMaximal","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nP : Ideal (Polynomial R)\nhP : P.IsMaximal\ninst✝¹ : IsJacobsonRing R\ninst✝ : Nontrivial R\nhP' : ∀ (x : R), Membership.mem P (Polynomial.C x) → Eq x 0\n⊢ (Ideal.comap Polynomial.C P).IsMaximal","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isMaximal_comap_C_of_isMaximal := isMaximal_comap_C_of_isMaximal\n"}
{"name":"Ideal.Polynomial.quotient_mk_comp_C_isIntegral_of_jacobson","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nP : Ideal (Polynomial R)\nhP : P.IsMaximal\ninst✝ : IsJacobsonRing R\n⊢ ((Ideal.Quotient.mk P).comp Polynomial.C).IsIntegral","decl":"@[deprecated (since := \"2024-10-27\")]\nalias quotient_mk_comp_C_isIntegral_of_jacobson :=\n  Polynomial.quotient_mk_comp_C_isIntegral_of_isJacobsonRing\n"}
{"name":"Ideal.Polynomial.isMaximal_comap_C_of_isJacobson","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nP : Ideal (Polynomial R)\nhP : P.IsMaximal\ninst✝ : IsJacobsonRing R\n⊢ (Ideal.comap Polynomial.C P).IsMaximal","decl":"@[deprecated (since := \"2024-10-27\")]\nalias isMaximal_comap_C_of_isJacobson := isMaximal_comap_C_of_isJacobsonRing\n"}
{"name":"Ideal.Polynomial.comp_C_integral_of_surjective_of_jacobson","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsJacobsonRing R\nS : Type u_2\ninst✝ : Field S\nf : RingHom (Polynomial R) S\nhf : Function.Surjective ⇑f\n⊢ (f.comp Polynomial.C).IsIntegral","decl":"@[deprecated (since := \"2024-10-27\")]\nalias comp_C_integral_of_surjective_of_jacobson :=\n  Polynomial.comp_C_integral_of_surjective_of_isJacobsonRing\n\n"}
{"name":"Ideal.MvPolynomial.isJacobson_MvPolynomial_fin","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u\ninst✝ : CommRing R\nH : IsJacobsonRing R\nn : Nat\n⊢ IsJacobsonRing (MvPolynomial (Fin n) R)","decl":"@[deprecated (since := \"2024-10-27\")]\nalias MvPolynomial.isJacobson_MvPolynomial_fin := isJacobsonRing_MvPolynomial_fin\n"}
{"name":"Ideal.MvPolynomial.quotient_mk_comp_C_isIntegral_of_jacobson","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsJacobsonRing R\nP : Ideal (MvPolynomial (Fin n) R)\nhP : P.IsMaximal\n⊢ ((Ideal.Quotient.mk P).comp MvPolynomial.C).IsIntegral","decl":"@[deprecated (since := \"2024-10-27\")]\nalias MvPolynomial.quotient_mk_comp_C_isIntegral_of_jacobson :=\n  MvPolynomial.quotient_mk_comp_C_isIntegral_of_isJacobsonRing\n"}
{"name":"Ideal.MvPolynomial.comp_C_integral_of_surjective_of_jacobson","module":"Mathlib.RingTheory.Jacobson.Ring","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsJacobsonRing R\nσ : Type u_2\ninst✝¹ : Finite σ\nS : Type u_3\ninst✝ : Field S\nf : RingHom (MvPolynomial σ R) S\nhf : Function.Surjective ⇑f\n⊢ (f.comp MvPolynomial.C).IsIntegral","decl":"@[deprecated (since := \"2024-10-27\")]\nalias MvPolynomial.comp_C_integral_of_surjective_of_jacobson :=\n  MvPolynomial.comp_C_integral_of_surjective_of_isJacobsonRing\n\n"}
