{"name":"TopCat.isTopologicalBasis_cofiltered_limit","module":"Mathlib.Topology.Category.TopCat.Limits.Cofiltered","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : CategoryTheory.IsCofiltered J\nF : CategoryTheory.Functor J TopCat\nC : CategoryTheory.Limits.Cone F\nhC : CategoryTheory.Limits.IsLimit C\nT : (j : J) → Set (Set ↑(F.obj j))\nhT : ∀ (j : J), TopologicalSpace.IsTopologicalBasis (T j)\nuniv : ∀ (i : J), Membership.mem (T i) Set.univ\ninter : ∀ (i : J) (U1 U2 : Set ↑(F.obj i)), Membership.mem (T i) U1 → Membership.mem (T i) U2 → Membership.mem (T i) (Inter.inter U1 U2)\ncompat : ∀ (i j : J) (f : Quiver.Hom i j) (V : Set ↑(F.obj j)), Membership.mem (T j) V → Membership.mem (T i) (Set.preimage (⇑(F.map f)) V)\n⊢ TopologicalSpace.IsTopologicalBasis (setOf fun U => Exists fun j => Exists fun V => And (Membership.mem (T j) V) (Eq U (Set.preimage (⇑(C.π.app j)) V)))","decl":"/-- Given a *compatible* collection of topological bases for the factors in a cofiltered limit\nwhich contain `Set.univ` and are closed under intersections, the induced *naive* collection\nof sets in the limit is, in fact, a topological basis.\n-/\ntheorem isTopologicalBasis_cofiltered_limit (hC : IsLimit C) (T : ∀ j, Set (Set (F.obj j)))\n    (hT : ∀ j, IsTopologicalBasis (T j)) (univ : ∀ i : J, Set.univ ∈ T i)\n    (inter : ∀ (i) (U1 U2 : Set (F.obj i)), U1 ∈ T i → U2 ∈ T i → U1 ∩ U2 ∈ T i)\n    (compat : ∀ (i j : J) (f : i ⟶ j) (V : Set (F.obj j)) (_hV : V ∈ T j), F.map f ⁻¹' V ∈ T i) :\n    IsTopologicalBasis\n      {U : Set C.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = C.π.app j ⁻¹' V} := by\n  classical\n  -- The limit cone for `F` whose topology is defined as an infimum.\n  let D := limitConeInfi F\n  -- The isomorphism between the cone point of `C` and the cone point of `D`.\n  let E : C.pt ≅ D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)\n  have hE : IsInducing E.hom := (TopCat.homeoOfIso E).isInducing\n  -- Reduce to the assertion of the theorem with `D` instead of `C`.\n  suffices\n    IsTopologicalBasis\n      {U : Set D.pt | ∃ (j : _) (V : Set (F.obj j)), V ∈ T j ∧ U = D.π.app j ⁻¹' V} by\n    convert this.isInducing hE\n    ext U0\n    constructor\n    · rintro ⟨j, V, hV, rfl⟩\n      exact ⟨D.π.app j ⁻¹' V, ⟨j, V, hV, rfl⟩, rfl⟩\n    · rintro ⟨W, ⟨j, V, hV, rfl⟩, rfl⟩\n      exact ⟨j, V, hV, rfl⟩\n  -- Using `D`, we can apply the characterization of the topological basis of a\n  -- topology defined as an infimum...\n  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.π.app j x using 1\n  ext U0\n  constructor\n  · rintro ⟨j, V, hV, rfl⟩\n    let U : ∀ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ\n    refine ⟨U, {j}, ?_, ?_⟩\n    · simp only [Finset.mem_singleton]\n      rintro i rfl\n      simpa [U]\n    · simp [U]\n  · rintro ⟨U, G, h1, h2⟩\n    obtain ⟨j, hj⟩ := IsCofiltered.inf_objs_exists G\n    let g : ∀ e ∈ G, j ⟶ e := fun _ he => (hj he).some\n    let Vs : J → Set (F.obj j) := fun e => if h : e ∈ G then F.map (g e h) ⁻¹' U e else Set.univ\n    let V : Set (F.obj j) := ⋂ (e : J) (_he : e ∈ G), Vs e\n    refine ⟨j, V, ?_, ?_⟩\n    · -- An intermediate claim used to apply induction along `G : Finset J` later on.\n      have :\n        ∀ (S : Set (Set (F.obj j))) (E : Finset J) (P : J → Set (F.obj j)) (_univ : Set.univ ∈ S)\n          (_inter : ∀ A B : Set (F.obj j), A ∈ S → B ∈ S → A ∩ B ∈ S)\n          (_cond : ∀ (e : J) (_he : e ∈ E), P e ∈ S), (⋂ (e) (_he : e ∈ E), P e) ∈ S := by\n        intro S E\n        induction E using Finset.induction_on with\n        | empty =>\n          intro P he _hh\n          simpa\n        | @insert a E _ha hh1 =>\n          intro hh2 hh3 hh4 hh5\n          rw [Finset.set_biInter_insert]\n          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)\n          intro e he\n          exact hh5 e (Finset.mem_insert_of_mem he)\n      -- use the intermediate claim to finish off the goal using `univ` and `inter`.\n      refine this _ _ _ (univ _) (inter _) ?_\n      intro e he\n      dsimp [Vs]\n      rw [dif_pos he]\n      exact compat j e (g e he) (U e) (h1 e he)\n    · -- conclude...\n      rw [h2]\n      change _ = (D.π.app j)⁻¹' ⋂ (e : J) (_ : e ∈ G), Vs e\n      rw [Set.preimage_iInter]\n      apply congrArg\n      ext1 e\n      rw [Set.preimage_iInter]\n      apply congrArg\n      ext1 he\n      -- Porting note: needed more hand holding here\n      change (D.π.app e)⁻¹' U e =\n        (D.π.app j) ⁻¹' if h : e ∈ G then F.map (g e h) ⁻¹' U e else Set.univ\n      rw [dif_pos he, ← Set.preimage_comp]\n      apply congrFun\n      apply congrArg\n      rw [← coe_comp, D.w]\n      rfl\n\n"}
