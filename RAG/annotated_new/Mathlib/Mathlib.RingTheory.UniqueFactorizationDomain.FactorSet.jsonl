{"name":"Associates.FactorSet.coe_add","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\na b : Multiset (Subtype fun a => Irreducible a)\n⊢ Eq (↑(HAdd.hAdd a b)) (HAdd.hAdd ↑a ↑b)","decl":"theorem FactorSet.coe_add {a b : Multiset { a : Associates α // Irreducible a }} :\n    (↑(a + b) : FactorSet α) = a + b := by norm_cast\n\n"}
{"name":"Associates.FactorSet.sup_add_inf_eq_add","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : DecidableEq (Associates α)\na b : Associates.FactorSet α\n⊢ Eq (HAdd.hAdd (Max.max a b) (Min.min a b)) (HAdd.hAdd a b)","decl":"theorem FactorSet.sup_add_inf_eq_add [DecidableEq (Associates α)] :\n    ∀ a b : FactorSet α, a ⊔ b + a ⊓ b = a + b\n  | ⊤, b => show ⊤ ⊔ b + ⊤ ⊓ b = ⊤ + b by simp\n  | a, ⊤ => show a ⊔ ⊤ + a ⊓ ⊤ = a + ⊤ by simp\n  | WithTop.some a, WithTop.some b =>\n    show (a : FactorSet α) ⊔ b + (a : FactorSet α) ⊓ b = a + b by\n      rw [← WithTop.coe_sup, ← WithTop.coe_inf, ← WithTop.coe_add, ← WithTop.coe_add,\n        WithTop.coe_eq_coe]\n      exact Multiset.union_add_inter _ _\n\n"}
{"name":"Associates.prod_top","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\n⊢ Eq Top.top.prod 0","decl":"@[simp]\ntheorem prod_top : (⊤ : FactorSet α).prod = 0 :=\n  rfl\n\n"}
{"name":"Associates.prod_coe","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\ns : Multiset (Subtype fun a => Irreducible a)\n⊢ Eq (Associates.FactorSet.prod ↑s) (Multiset.map Subtype.val s).prod","decl":"@[simp]\ntheorem prod_coe {s : Multiset { a : Associates α // Irreducible a }} :\n    FactorSet.prod (s : FactorSet α) = (s.map (↑)).prod :=\n  rfl\n\n"}
{"name":"Associates.prod_add","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\na b : Associates.FactorSet α\n⊢ Eq (HAdd.hAdd a b).prod (HMul.hMul a.prod b.prod)","decl":"@[simp]\ntheorem prod_add : ∀ a b : FactorSet α, (a + b).prod = a.prod * b.prod\n  | ⊤, b => show (⊤ + b).prod = (⊤ : FactorSet α).prod * b.prod by simp\n  | a, ⊤ => show (a + ⊤).prod = a.prod * (⊤ : FactorSet α).prod by simp\n  | WithTop.some a, WithTop.some b => by\n    rw [← FactorSet.coe_add, prod_coe, prod_coe, prod_coe, Multiset.map_add, Multiset.prod_add]\n\n"}
{"name":"Associates.prod_mono","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\na b : Associates.FactorSet α\na✝ : LE.le a b\n⊢ LE.le a.prod b.prod","decl":"@[gcongr]\ntheorem prod_mono : ∀ {a b : FactorSet α}, a ≤ b → a.prod ≤ b.prod\n  | ⊤, b, h => by\n    have : b = ⊤ := top_unique h\n    rw [this, prod_top]\n  | a, ⊤, _ => show a.prod ≤ (⊤ : FactorSet α).prod by simp\n  | WithTop.some _, WithTop.some _, h =>\n    prod_le_prod <| Multiset.map_le_map <| WithTop.coe_le_coe.1 <| h\n\n"}
{"name":"Associates.FactorSet.prod_eq_zero_iff","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : Nontrivial α\np : Associates.FactorSet α\n⊢ Iff (Eq p.prod 0) (Eq p Top.top)","decl":"theorem FactorSet.prod_eq_zero_iff [Nontrivial α] (p : FactorSet α) : p.prod = 0 ↔ p = ⊤ := by\n  unfold FactorSet at p\n  induction p  -- TODO: `induction_eliminator` doesn't work with `abbrev`\n  · simp only [eq_self_iff_true, Associates.prod_top]\n  · rw [prod_coe, Multiset.prod_eq_zero_iff, Multiset.mem_map, eq_false WithTop.coe_ne_top,\n      iff_false, not_exists]\n    exact fun a => not_and_of_not_right _ a.prop.ne_zero\n\n"}
{"name":"Associates.count_some","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\np : Associates α\nhp : Irreducible p\ns : Multiset (Subtype fun a => Irreducible a)\n⊢ Eq (p.count ↑s) (Multiset.count ⟨p, hp⟩ s)","decl":"@[simp]\ntheorem count_some (hp : Irreducible p) (s : Multiset _) :\n    count p (WithTop.some s) = s.count ⟨p, hp⟩ := by\n  simp only [count, dif_pos hp, bcount]\n\n"}
{"name":"Associates.count_zero","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\np : Associates α\nhp : Irreducible p\n⊢ Eq (p.count 0) 0","decl":"@[simp]\ntheorem count_zero (hp : Irreducible p) : count p (0 : FactorSet α) = 0 := by\n  simp only [count, dif_pos hp, bcount, Multiset.count_zero]\n\n"}
{"name":"Associates.count_reducible","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\np : Associates α\nhp : Not (Irreducible p)\n⊢ Eq p.count 0","decl":"theorem count_reducible (hp : ¬Irreducible p) : count p = 0 := dif_neg hp\n\n"}
{"name":"Associates.factorSetMem_eq_mem","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np : Associates α\ns : Associates.FactorSet α\n⊢ Eq (Associates.FactorSetMem s p) (Membership.mem s p)","decl":"@[simp]\ntheorem factorSetMem_eq_mem (p : Associates α) (s : FactorSet α) : FactorSetMem s p = (p ∈ s) :=\n  rfl\n\n"}
{"name":"Associates.mem_factorSet_top","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np : Associates α\nhp : Irreducible p\n⊢ Membership.mem Top.top p","decl":"theorem mem_factorSet_top {p : Associates α} {hp : Irreducible p} : p ∈ (⊤ : FactorSet α) := by\n  dsimp only [Membership.mem]; dsimp only [FactorSetMem]; split_ifs; exact trivial\n\n"}
{"name":"Associates.mem_factorSet_some","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np : Associates α\nhp : Irreducible p\nl : Multiset (Subtype fun a => Irreducible a)\n⊢ Iff (Membership.mem (↑l) p) (Membership.mem l ⟨p, hp⟩)","decl":"theorem mem_factorSet_some {p : Associates α} {hp : Irreducible p}\n    {l : Multiset { a : Associates α // Irreducible a }} :\n    p ∈ (l : FactorSet α) ↔ Subtype.mk p hp ∈ l := by\n  dsimp only [Membership.mem]; dsimp only [FactorSetMem]; split_ifs; rfl\n\n"}
{"name":"Associates.reducible_not_mem_factorSet","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np : Associates α\nhp : Not (Irreducible p)\ns : Associates.FactorSet α\n⊢ Not (Membership.mem s p)","decl":"theorem reducible_not_mem_factorSet {p : Associates α} (hp : ¬Irreducible p) (s : FactorSet α) :\n    ¬p ∈ s := fun h ↦ by\n  rwa [← factorSetMem_eq_mem, FactorSetMem, dif_neg hp] at h\n\n"}
{"name":"Associates.irreducible_of_mem_factorSet","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np : Associates α\ns : Associates.FactorSet α\nh : Membership.mem s p\n⊢ Irreducible p","decl":"theorem irreducible_of_mem_factorSet {p : Associates α} {s : FactorSet α} (h : p ∈ s) :\n    Irreducible p :=\n  by_contra fun hp ↦ reducible_not_mem_factorSet hp s h\n\n"}
{"name":"Associates.FactorSet.unique","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : Nontrivial α\np q : Associates.FactorSet α\nh : Eq p.prod q.prod\n⊢ Eq p q","decl":"theorem FactorSet.unique [Nontrivial α] {p q : FactorSet α} (h : p.prod = q.prod) : p = q := by\n  -- TODO: `induction_eliminator` doesn't work with `abbrev`\n  unfold FactorSet at p q\n  induction p <;> induction q\n  · rfl\n  · rw [eq_comm, ← FactorSet.prod_eq_zero_iff, ← h, Associates.prod_top]\n  · rw [← FactorSet.prod_eq_zero_iff, h, Associates.prod_top]\n  · congr 1\n    rw [← Multiset.map_eq_map Subtype.coe_injective]\n    apply unique' _ _ h <;>\n      · intro a ha\n        obtain ⟨⟨a', irred⟩, -, rfl⟩ := Multiset.mem_map.mp ha\n        rwa [Subtype.coe_mk]\n\n"}
{"name":"Associates.map_subtype_coe_factors'","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na : α\n⊢ Eq (Multiset.map Subtype.val (Associates.factors' a)) (Multiset.map Associates.mk (UniqueFactorizationMonoid.factors a))","decl":"@[simp]\ntheorem map_subtype_coe_factors' {a : α} :\n    (factors' a).map (↑) = (factors a).map Associates.mk := by\n  simp [factors', Multiset.map_pmap, Multiset.pmap_eq_map]\n\n"}
{"name":"Associates.factors'_cong","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na b : α\nh : Associated a b\n⊢ Eq (Associates.factors' a) (Associates.factors' b)","decl":"theorem factors'_cong {a b : α} (h : a ~ᵤ b) : factors' a = factors' b := by\n  obtain rfl | hb := eq_or_ne b 0\n  · rw [associated_zero_iff_eq_zero] at h\n    rw [h]\n  have ha : a ≠ 0 := by\n    contrapose! hb with ha\n    rw [← associated_zero_iff_eq_zero, ← ha]\n    exact h.symm\n  rw [← Multiset.map_eq_map Subtype.coe_injective, map_subtype_coe_factors',\n    map_subtype_coe_factors', ← rel_associated_iff_map_eq_map]\n  exact\n    factors_unique irreducible_of_factor irreducible_of_factor\n      ((factors_prod ha).trans <| h.trans <| (factors_prod hb).symm)\n\n"}
{"name":"Associates.factors_zero","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\n⊢ Eq (Associates.factors 0) Top.top","decl":"@[simp]\ntheorem factors_zero : (0 : Associates α).factors = ⊤ :=\n  dif_pos rfl\n\n\n"}
{"name":"Associates.factors_mk","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na : α\nh : Ne a 0\n⊢ Eq (Associates.mk a).factors ↑(Associates.factors' a)","decl":"@[simp]\ntheorem factors_mk (a : α) (h : a ≠ 0) : (Associates.mk a).factors = factors' a := by\n  classical\n    apply dif_neg\n    apply mt mk_eq_zero.1 h\n\n"}
{"name":"Associates.factors_prod","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na : Associates α\n⊢ Eq a.factors.prod a","decl":"@[simp]\ntheorem factors_prod (a : Associates α) : a.factors.prod = a := by\n  rcases Associates.mk_surjective a with ⟨a, rfl⟩\n  rcases eq_or_ne a 0 with rfl | ha\n  · simp\n  · simp [ha, prod_mk, mk_eq_mk_iff_associated, UniqueFactorizationMonoid.factors_prod,\n      -Quotient.eq]\n\n"}
{"name":"Associates.prod_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : Nontrivial α\ns : Associates.FactorSet α\n⊢ Eq s.prod.factors s","decl":"@[simp]\ntheorem prod_factors [Nontrivial α] (s : FactorSet α) : s.prod.factors = s :=\n  FactorSet.unique <| factors_prod _\n\n"}
{"name":"Associates.factors_subsingleton","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : Subsingleton α\na : Associates α\n⊢ Eq a.factors Top.top","decl":"@[nontriviality]\ntheorem factors_subsingleton [Subsingleton α] {a : Associates α} : a.factors = ⊤ := by\n  have : Subsingleton (Associates α) := inferInstance\n  convert factors_zero\n\n"}
{"name":"Associates.factors_eq_top_iff_zero","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na : Associates α\n⊢ Iff (Eq a.factors Top.top) (Eq a 0)","decl":"theorem factors_eq_top_iff_zero {a : Associates α} : a.factors = ⊤ ↔ a = 0 := by\n  nontriviality α\n  exact ⟨fun h ↦ by rwa [← factors_prod a, FactorSet.prod_eq_zero_iff], fun h ↦ h ▸ factors_zero⟩\n\n"}
{"name":"Associates.factors_eq_some_iff_ne_zero","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na : Associates α\n⊢ Iff (Exists fun s => Eq a.factors ↑s) (Ne a 0)","decl":"theorem factors_eq_some_iff_ne_zero {a : Associates α} :\n    (∃ s : Multiset { p : Associates α // Irreducible p }, a.factors = s) ↔ a ≠ 0 := by\n  simp_rw [@eq_comm _ a.factors, ← WithTop.ne_top_iff_exists]\n  exact factors_eq_top_iff_zero.not\n\n"}
{"name":"Associates.eq_of_factors_eq_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na b : Associates α\nh : Eq a.factors b.factors\n⊢ Eq a b","decl":"theorem eq_of_factors_eq_factors {a b : Associates α} (h : a.factors = b.factors) : a = b := by\n  have : a.factors.prod = b.factors.prod := by rw [h]\n  rwa [factors_prod, factors_prod] at this\n\n"}
{"name":"Associates.eq_of_prod_eq_prod","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : Nontrivial α\na b : Associates.FactorSet α\nh : Eq a.prod b.prod\n⊢ Eq a b","decl":"theorem eq_of_prod_eq_prod [Nontrivial α] {a b : FactorSet α} (h : a.prod = b.prod) : a = b := by\n  have : a.prod.factors = b.prod.factors := by rw [h]\n  rwa [prod_factors, prod_factors] at this\n\n"}
{"name":"Associates.factors_mul","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na b : Associates α\n⊢ Eq (HMul.hMul a b).factors (HAdd.hAdd a.factors b.factors)","decl":"@[simp]\ntheorem factors_mul (a b : Associates α) : (a * b).factors = a.factors + b.factors := by\n  nontriviality α\n  refine eq_of_prod_eq_prod <| eq_of_factors_eq_factors ?_\n  rw [prod_add, factors_prod, factors_prod, factors_prod]\n\n"}
{"name":"Associates.factors_mono","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na b : Associates α\na✝ : LE.le a b\n⊢ LE.le a.factors b.factors","decl":"@[gcongr]\ntheorem factors_mono : ∀ {a b : Associates α}, a ≤ b → a.factors ≤ b.factors\n  | s, t, ⟨d, eq⟩ => by rw [eq, factors_mul]; exact le_add_of_nonneg_right bot_le\n\n"}
{"name":"Associates.factors_le","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na b : Associates α\n⊢ Iff (LE.le a.factors b.factors) (LE.le a b)","decl":"@[simp]\ntheorem factors_le {a b : Associates α} : a.factors ≤ b.factors ↔ a ≤ b := by\n  refine ⟨fun h ↦ ?_, factors_mono⟩\n  have : a.factors.prod ≤ b.factors.prod := prod_mono h\n  rwa [factors_prod, factors_prod] at this\n\n"}
{"name":"Associates.eq_factors_of_eq_counts","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\na b : Associates α\nha : Ne a 0\nhb : Ne b 0\nh : ∀ (p : Associates α), Irreducible p → Eq (p.count a.factors) (p.count b.factors)\n⊢ Eq a.factors b.factors","decl":"theorem eq_factors_of_eq_counts {a b : Associates α} (ha : a ≠ 0) (hb : b ≠ 0)\n    (h : ∀ p : Associates α, Irreducible p → p.count a.factors = p.count b.factors) :\n    a.factors = b.factors := by\n  obtain ⟨sa, h_sa⟩ := factors_eq_some_iff_ne_zero.mpr ha\n  obtain ⟨sb, h_sb⟩ := factors_eq_some_iff_ne_zero.mpr hb\n  rw [h_sa, h_sb] at h ⊢\n  rw [WithTop.coe_eq_coe]\n  have h_count : ∀ (p : Associates α) (hp : Irreducible p),\n      sa.count ⟨p, hp⟩ = sb.count ⟨p, hp⟩ := by\n    intro p hp\n    rw [← count_some, ← count_some, h p hp]\n  apply Multiset.toFinsupp.injective\n  ext ⟨p, hp⟩\n  rw [Multiset.toFinsupp_apply, Multiset.toFinsupp_apply, h_count p hp]\n\n"}
{"name":"Associates.eq_of_eq_counts","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\na b : Associates α\nha : Ne a 0\nhb : Ne b 0\nh : ∀ (p : Associates α), Irreducible p → Eq (p.count a.factors) (p.count b.factors)\n⊢ Eq a b","decl":"theorem eq_of_eq_counts {a b : Associates α} (ha : a ≠ 0) (hb : b ≠ 0)\n    (h : ∀ p : Associates α, Irreducible p → p.count a.factors = p.count b.factors) : a = b :=\n  eq_of_factors_eq_factors (eq_factors_of_eq_counts ha hb h)\n\n"}
{"name":"Associates.count_le_count_of_factors_le","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\na b p : Associates α\nhb : Ne b 0\nhp : Irreducible p\nh : LE.le a.factors b.factors\n⊢ LE.le (p.count a.factors) (p.count b.factors)","decl":"theorem count_le_count_of_factors_le {a b p : Associates α} (hb : b ≠ 0) (hp : Irreducible p)\n    (h : a.factors ≤ b.factors) : p.count a.factors ≤ p.count b.factors := by\n  by_cases ha : a = 0\n  · simp_all\n  obtain ⟨sa, h_sa⟩ := factors_eq_some_iff_ne_zero.mpr ha\n  obtain ⟨sb, h_sb⟩ := factors_eq_some_iff_ne_zero.mpr hb\n  rw [h_sa, h_sb] at h ⊢\n  rw [count_some hp, count_some hp]; rw [WithTop.coe_le_coe] at h\n  exact Multiset.count_le_of_le _ h\n\n"}
{"name":"Associates.count_le_count_of_le","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\na b p : Associates α\nhb : Ne b 0\nhp : Irreducible p\nh : LE.le a b\n⊢ LE.le (p.count a.factors) (p.count b.factors)","decl":"theorem count_le_count_of_le {a b p : Associates α} (hb : b ≠ 0) (hp : Irreducible p) (h : a ≤ b) :\n    p.count a.factors ≤ p.count b.factors :=\n  count_le_count_of_factors_le hb hp <| factors_mono h\n\n"}
{"name":"Associates.prod_le","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : Nontrivial α\na b : Associates.FactorSet α\n⊢ Iff (LE.le a.prod b.prod) (LE.le a b)","decl":"theorem prod_le [Nontrivial α] {a b : FactorSet α} : a.prod ≤ b.prod ↔ a ≤ b := by\n  refine ⟨fun h ↦ ?_, prod_mono⟩\n  have : a.prod.factors ≤ b.prod.factors := factors_mono h\n  rwa [prod_factors, prod_factors] at this\n\n"}
{"name":"Associates.sup_mul_inf","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na b : Associates α\n⊢ Eq (HMul.hMul (Max.max a b) (Min.min a b)) (HMul.hMul a b)","decl":"open Classical in\ntheorem sup_mul_inf (a b : Associates α) : (a ⊔ b) * (a ⊓ b) = a * b :=\n  show (a.factors ⊔ b.factors).prod * (a.factors ⊓ b.factors).prod = a * b by\n    nontriviality α\n    refine eq_of_factors_eq_factors ?_\n    rw [← prod_add, prod_factors, factors_mul, FactorSet.sup_add_inf_eq_add]\n\n"}
{"name":"Associates.dvd_of_mem_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na p : Associates α\nhm : Membership.mem a.factors p\n⊢ Dvd.dvd p a","decl":"theorem dvd_of_mem_factors {a p : Associates α} (hm : p ∈ factors a) :\n    p ∣ a := by\n  rcases eq_or_ne a 0 with rfl | ha0\n  · exact dvd_zero p\n  obtain ⟨a0, nza, ha'⟩ := exists_non_zero_rep ha0\n  rw [← Associates.factors_prod a]\n  rw [← ha', factors_mk a0 nza] at hm ⊢\n  rw [prod_coe]\n  apply Multiset.dvd_prod; apply Multiset.mem_map.mpr\n  exact ⟨⟨p, irreducible_of_mem_factorSet hm⟩, mem_factorSet_some.mp hm, rfl⟩\n\n"}
{"name":"Associates.dvd_of_mem_factors'","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na : α\np : Associates α\nhp : Irreducible p\nhz : Ne a 0\nh_mem : Membership.mem (Associates.factors' a) ⟨p, hp⟩\n⊢ Dvd.dvd p (Associates.mk a)","decl":"theorem dvd_of_mem_factors' {a : α} {p : Associates α} {hp : Irreducible p} {hz : a ≠ 0}\n    (h_mem : Subtype.mk p hp ∈ factors' a) : p ∣ Associates.mk a := by\n  haveI := Classical.decEq (Associates α)\n  apply dvd_of_mem_factors\n  rw [factors_mk _ hz]\n  apply mem_factorSet_some.2 h_mem\n\n"}
{"name":"Associates.mem_factors'_of_dvd","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na p : α\nha0 : Ne a 0\nhp : Irreducible p\nhd : Dvd.dvd p a\n⊢ Membership.mem (Associates.factors' a) ⟨Associates.mk p, ⋯⟩","decl":"theorem mem_factors'_of_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) (hd : p ∣ a) :\n    Subtype.mk (Associates.mk p) (irreducible_mk.2 hp) ∈ factors' a := by\n  obtain ⟨q, hq, hpq⟩ := exists_mem_factors_of_dvd ha0 hp hd\n  apply Multiset.mem_pmap.mpr; use q; use hq\n  exact Subtype.eq (Eq.symm (mk_eq_mk_iff_associated.mpr hpq))\n\n"}
{"name":"Associates.mem_factors'_iff_dvd","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na p : α\nha0 : Ne a 0\nhp : Irreducible p\n⊢ Iff (Membership.mem (Associates.factors' a) ⟨Associates.mk p, ⋯⟩) (Dvd.dvd p a)","decl":"theorem mem_factors'_iff_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) :\n    Subtype.mk (Associates.mk p) (irreducible_mk.2 hp) ∈ factors' a ↔ p ∣ a := by\n  constructor\n  · rw [← mk_dvd_mk]\n    apply dvd_of_mem_factors'\n    apply ha0\n  · apply mem_factors'_of_dvd ha0 hp\n\n"}
{"name":"Associates.mem_factors_of_dvd","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na p : α\nha0 : Ne a 0\nhp : Irreducible p\nhd : Dvd.dvd p a\n⊢ Membership.mem (Associates.mk a).factors (Associates.mk p)","decl":"theorem mem_factors_of_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) (hd : p ∣ a) :\n    Associates.mk p ∈ factors (Associates.mk a) := by\n  rw [factors_mk _ ha0]\n  exact mem_factorSet_some.mpr (mem_factors'_of_dvd ha0 hp hd)\n\n"}
{"name":"Associates.mem_factors_iff_dvd","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na p : α\nha0 : Ne a 0\nhp : Irreducible p\n⊢ Iff (Membership.mem (Associates.mk a).factors (Associates.mk p)) (Dvd.dvd p a)","decl":"theorem mem_factors_iff_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) :\n    Associates.mk p ∈ factors (Associates.mk a) ↔ p ∣ a := by\n  constructor\n  · rw [← mk_dvd_mk]\n    apply dvd_of_mem_factors\n  · apply mem_factors_of_dvd ha0 hp\n\n"}
{"name":"Associates.exists_prime_dvd_of_not_inf_one","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na b : α\nha : Ne a 0\nhb : Ne b 0\nh : Ne (Min.min (Associates.mk a) (Associates.mk b)) 1\n⊢ Exists fun p => And (Prime p) (And (Dvd.dvd p a) (Dvd.dvd p b))","decl":"open Classical in\ntheorem exists_prime_dvd_of_not_inf_one {a b : α} (ha : a ≠ 0) (hb : b ≠ 0)\n    (h : Associates.mk a ⊓ Associates.mk b ≠ 1) : ∃ p : α, Prime p ∧ p ∣ a ∧ p ∣ b := by\n  have hz : factors (Associates.mk a) ⊓ factors (Associates.mk b) ≠ 0 := by\n    contrapose! h with hf\n    change (factors (Associates.mk a) ⊓ factors (Associates.mk b)).prod = 1\n    rw [hf]\n    exact Multiset.prod_zero\n  rw [factors_mk a ha, factors_mk b hb, ← WithTop.coe_inf] at hz\n  obtain ⟨⟨p0, p0_irr⟩, p0_mem⟩ := Multiset.exists_mem_of_ne_zero ((mt WithTop.coe_eq_coe.mpr) hz)\n  rw [Multiset.inf_eq_inter] at p0_mem\n  obtain ⟨p, rfl⟩ : ∃ p, Associates.mk p = p0 := Quot.exists_rep p0\n  refine ⟨p, ?_, ?_, ?_⟩\n  · rw [← UniqueFactorizationMonoid.irreducible_iff_prime, ← irreducible_mk]\n    exact p0_irr\n  · apply dvd_of_mk_le_mk\n    apply dvd_of_mem_factors' (Multiset.mem_inter.mp p0_mem).left\n    apply ha\n  · apply dvd_of_mk_le_mk\n    apply dvd_of_mem_factors' (Multiset.mem_inter.mp p0_mem).right\n    apply hb\n\n"}
{"name":"Associates.coprime_iff_inf_one","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na b : α\nha0 : Ne a 0\nhb0 : Ne b 0\n⊢ Iff (Eq (Min.min (Associates.mk a) (Associates.mk b)) 1) (∀ {d : α}, Dvd.dvd d a → Dvd.dvd d b → Not (Prime d))","decl":"theorem coprime_iff_inf_one {a b : α} (ha0 : a ≠ 0) (hb0 : b ≠ 0) :\n    Associates.mk a ⊓ Associates.mk b = 1 ↔ ∀ {d : α}, d ∣ a → d ∣ b → ¬Prime d := by\n  constructor\n  · intro hg p ha hb hp\n    refine (Associates.prime_mk.mpr hp).not_unit (isUnit_of_dvd_one ?_)\n    rw [← hg]\n    exact le_inf (mk_le_mk_of_dvd ha) (mk_le_mk_of_dvd hb)\n  · contrapose\n    intro hg hc\n    obtain ⟨p, hp, hpa, hpb⟩ := exists_prime_dvd_of_not_inf_one ha0 hb0 hg\n    exact hc hpa hpb hp\n\n"}
{"name":"Associates.factors_self","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : Nontrivial α\np : Associates α\nhp : Irreducible p\n⊢ Eq p.factors ↑(Singleton.singleton ⟨p, hp⟩)","decl":"theorem factors_self [Nontrivial α] {p : Associates α} (hp : Irreducible p) :\n    p.factors = WithTop.some {⟨p, hp⟩} :=\n  eq_of_prod_eq_prod\n    (by rw [factors_prod, FactorSet.prod.eq_def]; dsimp; rw [prod_singleton])\n\n"}
{"name":"Associates.factors_prime_pow","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : Nontrivial α\np : Associates α\nhp : Irreducible p\nk : Nat\n⊢ Eq (HPow.hPow p k).factors ↑(Multiset.replicate k ⟨p, hp⟩)","decl":"theorem factors_prime_pow [Nontrivial α] {p : Associates α} (hp : Irreducible p) (k : ℕ) :\n    factors (p ^ k) = WithTop.some (Multiset.replicate k ⟨p, hp⟩) :=\n  eq_of_prod_eq_prod\n    (by\n      rw [Associates.factors_prod, FactorSet.prod.eq_def]\n      dsimp; rw [Multiset.map_replicate, Multiset.prod_replicate, Subtype.coe_mk])\n\n"}
{"name":"Associates.prime_pow_le_iff_le_bcount","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : DecidableEq (Associates α)\nm p : Associates α\nh₁ : Ne m 0\nh₂ : Irreducible p\nk : Nat\n⊢ Iff (LE.le (HPow.hPow p k) m) (LE.le k (Associates.bcount ⟨p, h₂⟩ m.factors))","decl":"theorem prime_pow_le_iff_le_bcount [DecidableEq (Associates α)] {m p : Associates α}\n    (h₁ : m ≠ 0) (h₂ : Irreducible p) {k : ℕ} : p ^ k ≤ m ↔ k ≤ bcount ⟨p, h₂⟩ m.factors := by\n  rcases Associates.exists_non_zero_rep h₁ with ⟨m, hm, rfl⟩\n  have := nontrivial_of_ne _ _ hm\n  rw [bcount.eq_def, factors_mk, Multiset.le_count_iff_replicate_le, ← factors_le,\n    factors_prime_pow, factors_mk, WithTop.coe_le_coe] <;> assumption\n\n"}
{"name":"Associates.factors_one","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : Nontrivial α\n⊢ Eq (Associates.factors 1) 0","decl":"@[simp]\ntheorem factors_one [Nontrivial α] : factors (1 : Associates α) = 0 := by\n  apply eq_of_prod_eq_prod\n  rw [Associates.factors_prod]\n  exact Multiset.prod_zero\n\n"}
{"name":"Associates.pow_factors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : Nontrivial α\na : Associates α\nk : Nat\n⊢ Eq (HPow.hPow a k).factors (HSMul.hSMul k a.factors)","decl":"@[simp]\ntheorem pow_factors [Nontrivial α] {a : Associates α} {k : ℕ} :\n    (a ^ k).factors = k • a.factors := by\n  induction' k with n h\n  · rw [zero_nsmul, pow_zero]\n    exact factors_one\n  · rw [pow_succ, succ_nsmul, factors_mul, h]\n\n"}
{"name":"Associates.prime_pow_dvd_iff_le","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\nm p : Associates α\nh₁ : Ne m 0\nh₂ : Irreducible p\nk : Nat\n⊢ Iff (LE.le (HPow.hPow p k) m) (LE.le k (p.count m.factors))","decl":"theorem prime_pow_dvd_iff_le {m p : Associates α} (h₁ : m ≠ 0) (h₂ : Irreducible p) {k : ℕ} :\n    p ^ k ≤ m ↔ k ≤ count p m.factors := by\n  rw [count, dif_pos h₂, prime_pow_le_iff_le_bcount h₁]\n\n"}
{"name":"Associates.le_of_count_ne_zero","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\nm p : Associates α\nh0 : Ne m 0\nhp : Irreducible p\na✝ : Ne (p.count m.factors) 0\n⊢ LE.le p m","decl":"theorem le_of_count_ne_zero {m p : Associates α} (h0 : m ≠ 0) (hp : Irreducible p) :\n    count p m.factors ≠ 0 → p ≤ m := by\n  nontriviality α\n  rw [← pos_iff_ne_zero]\n  intro h\n  rw [← pow_one p]\n  apply (prime_pow_dvd_iff_le h0 hp).2\n  simpa only\n\n"}
{"name":"Associates.count_ne_zero_iff_dvd","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\na p : α\nha0 : Ne a 0\nhp : Irreducible p\n⊢ Iff (Ne ((Associates.mk p).count (Associates.mk a).factors) 0) (Dvd.dvd p a)","decl":"theorem count_ne_zero_iff_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) :\n    (Associates.mk p).count (Associates.mk a).factors ≠ 0 ↔ p ∣ a := by\n  nontriviality α\n  rw [← Associates.mk_le_mk_iff_dvd]\n  refine\n    ⟨fun h =>\n      Associates.le_of_count_ne_zero (Associates.mk_ne_zero.mpr ha0)\n        (Associates.irreducible_mk.mpr hp) h,\n      fun h => ?_⟩\n  rw [← pow_one (Associates.mk p),\n    Associates.prime_pow_dvd_iff_le (Associates.mk_ne_zero.mpr ha0)\n      (Associates.irreducible_mk.mpr hp)] at h\n  exact (zero_lt_one.trans_le h).ne'\n\n"}
{"name":"Associates.count_self","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝⁴ : CancelCommMonoidWithZero α\ninst✝³ : UniqueFactorizationMonoid α\ninst✝² : DecidableEq (Associates α)\ninst✝¹ : (p : Associates α) → Decidable (Irreducible p)\ninst✝ : Nontrivial α\np : Associates α\nhp : Irreducible p\n⊢ Eq (p.count p.factors) 1","decl":"theorem count_self [Nontrivial α] {p : Associates α}\n    (hp : Irreducible p) : p.count p.factors = 1 := by\n  simp [factors_self hp, Associates.count_some hp]\n\n"}
{"name":"Associates.count_eq_zero_of_ne","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\np q : Associates α\nhp : Irreducible p\nhq : Irreducible q\nh : Ne p q\n⊢ Eq (p.count q.factors) 0","decl":"theorem count_eq_zero_of_ne {p q : Associates α} (hp : Irreducible p)\n    (hq : Irreducible q) (h : p ≠ q) : p.count q.factors = 0 :=\n  not_ne_iff.mp fun h' ↦ h <| associated_iff_eq.mp <| hp.associated_of_dvd hq <|\n    le_of_count_ne_zero hq.ne_zero hp h'\n\n"}
{"name":"Associates.count_mul","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\na : Associates α\nha : Ne a 0\nb : Associates α\nhb : Ne b 0\np : Associates α\nhp : Irreducible p\n⊢ Eq (p.count (HMul.hMul a b).factors) (HAdd.hAdd (p.count a.factors) (p.count b.factors))","decl":"theorem count_mul {a : Associates α} (ha : a ≠ 0) {b : Associates α}\n    (hb : b ≠ 0) {p : Associates α} (hp : Irreducible p) :\n    count p (factors (a * b)) = count p a.factors + count p b.factors := by\n  obtain ⟨a0, nza, rfl⟩ := exists_non_zero_rep ha\n  obtain ⟨b0, nzb, rfl⟩ := exists_non_zero_rep hb\n  rw [factors_mul, factors_mk a0 nza, factors_mk b0 nzb, ← FactorSet.coe_add, count_some hp,\n    Multiset.count_add, count_some hp, count_some hp]\n\n"}
{"name":"Associates.count_of_coprime","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\na : Associates α\nha : Ne a 0\nb : Associates α\nhb : Ne b 0\nhab : ∀ (d : Associates α), Dvd.dvd d a → Dvd.dvd d b → Not (Prime d)\np : Associates α\nhp : Irreducible p\n⊢ Or (Eq (p.count a.factors) 0) (Eq (p.count b.factors) 0)","decl":"theorem count_of_coprime {a : Associates α} (ha : a ≠ 0)\n    {b : Associates α} (hb : b ≠ 0) (hab : ∀ d, d ∣ a → d ∣ b → ¬Prime d) {p : Associates α}\n    (hp : Irreducible p) : count p a.factors = 0 ∨ count p b.factors = 0 := by\n  rw [or_iff_not_imp_left, ← Ne]\n  intro hca\n  contrapose! hab with hcb\n  exact ⟨p, le_of_count_ne_zero ha hp hca, le_of_count_ne_zero hb hp hcb,\n    UniqueFactorizationMonoid.irreducible_iff_prime.mp hp⟩\n\n"}
{"name":"Associates.count_mul_of_coprime","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\na b : Associates α\nhb : Ne b 0\np : Associates α\nhp : Irreducible p\nhab : ∀ (d : Associates α), Dvd.dvd d a → Dvd.dvd d b → Not (Prime d)\n⊢ Or (Eq (p.count a.factors) 0) (Eq (p.count a.factors) (p.count (HMul.hMul a b).factors))","decl":"theorem count_mul_of_coprime {a : Associates α} {b : Associates α}\n    (hb : b ≠ 0) {p : Associates α} (hp : Irreducible p) (hab : ∀ d, d ∣ a → d ∣ b → ¬Prime d) :\n    count p a.factors = 0 ∨ count p a.factors = count p (a * b).factors := by\n  by_cases ha : a = 0\n  · simp [ha]\n  cases' count_of_coprime ha hb hab hp with hz hb0; · tauto\n  apply Or.intro_right\n  rw [count_mul ha hb hp, hb0, add_zero]\n\n"}
{"name":"Associates.count_mul_of_coprime'","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\na b p : Associates α\nhp : Irreducible p\nhab : ∀ (d : Associates α), Dvd.dvd d a → Dvd.dvd d b → Not (Prime d)\n⊢ Or (Eq (p.count (HMul.hMul a b).factors) (p.count a.factors)) (Eq (p.count (HMul.hMul a b).factors) (p.count b.factors))","decl":"theorem count_mul_of_coprime' {a b : Associates α} {p : Associates α}\n    (hp : Irreducible p) (hab : ∀ d, d ∣ a → d ∣ b → ¬Prime d) :\n    count p (a * b).factors = count p a.factors ∨ count p (a * b).factors = count p b.factors := by\n  by_cases ha : a = 0\n  · simp [ha]\n  by_cases hb : b = 0\n  · simp [hb]\n  rw [count_mul ha hb hp]\n  cases' count_of_coprime ha hb hab hp with ha0 hb0\n  · apply Or.intro_right\n    rw [ha0, zero_add]\n  · apply Or.intro_left\n    rw [hb0, add_zero]\n\n"}
{"name":"Associates.dvd_count_of_dvd_count_mul","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\na b : Associates α\nhb : Ne b 0\np : Associates α\nhp : Irreducible p\nhab : ∀ (d : Associates α), Dvd.dvd d a → Dvd.dvd d b → Not (Prime d)\nk : Nat\nhabk : Dvd.dvd k (p.count (HMul.hMul a b).factors)\n⊢ Dvd.dvd k (p.count a.factors)","decl":"theorem dvd_count_of_dvd_count_mul {a b : Associates α} (hb : b ≠ 0)\n    {p : Associates α} (hp : Irreducible p) (hab : ∀ d, d ∣ a → d ∣ b → ¬Prime d) {k : ℕ}\n    (habk : k ∣ count p (a * b).factors) : k ∣ count p a.factors := by\n  by_cases ha : a = 0\n  · simpa [*] using habk\n  cases' count_of_coprime ha hb hab hp with hz h\n  · rw [hz]\n    exact dvd_zero k\n  · rw [count_mul ha hb hp, h] at habk\n    exact habk\n\n"}
{"name":"Associates.count_pow","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝⁴ : CancelCommMonoidWithZero α\ninst✝³ : UniqueFactorizationMonoid α\ninst✝² : DecidableEq (Associates α)\ninst✝¹ : (p : Associates α) → Decidable (Irreducible p)\ninst✝ : Nontrivial α\na : Associates α\nha : Ne a 0\np : Associates α\nhp : Irreducible p\nk : Nat\n⊢ Eq (p.count (HPow.hPow a k).factors) (HMul.hMul k (p.count a.factors))","decl":"theorem count_pow [Nontrivial α] {a : Associates α} (ha : a ≠ 0)\n    {p : Associates α} (hp : Irreducible p) (k : ℕ) :\n    count p (a ^ k).factors = k * count p a.factors := by\n  induction' k with n h\n  · rw [pow_zero, factors_one, zero_mul, count_zero hp]\n  · rw [pow_succ', count_mul ha (pow_ne_zero _ ha) hp, h]\n    ring\n\n"}
{"name":"Associates.dvd_count_pow","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝⁴ : CancelCommMonoidWithZero α\ninst✝³ : UniqueFactorizationMonoid α\ninst✝² : DecidableEq (Associates α)\ninst✝¹ : (p : Associates α) → Decidable (Irreducible p)\ninst✝ : Nontrivial α\na : Associates α\nha : Ne a 0\np : Associates α\nhp : Irreducible p\nk : Nat\n⊢ Dvd.dvd k (p.count (HPow.hPow a k).factors)","decl":"theorem dvd_count_pow [Nontrivial α] {a : Associates α} (ha : a ≠ 0)\n    {p : Associates α} (hp : Irreducible p) (k : ℕ) : k ∣ count p (a ^ k).factors := by\n  rw [count_pow ha hp]\n  apply dvd_mul_right\n\n"}
{"name":"Associates.is_pow_of_dvd_count","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\na : Associates α\nha : Ne a 0\nk : Nat\nhk : ∀ (p : Associates α), Irreducible p → Dvd.dvd k (p.count a.factors)\n⊢ Exists fun b => Eq a (HPow.hPow b k)","decl":"theorem is_pow_of_dvd_count {a : Associates α}\n    (ha : a ≠ 0) {k : ℕ} (hk : ∀ p : Associates α, Irreducible p → k ∣ count p a.factors) :\n    ∃ b : Associates α, a = b ^ k := by\n  nontriviality α\n  obtain ⟨a0, hz, rfl⟩ := exists_non_zero_rep ha\n  rw [factors_mk a0 hz] at hk\n  have hk' : ∀ p, p ∈ factors' a0 → k ∣ (factors' a0).count p := by\n    rintro p -\n    have pp : p = ⟨p.val, p.2⟩ := by simp only [Subtype.coe_eta]\n    rw [pp, ← count_some p.2]\n    exact hk p.val p.2\n  obtain ⟨u, hu⟩ := Multiset.exists_smul_of_dvd_count _ hk'\n  use FactorSet.prod (u : FactorSet α)\n  apply eq_of_factors_eq_factors\n  rw [pow_factors, prod_factors, factors_mk a0 hz, hu]\n  exact WithBot.coe_nsmul u k\n\n"}
{"name":"Associates.eq_pow_count_factors_of_dvd_pow","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : UniqueFactorizationMonoid α\ninst✝¹ : DecidableEq (Associates α)\ninst✝ : (p : Associates α) → Decidable (Irreducible p)\np a : Associates α\nhp : Irreducible p\nn : Nat\nh : Dvd.dvd a (HPow.hPow p n)\n⊢ Eq a (HPow.hPow p (p.count a.factors))","decl":"/-- The only divisors of prime powers are prime powers. See `eq_pow_find_of_dvd_irreducible_pow`\nfor an explicit expression as a p-power (without using `count`). -/\ntheorem eq_pow_count_factors_of_dvd_pow {p a : Associates α}\n    (hp : Irreducible p) {n : ℕ} (h : a ∣ p ^ n) : a = p ^ p.count a.factors := by\n  nontriviality α\n  have hph := pow_ne_zero n hp.ne_zero\n  have ha := ne_zero_of_dvd_ne_zero hph h\n  apply eq_of_eq_counts ha (pow_ne_zero _ hp.ne_zero)\n  have eq_zero_of_ne : ∀ q : Associates α, Irreducible q → q ≠ p → _ = 0 := fun q hq h' =>\n    Nat.eq_zero_of_le_zero <| by\n      convert count_le_count_of_le hph hq h\n      symm\n      rw [count_pow hp.ne_zero hq, count_eq_zero_of_ne hq hp h', mul_zero]\n  intro q hq\n  rw [count_pow hp.ne_zero hq]\n  by_cases h : q = p\n  · rw [h, count_self hp, mul_one]\n  · rw [count_eq_zero_of_ne hq hp h, mul_zero, eq_zero_of_ne q hq h]\n\n"}
{"name":"Associates.count_factors_eq_find_of_dvd_pow","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝⁴ : CancelCommMonoidWithZero α\ninst✝³ : UniqueFactorizationMonoid α\ninst✝² : DecidableEq (Associates α)\ninst✝¹ : (p : Associates α) → Decidable (Irreducible p)\na p : Associates α\nhp : Irreducible p\ninst✝ : (n : Nat) → Decidable (Dvd.dvd a (HPow.hPow p n))\nn : Nat\nh : Dvd.dvd a (HPow.hPow p n)\n⊢ Eq (Nat.find ⋯) (p.count a.factors)","decl":"theorem count_factors_eq_find_of_dvd_pow {a p : Associates α}\n    (hp : Irreducible p) [∀ n : ℕ, Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n) :\n    @Nat.find (fun n => a ∣ p ^ n) _ ⟨n, h⟩ = p.count a.factors := by\n  apply le_antisymm\n  · refine Nat.find_le ⟨1, ?_⟩\n    rw [mul_one]\n    symm\n    exact eq_pow_count_factors_of_dvd_pow hp h\n  · have hph := pow_ne_zero (@Nat.find (fun n => a ∣ p ^ n) _ ⟨n, h⟩) hp.ne_zero\n    cases' subsingleton_or_nontrivial α with hα hα\n    · simp [eq_iff_true_of_subsingleton] at hph\n    convert count_le_count_of_le hph hp (@Nat.find_spec (fun n => a ∣ p ^ n) _ ⟨n, h⟩)\n    rw [count_pow hp.ne_zero hp, count_self hp, mul_one]\n\n"}
{"name":"Associates.eq_pow_of_mul_eq_pow","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : UniqueFactorizationMonoid α\na b c : Associates α\nha : Ne a 0\nhb : Ne b 0\nhab : ∀ (d : Associates α), Dvd.dvd d a → Dvd.dvd d b → Not (Prime d)\nk : Nat\nh : Eq (HMul.hMul a b) (HPow.hPow c k)\n⊢ Exists fun d => Eq a (HPow.hPow d k)","decl":"theorem eq_pow_of_mul_eq_pow {a b c : Associates α} (ha : a ≠ 0) (hb : b ≠ 0)\n    (hab : ∀ d, d ∣ a → d ∣ b → ¬Prime d) {k : ℕ} (h : a * b = c ^ k) :\n    ∃ d : Associates α, a = d ^ k := by\n  classical\n  nontriviality α\n  by_cases hk0 : k = 0\n  · use 1\n    rw [hk0, pow_zero] at h ⊢\n    apply (mul_eq_one.1 h).1\n  · refine is_pow_of_dvd_count ha fun p hp ↦ ?_\n    apply dvd_count_of_dvd_count_mul hb hp hab\n    rw [h]\n    apply dvd_count_pow _ hp\n    rintro rfl\n    rw [zero_pow hk0] at h\n    cases mul_eq_zero.mp h <;> contradiction\n\n"}
{"name":"Associates.eq_pow_find_of_dvd_irreducible_pow","module":"Mathlib.RingTheory.UniqueFactorizationDomain.FactorSet","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : UniqueFactorizationMonoid α\na p : Associates α\nhp : Irreducible p\ninst✝ : (n : Nat) → Decidable (Dvd.dvd a (HPow.hPow p n))\nn : Nat\nh : Dvd.dvd a (HPow.hPow p n)\n⊢ Eq a (HPow.hPow p (Nat.find ⋯))","decl":"/-- The only divisors of prime powers are prime powers. -/\ntheorem eq_pow_find_of_dvd_irreducible_pow {a p : Associates α} (hp : Irreducible p)\n    [∀ n : ℕ, Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n) :\n    a = p ^ @Nat.find (fun n => a ∣ p ^ n) _ ⟨n, h⟩ := by\n  classical rw [count_factors_eq_find_of_dvd_pow hp, ← eq_pow_count_factors_of_dvd_pow hp h]\n  exact h\n\n"}
