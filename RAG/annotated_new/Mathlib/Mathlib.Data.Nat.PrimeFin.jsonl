{"name":"Nat.infinite_setOf_prime","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"⊢ (setOf fun p => Nat.Prime p).Infinite","decl":"/-- A version of `Nat.exists_infinite_primes` using the `Set.Infinite` predicate. -/\ntheorem infinite_setOf_prime : { p | Prime p }.Infinite :=\n  Set.infinite_of_not_bddAbove not_bddAbove_setOf_prime\n\n"}
{"name":"Nat.Primes.infinite","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"⊢ Infinite Nat.Primes","decl":"instance Primes.infinite : Infinite Primes := infinite_setOf_prime.to_subtype\n\n"}
{"name":"Nat.Primes.countable","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"⊢ Countable Nat.Primes","decl":"instance Primes.countable : Countable Primes := ⟨⟨coeNat.coe, coe_nat_injective⟩⟩\n\n"}
{"name":"Nat.toFinset_factors","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"n : Nat\n⊢ Eq n.primeFactorsList.toFinset n.primeFactors","decl":"@[simp] lemma toFinset_factors (n : ℕ) : n.primeFactorsList.toFinset = n.primeFactors := rfl\n\n"}
{"name":"Nat.mem_primeFactors","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"n p : Nat\n⊢ Iff (Membership.mem n.primeFactors p) (And (Nat.Prime p) (And (Dvd.dvd p n) (Ne n 0)))","decl":"@[simp] lemma mem_primeFactors : p ∈ n.primeFactors ↔ p.Prime ∧ p ∣ n ∧ n ≠ 0 := by\n  simp_rw [← toFinset_factors, List.mem_toFinset, mem_primeFactorsList']\n\n"}
{"name":"Nat.mem_primeFactors_of_ne_zero","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"n p : Nat\nhn : Ne n 0\n⊢ Iff (Membership.mem n.primeFactors p) (And (Nat.Prime p) (Dvd.dvd p n))","decl":"lemma mem_primeFactors_of_ne_zero (hn : n ≠ 0) : p ∈ n.primeFactors ↔ p.Prime ∧ p ∣ n := by\n  simp [hn]\n\n"}
{"name":"Nat.primeFactors_mono","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"m n : Nat\nhmn : Dvd.dvd m n\nhn : Ne n 0\n⊢ HasSubset.Subset m.primeFactors n.primeFactors","decl":"lemma primeFactors_mono (hmn : m ∣ n) (hn : n ≠ 0) : primeFactors m ⊆ primeFactors n := by\n  simp only [subset_iff, mem_primeFactors, and_imp]\n  exact fun p hp hpm _ ↦ ⟨hp, hpm.trans hmn, hn⟩\n\n"}
{"name":"Nat.mem_primeFactors_iff_mem_primeFactorsList","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"n p : Nat\n⊢ Iff (Membership.mem n.primeFactors p) (Membership.mem n.primeFactorsList p)","decl":"lemma mem_primeFactors_iff_mem_primeFactorsList : p ∈ n.primeFactors ↔ p ∈ n.primeFactorsList := by\n  simp only [primeFactors, List.mem_toFinset]\n\n"}
{"name":"Nat.prime_of_mem_primeFactors","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"n p : Nat\nhp : Membership.mem n.primeFactors p\n⊢ Nat.Prime p","decl":"lemma prime_of_mem_primeFactors (hp : p ∈ n.primeFactors) : p.Prime := (mem_primeFactors.1 hp).1\n"}
{"name":"Nat.dvd_of_mem_primeFactors","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"n p : Nat\nhp : Membership.mem n.primeFactors p\n⊢ Dvd.dvd p n","decl":"lemma dvd_of_mem_primeFactors (hp : p ∈ n.primeFactors) : p ∣ n := (mem_primeFactors.1 hp).2.1\n\n"}
{"name":"Nat.pos_of_mem_primeFactors","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"n p : Nat\nhp : Membership.mem n.primeFactors p\n⊢ LT.lt 0 p","decl":"lemma pos_of_mem_primeFactors (hp : p ∈ n.primeFactors) : 0 < p :=\n  (prime_of_mem_primeFactors hp).pos\n\n"}
{"name":"Nat.le_of_mem_primeFactors","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"n p : Nat\nh : Membership.mem n.primeFactors p\n⊢ LE.le p n","decl":"lemma le_of_mem_primeFactors (h : p ∈ n.primeFactors) : p ≤ n :=\n  le_of_dvd (mem_primeFactors.1 h).2.2.bot_lt <| dvd_of_mem_primeFactors h\n\n"}
{"name":"Nat.primeFactors_zero","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"⊢ Eq (Nat.primeFactors 0) EmptyCollection.emptyCollection","decl":"@[simp] lemma primeFactors_zero : primeFactors 0 = ∅ := by\n  ext\n  simp\n\n"}
{"name":"Nat.primeFactors_one","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"⊢ Eq (Nat.primeFactors 1) EmptyCollection.emptyCollection","decl":"@[simp] lemma primeFactors_one : primeFactors 1 = ∅ := by\n  ext\n  simpa using Prime.ne_one\n\n"}
{"name":"Nat.primeFactors_eq_empty","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"n : Nat\n⊢ Iff (Eq n.primeFactors EmptyCollection.emptyCollection) (Or (Eq n 0) (Eq n 1))","decl":"@[simp] lemma primeFactors_eq_empty : n.primeFactors = ∅ ↔ n = 0 ∨ n = 1 := by\n  constructor\n  · contrapose!\n    rintro hn\n    obtain ⟨p, hp, hpn⟩ := exists_prime_and_dvd hn.2\n    exact Nonempty.ne_empty <| ⟨_, mem_primeFactors.2 ⟨hp, hpn, hn.1⟩⟩\n  · rintro (rfl | rfl) <;> simp\n\n"}
{"name":"Nat.nonempty_primeFactors","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"n : Nat\n⊢ Iff n.primeFactors.Nonempty (LT.lt 1 n)","decl":"@[simp]\nlemma nonempty_primeFactors {n : ℕ} : n.primeFactors.Nonempty ↔ 1 < n := by\n  rw [← not_iff_not, Finset.not_nonempty_iff_eq_empty, primeFactors_eq_empty, not_lt,\n    Nat.le_one_iff_eq_zero_or_eq_one]\n\n"}
{"name":"Nat.Prime.primeFactors","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Eq p.primeFactors (Singleton.singleton p)","decl":"@[simp] protected lemma Prime.primeFactors (hp : p.Prime) : p.primeFactors = {p} := by\n  simp [Nat.primeFactors, primeFactorsList_prime hp]\n\n"}
{"name":"Nat.primeFactors_mul","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"a b : Nat\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HMul.hMul a b).primeFactors (Union.union a.primeFactors b.primeFactors)","decl":"lemma primeFactors_mul (ha : a ≠ 0) (hb : b ≠ 0) :\n    (a * b).primeFactors = a.primeFactors ∪ b.primeFactors := by\n  ext; simp only [Finset.mem_union, mem_primeFactors_iff_mem_primeFactorsList,\n    mem_primeFactorsList_mul ha hb]\n\n"}
{"name":"Nat.Coprime.primeFactors_mul","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"a b : Nat\nhab : a.Coprime b\n⊢ Eq (HMul.hMul a b).primeFactors (Union.union a.primeFactors b.primeFactors)","decl":"lemma Coprime.primeFactors_mul {a b : ℕ} (hab : Coprime a b) :\n    (a * b).primeFactors = a.primeFactors ∪ b.primeFactors :=\n  (List.toFinset.ext <| mem_primeFactorsList_mul_of_coprime hab).trans <| List.toFinset_union _ _\n\n"}
{"name":"Nat.primeFactors_gcd","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"a b : Nat\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (a.gcd b).primeFactors (Inter.inter a.primeFactors b.primeFactors)","decl":"lemma primeFactors_gcd (ha : a ≠ 0) (hb : b ≠ 0) :\n    (a.gcd b).primeFactors = a.primeFactors ∩ b.primeFactors := by\n  ext; simp [dvd_gcd_iff, ha, hb, gcd_ne_zero_left ha]; aesop\n\n"}
{"name":"Nat.disjoint_primeFactors","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"a b : Nat\nha : Ne a 0\nhb : Ne b 0\n⊢ Iff (Disjoint a.primeFactors b.primeFactors) (a.Coprime b)","decl":"@[simp] lemma disjoint_primeFactors (ha : a ≠ 0) (hb : b ≠ 0) :\n    Disjoint a.primeFactors b.primeFactors ↔ Coprime a b := by\n  simp [disjoint_iff_inter_eq_empty, coprime_iff_gcd_eq_one, ← primeFactors_gcd, gcd_ne_zero_left,\n    ha, hb]\n\n"}
{"name":"Nat.Coprime.disjoint_primeFactors","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"a b : Nat\nhab : a.Coprime b\n⊢ Disjoint a.primeFactors b.primeFactors","decl":"protected lemma Coprime.disjoint_primeFactors (hab : Coprime a b) :\n    Disjoint a.primeFactors b.primeFactors :=\n  List.disjoint_toFinset_iff_disjoint.2 <| coprime_primeFactorsList_disjoint hab\n\n"}
{"name":"Nat.primeFactors_pow_succ","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"n k : Nat\n⊢ Eq (HPow.hPow n (HAdd.hAdd k 1)).primeFactors n.primeFactors","decl":"lemma primeFactors_pow_succ (n k : ℕ) : (n ^ (k + 1)).primeFactors = n.primeFactors := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp\n  induction' k with k ih\n  · simp\n  · rw [pow_succ', primeFactors_mul hn (pow_ne_zero _ hn), ih, Finset.union_idempotent]\n\n"}
{"name":"Nat.primeFactors_pow","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"k n : Nat\nhk : Ne k 0\n⊢ Eq (HPow.hPow n k).primeFactors n.primeFactors","decl":"lemma primeFactors_pow (n : ℕ) (hk : k ≠ 0) : (n ^ k).primeFactors = n.primeFactors := by\n  cases k\n  · simp at hk\n  rw [primeFactors_pow_succ]\n\n"}
{"name":"Nat.primeFactors_prime_pow","module":"Mathlib.Data.Nat.PrimeFin","initialProofState":"k p : Nat\nhk : Ne k 0\nhp : Nat.Prime p\n⊢ Eq (HPow.hPow p k).primeFactors (Singleton.singleton p)","decl":"/-- The only prime divisor of positive prime power `p^k` is `p` itself -/\nlemma primeFactors_prime_pow (hk : k ≠ 0) (hp : Prime p) :\n    (p ^ k).primeFactors = {p} := by simp [primeFactors_pow p hk, hp]\n\n"}
