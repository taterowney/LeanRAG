{"name":"Option.coe_def","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\n⊢ Eq (fun a => Option.some a) Option.some","decl":"theorem coe_def : (fun a ↦ ↑a : α → Option α) = some :=\n  rfl\n\n"}
{"name":"Option.mem_map","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ny : β\no : Option α\n⊢ Iff (Membership.mem (Option.map f o) y) (Exists fun x => And (Membership.mem o x) (Eq (f x) y))","decl":"theorem mem_map {f : α → β} {y : β} {o : Option α} : y ∈ o.map f ↔ ∃ x ∈ o, f x = y := by simp\n\n-- The simpNF linter says that the LHS can be simplified via `Option.mem_def`.\n-- However this is a higher priority lemma.\n-- https://github.com/leanprover/std4/issues/207\n"}
{"name":"Option.mem_map_of_injective","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nH : Function.Injective f\na : α\no : Option α\n⊢ Iff (Membership.mem (Option.map f o) (f a)) (Membership.mem o a)","decl":"@[simp 1100, nolint simpNF]\ntheorem mem_map_of_injective {f : α → β} (H : Function.Injective f) {a : α} {o : Option α} :\n    f a ∈ o.map f ↔ a ∈ o := by\n  aesop\n\n"}
{"name":"Option.forall_mem_map","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\no : Option α\np : β → Prop\n⊢ Iff (∀ (y : β), Membership.mem (Option.map f o) y → p y) (∀ (x : α), Membership.mem o x → p (f x))","decl":"theorem forall_mem_map {f : α → β} {o : Option α} {p : β → Prop} :\n    (∀ y ∈ o.map f, p y) ↔ ∀ x ∈ o, p (f x) := by simp\n\n"}
{"name":"Option.exists_mem_map","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\no : Option α\np : β → Prop\n⊢ Iff (Exists fun y => And (Membership.mem (Option.map f o) y) (p y)) (Exists fun x => And (Membership.mem o x) (p (f x)))","decl":"theorem exists_mem_map {f : α → β} {o : Option α} {p : β → Prop} :\n    (∃ y ∈ o.map f, p y) ↔ ∃ x ∈ o, p (f x) := by simp\n\n"}
{"name":"Option.coe_get","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\no : Option α\nh : Eq o.isSome Bool.true\n⊢ Eq (Option.some (o.get h)) o","decl":"theorem coe_get {o : Option α} (h : o.isSome) : ((Option.get _ h : α) : Option α) = o :=\n  Option.some_get h\n\n"}
{"name":"Option.eq_of_mem_of_mem","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\na : α\no1 o2 : Option α\nh1 : Membership.mem o1 a\nh2 : Membership.mem o2 a\n⊢ Eq o1 o2","decl":"theorem eq_of_mem_of_mem {a : α} {o1 o2 : Option α} (h1 : a ∈ o1) (h2 : a ∈ o2) : o1 = o2 :=\n  h1.trans h2.symm\n\n"}
{"name":"Option.Mem.leftUnique","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\n⊢ Relator.LeftUnique fun x1 x2 => Membership.mem x2 x1","decl":"theorem Mem.leftUnique : Relator.LeftUnique ((· ∈ ·) : α → Option α → Prop) :=\n  fun _ _ _=> mem_unique\n\n"}
{"name":"Option.some_injective","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_5\n⊢ Function.Injective Option.some","decl":"theorem some_injective (α : Type*) : Function.Injective (@some α) := fun _ _ ↦ some_inj.mp\n\n"}
{"name":"Option.map_injective","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nHf : Function.Injective f\n⊢ Function.Injective (Option.map f)","decl":"/-- `Option.map f` is injective if `f` is injective. -/\ntheorem map_injective {f : α → β} (Hf : Function.Injective f) : Function.Injective (Option.map f)\n  | none, none, _ => rfl\n  | some a₁, some a₂, H => by rw [Hf (Option.some.inj H)]\n\n"}
{"name":"Option.map_comp_some","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Function.comp (Option.map f) Option.some) (Function.comp Option.some f)","decl":"@[simp]\ntheorem map_comp_some (f : α → β) : Option.map f ∘ some = some ∘ f :=\n  rfl\n\n"}
{"name":"Option.none_bind'","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → Option β\n⊢ Eq (Option.none.bind f) Option.none","decl":"@[simp]\ntheorem none_bind' (f : α → Option β) : none.bind f = none :=\n  rfl\n\n"}
{"name":"Option.some_bind'","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nf : α → Option β\n⊢ Eq ((Option.some a).bind f) (f a)","decl":"@[simp]\ntheorem some_bind' (a : α) (f : α → Option β) : (some a).bind f = f a :=\n  rfl\n\n"}
{"name":"Option.bind_eq_some'","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx : Option α\nf : α → Option β\nb : β\n⊢ Iff (Eq (x.bind f) (Option.some b)) (Exists fun a => And (Eq x (Option.some a)) (Eq (f a) (Option.some b)))","decl":"theorem bind_eq_some' {x : Option α} {f : α → Option β} {b : β} :\n    x.bind f = some b ↔ ∃ a, x = some a ∧ f a = some b := by\n  cases x <;> simp\n\n"}
{"name":"Option.bind_congr","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → Option β\nx : Option α\nh : ∀ (a : α), Membership.mem x a → Eq (f a) (g a)\n⊢ Eq (x.bind f) (x.bind g)","decl":"theorem bind_congr {f g : α → Option β} {x : Option α}\n    (h : ∀ a ∈ x, f a = g a) : x.bind f = x.bind g := by\n  cases x <;> simp only [some_bind, none_bind, mem_def, h]\n\n"}
{"name":"Option.bind_congr'","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → Option β\nx y : Option α\nhx : Eq x y\nhf : ∀ (a : α), Membership.mem y a → Eq (f a) (g a)\n⊢ Eq (x.bind f) (y.bind g)","decl":"@[congr]\ntheorem bind_congr' {f g : α → Option β} {x y : Option α} (hx : x = y)\n    (hf : ∀ a ∈ y, f a = g a) : x.bind f = y.bind g :=\n  hx.symm ▸ bind_congr hf\n\n"}
{"name":"Option.joinM_eq_join","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\n⊢ Eq joinM Option.join","decl":"theorem joinM_eq_join : joinM = @join α :=\n  funext fun _ ↦ rfl\n\n"}
{"name":"Option.bind_eq_bind'","module":"Mathlib.Data.Option.Basic","initialProofState":"α β : Type u\nf : α → Option β\nx : Option α\n⊢ Eq (Bind.bind x f) (x.bind f)","decl":"theorem bind_eq_bind' {α β : Type u} {f : α → Option β} {x : Option α} : x >>= f = x.bind f :=\n  rfl\n\n"}
{"name":"Option.map_coe","module":"Mathlib.Data.Option.Basic","initialProofState":"α β : Type u_5\na : α\nf : α → β\n⊢ Eq (Functor.map f (Option.some a)) (Option.some (f a))","decl":"theorem map_coe {α β} {a : α} {f : α → β} : f <$> (a : Option α) = ↑(f a) :=\n  rfl\n\n"}
{"name":"Option.map_coe'","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nf : α → β\n⊢ Eq (Option.map f (Option.some a)) (Option.some (f a))","decl":"@[simp]\ntheorem map_coe' {a : α} {f : α → β} : Option.map f (a : Option α) = ↑(f a) :=\n  rfl\n\n"}
{"name":"Option.map_injective'","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Function.Injective Option.map","decl":"/-- `Option.map` as a function between functions is injective. -/\ntheorem map_injective' : Function.Injective (@Option.map α β) := fun f g h ↦\n  funext fun x ↦ some_injective _ <| by simp only [← map_some', h]\n\n"}
{"name":"Option.map_inj","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\n⊢ Iff (Eq (Option.map f) (Option.map g)) (Eq f g)","decl":"@[simp]\ntheorem map_inj {f g : α → β} : Option.map f = Option.map g ↔ f = g :=\n  map_injective'.eq_iff\n\n"}
{"name":"Option.map_eq_id","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nf : α → α\n⊢ Iff (Eq (Option.map f) id) (Eq f id)","decl":"@[simp]\ntheorem map_eq_id {f : α → α} : Option.map f = id ↔ f = id :=\n  map_injective'.eq_iff' map_id\n\n"}
{"name":"Option.map_comm","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf₁ : α → β\nf₂ : α → γ\ng₁ : β → δ\ng₂ : γ → δ\nh : Eq (Function.comp g₁ f₁) (Function.comp g₂ f₂)\na : α\n⊢ Eq (Option.map g₁ (Option.map f₁ (Option.some a))) (Option.map g₂ (Option.map f₂ (Option.some a)))","decl":"theorem map_comm {f₁ : α → β} {f₂ : α → γ} {g₁ : β → δ} {g₂ : γ → δ} (h : g₁ ∘ f₁ = g₂ ∘ f₂)\n    (a : α) :\n    (Option.map f₁ a).map g₁ = (Option.map f₂ a).map g₂ := by rw [map_map, h, ← map_map]\n\n"}
{"name":"Option.pbind_eq_bind","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → Option β\nx : Option α\n⊢ Eq (x.pbind fun a x => f a) (x.bind f)","decl":"theorem pbind_eq_bind (f : α → Option β) (x : Option α) : (x.pbind fun a _ ↦ f a) = x.bind f := by\n  cases x <;> simp only [pbind, none_bind', some_bind']\n\n"}
{"name":"Option.map_bind'","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : β → γ\nx : Option α\ng : α → Option β\n⊢ Eq (Option.map f (x.bind g)) (x.bind fun a => Option.map f (g a))","decl":"theorem map_bind' (f : β → γ) (x : Option α) (g : α → Option β) :\n    Option.map f (x.bind g) = x.bind fun a ↦ Option.map f (g a) := by cases x <;> simp\n\n"}
{"name":"Option.pbind_map","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nx : Option α\ng : (b : β) → Membership.mem (Option.map f x) b → Option γ\n⊢ Eq ((Option.map f x).pbind g) (x.pbind fun a h => g (f a) ⋯)","decl":"theorem pbind_map (f : α → β) (x : Option α) (g : ∀ b : β, b ∈ x.map f → Option γ) :\n    pbind (Option.map f x) g = x.pbind fun a h ↦ g (f a) (mem_map_of_mem _ h) := by cases x <;> rfl\n\n"}
{"name":"Option.mem_pmem","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → Prop\nf : (a : α) → p a → β\nx : Option α\na : α\nh : ∀ (a : α), Membership.mem x a → p a\nha : Membership.mem x a\n⊢ Membership.mem (Option.pmap f x h) (f a ⋯)","decl":"theorem mem_pmem {a : α} (h : ∀ a ∈ x, p a) (ha : a ∈ x) : f a (h a ha) ∈ pmap f x h := by\n  rw [mem_def] at ha ⊢\n  subst ha\n  rfl\n\n"}
{"name":"Option.pmap_map","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\np : α → Prop\nf : (a : α) → p a → β\ng : γ → α\nx : Option γ\nH : ∀ (a : α), Membership.mem (Option.map g x) a → p a\n⊢ Eq (Option.pmap f (Option.map g x) H) (Option.pmap (fun a h => f (g a) h) x ⋯)","decl":"theorem pmap_map (g : γ → α) (x : Option γ) (H) :\n    pmap f (x.map g) H = pmap (fun a h ↦ f (g a) h) x fun _ h ↦ H _ (mem_map_of_mem _ h) := by\n  cases x <;> simp only [map_none', map_some', pmap]\n\n"}
{"name":"Option.map_pmap","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\np : α → Prop\ng : β → γ\nf : (a : α) → p a → β\nx : Option α\nH : ∀ (a : α), Membership.mem x a → p a\n⊢ Eq (Option.map g (Option.pmap f x H)) (Option.pmap (fun a h => g (f a h)) x H)","decl":"theorem map_pmap (g : β → γ) (f : ∀ a, p a → β) (x H) :\n    Option.map g (pmap f x H) = pmap (fun a h ↦ g (f a h)) x H := by\n  cases x <;> simp only [map_none', map_some', pmap]\n\n-- Porting note: Can't simp tag this anymore because `pmap` simplifies\n-- @[simp]\n"}
{"name":"Option.pmap_eq_map","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → Prop\nf : α → β\nx : Option α\nH : ∀ (a : α), Membership.mem x a → p a\n⊢ Eq (Option.pmap (fun a x => f a) x H) (Option.map f x)","decl":"theorem pmap_eq_map (p : α → Prop) (f : α → β) (x H) :\n    @pmap _ _ p (fun a _ ↦ f a) x H = Option.map f x := by\n  cases x <;> simp only [map_none', map_some', pmap]\n\n"}
{"name":"Option.pmap_bind","module":"Mathlib.Data.Option.Basic","initialProofState":"α β γ : Type u_5\nx : Option α\ng : α → Option β\np : β → Prop\nf : (b : β) → p b → γ\nH : ∀ (a : β), Membership.mem (Bind.bind x g) a → p a\nH' : ∀ (a : α) (b : β), Membership.mem (g a) b → Membership.mem (Bind.bind x g) b\n⊢ Eq (Option.pmap f (Bind.bind x g) H) (Bind.bind x fun a => Option.pmap f (g a) ⋯)","decl":"theorem pmap_bind {α β γ} {x : Option α} {g : α → Option β} {p : β → Prop} {f : ∀ b, p b → γ} (H)\n    (H' : ∀ (a : α), ∀ b ∈ g a, b ∈ x >>= g) :\n    pmap f (x >>= g) H = x >>= fun a ↦ pmap f (g a) fun _ h ↦ H _ (H' a _ h) := by\n  cases x <;> simp only [pmap, bind_eq_bind, none_bind, some_bind]\n\n"}
{"name":"Option.bind_pmap","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_5\nβ γ : Type u_6\np : α → Prop\nf : (a : α) → p a → β\nx : Option α\ng : β → Option γ\nH : ∀ (a : α), Membership.mem x a → p a\n⊢ Eq (Bind.bind (Option.pmap f x H) g) (x.pbind fun a h => g (f a ⋯))","decl":"theorem bind_pmap {α β γ} {p : α → Prop} (f : ∀ a, p a → β) (x : Option α) (g : β → Option γ) (H) :\n    pmap f x H >>= g = x.pbind fun a h ↦ g (f a (H _ h)) := by\n  cases x <;> simp only [pmap, bind_eq_bind, none_bind, some_bind, pbind]\n\n"}
{"name":"Option.pbind_eq_none","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx : Option α\nf : (a : α) → Membership.mem x a → Option β\nh' : ∀ (a : α) (H : Membership.mem x a), Eq (f a H) Option.none → Eq x Option.none\n⊢ Iff (Eq (x.pbind f) Option.none) (Eq x Option.none)","decl":"theorem pbind_eq_none {f : ∀ a : α, a ∈ x → Option β}\n    (h' : ∀ a (H : a ∈ x), f a H = none → x = none) : x.pbind f = none ↔ x = none := by\n  cases x\n  · simp\n  · simp only [pbind, iff_false, reduceCtorEq]\n    intro h\n    cases h' _ rfl h\n\n"}
{"name":"Option.pbind_eq_some","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx : Option α\nf : (a : α) → Membership.mem x a → Option β\ny : β\n⊢ Iff (Eq (x.pbind f) (Option.some y)) (Exists fun z => Exists fun H => Eq (f z H) (Option.some y))","decl":"theorem pbind_eq_some {f : ∀ a : α, a ∈ x → Option β} {y : β} :\n    x.pbind f = some y ↔ ∃ (z : α) (H : z ∈ x), f z H = some y := by\n  rcases x with (_|x)\n  · simp\n  · simp only [pbind]\n    refine ⟨fun h ↦ ⟨x, rfl, h⟩, ?_⟩\n    rintro ⟨z, H, hz⟩\n    simp only [mem_def, Option.some_inj] at H\n    simpa [H] using hz\n\n-- Porting note: Can't simp tag this anymore because `join` and `pmap` simplify\n-- @[simp]\n"}
{"name":"Option.join_pmap_eq_pmap_join","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → Prop\nf : (a : α) → p a → β\nx : Option (Option α)\nH : ∀ (a : Option α), Membership.mem x a → ∀ (a_2 : α), Membership.mem a a_2 → p a_2\n⊢ Eq (Option.pmap (Option.pmap f) x H).join (Option.pmap f x.join ⋯)","decl":"theorem join_pmap_eq_pmap_join {f : ∀ a, p a → β} {x : Option (Option α)} (H) :\n    (pmap (pmap f) x H).join = pmap f x.join fun a h ↦ H (some a) (mem_of_mem_join h) _ rfl := by\n  rcases x with (_ | _ | x) <;> simp\n\n"}
{"name":"Option.seq_some","module":"Mathlib.Data.Option.Basic","initialProofState":"α β : Type u_5\na : α\nf : α → β\n⊢ Eq (Seq.seq (Option.some f) fun x => Option.some a) (Option.some (f a))","decl":"@[simp]\ntheorem seq_some {α β} {a : α} {f : α → β} : some f <*> some a = some (f a) :=\n  rfl\n\n"}
{"name":"Option.some_orElse'","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\na : α\nx : Option α\n⊢ Eq ((Option.some a).orElse fun x_1 => x) (Option.some a)","decl":"@[simp]\ntheorem some_orElse' (a : α) (x : Option α) : (some a).orElse (fun _ ↦ x) = some a :=\n  rfl\n\n"}
{"name":"Option.none_orElse'","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nx : Option α\n⊢ Eq (Option.none.orElse fun x_1 => x) x","decl":"@[simp]\ntheorem none_orElse' (x : Option α) : none.orElse (fun _ ↦ x) = x := by cases x <;> rfl\n\n"}
{"name":"Option.orElse_none'","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nx : Option α\n⊢ Eq (x.orElse fun x => Option.none) x","decl":"@[simp]\ntheorem orElse_none' (x : Option α) : x.orElse (fun _ ↦ none) = x := by cases x <;> rfl\n\n"}
{"name":"Option.exists_ne_none","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\np : Option α → Prop\n⊢ Iff (Exists fun x => And (Ne x Option.none) (p x)) (Exists fun x => p (Option.some x))","decl":"theorem exists_ne_none {p : Option α → Prop} : (∃ x ≠ none, p x) ↔ (∃ x : α, p x) := by\n  simp only [← exists_prop, bex_ne_none]\n\n"}
{"name":"Option.iget_mem","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\ninst✝ : Inhabited α\no : Option α\na✝ : Eq o.isSome Bool.true\n⊢ Membership.mem o o.iget","decl":"theorem iget_mem [Inhabited α] : ∀ {o : Option α}, isSome o → o.iget ∈ o\n  | some _, _ => rfl\n\n"}
{"name":"Option.iget_of_mem","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\ninst✝ : Inhabited α\na : α\no : Option α\na✝ : Membership.mem o a\n⊢ Eq o.iget a","decl":"theorem iget_of_mem [Inhabited α] {a : α} : ∀ {o : Option α}, a ∈ o → o.iget = a\n  | _, rfl => rfl\n\n"}
{"name":"Option.getD_default_eq_iget","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\ninst✝ : Inhabited α\no : Option α\n⊢ Eq (o.getD Inhabited.default) o.iget","decl":"theorem getD_default_eq_iget [Inhabited α] (o : Option α) :\n    o.getD default = o.iget := by cases o <;> rfl\n\n"}
{"name":"Option.guard_eq_some'","module":"Mathlib.Data.Option.Basic","initialProofState":"p : Prop\ninst✝ : Decidable p\nu : Unit\n⊢ Iff (Eq (guard p) (Option.some u)) p","decl":"@[simp]\ntheorem guard_eq_some' {p : Prop} [Decidable p] (u) : _root_.guard p = some u ↔ p := by\n  cases u\n  by_cases h : p <;> simp [_root_.guard, h]\n\n"}
{"name":"Option.liftOrGet_choice","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nf : α → α → α\nh : ∀ (a b : α), Or (Eq (f a b) a) (Eq (f a b) b)\no₁ o₂ : Option α\n⊢ Or (Eq (Option.liftOrGet f o₁ o₂) o₁) (Eq (Option.liftOrGet f o₁ o₂) o₂)","decl":"theorem liftOrGet_choice {f : α → α → α} (h : ∀ a b, f a b = a ∨ f a b = b) :\n    ∀ o₁ o₂, liftOrGet f o₁ o₂ = o₁ ∨ liftOrGet f o₁ o₂ = o₂\n  | none, none => Or.inl rfl\n  | some _, none => Or.inl rfl\n  | none, some _ => Or.inr rfl\n  | some a, some b => by simpa [liftOrGet] using h a b\n\n"}
{"name":"Option.casesOn'_none","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx : β\nf : α → β\n⊢ Eq (Option.none.casesOn' x f) x","decl":"@[simp]\ntheorem casesOn'_none (x : β) (f : α → β) : casesOn' none x f = x :=\n  rfl\n\n"}
{"name":"Option.casesOn'_some","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx : β\nf : α → β\na : α\n⊢ Eq ((Option.some a).casesOn' x f) (f a)","decl":"@[simp]\ntheorem casesOn'_some (x : β) (f : α → β) (a : α) : casesOn' (some a) x f = f a :=\n  rfl\n\n"}
{"name":"Option.casesOn'_coe","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nx : β\nf : α → β\na : α\n⊢ Eq ((Option.some a).casesOn' x f) (f a)","decl":"@[simp]\ntheorem casesOn'_coe (x : β) (f : α → β) (a : α) : casesOn' (a : Option α) x f = f a :=\n  rfl\n\n-- Porting note: Left-hand side does not simplify.\n-- @[simp]\n"}
{"name":"Option.casesOn'_none_coe","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Option α → β\no : Option α\n⊢ Eq (o.casesOn' (f Option.none) (Function.comp f fun a => Option.some a)) (f o)","decl":"theorem casesOn'_none_coe (f : Option α → β) (o : Option α) :\n    casesOn' o (f none) (f ∘ (fun a ↦ ↑a)) = f o := by cases o <;> rfl\n\n"}
{"name":"Option.casesOn'_eq_elim","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\nf : α → β\na : Option α\n⊢ Eq (a.casesOn' b f) (a.elim b f)","decl":"lemma casesOn'_eq_elim (b : β) (f : α → β) (a : Option α) :\n    Option.casesOn' a b f = Option.elim a b f := by cases a <;> rfl\n\n-- porting note: workaround for https://github.com/leanprover/lean4/issues/2049\n"}
{"name":"Option.orElse_eq_some","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\no o' : Option α\nx : α\n⊢ Iff (Eq (HOrElse.hOrElse o fun x => o') (Option.some x)) (Or (Eq o (Option.some x)) (And (Eq o Option.none) (Eq o' (Option.some x))))","decl":"theorem orElse_eq_some (o o' : Option α) (x : α) :\n    (o <|> o') = some x ↔ o = some x ∨ o = none ∧ o' = some x := by\n  cases o\n  · simp only [true_and, false_or, eq_self_iff_true, none_orElse, reduceCtorEq]\n  · simp only [some_orElse, or_false, false_and, reduceCtorEq]\n\n\n"}
{"name":"Option.orElse_eq_some'","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\no o' : Option α\nx : α\n⊢ Iff (Eq (o.orElse fun x => o') (Option.some x)) (Or (Eq o (Option.some x)) (And (Eq o Option.none) (Eq o' (Option.some x))))","decl":"theorem orElse_eq_some' (o o' : Option α) (x : α) :\n    o.orElse (fun _ ↦ o') = some x ↔ o = some x ∨ o = none ∧ o' = some x :=\n  Option.orElse_eq_some o o' x\n\n"}
{"name":"Option.orElse_eq_none","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\no o' : Option α\n⊢ Iff (Eq (HOrElse.hOrElse o fun x => o') Option.none) (And (Eq o Option.none) (Eq o' Option.none))","decl":"@[simp]\ntheorem orElse_eq_none (o o' : Option α) : (o <|> o') = none ↔ o = none ∧ o' = none := by\n  cases o\n  · simp only [true_and, none_orElse, eq_self_iff_true]\n  · simp only [some_orElse, reduceCtorEq, false_and]\n\n"}
{"name":"Option.orElse_eq_none'","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\no o' : Option α\n⊢ Iff (Eq (o.orElse fun x => o') Option.none) (And (Eq o Option.none) (Eq o' Option.none))","decl":"@[simp]\ntheorem orElse_eq_none' (o o' : Option α) : o.orElse (fun _ ↦ o') = none ↔ o = none ∧ o' = none :=\n  Option.orElse_eq_none o o'\n\n"}
{"name":"Option.choice_eq_none","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_5\ninst✝ : IsEmpty α\n⊢ Eq (Option.choice α) Option.none","decl":"theorem choice_eq_none (α : Type*) [IsEmpty α] : choice α = none :=\n  dif_neg (not_nonempty_iff_imp_false.mpr isEmptyElim)\n\n"}
{"name":"Option.elim_none_some","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Option α → β\n⊢ Eq (fun x => x.elim (f Option.none) (Function.comp f Option.some)) f","decl":"theorem elim_none_some (f : Option α → β) : (fun x ↦ Option.elim x (f none) (f ∘ some)) = f :=\n  funext fun o ↦ by cases o <;> rfl\n\n"}
{"name":"Option.elim_comp","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nh : α → β\nf : γ → α\nx : α\ni : Option γ\n⊢ Eq (i.elim (h x) fun j => h (f j)) (h (i.elim x f))","decl":"theorem elim_comp (h : α → β) {f : γ → α} {x : α} {i : Option γ} :\n    (i.elim (h x) fun j => h (f j)) = h (i.elim x f) := by cases i <;> rfl\n\n"}
{"name":"Option.elim_comp₂","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nh : α → β → γ\nf : γ → α\nx : α\ng : γ → β\ny : β\ni : Option γ\n⊢ Eq (i.elim (h x y) fun j => h (f j) (g j)) (h (i.elim x f) (i.elim y g))","decl":"theorem elim_comp₂ (h : α → β → γ) {f : γ → α} {x : α} {g : γ → β} {y : β}\n    {i : Option γ} : (i.elim (h x y) fun j => h (f j) (g j)) = h (i.elim x f) (i.elim y g) := by\n  cases i <;> rfl\n\n"}
{"name":"Option.elim_apply","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : γ → α → β\nx : α → β\ni : Option γ\ny : α\n⊢ Eq (i.elim x f y) (i.elim (x y) fun j => f j y)","decl":"theorem elim_apply {f : γ → α → β} {x : α → β} {i : Option γ} {y : α} :\n    i.elim x f y = i.elim (x y) fun j => f j y := by rw [elim_comp fun f : α → β => f y]\n\n"}
{"name":"Option.bnot_isSome","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\na : Option α\n⊢ Eq a.isSome.not a.isNone","decl":"@[simp]\nlemma bnot_isSome (a : Option α) : (! a.isSome) = a.isNone := by\n  cases a <;> simp\n\n"}
{"name":"Option.bnot_comp_isSome","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\n⊢ Eq (Function.comp (fun x => x.not) Option.isSome) Option.isNone","decl":"@[simp]\nlemma bnot_comp_isSome : (! ·) ∘ @Option.isSome α = Option.isNone := by\n  funext\n  simp\n\n"}
{"name":"Option.bnot_isNone","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\na : Option α\n⊢ Eq a.isNone.not a.isSome","decl":"@[simp]\nlemma bnot_isNone (a : Option α) : (! a.isNone) = a.isSome := by\n  cases a <;> simp\n\n"}
{"name":"Option.bnot_comp_isNone","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\n⊢ Eq (Function.comp (fun x => x.not) Option.isNone) Option.isSome","decl":"@[simp]\nlemma bnot_comp_isNone : (! ·) ∘ @Option.isNone α = Option.isSome := by\n  funext x\n  simp\n\n"}
{"name":"Option.isNone_eq_false_iff","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\na : Option α\n⊢ Iff (Eq a.isNone Bool.false) (Eq a.isSome Bool.true)","decl":"@[simp]\nlemma isNone_eq_false_iff (a : Option α) : Option.isNone a = false ↔ Option.isSome a := by\n  cases a <;> simp\n\n"}
{"name":"Option.eq_none_or_eq_some","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\na : Option α\n⊢ Or (Eq a Option.none) (Exists fun x => Eq a (Option.some x))","decl":"lemma eq_none_or_eq_some (a : Option α) : a = none ∨ ∃ x, a = some x :=\n  Option.exists.mp exists_eq'\n\n"}
{"name":"Option.forall_some_ne_iff_eq_none","module":"Mathlib.Data.Option.Basic","initialProofState":"α : Type u_1\no : Option α\n⊢ Iff (∀ (x : α), Ne (Option.some x) o) (Eq o Option.none)","decl":"lemma forall_some_ne_iff_eq_none {o : Option α} : (∀ (x : α), some x ≠ o) ↔ o = none := by\n  apply not_iff_not.1\n  simpa only [not_forall, not_not] using Option.ne_none_iff_exists.symm\n\n"}
