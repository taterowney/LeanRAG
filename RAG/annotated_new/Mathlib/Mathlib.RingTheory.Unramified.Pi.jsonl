{"name":"Algebra.FormallyUnramified.pi_iff","module":"Mathlib.RingTheory.Unramified.Pi","initialProofState":"R : Type (max u v)\nI : Type v\ninst✝³ : Finite I\nf : I → Type (max u v)\ninst✝² : CommRing R\ninst✝¹ : (i : I) → CommRing (f i)\ninst✝ : (i : I) → Algebra R (f i)\n⊢ Iff (Algebra.FormallyUnramified R ((i : I) → f i)) (∀ (i : I), Algebra.FormallyUnramified R (f i))","decl":"theorem pi_iff :\n    FormallyUnramified R (∀ i, f i) ↔ ∀ i, FormallyUnramified R (f i) := by\n  classical\n  cases nonempty_fintype I\n  constructor\n  · intro _ i\n    exact FormallyUnramified.of_surjective (Pi.evalAlgHom R f i) (Function.surjective_eval i)\n  · intro H\n    rw [iff_comp_injective]\n    intros B _ _ J hJ f₁ f₂ e\n    ext g\n    rw [← Finset.univ_sum_single g, map_sum, map_sum]\n    refine Finset.sum_congr rfl ?_\n    rintro x -\n    have hf : ∀ x, f₁ x - f₂ x ∈ J := by\n      intro g\n      rw [← Ideal.Quotient.eq_zero_iff_mem, map_sub, sub_eq_zero]\n      exact AlgHom.congr_fun e g\n    let e : ∀ i, f i := Pi.single x 1\n    have he : IsIdempotentElem e := by simp [IsIdempotentElem, e, ← Pi.single_mul]\n    have h₁ : (f₁ e) * (1 - f₂ e) = 0 := by\n      rw [← Ideal.mem_bot, ← hJ, ← ((he.map f₁).mul (he.map f₂).one_sub).eq, ← pow_two]\n      apply Ideal.pow_mem_pow\n      convert Ideal.mul_mem_left _ (f₁ e) (hf e) using 1\n      rw [mul_sub, mul_sub, mul_one, (he.map f₁).eq]\n    have h₂ : (f₂ e) * (1 - f₁ e) = 0 := by\n      rw [← Ideal.mem_bot, ← hJ, ← ((he.map f₂).mul (he.map f₁).one_sub).eq, ← pow_two]\n      apply Ideal.pow_mem_pow\n      convert Ideal.mul_mem_left _ (-f₂ e) (hf e) using 1\n      rw [neg_mul, mul_sub, mul_sub, mul_one, neg_sub, (he.map f₂).eq]\n    have H : f₁ e = f₂ e := by\n      trans f₁ e * f₂ e\n      · rw [← sub_eq_zero, ← h₁, mul_sub, mul_one]\n      · rw [eq_comm, ← sub_eq_zero, ← h₂, mul_sub, mul_one, mul_comm]\n    let J' := Ideal.span {1 - f₁ e}\n    let f₁' : f x →ₐ[R] B ⧸ J' := by\n      apply AlgHom.ofLinearMap\n        (((Ideal.Quotient.mkₐ R J').comp f₁).toLinearMap.comp (LinearMap.single _ _ x))\n      · simp only [AlgHom.comp_toLinearMap, LinearMap.coe_comp, LinearMap.coe_single,\n          Function.comp_apply, AlgHom.toLinearMap_apply, Ideal.Quotient.mkₐ_eq_mk]\n        rw [eq_comm, ← sub_eq_zero, ← (Ideal.Quotient.mk J').map_one, ← map_sub,\n          Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_span_singleton]\n      · intros r s; simp [Pi.single_mul]\n    let f₂' : f x →ₐ[R] B ⧸ J' := by\n      apply AlgHom.ofLinearMap\n        (((Ideal.Quotient.mkₐ R J').comp f₂).toLinearMap.comp (LinearMap.single _ _ x))\n      · simp only [AlgHom.comp_toLinearMap, LinearMap.coe_comp, LinearMap.coe_single,\n          Function.comp_apply, AlgHom.toLinearMap_apply, Ideal.Quotient.mkₐ_eq_mk]\n        rw [eq_comm, ← sub_eq_zero, ← (Ideal.Quotient.mk J').map_one, ← map_sub,\n          Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_span_singleton, H]\n      · intros r s; simp [Pi.single_mul]\n    suffices f₁' = f₂' by\n      have := AlgHom.congr_fun this (g x)\n      simp only [AlgHom.comp_toLinearMap, AlgHom.ofLinearMap_apply, LinearMap.coe_comp,\n        LinearMap.coe_single, Function.comp_apply, AlgHom.toLinearMap_apply, ← map_sub,\n        Ideal.Quotient.mkₐ_eq_mk, ← sub_eq_zero (b := Ideal.Quotient.mk J' _), sub_zero, f₁', f₂',\n        Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_span_singleton, J'] at this\n      obtain ⟨c, hc⟩ := this\n      apply_fun (f₁ e * ·) at hc\n      rwa [← mul_assoc, mul_sub, mul_sub, mul_one, (he.map f₁).eq, sub_self, zero_mul,\n        ← map_mul, H, ← map_mul, ← Pi.single_mul, one_mul, sub_eq_zero] at hc\n    apply FormallyUnramified.comp_injective (I := J.map (algebraMap _ _))\n    · rw [← Ideal.map_pow, hJ, Ideal.map_bot]\n    · ext r\n      rw [← sub_eq_zero]\n      simp only [Ideal.Quotient.algebraMap_eq, AlgHom.coe_comp, Ideal.Quotient.mkₐ_eq_mk,\n        Function.comp_apply, ← map_sub, Ideal.Quotient.eq_zero_iff_mem, f₁', f₂',\n        AlgHom.comp_toLinearMap, AlgHom.ofLinearMap_apply, LinearMap.coe_comp,\n        LinearMap.coe_single, Function.comp_apply, AlgHom.toLinearMap_apply,\n        Ideal.Quotient.mkₐ_eq_mk]\n      exact Ideal.mem_map_of_mem (Ideal.Quotient.mk J') (hf (Pi.single x r))\n\n"}
{"name":"Algebra.FormallyUnramified.instForall","module":"Mathlib.RingTheory.Unramified.Pi","initialProofState":"R : Type (max u v)\nI : Type v\ninst✝⁴ : Finite I\nf : I → Type (max u v)\ninst✝³ : CommRing R\ninst✝² : (i : I) → CommRing (f i)\ninst✝¹ : (i : I) → Algebra R (f i)\ninst✝ : ∀ (i : I), Algebra.FormallyUnramified R (f i)\n⊢ Algebra.FormallyUnramified R ((i : I) → f i)","decl":"instance [∀ i, FormallyUnramified R (f i)] : FormallyUnramified R (Π i, f i) :=\n  (pi_iff _).mpr ‹_›\n\n"}
