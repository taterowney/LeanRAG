{"name":"NNReal.instCanonicallyOrderedAdd","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ CanonicallyOrderedAdd NNReal","decl":"instance : CanonicallyOrderedAdd ℝ≥0 := Nonneg.canonicallyOrderedAdd\n"}
{"name":"NNReal.instNoZeroDivisors","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ NoZeroDivisors NNReal","decl":"instance : NoZeroDivisors ℝ≥0 := Nonneg.noZeroDivisors\n"}
{"name":"NNReal.instDenselyOrdered","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ DenselyOrdered NNReal","decl":"instance instDenselyOrdered : DenselyOrdered ℝ≥0 := Nonneg.instDenselyOrdered\n"}
{"name":"NNReal.instArchimedean","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Archimedean NNReal","decl":"instance instArchimedean : Archimedean ℝ≥0 := Nonneg.instArchimedean\n"}
{"name":"NNReal.instMulArchimedean","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ MulArchimedean NNReal","decl":"instance instMulArchimedean : MulArchimedean ℝ≥0 := Nonneg.instMulArchimedean\n"}
{"name":"NNReal.instOrderedSub","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ OrderedSub NNReal","decl":"instance : OrderedSub ℝ≥0 := Nonneg.orderedSub\n\n-- a computable copy of `Nonneg.instNNRatCast`\n"}
{"name":"NNReal.val_eq_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"n : NNReal\n⊢ Eq ↑n ↑n","decl":"@[simp]\ntheorem val_eq_coe (n : ℝ≥0) : n.val = n :=\n  rfl\n\n"}
{"name":"NNReal.canLift","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ CanLift Real NNReal NNReal.toReal fun r => LE.le 0 r","decl":"instance canLift : CanLift ℝ ℝ≥0 toReal fun r => 0 ≤ r :=\n  Subtype.canLift _\n\n"}
{"name":"NNReal.eq_iff","module":"Mathlib.Data.NNReal.Defs","initialProofState":"n m : NNReal\n⊢ Iff (Eq n m) (Eq ↑n ↑m)","decl":"@[ext] protected theorem eq {n m : ℝ≥0} : (n : ℝ) = (m : ℝ) → n = m :=\n  Subtype.eq\n\n"}
{"name":"NNReal.eq","module":"Mathlib.Data.NNReal.Defs","initialProofState":"n m : NNReal\na✝ : Eq ↑n ↑m\n⊢ Eq n m","decl":"@[ext] protected theorem eq {n m : ℝ≥0} : (n : ℝ) = (m : ℝ) → n = m :=\n  Subtype.eq\n\n"}
{"name":"NNReal.ne_iff","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x y : NNReal\n⊢ Iff (Ne ↑x ↑y) (Ne x y)","decl":"theorem ne_iff {x y : ℝ≥0} : (x : ℝ) ≠ (y : ℝ) ↔ x ≠ y :=\n  not_congr <| NNReal.eq_iff.symm\n\n"}
{"name":"NNReal.forall","module":"Mathlib.Data.NNReal.Defs","initialProofState":"p : NNReal → Prop\n⊢ Iff (∀ (x : NNReal), p x) (∀ (x : Real) (hx : LE.le 0 x), p ⟨x, hx⟩)","decl":"protected theorem «forall» {p : ℝ≥0 → Prop} :\n    (∀ x : ℝ≥0, p x) ↔ ∀ (x : ℝ) (hx : 0 ≤ x), p ⟨x, hx⟩ :=\n  Subtype.forall\n\n"}
{"name":"NNReal.exists","module":"Mathlib.Data.NNReal.Defs","initialProofState":"p : NNReal → Prop\n⊢ Iff (Exists fun x => p x) (Exists fun x => Exists fun hx => p ⟨x, hx⟩)","decl":"protected theorem «exists» {p : ℝ≥0 → Prop} :\n    (∃ x : ℝ≥0, p x) ↔ ∃ (x : ℝ) (hx : 0 ≤ x), p ⟨x, hx⟩ :=\n  Subtype.exists\n\n"}
{"name":"Real.coe_toNNReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\nhr : LE.le 0 r\n⊢ Eq (↑r.toNNReal) r","decl":"theorem _root_.Real.coe_toNNReal (r : ℝ) (hr : 0 ≤ r) : (Real.toNNReal r : ℝ) = r :=\n  max_eq_left hr\n\n"}
{"name":"Real.toNNReal_of_nonneg","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\nhr : LE.le 0 r\n⊢ Eq r.toNNReal ⟨r, hr⟩","decl":"theorem _root_.Real.toNNReal_of_nonneg {r : ℝ} (hr : 0 ≤ r) : r.toNNReal = ⟨r, hr⟩ := by\n  simp_rw [Real.toNNReal, max_eq_left hr]\n\n"}
{"name":"Real.le_coe_toNNReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\n⊢ LE.le r ↑r.toNNReal","decl":"theorem _root_.Real.le_coe_toNNReal (r : ℝ) : r ≤ Real.toNNReal r :=\n  le_max_left r 0\n\n"}
{"name":"NNReal.coe_nonneg","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\n⊢ LE.le 0 ↑r","decl":"@[bound] theorem coe_nonneg (r : ℝ≥0) : (0 : ℝ) ≤ r := r.2\n\n"}
{"name":"NNReal.coe_mk","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a : Real\nha : LE.le 0 a\n⊢ Eq (↑⟨a, ha⟩) a","decl":"@[simp, norm_cast] theorem coe_mk (a : ℝ) (ha) : toReal ⟨a, ha⟩ = a := rfl\n\n"}
{"name":"NNReal.coe_injective","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Function.Injective NNReal.toReal","decl":"protected theorem coe_injective : Injective ((↑) : ℝ≥0 → ℝ) := Subtype.coe_injective\n\n"}
{"name":"NNReal.coe_inj","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r₁ r₂ : NNReal\n⊢ Iff (Eq ↑r₁ ↑r₂) (Eq r₁ r₂)","decl":"@[simp, norm_cast] lemma coe_inj {r₁ r₂ : ℝ≥0} : (r₁ : ℝ) = r₂ ↔ r₁ = r₂ :=\n  NNReal.coe_injective.eq_iff\n\n\n"}
{"name":"NNReal.coe_zero","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Eq (↑0) 0","decl":"@[simp, norm_cast] lemma coe_zero : ((0 : ℝ≥0) : ℝ) = 0 := rfl\n\n"}
{"name":"NNReal.coe_one","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Eq (↑1) 1","decl":"@[simp, norm_cast] lemma coe_one : ((1 : ℝ≥0) : ℝ) = 1 := rfl\n\n"}
{"name":"NNReal.mk_zero","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Eq ⟨0, ⋯⟩ 0","decl":"@[simp] lemma mk_zero : (⟨0, le_rfl⟩ : ℝ≥0) = 0 := rfl\n"}
{"name":"NNReal.mk_one","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Eq ⟨1, ⋯⟩ 1","decl":"@[simp] lemma mk_one : (⟨1, zero_le_one⟩ : ℝ≥0) = 1 := rfl\n\n"}
{"name":"NNReal.coe_add","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r₁ r₂ : NNReal\n⊢ Eq (↑(HAdd.hAdd r₁ r₂)) (HAdd.hAdd ↑r₁ ↑r₂)","decl":"@[simp, norm_cast]\nprotected theorem coe_add (r₁ r₂ : ℝ≥0) : ((r₁ + r₂ : ℝ≥0) : ℝ) = r₁ + r₂ :=\n  rfl\n\n"}
{"name":"NNReal.coe_mul","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r₁ r₂ : NNReal\n⊢ Eq (↑(HMul.hMul r₁ r₂)) (HMul.hMul ↑r₁ ↑r₂)","decl":"@[simp, norm_cast]\nprotected theorem coe_mul (r₁ r₂ : ℝ≥0) : ((r₁ * r₂ : ℝ≥0) : ℝ) = r₁ * r₂ :=\n  rfl\n\n"}
{"name":"NNReal.coe_inv","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\n⊢ Eq (↑(Inv.inv r)) (Inv.inv ↑r)","decl":"@[simp, norm_cast]\nprotected theorem coe_inv (r : ℝ≥0) : ((r⁻¹ : ℝ≥0) : ℝ) = (r : ℝ)⁻¹ :=\n  rfl\n\n"}
{"name":"NNReal.coe_div","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r₁ r₂ : NNReal\n⊢ Eq (↑(HDiv.hDiv r₁ r₂)) (HDiv.hDiv ↑r₁ ↑r₂)","decl":"@[simp, norm_cast]\nprotected theorem coe_div (r₁ r₂ : ℝ≥0) : ((r₁ / r₂ : ℝ≥0) : ℝ) = (r₁ : ℝ) / r₂ :=\n  rfl\n\n"}
{"name":"NNReal.coe_two","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Eq (↑2) 2","decl":"protected theorem coe_two : ((2 : ℝ≥0) : ℝ) = 2 := rfl\n\n"}
{"name":"NNReal.coe_sub","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r₁ r₂ : NNReal\nh : LE.le r₂ r₁\n⊢ Eq (↑(HSub.hSub r₁ r₂)) (HSub.hSub ↑r₁ ↑r₂)","decl":"@[simp, norm_cast]\nprotected theorem coe_sub {r₁ r₂ : ℝ≥0} (h : r₂ ≤ r₁) : ((r₁ - r₂ : ℝ≥0) : ℝ) = ↑r₁ - ↑r₂ :=\n  max_eq_left <| le_sub_comm.2 <| by simp [show (r₂ : ℝ) ≤ r₁ from h]\n\n"}
{"name":"NNReal.coe_eq_zero","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\n⊢ Iff (Eq (↑r) 0) (Eq r 0)","decl":"@[simp, norm_cast] lemma coe_eq_zero : (r : ℝ) = 0 ↔ r = 0 := by rw [← coe_zero, coe_inj]\n\n"}
{"name":"NNReal.coe_eq_one","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\n⊢ Iff (Eq (↑r) 1) (Eq r 1)","decl":"@[simp, norm_cast] lemma coe_eq_one : (r : ℝ) = 1 ↔ r = 1 := by rw [← coe_one, coe_inj]\n\n"}
{"name":"NNReal.coe_ne_zero","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\n⊢ Iff (Ne (↑r) 0) (Ne r 0)","decl":"@[norm_cast] lemma coe_ne_zero : (r : ℝ) ≠ 0 ↔ r ≠ 0 := coe_eq_zero.not\n\n"}
{"name":"NNReal.coe_ne_one","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\n⊢ Iff (Ne (↑r) 1) (Ne r 1)","decl":"@[norm_cast] lemma coe_ne_one : (r : ℝ) ≠ 1 ↔ r ≠ 1 := coe_eq_one.not\n\n"}
{"name":"NNReal.coe_toRealHom","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Eq (⇑NNReal.toRealHom) NNReal.toReal","decl":"@[simp] theorem coe_toRealHom : ⇑toRealHom = toReal := rfl\n\n"}
{"name":"NNReal.smul_def","module":"Mathlib.Data.NNReal.Defs","initialProofState":"M : Type u_1\ninst✝ : MulAction Real M\nc : NNReal\nx : M\n⊢ Eq (HSMul.hSMul c x) (HSMul.hSMul (↑c) x)","decl":"theorem smul_def {M : Type*} [MulAction ℝ M] (c : ℝ≥0) (x : M) : c • x = (c : ℝ) • x :=\n  rfl\n\n"}
{"name":"NNReal.instIsScalarTowerOfReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : MulAction Real M\ninst✝² : MulAction Real N\ninst✝¹ : SMul M N\ninst✝ : IsScalarTower Real M N\n⊢ IsScalarTower NNReal M N","decl":"instance {M N : Type*} [MulAction ℝ M] [MulAction ℝ N] [SMul M N] [IsScalarTower ℝ M N] :\n    IsScalarTower ℝ≥0 M N where smul_assoc r := smul_assoc (r : ℝ)\n\n"}
{"name":"NNReal.smulCommClass_left","module":"Mathlib.Data.NNReal.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulAction Real N\ninst✝¹ : SMul M N\ninst✝ : SMulCommClass Real M N\n⊢ SMulCommClass NNReal M N","decl":"instance smulCommClass_left {M N : Type*} [MulAction ℝ N] [SMul M N] [SMulCommClass ℝ M N] :\n    SMulCommClass ℝ≥0 M N where smul_comm r := smul_comm (r : ℝ)\n\n"}
{"name":"NNReal.smulCommClass_right","module":"Mathlib.Data.NNReal.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulAction Real N\ninst✝¹ : SMul M N\ninst✝ : SMulCommClass M Real N\n⊢ SMulCommClass M NNReal N","decl":"instance smulCommClass_right {M N : Type*} [MulAction ℝ N] [SMul M N] [SMulCommClass M ℝ N] :\n    SMulCommClass M ℝ≥0 N where smul_comm m r := smul_comm m (r : ℝ)\n\n"}
{"name":"NNReal.coe_pow","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\nn : Nat\n⊢ Eq (↑(HPow.hPow r n)) (HPow.hPow (↑r) n)","decl":"@[simp, norm_cast]\ntheorem coe_pow (r : ℝ≥0) (n : ℕ) : ((r ^ n : ℝ≥0) : ℝ) = (r : ℝ) ^ n := rfl\n\n"}
{"name":"NNReal.coe_zpow","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\nn : Int\n⊢ Eq (↑(HPow.hPow r n)) (HPow.hPow (↑r) n)","decl":"@[simp, norm_cast]\ntheorem coe_zpow (r : ℝ≥0) (n : ℤ) : ((r ^ n : ℝ≥0) : ℝ) = (r : ℝ) ^ n := rfl\n\n"}
{"name":"NNReal.coe_nsmul","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\nn : Nat\n⊢ Eq (↑(HSMul.hSMul n r)) (HSMul.hSMul n ↑r)","decl":"@[simp, norm_cast] lemma coe_nsmul (r : ℝ≥0) (n : ℕ) : ↑(n • r) = n • (r : ℝ) := rfl\n"}
{"name":"NNReal.coe_nnqsmul","module":"Mathlib.Data.NNReal.Defs","initialProofState":"q : NNRat\nx : NNReal\n⊢ Eq (↑(HSMul.hSMul q x)) (HSMul.hSMul q ↑x)","decl":"@[simp, norm_cast] lemma coe_nnqsmul (q : ℚ≥0) (x : ℝ≥0) : ↑(q • x) = (q • x : ℝ) := rfl\n\n"}
{"name":"NNReal.coe_natCast","module":"Mathlib.Data.NNReal.Defs","initialProofState":"n : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\nprotected theorem coe_natCast (n : ℕ) : (↑(↑n : ℝ≥0) : ℝ) = n :=\n  map_natCast toRealHom n\n\n"}
{"name":"NNReal.coe_ofNat","module":"Mathlib.Data.NNReal.Defs","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast]\nprotected theorem coe_ofNat (n : ℕ) [n.AtLeastTwo] : ((ofNat(n) : ℝ≥0) : ℝ) = ofNat(n) :=\n  rfl\n\n"}
{"name":"NNReal.coe_ofScientific","module":"Mathlib.Data.NNReal.Defs","initialProofState":"m : Nat\ns : Bool\ne : Nat\n⊢ Eq (↑(OfScientific.ofScientific m s e)) (OfScientific.ofScientific m s e)","decl":"@[simp, norm_cast]\nprotected theorem coe_ofScientific (m : ℕ) (s : Bool) (e : ℕ) :\n    ↑(OfScientific.ofScientific m s e : ℝ≥0) = (OfScientific.ofScientific m s e : ℝ) :=\n  rfl\n\n"}
{"name":"NNReal.algebraMap_eq_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Eq (⇑(algebraMap NNReal Real)) NNReal.toReal","decl":"@[simp, norm_cast]\nlemma algebraMap_eq_coe : (algebraMap ℝ≥0 ℝ : ℝ≥0 → ℝ) = (↑) := rfl\n\n"}
{"name":"NNReal.coe_le_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r₁ r₂ : NNReal\n⊢ Iff (LE.le ↑r₁ ↑r₂) (LE.le r₁ r₂)","decl":"@[simp, norm_cast] lemma coe_le_coe : (r₁ : ℝ) ≤ r₂ ↔ r₁ ≤ r₂ := Iff.rfl\n\n"}
{"name":"NNReal.coe_lt_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r₁ r₂ : NNReal\n⊢ Iff (LT.lt ↑r₁ ↑r₂) (LT.lt r₁ r₂)","decl":"@[simp, norm_cast] lemma coe_lt_coe : (r₁ : ℝ) < r₂ ↔ r₁ < r₂ := Iff.rfl\n\n"}
{"name":"NNReal.coe_pos","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\n⊢ Iff (LT.lt 0 ↑r) (LT.lt 0 r)","decl":"@[simp, norm_cast] lemma coe_pos : (0 : ℝ) < r ↔ 0 < r := Iff.rfl\n\n"}
{"name":"NNReal.one_le_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\n⊢ Iff (LE.le 1 ↑r) (LE.le 1 r)","decl":"@[simp, norm_cast] lemma one_le_coe : 1 ≤ (r : ℝ) ↔ 1 ≤ r := by rw [← coe_le_coe, coe_one]\n"}
{"name":"NNReal.one_lt_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\n⊢ Iff (LT.lt 1 ↑r) (LT.lt 1 r)","decl":"@[simp, norm_cast] lemma one_lt_coe : 1 < (r : ℝ) ↔ 1 < r := by rw [← coe_lt_coe, coe_one]\n"}
{"name":"NNReal.coe_le_one","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\n⊢ Iff (LE.le (↑r) 1) (LE.le r 1)","decl":"@[simp, norm_cast] lemma coe_le_one : (r : ℝ) ≤ 1 ↔ r ≤ 1 := by rw [← coe_le_coe, coe_one]\n"}
{"name":"NNReal.coe_lt_one","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\n⊢ Iff (LT.lt (↑r) 1) (LT.lt r 1)","decl":"@[simp, norm_cast] lemma coe_lt_one : (r : ℝ) < 1 ↔ r < 1 := by rw [← coe_lt_coe, coe_one]\n\n"}
{"name":"NNReal.coe_mono","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Monotone NNReal.toReal","decl":"@[mono] lemma coe_mono : Monotone ((↑) : ℝ≥0 → ℝ) := fun _ _ => NNReal.coe_le_coe.2\n\n"}
{"name":"NNReal.GCongr.toReal_le_toReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r₁ r₂ : NNReal\na✝ : LE.le r₁ r₂\n⊢ LE.le ↑r₁ ↑r₂","decl":"/-- Alias for the use of `gcongr` -/\n@[gcongr] alias ⟨_, GCongr.toReal_le_toReal⟩ := coe_le_coe\n\n"}
{"name":"Real.toNNReal_mono","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Monotone Real.toNNReal","decl":"protected theorem _root_.Real.toNNReal_mono : Monotone Real.toNNReal := fun _ _ h =>\n  max_le_max h (le_refl 0)\n\n"}
{"name":"Real.toNNReal_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\n⊢ Eq (↑r).toNNReal r","decl":"@[simp]\ntheorem _root_.Real.toNNReal_coe {r : ℝ≥0} : Real.toNNReal r = r :=\n  NNReal.eq <| max_eq_left r.2\n\n"}
{"name":"NNReal.mk_natCast","module":"Mathlib.Data.NNReal.Defs","initialProofState":"n : Nat\n⊢ Eq ⟨↑n, ⋯⟩ ↑n","decl":"@[simp]\ntheorem mk_natCast (n : ℕ) : @Eq ℝ≥0 (⟨(n : ℝ), n.cast_nonneg⟩ : ℝ≥0) n :=\n  NNReal.eq (NNReal.coe_natCast n).symm\n\n-- Porting note: place this in the `Real` namespace\n"}
{"name":"NNReal.toNNReal_coe_nat","module":"Mathlib.Data.NNReal.Defs","initialProofState":"n : Nat\n⊢ Eq (↑n).toNNReal ↑n","decl":"@[simp]\ntheorem toNNReal_coe_nat (n : ℕ) : Real.toNNReal n = n :=\n  NNReal.eq <| by simp [Real.coe_toNNReal]\n\n"}
{"name":"Real.toNNReal_ofNat","module":"Mathlib.Data.NNReal.Defs","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).toNNReal (OfNat.ofNat n)","decl":"@[simp]\ntheorem _root_.Real.toNNReal_ofNat (n : ℕ) [n.AtLeastTwo] :\n    Real.toNNReal ofNat(n) = OfNat.ofNat n :=\n  toNNReal_coe_nat n\n\n"}
{"name":"NNReal.instPosSMulStrictMono","module":"Mathlib.Data.NNReal.Defs","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : MulAction Real α\ninst✝ : PosSMulStrictMono Real α\n⊢ PosSMulStrictMono NNReal α","decl":"instance instPosSMulStrictMono {α} [Preorder α] [MulAction ℝ α] [PosSMulStrictMono ℝ α] :\n    PosSMulStrictMono ℝ≥0 α where\n  elim _r hr _a₁ _a₂ ha := (smul_lt_smul_of_pos_left ha (coe_pos.2 hr):)\n\n"}
{"name":"NNReal.instSMulPosStrictMono","module":"Mathlib.Data.NNReal.Defs","initialProofState":"α : Type u_2\ninst✝³ : Zero α\ninst✝² : Preorder α\ninst✝¹ : MulAction Real α\ninst✝ : SMulPosStrictMono Real α\n⊢ SMulPosStrictMono NNReal α","decl":"instance instSMulPosStrictMono {α} [Zero α] [Preorder α] [MulAction ℝ α] [SMulPosStrictMono ℝ α] :\n    SMulPosStrictMono ℝ≥0 α where\n  elim _a ha _r₁ _r₂ hr := (smul_lt_smul_of_pos_right (coe_lt_coe.2 hr) ha :)\n\n"}
{"name":"NNReal.orderIsoIccZeroCoe_apply_coe_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a : NNReal\nb : ↑(Set.Icc 0 ↑a)\n⊢ Eq ↑↑(a.orderIsoIccZeroCoe b) ↑b","decl":"@[simp]\ntheorem orderIsoIccZeroCoe_apply_coe_coe (a : ℝ≥0) (b : Set.Icc (0 : ℝ) a) :\n    (orderIsoIccZeroCoe a b : ℝ) = b :=\n  rfl\n\n"}
{"name":"NNReal.orderIsoIccZeroCoe_symm_apply_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a : NNReal\nb : ↑(Set.Iic a)\n⊢ Eq ↑(a.orderIsoIccZeroCoe.symm b) ↑↑b","decl":"@[simp]\ntheorem orderIsoIccZeroCoe_symm_apply_coe (a : ℝ≥0) (b : Set.Iic a) :\n    ((orderIsoIccZeroCoe a).symm b : ℝ) = b :=\n  rfl\n\n-- note we need the `@` to make the `Membership.mem` have a sensible type\n"}
{"name":"NNReal.coe_image","module":"Mathlib.Data.NNReal.Defs","initialProofState":"s : Set NNReal\n⊢ Eq (Set.image NNReal.toReal s) (setOf fun x => Exists fun h => Membership.mem s ⟨x, h⟩)","decl":"theorem coe_image {s : Set ℝ≥0} :\n    (↑) '' s = { x : ℝ | ∃ h : 0 ≤ x, @Membership.mem ℝ≥0 _ _ s ⟨x, h⟩ } :=\n  Subtype.coe_image\n\n"}
{"name":"NNReal.bddAbove_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"s : Set NNReal\n⊢ Iff (BddAbove (Set.image NNReal.toReal s)) (BddAbove s)","decl":"theorem bddAbove_coe {s : Set ℝ≥0} : BddAbove (((↑) : ℝ≥0 → ℝ) '' s) ↔ BddAbove s :=\n  Iff.intro\n    (fun ⟨b, hb⟩ =>\n      ⟨Real.toNNReal b, fun ⟨y, _⟩ hys =>\n        show y ≤ max b 0 from le_max_of_le_left <| hb <| Set.mem_image_of_mem _ hys⟩)\n    fun ⟨b, hb⟩ => ⟨b, fun _ ⟨_, hx, eq⟩ => eq ▸ hb hx⟩\n\n"}
{"name":"NNReal.bddBelow_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"s : Set NNReal\n⊢ BddBelow (Set.image NNReal.toReal s)","decl":"theorem bddBelow_coe (s : Set ℝ≥0) : BddBelow (((↑) : ℝ≥0 → ℝ) '' s) :=\n  ⟨0, fun _ ⟨q, _, eq⟩ => eq ▸ q.2⟩\n\n"}
{"name":"NNReal.coe_sSup","module":"Mathlib.Data.NNReal.Defs","initialProofState":"s : Set NNReal\n⊢ Eq (↑(SupSet.sSup s)) (SupSet.sSup (Set.image NNReal.toReal s))","decl":"@[norm_cast]\ntheorem coe_sSup (s : Set ℝ≥0) : (↑(sSup s) : ℝ) = sSup (((↑) : ℝ≥0 → ℝ) '' s) := by\n  rcases Set.eq_empty_or_nonempty s with rfl|hs\n  · simp\n  by_cases H : BddAbove s\n  · have A : sSup (Subtype.val '' s) ∈ Set.Ici 0 := by\n      apply Real.sSup_nonneg\n      rintro - ⟨y, -, rfl⟩\n      exact y.2\n    exact (@subset_sSup_of_within ℝ (Set.Ici (0 : ℝ)) _ _ (_) s hs H A).symm\n  · simp only [csSup_of_not_bddAbove H, csSup_empty, bot_eq_zero', NNReal.coe_zero]\n    apply (Real.sSup_of_not_bddAbove ?_).symm\n    contrapose! H\n    exact bddAbove_coe.1 H\n\n"}
{"name":"NNReal.coe_iSup","module":"Mathlib.Data.NNReal.Defs","initialProofState":"ι : Sort u_2\ns : ι → NNReal\n⊢ Eq (↑(iSup fun i => s i)) (iSup fun i => ↑(s i))","decl":"@[simp, norm_cast] -- Porting note: add `simp`\ntheorem coe_iSup {ι : Sort*} (s : ι → ℝ≥0) : (↑(⨆ i, s i) : ℝ) = ⨆ i, ↑(s i) := by\n  rw [iSup, iSup, coe_sSup, ← Set.range_comp]; rfl\n\n"}
{"name":"NNReal.coe_sInf","module":"Mathlib.Data.NNReal.Defs","initialProofState":"s : Set NNReal\n⊢ Eq (↑(InfSet.sInf s)) (InfSet.sInf (Set.image NNReal.toReal s))","decl":"@[norm_cast]\ntheorem coe_sInf (s : Set ℝ≥0) : (↑(sInf s) : ℝ) = sInf (((↑) : ℝ≥0 → ℝ) '' s) := by\n  rcases Set.eq_empty_or_nonempty s with rfl|hs\n  · simp only [Set.image_empty, Real.sInf_empty, coe_eq_zero]\n    exact @subset_sInf_emptyset ℝ (Set.Ici (0 : ℝ)) _ _ (_)\n  have A : sInf (Subtype.val '' s) ∈ Set.Ici 0 := by\n    apply Real.sInf_nonneg\n    rintro - ⟨y, -, rfl⟩\n    exact y.2\n  exact (@subset_sInf_of_within ℝ (Set.Ici (0 : ℝ)) _ _ (_) s hs (OrderBot.bddBelow s) A).symm\n\n"}
{"name":"NNReal.sInf_empty","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Eq (InfSet.sInf EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem sInf_empty : sInf (∅ : Set ℝ≥0) = 0 := by\n  rw [← coe_eq_zero, coe_sInf, Set.image_empty, Real.sInf_empty]\n\n"}
{"name":"NNReal.coe_iInf","module":"Mathlib.Data.NNReal.Defs","initialProofState":"ι : Sort u_2\ns : ι → NNReal\n⊢ Eq (↑(iInf fun i => s i)) (iInf fun i => ↑(s i))","decl":"@[norm_cast]\ntheorem coe_iInf {ι : Sort*} (s : ι → ℝ≥0) : (↑(⨅ i, s i) : ℝ) = ⨅ i, ↑(s i) := by\n  rw [iInf, iInf, coe_sInf, ← Set.range_comp]; rfl\n\n-- Short-circuit instance search\n"}
{"name":"NNReal.addLeftMono","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ AddLeftMono NNReal","decl":"instance addLeftMono : AddLeftMono ℝ≥0 := inferInstance\n"}
{"name":"NNReal.addLeftReflectLT","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ AddLeftReflectLT NNReal","decl":"instance addLeftReflectLT : AddLeftReflectLT ℝ≥0 := inferInstance\n"}
{"name":"NNReal.mulLeftMono","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ MulLeftMono NNReal","decl":"instance mulLeftMono : MulLeftMono ℝ≥0 := inferInstance\n\n"}
{"name":"NNReal.le_of_forall_pos_le_add","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b : NNReal\nh : ∀ (ε : NNReal), LT.lt 0 ε → LE.le a (HAdd.hAdd b ε)\n⊢ LE.le a b","decl":"@[deprecated le_of_forall_pos_le_add (since := \"2024-10-17\")]\nprotected theorem le_of_forall_pos_le_add {a b : ℝ≥0} (h : ∀ ε, 0 < ε → a ≤ b + ε) : a ≤ b :=\n   le_of_forall_pos_le_add h\n\n"}
{"name":"NNReal.lt_iff_exists_rat_btwn","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b : NNReal\n⊢ Iff (LT.lt a b) (Exists fun q => And (LE.le 0 q) (And (LT.lt a (↑q).toNNReal) (LT.lt (↑q).toNNReal b)))","decl":"theorem lt_iff_exists_rat_btwn (a b : ℝ≥0) :\n    a < b ↔ ∃ q : ℚ, 0 ≤ q ∧ a < Real.toNNReal q ∧ Real.toNNReal q < b :=\n  Iff.intro\n    (fun h : (↑a : ℝ) < (↑b : ℝ) =>\n      let ⟨q, haq, hqb⟩ := exists_rat_btwn h\n      have : 0 ≤ (q : ℝ) := le_trans a.2 <| le_of_lt haq\n      ⟨q, Rat.cast_nonneg.1 this, by\n        simp [Real.coe_toNNReal _ this, NNReal.coe_lt_coe.symm, haq, hqb]⟩)\n    fun ⟨_, _, haq, hqb⟩ => lt_trans haq hqb\n\n"}
{"name":"NNReal.bot_eq_zero","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Eq Bot.bot 0","decl":"theorem bot_eq_zero : (⊥ : ℝ≥0) = 0 := rfl\n\n"}
{"name":"NNReal.mul_sup","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b c : NNReal\n⊢ Eq (HMul.hMul a (Max.max b c)) (Max.max (HMul.hMul a b) (HMul.hMul a c))","decl":"theorem mul_sup (a b c : ℝ≥0) : a * (b ⊔ c) = a * b ⊔ a * c :=\n  mul_max_of_nonneg _ _ <| zero_le a\n\n"}
{"name":"NNReal.sup_mul","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b c : NNReal\n⊢ Eq (HMul.hMul (Max.max a b) c) (Max.max (HMul.hMul a c) (HMul.hMul b c))","decl":"theorem sup_mul (a b c : ℝ≥0) : (a ⊔ b) * c = a * c ⊔ b * c :=\n  max_mul_of_nonneg _ _ <| zero_le c\n\n"}
{"name":"NNReal.coe_max","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x y : NNReal\n⊢ Eq (↑(Max.max x y)) (Max.max ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_max (x y : ℝ≥0) : ((max x y : ℝ≥0) : ℝ) = max (x : ℝ) (y : ℝ) :=\n  NNReal.coe_mono.map_max\n\n"}
{"name":"NNReal.coe_min","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x y : NNReal\n⊢ Eq (↑(Min.min x y)) (Min.min ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_min (x y : ℝ≥0) : ((min x y : ℝ≥0) : ℝ) = min (x : ℝ) (y : ℝ) :=\n  NNReal.coe_mono.map_min\n\n"}
{"name":"NNReal.zero_le_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"q : NNReal\n⊢ LE.le 0 ↑q","decl":"@[simp]\ntheorem zero_le_coe {q : ℝ≥0} : 0 ≤ (q : ℝ) :=\n  q.2\n\n"}
{"name":"NNReal.instOrderedSMul","module":"Mathlib.Data.NNReal.Defs","initialProofState":"M : Type u_2\ninst✝² : OrderedAddCommMonoid M\ninst✝¹ : Module Real M\ninst✝ : OrderedSMul Real M\n⊢ OrderedSMul NNReal M","decl":"instance instOrderedSMul {M : Type*} [OrderedAddCommMonoid M] [Module ℝ M] [OrderedSMul ℝ M] :\n    OrderedSMul ℝ≥0 M where\n  smul_lt_smul_of_pos hab hc := (smul_lt_smul_of_pos_left hab (NNReal.coe_pos.2 hc) :)\n  lt_of_smul_lt_smul_of_pos {_ _ c} hab _ :=\n    lt_of_smul_lt_smul_of_nonneg_left (by exact hab) (NNReal.coe_nonneg c)\n\n"}
{"name":"Real.coe_toNNReal'","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\n⊢ Eq (↑r.toNNReal) (Max.max r 0)","decl":"@[simp]\ntheorem coe_toNNReal' (r : ℝ) : (Real.toNNReal r : ℝ) = max r 0 :=\n  rfl\n\n"}
{"name":"Real.toNNReal_zero","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Eq (Real.toNNReal 0) 0","decl":"@[simp]\ntheorem toNNReal_zero : Real.toNNReal 0 = 0 := NNReal.eq <| coe_toNNReal _ le_rfl\n\n"}
{"name":"Real.toNNReal_one","module":"Mathlib.Data.NNReal.Defs","initialProofState":"⊢ Eq (Real.toNNReal 1) 1","decl":"@[simp]\ntheorem toNNReal_one : Real.toNNReal 1 = 1 := NNReal.eq <| coe_toNNReal _ zero_le_one\n\n"}
{"name":"Real.toNNReal_pos","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\n⊢ Iff (LT.lt 0 r.toNNReal) (LT.lt 0 r)","decl":"@[simp]\ntheorem toNNReal_pos {r : ℝ} : 0 < Real.toNNReal r ↔ 0 < r := by\n  simp [← NNReal.coe_lt_coe, lt_irrefl]\n\n"}
{"name":"Real.toNNReal_eq_zero","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\n⊢ Iff (Eq r.toNNReal 0) (LE.le r 0)","decl":"@[simp]\ntheorem toNNReal_eq_zero {r : ℝ} : Real.toNNReal r = 0 ↔ r ≤ 0 := by\n  simpa [-toNNReal_pos] using not_iff_not.2 (@toNNReal_pos r)\n\n"}
{"name":"Real.toNNReal_of_nonpos","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\na✝ : LE.le r 0\n⊢ Eq r.toNNReal 0","decl":"theorem toNNReal_of_nonpos {r : ℝ} : r ≤ 0 → Real.toNNReal r = 0 :=\n  toNNReal_eq_zero.2\n\n"}
{"name":"Real.toNNReal_eq_iff_eq_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\np : NNReal\nhp : Ne p 0\n⊢ Iff (Eq r.toNNReal p) (Eq r ↑p)","decl":"lemma toNNReal_eq_iff_eq_coe {r : ℝ} {p : ℝ≥0} (hp : p ≠ 0) : r.toNNReal = p ↔ r = p :=\n  ⟨fun h ↦ h ▸ (coe_toNNReal _ <| not_lt.1 fun hlt ↦ hp <| h ▸ toNNReal_of_nonpos hlt.le).symm,\n    fun h ↦ h.symm ▸ toNNReal_coe⟩\n\n"}
{"name":"Real.toNNReal_eq_one","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\n⊢ Iff (Eq r.toNNReal 1) (Eq r 1)","decl":"@[simp]\nlemma toNNReal_eq_one {r : ℝ} : r.toNNReal = 1 ↔ r = 1 := toNNReal_eq_iff_eq_coe one_ne_zero\n\n"}
{"name":"Real.toNNReal_eq_natCast","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\nn : Nat\nhn : Ne n 0\n⊢ Iff (Eq r.toNNReal ↑n) (Eq r ↑n)","decl":"@[simp]\nlemma toNNReal_eq_natCast {r : ℝ} {n : ℕ} (hn : n ≠ 0) : r.toNNReal = n ↔ r = n :=\n  mod_cast toNNReal_eq_iff_eq_coe <| Nat.cast_ne_zero.2 hn\n\n"}
{"name":"Real.toNNReal_eq_ofNat","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (Eq r.toNNReal (OfNat.ofNat n)) (Eq r (OfNat.ofNat n))","decl":"@[simp]\nlemma toNNReal_eq_ofNat {r : ℝ} {n : ℕ} [n.AtLeastTwo] :\n    r.toNNReal = ofNat(n) ↔ r = OfNat.ofNat n :=\n  toNNReal_eq_natCast (NeZero.ne n)\n\n"}
{"name":"Real.toNNReal_le_toNNReal_iff","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : Real\nhp : LE.le 0 p\n⊢ Iff (LE.le r.toNNReal p.toNNReal) (LE.le r p)","decl":"@[simp]\ntheorem toNNReal_le_toNNReal_iff {r p : ℝ} (hp : 0 ≤ p) :\n    toNNReal r ≤ toNNReal p ↔ r ≤ p := by simp [← NNReal.coe_le_coe, hp]\n\n"}
{"name":"Real.toNNReal_le_one","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\n⊢ Iff (LE.le r.toNNReal 1) (LE.le r 1)","decl":"@[simp]\nlemma toNNReal_le_one {r : ℝ} : r.toNNReal ≤ 1 ↔ r ≤ 1 := by\n  simpa using toNNReal_le_toNNReal_iff zero_le_one\n\n"}
{"name":"Real.one_lt_toNNReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\n⊢ Iff (LT.lt 1 r.toNNReal) (LT.lt 1 r)","decl":"@[simp]\nlemma one_lt_toNNReal {r : ℝ} : 1 < r.toNNReal ↔ 1 < r := by\n  simpa only [not_le] using toNNReal_le_one.not\n\n"}
{"name":"Real.toNNReal_le_natCast","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\nn : Nat\n⊢ Iff (LE.le r.toNNReal ↑n) (LE.le r ↑n)","decl":"@[simp]\nlemma toNNReal_le_natCast {r : ℝ} {n : ℕ} : r.toNNReal ≤ n ↔ r ≤ n := by\n  simpa using toNNReal_le_toNNReal_iff n.cast_nonneg\n\n"}
{"name":"Real.natCast_lt_toNNReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\nn : Nat\n⊢ Iff (LT.lt (↑n) r.toNNReal) (LT.lt (↑n) r)","decl":"@[simp]\nlemma natCast_lt_toNNReal {r : ℝ} {n : ℕ} : n < r.toNNReal ↔ n < r := by\n  simpa only [not_le] using toNNReal_le_natCast.not\n\n"}
{"name":"Real.toNNReal_le_ofNat","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LE.le r.toNNReal (OfNat.ofNat n)) (LE.le r ↑n)","decl":"@[simp]\nlemma toNNReal_le_ofNat {r : ℝ} {n : ℕ} [n.AtLeastTwo] :\n    r.toNNReal ≤ ofNat(n) ↔ r ≤ n :=\n  toNNReal_le_natCast\n\n"}
{"name":"Real.ofNat_lt_toNNReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LT.lt (OfNat.ofNat n) r.toNNReal) (LT.lt (↑n) r)","decl":"@[simp]\nlemma ofNat_lt_toNNReal {r : ℝ} {n : ℕ} [n.AtLeastTwo] :\n    ofNat(n) < r.toNNReal ↔ n < r :=\n  natCast_lt_toNNReal\n\n"}
{"name":"Real.toNNReal_eq_toNNReal_iff","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : Real\nhr : LE.le 0 r\nhp : LE.le 0 p\n⊢ Iff (Eq r.toNNReal p.toNNReal) (Eq r p)","decl":"@[simp]\ntheorem toNNReal_eq_toNNReal_iff {r p : ℝ} (hr : 0 ≤ r) (hp : 0 ≤ p) :\n    toNNReal r = toNNReal p ↔ r = p := by simp [← coe_inj, coe_toNNReal, hr, hp]\n\n"}
{"name":"Real.toNNReal_lt_toNNReal_iff'","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : Real\n⊢ Iff (LT.lt r.toNNReal p.toNNReal) (And (LT.lt r p) (LT.lt 0 p))","decl":"@[simp]\ntheorem toNNReal_lt_toNNReal_iff' {r p : ℝ} : Real.toNNReal r < Real.toNNReal p ↔ r < p ∧ 0 < p :=\n  NNReal.coe_lt_coe.symm.trans max_lt_max_left_iff\n\n"}
{"name":"Real.toNNReal_lt_toNNReal_iff","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : Real\nh : LT.lt 0 p\n⊢ Iff (LT.lt r.toNNReal p.toNNReal) (LT.lt r p)","decl":"theorem toNNReal_lt_toNNReal_iff {r p : ℝ} (h : 0 < p) :\n    Real.toNNReal r < Real.toNNReal p ↔ r < p :=\n  toNNReal_lt_toNNReal_iff'.trans (and_iff_left h)\n\n"}
{"name":"Real.lt_of_toNNReal_lt","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : Real\nh : LT.lt r.toNNReal p.toNNReal\n⊢ LT.lt r p","decl":"theorem lt_of_toNNReal_lt {r p : ℝ} (h : r.toNNReal < p.toNNReal) : r < p :=\n  (Real.toNNReal_lt_toNNReal_iff <| Real.toNNReal_pos.1 (ne_bot_of_gt h).bot_lt).1 h\n\n"}
{"name":"Real.toNNReal_lt_toNNReal_iff_of_nonneg","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : Real\nhr : LE.le 0 r\n⊢ Iff (LT.lt r.toNNReal p.toNNReal) (LT.lt r p)","decl":"theorem toNNReal_lt_toNNReal_iff_of_nonneg {r p : ℝ} (hr : 0 ≤ r) :\n    Real.toNNReal r < Real.toNNReal p ↔ r < p :=\n  toNNReal_lt_toNNReal_iff'.trans ⟨And.left, fun h => ⟨h, lt_of_le_of_lt hr h⟩⟩\n\n"}
{"name":"Real.toNNReal_le_toNNReal_iff'","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : Real\n⊢ Iff (LE.le r.toNNReal p.toNNReal) (Or (LE.le r p) (LE.le r 0))","decl":"lemma toNNReal_le_toNNReal_iff' {r p : ℝ} : r.toNNReal ≤ p.toNNReal ↔ r ≤ p ∨ r ≤ 0 := by\n  simp_rw [← not_lt, toNNReal_lt_toNNReal_iff', not_and_or]\n\n"}
{"name":"Real.toNNReal_le_toNNReal_iff_of_pos","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : Real\nhr : LT.lt 0 r\n⊢ Iff (LE.le r.toNNReal p.toNNReal) (LE.le r p)","decl":"lemma toNNReal_le_toNNReal_iff_of_pos {r p : ℝ} (hr : 0 < r) : r.toNNReal ≤ p.toNNReal ↔ r ≤ p := by\n  simp [toNNReal_le_toNNReal_iff', hr.not_le]\n\n"}
{"name":"Real.one_le_toNNReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\n⊢ Iff (LE.le 1 r.toNNReal) (LE.le 1 r)","decl":"@[simp]\nlemma one_le_toNNReal {r : ℝ} : 1 ≤ r.toNNReal ↔ 1 ≤ r := by\n  simpa using toNNReal_le_toNNReal_iff_of_pos one_pos\n\n"}
{"name":"Real.toNNReal_lt_one","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\n⊢ Iff (LT.lt r.toNNReal 1) (LT.lt r 1)","decl":"@[simp]\nlemma toNNReal_lt_one {r : ℝ} : r.toNNReal < 1 ↔ r < 1 := by simp only [← not_le, one_le_toNNReal]\n\n"}
{"name":"Real.natCastle_toNNReal'","module":"Mathlib.Data.NNReal.Defs","initialProofState":"n : Nat\nr : Real\n⊢ Iff (LE.le (↑n) r.toNNReal) (Or (LE.le (↑n) r) (Eq n 0))","decl":"@[simp]\nlemma natCastle_toNNReal' {n : ℕ} {r : ℝ} : ↑n ≤ r.toNNReal ↔ n ≤ r ∨ n = 0 := by\n  simpa [n.cast_nonneg.le_iff_eq] using toNNReal_le_toNNReal_iff' (r := n)\n\n"}
{"name":"Real.toNNReal_lt_natCast'","module":"Mathlib.Data.NNReal.Defs","initialProofState":"n : Nat\nr : Real\n⊢ Iff (LT.lt r.toNNReal ↑n) (And (LT.lt r ↑n) (Ne n 0))","decl":"@[simp]\nlemma toNNReal_lt_natCast' {n : ℕ} {r : ℝ} : r.toNNReal < n ↔ r < n ∧ n ≠ 0 := by\n  simpa [pos_iff_ne_zero] using toNNReal_lt_toNNReal_iff' (r := r) (p := n)\n\n"}
{"name":"Real.natCast_le_toNNReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"n : Nat\nr : Real\nhn : Ne n 0\n⊢ Iff (LE.le (↑n) r.toNNReal) (LE.le (↑n) r)","decl":"lemma natCast_le_toNNReal {n : ℕ} {r : ℝ} (hn : n ≠ 0) : ↑n ≤ r.toNNReal ↔ n ≤ r := by simp [hn]\n\n"}
{"name":"Real.toNNReal_lt_natCast","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\nn : Nat\nhn : Ne n 0\n⊢ Iff (LT.lt r.toNNReal ↑n) (LT.lt r ↑n)","decl":"lemma toNNReal_lt_natCast {r : ℝ} {n : ℕ} (hn : n ≠ 0) : r.toNNReal < n ↔ r < n := by simp [hn]\n\n"}
{"name":"Real.toNNReal_lt_ofNat","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (LT.lt r.toNNReal (OfNat.ofNat n)) (LT.lt r (OfNat.ofNat n))","decl":"@[simp]\nlemma toNNReal_lt_ofNat {r : ℝ} {n : ℕ} [n.AtLeastTwo] :\n    r.toNNReal < ofNat(n) ↔ r < OfNat.ofNat n :=\n  toNNReal_lt_natCast (NeZero.ne n)\n\n"}
{"name":"Real.ofNat_le_toNNReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"n : Nat\nr : Real\ninst✝ : n.AtLeastTwo\n⊢ Iff (LE.le (OfNat.ofNat n) r.toNNReal) (LE.le (OfNat.ofNat n) r)","decl":"@[simp]\nlemma ofNat_le_toNNReal {n : ℕ} {r : ℝ} [n.AtLeastTwo] :\n    ofNat(n) ≤ r.toNNReal ↔ OfNat.ofNat n ≤ r :=\n  natCast_le_toNNReal (NeZero.ne n)\n\n"}
{"name":"Real.toNNReal_add","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : Real\nhr : LE.le 0 r\nhp : LE.le 0 p\n⊢ Eq (HAdd.hAdd r p).toNNReal (HAdd.hAdd r.toNNReal p.toNNReal)","decl":"@[simp]\ntheorem toNNReal_add {r p : ℝ} (hr : 0 ≤ r) (hp : 0 ≤ p) :\n    Real.toNNReal (r + p) = Real.toNNReal r + Real.toNNReal p :=\n  NNReal.eq <| by simp [hr, hp, add_nonneg]\n\n"}
{"name":"Real.toNNReal_add_toNNReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : Real\nhr : LE.le 0 r\nhp : LE.le 0 p\n⊢ Eq (HAdd.hAdd r.toNNReal p.toNNReal) (HAdd.hAdd r p).toNNReal","decl":"theorem toNNReal_add_toNNReal {r p : ℝ} (hr : 0 ≤ r) (hp : 0 ≤ p) :\n    Real.toNNReal r + Real.toNNReal p = Real.toNNReal (r + p) :=\n  (Real.toNNReal_add hr hp).symm\n\n"}
{"name":"Real.toNNReal_le_toNNReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : Real\nh : LE.le r p\n⊢ LE.le r.toNNReal p.toNNReal","decl":"theorem toNNReal_le_toNNReal {r p : ℝ} (h : r ≤ p) : Real.toNNReal r ≤ Real.toNNReal p :=\n  Real.toNNReal_mono h\n\n"}
{"name":"Real.toNNReal_add_le","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : Real\n⊢ LE.le (HAdd.hAdd r p).toNNReal (HAdd.hAdd r.toNNReal p.toNNReal)","decl":"theorem toNNReal_add_le {r p : ℝ} : Real.toNNReal (r + p) ≤ Real.toNNReal r + Real.toNNReal p :=\n  NNReal.coe_le_coe.1 <| max_le (add_le_add (le_max_left _ _) (le_max_left _ _)) NNReal.zero_le_coe\n\n"}
{"name":"Real.toNNReal_le_iff_le_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\np : NNReal\n⊢ Iff (LE.le r.toNNReal p) (LE.le r ↑p)","decl":"theorem toNNReal_le_iff_le_coe {r : ℝ} {p : ℝ≥0} : toNNReal r ≤ p ↔ r ≤ ↑p :=\n  NNReal.gi.gc r p\n\n"}
{"name":"Real.le_toNNReal_iff_coe_le","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\np : Real\nhp : LE.le 0 p\n⊢ Iff (LE.le r p.toNNReal) (LE.le (↑r) p)","decl":"theorem le_toNNReal_iff_coe_le {r : ℝ≥0} {p : ℝ} (hp : 0 ≤ p) : r ≤ Real.toNNReal p ↔ ↑r ≤ p := by\n  rw [← NNReal.coe_le_coe, Real.coe_toNNReal p hp]\n\n"}
{"name":"Real.le_toNNReal_iff_coe_le'","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\np : Real\nhr : LT.lt 0 r\n⊢ Iff (LE.le r p.toNNReal) (LE.le (↑r) p)","decl":"theorem le_toNNReal_iff_coe_le' {r : ℝ≥0} {p : ℝ} (hr : 0 < r) : r ≤ Real.toNNReal p ↔ ↑r ≤ p :=\n  (le_or_lt 0 p).elim le_toNNReal_iff_coe_le fun hp => by\n    simp only [(hp.trans_le r.coe_nonneg).not_le, toNNReal_eq_zero.2 hp.le, hr.not_le]\n\n"}
{"name":"Real.toNNReal_lt_iff_lt_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : Real\np : NNReal\nha : LE.le 0 r\n⊢ Iff (LT.lt r.toNNReal p) (LT.lt r ↑p)","decl":"theorem toNNReal_lt_iff_lt_coe {r : ℝ} {p : ℝ≥0} (ha : 0 ≤ r) : Real.toNNReal r < p ↔ r < ↑p := by\n  rw [← NNReal.coe_lt_coe, Real.coe_toNNReal r ha]\n\n"}
{"name":"Real.lt_toNNReal_iff_coe_lt","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r : NNReal\np : Real\n⊢ Iff (LT.lt r p.toNNReal) (LT.lt (↑r) p)","decl":"theorem lt_toNNReal_iff_coe_lt {r : ℝ≥0} {p : ℝ} : r < Real.toNNReal p ↔ ↑r < p :=\n  lt_iff_lt_of_le_iff_le toNNReal_le_iff_le_coe\n\n"}
{"name":"Real.toNNReal_pow","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x : Real\nhx : LE.le 0 x\nn : Nat\n⊢ Eq (HPow.hPow x n).toNNReal (HPow.hPow x.toNNReal n)","decl":"theorem toNNReal_pow {x : ℝ} (hx : 0 ≤ x) (n : ℕ) : (x ^ n).toNNReal = x.toNNReal ^ n := by\n  rw [← coe_inj, NNReal.coe_pow, Real.coe_toNNReal _ (pow_nonneg hx _),\n    Real.coe_toNNReal x hx]\n\n"}
{"name":"Real.toNNReal_mul","module":"Mathlib.Data.NNReal.Defs","initialProofState":"p q : Real\nhp : LE.le 0 p\n⊢ Eq (HMul.hMul p q).toNNReal (HMul.hMul p.toNNReal q.toNNReal)","decl":"theorem toNNReal_mul {p q : ℝ} (hp : 0 ≤ p) :\n    Real.toNNReal (p * q) = Real.toNNReal p * Real.toNNReal q :=\n  NNReal.eq <| by simp [mul_max_of_nonneg, hp]\n\n"}
{"name":"NNReal.mul_eq_mul_left","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b c : NNReal\nh : Ne a 0\n⊢ Iff (Eq (HMul.hMul a b) (HMul.hMul a c)) (Eq b c)","decl":"theorem mul_eq_mul_left {a b c : ℝ≥0} (h : a ≠ 0) : a * b = a * c ↔ b = c := by\n  rw [mul_eq_mul_left_iff, or_iff_left h]\n\n"}
{"name":"NNReal.pow_antitone_exp","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a : NNReal\nm n : Nat\nmn : LE.le m n\na1 : LE.le a 1\n⊢ LE.le (HPow.hPow a n) (HPow.hPow a m)","decl":"theorem pow_antitone_exp {a : ℝ≥0} (m n : ℕ) (mn : m ≤ n) (a1 : a ≤ 1) : a ^ n ≤ a ^ m :=\n  pow_le_pow_of_le_one (zero_le a) a1 mn\n\n"}
{"name":"NNReal.exists_pow_lt_of_lt_one","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b : NNReal\nha : LT.lt 0 a\nhb : LT.lt b 1\n⊢ Exists fun n => LT.lt (HPow.hPow b n) a","decl":"nonrec theorem exists_pow_lt_of_lt_one {a b : ℝ≥0} (ha : 0 < a) (hb : b < 1) :\n    ∃ n : ℕ, b ^ n < a := by\n  simpa only [← coe_pow, NNReal.coe_lt_coe] using\n    exists_pow_lt_of_lt_one (NNReal.coe_pos.2 ha) (NNReal.coe_lt_coe.2 hb)\n\n"}
{"name":"NNReal.exists_mem_Ico_zpow","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x y : NNReal\nhx : Ne x 0\nhy : LT.lt 1 y\n⊢ Exists fun n => Membership.mem (Set.Ico (HPow.hPow y n) (HPow.hPow y (HAdd.hAdd n 1))) x","decl":"nonrec theorem exists_mem_Ico_zpow {x : ℝ≥0} {y : ℝ≥0} (hx : x ≠ 0) (hy : 1 < y) :\n    ∃ n : ℤ, x ∈ Set.Ico (y ^ n) (y ^ (n + 1)) :=\n  exists_mem_Ico_zpow (α := ℝ) hx.bot_lt hy\n\n"}
{"name":"NNReal.exists_mem_Ioc_zpow","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x y : NNReal\nhx : Ne x 0\nhy : LT.lt 1 y\n⊢ Exists fun n => Membership.mem (Set.Ioc (HPow.hPow y n) (HPow.hPow y (HAdd.hAdd n 1))) x","decl":"nonrec theorem exists_mem_Ioc_zpow {x : ℝ≥0} {y : ℝ≥0} (hx : x ≠ 0) (hy : 1 < y) :\n    ∃ n : ℤ, x ∈ Set.Ioc (y ^ n) (y ^ (n + 1)) :=\n  exists_mem_Ioc_zpow (α := ℝ) hx.bot_lt hy\n\n"}
{"name":"NNReal.sub_def","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : NNReal\n⊢ Eq (HSub.hSub r p) (HSub.hSub ↑r ↑p).toNNReal","decl":"theorem sub_def {r p : ℝ≥0} : r - p = Real.toNNReal (r - p) :=\n  rfl\n\n"}
{"name":"NNReal.coe_sub_def","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : NNReal\n⊢ Eq (↑(HSub.hSub r p)) (Max.max (HSub.hSub ↑r ↑p) 0)","decl":"theorem coe_sub_def {r p : ℝ≥0} : ↑(r - p) = max (r - p : ℝ) 0 :=\n  rfl\n\n"}
{"name":"NNReal.inv_le","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : NNReal\nh : Ne r 0\n⊢ Iff (LE.le (Inv.inv r) p) (LE.le 1 (HMul.hMul r p))","decl":"@[simp]\ntheorem inv_le {r p : ℝ≥0} (h : r ≠ 0) : r⁻¹ ≤ p ↔ 1 ≤ r * p := by\n  rw [← mul_le_mul_left (pos_iff_ne_zero.2 h), mul_inv_cancel₀ h]\n\n"}
{"name":"NNReal.inv_le_of_le_mul","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : NNReal\nh : LE.le 1 (HMul.hMul r p)\n⊢ LE.le (Inv.inv r) p","decl":"theorem inv_le_of_le_mul {r p : ℝ≥0} (h : 1 ≤ r * p) : r⁻¹ ≤ p := by\n  by_cases r = 0 <;> simp [*, inv_le]\n\n"}
{"name":"NNReal.le_inv_iff_mul_le","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : NNReal\nh : Ne p 0\n⊢ Iff (LE.le r (Inv.inv p)) (LE.le (HMul.hMul r p) 1)","decl":"@[simp]\ntheorem le_inv_iff_mul_le {r p : ℝ≥0} (h : p ≠ 0) : r ≤ p⁻¹ ↔ r * p ≤ 1 := by\n  rw [← mul_le_mul_left (pos_iff_ne_zero.2 h), mul_inv_cancel₀ h, mul_comm]\n\n"}
{"name":"NNReal.lt_inv_iff_mul_lt","module":"Mathlib.Data.NNReal.Defs","initialProofState":"r p : NNReal\nh : Ne p 0\n⊢ Iff (LT.lt r (Inv.inv p)) (LT.lt (HMul.hMul r p) 1)","decl":"@[simp]\ntheorem lt_inv_iff_mul_lt {r p : ℝ≥0} (h : p ≠ 0) : r < p⁻¹ ↔ r * p < 1 := by\n  rw [← mul_lt_mul_left (pos_iff_ne_zero.2 h), mul_inv_cancel₀ h, mul_comm]\n\n"}
{"name":"NNReal.mul_le_iff_le_inv","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b r : NNReal\nhr : Ne r 0\n⊢ Iff (LE.le (HMul.hMul r a) b) (LE.le a (HMul.hMul (Inv.inv r) b))","decl":"@[deprecated le_inv_mul_iff₀ (since := \"2024-08-21\")]\ntheorem mul_le_iff_le_inv {a b r : ℝ≥0} (hr : r ≠ 0) : r * a ≤ b ↔ a ≤ r⁻¹ * b :=\n  (le_inv_mul_iff₀ (pos_iff_ne_zero.2 hr)).symm\n\n"}
{"name":"NNReal.le_div_iff_mul_le","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b r : NNReal\nhr : Ne r 0\n⊢ Iff (LE.le a (HDiv.hDiv b r)) (LE.le (HMul.hMul a r) b)","decl":"@[deprecated le_div_iff₀ (since := \"2024-08-21\")]\ntheorem le_div_iff_mul_le {a b r : ℝ≥0} (hr : r ≠ 0) : a ≤ b / r ↔ a * r ≤ b :=\n  le_div_iff₀ (pos_iff_ne_zero.2 hr)\n\n"}
{"name":"NNReal.div_le_iff","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b r : NNReal\nhr : Ne r 0\n⊢ Iff (LE.le (HDiv.hDiv a r) b) (LE.le a (HMul.hMul b r))","decl":"@[deprecated div_le_iff₀ (since := \"2024-08-21\")]\nprotected lemma div_le_iff {a b r : ℝ≥0} (hr : r ≠ 0) : a / r ≤ b ↔ a ≤ b * r :=\n  div_le_iff₀ (pos_iff_ne_zero.2 hr)\n\n"}
{"name":"NNReal.div_le_iff'","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b r : NNReal\nhr : Ne r 0\n⊢ Iff (LE.le (HDiv.hDiv a r) b) (LE.le a (HMul.hMul r b))","decl":"@[deprecated div_le_iff₀' (since := \"2024-08-21\")]\nprotected lemma div_le_iff' {a b r : ℝ≥0} (hr : r ≠ 0) : a / r ≤ b ↔ a ≤ r * b :=\n  div_le_iff₀' (pos_iff_ne_zero.2 hr)\n\n"}
{"name":"NNReal.div_le_of_le_mul","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b c : NNReal\nh : LE.le a (HMul.hMul b c)\n⊢ LE.le (HDiv.hDiv a c) b","decl":"theorem div_le_of_le_mul {a b c : ℝ≥0} (h : a ≤ b * c) : a / c ≤ b :=\n  if h0 : c = 0 then by simp [h0] else (div_le_iff₀ (pos_iff_ne_zero.2 h0)).2 h\n\n"}
{"name":"NNReal.div_le_of_le_mul'","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b c : NNReal\nh : LE.le a (HMul.hMul b c)\n⊢ LE.le (HDiv.hDiv a b) c","decl":"theorem div_le_of_le_mul' {a b c : ℝ≥0} (h : a ≤ b * c) : a / b ≤ c :=\n  div_le_of_le_mul <| mul_comm b c ▸ h\n\n"}
{"name":"NNReal.le_div_iff","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b r : NNReal\nhr : Ne r 0\n⊢ Iff (LE.le a (HDiv.hDiv b r)) (LE.le (HMul.hMul a r) b)","decl":"@[deprecated le_div_iff₀ (since := \"2024-08-21\")]\nprotected lemma le_div_iff {a b r : ℝ≥0} (hr : r ≠ 0) : a ≤ b / r ↔ a * r ≤ b :=\n  le_div_iff₀ hr.bot_lt\n\n"}
{"name":"NNReal.le_div_iff'","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b r : NNReal\nhr : Ne r 0\n⊢ Iff (LE.le a (HDiv.hDiv b r)) (LE.le (HMul.hMul r a) b)","decl":"@[deprecated le_div_iff₀' (since := \"2024-10-02\")]\ntheorem le_div_iff' {a b r : ℝ≥0} (hr : r ≠ 0) : a ≤ b / r ↔ r * a ≤ b := le_div_iff₀' hr.bot_lt\n\n"}
{"name":"NNReal.div_lt_iff","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b r : NNReal\nhr : Ne r 0\n⊢ Iff (LT.lt (HDiv.hDiv a r) b) (LT.lt a (HMul.hMul b r))","decl":"@[deprecated div_lt_iff₀ (since := \"2024-10-02\")]\ntheorem div_lt_iff {a b r : ℝ≥0} (hr : r ≠ 0) : a / r < b ↔ a < b * r := div_lt_iff₀ hr.bot_lt\n\n"}
{"name":"NNReal.div_lt_iff'","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b r : NNReal\nhr : Ne r 0\n⊢ Iff (LT.lt (HDiv.hDiv a r) b) (LT.lt a (HMul.hMul r b))","decl":"@[deprecated div_lt_iff₀' (since := \"2024-10-02\")]\ntheorem div_lt_iff' {a b r : ℝ≥0} (hr : r ≠ 0) : a / r < b ↔ a < r * b := div_lt_iff₀' hr.bot_lt\n\n"}
{"name":"NNReal.lt_div_iff","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b r : NNReal\nhr : Ne r 0\n⊢ Iff (LT.lt a (HDiv.hDiv b r)) (LT.lt (HMul.hMul a r) b)","decl":"@[deprecated lt_div_iff₀ (since := \"2024-10-02\")]\ntheorem lt_div_iff {a b r : ℝ≥0} (hr : r ≠ 0) : a < b / r ↔ a * r < b := lt_div_iff₀ hr.bot_lt\n\n"}
{"name":"NNReal.lt_div_iff'","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b r : NNReal\nhr : Ne r 0\n⊢ Iff (LT.lt a (HDiv.hDiv b r)) (LT.lt (HMul.hMul r a) b)","decl":"@[deprecated lt_div_iff₀' (since := \"2024-10-02\")]\ntheorem lt_div_iff' {a b r : ℝ≥0} (hr : r ≠ 0) : a < b / r ↔ r * a < b := lt_div_iff₀' hr.bot_lt\n\n"}
{"name":"NNReal.mul_lt_of_lt_div","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b r : NNReal\nh : LT.lt a (HDiv.hDiv b r)\n⊢ LT.lt (HMul.hMul a r) b","decl":"theorem mul_lt_of_lt_div {a b r : ℝ≥0} (h : a < b / r) : a * r < b :=\n  (lt_div_iff₀ <| pos_iff_ne_zero.2 fun hr => False.elim <| by simp [hr] at h).1 h\n\n"}
{"name":"NNReal.div_le_div_left_of_le","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b c : NNReal\nc0 : Ne c 0\ncb : LE.le c b\n⊢ LE.le (HDiv.hDiv a b) (HDiv.hDiv a c)","decl":"@[deprecated div_le_div_of_nonneg_left (since := \"2024-11-12\")]\ntheorem div_le_div_left_of_le {a b c : ℝ≥0} (c0 : c ≠ 0) (cb : c ≤ b) :\n    a / b ≤ a / c :=\n  div_le_div_of_nonneg_left (zero_le _) c0.bot_lt cb\n\n"}
{"name":"NNReal.div_le_div_left","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b c : NNReal\na0 : LT.lt 0 a\nb0 : LT.lt 0 b\nc0 : LT.lt 0 c\n⊢ Iff (LE.le (HDiv.hDiv a b) (HDiv.hDiv a c)) (LE.le c b)","decl":"@[deprecated div_le_div_iff_of_pos_left (since := \"2024-11-12\")]\nnonrec theorem div_le_div_left {a b c : ℝ≥0} (a0 : 0 < a) (b0 : 0 < b) (c0 : 0 < c) :\n    a / b ≤ a / c ↔ c ≤ b :=\n  div_le_div_iff_of_pos_left a0 b0 c0\n\n"}
{"name":"NNReal.le_of_forall_lt_one_mul_le","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x y : NNReal\nh : ∀ (a : NNReal), LT.lt a 1 → LE.le (HMul.hMul a x) y\n⊢ LE.le x y","decl":"theorem le_of_forall_lt_one_mul_le {x y : ℝ≥0} (h : ∀ a < 1, a * x ≤ y) : x ≤ y :=\n  le_of_forall_lt_imp_le_of_dense fun a ha => by\n    have hx : x ≠ 0 := pos_iff_ne_zero.1 (lt_of_le_of_lt (zero_le _) ha)\n    have hx' : x⁻¹ ≠ 0 := by rwa [Ne, inv_eq_zero]\n    have : a * x⁻¹ < 1 := by rwa [← lt_inv_iff_mul_lt hx', inv_inv]\n    have : a * x⁻¹ * x ≤ y := h _ this\n    rwa [mul_assoc, inv_mul_cancel₀ hx, mul_one] at this\n\n"}
{"name":"NNReal.half_le_self","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a : NNReal\n⊢ LE.le (HDiv.hDiv a 2) a","decl":"nonrec theorem half_le_self (a : ℝ≥0) : a / 2 ≤ a :=\n  half_le_self bot_le\n\n"}
{"name":"NNReal.half_lt_self","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a : NNReal\nh : Ne a 0\n⊢ LT.lt (HDiv.hDiv a 2) a","decl":"nonrec theorem half_lt_self {a : ℝ≥0} (h : a ≠ 0) : a / 2 < a :=\n  half_lt_self h.bot_lt\n\n"}
{"name":"NNReal.div_lt_one_of_lt","module":"Mathlib.Data.NNReal.Defs","initialProofState":"a b : NNReal\nh : LT.lt a b\n⊢ LT.lt (HDiv.hDiv a b) 1","decl":"theorem div_lt_one_of_lt {a b : ℝ≥0} (h : a < b) : a / b < 1 := by\n  rwa [div_lt_iff₀ h.bot_lt, one_mul]\n\n"}
{"name":"Real.toNNReal_inv","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x : Real\n⊢ Eq (Inv.inv x).toNNReal (Inv.inv x.toNNReal)","decl":"theorem _root_.Real.toNNReal_inv {x : ℝ} : Real.toNNReal x⁻¹ = (Real.toNNReal x)⁻¹ := by\n  rcases le_total 0 x with hx | hx\n  · nth_rw 1 [← Real.coe_toNNReal x hx]\n    rw [← NNReal.coe_inv, Real.toNNReal_coe]\n  · rw [toNNReal_eq_zero.mpr hx, inv_zero, toNNReal_eq_zero.mpr (inv_nonpos.mpr hx)]\n\n"}
{"name":"Real.toNNReal_div","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x y : Real\nhx : LE.le 0 x\n⊢ Eq (HDiv.hDiv x y).toNNReal (HDiv.hDiv x.toNNReal y.toNNReal)","decl":"theorem _root_.Real.toNNReal_div {x y : ℝ} (hx : 0 ≤ x) :\n    Real.toNNReal (x / y) = Real.toNNReal x / Real.toNNReal y := by\n  rw [div_eq_mul_inv, div_eq_mul_inv, ← Real.toNNReal_inv, ← Real.toNNReal_mul hx]\n\n"}
{"name":"Real.toNNReal_div'","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x y : Real\nhy : LE.le 0 y\n⊢ Eq (HDiv.hDiv x y).toNNReal (HDiv.hDiv x.toNNReal y.toNNReal)","decl":"theorem _root_.Real.toNNReal_div' {x y : ℝ} (hy : 0 ≤ y) :\n    Real.toNNReal (x / y) = Real.toNNReal x / Real.toNNReal y := by\n  rw [div_eq_inv_mul, div_eq_inv_mul, Real.toNNReal_mul (inv_nonneg.2 hy), Real.toNNReal_inv]\n\n"}
{"name":"NNReal.inv_lt_one_iff","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x : NNReal\nhx : Ne x 0\n⊢ Iff (LT.lt (Inv.inv x) 1) (LT.lt 1 x)","decl":"theorem inv_lt_one_iff {x : ℝ≥0} (hx : x ≠ 0) : x⁻¹ < 1 ↔ 1 < x := by\n  rw [← one_div, div_lt_iff₀ hx.bot_lt, one_mul]\n\n"}
{"name":"NNReal.zpow_pos","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x : NNReal\nhx : Ne x 0\nn : Int\n⊢ LT.lt 0 (HPow.hPow x n)","decl":"@[deprecated zpow_pos (since := \"2024-10-08\")]\nprotected theorem zpow_pos {x : ℝ≥0} (hx : x ≠ 0) (n : ℤ) : 0 < x ^ n := zpow_pos hx.bot_lt _\n\n"}
{"name":"NNReal.inv_lt_inv","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x y : NNReal\nhx : Ne x 0\nh : LT.lt x y\n⊢ LT.lt (Inv.inv y) (Inv.inv x)","decl":"theorem inv_lt_inv {x y : ℝ≥0} (hx : x ≠ 0) (h : x < y) : y⁻¹ < x⁻¹ :=\n  inv_strictAnti₀ hx.bot_lt h\n\n"}
{"name":"NNReal.abs_eq","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x : NNReal\n⊢ Eq (abs ↑x) ↑x","decl":"@[simp]\ntheorem abs_eq (x : ℝ≥0) : |(x : ℝ)| = x :=\n  abs_of_nonneg x.property\n\n"}
{"name":"NNReal.le_toNNReal_of_coe_le","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x : NNReal\ny : Real\nh : LE.le (↑x) y\n⊢ LE.le x y.toNNReal","decl":"theorem le_toNNReal_of_coe_le {x : ℝ≥0} {y : ℝ} (h : ↑x ≤ y) : x ≤ y.toNNReal :=\n  (le_toNNReal_iff_coe_le <| x.2.trans h).2 h\n\n"}
{"name":"NNReal.sSup_of_not_bddAbove","module":"Mathlib.Data.NNReal.Defs","initialProofState":"s : Set NNReal\nhs : Not (BddAbove s)\n⊢ Eq (SupSet.sSup s) 0","decl":"nonrec theorem sSup_of_not_bddAbove {s : Set ℝ≥0} (hs : ¬BddAbove s) : SupSet.sSup s = 0 := by\n  rw [← bddAbove_coe] at hs\n  rw [← coe_inj, coe_sSup, NNReal.coe_zero]\n  exact sSup_of_not_bddAbove hs\n\n"}
{"name":"NNReal.iSup_of_not_bddAbove","module":"Mathlib.Data.NNReal.Defs","initialProofState":"ι : Sort u_1\nf : ι → NNReal\nhf : Not (BddAbove (Set.range f))\n⊢ Eq (iSup fun i => f i) 0","decl":"theorem iSup_of_not_bddAbove (hf : ¬BddAbove (range f)) : ⨆ i, f i = 0 :=\n  sSup_of_not_bddAbove hf\n\n"}
{"name":"NNReal.iSup_empty","module":"Mathlib.Data.NNReal.Defs","initialProofState":"ι : Sort u_1\ninst✝ : IsEmpty ι\nf : ι → NNReal\n⊢ Eq (iSup fun i => f i) 0","decl":"theorem iSup_empty [IsEmpty ι] (f : ι → ℝ≥0) : ⨆ i, f i = 0 := ciSup_of_empty f\n\n"}
{"name":"NNReal.iInf_empty","module":"Mathlib.Data.NNReal.Defs","initialProofState":"ι : Sort u_1\ninst✝ : IsEmpty ι\nf : ι → NNReal\n⊢ Eq (iInf fun i => f i) 0","decl":"theorem iInf_empty [IsEmpty ι] (f : ι → ℝ≥0) : ⨅ i, f i = 0 := by\n  rw [_root_.iInf_of_isEmpty, sInf_empty]\n\n"}
{"name":"NNReal.iSup_eq_zero","module":"Mathlib.Data.NNReal.Defs","initialProofState":"ι : Sort u_1\nf : ι → NNReal\nhf : BddAbove (Set.range f)\n⊢ Iff (Eq (iSup fun i => f i) 0) (∀ (i : ι), Eq (f i) 0)","decl":"@[simp] lemma iSup_eq_zero (hf : BddAbove (range f)) : ⨆ i, f i = 0 ↔ ∀ i, f i = 0 := by\n  cases isEmpty_or_nonempty ι\n  · simp\n  · simp [← bot_eq_zero', ← le_bot_iff, ciSup_le_iff hf]\n\n"}
{"name":"NNReal.iInf_const_zero","module":"Mathlib.Data.NNReal.Defs","initialProofState":"α : Sort u_2\n⊢ Eq (iInf fun x => 0) 0","decl":"@[simp]\ntheorem iInf_const_zero {α : Sort*} : ⨅ _ : α, (0 : ℝ≥0) = 0 := by\n  rw [← coe_inj, coe_iInf]\n  exact Real.iInf_const_zero\n\n"}
{"name":"Set.OrdConnected.preimage_coe_nnreal_real","module":"Mathlib.Data.NNReal.Defs","initialProofState":"s : Set Real\nh : s.OrdConnected\n⊢ (Set.preimage NNReal.toReal s).OrdConnected","decl":"theorem preimage_coe_nnreal_real (h : s.OrdConnected) : ((↑) ⁻¹' s : Set ℝ≥0).OrdConnected :=\n  h.preimage_mono NNReal.coe_mono\n\n"}
{"name":"Set.OrdConnected.image_coe_nnreal_real","module":"Mathlib.Data.NNReal.Defs","initialProofState":"t : Set NNReal\nh : t.OrdConnected\n⊢ (Set.image NNReal.toReal t).OrdConnected","decl":"theorem image_coe_nnreal_real (h : t.OrdConnected) : ((↑) '' t : Set ℝ).OrdConnected :=\n  ⟨forall_mem_image.2 fun x hx =>\n      forall_mem_image.2 fun _y hy z hz => ⟨⟨z, x.2.trans hz.1⟩, h.out hx hy hz, rfl⟩⟩\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: does it generalize to a `GaloisInsertion`?\n"}
{"name":"Set.OrdConnected.image_real_toNNReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"s : Set Real\nh : s.OrdConnected\n⊢ (Set.image Real.toNNReal s).OrdConnected","decl":"theorem image_real_toNNReal (h : s.OrdConnected) : (Real.toNNReal '' s).OrdConnected := by\n  refine ⟨forall_mem_image.2 fun x hx => forall_mem_image.2 fun y hy z hz => ?_⟩\n  rcases le_total y 0 with hy₀ | hy₀\n  · rw [mem_Icc, Real.toNNReal_of_nonpos hy₀, nonpos_iff_eq_zero] at hz\n    exact ⟨y, hy, (toNNReal_of_nonpos hy₀).trans hz.2.symm⟩\n  · lift y to ℝ≥0 using hy₀\n    rw [toNNReal_coe] at hz\n    exact ⟨z, h.out hx hy ⟨toNNReal_le_iff_le_coe.1 hz.1, hz.2⟩, toNNReal_coe⟩\n\n"}
{"name":"Set.OrdConnected.preimage_real_toNNReal","module":"Mathlib.Data.NNReal.Defs","initialProofState":"t : Set NNReal\nh : t.OrdConnected\n⊢ (Set.preimage Real.toNNReal t).OrdConnected","decl":"theorem preimage_real_toNNReal (h : t.OrdConnected) : (Real.toNNReal ⁻¹' t).OrdConnected :=\n  h.preimage_mono Real.toNNReal_mono\n\n"}
{"name":"Real.coe_nnabs","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x : Real\n⊢ Eq (↑(Real.nnabs x)) (abs x)","decl":"@[norm_cast, simp]\ntheorem coe_nnabs (x : ℝ) : (nnabs x : ℝ) = |x| :=\n  rfl\n\n"}
{"name":"Real.nnabs_of_nonneg","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x : Real\nh : LE.le 0 x\n⊢ Eq (Real.nnabs x) x.toNNReal","decl":"@[simp]\ntheorem nnabs_of_nonneg {x : ℝ} (h : 0 ≤ x) : nnabs x = toNNReal x := by\n  ext\n  rw [coe_toNNReal x h, coe_nnabs, abs_of_nonneg h]\n\n"}
{"name":"Real.nnabs_coe","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x : NNReal\n⊢ Eq (Real.nnabs ↑x) x","decl":"theorem nnabs_coe (x : ℝ≥0) : nnabs x = x := by simp\n\n"}
{"name":"Real.coe_toNNReal_le","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x : Real\n⊢ LE.le (↑x.toNNReal) (abs x)","decl":"theorem coe_toNNReal_le (x : ℝ) : (toNNReal x : ℝ) ≤ |x| :=\n  max_le (le_abs_self _) (abs_nonneg _)\n\n"}
{"name":"Real.toNNReal_abs","module":"Mathlib.Data.NNReal.Defs","initialProofState":"x : Real\n⊢ Eq (abs x).toNNReal (Real.nnabs x)","decl":"@[simp] lemma toNNReal_abs (x : ℝ) : |x|.toNNReal = nnabs x := NNReal.coe_injective <| by simp\n\n"}
{"name":"Real.cast_natAbs_eq_nnabs_cast","module":"Mathlib.Data.NNReal.Defs","initialProofState":"n : Int\n⊢ Eq (↑n.natAbs) (Real.nnabs ↑n)","decl":"theorem cast_natAbs_eq_nnabs_cast (n : ℤ) : (n.natAbs : ℝ≥0) = nnabs n := by\n  ext\n  rw [NNReal.coe_natCast, Int.cast_natAbs, Real.coe_nnabs, Int.cast_abs]\n\n"}
{"name":"NNReal.exists_lt_of_strictMono","module":"Mathlib.Data.NNReal.Defs","initialProofState":"Γ₀ : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nh : Nontrivial (Units Γ₀)\nf : MonoidWithZeroHom Γ₀ NNReal\nhf : StrictMono ⇑f\nr : NNReal\nhr : LT.lt 0 r\n⊢ Exists fun d => LT.lt (f ↑d) r","decl":"/-- If `Γ₀ˣ` is nontrivial and `f : Γ₀ →*₀ ℝ≥0` is strictly monotone, then for any positive\n  `r : ℝ≥0`, there exists `d : Γ₀ˣ` with `f d < r`. -/\ntheorem NNReal.exists_lt_of_strictMono [h : Nontrivial Γ₀ˣ] {f : Γ₀ →*₀ ℝ≥0} (hf : StrictMono f)\n    {r : ℝ≥0} (hr : 0 < r) : ∃ d : Γ₀ˣ, f d < r := by\n  obtain ⟨g, hg1⟩ := (nontrivial_iff_exists_ne (1 : Γ₀ˣ)).mp h\n  set u : Γ₀ˣ := if g < 1 then g else g⁻¹ with hu\n  have hfu : f u < 1 := by\n    rw [hu]\n    split_ifs with hu1\n    · rw [← map_one f]; exact hf hu1\n    · have hfg0 : f g ≠ 0 :=\n        fun h0 ↦ (Units.ne_zero g) ((map_eq_zero f).mp h0)\n      have hg1' : 1 < g := lt_of_le_of_ne (not_lt.mp hu1) hg1.symm\n      rw [Units.val_inv_eq_inv_val, map_inv₀, inv_lt_one_iff hfg0, ← map_one f]\n      exact hf hg1'\n  obtain ⟨n, hn⟩ := exists_pow_lt_of_lt_one hr hfu\n  use u ^ n\n  rwa [Units.val_pow_eq_pow_val, map_pow]\n\n"}
{"name":"Real.exists_lt_of_strictMono","module":"Mathlib.Data.NNReal.Defs","initialProofState":"Γ₀ : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nh : Nontrivial (Units Γ₀)\nf : MonoidWithZeroHom Γ₀ NNReal\nhf : StrictMono ⇑f\nr : Real\nhr : LT.lt 0 r\n⊢ Exists fun d => LT.lt (↑(f ↑d)) r","decl":"/-- If `Γ₀ˣ` is nontrivial and `f : Γ₀ →*₀ ℝ≥0` is strictly monotone, then for any positive\n  real `r`, there exists `d : Γ₀ˣ` with `f d < r`. -/\ntheorem Real.exists_lt_of_strictMono [h : Nontrivial Γ₀ˣ] {f : Γ₀ →*₀ ℝ≥0} (hf : StrictMono f)\n    {r : ℝ} (hr : 0 < r) : ∃ d : Γ₀ˣ, (f d : ℝ) < r := by\n  set s : NNReal := ⟨r, le_of_lt hr⟩\n  have hs : 0 < s := hr\n  exact NNReal.exists_lt_of_strictMono hf hs\n\n"}
