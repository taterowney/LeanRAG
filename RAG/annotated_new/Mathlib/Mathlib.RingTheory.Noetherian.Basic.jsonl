{"name":"isNoetherian_of_surjective","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R P\nf : LinearMap (RingHom.id R) M P\nhf : Eq (LinearMap.range f) Top.top\ninst✝ : IsNoetherian R M\n⊢ IsNoetherian R P","decl":"theorem isNoetherian_of_surjective (f : M →ₗ[R] P) (hf : LinearMap.range f = ⊤) [IsNoetherian R M] :\n    IsNoetherian R P :=\n  ⟨fun s =>\n    have : (s.comap f).map f = s := Submodule.map_comap_eq_self <| hf.symm ▸ le_top\n    this ▸ (noetherian _).map _⟩\n\n"}
{"name":"isNoetherian_range","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R P\nf : LinearMap (RingHom.id R) M P\ninst✝ : IsNoetherian R M\n⊢ IsNoetherian R (Subtype fun x => Membership.mem (LinearMap.range f) x)","decl":"instance isNoetherian_range (f : M →ₗ[R] P) [IsNoetherian R M] :\n    IsNoetherian R (LinearMap.range f) :=\n  isNoetherian_of_surjective _ _ f.range_rangeRestrict\n\n"}
{"name":"isNoetherian_quotient","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : Semiring R\nA : Type u_4\nM : Type u_5\ninst✝⁶ : Ring A\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : SMul R A\ninst✝³ : Module R M\ninst✝² : Module A M\ninst✝¹ : IsScalarTower R A M\nN : Submodule A M\ninst✝ : IsNoetherian R M\n⊢ IsNoetherian R (HasQuotient.Quotient M N)","decl":"instance isNoetherian_quotient {A M : Type*} [Ring A] [AddCommGroup M] [SMul R A] [Module R M]\n    [Module A M] [IsScalarTower R A M] (N : Submodule A M) [IsNoetherian R M] :\n    IsNoetherian R (M ⧸ N) :=\n  isNoetherian_of_surjective M ((Submodule.mkQ N).restrictScalars R) <|\n    LinearMap.range_eq_top.mpr N.mkQ_surjective\n\n"}
{"name":"isNoetherian_of_linearEquiv","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R P\nf : LinearEquiv (RingHom.id R) M P\ninst✝ : IsNoetherian R M\n⊢ IsNoetherian R P","decl":"theorem isNoetherian_of_linearEquiv (f : M ≃ₗ[R] P) [IsNoetherian R M] : IsNoetherian R P :=\n  isNoetherian_of_surjective _ f.toLinearMap f.range\n\n"}
{"name":"LinearEquiv.isNoetherian_iff","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid P\ninst✝¹ : Module R M\ninst✝ : Module R P\nf : LinearEquiv (RingHom.id R) M P\n⊢ Iff (IsNoetherian R M) (IsNoetherian R P)","decl":"theorem LinearEquiv.isNoetherian_iff (f : M ≃ₗ[R] P) : IsNoetherian R M ↔ IsNoetherian R P :=\n  ⟨fun _ ↦ isNoetherian_of_linearEquiv f, fun _ ↦ isNoetherian_of_linearEquiv f.symm⟩\n\n"}
{"name":"isNoetherian_top_iff","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (IsNoetherian R (Subtype fun x => Membership.mem Top.top x)) (IsNoetherian R M)","decl":"theorem isNoetherian_top_iff : IsNoetherian R (⊤ : Submodule R M) ↔ IsNoetherian R M :=\n  Submodule.topEquiv.isNoetherian_iff\n\n"}
{"name":"isNoetherian_of_injective","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R P\ninst✝ : IsNoetherian R P\nf : LinearMap (RingHom.id R) M P\nhf : Function.Injective ⇑f\n⊢ IsNoetherian R M","decl":"theorem isNoetherian_of_injective [IsNoetherian R P] (f : M →ₗ[R] P) (hf : Function.Injective f) :\n    IsNoetherian R M :=\n  isNoetherian_of_linearEquiv (LinearEquiv.ofInjective f hf).symm\n\n"}
{"name":"fg_of_injective","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R P\ninst✝ : IsNoetherian R P\nN : Submodule R M\nf : LinearMap (RingHom.id R) M P\nhf : Function.Injective ⇑f\n⊢ N.FG","decl":"theorem fg_of_injective [IsNoetherian R P] {N : Submodule R M} (f : M →ₗ[R] P)\n    (hf : Function.Injective f) : N.FG :=\n  haveI := isNoetherian_of_injective f hf\n  IsNoetherian.noetherian N\n\n"}
{"name":"isNoetherian_of_finite","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Finite M\n⊢ IsNoetherian R M","decl":"instance (priority := 80) _root_.isNoetherian_of_finite [Finite M] : IsNoetherian R M :=\n  ⟨fun s => ⟨(s : Set M).toFinite.toFinset, by rw [Set.Finite.coe_toFinset, Submodule.span_eq]⟩⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"Module.IsNoetherian.finite","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\n⊢ Module.Finite R M","decl":"instance (priority := 100) IsNoetherian.finite [IsNoetherian R M] : Module.Finite R M :=\n  ⟨IsNoetherian.noetherian ⊤⟩\n\n"}
{"name":"Module.instFiniteSubtypeMemIdealOfIsNoetherian","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R₁ : Type u_4\nS : Type u_5\ninst✝³ : CommSemiring R₁\ninst✝² : Semiring S\ninst✝¹ : Algebra R₁ S\ninst✝ : IsNoetherian R₁ S\nI : Ideal S\n⊢ Module.Finite R₁ (Subtype fun x => Membership.mem I x)","decl":"instance {R₁ S : Type*} [CommSemiring R₁] [Semiring S] [Algebra R₁ S]\n    [IsNoetherian R₁ S] (I : Ideal S) : Module.Finite R₁ I :=\n  IsNoetherian.finite R₁ ((I : Submodule S S).restrictScalars R₁)\n\n"}
{"name":"Module.Finite.of_injective","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : IsNoetherian R N\nf : LinearMap (RingHom.id R) M N\nhf : Function.Injective ⇑f\n⊢ Module.Finite R M","decl":"theorem Finite.of_injective [IsNoetherian R N] (f : M →ₗ[R] N) (hf : Function.Injective f) :\n    Module.Finite R M :=\n  ⟨fg_of_injective f hf⟩\n\n"}
{"name":"isNoetherian_of_ker_bot","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_4\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R P\ninst✝ : IsNoetherian R P\nf : LinearMap (RingHom.id R) M P\nhf : Eq (LinearMap.ker f) Bot.bot\n⊢ IsNoetherian R M","decl":"theorem isNoetherian_of_ker_bot [IsNoetherian R P] (f : M →ₗ[R] P) (hf : LinearMap.ker f = ⊥) :\n    IsNoetherian R M :=\n  isNoetherian_of_linearEquiv (LinearEquiv.ofInjective f <| LinearMap.ker_eq_bot.mp hf).symm\n\n"}
{"name":"fg_of_ker_bot","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_4\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R P\ninst✝ : IsNoetherian R P\nN : Submodule R M\nf : LinearMap (RingHom.id R) M P\nhf : Eq (LinearMap.ker f) Bot.bot\n⊢ N.FG","decl":"theorem fg_of_ker_bot [IsNoetherian R P] {N : Submodule R M} (f : M →ₗ[R] P)\n    (hf : LinearMap.ker f = ⊥) : N.FG :=\n  haveI := isNoetherian_of_ker_bot f hf\n  IsNoetherian.noetherian N\n\n-- False over a semiring: ℕ is a Noetherian ℕ-module but ℕ × ℕ is not.\n"}
{"name":"isNoetherian_prod","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_4\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup P\ninst✝³ : Module R M\ninst✝² : Module R P\ninst✝¹ : IsNoetherian R M\ninst✝ : IsNoetherian R P\n⊢ IsNoetherian R (Prod M P)","decl":"instance isNoetherian_prod [IsNoetherian R M] [IsNoetherian R P] : IsNoetherian R (M × P) :=\n  ⟨fun s =>\n    Submodule.fg_of_fg_map_of_fg_inf_ker (LinearMap.snd R M P) (noetherian _) <|\n      have : s ⊓ LinearMap.ker (LinearMap.snd R M P) ≤ LinearMap.range (LinearMap.inl R M P) :=\n        fun x ⟨_, hx2⟩ => ⟨x.1, Prod.ext rfl <| Eq.symm <| LinearMap.mem_ker.1 hx2⟩\n      Submodule.map_comap_eq_self this ▸ (noetherian _).map _⟩\n\n"}
{"name":"isNoetherian_sup","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nP : Type u_4\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup P\ninst✝² : Module R P\nM₁ M₂ : Submodule R P\ninst✝¹ : IsNoetherian R (Subtype fun x => Membership.mem M₁ x)\ninst✝ : IsNoetherian R (Subtype fun x => Membership.mem M₂ x)\n⊢ IsNoetherian R (Subtype fun x => Membership.mem (Max.max M₁ M₂) x)","decl":"instance isNoetherian_sup (M₁ M₂ : Submodule R P) [IsNoetherian R M₁] [IsNoetherian R M₂] :\n    IsNoetherian R ↥(M₁ ⊔ M₂) := by\n  have := isNoetherian_range (M₁.subtype.coprod M₂.subtype)\n  rwa [LinearMap.range_coprod, Submodule.range_subtype, Submodule.range_subtype] at this\n\n"}
{"name":"isNoetherian_pi","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\ninst✝³ : Ring R\nι : Type u_5\nM : ι → Type u_6\ninst✝² : (i : ι) → AddCommGroup (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : ∀ (i : ι), IsNoetherian R (M i)\n⊢ IsNoetherian R ((i : ι) → M i)","decl":"instance isNoetherian_pi :\n    ∀ {M : ι → Type*} [∀ i, AddCommGroup (M i)]\n      [∀ i, Module R (M i)] [∀ i, IsNoetherian R (M i)], IsNoetherian R (Π i, M i) := by\n  apply Finite.induction_empty_option _ _ _ ι\n  · exact fun e h ↦ isNoetherian_of_linearEquiv (LinearEquiv.piCongrLeft R _ e)\n  · infer_instance\n  · exact fun ih ↦ isNoetherian_of_linearEquiv (LinearEquiv.piOptionEquivProd R).symm\n\n"}
{"name":"isNoetherian_pi'","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_5\ninst✝ : IsNoetherian R M\n⊢ IsNoetherian R (ι → M)","decl":"/-- A version of `isNoetherian_pi` for non-dependent functions. We need this instance because\nsometimes Lean fails to apply the dependent version in non-dependent settings (e.g., it fails to\nprove that `ι → ℝ` is finite dimensional over `ℝ`). -/\ninstance isNoetherian_pi' [IsNoetherian R M] : IsNoetherian R (ι → M) :=\n  isNoetherian_pi\n\n"}
{"name":"isNoetherian_iSup","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nP : Type u_4\ninst✝³ : Ring R\ninst✝² : AddCommGroup P\ninst✝¹ : Module R P\nι : Type u_5\nM : ι → Submodule R P\ninst✝ : ∀ (i : ι), IsNoetherian R (Subtype fun x => Membership.mem (M i) x)\n⊢ IsNoetherian R (Subtype fun x => Membership.mem (iSup fun i => M i) x)","decl":"instance isNoetherian_iSup :\n    ∀ {M : ι → Submodule R P} [∀ i, IsNoetherian R (M i)], IsNoetherian R ↥(⨆ i, M i) := by\n  apply Finite.induction_empty_option _ _ _ ι\n  · intro _ _ e h _ _; rw [← e.iSup_comp]; apply h\n  · intros; rw [iSup_of_empty]; infer_instance\n  · intro _ _ ih _ _; rw [iSup_option]; infer_instance\n\n"}
{"name":"isNoetherian_of_range_eq_ker","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝⁸ : Ring R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : AddCommGroup P\ninst✝⁴ : Module R M\ninst✝³ : Module R N\ninst✝² : Module R P\ninst✝¹ : IsNoetherian R M\ninst✝ : IsNoetherian R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh : Eq (LinearMap.range f) (LinearMap.ker g)\n⊢ IsNoetherian R N","decl":"/-- If the first and final modules in an exact sequence are Noetherian,\n  then the middle module is also Noetherian. -/\ntheorem isNoetherian_of_range_eq_ker [IsNoetherian R M] [IsNoetherian R P]\n    (f : M →ₗ[R] N) (g : N →ₗ[R] P) (h : LinearMap.range f = LinearMap.ker g) :\n    IsNoetherian R N :=\n  isNoetherian_mk <|\n    wellFounded_gt_exact_sequence\n      (LinearMap.range f)\n      (Submodule.map (f.ker.liftQ f le_rfl))\n      (Submodule.comap (f.ker.liftQ f le_rfl))\n      (Submodule.comap g.rangeRestrict) (Submodule.map g.rangeRestrict)\n      (Submodule.gciMapComap <| LinearMap.ker_eq_bot.mp <| Submodule.ker_liftQ_eq_bot _ _ _ le_rfl)\n      (Submodule.giMapComap g.surjective_rangeRestrict)\n      (by simp [Submodule.map_comap_eq, inf_comm, Submodule.range_liftQ])\n      (by simp [Submodule.comap_map_eq, h])\n\n"}
{"name":"isNoetherian_iff_submodule_quotient","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nP : Type u_4\ninst✝² : Ring R\ninst✝¹ : AddCommGroup P\ninst✝ : Module R P\nS : Submodule R P\n⊢ Iff (IsNoetherian R P) (And (IsNoetherian R (Subtype fun x => Membership.mem S x)) (IsNoetherian R (HasQuotient.Quotient P S)))","decl":"theorem isNoetherian_iff_submodule_quotient (S : Submodule R P) :\n    IsNoetherian R P ↔ IsNoetherian R S ∧ IsNoetherian R (P ⧸ S) := by\n  refine ⟨fun _ ↦ ⟨inferInstance, inferInstance⟩, fun ⟨_, _⟩ ↦ ?_⟩\n  apply isNoetherian_of_range_eq_ker S.subtype S.mkQ\n  rw [Submodule.ker_mkQ, Submodule.range_subtype]\n\n"}
{"name":"isNoetherian_linearMap_pi","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsNoetherian R M\nι : Type u_4\ninst✝ : Finite ι\n⊢ IsNoetherian R (LinearMap (RingHom.id R) (ι → R) M)","decl":"instance isNoetherian_linearMap_pi {ι : Type*} [Finite ι] : IsNoetherian R ((ι → R) →ₗ[R] M) :=\n  let _i : Fintype ι := Fintype.ofFinite ι; isNoetherian_of_linearEquiv (Module.piEquiv ι R M)\n\n"}
{"name":"isNoetherian_linearMap","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ IsNoetherian R (LinearMap (RingHom.id R) N M)","decl":"instance isNoetherian_linearMap : IsNoetherian R (N →ₗ[R] M) := by\n  obtain ⟨n, f, hf⟩ := Module.Finite.exists_fin' R N\n  let g : (N →ₗ[R] M) →ₗ[R] (Fin n → R) →ₗ[R] M := (LinearMap.llcomp R (Fin n → R) N M).flip f\n  exact isNoetherian_of_injective g hf.injective_linearMapComp_right\n\n"}
{"name":"IsNoetherian.induction","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nP : Submodule R M → Prop\nhgt : ∀ (I : Submodule R M), (∀ (J : Submodule R M), GT.gt J I → P J) → P I\nI : Submodule R M\n⊢ P I","decl":"/-- If `∀ I > J, P I` implies `P J`, then `P` holds for all submodules. -/\ntheorem IsNoetherian.induction [IsNoetherian R M] {P : Submodule R M → Prop}\n    (hgt : ∀ I, (∀ J > I, P J) → P I) (I : Submodule R M) : P I :=\n  IsWellFounded.induction _ I hgt\n\n"}
{"name":"Submodule.finite_ne_bot_of_iSupIndep","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nι : Type u_5\nN : ι → Submodule R M\nh : iSupIndep N\n⊢ (setOf fun i => Ne (N i) Bot.bot).Finite","decl":"lemma Submodule.finite_ne_bot_of_iSupIndep {ι : Type*} {N : ι → Submodule R M}\n    (h : iSupIndep N) :\n    Set.Finite {i | N i ≠ ⊥} :=\n  WellFoundedGT.finite_ne_bot_of_iSupIndep h\n\n"}
{"name":"Submodule.finite_ne_bot_of_independent","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nι : Type u_5\nN : ι → Submodule R M\nh : iSupIndep N\n⊢ (setOf fun i => Ne (N i) Bot.bot).Finite","decl":"@[deprecated (since := \"2024-11-24\")]\nalias Submodule.finite_ne_bot_of_independent := Submodule.finite_ne_bot_of_iSupIndep\n\n"}
{"name":"LinearIndependent.finite_of_isNoetherian","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : IsNoetherian R M\ninst✝ : Nontrivial R\nι : Type u_5\nv : ι → M\nhv : LinearIndependent R v\n⊢ Finite ι","decl":"/-- A linearly-independent family of vectors in a module over a non-trivial ring must be finite if\nthe module is Noetherian. -/\ntheorem LinearIndependent.finite_of_isNoetherian [Nontrivial R] {ι} {v : ι → M}\n    (hv : LinearIndependent R v) : Finite ι := by\n  refine WellFoundedGT.finite_of_iSupIndep\n    hv.iSupIndep_span_singleton\n    fun i contra => ?_\n  apply hv.ne_zero i\n  have : v i ∈ R ∙ v i := Submodule.mem_span_singleton_self (v i)\n  rwa [contra, Submodule.mem_bot] at this\n\n"}
{"name":"LinearIndependent.set_finite_of_isNoetherian","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : IsNoetherian R M\ninst✝ : Nontrivial R\ns : Set M\nhi : LinearIndependent R Subtype.val\n⊢ s.Finite","decl":"theorem LinearIndependent.set_finite_of_isNoetherian [Nontrivial R] {s : Set M}\n    (hi : LinearIndependent R ((↑) : s → M)) : s.Finite :=\n  @Set.toFinite _ _ hi.finite_of_isNoetherian\n\n"}
{"name":"IsNoetherian.disjoint_partialSups_eventually_bot","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nf : Nat → Submodule R M\nh : ∀ (n : Nat), Disjoint ((partialSups f) n) (f (HAdd.hAdd n 1))\n⊢ Exists fun n => ∀ (m : Nat), LE.le n m → Eq (f m) Bot.bot","decl":"/-- A sequence `f` of submodules of a noetherian module,\nwith `f (n+1)` disjoint from the supremum of `f 0`, ..., `f n`,\nis eventually zero. -/\ntheorem IsNoetherian.disjoint_partialSups_eventually_bot\n    (f : ℕ → Submodule R M) (h : ∀ n, Disjoint (partialSups f n) (f (n + 1))) :\n    ∃ n : ℕ, ∀ m, n ≤ m → f m = ⊥ := by\n  -- A little off-by-one cleanup first:\n  suffices t : ∃ n : ℕ, ∀ m, n ≤ m → f (m + 1) = ⊥ by\n    obtain ⟨n, w⟩ := t\n    use n + 1\n    rintro (_ | m) p\n    · cases p\n    · apply w\n      exact Nat.succ_le_succ_iff.mp p\n  obtain ⟨n, w⟩ := monotone_stabilizes_iff_noetherian.mpr inferInstance (partialSups f)\n  refine ⟨n, fun m p ↦ (h m).eq_bot_of_ge <| sup_eq_left.mp ?_⟩\n  simpa only [partialSups_add_one] using (w (m + 1) <| le_add_right p).symm.trans <| w m p\n\n"}
{"name":"isNoetherian_of_subsingleton","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Subsingleton R\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ IsNoetherian R M","decl":"/-- Modules over the trivial ring are Noetherian. -/\ninstance (priority := 100) isNoetherian_of_subsingleton (R M) [Subsingleton R] [Semiring R]\n    [AddCommMonoid M] [Module R M] : IsNoetherian R M :=\n  haveI := Module.subsingleton R M\n  isNoetherian_of_finite R M\n\n"}
{"name":"isNoetherian_of_submodule_of_noetherian","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\nh : IsNoetherian R M\n⊢ IsNoetherian R (Subtype fun x => Membership.mem N x)","decl":"theorem isNoetherian_of_submodule_of_noetherian (R M) [Semiring R] [AddCommMonoid M] [Module R M]\n    (N : Submodule R M) (h : IsNoetherian R M) : IsNoetherian R N :=\n  isNoetherian_mk ⟨OrderEmbedding.wellFounded (Submodule.MapSubtype.orderEmbedding N).dual h.wf⟩\n\n"}
{"name":"isNoetherian_of_tower","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid M\ninst✝³ : SMul R S\ninst✝² : Module S M\ninst✝¹ : Module R M\ninst✝ : IsScalarTower R S M\nh : IsNoetherian R M\n⊢ IsNoetherian S M","decl":"/-- If `M / S / R` is a scalar tower, and `M / R` is Noetherian, then `M / S` is\nalso noetherian. -/\ntheorem isNoetherian_of_tower (R) {S M} [Semiring R] [Semiring S] [AddCommMonoid M] [SMul R S]\n    [Module S M] [Module R M] [IsScalarTower R S M] (h : IsNoetherian R M) : IsNoetherian S M :=\n  isNoetherian_mk ⟨(Submodule.restrictScalarsEmbedding R S M).dual.wellFounded h.wf⟩\n\n"}
{"name":"isNoetherian_of_fg_of_noetherian","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nI : IsNoetherianRing R\nhN : N.FG\n⊢ IsNoetherian R (Subtype fun x => Membership.mem N x)","decl":"theorem isNoetherian_of_fg_of_noetherian {R M} [Ring R] [AddCommGroup M] [Module R M]\n    (N : Submodule R M) [I : IsNoetherianRing R] (hN : N.FG) : IsNoetherian R N := by\n  let ⟨s, hs⟩ := hN\n  haveI := Classical.decEq M\n  haveI := Classical.decEq R\n  have : ∀ x ∈ s, x ∈ N := fun x hx => hs ▸ Submodule.subset_span hx\n  refine\n    @isNoetherian_of_surjective\n      R ((↑s : Set M) → R) N _ _ _ (Pi.module _ _ _) _ ?_ ?_ isNoetherian_pi\n  · fapply LinearMap.mk\n    · fapply AddHom.mk\n      · exact fun f => ⟨∑ i ∈ s.attach, f i • i.1, N.sum_mem fun c _ => N.smul_mem _ <| this _ c.2⟩\n      · intro f g\n        apply Subtype.eq\n        change (∑ i ∈ s.attach, (f i + g i) • _) = _\n        simp only [add_smul, Finset.sum_add_distrib]\n        rfl\n    · intro c f\n      apply Subtype.eq\n      change (∑ i ∈ s.attach, (c • f i) • _) = _\n      simp only [smul_eq_mul, mul_smul]\n      exact Finset.smul_sum.symm\n  · rw [LinearMap.range_eq_top]\n    rintro ⟨n, hn⟩\n    change n ∈ N at hn\n    rw [← hs, ← Set.image_id (s : Set M), Finsupp.mem_span_image_iff_linearCombination] at hn\n    rcases hn with ⟨l, hl1, hl2⟩\n    refine ⟨fun x => l x, Subtype.ext ?_⟩\n    change (∑ i ∈ s.attach, l i • (i : M)) = n\n    rw [s.sum_attach fun i ↦ l i • i, ← hl2,\n      Finsupp.linearCombination_apply, Finsupp.sum, eq_comm]\n    refine Finset.sum_subset hl1 fun x _ hx => ?_\n    rw [Finsupp.not_mem_support_iff.1 hx, zero_smul]\n\n"}
{"name":"isNoetherian_of_isNoetherianRing_of_finite","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsNoetherianRing R\ninst✝ : Module.Finite R M\n⊢ IsNoetherian R M","decl":"instance isNoetherian_of_isNoetherianRing_of_finite (R M : Type*)\n    [Ring R] [AddCommGroup M] [Module R M] [IsNoetherianRing R] [Module.Finite R M] :\n    IsNoetherian R M :=\n  have : IsNoetherian R (⊤ : Submodule R M) :=\n    isNoetherian_of_fg_of_noetherian _ <| Module.finite_def.mp inferInstance\n  isNoetherian_of_linearEquiv (LinearEquiv.ofTop (⊤ : Submodule R M) rfl)\n\n"}
{"name":"isNoetherian_span_of_finite","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherianRing R\nA : Set M\nhA : A.Finite\n⊢ IsNoetherian R (Subtype fun x => Membership.mem (Submodule.span R A) x)","decl":"/-- In a module over a Noetherian ring, the submodule generated by finitely many vectors is\nNoetherian. -/\ntheorem isNoetherian_span_of_finite (R) {M} [Ring R] [AddCommGroup M] [Module R M]\n    [IsNoetherianRing R] {A : Set M} (hA : A.Finite) : IsNoetherian R (Submodule.span R A) :=\n  isNoetherian_of_fg_of_noetherian _ (Submodule.fg_def.mpr ⟨A, hA, rfl⟩)\n\n"}
{"name":"isNoetherianRing_of_surjective","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nS : Type u_2\ninst✝ : Semiring S\nf : RingHom R S\nhf : Function.Surjective ⇑f\nH : IsNoetherianRing R\n⊢ IsNoetherianRing S","decl":"theorem isNoetherianRing_of_surjective (R) [Semiring R] (S) [Semiring S] (f : R →+* S)\n    (hf : Function.Surjective f) [H : IsNoetherianRing R] : IsNoetherianRing S :=\n  isNoetherian_mk ⟨OrderEmbedding.wellFounded (Ideal.orderEmbeddingOfSurjective f hf).dual H.wf⟩\n\n"}
{"name":"isNoetherianRing_rangeS","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Type u_2\ninst✝¹ : Semiring S\nf : RingHom R S\ninst✝ : IsNoetherianRing R\n⊢ IsNoetherianRing (Subtype fun x => Membership.mem f.rangeS x)","decl":"instance isNoetherianRing_rangeS {R} [Semiring R] {S} [Semiring S] (f : R →+* S)\n    [IsNoetherianRing R] : IsNoetherianRing f.rangeS :=\n  isNoetherianRing_of_surjective R f.rangeS f.rangeSRestrict f.rangeSRestrict_surjective\n\n"}
{"name":"isNoetherianRing_range","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\ninst✝² : Ring R\nS : Type u_2\ninst✝¹ : Ring S\nf : RingHom R S\ninst✝ : IsNoetherianRing R\n⊢ IsNoetherianRing (Subtype fun x => Membership.mem f.range x)","decl":"instance isNoetherianRing_range {R} [Ring R] {S} [Ring S] (f : R →+* S)\n    [IsNoetherianRing R] : IsNoetherianRing f.range :=\n  isNoetherianRing_rangeS f\n\n"}
{"name":"isNoetherianRing_of_ringEquiv","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nS : Type u_2\ninst✝¹ : Semiring S\nf : RingEquiv R S\ninst✝ : IsNoetherianRing R\n⊢ IsNoetherianRing S","decl":"theorem isNoetherianRing_of_ringEquiv (R) [Semiring R] {S} [Semiring S] (f : R ≃+* S)\n    [IsNoetherianRing R] : IsNoetherianRing S :=\n  isNoetherianRing_of_surjective R S f.toRingHom f.toEquiv.surjective\n\n"}
{"name":"instIsNoetherianRingProd","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : IsNoetherianRing R\ninst✝ : IsNoetherianRing S\n⊢ IsNoetherianRing (Prod R S)","decl":"instance {R S} [Semiring R] [Semiring S] [IsNoetherianRing R] [IsNoetherianRing S] :\n    IsNoetherianRing (R × S) := by\n  rw [IsNoetherianRing, isNoetherian_iff'] at *\n  exact Ideal.idealProdEquiv.toOrderEmbedding.wellFoundedGT\n\n"}
{"name":"instIsNoetherianRingForallOfFinite","module":"Mathlib.RingTheory.Noetherian.Basic","initialProofState":"ι : Type u_2\ninst✝² : Finite ι\nR : ι → Type u_1\ninst✝¹ : (i : ι) → Semiring (R i)\ninst✝ : ∀ (i : ι), IsNoetherianRing (R i)\n⊢ IsNoetherianRing ((i : ι) → R i)","decl":"instance {ι} [Finite ι] : ∀ {R : ι → Type*} [Π i, Semiring (R i)] [∀ i, IsNoetherianRing (R i)],\n    IsNoetherianRing (Π i, R i) := by\n  apply Finite.induction_empty_option _ _ _ ι\n  · exact fun e h ↦ isNoetherianRing_of_ringEquiv _ (.piCongrLeft _ e)\n  · infer_instance\n  · exact fun ih ↦ isNoetherianRing_of_ringEquiv _ (.symm .piOptionEquivProd)\n"}
