{"name":"GenContFract.IntFractPair.mk.sizeOf_spec","module":"Mathlib.Algebra.ContinuedFractions.Computation.Basic","initialProofState":"K : Type u_1\ninst✝ : SizeOf K\nb : Int\nfr : K\n⊢ Eq (SizeOf.sizeOf { b := b, fr := fr }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf b)) (SizeOf.sizeOf fr))","decl":"/-- We collect an integer part `b = ⌊v⌋` and fractional part `fr = v - ⌊v⌋` of a value `v` in a pair\n`⟨b, fr⟩`.\n-/\nstructure IntFractPair where\n  b : ℤ\n  fr : K\n\n"}
{"name":"GenContFract.IntFractPair.mk.injEq","module":"Mathlib.Algebra.ContinuedFractions.Computation.Basic","initialProofState":"K : Type u_1\nb✝ : Int\nfr✝ : K\nb : Int\nfr : K\n⊢ Eq (Eq { b := b✝, fr := fr✝ } { b := b, fr := fr }) (And (Eq b✝ b) (Eq fr✝ fr))","decl":"/-- We collect an integer part `b = ⌊v⌋` and fractional part `fr = v - ⌊v⌋` of a value `v` in a pair\n`⟨b, fr⟩`.\n-/\nstructure IntFractPair where\n  b : ℤ\n  fr : K\n\n"}
{"name":"GenContFract.IntFractPair.mk.inj","module":"Mathlib.Algebra.ContinuedFractions.Computation.Basic","initialProofState":"K : Type u_1\nb✝ : Int\nfr✝ : K\nb : Int\nfr : K\nx✝ : Eq { b := b✝, fr := fr✝ } { b := b, fr := fr }\n⊢ And (Eq b✝ b) (Eq fr✝ fr)","decl":"/-- We collect an integer part `b = ⌊v⌋` and fractional part `fr = v - ⌊v⌋` of a value `v` in a pair\n`⟨b, fr⟩`.\n-/\nstructure IntFractPair where\n  b : ℤ\n  fr : K\n\n"}
{"name":"GenContFract.IntFractPair.coe_to_intFractPair","module":"Mathlib.Algebra.ContinuedFractions.Computation.Basic","initialProofState":"K : Type u_1\nβ : Type u_2\ninst✝ : Coe K β\nb : Int\nfr : K\n⊢ Eq ↑{ b := b, fr := fr } { b := b, fr := Coe.coe fr }","decl":"@[simp, norm_cast]\ntheorem coe_to_intFractPair {b : ℤ} {fr : K} :\n    (↑(IntFractPair.mk b fr) : IntFractPair β) = IntFractPair.mk b (↑fr : β) :=\n  rfl\n\n"}
{"name":"GenContFract.IntFractPair.stream_isSeq","module":"Mathlib.Algebra.ContinuedFractions.Computation.Basic","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\n⊢ (GenContFract.IntFractPair.stream v).IsSeq","decl":"/-- Shows that `IntFractPair.stream` has the sequence property, that is once we return `none` at\nposition `n`, we also return `none` at `n + 1`.\n-/\ntheorem stream_isSeq (v : K) : (IntFractPair.stream v).IsSeq := by\n  intro _ hyp\n  simp [IntFractPair.stream, hyp]\n\n"}
