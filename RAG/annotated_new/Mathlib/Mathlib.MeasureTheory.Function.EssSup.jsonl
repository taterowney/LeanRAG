{"name":"essSup_congr_ae","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : ConditionallyCompleteLattice β\nf g : α → β\nhfg : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Eq (essSup f μ) (essSup g μ)","decl":"theorem essSup_congr_ae {f g : α → β} (hfg : f =ᵐ[μ] g) : essSup f μ = essSup g μ :=\n  limsup_congr hfg\n\n"}
{"name":"essInf_congr_ae","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : ConditionallyCompleteLattice β\nf g : α → β\nhfg : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Eq (essInf f μ) (essInf g μ)","decl":"theorem essInf_congr_ae {f g : α → β} (hfg : f =ᵐ[μ] g) : essInf f μ = essInf g μ :=\n  @essSup_congr_ae α βᵒᵈ _ _ _ _ _ hfg\n\n"}
{"name":"essSup_const'","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : NeZero μ\nc : β\n⊢ Eq (essSup (fun x => c) μ) c","decl":"@[simp]\ntheorem essSup_const' [NeZero μ] (c : β) : essSup (fun _ : α => c) μ = c :=\n  limsup_const _\n\n"}
{"name":"essInf_const'","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : NeZero μ\nc : β\n⊢ Eq (essInf (fun x => c) μ) c","decl":"@[simp]\ntheorem essInf_const' [NeZero μ] (c : β) : essInf (fun _ : α => c) μ = c :=\n  liminf_const _\n\n"}
{"name":"essSup_const","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : ConditionallyCompleteLattice β\nc : β\nhμ : Ne μ 0\n⊢ Eq (essSup (fun x => c) μ) c","decl":"theorem essSup_const (c : β) (hμ : μ ≠ 0) : essSup (fun _ : α => c) μ = c :=\n  have := NeZero.mk hμ; essSup_const' _\n\n"}
{"name":"essInf_const","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : ConditionallyCompleteLattice β\nc : β\nhμ : Ne μ 0\n⊢ Eq (essInf (fun x => c) μ) c","decl":"theorem essInf_const (c : β) (hμ : μ ≠ 0) : essInf (fun _ : α => c) μ = c :=\n  have := NeZero.mk hμ; essInf_const' _\n\n"}
{"name":"essSup_smul_measure","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁴ : ConditionallyCompleteLattice β\nR : Type u_3\ninst✝³ : Zero R\ninst✝² : SMulWithZero R ENNReal\ninst✝¹ : IsScalarTower R ENNReal ENNReal\ninst✝ : NoZeroSMulDivisors R ENNReal\nc : R\nhc : Ne c 0\nf : α → β\n⊢ Eq (essSup f (HSMul.hSMul c μ)) (essSup f μ)","decl":"@[simp]\nlemma essSup_smul_measure (hc : c ≠ 0) (f : α → β) : essSup f (c • μ) = essSup f μ := by\n  simp_rw [essSup, Measure.ae_smul_measure_eq hc]\n\n"}
{"name":"essSup_eq_ciSup","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : ConditionallyCompleteLattice β\nf : α → β\ninst✝ : Nonempty α\nhμ : ∀ (a : α), Ne (μ (Singleton.singleton a)) 0\nhf : BddAbove (Set.range f)\n⊢ Eq (essSup f μ) (iSup fun a => f a)","decl":"lemma essSup_eq_ciSup (hμ : ∀ a, μ {a} ≠ 0) (hf : BddAbove (Set.range f)) :\n    essSup f μ = ⨆ a, f a := by rw [essSup, ae_eq_top.2 hμ, limsup_top_eq_ciSup hf]\n\n"}
{"name":"essInf_eq_ciInf","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : ConditionallyCompleteLattice β\nf : α → β\ninst✝ : Nonempty α\nhμ : ∀ (a : α), Ne (μ (Singleton.singleton a)) 0\nhf : BddBelow (Set.range f)\n⊢ Eq (essInf f μ) (iInf fun a => f a)","decl":"lemma essInf_eq_ciInf (hμ : ∀ a, μ {a} ≠ 0) (hf : BddBelow (Set.range f)) :\n    essInf f μ = ⨅ a, f a := by rw [essInf, ae_eq_top.2 hμ, liminf_top_eq_ciInf hf]\n\n"}
{"name":"essSup_count_eq_ciSup","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝² : ConditionallyCompleteLattice β\nf : α → β\ninst✝¹ : Nonempty α\ninst✝ : MeasurableSingletonClass α\nhf : BddAbove (Set.range f)\n⊢ Eq (essSup f MeasureTheory.Measure.count) (iSup fun a => f a)","decl":"@[simp] lemma essSup_count_eq_ciSup (hf : BddAbove (Set.range f)) :\n    essSup f .count = ⨆ a, f a := essSup_eq_ciSup (by simp) hf\n\n"}
{"name":"essInf_count_eq_ciInf","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝² : ConditionallyCompleteLattice β\nf : α → β\ninst✝¹ : Nonempty α\ninst✝ : MeasurableSingletonClass α\nhf : BddBelow (Set.range f)\n⊢ Eq (essInf f MeasureTheory.Measure.count) (iInf fun a => f a)","decl":"@[simp] lemma essInf_count_eq_ciInf (hf : BddBelow (Set.range f)) :\n    essInf f .count = ⨅ a, f a := essInf_eq_ciInf (by simp) hf\n\n"}
{"name":"essSup_uniformOn_eq_ciSup","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝³ : ConditionallyCompleteLattice β\nf : α → β\ninst✝² : Nonempty α\ninst✝¹ : MeasurableSingletonClass α\ninst✝ : Finite α\nhf : BddAbove (Set.range f)\n⊢ Eq (essSup f (ProbabilityTheory.uniformOn Set.univ)) (iSup fun a => f a)","decl":"@[simp] lemma essSup_uniformOn_eq_ciSup [Finite α] (hf : BddAbove (Set.range f)) :\n    essSup f (uniformOn univ) = ⨆ a, f a :=\n  essSup_eq_ciSup (by simp [uniformOn, cond_apply, Set.finite_univ]) hf\n\n"}
{"name":"essInf_cond_count_eq_ciInf","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝³ : ConditionallyCompleteLattice β\nf : α → β\ninst✝² : Nonempty α\ninst✝¹ : MeasurableSingletonClass α\ninst✝ : Finite α\nhf : BddBelow (Set.range f)\n⊢ Eq (essInf f (ProbabilityTheory.uniformOn Set.univ)) (iInf fun a => f a)","decl":"@[simp] lemma essInf_cond_count_eq_ciInf [Finite α] (hf : BddBelow (Set.range f)) :\n    essInf f (uniformOn univ) = ⨅ a, f a :=\n  essInf_eq_ciInf (by simp [uniformOn, cond_apply, Set.finite_univ]) hf\n\n"}
{"name":"essSup_eq_sInf","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder β\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → β\n⊢ Eq (essSup f μ) (InfSet.sInf (setOf fun a => Eq (μ (setOf fun x => LT.lt a (f x))) 0))","decl":"theorem essSup_eq_sInf {m : MeasurableSpace α} (μ : Measure α) (f : α → β) :\n    essSup f μ = sInf { a | μ { x | a < f x } = 0 } := by\n  dsimp [essSup, limsup, limsSup]\n  simp only [eventually_map, ae_iff, not_le]\n\n"}
{"name":"essInf_eq_sSup","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder β\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → β\n⊢ Eq (essInf f μ) (SupSet.sSup (setOf fun a => Eq (μ (setOf fun x => LT.lt (f x) a)) 0))","decl":"theorem essInf_eq_sSup {m : MeasurableSpace α} (μ : Measure α) (f : α → β) :\n    essInf f μ = sSup { a | μ { x | f x < a } = 0 } := by\n  dsimp [essInf, liminf, limsInf]\n  simp only [eventually_map, ae_iff, not_le]\n\n"}
{"name":"ae_lt_of_essSup_lt","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : ConditionallyCompleteLinearOrder β\nx : β\nf : α → β\nhx : LT.lt (essSup f μ) x\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (MeasureTheory.ae μ) f) _auto✝\n⊢ Filter.Eventually (fun y => LT.lt (f y) x) (MeasureTheory.ae μ)","decl":"theorem ae_lt_of_essSup_lt (hx : essSup f μ < x)\n    (hf : IsBoundedUnder (· ≤ ·) (ae μ) f := by isBoundedDefault) :\n    ∀ᵐ y ∂μ, f y < x :=\n  eventually_lt_of_limsup_lt hx hf\n\n"}
{"name":"ae_lt_of_lt_essInf","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : ConditionallyCompleteLinearOrder β\nx : β\nf : α → β\nhx : LT.lt x (essInf f μ)\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) (MeasureTheory.ae μ) f) _auto✝\n⊢ Filter.Eventually (fun y => LT.lt x (f y)) (MeasureTheory.ae μ)","decl":"theorem ae_lt_of_lt_essInf (hx : x < essInf f μ)\n    (hf : IsBoundedUnder (· ≥ ·) (ae μ) f := by isBoundedDefault) :\n    ∀ᵐ y ∂μ, x < f y :=\n  eventually_lt_of_lt_liminf hx hf\n\n"}
{"name":"ae_le_essSup","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : ConditionallyCompleteLinearOrder β\nf : α → β\ninst✝² : TopologicalSpace β\ninst✝¹ : FirstCountableTopology β\ninst✝ : OrderTopology β\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (MeasureTheory.ae μ) f) _auto✝\n⊢ Filter.Eventually (fun y => LE.le (f y) (essSup f μ)) (MeasureTheory.ae μ)","decl":"theorem ae_le_essSup\n    (hf : IsBoundedUnder (· ≤ ·) (ae μ) f := by isBoundedDefault) :\n    ∀ᵐ y ∂μ, f y ≤ essSup f μ :=\n  eventually_le_limsup hf\n\n"}
{"name":"ae_essInf_le","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : ConditionallyCompleteLinearOrder β\nf : α → β\ninst✝² : TopologicalSpace β\ninst✝¹ : FirstCountableTopology β\ninst✝ : OrderTopology β\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) (MeasureTheory.ae μ) f) _auto✝\n⊢ Filter.Eventually (fun y => LE.le (essInf f μ) (f y)) (MeasureTheory.ae μ)","decl":"theorem ae_essInf_le\n    (hf : IsBoundedUnder (· ≥ ·) (ae μ) f := by isBoundedDefault) :\n    ∀ᵐ y ∂μ, essInf f μ ≤ f y :=\n  eventually_liminf_le hf\n\n"}
{"name":"meas_essSup_lt","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : ConditionallyCompleteLinearOrder β\nf : α → β\ninst✝² : TopologicalSpace β\ninst✝¹ : FirstCountableTopology β\ninst✝ : OrderTopology β\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (MeasureTheory.ae μ) f) _auto✝\n⊢ Eq (μ (setOf fun y => LT.lt (essSup f μ) (f y))) 0","decl":"theorem meas_essSup_lt\n    (hf : IsBoundedUnder (· ≤ ·) (ae μ) f := by isBoundedDefault) :\n    μ { y | essSup f μ < f y } = 0 := by\n  simp_rw [← not_le]\n  exact ae_le_essSup hf\n\n"}
{"name":"meas_lt_essInf","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : ConditionallyCompleteLinearOrder β\nf : α → β\ninst✝² : TopologicalSpace β\ninst✝¹ : FirstCountableTopology β\ninst✝ : OrderTopology β\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) (MeasureTheory.ae μ) f) _auto✝\n⊢ Eq (μ (setOf fun y => LT.lt (f y) (essInf f μ))) 0","decl":"theorem meas_lt_essInf\n    (hf : IsBoundedUnder (· ≥ ·) (ae μ) f := by isBoundedDefault) :\n    μ { y | f y < essInf f μ } = 0 := by\n  simp_rw [← not_le]\n  exact ae_essInf_le hf\n\n"}
{"name":"essSup_measure_zero","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice β\nm : MeasurableSpace α\nf : α → β\n⊢ Eq (essSup f 0) Bot.bot","decl":"@[simp]\ntheorem essSup_measure_zero {m : MeasurableSpace α} {f : α → β} : essSup f (0 : Measure α) = ⊥ :=\n  le_bot_iff.mp (sInf_le (by simp [Set.mem_setOf_eq, EventuallyLE, ae_iff]))\n\n"}
{"name":"essInf_measure_zero","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice β\nx✝ : MeasurableSpace α\nf : α → β\n⊢ Eq (essInf f 0) Top.top","decl":"@[simp]\ntheorem essInf_measure_zero {_ : MeasurableSpace α} {f : α → β} : essInf f (0 : Measure α) = ⊤ :=\n  @essSup_measure_zero α βᵒᵈ _ _ _\n\n"}
{"name":"essSup_mono_ae","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : CompleteLattice β\nf g : α → β\nhfg : (MeasureTheory.ae μ).EventuallyLE f g\n⊢ LE.le (essSup f μ) (essSup g μ)","decl":"theorem essSup_mono_ae {f g : α → β} (hfg : f ≤ᵐ[μ] g) : essSup f μ ≤ essSup g μ :=\n  limsup_le_limsup hfg\n\n"}
{"name":"essInf_mono_ae","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : CompleteLattice β\nf g : α → β\nhfg : (MeasureTheory.ae μ).EventuallyLE f g\n⊢ LE.le (essInf f μ) (essInf g μ)","decl":"theorem essInf_mono_ae {f g : α → β} (hfg : f ≤ᵐ[μ] g) : essInf f μ ≤ essInf g μ :=\n  liminf_le_liminf hfg\n\n"}
{"name":"essSup_le_of_ae_le","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : CompleteLattice β\nf : α → β\nc : β\nhf : (MeasureTheory.ae μ).EventuallyLE f fun x => c\n⊢ LE.le (essSup f μ) c","decl":"theorem essSup_le_of_ae_le {f : α → β} (c : β) (hf : f ≤ᵐ[μ] fun _ => c) : essSup f μ ≤ c :=\n  limsup_le_of_le (by isBoundedDefault) hf\n\n"}
{"name":"le_essInf_of_ae_le","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : CompleteLattice β\nf : α → β\nc : β\nhf : (MeasureTheory.ae μ).EventuallyLE (fun x => c) f\n⊢ LE.le c (essInf f μ)","decl":"theorem le_essInf_of_ae_le {f : α → β} (c : β) (hf : (fun _ => c) ≤ᵐ[μ] f) : c ≤ essInf f μ :=\n  @essSup_le_of_ae_le α βᵒᵈ _ _ _ _ c hf\n\n"}
{"name":"essSup_const_bot","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : CompleteLattice β\n⊢ Eq (essSup (fun x => Bot.bot) μ) Bot.bot","decl":"theorem essSup_const_bot : essSup (fun _ : α => (⊥ : β)) μ = (⊥ : β) :=\n  limsup_const_bot\n\n"}
{"name":"essInf_const_top","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : CompleteLattice β\n⊢ Eq (essInf (fun x => Top.top) μ) Top.top","decl":"theorem essInf_const_top : essInf (fun _ : α => (⊤ : β)) μ = (⊤ : β) :=\n  liminf_const_top\n\n"}
{"name":"OrderIso.essSup_apply","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice β\nm : MeasurableSpace α\nγ : Type u_3\ninst✝ : CompleteLattice γ\nf : α → β\nμ : MeasureTheory.Measure α\ng : OrderIso β γ\n⊢ Eq (g (essSup f μ)) (essSup (fun x => g (f x)) μ)","decl":"theorem OrderIso.essSup_apply {m : MeasurableSpace α} {γ} [CompleteLattice γ] (f : α → β)\n    (μ : Measure α) (g : β ≃o γ) : g (essSup f μ) = essSup (fun x => g (f x)) μ := by\n  refine OrderIso.limsup_apply g ?_ ?_ ?_ ?_\n  all_goals isBoundedDefault\n\n"}
{"name":"OrderIso.essInf_apply","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteLattice β\nx✝ : MeasurableSpace α\nγ : Type u_3\ninst✝ : CompleteLattice γ\nf : α → β\nμ : MeasureTheory.Measure α\ng : OrderIso β γ\n⊢ Eq (g (essInf f μ)) (essInf (fun x => g (f x)) μ)","decl":"theorem OrderIso.essInf_apply {_ : MeasurableSpace α} {γ} [CompleteLattice γ] (f : α → β)\n    (μ : Measure α) (g : β ≃o γ) : g (essInf f μ) = essInf (fun x => g (f x)) μ :=\n  @OrderIso.essSup_apply α βᵒᵈ _ _ γᵒᵈ _ _ _ g.dual\n\n"}
{"name":"essSup_mono_measure","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : CompleteLattice β\nf : α → β\nhμν : ν.AbsolutelyContinuous μ\n⊢ LE.le (essSup f ν) (essSup f μ)","decl":"theorem essSup_mono_measure {f : α → β} (hμν : ν ≪ μ) : essSup f ν ≤ essSup f μ := by\n  refine limsup_le_limsup_of_le (Measure.ae_le_iff_absolutelyContinuous.mpr hμν) ?_ ?_\n  all_goals isBoundedDefault\n\n"}
{"name":"essSup_mono_measure'","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_3\nβ : Type u_4\nx✝ : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : CompleteLattice β\nf : α → β\nhμν : LE.le ν μ\n⊢ LE.le (essSup f ν) (essSup f μ)","decl":"theorem essSup_mono_measure' {α : Type*} {β : Type*} {_ : MeasurableSpace α}\n    {μ ν : MeasureTheory.Measure α} [CompleteLattice β] {f : α → β} (hμν : ν ≤ μ) :\n    essSup f ν ≤ essSup f μ :=\n  essSup_mono_measure (Measure.absolutelyContinuous_of_le hμν)\n\n"}
{"name":"essInf_antitone_measure","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : CompleteLattice β\nf : α → β\nhμν : μ.AbsolutelyContinuous ν\n⊢ LE.le (essInf f ν) (essInf f μ)","decl":"theorem essInf_antitone_measure {f : α → β} (hμν : μ ≪ ν) : essInf f ν ≤ essInf f μ := by\n  refine liminf_le_liminf_of_le (Measure.ae_le_iff_absolutelyContinuous.mpr hμν) ?_ ?_\n  all_goals isBoundedDefault\n\n"}
{"name":"essSup_eq_iSup","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : CompleteLattice β\nhμ : ∀ (a : α), Ne (μ (Singleton.singleton a)) 0\nf : α → β\n⊢ Eq (essSup f μ) (iSup fun i => f i)","decl":"lemma essSup_eq_iSup (hμ : ∀ a, μ {a} ≠ 0) (f : α → β) : essSup f μ = ⨆ i, f i := by\n  rw [essSup, ae_eq_top.2 hμ, limsup_top_eq_iSup]\n\n"}
{"name":"essInf_eq_iInf","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : CompleteLattice β\nhμ : ∀ (a : α), Ne (μ (Singleton.singleton a)) 0\nf : α → β\n⊢ Eq (essInf f μ) (iInf fun i => f i)","decl":"lemma essInf_eq_iInf (hμ : ∀ a, μ {a} ≠ 0) (f : α → β) : essInf f μ = ⨅ i, f i := by\n  rw [essInf, ae_eq_top.2 hμ, liminf_top_eq_iInf]\n\n"}
{"name":"essSup_count","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝¹ : CompleteLattice β\ninst✝ : MeasurableSingletonClass α\nf : α → β\n⊢ Eq (essSup f MeasureTheory.Measure.count) (iSup fun i => f i)","decl":"@[simp] lemma essSup_count [MeasurableSingletonClass α] (f : α → β) : essSup f .count = ⨆ i, f i :=\n  essSup_eq_iSup (by simp) _\n\n"}
{"name":"essInf_count","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝¹ : CompleteLattice β\ninst✝ : MeasurableSingletonClass α\nf : α → β\n⊢ Eq (essInf f MeasureTheory.Measure.count) (iInf fun i => f i)","decl":"@[simp] lemma essInf_count [MeasurableSingletonClass α] (f : α → β) : essInf f .count = ⨅ i, f i :=\n  essInf_eq_iInf (by simp) _\n\n"}
{"name":"essSup_comp_le_essSup_map_measure","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : CompleteLattice β\nγ : Type u_3\nmγ : MeasurableSpace γ\nf : α → γ\ng : γ → β\nhf : AEMeasurable f μ\n⊢ LE.le (essSup (Function.comp g f) μ) (essSup g (MeasureTheory.Measure.map f μ))","decl":"theorem essSup_comp_le_essSup_map_measure (hf : AEMeasurable f μ) :\n    essSup (g ∘ f) μ ≤ essSup g (Measure.map f μ) := by\n  refine limsSup_le_limsSup_of_le ?_\n  rw [← Filter.map_map]\n  exact Filter.map_mono (Measure.tendsto_ae_map hf)\n\n"}
{"name":"MeasurableEmbedding.essSup_map_measure","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : CompleteLattice β\nγ : Type u_3\nmγ : MeasurableSpace γ\nf : α → γ\ng : γ → β\nhf : MeasurableEmbedding f\n⊢ Eq (essSup g (MeasureTheory.Measure.map f μ)) (essSup (Function.comp g f) μ)","decl":"theorem MeasurableEmbedding.essSup_map_measure (hf : MeasurableEmbedding f) :\n    essSup g (Measure.map f μ) = essSup (g ∘ f) μ := by\n  refine le_antisymm ?_ (essSup_comp_le_essSup_map_measure hf.measurable.aemeasurable)\n  refine limsSup_le_limsSup (by isBoundedDefault) (by isBoundedDefault) (fun c h_le => ?_)\n  rw [eventually_map] at h_le ⊢\n  exact hf.ae_map_iff.mpr h_le\n\n"}
{"name":"essSup_map_measure_of_measurable","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁵ : CompleteLattice β\nγ : Type u_3\nmγ : MeasurableSpace γ\nf : α → γ\ng : γ → β\ninst✝⁴ : MeasurableSpace β\ninst✝³ : TopologicalSpace β\ninst✝² : SecondCountableTopology β\ninst✝¹ : OrderClosedTopology β\ninst✝ : OpensMeasurableSpace β\nhg : Measurable g\nhf : AEMeasurable f μ\n⊢ Eq (essSup g (MeasureTheory.Measure.map f μ)) (essSup (Function.comp g f) μ)","decl":"theorem essSup_map_measure_of_measurable (hg : Measurable g) (hf : AEMeasurable f μ) :\n    essSup g (Measure.map f μ) = essSup (g ∘ f) μ := by\n  refine le_antisymm ?_ (essSup_comp_le_essSup_map_measure hf)\n  refine limsSup_le_limsSup (by isBoundedDefault) (by isBoundedDefault) (fun c h_le => ?_)\n  rw [eventually_map] at h_le ⊢\n  rw [ae_map_iff hf (measurableSet_le hg measurable_const)]\n  exact h_le\n\n"}
{"name":"essSup_map_measure","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁵ : CompleteLattice β\nγ : Type u_3\nmγ : MeasurableSpace γ\nf : α → γ\ng : γ → β\ninst✝⁴ : MeasurableSpace β\ninst✝³ : TopologicalSpace β\ninst✝² : SecondCountableTopology β\ninst✝¹ : OrderClosedTopology β\ninst✝ : OpensMeasurableSpace β\nhg : AEMeasurable g (MeasureTheory.Measure.map f μ)\nhf : AEMeasurable f μ\n⊢ Eq (essSup g (MeasureTheory.Measure.map f μ)) (essSup (Function.comp g f) μ)","decl":"theorem essSup_map_measure (hg : AEMeasurable g (Measure.map f μ)) (hf : AEMeasurable f μ) :\n    essSup g (Measure.map f μ) = essSup (g ∘ f) μ := by\n  rw [essSup_congr_ae hg.ae_eq_mk, essSup_map_measure_of_measurable hg.measurable_mk hf]\n  refine essSup_congr_ae ?_\n  have h_eq := ae_of_ae_map hf hg.ae_eq_mk\n  rw [← EventuallyEq] at h_eq\n  exact h_eq.symm\n\n"}
{"name":"ENNReal.essSup_piecewise","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\ng : α → ENNReal\nhs : MeasurableSet s\n⊢ Eq (essSup (s.piecewise f g) μ) (Max.max (essSup f (μ.restrict s)) (essSup g (μ.restrict (HasCompl.compl s))))","decl":"lemma essSup_piecewise {s : Set α} [DecidablePred (· ∈ s)] {g} (hs : MeasurableSet s) :\n    essSup (s.piecewise f g) μ = max (essSup f (μ.restrict s)) (essSup g (μ.restrict sᶜ)) := by\n  simp only [essSup, limsup_piecewise, blimsup_eq_limsup, ae_restrict_eq, hs, hs.compl]; rfl\n\n"}
{"name":"ENNReal.essSup_indicator_eq_essSup_restrict","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\nhs : MeasurableSet s\n⊢ Eq (essSup (s.indicator f) μ) (essSup f (μ.restrict s))","decl":"theorem essSup_indicator_eq_essSup_restrict {s : Set α} {f : α → ℝ≥0∞} (hs : MeasurableSet s) :\n    essSup (s.indicator f) μ = essSup f (μ.restrict s) := by\n  classical\n  simp only [← piecewise_eq_indicator, essSup_piecewise hs, max_eq_left_iff]\n  exact limsup_const_bot.trans_le (zero_le _)\n\n"}
{"name":"ENNReal.ae_le_essSup","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Filter.Eventually (fun y => LE.le (f y) (essSup f μ)) (MeasureTheory.ae μ)","decl":"theorem ae_le_essSup (f : α → ℝ≥0∞) : ∀ᵐ y ∂μ, f y ≤ essSup f μ :=\n  eventually_le_limsup f\n\n"}
{"name":"ENNReal.essSup_eq_zero_iff","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Iff (Eq (essSup f μ) 0) ((MeasureTheory.ae μ).EventuallyEq f 0)","decl":"@[simp]\ntheorem essSup_eq_zero_iff : essSup f μ = 0 ↔ f =ᵐ[μ] 0 :=\n  limsup_eq_zero_iff\n\n"}
{"name":"ENNReal.essSup_const_mul","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\na : ENNReal\n⊢ Eq (essSup (fun x => HMul.hMul a (f x)) μ) (HMul.hMul a (essSup f μ))","decl":"theorem essSup_const_mul {a : ℝ≥0∞} : essSup (fun x : α => a * f x) μ = a * essSup f μ :=\n  limsup_const_mul\n\n"}
{"name":"ENNReal.essSup_mul_le","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\n⊢ LE.le (essSup (HMul.hMul f g) μ) (HMul.hMul (essSup f μ) (essSup g μ))","decl":"theorem essSup_mul_le (f g : α → ℝ≥0∞) : essSup (f * g) μ ≤ essSup f μ * essSup g μ :=\n  limsup_mul_le f g\n\n"}
{"name":"ENNReal.essSup_add_le","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\n⊢ LE.le (essSup (HAdd.hAdd f g) μ) (HAdd.hAdd (essSup f μ) (essSup g μ))","decl":"theorem essSup_add_le (f g : α → ℝ≥0∞) : essSup (f + g) μ ≤ essSup f μ + essSup g μ :=\n  limsup_add_le f g\n\n"}
{"name":"ENNReal.essSup_liminf_le","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_3\ninst✝¹ : Countable ι\ninst✝ : LinearOrder ι\nf : ι → α → ENNReal\n⊢ LE.le (essSup (fun x => Filter.liminf (fun n => f n x) Filter.atTop) μ) (Filter.liminf (fun n => essSup (fun x => f n x) μ) Filter.atTop)","decl":"theorem essSup_liminf_le {ι} [Countable ι] [LinearOrder ι] (f : ι → α → ℝ≥0∞) :\n    essSup (fun x => atTop.liminf fun n => f n x) μ ≤\n      atTop.liminf fun n => essSup (fun x => f n x) μ := by\n  simp_rw [essSup]\n  exact ENNReal.limsup_liminf_le_liminf_limsup fun a b => f b a\n\n"}
{"name":"ENNReal.coe_essSup","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → NNReal\nhf : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (MeasureTheory.ae μ) f\n⊢ Eq (↑(essSup f μ)) (essSup (fun x => ↑(f x)) μ)","decl":"theorem coe_essSup {f : α → ℝ≥0} (hf : IsBoundedUnder (· ≤ ·) (ae μ) f) :\n    ((essSup f μ : ℝ≥0) : ℝ≥0∞) = essSup (fun x => (f x : ℝ≥0∞)) μ :=\n  (ENNReal.coe_sInf <| hf).trans <|\n    eq_of_forall_le_iff fun r => by\n      simp [essSup, limsup, limsSup, eventually_map, ENNReal.forall_ennreal]; rfl\n\n"}
{"name":"ENNReal.essSup_restrict_eq_of_support_subset","module":"Mathlib.MeasureTheory.Function.EssSup","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → ENNReal\nhsf : HasSubset.Subset (Function.support f) s\n⊢ Eq (essSup f (μ.restrict s)) (essSup f μ)","decl":"lemma essSup_restrict_eq_of_support_subset {s : Set α} {f : α → ℝ≥0∞} (hsf : f.support ⊆ s) :\n    essSup f (μ.restrict s) = essSup f μ := by\n  apply le_antisymm (essSup_mono_measure' Measure.restrict_le_self)\n  apply le_of_forall_lt (fun c hc ↦ ?_)\n  obtain ⟨d, cd, hd⟩ : ∃ d, c < d ∧ d < essSup f μ := exists_between hc\n  let t := {x | d < f x}\n  have A : 0 < (μ.restrict t) t := by\n    simp only [Measure.restrict_apply_self]\n    rw [essSup_eq_sInf] at hd\n    have : d ∉ {a | μ {x | a < f x} = 0} := not_mem_of_lt_csInf hd (OrderBot.bddBelow _)\n    exact bot_lt_iff_ne_bot.2 this\n  have B : 0 < (μ.restrict s) t := by\n    have : μ.restrict t ≤ μ.restrict s := by\n      apply Measure.restrict_mono _ le_rfl\n      apply subset_trans _ hsf\n      intro x (hx : d < f x)\n      exact (lt_of_le_of_lt bot_le hx).ne'\n    exact lt_of_lt_of_le A (this _)\n  apply cd.trans_le\n  rw [essSup_eq_sInf]\n  apply le_sInf (fun b hb ↦ ?_)\n  contrapose! hb\n  exact ne_of_gt (B.trans_le (measure_mono (fun x hx ↦ hb.trans hx)))\n\n"}
