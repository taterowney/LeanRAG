{"name":"FirstOrder.Language.Term.var.injEq","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\na✝¹ a✝ : α\n⊢ Eq (Eq (FirstOrder.Language.Term.var a✝¹) (FirstOrder.Language.Term.var a✝)) (Eq a✝¹ a✝)","decl":"/-- A term on `α` is either a variable indexed by an element of `α`\n  or a function symbol applied to simpler terms. -/\ninductive Term (α : Type u') : Type max u u'\n  | var : α → Term α\n  | func : ∀ {l : ℕ} (_f : L.Functions l) (_ts : Fin l → Term α), Term α\n"}
{"name":"FirstOrder.Language.Term.func.sizeOf_spec","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\ninst✝ : SizeOf α\nl : Nat\n_f : L.Functions l\n_ts : Fin l → L.Term α\n⊢ Eq (SizeOf.sizeOf (FirstOrder.Language.Term.func _f _ts)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf l)) (SizeOf.sizeOf _f))","decl":"/-- A term on `α` is either a variable indexed by an element of `α`\n  or a function symbol applied to simpler terms. -/\ninductive Term (α : Type u') : Type max u u'\n  | var : α → Term α\n  | func : ∀ {l : ℕ} (_f : L.Functions l) (_ts : Fin l → Term α), Term α\n"}
{"name":"FirstOrder.Language.Term.var.inj","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\na✝¹ a✝ : α\nx✝ : Eq (FirstOrder.Language.Term.var a✝¹) (FirstOrder.Language.Term.var a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- A term on `α` is either a variable indexed by an element of `α`\n  or a function symbol applied to simpler terms. -/\ninductive Term (α : Type u') : Type max u u'\n  | var : α → Term α\n  | func : ∀ {l : ℕ} (_f : L.Functions l) (_ts : Fin l → Term α), Term α\n"}
{"name":"FirstOrder.Language.Term.func.injEq","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nl✝ : Nat\n_f✝ : L.Functions l✝\n_ts✝ : Fin l✝ → L.Term α\nl : Nat\n_f : L.Functions l\n_ts : Fin l → L.Term α\n⊢ Eq (Eq (FirstOrder.Language.Term.func _f✝ _ts✝) (FirstOrder.Language.Term.func _f _ts)) (And (Eq l✝ l) (And (HEq _f✝ _f) (HEq _ts✝ _ts)))","decl":"/-- A term on `α` is either a variable indexed by an element of `α`\n  or a function symbol applied to simpler terms. -/\ninductive Term (α : Type u') : Type max u u'\n  | var : α → Term α\n  | func : ∀ {l : ℕ} (_f : L.Functions l) (_ts : Fin l → Term α), Term α\n"}
{"name":"FirstOrder.Language.Term.var.sizeOf_spec","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\ninst✝ : SizeOf α\na✝ : α\n⊢ Eq (SizeOf.sizeOf (FirstOrder.Language.Term.var a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- A term on `α` is either a variable indexed by an element of `α`\n  or a function symbol applied to simpler terms. -/\ninductive Term (α : Type u') : Type max u u'\n  | var : α → Term α\n  | func : ∀ {l : ℕ} (_f : L.Functions l) (_ts : Fin l → Term α), Term α\n"}
{"name":"FirstOrder.Language.Term.func.inj","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nl✝ : Nat\n_f✝ : L.Functions l✝\n_ts✝ : Fin l✝ → L.Term α\nl : Nat\n_f : L.Functions l\n_ts : Fin l → L.Term α\nx✝ : Eq (FirstOrder.Language.Term.func _f✝ _ts✝) (FirstOrder.Language.Term.func _f _ts)\n⊢ And (Eq l✝ l) (And (HEq _f✝ _f) (HEq _ts✝ _ts))","decl":"/-- A term on `α` is either a variable indexed by an element of `α`\n  or a function symbol applied to simpler terms. -/\ninductive Term (α : Type u') : Type max u u'\n  | var : α → Term α\n  | func : ∀ {l : ℕ} (_f : L.Functions l) (_ts : Fin l → Term α), Term α\n"}
{"name":"FirstOrder.Language.Term.relabel_id","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nt : L.Term α\n⊢ Eq (FirstOrder.Language.Term.relabel id t) t","decl":"theorem relabel_id (t : L.Term α) : t.relabel id = t := by\n  induction t with\n  | var => rfl\n  | func _ _ ih => simp [ih]\n\n"}
{"name":"FirstOrder.Language.Term.relabel_id_eq_id","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\n⊢ Eq (FirstOrder.Language.Term.relabel id) id","decl":"@[simp]\ntheorem relabel_id_eq_id : (Term.relabel id : L.Term α → L.Term α) = id :=\n  funext relabel_id\n\n"}
{"name":"FirstOrder.Language.Term.relabel_relabel","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\nγ : Type u_1\nf : α → β\ng : β → γ\nt : L.Term α\n⊢ Eq (FirstOrder.Language.Term.relabel g (FirstOrder.Language.Term.relabel f t)) (FirstOrder.Language.Term.relabel (Function.comp g f) t)","decl":"@[simp]\ntheorem relabel_relabel (f : α → β) (g : β → γ) (t : L.Term α) :\n    (t.relabel f).relabel g = t.relabel (g ∘ f) := by\n  induction t with\n  | var => rfl\n  | func _ _ ih => simp [ih]\n\n"}
{"name":"FirstOrder.Language.Term.relabel_comp_relabel","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\nγ : Type u_1\nf : α → β\ng : β → γ\n⊢ Eq (Function.comp (FirstOrder.Language.Term.relabel g) (FirstOrder.Language.Term.relabel f)) (FirstOrder.Language.Term.relabel (Function.comp g f))","decl":"@[simp]\ntheorem relabel_comp_relabel (f : α → β) (g : β → γ) :\n    (Term.relabel g ∘ Term.relabel f : L.Term α → L.Term γ) = Term.relabel (g ∘ f) :=\n  funext (relabel_relabel f g)\n\n"}
{"name":"FirstOrder.Language.Term.relabelEquiv_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\ng : Equiv α β\na✝ : L.Term α\n⊢ Eq ((FirstOrder.Language.Term.relabelEquiv g) a✝) (FirstOrder.Language.Term.relabel (⇑g) a✝)","decl":"/-- Relabels a term's variables along a bijection. -/\n@[simps]\ndef relabelEquiv (g : α ≃ β) : L.Term α ≃ L.Term β :=\n  ⟨relabel g, relabel g.symm, fun t => by simp, fun t => by simp⟩\n\n-- Porting note: universes in different order\n"}
{"name":"FirstOrder.Language.Term.relabelEquiv_symm_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\ng : Equiv α β\na✝ : L.Term β\n⊢ Eq ((FirstOrder.Language.Term.relabelEquiv g).symm a✝) (FirstOrder.Language.Term.relabel (⇑g.symm) a✝)","decl":"/-- Relabels a term's variables along a bijection. -/\n@[simps]\ndef relabelEquiv (g : α ≃ β) : L.Term α ≃ L.Term β :=\n  ⟨relabel g, relabel g.symm, fun t => by simp, fun t => by simp⟩\n\n-- Porting note: universes in different order\n"}
{"name":"FirstOrder.Language.Term.constantsVarsEquiv_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nγ : Type u_1\na✝ : (L.withConstants γ).Term α\n⊢ Eq (FirstOrder.Language.Term.constantsVarsEquiv a✝) a✝.constantsToVars","decl":"/-- A bijection between terms with constants and terms with extra variables. -/\n@[simps]\ndef constantsVarsEquiv : L[[γ]].Term α ≃ L.Term (γ ⊕ α) :=\n  ⟨constantsToVars, varsToConstants, by\n    intro t\n    induction t with\n    | var => rfl\n    | @func n f _ ih =>\n      cases n\n      · cases f\n        · simp [constantsToVars, varsToConstants, ih]\n        · simp [constantsToVars, varsToConstants, Constants.term, eq_iff_true_of_subsingleton]\n      · cases' f with f f\n        · simp [constantsToVars, varsToConstants, ih]\n        · exact isEmptyElim f, by\n    intro t\n    induction' t with x n f _ ih\n    · cases x <;> rfl\n    · cases n <;> · simp [varsToConstants, constantsToVars, ih]⟩\n\n"}
{"name":"FirstOrder.Language.Term.constantsVarsEquiv_symm_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nγ : Type u_1\na✝ : L.Term (Sum γ α)\n⊢ Eq (FirstOrder.Language.Term.constantsVarsEquiv.symm a✝) a✝.varsToConstants","decl":"/-- A bijection between terms with constants and terms with extra variables. -/\n@[simps]\ndef constantsVarsEquiv : L[[γ]].Term α ≃ L.Term (γ ⊕ α) :=\n  ⟨constantsToVars, varsToConstants, by\n    intro t\n    induction t with\n    | var => rfl\n    | @func n f _ ih =>\n      cases n\n      · cases f\n        · simp [constantsToVars, varsToConstants, ih]\n        · simp [constantsToVars, varsToConstants, Constants.term, eq_iff_true_of_subsingleton]\n      · cases' f with f f\n        · simp [constantsToVars, varsToConstants, ih]\n        · exact isEmptyElim f, by\n    intro t\n    induction' t with x n f _ ih\n    · cases x <;> rfl\n    · cases n <;> · simp [varsToConstants, constantsToVars, ih]⟩\n\n"}
{"name":"FirstOrder.Language.Term.constantsVarsEquivLeft_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\nγ : Type u_1\nt : (L.withConstants γ).Term (Sum α β)\n⊢ Eq (FirstOrder.Language.Term.constantsVarsEquivLeft t) (FirstOrder.Language.Term.relabel (⇑(Equiv.sumAssoc γ α β).symm) t.constantsToVars)","decl":"@[simp]\ntheorem constantsVarsEquivLeft_apply (t : L[[γ]].Term (α ⊕ β)) :\n    constantsVarsEquivLeft t = (constantsToVars t).relabel (Equiv.sumAssoc _ _ _).symm :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Term.constantsVarsEquivLeft_symm_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\nγ : Type u_1\nt : L.Term (Sum (Sum γ α) β)\n⊢ Eq (FirstOrder.Language.Term.constantsVarsEquivLeft.symm t) (FirstOrder.Language.Term.relabel (⇑(Equiv.sumAssoc γ α β)) t).varsToConstants","decl":"@[simp]\ntheorem constantsVarsEquivLeft_symm_apply (t : L.Term ((γ ⊕ α) ⊕ β)) :\n    constantsVarsEquivLeft.symm t = varsToConstants (t.relabel (Equiv.sumAssoc _ _ _)) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.LHom.id_onTerm","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\n⊢ Eq (FirstOrder.Language.LHom.id L).onTerm id","decl":"@[simp]\ntheorem id_onTerm : ((LHom.id L).onTerm : L.Term α → L.Term α) = id := by\n  ext t\n  induction t with\n  | var => rfl\n  | func _ _ ih => simp_rw [onTerm, ih]; rfl\n\n"}
{"name":"FirstOrder.Language.LHom.comp_onTerm","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nα : Type u'\nL'' : FirstOrder.Language\nφ : L'.LHom L''\nψ : L.LHom L'\n⊢ Eq (φ.comp ψ).onTerm (Function.comp φ.onTerm ψ.onTerm)","decl":"@[simp]\ntheorem comp_onTerm {L'' : Language} (φ : L' →ᴸ L'') (ψ : L →ᴸ L') :\n    ((φ.comp ψ).onTerm : L.Term α → L''.Term α) = φ.onTerm ∘ ψ.onTerm := by\n  ext t\n  induction t with\n  | var => rfl\n  | func _ _ ih => simp_rw [onTerm, ih]; rfl\n\n"}
{"name":"FirstOrder.Language.Lequiv.onTerm_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nα : Type u'\nφ : L.LEquiv L'\na✝ : L.Term α\n⊢ Eq ((FirstOrder.Language.Lequiv.onTerm φ) a✝) (φ.toLHom.onTerm a✝)","decl":"/-- Maps a term's symbols along a language equivalence. -/\n@[simps]\ndef Lequiv.onTerm (φ : L ≃ᴸ L') : L.Term α ≃ L'.Term α where\n  toFun := φ.toLHom.onTerm\n  invFun := φ.invLHom.onTerm\n  left_inv := by\n    rw [Function.leftInverse_iff_comp, ← LHom.comp_onTerm, φ.left_inv, LHom.id_onTerm]\n  right_inv := by\n    rw [Function.rightInverse_iff_comp, ← LHom.comp_onTerm, φ.right_inv, LHom.id_onTerm]\n\n"}
{"name":"FirstOrder.Language.Lequiv.onTerm_symm_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nα : Type u'\nφ : L.LEquiv L'\na✝ : L'.Term α\n⊢ Eq ((FirstOrder.Language.Lequiv.onTerm φ).symm a✝) (φ.invLHom.onTerm a✝)","decl":"/-- Maps a term's symbols along a language equivalence. -/\n@[simps]\ndef Lequiv.onTerm (φ : L ≃ᴸ L') : L.Term α ≃ L'.Term α where\n  toFun := φ.toLHom.onTerm\n  invFun := φ.invLHom.onTerm\n  left_inv := by\n    rw [Function.leftInverse_iff_comp, ← LHom.comp_onTerm, φ.left_inv, LHom.id_onTerm]\n  right_inv := by\n    rw [Function.rightInverse_iff_comp, ← LHom.comp_onTerm, φ.right_inv, LHom.id_onTerm]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.imp.injEq","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nf₁✝ f₂✝ f₁ f₂ : L.BoundedFormula α n\n⊢ Eq (Eq (f₁✝.imp f₂✝) (f₁.imp f₂)) (And (Eq f₁✝ f₁) (Eq f₂✝ f₂))","decl":"/-- `BoundedFormula α n` is the type of formulas with free variables indexed by `α` and up to `n`\n  additional free variables. -/\ninductive BoundedFormula : ℕ → Type max u v u'\n  | falsum {n} : BoundedFormula n\n  | equal {n} (t₁ t₂ : L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | rel {n l : ℕ} (R : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | imp {n} (f₁ f₂ : BoundedFormula n) : BoundedFormula n\n  | all {n} (f : BoundedFormula (n + 1)) : BoundedFormula n\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.rel.injEq","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn l✝ : Nat\nR✝ : L.Relations l✝\nts✝ : Fin l✝ → L.Term (Sum α (Fin n))\nl : Nat\nR : L.Relations l\nts : Fin l → L.Term (Sum α (Fin n))\n⊢ Eq (Eq (FirstOrder.Language.BoundedFormula.rel R✝ ts✝) (FirstOrder.Language.BoundedFormula.rel R ts)) (And (Eq l✝ l) (And (HEq R✝ R) (HEq ts✝ ts)))","decl":"/-- `BoundedFormula α n` is the type of formulas with free variables indexed by `α` and up to `n`\n  additional free variables. -/\ninductive BoundedFormula : ℕ → Type max u v u'\n  | falsum {n} : BoundedFormula n\n  | equal {n} (t₁ t₂ : L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | rel {n l : ℕ} (R : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | imp {n} (f₁ f₂ : BoundedFormula n) : BoundedFormula n\n  | all {n} (f : BoundedFormula (n + 1)) : BoundedFormula n\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.all.sizeOf_spec","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\ninst✝ : SizeOf α\nn : Nat\nf : L.BoundedFormula α (HAdd.hAdd n 1)\n⊢ Eq (SizeOf.sizeOf f.all) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf n)) (SizeOf.sizeOf f))","decl":"/-- `BoundedFormula α n` is the type of formulas with free variables indexed by `α` and up to `n`\n  additional free variables. -/\ninductive BoundedFormula : ℕ → Type max u v u'\n  | falsum {n} : BoundedFormula n\n  | equal {n} (t₁ t₂ : L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | rel {n l : ℕ} (R : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | imp {n} (f₁ f₂ : BoundedFormula n) : BoundedFormula n\n  | all {n} (f : BoundedFormula (n + 1)) : BoundedFormula n\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.equal.inj","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nt₁✝ t₂✝ t₁ t₂ : L.Term (Sum α (Fin n))\nx✝ : Eq (FirstOrder.Language.BoundedFormula.equal t₁✝ t₂✝) (FirstOrder.Language.BoundedFormula.equal t₁ t₂)\n⊢ And (Eq t₁✝ t₁) (Eq t₂✝ t₂)","decl":"/-- `BoundedFormula α n` is the type of formulas with free variables indexed by `α` and up to `n`\n  additional free variables. -/\ninductive BoundedFormula : ℕ → Type max u v u'\n  | falsum {n} : BoundedFormula n\n  | equal {n} (t₁ t₂ : L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | rel {n l : ℕ} (R : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | imp {n} (f₁ f₂ : BoundedFormula n) : BoundedFormula n\n  | all {n} (f : BoundedFormula (n + 1)) : BoundedFormula n\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.rel.sizeOf_spec","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\ninst✝ : SizeOf α\nn l : Nat\nR : L.Relations l\nts : Fin l → L.Term (Sum α (Fin n))\n⊢ Eq (SizeOf.sizeOf (FirstOrder.Language.BoundedFormula.rel R ts)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf n)) (SizeOf.sizeOf l)) (SizeOf.sizeOf R))","decl":"/-- `BoundedFormula α n` is the type of formulas with free variables indexed by `α` and up to `n`\n  additional free variables. -/\ninductive BoundedFormula : ℕ → Type max u v u'\n  | falsum {n} : BoundedFormula n\n  | equal {n} (t₁ t₂ : L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | rel {n l : ℕ} (R : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | imp {n} (f₁ f₂ : BoundedFormula n) : BoundedFormula n\n  | all {n} (f : BoundedFormula (n + 1)) : BoundedFormula n\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.equal.sizeOf_spec","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\ninst✝ : SizeOf α\nn : Nat\nt₁ t₂ : L.Term (Sum α (Fin n))\n⊢ Eq (SizeOf.sizeOf (FirstOrder.Language.BoundedFormula.equal t₁ t₂)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf n)) (SizeOf.sizeOf t₁)) (SizeOf.sizeOf t₂))","decl":"/-- `BoundedFormula α n` is the type of formulas with free variables indexed by `α` and up to `n`\n  additional free variables. -/\ninductive BoundedFormula : ℕ → Type max u v u'\n  | falsum {n} : BoundedFormula n\n  | equal {n} (t₁ t₂ : L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | rel {n l : ℕ} (R : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | imp {n} (f₁ f₂ : BoundedFormula n) : BoundedFormula n\n  | all {n} (f : BoundedFormula (n + 1)) : BoundedFormula n\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.falsum.sizeOf_spec","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\ninst✝ : SizeOf α\nn : Nat\n⊢ Eq (SizeOf.sizeOf FirstOrder.Language.BoundedFormula.falsum) (HAdd.hAdd 1 (SizeOf.sizeOf n))","decl":"/-- `BoundedFormula α n` is the type of formulas with free variables indexed by `α` and up to `n`\n  additional free variables. -/\ninductive BoundedFormula : ℕ → Type max u v u'\n  | falsum {n} : BoundedFormula n\n  | equal {n} (t₁ t₂ : L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | rel {n l : ℕ} (R : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | imp {n} (f₁ f₂ : BoundedFormula n) : BoundedFormula n\n  | all {n} (f : BoundedFormula (n + 1)) : BoundedFormula n\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.equal.injEq","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nt₁✝ t₂✝ t₁ t₂ : L.Term (Sum α (Fin n))\n⊢ Eq (Eq (FirstOrder.Language.BoundedFormula.equal t₁✝ t₂✝) (FirstOrder.Language.BoundedFormula.equal t₁ t₂)) (And (Eq t₁✝ t₁) (Eq t₂✝ t₂))","decl":"/-- `BoundedFormula α n` is the type of formulas with free variables indexed by `α` and up to `n`\n  additional free variables. -/\ninductive BoundedFormula : ℕ → Type max u v u'\n  | falsum {n} : BoundedFormula n\n  | equal {n} (t₁ t₂ : L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | rel {n l : ℕ} (R : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | imp {n} (f₁ f₂ : BoundedFormula n) : BoundedFormula n\n  | all {n} (f : BoundedFormula (n + 1)) : BoundedFormula n\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.all.inj","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nf✝ f : L.BoundedFormula α (HAdd.hAdd n 1)\nx✝ : Eq f✝.all f.all\n⊢ Eq f✝ f","decl":"/-- `BoundedFormula α n` is the type of formulas with free variables indexed by `α` and up to `n`\n  additional free variables. -/\ninductive BoundedFormula : ℕ → Type max u v u'\n  | falsum {n} : BoundedFormula n\n  | equal {n} (t₁ t₂ : L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | rel {n l : ℕ} (R : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | imp {n} (f₁ f₂ : BoundedFormula n) : BoundedFormula n\n  | all {n} (f : BoundedFormula (n + 1)) : BoundedFormula n\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.all.injEq","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nf✝ f : L.BoundedFormula α (HAdd.hAdd n 1)\n⊢ Eq (Eq f✝.all f.all) (Eq f✝ f)","decl":"/-- `BoundedFormula α n` is the type of formulas with free variables indexed by `α` and up to `n`\n  additional free variables. -/\ninductive BoundedFormula : ℕ → Type max u v u'\n  | falsum {n} : BoundedFormula n\n  | equal {n} (t₁ t₂ : L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | rel {n l : ℕ} (R : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | imp {n} (f₁ f₂ : BoundedFormula n) : BoundedFormula n\n  | all {n} (f : BoundedFormula (n + 1)) : BoundedFormula n\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.imp.sizeOf_spec","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\ninst✝ : SizeOf α\nn : Nat\nf₁ f₂ : L.BoundedFormula α n\n⊢ Eq (SizeOf.sizeOf (f₁.imp f₂)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf n)) (SizeOf.sizeOf f₁)) (SizeOf.sizeOf f₂))","decl":"/-- `BoundedFormula α n` is the type of formulas with free variables indexed by `α` and up to `n`\n  additional free variables. -/\ninductive BoundedFormula : ℕ → Type max u v u'\n  | falsum {n} : BoundedFormula n\n  | equal {n} (t₁ t₂ : L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | rel {n l : ℕ} (R : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | imp {n} (f₁ f₂ : BoundedFormula n) : BoundedFormula n\n  | all {n} (f : BoundedFormula (n + 1)) : BoundedFormula n\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.imp.inj","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nf₁✝ f₂✝ f₁ f₂ : L.BoundedFormula α n\nx✝ : Eq (f₁✝.imp f₂✝) (f₁.imp f₂)\n⊢ And (Eq f₁✝ f₁) (Eq f₂✝ f₂)","decl":"/-- `BoundedFormula α n` is the type of formulas with free variables indexed by `α` and up to `n`\n  additional free variables. -/\ninductive BoundedFormula : ℕ → Type max u v u'\n  | falsum {n} : BoundedFormula n\n  | equal {n} (t₁ t₂ : L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | rel {n l : ℕ} (R : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | imp {n} (f₁ f₂ : BoundedFormula n) : BoundedFormula n\n  | all {n} (f : BoundedFormula (n + 1)) : BoundedFormula n\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.rel.inj","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn l✝ : Nat\nR✝ : L.Relations l✝\nts✝ : Fin l✝ → L.Term (Sum α (Fin n))\nl : Nat\nR : L.Relations l\nts : Fin l → L.Term (Sum α (Fin n))\nx✝ : Eq (FirstOrder.Language.BoundedFormula.rel R✝ ts✝) (FirstOrder.Language.BoundedFormula.rel R ts)\n⊢ And (Eq l✝ l) (And (HEq R✝ R) (HEq ts✝ ts))","decl":"/-- `BoundedFormula α n` is the type of formulas with free variables indexed by `α` and up to `n`\n  additional free variables. -/\ninductive BoundedFormula : ℕ → Type max u v u'\n  | falsum {n} : BoundedFormula n\n  | equal {n} (t₁ t₂ : L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | rel {n l : ℕ} (R : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) : BoundedFormula n\n  | imp {n} (f₁ f₂ : BoundedFormula n) : BoundedFormula n\n  | all {n} (f : BoundedFormula (n + 1)) : BoundedFormula n\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.castLE_rfl","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nh : LE.le n n\nφ : L.BoundedFormula α n\n⊢ Eq (FirstOrder.Language.BoundedFormula.castLE h φ) φ","decl":"@[simp]\ntheorem castLE_rfl {n} (h : n ≤ n) (φ : L.BoundedFormula α n) : φ.castLE h = φ := by\n  induction φ with\n  | falsum => rfl\n  | equal => simp [Fin.castLE_of_eq]\n  | rel => simp [Fin.castLE_of_eq]\n  | imp _ _ ih1 ih2 => simp [Fin.castLE_of_eq, ih1, ih2]\n  | all _ ih3 => simp [Fin.castLE_of_eq, ih3]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.castLE_castLE","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nk m n : Nat\nkm : LE.le k m\nmn : LE.le m n\nφ : L.BoundedFormula α k\n⊢ Eq (FirstOrder.Language.BoundedFormula.castLE mn (FirstOrder.Language.BoundedFormula.castLE km φ)) (FirstOrder.Language.BoundedFormula.castLE ⋯ φ)","decl":"@[simp]\ntheorem castLE_castLE {k m n} (km : k ≤ m) (mn : m ≤ n) (φ : L.BoundedFormula α k) :\n    (φ.castLE km).castLE mn = φ.castLE (km.trans mn) := by\n  revert m n\n  induction φ with\n  | falsum => intros; rfl\n  | equal => simp\n  | rel =>\n    intros\n    simp only [castLE, eq_self_iff_true, heq_iff_eq]\n    rw [← Function.comp_assoc, Term.relabel_comp_relabel]\n    simp\n  | imp _ _ ih1 ih2 => simp [ih1, ih2]\n  | all _ ih3 => intros; simp only [castLE, ih3]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.castLE_comp_castLE","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nk m n : Nat\nkm : LE.le k m\nmn : LE.le m n\n⊢ Eq (Function.comp (FirstOrder.Language.BoundedFormula.castLE mn) (FirstOrder.Language.BoundedFormula.castLE km)) (FirstOrder.Language.BoundedFormula.castLE ⋯)","decl":"@[simp]\ntheorem castLE_comp_castLE {k m n} (km : k ≤ m) (mn : m ≤ n) :\n    (BoundedFormula.castLE mn ∘ BoundedFormula.castLE km :\n        L.BoundedFormula α k → L.BoundedFormula α n) =\n      BoundedFormula.castLE (km.trans mn) :=\n  funext (castLE_castLE km mn)\n\n-- Porting note: universes in different order\n"}
{"name":"FirstOrder.Language.BoundedFormula.mapTermRel_mapTermRel","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nα : Type u'\nβ : Type v'\nγ : Type u_1\nL'' : FirstOrder.Language\nft : (n : Nat) → L.Term (Sum α (Fin n)) → L'.Term (Sum β (Fin n))\nfr : (n : Nat) → L.Relations n → L'.Relations n\nft' : (n : Nat) → L'.Term (Sum β (Fin n)) → L''.Term (Sum γ (Fin n))\nfr' : (n : Nat) → L'.Relations n → L''.Relations n\nn : Nat\nφ : L.BoundedFormula α n\n⊢ Eq (FirstOrder.Language.BoundedFormula.mapTermRel ft' fr' (fun x => id) (FirstOrder.Language.BoundedFormula.mapTermRel ft fr (fun x => id) φ)) (FirstOrder.Language.BoundedFormula.mapTermRel (fun x => Function.comp (ft' x) (ft x)) (fun x => Function.comp (fr' x) (fr x)) (fun x => id) φ)","decl":"@[simp]\ntheorem mapTermRel_mapTermRel {L'' : Language}\n    (ft : ∀ n, L.Term (α ⊕ (Fin n)) → L'.Term (β ⊕ (Fin n)))\n    (fr : ∀ n, L.Relations n → L'.Relations n)\n    (ft' : ∀ n, L'.Term (β ⊕ Fin n) → L''.Term (γ ⊕ (Fin n)))\n    (fr' : ∀ n, L'.Relations n → L''.Relations n) {n} (φ : L.BoundedFormula α n) :\n    ((φ.mapTermRel ft fr fun _ => id).mapTermRel ft' fr' fun _ => id) =\n      φ.mapTermRel (fun _ => ft' _ ∘ ft _) (fun _ => fr' _ ∘ fr _) fun _ => id := by\n  induction φ with\n  | falsum => rfl\n  | equal => simp [mapTermRel]\n  | rel => simp [mapTermRel]\n  | imp _ _ ih1 ih2 => simp [mapTermRel, ih1, ih2]\n  | all _ ih3 => simp [mapTermRel, ih3]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.mapTermRel_id_id_id","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\n⊢ Eq (FirstOrder.Language.BoundedFormula.mapTermRel (fun x => id) (fun x => id) (fun x => id) φ) φ","decl":"@[simp]\ntheorem mapTermRel_id_id_id {n} (φ : L.BoundedFormula α n) :\n    (φ.mapTermRel (fun _ => id) (fun _ => id) fun _ => id) = φ := by\n  induction φ with\n  | falsum => rfl\n  | equal => simp [mapTermRel]\n  | rel => simp [mapTermRel]\n  | imp _ _ ih1 ih2 => simp [mapTermRel, ih1, ih2]\n  | all _ ih3 => simp [mapTermRel, ih3]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.mapTermRelEquiv_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nα : Type u'\nβ : Type v'\nft : (n : Nat) → Equiv (L.Term (Sum α (Fin n))) (L'.Term (Sum β (Fin n)))\nfr : (n : Nat) → Equiv (L.Relations n) (L'.Relations n)\nn : Nat\na✝ : L.BoundedFormula α n\n⊢ Eq ((FirstOrder.Language.BoundedFormula.mapTermRelEquiv ft fr) a✝) (FirstOrder.Language.BoundedFormula.mapTermRel (fun n => ⇑(ft n)) (fun n => ⇑(fr n)) (fun x => id) a✝)","decl":"/-- An equivalence of bounded formulas given by an equivalence of terms and an equivalence of\nrelations. -/\n@[simps]\ndef mapTermRelEquiv (ft : ∀ n, L.Term (α ⊕ (Fin n)) ≃ L'.Term (β ⊕ (Fin n)))\n    (fr : ∀ n, L.Relations n ≃ L'.Relations n) {n} : L.BoundedFormula α n ≃ L'.BoundedFormula β n :=\n  ⟨mapTermRel (fun n => ft n) (fun n => fr n) fun _ => id,\n    mapTermRel (fun n => (ft n).symm) (fun n => (fr n).symm) fun _ => id, fun φ => by simp, fun φ =>\n    by simp⟩\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.mapTermRelEquiv_symm_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nα : Type u'\nβ : Type v'\nft : (n : Nat) → Equiv (L.Term (Sum α (Fin n))) (L'.Term (Sum β (Fin n)))\nfr : (n : Nat) → Equiv (L.Relations n) (L'.Relations n)\nn : Nat\na✝ : L'.BoundedFormula β n\n⊢ Eq ((FirstOrder.Language.BoundedFormula.mapTermRelEquiv ft fr).symm a✝) (FirstOrder.Language.BoundedFormula.mapTermRel (fun n => ⇑(ft n).symm) (fun n => ⇑(fr n).symm) (fun x => id) a✝)","decl":"/-- An equivalence of bounded formulas given by an equivalence of terms and an equivalence of\nrelations. -/\n@[simps]\ndef mapTermRelEquiv (ft : ∀ n, L.Term (α ⊕ (Fin n)) ≃ L'.Term (β ⊕ (Fin n)))\n    (fr : ∀ n, L.Relations n ≃ L'.Relations n) {n} : L.BoundedFormula α n ≃ L'.BoundedFormula β n :=\n  ⟨mapTermRel (fun n => ft n) (fun n => fr n) fun _ => id,\n    mapTermRel (fun n => (ft n).symm) (fun n => (fr n).symm) fun _ => id, fun φ => by simp, fun φ =>\n    by simp⟩\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.sum_elim_comp_relabelAux","module":"Mathlib.ModelTheory.Syntax","initialProofState":"M : Type w\nα : Type u'\nβ : Type v'\nn m : Nat\ng : α → Sum β (Fin n)\nv : β → M\nxs : Fin (HAdd.hAdd n m) → M\n⊢ Eq (Function.comp (Sum.elim v xs) (FirstOrder.Language.BoundedFormula.relabelAux g m)) (Sum.elim (Function.comp (Sum.elim v (Function.comp xs (Fin.castAdd m))) g) (Function.comp xs (Fin.natAdd n)))","decl":"@[simp]\ntheorem sum_elim_comp_relabelAux {m : ℕ} {g : α → β ⊕ (Fin n)} {v : β → M}\n    {xs : Fin (n + m) → M} : Sum.elim v xs ∘ relabelAux g m =\n    Sum.elim (Sum.elim v (xs ∘ castAdd m) ∘ g) (xs ∘ natAdd n) := by\n  ext x\n  cases' x with x x\n  · simp only [BoundedFormula.relabelAux, Function.comp_apply, Sum.map_inl, Sum.elim_inl]\n    cases' g x with l r <;> simp\n  · simp [BoundedFormula.relabelAux]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.relabelAux_sum_inl","module":"Mathlib.ModelTheory.Syntax","initialProofState":"α : Type u'\nn k : Nat\n⊢ Eq (FirstOrder.Language.BoundedFormula.relabelAux Sum.inl k) (Sum.map id (Fin.natAdd n))","decl":"@[simp]\ntheorem relabelAux_sum_inl (k : ℕ) :\n    relabelAux (Sum.inl : α → α ⊕ (Fin n)) k = Sum.map id (natAdd n) := by\n  ext x\n  cases x <;> · simp [relabelAux]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.relabel_falsum","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\nn : Nat\ng : α → Sum β (Fin n)\nk : Nat\n⊢ Eq (FirstOrder.Language.BoundedFormula.relabel g FirstOrder.Language.BoundedFormula.falsum) FirstOrder.Language.BoundedFormula.falsum","decl":"@[simp]\ntheorem relabel_falsum (g : α → β ⊕ (Fin n)) {k} :\n    (falsum : L.BoundedFormula α k).relabel g = falsum :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.relabel_bot","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\nn : Nat\ng : α → Sum β (Fin n)\nk : Nat\n⊢ Eq (FirstOrder.Language.BoundedFormula.relabel g Bot.bot) Bot.bot","decl":"@[simp]\ntheorem relabel_bot (g : α → β ⊕ (Fin n)) {k} : (⊥ : L.BoundedFormula α k).relabel g = ⊥ :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.relabel_imp","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\nn : Nat\ng : α → Sum β (Fin n)\nk : Nat\nφ ψ : L.BoundedFormula α k\n⊢ Eq (FirstOrder.Language.BoundedFormula.relabel g (φ.imp ψ)) ((FirstOrder.Language.BoundedFormula.relabel g φ).imp (FirstOrder.Language.BoundedFormula.relabel g ψ))","decl":"@[simp]\ntheorem relabel_imp (g : α → β ⊕ (Fin n)) {k} (φ ψ : L.BoundedFormula α k) :\n    (φ.imp ψ).relabel g = (φ.relabel g).imp (ψ.relabel g) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.relabel_not","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\nn : Nat\ng : α → Sum β (Fin n)\nk : Nat\nφ : L.BoundedFormula α k\n⊢ Eq (FirstOrder.Language.BoundedFormula.relabel g φ.not) (FirstOrder.Language.BoundedFormula.relabel g φ).not","decl":"@[simp]\ntheorem relabel_not (g : α → β ⊕ (Fin n)) {k} (φ : L.BoundedFormula α k) :\n    φ.not.relabel g = (φ.relabel g).not := by simp [BoundedFormula.not]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.relabel_all","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\nn : Nat\ng : α → Sum β (Fin n)\nk : Nat\nφ : L.BoundedFormula α (HAdd.hAdd k 1)\n⊢ Eq (FirstOrder.Language.BoundedFormula.relabel g φ.all) (FirstOrder.Language.BoundedFormula.relabel g φ).all","decl":"@[simp]\ntheorem relabel_all (g : α → β ⊕ (Fin n)) {k} (φ : L.BoundedFormula α (k + 1)) :\n    φ.all.relabel g = (φ.relabel g).all := by\n  rw [relabel, mapTermRel, relabel]\n  simp\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.relabel_ex","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\nn : Nat\ng : α → Sum β (Fin n)\nk : Nat\nφ : L.BoundedFormula α (HAdd.hAdd k 1)\n⊢ Eq (FirstOrder.Language.BoundedFormula.relabel g φ.ex) (FirstOrder.Language.BoundedFormula.relabel g φ).ex","decl":"@[simp]\ntheorem relabel_ex (g : α → β ⊕ (Fin n)) {k} (φ : L.BoundedFormula α (k + 1)) :\n    φ.ex.relabel g = (φ.relabel g).ex := by simp [BoundedFormula.ex]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.relabel_sum_inl","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\n⊢ Eq (FirstOrder.Language.BoundedFormula.relabel Sum.inl φ) (FirstOrder.Language.BoundedFormula.castLE ⋯ φ)","decl":"@[simp]\ntheorem relabel_sum_inl (φ : L.BoundedFormula α n) :\n    (φ.relabel Sum.inl : L.BoundedFormula α (0 + n)) = φ.castLE (ge_of_eq (zero_add n)) := by\n  simp only [relabel, relabelAux_sum_inl]\n  induction φ with\n  | falsum => rfl\n  | equal => simp [Fin.natAdd_zero, castLE_of_eq, mapTermRel]\n  | rel => simp [Fin.natAdd_zero, castLE_of_eq, mapTermRel]; rfl\n  | imp _ _ ih1 ih2 => simp_all [mapTermRel]\n  | all _ ih3 => simp_all [mapTermRel]\n\n"}
{"name":"FirstOrder.Language.LHom.id_onBoundedFormula","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\n⊢ Eq (FirstOrder.Language.LHom.id L).onBoundedFormula id","decl":"@[simp]\ntheorem id_onBoundedFormula :\n    ((LHom.id L).onBoundedFormula : L.BoundedFormula α n → L.BoundedFormula α n) = id := by\n  ext f\n  induction f with\n  | falsum => rfl\n  | equal => rw [onBoundedFormula, LHom.id_onTerm, id, id, id, Term.bdEqual]\n  | rel => rw [onBoundedFormula, LHom.id_onTerm]; rfl\n  | imp _ _ ih1 ih2 => rw [onBoundedFormula, ih1, ih2, id, id, id]\n  | all _ ih3 => rw [onBoundedFormula, ih3, id, id]\n\n"}
{"name":"FirstOrder.Language.LHom.comp_onBoundedFormula","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nα : Type u'\nn : Nat\nL'' : FirstOrder.Language\nφ : L'.LHom L''\nψ : L.LHom L'\n⊢ Eq (φ.comp ψ).onBoundedFormula (Function.comp φ.onBoundedFormula ψ.onBoundedFormula)","decl":"@[simp]\ntheorem comp_onBoundedFormula {L'' : Language} (φ : L' →ᴸ L'') (ψ : L →ᴸ L') :\n    ((φ.comp ψ).onBoundedFormula : L.BoundedFormula α n → L''.BoundedFormula α n) =\n      φ.onBoundedFormula ∘ ψ.onBoundedFormula := by\n  ext f\n  induction f with\n  | falsum => rfl\n  | equal => simp [Term.bdEqual]\n  | rel => simp only [onBoundedFormula, comp_onRelation, comp_onTerm, Function.comp_apply]; rfl\n  | imp _ _ ih1 ih2 =>\n    simp only [onBoundedFormula, Function.comp_apply, ih1, ih2, eq_self_iff_true, and_self_iff]\n  | all _ ih3 => simp only [ih3, onBoundedFormula, Function.comp_apply]\n\n"}
{"name":"FirstOrder.Language.LHom.mem_onTheory","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\ng : L.LHom L'\nT : L.Theory\nφ : L'.Sentence\n⊢ Iff (Membership.mem (g.onTheory T) φ) (Exists fun φ₀ => And (Membership.mem T φ₀) (Eq (g.onSentence φ₀) φ))","decl":"@[simp]\ntheorem mem_onTheory {g : L →ᴸ L'} {T : L.Theory} {φ : L'.Sentence} :\n    φ ∈ g.onTheory T ↔ ∃ φ₀, φ₀ ∈ T ∧ g.onSentence φ₀ = φ :=\n  Set.mem_image _ _ _\n\n"}
{"name":"FirstOrder.Language.LEquiv.onBoundedFormula_symm_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.LEquiv L'\na✝ : L'.BoundedFormula α n\n⊢ Eq (φ.onBoundedFormula.symm a✝) (φ.invLHom.onBoundedFormula a✝)","decl":"/-- Maps a bounded formula's symbols along a language equivalence. -/\n@[simps]\ndef onBoundedFormula (φ : L ≃ᴸ L') : L.BoundedFormula α n ≃ L'.BoundedFormula α n where\n  toFun := φ.toLHom.onBoundedFormula\n  invFun := φ.invLHom.onBoundedFormula\n  left_inv := by\n    rw [Function.leftInverse_iff_comp, ← LHom.comp_onBoundedFormula, φ.left_inv,\n      LHom.id_onBoundedFormula]\n  right_inv := by\n    rw [Function.rightInverse_iff_comp, ← LHom.comp_onBoundedFormula, φ.right_inv,\n      LHom.id_onBoundedFormula]\n\n"}
{"name":"FirstOrder.Language.LEquiv.onBoundedFormula_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.LEquiv L'\na✝ : L.BoundedFormula α n\n⊢ Eq (φ.onBoundedFormula a✝) (φ.toLHom.onBoundedFormula a✝)","decl":"/-- Maps a bounded formula's symbols along a language equivalence. -/\n@[simps]\ndef onBoundedFormula (φ : L ≃ᴸ L') : L.BoundedFormula α n ≃ L'.BoundedFormula α n where\n  toFun := φ.toLHom.onBoundedFormula\n  invFun := φ.invLHom.onBoundedFormula\n  left_inv := by\n    rw [Function.leftInverse_iff_comp, ← LHom.comp_onBoundedFormula, φ.left_inv,\n      LHom.id_onBoundedFormula]\n  right_inv := by\n    rw [Function.rightInverse_iff_comp, ← LHom.comp_onBoundedFormula, φ.right_inv,\n      LHom.id_onBoundedFormula]\n\n"}
{"name":"FirstOrder.Language.LEquiv.onBoundedFormula_symm","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.LEquiv L'\n⊢ Eq φ.onBoundedFormula.symm φ.symm.onBoundedFormula","decl":"theorem onBoundedFormula_symm (φ : L ≃ᴸ L') :\n    (φ.onBoundedFormula.symm : L'.BoundedFormula α n ≃ L.BoundedFormula α n) =\n      φ.symm.onBoundedFormula :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.LEquiv.onFormula_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nα : Type u'\nφ : L.LEquiv L'\n⊢ Eq (⇑φ.onFormula) φ.toLHom.onFormula","decl":"@[simp]\ntheorem onFormula_apply (φ : L ≃ᴸ L') :\n    (φ.onFormula : L.Formula α → L'.Formula α) = φ.toLHom.onFormula :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.LEquiv.onFormula_symm","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nα : Type u'\nφ : L.LEquiv L'\n⊢ Eq φ.onFormula.symm φ.symm.onFormula","decl":"@[simp]\ntheorem onFormula_symm (φ : L ≃ᴸ L') :\n    (φ.onFormula.symm : L'.Formula α ≃ L.Formula α) = φ.symm.onFormula :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.LEquiv.onSentence_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nφ : L.LEquiv L'\na✝ : L.BoundedFormula Empty 0\n⊢ Eq (φ.onSentence a✝) (φ.toLHom.onBoundedFormula a✝)","decl":"/-- Maps a sentence's symbols along a language equivalence. -/\n@[simps!]\ndef onSentence (φ : L ≃ᴸ L') : L.Sentence ≃ L'.Sentence :=\n  φ.onFormula\n\n"}
{"name":"FirstOrder.Language.LEquiv.onSentence_symm_apply","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nL' : FirstOrder.Language\nφ : L.LEquiv L'\na✝ : L'.BoundedFormula Empty 0\n⊢ Eq (φ.onSentence.symm a✝) (φ.invLHom.onBoundedFormula a✝)","decl":"/-- Maps a sentence's symbols along a language equivalence. -/\n@[simps!]\ndef onSentence (φ : L ≃ᴸ L') : L.Sentence ≃ L'.Sentence :=\n  φ.onFormula\n\n"}
{"name":"FirstOrder.Language.Formula.equivSentence_not","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nφ : L.Formula α\n⊢ Eq (FirstOrder.Language.Formula.equivSentence φ.not) (FirstOrder.Language.Formula.not (FirstOrder.Language.Formula.equivSentence φ))","decl":"theorem equivSentence_not (φ : L.Formula α) : equivSentence φ.not = (equivSentence φ).not :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Formula.equivSentence_inf","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\nφ ψ : L.Formula α\n⊢ Eq (FirstOrder.Language.Formula.equivSentence (Min.min φ ψ)) (Min.min (FirstOrder.Language.Formula.equivSentence φ) (FirstOrder.Language.Formula.equivSentence ψ))","decl":"theorem equivSentence_inf (φ ψ : L.Formula α) :\n    equivSentence (φ ⊓ ψ) = equivSentence φ ⊓ equivSentence ψ :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.distinctConstantsTheory_mono","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\ns t : Set α\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (L.distinctConstantsTheory s) (L.distinctConstantsTheory t)","decl":"theorem distinctConstantsTheory_mono {s t : Set α} (h : s ⊆ t) :\n    L.distinctConstantsTheory s ⊆ L.distinctConstantsTheory t := by\n  unfold distinctConstantsTheory; gcongr\n\n"}
{"name":"FirstOrder.Language.monotone_distinctConstantsTheory","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\n⊢ Monotone L.distinctConstantsTheory","decl":"theorem monotone_distinctConstantsTheory :\n    Monotone (L.distinctConstantsTheory : Set α → L[[α]].Theory) := fun _s _t st =>\n  L.distinctConstantsTheory_mono st\n\n"}
{"name":"FirstOrder.Language.directed_distinctConstantsTheory","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\n⊢ Directed (fun x1 x2 => HasSubset.Subset x1 x2) L.distinctConstantsTheory","decl":"theorem directed_distinctConstantsTheory :\n    Directed (· ⊆ ·) (L.distinctConstantsTheory : Set α → L[[α]].Theory) :=\n  Monotone.directed_le monotone_distinctConstantsTheory\n\n"}
{"name":"FirstOrder.Language.distinctConstantsTheory_eq_iUnion","module":"Mathlib.ModelTheory.Syntax","initialProofState":"L : FirstOrder.Language\nα : Type u'\ns : Set α\n⊢ Eq (L.distinctConstantsTheory s) (Set.iUnion fun t => L.distinctConstantsTheory ↑(Finset.map (Function.Embedding.subtype fun x => Membership.mem s x) t))","decl":"theorem distinctConstantsTheory_eq_iUnion (s : Set α) :\n    L.distinctConstantsTheory s =\n      ⋃ t : Finset s,\n        L.distinctConstantsTheory (t.map (Function.Embedding.subtype fun x => x ∈ s)) := by\n  classical\n    simp only [distinctConstantsTheory]\n    rw [← image_iUnion, ← iUnion_inter]\n    refine congr(_ '' ($(?_) ∩ _))\n    ext ⟨i, j⟩\n    simp only [prod_mk_mem_set_prod_eq, Finset.coe_map, Function.Embedding.coe_subtype, mem_iUnion,\n      mem_image, Finset.mem_coe, Subtype.exists, Subtype.coe_mk, exists_and_right, exists_eq_right]\n    refine ⟨fun h => ⟨{⟨i, h.1⟩, ⟨j, h.2⟩}, ⟨h.1, ?_⟩, ⟨h.2, ?_⟩⟩, ?_⟩\n    · simp\n    · simp\n    · rintro ⟨t, ⟨is, _⟩, ⟨js, _⟩⟩\n      exact ⟨is, js⟩\n\n"}
