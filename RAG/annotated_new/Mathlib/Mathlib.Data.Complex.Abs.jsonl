{"name":"Complex.AbsTheory.abs_conj","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ Eq (Complex.normSq ((starRingEnd Complex) z)).sqrt (Complex.normSq z).sqrt","decl":"theorem abs_conj (z : ℂ) : (abs conj z) = abs z := by simp\n\n"}
{"name":"Complex.abs_def","module":"Mathlib.Data.Complex.Abs","initialProofState":"⊢ Eq ⇑Complex.abs fun z => (Complex.normSq z).sqrt","decl":"theorem abs_def : (Complex.abs : ℂ → ℝ) = fun z => (normSq z).sqrt :=\n  rfl\n\n"}
{"name":"Complex.abs_apply","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ Eq (Complex.abs z) (Complex.normSq z).sqrt","decl":"theorem abs_apply {z : ℂ} : Complex.abs z = (normSq z).sqrt :=\n  rfl\n\n"}
{"name":"Complex.abs_ofReal","module":"Mathlib.Data.Complex.Abs","initialProofState":"r : Real\n⊢ Eq (Complex.abs ↑r) (abs r)","decl":"@[simp, norm_cast]\ntheorem abs_ofReal (r : ℝ) : Complex.abs r = |r| := by\n  simp [Complex.abs, normSq_ofReal, Real.sqrt_mul_self_eq_abs]\n\n"}
{"name":"Complex.abs_of_nonneg","module":"Mathlib.Data.Complex.Abs","initialProofState":"r : Real\nh : LE.le 0 r\n⊢ Eq (Complex.abs ↑r) r","decl":"nonrec theorem abs_of_nonneg {r : ℝ} (h : 0 ≤ r) : Complex.abs r = r :=\n  (Complex.abs_ofReal _).trans (abs_of_nonneg h)\n\n-- Porting note: removed `norm_cast` attribute because the RHS can't start with `↑`\n"}
{"name":"Complex.abs_natCast","module":"Mathlib.Data.Complex.Abs","initialProofState":"n : Nat\n⊢ Eq (Complex.abs ↑n) ↑n","decl":"@[simp]\ntheorem abs_natCast (n : ℕ) : Complex.abs n = n := Complex.abs_of_nonneg (Nat.cast_nonneg n)\n\n"}
{"name":"Complex.abs_ofNat","module":"Mathlib.Data.Complex.Abs","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Complex.abs (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem abs_ofNat (n : ℕ) [n.AtLeastTwo] :\n    Complex.abs ofNat(n) = ofNat(n) :=\n  abs_natCast n\n\n"}
{"name":"Complex.mul_self_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ Eq (HMul.hMul (Complex.abs z) (Complex.abs z)) (Complex.normSq z)","decl":"theorem mul_self_abs (z : ℂ) : Complex.abs z * Complex.abs z = normSq z :=\n  Real.mul_self_sqrt (normSq_nonneg _)\n\n"}
{"name":"Complex.sq_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ Eq (HPow.hPow (Complex.abs z) 2) (Complex.normSq z)","decl":"theorem sq_abs (z : ℂ) : Complex.abs z ^ 2 = normSq z :=\n  Real.sq_sqrt (normSq_nonneg _)\n\n"}
{"name":"Complex.sq_abs_sub_sq_re","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ Eq (HSub.hSub (HPow.hPow (Complex.abs z) 2) (HPow.hPow z.re 2)) (HPow.hPow z.im 2)","decl":"@[simp]\ntheorem sq_abs_sub_sq_re (z : ℂ) : Complex.abs z ^ 2 - z.re ^ 2 = z.im ^ 2 := by\n  rw [sq_abs, normSq_apply, ← sq, ← sq, add_sub_cancel_left]\n\n"}
{"name":"Complex.sq_abs_sub_sq_im","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ Eq (HSub.hSub (HPow.hPow (Complex.abs z) 2) (HPow.hPow z.im 2)) (HPow.hPow z.re 2)","decl":"@[simp]\ntheorem sq_abs_sub_sq_im (z : ℂ) : Complex.abs z ^ 2 - z.im ^ 2 = z.re ^ 2 := by\n  rw [← sq_abs_sub_sq_re, sub_sub_cancel]\n\n"}
{"name":"Complex.abs_add_mul_I","module":"Mathlib.Data.Complex.Abs","initialProofState":"x y : Real\n⊢ Eq (Complex.abs (HAdd.hAdd (↑x) (HMul.hMul (↑y) Complex.I))) (HAdd.hAdd (HPow.hPow x 2) (HPow.hPow y 2)).sqrt","decl":"lemma abs_add_mul_I (x y : ℝ) : abs (x + y * I) = (x ^ 2 + y ^ 2).sqrt := by\n  rw [← normSq_add_mul_I]; rfl\n\n"}
{"name":"Complex.abs_eq_sqrt_sq_add_sq","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ Eq (Complex.abs z) (HAdd.hAdd (HPow.hPow z.re 2) (HPow.hPow z.im 2)).sqrt","decl":"lemma abs_eq_sqrt_sq_add_sq (z : ℂ) : abs z = (z.re ^ 2 + z.im ^ 2).sqrt := by\n  rw [abs_apply, normSq_apply, sq, sq]\n\n"}
{"name":"Complex.abs_I","module":"Mathlib.Data.Complex.Abs","initialProofState":"⊢ Eq (Complex.abs Complex.I) 1","decl":"@[simp]\ntheorem abs_I : Complex.abs I = 1 := by simp [Complex.abs]\n\n"}
{"name":"Complex.abs_two","module":"Mathlib.Data.Complex.Abs","initialProofState":"⊢ Eq (Complex.abs 2) 2","decl":"theorem abs_two : Complex.abs 2 = 2 := abs_ofNat 2\n\n"}
{"name":"Complex.range_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"⊢ Eq (Set.range ⇑Complex.abs) (Set.Ici 0)","decl":"@[simp]\ntheorem range_abs : range Complex.abs = Ici 0 :=\n  Subset.antisymm\n    (by simp only [range_subset_iff, Ici, mem_setOf_eq, apply_nonneg, forall_const])\n    (fun x hx => ⟨x, Complex.abs_of_nonneg hx⟩)\n\n"}
{"name":"Complex.abs_conj","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ Eq (Complex.abs ((starRingEnd Complex) z)) (Complex.abs z)","decl":"@[simp]\ntheorem abs_conj (z : ℂ) : Complex.abs (conj z) = Complex.abs z :=\n  AbsTheory.abs_conj z\n\n"}
{"name":"Complex.abs_prod","module":"Mathlib.Data.Complex.Abs","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → Complex\n⊢ Eq (Complex.abs (s.prod f)) (s.prod fun I => Complex.abs (f I))","decl":"theorem abs_prod {ι : Type*} (s : Finset ι) (f : ι → ℂ) :\n    Complex.abs (s.prod f) = s.prod fun I => Complex.abs (f I) :=\n  map_prod Complex.abs _ _\n\n"}
{"name":"Complex.abs_pow","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\nn : Nat\n⊢ Eq (Complex.abs (HPow.hPow z n)) (HPow.hPow (Complex.abs z) n)","decl":"theorem abs_pow (z : ℂ) (n : ℕ) : Complex.abs (z ^ n) = Complex.abs z ^ n :=\n  map_pow Complex.abs z n\n\n"}
{"name":"Complex.abs_zpow","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\nn : Int\n⊢ Eq (Complex.abs (HPow.hPow z n)) (HPow.hPow (Complex.abs z) n)","decl":"theorem abs_zpow (z : ℂ) (n : ℤ) : Complex.abs (z ^ n) = Complex.abs z ^ n :=\n  map_zpow₀ Complex.abs z n\n\n"}
{"name":"Complex.abs_re_le_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ LE.le (abs z.re) (Complex.abs z)","decl":"@[bound]\ntheorem abs_re_le_abs (z : ℂ) : |z.re| ≤ Complex.abs z :=\n  Real.abs_le_sqrt <| by\n    rw [normSq_apply, ← sq]\n    exact le_add_of_nonneg_right (mul_self_nonneg _)\n\n"}
{"name":"Complex.abs_im_le_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ LE.le (abs z.im) (Complex.abs z)","decl":"@[bound]\ntheorem abs_im_le_abs (z : ℂ) : |z.im| ≤ Complex.abs z :=\n  Real.abs_le_sqrt <| by\n    rw [normSq_apply, ← sq, ← sq]\n    exact le_add_of_nonneg_left (sq_nonneg _)\n\n"}
{"name":"Complex.re_le_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ LE.le z.re (Complex.abs z)","decl":"theorem re_le_abs (z : ℂ) : z.re ≤ Complex.abs z :=\n  (abs_le.1 (abs_re_le_abs _)).2\n\n"}
{"name":"Complex.im_le_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ LE.le z.im (Complex.abs z)","decl":"theorem im_le_abs (z : ℂ) : z.im ≤ Complex.abs z :=\n  (abs_le.1 (abs_im_le_abs _)).2\n\n"}
{"name":"Complex.abs_re_lt_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ Iff (LT.lt (abs z.re) (Complex.abs z)) (Ne z.im 0)","decl":"@[simp]\ntheorem abs_re_lt_abs {z : ℂ} : |z.re| < Complex.abs z ↔ z.im ≠ 0 := by\n  rw [Complex.abs, AbsoluteValue.coe_mk, MulHom.coe_mk, Real.lt_sqrt (abs_nonneg _), normSq_apply,\n    _root_.sq_abs, ← sq, lt_add_iff_pos_right, mul_self_pos]\n\n"}
{"name":"Complex.abs_im_lt_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ Iff (LT.lt (abs z.im) (Complex.abs z)) (Ne z.re 0)","decl":"@[simp]\ntheorem abs_im_lt_abs {z : ℂ} : |z.im| < Complex.abs z ↔ z.re ≠ 0 := by\n  simpa using @abs_re_lt_abs (z * I)\n\n"}
{"name":"Complex.abs_re_eq_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ Iff (Eq (abs z.re) (Complex.abs z)) (Eq z.im 0)","decl":"@[simp]\nlemma abs_re_eq_abs {z : ℂ} : |z.re| = abs z ↔ z.im = 0 :=\n  not_iff_not.1 <| (abs_re_le_abs z).lt_iff_ne.symm.trans abs_re_lt_abs\n\n"}
{"name":"Complex.abs_im_eq_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ Iff (Eq (abs z.im) (Complex.abs z)) (Eq z.re 0)","decl":"@[simp]\nlemma abs_im_eq_abs {z : ℂ} : |z.im| = abs z ↔ z.re = 0 :=\n  not_iff_not.1 <| (abs_im_le_abs z).lt_iff_ne.symm.trans abs_im_lt_abs\n\n"}
{"name":"Complex.abs_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ Eq (abs (Complex.abs z)) (Complex.abs z)","decl":"@[simp]\ntheorem abs_abs (z : ℂ) : |Complex.abs z| = Complex.abs z :=\n  _root_.abs_of_nonneg (AbsoluteValue.nonneg _ z)\n\n-- Porting note: probably should be golfed\n"}
{"name":"Complex.abs_le_abs_re_add_abs_im","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ LE.le (Complex.abs z) (HAdd.hAdd (abs z.re) (abs z.im))","decl":"theorem abs_le_abs_re_add_abs_im (z : ℂ) : Complex.abs z ≤ |z.re| + |z.im| := by\n  simpa [re_add_im] using Complex.abs.add_le z.re (z.im * I)\n\n"}
{"name":"Complex.abs_le_sqrt_two_mul_max","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ LE.le (Complex.abs z) (HMul.hMul (Real.sqrt 2) (Max.max (abs z.re) (abs z.im)))","decl":"theorem abs_le_sqrt_two_mul_max (z : ℂ) : Complex.abs z ≤ Real.sqrt 2 * max |z.re| |z.im| := by\n  cases' z with x y\n  simp only [abs_apply, normSq_mk, ← sq]\n  by_cases hle : |x| ≤ |y|\n  · calc\n      Real.sqrt (x ^ 2 + y ^ 2) ≤ Real.sqrt (y ^ 2 + y ^ 2) :=\n        Real.sqrt_le_sqrt (add_le_add_right (sq_le_sq.2 hle) _)\n      _ = Real.sqrt 2 * max |x| |y| := by\n        rw [max_eq_right hle, ← two_mul, Real.sqrt_mul two_pos.le, Real.sqrt_sq_eq_abs]\n  · have hle' := le_of_not_le hle\n    rw [add_comm]\n    calc\n      Real.sqrt (y ^ 2 + x ^ 2) ≤ Real.sqrt (x ^ 2 + x ^ 2) :=\n        Real.sqrt_le_sqrt (add_le_add_right (sq_le_sq.2 hle') _)\n      _ = Real.sqrt 2 * max |x| |y| := by\n        rw [max_eq_left hle', ← two_mul, Real.sqrt_mul two_pos.le, Real.sqrt_sq_eq_abs]\n\n"}
{"name":"Complex.abs_re_div_abs_le_one","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ LE.le (abs (HDiv.hDiv z.re (Complex.abs z))) 1","decl":"theorem abs_re_div_abs_le_one (z : ℂ) : |z.re / Complex.abs z| ≤ 1 :=\n  if hz : z = 0 then by simp [hz, zero_le_one]\n  else by simp_rw [_root_.abs_div, abs_abs,\n    div_le_iff₀ (AbsoluteValue.pos Complex.abs hz), one_mul, abs_re_le_abs]\n\n"}
{"name":"Complex.abs_im_div_abs_le_one","module":"Mathlib.Data.Complex.Abs","initialProofState":"z : Complex\n⊢ LE.le (abs (HDiv.hDiv z.im (Complex.abs z))) 1","decl":"theorem abs_im_div_abs_le_one (z : ℂ) : |z.im / Complex.abs z| ≤ 1 :=\n  if hz : z = 0 then by simp [hz, zero_le_one]\n  else by simp_rw [_root_.abs_div, abs_abs,\n    div_le_iff₀ (AbsoluteValue.pos Complex.abs hz), one_mul, abs_im_le_abs]\n\n"}
{"name":"Complex.abs_intCast","module":"Mathlib.Data.Complex.Abs","initialProofState":"n : Int\n⊢ Eq (Complex.abs ↑n) (abs ↑n)","decl":"@[simp, norm_cast] lemma abs_intCast (n : ℤ) : abs n = |↑n| := by rw [← ofReal_intCast, abs_ofReal]\n\n"}
{"name":"Complex.normSq_eq_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"x : Complex\n⊢ Eq (Complex.normSq x) (HPow.hPow (Complex.abs x) 2)","decl":"theorem normSq_eq_abs (x : ℂ) : normSq x = (Complex.abs x) ^ 2 := by\n  simp [abs, sq, abs_def, Real.mul_self_sqrt (normSq_nonneg _)]\n\n"}
{"name":"Complex.range_normSq","module":"Mathlib.Data.Complex.Abs","initialProofState":"⊢ Eq (Set.range ⇑Complex.normSq) (Set.Ici 0)","decl":"@[simp]\ntheorem range_normSq : range normSq = Ici 0 :=\n  Subset.antisymm (range_subset_iff.2 normSq_nonneg) fun x hx =>\n    ⟨Real.sqrt x, by rw [normSq_ofReal, Real.mul_self_sqrt hx]⟩\n\n"}
{"name":"Complex.isCauSeq_re","module":"Mathlib.Data.Complex.Abs","initialProofState":"f : CauSeq Complex ⇑Complex.abs\n⊢ IsCauSeq abs fun n => (↑f n).re","decl":"theorem isCauSeq_re (f : CauSeq ℂ Complex.abs) : IsCauSeq abs' fun n => (f n).re := fun _ ε0 =>\n  (f.cauchy ε0).imp fun i H j ij =>\n    lt_of_le_of_lt (by simpa using abs_re_le_abs (f j - f i)) (H _ ij)\n\n"}
{"name":"Complex.isCauSeq_im","module":"Mathlib.Data.Complex.Abs","initialProofState":"f : CauSeq Complex ⇑Complex.abs\n⊢ IsCauSeq abs fun n => (↑f n).im","decl":"theorem isCauSeq_im (f : CauSeq ℂ Complex.abs) : IsCauSeq abs' fun n => (f n).im := fun ε ε0 =>\n  (f.cauchy ε0).imp fun i H j ij ↦ by\n    simpa only [← ofReal_sub, abs_ofReal, sub_re] using (abs_im_le_abs _).trans_lt <| H _ ij\n\n"}
{"name":"Complex.isCauSeq_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"f : Nat → Complex\nhf : IsCauSeq (⇑Complex.abs) f\n⊢ IsCauSeq abs (Function.comp (⇑Complex.abs) f)","decl":"theorem isCauSeq_abs {f : ℕ → ℂ} (hf : IsCauSeq Complex.abs f) :\n    IsCauSeq abs' (Complex.abs ∘ f) := fun ε ε0 =>\n  let ⟨i, hi⟩ := hf ε ε0\n  ⟨i, fun j hj => lt_of_le_of_lt\n    (Complex.abs.abs_abv_sub_le_abv_sub _ _) (hi j hj)⟩\n\n"}
{"name":"Complex.equiv_limAux","module":"Mathlib.Data.Complex.Abs","initialProofState":"f : CauSeq Complex ⇑Complex.abs\n⊢ HasEquiv.Equiv f (CauSeq.const (⇑Complex.abs) (Complex.limAux f))","decl":"theorem equiv_limAux (f : CauSeq ℂ Complex.abs) :\n    f ≈ CauSeq.const Complex.abs (limAux f) := fun ε ε0 =>\n  (exists_forall_ge_and\n  (CauSeq.equiv_lim ⟨_, isCauSeq_re f⟩ _ (half_pos ε0))\n        (CauSeq.equiv_lim ⟨_, isCauSeq_im f⟩ _ (half_pos ε0))).imp\n    fun _ H j ij => by\n    cases' H _ ij with H₁ H₂\n    apply lt_of_le_of_lt (abs_le_abs_re_add_abs_im _)\n    dsimp [limAux] at *\n    have := add_lt_add H₁ H₂\n    rwa [add_halves] at this\n\n"}
{"name":"Complex.instIsComplete","module":"Mathlib.Data.Complex.Abs","initialProofState":"⊢ CauSeq.IsComplete Complex ⇑Complex.abs","decl":"instance instIsComplete : CauSeq.IsComplete ℂ Complex.abs :=\n  ⟨fun f => ⟨limAux f, equiv_limAux f⟩⟩\n\n"}
{"name":"Complex.lim_eq_lim_im_add_lim_re","module":"Mathlib.Data.Complex.Abs","initialProofState":"f : CauSeq Complex ⇑Complex.abs\n⊢ Eq f.lim (HAdd.hAdd (↑(Complex.cauSeqRe f).lim) (HMul.hMul (↑(Complex.cauSeqIm f).lim) Complex.I))","decl":"theorem lim_eq_lim_im_add_lim_re (f : CauSeq ℂ Complex.abs) :\n    lim f = ↑(lim (cauSeqRe f)) + ↑(lim (cauSeqIm f)) * I :=\n  lim_eq_of_equiv_const <|\n    calc\n      f ≈ _ := equiv_limAux f\n      _ = CauSeq.const Complex.abs (↑(lim (cauSeqRe f)) + ↑(lim (cauSeqIm f)) * I) :=\n        CauSeq.ext fun _ =>\n          Complex.ext (by simp [limAux, cauSeqRe, ofReal]) (by simp [limAux, cauSeqIm, ofReal])\n\n"}
{"name":"Complex.lim_re","module":"Mathlib.Data.Complex.Abs","initialProofState":"f : CauSeq Complex ⇑Complex.abs\n⊢ Eq (Complex.cauSeqRe f).lim f.lim.re","decl":"theorem lim_re (f : CauSeq ℂ Complex.abs) : lim (cauSeqRe f) = (lim f).re := by\n  rw [lim_eq_lim_im_add_lim_re]; simp [ofReal]\n\n"}
{"name":"Complex.lim_im","module":"Mathlib.Data.Complex.Abs","initialProofState":"f : CauSeq Complex ⇑Complex.abs\n⊢ Eq (Complex.cauSeqIm f).lim f.lim.im","decl":"theorem lim_im (f : CauSeq ℂ Complex.abs) : lim (cauSeqIm f) = (lim f).im := by\n  rw [lim_eq_lim_im_add_lim_re]; simp [ofReal]\n\n"}
{"name":"Complex.isCauSeq_conj","module":"Mathlib.Data.Complex.Abs","initialProofState":"f : CauSeq Complex ⇑Complex.abs\n⊢ IsCauSeq ⇑Complex.abs fun n => (starRingEnd Complex) (↑f n)","decl":"theorem isCauSeq_conj (f : CauSeq ℂ Complex.abs) :\n    IsCauSeq Complex.abs fun n => conj (f n) := fun ε ε0 =>\n  let ⟨i, hi⟩ := f.2 ε ε0\n  ⟨i, fun j hj => by\n    rw [← RingHom.map_sub, abs_conj]; exact hi j hj⟩\n\n"}
{"name":"Complex.lim_conj","module":"Mathlib.Data.Complex.Abs","initialProofState":"f : CauSeq Complex ⇑Complex.abs\n⊢ Eq (Complex.cauSeqConj f).lim ((starRingEnd Complex) f.lim)","decl":"theorem lim_conj (f : CauSeq ℂ Complex.abs) : lim (cauSeqConj f) = conj (lim f) :=\n  Complex.ext (by simp [cauSeqConj, (lim_re _).symm, cauSeqRe])\n    (by simp [cauSeqConj, (lim_im _).symm, cauSeqIm, (lim_neg _).symm]; rfl)\n\n"}
{"name":"Complex.lim_abs","module":"Mathlib.Data.Complex.Abs","initialProofState":"f : CauSeq Complex ⇑Complex.abs\n⊢ Eq (Complex.cauSeqAbs f).lim (Complex.abs f.lim)","decl":"theorem lim_abs (f : CauSeq ℂ Complex.abs) : lim (cauSeqAbs f) = Complex.abs (lim f) :=\n  lim_eq_of_equiv_const fun ε ε0 =>\n    let ⟨i, hi⟩ := equiv_lim f ε ε0\n    ⟨i, fun j hj => lt_of_le_of_lt (Complex.abs.abs_abv_sub_le_abv_sub _ _) (hi j hj)⟩\n\n"}
{"name":"Complex.ne_zero_of_re_pos","module":"Mathlib.Data.Complex.Abs","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\n⊢ Ne s 0","decl":"lemma ne_zero_of_re_pos {s : ℂ} (hs : 0 < s.re) : s ≠ 0 :=\n  fun h ↦ (zero_re ▸ h ▸ hs).false\n\n"}
{"name":"Complex.ne_zero_of_one_lt_re","module":"Mathlib.Data.Complex.Abs","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Ne s 0","decl":"lemma ne_zero_of_one_lt_re {s : ℂ} (hs : 1 < s.re) : s ≠ 0 :=\n  ne_zero_of_re_pos <| zero_lt_one.trans hs\n\n"}
{"name":"Complex.re_neg_ne_zero_of_re_pos","module":"Mathlib.Data.Complex.Abs","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\n⊢ Ne (Neg.neg s).re 0","decl":"lemma re_neg_ne_zero_of_re_pos {s : ℂ} (hs : 0 < s.re) : (-s).re ≠ 0 :=\n  ne_iff_lt_or_gt.mpr <| Or.inl <| neg_re s ▸ (neg_lt_zero.mpr hs)\n\n"}
{"name":"Complex.re_neg_ne_zero_of_one_lt_re","module":"Mathlib.Data.Complex.Abs","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Ne (Neg.neg s).re 0","decl":"lemma re_neg_ne_zero_of_one_lt_re {s : ℂ} (hs : 1 < s.re) : (-s).re ≠ 0 :=\n  re_neg_ne_zero_of_re_pos <| zero_lt_one.trans hs\n\n"}
