{"name":"CategoryTheory.Functor.final_of_isFiltered_structuredArrow","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : ∀ (d : D), CategoryTheory.IsFiltered (CategoryTheory.StructuredArrow d F)\n⊢ F.Final","decl":"/-- If `StructuredArrow d F` is filtered for any `d : D`, then `F : C ⥤ D` is final. This is\n    simply because filtered categories are connected. More profoundly, the converse is also true if\n    `C` is filtered, see `final_iff_isFiltered_structuredArrow`. -/\ntheorem Functor.final_of_isFiltered_structuredArrow [∀ d, IsFiltered (StructuredArrow d F)] :\n    Final F where\n  out _ := IsFiltered.isConnected _\n\n"}
{"name":"CategoryTheory.Functor.initial_of_isCofiltered_costructuredArrow","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : ∀ (d : D), CategoryTheory.IsCofiltered (CategoryTheory.CostructuredArrow F d)\n⊢ F.Initial","decl":"/-- If `CostructuredArrow F d` is filtered for any `d : D`, then `F : C ⥤ D` is initial. This is\n    simply because cofiltered categories are connectged. More profoundly, the converse is also true\n    if `C` is cofiltered, see `initial_iff_isCofiltered_costructuredArrow`. -/\ntheorem Functor.initial_of_isCofiltered_costructuredArrow\n    [∀ d, IsCofiltered (CostructuredArrow F d)] : Initial F where\n  out _ := IsCofiltered.isConnected _\n\n"}
{"name":"CategoryTheory.isFiltered_structuredArrow_of_isFiltered_of_exists","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nh₁ : ∀ (d : D), Exists fun c => Nonempty (Quiver.Hom d (F.obj c))\nh₂ : ∀ {d : D} {c : C} (s s' : Quiver.Hom d (F.obj c)), Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp s (F.map t)) (CategoryTheory.CategoryStruct.comp s' (F.map t))\nd : D\n⊢ CategoryTheory.IsFiltered (CategoryTheory.StructuredArrow d F)","decl":"theorem isFiltered_structuredArrow_of_isFiltered_of_exists [IsFilteredOrEmpty C]\n    (h₁ : ∀ d, ∃ c, Nonempty (d ⟶ F.obj c)) (h₂ : ∀ {d : D} {c : C} (s s' : d ⟶ F.obj c),\n      ∃ (c' : C) (t : c ⟶ c'), s ≫ F.map t = s' ≫ F.map t) (d : D) :\n    IsFiltered (StructuredArrow d F) := by\n  have : Nonempty (StructuredArrow d F) := by\n    obtain ⟨c, ⟨f⟩⟩ := h₁ d\n    exact ⟨.mk f⟩\n  suffices IsFilteredOrEmpty (StructuredArrow d F) from IsFiltered.mk\n  refine ⟨fun f g => ?_, fun f g η μ => ?_⟩\n  · obtain ⟨c, ⟨t, ht⟩⟩ := h₂ (f.hom ≫ F.map (IsFiltered.leftToMax f.right g.right))\n        (g.hom ≫ F.map (IsFiltered.rightToMax f.right g.right))\n    refine ⟨.mk (f.hom ≫ F.map (IsFiltered.leftToMax f.right g.right ≫ t)), ?_, ?_, trivial⟩\n    · exact StructuredArrow.homMk (IsFiltered.leftToMax _ _ ≫ t) rfl\n    · exact StructuredArrow.homMk (IsFiltered.rightToMax _ _ ≫ t) (by simpa using ht.symm)\n  · refine ⟨.mk (f.hom ≫ F.map (η.right ≫ IsFiltered.coeqHom η.right μ.right)),\n      StructuredArrow.homMk (IsFiltered.coeqHom η.right μ.right) (by simp), ?_⟩\n    simpa using IsFiltered.coeq_condition _ _\n\n"}
{"name":"CategoryTheory.isCofiltered_costructuredArrow_of_isCofiltered_of_exists","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\nh₁ : ∀ (d : D), Exists fun c => Nonempty (Quiver.Hom (F.obj c) d)\nh₂ : ∀ {d : D} {c : C} (s s' : Quiver.Hom (F.obj c) d), Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp (F.map t) s) (CategoryTheory.CategoryStruct.comp (F.map t) s')\nd : D\n⊢ CategoryTheory.IsCofiltered (CategoryTheory.CostructuredArrow F d)","decl":"theorem isCofiltered_costructuredArrow_of_isCofiltered_of_exists [IsCofilteredOrEmpty C]\n    (h₁ : ∀ d, ∃ c, Nonempty (F.obj c ⟶ d)) (h₂ : ∀ {d : D} {c : C} (s s' : F.obj c ⟶ d),\n      ∃ (c' : C) (t : c' ⟶ c), F.map t ≫ s = F.map t ≫ s') (d : D) :\n    IsCofiltered (CostructuredArrow F d) := by\n  suffices IsFiltered (CostructuredArrow F d)ᵒᵖ from isCofiltered_of_isFiltered_op _\n  suffices IsFiltered (StructuredArrow (op d) F.op) from\n    IsFiltered.of_equivalence (costructuredArrowOpEquivalence _ _).symm\n  apply isFiltered_structuredArrow_of_isFiltered_of_exists\n  · intro d\n    obtain ⟨c, ⟨t⟩⟩ := h₁ d.unop\n    exact ⟨op c, ⟨Quiver.Hom.op t⟩⟩\n  · intro d c s s'\n    obtain ⟨c', t, ht⟩ := h₂ s.unop s'.unop\n    exact ⟨op c', Quiver.Hom.op t, Quiver.Hom.unop_inj ht⟩\n\n"}
{"name":"CategoryTheory.Functor.final_of_exists_of_isFiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nh₁ : ∀ (d : D), Exists fun c => Nonempty (Quiver.Hom d (F.obj c))\nh₂ : ∀ {d : D} {c : C} (s s' : Quiver.Hom d (F.obj c)), Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp s (F.map t)) (CategoryTheory.CategoryStruct.comp s' (F.map t))\n⊢ F.Final","decl":"/-- If `C` is filtered, then we can give an explicit condition for a functor `F : C ⥤ D` to\n    be final. The converse is also true, see `final_iff_of_isFiltered`. -/\ntheorem Functor.final_of_exists_of_isFiltered [IsFilteredOrEmpty C]\n    (h₁ : ∀ d, ∃ c, Nonempty (d ⟶ F.obj c)) (h₂ : ∀ {d : D} {c : C} (s s' : d ⟶ F.obj c),\n      ∃ (c' : C) (t : c ⟶ c'), s ≫ F.map t = s' ≫ F.map t) : Functor.Final F := by\n  suffices ∀ d, IsFiltered (StructuredArrow d F) from final_of_isFiltered_structuredArrow F\n  exact isFiltered_structuredArrow_of_isFiltered_of_exists F h₁ h₂\n\n"}
{"name":"CategoryTheory.Functor.final_const_of_isTerminal","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.IsFiltered C\nX : D\nhX : CategoryTheory.Limits.IsTerminal X\n⊢ ((CategoryTheory.Functor.const C).obj X).Final","decl":"/-- The inclusion of a terminal object is final. -/\ntheorem Functor.final_const_of_isTerminal [IsFiltered C] {X : D} (hX : IsTerminal X) :\n    ((Functor.const C).obj X).Final :=\n  Functor.final_of_exists_of_isFiltered _ (fun _ => ⟨IsFiltered.nonempty.some, ⟨hX.from _⟩⟩)\n    (fun {_ c} _ _ => ⟨c, 𝟙 _, hX.hom_ext _ _⟩)\n\n"}
{"name":"CategoryTheory.Functor.final_const_terminal","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.IsFiltered C\ninst✝ : CategoryTheory.Limits.HasTerminal D\n⊢ ((CategoryTheory.Functor.const C).obj (CategoryTheory.Limits.terminal D)).Final","decl":"/-- The inclusion of the terminal object is final. -/\ntheorem Functor.final_const_terminal [IsFiltered C] [HasTerminal D] :\n    ((Functor.const C).obj (⊤_ D)).Final :=\n  Functor.final_const_of_isTerminal terminalIsTerminal\n\n"}
{"name":"CategoryTheory.Functor.initial_of_exists_of_isCofiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\nh₁ : ∀ (d : D), Exists fun c => Nonempty (Quiver.Hom (F.obj c) d)\nh₂ : ∀ {d : D} {c : C} (s s' : Quiver.Hom (F.obj c) d), Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp (F.map t) s) (CategoryTheory.CategoryStruct.comp (F.map t) s')\n⊢ F.Initial","decl":"/-- If `C` is cofiltered, then we can give an explicit condition for a functor `F : C ⥤ D` to\n    be final. The converse is also true, see `initial_iff_of_isCofiltered`. -/\ntheorem Functor.initial_of_exists_of_isCofiltered [IsCofilteredOrEmpty C]\n    (h₁ : ∀ d, ∃ c, Nonempty (F.obj c ⟶ d)) (h₂ : ∀ {d : D} {c : C} (s s' : F.obj c ⟶ d),\n      ∃ (c' : C) (t : c' ⟶ c), F.map t ≫ s = F.map t ≫ s') : Functor.Initial F := by\n  suffices ∀ d, IsCofiltered (CostructuredArrow F d) from\n    initial_of_isCofiltered_costructuredArrow F\n  exact isCofiltered_costructuredArrow_of_isCofiltered_of_exists F h₁ h₂\n\n"}
{"name":"CategoryTheory.Functor.initial_const_of_isInitial","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.IsCofiltered C\nX : D\nhX : CategoryTheory.Limits.IsInitial X\n⊢ ((CategoryTheory.Functor.const C).obj X).Initial","decl":"/-- The inclusion of an initial object is initial. -/\ntheorem Functor.initial_const_of_isInitial [IsCofiltered C] {X : D} (hX : IsInitial X) :\n    ((Functor.const C).obj X).Initial :=\n  Functor.initial_of_exists_of_isCofiltered _ (fun _ => ⟨IsCofiltered.nonempty.some, ⟨hX.to _⟩⟩)\n    (fun {_ c} _ _ => ⟨c, 𝟙 _, hX.hom_ext _ _⟩)\n\n"}
{"name":"CategoryTheory.Functor.initial_const_initial","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.IsCofiltered C\ninst✝ : CategoryTheory.Limits.HasInitial D\n⊢ ((CategoryTheory.Functor.const C).obj (CategoryTheory.Limits.initial D)).Initial","decl":"/-- The inclusion of the initial object is initial. -/\ntheorem Functor.initial_const_initial [IsCofiltered C] [HasInitial D] :\n    ((Functor.const C).obj (⊥_ D)).Initial :=\n  Functor.initial_const_of_isInitial initialIsInitial\n\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.IsFilteredOrEmpty D\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nh : ∀ (d : D), Exists fun c => Nonempty (Quiver.Hom d (F.obj c))\n⊢ CategoryTheory.IsFilteredOrEmpty C","decl":"/-- In this situation, `F` is also final, see\n    `Functor.final_of_exists_of_isFiltered_of_fullyFaithful`. -/\ntheorem IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful [IsFilteredOrEmpty D] [F.Full]\n    [F.Faithful] (h : ∀ d, ∃ c, Nonempty (d ⟶ F.obj c)) : IsFilteredOrEmpty C where\n  cocone_objs c c' := by\n    obtain ⟨c₀, ⟨f⟩⟩ := h (IsFiltered.max (F.obj c) (F.obj c'))\n    exact ⟨c₀, F.preimage (IsFiltered.leftToMax _ _ ≫ f),\n      F.preimage (IsFiltered.rightToMax _ _ ≫ f), trivial⟩\n  cocone_maps {c c'} f g := by\n    obtain ⟨c₀, ⟨f₀⟩⟩ := h (IsFiltered.coeq (F.map f) (F.map g))\n    refine ⟨_, F.preimage (IsFiltered.coeqHom (F.map f) (F.map g) ≫ f₀), F.map_injective ?_⟩\n    simp [reassoc_of% (IsFiltered.coeq_condition (F.map f) (F.map g))]\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.of_exists_of_isCofiltered_of_fullyFaithful","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.IsCofilteredOrEmpty D\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nh : ∀ (d : D), Exists fun c => Nonempty (Quiver.Hom (F.obj c) d)\n⊢ CategoryTheory.IsCofilteredOrEmpty C","decl":"/-- In this situation, `F` is also initial, see\n    `Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful`. -/\ntheorem IsCofilteredOrEmpty.of_exists_of_isCofiltered_of_fullyFaithful [IsCofilteredOrEmpty D]\n    [F.Full] [F.Faithful] (h : ∀ d, ∃ c, Nonempty (F.obj c ⟶ d)) : IsCofilteredOrEmpty C := by\n  suffices IsFilteredOrEmpty Cᵒᵖ from isCofilteredOrEmpty_of_isFilteredOrEmpty_op _\n  refine IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful F.op (fun d => ?_)\n  obtain ⟨c, ⟨f⟩⟩ := h d.unop\n  exact ⟨op c, ⟨f.op⟩⟩\n\n"}
{"name":"CategoryTheory.IsFiltered.of_exists_of_isFiltered_of_fullyFaithful","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.IsFiltered D\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nh : ∀ (d : D), Exists fun c => Nonempty (Quiver.Hom d (F.obj c))\n⊢ CategoryTheory.IsFiltered C","decl":"/-- In this situation, `F` is also final, see\n    `Functor.final_of_exists_of_isFiltered_of_fullyFaithful`. -/\ntheorem IsFiltered.of_exists_of_isFiltered_of_fullyFaithful [IsFiltered D] [F.Full] [F.Faithful]\n    (h : ∀ d, ∃ c, Nonempty (d ⟶ F.obj c)) : IsFiltered C :=\n  { IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful F h with\n    nonempty := by\n      have : Nonempty D := IsFiltered.nonempty\n      obtain ⟨c, -⟩ := h (Classical.arbitrary D)\n      exact ⟨c⟩ }\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_exists_of_isCofiltered_of_fullyFaithful","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.IsCofiltered D\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nh : ∀ (d : D), Exists fun c => Nonempty (Quiver.Hom (F.obj c) d)\n⊢ CategoryTheory.IsCofiltered C","decl":"/-- In this situation, `F` is also initial, see\n    `Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful`. -/\ntheorem IsCofiltered.of_exists_of_isCofiltered_of_fullyFaithful [IsCofiltered D] [F.Full]\n    [F.Faithful] (h : ∀ d, ∃ c, Nonempty (F.obj c ⟶ d)) : IsCofiltered C :=\n  { IsCofilteredOrEmpty.of_exists_of_isCofiltered_of_fullyFaithful F h with\n    nonempty := by\n      have : Nonempty D := IsCofiltered.nonempty\n      obtain ⟨c, -⟩ := h (Classical.arbitrary D)\n      exact ⟨c⟩ }\n\n"}
{"name":"CategoryTheory.Functor.final_of_exists_of_isFiltered_of_fullyFaithful","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.IsFilteredOrEmpty D\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nh : ∀ (d : D), Exists fun c => Nonempty (Quiver.Hom d (F.obj c))\n⊢ F.Final","decl":"/-- In this situation, `C` is also filtered, see\n    `IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful`. -/\ntheorem Functor.final_of_exists_of_isFiltered_of_fullyFaithful [IsFilteredOrEmpty D] [F.Full]\n    [F.Faithful] (h : ∀ d, ∃ c, Nonempty (d ⟶ F.obj c)) : Final F := by\n  have := IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful F h\n  refine Functor.final_of_exists_of_isFiltered F h (fun {d c} s s' => ?_)\n  obtain ⟨c₀, ⟨f⟩⟩ := h (IsFiltered.coeq s s')\n  refine ⟨c₀, F.preimage (IsFiltered.coeqHom s s' ≫ f), ?_⟩\n  simp [reassoc_of% (IsFiltered.coeq_condition s s')]\n\n"}
{"name":"CategoryTheory.Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.IsCofilteredOrEmpty D\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nh : ∀ (d : D), Exists fun c => Nonempty (Quiver.Hom (F.obj c) d)\n⊢ F.Initial","decl":"/-- In this situation, `C` is also cofiltered, see\n    `IsCofilteredOrEmpty.of_exists_of_isCofiltered_of_fullyFaithful`. -/\ntheorem Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful [IsCofilteredOrEmpty D] [F.Full]\n    [Faithful F] (h : ∀ d, ∃ c, Nonempty (F.obj c ⟶ d)) : Initial F := by\n  suffices Final F.op from initial_of_final_op _\n  refine Functor.final_of_exists_of_isFiltered_of_fullyFaithful F.op (fun d => ?_)\n  obtain ⟨c, ⟨f⟩⟩ := h d.unop\n  exact ⟨op c, ⟨f.op⟩⟩\n\n"}
{"name":"CategoryTheory.IsFiltered.under","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nc : C\n⊢ CategoryTheory.IsFiltered (CategoryTheory.Under c)","decl":"/-- Any under category on a filtered or empty category is filtered.\n(Note that under categories are always cofiltered since they have an initial object.) -/\ninstance IsFiltered.under [IsFilteredOrEmpty C] (c : C) : IsFiltered (Under c) :=\n  isFiltered_structuredArrow_of_isFiltered_of_exists _\n    (fun c' => ⟨c', ⟨𝟙 _⟩⟩)\n    (fun s s' => IsFilteredOrEmpty.cocone_maps s s') c\n\n"}
{"name":"CategoryTheory.IsCofiltered.over","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\nc : C\n⊢ CategoryTheory.IsCofiltered (CategoryTheory.Over c)","decl":"/-- Any over category on a cofiltered or empty category is cofiltered.\n(Note that over categories are always filtered since they have a terminal object.) -/\ninstance IsCofiltered.over [IsCofilteredOrEmpty C] (c : C) : IsCofiltered (Over c) :=\n  isCofiltered_costructuredArrow_of_isCofiltered_of_exists _\n    (fun c' => ⟨c', ⟨𝟙 _⟩⟩)\n    (fun s s' => IsCofilteredOrEmpty.cone_maps s s') c\n\n"}
{"name":"CategoryTheory.Under.final_forget","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nc : C\n⊢ (CategoryTheory.Under.forget c).Final","decl":"/-- The forgetful functor of the under category on any filtered or empty category is final. -/\ninstance Under.final_forget [IsFilteredOrEmpty C] (c : C) : Final (Under.forget c) :=\n  final_of_exists_of_isFiltered _\n    (fun c' => ⟨mk (IsFiltered.leftToMax c c'), ⟨IsFiltered.rightToMax c c'⟩⟩)\n    (fun {_} {x} s s' => by\n      use mk (x.hom ≫ IsFiltered.coeqHom s s')\n      use homMk (IsFiltered.coeqHom s s') (by simp)\n      simp only [forget_obj, id_obj, mk_right, const_obj_obj, forget_map, homMk_right]\n      rw [IsFiltered.coeq_condition])\n\n"}
{"name":"CategoryTheory.Over.initial_forget","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\nc : C\n⊢ (CategoryTheory.Over.forget c).Initial","decl":"/-- The forgetful functor of the over category on any cofiltered or empty category is initial. -/\ninstance Over.initial_forget [IsCofilteredOrEmpty C] (c : C) : Initial (Over.forget c) :=\n  initial_of_exists_of_isCofiltered _\n    (fun c' => ⟨mk (IsCofiltered.minToLeft c c'), ⟨IsCofiltered.minToRight c c'⟩⟩)\n    (fun {_} {x} s s' => by\n      use mk (IsCofiltered.eqHom s s' ≫ x.hom)\n      use homMk (IsCofiltered.eqHom s s') (by simp)\n      simp only [forget_obj, mk_left, forget_map, homMk_left]\n      rw [IsCofiltered.eq_condition])\n\n"}
{"name":"CategoryTheory.Functor.Final.exists_coeq_of_locally_small","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type v₁\ninst✝³ : CategoryTheory.Category.{v₁, v₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty C\ninst✝ : F.Final\nd : D\nc : C\ns s' : Quiver.Hom d (F.obj c)\n⊢ Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp s (F.map t)) (CategoryTheory.CategoryStruct.comp s' (F.map t))","decl":"/-- Implementation; use `Functor.Final.exists_coeq instead`. -/\ntheorem Functor.Final.exists_coeq_of_locally_small [IsFilteredOrEmpty C] [Final F] {d : D} {c : C}\n    (s s' : d ⟶ F.obj c) : ∃ (c' : C) (t : c ⟶ c'), s ≫ F.map t = s' ≫ F.map t := by\n  have : colimit.ι (F ⋙ coyoneda.obj (op d)) c s = colimit.ι (F ⋙ coyoneda.obj (op d)) c s' := by\n    apply (Final.colimitCompCoyonedaIso F d).toEquiv.injective\n    subsingleton\n  obtain ⟨c', t₁, t₂, h⟩ := (Types.FilteredColimit.colimit_eq_iff.{v₁, v₁, v₁} _).mp this\n  refine ⟨IsFiltered.coeq t₁ t₂, t₁ ≫ IsFiltered.coeqHom t₁ t₂, ?_⟩\n  conv_rhs => rw [IsFiltered.coeq_condition t₁ t₂]\n  dsimp only [comp_obj, coyoneda_obj_obj, unop_op, Functor.comp_map, coyoneda_obj_map] at h\n  simp [reassoc_of% h]\n\n"}
{"name":"CategoryTheory.Functor.final_iff_of_isFiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\n⊢ Iff F.Final (And (∀ (d : D), Exists fun c => Nonempty (Quiver.Hom d (F.obj c))) (∀ {d : D} {c : C} (s s' : Quiver.Hom d (F.obj c)), Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp s (F.map t)) (CategoryTheory.CategoryStruct.comp s' (F.map t))))","decl":"/-- If `C` is filtered, then we can give an explicit condition for a functor `F : C ⥤ D` to\n    be final. -/\ntheorem Functor.final_iff_of_isFiltered [IsFilteredOrEmpty C] :\n    Final F ↔ (∀ d, ∃ c, Nonempty (d ⟶ F.obj c)) ∧ (∀ {d : D} {c : C} (s s' : d ⟶ F.obj c),\n      ∃ (c' : C) (t : c ⟶ c'), s ≫ F.map t = s' ≫ F.map t) := by\n  refine ⟨fun hF => ⟨?_, ?_⟩, fun h => final_of_exists_of_isFiltered F h.1 h.2⟩\n  · intro d\n    obtain ⟨f⟩ : Nonempty (StructuredArrow d F) := IsConnected.is_nonempty\n    exact ⟨_, ⟨f.hom⟩⟩\n  · let s₁ : C ≌ AsSmall.{max u₁ v₁ u₂ v₂} C := AsSmall.equiv\n    let s₂ : D ≌ AsSmall.{max u₁ v₁ u₂ v₂} D := AsSmall.equiv\n    have : IsFilteredOrEmpty (AsSmall.{max u₁ v₁ u₂ v₂} C) := .of_equivalence s₁\n    intro d c s s'\n    obtain ⟨c', t, ht⟩ := Functor.Final.exists_coeq_of_locally_small (s₁.inverse ⋙ F ⋙ s₂.functor)\n      (AsSmall.up.map s) (AsSmall.up.map s')\n    exact ⟨AsSmall.down.obj c', AsSmall.down.map t, s₂.functor.map_injective (by simp_all [s₁, s₂])⟩\n\n"}
{"name":"CategoryTheory.Functor.initial_iff_of_isCofiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\n⊢ Iff F.Initial (And (∀ (d : D), Exists fun c => Nonempty (Quiver.Hom (F.obj c) d)) (∀ {d : D} {c : C} (s s' : Quiver.Hom (F.obj c) d), Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp (F.map t) s) (CategoryTheory.CategoryStruct.comp (F.map t) s')))","decl":"/-- If `C` is cofiltered, then we can give an explicit condition for a functor `F : C ⥤ D` to\n    be initial. -/\ntheorem Functor.initial_iff_of_isCofiltered [IsCofilteredOrEmpty C] :\n    Initial F ↔ (∀ d, ∃ c, Nonempty (F.obj c ⟶ d)) ∧ (∀ {d : D} {c : C} (s s' : F.obj c ⟶ d),\n      ∃ (c' : C) (t : c' ⟶ c), F.map t ≫ s = F.map t ≫ s') := by\n  refine ⟨fun hF => ?_, fun h => initial_of_exists_of_isCofiltered F h.1 h.2⟩\n  obtain ⟨h₁, h₂⟩ := F.op.final_iff_of_isFiltered.mp inferInstance\n  refine ⟨?_, ?_⟩\n  · intro d\n    obtain ⟨c, ⟨t⟩⟩ := h₁ (op d)\n    exact ⟨c.unop, ⟨t.unop⟩⟩\n  · intro d c s s'\n    obtain ⟨c', t, ht⟩ := h₂ (Quiver.Hom.op s) (Quiver.Hom.op s')\n    exact ⟨c'.unop, t.unop, Quiver.Hom.op_inj ht⟩\n\n"}
{"name":"CategoryTheory.Functor.Final.exists_coeq","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty C\ninst✝ : F.Final\nd : D\nc : C\ns s' : Quiver.Hom d (F.obj c)\n⊢ Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp s (F.map t)) (CategoryTheory.CategoryStruct.comp s' (F.map t))","decl":"theorem Functor.Final.exists_coeq [IsFilteredOrEmpty C] [Final F] {d : D} {c : C}\n    (s s' : d ⟶ F.obj c) : ∃ (c' : C) (t : c ⟶ c'), s ≫ F.map t = s' ≫ F.map t :=\n  ((final_iff_of_isFiltered F).1 inferInstance).2 s s'\n\n"}
{"name":"CategoryTheory.Functor.Initial.exists_eq","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.IsCofilteredOrEmpty C\ninst✝ : F.Initial\nd : D\nc : C\ns s' : Quiver.Hom (F.obj c) d\n⊢ Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp (F.map t) s) (CategoryTheory.CategoryStruct.comp (F.map t) s')","decl":"theorem Functor.Initial.exists_eq [IsCofilteredOrEmpty C] [Initial F] {d : D} {c : C}\n    (s s' : F.obj c ⟶ d) : ∃ (c' : C) (t : c' ⟶ c), F.map t ≫ s = F.map t ≫ s' :=\n  ((initial_iff_of_isCofiltered F).1 inferInstance).2 s s'\n\n"}
{"name":"CategoryTheory.Functor.final_iff_isFiltered_structuredArrow","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\n⊢ Iff F.Final (∀ (d : D), CategoryTheory.IsFiltered (CategoryTheory.StructuredArrow d F))","decl":"/-- If `C` is filtered, then `F : C ⥤ D` is final if and only if `StructuredArrow d F` is filtered\n    for all `d : D`. -/\ntheorem Functor.final_iff_isFiltered_structuredArrow [IsFilteredOrEmpty C] :\n    Final F ↔ ∀ d, IsFiltered (StructuredArrow d F) := by\n  refine ⟨?_, fun h => final_of_isFiltered_structuredArrow F⟩\n  rw [final_iff_of_isFiltered]\n  exact fun h => isFiltered_structuredArrow_of_isFiltered_of_exists F h.1 h.2\n\n"}
{"name":"CategoryTheory.Functor.initial_iff_isCofiltered_costructuredArrow","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\n⊢ Iff F.Initial (∀ (d : D), CategoryTheory.IsCofiltered (CategoryTheory.CostructuredArrow F d))","decl":"/-- If `C` is cofiltered, then `F : C ⥤ D` is initial if and only if `CostructuredArrow F d` is\n    cofiltered for all `d : D`. -/\ntheorem Functor.initial_iff_isCofiltered_costructuredArrow [IsCofilteredOrEmpty C] :\n    Initial F ↔ ∀ d, IsCofiltered (CostructuredArrow F d) := by\n  refine ⟨?_, fun h => initial_of_isCofiltered_costructuredArrow F⟩\n  rw [initial_iff_of_isCofiltered]\n  exact fun h => isCofiltered_costructuredArrow_of_isCofiltered_of_exists F h.1 h.2\n\n"}
{"name":"CategoryTheory.instIsFilteredStructuredArrowProdDiagOfIsFilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\nX : Prod C C\n⊢ CategoryTheory.IsFiltered (CategoryTheory.StructuredArrow X (CategoryTheory.Functor.diag C))","decl":"/-- If `C` is filtered, then the structured arrow category on the diagonal functor `C ⥤ C × C`\nis filtered as well. -/\ninstance [IsFilteredOrEmpty C] (X : C × C) : IsFiltered (StructuredArrow X (diag C)) := by\n  haveI : ∀ Y, IsFiltered (StructuredArrow Y (Under.forget X.1)) := by\n    rw [← final_iff_isFiltered_structuredArrow (Under.forget X.1)]\n    infer_instance\n  apply IsFiltered.of_equivalence (StructuredArrow.ofDiagEquivalence X).symm\n\n"}
{"name":"CategoryTheory.Functor.final_diag_of_isFiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\n⊢ (CategoryTheory.Functor.diag C).Final","decl":"/-- The diagonal functor on any filtered category is final. -/\ninstance Functor.final_diag_of_isFiltered [IsFilteredOrEmpty C] : Final (Functor.diag C) :=\n  final_of_isFiltered_structuredArrow _\n\n-- Adding this instance causes performance problems elsewhere, even with low priority\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.isSiftedOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsFilteredOrEmpty C\n⊢ CategoryTheory.IsSiftedOrEmpty C","decl":"theorem IsFilteredOrEmpty.isSiftedOrEmpty [IsFilteredOrEmpty C] : IsSiftedOrEmpty C :=\n  Functor.final_diag_of_isFiltered\n\n-- Adding this instance causes performance problems elsewhere, even with low priority\n"}
{"name":"CategoryTheory.IsFiltered.isSifted","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsFiltered C\n⊢ CategoryTheory.IsSifted C","decl":"attribute [local instance] IsFiltered.nonempty in\ntheorem IsFiltered.isSifted [IsFiltered C] : IsSifted C where\n\n"}
{"name":"CategoryTheory.instIsCofilteredCostructuredArrowProdDiagOfIsCofilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\nX : Prod C C\n⊢ CategoryTheory.IsCofiltered (CategoryTheory.CostructuredArrow (CategoryTheory.Functor.diag C) X)","decl":"/-- If `C` is cofiltered, then the costructured arrow category on the diagonal functor `C ⥤ C × C`\nis cofiltered as well. -/\ninstance [IsCofilteredOrEmpty C] (X : C × C) : IsCofiltered (CostructuredArrow (diag C) X) := by\n  haveI : ∀ Y, IsCofiltered (CostructuredArrow (Over.forget X.1) Y) := by\n    rw [← initial_iff_isCofiltered_costructuredArrow (Over.forget X.1)]\n    infer_instance\n  apply IsCofiltered.of_equivalence (CostructuredArrow.ofDiagEquivalence X).symm\n\n"}
{"name":"CategoryTheory.Functor.initial_diag_of_isFiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty C\n⊢ (CategoryTheory.Functor.diag C).Initial","decl":"/-- The diagonal functor on any cofiltered category is initial. -/\ninstance Functor.initial_diag_of_isFiltered [IsCofilteredOrEmpty C] : Initial (Functor.diag C) :=\n  initial_of_isCofiltered_costructuredArrow _\n\n"}
{"name":"CategoryTheory.Functor.final_of_isFiltered_of_pUnit","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsFiltered C\nF : CategoryTheory.Functor C (CategoryTheory.Discrete PUnit.{u_1 + 1})\n⊢ F.Final","decl":"/-- If `C` is filtered, then every functor `F : C ⥤ Discrete PUnit` is final. -/\ntheorem Functor.final_of_isFiltered_of_pUnit [IsFiltered C] (F : C ⥤ Discrete PUnit) :\n    Final F := by\n  refine final_of_exists_of_isFiltered F (fun _ => ?_) (fun {_} {c} _ _ => ?_)\n  · use Classical.choice IsFiltered.nonempty\n    exact ⟨Discrete.eqToHom (by simp)⟩\n  · use c; use 𝟙 c\n    apply Subsingleton.elim\n\n"}
{"name":"CategoryTheory.Functor.initial_of_isCofiltered_pUnit","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsCofiltered C\nF : CategoryTheory.Functor C (CategoryTheory.Discrete PUnit.{u_1 + 1})\n⊢ F.Initial","decl":"/-- If `C` is cofiltered, then every functor `F : C ⥤ Discrete PUnit` is initial. -/\ntheorem Functor.initial_of_isCofiltered_pUnit [IsCofiltered C] (F : C ⥤ Discrete PUnit) :\n    Initial F := by\n  refine initial_of_exists_of_isCofiltered F (fun _ => ?_) (fun {_} {c} _ _ => ?_)\n  · use Classical.choice IsCofiltered.nonempty\n    exact ⟨Discrete.eqToHom (by simp)⟩\n  · use c; use 𝟙 c\n    apply Subsingleton.elim\n\n"}
{"name":"CategoryTheory.StructuredArrow.final_proj_of_isFiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty C\nT : CategoryTheory.Functor C D\ninst✝ : T.Final\nY : D\n⊢ (CategoryTheory.StructuredArrow.proj Y T).Final","decl":"/-- The functor `StructuredArrow.proj : StructuredArrow Y T ⥤ C` is final if `T : C ⥤ D` is final\nand `C` is filtered. -/\ninstance StructuredArrow.final_proj_of_isFiltered [IsFilteredOrEmpty C]\n    (T : C ⥤ D) [Final T] (Y : D) : Final (StructuredArrow.proj Y T) := by\n  refine ⟨fun X => ?_⟩\n  rw [isConnected_iff_of_equivalence (ofStructuredArrowProjEquivalence T Y X)]\n  exact (final_comp (Under.forget X) T).out _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.initial_proj_of_isCofiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.IsCofilteredOrEmpty C\nT : CategoryTheory.Functor C D\ninst✝ : T.Initial\nY : D\n⊢ (CategoryTheory.CostructuredArrow.proj T Y).Initial","decl":"/-- The functor `CostructuredArrow.proj : CostructuredArrow Y T ⥤ C` is initial if `T : C ⥤ D` is\ninitial and `C` is cofiltered. -/\ninstance CostructuredArrow.initial_proj_of_isCofiltered [IsCofilteredOrEmpty C]\n    (T : C ⥤ D) [Initial T] (Y : D) : Initial (CostructuredArrow.proj T Y) := by\n  refine ⟨fun X => ?_⟩\n  rw [isConnected_iff_of_equivalence (ofCostructuredArrowProjEquivalence T Y X)]\n  exact (initial_comp (Over.forget X) T).out _\n\n"}
{"name":"CategoryTheory.StructuredArrow.final_map₂_id","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.IsFiltered C\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\nT : CategoryTheory.Functor C D\ninst✝² : T.Final\nS : CategoryTheory.Functor D E\ninst✝¹ : S.Final\nT' : CategoryTheory.Functor C E\nd : D\ne : E\nu : Quiver.Hom e (S.obj d)\nα : Quiver.Hom (T.comp S) T'\ninst✝ : CategoryTheory.IsIso α\n⊢ (CategoryTheory.StructuredArrow.map₂ u α).Final","decl":"/-- The functor `StructuredArrow d T ⥤ StructuredArrow e (T ⋙ S)` that `u : e ⟶ S.obj d`\ninduces via `StructuredArrow.map₂` is final, if `T` and `S` are final and the domain of `T` is\nfiltered. -/\ninstance StructuredArrow.final_map₂_id [IsFiltered C] {E : Type u₃} [Category.{v₃} E]\n    {T : C ⥤ D} [T.Final] {S : D ⥤ E} [S.Final] {T' : C ⥤ E}\n    {d : D} {e : E} (u : e ⟶ S.obj d) (α : T ⋙ S ⟶ T') [IsIso α] :\n    Final (map₂ (F := 𝟭 _) u α) := by\n  haveI : IsFiltered (StructuredArrow e (T ⋙ S)) :=\n    (T ⋙ S).final_iff_isFiltered_structuredArrow.mp inferInstance e\n  apply final_of_natIso (map₂IsoPreEquivalenceInverseCompProj d e u α).symm\n\n"}
{"name":"CategoryTheory.StructuredArrow.final_map","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.IsFiltered C\nS S' : D\nf : Quiver.Hom S S'\nT : CategoryTheory.Functor C D\ninst✝ : T.Final\n⊢ (CategoryTheory.StructuredArrow.map f).Final","decl":"/-- `StructuredArrow.map` is final if the functor `T` is final` and its domain is filtered. -/\ninstance StructuredArrow.final_map [IsFiltered C] {S S' : D} (f : S ⟶ S') (T : C ⥤ D) [T.Final] :\n    Final (map (T := T) f) := by\n  haveI := NatIso.isIso_of_isIso_app (𝟙 T)\n  have : (map₂ (F := 𝟭 C) (G := 𝟭 D) f (𝟙 T)).Final := by\n    apply StructuredArrow.final_map₂_id (S := 𝟭 D) (T := T) (T' := T) f (𝟙 T)\n  apply final_of_natIso (mapIsoMap₂ f).symm\n\n"}
{"name":"CategoryTheory.StructuredArrow.final_post","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.IsFiltered C\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nX : D\nT : CategoryTheory.Functor C D\ninst✝¹ : T.Final\nS : CategoryTheory.Functor D E\ninst✝ : S.Final\n⊢ (CategoryTheory.StructuredArrow.post X T S).Final","decl":"/-- `StructuredArrow.post X T S` is final if `T` and `S` are final and the domain of `T` is\nfiltered. -/\ninstance StructuredArrow.final_post [IsFiltered C] {E : Type u₃} [Category.{v₃} E] (X : D)\n    (T : C ⥤ D) [T.Final] (S : D ⥤ E) [S.Final] : Final (post X T S) := by\n  apply final_of_natIso (postIsoMap₂ X T S).symm\n\n"}
{"name":"CategoryTheory.CostructuredArrow.initial_map₂_id","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.IsCofiltered C\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nT : CategoryTheory.Functor C D\ninst✝¹ : T.Initial\nS : CategoryTheory.Functor D E\ninst✝ : S.Initial\nd : D\ne : E\nu : Quiver.Hom (S.obj d) e\n⊢ (CategoryTheory.CostructuredArrow.map₂ (CategoryTheory.CategoryStruct.id (T.comp S)) u).Initial","decl":"/-- The functor `CostructuredArrow T d ⥤ CostructuredArrow (T ⋙ S) e` that `u : S.obj d ⟶ e`\ninduces via `CostructuredArrow.map₂` is initial, if `T` and `S` are initial and the domain of `T` is\nfiltered. -/\ninstance CostructuredArrow.initial_map₂_id [IsCofiltered C] {E : Type u₃} [Category.{v₃} E]\n    (T : C ⥤ D) [T.Initial] (S : D ⥤ E) [S.Initial] (d : D) (e : E)\n    (u : S.obj d ⟶ e) : Initial (map₂ (F := 𝟭 _) (U := T ⋙ S) (𝟙 (T ⋙ S)) u) := by\n  have := (T ⋙ S).initial_iff_isCofiltered_costructuredArrow.mp inferInstance e\n  apply initial_of_natIso (map₂IsoPreEquivalenceInverseCompProj T S d e u).symm\n\n"}
{"name":"CategoryTheory.CostructuredArrow.initial_post","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.IsCofiltered C\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nX : D\nT : CategoryTheory.Functor C D\ninst✝¹ : T.Initial\nS : CategoryTheory.Functor D E\ninst✝ : S.Initial\n⊢ (CategoryTheory.CostructuredArrow.post T S X).Initial","decl":"/-- `CostructuredArrow.post T S X` is initial if `T` and `S` are initial and the domain of `T` is\ncofiltered. -/\ninstance CostructuredArrow.initial_post [IsCofiltered C] {E : Type u₃} [Category.{v₃} E] (X : D)\n    (T : C ⥤ D) [T.Initial] (S : D ⥤ E) [S.Initial] : Initial (post T S X) := by\n  apply initial_of_natIso (postIsoMap₂ X T S).symm\n\n"}
{"name":"CategoryTheory.final_eval","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"α : Type u₁\nI : α → Type u₂\ninst✝¹ : (s : α) → CategoryTheory.Category.{v₂, u₂} (I s)\ninst✝ : ∀ (s : α), CategoryTheory.IsFiltered (I s)\ns : α\n⊢ (CategoryTheory.Pi.eval I s).Final","decl":"open IsFiltered in\ninstance final_eval [∀ s, IsFiltered (I s)] (s : α) : (Pi.eval I s).Final := by\n  classical\n  apply Functor.final_of_exists_of_isFiltered\n  · exact fun i => ⟨Function.update (fun t => nonempty.some) s i, ⟨by simpa using 𝟙 _⟩⟩\n  · intro d c f g\n    let c't : (∀ s, (c' : I s) × (c s ⟶ c')) := Function.update (fun t => ⟨c t, 𝟙 (c t)⟩)\n      s ⟨coeq f g, coeqHom f g⟩\n    refine ⟨fun t => (c't t).1, fun t => (c't t).2, ?_⟩\n    dsimp only [Pi.eval_obj, Pi.eval_map, c't]\n    rw [Function.update_self]\n    simpa using coeq_condition _ _\n\n"}
{"name":"CategoryTheory.initial_eval","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"α : Type u₁\nI : α → Type u₂\ninst✝¹ : (s : α) → CategoryTheory.Category.{v₂, u₂} (I s)\ninst✝ : ∀ (s : α), CategoryTheory.IsCofiltered (I s)\ns : α\n⊢ (CategoryTheory.Pi.eval I s).Initial","decl":"open IsCofiltered in\ninstance initial_eval [∀ s, IsCofiltered (I s)] (s : α) : (Pi.eval I s).Initial := by\n  classical\n  apply Functor.initial_of_exists_of_isCofiltered\n  · exact fun i => ⟨Function.update (fun t => nonempty.some) s i, ⟨by simpa using 𝟙 _⟩⟩\n  · intro d c f g\n    let c't : (∀ s, (c' : I s) × (c' ⟶ c s)) := Function.update (fun t => ⟨c t, 𝟙 (c t)⟩)\n      s ⟨eq f g, eqHom f g⟩\n    refine ⟨fun t => (c't t).1, fun t => (c't t).2, ?_⟩\n    dsimp only [Pi.eval_obj, Pi.eval_map, c't]\n    rw [Function.update_self]\n    simpa using eq_condition _ _\n\n"}
{"name":"CategoryTheory.final_fst","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty C\ninst✝ : CategoryTheory.IsFiltered D\n⊢ (CategoryTheory.Prod.fst C D).Final","decl":"open IsFiltered in\ninstance final_fst [IsFilteredOrEmpty C] [IsFiltered D] : (Prod.fst C D).Final := by\n  apply Functor.final_of_exists_of_isFiltered\n  · exact fun c => ⟨(c, nonempty.some), ⟨𝟙 c⟩⟩\n  · intro c ⟨c', d'⟩ f g\n    exact ⟨(coeq f g, d'), (coeqHom f g, 𝟙 d'), coeq_condition _ _⟩\n\n"}
{"name":"CategoryTheory.final_snd","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.IsFiltered C\ninst✝ : CategoryTheory.IsFilteredOrEmpty D\n⊢ (CategoryTheory.Prod.snd C D).Final","decl":"instance final_snd [IsFiltered C] [IsFilteredOrEmpty D] : (Prod.snd C D).Final :=\n  inferInstanceAs ((Prod.braiding C D).functor ⋙ Prod.fst D C).Final\n\n"}
{"name":"CategoryTheory.initial_fst","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.IsCofilteredOrEmpty C\ninst✝ : CategoryTheory.IsCofiltered D\n⊢ (CategoryTheory.Prod.fst C D).Initial","decl":"open IsCofiltered in\ninstance initial_fst [IsCofilteredOrEmpty C] [IsCofiltered D] : (Prod.fst C D).Initial := by\n  apply Functor.initial_of_exists_of_isCofiltered\n  · exact fun c => ⟨(c, nonempty.some), ⟨𝟙 c⟩⟩\n  · intro c ⟨c', d'⟩ f g\n    exact ⟨(eq f g, d'), (eqHom f g, 𝟙 d'), eq_condition _ _⟩\n\n"}
{"name":"CategoryTheory.initial_snd","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.IsCofiltered C\ninst✝ : CategoryTheory.IsCofilteredOrEmpty D\n⊢ (CategoryTheory.Prod.snd C D).Initial","decl":"instance initial_snd [IsCofiltered C] [IsCofilteredOrEmpty D] : (Prod.snd C D).Initial :=\n  inferInstanceAs ((Prod.braiding C D).functor ⋙ Prod.fst D C).Initial\n\n"}
