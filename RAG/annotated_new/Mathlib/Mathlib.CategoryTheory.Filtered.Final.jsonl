{"name":"CategoryTheory.Functor.final_of_isFiltered_structuredArrow","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : âˆ€ (d : D), CategoryTheory.IsFiltered (CategoryTheory.StructuredArrow d F)\nâŠ¢ F.Final","decl":"/-- If `StructuredArrow d F` is filtered for any `d : D`, then `F : C â¥¤ D` is final. This is\n    simply because filtered categories are connected. More profoundly, the converse is also true if\n    `C` is filtered, see `final_iff_isFiltered_structuredArrow`. -/\ntheorem Functor.final_of_isFiltered_structuredArrow [âˆ€ d, IsFiltered (StructuredArrow d F)] :\n    Final F where\n  out _ := IsFiltered.isConnected _\n\n"}
{"name":"CategoryTheory.Functor.initial_of_isCofiltered_costructuredArrow","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : âˆ€ (d : D), CategoryTheory.IsCofiltered (CategoryTheory.CostructuredArrow F d)\nâŠ¢ F.Initial","decl":"/-- If `CostructuredArrow F d` is filtered for any `d : D`, then `F : C â¥¤ D` is initial. This is\n    simply because cofiltered categories are connectged. More profoundly, the converse is also true\n    if `C` is cofiltered, see `initial_iff_isCofiltered_costructuredArrow`. -/\ntheorem Functor.initial_of_isCofiltered_costructuredArrow\n    [âˆ€ d, IsCofiltered (CostructuredArrow F d)] : Initial F where\n  out _ := IsCofiltered.isConnected _\n\n"}
{"name":"CategoryTheory.isFiltered_structuredArrow_of_isFiltered_of_exists","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.IsFilteredOrEmpty C\nhâ‚ : âˆ€ (d : D), Exists fun c => Nonempty (Quiver.Hom d (F.obj c))\nhâ‚‚ : âˆ€ {d : D} {c : C} (s s' : Quiver.Hom d (F.obj c)), Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp s (F.map t)) (CategoryTheory.CategoryStruct.comp s' (F.map t))\nd : D\nâŠ¢ CategoryTheory.IsFiltered (CategoryTheory.StructuredArrow d F)","decl":"theorem isFiltered_structuredArrow_of_isFiltered_of_exists [IsFilteredOrEmpty C]\n    (hâ‚ : âˆ€ d, âˆƒ c, Nonempty (d âŸ¶ F.obj c)) (hâ‚‚ : âˆ€ {d : D} {c : C} (s s' : d âŸ¶ F.obj c),\n      âˆƒ (c' : C) (t : c âŸ¶ c'), s â‰« F.map t = s' â‰« F.map t) (d : D) :\n    IsFiltered (StructuredArrow d F) := by\n  have : Nonempty (StructuredArrow d F) := by\n    obtain âŸ¨c, âŸ¨fâŸ©âŸ© := hâ‚ d\n    exact âŸ¨.mk fâŸ©\n  suffices IsFilteredOrEmpty (StructuredArrow d F) from IsFiltered.mk\n  refine âŸ¨fun f g => ?_, fun f g Î· Î¼ => ?_âŸ©\n  Â· obtain âŸ¨c, âŸ¨t, htâŸ©âŸ© := hâ‚‚ (f.hom â‰« F.map (IsFiltered.leftToMax f.right g.right))\n        (g.hom â‰« F.map (IsFiltered.rightToMax f.right g.right))\n    refine âŸ¨.mk (f.hom â‰« F.map (IsFiltered.leftToMax f.right g.right â‰« t)), ?_, ?_, trivialâŸ©\n    Â· exact StructuredArrow.homMk (IsFiltered.leftToMax _ _ â‰« t) rfl\n    Â· exact StructuredArrow.homMk (IsFiltered.rightToMax _ _ â‰« t) (by simpa using ht.symm)\n  Â· refine âŸ¨.mk (f.hom â‰« F.map (Î·.right â‰« IsFiltered.coeqHom Î·.right Î¼.right)),\n      StructuredArrow.homMk (IsFiltered.coeqHom Î·.right Î¼.right) (by simp), ?_âŸ©\n    simpa using IsFiltered.coeq_condition _ _\n\n"}
{"name":"CategoryTheory.isCofiltered_costructuredArrow_of_isCofiltered_of_exists","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.IsCofilteredOrEmpty C\nhâ‚ : âˆ€ (d : D), Exists fun c => Nonempty (Quiver.Hom (F.obj c) d)\nhâ‚‚ : âˆ€ {d : D} {c : C} (s s' : Quiver.Hom (F.obj c) d), Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp (F.map t) s) (CategoryTheory.CategoryStruct.comp (F.map t) s')\nd : D\nâŠ¢ CategoryTheory.IsCofiltered (CategoryTheory.CostructuredArrow F d)","decl":"theorem isCofiltered_costructuredArrow_of_isCofiltered_of_exists [IsCofilteredOrEmpty C]\n    (hâ‚ : âˆ€ d, âˆƒ c, Nonempty (F.obj c âŸ¶ d)) (hâ‚‚ : âˆ€ {d : D} {c : C} (s s' : F.obj c âŸ¶ d),\n      âˆƒ (c' : C) (t : c' âŸ¶ c), F.map t â‰« s = F.map t â‰« s') (d : D) :\n    IsCofiltered (CostructuredArrow F d) := by\n  suffices IsFiltered (CostructuredArrow F d)áµ’áµ– from isCofiltered_of_isFiltered_op _\n  suffices IsFiltered (StructuredArrow (op d) F.op) from\n    IsFiltered.of_equivalence (costructuredArrowOpEquivalence _ _).symm\n  apply isFiltered_structuredArrow_of_isFiltered_of_exists\n  Â· intro d\n    obtain âŸ¨c, âŸ¨tâŸ©âŸ© := hâ‚ d.unop\n    exact âŸ¨op c, âŸ¨Quiver.Hom.op tâŸ©âŸ©\n  Â· intro d c s s'\n    obtain âŸ¨c', t, htâŸ© := hâ‚‚ s.unop s'.unop\n    exact âŸ¨op c', Quiver.Hom.op t, Quiver.Hom.unop_inj htâŸ©\n\n"}
{"name":"CategoryTheory.Functor.final_of_exists_of_isFiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.IsFilteredOrEmpty C\nhâ‚ : âˆ€ (d : D), Exists fun c => Nonempty (Quiver.Hom d (F.obj c))\nhâ‚‚ : âˆ€ {d : D} {c : C} (s s' : Quiver.Hom d (F.obj c)), Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp s (F.map t)) (CategoryTheory.CategoryStruct.comp s' (F.map t))\nâŠ¢ F.Final","decl":"/-- If `C` is filtered, then we can give an explicit condition for a functor `F : C â¥¤ D` to\n    be final. The converse is also true, see `final_iff_of_isFiltered`. -/\ntheorem Functor.final_of_exists_of_isFiltered [IsFilteredOrEmpty C]\n    (hâ‚ : âˆ€ d, âˆƒ c, Nonempty (d âŸ¶ F.obj c)) (hâ‚‚ : âˆ€ {d : D} {c : C} (s s' : d âŸ¶ F.obj c),\n      âˆƒ (c' : C) (t : c âŸ¶ c'), s â‰« F.map t = s' â‰« F.map t) : Functor.Final F := by\n  suffices âˆ€ d, IsFiltered (StructuredArrow d F) from final_of_isFiltered_structuredArrow F\n  exact isFiltered_structuredArrow_of_isFiltered_of_exists F hâ‚ hâ‚‚\n\n"}
{"name":"CategoryTheory.Functor.final_const_of_isTerminal","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.IsFiltered C\nX : D\nhX : CategoryTheory.Limits.IsTerminal X\nâŠ¢ ((CategoryTheory.Functor.const C).obj X).Final","decl":"/-- The inclusion of a terminal object is final. -/\ntheorem Functor.final_const_of_isTerminal [IsFiltered C] {X : D} (hX : IsTerminal X) :\n    ((Functor.const C).obj X).Final :=\n  Functor.final_of_exists_of_isFiltered _ (fun _ => âŸ¨IsFiltered.nonempty.some, âŸ¨hX.from _âŸ©âŸ©)\n    (fun {_ c} _ _ => âŸ¨c, ğŸ™ _, hX.hom_ext _ _âŸ©)\n\n"}
{"name":"CategoryTheory.Functor.final_const_terminal","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.IsFiltered C\ninstâœ : CategoryTheory.Limits.HasTerminal D\nâŠ¢ ((CategoryTheory.Functor.const C).obj (CategoryTheory.Limits.terminal D)).Final","decl":"/-- The inclusion of the terminal object is final. -/\ntheorem Functor.final_const_terminal [IsFiltered C] [HasTerminal D] :\n    ((Functor.const C).obj (âŠ¤_ D)).Final :=\n  Functor.final_const_of_isTerminal terminalIsTerminal\n\n"}
{"name":"CategoryTheory.Functor.initial_of_exists_of_isCofiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.IsCofilteredOrEmpty C\nhâ‚ : âˆ€ (d : D), Exists fun c => Nonempty (Quiver.Hom (F.obj c) d)\nhâ‚‚ : âˆ€ {d : D} {c : C} (s s' : Quiver.Hom (F.obj c) d), Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp (F.map t) s) (CategoryTheory.CategoryStruct.comp (F.map t) s')\nâŠ¢ F.Initial","decl":"/-- If `C` is cofiltered, then we can give an explicit condition for a functor `F : C â¥¤ D` to\n    be final. The converse is also true, see `initial_iff_of_isCofiltered`. -/\ntheorem Functor.initial_of_exists_of_isCofiltered [IsCofilteredOrEmpty C]\n    (hâ‚ : âˆ€ d, âˆƒ c, Nonempty (F.obj c âŸ¶ d)) (hâ‚‚ : âˆ€ {d : D} {c : C} (s s' : F.obj c âŸ¶ d),\n      âˆƒ (c' : C) (t : c' âŸ¶ c), F.map t â‰« s = F.map t â‰« s') : Functor.Initial F := by\n  suffices âˆ€ d, IsCofiltered (CostructuredArrow F d) from\n    initial_of_isCofiltered_costructuredArrow F\n  exact isCofiltered_costructuredArrow_of_isCofiltered_of_exists F hâ‚ hâ‚‚\n\n"}
{"name":"CategoryTheory.Functor.initial_const_of_isInitial","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.IsCofiltered C\nX : D\nhX : CategoryTheory.Limits.IsInitial X\nâŠ¢ ((CategoryTheory.Functor.const C).obj X).Initial","decl":"/-- The inclusion of an initial object is initial. -/\ntheorem Functor.initial_const_of_isInitial [IsCofiltered C] {X : D} (hX : IsInitial X) :\n    ((Functor.const C).obj X).Initial :=\n  Functor.initial_of_exists_of_isCofiltered _ (fun _ => âŸ¨IsCofiltered.nonempty.some, âŸ¨hX.to _âŸ©âŸ©)\n    (fun {_ c} _ _ => âŸ¨c, ğŸ™ _, hX.hom_ext _ _âŸ©)\n\n"}
{"name":"CategoryTheory.Functor.initial_const_initial","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.IsCofiltered C\ninstâœ : CategoryTheory.Limits.HasInitial D\nâŠ¢ ((CategoryTheory.Functor.const C).obj (CategoryTheory.Limits.initial D)).Initial","decl":"/-- The inclusion of the initial object is initial. -/\ntheorem Functor.initial_const_initial [IsCofiltered C] [HasInitial D] :\n    ((Functor.const C).obj (âŠ¥_ D)).Initial :=\n  Functor.initial_const_of_isInitial initialIsInitial\n\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : CategoryTheory.IsFilteredOrEmpty D\ninstâœÂ¹ : F.Full\ninstâœ : F.Faithful\nh : âˆ€ (d : D), Exists fun c => Nonempty (Quiver.Hom d (F.obj c))\nâŠ¢ CategoryTheory.IsFilteredOrEmpty C","decl":"/-- In this situation, `F` is also final, see\n    `Functor.final_of_exists_of_isFiltered_of_fullyFaithful`. -/\ntheorem IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful [IsFilteredOrEmpty D] [F.Full]\n    [F.Faithful] (h : âˆ€ d, âˆƒ c, Nonempty (d âŸ¶ F.obj c)) : IsFilteredOrEmpty C where\n  cocone_objs c c' := by\n    obtain âŸ¨câ‚€, âŸ¨fâŸ©âŸ© := h (IsFiltered.max (F.obj c) (F.obj c'))\n    exact âŸ¨câ‚€, F.preimage (IsFiltered.leftToMax _ _ â‰« f),\n      F.preimage (IsFiltered.rightToMax _ _ â‰« f), trivialâŸ©\n  cocone_maps {c c'} f g := by\n    obtain âŸ¨câ‚€, âŸ¨fâ‚€âŸ©âŸ© := h (IsFiltered.coeq (F.map f) (F.map g))\n    refine âŸ¨_, F.preimage (IsFiltered.coeqHom (F.map f) (F.map g) â‰« fâ‚€), F.map_injective ?_âŸ©\n    simp [reassoc_of% (IsFiltered.coeq_condition (F.map f) (F.map g))]\n\n"}
{"name":"CategoryTheory.IsCofilteredOrEmpty.of_exists_of_isCofiltered_of_fullyFaithful","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : CategoryTheory.IsCofilteredOrEmpty D\ninstâœÂ¹ : F.Full\ninstâœ : F.Faithful\nh : âˆ€ (d : D), Exists fun c => Nonempty (Quiver.Hom (F.obj c) d)\nâŠ¢ CategoryTheory.IsCofilteredOrEmpty C","decl":"/-- In this situation, `F` is also initial, see\n    `Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful`. -/\ntheorem IsCofilteredOrEmpty.of_exists_of_isCofiltered_of_fullyFaithful [IsCofilteredOrEmpty D]\n    [F.Full] [F.Faithful] (h : âˆ€ d, âˆƒ c, Nonempty (F.obj c âŸ¶ d)) : IsCofilteredOrEmpty C := by\n  suffices IsFilteredOrEmpty Cáµ’áµ– from isCofilteredOrEmpty_of_isFilteredOrEmpty_op _\n  refine IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful F.op (fun d => ?_)\n  obtain âŸ¨c, âŸ¨fâŸ©âŸ© := h d.unop\n  exact âŸ¨op c, âŸ¨f.opâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.IsFiltered.of_exists_of_isFiltered_of_fullyFaithful","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : CategoryTheory.IsFiltered D\ninstâœÂ¹ : F.Full\ninstâœ : F.Faithful\nh : âˆ€ (d : D), Exists fun c => Nonempty (Quiver.Hom d (F.obj c))\nâŠ¢ CategoryTheory.IsFiltered C","decl":"/-- In this situation, `F` is also final, see\n    `Functor.final_of_exists_of_isFiltered_of_fullyFaithful`. -/\ntheorem IsFiltered.of_exists_of_isFiltered_of_fullyFaithful [IsFiltered D] [F.Full] [F.Faithful]\n    (h : âˆ€ d, âˆƒ c, Nonempty (d âŸ¶ F.obj c)) : IsFiltered C :=\n  { IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful F h with\n    nonempty := by\n      have : Nonempty D := IsFiltered.nonempty\n      obtain âŸ¨c, -âŸ© := h (Classical.arbitrary D)\n      exact âŸ¨câŸ© }\n\n"}
{"name":"CategoryTheory.IsCofiltered.of_exists_of_isCofiltered_of_fullyFaithful","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : CategoryTheory.IsCofiltered D\ninstâœÂ¹ : F.Full\ninstâœ : F.Faithful\nh : âˆ€ (d : D), Exists fun c => Nonempty (Quiver.Hom (F.obj c) d)\nâŠ¢ CategoryTheory.IsCofiltered C","decl":"/-- In this situation, `F` is also initial, see\n    `Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful`. -/\ntheorem IsCofiltered.of_exists_of_isCofiltered_of_fullyFaithful [IsCofiltered D] [F.Full]\n    [F.Faithful] (h : âˆ€ d, âˆƒ c, Nonempty (F.obj c âŸ¶ d)) : IsCofiltered C :=\n  { IsCofilteredOrEmpty.of_exists_of_isCofiltered_of_fullyFaithful F h with\n    nonempty := by\n      have : Nonempty D := IsCofiltered.nonempty\n      obtain âŸ¨c, -âŸ© := h (Classical.arbitrary D)\n      exact âŸ¨câŸ© }\n\n"}
{"name":"CategoryTheory.Functor.final_of_exists_of_isFiltered_of_fullyFaithful","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : CategoryTheory.IsFilteredOrEmpty D\ninstâœÂ¹ : F.Full\ninstâœ : F.Faithful\nh : âˆ€ (d : D), Exists fun c => Nonempty (Quiver.Hom d (F.obj c))\nâŠ¢ F.Final","decl":"/-- In this situation, `C` is also filtered, see\n    `IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful`. -/\ntheorem Functor.final_of_exists_of_isFiltered_of_fullyFaithful [IsFilteredOrEmpty D] [F.Full]\n    [F.Faithful] (h : âˆ€ d, âˆƒ c, Nonempty (d âŸ¶ F.obj c)) : Final F := by\n  have := IsFilteredOrEmpty.of_exists_of_isFiltered_of_fullyFaithful F h\n  refine Functor.final_of_exists_of_isFiltered F h (fun {d c} s s' => ?_)\n  obtain âŸ¨câ‚€, âŸ¨fâŸ©âŸ© := h (IsFiltered.coeq s s')\n  refine âŸ¨câ‚€, F.preimage (IsFiltered.coeqHom s s' â‰« f), ?_âŸ©\n  simp [reassoc_of% (IsFiltered.coeq_condition s s')]\n\n"}
{"name":"CategoryTheory.Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ² : CategoryTheory.IsCofilteredOrEmpty D\ninstâœÂ¹ : F.Full\ninstâœ : F.Faithful\nh : âˆ€ (d : D), Exists fun c => Nonempty (Quiver.Hom (F.obj c) d)\nâŠ¢ F.Initial","decl":"/-- In this situation, `C` is also cofiltered, see\n    `IsCofilteredOrEmpty.of_exists_of_isCofiltered_of_fullyFaithful`. -/\ntheorem Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful [IsCofilteredOrEmpty D] [F.Full]\n    [Faithful F] (h : âˆ€ d, âˆƒ c, Nonempty (F.obj c âŸ¶ d)) : Initial F := by\n  suffices Final F.op from initial_of_final_op _\n  refine Functor.final_of_exists_of_isFiltered_of_fullyFaithful F.op (fun d => ?_)\n  obtain âŸ¨c, âŸ¨fâŸ©âŸ© := h d.unop\n  exact âŸ¨op c, âŸ¨f.opâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.IsFiltered.under","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.IsFilteredOrEmpty C\nc : C\nâŠ¢ CategoryTheory.IsFiltered (CategoryTheory.Under c)","decl":"/-- Any under category on a filtered or empty category is filtered.\n(Note that under categories are always cofiltered since they have an initial object.) -/\ninstance IsFiltered.under [IsFilteredOrEmpty C] (c : C) : IsFiltered (Under c) :=\n  isFiltered_structuredArrow_of_isFiltered_of_exists _\n    (fun c' => âŸ¨c', âŸ¨ğŸ™ _âŸ©âŸ©)\n    (fun s s' => IsFilteredOrEmpty.cocone_maps s s') c\n\n"}
{"name":"CategoryTheory.IsCofiltered.over","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.IsCofilteredOrEmpty C\nc : C\nâŠ¢ CategoryTheory.IsCofiltered (CategoryTheory.Over c)","decl":"/-- Any over category on a cofiltered or empty category is cofiltered.\n(Note that over categories are always filtered since they have a terminal object.) -/\ninstance IsCofiltered.over [IsCofilteredOrEmpty C] (c : C) : IsCofiltered (Over c) :=\n  isCofiltered_costructuredArrow_of_isCofiltered_of_exists _\n    (fun c' => âŸ¨c', âŸ¨ğŸ™ _âŸ©âŸ©)\n    (fun s s' => IsCofilteredOrEmpty.cone_maps s s') c\n\n"}
{"name":"CategoryTheory.Under.final_forget","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.IsFilteredOrEmpty C\nc : C\nâŠ¢ (CategoryTheory.Under.forget c).Final","decl":"/-- The forgetful functor of the under category on any filtered or empty category is final. -/\ninstance Under.final_forget [IsFilteredOrEmpty C] (c : C) : Final (Under.forget c) :=\n  final_of_exists_of_isFiltered _\n    (fun c' => âŸ¨mk (IsFiltered.leftToMax c c'), âŸ¨IsFiltered.rightToMax c c'âŸ©âŸ©)\n    (fun {_} {x} s s' => by\n      use mk (x.hom â‰« IsFiltered.coeqHom s s')\n      use homMk (IsFiltered.coeqHom s s') (by simp)\n      simp only [forget_obj, id_obj, mk_right, const_obj_obj, forget_map, homMk_right]\n      rw [IsFiltered.coeq_condition])\n\n"}
{"name":"CategoryTheory.Over.initial_forget","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.IsCofilteredOrEmpty C\nc : C\nâŠ¢ (CategoryTheory.Over.forget c).Initial","decl":"/-- The forgetful functor of the over category on any cofiltered or empty category is initial. -/\ninstance Over.initial_forget [IsCofilteredOrEmpty C] (c : C) : Initial (Over.forget c) :=\n  initial_of_exists_of_isCofiltered _\n    (fun c' => âŸ¨mk (IsCofiltered.minToLeft c c'), âŸ¨IsCofiltered.minToRight c c'âŸ©âŸ©)\n    (fun {_} {x} s s' => by\n      use mk (IsCofiltered.eqHom s s' â‰« x.hom)\n      use homMk (IsCofiltered.eqHom s s') (by simp)\n      simp only [forget_obj, mk_left, forget_map, homMk_left]\n      rw [IsCofiltered.eq_condition])\n\n"}
{"name":"CategoryTheory.Functor.Final.exists_coeq_of_locally_small","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type vâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, vâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : CategoryTheory.IsFilteredOrEmpty C\ninstâœ : F.Final\nd : D\nc : C\ns s' : Quiver.Hom d (F.obj c)\nâŠ¢ Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp s (F.map t)) (CategoryTheory.CategoryStruct.comp s' (F.map t))","decl":"/-- Implementation; use `Functor.Final.exists_coeq instead`. -/\ntheorem Functor.Final.exists_coeq_of_locally_small [IsFilteredOrEmpty C] [Final F] {d : D} {c : C}\n    (s s' : d âŸ¶ F.obj c) : âˆƒ (c' : C) (t : c âŸ¶ c'), s â‰« F.map t = s' â‰« F.map t := by\n  have : colimit.Î¹ (F â‹™ coyoneda.obj (op d)) c s = colimit.Î¹ (F â‹™ coyoneda.obj (op d)) c s' := by\n    apply (Final.colimitCompCoyonedaIso F d).toEquiv.injective\n    subsingleton\n  obtain âŸ¨c', tâ‚, tâ‚‚, hâŸ© := (Types.FilteredColimit.colimit_eq_iff.{vâ‚, vâ‚, vâ‚} _).mp this\n  refine âŸ¨IsFiltered.coeq tâ‚ tâ‚‚, tâ‚ â‰« IsFiltered.coeqHom tâ‚ tâ‚‚, ?_âŸ©\n  conv_rhs => rw [IsFiltered.coeq_condition tâ‚ tâ‚‚]\n  dsimp only [comp_obj, coyoneda_obj_obj, unop_op, Functor.comp_map, coyoneda_obj_map] at h\n  simp [reassoc_of% h]\n\n"}
{"name":"CategoryTheory.Functor.final_iff_of_isFiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.IsFilteredOrEmpty C\nâŠ¢ Iff F.Final (And (âˆ€ (d : D), Exists fun c => Nonempty (Quiver.Hom d (F.obj c))) (âˆ€ {d : D} {c : C} (s s' : Quiver.Hom d (F.obj c)), Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp s (F.map t)) (CategoryTheory.CategoryStruct.comp s' (F.map t))))","decl":"/-- If `C` is filtered, then we can give an explicit condition for a functor `F : C â¥¤ D` to\n    be final. -/\ntheorem Functor.final_iff_of_isFiltered [IsFilteredOrEmpty C] :\n    Final F â†” (âˆ€ d, âˆƒ c, Nonempty (d âŸ¶ F.obj c)) âˆ§ (âˆ€ {d : D} {c : C} (s s' : d âŸ¶ F.obj c),\n      âˆƒ (c' : C) (t : c âŸ¶ c'), s â‰« F.map t = s' â‰« F.map t) := by\n  refine âŸ¨fun hF => âŸ¨?_, ?_âŸ©, fun h => final_of_exists_of_isFiltered F h.1 h.2âŸ©\n  Â· intro d\n    obtain âŸ¨fâŸ© : Nonempty (StructuredArrow d F) := IsConnected.is_nonempty\n    exact âŸ¨_, âŸ¨f.homâŸ©âŸ©\n  Â· let sâ‚ : C â‰Œ AsSmall.{max uâ‚ vâ‚ uâ‚‚ vâ‚‚} C := AsSmall.equiv\n    let sâ‚‚ : D â‰Œ AsSmall.{max uâ‚ vâ‚ uâ‚‚ vâ‚‚} D := AsSmall.equiv\n    have : IsFilteredOrEmpty (AsSmall.{max uâ‚ vâ‚ uâ‚‚ vâ‚‚} C) := .of_equivalence sâ‚\n    intro d c s s'\n    obtain âŸ¨c', t, htâŸ© := Functor.Final.exists_coeq_of_locally_small (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor)\n      (AsSmall.up.map s) (AsSmall.up.map s')\n    exact âŸ¨AsSmall.down.obj c', AsSmall.down.map t, sâ‚‚.functor.map_injective (by simp_all [sâ‚, sâ‚‚])âŸ©\n\n"}
{"name":"CategoryTheory.Functor.initial_iff_of_isCofiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.IsCofilteredOrEmpty C\nâŠ¢ Iff F.Initial (And (âˆ€ (d : D), Exists fun c => Nonempty (Quiver.Hom (F.obj c) d)) (âˆ€ {d : D} {c : C} (s s' : Quiver.Hom (F.obj c) d), Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp (F.map t) s) (CategoryTheory.CategoryStruct.comp (F.map t) s')))","decl":"/-- If `C` is cofiltered, then we can give an explicit condition for a functor `F : C â¥¤ D` to\n    be initial. -/\ntheorem Functor.initial_iff_of_isCofiltered [IsCofilteredOrEmpty C] :\n    Initial F â†” (âˆ€ d, âˆƒ c, Nonempty (F.obj c âŸ¶ d)) âˆ§ (âˆ€ {d : D} {c : C} (s s' : F.obj c âŸ¶ d),\n      âˆƒ (c' : C) (t : c' âŸ¶ c), F.map t â‰« s = F.map t â‰« s') := by\n  refine âŸ¨fun hF => ?_, fun h => initial_of_exists_of_isCofiltered F h.1 h.2âŸ©\n  obtain âŸ¨hâ‚, hâ‚‚âŸ© := F.op.final_iff_of_isFiltered.mp inferInstance\n  refine âŸ¨?_, ?_âŸ©\n  Â· intro d\n    obtain âŸ¨c, âŸ¨tâŸ©âŸ© := hâ‚ (op d)\n    exact âŸ¨c.unop, âŸ¨t.unopâŸ©âŸ©\n  Â· intro d c s s'\n    obtain âŸ¨c', t, htâŸ© := hâ‚‚ (Quiver.Hom.op s) (Quiver.Hom.op s')\n    exact âŸ¨c'.unop, t.unop, Quiver.Hom.op_inj htâŸ©\n\n"}
{"name":"CategoryTheory.Functor.Final.exists_coeq","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : CategoryTheory.IsFilteredOrEmpty C\ninstâœ : F.Final\nd : D\nc : C\ns s' : Quiver.Hom d (F.obj c)\nâŠ¢ Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp s (F.map t)) (CategoryTheory.CategoryStruct.comp s' (F.map t))","decl":"theorem Functor.Final.exists_coeq [IsFilteredOrEmpty C] [Final F] {d : D} {c : C}\n    (s s' : d âŸ¶ F.obj c) : âˆƒ (c' : C) (t : c âŸ¶ c'), s â‰« F.map t = s' â‰« F.map t :=\n  ((final_iff_of_isFiltered F).1 inferInstance).2 s s'\n\n"}
{"name":"CategoryTheory.Functor.Initial.exists_eq","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœÂ¹ : CategoryTheory.IsCofilteredOrEmpty C\ninstâœ : F.Initial\nd : D\nc : C\ns s' : Quiver.Hom (F.obj c) d\nâŠ¢ Exists fun c' => Exists fun t => Eq (CategoryTheory.CategoryStruct.comp (F.map t) s) (CategoryTheory.CategoryStruct.comp (F.map t) s')","decl":"theorem Functor.Initial.exists_eq [IsCofilteredOrEmpty C] [Initial F] {d : D} {c : C}\n    (s s' : F.obj c âŸ¶ d) : âˆƒ (c' : C) (t : c' âŸ¶ c), F.map t â‰« s = F.map t â‰« s' :=\n  ((initial_iff_of_isCofiltered F).1 inferInstance).2 s s'\n\n"}
{"name":"CategoryTheory.Functor.final_iff_isFiltered_structuredArrow","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.IsFilteredOrEmpty C\nâŠ¢ Iff F.Final (âˆ€ (d : D), CategoryTheory.IsFiltered (CategoryTheory.StructuredArrow d F))","decl":"/-- If `C` is filtered, then `F : C â¥¤ D` is final if and only if `StructuredArrow d F` is filtered\n    for all `d : D`. -/\ntheorem Functor.final_iff_isFiltered_structuredArrow [IsFilteredOrEmpty C] :\n    Final F â†” âˆ€ d, IsFiltered (StructuredArrow d F) := by\n  refine âŸ¨?_, fun h => final_of_isFiltered_structuredArrow FâŸ©\n  rw [final_iff_of_isFiltered]\n  exact fun h => isFiltered_structuredArrow_of_isFiltered_of_exists F h.1 h.2\n\n"}
{"name":"CategoryTheory.Functor.initial_iff_isCofiltered_costructuredArrow","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\ninstâœ : CategoryTheory.IsCofilteredOrEmpty C\nâŠ¢ Iff F.Initial (âˆ€ (d : D), CategoryTheory.IsCofiltered (CategoryTheory.CostructuredArrow F d))","decl":"/-- If `C` is cofiltered, then `F : C â¥¤ D` is initial if and only if `CostructuredArrow F d` is\n    cofiltered for all `d : D`. -/\ntheorem Functor.initial_iff_isCofiltered_costructuredArrow [IsCofilteredOrEmpty C] :\n    Initial F â†” âˆ€ d, IsCofiltered (CostructuredArrow F d) := by\n  refine âŸ¨?_, fun h => initial_of_isCofiltered_costructuredArrow FâŸ©\n  rw [initial_iff_of_isCofiltered]\n  exact fun h => isCofiltered_costructuredArrow_of_isCofiltered_of_exists F h.1 h.2\n\n"}
{"name":"CategoryTheory.instIsFilteredStructuredArrowProdDiagOfIsFilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.IsFilteredOrEmpty C\nX : Prod C C\nâŠ¢ CategoryTheory.IsFiltered (CategoryTheory.StructuredArrow X (CategoryTheory.Functor.diag C))","decl":"/-- If `C` is filtered, then the structured arrow category on the diagonal functor `C â¥¤ C Ã— C`\nis filtered as well. -/\ninstance [IsFilteredOrEmpty C] (X : C Ã— C) : IsFiltered (StructuredArrow X (diag C)) := by\n  haveI : âˆ€ Y, IsFiltered (StructuredArrow Y (Under.forget X.1)) := by\n    rw [â† final_iff_isFiltered_structuredArrow (Under.forget X.1)]\n    infer_instance\n  apply IsFiltered.of_equivalence (StructuredArrow.ofDiagEquivalence X).symm\n\n"}
{"name":"CategoryTheory.Functor.final_diag_of_isFiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.IsFilteredOrEmpty C\nâŠ¢ (CategoryTheory.Functor.diag C).Final","decl":"/-- The diagonal functor on any filtered category is final. -/\ninstance Functor.final_diag_of_isFiltered [IsFilteredOrEmpty C] : Final (Functor.diag C) :=\n  final_of_isFiltered_structuredArrow _\n\n-- Adding this instance causes performance problems elsewhere, even with low priority\n"}
{"name":"CategoryTheory.IsFilteredOrEmpty.isSiftedOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.IsFilteredOrEmpty C\nâŠ¢ CategoryTheory.IsSiftedOrEmpty C","decl":"theorem IsFilteredOrEmpty.isSiftedOrEmpty [IsFilteredOrEmpty C] : IsSiftedOrEmpty C :=\n  Functor.final_diag_of_isFiltered\n\n-- Adding this instance causes performance problems elsewhere, even with low priority\n"}
{"name":"CategoryTheory.IsFiltered.isSifted","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.IsFiltered C\nâŠ¢ CategoryTheory.IsSifted C","decl":"attribute [local instance] IsFiltered.nonempty in\ntheorem IsFiltered.isSifted [IsFiltered C] : IsSifted C where\n\n"}
{"name":"CategoryTheory.instIsCofilteredCostructuredArrowProdDiagOfIsCofilteredOrEmpty","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.IsCofilteredOrEmpty C\nX : Prod C C\nâŠ¢ CategoryTheory.IsCofiltered (CategoryTheory.CostructuredArrow (CategoryTheory.Functor.diag C) X)","decl":"/-- If `C` is cofiltered, then the costructured arrow category on the diagonal functor `C â¥¤ C Ã— C`\nis cofiltered as well. -/\ninstance [IsCofilteredOrEmpty C] (X : C Ã— C) : IsCofiltered (CostructuredArrow (diag C) X) := by\n  haveI : âˆ€ Y, IsCofiltered (CostructuredArrow (Over.forget X.1) Y) := by\n    rw [â† initial_iff_isCofiltered_costructuredArrow (Over.forget X.1)]\n    infer_instance\n  apply IsCofiltered.of_equivalence (CostructuredArrow.ofDiagEquivalence X).symm\n\n"}
{"name":"CategoryTheory.Functor.initial_diag_of_isFiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.IsCofilteredOrEmpty C\nâŠ¢ (CategoryTheory.Functor.diag C).Initial","decl":"/-- The diagonal functor on any cofiltered category is initial. -/\ninstance Functor.initial_diag_of_isFiltered [IsCofilteredOrEmpty C] : Initial (Functor.diag C) :=\n  initial_of_isCofiltered_costructuredArrow _\n\n"}
{"name":"CategoryTheory.Functor.final_of_isFiltered_of_pUnit","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.IsFiltered C\nF : CategoryTheory.Functor C (CategoryTheory.Discrete PUnit.{u_1 + 1})\nâŠ¢ F.Final","decl":"/-- If `C` is filtered, then every functor `F : C â¥¤ Discrete PUnit` is final. -/\ntheorem Functor.final_of_isFiltered_of_pUnit [IsFiltered C] (F : C â¥¤ Discrete PUnit) :\n    Final F := by\n  refine final_of_exists_of_isFiltered F (fun _ => ?_) (fun {_} {c} _ _ => ?_)\n  Â· use Classical.choice IsFiltered.nonempty\n    exact âŸ¨Discrete.eqToHom (by simp)âŸ©\n  Â· use c; use ğŸ™ c\n    apply Subsingleton.elim\n\n"}
{"name":"CategoryTheory.Functor.initial_of_isCofiltered_pUnit","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.IsCofiltered C\nF : CategoryTheory.Functor C (CategoryTheory.Discrete PUnit.{u_1 + 1})\nâŠ¢ F.Initial","decl":"/-- If `C` is cofiltered, then every functor `F : C â¥¤ Discrete PUnit` is initial. -/\ntheorem Functor.initial_of_isCofiltered_pUnit [IsCofiltered C] (F : C â¥¤ Discrete PUnit) :\n    Initial F := by\n  refine initial_of_exists_of_isCofiltered F (fun _ => ?_) (fun {_} {c} _ _ => ?_)\n  Â· use Classical.choice IsCofiltered.nonempty\n    exact âŸ¨Discrete.eqToHom (by simp)âŸ©\n  Â· use c; use ğŸ™ c\n    apply Subsingleton.elim\n\n"}
{"name":"CategoryTheory.StructuredArrow.final_proj_of_isFiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.IsFilteredOrEmpty C\nT : CategoryTheory.Functor C D\ninstâœ : T.Final\nY : D\nâŠ¢ (CategoryTheory.StructuredArrow.proj Y T).Final","decl":"/-- The functor `StructuredArrow.proj : StructuredArrow Y T â¥¤ C` is final if `T : C â¥¤ D` is final\nand `C` is filtered. -/\ninstance StructuredArrow.final_proj_of_isFiltered [IsFilteredOrEmpty C]\n    (T : C â¥¤ D) [Final T] (Y : D) : Final (StructuredArrow.proj Y T) := by\n  refine âŸ¨fun X => ?_âŸ©\n  rw [isConnected_iff_of_equivalence (ofStructuredArrowProjEquivalence T Y X)]\n  exact (final_comp (Under.forget X) T).out _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.initial_proj_of_isCofiltered","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.IsCofilteredOrEmpty C\nT : CategoryTheory.Functor C D\ninstâœ : T.Initial\nY : D\nâŠ¢ (CategoryTheory.CostructuredArrow.proj T Y).Initial","decl":"/-- The functor `CostructuredArrow.proj : CostructuredArrow Y T â¥¤ C` is initial if `T : C â¥¤ D` is\ninitial and `C` is cofiltered. -/\ninstance CostructuredArrow.initial_proj_of_isCofiltered [IsCofilteredOrEmpty C]\n    (T : C â¥¤ D) [Initial T] (Y : D) : Initial (CostructuredArrow.proj T Y) := by\n  refine âŸ¨fun X => ?_âŸ©\n  rw [isConnected_iff_of_equivalence (ofCostructuredArrowProjEquivalence T Y X)]\n  exact (initial_comp (Over.forget X) T).out _\n\n"}
{"name":"CategoryTheory.StructuredArrow.final_mapâ‚‚_id","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâµ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâ´ : CategoryTheory.IsFiltered C\nE : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nT : CategoryTheory.Functor C D\ninstâœÂ² : T.Final\nS : CategoryTheory.Functor D E\ninstâœÂ¹ : S.Final\nT' : CategoryTheory.Functor C E\nd : D\ne : E\nu : Quiver.Hom e (S.obj d)\nÎ± : Quiver.Hom (T.comp S) T'\ninstâœ : CategoryTheory.IsIso Î±\nâŠ¢ (CategoryTheory.StructuredArrow.mapâ‚‚ u Î±).Final","decl":"/-- The functor `StructuredArrow d T â¥¤ StructuredArrow e (T â‹™ S)` that `u : e âŸ¶ S.obj d`\ninduces via `StructuredArrow.mapâ‚‚` is final, if `T` and `S` are final and the domain of `T` is\nfiltered. -/\ninstance StructuredArrow.final_mapâ‚‚_id [IsFiltered C] {E : Type uâ‚ƒ} [Category.{vâ‚ƒ} E]\n    {T : C â¥¤ D} [T.Final] {S : D â¥¤ E} [S.Final] {T' : C â¥¤ E}\n    {d : D} {e : E} (u : e âŸ¶ S.obj d) (Î± : T â‹™ S âŸ¶ T') [IsIso Î±] :\n    Final (mapâ‚‚ (F := ğŸ­ _) u Î±) := by\n  haveI : IsFiltered (StructuredArrow e (T â‹™ S)) :=\n    (T â‹™ S).final_iff_isFiltered_structuredArrow.mp inferInstance e\n  apply final_of_natIso (mapâ‚‚IsoPreEquivalenceInverseCompProj d e u Î±).symm\n\n"}
{"name":"CategoryTheory.StructuredArrow.final_map","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.IsFiltered C\nS S' : D\nf : Quiver.Hom S S'\nT : CategoryTheory.Functor C D\ninstâœ : T.Final\nâŠ¢ (CategoryTheory.StructuredArrow.map f).Final","decl":"/-- `StructuredArrow.map` is final if the functor `T` is final` and its domain is filtered. -/\ninstance StructuredArrow.final_map [IsFiltered C] {S S' : D} (f : S âŸ¶ S') (T : C â¥¤ D) [T.Final] :\n    Final (map (T := T) f) := by\n  haveI := NatIso.isIso_of_isIso_app (ğŸ™ T)\n  have : (mapâ‚‚ (F := ğŸ­ C) (G := ğŸ­ D) f (ğŸ™ T)).Final := by\n    apply StructuredArrow.final_mapâ‚‚_id (S := ğŸ­ D) (T := T) (T' := T) f (ğŸ™ T)\n  apply final_of_natIso (mapIsoMapâ‚‚ f).symm\n\n"}
{"name":"CategoryTheory.StructuredArrow.final_post","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.IsFiltered C\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nX : D\nT : CategoryTheory.Functor C D\ninstâœÂ¹ : T.Final\nS : CategoryTheory.Functor D E\ninstâœ : S.Final\nâŠ¢ (CategoryTheory.StructuredArrow.post X T S).Final","decl":"/-- `StructuredArrow.post X T S` is final if `T` and `S` are final and the domain of `T` is\nfiltered. -/\ninstance StructuredArrow.final_post [IsFiltered C] {E : Type uâ‚ƒ} [Category.{vâ‚ƒ} E] (X : D)\n    (T : C â¥¤ D) [T.Final] (S : D â¥¤ E) [S.Final] : Final (post X T S) := by\n  apply final_of_natIso (postIsoMapâ‚‚ X T S).symm\n\n"}
{"name":"CategoryTheory.CostructuredArrow.initial_mapâ‚‚_id","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.IsCofiltered C\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nT : CategoryTheory.Functor C D\ninstâœÂ¹ : T.Initial\nS : CategoryTheory.Functor D E\ninstâœ : S.Initial\nd : D\ne : E\nu : Quiver.Hom (S.obj d) e\nâŠ¢ (CategoryTheory.CostructuredArrow.mapâ‚‚ (CategoryTheory.CategoryStruct.id (T.comp S)) u).Initial","decl":"/-- The functor `CostructuredArrow T d â¥¤ CostructuredArrow (T â‹™ S) e` that `u : S.obj d âŸ¶ e`\ninduces via `CostructuredArrow.mapâ‚‚` is initial, if `T` and `S` are initial and the domain of `T` is\nfiltered. -/\ninstance CostructuredArrow.initial_mapâ‚‚_id [IsCofiltered C] {E : Type uâ‚ƒ} [Category.{vâ‚ƒ} E]\n    (T : C â¥¤ D) [T.Initial] (S : D â¥¤ E) [S.Initial] (d : D) (e : E)\n    (u : S.obj d âŸ¶ e) : Initial (mapâ‚‚ (F := ğŸ­ _) (U := T â‹™ S) (ğŸ™ (T â‹™ S)) u) := by\n  have := (T â‹™ S).initial_iff_isCofiltered_costructuredArrow.mp inferInstance e\n  apply initial_of_natIso (mapâ‚‚IsoPreEquivalenceInverseCompProj T S d e u).symm\n\n"}
{"name":"CategoryTheory.CostructuredArrow.initial_post","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.IsCofiltered C\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nX : D\nT : CategoryTheory.Functor C D\ninstâœÂ¹ : T.Initial\nS : CategoryTheory.Functor D E\ninstâœ : S.Initial\nâŠ¢ (CategoryTheory.CostructuredArrow.post T S X).Initial","decl":"/-- `CostructuredArrow.post T S X` is initial if `T` and `S` are initial and the domain of `T` is\ncofiltered. -/\ninstance CostructuredArrow.initial_post [IsCofiltered C] {E : Type uâ‚ƒ} [Category.{vâ‚ƒ} E] (X : D)\n    (T : C â¥¤ D) [T.Initial] (S : D â¥¤ E) [S.Initial] : Initial (post T S X) := by\n  apply initial_of_natIso (postIsoMapâ‚‚ X T S).symm\n\n"}
{"name":"CategoryTheory.final_eval","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"Î± : Type uâ‚\nI : Î± â†’ Type uâ‚‚\ninstâœÂ¹ : (s : Î±) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (I s)\ninstâœ : âˆ€ (s : Î±), CategoryTheory.IsFiltered (I s)\ns : Î±\nâŠ¢ (CategoryTheory.Pi.eval I s).Final","decl":"open IsFiltered in\ninstance final_eval [âˆ€ s, IsFiltered (I s)] (s : Î±) : (Pi.eval I s).Final := by\n  classical\n  apply Functor.final_of_exists_of_isFiltered\n  Â· exact fun i => âŸ¨Function.update (fun t => nonempty.some) s i, âŸ¨by simpa using ğŸ™ _âŸ©âŸ©\n  Â· intro d c f g\n    let c't : (âˆ€ s, (c' : I s) Ã— (c s âŸ¶ c')) := Function.update (fun t => âŸ¨c t, ğŸ™ (c t)âŸ©)\n      s âŸ¨coeq f g, coeqHom f gâŸ©\n    refine âŸ¨fun t => (c't t).1, fun t => (c't t).2, ?_âŸ©\n    dsimp only [Pi.eval_obj, Pi.eval_map, c't]\n    rw [Function.update_self]\n    simpa using coeq_condition _ _\n\n"}
{"name":"CategoryTheory.initial_eval","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"Î± : Type uâ‚\nI : Î± â†’ Type uâ‚‚\ninstâœÂ¹ : (s : Î±) â†’ CategoryTheory.Category.{vâ‚‚, uâ‚‚} (I s)\ninstâœ : âˆ€ (s : Î±), CategoryTheory.IsCofiltered (I s)\ns : Î±\nâŠ¢ (CategoryTheory.Pi.eval I s).Initial","decl":"open IsCofiltered in\ninstance initial_eval [âˆ€ s, IsCofiltered (I s)] (s : Î±) : (Pi.eval I s).Initial := by\n  classical\n  apply Functor.initial_of_exists_of_isCofiltered\n  Â· exact fun i => âŸ¨Function.update (fun t => nonempty.some) s i, âŸ¨by simpa using ğŸ™ _âŸ©âŸ©\n  Â· intro d c f g\n    let c't : (âˆ€ s, (c' : I s) Ã— (c' âŸ¶ c s)) := Function.update (fun t => âŸ¨c t, ğŸ™ (c t)âŸ©)\n      s âŸ¨eq f g, eqHom f gâŸ©\n    refine âŸ¨fun t => (c't t).1, fun t => (c't t).2, ?_âŸ©\n    dsimp only [Pi.eval_obj, Pi.eval_map, c't]\n    rw [Function.update_self]\n    simpa using eq_condition _ _\n\n"}
{"name":"CategoryTheory.final_fst","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.IsFilteredOrEmpty C\ninstâœ : CategoryTheory.IsFiltered D\nâŠ¢ (CategoryTheory.Prod.fst C D).Final","decl":"open IsFiltered in\ninstance final_fst [IsFilteredOrEmpty C] [IsFiltered D] : (Prod.fst C D).Final := by\n  apply Functor.final_of_exists_of_isFiltered\n  Â· exact fun c => âŸ¨(c, nonempty.some), âŸ¨ğŸ™ câŸ©âŸ©\n  Â· intro c âŸ¨c', d'âŸ© f g\n    exact âŸ¨(coeq f g, d'), (coeqHom f g, ğŸ™ d'), coeq_condition _ _âŸ©\n\n"}
{"name":"CategoryTheory.final_snd","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.IsFiltered C\ninstâœ : CategoryTheory.IsFilteredOrEmpty D\nâŠ¢ (CategoryTheory.Prod.snd C D).Final","decl":"instance final_snd [IsFiltered C] [IsFilteredOrEmpty D] : (Prod.snd C D).Final :=\n  inferInstanceAs ((Prod.braiding C D).functor â‹™ Prod.fst D C).Final\n\n"}
{"name":"CategoryTheory.initial_fst","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.IsCofilteredOrEmpty C\ninstâœ : CategoryTheory.IsCofiltered D\nâŠ¢ (CategoryTheory.Prod.fst C D).Initial","decl":"open IsCofiltered in\ninstance initial_fst [IsCofilteredOrEmpty C] [IsCofiltered D] : (Prod.fst C D).Initial := by\n  apply Functor.initial_of_exists_of_isCofiltered\n  Â· exact fun c => âŸ¨(c, nonempty.some), âŸ¨ğŸ™ câŸ©âŸ©\n  Â· intro c âŸ¨c', d'âŸ© f g\n    exact âŸ¨(eq f g, d'), (eqHom f g, ğŸ™ d'), eq_condition _ _âŸ©\n\n"}
{"name":"CategoryTheory.initial_snd","module":"Mathlib.CategoryTheory.Filtered.Final","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ¹ : CategoryTheory.IsCofiltered C\ninstâœ : CategoryTheory.IsCofilteredOrEmpty D\nâŠ¢ (CategoryTheory.Prod.snd C D).Initial","decl":"instance initial_snd [IsCofiltered C] [IsCofilteredOrEmpty D] : (Prod.snd C D).Initial :=\n  inferInstanceAs ((Prod.braiding C D).functor â‹™ Prod.fst D C).Initial\n\n"}
