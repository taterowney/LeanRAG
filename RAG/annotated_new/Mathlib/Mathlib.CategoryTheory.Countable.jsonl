{"name":"CategoryTheory.discreteCountable","module":"Mathlib.CategoryTheory.Countable","initialProofState":"α : Type u_1\ninst✝ : Countable α\n⊢ Countable (CategoryTheory.Discrete α)","decl":"instance discreteCountable {α : Type*} [Countable α] : Countable (Discrete α) :=\n  Countable.of_equiv α discreteEquiv.symm\n\n"}
{"name":"CategoryTheory.CountableCategory.countableHom","module":"Mathlib.CategoryTheory.Countable","initialProofState":"J : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} J\nself : CategoryTheory.CountableCategory J\nj j' : J\n⊢ Countable (Quiver.Hom j j')","decl":"/-- A category with countably many objects and morphisms. -/\nclass CountableCategory (J : Type*) [Category J] : Prop where\n  countableObj : Countable J := by infer_instance\n  countableHom : ∀ j j' : J, Countable (j ⟶ j') := by infer_instance\n\n"}
{"name":"CategoryTheory.CountableCategory.countableObj","module":"Mathlib.CategoryTheory.Countable","initialProofState":"J : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} J\nself : CategoryTheory.CountableCategory J\n⊢ Countable J","decl":"/-- A category with countably many objects and morphisms. -/\nclass CountableCategory (J : Type*) [Category J] : Prop where\n  countableObj : Countable J := by infer_instance\n  countableHom : ∀ j j' : J, Countable (j ⟶ j') := by infer_instance\n\n"}
{"name":"CategoryTheory.countablerCategoryDiscreteOfCountable","module":"Mathlib.CategoryTheory.Countable","initialProofState":"J : Type u_1\ninst✝ : Countable J\n⊢ CategoryTheory.CountableCategory (CategoryTheory.Discrete J)","decl":"instance countablerCategoryDiscreteOfCountable (J : Type*) [Countable J] :\n    CountableCategory (Discrete J) where\n\n"}
{"name":"CategoryTheory.instCountableCategoryNat","module":"Mathlib.CategoryTheory.Countable","initialProofState":"⊢ CategoryTheory.CountableCategory Nat","decl":"instance : CountableCategory ℕ where\n\n"}
{"name":"CategoryTheory.CountableCategory.instCountableObjAsType","module":"Mathlib.CategoryTheory.Countable","initialProofState":"α : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} α\ninst✝ : CategoryTheory.CountableCategory α\n⊢ Countable (CategoryTheory.CountableCategory.ObjAsType α)","decl":"instance : Countable (ObjAsType α) := Countable.of_equiv α (equivShrink.{0} α)\n\n"}
{"name":"CategoryTheory.CountableCategory.instCountableHomObjAsType","module":"Mathlib.CategoryTheory.Countable","initialProofState":"α : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} α\ninst✝ : CategoryTheory.CountableCategory α\ni j : CategoryTheory.CountableCategory.ObjAsType α\n⊢ Countable (Quiver.Hom i j)","decl":"instance {i j : ObjAsType α} : Countable (i ⟶ j) :=\n  CountableCategory.countableHom ((equivShrink.{0} α).symm i) _\n\n"}
{"name":"CategoryTheory.CountableCategory.instObjAsType","module":"Mathlib.CategoryTheory.Countable","initialProofState":"α : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} α\ninst✝ : CategoryTheory.CountableCategory α\n⊢ CategoryTheory.CountableCategory (CategoryTheory.CountableCategory.ObjAsType α)","decl":"instance : CountableCategory (ObjAsType α) where\n\n"}
{"name":"CategoryTheory.CountableCategory.instLocallySmallObjAsType","module":"Mathlib.CategoryTheory.Countable","initialProofState":"α : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} α\ninst✝ : CategoryTheory.CountableCategory α\n⊢ CategoryTheory.LocallySmall.{0, v, 0} (CategoryTheory.CountableCategory.ObjAsType α)","decl":"instance : LocallySmall.{0} (ObjAsType α) where\n  hom_small _ _ := inferInstance\n\n"}
{"name":"CategoryTheory.CountableCategory.instCountableHomAsType","module":"Mathlib.CategoryTheory.Countable","initialProofState":"α : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} α\ninst✝ : CategoryTheory.CountableCategory α\n⊢ Countable (CategoryTheory.CountableCategory.HomAsType α)","decl":"instance : Countable (HomAsType α) := Countable.of_equiv α (equivShrink.{0} α)\n\n"}
{"name":"CategoryTheory.CountableCategory.instCountableHomHomAsType","module":"Mathlib.CategoryTheory.Countable","initialProofState":"α : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} α\ninst✝ : CategoryTheory.CountableCategory α\ni j : CategoryTheory.CountableCategory.HomAsType α\n⊢ Countable (Quiver.Hom i j)","decl":"instance {i j : HomAsType α} : Countable (i ⟶ j) :=\n  Countable.of_equiv ((ShrinkHoms.equivalence _).inverse.obj i ⟶\n    (ShrinkHoms.equivalence _).inverse.obj j)\n    (Functor.FullyFaithful.ofFullyFaithful _).homEquiv.symm\n\n"}
{"name":"CategoryTheory.CountableCategory.instHomAsType","module":"Mathlib.CategoryTheory.Countable","initialProofState":"α : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} α\ninst✝ : CategoryTheory.CountableCategory α\n⊢ CategoryTheory.CountableCategory (CategoryTheory.CountableCategory.HomAsType α)","decl":"instance : CountableCategory (HomAsType α) where\n\n"}
{"name":"CategoryTheory.instCountableCategoryOfFinCategory","module":"Mathlib.CategoryTheory.Countable","initialProofState":"α : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_1, u_1} α\ninst✝ : CategoryTheory.FinCategory α\n⊢ CategoryTheory.CountableCategory α","decl":"instance (α : Type*) [Category α] [FinCategory α] : CountableCategory α where\n\n"}
{"name":"CategoryTheory.instCountableCategoryNat_1","module":"Mathlib.CategoryTheory.Countable","initialProofState":"⊢ CategoryTheory.CountableCategory Nat","decl":"instance : CountableCategory ℕ where\n\n"}
{"name":"CategoryTheory.countableCategoryOpposite","module":"Mathlib.CategoryTheory.Countable","initialProofState":"J : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} J\ninst✝ : CategoryTheory.CountableCategory J\n⊢ CategoryTheory.CountableCategory (Opposite J)","decl":"/-- The opposite of a countable category is countable. -/\ninstance countableCategoryOpposite {J : Type*} [Category J] [CountableCategory J] :\n    CountableCategory Jᵒᵖ where\n  countableObj := Countable.of_equiv _ equivToOpposite\n  countableHom j j' := Countable.of_equiv _ (opEquiv j j').symm\n\n"}
{"name":"CategoryTheory.countableCategoryUlift","module":"Mathlib.CategoryTheory.Countable","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{u_1, v} J\ninst✝ : CategoryTheory.CountableCategory J\n⊢ CategoryTheory.CountableCategory (CategoryTheory.ULiftHom (ULift.{w, v} J))","decl":"/-- Applying `ULift` to morphisms and objects of a category preserves countability. -/\ninstance countableCategoryUlift {J : Type v} [Category J] [CountableCategory J] :\n    CountableCategory.{max w v} (ULiftHom.{w, max w v} (ULift.{w, v} J)) where\n  countableObj := instCountableULift\n  countableHom := fun i j =>\n    have : Countable ((ULiftHom.objDown i).down ⟶ (ULiftHom.objDown j).down) := inferInstance\n    instCountableULift\n\n"}
