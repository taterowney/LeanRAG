{"name":"Finsupp.add_closure_setOf_eq_single","module":"Mathlib.Data.Finsupp.Ext","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : AddZeroClass M\n⊢ Eq (AddSubmonoid.closure (setOf fun f => Exists fun a => Exists fun b => Eq f (Finsupp.single a b))) Top.top","decl":"@[simp]\ntheorem add_closure_setOf_eq_single :\n    AddSubmonoid.closure { f : α →₀ M | ∃ a b, f = single a b } = ⊤ :=\n  top_unique fun x _hx =>\n    Finsupp.induction x (AddSubmonoid.zero_mem _) fun a b _f _ha _hb hf =>\n      AddSubmonoid.add_mem _ (AddSubmonoid.subset_closure <| ⟨a, b, rfl⟩) hf\n\n"}
{"name":"Finsupp.addHom_ext","module":"Mathlib.Data.Finsupp.Ext","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf g : AddMonoidHom (Finsupp α M) N\nH : ∀ (x : α) (y : M), Eq (f (Finsupp.single x y)) (g (Finsupp.single x y))\n⊢ Eq f g","decl":"/-- If two additive homomorphisms from `α →₀ M` are equal on each `single a b`,\nthen they are equal. -/\ntheorem addHom_ext [AddZeroClass N] ⦃f g : (α →₀ M) →+ N⦄\n    (H : ∀ x y, f (single x y) = g (single x y)) : f = g := by\n  refine AddMonoidHom.eq_of_eqOn_denseM add_closure_setOf_eq_single ?_\n  rintro _ ⟨x, y, rfl⟩\n  apply H\n\n"}
{"name":"Finsupp.addHom_ext'_iff","module":"Mathlib.Data.Finsupp.Ext","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf g : AddMonoidHom (Finsupp α M) N\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f.comp (Finsupp.singleAddHom x)) (g.comp (Finsupp.singleAddHom x)))","decl":"/-- If two additive homomorphisms from `α →₀ M` are equal on each `single a b`,\nthen they are equal.\n\nWe formulate this using equality of `AddMonoidHom`s so that `ext` tactic can apply a type-specific\nextensionality lemma after this one.  E.g., if the fiber `M` is `ℕ` or `ℤ`, then it suffices to\nverify `f (single a 1) = g (single a 1)`. -/\n@[ext high]\ntheorem addHom_ext' [AddZeroClass N] ⦃f g : (α →₀ M) →+ N⦄\n    (H : ∀ x, f.comp (singleAddHom x) = g.comp (singleAddHom x)) : f = g :=\n  addHom_ext fun x => DFunLike.congr_fun (H x)\n\n"}
{"name":"Finsupp.addHom_ext'","module":"Mathlib.Data.Finsupp.Ext","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf g : AddMonoidHom (Finsupp α M) N\nH : ∀ (x : α), Eq (f.comp (Finsupp.singleAddHom x)) (g.comp (Finsupp.singleAddHom x))\n⊢ Eq f g","decl":"/-- If two additive homomorphisms from `α →₀ M` are equal on each `single a b`,\nthen they are equal.\n\nWe formulate this using equality of `AddMonoidHom`s so that `ext` tactic can apply a type-specific\nextensionality lemma after this one.  E.g., if the fiber `M` is `ℕ` or `ℤ`, then it suffices to\nverify `f (single a 1) = g (single a 1)`. -/\n@[ext high]\ntheorem addHom_ext' [AddZeroClass N] ⦃f g : (α →₀ M) →+ N⦄\n    (H : ∀ x, f.comp (singleAddHom x) = g.comp (singleAddHom x)) : f = g :=\n  addHom_ext fun x => DFunLike.congr_fun (H x)\n\n"}
{"name":"Finsupp.mulHom_ext","module":"Mathlib.Data.Finsupp.Ext","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : MulOneClass N\nf g : MonoidHom (Multiplicative (Finsupp α M)) N\nH : ∀ (x : α) (y : M), Eq (f (Multiplicative.ofAdd (Finsupp.single x y))) (g (Multiplicative.ofAdd (Finsupp.single x y)))\n⊢ Eq f g","decl":"theorem mulHom_ext [MulOneClass N] ⦃f g : Multiplicative (α →₀ M) →* N⦄\n    (H : ∀ x y, f (Multiplicative.ofAdd <| single x y) = g (Multiplicative.ofAdd <| single x y)) :\n    f = g :=\n  MonoidHom.ext <|\n    DFunLike.congr_fun <| by\n      have := @addHom_ext α M (Additive N) _ _\n        (MonoidHom.toAdditive'' f) (MonoidHom.toAdditive'' g) H\n      ext\n      rw [DFunLike.ext_iff] at this\n      apply this\n\n"}
{"name":"Finsupp.mulHom_ext'","module":"Mathlib.Data.Finsupp.Ext","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : MulOneClass N\nf g : MonoidHom (Multiplicative (Finsupp α M)) N\nH : ∀ (x : α), Eq (f.comp (AddMonoidHom.toMultiplicative (Finsupp.singleAddHom x))) (g.comp (AddMonoidHom.toMultiplicative (Finsupp.singleAddHom x)))\n⊢ Eq f g","decl":"@[ext]\ntheorem mulHom_ext' [MulOneClass N] {f g : Multiplicative (α →₀ M) →* N}\n    (H : ∀ x, f.comp (AddMonoidHom.toMultiplicative (singleAddHom x)) =\n              g.comp (AddMonoidHom.toMultiplicative (singleAddHom x))) :\n    f = g :=\n  mulHom_ext fun x => DFunLike.congr_fun (H x)\n\n"}
{"name":"Finsupp.mulHom_ext'_iff","module":"Mathlib.Data.Finsupp.Ext","initialProofState":"α : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : MulOneClass N\nf g : MonoidHom (Multiplicative (Finsupp α M)) N\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f.comp (AddMonoidHom.toMultiplicative (Finsupp.singleAddHom x))) (g.comp (AddMonoidHom.toMultiplicative (Finsupp.singleAddHom x))))","decl":"@[ext]\ntheorem mulHom_ext' [MulOneClass N] {f g : Multiplicative (α →₀ M) →* N}\n    (H : ∀ x, f.comp (AddMonoidHom.toMultiplicative (singleAddHom x)) =\n              g.comp (AddMonoidHom.toMultiplicative (singleAddHom x))) :\n    f = g :=\n  mulHom_ext fun x => DFunLike.congr_fun (H x)\n\n"}
