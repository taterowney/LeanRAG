{"name":"SMulMemClass.smul_mem","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u_1\nR : outParam (Type u_2)\nM : Type u_3\ninst✝¹ : SMul R M\ninst✝ : SetLike S M\nself : SMulMemClass S R M\ns : S\nr : R\nm : M\na✝ : Membership.mem s m\n⊢ Membership.mem s (HSMul.hSMul r m)","decl":"/-- `SMulMemClass S R M` says `S` is a type of subsets `s ≤ M` that are closed under the\nscalar action of `R` on `M`.\n\nNote that only `R` is marked as an `outParam` here, since `M` is supplied by the `SetLike`\nclass instead.\n-/\nclass SMulMemClass (S : Type*) (R : outParam Type*) (M : Type*) [SMul R M] [SetLike S M] :\n    Prop where\n  /-- Multiplication by a scalar on an element of the set remains in the set. -/\n  smul_mem : ∀ {s : S} (r : R) {m : M}, m ∈ s → r • m ∈ s\n\n"}
{"name":"VAddMemClass.vadd_mem","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u_1\nR : outParam (Type u_2)\nM : Type u_3\ninst✝¹ : VAdd R M\ninst✝ : SetLike S M\nself : VAddMemClass S R M\ns : S\nr : R\nm : M\na✝ : Membership.mem s m\n⊢ Membership.mem s (HVAdd.hVAdd r m)","decl":"/-- `VAddMemClass S R M` says `S` is a type of subsets `s ≤ M` that are closed under the\nadditive action of `R` on `M`.\n\nNote that only `R` is marked as an `outParam` here, since `M` is supplied by the `SetLike`\nclass instead. -/\nclass VAddMemClass (S : Type*) (R : outParam Type*) (M : Type*) [VAdd R M] [SetLike S M] :\n    Prop where\n  /-- Addition by a scalar with an element of the set remains in the set. -/\n  vadd_mem : ∀ {s : S} (r : R) {m : M}, m ∈ s → r +ᵥ m ∈ s\n\n"}
{"name":"AddSubmonoidClass.nsmulMemClass","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u_1\nM : Type u_2\ninst✝² : AddMonoid M\ninst✝¹ : SetLike S M\ninst✝ : AddSubmonoidClass S M\n⊢ SMulMemClass S Nat M","decl":"/-- Not registered as an instance because `R` is an `outParam` in `SMulMemClass S R M`. -/\nlemma AddSubmonoidClass.nsmulMemClass {S M : Type*} [AddMonoid M] [SetLike S M]\n    [AddSubmonoidClass S M] : SMulMemClass S ℕ M where\n  smul_mem n _x hx := nsmul_mem hx n\n\n"}
{"name":"AddSubgroupClass.zsmulMemClass","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u_1\nM : Type u_2\ninst✝² : SubNegMonoid M\ninst✝¹ : SetLike S M\ninst✝ : AddSubgroupClass S M\n⊢ SMulMemClass S Int M","decl":"/-- Not registered as an instance because `R` is an `outParam` in `SMulMemClass S R M`. -/\nlemma AddSubgroupClass.zsmulMemClass {S M : Type*} [SubNegMonoid M] [SetLike S M]\n    [AddSubgroupClass S M] : SMulMemClass S ℤ M where\n  smul_mem n _x hx := zsmul_mem hx n\n\n"}
{"name":"SMulMemClass.ofIsScalarTower","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u_1\nM : Type u_2\nN : Type u_3\nα : Type u_4\ninst✝⁶ : SetLike S α\ninst✝⁵ : SMul M N\ninst✝⁴ : SMul M α\ninst✝³ : Monoid N\ninst✝² : MulAction N α\ninst✝¹ : SMulMemClass S N α\ninst✝ : IsScalarTower M N α\n⊢ SMulMemClass S M α","decl":"/-- This can't be an instance because Lean wouldn't know how to find `N`, but we can still use\nthis to manually derive `SMulMemClass` on specific types. -/\ntheorem _root_.SMulMemClass.ofIsScalarTower (S M N α : Type*) [SetLike S α] [SMul M N]\n    [SMul M α] [Monoid N] [MulAction N α] [SMulMemClass S N α] [IsScalarTower M N α] :\n    SMulMemClass S M α :=\n  { smul_mem := fun m a ha => smul_one_smul N m a ▸ SMulMemClass.smul_mem _ ha }\n\n"}
{"name":"SetLike.instIsScalarTower","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁴ : SMul R M\ninst✝³ : SetLike S M\nhS : SMulMemClass S R M\ninst✝² : Mul M\ninst✝¹ : MulMemClass S M\ninst✝ : IsScalarTower R M M\ns : S\n⊢ IsScalarTower R (Subtype fun x => Membership.mem s x) (Subtype fun x => Membership.mem s x)","decl":"instance instIsScalarTower [Mul M] [MulMemClass S M] [IsScalarTower R M M]\n    (s : S) : IsScalarTower R s s where\n  smul_assoc r x y := Subtype.ext <| smul_assoc r (x : M) (y : M)\n\n"}
{"name":"SetLike.instSMulCommClass","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁴ : SMul R M\ninst✝³ : SetLike S M\nhS : SMulMemClass S R M\ninst✝² : Mul M\ninst✝¹ : MulMemClass S M\ninst✝ : SMulCommClass R M M\ns : S\n⊢ SMulCommClass R (Subtype fun x => Membership.mem s x) (Subtype fun x => Membership.mem s x)","decl":"instance instSMulCommClass [Mul M] [MulMemClass S M] [SMulCommClass R M M]\n    (s : S) : SMulCommClass R s s where\n  smul_comm r x y := Subtype.ext <| smul_comm r (x : M) (y : M)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO lower priority not actually there\n-- lower priority so later simp lemmas are used first; to appease simp_nf\n"}
{"name":"SetLike.val_vadd","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝¹ : VAdd R M\ninst✝ : SetLike S M\nhS : VAddMemClass S R M\ns : S\nr : R\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(HVAdd.hVAdd r x)) (HVAdd.hVAdd r ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\nprotected theorem val_smul (r : R) (x : s) : (↑(r • x) : M) = r • (x : M) :=\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO lower priority not actually there\n-- lower priority so later simp lemmas are used first; to appease simp_nf\n"}
{"name":"SetLike.val_smul","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝¹ : SMul R M\ninst✝ : SetLike S M\nhS : SMulMemClass S R M\ns : S\nr : R\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(HSMul.hSMul r x)) (HSMul.hSMul r ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\nprotected theorem val_smul (r : R) (x : s) : (↑(r • x) : M) = r • (x : M) :=\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO lower priority not actually there\n-- lower priority so later simp lemmas are used first; to appease simp_nf\n"}
{"name":"SetLike.mk_smul_mk","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝¹ : SMul R M\ninst✝ : SetLike S M\nhS : SMulMemClass S R M\ns : S\nr : R\nx : M\nhx : Membership.mem s x\n⊢ Eq (HSMul.hSMul r ⟨x, hx⟩) ⟨HSMul.hSMul r x, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem mk_smul_mk (r : R) (x : M) (hx : x ∈ s) : r • (⟨x, hx⟩ : s) = ⟨r • x, smul_mem r hx⟩ :=\n  rfl\n\n"}
{"name":"SetLike.mk_vadd_mk","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝¹ : VAdd R M\ninst✝ : SetLike S M\nhS : VAddMemClass S R M\ns : S\nr : R\nx : M\nhx : Membership.mem s x\n⊢ Eq (HVAdd.hVAdd r ⟨x, hx⟩) ⟨HVAdd.hVAdd r x, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem mk_smul_mk (r : R) (x : M) (hx : x ∈ s) : r • (⟨x, hx⟩ : s) = ⟨r • x, smul_mem r hx⟩ :=\n  rfl\n\n"}
{"name":"SetLike.vadd_def","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝¹ : VAdd R M\ninst✝ : SetLike S M\nhS : VAddMemClass S R M\ns : S\nr : R\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (HVAdd.hVAdd r x) ⟨HVAdd.hVAdd r ↑x, ⋯⟩","decl":"@[to_additive]\ntheorem smul_def (r : R) (x : s) : r • x = ⟨r • x, smul_mem r x.2⟩ :=\n  rfl\n\n"}
{"name":"SetLike.smul_def","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝¹ : SMul R M\ninst✝ : SetLike S M\nhS : SMulMemClass S R M\ns : S\nr : R\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (HSMul.hSMul r x) ⟨HSMul.hSMul r ↑x, ⋯⟩","decl":"@[to_additive]\ntheorem smul_def (r : R) (x : s) : r • x = ⟨r • x, smul_mem r x.2⟩ :=\n  rfl\n\n"}
{"name":"SetLike.forall_smul_mem_iff","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u_1\nM : Type u_2\nS : Type u_3\ninst✝³ : Monoid R\ninst✝² : MulAction R M\ninst✝¹ : SetLike S M\ninst✝ : SMulMemClass S R M\nN : S\nx : M\n⊢ Iff (∀ (a : R), Membership.mem N (HSMul.hSMul a x)) (Membership.mem N x)","decl":"@[simp]\ntheorem forall_smul_mem_iff {R M S : Type*} [Monoid R] [MulAction R M] [SetLike S M]\n    [SMulMemClass S R M] {N : S} {x : M} : (∀ a : R, a • x ∈ N) ↔ x ∈ N :=\n  ⟨fun h => by simpa using h 1, fun h a => SMulMemClass.smul_mem a h⟩\n\n"}
{"name":"SetLike.val_smul_of_tower","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nM : Type v\nN : Type u_1\nα : Type u_2\ninst✝⁶ : SetLike S α\ninst✝⁵ : SMul M N\ninst✝⁴ : SMul M α\ninst✝³ : Monoid N\ninst✝² : MulAction N α\ninst✝¹ : SMulMemClass S N α\ninst✝ : IsScalarTower M N α\ns : S\nr : M\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(HSMul.hSMul r x)) (HSMul.hSMul r ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\nprotected theorem val_smul_of_tower (r : M) (x : s) : (↑(r • x) : α) = r • (x : α) :=\n  rfl\n\n"}
{"name":"SetLike.val_vadd_of_tower","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nM : Type v\nN : Type u_1\nα : Type u_2\ninst✝⁶ : SetLike S α\ninst✝⁵ : VAdd M N\ninst✝⁴ : VAdd M α\ninst✝³ : AddMonoid N\ninst✝² : AddAction N α\ninst✝¹ : VAddMemClass S N α\ninst✝ : VAddAssocClass M N α\ns : S\nr : M\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(HVAdd.hVAdd r x)) (HVAdd.hVAdd r ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\nprotected theorem val_smul_of_tower (r : M) (x : s) : (↑(r • x) : α) = r • (x : α) :=\n  rfl\n\n"}
{"name":"SetLike.mk_smul_of_tower_mk","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nM : Type v\nN : Type u_1\nα : Type u_2\ninst✝⁶ : SetLike S α\ninst✝⁵ : SMul M N\ninst✝⁴ : SMul M α\ninst✝³ : Monoid N\ninst✝² : MulAction N α\ninst✝¹ : SMulMemClass S N α\ninst✝ : IsScalarTower M N α\ns : S\nr : M\nx : α\nhx : Membership.mem s x\n⊢ Eq (HSMul.hSMul r ⟨x, hx⟩) ⟨HSMul.hSMul r x, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem mk_smul_of_tower_mk (r : M) (x : α) (hx : x ∈ s) :\n    r • (⟨x, hx⟩ : s) = ⟨r • x, smul_one_smul N r x ▸ smul_mem _ hx⟩ :=\n  rfl\n\n"}
{"name":"SetLike.mk_vadd_of_tower_mk","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nM : Type v\nN : Type u_1\nα : Type u_2\ninst✝⁶ : SetLike S α\ninst✝⁵ : VAdd M N\ninst✝⁴ : VAdd M α\ninst✝³ : AddMonoid N\ninst✝² : AddAction N α\ninst✝¹ : VAddMemClass S N α\ninst✝ : VAddAssocClass M N α\ns : S\nr : M\nx : α\nhx : Membership.mem s x\n⊢ Eq (HVAdd.hVAdd r ⟨x, hx⟩) ⟨HVAdd.hVAdd r x, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem mk_smul_of_tower_mk (r : M) (x : α) (hx : x ∈ s) :\n    r • (⟨x, hx⟩ : s) = ⟨r • x, smul_one_smul N r x ▸ smul_mem _ hx⟩ :=\n  rfl\n\n"}
{"name":"SetLike.smul_of_tower_def","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nM : Type v\nN : Type u_1\nα : Type u_2\ninst✝⁶ : SetLike S α\ninst✝⁵ : SMul M N\ninst✝⁴ : SMul M α\ninst✝³ : Monoid N\ninst✝² : MulAction N α\ninst✝¹ : SMulMemClass S N α\ninst✝ : IsScalarTower M N α\ns : S\nr : M\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (HSMul.hSMul r x) ⟨HSMul.hSMul r ↑x, ⋯⟩","decl":"@[to_additive]\ntheorem smul_of_tower_def (r : M) (x : s) :\n    r • x = ⟨r • x, smul_one_smul N r x.1 ▸ smul_mem _ x.2⟩ :=\n  rfl\n\n"}
{"name":"SetLike.vadd_of_tower_def","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nM : Type v\nN : Type u_1\nα : Type u_2\ninst✝⁶ : SetLike S α\ninst✝⁵ : VAdd M N\ninst✝⁴ : VAdd M α\ninst✝³ : AddMonoid N\ninst✝² : AddAction N α\ninst✝¹ : VAddMemClass S N α\ninst✝ : VAddAssocClass M N α\ns : S\nr : M\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (HVAdd.hVAdd r x) ⟨HVAdd.hVAdd r ↑x, ⋯⟩","decl":"@[to_additive]\ntheorem smul_of_tower_def (r : M) (x : s) :\n    r • x = ⟨r • x, smul_one_smul N r x.1 ▸ smul_mem _ x.2⟩ :=\n  rfl\n\n"}
{"name":"SubAddAction.vadd_mem'","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\nself : SubAddAction R M\nc : R\nx : M\na✝ : Membership.mem self.carrier x\n⊢ Membership.mem self.carrier (HVAdd.hVAdd c x)","decl":"/-- A SubAddAction is a set which is closed under scalar multiplication. -/\nstructure SubAddAction (R : Type u) (M : Type v) [VAdd R M] : Type v where\n  /-- The underlying set of a `SubAddAction`. -/\n  carrier : Set M\n  /-- The carrier set is closed under scalar multiplication. -/\n  vadd_mem' : ∀ (c : R) {x : M}, x ∈ carrier → c +ᵥ x ∈ carrier\n\n"}
{"name":"SubAddAction.mk.inj","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\ncarrier✝ : Set M\nvadd_mem'✝ : ∀ (c : R) {x : M}, Membership.mem carrier✝ x → Membership.mem carrier✝ (HVAdd.hVAdd c x)\ncarrier : Set M\nvadd_mem' : ∀ (c : R) {x : M}, Membership.mem carrier x → Membership.mem carrier (HVAdd.hVAdd c x)\nx✝ : Eq { carrier := carrier✝, vadd_mem' := vadd_mem'✝ } { carrier := carrier, vadd_mem' := vadd_mem' }\n⊢ Eq carrier✝ carrier","decl":"/-- A SubAddAction is a set which is closed under scalar multiplication. -/\nstructure SubAddAction (R : Type u) (M : Type v) [VAdd R M] : Type v where\n  /-- The underlying set of a `SubAddAction`. -/\n  carrier : Set M\n  /-- The carrier set is closed under scalar multiplication. -/\n  vadd_mem' : ∀ (c : R) {x : M}, x ∈ carrier → c +ᵥ x ∈ carrier\n\n"}
{"name":"SubAddAction.mk.injEq","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\ncarrier✝ : Set M\nvadd_mem'✝ : ∀ (c : R) {x : M}, Membership.mem carrier✝ x → Membership.mem carrier✝ (HVAdd.hVAdd c x)\ncarrier : Set M\nvadd_mem' : ∀ (c : R) {x : M}, Membership.mem carrier x → Membership.mem carrier (HVAdd.hVAdd c x)\n⊢ Eq (Eq { carrier := carrier✝, vadd_mem' := vadd_mem'✝ } { carrier := carrier, vadd_mem' := vadd_mem' }) (Eq carrier✝ carrier)","decl":"/-- A SubAddAction is a set which is closed under scalar multiplication. -/\nstructure SubAddAction (R : Type u) (M : Type v) [VAdd R M] : Type v where\n  /-- The underlying set of a `SubAddAction`. -/\n  carrier : Set M\n  /-- The carrier set is closed under scalar multiplication. -/\n  vadd_mem' : ∀ (c : R) {x : M}, x ∈ carrier → c +ᵥ x ∈ carrier\n\n"}
{"name":"SubAddAction.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝² : VAdd R M\ninst✝¹ : SizeOf R\ninst✝ : SizeOf M\ncarrier : Set M\nvadd_mem' : ∀ (c : R) {x : M}, Membership.mem carrier x → Membership.mem carrier (HVAdd.hVAdd c x)\n⊢ Eq (SizeOf.sizeOf { carrier := carrier, vadd_mem' := vadd_mem' }) 1","decl":"/-- A SubAddAction is a set which is closed under scalar multiplication. -/\nstructure SubAddAction (R : Type u) (M : Type v) [VAdd R M] : Type v where\n  /-- The underlying set of a `SubAddAction`. -/\n  carrier : Set M\n  /-- The carrier set is closed under scalar multiplication. -/\n  vadd_mem' : ∀ (c : R) {x : M}, x ∈ carrier → c +ᵥ x ∈ carrier\n\n"}
{"name":"SubMulAction.smul_mem'","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\nself : SubMulAction R M\nc : R\nx : M\na✝ : Membership.mem self.carrier x\n⊢ Membership.mem self.carrier (HSMul.hSMul c x)","decl":"/-- A SubMulAction is a set which is closed under scalar multiplication. -/\n@[to_additive]\nstructure SubMulAction (R : Type u) (M : Type v) [SMul R M] : Type v where\n  /-- The underlying set of a `SubMulAction`. -/\n  carrier : Set M\n  /-- The carrier set is closed under scalar multiplication. -/\n  smul_mem' : ∀ (c : R) {x : M}, x ∈ carrier → c • x ∈ carrier\n\n"}
{"name":"SubMulAction.mk.inj","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\ncarrier✝ : Set M\nsmul_mem'✝ : ∀ (c : R) {x : M}, Membership.mem carrier✝ x → Membership.mem carrier✝ (HSMul.hSMul c x)\ncarrier : Set M\nsmul_mem' : ∀ (c : R) {x : M}, Membership.mem carrier x → Membership.mem carrier (HSMul.hSMul c x)\nx✝ : Eq { carrier := carrier✝, smul_mem' := smul_mem'✝ } { carrier := carrier, smul_mem' := smul_mem' }\n⊢ Eq carrier✝ carrier","decl":"/-- A SubMulAction is a set which is closed under scalar multiplication. -/\n@[to_additive]\nstructure SubMulAction (R : Type u) (M : Type v) [SMul R M] : Type v where\n  /-- The underlying set of a `SubMulAction`. -/\n  carrier : Set M\n  /-- The carrier set is closed under scalar multiplication. -/\n  smul_mem' : ∀ (c : R) {x : M}, x ∈ carrier → c • x ∈ carrier\n\n"}
{"name":"SubMulAction.mk.sizeOf_spec","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝² : SMul R M\ninst✝¹ : SizeOf R\ninst✝ : SizeOf M\ncarrier : Set M\nsmul_mem' : ∀ (c : R) {x : M}, Membership.mem carrier x → Membership.mem carrier (HSMul.hSMul c x)\n⊢ Eq (SizeOf.sizeOf { carrier := carrier, smul_mem' := smul_mem' }) 1","decl":"/-- A SubMulAction is a set which is closed under scalar multiplication. -/\n@[to_additive]\nstructure SubMulAction (R : Type u) (M : Type v) [SMul R M] : Type v where\n  /-- The underlying set of a `SubMulAction`. -/\n  carrier : Set M\n  /-- The carrier set is closed under scalar multiplication. -/\n  smul_mem' : ∀ (c : R) {x : M}, x ∈ carrier → c • x ∈ carrier\n\n"}
{"name":"SubMulAction.mk.injEq","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\ncarrier✝ : Set M\nsmul_mem'✝ : ∀ (c : R) {x : M}, Membership.mem carrier✝ x → Membership.mem carrier✝ (HSMul.hSMul c x)\ncarrier : Set M\nsmul_mem' : ∀ (c : R) {x : M}, Membership.mem carrier x → Membership.mem carrier (HSMul.hSMul c x)\n⊢ Eq (Eq { carrier := carrier✝, smul_mem' := smul_mem'✝ } { carrier := carrier, smul_mem' := smul_mem' }) (Eq carrier✝ carrier)","decl":"/-- A SubMulAction is a set which is closed under scalar multiplication. -/\n@[to_additive]\nstructure SubMulAction (R : Type u) (M : Type v) [SMul R M] : Type v where\n  /-- The underlying set of a `SubMulAction`. -/\n  carrier : Set M\n  /-- The carrier set is closed under scalar multiplication. -/\n  smul_mem' : ∀ (c : R) {x : M}, x ∈ carrier → c • x ∈ carrier\n\n"}
{"name":"SubAddAction.instVAddMemClass","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\n⊢ VAddMemClass (SubAddAction R M) R M","decl":"@[to_additive]\ninstance : SMulMemClass (SubMulAction R M) R M where smul_mem := smul_mem' _\n\n"}
{"name":"SubMulAction.instSMulMemClass","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\n⊢ SMulMemClass (SubMulAction R M) R M","decl":"@[to_additive]\ninstance : SMulMemClass (SubMulAction R M) R M where smul_mem := smul_mem' _\n\n"}
{"name":"SubMulAction.mem_carrier","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\np : SubMulAction R M\nx : M\n⊢ Iff (Membership.mem p.carrier x) (Membership.mem (↑p) x)","decl":"@[to_additive (attr := simp)]\ntheorem mem_carrier {p : SubMulAction R M} {x : M} : x ∈ p.carrier ↔ x ∈ (p : Set M) :=\n  Iff.rfl\n\n"}
{"name":"SubAddAction.mem_carrier","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\np : SubAddAction R M\nx : M\n⊢ Iff (Membership.mem p.carrier x) (Membership.mem (↑p) x)","decl":"@[to_additive (attr := simp)]\ntheorem mem_carrier {p : SubMulAction R M} {x : M} : x ∈ p.carrier ↔ x ∈ (p : Set M) :=\n  Iff.rfl\n\n"}
{"name":"SubAddAction.ext","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\np q : SubAddAction R M\nh : ∀ (x : M), Iff (Membership.mem p x) (Membership.mem q x)\n⊢ Eq p q","decl":"@[to_additive (attr := ext)]\ntheorem ext {p q : SubMulAction R M} (h : ∀ x, x ∈ p ↔ x ∈ q) : p = q :=\n  SetLike.ext h\n\n"}
{"name":"SubAddAction.ext_iff","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\np q : SubAddAction R M\n⊢ Iff (Eq p q) (∀ (x : M), Iff (Membership.mem p x) (Membership.mem q x))","decl":"@[to_additive (attr := ext)]\ntheorem ext {p q : SubMulAction R M} (h : ∀ x, x ∈ p ↔ x ∈ q) : p = q :=\n  SetLike.ext h\n\n"}
{"name":"SubMulAction.ext","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\np q : SubMulAction R M\nh : ∀ (x : M), Iff (Membership.mem p x) (Membership.mem q x)\n⊢ Eq p q","decl":"@[to_additive (attr := ext)]\ntheorem ext {p q : SubMulAction R M} (h : ∀ x, x ∈ p ↔ x ∈ q) : p = q :=\n  SetLike.ext h\n\n"}
{"name":"SubMulAction.ext_iff","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\np q : SubMulAction R M\n⊢ Iff (Eq p q) (∀ (x : M), Iff (Membership.mem p x) (Membership.mem q x))","decl":"@[to_additive (attr := ext)]\ntheorem ext {p q : SubMulAction R M} (h : ∀ x, x ∈ p ↔ x ∈ q) : p = q :=\n  SetLike.ext h\n\n"}
{"name":"SubAddAction.coe_copy","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\np : SubAddAction R M\ns : Set M\nhs : Eq s ↑p\n⊢ Eq (↑(p.copy s hs)) s","decl":"@[to_additive (attr := simp)]\ntheorem coe_copy (p : SubMulAction R M) (s : Set M) (hs : s = ↑p) : (p.copy s hs : Set M) = s :=\n  rfl\n\n"}
{"name":"SubMulAction.coe_copy","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\np : SubMulAction R M\ns : Set M\nhs : Eq s ↑p\n⊢ Eq (↑(p.copy s hs)) s","decl":"@[to_additive (attr := simp)]\ntheorem coe_copy (p : SubMulAction R M) (s : Set M) (hs : s = ↑p) : (p.copy s hs : Set M) = s :=\n  rfl\n\n"}
{"name":"SubMulAction.copy_eq","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\np : SubMulAction R M\ns : Set M\nhs : Eq s ↑p\n⊢ Eq (p.copy s hs) p","decl":"@[to_additive]\ntheorem copy_eq (p : SubMulAction R M) (s : Set M) (hs : s = ↑p) : p.copy s hs = p :=\n  SetLike.coe_injective hs\n\n"}
{"name":"SubAddAction.copy_eq","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\np : SubAddAction R M\ns : Set M\nhs : Eq s ↑p\n⊢ Eq (p.copy s hs) p","decl":"@[to_additive]\ntheorem copy_eq (p : SubMulAction R M) (s : Set M) (hs : s = ↑p) : p.copy s hs = p :=\n  SetLike.coe_injective hs\n\n"}
{"name":"SubMulAction.smul_mem","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\np : SubMulAction R M\nx : M\nr : R\nh : Membership.mem p x\n⊢ Membership.mem p (HSMul.hSMul r x)","decl":"@[to_additive]\ntheorem smul_mem (r : R) (h : x ∈ p) : r • x ∈ p :=\n  p.smul_mem' r h\n\n"}
{"name":"SubAddAction.vadd_mem","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\np : SubAddAction R M\nx : M\nr : R\nh : Membership.mem p x\n⊢ Membership.mem p (HVAdd.hVAdd r x)","decl":"@[to_additive]\ntheorem smul_mem (r : R) (h : x ∈ p) : r • x ∈ p :=\n  p.smul_mem' r h\n\n"}
{"name":"SubAddAction.val_vadd","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\np : SubAddAction R M\nr : R\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑(HVAdd.hVAdd r x)) (HVAdd.hVAdd r ↑x)","decl":"@[to_additive (attr := norm_cast, simp)]\ntheorem val_smul (r : R) (x : p) : (↑(r • x) : M) = r • (x : M) :=\n  rfl\n\n-- Porting note: no longer needed because of defeq structure eta\n\n"}
{"name":"SubMulAction.val_smul","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\np : SubMulAction R M\nr : R\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑(HSMul.hSMul r x)) (HSMul.hSMul r ↑x)","decl":"@[to_additive (attr := norm_cast, simp)]\ntheorem val_smul (r : R) (x : p) : (↑(r • x) : M) = r • (x : M) :=\n  rfl\n\n-- Porting note: no longer needed because of defeq structure eta\n\n"}
{"name":"SubAddAction.subtype_apply","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\np : SubAddAction R M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (p.subtype x) ↑x","decl":"@[to_additive (attr := simp)]\ntheorem subtype_apply (x : p) : p.subtype x = x :=\n  rfl\n\n"}
{"name":"SubMulAction.subtype_apply","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\np : SubMulAction R M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (p.subtype x) ↑x","decl":"@[to_additive (attr := simp)]\ntheorem subtype_apply (x : p) : p.subtype x = x :=\n  rfl\n\n"}
{"name":"SubAddAction.subtype_eq_val","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : VAdd R M\np : SubAddAction R M\n⊢ Eq (⇑p.subtype) Subtype.val","decl":"@[to_additive]\ntheorem subtype_eq_val : (SubMulAction.subtype p : p → M) = Subtype.val :=\n  rfl\n\n"}
{"name":"SubMulAction.subtype_eq_val","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝ : SMul R M\np : SubMulAction R M\n⊢ Eq (⇑p.subtype) Subtype.val","decl":"@[to_additive]\ntheorem subtype_eq_val : (SubMulAction.subtype p : p → M) = Subtype.val :=\n  rfl\n\n"}
{"name":"SubMulAction.SMulMemClass.coeSubtype","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝² : Monoid R\ninst✝¹ : MulAction R M\nA : Type u_1\ninst✝ : SetLike A M\nhA : SMulMemClass A R M\nS' : A\n⊢ Eq (⇑(SubMulAction.SMulMemClass.subtype S')) Subtype.val","decl":"@[to_additive (attr := simp)]\nprotected theorem coeSubtype : (SMulMemClass.subtype S' : S' → M) = Subtype.val :=\n  rfl\n\n"}
{"name":"SubAddAction.SMulMemClass.coeSubtype","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝² : AddMonoid R\ninst✝¹ : AddAction R M\nA : Type u_1\ninst✝ : SetLike A M\nhA : VAddMemClass A R M\nS' : A\n⊢ Eq (⇑(SubAddAction.SMulMemClass.subtype S')) Subtype.val","decl":"@[to_additive (attr := simp)]\nprotected theorem coeSubtype : (SMulMemClass.subtype S' : S' → M) = Subtype.val :=\n  rfl\n\n"}
{"name":"SubMulAction.smul_of_tower_mem","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁴ : Monoid R\ninst✝³ : MulAction R M\ninst✝² : SMul S R\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower S R M\np : SubMulAction R M\ns : S\nx : M\nh : Membership.mem p x\n⊢ Membership.mem p (HSMul.hSMul s x)","decl":"@[to_additive]\ntheorem smul_of_tower_mem (s : S) {x : M} (h : x ∈ p) : s • x ∈ p := by\n  rw [← one_smul R x, ← smul_assoc]\n  exact p.smul_mem _ h\n\n"}
{"name":"SubAddAction.vadd_of_tower_mem","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁴ : AddMonoid R\ninst✝³ : AddAction R M\ninst✝² : VAdd S R\ninst✝¹ : VAdd S M\ninst✝ : VAddAssocClass S R M\np : SubAddAction R M\ns : S\nx : M\nh : Membership.mem p x\n⊢ Membership.mem p (HVAdd.hVAdd s x)","decl":"@[to_additive]\ntheorem smul_of_tower_mem (s : S) {x : M} (h : x ∈ p) : s • x ∈ p := by\n  rw [← one_smul R x, ← smul_assoc]\n  exact p.smul_mem _ h\n\n"}
{"name":"SubAddAction.isScalarTower","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁴ : AddMonoid R\ninst✝³ : AddAction R M\ninst✝² : VAdd S R\ninst✝¹ : VAdd S M\ninst✝ : VAddAssocClass S R M\np : SubAddAction R M\n⊢ VAddAssocClass S R (Subtype fun x => Membership.mem p x)","decl":"@[to_additive]\ninstance isScalarTower : IsScalarTower S R p where\n  smul_assoc s r x := Subtype.ext <| smul_assoc s r (x : M)\n\n"}
{"name":"SubMulAction.isScalarTower","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁴ : Monoid R\ninst✝³ : MulAction R M\ninst✝² : SMul S R\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower S R M\np : SubMulAction R M\n⊢ IsScalarTower S R (Subtype fun x => Membership.mem p x)","decl":"@[to_additive]\ninstance isScalarTower : IsScalarTower S R p where\n  smul_assoc s r x := Subtype.ext <| smul_assoc s r (x : M)\n\n"}
{"name":"SubAddAction.isScalarTower'","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁹ : AddMonoid R\ninst✝⁸ : AddAction R M\ninst✝⁷ : VAdd S R\ninst✝⁶ : VAdd S M\ninst✝⁵ : VAddAssocClass S R M\np : SubAddAction R M\nS' : Type u_1\ninst✝⁴ : VAdd S' R\ninst✝³ : VAdd S' S\ninst✝² : VAdd S' M\ninst✝¹ : VAddAssocClass S' R M\ninst✝ : VAddAssocClass S' S M\n⊢ VAddAssocClass S' S (Subtype fun x => Membership.mem p x)","decl":"@[to_additive]\ninstance isScalarTower' {S' : Type*} [SMul S' R] [SMul S' S] [SMul S' M] [IsScalarTower S' R M]\n    [IsScalarTower S' S M] : IsScalarTower S' S p where\n  smul_assoc s r x := Subtype.ext <| smul_assoc s r (x : M)\n\n"}
{"name":"SubMulAction.isScalarTower'","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁹ : Monoid R\ninst✝⁸ : MulAction R M\ninst✝⁷ : SMul S R\ninst✝⁶ : SMul S M\ninst✝⁵ : IsScalarTower S R M\np : SubMulAction R M\nS' : Type u_1\ninst✝⁴ : SMul S' R\ninst✝³ : SMul S' S\ninst✝² : SMul S' M\ninst✝¹ : IsScalarTower S' R M\ninst✝ : IsScalarTower S' S M\n⊢ IsScalarTower S' S (Subtype fun x => Membership.mem p x)","decl":"@[to_additive]\ninstance isScalarTower' {S' : Type*} [SMul S' R] [SMul S' S] [SMul S' M] [IsScalarTower S' R M]\n    [IsScalarTower S' S M] : IsScalarTower S' S p where\n  smul_assoc s r x := Subtype.ext <| smul_assoc s r (x : M)\n\n"}
{"name":"SubMulAction.val_smul_of_tower","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁴ : Monoid R\ninst✝³ : MulAction R M\ninst✝² : SMul S R\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower S R M\np : SubMulAction R M\ns : S\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑(HSMul.hSMul s x)) (HSMul.hSMul s ↑x)","decl":"@[to_additive (attr := norm_cast, simp)]\ntheorem val_smul_of_tower (s : S) (x : p) : ((s • x : p) : M) = s • (x : M) :=\n  rfl\n\n"}
{"name":"SubAddAction.val_vadd_of_tower","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁴ : AddMonoid R\ninst✝³ : AddAction R M\ninst✝² : VAdd S R\ninst✝¹ : VAdd S M\ninst✝ : VAddAssocClass S R M\np : SubAddAction R M\ns : S\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑(HVAdd.hVAdd s x)) (HVAdd.hVAdd s ↑x)","decl":"@[to_additive (attr := norm_cast, simp)]\ntheorem val_smul_of_tower (s : S) (x : p) : ((s • x : p) : M) = s • (x : M) :=\n  rfl\n\n"}
{"name":"SubMulAction.smul_mem_iff'","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Monoid R\ninst✝⁴ : MulAction R M\np : SubMulAction R M\nG : Type u_1\ninst✝³ : Group G\ninst✝² : SMul G R\ninst✝¹ : MulAction G M\ninst✝ : IsScalarTower G R M\ng : G\nx : M\n⊢ Iff (Membership.mem p (HSMul.hSMul g x)) (Membership.mem p x)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_iff' {G} [Group G] [SMul G R] [MulAction G M] [IsScalarTower G R M] (g : G)\n    {x : M} : g • x ∈ p ↔ x ∈ p :=\n  ⟨fun h => inv_smul_smul g x ▸ p.smul_of_tower_mem g⁻¹ h, p.smul_of_tower_mem g⟩\n\n"}
{"name":"SubAddAction.vadd_mem_iff'","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : AddMonoid R\ninst✝⁴ : AddAction R M\np : SubAddAction R M\nG : Type u_1\ninst✝³ : AddGroup G\ninst✝² : VAdd G R\ninst✝¹ : AddAction G M\ninst✝ : VAddAssocClass G R M\ng : G\nx : M\n⊢ Iff (Membership.mem p (HVAdd.hVAdd g x)) (Membership.mem p x)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_iff' {G} [Group G] [SMul G R] [MulAction G M] [IsScalarTower G R M] (g : G)\n    {x : M} : g • x ∈ p ↔ x ∈ p :=\n  ⟨fun h => inv_smul_smul g x ▸ p.smul_of_tower_mem g⁻¹ h, p.smul_of_tower_mem g⟩\n\n"}
{"name":"SubAddAction.isCentralVAdd","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁸ : AddMonoid R\ninst✝⁷ : AddAction R M\ninst✝⁶ : VAdd S R\ninst✝⁵ : VAdd S M\ninst✝⁴ : VAddAssocClass S R M\np : SubAddAction R M\ninst✝³ : VAdd (AddOpposite S) R\ninst✝² : VAdd (AddOpposite S) M\ninst✝¹ : VAddAssocClass (AddOpposite S) R M\ninst✝ : IsCentralVAdd S M\n⊢ IsCentralVAdd S (Subtype fun x => Membership.mem p x)","decl":"@[to_additive]\ninstance isCentralScalar [SMul Sᵐᵒᵖ R] [SMul Sᵐᵒᵖ M] [IsScalarTower Sᵐᵒᵖ R M]\n    [IsCentralScalar S M] :\n    IsCentralScalar S p where\n  op_smul_eq_smul r x := Subtype.ext <| op_smul_eq_smul r (x : M)\n\n"}
{"name":"SubMulAction.isCentralScalar","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁸ : Monoid R\ninst✝⁷ : MulAction R M\ninst✝⁶ : SMul S R\ninst✝⁵ : SMul S M\ninst✝⁴ : IsScalarTower S R M\np : SubMulAction R M\ninst✝³ : SMul (MulOpposite S) R\ninst✝² : SMul (MulOpposite S) M\ninst✝¹ : IsScalarTower (MulOpposite S) R M\ninst✝ : IsCentralScalar S M\n⊢ IsCentralScalar S (Subtype fun x => Membership.mem p x)","decl":"@[to_additive]\ninstance isCentralScalar [SMul Sᵐᵒᵖ R] [SMul Sᵐᵒᵖ M] [IsScalarTower Sᵐᵒᵖ R M]\n    [IsCentralScalar S M] :\n    IsCentralScalar S p where\n  op_smul_eq_smul r x := Subtype.ext <| op_smul_eq_smul r (x : M)\n\n"}
{"name":"SubMulAction.val_image_orbit","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Monoid R\ninst✝ : MulAction R M\np : SubMulAction R M\nm : Subtype fun x => Membership.mem p x\n⊢ Eq (Set.image Subtype.val (MulAction.orbit R m)) (MulAction.orbit R ↑m)","decl":"/-- Orbits in a `SubMulAction` coincide with orbits in the ambient space. -/\n@[to_additive]\ntheorem val_image_orbit {p : SubMulAction R M} (m : p) :\n    Subtype.val '' MulAction.orbit R m = MulAction.orbit R (m : M) :=\n  (Set.range_comp _ _).symm\n\n/- -- Previously, the relatively useless :\nlemma orbit_of_sub_mul {p : SubMulAction R M} (m : p) :\n    (mul_action.orbit R m : set M) = MulAction.orbit R (m : M) := rfl\n-/\n\n"}
{"name":"SubAddAction.val_image_orbit","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddMonoid R\ninst✝ : AddAction R M\np : SubAddAction R M\nm : Subtype fun x => Membership.mem p x\n⊢ Eq (Set.image Subtype.val (AddAction.orbit R m)) (AddAction.orbit R ↑m)","decl":"/-- Orbits in a `SubMulAction` coincide with orbits in the ambient space. -/\n@[to_additive]\ntheorem val_image_orbit {p : SubMulAction R M} (m : p) :\n    Subtype.val '' MulAction.orbit R m = MulAction.orbit R (m : M) :=\n  (Set.range_comp _ _).symm\n\n/- -- Previously, the relatively useless :\nlemma orbit_of_sub_mul {p : SubMulAction R M} (m : p) :\n    (mul_action.orbit R m : set M) = MulAction.orbit R (m : M) := rfl\n-/\n\n"}
{"name":"SubAddAction.val_preimage_orbit","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddMonoid R\ninst✝ : AddAction R M\np : SubAddAction R M\nm : Subtype fun x => Membership.mem p x\n⊢ Eq (Set.preimage Subtype.val (AddAction.orbit R ↑m)) (AddAction.orbit R m)","decl":"@[to_additive]\ntheorem val_preimage_orbit {p : SubMulAction R M} (m : p) :\n    Subtype.val ⁻¹' MulAction.orbit R (m : M) = MulAction.orbit R m := by\n  rw [← val_image_orbit, Subtype.val_injective.preimage_image]\n\n"}
{"name":"SubMulAction.val_preimage_orbit","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Monoid R\ninst✝ : MulAction R M\np : SubMulAction R M\nm : Subtype fun x => Membership.mem p x\n⊢ Eq (Set.preimage Subtype.val (MulAction.orbit R ↑m)) (MulAction.orbit R m)","decl":"@[to_additive]\ntheorem val_preimage_orbit {p : SubMulAction R M} (m : p) :\n    Subtype.val ⁻¹' MulAction.orbit R (m : M) = MulAction.orbit R m := by\n  rw [← val_image_orbit, Subtype.val_injective.preimage_image]\n\n"}
{"name":"SubAddAction.mem_orbit_subAdd_iff","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddMonoid R\ninst✝ : AddAction R M\np : SubAddAction R M\nx m : Subtype fun x => Membership.mem p x\n⊢ Iff (Membership.mem (AddAction.orbit R m) x) (Membership.mem (AddAction.orbit R ↑m) ↑x)","decl":"@[to_additive]\nlemma mem_orbit_subMul_iff {p : SubMulAction R M} {x m : p} :\n    x ∈ MulAction.orbit R m ↔ (x : M) ∈ MulAction.orbit R (m : M) := by\n  rw [← val_preimage_orbit, Set.mem_preimage]\n\n"}
{"name":"SubMulAction.mem_orbit_subMul_iff","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Monoid R\ninst✝ : MulAction R M\np : SubMulAction R M\nx m : Subtype fun x => Membership.mem p x\n⊢ Iff (Membership.mem (MulAction.orbit R m) x) (Membership.mem (MulAction.orbit R ↑m) ↑x)","decl":"@[to_additive]\nlemma mem_orbit_subMul_iff {p : SubMulAction R M} {x m : p} :\n    x ∈ MulAction.orbit R m ↔ (x : M) ∈ MulAction.orbit R (m : M) := by\n  rw [← val_preimage_orbit, Set.mem_preimage]\n\n"}
{"name":"SubMulAction.stabilizer_of_subMul.submonoid","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Monoid R\ninst✝ : MulAction R M\np : SubMulAction R M\nm : Subtype fun x => Membership.mem p x\n⊢ Eq (MulAction.stabilizerSubmonoid R m) (MulAction.stabilizerSubmonoid R ↑m)","decl":"/-- Stabilizers in monoid SubMulAction coincide with stabilizers in the ambient space -/\n@[to_additive]\ntheorem stabilizer_of_subMul.submonoid {p : SubMulAction R M} (m : p) :\n    MulAction.stabilizerSubmonoid R m = MulAction.stabilizerSubmonoid R (m : M) := by\n  ext\n  simp only [MulAction.mem_stabilizerSubmonoid_iff, ← SubMulAction.val_smul, SetLike.coe_eq_coe]\n\n"}
{"name":"SubAddAction.stabilizer_of_subMul.addSubmonoid","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddMonoid R\ninst✝ : AddAction R M\np : SubAddAction R M\nm : Subtype fun x => Membership.mem p x\n⊢ Eq (AddAction.stabilizerAddSubmonoid R m) (AddAction.stabilizerAddSubmonoid R ↑m)","decl":"/-- Stabilizers in monoid SubMulAction coincide with stabilizers in the ambient space -/\n@[to_additive]\ntheorem stabilizer_of_subMul.submonoid {p : SubMulAction R M} (m : p) :\n    MulAction.stabilizerSubmonoid R m = MulAction.stabilizerSubmonoid R (m : M) := by\n  ext\n  simp only [MulAction.mem_stabilizerSubmonoid_iff, ← SubMulAction.val_smul, SetLike.coe_eq_coe]\n\n"}
{"name":"SubAddAction.orbitRel_of_subAdd","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddGroup R\ninst✝ : AddAction R M\np : SubAddAction R M\n⊢ Eq (AddAction.orbitRel R (Subtype fun x => Membership.mem p x)) (Setoid.comap Subtype.val (AddAction.orbitRel R M))","decl":"@[to_additive]\nlemma orbitRel_of_subMul (p : SubMulAction R M) :\n    MulAction.orbitRel R p = (MulAction.orbitRel R M).comap Subtype.val := by\n  refine Setoid.ext_iff.2 (fun x y ↦ ?_)\n  rw [Setoid.comap_rel]\n  exact mem_orbit_subMul_iff\n\n"}
{"name":"SubMulAction.orbitRel_of_subMul","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Group R\ninst✝ : MulAction R M\np : SubMulAction R M\n⊢ Eq (MulAction.orbitRel R (Subtype fun x => Membership.mem p x)) (Setoid.comap Subtype.val (MulAction.orbitRel R M))","decl":"@[to_additive]\nlemma orbitRel_of_subMul (p : SubMulAction R M) :\n    MulAction.orbitRel R p = (MulAction.orbitRel R M).comap Subtype.val := by\n  refine Setoid.ext_iff.2 (fun x y ↦ ?_)\n  rw [Setoid.comap_rel]\n  exact mem_orbit_subMul_iff\n\n"}
{"name":"SubAddAction.stabilizer_of_subAdd","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : AddGroup R\ninst✝ : AddAction R M\np : SubAddAction R M\nm : Subtype fun x => Membership.mem p x\n⊢ Eq (AddAction.stabilizer R m) (AddAction.stabilizer R ↑m)","decl":"/-- Stabilizers in group SubMulAction coincide with stabilizers in the ambient space -/\n@[to_additive]\ntheorem stabilizer_of_subMul {p : SubMulAction R M} (m : p) :\n    MulAction.stabilizer R m = MulAction.stabilizer R (m : M) := by\n  rw [← Subgroup.toSubmonoid_inj]\n  exact stabilizer_of_subMul.submonoid m\n\n"}
{"name":"SubMulAction.stabilizer_of_subMul","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Group R\ninst✝ : MulAction R M\np : SubMulAction R M\nm : Subtype fun x => Membership.mem p x\n⊢ Eq (MulAction.stabilizer R m) (MulAction.stabilizer R ↑m)","decl":"/-- Stabilizers in group SubMulAction coincide with stabilizers in the ambient space -/\n@[to_additive]\ntheorem stabilizer_of_subMul {p : SubMulAction R M} (m : p) :\n    MulAction.stabilizer R m = MulAction.stabilizer R (m : M) := by\n  rw [← Subgroup.toSubmonoid_inj]\n  exact stabilizer_of_subMul.submonoid m\n\n"}
{"name":"SubMulAction.zero_mem","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : SubMulAction R M\nh : (↑p).Nonempty\n⊢ Membership.mem p 0","decl":"theorem zero_mem (h : (p : Set M).Nonempty) : (0 : M) ∈ p :=\n  let ⟨x, hx⟩ := h\n  zero_smul R (x : M) ▸ p.smul_mem 0 hx\n\n"}
{"name":"SubMulAction.neg_mem","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : SubMulAction R M\nx : M\nhx : Membership.mem p x\n⊢ Membership.mem p (Neg.neg x)","decl":"theorem neg_mem (hx : x ∈ p) : -x ∈ p := by\n  rw [← neg_one_smul R]\n  exact p.smul_mem _ hx\n\n"}
{"name":"SubMulAction.neg_mem_iff","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : SubMulAction R M\nx : M\n⊢ Iff (Membership.mem p (Neg.neg x)) (Membership.mem p x)","decl":"@[simp]\ntheorem neg_mem_iff : -x ∈ p ↔ x ∈ p :=\n  ⟨fun h => by\n    rw [← neg_neg x]\n    exact neg_mem _ h, neg_mem _⟩\n\n"}
{"name":"SubMulAction.val_neg","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u\nM : Type v\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : SubMulAction R M\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑(Neg.neg x)) (Neg.neg ↑x)","decl":"@[simp, norm_cast]\ntheorem val_neg (x : p) : ((-x : p) : M) = -x :=\n  rfl\n\n"}
{"name":"SubMulAction.smul_mem_iff","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"S : Type u'\nR : Type u\nM : Type v\ninst✝⁵ : GroupWithZero S\ninst✝⁴ : Monoid R\ninst✝³ : MulAction R M\ninst✝² : SMul S R\ninst✝¹ : MulAction S M\ninst✝ : IsScalarTower S R M\np : SubMulAction R M\ns : S\nx : M\ns0 : Ne s 0\n⊢ Iff (Membership.mem p (HSMul.hSMul s x)) (Membership.mem p x)","decl":"theorem smul_mem_iff (s0 : s ≠ 0) : s • x ∈ p ↔ x ∈ p :=\n  p.smul_mem_iff' (Units.mk0 s s0)\n\n"}
{"name":"SubAddAction.inclusion.toFun_eq_coe","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\ns : SubAddAction M α\n⊢ Eq s.inclusion.toFun Subtype.val","decl":"@[to_additive]\ntheorem inclusion.toFun_eq_coe (s : SubMulAction M α) :\n    s.inclusion.toFun = Subtype.val := rfl\n\n"}
{"name":"SubMulAction.inclusion.toFun_eq_coe","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\ns : SubMulAction M α\n⊢ Eq s.inclusion.toFun Subtype.val","decl":"@[to_additive]\ntheorem inclusion.toFun_eq_coe (s : SubMulAction M α) :\n    s.inclusion.toFun = Subtype.val := rfl\n\n"}
{"name":"SubAddAction.inclusion.coe_eq","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\ns : SubAddAction M α\n⊢ Eq (⇑s.inclusion) Subtype.val","decl":"@[to_additive]\ntheorem inclusion.coe_eq (s : SubMulAction M α) :\n    ⇑s.inclusion = Subtype.val := rfl\n\n"}
{"name":"SubMulAction.inclusion.coe_eq","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\ns : SubMulAction M α\n⊢ Eq (⇑s.inclusion) Subtype.val","decl":"@[to_additive]\ntheorem inclusion.coe_eq (s : SubMulAction M α) :\n    ⇑s.inclusion = Subtype.val := rfl\n\n"}
{"name":"SubMulAction.image_inclusion","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\ns : SubMulAction M α\n⊢ Eq (Set.range ⇑s.inclusion) s.carrier","decl":"@[to_additive]\nlemma image_inclusion (s : SubMulAction M α) :\n    Set.range s.inclusion = s.carrier := by\n  rw [inclusion.coe_eq]\n  exact Subtype.range_coe\n\n"}
{"name":"SubAddAction.image_inclusion","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\ns : SubAddAction M α\n⊢ Eq (Set.range ⇑s.inclusion) s.carrier","decl":"@[to_additive]\nlemma image_inclusion (s : SubMulAction M α) :\n    Set.range s.inclusion = s.carrier := by\n  rw [inclusion.coe_eq]\n  exact Subtype.range_coe\n\n"}
{"name":"SubAddAction.inclusion_injective","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\ns : SubAddAction M α\n⊢ Function.Injective ⇑s.inclusion","decl":"@[to_additive]\nlemma inclusion_injective (s : SubMulAction M α) :\n    Function.Injective s.inclusion :=\n  Subtype.val_injective\n\n"}
{"name":"SubMulAction.inclusion_injective","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\ns : SubMulAction M α\n⊢ Function.Injective ⇑s.inclusion","decl":"@[to_additive]\nlemma inclusion_injective (s : SubMulAction M α) :\n    Function.Injective s.inclusion :=\n  Subtype.val_injective\n\n"}
{"name":"Units.smul_coe","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Monoid R\ninst✝¹ : AddCommMonoid M\ninst✝ : DistribMulAction R M\na : Units R\nx : Subtype fun x => Ne x 0\n⊢ Eq (↑(HSMul.hSMul a x)) (HSMul.hSMul a ↑x)","decl":"@[simp]\nlemma smul_coe (a : Rˣ) (x : { x : M // x ≠ 0 }) :\n    (a • x).val = a • x.val :=\n  rfl\n\n"}
{"name":"Units.orbitRel_nonZero_iff","module":"Mathlib.GroupTheory.GroupAction.SubMulAction","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Monoid R\ninst✝¹ : AddCommMonoid M\ninst✝ : DistribMulAction R M\nx y : Subtype fun v => Ne v 0\n⊢ Iff ((MulAction.orbitRel (Units R) (Subtype fun v => Ne v 0)) x y) ((MulAction.orbitRel (Units R) M) ↑x ↑y)","decl":"lemma orbitRel_nonZero_iff (x y : { v : M // v ≠ 0 }) :\n    MulAction.orbitRel Rˣ { v // v ≠ 0 } x y ↔ MulAction.orbitRel Rˣ M x y :=\n  ⟨by rintro ⟨a, rfl⟩; exact ⟨a, by simp⟩, by intro ⟨a, ha⟩; exact ⟨a, by ext; simpa⟩⟩\n\n"}
