{"name":"instIsManifoldOfNatWithTopENatOfMinSmoothness","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¶ : TopologicalSpace H\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ³ : TopologicalSpace M\ninstâœÂ² : ChartedSpace H M\nn : Nat\ninstâœÂ¹ : n.AtLeastTwo\ninstâœ : IsManifold I (minSmoothness ð•œ (OfNat.ofNat n)) M\nâŠ¢ IsManifold I (OfNat.ofNat n) M","decl":"instance {n : â„•} [n.AtLeastTwo] [IsManifold I (minSmoothness ð•œ (ofNat(n))) M] :\n    IsManifold I (ofNat(n)) M :=\n  IsManifold.of_le (n := minSmoothness ð•œ n) le_minSmoothness\n\n"}
{"name":"instIsManifoldOfNatWithTopENatOfMinSmoothness_1","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâµ : TopologicalSpace H\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : IsManifold I (minSmoothness ð•œ 1) M\nâŠ¢ IsManifold I 1 M","decl":"instance [IsManifold I (minSmoothness ð•œ 1) M] :\n    IsManifold I 1 M :=\n  IsManifold.of_le (n := minSmoothness ð•œ 1) le_minSmoothness\n\n"}
{"name":"instIsManifoldMinSmoothnessOfNatWithTopENat","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâµ : TopologicalSpace H\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : IsManifold I (minSmoothness ð•œ 3) M\nâŠ¢ IsManifold I (minSmoothness ð•œ 2) M","decl":"instance [IsManifold I (minSmoothness ð•œ 3) M] :\n    IsManifold I (minSmoothness ð•œ 2) M :=\n  IsManifold.of_le (n := minSmoothness ð•œ 3) (minSmoothness_monotone (by norm_cast))\n\n"}
{"name":"instIsManifoldMinSmoothnessOfNatWithTopENat_1","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâµ : TopologicalSpace H\nE : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : IsManifold I (minSmoothness ð•œ 2) M\nâŠ¢ IsManifold I (minSmoothness ð•œ 1) M","decl":"instance [IsManifold I (minSmoothness ð•œ 2) M] :\n    IsManifold I (minSmoothness ð•œ 1) M :=\n  IsManifold.of_le (n := minSmoothness ð•œ 2) (minSmoothness_monotone (by norm_cast))\n\n"}
{"name":"VectorField.mpullbackWithin_apply","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nx : M\nV : (x : M') â†’ TangentSpace I' x\nâŠ¢ Eq (VectorField.mpullbackWithin I I' f V s x) ((mfderivWithin I I' f s x).inverse (V (f x)))","decl":"lemma mpullbackWithin_apply :\n    mpullbackWithin I I' f V s x = (mfderivWithin I I' f s x).inverse (V (f x)) := rfl\n\n"}
{"name":"VectorField.mpullbackWithin_smul_apply","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nx : M\nV : (x : M') â†’ TangentSpace I' x\nc : ð•œ\nâŠ¢ Eq (VectorField.mpullbackWithin I I' f (HSMul.hSMul c V) s x) (HSMul.hSMul c (VectorField.mpullbackWithin I I' f V s x))","decl":"lemma mpullbackWithin_smul_apply :\n    mpullbackWithin I I' f (c â€¢ V) s x = c â€¢ mpullbackWithin I I' f V s x := by\n  simp [mpullbackWithin_apply]\n\n"}
{"name":"VectorField.mpullbackWithin_smul","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nV : (x : M') â†’ TangentSpace I' x\nc : ð•œ\nâŠ¢ Eq (VectorField.mpullbackWithin I I' f (HSMul.hSMul c V) s) (HSMul.hSMul c (VectorField.mpullbackWithin I I' f V s))","decl":"lemma mpullbackWithin_smul :\n    mpullbackWithin I I' f (c â€¢ V) s = c â€¢ mpullbackWithin I I' f V s := by\n  ext x\n  simp [mpullbackWithin_apply]\n\n"}
{"name":"VectorField.mpullbackWithin_add_apply","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nx : M\nV Vâ‚ : (x : M') â†’ TangentSpace I' x\nâŠ¢ Eq (VectorField.mpullbackWithin I I' f (HAdd.hAdd V Vâ‚) s x) (HAdd.hAdd (VectorField.mpullbackWithin I I' f V s x) (VectorField.mpullbackWithin I I' f Vâ‚ s x))","decl":"lemma mpullbackWithin_add_apply :\n    mpullbackWithin I I' f (V + Vâ‚) s x =\n      mpullbackWithin I I' f V s x + mpullbackWithin I I' f Vâ‚ s x := by\n  simp [mpullbackWithin_apply]\n\n"}
{"name":"VectorField.mpullbackWithin_add","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nV Vâ‚ : (x : M') â†’ TangentSpace I' x\nâŠ¢ Eq (VectorField.mpullbackWithin I I' f (HAdd.hAdd V Vâ‚) s) (HAdd.hAdd (VectorField.mpullbackWithin I I' f V s) (VectorField.mpullbackWithin I I' f Vâ‚ s))","decl":"lemma mpullbackWithin_add :\n    mpullbackWithin I I' f (V + Vâ‚) s =\n      mpullbackWithin I I' f V s + mpullbackWithin I I' f Vâ‚ s := by\n  ext x\n  simp [mpullbackWithin_apply]\n\n"}
{"name":"VectorField.mpullbackWithin_neg_apply","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nx : M\nV : (x : M') â†’ TangentSpace I' x\nâŠ¢ Eq (VectorField.mpullbackWithin I I' f (Neg.neg V) s x) (Neg.neg (VectorField.mpullbackWithin I I' f V s x))","decl":"lemma mpullbackWithin_neg_apply :\n    mpullbackWithin I I' f (-V) s x = - mpullbackWithin I I' f V s x := by\n  simp [mpullbackWithin_apply]\n\n"}
{"name":"VectorField.mpullbackWithin_neg","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nV : (x : M') â†’ TangentSpace I' x\nâŠ¢ Eq (VectorField.mpullbackWithin I I' f (Neg.neg V) s) (Neg.neg (VectorField.mpullbackWithin I I' f V s))","decl":"lemma mpullbackWithin_neg :\n    mpullbackWithin I I' f (-V) s = - mpullbackWithin I I' f V s := by\n  ext x\n  simp [mpullbackWithin_apply]\n\n"}
{"name":"VectorField.mpullbackWithin_id","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ´ : TopologicalSpace H\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ns : Set M\nx : M\nV : (x : M) â†’ TangentSpace I x\nh : UniqueMDiffWithinAt I s x\nâŠ¢ Eq (VectorField.mpullbackWithin I I id V s x) (V x)","decl":"lemma mpullbackWithin_id {V : Î  (x : M), TangentSpace I x} (h : UniqueMDiffWithinAt I s x) :\n    mpullbackWithin I I id V s x = V x := by\n  simp [mpullbackWithin_apply, mfderivWithin_id h]\n\n"}
{"name":"VectorField.mpullback_apply","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\nx : M\nV : (x : M') â†’ TangentSpace I' x\nâŠ¢ Eq (VectorField.mpullback I I' f V x) ((mfderiv I I' f x).inverse (V (f x)))","decl":"lemma mpullback_apply :\n    mpullback I I' f V x = (mfderiv I I' f x).inverse (V (f x)) := rfl\n\n"}
{"name":"VectorField.mpullback_smul_apply","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\nx : M\nV : (x : M') â†’ TangentSpace I' x\nc : ð•œ\nâŠ¢ Eq (VectorField.mpullback I I' f (HSMul.hSMul c V) x) (HSMul.hSMul c (VectorField.mpullback I I' f V x))","decl":"lemma mpullback_smul_apply :\n    mpullback I I' f (c â€¢ V) x = c â€¢ mpullback I I' f V x := by\n  simp [mpullback]\n\n"}
{"name":"VectorField.mpullback_smul","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\nV : (x : M') â†’ TangentSpace I' x\nc : ð•œ\nâŠ¢ Eq (VectorField.mpullback I I' f (HSMul.hSMul c V)) (HSMul.hSMul c (VectorField.mpullback I I' f V))","decl":"lemma mpullback_smul :\n    mpullback I I' f (c â€¢ V) = c â€¢ mpullback I I' f V := by\n  ext x\n  simp [mpullback_apply]\n\n"}
{"name":"VectorField.mpullback_add_apply","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\nx : M\nV Vâ‚ : (x : M') â†’ TangentSpace I' x\nâŠ¢ Eq (VectorField.mpullback I I' f (HAdd.hAdd V Vâ‚) x) (HAdd.hAdd (VectorField.mpullback I I' f V x) (VectorField.mpullback I I' f Vâ‚ x))","decl":"lemma mpullback_add_apply :\n    mpullback I I' f (V + Vâ‚) x = mpullback I I' f V x + mpullback I I' f Vâ‚ x := by\n  simp [mpullback_apply]\n\n"}
{"name":"VectorField.mpullback_add","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\nV Vâ‚ : (x : M') â†’ TangentSpace I' x\nâŠ¢ Eq (VectorField.mpullback I I' f (HAdd.hAdd V Vâ‚)) (HAdd.hAdd (VectorField.mpullback I I' f V) (VectorField.mpullback I I' f Vâ‚))","decl":"lemma mpullback_add :\n    mpullback I I' f (V + Vâ‚) = mpullback I I' f V + mpullback I I' f Vâ‚ := by\n  ext x\n  simp [mpullback_apply]\n\n"}
{"name":"VectorField.mpullback_neg_apply","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\nx : M\nV : (x : M') â†’ TangentSpace I' x\nâŠ¢ Eq (VectorField.mpullback I I' f (Neg.neg V) x) (Neg.neg (VectorField.mpullback I I' f V x))","decl":"lemma mpullback_neg_apply :\n    mpullback I I' f (-V) x = - mpullback I I' f V x := by\n  simp [mpullback_apply]\n\n"}
{"name":"VectorField.mpullback_neg","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\nV : (x : M') â†’ TangentSpace I' x\nâŠ¢ Eq (VectorField.mpullback I I' f (Neg.neg V)) (Neg.neg (VectorField.mpullback I I' f V))","decl":"lemma mpullback_neg :\n    mpullback I I' f (-V) = - mpullback I I' f V := by\n  ext x\n  simp [mpullback_apply]\n\n"}
{"name":"VectorField.mpullbackWithin_univ","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ¹ : TopologicalSpace H\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nH' : Type u_5\ninstâœâ´ : TopologicalSpace H'\nE' : Type u_6\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\nV : (x : M') â†’ TangentSpace I' x\nâŠ¢ Eq (VectorField.mpullbackWithin I I' f V Set.univ) (VectorField.mpullback I I' f V)","decl":"@[simp] lemma mpullbackWithin_univ : mpullbackWithin I I' f V univ = mpullback I I' f V := by\n  ext x\n  simp [mpullback_apply, mpullbackWithin_apply]\n\n"}
{"name":"VectorField.mpullbackWithin_eq_pullbackWithin","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nE' : Type u_6\ninstâœÂ¹ : NormedAddCommGroup E'\ninstâœ : NormedSpace ð•œ E'\nf : E â†’ E'\nV : E' â†’ E'\ns : Set E\nâŠ¢ Eq (VectorField.mpullbackWithin (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f V s) (VectorField.pullbackWithin ð•œ f V s)","decl":"lemma mpullbackWithin_eq_pullbackWithin {f : E â†’ E'} {V : E' â†’ E'} {s : Set E} :\n    mpullbackWithin ð“˜(ð•œ, E) ð“˜(ð•œ, E') f V s = pullbackWithin ð•œ f V s := by\n  ext x\n  simp only [mpullbackWithin, mfderivWithin_eq_fderivWithin, pullbackWithin]\n  rfl\n\n"}
{"name":"VectorField.mpullback_eq_pullback","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nE' : Type u_6\ninstâœÂ¹ : NormedAddCommGroup E'\ninstâœ : NormedSpace ð•œ E'\nf : E â†’ E'\nV : E' â†’ E'\nâŠ¢ Eq (VectorField.mpullback (modelWithCornersSelf ð•œ E) (modelWithCornersSelf ð•œ E') f V) (VectorField.pullback ð•œ f V)","decl":"lemma mpullback_eq_pullback {f : E â†’ E'} {V : E' â†’ E'} :\n    mpullback ð“˜(ð•œ, E) ð“˜(ð•œ, E') f V = pullback ð•œ f V := by\n  simp only [â† mpullbackWithin_univ, â† pullbackWithin_univ, mpullbackWithin_eq_pullbackWithin]\n\n"}
{"name":"VectorField.mpullback_id","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœâ´ : TopologicalSpace H\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nV : (x : M) â†’ TangentSpace I x\nâŠ¢ Eq (VectorField.mpullback I I id V) V","decl":"@[simp] lemma mpullback_id {V : Î  (x : M), TangentSpace I x} : mpullback I I id V = V := by\n  ext x\n  simp [mpullback]\n\n"}
{"name":"MDifferentiableWithinAt.mpullbackWithin_vectorField_inter","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹Â³ : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœÂ¹Â² : TopologicalSpace H\nE : Type u_3\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¹ : TopologicalSpace M\ninstâœâ¸ : ChartedSpace H M\nH' : Type u_5\ninstâœâ· : TopologicalSpace H'\nE' : Type u_6\ninstâœâ¶ : NormedAddCommGroup E'\ninstâœâµ : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœâ´ : TopologicalSpace M'\ninstâœÂ³ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nxâ‚€ : M\nV : (x : M') â†’ TangentSpace I' x\nn : WithTop ENat\nt : Set M'\ninstâœÂ² : IsManifold I 2 M\ninstâœÂ¹ : IsManifold I' 2 M'\ninstâœ : CompleteSpace E\nhV : MDifferentiableWithinAt I' I'.tangent (fun y => { proj := y, snd := V y }) t (f xâ‚€)\nhf : ContMDiffWithinAt I I' n f s xâ‚€\nhf' : (mfderivWithin I I' f s xâ‚€).IsInvertible\nhxâ‚€ : Membership.mem s xâ‚€\nhs : UniqueMDiffOn I s\nhmn : LE.le 2 n\nâŠ¢ MDifferentiableWithinAt I I.tangent (fun y => { proj := y, snd := VectorField.mpullbackWithin I I' f V s y }) (Inter.inter s (Set.preimage f t)) xâ‚€","decl":"/-- The pullback of a differentiable vector field by a `C^n` function with `2 â‰¤ n` is\ndifferentiable. Version within a set at a point. -/\nprotected lemma _root_.MDifferentiableWithinAt.mpullbackWithin_vectorField_inter\n    (hV : MDifferentiableWithinAt I' I'.tangent\n      (fun (y : M') â†¦ (V y : TangentBundle I' M')) t (f xâ‚€))\n    (hf : ContMDiffWithinAt I I' n f s xâ‚€) (hf' : (mfderivWithin I I' f s xâ‚€).IsInvertible)\n    (hxâ‚€ : xâ‚€ âˆˆ s) (hs : UniqueMDiffOn I s) (hmn : 2 â‰¤ n) :\n    MDifferentiableWithinAt I I.tangent\n      (fun (y : M) â†¦ (mpullbackWithin I I' f V s y : TangentBundle I M)) (s âˆ© f â»Â¹' t) xâ‚€ := by\n  /- We want to apply the theorem `MDifferentiableWithinAt.clm_apply_of_inCoordinates`,\n  stating that applying linear maps to vector fields gives a smooth result when the linear map and\n  the vector field are smooth. This theorem is general, we will apply it to\n  `bâ‚ = f`, `bâ‚‚ = id`, `v = V âˆ˜ f`, `Ï• = fun x â†¦ (mfderivWithin I I' f s x).inverse`-/\n  let bâ‚ := f\n  let bâ‚‚ : M â†’ M := id\n  let v : Î  (x : M), TangentSpace I' (f x) := V âˆ˜ f\n  let Ï• : Î  (x : M), TangentSpace I' (f x) â†’L[ð•œ] TangentSpace I x :=\n    fun x â†¦ (mfderivWithin I I' f s x).inverse\n  have hv : MDifferentiableWithinAt I I'.tangent\n      (fun x â†¦ (v x : TangentBundle I' M')) (s âˆ© f â»Â¹' t) xâ‚€ := by\n    apply hV.comp xâ‚€ ((hf.mdifferentiableWithinAt (one_le_two.trans hmn)).mono inter_subset_left)\n    exact MapsTo.mono_left (mapsTo_preimage _ _) inter_subset_right\n  /- The only nontrivial fact, from which the conclusion follows, is\n  that `Ï•` depends smoothly on `x`. -/\n  suffices hÏ• : MDifferentiableWithinAt I ð“˜(ð•œ, E' â†’L[ð•œ] E)\n      (fun (x : M) â†¦ ContinuousLinearMap.inCoordinates\n        E' (TangentSpace I' (M := M')) E (TangentSpace I (M := M))\n        (bâ‚ xâ‚€) (bâ‚ x) (bâ‚‚ xâ‚€) (bâ‚‚ x) (Ï• x)) s xâ‚€ from\n    MDifferentiableWithinAt.clm_apply_of_inCoordinates (hÏ•.mono inter_subset_left)\n      hv mdifferentiableWithinAt_id\n  /- To prove that `Ï•` depends smoothly on `x`, we use that the derivative depends smoothly on `x`\n  (this is `ContMDiffWithinAt.mfderivWithin_const`), and that taking the inverse is a smooth\n  operation at an invertible map. -/\n  -- the derivative in coordinates depends smoothly on the point\n  have : MDifferentiableWithinAt I ð“˜(ð•œ, E â†’L[ð•œ] E')\n      (fun (x : M) â†¦ ContinuousLinearMap.inCoordinates\n        E (TangentSpace I (M := M)) E' (TangentSpace I' (M := M'))\n        xâ‚€ x (f xâ‚€) (f x) (mfderivWithin I I' f s x)) s xâ‚€ :=\n    ((hf.of_le hmn).mfderivWithin_const le_rfl hxâ‚€ hs).mdifferentiableWithinAt le_rfl\n  -- therefore, its inverse in coordinates also depends smoothly on the point\n  have : MDifferentiableWithinAt I ð“˜(ð•œ, E' â†’L[ð•œ] E)\n      (ContinuousLinearMap.inverse âˆ˜ (fun (x : M) â†¦ ContinuousLinearMap.inCoordinates\n        E (TangentSpace I (M := M)) E' (TangentSpace I' (M := M'))\n        xâ‚€ x (f xâ‚€) (f x) (mfderivWithin I I' f s x))) s xâ‚€ := by\n    apply MDifferentiableAt.comp_mdifferentiableWithinAt _ _ this\n    apply ContMDiffAt.mdifferentiableAt _ le_rfl\n    apply ContDiffAt.contMDiffAt\n    apply IsInvertible.contDiffAt_map_inverse\n    rw [inCoordinates_eq (FiberBundle.mem_baseSet_trivializationAt' xâ‚€)\n      (FiberBundle.mem_baseSet_trivializationAt' (f xâ‚€))]\n    exact isInvertible_equiv.comp (hf'.comp isInvertible_equiv)\n  -- the inverse in coordinates coincides with the in-coordinate version of the inverse,\n  -- therefore the previous point gives the conclusion\n  apply this.congr_of_eventuallyEq_of_mem _ hxâ‚€\n  have A : (trivializationAt E (TangentSpace I) xâ‚€).baseSet âˆˆ ð“[s] xâ‚€ := by\n    apply nhdsWithin_le_nhds\n    apply (trivializationAt _ _ _).open_baseSet.mem_nhds\n    exact FiberBundle.mem_baseSet_trivializationAt' _\n  have B : f â»Â¹' (trivializationAt E' (TangentSpace I') (f xâ‚€)).baseSet âˆˆ ð“[s] xâ‚€ := by\n    apply hf.continuousWithinAt.preimage_mem_nhdsWithin\n    apply (trivializationAt _ _ _).open_baseSet.mem_nhds\n    exact FiberBundle.mem_baseSet_trivializationAt' _\n  filter_upwards [A, B] with x hx h'x\n  simp only [Function.comp_apply]\n  rw [inCoordinates_eq hx h'x, inCoordinates_eq h'x (by exact hx)]\n  simp only [inverse_equiv_comp, inverse_comp_equiv, ContinuousLinearEquiv.symm_symm, Ï•]\n  rfl\n\n"}
{"name":"MDifferentiableWithinAt.mpullbackWithin_vectorField_inter_of_eq","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹Â³ : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœÂ¹Â² : TopologicalSpace H\nE : Type u_3\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¹ : TopologicalSpace M\ninstâœâ¸ : ChartedSpace H M\nH' : Type u_5\ninstâœâ· : TopologicalSpace H'\nE' : Type u_6\ninstâœâ¶ : NormedAddCommGroup E'\ninstâœâµ : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœâ´ : TopologicalSpace M'\ninstâœÂ³ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nxâ‚€ : M\nV : (x : M') â†’ TangentSpace I' x\nn : WithTop ENat\nt : Set M'\nyâ‚€ : M'\ninstâœÂ² : IsManifold I 2 M\ninstâœÂ¹ : IsManifold I' 2 M'\ninstâœ : CompleteSpace E\nhV : MDifferentiableWithinAt I' I'.tangent (fun y => { proj := y, snd := V y }) t yâ‚€\nhf : ContMDiffWithinAt I I' n f s xâ‚€\nhf' : (mfderivWithin I I' f s xâ‚€).IsInvertible\nhxâ‚€ : Membership.mem s xâ‚€\nhs : UniqueMDiffOn I s\nhmn : LE.le 2 n\nh : Eq yâ‚€ (f xâ‚€)\nâŠ¢ MDifferentiableWithinAt I I.tangent (fun y => { proj := y, snd := VectorField.mpullbackWithin I I' f V s y }) (Inter.inter s (Set.preimage f t)) xâ‚€","decl":"lemma _root_.MDifferentiableWithinAt.mpullbackWithin_vectorField_inter_of_eq\n    (hV : MDifferentiableWithinAt I' I'.tangent\n      (fun (y : M') â†¦ (V y : TangentBundle I' M')) t yâ‚€)\n    (hf : ContMDiffWithinAt I I' n f s xâ‚€) (hf' : (mfderivWithin I I' f s xâ‚€).IsInvertible)\n    (hxâ‚€ : xâ‚€ âˆˆ s) (hs : UniqueMDiffOn I s) (hmn : 2 â‰¤ n) (h : yâ‚€ = f xâ‚€) :\n    MDifferentiableWithinAt I I.tangent\n      (fun (y : M) â†¦ (mpullbackWithin I I' f V s y : TangentBundle I M)) (s âˆ© fâ»Â¹' t) xâ‚€ := by\n  subst h\n  exact hV.mpullbackWithin_vectorField_inter hf hf' hxâ‚€ hs hmn\n\n"}
{"name":"MDifferentiableOn.mpullbackWithin_vectorField_inter","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹Â³ : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœÂ¹Â² : TopologicalSpace H\nE : Type u_3\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¹ : TopologicalSpace M\ninstâœâ¸ : ChartedSpace H M\nH' : Type u_5\ninstâœâ· : TopologicalSpace H'\nE' : Type u_6\ninstâœâ¶ : NormedAddCommGroup E'\ninstâœâµ : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœâ´ : TopologicalSpace M'\ninstâœÂ³ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nV : (x : M') â†’ TangentSpace I' x\nn : WithTop ENat\nt : Set M'\ninstâœÂ² : IsManifold I 2 M\ninstâœÂ¹ : IsManifold I' 2 M'\ninstâœ : CompleteSpace E\nhV : MDifferentiableOn I' I'.tangent (fun y => { proj := y, snd := V y }) t\nhf : ContMDiffOn I I' n f s\nhf' : âˆ€ (x : M), Membership.mem (Inter.inter s (Set.preimage f t)) x â†’ (mfderivWithin I I' f s x).IsInvertible\nhs : UniqueMDiffOn I s\nhmn : LE.le 2 n\nâŠ¢ MDifferentiableOn I I.tangent (fun y => { proj := y, snd := VectorField.mpullbackWithin I I' f V s y }) (Inter.inter s (Set.preimage f t))","decl":"/-- The pullback of a differentiable vector field by a `C^n` function with `2 â‰¤ n` is\ndifferentiable. Version on a set. -/\nprotected lemma _root_.MDifferentiableOn.mpullbackWithin_vectorField_inter\n    (hV : MDifferentiableOn I' I'.tangent (fun (y : M') â†¦ (V y : TangentBundle I' M')) t)\n    (hf : ContMDiffOn I I' n f s) (hf' : âˆ€ x âˆˆ s âˆ© f â»Â¹' t, (mfderivWithin I I' f s x).IsInvertible)\n    (hs : UniqueMDiffOn I s) (hmn : 2 â‰¤ n) :\n    MDifferentiableOn I I.tangent\n      (fun (y : M) â†¦ (mpullbackWithin I I' f V s y : TangentBundle I M)) (s âˆ© f â»Â¹' t) :=\n  fun _ hxâ‚€ â†¦ MDifferentiableWithinAt.mpullbackWithin_vectorField_inter\n    (hV _ hxâ‚€.2) (hf _ hxâ‚€.1) (hf' _ hxâ‚€) hxâ‚€.1 hs hmn\n\n"}
{"name":"MDifferentiableWithinAt.mpullback_vectorField_preimage","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹Â³ : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœÂ¹Â² : TopologicalSpace H\nE : Type u_3\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¹ : TopologicalSpace M\ninstâœâ¸ : ChartedSpace H M\nH' : Type u_5\ninstâœâ· : TopologicalSpace H'\nE' : Type u_6\ninstâœâ¶ : NormedAddCommGroup E'\ninstâœâµ : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœâ´ : TopologicalSpace M'\ninstâœÂ³ : ChartedSpace H' M'\nf : M â†’ M'\nxâ‚€ : M\nV : (x : M') â†’ TangentSpace I' x\nn : WithTop ENat\nt : Set M'\ninstâœÂ² : IsManifold I 2 M\ninstâœÂ¹ : IsManifold I' 2 M'\ninstâœ : CompleteSpace E\nhV : MDifferentiableWithinAt I' I'.tangent (fun y => { proj := y, snd := V y }) t (f xâ‚€)\nhf : ContMDiffAt I I' n f xâ‚€\nhf' : (mfderiv I I' f xâ‚€).IsInvertible\nhmn : LE.le 2 n\nâŠ¢ MDifferentiableWithinAt I I.tangent (fun y => { proj := y, snd := VectorField.mpullback I I' f V y }) (Set.preimage f t) xâ‚€","decl":"/-- The pullback of a differentiable vector field by a `C^n` function with `2 â‰¤ n` is\ndifferentiable. Version within a set at a point, but with full pullback. -/\nprotected lemma _root_.MDifferentiableWithinAt.mpullback_vectorField_preimage\n    (hV : MDifferentiableWithinAt I' I'.tangent\n      (fun (y : M') â†¦ (V y : TangentBundle I' M')) t (f xâ‚€))\n    (hf : ContMDiffAt I I' n f xâ‚€) (hf' : (mfderiv I I' f xâ‚€).IsInvertible) (hmn : 2 â‰¤ n) :\n    MDifferentiableWithinAt I I.tangent\n      (fun (y : M) â†¦ (mpullback I I' f V y : TangentBundle I M)) (f â»Â¹' t) xâ‚€ := by\n  simp only [â† contMDiffWithinAt_univ, â† mfderivWithin_univ, â† mpullbackWithin_univ] at hV hf hf' âŠ¢\n  simpa using hV.mpullbackWithin_vectorField_inter hf hf' (mem_univ _) uniqueMDiffOn_univ hmn\n\n"}
{"name":"MDifferentiableWithinAt.mpullback_vectorField_preimage_of_eq","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹Â³ : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœÂ¹Â² : TopologicalSpace H\nE : Type u_3\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¹ : TopologicalSpace M\ninstâœâ¸ : ChartedSpace H M\nH' : Type u_5\ninstâœâ· : TopologicalSpace H'\nE' : Type u_6\ninstâœâ¶ : NormedAddCommGroup E'\ninstâœâµ : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœâ´ : TopologicalSpace M'\ninstâœÂ³ : ChartedSpace H' M'\nf : M â†’ M'\nxâ‚€ : M\nV : (x : M') â†’ TangentSpace I' x\nn : WithTop ENat\nt : Set M'\nyâ‚€ : M'\ninstâœÂ² : IsManifold I 2 M\ninstâœÂ¹ : IsManifold I' 2 M'\ninstâœ : CompleteSpace E\nhV : MDifferentiableWithinAt I' I'.tangent (fun y => { proj := y, snd := V y }) t yâ‚€\nhf : ContMDiffAt I I' n f xâ‚€\nhf' : (mfderiv I I' f xâ‚€).IsInvertible\nhmn : LE.le 2 n\nhyâ‚€ : Eq yâ‚€ (f xâ‚€)\nâŠ¢ MDifferentiableWithinAt I I.tangent (fun y => { proj := y, snd := VectorField.mpullback I I' f V y }) (Set.preimage f t) xâ‚€","decl":"/-- The pullback of a differentiable vector field by a `C^n` function with `2 â‰¤ n` is\ndifferentiable. Version within a set at a point, but with full pullback. -/\nprotected lemma _root_.MDifferentiableWithinAt.mpullback_vectorField_preimage_of_eq\n    (hV : MDifferentiableWithinAt I' I'.tangent (fun (y : M') â†¦ (V y : TangentBundle I' M')) t yâ‚€)\n    (hf : ContMDiffAt I I' n f xâ‚€) (hf' : (mfderiv I I' f xâ‚€).IsInvertible) (hmn : 2 â‰¤ n)\n    (hyâ‚€ : yâ‚€ = f xâ‚€) :\n    MDifferentiableWithinAt I I.tangent\n      (fun (y : M) â†¦ (mpullback I I' f V y : TangentBundle I M)) (f â»Â¹' t) xâ‚€ := by\n  subst hyâ‚€\n  exact hV.mpullback_vectorField_preimage hf hf' hmn\n\n"}
{"name":"MDifferentiableOn.mpullback_vectorField_preimage","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹Â³ : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœÂ¹Â² : TopologicalSpace H\nE : Type u_3\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¹ : TopologicalSpace M\ninstâœâ¸ : ChartedSpace H M\nH' : Type u_5\ninstâœâ· : TopologicalSpace H'\nE' : Type u_6\ninstâœâ¶ : NormedAddCommGroup E'\ninstâœâµ : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœâ´ : TopologicalSpace M'\ninstâœÂ³ : ChartedSpace H' M'\nf : M â†’ M'\nV : (x : M') â†’ TangentSpace I' x\nn : WithTop ENat\nt : Set M'\ninstâœÂ² : IsManifold I 2 M\ninstâœÂ¹ : IsManifold I' 2 M'\ninstâœ : CompleteSpace E\nhV : MDifferentiableOn I' I'.tangent (fun y => { proj := y, snd := V y }) t\nhf : ContMDiff I I' n f\nhf' : âˆ€ (x : M), Membership.mem (Set.preimage f t) x â†’ (mfderiv I I' f x).IsInvertible\nhmn : LE.le 2 n\nâŠ¢ MDifferentiableOn I I.tangent (fun y => { proj := y, snd := VectorField.mpullback I I' f V y }) (Set.preimage f t)","decl":"/-- The pullback of a differentiable vector field by a `C^n` function with `2 â‰¤ n` is\ndifferentiable. Version on a set, but with full pullback -/\nprotected lemma _root_.MDifferentiableOn.mpullback_vectorField_preimage\n    (hV : MDifferentiableOn I' I'.tangent (fun (y : M') â†¦ (V y : TangentBundle I' M')) t)\n    (hf : ContMDiff I I' n f) (hf' : âˆ€ x âˆˆ f â»Â¹' t, (mfderiv I I' f x).IsInvertible)\n    (hmn : 2 â‰¤ n) :\n    MDifferentiableOn I I.tangent\n      (fun (y : M) â†¦ (mpullback I I' f V y : TangentBundle I M)) (f â»Â¹' t) :=\n  fun xâ‚€ hxâ‚€ â†¦ MDifferentiableWithinAt.mpullback_vectorField_preimage\n    (hV _ hxâ‚€) (hf xâ‚€) (hf' _ hxâ‚€) hmn\n\n"}
{"name":"MDifferentiableAt.mpullback_vectorField","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹Â³ : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœÂ¹Â² : TopologicalSpace H\nE : Type u_3\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¹ : TopologicalSpace M\ninstâœâ¸ : ChartedSpace H M\nH' : Type u_5\ninstâœâ· : TopologicalSpace H'\nE' : Type u_6\ninstâœâ¶ : NormedAddCommGroup E'\ninstâœâµ : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœâ´ : TopologicalSpace M'\ninstâœÂ³ : ChartedSpace H' M'\nf : M â†’ M'\nxâ‚€ : M\nV : (x : M') â†’ TangentSpace I' x\nn : WithTop ENat\ninstâœÂ² : IsManifold I 2 M\ninstâœÂ¹ : IsManifold I' 2 M'\ninstâœ : CompleteSpace E\nhV : MDifferentiableAt I' I'.tangent (fun y => { proj := y, snd := V y }) (f xâ‚€)\nhf : ContMDiffAt I I' n f xâ‚€\nhf' : (mfderiv I I' f xâ‚€).IsInvertible\nhmn : LE.le 2 n\nâŠ¢ MDifferentiableAt I I.tangent (fun y => { proj := y, snd := VectorField.mpullback I I' f V y }) xâ‚€","decl":"/-- The pullback of a differentiable vector field by a `C^n` function with `2 â‰¤ n` is\ndifferentiable. Version at a point. -/\nprotected lemma _root_.MDifferentiableAt.mpullback_vectorField\n    (hV : MDifferentiableAt I' I'.tangent (fun (y : M') â†¦ (V y : TangentBundle I' M')) (f xâ‚€))\n    (hf : ContMDiffAt I I' n f xâ‚€) (hf' : (mfderiv I I' f xâ‚€).IsInvertible) (hmn : 2 â‰¤ n) :\n    MDifferentiableAt I I.tangent\n      (fun (y : M) â†¦ (mpullback I I' f V y : TangentBundle I M)) xâ‚€ := by\n  simpa using MDifferentiableWithinAt.mpullback_vectorField_preimage hV hf hf' hmn\n\n"}
{"name":"MDifferentiable.mpullback_vectorField","module":"Mathlib.Geometry.Manifold.VectorField","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹Â³ : NontriviallyNormedField ð•œ\nH : Type u_2\ninstâœÂ¹Â² : TopologicalSpace H\nE : Type u_3\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ð•œ E\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœâ¹ : TopologicalSpace M\ninstâœâ¸ : ChartedSpace H M\nH' : Type u_5\ninstâœâ· : TopologicalSpace H'\nE' : Type u_6\ninstâœâ¶ : NormedAddCommGroup E'\ninstâœâµ : NormedSpace ð•œ E'\nI' : ModelWithCorners ð•œ E' H'\nM' : Type u_7\ninstâœâ´ : TopologicalSpace M'\ninstâœÂ³ : ChartedSpace H' M'\nf : M â†’ M'\nV : (x : M') â†’ TangentSpace I' x\nn : WithTop ENat\ninstâœÂ² : IsManifold I 2 M\ninstâœÂ¹ : IsManifold I' 2 M'\ninstâœ : CompleteSpace E\nhV : MDifferentiable I' I'.tangent fun y => { proj := y, snd := V y }\nhf : ContMDiff I I' n f\nhf' : âˆ€ (x : M), (mfderiv I I' f x).IsInvertible\nhmn : LE.le 2 n\nâŠ¢ MDifferentiable I I.tangent fun y => { proj := y, snd := VectorField.mpullback I I' f V y }","decl":"/-- The pullback of a differentiable vector field by a `C^n` function with `2 â‰¤ n` is\ndifferentiable. -/\nprotected lemma _root_.MDifferentiable.mpullback_vectorField\n    (hV : MDifferentiable I' I'.tangent (fun (y : M') â†¦ (V y : TangentBundle I' M')))\n    (hf : ContMDiff I I' n f) (hf' : âˆ€ x, (mfderiv I I' f x).IsInvertible) (hmn : 2 â‰¤ n) :\n    MDifferentiable I I.tangent (fun (y : M) â†¦ (mpullback I I' f V y : TangentBundle I M)) :=\n  fun x â†¦ MDifferentiableAt.mpullback_vectorField (hV (f x)) (hf x) (hf' x) hmn\n\n"}
