{"name":"MvPolynomial.C_dvd_iff_zmod","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"σ : Type u_1\nn : Nat\nφ : MvPolynomial σ Int\n⊢ Iff (Dvd.dvd (MvPolynomial.C ↑n) φ) (Eq ((MvPolynomial.map (Int.castRingHom (ZMod n))) φ) 0)","decl":"/-- A polynomial over the integers is divisible by `n : ℕ`\nif and only if it is zero over `ZMod n`. -/\ntheorem C_dvd_iff_zmod (n : ℕ) (φ : MvPolynomial σ ℤ) :\n    C (n : ℤ) ∣ φ ↔ map (Int.castRingHom (ZMod n)) φ = 0 :=\n  C_dvd_iff_map_hom_eq_zero _ _ (CharP.intCast_eq_zero_iff (ZMod n) n) _\n\n"}
{"name":"MvPolynomial.frobenius_zmod","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"σ : Type u_1\np : Nat\ninst✝ : Fact (Nat.Prime p)\nf : MvPolynomial σ (ZMod p)\n⊢ Eq ((frobenius (MvPolynomial σ (ZMod p)) p) f) ((MvPolynomial.expand p) f)","decl":"theorem frobenius_zmod (f : MvPolynomial σ (ZMod p)) : frobenius _ p f = expand p f := by\n  apply induction_on f\n  · intro a; rw [expand_C, frobenius_def, ← C_pow, ZMod.pow_card]\n  · simp only [map_add]; intro _ _ hf hg; rw [hf, hg]\n  · simp only [expand_X, map_mul]\n    intro _ _ hf; rw [hf, frobenius_def]\n\n"}
{"name":"MvPolynomial.expand_zmod","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"σ : Type u_1\np : Nat\ninst✝ : Fact (Nat.Prime p)\nf : MvPolynomial σ (ZMod p)\n⊢ Eq ((MvPolynomial.expand p) f) (HPow.hPow f p)","decl":"theorem expand_zmod (f : MvPolynomial σ (ZMod p)) : expand p f = f ^ p :=\n  (frobenius_zmod _).symm\n\n"}
{"name":"MvPolynomial.eval_indicator_apply_eq_one","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"K : Type u_1\nσ : Type u_2\ninst✝² : Fintype K\ninst✝¹ : Fintype σ\ninst✝ : CommRing K\na : σ → K\n⊢ Eq ((MvPolynomial.eval a) (MvPolynomial.indicator a)) 1","decl":"theorem eval_indicator_apply_eq_one (a : σ → K) : eval a (indicator a) = 1 := by\n  nontriviality\n  have : 0 < Fintype.card K - 1 := tsub_pos_of_lt Fintype.one_lt_card\n  simp only [indicator, map_prod, map_sub, map_one, map_pow, eval_X, eval_C, sub_self,\n    zero_pow this.ne', sub_zero, Finset.prod_const_one]\n\n"}
{"name":"MvPolynomial.degrees_indicator","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"K : Type u_1\nσ : Type u_2\ninst✝² : Fintype K\ninst✝¹ : Fintype σ\ninst✝ : CommRing K\nc : σ → K\n⊢ LE.le (MvPolynomial.indicator c).degrees (Finset.univ.sum fun s => HSMul.hSMul (HSub.hSub (Fintype.card K) 1) (Singleton.singleton s))","decl":"theorem degrees_indicator (c : σ → K) :\n    degrees (indicator c) ≤ ∑ s : σ, (Fintype.card K - 1) • {s} := by\n  rw [indicator]\n  classical\n  refine degrees_prod_le.trans <| Finset.sum_le_sum fun s _ ↦ degrees_sub_le.trans ?_\n  rw [degrees_one, Multiset.zero_union]\n  refine le_trans degrees_pow_le (nsmul_le_nsmul_right ?_ _)\n  refine degrees_sub_le.trans ?_\n  rw [degrees_C, Multiset.union_zero]\n  exact degrees_X' _\n\n"}
{"name":"MvPolynomial.indicator_mem_restrictDegree","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"K : Type u_1\nσ : Type u_2\ninst✝² : Fintype K\ninst✝¹ : Fintype σ\ninst✝ : CommRing K\nc : σ → K\n⊢ Membership.mem (MvPolynomial.restrictDegree σ K (HSub.hSub (Fintype.card K) 1)) (MvPolynomial.indicator c)","decl":"theorem indicator_mem_restrictDegree (c : σ → K) :\n    indicator c ∈ restrictDegree σ K (Fintype.card K - 1) := by\n  classical\n  rw [mem_restrictDegree_iff_sup, indicator]\n  intro n\n  refine le_trans (Multiset.count_le_of_le _ <| degrees_indicator _) (le_of_eq ?_)\n  simp_rw [← Multiset.coe_countAddMonoidHom, map_sum,\n    AddMonoidHom.map_nsmul, Multiset.coe_countAddMonoidHom, nsmul_eq_mul, Nat.cast_id]\n  trans\n  · refine Finset.sum_eq_single n ?_ ?_\n    · intro b _ ne\n      simp [Multiset.count_singleton, ne, if_neg (Ne.symm _)]\n    · intro h; exact (h <| Finset.mem_univ _).elim\n  · rw [Multiset.count_singleton_self, mul_one]\n\n"}
{"name":"MvPolynomial.eval_indicator_apply_eq_zero","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"K : Type u_1\nσ : Type u_2\ninst✝² : Fintype K\ninst✝¹ : Fintype σ\ninst✝ : Field K\na b : σ → K\nh : Ne a b\n⊢ Eq ((MvPolynomial.eval a) (MvPolynomial.indicator b)) 0","decl":"theorem eval_indicator_apply_eq_zero (a b : σ → K) (h : a ≠ b) : eval a (indicator b) = 0 := by\n  obtain ⟨i, hi⟩ : ∃ i, a i ≠ b i := by rwa [Ne, funext_iff, not_forall] at h\n  simp only [indicator, map_prod, map_sub, map_one, map_pow, eval_X, eval_C, sub_self,\n    Finset.prod_eq_zero_iff]\n  refine ⟨i, Finset.mem_univ _, ?_⟩\n  rw [FiniteField.pow_card_sub_one_eq_one, sub_self]\n  rwa [Ne, sub_eq_zero]\n\n"}
{"name":"MvPolynomial.evalₗ_apply","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"K : Type u_1\nσ : Type u_2\ninst✝ : CommSemiring K\np : MvPolynomial σ K\ne : σ → K\n⊢ Eq ((MvPolynomial.evalₗ K σ) p e) ((MvPolynomial.eval e) p)","decl":"/-- `MvPolynomial.eval` as a `K`-linear map. -/\n@[simps]\ndef evalₗ [CommSemiring K] : MvPolynomial σ K →ₗ[K] (σ → K) → K where\n  toFun p e := eval e p\n  map_add' p q := by ext x; simp\n  map_smul' a p := by ext e; simp\n\n"}
{"name":"MvPolynomial.map_restrict_dom_evalₗ","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"K : Type u_1\nσ : Type u_2\ninst✝² : Field K\ninst✝¹ : Fintype K\ninst✝ : Finite σ\n⊢ Eq (Submodule.map (MvPolynomial.evalₗ K σ) (MvPolynomial.restrictDegree σ K (HSub.hSub (Fintype.card K) 1))) Top.top","decl":"theorem map_restrict_dom_evalₗ : (restrictDegree σ K (Fintype.card K - 1)).map (evalₗ K σ) = ⊤ := by\n  cases nonempty_fintype σ\n  refine top_unique (SetLike.le_def.2 fun e _ => mem_map.2 ?_)\n  classical\n  refine ⟨∑ n : σ → K, e n • indicator n, ?_, ?_⟩\n  · exact sum_mem fun c _ => smul_mem _ _ (indicator_mem_restrictDegree _)\n  · ext n\n    simp only [_root_.map_sum, @Finset.sum_apply (σ → K) (fun _ => K) _ _ _ _ _, Pi.smul_apply,\n      map_smul]\n    simp only [evalₗ_apply]\n    trans\n    · refine Finset.sum_eq_single n (fun b _ h => ?_) ?_\n      · rw [eval_indicator_apply_eq_zero _ _ h.symm, smul_zero]\n      · exact fun h => (h <| Finset.mem_univ n).elim\n    · rw [eval_indicator_apply_eq_one, smul_eq_mul, mul_one]\n\n"}
{"name":"MvPolynomial.rank_R","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"σ K : Type u\ninst✝² : Fintype K\ninst✝¹ : Field K\ninst✝ : Fintype σ\n⊢ Eq (Module.rank K (MvPolynomial.R σ K)) ↑(Fintype.card (σ → K))","decl":"open Classical in\ntheorem rank_R [Fintype σ] : Module.rank K (R σ K) = Fintype.card (σ → K) :=\n  calc\n    Module.rank K (R σ K) =\n        Module.rank K (↥{ s : σ →₀ ℕ | ∀ n : σ, s n ≤ Fintype.card K - 1 } →₀ K) :=\n      LinearEquiv.rank_eq\n        (Finsupp.supportedEquivFinsupp { s : σ →₀ ℕ | ∀ n : σ, s n ≤ Fintype.card K - 1 })\n    _ = #{ s : σ →₀ ℕ | ∀ n : σ, s n ≤ Fintype.card K - 1 } := by rw [rank_finsupp_self']\n    _ = #{ s : σ → ℕ | ∀ n : σ, s n < Fintype.card K } := by\n      refine Quotient.sound ⟨Equiv.subtypeEquiv Finsupp.equivFunOnFinite fun f => ?_⟩\n      refine forall_congr' fun n => le_tsub_iff_right ?_\n      exact Fintype.card_pos_iff.2 ⟨0⟩\n    _ = #(σ → { n // n < Fintype.card K }) :=\n      (@Equiv.subtypePiEquivPi σ (fun _ => ℕ) fun _ n => n < Fintype.card K).cardinal_eq\n    _ = #(σ → Fin (Fintype.card K)) :=\n      (Equiv.arrowCongr (Equiv.refl σ) Fin.equivSubtype.symm).cardinal_eq\n    _ = #(σ → K) := (Equiv.arrowCongr (Equiv.refl σ) (Fintype.equivFin K).symm).cardinal_eq\n    _ = Fintype.card (σ → K) := Cardinal.mk_fintype _\n\n"}
{"name":"MvPolynomial.instFiniteDimensionalROfFinite","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"σ K : Type u\ninst✝² : Fintype K\ninst✝¹ : Field K\ninst✝ : Finite σ\n⊢ FiniteDimensional K (MvPolynomial.R σ K)","decl":"instance [Finite σ] : FiniteDimensional K (R σ K) := by\n  cases nonempty_fintype σ\n  classical\n  exact\n    IsNoetherian.iff_fg.1\n      (IsNoetherian.iff_rank_lt_aleph0.mpr <| by\n        simpa only [rank_R] using Cardinal.nat_lt_aleph0 (Fintype.card (σ → K)))\n\n"}
{"name":"MvPolynomial.finrank_R","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"σ K : Type u\ninst✝² : Fintype K\ninst✝¹ : Field K\ninst✝ : Fintype σ\n⊢ Eq (Module.finrank K (MvPolynomial.R σ K)) (Fintype.card (σ → K))","decl":"open Classical in\ntheorem finrank_R [Fintype σ] : Module.finrank K (R σ K) = Fintype.card (σ → K) :=\n  Module.finrank_eq_of_rank_eq (rank_R σ K)\n\n-- Porting note: was `(evalᵢ σ K).range`.\n"}
{"name":"MvPolynomial.range_evalᵢ","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"σ K : Type u\ninst✝² : Fintype K\ninst✝¹ : Field K\ninst✝ : Finite σ\n⊢ Eq (LinearMap.range (MvPolynomial.evalᵢ σ K)) Top.top","decl":"theorem range_evalᵢ [Finite σ] : range (evalᵢ σ K) = ⊤ := by\n  rw [evalᵢ, LinearMap.range_comp, range_subtype]\n  exact map_restrict_dom_evalₗ K σ\n\n-- Porting note: was `(evalᵢ σ K).ker`.\n"}
{"name":"MvPolynomial.ker_evalₗ","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"σ K : Type u\ninst✝² : Fintype K\ninst✝¹ : Field K\ninst✝ : Finite σ\n⊢ Eq (LinearMap.ker (MvPolynomial.evalᵢ σ K)) Bot.bot","decl":"theorem ker_evalₗ [Finite σ] : ker (evalᵢ σ K) = ⊥ := by\n  cases nonempty_fintype σ\n  refine (ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank ?_).mpr (range_evalᵢ σ K)\n  classical\n  rw [Module.finrank_fintype_fun_eq_card, finrank_R]\n\n"}
{"name":"MvPolynomial.eq_zero_of_eval_eq_zero","module":"Mathlib.FieldTheory.Finite.Polynomial","initialProofState":"σ K : Type u\ninst✝² : Fintype K\ninst✝¹ : Field K\ninst✝ : Finite σ\np : MvPolynomial σ K\nh : ∀ (v : σ → K), Eq ((MvPolynomial.eval v) p) 0\nhp : Membership.mem (MvPolynomial.restrictDegree σ K (HSub.hSub (Fintype.card K) 1)) p\n⊢ Eq p 0","decl":"theorem eq_zero_of_eval_eq_zero [Finite σ] (p : MvPolynomial σ K) (h : ∀ v : σ → K, eval v p = 0)\n    (hp : p ∈ restrictDegree σ K (Fintype.card K - 1)) : p = 0 :=\n  let p' : R σ K := ⟨p, hp⟩\n  have : p' ∈ ker (evalᵢ σ K) := funext h\n  show p'.1 = (0 : R σ K).1 from congr_arg _ <| by rwa [ker_evalₗ, mem_bot] at this\n\n"}
