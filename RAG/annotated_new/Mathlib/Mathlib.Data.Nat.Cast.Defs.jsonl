{"name":"Nat.AtLeastTwo.prop","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"n : Nat\nself : n.AtLeastTwo\n⊢ GE.ge n 2","decl":"/-- A type class for natural numbers which are greater than or equal to `2`. -/\nclass Nat.AtLeastTwo (n : ℕ) : Prop where\n  prop : n ≥ 2\n\n"}
{"name":"instNatAtLeastTwo","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"n : Nat\n⊢ (HAdd.hAdd n 2).AtLeastTwo","decl":"instance instNatAtLeastTwo {n : ℕ} : Nat.AtLeastTwo (n + 2) where\n  prop := Nat.succ_le_succ <| Nat.succ_le_succ <| Nat.zero_le _\n\n"}
{"name":"Nat.AtLeastTwo.one_lt","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ LT.lt 1 n","decl":"lemma one_lt : 1 < n := prop\n"}
{"name":"Nat.AtLeastTwo.ne_one","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Ne n 1","decl":"lemma ne_one : n ≠ 1 := Nat.ne_of_gt one_lt\n\n"}
{"name":"Nat.cast_ofNat","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\nn : Nat\ninst✝¹ : NatCast R\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast] theorem Nat.cast_ofNat {n : ℕ} [NatCast R] [Nat.AtLeastTwo n] :\n  (Nat.cast ofNat(n) : R) = ofNat(n) := rfl\n\n"}
{"name":"Nat.cast_eq_ofNat","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\nn : Nat\ninst✝¹ : NatCast R\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑n) (OfNat.ofNat n)","decl":"@[deprecated Nat.cast_ofNat (since := \"2024-12-22\")]\ntheorem Nat.cast_eq_ofNat {n : ℕ} [NatCast R] [Nat.AtLeastTwo n] :\n    (Nat.cast n : R) = OfNat.ofNat n :=\n  rfl\n\n"}
{"name":"AddMonoidWithOne.natCast_succ","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_2\nself : AddMonoidWithOne R\nn : Nat\n⊢ Eq (NatCast.natCast (HAdd.hAdd n 1)) (HAdd.hAdd (NatCast.natCast n) 1)","decl":"/-- An `AddMonoidWithOne` is an `AddMonoid` with a `1`.\nIt also contains data for the unique homomorphism `ℕ → R`. -/\nclass AddMonoidWithOne (R : Type*) extends NatCast R, AddMonoid R, One R where\n  natCast := Nat.unaryCast\n  /-- The canonical map `ℕ → R` sends `0 : ℕ` to `0 : R`. -/\n  natCast_zero : natCast 0 = 0 := by intros; rfl\n  /-- The canonical map `ℕ → R` is a homomorphism. -/\n  natCast_succ : ∀ n, natCast (n + 1) = natCast n + 1 := by intros; rfl\n\n"}
{"name":"AddMonoidWithOne.natCast_zero","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_2\nself : AddMonoidWithOne R\n⊢ Eq (NatCast.natCast 0) 0","decl":"/-- An `AddMonoidWithOne` is an `AddMonoid` with a `1`.\nIt also contains data for the unique homomorphism `ℕ → R`. -/\nclass AddMonoidWithOne (R : Type*) extends NatCast R, AddMonoid R, One R where\n  natCast := Nat.unaryCast\n  /-- The canonical map `ℕ → R` sends `0 : ℕ` to `0 : R`. -/\n  natCast_zero : natCast 0 = 0 := by intros; rfl\n  /-- The canonical map `ℕ → R` is a homomorphism. -/\n  natCast_succ : ∀ n, natCast (n + 1) = natCast n + 1 := by intros; rfl\n\n"}
{"name":"AddCommMonoidWithOne.add_comm","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_2\nself : AddCommMonoidWithOne R\na b : R\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"/-- An `AddCommMonoidWithOne` is an `AddMonoidWithOne` satisfying `a + b = b + a`. -/\nclass AddCommMonoidWithOne (R : Type*) extends AddMonoidWithOne R, AddCommMonoid R\n\n"}
{"name":"Nat.cast_zero","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem cast_zero : ((0 : ℕ) : R) = 0 :=\n  AddMonoidWithOne.natCast_zero\n\n-- Lemmas about `Nat.succ` need to get a low priority, so that they are tried last.\n-- This is because `Nat.succ _` matches `1`, `3`, `x+1`, etc.\n-- Rewriting would then produce really wrong terms.\n"}
{"name":"Nat.cast_succ","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\nn : Nat\n⊢ Eq (↑n.succ) (HAdd.hAdd (↑n) 1)","decl":"@[norm_cast 500]\ntheorem cast_succ (n : ℕ) : ((succ n : ℕ) : R) = n + 1 :=\n  AddMonoidWithOne.natCast_succ _\n\n"}
{"name":"Nat.cast_add_one","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\nn : Nat\n⊢ Eq (↑(HAdd.hAdd n 1)) (HAdd.hAdd (↑n) 1)","decl":"theorem cast_add_one (n : ℕ) : ((n + 1 : ℕ) : R) = n + 1 :=\n  cast_succ _\n\n"}
{"name":"Nat.cast_ite","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\nP : Prop\ninst✝ : Decidable P\nm n : Nat\n⊢ Eq (↑(ite P m n)) (ite P ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_ite (P : Prop) [Decidable P] (m n : ℕ) :\n    ((ite P m n : ℕ) : R) = ite P (m : R) (n : R) := by\n  split_ifs <;> rfl\n\n"}
{"name":"Nat.cast_one","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem cast_one [AddMonoidWithOne R] : ((1 : ℕ) : R) = 1 := by\n  rw [cast_succ, Nat.cast_zero, zero_add]\n\n"}
{"name":"Nat.cast_add","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\nm n : Nat\n⊢ Eq (↑(HAdd.hAdd m n)) (HAdd.hAdd ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_add [AddMonoidWithOne R] (m n : ℕ) : ((m + n : ℕ) : R) = m + n := by\n  induction n with\n  | zero => simp\n  | succ n ih => rw [add_succ, cast_succ, ih, cast_succ, add_assoc]\n\n"}
{"name":"Nat.binCast_eq","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\nn : Nat\n⊢ Eq n.binCast ↑n","decl":"@[simp]\ntheorem binCast_eq [AddMonoidWithOne R] (n : ℕ) :\n    (Nat.binCast n : R) = ((n : ℕ) : R) := by\n  induction n using Nat.strongRecOn with | ind k hk => ?_\n  cases k with\n  | zero => rw [Nat.binCast, Nat.cast_zero]\n  | succ k =>\n      rw [Nat.binCast]\n      by_cases h : (k + 1) % 2 = 0\n      · conv => rhs; rw [← Nat.mod_add_div (k+1) 2]\n        rw [if_pos h, hk _ <| Nat.div_lt_self (Nat.succ_pos k) (Nat.le_refl 2), ← Nat.cast_add]\n        rw [h, Nat.zero_add, Nat.succ_mul, Nat.one_mul]\n      · conv => rhs; rw [← Nat.mod_add_div (k+1) 2]\n        rw [if_neg h, hk _ <| Nat.div_lt_self (Nat.succ_pos k) (Nat.le_refl 2), ← Nat.cast_add]\n        have h1 := Or.resolve_left (Nat.mod_two_eq_zero_or_one (succ k)) h\n        rw [h1, Nat.add_comm 1, Nat.succ_mul, Nat.one_mul]\n        simp only [Nat.cast_add, Nat.cast_one]\n\n"}
{"name":"Nat.cast_two","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\n⊢ Eq (↑2) 2","decl":"theorem cast_two [AddMonoidWithOne R] : ((2 : ℕ) : R) = (2 : R) := rfl\n\n"}
{"name":"Nat.cast_three","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\n⊢ Eq (↑3) 3","decl":"theorem cast_three [AddMonoidWithOne R] : ((3 : ℕ) : R) = (3 : R) := rfl\n\n"}
{"name":"Nat.cast_four","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\n⊢ Eq (↑4) 4","decl":"theorem cast_four [AddMonoidWithOne R] : ((4 : ℕ) : R) = (4 : R) := rfl\n\n"}
{"name":"one_add_one_eq_two","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\n⊢ Eq (HAdd.hAdd 1 1) 2","decl":"theorem one_add_one_eq_two [AddMonoidWithOne R] : 1 + 1 = (2 : R) := by\n  rw [← Nat.cast_one, ← Nat.cast_add]\n  apply congrArg\n  decide\n\n"}
{"name":"two_add_one_eq_three","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\n⊢ Eq (HAdd.hAdd 2 1) 3","decl":"theorem two_add_one_eq_three [AddMonoidWithOne R] : 2 + 1 = (3 : R) := by\n  rw [← one_add_one_eq_two, ← Nat.cast_one, ← Nat.cast_add, ← Nat.cast_add]\n  apply congrArg\n  decide\n\n"}
{"name":"three_add_one_eq_four","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\n⊢ Eq (HAdd.hAdd 3 1) 4","decl":"theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by\n  rw [← two_add_one_eq_three, ← one_add_one_eq_two, ← Nat.cast_one,\n    ← Nat.cast_add, ← Nat.cast_add, ← Nat.cast_add]\n  apply congrArg\n  decide\n\n"}
{"name":"two_add_two_eq_four","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\n⊢ Eq (HAdd.hAdd 2 2) 4","decl":"theorem two_add_two_eq_four [AddMonoidWithOne R] : 2 + 2 = (4 : R) := by\n  simp [← one_add_one_eq_two, ← Nat.cast_one, ← three_add_one_eq_four,\n    ← two_add_one_eq_three, add_assoc]\n\n"}
{"name":"nsmul_one","module":"Mathlib.Data.Nat.Cast.Defs","initialProofState":"A : Type u_2\ninst✝ : AddMonoidWithOne A\nn : Nat\n⊢ Eq (HSMul.hSMul n 1) ↑n","decl":"@[simp] lemma nsmul_one {A} [AddMonoidWithOne A] : ∀ n : ℕ, n • (1 : A) = n\n  | 0 => by simp [zero_nsmul]\n  | n + 1 => by simp [succ_nsmul, nsmul_one n]\n\n"}
