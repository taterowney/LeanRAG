{"name":"CategoryTheory.HasPullbacksOfInclusions.hasPullbackInl","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nself : CategoryTheory.HasPullbacksOfInclusions C\nX Y Z : C\nf : Quiver.Hom Z (CategoryTheory.Limits.coprod X Y)\n‚ä¢ CategoryTheory.Limits.HasPullback CategoryTheory.Limits.coprod.inl f","decl":"/-- A category has pullback of inclusions if it has all pullbacks along coproduct injections. -/\nclass HasPullbacksOfInclusions (C : Type u) [Category.{v} C] [HasBinaryCoproducts C] : Prop where\n  [hasPullbackInl : ‚àÄ {X Y Z : C} (f : Z ‚ü∂ X ‚®ø Y), HasPullback coprod.inl f]\n\n"}
{"name":"CategoryTheory.PreservesPullbacksOfInclusions.preservesPullbackInl","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nself : CategoryTheory.PreservesPullbacksOfInclusions F\nX Y Z : C\nf : Quiver.Hom Z (CategoryTheory.Limits.coprod X Y)\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan CategoryTheory.Limits.coprod.inl f) F","decl":"/--\nA functor preserves pullback of inclusions if it preserves all pullbacks along coproduct injections.\n-/\nclass PreservesPullbacksOfInclusions {C : Type*} [Category C] {D : Type*} [Category D]\n    (F : C ‚•§ D) [HasBinaryCoproducts C] where\n  [preservesPullbackInl : ‚àÄ {X Y Z : C} (f : Z ‚ü∂ X ‚®ø Y), PreservesLimit (cospan coprod.inl f) F]\n\n"}
{"name":"CategoryTheory.FinitaryPreExtensive.hasFiniteCoproducts","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.FinitaryPreExtensive C\n‚ä¢ CategoryTheory.Limits.HasFiniteCoproducts C","decl":"/-- A category is (finitary) pre-extensive if it has finite coproducts,\nand binary coproducts are universal. -/\nclass FinitaryPreExtensive (C : Type u) [Category.{v} C] : Prop where\n  [hasFiniteCoproducts : HasFiniteCoproducts C]\n  [hasPullbacksOfInclusions : HasPullbacksOfInclusions C]\n  /-- In a finitary extensive category, all coproducts are van Kampen -/\n  universal' : ‚àÄ {X Y : C} (c : BinaryCofan X Y), IsColimit c ‚Üí IsUniversalColimit c\n\n"}
{"name":"CategoryTheory.FinitaryPreExtensive.universal'","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.FinitaryPreExtensive C\nX Y : C\nc : CategoryTheory.Limits.BinaryCofan X Y\na‚úù : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.IsUniversalColimit c","decl":"/-- A category is (finitary) pre-extensive if it has finite coproducts,\nand binary coproducts are universal. -/\nclass FinitaryPreExtensive (C : Type u) [Category.{v} C] : Prop where\n  [hasFiniteCoproducts : HasFiniteCoproducts C]\n  [hasPullbacksOfInclusions : HasPullbacksOfInclusions C]\n  /-- In a finitary extensive category, all coproducts are van Kampen -/\n  universal' : ‚àÄ {X Y : C} (c : BinaryCofan X Y), IsColimit c ‚Üí IsUniversalColimit c\n\n"}
{"name":"CategoryTheory.FinitaryPreExtensive.hasPullbacksOfInclusions","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.FinitaryPreExtensive C\n‚ä¢ CategoryTheory.HasPullbacksOfInclusions C","decl":"/-- A category is (finitary) pre-extensive if it has finite coproducts,\nand binary coproducts are universal. -/\nclass FinitaryPreExtensive (C : Type u) [Category.{v} C] : Prop where\n  [hasFiniteCoproducts : HasFiniteCoproducts C]\n  [hasPullbacksOfInclusions : HasPullbacksOfInclusions C]\n  /-- In a finitary extensive category, all coproducts are van Kampen -/\n  universal' : ‚àÄ {X Y : C} (c : BinaryCofan X Y), IsColimit c ‚Üí IsUniversalColimit c\n\n"}
{"name":"CategoryTheory.FinitaryExtensive.hasFiniteCoproducts","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.FinitaryExtensive C\n‚ä¢ CategoryTheory.Limits.HasFiniteCoproducts C","decl":"/-- A category is (finitary) extensive if it has finite coproducts,\nand binary coproducts are van Kampen. -/\nclass FinitaryExtensive (C : Type u) [Category.{v} C] : Prop where\n  [hasFiniteCoproducts : HasFiniteCoproducts C]\n  [hasPullbacksOfInclusions : HasPullbacksOfInclusions C]\n  /-- In a finitary extensive category, all coproducts are van Kampen -/\n  van_kampen' : ‚àÄ {X Y : C} (c : BinaryCofan X Y), IsColimit c ‚Üí IsVanKampenColimit c\n\n"}
{"name":"CategoryTheory.FinitaryExtensive.hasPullbacksOfInclusions","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.FinitaryExtensive C\n‚ä¢ CategoryTheory.HasPullbacksOfInclusions C","decl":"/-- A category is (finitary) extensive if it has finite coproducts,\nand binary coproducts are van Kampen. -/\nclass FinitaryExtensive (C : Type u) [Category.{v} C] : Prop where\n  [hasFiniteCoproducts : HasFiniteCoproducts C]\n  [hasPullbacksOfInclusions : HasPullbacksOfInclusions C]\n  /-- In a finitary extensive category, all coproducts are van Kampen -/\n  van_kampen' : ‚àÄ {X Y : C} (c : BinaryCofan X Y), IsColimit c ‚Üí IsVanKampenColimit c\n\n"}
{"name":"CategoryTheory.FinitaryExtensive.van_kampen'","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.FinitaryExtensive C\nX Y : C\nc : CategoryTheory.Limits.BinaryCofan X Y\na‚úù : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.IsVanKampenColimit c","decl":"/-- A category is (finitary) extensive if it has finite coproducts,\nand binary coproducts are van Kampen. -/\nclass FinitaryExtensive (C : Type u) [Category.{v} C] : Prop where\n  [hasFiniteCoproducts : HasFiniteCoproducts C]\n  [hasPullbacksOfInclusions : HasPullbacksOfInclusions C]\n  /-- In a finitary extensive category, all coproducts are van Kampen -/\n  van_kampen' : ‚àÄ {X Y : C} (c : BinaryCofan X Y), IsColimit c ‚Üí IsVanKampenColimit c\n\n"}
{"name":"CategoryTheory.FinitaryExtensive.vanKampen","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.FinitaryExtensive C\nF : CategoryTheory.Functor (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.IsVanKampenColimit c","decl":"theorem FinitaryExtensive.vanKampen [FinitaryExtensive C] {F : Discrete WalkingPair ‚•§ C}\n    (c : Cocone F) (hc : IsColimit c) : IsVanKampenColimit c := by\n  let X := F.obj ‚ü®WalkingPair.left‚ü©\n  let Y := F.obj ‚ü®WalkingPair.right‚ü©\n  have : F = pair X Y := by\n    apply Functor.hext\n    ¬∑ rintro ‚ü®‚ü®‚ü©‚ü© <;> rfl\n    ¬∑ rintro ‚ü®‚ü®‚ü©‚ü© ‚ü®j‚ü© ‚ü®‚ü®rfl : _ = j‚ü©‚ü© <;> simp [X, Y]\n  clear_value X Y\n  subst this\n  exact FinitaryExtensive.van_kampen' c hc\n\n"}
{"name":"CategoryTheory.HasPullbacksOfInclusions.instOfHasPullbacks","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\n‚ä¢ CategoryTheory.HasPullbacksOfInclusions C","decl":"instance (priority := 100) [HasBinaryCoproducts C] [HasPullbacks C] :\n    HasPullbacksOfInclusions C := ‚ü®‚ü©\n\n"}
{"name":"CategoryTheory.HasPullbacksOfInclusions.preservesPullbackInl'","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproducts C\ninst‚úù : CategoryTheory.HasPullbacksOfInclusions C\nX Y Z : C\nf : Quiver.Hom Z (CategoryTheory.Limits.coprod X Y)\n‚ä¢ CategoryTheory.Limits.HasPullback f CategoryTheory.Limits.coprod.inl","decl":"instance preservesPullbackInl' :\n    HasPullback f coprod.inl :=\n  hasPullback_symmetry _ _\n\n"}
{"name":"CategoryTheory.HasPullbacksOfInclusions.hasPullbackInr'","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nX Y Z : C\nf : Quiver.Hom Z (CategoryTheory.Limits.coprod X Y)\n‚ä¢ CategoryTheory.Limits.HasPullback f CategoryTheory.Limits.coprod.inr","decl":"instance hasPullbackInr' :\n    HasPullback f coprod.inr := by\n  have : IsPullback (ùüô _) (f ‚â´ (coprod.braiding X Y).hom) f (coprod.braiding Y X).hom :=\n    IsPullback.of_horiz_isIso ‚ü®by simp‚ü©\n  have := (IsPullback.of_hasPullback (f ‚â´ (coprod.braiding X Y).hom) coprod.inl).paste_horiz this\n  simp only [coprod.braiding_hom, Category.comp_id, colimit.Œπ_desc, BinaryCofan.mk_pt,\n    BinaryCofan.Œπ_app_left, BinaryCofan.mk_inl] at this\n  exact ‚ü®‚ü®‚ü®_, this.isLimit‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.HasPullbacksOfInclusions.hasPullbackInr","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nX Y Z : C\nf : Quiver.Hom Z (CategoryTheory.Limits.coprod X Y)\n‚ä¢ CategoryTheory.Limits.HasPullback CategoryTheory.Limits.coprod.inr f","decl":"instance hasPullbackInr :\n    HasPullback coprod.inr f :=\n  hasPullback_symmetry _ _\n\n"}
{"name":"CategoryTheory.PreservesPullbacksOfInclusions.instOfPreservesLimitsOfShapeWalkingCospan","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproducts C\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan F\n‚ä¢ CategoryTheory.PreservesPullbacksOfInclusions F","decl":"noncomputable\ninstance (priority := 100) [PreservesLimitsOfShape WalkingCospan F] :\n    PreservesPullbacksOfInclusions F := ‚ü®‚ü©\n\n"}
{"name":"CategoryTheory.PreservesPullbacksOfInclusions.preservesPullbackInl'","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproducts C\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.PreservesPullbacksOfInclusions F\nX Y Z : C\nf : Quiver.Hom Z (CategoryTheory.Limits.coprod X Y)\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f CategoryTheory.Limits.coprod.inl) F","decl":"noncomputable\ninstance preservesPullbackInl' :\n    PreservesLimit (cospan f coprod.inl) F :=\n  preservesPullback_symmetry _ _ _\n\n"}
{"name":"CategoryTheory.PreservesPullbacksOfInclusions.preservesPullbackInr'","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nF : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom Z (CategoryTheory.Limits.coprod X Y)\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f CategoryTheory.Limits.coprod.inr) F","decl":"noncomputable\ninstance preservesPullbackInr' :\n    PreservesLimit (cospan f coprod.inr) F := by\n  apply preservesLimit_of_iso_diagram (K‚ÇÅ := cospan (f ‚â´ (coprod.braiding X Y).hom) coprod.inl)\n  apply cospanExt (Iso.refl _) (Iso.refl _) (coprod.braiding X Y).symm <;> simp\n\n"}
{"name":"CategoryTheory.PreservesPullbacksOfInclusions.preservesPullbackInr","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproducts C\nF : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom Z (CategoryTheory.Limits.coprod X Y)\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan CategoryTheory.Limits.coprod.inr f) F","decl":"noncomputable\ninstance preservesPullbackInr :\n    PreservesLimit (cospan coprod.inr f) F :=\n  preservesPullback_symmetry _ _ _\n\n"}
{"name":"CategoryTheory.FinitaryExtensive.toFinitaryPreExtensive","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.FinitaryExtensive C\n‚ä¢ CategoryTheory.FinitaryPreExtensive C","decl":"instance (priority := 100) FinitaryExtensive.toFinitaryPreExtensive [FinitaryExtensive C] :\n    FinitaryPreExtensive C :=\n  ‚ü®fun c hc ‚Ü¶ (FinitaryExtensive.van_kampen' c hc).isUniversal‚ü©\n\n"}
{"name":"CategoryTheory.FinitaryExtensive.mono_inr_of_isColimit","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù : CategoryTheory.FinitaryExtensive C\nc : CategoryTheory.Limits.BinaryCofan X Y\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.Mono c.inr","decl":"theorem FinitaryExtensive.mono_inr_of_isColimit [FinitaryExtensive C] {c : BinaryCofan X Y}\n    (hc : IsColimit c) : Mono c.inr :=\n  BinaryCofan.mono_inr_of_isVanKampen (FinitaryExtensive.vanKampen c hc)\n\n"}
{"name":"CategoryTheory.FinitaryExtensive.mono_inl_of_isColimit","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù : CategoryTheory.FinitaryExtensive C\nc : CategoryTheory.Limits.BinaryCofan X Y\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.Mono c.inl","decl":"theorem FinitaryExtensive.mono_inl_of_isColimit [FinitaryExtensive C] {c : BinaryCofan X Y}\n    (hc : IsColimit c) : Mono c.inl :=\n  FinitaryExtensive.mono_inr_of_isColimit (BinaryCofan.isColimitFlip hc)\n\n"}
{"name":"CategoryTheory.instMonoInl","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.FinitaryExtensive C\nX Y : C\n‚ä¢ CategoryTheory.Mono CategoryTheory.Limits.coprod.inl","decl":"instance [FinitaryExtensive C] (X Y : C) : Mono (coprod.inl : X ‚ü∂ X ‚®ø Y) :=\n  (FinitaryExtensive.mono_inl_of_isColimit (coprodIsCoprod X Y) :)\n\n"}
{"name":"CategoryTheory.instMonoInr","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.FinitaryExtensive C\nX Y : C\n‚ä¢ CategoryTheory.Mono CategoryTheory.Limits.coprod.inr","decl":"instance [FinitaryExtensive C] (X Y : C) : Mono (coprod.inr : Y ‚ü∂ X ‚®ø Y) :=\n  (FinitaryExtensive.mono_inr_of_isColimit (coprodIsCoprod X Y) :)\n\n"}
{"name":"CategoryTheory.FinitaryExtensive.isPullback_initial_to_binaryCofan","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\ninst‚úù : CategoryTheory.FinitaryExtensive C\nc : CategoryTheory.Limits.BinaryCofan X Y\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.IsPullback (CategoryTheory.Limits.initial.to ((CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.left })) (CategoryTheory.Limits.initial.to ((CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.right })) c.inl c.inr","decl":"theorem FinitaryExtensive.isPullback_initial_to_binaryCofan [FinitaryExtensive C]\n    {c : BinaryCofan X Y} (hc : IsColimit c) :\n    IsPullback (initial.to _) (initial.to _) c.inl c.inr :=\n  BinaryCofan.isPullback_initial_to_of_isVanKampen (FinitaryExtensive.vanKampen c hc)\n\n"}
{"name":"CategoryTheory.hasStrictInitialObjects_of_finitaryPreExtensive","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.FinitaryPreExtensive C\n‚ä¢ CategoryTheory.Limits.HasStrictInitialObjects C","decl":"instance (priority := 100) hasStrictInitialObjects_of_finitaryPreExtensive\n    [FinitaryPreExtensive C] : HasStrictInitialObjects C :=\n  hasStrictInitial_of_isUniversal (FinitaryPreExtensive.universal' _\n    ((BinaryCofan.isColimit_iff_isIso_inr initialIsInitial _).mpr (by\n      dsimp\n      infer_instance)).some)\n\n"}
{"name":"CategoryTheory.finitaryExtensive_iff_of_isTerminal","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteCoproducts C\ninst‚úù : CategoryTheory.HasPullbacksOfInclusions C\nT : C\nHT : CategoryTheory.Limits.IsTerminal T\nc‚ÇÄ : CategoryTheory.Limits.BinaryCofan T T\nhc‚ÇÄ : CategoryTheory.Limits.IsColimit c‚ÇÄ\n‚ä¢ Iff (CategoryTheory.FinitaryExtensive C) (CategoryTheory.IsVanKampenColimit c‚ÇÄ)","decl":"theorem finitaryExtensive_iff_of_isTerminal (C : Type u) [Category.{v} C] [HasFiniteCoproducts C]\n    [HasPullbacksOfInclusions C]\n    (T : C) (HT : IsTerminal T) (c‚ÇÄ : BinaryCofan T T) (hc‚ÇÄ : IsColimit c‚ÇÄ) :\n    FinitaryExtensive C ‚Üî IsVanKampenColimit c‚ÇÄ := by\n  refine ‚ü®fun H => H.van_kampen' c‚ÇÄ hc‚ÇÄ, fun H => ?_‚ü©\n  constructor\n  simp_rw [BinaryCofan.isVanKampen_iff] at H ‚ä¢\n  intro X Y c hc X' Y' c' Œ±X Œ±Y f hX hY\n  obtain ‚ü®d, hd, hd'‚ü© :=\n    Limits.BinaryCofan.IsColimit.desc' hc (HT.from _ ‚â´ c‚ÇÄ.inl) (HT.from _ ‚â´ c‚ÇÄ.inr)\n  rw [H c' (Œ±X ‚â´ HT.from _) (Œ±Y ‚â´ HT.from _) (f ‚â´ d) (by rw [‚Üê reassoc_of% hX, hd, Category.assoc])\n      (by rw [‚Üê reassoc_of% hY, hd', Category.assoc])]\n  obtain ‚ü®hl, hr‚ü© := (H c (HT.from _) (HT.from _) d hd.symm hd'.symm).mp ‚ü®hc‚ü©\n  rw [hl.paste_vert_iff hX.symm, hr.paste_vert_iff hY.symm]\n\n"}
{"name":"CategoryTheory.types.finitaryExtensive","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"‚ä¢ CategoryTheory.FinitaryExtensive (Type u)","decl":"instance types.finitaryExtensive : FinitaryExtensive (Type u) := by\n  classical\n  rw [finitaryExtensive_iff_of_isTerminal (Type u) PUnit Types.isTerminalPunit _\n      (Types.binaryCoproductColimit _ _)]\n  apply BinaryCofan.isVanKampen_mk _ _ (fun X Y => Types.binaryCoproductColimit X Y) _\n      fun f g => (Limits.Types.pullbackLimitCone f g).2\n  ¬∑ intros _ _ _ _ f hŒ±X hŒ±Y\n    constructor\n    ¬∑ refine ‚ü®‚ü®hŒ±X.symm‚ü©, ‚ü®PullbackCone.isLimitAux' _ ?_‚ü©‚ü©\n      intro s\n      have : ‚àÄ x, ‚àÉ! y, s.fst x = Sum.inl y := by\n        intro x\n        cases' h : s.fst x with val val\n        ¬∑ simp only [Types.binaryCoproductCocone_pt, Functor.const_obj_obj, Sum.inl.injEq,\n            existsUnique_eq']\n        ¬∑ apply_fun f at h\n          cases ((congr_fun s.condition x).symm.trans h).trans (congr_fun hŒ±Y val :).symm\n      delta ExistsUnique at this\n      choose l hl hl' using this\n      exact ‚ü®l, (funext hl).symm, Types.isTerminalPunit.hom_ext _ _,\n        fun {l'} h‚ÇÅ _ => funext fun x => hl' x (l' x) (congr_fun h‚ÇÅ x).symm‚ü©\n    ¬∑ refine ‚ü®‚ü®hŒ±Y.symm‚ü©, ‚ü®PullbackCone.isLimitAux' _ ?_‚ü©‚ü©\n      intro s\n      have : ‚àÄ x, ‚àÉ! y, s.fst x = Sum.inr y := by\n        intro x\n        cases' h : s.fst x with val val\n        ¬∑ apply_fun f at h\n          cases ((congr_fun s.condition x).symm.trans h).trans (congr_fun hŒ±X val :).symm\n        ¬∑ simp only [Types.binaryCoproductCocone_pt, Functor.const_obj_obj, Sum.inr.injEq,\n            existsUnique_eq']\n      delta ExistsUnique at this\n      choose l hl hl' using this\n      exact ‚ü®l, (funext hl).symm, Types.isTerminalPunit.hom_ext _ _,\n        fun {l'} h‚ÇÅ _ => funext fun x => hl' x (l' x) (congr_fun h‚ÇÅ x).symm‚ü©\n  ¬∑ intro Z f\n    dsimp [Limits.Types.binaryCoproductCocone]\n    delta Types.PullbackObj\n    have : ‚àÄ x, f x = Sum.inl PUnit.unit ‚à® f x = Sum.inr PUnit.unit := by\n      intro x\n      rcases f x with (‚ü®‚ü®‚ü©‚ü© | ‚ü®‚ü®‚ü©‚ü©)\n      exacts [Or.inl rfl, Or.inr rfl]\n    let eX : { p : Z √ó PUnit // f p.fst = Sum.inl p.snd } ‚âÉ { x : Z // f x = Sum.inl PUnit.unit } :=\n      ‚ü®fun p => ‚ü®p.1.1, by convert p.2‚ü©, fun x => ‚ü®‚ü®_, _‚ü©, x.2‚ü©, fun _ => by ext; rfl,\n        fun _ => by ext; rfl‚ü©\n    let eY : { p : Z √ó PUnit // f p.fst = Sum.inr p.snd } ‚âÉ { x : Z // f x = Sum.inr PUnit.unit } :=\n      ‚ü®fun p => ‚ü®p.1.1, p.2.trans (congr_arg Sum.inr <| Subsingleton.elim _ _)‚ü©,\n        fun x => ‚ü®‚ü®_, _‚ü©, x.2‚ü©, fun _ => by ext; rfl, fun _ => by ext; rfl‚ü©\n    fapply BinaryCofan.isColimitMk\n    ¬∑ exact fun s x => dite _ (fun h => s.inl <| eX.symm ‚ü®x, h‚ü©)\n        fun h => s.inr <| eY.symm ‚ü®x, (this x).resolve_left h‚ü©\n    ¬∑ intro s\n      ext ‚ü®‚ü®x, ‚ü®‚ü©‚ü©, _‚ü©\n      dsimp\n      split_ifs <;> rfl\n    ¬∑ intro s\n      ext ‚ü®‚ü®x, ‚ü®‚ü©‚ü©, hx‚ü©\n      dsimp\n      split_ifs with h\n      ¬∑ cases h.symm.trans hx\n      ¬∑ rfl\n    ¬∑ intro s m e‚ÇÅ e‚ÇÇ\n      ext x\n      split_ifs\n      ¬∑ rw [‚Üê e‚ÇÅ]\n        rfl\n      ¬∑ rw [‚Üê e‚ÇÇ]\n        rfl\n\n"}
{"name":"CategoryTheory.finitaryExtensive_TopCat","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"‚ä¢ CategoryTheory.FinitaryExtensive TopCat","decl":"instance finitaryExtensive_TopCat : FinitaryExtensive TopCat.{u} := by\n  rw [finitaryExtensive_iff_of_isTerminal TopCat.{u} _ TopCat.isTerminalPUnit _\n      (TopCat.binaryCofanIsColimit _ _)]\n  apply BinaryCofan.isVanKampen_mk _ _ (fun X Y => TopCat.binaryCofanIsColimit X Y) _\n      fun f g => TopCat.pullbackConeIsLimit f g\n  ¬∑ intro X' Y' Œ±X Œ±Y f hŒ±X hŒ±Y\n    constructor\n    ¬∑ refine ‚ü®‚ü®hŒ±X.symm‚ü©, ‚ü®PullbackCone.isLimitAux' _ ?_‚ü©‚ü©\n      intro s\n      have : ‚àÄ x, ‚àÉ! y, s.fst x = Sum.inl y := by\n        intro x\n        cases' h : s.fst x with val val\n        ¬∑ exact ‚ü®val, rfl, fun y h => Sum.inl_injective h.symm‚ü©\n        ¬∑ apply_fun f at h\n          cases ((ConcreteCategory.congr_hom s.condition x).symm.trans h).trans\n            (ConcreteCategory.congr_hom hŒ±Y val :).symm\n      delta ExistsUnique at this\n      choose l hl hl' using this\n      refine ‚ü®‚ü®l, ?_‚ü©, ContinuousMap.ext fun a => (hl a).symm, TopCat.isTerminalPUnit.hom_ext _ _,\n        fun {l'} h‚ÇÅ _ => ContinuousMap.ext fun x =>\n          hl' x (l' x) (ConcreteCategory.congr_hom h‚ÇÅ x).symm‚ü©\n      apply (IsEmbedding.inl (X := X') (Y := Y')).isInducing.continuous_iff.mpr\n      convert s.fst.2 using 1\n      exact (funext hl).symm\n    ¬∑ refine ‚ü®‚ü®hŒ±Y.symm‚ü©, ‚ü®PullbackCone.isLimitAux' _ ?_‚ü©‚ü©\n      intro s\n      have : ‚àÄ x, ‚àÉ! y, s.fst x = Sum.inr y := by\n        intro x\n        cases' h : s.fst x with val val\n        ¬∑ apply_fun f at h\n          cases ((ConcreteCategory.congr_hom s.condition x).symm.trans h).trans\n            (ConcreteCategory.congr_hom hŒ±X val :).symm\n        ¬∑ exact ‚ü®val, rfl, fun y h => Sum.inr_injective h.symm‚ü©\n      delta ExistsUnique at this\n      choose l hl hl' using this\n      refine ‚ü®‚ü®l, ?_‚ü©, ContinuousMap.ext fun a => (hl a).symm, TopCat.isTerminalPUnit.hom_ext _ _,\n        fun {l'} h‚ÇÅ _ =>\n          ContinuousMap.ext fun x => hl' x (l' x) (ConcreteCategory.congr_hom h‚ÇÅ x).symm‚ü©\n      apply (IsEmbedding.inr (X := X') (Y := Y')).isInducing.continuous_iff.mpr\n      convert s.fst.2 using 1\n      exact (funext hl).symm\n  ¬∑ intro Z f\n    exact finitaryExtensiveTopCatAux Z f\n\n"}
{"name":"CategoryTheory.finitaryExtensive_of_reflective","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù‚Åπ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst‚úù‚Å∏ : CategoryTheory.Category.{v'', u''} D\ninst‚úù‚Å∑ : CategoryTheory.Limits.HasFiniteCoproducts D\ninst‚úù‚Å∂ : CategoryTheory.HasPullbacksOfInclusions D\ninst‚úù‚Åµ : CategoryTheory.FinitaryExtensive C\nGl : CategoryTheory.Functor C D\nGr : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction Gl Gr\ninst‚úù‚Å¥ : Gr.Full\ninst‚úù¬≥ : Gr.Faithful\ninst‚úù¬≤ : ‚àÄ (X : D) (Y : C) (f : Quiver.Hom X (Gl.obj Y)), CategoryTheory.Limits.HasPullback (Gr.map f) (adj.unit.app Y)\ninst‚úù¬π : ‚àÄ (X : D) (Y : C) (f : Quiver.Hom X (Gl.obj Y)), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (Gr.map f) (adj.unit.app Y)) Gl\ninst‚úù : CategoryTheory.PreservesPullbacksOfInclusions Gl\n‚ä¢ CategoryTheory.FinitaryExtensive D","decl":"theorem finitaryExtensive_of_reflective\n    [HasFiniteCoproducts D] [HasPullbacksOfInclusions D] [FinitaryExtensive C]\n    {Gl : C ‚•§ D} {Gr : D ‚•§ C} (adj : Gl ‚ä£ Gr) [Gr.Full] [Gr.Faithful]\n    [‚àÄ X Y (f : X ‚ü∂ Gl.obj Y), HasPullback (Gr.map f) (adj.unit.app Y)]\n    [‚àÄ X Y (f : X ‚ü∂ Gl.obj Y), PreservesLimit (cospan (Gr.map f) (adj.unit.app Y)) Gl]\n    [PreservesPullbacksOfInclusions Gl] :\n    FinitaryExtensive D := by\n  have : PreservesColimitsOfSize Gl := adj.leftAdjoint_preservesColimits\n  constructor\n  intros X Y c hc\n  apply (IsVanKampenColimit.precompose_isIso_iff\n    (isoWhiskerLeft _ (asIso adj.counit) ‚â™‚â´ Functor.rightUnitor _).hom).mp\n  have : ‚àÄ (Z : C) (i : Discrete WalkingPair) (f : Z ‚ü∂ (colimit.cocone (pair X Y ‚ãô Gr)).pt),\n        PreservesLimit (cospan f ((colimit.cocone (pair X Y ‚ãô Gr)).Œπ.app i)) Gl := by\n    have : pair X Y ‚ãô Gr = pair (Gr.obj X) (Gr.obj Y) := by\n      apply Functor.hext\n      ¬∑ rintro ‚ü®‚ü®‚ü©‚ü© <;> rfl\n      ¬∑ rintro ‚ü®‚ü®‚ü©‚ü© ‚ü®j‚ü© ‚ü®‚ü®rfl : _ = j‚ü©‚ü© <;> simp\n    rw [this]\n    rintro Z ‚ü®_|_‚ü© f <;> dsimp <;> infer_instance\n  refine ((FinitaryExtensive.vanKampen _ (colimit.isColimit <| pair X Y ‚ãô _)).map_reflective\n    adj).of_iso (IsColimit.uniqueUpToIso ?_ ?_)\n  ¬∑ exact isColimitOfPreserves Gl (colimit.isColimit _)\n  ¬∑ exact (IsColimit.precomposeHomEquiv _ _).symm hc\n\n"}
{"name":"CategoryTheory.finitaryExtensive_functor","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst‚úù¬≤ : CategoryTheory.Category.{v'', u''} D\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\ninst‚úù : CategoryTheory.FinitaryExtensive C\n‚ä¢ CategoryTheory.FinitaryExtensive (CategoryTheory.Functor D C)","decl":"instance finitaryExtensive_functor [HasPullbacks C] [FinitaryExtensive C] :\n    FinitaryExtensive (D ‚•§ C) :=\n  haveI : HasFiniteCoproducts (D ‚•§ C) := ‚ü®fun _ => Limits.functorCategoryHasColimitsOfShape‚ü©\n  ‚ü®fun c hc => isVanKampenColimit_of_evaluation _ c fun _ =>\n    FinitaryExtensive.vanKampen _ <| isColimitOfPreserves _ hc‚ü©\n\n"}
{"name":"CategoryTheory.instPreservesLimitWalkingCospanCospanOfIsIso","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\nD : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_3} D\nF : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) F","decl":"instance {C} [Category C] {D} [Category D] (F : C ‚•§ D)\n    {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [IsIso f] : PreservesLimit (cospan f g) F :=\n  have := hasPullback_of_left_iso f g\n  preservesLimit_of_preserves_limit_cone (IsPullback.of_hasPullback f g).isLimit\n    ((isLimitMapConePullbackConeEquiv _ pullback.condition).symm\n      (IsPullback.of_vert_isIso ‚ü®by simp only [‚Üê F.map_comp, pullback.condition]‚ü©).isLimit)\n\n"}
{"name":"CategoryTheory.instPreservesLimitWalkingCospanCospanOfIsIso_1","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\nD : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_3} D\nF : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.IsIso g\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) F","decl":"instance {C} [Category C] {D} [Category D] (F : C ‚•§ D)\n    {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [IsIso g] : PreservesLimit (cospan f g) F :=\n  preservesPullback_symmetry _ _ _\n\n"}
{"name":"CategoryTheory.finitaryExtensive_of_preserves_and_reflects","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù‚Å∏ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst‚úù‚Å∑ : CategoryTheory.Category.{v'', u''} D\nF : CategoryTheory.Functor C D\ninst‚úù‚Å∂ : CategoryTheory.FinitaryExtensive D\ninst‚úù‚Åµ : CategoryTheory.Limits.HasFiniteCoproducts C\ninst‚úù‚Å¥ : CategoryTheory.HasPullbacksOfInclusions C\ninst‚úù¬≥ : CategoryTheory.PreservesPullbacksOfInclusions F\ninst‚úù¬≤ : CategoryTheory.Limits.ReflectsLimitsOfShape CategoryTheory.Limits.WalkingCospan F\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst‚úù : CategoryTheory.Limits.ReflectsColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\n‚ä¢ CategoryTheory.FinitaryExtensive C","decl":"theorem finitaryExtensive_of_preserves_and_reflects (F : C ‚•§ D) [FinitaryExtensive D]\n    [HasFiniteCoproducts C] [HasPullbacksOfInclusions C]\n    [PreservesPullbacksOfInclusions F]\n    [ReflectsLimitsOfShape WalkingCospan F] [PreservesColimitsOfShape (Discrete WalkingPair) F]\n    [ReflectsColimitsOfShape (Discrete WalkingPair) F] : FinitaryExtensive C := by\n  constructor\n  intros X Y c hc\n  refine IsVanKampenColimit.of_iso ?_ (hc.uniqueUpToIso (coprodIsCoprod X Y)).symm\n  have (i : Discrete WalkingPair) (Z : C) (f : Z ‚ü∂ X ‚®ø Y) :\n    PreservesLimit (cospan f ((BinaryCofan.mk coprod.inl coprod.inr).Œπ.app i)) F := by\n    rcases i with ‚ü®_|_‚ü© <;> dsimp <;> infer_instance\n  refine (FinitaryExtensive.vanKampen _\n    (isColimitOfPreserves F (coprodIsCoprod X Y))).of_mapCocone F\n\n"}
{"name":"CategoryTheory.finitaryExtensive_of_preserves_and_reflects_isomorphism","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst‚úù‚Å∂ : CategoryTheory.Category.{v'', u''} D\nF : CategoryTheory.Functor C D\ninst‚úù‚Åµ : CategoryTheory.FinitaryExtensive D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasFiniteCoproducts C\ninst‚úù¬≥ : CategoryTheory.Limits.HasPullbacks C\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan F\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst‚úù : F.ReflectsIsomorphisms\n‚ä¢ CategoryTheory.FinitaryExtensive C","decl":"theorem finitaryExtensive_of_preserves_and_reflects_isomorphism (F : C ‚•§ D) [FinitaryExtensive D]\n    [HasFiniteCoproducts C] [HasPullbacks C] [PreservesLimitsOfShape WalkingCospan F]\n    [PreservesColimitsOfShape (Discrete WalkingPair) F] [F.ReflectsIsomorphisms] :\n    FinitaryExtensive C := by\n  haveI : ReflectsLimitsOfShape WalkingCospan F := reflectsLimitsOfShape_of_reflectsIsomorphisms\n  haveI : ReflectsColimitsOfShape (Discrete WalkingPair) F :=\n    reflectsColimitsOfShape_of_reflectsIsomorphisms\n  exact finitaryExtensive_of_preserves_and_reflects F\n\n"}
{"name":"CategoryTheory.FinitaryPreExtensive.isUniversal_finiteCoproducts_Fin","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.FinitaryPreExtensive C\nn : Nat\nF : CategoryTheory.Functor (CategoryTheory.Discrete (Fin n)) C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.IsUniversalColimit c","decl":"theorem FinitaryPreExtensive.isUniversal_finiteCoproducts_Fin [FinitaryPreExtensive C] {n : ‚Ñï}\n    {F : Discrete (Fin n) ‚•§ C} {c : Cocone F} (hc : IsColimit c) : IsUniversalColimit c := by\n  let f : Fin n ‚Üí C := F.obj ‚àò Discrete.mk\n  have : F = Discrete.functor f :=\n    Functor.hext (fun _ ‚Ü¶ rfl) (by rintro ‚ü®i‚ü© ‚ü®j‚ü© ‚ü®‚ü®rfl : i = j‚ü©‚ü©; simp [f])\n  clear_value f\n  subst this\n  induction n with\n  | zero => exact (isVanKampenColimit_of_isEmpty _ hc).isUniversal\n  | succ n IH =>\n    refine IsUniversalColimit.of_iso (@isUniversalColimit_extendCofan _ _ _ _ _ _\n      (IH _ (coproductIsCoproduct _)) (FinitaryPreExtensive.universal' _ (coprodIsCoprod _ _)) ?_)\n      ((extendCofanIsColimit f (coproductIsCoproduct _) (coprodIsCoprod _ _)).uniqueUpToIso hc)\n    ¬∑ dsimp\n      infer_instance\n\n"}
{"name":"CategoryTheory.FinitaryPreExtensive.isUniversal_finiteCoproducts","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.FinitaryPreExtensive C\nŒπ : Type u_1\ninst‚úù : Finite Œπ\nF : CategoryTheory.Functor (CategoryTheory.Discrete Œπ) C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.IsUniversalColimit c","decl":"theorem FinitaryPreExtensive.isUniversal_finiteCoproducts [FinitaryPreExtensive C] {Œπ : Type*}\n    [Finite Œπ] {F : Discrete Œπ ‚•§ C} {c : Cocone F} (hc : IsColimit c) : IsUniversalColimit c := by\n  obtain ‚ü®n, ‚ü®e‚ü©‚ü© := Finite.exists_equiv_fin Œπ\n  apply (IsUniversalColimit.whiskerEquivalence_iff (Discrete.equivalence e).symm).mp\n  apply FinitaryPreExtensive.isUniversal_finiteCoproducts_Fin\n  exact (IsColimit.whiskerEquivalenceEquiv (Discrete.equivalence e).symm) hc\n\n"}
{"name":"CategoryTheory.FinitaryExtensive.isVanKampen_finiteCoproducts_Fin","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.FinitaryExtensive C\nn : Nat\nF : CategoryTheory.Functor (CategoryTheory.Discrete (Fin n)) C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.IsVanKampenColimit c","decl":"theorem FinitaryExtensive.isVanKampen_finiteCoproducts_Fin [FinitaryExtensive C] {n : ‚Ñï}\n    {F : Discrete (Fin n) ‚•§ C} {c : Cocone F} (hc : IsColimit c) : IsVanKampenColimit c := by\n  let f : Fin n ‚Üí C := F.obj ‚àò Discrete.mk\n  have : F = Discrete.functor f :=\n    Functor.hext (fun _ ‚Ü¶ rfl) (by rintro ‚ü®i‚ü© ‚ü®j‚ü© ‚ü®‚ü®rfl : i = j‚ü©‚ü©; simp [f])\n  clear_value f\n  subst this\n  induction' n with n IH\n  ¬∑ exact isVanKampenColimit_of_isEmpty _ hc\n  ¬∑ apply IsVanKampenColimit.of_iso _\n      ((extendCofanIsColimit f (coproductIsCoproduct _) (coprodIsCoprod _ _)).uniqueUpToIso hc)\n    apply @isVanKampenColimit_extendCofan _ _ _ _ _ _ _ _ ?_\n    ¬∑ apply IH\n      exact coproductIsCoproduct _\n    ¬∑ apply FinitaryExtensive.van_kampen'\n      exact coprodIsCoprod _ _\n    ¬∑ dsimp\n      infer_instance\n\n"}
{"name":"CategoryTheory.FinitaryExtensive.isVanKampen_finiteCoproducts","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.FinitaryExtensive C\nŒπ : Type u_1\ninst‚úù : Finite Œπ\nF : CategoryTheory.Functor (CategoryTheory.Discrete Œπ) C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ CategoryTheory.IsVanKampenColimit c","decl":"theorem FinitaryExtensive.isVanKampen_finiteCoproducts [FinitaryExtensive C] {Œπ : Type*}\n    [Finite Œπ] {F : Discrete Œπ ‚•§ C} {c : Cocone F} (hc : IsColimit c) : IsVanKampenColimit c := by\n  obtain ‚ü®n, ‚ü®e‚ü©‚ü© := Finite.exists_equiv_fin Œπ\n  apply (IsVanKampenColimit.whiskerEquivalence_iff (Discrete.equivalence e).symm).mp\n  apply FinitaryExtensive.isVanKampen_finiteCoproducts_Fin\n  exact (IsColimit.whiskerEquivalenceEquiv (Discrete.equivalence e).symm) hc\n\n"}
{"name":"CategoryTheory.FinitaryPreExtensive.hasPullbacks_of_is_coproduct","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.FinitaryPreExtensive C\nŒπ : Type u_1\ninst‚úù : Finite Œπ\nF : CategoryTheory.Functor (CategoryTheory.Discrete Œπ) C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\ni : CategoryTheory.Discrete Œπ\nX : C\ng : Quiver.Hom X (((CategoryTheory.Functor.const (CategoryTheory.Discrete Œπ)).obj c.pt).obj i)\n‚ä¢ CategoryTheory.Limits.HasPullback g (c.Œπ.app i)","decl":"lemma FinitaryPreExtensive.hasPullbacks_of_is_coproduct [FinitaryPreExtensive C] {Œπ : Type*}\n    [Finite Œπ] {F : Discrete Œπ ‚•§ C} {c : Cocone F} (hc : IsColimit c) (i : Discrete Œπ) {X : C}\n    (g : X ‚ü∂ _) : HasPullback g (c.Œπ.app i) := by\n  classical\n  let f : Œπ ‚Üí C := F.obj ‚àò Discrete.mk\n  have : F = Discrete.functor f :=\n    Functor.hext (fun i ‚Ü¶ rfl) (by rintro ‚ü®i‚ü© ‚ü®j‚ü© ‚ü®‚ü®rfl : i = j‚ü©‚ü©; simp [f])\n  clear_value f\n  subst this\n  change Cofan f at c\n  obtain ‚ü®i‚ü© := i\n  let e : ‚àê f ‚âÖ f i ‚®ø (‚àê fun j : ({i}·∂ú : Set Œπ) ‚Ü¶ f j) :=\n  { hom := Sigma.desc (fun j ‚Ü¶ if h : j = i then eqToHom (congr_arg f h) ‚â´ coprod.inl else\n      Sigma.Œπ (fun j : ({i}·∂ú : Set Œπ) ‚Ü¶ f j) ‚ü®j, h‚ü© ‚â´ coprod.inr)\n    inv := coprod.desc (Sigma.Œπ f i) (Sigma.desc fun j ‚Ü¶ Sigma.Œπ f j)\n    hom_inv_id := by aesop_cat\n    inv_hom_id := by\n      ext j\n      ¬∑ simp\n      ¬∑ simp only [coprod.desc_comp, colimit.Œπ_desc, Cofan.mk_pt, Cofan.mk_Œπ_app,\n          eqToHom_refl, Category.id_comp, dite_true, BinaryCofan.mk_pt, BinaryCofan.Œπ_app_right,\n          BinaryCofan.mk_inr, colimit.Œπ_desc_assoc, Discrete.functor_obj, Category.comp_id]\n        exact dif_neg j.prop }\n  let e' : c.pt ‚âÖ f i ‚®ø (‚àê fun j : ({i}·∂ú : Set Œπ) ‚Ü¶ f j) :=\n    hc.coconePointUniqueUpToIso (getColimitCocone _).2 ‚â™‚â´ e\n  have : coprod.inl ‚â´ e'.inv = c.Œπ.app ‚ü®i‚ü© := by\n    simp only [e, e', Iso.trans_inv, coprod.desc_comp, colimit.Œπ_desc, BinaryCofan.mk_pt,\n      BinaryCofan.Œπ_app_left, BinaryCofan.mk_inl]\n    exact colimit.comp_coconePointUniqueUpToIso_inv _ _\n  clear_value e'\n  rw [‚Üê this]\n  have : IsPullback (ùüô _) (g ‚â´ e'.hom) g e'.inv := IsPullback.of_horiz_isIso ‚ü®by simp‚ü©\n  exact ‚ü®‚ü®‚ü®_, ((IsPullback.of_hasPullback (g ‚â´ e'.hom) coprod.inl).paste_horiz this).isLimit‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.FinitaryExtensive.mono_Œπ","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.FinitaryExtensive C\nŒπ : Type u_1\ninst‚úù : Finite Œπ\nF : CategoryTheory.Functor (CategoryTheory.Discrete Œπ) C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\ni : CategoryTheory.Discrete Œπ\n‚ä¢ CategoryTheory.Mono (c.Œπ.app i)","decl":"lemma FinitaryExtensive.mono_Œπ [FinitaryExtensive C] {Œπ : Type*} [Finite Œπ] {F : Discrete Œπ ‚•§ C}\n    {c : Cocone F} (hc : IsColimit c) (i : Discrete Œπ) :\n    Mono (c.Œπ.app i) :=\n  mono_of_cofan_isVanKampen (isVanKampen_finiteCoproducts hc) _\n\n"}
{"name":"CategoryTheory.instMonoŒπ","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.FinitaryExtensive C\nŒπ : Type u_1\ninst‚úù : Finite Œπ\nX : Œπ ‚Üí C\ni : Œπ\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.Sigma.Œπ X i)","decl":"instance [FinitaryExtensive C] {Œπ : Type*} [Finite Œπ] (X : Œπ ‚Üí C) (i : Œπ) :\n    Mono (Sigma.Œπ X i) :=\n  FinitaryExtensive.mono_Œπ (coproductIsCoproduct _) ‚ü®i‚ü©\n\n"}
{"name":"CategoryTheory.FinitaryExtensive.isPullback_initial_to","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.FinitaryExtensive C\nŒπ : Type u_1\ninst‚úù : Finite Œπ\nF : CategoryTheory.Functor (CategoryTheory.Discrete Œπ) C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\ni j : CategoryTheory.Discrete Œπ\ne : Ne i j\n‚ä¢ CategoryTheory.IsPullback (CategoryTheory.Limits.initial.to (F.obj i)) (CategoryTheory.Limits.initial.to (F.obj j)) (c.Œπ.app i) (c.Œπ.app j)","decl":"lemma FinitaryExtensive.isPullback_initial_to [FinitaryExtensive C]\n    {Œπ : Type*} [Finite Œπ] {F : Discrete Œπ ‚•§ C}\n    {c : Cocone F} (hc : IsColimit c) (i j : Discrete Œπ) (e : i ‚â† j) :\n    IsPullback (initial.to _) (initial.to _) (c.Œπ.app i) (c.Œπ.app j) :=\n  isPullback_initial_to_of_cofan_isVanKampen (isVanKampen_finiteCoproducts hc) i j e\n\n"}
{"name":"CategoryTheory.FinitaryExtensive.isPullback_initial_to_sigma_Œπ","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.FinitaryExtensive C\nŒπ : Type u_1\ninst‚úù : Finite Œπ\nX : Œπ ‚Üí C\ni j : Œπ\ne : Ne i j\n‚ä¢ CategoryTheory.IsPullback (CategoryTheory.Limits.initial.to (X i)) (CategoryTheory.Limits.initial.to (X j)) (CategoryTheory.Limits.Sigma.Œπ X i) (CategoryTheory.Limits.Sigma.Œπ X j)","decl":"lemma FinitaryExtensive.isPullback_initial_to_sigma_Œπ [FinitaryExtensive C] {Œπ : Type*} [Finite Œπ]\n    (X : Œπ ‚Üí C) (i j : Œπ) (e : i ‚â† j) :\n    IsPullback (initial.to _) (initial.to _) (Sigma.Œπ X i) (Sigma.Œπ X j) :=\n  FinitaryExtensive.isPullback_initial_to (coproductIsCoproduct _) ‚ü®i‚ü© ‚ü®j‚ü©\n    (ne_of_apply_ne Discrete.as e)\n\n"}
{"name":"CategoryTheory.FinitaryPreExtensive.hasPullbacks_of_inclusions","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.FinitaryPreExtensive C\nX Z : C\nŒ± : Type u_1\nf : Quiver.Hom X Z\nY : Œ± ‚Üí C\ni : (a : Œ±) ‚Üí Quiver.Hom (Y a) Z\ninst‚úù : Finite Œ±\nhi : CategoryTheory.IsIso (CategoryTheory.Limits.Sigma.desc i)\na : Œ±\n‚ä¢ CategoryTheory.Limits.HasPullback f (i a)","decl":"instance FinitaryPreExtensive.hasPullbacks_of_inclusions [FinitaryPreExtensive C] {X Z : C}\n    {Œ± : Type*} (f : X ‚ü∂ Z) {Y : (a : Œ±) ‚Üí C} (i : (a : Œ±) ‚Üí Y a ‚ü∂ Z) [Finite Œ±]\n    [hi : IsIso (Sigma.desc i)] (a : Œ±) : HasPullback f (i a) := by\n  apply FinitaryPreExtensive.hasPullbacks_of_is_coproduct (c := Cofan.mk Z i)\n  exact @IsColimit.ofPointIso (t := Cofan.mk Z i) (P := _) (i := hi)\n\n"}
{"name":"CategoryTheory.FinitaryPreExtensive.sigma_desc_iso","module":"Mathlib.CategoryTheory.Extensive","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.FinitaryPreExtensive C\nŒ± : Type\ninst‚úù : Finite Œ±\nX : C\nZ : Œ± ‚Üí C\nœÄ : (a : Œ±) ‚Üí Quiver.Hom (Z a) X\nY : C\nf : Quiver.Hom Y X\nhœÄ : CategoryTheory.IsIso (CategoryTheory.Limits.Sigma.desc œÄ)\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.Sigma.desc fun x => CategoryTheory.Limits.pullback.fst f (œÄ x))","decl":"lemma FinitaryPreExtensive.sigma_desc_iso [FinitaryPreExtensive C] {Œ± : Type} [Finite Œ±] {X : C}\n    {Z : Œ± ‚Üí C} (œÄ : (a : Œ±) ‚Üí Z a ‚ü∂ X) {Y : C} (f : Y ‚ü∂ X) (hœÄ : IsIso (Sigma.desc œÄ)) :\n    IsIso (Sigma.desc ((fun _ ‚Ü¶ pullback.fst _ _) : (a : Œ±) ‚Üí pullback f (œÄ a) ‚ü∂ _)) := by\n  suffices IsColimit (Cofan.mk _ ((fun _ ‚Ü¶ pullback.fst _ _) : (a : Œ±) ‚Üí pullback f (œÄ a) ‚ü∂ _)) by\n    change IsIso (this.coconePointUniqueUpToIso (getColimitCocone _).2).inv\n    infer_instance\n  let this : IsColimit (Cofan.mk X œÄ) := by\n    refine @IsColimit.ofPointIso (t := Cofan.mk X œÄ) (P := coproductIsCoproduct Z) (i := ?_)\n    convert hœÄ\n    simp [coproductIsCoproduct]\n  refine (FinitaryPreExtensive.isUniversal_finiteCoproducts this\n    (Cofan.mk _ ((fun _ ‚Ü¶ pullback.fst _ _) : (a : Œ±) ‚Üí pullback f (œÄ a) ‚ü∂ _))\n    (Discrete.natTrans fun i ‚Ü¶ pullback.snd _ _) f ?_\n    (NatTrans.equifibered_of_discrete _) ?_).some\n  ¬∑ ext\n    simp [pullback.condition]\n  ¬∑ exact fun j ‚Ü¶ IsPullback.of_hasPullback f (œÄ j.as)\n\n"}
