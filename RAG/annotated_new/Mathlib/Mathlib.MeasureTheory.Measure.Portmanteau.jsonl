{"name":"MeasureTheory.le_measure_compl_liminf_of_limsup_measure_le","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\nι : Type u_2\nL : Filter ι\nμ : MeasureTheory.Measure Ω\nμs : ι → MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsProbabilityMeasure μ\ninst✝ : ∀ (i : ι), MeasureTheory.IsProbabilityMeasure (μs i)\nE : Set Ω\nE_mble : MeasurableSet E\nh : LE.le (Filter.limsup (fun i => (μs i) E) L) (μ E)\n⊢ LE.le (μ (HasCompl.compl E)) (Filter.liminf (fun i => (μs i) (HasCompl.compl E)) L)","decl":"theorem le_measure_compl_liminf_of_limsup_measure_le {ι : Type*} {L : Filter ι} {μ : Measure Ω}\n    {μs : ι → Measure Ω} [IsProbabilityMeasure μ] [∀ i, IsProbabilityMeasure (μs i)] {E : Set Ω}\n    (E_mble : MeasurableSet E) (h : (L.limsup fun i ↦ μs i E) ≤ μ E) :\n    μ Eᶜ ≤ L.liminf fun i ↦ μs i Eᶜ := by\n  rcases L.eq_or_neBot with rfl | hne\n  · simp only [liminf_bot, le_top]\n  have meas_Ec : μ Eᶜ = 1 - μ E := by\n    simpa only [measure_univ] using measure_compl E_mble (measure_lt_top μ E).ne\n  have meas_i_Ec : ∀ i, μs i Eᶜ = 1 - μs i E := by\n    intro i\n    simpa only [measure_univ] using measure_compl E_mble (measure_lt_top (μs i) E).ne\n  simp_rw [meas_Ec, meas_i_Ec]\n  rw [show (L.liminf fun i : ι ↦ 1 - μs i E) = L.liminf ((fun x ↦ 1 - x) ∘ fun i : ι ↦ μs i E)\n      from rfl]\n  have key := antitone_const_tsub.map_limsup_of_continuousAt (F := L)\n    (fun i ↦ μs i E) (ENNReal.continuous_sub_left ENNReal.one_ne_top).continuousAt\n  simpa [← key] using antitone_const_tsub h\n\n"}
{"name":"MeasureTheory.le_measure_liminf_of_limsup_measure_compl_le","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\nι : Type u_2\nL : Filter ι\nμ : MeasureTheory.Measure Ω\nμs : ι → MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsProbabilityMeasure μ\ninst✝ : ∀ (i : ι), MeasureTheory.IsProbabilityMeasure (μs i)\nE : Set Ω\nE_mble : MeasurableSet E\nh : LE.le (Filter.limsup (fun i => (μs i) (HasCompl.compl E)) L) (μ (HasCompl.compl E))\n⊢ LE.le (μ E) (Filter.liminf (fun i => (μs i) E) L)","decl":"theorem le_measure_liminf_of_limsup_measure_compl_le {ι : Type*} {L : Filter ι} {μ : Measure Ω}\n    {μs : ι → Measure Ω} [IsProbabilityMeasure μ] [∀ i, IsProbabilityMeasure (μs i)] {E : Set Ω}\n    (E_mble : MeasurableSet E) (h : (L.limsup fun i ↦ μs i Eᶜ) ≤ μ Eᶜ) :\n    μ E ≤ L.liminf fun i ↦ μs i E :=\n  compl_compl E ▸ le_measure_compl_liminf_of_limsup_measure_le (MeasurableSet.compl E_mble) h\n\n"}
{"name":"MeasureTheory.limsup_measure_compl_le_of_le_liminf_measure","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\nι : Type u_2\nL : Filter ι\nμ : MeasureTheory.Measure Ω\nμs : ι → MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsProbabilityMeasure μ\ninst✝ : ∀ (i : ι), MeasureTheory.IsProbabilityMeasure (μs i)\nE : Set Ω\nE_mble : MeasurableSet E\nh : LE.le (μ E) (Filter.liminf (fun i => (μs i) E) L)\n⊢ LE.le (Filter.limsup (fun i => (μs i) (HasCompl.compl E)) L) (μ (HasCompl.compl E))","decl":"theorem limsup_measure_compl_le_of_le_liminf_measure {ι : Type*} {L : Filter ι} {μ : Measure Ω}\n    {μs : ι → Measure Ω} [IsProbabilityMeasure μ] [∀ i, IsProbabilityMeasure (μs i)] {E : Set Ω}\n    (E_mble : MeasurableSet E) (h : μ E ≤ L.liminf fun i ↦ μs i E) :\n    (L.limsup fun i ↦ μs i Eᶜ) ≤ μ Eᶜ := by\n  rcases L.eq_or_neBot with rfl | hne\n  · simp only [limsup_bot, bot_le]\n  have meas_Ec : μ Eᶜ = 1 - μ E := by\n    simpa only [measure_univ] using measure_compl E_mble (measure_lt_top μ E).ne\n  have meas_i_Ec : ∀ i, μs i Eᶜ = 1 - μs i E := by\n    intro i\n    simpa only [measure_univ] using measure_compl E_mble (measure_lt_top (μs i) E).ne\n  simp_rw [meas_Ec, meas_i_Ec]\n  rw [show (L.limsup fun i : ι ↦ 1 - μs i E) = L.limsup ((fun x ↦ 1 - x) ∘ fun i : ι ↦ μs i E)\n      from rfl]\n  have key := antitone_const_tsub.map_liminf_of_continuousAt (F := L)\n    (fun i ↦ μs i E) (ENNReal.continuous_sub_left ENNReal.one_ne_top).continuousAt\n  simpa [← key] using antitone_const_tsub h\n\n"}
{"name":"MeasureTheory.limsup_measure_le_of_le_liminf_measure_compl","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\nι : Type u_2\nL : Filter ι\nμ : MeasureTheory.Measure Ω\nμs : ι → MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsProbabilityMeasure μ\ninst✝ : ∀ (i : ι), MeasureTheory.IsProbabilityMeasure (μs i)\nE : Set Ω\nE_mble : MeasurableSet E\nh : LE.le (μ (HasCompl.compl E)) (Filter.liminf (fun i => (μs i) (HasCompl.compl E)) L)\n⊢ LE.le (Filter.limsup (fun i => (μs i) E) L) (μ E)","decl":"theorem limsup_measure_le_of_le_liminf_measure_compl {ι : Type*} {L : Filter ι} {μ : Measure Ω}\n    {μs : ι → Measure Ω} [IsProbabilityMeasure μ] [∀ i, IsProbabilityMeasure (μs i)] {E : Set Ω}\n    (E_mble : MeasurableSet E) (h : μ Eᶜ ≤ L.liminf fun i ↦ μs i Eᶜ) :\n    (L.limsup fun i ↦ μs i E) ≤ μ E :=\n  compl_compl E ▸ limsup_measure_compl_le_of_le_liminf_measure (MeasurableSet.compl E_mble) h\n\n"}
{"name":"MeasureTheory.limsup_measure_closed_le_iff_liminf_measure_open_ge","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : TopologicalSpace Ω\ninst✝² : OpensMeasurableSpace Ω\nι : Type u_2\nL : Filter ι\nμ : MeasureTheory.Measure Ω\nμs : ι → MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsProbabilityMeasure μ\ninst✝ : ∀ (i : ι), MeasureTheory.IsProbabilityMeasure (μs i)\n⊢ Iff (∀ (F : Set Ω), IsClosed F → LE.le (Filter.limsup (fun i => (μs i) F) L) (μ F)) (∀ (G : Set Ω), IsOpen G → LE.le (μ G) (Filter.liminf (fun i => (μs i) G) L))","decl":"/-- One pair of implications of the portmanteau theorem:\nFor a sequence of Borel probability measures, the following two are equivalent:\n\n(C) The limsup of the measures of any closed set is at most the measure of the closed set\nunder a candidate limit measure.\n\n(O) The liminf of the measures of any open set is at least the measure of the open set\nunder a candidate limit measure.\n-/\ntheorem limsup_measure_closed_le_iff_liminf_measure_open_ge {ι : Type*} {L : Filter ι}\n    {μ : Measure Ω} {μs : ι → Measure Ω} [IsProbabilityMeasure μ]\n    [∀ i, IsProbabilityMeasure (μs i)] :\n    (∀ F, IsClosed F → (L.limsup fun i ↦ μs i F) ≤ μ F) ↔\n      ∀ G, IsOpen G → μ G ≤ L.liminf fun i ↦ μs i G := by\n  constructor\n  · intro h G G_open\n    exact le_measure_liminf_of_limsup_measure_compl_le\n      G_open.measurableSet (h Gᶜ (isClosed_compl_iff.mpr G_open))\n  · intro h F F_closed\n    exact limsup_measure_le_of_le_liminf_measure_compl\n      F_closed.measurableSet (h Fᶜ (isOpen_compl_iff.mpr F_closed))\n\n"}
{"name":"MeasureTheory.tendsto_measure_of_le_liminf_measure_of_limsup_measure_le","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\ninst✝ : MeasurableSpace Ω\nι : Type u_2\nL : Filter ι\nμ : MeasureTheory.Measure Ω\nμs : ι → MeasureTheory.Measure Ω\nE₀ E E₁ : Set Ω\nE₀_subset : HasSubset.Subset E₀ E\nsubset_E₁ : HasSubset.Subset E E₁\nnulldiff : Eq (μ (SDiff.sdiff E₁ E₀)) 0\nh_E₀ : LE.le (μ E₀) (Filter.liminf (fun i => (μs i) E₀) L)\nh_E₁ : LE.le (Filter.limsup (fun i => (μs i) E₁) L) (μ E₁)\n⊢ Filter.Tendsto (fun i => (μs i) E) L (nhds (μ E))","decl":"theorem tendsto_measure_of_le_liminf_measure_of_limsup_measure_le {ι : Type*} {L : Filter ι}\n    {μ : Measure Ω} {μs : ι → Measure Ω} {E₀ E E₁ : Set Ω} (E₀_subset : E₀ ⊆ E) (subset_E₁ : E ⊆ E₁)\n    (nulldiff : μ (E₁ \\ E₀) = 0) (h_E₀ : μ E₀ ≤ L.liminf fun i ↦ μs i E₀)\n    (h_E₁ : (L.limsup fun i ↦ μs i E₁) ≤ μ E₁) : L.Tendsto (fun i ↦ μs i E) (𝓝 (μ E)) := by\n  apply tendsto_of_le_liminf_of_limsup_le\n  · have E₀_ae_eq_E : E₀ =ᵐ[μ] E :=\n      EventuallyLE.antisymm E₀_subset.eventuallyLE\n        (subset_E₁.eventuallyLE.trans (ae_le_set.mpr nulldiff))\n    calc\n      μ E = μ E₀ := measure_congr E₀_ae_eq_E.symm\n      _ ≤ L.liminf fun i ↦ μs i E₀ := h_E₀\n      _ ≤ L.liminf fun i ↦ μs i E :=\n        liminf_le_liminf (.of_forall fun _ ↦ measure_mono E₀_subset)\n  · have E_ae_eq_E₁ : E =ᵐ[μ] E₁ :=\n      EventuallyLE.antisymm subset_E₁.eventuallyLE\n        ((ae_le_set.mpr nulldiff).trans E₀_subset.eventuallyLE)\n    calc\n      (L.limsup fun i ↦ μs i E) ≤ L.limsup fun i ↦ μs i E₁ :=\n        limsup_le_limsup (.of_forall fun _ ↦ measure_mono subset_E₁)\n      _ ≤ μ E₁ := h_E₁\n      _ = μ E := measure_congr E_ae_eq_E₁.symm\n  · infer_param\n  · infer_param\n\n"}
{"name":"MeasureTheory.tendsto_measure_of_null_frontier","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : TopologicalSpace Ω\ninst✝² : OpensMeasurableSpace Ω\nι : Type u_2\nL : Filter ι\nμ : MeasureTheory.Measure Ω\nμs : ι → MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsProbabilityMeasure μ\ninst✝ : ∀ (i : ι), MeasureTheory.IsProbabilityMeasure (μs i)\nh_opens : ∀ (G : Set Ω), IsOpen G → LE.le (μ G) (Filter.liminf (fun i => (μs i) G) L)\nE : Set Ω\nE_nullbdry : Eq (μ (frontier E)) 0\n⊢ Filter.Tendsto (fun i => (μs i) E) L (nhds (μ E))","decl":"/-- One implication of the portmanteau theorem:\nFor a sequence of Borel probability measures, if the liminf of the measures of any open set is at\nleast the measure of the open set under a candidate limit measure, then for any set whose\nboundary carries no probability mass under the candidate limit measure, then its measures under the\nsequence converge to its measure under the candidate limit measure.\n-/\ntheorem tendsto_measure_of_null_frontier {ι : Type*} {L : Filter ι} {μ : Measure Ω}\n    {μs : ι → Measure Ω} [IsProbabilityMeasure μ] [∀ i, IsProbabilityMeasure (μs i)]\n    (h_opens : ∀ G, IsOpen G → μ G ≤ L.liminf fun i ↦ μs i G) {E : Set Ω}\n    (E_nullbdry : μ (frontier E) = 0) : L.Tendsto (fun i ↦ μs i E) (𝓝 (μ E)) :=\n  haveI h_closeds : ∀ F, IsClosed F → (L.limsup fun i ↦ μs i F) ≤ μ F :=\n    limsup_measure_closed_le_iff_liminf_measure_open_ge.mpr h_opens\n  tendsto_measure_of_le_liminf_measure_of_limsup_measure_le interior_subset subset_closure\n    E_nullbdry (h_opens _ isOpen_interior) (h_closeds _ isClosed_closure)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.limsup_measure_closed_le_of_tendsto","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\nι : Type u_2\nL : Filter ι\ninst✝³ : MeasurableSpace Ω\ninst✝² : TopologicalSpace Ω\ninst✝¹ : HasOuterApproxClosed Ω\ninst✝ : OpensMeasurableSpace Ω\nμ : MeasureTheory.FiniteMeasure Ω\nμs : ι → MeasureTheory.FiniteMeasure Ω\nμs_lim : Filter.Tendsto μs L (nhds μ)\nF : Set Ω\nF_closed : IsClosed F\n⊢ LE.le (Filter.limsup (fun i => ↑(μs i) F) L) (↑μ F)","decl":"/-- One implication of the portmanteau theorem:\nWeak convergence of finite measures implies that the limsup of the measures of any closed set is\nat most the measure of the closed set under the limit measure.\n-/\ntheorem FiniteMeasure.limsup_measure_closed_le_of_tendsto {Ω ι : Type*} {L : Filter ι}\n    [MeasurableSpace Ω] [TopologicalSpace Ω] [HasOuterApproxClosed Ω]\n    [OpensMeasurableSpace Ω] {μ : FiniteMeasure Ω}\n    {μs : ι → FiniteMeasure Ω} (μs_lim : Tendsto μs L (𝓝 μ)) {F : Set Ω} (F_closed : IsClosed F) :\n    (L.limsup fun i ↦ (μs i : Measure Ω) F) ≤ (μ : Measure Ω) F := by\n  rcases L.eq_or_neBot with rfl | hne\n  · simp only [limsup_bot, bot_le]\n  apply ENNReal.le_of_forall_pos_le_add\n  intro ε ε_pos _\n  have ε_pos' := (ENNReal.half_pos (ENNReal.coe_ne_zero.mpr ε_pos.ne.symm)).ne.symm\n  let fs := F_closed.apprSeq\n  have key₁ : Tendsto (fun n ↦ ∫⁻  ω, (fs n ω : ℝ≥0∞) ∂μ) atTop (𝓝 ((μ : Measure Ω) F)) :=\n    HasOuterApproxClosed.tendsto_lintegral_apprSeq F_closed (μ : Measure Ω)\n  have room₁ : (μ : Measure Ω) F < (μ : Measure Ω) F + ε / 2 :=\n    ENNReal.lt_add_right (measure_lt_top (μ : Measure Ω) F).ne ε_pos'\n  obtain ⟨M, hM⟩ := eventually_atTop.mp <| key₁.eventually_lt_const room₁\n  have key₂ := FiniteMeasure.tendsto_iff_forall_lintegral_tendsto.mp μs_lim (fs M)\n  have room₂ :\n    (lintegral (μ : Measure Ω) fun a ↦ fs M a) <\n      (lintegral (μ : Measure Ω) fun a ↦ fs M a) + ε / 2 :=\n    ENNReal.lt_add_right (ne_of_lt ((fs M).lintegral_lt_top_of_nnreal _)) ε_pos'\n  have ev_near := key₂.eventually_le_const room₂\n  have ev_near' := ev_near.mono\n    (fun n ↦ le_trans (HasOuterApproxClosed.measure_le_lintegral F_closed (μs n) M))\n  apply (Filter.limsup_le_limsup ev_near').trans\n  rw [limsup_const]\n  apply le_trans (add_le_add (hM M rfl.le).le (le_refl (ε / 2 : ℝ≥0∞)))\n  simp only [add_assoc, ENNReal.add_halves, le_refl]\n\n"}
{"name":"MeasureTheory.ProbabilityMeasure.limsup_measure_closed_le_of_tendsto","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\nι : Type u_2\nL : Filter ι\ninst✝³ : MeasurableSpace Ω\ninst✝² : TopologicalSpace Ω\ninst✝¹ : OpensMeasurableSpace Ω\ninst✝ : HasOuterApproxClosed Ω\nμ : MeasureTheory.ProbabilityMeasure Ω\nμs : ι → MeasureTheory.ProbabilityMeasure Ω\nμs_lim : Filter.Tendsto μs L (nhds μ)\nF : Set Ω\nF_closed : IsClosed F\n⊢ LE.le (Filter.limsup (fun i => ↑(μs i) F) L) (↑μ F)","decl":"/-- One implication of the portmanteau theorem:\nWeak convergence of probability measures implies that the limsup of the measures of any closed\nset is at most the measure of the closed set under the limit probability measure.\n-/\ntheorem ProbabilityMeasure.limsup_measure_closed_le_of_tendsto {Ω ι : Type*} {L : Filter ι}\n    [MeasurableSpace Ω] [TopologicalSpace Ω] [OpensMeasurableSpace Ω] [HasOuterApproxClosed Ω]\n    {μ : ProbabilityMeasure Ω} {μs : ι → ProbabilityMeasure Ω} (μs_lim : Tendsto μs L (𝓝 μ))\n    {F : Set Ω} (F_closed : IsClosed F) :\n    (L.limsup fun i ↦ (μs i : Measure Ω) F) ≤ (μ : Measure Ω) F := by\n  apply FiniteMeasure.limsup_measure_closed_le_of_tendsto\n    ((tendsto_nhds_iff_toFiniteMeasure_tendsto_nhds L).mp μs_lim) F_closed\n\n"}
{"name":"MeasureTheory.ProbabilityMeasure.le_liminf_measure_open_of_tendsto","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\nι : Type u_2\nL : Filter ι\ninst✝³ : MeasurableSpace Ω\ninst✝² : PseudoEMetricSpace Ω\ninst✝¹ : OpensMeasurableSpace Ω\ninst✝ : HasOuterApproxClosed Ω\nμ : MeasureTheory.ProbabilityMeasure Ω\nμs : ι → MeasureTheory.ProbabilityMeasure Ω\nμs_lim : Filter.Tendsto μs L (nhds μ)\nG : Set Ω\nG_open : IsOpen G\n⊢ LE.le (↑μ G) (Filter.liminf (fun i => ↑(μs i) G) L)","decl":"/-- One implication of the portmanteau theorem:\nWeak convergence of probability measures implies that the liminf of the measures of any open set\nis at least the measure of the open set under the limit probability measure.\n-/\ntheorem ProbabilityMeasure.le_liminf_measure_open_of_tendsto {Ω ι : Type*} {L : Filter ι}\n    [MeasurableSpace Ω] [PseudoEMetricSpace Ω] [OpensMeasurableSpace Ω] [HasOuterApproxClosed Ω]\n    {μ : ProbabilityMeasure Ω} {μs : ι → ProbabilityMeasure Ω} (μs_lim : Tendsto μs L (𝓝 μ))\n    {G : Set Ω} (G_open : IsOpen G) :\n    (μ : Measure Ω) G ≤ L.liminf fun i ↦ (μs i : Measure Ω) G :=\n  haveI h_closeds : ∀ F, IsClosed F → (L.limsup fun i ↦ (μs i : Measure Ω) F) ≤ (μ : Measure Ω) F :=\n    fun _ F_closed ↦ limsup_measure_closed_le_of_tendsto μs_lim F_closed\n  le_measure_liminf_of_limsup_measure_compl_le G_open.measurableSet\n    (h_closeds _ (isClosed_compl_iff.mpr G_open))\n\n"}
{"name":"MeasureTheory.ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto'","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\nι : Type u_2\nL : Filter ι\ninst✝³ : MeasurableSpace Ω\ninst✝² : PseudoEMetricSpace Ω\ninst✝¹ : OpensMeasurableSpace Ω\ninst✝ : HasOuterApproxClosed Ω\nμ : MeasureTheory.ProbabilityMeasure Ω\nμs : ι → MeasureTheory.ProbabilityMeasure Ω\nμs_lim : Filter.Tendsto μs L (nhds μ)\nE : Set Ω\nE_nullbdry : Eq (↑μ (frontier E)) 0\n⊢ Filter.Tendsto (fun i => ↑(μs i) E) L (nhds (↑μ E))","decl":"theorem ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto' {Ω ι : Type*}\n    {L : Filter ι} [MeasurableSpace Ω] [PseudoEMetricSpace Ω] [OpensMeasurableSpace Ω]\n    [HasOuterApproxClosed Ω] {μ : ProbabilityMeasure Ω} {μs : ι → ProbabilityMeasure Ω}\n    (μs_lim : Tendsto μs L (𝓝 μ)) {E : Set Ω} (E_nullbdry : (μ : Measure Ω) (frontier E) = 0) :\n    Tendsto (fun i ↦ (μs i : Measure Ω) E) L (𝓝 ((μ : Measure Ω) E)) :=\n  haveI h_opens : ∀ G, IsOpen G → (μ : Measure Ω) G ≤ L.liminf fun i ↦ (μs i : Measure Ω) G :=\n    fun _ G_open ↦ le_liminf_measure_open_of_tendsto μs_lim G_open\n  tendsto_measure_of_null_frontier h_opens E_nullbdry\n\n"}
{"name":"MeasureTheory.ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\nι : Type u_2\nL : Filter ι\ninst✝³ : MeasurableSpace Ω\ninst✝² : PseudoEMetricSpace Ω\ninst✝¹ : OpensMeasurableSpace Ω\ninst✝ : HasOuterApproxClosed Ω\nμ : MeasureTheory.ProbabilityMeasure Ω\nμs : ι → MeasureTheory.ProbabilityMeasure Ω\nμs_lim : Filter.Tendsto μs L (nhds μ)\nE : Set Ω\nE_nullbdry : Eq (μ (frontier E)) 0\n⊢ Filter.Tendsto (fun i => (μs i) E) L (nhds (μ E))","decl":"/-- One implication of the portmanteau theorem:\nWeak convergence of probability measures implies that if the boundary of a Borel set\ncarries no probability mass under the limit measure, then the limit of the measures of the set\nequals the measure of the set under the limit probability measure.\n\nA version with coercions to ordinary `ℝ≥0∞`-valued measures is\n`MeasureTheory.ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto'`.\n-/\ntheorem ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto {Ω ι : Type*} {L : Filter ι}\n    [MeasurableSpace Ω] [PseudoEMetricSpace Ω] [OpensMeasurableSpace Ω] [HasOuterApproxClosed Ω]\n    {μ : ProbabilityMeasure Ω} {μs : ι → ProbabilityMeasure Ω} (μs_lim : Tendsto μs L (𝓝 μ))\n    {E : Set Ω} (E_nullbdry : μ (frontier E) = 0) : Tendsto (fun i ↦ μs i E) L (𝓝 (μ E)) := by\n  have key := tendsto_measure_of_null_frontier_of_tendsto' μs_lim (by simpa using E_nullbdry)\n  exact (ENNReal.tendsto_toNNReal (measure_ne_top (↑μ) E)).comp key\n\n"}
{"name":"MeasureTheory.exists_null_frontier_thickening","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\ninst✝³ : PseudoEMetricSpace Ω\ninst✝² : MeasurableSpace Ω\ninst✝¹ : OpensMeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.SFinite μ\ns : Set Ω\na b : Real\nhab : LT.lt a b\n⊢ Exists fun r => And (Membership.mem (Set.Ioo a b) r) (Eq (μ (frontier (Metric.thickening r s))) 0)","decl":"theorem exists_null_frontier_thickening (μ : Measure Ω) [SFinite μ] (s : Set Ω) {a b : ℝ}\n    (hab : a < b) : ∃ r ∈ Ioo a b, μ (frontier (Metric.thickening r s)) = 0 := by\n  have mbles : ∀ r : ℝ, MeasurableSet (frontier (Metric.thickening r s)) :=\n    fun r ↦ isClosed_frontier.measurableSet\n  have disjs := Metric.frontier_thickening_disjoint s\n  have key := Measure.countable_meas_pos_of_disjoint_iUnion (μ := μ) mbles disjs\n  have aux := measure_diff_null (s := Ioo a b) (Set.Countable.measure_zero key volume)\n  have len_pos : 0 < ENNReal.ofReal (b - a) := by simp only [hab, ENNReal.ofReal_pos, sub_pos]\n  rw [← Real.volume_Ioo, ← aux] at len_pos\n  rcases nonempty_of_measure_ne_zero len_pos.ne.symm with ⟨r, ⟨r_in_Ioo, hr⟩⟩\n  refine ⟨r, r_in_Ioo, ?_⟩\n  simpa only [mem_setOf_eq, not_lt, le_zero_iff] using hr\n\n"}
{"name":"MeasureTheory.exists_null_frontiers_thickening","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\ninst✝³ : PseudoEMetricSpace Ω\ninst✝² : MeasurableSpace Ω\ninst✝¹ : OpensMeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.SFinite μ\ns : Set Ω\n⊢ Exists fun rs => And (Filter.Tendsto rs Filter.atTop (nhds 0)) (∀ (n : Nat), And (LT.lt 0 (rs n)) (Eq (μ (frontier (Metric.thickening (rs n) s))) 0))","decl":"theorem exists_null_frontiers_thickening (μ : Measure Ω) [SFinite μ] (s : Set Ω) :\n    ∃ rs : ℕ → ℝ,\n      Tendsto rs atTop (𝓝 0) ∧ ∀ n, 0 < rs n ∧ μ (frontier (Metric.thickening (rs n) s)) = 0 := by\n  rcases exists_seq_strictAnti_tendsto (0 : ℝ) with ⟨Rs, ⟨_, ⟨Rs_pos, Rs_lim⟩⟩⟩\n  have obs := fun n : ℕ => exists_null_frontier_thickening μ s (Rs_pos n)\n  refine ⟨fun n : ℕ => (obs n).choose, ⟨?_, ?_⟩⟩\n  · exact tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds Rs_lim\n      (fun n ↦ (obs n).choose_spec.1.1.le) fun n ↦ (obs n).choose_spec.1.2.le\n  · exact fun n ↦ ⟨(obs n).choose_spec.1.1, (obs n).choose_spec.2⟩\n\n"}
{"name":"MeasureTheory.limsup_measure_closed_le_of_forall_tendsto_measure","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_2\nι : Type u_3\nL : Filter ι\ninst✝³ : MeasurableSpace Ω\ninst✝² : PseudoEMetricSpace Ω\ninst✝¹ : OpensMeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nμs : ι → MeasureTheory.Measure Ω\nh : ∀ {E : Set Ω}, MeasurableSet E → Eq (μ (frontier E)) 0 → Filter.Tendsto (fun i => (μs i) E) L (nhds (μ E))\nF : Set Ω\nF_closed : IsClosed F\n⊢ LE.le (Filter.limsup (fun i => (μs i) F) L) (μ F)","decl":"/-- One implication of the portmanteau theorem:\nAssuming that for all Borel sets E whose boundary ∂E carries no probability mass under a\ncandidate limit probability measure μ we have convergence of the measures μsᵢ(E) to μ(E),\nthen for all closed sets F we have the limsup condition limsup μsᵢ(F) ≤ μ(F). -/\nlemma limsup_measure_closed_le_of_forall_tendsto_measure\n    {Ω ι : Type*} {L : Filter ι} [MeasurableSpace Ω] [PseudoEMetricSpace Ω] [OpensMeasurableSpace Ω]\n    {μ : Measure Ω} [IsFiniteMeasure μ] {μs : ι → Measure Ω}\n    (h : ∀ {E : Set Ω}, MeasurableSet E → μ (frontier E) = 0 →\n            Tendsto (fun i ↦ μs i E) L (𝓝 (μ E)))\n    (F : Set Ω) (F_closed : IsClosed F) :\n    L.limsup (fun i ↦ μs i F) ≤ μ F := by\n  rcases L.eq_or_neBot with rfl | _\n  · simp only [limsup_bot, bot_eq_zero', zero_le]\n  have ex := exists_null_frontiers_thickening μ F\n  let rs := Classical.choose ex\n  have rs_lim : Tendsto rs atTop (𝓝 0) := (Classical.choose_spec ex).1\n  have rs_pos : ∀ n, 0 < rs n := fun n ↦ ((Classical.choose_spec ex).2 n).1\n  have rs_null : ∀ n, μ (frontier (Metric.thickening (rs n) F)) = 0 :=\n    fun n ↦ ((Classical.choose_spec ex).2 n).2\n  have Fthicks_open : ∀ n, IsOpen (Metric.thickening (rs n) F) :=\n    fun n ↦ Metric.isOpen_thickening\n  have key := fun (n : ℕ) ↦ h (Fthicks_open n).measurableSet (rs_null n)\n  apply ENNReal.le_of_forall_pos_le_add\n  intros ε ε_pos μF_finite\n  have keyB := tendsto_measure_cthickening_of_isClosed (μ := μ) (s := F)\n                ⟨1, ⟨by simp only [gt_iff_lt, zero_lt_one], measure_ne_top _ _⟩⟩ F_closed\n  have nhd : Iio (μ F + ε) ∈ 𝓝 (μ F) :=\n    Iio_mem_nhds <| ENNReal.lt_add_right μF_finite.ne (ENNReal.coe_pos.mpr ε_pos).ne'\n  specialize rs_lim (keyB nhd)\n  simp only [mem_map, mem_atTop_sets, ge_iff_le, mem_preimage, mem_Iio] at rs_lim\n  obtain ⟨m, hm⟩ := rs_lim\n  have aux : (fun i ↦ (μs i F)) ≤ᶠ[L] (fun i ↦ μs i (Metric.thickening (rs m) F)) :=\n    .of_forall <| fun i ↦ measure_mono (Metric.self_subset_thickening (rs_pos m) F)\n  refine (limsup_le_limsup aux).trans ?_\n  rw [Tendsto.limsup_eq (key m)]\n  apply (measure_mono (Metric.thickening_subset_cthickening (rs m) F)).trans (hm m rfl.le).le\n\n"}
{"name":"MeasureTheory.le_liminf_measure_open_of_forall_tendsto_measure","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_2\nι : Type u_3\nL : Filter ι\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : PseudoEMetricSpace Ω\ninst✝² : OpensMeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝¹ : MeasureTheory.IsProbabilityMeasure μ\nμs : ι → MeasureTheory.Measure Ω\ninst✝ : ∀ (i : ι), MeasureTheory.IsProbabilityMeasure (μs i)\nh : ∀ {E : Set Ω}, MeasurableSet E → Eq (μ (frontier E)) 0 → Filter.Tendsto (fun i => (μs i) E) L (nhds (μ E))\nG : Set Ω\nG_open : IsOpen G\n⊢ LE.le (μ G) (Filter.liminf (fun i => (μs i) G) L)","decl":"/-- One implication of the portmanteau theorem:\nAssuming that for all Borel sets E whose boundary ∂E carries no probability mass under a\ncandidate limit probability measure μ we have convergence of the measures μsᵢ(E) to μ(E),\nthen for all open sets G we have the limsup condition μ(G) ≤ liminf μsᵢ(G). -/\nlemma le_liminf_measure_open_of_forall_tendsto_measure\n    {Ω ι : Type*} {L : Filter ι}\n    [MeasurableSpace Ω] [PseudoEMetricSpace Ω] [OpensMeasurableSpace Ω]\n    {μ : Measure Ω} [IsProbabilityMeasure μ] {μs : ι → Measure Ω} [∀ i, IsProbabilityMeasure (μs i)]\n    (h : ∀ {E}, MeasurableSet E → μ (frontier E) = 0 → Tendsto (fun i ↦ μs i E) L (𝓝 (μ E)))\n    (G : Set Ω) (G_open : IsOpen G) :\n    μ G ≤ L.liminf (fun i ↦ μs i G) := by\n  apply le_measure_liminf_of_limsup_measure_compl_le G_open.measurableSet\n  exact limsup_measure_closed_le_of_forall_tendsto_measure h _ (isClosed_compl_iff.mpr G_open)\n\n"}
{"name":"MeasureTheory.lintegral_le_liminf_lintegral_of_forall_isOpen_measure_le_liminf_measure","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nμs : Nat → MeasureTheory.Measure Ω\nf : Ω → Real\nf_cont : Continuous f\nf_nn : LE.le 0 f\nh_opens : ∀ (G : Set Ω), IsOpen G → LE.le (μ G) (Filter.liminf (fun i => (μs i) G) Filter.atTop)\n⊢ LE.le (MeasureTheory.lintegral μ fun x => ENNReal.ofReal (f x)) (Filter.liminf (fun i => MeasureTheory.lintegral (μs i) fun x => ENNReal.ofReal (f x)) Filter.atTop)","decl":"lemma lintegral_le_liminf_lintegral_of_forall_isOpen_measure_le_liminf_measure\n    {μ : Measure Ω} {μs : ℕ → Measure Ω} {f : Ω → ℝ} (f_cont : Continuous f) (f_nn : 0 ≤ f)\n    (h_opens : ∀ G, IsOpen G → μ G ≤ atTop.liminf (fun i ↦ μs i G)) :\n    ∫⁻ x, ENNReal.ofReal (f x) ∂μ ≤ atTop.liminf (fun i ↦ ∫⁻ x, ENNReal.ofReal (f x) ∂ (μs i)) := by\n  simp_rw [lintegral_eq_lintegral_meas_lt _ (Eventually.of_forall f_nn) f_cont.aemeasurable]\n  calc  ∫⁻ (t : ℝ) in Set.Ioi 0, μ {a | t < f a}\n      ≤ ∫⁻ (t : ℝ) in Set.Ioi 0, atTop.liminf (fun i ↦ (μs i) {a | t < f a}) := ?_ -- (i)\n    _ ≤ atTop.liminf (fun i ↦ ∫⁻ (t : ℝ) in Set.Ioi 0, (μs i) {a | t < f a}) := ?_ -- (ii)\n  · -- (i)\n    exact (lintegral_mono (fun t ↦ h_opens _ (continuous_def.mp f_cont _ isOpen_Ioi))).trans\n            (le_refl _)\n  · -- (ii)\n    exact lintegral_liminf_le (fun n ↦ Antitone.measurable (fun s t hst ↦\n            measure_mono (fun ω hω ↦ lt_of_le_of_lt hst hω)))\n\n"}
{"name":"MeasureTheory.integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\ninst✝³ : MeasurableSpace Ω\ninst✝² : TopologicalSpace Ω\ninst✝¹ : OpensMeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nμs : Nat → MeasureTheory.Measure Ω\ninst✝ : ∀ (i : Nat), MeasureTheory.IsProbabilityMeasure (μs i)\nf : BoundedContinuousFunction Ω Real\nf_nn : LE.le 0 f\nh_opens : ∀ (G : Set Ω), IsOpen G → LE.le (μ G) (Filter.liminf (fun i => (μs i) G) Filter.atTop)\n⊢ LE.le (MeasureTheory.integral μ fun x => f x) (Filter.liminf (fun i => MeasureTheory.integral (μs i) fun x => f x) Filter.atTop)","decl":"lemma integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure\n    {μ : Measure Ω} {μs : ℕ → Measure Ω} [∀ i, IsProbabilityMeasure (μs i)]\n    {f : Ω →ᵇ ℝ} (f_nn : 0 ≤ f)\n    (h_opens : ∀ G, IsOpen G → μ G ≤ atTop.liminf (fun i ↦ μs i G)) :\n    ∫ x, (f x) ∂μ ≤ atTop.liminf (fun i ↦ ∫ x, (f x) ∂ (μs i)) := by\n  have same := lintegral_le_liminf_lintegral_of_forall_isOpen_measure_le_liminf_measure\n                  f.continuous f_nn h_opens\n  rw [@integral_eq_lintegral_of_nonneg_ae Ω _ μ f (Eventually.of_forall f_nn)\n        f.continuous.measurable.aestronglyMeasurable]\n  convert ENNReal.toReal_mono ?_ same\n  · simp only [fun i ↦ @integral_eq_lintegral_of_nonneg_ae Ω _ (μs i) f (Eventually.of_forall f_nn)\n                        f.continuous.measurable.aestronglyMeasurable]\n    let g := BoundedContinuousFunction.comp _ Real.lipschitzWith_toNNReal f\n    have bound : ∀ i, ∫⁻ x, ENNReal.ofReal (f x) ∂(μs i) ≤ nndist 0 g := fun i ↦ by\n      simpa only [coe_nnreal_ennreal_nndist, measure_univ, mul_one, ge_iff_le] using\n            BoundedContinuousFunction.lintegral_le_edist_mul (μ := μs i) g\n    apply ENNReal.liminf_toReal_eq ENNReal.coe_ne_top (Eventually.of_forall bound)\n  · apply ne_of_lt\n    have obs := fun (i : ℕ) ↦ @BoundedContinuousFunction.lintegral_nnnorm_le Ω _ _ (μs i) ℝ _ f\n    simp only [measure_univ, mul_one] at obs\n    apply lt_of_le_of_lt _ (show (‖f‖₊ : ℝ≥0∞) < ∞ from ENNReal.coe_lt_top)\n    apply liminf_le_of_le\n    · refine ⟨0, .of_forall (by simp only [ge_iff_le, zero_le, forall_const])⟩\n    · intro x hx\n      obtain ⟨i, hi⟩ := hx.exists\n      apply le_trans hi\n      convert obs i with x\n      have aux := ENNReal.ofReal_eq_coe_nnreal (f_nn x)\n      simp only [ContinuousMap.toFun_eq_coe, BoundedContinuousFunction.coe_toContinuousMap] at aux\n      rw [aux]\n      congr\n      exact (Real.norm_of_nonneg (f_nn x)).symm\n\n"}
{"name":"MeasureTheory.tendsto_of_forall_isOpen_le_liminf","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Ω : Type u_1\ninst✝² : MeasurableSpace Ω\ninst✝¹ : TopologicalSpace Ω\ninst✝ : OpensMeasurableSpace Ω\nμ : MeasureTheory.ProbabilityMeasure Ω\nμs : Nat → MeasureTheory.ProbabilityMeasure Ω\nh_opens : ∀ (G : Set Ω), IsOpen G → LE.le (μ G) (Filter.liminf (fun i => (μs i) G) Filter.atTop)\n⊢ Filter.Tendsto (fun i => μs i) Filter.atTop (nhds μ)","decl":"/-- One implication of the portmanteau theorem:\nIf for all open sets G we have the liminf condition `μ(G) ≤ liminf μsₙ(G)`, then the measures\nμsₙ converge weakly to the measure μ. -/\ntheorem tendsto_of_forall_isOpen_le_liminf {μ : ProbabilityMeasure Ω}\n    {μs : ℕ → ProbabilityMeasure Ω}\n    (h_opens : ∀ G, IsOpen G → μ G ≤ atTop.liminf (fun i ↦ μs i G)) :\n    atTop.Tendsto (fun i ↦ μs i) (𝓝 μ) := by\n  refine ProbabilityMeasure.tendsto_iff_forall_integral_tendsto.mpr ?_\n  apply tendsto_integral_of_forall_integral_le_liminf_integral\n  intro f f_nn\n  apply integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure (f := f) f_nn\n  intro G G_open\n  specialize h_opens G G_open\n  have aux : ENNReal.ofNNReal (liminf (fun i ↦ μs i G) atTop) =\n          liminf (ENNReal.ofNNReal ∘ fun i ↦ μs i G) atTop := by\n    refine Monotone.map_liminf_of_continuousAt (F := atTop) ENNReal.coe_mono (μs · G) ?_ ?_ ?_\n    · exact ENNReal.continuous_coe.continuousAt\n    · exact IsBoundedUnder.isCoboundedUnder_ge ⟨1, by simp⟩\n    · exact ⟨0, by simp⟩\n  have obs := ENNReal.coe_mono h_opens\n  simp only [ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure, aux] at obs\n  convert obs\n  simp only [Function.comp_apply, ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure]\n\n"}
