{"name":"MeasureTheory.le_measure_compl_liminf_of_limsup_measure_le","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\nÎ¹ : Type u_2\nL : Filter Î¹\nÎ¼ : MeasureTheory.Measure Î©\nÎ¼s : Î¹ â†’ MeasureTheory.Measure Î©\ninstâœÂ¹ : MeasureTheory.IsProbabilityMeasure Î¼\ninstâœ : âˆ€ (i : Î¹), MeasureTheory.IsProbabilityMeasure (Î¼s i)\nE : Set Î©\nE_mble : MeasurableSet E\nh : LE.le (Filter.limsup (fun i => (Î¼s i) E) L) (Î¼ E)\nâŠ¢ LE.le (Î¼ (HasCompl.compl E)) (Filter.liminf (fun i => (Î¼s i) (HasCompl.compl E)) L)","decl":"theorem le_measure_compl_liminf_of_limsup_measure_le {Î¹ : Type*} {L : Filter Î¹} {Î¼ : Measure Î©}\n    {Î¼s : Î¹ â†’ Measure Î©} [IsProbabilityMeasure Î¼] [âˆ€ i, IsProbabilityMeasure (Î¼s i)] {E : Set Î©}\n    (E_mble : MeasurableSet E) (h : (L.limsup fun i â†¦ Î¼s i E) â‰¤ Î¼ E) :\n    Î¼ Eá¶œ â‰¤ L.liminf fun i â†¦ Î¼s i Eá¶œ := by\n  rcases L.eq_or_neBot with rfl | hne\n  Â· simp only [liminf_bot, le_top]\n  have meas_Ec : Î¼ Eá¶œ = 1 - Î¼ E := by\n    simpa only [measure_univ] using measure_compl E_mble (measure_lt_top Î¼ E).ne\n  have meas_i_Ec : âˆ€ i, Î¼s i Eá¶œ = 1 - Î¼s i E := by\n    intro i\n    simpa only [measure_univ] using measure_compl E_mble (measure_lt_top (Î¼s i) E).ne\n  simp_rw [meas_Ec, meas_i_Ec]\n  rw [show (L.liminf fun i : Î¹ â†¦ 1 - Î¼s i E) = L.liminf ((fun x â†¦ 1 - x) âˆ˜ fun i : Î¹ â†¦ Î¼s i E)\n      from rfl]\n  have key := antitone_const_tsub.map_limsup_of_continuousAt (F := L)\n    (fun i â†¦ Î¼s i E) (ENNReal.continuous_sub_left ENNReal.one_ne_top).continuousAt\n  simpa [â† key] using antitone_const_tsub h\n\n"}
{"name":"MeasureTheory.le_measure_liminf_of_limsup_measure_compl_le","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\nÎ¹ : Type u_2\nL : Filter Î¹\nÎ¼ : MeasureTheory.Measure Î©\nÎ¼s : Î¹ â†’ MeasureTheory.Measure Î©\ninstâœÂ¹ : MeasureTheory.IsProbabilityMeasure Î¼\ninstâœ : âˆ€ (i : Î¹), MeasureTheory.IsProbabilityMeasure (Î¼s i)\nE : Set Î©\nE_mble : MeasurableSet E\nh : LE.le (Filter.limsup (fun i => (Î¼s i) (HasCompl.compl E)) L) (Î¼ (HasCompl.compl E))\nâŠ¢ LE.le (Î¼ E) (Filter.liminf (fun i => (Î¼s i) E) L)","decl":"theorem le_measure_liminf_of_limsup_measure_compl_le {Î¹ : Type*} {L : Filter Î¹} {Î¼ : Measure Î©}\n    {Î¼s : Î¹ â†’ Measure Î©} [IsProbabilityMeasure Î¼] [âˆ€ i, IsProbabilityMeasure (Î¼s i)] {E : Set Î©}\n    (E_mble : MeasurableSet E) (h : (L.limsup fun i â†¦ Î¼s i Eá¶œ) â‰¤ Î¼ Eá¶œ) :\n    Î¼ E â‰¤ L.liminf fun i â†¦ Î¼s i E :=\n  compl_compl E â–¸ le_measure_compl_liminf_of_limsup_measure_le (MeasurableSet.compl E_mble) h\n\n"}
{"name":"MeasureTheory.limsup_measure_compl_le_of_le_liminf_measure","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\nÎ¹ : Type u_2\nL : Filter Î¹\nÎ¼ : MeasureTheory.Measure Î©\nÎ¼s : Î¹ â†’ MeasureTheory.Measure Î©\ninstâœÂ¹ : MeasureTheory.IsProbabilityMeasure Î¼\ninstâœ : âˆ€ (i : Î¹), MeasureTheory.IsProbabilityMeasure (Î¼s i)\nE : Set Î©\nE_mble : MeasurableSet E\nh : LE.le (Î¼ E) (Filter.liminf (fun i => (Î¼s i) E) L)\nâŠ¢ LE.le (Filter.limsup (fun i => (Î¼s i) (HasCompl.compl E)) L) (Î¼ (HasCompl.compl E))","decl":"theorem limsup_measure_compl_le_of_le_liminf_measure {Î¹ : Type*} {L : Filter Î¹} {Î¼ : Measure Î©}\n    {Î¼s : Î¹ â†’ Measure Î©} [IsProbabilityMeasure Î¼] [âˆ€ i, IsProbabilityMeasure (Î¼s i)] {E : Set Î©}\n    (E_mble : MeasurableSet E) (h : Î¼ E â‰¤ L.liminf fun i â†¦ Î¼s i E) :\n    (L.limsup fun i â†¦ Î¼s i Eá¶œ) â‰¤ Î¼ Eá¶œ := by\n  rcases L.eq_or_neBot with rfl | hne\n  Â· simp only [limsup_bot, bot_le]\n  have meas_Ec : Î¼ Eá¶œ = 1 - Î¼ E := by\n    simpa only [measure_univ] using measure_compl E_mble (measure_lt_top Î¼ E).ne\n  have meas_i_Ec : âˆ€ i, Î¼s i Eá¶œ = 1 - Î¼s i E := by\n    intro i\n    simpa only [measure_univ] using measure_compl E_mble (measure_lt_top (Î¼s i) E).ne\n  simp_rw [meas_Ec, meas_i_Ec]\n  rw [show (L.limsup fun i : Î¹ â†¦ 1 - Î¼s i E) = L.limsup ((fun x â†¦ 1 - x) âˆ˜ fun i : Î¹ â†¦ Î¼s i E)\n      from rfl]\n  have key := antitone_const_tsub.map_liminf_of_continuousAt (F := L)\n    (fun i â†¦ Î¼s i E) (ENNReal.continuous_sub_left ENNReal.one_ne_top).continuousAt\n  simpa [â† key] using antitone_const_tsub h\n\n"}
{"name":"MeasureTheory.limsup_measure_le_of_le_liminf_measure_compl","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\nÎ¹ : Type u_2\nL : Filter Î¹\nÎ¼ : MeasureTheory.Measure Î©\nÎ¼s : Î¹ â†’ MeasureTheory.Measure Î©\ninstâœÂ¹ : MeasureTheory.IsProbabilityMeasure Î¼\ninstâœ : âˆ€ (i : Î¹), MeasureTheory.IsProbabilityMeasure (Î¼s i)\nE : Set Î©\nE_mble : MeasurableSet E\nh : LE.le (Î¼ (HasCompl.compl E)) (Filter.liminf (fun i => (Î¼s i) (HasCompl.compl E)) L)\nâŠ¢ LE.le (Filter.limsup (fun i => (Î¼s i) E) L) (Î¼ E)","decl":"theorem limsup_measure_le_of_le_liminf_measure_compl {Î¹ : Type*} {L : Filter Î¹} {Î¼ : Measure Î©}\n    {Î¼s : Î¹ â†’ Measure Î©} [IsProbabilityMeasure Î¼] [âˆ€ i, IsProbabilityMeasure (Î¼s i)] {E : Set Î©}\n    (E_mble : MeasurableSet E) (h : Î¼ Eá¶œ â‰¤ L.liminf fun i â†¦ Î¼s i Eá¶œ) :\n    (L.limsup fun i â†¦ Î¼s i E) â‰¤ Î¼ E :=\n  compl_compl E â–¸ limsup_measure_compl_le_of_le_liminf_measure (MeasurableSet.compl E_mble) h\n\n"}
{"name":"MeasureTheory.limsup_measure_closed_le_iff_liminf_measure_open_ge","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\ninstâœâ´ : MeasurableSpace Î©\ninstâœÂ³ : TopologicalSpace Î©\ninstâœÂ² : OpensMeasurableSpace Î©\nÎ¹ : Type u_2\nL : Filter Î¹\nÎ¼ : MeasureTheory.Measure Î©\nÎ¼s : Î¹ â†’ MeasureTheory.Measure Î©\ninstâœÂ¹ : MeasureTheory.IsProbabilityMeasure Î¼\ninstâœ : âˆ€ (i : Î¹), MeasureTheory.IsProbabilityMeasure (Î¼s i)\nâŠ¢ Iff (âˆ€ (F : Set Î©), IsClosed F â†’ LE.le (Filter.limsup (fun i => (Î¼s i) F) L) (Î¼ F)) (âˆ€ (G : Set Î©), IsOpen G â†’ LE.le (Î¼ G) (Filter.liminf (fun i => (Î¼s i) G) L))","decl":"/-- One pair of implications of the portmanteau theorem:\nFor a sequence of Borel probability measures, the following two are equivalent:\n\n(C) The limsup of the measures of any closed set is at most the measure of the closed set\nunder a candidate limit measure.\n\n(O) The liminf of the measures of any open set is at least the measure of the open set\nunder a candidate limit measure.\n-/\ntheorem limsup_measure_closed_le_iff_liminf_measure_open_ge {Î¹ : Type*} {L : Filter Î¹}\n    {Î¼ : Measure Î©} {Î¼s : Î¹ â†’ Measure Î©} [IsProbabilityMeasure Î¼]\n    [âˆ€ i, IsProbabilityMeasure (Î¼s i)] :\n    (âˆ€ F, IsClosed F â†’ (L.limsup fun i â†¦ Î¼s i F) â‰¤ Î¼ F) â†”\n      âˆ€ G, IsOpen G â†’ Î¼ G â‰¤ L.liminf fun i â†¦ Î¼s i G := by\n  constructor\n  Â· intro h G G_open\n    exact le_measure_liminf_of_limsup_measure_compl_le\n      G_open.measurableSet (h Gá¶œ (isClosed_compl_iff.mpr G_open))\n  Â· intro h F F_closed\n    exact limsup_measure_le_of_le_liminf_measure_compl\n      F_closed.measurableSet (h Fá¶œ (isOpen_compl_iff.mpr F_closed))\n\n"}
{"name":"MeasureTheory.tendsto_measure_of_le_liminf_measure_of_limsup_measure_le","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\ninstâœ : MeasurableSpace Î©\nÎ¹ : Type u_2\nL : Filter Î¹\nÎ¼ : MeasureTheory.Measure Î©\nÎ¼s : Î¹ â†’ MeasureTheory.Measure Î©\nEâ‚€ E Eâ‚ : Set Î©\nEâ‚€_subset : HasSubset.Subset Eâ‚€ E\nsubset_Eâ‚ : HasSubset.Subset E Eâ‚\nnulldiff : Eq (Î¼ (SDiff.sdiff Eâ‚ Eâ‚€)) 0\nh_Eâ‚€ : LE.le (Î¼ Eâ‚€) (Filter.liminf (fun i => (Î¼s i) Eâ‚€) L)\nh_Eâ‚ : LE.le (Filter.limsup (fun i => (Î¼s i) Eâ‚) L) (Î¼ Eâ‚)\nâŠ¢ Filter.Tendsto (fun i => (Î¼s i) E) L (nhds (Î¼ E))","decl":"theorem tendsto_measure_of_le_liminf_measure_of_limsup_measure_le {Î¹ : Type*} {L : Filter Î¹}\n    {Î¼ : Measure Î©} {Î¼s : Î¹ â†’ Measure Î©} {Eâ‚€ E Eâ‚ : Set Î©} (Eâ‚€_subset : Eâ‚€ âŠ† E) (subset_Eâ‚ : E âŠ† Eâ‚)\n    (nulldiff : Î¼ (Eâ‚ \\ Eâ‚€) = 0) (h_Eâ‚€ : Î¼ Eâ‚€ â‰¤ L.liminf fun i â†¦ Î¼s i Eâ‚€)\n    (h_Eâ‚ : (L.limsup fun i â†¦ Î¼s i Eâ‚) â‰¤ Î¼ Eâ‚) : L.Tendsto (fun i â†¦ Î¼s i E) (ğ“ (Î¼ E)) := by\n  apply tendsto_of_le_liminf_of_limsup_le\n  Â· have Eâ‚€_ae_eq_E : Eâ‚€ =áµ[Î¼] E :=\n      EventuallyLE.antisymm Eâ‚€_subset.eventuallyLE\n        (subset_Eâ‚.eventuallyLE.trans (ae_le_set.mpr nulldiff))\n    calc\n      Î¼ E = Î¼ Eâ‚€ := measure_congr Eâ‚€_ae_eq_E.symm\n      _ â‰¤ L.liminf fun i â†¦ Î¼s i Eâ‚€ := h_Eâ‚€\n      _ â‰¤ L.liminf fun i â†¦ Î¼s i E :=\n        liminf_le_liminf (.of_forall fun _ â†¦ measure_mono Eâ‚€_subset)\n  Â· have E_ae_eq_Eâ‚ : E =áµ[Î¼] Eâ‚ :=\n      EventuallyLE.antisymm subset_Eâ‚.eventuallyLE\n        ((ae_le_set.mpr nulldiff).trans Eâ‚€_subset.eventuallyLE)\n    calc\n      (L.limsup fun i â†¦ Î¼s i E) â‰¤ L.limsup fun i â†¦ Î¼s i Eâ‚ :=\n        limsup_le_limsup (.of_forall fun _ â†¦ measure_mono subset_Eâ‚)\n      _ â‰¤ Î¼ Eâ‚ := h_Eâ‚\n      _ = Î¼ E := measure_congr E_ae_eq_Eâ‚.symm\n  Â· infer_param\n  Â· infer_param\n\n"}
{"name":"MeasureTheory.tendsto_measure_of_null_frontier","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\ninstâœâ´ : MeasurableSpace Î©\ninstâœÂ³ : TopologicalSpace Î©\ninstâœÂ² : OpensMeasurableSpace Î©\nÎ¹ : Type u_2\nL : Filter Î¹\nÎ¼ : MeasureTheory.Measure Î©\nÎ¼s : Î¹ â†’ MeasureTheory.Measure Î©\ninstâœÂ¹ : MeasureTheory.IsProbabilityMeasure Î¼\ninstâœ : âˆ€ (i : Î¹), MeasureTheory.IsProbabilityMeasure (Î¼s i)\nh_opens : âˆ€ (G : Set Î©), IsOpen G â†’ LE.le (Î¼ G) (Filter.liminf (fun i => (Î¼s i) G) L)\nE : Set Î©\nE_nullbdry : Eq (Î¼ (frontier E)) 0\nâŠ¢ Filter.Tendsto (fun i => (Î¼s i) E) L (nhds (Î¼ E))","decl":"/-- One implication of the portmanteau theorem:\nFor a sequence of Borel probability measures, if the liminf of the measures of any open set is at\nleast the measure of the open set under a candidate limit measure, then for any set whose\nboundary carries no probability mass under the candidate limit measure, then its measures under the\nsequence converge to its measure under the candidate limit measure.\n-/\ntheorem tendsto_measure_of_null_frontier {Î¹ : Type*} {L : Filter Î¹} {Î¼ : Measure Î©}\n    {Î¼s : Î¹ â†’ Measure Î©} [IsProbabilityMeasure Î¼] [âˆ€ i, IsProbabilityMeasure (Î¼s i)]\n    (h_opens : âˆ€ G, IsOpen G â†’ Î¼ G â‰¤ L.liminf fun i â†¦ Î¼s i G) {E : Set Î©}\n    (E_nullbdry : Î¼ (frontier E) = 0) : L.Tendsto (fun i â†¦ Î¼s i E) (ğ“ (Î¼ E)) :=\n  haveI h_closeds : âˆ€ F, IsClosed F â†’ (L.limsup fun i â†¦ Î¼s i F) â‰¤ Î¼ F :=\n    limsup_measure_closed_le_iff_liminf_measure_open_ge.mpr h_opens\n  tendsto_measure_of_le_liminf_measure_of_limsup_measure_le interior_subset subset_closure\n    E_nullbdry (h_opens _ isOpen_interior) (h_closeds _ isClosed_closure)\n\n"}
{"name":"MeasureTheory.FiniteMeasure.limsup_measure_closed_le_of_tendsto","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_2\nL : Filter Î¹\ninstâœÂ³ : MeasurableSpace Î©\ninstâœÂ² : TopologicalSpace Î©\ninstâœÂ¹ : HasOuterApproxClosed Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.FiniteMeasure Î©\nÎ¼s : Î¹ â†’ MeasureTheory.FiniteMeasure Î©\nÎ¼s_lim : Filter.Tendsto Î¼s L (nhds Î¼)\nF : Set Î©\nF_closed : IsClosed F\nâŠ¢ LE.le (Filter.limsup (fun i => â†‘(Î¼s i) F) L) (â†‘Î¼ F)","decl":"/-- One implication of the portmanteau theorem:\nWeak convergence of finite measures implies that the limsup of the measures of any closed set is\nat most the measure of the closed set under the limit measure.\n-/\ntheorem FiniteMeasure.limsup_measure_closed_le_of_tendsto {Î© Î¹ : Type*} {L : Filter Î¹}\n    [MeasurableSpace Î©] [TopologicalSpace Î©] [HasOuterApproxClosed Î©]\n    [OpensMeasurableSpace Î©] {Î¼ : FiniteMeasure Î©}\n    {Î¼s : Î¹ â†’ FiniteMeasure Î©} (Î¼s_lim : Tendsto Î¼s L (ğ“ Î¼)) {F : Set Î©} (F_closed : IsClosed F) :\n    (L.limsup fun i â†¦ (Î¼s i : Measure Î©) F) â‰¤ (Î¼ : Measure Î©) F := by\n  rcases L.eq_or_neBot with rfl | hne\n  Â· simp only [limsup_bot, bot_le]\n  apply ENNReal.le_of_forall_pos_le_add\n  intro Îµ Îµ_pos _\n  have Îµ_pos' := (ENNReal.half_pos (ENNReal.coe_ne_zero.mpr Îµ_pos.ne.symm)).ne.symm\n  let fs := F_closed.apprSeq\n  have keyâ‚ : Tendsto (fun n â†¦ âˆ«â»  Ï‰, (fs n Ï‰ : â„â‰¥0âˆ) âˆ‚Î¼) atTop (ğ“ ((Î¼ : Measure Î©) F)) :=\n    HasOuterApproxClosed.tendsto_lintegral_apprSeq F_closed (Î¼ : Measure Î©)\n  have roomâ‚ : (Î¼ : Measure Î©) F < (Î¼ : Measure Î©) F + Îµ / 2 :=\n    ENNReal.lt_add_right (measure_lt_top (Î¼ : Measure Î©) F).ne Îµ_pos'\n  obtain âŸ¨M, hMâŸ© := eventually_atTop.mp <| keyâ‚.eventually_lt_const roomâ‚\n  have keyâ‚‚ := FiniteMeasure.tendsto_iff_forall_lintegral_tendsto.mp Î¼s_lim (fs M)\n  have roomâ‚‚ :\n    (lintegral (Î¼ : Measure Î©) fun a â†¦ fs M a) <\n      (lintegral (Î¼ : Measure Î©) fun a â†¦ fs M a) + Îµ / 2 :=\n    ENNReal.lt_add_right (ne_of_lt ((fs M).lintegral_lt_top_of_nnreal _)) Îµ_pos'\n  have ev_near := keyâ‚‚.eventually_le_const roomâ‚‚\n  have ev_near' := ev_near.mono\n    (fun n â†¦ le_trans (HasOuterApproxClosed.measure_le_lintegral F_closed (Î¼s n) M))\n  apply (Filter.limsup_le_limsup ev_near').trans\n  rw [limsup_const]\n  apply le_trans (add_le_add (hM M rfl.le).le (le_refl (Îµ / 2 : â„â‰¥0âˆ)))\n  simp only [add_assoc, ENNReal.add_halves, le_refl]\n\n"}
{"name":"MeasureTheory.ProbabilityMeasure.limsup_measure_closed_le_of_tendsto","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_2\nL : Filter Î¹\ninstâœÂ³ : MeasurableSpace Î©\ninstâœÂ² : TopologicalSpace Î©\ninstâœÂ¹ : OpensMeasurableSpace Î©\ninstâœ : HasOuterApproxClosed Î©\nÎ¼ : MeasureTheory.ProbabilityMeasure Î©\nÎ¼s : Î¹ â†’ MeasureTheory.ProbabilityMeasure Î©\nÎ¼s_lim : Filter.Tendsto Î¼s L (nhds Î¼)\nF : Set Î©\nF_closed : IsClosed F\nâŠ¢ LE.le (Filter.limsup (fun i => â†‘(Î¼s i) F) L) (â†‘Î¼ F)","decl":"/-- One implication of the portmanteau theorem:\nWeak convergence of probability measures implies that the limsup of the measures of any closed\nset is at most the measure of the closed set under the limit probability measure.\n-/\ntheorem ProbabilityMeasure.limsup_measure_closed_le_of_tendsto {Î© Î¹ : Type*} {L : Filter Î¹}\n    [MeasurableSpace Î©] [TopologicalSpace Î©] [OpensMeasurableSpace Î©] [HasOuterApproxClosed Î©]\n    {Î¼ : ProbabilityMeasure Î©} {Î¼s : Î¹ â†’ ProbabilityMeasure Î©} (Î¼s_lim : Tendsto Î¼s L (ğ“ Î¼))\n    {F : Set Î©} (F_closed : IsClosed F) :\n    (L.limsup fun i â†¦ (Î¼s i : Measure Î©) F) â‰¤ (Î¼ : Measure Î©) F := by\n  apply FiniteMeasure.limsup_measure_closed_le_of_tendsto\n    ((tendsto_nhds_iff_toFiniteMeasure_tendsto_nhds L).mp Î¼s_lim) F_closed\n\n"}
{"name":"MeasureTheory.ProbabilityMeasure.le_liminf_measure_open_of_tendsto","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_2\nL : Filter Î¹\ninstâœÂ³ : MeasurableSpace Î©\ninstâœÂ² : PseudoEMetricSpace Î©\ninstâœÂ¹ : OpensMeasurableSpace Î©\ninstâœ : HasOuterApproxClosed Î©\nÎ¼ : MeasureTheory.ProbabilityMeasure Î©\nÎ¼s : Î¹ â†’ MeasureTheory.ProbabilityMeasure Î©\nÎ¼s_lim : Filter.Tendsto Î¼s L (nhds Î¼)\nG : Set Î©\nG_open : IsOpen G\nâŠ¢ LE.le (â†‘Î¼ G) (Filter.liminf (fun i => â†‘(Î¼s i) G) L)","decl":"/-- One implication of the portmanteau theorem:\nWeak convergence of probability measures implies that the liminf of the measures of any open set\nis at least the measure of the open set under the limit probability measure.\n-/\ntheorem ProbabilityMeasure.le_liminf_measure_open_of_tendsto {Î© Î¹ : Type*} {L : Filter Î¹}\n    [MeasurableSpace Î©] [PseudoEMetricSpace Î©] [OpensMeasurableSpace Î©] [HasOuterApproxClosed Î©]\n    {Î¼ : ProbabilityMeasure Î©} {Î¼s : Î¹ â†’ ProbabilityMeasure Î©} (Î¼s_lim : Tendsto Î¼s L (ğ“ Î¼))\n    {G : Set Î©} (G_open : IsOpen G) :\n    (Î¼ : Measure Î©) G â‰¤ L.liminf fun i â†¦ (Î¼s i : Measure Î©) G :=\n  haveI h_closeds : âˆ€ F, IsClosed F â†’ (L.limsup fun i â†¦ (Î¼s i : Measure Î©) F) â‰¤ (Î¼ : Measure Î©) F :=\n    fun _ F_closed â†¦ limsup_measure_closed_le_of_tendsto Î¼s_lim F_closed\n  le_measure_liminf_of_limsup_measure_compl_le G_open.measurableSet\n    (h_closeds _ (isClosed_compl_iff.mpr G_open))\n\n"}
{"name":"MeasureTheory.ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto'","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_2\nL : Filter Î¹\ninstâœÂ³ : MeasurableSpace Î©\ninstâœÂ² : PseudoEMetricSpace Î©\ninstâœÂ¹ : OpensMeasurableSpace Î©\ninstâœ : HasOuterApproxClosed Î©\nÎ¼ : MeasureTheory.ProbabilityMeasure Î©\nÎ¼s : Î¹ â†’ MeasureTheory.ProbabilityMeasure Î©\nÎ¼s_lim : Filter.Tendsto Î¼s L (nhds Î¼)\nE : Set Î©\nE_nullbdry : Eq (â†‘Î¼ (frontier E)) 0\nâŠ¢ Filter.Tendsto (fun i => â†‘(Î¼s i) E) L (nhds (â†‘Î¼ E))","decl":"theorem ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto' {Î© Î¹ : Type*}\n    {L : Filter Î¹} [MeasurableSpace Î©] [PseudoEMetricSpace Î©] [OpensMeasurableSpace Î©]\n    [HasOuterApproxClosed Î©] {Î¼ : ProbabilityMeasure Î©} {Î¼s : Î¹ â†’ ProbabilityMeasure Î©}\n    (Î¼s_lim : Tendsto Î¼s L (ğ“ Î¼)) {E : Set Î©} (E_nullbdry : (Î¼ : Measure Î©) (frontier E) = 0) :\n    Tendsto (fun i â†¦ (Î¼s i : Measure Î©) E) L (ğ“ ((Î¼ : Measure Î©) E)) :=\n  haveI h_opens : âˆ€ G, IsOpen G â†’ (Î¼ : Measure Î©) G â‰¤ L.liminf fun i â†¦ (Î¼s i : Measure Î©) G :=\n    fun _ G_open â†¦ le_liminf_measure_open_of_tendsto Î¼s_lim G_open\n  tendsto_measure_of_null_frontier h_opens E_nullbdry\n\n"}
{"name":"MeasureTheory.ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_2\nL : Filter Î¹\ninstâœÂ³ : MeasurableSpace Î©\ninstâœÂ² : PseudoEMetricSpace Î©\ninstâœÂ¹ : OpensMeasurableSpace Î©\ninstâœ : HasOuterApproxClosed Î©\nÎ¼ : MeasureTheory.ProbabilityMeasure Î©\nÎ¼s : Î¹ â†’ MeasureTheory.ProbabilityMeasure Î©\nÎ¼s_lim : Filter.Tendsto Î¼s L (nhds Î¼)\nE : Set Î©\nE_nullbdry : Eq (Î¼ (frontier E)) 0\nâŠ¢ Filter.Tendsto (fun i => (Î¼s i) E) L (nhds (Î¼ E))","decl":"/-- One implication of the portmanteau theorem:\nWeak convergence of probability measures implies that if the boundary of a Borel set\ncarries no probability mass under the limit measure, then the limit of the measures of the set\nequals the measure of the set under the limit probability measure.\n\nA version with coercions to ordinary `â„â‰¥0âˆ`-valued measures is\n`MeasureTheory.ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto'`.\n-/\ntheorem ProbabilityMeasure.tendsto_measure_of_null_frontier_of_tendsto {Î© Î¹ : Type*} {L : Filter Î¹}\n    [MeasurableSpace Î©] [PseudoEMetricSpace Î©] [OpensMeasurableSpace Î©] [HasOuterApproxClosed Î©]\n    {Î¼ : ProbabilityMeasure Î©} {Î¼s : Î¹ â†’ ProbabilityMeasure Î©} (Î¼s_lim : Tendsto Î¼s L (ğ“ Î¼))\n    {E : Set Î©} (E_nullbdry : Î¼ (frontier E) = 0) : Tendsto (fun i â†¦ Î¼s i E) L (ğ“ (Î¼ E)) := by\n  have key := tendsto_measure_of_null_frontier_of_tendsto' Î¼s_lim (by simpa using E_nullbdry)\n  exact (ENNReal.tendsto_toNNReal (measure_ne_top (â†‘Î¼) E)).comp key\n\n"}
{"name":"MeasureTheory.exists_null_frontier_thickening","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\ninstâœÂ³ : PseudoEMetricSpace Î©\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\ninstâœ : MeasureTheory.SFinite Î¼\ns : Set Î©\na b : Real\nhab : LT.lt a b\nâŠ¢ Exists fun r => And (Membership.mem (Set.Ioo a b) r) (Eq (Î¼ (frontier (Metric.thickening r s))) 0)","decl":"theorem exists_null_frontier_thickening (Î¼ : Measure Î©) [SFinite Î¼] (s : Set Î©) {a b : â„}\n    (hab : a < b) : âˆƒ r âˆˆ Ioo a b, Î¼ (frontier (Metric.thickening r s)) = 0 := by\n  have mbles : âˆ€ r : â„, MeasurableSet (frontier (Metric.thickening r s)) :=\n    fun r â†¦ isClosed_frontier.measurableSet\n  have disjs := Metric.frontier_thickening_disjoint s\n  have key := Measure.countable_meas_pos_of_disjoint_iUnion (Î¼ := Î¼) mbles disjs\n  have aux := measure_diff_null (s := Ioo a b) (Set.Countable.measure_zero key volume)\n  have len_pos : 0 < ENNReal.ofReal (b - a) := by simp only [hab, ENNReal.ofReal_pos, sub_pos]\n  rw [â† Real.volume_Ioo, â† aux] at len_pos\n  rcases nonempty_of_measure_ne_zero len_pos.ne.symm with âŸ¨r, âŸ¨r_in_Ioo, hrâŸ©âŸ©\n  refine âŸ¨r, r_in_Ioo, ?_âŸ©\n  simpa only [mem_setOf_eq, not_lt, le_zero_iff] using hr\n\n"}
{"name":"MeasureTheory.exists_null_frontiers_thickening","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\ninstâœÂ³ : PseudoEMetricSpace Î©\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\ninstâœ : MeasureTheory.SFinite Î¼\ns : Set Î©\nâŠ¢ Exists fun rs => And (Filter.Tendsto rs Filter.atTop (nhds 0)) (âˆ€ (n : Nat), And (LT.lt 0 (rs n)) (Eq (Î¼ (frontier (Metric.thickening (rs n) s))) 0))","decl":"theorem exists_null_frontiers_thickening (Î¼ : Measure Î©) [SFinite Î¼] (s : Set Î©) :\n    âˆƒ rs : â„• â†’ â„,\n      Tendsto rs atTop (ğ“ 0) âˆ§ âˆ€ n, 0 < rs n âˆ§ Î¼ (frontier (Metric.thickening (rs n) s)) = 0 := by\n  rcases exists_seq_strictAnti_tendsto (0 : â„) with âŸ¨Rs, âŸ¨_, âŸ¨Rs_pos, Rs_limâŸ©âŸ©âŸ©\n  have obs := fun n : â„• => exists_null_frontier_thickening Î¼ s (Rs_pos n)\n  refine âŸ¨fun n : â„• => (obs n).choose, âŸ¨?_, ?_âŸ©âŸ©\n  Â· exact tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds Rs_lim\n      (fun n â†¦ (obs n).choose_spec.1.1.le) fun n â†¦ (obs n).choose_spec.1.2.le\n  Â· exact fun n â†¦ âŸ¨(obs n).choose_spec.1.1, (obs n).choose_spec.2âŸ©\n\n"}
{"name":"MeasureTheory.limsup_measure_closed_le_of_forall_tendsto_measure","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_2\nÎ¹ : Type u_3\nL : Filter Î¹\ninstâœÂ³ : MeasurableSpace Î©\ninstâœÂ² : PseudoEMetricSpace Î©\ninstâœÂ¹ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nÎ¼s : Î¹ â†’ MeasureTheory.Measure Î©\nh : âˆ€ {E : Set Î©}, MeasurableSet E â†’ Eq (Î¼ (frontier E)) 0 â†’ Filter.Tendsto (fun i => (Î¼s i) E) L (nhds (Î¼ E))\nF : Set Î©\nF_closed : IsClosed F\nâŠ¢ LE.le (Filter.limsup (fun i => (Î¼s i) F) L) (Î¼ F)","decl":"/-- One implication of the portmanteau theorem:\nAssuming that for all Borel sets E whose boundary âˆ‚E carries no probability mass under a\ncandidate limit probability measure Î¼ we have convergence of the measures Î¼sáµ¢(E) to Î¼(E),\nthen for all closed sets F we have the limsup condition limsup Î¼sáµ¢(F) â‰¤ Î¼(F). -/\nlemma limsup_measure_closed_le_of_forall_tendsto_measure\n    {Î© Î¹ : Type*} {L : Filter Î¹} [MeasurableSpace Î©] [PseudoEMetricSpace Î©] [OpensMeasurableSpace Î©]\n    {Î¼ : Measure Î©} [IsFiniteMeasure Î¼] {Î¼s : Î¹ â†’ Measure Î©}\n    (h : âˆ€ {E : Set Î©}, MeasurableSet E â†’ Î¼ (frontier E) = 0 â†’\n            Tendsto (fun i â†¦ Î¼s i E) L (ğ“ (Î¼ E)))\n    (F : Set Î©) (F_closed : IsClosed F) :\n    L.limsup (fun i â†¦ Î¼s i F) â‰¤ Î¼ F := by\n  rcases L.eq_or_neBot with rfl | _\n  Â· simp only [limsup_bot, bot_eq_zero', zero_le]\n  have ex := exists_null_frontiers_thickening Î¼ F\n  let rs := Classical.choose ex\n  have rs_lim : Tendsto rs atTop (ğ“ 0) := (Classical.choose_spec ex).1\n  have rs_pos : âˆ€ n, 0 < rs n := fun n â†¦ ((Classical.choose_spec ex).2 n).1\n  have rs_null : âˆ€ n, Î¼ (frontier (Metric.thickening (rs n) F)) = 0 :=\n    fun n â†¦ ((Classical.choose_spec ex).2 n).2\n  have Fthicks_open : âˆ€ n, IsOpen (Metric.thickening (rs n) F) :=\n    fun n â†¦ Metric.isOpen_thickening\n  have key := fun (n : â„•) â†¦ h (Fthicks_open n).measurableSet (rs_null n)\n  apply ENNReal.le_of_forall_pos_le_add\n  intros Îµ Îµ_pos Î¼F_finite\n  have keyB := tendsto_measure_cthickening_of_isClosed (Î¼ := Î¼) (s := F)\n                âŸ¨1, âŸ¨by simp only [gt_iff_lt, zero_lt_one], measure_ne_top _ _âŸ©âŸ© F_closed\n  have nhd : Iio (Î¼ F + Îµ) âˆˆ ğ“ (Î¼ F) :=\n    Iio_mem_nhds <| ENNReal.lt_add_right Î¼F_finite.ne (ENNReal.coe_pos.mpr Îµ_pos).ne'\n  specialize rs_lim (keyB nhd)\n  simp only [mem_map, mem_atTop_sets, ge_iff_le, mem_preimage, mem_Iio] at rs_lim\n  obtain âŸ¨m, hmâŸ© := rs_lim\n  have aux : (fun i â†¦ (Î¼s i F)) â‰¤á¶ [L] (fun i â†¦ Î¼s i (Metric.thickening (rs m) F)) :=\n    .of_forall <| fun i â†¦ measure_mono (Metric.self_subset_thickening (rs_pos m) F)\n  refine (limsup_le_limsup aux).trans ?_\n  rw [Tendsto.limsup_eq (key m)]\n  apply (measure_mono (Metric.thickening_subset_cthickening (rs m) F)).trans (hm m rfl.le).le\n\n"}
{"name":"MeasureTheory.le_liminf_measure_open_of_forall_tendsto_measure","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_2\nÎ¹ : Type u_3\nL : Filter Î¹\ninstâœâ´ : MeasurableSpace Î©\ninstâœÂ³ : PseudoEMetricSpace Î©\ninstâœÂ² : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\ninstâœÂ¹ : MeasureTheory.IsProbabilityMeasure Î¼\nÎ¼s : Î¹ â†’ MeasureTheory.Measure Î©\ninstâœ : âˆ€ (i : Î¹), MeasureTheory.IsProbabilityMeasure (Î¼s i)\nh : âˆ€ {E : Set Î©}, MeasurableSet E â†’ Eq (Î¼ (frontier E)) 0 â†’ Filter.Tendsto (fun i => (Î¼s i) E) L (nhds (Î¼ E))\nG : Set Î©\nG_open : IsOpen G\nâŠ¢ LE.le (Î¼ G) (Filter.liminf (fun i => (Î¼s i) G) L)","decl":"/-- One implication of the portmanteau theorem:\nAssuming that for all Borel sets E whose boundary âˆ‚E carries no probability mass under a\ncandidate limit probability measure Î¼ we have convergence of the measures Î¼sáµ¢(E) to Î¼(E),\nthen for all open sets G we have the limsup condition Î¼(G) â‰¤ liminf Î¼sáµ¢(G). -/\nlemma le_liminf_measure_open_of_forall_tendsto_measure\n    {Î© Î¹ : Type*} {L : Filter Î¹}\n    [MeasurableSpace Î©] [PseudoEMetricSpace Î©] [OpensMeasurableSpace Î©]\n    {Î¼ : Measure Î©} [IsProbabilityMeasure Î¼] {Î¼s : Î¹ â†’ Measure Î©} [âˆ€ i, IsProbabilityMeasure (Î¼s i)]\n    (h : âˆ€ {E}, MeasurableSet E â†’ Î¼ (frontier E) = 0 â†’ Tendsto (fun i â†¦ Î¼s i E) L (ğ“ (Î¼ E)))\n    (G : Set Î©) (G_open : IsOpen G) :\n    Î¼ G â‰¤ L.liminf (fun i â†¦ Î¼s i G) := by\n  apply le_measure_liminf_of_limsup_measure_compl_le G_open.measurableSet\n  exact limsup_measure_closed_le_of_forall_tendsto_measure h _ (isClosed_compl_iff.mpr G_open)\n\n"}
{"name":"MeasureTheory.lintegral_le_liminf_lintegral_of_forall_isOpen_measure_le_liminf_measure","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÎ¼s : Nat â†’ MeasureTheory.Measure Î©\nf : Î© â†’ Real\nf_cont : Continuous f\nf_nn : LE.le 0 f\nh_opens : âˆ€ (G : Set Î©), IsOpen G â†’ LE.le (Î¼ G) (Filter.liminf (fun i => (Î¼s i) G) Filter.atTop)\nâŠ¢ LE.le (MeasureTheory.lintegral Î¼ fun x => ENNReal.ofReal (f x)) (Filter.liminf (fun i => MeasureTheory.lintegral (Î¼s i) fun x => ENNReal.ofReal (f x)) Filter.atTop)","decl":"lemma lintegral_le_liminf_lintegral_of_forall_isOpen_measure_le_liminf_measure\n    {Î¼ : Measure Î©} {Î¼s : â„• â†’ Measure Î©} {f : Î© â†’ â„} (f_cont : Continuous f) (f_nn : 0 â‰¤ f)\n    (h_opens : âˆ€ G, IsOpen G â†’ Î¼ G â‰¤ atTop.liminf (fun i â†¦ Î¼s i G)) :\n    âˆ«â» x, ENNReal.ofReal (f x) âˆ‚Î¼ â‰¤ atTop.liminf (fun i â†¦ âˆ«â» x, ENNReal.ofReal (f x) âˆ‚ (Î¼s i)) := by\n  simp_rw [lintegral_eq_lintegral_meas_lt _ (Eventually.of_forall f_nn) f_cont.aemeasurable]\n  calc  âˆ«â» (t : â„) in Set.Ioi 0, Î¼ {a | t < f a}\n      â‰¤ âˆ«â» (t : â„) in Set.Ioi 0, atTop.liminf (fun i â†¦ (Î¼s i) {a | t < f a}) := ?_ -- (i)\n    _ â‰¤ atTop.liminf (fun i â†¦ âˆ«â» (t : â„) in Set.Ioi 0, (Î¼s i) {a | t < f a}) := ?_ -- (ii)\n  Â· -- (i)\n    exact (lintegral_mono (fun t â†¦ h_opens _ (continuous_def.mp f_cont _ isOpen_Ioi))).trans\n            (le_refl _)\n  Â· -- (ii)\n    exact lintegral_liminf_le (fun n â†¦ Antitone.measurable (fun s t hst â†¦\n            measure_mono (fun Ï‰ hÏ‰ â†¦ lt_of_le_of_lt hst hÏ‰)))\n\n"}
{"name":"MeasureTheory.integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\ninstâœÂ³ : MeasurableSpace Î©\ninstâœÂ² : TopologicalSpace Î©\ninstâœÂ¹ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÎ¼s : Nat â†’ MeasureTheory.Measure Î©\ninstâœ : âˆ€ (i : Nat), MeasureTheory.IsProbabilityMeasure (Î¼s i)\nf : BoundedContinuousFunction Î© Real\nf_nn : LE.le 0 f\nh_opens : âˆ€ (G : Set Î©), IsOpen G â†’ LE.le (Î¼ G) (Filter.liminf (fun i => (Î¼s i) G) Filter.atTop)\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun x => f x) (Filter.liminf (fun i => MeasureTheory.integral (Î¼s i) fun x => f x) Filter.atTop)","decl":"lemma integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure\n    {Î¼ : Measure Î©} {Î¼s : â„• â†’ Measure Î©} [âˆ€ i, IsProbabilityMeasure (Î¼s i)]\n    {f : Î© â†’áµ‡ â„} (f_nn : 0 â‰¤ f)\n    (h_opens : âˆ€ G, IsOpen G â†’ Î¼ G â‰¤ atTop.liminf (fun i â†¦ Î¼s i G)) :\n    âˆ« x, (f x) âˆ‚Î¼ â‰¤ atTop.liminf (fun i â†¦ âˆ« x, (f x) âˆ‚ (Î¼s i)) := by\n  have same := lintegral_le_liminf_lintegral_of_forall_isOpen_measure_le_liminf_measure\n                  f.continuous f_nn h_opens\n  rw [@integral_eq_lintegral_of_nonneg_ae Î© _ Î¼ f (Eventually.of_forall f_nn)\n        f.continuous.measurable.aestronglyMeasurable]\n  convert ENNReal.toReal_mono ?_ same\n  Â· simp only [fun i â†¦ @integral_eq_lintegral_of_nonneg_ae Î© _ (Î¼s i) f (Eventually.of_forall f_nn)\n                        f.continuous.measurable.aestronglyMeasurable]\n    let g := BoundedContinuousFunction.comp _ Real.lipschitzWith_toNNReal f\n    have bound : âˆ€ i, âˆ«â» x, ENNReal.ofReal (f x) âˆ‚(Î¼s i) â‰¤ nndist 0 g := fun i â†¦ by\n      simpa only [coe_nnreal_ennreal_nndist, measure_univ, mul_one, ge_iff_le] using\n            BoundedContinuousFunction.lintegral_le_edist_mul (Î¼ := Î¼s i) g\n    apply ENNReal.liminf_toReal_eq ENNReal.coe_ne_top (Eventually.of_forall bound)\n  Â· apply ne_of_lt\n    have obs := fun (i : â„•) â†¦ @BoundedContinuousFunction.lintegral_nnnorm_le Î© _ _ (Î¼s i) â„ _ f\n    simp only [measure_univ, mul_one] at obs\n    apply lt_of_le_of_lt _ (show (â€–fâ€–â‚Š : â„â‰¥0âˆ) < âˆ from ENNReal.coe_lt_top)\n    apply liminf_le_of_le\n    Â· refine âŸ¨0, .of_forall (by simp only [ge_iff_le, zero_le, forall_const])âŸ©\n    Â· intro x hx\n      obtain âŸ¨i, hiâŸ© := hx.exists\n      apply le_trans hi\n      convert obs i with x\n      have aux := ENNReal.ofReal_eq_coe_nnreal (f_nn x)\n      simp only [ContinuousMap.toFun_eq_coe, BoundedContinuousFunction.coe_toContinuousMap] at aux\n      rw [aux]\n      congr\n      exact (Real.norm_of_nonneg (f_nn x)).symm\n\n"}
{"name":"MeasureTheory.tendsto_of_forall_isOpen_le_liminf","module":"Mathlib.MeasureTheory.Measure.Portmanteau","initialProofState":"Î© : Type u_1\ninstâœÂ² : MeasurableSpace Î©\ninstâœÂ¹ : TopologicalSpace Î©\ninstâœ : OpensMeasurableSpace Î©\nÎ¼ : MeasureTheory.ProbabilityMeasure Î©\nÎ¼s : Nat â†’ MeasureTheory.ProbabilityMeasure Î©\nh_opens : âˆ€ (G : Set Î©), IsOpen G â†’ LE.le (Î¼ G) (Filter.liminf (fun i => (Î¼s i) G) Filter.atTop)\nâŠ¢ Filter.Tendsto (fun i => Î¼s i) Filter.atTop (nhds Î¼)","decl":"/-- One implication of the portmanteau theorem:\nIf for all open sets G we have the liminf condition `Î¼(G) â‰¤ liminf Î¼sâ‚™(G)`, then the measures\nÎ¼sâ‚™ converge weakly to the measure Î¼. -/\ntheorem tendsto_of_forall_isOpen_le_liminf {Î¼ : ProbabilityMeasure Î©}\n    {Î¼s : â„• â†’ ProbabilityMeasure Î©}\n    (h_opens : âˆ€ G, IsOpen G â†’ Î¼ G â‰¤ atTop.liminf (fun i â†¦ Î¼s i G)) :\n    atTop.Tendsto (fun i â†¦ Î¼s i) (ğ“ Î¼) := by\n  refine ProbabilityMeasure.tendsto_iff_forall_integral_tendsto.mpr ?_\n  apply tendsto_integral_of_forall_integral_le_liminf_integral\n  intro f f_nn\n  apply integral_le_liminf_integral_of_forall_isOpen_measure_le_liminf_measure (f := f) f_nn\n  intro G G_open\n  specialize h_opens G G_open\n  have aux : ENNReal.ofNNReal (liminf (fun i â†¦ Î¼s i G) atTop) =\n          liminf (ENNReal.ofNNReal âˆ˜ fun i â†¦ Î¼s i G) atTop := by\n    refine Monotone.map_liminf_of_continuousAt (F := atTop) ENNReal.coe_mono (Î¼s Â· G) ?_ ?_ ?_\n    Â· exact ENNReal.continuous_coe.continuousAt\n    Â· exact IsBoundedUnder.isCoboundedUnder_ge âŸ¨1, by simpâŸ©\n    Â· exact âŸ¨0, by simpâŸ©\n  have obs := ENNReal.coe_mono h_opens\n  simp only [ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure, aux] at obs\n  convert obs\n  simp only [Function.comp_apply, ne_eq, ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure]\n\n"}
