{"name":"Matrix.detp_one_one","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\n⊢ Eq (Matrix.detp 1 1) 1","decl":"@[simp]\nlemma detp_one_one : detp 1 (1 : Matrix n n R) = 1 := by\n  rw [detp, sum_eq_single_of_mem 1]\n  · simp [one_apply]\n  · simp [ofSign]\n  · rintro σ - hσ1\n    obtain ⟨i, hi⟩ := not_forall.mp (mt Perm.ext_iff.mpr hσ1)\n    exact prod_eq_zero (mem_univ i) (one_apply_ne' hi)\n\n"}
{"name":"Matrix.detp_neg_one_one","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\n⊢ Eq (Matrix.detp (-1) 1) 0","decl":"@[simp]\nlemma detp_neg_one_one : detp (-1) (1 : Matrix n n R) = 0 := by\n  rw [detp, sum_eq_zero]\n  intro σ hσ\n  have hσ1 : σ ≠ 1 := by\n    contrapose! hσ\n    rw [hσ, mem_ofSign, sign_one]\n    decide\n  obtain ⟨i, hi⟩ := not_forall.mp (mt Perm.ext_iff.mpr hσ1)\n  exact prod_eq_zero (mem_univ i) (one_apply_ne' hi)\n\n"}
{"name":"Matrix.adjp_apply","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\ns : Units Int\nA : Matrix n n R\ni j : n\n⊢ Eq (Matrix.adjp s A i j) ((Finset.filter (fun x => Eq (x j) i) (Equiv.Perm.ofSign s)).sum fun σ => (HasCompl.compl (Singleton.singleton j)).prod fun k => A k (σ k))","decl":"lemma adjp_apply (i j : n) :\n    adjp s A i j = ∑ σ ∈ (ofSign s).filter (· j = i), ∏ k ∈ {j}ᶜ, A k (σ k) :=\n  rfl\n\n"}
{"name":"Matrix.detp_mul","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA B : Matrix n n R\n⊢ Eq (HAdd.hAdd (Matrix.detp 1 (HMul.hMul A B)) (HAdd.hAdd (HMul.hMul (Matrix.detp 1 A) (Matrix.detp (-1) B)) (HMul.hMul (Matrix.detp (-1) A) (Matrix.detp 1 B)))) (HAdd.hAdd (Matrix.detp (-1) (HMul.hMul A B)) (HAdd.hAdd (HMul.hMul (Matrix.detp 1 A) (Matrix.detp 1 B)) (HMul.hMul (Matrix.detp (-1) A) (Matrix.detp (-1) B))))","decl":"theorem detp_mul :\n    detp 1 (A * B) + (detp 1 A * detp (-1) B + detp (-1) A * detp 1 B) =\n      detp (-1) (A * B) + (detp 1 A * detp 1 B + detp (-1) A * detp (-1) B) := by\n  have hf {s t} {σ : Perm n} (hσ : σ ∈ ofSign s) :\n      ofSign (t * s) = (ofSign t).map (mulRightEmbedding σ) := by\n    ext τ\n    simp_rw [mem_map, mulRightEmbedding_apply, ← eq_mul_inv_iff_mul_eq, exists_eq_right,\n      mem_ofSign, _root_.map_mul, _root_.map_inv, mul_inv_eq_iff_eq_mul, mem_ofSign.mp hσ]\n  have h {s t} : detp s A * detp t B =\n      ∑ σ ∈ ofSign s, ∑ τ ∈ ofSign (t * s), ∏ k, A k (σ k) * B (σ k) (τ k) := by\n    simp_rw [detp, sum_mul_sum, prod_mul_distrib]\n    refine sum_congr rfl fun σ hσ ↦ ?_\n    simp_rw [hf hσ, sum_map, mulRightEmbedding_apply, Perm.mul_apply]\n    exact sum_congr rfl fun τ hτ ↦ (congr_arg (_ * ·) (Equiv.prod_comp σ _).symm)\n  let ι : Perm n ↪ (n → n) := ⟨_, coe_fn_injective⟩\n  have hι {σ x} : ι σ x = σ x := rfl\n  let bij : Finset (n → n) := (disjUnion (ofSign 1) (ofSign (-1)) ofSign_disjoint).map ι\n  replace h (s) : detp s (A * B) =\n      ∑ σ ∈ bijᶜ, ∑ τ ∈ ofSign s, ∏ i : n, A i (σ i) * B (σ i) (τ i) +\n        (detp 1 A * detp s B + detp (-1) A * detp (-s) B) := by\n    simp_rw [h, neg_mul_neg, mul_one, detp, mul_apply, prod_univ_sum, Fintype.piFinset_univ]\n    rw [sum_comm, ← sum_compl_add_sum bij, sum_map, sum_disjUnion]\n    simp_rw [hι]\n  rw [h, h, neg_neg, add_assoc]\n  conv_rhs => rw [add_assoc]\n  refine congr_arg₂ (· + ·) (sum_congr rfl fun σ hσ ↦ ?_) (add_comm _ _)\n  replace hσ : ¬ Function.Injective σ := by\n    contrapose! hσ\n    rw [not_mem_compl, mem_map, ofSign_disjUnion]\n    exact ⟨Equiv.ofBijective σ hσ.bijective_of_finite, mem_univ _, rfl⟩\n  obtain ⟨i, j, hσ, hij⟩ := Function.not_injective_iff.mp hσ\n  replace hσ k : σ (swap i j k) = σ k := by\n    rw [swap_apply_def]\n    split_ifs with h h <;> simp only [hσ, h]\n  rw [← mul_neg_one, hf (mem_ofSign.mpr (sign_swap hij)), sum_map]\n  simp_rw [prod_mul_distrib, mulRightEmbedding_apply, Perm.mul_apply]\n  refine sum_congr rfl fun τ hτ ↦ congr_arg (_ *  ·) ?_\n  rw [← Equiv.prod_comp (swap i j)]\n  simp only [hσ]\n\n"}
{"name":"Matrix.mul_adjp_apply_eq","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\ns : Units Int\nA : Matrix n n R\ni : n\n⊢ Eq (HMul.hMul A (Matrix.adjp s A) i i) (Matrix.detp s A)","decl":"theorem mul_adjp_apply_eq : (A * adjp s A) i i = detp s A := by\n  have key := sum_fiberwise_eq_sum_filter (ofSign s) univ (· i) fun σ ↦ ∏ k, A k (σ k)\n  simp_rw [mem_univ, filter_True] at key\n  simp_rw [mul_apply, adjp_apply, mul_sum, detp, ← key]\n  refine sum_congr rfl fun x hx ↦ sum_congr rfl fun σ hσ ↦ ?_\n  rw [← prod_mul_prod_compl ({i} : Finset n), prod_singleton, (mem_filter.mp hσ).2]\n\n"}
{"name":"Matrix.mul_adjp_apply_ne","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA : Matrix n n R\ni j : n\nh : Ne i j\n⊢ Eq (HMul.hMul A (Matrix.adjp 1 A) i j) (HMul.hMul A (Matrix.adjp (-1) A) i j)","decl":"theorem mul_adjp_apply_ne (h : i ≠ j) : (A * adjp 1 A) i j = (A * adjp (-1) A) i j := by\n  simp_rw [mul_apply, adjp_apply, mul_sum, sum_sigma']\n  let f : (Σ x : n, Perm n) → (Σ x : n, Perm n) := fun ⟨x, σ⟩ ↦ ⟨σ i, σ * swap i j⟩\n  let t s : Finset (Σ x : n, Perm n) := univ.sigma fun x ↦ (ofSign s).filter fun σ ↦ σ j = x\n  have hf {s} : ∀ p ∈ t s, f (f p) = p := by\n    intro ⟨x, σ⟩ hp\n    rw [mem_sigma, mem_filter, mem_ofSign] at hp\n    simp_rw [f, Perm.mul_apply, swap_apply_left, hp.2.2, mul_swap_mul_self]\n  refine sum_bij' (fun p _ ↦ f p) (fun p _ ↦ f p) ?_ ?_ hf hf ?_\n  · intro ⟨x, σ⟩ hp\n    rw [mem_sigma, mem_filter, mem_ofSign] at hp ⊢\n    rw [Perm.mul_apply, sign_mul, hp.2.1, sign_swap h, swap_apply_right]\n    exact ⟨mem_univ (σ i), rfl, rfl⟩\n  · intro ⟨x, σ⟩ hp\n    rw [mem_sigma, mem_filter, mem_ofSign] at hp ⊢\n    rw [Perm.mul_apply, sign_mul, hp.2.1, sign_swap h, swap_apply_right]\n    exact ⟨mem_univ (σ i), rfl, rfl⟩\n  · intro ⟨x, σ⟩ hp\n    rw [mem_sigma, mem_filter, mem_ofSign] at hp\n    have key : ({j}ᶜ : Finset n) = disjUnion ({i} : Finset n) ({i, j} : Finset n)ᶜ (by simp) := by\n      rw [singleton_disjUnion, cons_eq_insert, compl_insert, insert_erase]\n      rwa [mem_compl, mem_singleton]\n    simp_rw [key, prod_disjUnion, prod_singleton, f, Perm.mul_apply, swap_apply_left, ← mul_assoc]\n    rw [mul_comm (A i x) (A i (σ i)), hp.2.2]\n    refine congr_arg _ (prod_congr rfl fun x hx ↦ ?_)\n    rw [mem_compl, mem_insert, mem_singleton, not_or] at hx\n    rw [swap_apply_of_ne_of_ne hx.1 hx.2]\n\n"}
{"name":"Matrix.mul_adjp_add_detp","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA : Matrix n n R\n⊢ Eq (HAdd.hAdd (HMul.hMul A (Matrix.adjp 1 A)) (HSMul.hSMul (Matrix.detp (-1) A) 1)) (HAdd.hAdd (HMul.hMul A (Matrix.adjp (-1) A)) (HSMul.hSMul (Matrix.detp 1 A) 1))","decl":"theorem mul_adjp_add_detp : A * adjp 1 A + detp (-1) A • 1 = A * adjp (-1) A + detp 1 A • 1 := by\n  ext i j\n  rcases eq_or_ne i j with rfl | h <;> simp_rw [add_apply, smul_apply, smul_eq_mul]\n  · simp_rw [mul_adjp_apply_eq, one_apply_eq, mul_one, add_comm]\n  · simp_rw [mul_adjp_apply_ne A i j h, one_apply_ne h, mul_zero]\n\n"}
{"name":"Matrix.isAddUnit_mul","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA B : Matrix n n R\nhAB : Eq (HMul.hMul A B) 1\ni j k : n\nhij : Ne i j\n⊢ IsAddUnit (HMul.hMul (A i k) (B k j))","decl":"theorem isAddUnit_mul (hAB : A * B = 1) (i j k : n) (hij : i ≠ j) : IsAddUnit (A i k * B k j) := by\n  revert k\n  rw [← IsAddUnit.sum_univ_iff, ← mul_apply, hAB, one_apply_ne hij]\n  exact isAddUnit_zero\n\n"}
{"name":"Matrix.isAddUnit_detp_mul_detp","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA B : Matrix n n R\nhAB : Eq (HMul.hMul A B) 1\n⊢ IsAddUnit (HAdd.hAdd (HMul.hMul (Matrix.detp 1 A) (Matrix.detp (-1) B)) (HMul.hMul (Matrix.detp (-1) A) (Matrix.detp 1 B)))","decl":"theorem isAddUnit_detp_mul_detp (hAB : A * B = 1) :\n    IsAddUnit (detp 1 A * detp (-1) B + detp (-1) A * detp 1 B) := by\n  suffices h : ∀ {s t}, s ≠ t → IsAddUnit (detp s A * detp t B) from\n    (h (by decide)).add (h (by decide))\n  intro s t h\n  simp_rw [detp, sum_mul_sum, IsAddUnit.sum_iff]\n  intro σ hσ τ hτ\n  rw [mem_ofSign] at hσ hτ\n  rw [← hσ, ← hτ, ← sign_inv] at h\n  replace h := ne_of_apply_ne sign h\n  rw [ne_eq, eq_comm, eq_inv_iff_mul_eq_one, eq_comm] at h\n  simp_rw [Equiv.ext_iff, not_forall, Perm.mul_apply, Perm.one_apply] at h\n  obtain ⟨k, hk⟩ := h\n  rw [mul_comm, ← Equiv.prod_comp σ, mul_comm, ← prod_mul_distrib,\n    ← mul_prod_erase univ _ (mem_univ k), ← smul_eq_mul]\n  exact (isAddUnit_mul hAB k (τ (σ k)) (σ k) hk).smul_right _\n\n"}
{"name":"Matrix.isAddUnit_detp_smul_mul_adjp","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA B : Matrix n n R\nhAB : Eq (HMul.hMul A B) 1\n⊢ IsAddUnit (HAdd.hAdd (HSMul.hSMul (Matrix.detp 1 A) (HMul.hMul B (Matrix.adjp (-1) B))) (HSMul.hSMul (Matrix.detp (-1) A) (HMul.hMul B (Matrix.adjp 1 B))))","decl":"theorem isAddUnit_detp_smul_mul_adjp (hAB : A * B = 1) :\n    IsAddUnit (detp 1 A • (B * adjp (-1) B) + detp (-1) A • (B * adjp 1 B)) := by\n  suffices h : ∀ {s t}, s ≠ t → IsAddUnit (detp s A • (B * adjp t B)) from\n    (h (by decide)).add (h (by decide))\n  intro s t h\n  rw [isAddUnit_iff]\n  intro i j\n  simp_rw [smul_apply, smul_eq_mul, mul_apply, detp, adjp_apply, mul_sum, sum_mul,\n    IsAddUnit.sum_iff]\n  intro k hk σ hσ τ hτ\n  rw [mem_filter] at hσ\n  rw [mem_ofSign] at hσ hτ\n  rw [← hσ.1, ← hτ, ← sign_inv] at h\n  replace h := ne_of_apply_ne sign h\n  rw [ne_eq, eq_comm, eq_inv_iff_mul_eq_one] at h\n  obtain ⟨l, hl1, hl2⟩ := exists_ne_of_one_lt_card (one_lt_card_support_of_ne_one h) (τ⁻¹ j)\n  rw [mem_support, ne_comm] at hl1\n  rw [ne_eq, ← mem_singleton, ← mem_compl] at hl2\n  rw [← prod_mul_prod_compl {τ⁻¹ j}, mul_mul_mul_comm, mul_comm, ← smul_eq_mul]\n  apply IsAddUnit.smul_right\n  have h0 : ∀ k, k ∈ ({τ⁻¹ j} : Finset n)ᶜ ↔ τ k ∈ ({j} : Finset n)ᶜ := by\n    simp [inv_def, eq_symm_apply]\n  rw [← prod_equiv τ h0 fun _ _ ↦ rfl, ← prod_mul_distrib, ← mul_prod_erase _ _ hl2, ← smul_eq_mul]\n  exact (isAddUnit_mul hAB l (σ (τ l)) (τ l) hl1).smul_right _\n\n"}
{"name":"Matrix.detp_smul_add_adjp","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA B : Matrix n n R\nhAB : Eq (HMul.hMul A B) 1\n⊢ Eq (HAdd.hAdd (HSMul.hSMul (Matrix.detp 1 B) A) (Matrix.adjp (-1) B)) (HAdd.hAdd (HSMul.hSMul (Matrix.detp (-1) B) A) (Matrix.adjp 1 B))","decl":"theorem detp_smul_add_adjp (hAB : A * B = 1) :\n    detp 1 B • A + adjp (-1) B = detp (-1) B • A + adjp 1 B := by\n  have key := congr(A * $(mul_adjp_add_detp B))\n  simp_rw [mul_add, ← mul_assoc, hAB, one_mul, mul_smul, mul_one] at key\n  rwa [add_comm, eq_comm, add_comm]\n\n"}
{"name":"Matrix.detp_smul_adjp","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA B : Matrix n n R\nhAB : Eq (HMul.hMul A B) 1\n⊢ Eq (HAdd.hAdd A (HAdd.hAdd (HSMul.hSMul (Matrix.detp 1 A) (Matrix.adjp (-1) B)) (HSMul.hSMul (Matrix.detp (-1) A) (Matrix.adjp 1 B)))) (HAdd.hAdd (HSMul.hSMul (Matrix.detp 1 A) (Matrix.adjp 1 B)) (HSMul.hSMul (Matrix.detp (-1) A) (Matrix.adjp (-1) B)))","decl":"theorem detp_smul_adjp (hAB : A * B = 1) :\n    A + (detp 1 A • adjp (-1) B + detp (-1) A • adjp 1 B) =\n      detp 1 A • adjp 1 B + detp (-1) A • adjp (-1) B := by\n  have h0 := detp_mul A B\n  rw [hAB, detp_one_one, detp_neg_one_one, zero_add] at h0\n  have h := detp_smul_add_adjp hAB\n  replace h := congr(detp 1 A • $h + detp (-1) A • $h.symm)\n  simp only [smul_add, smul_smul] at h\n  rwa [add_add_add_comm, ← add_smul, add_add_add_comm, ← add_smul, ← h0, add_smul, one_smul,\n    add_comm A, add_assoc, ((isAddUnit_detp_mul_detp hAB).smul_right _).add_right_inj] at h\n\n"}
{"name":"Matrix.mul_eq_one_comm","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA B : Matrix n n R\n⊢ Iff (Eq (HMul.hMul A B) 1) (Eq (HMul.hMul B A) 1)","decl":"theorem mul_eq_one_comm : A * B = 1 ↔ B * A = 1 := by\n  suffices h : ∀ A B : Matrix n n R, A * B = 1 → B * A = 1 from ⟨h A B, h B A⟩\n  intro A B hAB\n  have h0 := detp_mul A B\n  rw [hAB, detp_one_one, detp_neg_one_one, zero_add] at h0\n  replace h := congr(B * $(detp_smul_adjp hAB))\n  simp only [mul_add, mul_smul, add_assoc] at h\n  replace h := congr($h + (detp 1 A * detp (-1) B + detp (-1) A * detp 1 B) • 1)\n  simp_rw [add_smul, ← smul_smul] at h\n  rwa [add_assoc, add_add_add_comm, ← smul_add, ← smul_add,\n    add_add_add_comm, ← smul_add, ← smul_add, smul_add, smul_add,\n    mul_adjp_add_detp, smul_add, ← mul_adjp_add_detp, smul_add, ← smul_add, ← smul_add,\n    add_add_add_comm, smul_smul, smul_smul, ← add_smul, ← h0,\n    add_smul, one_smul, ← add_assoc _ 1, add_comm _ 1, add_assoc,\n    smul_add, smul_add, add_add_add_comm, smul_smul, smul_smul, ← add_smul,\n    ((isAddUnit_detp_smul_mul_adjp hAB).add\n      ((isAddUnit_detp_mul_detp hAB).smul_right _)).add_left_inj] at h\n\n"}
{"name":"Matrix.isUnit_of_left_inverse","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA B : Matrix n n R\nh : Eq (HMul.hMul B A) 1\n⊢ IsUnit A","decl":"theorem isUnit_of_left_inverse (h : B * A = 1) : IsUnit A :=\n  ⟨⟨A, B, mul_eq_one_comm.mp h, h⟩, rfl⟩\n\n"}
{"name":"Matrix.exists_left_inverse_iff_isUnit","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA : Matrix n n R\n⊢ Iff (Exists fun B => Eq (HMul.hMul B A) 1) (IsUnit A)","decl":"theorem exists_left_inverse_iff_isUnit : (∃ B, B * A = 1) ↔ IsUnit A :=\n  ⟨fun ⟨_, h⟩ ↦ isUnit_of_left_inverse h, fun h ↦ have := h.invertible; ⟨⅟A, invOf_mul_self' A⟩⟩\n\n"}
{"name":"Matrix.isUnit_of_right_inverse","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA B : Matrix n n R\nh : Eq (HMul.hMul A B) 1\n⊢ IsUnit A","decl":"theorem isUnit_of_right_inverse (h : A * B = 1) : IsUnit A :=\n  ⟨⟨A, B, h, mul_eq_one_comm.mp h⟩, rfl⟩\n\n"}
{"name":"Matrix.exists_right_inverse_iff_isUnit","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nR : Type u_3\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA : Matrix n n R\n⊢ Iff (Exists fun B => Eq (HMul.hMul A B) 1) (IsUnit A)","decl":"theorem exists_right_inverse_iff_isUnit : (∃ B, A * B = 1) ↔ IsUnit A :=\n  ⟨fun ⟨_, h⟩ ↦ isUnit_of_right_inverse h, fun h ↦ have := h.invertible; ⟨⅟A, mul_invOf_self' A⟩⟩\n\n"}
{"name":"Matrix.mul_eq_one_comm_of_equiv","module":"Mathlib.LinearAlgebra.Matrix.SemiringInverse","initialProofState":"n : Type u_1\nm : Type u_2\nR : Type u_3\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : DecidableEq m\ninst✝¹ : DecidableEq n\ninst✝ : CommSemiring R\nA : Matrix m n R\nB : Matrix n m R\ne : Equiv m n\n⊢ Iff (Eq (HMul.hMul A B) 1) (Eq (HMul.hMul B A) 1)","decl":"/-- A version of `mul_eq_one_comm` that works for square matrices with rectangular types. -/\ntheorem mul_eq_one_comm_of_equiv {A : Matrix m n R} {B : Matrix n m R} (e : m ≃ n) :\n    A * B = 1 ↔ B * A = 1 := by\n  refine (reindex e e).injective.eq_iff.symm.trans ?_\n  rw [reindex_apply, reindex_apply, submatrix_one_equiv, ← submatrix_mul_equiv _ _ _ (.refl _),\n    mul_eq_one_comm, submatrix_mul_equiv, coe_refl, submatrix_id_id]\n\n"}
