{"name":"Finset.prod_mk","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Multiset α\nhs : s.Nodup\nf : α → β\n⊢ Eq ({ val := s, nodup := hs }.prod f) (Multiset.map f s).prod","decl":"@[to_additive (attr := simp)]\ntheorem prod_mk [CommMonoid β] (s : Multiset α) (hs : s.Nodup) (f : α → β) :\n    (⟨s, hs⟩ : Finset α).prod f = (s.map f).prod :=\n  rfl\n\n"}
{"name":"Finset.sum_mk","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Multiset α\nhs : s.Nodup\nf : α → β\n⊢ Eq ({ val := s, nodup := hs }.sum f) (Multiset.map f s).sum","decl":"@[to_additive (attr := simp)]\ntheorem prod_mk [CommMonoid β] (s : Multiset α) (hs : s.Nodup) (f : α → β) :\n    (⟨s, hs⟩ : Finset α).prod f = (s.map f).prod :=\n  rfl\n\n"}
{"name":"Finset.sum_val","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\ns : Finset α\n⊢ Eq s.val.sum (s.sum id)","decl":"@[to_additive (attr := simp)]\ntheorem prod_val [CommMonoid α] (s : Finset α) : s.1.prod = s.prod id := by\n  rw [Finset.prod, Multiset.map_id]\n\n"}
{"name":"Finset.prod_val","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\ns : Finset α\n⊢ Eq s.val.prod (s.prod id)","decl":"@[to_additive (attr := simp)]\ntheorem prod_val [CommMonoid α] (s : Finset α) : s.1.prod = s.prod id := by\n  rw [Finset.prod, Multiset.map_id]\n\n"}
{"name":"Finset.prod_eq_multiset_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nf : α → β\n⊢ Eq (s.prod fun x => f x) (Multiset.map f s.val).prod","decl":"@[to_additive]\ntheorem prod_eq_multiset_prod [CommMonoid β] (s : Finset α) (f : α → β) :\n    ∏ x ∈ s, f x = (s.1.map f).prod :=\n  rfl\n\n"}
{"name":"Finset.sum_eq_multiset_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → β\n⊢ Eq (s.sum fun x => f x) (Multiset.map f s.val).sum","decl":"@[to_additive]\ntheorem prod_eq_multiset_prod [CommMonoid β] (s : Finset α) (f : α → β) :\n    ∏ x ∈ s, f x = (s.1.map f).prod :=\n  rfl\n\n"}
{"name":"Finset.sum_map_val","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → β\n⊢ Eq (Multiset.map f s.val).sum (s.sum fun a => f a)","decl":"@[to_additive (attr := simp)]\nlemma prod_map_val [CommMonoid β] (s : Finset α) (f : α → β) : (s.1.map f).prod = ∏ a ∈ s, f a :=\n  rfl\n\n"}
{"name":"Finset.prod_map_val","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nf : α → β\n⊢ Eq (Multiset.map f s.val).prod (s.prod fun a => f a)","decl":"@[to_additive (attr := simp)]\nlemma prod_map_val [CommMonoid β] (s : Finset α) (f : α → β) : (s.1.map f).prod = ∏ a ∈ s, f a :=\n  rfl\n\n"}
{"name":"Finset.sum_multiset_singleton","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ns : Finset α\n⊢ Eq (s.sum fun a => Singleton.singleton a) s.val","decl":"@[simp]\ntheorem sum_multiset_singleton (s : Finset α) : ∑ a ∈ s, {a} = s.val := by\n  simp only [sum_eq_multiset_sum, Multiset.sum_map_singleton]\n\n"}
{"name":"map_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝³ : CommMonoid β\ninst✝² : CommMonoid γ\nG : Type u_6\ninst✝¹ : FunLike G β γ\ninst✝ : MonoidHomClass G β γ\ng : G\nf : α → β\ns : Finset α\n⊢ Eq (g (s.prod fun x => f x)) (s.prod fun x => g (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_prod [CommMonoid β] [CommMonoid γ] {G : Type*} [FunLike G β γ] [MonoidHomClass G β γ]\n    (g : G) (f : α → β) (s : Finset α) : g (∏ x ∈ s, f x) = ∏ x ∈ s, g (f x) := by\n  simp only [Finset.prod_eq_multiset_prod, map_multiset_prod, Multiset.map_map]; rfl\n\n"}
{"name":"map_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝³ : AddCommMonoid β\ninst✝² : AddCommMonoid γ\nG : Type u_6\ninst✝¹ : FunLike G β γ\ninst✝ : AddMonoidHomClass G β γ\ng : G\nf : α → β\ns : Finset α\n⊢ Eq (g (s.sum fun x => f x)) (s.sum fun x => g (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_prod [CommMonoid β] [CommMonoid γ] {G : Type*} [FunLike G β γ] [MonoidHomClass G β γ]\n    (g : G) (f : α → β) (s : Finset α) : g (∏ x ∈ s, f x) = ∏ x ∈ s, g (f x) := by\n  simp only [Finset.prod_eq_multiset_prod, map_multiset_prod, Multiset.map_map]; rfl\n\n"}
{"name":"Finset.sum_empty","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ninst✝ : AddCommMonoid β\n⊢ Eq (EmptyCollection.emptyCollection.sum fun x => f x) 0","decl":"@[to_additive (attr := simp)]\ntheorem prod_empty : ∏ x ∈ ∅, f x = 1 :=\n  rfl\n\n"}
{"name":"Finset.prod_empty","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ninst✝ : CommMonoid β\n⊢ Eq (EmptyCollection.emptyCollection.prod fun x => f x) 1","decl":"@[to_additive (attr := simp)]\ntheorem prod_empty : ∏ x ∈ ∅, f x = 1 :=\n  rfl\n\n"}
{"name":"Finset.sum_of_isEmpty","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : IsEmpty α\ns : Finset α\n⊢ Eq (s.sum fun i => f i) 0","decl":"@[to_additive]\ntheorem prod_of_isEmpty [IsEmpty α] (s : Finset α) : ∏ i ∈ s, f i = 1 := by\n  rw [eq_empty_of_isEmpty s, prod_empty]\n\n"}
{"name":"Finset.prod_of_isEmpty","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ninst✝¹ : CommMonoid β\ninst✝ : IsEmpty α\ns : Finset α\n⊢ Eq (s.prod fun i => f i) 1","decl":"@[to_additive]\ntheorem prod_of_isEmpty [IsEmpty α] (s : Finset α) : ∏ i ∈ s, f i = 1 := by\n  rw [eq_empty_of_isEmpty s, prod_empty]\n\n"}
{"name":"Finset.prod_const_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : CommMonoid β\n⊢ Eq (s.prod fun _x => 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem prod_const_one : (∏ _x ∈ s, (1 : β)) = 1 := by\n  simp only [Finset.prod, Multiset.map_const', Multiset.prod_replicate, one_pow]\n\n"}
{"name":"Finset.sum_const_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : AddCommMonoid β\n⊢ Eq (s.sum fun _x => 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem prod_const_one : (∏ _x ∈ s, (1 : β)) = 1 := by\n  simp only [Finset.prod, Multiset.map_const', Multiset.prod_replicate, one_pow]\n\n"}
{"name":"Finset.prod_map","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\ns : Finset α\ne : Function.Embedding α γ\nf : γ → β\n⊢ Eq ((Finset.map e s).prod fun x => f x) (s.prod fun x => f (e x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_map (s : Finset α) (e : α ↪ γ) (f : γ → β) :\n    ∏ x ∈ s.map e, f x = ∏ x ∈ s, f (e x) := by\n  rw [Finset.prod, Finset.map_val, Multiset.map_map]; rfl\n\n"}
{"name":"Finset.sum_map","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\ns : Finset α\ne : Function.Embedding α γ\nf : γ → β\n⊢ Eq ((Finset.map e s).sum fun x => f x) (s.sum fun x => f (e x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_map (s : Finset α) (e : α ↪ γ) (f : γ → β) :\n    ∏ x ∈ s.map e, f x = ∏ x ∈ s, f (e x) := by\n  rw [Finset.prod, Finset.map_val, Multiset.map_map]; rfl\n\n"}
{"name":"Finset.prod_to_list","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nf : α → β\n⊢ Eq (List.map f s.toList).prod (s.prod f)","decl":"@[to_additive (attr := simp)]\ntheorem prod_to_list (s : Finset α) (f : α → β) : (s.toList.map f).prod = s.prod f := by\n  rw [Finset.prod, ← Multiset.prod_coe, ← Multiset.map_coe, Finset.coe_toList]\n\n"}
{"name":"Finset.sum_to_list","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → β\n⊢ Eq (List.map f s.toList).sum (s.sum f)","decl":"@[to_additive (attr := simp)]\ntheorem prod_to_list (s : Finset α) (f : α → β) : (s.toList.map f).prod = s.prod f := by\n  rw [Finset.prod, ← Multiset.prod_coe, ← Multiset.map_coe, Finset.coe_toList]\n\n"}
{"name":"Equiv.Perm.prod_comp","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\nσ : Equiv.Perm α\ns : Finset α\nf : α → β\nhs : HasSubset.Subset (setOf fun a => Ne (σ a) a) ↑s\n⊢ Eq (s.prod fun x => f (σ x)) (s.prod fun x => f x)","decl":"@[to_additive]\ntheorem _root_.Equiv.Perm.prod_comp (σ : Equiv.Perm α) (s : Finset α) (f : α → β)\n    (hs : { a | σ a ≠ a } ⊆ s) : (∏ x ∈ s, f (σ x)) = ∏ x ∈ s, f x := by\n  convert (prod_map s σ.toEmbedding f).symm\n  exact (map_perm hs).symm\n\n"}
{"name":"Equiv.Perm.sum_comp","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\nσ : Equiv.Perm α\ns : Finset α\nf : α → β\nhs : HasSubset.Subset (setOf fun a => Ne (σ a) a) ↑s\n⊢ Eq (s.sum fun x => f (σ x)) (s.sum fun x => f x)","decl":"@[to_additive]\ntheorem _root_.Equiv.Perm.prod_comp (σ : Equiv.Perm α) (s : Finset α) (f : α → β)\n    (hs : { a | σ a ≠ a } ⊆ s) : (∏ x ∈ s, f (σ x)) = ∏ x ∈ s, f x := by\n  convert (prod_map s σ.toEmbedding f).symm\n  exact (map_perm hs).symm\n\n"}
{"name":"Equiv.Perm.sum_comp'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\nσ : Equiv.Perm α\ns : Finset α\nf : α → α → β\nhs : HasSubset.Subset (setOf fun a => Ne (σ a) a) ↑s\n⊢ Eq (s.sum fun x => f (σ x) x) (s.sum fun x => f x ((Equiv.symm σ) x))","decl":"@[to_additive]\ntheorem _root_.Equiv.Perm.prod_comp' (σ : Equiv.Perm α) (s : Finset α) (f : α → α → β)\n    (hs : { a | σ a ≠ a } ⊆ s) : (∏ x ∈ s, f (σ x) x) = ∏ x ∈ s, f x (σ.symm x) := by\n  convert σ.prod_comp s (fun x => f x (σ.symm x)) hs\n  rw [Equiv.symm_apply_apply]\n\n"}
{"name":"Equiv.Perm.prod_comp'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\nσ : Equiv.Perm α\ns : Finset α\nf : α → α → β\nhs : HasSubset.Subset (setOf fun a => Ne (σ a) a) ↑s\n⊢ Eq (s.prod fun x => f (σ x) x) (s.prod fun x => f x ((Equiv.symm σ) x))","decl":"@[to_additive]\ntheorem _root_.Equiv.Perm.prod_comp' (σ : Equiv.Perm α) (s : Finset α) (f : α → α → β)\n    (hs : { a | σ a ≠ a } ⊆ s) : (∏ x ∈ s, f (σ x) x) = ∏ x ∈ s, f x (σ.symm x) := by\n  convert σ.prod_comp s (fun x => f x (σ.symm x)) hs\n  rw [Equiv.symm_apply_apply]\n\n"}
{"name":"Finset.prod_bij","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : CommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ni : (a : ι) → Membership.mem s a → κ\nhi : ∀ (a : ι) (ha : Membership.mem s a), Membership.mem t (i a ha)\ni_inj : ∀ (a₁ : ι) (ha₁ : Membership.mem s a₁) (a₂ : ι) (ha₂ : Membership.mem s a₂), Eq (i a₁ ha₁) (i a₂ ha₂) → Eq a₁ a₂\ni_surj : ∀ (b : κ), Membership.mem t b → Exists fun a => Exists fun ha => Eq (i a ha) b\nh : ∀ (a : ι) (ha : Membership.mem s a), Eq (f a) (g (i a ha))\n⊢ Eq (s.prod fun x => f x) (t.prod fun x => g x)","decl":"/-- Reorder a product.\n\nThe difference with `Finset.prod_bij'` is that the bijection is specified as a surjective injection,\nrather than by an inverse function.\n\nThe difference with `Finset.prod_nbij` is that the bijection is allowed to use membership of the\ndomain of the product, rather than being a non-dependent function. -/\n@[to_additive \"Reorder a sum.\n\nThe difference with `Finset.sum_bij'` is that the bijection is specified as a surjective injection,\nrather than by an inverse function.\n\nThe difference with `Finset.sum_nbij` is that the bijection is allowed to use membership of the\ndomain of the sum, rather than being a non-dependent function.\"]\ntheorem prod_bij (i : ∀ a ∈ s, κ) (hi : ∀ a ha, i a ha ∈ t)\n    (i_inj : ∀ a₁ ha₁ a₂ ha₂, i a₁ ha₁ = i a₂ ha₂ → a₁ = a₂)\n    (i_surj : ∀ b ∈ t, ∃ a ha, i a ha = b) (h : ∀ a ha, f a = g (i a ha)) :\n    ∏ x ∈ s, f x = ∏ x ∈ t, g x :=\n  congr_arg Multiset.prod (Multiset.map_eq_map_of_bij_of_nodup f g s.2 t.2 i hi i_inj i_surj h)\n\n"}
{"name":"Finset.sum_bij","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : AddCommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ni : (a : ι) → Membership.mem s a → κ\nhi : ∀ (a : ι) (ha : Membership.mem s a), Membership.mem t (i a ha)\ni_inj : ∀ (a₁ : ι) (ha₁ : Membership.mem s a₁) (a₂ : ι) (ha₂ : Membership.mem s a₂), Eq (i a₁ ha₁) (i a₂ ha₂) → Eq a₁ a₂\ni_surj : ∀ (b : κ), Membership.mem t b → Exists fun a => Exists fun ha => Eq (i a ha) b\nh : ∀ (a : ι) (ha : Membership.mem s a), Eq (f a) (g (i a ha))\n⊢ Eq (s.sum fun x => f x) (t.sum fun x => g x)","decl":"/-- Reorder a product.\n\nThe difference with `Finset.prod_bij'` is that the bijection is specified as a surjective injection,\nrather than by an inverse function.\n\nThe difference with `Finset.prod_nbij` is that the bijection is allowed to use membership of the\ndomain of the product, rather than being a non-dependent function. -/\n@[to_additive \"Reorder a sum.\n\nThe difference with `Finset.sum_bij'` is that the bijection is specified as a surjective injection,\nrather than by an inverse function.\n\nThe difference with `Finset.sum_nbij` is that the bijection is allowed to use membership of the\ndomain of the sum, rather than being a non-dependent function.\"]\ntheorem prod_bij (i : ∀ a ∈ s, κ) (hi : ∀ a ha, i a ha ∈ t)\n    (i_inj : ∀ a₁ ha₁ a₂ ha₂, i a₁ ha₁ = i a₂ ha₂ → a₁ = a₂)\n    (i_surj : ∀ b ∈ t, ∃ a ha, i a ha = b) (h : ∀ a ha, f a = g (i a ha)) :\n    ∏ x ∈ s, f x = ∏ x ∈ t, g x :=\n  congr_arg Multiset.prod (Multiset.map_eq_map_of_bij_of_nodup f g s.2 t.2 i hi i_inj i_surj h)\n\n"}
{"name":"Finset.prod_bij'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : CommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ni : (a : ι) → Membership.mem s a → κ\nj : (a : κ) → Membership.mem t a → ι\nhi : ∀ (a : ι) (ha : Membership.mem s a), Membership.mem t (i a ha)\nhj : ∀ (a : κ) (ha : Membership.mem t a), Membership.mem s (j a ha)\nleft_inv : ∀ (a : ι) (ha : Membership.mem s a), Eq (j (i a ha) ⋯) a\nright_inv : ∀ (a : κ) (ha : Membership.mem t a), Eq (i (j a ha) ⋯) a\nh : ∀ (a : ι) (ha : Membership.mem s a), Eq (f a) (g (i a ha))\n⊢ Eq (s.prod fun x => f x) (t.prod fun x => g x)","decl":"/-- Reorder a product.\n\nThe difference with `Finset.prod_bij` is that the bijection is specified with an inverse, rather\nthan as a surjective injection.\n\nThe difference with `Finset.prod_nbij'` is that the bijection and its inverse are allowed to use\nmembership of the domains of the products, rather than being non-dependent functions. -/\n@[to_additive \"Reorder a sum.\n\nThe difference with `Finset.sum_bij` is that the bijection is specified with an inverse, rather than\nas a surjective injection.\n\nThe difference with `Finset.sum_nbij'` is that the bijection and its inverse are allowed to use\nmembership of the domains of the sums, rather than being non-dependent functions.\"]\ntheorem prod_bij' (i : ∀ a ∈ s, κ) (j : ∀ a ∈ t, ι) (hi : ∀ a ha, i a ha ∈ t)\n    (hj : ∀ a ha, j a ha ∈ s) (left_inv : ∀ a ha, j (i a ha) (hi a ha) = a)\n    (right_inv : ∀ a ha, i (j a ha) (hj a ha) = a) (h : ∀ a ha, f a = g (i a ha)) :\n    ∏ x ∈ s, f x = ∏ x ∈ t, g x := by\n  refine prod_bij i hi (fun a1 h1 a2 h2 eq ↦ ?_) (fun b hb ↦ ⟨_, hj b hb, right_inv b hb⟩) h\n  rw [← left_inv a1 h1, ← left_inv a2 h2]\n  simp only [eq]\n\n"}
{"name":"Finset.sum_bij'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : AddCommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ni : (a : ι) → Membership.mem s a → κ\nj : (a : κ) → Membership.mem t a → ι\nhi : ∀ (a : ι) (ha : Membership.mem s a), Membership.mem t (i a ha)\nhj : ∀ (a : κ) (ha : Membership.mem t a), Membership.mem s (j a ha)\nleft_inv : ∀ (a : ι) (ha : Membership.mem s a), Eq (j (i a ha) ⋯) a\nright_inv : ∀ (a : κ) (ha : Membership.mem t a), Eq (i (j a ha) ⋯) a\nh : ∀ (a : ι) (ha : Membership.mem s a), Eq (f a) (g (i a ha))\n⊢ Eq (s.sum fun x => f x) (t.sum fun x => g x)","decl":"/-- Reorder a product.\n\nThe difference with `Finset.prod_bij` is that the bijection is specified with an inverse, rather\nthan as a surjective injection.\n\nThe difference with `Finset.prod_nbij'` is that the bijection and its inverse are allowed to use\nmembership of the domains of the products, rather than being non-dependent functions. -/\n@[to_additive \"Reorder a sum.\n\nThe difference with `Finset.sum_bij` is that the bijection is specified with an inverse, rather than\nas a surjective injection.\n\nThe difference with `Finset.sum_nbij'` is that the bijection and its inverse are allowed to use\nmembership of the domains of the sums, rather than being non-dependent functions.\"]\ntheorem prod_bij' (i : ∀ a ∈ s, κ) (j : ∀ a ∈ t, ι) (hi : ∀ a ha, i a ha ∈ t)\n    (hj : ∀ a ha, j a ha ∈ s) (left_inv : ∀ a ha, j (i a ha) (hi a ha) = a)\n    (right_inv : ∀ a ha, i (j a ha) (hj a ha) = a) (h : ∀ a ha, f a = g (i a ha)) :\n    ∏ x ∈ s, f x = ∏ x ∈ t, g x := by\n  refine prod_bij i hi (fun a1 h1 a2 h2 eq ↦ ?_) (fun b hb ↦ ⟨_, hj b hb, right_inv b hb⟩) h\n  rw [← left_inv a1 h1, ← left_inv a2 h2]\n  simp only [eq]\n\n"}
{"name":"Finset.sum_nbij","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : AddCommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ni : ι → κ\nhi : ∀ (a : ι), Membership.mem s a → Membership.mem t (i a)\ni_inj : Set.InjOn i ↑s\ni_surj : Set.SurjOn i ↑s ↑t\nh : ∀ (a : ι), Membership.mem s a → Eq (f a) (g (i a))\n⊢ Eq (s.sum fun x => f x) (t.sum fun x => g x)","decl":"/-- Reorder a product.\n\nThe difference with `Finset.prod_nbij'` is that the bijection is specified as a surjective\ninjection, rather than by an inverse function.\n\nThe difference with `Finset.prod_bij` is that the bijection is a non-dependent function, rather than\nbeing allowed to use membership of the domain of the product. -/\n@[to_additive \"Reorder a sum.\n\nThe difference with `Finset.sum_nbij'` is that the bijection is specified as a surjective injection,\nrather than by an inverse function.\n\nThe difference with `Finset.sum_bij` is that the bijection is a non-dependent function, rather than\nbeing allowed to use membership of the domain of the sum.\"]\nlemma prod_nbij (i : ι → κ) (hi : ∀ a ∈ s, i a ∈ t) (i_inj : (s : Set ι).InjOn i)\n    (i_surj : (s : Set ι).SurjOn i t) (h : ∀ a ∈ s, f a = g (i a)) :\n    ∏ x ∈ s, f x = ∏ x ∈ t, g x :=\n  prod_bij (fun a _ ↦ i a) hi i_inj (by simpa using i_surj) h\n\n"}
{"name":"Finset.prod_nbij","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : CommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ni : ι → κ\nhi : ∀ (a : ι), Membership.mem s a → Membership.mem t (i a)\ni_inj : Set.InjOn i ↑s\ni_surj : Set.SurjOn i ↑s ↑t\nh : ∀ (a : ι), Membership.mem s a → Eq (f a) (g (i a))\n⊢ Eq (s.prod fun x => f x) (t.prod fun x => g x)","decl":"/-- Reorder a product.\n\nThe difference with `Finset.prod_nbij'` is that the bijection is specified as a surjective\ninjection, rather than by an inverse function.\n\nThe difference with `Finset.prod_bij` is that the bijection is a non-dependent function, rather than\nbeing allowed to use membership of the domain of the product. -/\n@[to_additive \"Reorder a sum.\n\nThe difference with `Finset.sum_nbij'` is that the bijection is specified as a surjective injection,\nrather than by an inverse function.\n\nThe difference with `Finset.sum_bij` is that the bijection is a non-dependent function, rather than\nbeing allowed to use membership of the domain of the sum.\"]\nlemma prod_nbij (i : ι → κ) (hi : ∀ a ∈ s, i a ∈ t) (i_inj : (s : Set ι).InjOn i)\n    (i_surj : (s : Set ι).SurjOn i t) (h : ∀ a ∈ s, f a = g (i a)) :\n    ∏ x ∈ s, f x = ∏ x ∈ t, g x :=\n  prod_bij (fun a _ ↦ i a) hi i_inj (by simpa using i_surj) h\n\n"}
{"name":"Finset.sum_nbij'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : AddCommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ni : ι → κ\nj : κ → ι\nhi : ∀ (a : ι), Membership.mem s a → Membership.mem t (i a)\nhj : ∀ (a : κ), Membership.mem t a → Membership.mem s (j a)\nleft_inv : ∀ (a : ι), Membership.mem s a → Eq (j (i a)) a\nright_inv : ∀ (a : κ), Membership.mem t a → Eq (i (j a)) a\nh : ∀ (a : ι), Membership.mem s a → Eq (f a) (g (i a))\n⊢ Eq (s.sum fun x => f x) (t.sum fun x => g x)","decl":"/-- Reorder a product.\n\nThe difference with `Finset.prod_nbij` is that the bijection is specified with an inverse, rather\nthan as a surjective injection.\n\nThe difference with `Finset.prod_bij'` is that the bijection and its inverse are non-dependent\nfunctions, rather than being allowed to use membership of the domains of the products.\n\nThe difference with `Finset.prod_equiv` is that bijectivity is only required to hold on the domains\nof the products, rather than on the entire types.\n-/\n@[to_additive \"Reorder a sum.\n\nThe difference with `Finset.sum_nbij` is that the bijection is specified with an inverse, rather\nthan as a surjective injection.\n\nThe difference with `Finset.sum_bij'` is that the bijection and its inverse are non-dependent\nfunctions, rather than being allowed to use membership of the domains of the sums.\n\nThe difference with `Finset.sum_equiv` is that bijectivity is only required to hold on the domains\nof the sums, rather than on the entire types.\"]\nlemma prod_nbij' (i : ι → κ) (j : κ → ι) (hi : ∀ a ∈ s, i a ∈ t) (hj : ∀ a ∈ t, j a ∈ s)\n    (left_inv : ∀ a ∈ s, j (i a) = a) (right_inv : ∀ a ∈ t, i (j a) = a)\n    (h : ∀ a ∈ s, f a = g (i a)) : ∏ x ∈ s, f x = ∏ x ∈ t, g x :=\n  prod_bij' (fun a _ ↦ i a) (fun b _ ↦ j b) hi hj left_inv right_inv h\n\n"}
{"name":"Finset.prod_nbij'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : CommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ni : ι → κ\nj : κ → ι\nhi : ∀ (a : ι), Membership.mem s a → Membership.mem t (i a)\nhj : ∀ (a : κ), Membership.mem t a → Membership.mem s (j a)\nleft_inv : ∀ (a : ι), Membership.mem s a → Eq (j (i a)) a\nright_inv : ∀ (a : κ), Membership.mem t a → Eq (i (j a)) a\nh : ∀ (a : ι), Membership.mem s a → Eq (f a) (g (i a))\n⊢ Eq (s.prod fun x => f x) (t.prod fun x => g x)","decl":"/-- Reorder a product.\n\nThe difference with `Finset.prod_nbij` is that the bijection is specified with an inverse, rather\nthan as a surjective injection.\n\nThe difference with `Finset.prod_bij'` is that the bijection and its inverse are non-dependent\nfunctions, rather than being allowed to use membership of the domains of the products.\n\nThe difference with `Finset.prod_equiv` is that bijectivity is only required to hold on the domains\nof the products, rather than on the entire types.\n-/\n@[to_additive \"Reorder a sum.\n\nThe difference with `Finset.sum_nbij` is that the bijection is specified with an inverse, rather\nthan as a surjective injection.\n\nThe difference with `Finset.sum_bij'` is that the bijection and its inverse are non-dependent\nfunctions, rather than being allowed to use membership of the domains of the sums.\n\nThe difference with `Finset.sum_equiv` is that bijectivity is only required to hold on the domains\nof the sums, rather than on the entire types.\"]\nlemma prod_nbij' (i : ι → κ) (j : κ → ι) (hi : ∀ a ∈ s, i a ∈ t) (hj : ∀ a ∈ t, j a ∈ s)\n    (left_inv : ∀ a ∈ s, j (i a) = a) (right_inv : ∀ a ∈ t, i (j a) = a)\n    (h : ∀ a ∈ s, f a = g (i a)) : ∏ x ∈ s, f x = ∏ x ∈ t, g x :=\n  prod_bij' (fun a _ ↦ i a) (fun b _ ↦ j b) hi hj left_inv right_inv h\n\n"}
{"name":"Finset.prod_equiv","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : CommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ne : Equiv ι κ\nhst : ∀ (i : ι), Iff (Membership.mem s i) (Membership.mem t (e i))\nhfg : ∀ (i : ι), Membership.mem s i → Eq (f i) (g (e i))\n⊢ Eq (s.prod fun i => f i) (t.prod fun i => g i)","decl":"/-- Specialization of `Finset.prod_nbij'` that automatically fills in most arguments.\n\nSee `Fintype.prod_equiv` for the version where `s` and `t` are `univ`. -/\n@[to_additive \"`Specialization of `Finset.sum_nbij'` that automatically fills in most arguments.\n\nSee `Fintype.sum_equiv` for the version where `s` and `t` are `univ`.\"]\nlemma prod_equiv (e : ι ≃ κ) (hst : ∀ i, i ∈ s ↔ e i ∈ t) (hfg : ∀ i ∈ s, f i = g (e i)) :\n    ∏ i ∈ s, f i = ∏ i ∈ t, g i := by refine prod_nbij' e e.symm ?_ ?_ ?_ ?_ hfg <;> simp [hst]\n\n"}
{"name":"Finset.sum_equiv","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : AddCommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ne : Equiv ι κ\nhst : ∀ (i : ι), Iff (Membership.mem s i) (Membership.mem t (e i))\nhfg : ∀ (i : ι), Membership.mem s i → Eq (f i) (g (e i))\n⊢ Eq (s.sum fun i => f i) (t.sum fun i => g i)","decl":"/-- Specialization of `Finset.prod_nbij'` that automatically fills in most arguments.\n\nSee `Fintype.prod_equiv` for the version where `s` and `t` are `univ`. -/\n@[to_additive \"`Specialization of `Finset.sum_nbij'` that automatically fills in most arguments.\n\nSee `Fintype.sum_equiv` for the version where `s` and `t` are `univ`.\"]\nlemma prod_equiv (e : ι ≃ κ) (hst : ∀ i, i ∈ s ↔ e i ∈ t) (hfg : ∀ i ∈ s, f i = g (e i)) :\n    ∏ i ∈ s, f i = ∏ i ∈ t, g i := by refine prod_nbij' e e.symm ?_ ?_ ?_ ?_ hfg <;> simp [hst]\n\n"}
{"name":"Finset.sum_bijective","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : AddCommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ne : ι → κ\nhe : Function.Bijective e\nhst : ∀ (i : ι), Iff (Membership.mem s i) (Membership.mem t (e i))\nhfg : ∀ (i : ι), Membership.mem s i → Eq (f i) (g (e i))\n⊢ Eq (s.sum fun i => f i) (t.sum fun i => g i)","decl":"/-- Specialization of `Finset.prod_bij` that automatically fills in most arguments.\n\nSee `Fintype.prod_bijective` for the version where `s` and `t` are `univ`. -/\n@[to_additive \"`Specialization of `Finset.sum_bij` that automatically fills in most arguments.\n\nSee `Fintype.sum_bijective` for the version where `s` and `t` are `univ`.\"]\nlemma prod_bijective (e : ι → κ) (he : e.Bijective) (hst : ∀ i, i ∈ s ↔ e i ∈ t)\n    (hfg : ∀ i ∈ s, f i = g (e i)) :\n    ∏ i ∈ s, f i = ∏ i ∈ t, g i := prod_equiv (.ofBijective e he) hst hfg\n\n"}
{"name":"Finset.prod_bijective","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : CommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ne : ι → κ\nhe : Function.Bijective e\nhst : ∀ (i : ι), Iff (Membership.mem s i) (Membership.mem t (e i))\nhfg : ∀ (i : ι), Membership.mem s i → Eq (f i) (g (e i))\n⊢ Eq (s.prod fun i => f i) (t.prod fun i => g i)","decl":"/-- Specialization of `Finset.prod_bij` that automatically fills in most arguments.\n\nSee `Fintype.prod_bijective` for the version where `s` and `t` are `univ`. -/\n@[to_additive \"`Specialization of `Finset.sum_bij` that automatically fills in most arguments.\n\nSee `Fintype.sum_bijective` for the version where `s` and `t` are `univ`.\"]\nlemma prod_bijective (e : ι → κ) (he : e.Bijective) (hst : ∀ i, i ∈ s ↔ e i ∈ t)\n    (hfg : ∀ i ∈ s, f i = g (e i)) :\n    ∏ i ∈ s, f i = ∏ i ∈ t, g i := prod_equiv (.ofBijective e he) hst hfg\n\n"}
{"name":"Finset.prod_hom_rel","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝¹ : CommMonoid β\ninst✝ : CommMonoid γ\nr : β → γ → Prop\nf : α → β\ng : α → γ\ns : Finset α\nh₁ : r 1 1\nh₂ : ∀ (a : α) (b : β) (c : γ), r b c → r (HMul.hMul (f a) b) (HMul.hMul (g a) c)\n⊢ r (s.prod fun x => f x) (s.prod fun x => g x)","decl":"@[to_additive]\ntheorem prod_hom_rel [CommMonoid γ] {r : β → γ → Prop} {f : α → β} {g : α → γ} {s : Finset α}\n    (h₁ : r 1 1) (h₂ : ∀ a b c, r b c → r (f a * b) (g a * c)) :\n    r (∏ x ∈ s, f x) (∏ x ∈ s, g x) := by\n  delta Finset.prod\n  apply Multiset.prod_hom_rel <;> assumption\n\n"}
{"name":"Finset.sum_hom_rel","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝¹ : AddCommMonoid β\ninst✝ : AddCommMonoid γ\nr : β → γ → Prop\nf : α → β\ng : α → γ\ns : Finset α\nh₁ : r 0 0\nh₂ : ∀ (a : α) (b : β) (c : γ), r b c → r (HAdd.hAdd (f a) b) (HAdd.hAdd (g a) c)\n⊢ r (s.sum fun x => f x) (s.sum fun x => g x)","decl":"@[to_additive]\ntheorem prod_hom_rel [CommMonoid γ] {r : β → γ → Prop} {f : α → β} {g : α → γ} {s : Finset α}\n    (h₁ : r 1 1) (h₂ : ∀ a b c, r b c → r (f a * b) (g a * c)) :\n    r (∏ x ∈ s, f x) (∏ x ∈ s, g x) := by\n  delta Finset.prod\n  apply Multiset.prod_hom_rel <;> assumption\n\n"}
{"name":"Finset.prod_coe_sort_eq_attach","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : CommMonoid β\nf : (Subtype fun x => Membership.mem s x) → β\n⊢ Eq (Finset.univ.prod fun i => f i) (s.attach.prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_coe_sort_eq_attach (f : s → β) : ∏ i : s, f i = ∏ i ∈ s.attach, f i :=\n  rfl\n\n"}
{"name":"Finset.sum_coe_sort_eq_attach","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : AddCommMonoid β\nf : (Subtype fun x => Membership.mem s x) → β\n⊢ Eq (Finset.univ.sum fun i => f i) (s.attach.sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_coe_sort_eq_attach (f : s → β) : ∏ i : s, f i = ∏ i ∈ s.attach, f i :=\n  rfl\n\n"}
{"name":"Finset.sum_ite_index","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\np : Prop\ninst✝ : Decidable p\ns t : Finset α\nf : α → β\n⊢ Eq ((ite p s t).sum fun x => f x) (ite p (s.sum fun x => f x) (t.sum fun x => f x))","decl":"@[to_additive]\ntheorem prod_ite_index (p : Prop) [Decidable p] (s t : Finset α) (f : α → β) :\n    ∏ x ∈ if p then s else t, f x = if p then ∏ x ∈ s, f x else ∏ x ∈ t, f x :=\n  apply_ite (fun s => ∏ x ∈ s, f x) _ _ _\n\n"}
{"name":"Finset.prod_ite_index","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\np : Prop\ninst✝ : Decidable p\ns t : Finset α\nf : α → β\n⊢ Eq ((ite p s t).prod fun x => f x) (ite p (s.prod fun x => f x) (t.prod fun x => f x))","decl":"@[to_additive]\ntheorem prod_ite_index (p : Prop) [Decidable p] (s t : Finset α) (f : α → β) :\n    ∏ x ∈ if p then s else t, f x = if p then ∏ x ∈ s, f x else ∏ x ∈ t, f x :=\n  apply_ite (fun s => ∏ x ∈ s, f x) _ _ _\n\n"}
{"name":"Finset.prod_ite_irrel","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\np : Prop\ninst✝ : Decidable p\ns : Finset α\nf g : α → β\n⊢ Eq (s.prod fun x => ite p (f x) (g x)) (ite p (s.prod fun x => f x) (s.prod fun x => g x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_ite_irrel (p : Prop) [Decidable p] (s : Finset α) (f g : α → β) :\n    ∏ x ∈ s, (if p then f x else g x) = if p then ∏ x ∈ s, f x else ∏ x ∈ s, g x := by\n  split_ifs with h <;> rfl\n\n"}
{"name":"Finset.sum_ite_irrel","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\np : Prop\ninst✝ : Decidable p\ns : Finset α\nf g : α → β\n⊢ Eq (s.sum fun x => ite p (f x) (g x)) (ite p (s.sum fun x => f x) (s.sum fun x => g x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_ite_irrel (p : Prop) [Decidable p] (s : Finset α) (f g : α → β) :\n    ∏ x ∈ s, (if p then f x else g x) = if p then ∏ x ∈ s, f x else ∏ x ∈ s, g x := by\n  split_ifs with h <;> rfl\n\n"}
{"name":"Finset.prod_dite_irrel","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\np : Prop\ninst✝ : Decidable p\ns : Finset α\nf : p → α → β\ng : Not p → α → β\n⊢ Eq (s.prod fun x => dite p (fun h => f h x) fun h => g h x) (dite p (fun h => s.prod fun x => f h x) fun h => s.prod fun x => g h x)","decl":"@[to_additive (attr := simp)]\ntheorem prod_dite_irrel (p : Prop) [Decidable p] (s : Finset α) (f : p → α → β) (g : ¬p → α → β) :\n    ∏ x ∈ s, (if h : p then f h x else g h x) =\n      if h : p then ∏ x ∈ s, f h x else ∏ x ∈ s, g h x := by\n  split_ifs with h <;> rfl\n\n"}
{"name":"Finset.sum_dite_irrel","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\np : Prop\ninst✝ : Decidable p\ns : Finset α\nf : p → α → β\ng : Not p → α → β\n⊢ Eq (s.sum fun x => dite p (fun h => f h x) fun h => g h x) (dite p (fun h => s.sum fun x => f h x) fun h => s.sum fun x => g h x)","decl":"@[to_additive (attr := simp)]\ntheorem prod_dite_irrel (p : Prop) [Decidable p] (s : Finset α) (f : p → α → β) (g : ¬p → α → β) :\n    ∏ x ∈ s, (if h : p then f h x else g h x) =\n      if h : p then ∏ x ∈ s, f h x else ∏ x ∈ s, g h x := by\n  split_ifs with h <;> rfl\n\n"}
{"name":"Finset.ite_prod_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\np : Prop\ninst✝ : Decidable p\ns : Finset α\nf : α → β\n⊢ Eq (ite p (s.prod fun x => f x) 1) (s.prod fun x => ite p (f x) 1)","decl":"@[to_additive]\ntheorem ite_prod_one (p : Prop) [Decidable p] (s : Finset α) (f : α → β) :\n    (if p then (∏ x ∈ s, f x) else 1) = ∏ x ∈ s, if p then f x else 1 := by\n  simp only [prod_ite_irrel, prod_const_one]\n\n"}
{"name":"Finset.ite_sum_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\np : Prop\ninst✝ : Decidable p\ns : Finset α\nf : α → β\n⊢ Eq (ite p (s.sum fun x => f x) 0) (s.sum fun x => ite p (f x) 0)","decl":"@[to_additive]\ntheorem ite_prod_one (p : Prop) [Decidable p] (s : Finset α) (f : α → β) :\n    (if p then (∏ x ∈ s, f x) else 1) = ∏ x ∈ s, if p then f x else 1 := by\n  simp only [prod_ite_irrel, prod_const_one]\n\n"}
{"name":"Finset.ite_one_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\np : Prop\ninst✝ : Decidable p\ns : Finset α\nf : α → β\n⊢ Eq (ite p 1 (s.prod fun x => f x)) (s.prod fun x => ite p 1 (f x))","decl":"@[to_additive]\ntheorem ite_one_prod (p : Prop) [Decidable p] (s : Finset α) (f : α → β) :\n    (if p then 1 else (∏ x ∈ s, f x)) = ∏ x ∈ s, if p then 1 else f x := by\n  simp only [prod_ite_irrel, prod_const_one]\n\n"}
{"name":"Finset.ite_zero_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\np : Prop\ninst✝ : Decidable p\ns : Finset α\nf : α → β\n⊢ Eq (ite p 0 (s.sum fun x => f x)) (s.sum fun x => ite p 0 (f x))","decl":"@[to_additive]\ntheorem ite_one_prod (p : Prop) [Decidable p] (s : Finset α) (f : α → β) :\n    (if p then 1 else (∏ x ∈ s, f x)) = ∏ x ∈ s, if p then 1 else f x := by\n  simp only [prod_ite_irrel, prod_const_one]\n\n"}
{"name":"Finset.nonempty_of_sum_ne_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : AddCommMonoid β\nh : Ne (s.sum fun x => f x) 0\n⊢ s.Nonempty","decl":"@[to_additive]\ntheorem nonempty_of_prod_ne_one (h : ∏ x ∈ s, f x ≠ 1) : s.Nonempty :=\n  s.eq_empty_or_nonempty.elim (fun H => False.elim <| h <| H.symm ▸ prod_empty) id\n\n"}
{"name":"Finset.nonempty_of_prod_ne_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : CommMonoid β\nh : Ne (s.prod fun x => f x) 1\n⊢ s.Nonempty","decl":"@[to_additive]\ntheorem nonempty_of_prod_ne_one (h : ∏ x ∈ s, f x ≠ 1) : s.Nonempty :=\n  s.eq_empty_or_nonempty.elim (fun H => False.elim <| h <| H.symm ▸ prod_empty) id\n\n"}
{"name":"Finset.sum_range_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"β : Type u_4\ninst✝ : AddCommMonoid β\nf : Nat → β\n⊢ Eq ((Finset.range 0).sum fun k => f k) 0","decl":"@[to_additive]\ntheorem prod_range_zero (f : ℕ → β) : ∏ k ∈ range 0, f k = 1 := by rw [range_zero, prod_empty]\n\n"}
{"name":"Finset.prod_range_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"β : Type u_4\ninst✝ : CommMonoid β\nf : Nat → β\n⊢ Eq ((Finset.range 0).prod fun k => f k) 1","decl":"@[to_additive]\ntheorem prod_range_zero (f : ℕ → β) : ∏ k ∈ range 0, f k = 1 := by rw [range_zero, prod_empty]\n\n"}
{"name":"Finset.sum_filter_count_eq_countP","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\np : α → Prop\ninst✝ : DecidablePred p\nl : List α\n⊢ Eq ((Finset.filter (fun x => p x) l.toFinset).sum fun x => List.count x l) (List.countP (fun b => Decidable.decide (p b)) l)","decl":"theorem sum_filter_count_eq_countP [DecidableEq α] (p : α → Prop) [DecidablePred p] (l : List α) :\n    ∑ x ∈ l.toFinset with p x, l.count x = l.countP p := by\n  simp [Finset.sum, sum_map_count_dedup_filter_eq_countP p l]\n\n"}
{"name":"Finset.prod_mem_multiset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\nm : Multiset α\nf : (Subtype fun x => Membership.mem m x) → β\ng : α → β\nhfg : ∀ (x : Subtype fun x => Membership.mem m x), Eq (f x) (g ↑x)\n⊢ Eq (Finset.univ.prod fun x => f x) (m.toFinset.prod fun x => g x)","decl":"@[to_additive]\ntheorem prod_mem_multiset [DecidableEq α] (m : Multiset α) (f : { x // x ∈ m } → β) (g : α → β)\n    (hfg : ∀ x, f x = g x) : ∏ x : { x // x ∈ m }, f x = ∏ x ∈ m.toFinset, g x := by\n  refine prod_bij' (fun x _ ↦ x) (fun x hx ↦ ⟨x, Multiset.mem_toFinset.1 hx⟩) ?_ ?_ ?_ ?_ ?_ <;>\n    simp [hfg]\n\n"}
{"name":"Finset.sum_mem_multiset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\nm : Multiset α\nf : (Subtype fun x => Membership.mem m x) → β\ng : α → β\nhfg : ∀ (x : Subtype fun x => Membership.mem m x), Eq (f x) (g ↑x)\n⊢ Eq (Finset.univ.sum fun x => f x) (m.toFinset.sum fun x => g x)","decl":"@[to_additive]\ntheorem prod_mem_multiset [DecidableEq α] (m : Multiset α) (f : { x // x ∈ m } → β) (g : α → β)\n    (hfg : ∀ x, f x = g x) : ∏ x : { x // x ∈ m }, f x = ∏ x ∈ m.toFinset, g x := by\n  refine prod_bij' (fun x _ ↦ x) (fun x hx ↦ ⟨x, Multiset.mem_toFinset.1 hx⟩) ?_ ?_ ?_ ?_ ?_ <;>\n    simp [hfg]\n\n"}
{"name":"Finset.sum_induction","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ns : Finset α\nM : Type u_6\ninst✝ : AddCommMonoid M\nf : α → M\np : M → Prop\nhom : ∀ (a b : M), p a → p b → p (HAdd.hAdd a b)\nunit : p 0\nbase : ∀ (x : α), Membership.mem s x → p (f x)\n⊢ p (s.sum fun x => f x)","decl":"/-- To prove a property of a product, it suffices to prove that\nthe property is multiplicative and holds on factors. -/\n@[to_additive \"To prove a property of a sum, it suffices to prove that\nthe property is additive and holds on summands.\"]\ntheorem prod_induction {M : Type*} [CommMonoid M] (f : α → M) (p : M → Prop)\n    (hom : ∀ a b, p a → p b → p (a * b)) (unit : p 1) (base : ∀ x ∈ s, p <| f x) :\n    p <| ∏ x ∈ s, f x :=\n  Multiset.prod_induction _ _ hom unit (Multiset.forall_mem_map_iff.mpr base)\n\n"}
{"name":"Finset.prod_induction","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ns : Finset α\nM : Type u_6\ninst✝ : CommMonoid M\nf : α → M\np : M → Prop\nhom : ∀ (a b : M), p a → p b → p (HMul.hMul a b)\nunit : p 1\nbase : ∀ (x : α), Membership.mem s x → p (f x)\n⊢ p (s.prod fun x => f x)","decl":"/-- To prove a property of a product, it suffices to prove that\nthe property is multiplicative and holds on factors. -/\n@[to_additive \"To prove a property of a sum, it suffices to prove that\nthe property is additive and holds on summands.\"]\ntheorem prod_induction {M : Type*} [CommMonoid M] (f : α → M) (p : M → Prop)\n    (hom : ∀ a b, p a → p b → p (a * b)) (unit : p 1) (base : ∀ x ∈ s, p <| f x) :\n    p <| ∏ x ∈ s, f x :=\n  Multiset.prod_induction _ _ hom unit (Multiset.forall_mem_map_iff.mpr base)\n\n"}
{"name":"Finset.prod_induction_nonempty","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ns : Finset α\nM : Type u_6\ninst✝ : CommMonoid M\nf : α → M\np : M → Prop\nhom : ∀ (a b : M), p a → p b → p (HMul.hMul a b)\nnonempty : s.Nonempty\nbase : ∀ (x : α), Membership.mem s x → p (f x)\n⊢ p (s.prod fun x => f x)","decl":"/-- To prove a property of a product, it suffices to prove that\nthe property is multiplicative and holds on factors. -/\n@[to_additive \"To prove a property of a sum, it suffices to prove that\nthe property is additive and holds on summands.\"]\ntheorem prod_induction_nonempty {M : Type*} [CommMonoid M] (f : α → M) (p : M → Prop)\n    (hom : ∀ a b, p a → p b → p (a * b)) (nonempty : s.Nonempty) (base : ∀ x ∈ s, p <| f x) :\n    p <| ∏ x ∈ s, f x :=\n  Multiset.prod_induction_nonempty p hom (by simp [nonempty_iff_ne_empty.mp nonempty])\n    (Multiset.forall_mem_map_iff.mpr base)\n\n"}
{"name":"Finset.sum_induction_nonempty","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ns : Finset α\nM : Type u_6\ninst✝ : AddCommMonoid M\nf : α → M\np : M → Prop\nhom : ∀ (a b : M), p a → p b → p (HAdd.hAdd a b)\nnonempty : s.Nonempty\nbase : ∀ (x : α), Membership.mem s x → p (f x)\n⊢ p (s.sum fun x => f x)","decl":"/-- To prove a property of a product, it suffices to prove that\nthe property is multiplicative and holds on factors. -/\n@[to_additive \"To prove a property of a sum, it suffices to prove that\nthe property is additive and holds on summands.\"]\ntheorem prod_induction_nonempty {M : Type*} [CommMonoid M] (f : α → M) (p : M → Prop)\n    (hom : ∀ a b, p a → p b → p (a * b)) (nonempty : s.Nonempty) (base : ∀ x ∈ s, p <| f x) :\n    p <| ∏ x ∈ s, f x :=\n  Multiset.prod_induction_nonempty p hom (by simp [nonempty_iff_ne_empty.mp nonempty])\n    (Multiset.forall_mem_map_iff.mpr base)\n\n"}
{"name":"Finset.sum_nsmul","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nn : Nat\nf : α → β\n⊢ Eq (s.sum fun x => HSMul.hSMul n (f x)) (HSMul.hSMul n (s.sum fun x => f x))","decl":"@[to_additive]\ntheorem prod_pow (s : Finset α) (n : ℕ) (f : α → β) : ∏ x ∈ s, f x ^ n = (∏ x ∈ s, f x) ^ n :=\n  Multiset.prod_map_pow\n\n"}
{"name":"Finset.prod_pow","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nn : Nat\nf : α → β\n⊢ Eq (s.prod fun x => HPow.hPow (f x) n) (HPow.hPow (s.prod fun x => f x) n)","decl":"@[to_additive]\ntheorem prod_pow (s : Finset α) (n : ℕ) (f : α → β) : ∏ x ∈ s, f x ^ n = (∏ x ∈ s, f x) ^ n :=\n  Multiset.prod_map_pow\n\n"}
{"name":"Finset.prod_dvd_prod_of_subset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nM : Type u_7\ninst✝ : CommMonoid M\ns t : Finset ι\nf : ι → M\nh : HasSubset.Subset s t\n⊢ Dvd.dvd (s.prod fun i => f i) (t.prod fun i => f i)","decl":"theorem prod_dvd_prod_of_subset {ι M : Type*} [CommMonoid M] (s t : Finset ι) (f : ι → M)\n    (h : s ⊆ t) : (∏ i ∈ s, f i) ∣ ∏ i ∈ t, f i :=\n  Multiset.prod_dvd_prod_of_le <| Multiset.map_le_map <| by simpa\n\n"}
{"name":"Finset.op_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → β\n⊢ Eq (MulOpposite.op (s.sum fun x => f x)) (s.sum fun x => MulOpposite.op (f x))","decl":"/-- Moving to the opposite additive commutative monoid commutes with summing. -/\n@[simp]\ntheorem op_sum [AddCommMonoid β] {s : Finset α} (f : α → β) :\n    op (∑ x ∈ s, f x) = ∑ x ∈ s, op (f x) :=\n  map_sum (opAddEquiv : β ≃+ βᵐᵒᵖ) _ _\n\n"}
{"name":"Finset.unop_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → MulOpposite β\n⊢ Eq (MulOpposite.unop (s.sum fun x => f x)) (s.sum fun x => MulOpposite.unop (f x))","decl":"@[simp]\ntheorem unop_sum [AddCommMonoid β] {s : Finset α} (f : α → βᵐᵒᵖ) :\n    unop (∑ x ∈ s, f x) = ∑ x ∈ s, unop (f x) :=\n  map_sum (opAddEquiv : β ≃+ βᵐᵒᵖ).symm _ _\n\n"}
{"name":"Finset.sum_neg_distrib","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : SubtractionCommMonoid β\n⊢ Eq (s.sum fun x => Neg.neg (f x)) (Neg.neg (s.sum fun x => f x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_inv_distrib : (∏ x ∈ s, (f x)⁻¹) = (∏ x ∈ s, f x)⁻¹ :=\n  Multiset.prod_map_inv\n\n"}
{"name":"Finset.prod_inv_distrib","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : DivisionCommMonoid β\n⊢ Eq (s.prod fun x => Inv.inv (f x)) (Inv.inv (s.prod fun x => f x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_inv_distrib : (∏ x ∈ s, (f x)⁻¹) = (∏ x ∈ s, f x)⁻¹ :=\n  Multiset.prod_map_inv\n\n"}
{"name":"Finset.prod_div_distrib","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf g : α → β\ninst✝ : DivisionCommMonoid β\n⊢ Eq (s.prod fun x => HDiv.hDiv (f x) (g x)) (HDiv.hDiv (s.prod fun x => f x) (s.prod fun x => g x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_div_distrib : ∏ x ∈ s, f x / g x = (∏ x ∈ s, f x) / ∏ x ∈ s, g x :=\n  Multiset.prod_map_div\n\n"}
{"name":"Finset.sum_sub_distrib","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf g : α → β\ninst✝ : SubtractionCommMonoid β\n⊢ Eq (s.sum fun x => HSub.hSub (f x) (g x)) (HSub.hSub (s.sum fun x => f x) (s.sum fun x => g x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_div_distrib : ∏ x ∈ s, f x / g x = (∏ x ∈ s, f x) / ∏ x ∈ s, g x :=\n  Multiset.prod_map_div\n\n"}
{"name":"Finset.prod_zpow","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : DivisionCommMonoid β\nf : α → β\ns : Finset α\nn : Int\n⊢ Eq (s.prod fun a => HPow.hPow (f a) n) (HPow.hPow (s.prod fun a => f a) n)","decl":"@[to_additive]\ntheorem prod_zpow (f : α → β) (s : Finset α) (n : ℤ) : ∏ a ∈ s, f a ^ n = (∏ a ∈ s, f a) ^ n :=\n  Multiset.prod_map_zpow\n\n"}
{"name":"Finset.sum_zsmul","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : SubtractionCommMonoid β\nf : α → β\ns : Finset α\nn : Int\n⊢ Eq (s.sum fun a => HSMul.hSMul n (f a)) (HSMul.hSMul n (s.sum fun a => f a))","decl":"@[to_additive]\ntheorem prod_zpow (f : α → β) (s : Finset α) (n : ℤ) : ∏ a ∈ s, f a ^ n = (∏ a ∈ s, f a) ^ n :=\n  Multiset.prod_map_zpow\n\n"}
{"name":"Finset.sum_nat_mod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ns : Finset α\nn : Nat\nf : α → Nat\n⊢ Eq (HMod.hMod (s.sum fun i => f i) n) (HMod.hMod (s.sum fun i => HMod.hMod (f i) n) n)","decl":"theorem sum_nat_mod (s : Finset α) (n : ℕ) (f : α → ℕ) :\n    (∑ i ∈ s, f i) % n = (∑ i ∈ s, f i % n) % n :=\n  (Multiset.sum_nat_mod _ _).trans <| by rw [Finset.sum, Multiset.map_map]; rfl\n\n"}
{"name":"Finset.prod_nat_mod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ns : Finset α\nn : Nat\nf : α → Nat\n⊢ Eq (HMod.hMod (s.prod fun i => f i) n) (HMod.hMod (s.prod fun i => HMod.hMod (f i) n) n)","decl":"theorem prod_nat_mod (s : Finset α) (n : ℕ) (f : α → ℕ) :\n    (∏ i ∈ s, f i) % n = (∏ i ∈ s, f i % n) % n :=\n  (Multiset.prod_nat_mod _ _).trans <| by rw [Finset.prod, Multiset.map_map]; rfl\n\n"}
{"name":"Finset.sum_int_mod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ns : Finset α\nn : Int\nf : α → Int\n⊢ Eq (HMod.hMod (s.sum fun i => f i) n) (HMod.hMod (s.sum fun i => HMod.hMod (f i) n) n)","decl":"theorem sum_int_mod (s : Finset α) (n : ℤ) (f : α → ℤ) :\n    (∑ i ∈ s, f i) % n = (∑ i ∈ s, f i % n) % n :=\n  (Multiset.sum_int_mod _ _).trans <| by rw [Finset.sum, Multiset.map_map]; rfl\n\n"}
{"name":"Finset.prod_int_mod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ns : Finset α\nn : Int\nf : α → Int\n⊢ Eq (HMod.hMod (s.prod fun i => f i) n) (HMod.hMod (s.prod fun i => HMod.hMod (f i) n) n)","decl":"theorem prod_int_mod (s : Finset α) (n : ℤ) (f : α → ℤ) :\n    (∏ i ∈ s, f i) % n = (∏ i ∈ s, f i % n) % n :=\n  (Multiset.prod_int_mod _ _).trans <| by rw [Finset.prod, Multiset.map_map]; rfl\n\n"}
{"name":"Fintype.sum_bijective","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : Fintype κ\ninst✝ : AddCommMonoid α\ne : ι → κ\nhe : Function.Bijective e\nf : ι → α\ng : κ → α\nh : ∀ (x : ι), Eq (f x) (g (e x))\n⊢ Eq (Finset.univ.sum fun x => f x) (Finset.univ.sum fun x => g x)","decl":"/-- `Fintype.prod_bijective` is a variant of `Finset.prod_bij` that accepts `Function.Bijective`.\n\nSee `Function.Bijective.prod_comp` for a version without `h`. -/\n@[to_additive \"`Fintype.sum_bijective` is a variant of `Finset.sum_bij` that accepts\n`Function.Bijective`.\n\nSee `Function.Bijective.sum_comp` for a version without `h`. \"]\nlemma prod_bijective (e : ι → κ) (he : e.Bijective) (f : ι → α) (g : κ → α)\n    (h : ∀ x, f x = g (e x)) : ∏ x, f x = ∏ x, g x :=\n  prod_equiv (.ofBijective e he) (by simp) (by simp [h])\n\n"}
{"name":"Fintype.prod_bijective","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : Fintype κ\ninst✝ : CommMonoid α\ne : ι → κ\nhe : Function.Bijective e\nf : ι → α\ng : κ → α\nh : ∀ (x : ι), Eq (f x) (g (e x))\n⊢ Eq (Finset.univ.prod fun x => f x) (Finset.univ.prod fun x => g x)","decl":"/-- `Fintype.prod_bijective` is a variant of `Finset.prod_bij` that accepts `Function.Bijective`.\n\nSee `Function.Bijective.prod_comp` for a version without `h`. -/\n@[to_additive \"`Fintype.sum_bijective` is a variant of `Finset.sum_bij` that accepts\n`Function.Bijective`.\n\nSee `Function.Bijective.sum_comp` for a version without `h`. \"]\nlemma prod_bijective (e : ι → κ) (he : e.Bijective) (f : ι → α) (g : κ → α)\n    (h : ∀ x, f x = g (e x)) : ∏ x, f x = ∏ x, g x :=\n  prod_equiv (.ofBijective e he) (by simp) (by simp [h])\n\n"}
{"name":"Function.Bijective.finset_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : Fintype κ\ninst✝ : AddCommMonoid α\ne : ι → κ\nhe : Function.Bijective e\nf : ι → α\ng : κ → α\nh : ∀ (x : ι), Eq (f x) (g (e x))\n⊢ Eq (Finset.univ.sum fun x => f x) (Finset.univ.sum fun x => g x)","decl":"@[to_additive] alias _root_.Function.Bijective.finset_prod := prod_bijective\n\n"}
{"name":"Function.Bijective.finset_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : Fintype κ\ninst✝ : CommMonoid α\ne : ι → κ\nhe : Function.Bijective e\nf : ι → α\ng : κ → α\nh : ∀ (x : ι), Eq (f x) (g (e x))\n⊢ Eq (Finset.univ.prod fun x => f x) (Finset.univ.prod fun x => g x)","decl":"@[to_additive] alias _root_.Function.Bijective.finset_prod := prod_bijective\n\n"}
{"name":"Fintype.sum_equiv","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : Fintype κ\ninst✝ : AddCommMonoid α\ne : Equiv ι κ\nf : ι → α\ng : κ → α\nh : ∀ (x : ι), Eq (f x) (g (e x))\n⊢ Eq (Finset.univ.sum fun x => f x) (Finset.univ.sum fun x => g x)","decl":"/-- `Fintype.prod_equiv` is a specialization of `Finset.prod_bij` that\nautomatically fills in most arguments.\n\nSee `Equiv.prod_comp` for a version without `h`.\n-/\n@[to_additive \"`Fintype.sum_equiv` is a specialization of `Finset.sum_bij` that\nautomatically fills in most arguments.\n\nSee `Equiv.sum_comp` for a version without `h`.\"]\nlemma prod_equiv (e : ι ≃ κ) (f : ι → α) (g : κ → α) (h : ∀ x, f x = g (e x)) :\n    ∏ x, f x = ∏ x, g x := prod_bijective _ e.bijective _ _ h\n\n"}
{"name":"Fintype.prod_equiv","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : Fintype κ\ninst✝ : CommMonoid α\ne : Equiv ι κ\nf : ι → α\ng : κ → α\nh : ∀ (x : ι), Eq (f x) (g (e x))\n⊢ Eq (Finset.univ.prod fun x => f x) (Finset.univ.prod fun x => g x)","decl":"/-- `Fintype.prod_equiv` is a specialization of `Finset.prod_bij` that\nautomatically fills in most arguments.\n\nSee `Equiv.prod_comp` for a version without `h`.\n-/\n@[to_additive \"`Fintype.sum_equiv` is a specialization of `Finset.sum_bij` that\nautomatically fills in most arguments.\n\nSee `Equiv.sum_comp` for a version without `h`.\"]\nlemma prod_equiv (e : ι ≃ κ) (f : ι → α) (g : κ → α) (h : ∀ x, f x = g (e x)) :\n    ∏ x, f x = ∏ x, g x := prod_bijective _ e.bijective _ _ h\n\n"}
{"name":"Function.Bijective.sum_comp","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : Fintype κ\ninst✝ : AddCommMonoid α\ne : ι → κ\nhe : Function.Bijective e\ng : κ → α\n⊢ Eq (Finset.univ.sum fun i => g (e i)) (Finset.univ.sum fun i => g i)","decl":"@[to_additive]\nlemma _root_.Function.Bijective.prod_comp {e : ι → κ} (he : e.Bijective) (g : κ → α) :\n    ∏ i, g (e i) = ∏ i, g i := prod_bijective _ he _ _ fun _ ↦ rfl\n\n"}
{"name":"Function.Bijective.prod_comp","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : Fintype κ\ninst✝ : CommMonoid α\ne : ι → κ\nhe : Function.Bijective e\ng : κ → α\n⊢ Eq (Finset.univ.prod fun i => g (e i)) (Finset.univ.prod fun i => g i)","decl":"@[to_additive]\nlemma _root_.Function.Bijective.prod_comp {e : ι → κ} (he : e.Bijective) (g : κ → α) :\n    ∏ i, g (e i) = ∏ i, g i := prod_bijective _ he _ _ fun _ ↦ rfl\n\n"}
{"name":"Equiv.sum_comp","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : Fintype κ\ninst✝ : AddCommMonoid α\ne : Equiv ι κ\ng : κ → α\n⊢ Eq (Finset.univ.sum fun i => g (e i)) (Finset.univ.sum fun i => g i)","decl":"@[to_additive]\nlemma _root_.Equiv.prod_comp (e : ι ≃ κ) (g : κ → α) : ∏ i, g (e i) = ∏ i, g i :=\n  prod_equiv e _ _ fun _ ↦ rfl\n\n"}
{"name":"Equiv.prod_comp","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : Fintype κ\ninst✝ : CommMonoid α\ne : Equiv ι κ\ng : κ → α\n⊢ Eq (Finset.univ.prod fun i => g (e i)) (Finset.univ.prod fun i => g i)","decl":"@[to_additive]\nlemma _root_.Equiv.prod_comp (e : ι ≃ κ) (g : κ → α) : ∏ i, g (e i) = ∏ i, g i :=\n  prod_equiv e _ _ fun _ ↦ rfl\n\n"}
{"name":"Fintype.sum_empty","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : AddCommMonoid β\ninst✝¹ : IsEmpty α\ninst✝ : Fintype α\nf : α → β\n⊢ Eq (Finset.univ.sum fun x => f x) 0","decl":"@[to_additive]\ntheorem prod_empty {α β : Type*} [CommMonoid β] [IsEmpty α] [Fintype α] (f : α → β) :\n    ∏ x : α, f x = 1 :=\n  Finset.prod_of_isEmpty _\n\n"}
{"name":"Fintype.prod_empty","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : CommMonoid β\ninst✝¹ : IsEmpty α\ninst✝ : Fintype α\nf : α → β\n⊢ Eq (Finset.univ.prod fun x => f x) 1","decl":"@[to_additive]\ntheorem prod_empty {α β : Type*} [CommMonoid β] [IsEmpty α] [Fintype α] (f : α → β) :\n    ∏ x : α, f x = 1 :=\n  Finset.prod_of_isEmpty _\n\n"}
{"name":"Finset.sum_attach_univ","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : Fintype ι\nf : (Subtype fun i => Membership.mem Finset.univ i) → α\n⊢ Eq (Finset.univ.attach.sum fun i => f i) (Finset.univ.sum fun i => f ⟨i, ⋯⟩)","decl":"@[to_additive (attr := simp)]\nlemma prod_attach_univ [Fintype ι] (f : {i // i ∈ @univ ι _} → α) :\n    ∏ i ∈ univ.attach, f i = ∏ i, f ⟨i, mem_univ _⟩ :=\n  Fintype.prod_equiv (Equiv.subtypeUnivEquiv mem_univ) _ _ <| by simp\n\n"}
{"name":"Finset.prod_attach_univ","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : Fintype ι\nf : (Subtype fun i => Membership.mem Finset.univ i) → α\n⊢ Eq (Finset.univ.attach.prod fun i => f i) (Finset.univ.prod fun i => f ⟨i, ⋯⟩)","decl":"@[to_additive (attr := simp)]\nlemma prod_attach_univ [Fintype ι] (f : {i // i ∈ @univ ι _} → α) :\n    ∏ i ∈ univ.attach, f i = ∏ i, f ⟨i, mem_univ _⟩ :=\n  Fintype.prod_equiv (Equiv.subtypeUnivEquiv mem_univ) _ _ <| by simp\n\n"}
{"name":"Finset.prod_erase_attach","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : DecidableEq ι\ns : Finset ι\nf : ι → α\ni : Subtype fun x => Membership.mem s x\n⊢ Eq ((s.attach.erase i).prod fun j => f ↑j) ((s.erase ↑i).prod fun j => f j)","decl":"@[to_additive]\ntheorem prod_erase_attach [DecidableEq ι] {s : Finset ι} (f : ι → α) (i : ↑s) :\n    ∏ j ∈ s.attach.erase i, f ↑j = ∏ j ∈ s.erase ↑i, f j := by\n  rw [← Function.Embedding.coe_subtype, ← prod_map]\n  simp [attach_map_val]\n\n"}
{"name":"Finset.sum_erase_attach","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : DecidableEq ι\ns : Finset ι\nf : ι → α\ni : Subtype fun x => Membership.mem s x\n⊢ Eq ((s.attach.erase i).sum fun j => f ↑j) ((s.erase ↑i).sum fun j => f j)","decl":"@[to_additive]\ntheorem prod_erase_attach [DecidableEq ι] {s : Finset ι} (f : ι → α) (i : ↑s) :\n    ∏ j ∈ s.attach.erase i, f ↑j = ∏ j ∈ s.erase ↑i, f j := by\n  rw [← Function.Embedding.coe_subtype, ← prod_map]\n  simp [attach_map_val]\n\n"}
{"name":"Multiset.card_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_1\nα : Type u_3\ns : Finset ι\nf : ι → Multiset α\n⊢ Eq (s.sum fun i => f i).card (s.sum fun i => (f i).card)","decl":"@[simp]\nlemma card_sum (s : Finset ι) (f : ι → Multiset α) : card (∑ i ∈ s, f i) = ∑ i ∈ s, card (f i) :=\n  map_sum cardHom ..\n\n"}
{"name":"Multiset.disjoint_list_sum_left","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\na : Multiset α\nl : List (Multiset α)\n⊢ Iff (Disjoint l.sum a) (∀ (b : Multiset α), Membership.mem l b → Disjoint b a)","decl":"theorem disjoint_list_sum_left {a : Multiset α} {l : List (Multiset α)} :\n    Disjoint l.sum a ↔ ∀ b ∈ l, Disjoint b a := by\n  induction l with\n  | nil =>\n    simp only [zero_disjoint, List.not_mem_nil, IsEmpty.forall_iff, forall_const, List.sum_nil]\n  | cons b bs ih =>\n    simp_rw [List.sum_cons, disjoint_add_left, List.mem_cons, forall_eq_or_imp]\n    simp [and_congr_left_iff, ih]\n\n"}
{"name":"Multiset.disjoint_list_sum_right","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\na : Multiset α\nl : List (Multiset α)\n⊢ Iff (Disjoint a l.sum) (∀ (b : Multiset α), Membership.mem l b → Disjoint a b)","decl":"theorem disjoint_list_sum_right {a : Multiset α} {l : List (Multiset α)} :\n    Disjoint a l.sum ↔ ∀ b ∈ l, Disjoint a b := by\n  simpa only [disjoint_comm (a := a)] using disjoint_list_sum_left\n\n"}
{"name":"Multiset.disjoint_sum_left","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\na : Multiset α\ni : Multiset (Multiset α)\n⊢ Iff (Disjoint i.sum a) (∀ (b : Multiset α), Membership.mem i b → Disjoint b a)","decl":"theorem disjoint_sum_left {a : Multiset α} {i : Multiset (Multiset α)} :\n    Disjoint i.sum a ↔ ∀ b ∈ i, Disjoint b a :=\n  Quotient.inductionOn i fun l => by\n    rw [quot_mk_to_coe, Multiset.sum_coe]\n    exact disjoint_list_sum_left\n\n"}
{"name":"Multiset.disjoint_sum_right","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\na : Multiset α\ni : Multiset (Multiset α)\n⊢ Iff (Disjoint a i.sum) (∀ (b : Multiset α), Membership.mem i b → Disjoint a b)","decl":"theorem disjoint_sum_right {a : Multiset α} {i : Multiset (Multiset α)} :\n    Disjoint a i.sum ↔ ∀ b ∈ i, Disjoint a b := by\n  simpa only [disjoint_comm (a := a)] using disjoint_sum_left\n\n"}
{"name":"Multiset.disjoint_finset_sum_left","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_6\ni : Finset β\nf : β → Multiset α\na : Multiset α\n⊢ Iff (Disjoint (i.sum f) a) (∀ (b : β), Membership.mem i b → Disjoint (f b) a)","decl":"theorem disjoint_finset_sum_left {β : Type*} {i : Finset β} {f : β → Multiset α} {a : Multiset α} :\n    Disjoint (i.sum f) a ↔ ∀ b ∈ i, Disjoint (f b) a := by\n  convert @disjoint_sum_left _ a (map f i.val)\n  simp [and_congr_left_iff]\n\n"}
{"name":"Multiset.disjoint_finset_sum_right","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_6\ni : Finset β\nf : β → Multiset α\na : Multiset α\n⊢ Iff (Disjoint a (i.sum f)) (∀ (b : β), Membership.mem i b → Disjoint a (f b))","decl":"theorem disjoint_finset_sum_right {β : Type*} {i : Finset β} {f : β → Multiset α}\n    {a : Multiset α} : Disjoint a (i.sum f) ↔ ∀ b ∈ i, Disjoint a (f b) := by\n  simpa only [disjoint_comm] using disjoint_finset_sum_left\n\n"}
{"name":"Multiset.count_sum'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : DecidableEq α\ns : Finset β\na : α\nf : β → Multiset α\n⊢ Eq (Multiset.count a (s.sum fun x => f x)) (s.sum fun x => Multiset.count a (f x))","decl":"theorem count_sum' {s : Finset β} {a : α} {f : β → Multiset α} :\n    count a (∑ x ∈ s, f x) = ∑ x ∈ s, count a (f x) := by\n  dsimp only [Finset.sum]\n  rw [count_sum]\n\n"}
{"name":"Multiset.toFinset_prod_dvd_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\ninst✝ : CommMonoid α\nS : Multiset α\n⊢ Dvd.dvd (S.toFinset.prod id) S.prod","decl":"theorem toFinset_prod_dvd_prod [CommMonoid α] (S : Multiset α) : S.toFinset.prod id ∣ S.prod := by\n  rw [Finset.prod_eq_multiset_prod]\n  refine Multiset.prod_dvd_prod_of_le ?_\n  simp [Multiset.dedup_le S]\n\n"}
{"name":"Units.coe_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\nM : Type u_6\ninst✝ : CommMonoid M\nf : α → Units M\ns : Finset α\n⊢ Eq (↑(s.prod fun i => f i)) (s.prod fun i => ↑(f i))","decl":"@[simp, norm_cast]\ntheorem Units.coe_prod {M : Type*} [CommMonoid M] (f : α → Mˣ) (s : Finset α) :\n    (↑(∏ i ∈ s, f i) : M) = ∏ i ∈ s, (f i : M) :=\n  map_prod (Units.coeHom M) _ _\n\n\n"}
{"name":"ofMul_list_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ninst✝ : Monoid α\ns : List α\n⊢ Eq (Additive.ofMul s.prod) (List.map (⇑Additive.ofMul) s).sum","decl":"@[simp]\ntheorem ofMul_list_prod (s : List α) : ofMul s.prod = (s.map ofMul).sum := by simp [ofMul]; rfl\n\n"}
{"name":"toMul_list_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ninst✝ : Monoid α\ns : List (Additive α)\n⊢ Eq (Additive.toMul s.sum) (List.map (⇑Additive.toMul) s).prod","decl":"@[simp]\ntheorem toMul_list_sum (s : List (Additive α)) : s.sum.toMul = (s.map toMul).prod := by\n  simp [toMul, ofMul]; rfl\n\n"}
{"name":"ofAdd_list_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddMonoid α\ns : List α\n⊢ Eq (Multiplicative.ofAdd s.sum) (List.map (⇑Multiplicative.ofAdd) s).prod","decl":"@[simp]\ntheorem ofAdd_list_prod (s : List α) : ofAdd s.sum = (s.map ofAdd).prod := by simp [ofAdd]; rfl\n\n"}
{"name":"toAdd_list_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddMonoid α\ns : List (Multiplicative α)\n⊢ Eq (Multiplicative.toAdd s.prod) (List.map (⇑Multiplicative.toAdd) s).sum","decl":"@[simp]\ntheorem toAdd_list_sum (s : List (Multiplicative α)) : s.prod.toAdd = (s.map toAdd).sum := by\n  simp [toAdd, ofAdd]; rfl\n\n"}
{"name":"ofMul_multiset_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\ns : Multiset α\n⊢ Eq (Additive.ofMul s.prod) (Multiset.map (⇑Additive.ofMul) s).sum","decl":"@[simp]\ntheorem ofMul_multiset_prod (s : Multiset α) : ofMul s.prod = (s.map ofMul).sum := by\n  simp [ofMul]; rfl\n\n"}
{"name":"toMul_multiset_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\ns : Multiset (Additive α)\n⊢ Eq (Additive.toMul s.sum) (Multiset.map (⇑Additive.toMul) s).prod","decl":"@[simp]\ntheorem toMul_multiset_sum (s : Multiset (Additive α)) : s.sum.toMul = (s.map toMul).prod := by\n  simp [toMul, ofMul]; rfl\n\n"}
{"name":"ofMul_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : CommMonoid α\ns : Finset ι\nf : ι → α\n⊢ Eq (Additive.ofMul (s.prod fun i => f i)) (s.sum fun i => Additive.ofMul (f i))","decl":"@[simp]\ntheorem ofMul_prod (s : Finset ι) (f : ι → α) : ofMul (∏ i ∈ s, f i) = ∑ i ∈ s, ofMul (f i) :=\n  rfl\n\n"}
{"name":"toMul_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : CommMonoid α\ns : Finset ι\nf : ι → Additive α\n⊢ Eq (Additive.toMul (s.sum fun i => f i)) (s.prod fun i => Additive.toMul (f i))","decl":"@[simp]\ntheorem toMul_sum (s : Finset ι) (f : ι → Additive α) :\n    (∑ i ∈ s, f i).toMul = ∏ i ∈ s, (f i).toMul :=\n  rfl\n\n"}
{"name":"ofAdd_multiset_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\ns : Multiset α\n⊢ Eq (Multiplicative.ofAdd s.sum) (Multiset.map (⇑Multiplicative.ofAdd) s).prod","decl":"@[simp]\ntheorem ofAdd_multiset_prod (s : Multiset α) : ofAdd s.sum = (s.map ofAdd).prod := by\n  simp [ofAdd]; rfl\n\n"}
{"name":"toAdd_multiset_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\ns : Multiset (Multiplicative α)\n⊢ Eq (Multiplicative.toAdd s.prod) (Multiset.map (⇑Multiplicative.toAdd) s).sum","decl":"@[simp]\ntheorem toAdd_multiset_sum (s : Multiset (Multiplicative α)) :\n    s.prod.toAdd = (s.map toAdd).sum := by\n  simp [toAdd, ofAdd]; rfl\n\n"}
{"name":"ofAdd_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : AddCommMonoid α\ns : Finset ι\nf : ι → α\n⊢ Eq (Multiplicative.ofAdd (s.sum fun i => f i)) (s.prod fun i => Multiplicative.ofAdd (f i))","decl":"@[simp]\ntheorem ofAdd_sum (s : Finset ι) (f : ι → α) : ofAdd (∑ i ∈ s, f i) = ∏ i ∈ s, ofAdd (f i) :=\n  rfl\n\n"}
{"name":"toAdd_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Defs","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝ : AddCommMonoid α\ns : Finset ι\nf : ι → Multiplicative α\n⊢ Eq (Multiplicative.toAdd (s.prod fun i => f i)) (s.sum fun i => Multiplicative.toAdd (f i))","decl":"@[simp]\ntheorem toAdd_prod (s : Finset ι) (f : ι → Multiplicative α) :\n    (∏ i ∈ s, f i).toAdd = ∑ i ∈ s, (f i).toAdd :=\n  rfl\n\n"}
