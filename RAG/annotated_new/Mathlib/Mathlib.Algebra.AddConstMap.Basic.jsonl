{"name":"AddConstMap.map_add_const'","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\nself : AddConstMap G H a b\nx : G\n⊢ Eq (self.toFun (HAdd.hAdd x a)) (HAdd.hAdd (self.toFun x) b)","decl":"/-- A bundled map `f : G → H` such that `f (x + a) = f x + b` for all `x`,\ndenoted as `f: G →+c[a, b] H`.\n\nOne can think about `f` as a lift to `G` of a map between two `AddCircle`s. -/\nstructure AddConstMap (G H : Type*) [Add G] [Add H] (a : G) (b : H) where\n  /-- The underlying function of an `AddConstMap`.\n  Use automatic coercion to function instead. -/\n  protected toFun : G → H\n  /-- An `AddConstMap` satisfies `f (x + a) = f x + b`. Use `map_add_const` instead. -/\n  map_add_const' (x : G) : toFun (x + a) = toFun x + b\n\n"}
{"name":"AddConstMap.mk.inj","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\ntoFun✝ : G → H\nmap_add_const'✝ : ∀ (x : G), Eq (toFun✝ (HAdd.hAdd x a)) (HAdd.hAdd (toFun✝ x) b)\ntoFun : G → H\nmap_add_const' : ∀ (x : G), Eq (toFun (HAdd.hAdd x a)) (HAdd.hAdd (toFun x) b)\nx✝ : Eq { toFun := toFun✝, map_add_const' := map_add_const'✝ } { toFun := toFun, map_add_const' := map_add_const' }\n⊢ Eq toFun✝ toFun","decl":"/-- A bundled map `f : G → H` such that `f (x + a) = f x + b` for all `x`,\ndenoted as `f: G →+c[a, b] H`.\n\nOne can think about `f` as a lift to `G` of a map between two `AddCircle`s. -/\nstructure AddConstMap (G H : Type*) [Add G] [Add H] (a : G) (b : H) where\n  /-- The underlying function of an `AddConstMap`.\n  Use automatic coercion to function instead. -/\n  protected toFun : G → H\n  /-- An `AddConstMap` satisfies `f (x + a) = f x + b`. Use `map_add_const` instead. -/\n  map_add_const' (x : G) : toFun (x + a) = toFun x + b\n\n"}
{"name":"AddConstMap.mk.sizeOf_spec","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝³ : Add G\ninst✝² : Add H\na : G\nb : H\ninst✝¹ : SizeOf G\ninst✝ : SizeOf H\ntoFun : G → H\nmap_add_const' : ∀ (x : G), Eq (toFun (HAdd.hAdd x a)) (HAdd.hAdd (toFun x) b)\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_add_const' := map_add_const' }) 1","decl":"/-- A bundled map `f : G → H` such that `f (x + a) = f x + b` for all `x`,\ndenoted as `f: G →+c[a, b] H`.\n\nOne can think about `f` as a lift to `G` of a map between two `AddCircle`s. -/\nstructure AddConstMap (G H : Type*) [Add G] [Add H] (a : G) (b : H) where\n  /-- The underlying function of an `AddConstMap`.\n  Use automatic coercion to function instead. -/\n  protected toFun : G → H\n  /-- An `AddConstMap` satisfies `f (x + a) = f x + b`. Use `map_add_const` instead. -/\n  map_add_const' (x : G) : toFun (x + a) = toFun x + b\n\n"}
{"name":"AddConstMap.mk.injEq","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\ntoFun✝ : G → H\nmap_add_const'✝ : ∀ (x : G), Eq (toFun✝ (HAdd.hAdd x a)) (HAdd.hAdd (toFun✝ x) b)\ntoFun : G → H\nmap_add_const' : ∀ (x : G), Eq (toFun (HAdd.hAdd x a)) (HAdd.hAdd (toFun x) b)\n⊢ Eq (Eq { toFun := toFun✝, map_add_const' := map_add_const'✝ } { toFun := toFun, map_add_const' := map_add_const' }) (Eq toFun✝ toFun)","decl":"/-- A bundled map `f : G → H` such that `f (x + a) = f x + b` for all `x`,\ndenoted as `f: G →+c[a, b] H`.\n\nOne can think about `f` as a lift to `G` of a map between two `AddCircle`s. -/\nstructure AddConstMap (G H : Type*) [Add G] [Add H] (a : G) (b : H) where\n  /-- The underlying function of an `AddConstMap`.\n  Use automatic coercion to function instead. -/\n  protected toFun : G → H\n  /-- An `AddConstMap` satisfies `f (x + a) = f x + b`. Use `map_add_const` instead. -/\n  map_add_const' (x : G) : toFun (x + a) = toFun x + b\n\n"}
{"name":"AddConstMapClass.map_add_const","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : outParam (Type u_2)\nH : outParam (Type u_3)\ninst✝² : Add G\ninst✝¹ : Add H\na : outParam G\nb : outParam H\ninst✝ : FunLike F G H\nself : AddConstMapClass F G H a b\nf : F\nx : G\n⊢ Eq (f (HAdd.hAdd x a)) (HAdd.hAdd (f x) b)","decl":"/-- Typeclass for maps satisfying `f (x + a) = f x + b`.\n\nNote that `a` and `b` are `outParam`s,\nso one should not add instances like\n`[AddConstMapClass F G H a b] : AddConstMapClass F G H (-a) (-b)`. -/\nclass AddConstMapClass (F : Type*) (G H : outParam Type*) [Add G] [Add H]\n    (a : outParam G) (b : outParam H) [FunLike F G H] : Prop where\n  /-- A map of `AddConstMapClass` class semiconjugates shift by `a` to the shift by `b`:\n  `∀ x, f (x + a) = f x + b`. -/\n  map_add_const (f : F) (x : G) : f (x + a) = f x + b\n\n"}
{"name":"AddConstMapClass.semiconj","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\na : G\nb : H\ninst✝² : Add G\ninst✝¹ : Add H\ninst✝ : AddConstMapClass F G H a b\nf : F\n⊢ Function.Semiconj (⇑f) (fun x => HAdd.hAdd x a) fun x => HAdd.hAdd x b","decl":"protected theorem semiconj [Add G] [Add H] [AddConstMapClass F G H a b] (f : F) :\n    Semiconj f (· + a) (· + b) :=\n  map_add_const f\n\n"}
{"name":"AddConstMapClass.map_add_nsmul","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\na : G\nb : H\ninst✝² : AddMonoid G\ninst✝¹ : AddMonoid H\ninst✝ : AddConstMapClass F G H a b\nf : F\nx : G\nn : Nat\n⊢ Eq (f (HAdd.hAdd x (HSMul.hSMul n a))) (HAdd.hAdd (f x) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_add_nsmul [AddMonoid G] [AddMonoid H] [AddConstMapClass F G H a b]\n    (f : F) (x : G) (n : ℕ) : f (x + n • a) = f x + n • b := by\n  simpa using (AddConstMapClass.semiconj f).iterate_right n x\n\n"}
{"name":"AddConstMapClass.map_add_nat'","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\nb : H\ninst✝² : AddMonoidWithOne G\ninst✝¹ : AddMonoid H\ninst✝ : AddConstMapClass F G H 1 b\nf : F\nx : G\nn : Nat\n⊢ Eq (f (HAdd.hAdd x ↑n)) (HAdd.hAdd (f x) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_add_nat' [AddMonoidWithOne G] [AddMonoid H] [AddConstMapClass F G H 1 b]\n    (f : F) (x : G) (n : ℕ) : f (x + n) = f x + n • b := by simp [← map_add_nsmul]\n\n"}
{"name":"AddConstMapClass.map_add_one","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\nb : H\ninst✝² : AddMonoidWithOne G\ninst✝¹ : Add H\ninst✝ : AddConstMapClass F G H 1 b\nf : F\nx : G\n⊢ Eq (f (HAdd.hAdd x 1)) (HAdd.hAdd (f x) b)","decl":"theorem map_add_one [AddMonoidWithOne G] [Add H] [AddConstMapClass F G H 1 b]\n    (f : F) (x : G) : f (x + 1) = f x + b := map_add_const f x\n\n"}
{"name":"AddConstMapClass.map_add_ofNat'","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁴ : FunLike F G H\nb : H\ninst✝³ : AddMonoidWithOne G\ninst✝² : AddMonoid H\ninst✝¹ : AddConstMapClass F G H 1 b\nf : F\nx : G\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (f (HAdd.hAdd x (OfNat.ofNat n))) (HAdd.hAdd (f x) (HSMul.hSMul (OfNat.ofNat n) b))","decl":"@[scoped simp]\ntheorem map_add_ofNat' [AddMonoidWithOne G] [AddMonoid H] [AddConstMapClass F G H 1 b]\n    (f : F) (x : G) (n : ℕ) [n.AtLeastTwo] :\n    f (x + ofNat(n)) = f x + (ofNat(n) : ℕ) • b :=\n  map_add_nat' f x n\n\n"}
{"name":"AddConstMapClass.map_add_nat","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\ninst✝² : AddMonoidWithOne G\ninst✝¹ : AddMonoidWithOne H\ninst✝ : AddConstMapClass F G H 1 1\nf : F\nx : G\nn : Nat\n⊢ Eq (f (HAdd.hAdd x ↑n)) (HAdd.hAdd (f x) ↑n)","decl":"theorem map_add_nat [AddMonoidWithOne G] [AddMonoidWithOne H] [AddConstMapClass F G H 1 1]\n    (f : F) (x : G) (n : ℕ) : f (x + n) = f x + n := by simp\n\n"}
{"name":"AddConstMapClass.map_add_ofNat","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁴ : FunLike F G H\ninst✝³ : AddMonoidWithOne G\ninst✝² : AddMonoidWithOne H\ninst✝¹ : AddConstMapClass F G H 1 1\nf : F\nx : G\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (f (HAdd.hAdd x (OfNat.ofNat n))) (HAdd.hAdd (f x) (OfNat.ofNat n))","decl":"theorem map_add_ofNat [AddMonoidWithOne G] [AddMonoidWithOne H] [AddConstMapClass F G H 1 1]\n    (f : F) (x : G) (n : ℕ) [n.AtLeastTwo] :\n    f (x + ofNat(n)) = f x + ofNat(n) := map_add_nat f x n\n\n"}
{"name":"AddConstMapClass.map_const","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\na : G\nb : H\ninst✝² : AddZeroClass G\ninst✝¹ : Add H\ninst✝ : AddConstMapClass F G H a b\nf : F\n⊢ Eq (f a) (HAdd.hAdd (f 0) b)","decl":"@[scoped simp]\ntheorem map_const [AddZeroClass G] [Add H] [AddConstMapClass F G H a b] (f : F) :\n    f a = f 0 + b := by\n  simpa using map_add_const f 0\n\n"}
{"name":"AddConstMapClass.map_one","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁴ : FunLike F G H\nb : H\ninst✝³ : AddZeroClass G\ninst✝² : One G\ninst✝¹ : Add H\ninst✝ : AddConstMapClass F G H 1 b\nf : F\n⊢ Eq (f 1) (HAdd.hAdd (f 0) b)","decl":"theorem map_one [AddZeroClass G] [One G] [Add H] [AddConstMapClass F G H 1 b] (f : F) :\n    f 1 = f 0 + b :=\n  map_const f\n\n"}
{"name":"AddConstMapClass.map_nsmul_const","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\na : G\nb : H\ninst✝² : AddMonoid G\ninst✝¹ : AddMonoid H\ninst✝ : AddConstMapClass F G H a b\nf : F\nn : Nat\n⊢ Eq (f (HSMul.hSMul n a)) (HAdd.hAdd (f 0) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_nsmul_const [AddMonoid G] [AddMonoid H] [AddConstMapClass F G H a b]\n    (f : F) (n : ℕ) : f (n • a) = f 0 + n • b := by\n  simpa using map_add_nsmul f 0 n\n\n"}
{"name":"AddConstMapClass.map_nat'","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\nb : H\ninst✝² : AddMonoidWithOne G\ninst✝¹ : AddMonoid H\ninst✝ : AddConstMapClass F G H 1 b\nf : F\nn : Nat\n⊢ Eq (f ↑n) (HAdd.hAdd (f 0) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_nat' [AddMonoidWithOne G] [AddMonoid H] [AddConstMapClass F G H 1 b]\n    (f : F) (n : ℕ) : f n = f 0 + n • b := by\n  simpa using map_add_nat' f 0 n\n\n"}
{"name":"AddConstMapClass.map_ofNat'","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁴ : FunLike F G H\nb : H\ninst✝³ : AddMonoidWithOne G\ninst✝² : AddMonoid H\ninst✝¹ : AddConstMapClass F G H 1 b\nf : F\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (f (OfNat.ofNat n)) (HAdd.hAdd (f 0) (HSMul.hSMul (OfNat.ofNat n) b))","decl":"theorem map_ofNat' [AddMonoidWithOne G] [AddMonoid H] [AddConstMapClass F G H 1 b]\n    (f : F) (n : ℕ) [n.AtLeastTwo] :\n    f (ofNat(n)) = f 0 + (ofNat(n) : ℕ) • b :=\n  map_nat' f n\n\n"}
{"name":"AddConstMapClass.map_nat","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\ninst✝² : AddMonoidWithOne G\ninst✝¹ : AddMonoidWithOne H\ninst✝ : AddConstMapClass F G H 1 1\nf : F\nn : Nat\n⊢ Eq (f ↑n) (HAdd.hAdd (f 0) ↑n)","decl":"theorem map_nat [AddMonoidWithOne G] [AddMonoidWithOne H] [AddConstMapClass F G H 1 1]\n    (f : F) (n : ℕ) : f n = f 0 + n := by simp\n\n"}
{"name":"AddConstMapClass.map_ofNat","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁴ : FunLike F G H\ninst✝³ : AddMonoidWithOne G\ninst✝² : AddMonoidWithOne H\ninst✝¹ : AddConstMapClass F G H 1 1\nf : F\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (f (OfNat.ofNat n)) (HAdd.hAdd (f 0) (OfNat.ofNat n))","decl":"theorem map_ofNat [AddMonoidWithOne G] [AddMonoidWithOne H] [AddConstMapClass F G H 1 1]\n    (f : F) (n : ℕ) [n.AtLeastTwo] :\n    f ofNat(n) = f 0 + ofNat(n) := map_nat f n\n\n"}
{"name":"AddConstMapClass.map_const_add","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\na : G\nb : H\ninst✝² : AddCommSemigroup G\ninst✝¹ : Add H\ninst✝ : AddConstMapClass F G H a b\nf : F\nx : G\n⊢ Eq (f (HAdd.hAdd a x)) (HAdd.hAdd (f x) b)","decl":"@[scoped simp]\ntheorem map_const_add [AddCommSemigroup G] [Add H] [AddConstMapClass F G H a b]\n    (f : F) (x : G) : f (a + x) = f x + b := by\n  rw [add_comm, map_add_const]\n\n"}
{"name":"AddConstMapClass.map_one_add","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\nb : H\ninst✝² : AddCommMonoidWithOne G\ninst✝¹ : Add H\ninst✝ : AddConstMapClass F G H 1 b\nf : F\nx : G\n⊢ Eq (f (HAdd.hAdd 1 x)) (HAdd.hAdd (f x) b)","decl":"theorem map_one_add [AddCommMonoidWithOne G] [Add H] [AddConstMapClass F G H 1 b]\n    (f : F) (x : G) : f (1 + x) = f x + b := map_const_add f x\n\n"}
{"name":"AddConstMapClass.map_nsmul_add","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\na : G\nb : H\ninst✝² : AddCommMonoid G\ninst✝¹ : AddMonoid H\ninst✝ : AddConstMapClass F G H a b\nf : F\nn : Nat\nx : G\n⊢ Eq (f (HAdd.hAdd (HSMul.hSMul n a) x)) (HAdd.hAdd (f x) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_nsmul_add [AddCommMonoid G] [AddMonoid H] [AddConstMapClass F G H a b]\n    (f : F) (n : ℕ) (x : G) : f (n • a + x) = f x + n • b := by\n  rw [add_comm, map_add_nsmul]\n\n"}
{"name":"AddConstMapClass.map_nat_add'","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\nb : H\ninst✝² : AddCommMonoidWithOne G\ninst✝¹ : AddMonoid H\ninst✝ : AddConstMapClass F G H 1 b\nf : F\nn : Nat\nx : G\n⊢ Eq (f (HAdd.hAdd (↑n) x)) (HAdd.hAdd (f x) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_nat_add' [AddCommMonoidWithOne G] [AddMonoid H] [AddConstMapClass F G H 1 b]\n    (f : F) (n : ℕ) (x : G) : f (↑n + x) = f x + n • b := by\n  simpa using map_nsmul_add f n x\n\n"}
{"name":"AddConstMapClass.map_ofNat_add'","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁴ : FunLike F G H\nb : H\ninst✝³ : AddCommMonoidWithOne G\ninst✝² : AddMonoid H\ninst✝¹ : AddConstMapClass F G H 1 b\nf : F\nn : Nat\ninst✝ : n.AtLeastTwo\nx : G\n⊢ Eq (f (HAdd.hAdd (OfNat.ofNat n) x)) (HAdd.hAdd (f x) (HSMul.hSMul (OfNat.ofNat n) b))","decl":"theorem map_ofNat_add' [AddCommMonoidWithOne G] [AddMonoid H] [AddConstMapClass F G H 1 b]\n    (f : F) (n : ℕ) [n.AtLeastTwo] (x : G) :\n    f (ofNat(n) + x) = f x + ofNat(n) • b :=\n  map_nat_add' f n x\n\n"}
{"name":"AddConstMapClass.map_nat_add","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\ninst✝² : AddCommMonoidWithOne G\ninst✝¹ : AddMonoidWithOne H\ninst✝ : AddConstMapClass F G H 1 1\nf : F\nn : Nat\nx : G\n⊢ Eq (f (HAdd.hAdd (↑n) x)) (HAdd.hAdd (f x) ↑n)","decl":"theorem map_nat_add [AddCommMonoidWithOne G] [AddMonoidWithOne H] [AddConstMapClass F G H 1 1]\n    (f : F) (n : ℕ) (x : G) : f (↑n + x) = f x + n := by simp\n\n"}
{"name":"AddConstMapClass.map_ofNat_add","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁴ : FunLike F G H\ninst✝³ : AddCommMonoidWithOne G\ninst✝² : AddMonoidWithOne H\ninst✝¹ : AddConstMapClass F G H 1 1\nf : F\nn : Nat\ninst✝ : n.AtLeastTwo\nx : G\n⊢ Eq (f (HAdd.hAdd (OfNat.ofNat n) x)) (HAdd.hAdd (f x) (OfNat.ofNat n))","decl":"theorem map_ofNat_add [AddCommMonoidWithOne G] [AddMonoidWithOne H] [AddConstMapClass F G H 1 1]\n    (f : F) (n : ℕ) [n.AtLeastTwo] (x : G) :\n    f (ofNat(n) + x) = f x + ofNat(n) :=\n  map_nat_add f n x\n\n"}
{"name":"AddConstMapClass.map_sub_nsmul","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\na : G\nb : H\ninst✝² : AddGroup G\ninst✝¹ : AddGroup H\ninst✝ : AddConstMapClass F G H a b\nf : F\nx : G\nn : Nat\n⊢ Eq (f (HSub.hSub x (HSMul.hSMul n a))) (HSub.hSub (f x) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_sub_nsmul [AddGroup G] [AddGroup H] [AddConstMapClass F G H a b]\n    (f : F) (x : G) (n : ℕ) : f (x - n • a) = f x - n • b := by\n  conv_rhs => rw [← sub_add_cancel x (n • a), map_add_nsmul, add_sub_cancel_right]\n\n"}
{"name":"AddConstMapClass.map_sub_const","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\na : G\nb : H\ninst✝² : AddGroup G\ninst✝¹ : AddGroup H\ninst✝ : AddConstMapClass F G H a b\nf : F\nx : G\n⊢ Eq (f (HSub.hSub x a)) (HSub.hSub (f x) b)","decl":"@[scoped simp]\ntheorem map_sub_const [AddGroup G] [AddGroup H] [AddConstMapClass F G H a b]\n    (f : F) (x : G) : f (x - a) = f x - b := by\n  simpa using map_sub_nsmul f x 1\n\n"}
{"name":"AddConstMapClass.map_sub_one","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁴ : FunLike F G H\nb : H\ninst✝³ : AddGroup G\ninst✝² : One G\ninst✝¹ : AddGroup H\ninst✝ : AddConstMapClass F G H 1 b\nf : F\nx : G\n⊢ Eq (f (HSub.hSub x 1)) (HSub.hSub (f x) b)","decl":"theorem map_sub_one [AddGroup G] [One G] [AddGroup H] [AddConstMapClass F G H 1 b]\n    (f : F) (x : G) : f (x - 1) = f x - b :=\n  map_sub_const f x\n\n"}
{"name":"AddConstMapClass.map_sub_nat'","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\nb : H\ninst✝² : AddGroupWithOne G\ninst✝¹ : AddGroup H\ninst✝ : AddConstMapClass F G H 1 b\nf : F\nx : G\nn : Nat\n⊢ Eq (f (HSub.hSub x ↑n)) (HSub.hSub (f x) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_sub_nat' [AddGroupWithOne G] [AddGroup H] [AddConstMapClass F G H 1 b]\n    (f : F) (x : G) (n : ℕ) : f (x - n) = f x - n • b := by\n  simpa using map_sub_nsmul f x n\n\n"}
{"name":"AddConstMapClass.map_sub_ofNat'","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁴ : FunLike F G H\nb : H\ninst✝³ : AddGroupWithOne G\ninst✝² : AddGroup H\ninst✝¹ : AddConstMapClass F G H 1 b\nf : F\nx : G\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (f (HSub.hSub x (OfNat.ofNat n))) (HSub.hSub (f x) (HSMul.hSMul (OfNat.ofNat n) b))","decl":"@[scoped simp]\ntheorem map_sub_ofNat' [AddGroupWithOne G] [AddGroup H] [AddConstMapClass F G H 1 b]\n    (f : F) (x : G) (n : ℕ) [n.AtLeastTwo] :\n    f (x - ofNat(n)) = f x - ofNat(n) • b :=\n  map_sub_nat' f x n\n\n"}
{"name":"AddConstMapClass.map_add_zsmul","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\na : G\nb : H\ninst✝² : AddGroup G\ninst✝¹ : AddGroup H\ninst✝ : AddConstMapClass F G H a b\nf : F\nx : G\nn : Int\n⊢ Eq (f (HAdd.hAdd x (HSMul.hSMul n a))) (HAdd.hAdd (f x) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_add_zsmul [AddGroup G] [AddGroup H] [AddConstMapClass F G H a b]\n    (f : F) (x : G) : ∀ n : ℤ, f (x + n • a) = f x + n • b\n  | (n : ℕ) => by simp\n  | .negSucc n => by simp [← sub_eq_add_neg]\n\n"}
{"name":"AddConstMapClass.map_zsmul_const","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\na : G\nb : H\ninst✝² : AddGroup G\ninst✝¹ : AddGroup H\ninst✝ : AddConstMapClass F G H a b\nf : F\nn : Int\n⊢ Eq (f (HSMul.hSMul n a)) (HAdd.hAdd (f 0) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_zsmul_const [AddGroup G] [AddGroup H] [AddConstMapClass F G H a b]\n    (f : F) (n : ℤ) : f (n • a) = f 0 + n • b := by\n  simpa using map_add_zsmul f 0 n\n\n"}
{"name":"AddConstMapClass.map_add_int'","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\nb : H\ninst✝² : AddGroupWithOne G\ninst✝¹ : AddGroup H\ninst✝ : AddConstMapClass F G H 1 b\nf : F\nx : G\nn : Int\n⊢ Eq (f (HAdd.hAdd x ↑n)) (HAdd.hAdd (f x) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_add_int' [AddGroupWithOne G] [AddGroup H] [AddConstMapClass F G H 1 b]\n    (f : F) (x : G) (n : ℤ) : f (x + n) = f x + n • b := by\n  rw [← map_add_zsmul f x n, zsmul_one]\n\n"}
{"name":"AddConstMapClass.map_add_int","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\ninst✝² : AddGroupWithOne G\ninst✝¹ : AddGroupWithOne H\ninst✝ : AddConstMapClass F G H 1 1\nf : F\nx : G\nn : Int\n⊢ Eq (f (HAdd.hAdd x ↑n)) (HAdd.hAdd (f x) ↑n)","decl":"theorem map_add_int [AddGroupWithOne G] [AddGroupWithOne H] [AddConstMapClass F G H 1 1]\n    (f : F) (x : G) (n : ℤ) : f (x + n) = f x + n := by simp\n\n"}
{"name":"AddConstMapClass.map_sub_zsmul","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\na : G\nb : H\ninst✝² : AddGroup G\ninst✝¹ : AddGroup H\ninst✝ : AddConstMapClass F G H a b\nf : F\nx : G\nn : Int\n⊢ Eq (f (HSub.hSub x (HSMul.hSMul n a))) (HSub.hSub (f x) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_sub_zsmul [AddGroup G] [AddGroup H] [AddConstMapClass F G H a b]\n    (f : F) (x : G) (n : ℤ) : f (x - n • a) = f x - n • b := by\n  simpa [sub_eq_add_neg] using map_add_zsmul f x (-n)\n\n"}
{"name":"AddConstMapClass.map_sub_int'","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\nb : H\ninst✝² : AddGroupWithOne G\ninst✝¹ : AddGroup H\ninst✝ : AddConstMapClass F G H 1 b\nf : F\nx : G\nn : Int\n⊢ Eq (f (HSub.hSub x ↑n)) (HSub.hSub (f x) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_sub_int' [AddGroupWithOne G] [AddGroup H] [AddConstMapClass F G H 1 b]\n    (f : F) (x : G) (n : ℤ) : f (x - n) = f x - n • b := by\n  rw [← map_sub_zsmul, zsmul_one]\n\n"}
{"name":"AddConstMapClass.map_sub_int","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\ninst✝² : AddGroupWithOne G\ninst✝¹ : AddGroupWithOne H\ninst✝ : AddConstMapClass F G H 1 1\nf : F\nx : G\nn : Int\n⊢ Eq (f (HSub.hSub x ↑n)) (HSub.hSub (f x) ↑n)","decl":"theorem map_sub_int [AddGroupWithOne G] [AddGroupWithOne H] [AddConstMapClass F G H 1 1]\n    (f : F) (x : G) (n : ℤ) : f (x - n) = f x - n := by simp\n\n"}
{"name":"AddConstMapClass.map_zsmul_add","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\na : G\nb : H\ninst✝² : AddCommGroup G\ninst✝¹ : AddGroup H\ninst✝ : AddConstMapClass F G H a b\nf : F\nn : Int\nx : G\n⊢ Eq (f (HAdd.hAdd (HSMul.hSMul n a) x)) (HAdd.hAdd (f x) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_zsmul_add [AddCommGroup G] [AddGroup H] [AddConstMapClass F G H a b]\n    (f : F) (n : ℤ) (x : G) : f (n • a + x) = f x + n • b := by\n  rw [add_comm, map_add_zsmul]\n\n"}
{"name":"AddConstMapClass.map_int_add'","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\nb : H\ninst✝² : AddCommGroupWithOne G\ninst✝¹ : AddGroup H\ninst✝ : AddConstMapClass F G H 1 b\nf : F\nn : Int\nx : G\n⊢ Eq (f (HAdd.hAdd (↑n) x)) (HAdd.hAdd (f x) (HSMul.hSMul n b))","decl":"@[scoped simp]\ntheorem map_int_add' [AddCommGroupWithOne G] [AddGroup H] [AddConstMapClass F G H 1 b]\n    (f : F) (n : ℤ) (x : G) : f (↑n + x) = f x + n • b := by\n  rw [← map_zsmul_add, zsmul_one]\n\n"}
{"name":"AddConstMapClass.map_int_add","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝³ : FunLike F G H\ninst✝² : AddCommGroupWithOne G\ninst✝¹ : AddGroupWithOne H\ninst✝ : AddConstMapClass F G H 1 1\nf : F\nn : Int\nx : G\n⊢ Eq (f (HAdd.hAdd (↑n) x)) (HAdd.hAdd (f x) ↑n)","decl":"theorem map_int_add [AddCommGroupWithOne G] [AddGroupWithOne H] [AddConstMapClass F G H 1 1]\n    (f : F) (n : ℤ) (x : G) : f (↑n + x) = f x + n := by simp\n\n"}
{"name":"AddConstMapClass.map_fract","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nH : Type u_3\nb : H\nR : Type u_4\ninst✝⁴ : LinearOrderedRing R\ninst✝³ : FloorRing R\ninst✝² : AddGroup H\ninst✝¹ : FunLike F R H\ninst✝ : AddConstMapClass F R H 1 b\nf : F\nx : R\n⊢ Eq (f (Int.fract x)) (HSub.hSub (f x) (HSMul.hSMul (Int.floor x) b))","decl":"theorem map_fract {R : Type*} [LinearOrderedRing R] [FloorRing R] [AddGroup H]\n    [FunLike F R H] [AddConstMapClass F R H 1 b] (f : F) (x : R) :\n    f (Int.fract x) = f x - ⌊x⌋ • b :=\n  map_sub_int' ..\n\n"}
{"name":"AddConstMapClass.rel_map_of_Icc","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁵ : FunLike F G H\na : G\nb : H\ninst✝⁴ : LinearOrderedAddCommGroup G\ninst✝³ : Archimedean G\ninst✝² : AddGroup H\ninst✝¹ : AddConstMapClass F G H a b\nf : F\nR : H → H → Prop\ninst✝ : IsTrans H R\nhR : CovariantClass H H (fun x y => HAdd.hAdd y x) R\nha : LT.lt 0 a\nl : G\nhf : ∀ (x : G), Membership.mem (Set.Icc l (HAdd.hAdd l a)) x → ∀ (y : G), Membership.mem (Set.Icc l (HAdd.hAdd l a)) y → LT.lt x y → R (f x) (f y)\n⊢ Relator.LiftFun (fun x1 x2 => LT.lt x1 x2) R ⇑f ⇑f","decl":"/-- Auxiliary lemmas for the \"monotonicity on a fundamental interval implies monotonicity\" lemmas.\nWe formulate it for any relation so that the proof works both for `Monotone` and `StrictMono`. -/\nprotected theorem rel_map_of_Icc [LinearOrderedAddCommGroup G] [Archimedean G] [AddGroup H]\n    [AddConstMapClass F G H a b] {f : F} {R : H → H → Prop} [IsTrans H R]\n    [hR : CovariantClass H H (fun x y ↦ y + x) R] (ha : 0 < a) {l : G}\n    (hf : ∀ x ∈ Icc l (l + a), ∀ y ∈ Icc l (l + a), x < y → R (f x) (f y)) :\n    ((· < ·) ⇒ R) f f := fun x y hxy ↦ by\n  replace hR := hR.elim\n  have ha' : 0 ≤ a := ha.le\n  -- Shift both points by `m • a` so that `l ≤ x < l + a`\n  wlog hx : x ∈ Ico l (l + a) generalizing x y\n  · rcases existsUnique_sub_zsmul_mem_Ico ha x l with ⟨m, hm, -⟩\n    suffices R (f (x - m • a)) (f (y - m • a)) by simpa using hR (m • b) this\n    exact this _ _ (by simpa) hm\n  · -- Now find `n` such that `l + n • a < y ≤ l + (n + 1) • a`\n    rcases existsUnique_sub_zsmul_mem_Ioc ha y l with ⟨n, hny, -⟩\n    rcases lt_trichotomy n 0 with hn | rfl | hn\n    · -- Since `l ≤ x ≤ y`, the case `n < 0` is impossible\n      refine absurd ?_ hxy.not_le\n      calc\n        y ≤ l + a + n • a := sub_le_iff_le_add.1 hny.2\n        _ = l + (n + 1) • a := by rw [add_comm n, add_smul, one_smul, add_assoc]\n        _ ≤ l + 0 • a := add_le_add_left (zsmul_le_zsmul_left ha.le (by omega)) _\n        _ ≤ x := by simpa using hx.1\n    · -- If `n = 0`, then `l < y ≤ l + a`, hence we can apply the assumption\n      exact hf x (Ico_subset_Icc_self hx) y (by simpa using Ioc_subset_Icc_self hny) hxy\n    · -- In the remaining case `0 < n` we use transitivity.\n      -- If `R = (· < ·)`, then the proof looks like\n      -- `f x < f (l + a) ≤ f (l + n • a) < f y`\n      trans f (l + (1 : ℤ) • a)\n      · rw [one_zsmul]\n        exact hf x (Ico_subset_Icc_self hx) (l + a) (by simpa) hx.2\n      have hy : R (f (l + n • a)) (f y) := by\n        rw [← sub_add_cancel y (n • a), map_add_zsmul, map_add_zsmul]\n        refine hR _ <| hf _ ?_ _ (Ioc_subset_Icc_self hny) hny.1; simpa\n      rw [← Int.add_one_le_iff, zero_add] at hn\n      rcases hn.eq_or_lt with rfl | hn; · assumption\n      trans f (l + n • a)\n      · refine Int.rel_of_forall_rel_succ_of_lt R (f := (f <| l + · • a)) (fun k ↦ ?_) hn\n        simp_rw [add_comm k 1, add_zsmul, ← add_assoc, one_zsmul, map_add_zsmul]\n        refine hR (k • b) (hf _ ?_ _ ?_ ?_) <;> simpa\n      · assumption\n\n"}
{"name":"AddConstMapClass.monotone_iff_Icc","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁴ : FunLike F G H\na : G\nb : H\ninst✝³ : LinearOrderedAddCommGroup G\ninst✝² : Archimedean G\ninst✝¹ : OrderedAddCommGroup H\ninst✝ : AddConstMapClass F G H a b\nf : F\nha : LT.lt 0 a\nl : G\n⊢ Iff (Monotone ⇑f) (MonotoneOn (⇑f) (Set.Icc l (HAdd.hAdd l a)))","decl":"theorem monotone_iff_Icc [LinearOrderedAddCommGroup G] [Archimedean G] [OrderedAddCommGroup H]\n    [AddConstMapClass F G H a b] {f : F} (ha : 0 < a) (l : G) :\n    Monotone f ↔ MonotoneOn f (Icc l (l + a)) :=\n  ⟨(Monotone.monotoneOn · _), fun hf ↦ monotone_iff_forall_lt.2 <|\n    AddConstMapClass.rel_map_of_Icc ha fun _x hx _y hy hxy ↦ hf hx hy hxy.le⟩\n\n"}
{"name":"AddConstMapClass.antitone_iff_Icc","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁴ : FunLike F G H\na : G\nb : H\ninst✝³ : LinearOrderedAddCommGroup G\ninst✝² : Archimedean G\ninst✝¹ : OrderedAddCommGroup H\ninst✝ : AddConstMapClass F G H a b\nf : F\nha : LT.lt 0 a\nl : G\n⊢ Iff (Antitone ⇑f) (AntitoneOn (⇑f) (Set.Icc l (HAdd.hAdd l a)))","decl":"theorem antitone_iff_Icc [LinearOrderedAddCommGroup G] [Archimedean G] [OrderedAddCommGroup H]\n    [AddConstMapClass F G H a b] {f : F} (ha : 0 < a) (l : G) :\n    Antitone f ↔ AntitoneOn f (Icc l (l + a)) :=\n  monotone_iff_Icc (H := Hᵒᵈ) ha l\n\n"}
{"name":"AddConstMapClass.strictMono_iff_Icc","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁴ : FunLike F G H\na : G\nb : H\ninst✝³ : LinearOrderedAddCommGroup G\ninst✝² : Archimedean G\ninst✝¹ : OrderedAddCommGroup H\ninst✝ : AddConstMapClass F G H a b\nf : F\nha : LT.lt 0 a\nl : G\n⊢ Iff (StrictMono ⇑f) (StrictMonoOn (⇑f) (Set.Icc l (HAdd.hAdd l a)))","decl":"theorem strictMono_iff_Icc [LinearOrderedAddCommGroup G] [Archimedean G] [OrderedAddCommGroup H]\n    [AddConstMapClass F G H a b] {f : F} (ha : 0 < a) (l : G) :\n    StrictMono f ↔ StrictMonoOn f (Icc l (l + a)) :=\n  ⟨(StrictMono.strictMonoOn · _), AddConstMapClass.rel_map_of_Icc ha⟩\n\n"}
{"name":"AddConstMapClass.strictAnti_iff_Icc","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"F : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝⁴ : FunLike F G H\na : G\nb : H\ninst✝³ : LinearOrderedAddCommGroup G\ninst✝² : Archimedean G\ninst✝¹ : OrderedAddCommGroup H\ninst✝ : AddConstMapClass F G H a b\nf : F\nha : LT.lt 0 a\nl : G\n⊢ Iff (StrictAnti ⇑f) (StrictAntiOn (⇑f) (Set.Icc l (HAdd.hAdd l a)))","decl":"theorem strictAnti_iff_Icc [LinearOrderedAddCommGroup G] [Archimedean G] [OrderedAddCommGroup H]\n    [AddConstMapClass F G H a b] {f : F} (ha : 0 < a) (l : G) :\n    StrictAnti f ↔ StrictAntiOn f (Icc l (l + a)) :=\n  strictMono_iff_Icc (H := Hᵒᵈ) ha l\n\n"}
{"name":"AddConstMap.coe_mk","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\nf : G → H\nhf : ∀ (x : G), Eq (f (HAdd.hAdd x a)) (HAdd.hAdd (f x) b)\n⊢ Eq (⇑{ toFun := f, map_add_const' := hf }) f","decl":"@[simp, push_cast] theorem coe_mk (f : G → H) (hf) : ⇑(mk f hf : G →+c[a, b] H) = f := rfl\n"}
{"name":"AddConstMap.mk_coe","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\nf : AddConstMap G H a b\n⊢ Eq { toFun := ⇑f, map_add_const' := ⋯ } f","decl":"@[simp] theorem mk_coe (f : G →+c[a, b] H) : mk f f.2 = f := rfl\n"}
{"name":"AddConstMap.toFun_eq_coe","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\nf : AddConstMap G H a b\n⊢ Eq f.toFun ⇑f","decl":"@[simp] theorem toFun_eq_coe (f : G →+c[a, b] H) : f.toFun = f := rfl\n\n"}
{"name":"AddConstMap.instAddConstMapClass","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\n⊢ AddConstMapClass (AddConstMap G H a b) G H a b","decl":"instance : AddConstMapClass (G →+c[a, b] H) G H a b where\n  map_add_const f := f.map_add_const'\n\n"}
{"name":"AddConstMap.ext","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\nf g : AddConstMap G H a b\nh : ∀ (x : G), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext] protected theorem ext {f g : G →+c[a, b] H} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"AddConstMap.ext_iff","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\nf g : AddConstMap G H a b\n⊢ Iff (Eq f g) (∀ (x : G), Eq (f x) (g x))","decl":"@[ext] protected theorem ext {f g : G →+c[a, b] H} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"AddConstMap.coe_id","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\n⊢ Eq (⇑AddConstMap.id) id","decl":"/-- The identity map as `G →+c[a, a] G`. -/\n@[simps (config := .asFn)]\nprotected def id : G →+c[a, a] G := ⟨id, fun _ ↦ rfl⟩\n\n"}
{"name":"AddConstMap.coe_comp","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝² : Add G\ninst✝¹ : Add H\na : G\nb : H\nK : Type u_3\ninst✝ : Add K\nc : K\ng : AddConstMap H K b c\nf : AddConstMap G H a b\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"/-- Composition of two `AddConstMap`s. -/\n@[simps (config := .asFn)]\ndef comp {K : Type*} [Add K] {c : K} (g : H →+c[b, c] K) (f : G →+c[a, b] H) :\n    G →+c[a, c] K :=\n  ⟨g ∘ f, by simp⟩\n\n"}
{"name":"AddConstMap.comp_id","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\nf : AddConstMap G H a b\n⊢ Eq (f.comp AddConstMap.id) f","decl":"@[simp] theorem comp_id (f : G →+c[a, b] H) : f.comp .id = f := rfl\n"}
{"name":"AddConstMap.id_comp","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\nf : AddConstMap G H a b\n⊢ Eq (AddConstMap.id.comp f) f","decl":"@[simp] theorem id_comp (f : G →+c[a, b] H) : .comp .id f = f := rfl\n\n"}
{"name":"AddConstMap.coe_replaceConsts","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\nf : AddConstMap G H a b\na' : G\nb' : H\nha : Eq a a'\nhb : Eq b b'\n⊢ Eq ⇑(f.replaceConsts a' b' ha hb) ⇑f","decl":"/-- Change constants `a` and `b` in `(f : G →+c[a, b] H)` to improve definitional equalities. -/\n@[simps (config := .asFn)]\ndef replaceConsts (f : G →+c[a, b] H) (a' b') (ha : a = a') (hb : b = b') :\n    G →+c[a', b'] H where\n  toFun := f\n  map_add_const' := ha ▸ hb ▸ f.map_add_const'\n\n"}
{"name":"AddConstMap.coe_vadd","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝³ : Add G\ninst✝² : Add H\na : G\nb : H\nK : Type u_3\ninst✝¹ : VAdd K H\ninst✝ : VAddAssocClass K H H\nc : K\nf : AddConstMap G H a b\n⊢ Eq (⇑(HVAdd.hVAdd c f)) (HVAdd.hVAdd c ⇑f)","decl":"@[simp, norm_cast]\ntheorem coe_vadd {K : Type*} [VAdd K H] [VAddAssocClass K H H] (c : K) (f : G →+c[a, b] H) :\n    ⇑(c +ᵥ f) = c +ᵥ ⇑f :=\n  rfl\n\n"}
{"name":"AddConstMap.mul_def","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\nf g : AddConstMap G G a a\n⊢ Eq (HMul.hMul f g) (f.comp g)","decl":"theorem mul_def (f g : G →+c[a, a] G) : f * g = f.comp g := rfl\n"}
{"name":"AddConstMap.coe_mul","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\nf g : AddConstMap G G a a\n⊢ Eq (⇑(HMul.hMul f g)) (Function.comp ⇑f ⇑g)","decl":"@[simp, push_cast] theorem coe_mul (f g : G →+c[a, a] G) : ⇑(f * g) = f ∘ g := rfl\n\n"}
{"name":"AddConstMap.one_def","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\n⊢ Eq 1 AddConstMap.id","decl":"theorem one_def : (1 : G →+c[a, a] G) = .id := rfl\n"}
{"name":"AddConstMap.coe_one","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\n⊢ Eq (⇑1) id","decl":"@[simp, push_cast] theorem coe_one : ⇑(1 : G →+c[a, a] G) = id := rfl\n\n"}
{"name":"AddConstMap.coe_pow","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\nf : AddConstMap G G a a\nn : Nat\n⊢ Eq (⇑(HPow.hPow f n)) (Nat.iterate (⇑f) n)","decl":"@[simp, push_cast] theorem coe_pow (f : G →+c[a, a] G) (n : ℕ) : ⇑(f ^ n) = f^[n] := rfl\n\n"}
{"name":"AddConstMap.pow_apply","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\nf : AddConstMap G G a a\nn : Nat\nx : G\n⊢ Eq ((HPow.hPow f n) x) (Nat.iterate (⇑f) n x)","decl":"theorem pow_apply (f : G →+c[a, a] G) (n : ℕ) (x : G) : (f ^ n) x = f^[n] x := rfl\n\n"}
{"name":"AddConstMap.toEnd_apply","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\n⊢ Eq (⇑AddConstMap.toEnd) DFunLike.coe","decl":"/-- Coercion to functions as a monoid homomorphism to `Function.End G`. -/\n@[simps (config := .asFn)]\ndef toEnd : (G →+c[a, a] G) →* Function.End G where\n  toFun := DFunLike.coe\n  map_mul' _ _ := rfl\n  map_one' := rfl\n\n"}
{"name":"AddConstMap.coe_smul","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\nK : Type u_3\ninst✝² : Add G\ninst✝¹ : AddZeroClass H\na : G\nb : H\ninst✝ : DistribSMul K H\nc : K\nf : AddConstMap G H a b\n⊢ Eq (⇑(AddConstMap.smul c f)) (HSMul.hSMul c ⇑f)","decl":"/-- Pointwise scalar multiplication of `f : G →+c[a, b] H` as a map `G →+c[a, c • b] H`. -/\n@[simps (config := .asFn)]\ndef smul [DistribSMul K H] (c : K) (f : G →+c[a, b] H) : G →+c[a, c • b] H where\n  toFun := c • ⇑f\n  map_add_const' x := by simp [smul_add]\n\n"}
{"name":"AddConstMap.coe_addLeftHom_apply","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\na : G\nc : Multiplicative G\n⊢ Eq (⇑(AddConstMap.addLeftHom c)) (HSMul.hSMul c id)","decl":"/-- The map that sends `c` to a translation by `c`\nas a monoid homomorphism from `Multiplicative G` to `G →+c[a, a] G`. -/\n@[simps! (config := .asFn)]\ndef addLeftHom : Multiplicative G →* (G →+c[a, a] G) where\n  toFun c := c.toAdd +ᵥ .id\n  map_one' := by ext; apply zero_add\n  map_mul' _ _ := by ext; apply add_assoc\n\n"}
{"name":"AddConstMap.coe_conjNeg_apply","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : AddCommGroup H\na : G\nb : H\nf : AddConstMap G H a b\nx : G\n⊢ Eq ((AddConstMap.conjNeg f) x) (Neg.neg (f (Neg.neg x)))","decl":"/-- If `f : G → H` is an `AddConstMap`, then so is `fun x ↦ -f (-x)`. -/\n@[simps! apply_coe]\ndef conjNeg : (G →+c[a, b] H) ≃ (G →+c[a, b] H) :=\n  Involutive.toPerm (fun f ↦ ⟨fun x ↦ - f (-x), fun _ ↦ by simp [neg_add_eq_sub]⟩) fun _ ↦\n    AddConstMap.ext fun _ ↦ by simp\n\n"}
{"name":"AddConstMap.conjNeg_symm","module":"Mathlib.Algebra.AddConstMap.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : AddCommGroup H\na : G\nb : H\n⊢ Eq AddConstMap.conjNeg.symm AddConstMap.conjNeg","decl":"@[simp] theorem conjNeg_symm : (conjNeg (a := a) (b := b)).symm = conjNeg := rfl\n\n"}
