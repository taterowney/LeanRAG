{"name":"GenContFract.squashSeq_eq_self_of_terminated","module":"Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv","initialProofState":"K : Type u_1\nn : Nat\ns : Stream'.Seq (GenContFract.Pair K)\ninst✝ : DivisionRing K\nterminatedAt_succ_n : s.TerminatedAt (HAdd.hAdd n 1)\n⊢ Eq (GenContFract.squashSeq s n) s","decl":"/-- If the sequence already terminated at position `n + 1`, nothing gets squashed. -/\ntheorem squashSeq_eq_self_of_terminated (terminatedAt_succ_n : s.TerminatedAt (n + 1)) :\n    squashSeq s n = s := by\n  change s.get? (n + 1) = none at terminatedAt_succ_n\n  cases s_nth_eq : s.get? n <;> simp only [*, squashSeq]\n\n"}
{"name":"GenContFract.squashSeq_nth_of_not_terminated","module":"Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv","initialProofState":"K : Type u_1\nn : Nat\ns : Stream'.Seq (GenContFract.Pair K)\ninst✝ : DivisionRing K\ngp_n gp_succ_n : GenContFract.Pair K\ns_nth_eq : Eq (s.get? n) (Option.some gp_n)\ns_succ_nth_eq : Eq (s.get? (HAdd.hAdd n 1)) (Option.some gp_succ_n)\n⊢ Eq ((GenContFract.squashSeq s n).get? n) (Option.some { a := gp_n.a, b := HAdd.hAdd gp_n.b (HDiv.hDiv gp_succ_n.a gp_succ_n.b) })","decl":"/-- If the sequence has not terminated before position `n + 1`, the value at `n + 1` gets\nsquashed into position `n`. -/\ntheorem squashSeq_nth_of_not_terminated {gp_n gp_succ_n : Pair K} (s_nth_eq : s.get? n = some gp_n)\n    (s_succ_nth_eq : s.get? (n + 1) = some gp_succ_n) :\n    (squashSeq s n).get? n = some ⟨gp_n.a, gp_n.b + gp_succ_n.a / gp_succ_n.b⟩ := by\n  simp [*, squashSeq]\n\n"}
{"name":"GenContFract.squashSeq_nth_of_lt","module":"Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv","initialProofState":"K : Type u_1\nn : Nat\ns : Stream'.Seq (GenContFract.Pair K)\ninst✝ : DivisionRing K\nm : Nat\nm_lt_n : LT.lt m n\n⊢ Eq ((GenContFract.squashSeq s n).get? m) (s.get? m)","decl":"/-- The values before the squashed position stay the same. -/\ntheorem squashSeq_nth_of_lt {m : ℕ} (m_lt_n : m < n) : (squashSeq s n).get? m = s.get? m := by\n  cases s_succ_nth_eq : s.get? (n + 1) with\n  | none => rw [squashSeq_eq_self_of_terminated s_succ_nth_eq]\n  | some =>\n    obtain ⟨gp_n, s_nth_eq⟩ : ∃ gp_n, s.get? n = some gp_n :=\n      s.ge_stable n.le_succ s_succ_nth_eq\n    obtain ⟨gp_m, s_mth_eq⟩ : ∃ gp_m, s.get? m = some gp_m :=\n      s.ge_stable (le_of_lt m_lt_n) s_nth_eq\n    simp [*, squashSeq, m_lt_n.ne]\n\n"}
{"name":"GenContFract.squashSeq_succ_n_tail_eq_squashSeq_tail_n","module":"Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv","initialProofState":"K : Type u_1\nn : Nat\ns : Stream'.Seq (GenContFract.Pair K)\ninst✝ : DivisionRing K\n⊢ Eq (GenContFract.squashSeq s (HAdd.hAdd n 1)).tail (GenContFract.squashSeq s.tail n)","decl":"/-- Squashing at position `n + 1` and taking the tail is the same as squashing the tail of the\nsequence at position `n`. -/\ntheorem squashSeq_succ_n_tail_eq_squashSeq_tail_n :\n    (squashSeq s (n + 1)).tail = squashSeq s.tail n := by\n  cases s_succ_succ_nth_eq : s.get? (n + 2) with\n  | none =>\n    cases s_succ_nth_eq : s.get? (n + 1) <;>\n      simp only [squashSeq, Stream'.Seq.get?_tail, s_succ_nth_eq, s_succ_succ_nth_eq]\n  | some gp_succ_succ_n =>\n    obtain ⟨gp_succ_n, s_succ_nth_eq⟩ : ∃ gp_succ_n, s.get? (n + 1) = some gp_succ_n :=\n      s.ge_stable (n + 1).le_succ s_succ_succ_nth_eq\n    -- apply extensionality with `m` and continue by cases `m = n`.\n    ext1 m\n    rcases Decidable.em (m = n) with m_eq_n | m_ne_n\n    · simp [*, squashSeq]\n    · cases s_succ_mth_eq : s.get? (m + 1)\n      · simp only [*, squashSeq, Stream'.Seq.get?_tail, Stream'.Seq.get?_zipWith,\n          Option.map₂_none_right]\n      · simp [*, squashSeq]\n\n"}
{"name":"GenContFract.succ_succ_nth_conv'Aux_eq_succ_nth_conv'Aux_squashSeq","module":"Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv","initialProofState":"K : Type u_1\nn : Nat\ns : Stream'.Seq (GenContFract.Pair K)\ninst✝ : DivisionRing K\n⊢ Eq (GenContFract.convs'Aux s (HAdd.hAdd n 2)) (GenContFract.convs'Aux (GenContFract.squashSeq s n) (HAdd.hAdd n 1))","decl":"/-- The auxiliary function `convs'Aux` returns the same value for a sequence and the\ncorresponding squashed sequence at the squashed position. -/\ntheorem succ_succ_nth_conv'Aux_eq_succ_nth_conv'Aux_squashSeq :\n    convs'Aux s (n + 2) = convs'Aux (squashSeq s n) (n + 1) := by\n  cases s_succ_nth_eq : s.get? <| n + 1 with\n  | none =>\n    rw [squashSeq_eq_self_of_terminated s_succ_nth_eq,\n      convs'Aux_stable_step_of_terminated s_succ_nth_eq]\n  | some gp_succ_n =>\n    induction n generalizing s gp_succ_n with\n    | zero =>\n      obtain ⟨gp_head, s_head_eq⟩ : ∃ gp_head, s.head = some gp_head :=\n        s.ge_stable zero_le_one s_succ_nth_eq\n      have : (squashSeq s 0).head = some ⟨gp_head.a, gp_head.b + gp_succ_n.a / gp_succ_n.b⟩ :=\n        squashSeq_nth_of_not_terminated s_head_eq s_succ_nth_eq\n      simp_all [convs'Aux, Stream'.Seq.head, Stream'.Seq.get?_tail]\n    | succ m IH =>\n      obtain ⟨gp_head, s_head_eq⟩ : ∃ gp_head, s.head = some gp_head :=\n        s.ge_stable (m + 2).zero_le s_succ_nth_eq\n      suffices\n        gp_head.a / (gp_head.b + convs'Aux s.tail (m + 2)) =\n          convs'Aux (squashSeq s (m + 1)) (m + 2)\n        by simpa only [convs'Aux, s_head_eq]\n      have : (squashSeq s (m + 1)).head = some gp_head :=\n        (squashSeq_nth_of_lt m.succ_pos).trans s_head_eq\n      simp_all [convs'Aux, squashSeq_succ_n_tail_eq_squashSeq_tail_n]\n\n"}
{"name":"GenContFract.squashGCF_eq_self_of_terminated","module":"Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv","initialProofState":"K : Type u_1\nn : Nat\ng : GenContFract K\ninst✝ : DivisionRing K\nterminatedAt_n : g.TerminatedAt n\n⊢ Eq (g.squashGCF n) g","decl":"/-- If the gcf already terminated at position `n`, nothing gets squashed. -/\ntheorem squashGCF_eq_self_of_terminated (terminatedAt_n : TerminatedAt g n) :\n    squashGCF g n = g := by\n  cases n with\n  | zero =>\n    change g.s.get? 0 = none at terminatedAt_n\n    simp only [convs', squashGCF, convs'Aux, terminatedAt_n]\n  | succ =>\n    cases g\n    simp only [squashGCF, mk.injEq, true_and]\n    exact squashSeq_eq_self_of_terminated terminatedAt_n\n\n"}
{"name":"GenContFract.squashGCF_nth_of_lt","module":"Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv","initialProofState":"K : Type u_1\nn : Nat\ng : GenContFract K\ninst✝ : DivisionRing K\nm : Nat\nm_lt_n : LT.lt m n\n⊢ Eq ((g.squashGCF (HAdd.hAdd n 1)).s.get? m) (g.s.get? m)","decl":"/-- The values before the squashed position stay the same. -/\ntheorem squashGCF_nth_of_lt {m : ℕ} (m_lt_n : m < n) :\n    (squashGCF g (n + 1)).s.get? m = g.s.get? m := by\n  simp only [squashGCF, squashSeq_nth_of_lt m_lt_n, Nat.add_eq, add_zero]\n\n"}
{"name":"GenContFract.succ_nth_conv'_eq_squashGCF_nth_conv'","module":"Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv","initialProofState":"K : Type u_1\nn : Nat\ng : GenContFract K\ninst✝ : DivisionRing K\n⊢ Eq (g.convs' (HAdd.hAdd n 1)) ((g.squashGCF n).convs' n)","decl":"/-- `convs'` returns the same value for a gcf and the corresponding squashed gcf at the\nsquashed position. -/\ntheorem succ_nth_conv'_eq_squashGCF_nth_conv' :\n    g.convs' (n + 1) = (squashGCF g n).convs' n := by\n  cases n with\n  | zero =>\n    cases g_s_head_eq : g.s.get? 0 <;>\n      simp [g_s_head_eq, squashGCF, convs', convs'Aux, Stream'.Seq.head]\n  | succ =>\n    simp only [succ_succ_nth_conv'Aux_eq_succ_nth_conv'Aux_squashSeq, convs',\n      squashGCF]\n\n"}
{"name":"GenContFract.contsAux_eq_contsAux_squashGCF_of_le","module":"Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv","initialProofState":"K : Type u_1\nn : Nat\ng : GenContFract K\ninst✝ : DivisionRing K\nm : Nat\na✝ : LE.le m n\n⊢ Eq (g.contsAux m) ((g.squashGCF n).contsAux m)","decl":"/-- The auxiliary continuants before the squashed position stay the same. -/\ntheorem contsAux_eq_contsAux_squashGCF_of_le {m : ℕ} :\n    m ≤ n → contsAux g m = (squashGCF g n).contsAux m :=\n  Nat.strong_induction_on m\n    (by\n      clear m\n      intro m IH m_le_n\n      rcases m with - | m'\n      · rfl\n      · rcases n with - | n'\n        · exact (m'.not_succ_le_zero m_le_n).elim\n        -- 1 ≰ 0\n        · rcases m' with - | m''\n          · rfl\n          · -- get some inequalities to instantiate the IH for m'' and m'' + 1\n            have m'_lt_n : m'' + 1 < n' + 1 := m_le_n\n            have succ_m''th_contsAux_eq := IH (m'' + 1) (lt_add_one (m'' + 1)) m'_lt_n.le\n            have : m'' < m'' + 2 := lt_add_of_pos_right m'' zero_lt_two\n            have m''th_contsAux_eq := IH m'' this (le_trans this.le m_le_n)\n            have : (squashGCF g (n' + 1)).s.get? m'' = g.s.get? m'' :=\n              squashGCF_nth_of_lt (Nat.succ_lt_succ_iff.mp m'_lt_n)\n            simp [contsAux, succ_m''th_contsAux_eq, m''th_contsAux_eq, this])\n\n"}
{"name":"GenContFract.succ_nth_conv_eq_squashGCF_nth_conv","module":"Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv","initialProofState":"K : Type u_1\nn : Nat\ng : GenContFract K\ninst✝ : Field K\nnth_partDen_ne_zero : ∀ {b : K}, Eq (g.partDens.get? n) (Option.some b) → Ne b 0\n⊢ Eq (g.convs (HAdd.hAdd n 1)) ((g.squashGCF n).convs n)","decl":"/-- The convergents coincide in the expected way at the squashed position if the partial denominator\nat the squashed position is not zero. -/\ntheorem succ_nth_conv_eq_squashGCF_nth_conv [Field K]\n    (nth_partDen_ne_zero : ∀ {b : K}, g.partDens.get? n = some b → b ≠ 0) :\n    g.convs (n + 1) = (squashGCF g n).convs n := by\n  rcases Decidable.em (g.TerminatedAt n) with terminatedAt_n | not_terminatedAt_n\n  · have : squashGCF g n = g := squashGCF_eq_self_of_terminated terminatedAt_n\n    simp only [this, convs_stable_of_terminated n.le_succ terminatedAt_n]\n  · obtain ⟨⟨a, b⟩, s_nth_eq⟩ : ∃ gp_n, g.s.get? n = some gp_n :=\n      Option.ne_none_iff_exists'.mp not_terminatedAt_n\n    have b_ne_zero : b ≠ 0 := nth_partDen_ne_zero (partDen_eq_s_b s_nth_eq)\n    cases n with\n    | zero =>\n      suffices (b * g.h + a) / b = g.h + a / b by\n        simpa [squashGCF, s_nth_eq, conv_eq_conts_a_div_conts_b,\n          conts_recurrenceAux s_nth_eq zeroth_contAux_eq_one_zero first_contAux_eq_h_one]\n      calc\n        (b * g.h + a) / b = b * g.h / b + a / b := by ring\n        -- requires `Field`, not `DivisionRing`\n        _ = g.h + a / b := by rw [mul_div_cancel_left₀ _ b_ne_zero]\n    | succ n' =>\n      obtain ⟨⟨pa, pb⟩, s_n'th_eq⟩ : ∃ gp_n', g.s.get? n' = some gp_n' :=\n        g.s.ge_stable n'.le_succ s_nth_eq\n      -- Notations\n      let g' := squashGCF g (n' + 1)\n      set pred_conts := g.contsAux (n' + 1) with succ_n'th_contsAux_eq\n      set ppred_conts := g.contsAux n' with n'th_contsAux_eq\n      let pA := pred_conts.a\n      let pB := pred_conts.b\n      let ppA := ppred_conts.a\n      let ppB := ppred_conts.b\n      set pred_conts' := g'.contsAux (n' + 1) with succ_n'th_contsAux_eq'\n      set ppred_conts' := g'.contsAux n' with n'th_contsAux_eq'\n      let pA' := pred_conts'.a\n      let pB' := pred_conts'.b\n      let ppA' := ppred_conts'.a\n      let ppB' := ppred_conts'.b\n      -- first compute the convergent of the squashed gcf\n      have : g'.convs (n' + 1) =\n          ((pb + a / b) * pA' + pa * ppA') / ((pb + a / b) * pB' + pa * ppB') := by\n        have : g'.s.get? n' = some ⟨pa, pb + a / b⟩ :=\n          squashSeq_nth_of_not_terminated s_n'th_eq s_nth_eq\n        rw [conv_eq_conts_a_div_conts_b,\n          conts_recurrenceAux this n'th_contsAux_eq'.symm succ_n'th_contsAux_eq'.symm]\n      rw [this]\n      -- then compute the convergent of the original gcf by recursively unfolding the continuants\n      -- computation twice\n      have : g.convs (n' + 2) =\n          (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB) := by\n        -- use the recurrence once\n        have : g.contsAux (n' + 2) = ⟨pb * pA + pa * ppA, pb * pB + pa * ppB⟩ :=\n          contsAux_recurrence s_n'th_eq n'th_contsAux_eq.symm succ_n'th_contsAux_eq.symm\n        -- and a second time\n        rw [conv_eq_conts_a_div_conts_b,\n          conts_recurrenceAux s_nth_eq succ_n'th_contsAux_eq.symm this]\n      rw [this]\n      suffices\n        ((pb + a / b) * pA + pa * ppA) / ((pb + a / b) * pB + pa * ppB) =\n          (b * (pb * pA + pa * ppA) + a * pA) / (b * (pb * pB + pa * ppB) + a * pB) by\n        obtain ⟨eq1, eq2, eq3, eq4⟩ : pA' = pA ∧ pB' = pB ∧ ppA' = ppA ∧ ppB' = ppB := by\n          simp [*, g', pA, pB, ppA, ppB, pA', pB', ppA', ppB',\n            (contsAux_eq_contsAux_squashGCF_of_le <| le_refl <| n' + 1).symm,\n            (contsAux_eq_contsAux_squashGCF_of_le n'.le_succ).symm]\n        symm\n        simpa only [eq1, eq2, eq3, eq4, mul_div_cancel_right₀ _ b_ne_zero]\n      field_simp\n      congr 1 <;> ring\n\n"}
{"name":"GenContFract.convs_eq_convs'","module":"Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv","initialProofState":"K : Type u_1\nn : Nat\ng : GenContFract K\ninst✝ : LinearOrderedField K\ns_pos : ∀ {gp : GenContFract.Pair K} {m : Nat}, LT.lt m n → Eq (g.s.get? m) (Option.some gp) → And (LT.lt 0 gp.a) (LT.lt 0 gp.b)\n⊢ Eq (g.convs n) (g.convs' n)","decl":"/-- Shows that the recurrence relation (`convs`) and direct evaluation (`convs'`) of the\ngeneralized continued fraction coincide at position `n` if the sequence of fractions contains\nstrictly positive values only.\nRequiring positivity of all values is just one possible condition to obtain this result.\nFor example, the dual - sequences with strictly negative values only - would also work.\n\nIn practice, one most commonly deals with regular continued fractions, which satisfy the\npositivity criterion required here. The analogous result for them\n(see `ContFract.convs_eq_convs`) hence follows directly from this theorem.\n-/\ntheorem convs_eq_convs' [LinearOrderedField K]\n    (s_pos : ∀ {gp : Pair K} {m : ℕ}, m < n → g.s.get? m = some gp → 0 < gp.a ∧ 0 < gp.b) :\n    g.convs n = g.convs' n := by\n  induction n generalizing g with\n  | zero => simp\n  | succ n IH =>\n    let g' := squashGCF g n\n    -- first replace the rhs with the squashed computation\n    suffices g.convs (n + 1) = g'.convs' n by\n      rwa [succ_nth_conv'_eq_squashGCF_nth_conv']\n    rcases Decidable.em (TerminatedAt g n) with terminatedAt_n | not_terminatedAt_n\n    · have g'_eq_g : g' = g := squashGCF_eq_self_of_terminated terminatedAt_n\n      rw [convs_stable_of_terminated n.le_succ terminatedAt_n, g'_eq_g, IH _]\n      intro _ _ m_lt_n s_mth_eq\n      exact s_pos (Nat.lt.step m_lt_n) s_mth_eq\n    · suffices g.convs (n + 1) = g'.convs n by\n        -- invoke the IH for the squashed gcf\n        rwa [← IH]\n        intro gp' m m_lt_n s_mth_eq'\n        -- case distinction on m + 1 = n or m + 1 < n\n        rcases m_lt_n with n | succ_m_lt_n\n        · -- the difficult case at the squashed position: we first obtain the values from\n          -- the sequence\n          obtain ⟨gp_succ_m, s_succ_mth_eq⟩ : ∃ gp_succ_m, g.s.get? (m + 1) = some gp_succ_m :=\n            Option.ne_none_iff_exists'.mp not_terminatedAt_n\n          obtain ⟨gp_m, mth_s_eq⟩ : ∃ gp_m, g.s.get? m = some gp_m :=\n            g.s.ge_stable m.le_succ s_succ_mth_eq\n          -- we then plug them into the recurrence\n          suffices 0 < gp_m.a ∧ 0 < gp_m.b + gp_succ_m.a / gp_succ_m.b by\n            have ot : g'.s.get? m = some ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩ :=\n              squashSeq_nth_of_not_terminated mth_s_eq s_succ_mth_eq\n            have : gp' = ⟨gp_m.a, gp_m.b + gp_succ_m.a / gp_succ_m.b⟩ := by\n              simp_all only [Option.some.injEq]\n            rwa [this]\n          have m_lt_n : m < m.succ := Nat.lt_succ_self m\n          refine ⟨(s_pos (Nat.lt.step m_lt_n) mth_s_eq).left, ?_⟩\n          refine add_pos (s_pos (Nat.lt.step m_lt_n) mth_s_eq).right ?_\n          have : 0 < gp_succ_m.a ∧ 0 < gp_succ_m.b := s_pos (lt_add_one <| m + 1) s_succ_mth_eq\n          exact div_pos this.left this.right\n        · -- the easy case: before the squashed position, nothing changes\n          refine s_pos (Nat.lt.step <| Nat.lt.step succ_m_lt_n) ?_\n          exact Eq.trans (squashGCF_nth_of_lt succ_m_lt_n).symm s_mth_eq'\n      -- now the result follows from the fact that the convergents coincide at the squashed position\n      -- as established in `succ_nth_conv_eq_squashGCF_nth_conv`.\n      have : ∀ ⦃b⦄, g.partDens.get? n = some b → b ≠ 0 := by\n        intro b nth_partDen_eq\n        obtain ⟨gp, s_nth_eq, ⟨refl⟩⟩ : ∃ gp, g.s.get? n = some gp ∧ gp.b = b :=\n          exists_s_b_of_partDen nth_partDen_eq\n        exact (ne_of_lt (s_pos (lt_add_one n) s_nth_eq).right).symm\n      exact succ_nth_conv_eq_squashGCF_nth_conv @this\n\n"}
{"name":"ContFract.convs_eq_convs'","module":"Mathlib.Algebra.ContinuedFractions.ConvergentsEquiv","initialProofState":"K : Type u_1\ninst✝ : LinearOrderedField K\nc : ContFract K\n⊢ Eq (↑↑c).convs (↑↑c).convs'","decl":"/-- Shows that the recurrence relation (`convs`) and direct evaluation (`convs'`) of a\n(regular) continued fraction coincide. -/\nnonrec theorem convs_eq_convs' [LinearOrderedField K] {c : ContFract K} :\n    (↑c : GenContFract K).convs = (↑c : GenContFract K).convs' := by\n  ext n\n  apply convs_eq_convs'\n  intro gp m _ s_nth_eq\n  exact ⟨zero_lt_one.trans_le ((c : SimpContFract K).property m gp.a\n    (partNum_eq_s_a s_nth_eq)).symm.le, c.property m gp.b <| partDen_eq_s_b s_nth_eq⟩\n\n"}
