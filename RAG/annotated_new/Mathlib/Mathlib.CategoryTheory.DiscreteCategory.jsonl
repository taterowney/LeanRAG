{"name":"CategoryTheory.Discrete.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\ninst‚úù : SizeOf Œ±\nas : Œ±\n‚ä¢ Eq (SizeOf.sizeOf { as := as }) (HAdd.hAdd 1 (SizeOf.sizeOf as))","decl":"/-- A wrapper for promoting any type to a category,\nwith the only morphisms being equalities.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Discrete (Œ± : Type u‚ÇÅ) where\n  /-- A wrapper for promoting any type to a category,\n  with the only morphisms being equalities. -/\n  as : Œ±\n\n"}
{"name":"CategoryTheory.Discrete.ext","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\nx y : CategoryTheory.Discrete Œ±\nas : Eq x.as y.as\n‚ä¢ Eq x y","decl":"/-- A wrapper for promoting any type to a category,\nwith the only morphisms being equalities.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Discrete (Œ± : Type u‚ÇÅ) where\n  /-- A wrapper for promoting any type to a category,\n  with the only morphisms being equalities. -/\n  as : Œ±\n\n"}
{"name":"CategoryTheory.Discrete.mk.injEq","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\nas‚úù as : Œ±\n‚ä¢ Eq (Eq { as := as‚úù } { as := as }) (Eq as‚úù as)","decl":"/-- A wrapper for promoting any type to a category,\nwith the only morphisms being equalities.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Discrete (Œ± : Type u‚ÇÅ) where\n  /-- A wrapper for promoting any type to a category,\n  with the only morphisms being equalities. -/\n  as : Œ±\n\n"}
{"name":"CategoryTheory.Discrete.mk.inj","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\nas‚úù as : Œ±\nx‚úù : Eq { as := as‚úù } { as := as }\n‚ä¢ Eq as‚úù as","decl":"/-- A wrapper for promoting any type to a category,\nwith the only morphisms being equalities.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Discrete (Œ± : Type u‚ÇÅ) where\n  /-- A wrapper for promoting any type to a category,\n  with the only morphisms being equalities. -/\n  as : Œ±\n\n"}
{"name":"CategoryTheory.Discrete.ext_iff","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\nx y : CategoryTheory.Discrete Œ±\n‚ä¢ Iff (Eq x y) (Eq x.as y.as)","decl":"/-- A wrapper for promoting any type to a category,\nwith the only morphisms being equalities.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Discrete (Œ± : Type u‚ÇÅ) where\n  /-- A wrapper for promoting any type to a category,\n  with the only morphisms being equalities. -/\n  as : Œ±\n\n"}
{"name":"CategoryTheory.Discrete.mk_as","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\nX : CategoryTheory.Discrete Œ±\n‚ä¢ Eq { as := X.as } X","decl":"@[simp]\ntheorem Discrete.mk_as {Œ± : Type u‚ÇÅ} (X : Discrete Œ±) : Discrete.mk X.as = X := by\n  rfl\n\n"}
{"name":"CategoryTheory.discreteEquiv_symm_apply_as","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\nas : Œ±\n‚ä¢ Eq (CategoryTheory.discreteEquiv.symm as).as as","decl":"/-- `Discrete Œ±` is equivalent to the original type `Œ±`. -/\n@[simps]\ndef discreteEquiv {Œ± : Type u‚ÇÅ} : Discrete Œ± ‚âÉ Œ± where\n  toFun := Discrete.as\n  invFun := Discrete.mk\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.discreteEquiv_apply","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\nself : CategoryTheory.Discrete Œ±\n‚ä¢ Eq (CategoryTheory.discreteEquiv self) self.as","decl":"/-- `Discrete Œ±` is equivalent to the original type `Œ±`. -/\n@[simps]\ndef discreteEquiv {Œ± : Type u‚ÇÅ} : Discrete Œ± ‚âÉ Œ± where\n  toFun := Discrete.as\n  invFun := Discrete.mk\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Discrete.instSubsingleton","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\ninst‚úù : Subsingleton Œ±\n‚ä¢ Subsingleton (CategoryTheory.Discrete Œ±)","decl":"instance [Subsingleton Œ±] : Subsingleton (Discrete Œ±) :=\n  ‚ü®by aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Discrete.instSubsingletonDiscreteHom","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\nX Y : CategoryTheory.Discrete Œ±\n‚ä¢ Subsingleton (Quiver.Hom X Y)","decl":"instance instSubsingletonDiscreteHom (X Y : Discrete Œ±) : Subsingleton (X ‚ü∂ Y) :=\n  show Subsingleton (ULift (PLift _)) from inferInstance\n\n/- Porting note: rewrote `discrete_cases` tactic -/\n"}
{"name":"CategoryTheory.Discrete.eq_of_hom","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\nX Y : CategoryTheory.Discrete Œ±\ni : Quiver.Hom X Y\n‚ä¢ Eq X.as Y.as","decl":"/-- Extract the equation from a morphism in a discrete category. -/\ntheorem eq_of_hom {X Y : Discrete Œ±} (i : X ‚ü∂ Y) : X.as = Y.as :=\n  i.down.down\n\n"}
{"name":"CategoryTheory.Discrete.id_def","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\nX : CategoryTheory.Discrete Œ±\n‚ä¢ Eq { down := { down := ‚ãØ } } (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem id_def (X : Discrete Œ±) : ULift.up (PLift.up (Eq.refl X.as)) = ùüô X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Discrete.instIsIso","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"I : Type u‚ÇÅ\ni j : CategoryTheory.Discrete I\nf : Quiver.Hom i j\n‚ä¢ CategoryTheory.IsIso f","decl":"instance {I : Type u‚ÇÅ} {i j : Discrete I} (f : i ‚ü∂ j) : IsIso f :=\n  ‚ü®‚ü®Discrete.eqToHom (eq_of_hom f).symm, by aesop_cat‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Discrete.functor_obj","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nI : Type u‚ÇÅ\nF : I ‚Üí C\ni : I\n‚ä¢ Eq ((CategoryTheory.Discrete.functor F).obj { as := i }) (F i)","decl":"@[simp]\ntheorem functor_obj {I : Type u‚ÇÅ} (F : I ‚Üí C) (i : I) :\n    (Discrete.functor F).obj (Discrete.mk i) = F i :=\n  rfl\n\n"}
{"name":"CategoryTheory.Discrete.functor_map","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nI : Type u‚ÇÅ\nF : I ‚Üí C\ni : CategoryTheory.Discrete I\nf : Quiver.Hom i i\n‚ä¢ Eq ((CategoryTheory.Discrete.functor F).map f) (CategoryTheory.CategoryStruct.id (F i.as))","decl":"@[simp]\ntheorem functor_map {I : Type u‚ÇÅ} (F : I ‚Üí C) {i : Discrete I} (f : i ‚ü∂ i) :\n    (Discrete.functor F).map f = ùüô (F i.as) := by aesop_cat\n"}
{"name":"CategoryTheory.Discrete.functor_obj_eq_as","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nI : Type u‚ÇÅ\nF : I ‚Üí C\nX : CategoryTheory.Discrete I\n‚ä¢ Eq ((CategoryTheory.Discrete.functor F).obj X) (F X.as)","decl":"@[simp]\ntheorem functor_obj_eq_as {I : Type u‚ÇÅ} (F : I ‚Üí C) (X : Discrete I) :\n    (Discrete.functor F).obj X = F X.as :=\n  rfl\n"}
{"name":"CategoryTheory.Discrete.functorComp_inv_app","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nI : Type u‚ÇÅ\nJ : Type u‚ÇÅ'\nf : J ‚Üí C\ng : I ‚Üí J\nX : CategoryTheory.Discrete I\n‚ä¢ Eq ((CategoryTheory.Discrete.functorComp f g).inv.app X) (CategoryTheory.CategoryStruct.id (f (g X.as)))","decl":"/-- The discrete functor induced by a composition of maps can be written as a\ncomposition of two discrete functors.\n-/\n@[simps!]\ndef functorComp {I : Type u‚ÇÅ} {J : Type u‚ÇÅ'} (f : J ‚Üí C) (g : I ‚Üí J) :\n    Discrete.functor (f ‚àò g) ‚âÖ Discrete.functor (Discrete.mk ‚àò g) ‚ãô Discrete.functor f :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Discrete.functorComp_hom_app","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nI : Type u‚ÇÅ\nJ : Type u‚ÇÅ'\nf : J ‚Üí C\ng : I ‚Üí J\nX : CategoryTheory.Discrete I\n‚ä¢ Eq ((CategoryTheory.Discrete.functorComp f g).hom.app X) (CategoryTheory.CategoryStruct.id (f (g X.as)))","decl":"/-- The discrete functor induced by a composition of maps can be written as a\ncomposition of two discrete functors.\n-/\n@[simps!]\ndef functorComp {I : Type u‚ÇÅ} {J : Type u‚ÇÅ'} (f : J ‚Üí C) (g : I ‚Üí J) :\n    Discrete.functor (f ‚àò g) ‚âÖ Discrete.functor (Discrete.mk ‚àò g) ‚ãô Discrete.functor f :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Discrete.natTrans_app","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nI : Type u‚ÇÅ\nF G : CategoryTheory.Functor (CategoryTheory.Discrete I) C\nf : (i : CategoryTheory.Discrete I) ‚Üí Quiver.Hom (F.obj i) (G.obj i)\ni : CategoryTheory.Discrete I\n‚ä¢ Eq ((CategoryTheory.Discrete.natTrans f).app i) (f i)","decl":"/-- For functors out of a discrete category,\na natural transformation is just a collection of maps,\nas the naturality squares are trivial.\n-/\n@[simps]\ndef natTrans {I : Type u‚ÇÅ} {F G : Discrete I ‚•§ C} (f : ‚àÄ i : Discrete I, F.obj i ‚ü∂ G.obj i) :\n    F ‚ü∂ G where\n  app := f\n  naturality := fun {X Y} ‚ü®‚ü®g‚ü©‚ü© => by\n    discrete_cases\n    rcases g\n    change F.map (ùüô _) ‚â´ _ = _ ‚â´ G.map (ùüô _)\n    simp\n\n"}
{"name":"CategoryTheory.Discrete.natIso_inv_app","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nI : Type u‚ÇÅ\nF G : CategoryTheory.Functor (CategoryTheory.Discrete I) C\nf : (i : CategoryTheory.Discrete I) ‚Üí CategoryTheory.Iso (F.obj i) (G.obj i)\nX : CategoryTheory.Discrete I\n‚ä¢ Eq ((CategoryTheory.Discrete.natIso f).inv.app X) (f X).inv","decl":"/-- For functors out of a discrete category,\na natural isomorphism is just a collection of isomorphisms,\nas the naturality squares are trivial.\n-/\n@[simps!]\ndef natIso {I : Type u‚ÇÅ} {F G : Discrete I ‚•§ C} (f : ‚àÄ i : Discrete I, F.obj i ‚âÖ G.obj i) :\n    F ‚âÖ G :=\n  NatIso.ofComponents f fun ‚ü®‚ü®g‚ü©‚ü© => by\n    discrete_cases\n    rcases g\n    change F.map (ùüô _) ‚â´ _ = _ ‚â´ G.map (ùüô _)\n    simp\n\n"}
{"name":"CategoryTheory.Discrete.natIso_hom_app","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nI : Type u‚ÇÅ\nF G : CategoryTheory.Functor (CategoryTheory.Discrete I) C\nf : (i : CategoryTheory.Discrete I) ‚Üí CategoryTheory.Iso (F.obj i) (G.obj i)\nX : CategoryTheory.Discrete I\n‚ä¢ Eq ((CategoryTheory.Discrete.natIso f).hom.app X) (f X).hom","decl":"/-- For functors out of a discrete category,\na natural isomorphism is just a collection of isomorphisms,\nas the naturality squares are trivial.\n-/\n@[simps!]\ndef natIso {I : Type u‚ÇÅ} {F G : Discrete I ‚•§ C} (f : ‚àÄ i : Discrete I, F.obj i ‚âÖ G.obj i) :\n    F ‚âÖ G :=\n  NatIso.ofComponents f fun ‚ü®‚ü®g‚ü©‚ü© => by\n    discrete_cases\n    rcases g\n    change F.map (ùüô _) ‚â´ _ = _ ‚â´ G.map (ùüô _)\n    simp\n\n"}
{"name":"CategoryTheory.Discrete.instIsIsoFunctorNatTrans","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nI : Type u_1\nF G : CategoryTheory.Functor (CategoryTheory.Discrete I) C\nf : (i : CategoryTheory.Discrete I) ‚Üí Quiver.Hom (F.obj i) (G.obj i)\ninst‚úù : ‚àÄ (i : CategoryTheory.Discrete I), CategoryTheory.IsIso (f i)\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Discrete.natTrans f)","decl":"instance {I : Type*} {F G : Discrete I ‚•§ C} (f : ‚àÄ i, F.obj i ‚ü∂ G.obj i) [‚àÄ i, IsIso (f i)] :\n    IsIso (Discrete.natTrans f) := by\n  change IsIso (Discrete.natIso (fun i => asIso (f i))).hom\n  infer_instance\n\n"}
{"name":"CategoryTheory.Discrete.natIso_app","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nI : Type u‚ÇÅ\nF G : CategoryTheory.Functor (CategoryTheory.Discrete I) C\nf : (i : CategoryTheory.Discrete I) ‚Üí CategoryTheory.Iso (F.obj i) (G.obj i)\ni : CategoryTheory.Discrete I\n‚ä¢ Eq ((CategoryTheory.Discrete.natIso f).app i) (f i)","decl":"@[simp]\ntheorem natIso_app {I : Type u‚ÇÅ} {F G : Discrete I ‚•§ C} (f : ‚àÄ i : Discrete I, F.obj i ‚âÖ G.obj i)\n    (i : Discrete I) : (Discrete.natIso f).app i = f i := by aesop_cat\n\n"}
{"name":"CategoryTheory.Discrete.equivalence_counitIso","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"I : Type u‚ÇÅ\nJ : Type u‚ÇÇ\ne : Equiv I J\n‚ä¢ Eq (CategoryTheory.Discrete.equivalence e).counitIso (CategoryTheory.Discrete.natIso fun j => CategoryTheory.eqToIso ‚ãØ)","decl":"/-- We can promote a type-level `Equiv` to\nan equivalence between the corresponding `discrete` categories.\n-/\n@[simps]\ndef equivalence {I : Type u‚ÇÅ} {J : Type u‚ÇÇ} (e : I ‚âÉ J) : Discrete I ‚âå Discrete J where\n  functor := Discrete.functor (Discrete.mk ‚àò (e : I ‚Üí J))\n  inverse := Discrete.functor (Discrete.mk ‚àò (e.symm : J ‚Üí I))\n  unitIso :=\n    Discrete.natIso fun i => eqToIso (by simp)\n  counitIso :=\n    Discrete.natIso fun j => eqToIso (by simp)\n\n"}
{"name":"CategoryTheory.Discrete.equivalence_unitIso","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"I : Type u‚ÇÅ\nJ : Type u‚ÇÇ\ne : Equiv I J\n‚ä¢ Eq (CategoryTheory.Discrete.equivalence e).unitIso (CategoryTheory.Discrete.natIso fun i => CategoryTheory.eqToIso ‚ãØ)","decl":"/-- We can promote a type-level `Equiv` to\nan equivalence between the corresponding `discrete` categories.\n-/\n@[simps]\ndef equivalence {I : Type u‚ÇÅ} {J : Type u‚ÇÇ} (e : I ‚âÉ J) : Discrete I ‚âå Discrete J where\n  functor := Discrete.functor (Discrete.mk ‚àò (e : I ‚Üí J))\n  inverse := Discrete.functor (Discrete.mk ‚àò (e.symm : J ‚Üí I))\n  unitIso :=\n    Discrete.natIso fun i => eqToIso (by simp)\n  counitIso :=\n    Discrete.natIso fun j => eqToIso (by simp)\n\n"}
{"name":"CategoryTheory.Discrete.equivalence_functor","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"I : Type u‚ÇÅ\nJ : Type u‚ÇÇ\ne : Equiv I J\n‚ä¢ Eq (CategoryTheory.Discrete.equivalence e).functor (CategoryTheory.Discrete.functor (Function.comp CategoryTheory.Discrete.mk ‚áëe))","decl":"/-- We can promote a type-level `Equiv` to\nan equivalence between the corresponding `discrete` categories.\n-/\n@[simps]\ndef equivalence {I : Type u‚ÇÅ} {J : Type u‚ÇÇ} (e : I ‚âÉ J) : Discrete I ‚âå Discrete J where\n  functor := Discrete.functor (Discrete.mk ‚àò (e : I ‚Üí J))\n  inverse := Discrete.functor (Discrete.mk ‚àò (e.symm : J ‚Üí I))\n  unitIso :=\n    Discrete.natIso fun i => eqToIso (by simp)\n  counitIso :=\n    Discrete.natIso fun j => eqToIso (by simp)\n\n"}
{"name":"CategoryTheory.Discrete.equivalence_inverse","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"I : Type u‚ÇÅ\nJ : Type u‚ÇÇ\ne : Equiv I J\n‚ä¢ Eq (CategoryTheory.Discrete.equivalence e).inverse (CategoryTheory.Discrete.functor (Function.comp CategoryTheory.Discrete.mk ‚áëe.symm))","decl":"/-- We can promote a type-level `Equiv` to\nan equivalence between the corresponding `discrete` categories.\n-/\n@[simps]\ndef equivalence {I : Type u‚ÇÅ} {J : Type u‚ÇÇ} (e : I ‚âÉ J) : Discrete I ‚âå Discrete J where\n  functor := Discrete.functor (Discrete.mk ‚àò (e : I ‚Üí J))\n  inverse := Discrete.functor (Discrete.mk ‚àò (e.symm : J ‚Üí I))\n  unitIso :=\n    Discrete.natIso fun i => eqToIso (by simp)\n  counitIso :=\n    Discrete.natIso fun j => eqToIso (by simp)\n\n"}
{"name":"CategoryTheory.Discrete.equivOfEquivalence_symm_apply","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\nh : CategoryTheory.Equivalence (CategoryTheory.Discrete Œ±) (CategoryTheory.Discrete Œ≤)\na‚úù : Œ≤\n‚ä¢ Eq ((CategoryTheory.Discrete.equivOfEquivalence h).symm a‚úù) (Function.comp CategoryTheory.Discrete.as (Function.comp h.inverse.obj CategoryTheory.Discrete.mk) a‚úù)","decl":"/-- We can convert an equivalence of `discrete` categories to a type-level `Equiv`. -/\n@[simps]\ndef equivOfEquivalence {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} (h : Discrete Œ± ‚âå Discrete Œ≤) : Œ± ‚âÉ Œ≤ where\n  toFun := Discrete.as ‚àò h.functor.obj ‚àò Discrete.mk\n  invFun := Discrete.as ‚àò h.inverse.obj ‚àò Discrete.mk\n  left_inv a := by simpa using eq_of_hom (h.unitIso.app (Discrete.mk a)).2\n  right_inv a := by simpa using eq_of_hom (h.counitIso.app (Discrete.mk a)).1\n\n"}
{"name":"CategoryTheory.Discrete.equivOfEquivalence_apply","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\nŒ≤ : Type u‚ÇÇ\nh : CategoryTheory.Equivalence (CategoryTheory.Discrete Œ±) (CategoryTheory.Discrete Œ≤)\na‚úù : Œ±\n‚ä¢ Eq ((CategoryTheory.Discrete.equivOfEquivalence h) a‚úù) (Function.comp CategoryTheory.Discrete.as (Function.comp h.functor.obj CategoryTheory.Discrete.mk) a‚úù)","decl":"/-- We can convert an equivalence of `discrete` categories to a type-level `Equiv`. -/\n@[simps]\ndef equivOfEquivalence {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} (h : Discrete Œ± ‚âå Discrete Œ≤) : Œ± ‚âÉ Œ≤ where\n  toFun := Discrete.as ‚àò h.functor.obj ‚àò Discrete.mk\n  invFun := Discrete.as ‚àò h.inverse.obj ‚àò Discrete.mk\n  left_inv a := by simpa using eq_of_hom (h.unitIso.app (Discrete.mk a)).2\n  right_inv a := by simpa using eq_of_hom (h.counitIso.app (Discrete.mk a)).1\n\n"}
{"name":"CategoryTheory.Discrete.opposite_inverse_obj","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\na‚úù : CategoryTheory.Discrete Œ±\n‚ä¢ Eq ((CategoryTheory.Discrete.opposite Œ±).inverse.obj a‚úù) { unop := a‚úù }","decl":"/-- A discrete category is equivalent to its opposite category. -/\n@[simps! functor_obj_as inverse_obj]\nprotected def opposite (Œ± : Type u‚ÇÅ) : (Discrete Œ±)·µí·µñ ‚âå Discrete Œ± :=\n  let F : Discrete Œ± ‚•§ (Discrete Œ±)·µí·µñ := Discrete.functor fun x => op (Discrete.mk x)\n  { functor := F.leftOp\n    inverse := F\n    unitIso := NatIso.ofComponents fun ‚ü®_‚ü© => Iso.refl _\n    counitIso := Discrete.natIso fun ‚ü®_‚ü© => Iso.refl _ }\n\n"}
{"name":"CategoryTheory.Discrete.opposite_functor_obj_as","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"Œ± : Type u‚ÇÅ\nX : Opposite (CategoryTheory.Discrete Œ±)\n‚ä¢ Eq ((CategoryTheory.Discrete.opposite Œ±).functor.obj X).as (Opposite.unop X).as","decl":"/-- A discrete category is equivalent to its opposite category. -/\n@[simps! functor_obj_as inverse_obj]\nprotected def opposite (Œ± : Type u‚ÇÅ) : (Discrete Œ±)·µí·µñ ‚âå Discrete Œ± :=\n  let F : Discrete Œ± ‚•§ (Discrete Œ±)·µí·µñ := Discrete.functor fun x => op (Discrete.mk x)\n  { functor := F.leftOp\n    inverse := F\n    unitIso := NatIso.ofComponents fun ‚ü®_‚ü© => Iso.refl _\n    counitIso := Discrete.natIso fun ‚ü®_‚ü© => Iso.refl _ }\n\n"}
{"name":"CategoryTheory.Discrete.functor_map_id","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type v‚ÇÅ\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) C\nj : CategoryTheory.Discrete J\nf : Quiver.Hom j j\n‚ä¢ Eq (F.map f) (CategoryTheory.CategoryStruct.id (F.obj j))","decl":"@[simp]\ntheorem functor_map_id (F : Discrete J ‚•§ C) {j : Discrete J} (f : j ‚ü∂ j) :\n    F.map f = ùüô (F.obj j) := by\n  have h : f = ùüô j := by aesop_cat\n  rw [h]\n  simp\n\n"}
{"name":"CategoryTheory.piEquivalenceFunctorDiscrete_inverse_map","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type u‚ÇÇ\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : CategoryTheory.Functor (CategoryTheory.Discrete J) C\nf : Quiver.Hom X‚úù Y‚úù\nj : J\n‚ä¢ Eq ((CategoryTheory.piEquivalenceFunctorDiscrete J C).inverse.map f j) (f.app { as := j })","decl":"/-- The equivalence of categories `(J ‚Üí C) ‚âå (Discrete J ‚•§ C)`. -/\n@[simps]\ndef piEquivalenceFunctorDiscrete (J : Type u‚ÇÇ) (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] :\n    (J ‚Üí C) ‚âå (Discrete J ‚•§ C) where\n  functor :=\n    { obj := fun F => Discrete.functor F\n      map := fun f => Discrete.natTrans (fun j => f j.as) }\n  inverse :=\n    { obj := fun F j => F.obj ‚ü®j‚ü©\n      map := fun f j => f.app ‚ü®j‚ü© }\n  unitIso := Iso.refl _\n  counitIso := NatIso.ofComponents (fun F => (NatIso.ofComponents (fun _ => Iso.refl _)\n    (by\n      rintro ‚ü®x‚ü© ‚ü®y‚ü© f\n      obtain rfl : x = y := Discrete.eq_of_hom f\n      obtain rfl : f = ùüô _ := rfl\n      simp))) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.piEquivalenceFunctorDiscrete_functor_obj","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type u‚ÇÇ\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : J ‚Üí C\n‚ä¢ Eq ((CategoryTheory.piEquivalenceFunctorDiscrete J C).functor.obj F) (CategoryTheory.Discrete.functor F)","decl":"/-- The equivalence of categories `(J ‚Üí C) ‚âå (Discrete J ‚•§ C)`. -/\n@[simps]\ndef piEquivalenceFunctorDiscrete (J : Type u‚ÇÇ) (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] :\n    (J ‚Üí C) ‚âå (Discrete J ‚•§ C) where\n  functor :=\n    { obj := fun F => Discrete.functor F\n      map := fun f => Discrete.natTrans (fun j => f j.as) }\n  inverse :=\n    { obj := fun F j => F.obj ‚ü®j‚ü©\n      map := fun f j => f.app ‚ü®j‚ü© }\n  unitIso := Iso.refl _\n  counitIso := NatIso.ofComponents (fun F => (NatIso.ofComponents (fun _ => Iso.refl _)\n    (by\n      rintro ‚ü®x‚ü© ‚ü®y‚ü© f\n      obtain rfl : x = y := Discrete.eq_of_hom f\n      obtain rfl : f = ùüô _ := rfl\n      simp))) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.piEquivalenceFunctorDiscrete_inverse_obj","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type u‚ÇÇ\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) C\nj : J\n‚ä¢ Eq ((CategoryTheory.piEquivalenceFunctorDiscrete J C).inverse.obj F j) (F.obj { as := j })","decl":"/-- The equivalence of categories `(J ‚Üí C) ‚âå (Discrete J ‚•§ C)`. -/\n@[simps]\ndef piEquivalenceFunctorDiscrete (J : Type u‚ÇÇ) (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] :\n    (J ‚Üí C) ‚âå (Discrete J ‚•§ C) where\n  functor :=\n    { obj := fun F => Discrete.functor F\n      map := fun f => Discrete.natTrans (fun j => f j.as) }\n  inverse :=\n    { obj := fun F j => F.obj ‚ü®j‚ü©\n      map := fun f j => f.app ‚ü®j‚ü© }\n  unitIso := Iso.refl _\n  counitIso := NatIso.ofComponents (fun F => (NatIso.ofComponents (fun _ => Iso.refl _)\n    (by\n      rintro ‚ü®x‚ü© ‚ü®y‚ü© f\n      obtain rfl : x = y := Discrete.eq_of_hom f\n      obtain rfl : f = ùüô _ := rfl\n      simp))) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.piEquivalenceFunctorDiscrete_counitIso","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type u‚ÇÇ\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.piEquivalenceFunctorDiscrete J C).counitIso (CategoryTheory.NatIso.ofComponents (fun F => CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl ((({ obj := fun F j => F.obj { as := j }, map := fun {X Y} f j => f.app { as := j }, map_id := ‚ãØ, map_comp := ‚ãØ }.comp { obj := fun F => CategoryTheory.Discrete.functor F, map := fun {X Y} f => CategoryTheory.Discrete.natTrans fun j => f j.as, map_id := ‚ãØ, map_comp := ‚ãØ }).obj F).obj x)) ‚ãØ) ‚ãØ)","decl":"/-- The equivalence of categories `(J ‚Üí C) ‚âå (Discrete J ‚•§ C)`. -/\n@[simps]\ndef piEquivalenceFunctorDiscrete (J : Type u‚ÇÇ) (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] :\n    (J ‚Üí C) ‚âå (Discrete J ‚•§ C) where\n  functor :=\n    { obj := fun F => Discrete.functor F\n      map := fun f => Discrete.natTrans (fun j => f j.as) }\n  inverse :=\n    { obj := fun F j => F.obj ‚ü®j‚ü©\n      map := fun f j => f.app ‚ü®j‚ü© }\n  unitIso := Iso.refl _\n  counitIso := NatIso.ofComponents (fun F => (NatIso.ofComponents (fun _ => Iso.refl _)\n    (by\n      rintro ‚ü®x‚ü© ‚ü®y‚ü© f\n      obtain rfl : x = y := Discrete.eq_of_hom f\n      obtain rfl : f = ùüô _ := rfl\n      simp))) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.piEquivalenceFunctorDiscrete_functor_map","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type u‚ÇÇ\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : J ‚Üí C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.piEquivalenceFunctorDiscrete J C).functor.map f) (CategoryTheory.Discrete.natTrans fun j => f j.as)","decl":"/-- The equivalence of categories `(J ‚Üí C) ‚âå (Discrete J ‚•§ C)`. -/\n@[simps]\ndef piEquivalenceFunctorDiscrete (J : Type u‚ÇÇ) (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] :\n    (J ‚Üí C) ‚âå (Discrete J ‚•§ C) where\n  functor :=\n    { obj := fun F => Discrete.functor F\n      map := fun f => Discrete.natTrans (fun j => f j.as) }\n  inverse :=\n    { obj := fun F j => F.obj ‚ü®j‚ü©\n      map := fun f j => f.app ‚ü®j‚ü© }\n  unitIso := Iso.refl _\n  counitIso := NatIso.ofComponents (fun F => (NatIso.ofComponents (fun _ => Iso.refl _)\n    (by\n      rintro ‚ü®x‚ü© ‚ü®y‚ü© f\n      obtain rfl : x = y := Discrete.eq_of_hom f\n      obtain rfl : f = ùüô _ := rfl\n      simp))) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.piEquivalenceFunctorDiscrete_unitIso","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type u‚ÇÇ\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq (CategoryTheory.piEquivalenceFunctorDiscrete J C).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (J ‚Üí C)))","decl":"/-- The equivalence of categories `(J ‚Üí C) ‚âå (Discrete J ‚•§ C)`. -/\n@[simps]\ndef piEquivalenceFunctorDiscrete (J : Type u‚ÇÇ) (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] :\n    (J ‚Üí C) ‚âå (Discrete J ‚•§ C) where\n  functor :=\n    { obj := fun F => Discrete.functor F\n      map := fun f => Discrete.natTrans (fun j => f j.as) }\n  inverse :=\n    { obj := fun F j => F.obj ‚ü®j‚ü©\n      map := fun f j => f.app ‚ü®j‚ü© }\n  unitIso := Iso.refl _\n  counitIso := NatIso.ofComponents (fun F => (NatIso.ofComponents (fun _ => Iso.refl _)\n    (by\n      rintro ‚ü®x‚ü© ‚ü®y‚ü© f\n      obtain rfl : x = y := Discrete.eq_of_hom f\n      obtain rfl : f = ùüô _ := rfl\n      simp))) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.IsDiscrete.subsingleton","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nself : CategoryTheory.IsDiscrete C\nX Y : C\n‚ä¢ Subsingleton (Quiver.Hom X Y)","decl":"/-- A category is discrete when there is at most one morphism between two objects,\nin which case they are equal. -/\nclass IsDiscrete (C : Type*) [Category C] : Prop where\n  subsingleton (X Y : C) : Subsingleton (X ‚ü∂ Y) := by infer_instance\n  eq_of_hom {X Y : C} (f : X ‚ü∂ Y) : X = Y\n\n"}
{"name":"CategoryTheory.IsDiscrete.eq_of_hom","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nself : CategoryTheory.IsDiscrete C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq X Y","decl":"/-- A category is discrete when there is at most one morphism between two objects,\nin which case they are equal. -/\nclass IsDiscrete (C : Type*) [Category C] : Prop where\n  subsingleton (X Y : C) : Subsingleton (X ‚ü∂ Y) := by infer_instance\n  eq_of_hom {X Y : C} (f : X ‚ü∂ Y) : X = Y\n\n"}
{"name":"CategoryTheory.obj_ext_of_isDiscrete","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.IsDiscrete C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq X Y","decl":"lemma obj_ext_of_isDiscrete {C : Type*} [Category C] [IsDiscrete C]\n    {X Y : C} (f : X ‚ü∂ Y) : X = Y := IsDiscrete.eq_of_hom f\n\n"}
{"name":"CategoryTheory.Discrete.isDiscrete","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u_1\n‚ä¢ CategoryTheory.IsDiscrete (CategoryTheory.Discrete C)","decl":"instance Discrete.isDiscrete (C : Type*) : IsDiscrete (Discrete C) where\n  eq_of_hom := by rintro ‚ü®_‚ü© ‚ü®_‚ü© ‚ü®‚ü®rfl‚ü©‚ü©; rfl\n\n"}
{"name":"CategoryTheory.instIsDiscreteOpposite","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.IsDiscrete C\n‚ä¢ CategoryTheory.IsDiscrete (Opposite C)","decl":"instance (C : Type*) [Category C] [IsDiscrete C] : IsDiscrete C·µí·µñ where\n  eq_of_hom := by\n    rintro ‚ü®_‚ü© ‚ü®_‚ü© ‚ü®f‚ü©\n    obtain rfl := obj_ext_of_isDiscrete f\n    rfl\n\n"}
