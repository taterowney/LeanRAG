{"name":"CategoryTheory.Discrete.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\ninst✝ : SizeOf α\nas : α\n⊢ Eq (SizeOf.sizeOf { as := as }) (HAdd.hAdd 1 (SizeOf.sizeOf as))","decl":"/-- A wrapper for promoting any type to a category,\nwith the only morphisms being equalities.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Discrete (α : Type u₁) where\n  /-- A wrapper for promoting any type to a category,\n  with the only morphisms being equalities. -/\n  as : α\n\n"}
{"name":"CategoryTheory.Discrete.ext","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\nx y : CategoryTheory.Discrete α\nas : Eq x.as y.as\n⊢ Eq x y","decl":"/-- A wrapper for promoting any type to a category,\nwith the only morphisms being equalities.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Discrete (α : Type u₁) where\n  /-- A wrapper for promoting any type to a category,\n  with the only morphisms being equalities. -/\n  as : α\n\n"}
{"name":"CategoryTheory.Discrete.mk.injEq","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\nas✝ as : α\n⊢ Eq (Eq { as := as✝ } { as := as }) (Eq as✝ as)","decl":"/-- A wrapper for promoting any type to a category,\nwith the only morphisms being equalities.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Discrete (α : Type u₁) where\n  /-- A wrapper for promoting any type to a category,\n  with the only morphisms being equalities. -/\n  as : α\n\n"}
{"name":"CategoryTheory.Discrete.mk.inj","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\nas✝ as : α\nx✝ : Eq { as := as✝ } { as := as }\n⊢ Eq as✝ as","decl":"/-- A wrapper for promoting any type to a category,\nwith the only morphisms being equalities.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Discrete (α : Type u₁) where\n  /-- A wrapper for promoting any type to a category,\n  with the only morphisms being equalities. -/\n  as : α\n\n"}
{"name":"CategoryTheory.Discrete.ext_iff","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\nx y : CategoryTheory.Discrete α\n⊢ Iff (Eq x y) (Eq x.as y.as)","decl":"/-- A wrapper for promoting any type to a category,\nwith the only morphisms being equalities.\n-/\n@[ext, aesop safe cases (rule_sets := [CategoryTheory])]\nstructure Discrete (α : Type u₁) where\n  /-- A wrapper for promoting any type to a category,\n  with the only morphisms being equalities. -/\n  as : α\n\n"}
{"name":"CategoryTheory.Discrete.mk_as","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\nX : CategoryTheory.Discrete α\n⊢ Eq { as := X.as } X","decl":"@[simp]\ntheorem Discrete.mk_as {α : Type u₁} (X : Discrete α) : Discrete.mk X.as = X := by\n  rfl\n\n"}
{"name":"CategoryTheory.discreteEquiv_symm_apply_as","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\nas : α\n⊢ Eq (CategoryTheory.discreteEquiv.symm as).as as","decl":"/-- `Discrete α` is equivalent to the original type `α`. -/\n@[simps]\ndef discreteEquiv {α : Type u₁} : Discrete α ≃ α where\n  toFun := Discrete.as\n  invFun := Discrete.mk\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.discreteEquiv_apply","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\nself : CategoryTheory.Discrete α\n⊢ Eq (CategoryTheory.discreteEquiv self) self.as","decl":"/-- `Discrete α` is equivalent to the original type `α`. -/\n@[simps]\ndef discreteEquiv {α : Type u₁} : Discrete α ≃ α where\n  toFun := Discrete.as\n  invFun := Discrete.mk\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CategoryTheory.Discrete.instSubsingleton","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\ninst✝ : Subsingleton α\n⊢ Subsingleton (CategoryTheory.Discrete α)","decl":"instance [Subsingleton α] : Subsingleton (Discrete α) :=\n  ⟨by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Discrete.instSubsingletonDiscreteHom","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\nX Y : CategoryTheory.Discrete α\n⊢ Subsingleton (Quiver.Hom X Y)","decl":"instance instSubsingletonDiscreteHom (X Y : Discrete α) : Subsingleton (X ⟶ Y) :=\n  show Subsingleton (ULift (PLift _)) from inferInstance\n\n/- Porting note: rewrote `discrete_cases` tactic -/\n"}
{"name":"CategoryTheory.Discrete.eq_of_hom","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\nX Y : CategoryTheory.Discrete α\ni : Quiver.Hom X Y\n⊢ Eq X.as Y.as","decl":"/-- Extract the equation from a morphism in a discrete category. -/\ntheorem eq_of_hom {X Y : Discrete α} (i : X ⟶ Y) : X.as = Y.as :=\n  i.down.down\n\n"}
{"name":"CategoryTheory.Discrete.id_def","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\nX : CategoryTheory.Discrete α\n⊢ Eq { down := { down := ⋯ } } (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem id_def (X : Discrete α) : ULift.up (PLift.up (Eq.refl X.as)) = 𝟙 X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Discrete.instIsIso","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"I : Type u₁\ni j : CategoryTheory.Discrete I\nf : Quiver.Hom i j\n⊢ CategoryTheory.IsIso f","decl":"instance {I : Type u₁} {i j : Discrete I} (f : i ⟶ j) : IsIso f :=\n  ⟨⟨Discrete.eqToHom (eq_of_hom f).symm, by aesop_cat⟩⟩\n\n"}
{"name":"CategoryTheory.Discrete.functor_obj","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} C\nI : Type u₁\nF : I → C\ni : I\n⊢ Eq ((CategoryTheory.Discrete.functor F).obj { as := i }) (F i)","decl":"@[simp]\ntheorem functor_obj {I : Type u₁} (F : I → C) (i : I) :\n    (Discrete.functor F).obj (Discrete.mk i) = F i :=\n  rfl\n\n"}
{"name":"CategoryTheory.Discrete.functor_map","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} C\nI : Type u₁\nF : I → C\ni : CategoryTheory.Discrete I\nf : Quiver.Hom i i\n⊢ Eq ((CategoryTheory.Discrete.functor F).map f) (CategoryTheory.CategoryStruct.id (F i.as))","decl":"@[simp]\ntheorem functor_map {I : Type u₁} (F : I → C) {i : Discrete I} (f : i ⟶ i) :\n    (Discrete.functor F).map f = 𝟙 (F i.as) := by aesop_cat\n"}
{"name":"CategoryTheory.Discrete.functor_obj_eq_as","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} C\nI : Type u₁\nF : I → C\nX : CategoryTheory.Discrete I\n⊢ Eq ((CategoryTheory.Discrete.functor F).obj X) (F X.as)","decl":"@[simp]\ntheorem functor_obj_eq_as {I : Type u₁} (F : I → C) (X : Discrete I) :\n    (Discrete.functor F).obj X = F X.as :=\n  rfl\n"}
{"name":"CategoryTheory.Discrete.functorComp_inv_app","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} C\nI : Type u₁\nJ : Type u₁'\nf : J → C\ng : I → J\nX : CategoryTheory.Discrete I\n⊢ Eq ((CategoryTheory.Discrete.functorComp f g).inv.app X) (CategoryTheory.CategoryStruct.id (f (g X.as)))","decl":"/-- The discrete functor induced by a composition of maps can be written as a\ncomposition of two discrete functors.\n-/\n@[simps!]\ndef functorComp {I : Type u₁} {J : Type u₁'} (f : J → C) (g : I → J) :\n    Discrete.functor (f ∘ g) ≅ Discrete.functor (Discrete.mk ∘ g) ⋙ Discrete.functor f :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Discrete.functorComp_hom_app","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} C\nI : Type u₁\nJ : Type u₁'\nf : J → C\ng : I → J\nX : CategoryTheory.Discrete I\n⊢ Eq ((CategoryTheory.Discrete.functorComp f g).hom.app X) (CategoryTheory.CategoryStruct.id (f (g X.as)))","decl":"/-- The discrete functor induced by a composition of maps can be written as a\ncomposition of two discrete functors.\n-/\n@[simps!]\ndef functorComp {I : Type u₁} {J : Type u₁'} (f : J → C) (g : I → J) :\n    Discrete.functor (f ∘ g) ≅ Discrete.functor (Discrete.mk ∘ g) ⋙ Discrete.functor f :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Discrete.natTrans_app","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} C\nI : Type u₁\nF G : CategoryTheory.Functor (CategoryTheory.Discrete I) C\nf : (i : CategoryTheory.Discrete I) → Quiver.Hom (F.obj i) (G.obj i)\ni : CategoryTheory.Discrete I\n⊢ Eq ((CategoryTheory.Discrete.natTrans f).app i) (f i)","decl":"/-- For functors out of a discrete category,\na natural transformation is just a collection of maps,\nas the naturality squares are trivial.\n-/\n@[simps]\ndef natTrans {I : Type u₁} {F G : Discrete I ⥤ C} (f : ∀ i : Discrete I, F.obj i ⟶ G.obj i) :\n    F ⟶ G where\n  app := f\n  naturality := fun {X Y} ⟨⟨g⟩⟩ => by\n    discrete_cases\n    rcases g\n    change F.map (𝟙 _) ≫ _ = _ ≫ G.map (𝟙 _)\n    simp\n\n"}
{"name":"CategoryTheory.Discrete.natIso_inv_app","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} C\nI : Type u₁\nF G : CategoryTheory.Functor (CategoryTheory.Discrete I) C\nf : (i : CategoryTheory.Discrete I) → CategoryTheory.Iso (F.obj i) (G.obj i)\nX : CategoryTheory.Discrete I\n⊢ Eq ((CategoryTheory.Discrete.natIso f).inv.app X) (f X).inv","decl":"/-- For functors out of a discrete category,\na natural isomorphism is just a collection of isomorphisms,\nas the naturality squares are trivial.\n-/\n@[simps!]\ndef natIso {I : Type u₁} {F G : Discrete I ⥤ C} (f : ∀ i : Discrete I, F.obj i ≅ G.obj i) :\n    F ≅ G :=\n  NatIso.ofComponents f fun ⟨⟨g⟩⟩ => by\n    discrete_cases\n    rcases g\n    change F.map (𝟙 _) ≫ _ = _ ≫ G.map (𝟙 _)\n    simp\n\n"}
{"name":"CategoryTheory.Discrete.natIso_hom_app","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} C\nI : Type u₁\nF G : CategoryTheory.Functor (CategoryTheory.Discrete I) C\nf : (i : CategoryTheory.Discrete I) → CategoryTheory.Iso (F.obj i) (G.obj i)\nX : CategoryTheory.Discrete I\n⊢ Eq ((CategoryTheory.Discrete.natIso f).hom.app X) (f X).hom","decl":"/-- For functors out of a discrete category,\na natural isomorphism is just a collection of isomorphisms,\nas the naturality squares are trivial.\n-/\n@[simps!]\ndef natIso {I : Type u₁} {F G : Discrete I ⥤ C} (f : ∀ i : Discrete I, F.obj i ≅ G.obj i) :\n    F ≅ G :=\n  NatIso.ofComponents f fun ⟨⟨g⟩⟩ => by\n    discrete_cases\n    rcases g\n    change F.map (𝟙 _) ≫ _ = _ ≫ G.map (𝟙 _)\n    simp\n\n"}
{"name":"CategoryTheory.Discrete.instIsIsoFunctorNatTrans","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C\nI : Type u_1\nF G : CategoryTheory.Functor (CategoryTheory.Discrete I) C\nf : (i : CategoryTheory.Discrete I) → Quiver.Hom (F.obj i) (G.obj i)\ninst✝ : ∀ (i : CategoryTheory.Discrete I), CategoryTheory.IsIso (f i)\n⊢ CategoryTheory.IsIso (CategoryTheory.Discrete.natTrans f)","decl":"instance {I : Type*} {F G : Discrete I ⥤ C} (f : ∀ i, F.obj i ⟶ G.obj i) [∀ i, IsIso (f i)] :\n    IsIso (Discrete.natTrans f) := by\n  change IsIso (Discrete.natIso (fun i => asIso (f i))).hom\n  infer_instance\n\n"}
{"name":"CategoryTheory.Discrete.natIso_app","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} C\nI : Type u₁\nF G : CategoryTheory.Functor (CategoryTheory.Discrete I) C\nf : (i : CategoryTheory.Discrete I) → CategoryTheory.Iso (F.obj i) (G.obj i)\ni : CategoryTheory.Discrete I\n⊢ Eq ((CategoryTheory.Discrete.natIso f).app i) (f i)","decl":"@[simp]\ntheorem natIso_app {I : Type u₁} {F G : Discrete I ⥤ C} (f : ∀ i : Discrete I, F.obj i ≅ G.obj i)\n    (i : Discrete I) : (Discrete.natIso f).app i = f i := by aesop_cat\n\n"}
{"name":"CategoryTheory.Discrete.equivalence_counitIso","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"I : Type u₁\nJ : Type u₂\ne : Equiv I J\n⊢ Eq (CategoryTheory.Discrete.equivalence e).counitIso (CategoryTheory.Discrete.natIso fun j => CategoryTheory.eqToIso ⋯)","decl":"/-- We can promote a type-level `Equiv` to\nan equivalence between the corresponding `discrete` categories.\n-/\n@[simps]\ndef equivalence {I : Type u₁} {J : Type u₂} (e : I ≃ J) : Discrete I ≌ Discrete J where\n  functor := Discrete.functor (Discrete.mk ∘ (e : I → J))\n  inverse := Discrete.functor (Discrete.mk ∘ (e.symm : J → I))\n  unitIso :=\n    Discrete.natIso fun i => eqToIso (by simp)\n  counitIso :=\n    Discrete.natIso fun j => eqToIso (by simp)\n\n"}
{"name":"CategoryTheory.Discrete.equivalence_unitIso","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"I : Type u₁\nJ : Type u₂\ne : Equiv I J\n⊢ Eq (CategoryTheory.Discrete.equivalence e).unitIso (CategoryTheory.Discrete.natIso fun i => CategoryTheory.eqToIso ⋯)","decl":"/-- We can promote a type-level `Equiv` to\nan equivalence between the corresponding `discrete` categories.\n-/\n@[simps]\ndef equivalence {I : Type u₁} {J : Type u₂} (e : I ≃ J) : Discrete I ≌ Discrete J where\n  functor := Discrete.functor (Discrete.mk ∘ (e : I → J))\n  inverse := Discrete.functor (Discrete.mk ∘ (e.symm : J → I))\n  unitIso :=\n    Discrete.natIso fun i => eqToIso (by simp)\n  counitIso :=\n    Discrete.natIso fun j => eqToIso (by simp)\n\n"}
{"name":"CategoryTheory.Discrete.equivalence_functor","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"I : Type u₁\nJ : Type u₂\ne : Equiv I J\n⊢ Eq (CategoryTheory.Discrete.equivalence e).functor (CategoryTheory.Discrete.functor (Function.comp CategoryTheory.Discrete.mk ⇑e))","decl":"/-- We can promote a type-level `Equiv` to\nan equivalence between the corresponding `discrete` categories.\n-/\n@[simps]\ndef equivalence {I : Type u₁} {J : Type u₂} (e : I ≃ J) : Discrete I ≌ Discrete J where\n  functor := Discrete.functor (Discrete.mk ∘ (e : I → J))\n  inverse := Discrete.functor (Discrete.mk ∘ (e.symm : J → I))\n  unitIso :=\n    Discrete.natIso fun i => eqToIso (by simp)\n  counitIso :=\n    Discrete.natIso fun j => eqToIso (by simp)\n\n"}
{"name":"CategoryTheory.Discrete.equivalence_inverse","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"I : Type u₁\nJ : Type u₂\ne : Equiv I J\n⊢ Eq (CategoryTheory.Discrete.equivalence e).inverse (CategoryTheory.Discrete.functor (Function.comp CategoryTheory.Discrete.mk ⇑e.symm))","decl":"/-- We can promote a type-level `Equiv` to\nan equivalence between the corresponding `discrete` categories.\n-/\n@[simps]\ndef equivalence {I : Type u₁} {J : Type u₂} (e : I ≃ J) : Discrete I ≌ Discrete J where\n  functor := Discrete.functor (Discrete.mk ∘ (e : I → J))\n  inverse := Discrete.functor (Discrete.mk ∘ (e.symm : J → I))\n  unitIso :=\n    Discrete.natIso fun i => eqToIso (by simp)\n  counitIso :=\n    Discrete.natIso fun j => eqToIso (by simp)\n\n"}
{"name":"CategoryTheory.Discrete.equivOfEquivalence_symm_apply","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\nβ : Type u₂\nh : CategoryTheory.Equivalence (CategoryTheory.Discrete α) (CategoryTheory.Discrete β)\na✝ : β\n⊢ Eq ((CategoryTheory.Discrete.equivOfEquivalence h).symm a✝) (Function.comp CategoryTheory.Discrete.as (Function.comp h.inverse.obj CategoryTheory.Discrete.mk) a✝)","decl":"/-- We can convert an equivalence of `discrete` categories to a type-level `Equiv`. -/\n@[simps]\ndef equivOfEquivalence {α : Type u₁} {β : Type u₂} (h : Discrete α ≌ Discrete β) : α ≃ β where\n  toFun := Discrete.as ∘ h.functor.obj ∘ Discrete.mk\n  invFun := Discrete.as ∘ h.inverse.obj ∘ Discrete.mk\n  left_inv a := by simpa using eq_of_hom (h.unitIso.app (Discrete.mk a)).2\n  right_inv a := by simpa using eq_of_hom (h.counitIso.app (Discrete.mk a)).1\n\n"}
{"name":"CategoryTheory.Discrete.equivOfEquivalence_apply","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\nβ : Type u₂\nh : CategoryTheory.Equivalence (CategoryTheory.Discrete α) (CategoryTheory.Discrete β)\na✝ : α\n⊢ Eq ((CategoryTheory.Discrete.equivOfEquivalence h) a✝) (Function.comp CategoryTheory.Discrete.as (Function.comp h.functor.obj CategoryTheory.Discrete.mk) a✝)","decl":"/-- We can convert an equivalence of `discrete` categories to a type-level `Equiv`. -/\n@[simps]\ndef equivOfEquivalence {α : Type u₁} {β : Type u₂} (h : Discrete α ≌ Discrete β) : α ≃ β where\n  toFun := Discrete.as ∘ h.functor.obj ∘ Discrete.mk\n  invFun := Discrete.as ∘ h.inverse.obj ∘ Discrete.mk\n  left_inv a := by simpa using eq_of_hom (h.unitIso.app (Discrete.mk a)).2\n  right_inv a := by simpa using eq_of_hom (h.counitIso.app (Discrete.mk a)).1\n\n"}
{"name":"CategoryTheory.Discrete.opposite_inverse_obj","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\na✝ : CategoryTheory.Discrete α\n⊢ Eq ((CategoryTheory.Discrete.opposite α).inverse.obj a✝) { unop := a✝ }","decl":"/-- A discrete category is equivalent to its opposite category. -/\n@[simps! functor_obj_as inverse_obj]\nprotected def opposite (α : Type u₁) : (Discrete α)ᵒᵖ ≌ Discrete α :=\n  let F : Discrete α ⥤ (Discrete α)ᵒᵖ := Discrete.functor fun x => op (Discrete.mk x)\n  { functor := F.leftOp\n    inverse := F\n    unitIso := NatIso.ofComponents fun ⟨_⟩ => Iso.refl _\n    counitIso := Discrete.natIso fun ⟨_⟩ => Iso.refl _ }\n\n"}
{"name":"CategoryTheory.Discrete.opposite_functor_obj_as","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"α : Type u₁\nX : Opposite (CategoryTheory.Discrete α)\n⊢ Eq ((CategoryTheory.Discrete.opposite α).functor.obj X).as (Opposite.unop X).as","decl":"/-- A discrete category is equivalent to its opposite category. -/\n@[simps! functor_obj_as inverse_obj]\nprotected def opposite (α : Type u₁) : (Discrete α)ᵒᵖ ≌ Discrete α :=\n  let F : Discrete α ⥤ (Discrete α)ᵒᵖ := Discrete.functor fun x => op (Discrete.mk x)\n  { functor := F.leftOp\n    inverse := F\n    unitIso := NatIso.ofComponents fun ⟨_⟩ => Iso.refl _\n    counitIso := Discrete.natIso fun ⟨_⟩ => Iso.refl _ }\n\n"}
{"name":"CategoryTheory.Discrete.functor_map_id","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type v₁\nC : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) C\nj : CategoryTheory.Discrete J\nf : Quiver.Hom j j\n⊢ Eq (F.map f) (CategoryTheory.CategoryStruct.id (F.obj j))","decl":"@[simp]\ntheorem functor_map_id (F : Discrete J ⥤ C) {j : Discrete J} (f : j ⟶ j) :\n    F.map f = 𝟙 (F.obj j) := by\n  have h : f = 𝟙 j := by aesop_cat\n  rw [h]\n  simp\n\n"}
{"name":"CategoryTheory.piEquivalenceFunctorDiscrete_inverse_map","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type u₂\nC : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : CategoryTheory.Functor (CategoryTheory.Discrete J) C\nf : Quiver.Hom X✝ Y✝\nj : J\n⊢ Eq ((CategoryTheory.piEquivalenceFunctorDiscrete J C).inverse.map f j) (f.app { as := j })","decl":"/-- The equivalence of categories `(J → C) ≌ (Discrete J ⥤ C)`. -/\n@[simps]\ndef piEquivalenceFunctorDiscrete (J : Type u₂) (C : Type u₁) [Category.{v₁} C] :\n    (J → C) ≌ (Discrete J ⥤ C) where\n  functor :=\n    { obj := fun F => Discrete.functor F\n      map := fun f => Discrete.natTrans (fun j => f j.as) }\n  inverse :=\n    { obj := fun F j => F.obj ⟨j⟩\n      map := fun f j => f.app ⟨j⟩ }\n  unitIso := Iso.refl _\n  counitIso := NatIso.ofComponents (fun F => (NatIso.ofComponents (fun _ => Iso.refl _)\n    (by\n      rintro ⟨x⟩ ⟨y⟩ f\n      obtain rfl : x = y := Discrete.eq_of_hom f\n      obtain rfl : f = 𝟙 _ := rfl\n      simp))) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.piEquivalenceFunctorDiscrete_functor_obj","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type u₂\nC : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nF : J → C\n⊢ Eq ((CategoryTheory.piEquivalenceFunctorDiscrete J C).functor.obj F) (CategoryTheory.Discrete.functor F)","decl":"/-- The equivalence of categories `(J → C) ≌ (Discrete J ⥤ C)`. -/\n@[simps]\ndef piEquivalenceFunctorDiscrete (J : Type u₂) (C : Type u₁) [Category.{v₁} C] :\n    (J → C) ≌ (Discrete J ⥤ C) where\n  functor :=\n    { obj := fun F => Discrete.functor F\n      map := fun f => Discrete.natTrans (fun j => f j.as) }\n  inverse :=\n    { obj := fun F j => F.obj ⟨j⟩\n      map := fun f j => f.app ⟨j⟩ }\n  unitIso := Iso.refl _\n  counitIso := NatIso.ofComponents (fun F => (NatIso.ofComponents (fun _ => Iso.refl _)\n    (by\n      rintro ⟨x⟩ ⟨y⟩ f\n      obtain rfl : x = y := Discrete.eq_of_hom f\n      obtain rfl : f = 𝟙 _ := rfl\n      simp))) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.piEquivalenceFunctorDiscrete_inverse_obj","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type u₂\nC : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nF : CategoryTheory.Functor (CategoryTheory.Discrete J) C\nj : J\n⊢ Eq ((CategoryTheory.piEquivalenceFunctorDiscrete J C).inverse.obj F j) (F.obj { as := j })","decl":"/-- The equivalence of categories `(J → C) ≌ (Discrete J ⥤ C)`. -/\n@[simps]\ndef piEquivalenceFunctorDiscrete (J : Type u₂) (C : Type u₁) [Category.{v₁} C] :\n    (J → C) ≌ (Discrete J ⥤ C) where\n  functor :=\n    { obj := fun F => Discrete.functor F\n      map := fun f => Discrete.natTrans (fun j => f j.as) }\n  inverse :=\n    { obj := fun F j => F.obj ⟨j⟩\n      map := fun f j => f.app ⟨j⟩ }\n  unitIso := Iso.refl _\n  counitIso := NatIso.ofComponents (fun F => (NatIso.ofComponents (fun _ => Iso.refl _)\n    (by\n      rintro ⟨x⟩ ⟨y⟩ f\n      obtain rfl : x = y := Discrete.eq_of_hom f\n      obtain rfl : f = 𝟙 _ := rfl\n      simp))) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.piEquivalenceFunctorDiscrete_counitIso","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type u₂\nC : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq (CategoryTheory.piEquivalenceFunctorDiscrete J C).counitIso (CategoryTheory.NatIso.ofComponents (fun F => CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl ((({ obj := fun F j => F.obj { as := j }, map := fun {X Y} f j => f.app { as := j }, map_id := ⋯, map_comp := ⋯ }.comp { obj := fun F => CategoryTheory.Discrete.functor F, map := fun {X Y} f => CategoryTheory.Discrete.natTrans fun j => f j.as, map_id := ⋯, map_comp := ⋯ }).obj F).obj x)) ⋯) ⋯)","decl":"/-- The equivalence of categories `(J → C) ≌ (Discrete J ⥤ C)`. -/\n@[simps]\ndef piEquivalenceFunctorDiscrete (J : Type u₂) (C : Type u₁) [Category.{v₁} C] :\n    (J → C) ≌ (Discrete J ⥤ C) where\n  functor :=\n    { obj := fun F => Discrete.functor F\n      map := fun f => Discrete.natTrans (fun j => f j.as) }\n  inverse :=\n    { obj := fun F j => F.obj ⟨j⟩\n      map := fun f j => f.app ⟨j⟩ }\n  unitIso := Iso.refl _\n  counitIso := NatIso.ofComponents (fun F => (NatIso.ofComponents (fun _ => Iso.refl _)\n    (by\n      rintro ⟨x⟩ ⟨y⟩ f\n      obtain rfl : x = y := Discrete.eq_of_hom f\n      obtain rfl : f = 𝟙 _ := rfl\n      simp))) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.piEquivalenceFunctorDiscrete_functor_map","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type u₂\nC : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : J → C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.piEquivalenceFunctorDiscrete J C).functor.map f) (CategoryTheory.Discrete.natTrans fun j => f j.as)","decl":"/-- The equivalence of categories `(J → C) ≌ (Discrete J ⥤ C)`. -/\n@[simps]\ndef piEquivalenceFunctorDiscrete (J : Type u₂) (C : Type u₁) [Category.{v₁} C] :\n    (J → C) ≌ (Discrete J ⥤ C) where\n  functor :=\n    { obj := fun F => Discrete.functor F\n      map := fun f => Discrete.natTrans (fun j => f j.as) }\n  inverse :=\n    { obj := fun F j => F.obj ⟨j⟩\n      map := fun f j => f.app ⟨j⟩ }\n  unitIso := Iso.refl _\n  counitIso := NatIso.ofComponents (fun F => (NatIso.ofComponents (fun _ => Iso.refl _)\n    (by\n      rintro ⟨x⟩ ⟨y⟩ f\n      obtain rfl : x = y := Discrete.eq_of_hom f\n      obtain rfl : f = 𝟙 _ := rfl\n      simp))) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.piEquivalenceFunctorDiscrete_unitIso","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"J : Type u₂\nC : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq (CategoryTheory.piEquivalenceFunctorDiscrete J C).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (J → C)))","decl":"/-- The equivalence of categories `(J → C) ≌ (Discrete J ⥤ C)`. -/\n@[simps]\ndef piEquivalenceFunctorDiscrete (J : Type u₂) (C : Type u₁) [Category.{v₁} C] :\n    (J → C) ≌ (Discrete J ⥤ C) where\n  functor :=\n    { obj := fun F => Discrete.functor F\n      map := fun f => Discrete.natTrans (fun j => f j.as) }\n  inverse :=\n    { obj := fun F j => F.obj ⟨j⟩\n      map := fun f j => f.app ⟨j⟩ }\n  unitIso := Iso.refl _\n  counitIso := NatIso.ofComponents (fun F => (NatIso.ofComponents (fun _ => Iso.refl _)\n    (by\n      rintro ⟨x⟩ ⟨y⟩ f\n      obtain rfl : x = y := Discrete.eq_of_hom f\n      obtain rfl : f = 𝟙 _ := rfl\n      simp))) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.IsDiscrete.subsingleton","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nself : CategoryTheory.IsDiscrete C\nX Y : C\n⊢ Subsingleton (Quiver.Hom X Y)","decl":"/-- A category is discrete when there is at most one morphism between two objects,\nin which case they are equal. -/\nclass IsDiscrete (C : Type*) [Category C] : Prop where\n  subsingleton (X Y : C) : Subsingleton (X ⟶ Y) := by infer_instance\n  eq_of_hom {X Y : C} (f : X ⟶ Y) : X = Y\n\n"}
{"name":"CategoryTheory.IsDiscrete.eq_of_hom","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nself : CategoryTheory.IsDiscrete C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq X Y","decl":"/-- A category is discrete when there is at most one morphism between two objects,\nin which case they are equal. -/\nclass IsDiscrete (C : Type*) [Category C] : Prop where\n  subsingleton (X Y : C) : Subsingleton (X ⟶ Y) := by infer_instance\n  eq_of_hom {X Y : C} (f : X ⟶ Y) : X = Y\n\n"}
{"name":"CategoryTheory.obj_ext_of_isDiscrete","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.IsDiscrete C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq X Y","decl":"lemma obj_ext_of_isDiscrete {C : Type*} [Category C] [IsDiscrete C]\n    {X Y : C} (f : X ⟶ Y) : X = Y := IsDiscrete.eq_of_hom f\n\n"}
{"name":"CategoryTheory.Discrete.isDiscrete","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u_1\n⊢ CategoryTheory.IsDiscrete (CategoryTheory.Discrete C)","decl":"instance Discrete.isDiscrete (C : Type*) : IsDiscrete (Discrete C) where\n  eq_of_hom := by rintro ⟨_⟩ ⟨_⟩ ⟨⟨rfl⟩⟩; rfl\n\n"}
{"name":"CategoryTheory.instIsDiscreteOpposite","module":"Mathlib.CategoryTheory.DiscreteCategory","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.IsDiscrete C\n⊢ CategoryTheory.IsDiscrete (Opposite C)","decl":"instance (C : Type*) [Category C] [IsDiscrete C] : IsDiscrete Cᵒᵖ where\n  eq_of_hom := by\n    rintro ⟨_⟩ ⟨_⟩ ⟨f⟩\n    obtain rfl := obj_ext_of_isDiscrete f\n    rfl\n\n"}
