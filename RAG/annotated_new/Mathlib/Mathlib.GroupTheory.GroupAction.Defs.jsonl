{"name":"AddAction.mem_orbit_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\na₁ a₂ : α\n⊢ Iff (Membership.mem (AddAction.orbit M a₁) a₂) (Exists fun x => Eq (HVAdd.hVAdd x a₁) a₂)","decl":"@[to_additive]\ntheorem mem_orbit_iff {a₁ a₂ : α} : a₂ ∈ orbit M a₁ ↔ ∃ x : M, x • a₁ = a₂ :=\n  Iff.rfl\n\n"}
{"name":"MulAction.mem_orbit_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\na₁ a₂ : α\n⊢ Iff (Membership.mem (MulAction.orbit M a₁) a₂) (Exists fun x => Eq (HSMul.hSMul x a₁) a₂)","decl":"@[to_additive]\ntheorem mem_orbit_iff {a₁ a₂ : α} : a₂ ∈ orbit M a₁ ↔ ∃ x : M, x • a₁ = a₂ :=\n  Iff.rfl\n\n"}
{"name":"MulAction.mem_orbit","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\na : α\nm : M\n⊢ Membership.mem (MulAction.orbit M a) (HSMul.hSMul m a)","decl":"@[to_additive (attr := simp)]\ntheorem mem_orbit (a : α) (m : M) : m • a ∈ orbit M a :=\n  ⟨m, rfl⟩\n\n"}
{"name":"AddAction.mem_orbit","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\na : α\nm : M\n⊢ Membership.mem (AddAction.orbit M a) (HVAdd.hVAdd m a)","decl":"@[to_additive (attr := simp)]\ntheorem mem_orbit (a : α) (m : M) : m • a ∈ orbit M a :=\n  ⟨m, rfl⟩\n\n"}
{"name":"AddAction.mem_orbit_self","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\na : α\n⊢ Membership.mem (AddAction.orbit M a) a","decl":"@[to_additive (attr := simp)]\ntheorem mem_orbit_self (a : α) : a ∈ orbit M a :=\n  ⟨1, by simp [MulAction.one_smul]⟩\n\n"}
{"name":"MulAction.mem_orbit_self","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\na : α\n⊢ Membership.mem (MulAction.orbit M a) a","decl":"@[to_additive (attr := simp)]\ntheorem mem_orbit_self (a : α) : a ∈ orbit M a :=\n  ⟨1, by simp [MulAction.one_smul]⟩\n\n"}
{"name":"MulAction.orbit_nonempty","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\na : α\n⊢ (MulAction.orbit M a).Nonempty","decl":"@[to_additive]\ntheorem orbit_nonempty (a : α) : Set.Nonempty (orbit M a) :=\n  Set.range_nonempty _\n\n"}
{"name":"AddAction.orbit_nonempty","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\na : α\n⊢ (AddAction.orbit M a).Nonempty","decl":"@[to_additive]\ntheorem orbit_nonempty (a : α) : Set.Nonempty (orbit M a) :=\n  Set.range_nonempty _\n\n"}
{"name":"MulAction.mapsTo_smul_orbit","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\nm : M\na : α\n⊢ Set.MapsTo (fun x => HSMul.hSMul m x) (MulAction.orbit M a) (MulAction.orbit M a)","decl":"@[to_additive]\ntheorem mapsTo_smul_orbit (m : M) (a : α) : Set.MapsTo (m • ·) (orbit M a) (orbit M a) :=\n  Set.range_subset_iff.2 fun m' => ⟨m * m', mul_smul _ _ _⟩\n\n"}
{"name":"AddAction.mapsTo_vadd_orbit","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\nm : M\na : α\n⊢ Set.MapsTo (fun x => HVAdd.hVAdd m x) (AddAction.orbit M a) (AddAction.orbit M a)","decl":"@[to_additive]\ntheorem mapsTo_smul_orbit (m : M) (a : α) : Set.MapsTo (m • ·) (orbit M a) (orbit M a) :=\n  Set.range_subset_iff.2 fun m' => ⟨m * m', mul_smul _ _ _⟩\n\n"}
{"name":"MulAction.smul_orbit_subset","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\nm : M\na : α\n⊢ HasSubset.Subset (HSMul.hSMul m (MulAction.orbit M a)) (MulAction.orbit M a)","decl":"@[to_additive]\ntheorem smul_orbit_subset (m : M) (a : α) : m • orbit M a ⊆ orbit M a :=\n  (mapsTo_smul_orbit m a).image_subset\n\n"}
{"name":"AddAction.vadd_orbit_subset","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\nm : M\na : α\n⊢ HasSubset.Subset (HVAdd.hVAdd m (AddAction.orbit M a)) (AddAction.orbit M a)","decl":"@[to_additive]\ntheorem smul_orbit_subset (m : M) (a : α) : m • orbit M a ⊆ orbit M a :=\n  (mapsTo_smul_orbit m a).image_subset\n\n"}
{"name":"AddAction.orbit_vadd_subset","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\nm : M\na : α\n⊢ HasSubset.Subset (AddAction.orbit M (HVAdd.hVAdd m a)) (AddAction.orbit M a)","decl":"@[to_additive]\ntheorem orbit_smul_subset (m : M) (a : α) : orbit M (m • a) ⊆ orbit M a :=\n  Set.range_subset_iff.2 fun m' => mul_smul m' m a ▸ mem_orbit _ _\n\n"}
{"name":"MulAction.orbit_smul_subset","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\nm : M\na : α\n⊢ HasSubset.Subset (MulAction.orbit M (HSMul.hSMul m a)) (MulAction.orbit M a)","decl":"@[to_additive]\ntheorem orbit_smul_subset (m : M) (a : α) : orbit M (m • a) ⊆ orbit M a :=\n  Set.range_subset_iff.2 fun m' => mul_smul m' m a ▸ mem_orbit _ _\n\n"}
{"name":"MulAction.orbit.coe_smul","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\na : α\nm : M\na' : ↑(MulAction.orbit M a)\n⊢ Eq (↑(HSMul.hSMul m a')) (HSMul.hSMul m ↑a')","decl":"@[to_additive (attr := simp)]\ntheorem orbit.coe_smul {a : α} {m : M} {a' : orbit M a} : ↑(m • a') = m • (a' : α) :=\n  rfl\n\n"}
{"name":"AddAction.orbit.coe_vadd","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\na : α\nm : M\na' : ↑(AddAction.orbit M a)\n⊢ Eq (↑(HVAdd.hVAdd m a')) (HVAdd.hVAdd m ↑a')","decl":"@[to_additive (attr := simp)]\ntheorem orbit.coe_smul {a : α} {m : M} {a' : orbit M a} : ↑(m • a') = m • (a' : α) :=\n  rfl\n\n"}
{"name":"MulAction.orbit_submonoid_subset","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\nS : Submonoid M\na : α\n⊢ HasSubset.Subset (MulAction.orbit (Subtype fun x => Membership.mem S x) a) (MulAction.orbit M a)","decl":"@[to_additive]\nlemma orbit_submonoid_subset (S : Submonoid M) (a : α) : orbit S a ⊆ orbit M a := by\n  rintro b ⟨g, rfl⟩\n  exact mem_orbit _ _\n\n"}
{"name":"AddAction.orbit_addSubmonoid_subset","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\nS : AddSubmonoid M\na : α\n⊢ HasSubset.Subset (AddAction.orbit (Subtype fun x => Membership.mem S x) a) (AddAction.orbit M a)","decl":"@[to_additive]\nlemma orbit_submonoid_subset (S : Submonoid M) (a : α) : orbit S a ⊆ orbit M a := by\n  rintro b ⟨g, rfl⟩\n  exact mem_orbit _ _\n\n"}
{"name":"MulAction.mem_orbit_of_mem_orbit_submonoid","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\nS : Submonoid M\na b : α\nh : Membership.mem (MulAction.orbit (Subtype fun x => Membership.mem S x) b) a\n⊢ Membership.mem (MulAction.orbit M b) a","decl":"@[to_additive]\nlemma mem_orbit_of_mem_orbit_submonoid {S : Submonoid M} {a b : α} (h : a ∈ orbit S b) :\n    a ∈ orbit M b :=\n  orbit_submonoid_subset S _ h\n\n"}
{"name":"AddAction.mem_orbit_of_mem_orbit_addSubmonoid","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\nS : AddSubmonoid M\na b : α\nh : Membership.mem (AddAction.orbit (Subtype fun x => Membership.mem S x) b) a\n⊢ Membership.mem (AddAction.orbit M b) a","decl":"@[to_additive]\nlemma mem_orbit_of_mem_orbit_submonoid {S : Submonoid M} {a b : α} (h : a ∈ orbit S b) :\n    a ∈ orbit M b :=\n  orbit_submonoid_subset S _ h\n\n"}
{"name":"MulAction.fixed_eq_iInter_fixedBy","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\n⊢ Eq (MulAction.fixedPoints M α) (Set.iInter fun m => MulAction.fixedBy α m)","decl":"@[to_additive]\ntheorem fixed_eq_iInter_fixedBy : fixedPoints M α = ⋂ m : M, fixedBy α m :=\n  Set.ext fun _ =>\n    ⟨fun hx => Set.mem_iInter.2 fun m => hx m, fun hx m => (Set.mem_iInter.1 hx m :)⟩\n\n"}
{"name":"AddAction.fixed_eq_iInter_fixedBy","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\n⊢ Eq (AddAction.fixedPoints M α) (Set.iInter fun m => AddAction.fixedBy α m)","decl":"@[to_additive]\ntheorem fixed_eq_iInter_fixedBy : fixedPoints M α = ⋂ m : M, fixedBy α m :=\n  Set.ext fun _ =>\n    ⟨fun hx => Set.mem_iInter.2 fun m => hx m, fun hx m => (Set.mem_iInter.1 hx m :)⟩\n\n"}
{"name":"AddAction.mem_fixedPoints","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\na : α\n⊢ Iff (Membership.mem (AddAction.fixedPoints M α) a) (∀ (m : M), Eq (HVAdd.hVAdd m a) a)","decl":"@[to_additive (attr := simp)]\ntheorem mem_fixedPoints {a : α} : a ∈ fixedPoints M α ↔ ∀ m : M, m • a = a :=\n  Iff.rfl\n\n"}
{"name":"MulAction.mem_fixedPoints","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\na : α\n⊢ Iff (Membership.mem (MulAction.fixedPoints M α) a) (∀ (m : M), Eq (HSMul.hSMul m a) a)","decl":"@[to_additive (attr := simp)]\ntheorem mem_fixedPoints {a : α} : a ∈ fixedPoints M α ↔ ∀ m : M, m • a = a :=\n  Iff.rfl\n\n"}
{"name":"AddAction.mem_fixedBy","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\nm : M\na : α\n⊢ Iff (Membership.mem (AddAction.fixedBy α m) a) (Eq (HVAdd.hVAdd m a) a)","decl":"@[to_additive (attr := simp)]\ntheorem mem_fixedBy {m : M} {a : α} : a ∈ fixedBy α m ↔ m • a = a :=\n  Iff.rfl\n\n"}
{"name":"MulAction.mem_fixedBy","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\nm : M\na : α\n⊢ Iff (Membership.mem (MulAction.fixedBy α m) a) (Eq (HSMul.hSMul m a) a)","decl":"@[to_additive (attr := simp)]\ntheorem mem_fixedBy {m : M} {a : α} : a ∈ fixedBy α m ↔ m • a = a :=\n  Iff.rfl\n\n"}
{"name":"AddAction.mem_fixedPoints'","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\na : α\n⊢ Iff (Membership.mem (AddAction.fixedPoints M α) a) (∀ (a' : α), Membership.mem (AddAction.orbit M a) a' → Eq a' a)","decl":"@[to_additive]\ntheorem mem_fixedPoints' {a : α} : a ∈ fixedPoints M α ↔ ∀ a', a' ∈ orbit M a → a' = a :=\n  ⟨fun h _ h₁ =>\n    let ⟨m, hm⟩ := mem_orbit_iff.1 h₁\n    hm ▸ h m,\n    fun h _ => h _ (mem_orbit _ _)⟩\n\n"}
{"name":"MulAction.mem_fixedPoints'","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\na : α\n⊢ Iff (Membership.mem (MulAction.fixedPoints M α) a) (∀ (a' : α), Membership.mem (MulAction.orbit M a) a' → Eq a' a)","decl":"@[to_additive]\ntheorem mem_fixedPoints' {a : α} : a ∈ fixedPoints M α ↔ ∀ a', a' ∈ orbit M a → a' = a :=\n  ⟨fun h _ h₁ =>\n    let ⟨m, hm⟩ := mem_orbit_iff.1 h₁\n    hm ▸ h m,\n    fun h _ => h _ (mem_orbit _ _)⟩\n\n"}
{"name":"MulAction.mem_stabilizerSubmonoid_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : Monoid M\nα : Type v\ninst✝ : MulAction M α\na : α\nm : M\n⊢ Iff (Membership.mem (MulAction.stabilizerSubmonoid M a) m) (Eq (HSMul.hSMul m a) a)","decl":"@[to_additive (attr := simp)]\ntheorem mem_stabilizerSubmonoid_iff {a : α} {m : M} : m ∈ stabilizerSubmonoid M a ↔ m • a = a :=\n  Iff.rfl\n\n"}
{"name":"AddAction.mem_stabilizerAddSubmonoid_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\ninst✝¹ : AddMonoid M\nα : Type v\ninst✝ : AddAction M α\na : α\nm : M\n⊢ Iff (Membership.mem (AddAction.stabilizerAddSubmonoid M a) m) (Eq (HVAdd.hVAdd m a) a)","decl":"@[to_additive (attr := simp)]\ntheorem mem_stabilizerSubmonoid_iff {a : α} {m : M} : m ∈ stabilizerSubmonoid M a ↔ m • a = a :=\n  Iff.rfl\n\n"}
{"name":"FixedPoints.mem_submonoid","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\nα : Type v\ninst✝² : Monoid M\ninst✝¹ : Monoid α\ninst✝ : MulDistribMulAction M α\na : α\n⊢ Iff (Membership.mem (FixedPoints.submonoid M α) a) (∀ (m : M), Eq (HSMul.hSMul m a) a)","decl":"@[simp]\nlemma FixedPoints.mem_submonoid (a : α) : a ∈ submonoid M α ↔ ∀ m : M, m • a = a :=\n  Iff.rfl\n\n"}
{"name":"FixedPoints.mem_subgroup","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\nα : Type v\ninst✝² : Monoid M\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction M α\na : α\n⊢ Iff (Membership.mem (FixedPoints.subgroup M α) a) (∀ (m : M), Eq (HSMul.hSMul m a) a)","decl":"@[simp]\nlemma mem_subgroup (a : α) : a ∈ α^*M ↔ ∀ m : M, m • a = a :=\n  Iff.rfl\n\n"}
{"name":"FixedPoints.subgroup_toSubmonoid","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\nα : Type v\ninst✝² : Monoid M\ninst✝¹ : Group α\ninst✝ : MulDistribMulAction M α\n⊢ Eq (FixedPoints.subgroup M α).toSubmonoid (FixedPoints.submonoid M α)","decl":"@[simp]\nlemma subgroup_toSubmonoid : (α^*M).toSubmonoid = submonoid M α :=\n  rfl\n\n"}
{"name":"FixedPoints.mem_addSubmonoid","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\nα : Type v\ninst✝² : Monoid M\ninst✝¹ : AddMonoid α\ninst✝ : DistribMulAction M α\na : α\n⊢ Iff (Membership.mem (FixedPoints.addSubmonoid M α) a) (∀ (m : M), Eq (HSMul.hSMul m a) a)","decl":"@[simp]\nlemma FixedPoints.mem_addSubmonoid (a : α) : a ∈ addSubmonoid M α ↔ ∀ m : M, m • a = a :=\n  Iff.rfl\n\n"}
{"name":"FixedPoints.mem_addSubgroup","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\nα : Type v\ninst✝² : Monoid M\ninst✝¹ : AddGroup α\ninst✝ : DistribMulAction M α\na : α\n⊢ Iff (Membership.mem (FixedPoints.addSubgroup M α) a) (∀ (m : M), Eq (HSMul.hSMul m a) a)","decl":"@[simp]\nlemma FixedPoints.mem_addSubgroup (a : α) : a ∈ α^+M ↔ ∀ m : M, m • a = a :=\n  Iff.rfl\n\n"}
{"name":"FixedPoints.addSubgroup_toAddSubmonoid","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"M : Type u\nα : Type v\ninst✝² : Monoid M\ninst✝¹ : AddGroup α\ninst✝ : DistribMulAction M α\n⊢ Eq (FixedPoints.addSubgroup M α).toAddSubmonoid (FixedPoints.addSubmonoid M α)","decl":"@[simp]\nlemma FixedPoints.addSubgroup_toAddSubmonoid : (α^+M).toAddSubmonoid = addSubmonoid M α :=\n  rfl\n\n"}
{"name":"MulAction.orbit_smul","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng : G\na : α\n⊢ Eq (MulAction.orbit G (HSMul.hSMul g a)) (MulAction.orbit G a)","decl":"@[to_additive (attr := simp)]\ntheorem orbit_smul (g : G) (a : α) : orbit G (g • a) = orbit G a :=\n  (orbit_smul_subset g a).antisymm <|\n    calc\n      orbit G a = orbit G (g⁻¹ • g • a) := by rw [inv_smul_smul]\n      _ ⊆ orbit G (g • a) := orbit_smul_subset _ _\n\n"}
{"name":"AddAction.orbit_vadd","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng : G\na : α\n⊢ Eq (AddAction.orbit G (HVAdd.hVAdd g a)) (AddAction.orbit G a)","decl":"@[to_additive (attr := simp)]\ntheorem orbit_smul (g : G) (a : α) : orbit G (g • a) = orbit G a :=\n  (orbit_smul_subset g a).antisymm <|\n    calc\n      orbit G a = orbit G (g⁻¹ • g • a) := by rw [inv_smul_smul]\n      _ ⊆ orbit G (g • a) := orbit_smul_subset _ _\n\n"}
{"name":"AddAction.orbit_eq_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na b : α\n⊢ Iff (Eq (AddAction.orbit G a) (AddAction.orbit G b)) (Membership.mem (AddAction.orbit G b) a)","decl":"@[to_additive]\ntheorem orbit_eq_iff {a b : α} : orbit G a = orbit G b ↔ a ∈ orbit G b :=\n  ⟨fun h => h ▸ mem_orbit_self _, fun ⟨_, hc⟩ => hc ▸ orbit_smul _ _⟩\n\n"}
{"name":"MulAction.orbit_eq_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\na b : α\n⊢ Iff (Eq (MulAction.orbit G a) (MulAction.orbit G b)) (Membership.mem (MulAction.orbit G b) a)","decl":"@[to_additive]\ntheorem orbit_eq_iff {a b : α} : orbit G a = orbit G b ↔ a ∈ orbit G b :=\n  ⟨fun h => h ▸ mem_orbit_self _, fun ⟨_, hc⟩ => hc ▸ orbit_smul _ _⟩\n\n"}
{"name":"AddAction.mem_orbit_vadd","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng : G\na : α\n⊢ Membership.mem (AddAction.orbit G (HVAdd.hVAdd g a)) a","decl":"@[to_additive]\ntheorem mem_orbit_smul (g : G) (a : α) : a ∈ orbit G (g • a) := by\n  simp only [orbit_smul, mem_orbit_self]\n\n"}
{"name":"MulAction.mem_orbit_smul","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng : G\na : α\n⊢ Membership.mem (MulAction.orbit G (HSMul.hSMul g a)) a","decl":"@[to_additive]\ntheorem mem_orbit_smul (g : G) (a : α) : a ∈ orbit G (g • a) := by\n  simp only [orbit_smul, mem_orbit_self]\n\n"}
{"name":"AddAction.vadd_mem_orbit_vadd","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng h : G\na : α\n⊢ Membership.mem (AddAction.orbit G (HVAdd.hVAdd h a)) (HVAdd.hVAdd g a)","decl":"@[to_additive]\ntheorem smul_mem_orbit_smul (g h : G) (a : α) : g • a ∈ orbit G (h • a) := by\n  simp only [orbit_smul, mem_orbit]\n\n"}
{"name":"MulAction.smul_mem_orbit_smul","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng h : G\na : α\n⊢ Membership.mem (MulAction.orbit G (HSMul.hSMul h a)) (HSMul.hSMul g a)","decl":"@[to_additive]\ntheorem smul_mem_orbit_smul (g h : G) (a : α) : g • a ∈ orbit G (h • a) := by\n  simp only [orbit_smul, mem_orbit]\n\n"}
{"name":"AddAction.orbit_addSubgroup_subset","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nH : AddSubgroup G\na : α\n⊢ HasSubset.Subset (AddAction.orbit (Subtype fun x => Membership.mem H x) a) (AddAction.orbit G a)","decl":"@[to_additive]\nlemma orbit_subgroup_subset (H : Subgroup G) (a : α) : orbit H a ⊆ orbit G a :=\n  orbit_submonoid_subset H.toSubmonoid a\n\n"}
{"name":"MulAction.orbit_subgroup_subset","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nH : Subgroup G\na : α\n⊢ HasSubset.Subset (MulAction.orbit (Subtype fun x => Membership.mem H x) a) (MulAction.orbit G a)","decl":"@[to_additive]\nlemma orbit_subgroup_subset (H : Subgroup G) (a : α) : orbit H a ⊆ orbit G a :=\n  orbit_submonoid_subset H.toSubmonoid a\n\n"}
{"name":"AddAction.mem_orbit_of_mem_orbit_addSubgroup","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nH : AddSubgroup G\na b : α\nh : Membership.mem (AddAction.orbit (Subtype fun x => Membership.mem H x) b) a\n⊢ Membership.mem (AddAction.orbit G b) a","decl":"@[to_additive]\nlemma mem_orbit_of_mem_orbit_subgroup {H : Subgroup G} {a b : α} (h : a ∈ orbit H b) :\n    a ∈ orbit G b :=\n  orbit_subgroup_subset H _ h\n\n"}
{"name":"MulAction.mem_orbit_of_mem_orbit_subgroup","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nH : Subgroup G\na b : α\nh : Membership.mem (MulAction.orbit (Subtype fun x => Membership.mem H x) b) a\n⊢ Membership.mem (MulAction.orbit G b) a","decl":"@[to_additive]\nlemma mem_orbit_of_mem_orbit_subgroup {H : Subgroup G} {a b : α} (h : a ∈ orbit H b) :\n    a ∈ orbit G b :=\n  orbit_subgroup_subset H _ h\n\n"}
{"name":"MulAction.mem_orbit_symm","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\na₁ a₂ : α\n⊢ Iff (Membership.mem (MulAction.orbit G a₂) a₁) (Membership.mem (MulAction.orbit G a₁) a₂)","decl":"@[to_additive]\nlemma mem_orbit_symm {a₁ a₂ : α} : a₁ ∈ orbit G a₂ ↔ a₂ ∈ orbit G a₁ := by\n  simp_rw [← orbit_eq_iff, eq_comm]\n\n"}
{"name":"AddAction.mem_orbit_symm","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na₁ a₂ : α\n⊢ Iff (Membership.mem (AddAction.orbit G a₂) a₁) (Membership.mem (AddAction.orbit G a₁) a₂)","decl":"@[to_additive]\nlemma mem_orbit_symm {a₁ a₂ : α} : a₁ ∈ orbit G a₂ ↔ a₂ ∈ orbit G a₁ := by\n  simp_rw [← orbit_eq_iff, eq_comm]\n\n"}
{"name":"AddAction.mem_addSubgroup_orbit_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nH : AddSubgroup G\nx : α\na b : ↑(AddAction.orbit G x)\n⊢ Iff (Membership.mem (AddAction.orbit (Subtype fun x => Membership.mem H x) b) a) (Membership.mem (AddAction.orbit (Subtype fun x => Membership.mem H x) ↑b) ↑a)","decl":"@[to_additive]\nlemma mem_subgroup_orbit_iff {H : Subgroup G} {x : α} {a b : orbit G x} :\n    a ∈ MulAction.orbit H b ↔ (a : α) ∈ MulAction.orbit H (b : α) := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rcases h with ⟨g, rfl⟩\n    exact MulAction.mem_orbit _ g\n  · rcases h with ⟨g, h⟩\n    dsimp at h\n    erw [← orbit.coe_smul, ← Subtype.ext_iff] at h\n    subst h\n    exact MulAction.mem_orbit _ g\n\n"}
{"name":"MulAction.mem_subgroup_orbit_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nH : Subgroup G\nx : α\na b : ↑(MulAction.orbit G x)\n⊢ Iff (Membership.mem (MulAction.orbit (Subtype fun x => Membership.mem H x) b) a) (Membership.mem (MulAction.orbit (Subtype fun x => Membership.mem H x) ↑b) ↑a)","decl":"@[to_additive]\nlemma mem_subgroup_orbit_iff {H : Subgroup G} {x : α} {a b : orbit G x} :\n    a ∈ MulAction.orbit H b ↔ (a : α) ∈ MulAction.orbit H (b : α) := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rcases h with ⟨g, rfl⟩\n    exact MulAction.mem_orbit _ g\n  · rcases h with ⟨g, h⟩\n    dsimp at h\n    erw [← orbit.coe_smul, ← Subtype.ext_iff] at h\n    subst h\n    exact MulAction.mem_orbit _ g\n\n"}
{"name":"AddAction.orbitRel_apply","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na b : α\n⊢ Iff ((AddAction.orbitRel G α) a b) (Membership.mem (AddAction.orbit G b) a)","decl":"@[to_additive]\ntheorem orbitRel_apply {a b : α} : orbitRel G α a b ↔ a ∈ orbit G b :=\n  Iff.rfl\n\n"}
{"name":"MulAction.orbitRel_apply","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\na b : α\n⊢ Iff ((MulAction.orbitRel G α) a b) (Membership.mem (MulAction.orbit G b) a)","decl":"@[to_additive]\ntheorem orbitRel_apply {a b : α} : orbitRel G α a b ↔ a ∈ orbit G b :=\n  Iff.rfl\n\n"}
{"name":"MulAction.orbitRel_r_apply","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\na b : α\n⊢ Iff ((MulAction.orbitRel G α) a b) (Membership.mem (MulAction.orbit G b) a)","decl":"@[to_additive]\nalias orbitRel_r_apply := orbitRel_apply\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"AddAction.orbitRel_r_apply","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na b : α\n⊢ Iff ((AddAction.orbitRel G α) a b) (Membership.mem (AddAction.orbit G b) a)","decl":"@[to_additive]\nalias orbitRel_r_apply := orbitRel_apply\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"AddAction.quotient_preimage_image_eq_union_add","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nU : Set α\n⊢ Eq (Set.preimage Quotient.mk' (Set.image Quotient.mk' U)) (Set.iUnion fun g => Set.image (fun x => HVAdd.hVAdd g x) U)","decl":"/-- When you take a set `U` in `α`, push it down to the quotient, and pull back, you get the union\nof the orbit of `U` under `G`. -/\n@[to_additive\n      \"When you take a set `U` in `α`, push it down to the quotient, and pull back, you get the\n      union of the orbit of `U` under `G`.\"]\ntheorem quotient_preimage_image_eq_union_mul (U : Set α) :\n    letI := orbitRel G α\n    Quotient.mk' ⁻¹' (Quotient.mk' '' U) = ⋃ g : G, (g • ·) '' U := by\n  letI := orbitRel G α\n  set f : α → Quotient (MulAction.orbitRel G α) := Quotient.mk'\n  ext a\n  constructor\n  · rintro ⟨b, hb, hab⟩\n    obtain ⟨g, rfl⟩ := Quotient.exact hab\n    rw [Set.mem_iUnion]\n    exact ⟨g⁻¹, g • a, hb, inv_smul_smul g a⟩\n  · intro hx\n    rw [Set.mem_iUnion] at hx\n    obtain ⟨g, u, hu₁, hu₂⟩ := hx\n    rw [Set.mem_preimage, Set.mem_image]\n    refine ⟨g⁻¹ • a, ?_, by simp only [f, Quotient.eq']; use g⁻¹⟩\n    rw [← hu₂]\n    convert hu₁\n    simp only [inv_smul_smul]\n\n"}
{"name":"MulAction.quotient_preimage_image_eq_union_mul","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nU : Set α\n⊢ Eq (Set.preimage Quotient.mk' (Set.image Quotient.mk' U)) (Set.iUnion fun g => Set.image (fun x => HSMul.hSMul g x) U)","decl":"/-- When you take a set `U` in `α`, push it down to the quotient, and pull back, you get the union\nof the orbit of `U` under `G`. -/\n@[to_additive\n      \"When you take a set `U` in `α`, push it down to the quotient, and pull back, you get the\n      union of the orbit of `U` under `G`.\"]\ntheorem quotient_preimage_image_eq_union_mul (U : Set α) :\n    letI := orbitRel G α\n    Quotient.mk' ⁻¹' (Quotient.mk' '' U) = ⋃ g : G, (g • ·) '' U := by\n  letI := orbitRel G α\n  set f : α → Quotient (MulAction.orbitRel G α) := Quotient.mk'\n  ext a\n  constructor\n  · rintro ⟨b, hb, hab⟩\n    obtain ⟨g, rfl⟩ := Quotient.exact hab\n    rw [Set.mem_iUnion]\n    exact ⟨g⁻¹, g • a, hb, inv_smul_smul g a⟩\n  · intro hx\n    rw [Set.mem_iUnion] at hx\n    obtain ⟨g, u, hu₁, hu₂⟩ := hx\n    rw [Set.mem_preimage, Set.mem_image]\n    refine ⟨g⁻¹ • a, ?_, by simp only [f, Quotient.eq']; use g⁻¹⟩\n    rw [← hu₂]\n    convert hu₁\n    simp only [inv_smul_smul]\n\n"}
{"name":"MulAction.disjoint_image_image_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nU V : Set α\n⊢ Iff (Disjoint (Set.image Quotient.mk' U) (Set.image Quotient.mk' V)) (∀ (x : α), Membership.mem U x → ∀ (g : G), Not (Membership.mem V (HSMul.hSMul g x)))","decl":"@[to_additive]\ntheorem disjoint_image_image_iff {U V : Set α} :\n    letI := orbitRel G α\n    Disjoint (Quotient.mk' '' U) (Quotient.mk' '' V) ↔ ∀ x ∈ U, ∀ g : G, g • x ∉ V := by\n  letI := orbitRel G α\n  set f : α → Quotient (MulAction.orbitRel G α) := Quotient.mk'\n  refine\n    ⟨fun h a a_in_U g g_in_V =>\n      h.le_bot ⟨⟨a, a_in_U, Quotient.sound ⟨g⁻¹, ?_⟩⟩, ⟨g • a, g_in_V, rfl⟩⟩, ?_⟩\n  · simp\n  · intro h\n    rw [Set.disjoint_left]\n    rintro _ ⟨b, hb₁, hb₂⟩ ⟨c, hc₁, hc₂⟩\n    obtain ⟨g, rfl⟩ := Quotient.exact (hc₂.trans hb₂.symm)\n    exact h b hb₁ g hc₁\n\n"}
{"name":"AddAction.disjoint_image_image_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nU V : Set α\n⊢ Iff (Disjoint (Set.image Quotient.mk' U) (Set.image Quotient.mk' V)) (∀ (x : α), Membership.mem U x → ∀ (g : G), Not (Membership.mem V (HVAdd.hVAdd g x)))","decl":"@[to_additive]\ntheorem disjoint_image_image_iff {U V : Set α} :\n    letI := orbitRel G α\n    Disjoint (Quotient.mk' '' U) (Quotient.mk' '' V) ↔ ∀ x ∈ U, ∀ g : G, g • x ∉ V := by\n  letI := orbitRel G α\n  set f : α → Quotient (MulAction.orbitRel G α) := Quotient.mk'\n  refine\n    ⟨fun h a a_in_U g g_in_V =>\n      h.le_bot ⟨⟨a, a_in_U, Quotient.sound ⟨g⁻¹, ?_⟩⟩, ⟨g • a, g_in_V, rfl⟩⟩, ?_⟩\n  · simp\n  · intro h\n    rw [Set.disjoint_left]\n    rintro _ ⟨b, hb₁, hb₂⟩ ⟨c, hc₁, hc₂⟩\n    obtain ⟨g, rfl⟩ := Quotient.exact (hc₂.trans hb₂.symm)\n    exact h b hb₁ g hc₁\n\n"}
{"name":"MulAction.image_inter_image_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nU V : Set α\n⊢ Iff (Eq (Inter.inter (Set.image Quotient.mk' U) (Set.image Quotient.mk' V)) EmptyCollection.emptyCollection) (∀ (x : α), Membership.mem U x → ∀ (g : G), Not (Membership.mem V (HSMul.hSMul g x)))","decl":"@[to_additive]\ntheorem image_inter_image_iff (U V : Set α) :\n    letI := orbitRel G α\n    Quotient.mk' '' U ∩ Quotient.mk' '' V = ∅ ↔ ∀ x ∈ U, ∀ g : G, g • x ∉ V :=\n  Set.disjoint_iff_inter_eq_empty.symm.trans disjoint_image_image_iff\n\n"}
{"name":"AddAction.image_inter_image_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nU V : Set α\n⊢ Iff (Eq (Inter.inter (Set.image Quotient.mk' U) (Set.image Quotient.mk' V)) EmptyCollection.emptyCollection) (∀ (x : α), Membership.mem U x → ∀ (g : G), Not (Membership.mem V (HVAdd.hVAdd g x)))","decl":"@[to_additive]\ntheorem image_inter_image_iff (U V : Set α) :\n    letI := orbitRel G α\n    Quotient.mk' '' U ∩ Quotient.mk' '' V = ∅ ↔ ∀ x ∈ U, ∀ g : G, g • x ∉ V :=\n  Set.disjoint_iff_inter_eq_empty.symm.trans disjoint_image_image_iff\n\n"}
{"name":"MulAction.orbitRel.Quotient.orbit_mk","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : α\n⊢ Eq (MulAction.orbitRel.Quotient.orbit (Quotient.mk'' a)) (MulAction.orbit G a)","decl":"@[to_additive (attr := simp)]\ntheorem orbitRel.Quotient.orbit_mk (a : α) :\n    orbitRel.Quotient.orbit (Quotient.mk'' a : orbitRel.Quotient G α) = MulAction.orbit G a :=\n  rfl\n\n"}
{"name":"AddAction.orbitRel.Quotient.orbit_mk","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : α\n⊢ Eq (AddAction.orbitRel.Quotient.orbit (Quotient.mk'' a)) (AddAction.orbit G a)","decl":"@[to_additive (attr := simp)]\ntheorem orbitRel.Quotient.orbit_mk (a : α) :\n    orbitRel.Quotient.orbit (Quotient.mk'' a : orbitRel.Quotient G α) = MulAction.orbit G a :=\n  rfl\n\n"}
{"name":"AddAction.orbitRel.Quotient.mem_orbit","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : α\nx : AddAction.orbitRel.Quotient G α\n⊢ Iff (Membership.mem x.orbit a) (Eq (Quotient.mk'' a) x)","decl":"@[to_additive]\ntheorem orbitRel.Quotient.mem_orbit {a : α} {x : orbitRel.Quotient G α} :\n    a ∈ x.orbit ↔ Quotient.mk'' a = x := by\n  induction x using Quotient.inductionOn'\n  rw [Quotient.eq'']\n  rfl\n\n"}
{"name":"MulAction.orbitRel.Quotient.mem_orbit","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : α\nx : MulAction.orbitRel.Quotient G α\n⊢ Iff (Membership.mem x.orbit a) (Eq (Quotient.mk'' a) x)","decl":"@[to_additive]\ntheorem orbitRel.Quotient.mem_orbit {a : α} {x : orbitRel.Quotient G α} :\n    a ∈ x.orbit ↔ Quotient.mk'' a = x := by\n  induction x using Quotient.inductionOn'\n  rw [Quotient.eq'']\n  rfl\n\n"}
{"name":"MulAction.orbitRel.Quotient.orbit_eq_orbit_out","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nx : MulAction.orbitRel.Quotient G α\nφ : MulAction.orbitRel.Quotient G α → α\nhφ : Function.RightInverse φ Quotient.mk'\n⊢ Eq x.orbit (MulAction.orbit G (φ x))","decl":"/-- Note that `hφ = Quotient.out_eq'` is a useful choice here. -/\n@[to_additive \"Note that `hφ = Quotient.out_eq'` is a useful choice here.\"]\ntheorem orbitRel.Quotient.orbit_eq_orbit_out (x : orbitRel.Quotient G α)\n    {φ : orbitRel.Quotient G α → α} (hφ : letI := orbitRel G α; RightInverse φ Quotient.mk') :\n    orbitRel.Quotient.orbit x = MulAction.orbit G (φ x) := by\n  conv_lhs => rw [← hφ x]\n  rfl\n\n"}
{"name":"AddAction.orbitRel.Quotient.orbit_eq_orbit_out","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nx : AddAction.orbitRel.Quotient G α\nφ : AddAction.orbitRel.Quotient G α → α\nhφ : Function.RightInverse φ Quotient.mk'\n⊢ Eq x.orbit (AddAction.orbit G (φ x))","decl":"/-- Note that `hφ = Quotient.out_eq'` is a useful choice here. -/\n@[to_additive \"Note that `hφ = Quotient.out_eq'` is a useful choice here.\"]\ntheorem orbitRel.Quotient.orbit_eq_orbit_out (x : orbitRel.Quotient G α)\n    {φ : orbitRel.Quotient G α → α} (hφ : letI := orbitRel G α; RightInverse φ Quotient.mk') :\n    orbitRel.Quotient.orbit x = MulAction.orbit G (φ x) := by\n  conv_lhs => rw [← hφ x]\n  rfl\n\n"}
{"name":"MulAction.orbitRel.Quotient.orbit_injective","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\n⊢ Function.Injective MulAction.orbitRel.Quotient.orbit","decl":"@[to_additive]\nlemma orbitRel.Quotient.orbit_injective :\n    Injective (orbitRel.Quotient.orbit : orbitRel.Quotient G α → Set α) := by\n  intro x y h\n  simp_rw [orbitRel.Quotient.orbit_eq_orbit_out _ Quotient.out_eq', orbit_eq_iff,\n    ← orbitRel_apply] at h\n  simpa [← Quotient.eq''] using h\n\n"}
{"name":"AddAction.orbitRel.Quotient.orbit_injective","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\n⊢ Function.Injective AddAction.orbitRel.Quotient.orbit","decl":"@[to_additive]\nlemma orbitRel.Quotient.orbit_injective :\n    Injective (orbitRel.Quotient.orbit : orbitRel.Quotient G α → Set α) := by\n  intro x y h\n  simp_rw [orbitRel.Quotient.orbit_eq_orbit_out _ Quotient.out_eq', orbit_eq_iff,\n    ← orbitRel_apply] at h\n  simpa [← Quotient.eq''] using h\n\n"}
{"name":"AddAction.orbitRel.Quotient.orbit_inj","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nx y : AddAction.orbitRel.Quotient G α\n⊢ Iff (Eq x.orbit y.orbit) (Eq x y)","decl":"@[to_additive (attr := simp)]\nlemma orbitRel.Quotient.orbit_inj {x y : orbitRel.Quotient G α} : x.orbit = y.orbit ↔ x = y :=\n  orbitRel.Quotient.orbit_injective.eq_iff\n\n"}
{"name":"MulAction.orbitRel.Quotient.orbit_inj","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nx y : MulAction.orbitRel.Quotient G α\n⊢ Iff (Eq x.orbit y.orbit) (Eq x y)","decl":"@[to_additive (attr := simp)]\nlemma orbitRel.Quotient.orbit_inj {x y : orbitRel.Quotient G α} : x.orbit = y.orbit ↔ x = y :=\n  orbitRel.Quotient.orbit_injective.eq_iff\n\n"}
{"name":"MulAction.orbitRel.quotient_eq_of_quotient_subgroup_eq","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nH : Subgroup G\na b : α\nh : Eq (Quotient.mk (MulAction.orbitRel (Subtype fun x => Membership.mem H x) α) a) (Quotient.mk (MulAction.orbitRel (Subtype fun x => Membership.mem H x) α) b)\n⊢ Eq (Quotient.mk (MulAction.orbitRel G α) a) (Quotient.mk (MulAction.orbitRel G α) b)","decl":"@[to_additive]\nlemma orbitRel.quotient_eq_of_quotient_subgroup_eq {H : Subgroup G} {a b : α}\n    (h : (⟦a⟧ : orbitRel.Quotient H α) = ⟦b⟧) : (⟦a⟧ : orbitRel.Quotient G α) = ⟦b⟧ := by\n  rw [@Quotient.eq] at h ⊢\n  exact mem_orbit_of_mem_orbit_subgroup h\n\n"}
{"name":"AddAction.orbitRel.quotient_eq_of_quotient_addSubgroup_eq","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nH : AddSubgroup G\na b : α\nh : Eq (Quotient.mk (AddAction.orbitRel (Subtype fun x => Membership.mem H x) α) a) (Quotient.mk (AddAction.orbitRel (Subtype fun x => Membership.mem H x) α) b)\n⊢ Eq (Quotient.mk (AddAction.orbitRel G α) a) (Quotient.mk (AddAction.orbitRel G α) b)","decl":"@[to_additive]\nlemma orbitRel.quotient_eq_of_quotient_subgroup_eq {H : Subgroup G} {a b : α}\n    (h : (⟦a⟧ : orbitRel.Quotient H α) = ⟦b⟧) : (⟦a⟧ : orbitRel.Quotient G α) = ⟦b⟧ := by\n  rw [@Quotient.eq] at h ⊢\n  exact mem_orbit_of_mem_orbit_subgroup h\n\n"}
{"name":"MulAction.orbitRel.quotient_eq_of_quotient_subgroup_eq'","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nH : Subgroup G\na b : α\nh : Eq (Quotient.mk'' a) (Quotient.mk'' b)\n⊢ Eq (Quotient.mk'' a) (Quotient.mk'' b)","decl":"@[to_additive]\nlemma orbitRel.quotient_eq_of_quotient_subgroup_eq' {H : Subgroup G} {a b : α}\n    (h : (Quotient.mk'' a : orbitRel.Quotient H α) = Quotient.mk'' b) :\n    (Quotient.mk'' a : orbitRel.Quotient G α) = Quotient.mk'' b :=\n  orbitRel.quotient_eq_of_quotient_subgroup_eq h\n\n"}
{"name":"AddAction.orbitRel.quotient_eq_of_quotient_addSubgroup_eq'","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nH : AddSubgroup G\na b : α\nh : Eq (Quotient.mk'' a) (Quotient.mk'' b)\n⊢ Eq (Quotient.mk'' a) (Quotient.mk'' b)","decl":"@[to_additive]\nlemma orbitRel.quotient_eq_of_quotient_subgroup_eq' {H : Subgroup G} {a b : α}\n    (h : (Quotient.mk'' a : orbitRel.Quotient H α) = Quotient.mk'' b) :\n    (Quotient.mk'' a : orbitRel.Quotient G α) = Quotient.mk'' b :=\n  orbitRel.quotient_eq_of_quotient_subgroup_eq h\n\n"}
{"name":"MulAction.orbitRel.Quotient.orbit_nonempty","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nx : MulAction.orbitRel.Quotient G α\n⊢ x.orbit.Nonempty","decl":"@[to_additive]\nnonrec lemma orbitRel.Quotient.orbit_nonempty (x : orbitRel.Quotient G α) :\n    Set.Nonempty x.orbit := by\n  rw [orbitRel.Quotient.orbit_eq_orbit_out x Quotient.out_eq']\n  exact orbit_nonempty _\n\n"}
{"name":"AddAction.orbitRel.Quotient.orbit_nonempty","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nx : AddAction.orbitRel.Quotient G α\n⊢ x.orbit.Nonempty","decl":"@[to_additive]\nnonrec lemma orbitRel.Quotient.orbit_nonempty (x : orbitRel.Quotient G α) :\n    Set.Nonempty x.orbit := by\n  rw [orbitRel.Quotient.orbit_eq_orbit_out x Quotient.out_eq']\n  exact orbit_nonempty _\n\n"}
{"name":"AddAction.orbitRel.Quotient.mapsTo_vadd_orbit","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng : G\nx : AddAction.orbitRel.Quotient G α\n⊢ Set.MapsTo (fun x => HVAdd.hVAdd g x) x.orbit x.orbit","decl":"@[to_additive]\nnonrec lemma orbitRel.Quotient.mapsTo_smul_orbit (g : G) (x : orbitRel.Quotient G α) :\n    Set.MapsTo (g • ·) x.orbit x.orbit := by\n  rw [orbitRel.Quotient.orbit_eq_orbit_out x Quotient.out_eq']\n  exact mapsTo_smul_orbit g x.out\n\n"}
{"name":"MulAction.orbitRel.Quotient.mapsTo_smul_orbit","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng : G\nx : MulAction.orbitRel.Quotient G α\n⊢ Set.MapsTo (fun x => HSMul.hSMul g x) x.orbit x.orbit","decl":"@[to_additive]\nnonrec lemma orbitRel.Quotient.mapsTo_smul_orbit (g : G) (x : orbitRel.Quotient G α) :\n    Set.MapsTo (g • ·) x.orbit x.orbit := by\n  rw [orbitRel.Quotient.orbit_eq_orbit_out x Quotient.out_eq']\n  exact mapsTo_smul_orbit g x.out\n\n"}
{"name":"MulAction.orbitRel.Quotient.orbit.coe_smul","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng : G\nx : MulAction.orbitRel.Quotient G α\na : ↑x.orbit\n⊢ Eq (↑(HSMul.hSMul g a)) (HSMul.hSMul g ↑a)","decl":"@[to_additive (attr := simp)]\nlemma orbitRel.Quotient.orbit.coe_smul {g : G} {x : orbitRel.Quotient G α} {a : x.orbit} :\n    ↑(g • a) = g • (a : α) :=\n  rfl\n\n"}
{"name":"AddAction.orbitRel.Quotient.orbit.coe_vadd","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng : G\nx : AddAction.orbitRel.Quotient G α\na : ↑x.orbit\n⊢ Eq (↑(HVAdd.hVAdd g a)) (HVAdd.hVAdd g ↑a)","decl":"@[to_additive (attr := simp)]\nlemma orbitRel.Quotient.orbit.coe_smul {g : G} {x : orbitRel.Quotient G α} {a : x.orbit} :\n    ↑(g • a) = g • (a : α) :=\n  rfl\n\n"}
{"name":"MulAction.orbitRel.Quotient.mem_subgroup_orbit_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nH : Subgroup G\nx : MulAction.orbitRel.Quotient G α\na b : ↑x.orbit\n⊢ Iff (Membership.mem (MulAction.orbit (Subtype fun x => Membership.mem H x) ↑b) ↑a) (Membership.mem (MulAction.orbit (Subtype fun x => Membership.mem H x) b) a)","decl":"@[to_additive (attr := norm_cast, simp)]\nlemma orbitRel.Quotient.mem_subgroup_orbit_iff {H : Subgroup G} {x : orbitRel.Quotient G α}\n    {a b : x.orbit} : (a : α) ∈ MulAction.orbit H (b : α) ↔ a ∈ MulAction.orbit H b := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rcases h with ⟨g, h⟩\n    dsimp at h\n    erw [← orbit.coe_smul, ← Subtype.ext_iff] at h\n    subst h\n    exact MulAction.mem_orbit _ g\n  · rcases h with ⟨g, rfl⟩\n    exact MulAction.mem_orbit _ g\n\n"}
{"name":"AddAction.orbitRel.Quotient.mem_addSubgroup_orbit_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nH : AddSubgroup G\nx : AddAction.orbitRel.Quotient G α\na b : ↑x.orbit\n⊢ Iff (Membership.mem (AddAction.orbit (Subtype fun x => Membership.mem H x) ↑b) ↑a) (Membership.mem (AddAction.orbit (Subtype fun x => Membership.mem H x) b) a)","decl":"@[to_additive (attr := norm_cast, simp)]\nlemma orbitRel.Quotient.mem_subgroup_orbit_iff {H : Subgroup G} {x : orbitRel.Quotient G α}\n    {a b : x.orbit} : (a : α) ∈ MulAction.orbit H (b : α) ↔ a ∈ MulAction.orbit H b := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rcases h with ⟨g, h⟩\n    dsimp at h\n    erw [← orbit.coe_smul, ← Subtype.ext_iff] at h\n    subst h\n    exact MulAction.mem_orbit _ g\n  · rcases h with ⟨g, rfl⟩\n    exact MulAction.mem_orbit _ g\n\n"}
{"name":"AddAction.orbitRel.Quotient.addSubgroup_quotient_eq_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nH : AddSubgroup G\nx : AddAction.orbitRel.Quotient G α\na b : ↑x.orbit\n⊢ Iff (Eq (Quotient.mk (AddAction.orbitRel (Subtype fun x => Membership.mem H x) ↑x.orbit) a) (Quotient.mk (AddAction.orbitRel (Subtype fun x => Membership.mem H x) ↑x.orbit) b)) (Eq (Quotient.mk (AddAction.orbitRel (Subtype fun x => Membership.mem H x) α) ↑a) (Quotient.mk (AddAction.orbitRel (Subtype fun x => Membership.mem H x) α) ↑b))","decl":"@[to_additive]\nlemma orbitRel.Quotient.subgroup_quotient_eq_iff {H : Subgroup G} {x : orbitRel.Quotient G α}\n    {a b : x.orbit} : (⟦a⟧ : orbitRel.Quotient H x.orbit) = ⟦b⟧ ↔\n      (⟦↑a⟧ : orbitRel.Quotient H α) = ⟦↑b⟧ := by\n  simp_rw [← @Quotient.mk''_eq_mk, Quotient.eq'']\n  exact orbitRel.Quotient.mem_subgroup_orbit_iff.symm\n\n"}
{"name":"MulAction.orbitRel.Quotient.subgroup_quotient_eq_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nH : Subgroup G\nx : MulAction.orbitRel.Quotient G α\na b : ↑x.orbit\n⊢ Iff (Eq (Quotient.mk (MulAction.orbitRel (Subtype fun x => Membership.mem H x) ↑x.orbit) a) (Quotient.mk (MulAction.orbitRel (Subtype fun x => Membership.mem H x) ↑x.orbit) b)) (Eq (Quotient.mk (MulAction.orbitRel (Subtype fun x => Membership.mem H x) α) ↑a) (Quotient.mk (MulAction.orbitRel (Subtype fun x => Membership.mem H x) α) ↑b))","decl":"@[to_additive]\nlemma orbitRel.Quotient.subgroup_quotient_eq_iff {H : Subgroup G} {x : orbitRel.Quotient G α}\n    {a b : x.orbit} : (⟦a⟧ : orbitRel.Quotient H x.orbit) = ⟦b⟧ ↔\n      (⟦↑a⟧ : orbitRel.Quotient H α) = ⟦↑b⟧ := by\n  simp_rw [← @Quotient.mk''_eq_mk, Quotient.eq'']\n  exact orbitRel.Quotient.mem_subgroup_orbit_iff.symm\n\n"}
{"name":"AddAction.orbitRel.Quotient.mem_addSubgroup_orbit_iff'","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nH : AddSubgroup G\nx : AddAction.orbitRel.Quotient G α\na b : ↑x.orbit\nc : α\nh : Eq (Quotient.mk (AddAction.orbitRel (Subtype fun x => Membership.mem H x) ↑x.orbit) a) (Quotient.mk (AddAction.orbitRel (Subtype fun x => Membership.mem H x) ↑x.orbit) b)\n⊢ Iff (Membership.mem (AddAction.orbit (Subtype fun x => Membership.mem H x) c) ↑a) (Membership.mem (AddAction.orbit (Subtype fun x => Membership.mem H x) c) ↑b)","decl":"@[to_additive]\nlemma orbitRel.Quotient.mem_subgroup_orbit_iff' {H : Subgroup G} {x : orbitRel.Quotient G α}\n    {a b : x.orbit} {c : α} (h : (⟦a⟧ : orbitRel.Quotient H x.orbit) = ⟦b⟧) :\n    (a : α) ∈ MulAction.orbit H c ↔ (b : α) ∈ MulAction.orbit H c := by\n  simp_rw [mem_orbit_symm (a₂ := c)]\n  convert Iff.rfl using 2\n  rw [orbit_eq_iff]\n  suffices hb : ↑b ∈ orbitRel.Quotient.orbit (⟦a⟧ : orbitRel.Quotient H x.orbit) by\n    rw [orbitRel.Quotient.orbit_eq_orbit_out (⟦a⟧ : orbitRel.Quotient H x.orbit) Quotient.out_eq']\n       at hb\n    rw [orbitRel.Quotient.mem_subgroup_orbit_iff]\n    convert hb using 1\n    rw [orbit_eq_iff, ← orbitRel_apply, ← Quotient.eq'', Quotient.out_eq', @Quotient.mk''_eq_mk]\n  rw [orbitRel.Quotient.mem_orbit, h, @Quotient.mk''_eq_mk]\n\n"}
{"name":"MulAction.orbitRel.Quotient.mem_subgroup_orbit_iff'","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nH : Subgroup G\nx : MulAction.orbitRel.Quotient G α\na b : ↑x.orbit\nc : α\nh : Eq (Quotient.mk (MulAction.orbitRel (Subtype fun x => Membership.mem H x) ↑x.orbit) a) (Quotient.mk (MulAction.orbitRel (Subtype fun x => Membership.mem H x) ↑x.orbit) b)\n⊢ Iff (Membership.mem (MulAction.orbit (Subtype fun x => Membership.mem H x) c) ↑a) (Membership.mem (MulAction.orbit (Subtype fun x => Membership.mem H x) c) ↑b)","decl":"@[to_additive]\nlemma orbitRel.Quotient.mem_subgroup_orbit_iff' {H : Subgroup G} {x : orbitRel.Quotient G α}\n    {a b : x.orbit} {c : α} (h : (⟦a⟧ : orbitRel.Quotient H x.orbit) = ⟦b⟧) :\n    (a : α) ∈ MulAction.orbit H c ↔ (b : α) ∈ MulAction.orbit H c := by\n  simp_rw [mem_orbit_symm (a₂ := c)]\n  convert Iff.rfl using 2\n  rw [orbit_eq_iff]\n  suffices hb : ↑b ∈ orbitRel.Quotient.orbit (⟦a⟧ : orbitRel.Quotient H x.orbit) by\n    rw [orbitRel.Quotient.orbit_eq_orbit_out (⟦a⟧ : orbitRel.Quotient H x.orbit) Quotient.out_eq']\n       at hb\n    rw [orbitRel.Quotient.mem_subgroup_orbit_iff]\n    convert hb using 1\n    rw [orbit_eq_iff, ← orbitRel_apply, ← Quotient.eq'', Quotient.out_eq', @Quotient.mk''_eq_mk]\n  rw [orbitRel.Quotient.mem_orbit, h, @Quotient.mk''_eq_mk]\n\n"}
{"name":"MulAction.univ_eq_iUnion_orbit","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\n⊢ Eq Set.univ (Set.iUnion fun x => x.orbit)","decl":"/-- Decomposition of a type `X` as a disjoint union of its orbits under a group action.\nPhrased as a set union. See `MulAction.selfEquivSigmaOrbits` for the type isomorphism. -/\n@[to_additive \"Decomposition of a type `X` as a disjoint union of its orbits under an additive group\naction. Phrased as a set union. See `AddAction.selfEquivSigmaOrbits` for the type isomorphism.\"]\nlemma univ_eq_iUnion_orbit :\n    Set.univ (α := α) = ⋃ x : Ω, x.orbit := by\n  ext x\n  simp only [Set.mem_univ, Set.mem_iUnion, true_iff]\n  exact ⟨Quotient.mk'' x, by simp⟩\n\n"}
{"name":"AddAction.univ_eq_iUnion_orbit","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\n⊢ Eq Set.univ (Set.iUnion fun x => x.orbit)","decl":"/-- Decomposition of a type `X` as a disjoint union of its orbits under a group action.\nPhrased as a set union. See `MulAction.selfEquivSigmaOrbits` for the type isomorphism. -/\n@[to_additive \"Decomposition of a type `X` as a disjoint union of its orbits under an additive group\naction. Phrased as a set union. See `AddAction.selfEquivSigmaOrbits` for the type isomorphism.\"]\nlemma univ_eq_iUnion_orbit :\n    Set.univ (α := α) = ⋃ x : Ω, x.orbit := by\n  ext x\n  simp only [Set.mem_univ, Set.mem_iUnion, true_iff]\n  exact ⟨Quotient.mk'' x, by simp⟩\n\n"}
{"name":"AddAction.mem_stabilizer_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : α\ng : G\n⊢ Iff (Membership.mem (AddAction.stabilizer G a) g) (Eq (HVAdd.hVAdd g a) a)","decl":"@[to_additive (attr := simp)]\ntheorem mem_stabilizer_iff {a : α} {g : G} : g ∈ stabilizer G a ↔ g • a = a :=\n  Iff.rfl\n\n"}
{"name":"MulAction.mem_stabilizer_iff","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : α\ng : G\n⊢ Iff (Membership.mem (MulAction.stabilizer G a) g) (Eq (HSMul.hSMul g a) a)","decl":"@[to_additive (attr := simp)]\ntheorem mem_stabilizer_iff {a : α} {g : G} : g ∈ stabilizer G a ↔ g • a = a :=\n  Iff.rfl\n\n"}
{"name":"AddAction.le_stabilizer_vadd_left","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : AddGroup G\ninst✝³ : AddAction G α\ninst✝² : AddAction G β\ninst✝¹ : VAdd α β\ninst✝ : VAddAssocClass G α β\na : α\nb : β\n⊢ LE.le (AddAction.stabilizer G a) (AddAction.stabilizer G (HVAdd.hVAdd a b))","decl":"@[to_additive]\nlemma le_stabilizer_smul_left [SMul α β] [IsScalarTower G α β] (a : α) (b : β) :\n    stabilizer G a ≤ stabilizer G (a • b) := by\n  simp_rw [SetLike.le_def, mem_stabilizer_iff, ← smul_assoc]; rintro a h; rw [h]\n\n-- This lemma does not need `MulAction G α`, only `SMul G α`.\n-- We use `G'` instead of `G` to locally reduce the typeclass assumptions.\n"}
{"name":"MulAction.le_stabilizer_smul_left","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : Group G\ninst✝³ : MulAction G α\ninst✝² : MulAction G β\ninst✝¹ : SMul α β\ninst✝ : IsScalarTower G α β\na : α\nb : β\n⊢ LE.le (MulAction.stabilizer G a) (MulAction.stabilizer G (HSMul.hSMul a b))","decl":"@[to_additive]\nlemma le_stabilizer_smul_left [SMul α β] [IsScalarTower G α β] (a : α) (b : β) :\n    stabilizer G a ≤ stabilizer G (a • b) := by\n  simp_rw [SetLike.le_def, mem_stabilizer_iff, ← smul_assoc]; rintro a h; rw [h]\n\n-- This lemma does not need `MulAction G α`, only `SMul G α`.\n-- We use `G'` instead of `G` to locally reduce the typeclass assumptions.\n"}
{"name":"MulAction.le_stabilizer_smul_right","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nG' : Type u_4\ninst✝³ : Group G'\ninst✝² : SMul α β\ninst✝¹ : MulAction G' β\ninst✝ : SMulCommClass G' α β\na : α\nb : β\n⊢ LE.le (MulAction.stabilizer G' b) (MulAction.stabilizer G' (HSMul.hSMul a b))","decl":"@[to_additive]\nlemma le_stabilizer_smul_right {G'} [Group G'] [SMul α β] [MulAction G' β]\n    [SMulCommClass G' α β] (a : α) (b : β) :\n    stabilizer G' b ≤ stabilizer G' (a • b) := by\n  simp_rw [SetLike.le_def, mem_stabilizer_iff, smul_comm]; rintro a h; rw [h]\n\n"}
{"name":"AddAction.le_stabilizer_vadd_right","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\nG' : Type u_4\ninst✝³ : AddGroup G'\ninst✝² : VAdd α β\ninst✝¹ : AddAction G' β\ninst✝ : VAddCommClass G' α β\na : α\nb : β\n⊢ LE.le (AddAction.stabilizer G' b) (AddAction.stabilizer G' (HVAdd.hVAdd a b))","decl":"@[to_additive]\nlemma le_stabilizer_smul_right {G'} [Group G'] [SMul α β] [MulAction G' β]\n    [SMulCommClass G' α β] (a : α) (b : β) :\n    stabilizer G' b ≤ stabilizer G' (a • b) := by\n  simp_rw [SetLike.le_def, mem_stabilizer_iff, smul_comm]; rintro a h; rw [h]\n\n"}
{"name":"AddAction.stabilizer_vadd_eq_left","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : AddGroup G\ninst✝³ : AddAction G α\ninst✝² : AddAction G β\ninst✝¹ : VAdd α β\ninst✝ : VAddAssocClass G α β\na : α\nb : β\nh : Function.Injective fun x => HVAdd.hVAdd x b\n⊢ Eq (AddAction.stabilizer G (HVAdd.hVAdd a b)) (AddAction.stabilizer G a)","decl":"@[to_additive (attr := simp)]\nlemma stabilizer_smul_eq_left [SMul α β] [IsScalarTower G α β] (a : α) (b : β)\n    (h : Injective (· • b : α → β)) : stabilizer G (a • b) = stabilizer G a := by\n  refine (le_stabilizer_smul_left _ _).antisymm' fun a ha ↦ ?_\n  simpa only [mem_stabilizer_iff, ← smul_assoc, h.eq_iff] using ha\n\n"}
{"name":"MulAction.stabilizer_smul_eq_left","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : Group G\ninst✝³ : MulAction G α\ninst✝² : MulAction G β\ninst✝¹ : SMul α β\ninst✝ : IsScalarTower G α β\na : α\nb : β\nh : Function.Injective fun x => HSMul.hSMul x b\n⊢ Eq (MulAction.stabilizer G (HSMul.hSMul a b)) (MulAction.stabilizer G a)","decl":"@[to_additive (attr := simp)]\nlemma stabilizer_smul_eq_left [SMul α β] [IsScalarTower G α β] (a : α) (b : β)\n    (h : Injective (· • b : α → β)) : stabilizer G (a • b) = stabilizer G a := by\n  refine (le_stabilizer_smul_left _ _).antisymm' fun a ha ↦ ?_\n  simpa only [mem_stabilizer_iff, ← smul_assoc, h.eq_iff] using ha\n\n"}
{"name":"AddAction.stabilizer_vadd_eq_right","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nβ : Type u_3\ninst✝⁴ : AddGroup G\ninst✝³ : AddAction G β\nα : Type u_4\ninst✝² : AddGroup α\ninst✝¹ : AddAction α β\ninst✝ : VAddCommClass G α β\na : α\nb : β\n⊢ Eq (AddAction.stabilizer G (HVAdd.hVAdd a b)) (AddAction.stabilizer G b)","decl":"@[to_additive (attr := simp)]\nlemma stabilizer_smul_eq_right {α} [Group α] [MulAction α β] [SMulCommClass G α β] (a : α) (b : β) :\n    stabilizer G (a • b) = stabilizer G b :=\n  (le_stabilizer_smul_right _ _).antisymm' <| (le_stabilizer_smul_right a⁻¹ _).trans_eq <| by\n    rw [inv_smul_smul]\n\n"}
{"name":"MulAction.stabilizer_smul_eq_right","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nβ : Type u_3\ninst✝⁴ : Group G\ninst✝³ : MulAction G β\nα : Type u_4\ninst✝² : Group α\ninst✝¹ : MulAction α β\ninst✝ : SMulCommClass G α β\na : α\nb : β\n⊢ Eq (MulAction.stabilizer G (HSMul.hSMul a b)) (MulAction.stabilizer G b)","decl":"@[to_additive (attr := simp)]\nlemma stabilizer_smul_eq_right {α} [Group α] [MulAction α β] [SMulCommClass G α β] (a : α) (b : β) :\n    stabilizer G (a • b) = stabilizer G b :=\n  (le_stabilizer_smul_right _ _).antisymm' <| (le_stabilizer_smul_right a⁻¹ _).trans_eq <| by\n    rw [inv_smul_smul]\n\n"}
{"name":"MulAction.stabilizer_mul_eq_left","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝³ : Group G\ninst✝² : MulAction G α\ninst✝¹ : Group α\ninst✝ : IsScalarTower G α α\na b : α\n⊢ Eq (MulAction.stabilizer G (HMul.hMul a b)) (MulAction.stabilizer G a)","decl":"@[to_additive (attr := simp)]\nlemma stabilizer_mul_eq_left [Group α] [IsScalarTower G α α] (a b : α)  :\n    stabilizer G (a * b) = stabilizer G a := stabilizer_smul_eq_left a _ <| mul_left_injective _\n\n"}
{"name":"AddAction.stabilizer_add_eq_left","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝³ : AddGroup G\ninst✝² : AddAction G α\ninst✝¹ : AddGroup α\ninst✝ : VAddAssocClass G α α\na b : α\n⊢ Eq (AddAction.stabilizer G (HAdd.hAdd a b)) (AddAction.stabilizer G a)","decl":"@[to_additive (attr := simp)]\nlemma stabilizer_mul_eq_left [Group α] [IsScalarTower G α α] (a b : α)  :\n    stabilizer G (a * b) = stabilizer G a := stabilizer_smul_eq_left a _ <| mul_left_injective _\n\n"}
{"name":"AddAction.stabilizer_add_eq_right","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝³ : AddGroup G\ninst✝² : AddAction G α\ninst✝¹ : AddGroup α\ninst✝ : VAddCommClass G α α\na b : α\n⊢ Eq (AddAction.stabilizer G (HAdd.hAdd a b)) (AddAction.stabilizer G b)","decl":"@[to_additive (attr := simp)]\nlemma stabilizer_mul_eq_right [Group α] [SMulCommClass G α α] (a b : α) :\n    stabilizer G (a * b) = stabilizer G b := stabilizer_smul_eq_right a _\n\n"}
{"name":"MulAction.stabilizer_mul_eq_right","module":"Mathlib.GroupTheory.GroupAction.Defs","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝³ : Group G\ninst✝² : MulAction G α\ninst✝¹ : Group α\ninst✝ : SMulCommClass G α α\na b : α\n⊢ Eq (MulAction.stabilizer G (HMul.hMul a b)) (MulAction.stabilizer G b)","decl":"@[to_additive (attr := simp)]\nlemma stabilizer_mul_eq_right [Group α] [SMulCommClass G α α] (a b : α) :\n    stabilizer G (a * b) = stabilizer G b := stabilizer_smul_eq_right a _\n\n"}
