{"name":"ProbabilityTheory.Kernel.iIndepSets_zero_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nπ : ι → Set (Set Ω)\n⊢ ProbabilityTheory.Kernel.iIndepSets π κ 0","decl":"@[simp] lemma iIndepSets_zero_right : iIndepSets π κ 0 := by simp [iIndepSets]\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSets_zero_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\ns1 s2 : Set (Set Ω)\n⊢ ProbabilityTheory.Kernel.IndepSets s1 s2 κ 0","decl":"@[simp] lemma indepSets_zero_right : IndepSets s1 s2 κ 0 := by simp [IndepSets]\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSets_zero_left","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure α\ns1 s2 : Set (Set Ω)\n⊢ ProbabilityTheory.Kernel.IndepSets s1 s2 0 μ","decl":"@[simp] lemma indepSets_zero_left : IndepSets s1 s2 (0 : Kernel α Ω) μ := by simp [IndepSets]\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndep_zero_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\nm : ι → MeasurableSpace Ω\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\n⊢ ProbabilityTheory.Kernel.iIndep m κ 0","decl":"@[simp] lemma iIndep_zero_right : iIndep m κ 0 := by simp [iIndep]\n\n"}
{"name":"ProbabilityTheory.Kernel.indep_zero_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\nm₁ m₂ _mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\n⊢ ProbabilityTheory.Kernel.Indep m₁ m₂ κ 0","decl":"@[simp] lemma indep_zero_right {m₁ m₂ : MeasurableSpace Ω} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} : Indep m₁ m₂ κ 0 := by simp [Indep]\n\n"}
{"name":"ProbabilityTheory.Kernel.indep_zero_left","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nm₁ m₂ _mΩ : MeasurableSpace Ω\n⊢ ProbabilityTheory.Kernel.Indep m₁ m₂ 0 μ","decl":"@[simp] lemma indep_zero_left {m₁ m₂ : MeasurableSpace Ω} {_mΩ : MeasurableSpace Ω} :\n    Indep m₁ m₂ (0 : Kernel α Ω) μ  := by simp [Indep]\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSet_zero_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\ns : ι → Set Ω\n⊢ ProbabilityTheory.Kernel.iIndepSet s κ 0","decl":"@[simp] lemma iIndepSet_zero_right : iIndepSet s κ 0 := by simp [iIndepSet]\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSet_zero_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\ns t : Set Ω\n⊢ ProbabilityTheory.Kernel.IndepSet s t κ 0","decl":"@[simp] lemma indepSet_zero_right {s t : Set Ω} : IndepSet s t κ 0 := by simp [IndepSet]\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSet_zero_left","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure α\ns t : Set Ω\n⊢ ProbabilityTheory.Kernel.IndepSet s t 0 μ","decl":"@[simp] lemma indepSet_zero_left {s t : Set Ω} : IndepSet s t (0 : Kernel α Ω) μ := by\n  simp [IndepSet]\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun_zero_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nβ : ι → Type u_5\nm : (x : ι) → MeasurableSpace (β x)\nf : (x : ι) → Ω → β x\n⊢ ProbabilityTheory.Kernel.iIndepFun m f κ 0","decl":"@[simp] lemma iIndepFun_zero_right {β : ι → Type*} {m : ∀ x : ι, MeasurableSpace (β x)}\n    {f : ∀ x : ι, Ω → β x} : iIndepFun m f κ 0 := by simp [iIndepFun]\n\n"}
{"name":"ProbabilityTheory.Kernel.indepFun_zero_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nβ : Type u_5\nγ : Type u_6\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nf : Ω → β\ng : Ω → γ\n⊢ ProbabilityTheory.Kernel.IndepFun f g κ 0","decl":"@[simp] lemma indepFun_zero_right {β γ} [MeasurableSpace β] [MeasurableSpace γ]\n    {f : Ω → β} {g : Ω → γ} : IndepFun f g κ 0 := by simp [IndepFun]\n\n"}
{"name":"ProbabilityTheory.Kernel.indepFun_zero_left","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure α\nβ : Type u_5\nγ : Type u_6\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nf : Ω → β\ng : Ω → γ\n⊢ ProbabilityTheory.Kernel.IndepFun f g 0 μ","decl":"@[simp] lemma indepFun_zero_left {β γ} [MeasurableSpace β] [MeasurableSpace γ]\n    {f : Ω → β} {g : Ω → γ} : IndepFun f g (0 : Kernel α Ω) μ := by simp [IndepFun]\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSets_congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nπ : ι → Set (Set Ω)\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\n⊢ Iff (ProbabilityTheory.Kernel.iIndepSets π κ μ) (ProbabilityTheory.Kernel.iIndepSets π η μ)","decl":"lemma iIndepSets_congr (h : κ =ᵐ[μ] η) : iIndepSets π κ μ ↔ iIndepSets π η μ := by\n  peel 3\n  refine ⟨fun h' ↦ ?_, fun h' ↦ ?_⟩ <;>\n  · filter_upwards [h, h'] with a ha h'a\n    simpa [ha] using h'a\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSets.congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nπ : ι → Set (Set Ω)\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\na✝ : ProbabilityTheory.Kernel.iIndepSets π κ μ\n⊢ ProbabilityTheory.Kernel.iIndepSets π η μ","decl":"alias ⟨iIndepSets.congr, _⟩ := iIndepSets_congr\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSets_congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns1 s2 : Set (Set Ω)\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\n⊢ Iff (ProbabilityTheory.Kernel.IndepSets s1 s2 κ μ) (ProbabilityTheory.Kernel.IndepSets s1 s2 η μ)","decl":"lemma indepSets_congr (h : κ =ᵐ[μ] η) : IndepSets s1 s2 κ μ ↔ IndepSets s1 s2 η μ := by\n  peel 4\n  refine ⟨fun h' ↦ ?_, fun h' ↦ ?_⟩ <;>\n  · filter_upwards [h, h'] with a ha h'a\n    simpa [ha] using h'a\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSets.congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns1 s2 : Set (Set Ω)\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\na✝ : ProbabilityTheory.Kernel.IndepSets s1 s2 κ μ\n⊢ ProbabilityTheory.Kernel.IndepSets s1 s2 η μ","decl":"alias ⟨IndepSets.congr, _⟩ := indepSets_congr\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndep_congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\nm : ι → MeasurableSpace Ω\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\n⊢ Iff (ProbabilityTheory.Kernel.iIndep m κ μ) (ProbabilityTheory.Kernel.iIndep m η μ)","decl":"lemma iIndep_congr (h : κ =ᵐ[μ] η) : iIndep m κ μ ↔ iIndep m η μ :=\n  iIndepSets_congr h\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndep.congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\nm : ι → MeasurableSpace Ω\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\na✝ : ProbabilityTheory.Kernel.iIndep m κ μ\n⊢ ProbabilityTheory.Kernel.iIndep m η μ","decl":"alias ⟨iIndep.congr, _⟩ := iIndep_congr\n\n"}
{"name":"ProbabilityTheory.Kernel.indep_congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nm₁ m₂ _mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\n⊢ Iff (ProbabilityTheory.Kernel.Indep m₁ m₂ κ μ) (ProbabilityTheory.Kernel.Indep m₁ m₂ η μ)","decl":"lemma indep_congr {m₁ m₂ : MeasurableSpace Ω} {_mΩ : MeasurableSpace Ω}\n    {κ η : Kernel α Ω} (h : κ =ᵐ[μ] η) : Indep m₁ m₂ κ μ ↔ Indep m₁ m₂ η μ :=\n  indepSets_congr h\n\n"}
{"name":"ProbabilityTheory.Kernel.Indep.congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nm₁ m₂ _mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\na✝ : ProbabilityTheory.Kernel.Indep m₁ m₂ κ μ\n⊢ ProbabilityTheory.Kernel.Indep m₁ m₂ η μ","decl":"alias ⟨Indep.congr, _⟩ := indep_congr\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSet_congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns : ι → Set Ω\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\n⊢ Iff (ProbabilityTheory.Kernel.iIndepSet s κ μ) (ProbabilityTheory.Kernel.iIndepSet s η μ)","decl":"lemma iIndepSet_congr (h : κ =ᵐ[μ] η) : iIndepSet s κ μ ↔ iIndepSet s η μ :=\n  iIndep_congr h\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSet.congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns : ι → Set Ω\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\na✝ : ProbabilityTheory.Kernel.iIndepSet s κ μ\n⊢ ProbabilityTheory.Kernel.iIndepSet s η μ","decl":"alias ⟨iIndepSet.congr, _⟩ := iIndepSet_congr\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSet_congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns t : Set Ω\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\n⊢ Iff (ProbabilityTheory.Kernel.IndepSet s t κ μ) (ProbabilityTheory.Kernel.IndepSet s t η μ)","decl":"lemma indepSet_congr {s t : Set Ω} (h : κ =ᵐ[μ] η) : IndepSet s t κ μ ↔ IndepSet s t η μ :=\n  indep_congr h\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSet.congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns t : Set Ω\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\na✝ : ProbabilityTheory.Kernel.IndepSet s t κ μ\n⊢ ProbabilityTheory.Kernel.IndepSet s t η μ","decl":"alias ⟨indepSet.congr, _⟩ := indepSet_congr\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun_congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : ι → Type u_5\nm : (x : ι) → MeasurableSpace (β x)\nf : (x : ι) → Ω → β x\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\n⊢ Iff (ProbabilityTheory.Kernel.iIndepFun m f κ μ) (ProbabilityTheory.Kernel.iIndepFun m f η μ)","decl":"lemma iIndepFun_congr {β : ι → Type*} {m : ∀ x : ι, MeasurableSpace (β x)}\n    {f : ∀ x : ι, Ω → β x} (h : κ =ᵐ[μ] η) : iIndepFun m f κ μ ↔ iIndepFun m f η μ :=\n  iIndep_congr h\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : ι → Type u_5\nm : (x : ι) → MeasurableSpace (β x)\nf : (x : ι) → Ω → β x\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\na✝ : ProbabilityTheory.Kernel.iIndepFun m f κ μ\n⊢ ProbabilityTheory.Kernel.iIndepFun m f η μ","decl":"alias ⟨iIndepFun.congr, _⟩ := iIndepFun_congr\n\n"}
{"name":"ProbabilityTheory.Kernel.indepFun_congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_5\nγ : Type u_6\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nf : Ω → β\ng : Ω → γ\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\n⊢ Iff (ProbabilityTheory.Kernel.IndepFun f g κ μ) (ProbabilityTheory.Kernel.IndepFun f g η μ)","decl":"lemma indepFun_congr {β γ} [MeasurableSpace β] [MeasurableSpace γ]\n    {f : Ω → β} {g : Ω → γ} (h : κ =ᵐ[μ] η) : IndepFun f g κ μ ↔ IndepFun f g η μ :=\n  indep_congr h\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepFun.congr","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ η : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_5\nγ : Type u_6\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSpace γ\nf : Ω → β\ng : Ω → γ\nh : (MeasureTheory.ae μ).EventuallyEq ⇑κ ⇑η\na✝ : ProbabilityTheory.Kernel.IndepFun f g κ μ\n⊢ ProbabilityTheory.Kernel.IndepFun f g η μ","decl":"alias ⟨IndepFun.congr, _⟩ := indepFun_congr\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSets.meas_biInter","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nπ : ι → Set (Set Ω)\nh : ProbabilityTheory.Kernel.iIndepSets π κ μ\ns : Finset ι\nf : ι → Set Ω\nhf : ∀ (i : ι), Membership.mem s i → Membership.mem (π i) (f i)\n⊢ Filter.Eventually (fun a => Eq ((κ a) (Set.iInter fun i => Set.iInter fun h => f i)) (s.prod fun i => (κ a) (f i))) (MeasureTheory.ae μ)","decl":"lemma iIndepSets.meas_biInter (h : iIndepSets π κ μ) (s : Finset ι)\n    {f : ι → Set Ω} (hf : ∀ i, i ∈ s → f i ∈ π i) :\n    ∀ᵐ a ∂μ, κ a (⋂ i ∈ s, f i) = ∏ i ∈ s, κ a (f i) := h s hf\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSets.ae_isProbabilityMeasure","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nπ : ι → Set (Set Ω)\nh : ProbabilityTheory.Kernel.iIndepSets π κ μ\n⊢ Filter.Eventually (fun a => MeasureTheory.IsProbabilityMeasure (κ a)) (MeasureTheory.ae μ)","decl":"lemma iIndepSets.ae_isProbabilityMeasure (h : iIndepSets π κ μ) :\n    ∀ᵐ a ∂μ, IsProbabilityMeasure (κ a) := by\n  filter_upwards [h.meas_biInter ∅ (f := fun _ ↦ Set.univ) (by simp)] with a ha\n  exact ⟨by simpa using ha⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSets.meas_iInter","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nπ : ι → Set (Set Ω)\ns : ι → Set Ω\ninst✝ : Fintype ι\nh : ProbabilityTheory.Kernel.iIndepSets π κ μ\nhs : ∀ (i : ι), Membership.mem (π i) (s i)\n⊢ Filter.Eventually (fun a => Eq ((κ a) (Set.iInter fun i => s i)) (Finset.univ.prod fun i => (κ a) (s i))) (MeasureTheory.ae μ)","decl":"lemma iIndepSets.meas_iInter [Fintype ι] (h : iIndepSets π κ μ) (hs : ∀ i, s i ∈ π i) :\n    ∀ᵐ a ∂μ, κ a (⋂ i, s i) = ∏ i, κ a (s i) := by\n  filter_upwards [h.meas_biInter Finset.univ (fun _i _ ↦ hs _)] with a ha using by simp [← ha]\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndep.iIndepSets'","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\nm : ι → MeasurableSpace Ω\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nhμ : ProbabilityTheory.Kernel.iIndep m κ μ\n⊢ ProbabilityTheory.Kernel.iIndepSets (fun x => setOf fun s => MeasurableSet s) κ μ","decl":"lemma iIndep.iIndepSets' (hμ : iIndep m κ μ) :\n    iIndepSets (fun x ↦ {s | MeasurableSet[m x] s}) κ μ := hμ\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndep.ae_isProbabilityMeasure","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\nm : ι → MeasurableSpace Ω\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh : ProbabilityTheory.Kernel.iIndep m κ μ\n⊢ Filter.Eventually (fun a => MeasureTheory.IsProbabilityMeasure (κ a)) (MeasureTheory.ae μ)","decl":"lemma iIndep.ae_isProbabilityMeasure (h : iIndep m κ μ) :\n    ∀ᵐ a ∂μ, IsProbabilityMeasure (κ a) :=\n  h.iIndepSets'.ae_isProbabilityMeasure\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndep.meas_biInter","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\nm : ι → MeasurableSpace Ω\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns : ι → Set Ω\nS : Finset ι\nhμ : ProbabilityTheory.Kernel.iIndep m κ μ\nhs : ∀ (i : ι), Membership.mem S i → MeasurableSet (s i)\n⊢ Filter.Eventually (fun a => Eq ((κ a) (Set.iInter fun i => Set.iInter fun h => s i)) (S.prod fun i => (κ a) (s i))) (MeasureTheory.ae μ)","decl":"lemma iIndep.meas_biInter (hμ : iIndep m κ μ) (hs : ∀ i, i ∈ S → MeasurableSet[m i] (s i)) :\n    ∀ᵐ a ∂μ, κ a (⋂ i ∈ S, s i) = ∏ i ∈ S, κ a (s i) := hμ _ hs\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndep.meas_iInter","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\nm : ι → MeasurableSpace Ω\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns : ι → Set Ω\ninst✝ : Fintype ι\nh : ProbabilityTheory.Kernel.iIndep m κ μ\nhs : ∀ (i : ι), MeasurableSet (s i)\n⊢ Filter.Eventually (fun a => Eq ((κ a) (Set.iInter fun i => s i)) (Finset.univ.prod fun i => (κ a) (s i))) (MeasureTheory.ae μ)","decl":"lemma iIndep.meas_iInter [Fintype ι] (h : iIndep m κ μ) (hs : ∀ i, MeasurableSet[m i] (s i)) :\n    ∀ᵐ a ∂μ, κ a (⋂ i, s i) = ∏ i, κ a (s i) := by\n  filter_upwards [h.meas_biInter (fun i (_ : i ∈ Finset.univ) ↦ hs _)] with a ha\n  simp [← ha]\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.iIndep","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\nβ : ι → Type u_4\nmβ : (i : ι) → MeasurableSpace (β i)\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nf : (x : ι) → Ω → β x\nhf : ProbabilityTheory.Kernel.iIndepFun mβ f κ μ\n⊢ ProbabilityTheory.Kernel.iIndep (fun x => MeasurableSpace.comap (f x) (mβ x)) κ μ","decl":"protected lemma iIndepFun.iIndep (hf : iIndepFun mβ f κ μ) :\n    iIndep (fun x ↦ (mβ x).comap (f x)) κ μ := hf\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.ae_isProbabilityMeasure","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\nβ : ι → Type u_4\nmβ : (i : ι) → MeasurableSpace (β i)\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nf : (x : ι) → Ω → β x\nh : ProbabilityTheory.Kernel.iIndepFun mβ f κ μ\n⊢ Filter.Eventually (fun a => MeasureTheory.IsProbabilityMeasure (κ a)) (MeasureTheory.ae μ)","decl":"lemma iIndepFun.ae_isProbabilityMeasure (h : iIndepFun mβ f κ μ) :\n    ∀ᵐ a ∂μ, IsProbabilityMeasure (κ a) :=\n  h.iIndep.ae_isProbabilityMeasure\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.meas_biInter","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\nβ : ι → Type u_4\nmβ : (i : ι) → MeasurableSpace (β i)\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns : ι → Set Ω\nS : Finset ι\nf : (x : ι) → Ω → β x\nhf : ProbabilityTheory.Kernel.iIndepFun mβ f κ μ\nhs : ∀ (i : ι), Membership.mem S i → MeasurableSet (s i)\n⊢ Filter.Eventually (fun a => Eq ((κ a) (Set.iInter fun i => Set.iInter fun h => s i)) (S.prod fun i => (κ a) (s i))) (MeasureTheory.ae μ)","decl":"lemma iIndepFun.meas_biInter (hf : iIndepFun mβ f κ μ)\n    (hs : ∀ i, i ∈ S → MeasurableSet[(mβ i).comap (f i)] (s i)) :\n    ∀ᵐ a ∂μ, κ a (⋂ i ∈ S, s i) = ∏ i ∈ S, κ a (s i) := hf.iIndep.meas_biInter hs\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.meas_iInter","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\nβ : ι → Type u_4\nmβ : (i : ι) → MeasurableSpace (β i)\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns : ι → Set Ω\nf : (x : ι) → Ω → β x\ninst✝ : Fintype ι\nhf : ProbabilityTheory.Kernel.iIndepFun mβ f κ μ\nhs : ∀ (i : ι), MeasurableSet (s i)\n⊢ Filter.Eventually (fun a => Eq ((κ a) (Set.iInter fun i => s i)) (Finset.univ.prod fun i => (κ a) (s i))) (MeasureTheory.ae μ)","decl":"lemma iIndepFun.meas_iInter [Fintype ι] (hf : iIndepFun mβ f κ μ)\n    (hs : ∀ i, MeasurableSet[(mβ i).comap (f i)] (s i)) :\n    ∀ᵐ a ∂μ, κ a (⋂ i, s i) = ∏ i, κ a (s i) := hf.iIndep.meas_iInter hs\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepFun.meas_inter","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_5\nγ : Type u_6\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nf : Ω → β\ng : Ω → γ\nhfg : ProbabilityTheory.Kernel.IndepFun f g κ μ\ns t : Set Ω\nhs : MeasurableSet s\nht : MeasurableSet t\n⊢ Filter.Eventually (fun a => Eq ((κ a) (Inter.inter s t)) (HMul.hMul ((κ a) s) ((κ a) t))) (MeasureTheory.ae μ)","decl":"lemma IndepFun.meas_inter {β γ : Type*} [mβ : MeasurableSpace β] [mγ : MeasurableSpace γ]\n    {f : Ω → β} {g : Ω → γ} (hfg : IndepFun f g κ μ)\n    {s t : Set Ω} (hs : MeasurableSet[mβ.comap f] s) (ht : MeasurableSet[mγ.comap g] t) :\n    ∀ᵐ a ∂μ, κ a (s ∩ t) = κ a s * κ a t := hfg _ _ hs ht\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSets.symm","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns₁ s₂ : Set (Set Ω)\nh : ProbabilityTheory.Kernel.IndepSets s₁ s₂ κ μ\n⊢ ProbabilityTheory.Kernel.IndepSets s₂ s₁ κ μ","decl":"@[symm]\ntheorem IndepSets.symm {_mΩ : MeasurableSpace Ω} {κ : Kernel α Ω} {μ : Measure α}\n    {s₁ s₂ : Set (Set Ω)} (h : IndepSets s₁ s₂ κ μ) :\n    IndepSets s₂ s₁ κ μ := by\n  intros t1 t2 ht1 ht2\n  filter_upwards [h t2 t1 ht2 ht1] with a ha\n  rwa [Set.inter_comm, mul_comm]\n\n"}
{"name":"ProbabilityTheory.Kernel.Indep.symm","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\nm₁ m₂ _mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh : ProbabilityTheory.Kernel.Indep m₁ m₂ κ μ\n⊢ ProbabilityTheory.Kernel.Indep m₂ m₁ κ μ","decl":"@[symm]\ntheorem Indep.symm {m₁ m₂ : MeasurableSpace Ω} {_mΩ : MeasurableSpace Ω} {κ : Kernel α Ω}\n    {μ : Measure α} (h : Indep m₁ m₂ κ μ) :\n    Indep m₂ m₁ κ μ :=\n  IndepSets.symm h\n\n"}
{"name":"ProbabilityTheory.Kernel.indep_bot_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\nm' _mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ ProbabilityTheory.Kernel.Indep m' Bot.bot κ μ","decl":"theorem indep_bot_right (m' : MeasurableSpace Ω) {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} [IsZeroOrMarkovKernel κ] :\n    Indep m' ⊥ κ μ := by\n  intros s t _ ht\n  rw [Set.mem_setOf_eq, MeasurableSpace.measurableSet_bot_iff] at ht\n  rcases eq_zero_or_isMarkovKernel κ with rfl| h\n  · simp\n  refine Filter.Eventually.of_forall (fun a ↦ ?_)\n  cases' ht with ht ht\n  · rw [ht, Set.inter_empty, measure_empty, mul_zero]\n  · rw [ht, Set.inter_univ, measure_univ, mul_one]\n\n"}
{"name":"ProbabilityTheory.Kernel.indep_bot_left","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\nm' _mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ ProbabilityTheory.Kernel.Indep Bot.bot m' κ μ","decl":"theorem indep_bot_left (m' : MeasurableSpace Ω) {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} [IsZeroOrMarkovKernel κ] :\n    Indep ⊥ m' κ μ := (indep_bot_right m').symm\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSet_empty_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\ns : Set Ω\n⊢ ProbabilityTheory.Kernel.IndepSet s EmptyCollection.emptyCollection κ μ","decl":"theorem indepSet_empty_right {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} [IsZeroOrMarkovKernel κ] (s : Set Ω) :\n    IndepSet s ∅ κ μ := by\n  simp only [IndepSet, generateFrom_singleton_empty]\n  exact indep_bot_right _\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSet_empty_left","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\ns : Set Ω\n⊢ ProbabilityTheory.Kernel.IndepSet EmptyCollection.emptyCollection s κ μ","decl":"theorem indepSet_empty_left {_mΩ : MeasurableSpace Ω} {κ : Kernel α Ω}\n    {μ : Measure α} [IsZeroOrMarkovKernel κ] (s : Set Ω) :\n    IndepSet ∅ s κ μ :=\n  (indepSet_empty_right s).symm\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSets_of_indepSets_of_le_left","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\ns₁ s₂ s₃ : Set (Set Ω)\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh_indep : ProbabilityTheory.Kernel.IndepSets s₁ s₂ κ μ\nh31 : HasSubset.Subset s₃ s₁\n⊢ ProbabilityTheory.Kernel.IndepSets s₃ s₂ κ μ","decl":"theorem indepSets_of_indepSets_of_le_left {s₁ s₂ s₃ : Set (Set Ω)} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} (h_indep : IndepSets s₁ s₂ κ μ) (h31 : s₃ ⊆ s₁) :\n    IndepSets s₃ s₂ κ μ :=\n  fun t1 t2 ht1 ht2 => h_indep t1 t2 (Set.mem_of_subset_of_mem h31 ht1) ht2\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSets_of_indepSets_of_le_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\ns₁ s₂ s₃ : Set (Set Ω)\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh_indep : ProbabilityTheory.Kernel.IndepSets s₁ s₂ κ μ\nh32 : HasSubset.Subset s₃ s₂\n⊢ ProbabilityTheory.Kernel.IndepSets s₁ s₃ κ μ","decl":"theorem indepSets_of_indepSets_of_le_right {s₁ s₂ s₃ : Set (Set Ω)} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} (h_indep : IndepSets s₁ s₂ κ μ) (h32 : s₃ ⊆ s₂) :\n    IndepSets s₁ s₃ κ μ :=\n  fun t1 t2 ht1 ht2 => h_indep t1 t2 ht1 (Set.mem_of_subset_of_mem h32 ht2)\n\n"}
{"name":"ProbabilityTheory.Kernel.indep_of_indep_of_le_left","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\nm₁ m₂ m₃ _mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh_indep : ProbabilityTheory.Kernel.Indep m₁ m₂ κ μ\nh31 : LE.le m₃ m₁\n⊢ ProbabilityTheory.Kernel.Indep m₃ m₂ κ μ","decl":"theorem indep_of_indep_of_le_left {m₁ m₂ m₃ : MeasurableSpace Ω} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} (h_indep : Indep m₁ m₂ κ μ) (h31 : m₃ ≤ m₁) :\n    Indep m₃ m₂ κ μ :=\n  fun t1 t2 ht1 ht2 => h_indep t1 t2 (h31 _ ht1) ht2\n\n"}
{"name":"ProbabilityTheory.Kernel.indep_of_indep_of_le_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\nm₁ m₂ m₃ _mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh_indep : ProbabilityTheory.Kernel.Indep m₁ m₂ κ μ\nh32 : LE.le m₃ m₂\n⊢ ProbabilityTheory.Kernel.Indep m₁ m₃ κ μ","decl":"theorem indep_of_indep_of_le_right {m₁ m₂ m₃ : MeasurableSpace Ω} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} (h_indep : Indep m₁ m₂ κ μ) (h32 : m₃ ≤ m₂) :\n    Indep m₁ m₃ κ μ :=\n  fun t1 t2 ht1 ht2 => h_indep t1 t2 ht1 (h32 _ ht2)\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSets.union","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\ns₁ s₂ s' : Set (Set Ω)\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh₁ : ProbabilityTheory.Kernel.IndepSets s₁ s' κ μ\nh₂ : ProbabilityTheory.Kernel.IndepSets s₂ s' κ μ\n⊢ ProbabilityTheory.Kernel.IndepSets (Union.union s₁ s₂) s' κ μ","decl":"theorem IndepSets.union {s₁ s₂ s' : Set (Set Ω)} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α}\n    (h₁ : IndepSets s₁ s' κ μ) (h₂ : IndepSets s₂ s' κ μ) :\n    IndepSets (s₁ ∪ s₂) s' κ μ := by\n  intro t1 t2 ht1 ht2\n  cases' (Set.mem_union _ _ _).mp ht1 with ht1₁ ht1₂\n  · exact h₁ t1 t2 ht1₁ ht2\n  · exact h₂ t1 t2 ht1₂ ht2\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSets.union_iff","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\ns₁ s₂ s' : Set (Set Ω)\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\n⊢ Iff (ProbabilityTheory.Kernel.IndepSets (Union.union s₁ s₂) s' κ μ) (And (ProbabilityTheory.Kernel.IndepSets s₁ s' κ μ) (ProbabilityTheory.Kernel.IndepSets s₂ s' κ μ))","decl":"@[simp]\ntheorem IndepSets.union_iff {s₁ s₂ s' : Set (Set Ω)} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} :\n    IndepSets (s₁ ∪ s₂) s' κ μ ↔ IndepSets s₁ s' κ μ ∧ IndepSets s₂ s' κ μ :=\n  ⟨fun h =>\n    ⟨indepSets_of_indepSets_of_le_left h Set.subset_union_left,\n      indepSets_of_indepSets_of_le_left h Set.subset_union_right⟩,\n    fun h => IndepSets.union h.left h.right⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSets.iUnion","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\ns : ι → Set (Set Ω)\ns' : Set (Set Ω)\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nhyp : ∀ (n : ι), ProbabilityTheory.Kernel.IndepSets (s n) s' κ μ\n⊢ ProbabilityTheory.Kernel.IndepSets (Set.iUnion fun n => s n) s' κ μ","decl":"theorem IndepSets.iUnion {s : ι → Set (Set Ω)} {s' : Set (Set Ω)} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} (hyp : ∀ n, IndepSets (s n) s' κ μ) :\n    IndepSets (⋃ n, s n) s' κ μ := by\n  intro t1 t2 ht1 ht2\n  rw [Set.mem_iUnion] at ht1\n  cases' ht1 with n ht1\n  exact hyp n t1 t2 ht1 ht2\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSets.bUnion","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\ns : ι → Set (Set Ω)\ns' : Set (Set Ω)\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nu : Set ι\nhyp : ∀ (n : ι), Membership.mem u n → ProbabilityTheory.Kernel.IndepSets (s n) s' κ μ\n⊢ ProbabilityTheory.Kernel.IndepSets (Set.iUnion fun n => Set.iUnion fun h => s n) s' κ μ","decl":"theorem IndepSets.bUnion {s : ι → Set (Set Ω)} {s' : Set (Set Ω)} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} {u : Set ι} (hyp : ∀ n ∈ u, IndepSets (s n) s' κ μ) :\n    IndepSets (⋃ n ∈ u, s n) s' κ μ := by\n  intro t1 t2 ht1 ht2\n  simp_rw [Set.mem_iUnion] at ht1\n  rcases ht1 with ⟨n, hpn, ht1⟩\n  exact hyp n hpn t1 t2 ht1 ht2\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSets.inter","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\ns₁ s' s₂ : Set (Set Ω)\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh₁ : ProbabilityTheory.Kernel.IndepSets s₁ s' κ μ\n⊢ ProbabilityTheory.Kernel.IndepSets (Inter.inter s₁ s₂) s' κ μ","decl":"theorem IndepSets.inter {s₁ s' : Set (Set Ω)} (s₂ : Set (Set Ω)) {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} (h₁ : IndepSets s₁ s' κ μ) :\n    IndepSets (s₁ ∩ s₂) s' κ μ :=\n  fun t1 t2 ht1 ht2 => h₁ t1 t2 ((Set.mem_inter_iff _ _ _).mp ht1).left ht2\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSets.iInter","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\ns : ι → Set (Set Ω)\ns' : Set (Set Ω)\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh : Exists fun n => ProbabilityTheory.Kernel.IndepSets (s n) s' κ μ\n⊢ ProbabilityTheory.Kernel.IndepSets (Set.iInter fun n => s n) s' κ μ","decl":"theorem IndepSets.iInter {s : ι → Set (Set Ω)} {s' : Set (Set Ω)} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} (h : ∃ n, IndepSets (s n) s' κ μ) :\n    IndepSets (⋂ n, s n) s' κ μ := by\n  intro t1 t2 ht1 ht2; cases' h with n h; exact h t1 t2 (Set.mem_iInter.mp ht1 n) ht2\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSets.bInter","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\ns : ι → Set (Set Ω)\ns' : Set (Set Ω)\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nu : Set ι\nh : Exists fun n => And (Membership.mem u n) (ProbabilityTheory.Kernel.IndepSets (s n) s' κ μ)\n⊢ ProbabilityTheory.Kernel.IndepSets (Set.iInter fun n => Set.iInter fun h => s n) s' κ μ","decl":"theorem IndepSets.bInter {s : ι → Set (Set Ω)} {s' : Set (Set Ω)} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} {u : Set ι} (h : ∃ n ∈ u, IndepSets (s n) s' κ μ) :\n    IndepSets (⋂ n ∈ u, s n) s' κ μ := by\n  intro t1 t2 ht1 ht2\n  rcases h with ⟨n, hn, h⟩\n  exact h t1 t2 (Set.biInter_subset_of_mem hn ht1) ht2\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndep_comap_mem_iff","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\nf : ι → Set Ω\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\n⊢ Iff (ProbabilityTheory.Kernel.iIndep (fun i => MeasurableSpace.comap (fun x => Membership.mem (f i) x) Top.top) κ μ) (ProbabilityTheory.Kernel.iIndepSet f κ μ)","decl":"theorem iIndep_comap_mem_iff {f : ι → Set Ω} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} :\n    iIndep (fun i => MeasurableSpace.comap (· ∈ f i) ⊤) κ μ ↔ iIndepSet f κ μ := by\n  simp_rw [← generateFrom_singleton, iIndepSet]\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSets_singleton_iff","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\ns : ι → Set Ω\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\n⊢ Iff (ProbabilityTheory.Kernel.iIndepSets (fun i => Singleton.singleton (s i)) κ μ) (∀ (S : Finset ι), Filter.Eventually (fun a => Eq ((κ a) (Set.iInter fun i => Set.iInter fun h => s i)) (S.prod fun i => (κ a) (s i))) (MeasureTheory.ae μ))","decl":"theorem iIndepSets_singleton_iff {s : ι → Set Ω} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} :\n    iIndepSets (fun i ↦ {s i}) κ μ ↔\n      ∀ S : Finset ι, ∀ᵐ a ∂μ, κ a (⋂ i ∈ S, s i) = ∏ i ∈ S, κ a (s i) := by\n  refine ⟨fun h S ↦ h S (fun i _ ↦ rfl), fun h S f hf ↦ ?_⟩\n  filter_upwards [h S] with a ha\n  have : ∀ i ∈ S, κ a (f i) = κ a (s i) := fun i hi ↦ by rw [hf i hi]\n  rwa [Finset.prod_congr rfl this, Set.iInter₂_congr hf]\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSets_singleton_iff","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\ns t : Set Ω\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\n⊢ Iff (ProbabilityTheory.Kernel.IndepSets (Singleton.singleton s) (Singleton.singleton t) κ μ) (Filter.Eventually (fun a => Eq ((κ a) (Inter.inter s t)) (HMul.hMul ((κ a) s) ((κ a) t))) (MeasureTheory.ae μ))","decl":"theorem indepSets_singleton_iff {s t : Set Ω} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} :\n    IndepSets {s} {t} κ μ ↔ ∀ᵐ a ∂μ, κ a (s ∩ t) = κ a s * κ a t :=\n  ⟨fun h ↦ h s t rfl rfl,\n   fun h s1 t1 hs1 ht1 ↦ by rwa [Set.mem_singleton_iff.mp hs1, Set.mem_singleton_iff.mp ht1]⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSets.indepSets","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\ns : ι → Set (Set Ω)\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh_indep : ProbabilityTheory.Kernel.iIndepSets s κ μ\ni j : ι\nhij : Ne i j\n⊢ ProbabilityTheory.Kernel.IndepSets (s i) (s j) κ μ","decl":"theorem iIndepSets.indepSets {s : ι → Set (Set Ω)} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} (h_indep : iIndepSets s κ μ) {i j : ι} (hij : i ≠ j) :\n    IndepSets (s i) (s j) κ μ := by\n  classical\n  intro t₁ t₂ ht₁ ht₂\n  have hf_m : ∀ x : ι, x ∈ ({i, j} : Finset ι) → ite (x = i) t₁ t₂ ∈ s x := by\n    intro x hx\n    cases' Finset.mem_insert.mp hx with hx hx\n    · simp [hx, ht₁]\n    · simp [Finset.mem_singleton.mp hx, hij.symm, ht₂]\n  have h1 : t₁ = ite (i = i) t₁ t₂ := by simp only [if_true, eq_self_iff_true]\n  have h2 : t₂ = ite (j = i) t₁ t₂ := by simp only [hij.symm, if_false]\n  have h_inter : ⋂ (t : ι) (_ : t ∈ ({i, j} : Finset ι)), ite (t = i) t₁ t₂ =\n      ite (i = i) t₁ t₂ ∩ ite (j = i) t₁ t₂ := by\n    simp only [Finset.set_biInter_singleton, Finset.set_biInter_insert]\n  filter_upwards [h_indep {i, j} hf_m] with a h_indep'\n  have h_prod : (∏ t ∈ ({i, j} : Finset ι), κ a (ite (t = i) t₁ t₂))\n      = κ a (ite (i = i) t₁ t₂) * κ a (ite (j = i) t₁ t₂) := by\n    simp only [hij, Finset.prod_singleton, Finset.prod_insert, not_false_iff,\n      Finset.mem_singleton]\n  rw [h1]\n  nth_rw 2 [h2]\n  nth_rw 4 [h2]\n  rw [← h_inter, ← h_prod, h_indep']\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndep.indep","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\nm : ι → MeasurableSpace Ω\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh_indep : ProbabilityTheory.Kernel.iIndep m κ μ\ni j : ι\nhij : Ne i j\n⊢ ProbabilityTheory.Kernel.Indep (m i) (m j) κ μ","decl":"theorem iIndep.indep {m : ι → MeasurableSpace Ω} {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α}\n    (h_indep : iIndep m κ μ) {i j : ι} (hij : i ≠ j) : Indep (m i) (m j) κ μ :=\n  iIndepSets.indepSets h_indep hij\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : ι → Type u_4\nm : (x : ι) → MeasurableSpace (β x)\nf : (i : ι) → Ω → β i\nhf_Indep : ProbabilityTheory.Kernel.iIndepFun m f κ μ\ni j : ι\nhij : Ne i j\n⊢ ProbabilityTheory.Kernel.IndepFun (f i) (f j) κ μ","decl":"theorem iIndepFun.indepFun {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} {β : ι → Type*}\n    {m : ∀ x, MeasurableSpace (β x)} {f : ∀ i, Ω → β i} (hf_Indep : iIndepFun m f κ μ) {i j : ι}\n    (hij : i ≠ j) : IndepFun (f i) (f j) κ μ :=\n  hf_Indep.indep hij\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndep.iIndepSets","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nm : ι → MeasurableSpace Ω\ns : ι → Set (Set Ω)\nhms : ∀ (n : ι), Eq (m n) (MeasurableSpace.generateFrom (s n))\nh_indep : ProbabilityTheory.Kernel.iIndep m κ μ\n⊢ ProbabilityTheory.Kernel.iIndepSets s κ μ","decl":"theorem iIndep.iIndepSets {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} {m : ι → MeasurableSpace Ω}\n    {s : ι → Set (Set Ω)} (hms : ∀ n, m n = generateFrom (s n)) (h_indep : iIndep m κ μ) :\n    iIndepSets s κ μ :=\n  fun S f hfs =>\n  h_indep S fun x hxS =>\n    ((hms x).symm ▸ measurableSet_generateFrom (hfs x hxS) : MeasurableSet[m x] (f x))\n\n"}
{"name":"ProbabilityTheory.Kernel.Indep.indepSets","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns1 s2 : Set (Set Ω)\nh_indep : ProbabilityTheory.Kernel.Indep (MeasurableSpace.generateFrom s1) (MeasurableSpace.generateFrom s2) κ μ\n⊢ ProbabilityTheory.Kernel.IndepSets s1 s2 κ μ","decl":"theorem Indep.indepSets {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} {s1 s2 : Set (Set Ω)}\n    (h_indep : Indep (generateFrom s1) (generateFrom s2) κ μ) :\n    IndepSets s1 s2 κ μ :=\n  fun t1 t2 ht1 ht2 =>\n  h_indep t1 t2 (measurableSet_generateFrom ht1) (measurableSet_generateFrom ht2)\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSets.indep_aux","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\nm₂ m : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\np1 p2 : Set (Set Ω)\nh2 : LE.le m₂ m\nhp2 : IsPiSystem p2\nhpm2 : Eq m₂ (MeasurableSpace.generateFrom p2)\nhyp : ProbabilityTheory.Kernel.IndepSets p1 p2 κ μ\nt1 t2 : Set Ω\nht1 : Membership.mem p1 t1\nht1m : MeasurableSet t1\nht2m : MeasurableSet t2\n⊢ Filter.Eventually (fun a => Eq ((κ a) (Inter.inter t1 t2)) (HMul.hMul ((κ a) t1) ((κ a) t2))) (MeasureTheory.ae μ)","decl":"theorem IndepSets.indep_aux {m₂ m : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} [IsZeroOrMarkovKernel κ] {p1 p2 : Set (Set Ω)} (h2 : m₂ ≤ m)\n    (hp2 : IsPiSystem p2) (hpm2 : m₂ = generateFrom p2) (hyp : IndepSets p1 p2 κ μ) {t1 t2 : Set Ω}\n    (ht1 : t1 ∈ p1) (ht1m : MeasurableSet[m] t1) (ht2m : MeasurableSet[m₂] t2) :\n    ∀ᵐ a ∂μ, κ a (t1 ∩ t2) = κ a t1 * κ a t2 := by\n  rcases eq_zero_or_isMarkovKernel κ with rfl | h\n  · simp\n  induction t2, ht2m using induction_on_inter hpm2 hp2 with\n  | empty => simp\n  | basic u hu => exact hyp t1 u ht1 hu\n  | compl u hu ihu =>\n    filter_upwards [ihu] with a ha\n    rw [← Set.diff_eq, ← Set.diff_self_inter,\n      measure_diff inter_subset_left (ht1m.inter (h2 _ hu)).nullMeasurableSet (measure_ne_top _ _),\n      ha, measure_compl (h2 _ hu) (measure_ne_top _ _), measure_univ, ENNReal.mul_sub, mul_one]\n    exact fun _ _ ↦ measure_ne_top _ _\n  | iUnion f hfd hfm ihf =>\n    rw [← ae_all_iff] at ihf\n    filter_upwards [ihf] with a ha\n    rw [inter_iUnion, measure_iUnion, measure_iUnion hfd fun i ↦ h2 _ (hfm i)]\n    · simp only [ENNReal.tsum_mul_left, ha]\n    · exact hfd.mono fun i j h ↦ (h.inter_left' _).inter_right' _\n    · exact fun i ↦ .inter ht1m (h2 _ <| hfm i)\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSets.indep","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\nm1 m2 m : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\np1 p2 : Set (Set Ω)\nh1 : LE.le m1 m\nh2 : LE.le m2 m\nhp1 : IsPiSystem p1\nhp2 : IsPiSystem p2\nhpm1 : Eq m1 (MeasurableSpace.generateFrom p1)\nhpm2 : Eq m2 (MeasurableSpace.generateFrom p2)\nhyp : ProbabilityTheory.Kernel.IndepSets p1 p2 κ μ\n⊢ ProbabilityTheory.Kernel.Indep m1 m2 κ μ","decl":"/-- The measurable space structures generated by independent pi-systems are independent. -/\ntheorem IndepSets.indep {m1 m2 m : MeasurableSpace Ω} {κ : Kernel α Ω} {μ : Measure α}\n    [IsZeroOrMarkovKernel κ] {p1 p2 : Set (Set Ω)} (h1 : m1 ≤ m) (h2 : m2 ≤ m) (hp1 : IsPiSystem p1)\n    (hp2 : IsPiSystem p2) (hpm1 : m1 = generateFrom p1) (hpm2 : m2 = generateFrom p2)\n    (hyp : IndepSets p1 p2 κ μ) :\n    Indep m1 m2 κ μ := by\n  rcases eq_zero_or_isMarkovKernel κ with rfl | h\n  · simp\n  intros t1 t2 ht1 ht2\n  induction t1, ht1 using induction_on_inter hpm1 hp1 with\n  | empty =>\n    simp only [Set.empty_inter, measure_empty, zero_mul, eq_self_iff_true, Filter.eventually_true]\n  | basic t ht =>\n    refine IndepSets.indep_aux h2 hp2 hpm2 hyp ht (h1 _ ?_) ht2\n    rw [hpm1]\n    exact measurableSet_generateFrom ht\n  | compl t ht iht =>\n    filter_upwards [iht] with a ha\n    have : tᶜ ∩ t2 = t2 \\ (t ∩ t2) := by\n      rw [Set.inter_comm t, Set.diff_self_inter, Set.diff_eq_compl_inter]\n    rw [this, Set.inter_comm t t2,\n      measure_diff Set.inter_subset_left ((h2 _ ht2).inter (h1 _ ht)).nullMeasurableSet\n        (measure_ne_top (κ a) _),\n      Set.inter_comm, ha, measure_compl (h1 _ ht) (measure_ne_top (κ a) t), measure_univ,\n      mul_comm (1 - κ a t), ENNReal.mul_sub (fun _ _ ↦ measure_ne_top (κ a) _), mul_one, mul_comm]\n  | iUnion f hf_disj hf_meas h =>\n    rw [← ae_all_iff] at h\n    filter_upwards [h] with a ha\n    rw [Set.inter_comm, Set.inter_iUnion, measure_iUnion]\n    · rw [measure_iUnion hf_disj (fun i ↦ h1 _ (hf_meas i))]\n      rw [← ENNReal.tsum_mul_right]\n      congr 1 with i\n      rw [Set.inter_comm t2, ha i]\n    · intros i j hij\n      rw [Function.onFun, Set.inter_comm t2, Set.inter_comm t2]\n      exact Disjoint.inter_left _ (Disjoint.inter_right _ (hf_disj hij))\n    · exact fun i ↦ (h2 _ ht2).inter (h1 _ (hf_meas i))\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSets.indep'","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\np1 p2 : Set (Set Ω)\nhp1m : ∀ (s : Set Ω), Membership.mem p1 s → MeasurableSet s\nhp2m : ∀ (s : Set Ω), Membership.mem p2 s → MeasurableSet s\nhp1 : IsPiSystem p1\nhp2 : IsPiSystem p2\nhyp : ProbabilityTheory.Kernel.IndepSets p1 p2 κ μ\n⊢ ProbabilityTheory.Kernel.Indep (MeasurableSpace.generateFrom p1) (MeasurableSpace.generateFrom p2) κ μ","decl":"theorem IndepSets.indep' {_mΩ : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} [IsZeroOrMarkovKernel κ]\n    {p1 p2 : Set (Set Ω)} (hp1m : ∀ s ∈ p1, MeasurableSet s) (hp2m : ∀ s ∈ p2, MeasurableSet s)\n    (hp1 : IsPiSystem p1) (hp2 : IsPiSystem p2) (hyp : IndepSets p1 p2 κ μ) :\n    Indep (generateFrom p1) (generateFrom p2) κ μ :=\n  hyp.indep (generateFrom_le hp1m) (generateFrom_le hp2m) hp1 hp2 rfl rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSets_piiUnionInter_of_disjoint","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns : ι → Set (Set Ω)\nS T : Set ι\nh_indep : ProbabilityTheory.Kernel.iIndepSets s κ μ\nhST : Disjoint S T\n⊢ ProbabilityTheory.Kernel.IndepSets (piiUnionInter s S) (piiUnionInter s T) κ μ","decl":"theorem indepSets_piiUnionInter_of_disjoint {s : ι → Set (Set Ω)}\n    {S T : Set ι} (h_indep : iIndepSets s κ μ) (hST : Disjoint S T) :\n    IndepSets (piiUnionInter s S) (piiUnionInter s T) κ μ := by\n  rintro t1 t2 ⟨p1, hp1, f1, ht1_m, ht1_eq⟩ ⟨p2, hp2, f2, ht2_m, ht2_eq⟩\n  classical\n  let g i := ite (i ∈ p1) (f1 i) Set.univ ∩ ite (i ∈ p2) (f2 i) Set.univ\n  have h_P_inter : ∀ᵐ a ∂μ, κ a (t1 ∩ t2) = ∏ n ∈ p1 ∪ p2, κ a (g n) := by\n    have hgm : ∀ i ∈ p1 ∪ p2, g i ∈ s i := by\n      intro i hi_mem_union\n      rw [Finset.mem_union] at hi_mem_union\n      cases' hi_mem_union with hi1 hi2\n      · have hi2 : i ∉ p2 := fun hip2 => Set.disjoint_left.mp hST (hp1 hi1) (hp2 hip2)\n        simp_rw [g, if_pos hi1, if_neg hi2, Set.inter_univ]\n        exact ht1_m i hi1\n      · have hi1 : i ∉ p1 := fun hip1 => Set.disjoint_right.mp hST (hp2 hi2) (hp1 hip1)\n        simp_rw [g, if_neg hi1, if_pos hi2, Set.univ_inter]\n        exact ht2_m i hi2\n    have h_p1_inter_p2 :\n      ((⋂ x ∈ p1, f1 x) ∩ ⋂ x ∈ p2, f2 x) =\n        ⋂ i ∈ p1 ∪ p2, ite (i ∈ p1) (f1 i) Set.univ ∩ ite (i ∈ p2) (f2 i) Set.univ := by\n      ext1 x\n      simp only [Set.mem_ite_univ_right, Set.mem_inter_iff, Set.mem_iInter, Finset.mem_union]\n      exact\n        ⟨fun h i _ => ⟨h.1 i, h.2 i⟩, fun h =>\n          ⟨fun i hi => (h i (Or.inl hi)).1 hi, fun i hi => (h i (Or.inr hi)).2 hi⟩⟩\n    filter_upwards [h_indep _ hgm] with a ha\n    rw [ht1_eq, ht2_eq, h_p1_inter_p2, ← ha]\n  filter_upwards [h_P_inter, h_indep p1 ht1_m, h_indep p2 ht2_m, h_indep.ae_isProbabilityMeasure]\n    with a h_P_inter ha1 ha2 h'\n  have h_μg : ∀ n, κ a (g n) = (ite (n ∈ p1) (κ a (f1 n)) 1) * (ite (n ∈ p2) (κ a (f2 n)) 1) := by\n    intro n\n    dsimp only [g]\n    split_ifs with h1 h2\n    · exact absurd rfl (Set.disjoint_iff_forall_ne.mp hST (hp1 h1) (hp2 h2))\n    all_goals simp only [measure_univ, one_mul, mul_one, Set.inter_univ, Set.univ_inter]\n  simp_rw [h_P_inter, h_μg, Finset.prod_mul_distrib,\n    Finset.prod_ite_mem (p1 ∪ p2) p1 (fun x ↦ κ a (f1 x)), Finset.union_inter_cancel_left,\n    Finset.prod_ite_mem (p1 ∪ p2) p2 (fun x => κ a (f2 x)), Finset.union_inter_cancel_right, ht1_eq,\n      ← ha1, ht2_eq, ← ha2]\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSet.indep_generateFrom_of_disjoint","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns : ι → Set Ω\nhsm : ∀ (n : ι), MeasurableSet (s n)\nhs : ProbabilityTheory.Kernel.iIndepSet s κ μ\nS T : Set ι\nhST : Disjoint S T\n⊢ ProbabilityTheory.Kernel.Indep (MeasurableSpace.generateFrom (setOf fun t => Exists fun n => And (Membership.mem S n) (Eq (s n) t))) (MeasurableSpace.generateFrom (setOf fun t => Exists fun k => And (Membership.mem T k) (Eq (s k) t))) κ μ","decl":"theorem iIndepSet.indep_generateFrom_of_disjoint {s : ι → Set Ω}\n    (hsm : ∀ n, MeasurableSet (s n)) (hs : iIndepSet s κ μ) (S T : Set ι) (hST : Disjoint S T) :\n    Indep (generateFrom { t | ∃ n ∈ S, s n = t }) (generateFrom { t | ∃ k ∈ T, s k = t }) κ μ := by\n  classical\n  rcases eq_or_ne μ 0 with rfl | hμ\n  · simp\n  obtain ⟨η, η_eq, hη⟩ : ∃ (η : Kernel α Ω), κ =ᵐ[μ] η ∧ IsMarkovKernel η :=\n    exists_ae_eq_isMarkovKernel hs.ae_isProbabilityMeasure hμ\n  apply Indep.congr (Filter.EventuallyEq.symm η_eq)\n  rw [← generateFrom_piiUnionInter_singleton_left, ← generateFrom_piiUnionInter_singleton_left]\n  refine\n    IndepSets.indep'\n      (fun t ht => generateFrom_piiUnionInter_le _ ?_ _ _ (measurableSet_generateFrom ht))\n      (fun t ht => generateFrom_piiUnionInter_le _ ?_ _ _ (measurableSet_generateFrom ht)) ?_ ?_ ?_\n  · exact fun k => generateFrom_le fun t ht => (Set.mem_singleton_iff.1 ht).symm ▸ hsm k\n  · exact fun k => generateFrom_le fun t ht => (Set.mem_singleton_iff.1 ht).symm ▸ hsm k\n  · exact isPiSystem_piiUnionInter _ (fun k => IsPiSystem.singleton _) _\n  · exact isPiSystem_piiUnionInter _ (fun k => IsPiSystem.singleton _) _\n  · exact indepSets_piiUnionInter_of_disjoint (iIndep.iIndepSets (fun n => rfl) (hs.congr η_eq)) hST\n\n"}
{"name":"ProbabilityTheory.Kernel.indep_iSup_of_disjoint","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nm : ι → MeasurableSpace Ω\nh_le : ∀ (i : ι), LE.le (m i) _mΩ\nh_indep : ProbabilityTheory.Kernel.iIndep m κ μ\nS T : Set ι\nhST : Disjoint S T\n⊢ ProbabilityTheory.Kernel.Indep (iSup fun i => iSup fun h => m i) (iSup fun i => iSup fun h => m i) κ μ","decl":"theorem indep_iSup_of_disjoint {m : ι → MeasurableSpace Ω}\n    (h_le : ∀ i, m i ≤ _mΩ) (h_indep : iIndep m κ μ) {S T : Set ι} (hST : Disjoint S T) :\n    Indep (⨆ i ∈ S, m i) (⨆ i ∈ T, m i) κ μ := by\n  classical\n  rcases eq_or_ne μ 0 with rfl | hμ\n  · simp\n  obtain ⟨η, η_eq, hη⟩ : ∃ (η : Kernel α Ω), κ =ᵐ[μ] η ∧ IsMarkovKernel η :=\n    exists_ae_eq_isMarkovKernel h_indep.ae_isProbabilityMeasure hμ\n  apply Indep.congr (Filter.EventuallyEq.symm η_eq)\n  refine\n    IndepSets.indep (iSup₂_le fun i _ => h_le i) (iSup₂_le fun i _ => h_le i) ?_ ?_\n      (generateFrom_piiUnionInter_measurableSet m S).symm\n      (generateFrom_piiUnionInter_measurableSet m T).symm ?_\n  · exact isPiSystem_piiUnionInter _ (fun n => @isPiSystem_measurableSet Ω (m n)) _\n  · exact isPiSystem_piiUnionInter _ (fun n => @isPiSystem_measurableSet Ω (m n)) _\n  · exact indepSets_piiUnionInter_of_disjoint (h_indep.congr η_eq) hST\n\n"}
{"name":"ProbabilityTheory.Kernel.indep_iSup_of_directed_le","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nι : Type u_3\n_mα : MeasurableSpace α\nΩ : Type u_4\nm : ι → MeasurableSpace Ω\nm' m0 : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\nh_indep : ∀ (i : ι), ProbabilityTheory.Kernel.Indep (m i) m' κ μ\nh_le : ∀ (i : ι), LE.le (m i) m0\nh_le' : LE.le m' m0\nhm : Directed (fun x1 x2 => LE.le x1 x2) m\n⊢ ProbabilityTheory.Kernel.Indep (iSup fun i => m i) m' κ μ","decl":"theorem indep_iSup_of_directed_le {Ω} {m : ι → MeasurableSpace Ω} {m' m0 : MeasurableSpace Ω}\n    {κ : Kernel α Ω} {μ : Measure α} [IsZeroOrMarkovKernel κ] (h_indep : ∀ i, Indep (m i) m' κ μ)\n    (h_le : ∀ i, m i ≤ m0) (h_le' : m' ≤ m0) (hm : Directed (· ≤ ·) m) :\n    Indep (⨆ i, m i) m' κ μ := by\n  let p : ι → Set (Set Ω) := fun n => { t | MeasurableSet[m n] t }\n  have hp : ∀ n, IsPiSystem (p n) := fun n => @isPiSystem_measurableSet Ω (m n)\n  have h_gen_n : ∀ n, m n = generateFrom (p n) := fun n =>\n    (@generateFrom_measurableSet Ω (m n)).symm\n  have hp_supr_pi : IsPiSystem (⋃ n, p n) := isPiSystem_iUnion_of_directed_le p hp hm\n  let p' := { t : Set Ω | MeasurableSet[m'] t }\n  have hp'_pi : IsPiSystem p' := @isPiSystem_measurableSet Ω m'\n  have h_gen' : m' = generateFrom p' := (@generateFrom_measurableSet Ω m').symm\n  -- the π-systems defined are independent\n  have h_pi_system_indep : IndepSets (⋃ n, p n) p' κ μ := by\n    refine IndepSets.iUnion ?_\n    conv at h_indep =>\n      intro i\n      rw [h_gen_n i, h_gen']\n    exact fun n => (h_indep n).indepSets\n  -- now go from π-systems to σ-algebras\n  refine IndepSets.indep (iSup_le h_le) h_le' hp_supr_pi hp'_pi ?_ h_gen' h_pi_system_indep\n  exact (generateFrom_iUnion_measurableSet _).symm\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSet.indep_generateFrom_lt","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : Preorder ι\ns : ι → Set Ω\nhsm : ∀ (n : ι), MeasurableSet (s n)\nhs : ProbabilityTheory.Kernel.iIndepSet s κ μ\ni : ι\n⊢ ProbabilityTheory.Kernel.Indep (MeasurableSpace.generateFrom (Singleton.singleton (s i))) (MeasurableSpace.generateFrom (setOf fun t => Exists fun j => And (LT.lt j i) (Eq (s j) t))) κ μ","decl":"theorem iIndepSet.indep_generateFrom_lt [Preorder ι] {s : ι → Set Ω}\n    (hsm : ∀ n, MeasurableSet (s n)) (hs : iIndepSet s κ μ) (i : ι) :\n    Indep (generateFrom {s i}) (generateFrom { t | ∃ j < i, s j = t }) κ μ := by\n  convert iIndepSet.indep_generateFrom_of_disjoint hsm hs {i} { j | j < i }\n    (Set.disjoint_singleton_left.mpr (lt_irrefl _)) using 1\n  simp only [Set.mem_singleton_iff, exists_prop, exists_eq_left, Set.setOf_eq_eq_singleton']\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSet.indep_generateFrom_le","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : LinearOrder ι\ns : ι → Set Ω\nhsm : ∀ (n : ι), MeasurableSet (s n)\nhs : ProbabilityTheory.Kernel.iIndepSet s κ μ\ni k : ι\nhk : LT.lt i k\n⊢ ProbabilityTheory.Kernel.Indep (MeasurableSpace.generateFrom (Singleton.singleton (s k))) (MeasurableSpace.generateFrom (setOf fun t => Exists fun j => And (LE.le j i) (Eq (s j) t))) κ μ","decl":"theorem iIndepSet.indep_generateFrom_le [LinearOrder ι] {s : ι → Set Ω}\n    (hsm : ∀ n, MeasurableSet (s n)) (hs : iIndepSet s κ μ) (i : ι) {k : ι} (hk : i < k) :\n    Indep (generateFrom {s k}) (generateFrom { t | ∃ j ≤ i, s j = t }) κ μ := by\n  convert iIndepSet.indep_generateFrom_of_disjoint hsm hs {k} { j | j ≤ i }\n      (Set.disjoint_singleton_left.mpr hk.not_le) using 1\n  simp only [Set.mem_singleton_iff, exists_prop, exists_eq_left, Set.setOf_eq_eq_singleton']\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSet.indep_generateFrom_le_nat","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ns : Nat → Set Ω\nhsm : ∀ (n : Nat), MeasurableSet (s n)\nhs : ProbabilityTheory.Kernel.iIndepSet s κ μ\nn : Nat\n⊢ ProbabilityTheory.Kernel.Indep (MeasurableSpace.generateFrom (Singleton.singleton (s (HAdd.hAdd n 1)))) (MeasurableSpace.generateFrom (setOf fun t => Exists fun k => And (LE.le k n) (Eq (s k) t))) κ μ","decl":"theorem iIndepSet.indep_generateFrom_le_nat {s : ℕ → Set Ω}\n    (hsm : ∀ n, MeasurableSet (s n)) (hs : iIndepSet s κ μ) (n : ℕ) :\n    Indep (generateFrom {s (n + 1)}) (generateFrom { t | ∃ k ≤ n, s k = t }) κ μ :=\n  iIndepSet.indep_generateFrom_le hsm hs _ n.lt_succ_self\n\n"}
{"name":"ProbabilityTheory.Kernel.indep_iSup_of_monotone","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nι : Type u_3\n_mα : MeasurableSpace α\ninst✝¹ : SemilatticeSup ι\nΩ : Type u_4\nm : ι → MeasurableSpace Ω\nm' m0 : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\nh_indep : ∀ (i : ι), ProbabilityTheory.Kernel.Indep (m i) m' κ μ\nh_le : ∀ (i : ι), LE.le (m i) m0\nh_le' : LE.le m' m0\nhm : Monotone m\n⊢ ProbabilityTheory.Kernel.Indep (iSup fun i => m i) m' κ μ","decl":"theorem indep_iSup_of_monotone [SemilatticeSup ι] {Ω} {m : ι → MeasurableSpace Ω}\n    {m' m0 : MeasurableSpace Ω} {κ : Kernel α Ω} {μ : Measure α} [IsZeroOrMarkovKernel κ]\n    (h_indep : ∀ i, Indep (m i) m' κ μ) (h_le : ∀ i, m i ≤ m0) (h_le' : m' ≤ m0)\n    (hm : Monotone m) :\n    Indep (⨆ i, m i) m' κ μ :=\n  indep_iSup_of_directed_le h_indep h_le h_le' (Monotone.directed_le hm)\n\n"}
{"name":"ProbabilityTheory.Kernel.indep_iSup_of_antitone","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nι : Type u_3\n_mα : MeasurableSpace α\ninst✝¹ : SemilatticeInf ι\nΩ : Type u_4\nm : ι → MeasurableSpace Ω\nm' m0 : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\nh_indep : ∀ (i : ι), ProbabilityTheory.Kernel.Indep (m i) m' κ μ\nh_le : ∀ (i : ι), LE.le (m i) m0\nh_le' : LE.le m' m0\nhm : Antitone m\n⊢ ProbabilityTheory.Kernel.Indep (iSup fun i => m i) m' κ μ","decl":"theorem indep_iSup_of_antitone [SemilatticeInf ι] {Ω} {m : ι → MeasurableSpace Ω}\n    {m' m0 : MeasurableSpace Ω} {κ : Kernel α Ω} {μ : Measure α} [IsZeroOrMarkovKernel κ]\n    (h_indep : ∀ i, Indep (m i) m' κ μ) (h_le : ∀ i, m i ≤ m0) (h_le' : m' ≤ m0)\n    (hm : Antitone m) :\n    Indep (⨆ i, m i) m' κ μ :=\n  indep_iSup_of_directed_le h_indep h_le h_le' hm.directed_le\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSets.piiUnionInter_of_not_mem","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nπ : ι → Set (Set Ω)\na : ι\nS : Finset ι\nhp_ind : ProbabilityTheory.Kernel.iIndepSets π κ μ\nhaS : Not (Membership.mem S a)\n⊢ ProbabilityTheory.Kernel.IndepSets (piiUnionInter π ↑S) (π a) κ μ","decl":"theorem iIndepSets.piiUnionInter_of_not_mem {π : ι → Set (Set Ω)} {a : ι} {S : Finset ι}\n    (hp_ind : iIndepSets π κ μ) (haS : a ∉ S) :\n    IndepSets (piiUnionInter π S) (π a) κ μ := by\n  rintro t1 t2 ⟨s, hs_mem, ft1, hft1_mem, ht1_eq⟩ ht2_mem_pia\n  rw [Finset.coe_subset] at hs_mem\n  classical\n  let f := fun n => ite (n = a) t2 (ite (n ∈ s) (ft1 n) Set.univ)\n  have h_f_mem : ∀ n ∈ insert a s, f n ∈ π n := by\n    intro n hn_mem_insert\n    dsimp only [f]\n    cases' Finset.mem_insert.mp hn_mem_insert with hn_mem hn_mem\n    · simp [hn_mem, ht2_mem_pia]\n    · have hn_ne_a : n ≠ a := by rintro rfl; exact haS (hs_mem hn_mem)\n      simp [hn_ne_a, hn_mem, hft1_mem n hn_mem]\n  have h_f_mem_pi : ∀ n ∈ s, f n ∈ π n := fun x hxS => h_f_mem x (by simp [hxS])\n  have h_t1 : t1 = ⋂ n ∈ s, f n := by\n    suffices h_forall : ∀ n ∈ s, f n = ft1 n by\n      rw [ht1_eq]\n      ext x\n      simp_rw [Set.mem_iInter]\n      conv => lhs; intro i hns; rw [← h_forall i hns]\n    intro n hnS\n    have hn_ne_a : n ≠ a := by rintro rfl; exact haS (hs_mem hnS)\n    simp_rw [f, if_pos hnS, if_neg hn_ne_a]\n  have h_μ_t1 : ∀ᵐ a' ∂μ, κ a' t1 = ∏ n ∈ s, κ a' (f n) := by\n    filter_upwards [hp_ind s h_f_mem_pi] with a' ha'\n    rw [h_t1, ← ha']\n  have h_t2 : t2 = f a := by simp [f]\n  have h_μ_inter : ∀ᵐ a' ∂μ, κ a' (t1 ∩ t2) = ∏ n ∈ insert a s, κ a' (f n) := by\n    have h_t1_inter_t2 : t1 ∩ t2 = ⋂ n ∈ insert a s, f n := by\n      rw [h_t1, h_t2, Finset.set_biInter_insert, Set.inter_comm]\n    filter_upwards [hp_ind (insert a s) h_f_mem] with a' ha'\n    rw [h_t1_inter_t2, ← ha']\n  have has : a ∉ s := fun has_mem => haS (hs_mem has_mem)\n  filter_upwards [h_μ_t1, h_μ_inter] with a' ha1 ha2\n  rw [ha2, Finset.prod_insert has, h_t2, mul_comm, ha1]\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSets.iIndep","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nm : ι → MeasurableSpace Ω\nh_le : ∀ (i : ι), LE.le (m i) _mΩ\nπ : ι → Set (Set Ω)\nh_pi : ∀ (n : ι), IsPiSystem (π n)\nh_generate : ∀ (i : ι), Eq (m i) (MeasurableSpace.generateFrom (π i))\nh_ind : ProbabilityTheory.Kernel.iIndepSets π κ μ\n⊢ ProbabilityTheory.Kernel.iIndep m κ μ","decl":"/-- The measurable space structures generated by independent pi-systems are independent. -/\ntheorem iIndepSets.iIndep (m : ι → MeasurableSpace Ω)\n    (h_le : ∀ i, m i ≤ _mΩ) (π : ι → Set (Set Ω)) (h_pi : ∀ n, IsPiSystem (π n))\n    (h_generate : ∀ i, m i = generateFrom (π i)) (h_ind : iIndepSets π κ μ) :\n    iIndep m κ μ := by\n  classical\n  rcases eq_or_ne μ 0 with rfl | hμ\n  · simp\n  obtain ⟨η, η_eq, hη⟩ : ∃ (η : Kernel α Ω), κ =ᵐ[μ] η ∧ IsMarkovKernel η :=\n    exists_ae_eq_isMarkovKernel h_ind.ae_isProbabilityMeasure hμ\n  apply iIndep.congr (Filter.EventuallyEq.symm η_eq)\n  intro s f\n  refine Finset.induction ?_ ?_ s\n  · simp only [Finset.not_mem_empty, Set.mem_setOf_eq, IsEmpty.forall_iff, implies_true,\n      Set.iInter_of_empty, Set.iInter_univ, measure_univ, Finset.prod_empty,\n      Filter.eventually_true, forall_true_left]\n  · intro a S ha_notin_S h_rec hf_m\n    have hf_m_S : ∀ x ∈ S, MeasurableSet[m x] (f x) := fun x hx => hf_m x (by simp [hx])\n    let p := piiUnionInter π S\n    set m_p := generateFrom p with hS_eq_generate\n    have h_indep : Indep m_p (m a) η μ := by\n      have hp : IsPiSystem p := isPiSystem_piiUnionInter π h_pi S\n      have h_le' : ∀ i, generateFrom (π i) ≤ _mΩ := fun i ↦ (h_generate i).symm.trans_le (h_le i)\n      have hm_p : m_p ≤ _mΩ := generateFrom_piiUnionInter_le π h_le' S\n      exact IndepSets.indep hm_p (h_le a) hp (h_pi a) hS_eq_generate (h_generate a)\n        (iIndepSets.piiUnionInter_of_not_mem (h_ind.congr η_eq) ha_notin_S)\n    have h := h_indep.symm (f a) (⋂ n ∈ S, f n) (hf_m a (Finset.mem_insert_self a S)) ?_\n    · filter_upwards [h_rec hf_m_S, h] with a' ha' h'\n      rwa [Finset.set_biInter_insert, Finset.prod_insert ha_notin_S, ← ha']\n    · have h_le_p : ∀ i ∈ S, m i ≤ m_p := by\n        intros n hn\n        rw [hS_eq_generate, h_generate n]\n        exact le_generateFrom_piiUnionInter (S : Set ι) hn\n      have h_S_f : ∀ i ∈ S, MeasurableSet[m_p] (f i) :=\n        fun i hi ↦ (h_le_p i hi) (f i) (hf_m_S i hi)\n      exact S.measurableSet_biInter h_S_f\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSet_iff_iIndepSets_singleton","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nf : ι → Set Ω\nhf : ∀ (i : ι), MeasurableSet (f i)\n⊢ Iff (ProbabilityTheory.Kernel.iIndepSet f κ μ) (ProbabilityTheory.Kernel.iIndepSets (fun i => Singleton.singleton (f i)) κ μ)","decl":"theorem iIndepSet_iff_iIndepSets_singleton {_mΩ : MeasurableSpace Ω} {κ : Kernel α Ω}\n    {μ : Measure α} {f : ι → Set Ω} (hf : ∀ i, MeasurableSet (f i)) :\n    iIndepSet f κ μ ↔ iIndepSets (fun i ↦ {f i}) κ μ :=\n  ⟨iIndep.iIndepSets fun _ ↦ rfl,\n    iIndepSets.iIndep _ (fun i ↦ generateFrom_le <| by rintro t (rfl : t = _); exact hf _) _\n      (fun _ ↦ IsPiSystem.singleton _) fun _ ↦ rfl⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSet.meas_biInter","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nf : ι → Set Ω\nh : ProbabilityTheory.Kernel.iIndepSet f κ μ\ns : Finset ι\n⊢ Filter.Eventually (fun a => Eq ((κ a) (Set.iInter fun i => Set.iInter fun h => f i)) (s.prod fun i => (κ a) (f i))) (MeasureTheory.ae μ)","decl":"theorem iIndepSet.meas_biInter {_mΩ : MeasurableSpace Ω} {κ : Kernel α Ω}\n    {μ : Measure α} {f : ι → Set Ω} (h : iIndepSet f κ μ) (s : Finset ι) :\n    ∀ᵐ a ∂μ, κ a (⋂ i ∈ s, f i) = ∏ i ∈ s, κ a (f i) :=\n  iIndep.iIndepSets (fun _ ↦ rfl) h _ (by simp)\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSet_iff_meas_biInter","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nf : ι → Set Ω\nhf : ∀ (i : ι), MeasurableSet (f i)\n⊢ Iff (ProbabilityTheory.Kernel.iIndepSet f κ μ) (∀ (s : Finset ι), Filter.Eventually (fun a => Eq ((κ a) (Set.iInter fun i => Set.iInter fun h => f i)) (s.prod fun i => (κ a) (f i))) (MeasureTheory.ae μ))","decl":"theorem iIndepSet_iff_meas_biInter {_mΩ : MeasurableSpace Ω} {κ : Kernel α Ω}\n    {μ : Measure α} {f : ι → Set Ω} (hf : ∀ i, MeasurableSet (f i)) :\n    iIndepSet f κ μ ↔ ∀ s, ∀ᵐ a ∂μ, κ a (⋂ i ∈ s, f i) = ∏ i ∈ s, κ a (f i) :=\n  (iIndepSet_iff_iIndepSets_singleton hf).trans iIndepSets_singleton_iff\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSets.iIndepSet_of_mem","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nπ : ι → Set (Set Ω)\nf : ι → Set Ω\nhfπ : ∀ (i : ι), Membership.mem (π i) (f i)\nhf : ∀ (i : ι), MeasurableSet (f i)\nhπ : ProbabilityTheory.Kernel.iIndepSets π κ μ\n⊢ ProbabilityTheory.Kernel.iIndepSet f κ μ","decl":"theorem iIndepSets.iIndepSet_of_mem {_mΩ : MeasurableSpace Ω} {κ : Kernel α Ω}\n    {μ : Measure α} {π : ι → Set (Set Ω)} {f : ι → Set Ω}\n    (hfπ : ∀ i, f i ∈ π i) (hf : ∀ i, MeasurableSet (f i)) (hπ : iIndepSets π κ μ) :\n    iIndepSet f κ μ :=\n  (iIndepSet_iff_meas_biInter hf).2 fun _t ↦ hπ.meas_biInter _ fun _i _ ↦ hfπ _\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSet_iff_indepSets_singleton","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\ns t : Set Ω\nm0 : MeasurableSpace Ω\nhs_meas : MeasurableSet s\nht_meas : MeasurableSet t\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ Iff (ProbabilityTheory.Kernel.IndepSet s t κ μ) (ProbabilityTheory.Kernel.IndepSets (Singleton.singleton s) (Singleton.singleton t) κ μ)","decl":"theorem indepSet_iff_indepSets_singleton {m0 : MeasurableSpace Ω} (hs_meas : MeasurableSet s)\n    (ht_meas : MeasurableSet t) (κ : Kernel α Ω) (μ : Measure α)\n    [IsZeroOrMarkovKernel κ] :\n    IndepSet s t κ μ ↔ IndepSets {s} {t} κ μ :=\n  ⟨Indep.indepSets, fun h =>\n    IndepSets.indep\n      (generateFrom_le fun u hu => by rwa [Set.mem_singleton_iff.mp hu])\n      (generateFrom_le fun u hu => by rwa [Set.mem_singleton_iff.mp hu])\n      (IsPiSystem.singleton s) (IsPiSystem.singleton t) rfl rfl h⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.indepSet_iff_measure_inter_eq_mul","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\ns t : Set Ω\n_m0 : MeasurableSpace Ω\nhs_meas : MeasurableSet s\nht_meas : MeasurableSet t\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ Iff (ProbabilityTheory.Kernel.IndepSet s t κ μ) (Filter.Eventually (fun a => Eq ((κ a) (Inter.inter s t)) (HMul.hMul ((κ a) s) ((κ a) t))) (MeasureTheory.ae μ))","decl":"theorem indepSet_iff_measure_inter_eq_mul {_m0 : MeasurableSpace Ω} (hs_meas : MeasurableSet s)\n    (ht_meas : MeasurableSet t) (κ : Kernel α Ω) (μ : Measure α)\n    [IsZeroOrMarkovKernel κ] :\n    IndepSet s t κ μ ↔ ∀ᵐ a ∂μ, κ a (s ∩ t) = κ a s * κ a t :=\n  (indepSet_iff_indepSets_singleton hs_meas ht_meas κ μ).trans indepSets_singleton_iff\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSet.measure_inter_eq_mul","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\ns t : Set Ω\n_m0 : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh : ProbabilityTheory.Kernel.IndepSet s t κ μ\n⊢ Filter.Eventually (fun a => Eq ((κ a) (Inter.inter s t)) (HMul.hMul ((κ a) s) ((κ a) t))) (MeasureTheory.ae μ)","decl":"theorem IndepSet.measure_inter_eq_mul {_m0 : MeasurableSpace Ω} (κ : Kernel α Ω) (μ : Measure α)\n    (h : IndepSet s t κ μ) : ∀ᵐ a ∂μ, κ a (s ∩ t) = κ a s * κ a t :=\n  Indep.indepSets h _ _ (by simp) (by simp)\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepSets.indepSet_of_mem","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\ns t : Set Ω\nS T : Set (Set Ω)\n_m0 : MeasurableSpace Ω\nhs : Membership.mem S s\nht : Membership.mem T t\nhs_meas : MeasurableSet s\nht_meas : MeasurableSet t\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\nh_indep : ProbabilityTheory.Kernel.IndepSets S T κ μ\n⊢ ProbabilityTheory.Kernel.IndepSet s t κ μ","decl":"theorem IndepSets.indepSet_of_mem {_m0 : MeasurableSpace Ω} (hs : s ∈ S) (ht : t ∈ T)\n    (hs_meas : MeasurableSet s) (ht_meas : MeasurableSet t)\n    (κ : Kernel α Ω) (μ : Measure α) [IsZeroOrMarkovKernel κ]\n    (h_indep : IndepSets S T κ μ) :\n    IndepSet s t κ μ :=\n  (indepSet_iff_measure_inter_eq_mul hs_meas ht_meas κ μ).mpr (h_indep s t hs ht)\n\n"}
{"name":"ProbabilityTheory.Kernel.Indep.indepSet_of_measurableSet","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\nm₁ m₂ x✝ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nh_indep : ProbabilityTheory.Kernel.Indep m₁ m₂ κ μ\ns t : Set Ω\nhs : MeasurableSet s\nht : MeasurableSet t\n⊢ ProbabilityTheory.Kernel.IndepSet s t κ μ","decl":"theorem Indep.indepSet_of_measurableSet {m₁ m₂ _ : MeasurableSpace Ω} {κ : Kernel α Ω}\n    {μ : Measure α}\n    (h_indep : Indep m₁ m₂ κ μ) {s t : Set Ω} (hs : MeasurableSet[m₁] s)\n    (ht : MeasurableSet[m₂] t) :\n    IndepSet s t κ μ := by\n  refine fun s' t' hs' ht' => h_indep s' t' ?_ ?_\n  · induction s', hs' using generateFrom_induction with\n    | hC t ht => exact ht ▸ hs\n    | empty => exact @MeasurableSet.empty _ m₁\n    | compl u _ hu => exact hu.compl\n    | iUnion f _ hf => exact .iUnion hf\n  · induction t', ht' using generateFrom_induction with\n    | hC s hs => exact hs ▸ ht\n    | empty => exact @MeasurableSet.empty _ m₂\n    | compl u _ hu => exact hu.compl\n    | iUnion f _ hf => exact .iUnion hf\n\n"}
{"name":"ProbabilityTheory.Kernel.indep_iff_forall_indepSet","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\nm₁ m₂ _m0 : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\n⊢ Iff (ProbabilityTheory.Kernel.Indep m₁ m₂ κ μ) (∀ (s t : Set Ω), MeasurableSet s → MeasurableSet t → ProbabilityTheory.Kernel.IndepSet s t κ μ)","decl":"theorem indep_iff_forall_indepSet (m₁ m₂ : MeasurableSpace Ω) {_m0 : MeasurableSpace Ω}\n    (κ : Kernel α Ω) (μ : Measure α) :\n    Indep m₁ m₂ κ μ ↔ ∀ s t, MeasurableSet[m₁] s → MeasurableSet[m₂] t → IndepSet s t κ μ :=\n  ⟨fun h => fun _s _t hs ht => h.indepSet_of_measurableSet hs ht, fun h s t hs ht =>\n    h s t hs ht s t (measurableSet_generateFrom (Set.mem_singleton s))\n      (measurableSet_generateFrom (Set.mem_singleton t))⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.indepFun_iff_measure_inter_preimage_eq_mul","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nβ : Type u_4\nβ' : Type u_5\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nf : Ω → β\ng : Ω → β'\nmβ : MeasurableSpace β\nmβ' : MeasurableSpace β'\n⊢ Iff (ProbabilityTheory.Kernel.IndepFun f g κ μ) (∀ (s : Set β) (t : Set β'), MeasurableSet s → MeasurableSet t → Filter.Eventually (fun a => Eq ((κ a) (Inter.inter (Set.preimage f s) (Set.preimage g t))) (HMul.hMul ((κ a) (Set.preimage f s)) ((κ a) (Set.preimage g t)))) (MeasureTheory.ae μ))","decl":"theorem indepFun_iff_measure_inter_preimage_eq_mul {mβ : MeasurableSpace β}\n    {mβ' : MeasurableSpace β'} :\n    IndepFun f g κ μ ↔\n      ∀ s t, MeasurableSet s → MeasurableSet t\n        → ∀ᵐ a ∂μ, κ a (f ⁻¹' s ∩ g ⁻¹' t) = κ a (f ⁻¹' s) * κ a (g ⁻¹' t) := by\n  constructor <;> intro h\n  · refine fun s t hs ht => h (f ⁻¹' s) (g ⁻¹' t) ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  · rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩; exact h s t hs ht\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepFun.measure_inter_preimage_eq_mul","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nβ : Type u_4\nβ' : Type u_5\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nf : Ω → β\ng : Ω → β'\nmβ : MeasurableSpace β\nmβ' : MeasurableSpace β'\na✝² : ProbabilityTheory.Kernel.IndepFun f g κ μ\ns : Set β\nt : Set β'\na✝¹ : MeasurableSet s\na✝ : MeasurableSet t\n⊢ Filter.Eventually (fun a => Eq ((κ a) (Inter.inter (Set.preimage f s) (Set.preimage g t))) (HMul.hMul ((κ a) (Set.preimage f s)) ((κ a) (Set.preimage g t)))) (MeasureTheory.ae μ)","decl":"alias ⟨IndepFun.measure_inter_preimage_eq_mul, _⟩ := indepFun_iff_measure_inter_preimage_eq_mul\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun_iff_measure_inter_preimage_eq_mul","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nι : Type u_8\nβ : ι → Type u_9\nm : (x : ι) → MeasurableSpace (β x)\nf : (i : ι) → Ω → β i\n⊢ Iff (ProbabilityTheory.Kernel.iIndepFun m f κ μ) (∀ (S : Finset ι) {sets : (i : ι) → Set (β i)}, (∀ (i : ι), Membership.mem S i → MeasurableSet (sets i)) → Filter.Eventually (fun a => Eq ((κ a) (Set.iInter fun i => Set.iInter fun h => Set.preimage (f i) (sets i))) (S.prod fun i => (κ a) (Set.preimage (f i) (sets i)))) (MeasureTheory.ae μ))","decl":"theorem iIndepFun_iff_measure_inter_preimage_eq_mul {ι : Type*} {β : ι → Type*}\n    (m : ∀ x, MeasurableSpace (β x)) (f : ∀ i, Ω → β i) :\n    iIndepFun m f κ μ ↔\n      ∀ (S : Finset ι) {sets : ∀ i : ι, Set (β i)} (_H : ∀ i, i ∈ S → MeasurableSet[m i] (sets i)),\n        ∀ᵐ a ∂μ, κ a (⋂ i ∈ S, (f i) ⁻¹' (sets i)) = ∏ i ∈ S, κ a ((f i) ⁻¹' (sets i)) := by\n  refine ⟨fun h S sets h_meas => h _ fun i hi_mem => ⟨sets i, h_meas i hi_mem, rfl⟩, ?_⟩\n  intro h S setsΩ h_meas\n  classical\n  let setsβ : ∀ i : ι, Set (β i) := fun i =>\n    dite (i ∈ S) (fun hi_mem => (h_meas i hi_mem).choose) fun _ => Set.univ\n  have h_measβ : ∀ i ∈ S, MeasurableSet[m i] (setsβ i) := by\n    intro i hi_mem\n    simp_rw [setsβ, dif_pos hi_mem]\n    exact (h_meas i hi_mem).choose_spec.1\n  have h_preim : ∀ i ∈ S, setsΩ i = f i ⁻¹' setsβ i := by\n    intro i hi_mem\n    simp_rw [setsβ, dif_pos hi_mem]\n    exact (h_meas i hi_mem).choose_spec.2.symm\n  have h_left_eq : ∀ a, κ a (⋂ i ∈ S, setsΩ i) = κ a (⋂ i ∈ S, (f i) ⁻¹' (setsβ i)) := by\n    intro a\n    congr with x\n    simp_rw [Set.mem_iInter]\n    constructor <;> intro h i hi_mem <;> specialize h i hi_mem\n    · rwa [h_preim i hi_mem] at h\n    · rwa [h_preim i hi_mem]\n  have h_right_eq : ∀ a, (∏ i ∈ S, κ a (setsΩ i)) = ∏ i ∈ S, κ a ((f i) ⁻¹' (setsβ i)) := by\n    refine fun a ↦ Finset.prod_congr rfl fun i hi_mem => ?_\n    rw [h_preim i hi_mem]\n  filter_upwards [h S h_measβ] with a ha\n  rw [h_left_eq a, h_right_eq a, ha]\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.measure_inter_preimage_eq_mul","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nι : Type u_8\nβ : ι → Type u_9\nm : (x : ι) → MeasurableSpace (β x)\nf : (i : ι) → Ω → β i\na✝ : ProbabilityTheory.Kernel.iIndepFun m f κ μ\nS : Finset ι\nsets : (i : ι) → Set (β i)\n_H : ∀ (i : ι), Membership.mem S i → MeasurableSet (sets i)\n⊢ Filter.Eventually (fun a => Eq ((κ a) (Set.iInter fun i => Set.iInter fun h => Set.preimage (f i) (sets i))) (S.prod fun i => (κ a) (Set.preimage (f i) (sets i)))) (MeasureTheory.ae μ)","decl":"alias ⟨iIndepFun.measure_inter_preimage_eq_mul, _⟩ := iIndepFun_iff_measure_inter_preimage_eq_mul\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.comp","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : ι → Type u_8\nγ : ι → Type u_9\nmβ : (i : ι) → MeasurableSpace (β i)\nmγ : (i : ι) → MeasurableSpace (γ i)\nf : (i : ι) → Ω → β i\nh : ProbabilityTheory.Kernel.iIndepFun mβ f κ μ\ng : (i : ι) → β i → γ i\nhg : ∀ (i : ι), Measurable (g i)\n⊢ ProbabilityTheory.Kernel.iIndepFun mγ (fun i => Function.comp (g i) (f i)) κ μ","decl":"lemma iIndepFun.comp {β γ : ι → Type*} {mβ : ∀ i, MeasurableSpace (β i)}\n    {mγ : ∀ i, MeasurableSpace (γ i)} {f : ∀ i, Ω → β i}\n    (h : iIndepFun mβ f κ μ) (g : ∀ i, β i → γ i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun mγ (fun i ↦ g i ∘ f i) κ μ := by\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul] at h ⊢\n  refine fun t s hs ↦ ?_\n  have := h t (sets := fun i ↦ g i ⁻¹' (s i)) (fun i a ↦ hg i (hs i a))\n  filter_upwards [this] with a ha\n  simp_rw [Set.preimage_comp]\n  exact ha\n\n"}
{"name":"ProbabilityTheory.Kernel.indepFun_iff_indepSet_preimage","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nβ : Type u_4\nβ' : Type u_5\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nf : Ω → β\ng : Ω → β'\nmβ : MeasurableSpace β\nmβ' : MeasurableSpace β'\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\nhf : Measurable f\nhg : Measurable g\n⊢ Iff (ProbabilityTheory.Kernel.IndepFun f g κ μ) (∀ (s : Set β) (t : Set β'), MeasurableSet s → MeasurableSet t → ProbabilityTheory.Kernel.IndepSet (Set.preimage f s) (Set.preimage g t) κ μ)","decl":"theorem indepFun_iff_indepSet_preimage {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    [IsZeroOrMarkovKernel κ] (hf : Measurable f) (hg : Measurable g) :\n    IndepFun f g κ μ ↔\n      ∀ s t, MeasurableSet s → MeasurableSet t → IndepSet (f ⁻¹' s) (g ⁻¹' t) κ μ := by\n  refine indepFun_iff_measure_inter_preimage_eq_mul.trans ?_\n  constructor <;> intro h s t hs ht <;> specialize h s t hs ht\n  · rwa [indepSet_iff_measure_inter_eq_mul (hf hs) (hg ht) κ μ]\n  · rwa [← indepSet_iff_measure_inter_eq_mul (hf hs) (hg ht) κ μ]\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepFun.symm","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nβ : Type u_4\nβ' : Type u_5\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nf : Ω → β\ng : Ω → β'\nx✝¹ : MeasurableSpace β\nx✝ : MeasurableSpace β'\nhfg : ProbabilityTheory.Kernel.IndepFun f g κ μ\n⊢ ProbabilityTheory.Kernel.IndepFun g f κ μ","decl":"@[symm]\nnonrec theorem IndepFun.symm {_ : MeasurableSpace β} {_ : MeasurableSpace β'}\n    (hfg : IndepFun f g κ μ) : IndepFun g f κ μ := hfg.symm\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepFun.ae_eq","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nβ : Type u_4\nβ' : Type u_5\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nf : Ω → β\ng : Ω → β'\nmβ : MeasurableSpace β\nmβ' : MeasurableSpace β'\nf' : Ω → β\ng' : Ω → β'\nhfg : ProbabilityTheory.Kernel.IndepFun f g κ μ\nhf : Filter.Eventually (fun a => (MeasureTheory.ae (κ a)).EventuallyEq f f') (MeasureTheory.ae μ)\nhg : Filter.Eventually (fun a => (MeasureTheory.ae (κ a)).EventuallyEq g g') (MeasureTheory.ae μ)\n⊢ ProbabilityTheory.Kernel.IndepFun f' g' κ μ","decl":"theorem IndepFun.ae_eq {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f' : Ω → β} {g' : Ω → β'} (hfg : IndepFun f g κ μ)\n    (hf : ∀ᵐ a ∂μ, f =ᵐ[κ a] f') (hg : ∀ᵐ a ∂μ, g =ᵐ[κ a] g') :\n    IndepFun f' g' κ μ := by\n  rintro _ _ ⟨A, hA, rfl⟩ ⟨B, hB, rfl⟩\n  filter_upwards [hf, hg, hfg _ _ ⟨_, hA, rfl⟩ ⟨_, hB, rfl⟩] with a hf' hg' hfg'\n  have h1 : f ⁻¹' A =ᵐ[κ a] f' ⁻¹' A := hf'.fun_comp A\n  have h2 : g ⁻¹' B =ᵐ[κ a] g' ⁻¹' B := hg'.fun_comp B\n  rwa [← measure_congr h1, ← measure_congr h2, ← measure_congr (h1.inter h2)]\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepFun.comp","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nβ : Type u_4\nβ' : Type u_5\nγ : Type u_6\nγ' : Type u_7\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nf : Ω → β\ng : Ω → β'\nmβ : MeasurableSpace β\nmβ' : MeasurableSpace β'\nmγ : MeasurableSpace γ\nmγ' : MeasurableSpace γ'\nφ : β → γ\nψ : β' → γ'\nhfg : ProbabilityTheory.Kernel.IndepFun f g κ μ\nhφ : Measurable φ\nhψ : Measurable ψ\n⊢ ProbabilityTheory.Kernel.IndepFun (Function.comp φ f) (Function.comp ψ g) κ μ","decl":"theorem IndepFun.comp {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {mγ : MeasurableSpace γ} {mγ' : MeasurableSpace γ'} {φ : β → γ} {ψ : β' → γ'}\n    (hfg : IndepFun f g κ μ) (hφ : Measurable φ) (hψ : Measurable ψ) :\n    IndepFun (φ ∘ f) (ψ ∘ g) κ μ := by\n  rintro _ _ ⟨A, hA, rfl⟩ ⟨B, hB, rfl⟩\n  apply hfg\n  · exact ⟨φ ⁻¹' A, hφ hA, Set.preimage_comp.symm⟩\n  · exact ⟨ψ ⁻¹' B, hψ hB, Set.preimage_comp.symm⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepFun.neg_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nβ : Type u_4\nβ' : Type u_5\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nf : Ω → β\ng : Ω → β'\n_mβ : MeasurableSpace β\n_mβ' : MeasurableSpace β'\ninst✝¹ : Neg β'\ninst✝ : MeasurableNeg β'\nhfg : ProbabilityTheory.Kernel.IndepFun f g κ μ\n⊢ ProbabilityTheory.Kernel.IndepFun f (Neg.neg g) κ μ","decl":"theorem IndepFun.neg_right {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'} [Neg β']\n    [MeasurableNeg β'] (hfg : IndepFun f g κ μ)  :\n    IndepFun f (-g) κ μ := hfg.comp measurable_id measurable_neg\n\n"}
{"name":"ProbabilityTheory.Kernel.IndepFun.neg_left","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nβ : Type u_4\nβ' : Type u_5\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nf : Ω → β\ng : Ω → β'\n_mβ : MeasurableSpace β\n_mβ' : MeasurableSpace β'\ninst✝¹ : Neg β\ninst✝ : MeasurableNeg β\nhfg : ProbabilityTheory.Kernel.IndepFun f g κ μ\n⊢ ProbabilityTheory.Kernel.IndepFun (Neg.neg f) g κ μ","decl":"theorem IndepFun.neg_left {_mβ : MeasurableSpace β} {_mβ' : MeasurableSpace β'} [Neg β]\n    [MeasurableNeg β] (hfg : IndepFun f g κ μ) :\n    IndepFun (-f) g κ μ := hfg.comp measurable_neg measurable_id\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.of_subsingleton","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : ι → Type u_8\nm : (i : ι) → MeasurableSpace (β i)\nf : (i : ι) → Ω → β i\ninst✝¹ : ProbabilityTheory.IsMarkovKernel κ\ninst✝ : Subsingleton ι\n⊢ ProbabilityTheory.Kernel.iIndepFun m f κ μ","decl":"@[nontriviality]\nlemma iIndepFun.of_subsingleton [IsMarkovKernel κ] [Subsingleton ι] : iIndepFun m f κ μ := by\n  refine (iIndepFun_iff_measure_inter_preimage_eq_mul ..).2 fun s f' hf' ↦ ?_\n  obtain rfl | ⟨x, hx⟩ := s.eq_empty_or_nonempty\n  · simp\n  · have : s = {x} := by ext y; simp [Subsingleton.elim y x, hx]\n    simp [this]\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_finset","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : ι → Type u_8\nm : (i : ι) → MeasurableSpace (β i)\nf : (i : ι) → Ω → β i\nS T : Finset ι\nhST : Disjoint S T\nhf_Indep : ProbabilityTheory.Kernel.iIndepFun m f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\n⊢ ProbabilityTheory.Kernel.IndepFun (fun a i => f (↑i) a) (fun a i => f (↑i) a) κ μ","decl":"/-- If `f` is a family of mutually independent random variables (`iIndepFun m f μ`) and `S, T` are\ntwo disjoint finite index sets, then the tuple formed by `f i` for `i ∈ S` is independent of the\ntuple `(f i)_i` for `i ∈ T`. -/\ntheorem iIndepFun.indepFun_finset (S T : Finset ι) (hST : Disjoint S T)\n    (hf_Indep : iIndepFun m f κ μ) (hf_meas : ∀ i, Measurable (f i)) :\n    IndepFun (fun a (i : S) => f i a) (fun a (i : T) => f i a) κ μ := by\n  rcases eq_or_ne μ 0 with rfl | hμ\n  · simp\n  obtain ⟨η, η_eq, hη⟩ : ∃ (η : Kernel α Ω), κ =ᵐ[μ] η ∧ IsMarkovKernel η :=\n    exists_ae_eq_isMarkovKernel hf_Indep.ae_isProbabilityMeasure hμ\n  apply IndepFun.congr (Filter.EventuallyEq.symm η_eq)\n  -- We introduce π-systems, built from the π-system of boxes which generates `MeasurableSpace.pi`.\n  let πSβ := Set.pi (Set.univ : Set S) ''\n    Set.pi (Set.univ : Set S) fun i => { s : Set (β i) | MeasurableSet[m i] s }\n  let πS := { s : Set Ω | ∃ t ∈ πSβ, (fun a (i : S) => f i a) ⁻¹' t = s }\n  have hπS_pi : IsPiSystem πS := by exact IsPiSystem.comap (@isPiSystem_pi _ _ ?_) _\n  have hπS_gen : (MeasurableSpace.pi.comap fun a (i : S) => f i a) = generateFrom πS := by\n    rw [generateFrom_pi.symm, comap_generateFrom]\n    congr\n  let πTβ := Set.pi (Set.univ : Set T) ''\n      Set.pi (Set.univ : Set T) fun i => { s : Set (β i) | MeasurableSet[m i] s }\n  let πT := { s : Set Ω | ∃ t ∈ πTβ, (fun a (i : T) => f i a) ⁻¹' t = s }\n  have hπT_pi : IsPiSystem πT := by exact IsPiSystem.comap (@isPiSystem_pi _ _ ?_) _\n  have hπT_gen : (MeasurableSpace.pi.comap fun a (i : T) => f i a) = generateFrom πT := by\n    rw [generateFrom_pi.symm, comap_generateFrom]\n    congr\n  -- To prove independence, we prove independence of the generating π-systems.\n  refine IndepSets.indep (Measurable.comap_le (measurable_pi_iff.mpr fun i => hf_meas i))\n    (Measurable.comap_le (measurable_pi_iff.mpr fun i => hf_meas i)) hπS_pi hπT_pi hπS_gen hπT_gen\n    ?_\n  rintro _ _ ⟨s, ⟨sets_s, hs1, hs2⟩, rfl⟩ ⟨t, ⟨sets_t, ht1, ht2⟩, rfl⟩\n  simp only [Set.mem_univ_pi, Set.mem_setOf_eq] at hs1 ht1\n  rw [← hs2, ← ht2]\n  classical\n  let sets_s' : ∀ i : ι, Set (β i) := fun i =>\n    dite (i ∈ S) (fun hi => sets_s ⟨i, hi⟩) fun _ => Set.univ\n  have h_sets_s'_eq : ∀ {i} (hi : i ∈ S), sets_s' i = sets_s ⟨i, hi⟩ := by\n    intro i hi; simp_rw [sets_s', dif_pos hi]\n  have h_sets_s'_univ : ∀ {i} (_hi : i ∈ T), sets_s' i = Set.univ := by\n    intro i hi; simp_rw [sets_s', dif_neg (Finset.disjoint_right.mp hST hi)]\n  let sets_t' : ∀ i : ι, Set (β i) := fun i =>\n    dite (i ∈ T) (fun hi => sets_t ⟨i, hi⟩) fun _ => Set.univ\n  have h_sets_t'_univ : ∀ {i} (_hi : i ∈ S), sets_t' i = Set.univ := by\n    intro i hi; simp_rw [sets_t', dif_neg (Finset.disjoint_left.mp hST hi)]\n  have h_meas_s' : ∀ i ∈ S, MeasurableSet (sets_s' i) := by\n    intro i hi; rw [h_sets_s'_eq hi]; exact hs1 _\n  have h_meas_t' : ∀ i ∈ T, MeasurableSet (sets_t' i) := by\n    intro i hi; simp_rw [sets_t', dif_pos hi]; exact ht1 _\n  have h_eq_inter_S : (fun (ω : Ω) (i : ↥S) =>\n    f (↑i) ω) ⁻¹' Set.pi Set.univ sets_s = ⋂ i ∈ S, f i ⁻¹' sets_s' i := by\n    ext1 x\n    simp_rw [Set.mem_preimage, Set.mem_univ_pi, Set.mem_iInter]\n    constructor <;> intro h\n    · intro i hi; simp only [h_sets_s'_eq hi, Set.mem_preimage]; exact h ⟨i, hi⟩\n    · rintro ⟨i, hi⟩; specialize h i hi; simp only [sets_s'] at h; rwa [dif_pos hi] at h\n  have h_eq_inter_T : (fun (ω : Ω) (i : ↥T) => f (↑i) ω) ⁻¹' Set.pi Set.univ sets_t\n    = ⋂ i ∈ T, f i ⁻¹' sets_t' i := by\n    ext1 x\n    simp only [Set.mem_preimage, Set.mem_univ_pi, Set.mem_iInter]\n    constructor <;> intro h\n    · intro i hi; simp_rw [sets_t', dif_pos hi]; exact h ⟨i, hi⟩\n    · rintro ⟨i, hi⟩; specialize h i hi; simp_rw [sets_t', dif_pos hi] at h; exact h\n  replace hf_Indep := hf_Indep.congr η_eq\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul] at hf_Indep\n  have h_Inter_inter :\n    ((⋂ i ∈ S, f i ⁻¹' sets_s' i) ∩ ⋂ i ∈ T, f i ⁻¹' sets_t' i) =\n      ⋂ i ∈ S ∪ T, f i ⁻¹' (sets_s' i ∩ sets_t' i) := by\n    ext1 x\n    simp_rw [Set.mem_inter_iff, Set.mem_iInter, Set.mem_preimage, Finset.mem_union]\n    constructor <;> intro h\n    · intro i hi\n      cases' hi with hiS hiT\n      · replace h := h.1 i hiS\n        simp_rw [sets_s', sets_t', dif_pos hiS, dif_neg (Finset.disjoint_left.mp hST hiS)]\n        simp only [sets_s'] at h\n        exact ⟨by rwa [dif_pos hiS] at h, Set.mem_univ _⟩\n      · replace h := h.2 i hiT\n        simp_rw [sets_s', sets_t', dif_pos hiT, dif_neg (Finset.disjoint_right.mp hST hiT)]\n        simp only [sets_t'] at h\n        exact ⟨Set.mem_univ _, by rwa [dif_pos hiT] at h⟩\n    · exact ⟨fun i hi => (h i (Or.inl hi)).1, fun i hi => (h i (Or.inr hi)).2⟩\n  have h_meas_inter : ∀ i ∈ S ∪ T, MeasurableSet (sets_s' i ∩ sets_t' i) := by\n    intros i hi_mem\n    rw [Finset.mem_union] at hi_mem\n    cases' hi_mem with hi_mem hi_mem\n    · rw [h_sets_t'_univ hi_mem, Set.inter_univ]\n      exact h_meas_s' i hi_mem\n    · rw [h_sets_s'_univ hi_mem, Set.univ_inter]\n      exact h_meas_t' i hi_mem\n  filter_upwards [hf_Indep S h_meas_s', hf_Indep T h_meas_t', hf_Indep (S ∪ T) h_meas_inter]\n    with a h_indepS h_indepT h_indepST\n  rw [h_eq_inter_S, h_eq_inter_T, h_indepS, h_indepT, h_Inter_inter, h_indepST,\n    Finset.prod_union hST]\n  congr 1\n  · refine Finset.prod_congr rfl fun i hi => ?_\n    rw [h_sets_t'_univ hi, Set.inter_univ]\n  · refine Finset.prod_congr rfl fun i hi => ?_\n    rw [h_sets_s'_univ hi, Set.univ_inter]\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_prod_mk","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : ι → Type u_8\nm : (i : ι) → MeasurableSpace (β i)\nf : (i : ι) → Ω → β i\nhf_Indep : ProbabilityTheory.Kernel.iIndepFun m f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhik : Ne i k\nhjk : Ne j k\n⊢ ProbabilityTheory.Kernel.IndepFun (fun a => { fst := f i a, snd := f j a }) (f k) κ μ","decl":"theorem iIndepFun.indepFun_prod_mk (hf_Indep : iIndepFun m f κ μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hik : i ≠ k) (hjk : j ≠ k) :\n    IndepFun (fun a => (f i a, f j a)) (f k) κ μ := by\n  classical\n  have h_right : f k =\n    (fun p : ∀ j : ({k} : Finset ι), β j => p ⟨k, Finset.mem_singleton_self k⟩) ∘\n    fun a (j : ({k} : Finset ι)) => f j a := rfl\n  have h_meas_right :  Measurable fun p : ∀ j : ({k} : Finset ι),\n    β j => p ⟨k, Finset.mem_singleton_self k⟩ := measurable_pi_apply _\n  let s : Finset ι := {i, j}\n  have h_left : (fun ω => (f i ω, f j ω)) = (fun p : ∀ l : s, β l =>\n    (p ⟨i, Finset.mem_insert_self i _⟩,\n    p ⟨j, Finset.mem_insert_of_mem (Finset.mem_singleton_self _)⟩)) ∘ fun a (j : s) => f j a := by\n    ext1 a\n    simp only [Prod.mk.inj_iff]\n    constructor\n  have h_meas_left : Measurable fun p : ∀ l : s, β l =>\n    (p ⟨i, Finset.mem_insert_self i _⟩,\n    p ⟨j, Finset.mem_insert_of_mem (Finset.mem_singleton_self _)⟩) :=\n      Measurable.prod (measurable_pi_apply _) (measurable_pi_apply _)\n  rw [h_left, h_right]\n  refine (hf_Indep.indepFun_finset s {k} ?_ hf_meas).comp h_meas_left h_meas_right\n  rw [Finset.disjoint_singleton_right]\n  simp only [s, Finset.mem_insert, Finset.mem_singleton, not_or]\n  exact ⟨hik.symm, hjk.symm⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_prod_mk_prod_mk","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : ι → Type u_8\nm : (i : ι) → MeasurableSpace (β i)\nf : (i : ι) → Ω → β i\nhf_indep : ProbabilityTheory.Kernel.iIndepFun m f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k l : ι\nhik : Ne i k\nhil : Ne i l\nhjk : Ne j k\nhjl : Ne j l\n⊢ ProbabilityTheory.Kernel.IndepFun (fun a => { fst := f i a, snd := f j a }) (fun a => { fst := f k a, snd := f l a }) κ μ","decl":"open Finset in\nlemma iIndepFun.indepFun_prod_mk_prod_mk (hf_indep : iIndepFun m f κ μ)\n    (hf_meas : ∀ i, Measurable (f i))\n    (i j k l : ι) (hik : i ≠ k) (hil : i ≠ l) (hjk : j ≠ k) (hjl : j ≠ l) :\n    IndepFun (fun a ↦ (f i a, f j a)) (fun a ↦ (f k a, f l a)) κ μ := by\n  classical\n  let g (i j : ι) (v : Π x : ({i, j} : Finset ι), β x) : β i × β j :=\n    ⟨v ⟨i, mem_insert_self _ _⟩, v ⟨j, mem_insert_of_mem <| mem_singleton_self _⟩⟩\n  have hg (i j : ι) : Measurable (g i j) := by fun_prop\n  exact (hf_indep.indepFun_finset {i, j} {k, l} (by aesop) hf_meas).comp (hg i j) (hg k l)\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_add_left","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : Add β\ninst✝ : MeasurableAdd₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhik : Ne i k\nhjk : Ne j k\n⊢ ProbabilityTheory.Kernel.IndepFun (HAdd.hAdd (f i) (f j)) (f k) κ μ","decl":"@[to_additive]\nlemma iIndepFun.indepFun_mul_left (hf_indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hik : i ≠ k) (hjk : j ≠ k) :\n    IndepFun (f i * f j) (f k) κ μ := by\n  have : IndepFun (fun ω => (f i ω, f j ω)) (f k) κ μ :=\n    hf_indep.indepFun_prod_mk hf_meas i j k hik hjk\n  simpa using this.comp (measurable_fst.mul measurable_snd) measurable_id\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_mul_left","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : Mul β\ninst✝ : MeasurableMul₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhik : Ne i k\nhjk : Ne j k\n⊢ ProbabilityTheory.Kernel.IndepFun (HMul.hMul (f i) (f j)) (f k) κ μ","decl":"@[to_additive]\nlemma iIndepFun.indepFun_mul_left (hf_indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hik : i ≠ k) (hjk : j ≠ k) :\n    IndepFun (f i * f j) (f k) κ μ := by\n  have : IndepFun (fun ω => (f i ω, f j ω)) (f k) κ μ :=\n    hf_indep.indepFun_prod_mk hf_meas i j k hik hjk\n  simpa using this.comp (measurable_fst.mul measurable_snd) measurable_id\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_mul_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : Mul β\ninst✝ : MeasurableMul₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhij : Ne i j\nhik : Ne i k\n⊢ ProbabilityTheory.Kernel.IndepFun (f i) (HMul.hMul (f j) (f k)) κ μ","decl":"@[to_additive]\nlemma iIndepFun.indepFun_mul_right (hf_indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hij : i ≠ j) (hik : i ≠ k) :\n    IndepFun (f i) (f j * f k) κ μ :=\n  (hf_indep.indepFun_mul_left hf_meas _ _ _ hij.symm hik.symm).symm\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_add_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : Add β\ninst✝ : MeasurableAdd₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhij : Ne i j\nhik : Ne i k\n⊢ ProbabilityTheory.Kernel.IndepFun (f i) (HAdd.hAdd (f j) (f k)) κ μ","decl":"@[to_additive]\nlemma iIndepFun.indepFun_mul_right (hf_indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hij : i ≠ j) (hik : i ≠ k) :\n    IndepFun (f i) (f j * f k) κ μ :=\n  (hf_indep.indepFun_mul_left hf_meas _ _ _ hij.symm hik.symm).symm\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_add_add","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : Add β\ninst✝ : MeasurableAdd₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k l : ι\nhik : Ne i k\nhil : Ne i l\nhjk : Ne j k\nhjl : Ne j l\n⊢ ProbabilityTheory.Kernel.IndepFun (HAdd.hAdd (f i) (f j)) (HAdd.hAdd (f k) (f l)) κ μ","decl":"@[to_additive]\nlemma iIndepFun.indepFun_mul_mul (hf_indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i))\n    (i j k l : ι) (hik : i ≠ k) (hil : i ≠ l) (hjk : j ≠ k) (hjl : j ≠ l) :\n    IndepFun (f i * f j) (f k * f l) κ μ :=\n  (hf_indep.indepFun_prod_mk_prod_mk hf_meas i j k l hik hil hjk hjl).comp\n    measurable_mul measurable_mul\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_mul_mul","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : Mul β\ninst✝ : MeasurableMul₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k l : ι\nhik : Ne i k\nhil : Ne i l\nhjk : Ne j k\nhjl : Ne j l\n⊢ ProbabilityTheory.Kernel.IndepFun (HMul.hMul (f i) (f j)) (HMul.hMul (f k) (f l)) κ μ","decl":"@[to_additive]\nlemma iIndepFun.indepFun_mul_mul (hf_indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i))\n    (i j k l : ι) (hik : i ≠ k) (hil : i ≠ l) (hjk : j ≠ k) (hjl : j ≠ l) :\n    IndepFun (f i * f j) (f k * f l) κ μ :=\n  (hf_indep.indepFun_prod_mk_prod_mk hf_meas i j k l hik hil hjk hjl).comp\n    measurable_mul measurable_mul\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_sub_left","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : Sub β\ninst✝ : MeasurableSub₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhik : Ne i k\nhjk : Ne j k\n⊢ ProbabilityTheory.Kernel.IndepFun (HSub.hSub (f i) (f j)) (f k) κ μ","decl":"@[to_additive]\nlemma iIndepFun.indepFun_div_left (hf_indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hik : i ≠ k) (hjk : j ≠ k) :\n    IndepFun (f i / f j) (f k) κ μ := by\n  have : IndepFun (fun ω => (f i ω, f j ω)) (f k) κ μ :=\n    hf_indep.indepFun_prod_mk hf_meas i j k hik hjk\n  simpa using this.comp (measurable_fst.div measurable_snd) measurable_id\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_div_left","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : Div β\ninst✝ : MeasurableDiv₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhik : Ne i k\nhjk : Ne j k\n⊢ ProbabilityTheory.Kernel.IndepFun (HDiv.hDiv (f i) (f j)) (f k) κ μ","decl":"@[to_additive]\nlemma iIndepFun.indepFun_div_left (hf_indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hik : i ≠ k) (hjk : j ≠ k) :\n    IndepFun (f i / f j) (f k) κ μ := by\n  have : IndepFun (fun ω => (f i ω, f j ω)) (f k) κ μ :=\n    hf_indep.indepFun_prod_mk hf_meas i j k hik hjk\n  simpa using this.comp (measurable_fst.div measurable_snd) measurable_id\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_div_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : Div β\ninst✝ : MeasurableDiv₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhij : Ne i j\nhik : Ne i k\n⊢ ProbabilityTheory.Kernel.IndepFun (f i) (HDiv.hDiv (f j) (f k)) κ μ","decl":"@[to_additive]\nlemma iIndepFun.indepFun_div_right (hf_indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hij : i ≠ j) (hik : i ≠ k) :\n    IndepFun (f i) (f j / f k) κ μ :=\n  (hf_indep.indepFun_div_left hf_meas _ _ _ hij.symm hik.symm).symm\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_sub_right","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : Sub β\ninst✝ : MeasurableSub₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k : ι\nhij : Ne i j\nhik : Ne i k\n⊢ ProbabilityTheory.Kernel.IndepFun (f i) (HSub.hSub (f j) (f k)) κ μ","decl":"@[to_additive]\nlemma iIndepFun.indepFun_div_right (hf_indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i)) (i j k : ι) (hij : i ≠ j) (hik : i ≠ k) :\n    IndepFun (f i) (f j / f k) κ μ :=\n  (hf_indep.indepFun_div_left hf_meas _ _ _ hij.symm hik.symm).symm\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_sub_sub","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : Sub β\ninst✝ : MeasurableSub₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k l : ι\nhik : Ne i k\nhil : Ne i l\nhjk : Ne j k\nhjl : Ne j l\n⊢ ProbabilityTheory.Kernel.IndepFun (HSub.hSub (f i) (f j)) (HSub.hSub (f k) (f l)) κ μ","decl":"@[to_additive]\nlemma iIndepFun.indepFun_div_div (hf_indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i))\n    (i j k l : ι) (hik : i ≠ k) (hil : i ≠ l) (hjk : j ≠ k) (hjl : j ≠ l) :\n    IndepFun (f i / f j) (f k / f l) κ μ :=\n  (hf_indep.indepFun_prod_mk_prod_mk hf_meas i j k l hik hil hjk hjl).comp\n    measurable_div measurable_div\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_div_div","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : Div β\ninst✝ : MeasurableDiv₂ β\nf : ι → Ω → β\nhf_indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ni j k l : ι\nhik : Ne i k\nhil : Ne i l\nhjk : Ne j k\nhjl : Ne j l\n⊢ ProbabilityTheory.Kernel.IndepFun (HDiv.hDiv (f i) (f j)) (HDiv.hDiv (f k) (f l)) κ μ","decl":"@[to_additive]\nlemma iIndepFun.indepFun_div_div (hf_indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i))\n    (i j k l : ι) (hik : i ≠ k) (hil : i ≠ l) (hjk : j ≠ k) (hjl : j ≠ l) :\n    IndepFun (f i / f j) (f k / f l) κ μ :=\n  (hf_indep.indepFun_prod_mk_prod_mk hf_meas i j k l hik hil hjk hjl).comp\n    measurable_div measurable_div\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_finset_prod_of_not_mem","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : CommMonoid β\ninst✝ : MeasurableMul₂ β\nf : ι → Ω → β\nhf_Indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ns : Finset ι\ni : ι\nhi : Not (Membership.mem s i)\n⊢ ProbabilityTheory.Kernel.IndepFun (s.prod fun j => f j) (f i) κ μ","decl":"@[to_additive]\ntheorem iIndepFun.indepFun_finset_prod_of_not_mem (hf_Indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i)) {s : Finset ι} {i : ι} (hi : i ∉ s) :\n    IndepFun (∏ j ∈ s, f j) (f i) κ μ := by\n  classical\n  have h_right : f i =\n    (fun p : ({i} : Finset ι) → β => p ⟨i, Finset.mem_singleton_self i⟩) ∘\n    fun a (j : ({i} : Finset ι)) => f j a := rfl\n  have h_meas_right : Measurable fun p : ({i} : Finset ι) → β =>\n      p ⟨i, Finset.mem_singleton_self i⟩ := measurable_pi_apply _\n  have h_left : ∏ j ∈ s, f j = (fun p : s → β => ∏ j, p j) ∘ fun a (j : s) => f j a := by\n    ext1 a\n    simp only [Function.comp_apply]\n    have : (∏ j : ↥s, f (↑j) a) = (∏ j : ↥s, f ↑j) a := by rw [Finset.prod_apply]\n    rw [this, Finset.prod_coe_sort]\n  have h_meas_left : Measurable fun p : s → β => ∏ j, p j :=\n    Finset.univ.measurable_prod fun (j : ↥s) (_H : j ∈ Finset.univ) => measurable_pi_apply j\n  rw [h_left, h_right]\n  exact\n    (hf_Indep.indepFun_finset s {i} (Finset.disjoint_singleton_left.mpr hi).symm hf_meas).comp\n      h_meas_left h_meas_right\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_finset_sum_of_not_mem","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : AddCommMonoid β\ninst✝ : MeasurableAdd₂ β\nf : ι → Ω → β\nhf_Indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : ι), Measurable (f i)\ns : Finset ι\ni : ι\nhi : Not (Membership.mem s i)\n⊢ ProbabilityTheory.Kernel.IndepFun (s.sum fun j => f j) (f i) κ μ","decl":"@[to_additive]\ntheorem iIndepFun.indepFun_finset_prod_of_not_mem (hf_Indep : iIndepFun (fun _ ↦ m) f κ μ)\n    (hf_meas : ∀ i, Measurable (f i)) {s : Finset ι} {i : ι} (hi : i ∉ s) :\n    IndepFun (∏ j ∈ s, f j) (f i) κ μ := by\n  classical\n  have h_right : f i =\n    (fun p : ({i} : Finset ι) → β => p ⟨i, Finset.mem_singleton_self i⟩) ∘\n    fun a (j : ({i} : Finset ι)) => f j a := rfl\n  have h_meas_right : Measurable fun p : ({i} : Finset ι) → β =>\n      p ⟨i, Finset.mem_singleton_self i⟩ := measurable_pi_apply _\n  have h_left : ∏ j ∈ s, f j = (fun p : s → β => ∏ j, p j) ∘ fun a (j : s) => f j a := by\n    ext1 a\n    simp only [Function.comp_apply]\n    have : (∏ j : ↥s, f (↑j) a) = (∏ j : ↥s, f ↑j) a := by rw [Finset.prod_apply]\n    rw [this, Finset.prod_coe_sort]\n  have h_meas_left : Measurable fun p : s → β => ∏ j, p j :=\n    Finset.univ.measurable_prod fun (j : ↥s) (_H : j ∈ Finset.univ) => measurable_pi_apply j\n  rw [h_left, h_right]\n  exact\n    (hf_Indep.indepFun_finset s {i} (Finset.disjoint_singleton_left.mpr hi).symm hf_meas).comp\n      h_meas_left h_meas_right\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_prod_range_succ","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : CommMonoid β\ninst✝ : MeasurableMul₂ β\nf : Nat → Ω → β\nhf_Indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : Nat), Measurable (f i)\nn : Nat\n⊢ ProbabilityTheory.Kernel.IndepFun ((Finset.range n).prod fun j => f j) (f n) κ μ","decl":"@[to_additive]\ntheorem iIndepFun.indepFun_prod_range_succ {f : ℕ → Ω → β}\n    (hf_Indep : iIndepFun (fun _ => m) f κ μ) (hf_meas : ∀ i, Measurable (f i)) (n : ℕ) :\n    IndepFun (∏ j ∈ Finset.range n, f j) (f n) κ μ :=\n  hf_Indep.indepFun_finset_prod_of_not_mem hf_meas Finset.not_mem_range_self\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.indepFun_sum_range_succ","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nβ : Type u_8\nm : MeasurableSpace β\ninst✝¹ : AddCommMonoid β\ninst✝ : MeasurableAdd₂ β\nf : Nat → Ω → β\nhf_Indep : ProbabilityTheory.Kernel.iIndepFun (fun x => m) f κ μ\nhf_meas : ∀ (i : Nat), Measurable (f i)\nn : Nat\n⊢ ProbabilityTheory.Kernel.IndepFun ((Finset.range n).sum fun j => f j) (f n) κ μ","decl":"@[to_additive]\ntheorem iIndepFun.indepFun_prod_range_succ {f : ℕ → Ω → β}\n    (hf_Indep : iIndepFun (fun _ => m) f κ μ) (hf_meas : ∀ i, Measurable (f i)) (n : ℕ) :\n    IndepFun (∏ j ∈ Finset.range n, f j) (f n) κ μ :=\n  hf_Indep.indepFun_finset_prod_of_not_mem hf_meas Finset.not_mem_range_self\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepSet.iIndepFun_indicator","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"α : Type u_1\nΩ : Type u_2\nι : Type u_3\nβ : Type u_4\n_mα : MeasurableSpace α\n_mΩ : MeasurableSpace Ω\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\ninst✝¹ : Zero β\ninst✝ : One β\nm : MeasurableSpace β\ns : ι → Set Ω\nhs : ProbabilityTheory.Kernel.iIndepSet s κ μ\n⊢ ProbabilityTheory.Kernel.iIndepFun (fun _n => m) (fun n => (s n).indicator fun _ω => 1) κ μ","decl":"theorem iIndepSet.iIndepFun_indicator [Zero β] [One β] {m : MeasurableSpace β} {s : ι → Set Ω}\n    (hs : iIndepSet s κ μ) :\n    iIndepFun (fun _n => m) (fun n => (s n).indicator fun _ω => 1) κ μ := by\n  classical\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul]\n  rintro S π _hπ\n  simp_rw [Set.indicator_const_preimage_eq_union]\n  refine @hs S (fun i => ite (1 ∈ π i) (s i) ∅ ∪ ite ((0 : β) ∈ π i) (s i)ᶜ ∅) fun i _hi => ?_\n  have hsi : MeasurableSet[generateFrom {s i}] (s i) :=\n    measurableSet_generateFrom (Set.mem_singleton _)\n  refine\n    MeasurableSet.union (MeasurableSet.ite' (fun _ => hsi) fun _ => ?_)\n      (MeasurableSet.ite' (fun _ => hsi.compl) fun _ => ?_)\n  · exact @MeasurableSet.empty _ (generateFrom {s i})\n  · exact @MeasurableSet.empty _ (generateFrom {s i})\n\n"}
{"name":"ProbabilityTheory.Kernel.iIndepFun.cond_iInter","module":"Mathlib.Probability.Independence.Kernel","initialProofState":"ι : Type u_4\nΩ : Type u_5\nα : Type u_6\nβ : Type u_7\nmΩ : MeasurableSpace Ω\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α Ω\nμ : MeasureTheory.Measure α\nX : ι → Ω → α\nY : ι → Ω → β\nf : ι → Set Ω\nt : ι → Set β\ns : Finset ι\ninst✝ : Finite ι\nhY : ∀ (i : ι), Measurable (Y i)\nhindep : ProbabilityTheory.Kernel.iIndepFun (fun x => mα.prod mβ) (fun i ω => { fst := X i ω, snd := Y i ω }) κ μ\nhf : ∀ (i : ι), Membership.mem s i → MeasurableSet (f i)\nhy : Filter.Eventually (fun a => ∀ (i : ι), Not (Membership.mem s i) → Ne ((κ a) (Set.preimage (Y i) (t i))) 0) (MeasureTheory.ae μ)\nht : ∀ (i : ι), MeasurableSet (t i)\n⊢ Filter.Eventually (fun a => Eq ((ProbabilityTheory.cond (κ a) (Set.iInter fun i => Set.preimage (Y i) (t i))) (Set.iInter fun i => Set.iInter fun h => f i)) (s.prod fun i => (ProbabilityTheory.cond (κ a) (Set.preimage (Y i) (t i))) (f i))) (MeasureTheory.ae μ)","decl":"/-- The probability of an intersection of preimages conditioning on another intersection factors\ninto a product. -/\nlemma iIndepFun.cond_iInter [Finite ι] (hY : ∀ i, Measurable (Y i))\n    (hindep : iIndepFun (fun _ ↦ mα.prod mβ) (fun i ω ↦ (X i ω, Y i ω)) κ μ)\n    (hf : ∀ i ∈ s, MeasurableSet[mα.comap (X i)] (f i))\n    (hy : ∀ᵐ a ∂μ, ∀ i ∉ s, κ a (Y i ⁻¹' t i) ≠ 0) (ht : ∀ i, MeasurableSet (t i)) :\n    ∀ᵐ a ∂μ, (κ a)[⋂ i ∈ s, f i | ⋂ i, Y i ⁻¹' t i] = ∏ i ∈ s, (κ a)[f i | Y i in t i] := by\n  classical\n  cases nonempty_fintype ι\n  let g (i' : ι) := if i' ∈ s then Y i' ⁻¹' t i' ∩ f i' else Y i' ⁻¹' t i'\n  have hYt i : MeasurableSet[(mα.prod mβ).comap fun ω ↦ (X i ω, Y i ω)] (Y i ⁻¹' t i) :=\n    ⟨.univ ×ˢ t i, .prod .univ (ht _), by ext; simp [eq_comm]⟩\n  have hg i : MeasurableSet[(mα.prod mβ).comap fun ω ↦ (X i ω, Y i ω)] (g i) := by\n    by_cases hi : i ∈ s <;> simp only [hi, ↓reduceIte, g]\n    · obtain ⟨A, hA, hA'⟩ := hf i hi\n      exact (hYt _).inter ⟨A ×ˢ .univ, hA.prod .univ, by ext; simp [← hA']⟩\n    · exact hYt _\n  filter_upwards [hy, hindep.ae_isProbabilityMeasure, hindep.meas_iInter hYt, hindep.meas_iInter hg]\n    with a hy _ hYt hg\n  calc\n    _ = (κ a (⋂ i, Y i ⁻¹' t i))⁻¹ * κ a ((⋂ i, Y i ⁻¹' t i) ∩ ⋂ i ∈ s, f i) := by\n      rw [cond_apply]; exact .iInter fun i ↦ hY i (ht i)\n    _ = (κ a (⋂ i, Y i ⁻¹' t i))⁻¹ * κ a (⋂ i, g i) := by\n      congr\n      calc\n        _ = (⋂ i, Y i ⁻¹' t i) ∩ ⋂ i, if i ∈ s then f i else .univ := by\n          congr\n          simp only [Set.iInter_ite, Set.iInter_univ, Set.inter_univ]\n        _ = ⋂ i, Y i ⁻¹' t i ∩ (if i ∈ s then f i else .univ) := by rw [Set.iInter_inter_distrib]\n        _ = _ := Set.iInter_congr fun i ↦ by by_cases hi : i ∈ s <;> simp [hi, g]\n    _ = (∏ i, κ a (Y i ⁻¹' t i))⁻¹ * κ a (⋂ i, g i) := by\n      rw [hYt]\n    _ = (∏ i, κ a (Y i ⁻¹' t i))⁻¹ * ∏ i, κ a (g i) := by\n      rw [hg]\n    _ = ∏ i, (κ a (Y i ⁻¹' t i))⁻¹ * κ a (g i) := by\n      rw [Finset.prod_mul_distrib, ENNReal.prod_inv_distrib]\n      exact fun _ _ i _ _ ↦ .inr <| measure_ne_top _ _\n    _ = ∏ i, if i ∈ s then (κ a)[f i | Y i ⁻¹' t i] else 1 := by\n      refine Finset.prod_congr rfl fun i _ ↦ ?_\n      by_cases hi : i ∈ s\n      · simp only [hi, ↓reduceIte, g, cond_apply (hY i (ht i))]\n      · simp only [hi, ↓reduceIte, g, ENNReal.inv_mul_cancel (hy i hi) (measure_ne_top _ _)]\n    _ = _ := by simp\n\n-- TODO: We can't state `Kernel.iIndepFun.cond` (the `Kernel` analogue of\n-- `ProbabilityTheory.iIndepFun.cond`) because we don't have a version of `ProbabilityTheory.cond`\n-- for kernels\n\n"}
