{"name":"Nat.primesBelow_zero","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"⊢ Eq (Nat.primesBelow 0) EmptyCollection.emptyCollection","decl":"@[simp]\nlemma primesBelow_zero : primesBelow 0 = ∅ := by\n  rw [primesBelow, Finset.range_zero, Finset.filter_empty]\n\n"}
{"name":"Nat.mem_primesBelow","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"k n : Nat\n⊢ Iff (Membership.mem k.primesBelow n) (And (LT.lt n k) (Nat.Prime n))","decl":"lemma mem_primesBelow {k n : ℕ} :\n    n ∈ primesBelow k ↔ n < k ∧ n.Prime := by simp [primesBelow]\n\n"}
{"name":"Nat.prime_of_mem_primesBelow","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"p n : Nat\nh : Membership.mem n.primesBelow p\n⊢ Nat.Prime p","decl":"lemma prime_of_mem_primesBelow {p n : ℕ} (h : p ∈ n.primesBelow) : p.Prime :=\n  (Finset.mem_filter.mp h).2\n\n"}
{"name":"Nat.lt_of_mem_primesBelow","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"p n : Nat\nh : Membership.mem n.primesBelow p\n⊢ LT.lt p n","decl":"lemma lt_of_mem_primesBelow {p n : ℕ} (h : p ∈ n.primesBelow) : p < n :=\n  Finset.mem_range.mp <| Finset.mem_of_mem_filter p h\n\n"}
{"name":"Nat.primesBelow_succ","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"n : Nat\n⊢ Eq n.succ.primesBelow (ite (Nat.Prime n) (Insert.insert n n.primesBelow) n.primesBelow)","decl":"lemma primesBelow_succ (n : ℕ) :\n    primesBelow n.succ = if n.Prime then insert n (primesBelow n) else primesBelow n := by\n  rw [primesBelow, primesBelow, Finset.range_succ, Finset.filter_insert]\n\n"}
{"name":"Nat.not_mem_primesBelow","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"n : Nat\n⊢ Not (Membership.mem n.primesBelow n)","decl":"lemma not_mem_primesBelow (n : ℕ) : n ∉ primesBelow n :=\n  fun hn ↦ (lt_of_mem_primesBelow hn).false\n\n\n"}
{"name":"Nat.mem_factoredNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\nm : Nat\n⊢ Iff (Membership.mem (Nat.factoredNumbers s) m) (And (Ne m 0) (∀ (p : Nat), Membership.mem m.primeFactorsList p → Membership.mem s p))","decl":"lemma mem_factoredNumbers {s : Finset ℕ} {m : ℕ} :\n    m ∈ factoredNumbers s ↔ m ≠ 0 ∧ ∀ p ∈ primeFactorsList m, p ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Nat.mem_factoredNumbers_of_dvd","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\nm k : Nat\nh : Membership.mem (Nat.factoredNumbers s) m\nh' : Dvd.dvd k m\n⊢ Membership.mem (Nat.factoredNumbers s) k","decl":"/-- A number that divides an `s`-factored number is itself `s`-factored. -/\nlemma mem_factoredNumbers_of_dvd {s : Finset ℕ} {m k : ℕ} (h : m ∈ factoredNumbers s)\n    (h' : k ∣ m) :\n    k ∈ factoredNumbers s := by\n  obtain ⟨h₁, h₂⟩ := h\n  have hk := ne_zero_of_dvd_ne_zero h₁ h'\n  refine ⟨hk, fun p hp ↦ h₂ p ?_⟩\n  rw [mem_primeFactorsList <| by assumption] at hp ⊢\n  exact ⟨hp.1, hp.2.trans h'⟩\n\n"}
{"name":"Nat.mem_factoredNumbers_iff_forall_le","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\nm : Nat\n⊢ Iff (Membership.mem (Nat.factoredNumbers s) m) (And (Ne m 0) (∀ (p : Nat), LE.le p m → Nat.Prime p → Dvd.dvd p m → Membership.mem s p))","decl":"/-- `m` is `s`-factored if and only if `m` is nonzero and all prime divisors `≤ m` of `m`\nare in `s`. -/\nlemma mem_factoredNumbers_iff_forall_le {s : Finset ℕ} {m : ℕ} :\n    m ∈ factoredNumbers s ↔ m ≠ 0 ∧ ∀ p ≤ m, p.Prime → p ∣ m → p ∈ s := by\n  simp_rw [mem_factoredNumbers, mem_primeFactorsList']\n  exact ⟨fun ⟨H₀, H₁⟩ ↦ ⟨H₀, fun p _ hp₂ hp₃ ↦ H₁ p ⟨hp₂, hp₃, H₀⟩⟩,\n    fun ⟨H₀, H₁⟩ ↦\n      ⟨H₀, fun p ⟨hp₁, hp₂, hp₃⟩ ↦ H₁ p (le_of_dvd (Nat.pos_of_ne_zero hp₃) hp₂) hp₁ hp₂⟩⟩\n\n"}
{"name":"Nat.mem_factoredNumbers'","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\nm : Nat\n⊢ Iff (Membership.mem (Nat.factoredNumbers s) m) (∀ (p : Nat), Nat.Prime p → Dvd.dvd p m → Membership.mem s p)","decl":"/-- `m` is `s`-factored if and only if all prime divisors of `m` are in `s`. -/\nlemma mem_factoredNumbers' {s : Finset ℕ} {m : ℕ} :\n    m ∈ factoredNumbers s ↔ ∀ p, p.Prime → p ∣ m → p ∈ s := by\n  obtain ⟨p, hp₁, hp₂⟩ := exists_infinite_primes (1 + Finset.sup s id)\n  rw [mem_factoredNumbers_iff_forall_le]\n  refine ⟨fun ⟨H₀, H₁⟩ ↦ fun p hp₁ hp₂ ↦ H₁ p (le_of_dvd (Nat.pos_of_ne_zero H₀) hp₂) hp₁ hp₂,\n         fun H ↦ ⟨fun h ↦ lt_irrefl p ?_, fun p _ ↦ H p⟩⟩\n  calc\n    p ≤ s.sup id := Finset.le_sup (f := @id ℕ) <| H p hp₂ <| h.symm ▸ dvd_zero p\n    _ < 1 + s.sup id := lt_one_add _\n    _ ≤ p := hp₁\n\n"}
{"name":"Nat.ne_zero_of_mem_factoredNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\nm : Nat\nh : Membership.mem (Nat.factoredNumbers s) m\n⊢ Ne m 0","decl":"lemma ne_zero_of_mem_factoredNumbers {s : Finset ℕ} {m : ℕ} (h : m ∈ factoredNumbers s) : m ≠ 0 :=\n  h.1\n\n"}
{"name":"Nat.primeFactors_subset_of_mem_factoredNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\nm : Nat\nhm : Membership.mem (Nat.factoredNumbers s) m\n⊢ HasSubset.Subset m.primeFactors s","decl":"/-- The `Finset` of prime factors of an `s`-factored number is contained in `s`. -/\nlemma primeFactors_subset_of_mem_factoredNumbers {s : Finset ℕ} {m : ℕ}\n    (hm : m ∈ factoredNumbers s) :\n    m.primeFactors ⊆ s := by\n  rw [mem_factoredNumbers] at hm\n  exact fun n hn ↦ hm.2 n (mem_primeFactors_iff_mem_primeFactorsList.mp hn)\n\n"}
{"name":"Nat.mem_factoredNumbers_of_primeFactors_subset","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\nm : Nat\nhm : Ne m 0\nhp : HasSubset.Subset m.primeFactors s\n⊢ Membership.mem (Nat.factoredNumbers s) m","decl":"/-- If `m ≠ 0` and the `Finset` of prime factors of `m` is contained in `s`, then `m`\nis `s`-factored. -/\nlemma mem_factoredNumbers_of_primeFactors_subset {s : Finset ℕ} {m : ℕ} (hm : m ≠ 0)\n    (hp : m.primeFactors ⊆ s) :\n    m ∈ factoredNumbers s := by\n  rw [mem_factoredNumbers]\n  exact ⟨hm, fun p hp' ↦ hp <| mem_primeFactors_iff_mem_primeFactorsList.mpr hp'⟩\n\n"}
{"name":"Nat.mem_factoredNumbers_iff_primeFactors_subset","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\nm : Nat\n⊢ Iff (Membership.mem (Nat.factoredNumbers s) m) (And (Ne m 0) (HasSubset.Subset m.primeFactors s))","decl":"/-- `m` is `s`-factored if and only if `m ≠ 0` and its `Finset` of prime factors\nis contained in `s`. -/\nlemma mem_factoredNumbers_iff_primeFactors_subset {s : Finset ℕ} {m : ℕ} :\n    m ∈ factoredNumbers s ↔ m ≠ 0 ∧ m.primeFactors ⊆ s :=\n  ⟨fun h ↦ ⟨ne_zero_of_mem_factoredNumbers h, primeFactors_subset_of_mem_factoredNumbers h⟩,\n   fun ⟨h₁, h₂⟩ ↦ mem_factoredNumbers_of_primeFactors_subset h₁ h₂⟩\n\n"}
{"name":"Nat.factoredNumbers_empty","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"⊢ Eq (Nat.factoredNumbers EmptyCollection.emptyCollection) (Singleton.singleton 1)","decl":"@[simp]\nlemma factoredNumbers_empty : factoredNumbers ∅ = {1} := by\n  ext m\n  simp only [mem_factoredNumbers, Finset.not_mem_empty, ← List.eq_nil_iff_forall_not_mem,\n    primeFactorsList_eq_nil, and_or_left, not_and_self_iff, ne_and_eq_iff_right zero_ne_one,\n    false_or, Set.mem_singleton_iff]\n\n"}
{"name":"Nat.mul_mem_factoredNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\nm n : Nat\nhm : Membership.mem (Nat.factoredNumbers s) m\nhn : Membership.mem (Nat.factoredNumbers s) n\n⊢ Membership.mem (Nat.factoredNumbers s) (HMul.hMul m n)","decl":"/-- The product of two `s`-factored numbers is again `s`-factored. -/\nlemma mul_mem_factoredNumbers {s : Finset ℕ} {m n : ℕ} (hm : m ∈ factoredNumbers s)\n    (hn : n ∈ factoredNumbers s) :\n    m * n ∈ factoredNumbers s := by\n  have hm' := primeFactors_subset_of_mem_factoredNumbers hm\n  have hn' := primeFactors_subset_of_mem_factoredNumbers hn\n  exact mem_factoredNumbers_of_primeFactors_subset (mul_ne_zero hm.1 hn.1)\n    <| primeFactors_mul hm.1 hn.1 ▸ Finset.union_subset hm' hn'\n\n"}
{"name":"Nat.prod_mem_factoredNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\nn : Nat\n⊢ Membership.mem (Nat.factoredNumbers s) (List.filter (fun x => Decidable.decide (Membership.mem s x)) n.primeFactorsList).prod","decl":"/-- The product of the prime factors of `n` that are in `s` is an `s`-factored number. -/\nlemma prod_mem_factoredNumbers (s : Finset ℕ) (n : ℕ) :\n    (n.primeFactorsList.filter (· ∈ s)).prod ∈ factoredNumbers s := by\n  have h₀ : (n.primeFactorsList.filter (· ∈ s)).prod ≠ 0 :=\n    List.prod_ne_zero fun h ↦ (pos_of_mem_primeFactorsList (List.mem_of_mem_filter h)).false\n  refine ⟨h₀, fun p hp ↦ ?_⟩\n  obtain ⟨H₁, H₂⟩ := (mem_primeFactorsList h₀).mp hp\n  simpa only [decide_eq_true_eq] using List.of_mem_filter <| mem_list_primes_of_dvd_prod H₁.prime\n    (fun _ hq ↦ (prime_of_mem_primeFactorsList (List.mem_of_mem_filter hq)).prime) H₂\n\n"}
{"name":"Nat.factoredNumbers_insert","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\nN : Nat\nhN : Not (Nat.Prime N)\n⊢ Eq (Nat.factoredNumbers (Insert.insert N s)) (Nat.factoredNumbers s)","decl":"/-- The sets of `s`-factored and of `s ∪ {N}`-factored numbers are the same when `N` is not prime.\nSee `Nat.equivProdNatFactoredNumbers` for when `N` is prime. -/\nlemma factoredNumbers_insert (s : Finset ℕ) {N : ℕ} (hN : ¬ N.Prime) :\n    factoredNumbers (insert N s) = factoredNumbers s := by\n  ext m\n  refine ⟨fun hm ↦ ⟨hm.1, fun p hp ↦ ?_⟩,\n          fun hm ↦ ⟨hm.1, fun p hp ↦ Finset.mem_insert_of_mem <| hm.2 p hp⟩⟩\n  exact Finset.mem_of_mem_insert_of_ne (hm.2 p hp)\n    fun h ↦ hN <| h ▸ prime_of_mem_primeFactorsList hp\n\n"}
{"name":"Nat.factoredNumbers_mono","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s t : Finset Nat\nhst : LE.le s t\n⊢ HasSubset.Subset (Nat.factoredNumbers s) (Nat.factoredNumbers t)","decl":"@[gcongr] lemma factoredNumbers_mono {s t : Finset ℕ} (hst : s ≤ t) :\n    factoredNumbers s ⊆ factoredNumbers t :=\n  fun _ hx ↦ ⟨hx.1, fun p hp ↦ hst <| hx.2 p hp⟩\n\n"}
{"name":"Nat.factoredNumbers_compl","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"N : Nat\ns : Finset Nat\nh : LE.le N.primesBelow s\n⊢ HasSubset.Subset (SDiff.sdiff (HasCompl.compl (Nat.factoredNumbers s)) (Singleton.singleton 0)) (setOf fun n => LE.le N n)","decl":"/-- The non-zero non-`s`-factored numbers are `≥ N` when `s` contains all primes less than `N`. -/\nlemma factoredNumbers_compl {N : ℕ} {s : Finset ℕ} (h : primesBelow N ≤ s) :\n    (factoredNumbers s)ᶜ \\ {0} ⊆ {n | N ≤ n} := by\n  intro n hn\n  simp only [Set.mem_compl_iff, mem_factoredNumbers, Set.mem_diff, ne_eq, not_and, not_forall,\n    not_lt, exists_prop, Set.mem_singleton_iff] at hn\n  simp only [Set.mem_setOf_eq]\n  obtain ⟨p, hp₁, hp₂⟩ := hn.1 hn.2\n  have : N ≤ p := by\n    contrapose! hp₂\n    exact h <| mem_primesBelow.mpr ⟨hp₂, prime_of_mem_primeFactorsList hp₁⟩\n  exact this.trans <| le_of_mem_primeFactorsList hp₁\n\n"}
{"name":"Nat.pow_mul_mem_factoredNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\np n : Nat\nhp : Nat.Prime p\ne : Nat\nhn : Membership.mem (Nat.factoredNumbers s) n\n⊢ Membership.mem (Nat.factoredNumbers (Insert.insert p s)) (HMul.hMul (HPow.hPow p e) n)","decl":"/-- If `p` is a prime and `n` is `s`-factored, then every product `p^e * n`\nis `s ∪ {p}`-factored. -/\nlemma pow_mul_mem_factoredNumbers {s : Finset ℕ} {p n : ℕ} (hp : p.Prime) (e : ℕ)\n    (hn : n ∈ factoredNumbers s) :\n    p ^ e * n ∈ factoredNumbers (insert p s) := by\n  have hp' := pow_ne_zero e hp.ne_zero\n  refine ⟨mul_ne_zero hp' hn.1, fun q hq ↦ ?_⟩\n  rcases (mem_primeFactorsList_mul hp' hn.1).mp hq with H | H\n  · rw [mem_primeFactorsList hp'] at H\n    rw [(prime_dvd_prime_iff_eq H.1 hp).mp <| H.1.dvd_of_dvd_pow H.2]\n    exact Finset.mem_insert_self p s\n  · exact Finset.mem_insert_of_mem <| hn.2 _ H\n\n"}
{"name":"Nat.Prime.factoredNumbers_coprime","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\np n : Nat\nhp : Nat.Prime p\nhs : Not (Membership.mem s p)\nhn : Membership.mem (Nat.factoredNumbers s) n\n⊢ p.Coprime n","decl":"/-- If `p ∉ s` is a prime and `n` is `s`-factored, then `p` and `n` are coprime. -/\nlemma Prime.factoredNumbers_coprime {s : Finset ℕ} {p n : ℕ} (hp : p.Prime) (hs : p ∉ s)\n    (hn : n ∈ factoredNumbers s) :\n    Nat.Coprime p n := by\n  rw [hp.coprime_iff_not_dvd, ← mem_primeFactorsList_iff_dvd hn.1 hp]\n  exact fun H ↦ hs <| hn.2 p H\n\n"}
{"name":"Nat.factoredNumbers.map_prime_pow_mul","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"F : Type u_1\ninst✝ : CommSemiring F\nf : Nat → F\nhmul : ∀ {m n : Nat}, m.Coprime n → Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\ns : Finset Nat\np : Nat\nhp : Nat.Prime p\nhs : Not (Membership.mem s p)\ne : Nat\nm : ↑(Nat.factoredNumbers s)\n⊢ Eq (f (HMul.hMul (HPow.hPow p e) ↑m)) (HMul.hMul (f (HPow.hPow p e)) (f ↑m))","decl":"/-- If `f : ℕ → F` is multiplicative on coprime arguments, `p ∉ s` is a prime and `m`\nis `s`-factored, then `f (p^e * m) = f (p^e) * f m`. -/\nlemma factoredNumbers.map_prime_pow_mul {F : Type*} [CommSemiring F] {f : ℕ → F}\n    (hmul : ∀ {m n}, Coprime m n → f (m * n) = f m * f n) {s : Finset ℕ} {p : ℕ}\n    (hp : p.Prime) (hs : p ∉ s) (e : ℕ) {m : factoredNumbers s} :\n    f (p ^ e * m) = f (p ^ e) * f m :=\n  hmul <| Coprime.pow_left _ <| hp.factoredNumbers_coprime hs <| Subtype.mem m\n\n"}
{"name":"Nat.equivProdNatFactoredNumbers_apply","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\np e m : Nat\nhp : Nat.Prime p\nhs : Not (Membership.mem s p)\nhm : Membership.mem (Nat.factoredNumbers s) m\n⊢ Eq (↑((Nat.equivProdNatFactoredNumbers hp hs) { fst := e, snd := ⟨m, hm⟩ })) (HMul.hMul (HPow.hPow p e) m)","decl":"@[simp]\nlemma equivProdNatFactoredNumbers_apply {s : Finset ℕ} {p e m : ℕ} (hp : p.Prime) (hs : p ∉ s)\n    (hm : m ∈ factoredNumbers s) :\n    equivProdNatFactoredNumbers hp hs (e, ⟨m, hm⟩) = p ^ e * m := rfl\n\n"}
{"name":"Nat.equivProdNatFactoredNumbers_apply'","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"s : Finset Nat\np : Nat\nhp : Nat.Prime p\nhs : Not (Membership.mem s p)\nx : Prod Nat ↑(Nat.factoredNumbers s)\n⊢ Eq (↑((Nat.equivProdNatFactoredNumbers hp hs) x)) (HMul.hMul (HPow.hPow p x.1) ↑x.2)","decl":"@[simp]\nlemma equivProdNatFactoredNumbers_apply' {s : Finset ℕ} {p : ℕ} (hp : p.Prime) (hs : p ∉ s)\n    (x : ℕ × factoredNumbers s) :\n    equivProdNatFactoredNumbers hp hs x = p ^ x.1 * x.2 := rfl\n\n\n"}
{"name":"Nat.mem_smoothNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"n m : Nat\n⊢ Iff (Membership.mem n.smoothNumbers m) (And (Ne m 0) (∀ (p : Nat), Membership.mem m.primeFactorsList p → LT.lt p n))","decl":"lemma mem_smoothNumbers {n m : ℕ} : m ∈ smoothNumbers n ↔ m ≠ 0 ∧ ∀ p ∈ primeFactorsList m, p < n :=\n  Iff.rfl\n\n"}
{"name":"Nat.smoothNumbers_eq_factoredNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"n : Nat\n⊢ Eq n.smoothNumbers (Nat.factoredNumbers (Finset.range n))","decl":"/-- The `n`-smooth numbers agree with the `Finset.range n`-factored numbers. -/\nlemma smoothNumbers_eq_factoredNumbers (n : ℕ) :\n    smoothNumbers n = factoredNumbers (Finset.range n) := by\n  simp only [smoothNumbers, ne_eq, mem_primeFactorsList', and_imp, factoredNumbers,\n    Finset.mem_range]\n\n"}
{"name":"Nat.smmoothNumbers_eq_factoredNumbers_primesBelow","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"n : Nat\n⊢ Eq n.smoothNumbers (Nat.factoredNumbers n.primesBelow)","decl":"/-- The `n`-smooth numbers agree with the `primesBelow n`-factored numbers. -/\nlemma smmoothNumbers_eq_factoredNumbers_primesBelow (n : ℕ) :\n    smoothNumbers n = factoredNumbers n.primesBelow := by\n  rw [smoothNumbers_eq_factoredNumbers]\n  refine Set.Subset.antisymm (fun m hm ↦ ?_) <| factoredNumbers_mono Finset.mem_of_mem_filter\n  simp_rw [mem_factoredNumbers'] at hm ⊢\n  exact fun p hp hp' ↦ mem_primesBelow.mpr ⟨Finset.mem_range.mp <| hm p hp hp', hp⟩\n\n"}
{"name":"Nat.mem_smoothNumbers_of_dvd","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"n m k : Nat\nh : Membership.mem n.smoothNumbers m\nh' : Dvd.dvd k m\n⊢ Membership.mem n.smoothNumbers k","decl":"/-- A number that divides an `n`-smooth number is itself `n`-smooth. -/\nlemma mem_smoothNumbers_of_dvd {n m k : ℕ} (h : m ∈ smoothNumbers n) (h' : k ∣ m) :\n    k ∈ smoothNumbers n := by\n  simp only [smoothNumbers_eq_factoredNumbers] at h ⊢\n  exact mem_factoredNumbers_of_dvd h h'\n\n"}
{"name":"Nat.mem_smoothNumbers_iff_forall_le","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"n m : Nat\n⊢ Iff (Membership.mem n.smoothNumbers m) (And (Ne m 0) (∀ (p : Nat), LE.le p m → Nat.Prime p → Dvd.dvd p m → LT.lt p n))","decl":"/-- `m` is `n`-smooth if and only if `m` is nonzero and all prime divisors `≤ m` of `m`\nare less than `n`. -/\nlemma mem_smoothNumbers_iff_forall_le {n m : ℕ} :\n    m ∈ smoothNumbers n ↔ m ≠ 0 ∧ ∀ p ≤ m, p.Prime → p ∣ m → p < n := by\n  simp only [smoothNumbers_eq_factoredNumbers, mem_factoredNumbers_iff_forall_le, Finset.mem_range]\n\n"}
{"name":"Nat.mem_smoothNumbers'","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"n m : Nat\n⊢ Iff (Membership.mem n.smoothNumbers m) (∀ (p : Nat), Nat.Prime p → Dvd.dvd p m → LT.lt p n)","decl":"/-- `m` is `n`-smooth if and only if all prime divisors of `m` are less than `n`. -/\nlemma mem_smoothNumbers' {n m : ℕ} : m ∈ smoothNumbers n ↔ ∀ p, p.Prime → p ∣ m → p < n := by\n  simp only [smoothNumbers_eq_factoredNumbers, mem_factoredNumbers', Finset.mem_range]\n\n"}
{"name":"Nat.primeFactors_subset_of_mem_smoothNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"m n : Nat\nhms : Membership.mem n.smoothNumbers m\n⊢ HasSubset.Subset m.primeFactors n.primesBelow","decl":"/-- The `Finset` of prime factors of an `n`-smooth number is contained in the `Finset`\nof primes below `n`. -/\nlemma primeFactors_subset_of_mem_smoothNumbers {m n : ℕ} (hms : m ∈ n.smoothNumbers) :\n    m.primeFactors ⊆ n.primesBelow :=\n  primeFactors_subset_of_mem_factoredNumbers <|\n    smmoothNumbers_eq_factoredNumbers_primesBelow n ▸ hms\n\n"}
{"name":"Nat.mem_smoothNumbers_of_primeFactors_subset","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"m n : Nat\nhm : Ne m 0\nhp : HasSubset.Subset m.primeFactors (Finset.range n)\n⊢ Membership.mem n.smoothNumbers m","decl":"/-- `m` is an `n`-smooth number if the `Finset` of its prime factors consists of numbers `< n`. -/\nlemma mem_smoothNumbers_of_primeFactors_subset {m n : ℕ} (hm : m ≠ 0)\n    (hp : m.primeFactors ⊆ Finset.range n) : m ∈ n.smoothNumbers :=\n  smoothNumbers_eq_factoredNumbers n ▸ mem_factoredNumbers_of_primeFactors_subset hm hp\n\n"}
{"name":"Nat.mem_smoothNumbers_iff_primeFactors_subset","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"m n : Nat\n⊢ Iff (Membership.mem n.smoothNumbers m) (And (Ne m 0) (HasSubset.Subset m.primeFactors n.primesBelow))","decl":"/-- `m` is an `n`-smooth number if and only if `m ≠ 0` and the `Finset` of its prime factors\nis contained in the `Finset` of primes below `n` -/\nlemma mem_smoothNumbers_iff_primeFactors_subset {m n : ℕ} :\n    m ∈ n.smoothNumbers ↔ m ≠ 0 ∧ m.primeFactors ⊆ n.primesBelow :=\n  ⟨fun h ↦ ⟨h.1, primeFactors_subset_of_mem_smoothNumbers h⟩,\n   fun h ↦ mem_smoothNumbers_of_primeFactors_subset h.1 <| h.2.trans <| Finset.filter_subset ..⟩\n\n"}
{"name":"Nat.ne_zero_of_mem_smoothNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"n m : Nat\nh : Membership.mem n.smoothNumbers m\n⊢ Ne m 0","decl":"/-- Zero is never a smooth number -/\nlemma ne_zero_of_mem_smoothNumbers {n m : ℕ} (h : m ∈ smoothNumbers n) : m ≠ 0 := h.1\n\n"}
{"name":"Nat.smoothNumbers_zero","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"⊢ Eq (Nat.smoothNumbers 0) (Singleton.singleton 1)","decl":"@[simp]\nlemma smoothNumbers_zero : smoothNumbers 0 = {1} := by\n  simp only [smoothNumbers_eq_factoredNumbers, Finset.range_zero, factoredNumbers_empty]\n\n"}
{"name":"Nat.mul_mem_smoothNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"m₁ m₂ n : Nat\nhm1 : Membership.mem n.smoothNumbers m₁\nhm2 : Membership.mem n.smoothNumbers m₂\n⊢ Membership.mem n.smoothNumbers (HMul.hMul m₁ m₂)","decl":"/-- The product of two `n`-smooth numbers is an `n`-smooth number. -/\ntheorem mul_mem_smoothNumbers {m₁ m₂ n : ℕ}\n    (hm1 : m₁ ∈ n.smoothNumbers) (hm2 : m₂ ∈ n.smoothNumbers) : m₁ * m₂ ∈ n.smoothNumbers := by\n  rw [smoothNumbers_eq_factoredNumbers] at hm1 hm2 ⊢\n  exact mul_mem_factoredNumbers hm1 hm2\n\n"}
{"name":"Nat.prod_mem_smoothNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"n N : Nat\n⊢ Membership.mem N.smoothNumbers (List.filter (fun x => Decidable.decide (LT.lt x N)) n.primeFactorsList).prod","decl":"/-- The product of the prime factors of `n` that are less than `N` is an `N`-smooth number. -/\nlemma prod_mem_smoothNumbers (n N : ℕ) :\n    (n.primeFactorsList.filter (· < N)).prod ∈ smoothNumbers N := by\n  simp only [smoothNumbers_eq_factoredNumbers, ← Finset.mem_range, prod_mem_factoredNumbers]\n\n"}
{"name":"Nat.smoothNumbers_succ","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"N : Nat\nhN : Not (Nat.Prime N)\n⊢ Eq N.succ.smoothNumbers N.smoothNumbers","decl":"/-- The sets of `N`-smooth and of `(N+1)`-smooth numbers are the same when `N` is not prime.\nSee `Nat.equivProdNatSmoothNumbers` for when `N` is prime. -/\nlemma smoothNumbers_succ {N : ℕ} (hN : ¬ N.Prime) : N.succ.smoothNumbers = N.smoothNumbers := by\n  simp only [smoothNumbers_eq_factoredNumbers, Finset.range_succ, factoredNumbers_insert _ hN]\n\n"}
{"name":"Nat.smoothNumbers_one","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"⊢ Eq (Nat.smoothNumbers 1) (Singleton.singleton 1)","decl":"@[simp] lemma smoothNumbers_one : smoothNumbers 1 = {1} := by\n  simp +decide only [not_false_eq_true, smoothNumbers_succ, smoothNumbers_zero]\n\n"}
{"name":"Nat.smoothNumbers_mono","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"N M : Nat\nhNM : LE.le N M\n⊢ HasSubset.Subset N.smoothNumbers M.smoothNumbers","decl":"@[gcongr] lemma smoothNumbers_mono {N M : ℕ} (hNM : N ≤ M) : N.smoothNumbers ⊆ M.smoothNumbers :=\n  fun _ hx ↦ ⟨hx.1, fun p hp => (hx.2 p hp).trans_le hNM⟩\n\n"}
{"name":"Nat.mem_smoothNumbers_of_lt","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"m n : Nat\nhm : LT.lt 0 m\nhmn : LT.lt m n\n⊢ Membership.mem n.smoothNumbers m","decl":"/-- All `m`, `0 < m < n` are `n`-smooth numbers -/\nlemma mem_smoothNumbers_of_lt {m n : ℕ} (hm : 0 < m) (hmn : m < n) : m ∈ n.smoothNumbers :=\n  smoothNumbers_eq_factoredNumbers _ ▸ ⟨not_eq_zero_of_lt hm,\n  fun _ h => Finset.mem_range.mpr <| lt_of_le_of_lt (le_of_mem_primeFactorsList h) hmn⟩\n\n"}
{"name":"Nat.smoothNumbers_compl","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"N : Nat\n⊢ HasSubset.Subset (SDiff.sdiff (HasCompl.compl N.smoothNumbers) (Singleton.singleton 0)) (setOf fun n => LE.le N n)","decl":"/-- The non-zero non-`N`-smooth numbers are `≥ N`. -/\nlemma smoothNumbers_compl (N : ℕ) : (N.smoothNumbers)ᶜ \\ {0} ⊆ {n | N ≤ n} := by\n  simpa only [smoothNumbers_eq_factoredNumbers]\n    using factoredNumbers_compl <| Finset.filter_subset _ (Finset.range N)\n\n"}
{"name":"Nat.pow_mul_mem_smoothNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"p n : Nat\nhp : Ne p 0\ne : Nat\nhn : Membership.mem p.smoothNumbers n\n⊢ Membership.mem p.succ.smoothNumbers (HMul.hMul (HPow.hPow p e) n)","decl":"/-- If `p` is positive and `n` is `p`-smooth, then every product `p^e * n` is `(p+1)`-smooth. -/\nlemma pow_mul_mem_smoothNumbers {p n : ℕ} (hp : p ≠ 0) (e : ℕ) (hn : n ∈ smoothNumbers p) :\n    p ^ e * n ∈ smoothNumbers (succ p) := by\n  -- This cannot be easily reduced to `pow_mul_mem_factoredNumbers`, as there `p.Prime` is needed.\n  have : NoZeroDivisors ℕ := inferInstance -- this is needed twice --> speed-up\n  have hp' := pow_ne_zero e hp\n  refine ⟨mul_ne_zero hp' hn.1, fun q hq ↦ ?_⟩\n  rcases (mem_primeFactorsList_mul hp' hn.1).mp hq with H | H\n  · rw [mem_primeFactorsList hp'] at H\n    exact lt_succ.mpr <| le_of_dvd hp.bot_lt <| H.1.dvd_of_dvd_pow H.2\n  · exact (hn.2 q H).trans <| lt_succ_self p\n\n"}
{"name":"Nat.Prime.smoothNumbers_coprime","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"p n : Nat\nhp : Nat.Prime p\nhn : Membership.mem p.smoothNumbers n\n⊢ p.Coprime n","decl":"/-- If `p` is a prime and `n` is `p`-smooth, then `p` and `n` are coprime. -/\nlemma Prime.smoothNumbers_coprime {p n : ℕ} (hp : p.Prime) (hn : n ∈ smoothNumbers p) :\n    Nat.Coprime p n := by\n  simp only [smoothNumbers_eq_factoredNumbers] at hn\n  exact hp.factoredNumbers_coprime Finset.not_mem_range_self hn\n\n"}
{"name":"Nat.map_prime_pow_mul","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"F : Type u_1\ninst✝ : CommSemiring F\nf : Nat → F\nhmul : ∀ {m n : Nat}, m.Coprime n → Eq (f (HMul.hMul m n)) (HMul.hMul (f m) (f n))\np : Nat\nhp : Nat.Prime p\ne : Nat\nm : ↑p.smoothNumbers\n⊢ Eq (f (HMul.hMul (HPow.hPow p e) ↑m)) (HMul.hMul (f (HPow.hPow p e)) (f ↑m))","decl":"/-- If `f : ℕ → F` is multiplicative on coprime arguments, `p` is a prime and `m` is `p`-smooth,\nthen `f (p^e * m) = f (p^e) * f m`. -/\nlemma map_prime_pow_mul {F : Type*} [CommSemiring F] {f : ℕ → F}\n    (hmul : ∀ {m n}, Nat.Coprime m n → f (m * n) = f m * f n) {p : ℕ} (hp : p.Prime) (e : ℕ)\n    {m : p.smoothNumbers} :\n    f (p ^ e * m) = f (p ^ e) * f m :=\n  hmul <| Coprime.pow_left _ <| hp.smoothNumbers_coprime <| Subtype.mem m\n\n"}
{"name":"Nat.equivProdNatSmoothNumbers_apply","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"p e m : Nat\nhp : Nat.Prime p\nhm : Membership.mem p.smoothNumbers m\n⊢ Eq (↑((Nat.equivProdNatSmoothNumbers hp) { fst := e, snd := ⟨m, hm⟩ })) (HMul.hMul (HPow.hPow p e) m)","decl":"@[simp]\nlemma equivProdNatSmoothNumbers_apply {p e m : ℕ} (hp : p.Prime) (hm : m ∈ p.smoothNumbers) :\n    equivProdNatSmoothNumbers hp (e, ⟨m, hm⟩) = p ^ e * m := rfl\n\n"}
{"name":"Nat.equivProdNatSmoothNumbers_apply'","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"p : Nat\nhp : Nat.Prime p\nx : Prod Nat ↑p.smoothNumbers\n⊢ Eq (↑((Nat.equivProdNatSmoothNumbers hp) x)) (HMul.hMul (HPow.hPow p x.1) ↑x.2)","decl":"@[simp]\nlemma equivProdNatSmoothNumbers_apply' {p : ℕ} (hp : p.Prime) (x : ℕ × p.smoothNumbers) :\n    equivProdNatSmoothNumbers hp x = p ^ x.1 * x.2 := rfl\n\n\n"}
{"name":"Nat.mem_smoothNumbersUpTo","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"N k n : Nat\n⊢ Iff (Membership.mem (N.smoothNumbersUpTo k) n) (And (LE.le n N) (Membership.mem k.smoothNumbers n))","decl":"lemma mem_smoothNumbersUpTo {N k n : ℕ} :\n    n ∈ smoothNumbersUpTo N k ↔ n ≤ N ∧ n ∈ smoothNumbers k := by\n  simp [smoothNumbersUpTo, lt_succ]\n\n"}
{"name":"Nat.smoothNumbersUpTo_card_add_roughNumbersUpTo_card","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"N k : Nat\n⊢ Eq (HAdd.hAdd (N.smoothNumbersUpTo k).card (N.roughNumbersUpTo k).card) N","decl":"lemma smoothNumbersUpTo_card_add_roughNumbersUpTo_card (N k : ℕ) :\n    (smoothNumbersUpTo N k).card + (roughNumbersUpTo N k).card = N := by\n  rw [smoothNumbersUpTo, roughNumbersUpTo,\n    ← Finset.card_union_of_disjoint <| Finset.disjoint_filter.mpr fun n _ hn₂ h ↦ h.2 hn₂,\n    Finset.filter_union_right]\n  suffices Finset.card (Finset.filter (fun x ↦ x ≠ 0) (Finset.range (succ N))) = N by\n    have hn' (n) : n ∈ smoothNumbers k ∨ n ≠ 0 ∧ n ∉ smoothNumbers k ↔ n ≠ 0 := by\n      have : n ∈ smoothNumbers k → n ≠ 0 := ne_zero_of_mem_smoothNumbers\n      refine ⟨fun H ↦ Or.elim H this fun H ↦ H.1, fun H ↦ ?_⟩\n      simp only [ne_eq, H, not_false_eq_true, true_and, or_not]\n    rwa [Finset.filter_congr (s := Finset.range (succ N)) fun n _ ↦ hn' n]\n  rw [Finset.filter_ne', Finset.card_erase_of_mem <| Finset.mem_range_succ_iff.mpr <| zero_le N]\n  simp only [Finset.card_range, succ_sub_succ_eq_sub, tsub_zero]\n\n"}
{"name":"Nat.eq_prod_primes_mul_sq_of_mem_smoothNumbers","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"n k : Nat\nh : Membership.mem k.smoothNumbers n\n⊢ Exists fun s => And (Membership.mem k.primesBelow.powerset s) (Exists fun m => Eq n (HMul.hMul (HPow.hPow m 2) (s.prod id)))","decl":"/-- A `k`-smooth number can be written as a square times a product of distinct primes `< k`. -/\nlemma eq_prod_primes_mul_sq_of_mem_smoothNumbers {n k : ℕ} (h : n ∈ smoothNumbers k) :\n    ∃ s ∈ k.primesBelow.powerset, ∃ m, n = m ^ 2 * (s.prod id) := by\n  obtain ⟨l, m, H₁, H₂⟩ := sq_mul_squarefree n\n  have hl : l ∈ smoothNumbers k := mem_smoothNumbers_of_dvd h (Dvd.intro_left (m ^ 2) H₁)\n  refine ⟨l.primeFactorsList.toFinset, ?_,  m, ?_⟩\n  · simp only [toFinset_factors, Finset.mem_powerset]\n    refine fun p hp ↦ mem_primesBelow.mpr ⟨?_, (mem_primeFactors.mp hp).1⟩\n    rw [mem_primeFactors] at hp\n    exact mem_smoothNumbers'.mp hl p hp.1 hp.2.1\n  rw [← H₁]\n  congr\n  simp only [toFinset_factors]\n  exact (prod_primeFactors_of_squarefree H₂).symm\n\n"}
{"name":"Nat.smoothNumbersUpTo_subset_image","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"N k : Nat\n⊢ HasSubset.Subset (N.smoothNumbersUpTo k) (Finset.image (fun x => Nat.smoothNumbersUpTo_subset_image.match_1 (fun x => Nat) x fun s m => HMul.hMul (HPow.hPow m 2) (s.prod id)) (SProd.sprod k.primesBelow.powerset ((Finset.range N.sqrt.succ).erase 0)))","decl":"/-- The set of `k`-smooth numbers `≤ N` is contained in the set of numbers of the form `m^2 * P`,\nwhere `m ≤ √N` and `P` is a product of distinct primes `< k`. -/\nlemma smoothNumbersUpTo_subset_image (N k : ℕ) :\n    smoothNumbersUpTo N k ⊆ Finset.image (fun (s, m) ↦ m ^ 2 * (s.prod id))\n      (k.primesBelow.powerset ×ˢ (Finset.range N.sqrt.succ).erase 0) := by\n  intro n hn\n  obtain ⟨hn₁, hn₂⟩ := mem_smoothNumbersUpTo.mp hn\n  obtain ⟨s, hs, m, hm⟩ := eq_prod_primes_mul_sq_of_mem_smoothNumbers hn₂\n  simp only [id_eq, Finset.mem_range, zero_lt_succ, not_true_eq_false, Finset.mem_image,\n    Finset.mem_product, Finset.mem_powerset, Finset.mem_erase, Prod.exists]\n  refine ⟨s, m, ⟨Finset.mem_powerset.mp hs, ?_, ?_⟩, hm.symm⟩\n  · have := hm ▸ ne_zero_of_mem_smoothNumbers hn₂\n    simp only [ne_eq, _root_.mul_eq_zero, sq_eq_zero_iff, not_or] at this\n    exact this.1\n  · rw [lt_succ, le_sqrt']\n    refine LE.le.trans ?_ (hm ▸ hn₁)\n    nth_rw 1 [← mul_one (m ^ 2)]\n    exact mul_le_mul_left' (Finset.one_le_prod' fun p hp ↦\n      (prime_of_mem_primesBelow <| Finset.mem_powerset.mp hs hp).one_lt.le) _\n\n"}
{"name":"Nat.smoothNumbersUpTo_card_le","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"N k : Nat\n⊢ LE.le (N.smoothNumbersUpTo k).card (HMul.hMul (HPow.hPow 2 k.primesBelow.card) N.sqrt)","decl":"/-- The cardinality of the set of `k`-smooth numbers `≤ N` is bounded by `2^π(k-1) * √N`. -/\nlemma smoothNumbersUpTo_card_le (N k : ℕ) :\n    (smoothNumbersUpTo N k).card ≤ 2 ^ k.primesBelow.card * N.sqrt := by\n  convert (Finset.card_le_card <| smoothNumbersUpTo_subset_image N k).trans <|\n    Finset.card_image_le\n  simp only [Finset.card_product, Finset.card_powerset, Finset.mem_range, zero_lt_succ,\n    Finset.card_erase_of_mem, Finset.card_range, succ_sub_succ_eq_sub, tsub_zero]\n\n"}
{"name":"Nat.roughNumbersUpTo_eq_biUnion","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"N k : Nat\n⊢ Eq (N.roughNumbersUpTo k) ((SDiff.sdiff N.succ.primesBelow k.primesBelow).biUnion fun p => Finset.filter (fun m => And (Ne m 0) (Dvd.dvd p m)) (Finset.range N.succ))","decl":"/-- The set of `k`-rough numbers `≤ N` can be written as the union of the sets of multiples `≤ N`\nof primes `k ≤ p ≤ N`. -/\nlemma roughNumbersUpTo_eq_biUnion (N k) :\n    roughNumbersUpTo N k =\n      (N.succ.primesBelow \\ k.primesBelow).biUnion\n        fun p ↦ (Finset.range N.succ).filter (fun m ↦ m ≠ 0 ∧ p ∣ m) := by\n  ext m\n  simp only [roughNumbersUpTo, mem_smoothNumbers_iff_forall_le, not_and, not_forall,\n    not_lt, exists_prop, exists_and_left, Finset.mem_range, not_le, Finset.mem_filter,\n    Finset.filter_congr_decidable, Finset.mem_biUnion, Finset.mem_sdiff, mem_primesBelow,\n    show ∀ P Q : Prop, P ∧ (P → Q) ↔ P ∧ Q by tauto]\n  simp_rw [← exists_and_left, ← not_lt]\n  refine exists_congr fun p ↦ ?_\n  have H₁ : m ≠ 0 → p ∣ m → m < N.succ → p < N.succ :=\n    fun h₁ h₂ h₃ ↦ (le_of_dvd (Nat.pos_of_ne_zero h₁) h₂).trans_lt h₃\n  have H₂ : m ≠ 0 → p ∣ m → ¬ m < p :=\n    fun h₁ h₂ ↦ not_lt.mpr <| le_of_dvd (Nat.pos_of_ne_zero h₁) h₂\n  constructor\n  · rintro ⟨h₁, h₂, _, h₄, h₅, h₆⟩\n    exact ⟨⟨⟨H₁ h₂ h₅ h₁, h₄⟩, fun h _ ↦ h₆ h⟩, h₁, h₂, h₅⟩\n  · rintro ⟨⟨⟨_, h₂⟩, h₃⟩, h₄, h₅, h₆⟩\n    exact ⟨h₄, h₅, H₂ h₅ h₆, h₂, h₆, fun h ↦ h₃ h h₂⟩\n\n"}
{"name":"Nat.roughNumbersUpTo_card_le","module":"Mathlib.NumberTheory.SmoothNumbers","initialProofState":"N k : Nat\n⊢ LE.le (N.roughNumbersUpTo k).card ((SDiff.sdiff N.succ.primesBelow k.primesBelow).sum fun p => HDiv.hDiv N p)","decl":"/-- The cardinality of the set of `k`-rough numbers `≤ N` is bounded by the sum of `⌊N/p⌋`\nover the primes `k ≤ p ≤ N`. -/\nlemma roughNumbersUpTo_card_le (N k : ℕ) :\n    (roughNumbersUpTo N k).card ≤ (N.succ.primesBelow \\ k.primesBelow).sum (fun p ↦ N / p) := by\n  rw [roughNumbersUpTo_eq_biUnion]\n  exact Finset.card_biUnion_le.trans <| Finset.sum_le_sum fun p _ ↦ (card_multiples' N p).le\n\n"}
