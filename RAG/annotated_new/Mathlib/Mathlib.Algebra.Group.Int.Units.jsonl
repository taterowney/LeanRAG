{"name":"Int.units_natAbs","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u : Units Int\n⊢ Eq (↑u).natAbs 1","decl":"lemma units_natAbs (u : ℤˣ) : natAbs u = 1 :=\n  Units.ext_iff.1 <|\n    Nat.units_eq_one\n      ⟨natAbs u, natAbs ↑u⁻¹, by rw [← natAbs_mul, Units.mul_inv]; rfl, by\n        rw [← natAbs_mul, Units.inv_mul]; rfl⟩\n\n"}
{"name":"Int.natAbs_of_isUnit","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u : Int\nhu : IsUnit u\n⊢ Eq u.natAbs 1","decl":"@[simp] lemma natAbs_of_isUnit (hu : IsUnit u) : natAbs u = 1 := units_natAbs hu.unit\n\n"}
{"name":"Int.isUnit_eq_one_or","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u : Int\nhu : IsUnit u\n⊢ Or (Eq u 1) (Eq u (-1))","decl":"lemma isUnit_eq_one_or (hu : IsUnit u) : u = 1 ∨ u = -1 := by\n  simpa only [natAbs_of_isUnit hu] using natAbs_eq u\n\n"}
{"name":"Int.isUnit_ne_iff_eq_neg","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u v : Int\nhu : IsUnit u\nhv : IsUnit v\n⊢ Iff (Ne u v) (Eq u (Neg.neg v))","decl":"lemma isUnit_ne_iff_eq_neg (hu : IsUnit u) (hv : IsUnit v) : u ≠ v ↔ u = -v := by\n  obtain rfl | rfl := isUnit_eq_one_or hu <;> obtain rfl | rfl := isUnit_eq_one_or hv <;> decide\n\n"}
{"name":"Int.isUnit_eq_or_eq_neg","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u v : Int\nhu : IsUnit u\nhv : IsUnit v\n⊢ Or (Eq u v) (Eq u (Neg.neg v))","decl":"lemma isUnit_eq_or_eq_neg (hu : IsUnit u) (hv : IsUnit v) : u = v ∨ u = -v :=\n  or_iff_not_imp_left.2 (isUnit_ne_iff_eq_neg hu hv).1\n\n"}
{"name":"Int.isUnit_iff","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u : Int\n⊢ Iff (IsUnit u) (Or (Eq u 1) (Eq u (-1)))","decl":"lemma isUnit_iff : IsUnit u ↔ u = 1 ∨ u = -1 := by\n  refine ⟨fun h ↦ isUnit_eq_one_or h, fun h ↦ ?_⟩\n  rcases h with (rfl | rfl)\n  · exact isUnit_one\n  · exact ⟨⟨-1, -1, by decide, by decide⟩, rfl⟩\n\n"}
{"name":"Int.eq_one_or_neg_one_of_mul_eq_one","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u v : Int\nh : Eq (HMul.hMul u v) 1\n⊢ Or (Eq u 1) (Eq u (-1))","decl":"lemma eq_one_or_neg_one_of_mul_eq_one (h : u * v = 1) : u = 1 ∨ u = -1 :=\n  isUnit_iff.1 (isUnit_of_mul_eq_one u v h)\n\n"}
{"name":"Int.eq_one_or_neg_one_of_mul_eq_one'","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u v : Int\nh : Eq (HMul.hMul u v) 1\n⊢ Or (And (Eq u 1) (Eq v 1)) (And (Eq u (-1)) (Eq v (-1)))","decl":"lemma eq_one_or_neg_one_of_mul_eq_one' (h : u * v = 1) : u = 1 ∧ v = 1 ∨ u = -1 ∧ v = -1 := by\n  have h' : v * u = 1 := mul_comm u v ▸ h\n  obtain rfl | rfl := eq_one_or_neg_one_of_mul_eq_one h <;>\n      obtain rfl | rfl := eq_one_or_neg_one_of_mul_eq_one h' <;> tauto\n\n"}
{"name":"Int.eq_of_mul_eq_one","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u v : Int\nh : Eq (HMul.hMul u v) 1\n⊢ Eq u v","decl":"lemma eq_of_mul_eq_one (h : u * v = 1) : u = v :=\n  (eq_one_or_neg_one_of_mul_eq_one' h).elim\n    (and_imp.2 (·.trans ·.symm)) (and_imp.2 (·.trans ·.symm))\n\n"}
{"name":"Int.mul_eq_one_iff_eq_one_or_neg_one","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u v : Int\n⊢ Iff (Eq (HMul.hMul u v) 1) (Or (And (Eq u 1) (Eq v 1)) (And (Eq u (-1)) (Eq v (-1))))","decl":"lemma mul_eq_one_iff_eq_one_or_neg_one : u * v = 1 ↔ u = 1 ∧ v = 1 ∨ u = -1 ∧ v = -1 := by\n  refine ⟨eq_one_or_neg_one_of_mul_eq_one', fun h ↦ Or.elim h (fun H ↦ ?_) fun H ↦ ?_⟩ <;>\n    obtain ⟨rfl, rfl⟩ := H <;> rfl\n\n"}
{"name":"Int.eq_one_or_neg_one_of_mul_eq_neg_one'","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u v : Int\nh : Eq (HMul.hMul u v) (-1)\n⊢ Or (And (Eq u 1) (Eq v (-1))) (And (Eq u (-1)) (Eq v 1))","decl":"lemma eq_one_or_neg_one_of_mul_eq_neg_one' (h : u * v = -1) : u = 1 ∧ v = -1 ∨ u = -1 ∧ v = 1 := by\n  obtain rfl | rfl := isUnit_eq_one_or (IsUnit.mul_iff.mp (Int.isUnit_iff.mpr (Or.inr h))).1\n  · exact Or.inl ⟨rfl, one_mul v ▸ h⟩\n  · simpa [Int.neg_mul] using h\n\n"}
{"name":"Int.mul_eq_neg_one_iff_eq_one_or_neg_one","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u v : Int\n⊢ Iff (Eq (HMul.hMul u v) (-1)) (Or (And (Eq u 1) (Eq v (-1))) (And (Eq u (-1)) (Eq v 1)))","decl":"lemma mul_eq_neg_one_iff_eq_one_or_neg_one : u * v = -1 ↔ u = 1 ∧ v = -1 ∨ u = -1 ∧ v = 1 := by\n  refine ⟨eq_one_or_neg_one_of_mul_eq_neg_one', fun h ↦ Or.elim h (fun H ↦ ?_) fun H ↦ ?_⟩ <;>\n    obtain ⟨rfl, rfl⟩ := H <;> rfl\n\n"}
{"name":"Int.isUnit_iff_natAbs_eq","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u : Int\n⊢ Iff (IsUnit u) (Eq u.natAbs 1)","decl":"lemma isUnit_iff_natAbs_eq : IsUnit u ↔ u.natAbs = 1 := by simp [natAbs_eq_iff, isUnit_iff]\n\n"}
{"name":"Int.IsUnit.natAbs_eq","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u : Int\na✝ : IsUnit u\n⊢ Eq u.natAbs 1","decl":"alias ⟨IsUnit.natAbs_eq, _⟩ := isUnit_iff_natAbs_eq\n\n-- Porting note: `rw` didn't work on `natAbs_ofNat`, so had to change to `simp`,\n-- presumably because `(n : ℤ)` is `Nat.cast` and not just `ofNat`\n"}
{"name":"Int.ofNat_isUnit","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"n : Nat\n⊢ Iff (IsUnit ↑n) (IsUnit n)","decl":"@[norm_cast]\nlemma ofNat_isUnit {n : ℕ} : IsUnit (n : ℤ) ↔ IsUnit n := by simp [isUnit_iff_natAbs_eq]\n\n"}
{"name":"Int.isUnit_mul_self","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u : Int\nhu : IsUnit u\n⊢ Eq (HMul.hMul u u) 1","decl":"lemma isUnit_mul_self (hu : IsUnit u) : u * u = 1 :=\n  (isUnit_eq_one_or hu).elim (fun h ↦ h.symm ▸ rfl) fun h ↦ h.symm ▸ rfl\n\n"}
{"name":"Int.isUnit_add_isUnit_eq_isUnit_add_isUnit","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"a b c d : Int\nha : IsUnit a\nhb : IsUnit b\nhc : IsUnit c\nhd : IsUnit d\n⊢ Iff (Eq (HAdd.hAdd a b) (HAdd.hAdd c d)) (Or (And (Eq a c) (Eq b d)) (And (Eq a d) (Eq b c)))","decl":"lemma isUnit_add_isUnit_eq_isUnit_add_isUnit {a b c d : ℤ} (ha : IsUnit a) (hb : IsUnit b)\n    (hc : IsUnit c) (hd : IsUnit d) : a + b = c + d ↔ a = c ∧ b = d ∨ a = d ∧ b = c := by\n  rw [isUnit_iff] at ha hb hc hd\n  aesop\n\n"}
{"name":"Int.eq_one_or_neg_one_of_mul_eq_neg_one","module":"Mathlib.Algebra.Group.Int.Units","initialProofState":"u v : Int\nh : Eq (HMul.hMul u v) (-1)\n⊢ Or (Eq u 1) (Eq u (-1))","decl":"lemma eq_one_or_neg_one_of_mul_eq_neg_one (h : u * v = -1) : u = 1 ∨ u = -1 :=\n  Or.elim (eq_one_or_neg_one_of_mul_eq_neg_one' h) (fun H => Or.inl H.1) fun H => Or.inr H.1\n\n"}
