{"name":"OmegaCompletePartialOrder.Chain.instOrderHomClassNat","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : Preorder Î±\nâŠ¢ OrderHomClass (OmegaCompletePartialOrder.Chain Î±) Nat Î±","decl":"instance : OrderHomClass (Chain Î±) â„• Î± := inferInstanceAs <| OrderHomClass (â„• â†’o Î±) â„• Î±\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.isChain_range","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : Preorder Î±\nc : OmegaCompletePartialOrder.Chain Î±\nâŠ¢ IsChain (fun x1 x2 => LE.le x1 x2) (Set.range â‡‘c)","decl":"lemma isChain_range : IsChain (Â· â‰¤ Â·) (Set.range c) := Monotone.isChain_range (OrderHomClass.mono c)\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.directed","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : Preorder Î±\nc : OmegaCompletePartialOrder.Chain Î±\nâŠ¢ Directed (fun x1 x2 => LE.le x1 x2) â‡‘c","decl":"lemma directed : Directed (Â· â‰¤ Â·) c := directedOn_range.2 c.isChain_range.directedOn\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.map_coe","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Preorder Î±\ninstâœ : Preorder Î²\nc : OmegaCompletePartialOrder.Chain Î±\nf : OrderHom Î± Î²\nâŠ¢ Eq (â‡‘(c.map f)) (Function.comp â‡‘f â‡‘c)","decl":"@[simp] theorem map_coe : â‡‘(map c f) = f âˆ˜ c := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.mem_map","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Preorder Î±\ninstâœ : Preorder Î²\nc : OmegaCompletePartialOrder.Chain Î±\nf : OrderHom Î± Î²\nx : Î±\naâœ : Membership.mem c x\nâŠ¢ Membership.mem (c.map f) (f x)","decl":"theorem mem_map (x : Î±) : x âˆˆ c â†’ f x âˆˆ Chain.map c f :=\n  fun âŸ¨i, hâŸ© => âŸ¨i, h.symm â–¸ rflâŸ©\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.exists_of_mem_map","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Preorder Î±\ninstâœ : Preorder Î²\nc : OmegaCompletePartialOrder.Chain Î±\nf : OrderHom Î± Î²\nb : Î²\naâœ : Membership.mem (c.map f) b\nâŠ¢ Exists fun a => And (Membership.mem c a) (Eq (f a) b)","decl":"theorem exists_of_mem_map {b : Î²} : b âˆˆ c.map f â†’ âˆƒ a, a âˆˆ c âˆ§ f a = b :=\n  fun âŸ¨i, hâŸ© => âŸ¨c i, âŸ¨i, rflâŸ©, h.symmâŸ©\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.mem_map_iff","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Preorder Î±\ninstâœ : Preorder Î²\nc : OmegaCompletePartialOrder.Chain Î±\nf : OrderHom Î± Î²\nb : Î²\nâŠ¢ Iff (Membership.mem (c.map f) b) (Exists fun a => And (Membership.mem c a) (Eq (f a) b))","decl":"@[simp]\ntheorem mem_map_iff {b : Î²} : b âˆˆ c.map f â†” âˆƒ a, a âˆˆ c âˆ§ f a = b :=\n  âŸ¨exists_of_mem_map _, fun h => by\n    rcases h with âŸ¨w, h, h'âŸ©\n    subst b\n    apply mem_map c _ hâŸ©\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.map_id","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : Preorder Î±\nc : OmegaCompletePartialOrder.Chain Î±\nâŠ¢ Eq (c.map OrderHom.id) c","decl":"@[simp]\ntheorem map_id : c.map OrderHom.id = c :=\n  OrderHom.comp_id _\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.map_comp","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : Preorder Î²\ninstâœ : Preorder Î³\nc : OmegaCompletePartialOrder.Chain Î±\nf : OrderHom Î± Î²\ng : OrderHom Î² Î³\nâŠ¢ Eq ((c.map f).map g) (c.map (g.comp f))","decl":"theorem map_comp : (c.map f).map g = c.map (g.comp f) :=\n  rfl\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.map_le_map","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Preorder Î±\ninstâœ : Preorder Î²\nc : OmegaCompletePartialOrder.Chain Î±\nf g : OrderHom Î± Î²\nh : LE.le f g\nâŠ¢ LE.le (c.map f) (c.map g)","decl":"@[mono]\ntheorem map_le_map {g : Î± â†’o Î²} (h : f â‰¤ g) : c.map f â‰¤ c.map g :=\n  fun i => by simp only [map_coe, Function.comp_apply]; exists i; apply h\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.zip_coe","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Preorder Î±\ninstâœ : Preorder Î²\ncâ‚€ : OmegaCompletePartialOrder.Chain Î±\ncâ‚ : OmegaCompletePartialOrder.Chain Î²\nn : Nat\nâŠ¢ Eq ((câ‚€.zip câ‚) n) { fst := câ‚€ n, snd := câ‚ n }","decl":"@[simp] theorem zip_coe (câ‚€ : Chain Î±) (câ‚ : Chain Î²) (n : â„•) : câ‚€.zip câ‚ n = (câ‚€ n, câ‚ n) := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.pair_zero","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : Preorder Î±\na b : Î±\nhab : LE.le a b\nâŠ¢ Eq ((OmegaCompletePartialOrder.Chain.pair a b hab) 0) a","decl":"@[simp] lemma pair_zero (a b : Î±) (hab) : pair a b hab 0 = a := rfl\n"}
{"name":"OmegaCompletePartialOrder.Chain.pair_succ","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : Preorder Î±\na b : Î±\nhab : LE.le a b\nn : Nat\nâŠ¢ Eq ((OmegaCompletePartialOrder.Chain.pair a b hab) (HAdd.hAdd n 1)) b","decl":"@[simp] lemma pair_succ (a b : Î±) (hab) (n : â„•) : pair a b hab (n + 1) = b := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.range_pair","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : Preorder Î±\na b : Î±\nhab : LE.le a b\nâŠ¢ Eq (Set.range â‡‘(OmegaCompletePartialOrder.Chain.pair a b hab)) (Insert.insert a (Singleton.singleton b))","decl":"@[simp] lemma range_pair (a b : Î±) (hab) : Set.range (pair a b hab) = {a, b} := by\n  ext; exact Nat.or_exists_add_one.symm.trans (by aesop)\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.pair_zip_pair","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Preorder Î±\ninstâœ : Preorder Î²\naâ‚ aâ‚‚ : Î±\nbâ‚ bâ‚‚ : Î²\nha : LE.le aâ‚ aâ‚‚\nhb : LE.le bâ‚ bâ‚‚\nâŠ¢ Eq ((OmegaCompletePartialOrder.Chain.pair aâ‚ aâ‚‚ ha).zip (OmegaCompletePartialOrder.Chain.pair bâ‚ bâ‚‚ hb)) (OmegaCompletePartialOrder.Chain.pair { fst := aâ‚, snd := bâ‚ } { fst := aâ‚‚, snd := bâ‚‚ } â‹¯)","decl":"@[simp] lemma pair_zip_pair (aâ‚ aâ‚‚ : Î±) (bâ‚ bâ‚‚ : Î²) (ha hb) :\n    (pair aâ‚ aâ‚‚ ha).zip (pair bâ‚ bâ‚‚ hb) = pair (aâ‚, bâ‚) (aâ‚‚, bâ‚‚) (Prod.le_def.2 âŸ¨ha, hbâŸ©) := by\n  unfold Chain; ext n : 2; cases n <;> rfl\n\n"}
{"name":"OmegaCompletePartialOrder.le_Ï‰Sup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_6\nself : OmegaCompletePartialOrder Î±\nc : OmegaCompletePartialOrder.Chain Î±\ni : Nat\nâŠ¢ LE.le (c i) (OmegaCompletePartialOrder.Ï‰Sup c)","decl":"/-- An omega-complete partial order is a partial order with a supremum\noperation on increasing sequences indexed by natural numbers (which we\ncall `Ï‰Sup`). In this sense, it is strictly weaker than join complete\nsemi-lattices as only Ï‰-sized totally ordered sets have a supremum.\n\nSee the definition on page 114 of [gunter1992]. -/\nclass OmegaCompletePartialOrder (Î± : Type*) extends PartialOrder Î± where\n  /-- The supremum of an increasing sequence -/\n  Ï‰Sup : Chain Î± â†’ Î±\n  /-- `Ï‰Sup` is an upper bound of the increasing sequence -/\n  le_Ï‰Sup : âˆ€ c : Chain Î±, âˆ€ i, c i â‰¤ Ï‰Sup c\n  /-- `Ï‰Sup` is a lower bound of the set of upper bounds of the increasing sequence -/\n  Ï‰Sup_le : âˆ€ (c : Chain Î±) (x), (âˆ€ i, c i â‰¤ x) â†’ Ï‰Sup c â‰¤ x\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰Sup_le","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_6\nself : OmegaCompletePartialOrder Î±\nc : OmegaCompletePartialOrder.Chain Î±\nx : Î±\naâœ : âˆ€ (i : Nat), LE.le (c i) x\nâŠ¢ LE.le (OmegaCompletePartialOrder.Ï‰Sup c) x","decl":"/-- An omega-complete partial order is a partial order with a supremum\noperation on increasing sequences indexed by natural numbers (which we\ncall `Ï‰Sup`). In this sense, it is strictly weaker than join complete\nsemi-lattices as only Ï‰-sized totally ordered sets have a supremum.\n\nSee the definition on page 114 of [gunter1992]. -/\nclass OmegaCompletePartialOrder (Î± : Type*) extends PartialOrder Î± where\n  /-- The supremum of an increasing sequence -/\n  Ï‰Sup : Chain Î± â†’ Î±\n  /-- `Ï‰Sup` is an upper bound of the increasing sequence -/\n  le_Ï‰Sup : âˆ€ c : Chain Î±, âˆ€ i, c i â‰¤ Ï‰Sup c\n  /-- `Ï‰Sup` is a lower bound of the set of upper bounds of the increasing sequence -/\n  Ï‰Sup_le : âˆ€ (c : Chain Î±) (x), (âˆ€ i, c i â‰¤ x) â†’ Ï‰Sup c â‰¤ x\n\n"}
{"name":"OmegaCompletePartialOrder.le_Ï‰Sup_of_le","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nc : OmegaCompletePartialOrder.Chain Î±\nx : Î±\ni : Nat\nh : LE.le x (c i)\nâŠ¢ LE.le x (OmegaCompletePartialOrder.Ï‰Sup c)","decl":"theorem le_Ï‰Sup_of_le {c : Chain Î±} {x : Î±} (i : â„•) (h : x â‰¤ c i) : x â‰¤ Ï‰Sup c :=\n  le_trans h (le_Ï‰Sup c _)\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰Sup_total","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nc : OmegaCompletePartialOrder.Chain Î±\nx : Î±\nh : âˆ€ (i : Nat), Or (LE.le (c i) x) (LE.le x (c i))\nâŠ¢ Or (LE.le (OmegaCompletePartialOrder.Ï‰Sup c) x) (LE.le x (OmegaCompletePartialOrder.Ï‰Sup c))","decl":"theorem Ï‰Sup_total {c : Chain Î±} {x : Î±} (h : âˆ€ i, c i â‰¤ x âˆ¨ x â‰¤ c i) : Ï‰Sup c â‰¤ x âˆ¨ x â‰¤ Ï‰Sup c :=\n  by_cases\n    (fun (this : âˆ€ i, c i â‰¤ x) => Or.inl (Ï‰Sup_le _ _ this))\n    (fun (this : Â¬âˆ€ i, c i â‰¤ x) =>\n      have : âˆƒ i, Â¬c i â‰¤ x := by simp only [not_forall] at this âŠ¢; assumption\n      let âŸ¨i, hxâŸ© := this\n      have : x â‰¤ c i := (h i).resolve_left hx\n      Or.inr <| le_Ï‰Sup_of_le _ this)\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰Sup_le_Ï‰Sup_of_le","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\ncâ‚€ câ‚ : OmegaCompletePartialOrder.Chain Î±\nh : LE.le câ‚€ câ‚\nâŠ¢ LE.le (OmegaCompletePartialOrder.Ï‰Sup câ‚€) (OmegaCompletePartialOrder.Ï‰Sup câ‚)","decl":"@[mono]\ntheorem Ï‰Sup_le_Ï‰Sup_of_le {câ‚€ câ‚ : Chain Î±} (h : câ‚€ â‰¤ câ‚) : Ï‰Sup câ‚€ â‰¤ Ï‰Sup câ‚ :=\n  (Ï‰Sup_le _ _) fun i => by\n    obtain âŸ¨_, hâŸ© := h i\n    exact le_trans h (le_Ï‰Sup _ _)\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰Sup_le_iff","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nc : OmegaCompletePartialOrder.Chain Î±\nx : Î±\nâŠ¢ Iff (LE.le (OmegaCompletePartialOrder.Ï‰Sup c) x) (âˆ€ (i : Nat), LE.le (c i) x)","decl":"@[simp] theorem Ï‰Sup_le_iff {c : Chain Î±} {x : Î±} : Ï‰Sup c â‰¤ x â†” âˆ€ i, c i â‰¤ x := by\n  constructor <;> intros\n  Â· trans Ï‰Sup c\n    Â· exact le_Ï‰Sup _ _\n    Â· assumption\n  exact Ï‰Sup_le _ _ â€¹_â€º\n\n"}
{"name":"OmegaCompletePartialOrder.isLUB_range_Ï‰Sup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nc : OmegaCompletePartialOrder.Chain Î±\nâŠ¢ IsLUB (Set.range â‡‘c) (OmegaCompletePartialOrder.Ï‰Sup c)","decl":"lemma isLUB_range_Ï‰Sup (c : Chain Î±) : IsLUB (Set.range c) (Ï‰Sup c) := by\n  constructor\n  Â· simp only [upperBounds, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff,\n      Set.mem_setOf_eq]\n    exact fun a â†¦ le_Ï‰Sup c a\n  Â· simp only [lowerBounds, upperBounds, Set.mem_range, forall_exists_index,\n      forall_apply_eq_imp_iff, Set.mem_setOf_eq]\n    exact fun â¦ƒaâ¦„ a_1 â†¦ Ï‰Sup_le c a a_1\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰Sup_eq_of_isLUB","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nc : OmegaCompletePartialOrder.Chain Î±\na : Î±\nh : IsLUB (Set.range â‡‘c) a\nâŠ¢ Eq a (OmegaCompletePartialOrder.Ï‰Sup c)","decl":"lemma Ï‰Sup_eq_of_isLUB {c : Chain Î±} {a : Î±} (h : IsLUB (Set.range c) a) : a = Ï‰Sup c := by\n  rw [le_antisymm_iff]\n  simp only [IsLUB, IsLeast, upperBounds, lowerBounds, Set.mem_range, forall_exists_index,\n    forall_apply_eq_imp_iff, Set.mem_setOf_eq] at h\n  constructor\n  Â· apply h.2\n    exact fun a â†¦ le_Ï‰Sup c a\n  Â· rw [Ï‰Sup_le_iff]\n    apply h.1\n\n"}
{"name":"ScottContinuous.Ï‰ScottContinuous","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : Î± â†’ Î²\nhf : ScottContinuous f\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous f","decl":"lemma _root_.ScottContinuous.Ï‰ScottContinuous (hf : ScottContinuous f) : Ï‰ScottContinuous f :=\n  hf.scottContinuousOn\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous.monotone","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : Î± â†’ Î²\nh : OmegaCompletePartialOrder.Ï‰ScottContinuous f\nâŠ¢ Monotone f","decl":"lemma Ï‰ScottContinuous.monotone (h : Ï‰ScottContinuous f) : Monotone f :=\n  ScottContinuousOn.monotone _ (fun a b hab => by\n    use pair a b hab; exact range_pair a b hab) h\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous.isLUB","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : Î± â†’ Î²\nc : OmegaCompletePartialOrder.Chain Î±\nhf : OmegaCompletePartialOrder.Ï‰ScottContinuous f\nâŠ¢ IsLUB (Set.range â‡‘(c.map { toFun := f, monotone' := â‹¯ })) (f (OmegaCompletePartialOrder.Ï‰Sup c))","decl":"lemma Ï‰ScottContinuous.isLUB {c : Chain Î±} (hf : Ï‰ScottContinuous f) :\n    IsLUB (Set.range (c.map âŸ¨f, hf.monotoneâŸ©)) (f (Ï‰Sup c)) := by\n  simpa [map_coe, OrderHom.coe_mk, Set.range_comp]\n    using hf (by simp) (Set.range_nonempty _) (isChain_range c).directedOn (isLUB_range_Ï‰Sup c)\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous.id","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous id","decl":"lemma Ï‰ScottContinuous.id : Ï‰ScottContinuous (id : Î± â†’ Î±) := ScottContinuousOn.id\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous.map_Ï‰Sup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : Î± â†’ Î²\nhf : OmegaCompletePartialOrder.Ï‰ScottContinuous f\nc : OmegaCompletePartialOrder.Chain Î±\nâŠ¢ Eq (f (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map { toFun := f, monotone' := â‹¯ }))","decl":"lemma Ï‰ScottContinuous.map_Ï‰Sup (hf : Ï‰ScottContinuous f) (c : Chain Î±) :\n    f (Ï‰Sup c) = Ï‰Sup (c.map âŸ¨f, hf.monotoneâŸ©) := Ï‰Sup_eq_of_isLUB hf.isLUB\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous_iff_monotone_map_Ï‰Sup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (OmegaCompletePartialOrder.Ï‰ScottContinuous f) (Exists fun hf => âˆ€ (c : OmegaCompletePartialOrder.Chain Î±), Eq (f (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map { toFun := f, monotone' := hf })))","decl":"/-- `Ï‰ScottContinuous f` asserts that `f` is both monotone and distributes over Ï‰Sup. -/\nlemma Ï‰ScottContinuous_iff_monotone_map_Ï‰Sup :\n    Ï‰ScottContinuous f â†” âˆƒ hf : Monotone f, âˆ€ c : Chain Î±, f (Ï‰Sup c) = Ï‰Sup (c.map âŸ¨f, hfâŸ©) := by\n  refine âŸ¨fun hf â†¦ âŸ¨hf.monotone, hf.map_Ï‰SupâŸ©, ?_âŸ©\n  intro hf _ âŸ¨c, hcâŸ© _ _ _ hda\n  convert isLUB_range_Ï‰Sup (c.map { toFun := f, monotone' := hf.1 })\n  Â· rw [map_coe, OrderHom.coe_mk, â† hc, â† (Set.range_comp f â‡‘c)]\n  Â· rw [â† hc] at hda\n    rw [â† hf.2 c, Ï‰Sup_eq_of_isLUB hda]\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous.of_monotone_map_Ï‰Sup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : Î± â†’ Î²\naâœ : Exists fun hf => âˆ€ (c : OmegaCompletePartialOrder.Chain Î±), Eq (f (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map { toFun := f, monotone' := hf }))\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous f","decl":"alias âŸ¨Ï‰ScottContinuous.monotone_map_Ï‰Sup, Ï‰ScottContinuous.of_monotone_map_Ï‰SupâŸ© :=\n  Ï‰ScottContinuous_iff_monotone_map_Ï‰Sup\n\n/- A monotone function `f : Î± â†’o Î²` is Ï‰Scott continuous if and only if it distributes over Ï‰Sup. -/\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous.monotone_map_Ï‰Sup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : Î± â†’ Î²\naâœ : OmegaCompletePartialOrder.Ï‰ScottContinuous f\nâŠ¢ Exists fun hf => âˆ€ (c : OmegaCompletePartialOrder.Chain Î±), Eq (f (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map { toFun := f, monotone' := hf }))","decl":"alias âŸ¨Ï‰ScottContinuous.monotone_map_Ï‰Sup, Ï‰ScottContinuous.of_monotone_map_Ï‰SupâŸ© :=\n  Ï‰ScottContinuous_iff_monotone_map_Ï‰Sup\n\n/- A monotone function `f : Î± â†’o Î²` is Ï‰Scott continuous if and only if it distributes over Ï‰Sup. -/\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous_iff_map_Ï‰Sup_of_orderHom","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : OrderHom Î± Î²\nâŠ¢ Iff (OmegaCompletePartialOrder.Ï‰ScottContinuous â‡‘f) (âˆ€ (c : OmegaCompletePartialOrder.Chain Î±), Eq (f (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map f)))","decl":"lemma Ï‰ScottContinuous_iff_map_Ï‰Sup_of_orderHom {f : Î± â†’o Î²} :\n    Ï‰ScottContinuous f â†” âˆ€ c : Chain Î±, f (Ï‰Sup c) = Ï‰Sup (c.map f) := by\n  rw [Ï‰ScottContinuous_iff_monotone_map_Ï‰Sup]\n  exact exists_prop_of_true f.monotone'\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous.map_Ï‰Sup_of_orderHom","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : OrderHom Î± Î²\naâœ : OmegaCompletePartialOrder.Ï‰ScottContinuous â‡‘f\nc : OmegaCompletePartialOrder.Chain Î±\nâŠ¢ Eq (f (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map f))","decl":"alias âŸ¨Ï‰ScottContinuous.map_Ï‰Sup_of_orderHom, Ï‰ScottContinuous.of_map_Ï‰Sup_of_orderHomâŸ© :=\n  Ï‰ScottContinuous_iff_map_Ï‰Sup_of_orderHom\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous.of_map_Ï‰Sup_of_orderHom","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : OrderHom Î± Î²\naâœ : âˆ€ (c : OmegaCompletePartialOrder.Chain Î±), Eq (f (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map f))\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous â‡‘f","decl":"alias âŸ¨Ï‰ScottContinuous.map_Ï‰Sup_of_orderHom, Ï‰ScottContinuous.of_map_Ï‰Sup_of_orderHomâŸ© :=\n  Ï‰ScottContinuous_iff_map_Ï‰Sup_of_orderHom\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous.comp","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : OmegaCompletePartialOrder Î±\ninstâœÂ¹ : OmegaCompletePartialOrder Î²\ninstâœ : OmegaCompletePartialOrder Î³\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nhg : OmegaCompletePartialOrder.Ï‰ScottContinuous g\nhf : OmegaCompletePartialOrder.Ï‰ScottContinuous f\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous (Function.comp g f)","decl":"lemma Ï‰ScottContinuous.comp (hg : Ï‰ScottContinuous g) (hf : Ï‰ScottContinuous f) :\n    Ï‰ScottContinuous (g.comp f) :=\n  Ï‰ScottContinuous.of_monotone_map_Ï‰Sup\n    âŸ¨hg.monotone.comp hf.monotone, by simp [hf.map_Ï‰Sup, hg.map_Ï‰Sup, map_comp]âŸ©\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous.const","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nx : Î²\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous (Function.const Î± x)","decl":"lemma Ï‰ScottContinuous.const {x : Î²} : Ï‰ScottContinuous (Function.const Î± x) := by\n  simp [Ï‰ScottContinuous, ScottContinuousOn, Set.range_nonempty]\n\n"}
{"name":"Part.eq_of_chain","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nc : OmegaCompletePartialOrder.Chain (Part Î±)\na b : Î±\nha : Membership.mem c (Part.some a)\nhb : Membership.mem c (Part.some b)\nâŠ¢ Eq a b","decl":"theorem eq_of_chain {c : Chain (Part Î±)} {a b : Î±} (ha : some a âˆˆ c) (hb : some b âˆˆ c) : a = b := by\n  cases' ha with i ha; replace ha := ha.symm\n  cases' hb with j hb; replace hb := hb.symm\n  rw [eq_some_iff] at ha hb\n  rcases le_total i j with hij | hji\n  Â· have := c.monotone hij _ ha; apply mem_unique this hb\n  Â· have := c.monotone hji _ hb; apply Eq.symm; apply mem_unique this ha\n  -- Porting note: Old proof\n  -- wlog h : i â‰¤ j := le_total i j using a b i j, b a j i\n  -- rw [eq_some_iff] at ha hb\n  -- have := c.monotone h _ ha; apply mem_unique this hb\n\n"}
{"name":"Part.Ï‰Sup_eq_some","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nc : OmegaCompletePartialOrder.Chain (Part Î±)\na : Î±\nh : Membership.mem c (Part.some a)\nâŠ¢ Eq (Part.Ï‰Sup c) (Part.some a)","decl":"theorem Ï‰Sup_eq_some {c : Chain (Part Î±)} {a : Î±} (h : some a âˆˆ c) : Part.Ï‰Sup c = some a :=\n  have : âˆƒ a, some a âˆˆ c := âŸ¨a, hâŸ©\n  have a' : some (Classical.choose this) âˆˆ c := Classical.choose_spec this\n  calc\n    Part.Ï‰Sup c = some (Classical.choose this) := dif_pos this\n    _ = some a := congr_arg _ (eq_of_chain a' h)\n\n"}
{"name":"Part.Ï‰Sup_eq_none","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nc : OmegaCompletePartialOrder.Chain (Part Î±)\nh : Not (Exists fun a => Membership.mem c (Part.some a))\nâŠ¢ Eq (Part.Ï‰Sup c) Part.none","decl":"theorem Ï‰Sup_eq_none {c : Chain (Part Î±)} (h : Â¬âˆƒ a, some a âˆˆ c) : Part.Ï‰Sup c = none :=\n  dif_neg h\n\n"}
{"name":"Part.mem_chain_of_mem_Ï‰Sup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nc : OmegaCompletePartialOrder.Chain (Part Î±)\na : Î±\nh : Membership.mem (Part.Ï‰Sup c) a\nâŠ¢ Membership.mem c (Part.some a)","decl":"theorem mem_chain_of_mem_Ï‰Sup {c : Chain (Part Î±)} {a : Î±} (h : a âˆˆ Part.Ï‰Sup c) : some a âˆˆ c := by\n  simp only [Part.Ï‰Sup] at h; split_ifs at h with h_1\n  Â· have h' := Classical.choose_spec h_1\n    rw [â† eq_some_iff] at h\n    rw [â† h]\n    exact h'\n  Â· rcases h with âŸ¨âŸ¨âŸ©âŸ©\n\n"}
{"name":"Part.mem_Ï‰Sup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nx : Î±\nc : OmegaCompletePartialOrder.Chain (Part Î±)\nâŠ¢ Iff (Membership.mem (OmegaCompletePartialOrder.Ï‰Sup c) x) (Membership.mem c (Part.some x))","decl":"theorem mem_Ï‰Sup (x : Î±) (c : Chain (Part Î±)) : x âˆˆ Ï‰Sup c â†” some x âˆˆ c := by\n  simp only [Ï‰Sup, Part.Ï‰Sup]\n  constructor\n  Â· split_ifs with h\n    swap\n    Â· rintro âŸ¨âŸ¨âŸ©âŸ©\n    intro h'\n    have hh := Classical.choose_spec h\n    simp only [mem_some_iff] at h'\n    subst x\n    exact hh\n  Â· intro h\n    have h' : âˆƒ a : Î±, some a âˆˆ c := âŸ¨_, hâŸ©\n    rw [dif_pos h']\n    have hh := Classical.choose_spec h'\n    rw [eq_of_chain hh h]\n    simp\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous.applyâ‚‚","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ³ : Type u_4\nÎ² : Î± â†’ Type u_6\ninstâœÂ¹ : (x : Î±) â†’ OmegaCompletePartialOrder (Î² x)\ninstâœ : OmegaCompletePartialOrder Î³\nf : Î³ â†’ (x : Î±) â†’ Î² x\nhf : OmegaCompletePartialOrder.Ï‰ScottContinuous f\na : Î±\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous fun x => f x a","decl":"lemma Ï‰ScottContinuous.applyâ‚‚ (hf : Ï‰ScottContinuous f) (a : Î±) : Ï‰ScottContinuous (f Â· a) :=\n  Ï‰ScottContinuous.of_monotone_map_Ï‰Sup\n    âŸ¨fun _ _ h â†¦ hf.monotone h a, fun c â†¦ congr_fun (hf.map_Ï‰Sup c) aâŸ©\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous.of_applyâ‚‚","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ³ : Type u_4\nÎ² : Î± â†’ Type u_6\ninstâœÂ¹ : (x : Î±) â†’ OmegaCompletePartialOrder (Î² x)\ninstâœ : OmegaCompletePartialOrder Î³\nf : Î³ â†’ (x : Î±) â†’ Î² x\nhf : âˆ€ (a : Î±), OmegaCompletePartialOrder.Ï‰ScottContinuous fun x => f x a\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous f","decl":"lemma Ï‰ScottContinuous.of_applyâ‚‚ (hf : âˆ€ a, Ï‰ScottContinuous (f Â· a)) : Ï‰ScottContinuous f :=\n  Ï‰ScottContinuous.of_monotone_map_Ï‰Sup\n    âŸ¨fun _ _ h a â†¦ (hf a).monotone h, fun c â†¦ by ext a; apply (hf a).map_Ï‰Sup câŸ©\n\n"}
{"name":"OmegaCompletePartialOrder.Ï‰ScottContinuous_iff_applyâ‚‚","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ³ : Type u_4\nÎ² : Î± â†’ Type u_6\ninstâœÂ¹ : (x : Î±) â†’ OmegaCompletePartialOrder (Î² x)\ninstâœ : OmegaCompletePartialOrder Î³\nf : Î³ â†’ (x : Î±) â†’ Î² x\nâŠ¢ Iff (OmegaCompletePartialOrder.Ï‰ScottContinuous f) (âˆ€ (a : Î±), OmegaCompletePartialOrder.Ï‰ScottContinuous fun x => f x a)","decl":"lemma Ï‰ScottContinuous_iff_applyâ‚‚ : Ï‰ScottContinuous f â†” âˆ€ a, Ï‰ScottContinuous (f Â· a) :=\n  âŸ¨Ï‰ScottContinuous.applyâ‚‚, Ï‰ScottContinuous.of_applyâ‚‚âŸ©\n\n"}
{"name":"Prod.Ï‰Sup_fst","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nc : OmegaCompletePartialOrder.Chain (Prod Î± Î²)\nâŠ¢ Eq (Prod.Ï‰Sup c).1 (OmegaCompletePartialOrder.Ï‰Sup (c.map OrderHom.fst))","decl":"/-- The supremum of a chain in the product `Ï‰`-CPO. -/\n@[simps]\nprotected def Ï‰Sup (c : Chain (Î± Ã— Î²)) : Î± Ã— Î² :=\n  (Ï‰Sup (c.map OrderHom.fst), Ï‰Sup (c.map OrderHom.snd))\n\n"}
{"name":"Prod.Ï‰Sup_snd","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nc : OmegaCompletePartialOrder.Chain (Prod Î± Î²)\nâŠ¢ Eq (Prod.Ï‰Sup c).2 (OmegaCompletePartialOrder.Ï‰Sup (c.map OrderHom.snd))","decl":"/-- The supremum of a chain in the product `Ï‰`-CPO. -/\n@[simps]\nprotected def Ï‰Sup (c : Chain (Î± Ã— Î²)) : Î± Ã— Î² :=\n  (Ï‰Sup (c.map OrderHom.fst), Ï‰Sup (c.map OrderHom.snd))\n\n"}
{"name":"Prod.instOmegaCompletePartialOrder_Ï‰Sup_snd","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nc : OmegaCompletePartialOrder.Chain (Prod Î± Î²)\nâŠ¢ Eq (OmegaCompletePartialOrder.Ï‰Sup c).2 (OmegaCompletePartialOrder.Ï‰Sup (c.map OrderHom.snd))","decl":"@[simps! Ï‰Sup_fst Ï‰Sup_snd]\ninstance : OmegaCompletePartialOrder (Î± Ã— Î²) where\n  Ï‰Sup := Prod.Ï‰Sup\n  Ï‰Sup_le := fun _ _ h => âŸ¨Ï‰Sup_le _ _ fun i => (h i).1, Ï‰Sup_le _ _ fun i => (h i).2âŸ©\n  le_Ï‰Sup c i := âŸ¨le_Ï‰Sup (c.map OrderHom.fst) i, le_Ï‰Sup (c.map OrderHom.snd) iâŸ©\n\n"}
{"name":"Prod.instOmegaCompletePartialOrder_Ï‰Sup_fst","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nc : OmegaCompletePartialOrder.Chain (Prod Î± Î²)\nâŠ¢ Eq (OmegaCompletePartialOrder.Ï‰Sup c).1 (OmegaCompletePartialOrder.Ï‰Sup (c.map OrderHom.fst))","decl":"@[simps! Ï‰Sup_fst Ï‰Sup_snd]\ninstance : OmegaCompletePartialOrder (Î± Ã— Î²) where\n  Ï‰Sup := Prod.Ï‰Sup\n  Ï‰Sup_le := fun _ _ h => âŸ¨Ï‰Sup_le _ _ fun i => (h i).1, Ï‰Sup_le _ _ fun i => (h i).2âŸ©\n  le_Ï‰Sup c i := âŸ¨le_Ï‰Sup (c.map OrderHom.fst) i, le_Ï‰Sup (c.map OrderHom.snd) iâŸ©\n\n"}
{"name":"Prod.Ï‰Sup_zip","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\ncâ‚€ : OmegaCompletePartialOrder.Chain Î±\ncâ‚ : OmegaCompletePartialOrder.Chain Î²\nâŠ¢ Eq (OmegaCompletePartialOrder.Ï‰Sup (câ‚€.zip câ‚)) { fst := OmegaCompletePartialOrder.Ï‰Sup câ‚€, snd := OmegaCompletePartialOrder.Ï‰Sup câ‚ }","decl":"theorem Ï‰Sup_zip (câ‚€ : Chain Î±) (câ‚ : Chain Î²) : Ï‰Sup (câ‚€.zip câ‚) = (Ï‰Sup câ‚€, Ï‰Sup câ‚) := by\n  apply eq_of_forall_ge_iff; rintro âŸ¨zâ‚, zâ‚‚âŸ©\n  simp [Ï‰Sup_le_iff, forall_and]\n\n"}
{"name":"CompleteLattice.Ï‰ScottContinuous.prodMk","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : CompleteLattice Î²\nf g : Î± â†’ Î²\nhf : OmegaCompletePartialOrder.Ï‰ScottContinuous f\nhg : OmegaCompletePartialOrder.Ï‰ScottContinuous g\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous fun x => { fst := f x, snd := g x }","decl":"open Chain in\nlemma Ï‰ScottContinuous.prodMk (hf : Ï‰ScottContinuous f) (hg : Ï‰ScottContinuous g) :\n    Ï‰ScottContinuous fun x => (f x, g x) := ScottContinuousOn.prodMk (fun a b hab => by\n  use pair a b hab; exact range_pair a b hab) hf hg\n\n"}
{"name":"CompleteLattice.Ï‰ScottContinuous.iSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : CompleteLattice Î²\nf : Î¹ â†’ Î± â†’ Î²\nhf : âˆ€ (i : Î¹), OmegaCompletePartialOrder.Ï‰ScottContinuous (f i)\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous (iSup fun i => f i)","decl":"lemma Ï‰ScottContinuous.iSup {f : Î¹ â†’ Î± â†’ Î²} (hf : âˆ€ i, Ï‰ScottContinuous (f i)) :\n    Ï‰ScottContinuous (â¨† i, f i) := by\n  refine Ï‰ScottContinuous.of_monotone_map_Ï‰Sup\n    âŸ¨Monotone.iSup fun i â†¦ (hf i).monotone, fun c â†¦ eq_of_forall_ge_iff fun a â†¦ ?_âŸ©\n  simp +contextual [Ï‰Sup_le_iff, (hf _).map_Ï‰Sup, @forall_swap Î¹]\n\n"}
{"name":"CompleteLattice.Ï‰ScottContinuous.sSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : CompleteLattice Î²\ns : Set (Î± â†’ Î²)\nhs : âˆ€ (f : Î± â†’ Î²), Membership.mem s f â†’ OmegaCompletePartialOrder.Ï‰ScottContinuous f\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous (SupSet.sSup s)","decl":"lemma Ï‰ScottContinuous.sSup {s : Set (Î± â†’ Î²)} (hs : âˆ€ f âˆˆ s, Ï‰ScottContinuous f) :\n    Ï‰ScottContinuous (sSup s) := by\n  rw [sSup_eq_iSup]; exact Ï‰ScottContinuous.iSup fun f â†¦ Ï‰ScottContinuous.iSup <| hs f\n\n"}
{"name":"CompleteLattice.Ï‰ScottContinuous.sup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : CompleteLattice Î²\nf g : Î± â†’ Î²\nhf : OmegaCompletePartialOrder.Ï‰ScottContinuous f\nhg : OmegaCompletePartialOrder.Ï‰ScottContinuous g\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous (Max.max f g)","decl":"lemma Ï‰ScottContinuous.sup (hf : Ï‰ScottContinuous f) (hg : Ï‰ScottContinuous g) :\n    Ï‰ScottContinuous (f âŠ” g) := by\n  rw [â† sSup_pair]\n  apply Ï‰ScottContinuous.sSup\n  rintro f (rfl | rfl | _) <;> assumption\n\n"}
{"name":"CompleteLattice.Ï‰ScottContinuous.top","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : CompleteLattice Î²\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous Top.top","decl":"lemma Ï‰ScottContinuous.top : Ï‰ScottContinuous (âŠ¤ : Î± â†’ Î²) :=\n  Ï‰ScottContinuous.of_monotone_map_Ï‰Sup\n    âŸ¨monotone_const, fun c â†¦ eq_of_forall_ge_iff fun a â†¦ by simpâŸ©\n\n"}
{"name":"CompleteLattice.Ï‰ScottContinuous.bot","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : CompleteLattice Î²\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous Bot.bot","decl":"lemma Ï‰ScottContinuous.bot : Ï‰ScottContinuous (âŠ¥ : Î± â†’ Î²) := by\n  rw [â† sSup_empty]; exact Ï‰ScottContinuous.sSup (by simp)\n\n"}
{"name":"CompleteLattice.Ï‰ScottContinuous.inf","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : CompleteLinearOrder Î²\nf g : Î± â†’ Î²\nhf : OmegaCompletePartialOrder.Ï‰ScottContinuous f\nhg : OmegaCompletePartialOrder.Ï‰ScottContinuous g\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous (Min.min f g)","decl":"lemma Ï‰ScottContinuous.inf (hf : Ï‰ScottContinuous f) (hg : Ï‰ScottContinuous g) :\n    Ï‰ScottContinuous (f âŠ“ g) := by\n  refine Ï‰ScottContinuous.of_monotone_map_Ï‰Sup\n    âŸ¨hf.monotone.inf hg.monotone, fun c â†¦ eq_of_forall_ge_iff fun a â†¦ ?_âŸ©\n  simp only [Pi.inf_apply, hf.map_Ï‰Sup c, hg.map_Ï‰Sup c, inf_le_iff, Ï‰Sup_le_iff, Chain.map_coe,\n    Function.comp, OrderHom.coe_mk, â† forall_or_left, â† forall_or_right]\n  exact âŸ¨fun h _ â†¦ h _ _, fun h i j â†¦\n    (h (max j i)).imp (le_trans <| hf.monotone <| c.mono <| le_max_left _ _)\n      (le_trans <| hg.monotone <| c.mono <| le_max_right _ _)âŸ©\n\n"}
{"name":"OmegaCompletePartialOrder.OrderHom.Ï‰Sup_coe","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nc : OmegaCompletePartialOrder.Chain (OrderHom Î± Î²)\na : Î±\nâŠ¢ Eq ((OmegaCompletePartialOrder.OrderHom.Ï‰Sup c) a) (OmegaCompletePartialOrder.Ï‰Sup (c.map (OrderHom.apply a)))","decl":"/-- The `Ï‰Sup` operator for monotone functions. -/\n@[simps]\nprotected def Ï‰Sup (c : Chain (Î± â†’o Î²)) : Î± â†’o Î² where\n  toFun a := Ï‰Sup (c.map (OrderHom.apply a))\n  monotone' _ _ h := Ï‰Sup_le_Ï‰Sup_of_le ((Chain.map_le_map _) fun a => a.monotone h)\n\n"}
{"name":"OmegaCompletePartialOrder.OrderHom.omegaCompletePartialOrder_Ï‰Sup_coe","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nc : OmegaCompletePartialOrder.Chain (OrderHom Î± Î²)\na : Î±\nâŠ¢ Eq ((OmegaCompletePartialOrder.Ï‰Sup c) a) (OmegaCompletePartialOrder.Ï‰Sup (c.map (OrderHom.apply a)))","decl":"@[simps! Ï‰Sup_coe]\ninstance omegaCompletePartialOrder : OmegaCompletePartialOrder (Î± â†’o Î²) :=\n  OmegaCompletePartialOrder.lift OrderHom.coeFnHom OrderHom.Ï‰Sup (fun _ _ h => h) fun _ => rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.mk.injEq","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\ntoOrderHomâœ : OrderHom Î± Î²\nmap_Ï‰Sup'âœ : âˆ€ (c : OmegaCompletePartialOrder.Chain Î±), Eq (toOrderHomâœ.toFun (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map toOrderHomâœ))\ntoOrderHom : OrderHom Î± Î²\nmap_Ï‰Sup' : âˆ€ (c : OmegaCompletePartialOrder.Chain Î±), Eq (toOrderHom.toFun (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map toOrderHom))\nâŠ¢ Eq (Eq { toOrderHom := toOrderHomâœ, map_Ï‰Sup' := map_Ï‰Sup'âœ } { toOrderHom := toOrderHom, map_Ï‰Sup' := map_Ï‰Sup' }) (Eq toOrderHomâœ toOrderHom)","decl":"variable (Î± Î²) in\n/-- A monotone function on `Ï‰`-continuous partial orders is said to be continuous\nif for every chain `c : chain Î±`, `f (âŠ” i, c i) = âŠ” i, f (c i)`.\nThis is just the bundled version of `OrderHom.continuous`. -/\nstructure ContinuousHom extends OrderHom Î± Î² where\n  /-- The underlying function of a `ContinuousHom` is continuous, i.e. it preserves `Ï‰Sup` -/\n  protected map_Ï‰Sup' (c : Chain Î±) : toFun (Ï‰Sup c) = Ï‰Sup (c.map toOrderHom)\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.mk.sizeOf_spec","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : OmegaCompletePartialOrder Î±\ninstâœÂ² : OmegaCompletePartialOrder Î²\ninstâœÂ¹ : SizeOf Î±\ninstâœ : SizeOf Î²\ntoOrderHom : OrderHom Î± Î²\nmap_Ï‰Sup' : âˆ€ (c : OmegaCompletePartialOrder.Chain Î±), Eq (toOrderHom.toFun (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map toOrderHom))\nâŠ¢ Eq (SizeOf.sizeOf { toOrderHom := toOrderHom, map_Ï‰Sup' := map_Ï‰Sup' }) (HAdd.hAdd 1 (SizeOf.sizeOf toOrderHom))","decl":"variable (Î± Î²) in\n/-- A monotone function on `Ï‰`-continuous partial orders is said to be continuous\nif for every chain `c : chain Î±`, `f (âŠ” i, c i) = âŠ” i, f (c i)`.\nThis is just the bundled version of `OrderHom.continuous`. -/\nstructure ContinuousHom extends OrderHom Î± Î² where\n  /-- The underlying function of a `ContinuousHom` is continuous, i.e. it preserves `Ï‰Sup` -/\n  protected map_Ï‰Sup' (c : Chain Î±) : toFun (Ï‰Sup c) = Ï‰Sup (c.map toOrderHom)\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.mk.inj","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\ntoOrderHomâœ : OrderHom Î± Î²\nmap_Ï‰Sup'âœ : âˆ€ (c : OmegaCompletePartialOrder.Chain Î±), Eq (toOrderHomâœ.toFun (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map toOrderHomâœ))\ntoOrderHom : OrderHom Î± Î²\nmap_Ï‰Sup' : âˆ€ (c : OmegaCompletePartialOrder.Chain Î±), Eq (toOrderHom.toFun (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map toOrderHom))\nxâœ : Eq { toOrderHom := toOrderHomâœ, map_Ï‰Sup' := map_Ï‰Sup'âœ } { toOrderHom := toOrderHom, map_Ï‰Sup' := map_Ï‰Sup' }\nâŠ¢ Eq toOrderHomâœ toOrderHom","decl":"variable (Î± Î²) in\n/-- A monotone function on `Ï‰`-continuous partial orders is said to be continuous\nif for every chain `c : chain Î±`, `f (âŠ” i, c i) = âŠ” i, f (c i)`.\nThis is just the bundled version of `OrderHom.continuous`. -/\nstructure ContinuousHom extends OrderHom Î± Î² where\n  /-- The underlying function of a `ContinuousHom` is continuous, i.e. it preserves `Ï‰Sup` -/\n  protected map_Ï‰Sup' (c : Chain Î±) : toFun (Ï‰Sup c) = Ï‰Sup (c.map toOrderHom)\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.map_Ï‰Sup'","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nself : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nc : OmegaCompletePartialOrder.Chain Î±\nâŠ¢ Eq (self.toFun (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map self.toOrderHom))","decl":"variable (Î± Î²) in\n/-- A monotone function on `Ï‰`-continuous partial orders is said to be continuous\nif for every chain `c : chain Î±`, `f (âŠ” i, c i) = âŠ” i, f (c i)`.\nThis is just the bundled version of `OrderHom.continuous`. -/\nstructure ContinuousHom extends OrderHom Î± Î² where\n  /-- The underlying function of a `ContinuousHom` is continuous, i.e. it preserves `Ï‰Sup` -/\n  protected map_Ï‰Sup' (c : Chain Î±) : toFun (Ï‰Sup c) = Ï‰Sup (c.map toOrderHom)\n\n"}
{"name":"OmegaCompletePartialOrder.instOrderHomClassContinuousHom","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nâŠ¢ OrderHomClass (OmegaCompletePartialOrder.ContinuousHom Î± Î²) Î± Î²","decl":"instance : OrderHomClass (Î± â†’ğ’„ Î²) Î± Î² where\n  map_rel f _ _ h := f.mono h\n\n-- Porting note: removed to avoid conflict with the generic instance\n-- instance : Coe (Î± â†’ğ’„ Î²) (Î± â†’o Î²) where coe := ContinuousHom.toOrderHom\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.Ï‰ScottContinuous","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous â‡‘f","decl":"protected lemma Ï‰ScottContinuous (f : Î± â†’ğ’„ Î²) : Ï‰ScottContinuous f :=\n  Ï‰ScottContinuous.of_map_Ï‰Sup_of_orderHom f.map_Ï‰Sup'\n\n-- Not a `simp` lemma because in many cases projection is simpler than a generic coercion\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.toOrderHom_eq_coe","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nâŠ¢ Eq f.toOrderHom â†‘f","decl":"theorem toOrderHom_eq_coe (f : Î± â†’ğ’„ Î²) : f.1 = f := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.coe_mk","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : OrderHom Î± Î²\nhf : âˆ€ (c : OmegaCompletePartialOrder.Chain Î±), Eq (f.toFun (OmegaCompletePartialOrder.Ï‰Sup c)) (OmegaCompletePartialOrder.Ï‰Sup (c.map f))\nâŠ¢ Eq â‡‘{ toOrderHom := f, map_Ï‰Sup' := hf } â‡‘f","decl":"@[simp] theorem coe_mk (f : Î± â†’o Î²) (hf) : â‡‘(mk f hf) = f := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.coe_toOrderHom","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nâŠ¢ Eq â‡‘f.toOrderHom â‡‘f","decl":"@[simp] theorem coe_toOrderHom (f : Î± â†’ğ’„ Î²) : â‡‘f.1 = f := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.congr_fun","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf g : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nh : Eq f g\nx : Î±\nâŠ¢ Eq (f x) (g x)","decl":"protected theorem congr_fun {f g : Î± â†’ğ’„ Î²} (h : f = g) (x : Î±) : f x = g x :=\n  DFunLike.congr_fun h x\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.congr_arg","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nx y : Î±\nh : Eq x y\nâŠ¢ Eq (f x) (f y)","decl":"protected theorem congr_arg (f : Î± â†’ğ’„ Î²) {x y : Î±} (h : x = y) : f x = f y :=\n  congr_arg f h\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.monotone","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nâŠ¢ Monotone â‡‘f","decl":"protected theorem monotone (f : Î± â†’ğ’„ Î²) : Monotone f :=\n  f.monotone'\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.apply_mono","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf g : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nx y : Î±\nhâ‚ : LE.le f g\nhâ‚‚ : LE.le x y\nâŠ¢ LE.le (f x) (g y)","decl":"@[mono]\ntheorem apply_mono {f g : Î± â†’ğ’„ Î²} {x y : Î±} (hâ‚ : f â‰¤ g) (hâ‚‚ : x â‰¤ y) : f x â‰¤ g y :=\n  OrderHom.apply_mono (show (f : Î± â†’o Î²) â‰¤ g from hâ‚) hâ‚‚\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.Ï‰Sup_bind","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nÎ² Î³ : Type v\nc : OmegaCompletePartialOrder.Chain Î±\nf : OrderHom Î± (Part Î²)\ng : OrderHom Î± (Î² â†’ Part Î³)\nâŠ¢ Eq (OmegaCompletePartialOrder.Ï‰Sup (c.map (f.partBind g))) (Bind.bind (OmegaCompletePartialOrder.Ï‰Sup (c.map f)) (OmegaCompletePartialOrder.Ï‰Sup (c.map g)))","decl":"theorem Ï‰Sup_bind {Î² Î³ : Type v} (c : Chain Î±) (f : Î± â†’o Part Î²) (g : Î± â†’o Î² â†’ Part Î³) :\n    Ï‰Sup (c.map (f.partBind g)) = Ï‰Sup (c.map f) >>= Ï‰Sup (c.map g) := by\n  apply eq_of_forall_ge_iff; intro x\n  simp only [Ï‰Sup_le_iff, Part.bind_le, Chain.mem_map_iff, and_imp, OrderHom.partBind_coe,\n    exists_imp]\n  constructor <;> intro h'''\n  Â· intro b hb\n    apply Ï‰Sup_le _ _ _\n    rintro i y hy\n    simp only [Part.mem_Ï‰Sup] at hb\n    rcases hb with âŸ¨j, hbâŸ©\n    replace hb := hb.symm\n    simp only [Part.eq_some_iff, Chain.map_coe, Function.comp_apply, OrderHom.apply_coe] at hy hb\n    replace hb : b âˆˆ f (c (max i j)) := f.mono (c.mono (le_max_right i j)) _ hb\n    replace hy : y âˆˆ g (c (max i j)) b := g.mono (c.mono (le_max_left i j)) _ _ hy\n    apply h''' (max i j)\n    simp only [exists_prop, Part.bind_eq_bind, Part.mem_bind_iff, Chain.map_coe,\n      Function.comp_apply, OrderHom.partBind_coe]\n    exact âŸ¨_, hb, hyâŸ©\n  Â· intro i\n    intro y hy\n    simp only [exists_prop, Part.bind_eq_bind, Part.mem_bind_iff, Chain.map_coe,\n      Function.comp_apply, OrderHom.partBind_coe] at hy\n    rcases hy with âŸ¨b, hbâ‚€, hbâ‚âŸ©\n    apply h''' b _\n    Â· apply le_Ï‰Sup (c.map g) _ _ _ hbâ‚\n    Â· apply le_Ï‰Sup (c.map f) i _ hbâ‚€\n\n-- TODO: We should move `Ï‰ScottContinuous` to the root namespace\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.Ï‰ScottContinuous.bind","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nÎ² Î³ : Type u_6\nf : Î± â†’ Part Î²\ng : Î± â†’ Î² â†’ Part Î³\nhf : OmegaCompletePartialOrder.Ï‰ScottContinuous f\nhg : OmegaCompletePartialOrder.Ï‰ScottContinuous g\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous fun x => Bind.bind (f x) (g x)","decl":"lemma Ï‰ScottContinuous.bind {Î² Î³} {f : Î± â†’ Part Î²} {g : Î± â†’ Î² â†’ Part Î³} (hf : Ï‰ScottContinuous f)\n    (hg : Ï‰ScottContinuous g) : Ï‰ScottContinuous fun x â†¦ f x >>= g x :=\n  Ï‰ScottContinuous.of_monotone_map_Ï‰Sup\n    âŸ¨hf.monotone.partBind hg.monotone, fun c â†¦ by rw [hf.map_Ï‰Sup, hg.map_Ï‰Sup, â† Ï‰Sup_bind]; rflâŸ©\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.Ï‰ScottContinuous.map","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nÎ² Î³ : Type u_6\nf : Î² â†’ Î³\ng : Î± â†’ Part Î²\nhg : OmegaCompletePartialOrder.Ï‰ScottContinuous g\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous fun x => Functor.map f (g x)","decl":"lemma Ï‰ScottContinuous.map {Î² Î³} {f : Î² â†’ Î³} {g : Î± â†’ Part Î²} (hg : Ï‰ScottContinuous g) :\n    Ï‰ScottContinuous fun x â†¦ f <$> g x := by\n  simpa only [map_eq_bind_pure_comp] using Ï‰ScottContinuous.bind hg Ï‰ScottContinuous.const\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.Ï‰ScottContinuous.seq","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nÎ² Î³ : Type u_6\nf : Î± â†’ Part (Î² â†’ Î³)\ng : Î± â†’ Part Î²\nhf : OmegaCompletePartialOrder.Ï‰ScottContinuous f\nhg : OmegaCompletePartialOrder.Ï‰ScottContinuous g\nâŠ¢ OmegaCompletePartialOrder.Ï‰ScottContinuous fun x => Seq.seq (f x) fun x_1 => g x","decl":"lemma Ï‰ScottContinuous.seq {Î² Î³} {f : Î± â†’ Part (Î² â†’ Î³)} {g : Î± â†’ Part Î²} (hf : Ï‰ScottContinuous f)\n    (hg : Ï‰ScottContinuous g) : Ï‰ScottContinuous fun x â†¦ f x <*> g x := by\n  simp only [seq_eq_bind_map]\n  exact Ï‰ScottContinuous.bind hf <| Ï‰ScottContinuous.of_applyâ‚‚ fun _ â†¦ Ï‰ScottContinuous.map hg\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.continuous","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nF : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nC : OmegaCompletePartialOrder.Chain Î±\nâŠ¢ Eq (F (OmegaCompletePartialOrder.Ï‰Sup C)) (OmegaCompletePartialOrder.Ï‰Sup (C.map â†‘F))","decl":"theorem continuous (F : Î± â†’ğ’„ Î²) (C : Chain Î±) : F (Ï‰Sup C) = Ï‰Sup (C.map F) :=\n  F.Ï‰ScottContinuous.map_Ï‰Sup _\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.copy_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : Î± â†’ Î²\ng : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nh : Eq f â‡‘g\naâœ : Î±\nâŠ¢ Eq ((OmegaCompletePartialOrder.ContinuousHom.copy f g h) aâœ) (f aâœ)","decl":"/-- Construct a continuous function from a bare function, a continuous function, and a proof that\nthey are equal. -/\n-- Porting note: removed `@[reducible]`\n@[simps!]\ndef copy (f : Î± â†’ Î²) (g : Î± â†’ğ’„ Î²) (h : f = g) : Î± â†’ğ’„ Î² where\n  toOrderHom := g.1.copy f h\n  map_Ï‰Sup' := by rw [OrderHom.copy_eq]; exact g.map_Ï‰Sup'\n\n-- Porting note: `of_mono` now defeq `mk`\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.id_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\na : Î±\nâŠ¢ Eq (OmegaCompletePartialOrder.ContinuousHom.id a) a","decl":"/-- The identity as a continuous function. -/\n@[simps!]\ndef id : Î± â†’ğ’„ Î± := âŸ¨OrderHom.id, Ï‰ScottContinuous.id.map_Ï‰SupâŸ©\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.comp_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœÂ² : OmegaCompletePartialOrder Î±\ninstâœÂ¹ : OmegaCompletePartialOrder Î²\ninstâœ : OmegaCompletePartialOrder Î³\nf : OmegaCompletePartialOrder.ContinuousHom Î² Î³\ng : OmegaCompletePartialOrder.ContinuousHom Î± Î²\naâœ : Î±\nâŠ¢ Eq ((f.comp g) aâœ) (f (g aâœ))","decl":"/-- The composition of continuous functions. -/\n@[simps!]\ndef comp (f : Î² â†’ğ’„ Î³) (g : Î± â†’ğ’„ Î²) : Î± â†’ğ’„ Î³ :=\n  âŸ¨.comp f.1 g.1, (f.Ï‰ScottContinuous.comp g.Ï‰ScottContinuous).map_Ï‰SupâŸ©\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.ext","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf g : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nh : âˆ€ (x : Î±), Eq (f x) (g x)\nâŠ¢ Eq f g","decl":"@[ext]\nprotected theorem ext (f g : Î± â†’ğ’„ Î²) (h : âˆ€ x, f x = g x) : f = g := DFunLike.ext f g h\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.ext_iff","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf g : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nâŠ¢ Iff (Eq f g) (âˆ€ (x : Î±), Eq (f x) (g x))","decl":"@[ext]\nprotected theorem ext (f g : Î± â†’ğ’„ Î²) (h : âˆ€ x, f x = g x) : f = g := DFunLike.ext f g h\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.coe_inj","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf g : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nh : Eq â‡‘f â‡‘g\nâŠ¢ Eq f g","decl":"protected theorem coe_inj (f g : Î± â†’ğ’„ Î²) (h : (f : Î± â†’ Î²) = g) : f = g :=\n  DFunLike.ext' h\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.comp_id","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î² : Type u_3\nÎ³ : Type u_4\ninstâœÂ¹ : OmegaCompletePartialOrder Î²\ninstâœ : OmegaCompletePartialOrder Î³\nf : OmegaCompletePartialOrder.ContinuousHom Î² Î³\nâŠ¢ Eq (f.comp OmegaCompletePartialOrder.ContinuousHom.id) f","decl":"@[simp]\ntheorem comp_id (f : Î² â†’ğ’„ Î³) : f.comp id = f := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.id_comp","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î² : Type u_3\nÎ³ : Type u_4\ninstâœÂ¹ : OmegaCompletePartialOrder Î²\ninstâœ : OmegaCompletePartialOrder Î³\nf : OmegaCompletePartialOrder.ContinuousHom Î² Î³\nâŠ¢ Eq (OmegaCompletePartialOrder.ContinuousHom.id.comp f) f","decl":"@[simp]\ntheorem id_comp (f : Î² â†’ğ’„ Î³) : id.comp f = f := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.comp_assoc","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\nÎ´ : Type u_5\ninstâœÂ³ : OmegaCompletePartialOrder Î±\ninstâœÂ² : OmegaCompletePartialOrder Î²\ninstâœÂ¹ : OmegaCompletePartialOrder Î³\ninstâœ : OmegaCompletePartialOrder Î´\nf : OmegaCompletePartialOrder.ContinuousHom Î³ Î´\ng : OmegaCompletePartialOrder.ContinuousHom Î² Î³\nh : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nâŠ¢ Eq (f.comp (g.comp h)) ((f.comp g).comp h)","decl":"@[simp]\ntheorem comp_assoc (f : Î³ â†’ğ’„ Î´) (g : Î² â†’ğ’„ Î³) (h : Î± â†’ğ’„ Î²) : f.comp (g.comp h) = (f.comp g).comp h :=\n  rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.coe_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\na : Î±\nf : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nâŠ¢ Eq (â†‘f a) (f a)","decl":"@[simp]\ntheorem coe_apply (a : Î±) (f : Î± â†’ğ’„ Î²) : (f : Î± â†’o Î²) a = f a :=\n  rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.const_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nx : Î²\naâœ : Î±\nâŠ¢ Eq ((OmegaCompletePartialOrder.ContinuousHom.const x) aâœ) x","decl":"/-- `Function.const` is a continuous function. -/\n@[simps!]\ndef const (x : Î²) : Î± â†’ğ’„ Î² := âŸ¨.const _ x, Ï‰ScottContinuous.const.map_Ï‰SupâŸ©\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.toMono_coe","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : OmegaCompletePartialOrder.ContinuousHom Î± Î²\nâŠ¢ Eq (OmegaCompletePartialOrder.ContinuousHom.toMono f) â†‘f","decl":"/-- The map from continuous functions to monotone functions is itself a monotone function. -/\n@[simps]\ndef toMono : (Î± â†’ğ’„ Î²) â†’o Î± â†’o Î² where\n  toFun f := f\n  monotone' _ _ h := h\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.forall_forall_merge","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\ncâ‚€ : OmegaCompletePartialOrder.Chain (OmegaCompletePartialOrder.ContinuousHom Î± Î²)\ncâ‚ : OmegaCompletePartialOrder.Chain Î±\nz : Î²\nâŠ¢ Iff (âˆ€ (i j : Nat), LE.le ((câ‚€ i) (câ‚ j)) z) (âˆ€ (i : Nat), LE.le ((câ‚€ i) (câ‚ i)) z)","decl":"/-- When proving that a chain of applications is below a bound `z`, it suffices to consider the\nfunctions and values being selected from the same index in the chains.\n\nThis lemma is more specific than necessary, i.e. `câ‚€` only needs to be a\nchain of monotone functions, but it is only used with continuous functions. -/\n@[simp]\ntheorem forall_forall_merge (câ‚€ : Chain (Î± â†’ğ’„ Î²)) (câ‚ : Chain Î±) (z : Î²) :\n    (âˆ€ i j : â„•, (câ‚€ i) (câ‚ j) â‰¤ z) â†” âˆ€ i : â„•, (câ‚€ i) (câ‚ i) â‰¤ z := by\n  constructor <;> introv h\n  Â· apply h\n  Â· apply le_trans _ (h (max i j))\n    trans câ‚€ i (câ‚ (max i j))\n    Â· apply (câ‚€ i).monotone\n      apply câ‚.monotone\n      apply le_max_right\n    Â· apply câ‚€.monotone\n      apply le_max_left\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.forall_forall_merge'","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\ncâ‚€ : OmegaCompletePartialOrder.Chain (OmegaCompletePartialOrder.ContinuousHom Î± Î²)\ncâ‚ : OmegaCompletePartialOrder.Chain Î±\nz : Î²\nâŠ¢ Iff (âˆ€ (j i : Nat), LE.le ((câ‚€ i) (câ‚ j)) z) (âˆ€ (i : Nat), LE.le ((câ‚€ i) (câ‚ i)) z)","decl":"@[simp]\ntheorem forall_forall_merge' (câ‚€ : Chain (Î± â†’ğ’„ Î²)) (câ‚ : Chain Î±) (z : Î²) :\n    (âˆ€ j i : â„•, (câ‚€ i) (câ‚ j) â‰¤ z) â†” âˆ€ i : â„•, (câ‚€ i) (câ‚ i) â‰¤ z := by\n  rw [forall_swap, forall_forall_merge]\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.Ï‰Sup_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nc : OmegaCompletePartialOrder.Chain (OmegaCompletePartialOrder.ContinuousHom Î± Î²)\na : Î±\nâŠ¢ Eq ((OmegaCompletePartialOrder.ContinuousHom.Ï‰Sup c) a) (OmegaCompletePartialOrder.Ï‰Sup ((c.map OmegaCompletePartialOrder.ContinuousHom.toMono).map (OrderHom.apply a)))","decl":"/-- The `Ï‰Sup` operator for continuous functions, which takes the pointwise countable supremum\nof the functions in the `Ï‰`-chain. -/\n@[simps!]\nprotected def Ï‰Sup (c : Chain (Î± â†’ğ’„ Î²)) : Î± â†’ğ’„ Î² where\n  toOrderHom := Ï‰Sup <| c.map toMono\n  map_Ï‰Sup' c' := eq_of_forall_ge_iff fun a â†¦ by simp [(c _).Ï‰ScottContinuous.map_Ï‰Sup]\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.inst_Ï‰Sup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nc : OmegaCompletePartialOrder.Chain (OmegaCompletePartialOrder.ContinuousHom Î± Î²)\nâŠ¢ Eq (OmegaCompletePartialOrder.Ï‰Sup c) (OmegaCompletePartialOrder.ContinuousHom.Ï‰Sup c)","decl":"@[simps Ï‰Sup]\ninstance : OmegaCompletePartialOrder (Î± â†’ğ’„ Î²) :=\n  OmegaCompletePartialOrder.lift ContinuousHom.toMono ContinuousHom.Ï‰Sup\n    (fun _ _ h => h) (fun _ => rfl)\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.Prod.apply_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nf : Prod (OmegaCompletePartialOrder.ContinuousHom Î± Î²) Î±\nâŠ¢ Eq (OmegaCompletePartialOrder.ContinuousHom.Prod.apply f) (f.1 f.2)","decl":"/-- The application of continuous functions as a continuous function. -/\n@[simps]\ndef apply : (Î± â†’ğ’„ Î²) Ã— Î± â†’ğ’„ Î² where\n  toFun f := f.1 f.2\n  monotone' x y h := by\n    dsimp\n    trans y.fst x.snd <;> [apply h.1; apply y.1.monotone h.2]\n  map_Ï‰Sup' c := by\n    apply le_antisymm\n    Â· apply Ï‰Sup_le\n      intro i\n      dsimp\n      rw [(c _).fst.continuous]\n      apply Ï‰Sup_le\n      intro j\n      apply le_Ï‰Sup_of_le (max i j)\n      apply apply_mono\n      Â· exact monotone_fst (OrderHom.mono _ (le_max_left _ _))\n      Â· exact monotone_snd (OrderHom.mono _ (le_max_right _ _))\n    Â· apply Ï‰Sup_le\n      intro i\n      apply le_Ï‰Sup_of_le i\n      dsimp\n      apply OrderHom.mono _\n      apply le_Ï‰Sup_of_le i\n      rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.Ï‰Sup_def","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\nc : OmegaCompletePartialOrder.Chain (OmegaCompletePartialOrder.ContinuousHom Î± Î²)\nx : Î±\nâŠ¢ Eq ((OmegaCompletePartialOrder.Ï‰Sup c) x) ((OmegaCompletePartialOrder.ContinuousHom.Ï‰Sup c) x)","decl":"theorem Ï‰Sup_def (c : Chain (Î± â†’ğ’„ Î²)) (x : Î±) : Ï‰Sup c x = ContinuousHom.Ï‰Sup c x :=\n  rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.Ï‰Sup_apply_Ï‰Sup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : OmegaCompletePartialOrder Î±\ninstâœ : OmegaCompletePartialOrder Î²\ncâ‚€ : OmegaCompletePartialOrder.Chain (OmegaCompletePartialOrder.ContinuousHom Î± Î²)\ncâ‚ : OmegaCompletePartialOrder.Chain Î±\nâŠ¢ Eq ((OmegaCompletePartialOrder.Ï‰Sup câ‚€) (OmegaCompletePartialOrder.Ï‰Sup câ‚)) (OmegaCompletePartialOrder.ContinuousHom.Prod.apply (OmegaCompletePartialOrder.Ï‰Sup (câ‚€.zip câ‚)))","decl":"theorem Ï‰Sup_apply_Ï‰Sup (câ‚€ : Chain (Î± â†’ğ’„ Î²)) (câ‚ : Chain Î±) :\n    Ï‰Sup câ‚€ (Ï‰Sup câ‚) = Prod.apply (Ï‰Sup (câ‚€.zip câ‚)) := by simp [Prod.apply_apply, Prod.Ï‰Sup_zip]\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.flip_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î² : Type u_3\nÎ³ : Type u_4\ninstâœÂ¹ : OmegaCompletePartialOrder Î²\ninstâœ : OmegaCompletePartialOrder Î³\nÎ± : Type u_6\nf : Î± â†’ OmegaCompletePartialOrder.ContinuousHom Î² Î³\nx : Î²\ny : Î±\nâŠ¢ Eq ((OmegaCompletePartialOrder.ContinuousHom.flip f) x y) ((f y) x)","decl":"/-- A family of continuous functions yields a continuous family of functions. -/\n@[simps]\ndef flip {Î± : Type*} (f : Î± â†’ Î² â†’ğ’„ Î³) : Î² â†’ğ’„ Î± â†’ Î³ where\n  toFun x y := f y x\n  monotone' _ _ h a := (f a).monotone h\n  map_Ï‰Sup' _ := by ext x; change f _ _ = _; rw [(f _).continuous]; rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.bind_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nÎ² Î³ : Type v\nf : OmegaCompletePartialOrder.ContinuousHom Î± (Part Î²)\ng : OmegaCompletePartialOrder.ContinuousHom Î± (Î² â†’ Part Î³)\nx : Î±\nâŠ¢ Eq ((f.bind g) x) ((f x).bind (g x))","decl":"/-- `Part.bind` as a continuous function. -/\n@[simps! apply] -- Porting note: removed `(config := { rhsMd := reducible })`\nnoncomputable def bind {Î² Î³ : Type v} (f : Î± â†’ğ’„ Part Î²) (g : Î± â†’ğ’„ Î² â†’ Part Î³) : Î± â†’ğ’„ Part Î³ :=\n  .mk (OrderHom.partBind f g.toOrderHom) fun c => by\n    rw [Ï‰Sup_bind, â† f.continuous, g.toOrderHom_eq_coe, â† g.continuous]\n    rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.map_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nÎ² Î³ : Type v\nf : Î² â†’ Î³\ng : OmegaCompletePartialOrder.ContinuousHom Î± (Part Î²)\nx : Î±\nâŠ¢ Eq ((OmegaCompletePartialOrder.ContinuousHom.map f g) x) (Part.map f (g x))","decl":"/-- `Part.map` as a continuous function. -/\n@[simps! apply] -- Porting note: removed `(config := { rhsMd := reducible })`\nnoncomputable def map {Î² Î³ : Type v} (f : Î² â†’ Î³) (g : Î± â†’ğ’„ Part Î²) : Î± â†’ğ’„ Part Î³ :=\n  .copy (fun x => f <$> g x) (bind g (const (pure âˆ˜ f))) <| by\n    ext1\n    simp only [map_eq_bind_pure_comp, bind, coe_mk, OrderHom.partBind_coe, coe_apply,\n      coe_toOrderHom, const_apply, Part.bind_eq_bind]\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.seq_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nÎ² Î³ : Type v\nf : OmegaCompletePartialOrder.ContinuousHom Î± (Part (Î² â†’ Î³))\ng : OmegaCompletePartialOrder.ContinuousHom Î± (Part Î²)\nx : Î±\nâŠ¢ Eq ((f.seq g) x) (Seq.seq (f x) fun x_1 => g x)","decl":"/-- `Part.seq` as a continuous function. -/\n@[simps! apply] -- Porting note: removed `(config := { rhsMd := reducible })`\nnoncomputable def seq {Î² Î³ : Type v} (f : Î± â†’ğ’„ Part (Î² â†’ Î³)) (g : Î± â†’ğ’„ Part Î²) : Î± â†’ğ’„ Part Î³ :=\n  .copy (fun x => f x <*> g x) (bind f <| flip <| _root_.flip map g) <| by\n      ext\n      simp only [seq_eq_bind_map, Part.bind_eq_bind, Part.mem_bind_iff, flip_apply, _root_.flip,\n        map_apply, bind_apply, Part.map_eq_map]\n\n"}
{"name":"OmegaCompletePartialOrder.fixedPoints.Ï‰Sup_iterate_mem_fixedPoint","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nf : OmegaCompletePartialOrder.ContinuousHom Î± Î±\nx : Î±\nh : LE.le x (f x)\nâŠ¢ Membership.mem (Function.fixedPoints â‡‘f) (OmegaCompletePartialOrder.Ï‰Sup (OmegaCompletePartialOrder.fixedPoints.iterateChain (â†‘f) x h))","decl":"/-- The supremum of iterating a function on x arbitrary often is a fixed point -/\ntheorem Ï‰Sup_iterate_mem_fixedPoint (h : x â‰¤ f x) :\n    Ï‰Sup (iterateChain f x h) âˆˆ fixedPoints f := by\n  rw [mem_fixedPoints, IsFixedPt, f.continuous]\n  apply le_antisymm\n  Â· apply Ï‰Sup_le\n    intro n\n    simp only [Chain.map_coe, OrderHomClass.coe_coe, comp_apply]\n    have : iterateChain f x h (n.succ) = f (iterateChain f x h n) :=\n      Function.iterate_succ_apply' ..\n    rw [â† this]\n    apply le_Ï‰Sup\n  Â· apply Ï‰Sup_le\n    rintro (_ | n)\n    Â· apply le_trans h\n      change ((iterateChain f x h).map f) 0 â‰¤ Ï‰Sup ((iterateChain f x h).map (f : Î± â†’o Î±))\n      apply le_Ï‰Sup\n    Â· have : iterateChain f x h (n.succ) = (iterateChain f x h).map f n :=\n        Function.iterate_succ_apply' ..\n      rw [this]\n      apply le_Ï‰Sup\n\n"}
{"name":"OmegaCompletePartialOrder.fixedPoints.Ï‰Sup_iterate_le_prefixedPoint","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nf : OmegaCompletePartialOrder.ContinuousHom Î± Î±\nx : Î±\nh : LE.le x (f x)\na : Î±\nh_a : LE.le (f a) a\nh_x_le_a : LE.le x a\nâŠ¢ LE.le (OmegaCompletePartialOrder.Ï‰Sup (OmegaCompletePartialOrder.fixedPoints.iterateChain (â†‘f) x h)) a","decl":"/-- The supremum of iterating a function on x arbitrary often is smaller than any prefixed point.\n\nA prefixed point is a value `a` with `f a â‰¤ a`. -/\ntheorem Ï‰Sup_iterate_le_prefixedPoint (h : x â‰¤ f x) {a : Î±}\n    (h_a : f a â‰¤ a) (h_x_le_a : x â‰¤ a) :\n    Ï‰Sup (iterateChain f x h) â‰¤ a := by\n  apply Ï‰Sup_le\n  intro n\n  induction n with\n  | zero => exact h_x_le_a\n  | succ n h_ind =>\n    have : iterateChain f x h (n.succ) = f (iterateChain f x h n) :=\n      Function.iterate_succ_apply' ..\n    rw [this]\n    exact le_trans (f.monotone h_ind) h_a\n\n"}
{"name":"OmegaCompletePartialOrder.fixedPoints.Ï‰Sup_iterate_le_fixedPoint","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"Î± : Type u_2\ninstâœ : OmegaCompletePartialOrder Î±\nf : OmegaCompletePartialOrder.ContinuousHom Î± Î±\nx : Î±\nh : LE.le x (f x)\na : Î±\nh_a : Membership.mem (Function.fixedPoints â‡‘f) a\nh_x_le_a : LE.le x a\nâŠ¢ LE.le (OmegaCompletePartialOrder.Ï‰Sup (OmegaCompletePartialOrder.fixedPoints.iterateChain (â†‘f) x h)) a","decl":"/-- The supremum of iterating a function on x arbitrary often is smaller than any fixed point. -/\ntheorem Ï‰Sup_iterate_le_fixedPoint (h : x â‰¤ f x) {a : Î±}\n    (h_a : a âˆˆ fixedPoints f) (h_x_le_a : x â‰¤ a) :\n    Ï‰Sup (iterateChain f x h) â‰¤ a := by\n  rw [mem_fixedPoints] at h_a\n  obtain h_a := Eq.le h_a\n  exact Ï‰Sup_iterate_le_prefixedPoint f x h h_a h_x_le_a\n\n"}
