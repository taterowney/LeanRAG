{"name":"OmegaCompletePartialOrder.Chain.instOrderHomClassNat","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : Preorder α\n⊢ OrderHomClass (OmegaCompletePartialOrder.Chain α) Nat α","decl":"instance : OrderHomClass (Chain α) ℕ α := inferInstanceAs <| OrderHomClass (ℕ →o α) ℕ α\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.isChain_range","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : Preorder α\nc : OmegaCompletePartialOrder.Chain α\n⊢ IsChain (fun x1 x2 => LE.le x1 x2) (Set.range ⇑c)","decl":"lemma isChain_range : IsChain (· ≤ ·) (Set.range c) := Monotone.isChain_range (OrderHomClass.mono c)\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.directed","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : Preorder α\nc : OmegaCompletePartialOrder.Chain α\n⊢ Directed (fun x1 x2 => LE.le x1 x2) ⇑c","decl":"lemma directed : Directed (· ≤ ·) c := directedOn_range.2 c.isChain_range.directedOn\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.map_coe","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nc : OmegaCompletePartialOrder.Chain α\nf : OrderHom α β\n⊢ Eq (⇑(c.map f)) (Function.comp ⇑f ⇑c)","decl":"@[simp] theorem map_coe : ⇑(map c f) = f ∘ c := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.mem_map","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nc : OmegaCompletePartialOrder.Chain α\nf : OrderHom α β\nx : α\na✝ : Membership.mem c x\n⊢ Membership.mem (c.map f) (f x)","decl":"theorem mem_map (x : α) : x ∈ c → f x ∈ Chain.map c f :=\n  fun ⟨i, h⟩ => ⟨i, h.symm ▸ rfl⟩\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.exists_of_mem_map","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nc : OmegaCompletePartialOrder.Chain α\nf : OrderHom α β\nb : β\na✝ : Membership.mem (c.map f) b\n⊢ Exists fun a => And (Membership.mem c a) (Eq (f a) b)","decl":"theorem exists_of_mem_map {b : β} : b ∈ c.map f → ∃ a, a ∈ c ∧ f a = b :=\n  fun ⟨i, h⟩ => ⟨c i, ⟨i, rfl⟩, h.symm⟩\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.mem_map_iff","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nc : OmegaCompletePartialOrder.Chain α\nf : OrderHom α β\nb : β\n⊢ Iff (Membership.mem (c.map f) b) (Exists fun a => And (Membership.mem c a) (Eq (f a) b))","decl":"@[simp]\ntheorem mem_map_iff {b : β} : b ∈ c.map f ↔ ∃ a, a ∈ c ∧ f a = b :=\n  ⟨exists_of_mem_map _, fun h => by\n    rcases h with ⟨w, h, h'⟩\n    subst b\n    apply mem_map c _ h⟩\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.map_id","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : Preorder α\nc : OmegaCompletePartialOrder.Chain α\n⊢ Eq (c.map OrderHom.id) c","decl":"@[simp]\ntheorem map_id : c.map OrderHom.id = c :=\n  OrderHom.comp_id _\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.map_comp","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nc : OmegaCompletePartialOrder.Chain α\nf : OrderHom α β\ng : OrderHom β γ\n⊢ Eq ((c.map f).map g) (c.map (g.comp f))","decl":"theorem map_comp : (c.map f).map g = c.map (g.comp f) :=\n  rfl\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.map_le_map","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nc : OmegaCompletePartialOrder.Chain α\nf g : OrderHom α β\nh : LE.le f g\n⊢ LE.le (c.map f) (c.map g)","decl":"@[mono]\ntheorem map_le_map {g : α →o β} (h : f ≤ g) : c.map f ≤ c.map g :=\n  fun i => by simp only [map_coe, Function.comp_apply]; exists i; apply h\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.zip_coe","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nc₀ : OmegaCompletePartialOrder.Chain α\nc₁ : OmegaCompletePartialOrder.Chain β\nn : Nat\n⊢ Eq ((c₀.zip c₁) n) { fst := c₀ n, snd := c₁ n }","decl":"@[simp] theorem zip_coe (c₀ : Chain α) (c₁ : Chain β) (n : ℕ) : c₀.zip c₁ n = (c₀ n, c₁ n) := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.pair_zero","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b : α\nhab : LE.le a b\n⊢ Eq ((OmegaCompletePartialOrder.Chain.pair a b hab) 0) a","decl":"@[simp] lemma pair_zero (a b : α) (hab) : pair a b hab 0 = a := rfl\n"}
{"name":"OmegaCompletePartialOrder.Chain.pair_succ","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b : α\nhab : LE.le a b\nn : Nat\n⊢ Eq ((OmegaCompletePartialOrder.Chain.pair a b hab) (HAdd.hAdd n 1)) b","decl":"@[simp] lemma pair_succ (a b : α) (hab) (n : ℕ) : pair a b hab (n + 1) = b := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.range_pair","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b : α\nhab : LE.le a b\n⊢ Eq (Set.range ⇑(OmegaCompletePartialOrder.Chain.pair a b hab)) (Insert.insert a (Singleton.singleton b))","decl":"@[simp] lemma range_pair (a b : α) (hab) : Set.range (pair a b hab) = {a, b} := by\n  ext; exact Nat.or_exists_add_one.symm.trans (by aesop)\n\n"}
{"name":"OmegaCompletePartialOrder.Chain.pair_zip_pair","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na₁ a₂ : α\nb₁ b₂ : β\nha : LE.le a₁ a₂\nhb : LE.le b₁ b₂\n⊢ Eq ((OmegaCompletePartialOrder.Chain.pair a₁ a₂ ha).zip (OmegaCompletePartialOrder.Chain.pair b₁ b₂ hb)) (OmegaCompletePartialOrder.Chain.pair { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ } ⋯)","decl":"@[simp] lemma pair_zip_pair (a₁ a₂ : α) (b₁ b₂ : β) (ha hb) :\n    (pair a₁ a₂ ha).zip (pair b₁ b₂ hb) = pair (a₁, b₁) (a₂, b₂) (Prod.le_def.2 ⟨ha, hb⟩) := by\n  unfold Chain; ext n : 2; cases n <;> rfl\n\n"}
{"name":"OmegaCompletePartialOrder.le_ωSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_6\nself : OmegaCompletePartialOrder α\nc : OmegaCompletePartialOrder.Chain α\ni : Nat\n⊢ LE.le (c i) (OmegaCompletePartialOrder.ωSup c)","decl":"/-- An omega-complete partial order is a partial order with a supremum\noperation on increasing sequences indexed by natural numbers (which we\ncall `ωSup`). In this sense, it is strictly weaker than join complete\nsemi-lattices as only ω-sized totally ordered sets have a supremum.\n\nSee the definition on page 114 of [gunter1992]. -/\nclass OmegaCompletePartialOrder (α : Type*) extends PartialOrder α where\n  /-- The supremum of an increasing sequence -/\n  ωSup : Chain α → α\n  /-- `ωSup` is an upper bound of the increasing sequence -/\n  le_ωSup : ∀ c : Chain α, ∀ i, c i ≤ ωSup c\n  /-- `ωSup` is a lower bound of the set of upper bounds of the increasing sequence -/\n  ωSup_le : ∀ (c : Chain α) (x), (∀ i, c i ≤ x) → ωSup c ≤ x\n\n"}
{"name":"OmegaCompletePartialOrder.ωSup_le","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_6\nself : OmegaCompletePartialOrder α\nc : OmegaCompletePartialOrder.Chain α\nx : α\na✝ : ∀ (i : Nat), LE.le (c i) x\n⊢ LE.le (OmegaCompletePartialOrder.ωSup c) x","decl":"/-- An omega-complete partial order is a partial order with a supremum\noperation on increasing sequences indexed by natural numbers (which we\ncall `ωSup`). In this sense, it is strictly weaker than join complete\nsemi-lattices as only ω-sized totally ordered sets have a supremum.\n\nSee the definition on page 114 of [gunter1992]. -/\nclass OmegaCompletePartialOrder (α : Type*) extends PartialOrder α where\n  /-- The supremum of an increasing sequence -/\n  ωSup : Chain α → α\n  /-- `ωSup` is an upper bound of the increasing sequence -/\n  le_ωSup : ∀ c : Chain α, ∀ i, c i ≤ ωSup c\n  /-- `ωSup` is a lower bound of the set of upper bounds of the increasing sequence -/\n  ωSup_le : ∀ (c : Chain α) (x), (∀ i, c i ≤ x) → ωSup c ≤ x\n\n"}
{"name":"OmegaCompletePartialOrder.le_ωSup_of_le","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nc : OmegaCompletePartialOrder.Chain α\nx : α\ni : Nat\nh : LE.le x (c i)\n⊢ LE.le x (OmegaCompletePartialOrder.ωSup c)","decl":"theorem le_ωSup_of_le {c : Chain α} {x : α} (i : ℕ) (h : x ≤ c i) : x ≤ ωSup c :=\n  le_trans h (le_ωSup c _)\n\n"}
{"name":"OmegaCompletePartialOrder.ωSup_total","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nc : OmegaCompletePartialOrder.Chain α\nx : α\nh : ∀ (i : Nat), Or (LE.le (c i) x) (LE.le x (c i))\n⊢ Or (LE.le (OmegaCompletePartialOrder.ωSup c) x) (LE.le x (OmegaCompletePartialOrder.ωSup c))","decl":"theorem ωSup_total {c : Chain α} {x : α} (h : ∀ i, c i ≤ x ∨ x ≤ c i) : ωSup c ≤ x ∨ x ≤ ωSup c :=\n  by_cases\n    (fun (this : ∀ i, c i ≤ x) => Or.inl (ωSup_le _ _ this))\n    (fun (this : ¬∀ i, c i ≤ x) =>\n      have : ∃ i, ¬c i ≤ x := by simp only [not_forall] at this ⊢; assumption\n      let ⟨i, hx⟩ := this\n      have : x ≤ c i := (h i).resolve_left hx\n      Or.inr <| le_ωSup_of_le _ this)\n\n"}
{"name":"OmegaCompletePartialOrder.ωSup_le_ωSup_of_le","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nc₀ c₁ : OmegaCompletePartialOrder.Chain α\nh : LE.le c₀ c₁\n⊢ LE.le (OmegaCompletePartialOrder.ωSup c₀) (OmegaCompletePartialOrder.ωSup c₁)","decl":"@[mono]\ntheorem ωSup_le_ωSup_of_le {c₀ c₁ : Chain α} (h : c₀ ≤ c₁) : ωSup c₀ ≤ ωSup c₁ :=\n  (ωSup_le _ _) fun i => by\n    obtain ⟨_, h⟩ := h i\n    exact le_trans h (le_ωSup _ _)\n\n"}
{"name":"OmegaCompletePartialOrder.ωSup_le_iff","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nc : OmegaCompletePartialOrder.Chain α\nx : α\n⊢ Iff (LE.le (OmegaCompletePartialOrder.ωSup c) x) (∀ (i : Nat), LE.le (c i) x)","decl":"@[simp] theorem ωSup_le_iff {c : Chain α} {x : α} : ωSup c ≤ x ↔ ∀ i, c i ≤ x := by\n  constructor <;> intros\n  · trans ωSup c\n    · exact le_ωSup _ _\n    · assumption\n  exact ωSup_le _ _ ‹_›\n\n"}
{"name":"OmegaCompletePartialOrder.isLUB_range_ωSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nc : OmegaCompletePartialOrder.Chain α\n⊢ IsLUB (Set.range ⇑c) (OmegaCompletePartialOrder.ωSup c)","decl":"lemma isLUB_range_ωSup (c : Chain α) : IsLUB (Set.range c) (ωSup c) := by\n  constructor\n  · simp only [upperBounds, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff,\n      Set.mem_setOf_eq]\n    exact fun a ↦ le_ωSup c a\n  · simp only [lowerBounds, upperBounds, Set.mem_range, forall_exists_index,\n      forall_apply_eq_imp_iff, Set.mem_setOf_eq]\n    exact fun ⦃a⦄ a_1 ↦ ωSup_le c a a_1\n\n"}
{"name":"OmegaCompletePartialOrder.ωSup_eq_of_isLUB","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nc : OmegaCompletePartialOrder.Chain α\na : α\nh : IsLUB (Set.range ⇑c) a\n⊢ Eq a (OmegaCompletePartialOrder.ωSup c)","decl":"lemma ωSup_eq_of_isLUB {c : Chain α} {a : α} (h : IsLUB (Set.range c) a) : a = ωSup c := by\n  rw [le_antisymm_iff]\n  simp only [IsLUB, IsLeast, upperBounds, lowerBounds, Set.mem_range, forall_exists_index,\n    forall_apply_eq_imp_iff, Set.mem_setOf_eq] at h\n  constructor\n  · apply h.2\n    exact fun a ↦ le_ωSup c a\n  · rw [ωSup_le_iff]\n    apply h.1\n\n"}
{"name":"ScottContinuous.ωScottContinuous","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : α → β\nhf : ScottContinuous f\n⊢ OmegaCompletePartialOrder.ωScottContinuous f","decl":"lemma _root_.ScottContinuous.ωScottContinuous (hf : ScottContinuous f) : ωScottContinuous f :=\n  hf.scottContinuousOn\n\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous.monotone","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : α → β\nh : OmegaCompletePartialOrder.ωScottContinuous f\n⊢ Monotone f","decl":"lemma ωScottContinuous.monotone (h : ωScottContinuous f) : Monotone f :=\n  ScottContinuousOn.monotone _ (fun a b hab => by\n    use pair a b hab; exact range_pair a b hab) h\n\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous.isLUB","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : α → β\nc : OmegaCompletePartialOrder.Chain α\nhf : OmegaCompletePartialOrder.ωScottContinuous f\n⊢ IsLUB (Set.range ⇑(c.map { toFun := f, monotone' := ⋯ })) (f (OmegaCompletePartialOrder.ωSup c))","decl":"lemma ωScottContinuous.isLUB {c : Chain α} (hf : ωScottContinuous f) :\n    IsLUB (Set.range (c.map ⟨f, hf.monotone⟩)) (f (ωSup c)) := by\n  simpa [map_coe, OrderHom.coe_mk, Set.range_comp]\n    using hf (by simp) (Set.range_nonempty _) (isChain_range c).directedOn (isLUB_range_ωSup c)\n\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous.id","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\n⊢ OmegaCompletePartialOrder.ωScottContinuous id","decl":"lemma ωScottContinuous.id : ωScottContinuous (id : α → α) := ScottContinuousOn.id\n\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous.map_ωSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : α → β\nhf : OmegaCompletePartialOrder.ωScottContinuous f\nc : OmegaCompletePartialOrder.Chain α\n⊢ Eq (f (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map { toFun := f, monotone' := ⋯ }))","decl":"lemma ωScottContinuous.map_ωSup (hf : ωScottContinuous f) (c : Chain α) :\n    f (ωSup c) = ωSup (c.map ⟨f, hf.monotone⟩) := ωSup_eq_of_isLUB hf.isLUB\n\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous_iff_monotone_map_ωSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : α → β\n⊢ Iff (OmegaCompletePartialOrder.ωScottContinuous f) (Exists fun hf => ∀ (c : OmegaCompletePartialOrder.Chain α), Eq (f (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map { toFun := f, monotone' := hf })))","decl":"/-- `ωScottContinuous f` asserts that `f` is both monotone and distributes over ωSup. -/\nlemma ωScottContinuous_iff_monotone_map_ωSup :\n    ωScottContinuous f ↔ ∃ hf : Monotone f, ∀ c : Chain α, f (ωSup c) = ωSup (c.map ⟨f, hf⟩) := by\n  refine ⟨fun hf ↦ ⟨hf.monotone, hf.map_ωSup⟩, ?_⟩\n  intro hf _ ⟨c, hc⟩ _ _ _ hda\n  convert isLUB_range_ωSup (c.map { toFun := f, monotone' := hf.1 })\n  · rw [map_coe, OrderHom.coe_mk, ← hc, ← (Set.range_comp f ⇑c)]\n  · rw [← hc] at hda\n    rw [← hf.2 c, ωSup_eq_of_isLUB hda]\n\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous.of_monotone_map_ωSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : α → β\na✝ : Exists fun hf => ∀ (c : OmegaCompletePartialOrder.Chain α), Eq (f (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map { toFun := f, monotone' := hf }))\n⊢ OmegaCompletePartialOrder.ωScottContinuous f","decl":"alias ⟨ωScottContinuous.monotone_map_ωSup, ωScottContinuous.of_monotone_map_ωSup⟩ :=\n  ωScottContinuous_iff_monotone_map_ωSup\n\n/- A monotone function `f : α →o β` is ωScott continuous if and only if it distributes over ωSup. -/\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous.monotone_map_ωSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : α → β\na✝ : OmegaCompletePartialOrder.ωScottContinuous f\n⊢ Exists fun hf => ∀ (c : OmegaCompletePartialOrder.Chain α), Eq (f (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map { toFun := f, monotone' := hf }))","decl":"alias ⟨ωScottContinuous.monotone_map_ωSup, ωScottContinuous.of_monotone_map_ωSup⟩ :=\n  ωScottContinuous_iff_monotone_map_ωSup\n\n/- A monotone function `f : α →o β` is ωScott continuous if and only if it distributes over ωSup. -/\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous_iff_map_ωSup_of_orderHom","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : OrderHom α β\n⊢ Iff (OmegaCompletePartialOrder.ωScottContinuous ⇑f) (∀ (c : OmegaCompletePartialOrder.Chain α), Eq (f (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map f)))","decl":"lemma ωScottContinuous_iff_map_ωSup_of_orderHom {f : α →o β} :\n    ωScottContinuous f ↔ ∀ c : Chain α, f (ωSup c) = ωSup (c.map f) := by\n  rw [ωScottContinuous_iff_monotone_map_ωSup]\n  exact exists_prop_of_true f.monotone'\n\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous.map_ωSup_of_orderHom","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : OrderHom α β\na✝ : OmegaCompletePartialOrder.ωScottContinuous ⇑f\nc : OmegaCompletePartialOrder.Chain α\n⊢ Eq (f (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map f))","decl":"alias ⟨ωScottContinuous.map_ωSup_of_orderHom, ωScottContinuous.of_map_ωSup_of_orderHom⟩ :=\n  ωScottContinuous_iff_map_ωSup_of_orderHom\n\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous.of_map_ωSup_of_orderHom","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : OrderHom α β\na✝ : ∀ (c : OmegaCompletePartialOrder.Chain α), Eq (f (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map f))\n⊢ OmegaCompletePartialOrder.ωScottContinuous ⇑f","decl":"alias ⟨ωScottContinuous.map_ωSup_of_orderHom, ωScottContinuous.of_map_ωSup_of_orderHom⟩ :=\n  ωScottContinuous_iff_map_ωSup_of_orderHom\n\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous.comp","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : OmegaCompletePartialOrder α\ninst✝¹ : OmegaCompletePartialOrder β\ninst✝ : OmegaCompletePartialOrder γ\nf : α → β\ng : β → γ\nhg : OmegaCompletePartialOrder.ωScottContinuous g\nhf : OmegaCompletePartialOrder.ωScottContinuous f\n⊢ OmegaCompletePartialOrder.ωScottContinuous (Function.comp g f)","decl":"lemma ωScottContinuous.comp (hg : ωScottContinuous g) (hf : ωScottContinuous f) :\n    ωScottContinuous (g.comp f) :=\n  ωScottContinuous.of_monotone_map_ωSup\n    ⟨hg.monotone.comp hf.monotone, by simp [hf.map_ωSup, hg.map_ωSup, map_comp]⟩\n\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous.const","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nx : β\n⊢ OmegaCompletePartialOrder.ωScottContinuous (Function.const α x)","decl":"lemma ωScottContinuous.const {x : β} : ωScottContinuous (Function.const α x) := by\n  simp [ωScottContinuous, ScottContinuousOn, Set.range_nonempty]\n\n"}
{"name":"Part.eq_of_chain","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nc : OmegaCompletePartialOrder.Chain (Part α)\na b : α\nha : Membership.mem c (Part.some a)\nhb : Membership.mem c (Part.some b)\n⊢ Eq a b","decl":"theorem eq_of_chain {c : Chain (Part α)} {a b : α} (ha : some a ∈ c) (hb : some b ∈ c) : a = b := by\n  cases' ha with i ha; replace ha := ha.symm\n  cases' hb with j hb; replace hb := hb.symm\n  rw [eq_some_iff] at ha hb\n  rcases le_total i j with hij | hji\n  · have := c.monotone hij _ ha; apply mem_unique this hb\n  · have := c.monotone hji _ hb; apply Eq.symm; apply mem_unique this ha\n  -- Porting note: Old proof\n  -- wlog h : i ≤ j := le_total i j using a b i j, b a j i\n  -- rw [eq_some_iff] at ha hb\n  -- have := c.monotone h _ ha; apply mem_unique this hb\n\n"}
{"name":"Part.ωSup_eq_some","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nc : OmegaCompletePartialOrder.Chain (Part α)\na : α\nh : Membership.mem c (Part.some a)\n⊢ Eq (Part.ωSup c) (Part.some a)","decl":"theorem ωSup_eq_some {c : Chain (Part α)} {a : α} (h : some a ∈ c) : Part.ωSup c = some a :=\n  have : ∃ a, some a ∈ c := ⟨a, h⟩\n  have a' : some (Classical.choose this) ∈ c := Classical.choose_spec this\n  calc\n    Part.ωSup c = some (Classical.choose this) := dif_pos this\n    _ = some a := congr_arg _ (eq_of_chain a' h)\n\n"}
{"name":"Part.ωSup_eq_none","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nc : OmegaCompletePartialOrder.Chain (Part α)\nh : Not (Exists fun a => Membership.mem c (Part.some a))\n⊢ Eq (Part.ωSup c) Part.none","decl":"theorem ωSup_eq_none {c : Chain (Part α)} (h : ¬∃ a, some a ∈ c) : Part.ωSup c = none :=\n  dif_neg h\n\n"}
{"name":"Part.mem_chain_of_mem_ωSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nc : OmegaCompletePartialOrder.Chain (Part α)\na : α\nh : Membership.mem (Part.ωSup c) a\n⊢ Membership.mem c (Part.some a)","decl":"theorem mem_chain_of_mem_ωSup {c : Chain (Part α)} {a : α} (h : a ∈ Part.ωSup c) : some a ∈ c := by\n  simp only [Part.ωSup] at h; split_ifs at h with h_1\n  · have h' := Classical.choose_spec h_1\n    rw [← eq_some_iff] at h\n    rw [← h]\n    exact h'\n  · rcases h with ⟨⟨⟩⟩\n\n"}
{"name":"Part.mem_ωSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nx : α\nc : OmegaCompletePartialOrder.Chain (Part α)\n⊢ Iff (Membership.mem (OmegaCompletePartialOrder.ωSup c) x) (Membership.mem c (Part.some x))","decl":"theorem mem_ωSup (x : α) (c : Chain (Part α)) : x ∈ ωSup c ↔ some x ∈ c := by\n  simp only [ωSup, Part.ωSup]\n  constructor\n  · split_ifs with h\n    swap\n    · rintro ⟨⟨⟩⟩\n    intro h'\n    have hh := Classical.choose_spec h\n    simp only [mem_some_iff] at h'\n    subst x\n    exact hh\n  · intro h\n    have h' : ∃ a : α, some a ∈ c := ⟨_, h⟩\n    rw [dif_pos h']\n    have hh := Classical.choose_spec h'\n    rw [eq_of_chain hh h]\n    simp\n\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous.apply₂","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nγ : Type u_4\nβ : α → Type u_6\ninst✝¹ : (x : α) → OmegaCompletePartialOrder (β x)\ninst✝ : OmegaCompletePartialOrder γ\nf : γ → (x : α) → β x\nhf : OmegaCompletePartialOrder.ωScottContinuous f\na : α\n⊢ OmegaCompletePartialOrder.ωScottContinuous fun x => f x a","decl":"lemma ωScottContinuous.apply₂ (hf : ωScottContinuous f) (a : α) : ωScottContinuous (f · a) :=\n  ωScottContinuous.of_monotone_map_ωSup\n    ⟨fun _ _ h ↦ hf.monotone h a, fun c ↦ congr_fun (hf.map_ωSup c) a⟩\n\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous.of_apply₂","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nγ : Type u_4\nβ : α → Type u_6\ninst✝¹ : (x : α) → OmegaCompletePartialOrder (β x)\ninst✝ : OmegaCompletePartialOrder γ\nf : γ → (x : α) → β x\nhf : ∀ (a : α), OmegaCompletePartialOrder.ωScottContinuous fun x => f x a\n⊢ OmegaCompletePartialOrder.ωScottContinuous f","decl":"lemma ωScottContinuous.of_apply₂ (hf : ∀ a, ωScottContinuous (f · a)) : ωScottContinuous f :=\n  ωScottContinuous.of_monotone_map_ωSup\n    ⟨fun _ _ h a ↦ (hf a).monotone h, fun c ↦ by ext a; apply (hf a).map_ωSup c⟩\n\n"}
{"name":"OmegaCompletePartialOrder.ωScottContinuous_iff_apply₂","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nγ : Type u_4\nβ : α → Type u_6\ninst✝¹ : (x : α) → OmegaCompletePartialOrder (β x)\ninst✝ : OmegaCompletePartialOrder γ\nf : γ → (x : α) → β x\n⊢ Iff (OmegaCompletePartialOrder.ωScottContinuous f) (∀ (a : α), OmegaCompletePartialOrder.ωScottContinuous fun x => f x a)","decl":"lemma ωScottContinuous_iff_apply₂ : ωScottContinuous f ↔ ∀ a, ωScottContinuous (f · a) :=\n  ⟨ωScottContinuous.apply₂, ωScottContinuous.of_apply₂⟩\n\n"}
{"name":"Prod.ωSup_fst","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nc : OmegaCompletePartialOrder.Chain (Prod α β)\n⊢ Eq (Prod.ωSup c).1 (OmegaCompletePartialOrder.ωSup (c.map OrderHom.fst))","decl":"/-- The supremum of a chain in the product `ω`-CPO. -/\n@[simps]\nprotected def ωSup (c : Chain (α × β)) : α × β :=\n  (ωSup (c.map OrderHom.fst), ωSup (c.map OrderHom.snd))\n\n"}
{"name":"Prod.ωSup_snd","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nc : OmegaCompletePartialOrder.Chain (Prod α β)\n⊢ Eq (Prod.ωSup c).2 (OmegaCompletePartialOrder.ωSup (c.map OrderHom.snd))","decl":"/-- The supremum of a chain in the product `ω`-CPO. -/\n@[simps]\nprotected def ωSup (c : Chain (α × β)) : α × β :=\n  (ωSup (c.map OrderHom.fst), ωSup (c.map OrderHom.snd))\n\n"}
{"name":"Prod.instOmegaCompletePartialOrder_ωSup_snd","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nc : OmegaCompletePartialOrder.Chain (Prod α β)\n⊢ Eq (OmegaCompletePartialOrder.ωSup c).2 (OmegaCompletePartialOrder.ωSup (c.map OrderHom.snd))","decl":"@[simps! ωSup_fst ωSup_snd]\ninstance : OmegaCompletePartialOrder (α × β) where\n  ωSup := Prod.ωSup\n  ωSup_le := fun _ _ h => ⟨ωSup_le _ _ fun i => (h i).1, ωSup_le _ _ fun i => (h i).2⟩\n  le_ωSup c i := ⟨le_ωSup (c.map OrderHom.fst) i, le_ωSup (c.map OrderHom.snd) i⟩\n\n"}
{"name":"Prod.instOmegaCompletePartialOrder_ωSup_fst","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nc : OmegaCompletePartialOrder.Chain (Prod α β)\n⊢ Eq (OmegaCompletePartialOrder.ωSup c).1 (OmegaCompletePartialOrder.ωSup (c.map OrderHom.fst))","decl":"@[simps! ωSup_fst ωSup_snd]\ninstance : OmegaCompletePartialOrder (α × β) where\n  ωSup := Prod.ωSup\n  ωSup_le := fun _ _ h => ⟨ωSup_le _ _ fun i => (h i).1, ωSup_le _ _ fun i => (h i).2⟩\n  le_ωSup c i := ⟨le_ωSup (c.map OrderHom.fst) i, le_ωSup (c.map OrderHom.snd) i⟩\n\n"}
{"name":"Prod.ωSup_zip","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nc₀ : OmegaCompletePartialOrder.Chain α\nc₁ : OmegaCompletePartialOrder.Chain β\n⊢ Eq (OmegaCompletePartialOrder.ωSup (c₀.zip c₁)) { fst := OmegaCompletePartialOrder.ωSup c₀, snd := OmegaCompletePartialOrder.ωSup c₁ }","decl":"theorem ωSup_zip (c₀ : Chain α) (c₁ : Chain β) : ωSup (c₀.zip c₁) = (ωSup c₀, ωSup c₁) := by\n  apply eq_of_forall_ge_iff; rintro ⟨z₁, z₂⟩\n  simp [ωSup_le_iff, forall_and]\n\n"}
{"name":"CompleteLattice.ωScottContinuous.prodMk","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : CompleteLattice β\nf g : α → β\nhf : OmegaCompletePartialOrder.ωScottContinuous f\nhg : OmegaCompletePartialOrder.ωScottContinuous g\n⊢ OmegaCompletePartialOrder.ωScottContinuous fun x => { fst := f x, snd := g x }","decl":"open Chain in\nlemma ωScottContinuous.prodMk (hf : ωScottContinuous f) (hg : ωScottContinuous g) :\n    ωScottContinuous fun x => (f x, g x) := ScottContinuousOn.prodMk (fun a b hab => by\n  use pair a b hab; exact range_pair a b hab) hf hg\n\n"}
{"name":"CompleteLattice.ωScottContinuous.iSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"ι : Sort u_1\nα : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : CompleteLattice β\nf : ι → α → β\nhf : ∀ (i : ι), OmegaCompletePartialOrder.ωScottContinuous (f i)\n⊢ OmegaCompletePartialOrder.ωScottContinuous (iSup fun i => f i)","decl":"lemma ωScottContinuous.iSup {f : ι → α → β} (hf : ∀ i, ωScottContinuous (f i)) :\n    ωScottContinuous (⨆ i, f i) := by\n  refine ωScottContinuous.of_monotone_map_ωSup\n    ⟨Monotone.iSup fun i ↦ (hf i).monotone, fun c ↦ eq_of_forall_ge_iff fun a ↦ ?_⟩\n  simp +contextual [ωSup_le_iff, (hf _).map_ωSup, @forall_swap ι]\n\n"}
{"name":"CompleteLattice.ωScottContinuous.sSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : CompleteLattice β\ns : Set (α → β)\nhs : ∀ (f : α → β), Membership.mem s f → OmegaCompletePartialOrder.ωScottContinuous f\n⊢ OmegaCompletePartialOrder.ωScottContinuous (SupSet.sSup s)","decl":"lemma ωScottContinuous.sSup {s : Set (α → β)} (hs : ∀ f ∈ s, ωScottContinuous f) :\n    ωScottContinuous (sSup s) := by\n  rw [sSup_eq_iSup]; exact ωScottContinuous.iSup fun f ↦ ωScottContinuous.iSup <| hs f\n\n"}
{"name":"CompleteLattice.ωScottContinuous.sup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : CompleteLattice β\nf g : α → β\nhf : OmegaCompletePartialOrder.ωScottContinuous f\nhg : OmegaCompletePartialOrder.ωScottContinuous g\n⊢ OmegaCompletePartialOrder.ωScottContinuous (Max.max f g)","decl":"lemma ωScottContinuous.sup (hf : ωScottContinuous f) (hg : ωScottContinuous g) :\n    ωScottContinuous (f ⊔ g) := by\n  rw [← sSup_pair]\n  apply ωScottContinuous.sSup\n  rintro f (rfl | rfl | _) <;> assumption\n\n"}
{"name":"CompleteLattice.ωScottContinuous.top","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : CompleteLattice β\n⊢ OmegaCompletePartialOrder.ωScottContinuous Top.top","decl":"lemma ωScottContinuous.top : ωScottContinuous (⊤ : α → β) :=\n  ωScottContinuous.of_monotone_map_ωSup\n    ⟨monotone_const, fun c ↦ eq_of_forall_ge_iff fun a ↦ by simp⟩\n\n"}
{"name":"CompleteLattice.ωScottContinuous.bot","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : CompleteLattice β\n⊢ OmegaCompletePartialOrder.ωScottContinuous Bot.bot","decl":"lemma ωScottContinuous.bot : ωScottContinuous (⊥ : α → β) := by\n  rw [← sSup_empty]; exact ωScottContinuous.sSup (by simp)\n\n"}
{"name":"CompleteLattice.ωScottContinuous.inf","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : CompleteLinearOrder β\nf g : α → β\nhf : OmegaCompletePartialOrder.ωScottContinuous f\nhg : OmegaCompletePartialOrder.ωScottContinuous g\n⊢ OmegaCompletePartialOrder.ωScottContinuous (Min.min f g)","decl":"lemma ωScottContinuous.inf (hf : ωScottContinuous f) (hg : ωScottContinuous g) :\n    ωScottContinuous (f ⊓ g) := by\n  refine ωScottContinuous.of_monotone_map_ωSup\n    ⟨hf.monotone.inf hg.monotone, fun c ↦ eq_of_forall_ge_iff fun a ↦ ?_⟩\n  simp only [Pi.inf_apply, hf.map_ωSup c, hg.map_ωSup c, inf_le_iff, ωSup_le_iff, Chain.map_coe,\n    Function.comp, OrderHom.coe_mk, ← forall_or_left, ← forall_or_right]\n  exact ⟨fun h _ ↦ h _ _, fun h i j ↦\n    (h (max j i)).imp (le_trans <| hf.monotone <| c.mono <| le_max_left _ _)\n      (le_trans <| hg.monotone <| c.mono <| le_max_right _ _)⟩\n\n"}
{"name":"OmegaCompletePartialOrder.OrderHom.ωSup_coe","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nc : OmegaCompletePartialOrder.Chain (OrderHom α β)\na : α\n⊢ Eq ((OmegaCompletePartialOrder.OrderHom.ωSup c) a) (OmegaCompletePartialOrder.ωSup (c.map (OrderHom.apply a)))","decl":"/-- The `ωSup` operator for monotone functions. -/\n@[simps]\nprotected def ωSup (c : Chain (α →o β)) : α →o β where\n  toFun a := ωSup (c.map (OrderHom.apply a))\n  monotone' _ _ h := ωSup_le_ωSup_of_le ((Chain.map_le_map _) fun a => a.monotone h)\n\n"}
{"name":"OmegaCompletePartialOrder.OrderHom.omegaCompletePartialOrder_ωSup_coe","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nc : OmegaCompletePartialOrder.Chain (OrderHom α β)\na : α\n⊢ Eq ((OmegaCompletePartialOrder.ωSup c) a) (OmegaCompletePartialOrder.ωSup (c.map (OrderHom.apply a)))","decl":"@[simps! ωSup_coe]\ninstance omegaCompletePartialOrder : OmegaCompletePartialOrder (α →o β) :=\n  OmegaCompletePartialOrder.lift OrderHom.coeFnHom OrderHom.ωSup (fun _ _ h => h) fun _ => rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.mk.injEq","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\ntoOrderHom✝ : OrderHom α β\nmap_ωSup'✝ : ∀ (c : OmegaCompletePartialOrder.Chain α), Eq (toOrderHom✝.toFun (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map toOrderHom✝))\ntoOrderHom : OrderHom α β\nmap_ωSup' : ∀ (c : OmegaCompletePartialOrder.Chain α), Eq (toOrderHom.toFun (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map toOrderHom))\n⊢ Eq (Eq { toOrderHom := toOrderHom✝, map_ωSup' := map_ωSup'✝ } { toOrderHom := toOrderHom, map_ωSup' := map_ωSup' }) (Eq toOrderHom✝ toOrderHom)","decl":"variable (α β) in\n/-- A monotone function on `ω`-continuous partial orders is said to be continuous\nif for every chain `c : chain α`, `f (⊔ i, c i) = ⊔ i, f (c i)`.\nThis is just the bundled version of `OrderHom.continuous`. -/\nstructure ContinuousHom extends OrderHom α β where\n  /-- The underlying function of a `ContinuousHom` is continuous, i.e. it preserves `ωSup` -/\n  protected map_ωSup' (c : Chain α) : toFun (ωSup c) = ωSup (c.map toOrderHom)\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.mk.sizeOf_spec","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : OmegaCompletePartialOrder α\ninst✝² : OmegaCompletePartialOrder β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoOrderHom : OrderHom α β\nmap_ωSup' : ∀ (c : OmegaCompletePartialOrder.Chain α), Eq (toOrderHom.toFun (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map toOrderHom))\n⊢ Eq (SizeOf.sizeOf { toOrderHom := toOrderHom, map_ωSup' := map_ωSup' }) (HAdd.hAdd 1 (SizeOf.sizeOf toOrderHom))","decl":"variable (α β) in\n/-- A monotone function on `ω`-continuous partial orders is said to be continuous\nif for every chain `c : chain α`, `f (⊔ i, c i) = ⊔ i, f (c i)`.\nThis is just the bundled version of `OrderHom.continuous`. -/\nstructure ContinuousHom extends OrderHom α β where\n  /-- The underlying function of a `ContinuousHom` is continuous, i.e. it preserves `ωSup` -/\n  protected map_ωSup' (c : Chain α) : toFun (ωSup c) = ωSup (c.map toOrderHom)\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.mk.inj","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\ntoOrderHom✝ : OrderHom α β\nmap_ωSup'✝ : ∀ (c : OmegaCompletePartialOrder.Chain α), Eq (toOrderHom✝.toFun (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map toOrderHom✝))\ntoOrderHom : OrderHom α β\nmap_ωSup' : ∀ (c : OmegaCompletePartialOrder.Chain α), Eq (toOrderHom.toFun (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map toOrderHom))\nx✝ : Eq { toOrderHom := toOrderHom✝, map_ωSup' := map_ωSup'✝ } { toOrderHom := toOrderHom, map_ωSup' := map_ωSup' }\n⊢ Eq toOrderHom✝ toOrderHom","decl":"variable (α β) in\n/-- A monotone function on `ω`-continuous partial orders is said to be continuous\nif for every chain `c : chain α`, `f (⊔ i, c i) = ⊔ i, f (c i)`.\nThis is just the bundled version of `OrderHom.continuous`. -/\nstructure ContinuousHom extends OrderHom α β where\n  /-- The underlying function of a `ContinuousHom` is continuous, i.e. it preserves `ωSup` -/\n  protected map_ωSup' (c : Chain α) : toFun (ωSup c) = ωSup (c.map toOrderHom)\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.map_ωSup'","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nself : OmegaCompletePartialOrder.ContinuousHom α β\nc : OmegaCompletePartialOrder.Chain α\n⊢ Eq (self.toFun (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map self.toOrderHom))","decl":"variable (α β) in\n/-- A monotone function on `ω`-continuous partial orders is said to be continuous\nif for every chain `c : chain α`, `f (⊔ i, c i) = ⊔ i, f (c i)`.\nThis is just the bundled version of `OrderHom.continuous`. -/\nstructure ContinuousHom extends OrderHom α β where\n  /-- The underlying function of a `ContinuousHom` is continuous, i.e. it preserves `ωSup` -/\n  protected map_ωSup' (c : Chain α) : toFun (ωSup c) = ωSup (c.map toOrderHom)\n\n"}
{"name":"OmegaCompletePartialOrder.instOrderHomClassContinuousHom","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\n⊢ OrderHomClass (OmegaCompletePartialOrder.ContinuousHom α β) α β","decl":"instance : OrderHomClass (α →𝒄 β) α β where\n  map_rel f _ _ h := f.mono h\n\n-- Porting note: removed to avoid conflict with the generic instance\n-- instance : Coe (α →𝒄 β) (α →o β) where coe := ContinuousHom.toOrderHom\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.ωScottContinuous","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : OmegaCompletePartialOrder.ContinuousHom α β\n⊢ OmegaCompletePartialOrder.ωScottContinuous ⇑f","decl":"protected lemma ωScottContinuous (f : α →𝒄 β) : ωScottContinuous f :=\n  ωScottContinuous.of_map_ωSup_of_orderHom f.map_ωSup'\n\n-- Not a `simp` lemma because in many cases projection is simpler than a generic coercion\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.toOrderHom_eq_coe","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : OmegaCompletePartialOrder.ContinuousHom α β\n⊢ Eq f.toOrderHom ↑f","decl":"theorem toOrderHom_eq_coe (f : α →𝒄 β) : f.1 = f := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.coe_mk","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : OrderHom α β\nhf : ∀ (c : OmegaCompletePartialOrder.Chain α), Eq (f.toFun (OmegaCompletePartialOrder.ωSup c)) (OmegaCompletePartialOrder.ωSup (c.map f))\n⊢ Eq ⇑{ toOrderHom := f, map_ωSup' := hf } ⇑f","decl":"@[simp] theorem coe_mk (f : α →o β) (hf) : ⇑(mk f hf) = f := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.coe_toOrderHom","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : OmegaCompletePartialOrder.ContinuousHom α β\n⊢ Eq ⇑f.toOrderHom ⇑f","decl":"@[simp] theorem coe_toOrderHom (f : α →𝒄 β) : ⇑f.1 = f := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.congr_fun","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf g : OmegaCompletePartialOrder.ContinuousHom α β\nh : Eq f g\nx : α\n⊢ Eq (f x) (g x)","decl":"protected theorem congr_fun {f g : α →𝒄 β} (h : f = g) (x : α) : f x = g x :=\n  DFunLike.congr_fun h x\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.congr_arg","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : OmegaCompletePartialOrder.ContinuousHom α β\nx y : α\nh : Eq x y\n⊢ Eq (f x) (f y)","decl":"protected theorem congr_arg (f : α →𝒄 β) {x y : α} (h : x = y) : f x = f y :=\n  congr_arg f h\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.monotone","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : OmegaCompletePartialOrder.ContinuousHom α β\n⊢ Monotone ⇑f","decl":"protected theorem monotone (f : α →𝒄 β) : Monotone f :=\n  f.monotone'\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.apply_mono","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf g : OmegaCompletePartialOrder.ContinuousHom α β\nx y : α\nh₁ : LE.le f g\nh₂ : LE.le x y\n⊢ LE.le (f x) (g y)","decl":"@[mono]\ntheorem apply_mono {f g : α →𝒄 β} {x y : α} (h₁ : f ≤ g) (h₂ : x ≤ y) : f x ≤ g y :=\n  OrderHom.apply_mono (show (f : α →o β) ≤ g from h₁) h₂\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.ωSup_bind","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nβ γ : Type v\nc : OmegaCompletePartialOrder.Chain α\nf : OrderHom α (Part β)\ng : OrderHom α (β → Part γ)\n⊢ Eq (OmegaCompletePartialOrder.ωSup (c.map (f.partBind g))) (Bind.bind (OmegaCompletePartialOrder.ωSup (c.map f)) (OmegaCompletePartialOrder.ωSup (c.map g)))","decl":"theorem ωSup_bind {β γ : Type v} (c : Chain α) (f : α →o Part β) (g : α →o β → Part γ) :\n    ωSup (c.map (f.partBind g)) = ωSup (c.map f) >>= ωSup (c.map g) := by\n  apply eq_of_forall_ge_iff; intro x\n  simp only [ωSup_le_iff, Part.bind_le, Chain.mem_map_iff, and_imp, OrderHom.partBind_coe,\n    exists_imp]\n  constructor <;> intro h'''\n  · intro b hb\n    apply ωSup_le _ _ _\n    rintro i y hy\n    simp only [Part.mem_ωSup] at hb\n    rcases hb with ⟨j, hb⟩\n    replace hb := hb.symm\n    simp only [Part.eq_some_iff, Chain.map_coe, Function.comp_apply, OrderHom.apply_coe] at hy hb\n    replace hb : b ∈ f (c (max i j)) := f.mono (c.mono (le_max_right i j)) _ hb\n    replace hy : y ∈ g (c (max i j)) b := g.mono (c.mono (le_max_left i j)) _ _ hy\n    apply h''' (max i j)\n    simp only [exists_prop, Part.bind_eq_bind, Part.mem_bind_iff, Chain.map_coe,\n      Function.comp_apply, OrderHom.partBind_coe]\n    exact ⟨_, hb, hy⟩\n  · intro i\n    intro y hy\n    simp only [exists_prop, Part.bind_eq_bind, Part.mem_bind_iff, Chain.map_coe,\n      Function.comp_apply, OrderHom.partBind_coe] at hy\n    rcases hy with ⟨b, hb₀, hb₁⟩\n    apply h''' b _\n    · apply le_ωSup (c.map g) _ _ _ hb₁\n    · apply le_ωSup (c.map f) i _ hb₀\n\n-- TODO: We should move `ωScottContinuous` to the root namespace\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.ωScottContinuous.bind","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nβ γ : Type u_6\nf : α → Part β\ng : α → β → Part γ\nhf : OmegaCompletePartialOrder.ωScottContinuous f\nhg : OmegaCompletePartialOrder.ωScottContinuous g\n⊢ OmegaCompletePartialOrder.ωScottContinuous fun x => Bind.bind (f x) (g x)","decl":"lemma ωScottContinuous.bind {β γ} {f : α → Part β} {g : α → β → Part γ} (hf : ωScottContinuous f)\n    (hg : ωScottContinuous g) : ωScottContinuous fun x ↦ f x >>= g x :=\n  ωScottContinuous.of_monotone_map_ωSup\n    ⟨hf.monotone.partBind hg.monotone, fun c ↦ by rw [hf.map_ωSup, hg.map_ωSup, ← ωSup_bind]; rfl⟩\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.ωScottContinuous.map","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nβ γ : Type u_6\nf : β → γ\ng : α → Part β\nhg : OmegaCompletePartialOrder.ωScottContinuous g\n⊢ OmegaCompletePartialOrder.ωScottContinuous fun x => Functor.map f (g x)","decl":"lemma ωScottContinuous.map {β γ} {f : β → γ} {g : α → Part β} (hg : ωScottContinuous g) :\n    ωScottContinuous fun x ↦ f <$> g x := by\n  simpa only [map_eq_bind_pure_comp] using ωScottContinuous.bind hg ωScottContinuous.const\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.ωScottContinuous.seq","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nβ γ : Type u_6\nf : α → Part (β → γ)\ng : α → Part β\nhf : OmegaCompletePartialOrder.ωScottContinuous f\nhg : OmegaCompletePartialOrder.ωScottContinuous g\n⊢ OmegaCompletePartialOrder.ωScottContinuous fun x => Seq.seq (f x) fun x_1 => g x","decl":"lemma ωScottContinuous.seq {β γ} {f : α → Part (β → γ)} {g : α → Part β} (hf : ωScottContinuous f)\n    (hg : ωScottContinuous g) : ωScottContinuous fun x ↦ f x <*> g x := by\n  simp only [seq_eq_bind_map]\n  exact ωScottContinuous.bind hf <| ωScottContinuous.of_apply₂ fun _ ↦ ωScottContinuous.map hg\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.continuous","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nF : OmegaCompletePartialOrder.ContinuousHom α β\nC : OmegaCompletePartialOrder.Chain α\n⊢ Eq (F (OmegaCompletePartialOrder.ωSup C)) (OmegaCompletePartialOrder.ωSup (C.map ↑F))","decl":"theorem continuous (F : α →𝒄 β) (C : Chain α) : F (ωSup C) = ωSup (C.map F) :=\n  F.ωScottContinuous.map_ωSup _\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.copy_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : α → β\ng : OmegaCompletePartialOrder.ContinuousHom α β\nh : Eq f ⇑g\na✝ : α\n⊢ Eq ((OmegaCompletePartialOrder.ContinuousHom.copy f g h) a✝) (f a✝)","decl":"/-- Construct a continuous function from a bare function, a continuous function, and a proof that\nthey are equal. -/\n-- Porting note: removed `@[reducible]`\n@[simps!]\ndef copy (f : α → β) (g : α →𝒄 β) (h : f = g) : α →𝒄 β where\n  toOrderHom := g.1.copy f h\n  map_ωSup' := by rw [OrderHom.copy_eq]; exact g.map_ωSup'\n\n-- Porting note: `of_mono` now defeq `mk`\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.id_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\na : α\n⊢ Eq (OmegaCompletePartialOrder.ContinuousHom.id a) a","decl":"/-- The identity as a continuous function. -/\n@[simps!]\ndef id : α →𝒄 α := ⟨OrderHom.id, ωScottContinuous.id.map_ωSup⟩\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.comp_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : OmegaCompletePartialOrder α\ninst✝¹ : OmegaCompletePartialOrder β\ninst✝ : OmegaCompletePartialOrder γ\nf : OmegaCompletePartialOrder.ContinuousHom β γ\ng : OmegaCompletePartialOrder.ContinuousHom α β\na✝ : α\n⊢ Eq ((f.comp g) a✝) (f (g a✝))","decl":"/-- The composition of continuous functions. -/\n@[simps!]\ndef comp (f : β →𝒄 γ) (g : α →𝒄 β) : α →𝒄 γ :=\n  ⟨.comp f.1 g.1, (f.ωScottContinuous.comp g.ωScottContinuous).map_ωSup⟩\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.ext","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf g : OmegaCompletePartialOrder.ContinuousHom α β\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\nprotected theorem ext (f g : α →𝒄 β) (h : ∀ x, f x = g x) : f = g := DFunLike.ext f g h\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.ext_iff","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf g : OmegaCompletePartialOrder.ContinuousHom α β\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f x) (g x))","decl":"@[ext]\nprotected theorem ext (f g : α →𝒄 β) (h : ∀ x, f x = g x) : f = g := DFunLike.ext f g h\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.coe_inj","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf g : OmegaCompletePartialOrder.ContinuousHom α β\nh : Eq ⇑f ⇑g\n⊢ Eq f g","decl":"protected theorem coe_inj (f g : α →𝒄 β) (h : (f : α → β) = g) : f = g :=\n  DFunLike.ext' h\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.comp_id","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"β : Type u_3\nγ : Type u_4\ninst✝¹ : OmegaCompletePartialOrder β\ninst✝ : OmegaCompletePartialOrder γ\nf : OmegaCompletePartialOrder.ContinuousHom β γ\n⊢ Eq (f.comp OmegaCompletePartialOrder.ContinuousHom.id) f","decl":"@[simp]\ntheorem comp_id (f : β →𝒄 γ) : f.comp id = f := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.id_comp","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"β : Type u_3\nγ : Type u_4\ninst✝¹ : OmegaCompletePartialOrder β\ninst✝ : OmegaCompletePartialOrder γ\nf : OmegaCompletePartialOrder.ContinuousHom β γ\n⊢ Eq (OmegaCompletePartialOrder.ContinuousHom.id.comp f) f","decl":"@[simp]\ntheorem id_comp (f : β →𝒄 γ) : id.comp f = f := rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.comp_assoc","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝³ : OmegaCompletePartialOrder α\ninst✝² : OmegaCompletePartialOrder β\ninst✝¹ : OmegaCompletePartialOrder γ\ninst✝ : OmegaCompletePartialOrder δ\nf : OmegaCompletePartialOrder.ContinuousHom γ δ\ng : OmegaCompletePartialOrder.ContinuousHom β γ\nh : OmegaCompletePartialOrder.ContinuousHom α β\n⊢ Eq (f.comp (g.comp h)) ((f.comp g).comp h)","decl":"@[simp]\ntheorem comp_assoc (f : γ →𝒄 δ) (g : β →𝒄 γ) (h : α →𝒄 β) : f.comp (g.comp h) = (f.comp g).comp h :=\n  rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.coe_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\na : α\nf : OmegaCompletePartialOrder.ContinuousHom α β\n⊢ Eq (↑f a) (f a)","decl":"@[simp]\ntheorem coe_apply (a : α) (f : α →𝒄 β) : (f : α →o β) a = f a :=\n  rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.const_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nx : β\na✝ : α\n⊢ Eq ((OmegaCompletePartialOrder.ContinuousHom.const x) a✝) x","decl":"/-- `Function.const` is a continuous function. -/\n@[simps!]\ndef const (x : β) : α →𝒄 β := ⟨.const _ x, ωScottContinuous.const.map_ωSup⟩\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.toMono_coe","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : OmegaCompletePartialOrder.ContinuousHom α β\n⊢ Eq (OmegaCompletePartialOrder.ContinuousHom.toMono f) ↑f","decl":"/-- The map from continuous functions to monotone functions is itself a monotone function. -/\n@[simps]\ndef toMono : (α →𝒄 β) →o α →o β where\n  toFun f := f\n  monotone' _ _ h := h\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.forall_forall_merge","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nc₀ : OmegaCompletePartialOrder.Chain (OmegaCompletePartialOrder.ContinuousHom α β)\nc₁ : OmegaCompletePartialOrder.Chain α\nz : β\n⊢ Iff (∀ (i j : Nat), LE.le ((c₀ i) (c₁ j)) z) (∀ (i : Nat), LE.le ((c₀ i) (c₁ i)) z)","decl":"/-- When proving that a chain of applications is below a bound `z`, it suffices to consider the\nfunctions and values being selected from the same index in the chains.\n\nThis lemma is more specific than necessary, i.e. `c₀` only needs to be a\nchain of monotone functions, but it is only used with continuous functions. -/\n@[simp]\ntheorem forall_forall_merge (c₀ : Chain (α →𝒄 β)) (c₁ : Chain α) (z : β) :\n    (∀ i j : ℕ, (c₀ i) (c₁ j) ≤ z) ↔ ∀ i : ℕ, (c₀ i) (c₁ i) ≤ z := by\n  constructor <;> introv h\n  · apply h\n  · apply le_trans _ (h (max i j))\n    trans c₀ i (c₁ (max i j))\n    · apply (c₀ i).monotone\n      apply c₁.monotone\n      apply le_max_right\n    · apply c₀.monotone\n      apply le_max_left\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.forall_forall_merge'","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nc₀ : OmegaCompletePartialOrder.Chain (OmegaCompletePartialOrder.ContinuousHom α β)\nc₁ : OmegaCompletePartialOrder.Chain α\nz : β\n⊢ Iff (∀ (j i : Nat), LE.le ((c₀ i) (c₁ j)) z) (∀ (i : Nat), LE.le ((c₀ i) (c₁ i)) z)","decl":"@[simp]\ntheorem forall_forall_merge' (c₀ : Chain (α →𝒄 β)) (c₁ : Chain α) (z : β) :\n    (∀ j i : ℕ, (c₀ i) (c₁ j) ≤ z) ↔ ∀ i : ℕ, (c₀ i) (c₁ i) ≤ z := by\n  rw [forall_swap, forall_forall_merge]\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.ωSup_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nc : OmegaCompletePartialOrder.Chain (OmegaCompletePartialOrder.ContinuousHom α β)\na : α\n⊢ Eq ((OmegaCompletePartialOrder.ContinuousHom.ωSup c) a) (OmegaCompletePartialOrder.ωSup ((c.map OmegaCompletePartialOrder.ContinuousHom.toMono).map (OrderHom.apply a)))","decl":"/-- The `ωSup` operator for continuous functions, which takes the pointwise countable supremum\nof the functions in the `ω`-chain. -/\n@[simps!]\nprotected def ωSup (c : Chain (α →𝒄 β)) : α →𝒄 β where\n  toOrderHom := ωSup <| c.map toMono\n  map_ωSup' c' := eq_of_forall_ge_iff fun a ↦ by simp [(c _).ωScottContinuous.map_ωSup]\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.inst_ωSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nc : OmegaCompletePartialOrder.Chain (OmegaCompletePartialOrder.ContinuousHom α β)\n⊢ Eq (OmegaCompletePartialOrder.ωSup c) (OmegaCompletePartialOrder.ContinuousHom.ωSup c)","decl":"@[simps ωSup]\ninstance : OmegaCompletePartialOrder (α →𝒄 β) :=\n  OmegaCompletePartialOrder.lift ContinuousHom.toMono ContinuousHom.ωSup\n    (fun _ _ h => h) (fun _ => rfl)\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.Prod.apply_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nf : Prod (OmegaCompletePartialOrder.ContinuousHom α β) α\n⊢ Eq (OmegaCompletePartialOrder.ContinuousHom.Prod.apply f) (f.1 f.2)","decl":"/-- The application of continuous functions as a continuous function. -/\n@[simps]\ndef apply : (α →𝒄 β) × α →𝒄 β where\n  toFun f := f.1 f.2\n  monotone' x y h := by\n    dsimp\n    trans y.fst x.snd <;> [apply h.1; apply y.1.monotone h.2]\n  map_ωSup' c := by\n    apply le_antisymm\n    · apply ωSup_le\n      intro i\n      dsimp\n      rw [(c _).fst.continuous]\n      apply ωSup_le\n      intro j\n      apply le_ωSup_of_le (max i j)\n      apply apply_mono\n      · exact monotone_fst (OrderHom.mono _ (le_max_left _ _))\n      · exact monotone_snd (OrderHom.mono _ (le_max_right _ _))\n    · apply ωSup_le\n      intro i\n      apply le_ωSup_of_le i\n      dsimp\n      apply OrderHom.mono _\n      apply le_ωSup_of_le i\n      rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.ωSup_def","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nc : OmegaCompletePartialOrder.Chain (OmegaCompletePartialOrder.ContinuousHom α β)\nx : α\n⊢ Eq ((OmegaCompletePartialOrder.ωSup c) x) ((OmegaCompletePartialOrder.ContinuousHom.ωSup c) x)","decl":"theorem ωSup_def (c : Chain (α →𝒄 β)) (x : α) : ωSup c x = ContinuousHom.ωSup c x :=\n  rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.ωSup_apply_ωSup","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : OmegaCompletePartialOrder α\ninst✝ : OmegaCompletePartialOrder β\nc₀ : OmegaCompletePartialOrder.Chain (OmegaCompletePartialOrder.ContinuousHom α β)\nc₁ : OmegaCompletePartialOrder.Chain α\n⊢ Eq ((OmegaCompletePartialOrder.ωSup c₀) (OmegaCompletePartialOrder.ωSup c₁)) (OmegaCompletePartialOrder.ContinuousHom.Prod.apply (OmegaCompletePartialOrder.ωSup (c₀.zip c₁)))","decl":"theorem ωSup_apply_ωSup (c₀ : Chain (α →𝒄 β)) (c₁ : Chain α) :\n    ωSup c₀ (ωSup c₁) = Prod.apply (ωSup (c₀.zip c₁)) := by simp [Prod.apply_apply, Prod.ωSup_zip]\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.flip_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"β : Type u_3\nγ : Type u_4\ninst✝¹ : OmegaCompletePartialOrder β\ninst✝ : OmegaCompletePartialOrder γ\nα : Type u_6\nf : α → OmegaCompletePartialOrder.ContinuousHom β γ\nx : β\ny : α\n⊢ Eq ((OmegaCompletePartialOrder.ContinuousHom.flip f) x y) ((f y) x)","decl":"/-- A family of continuous functions yields a continuous family of functions. -/\n@[simps]\ndef flip {α : Type*} (f : α → β →𝒄 γ) : β →𝒄 α → γ where\n  toFun x y := f y x\n  monotone' _ _ h a := (f a).monotone h\n  map_ωSup' _ := by ext x; change f _ _ = _; rw [(f _).continuous]; rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.bind_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nβ γ : Type v\nf : OmegaCompletePartialOrder.ContinuousHom α (Part β)\ng : OmegaCompletePartialOrder.ContinuousHom α (β → Part γ)\nx : α\n⊢ Eq ((f.bind g) x) ((f x).bind (g x))","decl":"/-- `Part.bind` as a continuous function. -/\n@[simps! apply] -- Porting note: removed `(config := { rhsMd := reducible })`\nnoncomputable def bind {β γ : Type v} (f : α →𝒄 Part β) (g : α →𝒄 β → Part γ) : α →𝒄 Part γ :=\n  .mk (OrderHom.partBind f g.toOrderHom) fun c => by\n    rw [ωSup_bind, ← f.continuous, g.toOrderHom_eq_coe, ← g.continuous]\n    rfl\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.map_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nβ γ : Type v\nf : β → γ\ng : OmegaCompletePartialOrder.ContinuousHom α (Part β)\nx : α\n⊢ Eq ((OmegaCompletePartialOrder.ContinuousHom.map f g) x) (Part.map f (g x))","decl":"/-- `Part.map` as a continuous function. -/\n@[simps! apply] -- Porting note: removed `(config := { rhsMd := reducible })`\nnoncomputable def map {β γ : Type v} (f : β → γ) (g : α →𝒄 Part β) : α →𝒄 Part γ :=\n  .copy (fun x => f <$> g x) (bind g (const (pure ∘ f))) <| by\n    ext1\n    simp only [map_eq_bind_pure_comp, bind, coe_mk, OrderHom.partBind_coe, coe_apply,\n      coe_toOrderHom, const_apply, Part.bind_eq_bind]\n\n"}
{"name":"OmegaCompletePartialOrder.ContinuousHom.seq_apply","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nβ γ : Type v\nf : OmegaCompletePartialOrder.ContinuousHom α (Part (β → γ))\ng : OmegaCompletePartialOrder.ContinuousHom α (Part β)\nx : α\n⊢ Eq ((f.seq g) x) (Seq.seq (f x) fun x_1 => g x)","decl":"/-- `Part.seq` as a continuous function. -/\n@[simps! apply] -- Porting note: removed `(config := { rhsMd := reducible })`\nnoncomputable def seq {β γ : Type v} (f : α →𝒄 Part (β → γ)) (g : α →𝒄 Part β) : α →𝒄 Part γ :=\n  .copy (fun x => f x <*> g x) (bind f <| flip <| _root_.flip map g) <| by\n      ext\n      simp only [seq_eq_bind_map, Part.bind_eq_bind, Part.mem_bind_iff, flip_apply, _root_.flip,\n        map_apply, bind_apply, Part.map_eq_map]\n\n"}
{"name":"OmegaCompletePartialOrder.fixedPoints.ωSup_iterate_mem_fixedPoint","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nf : OmegaCompletePartialOrder.ContinuousHom α α\nx : α\nh : LE.le x (f x)\n⊢ Membership.mem (Function.fixedPoints ⇑f) (OmegaCompletePartialOrder.ωSup (OmegaCompletePartialOrder.fixedPoints.iterateChain (↑f) x h))","decl":"/-- The supremum of iterating a function on x arbitrary often is a fixed point -/\ntheorem ωSup_iterate_mem_fixedPoint (h : x ≤ f x) :\n    ωSup (iterateChain f x h) ∈ fixedPoints f := by\n  rw [mem_fixedPoints, IsFixedPt, f.continuous]\n  apply le_antisymm\n  · apply ωSup_le\n    intro n\n    simp only [Chain.map_coe, OrderHomClass.coe_coe, comp_apply]\n    have : iterateChain f x h (n.succ) = f (iterateChain f x h n) :=\n      Function.iterate_succ_apply' ..\n    rw [← this]\n    apply le_ωSup\n  · apply ωSup_le\n    rintro (_ | n)\n    · apply le_trans h\n      change ((iterateChain f x h).map f) 0 ≤ ωSup ((iterateChain f x h).map (f : α →o α))\n      apply le_ωSup\n    · have : iterateChain f x h (n.succ) = (iterateChain f x h).map f n :=\n        Function.iterate_succ_apply' ..\n      rw [this]\n      apply le_ωSup\n\n"}
{"name":"OmegaCompletePartialOrder.fixedPoints.ωSup_iterate_le_prefixedPoint","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nf : OmegaCompletePartialOrder.ContinuousHom α α\nx : α\nh : LE.le x (f x)\na : α\nh_a : LE.le (f a) a\nh_x_le_a : LE.le x a\n⊢ LE.le (OmegaCompletePartialOrder.ωSup (OmegaCompletePartialOrder.fixedPoints.iterateChain (↑f) x h)) a","decl":"/-- The supremum of iterating a function on x arbitrary often is smaller than any prefixed point.\n\nA prefixed point is a value `a` with `f a ≤ a`. -/\ntheorem ωSup_iterate_le_prefixedPoint (h : x ≤ f x) {a : α}\n    (h_a : f a ≤ a) (h_x_le_a : x ≤ a) :\n    ωSup (iterateChain f x h) ≤ a := by\n  apply ωSup_le\n  intro n\n  induction n with\n  | zero => exact h_x_le_a\n  | succ n h_ind =>\n    have : iterateChain f x h (n.succ) = f (iterateChain f x h n) :=\n      Function.iterate_succ_apply' ..\n    rw [this]\n    exact le_trans (f.monotone h_ind) h_a\n\n"}
{"name":"OmegaCompletePartialOrder.fixedPoints.ωSup_iterate_le_fixedPoint","module":"Mathlib.Order.OmegaCompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : OmegaCompletePartialOrder α\nf : OmegaCompletePartialOrder.ContinuousHom α α\nx : α\nh : LE.le x (f x)\na : α\nh_a : Membership.mem (Function.fixedPoints ⇑f) a\nh_x_le_a : LE.le x a\n⊢ LE.le (OmegaCompletePartialOrder.ωSup (OmegaCompletePartialOrder.fixedPoints.iterateChain (↑f) x h)) a","decl":"/-- The supremum of iterating a function on x arbitrary often is smaller than any fixed point. -/\ntheorem ωSup_iterate_le_fixedPoint (h : x ≤ f x) {a : α}\n    (h_a : a ∈ fixedPoints f) (h_x_le_a : x ≤ a) :\n    ωSup (iterateChain f x h) ≤ a := by\n  rw [mem_fixedPoints] at h_a\n  obtain h_a := Eq.le h_a\n  exact ωSup_iterate_le_prefixedPoint f x h h_a h_x_le_a\n\n"}
