{"name":"CochainComplex.shiftFunctor_obj_d","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nn : Int\nK : CochainComplex C Int\nx‚úù¬π x‚úù : Int\n‚ä¢ Eq (((CochainComplex.shiftFunctor C n).obj K).d x‚úù¬π x‚úù) (HSMul.hSMul n.negOnePow (K.d (HAdd.hAdd x‚úù¬π n) (HAdd.hAdd x‚úù n)))","decl":"/-- The shift functor by `n : ‚Ñ§` on `CochainComplex C ‚Ñ§` which sends a cochain\ncomplex `K` to the complex which is `K.X (i + n)` in degree `i`, and which\nmultiplies the differentials by `(-1)^n`. -/\n@[simps]\ndef shiftFunctor (n : ‚Ñ§) : CochainComplex C ‚Ñ§ ‚•§ CochainComplex C ‚Ñ§ where\n  obj K :=\n    { X := fun i => K.X (i + n)\n      d := fun _ _ => n.negOnePow ‚Ä¢ K.d _ _\n      d_comp_d' := by\n        intros\n        simp only [Linear.comp_units_smul, Linear.units_smul_comp, d_comp_d, smul_zero]\n      shape := fun i j hij => by\n        dsimp\n        rw [K.shape, smul_zero]\n        intro hij'\n        apply hij\n        dsimp at hij' ‚ä¢\n        omega }\n  map œÜ :=\n    { f := fun _ => œÜ.f _\n      comm' := by\n        intros\n        dsimp\n        simp only [Linear.comp_units_smul, Hom.comm, Linear.units_smul_comp] }\n  map_id := by intros; rfl\n  map_comp := by intros; rfl\n\n"}
{"name":"CochainComplex.shiftFunctor_obj_X","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nn : Int\nK : CochainComplex C Int\ni : Int\n‚ä¢ Eq (((CochainComplex.shiftFunctor C n).obj K).X i) (K.X (HAdd.hAdd i n))","decl":"/-- The shift functor by `n : ‚Ñ§` on `CochainComplex C ‚Ñ§` which sends a cochain\ncomplex `K` to the complex which is `K.X (i + n)` in degree `i`, and which\nmultiplies the differentials by `(-1)^n`. -/\n@[simps]\ndef shiftFunctor (n : ‚Ñ§) : CochainComplex C ‚Ñ§ ‚•§ CochainComplex C ‚Ñ§ where\n  obj K :=\n    { X := fun i => K.X (i + n)\n      d := fun _ _ => n.negOnePow ‚Ä¢ K.d _ _\n      d_comp_d' := by\n        intros\n        simp only [Linear.comp_units_smul, Linear.units_smul_comp, d_comp_d, smul_zero]\n      shape := fun i j hij => by\n        dsimp\n        rw [K.shape, smul_zero]\n        intro hij'\n        apply hij\n        dsimp at hij' ‚ä¢\n        omega }\n  map œÜ :=\n    { f := fun _ => œÜ.f _\n      comm' := by\n        intros\n        dsimp\n        simp only [Linear.comp_units_smul, Hom.comm, Linear.units_smul_comp] }\n  map_id := by intros; rfl\n  map_comp := by intros; rfl\n\n"}
{"name":"CochainComplex.shiftFunctor_map_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nn : Int\nX‚úù Y‚úù : CochainComplex C Int\nœÜ : Quiver.Hom X‚úù Y‚úù\nx‚úù : Int\n‚ä¢ Eq (((CochainComplex.shiftFunctor C n).map œÜ).f x‚úù) (œÜ.f (HAdd.hAdd x‚úù n))","decl":"/-- The shift functor by `n : ‚Ñ§` on `CochainComplex C ‚Ñ§` which sends a cochain\ncomplex `K` to the complex which is `K.X (i + n)` in degree `i`, and which\nmultiplies the differentials by `(-1)^n`. -/\n@[simps]\ndef shiftFunctor (n : ‚Ñ§) : CochainComplex C ‚Ñ§ ‚•§ CochainComplex C ‚Ñ§ where\n  obj K :=\n    { X := fun i => K.X (i + n)\n      d := fun _ _ => n.negOnePow ‚Ä¢ K.d _ _\n      d_comp_d' := by\n        intros\n        simp only [Linear.comp_units_smul, Linear.units_smul_comp, d_comp_d, smul_zero]\n      shape := fun i j hij => by\n        dsimp\n        rw [K.shape, smul_zero]\n        intro hij'\n        apply hij\n        dsimp at hij' ‚ä¢\n        omega }\n  map œÜ :=\n    { f := fun _ => œÜ.f _\n      comm' := by\n        intros\n        dsimp\n        simp only [Linear.comp_units_smul, Hom.comm, Linear.units_smul_comp] }\n  map_id := by intros; rfl\n  map_comp := by intros; rfl\n\n"}
{"name":"CochainComplex.instAdditiveIntShiftFunctor","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nn : Int\n‚ä¢ (CochainComplex.shiftFunctor C n).Additive","decl":"instance (n : ‚Ñ§) : (shiftFunctor C n).Additive where\n\n"}
{"name":"CochainComplex.shiftFunctorZero'_inv_app_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nn : Int\nh : Eq n 0\nX : CochainComplex C Int\ni : Int\n‚ä¢ Eq (((CochainComplex.shiftFunctorZero' C n h).inv.app X).f i) (HomologicalComplex.XIsoOfEq X ‚ãØ).inv","decl":"/-- The shift functor by `n` on `CochainComplex C ‚Ñ§` identifies to the identity\nfunctor when `n = 0`. -/\n@[simps!]\ndef shiftFunctorZero' (n : ‚Ñ§) (h : n = 0) :\n    shiftFunctor C n ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents (fun K => Hom.isoOfComponents\n    (fun i => K.shiftFunctorObjXIso _ _ _ (by omega))\n    (fun _ _ _ => by dsimp; simp [h])) (fun _ ‚Ü¶ by ext; dsimp; simp)\n\n"}
{"name":"CochainComplex.shiftFunctorZero'_hom_app_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nn : Int\nh : Eq n 0\nX : CochainComplex C Int\ni : Int\n‚ä¢ Eq (((CochainComplex.shiftFunctorZero' C n h).hom.app X).f i) (HomologicalComplex.XIsoOfEq X ‚ãØ).hom","decl":"/-- The shift functor by `n` on `CochainComplex C ‚Ñ§` identifies to the identity\nfunctor when `n = 0`. -/\n@[simps!]\ndef shiftFunctorZero' (n : ‚Ñ§) (h : n = 0) :\n    shiftFunctor C n ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents (fun K => Hom.isoOfComponents\n    (fun i => K.shiftFunctorObjXIso _ _ _ (by omega))\n    (fun _ _ _ => by dsimp; simp [h])) (fun _ ‚Ü¶ by ext; dsimp; simp)\n\n"}
{"name":"CochainComplex.shiftFunctorAdd'_inv_app_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\nX : CochainComplex C Int\ni : Int\n‚ä¢ Eq (((CochainComplex.shiftFunctorAdd' C n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ h).inv.app X).f i) (HomologicalComplex.XIsoOfEq X ‚ãØ).inv","decl":"/-- The compatibility of the shift functors on `CochainComplex C ‚Ñ§` with respect\nto the addition of integers. -/\n@[simps!]\ndef shiftFunctorAdd' (n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§) (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) :\n    shiftFunctor C n‚ÇÅ‚ÇÇ ‚âÖ shiftFunctor C n‚ÇÅ ‚ãô shiftFunctor C n‚ÇÇ :=\n  NatIso.ofComponents (fun K => Hom.isoOfComponents\n    (fun i => K.shiftFunctorObjXIso _ _ _ (by omega))\n    (fun _ _ _ => by\n      subst h\n      dsimp\n      simp only [add_comm n‚ÇÅ n‚ÇÇ, Int.negOnePow_add, Linear.units_smul_comp,\n        Linear.comp_units_smul, d_comp_XIsoOfEq_hom, smul_smul, XIsoOfEq_hom_comp_d]))\n    (by intros; ext; dsimp; simp)\n\n"}
{"name":"CochainComplex.shiftFunctorAdd'_hom_app_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nn‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : Int\nh : Eq (HAdd.hAdd n‚ÇÅ n‚ÇÇ) n‚ÇÅ‚ÇÇ\nX : CochainComplex C Int\ni : Int\n‚ä¢ Eq (((CochainComplex.shiftFunctorAdd' C n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ h).hom.app X).f i) (HomologicalComplex.XIsoOfEq X ‚ãØ).hom","decl":"/-- The compatibility of the shift functors on `CochainComplex C ‚Ñ§` with respect\nto the addition of integers. -/\n@[simps!]\ndef shiftFunctorAdd' (n‚ÇÅ n‚ÇÇ n‚ÇÅ‚ÇÇ : ‚Ñ§) (h : n‚ÇÅ + n‚ÇÇ = n‚ÇÅ‚ÇÇ) :\n    shiftFunctor C n‚ÇÅ‚ÇÇ ‚âÖ shiftFunctor C n‚ÇÅ ‚ãô shiftFunctor C n‚ÇÇ :=\n  NatIso.ofComponents (fun K => Hom.isoOfComponents\n    (fun i => K.shiftFunctorObjXIso _ _ _ (by omega))\n    (fun _ _ _ => by\n      subst h\n      dsimp\n      simp only [add_comm n‚ÇÅ n‚ÇÇ, Int.negOnePow_add, Linear.units_smul_comp,\n        Linear.comp_units_smul, d_comp_XIsoOfEq_hom, smul_smul, XIsoOfEq_hom_comp_d]))\n    (by intros; ext; dsimp; simp)\n\n"}
{"name":"CochainComplex.instAdditiveHomologicalComplexIntUpShiftFunctor","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nn : Int\n‚ä¢ (CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) n).Additive","decl":"instance (n : ‚Ñ§) :\n    (CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up ‚Ñ§)) n).Additive :=\n  (inferInstance : (CochainComplex.shiftFunctor C n).Additive)\n\n"}
{"name":"CochainComplex.shiftFunctor_obj_X'","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nK : CochainComplex C Int\nn p : Int\n‚ä¢ Eq (((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj K).X p) (K.X (HAdd.hAdd p n))","decl":"@[simp]\nlemma shiftFunctor_obj_X' (K : CochainComplex C ‚Ñ§) (n p : ‚Ñ§) :\n    ((CategoryTheory.shiftFunctor (CochainComplex C ‚Ñ§) n).obj K).X p = K.X (p + n) := rfl\n\n"}
{"name":"CochainComplex.shiftFunctor_map_f'","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nK L : CochainComplex C Int\nœÜ : Quiver.Hom K L\nn p : Int\n‚ä¢ Eq (((CategoryTheory.shiftFunctor (CochainComplex C Int) n).map œÜ).f p) (œÜ.f (HAdd.hAdd p n))","decl":"@[simp]\nlemma shiftFunctor_map_f' {K L : CochainComplex C ‚Ñ§} (œÜ : K ‚ü∂ L) (n p : ‚Ñ§) :\n    ((CategoryTheory.shiftFunctor (CochainComplex C ‚Ñ§) n).map œÜ).f p = œÜ.f (p + n) := rfl\n\n"}
{"name":"CochainComplex.shiftFunctor_obj_d'","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nK : CochainComplex C Int\nn i j : Int\n‚ä¢ Eq (((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj K).d i j) (HSMul.hSMul n.negOnePow (K.d (HAdd.hAdd i { as := n }.as) (HAdd.hAdd j { as := n }.as)))","decl":"@[simp]\nlemma shiftFunctor_obj_d' (K : CochainComplex C ‚Ñ§) (n i j : ‚Ñ§) :\n    ((CategoryTheory.shiftFunctor (CochainComplex C ‚Ñ§) n).obj K).d i j =\n      n.negOnePow ‚Ä¢ K.d _ _ := rfl\n\n"}
{"name":"CochainComplex.shiftFunctorAdd_inv_app_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nK : CochainComplex C Int\na b n : Int\n‚ä¢ Eq (((CategoryTheory.shiftFunctorAdd (CochainComplex C Int) a b).inv.app K).f n) (HomologicalComplex.XIsoOfEq K ‚ãØ).hom","decl":"lemma shiftFunctorAdd_inv_app_f (K : CochainComplex C ‚Ñ§) (a b n : ‚Ñ§) :\n    ((shiftFunctorAdd (CochainComplex C ‚Ñ§) a b).inv.app K).f n =\n      (K.XIsoOfEq (by dsimp; rw [add_comm a, add_assoc])).hom := rfl\n\n"}
{"name":"CochainComplex.shiftFunctorAdd_hom_app_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nK : CochainComplex C Int\na b n : Int\n‚ä¢ Eq (((CategoryTheory.shiftFunctorAdd (CochainComplex C Int) a b).hom.app K).f n) (HomologicalComplex.XIsoOfEq K ‚ãØ).hom","decl":"lemma shiftFunctorAdd_hom_app_f (K : CochainComplex C ‚Ñ§) (a b n : ‚Ñ§) :\n    ((shiftFunctorAdd (CochainComplex C ‚Ñ§) a b).hom.app K).f n =\n      (K.XIsoOfEq (by dsimp; rw [add_comm a, add_assoc])).hom := by\n  have : IsIso (((shiftFunctorAdd (CochainComplex C ‚Ñ§) a b).inv.app K).f n) := by\n    rw [shiftFunctorAdd_inv_app_f]\n    infer_instance\n  rw [‚Üê cancel_mono (((shiftFunctorAdd (CochainComplex C ‚Ñ§) a b).inv.app K).f n),\n    ‚Üê comp_f, Iso.hom_inv_id_app, id_f, shiftFunctorAdd_inv_app_f]\n  simp only [XIsoOfEq, eqToIso.hom, eqToHom_trans, eqToHom_refl]\n\n"}
{"name":"CochainComplex.shiftFunctorAdd'_inv_app_f'","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nK : CochainComplex C Int\na b ab : Int\nh : Eq (HAdd.hAdd a b) ab\nn : Int\n‚ä¢ Eq (((CategoryTheory.shiftFunctorAdd' (CochainComplex C Int) a b ab h).inv.app K).f n) (HomologicalComplex.XIsoOfEq K ‚ãØ).hom","decl":"lemma shiftFunctorAdd'_inv_app_f' (K : CochainComplex C ‚Ñ§) (a b ab : ‚Ñ§) (h : a + b = ab) (n : ‚Ñ§) :\n    ((CategoryTheory.shiftFunctorAdd' (CochainComplex C ‚Ñ§) a b ab h).inv.app K).f n =\n      (K.XIsoOfEq (by dsimp; rw [‚Üê h, add_assoc, add_comm a])).hom := by\n  subst h\n  rw [shiftFunctorAdd'_eq_shiftFunctorAdd, shiftFunctorAdd_inv_app_f]\n\n"}
{"name":"CochainComplex.shiftFunctorAdd'_hom_app_f'","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nK : CochainComplex C Int\na b ab : Int\nh : Eq (HAdd.hAdd a b) ab\nn : Int\n‚ä¢ Eq (((CategoryTheory.shiftFunctorAdd' (CochainComplex C Int) a b ab h).hom.app K).f n) (HomologicalComplex.XIsoOfEq K ‚ãØ).hom","decl":"lemma shiftFunctorAdd'_hom_app_f' (K : CochainComplex C ‚Ñ§) (a b ab : ‚Ñ§) (h : a + b = ab) (n : ‚Ñ§) :\n    ((CategoryTheory.shiftFunctorAdd' (CochainComplex C ‚Ñ§) a b ab h).hom.app K).f n =\n      (K.XIsoOfEq (by dsimp; rw [‚Üê h, add_assoc, add_comm a])).hom := by\n  subst h\n  rw [shiftFunctorAdd'_eq_shiftFunctorAdd, shiftFunctorAdd_hom_app_f]\n\n"}
{"name":"CochainComplex.shiftFunctorZero_inv_app_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nK : CochainComplex C Int\nn : Int\n‚ä¢ Eq (((CategoryTheory.shiftFunctorZero (CochainComplex C Int) Int).inv.app K).f n) (HomologicalComplex.XIsoOfEq K ‚ãØ).hom","decl":"lemma shiftFunctorZero_inv_app_f (K : CochainComplex C ‚Ñ§) (n : ‚Ñ§) :\n    ((CategoryTheory.shiftFunctorZero (CochainComplex C ‚Ñ§) ‚Ñ§).inv.app K).f n =\n      (K.XIsoOfEq (by dsimp; rw [add_zero])).hom := rfl\n\n"}
{"name":"CochainComplex.shiftFunctorZero_hom_app_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nK : CochainComplex C Int\nn : Int\n‚ä¢ Eq (((CategoryTheory.shiftFunctorZero (CochainComplex C Int) Int).hom.app K).f n) (HomologicalComplex.XIsoOfEq K ‚ãØ).hom","decl":"lemma shiftFunctorZero_hom_app_f (K : CochainComplex C ‚Ñ§) (n : ‚Ñ§) :\n    ((CategoryTheory.shiftFunctorZero (CochainComplex C ‚Ñ§) ‚Ñ§).hom.app K).f n =\n      (K.XIsoOfEq (by dsimp; rw [add_zero])).hom := by\n  have : IsIso (((shiftFunctorZero (CochainComplex C ‚Ñ§) ‚Ñ§).inv.app K).f n) := by\n    rw [shiftFunctorZero_inv_app_f]\n    infer_instance\n  rw [‚Üê cancel_mono (((shiftFunctorZero (CochainComplex C ‚Ñ§) ‚Ñ§).inv.app K).f n), ‚Üê comp_f,\n    Iso.hom_inv_id_app, id_f, shiftFunctorZero_inv_app_f]\n  simp only [XIsoOfEq, eqToIso.hom, eqToHom_trans, eqToHom_refl]\n\n"}
{"name":"CochainComplex.XIsoOfEq_shift","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nK : CochainComplex C Int\nn p q : Int\nhpq : Eq p q\n‚ä¢ Eq (HomologicalComplex.XIsoOfEq ((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj K) hpq) (HomologicalComplex.XIsoOfEq K ‚ãØ)","decl":"lemma XIsoOfEq_shift (K : CochainComplex C ‚Ñ§) (n : ‚Ñ§) {p q : ‚Ñ§} (hpq : p = q) :\n    (K‚ü¶n‚üß).XIsoOfEq hpq = K.XIsoOfEq (show p + n = q + n by rw [hpq]) := rfl\n\n"}
{"name":"CochainComplex.shiftFunctorAdd'_eq","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\na b c : Int\nh : Eq (HAdd.hAdd a b) c\n‚ä¢ Eq (CategoryTheory.shiftFunctorAdd' (CochainComplex C Int) a b c h) (CochainComplex.shiftFunctorAdd' C a b c h)","decl":"lemma shiftFunctorAdd'_eq (a b c : ‚Ñ§) (h : a + b = c) :\n    CategoryTheory.shiftFunctorAdd' (CochainComplex C ‚Ñ§) a b c h =\n      shiftFunctorAdd' C a b c h := by\n  ext\n  simp only [shiftFunctorAdd'_hom_app_f', XIsoOfEq, eqToIso.hom, shiftFunctorAdd'_hom_app_f]\n\n"}
{"name":"CochainComplex.shiftFunctorAdd_eq","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\na b : Int\n‚ä¢ Eq (CategoryTheory.shiftFunctorAdd (CochainComplex C Int) a b) (CochainComplex.shiftFunctorAdd' C a b (HAdd.hAdd a b) ‚ãØ)","decl":"lemma shiftFunctorAdd_eq (a b : ‚Ñ§) :\n    CategoryTheory.shiftFunctorAdd (CochainComplex C ‚Ñ§) a b = shiftFunctorAdd' C a b _ rfl := by\n  rw [‚Üê CategoryTheory.shiftFunctorAdd'_eq_shiftFunctorAdd, shiftFunctorAdd'_eq]\n\n"}
{"name":"CochainComplex.shiftFunctorZero_eq","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\n‚ä¢ Eq (CategoryTheory.shiftFunctorZero (CochainComplex C Int) Int) (CochainComplex.shiftFunctorZero' C 0 ‚ãØ)","decl":"lemma shiftFunctorZero_eq :\n    CategoryTheory.shiftFunctorZero (CochainComplex C ‚Ñ§) ‚Ñ§ = shiftFunctorZero' C 0 rfl := by\n  ext\n  rw [shiftFunctorZero_hom_app_f, shiftFunctorZero'_hom_app_f]\n\n"}
{"name":"CochainComplex.shiftFunctorComm_hom_app_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nK : CochainComplex C Int\na b p : Int\n‚ä¢ Eq (((CategoryTheory.shiftFunctorComm (CochainComplex C Int) a b).hom.app K).f p) (HomologicalComplex.XIsoOfEq K ‚ãØ).hom","decl":"lemma shiftFunctorComm_hom_app_f (K : CochainComplex C ‚Ñ§) (a b p : ‚Ñ§) :\n    ((shiftFunctorComm (CochainComplex C ‚Ñ§) a b).hom.app K).f p =\n      (K.XIsoOfEq (show p + b + a = p + a + b\n        by rw [add_assoc, add_comm b, add_assoc])).hom := by\n  rw [shiftFunctorComm_eq _ _ _ _ rfl]\n  dsimp\n  rw [shiftFunctorAdd'_inv_app_f', shiftFunctorAdd'_hom_app_f']\n  simp only [XIsoOfEq, eqToIso.hom, eqToHom_trans]\n\n"}
{"name":"CochainComplex.shiftEval_hom_app","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nn i i' : Int\nhi : Eq (HAdd.hAdd n i) i'\nX : CochainComplex C Int\n‚ä¢ Eq ((CochainComplex.shiftEval C n i i' hi).hom.app X) (HomologicalComplex.XIsoOfEq X ‚ãØ).hom","decl":"/-- Shifting cochain complexes by `n` and evaluating in a degree `i` identifies\nto the evaluation in degree `i'` when `n + i = i'`. -/\n@[simps!]\ndef shiftEval (n i i' : ‚Ñ§) (hi : n + i = i') :\n    (CategoryTheory.shiftFunctor (CochainComplex C ‚Ñ§) n) ‚ãô\n      HomologicalComplex.eval C (ComplexShape.up ‚Ñ§) i ‚âÖ\n      HomologicalComplex.eval C (ComplexShape.up ‚Ñ§) i' :=\n  NatIso.ofComponents (fun K => K.XIsoOfEq (by dsimp; rw [‚Üê hi, add_comm i]))\n    (by intros; dsimp; simp)\n\n"}
{"name":"CochainComplex.shiftEval_inv_app","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nn i i' : Int\nhi : Eq (HAdd.hAdd n i) i'\nX : CochainComplex C Int\n‚ä¢ Eq ((CochainComplex.shiftEval C n i i' hi).inv.app X) (HomologicalComplex.XIsoOfEq X ‚ãØ).inv","decl":"/-- Shifting cochain complexes by `n` and evaluating in a degree `i` identifies\nto the evaluation in degree `i'` when `n + i = i'`. -/\n@[simps!]\ndef shiftEval (n i i' : ‚Ñ§) (hi : n + i = i') :\n    (CategoryTheory.shiftFunctor (CochainComplex C ‚Ñ§) n) ‚ãô\n      HomologicalComplex.eval C (ComplexShape.up ‚Ñ§) i ‚âÖ\n      HomologicalComplex.eval C (ComplexShape.up ‚Ñ§) i' :=\n  NatIso.ofComponents (fun K => K.XIsoOfEq (by dsimp; rw [‚Üê hi, add_comm i]))\n    (by intros; dsimp; simp)\n\n"}
{"name":"CategoryTheory.Functor.mapCochainComplexShiftIso_hom_app_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Int\nX : HomologicalComplex C (ComplexShape.up Int)\ni : Int\n‚ä¢ Eq (((F.mapCochainComplexShiftIso n).hom.app X).f i) (CategoryTheory.CategoryStruct.id (F.obj (X.X (HAdd.hAdd i n))))","decl":"/-- The commutation with the shift isomorphism for the functor on cochain complexes\ninduced by an additive functor between preadditive categories. -/\n@[simps!]\ndef mapCochainComplexShiftIso (n : ‚Ñ§) :\n    shiftFunctor _ n ‚ãô F.mapHomologicalComplex (ComplexShape.up ‚Ñ§) ‚âÖ\n      F.mapHomologicalComplex (ComplexShape.up ‚Ñ§) ‚ãô shiftFunctor _ n :=\n  NatIso.ofComponents (fun K => HomologicalComplex.Hom.isoOfComponents (fun _ => Iso.refl _)\n    (by dsimp; simp)) (fun _ => by ext; dsimp; rw [id_comp, comp_id])\n\n"}
{"name":"CategoryTheory.Functor.mapCochainComplexShiftIso_inv_app_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Int\nX : HomologicalComplex C (ComplexShape.up Int)\ni : Int\n‚ä¢ Eq (((F.mapCochainComplexShiftIso n).inv.app X).f i) (CategoryTheory.CategoryStruct.id (F.obj (X.X (HAdd.hAdd i n))))","decl":"/-- The commutation with the shift isomorphism for the functor on cochain complexes\ninduced by an additive functor between preadditive categories. -/\n@[simps!]\ndef mapCochainComplexShiftIso (n : ‚Ñ§) :\n    shiftFunctor _ n ‚ãô F.mapHomologicalComplex (ComplexShape.up ‚Ñ§) ‚âÖ\n      F.mapHomologicalComplex (ComplexShape.up ‚Ñ§) ‚ãô shiftFunctor _ n :=\n  NatIso.ofComponents (fun K => HomologicalComplex.Hom.isoOfComponents (fun _ => Iso.refl _)\n    (by dsimp; simp)) (fun _ => by ext; dsimp; rw [id_comp, comp_id])\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplex_commShiftIso_eq","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Int\n‚ä¢ Eq ((F.mapHomologicalComplex (ComplexShape.up Int)).commShiftIso n) (F.mapCochainComplexShiftIso n)","decl":"lemma mapHomologicalComplex_commShiftIso_eq (n : ‚Ñ§) :\n    (F.mapHomologicalComplex (ComplexShape.up ‚Ñ§)).commShiftIso n =\n      F.mapCochainComplexShiftIso n := rfl\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplex_commShiftIso_hom_app_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nK : CochainComplex C Int\nn i : Int\n‚ä¢ Eq ((((F.mapHomologicalComplex (ComplexShape.up Int)).commShiftIso n).hom.app K).f i) (CategoryTheory.CategoryStruct.id ((((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) n).comp (F.mapHomologicalComplex (ComplexShape.up Int))).obj K).X i))","decl":"@[simp]\nlemma mapHomologicalComplex_commShiftIso_hom_app_f (K : CochainComplex C ‚Ñ§) (n i : ‚Ñ§) :\n    (((F.mapHomologicalComplex (ComplexShape.up ‚Ñ§)).commShiftIso n).hom.app K).f i = ùüô _ := rfl\n\n"}
{"name":"CategoryTheory.Functor.mapHomologicalComplex_commShiftIso_inv_app_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nK : CochainComplex C Int\nn i : Int\n‚ä¢ Eq ((((F.mapHomologicalComplex (ComplexShape.up Int)).commShiftIso n).inv.app K).f i) (CategoryTheory.CategoryStruct.id ((((F.mapHomologicalComplex (ComplexShape.up Int)).comp (CategoryTheory.shiftFunctor (HomologicalComplex D (ComplexShape.up Int)) n)).obj K).X i))","decl":"@[simp]\nlemma mapHomologicalComplex_commShiftIso_inv_app_f (K : CochainComplex C ‚Ñ§) (n i : ‚Ñ§) :\n    (((F.mapHomologicalComplex (ComplexShape.up ‚Ñ§)).commShiftIso n).inv.app K).f i = ùüô _ := rfl\n\n"}
{"name":"HomotopyCategory.instIsCompatibleWithShiftHomologicalComplexIntUpHomotopic","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\n‚ä¢ (homotopic C (ComplexShape.up Int)).IsCompatibleWithShift Int","decl":"instance : (homotopic C (ComplexShape.up ‚Ñ§)).IsCompatibleWithShift ‚Ñ§ :=\n  ‚ü®fun n _ _ _ _ ‚ü®h‚ü© => ‚ü®h.shift n‚ü©‚ü©\n\n"}
{"name":"HomotopyCategory.instAdditiveIntUpShiftFunctor","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Preadditive C\nn : Int\n‚ä¢ (CategoryTheory.shiftFunctor (HomotopyCategory C (ComplexShape.up Int)) n).Additive","decl":"instance (n : ‚Ñ§) : (shiftFunctor (HomotopyCategory C (ComplexShape.up ‚Ñ§)) n).Additive := by\n  have : ((quotient C (ComplexShape.up ‚Ñ§) ‚ãô shiftFunctor _ n)).Additive :=\n    Functor.additive_of_iso ((quotient C (ComplexShape.up ‚Ñ§)).commShiftIso n)\n  apply Functor.additive_of_full_essSurj_comp (quotient _ _ )\n\n"}
{"name":"HomotopyCategory.instCommShiftHomologicalComplexIntUpHomFunctorMapHomotopyCategoryFactors","module":"Mathlib.Algebra.Homology.HomotopyCategory.Shift","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ CategoryTheory.NatTrans.CommShift (F.mapHomotopyCategoryFactors (ComplexShape.up Int)).hom Int","decl":"instance : NatTrans.CommShift (F.mapHomotopyCategoryFactors (ComplexShape.up ‚Ñ§)).hom ‚Ñ§ :=\n  Quotient.liftCommShift_compatibility _ _ _ _\n\n"}
