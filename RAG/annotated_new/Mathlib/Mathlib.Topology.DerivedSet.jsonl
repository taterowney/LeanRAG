{"name":"AccPt.map","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nβ : Type u_2\ninst✝ : TopologicalSpace β\nF : Filter X\nx : X\nh : AccPt x F\nf : X → β\nhf1 : ContinuousAt f x\nhf2 : Function.Injective f\n⊢ AccPt (f x) (Filter.map f F)","decl":"theorem AccPt.map {β : Type*} [TopologicalSpace β] {F : Filter X} {x : X}\n    (h : AccPt x F) {f : X → β} (hf1 : ContinuousAt f x) (hf2 : Function.Injective f) :\n    AccPt (f x) (map f F) := by\n  apply map_neBot (m := f) (hf := h) |>.mono\n  rw [Filter.map_inf hf2]\n  gcongr\n  apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hf1.continuousWithinAt\n  simpa [hf2.eq_iff] using eventually_mem_nhdsWithin\n\n"}
{"name":"mem_derivedSet","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nA : Set X\nx : X\n⊢ Iff (Membership.mem (derivedSet A) x) (AccPt x (Filter.principal A))","decl":"@[simp]\nlemma mem_derivedSet {A : Set X} {x : X} : x ∈ derivedSet A ↔ AccPt x (𝓟 A) := Iff.rfl\n\n"}
{"name":"derivedSet_union","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nA B : Set X\n⊢ Eq (derivedSet (Union.union A B)) (Union.union (derivedSet A) (derivedSet B))","decl":"lemma derivedSet_union (A B : Set X) : derivedSet (A ∪ B) = derivedSet A ∪ derivedSet B := by\n  ext x\n  simp [derivedSet, ← sup_principal, accPt_sup]\n\n"}
{"name":"derivedSet_mono","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nA B : Set X\nh : HasSubset.Subset A B\n⊢ HasSubset.Subset (derivedSet A) (derivedSet B)","decl":"lemma derivedSet_mono (A B : Set X) (h : A ⊆ B) : derivedSet A ⊆ derivedSet B :=\n  fun _ hx ↦ hx.mono <| le_principal_iff.mpr <| mem_principal.mpr h\n\n"}
{"name":"Continuous.image_derivedSet","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nβ : Type u_2\ninst✝ : TopologicalSpace β\nA : Set X\nf : X → β\nhf1 : Continuous f\nhf2 : Function.Injective f\n⊢ HasSubset.Subset (Set.image f (derivedSet A)) (derivedSet (Set.image f A))","decl":"theorem Continuous.image_derivedSet {β : Type*} [TopologicalSpace β] {A : Set X} {f : X → β}\n    (hf1 : Continuous f) (hf2 : Function.Injective f) :\n    f '' derivedSet A ⊆ derivedSet (f '' A) := by\n  intro x hx\n  simp only [Set.mem_image, mem_derivedSet] at hx\n  obtain ⟨y, hy1, rfl⟩ := hx\n  convert hy1.map hf1.continuousAt hf2\n  simp\n\n"}
{"name":"derivedSet_subset_closure","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nA : Set X\n⊢ HasSubset.Subset (derivedSet A) (closure A)","decl":"lemma derivedSet_subset_closure (A : Set X) : derivedSet A ⊆ closure A :=\n  fun _ hx ↦ mem_closure_iff_clusterPt.mpr hx.clusterPt\n\n"}
{"name":"isClosed_iff_derivedSet_subset","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nA : Set X\n⊢ Iff (IsClosed A) (HasSubset.Subset (derivedSet A) A)","decl":"lemma isClosed_iff_derivedSet_subset (A : Set X) : IsClosed A ↔ derivedSet A ⊆ A where\n  mp h := derivedSet_subset_closure A |>.trans h.closure_subset\n  mpr h := by\n    rw [isClosed_iff_clusterPt]\n    intro a ha\n    by_contra! nh\n    have : A = A \\ {a} := by simp [nh]\n    rw [this, ← acc_principal_iff_cluster] at ha\n    exact nh (h ha)\n\n"}
{"name":"derivedSet_closure","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T1Space X\nA : Set X\n⊢ Eq (derivedSet (closure A)) (derivedSet A)","decl":"/-- In a `T1Space`, the `derivedSet` of the closure of a set is equal to the derived set of the\nset itself.\n\nNote: this doesn't hold in a space with the indiscrete topology. For example, if `X` is a type with\ntwo elements, `x` and `y`, and `A := {x}`, then `closure A = Set.univ` and `derivedSet A = {y}`,\nbut `derivedSet Set.univ = Set.univ`. -/\nlemma derivedSet_closure [T1Space X] (A : Set X) : derivedSet (closure A) = derivedSet A := by\n  refine le_antisymm (fun x hx => ?_) (derivedSet_mono _ _ subset_closure)\n  rw [mem_derivedSet, AccPt, (nhdsWithin_basis_open x {x}ᶜ).inf_principal_neBot_iff] at hx ⊢\n  peel hx with u hu _\n  obtain ⟨-, hu_open⟩ := hu\n  exact mem_closure_iff.mp this.some_mem.2 (u ∩ {x}ᶜ) (hu_open.inter isOpen_compl_singleton)\n    this.some_mem.1\n\n"}
{"name":"isClosed_derivedSet","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T1Space X\nA : Set X\n⊢ IsClosed (derivedSet A)","decl":"@[simp]\nlemma isClosed_derivedSet [T1Space X] (A : Set X) : IsClosed (derivedSet A) := by\n  rw [← derivedSet_closure, isClosed_iff_derivedSet_subset]\n  apply derivedSet_mono\n  simp [← isClosed_iff_derivedSet_subset]\n\n"}
{"name":"preperfect_iff_subset_derivedSet","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nU : Set X\n⊢ Iff (Preperfect U) (HasSubset.Subset U (derivedSet U))","decl":"lemma preperfect_iff_subset_derivedSet {U : Set X} : Preperfect U ↔ U ⊆ derivedSet U :=\n  Iff.rfl\n\n"}
{"name":"perfect_iff_eq_derivedSet","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nU : Set X\n⊢ Iff (Perfect U) (Eq U (derivedSet U))","decl":"lemma perfect_iff_eq_derivedSet {U : Set X} : Perfect U ↔ U = derivedSet U := by\n  rw [perfect_def, isClosed_iff_derivedSet_subset, preperfect_iff_subset_derivedSet,\n    ← subset_antisymm_iff, eq_comm]\n\n"}
{"name":"IsPreconnected.inter_derivedSet_nonempty","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T1Space X\nU : Set X\nhs : IsPreconnected U\na b : Set X\nh : HasSubset.Subset U (Union.union a b)\nha : (Inter.inter U (derivedSet a)).Nonempty\nhb : (Inter.inter U (derivedSet b)).Nonempty\n⊢ (Inter.inter U (Inter.inter (derivedSet a) (derivedSet b))).Nonempty","decl":"lemma IsPreconnected.inter_derivedSet_nonempty [T1Space X] {U : Set X} (hs : IsPreconnected U)\n    (a b : Set X) (h : U ⊆ a ∪ b) (ha : (U ∩ derivedSet a).Nonempty)\n    (hb : (U ∩ derivedSet b).Nonempty) : (U ∩ (derivedSet a ∩ derivedSet b)).Nonempty := by\n  by_cases hu : U.Nontrivial\n  · apply isPreconnected_closed_iff.mp hs\n    · simp\n    · simp\n    · trans derivedSet U\n      · apply hs.preperfect_of_nontrivial hu\n      · rw [← derivedSet_union]\n        exact derivedSet_mono _ _ h\n    · exact ha\n    · exact hb\n  · obtain ⟨x, hx⟩ := ha.left.exists_eq_singleton_or_nontrivial.resolve_right hu\n    simp_all\n"}
