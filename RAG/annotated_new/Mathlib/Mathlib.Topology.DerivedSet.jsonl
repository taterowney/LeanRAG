{"name":"AccPt.map","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nÎ² : Type u_2\ninstâœ : TopologicalSpace Î²\nF : Filter X\nx : X\nh : AccPt x F\nf : X â†’ Î²\nhf1 : ContinuousAt f x\nhf2 : Function.Injective f\nâŠ¢ AccPt (f x) (Filter.map f F)","decl":"theorem AccPt.map {Î² : Type*} [TopologicalSpace Î²] {F : Filter X} {x : X}\n    (h : AccPt x F) {f : X â†’ Î²} (hf1 : ContinuousAt f x) (hf2 : Function.Injective f) :\n    AccPt (f x) (map f F) := by\n  apply map_neBot (m := f) (hf := h) |>.mono\n  rw [Filter.map_inf hf2]\n  gcongr\n  apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hf1.continuousWithinAt\n  simpa [hf2.eq_iff] using eventually_mem_nhdsWithin\n\n"}
{"name":"mem_derivedSet","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nA : Set X\nx : X\nâŠ¢ Iff (Membership.mem (derivedSet A) x) (AccPt x (Filter.principal A))","decl":"@[simp]\nlemma mem_derivedSet {A : Set X} {x : X} : x âˆˆ derivedSet A â†” AccPt x (ğ“Ÿ A) := Iff.rfl\n\n"}
{"name":"derivedSet_union","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nA B : Set X\nâŠ¢ Eq (derivedSet (Union.union A B)) (Union.union (derivedSet A) (derivedSet B))","decl":"lemma derivedSet_union (A B : Set X) : derivedSet (A âˆª B) = derivedSet A âˆª derivedSet B := by\n  ext x\n  simp [derivedSet, â† sup_principal, accPt_sup]\n\n"}
{"name":"derivedSet_mono","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nA B : Set X\nh : HasSubset.Subset A B\nâŠ¢ HasSubset.Subset (derivedSet A) (derivedSet B)","decl":"lemma derivedSet_mono (A B : Set X) (h : A âŠ† B) : derivedSet A âŠ† derivedSet B :=\n  fun _ hx â†¦ hx.mono <| le_principal_iff.mpr <| mem_principal.mpr h\n\n"}
{"name":"Continuous.image_derivedSet","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\nÎ² : Type u_2\ninstâœ : TopologicalSpace Î²\nA : Set X\nf : X â†’ Î²\nhf1 : Continuous f\nhf2 : Function.Injective f\nâŠ¢ HasSubset.Subset (Set.image f (derivedSet A)) (derivedSet (Set.image f A))","decl":"theorem Continuous.image_derivedSet {Î² : Type*} [TopologicalSpace Î²] {A : Set X} {f : X â†’ Î²}\n    (hf1 : Continuous f) (hf2 : Function.Injective f) :\n    f '' derivedSet A âŠ† derivedSet (f '' A) := by\n  intro x hx\n  simp only [Set.mem_image, mem_derivedSet] at hx\n  obtain âŸ¨y, hy1, rflâŸ© := hx\n  convert hy1.map hf1.continuousAt hf2\n  simp\n\n"}
{"name":"derivedSet_subset_closure","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nA : Set X\nâŠ¢ HasSubset.Subset (derivedSet A) (closure A)","decl":"lemma derivedSet_subset_closure (A : Set X) : derivedSet A âŠ† closure A :=\n  fun _ hx â†¦ mem_closure_iff_clusterPt.mpr hx.clusterPt\n\n"}
{"name":"isClosed_iff_derivedSet_subset","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nA : Set X\nâŠ¢ Iff (IsClosed A) (HasSubset.Subset (derivedSet A) A)","decl":"lemma isClosed_iff_derivedSet_subset (A : Set X) : IsClosed A â†” derivedSet A âŠ† A where\n  mp h := derivedSet_subset_closure A |>.trans h.closure_subset\n  mpr h := by\n    rw [isClosed_iff_clusterPt]\n    intro a ha\n    by_contra! nh\n    have : A = A \\ {a} := by simp [nh]\n    rw [this, â† acc_principal_iff_cluster] at ha\n    exact nh (h ha)\n\n"}
{"name":"derivedSet_closure","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T1Space X\nA : Set X\nâŠ¢ Eq (derivedSet (closure A)) (derivedSet A)","decl":"/-- In a `T1Space`, the `derivedSet` of the closure of a set is equal to the derived set of the\nset itself.\n\nNote: this doesn't hold in a space with the indiscrete topology. For example, if `X` is a type with\ntwo elements, `x` and `y`, and `A := {x}`, then `closure A = Set.univ` and `derivedSet A = {y}`,\nbut `derivedSet Set.univ = Set.univ`. -/\nlemma derivedSet_closure [T1Space X] (A : Set X) : derivedSet (closure A) = derivedSet A := by\n  refine le_antisymm (fun x hx => ?_) (derivedSet_mono _ _ subset_closure)\n  rw [mem_derivedSet, AccPt, (nhdsWithin_basis_open x {x}á¶œ).inf_principal_neBot_iff] at hx âŠ¢\n  peel hx with u hu _\n  obtain âŸ¨-, hu_openâŸ© := hu\n  exact mem_closure_iff.mp this.some_mem.2 (u âˆ© {x}á¶œ) (hu_open.inter isOpen_compl_singleton)\n    this.some_mem.1\n\n"}
{"name":"isClosed_derivedSet","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T1Space X\nA : Set X\nâŠ¢ IsClosed (derivedSet A)","decl":"@[simp]\nlemma isClosed_derivedSet [T1Space X] (A : Set X) : IsClosed (derivedSet A) := by\n  rw [â† derivedSet_closure, isClosed_iff_derivedSet_subset]\n  apply derivedSet_mono\n  simp [â† isClosed_iff_derivedSet_subset]\n\n"}
{"name":"preperfect_iff_subset_derivedSet","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nU : Set X\nâŠ¢ Iff (Preperfect U) (HasSubset.Subset U (derivedSet U))","decl":"lemma preperfect_iff_subset_derivedSet {U : Set X} : Preperfect U â†” U âŠ† derivedSet U :=\n  Iff.rfl\n\n"}
{"name":"perfect_iff_eq_derivedSet","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nU : Set X\nâŠ¢ Iff (Perfect U) (Eq U (derivedSet U))","decl":"lemma perfect_iff_eq_derivedSet {U : Set X} : Perfect U â†” U = derivedSet U := by\n  rw [perfect_def, isClosed_iff_derivedSet_subset, preperfect_iff_subset_derivedSet,\n    â† subset_antisymm_iff, eq_comm]\n\n"}
{"name":"IsPreconnected.inter_derivedSet_nonempty","module":"Mathlib.Topology.DerivedSet","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : T1Space X\nU : Set X\nhs : IsPreconnected U\na b : Set X\nh : HasSubset.Subset U (Union.union a b)\nha : (Inter.inter U (derivedSet a)).Nonempty\nhb : (Inter.inter U (derivedSet b)).Nonempty\nâŠ¢ (Inter.inter U (Inter.inter (derivedSet a) (derivedSet b))).Nonempty","decl":"lemma IsPreconnected.inter_derivedSet_nonempty [T1Space X] {U : Set X} (hs : IsPreconnected U)\n    (a b : Set X) (h : U âŠ† a âˆª b) (ha : (U âˆ© derivedSet a).Nonempty)\n    (hb : (U âˆ© derivedSet b).Nonempty) : (U âˆ© (derivedSet a âˆ© derivedSet b)).Nonempty := by\n  by_cases hu : U.Nontrivial\n  Â· apply isPreconnected_closed_iff.mp hs\n    Â· simp\n    Â· simp\n    Â· trans derivedSet U\n      Â· apply hs.preperfect_of_nontrivial hu\n      Â· rw [â† derivedSet_union]\n        exact derivedSet_mono _ _ h\n    Â· exact ha\n    Â· exact hb\n  Â· obtain âŸ¨x, hxâŸ© := ha.left.exists_eq_singleton_or_nontrivial.resolve_right hu\n    simp_all\n"}
