{"name":"RingHom.isIntegral_stableUnderComposition","module":"Mathlib.RingTheory.RingHom.Integral","initialProofState":"⊢ RingHom.StableUnderComposition fun {R S} [CommRing R] [CommRing S] f => f.IsIntegral","decl":"theorem isIntegral_stableUnderComposition : StableUnderComposition fun f => f.IsIntegral := by\n  introv R hf hg; exact hf.trans _ _ hg\n\n"}
{"name":"RingHom.isIntegral_respectsIso","module":"Mathlib.RingTheory.RingHom.Integral","initialProofState":"⊢ RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] f => f.IsIntegral","decl":"theorem isIntegral_respectsIso : RespectsIso fun f => f.IsIntegral := by\n  apply isIntegral_stableUnderComposition.respectsIso\n  introv x\n  rw [← e.apply_symm_apply x]\n  apply RingHom.isIntegralElem_map\n\n"}
{"name":"RingHom.isIntegral_isStableUnderBaseChange","module":"Mathlib.RingTheory.RingHom.Integral","initialProofState":"⊢ RingHom.IsStableUnderBaseChange fun {R S} [CommRing R] [CommRing S] f => f.IsIntegral","decl":"theorem isIntegral_isStableUnderBaseChange : IsStableUnderBaseChange fun f => f.IsIntegral := by\n  refine IsStableUnderBaseChange.mk _ isIntegral_respectsIso ?_\n  introv h x\n  refine TensorProduct.induction_on x ?_ ?_ ?_\n  · apply isIntegral_zero\n  · intro x y; exact IsIntegral.tmul x (h y)\n  · intro x y hx hy; exact IsIntegral.add hx hy\n\n"}
{"name":"RingHom.isIntegral_ofLocalizationSpan","module":"Mathlib.RingTheory.RingHom.Integral","initialProofState":"⊢ RingHom.OfLocalizationSpan fun {R S} [CommRing R] [CommRing S] x => x.IsIntegral","decl":"open Polynomial in\n/-- `S` is an integral `R`-algebra if there exists a set `{ r }` that\n  spans `R` such that each `Sᵣ` is an integral `Rᵣ`-algebra. -/\ntheorem isIntegral_ofLocalizationSpan :\n    OfLocalizationSpan (RingHom.IsIntegral ·) := by\n  introv R hs H r\n  letI := f.toAlgebra\n  show r ∈ (integralClosure R S).toSubmodule\n  apply Submodule.mem_of_span_eq_top_of_smul_pow_mem _ s hs\n  rintro ⟨t, ht⟩\n  letI := (Localization.awayMap f t).toAlgebra\n  haveI : IsScalarTower R (Localization.Away t) (Localization.Away (f t)) := .of_algebraMap_eq'\n    (IsLocalization.lift_comp _).symm\n  have : _root_.IsIntegral (Localization.Away t) (algebraMap S (Localization.Away (f t)) r) :=\n    H ⟨t, ht⟩ (algebraMap _ _ r)\n  obtain ⟨⟨_, n, rfl⟩, p, hp, hp'⟩ := this.exists_multiple_integral_of_isLocalization (.powers t)\n  rw [IsScalarTower.algebraMap_eq R S, Submonoid.smul_def, Algebra.smul_def,\n    IsScalarTower.algebraMap_apply R S, ← map_mul, ← hom_eval₂,\n    IsLocalization.map_eq_zero_iff (.powers (f t))] at hp'\n  obtain ⟨⟨x, m, (rfl : algebraMap R S t ^ m = x)⟩, e⟩ := hp'\n  by_cases hp' : 1 ≤ p.natDegree; swap\n  · obtain rfl : p = 1 := eq_one_of_monic_natDegree_zero hp (by omega)\n    exact ⟨m, by simp [Algebra.smul_def, show algebraMap R S t ^ m = 0 by simpa using e]⟩\n  refine ⟨m + n, p.scaleRoots (t ^ m), (monic_scaleRoots_iff _).mpr hp, ?_⟩\n  have := p.scaleRoots_eval₂_mul (algebraMap R S) (t ^ n • r) (t ^ m)\n  simp only [pow_add, ← Algebra.smul_def, mul_smul, ← map_pow] at e this ⊢\n  rw [this, ← tsub_add_cancel_of_le hp', pow_succ, mul_smul, e, smul_zero]\n\n"}
