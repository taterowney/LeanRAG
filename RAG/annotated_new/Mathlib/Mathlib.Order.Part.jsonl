{"name":"Monotone.partBind","module":"Mathlib.Order.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Preorder α\nf : α → Part β\ng : α → β → Part γ\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone fun x => (f x).bind (g x)","decl":"lemma Monotone.partBind (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x ↦ (f x).bind (g x) := by\n  rintro x y h a\n  simp only [and_imp, exists_prop, Part.bind_eq_bind, Part.mem_bind_iff, exists_imp]\n  exact fun b hb ha ↦ ⟨b, hf h _ hb, hg h _ _ ha⟩\n\n"}
{"name":"Antitone.partBind","module":"Mathlib.Order.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Preorder α\nf : α → Part β\ng : α → β → Part γ\nhf : Antitone f\nhg : Antitone g\n⊢ Antitone fun x => (f x).bind (g x)","decl":"lemma Antitone.partBind (hf : Antitone f) (hg : Antitone g) :\n    Antitone fun x ↦ (f x).bind (g x) := by\n  rintro x y h a\n  simp only [and_imp, exists_prop, Part.bind_eq_bind, Part.mem_bind_iff, exists_imp]\n  exact fun b hb ha ↦ ⟨b, hf h _ hb, hg h _ _ ha⟩\n\n"}
{"name":"Monotone.partMap","module":"Mathlib.Order.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Preorder α\nf : β → γ\ng : α → Part β\nhg : Monotone g\n⊢ Monotone fun x => Part.map f (g x)","decl":"lemma Monotone.partMap (hg : Monotone g) : Monotone fun x ↦ (g x).map f := by\n  simpa only [← bind_some_eq_map] using hg.partBind monotone_const\n\n"}
{"name":"Antitone.partMap","module":"Mathlib.Order.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Preorder α\nf : β → γ\ng : α → Part β\nhg : Antitone g\n⊢ Antitone fun x => Part.map f (g x)","decl":"lemma Antitone.partMap (hg : Antitone g) : Antitone fun x ↦ (g x).map f := by\n  simpa only [← bind_some_eq_map] using hg.partBind antitone_const\n\n"}
{"name":"Monotone.partSeq","module":"Mathlib.Order.Part","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nβ γ : Type u_4\nf : α → Part (β → γ)\ng : α → Part β\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone fun x => Seq.seq (f x) fun x_1 => g x","decl":"lemma Monotone.partSeq (hf : Monotone f) (hg : Monotone g) : Monotone fun x ↦ f x <*> g x := by\n  simpa only [seq_eq_bind_map] using hf.partBind <| Monotone.of_apply₂ fun _ ↦ hg.partMap\n\n"}
{"name":"Antitone.partSeq","module":"Mathlib.Order.Part","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nβ γ : Type u_4\nf : α → Part (β → γ)\ng : α → Part β\nhf : Antitone f\nhg : Antitone g\n⊢ Antitone fun x => Seq.seq (f x) fun x_1 => g x","decl":"lemma Antitone.partSeq (hf : Antitone f) (hg : Antitone g) : Antitone fun x ↦ f x <*> g x := by\n  simpa only [seq_eq_bind_map] using hf.partBind <| Antitone.of_apply₂ fun _ ↦ hg.partMap\n\n"}
{"name":"OrderHom.partBind_coe","module":"Mathlib.Order.Part","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Preorder α\nf : OrderHom α (Part β)\ng : OrderHom α (β → Part γ)\nx : α\n⊢ Eq ((f.partBind g) x) ((f x).bind (g x))","decl":"/-- `Part.bind` as a monotone function -/\n@[simps]\ndef partBind (f : α →o Part β) (g : α →o β → Part γ) : α →o Part γ where\n  toFun x := (f x).bind (g x)\n  monotone' := f.2.partBind g.2\n\n"}
