{"name":"CategoryTheory.Limits.Fan.mk_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : β → C\nP : C\np : (b : β) → Quiver.Hom P (f b)\n⊢ Eq (CategoryTheory.Limits.Fan.mk P p).pt P","decl":"/-- A fan over `f : β → C` consists of a collection of maps from an object `P` to every `f b`. -/\n@[simps! pt π_app]\ndef Fan.mk {f : β → C} (P : C) (p : ∀ b, P ⟶ f b) : Fan f where\n  pt := P\n  π := Discrete.natTrans (fun X => p X.as)\n\n"}
{"name":"CategoryTheory.Limits.Fan.mk_π_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : β → C\nP : C\np : (b : β) → Quiver.Hom P (f b)\nX : CategoryTheory.Discrete β\n⊢ Eq ((CategoryTheory.Limits.Fan.mk P p).π.app X) (p X.as)","decl":"/-- A fan over `f : β → C` consists of a collection of maps from an object `P` to every `f b`. -/\n@[simps! pt π_app]\ndef Fan.mk {f : β → C} (P : C) (p : ∀ b, P ⟶ f b) : Fan f where\n  pt := P\n  π := Discrete.natTrans (fun X => p X.as)\n\n"}
{"name":"CategoryTheory.Limits.Cofan.mk_ι_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : β → C\nP : C\np : (b : β) → Quiver.Hom (f b) P\nX : CategoryTheory.Discrete β\n⊢ Eq ((CategoryTheory.Limits.Cofan.mk P p).ι.app X) (p X.as)","decl":"/-- A cofan over `f : β → C` consists of a collection of maps from every `f b` to an object `P`. -/\n@[simps! pt ι_app]\ndef Cofan.mk {f : β → C} (P : C) (p : ∀ b, f b ⟶ P) : Cofan f where\n  pt := P\n  ι := Discrete.natTrans (fun X => p X.as)\n\n"}
{"name":"CategoryTheory.Limits.Cofan.mk_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : β → C\nP : C\np : (b : β) → Quiver.Hom (f b) P\n⊢ Eq (CategoryTheory.Limits.Cofan.mk P p).pt P","decl":"/-- A cofan over `f : β → C` consists of a collection of maps from every `f b` to an object `P`. -/\n@[simps! pt ι_app]\ndef Cofan.mk {f : β → C} (P : C) (p : ∀ b, f b ⟶ P) : Cofan f where\n  pt := P\n  ι := Discrete.natTrans (fun X => p X.as)\n\n"}
{"name":"CategoryTheory.Limits.fan_mk_proj","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : β → C\nP : C\np : (b : β) → Quiver.Hom P (f b)\nj : β\n⊢ Eq ((CategoryTheory.Limits.Fan.mk P p).proj j) (p j)","decl":"@[simp]\ntheorem fan_mk_proj {f : β → C} (P : C) (p : ∀ b, P ⟶ f b) (j : β) : (Fan.mk P p).proj j = p j :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.cofan_mk_inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : β → C\nP : C\np : (b : β) → Quiver.Hom (f b) P\nj : β\n⊢ Eq ((CategoryTheory.Limits.Cofan.mk P p).inj j) (p j)","decl":"@[simp]\ntheorem cofan_mk_inj {f : β → C} (P : C) (p : ∀ b, f b ⟶ P) (j : β) :\n    (Cofan.mk P p).inj j = p j :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.hasCoproduct_of_equiv_of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : α → C\ng : β → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\ne : Equiv β α\niso : (j : β) → CategoryTheory.Iso (g j) (f (e j))\n⊢ CategoryTheory.Limits.HasCoproduct g","decl":"lemma hasCoproduct_of_equiv_of_iso (f : α → C) (g : β → C)\n    [HasCoproduct f] (e : β ≃ α) (iso : ∀ j, g j ≅ f (e j)) : HasCoproduct g := by\n  have : HasColimit ((Discrete.equivalence e).functor ⋙ Discrete.functor f) :=\n    hasColimit_equivalence_comp _\n  have α : Discrete.functor g ≅ (Discrete.equivalence e).functor ⋙ Discrete.functor f :=\n    Discrete.natIso (fun ⟨j⟩ => iso j)\n  exact hasColimitOfIso α\n\n"}
{"name":"CategoryTheory.Limits.hasProduct_of_equiv_of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : α → C\ng : β → C\ninst✝ : CategoryTheory.Limits.HasProduct f\ne : Equiv β α\niso : (j : β) → CategoryTheory.Iso (g j) (f (e j))\n⊢ CategoryTheory.Limits.HasProduct g","decl":"lemma hasProduct_of_equiv_of_iso (f : α → C) (g : β → C)\n    [HasProduct f] (e : β ≃ α) (iso : ∀ j, g j ≅ f (e j)) : HasProduct g := by\n  have : HasLimit ((Discrete.equivalence e).functor ⋙ Discrete.functor f) :=\n    hasLimitEquivalenceComp _\n  have α : Discrete.functor g ≅ (Discrete.equivalence e).functor ⋙ Discrete.functor f :=\n    Discrete.natIso (fun ⟨j⟩ => iso j)\n  exact hasLimitOfIso α.symm\n\n"}
{"name":"CategoryTheory.Limits.mkFanLimit_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : β → C\nt : CategoryTheory.Limits.Fan f\nlift : (s : CategoryTheory.Limits.Fan f) → Quiver.Hom s.pt t.pt\nfac : autoParam (∀ (s : CategoryTheory.Limits.Fan f) (j : β), Eq (CategoryTheory.CategoryStruct.comp (lift s) (t.proj j)) (s.proj j)) _auto✝\nuniq : autoParam (∀ (s : CategoryTheory.Limits.Fan f) (m : Quiver.Hom s.pt t.pt), (∀ (j : β), Eq (CategoryTheory.CategoryStruct.comp m (t.proj j)) (s.proj j)) → Eq m (lift s)) _auto✝\ns : CategoryTheory.Limits.Fan f\n⊢ Eq ((CategoryTheory.Limits.mkFanLimit t lift fac uniq).lift s) (lift s)","decl":"/-- Make a fan `f` into a limit fan by providing `lift`, `fac`, and `uniq` --\n  just a convenience lemma to avoid having to go through `Discrete` -/\n@[simps]\ndef mkFanLimit {f : β → C} (t : Fan f) (lift : ∀ s : Fan f, s.pt ⟶ t.pt)\n    (fac : ∀ (s : Fan f) (j : β), lift s ≫ t.proj j = s.proj j := by aesop_cat)\n    (uniq : ∀ (s : Fan f) (m : s.pt ⟶ t.pt) (_ : ∀ j : β, m ≫ t.proj j = s.proj j),\n      m = lift s := by aesop_cat) :\n    IsLimit t :=\n  { lift }\n\n"}
{"name":"CategoryTheory.Limits.Fan.IsLimit.fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : β → C\nc : CategoryTheory.Limits.Fan F\nhc : CategoryTheory.Limits.IsLimit c\nA : C\nf : (i : β) → Quiver.Hom A (F i)\ni : β\nZ : C\nh : Quiver.Hom (F i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fan.IsLimit.desc hc f) (CategoryTheory.CategoryStruct.comp (c.proj i) h)) (CategoryTheory.CategoryStruct.comp (f i) h)","decl":"@[reassoc (attr := simp)]\nlemma Fan.IsLimit.fac {F : β → C} {c : Fan F} (hc : IsLimit c) {A : C}\n    (f : ∀ i, A ⟶ F i) (i : β) :\n    Fan.IsLimit.desc hc f ≫ c.proj i = f i :=\n  hc.fac (Fan.mk A f) ⟨i⟩\n\n"}
{"name":"CategoryTheory.Limits.Fan.IsLimit.fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : β → C\nc : CategoryTheory.Limits.Fan F\nhc : CategoryTheory.Limits.IsLimit c\nA : C\nf : (i : β) → Quiver.Hom A (F i)\ni : β\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fan.IsLimit.desc hc f) (c.proj i)) (f i)","decl":"@[reassoc (attr := simp)]\nlemma Fan.IsLimit.fac {F : β → C} {c : Fan F} (hc : IsLimit c) {A : C}\n    (f : ∀ i, A ⟶ F i) (i : β) :\n    Fan.IsLimit.desc hc f ≫ c.proj i = f i :=\n  hc.fac (Fan.mk A f) ⟨i⟩\n\n"}
{"name":"CategoryTheory.Limits.Fan.IsLimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : Type u_1\nF : I → C\nc : CategoryTheory.Limits.Fan F\nhc : CategoryTheory.Limits.IsLimit c\nA : C\nf g : Quiver.Hom A c.pt\nh : ∀ (i : I), Eq (CategoryTheory.CategoryStruct.comp f (c.proj i)) (CategoryTheory.CategoryStruct.comp g (c.proj i))\n⊢ Eq f g","decl":"lemma Fan.IsLimit.hom_ext {I : Type*} {F : I → C} {c : Fan F} (hc : IsLimit c) {A : C}\n    (f g : A ⟶ c.pt) (h : ∀ i, f ≫ c.proj i = g ≫ c.proj i) : f = g :=\n  hc.hom_ext (fun ⟨i⟩ => h i)\n\n"}
{"name":"CategoryTheory.Limits.mkCofanColimit_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : β → C\ns : CategoryTheory.Limits.Cofan f\ndesc : (t : CategoryTheory.Limits.Cofan f) → Quiver.Hom s.pt t.pt\nfac : autoParam (∀ (t : CategoryTheory.Limits.Cofan f) (j : β), Eq (CategoryTheory.CategoryStruct.comp (s.inj j) (desc t)) (t.inj j)) _auto✝\nuniq : autoParam (∀ (t : CategoryTheory.Limits.Cofan f) (m : Quiver.Hom s.pt t.pt), (∀ (j : β), Eq (CategoryTheory.CategoryStruct.comp (s.inj j) m) (t.inj j)) → Eq m (desc t)) _auto✝\nt : CategoryTheory.Limits.Cofan f\n⊢ Eq ((CategoryTheory.Limits.mkCofanColimit s desc fac uniq).desc t) (desc t)","decl":"/-- Make a cofan `f` into a colimit cofan by providing `desc`, `fac`, and `uniq` --\n  just a convenience lemma to avoid having to go through `Discrete` -/\n@[simps]\ndef mkCofanColimit {f : β → C} (s : Cofan f) (desc : ∀ t : Cofan f, s.pt ⟶ t.pt)\n    (fac : ∀ (t : Cofan f) (j : β), s.inj j ≫ desc t = t.inj j := by aesop_cat)\n    (uniq : ∀ (t : Cofan f) (m : s.pt ⟶ t.pt) (_ : ∀ j : β, s.inj j ≫ m = t.inj j),\n      m = desc t := by aesop_cat) :\n    IsColimit s :=\n  { desc }\n\n"}
{"name":"CategoryTheory.Limits.Cofan.IsColimit.fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : β → C\nc : CategoryTheory.Limits.Cofan F\nhc : CategoryTheory.Limits.IsColimit c\nA : C\nf : (i : β) → Quiver.Hom (F i) A\ni : β\n⊢ Eq (CategoryTheory.CategoryStruct.comp (c.inj i) (CategoryTheory.Limits.Cofan.IsColimit.desc hc f)) (f i)","decl":"@[reassoc (attr := simp)]\nlemma Cofan.IsColimit.fac {F : β → C} {c : Cofan F} (hc : IsColimit c) {A : C}\n    (f : ∀ i, F i ⟶ A) (i : β) :\n    c.inj i ≫ Cofan.IsColimit.desc hc f = f i :=\n  hc.fac (Cofan.mk A f) ⟨i⟩\n\n"}
{"name":"CategoryTheory.Limits.Cofan.IsColimit.fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : β → C\nc : CategoryTheory.Limits.Cofan F\nhc : CategoryTheory.Limits.IsColimit c\nA : C\nf : (i : β) → Quiver.Hom (F i) A\ni : β\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (c.inj i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofan.IsColimit.desc hc f) h)) (CategoryTheory.CategoryStruct.comp (f i) h)","decl":"@[reassoc (attr := simp)]\nlemma Cofan.IsColimit.fac {F : β → C} {c : Cofan F} (hc : IsColimit c) {A : C}\n    (f : ∀ i, F i ⟶ A) (i : β) :\n    c.inj i ≫ Cofan.IsColimit.desc hc f = f i :=\n  hc.fac (Cofan.mk A f) ⟨i⟩\n\n"}
{"name":"CategoryTheory.Limits.Cofan.IsColimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : Type u_1\nF : I → C\nc : CategoryTheory.Limits.Cofan F\nhc : CategoryTheory.Limits.IsColimit c\nA : C\nf g : Quiver.Hom c.pt A\nh : ∀ (i : I), Eq (CategoryTheory.CategoryStruct.comp (c.inj i) f) (CategoryTheory.CategoryStruct.comp (c.inj i) g)\n⊢ Eq f g","decl":"lemma Cofan.IsColimit.hom_ext {I : Type*} {F : I → C} {c : Cofan F} (hc : IsColimit c) {A : C}\n    (f g : c.pt ⟶ A) (h : ∀ i, c.inj i ≫ f = c.inj i ≫ g) : f = g :=\n  hc.hom_ext (fun ⟨i⟩ => h i)\n\n"}
{"name":"CategoryTheory.Limits.Pi.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : β → C\ninst✝ : CategoryTheory.Limits.HasProduct f\nX : C\ng₁ g₂ : Quiver.Hom X (CategoryTheory.Limits.piObj f)\n⊢ Iff (Eq g₁ g₂) (∀ (b : β), Eq (CategoryTheory.CategoryStruct.comp g₁ (CategoryTheory.Limits.Pi.π f b)) (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.Pi.π f b)))","decl":"@[ext 1050]\nlemma Pi.hom_ext {f : β → C} [HasProduct f] {X : C} (g₁ g₂ : X ⟶ ∏ᶜ f)\n    (h : ∀ (b : β), g₁ ≫ Pi.π f b = g₂ ≫ Pi.π f b) : g₁ = g₂ :=\n  limit.hom_ext (fun ⟨j⟩ => h j)\n\n"}
{"name":"CategoryTheory.Limits.Pi.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : β → C\ninst✝ : CategoryTheory.Limits.HasProduct f\nX : C\ng₁ g₂ : Quiver.Hom X (CategoryTheory.Limits.piObj f)\nh : ∀ (b : β), Eq (CategoryTheory.CategoryStruct.comp g₁ (CategoryTheory.Limits.Pi.π f b)) (CategoryTheory.CategoryStruct.comp g₂ (CategoryTheory.Limits.Pi.π f b))\n⊢ Eq g₁ g₂","decl":"@[ext 1050]\nlemma Pi.hom_ext {f : β → C} [HasProduct f] {X : C} (g₁ g₂ : X ⟶ ∏ᶜ f)\n    (h : ∀ (b : β), g₁ ≫ Pi.π f b = g₂ ≫ Pi.π f b) : g₁ = g₂ :=\n  limit.hom_ext (fun ⟨j⟩ => h j)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : β → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\nX : C\ng₁ g₂ : Quiver.Hom (CategoryTheory.Limits.sigmaObj f) X\nh : ∀ (b : β), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f b) g₁) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f b) g₂)\n⊢ Eq g₁ g₂","decl":"@[ext 1050]\nlemma Sigma.hom_ext {f : β → C} [HasCoproduct f] {X : C} (g₁ g₂ : ∐ f ⟶ X)\n    (h : ∀ (b : β), Sigma.ι f b ≫ g₁ = Sigma.ι f b ≫ g₂) : g₁ = g₂ :=\n  colimit.hom_ext (fun ⟨j⟩ => h j)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : β → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\nX : C\ng₁ g₂ : Quiver.Hom (CategoryTheory.Limits.sigmaObj f) X\n⊢ Iff (Eq g₁ g₂) (∀ (b : β), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f b) g₁) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f b) g₂))","decl":"@[ext 1050]\nlemma Sigma.hom_ext {f : β → C} [HasCoproduct f] {X : C} (g₁ g₂ : ∐ f ⟶ X)\n    (h : ∀ (b : β), Sigma.ι f b ≫ g₁ = Sigma.ι f b ≫ g₂) : g₁ = g₂ :=\n  colimit.hom_ext (fun ⟨j⟩ => h j)\n\n"}
{"name":"CategoryTheory.Limits.Pi.π_comp_eqToHom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nf : J → C\ninst✝ : CategoryTheory.Limits.HasProduct f\nj j' : J\nw : Eq j j'\nZ : C\nh : Quiver.Hom (f j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π f j') h)","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem Pi.π_comp_eqToHom {J : Type*} (f : J → C) [HasProduct f] {j j' : J} (w : j = j') :\n    Pi.π f j ≫ eqToHom (by simp [w]) = Pi.π f j' := by\n  cases w\n  simp\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `Sigma.whiskerEquiv` below.\n"}
{"name":"CategoryTheory.Limits.Pi.π_comp_eqToHom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nf : J → C\ninst✝ : CategoryTheory.Limits.HasProduct f\nj j' : J\nw : Eq j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π f j) (CategoryTheory.eqToHom ⋯)) (CategoryTheory.Limits.Pi.π f j')","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem Pi.π_comp_eqToHom {J : Type*} (f : J → C) [HasProduct f] {j j' : J} (w : j = j') :\n    Pi.π f j ≫ eqToHom (by simp [w]) = Pi.π f j' := by\n  cases w\n  simp\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `Sigma.whiskerEquiv` below.\n"}
{"name":"CategoryTheory.Limits.Sigma.eqToHom_comp_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nf : J → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\nj j' : J\nw : Eq j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.Limits.Sigma.ι f j')) (CategoryTheory.Limits.Sigma.ι f j)","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem Sigma.eqToHom_comp_ι {J : Type*} (f : J → C) [HasCoproduct f] {j j' : J} (w : j = j') :\n    eqToHom (by simp [w]) ≫ Sigma.ι f j' = Sigma.ι f j := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.eqToHom_comp_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nf : J → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\nj j' : J\nw : Eq j j'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f j') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f j) h)","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem Sigma.eqToHom_comp_ι {J : Type*} (f : J → C) [HasCoproduct f] {j j' : J} (w : j = j') :\n    eqToHom (by simp [w]) ≫ Sigma.ι f j' = Sigma.ι f j := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.lift_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nβ : Type w\nf : β → C\ninst✝ : CategoryTheory.Limits.HasProduct f\nP : C\np : (b : β) → Quiver.Hom P (f b)\nb : β\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift p) (CategoryTheory.Limits.Pi.π f b)) (p b)","decl":"theorem Pi.lift_π {β : Type w} {f : β → C} [HasProduct f] {P : C} (p : ∀ b, P ⟶ f b) (b : β) :\n    Pi.lift p ≫ Pi.π f b = p b := by\n  simp only [limit.lift_π, Fan.mk_pt, Fan.mk_π_app]\n\n"}
{"name":"CategoryTheory.Limits.Fan.ext_inv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : β → C\nc₁ c₂ : CategoryTheory.Limits.Fan f\ne : CategoryTheory.Iso c₁.pt c₂.pt\nw : autoParam (∀ (b : β), Eq (c₁.proj b) (CategoryTheory.CategoryStruct.comp e.hom (c₂.proj b))) _auto✝\n⊢ Eq (CategoryTheory.Limits.Fan.ext e w).inv.hom e.inv","decl":"/-- A version of `Cones.ext` for `Fan`s. -/\n@[simps!]\ndef Fan.ext {f : β → C} {c₁ c₂ : Fan f} (e : c₁.pt ≅ c₂.pt)\n    (w : ∀ (b : β), c₁.proj b = e.hom ≫ c₂.proj b := by aesop_cat) : c₁ ≅ c₂ :=\n  Cones.ext e (fun ⟨j⟩ => w j)\n\n"}
{"name":"CategoryTheory.Limits.Fan.ext_hom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : β → C\nc₁ c₂ : CategoryTheory.Limits.Fan f\ne : CategoryTheory.Iso c₁.pt c₂.pt\nw : autoParam (∀ (b : β), Eq (c₁.proj b) (CategoryTheory.CategoryStruct.comp e.hom (c₂.proj b))) _auto✝\n⊢ Eq (CategoryTheory.Limits.Fan.ext e w).hom.hom e.hom","decl":"/-- A version of `Cones.ext` for `Fan`s. -/\n@[simps!]\ndef Fan.ext {f : β → C} {c₁ c₂ : Fan f} (e : c₁.pt ≅ c₂.pt)\n    (w : ∀ (b : β), c₁.proj b = e.hom ≫ c₂.proj b := by aesop_cat) : c₁ ≅ c₂ :=\n  Cones.ext e (fun ⟨j⟩ => w j)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.ι_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nβ : Type w\nf : β → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\nP : C\np : (b : β) → Quiver.Hom (f b) P\nb : β\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f b) (CategoryTheory.Limits.Sigma.desc p)) (p b)","decl":"theorem Sigma.ι_desc {β : Type w} {f : β → C} [HasCoproduct f] {P : C} (p : ∀ b, f b ⟶ P) (b : β) :\n    Sigma.ι f b ≫ Sigma.desc p = p b := by\n  simp only [colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app]\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoDescι","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : β → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.Sigma.desc fun a => CategoryTheory.Limits.Sigma.ι f a)","decl":"instance {f : β → C} [HasCoproduct f] : IsIso (Sigma.desc (fun a ↦ Sigma.ι f a)) := by\n  convert IsIso.id _\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Cofan.ext_hom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : β → C\nc₁ c₂ : CategoryTheory.Limits.Cofan f\ne : CategoryTheory.Iso c₁.pt c₂.pt\nw : autoParam (∀ (b : β), Eq (CategoryTheory.CategoryStruct.comp (c₁.inj b) e.hom) (c₂.inj b)) _auto✝\n⊢ Eq (CategoryTheory.Limits.Cofan.ext e w).hom.hom e.hom","decl":"/-- A version of `Cocones.ext` for `Cofan`s. -/\n@[simps!]\ndef Cofan.ext {f : β → C} {c₁ c₂ : Cofan f} (e : c₁.pt ≅ c₂.pt)\n    (w : ∀ (b : β), c₁.inj b ≫ e.hom = c₂.inj b := by aesop_cat) : c₁ ≅ c₂ :=\n  Cocones.ext e (fun ⟨j⟩ => w j)\n\n"}
{"name":"CategoryTheory.Limits.Cofan.ext_inv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nf : β → C\nc₁ c₂ : CategoryTheory.Limits.Cofan f\ne : CategoryTheory.Iso c₁.pt c₂.pt\nw : autoParam (∀ (b : β), Eq (CategoryTheory.CategoryStruct.comp (c₁.inj b) e.hom) (c₂.inj b)) _auto✝\n⊢ Eq (CategoryTheory.Limits.Cofan.ext e w).inv.hom e.inv","decl":"/-- A version of `Cocones.ext` for `Cofan`s. -/\n@[simps!]\ndef Cofan.ext {f : β → C} {c₁ c₂ : Cofan f} (e : c₁.pt ≅ c₂.pt)\n    (w : ∀ (b : β), c₁.inj b ≫ e.hom = c₂.inj b := by aesop_cat) : c₁ ≅ c₂ :=\n  Cocones.ext e (fun ⟨j⟩ => w j)\n\n"}
{"name":"CategoryTheory.Limits.Cofan.isColimit_iff_isIso_sigmaDesc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : β → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\nc : CategoryTheory.Limits.Cofan f\n⊢ Iff (CategoryTheory.IsIso (CategoryTheory.Limits.Sigma.desc c.inj)) (Nonempty (CategoryTheory.Limits.IsColimit c))","decl":"lemma Cofan.isColimit_iff_isIso_sigmaDesc {f : β → C} [HasCoproduct f] (c : Cofan f) :\n    IsIso (Sigma.desc c.inj) ↔ Nonempty (IsColimit c) := by\n  refine ⟨fun h ↦ ⟨isColimitOfIsIsoSigmaDesc c⟩, fun ⟨hc⟩ ↦ ?_⟩\n  have : IsIso (((coproductIsCoproduct f).coconePointUniqueUpToIso hc).hom ≫ hc.desc c) := by\n    simp; infer_instance\n  convert this\n  ext\n  simp only [colimit.ι_desc, mk_pt, mk_ι_app, IsColimit.coconePointUniqueUpToIso,\n    coproductIsCoproduct, colimit.cocone_x, Functor.mapIso_hom, IsColimit.uniqueUpToIso_hom,\n    Cocones.forget_map, IsColimit.descCoconeMorphism_hom, IsColimit.ofIsoColimit_desc,\n    Cocones.ext_inv_hom, Iso.refl_inv, colimit.isColimit_desc, Category.id_comp,\n    IsColimit.desc_self, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Pi.map_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : α → C\ninst✝ : CategoryTheory.Limits.HasProduct f\n⊢ Eq (CategoryTheory.Limits.Pi.map fun a => CategoryTheory.CategoryStruct.id (f a)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.piObj f))","decl":"@[simp]\nlemma Pi.map_id {f : α → C} [HasProduct f] : Pi.map (fun a => 𝟙 (f a)) = 𝟙 (∏ᶜ f) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.map_comp_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf g h : α → C\ninst✝² : CategoryTheory.Limits.HasProduct f\ninst✝¹ : CategoryTheory.Limits.HasProduct g\ninst✝ : CategoryTheory.Limits.HasProduct h\nq : (a : α) → Quiver.Hom (f a) (g a)\nq' : (a : α) → Quiver.Hom (g a) (h a)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.map q) (CategoryTheory.Limits.Pi.map q')) (CategoryTheory.Limits.Pi.map fun a => CategoryTheory.CategoryStruct.comp (q a) (q' a))","decl":"lemma Pi.map_comp_map {f g h : α → C} [HasProduct f] [HasProduct g] [HasProduct h]\n    (q : ∀ (a : α), f a ⟶ g a) (q' : ∀ (a : α), g a ⟶ h a) :\n    Pi.map q ≫ Pi.map q' = Pi.map (fun a => q a ≫ q' a) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.map_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf g : β → C\ninst✝² : CategoryTheory.Limits.HasProduct f\ninst✝¹ : CategoryTheory.Limits.HasProduct g\np : (b : β) → Quiver.Hom (f b) (g b)\ninst✝ : ∀ (i : β), CategoryTheory.Mono (p i)\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.Pi.map p)","decl":"instance Pi.map_mono {f g : β → C} [HasProduct f] [HasProduct g] (p : ∀ b, f b ⟶ g b)\n    [∀ i, Mono (p i)] : Mono <| Pi.map p :=\n  @Limits.limMap_mono _ _ _ _ (Discrete.functor f) (Discrete.functor g) _ _\n    (Discrete.natTrans fun X => p X.as) (by dsimp; infer_instance)\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_comp_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf : α → C\ng : β → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct g\np : β → α\nq : (b : β) → Quiver.Hom (f (p b)) (g b)\nb : β\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.map' p q) (CategoryTheory.Limits.Pi.π g b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π f (p b)) (q b))","decl":"@[reassoc (attr := simp)]\nlemma Pi.map'_comp_π {f : α → C} {g : β → C} [HasProduct f] [HasProduct g] (p : β → α)\n    (q : ∀ (b : β), f (p b) ⟶ g b) (b : β) : Pi.map' p q ≫ Pi.π g b = Pi.π f (p b) ≫ q b :=\n  limit.lift_π _ _\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf : α → C\ng : β → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct g\np : β → α\nq : (b : β) → Quiver.Hom (f (p b)) (g b)\nb : β\nZ : C\nh : Quiver.Hom (g b) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.map' p q) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π g b) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π f (p b)) (CategoryTheory.CategoryStruct.comp (q b) h))","decl":"@[reassoc (attr := simp)]\nlemma Pi.map'_comp_π {f : α → C} {g : β → C} [HasProduct f] [HasProduct g] (p : β → α)\n    (q : ∀ (b : β), f (p b) ⟶ g b) (b : β) : Pi.map' p q ≫ Pi.π g b = Pi.π f (p b) ≫ q b :=\n  limit.lift_π _ _\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_id_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : α → C\ninst✝ : CategoryTheory.Limits.HasProduct f\n⊢ Eq (CategoryTheory.Limits.Pi.map' id fun a => CategoryTheory.CategoryStruct.id (f a)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.piObj f))","decl":"lemma Pi.map'_id_id {f : α → C} [HasProduct f] : Pi.map' id (fun a => 𝟙 (f a)) = 𝟙 (∏ᶜ f) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : α → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct g\np : (b : α) → Quiver.Hom (f b) (g b)\n⊢ Eq (CategoryTheory.Limits.Pi.map' id p) (CategoryTheory.Limits.Pi.map p)","decl":"@[simp]\nlemma Pi.map'_id {f g : α → C} [HasProduct f] [HasProduct g] (p : ∀ b, f b ⟶ g b) :\n    Pi.map' id p = Pi.map p :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_comp_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nγ : Type w₃\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf : α → C\ng : β → C\nh : γ → C\ninst✝² : CategoryTheory.Limits.HasProduct f\ninst✝¹ : CategoryTheory.Limits.HasProduct g\ninst✝ : CategoryTheory.Limits.HasProduct h\np : β → α\np' : γ → β\nq : (b : β) → Quiver.Hom (f (p b)) (g b)\nq' : (c : γ) → Quiver.Hom (g (p' c)) (h c)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.map' p q) (CategoryTheory.Limits.Pi.map' p' q')) (CategoryTheory.Limits.Pi.map' (Function.comp p p') fun c => CategoryTheory.CategoryStruct.comp (q (p' c)) (q' c))","decl":"lemma Pi.map'_comp_map' {f : α → C} {g : β → C} {h : γ → C} [HasProduct f] [HasProduct g]\n    [HasProduct h] (p : β → α) (p' : γ → β) (q : ∀ (b : β), f (p b) ⟶ g b)\n    (q' : ∀ (c : γ), g (p' c) ⟶ h c) :\n    Pi.map' p q ≫ Pi.map' p' q' = Pi.map' (p ∘ p') (fun c => q (p' c) ≫ q' c) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_comp_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf : α → C\ng h : β → C\ninst✝² : CategoryTheory.Limits.HasProduct f\ninst✝¹ : CategoryTheory.Limits.HasProduct g\ninst✝ : CategoryTheory.Limits.HasProduct h\np : β → α\nq : (b : β) → Quiver.Hom (f (p b)) (g b)\nq' : (b : β) → Quiver.Hom (g b) (h b)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.map' p q) (CategoryTheory.Limits.Pi.map q')) (CategoryTheory.Limits.Pi.map' p fun b => CategoryTheory.CategoryStruct.comp (q b) (q' b))","decl":"lemma Pi.map'_comp_map {f : α → C} {g h : β → C} [HasProduct f] [HasProduct g] [HasProduct h]\n    (p : β → α) (q : ∀ (b : β), f (p b) ⟶ g b) (q' : ∀ (b : β), g b ⟶ h b) :\n    Pi.map' p q ≫ Pi.map q' = Pi.map' p (fun b => q b ≫ q' b) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.map_comp_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf g : α → C\nh : β → C\ninst✝² : CategoryTheory.Limits.HasProduct f\ninst✝¹ : CategoryTheory.Limits.HasProduct g\ninst✝ : CategoryTheory.Limits.HasProduct h\np : β → α\nq : (a : α) → Quiver.Hom (f a) (g a)\nq' : (b : β) → Quiver.Hom (g (p b)) (h b)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.map q) (CategoryTheory.Limits.Pi.map' p q')) (CategoryTheory.Limits.Pi.map' p fun b => CategoryTheory.CategoryStruct.comp (q (p b)) (q' b))","decl":"lemma Pi.map_comp_map' {f g : α → C} {h : β → C} [HasProduct f] [HasProduct g] [HasProduct h]\n    (p : β → α) (q : ∀ (a : α), f a ⟶ g a) (q' : ∀ (b : β), g (p b) ⟶ h b) :\n    Pi.map q ≫ Pi.map' p q' = Pi.map' p (fun b => q (p b) ≫ q' b) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf : α → C\ng : β → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct g\np p' : β → α\nq : (b : β) → Quiver.Hom (f (p b)) (g b)\nq' : (b : β) → Quiver.Hom (f (p' b)) (g b)\nhp : Eq p p'\nhq : ∀ (b : β), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (q b)) (q' b)\n⊢ Eq (CategoryTheory.Limits.Pi.map' p q) (CategoryTheory.Limits.Pi.map' p' q')","decl":"lemma Pi.map'_eq {f : α → C} {g : β → C} [HasProduct f] [HasProduct g] {p p' : β → α}\n    {q : ∀ (b : β), f (p b) ⟶ g b} {q' : ∀ (b : β), f (p' b) ⟶ g b} (hp : p = p')\n    (hq : ∀ (b : β), eqToHom (hp ▸ rfl) ≫ q b = q' b) : Pi.map' p q = Pi.map' p' q' := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.Pi.map_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : β → C\ninst✝¹ : CategoryTheory.Limits.HasProductsOfShape β C\np : (b : β) → Quiver.Hom (f b) (g b)\ninst✝ : ∀ (b : β), CategoryTheory.IsIso (p b)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.Pi.map p)","decl":"instance Pi.map_isIso {f g : β → C} [HasProductsOfShape β C] (p : ∀ b, f b ⟶ g b)\n    [∀ b, IsIso <| p b] : IsIso <| Pi.map p :=\n  inferInstanceAs (IsIso (Pi.mapIso (fun b ↦ asIso (p b))).hom)\n\n"}
{"name":"CategoryTheory.Limits.Pi.cone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ninst✝ : CategoryTheory.Limits.HasProduct fun j => X.obj { as := j }\n⊢ Eq (CategoryTheory.Limits.Pi.cone X).pt (CategoryTheory.Limits.piObj fun j => X.obj { as := j })","decl":"/-- A limit cone for `X : Discrete α ⥤ C` that is given\nby `∏ᶜ (fun j => X.obj (Discrete.mk j))`. -/\n@[simps]\ndef Pi.cone : Cone X where\n  pt := ∏ᶜ (fun j => X.obj (Discrete.mk j))\n  π := Discrete.natTrans (fun _ => Pi.π _ _)\n\n"}
{"name":"CategoryTheory.Limits.Pi.cone_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ninst✝ : CategoryTheory.Limits.HasProduct fun j => X.obj { as := j }\n⊢ Eq (CategoryTheory.Limits.Pi.cone X).π (CategoryTheory.Discrete.natTrans fun x => CategoryTheory.Limits.Pi.π (fun j => X.obj { as := j }) x.as)","decl":"/-- A limit cone for `X : Discrete α ⥤ C` that is given\nby `∏ᶜ (fun j => X.obj (Discrete.mk j))`. -/\n@[simps]\ndef Pi.cone : Cone X where\n  pt := ∏ᶜ (fun j => X.obj (Discrete.mk j))\n  π := Discrete.natTrans (fun _ => Pi.π _ _)\n\n"}
{"name":"CategoryTheory.Limits.Pi.isoLimit_inv_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ninst✝¹ : CategoryTheory.Limits.HasProduct fun j => X.obj { as := j }\ninst✝ : CategoryTheory.Limits.HasLimit X\nj : α\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.isoLimit X).inv (CategoryTheory.Limits.Pi.π (fun j => X.obj { as := j }) j)) (CategoryTheory.Limits.limit.π X { as := j })","decl":"@[reassoc (attr := simp)]\nlemma Pi.isoLimit_inv_π (j : α) :\n    (Pi.isoLimit X).inv ≫ Pi.π _ j = limit.π _ (Discrete.mk j) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Pi.isoLimit_inv_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ninst✝¹ : CategoryTheory.Limits.HasProduct fun j => X.obj { as := j }\ninst✝ : CategoryTheory.Limits.HasLimit X\nj : α\nZ : C\nh : Quiver.Hom (X.obj { as := j }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.isoLimit X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun j => X.obj { as := j }) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π X { as := j }) h)","decl":"@[reassoc (attr := simp)]\nlemma Pi.isoLimit_inv_π (j : α) :\n    (Pi.isoLimit X).inv ≫ Pi.π _ j = limit.π _ (Discrete.mk j) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Pi.isoLimit_hom_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ninst✝¹ : CategoryTheory.Limits.HasProduct fun j => X.obj { as := j }\ninst✝ : CategoryTheory.Limits.HasLimit X\nj : α\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.isoLimit X).hom (CategoryTheory.Limits.limit.π X { as := j })) (CategoryTheory.Limits.Pi.π (fun j => X.obj { as := j }) j)","decl":"@[reassoc (attr := simp)]\nlemma Pi.isoLimit_hom_π (j : α) :\n    (Pi.isoLimit X).hom ≫ limit.π _ (Discrete.mk j) = Pi.π _ j :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Pi.isoLimit_hom_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ninst✝¹ : CategoryTheory.Limits.HasProduct fun j => X.obj { as := j }\ninst✝ : CategoryTheory.Limits.HasLimit X\nj : α\nZ : C\nh : Quiver.Hom (X.obj { as := j }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.isoLimit X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π X { as := j }) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun j => X.obj { as := j }) j) h)","decl":"@[reassoc (attr := simp)]\nlemma Pi.isoLimit_hom_π (j : α) :\n    (Pi.isoLimit X).hom ≫ limit.π _ (Discrete.mk j) = Pi.π _ j :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : α → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\n⊢ Eq (CategoryTheory.Limits.Sigma.map fun a => CategoryTheory.CategoryStruct.id (f a)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.sigmaObj f))","decl":"@[simp]\nlemma Sigma.map_id {f : α → C} [HasCoproduct f] : Sigma.map (fun a => 𝟙 (f a)) = 𝟙 (∐ f) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map_comp_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf g h : α → C\ninst✝² : CategoryTheory.Limits.HasCoproduct f\ninst✝¹ : CategoryTheory.Limits.HasCoproduct g\ninst✝ : CategoryTheory.Limits.HasCoproduct h\nq : (a : α) → Quiver.Hom (f a) (g a)\nq' : (a : α) → Quiver.Hom (g a) (h a)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.map q) (CategoryTheory.Limits.Sigma.map q')) (CategoryTheory.Limits.Sigma.map fun a => CategoryTheory.CategoryStruct.comp (q a) (q' a))","decl":"lemma Sigma.map_comp_map {f g h : α → C} [HasCoproduct f] [HasCoproduct g] [HasCoproduct h]\n    (q : ∀ (a : α), f a ⟶ g a) (q' : ∀ (a : α), g a ⟶ h a) :\n    Sigma.map q ≫ Sigma.map q' = Sigma.map (fun a => q a ≫ q' a) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf g : β → C\ninst✝² : CategoryTheory.Limits.HasCoproduct f\ninst✝¹ : CategoryTheory.Limits.HasCoproduct g\np : (b : β) → Quiver.Hom (f b) (g b)\ninst✝ : ∀ (i : β), CategoryTheory.Epi (p i)\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.Sigma.map p)","decl":"instance Sigma.map_epi {f g : β → C} [HasCoproduct f] [HasCoproduct g] (p : ∀ b, f b ⟶ g b)\n    [∀ i, Epi (p i)] : Epi <| Sigma.map p :=\n  @Limits.colimMap_epi _ _ _ _ (Discrete.functor f) (Discrete.functor g) _ _\n    (Discrete.natTrans fun X => p X.as) (by dsimp; infer_instance)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.ι_comp_map'_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf : α → C\ng : β → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct g\np : α → β\nq : (a : α) → Quiver.Hom (f a) (g (p a))\na : α\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.map' p q) h)) (CategoryTheory.CategoryStruct.comp (q a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι g (p a)) h))","decl":"@[reassoc (attr := simp)]\nlemma Sigma.ι_comp_map' {f : α → C} {g : β → C} [HasCoproduct f] [HasCoproduct g]\n    (p : α → β) (q : ∀ (a : α), f a ⟶ g (p a)) (a : α) :\n    Sigma.ι f a ≫ Sigma.map' p q = q a ≫ Sigma.ι g (p a) :=\n  colimit.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.Sigma.ι_comp_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf : α → C\ng : β → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct g\np : α → β\nq : (a : α) → Quiver.Hom (f a) (g (p a))\na : α\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f a) (CategoryTheory.Limits.Sigma.map' p q)) (CategoryTheory.CategoryStruct.comp (q a) (CategoryTheory.Limits.Sigma.ι g (p a)))","decl":"@[reassoc (attr := simp)]\nlemma Sigma.ι_comp_map' {f : α → C} {g : β → C} [HasCoproduct f] [HasCoproduct g]\n    (p : α → β) (q : ∀ (a : α), f a ⟶ g (p a)) (a : α) :\n    Sigma.ι f a ≫ Sigma.map' p q = q a ≫ Sigma.ι g (p a) :=\n  colimit.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map'_id_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nf : α → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\n⊢ Eq (CategoryTheory.Limits.Sigma.map' id fun a => CategoryTheory.CategoryStruct.id (f a)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.sigmaObj f))","decl":"lemma Sigma.map'_id_id {f : α → C} [HasCoproduct f] :\n    Sigma.map' id (fun a => 𝟙 (f a)) = 𝟙 (∐ f) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map'_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : α → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct g\np : (b : α) → Quiver.Hom (f b) (g b)\n⊢ Eq (CategoryTheory.Limits.Sigma.map' id p) (CategoryTheory.Limits.Sigma.map p)","decl":"@[simp]\nlemma Sigma.map'_id {f g : α → C} [HasCoproduct f] [HasCoproduct g] (p : ∀ b, f b ⟶ g b) :\n    Sigma.map' id p = Sigma.map p :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map'_comp_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nγ : Type w₃\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf : α → C\ng : β → C\nh : γ → C\ninst✝² : CategoryTheory.Limits.HasCoproduct f\ninst✝¹ : CategoryTheory.Limits.HasCoproduct g\ninst✝ : CategoryTheory.Limits.HasCoproduct h\np : α → β\np' : β → γ\nq : (a : α) → Quiver.Hom (f a) (g (p a))\nq' : (b : β) → Quiver.Hom (g b) (h (p' b))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.map' p q) (CategoryTheory.Limits.Sigma.map' p' q')) (CategoryTheory.Limits.Sigma.map' (Function.comp p' p) fun a => CategoryTheory.CategoryStruct.comp (q a) (q' (p a)))","decl":"lemma Sigma.map'_comp_map' {f : α → C} {g : β → C} {h : γ → C} [HasCoproduct f] [HasCoproduct g]\n    [HasCoproduct h] (p : α → β) (p' : β → γ) (q : ∀ (a : α), f a ⟶ g (p a))\n    (q' : ∀ (b : β), g b ⟶ h (p' b)) :\n    Sigma.map' p q ≫ Sigma.map' p' q' = Sigma.map' (p' ∘ p) (fun a => q a ≫ q' (p a)) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map'_comp_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf : α → C\ng h : β → C\ninst✝² : CategoryTheory.Limits.HasCoproduct f\ninst✝¹ : CategoryTheory.Limits.HasCoproduct g\ninst✝ : CategoryTheory.Limits.HasCoproduct h\np : α → β\nq : (a : α) → Quiver.Hom (f a) (g (p a))\nq' : (b : β) → Quiver.Hom (g b) (h b)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.map' p q) (CategoryTheory.Limits.Sigma.map q')) (CategoryTheory.Limits.Sigma.map' p fun a => CategoryTheory.CategoryStruct.comp (q a) (q' (p a)))","decl":"lemma Sigma.map'_comp_map {f : α → C} {g h : β → C} [HasCoproduct f] [HasCoproduct g]\n    [HasCoproduct h] (p : α → β) (q : ∀ (a : α), f a ⟶ g (p a)) (q' : ∀ (b : β), g b ⟶ h b) :\n    Sigma.map' p q ≫ Sigma.map q' = Sigma.map' p (fun a => q a ≫ q' (p a)) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map_comp_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nf g : α → C\nh : β → C\ninst✝² : CategoryTheory.Limits.HasCoproduct f\ninst✝¹ : CategoryTheory.Limits.HasCoproduct g\ninst✝ : CategoryTheory.Limits.HasCoproduct h\np : α → β\nq : (a : α) → Quiver.Hom (f a) (g a)\nq' : (a : α) → Quiver.Hom (g a) (h (p a))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.map q) (CategoryTheory.Limits.Sigma.map' p q')) (CategoryTheory.Limits.Sigma.map' p fun a => CategoryTheory.CategoryStruct.comp (q a) (q' a))","decl":"lemma Sigma.map_comp_map' {f g : α → C} {h : β → C} [HasCoproduct f] [HasCoproduct g]\n    [HasCoproduct h] (p : α → β) (q : ∀ (a : α), f a ⟶ g a) (q' : ∀ (a : α), g a ⟶ h (p a)) :\n    Sigma.map q ≫ Sigma.map' p q' = Sigma.map' p (fun a => q a ≫ q' a) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map'_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nα : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf : α → C\ng : β → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct g\np p' : α → β\nq : (a : α) → Quiver.Hom (f a) (g (p a))\nq' : (a : α) → Quiver.Hom (f a) (g (p' a))\nhp : Eq p p'\nhq : ∀ (a : α), Eq (CategoryTheory.CategoryStruct.comp (q a) (CategoryTheory.eqToHom ⋯)) (q' a)\n⊢ Eq (CategoryTheory.Limits.Sigma.map' p q) (CategoryTheory.Limits.Sigma.map' p' q')","decl":"lemma Sigma.map'_eq {f : α → C} {g : β → C} [HasCoproduct f] [HasCoproduct g]\n    {p p' : α → β} {q : ∀ (a : α), f a ⟶ g (p a)} {q' : ∀ (a : α), f a ⟶ g (p' a)}\n    (hp : p = p') (hq : ∀ (a : α), q a ≫ eqToHom (hp ▸ rfl) = q' a) :\n    Sigma.map' p q = Sigma.map' p' q' := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nf g : β → C\ninst✝¹ : CategoryTheory.Limits.HasCoproductsOfShape β C\np : (b : β) → Quiver.Hom (f b) (g b)\ninst✝ : ∀ (b : β), CategoryTheory.IsIso (p b)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.Sigma.map p)","decl":"instance Sigma.map_isIso {f g : β → C} [HasCoproductsOfShape β C] (p : ∀ b, f b ⟶ g b)\n    [∀ b, IsIso <| p b] : IsIso (Sigma.map p) :=\n  inferInstanceAs (IsIso (Sigma.mapIso (fun b ↦ asIso (p b))).hom)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.cocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ninst✝ : CategoryTheory.Limits.HasCoproduct fun j => X.obj { as := j }\n⊢ Eq (CategoryTheory.Limits.Sigma.cocone X).pt (CategoryTheory.Limits.sigmaObj fun j => X.obj { as := j })","decl":"/-- A colimit cocone for `X : Discrete α ⥤ C` that is given\nby `∐ (fun j => X.obj (Discrete.mk j))`. -/\n@[simps]\ndef Sigma.cocone : Cocone X where\n  pt := ∐ (fun j => X.obj (Discrete.mk j))\n  ι := Discrete.natTrans (fun _ => Sigma.ι (fun j ↦ X.obj ⟨j⟩) _)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.cocone_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ninst✝ : CategoryTheory.Limits.HasCoproduct fun j => X.obj { as := j }\n⊢ Eq (CategoryTheory.Limits.Sigma.cocone X).ι (CategoryTheory.Discrete.natTrans fun x => CategoryTheory.Limits.Sigma.ι (fun j => X.obj { as := j }) x.as)","decl":"/-- A colimit cocone for `X : Discrete α ⥤ C` that is given\nby `∐ (fun j => X.obj (Discrete.mk j))`. -/\n@[simps]\ndef Sigma.cocone : Cocone X where\n  pt := ∐ (fun j => X.obj (Discrete.mk j))\n  ι := Discrete.natTrans (fun _ => Sigma.ι (fun j ↦ X.obj ⟨j⟩) _)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.ι_isoColimit_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct fun j => X.obj { as := j }\ninst✝ : CategoryTheory.Limits.HasColimit X\nj : α\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (fun j => X.obj { as := j }) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.isoColimit X).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι X { as := j }) h)","decl":"@[reassoc (attr := simp)]\nlemma Sigma.ι_isoColimit_hom (j : α) :\n    Sigma.ι _ j ≫ (Sigma.isoColimit X).hom = colimit.ι _ (Discrete.mk j) :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom (coproductIsCoproduct' X) _ _\n\n"}
{"name":"CategoryTheory.Limits.Sigma.ι_isoColimit_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct fun j => X.obj { as := j }\ninst✝ : CategoryTheory.Limits.HasColimit X\nj : α\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (fun j => X.obj { as := j }) j) (CategoryTheory.Limits.Sigma.isoColimit X).hom) (CategoryTheory.Limits.colimit.ι X { as := j })","decl":"@[reassoc (attr := simp)]\nlemma Sigma.ι_isoColimit_hom (j : α) :\n    Sigma.ι _ j ≫ (Sigma.isoColimit X).hom = colimit.ι _ (Discrete.mk j) :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom (coproductIsCoproduct' X) _ _\n\n"}
{"name":"CategoryTheory.Limits.Sigma.ι_isoColimit_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct fun j => X.obj { as := j }\ninst✝ : CategoryTheory.Limits.HasColimit X\nj : α\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι X { as := j }) (CategoryTheory.Limits.Sigma.isoColimit X).inv) (CategoryTheory.Limits.Sigma.ι (fun j => X.obj { as := j }) j)","decl":"@[reassoc (attr := simp)]\nlemma Sigma.ι_isoColimit_inv (j : α) :\n    colimit.ι _ ⟨j⟩ ≫ (Sigma.isoColimit X).inv = Sigma.ι (fun j ↦ X.obj ⟨j⟩) _ :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Sigma.ι_isoColimit_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"α : Type w₂\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete α) C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct fun j => X.obj { as := j }\ninst✝ : CategoryTheory.Limits.HasColimit X\nj : α\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj fun j => X.obj { as := j }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι X { as := j }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.isoColimit X).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (fun j => X.obj { as := j }) j) h)","decl":"@[reassoc (attr := simp)]\nlemma Sigma.ι_isoColimit_inv (j : α) :\n    colimit.ι _ ⟨j⟩ ≫ (Sigma.isoColimit X).inv = Sigma.ι (fun j ↦ X.obj ⟨j⟩) _ :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Pi.whiskerEquiv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nK : Type u_2\nf : J → C\ng : K → C\ne : Equiv J K\nw : (j : J) → CategoryTheory.Iso (g (e j)) (f j)\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct g\n⊢ Eq (CategoryTheory.Limits.Pi.whiskerEquiv e w).hom (CategoryTheory.Limits.Pi.map' ⇑e.symm fun k => CategoryTheory.CategoryStruct.comp (w (e.symm k)).inv (CategoryTheory.eqToHom ⋯))","decl":"/-- Two products which differ by an equivalence in the indexing type,\nand up to isomorphism in the factors, are isomorphic.\n-/\n@[simps]\ndef Pi.whiskerEquiv {J K : Type*} {f : J → C} {g : K → C} (e : J ≃ K) (w : ∀ j, g (e j) ≅ f j)\n    [HasProduct f] [HasProduct g] : ∏ᶜ f ≅ ∏ᶜ g where\n  hom := Pi.map' e.symm fun k => (w (e.symm k)).inv ≫ eqToHom (by simp)\n  inv := Pi.map' e fun j => (w j).hom\n\n"}
{"name":"CategoryTheory.Limits.Pi.whiskerEquiv_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nK : Type u_2\nf : J → C\ng : K → C\ne : Equiv J K\nw : (j : J) → CategoryTheory.Iso (g (e j)) (f j)\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct g\n⊢ Eq (CategoryTheory.Limits.Pi.whiskerEquiv e w).inv (CategoryTheory.Limits.Pi.map' ⇑e fun j => (w j).hom)","decl":"/-- Two products which differ by an equivalence in the indexing type,\nand up to isomorphism in the factors, are isomorphic.\n-/\n@[simps]\ndef Pi.whiskerEquiv {J K : Type*} {f : J → C} {g : K → C} (e : J ≃ K) (w : ∀ j, g (e j) ≅ f j)\n    [HasProduct f] [HasProduct g] : ∏ᶜ f ≅ ∏ᶜ g where\n  hom := Pi.map' e.symm fun k => (w (e.symm k)).inv ≫ eqToHom (by simp)\n  inv := Pi.map' e fun j => (w j).hom\n\n"}
{"name":"CategoryTheory.Limits.Sigma.whiskerEquiv_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nK : Type u_2\nf : J → C\ng : K → C\ne : Equiv J K\nw : (j : J) → CategoryTheory.Iso (g (e j)) (f j)\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct g\n⊢ Eq (CategoryTheory.Limits.Sigma.whiskerEquiv e w).inv (CategoryTheory.Limits.Sigma.map' ⇑e.symm fun k => CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (w (e.symm k)).hom)","decl":"/-- Two coproducts which differ by an equivalence in the indexing type,\nand up to isomorphism in the factors, are isomorphic.\n-/\n@[simps]\ndef Sigma.whiskerEquiv {J K : Type*} {f : J → C} {g : K → C} (e : J ≃ K) (w : ∀ j, g (e j) ≅ f j)\n    [HasCoproduct f] [HasCoproduct g] : ∐ f ≅ ∐ g where\n  hom := Sigma.map' e fun j => (w j).inv\n  inv := Sigma.map' e.symm fun k => eqToHom (by simp) ≫ (w (e.symm k)).hom\n\n"}
{"name":"CategoryTheory.Limits.Sigma.whiskerEquiv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nK : Type u_2\nf : J → C\ng : K → C\ne : Equiv J K\nw : (j : J) → CategoryTheory.Iso (g (e j)) (f j)\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct g\n⊢ Eq (CategoryTheory.Limits.Sigma.whiskerEquiv e w).hom (CategoryTheory.Limits.Sigma.map' ⇑e fun j => (w j).inv)","decl":"/-- Two coproducts which differ by an equivalence in the indexing type,\nand up to isomorphism in the factors, are isomorphic.\n-/\n@[simps]\ndef Sigma.whiskerEquiv {J K : Type*} {f : J → C} {g : K → C} (e : J ≃ K) (w : ∀ j, g (e j) ≅ f j)\n    [HasCoproduct f] [HasCoproduct g] : ∐ f ≅ ∐ g where\n  hom := Sigma.map' e fun j => (w j).inv\n  inv := Sigma.map' e.symm fun k => eqToHom (by simp) ≫ (w (e.symm k)).hom\n\n"}
{"name":"CategoryTheory.Limits.instHasProductSigmaFstSndOfPiObj","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nι : Type u_1\nf : ι → Type u_2\ng : (i : ι) → f i → C\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasProduct (g i)\ninst✝ : CategoryTheory.Limits.HasProduct fun i => CategoryTheory.Limits.piObj (g i)\n⊢ CategoryTheory.Limits.HasProduct fun p => g p.fst p.snd","decl":"instance {ι : Type*} (f : ι → Type*) (g : (i : ι) → (f i) → C)\n    [∀ i, HasProduct (g i)] [HasProduct fun i => ∏ᶜ g i] :\n    HasProduct fun p : Σ i, f i => g p.1 p.2 where\n  exists_limit := Nonempty.intro\n    { cone := Fan.mk (∏ᶜ fun i => ∏ᶜ g i) (fun X => Pi.π (fun i => ∏ᶜ g i) X.1 ≫ Pi.π (g X.1) X.2)\n      isLimit := mkFanLimit _ (fun s => Pi.lift fun b => Pi.lift fun c => s.proj ⟨b, c⟩)\n        (by simp)\n        (by intro s m w; simp only [Fan.mk_pt]; symm; ext i x; simp_all [Sigma.forall]) }\n\n"}
{"name":"CategoryTheory.Limits.piPiIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nι : Type u_1\nf : ι → Type u_2\ng : (i : ι) → f i → C\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasProduct (g i)\ninst✝ : CategoryTheory.Limits.HasProduct fun i => CategoryTheory.Limits.piObj (g i)\n⊢ Eq (CategoryTheory.Limits.piPiIso f g).inv (CategoryTheory.Limits.Pi.lift fun i => CategoryTheory.Limits.Pi.lift fun x => CategoryTheory.Limits.Pi.π (fun p => g p.fst p.snd) ⟨i, x⟩)","decl":"/-- An iterated product is a product over a sigma type. -/\n@[simps]\ndef piPiIso {ι : Type*} (f : ι → Type*) (g : (i : ι) → (f i) → C)\n    [∀ i, HasProduct (g i)] [HasProduct fun i => ∏ᶜ g i] :\n    (∏ᶜ fun i => ∏ᶜ g i) ≅ (∏ᶜ fun p : Σ i, f i => g p.1 p.2) where\n  hom := Pi.lift fun ⟨i, x⟩ => Pi.π _ i ≫ Pi.π _ x\n  inv := Pi.lift fun i => Pi.lift fun x => Pi.π _ (⟨i, x⟩ : Σ i, f i)\n\n"}
{"name":"CategoryTheory.Limits.piPiIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nι : Type u_1\nf : ι → Type u_2\ng : (i : ι) → f i → C\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasProduct (g i)\ninst✝ : CategoryTheory.Limits.HasProduct fun i => CategoryTheory.Limits.piObj (g i)\n⊢ Eq (CategoryTheory.Limits.piPiIso f g).hom (CategoryTheory.Limits.Pi.lift fun x => CategoryTheory.Limits.piPiIso.match_1 f (fun x => Quiver.Hom (CategoryTheory.Limits.piObj fun i => CategoryTheory.Limits.piObj (g i)) (g x.fst x.snd)) x fun i x => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun i => CategoryTheory.Limits.piObj (g i)) i) (CategoryTheory.Limits.Pi.π (g i) x))","decl":"/-- An iterated product is a product over a sigma type. -/\n@[simps]\ndef piPiIso {ι : Type*} (f : ι → Type*) (g : (i : ι) → (f i) → C)\n    [∀ i, HasProduct (g i)] [HasProduct fun i => ∏ᶜ g i] :\n    (∏ᶜ fun i => ∏ᶜ g i) ≅ (∏ᶜ fun p : Σ i, f i => g p.1 p.2) where\n  hom := Pi.lift fun ⟨i, x⟩ => Pi.π _ i ≫ Pi.π _ x\n  inv := Pi.lift fun i => Pi.lift fun x => Pi.π _ (⟨i, x⟩ : Σ i, f i)\n\n"}
{"name":"CategoryTheory.Limits.instHasCoproductSigmaFstSndOfSigmaObj","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nι : Type u_1\nf : ι → Type u_2\ng : (i : ι) → f i → C\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasCoproduct (g i)\ninst✝ : CategoryTheory.Limits.HasCoproduct fun i => CategoryTheory.Limits.sigmaObj (g i)\n⊢ CategoryTheory.Limits.HasCoproduct fun p => g p.fst p.snd","decl":"instance {ι : Type*} (f : ι → Type*) (g : (i : ι) → (f i) → C)\n    [∀ i, HasCoproduct (g i)] [HasCoproduct fun i => ∐ g i] :\n    HasCoproduct fun p : Σ i, f i => g p.1 p.2 where\n  exists_colimit := Nonempty.intro\n    { cocone := Cofan.mk (∐ fun i => ∐ g i)\n        (fun X => Sigma.ι (g X.1) X.2 ≫ Sigma.ι (fun i => ∐ g i) X.1)\n      isColimit := mkCofanColimit _\n        (fun s => Sigma.desc fun b => Sigma.desc fun c => s.inj ⟨b, c⟩)\n        (by simp)\n        (by intro s m w; simp only [Cofan.mk_pt]; symm; ext i x; simp_all [Sigma.forall]) }\n\n"}
{"name":"CategoryTheory.Limits.sigmaSigmaIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nι : Type u_1\nf : ι → Type u_2\ng : (i : ι) → f i → C\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasCoproduct (g i)\ninst✝ : CategoryTheory.Limits.HasCoproduct fun i => CategoryTheory.Limits.sigmaObj (g i)\n⊢ Eq (CategoryTheory.Limits.sigmaSigmaIso f g).hom (CategoryTheory.Limits.Sigma.desc fun i => CategoryTheory.Limits.Sigma.desc fun x => CategoryTheory.Limits.Sigma.ι (fun p => g p.fst p.snd) ⟨i, x⟩)","decl":"/-- An iterated coproduct is a coproduct over a sigma type. -/\n@[simps]\ndef sigmaSigmaIso {ι : Type*} (f : ι → Type*) (g : (i : ι) → (f i) → C)\n    [∀ i, HasCoproduct (g i)] [HasCoproduct fun i => ∐ g i] :\n    (∐ fun i => ∐ g i) ≅ (∐ fun p : Σ i, f i => g p.1 p.2) where\n  hom := Sigma.desc fun i => Sigma.desc fun x => Sigma.ι (fun p : Σ i, f i => g p.1 p.2) ⟨i, x⟩\n  inv := Sigma.desc fun ⟨i, x⟩ => Sigma.ι (g i) x ≫ Sigma.ι (fun i => ∐ g i) i\n\n"}
{"name":"CategoryTheory.Limits.sigmaSigmaIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nι : Type u_1\nf : ι → Type u_2\ng : (i : ι) → f i → C\ninst✝¹ : ∀ (i : ι), CategoryTheory.Limits.HasCoproduct (g i)\ninst✝ : CategoryTheory.Limits.HasCoproduct fun i => CategoryTheory.Limits.sigmaObj (g i)\n⊢ Eq (CategoryTheory.Limits.sigmaSigmaIso f g).inv (CategoryTheory.Limits.Sigma.desc fun x => CategoryTheory.Limits.piPiIso.match_1 f (fun x => Quiver.Hom (g x.fst x.snd) (CategoryTheory.Limits.sigmaObj fun i => CategoryTheory.Limits.sigmaObj (g i))) x fun i x => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (g i) x) (CategoryTheory.Limits.Sigma.ι (fun i => CategoryTheory.Limits.sigmaObj (g i)) i))","decl":"/-- An iterated coproduct is a coproduct over a sigma type. -/\n@[simps]\ndef sigmaSigmaIso {ι : Type*} (f : ι → Type*) (g : (i : ι) → (f i) → C)\n    [∀ i, HasCoproduct (g i)] [HasCoproduct fun i => ∐ g i] :\n    (∐ fun i => ∐ g i) ≅ (∐ fun p : Σ i, f i => g p.1 p.2) where\n  hom := Sigma.desc fun i => Sigma.desc fun x => Sigma.ι (fun p : Σ i, f i => g p.1 p.2) ⟨i, x⟩\n  inv := Sigma.desc fun ⟨i, x⟩ => Sigma.ι (g i) x ≫ Sigma.ι (fun i => ∐ g i) i\n\n"}
{"name":"CategoryTheory.Limits.piComparison_comp_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : β → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct fun b => G.obj (f b)\nb : β\nZ : D\nh : Quiver.Hom (G.obj (f b)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.piComparison G f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun b => G.obj (f b)) b) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.Pi.π f b)) h)","decl":"@[reassoc (attr := simp)]\ntheorem piComparison_comp_π [HasProduct f] [HasProduct fun b => G.obj (f b)] (b : β) :\n    piComparison G f ≫ Pi.π _ b = G.map (Pi.π f b) :=\n  limit.lift_π _ (Discrete.mk b)\n\n"}
{"name":"CategoryTheory.Limits.piComparison_comp_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : β → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct fun b => G.obj (f b)\nb : β\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.piComparison G f) (CategoryTheory.Limits.Pi.π (fun b => G.obj (f b)) b)) (G.map (CategoryTheory.Limits.Pi.π f b))","decl":"@[reassoc (attr := simp)]\ntheorem piComparison_comp_π [HasProduct f] [HasProduct fun b => G.obj (f b)] (b : β) :\n    piComparison G f ≫ Pi.π _ b = G.map (Pi.π f b) :=\n  limit.lift_π _ (Discrete.mk b)\n\n"}
{"name":"CategoryTheory.Limits.map_lift_piComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : β → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct fun b => G.obj (f b)\nP : C\ng : (j : β) → Quiver.Hom P (f j)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.Pi.lift g)) (CategoryTheory.Limits.piComparison G f)) (CategoryTheory.Limits.Pi.lift fun j => G.map (g j))","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_piComparison [HasProduct f] [HasProduct fun b => G.obj (f b)] (P : C)\n    (g : ∀ j, P ⟶ f j) : G.map (Pi.lift g) ≫ piComparison G f = Pi.lift fun j => G.map (g j) := by\n  ext j\n  simp only [Discrete.functor_obj, Category.assoc, piComparison_comp_π, ← G.map_comp,\n    limit.lift_π, Fan.mk_pt, Fan.mk_π_app]\n\n"}
{"name":"CategoryTheory.Limits.map_lift_piComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : β → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct fun b => G.obj (f b)\nP : C\ng : (j : β) → Quiver.Hom P (f j)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.piObj fun b => G.obj (f b)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.Pi.lift g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.piComparison G f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift fun j => G.map (g j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_piComparison [HasProduct f] [HasProduct fun b => G.obj (f b)] (P : C)\n    (g : ∀ j, P ⟶ f j) : G.map (Pi.lift g) ≫ piComparison G f = Pi.lift fun j => G.map (g j) := by\n  ext j\n  simp only [Discrete.functor_obj, Category.assoc, piComparison_comp_π, ← G.map_comp,\n    limit.lift_π, Fan.mk_pt, Fan.mk_π_app]\n\n"}
{"name":"CategoryTheory.Limits.ι_comp_sigmaComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : β → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct fun b => G.obj (f b)\nb : β\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (fun b => G.obj (f b)) b) (CategoryTheory.Limits.sigmaComparison G f)) (G.map (CategoryTheory.Limits.Sigma.ι f b))","decl":"@[reassoc (attr := simp)]\ntheorem ι_comp_sigmaComparison [HasCoproduct f] [HasCoproduct fun b => G.obj (f b)] (b : β) :\n    Sigma.ι _ b ≫ sigmaComparison G f = G.map (Sigma.ι f b) :=\n  colimit.ι_desc _ (Discrete.mk b)\n\n"}
{"name":"CategoryTheory.Limits.ι_comp_sigmaComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : β → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct fun b => G.obj (f b)\nb : β\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.sigmaObj f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (fun b => G.obj (f b)) b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.sigmaComparison G f) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.Sigma.ι f b)) h)","decl":"@[reassoc (attr := simp)]\ntheorem ι_comp_sigmaComparison [HasCoproduct f] [HasCoproduct fun b => G.obj (f b)] (b : β) :\n    Sigma.ι _ b ≫ sigmaComparison G f = G.map (Sigma.ι f b) :=\n  colimit.ι_desc _ (Discrete.mk b)\n\n"}
{"name":"CategoryTheory.Limits.sigmaComparison_map_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : β → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct fun b => G.obj (f b)\nP : C\ng : (j : β) → Quiver.Hom (f j) P\nZ : D\nh : Quiver.Hom (G.obj P) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.sigmaComparison G f) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.Sigma.desc g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.desc fun j => G.map (g j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem sigmaComparison_map_desc [HasCoproduct f] [HasCoproduct fun b => G.obj (f b)] (P : C)\n    (g : ∀ j, f j ⟶ P) :\n    sigmaComparison G f ≫ G.map (Sigma.desc g) = Sigma.desc fun j => G.map (g j) := by\n  ext j\n  simp only [Discrete.functor_obj, ι_comp_sigmaComparison_assoc, ← G.map_comp, colimit.ι_desc,\n    Cofan.mk_pt, Cofan.mk_ι_app]\n\n"}
{"name":"CategoryTheory.Limits.sigmaComparison_map_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nf : β → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct fun b => G.obj (f b)\nP : C\ng : (j : β) → Quiver.Hom (f j) P\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.sigmaComparison G f) (G.map (CategoryTheory.Limits.Sigma.desc g))) (CategoryTheory.Limits.Sigma.desc fun j => G.map (g j))","decl":"@[reassoc (attr := simp)]\ntheorem sigmaComparison_map_desc [HasCoproduct f] [HasCoproduct fun b => G.obj (f b)] (P : C)\n    (g : ∀ j, f j ⟶ P) :\n    sigmaComparison G f ≫ G.map (Sigma.desc g) = Sigma.desc fun j => G.map (g j) := by\n  ext j\n  simp only [Discrete.functor_obj, ι_comp_sigmaComparison_assoc, ← G.map_comp, colimit.ι_desc,\n    Cofan.mk_pt, Cofan.mk_ι_app]\n\n"}
{"name":"CategoryTheory.Limits.hasProducts_shrink","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\n⊢ CategoryTheory.Limits.HasProducts C","decl":"lemma hasProducts_shrink [HasProducts.{max w w'} C] : HasProducts.{w} C := fun J =>\n  hasLimitsOfShape_of_equivalence (Discrete.equivalence Equiv.ulift : Discrete (ULift.{w'} J) ≌ _)\n\n"}
{"name":"CategoryTheory.Limits.hasCoproducts_shrink","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasCoproducts C\n⊢ CategoryTheory.Limits.HasCoproducts C","decl":"lemma hasCoproducts_shrink [HasCoproducts.{max w w'} C] : HasCoproducts.{w} C := fun J =>\n  hasColimitsOfShape_of_equivalence (Discrete.equivalence Equiv.ulift : Discrete (ULift.{w'} J) ≌ _)\n\n"}
{"name":"CategoryTheory.Limits.has_smallest_products_of_hasProducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\n⊢ CategoryTheory.Limits.HasProducts C","decl":"theorem has_smallest_products_of_hasProducts [HasProducts.{w} C] : HasProducts.{0} C :=\n  hasProducts_shrink\n\n"}
{"name":"CategoryTheory.Limits.has_smallest_coproducts_of_hasCoproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasCoproducts C\n⊢ CategoryTheory.Limits.HasCoproducts C","decl":"theorem has_smallest_coproducts_of_hasCoproducts [HasCoproducts.{w} C] : HasCoproducts.{0} C :=\n  hasCoproducts_shrink\n\n"}
{"name":"CategoryTheory.Limits.hasProducts_of_limit_fans","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nlf : {J : Type w} → (f : J → C) → CategoryTheory.Limits.Fan f\nlf_isLimit : {J : Type w} → (f : J → C) → CategoryTheory.Limits.IsLimit (lf f)\n⊢ CategoryTheory.Limits.HasProducts C","decl":"theorem hasProducts_of_limit_fans (lf : ∀ {J : Type w} (f : J → C), Fan f)\n    (lf_isLimit : ∀ {J : Type w} (f : J → C), IsLimit (lf f)) : HasProducts.{w} C :=\n  fun _ : Type w =>\n  { has_limit := fun F =>\n      HasLimit.mk\n        ⟨(Cones.postcompose Discrete.natIsoFunctor.inv).obj (lf fun j => F.obj ⟨j⟩),\n          (IsLimit.postcomposeInvEquiv _ _).symm (lf_isLimit _)⟩ }\n\n"}
{"name":"CategoryTheory.Limits.hasProductsOfShape_of_hasProducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nJ : Type w\n⊢ CategoryTheory.Limits.HasProductsOfShape J C","decl":"instance (priority := 100) hasProductsOfShape_of_hasProducts [HasProducts.{w} C] (J : Type w) :\n    HasProductsOfShape J C := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasCoproductsOfShape_of_hasCoproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasCoproducts C\nJ : Type w\n⊢ CategoryTheory.Limits.HasCoproductsOfShape J C","decl":"instance (priority := 100) hasCoproductsOfShape_of_hasCoproducts [HasCoproducts.{w} C]\n    (J : Type w) : HasCoproductsOfShape J C := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.limitConeOfUnique_isLimit_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : Unique β\nf : β → C\ns : CategoryTheory.Limits.Cone (CategoryTheory.Discrete.functor f)\n⊢ Eq ((CategoryTheory.Limits.limitConeOfUnique f).isLimit.lift s) (s.π.app Inhabited.default)","decl":"/-- The limit cone for the product over an index type with exactly one term. -/\n@[simps]\ndef limitConeOfUnique [Unique β] (f : β → C) : LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := f default\n      π := Discrete.natTrans (fun ⟨j⟩ => eqToHom (by\n        dsimp\n        congr\n        subsingleton)) }\n  isLimit :=\n    { lift := fun s => s.π.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        simp\n      uniq := fun s m w => by\n        specialize w default\n        simpa using w }\n\n"}
{"name":"CategoryTheory.Limits.limitConeOfUnique_cone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : Unique β\nf : β → C\n⊢ Eq (CategoryTheory.Limits.limitConeOfUnique f).cone.pt (f Inhabited.default)","decl":"/-- The limit cone for the product over an index type with exactly one term. -/\n@[simps]\ndef limitConeOfUnique [Unique β] (f : β → C) : LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := f default\n      π := Discrete.natTrans (fun ⟨j⟩ => eqToHom (by\n        dsimp\n        congr\n        subsingleton)) }\n  isLimit :=\n    { lift := fun s => s.π.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        simp\n      uniq := fun s m w => by\n        specialize w default\n        simpa using w }\n\n"}
{"name":"CategoryTheory.Limits.limitConeOfUnique_cone_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : Unique β\nf : β → C\n⊢ Eq (CategoryTheory.Limits.limitConeOfUnique f).cone.π (CategoryTheory.Discrete.natTrans fun x => CategoryTheory.Limits.limitConeOfUnique.match_1 (fun x => Quiver.Hom (((CategoryTheory.Functor.const (CategoryTheory.Discrete β)).obj (f Inhabited.default)).obj x) ((CategoryTheory.Discrete.functor f).obj x)) x fun j => CategoryTheory.eqToHom ⋯)","decl":"/-- The limit cone for the product over an index type with exactly one term. -/\n@[simps]\ndef limitConeOfUnique [Unique β] (f : β → C) : LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := f default\n      π := Discrete.natTrans (fun ⟨j⟩ => eqToHom (by\n        dsimp\n        congr\n        subsingleton)) }\n  isLimit :=\n    { lift := fun s => s.π.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        simp\n      uniq := fun s m w => by\n        specialize w default\n        simpa using w }\n\n"}
{"name":"CategoryTheory.Limits.hasProduct_unique","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : Nonempty β\ninst✝ : Subsingleton β\nf : β → C\n⊢ CategoryTheory.Limits.HasProduct f","decl":"instance (priority := 100) hasProduct_unique [Nonempty β] [Subsingleton β] (f : β → C) :\n    HasProduct f :=\n  let ⟨_⟩ := nonempty_unique β; HasLimit.mk (limitConeOfUnique f)\n\n"}
{"name":"CategoryTheory.Limits.productUniqueIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : Unique β\nf : β → C\n⊢ Eq (CategoryTheory.Limits.productUniqueIso f).hom (CategoryTheory.Limits.limit.π (CategoryTheory.Discrete.functor f) Inhabited.default)","decl":"/-- A product over an index type with exactly one term is just the object over that term. -/\n@[simps!]\ndef productUniqueIso [Unique β] (f : β → C) : ∏ᶜ f ≅ f default :=\n  IsLimit.conePointUniqueUpToIso (limit.isLimit _) (limitConeOfUnique f).isLimit\n\n"}
{"name":"CategoryTheory.Limits.productUniqueIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : Unique β\nf : β → C\n⊢ Eq (CategoryTheory.Limits.productUniqueIso f).inv (CategoryTheory.Limits.limit.lift (CategoryTheory.Discrete.functor f) (CategoryTheory.Limits.limitConeOfUnique f).cone)","decl":"/-- A product over an index type with exactly one term is just the object over that term. -/\n@[simps!]\ndef productUniqueIso [Unique β] (f : β → C) : ∏ᶜ f ≅ f default :=\n  IsLimit.conePointUniqueUpToIso (limit.isLimit _) (limitConeOfUnique f).isLimit\n\n"}
{"name":"CategoryTheory.Limits.colimitCoconeOfUnique_cocone_ι","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : Unique β\nf : β → C\n⊢ Eq (CategoryTheory.Limits.colimitCoconeOfUnique f).cocone.ι (CategoryTheory.Discrete.natTrans fun x => CategoryTheory.Limits.limitConeOfUnique.match_1 (fun x => Quiver.Hom ((CategoryTheory.Discrete.functor f).obj x) (((CategoryTheory.Functor.const (CategoryTheory.Discrete β)).obj (f Inhabited.default)).obj x)) x fun j => CategoryTheory.eqToHom ⋯)","decl":"/-- The colimit cocone for the coproduct over an index type with exactly one term. -/\n@[simps]\ndef colimitCoconeOfUnique [Unique β] (f : β → C) : ColimitCocone (Discrete.functor f) where\n  cocone :=\n    { pt := f default\n      ι := Discrete.natTrans (fun ⟨j⟩ => eqToHom (by\n        dsimp\n        congr\n        subsingleton)) }\n  isColimit :=\n    { desc := fun s => s.ι.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        apply Category.id_comp\n      uniq := fun s m w => by\n        specialize w default\n        erw [Category.id_comp] at w\n        exact w }\n\n"}
{"name":"CategoryTheory.Limits.colimitCoconeOfUnique_cocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : Unique β\nf : β → C\n⊢ Eq (CategoryTheory.Limits.colimitCoconeOfUnique f).cocone.pt (f Inhabited.default)","decl":"/-- The colimit cocone for the coproduct over an index type with exactly one term. -/\n@[simps]\ndef colimitCoconeOfUnique [Unique β] (f : β → C) : ColimitCocone (Discrete.functor f) where\n  cocone :=\n    { pt := f default\n      ι := Discrete.natTrans (fun ⟨j⟩ => eqToHom (by\n        dsimp\n        congr\n        subsingleton)) }\n  isColimit :=\n    { desc := fun s => s.ι.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        apply Category.id_comp\n      uniq := fun s m w => by\n        specialize w default\n        erw [Category.id_comp] at w\n        exact w }\n\n"}
{"name":"CategoryTheory.Limits.colimitCoconeOfUnique_isColimit_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : Unique β\nf : β → C\ns : CategoryTheory.Limits.Cocone (CategoryTheory.Discrete.functor f)\n⊢ Eq ((CategoryTheory.Limits.colimitCoconeOfUnique f).isColimit.desc s) (s.ι.app Inhabited.default)","decl":"/-- The colimit cocone for the coproduct over an index type with exactly one term. -/\n@[simps]\ndef colimitCoconeOfUnique [Unique β] (f : β → C) : ColimitCocone (Discrete.functor f) where\n  cocone :=\n    { pt := f default\n      ι := Discrete.natTrans (fun ⟨j⟩ => eqToHom (by\n        dsimp\n        congr\n        subsingleton)) }\n  isColimit :=\n    { desc := fun s => s.ι.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        apply Category.id_comp\n      uniq := fun s m w => by\n        specialize w default\n        erw [Category.id_comp] at w\n        exact w }\n\n"}
{"name":"CategoryTheory.Limits.hasCoproduct_unique","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : Nonempty β\ninst✝ : Subsingleton β\nf : β → C\n⊢ CategoryTheory.Limits.HasCoproduct f","decl":"instance (priority := 100) hasCoproduct_unique [Nonempty β] [Subsingleton β] (f : β → C) :\n    HasCoproduct f :=\n  let ⟨_⟩ := nonempty_unique β; HasColimit.mk (colimitCoconeOfUnique f)\n\n"}
{"name":"CategoryTheory.Limits.coproductUniqueIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : Unique β\nf : β → C\n⊢ Eq (CategoryTheory.Limits.coproductUniqueIso f).hom (CategoryTheory.Limits.colimit.desc (CategoryTheory.Discrete.functor f) (CategoryTheory.Limits.colimitCoconeOfUnique f).cocone)","decl":"/-- A coproduct over an index type with exactly one term is just the object over that term. -/\n@[simps!]\ndef coproductUniqueIso [Unique β] (f : β → C) : ∐ f ≅ f default :=\n  IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) (colimitCoconeOfUnique f).isColimit\n\n"}
{"name":"CategoryTheory.Limits.coproductUniqueIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : Unique β\nf : β → C\n⊢ Eq (CategoryTheory.Limits.coproductUniqueIso f).inv (CategoryTheory.Limits.colimit.ι (CategoryTheory.Discrete.functor f) Inhabited.default)","decl":"/-- A coproduct over an index type with exactly one term is just the object over that term. -/\n@[simps!]\ndef coproductUniqueIso [Unique β] (f : β → C) : ∐ f ≅ f default :=\n  IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) (colimitCoconeOfUnique f).isColimit\n\n"}
{"name":"CategoryTheory.Limits.Pi.reindex_hom_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nγ : Type w'\nε : Equiv β γ\nf : γ → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct (Function.comp f ⇑ε)\nb : β\nZ : C\nh : Quiver.Hom (f (ε b)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.reindex ε f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π f (ε b)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (Function.comp f ⇑ε) b) h)","decl":"@[reassoc (attr := simp)]\ntheorem Pi.reindex_hom_π (b : β) : (Pi.reindex ε f).hom ≫ Pi.π f (ε b) = Pi.π (f ∘ ε) b := by\n  dsimp [Pi.reindex]\n  simp only [HasLimit.isoOfEquivalence_hom_π, Discrete.equivalence_inverse, Discrete.functor_obj,\n    Function.comp_apply, Functor.id_obj, Discrete.equivalence_functor, Functor.comp_obj,\n    Discrete.natIso_inv_app, Iso.refl_inv, Category.id_comp]\n  exact limit.w (Discrete.functor (f ∘ ε)) (Discrete.eqToHom' (ε.symm_apply_apply b))\n\n"}
{"name":"CategoryTheory.Limits.Pi.reindex_hom_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nγ : Type w'\nε : Equiv β γ\nf : γ → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct (Function.comp f ⇑ε)\nb : β\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.reindex ε f).hom (CategoryTheory.Limits.Pi.π f (ε b))) (CategoryTheory.Limits.Pi.π (Function.comp f ⇑ε) b)","decl":"@[reassoc (attr := simp)]\ntheorem Pi.reindex_hom_π (b : β) : (Pi.reindex ε f).hom ≫ Pi.π f (ε b) = Pi.π (f ∘ ε) b := by\n  dsimp [Pi.reindex]\n  simp only [HasLimit.isoOfEquivalence_hom_π, Discrete.equivalence_inverse, Discrete.functor_obj,\n    Function.comp_apply, Functor.id_obj, Discrete.equivalence_functor, Functor.comp_obj,\n    Discrete.natIso_inv_app, Iso.refl_inv, Category.id_comp]\n  exact limit.w (Discrete.functor (f ∘ ε)) (Discrete.eqToHom' (ε.symm_apply_apply b))\n\n"}
{"name":"CategoryTheory.Limits.Pi.reindex_inv_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nγ : Type w'\nε : Equiv β γ\nf : γ → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct (Function.comp f ⇑ε)\nb : β\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.reindex ε f).inv (CategoryTheory.Limits.Pi.π (Function.comp f ⇑ε) b)) (CategoryTheory.Limits.Pi.π f (ε b))","decl":"@[reassoc (attr := simp)]\ntheorem Pi.reindex_inv_π (b : β) : (Pi.reindex ε f).inv ≫ Pi.π (f ∘ ε) b = Pi.π f (ε b) := by\n  simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.Pi.reindex_inv_π_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nγ : Type w'\nε : Equiv β γ\nf : γ → C\ninst✝¹ : CategoryTheory.Limits.HasProduct f\ninst✝ : CategoryTheory.Limits.HasProduct (Function.comp f ⇑ε)\nb : β\nZ : C\nh : Quiver.Hom (Function.comp f (⇑ε) b) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.reindex ε f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (Function.comp f ⇑ε) b) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π f (ε b)) h)","decl":"@[reassoc (attr := simp)]\ntheorem Pi.reindex_inv_π (b : β) : (Pi.reindex ε f).inv ≫ Pi.π (f ∘ ε) b = Pi.π f (ε b) := by\n  simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.Sigma.ι_reindex_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nγ : Type w'\nε : Equiv β γ\nf : γ → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct (Function.comp f ⇑ε)\nb : β\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (Function.comp f ⇑ε) b) (CategoryTheory.Limits.Sigma.reindex ε f).hom) (CategoryTheory.Limits.Sigma.ι f (ε b))","decl":"@[reassoc (attr := simp)]\ntheorem Sigma.ι_reindex_hom (b : β) :\n    Sigma.ι (f ∘ ε) b ≫ (Sigma.reindex ε f).hom = Sigma.ι f (ε b) := by\n  dsimp [Sigma.reindex]\n  simp only [HasColimit.isoOfEquivalence_hom_π, Functor.id_obj, Discrete.functor_obj,\n    Function.comp_apply, Discrete.equivalence_functor, Discrete.equivalence_inverse,\n    Functor.comp_obj, Discrete.natIso_inv_app, Iso.refl_inv, Category.id_comp]\n  have h := colimit.w (Discrete.functor f) (Discrete.eqToHom' (ε.apply_symm_apply (ε b)))\n  simp only [Discrete.functor_obj] at h\n  erw [← h, eqToHom_map, eqToHom_map, eqToHom_trans_assoc]\n  all_goals { simp }\n\n"}
{"name":"CategoryTheory.Limits.Sigma.ι_reindex_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nγ : Type w'\nε : Equiv β γ\nf : γ → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct (Function.comp f ⇑ε)\nb : β\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (Function.comp f ⇑ε) b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.reindex ε f).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f (ε b)) h)","decl":"@[reassoc (attr := simp)]\ntheorem Sigma.ι_reindex_hom (b : β) :\n    Sigma.ι (f ∘ ε) b ≫ (Sigma.reindex ε f).hom = Sigma.ι f (ε b) := by\n  dsimp [Sigma.reindex]\n  simp only [HasColimit.isoOfEquivalence_hom_π, Functor.id_obj, Discrete.functor_obj,\n    Function.comp_apply, Discrete.equivalence_functor, Discrete.equivalence_inverse,\n    Functor.comp_obj, Discrete.natIso_inv_app, Iso.refl_inv, Category.id_comp]\n  have h := colimit.w (Discrete.functor f) (Discrete.eqToHom' (ε.apply_symm_apply (ε b)))\n  simp only [Discrete.functor_obj] at h\n  erw [← h, eqToHom_map, eqToHom_map, eqToHom_trans_assoc]\n  all_goals { simp }\n\n"}
{"name":"CategoryTheory.Limits.Sigma.ι_reindex_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nγ : Type w'\nε : Equiv β γ\nf : γ → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct (Function.comp f ⇑ε)\nb : β\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f (ε b)) (CategoryTheory.Limits.Sigma.reindex ε f).inv) (CategoryTheory.Limits.Sigma.ι (Function.comp f ⇑ε) b)","decl":"@[reassoc (attr := simp)]\ntheorem Sigma.ι_reindex_inv (b : β) :\n    Sigma.ι f (ε b) ≫ (Sigma.reindex ε f).inv = Sigma.ι (f ∘ ε) b := by simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.Sigma.ι_reindex_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"β : Type w\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nγ : Type w'\nε : Equiv β γ\nf : γ → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct f\ninst✝ : CategoryTheory.Limits.HasCoproduct (Function.comp f ⇑ε)\nb : β\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj (Function.comp f ⇑ε)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f (ε b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.reindex ε f).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (Function.comp f ⇑ε) b) h)","decl":"@[reassoc (attr := simp)]\ntheorem Sigma.ι_reindex_inv (b : β) :\n    Sigma.ι f (ε b) ≫ (Sigma.reindex ε f).inv = Sigma.ι (f ∘ ε) b := by simp [Iso.comp_inv_eq]\n\n"}
