{"name":"CategoryTheory.Limits.Fan.mk_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\nP : C\np : (b : Î²) â†’ Quiver.Hom P (f b)\nâŠ¢ Eq (CategoryTheory.Limits.Fan.mk P p).pt P","decl":"/-- A fan over `f : Î² â†’ C` consists of a collection of maps from an object `P` to every `f b`. -/\n@[simps! pt Ï€_app]\ndef Fan.mk {f : Î² â†’ C} (P : C) (p : âˆ€ b, P âŸ¶ f b) : Fan f where\n  pt := P\n  Ï€ := Discrete.natTrans (fun X => p X.as)\n\n"}
{"name":"CategoryTheory.Limits.Fan.mk_Ï€_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\nP : C\np : (b : Î²) â†’ Quiver.Hom P (f b)\nX : CategoryTheory.Discrete Î²\nâŠ¢ Eq ((CategoryTheory.Limits.Fan.mk P p).Ï€.app X) (p X.as)","decl":"/-- A fan over `f : Î² â†’ C` consists of a collection of maps from an object `P` to every `f b`. -/\n@[simps! pt Ï€_app]\ndef Fan.mk {f : Î² â†’ C} (P : C) (p : âˆ€ b, P âŸ¶ f b) : Fan f where\n  pt := P\n  Ï€ := Discrete.natTrans (fun X => p X.as)\n\n"}
{"name":"CategoryTheory.Limits.Cofan.mk_Î¹_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\nP : C\np : (b : Î²) â†’ Quiver.Hom (f b) P\nX : CategoryTheory.Discrete Î²\nâŠ¢ Eq ((CategoryTheory.Limits.Cofan.mk P p).Î¹.app X) (p X.as)","decl":"/-- A cofan over `f : Î² â†’ C` consists of a collection of maps from every `f b` to an object `P`. -/\n@[simps! pt Î¹_app]\ndef Cofan.mk {f : Î² â†’ C} (P : C) (p : âˆ€ b, f b âŸ¶ P) : Cofan f where\n  pt := P\n  Î¹ := Discrete.natTrans (fun X => p X.as)\n\n"}
{"name":"CategoryTheory.Limits.Cofan.mk_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\nP : C\np : (b : Î²) â†’ Quiver.Hom (f b) P\nâŠ¢ Eq (CategoryTheory.Limits.Cofan.mk P p).pt P","decl":"/-- A cofan over `f : Î² â†’ C` consists of a collection of maps from every `f b` to an object `P`. -/\n@[simps! pt Î¹_app]\ndef Cofan.mk {f : Î² â†’ C} (P : C) (p : âˆ€ b, f b âŸ¶ P) : Cofan f where\n  pt := P\n  Î¹ := Discrete.natTrans (fun X => p X.as)\n\n"}
{"name":"CategoryTheory.Limits.fan_mk_proj","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\nP : C\np : (b : Î²) â†’ Quiver.Hom P (f b)\nj : Î²\nâŠ¢ Eq ((CategoryTheory.Limits.Fan.mk P p).proj j) (p j)","decl":"@[simp]\ntheorem fan_mk_proj {f : Î² â†’ C} (P : C) (p : âˆ€ b, P âŸ¶ f b) (j : Î²) : (Fan.mk P p).proj j = p j :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.cofan_mk_inj","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\nP : C\np : (b : Î²) â†’ Quiver.Hom (f b) P\nj : Î²\nâŠ¢ Eq ((CategoryTheory.Limits.Cofan.mk P p).inj j) (p j)","decl":"@[simp]\ntheorem cofan_mk_inj {f : Î² â†’ C} (P : C) (p : âˆ€ b, f b âŸ¶ P) (j : Î²) :\n    (Cofan.mk P p).inj j = p j :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.hasCoproduct_of_equiv_of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ng : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\ne : Equiv Î² Î±\niso : (j : Î²) â†’ CategoryTheory.Iso (g j) (f (e j))\nâŠ¢ CategoryTheory.Limits.HasCoproduct g","decl":"lemma hasCoproduct_of_equiv_of_iso (f : Î± â†’ C) (g : Î² â†’ C)\n    [HasCoproduct f] (e : Î² â‰ƒ Î±) (iso : âˆ€ j, g j â‰… f (e j)) : HasCoproduct g := by\n  have : HasColimit ((Discrete.equivalence e).functor â‹™ Discrete.functor f) :=\n    hasColimit_equivalence_comp _\n  have Î± : Discrete.functor g â‰… (Discrete.equivalence e).functor â‹™ Discrete.functor f :=\n    Discrete.natIso (fun âŸ¨jâŸ© => iso j)\n  exact hasColimitOfIso Î±\n\n"}
{"name":"CategoryTheory.Limits.hasProduct_of_equiv_of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ng : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasProduct f\ne : Equiv Î² Î±\niso : (j : Î²) â†’ CategoryTheory.Iso (g j) (f (e j))\nâŠ¢ CategoryTheory.Limits.HasProduct g","decl":"lemma hasProduct_of_equiv_of_iso (f : Î± â†’ C) (g : Î² â†’ C)\n    [HasProduct f] (e : Î² â‰ƒ Î±) (iso : âˆ€ j, g j â‰… f (e j)) : HasProduct g := by\n  have : HasLimit ((Discrete.equivalence e).functor â‹™ Discrete.functor f) :=\n    hasLimitEquivalenceComp _\n  have Î± : Discrete.functor g â‰… (Discrete.equivalence e).functor â‹™ Discrete.functor f :=\n    Discrete.natIso (fun âŸ¨jâŸ© => iso j)\n  exact hasLimitOfIso Î±.symm\n\n"}
{"name":"CategoryTheory.Limits.mkFanLimit_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\nt : CategoryTheory.Limits.Fan f\nlift : (s : CategoryTheory.Limits.Fan f) â†’ Quiver.Hom s.pt t.pt\nfac : autoParam (âˆ€ (s : CategoryTheory.Limits.Fan f) (j : Î²), Eq (CategoryTheory.CategoryStruct.comp (lift s) (t.proj j)) (s.proj j)) _autoâœ\nuniq : autoParam (âˆ€ (s : CategoryTheory.Limits.Fan f) (m : Quiver.Hom s.pt t.pt), (âˆ€ (j : Î²), Eq (CategoryTheory.CategoryStruct.comp m (t.proj j)) (s.proj j)) â†’ Eq m (lift s)) _autoâœ\ns : CategoryTheory.Limits.Fan f\nâŠ¢ Eq ((CategoryTheory.Limits.mkFanLimit t lift fac uniq).lift s) (lift s)","decl":"/-- Make a fan `f` into a limit fan by providing `lift`, `fac`, and `uniq` --\n  just a convenience lemma to avoid having to go through `Discrete` -/\n@[simps]\ndef mkFanLimit {f : Î² â†’ C} (t : Fan f) (lift : âˆ€ s : Fan f, s.pt âŸ¶ t.pt)\n    (fac : âˆ€ (s : Fan f) (j : Î²), lift s â‰« t.proj j = s.proj j := by aesop_cat)\n    (uniq : âˆ€ (s : Fan f) (m : s.pt âŸ¶ t.pt) (_ : âˆ€ j : Î², m â‰« t.proj j = s.proj j),\n      m = lift s := by aesop_cat) :\n    IsLimit t :=\n  { lift }\n\n"}
{"name":"CategoryTheory.Limits.Fan.IsLimit.fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : Î² â†’ C\nc : CategoryTheory.Limits.Fan F\nhc : CategoryTheory.Limits.IsLimit c\nA : C\nf : (i : Î²) â†’ Quiver.Hom A (F i)\ni : Î²\nZ : C\nh : Quiver.Hom (F i) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fan.IsLimit.desc hc f) (CategoryTheory.CategoryStruct.comp (c.proj i) h)) (CategoryTheory.CategoryStruct.comp (f i) h)","decl":"@[reassoc (attr := simp)]\nlemma Fan.IsLimit.fac {F : Î² â†’ C} {c : Fan F} (hc : IsLimit c) {A : C}\n    (f : âˆ€ i, A âŸ¶ F i) (i : Î²) :\n    Fan.IsLimit.desc hc f â‰« c.proj i = f i :=\n  hc.fac (Fan.mk A f) âŸ¨iâŸ©\n\n"}
{"name":"CategoryTheory.Limits.Fan.IsLimit.fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : Î² â†’ C\nc : CategoryTheory.Limits.Fan F\nhc : CategoryTheory.Limits.IsLimit c\nA : C\nf : (i : Î²) â†’ Quiver.Hom A (F i)\ni : Î²\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fan.IsLimit.desc hc f) (c.proj i)) (f i)","decl":"@[reassoc (attr := simp)]\nlemma Fan.IsLimit.fac {F : Î² â†’ C} {c : Fan F} (hc : IsLimit c) {A : C}\n    (f : âˆ€ i, A âŸ¶ F i) (i : Î²) :\n    Fan.IsLimit.desc hc f â‰« c.proj i = f i :=\n  hc.fac (Fan.mk A f) âŸ¨iâŸ©\n\n"}
{"name":"CategoryTheory.Limits.Fan.IsLimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : Type u_1\nF : I â†’ C\nc : CategoryTheory.Limits.Fan F\nhc : CategoryTheory.Limits.IsLimit c\nA : C\nf g : Quiver.Hom A c.pt\nh : âˆ€ (i : I), Eq (CategoryTheory.CategoryStruct.comp f (c.proj i)) (CategoryTheory.CategoryStruct.comp g (c.proj i))\nâŠ¢ Eq f g","decl":"lemma Fan.IsLimit.hom_ext {I : Type*} {F : I â†’ C} {c : Fan F} (hc : IsLimit c) {A : C}\n    (f g : A âŸ¶ c.pt) (h : âˆ€ i, f â‰« c.proj i = g â‰« c.proj i) : f = g :=\n  hc.hom_ext (fun âŸ¨iâŸ© => h i)\n\n"}
{"name":"CategoryTheory.Limits.mkCofanColimit_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\ns : CategoryTheory.Limits.Cofan f\ndesc : (t : CategoryTheory.Limits.Cofan f) â†’ Quiver.Hom s.pt t.pt\nfac : autoParam (âˆ€ (t : CategoryTheory.Limits.Cofan f) (j : Î²), Eq (CategoryTheory.CategoryStruct.comp (s.inj j) (desc t)) (t.inj j)) _autoâœ\nuniq : autoParam (âˆ€ (t : CategoryTheory.Limits.Cofan f) (m : Quiver.Hom s.pt t.pt), (âˆ€ (j : Î²), Eq (CategoryTheory.CategoryStruct.comp (s.inj j) m) (t.inj j)) â†’ Eq m (desc t)) _autoâœ\nt : CategoryTheory.Limits.Cofan f\nâŠ¢ Eq ((CategoryTheory.Limits.mkCofanColimit s desc fac uniq).desc t) (desc t)","decl":"/-- Make a cofan `f` into a colimit cofan by providing `desc`, `fac`, and `uniq` --\n  just a convenience lemma to avoid having to go through `Discrete` -/\n@[simps]\ndef mkCofanColimit {f : Î² â†’ C} (s : Cofan f) (desc : âˆ€ t : Cofan f, s.pt âŸ¶ t.pt)\n    (fac : âˆ€ (t : Cofan f) (j : Î²), s.inj j â‰« desc t = t.inj j := by aesop_cat)\n    (uniq : âˆ€ (t : Cofan f) (m : s.pt âŸ¶ t.pt) (_ : âˆ€ j : Î², s.inj j â‰« m = t.inj j),\n      m = desc t := by aesop_cat) :\n    IsColimit s :=\n  { desc }\n\n"}
{"name":"CategoryTheory.Limits.Cofan.IsColimit.fac","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : Î² â†’ C\nc : CategoryTheory.Limits.Cofan F\nhc : CategoryTheory.Limits.IsColimit c\nA : C\nf : (i : Î²) â†’ Quiver.Hom (F i) A\ni : Î²\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (c.inj i) (CategoryTheory.Limits.Cofan.IsColimit.desc hc f)) (f i)","decl":"@[reassoc (attr := simp)]\nlemma Cofan.IsColimit.fac {F : Î² â†’ C} {c : Cofan F} (hc : IsColimit c) {A : C}\n    (f : âˆ€ i, F i âŸ¶ A) (i : Î²) :\n    c.inj i â‰« Cofan.IsColimit.desc hc f = f i :=\n  hc.fac (Cofan.mk A f) âŸ¨iâŸ©\n\n"}
{"name":"CategoryTheory.Limits.Cofan.IsColimit.fac_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : Î² â†’ C\nc : CategoryTheory.Limits.Cofan F\nhc : CategoryTheory.Limits.IsColimit c\nA : C\nf : (i : Î²) â†’ Quiver.Hom (F i) A\ni : Î²\nZ : C\nh : Quiver.Hom A Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (c.inj i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofan.IsColimit.desc hc f) h)) (CategoryTheory.CategoryStruct.comp (f i) h)","decl":"@[reassoc (attr := simp)]\nlemma Cofan.IsColimit.fac {F : Î² â†’ C} {c : Cofan F} (hc : IsColimit c) {A : C}\n    (f : âˆ€ i, F i âŸ¶ A) (i : Î²) :\n    c.inj i â‰« Cofan.IsColimit.desc hc f = f i :=\n  hc.fac (Cofan.mk A f) âŸ¨iâŸ©\n\n"}
{"name":"CategoryTheory.Limits.Cofan.IsColimit.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : Type u_1\nF : I â†’ C\nc : CategoryTheory.Limits.Cofan F\nhc : CategoryTheory.Limits.IsColimit c\nA : C\nf g : Quiver.Hom c.pt A\nh : âˆ€ (i : I), Eq (CategoryTheory.CategoryStruct.comp (c.inj i) f) (CategoryTheory.CategoryStruct.comp (c.inj i) g)\nâŠ¢ Eq f g","decl":"lemma Cofan.IsColimit.hom_ext {I : Type*} {F : I â†’ C} {c : Cofan F} (hc : IsColimit c) {A : C}\n    (f g : c.pt âŸ¶ A) (h : âˆ€ i, c.inj i â‰« f = c.inj i â‰« g) : f = g :=\n  hc.hom_ext (fun âŸ¨iâŸ© => h i)\n\n"}
{"name":"CategoryTheory.Limits.Pi.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasProduct f\nX : C\ngâ‚ gâ‚‚ : Quiver.Hom X (CategoryTheory.Limits.piObj f)\nâŠ¢ Iff (Eq gâ‚ gâ‚‚) (âˆ€ (b : Î²), Eq (CategoryTheory.CategoryStruct.comp gâ‚ (CategoryTheory.Limits.Pi.Ï€ f b)) (CategoryTheory.CategoryStruct.comp gâ‚‚ (CategoryTheory.Limits.Pi.Ï€ f b)))","decl":"@[ext 1050]\nlemma Pi.hom_ext {f : Î² â†’ C} [HasProduct f] {X : C} (gâ‚ gâ‚‚ : X âŸ¶ âˆá¶œ f)\n    (h : âˆ€ (b : Î²), gâ‚ â‰« Pi.Ï€ f b = gâ‚‚ â‰« Pi.Ï€ f b) : gâ‚ = gâ‚‚ :=\n  limit.hom_ext (fun âŸ¨jâŸ© => h j)\n\n"}
{"name":"CategoryTheory.Limits.Pi.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasProduct f\nX : C\ngâ‚ gâ‚‚ : Quiver.Hom X (CategoryTheory.Limits.piObj f)\nh : âˆ€ (b : Î²), Eq (CategoryTheory.CategoryStruct.comp gâ‚ (CategoryTheory.Limits.Pi.Ï€ f b)) (CategoryTheory.CategoryStruct.comp gâ‚‚ (CategoryTheory.Limits.Pi.Ï€ f b))\nâŠ¢ Eq gâ‚ gâ‚‚","decl":"@[ext 1050]\nlemma Pi.hom_ext {f : Î² â†’ C} [HasProduct f] {X : C} (gâ‚ gâ‚‚ : X âŸ¶ âˆá¶œ f)\n    (h : âˆ€ (b : Î²), gâ‚ â‰« Pi.Ï€ f b = gâ‚‚ â‰« Pi.Ï€ f b) : gâ‚ = gâ‚‚ :=\n  limit.hom_ext (fun âŸ¨jâŸ© => h j)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\nX : C\ngâ‚ gâ‚‚ : Quiver.Hom (CategoryTheory.Limits.sigmaObj f) X\nh : âˆ€ (b : Î²), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ f b) gâ‚) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ f b) gâ‚‚)\nâŠ¢ Eq gâ‚ gâ‚‚","decl":"@[ext 1050]\nlemma Sigma.hom_ext {f : Î² â†’ C} [HasCoproduct f] {X : C} (gâ‚ gâ‚‚ : âˆ f âŸ¶ X)\n    (h : âˆ€ (b : Î²), Sigma.Î¹ f b â‰« gâ‚ = Sigma.Î¹ f b â‰« gâ‚‚) : gâ‚ = gâ‚‚ :=\n  colimit.hom_ext (fun âŸ¨jâŸ© => h j)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\nX : C\ngâ‚ gâ‚‚ : Quiver.Hom (CategoryTheory.Limits.sigmaObj f) X\nâŠ¢ Iff (Eq gâ‚ gâ‚‚) (âˆ€ (b : Î²), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ f b) gâ‚) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ f b) gâ‚‚))","decl":"@[ext 1050]\nlemma Sigma.hom_ext {f : Î² â†’ C} [HasCoproduct f] {X : C} (gâ‚ gâ‚‚ : âˆ f âŸ¶ X)\n    (h : âˆ€ (b : Î²), Sigma.Î¹ f b â‰« gâ‚ = Sigma.Î¹ f b â‰« gâ‚‚) : gâ‚ = gâ‚‚ :=\n  colimit.hom_ext (fun âŸ¨jâŸ© => h j)\n\n"}
{"name":"CategoryTheory.Limits.Pi.Ï€_comp_eqToHom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasProduct f\nj j' : J\nw : Eq j j'\nZ : C\nh : Quiver.Hom (f j') Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ f j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ f j') h)","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem Pi.Ï€_comp_eqToHom {J : Type*} (f : J â†’ C) [HasProduct f] {j j' : J} (w : j = j') :\n    Pi.Ï€ f j â‰« eqToHom (by simp [w]) = Pi.Ï€ f j' := by\n  cases w\n  simp\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `Sigma.whiskerEquiv` below.\n"}
{"name":"CategoryTheory.Limits.Pi.Ï€_comp_eqToHom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasProduct f\nj j' : J\nw : Eq j j'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ f j) (CategoryTheory.eqToHom â‹¯)) (CategoryTheory.Limits.Pi.Ï€ f j')","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem Pi.Ï€_comp_eqToHom {J : Type*} (f : J â†’ C) [HasProduct f] {j j' : J} (w : j = j') :\n    Pi.Ï€ f j â‰« eqToHom (by simp [w]) = Pi.Ï€ f j' := by\n  cases w\n  simp\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `Sigma.whiskerEquiv` below.\n"}
{"name":"CategoryTheory.Limits.Sigma.eqToHom_comp_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\nj j' : J\nw : Eq j j'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (CategoryTheory.Limits.Sigma.Î¹ f j')) (CategoryTheory.Limits.Sigma.Î¹ f j)","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem Sigma.eqToHom_comp_Î¹ {J : Type*} (f : J â†’ C) [HasCoproduct f] {j j' : J} (w : j = j') :\n    eqToHom (by simp [w]) â‰« Sigma.Î¹ f j' = Sigma.Î¹ f j := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.eqToHom_comp_Î¹_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nf : J â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\nj j' : J\nw : Eq j j'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj f) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ f j') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ f j) h)","decl":"@[reassoc (attr := simp, nolint simpNF)]\ntheorem Sigma.eqToHom_comp_Î¹ {J : Type*} (f : J â†’ C) [HasCoproduct f] {j j' : J} (w : j = j') :\n    eqToHom (by simp [w]) â‰« Sigma.Î¹ f j' = Sigma.Î¹ f j := by\n  cases w\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.lift_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nÎ² : Type w\nf : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasProduct f\nP : C\np : (b : Î²) â†’ Quiver.Hom P (f b)\nb : Î²\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift p) (CategoryTheory.Limits.Pi.Ï€ f b)) (p b)","decl":"theorem Pi.lift_Ï€ {Î² : Type w} {f : Î² â†’ C} [HasProduct f] {P : C} (p : âˆ€ b, P âŸ¶ f b) (b : Î²) :\n    Pi.lift p â‰« Pi.Ï€ f b = p b := by\n  simp only [limit.lift_Ï€, Fan.mk_pt, Fan.mk_Ï€_app]\n\n"}
{"name":"CategoryTheory.Limits.Fan.ext_inv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\ncâ‚ câ‚‚ : CategoryTheory.Limits.Fan f\ne : CategoryTheory.Iso câ‚.pt câ‚‚.pt\nw : autoParam (âˆ€ (b : Î²), Eq (câ‚.proj b) (CategoryTheory.CategoryStruct.comp e.hom (câ‚‚.proj b))) _autoâœ\nâŠ¢ Eq (CategoryTheory.Limits.Fan.ext e w).inv.hom e.inv","decl":"/-- A version of `Cones.ext` for `Fan`s. -/\n@[simps!]\ndef Fan.ext {f : Î² â†’ C} {câ‚ câ‚‚ : Fan f} (e : câ‚.pt â‰… câ‚‚.pt)\n    (w : âˆ€ (b : Î²), câ‚.proj b = e.hom â‰« câ‚‚.proj b := by aesop_cat) : câ‚ â‰… câ‚‚ :=\n  Cones.ext e (fun âŸ¨jâŸ© => w j)\n\n"}
{"name":"CategoryTheory.Limits.Fan.ext_hom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\ncâ‚ câ‚‚ : CategoryTheory.Limits.Fan f\ne : CategoryTheory.Iso câ‚.pt câ‚‚.pt\nw : autoParam (âˆ€ (b : Î²), Eq (câ‚.proj b) (CategoryTheory.CategoryStruct.comp e.hom (câ‚‚.proj b))) _autoâœ\nâŠ¢ Eq (CategoryTheory.Limits.Fan.ext e w).hom.hom e.hom","decl":"/-- A version of `Cones.ext` for `Fan`s. -/\n@[simps!]\ndef Fan.ext {f : Î² â†’ C} {câ‚ câ‚‚ : Fan f} (e : câ‚.pt â‰… câ‚‚.pt)\n    (w : âˆ€ (b : Î²), câ‚.proj b = e.hom â‰« câ‚‚.proj b := by aesop_cat) : câ‚ â‰… câ‚‚ :=\n  Cones.ext e (fun âŸ¨jâŸ© => w j)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.Î¹_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nÎ² : Type w\nf : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\nP : C\np : (b : Î²) â†’ Quiver.Hom (f b) P\nb : Î²\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ f b) (CategoryTheory.Limits.Sigma.desc p)) (p b)","decl":"theorem Sigma.Î¹_desc {Î² : Type w} {f : Î² â†’ C} [HasCoproduct f] {P : C} (p : âˆ€ b, f b âŸ¶ P) (b : Î²) :\n    Sigma.Î¹ f b â‰« Sigma.desc p = p b := by\n  simp only [colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app]\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoDescÎ¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.Sigma.desc fun a => CategoryTheory.Limits.Sigma.Î¹ f a)","decl":"instance {f : Î² â†’ C} [HasCoproduct f] : IsIso (Sigma.desc (fun a â†¦ Sigma.Î¹ f a)) := by\n  convert IsIso.id _\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Cofan.ext_hom_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\ncâ‚ câ‚‚ : CategoryTheory.Limits.Cofan f\ne : CategoryTheory.Iso câ‚.pt câ‚‚.pt\nw : autoParam (âˆ€ (b : Î²), Eq (CategoryTheory.CategoryStruct.comp (câ‚.inj b) e.hom) (câ‚‚.inj b)) _autoâœ\nâŠ¢ Eq (CategoryTheory.Limits.Cofan.ext e w).hom.hom e.hom","decl":"/-- A version of `Cocones.ext` for `Cofan`s. -/\n@[simps!]\ndef Cofan.ext {f : Î² â†’ C} {câ‚ câ‚‚ : Cofan f} (e : câ‚.pt â‰… câ‚‚.pt)\n    (w : âˆ€ (b : Î²), câ‚.inj b â‰« e.hom = câ‚‚.inj b := by aesop_cat) : câ‚ â‰… câ‚‚ :=\n  Cocones.ext e (fun âŸ¨jâŸ© => w j)\n\n"}
{"name":"CategoryTheory.Limits.Cofan.ext_inv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\ncâ‚ câ‚‚ : CategoryTheory.Limits.Cofan f\ne : CategoryTheory.Iso câ‚.pt câ‚‚.pt\nw : autoParam (âˆ€ (b : Î²), Eq (CategoryTheory.CategoryStruct.comp (câ‚.inj b) e.hom) (câ‚‚.inj b)) _autoâœ\nâŠ¢ Eq (CategoryTheory.Limits.Cofan.ext e w).inv.hom e.inv","decl":"/-- A version of `Cocones.ext` for `Cofan`s. -/\n@[simps!]\ndef Cofan.ext {f : Î² â†’ C} {câ‚ câ‚‚ : Cofan f} (e : câ‚.pt â‰… câ‚‚.pt)\n    (w : âˆ€ (b : Î²), câ‚.inj b â‰« e.hom = câ‚‚.inj b := by aesop_cat) : câ‚ â‰… câ‚‚ :=\n  Cocones.ext e (fun âŸ¨jâŸ© => w j)\n\n"}
{"name":"CategoryTheory.Limits.Cofan.isColimit_iff_isIso_sigmaDesc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nf : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\nc : CategoryTheory.Limits.Cofan f\nâŠ¢ Iff (CategoryTheory.IsIso (CategoryTheory.Limits.Sigma.desc c.inj)) (Nonempty (CategoryTheory.Limits.IsColimit c))","decl":"lemma Cofan.isColimit_iff_isIso_sigmaDesc {f : Î² â†’ C} [HasCoproduct f] (c : Cofan f) :\n    IsIso (Sigma.desc c.inj) â†” Nonempty (IsColimit c) := by\n  refine âŸ¨fun h â†¦ âŸ¨isColimitOfIsIsoSigmaDesc câŸ©, fun âŸ¨hcâŸ© â†¦ ?_âŸ©\n  have : IsIso (((coproductIsCoproduct f).coconePointUniqueUpToIso hc).hom â‰« hc.desc c) := by\n    simp; infer_instance\n  convert this\n  ext\n  simp only [colimit.Î¹_desc, mk_pt, mk_Î¹_app, IsColimit.coconePointUniqueUpToIso,\n    coproductIsCoproduct, colimit.cocone_x, Functor.mapIso_hom, IsColimit.uniqueUpToIso_hom,\n    Cocones.forget_map, IsColimit.descCoconeMorphism_hom, IsColimit.ofIsoColimit_desc,\n    Cocones.ext_inv_hom, Iso.refl_inv, colimit.isColimit_desc, Category.id_comp,\n    IsColimit.desc_self, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Pi.map_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ninstâœ : CategoryTheory.Limits.HasProduct f\nâŠ¢ Eq (CategoryTheory.Limits.Pi.map fun a => CategoryTheory.CategoryStruct.id (f a)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.piObj f))","decl":"@[simp]\nlemma Pi.map_id {f : Î± â†’ C} [HasProduct f] : Pi.map (fun a => ğŸ™ (f a)) = ğŸ™ (âˆá¶œ f) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.map_comp_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nf g h : Î± â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasProduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct g\ninstâœ : CategoryTheory.Limits.HasProduct h\nq : (a : Î±) â†’ Quiver.Hom (f a) (g a)\nq' : (a : Î±) â†’ Quiver.Hom (g a) (h a)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.map q) (CategoryTheory.Limits.Pi.map q')) (CategoryTheory.Limits.Pi.map fun a => CategoryTheory.CategoryStruct.comp (q a) (q' a))","decl":"lemma Pi.map_comp_map {f g h : Î± â†’ C} [HasProduct f] [HasProduct g] [HasProduct h]\n    (q : âˆ€ (a : Î±), f a âŸ¶ g a) (q' : âˆ€ (a : Î±), g a âŸ¶ h a) :\n    Pi.map q â‰« Pi.map q' = Pi.map (fun a => q a â‰« q' a) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.map_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nf g : Î² â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasProduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct g\np : (b : Î²) â†’ Quiver.Hom (f b) (g b)\ninstâœ : âˆ€ (i : Î²), CategoryTheory.Mono (p i)\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Limits.Pi.map p)","decl":"instance Pi.map_mono {f g : Î² â†’ C} [HasProduct f] [HasProduct g] (p : âˆ€ b, f b âŸ¶ g b)\n    [âˆ€ i, Mono (p i)] : Mono <| Pi.map p :=\n  @Limits.limMap_mono _ _ _ _ (Discrete.functor f) (Discrete.functor g) _ _\n    (Discrete.natTrans fun X => p X.as) (by dsimp; infer_instance)\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_comp_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ng : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct g\np : Î² â†’ Î±\nq : (b : Î²) â†’ Quiver.Hom (f (p b)) (g b)\nb : Î²\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.map' p q) (CategoryTheory.Limits.Pi.Ï€ g b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ f (p b)) (q b))","decl":"@[reassoc (attr := simp)]\nlemma Pi.map'_comp_Ï€ {f : Î± â†’ C} {g : Î² â†’ C} [HasProduct f] [HasProduct g] (p : Î² â†’ Î±)\n    (q : âˆ€ (b : Î²), f (p b) âŸ¶ g b) (b : Î²) : Pi.map' p q â‰« Pi.Ï€ g b = Pi.Ï€ f (p b) â‰« q b :=\n  limit.lift_Ï€ _ _\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_comp_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ng : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct g\np : Î² â†’ Î±\nq : (b : Î²) â†’ Quiver.Hom (f (p b)) (g b)\nb : Î²\nZ : C\nh : Quiver.Hom (g b) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.map' p q) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ g b) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ f (p b)) (CategoryTheory.CategoryStruct.comp (q b) h))","decl":"@[reassoc (attr := simp)]\nlemma Pi.map'_comp_Ï€ {f : Î± â†’ C} {g : Î² â†’ C} [HasProduct f] [HasProduct g] (p : Î² â†’ Î±)\n    (q : âˆ€ (b : Î²), f (p b) âŸ¶ g b) (b : Î²) : Pi.map' p q â‰« Pi.Ï€ g b = Pi.Ï€ f (p b) â‰« q b :=\n  limit.lift_Ï€ _ _\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_id_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ninstâœ : CategoryTheory.Limits.HasProduct f\nâŠ¢ Eq (CategoryTheory.Limits.Pi.map' id fun a => CategoryTheory.CategoryStruct.id (f a)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.piObj f))","decl":"lemma Pi.map'_id_id {f : Î± â†’ C} [HasProduct f] : Pi.map' id (fun a => ğŸ™ (f a)) = ğŸ™ (âˆá¶œ f) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nf g : Î± â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct g\np : (b : Î±) â†’ Quiver.Hom (f b) (g b)\nâŠ¢ Eq (CategoryTheory.Limits.Pi.map' id p) (CategoryTheory.Limits.Pi.map p)","decl":"@[simp]\nlemma Pi.map'_id {f g : Î± â†’ C} [HasProduct f] [HasProduct g] (p : âˆ€ b, f b âŸ¶ g b) :\n    Pi.map' id p = Pi.map p :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_comp_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nÎ³ : Type wâ‚ƒ\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ng : Î² â†’ C\nh : Î³ â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasProduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct g\ninstâœ : CategoryTheory.Limits.HasProduct h\np : Î² â†’ Î±\np' : Î³ â†’ Î²\nq : (b : Î²) â†’ Quiver.Hom (f (p b)) (g b)\nq' : (c : Î³) â†’ Quiver.Hom (g (p' c)) (h c)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.map' p q) (CategoryTheory.Limits.Pi.map' p' q')) (CategoryTheory.Limits.Pi.map' (Function.comp p p') fun c => CategoryTheory.CategoryStruct.comp (q (p' c)) (q' c))","decl":"lemma Pi.map'_comp_map' {f : Î± â†’ C} {g : Î² â†’ C} {h : Î³ â†’ C} [HasProduct f] [HasProduct g]\n    [HasProduct h] (p : Î² â†’ Î±) (p' : Î³ â†’ Î²) (q : âˆ€ (b : Î²), f (p b) âŸ¶ g b)\n    (q' : âˆ€ (c : Î³), g (p' c) âŸ¶ h c) :\n    Pi.map' p q â‰« Pi.map' p' q' = Pi.map' (p âˆ˜ p') (fun c => q (p' c) â‰« q' c) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_comp_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ng h : Î² â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasProduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct g\ninstâœ : CategoryTheory.Limits.HasProduct h\np : Î² â†’ Î±\nq : (b : Î²) â†’ Quiver.Hom (f (p b)) (g b)\nq' : (b : Î²) â†’ Quiver.Hom (g b) (h b)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.map' p q) (CategoryTheory.Limits.Pi.map q')) (CategoryTheory.Limits.Pi.map' p fun b => CategoryTheory.CategoryStruct.comp (q b) (q' b))","decl":"lemma Pi.map'_comp_map {f : Î± â†’ C} {g h : Î² â†’ C} [HasProduct f] [HasProduct g] [HasProduct h]\n    (p : Î² â†’ Î±) (q : âˆ€ (b : Î²), f (p b) âŸ¶ g b) (q' : âˆ€ (b : Î²), g b âŸ¶ h b) :\n    Pi.map' p q â‰« Pi.map q' = Pi.map' p (fun b => q b â‰« q' b) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.map_comp_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nf g : Î± â†’ C\nh : Î² â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasProduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct g\ninstâœ : CategoryTheory.Limits.HasProduct h\np : Î² â†’ Î±\nq : (a : Î±) â†’ Quiver.Hom (f a) (g a)\nq' : (b : Î²) â†’ Quiver.Hom (g (p b)) (h b)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.map q) (CategoryTheory.Limits.Pi.map' p q')) (CategoryTheory.Limits.Pi.map' p fun b => CategoryTheory.CategoryStruct.comp (q (p b)) (q' b))","decl":"lemma Pi.map_comp_map' {f g : Î± â†’ C} {h : Î² â†’ C} [HasProduct f] [HasProduct g] [HasProduct h]\n    (p : Î² â†’ Î±) (q : âˆ€ (a : Î±), f a âŸ¶ g a) (q' : âˆ€ (b : Î²), g (p b) âŸ¶ h b) :\n    Pi.map q â‰« Pi.map' p q' = Pi.map' p (fun b => q (p b) â‰« q' b) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Pi.map'_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ng : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct g\np p' : Î² â†’ Î±\nq : (b : Î²) â†’ Quiver.Hom (f (p b)) (g b)\nq' : (b : Î²) â†’ Quiver.Hom (f (p' b)) (g b)\nhp : Eq p p'\nhq : âˆ€ (b : Î²), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (q b)) (q' b)\nâŠ¢ Eq (CategoryTheory.Limits.Pi.map' p q) (CategoryTheory.Limits.Pi.map' p' q')","decl":"lemma Pi.map'_eq {f : Î± â†’ C} {g : Î² â†’ C} [HasProduct f] [HasProduct g] {p p' : Î² â†’ Î±}\n    {q : âˆ€ (b : Î²), f (p b) âŸ¶ g b} {q' : âˆ€ (b : Î²), f (p' b) âŸ¶ g b} (hp : p = p')\n    (hq : âˆ€ (b : Î²), eqToHom (hp â–¸ rfl) â‰« q b = q' b) : Pi.map' p q = Pi.map' p' q' := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.Pi.map_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nf g : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasProductsOfShape Î² C\np : (b : Î²) â†’ Quiver.Hom (f b) (g b)\ninstâœ : âˆ€ (b : Î²), CategoryTheory.IsIso (p b)\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.Pi.map p)","decl":"instance Pi.map_isIso {f g : Î² â†’ C} [HasProductsOfShape Î² C] (p : âˆ€ b, f b âŸ¶ g b)\n    [âˆ€ b, IsIso <| p b] : IsIso <| Pi.map p :=\n  inferInstanceAs (IsIso (Pi.mapIso (fun b â†¦ asIso (p b))).hom)\n\n"}
{"name":"CategoryTheory.Limits.Pi.cone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete Î±) C\ninstâœ : CategoryTheory.Limits.HasProduct fun j => X.obj { as := j }\nâŠ¢ Eq (CategoryTheory.Limits.Pi.cone X).pt (CategoryTheory.Limits.piObj fun j => X.obj { as := j })","decl":"/-- A limit cone for `X : Discrete Î± â¥¤ C` that is given\nby `âˆá¶œ (fun j => X.obj (Discrete.mk j))`. -/\n@[simps]\ndef Pi.cone : Cone X where\n  pt := âˆá¶œ (fun j => X.obj (Discrete.mk j))\n  Ï€ := Discrete.natTrans (fun _ => Pi.Ï€ _ _)\n\n"}
{"name":"CategoryTheory.Limits.Pi.cone_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete Î±) C\ninstâœ : CategoryTheory.Limits.HasProduct fun j => X.obj { as := j }\nâŠ¢ Eq (CategoryTheory.Limits.Pi.cone X).Ï€ (CategoryTheory.Discrete.natTrans fun x => CategoryTheory.Limits.Pi.Ï€ (fun j => X.obj { as := j }) x.as)","decl":"/-- A limit cone for `X : Discrete Î± â¥¤ C` that is given\nby `âˆá¶œ (fun j => X.obj (Discrete.mk j))`. -/\n@[simps]\ndef Pi.cone : Cone X where\n  pt := âˆá¶œ (fun j => X.obj (Discrete.mk j))\n  Ï€ := Discrete.natTrans (fun _ => Pi.Ï€ _ _)\n\n"}
{"name":"CategoryTheory.Limits.Pi.isoLimit_inv_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete Î±) C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct fun j => X.obj { as := j }\ninstâœ : CategoryTheory.Limits.HasLimit X\nj : Î±\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.isoLimit X).inv (CategoryTheory.Limits.Pi.Ï€ (fun j => X.obj { as := j }) j)) (CategoryTheory.Limits.limit.Ï€ X { as := j })","decl":"@[reassoc (attr := simp)]\nlemma Pi.isoLimit_inv_Ï€ (j : Î±) :\n    (Pi.isoLimit X).inv â‰« Pi.Ï€ _ j = limit.Ï€ _ (Discrete.mk j) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Pi.isoLimit_inv_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete Î±) C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct fun j => X.obj { as := j }\ninstâœ : CategoryTheory.Limits.HasLimit X\nj : Î±\nZ : C\nh : Quiver.Hom (X.obj { as := j }) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.isoLimit X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ (fun j => X.obj { as := j }) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ X { as := j }) h)","decl":"@[reassoc (attr := simp)]\nlemma Pi.isoLimit_inv_Ï€ (j : Î±) :\n    (Pi.isoLimit X).inv â‰« Pi.Ï€ _ j = limit.Ï€ _ (Discrete.mk j) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Pi.isoLimit_hom_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete Î±) C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct fun j => X.obj { as := j }\ninstâœ : CategoryTheory.Limits.HasLimit X\nj : Î±\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.isoLimit X).hom (CategoryTheory.Limits.limit.Ï€ X { as := j })) (CategoryTheory.Limits.Pi.Ï€ (fun j => X.obj { as := j }) j)","decl":"@[reassoc (attr := simp)]\nlemma Pi.isoLimit_hom_Ï€ (j : Î±) :\n    (Pi.isoLimit X).hom â‰« limit.Ï€ _ (Discrete.mk j) = Pi.Ï€ _ j :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Pi.isoLimit_hom_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete Î±) C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct fun j => X.obj { as := j }\ninstâœ : CategoryTheory.Limits.HasLimit X\nj : Î±\nZ : C\nh : Quiver.Hom (X.obj { as := j }) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.isoLimit X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ X { as := j }) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ (fun j => X.obj { as := j }) j) h)","decl":"@[reassoc (attr := simp)]\nlemma Pi.isoLimit_hom_Ï€ (j : Î±) :\n    (Pi.isoLimit X).hom â‰« limit.Ï€ _ (Discrete.mk j) = Pi.Ï€ _ j :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\nâŠ¢ Eq (CategoryTheory.Limits.Sigma.map fun a => CategoryTheory.CategoryStruct.id (f a)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.sigmaObj f))","decl":"@[simp]\nlemma Sigma.map_id {f : Î± â†’ C} [HasCoproduct f] : Sigma.map (fun a => ğŸ™ (f a)) = ğŸ™ (âˆ f) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map_comp_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nf g h : Î± â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasCoproduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct g\ninstâœ : CategoryTheory.Limits.HasCoproduct h\nq : (a : Î±) â†’ Quiver.Hom (f a) (g a)\nq' : (a : Î±) â†’ Quiver.Hom (g a) (h a)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.map q) (CategoryTheory.Limits.Sigma.map q')) (CategoryTheory.Limits.Sigma.map fun a => CategoryTheory.CategoryStruct.comp (q a) (q' a))","decl":"lemma Sigma.map_comp_map {f g h : Î± â†’ C} [HasCoproduct f] [HasCoproduct g] [HasCoproduct h]\n    (q : âˆ€ (a : Î±), f a âŸ¶ g a) (q' : âˆ€ (a : Î±), g a âŸ¶ h a) :\n    Sigma.map q â‰« Sigma.map q' = Sigma.map (fun a => q a â‰« q' a) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nf g : Î² â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasCoproduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct g\np : (b : Î²) â†’ Quiver.Hom (f b) (g b)\ninstâœ : âˆ€ (i : Î²), CategoryTheory.Epi (p i)\nâŠ¢ CategoryTheory.Epi (CategoryTheory.Limits.Sigma.map p)","decl":"instance Sigma.map_epi {f g : Î² â†’ C} [HasCoproduct f] [HasCoproduct g] (p : âˆ€ b, f b âŸ¶ g b)\n    [âˆ€ i, Epi (p i)] : Epi <| Sigma.map p :=\n  @Limits.colimMap_epi _ _ _ _ (Discrete.functor f) (Discrete.functor g) _ _\n    (Discrete.natTrans fun X => p X.as) (by dsimp; infer_instance)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.Î¹_comp_map'_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ng : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct g\np : Î± â†’ Î²\nq : (a : Î±) â†’ Quiver.Hom (f a) (g (p a))\na : Î±\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj g) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ f a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.map' p q) h)) (CategoryTheory.CategoryStruct.comp (q a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ g (p a)) h))","decl":"@[reassoc (attr := simp)]\nlemma Sigma.Î¹_comp_map' {f : Î± â†’ C} {g : Î² â†’ C} [HasCoproduct f] [HasCoproduct g]\n    (p : Î± â†’ Î²) (q : âˆ€ (a : Î±), f a âŸ¶ g (p a)) (a : Î±) :\n    Sigma.Î¹ f a â‰« Sigma.map' p q = q a â‰« Sigma.Î¹ g (p a) :=\n  colimit.Î¹_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.Sigma.Î¹_comp_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ng : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct g\np : Î± â†’ Î²\nq : (a : Î±) â†’ Quiver.Hom (f a) (g (p a))\na : Î±\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ f a) (CategoryTheory.Limits.Sigma.map' p q)) (CategoryTheory.CategoryStruct.comp (q a) (CategoryTheory.Limits.Sigma.Î¹ g (p a)))","decl":"@[reassoc (attr := simp)]\nlemma Sigma.Î¹_comp_map' {f : Î± â†’ C} {g : Î² â†’ C} [HasCoproduct f] [HasCoproduct g]\n    (p : Î± â†’ Î²) (q : âˆ€ (a : Î±), f a âŸ¶ g (p a)) (a : Î±) :\n    Sigma.Î¹ f a â‰« Sigma.map' p q = q a â‰« Sigma.Î¹ g (p a) :=\n  colimit.Î¹_desc _ _\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map'_id_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\nâŠ¢ Eq (CategoryTheory.Limits.Sigma.map' id fun a => CategoryTheory.CategoryStruct.id (f a)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.sigmaObj f))","decl":"lemma Sigma.map'_id_id {f : Î± â†’ C} [HasCoproduct f] :\n    Sigma.map' id (fun a => ğŸ™ (f a)) = ğŸ™ (âˆ f) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map'_id","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nf g : Î± â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct g\np : (b : Î±) â†’ Quiver.Hom (f b) (g b)\nâŠ¢ Eq (CategoryTheory.Limits.Sigma.map' id p) (CategoryTheory.Limits.Sigma.map p)","decl":"@[simp]\nlemma Sigma.map'_id {f g : Î± â†’ C} [HasCoproduct f] [HasCoproduct g] (p : âˆ€ b, f b âŸ¶ g b) :\n    Sigma.map' id p = Sigma.map p :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map'_comp_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nÎ³ : Type wâ‚ƒ\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ng : Î² â†’ C\nh : Î³ â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasCoproduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct g\ninstâœ : CategoryTheory.Limits.HasCoproduct h\np : Î± â†’ Î²\np' : Î² â†’ Î³\nq : (a : Î±) â†’ Quiver.Hom (f a) (g (p a))\nq' : (b : Î²) â†’ Quiver.Hom (g b) (h (p' b))\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.map' p q) (CategoryTheory.Limits.Sigma.map' p' q')) (CategoryTheory.Limits.Sigma.map' (Function.comp p' p) fun a => CategoryTheory.CategoryStruct.comp (q a) (q' (p a)))","decl":"lemma Sigma.map'_comp_map' {f : Î± â†’ C} {g : Î² â†’ C} {h : Î³ â†’ C} [HasCoproduct f] [HasCoproduct g]\n    [HasCoproduct h] (p : Î± â†’ Î²) (p' : Î² â†’ Î³) (q : âˆ€ (a : Î±), f a âŸ¶ g (p a))\n    (q' : âˆ€ (b : Î²), g b âŸ¶ h (p' b)) :\n    Sigma.map' p q â‰« Sigma.map' p' q' = Sigma.map' (p' âˆ˜ p) (fun a => q a â‰« q' (p a)) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map'_comp_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ng h : Î² â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasCoproduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct g\ninstâœ : CategoryTheory.Limits.HasCoproduct h\np : Î± â†’ Î²\nq : (a : Î±) â†’ Quiver.Hom (f a) (g (p a))\nq' : (b : Î²) â†’ Quiver.Hom (g b) (h b)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.map' p q) (CategoryTheory.Limits.Sigma.map q')) (CategoryTheory.Limits.Sigma.map' p fun a => CategoryTheory.CategoryStruct.comp (q a) (q' (p a)))","decl":"lemma Sigma.map'_comp_map {f : Î± â†’ C} {g h : Î² â†’ C} [HasCoproduct f] [HasCoproduct g]\n    [HasCoproduct h] (p : Î± â†’ Î²) (q : âˆ€ (a : Î±), f a âŸ¶ g (p a)) (q' : âˆ€ (b : Î²), g b âŸ¶ h b) :\n    Sigma.map' p q â‰« Sigma.map q' = Sigma.map' p (fun a => q a â‰« q' (p a)) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map_comp_map'","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nf g : Î± â†’ C\nh : Î² â†’ C\ninstâœÂ² : CategoryTheory.Limits.HasCoproduct f\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct g\ninstâœ : CategoryTheory.Limits.HasCoproduct h\np : Î± â†’ Î²\nq : (a : Î±) â†’ Quiver.Hom (f a) (g a)\nq' : (a : Î±) â†’ Quiver.Hom (g a) (h (p a))\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.map q) (CategoryTheory.Limits.Sigma.map' p q')) (CategoryTheory.Limits.Sigma.map' p fun a => CategoryTheory.CategoryStruct.comp (q a) (q' a))","decl":"lemma Sigma.map_comp_map' {f g : Î± â†’ C} {h : Î² â†’ C} [HasCoproduct f] [HasCoproduct g]\n    [HasCoproduct h] (p : Î± â†’ Î²) (q : âˆ€ (a : Î±), f a âŸ¶ g a) (q' : âˆ€ (a : Î±), g a âŸ¶ h (p a)) :\n    Sigma.map q â‰« Sigma.map' p q' = Sigma.map' p (fun a => q a â‰« q' a) := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map'_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nÎ± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nf : Î± â†’ C\ng : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct g\np p' : Î± â†’ Î²\nq : (a : Î±) â†’ Quiver.Hom (f a) (g (p a))\nq' : (a : Î±) â†’ Quiver.Hom (f a) (g (p' a))\nhp : Eq p p'\nhq : âˆ€ (a : Î±), Eq (CategoryTheory.CategoryStruct.comp (q a) (CategoryTheory.eqToHom â‹¯)) (q' a)\nâŠ¢ Eq (CategoryTheory.Limits.Sigma.map' p q) (CategoryTheory.Limits.Sigma.map' p' q')","decl":"lemma Sigma.map'_eq {f : Î± â†’ C} {g : Î² â†’ C} [HasCoproduct f] [HasCoproduct g]\n    {p p' : Î± â†’ Î²} {q : âˆ€ (a : Î±), f a âŸ¶ g (p a)} {q' : âˆ€ (a : Î±), f a âŸ¶ g (p' a)}\n    (hp : p = p') (hq : âˆ€ (a : Î±), q a â‰« eqToHom (hp â–¸ rfl) = q' a) :\n    Sigma.map' p q = Sigma.map' p' q' := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.Sigma.map_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nf g : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproductsOfShape Î² C\np : (b : Î²) â†’ Quiver.Hom (f b) (g b)\ninstâœ : âˆ€ (b : Î²), CategoryTheory.IsIso (p b)\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.Sigma.map p)","decl":"instance Sigma.map_isIso {f g : Î² â†’ C} [HasCoproductsOfShape Î² C] (p : âˆ€ b, f b âŸ¶ g b)\n    [âˆ€ b, IsIso <| p b] : IsIso (Sigma.map p) :=\n  inferInstanceAs (IsIso (Sigma.mapIso (fun b â†¦ asIso (p b))).hom)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.cocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete Î±) C\ninstâœ : CategoryTheory.Limits.HasCoproduct fun j => X.obj { as := j }\nâŠ¢ Eq (CategoryTheory.Limits.Sigma.cocone X).pt (CategoryTheory.Limits.sigmaObj fun j => X.obj { as := j })","decl":"/-- A colimit cocone for `X : Discrete Î± â¥¤ C` that is given\nby `âˆ (fun j => X.obj (Discrete.mk j))`. -/\n@[simps]\ndef Sigma.cocone : Cocone X where\n  pt := âˆ (fun j => X.obj (Discrete.mk j))\n  Î¹ := Discrete.natTrans (fun _ => Sigma.Î¹ (fun j â†¦ X.obj âŸ¨jâŸ©) _)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.cocone_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete Î±) C\ninstâœ : CategoryTheory.Limits.HasCoproduct fun j => X.obj { as := j }\nâŠ¢ Eq (CategoryTheory.Limits.Sigma.cocone X).Î¹ (CategoryTheory.Discrete.natTrans fun x => CategoryTheory.Limits.Sigma.Î¹ (fun j => X.obj { as := j }) x.as)","decl":"/-- A colimit cocone for `X : Discrete Î± â¥¤ C` that is given\nby `âˆ (fun j => X.obj (Discrete.mk j))`. -/\n@[simps]\ndef Sigma.cocone : Cocone X where\n  pt := âˆ (fun j => X.obj (Discrete.mk j))\n  Î¹ := Discrete.natTrans (fun _ => Sigma.Î¹ (fun j â†¦ X.obj âŸ¨jâŸ©) _)\n\n"}
{"name":"CategoryTheory.Limits.Sigma.Î¹_isoColimit_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete Î±) C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct fun j => X.obj { as := j }\ninstâœ : CategoryTheory.Limits.HasColimit X\nj : Î±\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (fun j => X.obj { as := j }) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.isoColimit X).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ X { as := j }) h)","decl":"@[reassoc (attr := simp)]\nlemma Sigma.Î¹_isoColimit_hom (j : Î±) :\n    Sigma.Î¹ _ j â‰« (Sigma.isoColimit X).hom = colimit.Î¹ _ (Discrete.mk j) :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom (coproductIsCoproduct' X) _ _\n\n"}
{"name":"CategoryTheory.Limits.Sigma.Î¹_isoColimit_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete Î±) C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct fun j => X.obj { as := j }\ninstâœ : CategoryTheory.Limits.HasColimit X\nj : Î±\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (fun j => X.obj { as := j }) j) (CategoryTheory.Limits.Sigma.isoColimit X).hom) (CategoryTheory.Limits.colimit.Î¹ X { as := j })","decl":"@[reassoc (attr := simp)]\nlemma Sigma.Î¹_isoColimit_hom (j : Î±) :\n    Sigma.Î¹ _ j â‰« (Sigma.isoColimit X).hom = colimit.Î¹ _ (Discrete.mk j) :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom (coproductIsCoproduct' X) _ _\n\n"}
{"name":"CategoryTheory.Limits.Sigma.Î¹_isoColimit_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete Î±) C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct fun j => X.obj { as := j }\ninstâœ : CategoryTheory.Limits.HasColimit X\nj : Î±\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ X { as := j }) (CategoryTheory.Limits.Sigma.isoColimit X).inv) (CategoryTheory.Limits.Sigma.Î¹ (fun j => X.obj { as := j }) j)","decl":"@[reassoc (attr := simp)]\nlemma Sigma.Î¹_isoColimit_inv (j : Î±) :\n    colimit.Î¹ _ âŸ¨jâŸ© â‰« (Sigma.isoColimit X).inv = Sigma.Î¹ (fun j â†¦ X.obj âŸ¨jâŸ©) _ :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Sigma.Î¹_isoColimit_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î± : Type wâ‚‚\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Functor (CategoryTheory.Discrete Î±) C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct fun j => X.obj { as := j }\ninstâœ : CategoryTheory.Limits.HasColimit X\nj : Î±\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj fun j => X.obj { as := j }) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ X { as := j }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.isoColimit X).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (fun j => X.obj { as := j }) j) h)","decl":"@[reassoc (attr := simp)]\nlemma Sigma.Î¹_isoColimit_inv (j : Î±) :\n    colimit.Î¹ _ âŸ¨jâŸ© â‰« (Sigma.isoColimit X).inv = Sigma.Î¹ (fun j â†¦ X.obj âŸ¨jâŸ©) _ :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Pi.whiskerEquiv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nK : Type u_2\nf : J â†’ C\ng : K â†’ C\ne : Equiv J K\nw : (j : J) â†’ CategoryTheory.Iso (g (e j)) (f j)\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct g\nâŠ¢ Eq (CategoryTheory.Limits.Pi.whiskerEquiv e w).hom (CategoryTheory.Limits.Pi.map' â‡‘e.symm fun k => CategoryTheory.CategoryStruct.comp (w (e.symm k)).inv (CategoryTheory.eqToHom â‹¯))","decl":"/-- Two products which differ by an equivalence in the indexing type,\nand up to isomorphism in the factors, are isomorphic.\n-/\n@[simps]\ndef Pi.whiskerEquiv {J K : Type*} {f : J â†’ C} {g : K â†’ C} (e : J â‰ƒ K) (w : âˆ€ j, g (e j) â‰… f j)\n    [HasProduct f] [HasProduct g] : âˆá¶œ f â‰… âˆá¶œ g where\n  hom := Pi.map' e.symm fun k => (w (e.symm k)).inv â‰« eqToHom (by simp)\n  inv := Pi.map' e fun j => (w j).hom\n\n"}
{"name":"CategoryTheory.Limits.Pi.whiskerEquiv_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nK : Type u_2\nf : J â†’ C\ng : K â†’ C\ne : Equiv J K\nw : (j : J) â†’ CategoryTheory.Iso (g (e j)) (f j)\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct g\nâŠ¢ Eq (CategoryTheory.Limits.Pi.whiskerEquiv e w).inv (CategoryTheory.Limits.Pi.map' â‡‘e fun j => (w j).hom)","decl":"/-- Two products which differ by an equivalence in the indexing type,\nand up to isomorphism in the factors, are isomorphic.\n-/\n@[simps]\ndef Pi.whiskerEquiv {J K : Type*} {f : J â†’ C} {g : K â†’ C} (e : J â‰ƒ K) (w : âˆ€ j, g (e j) â‰… f j)\n    [HasProduct f] [HasProduct g] : âˆá¶œ f â‰… âˆá¶œ g where\n  hom := Pi.map' e.symm fun k => (w (e.symm k)).inv â‰« eqToHom (by simp)\n  inv := Pi.map' e fun j => (w j).hom\n\n"}
{"name":"CategoryTheory.Limits.Sigma.whiskerEquiv_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nK : Type u_2\nf : J â†’ C\ng : K â†’ C\ne : Equiv J K\nw : (j : J) â†’ CategoryTheory.Iso (g (e j)) (f j)\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct g\nâŠ¢ Eq (CategoryTheory.Limits.Sigma.whiskerEquiv e w).inv (CategoryTheory.Limits.Sigma.map' â‡‘e.symm fun k => CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (w (e.symm k)).hom)","decl":"/-- Two coproducts which differ by an equivalence in the indexing type,\nand up to isomorphism in the factors, are isomorphic.\n-/\n@[simps]\ndef Sigma.whiskerEquiv {J K : Type*} {f : J â†’ C} {g : K â†’ C} (e : J â‰ƒ K) (w : âˆ€ j, g (e j) â‰… f j)\n    [HasCoproduct f] [HasCoproduct g] : âˆ f â‰… âˆ g where\n  hom := Sigma.map' e fun j => (w j).inv\n  inv := Sigma.map' e.symm fun k => eqToHom (by simp) â‰« (w (e.symm k)).hom\n\n"}
{"name":"CategoryTheory.Limits.Sigma.whiskerEquiv_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nK : Type u_2\nf : J â†’ C\ng : K â†’ C\ne : Equiv J K\nw : (j : J) â†’ CategoryTheory.Iso (g (e j)) (f j)\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct g\nâŠ¢ Eq (CategoryTheory.Limits.Sigma.whiskerEquiv e w).hom (CategoryTheory.Limits.Sigma.map' â‡‘e fun j => (w j).inv)","decl":"/-- Two coproducts which differ by an equivalence in the indexing type,\nand up to isomorphism in the factors, are isomorphic.\n-/\n@[simps]\ndef Sigma.whiskerEquiv {J K : Type*} {f : J â†’ C} {g : K â†’ C} (e : J â‰ƒ K) (w : âˆ€ j, g (e j) â‰… f j)\n    [HasCoproduct f] [HasCoproduct g] : âˆ f â‰… âˆ g where\n  hom := Sigma.map' e fun j => (w j).inv\n  inv := Sigma.map' e.symm fun k => eqToHom (by simp) â‰« (w (e.symm k)).hom\n\n"}
{"name":"CategoryTheory.Limits.instHasProductSigmaFstSndOfPiObj","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ¹ : Type u_1\nf : Î¹ â†’ Type u_2\ng : (i : Î¹) â†’ f i â†’ C\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasProduct (g i)\ninstâœ : CategoryTheory.Limits.HasProduct fun i => CategoryTheory.Limits.piObj (g i)\nâŠ¢ CategoryTheory.Limits.HasProduct fun p => g p.fst p.snd","decl":"instance {Î¹ : Type*} (f : Î¹ â†’ Type*) (g : (i : Î¹) â†’ (f i) â†’ C)\n    [âˆ€ i, HasProduct (g i)] [HasProduct fun i => âˆá¶œ g i] :\n    HasProduct fun p : Î£ i, f i => g p.1 p.2 where\n  exists_limit := Nonempty.intro\n    { cone := Fan.mk (âˆá¶œ fun i => âˆá¶œ g i) (fun X => Pi.Ï€ (fun i => âˆá¶œ g i) X.1 â‰« Pi.Ï€ (g X.1) X.2)\n      isLimit := mkFanLimit _ (fun s => Pi.lift fun b => Pi.lift fun c => s.proj âŸ¨b, câŸ©)\n        (by simp)\n        (by intro s m w; simp only [Fan.mk_pt]; symm; ext i x; simp_all [Sigma.forall]) }\n\n"}
{"name":"CategoryTheory.Limits.piPiIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ¹ : Type u_1\nf : Î¹ â†’ Type u_2\ng : (i : Î¹) â†’ f i â†’ C\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasProduct (g i)\ninstâœ : CategoryTheory.Limits.HasProduct fun i => CategoryTheory.Limits.piObj (g i)\nâŠ¢ Eq (CategoryTheory.Limits.piPiIso f g).inv (CategoryTheory.Limits.Pi.lift fun i => CategoryTheory.Limits.Pi.lift fun x => CategoryTheory.Limits.Pi.Ï€ (fun p => g p.fst p.snd) âŸ¨i, xâŸ©)","decl":"/-- An iterated product is a product over a sigma type. -/\n@[simps]\ndef piPiIso {Î¹ : Type*} (f : Î¹ â†’ Type*) (g : (i : Î¹) â†’ (f i) â†’ C)\n    [âˆ€ i, HasProduct (g i)] [HasProduct fun i => âˆá¶œ g i] :\n    (âˆá¶œ fun i => âˆá¶œ g i) â‰… (âˆá¶œ fun p : Î£ i, f i => g p.1 p.2) where\n  hom := Pi.lift fun âŸ¨i, xâŸ© => Pi.Ï€ _ i â‰« Pi.Ï€ _ x\n  inv := Pi.lift fun i => Pi.lift fun x => Pi.Ï€ _ (âŸ¨i, xâŸ© : Î£ i, f i)\n\n"}
{"name":"CategoryTheory.Limits.piPiIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ¹ : Type u_1\nf : Î¹ â†’ Type u_2\ng : (i : Î¹) â†’ f i â†’ C\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasProduct (g i)\ninstâœ : CategoryTheory.Limits.HasProduct fun i => CategoryTheory.Limits.piObj (g i)\nâŠ¢ Eq (CategoryTheory.Limits.piPiIso f g).hom (CategoryTheory.Limits.Pi.lift fun x => CategoryTheory.Limits.piPiIso.match_1 f (fun x => Quiver.Hom (CategoryTheory.Limits.piObj fun i => CategoryTheory.Limits.piObj (g i)) (g x.fst x.snd)) x fun i x => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ (fun i => CategoryTheory.Limits.piObj (g i)) i) (CategoryTheory.Limits.Pi.Ï€ (g i) x))","decl":"/-- An iterated product is a product over a sigma type. -/\n@[simps]\ndef piPiIso {Î¹ : Type*} (f : Î¹ â†’ Type*) (g : (i : Î¹) â†’ (f i) â†’ C)\n    [âˆ€ i, HasProduct (g i)] [HasProduct fun i => âˆá¶œ g i] :\n    (âˆá¶œ fun i => âˆá¶œ g i) â‰… (âˆá¶œ fun p : Î£ i, f i => g p.1 p.2) where\n  hom := Pi.lift fun âŸ¨i, xâŸ© => Pi.Ï€ _ i â‰« Pi.Ï€ _ x\n  inv := Pi.lift fun i => Pi.lift fun x => Pi.Ï€ _ (âŸ¨i, xâŸ© : Î£ i, f i)\n\n"}
{"name":"CategoryTheory.Limits.instHasCoproductSigmaFstSndOfSigmaObj","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ¹ : Type u_1\nf : Î¹ â†’ Type u_2\ng : (i : Î¹) â†’ f i â†’ C\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasCoproduct (g i)\ninstâœ : CategoryTheory.Limits.HasCoproduct fun i => CategoryTheory.Limits.sigmaObj (g i)\nâŠ¢ CategoryTheory.Limits.HasCoproduct fun p => g p.fst p.snd","decl":"instance {Î¹ : Type*} (f : Î¹ â†’ Type*) (g : (i : Î¹) â†’ (f i) â†’ C)\n    [âˆ€ i, HasCoproduct (g i)] [HasCoproduct fun i => âˆ g i] :\n    HasCoproduct fun p : Î£ i, f i => g p.1 p.2 where\n  exists_colimit := Nonempty.intro\n    { cocone := Cofan.mk (âˆ fun i => âˆ g i)\n        (fun X => Sigma.Î¹ (g X.1) X.2 â‰« Sigma.Î¹ (fun i => âˆ g i) X.1)\n      isColimit := mkCofanColimit _\n        (fun s => Sigma.desc fun b => Sigma.desc fun c => s.inj âŸ¨b, câŸ©)\n        (by simp)\n        (by intro s m w; simp only [Cofan.mk_pt]; symm; ext i x; simp_all [Sigma.forall]) }\n\n"}
{"name":"CategoryTheory.Limits.sigmaSigmaIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ¹ : Type u_1\nf : Î¹ â†’ Type u_2\ng : (i : Î¹) â†’ f i â†’ C\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasCoproduct (g i)\ninstâœ : CategoryTheory.Limits.HasCoproduct fun i => CategoryTheory.Limits.sigmaObj (g i)\nâŠ¢ Eq (CategoryTheory.Limits.sigmaSigmaIso f g).hom (CategoryTheory.Limits.Sigma.desc fun i => CategoryTheory.Limits.Sigma.desc fun x => CategoryTheory.Limits.Sigma.Î¹ (fun p => g p.fst p.snd) âŸ¨i, xâŸ©)","decl":"/-- An iterated coproduct is a coproduct over a sigma type. -/\n@[simps]\ndef sigmaSigmaIso {Î¹ : Type*} (f : Î¹ â†’ Type*) (g : (i : Î¹) â†’ (f i) â†’ C)\n    [âˆ€ i, HasCoproduct (g i)] [HasCoproduct fun i => âˆ g i] :\n    (âˆ fun i => âˆ g i) â‰… (âˆ fun p : Î£ i, f i => g p.1 p.2) where\n  hom := Sigma.desc fun i => Sigma.desc fun x => Sigma.Î¹ (fun p : Î£ i, f i => g p.1 p.2) âŸ¨i, xâŸ©\n  inv := Sigma.desc fun âŸ¨i, xâŸ© => Sigma.Î¹ (g i) x â‰« Sigma.Î¹ (fun i => âˆ g i) i\n\n"}
{"name":"CategoryTheory.Limits.sigmaSigmaIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ¹ : Type u_1\nf : Î¹ â†’ Type u_2\ng : (i : Î¹) â†’ f i â†’ C\ninstâœÂ¹ : âˆ€ (i : Î¹), CategoryTheory.Limits.HasCoproduct (g i)\ninstâœ : CategoryTheory.Limits.HasCoproduct fun i => CategoryTheory.Limits.sigmaObj (g i)\nâŠ¢ Eq (CategoryTheory.Limits.sigmaSigmaIso f g).inv (CategoryTheory.Limits.Sigma.desc fun x => CategoryTheory.Limits.piPiIso.match_1 f (fun x => Quiver.Hom (g x.fst x.snd) (CategoryTheory.Limits.sigmaObj fun i => CategoryTheory.Limits.sigmaObj (g i))) x fun i x => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (g i) x) (CategoryTheory.Limits.Sigma.Î¹ (fun i => CategoryTheory.Limits.sigmaObj (g i)) i))","decl":"/-- An iterated coproduct is a coproduct over a sigma type. -/\n@[simps]\ndef sigmaSigmaIso {Î¹ : Type*} (f : Î¹ â†’ Type*) (g : (i : Î¹) â†’ (f i) â†’ C)\n    [âˆ€ i, HasCoproduct (g i)] [HasCoproduct fun i => âˆ g i] :\n    (âˆ fun i => âˆ g i) â‰… (âˆ fun p : Î£ i, f i => g p.1 p.2) where\n  hom := Sigma.desc fun i => Sigma.desc fun x => Sigma.Î¹ (fun p : Î£ i, f i => g p.1 p.2) âŸ¨i, xâŸ©\n  inv := Sigma.desc fun âŸ¨i, xâŸ© => Sigma.Î¹ (g i) x â‰« Sigma.Î¹ (fun i => âˆ g i) i\n\n"}
{"name":"CategoryTheory.Limits.piComparison_comp_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nG : CategoryTheory.Functor C D\nf : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct fun b => G.obj (f b)\nb : Î²\nZ : D\nh : Quiver.Hom (G.obj (f b)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.piComparison G f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ (fun b => G.obj (f b)) b) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.Pi.Ï€ f b)) h)","decl":"@[reassoc (attr := simp)]\ntheorem piComparison_comp_Ï€ [HasProduct f] [HasProduct fun b => G.obj (f b)] (b : Î²) :\n    piComparison G f â‰« Pi.Ï€ _ b = G.map (Pi.Ï€ f b) :=\n  limit.lift_Ï€ _ (Discrete.mk b)\n\n"}
{"name":"CategoryTheory.Limits.piComparison_comp_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nG : CategoryTheory.Functor C D\nf : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct fun b => G.obj (f b)\nb : Î²\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.piComparison G f) (CategoryTheory.Limits.Pi.Ï€ (fun b => G.obj (f b)) b)) (G.map (CategoryTheory.Limits.Pi.Ï€ f b))","decl":"@[reassoc (attr := simp)]\ntheorem piComparison_comp_Ï€ [HasProduct f] [HasProduct fun b => G.obj (f b)] (b : Î²) :\n    piComparison G f â‰« Pi.Ï€ _ b = G.map (Pi.Ï€ f b) :=\n  limit.lift_Ï€ _ (Discrete.mk b)\n\n"}
{"name":"CategoryTheory.Limits.map_lift_piComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nG : CategoryTheory.Functor C D\nf : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct fun b => G.obj (f b)\nP : C\ng : (j : Î²) â†’ Quiver.Hom P (f j)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.Pi.lift g)) (CategoryTheory.Limits.piComparison G f)) (CategoryTheory.Limits.Pi.lift fun j => G.map (g j))","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_piComparison [HasProduct f] [HasProduct fun b => G.obj (f b)] (P : C)\n    (g : âˆ€ j, P âŸ¶ f j) : G.map (Pi.lift g) â‰« piComparison G f = Pi.lift fun j => G.map (g j) := by\n  ext j\n  simp only [Discrete.functor_obj, Category.assoc, piComparison_comp_Ï€, â† G.map_comp,\n    limit.lift_Ï€, Fan.mk_pt, Fan.mk_Ï€_app]\n\n"}
{"name":"CategoryTheory.Limits.map_lift_piComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nG : CategoryTheory.Functor C D\nf : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct fun b => G.obj (f b)\nP : C\ng : (j : Î²) â†’ Quiver.Hom P (f j)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.piObj fun b => G.obj (f b)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.Pi.lift g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.piComparison G f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.lift fun j => G.map (g j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_piComparison [HasProduct f] [HasProduct fun b => G.obj (f b)] (P : C)\n    (g : âˆ€ j, P âŸ¶ f j) : G.map (Pi.lift g) â‰« piComparison G f = Pi.lift fun j => G.map (g j) := by\n  ext j\n  simp only [Discrete.functor_obj, Category.assoc, piComparison_comp_Ï€, â† G.map_comp,\n    limit.lift_Ï€, Fan.mk_pt, Fan.mk_Ï€_app]\n\n"}
{"name":"CategoryTheory.Limits.Î¹_comp_sigmaComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nG : CategoryTheory.Functor C D\nf : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct fun b => G.obj (f b)\nb : Î²\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (fun b => G.obj (f b)) b) (CategoryTheory.Limits.sigmaComparison G f)) (G.map (CategoryTheory.Limits.Sigma.Î¹ f b))","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_comp_sigmaComparison [HasCoproduct f] [HasCoproduct fun b => G.obj (f b)] (b : Î²) :\n    Sigma.Î¹ _ b â‰« sigmaComparison G f = G.map (Sigma.Î¹ f b) :=\n  colimit.Î¹_desc _ (Discrete.mk b)\n\n"}
{"name":"CategoryTheory.Limits.Î¹_comp_sigmaComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nG : CategoryTheory.Functor C D\nf : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct fun b => G.obj (f b)\nb : Î²\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.sigmaObj f)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (fun b => G.obj (f b)) b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.sigmaComparison G f) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.Sigma.Î¹ f b)) h)","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_comp_sigmaComparison [HasCoproduct f] [HasCoproduct fun b => G.obj (f b)] (b : Î²) :\n    Sigma.Î¹ _ b â‰« sigmaComparison G f = G.map (Sigma.Î¹ f b) :=\n  colimit.Î¹_desc _ (Discrete.mk b)\n\n"}
{"name":"CategoryTheory.Limits.sigmaComparison_map_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nG : CategoryTheory.Functor C D\nf : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct fun b => G.obj (f b)\nP : C\ng : (j : Î²) â†’ Quiver.Hom (f j) P\nZ : D\nh : Quiver.Hom (G.obj P) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.sigmaComparison G f) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.Sigma.desc g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.desc fun j => G.map (g j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem sigmaComparison_map_desc [HasCoproduct f] [HasCoproduct fun b => G.obj (f b)] (P : C)\n    (g : âˆ€ j, f j âŸ¶ P) :\n    sigmaComparison G f â‰« G.map (Sigma.desc g) = Sigma.desc fun j => G.map (g j) := by\n  ext j\n  simp only [Discrete.functor_obj, Î¹_comp_sigmaComparison_assoc, â† G.map_comp, colimit.Î¹_desc,\n    Cofan.mk_pt, Cofan.mk_Î¹_app]\n\n"}
{"name":"CategoryTheory.Limits.sigmaComparison_map_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nG : CategoryTheory.Functor C D\nf : Î² â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct fun b => G.obj (f b)\nP : C\ng : (j : Î²) â†’ Quiver.Hom (f j) P\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.sigmaComparison G f) (G.map (CategoryTheory.Limits.Sigma.desc g))) (CategoryTheory.Limits.Sigma.desc fun j => G.map (g j))","decl":"@[reassoc (attr := simp)]\ntheorem sigmaComparison_map_desc [HasCoproduct f] [HasCoproduct fun b => G.obj (f b)] (P : C)\n    (g : âˆ€ j, f j âŸ¶ P) :\n    sigmaComparison G f â‰« G.map (Sigma.desc g) = Sigma.desc fun j => G.map (g j) := by\n  ext j\n  simp only [Discrete.functor_obj, Î¹_comp_sigmaComparison_assoc, â† G.map_comp, colimit.Î¹_desc,\n    Cofan.mk_pt, Cofan.mk_Î¹_app]\n\n"}
{"name":"CategoryTheory.Limits.hasProducts_shrink","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasProducts C\nâŠ¢ CategoryTheory.Limits.HasProducts C","decl":"lemma hasProducts_shrink [HasProducts.{max w w'} C] : HasProducts.{w} C := fun J =>\n  hasLimitsOfShape_of_equivalence (Discrete.equivalence Equiv.ulift : Discrete (ULift.{w'} J) â‰Œ _)\n\n"}
{"name":"CategoryTheory.Limits.hasCoproducts_shrink","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasCoproducts C\nâŠ¢ CategoryTheory.Limits.HasCoproducts C","decl":"lemma hasCoproducts_shrink [HasCoproducts.{max w w'} C] : HasCoproducts.{w} C := fun J =>\n  hasColimitsOfShape_of_equivalence (Discrete.equivalence Equiv.ulift : Discrete (ULift.{w'} J) â‰Œ _)\n\n"}
{"name":"CategoryTheory.Limits.has_smallest_products_of_hasProducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasProducts C\nâŠ¢ CategoryTheory.Limits.HasProducts C","decl":"theorem has_smallest_products_of_hasProducts [HasProducts.{w} C] : HasProducts.{0} C :=\n  hasProducts_shrink\n\n"}
{"name":"CategoryTheory.Limits.has_smallest_coproducts_of_hasCoproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasCoproducts C\nâŠ¢ CategoryTheory.Limits.HasCoproducts C","decl":"theorem has_smallest_coproducts_of_hasCoproducts [HasCoproducts.{w} C] : HasCoproducts.{0} C :=\n  hasCoproducts_shrink\n\n"}
{"name":"CategoryTheory.Limits.hasProducts_of_limit_fans","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nlf : {J : Type w} â†’ (f : J â†’ C) â†’ CategoryTheory.Limits.Fan f\nlf_isLimit : {J : Type w} â†’ (f : J â†’ C) â†’ CategoryTheory.Limits.IsLimit (lf f)\nâŠ¢ CategoryTheory.Limits.HasProducts C","decl":"theorem hasProducts_of_limit_fans (lf : âˆ€ {J : Type w} (f : J â†’ C), Fan f)\n    (lf_isLimit : âˆ€ {J : Type w} (f : J â†’ C), IsLimit (lf f)) : HasProducts.{w} C :=\n  fun _ : Type w =>\n  { has_limit := fun F =>\n      HasLimit.mk\n        âŸ¨(Cones.postcompose Discrete.natIsoFunctor.inv).obj (lf fun j => F.obj âŸ¨jâŸ©),\n          (IsLimit.postcomposeInvEquiv _ _).symm (lf_isLimit _)âŸ© }\n\n"}
{"name":"CategoryTheory.Limits.hasProductsOfShape_of_hasProducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasProducts C\nJ : Type w\nâŠ¢ CategoryTheory.Limits.HasProductsOfShape J C","decl":"instance (priority := 100) hasProductsOfShape_of_hasProducts [HasProducts.{w} C] (J : Type w) :\n    HasProductsOfShape J C := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasCoproductsOfShape_of_hasCoproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasCoproducts C\nJ : Type w\nâŠ¢ CategoryTheory.Limits.HasCoproductsOfShape J C","decl":"instance (priority := 100) hasCoproductsOfShape_of_hasCoproducts [HasCoproducts.{w} C]\n    (J : Type w) : HasCoproductsOfShape J C := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.limitConeOfUnique_isLimit_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : Unique Î²\nf : Î² â†’ C\ns : CategoryTheory.Limits.Cone (CategoryTheory.Discrete.functor f)\nâŠ¢ Eq ((CategoryTheory.Limits.limitConeOfUnique f).isLimit.lift s) (s.Ï€.app Inhabited.default)","decl":"/-- The limit cone for the product over an index type with exactly one term. -/\n@[simps]\ndef limitConeOfUnique [Unique Î²] (f : Î² â†’ C) : LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := f default\n      Ï€ := Discrete.natTrans (fun âŸ¨jâŸ© => eqToHom (by\n        dsimp\n        congr\n        subsingleton)) }\n  isLimit :=\n    { lift := fun s => s.Ï€.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        simp\n      uniq := fun s m w => by\n        specialize w default\n        simpa using w }\n\n"}
{"name":"CategoryTheory.Limits.limitConeOfUnique_cone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : Unique Î²\nf : Î² â†’ C\nâŠ¢ Eq (CategoryTheory.Limits.limitConeOfUnique f).cone.pt (f Inhabited.default)","decl":"/-- The limit cone for the product over an index type with exactly one term. -/\n@[simps]\ndef limitConeOfUnique [Unique Î²] (f : Î² â†’ C) : LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := f default\n      Ï€ := Discrete.natTrans (fun âŸ¨jâŸ© => eqToHom (by\n        dsimp\n        congr\n        subsingleton)) }\n  isLimit :=\n    { lift := fun s => s.Ï€.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        simp\n      uniq := fun s m w => by\n        specialize w default\n        simpa using w }\n\n"}
{"name":"CategoryTheory.Limits.limitConeOfUnique_cone_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : Unique Î²\nf : Î² â†’ C\nâŠ¢ Eq (CategoryTheory.Limits.limitConeOfUnique f).cone.Ï€ (CategoryTheory.Discrete.natTrans fun x => CategoryTheory.Limits.limitConeOfUnique.match_1 (fun x => Quiver.Hom (((CategoryTheory.Functor.const (CategoryTheory.Discrete Î²)).obj (f Inhabited.default)).obj x) ((CategoryTheory.Discrete.functor f).obj x)) x fun j => CategoryTheory.eqToHom â‹¯)","decl":"/-- The limit cone for the product over an index type with exactly one term. -/\n@[simps]\ndef limitConeOfUnique [Unique Î²] (f : Î² â†’ C) : LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := f default\n      Ï€ := Discrete.natTrans (fun âŸ¨jâŸ© => eqToHom (by\n        dsimp\n        congr\n        subsingleton)) }\n  isLimit :=\n    { lift := fun s => s.Ï€.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        simp\n      uniq := fun s m w => by\n        specialize w default\n        simpa using w }\n\n"}
{"name":"CategoryTheory.Limits.hasProduct_unique","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : Nonempty Î²\ninstâœ : Subsingleton Î²\nf : Î² â†’ C\nâŠ¢ CategoryTheory.Limits.HasProduct f","decl":"instance (priority := 100) hasProduct_unique [Nonempty Î²] [Subsingleton Î²] (f : Î² â†’ C) :\n    HasProduct f :=\n  let âŸ¨_âŸ© := nonempty_unique Î²; HasLimit.mk (limitConeOfUnique f)\n\n"}
{"name":"CategoryTheory.Limits.productUniqueIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : Unique Î²\nf : Î² â†’ C\nâŠ¢ Eq (CategoryTheory.Limits.productUniqueIso f).hom (CategoryTheory.Limits.limit.Ï€ (CategoryTheory.Discrete.functor f) Inhabited.default)","decl":"/-- A product over an index type with exactly one term is just the object over that term. -/\n@[simps!]\ndef productUniqueIso [Unique Î²] (f : Î² â†’ C) : âˆá¶œ f â‰… f default :=\n  IsLimit.conePointUniqueUpToIso (limit.isLimit _) (limitConeOfUnique f).isLimit\n\n"}
{"name":"CategoryTheory.Limits.productUniqueIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : Unique Î²\nf : Î² â†’ C\nâŠ¢ Eq (CategoryTheory.Limits.productUniqueIso f).inv (CategoryTheory.Limits.limit.lift (CategoryTheory.Discrete.functor f) (CategoryTheory.Limits.limitConeOfUnique f).cone)","decl":"/-- A product over an index type with exactly one term is just the object over that term. -/\n@[simps!]\ndef productUniqueIso [Unique Î²] (f : Î² â†’ C) : âˆá¶œ f â‰… f default :=\n  IsLimit.conePointUniqueUpToIso (limit.isLimit _) (limitConeOfUnique f).isLimit\n\n"}
{"name":"CategoryTheory.Limits.colimitCoconeOfUnique_cocone_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : Unique Î²\nf : Î² â†’ C\nâŠ¢ Eq (CategoryTheory.Limits.colimitCoconeOfUnique f).cocone.Î¹ (CategoryTheory.Discrete.natTrans fun x => CategoryTheory.Limits.limitConeOfUnique.match_1 (fun x => Quiver.Hom ((CategoryTheory.Discrete.functor f).obj x) (((CategoryTheory.Functor.const (CategoryTheory.Discrete Î²)).obj (f Inhabited.default)).obj x)) x fun j => CategoryTheory.eqToHom â‹¯)","decl":"/-- The colimit cocone for the coproduct over an index type with exactly one term. -/\n@[simps]\ndef colimitCoconeOfUnique [Unique Î²] (f : Î² â†’ C) : ColimitCocone (Discrete.functor f) where\n  cocone :=\n    { pt := f default\n      Î¹ := Discrete.natTrans (fun âŸ¨jâŸ© => eqToHom (by\n        dsimp\n        congr\n        subsingleton)) }\n  isColimit :=\n    { desc := fun s => s.Î¹.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        apply Category.id_comp\n      uniq := fun s m w => by\n        specialize w default\n        erw [Category.id_comp] at w\n        exact w }\n\n"}
{"name":"CategoryTheory.Limits.colimitCoconeOfUnique_cocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : Unique Î²\nf : Î² â†’ C\nâŠ¢ Eq (CategoryTheory.Limits.colimitCoconeOfUnique f).cocone.pt (f Inhabited.default)","decl":"/-- The colimit cocone for the coproduct over an index type with exactly one term. -/\n@[simps]\ndef colimitCoconeOfUnique [Unique Î²] (f : Î² â†’ C) : ColimitCocone (Discrete.functor f) where\n  cocone :=\n    { pt := f default\n      Î¹ := Discrete.natTrans (fun âŸ¨jâŸ© => eqToHom (by\n        dsimp\n        congr\n        subsingleton)) }\n  isColimit :=\n    { desc := fun s => s.Î¹.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        apply Category.id_comp\n      uniq := fun s m w => by\n        specialize w default\n        erw [Category.id_comp] at w\n        exact w }\n\n"}
{"name":"CategoryTheory.Limits.colimitCoconeOfUnique_isColimit_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : Unique Î²\nf : Î² â†’ C\ns : CategoryTheory.Limits.Cocone (CategoryTheory.Discrete.functor f)\nâŠ¢ Eq ((CategoryTheory.Limits.colimitCoconeOfUnique f).isColimit.desc s) (s.Î¹.app Inhabited.default)","decl":"/-- The colimit cocone for the coproduct over an index type with exactly one term. -/\n@[simps]\ndef colimitCoconeOfUnique [Unique Î²] (f : Î² â†’ C) : ColimitCocone (Discrete.functor f) where\n  cocone :=\n    { pt := f default\n      Î¹ := Discrete.natTrans (fun âŸ¨jâŸ© => eqToHom (by\n        dsimp\n        congr\n        subsingleton)) }\n  isColimit :=\n    { desc := fun s => s.Î¹.app default\n      fac := fun s j => by\n        have h := Subsingleton.elim j default\n        subst h\n        apply Category.id_comp\n      uniq := fun s m w => by\n        specialize w default\n        erw [Category.id_comp] at w\n        exact w }\n\n"}
{"name":"CategoryTheory.Limits.hasCoproduct_unique","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : Nonempty Î²\ninstâœ : Subsingleton Î²\nf : Î² â†’ C\nâŠ¢ CategoryTheory.Limits.HasCoproduct f","decl":"instance (priority := 100) hasCoproduct_unique [Nonempty Î²] [Subsingleton Î²] (f : Î² â†’ C) :\n    HasCoproduct f :=\n  let âŸ¨_âŸ© := nonempty_unique Î²; HasColimit.mk (colimitCoconeOfUnique f)\n\n"}
{"name":"CategoryTheory.Limits.coproductUniqueIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : Unique Î²\nf : Î² â†’ C\nâŠ¢ Eq (CategoryTheory.Limits.coproductUniqueIso f).hom (CategoryTheory.Limits.colimit.desc (CategoryTheory.Discrete.functor f) (CategoryTheory.Limits.colimitCoconeOfUnique f).cocone)","decl":"/-- A coproduct over an index type with exactly one term is just the object over that term. -/\n@[simps!]\ndef coproductUniqueIso [Unique Î²] (f : Î² â†’ C) : âˆ f â‰… f default :=\n  IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) (colimitCoconeOfUnique f).isColimit\n\n"}
{"name":"CategoryTheory.Limits.coproductUniqueIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : Unique Î²\nf : Î² â†’ C\nâŠ¢ Eq (CategoryTheory.Limits.coproductUniqueIso f).inv (CategoryTheory.Limits.colimit.Î¹ (CategoryTheory.Discrete.functor f) Inhabited.default)","decl":"/-- A coproduct over an index type with exactly one term is just the object over that term. -/\n@[simps!]\ndef coproductUniqueIso [Unique Î²] (f : Î² â†’ C) : âˆ f â‰… f default :=\n  IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) (colimitCoconeOfUnique f).isColimit\n\n"}
{"name":"CategoryTheory.Limits.Pi.reindex_hom_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ³ : Type w'\nÎµ : Equiv Î² Î³\nf : Î³ â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct (Function.comp f â‡‘Îµ)\nb : Î²\nZ : C\nh : Quiver.Hom (f (Îµ b)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.reindex Îµ f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ f (Îµ b)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ (Function.comp f â‡‘Îµ) b) h)","decl":"@[reassoc (attr := simp)]\ntheorem Pi.reindex_hom_Ï€ (b : Î²) : (Pi.reindex Îµ f).hom â‰« Pi.Ï€ f (Îµ b) = Pi.Ï€ (f âˆ˜ Îµ) b := by\n  dsimp [Pi.reindex]\n  simp only [HasLimit.isoOfEquivalence_hom_Ï€, Discrete.equivalence_inverse, Discrete.functor_obj,\n    Function.comp_apply, Functor.id_obj, Discrete.equivalence_functor, Functor.comp_obj,\n    Discrete.natIso_inv_app, Iso.refl_inv, Category.id_comp]\n  exact limit.w (Discrete.functor (f âˆ˜ Îµ)) (Discrete.eqToHom' (Îµ.symm_apply_apply b))\n\n"}
{"name":"CategoryTheory.Limits.Pi.reindex_hom_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ³ : Type w'\nÎµ : Equiv Î² Î³\nf : Î³ â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct (Function.comp f â‡‘Îµ)\nb : Î²\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.reindex Îµ f).hom (CategoryTheory.Limits.Pi.Ï€ f (Îµ b))) (CategoryTheory.Limits.Pi.Ï€ (Function.comp f â‡‘Îµ) b)","decl":"@[reassoc (attr := simp)]\ntheorem Pi.reindex_hom_Ï€ (b : Î²) : (Pi.reindex Îµ f).hom â‰« Pi.Ï€ f (Îµ b) = Pi.Ï€ (f âˆ˜ Îµ) b := by\n  dsimp [Pi.reindex]\n  simp only [HasLimit.isoOfEquivalence_hom_Ï€, Discrete.equivalence_inverse, Discrete.functor_obj,\n    Function.comp_apply, Functor.id_obj, Discrete.equivalence_functor, Functor.comp_obj,\n    Discrete.natIso_inv_app, Iso.refl_inv, Category.id_comp]\n  exact limit.w (Discrete.functor (f âˆ˜ Îµ)) (Discrete.eqToHom' (Îµ.symm_apply_apply b))\n\n"}
{"name":"CategoryTheory.Limits.Pi.reindex_inv_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ³ : Type w'\nÎµ : Equiv Î² Î³\nf : Î³ â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct (Function.comp f â‡‘Îµ)\nb : Î²\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.reindex Îµ f).inv (CategoryTheory.Limits.Pi.Ï€ (Function.comp f â‡‘Îµ) b)) (CategoryTheory.Limits.Pi.Ï€ f (Îµ b))","decl":"@[reassoc (attr := simp)]\ntheorem Pi.reindex_inv_Ï€ (b : Î²) : (Pi.reindex Îµ f).inv â‰« Pi.Ï€ (f âˆ˜ Îµ) b = Pi.Ï€ f (Îµ b) := by\n  simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.Pi.reindex_inv_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ³ : Type w'\nÎµ : Equiv Î² Î³\nf : Î³ â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasProduct f\ninstâœ : CategoryTheory.Limits.HasProduct (Function.comp f â‡‘Îµ)\nb : Î²\nZ : C\nh : Quiver.Hom (Function.comp f (â‡‘Îµ) b) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.reindex Îµ f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ (Function.comp f â‡‘Îµ) b) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.Ï€ f (Îµ b)) h)","decl":"@[reassoc (attr := simp)]\ntheorem Pi.reindex_inv_Ï€ (b : Î²) : (Pi.reindex Îµ f).inv â‰« Pi.Ï€ (f âˆ˜ Îµ) b = Pi.Ï€ f (Îµ b) := by\n  simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.Sigma.Î¹_reindex_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ³ : Type w'\nÎµ : Equiv Î² Î³\nf : Î³ â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct (Function.comp f â‡‘Îµ)\nb : Î²\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (Function.comp f â‡‘Îµ) b) (CategoryTheory.Limits.Sigma.reindex Îµ f).hom) (CategoryTheory.Limits.Sigma.Î¹ f (Îµ b))","decl":"@[reassoc (attr := simp)]\ntheorem Sigma.Î¹_reindex_hom (b : Î²) :\n    Sigma.Î¹ (f âˆ˜ Îµ) b â‰« (Sigma.reindex Îµ f).hom = Sigma.Î¹ f (Îµ b) := by\n  dsimp [Sigma.reindex]\n  simp only [HasColimit.isoOfEquivalence_hom_Ï€, Functor.id_obj, Discrete.functor_obj,\n    Function.comp_apply, Discrete.equivalence_functor, Discrete.equivalence_inverse,\n    Functor.comp_obj, Discrete.natIso_inv_app, Iso.refl_inv, Category.id_comp]\n  have h := colimit.w (Discrete.functor f) (Discrete.eqToHom' (Îµ.apply_symm_apply (Îµ b)))\n  simp only [Discrete.functor_obj] at h\n  erw [â† h, eqToHom_map, eqToHom_map, eqToHom_trans_assoc]\n  all_goals { simp }\n\n"}
{"name":"CategoryTheory.Limits.Sigma.Î¹_reindex_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ³ : Type w'\nÎµ : Equiv Î² Î³\nf : Î³ â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct (Function.comp f â‡‘Îµ)\nb : Î²\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj f) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (Function.comp f â‡‘Îµ) b) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.reindex Îµ f).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ f (Îµ b)) h)","decl":"@[reassoc (attr := simp)]\ntheorem Sigma.Î¹_reindex_hom (b : Î²) :\n    Sigma.Î¹ (f âˆ˜ Îµ) b â‰« (Sigma.reindex Îµ f).hom = Sigma.Î¹ f (Îµ b) := by\n  dsimp [Sigma.reindex]\n  simp only [HasColimit.isoOfEquivalence_hom_Ï€, Functor.id_obj, Discrete.functor_obj,\n    Function.comp_apply, Discrete.equivalence_functor, Discrete.equivalence_inverse,\n    Functor.comp_obj, Discrete.natIso_inv_app, Iso.refl_inv, Category.id_comp]\n  have h := colimit.w (Discrete.functor f) (Discrete.eqToHom' (Îµ.apply_symm_apply (Îµ b)))\n  simp only [Discrete.functor_obj] at h\n  erw [â† h, eqToHom_map, eqToHom_map, eqToHom_trans_assoc]\n  all_goals { simp }\n\n"}
{"name":"CategoryTheory.Limits.Sigma.Î¹_reindex_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ³ : Type w'\nÎµ : Equiv Î² Î³\nf : Î³ â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct (Function.comp f â‡‘Îµ)\nb : Î²\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ f (Îµ b)) (CategoryTheory.Limits.Sigma.reindex Îµ f).inv) (CategoryTheory.Limits.Sigma.Î¹ (Function.comp f â‡‘Îµ) b)","decl":"@[reassoc (attr := simp)]\ntheorem Sigma.Î¹_reindex_inv (b : Î²) :\n    Sigma.Î¹ f (Îµ b) â‰« (Sigma.reindex Îµ f).inv = Sigma.Î¹ (f âˆ˜ Îµ) b := by simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.Sigma.Î¹_reindex_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Products","initialProofState":"Î² : Type w\nC : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nÎ³ : Type w'\nÎµ : Equiv Î² Î³\nf : Î³ â†’ C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoproduct f\ninstâœ : CategoryTheory.Limits.HasCoproduct (Function.comp f â‡‘Îµ)\nb : Î²\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj (Function.comp f â‡‘Îµ)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ f (Îµ b)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.reindex Îµ f).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (Function.comp f â‡‘Îµ) b) h)","decl":"@[reassoc (attr := simp)]\ntheorem Sigma.Î¹_reindex_inv (b : Î²) :\n    Sigma.Î¹ f (Îµ b) â‰« (Sigma.reindex Îµ f).inv = Sigma.Î¹ (f âˆ˜ Îµ) b := by simp [Iso.comp_inv_eq]\n\n"}
