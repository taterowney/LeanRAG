{"name":"mdifferentiableWithinAt_totalSpace","module":"Mathlib.Geometry.Manifold.VectorBundle.MDifferentiable","initialProofState":"ğ•œ : Type u_1\nB : Type u_2\nF : Type u_4\nM : Type u_5\nE : B â†’ Type u_6\ninstâœÂ¹âµ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â´ : NormedAddCommGroup F\ninstâœÂ¹Â³ : NormedSpace ğ•œ F\ninstâœÂ¹Â² : TopologicalSpace (Bundle.TotalSpace F E)\ninstâœÂ¹Â¹ : (x : B) â†’ TopologicalSpace (E x)\nEB : Type u_7\ninstâœÂ¹â° : NormedAddCommGroup EB\ninstâœâ¹ : NormedSpace ğ•œ EB\nHB : Type u_8\ninstâœâ¸ : TopologicalSpace HB\nIB : ModelWithCorners ğ•œ EB HB\nEM : Type u_10\ninstâœâ· : NormedAddCommGroup EM\ninstâœâ¶ : NormedSpace ğ•œ EM\nHM : Type u_11\ninstâœâµ : TopologicalSpace HM\nIM : ModelWithCorners ğ•œ EM HM\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace HM M\ninstâœÂ² : TopologicalSpace B\ninstâœÂ¹ : ChartedSpace HB B\ninstâœ : FiberBundle F E\nf : M â†’ Bundle.TotalSpace F E\ns : Set M\nxâ‚€ : M\nâŠ¢ Iff (MDifferentiableWithinAt IM (IB.prod (modelWithCornersSelf ğ•œ F)) f s xâ‚€) (And (MDifferentiableWithinAt IM IB (fun x => (f x).proj) s xâ‚€) (MDifferentiableWithinAt IM (modelWithCornersSelf ğ•œ F) (fun x => (â†‘(FiberBundle.trivializationAt F E (f xâ‚€).proj) (f x)).2) s xâ‚€))","decl":"/-- Characterization of differentiable functions into a vector bundle. -/\ntheorem mdifferentiableWithinAt_totalSpace (f : M â†’ TotalSpace F E) {s : Set M} {xâ‚€ : M} :\n    MDifferentiableWithinAt IM (IB.prod ğ“˜(ğ•œ, F)) f s xâ‚€ â†”\n      MDifferentiableWithinAt IM IB (fun x => (f x).proj) s xâ‚€ âˆ§\n      MDifferentiableWithinAt IM ğ“˜(ğ•œ, F)\n        (fun x â†¦ (trivializationAt F E (f xâ‚€).proj (f x)).2) s xâ‚€ := by\n  simp (config := { singlePass := true }) only [mdifferentiableWithinAt_iff_target]\n  rw [and_and_and_comm, â† FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]\n  intro hf\n  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp_def,\n    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe,\n    extChartAt_self_apply, modelWithCornersSelf_coe, Function.id_def, â† chartedSpaceSelf_prod]\n  refine (mdifferentiableWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)\n  have h1 : (fun x => (f x).proj) â»Â¹' (trivializationAt F E (f xâ‚€).proj).baseSet âˆˆ ğ“[s] xâ‚€ :=\n    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))\n      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))\n  refine EventuallyEq.mdifferentiableWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_\n  Â· simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]\n    rw [Trivialization.coe_fst']\n    exact hx\n  Â· simp only [mfld_simps]\n\n"}
{"name":"MDifferentiableWithinAt.clm_apply_of_inCoordinates","module":"Mathlib.Geometry.Manifold.VectorBundle.MDifferentiable","initialProofState":"ğ•œ : Type u_1\nFâ‚ : Type u_2\nFâ‚‚ : Type u_3\nBâ‚ : Type u_4\nBâ‚‚ : Type u_5\nM : Type u_6\nEâ‚ : Bâ‚ â†’ Type u_7\nEâ‚‚ : Bâ‚‚ â†’ Type u_8\ninstâœÂ³Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ³â° : (x : Bâ‚) â†’ AddCommGroup (Eâ‚ x)\ninstâœÂ²â¹ : (x : Bâ‚) â†’ Module ğ•œ (Eâ‚ x)\ninstâœÂ²â¸ : NormedAddCommGroup Fâ‚\ninstâœÂ²â· : NormedSpace ğ•œ Fâ‚\ninstâœÂ²â¶ : TopologicalSpace (Bundle.TotalSpace Fâ‚ Eâ‚)\ninstâœÂ²âµ : (x : Bâ‚) â†’ TopologicalSpace (Eâ‚ x)\ninstâœÂ²â´ : (x : Bâ‚‚) â†’ AddCommGroup (Eâ‚‚ x)\ninstâœÂ²Â³ : (x : Bâ‚‚) â†’ Module ğ•œ (Eâ‚‚ x)\ninstâœÂ²Â² : NormedAddCommGroup Fâ‚‚\ninstâœÂ²Â¹ : NormedSpace ğ•œ Fâ‚‚\ninstâœÂ²â° : TopologicalSpace (Bundle.TotalSpace Fâ‚‚ Eâ‚‚)\ninstâœÂ¹â¹ : (x : Bâ‚‚) â†’ TopologicalSpace (Eâ‚‚ x)\nEBâ‚ : Type u_9\ninstâœÂ¹â¸ : NormedAddCommGroup EBâ‚\ninstâœÂ¹â· : NormedSpace ğ•œ EBâ‚\nHBâ‚ : Type u_10\ninstâœÂ¹â¶ : TopologicalSpace HBâ‚\nIBâ‚ : ModelWithCorners ğ•œ EBâ‚ HBâ‚\ninstâœÂ¹âµ : TopologicalSpace Bâ‚\ninstâœÂ¹â´ : ChartedSpace HBâ‚ Bâ‚\nEBâ‚‚ : Type u_11\ninstâœÂ¹Â³ : NormedAddCommGroup EBâ‚‚\ninstâœÂ¹Â² : NormedSpace ğ•œ EBâ‚‚\nHBâ‚‚ : Type u_12\ninstâœÂ¹Â¹ : TopologicalSpace HBâ‚‚\nIBâ‚‚ : ModelWithCorners ğ•œ EBâ‚‚ HBâ‚‚\ninstâœÂ¹â° : TopologicalSpace Bâ‚‚\ninstâœâ¹ : ChartedSpace HBâ‚‚ Bâ‚‚\nEM : Type u_13\ninstâœâ¸ : NormedAddCommGroup EM\ninstâœâ· : NormedSpace ğ•œ EM\nHM : Type u_14\ninstâœâ¶ : TopologicalSpace HM\nIM : ModelWithCorners ğ•œ EM HM\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace HM M\ninstâœÂ³ : FiberBundle Fâ‚ Eâ‚\ninstâœÂ² : VectorBundle ğ•œ Fâ‚ Eâ‚\ninstâœÂ¹ : FiberBundle Fâ‚‚ Eâ‚‚\ninstâœ : VectorBundle ğ•œ Fâ‚‚ Eâ‚‚\nbâ‚ : M â†’ Bâ‚\nbâ‚‚ : M â†’ Bâ‚‚\nmâ‚€ : M\nÏ• : (m : M) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (Eâ‚ (bâ‚ m)) (Eâ‚‚ (bâ‚‚ m))\nv : (m : M) â†’ Eâ‚ (bâ‚ m)\ns : Set M\nhÏ• : MDifferentiableWithinAt IM (modelWithCornersSelf ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) Fâ‚ Fâ‚‚)) (fun m => ContinuousLinearMap.inCoordinates Fâ‚ Eâ‚ Fâ‚‚ Eâ‚‚ (bâ‚ mâ‚€) (bâ‚ m) (bâ‚‚ mâ‚€) (bâ‚‚ m) (Ï• m)) s mâ‚€\nhv : MDifferentiableWithinAt IM (IBâ‚.prod (modelWithCornersSelf ğ•œ Fâ‚)) (fun m => { proj := bâ‚ m, snd := v m }) s mâ‚€\nhbâ‚‚ : MDifferentiableWithinAt IM IBâ‚‚ bâ‚‚ s mâ‚€\nâŠ¢ MDifferentiableWithinAt IM (IBâ‚‚.prod (modelWithCornersSelf ğ•œ Fâ‚‚)) (fun m => { proj := bâ‚‚ m, snd := (Ï• m) (v m) }) s mâ‚€","decl":"/-- Consider a differentiable map `v : M â†’ Eâ‚` to a vector bundle, over a basemap `bâ‚ : M â†’ Bâ‚`, and\nanother basemap `bâ‚‚ : M â†’ Bâ‚‚`. Given linear maps `Ï• m : Eâ‚ (bâ‚ m) â†’ Eâ‚‚ (bâ‚‚ m)` depending\ndifferentiably on `m`, one can apply `Ï• m` to `g m`, and the resulting map is differentiable.\n\nNote that the differentiability of `Ï•` can not be always be stated as differentiability of a map\ninto a manifold, as the pullback bundles `bâ‚ *áµ– Eâ‚` and `bâ‚‚ *áµ– Eâ‚‚` only make sense when `bâ‚`\nand `bâ‚‚` are globally smooth, but we want to apply this lemma with only local information.\nTherefore, we formulate it using differentiability of `Ï•` read in coordinates.\n\nVersion for `MDifferentiableWithinAt`. We also give a version for `MDifferentiableAt`, but no\nversion for `MDifferentiableOn` or `MDifferentiable` as our assumption, written in coordinates,\nonly makes sense around a point.\n -/\nlemma MDifferentiableWithinAt.clm_apply_of_inCoordinates\n    (hÏ• : MDifferentiableWithinAt IM ğ“˜(ğ•œ, Fâ‚ â†’L[ğ•œ] Fâ‚‚)\n      (fun m â†¦ inCoordinates Fâ‚ Eâ‚ Fâ‚‚ Eâ‚‚ (bâ‚ mâ‚€) (bâ‚ m) (bâ‚‚ mâ‚€) (bâ‚‚ m) (Ï• m)) s mâ‚€)\n    (hv : MDifferentiableWithinAt IM (IBâ‚.prod ğ“˜(ğ•œ, Fâ‚)) (fun m â†¦ (v m : TotalSpace Fâ‚ Eâ‚)) s mâ‚€)\n    (hbâ‚‚ : MDifferentiableWithinAt IM IBâ‚‚ bâ‚‚ s mâ‚€) :\n    MDifferentiableWithinAt IM (IBâ‚‚.prod ğ“˜(ğ•œ, Fâ‚‚))\n      (fun m â†¦ (Ï• m (v m) : TotalSpace Fâ‚‚ Eâ‚‚)) s mâ‚€ := by\n  rw [mdifferentiableWithinAt_totalSpace] at hv âŠ¢\n  refine âŸ¨hbâ‚‚, ?_âŸ©\n  apply (MDifferentiableWithinAt.clm_apply hÏ• hv.2).congr_of_eventuallyEq_insert\n  have A : âˆ€á¶  m in ğ“[insert mâ‚€ s] mâ‚€, bâ‚ m âˆˆ (trivializationAt Fâ‚ Eâ‚ (bâ‚ mâ‚€)).baseSet := by\n    apply hv.1.insert.continuousWithinAt\n    apply (trivializationAt Fâ‚ Eâ‚ (bâ‚ mâ‚€)).open_baseSet.mem_nhds\n    exact FiberBundle.mem_baseSet_trivializationAt' (bâ‚ mâ‚€)\n  have A' : âˆ€á¶  m in ğ“[insert mâ‚€ s] mâ‚€, bâ‚‚ m âˆˆ (trivializationAt Fâ‚‚ Eâ‚‚ (bâ‚‚ mâ‚€)).baseSet := by\n    apply hbâ‚‚.insert.continuousWithinAt\n    apply (trivializationAt Fâ‚‚ Eâ‚‚ (bâ‚‚ mâ‚€)).open_baseSet.mem_nhds\n    exact FiberBundle.mem_baseSet_trivializationAt' (bâ‚‚ mâ‚€)\n  filter_upwards [A, A'] with m hm h'm\n  rw [inCoordinates_eq hm h'm]\n  simp only [coe_comp', ContinuousLinearEquiv.coe_coe, Trivialization.continuousLinearEquivAt_apply,\n    Trivialization.continuousLinearEquivAt_symm_apply, Function.comp_apply]\n  congr\n  rw [Trivialization.symm_apply_apply_mk (trivializationAt Fâ‚ Eâ‚ (bâ‚ mâ‚€)) hm (v m)]\n\n"}
{"name":"MDifferentiableAt.clm_apply_of_inCoordinates","module":"Mathlib.Geometry.Manifold.VectorBundle.MDifferentiable","initialProofState":"ğ•œ : Type u_1\nFâ‚ : Type u_2\nFâ‚‚ : Type u_3\nBâ‚ : Type u_4\nBâ‚‚ : Type u_5\nM : Type u_6\nEâ‚ : Bâ‚ â†’ Type u_7\nEâ‚‚ : Bâ‚‚ â†’ Type u_8\ninstâœÂ³Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ³â° : (x : Bâ‚) â†’ AddCommGroup (Eâ‚ x)\ninstâœÂ²â¹ : (x : Bâ‚) â†’ Module ğ•œ (Eâ‚ x)\ninstâœÂ²â¸ : NormedAddCommGroup Fâ‚\ninstâœÂ²â· : NormedSpace ğ•œ Fâ‚\ninstâœÂ²â¶ : TopologicalSpace (Bundle.TotalSpace Fâ‚ Eâ‚)\ninstâœÂ²âµ : (x : Bâ‚) â†’ TopologicalSpace (Eâ‚ x)\ninstâœÂ²â´ : (x : Bâ‚‚) â†’ AddCommGroup (Eâ‚‚ x)\ninstâœÂ²Â³ : (x : Bâ‚‚) â†’ Module ğ•œ (Eâ‚‚ x)\ninstâœÂ²Â² : NormedAddCommGroup Fâ‚‚\ninstâœÂ²Â¹ : NormedSpace ğ•œ Fâ‚‚\ninstâœÂ²â° : TopologicalSpace (Bundle.TotalSpace Fâ‚‚ Eâ‚‚)\ninstâœÂ¹â¹ : (x : Bâ‚‚) â†’ TopologicalSpace (Eâ‚‚ x)\nEBâ‚ : Type u_9\ninstâœÂ¹â¸ : NormedAddCommGroup EBâ‚\ninstâœÂ¹â· : NormedSpace ğ•œ EBâ‚\nHBâ‚ : Type u_10\ninstâœÂ¹â¶ : TopologicalSpace HBâ‚\nIBâ‚ : ModelWithCorners ğ•œ EBâ‚ HBâ‚\ninstâœÂ¹âµ : TopologicalSpace Bâ‚\ninstâœÂ¹â´ : ChartedSpace HBâ‚ Bâ‚\nEBâ‚‚ : Type u_11\ninstâœÂ¹Â³ : NormedAddCommGroup EBâ‚‚\ninstâœÂ¹Â² : NormedSpace ğ•œ EBâ‚‚\nHBâ‚‚ : Type u_12\ninstâœÂ¹Â¹ : TopologicalSpace HBâ‚‚\nIBâ‚‚ : ModelWithCorners ğ•œ EBâ‚‚ HBâ‚‚\ninstâœÂ¹â° : TopologicalSpace Bâ‚‚\ninstâœâ¹ : ChartedSpace HBâ‚‚ Bâ‚‚\nEM : Type u_13\ninstâœâ¸ : NormedAddCommGroup EM\ninstâœâ· : NormedSpace ğ•œ EM\nHM : Type u_14\ninstâœâ¶ : TopologicalSpace HM\nIM : ModelWithCorners ğ•œ EM HM\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace HM M\ninstâœÂ³ : FiberBundle Fâ‚ Eâ‚\ninstâœÂ² : VectorBundle ğ•œ Fâ‚ Eâ‚\ninstâœÂ¹ : FiberBundle Fâ‚‚ Eâ‚‚\ninstâœ : VectorBundle ğ•œ Fâ‚‚ Eâ‚‚\nbâ‚ : M â†’ Bâ‚\nbâ‚‚ : M â†’ Bâ‚‚\nmâ‚€ : M\nÏ• : (m : M) â†’ ContinuousLinearMap (RingHom.id ğ•œ) (Eâ‚ (bâ‚ m)) (Eâ‚‚ (bâ‚‚ m))\nv : (m : M) â†’ Eâ‚ (bâ‚ m)\nhÏ• : MDifferentiableAt IM (modelWithCornersSelf ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) Fâ‚ Fâ‚‚)) (fun m => ContinuousLinearMap.inCoordinates Fâ‚ Eâ‚ Fâ‚‚ Eâ‚‚ (bâ‚ mâ‚€) (bâ‚ m) (bâ‚‚ mâ‚€) (bâ‚‚ m) (Ï• m)) mâ‚€\nhv : MDifferentiableAt IM (IBâ‚.prod (modelWithCornersSelf ğ•œ Fâ‚)) (fun m => { proj := bâ‚ m, snd := v m }) mâ‚€\nhbâ‚‚ : MDifferentiableAt IM IBâ‚‚ bâ‚‚ mâ‚€\nâŠ¢ MDifferentiableAt IM (IBâ‚‚.prod (modelWithCornersSelf ğ•œ Fâ‚‚)) (fun m => { proj := bâ‚‚ m, snd := (Ï• m) (v m) }) mâ‚€","decl":"/-- Consider a differentiable map `v : M â†’ Eâ‚` to a vector bundle, over a basemap `bâ‚ : M â†’ Bâ‚`, and\nanother basemap `bâ‚‚ : M â†’ Bâ‚‚`. Given linear maps `Ï• m : Eâ‚ (bâ‚ m) â†’ Eâ‚‚ (bâ‚‚ m)` depending\ndifferentiably on `m`, one can apply `Ï• m` to `g m`, and the resulting map is differentiable.\n\nNote that the differentiability of `Ï•` can not be always be stated as differentiability of a map\ninto a manifold, as the pullback bundles `bâ‚ *áµ– Eâ‚` and `bâ‚‚ *áµ– Eâ‚‚` only make sense when `bâ‚`\nand `bâ‚‚` are globally smooth, but we want to apply this lemma with only local information.\nTherefore, we formulate it using differentiability of `Ï•` read in coordinates.\n\nVersion for `MDifferentiableAt`. We also give a version for `MDifferentiableWithinAt`,\nbut no version for `MDifferentiableOn` or `MDifferentiable` as our assumption, written\nin coordinates, only makes sense around a point.\n -/\nlemma MDifferentiableAt.clm_apply_of_inCoordinates\n    (hÏ• : MDifferentiableAt IM ğ“˜(ğ•œ, Fâ‚ â†’L[ğ•œ] Fâ‚‚)\n      (fun m â†¦ inCoordinates Fâ‚ Eâ‚ Fâ‚‚ Eâ‚‚ (bâ‚ mâ‚€) (bâ‚ m) (bâ‚‚ mâ‚€) (bâ‚‚ m) (Ï• m)) mâ‚€)\n    (hv : MDifferentiableAt IM (IBâ‚.prod ğ“˜(ğ•œ, Fâ‚)) (fun m â†¦ (v m : TotalSpace Fâ‚ Eâ‚)) mâ‚€)\n    (hbâ‚‚ : MDifferentiableAt IM IBâ‚‚ bâ‚‚ mâ‚€) :\n    MDifferentiableAt IM (IBâ‚‚.prod ğ“˜(ğ•œ, Fâ‚‚)) (fun m â†¦ (Ï• m (v m) : TotalSpace Fâ‚‚ Eâ‚‚)) mâ‚€ := by\n  rw [â† mdifferentiableWithinAt_univ] at hÏ• hv hbâ‚‚ âŠ¢\n  exact MDifferentiableWithinAt.clm_apply_of_inCoordinates hÏ• hv hbâ‚‚\n\n"}
