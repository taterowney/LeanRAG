{"name":"mdifferentiableWithinAt_totalSpace","module":"Mathlib.Geometry.Manifold.VectorBundle.MDifferentiable","initialProofState":"𝕜 : Type u_1\nB : Type u_2\nF : Type u_4\nM : Type u_5\nE : B → Type u_6\ninst✝¹⁵ : NontriviallyNormedField 𝕜\ninst✝¹⁴ : NormedAddCommGroup F\ninst✝¹³ : NormedSpace 𝕜 F\ninst✝¹² : TopologicalSpace (Bundle.TotalSpace F E)\ninst✝¹¹ : (x : B) → TopologicalSpace (E x)\nEB : Type u_7\ninst✝¹⁰ : NormedAddCommGroup EB\ninst✝⁹ : NormedSpace 𝕜 EB\nHB : Type u_8\ninst✝⁸ : TopologicalSpace HB\nIB : ModelWithCorners 𝕜 EB HB\nEM : Type u_10\ninst✝⁷ : NormedAddCommGroup EM\ninst✝⁶ : NormedSpace 𝕜 EM\nHM : Type u_11\ninst✝⁵ : TopologicalSpace HM\nIM : ModelWithCorners 𝕜 EM HM\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace HM M\ninst✝² : TopologicalSpace B\ninst✝¹ : ChartedSpace HB B\ninst✝ : FiberBundle F E\nf : M → Bundle.TotalSpace F E\ns : Set M\nx₀ : M\n⊢ Iff (MDifferentiableWithinAt IM (IB.prod (modelWithCornersSelf 𝕜 F)) f s x₀) (And (MDifferentiableWithinAt IM IB (fun x => (f x).proj) s x₀) (MDifferentiableWithinAt IM (modelWithCornersSelf 𝕜 F) (fun x => (↑(FiberBundle.trivializationAt F E (f x₀).proj) (f x)).2) s x₀))","decl":"/-- Characterization of differentiable functions into a vector bundle. -/\ntheorem mdifferentiableWithinAt_totalSpace (f : M → TotalSpace F E) {s : Set M} {x₀ : M} :\n    MDifferentiableWithinAt IM (IB.prod 𝓘(𝕜, F)) f s x₀ ↔\n      MDifferentiableWithinAt IM IB (fun x => (f x).proj) s x₀ ∧\n      MDifferentiableWithinAt IM 𝓘(𝕜, F)\n        (fun x ↦ (trivializationAt F E (f x₀).proj (f x)).2) s x₀ := by\n  simp (config := { singlePass := true }) only [mdifferentiableWithinAt_iff_target]\n  rw [and_and_and_comm, ← FiberBundle.continuousWithinAt_totalSpace, and_congr_right_iff]\n  intro hf\n  simp_rw [modelWithCornersSelf_prod, FiberBundle.extChartAt, Function.comp_def,\n    PartialEquiv.trans_apply, PartialEquiv.prod_coe, PartialEquiv.refl_coe,\n    extChartAt_self_apply, modelWithCornersSelf_coe, Function.id_def, ← chartedSpaceSelf_prod]\n  refine (mdifferentiableWithinAt_prod_iff _).trans (and_congr ?_ Iff.rfl)\n  have h1 : (fun x => (f x).proj) ⁻¹' (trivializationAt F E (f x₀).proj).baseSet ∈ 𝓝[s] x₀ :=\n    ((FiberBundle.continuous_proj F E).continuousWithinAt.comp hf (mapsTo_image f s))\n      ((Trivialization.open_baseSet _).mem_nhds (mem_baseSet_trivializationAt F E _))\n  refine EventuallyEq.mdifferentiableWithinAt_iff (eventually_of_mem h1 fun x hx => ?_) ?_\n  · simp_rw [Function.comp, PartialHomeomorph.coe_coe, Trivialization.coe_coe]\n    rw [Trivialization.coe_fst']\n    exact hx\n  · simp only [mfld_simps]\n\n"}
{"name":"MDifferentiableWithinAt.clm_apply_of_inCoordinates","module":"Mathlib.Geometry.Manifold.VectorBundle.MDifferentiable","initialProofState":"𝕜 : Type u_1\nF₁ : Type u_2\nF₂ : Type u_3\nB₁ : Type u_4\nB₂ : Type u_5\nM : Type u_6\nE₁ : B₁ → Type u_7\nE₂ : B₂ → Type u_8\ninst✝³¹ : NontriviallyNormedField 𝕜\ninst✝³⁰ : (x : B₁) → AddCommGroup (E₁ x)\ninst✝²⁹ : (x : B₁) → Module 𝕜 (E₁ x)\ninst✝²⁸ : NormedAddCommGroup F₁\ninst✝²⁷ : NormedSpace 𝕜 F₁\ninst✝²⁶ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\ninst✝²⁵ : (x : B₁) → TopologicalSpace (E₁ x)\ninst✝²⁴ : (x : B₂) → AddCommGroup (E₂ x)\ninst✝²³ : (x : B₂) → Module 𝕜 (E₂ x)\ninst✝²² : NormedAddCommGroup F₂\ninst✝²¹ : NormedSpace 𝕜 F₂\ninst✝²⁰ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝¹⁹ : (x : B₂) → TopologicalSpace (E₂ x)\nEB₁ : Type u_9\ninst✝¹⁸ : NormedAddCommGroup EB₁\ninst✝¹⁷ : NormedSpace 𝕜 EB₁\nHB₁ : Type u_10\ninst✝¹⁶ : TopologicalSpace HB₁\nIB₁ : ModelWithCorners 𝕜 EB₁ HB₁\ninst✝¹⁵ : TopologicalSpace B₁\ninst✝¹⁴ : ChartedSpace HB₁ B₁\nEB₂ : Type u_11\ninst✝¹³ : NormedAddCommGroup EB₂\ninst✝¹² : NormedSpace 𝕜 EB₂\nHB₂ : Type u_12\ninst✝¹¹ : TopologicalSpace HB₂\nIB₂ : ModelWithCorners 𝕜 EB₂ HB₂\ninst✝¹⁰ : TopologicalSpace B₂\ninst✝⁹ : ChartedSpace HB₂ B₂\nEM : Type u_13\ninst✝⁸ : NormedAddCommGroup EM\ninst✝⁷ : NormedSpace 𝕜 EM\nHM : Type u_14\ninst✝⁶ : TopologicalSpace HM\nIM : ModelWithCorners 𝕜 EM HM\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : ChartedSpace HM M\ninst✝³ : FiberBundle F₁ E₁\ninst✝² : VectorBundle 𝕜 F₁ E₁\ninst✝¹ : FiberBundle F₂ E₂\ninst✝ : VectorBundle 𝕜 F₂ E₂\nb₁ : M → B₁\nb₂ : M → B₂\nm₀ : M\nϕ : (m : M) → ContinuousLinearMap (RingHom.id 𝕜) (E₁ (b₁ m)) (E₂ (b₂ m))\nv : (m : M) → E₁ (b₁ m)\ns : Set M\nhϕ : MDifferentiableWithinAt IM (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂)) (fun m => ContinuousLinearMap.inCoordinates F₁ E₁ F₂ E₂ (b₁ m₀) (b₁ m) (b₂ m₀) (b₂ m) (ϕ m)) s m₀\nhv : MDifferentiableWithinAt IM (IB₁.prod (modelWithCornersSelf 𝕜 F₁)) (fun m => { proj := b₁ m, snd := v m }) s m₀\nhb₂ : MDifferentiableWithinAt IM IB₂ b₂ s m₀\n⊢ MDifferentiableWithinAt IM (IB₂.prod (modelWithCornersSelf 𝕜 F₂)) (fun m => { proj := b₂ m, snd := (ϕ m) (v m) }) s m₀","decl":"/-- Consider a differentiable map `v : M → E₁` to a vector bundle, over a basemap `b₁ : M → B₁`, and\nanother basemap `b₂ : M → B₂`. Given linear maps `ϕ m : E₁ (b₁ m) → E₂ (b₂ m)` depending\ndifferentiably on `m`, one can apply `ϕ m` to `g m`, and the resulting map is differentiable.\n\nNote that the differentiability of `ϕ` can not be always be stated as differentiability of a map\ninto a manifold, as the pullback bundles `b₁ *ᵖ E₁` and `b₂ *ᵖ E₂` only make sense when `b₁`\nand `b₂` are globally smooth, but we want to apply this lemma with only local information.\nTherefore, we formulate it using differentiability of `ϕ` read in coordinates.\n\nVersion for `MDifferentiableWithinAt`. We also give a version for `MDifferentiableAt`, but no\nversion for `MDifferentiableOn` or `MDifferentiable` as our assumption, written in coordinates,\nonly makes sense around a point.\n -/\nlemma MDifferentiableWithinAt.clm_apply_of_inCoordinates\n    (hϕ : MDifferentiableWithinAt IM 𝓘(𝕜, F₁ →L[𝕜] F₂)\n      (fun m ↦ inCoordinates F₁ E₁ F₂ E₂ (b₁ m₀) (b₁ m) (b₂ m₀) (b₂ m) (ϕ m)) s m₀)\n    (hv : MDifferentiableWithinAt IM (IB₁.prod 𝓘(𝕜, F₁)) (fun m ↦ (v m : TotalSpace F₁ E₁)) s m₀)\n    (hb₂ : MDifferentiableWithinAt IM IB₂ b₂ s m₀) :\n    MDifferentiableWithinAt IM (IB₂.prod 𝓘(𝕜, F₂))\n      (fun m ↦ (ϕ m (v m) : TotalSpace F₂ E₂)) s m₀ := by\n  rw [mdifferentiableWithinAt_totalSpace] at hv ⊢\n  refine ⟨hb₂, ?_⟩\n  apply (MDifferentiableWithinAt.clm_apply hϕ hv.2).congr_of_eventuallyEq_insert\n  have A : ∀ᶠ m in 𝓝[insert m₀ s] m₀, b₁ m ∈ (trivializationAt F₁ E₁ (b₁ m₀)).baseSet := by\n    apply hv.1.insert.continuousWithinAt\n    apply (trivializationAt F₁ E₁ (b₁ m₀)).open_baseSet.mem_nhds\n    exact FiberBundle.mem_baseSet_trivializationAt' (b₁ m₀)\n  have A' : ∀ᶠ m in 𝓝[insert m₀ s] m₀, b₂ m ∈ (trivializationAt F₂ E₂ (b₂ m₀)).baseSet := by\n    apply hb₂.insert.continuousWithinAt\n    apply (trivializationAt F₂ E₂ (b₂ m₀)).open_baseSet.mem_nhds\n    exact FiberBundle.mem_baseSet_trivializationAt' (b₂ m₀)\n  filter_upwards [A, A'] with m hm h'm\n  rw [inCoordinates_eq hm h'm]\n  simp only [coe_comp', ContinuousLinearEquiv.coe_coe, Trivialization.continuousLinearEquivAt_apply,\n    Trivialization.continuousLinearEquivAt_symm_apply, Function.comp_apply]\n  congr\n  rw [Trivialization.symm_apply_apply_mk (trivializationAt F₁ E₁ (b₁ m₀)) hm (v m)]\n\n"}
{"name":"MDifferentiableAt.clm_apply_of_inCoordinates","module":"Mathlib.Geometry.Manifold.VectorBundle.MDifferentiable","initialProofState":"𝕜 : Type u_1\nF₁ : Type u_2\nF₂ : Type u_3\nB₁ : Type u_4\nB₂ : Type u_5\nM : Type u_6\nE₁ : B₁ → Type u_7\nE₂ : B₂ → Type u_8\ninst✝³¹ : NontriviallyNormedField 𝕜\ninst✝³⁰ : (x : B₁) → AddCommGroup (E₁ x)\ninst✝²⁹ : (x : B₁) → Module 𝕜 (E₁ x)\ninst✝²⁸ : NormedAddCommGroup F₁\ninst✝²⁷ : NormedSpace 𝕜 F₁\ninst✝²⁶ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\ninst✝²⁵ : (x : B₁) → TopologicalSpace (E₁ x)\ninst✝²⁴ : (x : B₂) → AddCommGroup (E₂ x)\ninst✝²³ : (x : B₂) → Module 𝕜 (E₂ x)\ninst✝²² : NormedAddCommGroup F₂\ninst✝²¹ : NormedSpace 𝕜 F₂\ninst✝²⁰ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝¹⁹ : (x : B₂) → TopologicalSpace (E₂ x)\nEB₁ : Type u_9\ninst✝¹⁸ : NormedAddCommGroup EB₁\ninst✝¹⁷ : NormedSpace 𝕜 EB₁\nHB₁ : Type u_10\ninst✝¹⁶ : TopologicalSpace HB₁\nIB₁ : ModelWithCorners 𝕜 EB₁ HB₁\ninst✝¹⁵ : TopologicalSpace B₁\ninst✝¹⁴ : ChartedSpace HB₁ B₁\nEB₂ : Type u_11\ninst✝¹³ : NormedAddCommGroup EB₂\ninst✝¹² : NormedSpace 𝕜 EB₂\nHB₂ : Type u_12\ninst✝¹¹ : TopologicalSpace HB₂\nIB₂ : ModelWithCorners 𝕜 EB₂ HB₂\ninst✝¹⁰ : TopologicalSpace B₂\ninst✝⁹ : ChartedSpace HB₂ B₂\nEM : Type u_13\ninst✝⁸ : NormedAddCommGroup EM\ninst✝⁷ : NormedSpace 𝕜 EM\nHM : Type u_14\ninst✝⁶ : TopologicalSpace HM\nIM : ModelWithCorners 𝕜 EM HM\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : ChartedSpace HM M\ninst✝³ : FiberBundle F₁ E₁\ninst✝² : VectorBundle 𝕜 F₁ E₁\ninst✝¹ : FiberBundle F₂ E₂\ninst✝ : VectorBundle 𝕜 F₂ E₂\nb₁ : M → B₁\nb₂ : M → B₂\nm₀ : M\nϕ : (m : M) → ContinuousLinearMap (RingHom.id 𝕜) (E₁ (b₁ m)) (E₂ (b₂ m))\nv : (m : M) → E₁ (b₁ m)\nhϕ : MDifferentiableAt IM (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂)) (fun m => ContinuousLinearMap.inCoordinates F₁ E₁ F₂ E₂ (b₁ m₀) (b₁ m) (b₂ m₀) (b₂ m) (ϕ m)) m₀\nhv : MDifferentiableAt IM (IB₁.prod (modelWithCornersSelf 𝕜 F₁)) (fun m => { proj := b₁ m, snd := v m }) m₀\nhb₂ : MDifferentiableAt IM IB₂ b₂ m₀\n⊢ MDifferentiableAt IM (IB₂.prod (modelWithCornersSelf 𝕜 F₂)) (fun m => { proj := b₂ m, snd := (ϕ m) (v m) }) m₀","decl":"/-- Consider a differentiable map `v : M → E₁` to a vector bundle, over a basemap `b₁ : M → B₁`, and\nanother basemap `b₂ : M → B₂`. Given linear maps `ϕ m : E₁ (b₁ m) → E₂ (b₂ m)` depending\ndifferentiably on `m`, one can apply `ϕ m` to `g m`, and the resulting map is differentiable.\n\nNote that the differentiability of `ϕ` can not be always be stated as differentiability of a map\ninto a manifold, as the pullback bundles `b₁ *ᵖ E₁` and `b₂ *ᵖ E₂` only make sense when `b₁`\nand `b₂` are globally smooth, but we want to apply this lemma with only local information.\nTherefore, we formulate it using differentiability of `ϕ` read in coordinates.\n\nVersion for `MDifferentiableAt`. We also give a version for `MDifferentiableWithinAt`,\nbut no version for `MDifferentiableOn` or `MDifferentiable` as our assumption, written\nin coordinates, only makes sense around a point.\n -/\nlemma MDifferentiableAt.clm_apply_of_inCoordinates\n    (hϕ : MDifferentiableAt IM 𝓘(𝕜, F₁ →L[𝕜] F₂)\n      (fun m ↦ inCoordinates F₁ E₁ F₂ E₂ (b₁ m₀) (b₁ m) (b₂ m₀) (b₂ m) (ϕ m)) m₀)\n    (hv : MDifferentiableAt IM (IB₁.prod 𝓘(𝕜, F₁)) (fun m ↦ (v m : TotalSpace F₁ E₁)) m₀)\n    (hb₂ : MDifferentiableAt IM IB₂ b₂ m₀) :\n    MDifferentiableAt IM (IB₂.prod 𝓘(𝕜, F₂)) (fun m ↦ (ϕ m (v m) : TotalSpace F₂ E₂)) m₀ := by\n  rw [← mdifferentiableWithinAt_univ] at hϕ hv hb₂ ⊢\n  exact MDifferentiableWithinAt.clm_apply_of_inCoordinates hϕ hv hb₂\n\n"}
