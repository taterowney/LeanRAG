{"name":"Set.IsPWO.vadd","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\ns : Set G\nt : Set P\nhs : s.IsPWO\nht : t.IsPWO\n⊢ (HVAdd.hVAdd s t).IsPWO","decl":"@[to_additive]\ntheorem IsPWO.smul [PartialOrder G] [PartialOrder P] [SMul G P] [IsOrderedCancelSMul G P]\n    {s : Set G} {t : Set P} (hs : s.IsPWO) (ht : t.IsPWO) : IsPWO (s • t) := by\n  rw [← @image_smul_prod]\n  exact (hs.prod ht).image_of_monotone (monotone_fst.smul monotone_snd)\n\n"}
{"name":"Set.IsPWO.smul","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\ns : Set G\nt : Set P\nhs : s.IsPWO\nht : t.IsPWO\n⊢ (HSMul.hSMul s t).IsPWO","decl":"@[to_additive]\ntheorem IsPWO.smul [PartialOrder G] [PartialOrder P] [SMul G P] [IsOrderedCancelSMul G P]\n    {s : Set G} {t : Set P} (hs : s.IsPWO) (ht : t.IsPWO) : IsPWO (s • t) := by\n  rw [← @image_smul_prod]\n  exact (hs.prod ht).image_of_monotone (monotone_fst.smul monotone_snd)\n\n"}
{"name":"Set.IsWF.smul","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : LinearOrder G\ninst✝² : LinearOrder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\ns : Set G\nt : Set P\nhs : s.IsWF\nht : t.IsWF\n⊢ (HSMul.hSMul s t).IsWF","decl":"@[to_additive]\ntheorem IsWF.smul [LinearOrder G] [LinearOrder P] [SMul G P] [IsOrderedCancelSMul G P] {s : Set G}\n    {t : Set P} (hs : s.IsWF) (ht : t.IsWF) : IsWF (s • t) :=\n  (hs.isPWO.smul ht.isPWO).isWF\n\n"}
{"name":"Set.IsWF.vadd","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : LinearOrder G\ninst✝² : LinearOrder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\ns : Set G\nt : Set P\nhs : s.IsWF\nht : t.IsWF\n⊢ (HVAdd.hVAdd s t).IsWF","decl":"@[to_additive]\ntheorem IsWF.smul [LinearOrder G] [LinearOrder P] [SMul G P] [IsOrderedCancelSMul G P] {s : Set G}\n    {t : Set P} (hs : s.IsWF) (ht : t.IsWF) : IsWF (s • t) :=\n  (hs.isPWO.smul ht.isPWO).isWF\n\n"}
{"name":"Set.IsWF.min_vadd","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : LinearOrder G\ninst✝² : LinearOrder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\ns : Set G\nt : Set P\nhs : s.IsWF\nht : t.IsWF\nhsn : s.Nonempty\nhtn : t.Nonempty\n⊢ Eq (⋯.min ⋯) (HVAdd.hVAdd (hs.min hsn) (ht.min htn))","decl":"@[to_additive]\ntheorem IsWF.min_smul [LinearOrder G] [LinearOrder P] [SMul G P] [IsOrderedCancelSMul G P]\n    {s : Set G} {t : Set P} (hs : s.IsWF) (ht : t.IsWF) (hsn : s.Nonempty) (htn : t.Nonempty) :\n    (hs.smul ht).min (hsn.smul htn) = hs.min hsn • ht.min htn := by\n  refine le_antisymm (IsWF.min_le _ _ (mem_smul.2 ⟨_, hs.min_mem _, _, ht.min_mem _, rfl⟩)) ?_\n  rw [IsWF.le_min_iff]\n  rintro _ ⟨x, hx, y, hy, rfl⟩\n  exact IsOrderedSMul.smul_le_smul (hs.min_le _ hx) (ht.min_le _ hy)\n\n"}
{"name":"Set.IsWF.min_smul","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : LinearOrder G\ninst✝² : LinearOrder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\ns : Set G\nt : Set P\nhs : s.IsWF\nht : t.IsWF\nhsn : s.Nonempty\nhtn : t.Nonempty\n⊢ Eq (⋯.min ⋯) (HSMul.hSMul (hs.min hsn) (ht.min htn))","decl":"@[to_additive]\ntheorem IsWF.min_smul [LinearOrder G] [LinearOrder P] [SMul G P] [IsOrderedCancelSMul G P]\n    {s : Set G} {t : Set P} (hs : s.IsWF) (ht : t.IsWF) (hsn : s.Nonempty) (htn : t.Nonempty) :\n    (hs.smul ht).min (hsn.smul htn) = hs.min hsn • ht.min htn := by\n  refine le_antisymm (IsWF.min_le _ _ (mem_smul.2 ⟨_, hs.min_mem _, _, ht.min_mem _, rfl⟩)) ?_\n  rw [IsWF.le_min_iff]\n  rintro _ ⟨x, hx, y, hy, rfl⟩\n  exact IsOrderedSMul.smul_le_smul (hs.min_le _ hx) (ht.min_le _ hy)\n\n"}
{"name":"Finset.mem_vaddAntidiagonal","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\ns : Set G\nt : Set P\nhs : s.IsPWO\nht : t.IsPWO\na : P\nx : Prod G P\n⊢ Iff (Membership.mem (Finset.VAddAntidiagonal hs ht a) x) (And (Membership.mem s x.1) (And (Membership.mem t x.2) (Eq (HVAdd.hVAdd x.1 x.2) a)))","decl":"@[to_additive (attr := simp)]\ntheorem mem_smulAntidiagonal :\n    x ∈ SMulAntidiagonal hs ht a ↔ x.1 ∈ s ∧ x.2 ∈ t ∧ x.1 • x.2 = a := by\n  simp only [SMulAntidiagonal, Set.Finite.mem_toFinset]\n  exact Set.mem_sep_iff\n\n"}
{"name":"Finset.mem_smulAntidiagonal","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\ns : Set G\nt : Set P\nhs : s.IsPWO\nht : t.IsPWO\na : P\nx : Prod G P\n⊢ Iff (Membership.mem (Finset.SMulAntidiagonal hs ht a) x) (And (Membership.mem s x.1) (And (Membership.mem t x.2) (Eq (HSMul.hSMul x.1 x.2) a)))","decl":"@[to_additive (attr := simp)]\ntheorem mem_smulAntidiagonal :\n    x ∈ SMulAntidiagonal hs ht a ↔ x.1 ∈ s ∧ x.2 ∈ t ∧ x.1 • x.2 = a := by\n  simp only [SMulAntidiagonal, Set.Finite.mem_toFinset]\n  exact Set.mem_sep_iff\n\n"}
{"name":"Finset.smulAntidiagonal_mono_left","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\ns : Set G\nt : Set P\nu : Set G\nhu : u.IsPWO\na : P\nhs : s.IsPWO\nht : t.IsPWO\nh : HasSubset.Subset u s\n⊢ HasSubset.Subset (Finset.SMulAntidiagonal hu ht a) (Finset.SMulAntidiagonal hs ht a)","decl":"@[to_additive]\ntheorem smulAntidiagonal_mono_left {a : P} {hs : s.IsPWO} {ht : t.IsPWO} (h : u ⊆ s) :\n    SMulAntidiagonal hu ht a ⊆ SMulAntidiagonal hs ht a :=\n  Set.Finite.toFinset_mono <| Set.smulAntidiagonal_mono_left h\n\n"}
{"name":"Finset.vaddAntidiagonal_mono_left","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\ns : Set G\nt : Set P\nu : Set G\nhu : u.IsPWO\na : P\nhs : s.IsPWO\nht : t.IsPWO\nh : HasSubset.Subset u s\n⊢ HasSubset.Subset (Finset.VAddAntidiagonal hu ht a) (Finset.VAddAntidiagonal hs ht a)","decl":"@[to_additive]\ntheorem smulAntidiagonal_mono_left {a : P} {hs : s.IsPWO} {ht : t.IsPWO} (h : u ⊆ s) :\n    SMulAntidiagonal hu ht a ⊆ SMulAntidiagonal hs ht a :=\n  Set.Finite.toFinset_mono <| Set.smulAntidiagonal_mono_left h\n\n"}
{"name":"Finset.vaddAntidiagonal_mono_right","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\ns : Set G\nt v : Set P\nhv : v.IsPWO\na : P\nhs : s.IsPWO\nht : t.IsPWO\nh : HasSubset.Subset v t\n⊢ HasSubset.Subset (Finset.VAddAntidiagonal hs hv a) (Finset.VAddAntidiagonal hs ht a)","decl":"@[to_additive]\ntheorem smulAntidiagonal_mono_right {a : P} {hs : s.IsPWO} {ht : t.IsPWO} (h : v ⊆ t) :\n    SMulAntidiagonal hs hv a ⊆ SMulAntidiagonal hs ht a :=\n  Set.Finite.toFinset_mono <| Set.smulAntidiagonal_mono_right h\n\n"}
{"name":"Finset.smulAntidiagonal_mono_right","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\ns : Set G\nt v : Set P\nhv : v.IsPWO\na : P\nhs : s.IsPWO\nht : t.IsPWO\nh : HasSubset.Subset v t\n⊢ HasSubset.Subset (Finset.SMulAntidiagonal hs hv a) (Finset.SMulAntidiagonal hs ht a)","decl":"@[to_additive]\ntheorem smulAntidiagonal_mono_right {a : P} {hs : s.IsPWO} {ht : t.IsPWO} (h : v ⊆ t) :\n    SMulAntidiagonal hs hv a ⊆ SMulAntidiagonal hs ht a :=\n  Set.Finite.toFinset_mono <| Set.smulAntidiagonal_mono_right h\n\n"}
{"name":"Finset.support_smulAntidiagonal_subset_smul","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\ns : Set G\nt : Set P\nhs : s.IsPWO\nht : t.IsPWO\n⊢ HasSubset.Subset (setOf fun a => (Finset.SMulAntidiagonal hs ht a).Nonempty) (HSMul.hSMul s t)","decl":"@[to_additive]\ntheorem support_smulAntidiagonal_subset_smul {hs : s.IsPWO} {ht : t.IsPWO} :\n    { a | (SMulAntidiagonal hs ht a).Nonempty } ⊆ (s • t) :=\n  fun a ⟨b, hb⟩ => by\n  rw [mem_smulAntidiagonal] at hb\n  rw [Set.mem_smul]\n  use b.1\n  refine { left := hb.1, right := ?_ }\n  use b.2\n  exact { left := hb.2.1, right := hb.2.2 }\n\n"}
{"name":"Finset.support_vaddAntidiagonal_subset_vadd","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\ns : Set G\nt : Set P\nhs : s.IsPWO\nht : t.IsPWO\n⊢ HasSubset.Subset (setOf fun a => (Finset.VAddAntidiagonal hs ht a).Nonempty) (HVAdd.hVAdd s t)","decl":"@[to_additive]\ntheorem support_smulAntidiagonal_subset_smul {hs : s.IsPWO} {ht : t.IsPWO} :\n    { a | (SMulAntidiagonal hs ht a).Nonempty } ⊆ (s • t) :=\n  fun a ⟨b, hb⟩ => by\n  rw [mem_smulAntidiagonal] at hb\n  rw [Set.mem_smul]\n  use b.1\n  refine { left := hb.1, right := ?_ }\n  use b.2\n  exact { left := hb.2.1, right := hb.2.2 }\n\n"}
{"name":"Finset.isPWO_support_vaddAntidiagonal","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\ns : Set G\nt : Set P\nhs : s.IsPWO\nht : t.IsPWO\n⊢ (setOf fun a => (Finset.VAddAntidiagonal hs ht a).Nonempty).IsPWO","decl":"@[to_additive]\ntheorem isPWO_support_smulAntidiagonal {hs : s.IsPWO} {ht : t.IsPWO} :\n    { a | (SMulAntidiagonal hs ht a).Nonempty }.IsPWO :=\n  (hs.smul ht).mono (support_smulAntidiagonal_subset_smul)\n\n"}
{"name":"Finset.isPWO_support_smulAntidiagonal","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\ns : Set G\nt : Set P\nhs : s.IsPWO\nht : t.IsPWO\n⊢ (setOf fun a => (Finset.SMulAntidiagonal hs ht a).Nonempty).IsPWO","decl":"@[to_additive]\ntheorem isPWO_support_smulAntidiagonal {hs : s.IsPWO} {ht : t.IsPWO} :\n    { a | (SMulAntidiagonal hs ht a).Nonempty }.IsPWO :=\n  (hs.smul ht).mono (support_smulAntidiagonal_subset_smul)\n\n"}
{"name":"Finset.smulAntidiagonal_min_smul_min","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : LinearOrder G\ninst✝² : LinearOrder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\ns : Set G\nt : Set P\nhs : s.IsWF\nht : t.IsWF\nhns : s.Nonempty\nhnt : t.Nonempty\n⊢ Eq (Finset.SMulAntidiagonal ⋯ ⋯ (HSMul.hSMul (hs.min hns) (ht.min hnt))) (Singleton.singleton { fst := hs.min hns, snd := ht.min hnt })","decl":"@[to_additive]\ntheorem smulAntidiagonal_min_smul_min [LinearOrder G] [LinearOrder P] [SMul G P]\n    [IsOrderedCancelSMul G P] {s : Set G} {t : Set P} (hs : s.IsWF) (ht : t.IsWF) (hns : s.Nonempty)\n    (hnt : t.Nonempty) :\n    SMulAntidiagonal hs.isPWO ht.isPWO (hs.min hns • ht.min hnt) = {(hs.min hns, ht.min hnt)} := by\n  ext ⟨a, b⟩\n  simp only [mem_smulAntidiagonal, mem_singleton, Prod.ext_iff]\n  constructor\n  · rintro ⟨has, hat, hst⟩\n    obtain rfl :=\n      (hs.min_le hns has).eq_of_not_lt fun hlt =>\n        (SMul.smul_lt_smul_of_lt_of_le hlt <| ht.min_le hnt hat).ne' hst\n    exact ⟨rfl, IsCancelSMul.left_cancel _ _ _ hst⟩\n  · rintro ⟨rfl, rfl⟩\n    exact ⟨hs.min_mem _, ht.min_mem _, rfl⟩\n\n"}
{"name":"Finset.vaddAntidiagonal_min_vadd_min","module":"Mathlib.Data.Finset.SMulAntidiagonal","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : LinearOrder G\ninst✝² : LinearOrder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\ns : Set G\nt : Set P\nhs : s.IsWF\nht : t.IsWF\nhns : s.Nonempty\nhnt : t.Nonempty\n⊢ Eq (Finset.VAddAntidiagonal ⋯ ⋯ (HVAdd.hVAdd (hs.min hns) (ht.min hnt))) (Singleton.singleton { fst := hs.min hns, snd := ht.min hnt })","decl":"@[to_additive]\ntheorem smulAntidiagonal_min_smul_min [LinearOrder G] [LinearOrder P] [SMul G P]\n    [IsOrderedCancelSMul G P] {s : Set G} {t : Set P} (hs : s.IsWF) (ht : t.IsWF) (hns : s.Nonempty)\n    (hnt : t.Nonempty) :\n    SMulAntidiagonal hs.isPWO ht.isPWO (hs.min hns • ht.min hnt) = {(hs.min hns, ht.min hnt)} := by\n  ext ⟨a, b⟩\n  simp only [mem_smulAntidiagonal, mem_singleton, Prod.ext_iff]\n  constructor\n  · rintro ⟨has, hat, hst⟩\n    obtain rfl :=\n      (hs.min_le hns has).eq_of_not_lt fun hlt =>\n        (SMul.smul_lt_smul_of_lt_of_le hlt <| ht.min_le hnt hat).ne' hst\n    exact ⟨rfl, IsCancelSMul.left_cancel _ _ _ hst⟩\n  · rintro ⟨rfl, rfl⟩\n    exact ⟨hs.min_mem _, ht.min_mem _, rfl⟩\n\n"}
