{"name":"TopCat.pullbackFst_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : ‚Üë(TopCat.of (Subtype fun p => Eq (f p.1) (g p.2)))\n‚ä¢ Eq ((TopCat.pullbackFst f g) x) (‚Üëx).1","decl":"lemma pullbackFst_apply (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (x) : pullbackFst f g x = x.1.1 := rfl\n\n"}
{"name":"TopCat.pullbackSnd_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : ‚Üë(TopCat.of (Subtype fun p => Eq (f p.1) (g p.2)))\n‚ä¢ Eq ((TopCat.pullbackSnd f g) x) (‚Üëx).2","decl":"lemma pullbackSnd_apply (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (x) : pullbackSnd f g x = x.1.2 := rfl\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_inv_fst_assoc","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z‚úù : TopCat\nf : Quiver.Hom X Z‚úù\ng : Quiver.Hom Y Z‚úù\nZ : TopCat\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.pullbackIsoProdSubtype f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)) (CategoryTheory.CategoryStruct.comp (TopCat.pullbackFst f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoProdSubtype_inv_fst (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :\n    (pullbackIsoProdSubtype f g).inv ‚â´ pullback.fst _ _ = pullbackFst f g := by\n  simp [pullbackCone, pullbackIsoProdSubtype]\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_inv_fst","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.pullbackIsoProdSubtype f g).inv (CategoryTheory.Limits.pullback.fst f g)) (TopCat.pullbackFst f g)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoProdSubtype_inv_fst (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :\n    (pullbackIsoProdSubtype f g).inv ‚â´ pullback.fst _ _ = pullbackFst f g := by\n  simp [pullbackCone, pullbackIsoProdSubtype]\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_inv_fst_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : Subtype fun p => Eq (f p.1) (g p.2)\n‚ä¢ Eq ((CategoryTheory.Limits.pullback.fst f g) ((TopCat.pullbackIsoProdSubtype f g).inv x)) (‚Üëx).1","decl":"theorem pullbackIsoProdSubtype_inv_fst_apply (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)\n    (x : { p : X √ó Y // f p.1 = g p.2 }) :\n    pullback.fst f g ((pullbackIsoProdSubtype f g).inv x) = (x : X √ó Y).fst :=\n  ConcreteCategory.congr_hom (pullbackIsoProdSubtype_inv_fst f g) x\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_inv_snd_assoc","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z‚úù : TopCat\nf : Quiver.Hom X Z‚úù\ng : Quiver.Hom Y Z‚úù\nZ : TopCat\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.pullbackIsoProdSubtype f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)) (CategoryTheory.CategoryStruct.comp (TopCat.pullbackSnd f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoProdSubtype_inv_snd (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :\n    (pullbackIsoProdSubtype f g).inv ‚â´ pullback.snd _ _ = pullbackSnd f g := by\n  simp [pullbackCone, pullbackIsoProdSubtype]\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_inv_snd","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.pullbackIsoProdSubtype f g).inv (CategoryTheory.Limits.pullback.snd f g)) (TopCat.pullbackSnd f g)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoProdSubtype_inv_snd (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :\n    (pullbackIsoProdSubtype f g).inv ‚â´ pullback.snd _ _ = pullbackSnd f g := by\n  simp [pullbackCone, pullbackIsoProdSubtype]\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_inv_snd_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : Subtype fun p => Eq (f p.1) (g p.2)\n‚ä¢ Eq ((CategoryTheory.Limits.pullback.snd f g) ((TopCat.pullbackIsoProdSubtype f g).inv x)) (‚Üëx).2","decl":"theorem pullbackIsoProdSubtype_inv_snd_apply (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)\n    (x : { p : X √ó Y // f p.1 = g p.2 }) :\n    pullback.snd f g ((pullbackIsoProdSubtype f g).inv x) = (x : X √ó Y).snd :=\n  ConcreteCategory.congr_hom (pullbackIsoProdSubtype_inv_snd f g) x\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_hom_fst","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.pullbackIsoProdSubtype f g).hom (TopCat.pullbackFst f g)) (CategoryTheory.Limits.pullback.fst f g)","decl":"theorem pullbackIsoProdSubtype_hom_fst (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :\n    (pullbackIsoProdSubtype f g).hom ‚â´ pullbackFst f g = pullback.fst _ _ := by\n  rw [‚Üê Iso.eq_inv_comp, pullbackIsoProdSubtype_inv_fst]\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_hom_snd","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.pullbackIsoProdSubtype f g).hom (TopCat.pullbackSnd f g)) (CategoryTheory.Limits.pullback.snd f g)","decl":"theorem pullbackIsoProdSubtype_hom_snd (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :\n    (pullbackIsoProdSubtype f g).hom ‚â´ pullbackSnd f g = pullback.snd _ _ := by\n  rw [‚Üê Iso.eq_inv_comp, pullbackIsoProdSubtype_inv_snd]\n\n-- Porting note: why do I need to tell Lean to coerce pullback to a type\n"}
{"name":"TopCat.pullbackIsoProdSubtype_hom_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : CategoryTheory.HasForget.forget.obj (CategoryTheory.Limits.pullback f g)\n‚ä¢ Eq ((TopCat.pullbackIsoProdSubtype f g).hom x) ‚ü®{ fst := (CategoryTheory.Limits.pullback.fst f g) x, snd := (CategoryTheory.Limits.pullback.snd f g) x }, ‚ãØ‚ü©","decl":"theorem pullbackIsoProdSubtype_hom_apply {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}\n    (x : HasForget.forget.obj (pullback f g)) :\n    (pullbackIsoProdSubtype f g).hom x =\n      ‚ü®‚ü®pullback.fst f g x, pullback.snd f g x‚ü©, by\n        simpa using ConcreteCategory.congr_hom pullback.condition x‚ü© := by\n  apply Subtype.ext; apply Prod.ext\n  exacts [ConcreteCategory.congr_hom (pullbackIsoProdSubtype_hom_fst f g) x,\n    ConcreteCategory.congr_hom (pullbackIsoProdSubtype_hom_snd f g) x]\n\n"}
{"name":"TopCat.pullback_topology","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.Limits.pullback f g).str (Min.min (TopologicalSpace.induced (‚áë(CategoryTheory.Limits.pullback.fst f g)) X.str) (TopologicalSpace.induced (‚áë(CategoryTheory.Limits.pullback.snd f g)) Y.str))","decl":"theorem pullback_topology {X Y Z : TopCat.{u}} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :\n    (pullback f g).str =\n      induced (pullback.fst f g) X.str ‚äì\n        induced (pullback.snd f g) Y.str := by\n  let homeo := homeoOfIso (pullbackIsoProdSubtype f g)\n  refine homeo.isInducing.eq_induced.trans ?_\n  change induced homeo (induced _ ( (induced Prod.fst X.str) ‚äì (induced Prod.snd Y.str))) = _\n  simp only [induced_compose, induced_inf]\n  congr\n\n"}
{"name":"TopCat.range_pullback_to_prod","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Eq (Set.range ‚áë(CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.snd f g))) (setOf fun x => Eq ((CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst f) x) ((CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd g) x))","decl":"theorem range_pullback_to_prod {X Y Z : TopCat} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :\n    Set.range (prod.lift (pullback.fst f g) (pullback.snd f g)) =\n      { x | (Limits.prod.fst ‚â´ f) x = (Limits.prod.snd ‚â´ g) x } := by\n  ext x\n  constructor\n  ¬∑ rintro ‚ü®y, rfl‚ü©\n    change (_ ‚â´ _ ‚â´ f) _ = (_ ‚â´ _ ‚â´ g) _ -- new `change` after https://github.com/leanprover-community/mathlib4/pull/13170\n    simp [pullback.condition]\n  ¬∑ rintro (h : f (_, _).1 = g (_, _).2)\n    use (pullbackIsoProdSubtype f g).inv ‚ü®‚ü®_, _‚ü©, h‚ü©\n    change (forget TopCat).map _ _ = _ -- new `change` after https://github.com/leanprover-community/mathlib4/pull/13170\n    apply Concrete.limit_ext\n    rintro ‚ü®‚ü®‚ü©‚ü© <;>\n    erw [‚Üê CategoryTheory.comp_apply, ‚Üê CategoryTheory.comp_apply, limit.lift_œÄ] <;> -- now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n    -- This used to be `simp` before https://github.com/leanprover/lean4/pull/2644\n    aesop_cat\n\n"}
{"name":"TopCat.isInducing_pullback_to_prod","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Topology.IsInducing ‚áë(CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.snd f g))","decl":"theorem isInducing_pullback_to_prod {X Y Z : TopCat.{u}} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :\n    IsInducing <| ‚áë(prod.lift (pullback.fst f g) (pullback.snd f g)) :=\n  ‚ü®by simp [topologicalSpace_coe, prod_topology, pullback_topology, induced_compose, ‚Üê coe_comp]‚ü©\n\n"}
{"name":"TopCat.inducing_pullback_to_prod","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Topology.IsInducing ‚áë(CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.snd f g))","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_pullback_to_prod := isInducing_pullback_to_prod\n\n"}
{"name":"TopCat.isEmbedding_pullback_to_prod","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Topology.IsEmbedding ‚áë(CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.snd f g))","decl":"theorem isEmbedding_pullback_to_prod {X Y Z : TopCat.{u}} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :\n    IsEmbedding <| ‚áë(prod.lift (pullback.fst f g) (pullback.snd f g)) :=\n  ‚ü®isInducing_pullback_to_prod f g, (TopCat.mono_iff_injective _).mp inferInstance‚ü©\n\n"}
{"name":"TopCat.embedding_pullback_to_prod","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n‚ä¢ Topology.IsEmbedding ‚áë(CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.snd f g))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_pullback_to_prod := isEmbedding_pullback_to_prod\n\n"}
{"name":"TopCat.range_pullback_map","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"W X Y Z S T : TopCat\nf‚ÇÅ : Quiver.Hom W S\nf‚ÇÇ : Quiver.Hom X S\ng‚ÇÅ : Quiver.Hom Y T\ng‚ÇÇ : Quiver.Hom Z T\ni‚ÇÅ : Quiver.Hom W Y\ni‚ÇÇ : Quiver.Hom X Z\ni‚ÇÉ : Quiver.Hom S T\nH‚ÇÉ : CategoryTheory.Mono i‚ÇÉ\neq‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ g‚ÇÅ)\neq‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÇ i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÇ g‚ÇÇ)\n‚ä¢ Eq (Set.range ‚áë(CategoryTheory.Limits.pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ)) (Inter.inter (Set.preimage (‚áë(CategoryTheory.Limits.pullback.fst g‚ÇÅ g‚ÇÇ)) (Set.range ‚áëi‚ÇÅ)) (Set.preimage (‚áë(CategoryTheory.Limits.pullback.snd g‚ÇÅ g‚ÇÇ)) (Set.range ‚áëi‚ÇÇ)))","decl":"/-- If the map `S ‚ü∂ T` is mono, then there is a description of the image of `W √ó‚Çõ X ‚ü∂ Y √ó‚Çú Z`. -/\ntheorem range_pullback_map {W X Y Z S T : TopCat} (f‚ÇÅ : W ‚ü∂ S) (f‚ÇÇ : X ‚ü∂ S) (g‚ÇÅ : Y ‚ü∂ T)\n    (g‚ÇÇ : Z ‚ü∂ T) (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T) [H‚ÇÉ : Mono i‚ÇÉ] (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ)\n    (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ) :\n    Set.range (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) =\n      (pullback.fst g‚ÇÅ g‚ÇÇ) ‚Åª¬π' Set.range i‚ÇÅ ‚à© (pullback.snd g‚ÇÅ g‚ÇÇ) ‚Åª¬π' Set.range i‚ÇÇ := by\n  ext\n  constructor\n  ¬∑ rintro ‚ü®y, rfl‚ü©\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range]\n    rw [‚Üê CategoryTheory.comp_apply, ‚Üê CategoryTheory.comp_apply]\n    simp only [limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app, CategoryTheory.comp_apply]\n    exact ‚ü®exists_apply_eq_apply _ _, exists_apply_eq_apply _ _‚ü©\n  rintro ‚ü®‚ü®x‚ÇÅ, hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hx‚ÇÇ‚ü©‚ü©\n  have : f‚ÇÅ x‚ÇÅ = f‚ÇÇ x‚ÇÇ := by\n    apply (TopCat.mono_iff_injective _).mp H‚ÇÉ\n    rw [‚Üê CategoryTheory.comp_apply, eq‚ÇÅ, ‚Üê CategoryTheory.comp_apply, eq‚ÇÇ,\n      CategoryTheory.comp_apply, CategoryTheory.comp_apply, hx‚ÇÅ, hx‚ÇÇ, ‚Üê CategoryTheory.comp_apply,\n      pullback.condition]\n    rfl -- `rfl` was not needed before https://github.com/leanprover-community/mathlib4/pull/13170\n  use (pullbackIsoProdSubtype f‚ÇÅ f‚ÇÇ).inv ‚ü®‚ü®x‚ÇÅ, x‚ÇÇ‚ü©, this‚ü©\n  change (forget TopCat).map _ _ = _\n  apply Concrete.limit_ext\n  rintro (_ | _ | _) <;>\n  erw [‚Üê CategoryTheory.comp_apply, ‚Üê CategoryTheory.comp_apply] -- now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n  ¬∑ simp only [Category.assoc, limit.lift_œÄ, PullbackCone.mk_œÄ_app_one]\n    simp only [cospan_one, pullbackIsoProdSubtype_inv_fst_assoc, CategoryTheory.comp_apply]\n    rw [pullbackFst_apply, hx‚ÇÅ, ‚Üê limit.w _ WalkingCospan.Hom.inl, cospan_map_inl,\n        CategoryTheory.comp_apply (g := g‚ÇÅ)]\n  ¬∑ simp only [cospan_left, limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app,\n      pullbackIsoProdSubtype_inv_fst_assoc, CategoryTheory.comp_apply]\n    erw [hx‚ÇÅ] -- now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n  ¬∑ simp only [cospan_right, limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app,\n      pullbackIsoProdSubtype_inv_snd_assoc, CategoryTheory.comp_apply]\n    erw [hx‚ÇÇ] -- now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n\n"}
{"name":"TopCat.pullback_fst_range","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\n‚ä¢ Eq (Set.range ‚áë(CategoryTheory.Limits.pullback.fst f g)) (setOf fun x => Exists fun y => Eq (f x) (g y))","decl":"theorem pullback_fst_range {X Y S : TopCat} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) :\n    Set.range (pullback.fst f g) = { x : X | ‚àÉ y : Y, f x = g y } := by\n  ext x\n  constructor\n  ¬∑ rintro ‚ü®(y : (forget TopCat).obj _), rfl‚ü©\n    use (pullback.snd f g) y\n    exact ConcreteCategory.congr_hom pullback.condition y\n  ¬∑ rintro ‚ü®y, eq‚ü©\n    use (TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®x, y‚ü©, eq‚ü©\n    rw [pullbackIsoProdSubtype_inv_fst_apply]\n\n"}
{"name":"TopCat.pullback_snd_range","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\n‚ä¢ Eq (Set.range ‚áë(CategoryTheory.Limits.pullback.snd f g)) (setOf fun y => Exists fun x => Eq (f x) (g y))","decl":"theorem pullback_snd_range {X Y S : TopCat} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) :\n    Set.range (pullback.snd f g) = { y : Y | ‚àÉ x : X, f x = g y } := by\n  ext y\n  constructor\n  ¬∑ rintro ‚ü®(x : (forget TopCat).obj _), rfl‚ü©\n    use (pullback.fst f g) x\n    exact ConcreteCategory.congr_hom pullback.condition x\n  ¬∑ rintro ‚ü®x, eq‚ü©\n    use (TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®x, y‚ü©, eq‚ü©\n    rw [pullbackIsoProdSubtype_inv_snd_apply]\n\n"}
{"name":"TopCat.pullback_map_isEmbedding","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"W X Y Z S T : TopCat\nf‚ÇÅ : Quiver.Hom W S\nf‚ÇÇ : Quiver.Hom X S\ng‚ÇÅ : Quiver.Hom Y T\ng‚ÇÇ : Quiver.Hom Z T\ni‚ÇÅ : Quiver.Hom W Y\ni‚ÇÇ : Quiver.Hom X Z\nH‚ÇÅ : Topology.IsEmbedding ‚áëi‚ÇÅ\nH‚ÇÇ : Topology.IsEmbedding ‚áëi‚ÇÇ\ni‚ÇÉ : Quiver.Hom S T\neq‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ g‚ÇÅ)\neq‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÇ i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÇ g‚ÇÇ)\n‚ä¢ Topology.IsEmbedding ‚áë(CategoryTheory.Limits.pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ)","decl":"/-- If there is a diagram where the morphisms `W ‚ü∂ Y` and `X ‚ü∂ Z` are embeddings,\nthen the induced morphism `W √ó‚Çõ X ‚ü∂ Y √ó‚Çú Z` is also an embedding.\n\n```\nW ‚ü∂ Y\n ‚Üò   ‚Üò\n  S ‚ü∂ T\n ‚Üó   ‚Üó\nX ‚ü∂ Z\n```\n-/\ntheorem pullback_map_isEmbedding {W X Y Z S T : TopCat.{u}} (f‚ÇÅ : W ‚ü∂ S) (f‚ÇÇ : X ‚ü∂ S)\n    (g‚ÇÅ : Y ‚ü∂ T) (g‚ÇÇ : Z ‚ü∂ T) {i‚ÇÅ : W ‚ü∂ Y} {i‚ÇÇ : X ‚ü∂ Z} (H‚ÇÅ : IsEmbedding i‚ÇÅ)\n    (H‚ÇÇ : IsEmbedding i‚ÇÇ) (i‚ÇÉ : S ‚ü∂ T) (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ) (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ) :\n    IsEmbedding (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) := by\n  refine .of_comp (ContinuousMap.continuous_toFun _)\n    (show Continuous (prod.lift (pullback.fst g‚ÇÅ g‚ÇÇ) (pullback.snd g‚ÇÅ g‚ÇÇ)) from\n        ContinuousMap.continuous_toFun _)\n      ?_\n  suffices\n    IsEmbedding (prod.lift (pullback.fst f‚ÇÅ f‚ÇÇ) (pullback.snd f‚ÇÅ f‚ÇÇ) ‚â´ Limits.prod.map i‚ÇÅ i‚ÇÇ) by\n    simpa [‚Üê coe_comp] using this\n  rw [coe_comp]\n  exact (isEmbedding_prodMap H‚ÇÅ H‚ÇÇ).comp (isEmbedding_pullback_to_prod _ _)\n\n"}
{"name":"TopCat.pullback_map_embedding_of_embeddings","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"W X Y Z S T : TopCat\nf‚ÇÅ : Quiver.Hom W S\nf‚ÇÇ : Quiver.Hom X S\ng‚ÇÅ : Quiver.Hom Y T\ng‚ÇÇ : Quiver.Hom Z T\ni‚ÇÅ : Quiver.Hom W Y\ni‚ÇÇ : Quiver.Hom X Z\nH‚ÇÅ : Topology.IsEmbedding ‚áëi‚ÇÅ\nH‚ÇÇ : Topology.IsEmbedding ‚áëi‚ÇÇ\ni‚ÇÉ : Quiver.Hom S T\neq‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ g‚ÇÅ)\neq‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÇ i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÇ g‚ÇÇ)\n‚ä¢ Topology.IsEmbedding ‚áë(CategoryTheory.Limits.pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias pullback_map_embedding_of_embeddings := pullback_map_isEmbedding\n\n"}
{"name":"TopCat.pullback_map_isOpenEmbedding","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"W X Y Z S T : TopCat\nf‚ÇÅ : Quiver.Hom W S\nf‚ÇÇ : Quiver.Hom X S\ng‚ÇÅ : Quiver.Hom Y T\ng‚ÇÇ : Quiver.Hom Z T\ni‚ÇÅ : Quiver.Hom W Y\ni‚ÇÇ : Quiver.Hom X Z\nH‚ÇÅ : Topology.IsOpenEmbedding ‚áëi‚ÇÅ\nH‚ÇÇ : Topology.IsOpenEmbedding ‚áëi‚ÇÇ\ni‚ÇÉ : Quiver.Hom S T\nH‚ÇÉ : CategoryTheory.Mono i‚ÇÉ\neq‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ g‚ÇÅ)\neq‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÇ i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÇ g‚ÇÇ)\n‚ä¢ Topology.IsOpenEmbedding ‚áë(CategoryTheory.Limits.pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ)","decl":"/-- If there is a diagram where the morphisms `W ‚ü∂ Y` and `X ‚ü∂ Z` are open embeddings, and `S ‚ü∂ T`\nis mono, then the induced morphism `W √ó‚Çõ X ‚ü∂ Y √ó‚Çú Z` is also an open embedding.\n\n```\nW ‚ü∂ Y\n ‚Üò   ‚Üò\n  S ‚ü∂ T\n ‚Üó   ‚Üó\nX ‚ü∂ Z\n```\n-/\ntheorem pullback_map_isOpenEmbedding {W X Y Z S T : TopCat.{u}} (f‚ÇÅ : W ‚ü∂ S)\n    (f‚ÇÇ : X ‚ü∂ S) (g‚ÇÅ : Y ‚ü∂ T) (g‚ÇÇ : Z ‚ü∂ T) {i‚ÇÅ : W ‚ü∂ Y} {i‚ÇÇ : X ‚ü∂ Z} (H‚ÇÅ : IsOpenEmbedding i‚ÇÅ)\n    (H‚ÇÇ : IsOpenEmbedding i‚ÇÇ) (i‚ÇÉ : S ‚ü∂ T) [H‚ÇÉ : Mono i‚ÇÉ] (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ)\n    (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ) : IsOpenEmbedding (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) := by\n  constructor\n  ¬∑ apply\n      pullback_map_isEmbedding f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ H‚ÇÅ.isEmbedding H‚ÇÇ.isEmbedding i‚ÇÉ eq‚ÇÅ eq‚ÇÇ\n  ¬∑ rw [range_pullback_map]\n    apply IsOpen.inter <;> apply Continuous.isOpen_preimage\n    ¬∑ apply ContinuousMap.continuous_toFun\n    ¬∑ exact H‚ÇÅ.isOpen_range\n    ¬∑ apply ContinuousMap.continuous_toFun\n    ¬∑ exact H‚ÇÇ.isOpen_range\n\n"}
{"name":"TopCat.pullback_map_openEmbedding_of_open_embeddings","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"W X Y Z S T : TopCat\nf‚ÇÅ : Quiver.Hom W S\nf‚ÇÇ : Quiver.Hom X S\ng‚ÇÅ : Quiver.Hom Y T\ng‚ÇÇ : Quiver.Hom Z T\ni‚ÇÅ : Quiver.Hom W Y\ni‚ÇÇ : Quiver.Hom X Z\nH‚ÇÅ : Topology.IsOpenEmbedding ‚áëi‚ÇÅ\nH‚ÇÇ : Topology.IsOpenEmbedding ‚áëi‚ÇÇ\ni‚ÇÉ : Quiver.Hom S T\nH‚ÇÉ : CategoryTheory.Mono i‚ÇÉ\neq‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÅ g‚ÇÅ)\neq‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÇ i‚ÇÉ) (CategoryTheory.CategoryStruct.comp i‚ÇÇ g‚ÇÇ)\n‚ä¢ Topology.IsOpenEmbedding ‚áë(CategoryTheory.Limits.pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias pullback_map_openEmbedding_of_open_embeddings := pullback_map_isOpenEmbedding\n\n\n"}
{"name":"TopCat.snd_isEmbedding_of_left","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\nH : Topology.IsEmbedding ‚áëf\ng : Quiver.Hom Y S\n‚ä¢ Topology.IsEmbedding ‚áë(CategoryTheory.Limits.pullback.snd f g)","decl":"lemma snd_isEmbedding_of_left {X Y S : TopCat} {f : X ‚ü∂ S} (H : IsEmbedding f) (g : Y ‚ü∂ S) :\n    IsEmbedding <| ‚áë(pullback.snd f g) := by\n  convert (homeoOfIso (asIso (pullback.snd (ùüô S) g))).isEmbedding.comp\n      (pullback_map_isEmbedding (i‚ÇÇ := ùüô Y)\n        f g (ùüô S) g H (homeoOfIso (Iso.refl _)).isEmbedding (ùüô _) rfl (by simp))\n  erw [‚Üê coe_comp]\n  simp\n\n"}
{"name":"TopCat.snd_embedding_of_left_embedding","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\nH : Topology.IsEmbedding ‚áëf\ng : Quiver.Hom Y S\n‚ä¢ Topology.IsEmbedding ‚áë(CategoryTheory.Limits.pullback.snd f g)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias snd_embedding_of_left_embedding := snd_isEmbedding_of_left\n\n"}
{"name":"TopCat.fst_isEmbedding_of_right","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH : Topology.IsEmbedding ‚áëg\n‚ä¢ Topology.IsEmbedding ‚áë(CategoryTheory.Limits.pullback.fst f g)","decl":"theorem fst_isEmbedding_of_right {X Y S : TopCat} (f : X ‚ü∂ S) {g : Y ‚ü∂ S}\n    (H : IsEmbedding g) : IsEmbedding <| ‚áë(pullback.fst f g) := by\n  convert (homeoOfIso (asIso (pullback.fst f (ùüô S)))).isEmbedding.comp\n      (pullback_map_isEmbedding (i‚ÇÅ := ùüô X)\n        f g f (ùüô _) (homeoOfIso (Iso.refl _)).isEmbedding H (ùüô _) rfl (by simp))\n  erw [‚Üê coe_comp]\n  simp\n\n"}
{"name":"TopCat.fst_embedding_of_right_embedding","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH : Topology.IsEmbedding ‚áëg\n‚ä¢ Topology.IsEmbedding ‚áë(CategoryTheory.Limits.pullback.fst f g)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias fst_embedding_of_right_embedding := fst_isEmbedding_of_right\n\n"}
{"name":"TopCat.isEmbedding_of_pullback","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH‚ÇÅ : Topology.IsEmbedding ‚áëf\nH‚ÇÇ : Topology.IsEmbedding ‚áëg\n‚ä¢ Topology.IsEmbedding ‚áë(CategoryTheory.Limits.limit.œÄ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)","decl":"theorem isEmbedding_of_pullback {X Y S : TopCat} {f : X ‚ü∂ S} {g : Y ‚ü∂ S} (H‚ÇÅ : IsEmbedding f)\n    (H‚ÇÇ : IsEmbedding g) : IsEmbedding (limit.œÄ (cospan f g) WalkingCospan.one) := by\n  convert H‚ÇÇ.comp (snd_isEmbedding_of_left H‚ÇÅ g)\n  rw [‚Üê coe_comp, ‚Üê limit.w _ WalkingCospan.Hom.inr]\n  rfl\n\n"}
{"name":"TopCat.embedding_of_pullback_embeddings","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH‚ÇÅ : Topology.IsEmbedding ‚áëf\nH‚ÇÇ : Topology.IsEmbedding ‚áëg\n‚ä¢ Topology.IsEmbedding ‚áë(CategoryTheory.Limits.limit.œÄ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_of_pullback_embeddings := isEmbedding_of_pullback\n\n"}
{"name":"TopCat.snd_isOpenEmbedding_of_left","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\nH : Topology.IsOpenEmbedding ‚áëf\ng : Quiver.Hom Y S\n‚ä¢ Topology.IsOpenEmbedding ‚áë(CategoryTheory.Limits.pullback.snd f g)","decl":"theorem snd_isOpenEmbedding_of_left {X Y S : TopCat} {f : X ‚ü∂ S} (H : IsOpenEmbedding f)\n    (g : Y ‚ü∂ S) : IsOpenEmbedding <| ‚áë(pullback.snd f g) := by\n  convert (homeoOfIso (asIso (pullback.snd (ùüô S) g))).isOpenEmbedding.comp\n      (pullback_map_isOpenEmbedding (i‚ÇÇ := ùüô Y) f g (ùüô _) g H\n        (homeoOfIso (Iso.refl _)).isOpenEmbedding (ùüô _) rfl (by simp))\n  erw [‚Üê coe_comp]\n  simp\n\n"}
{"name":"TopCat.snd_openEmbedding_of_left_openEmbedding","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\nH : Topology.IsOpenEmbedding ‚áëf\ng : Quiver.Hom Y S\n‚ä¢ Topology.IsOpenEmbedding ‚áë(CategoryTheory.Limits.pullback.snd f g)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias snd_openEmbedding_of_left_openEmbedding := snd_isOpenEmbedding_of_left\n\n"}
{"name":"TopCat.fst_isOpenEmbedding_of_right","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH : Topology.IsOpenEmbedding ‚áëg\n‚ä¢ Topology.IsOpenEmbedding ‚áë(CategoryTheory.Limits.pullback.fst f g)","decl":"theorem fst_isOpenEmbedding_of_right {X Y S : TopCat} (f : X ‚ü∂ S) {g : Y ‚ü∂ S}\n    (H : IsOpenEmbedding g) : IsOpenEmbedding <| ‚áë(pullback.fst f g) := by\n  convert (homeoOfIso (asIso (pullback.fst f (ùüô S)))).isOpenEmbedding.comp\n      (pullback_map_isOpenEmbedding (i‚ÇÅ := ùüô X) f g f (ùüô _)\n        (homeoOfIso (Iso.refl _)).isOpenEmbedding H (ùüô _) rfl (by simp))\n  erw [‚Üê coe_comp]\n  simp\n\n"}
{"name":"TopCat.fst_openEmbedding_of_right_openEmbedding","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH : Topology.IsOpenEmbedding ‚áëg\n‚ä¢ Topology.IsOpenEmbedding ‚áë(CategoryTheory.Limits.pullback.fst f g)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias fst_openEmbedding_of_right_openEmbedding := fst_isOpenEmbedding_of_right\n\n"}
{"name":"TopCat.isOpenEmbedding_of_pullback","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH‚ÇÅ : Topology.IsOpenEmbedding ‚áëf\nH‚ÇÇ : Topology.IsOpenEmbedding ‚áëg\n‚ä¢ Topology.IsOpenEmbedding ‚áë(CategoryTheory.Limits.limit.œÄ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)","decl":"/-- If `X ‚ü∂ S`, `Y ‚ü∂ S` are open embeddings, then so is `X √ó‚Çõ Y ‚ü∂ S`. -/\ntheorem isOpenEmbedding_of_pullback {X Y S : TopCat} {f : X ‚ü∂ S} {g : Y ‚ü∂ S}\n    (H‚ÇÅ : IsOpenEmbedding f) (H‚ÇÇ : IsOpenEmbedding g) :\n    IsOpenEmbedding (limit.œÄ (cospan f g) WalkingCospan.one) := by\n  convert H‚ÇÇ.comp (snd_isOpenEmbedding_of_left H‚ÇÅ g)\n  rw [‚Üê coe_comp, ‚Üê limit.w _ WalkingCospan.Hom.inr]\n  rfl\n\n"}
{"name":"TopCat.isOpenEmbedding_of_pullback_open_embeddings","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH‚ÇÅ : Topology.IsOpenEmbedding ‚áëf\nH‚ÇÇ : Topology.IsOpenEmbedding ‚áëg\n‚ä¢ Topology.IsOpenEmbedding ‚áë(CategoryTheory.Limits.limit.œÄ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)","decl":"@[deprecated (since := \"2024-10-30\")]\nalias isOpenEmbedding_of_pullback_open_embeddings := isOpenEmbedding_of_pullback\n\n"}
{"name":"TopCat.openEmbedding_of_pullback_open_embeddings","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH‚ÇÅ : Topology.IsOpenEmbedding ‚áëf\nH‚ÇÇ : Topology.IsOpenEmbedding ‚áëg\n‚ä¢ Topology.IsOpenEmbedding ‚áë(CategoryTheory.Limits.limit.œÄ (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_of_pullback_open_embeddings := isOpenEmbedding_of_pullback\n\n"}
{"name":"TopCat.fst_iso_of_right_embedding_range_subset","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nhg : Topology.IsEmbedding ‚áëg\nH : HasSubset.Subset (Set.range ‚áëf) (Set.range ‚áëg)\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.fst f g)","decl":"theorem fst_iso_of_right_embedding_range_subset {X Y S : TopCat} (f : X ‚ü∂ S) {g : Y ‚ü∂ S}\n    (hg : IsEmbedding g) (H : Set.range f ‚äÜ Set.range g) :\n    IsIso (pullback.fst f g) := by\n  let esto : (pullback f g : TopCat) ‚âÉ‚Çú X :=\n    (Homeomorph.ofIsEmbedding _ (fst_isEmbedding_of_right f hg)).trans\n      { toFun := Subtype.val\n        invFun := fun x =>\n          ‚ü®x, by\n            rw [pullback_fst_range]\n            exact ‚ü®_, (H (Set.mem_range_self x)).choose_spec.symm‚ü©‚ü©\n        left_inv := fun ‚ü®_, _‚ü© => rfl\n        right_inv := fun x => rfl }\n  convert (isoOfHomeo esto).isIso_hom\n\n"}
{"name":"TopCat.snd_iso_of_left_embedding_range_subset","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\nhf : Topology.IsEmbedding ‚áëf\ng : Quiver.Hom Y S\nH : HasSubset.Subset (Set.range ‚áëg) (Set.range ‚áëf)\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.snd f g)","decl":"theorem snd_iso_of_left_embedding_range_subset {X Y S : TopCat} {f : X ‚ü∂ S} (hf : IsEmbedding f)\n    (g : Y ‚ü∂ S) (H : Set.range g ‚äÜ Set.range f) : IsIso (pullback.snd f g) := by\n  let esto : (pullback f g : TopCat) ‚âÉ‚Çú Y :=\n    (Homeomorph.ofIsEmbedding _ (snd_isEmbedding_of_left hf g)).trans\n      { toFun := Subtype.val\n        invFun := fun x =>\n          ‚ü®x, by\n            rw [pullback_snd_range]\n            exact ‚ü®_, (H (Set.mem_range_self x)).choose_spec‚ü©‚ü©\n        left_inv := fun ‚ü®_, _‚ü© => rfl\n        right_inv := fun x => rfl }\n  convert (isoOfHomeo esto).isIso_hom\n\n"}
{"name":"TopCat.pullback_snd_image_fst_preimage","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nU : Set ‚ÜëX\n‚ä¢ Eq (Set.image (‚áë(CategoryTheory.Limits.pullback.snd f g)) (Set.preimage (‚áë(CategoryTheory.Limits.pullback.fst f g)) U)) (Set.preimage (‚áëg) (Set.image (‚áëf) U))","decl":"theorem pullback_snd_image_fst_preimage (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (U : Set X) :\n    (pullback.snd f g) '' ((pullback.fst f g) ‚Åª¬π' U) =\n      g ‚Åª¬π' (f '' U) := by\n  ext x\n  constructor\n  ¬∑ rintro ‚ü®(y : (forget TopCat).obj _), hy, rfl‚ü©\n    exact\n      ‚ü®(pullback.fst f g) y, hy, ConcreteCategory.congr_hom pullback.condition y‚ü©\n  ¬∑ rintro ‚ü®y, hy, eq‚ü©\n  -- next 5 lines were\n  -- `exact ‚ü®(TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®_, _‚ü©, eq‚ü©, by simpa, by simp‚ü©` before https://github.com/leanprover-community/mathlib4/pull/13170\n    refine ‚ü®(TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®_, _‚ü©, eq‚ü©, ?_, ?_‚ü©\n    ¬∑ simp only [coe_of, Set.mem_preimage]\n      convert hy\n      erw [pullbackIsoProdSubtype_inv_fst_apply]\n    ¬∑ rw [pullbackIsoProdSubtype_inv_snd_apply]\n\n"}
{"name":"TopCat.pullback_fst_image_snd_preimage","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nU : Set ‚ÜëY\n‚ä¢ Eq (Set.image (‚áë(CategoryTheory.Limits.pullback.fst f g)) (Set.preimage (‚áë(CategoryTheory.Limits.pullback.snd f g)) U)) (Set.preimage (‚áëf) (Set.image (‚áëg) U))","decl":"theorem pullback_fst_image_snd_preimage (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (U : Set Y) :\n    (pullback.fst f g) '' ((pullback.snd f g) ‚Åª¬π' U) =\n      f ‚Åª¬π' (g '' U) := by\n  ext x\n  constructor\n  ¬∑ rintro ‚ü®(y : (forget TopCat).obj _), hy, rfl‚ü©\n    exact\n      ‚ü®(pullback.snd f g) y, hy,\n        (ConcreteCategory.congr_hom pullback.condition y).symm‚ü©\n  ¬∑ rintro ‚ü®y, hy, eq‚ü©\n    -- next 5 lines were\n    -- `exact ‚ü®(TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®_, _‚ü©, eq.symm‚ü©, by simpa, by simp‚ü©`\n    -- before https://github.com/leanprover-community/mathlib4/pull/13170\n    refine ‚ü®(TopCat.pullbackIsoProdSubtype f g).inv ‚ü®‚ü®_, _‚ü©, eq.symm‚ü©, ?_, ?_‚ü©\n    ¬∑ simp only [coe_of, Set.mem_preimage]\n      convert hy\n      erw [pullbackIsoProdSubtype_inv_snd_apply]\n    ¬∑ rw [pullbackIsoProdSubtype_inv_fst_apply]\n\n"}
{"name":"TopCat.coinduced_of_isColimit","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"J : Type v\ninst‚úù : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J TopCat\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq c.pt.str (iSup fun j => TopologicalSpace.coinduced (‚áë(c.Œπ.app j)) (F.obj j).str)","decl":"theorem coinduced_of_isColimit {F : J ‚•§ TopCat.{max v u}} (c : Cocone F) (hc : IsColimit c) :\n    c.pt.str = ‚®Ü j, (F.obj j).str.coinduced (c.Œπ.app j) := by\n  let homeo := homeoOfIso (hc.coconePointUniqueUpToIso (colimitCoconeIsColimit F))\n  ext\n  refine homeo.symm.isOpen_preimage.symm.trans (Iff.trans ?_ isOpen_iSup_iff.symm)\n  exact isOpen_iSup_iff\n\n"}
{"name":"TopCat.colimit_topology","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"J : Type v\ninst‚úù : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J TopCat\n‚ä¢ Eq (CategoryTheory.Limits.colimit F).str (iSup fun j => TopologicalSpace.coinduced (‚áë(CategoryTheory.Limits.colimit.Œπ F j)) (F.obj j).str)","decl":"theorem colimit_topology (F : J ‚•§ TopCat.{max v u}) :\n    (colimit F).str = ‚®Ü j, (F.obj j).str.coinduced (colimit.Œπ F j) :=\n  coinduced_of_isColimit _ (colimit.isColimit F)\n\n"}
{"name":"TopCat.colimit_isOpen_iff","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"J : Type v\ninst‚úù : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J TopCat\nU : Set ‚Üë(CategoryTheory.Limits.colimit F)\n‚ä¢ Iff (IsOpen U) (‚àÄ (j : J), IsOpen (Set.preimage (‚áë(CategoryTheory.Limits.colimit.Œπ F j)) U))","decl":"theorem colimit_isOpen_iff (F : J ‚•§ TopCat.{max v u}) (U : Set ((colimit F :) : Type max v u)) :\n    IsOpen U ‚Üî ‚àÄ j, IsOpen (colimit.Œπ F j ‚Åª¬π' U) := by\n  dsimp [topologicalSpace_coe]\n  conv_lhs => rw [colimit_topology F]\n  exact isOpen_iSup_iff\n\n"}
{"name":"TopCat.coequalizer_isOpen_iff","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair TopCat\nU : Set ‚Üë(CategoryTheory.Limits.colimit F)\n‚ä¢ Iff (IsOpen U) (IsOpen (Set.preimage (‚áë(CategoryTheory.Limits.colimit.Œπ F CategoryTheory.Limits.WalkingParallelPair.one)) U))","decl":"theorem coequalizer_isOpen_iff (F : WalkingParallelPair ‚•§ TopCat.{u})\n    (U : Set ((colimit F :) : Type u)) :\n    IsOpen U ‚Üî IsOpen (colimit.Œπ F WalkingParallelPair.one ‚Åª¬π' U) := by\n  rw [colimit_isOpen_iff]\n  constructor\n  ¬∑ intro H\n    exact H _\n  ¬∑ intro H j\n    cases j\n    ¬∑ rw [‚Üê colimit.w F WalkingParallelPairHom.left]\n      exact (F.map WalkingParallelPairHom.left).continuous_toFun.isOpen_preimage _ H\n    ¬∑ exact H\n\n"}
