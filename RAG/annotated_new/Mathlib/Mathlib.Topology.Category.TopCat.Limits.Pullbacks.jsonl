{"name":"TopCat.pullbackFst_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : ↑(TopCat.of (Subtype fun p => Eq (f p.1) (g p.2)))\n⊢ Eq ((TopCat.pullbackFst f g) x) (↑x).1","decl":"lemma pullbackFst_apply (f : X ⟶ Z) (g : Y ⟶ Z) (x) : pullbackFst f g x = x.1.1 := rfl\n\n"}
{"name":"TopCat.pullbackSnd_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : ↑(TopCat.of (Subtype fun p => Eq (f p.1) (g p.2)))\n⊢ Eq ((TopCat.pullbackSnd f g) x) (↑x).2","decl":"lemma pullbackSnd_apply (f : X ⟶ Z) (g : Y ⟶ Z) (x) : pullbackSnd f g x = x.1.2 := rfl\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_inv_fst_assoc","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z✝ : TopCat\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nZ : TopCat\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.pullbackIsoProdSubtype f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h)) (CategoryTheory.CategoryStruct.comp (TopCat.pullbackFst f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoProdSubtype_inv_fst (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (pullbackIsoProdSubtype f g).inv ≫ pullback.fst _ _ = pullbackFst f g := by\n  simp [pullbackCone, pullbackIsoProdSubtype]\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_inv_fst","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.pullbackIsoProdSubtype f g).inv (CategoryTheory.Limits.pullback.fst f g)) (TopCat.pullbackFst f g)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoProdSubtype_inv_fst (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (pullbackIsoProdSubtype f g).inv ≫ pullback.fst _ _ = pullbackFst f g := by\n  simp [pullbackCone, pullbackIsoProdSubtype]\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_inv_fst_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : Subtype fun p => Eq (f p.1) (g p.2)\n⊢ Eq ((CategoryTheory.Limits.pullback.fst f g) ((TopCat.pullbackIsoProdSubtype f g).inv x)) (↑x).1","decl":"theorem pullbackIsoProdSubtype_inv_fst_apply (f : X ⟶ Z) (g : Y ⟶ Z)\n    (x : { p : X × Y // f p.1 = g p.2 }) :\n    pullback.fst f g ((pullbackIsoProdSubtype f g).inv x) = (x : X × Y).fst :=\n  ConcreteCategory.congr_hom (pullbackIsoProdSubtype_inv_fst f g) x\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_inv_snd_assoc","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z✝ : TopCat\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nZ : TopCat\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.pullbackIsoProdSubtype f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h)) (CategoryTheory.CategoryStruct.comp (TopCat.pullbackSnd f g) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoProdSubtype_inv_snd (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (pullbackIsoProdSubtype f g).inv ≫ pullback.snd _ _ = pullbackSnd f g := by\n  simp [pullbackCone, pullbackIsoProdSubtype]\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_inv_snd","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.pullbackIsoProdSubtype f g).inv (CategoryTheory.Limits.pullback.snd f g)) (TopCat.pullbackSnd f g)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackIsoProdSubtype_inv_snd (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (pullbackIsoProdSubtype f g).inv ≫ pullback.snd _ _ = pullbackSnd f g := by\n  simp [pullbackCone, pullbackIsoProdSubtype]\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_inv_snd_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : Subtype fun p => Eq (f p.1) (g p.2)\n⊢ Eq ((CategoryTheory.Limits.pullback.snd f g) ((TopCat.pullbackIsoProdSubtype f g).inv x)) (↑x).2","decl":"theorem pullbackIsoProdSubtype_inv_snd_apply (f : X ⟶ Z) (g : Y ⟶ Z)\n    (x : { p : X × Y // f p.1 = g p.2 }) :\n    pullback.snd f g ((pullbackIsoProdSubtype f g).inv x) = (x : X × Y).snd :=\n  ConcreteCategory.congr_hom (pullbackIsoProdSubtype_inv_snd f g) x\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_hom_fst","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.pullbackIsoProdSubtype f g).hom (TopCat.pullbackFst f g)) (CategoryTheory.Limits.pullback.fst f g)","decl":"theorem pullbackIsoProdSubtype_hom_fst (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (pullbackIsoProdSubtype f g).hom ≫ pullbackFst f g = pullback.fst _ _ := by\n  rw [← Iso.eq_inv_comp, pullbackIsoProdSubtype_inv_fst]\n\n"}
{"name":"TopCat.pullbackIsoProdSubtype_hom_snd","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.pullbackIsoProdSubtype f g).hom (TopCat.pullbackSnd f g)) (CategoryTheory.Limits.pullback.snd f g)","decl":"theorem pullbackIsoProdSubtype_hom_snd (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (pullbackIsoProdSubtype f g).hom ≫ pullbackSnd f g = pullback.snd _ _ := by\n  rw [← Iso.eq_inv_comp, pullbackIsoProdSubtype_inv_snd]\n\n-- Porting note: why do I need to tell Lean to coerce pullback to a type\n"}
{"name":"TopCat.pullbackIsoProdSubtype_hom_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nx : CategoryTheory.HasForget.forget.obj (CategoryTheory.Limits.pullback f g)\n⊢ Eq ((TopCat.pullbackIsoProdSubtype f g).hom x) ⟨{ fst := (CategoryTheory.Limits.pullback.fst f g) x, snd := (CategoryTheory.Limits.pullback.snd f g) x }, ⋯⟩","decl":"theorem pullbackIsoProdSubtype_hom_apply {f : X ⟶ Z} {g : Y ⟶ Z}\n    (x : HasForget.forget.obj (pullback f g)) :\n    (pullbackIsoProdSubtype f g).hom x =\n      ⟨⟨pullback.fst f g x, pullback.snd f g x⟩, by\n        simpa using ConcreteCategory.congr_hom pullback.condition x⟩ := by\n  apply Subtype.ext; apply Prod.ext\n  exacts [ConcreteCategory.congr_hom (pullbackIsoProdSubtype_hom_fst f g) x,\n    ConcreteCategory.congr_hom (pullbackIsoProdSubtype_hom_snd f g) x]\n\n"}
{"name":"TopCat.pullback_topology","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.Limits.pullback f g).str (Min.min (TopologicalSpace.induced (⇑(CategoryTheory.Limits.pullback.fst f g)) X.str) (TopologicalSpace.induced (⇑(CategoryTheory.Limits.pullback.snd f g)) Y.str))","decl":"theorem pullback_topology {X Y Z : TopCat.{u}} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    (pullback f g).str =\n      induced (pullback.fst f g) X.str ⊓\n        induced (pullback.snd f g) Y.str := by\n  let homeo := homeoOfIso (pullbackIsoProdSubtype f g)\n  refine homeo.isInducing.eq_induced.trans ?_\n  change induced homeo (induced _ ( (induced Prod.fst X.str) ⊓ (induced Prod.snd Y.str))) = _\n  simp only [induced_compose, induced_inf]\n  congr\n\n"}
{"name":"TopCat.range_pullback_to_prod","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Eq (Set.range ⇑(CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.snd f g))) (setOf fun x => Eq ((CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst f) x) ((CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd g) x))","decl":"theorem range_pullback_to_prod {X Y Z : TopCat} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    Set.range (prod.lift (pullback.fst f g) (pullback.snd f g)) =\n      { x | (Limits.prod.fst ≫ f) x = (Limits.prod.snd ≫ g) x } := by\n  ext x\n  constructor\n  · rintro ⟨y, rfl⟩\n    change (_ ≫ _ ≫ f) _ = (_ ≫ _ ≫ g) _ -- new `change` after https://github.com/leanprover-community/mathlib4/pull/13170\n    simp [pullback.condition]\n  · rintro (h : f (_, _).1 = g (_, _).2)\n    use (pullbackIsoProdSubtype f g).inv ⟨⟨_, _⟩, h⟩\n    change (forget TopCat).map _ _ = _ -- new `change` after https://github.com/leanprover-community/mathlib4/pull/13170\n    apply Concrete.limit_ext\n    rintro ⟨⟨⟩⟩ <;>\n    erw [← CategoryTheory.comp_apply, ← CategoryTheory.comp_apply, limit.lift_π] <;> -- now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n    -- This used to be `simp` before https://github.com/leanprover/lean4/pull/2644\n    aesop_cat\n\n"}
{"name":"TopCat.isInducing_pullback_to_prod","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Topology.IsInducing ⇑(CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.snd f g))","decl":"theorem isInducing_pullback_to_prod {X Y Z : TopCat.{u}} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    IsInducing <| ⇑(prod.lift (pullback.fst f g) (pullback.snd f g)) :=\n  ⟨by simp [topologicalSpace_coe, prod_topology, pullback_topology, induced_compose, ← coe_comp]⟩\n\n"}
{"name":"TopCat.inducing_pullback_to_prod","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Topology.IsInducing ⇑(CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.snd f g))","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_pullback_to_prod := isInducing_pullback_to_prod\n\n"}
{"name":"TopCat.isEmbedding_pullback_to_prod","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Topology.IsEmbedding ⇑(CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.snd f g))","decl":"theorem isEmbedding_pullback_to_prod {X Y Z : TopCat.{u}} (f : X ⟶ Z) (g : Y ⟶ Z) :\n    IsEmbedding <| ⇑(prod.lift (pullback.fst f g) (pullback.snd f g)) :=\n  ⟨isInducing_pullback_to_prod f g, (TopCat.mono_iff_injective _).mp inferInstance⟩\n\n"}
{"name":"TopCat.embedding_pullback_to_prod","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ Topology.IsEmbedding ⇑(CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.snd f g))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_pullback_to_prod := isEmbedding_pullback_to_prod\n\n"}
{"name":"TopCat.range_pullback_map","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"W X Y Z S T : TopCat\nf₁ : Quiver.Hom W S\nf₂ : Quiver.Hom X S\ng₁ : Quiver.Hom Y T\ng₂ : Quiver.Hom Z T\ni₁ : Quiver.Hom W Y\ni₂ : Quiver.Hom X Z\ni₃ : Quiver.Hom S T\nH₃ : CategoryTheory.Mono i₃\neq₁ : Eq (CategoryTheory.CategoryStruct.comp f₁ i₃) (CategoryTheory.CategoryStruct.comp i₁ g₁)\neq₂ : Eq (CategoryTheory.CategoryStruct.comp f₂ i₃) (CategoryTheory.CategoryStruct.comp i₂ g₂)\n⊢ Eq (Set.range ⇑(CategoryTheory.Limits.pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂)) (Inter.inter (Set.preimage (⇑(CategoryTheory.Limits.pullback.fst g₁ g₂)) (Set.range ⇑i₁)) (Set.preimage (⇑(CategoryTheory.Limits.pullback.snd g₁ g₂)) (Set.range ⇑i₂)))","decl":"/-- If the map `S ⟶ T` is mono, then there is a description of the image of `W ×ₛ X ⟶ Y ×ₜ Z`. -/\ntheorem range_pullback_map {W X Y Z S T : TopCat} (f₁ : W ⟶ S) (f₂ : X ⟶ S) (g₁ : Y ⟶ T)\n    (g₂ : Z ⟶ T) (i₁ : W ⟶ Y) (i₂ : X ⟶ Z) (i₃ : S ⟶ T) [H₃ : Mono i₃] (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁)\n    (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) :\n    Set.range (pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) =\n      (pullback.fst g₁ g₂) ⁻¹' Set.range i₁ ∩ (pullback.snd g₁ g₂) ⁻¹' Set.range i₂ := by\n  ext\n  constructor\n  · rintro ⟨y, rfl⟩\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range]\n    rw [← CategoryTheory.comp_apply, ← CategoryTheory.comp_apply]\n    simp only [limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app, CategoryTheory.comp_apply]\n    exact ⟨exists_apply_eq_apply _ _, exists_apply_eq_apply _ _⟩\n  rintro ⟨⟨x₁, hx₁⟩, ⟨x₂, hx₂⟩⟩\n  have : f₁ x₁ = f₂ x₂ := by\n    apply (TopCat.mono_iff_injective _).mp H₃\n    rw [← CategoryTheory.comp_apply, eq₁, ← CategoryTheory.comp_apply, eq₂,\n      CategoryTheory.comp_apply, CategoryTheory.comp_apply, hx₁, hx₂, ← CategoryTheory.comp_apply,\n      pullback.condition]\n    rfl -- `rfl` was not needed before https://github.com/leanprover-community/mathlib4/pull/13170\n  use (pullbackIsoProdSubtype f₁ f₂).inv ⟨⟨x₁, x₂⟩, this⟩\n  change (forget TopCat).map _ _ = _\n  apply Concrete.limit_ext\n  rintro (_ | _ | _) <;>\n  erw [← CategoryTheory.comp_apply, ← CategoryTheory.comp_apply] -- now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n  · simp only [Category.assoc, limit.lift_π, PullbackCone.mk_π_app_one]\n    simp only [cospan_one, pullbackIsoProdSubtype_inv_fst_assoc, CategoryTheory.comp_apply]\n    rw [pullbackFst_apply, hx₁, ← limit.w _ WalkingCospan.Hom.inl, cospan_map_inl,\n        CategoryTheory.comp_apply (g := g₁)]\n  · simp only [cospan_left, limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app,\n      pullbackIsoProdSubtype_inv_fst_assoc, CategoryTheory.comp_apply]\n    erw [hx₁] -- now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n  · simp only [cospan_right, limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app,\n      pullbackIsoProdSubtype_inv_snd_assoc, CategoryTheory.comp_apply]\n    erw [hx₂] -- now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n\n"}
{"name":"TopCat.pullback_fst_range","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\n⊢ Eq (Set.range ⇑(CategoryTheory.Limits.pullback.fst f g)) (setOf fun x => Exists fun y => Eq (f x) (g y))","decl":"theorem pullback_fst_range {X Y S : TopCat} (f : X ⟶ S) (g : Y ⟶ S) :\n    Set.range (pullback.fst f g) = { x : X | ∃ y : Y, f x = g y } := by\n  ext x\n  constructor\n  · rintro ⟨(y : (forget TopCat).obj _), rfl⟩\n    use (pullback.snd f g) y\n    exact ConcreteCategory.congr_hom pullback.condition y\n  · rintro ⟨y, eq⟩\n    use (TopCat.pullbackIsoProdSubtype f g).inv ⟨⟨x, y⟩, eq⟩\n    rw [pullbackIsoProdSubtype_inv_fst_apply]\n\n"}
{"name":"TopCat.pullback_snd_range","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\n⊢ Eq (Set.range ⇑(CategoryTheory.Limits.pullback.snd f g)) (setOf fun y => Exists fun x => Eq (f x) (g y))","decl":"theorem pullback_snd_range {X Y S : TopCat} (f : X ⟶ S) (g : Y ⟶ S) :\n    Set.range (pullback.snd f g) = { y : Y | ∃ x : X, f x = g y } := by\n  ext y\n  constructor\n  · rintro ⟨(x : (forget TopCat).obj _), rfl⟩\n    use (pullback.fst f g) x\n    exact ConcreteCategory.congr_hom pullback.condition x\n  · rintro ⟨x, eq⟩\n    use (TopCat.pullbackIsoProdSubtype f g).inv ⟨⟨x, y⟩, eq⟩\n    rw [pullbackIsoProdSubtype_inv_snd_apply]\n\n"}
{"name":"TopCat.pullback_map_isEmbedding","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"W X Y Z S T : TopCat\nf₁ : Quiver.Hom W S\nf₂ : Quiver.Hom X S\ng₁ : Quiver.Hom Y T\ng₂ : Quiver.Hom Z T\ni₁ : Quiver.Hom W Y\ni₂ : Quiver.Hom X Z\nH₁ : Topology.IsEmbedding ⇑i₁\nH₂ : Topology.IsEmbedding ⇑i₂\ni₃ : Quiver.Hom S T\neq₁ : Eq (CategoryTheory.CategoryStruct.comp f₁ i₃) (CategoryTheory.CategoryStruct.comp i₁ g₁)\neq₂ : Eq (CategoryTheory.CategoryStruct.comp f₂ i₃) (CategoryTheory.CategoryStruct.comp i₂ g₂)\n⊢ Topology.IsEmbedding ⇑(CategoryTheory.Limits.pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂)","decl":"/-- If there is a diagram where the morphisms `W ⟶ Y` and `X ⟶ Z` are embeddings,\nthen the induced morphism `W ×ₛ X ⟶ Y ×ₜ Z` is also an embedding.\n\n```\nW ⟶ Y\n ↘   ↘\n  S ⟶ T\n ↗   ↗\nX ⟶ Z\n```\n-/\ntheorem pullback_map_isEmbedding {W X Y Z S T : TopCat.{u}} (f₁ : W ⟶ S) (f₂ : X ⟶ S)\n    (g₁ : Y ⟶ T) (g₂ : Z ⟶ T) {i₁ : W ⟶ Y} {i₂ : X ⟶ Z} (H₁ : IsEmbedding i₁)\n    (H₂ : IsEmbedding i₂) (i₃ : S ⟶ T) (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁) (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) :\n    IsEmbedding (pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) := by\n  refine .of_comp (ContinuousMap.continuous_toFun _)\n    (show Continuous (prod.lift (pullback.fst g₁ g₂) (pullback.snd g₁ g₂)) from\n        ContinuousMap.continuous_toFun _)\n      ?_\n  suffices\n    IsEmbedding (prod.lift (pullback.fst f₁ f₂) (pullback.snd f₁ f₂) ≫ Limits.prod.map i₁ i₂) by\n    simpa [← coe_comp] using this\n  rw [coe_comp]\n  exact (isEmbedding_prodMap H₁ H₂).comp (isEmbedding_pullback_to_prod _ _)\n\n"}
{"name":"TopCat.pullback_map_embedding_of_embeddings","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"W X Y Z S T : TopCat\nf₁ : Quiver.Hom W S\nf₂ : Quiver.Hom X S\ng₁ : Quiver.Hom Y T\ng₂ : Quiver.Hom Z T\ni₁ : Quiver.Hom W Y\ni₂ : Quiver.Hom X Z\nH₁ : Topology.IsEmbedding ⇑i₁\nH₂ : Topology.IsEmbedding ⇑i₂\ni₃ : Quiver.Hom S T\neq₁ : Eq (CategoryTheory.CategoryStruct.comp f₁ i₃) (CategoryTheory.CategoryStruct.comp i₁ g₁)\neq₂ : Eq (CategoryTheory.CategoryStruct.comp f₂ i₃) (CategoryTheory.CategoryStruct.comp i₂ g₂)\n⊢ Topology.IsEmbedding ⇑(CategoryTheory.Limits.pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias pullback_map_embedding_of_embeddings := pullback_map_isEmbedding\n\n"}
{"name":"TopCat.pullback_map_isOpenEmbedding","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"W X Y Z S T : TopCat\nf₁ : Quiver.Hom W S\nf₂ : Quiver.Hom X S\ng₁ : Quiver.Hom Y T\ng₂ : Quiver.Hom Z T\ni₁ : Quiver.Hom W Y\ni₂ : Quiver.Hom X Z\nH₁ : Topology.IsOpenEmbedding ⇑i₁\nH₂ : Topology.IsOpenEmbedding ⇑i₂\ni₃ : Quiver.Hom S T\nH₃ : CategoryTheory.Mono i₃\neq₁ : Eq (CategoryTheory.CategoryStruct.comp f₁ i₃) (CategoryTheory.CategoryStruct.comp i₁ g₁)\neq₂ : Eq (CategoryTheory.CategoryStruct.comp f₂ i₃) (CategoryTheory.CategoryStruct.comp i₂ g₂)\n⊢ Topology.IsOpenEmbedding ⇑(CategoryTheory.Limits.pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂)","decl":"/-- If there is a diagram where the morphisms `W ⟶ Y` and `X ⟶ Z` are open embeddings, and `S ⟶ T`\nis mono, then the induced morphism `W ×ₛ X ⟶ Y ×ₜ Z` is also an open embedding.\n\n```\nW ⟶ Y\n ↘   ↘\n  S ⟶ T\n ↗   ↗\nX ⟶ Z\n```\n-/\ntheorem pullback_map_isOpenEmbedding {W X Y Z S T : TopCat.{u}} (f₁ : W ⟶ S)\n    (f₂ : X ⟶ S) (g₁ : Y ⟶ T) (g₂ : Z ⟶ T) {i₁ : W ⟶ Y} {i₂ : X ⟶ Z} (H₁ : IsOpenEmbedding i₁)\n    (H₂ : IsOpenEmbedding i₂) (i₃ : S ⟶ T) [H₃ : Mono i₃] (eq₁ : f₁ ≫ i₃ = i₁ ≫ g₁)\n    (eq₂ : f₂ ≫ i₃ = i₂ ≫ g₂) : IsOpenEmbedding (pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂) := by\n  constructor\n  · apply\n      pullback_map_isEmbedding f₁ f₂ g₁ g₂ H₁.isEmbedding H₂.isEmbedding i₃ eq₁ eq₂\n  · rw [range_pullback_map]\n    apply IsOpen.inter <;> apply Continuous.isOpen_preimage\n    · apply ContinuousMap.continuous_toFun\n    · exact H₁.isOpen_range\n    · apply ContinuousMap.continuous_toFun\n    · exact H₂.isOpen_range\n\n"}
{"name":"TopCat.pullback_map_openEmbedding_of_open_embeddings","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"W X Y Z S T : TopCat\nf₁ : Quiver.Hom W S\nf₂ : Quiver.Hom X S\ng₁ : Quiver.Hom Y T\ng₂ : Quiver.Hom Z T\ni₁ : Quiver.Hom W Y\ni₂ : Quiver.Hom X Z\nH₁ : Topology.IsOpenEmbedding ⇑i₁\nH₂ : Topology.IsOpenEmbedding ⇑i₂\ni₃ : Quiver.Hom S T\nH₃ : CategoryTheory.Mono i₃\neq₁ : Eq (CategoryTheory.CategoryStruct.comp f₁ i₃) (CategoryTheory.CategoryStruct.comp i₁ g₁)\neq₂ : Eq (CategoryTheory.CategoryStruct.comp f₂ i₃) (CategoryTheory.CategoryStruct.comp i₂ g₂)\n⊢ Topology.IsOpenEmbedding ⇑(CategoryTheory.Limits.pullback.map f₁ f₂ g₁ g₂ i₁ i₂ i₃ eq₁ eq₂)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias pullback_map_openEmbedding_of_open_embeddings := pullback_map_isOpenEmbedding\n\n\n"}
{"name":"TopCat.snd_isEmbedding_of_left","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\nH : Topology.IsEmbedding ⇑f\ng : Quiver.Hom Y S\n⊢ Topology.IsEmbedding ⇑(CategoryTheory.Limits.pullback.snd f g)","decl":"lemma snd_isEmbedding_of_left {X Y S : TopCat} {f : X ⟶ S} (H : IsEmbedding f) (g : Y ⟶ S) :\n    IsEmbedding <| ⇑(pullback.snd f g) := by\n  convert (homeoOfIso (asIso (pullback.snd (𝟙 S) g))).isEmbedding.comp\n      (pullback_map_isEmbedding (i₂ := 𝟙 Y)\n        f g (𝟙 S) g H (homeoOfIso (Iso.refl _)).isEmbedding (𝟙 _) rfl (by simp))\n  erw [← coe_comp]\n  simp\n\n"}
{"name":"TopCat.snd_embedding_of_left_embedding","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\nH : Topology.IsEmbedding ⇑f\ng : Quiver.Hom Y S\n⊢ Topology.IsEmbedding ⇑(CategoryTheory.Limits.pullback.snd f g)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias snd_embedding_of_left_embedding := snd_isEmbedding_of_left\n\n"}
{"name":"TopCat.fst_isEmbedding_of_right","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH : Topology.IsEmbedding ⇑g\n⊢ Topology.IsEmbedding ⇑(CategoryTheory.Limits.pullback.fst f g)","decl":"theorem fst_isEmbedding_of_right {X Y S : TopCat} (f : X ⟶ S) {g : Y ⟶ S}\n    (H : IsEmbedding g) : IsEmbedding <| ⇑(pullback.fst f g) := by\n  convert (homeoOfIso (asIso (pullback.fst f (𝟙 S)))).isEmbedding.comp\n      (pullback_map_isEmbedding (i₁ := 𝟙 X)\n        f g f (𝟙 _) (homeoOfIso (Iso.refl _)).isEmbedding H (𝟙 _) rfl (by simp))\n  erw [← coe_comp]\n  simp\n\n"}
{"name":"TopCat.fst_embedding_of_right_embedding","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH : Topology.IsEmbedding ⇑g\n⊢ Topology.IsEmbedding ⇑(CategoryTheory.Limits.pullback.fst f g)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias fst_embedding_of_right_embedding := fst_isEmbedding_of_right\n\n"}
{"name":"TopCat.isEmbedding_of_pullback","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH₁ : Topology.IsEmbedding ⇑f\nH₂ : Topology.IsEmbedding ⇑g\n⊢ Topology.IsEmbedding ⇑(CategoryTheory.Limits.limit.π (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)","decl":"theorem isEmbedding_of_pullback {X Y S : TopCat} {f : X ⟶ S} {g : Y ⟶ S} (H₁ : IsEmbedding f)\n    (H₂ : IsEmbedding g) : IsEmbedding (limit.π (cospan f g) WalkingCospan.one) := by\n  convert H₂.comp (snd_isEmbedding_of_left H₁ g)\n  rw [← coe_comp, ← limit.w _ WalkingCospan.Hom.inr]\n  rfl\n\n"}
{"name":"TopCat.embedding_of_pullback_embeddings","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH₁ : Topology.IsEmbedding ⇑f\nH₂ : Topology.IsEmbedding ⇑g\n⊢ Topology.IsEmbedding ⇑(CategoryTheory.Limits.limit.π (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_of_pullback_embeddings := isEmbedding_of_pullback\n\n"}
{"name":"TopCat.snd_isOpenEmbedding_of_left","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\nH : Topology.IsOpenEmbedding ⇑f\ng : Quiver.Hom Y S\n⊢ Topology.IsOpenEmbedding ⇑(CategoryTheory.Limits.pullback.snd f g)","decl":"theorem snd_isOpenEmbedding_of_left {X Y S : TopCat} {f : X ⟶ S} (H : IsOpenEmbedding f)\n    (g : Y ⟶ S) : IsOpenEmbedding <| ⇑(pullback.snd f g) := by\n  convert (homeoOfIso (asIso (pullback.snd (𝟙 S) g))).isOpenEmbedding.comp\n      (pullback_map_isOpenEmbedding (i₂ := 𝟙 Y) f g (𝟙 _) g H\n        (homeoOfIso (Iso.refl _)).isOpenEmbedding (𝟙 _) rfl (by simp))\n  erw [← coe_comp]\n  simp\n\n"}
{"name":"TopCat.snd_openEmbedding_of_left_openEmbedding","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\nH : Topology.IsOpenEmbedding ⇑f\ng : Quiver.Hom Y S\n⊢ Topology.IsOpenEmbedding ⇑(CategoryTheory.Limits.pullback.snd f g)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias snd_openEmbedding_of_left_openEmbedding := snd_isOpenEmbedding_of_left\n\n"}
{"name":"TopCat.fst_isOpenEmbedding_of_right","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH : Topology.IsOpenEmbedding ⇑g\n⊢ Topology.IsOpenEmbedding ⇑(CategoryTheory.Limits.pullback.fst f g)","decl":"theorem fst_isOpenEmbedding_of_right {X Y S : TopCat} (f : X ⟶ S) {g : Y ⟶ S}\n    (H : IsOpenEmbedding g) : IsOpenEmbedding <| ⇑(pullback.fst f g) := by\n  convert (homeoOfIso (asIso (pullback.fst f (𝟙 S)))).isOpenEmbedding.comp\n      (pullback_map_isOpenEmbedding (i₁ := 𝟙 X) f g f (𝟙 _)\n        (homeoOfIso (Iso.refl _)).isOpenEmbedding H (𝟙 _) rfl (by simp))\n  erw [← coe_comp]\n  simp\n\n"}
{"name":"TopCat.fst_openEmbedding_of_right_openEmbedding","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH : Topology.IsOpenEmbedding ⇑g\n⊢ Topology.IsOpenEmbedding ⇑(CategoryTheory.Limits.pullback.fst f g)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias fst_openEmbedding_of_right_openEmbedding := fst_isOpenEmbedding_of_right\n\n"}
{"name":"TopCat.isOpenEmbedding_of_pullback","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH₁ : Topology.IsOpenEmbedding ⇑f\nH₂ : Topology.IsOpenEmbedding ⇑g\n⊢ Topology.IsOpenEmbedding ⇑(CategoryTheory.Limits.limit.π (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)","decl":"/-- If `X ⟶ S`, `Y ⟶ S` are open embeddings, then so is `X ×ₛ Y ⟶ S`. -/\ntheorem isOpenEmbedding_of_pullback {X Y S : TopCat} {f : X ⟶ S} {g : Y ⟶ S}\n    (H₁ : IsOpenEmbedding f) (H₂ : IsOpenEmbedding g) :\n    IsOpenEmbedding (limit.π (cospan f g) WalkingCospan.one) := by\n  convert H₂.comp (snd_isOpenEmbedding_of_left H₁ g)\n  rw [← coe_comp, ← limit.w _ WalkingCospan.Hom.inr]\n  rfl\n\n"}
{"name":"TopCat.isOpenEmbedding_of_pullback_open_embeddings","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH₁ : Topology.IsOpenEmbedding ⇑f\nH₂ : Topology.IsOpenEmbedding ⇑g\n⊢ Topology.IsOpenEmbedding ⇑(CategoryTheory.Limits.limit.π (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)","decl":"@[deprecated (since := \"2024-10-30\")]\nalias isOpenEmbedding_of_pullback_open_embeddings := isOpenEmbedding_of_pullback\n\n"}
{"name":"TopCat.openEmbedding_of_pullback_open_embeddings","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH₁ : Topology.IsOpenEmbedding ⇑f\nH₂ : Topology.IsOpenEmbedding ⇑g\n⊢ Topology.IsOpenEmbedding ⇑(CategoryTheory.Limits.limit.π (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_of_pullback_open_embeddings := isOpenEmbedding_of_pullback\n\n"}
{"name":"TopCat.fst_iso_of_right_embedding_range_subset","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nhg : Topology.IsEmbedding ⇑g\nH : HasSubset.Subset (Set.range ⇑f) (Set.range ⇑g)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.fst f g)","decl":"theorem fst_iso_of_right_embedding_range_subset {X Y S : TopCat} (f : X ⟶ S) {g : Y ⟶ S}\n    (hg : IsEmbedding g) (H : Set.range f ⊆ Set.range g) :\n    IsIso (pullback.fst f g) := by\n  let esto : (pullback f g : TopCat) ≃ₜ X :=\n    (Homeomorph.ofIsEmbedding _ (fst_isEmbedding_of_right f hg)).trans\n      { toFun := Subtype.val\n        invFun := fun x =>\n          ⟨x, by\n            rw [pullback_fst_range]\n            exact ⟨_, (H (Set.mem_range_self x)).choose_spec.symm⟩⟩\n        left_inv := fun ⟨_, _⟩ => rfl\n        right_inv := fun x => rfl }\n  convert (isoOfHomeo esto).isIso_hom\n\n"}
{"name":"TopCat.snd_iso_of_left_embedding_range_subset","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y S : TopCat\nf : Quiver.Hom X S\nhf : Topology.IsEmbedding ⇑f\ng : Quiver.Hom Y S\nH : HasSubset.Subset (Set.range ⇑g) (Set.range ⇑f)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.snd f g)","decl":"theorem snd_iso_of_left_embedding_range_subset {X Y S : TopCat} {f : X ⟶ S} (hf : IsEmbedding f)\n    (g : Y ⟶ S) (H : Set.range g ⊆ Set.range f) : IsIso (pullback.snd f g) := by\n  let esto : (pullback f g : TopCat) ≃ₜ Y :=\n    (Homeomorph.ofIsEmbedding _ (snd_isEmbedding_of_left hf g)).trans\n      { toFun := Subtype.val\n        invFun := fun x =>\n          ⟨x, by\n            rw [pullback_snd_range]\n            exact ⟨_, (H (Set.mem_range_self x)).choose_spec⟩⟩\n        left_inv := fun ⟨_, _⟩ => rfl\n        right_inv := fun x => rfl }\n  convert (isoOfHomeo esto).isIso_hom\n\n"}
{"name":"TopCat.pullback_snd_image_fst_preimage","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nU : Set ↑X\n⊢ Eq (Set.image (⇑(CategoryTheory.Limits.pullback.snd f g)) (Set.preimage (⇑(CategoryTheory.Limits.pullback.fst f g)) U)) (Set.preimage (⇑g) (Set.image (⇑f) U))","decl":"theorem pullback_snd_image_fst_preimage (f : X ⟶ Z) (g : Y ⟶ Z) (U : Set X) :\n    (pullback.snd f g) '' ((pullback.fst f g) ⁻¹' U) =\n      g ⁻¹' (f '' U) := by\n  ext x\n  constructor\n  · rintro ⟨(y : (forget TopCat).obj _), hy, rfl⟩\n    exact\n      ⟨(pullback.fst f g) y, hy, ConcreteCategory.congr_hom pullback.condition y⟩\n  · rintro ⟨y, hy, eq⟩\n  -- next 5 lines were\n  -- `exact ⟨(TopCat.pullbackIsoProdSubtype f g).inv ⟨⟨_, _⟩, eq⟩, by simpa, by simp⟩` before https://github.com/leanprover-community/mathlib4/pull/13170\n    refine ⟨(TopCat.pullbackIsoProdSubtype f g).inv ⟨⟨_, _⟩, eq⟩, ?_, ?_⟩\n    · simp only [coe_of, Set.mem_preimage]\n      convert hy\n      erw [pullbackIsoProdSubtype_inv_fst_apply]\n    · rw [pullbackIsoProdSubtype_inv_snd_apply]\n\n"}
{"name":"TopCat.pullback_fst_image_snd_preimage","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nU : Set ↑Y\n⊢ Eq (Set.image (⇑(CategoryTheory.Limits.pullback.fst f g)) (Set.preimage (⇑(CategoryTheory.Limits.pullback.snd f g)) U)) (Set.preimage (⇑f) (Set.image (⇑g) U))","decl":"theorem pullback_fst_image_snd_preimage (f : X ⟶ Z) (g : Y ⟶ Z) (U : Set Y) :\n    (pullback.fst f g) '' ((pullback.snd f g) ⁻¹' U) =\n      f ⁻¹' (g '' U) := by\n  ext x\n  constructor\n  · rintro ⟨(y : (forget TopCat).obj _), hy, rfl⟩\n    exact\n      ⟨(pullback.snd f g) y, hy,\n        (ConcreteCategory.congr_hom pullback.condition y).symm⟩\n  · rintro ⟨y, hy, eq⟩\n    -- next 5 lines were\n    -- `exact ⟨(TopCat.pullbackIsoProdSubtype f g).inv ⟨⟨_, _⟩, eq.symm⟩, by simpa, by simp⟩`\n    -- before https://github.com/leanprover-community/mathlib4/pull/13170\n    refine ⟨(TopCat.pullbackIsoProdSubtype f g).inv ⟨⟨_, _⟩, eq.symm⟩, ?_, ?_⟩\n    · simp only [coe_of, Set.mem_preimage]\n      convert hy\n      erw [pullbackIsoProdSubtype_inv_snd_apply]\n    · rw [pullbackIsoProdSubtype_inv_fst_apply]\n\n"}
{"name":"TopCat.coinduced_of_isColimit","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J TopCat\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq c.pt.str (iSup fun j => TopologicalSpace.coinduced (⇑(c.ι.app j)) (F.obj j).str)","decl":"theorem coinduced_of_isColimit {F : J ⥤ TopCat.{max v u}} (c : Cocone F) (hc : IsColimit c) :\n    c.pt.str = ⨆ j, (F.obj j).str.coinduced (c.ι.app j) := by\n  let homeo := homeoOfIso (hc.coconePointUniqueUpToIso (colimitCoconeIsColimit F))\n  ext\n  refine homeo.symm.isOpen_preimage.symm.trans (Iff.trans ?_ isOpen_iSup_iff.symm)\n  exact isOpen_iSup_iff\n\n"}
{"name":"TopCat.colimit_topology","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J TopCat\n⊢ Eq (CategoryTheory.Limits.colimit F).str (iSup fun j => TopologicalSpace.coinduced (⇑(CategoryTheory.Limits.colimit.ι F j)) (F.obj j).str)","decl":"theorem colimit_topology (F : J ⥤ TopCat.{max v u}) :\n    (colimit F).str = ⨆ j, (F.obj j).str.coinduced (colimit.ι F j) :=\n  coinduced_of_isColimit _ (colimit.isColimit F)\n\n"}
{"name":"TopCat.colimit_isOpen_iff","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J TopCat\nU : Set ↑(CategoryTheory.Limits.colimit F)\n⊢ Iff (IsOpen U) (∀ (j : J), IsOpen (Set.preimage (⇑(CategoryTheory.Limits.colimit.ι F j)) U))","decl":"theorem colimit_isOpen_iff (F : J ⥤ TopCat.{max v u}) (U : Set ((colimit F :) : Type max v u)) :\n    IsOpen U ↔ ∀ j, IsOpen (colimit.ι F j ⁻¹' U) := by\n  dsimp [topologicalSpace_coe]\n  conv_lhs => rw [colimit_topology F]\n  exact isOpen_iSup_iff\n\n"}
{"name":"TopCat.coequalizer_isOpen_iff","module":"Mathlib.Topology.Category.TopCat.Limits.Pullbacks","initialProofState":"F : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair TopCat\nU : Set ↑(CategoryTheory.Limits.colimit F)\n⊢ Iff (IsOpen U) (IsOpen (Set.preimage (⇑(CategoryTheory.Limits.colimit.ι F CategoryTheory.Limits.WalkingParallelPair.one)) U))","decl":"theorem coequalizer_isOpen_iff (F : WalkingParallelPair ⥤ TopCat.{u})\n    (U : Set ((colimit F :) : Type u)) :\n    IsOpen U ↔ IsOpen (colimit.ι F WalkingParallelPair.one ⁻¹' U) := by\n  rw [colimit_isOpen_iff]\n  constructor\n  · intro H\n    exact H _\n  · intro H j\n    cases j\n    · rw [← colimit.w F WalkingParallelPairHom.left]\n      exact (F.map WalkingParallelPairHom.left).continuous_toFun.isOpen_preimage _ H\n    · exact H\n\n"}
