{"name":"padicValNat.self","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : LT.lt 1 p\n⊢ Eq (padicValNat p p) 1","decl":"/-- If `p ≠ 0` and `p ≠ 1`, then `padicValNat p p` is `1`. -/\n@[simp]\ntheorem self (hp : 1 < p) : padicValNat p p = 1 := by\n  simp [padicValNat_def', zero_lt_one.trans hp, hp.ne']\n\n"}
{"name":"padicValNat.eq_zero_of_not_dvd","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\nh : Not (Dvd.dvd p n)\n⊢ Eq (padicValNat p n) 0","decl":"theorem eq_zero_of_not_dvd {n : ℕ} (h : ¬p ∣ n) : padicValNat p n = 0 :=\n  eq_zero_iff.2 <| Or.inr <| Or.inr h\n\n"}
{"name":"padicValNat.maxPowDiv_eq_emultiplicity","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\nhp : LT.lt 1 p\nhn : LT.lt 0 n\n⊢ Eq (↑(p.maxPowDiv n)) (emultiplicity p n)","decl":"theorem maxPowDiv_eq_emultiplicity {p n : ℕ} (hp : 1 < p) (hn : 0 < n) :\n    p.maxPowDiv n = emultiplicity p n := by\n  apply (emultiplicity_eq_of_dvd_of_not_dvd (pow_dvd p n) _).symm\n  intro h\n  apply Nat.not_lt.mpr <| le_of_dvd hp hn h\n  simp\n\n"}
{"name":"padicValNat.maxPowDiv_eq_multiplicity","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\nhp : LT.lt 1 p\nhn : LT.lt 0 n\nh : FiniteMultiplicity p n\n⊢ Eq (p.maxPowDiv n) (multiplicity p n)","decl":"theorem maxPowDiv_eq_multiplicity {p n : ℕ} (hp : 1 < p) (hn : 0 < n) (h : FiniteMultiplicity p n) :\n    p.maxPowDiv n = multiplicity p n := by\n  exact_mod_cast h.emultiplicity_eq_multiplicity ▸ maxPowDiv_eq_emultiplicity hp hn\n\n"}
{"name":"padicValNat.padicValNat_eq_maxPowDiv","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"⊢ Eq padicValNat Nat.maxPowDiv","decl":"/-- Allows for more efficient code for `padicValNat` -/\n@[csimp]\ntheorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv := by\n  ext p n\n  by_cases h : 1 < p ∧ 0 < n\n  · rw [padicValNat_def' h.1.ne' h.2, maxPowDiv_eq_multiplicity h.1 h.2]\n    exact Nat.finiteMultiplicity_iff.2 ⟨h.1.ne', h.2⟩\n  · simp only [not_and_or,not_gt_eq,Nat.le_zero] at h\n    apply h.elim\n    · intro h\n      interval_cases p\n      · simp [Classical.em]\n      · dsimp [padicValNat, maxPowDiv]\n        rw [go, if_neg]; simp\n    · intro h\n      simp [h]\n\n"}
{"name":"padicValInt.of_ne_one_ne_zero","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nz : Int\nhp : Ne p 1\nhz : Ne z 0\n⊢ Eq (padicValInt p z) (multiplicity (↑p) z)","decl":"theorem of_ne_one_ne_zero {z : ℤ} (hp : p ≠ 1) (hz : z ≠ 0) :\n    padicValInt p z = multiplicity (p : ℤ) z:= by\n  rw [padicValInt, padicValNat_def' hp (Int.natAbs_pos.mpr hz)]\n  apply Int.multiplicity_natAbs\n\n"}
{"name":"padicValInt.zero","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\n⊢ Eq (padicValInt p 0) 0","decl":"/-- `padicValInt p 0` is `0` for any `p`. -/\n@[simp]\nprotected theorem zero : padicValInt p 0 = 0 := by simp [padicValInt]\n\n"}
{"name":"padicValInt.one","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\n⊢ Eq (padicValInt p 1) 0","decl":"/-- `padicValInt p 1` is `0` for any `p`. -/\n@[simp]\nprotected theorem one : padicValInt p 1 = 0 := by simp [padicValInt]\n\n"}
{"name":"padicValInt.of_nat","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\n⊢ Eq (padicValInt p ↑n) (padicValNat p n)","decl":"/-- The `p`-adic value of a natural is its `p`-adic value as an integer. -/\n@[simp]\ntheorem of_nat {n : ℕ} : padicValInt p n = padicValNat p n := by simp [padicValInt]\n\n"}
{"name":"padicValInt.self","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : LT.lt 1 p\n⊢ Eq (padicValInt p ↑p) 1","decl":"/-- If `p ≠ 0` and `p ≠ 1`, then `padicValInt p p` is `1`. -/\ntheorem self (hp : 1 < p) : padicValInt p p = 1 := by simp [padicValNat.self hp]\n\n"}
{"name":"padicValInt.eq_zero_of_not_dvd","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nz : Int\nh : Not (Dvd.dvd (↑p) z)\n⊢ Eq (padicValInt p z) 0","decl":"theorem eq_zero_of_not_dvd {z : ℤ} (h : ¬(p : ℤ) ∣ z) : padicValInt p z = 0 := by\n  rw [padicValInt, padicValNat.eq_zero_iff]\n  right; right\n  rwa [← Int.ofNat_dvd_left]\n\n"}
{"name":"padicValRat_def","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nq : Rat\n⊢ Eq (padicValRat p q) (HSub.hSub ↑(padicValInt p q.num) ↑(padicValNat p q.den))","decl":"lemma padicValRat_def (p : ℕ) (q : ℚ) :\n    padicValRat p q = padicValInt p q.num - padicValNat p q.den :=\n  rfl\n\n"}
{"name":"padicValRat.neg","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nq : Rat\n⊢ Eq (padicValRat p (Neg.neg q)) (padicValRat p q)","decl":"/-- `padicValRat p q` is symmetric in `q`. -/\n@[simp]\nprotected theorem neg (q : ℚ) : padicValRat p (-q) = padicValRat p q := by\n  simp [padicValRat, padicValInt]\n\n"}
{"name":"padicValRat.zero","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\n⊢ Eq (padicValRat p 0) 0","decl":"/-- `padicValRat p 0` is `0` for any `p`. -/\n@[simp]\nprotected theorem zero : padicValRat p 0 = 0 := by simp [padicValRat]\n\n"}
{"name":"padicValRat.one","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\n⊢ Eq (padicValRat p 1) 0","decl":"/-- `padicValRat p 1` is `0` for any `p`. -/\n@[simp]\nprotected theorem one : padicValRat p 1 = 0 := by simp [padicValRat]\n\n"}
{"name":"padicValRat.of_int","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nz : Int\n⊢ Eq (padicValRat p ↑z) ↑(padicValInt p z)","decl":"/-- The `p`-adic value of an integer `z ≠ 0` is its `p`-adic_value as a rational. -/\n@[simp]\ntheorem of_int {z : ℤ} : padicValRat p z = padicValInt p z := by simp [padicValRat]\n\n"}
{"name":"padicValRat.of_int_multiplicity","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nz : Int\nhp : Ne p 1\nhz : Ne z 0\n⊢ Eq (padicValRat p ↑z) ↑(multiplicity (↑p) z)","decl":"/-- The `p`-adic value of an integer `z ≠ 0` is the multiplicity of `p` in `z`. -/\ntheorem of_int_multiplicity {z : ℤ} (hp : p ≠ 1) (hz : z ≠ 0) :\n    padicValRat p (z : ℚ) = multiplicity (p : ℤ) z := by\n  rw [of_int, padicValInt.of_ne_one_ne_zero hp hz]\n\n"}
{"name":"padicValRat.multiplicity_sub_multiplicity","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nq : Rat\nhp : Ne p 1\nhq : Ne q 0\n⊢ Eq (padicValRat p q) (HSub.hSub ↑(multiplicity (↑p) q.num) ↑(multiplicity p q.den))","decl":"theorem multiplicity_sub_multiplicity {q : ℚ} (hp : p ≠ 1) (hq : q ≠ 0) :\n    padicValRat p q = multiplicity (p : ℤ) q.num - multiplicity p q.den := by\n  rw [padicValRat, padicValInt.of_ne_one_ne_zero hp (Rat.num_ne_zero.2 hq),\n    padicValNat_def' hp q.pos]\n\n"}
{"name":"padicValRat.of_nat","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\n⊢ Eq (padicValRat p ↑n) ↑(padicValNat p n)","decl":"/-- The `p`-adic value of an integer `z ≠ 0` is its `p`-adic value as a rational. -/\n@[simp]\ntheorem of_nat {n : ℕ} : padicValRat p n = padicValNat p n := by simp [padicValRat]\n\n"}
{"name":"padicValRat.self","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : LT.lt 1 p\n⊢ Eq (padicValRat p ↑p) 1","decl":"/-- If `p ≠ 0` and `p ≠ 1`, then `padicValRat p p` is `1`. -/\ntheorem self (hp : 1 < p) : padicValRat p p = 1 := by simp [hp]\n\n"}
{"name":"zero_le_padicValRat_of_nat","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\n⊢ LE.le 0 (padicValRat p ↑n)","decl":"theorem zero_le_padicValRat_of_nat (n : ℕ) : 0 ≤ padicValRat p n := by simp\n\n"}
{"name":"padicValRat_of_nat","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\n⊢ Eq (↑(padicValNat p n)) (padicValRat p ↑n)","decl":"/-- `padicValRat` coincides with `padicValNat`. -/\n@[norm_cast]\ntheorem padicValRat_of_nat (n : ℕ) : ↑(padicValNat p n) = padicValRat p n := by simp\n\n"}
{"name":"padicValNat_self","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (padicValNat p p) 1","decl":"@[simp]\ntheorem padicValNat_self [Fact p.Prime] : padicValNat p p = 1 := by\n  rw [padicValNat_def (@Fact.out p.Prime).pos]\n  simp\n\n"}
{"name":"one_le_padicValNat_of_dvd","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\nhp : Fact (Nat.Prime p)\nhn : LT.lt 0 n\ndiv : Dvd.dvd p n\n⊢ LE.le 1 (padicValNat p n)","decl":"theorem one_le_padicValNat_of_dvd {n : ℕ} [hp : Fact p.Prime] (hn : 0 < n) (div : p ∣ n) :\n    1 ≤ padicValNat p n := by\n  rwa [← WithTop.coe_le_coe, ENat.some_eq_coe, padicValNat_eq_emultiplicity hn,\n    ← pow_dvd_iff_le_emultiplicity, pow_one]\n\n"}
{"name":"dvd_iff_padicValNat_ne_zero","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\ninst✝ : Fact (Nat.Prime p)\nhn0 : Ne n 0\n⊢ Iff (Dvd.dvd p n) (Ne (padicValNat p n) 0)","decl":"theorem dvd_iff_padicValNat_ne_zero {p n : ℕ} [Fact p.Prime] (hn0 : n ≠ 0) :\n    p ∣ n ↔ padicValNat p n ≠ 0 :=\n  ⟨fun h => one_le_iff_ne_zero.mp (one_le_padicValNat_of_dvd hn0.bot_lt h), fun h =>\n    Classical.not_not.1 (mt padicValNat.eq_zero_of_not_dvd h)⟩\n\n"}
{"name":"padicValRat.finite_int_prime_iff","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\na : Int\n⊢ Iff (FiniteMultiplicity (↑p) a) (Ne a 0)","decl":"/-- The multiplicity of `p : ℕ` in `a : ℤ` is finite exactly when `a ≠ 0`. -/\ntheorem finite_int_prime_iff {a : ℤ} : FiniteMultiplicity (p : ℤ) a ↔ a ≠ 0 := by\n  simp [Int.finiteMultiplicity_iff, hp.1.ne_one]\n\n"}
{"name":"padicValRat.defn","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Rat\nn d : Int\nhqz : Ne q 0\nqdf : Eq q (Rat.divInt n d)\n⊢ Eq (padicValRat p q) (HSub.hSub ↑(multiplicity (↑p) n) ↑(multiplicity (↑p) d))","decl":"/-- A rewrite lemma for `padicValRat p q` when `q` is expressed in terms of `Rat.mk`. -/\nprotected theorem defn (p : ℕ) [hp : Fact p.Prime] {q : ℚ} {n d : ℤ} (hqz : q ≠ 0)\n    (qdf : q = n /. d) :\n    padicValRat p q = multiplicity (p : ℤ) n - multiplicity (p : ℤ) d := by\n  have hd : d ≠ 0 := Rat.mk_denom_ne_zero_of_ne_zero hqz qdf\n  let ⟨c, hc1, hc2⟩ := Rat.num_den_mk hd qdf\n  rw [padicValRat.multiplicity_sub_multiplicity hp.1.ne_one hqz]\n  simp only [Nat.isUnit_iff, hc1, hc2]\n  rw [multiplicity_mul (Nat.prime_iff_prime_int.1 hp.1),\n    multiplicity_mul (Nat.prime_iff_prime_int.1 hp.1)]\n  · rw [Nat.cast_add, Nat.cast_add]\n    simp_rw [Int.natCast_multiplicity p q.den]\n    ring\n  · simpa [finite_int_prime_iff, hc2] using hd\n  · simpa [finite_int_prime_iff, hqz, hc2] using hd\n\n"}
{"name":"padicValRat.mul","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Rat\nhq : Ne q 0\nhr : Ne r 0\n⊢ Eq (padicValRat p (HMul.hMul q r)) (HAdd.hAdd (padicValRat p q) (padicValRat p r))","decl":"/-- A rewrite lemma for `padicValRat p (q * r)` with conditions `q ≠ 0`, `r ≠ 0`. -/\nprotected theorem mul {q r : ℚ} (hq : q ≠ 0) (hr : r ≠ 0) :\n    padicValRat p (q * r) = padicValRat p q + padicValRat p r := by\n  have : q * r = (q.num * r.num) /. (q.den * r.den) := by\n    rw [Rat.mul_eq_mkRat, Rat.mkRat_eq_divInt, Nat.cast_mul]\n  have hq' : q.num /. q.den ≠ 0 := by rwa [Rat.num_divInt_den]\n  have hr' : r.num /. r.den ≠ 0 := by rwa [Rat.num_divInt_den]\n  have hp' : Prime (p : ℤ) := Nat.prime_iff_prime_int.1 hp.1\n  rw [padicValRat.defn p (mul_ne_zero hq hr) this]\n  conv_rhs =>\n    rw [← q.num_divInt_den, padicValRat.defn p hq', ← r.num_divInt_den, padicValRat.defn p hr']\n  rw [multiplicity_mul hp', multiplicity_mul hp', Nat.cast_add, Nat.cast_add]\n  · ring\n  · simp [finite_int_prime_iff]\n  · simp [finite_int_prime_iff, hq, hr]\n\n"}
{"name":"padicValRat.pow","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Rat\nhq : Ne q 0\nk : Nat\n⊢ Eq (padicValRat p (HPow.hPow q k)) (HMul.hMul (↑k) (padicValRat p q))","decl":"/-- A rewrite lemma for `padicValRat p (q^k)` with condition `q ≠ 0`. -/\nprotected theorem pow {q : ℚ} (hq : q ≠ 0) {k : ℕ} :\n    padicValRat p (q ^ k) = k * padicValRat p q := by\n  induction k <;>\n    simp [*, padicValRat.mul hq (pow_ne_zero _ hq), _root_.pow_succ', add_mul, add_comm]\n\n"}
{"name":"padicValRat.inv","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq : Rat\n⊢ Eq (padicValRat p (Inv.inv q)) (Neg.neg (padicValRat p q))","decl":"/-- A rewrite lemma for `padicValRat p (q⁻¹)` with condition `q ≠ 0`. -/\nprotected theorem inv (q : ℚ) : padicValRat p q⁻¹ = -padicValRat p q := by\n  by_cases hq : q = 0\n  · simp [hq]\n  · rw [eq_neg_iff_add_eq_zero, ← padicValRat.mul (inv_ne_zero hq) hq, inv_mul_cancel₀ hq,\n      padicValRat.one]\n\n"}
{"name":"padicValRat.div","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Rat\nhq : Ne q 0\nhr : Ne r 0\n⊢ Eq (padicValRat p (HDiv.hDiv q r)) (HSub.hSub (padicValRat p q) (padicValRat p r))","decl":"/-- A rewrite lemma for `padicValRat p (q / r)` with conditions `q ≠ 0`, `r ≠ 0`. -/\nprotected theorem div {q r : ℚ} (hq : q ≠ 0) (hr : r ≠ 0) :\n    padicValRat p (q / r) = padicValRat p q - padicValRat p r := by\n  rw [div_eq_mul_inv, padicValRat.mul hq (inv_ne_zero hr), padicValRat.inv r, sub_eq_add_neg]\n\n"}
{"name":"padicValRat.padicValRat_le_padicValRat_iff","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn₁ n₂ d₁ d₂ : Int\nhn₁ : Ne n₁ 0\nhn₂ : Ne n₂ 0\nhd₁ : Ne d₁ 0\nhd₂ : Ne d₂ 0\n⊢ Iff (LE.le (padicValRat p (Rat.divInt n₁ d₁)) (padicValRat p (Rat.divInt n₂ d₂))) (∀ (n : Nat), Dvd.dvd (HPow.hPow (↑p) n) (HMul.hMul n₁ d₂) → Dvd.dvd (HPow.hPow (↑p) n) (HMul.hMul n₂ d₁))","decl":"/-- A condition for `padicValRat p (n₁ / d₁) ≤ padicValRat p (n₂ / d₂)`, in terms of\ndivisibility by `p^n`. -/\ntheorem padicValRat_le_padicValRat_iff {n₁ n₂ d₁ d₂ : ℤ} (hn₁ : n₁ ≠ 0) (hn₂ : n₂ ≠ 0)\n    (hd₁ : d₁ ≠ 0) (hd₂ : d₂ ≠ 0) :\n    padicValRat p (n₁ /. d₁) ≤ padicValRat p (n₂ /. d₂) ↔\n      ∀ n : ℕ, (p : ℤ) ^ n ∣ n₁ * d₂ → (p : ℤ) ^ n ∣ n₂ * d₁ := by\n  have hf1 : FiniteMultiplicity (p : ℤ) (n₁ * d₂) := finite_int_prime_iff.2 (mul_ne_zero hn₁ hd₂)\n  have hf2 : FiniteMultiplicity (p : ℤ) (n₂ * d₁) := finite_int_prime_iff.2 (mul_ne_zero hn₂ hd₁)\n  conv =>\n    lhs\n    rw [padicValRat.defn p (Rat.divInt_ne_zero_of_ne_zero hn₁ hd₁) rfl,\n      padicValRat.defn p (Rat.divInt_ne_zero_of_ne_zero hn₂ hd₂) rfl, sub_le_iff_le_add', ←\n      add_sub_assoc, _root_.le_sub_iff_add_le]\n    norm_cast\n    rw [← multiplicity_mul (Nat.prime_iff_prime_int.1 hp.1) hf1, add_comm,\n        ← multiplicity_mul (Nat.prime_iff_prime_int.1 hp.1) hf2,\n        hf1.multiplicity_le_multiplicity_iff hf2]\n\n"}
{"name":"padicValRat.le_padicValRat_add_of_le","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Rat\nhqr : Ne (HAdd.hAdd q r) 0\nh : LE.le (padicValRat p q) (padicValRat p r)\n⊢ LE.le (padicValRat p q) (padicValRat p (HAdd.hAdd q r))","decl":"/-- Sufficient conditions to show that the `p`-adic valuation of `q` is less than or equal to the\n`p`-adic valuation of `q + r`. -/\ntheorem le_padicValRat_add_of_le {q r : ℚ} (hqr : q + r ≠ 0)\n    (h : padicValRat p q ≤ padicValRat p r) : padicValRat p q ≤ padicValRat p (q + r) :=\n  if hq : q = 0 then by simpa [hq] using h\n  else\n    if hr : r = 0 then by simp [hr]\n    else by\n      have hqn : q.num ≠ 0 := Rat.num_ne_zero.2 hq\n      have hqd : (q.den : ℤ) ≠ 0 := mod_cast Rat.den_nz _\n      have hrn : r.num ≠ 0 := Rat.num_ne_zero.2 hr\n      have hrd : (r.den : ℤ) ≠ 0 := mod_cast Rat.den_nz _\n      have hqreq : q + r = (q.num * r.den + q.den * r.num) /. (q.den * r.den) := Rat.add_num_den _ _\n      have hqrd : q.num * r.den + q.den * r.num ≠ 0 := Rat.mk_num_ne_zero_of_ne_zero hqr hqreq\n      conv_lhs => rw [← q.num_divInt_den]\n      rw [hqreq, padicValRat_le_padicValRat_iff hqn hqrd hqd (mul_ne_zero hqd hrd), ←\n        emultiplicity_le_emultiplicity_iff, mul_left_comm,\n        emultiplicity_mul (Nat.prime_iff_prime_int.1 hp.1), add_mul]\n      rw [← q.num_divInt_den, ← r.num_divInt_den, padicValRat_le_padicValRat_iff hqn hrn hqd hrd, ←\n        emultiplicity_le_emultiplicity_iff] at h\n      calc\n        _ ≤\n            min (emultiplicity (↑p) (q.num * r.den * q.den))\n              (emultiplicity (↑p) (↑q.den * r.num * ↑q.den)) :=\n          le_min\n            (by rw [emultiplicity_mul (a :=_ * _) (Nat.prime_iff_prime_int.1 hp.1), add_comm])\n            (by\n              rw [mul_assoc,\n                  emultiplicity_mul (b := _ * _) (Nat.prime_iff_prime_int.1 hp.1)]\n              exact add_le_add_left h _)\n        _ ≤ _ := min_le_emultiplicity_add\n\n"}
{"name":"padicValRat.min_le_padicValRat_add","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Rat\nhqr : Ne (HAdd.hAdd q r) 0\n⊢ LE.le (Min.min (padicValRat p q) (padicValRat p r)) (padicValRat p (HAdd.hAdd q r))","decl":"/-- The minimum of the valuations of `q` and `r` is at most the valuation of `q + r`. -/\ntheorem min_le_padicValRat_add {q r : ℚ} (hqr : q + r ≠ 0) :\n    min (padicValRat p q) (padicValRat p r) ≤ padicValRat p (q + r) :=\n  (le_total (padicValRat p q) (padicValRat p r)).elim\n  (fun h => by rw [min_eq_left h]; exact le_padicValRat_add_of_le hqr h)\n  (fun h => by rw [min_eq_right h, add_comm]; exact le_padicValRat_add_of_le (by rwa [add_comm]) h)\n\n"}
{"name":"padicValRat.add_eq_min","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Rat\nhqr : Ne (HAdd.hAdd q r) 0\nhq : Ne q 0\nhr : Ne r 0\nhval : Ne (padicValRat p q) (padicValRat p r)\n⊢ Eq (padicValRat p (HAdd.hAdd q r)) (Min.min (padicValRat p q) (padicValRat p r))","decl":"/-- Ultrametric property of a p-adic valuation. -/\nlemma add_eq_min {q r : ℚ} (hqr : q + r ≠ 0) (hq : q ≠ 0) (hr : r ≠ 0)\n    (hval : padicValRat p q ≠ padicValRat p r) :\n    padicValRat p (q + r) = min (padicValRat p q) (padicValRat p r) := by\n  have h1 := min_le_padicValRat_add (p := p) hqr\n  have h2 := min_le_padicValRat_add (p := p) (ne_of_eq_of_ne (add_neg_cancel_right q r) hq)\n  have h3 := min_le_padicValRat_add (p := p) (ne_of_eq_of_ne (add_neg_cancel_right r q) hr)\n  rw [add_neg_cancel_right, padicValRat.neg] at h2 h3\n  rw [add_comm] at h3\n  omega\n\n"}
{"name":"padicValRat.add_eq_of_lt","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r : Rat\nhqr : Ne (HAdd.hAdd q r) 0\nhq : Ne q 0\nhr : Ne r 0\nhval : LT.lt (padicValRat p q) (padicValRat p r)\n⊢ Eq (padicValRat p (HAdd.hAdd q r)) (padicValRat p q)","decl":"lemma add_eq_of_lt {q r : ℚ} (hqr : q + r ≠ 0)\n    (hq : q ≠ 0) (hr : r ≠ 0) (hval : padicValRat p q < padicValRat p r) :\n    padicValRat p (q + r) = padicValRat p q := by\n  rw [add_eq_min hqr hq hr (ne_of_lt hval), min_eq_left (le_of_lt hval)]\n\n"}
{"name":"padicValRat.lt_add_of_lt","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nq r₁ r₂ : Rat\nhqr : Ne (HAdd.hAdd r₁ r₂) 0\nhval₁ : LT.lt (padicValRat p q) (padicValRat p r₁)\nhval₂ : LT.lt (padicValRat p q) (padicValRat p r₂)\n⊢ LT.lt (padicValRat p q) (padicValRat p (HAdd.hAdd r₁ r₂))","decl":"lemma lt_add_of_lt {q r₁ r₂ : ℚ} (hqr : r₁ + r₂ ≠ 0)\n    (hval₁ : padicValRat p q < padicValRat p r₁) (hval₂ : padicValRat p q < padicValRat p r₂) :\n    padicValRat p q < padicValRat p (r₁ + r₂) :=\n  lt_of_lt_of_le (lt_min hval₁ hval₂) (padicValRat.min_le_padicValRat_add hqr)\n\n"}
{"name":"padicValRat.self_pow_inv","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nr : Nat\n⊢ Eq (padicValRat p (Inv.inv (HPow.hPow (↑p) r))) (Neg.neg ↑r)","decl":"@[simp]\nlemma self_pow_inv (r : ℕ) : padicValRat p ((p : ℚ) ^ r)⁻¹ = -r := by\n  rw [padicValRat.inv, neg_inj, padicValRat.pow (Nat.cast_ne_zero.mpr hp.elim.ne_zero),\n      padicValRat.self hp.elim.one_lt, mul_one]\n\n"}
{"name":"padicValRat.sum_pos_of_pos","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\nF : Nat → Rat\nhF : ∀ (i : Nat), LT.lt i n → LT.lt 0 (padicValRat p (F i))\nhn0 : Ne ((Finset.range n).sum fun i => F i) 0\n⊢ LT.lt 0 (padicValRat p ((Finset.range n).sum fun i => F i))","decl":"/-- A finite sum of rationals with positive `p`-adic valuation has positive `p`-adic valuation\n(if the sum is non-zero). -/\ntheorem sum_pos_of_pos {n : ℕ} {F : ℕ → ℚ} (hF : ∀ i, i < n → 0 < padicValRat p (F i))\n    (hn0 : ∑ i ∈ Finset.range n, F i ≠ 0) : 0 < padicValRat p (∑ i ∈ Finset.range n, F i) := by\n  induction' n with d hd\n  · exact False.elim (hn0 rfl)\n  · rw [Finset.sum_range_succ] at hn0 ⊢\n    by_cases h : ∑ x ∈ Finset.range d, F x = 0\n    · rw [h, zero_add]\n      exact hF d (lt_add_one _)\n    · refine lt_of_lt_of_le ?_ (min_le_padicValRat_add hn0)\n      refine lt_min (hd (fun i hi => ?_) h) (hF d (lt_add_one _))\n      exact hF _ (lt_trans hi (lt_add_one _))\n\n"}
{"name":"padicValRat.lt_sum_of_lt","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p j : Nat\nhp : Fact (Nat.Prime p)\nF : Nat → Rat\nS : Finset Nat\nhS : S.Nonempty\nhF : ∀ (i : Nat), Membership.mem S i → LT.lt (padicValRat p (F j)) (padicValRat p (F i))\nhn1 : ∀ (i : Nat), LT.lt 0 (F i)\n⊢ LT.lt (padicValRat p (F j)) (padicValRat p (S.sum fun i => F i))","decl":"/-- If the p-adic valuation of a finite set of positive rationals is greater than a given rational\nnumber, then the p-adic valuation of their sum is also greater than the same rational number. -/\ntheorem lt_sum_of_lt {p j : ℕ} [hp : Fact (Nat.Prime p)] {F : ℕ → ℚ} {S : Finset ℕ}\n    (hS : S.Nonempty) (hF : ∀ i, i ∈ S → padicValRat p (F j) < padicValRat p (F i))\n    (hn1 : ∀ i : ℕ, 0 < F i) : padicValRat p (F j) < padicValRat p (∑ i ∈ S, F i) := by\n  induction' hS using Finset.Nonempty.cons_induction with k s S' Hnot Hne Hind\n  · rw [Finset.sum_singleton]\n    exact hF k (by simp)\n  · rw [Finset.cons_eq_insert, Finset.sum_insert Hnot]\n    exact padicValRat.lt_add_of_lt\n      (ne_of_gt (add_pos (hn1 s) (Finset.sum_pos (fun i _ => hn1 i) Hne)))\n      (hF _ (by simp [Finset.mem_insert, true_or]))\n      (Hind (fun i hi => hF _ (by rw [Finset.cons_eq_insert,Finset.mem_insert]; exact Or.inr hi)))\n\n"}
{"name":"padicValNat.mul","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p a b : Nat\nhp : Fact (Nat.Prime p)\na✝¹ : Ne a 0\na✝ : Ne b 0\n⊢ Eq (padicValNat p (HMul.hMul a b)) (HAdd.hAdd (padicValNat p a) (padicValNat p b))","decl":"/-- A rewrite lemma for `padicValNat p (a * b)` with conditions `a ≠ 0`, `b ≠ 0`. -/\nprotected theorem mul : a ≠ 0 → b ≠ 0 → padicValNat p (a * b) = padicValNat p a + padicValNat p b :=\n  mod_cast padicValRat.mul (p := p) (q := a) (r := b)\n\n"}
{"name":"padicValNat.div_of_dvd","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p a b : Nat\nhp : Fact (Nat.Prime p)\nh : Dvd.dvd b a\n⊢ Eq (padicValNat p (HDiv.hDiv a b)) (HSub.hSub (padicValNat p a) (padicValNat p b))","decl":"protected theorem div_of_dvd (h : b ∣ a) :\n    padicValNat p (a / b) = padicValNat p a - padicValNat p b := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · simp\n  obtain ⟨k, rfl⟩ := h\n  obtain ⟨hb, hk⟩ := mul_ne_zero_iff.mp ha\n  rw [mul_comm, k.mul_div_cancel hb.bot_lt, padicValNat.mul hk hb, Nat.add_sub_cancel]\n\n"}
{"name":"padicValNat.div","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p b : Nat\nhp : Fact (Nat.Prime p)\ndvd : Dvd.dvd p b\n⊢ Eq (padicValNat p (HDiv.hDiv b p)) (HSub.hSub (padicValNat p b) 1)","decl":"/-- Dividing out by a prime factor reduces the `padicValNat` by `1`. -/\nprotected theorem div (dvd : p ∣ b) : padicValNat p (b / p) = padicValNat p b - 1 := by\n  rw [padicValNat.div_of_dvd dvd, padicValNat_self]\n\n"}
{"name":"padicValNat.pow","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p a : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\nha : Ne a 0\n⊢ Eq (padicValNat p (HPow.hPow a n)) (HMul.hMul n (padicValNat p a))","decl":"/-- A version of `padicValRat.pow` for `padicValNat`. -/\nprotected theorem pow (n : ℕ) (ha : a ≠ 0) : padicValNat p (a ^ n) = n * padicValNat p a := by\n  simpa only [← @Nat.cast_inj ℤ, push_cast] using padicValRat.pow (Nat.cast_ne_zero.mpr ha)\n\n"}
{"name":"padicValNat.prime_pow","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n⊢ Eq (padicValNat p (HPow.hPow p n)) n","decl":"@[simp]\nprotected theorem prime_pow (n : ℕ) : padicValNat p (p ^ n) = n := by\n  rw [padicValNat.pow _ (@Fact.out p.Prime).ne_zero, padicValNat_self, mul_one]\n\n"}
{"name":"padicValNat.div_pow","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p a b : Nat\nhp : Fact (Nat.Prime p)\ndvd : Dvd.dvd (HPow.hPow p a) b\n⊢ Eq (padicValNat p (HDiv.hDiv b (HPow.hPow p a))) (HSub.hSub (padicValNat p b) a)","decl":"protected theorem div_pow (dvd : p ^ a ∣ b) : padicValNat p (b / p ^ a) = padicValNat p b - a := by\n  rw [padicValNat.div_of_dvd dvd, padicValNat.prime_pow]\n\n"}
{"name":"padicValNat.div'","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nm : Nat\ncpm : p.Coprime m\nb : Nat\ndvd : Dvd.dvd m b\n⊢ Eq (padicValNat p (HDiv.hDiv b m)) (padicValNat p b)","decl":"protected theorem div' {m : ℕ} (cpm : Coprime p m) {b : ℕ} (dvd : m ∣ b) :\n    padicValNat p (b / m) = padicValNat p b := by\n  rw [padicValNat.div_of_dvd dvd, eq_zero_of_not_dvd (hp.out.coprime_iff_not_dvd.mp cpm),\n    Nat.sub_zero]\n\n"}
{"name":"dvd_of_one_le_padicValNat","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\nhp : LE.le 1 (padicValNat p n)\n⊢ Dvd.dvd p n","decl":"theorem dvd_of_one_le_padicValNat {n : ℕ} (hp : 1 ≤ padicValNat p n) : p ∣ n := by\n  by_contra h\n  rw [padicValNat.eq_zero_of_not_dvd h] at hp\n  exact lt_irrefl 0 (lt_of_lt_of_le zero_lt_one hp)\n\n"}
{"name":"pow_padicValNat_dvd","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\n⊢ Dvd.dvd (HPow.hPow p (padicValNat p n)) n","decl":"theorem pow_padicValNat_dvd {n : ℕ} : p ^ padicValNat p n ∣ n := by\n  rcases n.eq_zero_or_pos with (rfl | hn); · simp\n  rcases eq_or_ne p 1 with (rfl | hp); · simp\n  apply pow_dvd_of_le_multiplicity\n  rw [padicValNat_def'] <;> assumption\n\n"}
{"name":"padicValNat_dvd_iff_le","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\na n : Nat\nha : Ne a 0\n⊢ Iff (Dvd.dvd (HPow.hPow p n) a) (LE.le n (padicValNat p a))","decl":"theorem padicValNat_dvd_iff_le [hp : Fact p.Prime] {a n : ℕ} (ha : a ≠ 0) :\n    p ^ n ∣ a ↔ n ≤ padicValNat p a := by\n  rw [pow_dvd_iff_le_emultiplicity, ← padicValNat_eq_emultiplicity (Nat.pos_of_ne_zero ha),\n    Nat.cast_le]\n\n"}
{"name":"padicValNat_dvd_iff","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\nhp : Fact (Nat.Prime p)\na : Nat\n⊢ Iff (Dvd.dvd (HPow.hPow p n) a) (Or (Eq a 0) (LE.le n (padicValNat p a)))","decl":"theorem padicValNat_dvd_iff (n : ℕ) [hp : Fact p.Prime] (a : ℕ) :\n    p ^ n ∣ a ↔ a = 0 ∨ n ≤ padicValNat p a := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  · exact iff_of_true (dvd_zero _) (Or.inl rfl)\n  · rw [padicValNat_dvd_iff_le ha, or_iff_right ha]\n\n"}
{"name":"pow_succ_padicValNat_not_dvd","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\nhp : Fact (Nat.Prime p)\nhn : Ne n 0\n⊢ Not (Dvd.dvd (HPow.hPow p (HAdd.hAdd (padicValNat p n) 1)) n)","decl":"theorem pow_succ_padicValNat_not_dvd {n : ℕ} [hp : Fact p.Prime] (hn : n ≠ 0) :\n    ¬p ^ (padicValNat p n + 1) ∣ n := by\n  rw [padicValNat_dvd_iff_le hn, not_le]\n  exact Nat.lt_succ_self _\n\n"}
{"name":"padicValNat_primes","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p q : Nat\nhp : Fact (Nat.Prime p)\nhq : Fact (Nat.Prime q)\nneq : Ne p q\n⊢ Eq (padicValNat p q) 0","decl":"theorem padicValNat_primes {q : ℕ} [hp : Fact p.Prime] [hq : Fact q.Prime] (neq : p ≠ q) :\n    padicValNat p q = 0 :=\n  @padicValNat.eq_zero_of_not_dvd p q <|\n    (not_congr (Iff.symm (prime_dvd_prime_iff_eq hp.1 hq.1))).mp neq\n\n"}
{"name":"padicValNat_prime_prime_pow","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p q : Nat\nhp : Fact (Nat.Prime p)\nhq : Fact (Nat.Prime q)\nn : Nat\nneq : Ne p q\n⊢ Eq (padicValNat p (HPow.hPow q n)) 0","decl":"theorem padicValNat_prime_prime_pow {q : ℕ} [hp : Fact p.Prime] [hq : Fact q.Prime]\n    (n : ℕ) (neq : p ≠ q) : padicValNat p (q ^ n) = 0 := by\n  rw [padicValNat.pow _ <| Nat.Prime.ne_zero hq.elim, padicValNat_primes neq, mul_zero]\n\n"}
{"name":"padicValNat_mul_pow_left","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p q : Nat\nhp : Fact (Nat.Prime p)\nhq : Fact (Nat.Prime q)\nn m : Nat\nneq : Ne p q\n⊢ Eq (padicValNat p (HMul.hMul (HPow.hPow p n) (HPow.hPow q m))) n","decl":"theorem padicValNat_mul_pow_left {q : ℕ} [hp : Fact p.Prime] [hq : Fact q.Prime]\n    (n m : ℕ) (neq : p ≠ q) : padicValNat p (p^n * q^m) = n := by\n  rw [padicValNat.mul (NeZero.ne' (p^n)).symm (NeZero.ne' (q^m)).symm,\n    padicValNat.prime_pow, padicValNat_prime_prime_pow m neq, add_zero]\n\n"}
{"name":"padicValNat_mul_pow_right","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p q : Nat\nhp : Fact (Nat.Prime p)\nhq : Fact (Nat.Prime q)\nn m : Nat\nneq : Ne q p\n⊢ Eq (padicValNat q (HMul.hMul (HPow.hPow p n) (HPow.hPow q m))) m","decl":"theorem padicValNat_mul_pow_right {q : ℕ} [hp : Fact p.Prime] [hq : Fact q.Prime]\n    (n m : ℕ) (neq : q ≠ p) : padicValNat q (p^n * q^m) = m := by\n  rw [mul_comm (p^n) (q^m)]\n  exact padicValNat_mul_pow_left m n neq\n\n"}
{"name":"padicValNat_le_nat_log","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\n⊢ LE.le (padicValNat p n) (Nat.log p n)","decl":"/-- The p-adic valuation of `n` is less than or equal to its logarithm w.r.t `p`. -/\nlemma padicValNat_le_nat_log (n : ℕ) : padicValNat p n ≤ Nat.log p n := by\n  rcases n with _ | n\n  · simp\n  rcases p with _ | _ | p\n  · simp\n  · simp\n  exact Nat.le_log_of_pow_le p.one_lt_succ_succ (le_of_dvd n.succ_pos pow_padicValNat_dvd)\n\n"}
{"name":"nat_log_eq_padicValNat_iff","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\nhp : Fact (Nat.Prime p)\nhn : LT.lt 0 n\n⊢ Iff (Eq (Nat.log p n) (padicValNat p n)) (LT.lt n (HPow.hPow p (HAdd.hAdd (padicValNat p n) 1)))","decl":"/-- The p-adic valuation of `n` is equal to the logarithm w.r.t `p` iff\n    `n` is less than `p` raised to one plus the p-adic valuation of `n`. -/\nlemma nat_log_eq_padicValNat_iff {n : ℕ} [hp : Fact (Nat.Prime p)] (hn : 0 < n) :\n    Nat.log p n = padicValNat p n ↔ n < p ^ (padicValNat p n + 1) := by\n  rw [Nat.log_eq_iff (Or.inr ⟨(Nat.Prime.one_lt' p).out, by omega⟩), and_iff_right_iff_imp]\n  exact fun _ => Nat.le_of_dvd hn pow_padicValNat_dvd\n\n"}
{"name":"Nat.log_ne_padicValNat_succ","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Ne (Nat.log 2 n) (padicValNat 2 (HAdd.hAdd n 1))","decl":"lemma Nat.log_ne_padicValNat_succ {n : ℕ} (hn : n ≠ 0) : log 2 n ≠ padicValNat 2 (n + 1) := by\n  rw [Ne, log_eq_iff (by simp [hn])]\n  rintro ⟨h1, h2⟩\n  rw [← Nat.lt_add_one_iff, ← mul_one (2 ^ _)] at h1\n  rw [← add_one_le_iff, Nat.pow_succ] at h2\n  refine not_dvd_of_between_consec_multiples h1 (lt_of_le_of_ne' h2 ?_) pow_padicValNat_dvd\n  -- TODO(kmill): Why is this `p := 2` necessary?\n  exact pow_succ_padicValNat_not_dvd (p := 2) n.succ_ne_zero ∘ dvd_of_eq\n\n"}
{"name":"Nat.max_log_padicValNat_succ_eq_log_succ","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"n : Nat\n⊢ Eq (Max.max (Nat.log 2 n) (padicValNat 2 (HAdd.hAdd n 1))) (Nat.log 2 (HAdd.hAdd n 1))","decl":"lemma Nat.max_log_padicValNat_succ_eq_log_succ (n : ℕ) :\n    max (log 2 n) (padicValNat 2 (n + 1)) = log 2 (n + 1) := by\n  apply le_antisymm (max_le (le_log_of_pow_le one_lt_two (pow_log_le_add_one 2 n))\n    (padicValNat_le_nat_log (n + 1)))\n  rw [le_max_iff, or_iff_not_imp_left, not_le]\n  intro h\n  replace h := le_antisymm (add_one_le_iff.mpr (lt_pow_of_log_lt one_lt_two h))\n    (pow_log_le_self 2 n.succ_ne_zero)\n  rw [h, padicValNat.prime_pow, ← h]\n\n"}
{"name":"range_pow_padicValNat_subset_divisors","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\nhn : Ne n 0\n⊢ HasSubset.Subset (Finset.image (fun x => HPow.hPow p x) (Finset.range (HAdd.hAdd (padicValNat p n) 1))) n.divisors","decl":"theorem range_pow_padicValNat_subset_divisors {n : ℕ} (hn : n ≠ 0) :\n    (Finset.range (padicValNat p n + 1)).image (p ^ ·) ⊆ n.divisors := by\n  intro t ht\n  simp only [exists_prop, Finset.mem_image, Finset.mem_range] at ht\n  obtain ⟨k, hk, rfl⟩ := ht\n  rw [Nat.mem_divisors]\n  exact ⟨(pow_dvd_pow p <| by omega).trans pow_padicValNat_dvd, hn⟩\n\n"}
{"name":"range_pow_padicValNat_subset_divisors'","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\nhp : Fact (Nat.Prime p)\n⊢ HasSubset.Subset (Finset.image (fun t => HPow.hPow p (HAdd.hAdd t 1)) (Finset.range (padicValNat p n))) (n.divisors.erase 1)","decl":"theorem range_pow_padicValNat_subset_divisors' {n : ℕ} [hp : Fact p.Prime] :\n    ((Finset.range (padicValNat p n)).image fun t => p ^ (t + 1)) ⊆ n.divisors.erase 1 := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp\n  intro t ht\n  simp only [exists_prop, Finset.mem_image, Finset.mem_range] at ht\n  obtain ⟨k, hk, rfl⟩ := ht\n  rw [Finset.mem_erase, Nat.mem_divisors]\n  refine ⟨?_, (pow_dvd_pow p <| succ_le_iff.2 hk).trans pow_padicValNat_dvd, hn⟩\n  exact (Nat.one_lt_pow k.succ_ne_zero hp.out.one_lt).ne'\n\n"}
{"name":"padicValNat_factorial_mul","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (padicValNat p (HMul.hMul p n).factorial) (HAdd.hAdd (padicValNat p n.factorial) n)","decl":"/-- The `p`-adic valuation of `(p * n)!` is `n` more than that of `n!`. -/\ntheorem padicValNat_factorial_mul (n : ℕ) [hp : Fact p.Prime] :\n    padicValNat p (p * n) ! = padicValNat p n ! + n := by\n  apply Nat.cast_injective (R := ℕ∞)\n  rw [padicValNat_eq_emultiplicity <| factorial_pos (p * n), Nat.cast_add,\n      padicValNat_eq_emultiplicity <| factorial_pos n]\n  exact Prime.emultiplicity_factorial_mul hp.out\n\n"}
{"name":"padicValNat_eq_zero_of_mem_Ioo","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p m k : Nat\nhm : Membership.mem (Set.Ioo (HMul.hMul p k) (HMul.hMul p (HAdd.hAdd k 1))) m\n⊢ Eq (padicValNat p m) 0","decl":"/-- The `p`-adic valuation of `m` equals zero if it is between `p * k` and `p * (k + 1)` for\nsome `k`. -/\ntheorem padicValNat_eq_zero_of_mem_Ioo {m k : ℕ}\n    (hm : m ∈ Set.Ioo (p * k) (p * (k + 1))) : padicValNat p m = 0 :=\n  padicValNat.eq_zero_of_not_dvd <| not_dvd_of_between_consec_multiples hm.1 hm.2\n\n"}
{"name":"padicValNat_factorial_mul_add","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n m : Nat\nhp : Fact (Nat.Prime p)\nh : LT.lt n p\n⊢ Eq (padicValNat p (HAdd.hAdd (HMul.hMul p m) n).factorial) (padicValNat p (HMul.hMul p m).factorial)","decl":"theorem padicValNat_factorial_mul_add {n : ℕ} (m : ℕ) [hp : Fact p.Prime] (h : n < p) :\n    padicValNat p (p * m + n) ! = padicValNat p (p * m) ! := by\n  induction n with\n  | zero => rw [add_zero]\n  | succ n hn =>\n    rw [add_succ, factorial_succ,\n      padicValNat.mul (succ_ne_zero (p * m + n)) <| factorial_ne_zero (p * m + _),\n      hn <| lt_of_succ_lt h, ← add_succ,\n      padicValNat_eq_zero_of_mem_Ioo ⟨(Nat.lt_add_of_pos_right <| succ_pos n),\n        (Nat.mul_add _ _ _▸ Nat.mul_one _ ▸ ((add_lt_add_iff_left (p * m)).mpr h))⟩,\n      zero_add]\n\n"}
{"name":"padicValNat_mul_div_factorial","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (padicValNat p (HMul.hMul p (HDiv.hDiv n p)).factorial) (padicValNat p n.factorial)","decl":"/-- The `p`-adic valuation of `n!` is equal to the `p`-adic valuation of the factorial of the\nlargest multiple of `p` below `n`, i.e. `(p * ⌊n / p⌋)!`. -/\n@[simp] theorem padicValNat_mul_div_factorial (n : ℕ) [hp : Fact p.Prime] :\n    padicValNat p (p * (n / p))! = padicValNat p n ! := by\n  nth_rw 2 [← div_add_mod n p]\n  exact (padicValNat_factorial_mul_add (n / p) <| mod_lt n hp.out.pos).symm\n\n"}
{"name":"padicValNat_factorial","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n b : Nat\nhp : Fact (Nat.Prime p)\nhnb : LT.lt (Nat.log p n) b\n⊢ Eq (padicValNat p n.factorial) ((Finset.Ico 1 b).sum fun i => HDiv.hDiv n (HPow.hPow p i))","decl":"/-- **Legendre's Theorem**\n\nThe `p`-adic valuation of `n!` is the sum of the quotients `n / p ^ i`. This sum is expressed\nover the finset `Ico 1 b` where `b` is any bound greater than `log p n`. -/\ntheorem padicValNat_factorial {n b : ℕ} [hp : Fact p.Prime] (hnb : log p n < b) :\n    padicValNat p (n !) = ∑ i ∈ Finset.Ico 1 b, n / p ^ i := by\n  exact_mod_cast ((padicValNat_eq_emultiplicity (p := p) <| factorial_pos _) ▸\n      Prime.emultiplicity_factorial hp.out hnb)\n\n"}
{"name":"sub_one_mul_padicValNat_factorial","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n⊢ Eq (HMul.hMul (HSub.hSub p 1) (padicValNat p n.factorial)) (HSub.hSub n (p.digits n).sum)","decl":"/-- **Legendre's Theorem**\n\nTaking (`p - 1`) times the `p`-adic valuation of `n!` equals `n` minus the sum of base `p` digits\nof `n`. -/\ntheorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : ℕ) :\n    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum := by\n  rw [padicValNat_factorial <| lt_succ_of_lt <| lt.base (log p n)]\n  nth_rw 2 [← zero_add 1]\n  rw [Nat.succ_eq_add_one, ← Finset.sum_Ico_add' _ 0 _ 1,\n    Ico_zero_eq_range, ← sub_one_mul_sum_log_div_pow_eq_sub_sum_digits, Nat.succ_eq_add_one]\n\n"}
{"name":"padicValNat_choose","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n k b : Nat\nhp : Fact (Nat.Prime p)\nhkn : LE.le k n\nhnb : LT.lt (Nat.log p n) b\n⊢ Eq (padicValNat p (n.choose k)) (Finset.filter (fun i => LE.le (HPow.hPow p i) (HAdd.hAdd (HMod.hMod k (HPow.hPow p i)) (HMod.hMod (HSub.hSub n k) (HPow.hPow p i)))) (Finset.Ico 1 b)).card","decl":"/-- **Kummer's Theorem**\n\nThe `p`-adic valuation of `n.choose k` is the number of carries when `k` and `n - k` are added\nin base `p`. This sum is expressed over the finset `Ico 1 b` where `b` is any bound greater than\n`log p n`. -/\ntheorem padicValNat_choose {n k b : ℕ} [hp : Fact p.Prime] (hkn : k ≤ n) (hnb : log p n < b) :\n    padicValNat p (choose n k) =\n    ((Finset.Ico 1 b).filter fun i => p ^ i ≤ k % p ^ i + (n - k) % p ^ i).card := by\n  exact_mod_cast (padicValNat_eq_emultiplicity (p := p) <| choose_pos hkn) ▸\n    Prime.emultiplicity_choose hp.out hkn hnb\n\n"}
{"name":"padicValNat_choose'","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p n k b : Nat\nhp : Fact (Nat.Prime p)\nhnb : LT.lt (Nat.log p (HAdd.hAdd n k)) b\n⊢ Eq (padicValNat p ((HAdd.hAdd n k).choose k)) (Finset.filter (fun i => LE.le (HPow.hPow p i) (HAdd.hAdd (HMod.hMod k (HPow.hPow p i)) (HMod.hMod n (HPow.hPow p i)))) (Finset.Ico 1 b)).card","decl":"/-- **Kummer's Theorem**\n\nThe `p`-adic valuation of `(n + k).choose k` is the number of carries when `k` and `n` are added\nin base `p`. This sum is expressed over the finset `Ico 1 b` where `b` is any bound greater than\n`log p (n + k)`. -/\ntheorem padicValNat_choose' {n k b : ℕ} [hp : Fact p.Prime] (hnb : log p (n + k) < b) :\n    padicValNat p (choose (n + k) k) =\n    ((Finset.Ico 1 b).filter fun i => p ^ i ≤ k % p ^ i + n % p ^ i).card := by\n  exact_mod_cast (padicValNat_eq_emultiplicity (p := p) <| choose_pos <|\n    Nat.le_add_left k n)▸ Prime.emultiplicity_choose' hp.out hnb\n\n"}
{"name":"sub_one_mul_padicValNat_choose_eq_sub_sum_digits'","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p k n : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (HMul.hMul (HSub.hSub p 1) (padicValNat p ((HAdd.hAdd n k).choose k))) (HSub.hSub (HAdd.hAdd (p.digits k).sum (p.digits n).sum) (p.digits (HAdd.hAdd n k)).sum)","decl":"/-- **Kummer's Theorem**\nTaking (`p - 1`) times the `p`-adic valuation of the binomial `n + k` over `k` equals the sum of the\ndigits of `k` plus the sum of the digits of `n` minus the sum of digits of `n + k`, all base `p`.\n-/\ntheorem sub_one_mul_padicValNat_choose_eq_sub_sum_digits' {k n : ℕ} [hp : Fact p.Prime] :\n    (p - 1) * padicValNat p (choose (n + k) k) =\n    (p.digits k).sum + (p.digits n).sum - (p.digits (n + k)).sum := by\n  have h : k ≤ n + k := by exact Nat.le_add_left k n\n  simp only [Nat.choose_eq_factorial_div_factorial h]\n  rw [padicValNat.div_of_dvd <| factorial_mul_factorial_dvd_factorial h, Nat.mul_sub_left_distrib,\n      padicValNat.mul (factorial_ne_zero _) (factorial_ne_zero _), Nat.mul_add]\n  simp only [sub_one_mul_padicValNat_factorial]\n  rw [← Nat.sub_add_comm <| digit_sum_le p k, Nat.add_sub_cancel n k, ← Nat.add_sub_assoc <|\n      digit_sum_le p n, Nat.sub_sub (k + n), ← Nat.sub_right_comm, Nat.sub_sub, sub_add_eq,\n      add_comm, tsub_tsub_assoc (Nat.le_refl (k + n)) <| (add_comm k n) ▸ (Nat.add_le_add\n      (digit_sum_le p n) (digit_sum_le p k)), Nat.sub_self (k + n), zero_add, add_comm]\n\n"}
{"name":"sub_one_mul_padicValNat_choose_eq_sub_sum_digits","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p k n : Nat\nhp : Fact (Nat.Prime p)\nh : LE.le k n\n⊢ Eq (HMul.hMul (HSub.hSub p 1) (padicValNat p (n.choose k))) (HSub.hSub (HAdd.hAdd (p.digits k).sum (p.digits (HSub.hSub n k)).sum) (p.digits n).sum)","decl":"/-- **Kummer's Theorem**\nTaking (`p - 1`) times the `p`-adic valuation of the binomial `n` over `k` equals the sum of the\ndigits of `k` plus the sum of the digits of `n - k` minus the sum of digits of `n`, all base `p`.\n-/\ntheorem sub_one_mul_padicValNat_choose_eq_sub_sum_digits {k n : ℕ} [hp : Fact p.Prime]\n    (h : k ≤ n) : (p - 1) * padicValNat p (choose n k) =\n    (p.digits k).sum + (p.digits (n - k)).sum - (p.digits n).sum := by\n  convert @sub_one_mul_padicValNat_choose_eq_sub_sum_digits' _ _ _ ‹_›\n  all_goals omega\n\n"}
{"name":"padicValInt_dvd_iff","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\na : Int\n⊢ Iff (Dvd.dvd (HPow.hPow (↑p) n) a) (Or (Eq a 0) (LE.le n (padicValInt p a)))","decl":"theorem padicValInt_dvd_iff (n : ℕ) (a : ℤ) : (p : ℤ) ^ n ∣ a ↔ a = 0 ∨ n ≤ padicValInt p a := by\n  rw [padicValInt, ← Int.natAbs_eq_zero, ← padicValNat_dvd_iff, ← Int.natCast_dvd, Int.natCast_pow]\n\n"}
{"name":"padicValInt_dvd","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\na : Int\n⊢ Dvd.dvd (HPow.hPow (↑p) (padicValInt p a)) a","decl":"theorem padicValInt_dvd (a : ℤ) : (p : ℤ) ^ padicValInt p a ∣ a := by\n  rw [padicValInt_dvd_iff]\n  exact Or.inr le_rfl\n\n"}
{"name":"padicValInt_self","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (padicValInt p ↑p) 1","decl":"theorem padicValInt_self : padicValInt p p = 1 :=\n  padicValInt.self hp.out.one_lt\n\n"}
{"name":"padicValInt.mul","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\na b : Int\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (padicValInt p (HMul.hMul a b)) (HAdd.hAdd (padicValInt p a) (padicValInt p b))","decl":"theorem padicValInt.mul {a b : ℤ} (ha : a ≠ 0) (hb : b ≠ 0) :\n    padicValInt p (a * b) = padicValInt p a + padicValInt p b := by\n  simp_rw [padicValInt]\n  rw [Int.natAbs_mul, padicValNat.mul] <;> rwa [Int.natAbs_ne_zero]\n\n"}
{"name":"padicValInt_mul_eq_succ","module":"Mathlib.NumberTheory.Padics.PadicVal.Basic","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\na : Int\nha : Ne a 0\n⊢ Eq (padicValInt p (HMul.hMul a ↑p)) (HAdd.hAdd (padicValInt p a) 1)","decl":"theorem padicValInt_mul_eq_succ (a : ℤ) (ha : a ≠ 0) :\n    padicValInt p (a * p) = padicValInt p a + 1 := by\n  rw [padicValInt.mul ha (Int.natCast_ne_zero.mpr hp.out.ne_zero)]\n  simp only [eq_self_iff_true, padicValInt.of_nat, padicValNat_self]\n\n"}
