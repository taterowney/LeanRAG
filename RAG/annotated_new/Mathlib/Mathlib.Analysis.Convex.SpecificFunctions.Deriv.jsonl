{"name":"strictConvexOn_pow","module":"Mathlib.Analysis.Convex.SpecificFunctions.Deriv","initialProofState":"n : Nat\nhn : LE.le 2 n\n⊢ StrictConvexOn Real (Set.Ici 0) fun x => HPow.hPow x n","decl":"/-- `x^n`, `n : ℕ` is strictly convex on `[0, +∞)` for all `n` greater than `2`. -/\ntheorem strictConvexOn_pow {n : ℕ} (hn : 2 ≤ n) : StrictConvexOn ℝ (Ici 0) fun x : ℝ => x ^ n := by\n  apply StrictMonoOn.strictConvexOn_of_deriv (convex_Ici _) (continuousOn_pow _)\n  rw [deriv_pow', interior_Ici]\n  exact fun x (hx : 0 < x) y _ hxy => mul_lt_mul_of_pos_left\n    (pow_lt_pow_left₀ hxy hx.le <| Nat.sub_ne_zero_of_lt hn) (by positivity)\n\n"}
{"name":"Even.strictConvexOn_pow","module":"Mathlib.Analysis.Convex.SpecificFunctions.Deriv","initialProofState":"n : Nat\nhn : Even n\nh : Ne n 0\n⊢ StrictConvexOn Real Set.univ fun x => HPow.hPow x n","decl":"/-- `x^n`, `n : ℕ` is strictly convex on the whole real line whenever `n ≠ 0` is even. -/\ntheorem Even.strictConvexOn_pow {n : ℕ} (hn : Even n) (h : n ≠ 0) :\n    StrictConvexOn ℝ Set.univ fun x : ℝ => x ^ n := by\n  apply StrictMono.strictConvexOn_univ_of_deriv (continuous_pow n)\n  rw [deriv_pow']\n  replace h := Nat.pos_of_ne_zero h\n  exact StrictMono.const_mul (Odd.strictMono_pow <| Nat.Even.sub_odd h hn <| Nat.odd_iff.2 rfl)\n    (Nat.cast_pos.2 h)\n\n"}
{"name":"Finset.prod_nonneg_of_card_nonpos_even","module":"Mathlib.Analysis.Convex.SpecificFunctions.Deriv","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedCommRing β\nf : α → β\ninst✝ : DecidablePred fun x => LE.le (f x) 0\ns : Finset α\nh0 : Even (Finset.filter (fun x => LE.le (f x) 0) s).card\n⊢ LE.le 0 (s.prod fun x => f x)","decl":"theorem Finset.prod_nonneg_of_card_nonpos_even {α β : Type*} [LinearOrderedCommRing β] {f : α → β}\n    [DecidablePred fun x => f x ≤ 0] {s : Finset α} (h0 : Even (s.filter fun x => f x ≤ 0).card) :\n    0 ≤ ∏ x ∈ s, f x :=\n  calc\n    0 ≤ ∏ x ∈ s, (if f x ≤ 0 then (-1 : β) else 1) * f x :=\n      Finset.prod_nonneg fun x _ => by\n        split_ifs with hx\n        · simp [hx]\n        simp? at hx ⊢ says simp only [not_le, one_mul] at hx ⊢\n        exact le_of_lt hx\n    _ = _ := by\n      rw [Finset.prod_mul_distrib, Finset.prod_ite, Finset.prod_const_one, mul_one,\n        Finset.prod_const, neg_one_pow_eq_pow_mod_two, Nat.even_iff.1 h0, pow_zero, one_mul]\n\n"}
{"name":"int_prod_range_nonneg","module":"Mathlib.Analysis.Convex.SpecificFunctions.Deriv","initialProofState":"m : Int\nn : Nat\nhn : Even n\n⊢ LE.le 0 ((Finset.range n).prod fun k => HSub.hSub m ↑k)","decl":"theorem int_prod_range_nonneg (m : ℤ) (n : ℕ) (hn : Even n) :\n    0 ≤ ∏ k ∈ Finset.range n, (m - k) := by\n  rcases hn with ⟨n, rfl⟩\n  induction n with\n  | zero => simp\n  | succ n ihn =>\n    rw [← two_mul] at ihn\n    rw [← two_mul, mul_add, mul_one, ← one_add_one_eq_two, ← add_assoc,\n      Finset.prod_range_succ, Finset.prod_range_succ, mul_assoc]\n    refine mul_nonneg ihn ?_; generalize (1 + 1) * n = k\n    rcases le_or_lt m k with hmk | hmk\n    · have : m ≤ k + 1 := hmk.trans (lt_add_one (k : ℤ)).le\n      convert mul_nonneg_of_nonpos_of_nonpos (sub_nonpos_of_le hmk) _\n      convert sub_nonpos_of_le this\n    · exact mul_nonneg (sub_nonneg_of_le hmk.le) (sub_nonneg_of_le hmk)\n\n"}
{"name":"int_prod_range_pos","module":"Mathlib.Analysis.Convex.SpecificFunctions.Deriv","initialProofState":"m : Int\nn : Nat\nhn : Even n\nhm : Not (Membership.mem (Set.Ico 0 ↑n) m)\n⊢ LT.lt 0 ((Finset.range n).prod fun k => HSub.hSub m ↑k)","decl":"theorem int_prod_range_pos {m : ℤ} {n : ℕ} (hn : Even n) (hm : m ∉ Ico (0 : ℤ) n) :\n    0 < ∏ k ∈ Finset.range n, (m - k) := by\n  refine (int_prod_range_nonneg m n hn).lt_of_ne fun h => hm ?_\n  rw [eq_comm, Finset.prod_eq_zero_iff] at h\n  obtain ⟨a, ha, h⟩ := h\n  rw [sub_eq_zero.1 h]\n  exact ⟨Int.ofNat_zero_le _, Int.ofNat_lt.2 <| Finset.mem_range.1 ha⟩\n\n"}
{"name":"strictConvexOn_zpow","module":"Mathlib.Analysis.Convex.SpecificFunctions.Deriv","initialProofState":"m : Int\nhm₀ : Ne m 0\nhm₁ : Ne m 1\n⊢ StrictConvexOn Real (Set.Ioi 0) fun x => HPow.hPow x m","decl":"/-- `x^m`, `m : ℤ` is convex on `(0, +∞)` for all `m` except `0` and `1`. -/\ntheorem strictConvexOn_zpow {m : ℤ} (hm₀ : m ≠ 0) (hm₁ : m ≠ 1) :\n    StrictConvexOn ℝ (Ioi 0) fun x : ℝ => x ^ m := by\n  apply strictConvexOn_of_deriv2_pos' (convex_Ioi 0)\n  · exact (continuousOn_zpow₀ m).mono fun x hx => ne_of_gt hx\n  intro x hx\n  rw [mem_Ioi] at hx\n  rw [iter_deriv_zpow]\n  refine mul_pos ?_ (zpow_pos hx _)\n  norm_cast\n  refine int_prod_range_pos (by decide) fun hm => ?_\n  rw [← Finset.coe_Ico] at hm\n  norm_cast at hm\n  fin_cases hm <;> simp_all\n\n"}
{"name":"hasDerivAt_sqrt_mul_log","module":"Mathlib.Analysis.Convex.SpecificFunctions.Deriv","initialProofState":"x : Real\nhx : Ne x 0\n⊢ HasDerivAt (fun x => HMul.hMul x.sqrt (Real.log x)) (HDiv.hDiv (HAdd.hAdd 2 (Real.log x)) (HMul.hMul 2 x.sqrt)) x","decl":"theorem hasDerivAt_sqrt_mul_log {x : ℝ} (hx : x ≠ 0) :\n    HasDerivAt (fun x => √x * log x) ((2 + log x) / (2 * √x)) x := by\n  convert (hasDerivAt_sqrt hx).mul (hasDerivAt_log hx) using 1\n  rw [add_div, div_mul_cancel_left₀ two_ne_zero, ← div_eq_mul_inv, sqrt_div_self', add_comm,\n    one_div, one_div, ← div_eq_inv_mul]\n\n"}
{"name":"deriv_sqrt_mul_log","module":"Mathlib.Analysis.Convex.SpecificFunctions.Deriv","initialProofState":"x : Real\n⊢ Eq (deriv (fun x => HMul.hMul x.sqrt (Real.log x)) x) (HDiv.hDiv (HAdd.hAdd 2 (Real.log x)) (HMul.hMul 2 x.sqrt))","decl":"theorem deriv_sqrt_mul_log (x : ℝ) :\n    deriv (fun x => √x * log x) x = (2 + log x) / (2 * √x) := by\n  cases' lt_or_le 0 x with hx hx\n  · exact (hasDerivAt_sqrt_mul_log hx.ne').deriv\n  · rw [sqrt_eq_zero_of_nonpos hx, mul_zero, div_zero]\n    refine HasDerivWithinAt.deriv_eq_zero ?_ (uniqueDiffOn_Iic 0 x hx)\n    refine (hasDerivWithinAt_const x _ 0).congr_of_mem (fun x hx => ?_) hx\n    rw [sqrt_eq_zero_of_nonpos hx, zero_mul]\n\n"}
{"name":"deriv_sqrt_mul_log'","module":"Mathlib.Analysis.Convex.SpecificFunctions.Deriv","initialProofState":"⊢ Eq (deriv fun x => HMul.hMul x.sqrt (Real.log x)) fun x => HDiv.hDiv (HAdd.hAdd 2 (Real.log x)) (HMul.hMul 2 x.sqrt)","decl":"theorem deriv_sqrt_mul_log' :\n    (deriv fun x => √x * log x) = fun x => (2 + log x) / (2 * √x) :=\n  funext deriv_sqrt_mul_log\n\n"}
{"name":"deriv2_sqrt_mul_log","module":"Mathlib.Analysis.Convex.SpecificFunctions.Deriv","initialProofState":"x : Real\n⊢ Eq (Nat.iterate deriv 2 (fun x => HMul.hMul x.sqrt (Real.log x)) x) (HDiv.hDiv (Neg.neg (Real.log x)) (HMul.hMul 4 (HPow.hPow x.sqrt 3)))","decl":"theorem deriv2_sqrt_mul_log (x : ℝ) :\n    deriv^[2] (fun x => √x * log x) x = -log x / (4 * √x ^ 3) := by\n  simp only [Nat.iterate, deriv_sqrt_mul_log']\n  rcases le_or_lt x 0 with hx | hx\n  · rw [sqrt_eq_zero_of_nonpos hx, zero_pow three_ne_zero, mul_zero, div_zero]\n    refine HasDerivWithinAt.deriv_eq_zero ?_ (uniqueDiffOn_Iic 0 x hx)\n    refine (hasDerivWithinAt_const _ _ 0).congr_of_mem (fun x hx => ?_) hx\n    rw [sqrt_eq_zero_of_nonpos hx, mul_zero, div_zero]\n  · have h₀ : √x ≠ 0 := sqrt_ne_zero'.2 hx\n    convert (((hasDerivAt_log hx.ne').const_add 2).div ((hasDerivAt_sqrt hx.ne').const_mul 2) <|\n      mul_ne_zero two_ne_zero h₀).deriv using 1\n    nth_rw 3 [← mul_self_sqrt hx.le]\n    generalize √x = sqx at h₀ -- else field_simp rewrites sqrt x * sqrt x back to x\n    field_simp\n    ring\n\n"}
{"name":"strictConcaveOn_sqrt_mul_log_Ioi","module":"Mathlib.Analysis.Convex.SpecificFunctions.Deriv","initialProofState":"⊢ StrictConcaveOn Real (Set.Ioi 1) fun x => HMul.hMul x.sqrt (Real.log x)","decl":"theorem strictConcaveOn_sqrt_mul_log_Ioi :\n    StrictConcaveOn ℝ (Set.Ioi 1) fun x => √x * log x := by\n  apply strictConcaveOn_of_deriv2_neg' (convex_Ioi 1) _ fun x hx => ?_\n  · exact continuous_sqrt.continuousOn.mul\n      (continuousOn_log.mono fun x hx => ne_of_gt (zero_lt_one.trans hx))\n  · rw [deriv2_sqrt_mul_log x]\n    exact div_neg_of_neg_of_pos (neg_neg_of_pos (log_pos hx))\n      (mul_pos four_pos (pow_pos (sqrt_pos.mpr (zero_lt_one.trans hx)) 3))\n\n"}
{"name":"strictConcaveOn_sin_Icc","module":"Mathlib.Analysis.Convex.SpecificFunctions.Deriv","initialProofState":"⊢ StrictConcaveOn Real (Set.Icc 0 Real.pi) Real.sin","decl":"theorem strictConcaveOn_sin_Icc : StrictConcaveOn ℝ (Icc 0 π) sin := by\n  apply strictConcaveOn_of_deriv2_neg (convex_Icc _ _) continuousOn_sin fun x hx => ?_\n  rw [interior_Icc] at hx\n  simp [sin_pos_of_mem_Ioo hx]\n\n"}
{"name":"strictConcaveOn_cos_Icc","module":"Mathlib.Analysis.Convex.SpecificFunctions.Deriv","initialProofState":"⊢ StrictConcaveOn Real (Set.Icc (Neg.neg (HDiv.hDiv Real.pi 2)) (HDiv.hDiv Real.pi 2)) Real.cos","decl":"theorem strictConcaveOn_cos_Icc : StrictConcaveOn ℝ (Icc (-(π / 2)) (π / 2)) cos := by\n  apply strictConcaveOn_of_deriv2_neg (convex_Icc _ _) continuousOn_cos fun x hx => ?_\n  rw [interior_Icc] at hx\n  simp [cos_pos_of_mem_Ioo hx]\n"}
