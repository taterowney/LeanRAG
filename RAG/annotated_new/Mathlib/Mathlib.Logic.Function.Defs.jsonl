{"name":"Function.flip_def","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nφ : Sort u₃\nf : α → β → φ\n⊢ Eq (flip f) fun b a => f a b","decl":"lemma flip_def {f : α → β → φ} : flip f = fun b a => f a b := rfl\n\n"}
{"name":"Function.swap_def","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nφ : α → β → Sort u₃\nf : (x : α) → (y : β) → φ x y\n⊢ Eq (Function.swap f) fun y x => f x y","decl":"theorem swap_def {φ : α → β → Sort u₃} (f : ∀ x y, φ x y) : swap f = fun y x => f x y := rfl\n\n-- Porting note: removed, it was never used\n-- notation f \" -[\" op \"]- \" g => combine f op g\n\n"}
{"name":"Function.id_comp","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nf : α → β\n⊢ Eq (Function.comp id f) f","decl":"@[simp, mfld_simps]\ntheorem id_comp (f : α → β) : id ∘ f = f := rfl\n\n"}
{"name":"Function.comp_id","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nf : α → β\n⊢ Eq (Function.comp f id) f","decl":"@[simp, mfld_simps]\ntheorem comp_id (f : α → β) : f ∘ id = f := rfl\n\n"}
{"name":"Function.comp_assoc","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nφ : Sort u₃\nδ : Sort u₄\nf : φ → δ\ng : β → φ\nh : α → β\n⊢ Eq (Function.comp (Function.comp f g) h) (Function.comp f (Function.comp g h))","decl":"theorem comp_assoc (f : φ → δ) (g : β → φ) (h : α → β) : (f ∘ g) ∘ h = f ∘ g ∘ h :=\n  rfl\n"}
{"name":"Function.comp.assoc","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nφ : Sort u₃\nδ : Sort u₄\nf : φ → δ\ng : β → φ\nh : α → β\n⊢ Eq (Function.comp (Function.comp f g) h) (Function.comp f (Function.comp g h))","decl":"@[deprecated (since := \"2024-09-24\")] alias comp.assoc := comp_assoc\n\n"}
{"name":"Function.Injective.comp","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nφ : Sort u₃\ng : β → φ\nf : α → β\nhg : Function.Injective g\nhf : Function.Injective f\n⊢ Function.Injective (Function.comp g f)","decl":"theorem Injective.comp {g : β → φ} {f : α → β} (hg : Injective g) (hf : Injective f) :\n    Injective (g ∘ f) := fun _a₁ _a₂ => fun h => hf (hg h)\n\n"}
{"name":"Function.Surjective.comp","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nφ : Sort u₃\ng : β → φ\nf : α → β\nhg : Function.Surjective g\nhf : Function.Surjective f\n⊢ Function.Surjective (Function.comp g f)","decl":"theorem Surjective.comp {g : β → φ} {f : α → β} (hg : Surjective g) (hf : Surjective f) :\n    Surjective (g ∘ f) := fun c : φ =>\n  Exists.elim (hg c) fun b hb =>\n    Exists.elim (hf b) fun a ha =>\n      Exists.intro a (show g (f a) = c from Eq.trans (congr_arg g ha) hb)\n\n"}
{"name":"Function.Bijective.comp","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nφ : Sort u₃\ng : β → φ\nf : α → β\na✝¹ : Function.Bijective g\na✝ : Function.Bijective f\n⊢ Function.Bijective (Function.comp g f)","decl":"theorem Bijective.comp {g : β → φ} {f : α → β} : Bijective g → Bijective f → Bijective (g ∘ f)\n  | ⟨h_ginj, h_gsurj⟩, ⟨h_finj, h_fsurj⟩ => ⟨h_ginj.comp h_finj, h_gsurj.comp h_fsurj⟩\n\n"}
{"name":"Function.LeftInverse.injective","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\ng : β → α\nf : α → β\na✝ : Function.LeftInverse g f\n⊢ Function.Injective f","decl":"theorem LeftInverse.injective {g : β → α} {f : α → β} : LeftInverse g f → Injective f :=\n  fun h a b faeqfb =>\n  calc\n    a = g (f a) := (h a).symm\n    _ = g (f b) := congr_arg g faeqfb\n    _ = b := h b\n\n"}
{"name":"Function.HasLeftInverse.injective","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nf : α → β\na✝ : Function.HasLeftInverse f\n⊢ Function.Injective f","decl":"theorem HasLeftInverse.injective {f : α → β} : HasLeftInverse f → Injective f := fun h =>\n  Exists.elim h fun _finv inv => inv.injective\n\n"}
{"name":"Function.rightInverse_of_injective_of_leftInverse","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nf : α → β\ng : β → α\ninjf : Function.Injective f\nlfg : Function.LeftInverse f g\n⊢ Function.RightInverse f g","decl":"theorem rightInverse_of_injective_of_leftInverse {f : α → β} {g : β → α} (injf : Injective f)\n    (lfg : LeftInverse f g) : RightInverse f g := fun x =>\n  have h : f (g (f x)) = f x := lfg (f x)\n  injf h\n\n"}
{"name":"Function.RightInverse.surjective","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nf : α → β\ng : β → α\nh : Function.RightInverse g f\n⊢ Function.Surjective f","decl":"theorem RightInverse.surjective {f : α → β} {g : β → α} (h : RightInverse g f) : Surjective f :=\n  fun y => ⟨g y, h y⟩\n\n"}
{"name":"Function.HasRightInverse.surjective","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nf : α → β\na✝ : Function.HasRightInverse f\n⊢ Function.Surjective f","decl":"theorem HasRightInverse.surjective {f : α → β} : HasRightInverse f → Surjective f\n  | ⟨_finv, inv⟩ => inv.surjective\n\n"}
{"name":"Function.leftInverse_of_surjective_of_rightInverse","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\nβ : Sort u₂\nf : α → β\ng : β → α\nsurjf : Function.Surjective f\nrfg : Function.RightInverse f g\n⊢ Function.LeftInverse f g","decl":"theorem leftInverse_of_surjective_of_rightInverse {f : α → β} {g : β → α} (surjf : Surjective f)\n    (rfg : RightInverse f g) : LeftInverse f g := fun y =>\n  Exists.elim (surjf y) fun x hx =>\n    calc\n      f (g y) = f (g (f x)) := hx ▸ rfl\n      _ = f x := Eq.symm (rfg x) ▸ rfl\n      _ = y := hx\n\n"}
{"name":"Function.injective_id","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\n⊢ Function.Injective id","decl":"theorem injective_id : Injective (@id α) := fun _a₁ _a₂ h => h\n\n"}
{"name":"Function.surjective_id","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\n⊢ Function.Surjective id","decl":"theorem surjective_id : Surjective (@id α) := fun a => ⟨a, rfl⟩\n\n"}
{"name":"Function.bijective_id","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Sort u₁\n⊢ Function.Bijective id","decl":"theorem bijective_id : Bijective (@id α) :=\n  ⟨injective_id, surjective_id⟩\n\n"}
{"name":"Function.LeftInverse.id","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Type u₁\nβ : Type u₂\ng : β → α\nf : α → β\nh : Function.LeftInverse g f\n⊢ Eq (Function.comp g f) id","decl":"protected theorem LeftInverse.id {g : β → α} {f : α → β} (h : LeftInverse g f) : g ∘ f = id :=\n  funext h\n\n"}
{"name":"Function.RightInverse.id","module":"Mathlib.Logic.Function.Defs","initialProofState":"α : Type u₁\nβ : Type u₂\ng : β → α\nf : α → β\nh : Function.RightInverse g f\n⊢ Eq (Function.comp f g) id","decl":"protected theorem RightInverse.id {g : β → α} {f : α → β} (h : RightInverse g f) : f ∘ g = id :=\n  funext h\n\n"}
{"name":"Pi.map_apply","module":"Mathlib.Logic.Function.Defs","initialProofState":"ι : Sort u_1\nα : ι → Sort u_2\nβ : ι → Sort u_3\nf : (i : ι) → α i → β i\na : (i : ι) → α i\ni : ι\n⊢ Eq (Pi.map f a i) (f i (a i))","decl":"@[simp]\nlemma map_apply (f : ∀ i, α i → β i) (a : ∀ i, α i) (i : ι) : Pi.map f a i = f i (a i) := rfl\n\n"}
