{"name":"MeasureTheory.measurePreserving_prod_add","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ν.IsAddLeftInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.1, snd := HAdd.hAdd z.1 z.2 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The multiplicative shear mapping `(x, y) ↦ (x, xy)` preserves the measure `μ × ν`.\nThis condition is part of the definition of a measurable group in [Halmos, §59].\nThere, the map in this lemma is called `S`. -/\n@[to_additive measurePreserving_prod_add\n\" The shear mapping `(x, y) ↦ (x, x + y)` preserves the measure `μ × ν`. \"]\ntheorem measurePreserving_prod_mul [IsMulLeftInvariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1, z.1 * z.2)) (μ.prod ν) (μ.prod ν) :=\n  (MeasurePreserving.id μ).skew_product measurable_mul <|\n    Filter.Eventually.of_forall <| map_mul_left_eq_self ν\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_mul","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ν.IsMulLeftInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.1, snd := HMul.hMul z.1 z.2 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The multiplicative shear mapping `(x, y) ↦ (x, xy)` preserves the measure `μ × ν`.\nThis condition is part of the definition of a measurable group in [Halmos, §59].\nThere, the map in this lemma is called `S`. -/\n@[to_additive measurePreserving_prod_add\n\" The shear mapping `(x, y) ↦ (x, x + y)` preserves the measure `μ × ν`. \"]\ntheorem measurePreserving_prod_mul [IsMulLeftInvariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1, z.1 * z.2)) (μ.prod ν) (μ.prod ν) :=\n  (MeasurePreserving.id μ).skew_product measurable_mul <|\n    Filter.Eventually.of_forall <| map_mul_left_eq_self ν\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_add_swap","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.IsAddLeftInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.2, snd := HAdd.hAdd z.2 z.1 }) (μ.prod ν) (ν.prod μ)","decl":"/-- The map `(x, y) ↦ (y, yx)` sends the measure `μ × ν` to `ν × μ`.\nThis is the map `SR` in [Halmos, §59].\n`S` is the map `(x, y) ↦ (x, xy)` and `R` is `Prod.swap`. -/\n@[to_additive measurePreserving_prod_add_swap\n\" The map `(x, y) ↦ (y, y + x)` sends the measure `μ × ν` to `ν × μ`. \"]\ntheorem measurePreserving_prod_mul_swap [IsMulLeftInvariant μ] :\n    MeasurePreserving (fun z : G × G => (z.2, z.2 * z.1)) (μ.prod ν) (ν.prod μ) :=\n  (measurePreserving_prod_mul ν μ).comp measurePreserving_swap\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_mul_swap","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.IsMulLeftInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.2, snd := HMul.hMul z.2 z.1 }) (μ.prod ν) (ν.prod μ)","decl":"/-- The map `(x, y) ↦ (y, yx)` sends the measure `μ × ν` to `ν × μ`.\nThis is the map `SR` in [Halmos, §59].\n`S` is the map `(x, y) ↦ (x, xy)` and `R` is `Prod.swap`. -/\n@[to_additive measurePreserving_prod_add_swap\n\" The map `(x, y) ↦ (y, y + x)` sends the measure `μ × ν` to `ν × μ`. \"]\ntheorem measurePreserving_prod_mul_swap [IsMulLeftInvariant μ] :\n    MeasurePreserving (fun z : G × G => (z.2, z.2 * z.1)) (μ.prod ν) (ν.prod μ) :=\n  (measurePreserving_prod_mul ν μ).comp measurePreserving_swap\n\n"}
{"name":"MeasureTheory.measurable_measure_add_right","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝ : MeasureTheory.SFinite μ\ns : Set G\nhs : MeasurableSet s\n⊢ Measurable fun x => μ (Set.preimage (fun y => HAdd.hAdd y x) s)","decl":"@[to_additive]\ntheorem measurable_measure_mul_right (hs : MeasurableSet s) :\n    Measurable fun x => μ ((fun y => y * x) ⁻¹' s) := by\n  suffices\n    Measurable fun y =>\n      μ ((fun x => (x, y)) ⁻¹' ((fun z : G × G => ((1 : G), z.1 * z.2)) ⁻¹' univ ×ˢ s))\n    by convert this using 1; ext1 x; congr 1 with y : 1; simp\n  apply measurable_measure_prod_mk_right\n  apply measurable_const.prod_mk measurable_mul (MeasurableSet.univ.prod hs)\n  infer_instance\n\n"}
{"name":"MeasureTheory.measurable_measure_mul_right","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝³ : MeasurableSpace G\ninst✝² : Group G\ninst✝¹ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝ : MeasureTheory.SFinite μ\ns : Set G\nhs : MeasurableSet s\n⊢ Measurable fun x => μ (Set.preimage (fun y => HMul.hMul y x) s)","decl":"@[to_additive]\ntheorem measurable_measure_mul_right (hs : MeasurableSet s) :\n    Measurable fun x => μ ((fun y => y * x) ⁻¹' s) := by\n  suffices\n    Measurable fun y =>\n      μ ((fun x => (x, y)) ⁻¹' ((fun z : G × G => ((1 : G), z.1 * z.2)) ⁻¹' univ ×ˢ s))\n    by convert this using 1; ext1 x; congr 1 with y : 1; simp\n  apply measurable_measure_prod_mk_right\n  apply measurable_const.prod_mk measurable_mul (MeasurableSet.univ.prod hs)\n  infer_instance\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_neg_add","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : AddGroup G\ninst✝⁴ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : ν.IsAddLeftInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.1, snd := HAdd.hAdd (Neg.neg z.1) z.2 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The map `(x, y) ↦ (x, x⁻¹y)` is measure-preserving.\nThis is the function `S⁻¹` in [Halmos, §59],\nwhere `S` is the map `(x, y) ↦ (x, xy)`. -/\n@[to_additive measurePreserving_prod_neg_add\n\"The map `(x, y) ↦ (x, - x + y)` is measure-preserving.\"]\ntheorem measurePreserving_prod_inv_mul [IsMulLeftInvariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1, z.1⁻¹ * z.2)) (μ.prod ν) (μ.prod ν) :=\n  (measurePreserving_prod_mul μ ν).symm <| MeasurableEquiv.shearMulRight G\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_inv_mul","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : Group G\ninst✝⁴ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : ν.IsMulLeftInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.1, snd := HMul.hMul (Inv.inv z.1) z.2 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The map `(x, y) ↦ (x, x⁻¹y)` is measure-preserving.\nThis is the function `S⁻¹` in [Halmos, §59],\nwhere `S` is the map `(x, y) ↦ (x, xy)`. -/\n@[to_additive measurePreserving_prod_neg_add\n\"The map `(x, y) ↦ (x, - x + y)` is measure-preserving.\"]\ntheorem measurePreserving_prod_inv_mul [IsMulLeftInvariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1, z.1⁻¹ * z.2)) (μ.prod ν) (μ.prod ν) :=\n  (measurePreserving_prod_mul μ ν).symm <| MeasurableEquiv.shearMulRight G\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_neg_add_swap","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : AddGroup G\ninst✝⁴ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.2, snd := HAdd.hAdd (Neg.neg z.2) z.1 }) (μ.prod ν) (ν.prod μ)","decl":"/-- The map `(x, y) ↦ (y, y⁻¹x)` sends `μ × ν` to `ν × μ`.\nThis is the function `S⁻¹R` in [Halmos, §59],\nwhere `S` is the map `(x, y) ↦ (x, xy)` and `R` is `Prod.swap`. -/\n@[to_additive measurePreserving_prod_neg_add_swap\n\"The map `(x, y) ↦ (y, - y + x)` sends `μ × ν` to `ν × μ`.\"]\ntheorem measurePreserving_prod_inv_mul_swap :\n    MeasurePreserving (fun z : G × G => (z.2, z.2⁻¹ * z.1)) (μ.prod ν) (ν.prod μ) :=\n  (measurePreserving_prod_inv_mul ν μ).comp measurePreserving_swap\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_inv_mul_swap","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : Group G\ninst✝⁴ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.2, snd := HMul.hMul (Inv.inv z.2) z.1 }) (μ.prod ν) (ν.prod μ)","decl":"/-- The map `(x, y) ↦ (y, y⁻¹x)` sends `μ × ν` to `ν × μ`.\nThis is the function `S⁻¹R` in [Halmos, §59],\nwhere `S` is the map `(x, y) ↦ (x, xy)` and `R` is `Prod.swap`. -/\n@[to_additive measurePreserving_prod_neg_add_swap\n\"The map `(x, y) ↦ (y, - y + x)` sends `μ × ν` to `ν × μ`.\"]\ntheorem measurePreserving_prod_inv_mul_swap :\n    MeasurePreserving (fun z : G × G => (z.2, z.2⁻¹ * z.1)) (μ.prod ν) (ν.prod μ) :=\n  (measurePreserving_prod_inv_mul ν μ).comp measurePreserving_swap\n\n"}
{"name":"MeasureTheory.measurePreserving_mul_prod_inv","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Group G\ninst✝⁵ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝⁴ : MeasureTheory.SFinite ν\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasurableInv G\ninst✝¹ : μ.IsMulLeftInvariant\ninst✝ : ν.IsMulLeftInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := HMul.hMul z.2 z.1, snd := Inv.inv z.1 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The map `(x, y) ↦ (yx, x⁻¹)` is measure-preserving.\nThis is the function `S⁻¹RSR` in [Halmos, §59],\nwhere `S` is the map `(x, y) ↦ (x, xy)` and `R` is `Prod.swap`. -/\n@[to_additive measurePreserving_add_prod_neg\n\"The map `(x, y) ↦ (y + x, - x)` is measure-preserving.\"]\ntheorem measurePreserving_mul_prod_inv [IsMulLeftInvariant ν] :\n    MeasurePreserving (fun z : G × G => (z.2 * z.1, z.1⁻¹)) (μ.prod ν) (μ.prod ν) := by\n  convert (measurePreserving_prod_inv_mul_swap ν μ).comp (measurePreserving_prod_mul_swap μ ν)\n    using 1\n  ext1 ⟨x, y⟩\n  simp_rw [Function.comp_apply, mul_inv_rev, inv_mul_cancel_right]\n\n"}
{"name":"MeasureTheory.measurePreserving_add_prod_neg","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝⁴ : MeasureTheory.SFinite ν\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasurableNeg G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : ν.IsAddLeftInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := HAdd.hAdd z.2 z.1, snd := Neg.neg z.1 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The map `(x, y) ↦ (yx, x⁻¹)` is measure-preserving.\nThis is the function `S⁻¹RSR` in [Halmos, §59],\nwhere `S` is the map `(x, y) ↦ (x, xy)` and `R` is `Prod.swap`. -/\n@[to_additive measurePreserving_add_prod_neg\n\"The map `(x, y) ↦ (y + x, - x)` is measure-preserving.\"]\ntheorem measurePreserving_mul_prod_inv [IsMulLeftInvariant ν] :\n    MeasurePreserving (fun z : G × G => (z.2 * z.1, z.1⁻¹)) (μ.prod ν) (μ.prod ν) := by\n  convert (measurePreserving_prod_inv_mul_swap ν μ).comp (measurePreserving_prod_mul_swap μ ν)\n    using 1\n  ext1 ⟨x, y⟩\n  simp_rw [Function.comp_apply, mul_inv_rev, inv_mul_cancel_right]\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_neg","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving Neg.neg μ μ","decl":"@[to_additive]\ntheorem quasiMeasurePreserving_inv : QuasiMeasurePreserving (Inv.inv : G → G) μ μ := by\n  refine ⟨measurable_inv, AbsolutelyContinuous.mk fun s hsm hμs => ?_⟩\n  rw [map_apply measurable_inv hsm, inv_preimage]\n  have hf : Measurable fun z : G × G => (z.2 * z.1, z.1⁻¹) :=\n    (measurable_snd.mul measurable_fst).prod_mk measurable_fst.inv\n  suffices map (fun z : G × G => (z.2 * z.1, z.1⁻¹)) (μ.prod μ) (s⁻¹ ×ˢ s⁻¹) = 0 by\n    simpa only [(measurePreserving_mul_prod_inv μ μ).map_eq, prod_prod, mul_eq_zero (M₀ := ℝ≥0∞),\n      or_self_iff] using this\n  have hsm' : MeasurableSet (s⁻¹ ×ˢ s⁻¹) := hsm.inv.prod hsm.inv\n  simp_rw [map_apply hf hsm', prod_apply_symm (μ := μ) (ν := μ) (hf hsm'), preimage_preimage,\n    mk_preimage_prod, inv_preimage, inv_inv, measure_mono_null inter_subset_right hμs,\n    lintegral_zero]\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_inv","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving Inv.inv μ μ","decl":"@[to_additive]\ntheorem quasiMeasurePreserving_inv : QuasiMeasurePreserving (Inv.inv : G → G) μ μ := by\n  refine ⟨measurable_inv, AbsolutelyContinuous.mk fun s hsm hμs => ?_⟩\n  rw [map_apply measurable_inv hsm, inv_preimage]\n  have hf : Measurable fun z : G × G => (z.2 * z.1, z.1⁻¹) :=\n    (measurable_snd.mul measurable_fst).prod_mk measurable_fst.inv\n  suffices map (fun z : G × G => (z.2 * z.1, z.1⁻¹)) (μ.prod μ) (s⁻¹ ×ˢ s⁻¹) = 0 by\n    simpa only [(measurePreserving_mul_prod_inv μ μ).map_eq, prod_prod, mul_eq_zero (M₀ := ℝ≥0∞),\n      or_self_iff] using this\n  have hsm' : MeasurableSet (s⁻¹ ×ˢ s⁻¹) := hsm.inv.prod hsm.inv\n  simp_rw [map_apply hf hsm', prod_apply_symm (μ := μ) (ν := μ) (hf hsm'), preimage_preimage,\n    mk_preimage_prod, inv_preimage, inv_inv, measure_mono_null inter_subset_right hμs,\n    lintegral_zero]\n\n"}
{"name":"MeasureTheory.measure_neg_null","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ns : Set G\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\n⊢ Iff (Eq (μ (Neg.neg s)) 0) (Eq (μ s) 0)","decl":"@[to_additive (attr := simp)]\ntheorem measure_inv_null : μ s⁻¹ = 0 ↔ μ s = 0 := by\n  refine ⟨fun hs => ?_, (quasiMeasurePreserving_inv μ).preimage_null⟩\n  rw [← inv_inv s]\n  exact (quasiMeasurePreserving_inv μ).preimage_null hs\n\n"}
{"name":"MeasureTheory.measure_inv_null","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ns : Set G\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\n⊢ Iff (Eq (μ (Inv.inv s)) 0) (Eq (μ s) 0)","decl":"@[to_additive (attr := simp)]\ntheorem measure_inv_null : μ s⁻¹ = 0 ↔ μ s = 0 := by\n  refine ⟨fun hs => ?_, (quasiMeasurePreserving_inv μ).preimage_null⟩\n  rw [← inv_inv s]\n  exact (quasiMeasurePreserving_inv μ).preimage_null hs\n\n"}
{"name":"MeasureTheory.neg_ae","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\n⊢ Eq (Neg.neg (MeasureTheory.ae μ)) (MeasureTheory.ae μ)","decl":"@[to_additive (attr := simp)]\ntheorem inv_ae : (ae μ)⁻¹ = ae μ := by\n  refine le_antisymm (quasiMeasurePreserving_inv μ).tendsto_ae ?_\n  nth_rewrite 1 [← inv_inv (ae μ)]\n  exact Filter.map_mono (quasiMeasurePreserving_inv μ).tendsto_ae\n\n"}
{"name":"MeasureTheory.inv_ae","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\n⊢ Eq (Inv.inv (MeasureTheory.ae μ)) (MeasureTheory.ae μ)","decl":"@[to_additive (attr := simp)]\ntheorem inv_ae : (ae μ)⁻¹ = ae μ := by\n  refine le_antisymm (quasiMeasurePreserving_inv μ).tendsto_ae ?_\n  nth_rewrite 1 [← inv_inv (ae μ)]\n  exact Filter.map_mono (quasiMeasurePreserving_inv μ).tendsto_ae\n\n"}
{"name":"MeasureTheory.eventuallyConst_inv_set_ae","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ns : Set G\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\n⊢ Iff (Filter.EventuallyConst (Inv.inv s) (MeasureTheory.ae μ)) (Filter.EventuallyConst s (MeasureTheory.ae μ))","decl":"@[to_additive (attr := simp)]\ntheorem eventuallyConst_inv_set_ae :\n    EventuallyConst (s⁻¹ : Set G) (ae μ) ↔ EventuallyConst s (ae μ) := by\n  rw [← inv_preimage, eventuallyConst_preimage, Filter.map_inv, inv_ae]\n\n"}
{"name":"MeasureTheory.eventuallyConst_neg_set_ae","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ns : Set G\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\n⊢ Iff (Filter.EventuallyConst (Neg.neg s) (MeasureTheory.ae μ)) (Filter.EventuallyConst s (MeasureTheory.ae μ))","decl":"@[to_additive (attr := simp)]\ntheorem eventuallyConst_inv_set_ae :\n    EventuallyConst (s⁻¹ : Set G) (ae μ) ↔ EventuallyConst s (ae μ) := by\n  rw [← inv_preimage, eventuallyConst_preimage, Filter.map_inv, inv_ae]\n\n"}
{"name":"MeasureTheory.neg_absolutelyContinuous","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\n⊢ μ.neg.AbsolutelyContinuous μ","decl":"@[to_additive]\ntheorem inv_absolutelyContinuous : μ.inv ≪ μ :=\n  (quasiMeasurePreserving_inv μ).absolutelyContinuous\n\n"}
{"name":"MeasureTheory.inv_absolutelyContinuous","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\n⊢ μ.inv.AbsolutelyContinuous μ","decl":"@[to_additive]\ntheorem inv_absolutelyContinuous : μ.inv ≪ μ :=\n  (quasiMeasurePreserving_inv μ).absolutelyContinuous\n\n"}
{"name":"MeasureTheory.absolutelyContinuous_inv","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\n⊢ μ.AbsolutelyContinuous μ.inv","decl":"@[to_additive]\ntheorem absolutelyContinuous_inv : μ ≪ μ.inv := by\n  refine AbsolutelyContinuous.mk fun s _ => ?_\n  simp_rw [inv_apply μ s, measure_inv_null, imp_self]\n\n"}
{"name":"MeasureTheory.absolutelyContinuous_neg","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\n⊢ μ.AbsolutelyContinuous μ.neg","decl":"@[to_additive]\ntheorem absolutelyContinuous_inv : μ ≪ μ.inv := by\n  refine AbsolutelyContinuous.mk fun s _ => ?_\n  simp_rw [inv_apply μ s, measure_inv_null, imp_self]\n\n"}
{"name":"MeasureTheory.lintegral_lintegral_mul_inv","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Group G\ninst✝⁵ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝⁴ : MeasureTheory.SFinite ν\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasurableInv G\ninst✝¹ : μ.IsMulLeftInvariant\ninst✝ : ν.IsMulLeftInvariant\nf : G → G → ENNReal\nhf : AEMeasurable (Function.uncurry f) (μ.prod ν)\n⊢ Eq (MeasureTheory.lintegral μ fun x => MeasureTheory.lintegral ν fun y => f (HMul.hMul y x) (Inv.inv x)) (MeasureTheory.lintegral μ fun x => MeasureTheory.lintegral ν fun y => f x y)","decl":"@[to_additive]\ntheorem lintegral_lintegral_mul_inv [IsMulLeftInvariant ν] (f : G → G → ℝ≥0∞)\n    (hf : AEMeasurable (uncurry f) (μ.prod ν)) :\n    (∫⁻ x, ∫⁻ y, f (y * x) x⁻¹ ∂ν ∂μ) = ∫⁻ x, ∫⁻ y, f x y ∂ν ∂μ := by\n  have h : Measurable fun z : G × G => (z.2 * z.1, z.1⁻¹) :=\n    (measurable_snd.mul measurable_fst).prod_mk measurable_fst.inv\n  have h2f : AEMeasurable (uncurry fun x y => f (y * x) x⁻¹) (μ.prod ν) :=\n    hf.comp_quasiMeasurePreserving (measurePreserving_mul_prod_inv μ ν).quasiMeasurePreserving\n  simp_rw [lintegral_lintegral h2f, lintegral_lintegral hf]\n  conv_rhs => rw [← (measurePreserving_mul_prod_inv μ ν).map_eq]\n  symm\n  exact\n    lintegral_map' (hf.mono' (measurePreserving_mul_prod_inv μ ν).map_eq.absolutelyContinuous)\n      h.aemeasurable\n\n"}
{"name":"MeasureTheory.lintegral_lintegral_add_neg","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝⁴ : MeasureTheory.SFinite ν\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasurableNeg G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : ν.IsAddLeftInvariant\nf : G → G → ENNReal\nhf : AEMeasurable (Function.uncurry f) (μ.prod ν)\n⊢ Eq (MeasureTheory.lintegral μ fun x => MeasureTheory.lintegral ν fun y => f (HAdd.hAdd y x) (Neg.neg x)) (MeasureTheory.lintegral μ fun x => MeasureTheory.lintegral ν fun y => f x y)","decl":"@[to_additive]\ntheorem lintegral_lintegral_mul_inv [IsMulLeftInvariant ν] (f : G → G → ℝ≥0∞)\n    (hf : AEMeasurable (uncurry f) (μ.prod ν)) :\n    (∫⁻ x, ∫⁻ y, f (y * x) x⁻¹ ∂ν ∂μ) = ∫⁻ x, ∫⁻ y, f x y ∂ν ∂μ := by\n  have h : Measurable fun z : G × G => (z.2 * z.1, z.1⁻¹) :=\n    (measurable_snd.mul measurable_fst).prod_mk measurable_fst.inv\n  have h2f : AEMeasurable (uncurry fun x y => f (y * x) x⁻¹) (μ.prod ν) :=\n    hf.comp_quasiMeasurePreserving (measurePreserving_mul_prod_inv μ ν).quasiMeasurePreserving\n  simp_rw [lintegral_lintegral h2f, lintegral_lintegral hf]\n  conv_rhs => rw [← (measurePreserving_mul_prod_inv μ ν).map_eq]\n  symm\n  exact\n    lintegral_map' (hf.mono' (measurePreserving_mul_prod_inv μ ν).map_eq.absolutelyContinuous)\n      h.aemeasurable\n\n"}
{"name":"MeasureTheory.measure_mul_right_null","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ns : Set G\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\ny : G\n⊢ Iff (Eq (μ (Set.preimage (fun x => HMul.hMul x y) s)) 0) (Eq (μ s) 0)","decl":"@[to_additive]\ntheorem measure_mul_right_null (y : G) : μ ((fun x => x * y) ⁻¹' s) = 0 ↔ μ s = 0 :=\n  calc\n    μ ((fun x => x * y) ⁻¹' s) = 0 ↔ μ ((fun x => y⁻¹ * x) ⁻¹' s⁻¹)⁻¹ = 0 := by\n      simp_rw [← inv_preimage, preimage_preimage, mul_inv_rev, inv_inv]\n    _ ↔ μ s = 0 := by simp only [measure_inv_null μ, measure_preimage_mul]\n\n"}
{"name":"MeasureTheory.measure_add_right_null","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ns : Set G\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\ny : G\n⊢ Iff (Eq (μ (Set.preimage (fun x => HAdd.hAdd x y) s)) 0) (Eq (μ s) 0)","decl":"@[to_additive]\ntheorem measure_mul_right_null (y : G) : μ ((fun x => x * y) ⁻¹' s) = 0 ↔ μ s = 0 :=\n  calc\n    μ ((fun x => x * y) ⁻¹' s) = 0 ↔ μ ((fun x => y⁻¹ * x) ⁻¹' s⁻¹)⁻¹ = 0 := by\n      simp_rw [← inv_preimage, preimage_preimage, mul_inv_rev, inv_inv]\n    _ ↔ μ s = 0 := by simp only [measure_inv_null μ, measure_preimage_mul]\n\n"}
{"name":"MeasureTheory.measure_add_right_ne_zero","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ns : Set G\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\nh2s : Ne (μ s) 0\ny : G\n⊢ Ne (μ (Set.preimage (fun x => HAdd.hAdd x y) s)) 0","decl":"@[to_additive]\ntheorem measure_mul_right_ne_zero (h2s : μ s ≠ 0) (y : G) : μ ((fun x => x * y) ⁻¹' s) ≠ 0 :=\n  (not_congr (measure_mul_right_null μ y)).mpr h2s\n\n"}
{"name":"MeasureTheory.measure_mul_right_ne_zero","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ns : Set G\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\nh2s : Ne (μ s) 0\ny : G\n⊢ Ne (μ (Set.preimage (fun x => HMul.hMul x y) s)) 0","decl":"@[to_additive]\ntheorem measure_mul_right_ne_zero (h2s : μ s ≠ 0) (y : G) : μ ((fun x => x * y) ⁻¹' s) ≠ 0 :=\n  (not_congr (measure_mul_right_null μ y)).mpr h2s\n\n"}
{"name":"MeasureTheory.absolutelyContinuous_map_add_right","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\ng : G\n⊢ μ.AbsolutelyContinuous (MeasureTheory.Measure.map (fun x => HAdd.hAdd x g) μ)","decl":"@[to_additive]\ntheorem absolutelyContinuous_map_mul_right (g : G) : μ ≪ map (· * g) μ := by\n  refine AbsolutelyContinuous.mk fun s hs => ?_\n  rw [map_apply (measurable_mul_const g) hs, measure_mul_right_null]; exact id\n\n"}
{"name":"MeasureTheory.absolutelyContinuous_map_mul_right","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\ng : G\n⊢ μ.AbsolutelyContinuous (MeasureTheory.Measure.map (fun x => HMul.hMul x g) μ)","decl":"@[to_additive]\ntheorem absolutelyContinuous_map_mul_right (g : G) : μ ≪ map (· * g) μ := by\n  refine AbsolutelyContinuous.mk fun s hs => ?_\n  rw [map_apply (measurable_mul_const g) hs, measure_mul_right_null]; exact id\n\n"}
{"name":"MeasureTheory.absolutelyContinuous_map_div_left","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\ng : G\n⊢ μ.AbsolutelyContinuous (MeasureTheory.Measure.map (fun h => HDiv.hDiv g h) μ)","decl":"@[to_additive]\ntheorem absolutelyContinuous_map_div_left (g : G) : μ ≪ map (fun h => g / h) μ := by\n  simp_rw [div_eq_mul_inv]\n  erw [← map_map (measurable_const_mul g) measurable_inv]\n  conv_lhs => rw [← map_mul_left_eq_self μ g]\n  exact (absolutelyContinuous_inv μ).map (measurable_const_mul g)\n\n"}
{"name":"MeasureTheory.absolutelyContinuous_map_sub_left","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\ng : G\n⊢ μ.AbsolutelyContinuous (MeasureTheory.Measure.map (fun h => HSub.hSub g h) μ)","decl":"@[to_additive]\ntheorem absolutelyContinuous_map_div_left (g : G) : μ ≪ map (fun h => g / h) μ := by\n  simp_rw [div_eq_mul_inv]\n  erw [← map_map (measurable_const_mul g) measurable_inv]\n  conv_lhs => rw [← map_mul_left_eq_self μ g]\n  exact (absolutelyContinuous_inv μ).map (measurable_const_mul g)\n\n"}
{"name":"MeasureTheory.measure_add_lintegral_eq","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝⁴ : MeasureTheory.SFinite ν\ninst✝³ : MeasureTheory.SFinite μ\ns : Set G\ninst✝² : MeasurableNeg G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : ν.IsAddLeftInvariant\nsm : MeasurableSet s\nf : G → ENNReal\nhf : Measurable f\n⊢ Eq (HMul.hMul (μ s) (MeasureTheory.lintegral ν fun y => f y)) (MeasureTheory.lintegral μ fun x => HMul.hMul (ν (Set.preimage (fun z => HAdd.hAdd z x) s)) (f (Neg.neg x)))","decl":"/-- This is the computation performed in the proof of [Halmos, §60 Th. A]. -/\n@[to_additive \"This is the computation performed in the proof of [Halmos, §60 Th. A].\"]\ntheorem measure_mul_lintegral_eq [IsMulLeftInvariant ν] (sm : MeasurableSet s) (f : G → ℝ≥0∞)\n    (hf : Measurable f) : (μ s * ∫⁻ y, f y ∂ν) = ∫⁻ x, ν ((fun z => z * x) ⁻¹' s) * f x⁻¹ ∂μ := by\n  rw [← setLIntegral_one, ← lintegral_indicator sm,\n    ← lintegral_lintegral_mul (measurable_const.indicator sm).aemeasurable hf.aemeasurable,\n    ← lintegral_lintegral_mul_inv μ ν]\n  swap\n  · exact (((measurable_const.indicator sm).comp measurable_fst).mul\n      (hf.comp measurable_snd)).aemeasurable\n  have ms :\n    ∀ x : G, Measurable fun y => ((fun z => z * x) ⁻¹' s).indicator (fun _ => (1 : ℝ≥0∞)) y :=\n    fun x => measurable_const.indicator (measurable_mul_const _ sm)\n  have : ∀ x y, s.indicator (fun _ : G => (1 : ℝ≥0∞)) (y * x) =\n      ((fun z => z * x) ⁻¹' s).indicator (fun b : G => 1) y := by\n    intro x y; symm; convert indicator_comp_right (M := ℝ≥0∞) fun y => y * x using 2; ext1; rfl\n  simp_rw [this, lintegral_mul_const _ (ms _), lintegral_indicator (measurable_mul_const _ sm),\n    setLIntegral_one]\n\n"}
{"name":"MeasureTheory.measure_mul_lintegral_eq","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Group G\ninst✝⁵ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝⁴ : MeasureTheory.SFinite ν\ninst✝³ : MeasureTheory.SFinite μ\ns : Set G\ninst✝² : MeasurableInv G\ninst✝¹ : μ.IsMulLeftInvariant\ninst✝ : ν.IsMulLeftInvariant\nsm : MeasurableSet s\nf : G → ENNReal\nhf : Measurable f\n⊢ Eq (HMul.hMul (μ s) (MeasureTheory.lintegral ν fun y => f y)) (MeasureTheory.lintegral μ fun x => HMul.hMul (ν (Set.preimage (fun z => HMul.hMul z x) s)) (f (Inv.inv x)))","decl":"/-- This is the computation performed in the proof of [Halmos, §60 Th. A]. -/\n@[to_additive \"This is the computation performed in the proof of [Halmos, §60 Th. A].\"]\ntheorem measure_mul_lintegral_eq [IsMulLeftInvariant ν] (sm : MeasurableSet s) (f : G → ℝ≥0∞)\n    (hf : Measurable f) : (μ s * ∫⁻ y, f y ∂ν) = ∫⁻ x, ν ((fun z => z * x) ⁻¹' s) * f x⁻¹ ∂μ := by\n  rw [← setLIntegral_one, ← lintegral_indicator sm,\n    ← lintegral_lintegral_mul (measurable_const.indicator sm).aemeasurable hf.aemeasurable,\n    ← lintegral_lintegral_mul_inv μ ν]\n  swap\n  · exact (((measurable_const.indicator sm).comp measurable_fst).mul\n      (hf.comp measurable_snd)).aemeasurable\n  have ms :\n    ∀ x : G, Measurable fun y => ((fun z => z * x) ⁻¹' s).indicator (fun _ => (1 : ℝ≥0∞)) y :=\n    fun x => measurable_const.indicator (measurable_mul_const _ sm)\n  have : ∀ x y, s.indicator (fun _ : G => (1 : ℝ≥0∞)) (y * x) =\n      ((fun z => z * x) ⁻¹' s).indicator (fun b : G => 1) y := by\n    intro x y; symm; convert indicator_comp_right (M := ℝ≥0∞) fun y => y * x using 2; ext1; rfl\n  simp_rw [this, lintegral_mul_const _ (ms _), lintegral_indicator (measurable_mul_const _ sm),\n    setLIntegral_one]\n\n"}
{"name":"MeasureTheory.absolutelyContinuous_of_isAddLeftInvariant","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝⁴ : MeasureTheory.SFinite ν\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasurableNeg G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : ν.IsAddLeftInvariant\nhν : Ne ν 0\n⊢ μ.AbsolutelyContinuous ν","decl":"/-- Any two nonzero left-invariant measures are absolutely continuous w.r.t. each other. -/\n@[to_additive\n\" Any two nonzero left-invariant measures are absolutely continuous w.r.t. each other. \"]\ntheorem absolutelyContinuous_of_isMulLeftInvariant [IsMulLeftInvariant ν] (hν : ν ≠ 0) : μ ≪ ν := by\n  refine AbsolutelyContinuous.mk fun s sm hνs => ?_\n  have h1 := measure_mul_lintegral_eq μ ν sm 1 measurable_one\n  simp_rw [Pi.one_apply, lintegral_one, mul_one, (measure_mul_right_null ν _).mpr hνs,\n    lintegral_zero, mul_eq_zero (M₀ := ℝ≥0∞), measure_univ_eq_zero.not.mpr hν, or_false] at h1\n  exact h1\n\n"}
{"name":"MeasureTheory.absolutelyContinuous_of_isMulLeftInvariant","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Group G\ninst✝⁵ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝⁴ : MeasureTheory.SFinite ν\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasurableInv G\ninst✝¹ : μ.IsMulLeftInvariant\ninst✝ : ν.IsMulLeftInvariant\nhν : Ne ν 0\n⊢ μ.AbsolutelyContinuous ν","decl":"/-- Any two nonzero left-invariant measures are absolutely continuous w.r.t. each other. -/\n@[to_additive\n\" Any two nonzero left-invariant measures are absolutely continuous w.r.t. each other. \"]\ntheorem absolutelyContinuous_of_isMulLeftInvariant [IsMulLeftInvariant ν] (hν : ν ≠ 0) : μ ≪ ν := by\n  refine AbsolutelyContinuous.mk fun s sm hνs => ?_\n  have h1 := measure_mul_lintegral_eq μ ν sm 1 measurable_one\n  simp_rw [Pi.one_apply, lintegral_one, mul_one, (measure_mul_right_null ν _).mpr hνs,\n    lintegral_zero, mul_eq_zero (M₀ := ℝ≥0∞), measure_univ_eq_zero.not.mpr hν, or_false] at h1\n  exact h1\n\n"}
{"name":"MeasureTheory.ae_measure_preimage_mul_right_lt_top","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Group G\ninst✝⁵ : MeasurableMul₂ G\ns : Set G\ninst✝⁴ : MeasurableInv G\nμ' ν' : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SigmaFinite μ'\ninst✝² : MeasureTheory.SigmaFinite ν'\ninst✝¹ : μ'.IsMulLeftInvariant\ninst✝ : ν'.IsMulLeftInvariant\nhμs : Ne (μ' s) Top.top\n⊢ Filter.Eventually (fun x => LT.lt (ν' (Set.preimage (fun x_1 => HMul.hMul x_1 x) s)) Top.top) (MeasureTheory.ae μ')","decl":"@[to_additive]\ntheorem ae_measure_preimage_mul_right_lt_top (hμs : μ' s ≠ ∞) :\n    ∀ᵐ x ∂μ', ν' ((· * x) ⁻¹' s) < ∞ := by\n  wlog sm : MeasurableSet s generalizing s\n  · filter_upwards [this ((measure_toMeasurable _).trans_ne hμs) (measurableSet_toMeasurable ..)]\n      with x hx using lt_of_le_of_lt (by gcongr; apply subset_toMeasurable) hx\n  refine ae_of_forall_measure_lt_top_ae_restrict' ν'.inv _ ?_\n  intro A hA _ h3A\n  simp only [ν'.inv_apply] at h3A\n  apply ae_lt_top (measurable_measure_mul_right ν' sm)\n  have h1 := measure_mul_lintegral_eq μ' ν' sm (A⁻¹.indicator 1) (measurable_one.indicator hA.inv)\n  rw [lintegral_indicator hA.inv] at h1\n  simp_rw [Pi.one_apply, setLIntegral_one, ← image_inv_eq_inv, indicator_image inv_injective,\n    image_inv_eq_inv, ← indicator_mul_right _ fun x => ν' ((· * x) ⁻¹' s), Function.comp,\n    Pi.one_apply, mul_one] at h1\n  rw [← lintegral_indicator hA, ← h1]\n  exact ENNReal.mul_ne_top hμs h3A.ne\n\n"}
{"name":"MeasureTheory.ae_measure_preimage_add_right_lt_top","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : MeasurableAdd₂ G\ns : Set G\ninst✝⁴ : MeasurableNeg G\nμ' ν' : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SigmaFinite μ'\ninst✝² : MeasureTheory.SigmaFinite ν'\ninst✝¹ : μ'.IsAddLeftInvariant\ninst✝ : ν'.IsAddLeftInvariant\nhμs : Ne (μ' s) Top.top\n⊢ Filter.Eventually (fun x => LT.lt (ν' (Set.preimage (fun x_1 => HAdd.hAdd x_1 x) s)) Top.top) (MeasureTheory.ae μ')","decl":"@[to_additive]\ntheorem ae_measure_preimage_mul_right_lt_top (hμs : μ' s ≠ ∞) :\n    ∀ᵐ x ∂μ', ν' ((· * x) ⁻¹' s) < ∞ := by\n  wlog sm : MeasurableSet s generalizing s\n  · filter_upwards [this ((measure_toMeasurable _).trans_ne hμs) (measurableSet_toMeasurable ..)]\n      with x hx using lt_of_le_of_lt (by gcongr; apply subset_toMeasurable) hx\n  refine ae_of_forall_measure_lt_top_ae_restrict' ν'.inv _ ?_\n  intro A hA _ h3A\n  simp only [ν'.inv_apply] at h3A\n  apply ae_lt_top (measurable_measure_mul_right ν' sm)\n  have h1 := measure_mul_lintegral_eq μ' ν' sm (A⁻¹.indicator 1) (measurable_one.indicator hA.inv)\n  rw [lintegral_indicator hA.inv] at h1\n  simp_rw [Pi.one_apply, setLIntegral_one, ← image_inv_eq_inv, indicator_image inv_injective,\n    image_inv_eq_inv, ← indicator_mul_right _ fun x => ν' ((· * x) ⁻¹' s), Function.comp,\n    Pi.one_apply, mul_one] at h1\n  rw [← lintegral_indicator hA, ← h1]\n  exact ENNReal.mul_ne_top hμs h3A.ne\n\n"}
{"name":"MeasureTheory.ae_measure_preimage_mul_right_lt_top_of_ne_zero","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Group G\ninst✝⁵ : MeasurableMul₂ G\ns : Set G\ninst✝⁴ : MeasurableInv G\nμ' ν' : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SigmaFinite μ'\ninst✝² : MeasureTheory.SigmaFinite ν'\ninst✝¹ : μ'.IsMulLeftInvariant\ninst✝ : ν'.IsMulLeftInvariant\nh2s : Ne (ν' s) 0\nh3s : Ne (ν' s) Top.top\n⊢ Filter.Eventually (fun x => LT.lt (ν' (Set.preimage (fun y => HMul.hMul y x) s)) Top.top) (MeasureTheory.ae μ')","decl":"@[to_additive]\ntheorem ae_measure_preimage_mul_right_lt_top_of_ne_zero (h2s : ν' s ≠ 0) (h3s : ν' s ≠ ∞) :\n    ∀ᵐ x ∂μ', ν' ((fun y => y * x) ⁻¹' s) < ∞ := by\n  refine (ae_measure_preimage_mul_right_lt_top ν' ν' h3s).filter_mono ?_\n  refine (absolutelyContinuous_of_isMulLeftInvariant μ' ν' ?_).ae_le\n  refine mt ?_ h2s\n  intro hν\n  rw [hν, Measure.coe_zero, Pi.zero_apply]\n\n"}
{"name":"MeasureTheory.ae_measure_preimage_add_right_lt_top_of_ne_zero","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : MeasurableAdd₂ G\ns : Set G\ninst✝⁴ : MeasurableNeg G\nμ' ν' : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SigmaFinite μ'\ninst✝² : MeasureTheory.SigmaFinite ν'\ninst✝¹ : μ'.IsAddLeftInvariant\ninst✝ : ν'.IsAddLeftInvariant\nh2s : Ne (ν' s) 0\nh3s : Ne (ν' s) Top.top\n⊢ Filter.Eventually (fun x => LT.lt (ν' (Set.preimage (fun y => HAdd.hAdd y x) s)) Top.top) (MeasureTheory.ae μ')","decl":"@[to_additive]\ntheorem ae_measure_preimage_mul_right_lt_top_of_ne_zero (h2s : ν' s ≠ 0) (h3s : ν' s ≠ ∞) :\n    ∀ᵐ x ∂μ', ν' ((fun y => y * x) ⁻¹' s) < ∞ := by\n  refine (ae_measure_preimage_mul_right_lt_top ν' ν' h3s).filter_mono ?_\n  refine (absolutelyContinuous_of_isMulLeftInvariant μ' ν' ?_).ae_le\n  refine mt ?_ h2s\n  intro hν\n  rw [hν, Measure.coe_zero, Pi.zero_apply]\n\n"}
{"name":"MeasureTheory.measure_lintegral_sub_measure","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : MeasurableAdd₂ G\ns : Set G\ninst✝⁴ : MeasurableNeg G\nμ' ν' : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SigmaFinite μ'\ninst✝² : MeasureTheory.SigmaFinite ν'\ninst✝¹ : μ'.IsAddLeftInvariant\ninst✝ : ν'.IsAddLeftInvariant\nsm : MeasurableSet s\nh2s : Ne (ν' s) 0\nh3s : Ne (ν' s) Top.top\nf : G → ENNReal\nhf : Measurable f\n⊢ Eq (HMul.hMul (μ' s) (MeasureTheory.lintegral ν' fun y => HDiv.hDiv (f (Neg.neg y)) (ν' (Set.preimage (fun x => HAdd.hAdd x (Neg.neg y)) s)))) (MeasureTheory.lintegral μ' fun x => f x)","decl":"/-- A technical lemma relating two different measures. This is basically [Halmos, §60 Th. A].\n  Note that if `f` is the characteristic function of a measurable set `t` this states that\n  `μ t = c * μ s` for a constant `c` that does not depend on `μ`.\n\n  Note: There is a gap in the last step of the proof in [Halmos].\n  In the last line, the equality `g(x⁻¹)ν(sx⁻¹) = f(x)` holds if we can prove that\n  `0 < ν(sx⁻¹) < ∞`. The first inequality follows from §59, Th. D, but the second inequality is\n  not justified. We prove this inequality for almost all `x` in\n  `MeasureTheory.ae_measure_preimage_mul_right_lt_top_of_ne_zero`. -/\n@[to_additive\n\"A technical lemma relating two different measures. This is basically [Halmos, §60 Th. A]. Note that\nif `f` is the characteristic function of a measurable set `t` this states that `μ t = c * μ s` for a\nconstant `c` that does not depend on `μ`.\n\nNote: There is a gap in the last step of the proof in [Halmos]. In the last line, the equality\n`g(-x) + ν(s - x) = f(x)` holds if we can prove that `0 < ν(s - x) < ∞`. The first inequality\nfollows from §59, Th. D, but the second inequality is not justified. We prove this inequality for\nalmost all `x` in `MeasureTheory.ae_measure_preimage_add_right_lt_top_of_ne_zero`.\"]\ntheorem measure_lintegral_div_measure (sm : MeasurableSet s) (h2s : ν' s ≠ 0) (h3s : ν' s ≠ ∞)\n    (f : G → ℝ≥0∞) (hf : Measurable f) :\n    (μ' s * ∫⁻ y, f y⁻¹ / ν' ((· * y⁻¹) ⁻¹' s) ∂ν') = ∫⁻ x, f x ∂μ' := by\n  set g := fun y => f y⁻¹ / ν' ((fun x => x * y⁻¹) ⁻¹' s)\n  have hg : Measurable g :=\n    (hf.comp measurable_inv).div ((measurable_measure_mul_right ν' sm).comp measurable_inv)\n  simp_rw [measure_mul_lintegral_eq μ' ν' sm g hg, g, inv_inv]\n  refine lintegral_congr_ae ?_\n  refine (ae_measure_preimage_mul_right_lt_top_of_ne_zero μ' ν' h2s h3s).mono fun x hx => ?_\n  simp_rw [ENNReal.mul_div_cancel (measure_mul_right_ne_zero ν' h2s _) hx.ne]\n\n"}
{"name":"MeasureTheory.measure_lintegral_div_measure","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Group G\ninst✝⁵ : MeasurableMul₂ G\ns : Set G\ninst✝⁴ : MeasurableInv G\nμ' ν' : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SigmaFinite μ'\ninst✝² : MeasureTheory.SigmaFinite ν'\ninst✝¹ : μ'.IsMulLeftInvariant\ninst✝ : ν'.IsMulLeftInvariant\nsm : MeasurableSet s\nh2s : Ne (ν' s) 0\nh3s : Ne (ν' s) Top.top\nf : G → ENNReal\nhf : Measurable f\n⊢ Eq (HMul.hMul (μ' s) (MeasureTheory.lintegral ν' fun y => HDiv.hDiv (f (Inv.inv y)) (ν' (Set.preimage (fun x => HMul.hMul x (Inv.inv y)) s)))) (MeasureTheory.lintegral μ' fun x => f x)","decl":"/-- A technical lemma relating two different measures. This is basically [Halmos, §60 Th. A].\n  Note that if `f` is the characteristic function of a measurable set `t` this states that\n  `μ t = c * μ s` for a constant `c` that does not depend on `μ`.\n\n  Note: There is a gap in the last step of the proof in [Halmos].\n  In the last line, the equality `g(x⁻¹)ν(sx⁻¹) = f(x)` holds if we can prove that\n  `0 < ν(sx⁻¹) < ∞`. The first inequality follows from §59, Th. D, but the second inequality is\n  not justified. We prove this inequality for almost all `x` in\n  `MeasureTheory.ae_measure_preimage_mul_right_lt_top_of_ne_zero`. -/\n@[to_additive\n\"A technical lemma relating two different measures. This is basically [Halmos, §60 Th. A]. Note that\nif `f` is the characteristic function of a measurable set `t` this states that `μ t = c * μ s` for a\nconstant `c` that does not depend on `μ`.\n\nNote: There is a gap in the last step of the proof in [Halmos]. In the last line, the equality\n`g(-x) + ν(s - x) = f(x)` holds if we can prove that `0 < ν(s - x) < ∞`. The first inequality\nfollows from §59, Th. D, but the second inequality is not justified. We prove this inequality for\nalmost all `x` in `MeasureTheory.ae_measure_preimage_add_right_lt_top_of_ne_zero`.\"]\ntheorem measure_lintegral_div_measure (sm : MeasurableSet s) (h2s : ν' s ≠ 0) (h3s : ν' s ≠ ∞)\n    (f : G → ℝ≥0∞) (hf : Measurable f) :\n    (μ' s * ∫⁻ y, f y⁻¹ / ν' ((· * y⁻¹) ⁻¹' s) ∂ν') = ∫⁻ x, f x ∂μ' := by\n  set g := fun y => f y⁻¹ / ν' ((fun x => x * y⁻¹) ⁻¹' s)\n  have hg : Measurable g :=\n    (hf.comp measurable_inv).div ((measurable_measure_mul_right ν' sm).comp measurable_inv)\n  simp_rw [measure_mul_lintegral_eq μ' ν' sm g hg, g, inv_inv]\n  refine lintegral_congr_ae ?_\n  refine (ae_measure_preimage_mul_right_lt_top_of_ne_zero μ' ν' h2s h3s).mono fun x hx => ?_\n  simp_rw [ENNReal.mul_div_cancel (measure_mul_right_ne_zero ν' h2s _) hx.ne]\n\n"}
{"name":"MeasureTheory.measure_mul_measure_eq","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Group G\ninst✝⁵ : MeasurableMul₂ G\ninst✝⁴ : MeasurableInv G\nμ' ν' : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SigmaFinite μ'\ninst✝² : MeasureTheory.SigmaFinite ν'\ninst✝¹ : μ'.IsMulLeftInvariant\ninst✝ : ν'.IsMulLeftInvariant\ns t : Set G\nh2s : Ne (ν' s) 0\nh3s : Ne (ν' s) Top.top\n⊢ Eq (HMul.hMul (μ' s) (ν' t)) (HMul.hMul (ν' s) (μ' t))","decl":"@[to_additive]\ntheorem measure_mul_measure_eq (s t : Set G) (h2s : ν' s ≠ 0) (h3s : ν' s ≠ ∞) :\n    μ' s * ν' t = ν' s * μ' t := by\n  wlog hs : MeasurableSet s generalizing s\n  · rcases exists_measurable_superset₂ μ' ν' s with ⟨s', -, hm, hμ, hν⟩\n    rw [← hμ, ← hν, this s' _ _ hm] <;> rwa [hν]\n  wlog ht : MeasurableSet t generalizing t\n  · rcases exists_measurable_superset₂ μ' ν' t with ⟨t', -, hm, hμ, hν⟩\n    rw [← hμ, ← hν, this _ hm]\n  have h1 := measure_lintegral_div_measure ν' ν' hs h2s h3s (t.indicator fun _ => 1)\n    (measurable_const.indicator ht)\n  have h2 := measure_lintegral_div_measure μ' ν' hs h2s h3s (t.indicator fun _ => 1)\n    (measurable_const.indicator ht)\n  rw [lintegral_indicator ht, setLIntegral_one] at h1 h2\n  rw [← h1, mul_left_comm, h2]\n\n"}
{"name":"MeasureTheory.measure_add_measure_eq","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : MeasurableAdd₂ G\ninst✝⁴ : MeasurableNeg G\nμ' ν' : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SigmaFinite μ'\ninst✝² : MeasureTheory.SigmaFinite ν'\ninst✝¹ : μ'.IsAddLeftInvariant\ninst✝ : ν'.IsAddLeftInvariant\ns t : Set G\nh2s : Ne (ν' s) 0\nh3s : Ne (ν' s) Top.top\n⊢ Eq (HMul.hMul (μ' s) (ν' t)) (HMul.hMul (ν' s) (μ' t))","decl":"@[to_additive]\ntheorem measure_mul_measure_eq (s t : Set G) (h2s : ν' s ≠ 0) (h3s : ν' s ≠ ∞) :\n    μ' s * ν' t = ν' s * μ' t := by\n  wlog hs : MeasurableSet s generalizing s\n  · rcases exists_measurable_superset₂ μ' ν' s with ⟨s', -, hm, hμ, hν⟩\n    rw [← hμ, ← hν, this s' _ _ hm] <;> rwa [hν]\n  wlog ht : MeasurableSet t generalizing t\n  · rcases exists_measurable_superset₂ μ' ν' t with ⟨t', -, hm, hμ, hν⟩\n    rw [← hμ, ← hν, this _ hm]\n  have h1 := measure_lintegral_div_measure ν' ν' hs h2s h3s (t.indicator fun _ => 1)\n    (measurable_const.indicator ht)\n  have h2 := measure_lintegral_div_measure μ' ν' hs h2s h3s (t.indicator fun _ => 1)\n    (measurable_const.indicator ht)\n  rw [lintegral_indicator ht, setLIntegral_one] at h1 h2\n  rw [← h1, mul_left_comm, h2]\n\n"}
{"name":"MeasureTheory.measure_eq_div_smul","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Group G\ninst✝⁵ : MeasurableMul₂ G\ns : Set G\ninst✝⁴ : MeasurableInv G\nμ' ν' : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SigmaFinite μ'\ninst✝² : MeasureTheory.SigmaFinite ν'\ninst✝¹ : μ'.IsMulLeftInvariant\ninst✝ : ν'.IsMulLeftInvariant\nh2s : Ne (ν' s) 0\nh3s : Ne (ν' s) Top.top\n⊢ Eq μ' (HSMul.hSMul (HDiv.hDiv (μ' s) (ν' s)) ν')","decl":"/-- Left invariant Borel measures on a measurable group are unique (up to a scalar). -/\n@[to_additive\n\" Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"]\ntheorem measure_eq_div_smul (h2s : ν' s ≠ 0) (h3s : ν' s ≠ ∞) :\n    μ' = (μ' s / ν' s) • ν' := by\n  ext1 t -\n  rw [smul_apply, smul_eq_mul, mul_comm, ← mul_div_assoc, mul_comm,\n    measure_mul_measure_eq μ' ν' s t h2s h3s, mul_div_assoc, ENNReal.mul_div_cancel h2s h3s]\n\n"}
{"name":"MeasureTheory.measure_eq_sub_vadd","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : MeasurableAdd₂ G\ns : Set G\ninst✝⁴ : MeasurableNeg G\nμ' ν' : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SigmaFinite μ'\ninst✝² : MeasureTheory.SigmaFinite ν'\ninst✝¹ : μ'.IsAddLeftInvariant\ninst✝ : ν'.IsAddLeftInvariant\nh2s : Ne (ν' s) 0\nh3s : Ne (ν' s) Top.top\n⊢ Eq μ' (HSMul.hSMul (HDiv.hDiv (μ' s) (ν' s)) ν')","decl":"/-- Left invariant Borel measures on a measurable group are unique (up to a scalar). -/\n@[to_additive\n\" Left invariant Borel measures on an additive measurable group are unique (up to a scalar). \"]\ntheorem measure_eq_div_smul (h2s : ν' s ≠ 0) (h3s : ν' s ≠ ∞) :\n    μ' = (μ' s / ν' s) • ν' := by\n  ext1 t -\n  rw [smul_apply, smul_eq_mul, mul_comm, ← mul_div_assoc, mul_comm,\n    measure_mul_measure_eq μ' ν' s t h2s h3s, mul_div_assoc, ENNReal.mul_div_cancel h2s h3s]\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_mul_right","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ν.IsMulRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.1, snd := HMul.hMul z.2 z.1 }) (μ.prod ν) (μ.prod ν)","decl":"@[to_additive measurePreserving_prod_add_right]\ntheorem measurePreserving_prod_mul_right [IsMulRightInvariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1, z.2 * z.1)) (μ.prod ν) (μ.prod ν) :=\n  MeasurePreserving.skew_product (g := fun x y => y * x) (MeasurePreserving.id μ)\n    (measurable_snd.mul measurable_fst) <| Filter.Eventually.of_forall <| map_mul_right_eq_self ν\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_add_right","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : ν.IsAddRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.1, snd := HAdd.hAdd z.2 z.1 }) (μ.prod ν) (μ.prod ν)","decl":"@[to_additive measurePreserving_prod_add_right]\ntheorem measurePreserving_prod_mul_right [IsMulRightInvariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1, z.2 * z.1)) (μ.prod ν) (μ.prod ν) :=\n  MeasurePreserving.skew_product (g := fun x y => y * x) (MeasurePreserving.id μ)\n    (measurable_snd.mul measurable_fst) <| Filter.Eventually.of_forall <| map_mul_right_eq_self ν\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_add_swap_right","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.IsAddRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.2, snd := HAdd.hAdd z.1 z.2 }) (μ.prod ν) (ν.prod μ)","decl":"/-- The map `(x, y) ↦ (y, xy)` sends the measure `μ × ν` to `ν × μ`. -/\n@[to_additive measurePreserving_prod_add_swap_right\n\" The map `(x, y) ↦ (y, x + y)` sends the measure `μ × ν` to `ν × μ`. \"]\ntheorem measurePreserving_prod_mul_swap_right [IsMulRightInvariant μ] :\n    MeasurePreserving (fun z : G × G => (z.2, z.1 * z.2)) (μ.prod ν) (ν.prod μ) :=\n  (measurePreserving_prod_mul_right ν μ).comp measurePreserving_swap\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_mul_swap_right","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.IsMulRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.2, snd := HMul.hMul z.1 z.2 }) (μ.prod ν) (ν.prod μ)","decl":"/-- The map `(x, y) ↦ (y, xy)` sends the measure `μ × ν` to `ν × μ`. -/\n@[to_additive measurePreserving_prod_add_swap_right\n\" The map `(x, y) ↦ (y, x + y)` sends the measure `μ × ν` to `ν × μ`. \"]\ntheorem measurePreserving_prod_mul_swap_right [IsMulRightInvariant μ] :\n    MeasurePreserving (fun z : G × G => (z.2, z.1 * z.2)) (μ.prod ν) (ν.prod μ) :=\n  (measurePreserving_prod_mul_right ν μ).comp measurePreserving_swap\n\n"}
{"name":"MeasureTheory.measurePreserving_add_prod","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.IsAddRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := HAdd.hAdd z.1 z.2, snd := z.2 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The map `(x, y) ↦ (xy, y)` preserves the measure `μ × ν`. -/\n@[to_additive measurePreserving_add_prod\n\" The map `(x, y) ↦ (x + y, y)` preserves the measure `μ × ν`. \"]\ntheorem measurePreserving_mul_prod [IsMulRightInvariant μ] :\n    MeasurePreserving (fun z : G × G => (z.1 * z.2, z.2)) (μ.prod ν) (μ.prod ν) :=\n  measurePreserving_swap.comp (measurePreserving_prod_mul_swap_right μ ν)\n\n"}
{"name":"MeasureTheory.measurePreserving_mul_prod","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.IsMulRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := HMul.hMul z.1 z.2, snd := z.2 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The map `(x, y) ↦ (xy, y)` preserves the measure `μ × ν`. -/\n@[to_additive measurePreserving_add_prod\n\" The map `(x, y) ↦ (x + y, y)` preserves the measure `μ × ν`. \"]\ntheorem measurePreserving_mul_prod [IsMulRightInvariant μ] :\n    MeasurePreserving (fun z : G × G => (z.1 * z.2, z.2)) (μ.prod ν) (μ.prod ν) :=\n  measurePreserving_swap.comp (measurePreserving_prod_mul_swap_right μ ν)\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_sub","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : AddGroup G\ninst✝⁴ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : ν.IsAddRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.1, snd := HSub.hSub z.2 z.1 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The map `(x, y) ↦ (x, y / x)` is measure-preserving. -/\n@[to_additive measurePreserving_prod_sub \"The map `(x, y) ↦ (x, y - x)` is measure-preserving.\"]\ntheorem measurePreserving_prod_div [IsMulRightInvariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1, z.2 / z.1)) (μ.prod ν) (μ.prod ν) :=\n  (measurePreserving_prod_mul_right μ ν).symm (MeasurableEquiv.shearDivRight G).symm\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_div","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : Group G\ninst✝⁴ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : ν.IsMulRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.1, snd := HDiv.hDiv z.2 z.1 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The map `(x, y) ↦ (x, y / x)` is measure-preserving. -/\n@[to_additive measurePreserving_prod_sub \"The map `(x, y) ↦ (x, y - x)` is measure-preserving.\"]\ntheorem measurePreserving_prod_div [IsMulRightInvariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1, z.2 / z.1)) (μ.prod ν) (μ.prod ν) :=\n  (measurePreserving_prod_mul_right μ ν).symm (MeasurableEquiv.shearDivRight G).symm\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_div_swap","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : Group G\ninst✝⁴ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.2, snd := HDiv.hDiv z.1 z.2 }) (μ.prod ν) (ν.prod μ)","decl":"/-- The map `(x, y) ↦ (y, x / y)` sends `μ × ν` to `ν × μ`. -/\n@[to_additive measurePreserving_prod_sub_swap\n      \"The map `(x, y) ↦ (y, x - y)` sends `μ × ν` to `ν × μ`.\"]\ntheorem measurePreserving_prod_div_swap [IsMulRightInvariant μ] :\n    MeasurePreserving (fun z : G × G => (z.2, z.1 / z.2)) (μ.prod ν) (ν.prod μ) :=\n  (measurePreserving_prod_div ν μ).comp measurePreserving_swap\n\n"}
{"name":"MeasureTheory.measurePreserving_prod_sub_swap","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : AddGroup G\ninst✝⁴ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := z.2, snd := HSub.hSub z.1 z.2 }) (μ.prod ν) (ν.prod μ)","decl":"/-- The map `(x, y) ↦ (y, x / y)` sends `μ × ν` to `ν × μ`. -/\n@[to_additive measurePreserving_prod_sub_swap\n      \"The map `(x, y) ↦ (y, x - y)` sends `μ × ν` to `ν × μ`.\"]\ntheorem measurePreserving_prod_div_swap [IsMulRightInvariant μ] :\n    MeasurePreserving (fun z : G × G => (z.2, z.1 / z.2)) (μ.prod ν) (ν.prod μ) :=\n  (measurePreserving_prod_div ν μ).comp measurePreserving_swap\n\n"}
{"name":"MeasureTheory.measurePreserving_div_prod","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : Group G\ninst✝⁴ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := HDiv.hDiv z.1 z.2, snd := z.2 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The map `(x, y) ↦ (x / y, y)` preserves the measure `μ × ν`. -/\n@[to_additive measurePreserving_sub_prod\n\" The map `(x, y) ↦ (x - y, y)` preserves the measure `μ × ν`. \"]\ntheorem measurePreserving_div_prod [IsMulRightInvariant μ] :\n    MeasurePreserving (fun z : G × G => (z.1 / z.2, z.2)) (μ.prod ν) (μ.prod ν) :=\n  measurePreserving_swap.comp (measurePreserving_prod_div_swap μ ν)\n\n"}
{"name":"MeasureTheory.measurePreserving_sub_prod","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : AddGroup G\ninst✝⁴ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := HSub.hSub z.1 z.2, snd := z.2 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The map `(x, y) ↦ (x / y, y)` preserves the measure `μ × ν`. -/\n@[to_additive measurePreserving_sub_prod\n\" The map `(x, y) ↦ (x - y, y)` preserves the measure `μ × ν`. \"]\ntheorem measurePreserving_div_prod [IsMulRightInvariant μ] :\n    MeasurePreserving (fun z : G × G => (z.1 / z.2, z.2)) (μ.prod ν) (μ.prod ν) :=\n  measurePreserving_swap.comp (measurePreserving_prod_div_swap μ ν)\n\n"}
{"name":"MeasureTheory.measurePreserving_add_prod_neg_right","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : AddGroup G\ninst✝⁵ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝⁴ : MeasureTheory.SFinite ν\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasurableNeg G\ninst✝¹ : μ.IsAddRightInvariant\ninst✝ : ν.IsAddRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := HAdd.hAdd z.1 z.2, snd := Neg.neg z.1 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The map `(x, y) ↦ (xy, x⁻¹)` is measure-preserving. -/\n@[to_additive measurePreserving_add_prod_neg_right\n\"The map `(x, y) ↦ (x + y, - x)` is measure-preserving.\"]\ntheorem measurePreserving_mul_prod_inv_right [IsMulRightInvariant μ] [IsMulRightInvariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1 * z.2, z.1⁻¹)) (μ.prod ν) (μ.prod ν) := by\n  convert (measurePreserving_prod_div_swap ν μ).comp (measurePreserving_prod_mul_swap_right μ ν)\n    using 1\n  ext1 ⟨x, y⟩\n  simp_rw [Function.comp_apply, div_mul_eq_div_div_swap, div_self', one_div]\n\n"}
{"name":"MeasureTheory.measurePreserving_mul_prod_inv_right","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : Group G\ninst✝⁵ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝⁴ : MeasureTheory.SFinite ν\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasurableInv G\ninst✝¹ : μ.IsMulRightInvariant\ninst✝ : ν.IsMulRightInvariant\n⊢ MeasureTheory.MeasurePreserving (fun z => { fst := HMul.hMul z.1 z.2, snd := Inv.inv z.1 }) (μ.prod ν) (μ.prod ν)","decl":"/-- The map `(x, y) ↦ (xy, x⁻¹)` is measure-preserving. -/\n@[to_additive measurePreserving_add_prod_neg_right\n\"The map `(x, y) ↦ (x + y, - x)` is measure-preserving.\"]\ntheorem measurePreserving_mul_prod_inv_right [IsMulRightInvariant μ] [IsMulRightInvariant ν] :\n    MeasurePreserving (fun z : G × G => (z.1 * z.2, z.1⁻¹)) (μ.prod ν) (μ.prod ν) := by\n  convert (measurePreserving_prod_div_swap ν μ).comp (measurePreserving_prod_mul_swap_right μ ν)\n    using 1\n  ext1 ⟨x, y⟩\n  simp_rw [Function.comp_apply, div_mul_eq_div_div_swap, div_self', one_div]\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_inv_of_right_invariant","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulRightInvariant\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving Inv.inv μ μ","decl":"@[to_additive]\ntheorem quasiMeasurePreserving_inv_of_right_invariant [IsMulRightInvariant μ] :\n    QuasiMeasurePreserving (Inv.inv : G → G) μ μ := by\n  rw [← μ.inv_inv]\n  exact\n    (quasiMeasurePreserving_inv μ.inv).mono (inv_absolutelyContinuous μ.inv)\n      (absolutelyContinuous_inv μ.inv)\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_neg_of_right_invariant","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddRightInvariant\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving Neg.neg μ μ","decl":"@[to_additive]\ntheorem quasiMeasurePreserving_inv_of_right_invariant [IsMulRightInvariant μ] :\n    QuasiMeasurePreserving (Inv.inv : G → G) μ μ := by\n  rw [← μ.inv_inv]\n  exact\n    (quasiMeasurePreserving_inv μ.inv).mono (inv_absolutelyContinuous μ.inv)\n      (absolutelyContinuous_inv μ.inv)\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_div_left","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\ng : G\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving (fun h => HDiv.hDiv g h) μ μ","decl":"@[to_additive]\ntheorem quasiMeasurePreserving_div_left [IsMulLeftInvariant μ] (g : G) :\n    QuasiMeasurePreserving (fun h : G => g / h) μ μ := by\n  simp_rw [div_eq_mul_inv]\n  exact\n    (measurePreserving_mul_left μ g).quasiMeasurePreserving.comp (quasiMeasurePreserving_inv μ)\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_sub_left","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\ng : G\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving (fun h => HSub.hSub g h) μ μ","decl":"@[to_additive]\ntheorem quasiMeasurePreserving_div_left [IsMulLeftInvariant μ] (g : G) :\n    QuasiMeasurePreserving (fun h : G => g / h) μ μ := by\n  simp_rw [div_eq_mul_inv]\n  exact\n    (measurePreserving_mul_left μ g).quasiMeasurePreserving.comp (quasiMeasurePreserving_inv μ)\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_div_left_of_right_invariant","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulRightInvariant\ng : G\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving (fun h => HDiv.hDiv g h) μ μ","decl":"@[to_additive]\ntheorem quasiMeasurePreserving_div_left_of_right_invariant [IsMulRightInvariant μ] (g : G) :\n    QuasiMeasurePreserving (fun h : G => g / h) μ μ := by\n  rw [← μ.inv_inv]\n  exact\n    (quasiMeasurePreserving_div_left μ.inv g).mono (inv_absolutelyContinuous μ.inv)\n      (absolutelyContinuous_inv μ.inv)\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_sub_left_of_right_invariant","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddRightInvariant\ng : G\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving (fun h => HSub.hSub g h) μ μ","decl":"@[to_additive]\ntheorem quasiMeasurePreserving_div_left_of_right_invariant [IsMulRightInvariant μ] (g : G) :\n    QuasiMeasurePreserving (fun h : G => g / h) μ μ := by\n  rw [← μ.inv_inv]\n  exact\n    (quasiMeasurePreserving_div_left μ.inv g).mono (inv_absolutelyContinuous μ.inv)\n      (absolutelyContinuous_inv μ.inv)\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_sub_of_right_invariant","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : AddGroup G\ninst✝⁴ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddRightInvariant\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving (fun p => HSub.hSub p.1 p.2) (μ.prod ν) μ","decl":"@[to_additive]\ntheorem quasiMeasurePreserving_div_of_right_invariant [IsMulRightInvariant μ] :\n    QuasiMeasurePreserving (fun p : G × G => p.1 / p.2) (μ.prod ν) μ := by\n  refine QuasiMeasurePreserving.prod_of_left measurable_div (Eventually.of_forall fun y => ?_)\n  exact (measurePreserving_div_right μ y).quasiMeasurePreserving\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_div_of_right_invariant","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : Group G\ninst✝⁴ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulRightInvariant\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving (fun p => HDiv.hDiv p.1 p.2) (μ.prod ν) μ","decl":"@[to_additive]\ntheorem quasiMeasurePreserving_div_of_right_invariant [IsMulRightInvariant μ] :\n    QuasiMeasurePreserving (fun p : G × G => p.1 / p.2) (μ.prod ν) μ := by\n  refine QuasiMeasurePreserving.prod_of_left measurable_div (Eventually.of_forall fun y => ?_)\n  exact (measurePreserving_div_right μ y).quasiMeasurePreserving\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_sub","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : AddGroup G\ninst✝⁴ : MeasurableAdd₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving (fun p => HSub.hSub p.1 p.2) (μ.prod ν) μ","decl":"@[to_additive]\ntheorem quasiMeasurePreserving_div [IsMulLeftInvariant μ] :\n    QuasiMeasurePreserving (fun p : G × G => p.1 / p.2) (μ.prod ν) μ :=\n  (quasiMeasurePreserving_div_of_right_invariant μ.inv ν).mono\n    ((absolutelyContinuous_inv μ).prod AbsolutelyContinuous.rfl) (inv_absolutelyContinuous μ)\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_div","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : Group G\ninst✝⁴ : MeasurableMul₂ G\nμ ν : MeasureTheory.Measure G\ninst✝³ : MeasureTheory.SFinite ν\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving (fun p => HDiv.hDiv p.1 p.2) (μ.prod ν) μ","decl":"@[to_additive]\ntheorem quasiMeasurePreserving_div [IsMulLeftInvariant μ] :\n    QuasiMeasurePreserving (fun p : G × G => p.1 / p.2) (μ.prod ν) μ :=\n  (quasiMeasurePreserving_div_of_right_invariant μ.inv ν).mono\n    ((absolutelyContinuous_inv μ).prod AbsolutelyContinuous.rfl) (inv_absolutelyContinuous μ)\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_add_right","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddLeftInvariant\ng : G\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving (fun h => HAdd.hAdd h g) μ μ","decl":"/-- A *left*-invariant measure is quasi-preserved by *right*-multiplication.\nThis should not be confused with `(measurePreserving_mul_right μ g).quasiMeasurePreserving`. -/\n@[to_additive\n\"A *left*-invariant measure is quasi-preserved by *right*-addition.\nThis should not be confused with `(measurePreserving_add_right μ g).quasiMeasurePreserving`. \"]\ntheorem quasiMeasurePreserving_mul_right [IsMulLeftInvariant μ] (g : G) :\n    QuasiMeasurePreserving (fun h : G => h * g) μ μ := by\n  refine ⟨measurable_mul_const g, AbsolutelyContinuous.mk fun s hs => ?_⟩\n  rw [map_apply (measurable_mul_const g) hs, measure_mul_right_null]; exact id\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_mul_right","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulLeftInvariant\ng : G\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving (fun h => HMul.hMul h g) μ μ","decl":"/-- A *left*-invariant measure is quasi-preserved by *right*-multiplication.\nThis should not be confused with `(measurePreserving_mul_right μ g).quasiMeasurePreserving`. -/\n@[to_additive\n\"A *left*-invariant measure is quasi-preserved by *right*-addition.\nThis should not be confused with `(measurePreserving_add_right μ g).quasiMeasurePreserving`. \"]\ntheorem quasiMeasurePreserving_mul_right [IsMulLeftInvariant μ] (g : G) :\n    QuasiMeasurePreserving (fun h : G => h * g) μ μ := by\n  refine ⟨measurable_mul_const g, AbsolutelyContinuous.mk fun s hs => ?_⟩\n  rw [map_apply (measurable_mul_const g) hs, measure_mul_right_null]; exact id\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_mul_left","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsMulRightInvariant\ng : G\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving (fun h => HMul.hMul g h) μ μ","decl":"/-- A *right*-invariant measure is quasi-preserved by *left*-multiplication.\nThis should not be confused with `(measurePreserving_mul_left μ g).quasiMeasurePreserving`. -/\n@[to_additive\n\"A *right*-invariant measure is quasi-preserved by *left*-addition.\nThis should not be confused with `(measurePreserving_add_left μ g).quasiMeasurePreserving`. \"]\ntheorem quasiMeasurePreserving_mul_left [IsMulRightInvariant μ] (g : G) :\n    QuasiMeasurePreserving (fun h : G => g * h) μ μ := by\n  have :=\n    (quasiMeasurePreserving_mul_right μ.inv g⁻¹).mono (inv_absolutelyContinuous μ.inv)\n      (absolutelyContinuous_inv μ.inv)\n  rw [μ.inv_inv] at this\n  have :=\n    (quasiMeasurePreserving_inv_of_right_invariant μ).comp\n      (this.comp (quasiMeasurePreserving_inv_of_right_invariant μ))\n  simp_rw [Function.comp_def, mul_inv_rev, inv_inv] at this\n  exact this\n\n"}
{"name":"MeasureTheory.quasiMeasurePreserving_add_left","module":"Mathlib.MeasureTheory.Group.Prod","initialProofState":"G : Type u_1\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\nμ : MeasureTheory.Measure G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsAddRightInvariant\ng : G\n⊢ MeasureTheory.Measure.QuasiMeasurePreserving (fun h => HAdd.hAdd g h) μ μ","decl":"/-- A *right*-invariant measure is quasi-preserved by *left*-multiplication.\nThis should not be confused with `(measurePreserving_mul_left μ g).quasiMeasurePreserving`. -/\n@[to_additive\n\"A *right*-invariant measure is quasi-preserved by *left*-addition.\nThis should not be confused with `(measurePreserving_add_left μ g).quasiMeasurePreserving`. \"]\ntheorem quasiMeasurePreserving_mul_left [IsMulRightInvariant μ] (g : G) :\n    QuasiMeasurePreserving (fun h : G => g * h) μ μ := by\n  have :=\n    (quasiMeasurePreserving_mul_right μ.inv g⁻¹).mono (inv_absolutelyContinuous μ.inv)\n      (absolutelyContinuous_inv μ.inv)\n  rw [μ.inv_inv] at this\n  have :=\n    (quasiMeasurePreserving_inv_of_right_invariant μ).comp\n      (this.comp (quasiMeasurePreserving_inv_of_right_invariant μ))\n  simp_rw [Function.comp_def, mul_inv_rev, inv_inv] at this\n  exact this\n\n"}
