{"name":"MeasureTheory.Integrable.comp_neg","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nF : Type u_6\ninst✝⁴ : MeasurableSpace G\ninst✝³ : NormedAddCommGroup F\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableNeg G\ninst✝ : μ.IsNegInvariant\nf : G → F\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun t => f (Neg.neg t)) μ","decl":"@[to_additive]\ntheorem Integrable.comp_inv [IsInvInvariant μ] {f : G → F} (hf : Integrable f μ) :\n    Integrable (fun t => f t⁻¹) μ :=\n  (hf.mono_measure (map_inv_eq_self μ).le).comp_measurable measurable_inv\n\n"}
{"name":"MeasureTheory.Integrable.comp_inv","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nF : Type u_6\ninst✝⁴ : MeasurableSpace G\ninst✝³ : NormedAddCommGroup F\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : MeasurableInv G\ninst✝ : μ.IsInvInvariant\nf : G → F\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun t => f (Inv.inv t)) μ","decl":"@[to_additive]\ntheorem Integrable.comp_inv [IsInvInvariant μ] {f : G → F} (hf : Integrable f μ) :\n    Integrable (fun t => f t⁻¹) μ :=\n  (hf.mono_measure (map_inv_eq_self μ).le).comp_measurable measurable_inv\n\n"}
{"name":"MeasureTheory.integral_inv_eq_self","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : Group G\ninst✝¹ : MeasurableInv G\nf : G → E\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsInvInvariant\n⊢ Eq (MeasureTheory.integral μ fun x => f (Inv.inv x)) (MeasureTheory.integral μ fun x => f x)","decl":"@[to_additive]\ntheorem integral_inv_eq_self (f : G → E) (μ : Measure G) [IsInvInvariant μ] :\n    ∫ x, f x⁻¹ ∂μ = ∫ x, f x ∂μ := by\n  have h : MeasurableEmbedding fun x : G => x⁻¹ := (MeasurableEquiv.inv G).measurableEmbedding\n  rw [← h.integral_map, map_inv_eq_self]\n\n"}
{"name":"MeasureTheory.integral_neg_eq_self","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : AddGroup G\ninst✝¹ : MeasurableNeg G\nf : G → E\nμ : MeasureTheory.Measure G\ninst✝ : μ.IsNegInvariant\n⊢ Eq (MeasureTheory.integral μ fun x => f (Neg.neg x)) (MeasureTheory.integral μ fun x => f x)","decl":"@[to_additive]\ntheorem integral_inv_eq_self (f : G → E) (μ : Measure G) [IsInvInvariant μ] :\n    ∫ x, f x⁻¹ ∂μ = ∫ x, f x ∂μ := by\n  have h : MeasurableEmbedding fun x : G => x⁻¹ := (MeasurableEquiv.inv G).measurableEmbedding\n  rw [← h.integral_map, map_inv_eq_self]\n\n"}
{"name":"MeasureTheory.integral_mul_left_eq_self","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\ninst✝ : μ.IsMulLeftInvariant\nf : G → E\ng : G\n⊢ Eq (MeasureTheory.integral μ fun x => f (HMul.hMul g x)) (MeasureTheory.integral μ fun x => f x)","decl":"/-- Translating a function by left-multiplication does not change its integral with respect to a\nleft-invariant measure. -/\n@[to_additive\n      \"Translating a function by left-addition does not change its integral with respect to a\n      left-invariant measure.\"] -- Porting note: was `@[simp]`\ntheorem integral_mul_left_eq_self [IsMulLeftInvariant μ] (f : G → E) (g : G) :\n    (∫ x, f (g * x) ∂μ) = ∫ x, f x ∂μ := by\n  have h_mul : MeasurableEmbedding fun x => g * x := (MeasurableEquiv.mulLeft g).measurableEmbedding\n  rw [← h_mul.integral_map, map_mul_left_eq_self]\n\n"}
{"name":"MeasureTheory.integral_add_left_eq_self","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\ninst✝ : μ.IsAddLeftInvariant\nf : G → E\ng : G\n⊢ Eq (MeasureTheory.integral μ fun x => f (HAdd.hAdd g x)) (MeasureTheory.integral μ fun x => f x)","decl":"/-- Translating a function by left-multiplication does not change its integral with respect to a\nleft-invariant measure. -/\n@[to_additive\n      \"Translating a function by left-addition does not change its integral with respect to a\n      left-invariant measure.\"] -- Porting note: was `@[simp]`\ntheorem integral_mul_left_eq_self [IsMulLeftInvariant μ] (f : G → E) (g : G) :\n    (∫ x, f (g * x) ∂μ) = ∫ x, f x ∂μ := by\n  have h_mul : MeasurableEmbedding fun x => g * x := (MeasurableEquiv.mulLeft g).measurableEmbedding\n  rw [← h_mul.integral_map, map_mul_left_eq_self]\n\n"}
{"name":"MeasureTheory.integral_mul_right_eq_self","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\ninst✝ : μ.IsMulRightInvariant\nf : G → E\ng : G\n⊢ Eq (MeasureTheory.integral μ fun x => f (HMul.hMul x g)) (MeasureTheory.integral μ fun x => f x)","decl":"/-- Translating a function by right-multiplication does not change its integral with respect to a\nright-invariant measure. -/\n@[to_additive\n      \"Translating a function by right-addition does not change its integral with respect to a\n      right-invariant measure.\"] -- Porting note: was `@[simp]`\ntheorem integral_mul_right_eq_self [IsMulRightInvariant μ] (f : G → E) (g : G) :\n    (∫ x, f (x * g) ∂μ) = ∫ x, f x ∂μ := by\n  have h_mul : MeasurableEmbedding fun x => x * g :=\n    (MeasurableEquiv.mulRight g).measurableEmbedding\n  rw [← h_mul.integral_map, map_mul_right_eq_self]\n\n"}
{"name":"MeasureTheory.integral_add_right_eq_self","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\ninst✝ : μ.IsAddRightInvariant\nf : G → E\ng : G\n⊢ Eq (MeasureTheory.integral μ fun x => f (HAdd.hAdd x g)) (MeasureTheory.integral μ fun x => f x)","decl":"/-- Translating a function by right-multiplication does not change its integral with respect to a\nright-invariant measure. -/\n@[to_additive\n      \"Translating a function by right-addition does not change its integral with respect to a\n      right-invariant measure.\"] -- Porting note: was `@[simp]`\ntheorem integral_mul_right_eq_self [IsMulRightInvariant μ] (f : G → E) (g : G) :\n    (∫ x, f (x * g) ∂μ) = ∫ x, f x ∂μ := by\n  have h_mul : MeasurableEmbedding fun x => x * g :=\n    (MeasurableEquiv.mulRight g).measurableEmbedding\n  rw [← h_mul.integral_map, map_mul_right_eq_self]\n\n"}
{"name":"MeasureTheory.integral_div_right_eq_self","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\ninst✝ : μ.IsMulRightInvariant\nf : G → E\ng : G\n⊢ Eq (MeasureTheory.integral μ fun x => f (HDiv.hDiv x g)) (MeasureTheory.integral μ fun x => f x)","decl":"@[to_additive] -- Porting note: was `@[simp]`\ntheorem integral_div_right_eq_self [IsMulRightInvariant μ] (f : G → E) (g : G) :\n    (∫ x, f (x / g) ∂μ) = ∫ x, f x ∂μ := by\n  simp_rw [div_eq_mul_inv, integral_mul_right_eq_self f g⁻¹]\n\n"}
{"name":"MeasureTheory.integral_sub_right_eq_self","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\ninst✝ : μ.IsAddRightInvariant\nf : G → E\ng : G\n⊢ Eq (MeasureTheory.integral μ fun x => f (HSub.hSub x g)) (MeasureTheory.integral μ fun x => f x)","decl":"@[to_additive] -- Porting note: was `@[simp]`\ntheorem integral_div_right_eq_self [IsMulRightInvariant μ] (f : G → E) (g : G) :\n    (∫ x, f (x / g) ∂μ) = ∫ x, f x ∂μ := by\n  simp_rw [div_eq_mul_inv, integral_mul_right_eq_self f g⁻¹]\n\n"}
{"name":"MeasureTheory.integral_eq_zero_of_mul_left_eq_neg","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nμ : MeasureTheory.Measure G\nf : G → E\ng : G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\ninst✝ : μ.IsMulLeftInvariant\nhf' : ∀ (x : G), Eq (f (HMul.hMul g x)) (Neg.neg (f x))\n⊢ Eq (MeasureTheory.integral μ fun x => f x) 0","decl":"/-- If some left-translate of a function negates it, then the integral of the function with respect\nto a left-invariant measure is 0. -/\n@[to_additive\n      \"If some left-translate of a function negates it, then the integral of the function with\n      respect to a left-invariant measure is 0.\"]\ntheorem integral_eq_zero_of_mul_left_eq_neg [IsMulLeftInvariant μ] (hf' : ∀ x, f (g * x) = -f x) :\n    ∫ x, f x ∂μ = 0 := by\n  simp_rw [← self_eq_neg ℝ E, ← integral_neg, ← hf', integral_mul_left_eq_self]\n\n"}
{"name":"MeasureTheory.integral_eq_zero_of_add_left_eq_neg","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nμ : MeasureTheory.Measure G\nf : G → E\ng : G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\ninst✝ : μ.IsAddLeftInvariant\nhf' : ∀ (x : G), Eq (f (HAdd.hAdd g x)) (Neg.neg (f x))\n⊢ Eq (MeasureTheory.integral μ fun x => f x) 0","decl":"/-- If some left-translate of a function negates it, then the integral of the function with respect\nto a left-invariant measure is 0. -/\n@[to_additive\n      \"If some left-translate of a function negates it, then the integral of the function with\n      respect to a left-invariant measure is 0.\"]\ntheorem integral_eq_zero_of_mul_left_eq_neg [IsMulLeftInvariant μ] (hf' : ∀ x, f (g * x) = -f x) :\n    ∫ x, f x ∂μ = 0 := by\n  simp_rw [← self_eq_neg ℝ E, ← integral_neg, ← hf', integral_mul_left_eq_self]\n\n"}
{"name":"MeasureTheory.integral_eq_zero_of_mul_right_eq_neg","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nμ : MeasureTheory.Measure G\nf : G → E\ng : G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\ninst✝ : μ.IsMulRightInvariant\nhf' : ∀ (x : G), Eq (f (HMul.hMul x g)) (Neg.neg (f x))\n⊢ Eq (MeasureTheory.integral μ fun x => f x) 0","decl":"/-- If some right-translate of a function negates it, then the integral of the function with respect\nto a right-invariant measure is 0. -/\n@[to_additive\n      \"If some right-translate of a function negates it, then the integral of the function with\n      respect to a right-invariant measure is 0.\"]\ntheorem integral_eq_zero_of_mul_right_eq_neg [IsMulRightInvariant μ] (hf' : ∀ x, f (x * g) = -f x) :\n    ∫ x, f x ∂μ = 0 := by\n  simp_rw [← self_eq_neg ℝ E, ← integral_neg, ← hf', integral_mul_right_eq_self]\n\n"}
{"name":"MeasureTheory.integral_eq_zero_of_add_right_eq_neg","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nμ : MeasureTheory.Measure G\nf : G → E\ng : G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\ninst✝ : μ.IsAddRightInvariant\nhf' : ∀ (x : G), Eq (f (HAdd.hAdd x g)) (Neg.neg (f x))\n⊢ Eq (MeasureTheory.integral μ fun x => f x) 0","decl":"/-- If some right-translate of a function negates it, then the integral of the function with respect\nto a right-invariant measure is 0. -/\n@[to_additive\n      \"If some right-translate of a function negates it, then the integral of the function with\n      respect to a right-invariant measure is 0.\"]\ntheorem integral_eq_zero_of_mul_right_eq_neg [IsMulRightInvariant μ] (hf' : ∀ x, f (x * g) = -f x) :\n    ∫ x, f x ∂μ = 0 := by\n  simp_rw [← self_eq_neg ℝ E, ← integral_neg, ← hf', integral_mul_right_eq_self]\n\n"}
{"name":"MeasureTheory.Integrable.comp_add_left","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nF : Type u_6\ninst✝⁴ : MeasurableSpace G\ninst✝³ : NormedAddCommGroup F\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\nf : G → F\ninst✝ : μ.IsAddLeftInvariant\nhf : MeasureTheory.Integrable f μ\ng : G\n⊢ MeasureTheory.Integrable (fun t => f (HAdd.hAdd g t)) μ","decl":"@[to_additive]\ntheorem Integrable.comp_mul_left {f : G → F} [IsMulLeftInvariant μ] (hf : Integrable f μ) (g : G) :\n    Integrable (fun t => f (g * t)) μ :=\n  (hf.mono_measure (map_mul_left_eq_self μ g).le).comp_measurable <| measurable_const_mul g\n\n"}
{"name":"MeasureTheory.Integrable.comp_mul_left","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nF : Type u_6\ninst✝⁴ : MeasurableSpace G\ninst✝³ : NormedAddCommGroup F\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\nf : G → F\ninst✝ : μ.IsMulLeftInvariant\nhf : MeasureTheory.Integrable f μ\ng : G\n⊢ MeasureTheory.Integrable (fun t => f (HMul.hMul g t)) μ","decl":"@[to_additive]\ntheorem Integrable.comp_mul_left {f : G → F} [IsMulLeftInvariant μ] (hf : Integrable f μ) (g : G) :\n    Integrable (fun t => f (g * t)) μ :=\n  (hf.mono_measure (map_mul_left_eq_self μ g).le).comp_measurable <| measurable_const_mul g\n\n"}
{"name":"MeasureTheory.Integrable.comp_mul_right","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nF : Type u_6\ninst✝⁴ : MeasurableSpace G\ninst✝³ : NormedAddCommGroup F\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\nf : G → F\ninst✝ : μ.IsMulRightInvariant\nhf : MeasureTheory.Integrable f μ\ng : G\n⊢ MeasureTheory.Integrable (fun t => f (HMul.hMul t g)) μ","decl":"@[to_additive]\ntheorem Integrable.comp_mul_right {f : G → F} [IsMulRightInvariant μ] (hf : Integrable f μ)\n    (g : G) : Integrable (fun t => f (t * g)) μ :=\n  (hf.mono_measure (map_mul_right_eq_self μ g).le).comp_measurable <| measurable_mul_const g\n\n"}
{"name":"MeasureTheory.Integrable.comp_add_right","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nF : Type u_6\ninst✝⁴ : MeasurableSpace G\ninst✝³ : NormedAddCommGroup F\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\nf : G → F\ninst✝ : μ.IsAddRightInvariant\nhf : MeasureTheory.Integrable f μ\ng : G\n⊢ MeasureTheory.Integrable (fun t => f (HAdd.hAdd t g)) μ","decl":"@[to_additive]\ntheorem Integrable.comp_mul_right {f : G → F} [IsMulRightInvariant μ] (hf : Integrable f μ)\n    (g : G) : Integrable (fun t => f (t * g)) μ :=\n  (hf.mono_measure (map_mul_right_eq_self μ g).le).comp_measurable <| measurable_mul_const g\n\n"}
{"name":"MeasureTheory.Integrable.comp_div_right","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nF : Type u_6\ninst✝⁴ : MeasurableSpace G\ninst✝³ : NormedAddCommGroup F\nμ : MeasureTheory.Measure G\ninst✝² : Group G\ninst✝¹ : MeasurableMul G\nf : G → F\ninst✝ : μ.IsMulRightInvariant\nhf : MeasureTheory.Integrable f μ\ng : G\n⊢ MeasureTheory.Integrable (fun t => f (HDiv.hDiv t g)) μ","decl":"@[to_additive]\ntheorem Integrable.comp_div_right {f : G → F} [IsMulRightInvariant μ] (hf : Integrable f μ)\n    (g : G) : Integrable (fun t => f (t / g)) μ := by\n  simp_rw [div_eq_mul_inv]\n  exact hf.comp_mul_right g⁻¹\n\n"}
{"name":"MeasureTheory.Integrable.comp_sub_right","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nF : Type u_6\ninst✝⁴ : MeasurableSpace G\ninst✝³ : NormedAddCommGroup F\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\nf : G → F\ninst✝ : μ.IsAddRightInvariant\nhf : MeasureTheory.Integrable f μ\ng : G\n⊢ MeasureTheory.Integrable (fun t => f (HSub.hSub t g)) μ","decl":"@[to_additive]\ntheorem Integrable.comp_div_right {f : G → F} [IsMulRightInvariant μ] (hf : Integrable f μ)\n    (g : G) : Integrable (fun t => f (t / g)) μ := by\n  simp_rw [div_eq_mul_inv]\n  exact hf.comp_mul_right g⁻¹\n\n"}
{"name":"MeasureTheory.Integrable.comp_div_left","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nF : Type u_6\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : NormedAddCommGroup F\nμ : MeasureTheory.Measure G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul G\ninst✝² : MeasurableInv G\nf : G → F\ninst✝¹ : μ.IsInvInvariant\ninst✝ : μ.IsMulLeftInvariant\nhf : MeasureTheory.Integrable f μ\ng : G\n⊢ MeasureTheory.Integrable (fun t => f (HDiv.hDiv g t)) μ","decl":"@[to_additive]\ntheorem Integrable.comp_div_left {f : G → F} [IsInvInvariant μ] [IsMulLeftInvariant μ]\n    (hf : Integrable f μ) (g : G) : Integrable (fun t => f (g / t)) μ :=\n  ((measurePreserving_div_left μ g).integrable_comp hf.aestronglyMeasurable).mpr hf\n\n"}
{"name":"MeasureTheory.Integrable.comp_sub_left","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nF : Type u_6\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : NormedAddCommGroup F\nμ : MeasureTheory.Measure G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd G\ninst✝² : MeasurableNeg G\nf : G → F\ninst✝¹ : μ.IsNegInvariant\ninst✝ : μ.IsAddLeftInvariant\nhf : MeasureTheory.Integrable f μ\ng : G\n⊢ MeasureTheory.Integrable (fun t => f (HSub.hSub g t)) μ","decl":"@[to_additive]\ntheorem Integrable.comp_div_left {f : G → F} [IsInvInvariant μ] [IsMulLeftInvariant μ]\n    (hf : Integrable f μ) (g : G) : Integrable (fun t => f (g / t)) μ :=\n  ((measurePreserving_div_left μ g).integrable_comp hf.aestronglyMeasurable).mpr hf\n\n"}
{"name":"MeasureTheory.integrable_comp_div_left","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nF : Type u_6\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : NormedAddCommGroup F\nμ : MeasureTheory.Measure G\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul G\ninst✝² : MeasurableInv G\nf : G → F\ninst✝¹ : μ.IsInvInvariant\ninst✝ : μ.IsMulLeftInvariant\ng : G\n⊢ Iff (MeasureTheory.Integrable (fun t => f (HDiv.hDiv g t)) μ) (MeasureTheory.Integrable f μ)","decl":"@[to_additive] -- Porting note: was `@[simp]`\ntheorem integrable_comp_div_left (f : G → F) [IsInvInvariant μ] [IsMulLeftInvariant μ] (g : G) :\n    Integrable (fun t => f (g / t)) μ ↔ Integrable f μ := by\n  refine ⟨fun h => ?_, fun h => h.comp_div_left g⟩\n  convert h.comp_inv.comp_mul_left g⁻¹\n  simp_rw [div_inv_eq_mul, mul_inv_cancel_left]\n\n"}
{"name":"MeasureTheory.integrable_comp_sub_left","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nF : Type u_6\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : NormedAddCommGroup F\nμ : MeasureTheory.Measure G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd G\ninst✝² : MeasurableNeg G\nf : G → F\ninst✝¹ : μ.IsNegInvariant\ninst✝ : μ.IsAddLeftInvariant\ng : G\n⊢ Iff (MeasureTheory.Integrable (fun t => f (HSub.hSub g t)) μ) (MeasureTheory.Integrable f μ)","decl":"@[to_additive] -- Porting note: was `@[simp]`\ntheorem integrable_comp_div_left (f : G → F) [IsInvInvariant μ] [IsMulLeftInvariant μ] (g : G) :\n    Integrable (fun t => f (g / t)) μ ↔ Integrable f μ := by\n  refine ⟨fun h => ?_, fun h => h.comp_div_left g⟩\n  convert h.comp_inv.comp_mul_left g⁻¹\n  simp_rw [div_inv_eq_mul, mul_inv_cancel_left]\n\n"}
{"name":"MeasureTheory.integral_sub_left_eq_self","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd G\ninst✝² : MeasurableNeg G\nf : G → E\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsNegInvariant\ninst✝ : μ.IsAddLeftInvariant\nx' : G\n⊢ Eq (MeasureTheory.integral μ fun x => f (HSub.hSub x' x)) (MeasureTheory.integral μ fun x => f x)","decl":"@[to_additive] -- Porting note: was `@[simp]`\ntheorem integral_div_left_eq_self (f : G → E) (μ : Measure G) [IsInvInvariant μ]\n    [IsMulLeftInvariant μ] (x' : G) : (∫ x, f (x' / x) ∂μ) = ∫ x, f x ∂μ := by\n  simp_rw [div_eq_mul_inv, integral_inv_eq_self (fun x => f (x' * x)) μ,\n    integral_mul_left_eq_self f x']\n\n"}
{"name":"MeasureTheory.integral_div_left_eq_self","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"G : Type u_4\nE : Type u_5\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : Group G\ninst✝³ : MeasurableMul G\ninst✝² : MeasurableInv G\nf : G → E\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsInvInvariant\ninst✝ : μ.IsMulLeftInvariant\nx' : G\n⊢ Eq (MeasureTheory.integral μ fun x => f (HDiv.hDiv x' x)) (MeasureTheory.integral μ fun x => f x)","decl":"@[to_additive] -- Porting note: was `@[simp]`\ntheorem integral_div_left_eq_self (f : G → E) (μ : Measure G) [IsInvInvariant μ]\n    [IsMulLeftInvariant μ] (x' : G) : (∫ x, f (x' / x) ∂μ) = ∫ x, f x ∂μ := by\n  simp_rw [div_eq_mul_inv, integral_inv_eq_self (fun x => f (x' * x)) μ,\n    integral_mul_left_eq_self f x']\n\n"}
{"name":"MeasureTheory.integral_smul_eq_self","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"α : Type u_3\nG : Type u_4\nE : Type u_5\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : Group G\ninst✝³ : MeasurableSpace α\ninst✝² : MulAction G α\ninst✝¹ : MeasurableSMul G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nf : α → E\ng : G\n⊢ Eq (MeasureTheory.integral μ fun x => f (HSMul.hSMul g x)) (MeasureTheory.integral μ fun x => f x)","decl":"@[to_additive] -- Porting note: was `@[simp]`\ntheorem integral_smul_eq_self {μ : Measure α} [SMulInvariantMeasure G α μ] (f : α → E) {g : G} :\n    (∫ x, f (g • x) ∂μ) = ∫ x, f x ∂μ := by\n  have h : MeasurableEmbedding fun x : α => g • x := (MeasurableEquiv.smul g).measurableEmbedding\n  rw [← h.integral_map, map_smul]\n\n"}
{"name":"MeasureTheory.integral_vadd_eq_self","module":"Mathlib.MeasureTheory.Group.Integral","initialProofState":"α : Type u_3\nG : Type u_4\nE : Type u_5\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableSpace α\ninst✝² : AddAction G α\ninst✝¹ : MeasurableVAdd G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nf : α → E\ng : G\n⊢ Eq (MeasureTheory.integral μ fun x => f (HVAdd.hVAdd g x)) (MeasureTheory.integral μ fun x => f x)","decl":"@[to_additive] -- Porting note: was `@[simp]`\ntheorem integral_smul_eq_self {μ : Measure α} [SMulInvariantMeasure G α μ] (f : α → E) {g : G} :\n    (∫ x, f (g • x) ∂μ) = ∫ x, f x ∂μ := by\n  have h : MeasurableEmbedding fun x : α => g • x := (MeasurableEquiv.smul g).measurableEmbedding\n  rw [← h.integral_map, map_smul]\n\n"}
