{"name":"List.formPerm_disjoint_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\nhl : l.Nodup\nhl' : l'.Nodup\nhn : LE.le 2 l.length\nhn' : LE.le 2 l'.length\n⊢ Iff (l.formPerm.Disjoint l'.formPerm) (l.Disjoint l')","decl":"theorem formPerm_disjoint_iff (hl : Nodup l) (hl' : Nodup l') (hn : 2 ≤ l.length)\n    (hn' : 2 ≤ l'.length) : Perm.Disjoint (formPerm l) (formPerm l') ↔ l.Disjoint l' := by\n  rw [disjoint_iff_eq_or_eq, List.Disjoint]\n  constructor\n  · rintro h x hx hx'\n    specialize h x\n    rw [formPerm_apply_mem_eq_self_iff _ hl _ hx, formPerm_apply_mem_eq_self_iff _ hl' _ hx'] at h\n    omega\n  · intro h x\n    by_cases hx : x ∈ l\n    on_goal 1 => by_cases hx' : x ∈ l'\n    · exact (h hx hx').elim\n    all_goals have := formPerm_eq_self_of_not_mem _ _ ‹_›; tauto\n\n"}
{"name":"List.isCycle_formPerm","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\nhn : LE.le 2 l.length\n⊢ l.formPerm.IsCycle","decl":"theorem isCycle_formPerm (hl : Nodup l) (hn : 2 ≤ l.length) : IsCycle (formPerm l) := by\n  cases' l with x l\n  · norm_num at hn\n  induction' l with y l generalizing x\n  · norm_num at hn\n  · use x\n    constructor\n    · rwa [formPerm_apply_mem_ne_self_iff _ hl _ (mem_cons_self _ _)]\n    · intro w hw\n      have : w ∈ x::y::l := mem_of_formPerm_ne_self _ _ hw\n      obtain ⟨k, hk, rfl⟩ := getElem_of_mem this\n      use k\n      simp only [zpow_natCast, formPerm_pow_apply_head _ _ hl k, Nat.mod_eq_of_lt hk]\n\n"}
{"name":"List.pairwise_sameCycle_formPerm","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\nhn : LE.le 2 l.length\n⊢ List.Pairwise l.formPerm.SameCycle l","decl":"theorem pairwise_sameCycle_formPerm (hl : Nodup l) (hn : 2 ≤ l.length) :\n    Pairwise l.formPerm.SameCycle l :=\n  Pairwise.imp_mem.mpr\n    (pairwise_of_forall fun _ _ hx hy =>\n      (isCycle_formPerm hl hn).sameCycle ((formPerm_apply_mem_ne_self_iff _ hl _ hx).mpr hn)\n        ((formPerm_apply_mem_ne_self_iff _ hl _ hy).mpr hn))\n\n"}
{"name":"List.cycleOf_formPerm","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\nhn : LE.le 2 l.length\nx : Subtype fun x => Membership.mem l x\n⊢ Eq (l.attach.formPerm.cycleOf x) l.attach.formPerm","decl":"theorem cycleOf_formPerm (hl : Nodup l) (hn : 2 ≤ l.length) (x) :\n    cycleOf l.attach.formPerm x = l.attach.formPerm :=\n  have hn : 2 ≤ l.attach.length := by rwa [← length_attach] at hn\n  have hl : l.attach.Nodup := by rwa [← nodup_attach] at hl\n  (isCycle_formPerm hl hn).cycleOf_eq\n    ((formPerm_apply_mem_ne_self_iff _ hl _ (mem_attach _ _)).mpr hn)\n\n"}
{"name":"List.cycleType_formPerm","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\nhn : LE.le 2 l.length\n⊢ Eq l.attach.formPerm.cycleType (Singleton.singleton l.length)","decl":"theorem cycleType_formPerm (hl : Nodup l) (hn : 2 ≤ l.length) :\n    cycleType l.attach.formPerm = {l.length} := by\n  rw [← length_attach] at hn\n  rw [← nodup_attach] at hl\n  rw [cycleType_eq [l.attach.formPerm]]\n  · simp only [map, Function.comp_apply]\n    rw [support_formPerm_of_nodup _ hl, card_toFinset, dedup_eq_self.mpr hl]\n    · simp\n    · intro x h\n      simp [h, Nat.succ_le_succ_iff] at hn\n  · simp\n  · simpa using isCycle_formPerm hl hn\n  · simp\n\n"}
{"name":"List.formPerm_apply_mem_eq_next","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\nx : α\nhx : Membership.mem l x\n⊢ Eq (l.formPerm x) (l.next x hx)","decl":"theorem formPerm_apply_mem_eq_next (hl : Nodup l) (x : α) (hx : x ∈ l) :\n    formPerm l x = next l x hx := by\n  obtain ⟨k, rfl⟩ := get_of_mem hx\n  rw [next_get _ hl, get_eq_getElem, formPerm_apply_getElem _ hl]; rfl\n\n"}
{"name":"Cycle.formPerm_coe","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nhl : l.Nodup\n⊢ Eq ((↑l).formPerm hl) l.formPerm","decl":"@[simp]\ntheorem formPerm_coe (l : List α) (hl : l.Nodup) : formPerm (l : Cycle α) hl = l.formPerm :=\n  rfl\n\n"}
{"name":"Cycle.formPerm_subsingleton","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\nh : s.Subsingleton\n⊢ Eq (s.formPerm ⋯) 1","decl":"theorem formPerm_subsingleton (s : Cycle α) (h : Subsingleton s) : formPerm s h.nodup = 1 := by\n  induction' s using Quot.inductionOn with s\n  simp only [formPerm_coe, mk_eq_coe]\n  simp only [length_subsingleton_iff, length_coe, mk_eq_coe] at h\n  cases' s with hd tl\n  · simp\n  · simp only [length_eq_zero, add_le_iff_nonpos_left, List.length, nonpos_iff_eq_zero] at h\n    simp [h]\n\n"}
{"name":"Cycle.isCycle_formPerm","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\nh : s.Nodup\nhn : s.Nontrivial\n⊢ (s.formPerm h).IsCycle","decl":"theorem isCycle_formPerm (s : Cycle α) (h : Nodup s) (hn : Nontrivial s) :\n    IsCycle (formPerm s h) := by\n  induction s using Quot.inductionOn\n  exact List.isCycle_formPerm h (length_nontrivial hn)\n\n"}
{"name":"Cycle.support_formPerm","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Cycle α\nh : s.Nodup\nhn : s.Nontrivial\n⊢ Eq (s.formPerm h).support s.toFinset","decl":"theorem support_formPerm [Fintype α] (s : Cycle α) (h : Nodup s) (hn : Nontrivial s) :\n    support (formPerm s h) = s.toFinset := by\n  induction' s using Quot.inductionOn with s\n  refine support_formPerm_of_nodup s h ?_\n  rintro _ rfl\n  simpa [Nat.succ_le_succ_iff] using length_nontrivial hn\n\n"}
{"name":"Cycle.formPerm_eq_self_of_not_mem","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\nh : s.Nodup\nx : α\nhx : Not (Membership.mem s x)\n⊢ Eq ((s.formPerm h) x) x","decl":"theorem formPerm_eq_self_of_not_mem (s : Cycle α) (h : Nodup s) (x : α) (hx : x ∉ s) :\n    formPerm s h x = x := by\n  induction s using Quot.inductionOn\n  simpa using List.formPerm_eq_self_of_not_mem _ _ hx\n\n"}
{"name":"Cycle.formPerm_apply_mem_eq_next","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\nh : s.Nodup\nx : α\nhx : Membership.mem s x\n⊢ Eq ((s.formPerm h) x) (s.next h x hx)","decl":"theorem formPerm_apply_mem_eq_next (s : Cycle α) (h : Nodup s) (x : α) (hx : x ∈ s) :\n    formPerm s h x = next s h x hx := by\n  induction s using Quot.inductionOn\n  simpa using List.formPerm_apply_mem_eq_next h _ (by simp_all)\n\n"}
{"name":"Cycle.formPerm_reverse","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Cycle α\nh : s.Nodup\n⊢ Eq (s.reverse.formPerm ⋯) (Inv.inv (s.formPerm h))","decl":"nonrec theorem formPerm_reverse (s : Cycle α) (h : Nodup s) :\n    formPerm s.reverse (nodup_reverse_iff.mpr h) = (formPerm s h)⁻¹ := by\n  induction s using Quot.inductionOn\n  simpa using formPerm_reverse _\n\n"}
{"name":"Cycle.formPerm_eq_formPerm_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\ns s' : Cycle α\nhs : s.Nodup\nhs' : s'.Nodup\n⊢ Iff (Eq (s.formPerm hs) (s'.formPerm hs')) (Or (Eq s s') (And s.Subsingleton s'.Subsingleton))","decl":"nonrec theorem formPerm_eq_formPerm_iff {α : Type*} [DecidableEq α] {s s' : Cycle α} {hs : s.Nodup}\n    {hs' : s'.Nodup} :\n    s.formPerm hs = s'.formPerm hs' ↔ s = s' ∨ s.Subsingleton ∧ s'.Subsingleton := by\n  rw [Cycle.length_subsingleton_iff, Cycle.length_subsingleton_iff]\n  revert s s'\n  intro s s'\n  apply @Quotient.inductionOn₂' _ _ _ _ _ s s'\n  intro l l' hl hl'\n  simpa using formPerm_eq_formPerm_iff hl hl'\n\n"}
{"name":"Equiv.Perm.toList_one","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nx : α\n⊢ Eq (Equiv.Perm.toList 1 x) List.nil","decl":"@[simp]\ntheorem toList_one : toList (1 : Perm α) x = [] := by simp [toList, cycleOf_one]\n\n"}
{"name":"Equiv.Perm.toList_eq_nil_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\np : Equiv.Perm α\nx : α\n⊢ Iff (Eq (p.toList x) List.nil) (Not (Membership.mem p.support x))","decl":"@[simp]\ntheorem toList_eq_nil_iff {p : Perm α} {x} : toList p x = [] ↔ x ∉ p.support := by simp [toList]\n\n"}
{"name":"Equiv.Perm.length_toList","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\np : Equiv.Perm α\nx : α\n⊢ Eq (p.toList x).length (p.cycleOf x).support.card","decl":"@[simp]\ntheorem length_toList : length (toList p x) = (cycleOf p x).support.card := by simp [toList]\n\n"}
{"name":"Equiv.Perm.toList_ne_singleton","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\np : Equiv.Perm α\nx y : α\n⊢ Ne (p.toList x) (List.cons y List.nil)","decl":"theorem toList_ne_singleton (y : α) : toList p x ≠ [y] := by\n  intro H\n  simpa [card_support_ne_one] using congr_arg length H\n\n"}
{"name":"Equiv.Perm.two_le_length_toList_iff_mem_support","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\np : Equiv.Perm α\nx : α\n⊢ Iff (LE.le 2 (p.toList x).length) (Membership.mem p.support x)","decl":"theorem two_le_length_toList_iff_mem_support {p : Perm α} {x : α} :\n    2 ≤ length (toList p x) ↔ x ∈ p.support := by simp\n\n"}
{"name":"Equiv.Perm.length_toList_pos_of_mem_support","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\np : Equiv.Perm α\nx : α\nh : Membership.mem p.support x\n⊢ LT.lt 0 (p.toList x).length","decl":"theorem length_toList_pos_of_mem_support (h : x ∈ p.support) : 0 < length (toList p x) :=\n  zero_lt_two.trans_le (two_le_length_toList_iff_mem_support.mpr h)\n\n"}
{"name":"Equiv.Perm.get_toList","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\np : Equiv.Perm α\nx : α\nn : Nat\nhn : LT.lt n (p.toList x).length\n⊢ Eq ((p.toList x).get ⟨n, hn⟩) ((HPow.hPow p n) x)","decl":"theorem get_toList (n : ℕ) (hn : n < length (toList p x)) :\n    (toList p x).get ⟨n, hn⟩ = (p ^ n) x := by simp [toList]\n\n"}
{"name":"Equiv.Perm.toList_get_zero","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\np : Equiv.Perm α\nx : α\nh : Membership.mem p.support x\n⊢ Eq ((p.toList x).get ⟨0, ⋯⟩) x","decl":"theorem toList_get_zero (h : x ∈ p.support) :\n    (toList p x).get ⟨0, (length_toList_pos_of_mem_support _ _ h)⟩ = x := by simp [toList]\n\n"}
{"name":"Equiv.Perm.mem_toList_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\np : Equiv.Perm α\nx y : α\n⊢ Iff (Membership.mem (p.toList x) y) (And (p.SameCycle x y) (Membership.mem p.support x))","decl":"theorem mem_toList_iff {y : α} : y ∈ toList p x ↔ SameCycle p x y ∧ x ∈ p.support := by\n  simp only [toList, mem_iterate, iterate_eq_pow, eq_comm (a := y)]\n  constructor\n  · rintro ⟨n, hx, rfl⟩\n    refine ⟨⟨n, rfl⟩, ?_⟩\n    contrapose! hx\n    rw [← support_cycleOf_eq_nil_iff] at hx\n    simp [hx]\n  · rintro ⟨h, hx⟩\n    simpa using h.exists_pow_eq_of_mem_support hx\n\n"}
{"name":"Equiv.Perm.nodup_toList","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\np : Equiv.Perm α\nx : α\n⊢ (p.toList x).Nodup","decl":"theorem nodup_toList (p : Perm α) (x : α) : Nodup (toList p x) := by\n  by_cases hx : p x = x\n  · rw [← not_mem_support, ← toList_eq_nil_iff] at hx\n    simp [hx]\n  have hc : IsCycle (cycleOf p x) := isCycle_cycleOf p hx\n  rw [nodup_iff_injective_get]\n  intro ⟨n, hn⟩ ⟨m, hm⟩\n  rw [length_toList, ← hc.orderOf] at hm hn\n  rw [← cycleOf_apply_self, ← Ne, ← mem_support] at hx\n  rw [get_toList, get_toList, ← cycleOf_pow_apply_self p x n, ←\n    cycleOf_pow_apply_self p x m]\n  cases' n with n <;> cases' m with m\n  · simp\n  · rw [← hc.support_pow_of_pos_of_lt_orderOf m.zero_lt_succ hm, mem_support,\n      cycleOf_pow_apply_self] at hx\n    simp [hx.symm]\n  · rw [← hc.support_pow_of_pos_of_lt_orderOf n.zero_lt_succ hn, mem_support,\n      cycleOf_pow_apply_self] at hx\n    simp [hx]\n  intro h\n  have hn' : ¬orderOf (p.cycleOf x) ∣ n.succ := Nat.not_dvd_of_pos_of_lt n.zero_lt_succ hn\n  have hm' : ¬orderOf (p.cycleOf x) ∣ m.succ := Nat.not_dvd_of_pos_of_lt m.zero_lt_succ hm\n  rw [← hc.support_pow_eq_iff] at hn' hm'\n  rw [Fin.mk_eq_mk, ← Nat.mod_eq_of_lt hn, ← Nat.mod_eq_of_lt hm, ← pow_inj_mod]\n  refine support_congr ?_ ?_\n  · rw [hm', hn']\n  · rw [hm']\n    intro y hy\n    obtain ⟨k, rfl⟩ := hc.exists_pow_eq (mem_support.mp hx) (mem_support.mp hy)\n    rw [← mul_apply, (Commute.pow_pow_self _ _ _).eq, mul_apply, h, ← mul_apply, ← mul_apply,\n      (Commute.pow_pow_self _ _ _).eq]\n\n"}
{"name":"Equiv.Perm.next_toList_eq_apply","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\np : Equiv.Perm α\nx y : α\nhy : Membership.mem (p.toList x) y\n⊢ Eq ((p.toList x).next y hy) (p y)","decl":"theorem next_toList_eq_apply (p : Perm α) (x y : α) (hy : y ∈ toList p x) :\n    next (toList p x) y hy = p y := by\n  rw [mem_toList_iff] at hy\n  obtain ⟨k, hk, hk'⟩ := hy.left.exists_pow_eq_of_mem_support hy.right\n  rw [← get_toList p x k (by simpa using hk)] at hk'\n  simp_rw [← hk']\n  rw [next_get _ (nodup_toList _ _), get_toList, get_toList, ← mul_apply, ← pow_succ']\n  simp_rw [length_toList]\n  rw [← pow_mod_orderOf_cycleOf_apply p (k + 1), IsCycle.orderOf]\n  exact isCycle_cycleOf _ (mem_support.mp hy.right)\n\n"}
{"name":"Equiv.Perm.toList_pow_apply_eq_rotate","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\np : Equiv.Perm α\nx : α\nk : Nat\n⊢ Eq (p.toList ((HPow.hPow p k) x)) ((p.toList x).rotate k)","decl":"theorem toList_pow_apply_eq_rotate (p : Perm α) (x : α) (k : ℕ) :\n    p.toList ((p ^ k) x) = (p.toList x).rotate k := by\n  apply ext_get\n  · simp only [length_toList, cycleOf_self_apply_pow, length_rotate]\n  · intro n hn hn'\n    rw [get_toList, get_rotate, get_toList, length_toList,\n      pow_mod_card_support_cycleOf_self_apply, pow_add, mul_apply]\n\n"}
{"name":"Equiv.Perm.SameCycle.toList_isRotated","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nx y : α\nh : f.SameCycle x y\n⊢ (f.toList x).IsRotated (f.toList y)","decl":"theorem SameCycle.toList_isRotated {f : Perm α} {x y : α} (h : SameCycle f x y) :\n    toList f x ~r toList f y := by\n  by_cases hx : x ∈ f.support\n  · obtain ⟨_ | k, _, hy⟩ := h.exists_pow_eq_of_mem_support hx\n    · simp only [coe_one, id, pow_zero] at hy\n      -- Porting note: added `IsRotated.refl`\n      simp [hy, IsRotated.refl]\n    use k.succ\n    rw [← toList_pow_apply_eq_rotate, hy]\n  · rw [toList_eq_nil_iff.mpr hx, isRotated_nil_iff', eq_comm, toList_eq_nil_iff]\n    rwa [← h.mem_support_iff]\n\n"}
{"name":"Equiv.Perm.pow_apply_mem_toList_iff_mem_support","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\np : Equiv.Perm α\nx : α\nn : Nat\n⊢ Iff (Membership.mem (p.toList x) ((HPow.hPow p n) x)) (Membership.mem p.support x)","decl":"theorem pow_apply_mem_toList_iff_mem_support {n : ℕ} : (p ^ n) x ∈ p.toList x ↔ x ∈ p.support := by\n  rw [mem_toList_iff, and_iff_right_iff_imp]\n  refine fun _ => SameCycle.symm ?_\n  rw [sameCycle_pow_left]\n\n"}
{"name":"Equiv.Perm.toList_formPerm_nil","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nx : α\n⊢ Eq (List.nil.formPerm.toList x) List.nil","decl":"theorem toList_formPerm_nil (x : α) : toList (formPerm ([] : List α)) x = [] := by simp\n\n"}
{"name":"Equiv.Perm.toList_formPerm_singleton","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nx y : α\n⊢ Eq ((List.cons x List.nil).formPerm.toList y) List.nil","decl":"theorem toList_formPerm_singleton (x y : α) : toList (formPerm [x]) y = [] := by simp\n\n"}
{"name":"Equiv.Perm.toList_formPerm_nontrivial","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nl : List α\nhl : LE.le 2 l.length\nhn : l.Nodup\n⊢ Eq (l.formPerm.toList (l.get ⟨0, ⋯⟩)) l","decl":"theorem toList_formPerm_nontrivial (l : List α) (hl : 2 ≤ l.length) (hn : Nodup l) :\n    toList (formPerm l) (l.get ⟨0, (zero_lt_two.trans_le hl)⟩) = l := by\n  have hc : l.formPerm.IsCycle := List.isCycle_formPerm hn hl\n  have hs : l.formPerm.support = l.toFinset := by\n    refine support_formPerm_of_nodup _ hn ?_\n    rintro _ rfl\n    simp [Nat.succ_le_succ_iff] at hl\n  rw [toList, hc.cycleOf_eq (mem_support.mp _), hs, card_toFinset, dedup_eq_self.mpr hn]\n  · refine ext_getElem (by simp) fun k hk hk' => ?_\n    simp only [get_eq_getElem, getElem_iterate, iterate_eq_pow, formPerm_pow_apply_getElem _ hn,\n      zero_add, Nat.mod_eq_of_lt hk']\n  · simp [hs]\n\n"}
{"name":"Equiv.Perm.toList_formPerm_isRotated_self","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nl : List α\nhl : LE.le 2 l.length\nhn : l.Nodup\nx : α\nhx : Membership.mem l x\n⊢ (l.formPerm.toList x).IsRotated l","decl":"theorem toList_formPerm_isRotated_self (l : List α) (hl : 2 ≤ l.length) (hn : Nodup l) (x : α)\n    (hx : x ∈ l) : toList (formPerm l) x ~r l := by\n  obtain ⟨k, hk, rfl⟩ := get_of_mem hx\n  have hr : l ~r l.rotate k := ⟨k, rfl⟩\n  rw [formPerm_eq_of_isRotated hn hr]\n  rw [get_eq_get_rotate l k k]\n  simp only [Nat.mod_eq_of_lt k.2, tsub_add_cancel_of_le (le_of_lt k.2), Nat.mod_self]\n  rw [toList_formPerm_nontrivial]\n  · simp\n  · simpa using hl\n  · simpa using hn\n\n"}
{"name":"Equiv.Perm.formPerm_toList","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nx : α\n⊢ Eq (f.toList x).formPerm (f.cycleOf x)","decl":"theorem formPerm_toList (f : Perm α) (x : α) : formPerm (toList f x) = f.cycleOf x := by\n  by_cases hx : f x = x\n  · rw [(cycleOf_eq_one_iff f).mpr hx, toList_eq_nil_iff.mpr (not_mem_support.mpr hx),\n      formPerm_nil]\n  ext y\n  by_cases hy : SameCycle f x y\n  · obtain ⟨k, _, rfl⟩ := hy.exists_pow_eq_of_mem_support (mem_support.mpr hx)\n    rw [cycleOf_apply_apply_pow_self, List.formPerm_apply_mem_eq_next (nodup_toList f x),\n      next_toList_eq_apply, pow_succ', mul_apply]\n    rw [mem_toList_iff]\n    exact ⟨⟨k, rfl⟩, mem_support.mpr hx⟩\n  · rw [cycleOf_apply_of_not_sameCycle hy, formPerm_apply_of_not_mem]\n    simp [mem_toList_iff, hy]\n\n"}
{"name":"Equiv.Perm.toCycle_eq_toList","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nhf : f.IsCycle\nx : α\nhx : Ne (f x) x\n⊢ Eq (f.toCycle hf) ↑(f.toList x)","decl":"theorem toCycle_eq_toList (f : Perm α) (hf : IsCycle f) (x : α) (hx : f x ≠ x) :\n    toCycle f hf = toList f x := by\n  have key : (Finset.univ : Finset α).val = x ::ₘ Finset.univ.val.erase x := by simp\n  rw [toCycle, key]\n  simp [hx]\n\n"}
{"name":"Equiv.Perm.nodup_toCycle","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nhf : f.IsCycle\n⊢ (f.toCycle hf).Nodup","decl":"theorem nodup_toCycle (f : Perm α) (hf : IsCycle f) : (toCycle f hf).Nodup := by\n  obtain ⟨x, hx, -⟩ := id hf\n  simpa [toCycle_eq_toList f hf x hx] using nodup_toList _ _\n\n"}
{"name":"Equiv.Perm.nontrivial_toCycle","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nhf : f.IsCycle\n⊢ (f.toCycle hf).Nontrivial","decl":"theorem nontrivial_toCycle (f : Perm α) (hf : IsCycle f) : (toCycle f hf).Nontrivial := by\n  obtain ⟨x, hx, -⟩ := id hf\n  simp [toCycle_eq_toList f hf x hx, hx, Cycle.nontrivial_coe_nodup_iff (nodup_toList _ _)]\n\n"}
{"name":"Equiv.Perm.IsCycle.existsUnique_cycle","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Finite α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nhf : f.IsCycle\n⊢ ExistsUnique fun s => Exists fun h => Eq (s.formPerm h) f","decl":"theorem IsCycle.existsUnique_cycle {f : Perm α} (hf : IsCycle f) :\n    ∃! s : Cycle α, ∃ h : s.Nodup, s.formPerm h = f := by\n  cases nonempty_fintype α\n  obtain ⟨x, hx, hy⟩ := id hf\n  refine ⟨f.toList x, ⟨nodup_toList f x, ?_⟩, ?_⟩\n  · simp [formPerm_toList, hf.cycleOf_eq hx]\n  · rintro ⟨l⟩ ⟨hn, rfl⟩\n    simp only [Cycle.mk_eq_coe, Cycle.coe_eq_coe, Subtype.coe_mk, Cycle.formPerm_coe]\n    refine (toList_formPerm_isRotated_self _ ?_ hn _ ?_).symm\n    · contrapose! hx\n      suffices formPerm l = 1 by simp [this]\n      rw [formPerm_eq_one_iff _ hn]\n      exact Nat.le_of_lt_succ hx\n    · rw [← mem_toFinset]\n      refine support_formPerm_le l ?_\n      simpa using hx\n\n"}
{"name":"Equiv.Perm.IsCycle.existsUnique_cycle_subtype","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Finite α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nhf : f.IsCycle\n⊢ ExistsUnique fun s => Eq ((↑s).formPerm ⋯) f","decl":"theorem IsCycle.existsUnique_cycle_subtype {f : Perm α} (hf : IsCycle f) :\n    ∃! s : { s : Cycle α // s.Nodup }, (s : Cycle α).formPerm s.prop = f := by\n  obtain ⟨s, ⟨hs, rfl⟩, hs'⟩ := hf.existsUnique_cycle\n  refine ⟨⟨s, hs⟩, rfl, ?_⟩\n  rintro ⟨t, ht⟩ ht'\n  simpa using hs' _ ⟨ht, ht'⟩\n\n"}
{"name":"Equiv.Perm.IsCycle.existsUnique_cycle_nontrivial_subtype","module":"Mathlib.GroupTheory.Perm.Cycle.Concrete","initialProofState":"α : Type u_1\ninst✝¹ : Finite α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nhf : f.IsCycle\n⊢ ExistsUnique fun s => Eq ((↑s).formPerm ⋯) f","decl":"theorem IsCycle.existsUnique_cycle_nontrivial_subtype {f : Perm α} (hf : IsCycle f) :\n    ∃! s : { s : Cycle α // s.Nodup ∧ s.Nontrivial }, (s : Cycle α).formPerm s.prop.left = f := by\n  obtain ⟨⟨s, hn⟩, hs, hs'⟩ := hf.existsUnique_cycle_subtype\n  refine ⟨⟨s, hn, ?_⟩, ?_, ?_⟩\n  · rw [hn.nontrivial_iff]\n    subst f\n    intro H\n    refine hf.ne_one ?_\n    simpa using Cycle.formPerm_subsingleton _ H\n  · simpa using hs\n  · rintro ⟨t, ht, ht'⟩ ht''\n    simpa using hs' ⟨t, ht⟩ ht''\n\n"}
