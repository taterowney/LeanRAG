{"name":"GradedRing.toGradedMonoid","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddMonoid ι\ninst✝² : Semiring A\ninst✝¹ : SetLike σ A\ninst✝ : AddSubmonoidClass σ A\n𝒜 : ι → σ\nself : GradedRing 𝒜\n⊢ SetLike.GradedMonoid 𝒜","decl":"/-- An internally-graded `R`-algebra `A` is one that can be decomposed into a collection\nof `Submodule R A`s indexed by `ι` such that the canonical map `A → ⨁ i, 𝒜 i` is bijective and\nrespects multiplication, i.e. the product of an element of degree `i` and an element of degree `j`\nis an element of degree `i + j`.\n\nNote that the fact that `A` is internally-graded, `GradedAlgebra 𝒜`, implies an externally-graded\nalgebra structure `DirectSum.GAlgebra R (fun i ↦ ↥(𝒜 i))`, which in turn makes available an\n`Algebra R (⨁ i, 𝒜 i)` instance.\n-/\nclass GradedRing (𝒜 : ι → σ) extends SetLike.GradedMonoid 𝒜, DirectSum.Decomposition 𝒜\n\n"}
{"name":"DirectSum.decompose_one","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : Semiring A\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\n⊢ Eq ((DirectSum.decompose 𝒜) 1) 1","decl":"@[simp]\ntheorem decompose_one : decompose 𝒜 (1 : A) = 1 :=\n  map_one (decomposeRingEquiv 𝒜)\n\n"}
{"name":"DirectSum.decompose_symm_one","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : Semiring A\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\n⊢ Eq ((DirectSum.decompose 𝒜).symm 1) 1","decl":"@[simp]\ntheorem decompose_symm_one : (decompose 𝒜).symm 1 = (1 : A) :=\n  map_one (decomposeRingEquiv 𝒜).symm\n\n"}
{"name":"DirectSum.decompose_mul","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : Semiring A\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\nx y : A\n⊢ Eq ((DirectSum.decompose 𝒜) (HMul.hMul x y)) (HMul.hMul ((DirectSum.decompose 𝒜) x) ((DirectSum.decompose 𝒜) y))","decl":"@[simp]\ntheorem decompose_mul (x y : A) : decompose 𝒜 (x * y) = decompose 𝒜 x * decompose 𝒜 y :=\n  map_mul (decomposeRingEquiv 𝒜) x y\n\n"}
{"name":"DirectSum.decompose_symm_mul","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : Semiring A\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\nx y : DirectSum ι fun i => Subtype fun x => Membership.mem (𝒜 i) x\n⊢ Eq ((DirectSum.decompose 𝒜).symm (HMul.hMul x y)) (HMul.hMul ((DirectSum.decompose 𝒜).symm x) ((DirectSum.decompose 𝒜).symm y))","decl":"@[simp]\ntheorem decompose_symm_mul (x y : ⨁ i, 𝒜 i) :\n    (decompose 𝒜).symm (x * y) = (decompose 𝒜).symm x * (decompose 𝒜).symm y :=\n  map_mul (decomposeRingEquiv 𝒜).symm x y\n\n"}
{"name":"GradedRing.proj_apply","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : Semiring A\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\ni : ι\nr : A\n⊢ Eq ((GradedRing.proj 𝒜 i) r) ↑(((DirectSum.decompose 𝒜) r) i)","decl":"@[simp]\ntheorem GradedRing.proj_apply (i : ι) (r : A) :\n    GradedRing.proj 𝒜 i r = (decompose 𝒜 r : ⨁ i, 𝒜 i) i :=\n  rfl\n\n"}
{"name":"GradedRing.proj_recompose","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : Semiring A\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\na : DirectSum ι fun i => Subtype fun x => Membership.mem (𝒜 i) x\ni : ι\n⊢ Eq ((GradedRing.proj 𝒜 i) ((DirectSum.decompose 𝒜).symm a)) ((DirectSum.decompose 𝒜).symm ((DirectSum.of (fun i => Subtype fun x => Membership.mem (𝒜 i) x) i) (a i)))","decl":"theorem GradedRing.proj_recompose (a : ⨁ i, 𝒜 i) (i : ι) :\n    GradedRing.proj 𝒜 i ((decompose 𝒜).symm a) = (decompose 𝒜).symm (DirectSum.of _ i (a i)) := by\n  rw [GradedRing.proj_apply, decompose_symm_of, Equiv.apply_symm_apply]\n\n"}
{"name":"GradedRing.mem_support_iff","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : AddMonoid ι\ninst✝⁴ : Semiring A\ninst✝³ : SetLike σ A\ninst✝² : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝¹ : GradedRing 𝒜\ninst✝ : (i : ι) → (x : Subtype fun x => Membership.mem (𝒜 i) x) → Decidable (Ne x 0)\nr : A\ni : ι\n⊢ Iff (Membership.mem (DFinsupp.support ((DirectSum.decompose 𝒜) r)) i) (Ne ((GradedRing.proj 𝒜 i) r) 0)","decl":"theorem GradedRing.mem_support_iff [∀ (i) (x : 𝒜 i), Decidable (x ≠ 0)] (r : A) (i : ι) :\n    i ∈ (decompose 𝒜 r).support ↔ GradedRing.proj 𝒜 i r ≠ 0 :=\n  DFinsupp.mem_support_iff.trans ZeroMemClass.coe_eq_zero.not.symm\n\n"}
{"name":"DirectSum.coe_decompose_mul_add_of_left_mem","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Semiring A\ninst✝³ : SetLike σ A\ninst✝² : AddSubmonoidClass σ A\n𝒜 : ι → σ\ni j : ι\ninst✝¹ : AddLeftCancelMonoid ι\ninst✝ : GradedRing 𝒜\na b : A\na_mem : Membership.mem (𝒜 i) a\n⊢ Eq (↑(((DirectSum.decompose 𝒜) (HMul.hMul a b)) (HAdd.hAdd i j))) (HMul.hMul a ↑(((DirectSum.decompose 𝒜) b) j))","decl":"theorem coe_decompose_mul_add_of_left_mem [AddLeftCancelMonoid ι] [GradedRing 𝒜] {a b : A}\n    (a_mem : a ∈ 𝒜 i) : (decompose 𝒜 (a * b) (i + j) : A) = a * decompose 𝒜 b j := by\n  lift a to 𝒜 i using a_mem\n  rw [decompose_mul, decompose_coe, coe_of_mul_apply_add]\n\n"}
{"name":"DirectSum.coe_decompose_mul_add_of_right_mem","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Semiring A\ninst✝³ : SetLike σ A\ninst✝² : AddSubmonoidClass σ A\n𝒜 : ι → σ\ni j : ι\ninst✝¹ : AddRightCancelMonoid ι\ninst✝ : GradedRing 𝒜\na b : A\nb_mem : Membership.mem (𝒜 j) b\n⊢ Eq (↑(((DirectSum.decompose 𝒜) (HMul.hMul a b)) (HAdd.hAdd i j))) (HMul.hMul (↑(((DirectSum.decompose 𝒜) a) i)) b)","decl":"theorem coe_decompose_mul_add_of_right_mem [AddRightCancelMonoid ι] [GradedRing 𝒜] {a b : A}\n    (b_mem : b ∈ 𝒜 j) : (decompose 𝒜 (a * b) (i + j) : A) = decompose 𝒜 a i * b := by\n  lift b to 𝒜 j using b_mem\n  rw [decompose_mul, decompose_coe, coe_mul_of_apply_add]\n\n"}
{"name":"DirectSum.decompose_mul_add_left","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Semiring A\ninst✝³ : SetLike σ A\ninst✝² : AddSubmonoidClass σ A\n𝒜 : ι → σ\ni j : ι\ninst✝¹ : AddLeftCancelMonoid ι\ninst✝ : GradedRing 𝒜\na : Subtype fun x => Membership.mem (𝒜 i) x\nb : A\n⊢ Eq (((DirectSum.decompose 𝒜) (HMul.hMul (↑a) b)) (HAdd.hAdd i j)) (GradedMonoid.GMul.mul a (((DirectSum.decompose 𝒜) b) j))","decl":"theorem decompose_mul_add_left [AddLeftCancelMonoid ι] [GradedRing 𝒜] (a : 𝒜 i) {b : A} :\n    decompose 𝒜 (↑a * b) (i + j) =\n      @GradedMonoid.GMul.mul ι (fun i => 𝒜 i) _ _ _ _ a (decompose 𝒜 b j) :=\n  Subtype.ext <| coe_decompose_mul_add_of_left_mem 𝒜 a.2\n\n"}
{"name":"DirectSum.decompose_mul_add_right","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Semiring A\ninst✝³ : SetLike σ A\ninst✝² : AddSubmonoidClass σ A\n𝒜 : ι → σ\ni j : ι\ninst✝¹ : AddRightCancelMonoid ι\ninst✝ : GradedRing 𝒜\na : A\nb : Subtype fun x => Membership.mem (𝒜 j) x\n⊢ Eq (((DirectSum.decompose 𝒜) (HMul.hMul a ↑b)) (HAdd.hAdd i j)) (GradedMonoid.GMul.mul (((DirectSum.decompose 𝒜) a) i) b)","decl":"theorem decompose_mul_add_right [AddRightCancelMonoid ι] [GradedRing 𝒜] {a : A} (b : 𝒜 j) :\n    decompose 𝒜 (a * ↑b) (i + j) =\n      @GradedMonoid.GMul.mul ι (fun i => 𝒜 i) _ _ _ _ (decompose 𝒜 a i) b :=\n  Subtype.ext <| coe_decompose_mul_add_of_right_mem 𝒜 b.2\n\n"}
{"name":"DirectSum.decomposeAlgEquiv_apply","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : CommSemiring R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\n𝒜 : ι → Submodule R A\ninst✝ : GradedAlgebra 𝒜\na : A\n⊢ Eq ((DirectSum.decomposeAlgEquiv 𝒜) a) ((DirectSum.decompose 𝒜) a)","decl":"@[simp]\nlemma decomposeAlgEquiv_apply (a : A) :\n    decomposeAlgEquiv 𝒜 a = decompose 𝒜 a := rfl\n\n"}
{"name":"DirectSum.decomposeAlgEquiv_symm_apply","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : CommSemiring R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\n𝒜 : ι → Submodule R A\ninst✝ : GradedAlgebra 𝒜\na : DirectSum ι fun i => Subtype fun x => Membership.mem (𝒜 i) x\n⊢ Eq ((DirectSum.decomposeAlgEquiv 𝒜).symm a) ((DirectSum.decompose 𝒜).symm a)","decl":"@[simp]\nlemma decomposeAlgEquiv_symm_apply (a : ⨁ i, 𝒜 i) :\n    (decomposeAlgEquiv 𝒜).symm a = (decompose 𝒜).symm a := rfl\n\n"}
{"name":"DirectSum.decompose_algebraMap","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : CommSemiring R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\n𝒜 : ι → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nr : R\n⊢ Eq ((DirectSum.decompose 𝒜) ((algebraMap R A) r)) ((algebraMap R (DirectSum ι fun i => Subtype fun x => Membership.mem (𝒜 i) x)) r)","decl":"@[simp]\nlemma decompose_algebraMap (r : R) :\n    decompose 𝒜 (algebraMap R A r) = algebraMap R (⨁ i, 𝒜 i) r :=\n  (decomposeAlgEquiv 𝒜).commutes r\n\n"}
{"name":"DirectSum.decompose_symm_algebraMap","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : CommSemiring R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\n𝒜 : ι → Submodule R A\ninst✝ : GradedAlgebra 𝒜\nr : R\n⊢ Eq ((DirectSum.decompose 𝒜).symm ((algebraMap R (DirectSum ι fun i => Subtype fun x => Membership.mem (𝒜 i) x)) r)) ((algebraMap R A) r)","decl":"@[simp]\nlemma decompose_symm_algebraMap (r : R) :\n    (decompose 𝒜).symm (algebraMap R (⨁ i, 𝒜 i) r) = algebraMap R A r :=\n  (decomposeAlgEquiv 𝒜).symm.commutes r\n\n"}
{"name":"GradedAlgebra.proj_apply","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : CommSemiring R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\n𝒜 : ι → Submodule R A\ninst✝ : GradedAlgebra 𝒜\ni : ι\nr : A\n⊢ Eq ((GradedAlgebra.proj 𝒜 i) r) ↑(((DirectSum.decompose 𝒜) r) i)","decl":"@[simp]\ntheorem GradedAlgebra.proj_apply (i : ι) (r : A) :\n    GradedAlgebra.proj 𝒜 i r = (decompose 𝒜 r : ⨁ i, 𝒜 i) i :=\n  rfl\n\n"}
{"name":"GradedAlgebra.proj_recompose","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : CommSemiring R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\n𝒜 : ι → Submodule R A\ninst✝ : GradedAlgebra 𝒜\na : DirectSum ι fun i => Subtype fun x => Membership.mem (𝒜 i) x\ni : ι\n⊢ Eq ((GradedAlgebra.proj 𝒜 i) ((DirectSum.decompose 𝒜).symm a)) ((DirectSum.decompose 𝒜).symm ((DirectSum.of (fun i => Subtype fun x => Membership.mem (𝒜 i) x) i) (a i)))","decl":"theorem GradedAlgebra.proj_recompose (a : ⨁ i, 𝒜 i) (i : ι) :\n    GradedAlgebra.proj 𝒜 i ((decompose 𝒜).symm a) = (decompose 𝒜).symm (of _ i (a i)) := by\n  rw [GradedAlgebra.proj_apply, decompose_symm_of, Equiv.apply_symm_apply]\n\n"}
{"name":"GradedAlgebra.mem_support_iff","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nR : Type u_2\nA : Type u_3\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : AddMonoid ι\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\n𝒜 : ι → Submodule R A\ninst✝¹ : GradedAlgebra 𝒜\ninst✝ : DecidableEq A\nr : A\ni : ι\n⊢ Iff (Membership.mem (DFinsupp.support ((DirectSum.decompose 𝒜) r)) i) (Ne ((GradedAlgebra.proj 𝒜 i) r) 0)","decl":"theorem GradedAlgebra.mem_support_iff [DecidableEq A] (r : A) (i : ι) :\n    i ∈ (decompose 𝒜 r).support ↔ GradedAlgebra.proj 𝒜 i r ≠ 0 :=\n  DFinsupp.mem_support_iff.trans Submodule.coe_eq_zero.not.symm\n\n"}
{"name":"GradedRing.projZeroRingHom_apply","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁵ : Semiring A\ninst✝⁴ : DecidableEq ι\ninst✝³ : AddCommMonoid ι\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\na : A\n⊢ Eq ((GradedRing.projZeroRingHom 𝒜) a) ↑(((DirectSum.decompose 𝒜) a) 0)","decl":"/-- If `A` is graded by a canonically ordered add monoid, then the projection map `x ↦ x₀` is a ring\nhomomorphism.\n-/\n@[simps]\ndef GradedRing.projZeroRingHom : A →+* A where\n  toFun a := decompose 𝒜 a 0\n  map_one' :=\n    -- Porting note: qualified `one_mem`\n    decompose_of_mem_same 𝒜 SetLike.GradedOne.one_mem\n  map_zero' := by\n    simp only -- Porting note: added\n    rw [decompose_zero]\n    rfl\n  map_add' _ _ := by\n    simp only -- Porting note: added\n    rw [decompose_add]\n    rfl\n  map_mul' := by\n    refine DirectSum.Decomposition.inductionOn 𝒜 (fun x => ?_) ?_ ?_\n    · simp only [zero_mul, decompose_zero, zero_apply, ZeroMemClass.coe_zero]\n    · rintro i ⟨c, hc⟩\n      refine DirectSum.Decomposition.inductionOn 𝒜 ?_ ?_ ?_\n      · simp only [mul_zero, decompose_zero, zero_apply, ZeroMemClass.coe_zero]\n      · rintro j ⟨c', hc'⟩\n        simp only [Subtype.coe_mk]\n        by_cases h : i + j = 0\n        · rw [decompose_of_mem_same 𝒜\n              (show c * c' ∈ 𝒜 0 from h ▸ SetLike.GradedMul.mul_mem hc hc'),\n            decompose_of_mem_same 𝒜 (show c ∈ 𝒜 0 from (add_eq_zero.mp h).1 ▸ hc),\n            decompose_of_mem_same 𝒜 (show c' ∈ 𝒜 0 from (add_eq_zero.mp h).2 ▸ hc')]\n        · rw [decompose_of_mem_ne 𝒜 (SetLike.GradedMul.mul_mem hc hc') h]\n          cases' show i ≠ 0 ∨ j ≠ 0 by rwa [add_eq_zero, not_and_or] at h with h' h'\n          · simp only [decompose_of_mem_ne 𝒜 hc h', zero_mul]\n          · simp only [decompose_of_mem_ne 𝒜 hc' h', mul_zero]\n      · intro _ _ hd he\n        simp only at hd he -- Porting note: added\n        simp only [mul_add, decompose_add, add_apply, AddMemClass.coe_add, hd, he]\n    · rintro _ _ ha hb _\n      simp only at ha hb -- Porting note: added\n      simp only [add_mul, decompose_add, add_apply, AddMemClass.coe_add, ha, hb]\n\n"}
{"name":"GradedRing.coe_projZeroRingHom'_apply","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁷ : Semiring A\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : AddCommMonoid ι\ninst✝⁴ : PartialOrder ι\ninst✝³ : CanonicallyOrderedAdd ι\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\na : A\n⊢ Eq (↑((GradedRing.projZeroRingHom' 𝒜) a)) ((GradedRing.projZeroRingHom 𝒜) a)","decl":"@[simp] lemma GradedRing.coe_projZeroRingHom'_apply (a : A) :\n    (GradedRing.projZeroRingHom' 𝒜 a : A) = GradedRing.projZeroRingHom 𝒜 a := rfl\n\n"}
{"name":"GradedRing.projZeroRingHom'_apply_coe","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁷ : Semiring A\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : AddCommMonoid ι\ninst✝⁴ : PartialOrder ι\ninst✝³ : CanonicallyOrderedAdd ι\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\na : Subtype fun x => Membership.mem (𝒜 0) x\n⊢ Eq ((GradedRing.projZeroRingHom' 𝒜) ↑a) a","decl":"@[simp] lemma GradedRing.projZeroRingHom'_apply_coe (a : 𝒜 0) :\n    GradedRing.projZeroRingHom' 𝒜 a = a := by\n  ext; simp only [coe_projZeroRingHom'_apply, projZeroRingHom_apply, decompose_coe, of_eq_same]\n\n"}
{"name":"GradedRing.projZeroRingHom'_surjective","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁷ : Semiring A\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : AddCommMonoid ι\ninst✝⁴ : PartialOrder ι\ninst✝³ : CanonicallyOrderedAdd ι\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\n⊢ Function.Surjective ⇑(GradedRing.projZeroRingHom' 𝒜)","decl":"/-- The ring homomorphism `GradedRing.projZeroRingHom' 𝒜` is surjective. -/\nlemma GradedRing.projZeroRingHom'_surjective :\n    Function.Surjective (GradedRing.projZeroRingHom' 𝒜) :=\n  Function.RightInverse.surjective (GradedRing.projZeroRingHom'_apply_coe 𝒜)\n\n"}
{"name":"DirectSum.coe_decompose_mul_of_left_mem_of_not_le","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁷ : Semiring A\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : AddCommMonoid ι\ninst✝⁴ : PartialOrder ι\ninst✝³ : CanonicallyOrderedAdd ι\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\na b : A\nn i : ι\na_mem : Membership.mem (𝒜 i) a\nh : Not (LE.le i n)\n⊢ Eq (↑(((DirectSum.decompose 𝒜) (HMul.hMul a b)) n)) 0","decl":"theorem coe_decompose_mul_of_left_mem_of_not_le (a_mem : a ∈ 𝒜 i) (h : ¬i ≤ n) :\n    (decompose 𝒜 (a * b) n : A) = 0 := by\n  lift a to 𝒜 i using a_mem\n  rwa [decompose_mul, decompose_coe, coe_of_mul_apply_of_not_le]\n\n"}
{"name":"DirectSum.coe_decompose_mul_of_right_mem_of_not_le","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝⁷ : Semiring A\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : AddCommMonoid ι\ninst✝⁴ : PartialOrder ι\ninst✝³ : CanonicallyOrderedAdd ι\ninst✝² : SetLike σ A\ninst✝¹ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝ : GradedRing 𝒜\na b : A\nn i : ι\nb_mem : Membership.mem (𝒜 i) b\nh : Not (LE.le i n)\n⊢ Eq (↑(((DirectSum.decompose 𝒜) (HMul.hMul a b)) n)) 0","decl":"theorem coe_decompose_mul_of_right_mem_of_not_le (b_mem : b ∈ 𝒜 i) (h : ¬i ≤ n) :\n    (decompose 𝒜 (a * b) n : A) = 0 := by\n  lift b to 𝒜 i using b_mem\n  rwa [decompose_mul, decompose_coe, coe_mul_of_apply_of_not_le]\n\n"}
{"name":"DirectSum.coe_decompose_mul_of_left_mem_of_le","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝¹⁰ : Semiring A\ninst✝⁹ : DecidableEq ι\ninst✝⁸ : AddCommMonoid ι\ninst✝⁷ : PartialOrder ι\ninst✝⁶ : CanonicallyOrderedAdd ι\ninst✝⁵ : SetLike σ A\ninst✝⁴ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝³ : GradedRing 𝒜\na b : A\nn i : ι\ninst✝² : Sub ι\ninst✝¹ : OrderedSub ι\ninst✝ : AddLeftReflectLE ι\na_mem : Membership.mem (𝒜 i) a\nh : LE.le i n\n⊢ Eq (↑(((DirectSum.decompose 𝒜) (HMul.hMul a b)) n)) (HMul.hMul a ↑(((DirectSum.decompose 𝒜) b) (HSub.hSub n i)))","decl":"theorem coe_decompose_mul_of_left_mem_of_le (a_mem : a ∈ 𝒜 i) (h : i ≤ n) :\n    (decompose 𝒜 (a * b) n : A) = a * decompose 𝒜 b (n - i) := by\n  lift a to 𝒜 i using a_mem\n  rwa [decompose_mul, decompose_coe, coe_of_mul_apply_of_le]\n\n"}
{"name":"DirectSum.coe_decompose_mul_of_right_mem_of_le","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝¹⁰ : Semiring A\ninst✝⁹ : DecidableEq ι\ninst✝⁸ : AddCommMonoid ι\ninst✝⁷ : PartialOrder ι\ninst✝⁶ : CanonicallyOrderedAdd ι\ninst✝⁵ : SetLike σ A\ninst✝⁴ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝³ : GradedRing 𝒜\na b : A\nn i : ι\ninst✝² : Sub ι\ninst✝¹ : OrderedSub ι\ninst✝ : AddLeftReflectLE ι\nb_mem : Membership.mem (𝒜 i) b\nh : LE.le i n\n⊢ Eq (↑(((DirectSum.decompose 𝒜) (HMul.hMul a b)) n)) (HMul.hMul (↑(((DirectSum.decompose 𝒜) a) (HSub.hSub n i))) b)","decl":"theorem coe_decompose_mul_of_right_mem_of_le (b_mem : b ∈ 𝒜 i) (h : i ≤ n) :\n    (decompose 𝒜 (a * b) n : A) = decompose 𝒜 a (n - i) * b := by\n  lift b to 𝒜 i using b_mem\n  rwa [decompose_mul, decompose_coe, coe_mul_of_apply_of_le]\n\n"}
{"name":"DirectSum.coe_decompose_mul_of_left_mem","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : DecidableEq ι\ninst✝⁹ : AddCommMonoid ι\ninst✝⁸ : PartialOrder ι\ninst✝⁷ : CanonicallyOrderedAdd ι\ninst✝⁶ : SetLike σ A\ninst✝⁵ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝⁴ : GradedRing 𝒜\na b : A\ni : ι\ninst✝³ : Sub ι\ninst✝² : OrderedSub ι\ninst✝¹ : AddLeftReflectLE ι\nn : ι\ninst✝ : Decidable (LE.le i n)\na_mem : Membership.mem (𝒜 i) a\n⊢ Eq (↑(((DirectSum.decompose 𝒜) (HMul.hMul a b)) n)) (ite (LE.le i n) (HMul.hMul a ↑(((DirectSum.decompose 𝒜) b) (HSub.hSub n i))) 0)","decl":"theorem coe_decompose_mul_of_left_mem (n) [Decidable (i ≤ n)] (a_mem : a ∈ 𝒜 i) :\n    (decompose 𝒜 (a * b) n : A) = if i ≤ n then a * decompose 𝒜 b (n - i) else 0 := by\n  lift a to 𝒜 i using a_mem\n  rw [decompose_mul, decompose_coe, coe_of_mul_apply]\n\n"}
{"name":"DirectSum.coe_decompose_mul_of_right_mem","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"ι : Type u_1\nA : Type u_3\nσ : Type u_4\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : DecidableEq ι\ninst✝⁹ : AddCommMonoid ι\ninst✝⁸ : PartialOrder ι\ninst✝⁷ : CanonicallyOrderedAdd ι\ninst✝⁶ : SetLike σ A\ninst✝⁵ : AddSubmonoidClass σ A\n𝒜 : ι → σ\ninst✝⁴ : GradedRing 𝒜\na b : A\ni : ι\ninst✝³ : Sub ι\ninst✝² : OrderedSub ι\ninst✝¹ : AddLeftReflectLE ι\nn : ι\ninst✝ : Decidable (LE.le i n)\nb_mem : Membership.mem (𝒜 i) b\n⊢ Eq (↑(((DirectSum.decompose 𝒜) (HMul.hMul a b)) n)) (ite (LE.le i n) (HMul.hMul (↑(((DirectSum.decompose 𝒜) a) (HSub.hSub n i))) b) 0)","decl":"theorem coe_decompose_mul_of_right_mem (n) [Decidable (i ≤ n)] (b_mem : b ∈ 𝒜 i) :\n    (decompose 𝒜 (a * b) n : A) = if i ≤ n then decompose 𝒜 a (n - i) * b else 0 := by\n  lift b to 𝒜 i using b_mem\n  rw [decompose_mul, decompose_coe, coe_mul_of_apply]\n\n"}
