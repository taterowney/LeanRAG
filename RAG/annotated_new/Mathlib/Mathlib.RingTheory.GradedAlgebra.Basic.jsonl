{"name":"GradedRing.toGradedMonoid","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâ´ : DecidableEq Î¹\ninstâœÂ³ : AddMonoid Î¹\ninstâœÂ² : Semiring A\ninstâœÂ¹ : SetLike Ïƒ A\ninstâœ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\nself : GradedRing ğ’œ\nâŠ¢ SetLike.GradedMonoid ğ’œ","decl":"/-- An internally-graded `R`-algebra `A` is one that can be decomposed into a collection\nof `Submodule R A`s indexed by `Î¹` such that the canonical map `A â†’ â¨ i, ğ’œ i` is bijective and\nrespects multiplication, i.e. the product of an element of degree `i` and an element of degree `j`\nis an element of degree `i + j`.\n\nNote that the fact that `A` is internally-graded, `GradedAlgebra ğ’œ`, implies an externally-graded\nalgebra structure `DirectSum.GAlgebra R (fun i â†¦ â†¥(ğ’œ i))`, which in turn makes available an\n`Algebra R (â¨ i, ğ’œ i)` instance.\n-/\nclass GradedRing (ğ’œ : Î¹ â†’ Ïƒ) extends SetLike.GradedMonoid ğ’œ, DirectSum.Decomposition ğ’œ\n\n"}
{"name":"DirectSum.decompose_one","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : AddMonoid Î¹\ninstâœÂ³ : Semiring A\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\nâŠ¢ Eq ((DirectSum.decompose ğ’œ) 1) 1","decl":"@[simp]\ntheorem decompose_one : decompose ğ’œ (1 : A) = 1 :=\n  map_one (decomposeRingEquiv ğ’œ)\n\n"}
{"name":"DirectSum.decompose_symm_one","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : AddMonoid Î¹\ninstâœÂ³ : Semiring A\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\nâŠ¢ Eq ((DirectSum.decompose ğ’œ).symm 1) 1","decl":"@[simp]\ntheorem decompose_symm_one : (decompose ğ’œ).symm 1 = (1 : A) :=\n  map_one (decomposeRingEquiv ğ’œ).symm\n\n"}
{"name":"DirectSum.decompose_mul","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : AddMonoid Î¹\ninstâœÂ³ : Semiring A\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\nx y : A\nâŠ¢ Eq ((DirectSum.decompose ğ’œ) (HMul.hMul x y)) (HMul.hMul ((DirectSum.decompose ğ’œ) x) ((DirectSum.decompose ğ’œ) y))","decl":"@[simp]\ntheorem decompose_mul (x y : A) : decompose ğ’œ (x * y) = decompose ğ’œ x * decompose ğ’œ y :=\n  map_mul (decomposeRingEquiv ğ’œ) x y\n\n"}
{"name":"DirectSum.decompose_symm_mul","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : AddMonoid Î¹\ninstâœÂ³ : Semiring A\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\nx y : DirectSum Î¹ fun i => Subtype fun x => Membership.mem (ğ’œ i) x\nâŠ¢ Eq ((DirectSum.decompose ğ’œ).symm (HMul.hMul x y)) (HMul.hMul ((DirectSum.decompose ğ’œ).symm x) ((DirectSum.decompose ğ’œ).symm y))","decl":"@[simp]\ntheorem decompose_symm_mul (x y : â¨ i, ğ’œ i) :\n    (decompose ğ’œ).symm (x * y) = (decompose ğ’œ).symm x * (decompose ğ’œ).symm y :=\n  map_mul (decomposeRingEquiv ğ’œ).symm x y\n\n"}
{"name":"GradedRing.proj_apply","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : AddMonoid Î¹\ninstâœÂ³ : Semiring A\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\ni : Î¹\nr : A\nâŠ¢ Eq ((GradedRing.proj ğ’œ i) r) â†‘(((DirectSum.decompose ğ’œ) r) i)","decl":"@[simp]\ntheorem GradedRing.proj_apply (i : Î¹) (r : A) :\n    GradedRing.proj ğ’œ i r = (decompose ğ’œ r : â¨ i, ğ’œ i) i :=\n  rfl\n\n"}
{"name":"GradedRing.proj_recompose","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : AddMonoid Î¹\ninstâœÂ³ : Semiring A\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\na : DirectSum Î¹ fun i => Subtype fun x => Membership.mem (ğ’œ i) x\ni : Î¹\nâŠ¢ Eq ((GradedRing.proj ğ’œ i) ((DirectSum.decompose ğ’œ).symm a)) ((DirectSum.decompose ğ’œ).symm ((DirectSum.of (fun i => Subtype fun x => Membership.mem (ğ’œ i) x) i) (a i)))","decl":"theorem GradedRing.proj_recompose (a : â¨ i, ğ’œ i) (i : Î¹) :\n    GradedRing.proj ğ’œ i ((decompose ğ’œ).symm a) = (decompose ğ’œ).symm (DirectSum.of _ i (a i)) := by\n  rw [GradedRing.proj_apply, decompose_symm_of, Equiv.apply_symm_apply]\n\n"}
{"name":"GradedRing.mem_support_iff","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâ¶ : DecidableEq Î¹\ninstâœâµ : AddMonoid Î¹\ninstâœâ´ : Semiring A\ninstâœÂ³ : SetLike Ïƒ A\ninstâœÂ² : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœÂ¹ : GradedRing ğ’œ\ninstâœ : (i : Î¹) â†’ (x : Subtype fun x => Membership.mem (ğ’œ i) x) â†’ Decidable (Ne x 0)\nr : A\ni : Î¹\nâŠ¢ Iff (Membership.mem (DFinsupp.support ((DirectSum.decompose ğ’œ) r)) i) (Ne ((GradedRing.proj ğ’œ i) r) 0)","decl":"theorem GradedRing.mem_support_iff [âˆ€ (i) (x : ğ’œ i), Decidable (x â‰  0)] (r : A) (i : Î¹) :\n    i âˆˆ (decompose ğ’œ r).support â†” GradedRing.proj ğ’œ i r â‰  0 :=\n  DFinsupp.mem_support_iff.trans ZeroMemClass.coe_eq_zero.not.symm\n\n"}
{"name":"DirectSum.coe_decompose_mul_add_of_left_mem","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : Semiring A\ninstâœÂ³ : SetLike Ïƒ A\ninstâœÂ² : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ni j : Î¹\ninstâœÂ¹ : AddLeftCancelMonoid Î¹\ninstâœ : GradedRing ğ’œ\na b : A\na_mem : Membership.mem (ğ’œ i) a\nâŠ¢ Eq (â†‘(((DirectSum.decompose ğ’œ) (HMul.hMul a b)) (HAdd.hAdd i j))) (HMul.hMul a â†‘(((DirectSum.decompose ğ’œ) b) j))","decl":"theorem coe_decompose_mul_add_of_left_mem [AddLeftCancelMonoid Î¹] [GradedRing ğ’œ] {a b : A}\n    (a_mem : a âˆˆ ğ’œ i) : (decompose ğ’œ (a * b) (i + j) : A) = a * decompose ğ’œ b j := by\n  lift a to ğ’œ i using a_mem\n  rw [decompose_mul, decompose_coe, coe_of_mul_apply_add]\n\n"}
{"name":"DirectSum.coe_decompose_mul_add_of_right_mem","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : Semiring A\ninstâœÂ³ : SetLike Ïƒ A\ninstâœÂ² : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ni j : Î¹\ninstâœÂ¹ : AddRightCancelMonoid Î¹\ninstâœ : GradedRing ğ’œ\na b : A\nb_mem : Membership.mem (ğ’œ j) b\nâŠ¢ Eq (â†‘(((DirectSum.decompose ğ’œ) (HMul.hMul a b)) (HAdd.hAdd i j))) (HMul.hMul (â†‘(((DirectSum.decompose ğ’œ) a) i)) b)","decl":"theorem coe_decompose_mul_add_of_right_mem [AddRightCancelMonoid Î¹] [GradedRing ğ’œ] {a b : A}\n    (b_mem : b âˆˆ ğ’œ j) : (decompose ğ’œ (a * b) (i + j) : A) = decompose ğ’œ a i * b := by\n  lift b to ğ’œ j using b_mem\n  rw [decompose_mul, decompose_coe, coe_mul_of_apply_add]\n\n"}
{"name":"DirectSum.decompose_mul_add_left","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : Semiring A\ninstâœÂ³ : SetLike Ïƒ A\ninstâœÂ² : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ni j : Î¹\ninstâœÂ¹ : AddLeftCancelMonoid Î¹\ninstâœ : GradedRing ğ’œ\na : Subtype fun x => Membership.mem (ğ’œ i) x\nb : A\nâŠ¢ Eq (((DirectSum.decompose ğ’œ) (HMul.hMul (â†‘a) b)) (HAdd.hAdd i j)) (GradedMonoid.GMul.mul a (((DirectSum.decompose ğ’œ) b) j))","decl":"theorem decompose_mul_add_left [AddLeftCancelMonoid Î¹] [GradedRing ğ’œ] (a : ğ’œ i) {b : A} :\n    decompose ğ’œ (â†‘a * b) (i + j) =\n      @GradedMonoid.GMul.mul Î¹ (fun i => ğ’œ i) _ _ _ _ a (decompose ğ’œ b j) :=\n  Subtype.ext <| coe_decompose_mul_add_of_left_mem ğ’œ a.2\n\n"}
{"name":"DirectSum.decompose_mul_add_right","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : Semiring A\ninstâœÂ³ : SetLike Ïƒ A\ninstâœÂ² : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ni j : Î¹\ninstâœÂ¹ : AddRightCancelMonoid Î¹\ninstâœ : GradedRing ğ’œ\na : A\nb : Subtype fun x => Membership.mem (ğ’œ j) x\nâŠ¢ Eq (((DirectSum.decompose ğ’œ) (HMul.hMul a â†‘b)) (HAdd.hAdd i j)) (GradedMonoid.GMul.mul (((DirectSum.decompose ğ’œ) a) i) b)","decl":"theorem decompose_mul_add_right [AddRightCancelMonoid Î¹] [GradedRing ğ’œ] {a : A} (b : ğ’œ j) :\n    decompose ğ’œ (a * â†‘b) (i + j) =\n      @GradedMonoid.GMul.mul Î¹ (fun i => ğ’œ i) _ _ _ _ (decompose ğ’œ a i) b :=\n  Subtype.ext <| coe_decompose_mul_add_of_right_mem ğ’œ b.2\n\n"}
{"name":"DirectSum.decomposeAlgEquiv_apply","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : AddMonoid Î¹\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : Semiring A\ninstâœÂ¹ : Algebra R A\nğ’œ : Î¹ â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\na : A\nâŠ¢ Eq ((DirectSum.decomposeAlgEquiv ğ’œ) a) ((DirectSum.decompose ğ’œ) a)","decl":"@[simp]\nlemma decomposeAlgEquiv_apply (a : A) :\n    decomposeAlgEquiv ğ’œ a = decompose ğ’œ a := rfl\n\n"}
{"name":"DirectSum.decomposeAlgEquiv_symm_apply","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : AddMonoid Î¹\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : Semiring A\ninstâœÂ¹ : Algebra R A\nğ’œ : Î¹ â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\na : DirectSum Î¹ fun i => Subtype fun x => Membership.mem (ğ’œ i) x\nâŠ¢ Eq ((DirectSum.decomposeAlgEquiv ğ’œ).symm a) ((DirectSum.decompose ğ’œ).symm a)","decl":"@[simp]\nlemma decomposeAlgEquiv_symm_apply (a : â¨ i, ğ’œ i) :\n    (decomposeAlgEquiv ğ’œ).symm a = (decompose ğ’œ).symm a := rfl\n\n"}
{"name":"DirectSum.decompose_algebraMap","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : AddMonoid Î¹\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : Semiring A\ninstâœÂ¹ : Algebra R A\nğ’œ : Î¹ â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\nr : R\nâŠ¢ Eq ((DirectSum.decompose ğ’œ) ((algebraMap R A) r)) ((algebraMap R (DirectSum Î¹ fun i => Subtype fun x => Membership.mem (ğ’œ i) x)) r)","decl":"@[simp]\nlemma decompose_algebraMap (r : R) :\n    decompose ğ’œ (algebraMap R A r) = algebraMap R (â¨ i, ğ’œ i) r :=\n  (decomposeAlgEquiv ğ’œ).commutes r\n\n"}
{"name":"DirectSum.decompose_symm_algebraMap","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : AddMonoid Î¹\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : Semiring A\ninstâœÂ¹ : Algebra R A\nğ’œ : Î¹ â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\nr : R\nâŠ¢ Eq ((DirectSum.decompose ğ’œ).symm ((algebraMap R (DirectSum Î¹ fun i => Subtype fun x => Membership.mem (ğ’œ i) x)) r)) ((algebraMap R A) r)","decl":"@[simp]\nlemma decompose_symm_algebraMap (r : R) :\n    (decompose ğ’œ).symm (algebraMap R (â¨ i, ğ’œ i) r) = algebraMap R A r :=\n  (decomposeAlgEquiv ğ’œ).symm.commutes r\n\n"}
{"name":"GradedAlgebra.proj_apply","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : AddMonoid Î¹\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : Semiring A\ninstâœÂ¹ : Algebra R A\nğ’œ : Î¹ â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\ni : Î¹\nr : A\nâŠ¢ Eq ((GradedAlgebra.proj ğ’œ i) r) â†‘(((DirectSum.decompose ğ’œ) r) i)","decl":"@[simp]\ntheorem GradedAlgebra.proj_apply (i : Î¹) (r : A) :\n    GradedAlgebra.proj ğ’œ i r = (decompose ğ’œ r : â¨ i, ğ’œ i) i :=\n  rfl\n\n"}
{"name":"GradedAlgebra.proj_recompose","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâµ : DecidableEq Î¹\ninstâœâ´ : AddMonoid Î¹\ninstâœÂ³ : CommSemiring R\ninstâœÂ² : Semiring A\ninstâœÂ¹ : Algebra R A\nğ’œ : Î¹ â†’ Submodule R A\ninstâœ : GradedAlgebra ğ’œ\na : DirectSum Î¹ fun i => Subtype fun x => Membership.mem (ğ’œ i) x\ni : Î¹\nâŠ¢ Eq ((GradedAlgebra.proj ğ’œ i) ((DirectSum.decompose ğ’œ).symm a)) ((DirectSum.decompose ğ’œ).symm ((DirectSum.of (fun i => Subtype fun x => Membership.mem (ğ’œ i) x) i) (a i)))","decl":"theorem GradedAlgebra.proj_recompose (a : â¨ i, ğ’œ i) (i : Î¹) :\n    GradedAlgebra.proj ğ’œ i ((decompose ğ’œ).symm a) = (decompose ğ’œ).symm (of _ i (a i)) := by\n  rw [GradedAlgebra.proj_apply, decompose_symm_of, Equiv.apply_symm_apply]\n\n"}
{"name":"GradedAlgebra.mem_support_iff","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nR : Type u_2\nA : Type u_3\ninstâœâ¶ : DecidableEq Î¹\ninstâœâµ : AddMonoid Î¹\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : Semiring A\ninstâœÂ² : Algebra R A\nğ’œ : Î¹ â†’ Submodule R A\ninstâœÂ¹ : GradedAlgebra ğ’œ\ninstâœ : DecidableEq A\nr : A\ni : Î¹\nâŠ¢ Iff (Membership.mem (DFinsupp.support ((DirectSum.decompose ğ’œ) r)) i) (Ne ((GradedAlgebra.proj ğ’œ i) r) 0)","decl":"theorem GradedAlgebra.mem_support_iff [DecidableEq A] (r : A) (i : Î¹) :\n    i âˆˆ (decompose ğ’œ r).support â†” GradedAlgebra.proj ğ’œ i r â‰  0 :=\n  DFinsupp.mem_support_iff.trans Submodule.coe_eq_zero.not.symm\n\n"}
{"name":"GradedRing.projZeroRingHom_apply","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâµ : Semiring A\ninstâœâ´ : DecidableEq Î¹\ninstâœÂ³ : AddCommMonoid Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\na : A\nâŠ¢ Eq ((GradedRing.projZeroRingHom ğ’œ) a) â†‘(((DirectSum.decompose ğ’œ) a) 0)","decl":"/-- If `A` is graded by a canonically ordered add monoid, then the projection map `x â†¦ xâ‚€` is a ring\nhomomorphism.\n-/\n@[simps]\ndef GradedRing.projZeroRingHom : A â†’+* A where\n  toFun a := decompose ğ’œ a 0\n  map_one' :=\n    -- Porting note: qualified `one_mem`\n    decompose_of_mem_same ğ’œ SetLike.GradedOne.one_mem\n  map_zero' := by\n    simp only -- Porting note: added\n    rw [decompose_zero]\n    rfl\n  map_add' _ _ := by\n    simp only -- Porting note: added\n    rw [decompose_add]\n    rfl\n  map_mul' := by\n    refine DirectSum.Decomposition.inductionOn ğ’œ (fun x => ?_) ?_ ?_\n    Â· simp only [zero_mul, decompose_zero, zero_apply, ZeroMemClass.coe_zero]\n    Â· rintro i âŸ¨c, hcâŸ©\n      refine DirectSum.Decomposition.inductionOn ğ’œ ?_ ?_ ?_\n      Â· simp only [mul_zero, decompose_zero, zero_apply, ZeroMemClass.coe_zero]\n      Â· rintro j âŸ¨c', hc'âŸ©\n        simp only [Subtype.coe_mk]\n        by_cases h : i + j = 0\n        Â· rw [decompose_of_mem_same ğ’œ\n              (show c * c' âˆˆ ğ’œ 0 from h â–¸ SetLike.GradedMul.mul_mem hc hc'),\n            decompose_of_mem_same ğ’œ (show c âˆˆ ğ’œ 0 from (add_eq_zero.mp h).1 â–¸ hc),\n            decompose_of_mem_same ğ’œ (show c' âˆˆ ğ’œ 0 from (add_eq_zero.mp h).2 â–¸ hc')]\n        Â· rw [decompose_of_mem_ne ğ’œ (SetLike.GradedMul.mul_mem hc hc') h]\n          cases' show i â‰  0 âˆ¨ j â‰  0 by rwa [add_eq_zero, not_and_or] at h with h' h'\n          Â· simp only [decompose_of_mem_ne ğ’œ hc h', zero_mul]\n          Â· simp only [decompose_of_mem_ne ğ’œ hc' h', mul_zero]\n      Â· intro _ _ hd he\n        simp only at hd he -- Porting note: added\n        simp only [mul_add, decompose_add, add_apply, AddMemClass.coe_add, hd, he]\n    Â· rintro _ _ ha hb _\n      simp only at ha hb -- Porting note: added\n      simp only [add_mul, decompose_add, add_apply, AddMemClass.coe_add, ha, hb]\n\n"}
{"name":"GradedRing.coe_projZeroRingHom'_apply","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâ· : Semiring A\ninstâœâ¶ : DecidableEq Î¹\ninstâœâµ : AddCommMonoid Î¹\ninstâœâ´ : PartialOrder Î¹\ninstâœÂ³ : CanonicallyOrderedAdd Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\na : A\nâŠ¢ Eq (â†‘((GradedRing.projZeroRingHom' ğ’œ) a)) ((GradedRing.projZeroRingHom ğ’œ) a)","decl":"@[simp] lemma GradedRing.coe_projZeroRingHom'_apply (a : A) :\n    (GradedRing.projZeroRingHom' ğ’œ a : A) = GradedRing.projZeroRingHom ğ’œ a := rfl\n\n"}
{"name":"GradedRing.projZeroRingHom'_apply_coe","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâ· : Semiring A\ninstâœâ¶ : DecidableEq Î¹\ninstâœâµ : AddCommMonoid Î¹\ninstâœâ´ : PartialOrder Î¹\ninstâœÂ³ : CanonicallyOrderedAdd Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\na : Subtype fun x => Membership.mem (ğ’œ 0) x\nâŠ¢ Eq ((GradedRing.projZeroRingHom' ğ’œ) â†‘a) a","decl":"@[simp] lemma GradedRing.projZeroRingHom'_apply_coe (a : ğ’œ 0) :\n    GradedRing.projZeroRingHom' ğ’œ a = a := by\n  ext; simp only [coe_projZeroRingHom'_apply, projZeroRingHom_apply, decompose_coe, of_eq_same]\n\n"}
{"name":"GradedRing.projZeroRingHom'_surjective","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâ· : Semiring A\ninstâœâ¶ : DecidableEq Î¹\ninstâœâµ : AddCommMonoid Î¹\ninstâœâ´ : PartialOrder Î¹\ninstâœÂ³ : CanonicallyOrderedAdd Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\nâŠ¢ Function.Surjective â‡‘(GradedRing.projZeroRingHom' ğ’œ)","decl":"/-- The ring homomorphism `GradedRing.projZeroRingHom' ğ’œ` is surjective. -/\nlemma GradedRing.projZeroRingHom'_surjective :\n    Function.Surjective (GradedRing.projZeroRingHom' ğ’œ) :=\n  Function.RightInverse.surjective (GradedRing.projZeroRingHom'_apply_coe ğ’œ)\n\n"}
{"name":"DirectSum.coe_decompose_mul_of_left_mem_of_not_le","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâ· : Semiring A\ninstâœâ¶ : DecidableEq Î¹\ninstâœâµ : AddCommMonoid Î¹\ninstâœâ´ : PartialOrder Î¹\ninstâœÂ³ : CanonicallyOrderedAdd Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\na b : A\nn i : Î¹\na_mem : Membership.mem (ğ’œ i) a\nh : Not (LE.le i n)\nâŠ¢ Eq (â†‘(((DirectSum.decompose ğ’œ) (HMul.hMul a b)) n)) 0","decl":"theorem coe_decompose_mul_of_left_mem_of_not_le (a_mem : a âˆˆ ğ’œ i) (h : Â¬i â‰¤ n) :\n    (decompose ğ’œ (a * b) n : A) = 0 := by\n  lift a to ğ’œ i using a_mem\n  rwa [decompose_mul, decompose_coe, coe_of_mul_apply_of_not_le]\n\n"}
{"name":"DirectSum.coe_decompose_mul_of_right_mem_of_not_le","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœâ· : Semiring A\ninstâœâ¶ : DecidableEq Î¹\ninstâœâµ : AddCommMonoid Î¹\ninstâœâ´ : PartialOrder Î¹\ninstâœÂ³ : CanonicallyOrderedAdd Î¹\ninstâœÂ² : SetLike Ïƒ A\ninstâœÂ¹ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœ : GradedRing ğ’œ\na b : A\nn i : Î¹\nb_mem : Membership.mem (ğ’œ i) b\nh : Not (LE.le i n)\nâŠ¢ Eq (â†‘(((DirectSum.decompose ğ’œ) (HMul.hMul a b)) n)) 0","decl":"theorem coe_decompose_mul_of_right_mem_of_not_le (b_mem : b âˆˆ ğ’œ i) (h : Â¬i â‰¤ n) :\n    (decompose ğ’œ (a * b) n : A) = 0 := by\n  lift b to ğ’œ i using b_mem\n  rwa [decompose_mul, decompose_coe, coe_mul_of_apply_of_not_le]\n\n"}
{"name":"DirectSum.coe_decompose_mul_of_left_mem_of_le","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœÂ¹â° : Semiring A\ninstâœâ¹ : DecidableEq Î¹\ninstâœâ¸ : AddCommMonoid Î¹\ninstâœâ· : PartialOrder Î¹\ninstâœâ¶ : CanonicallyOrderedAdd Î¹\ninstâœâµ : SetLike Ïƒ A\ninstâœâ´ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœÂ³ : GradedRing ğ’œ\na b : A\nn i : Î¹\ninstâœÂ² : Sub Î¹\ninstâœÂ¹ : OrderedSub Î¹\ninstâœ : AddLeftReflectLE Î¹\na_mem : Membership.mem (ğ’œ i) a\nh : LE.le i n\nâŠ¢ Eq (â†‘(((DirectSum.decompose ğ’œ) (HMul.hMul a b)) n)) (HMul.hMul a â†‘(((DirectSum.decompose ğ’œ) b) (HSub.hSub n i)))","decl":"theorem coe_decompose_mul_of_left_mem_of_le (a_mem : a âˆˆ ğ’œ i) (h : i â‰¤ n) :\n    (decompose ğ’œ (a * b) n : A) = a * decompose ğ’œ b (n - i) := by\n  lift a to ğ’œ i using a_mem\n  rwa [decompose_mul, decompose_coe, coe_of_mul_apply_of_le]\n\n"}
{"name":"DirectSum.coe_decompose_mul_of_right_mem_of_le","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœÂ¹â° : Semiring A\ninstâœâ¹ : DecidableEq Î¹\ninstâœâ¸ : AddCommMonoid Î¹\ninstâœâ· : PartialOrder Î¹\ninstâœâ¶ : CanonicallyOrderedAdd Î¹\ninstâœâµ : SetLike Ïƒ A\ninstâœâ´ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœÂ³ : GradedRing ğ’œ\na b : A\nn i : Î¹\ninstâœÂ² : Sub Î¹\ninstâœÂ¹ : OrderedSub Î¹\ninstâœ : AddLeftReflectLE Î¹\nb_mem : Membership.mem (ğ’œ i) b\nh : LE.le i n\nâŠ¢ Eq (â†‘(((DirectSum.decompose ğ’œ) (HMul.hMul a b)) n)) (HMul.hMul (â†‘(((DirectSum.decompose ğ’œ) a) (HSub.hSub n i))) b)","decl":"theorem coe_decompose_mul_of_right_mem_of_le (b_mem : b âˆˆ ğ’œ i) (h : i â‰¤ n) :\n    (decompose ğ’œ (a * b) n : A) = decompose ğ’œ a (n - i) * b := by\n  lift b to ğ’œ i using b_mem\n  rwa [decompose_mul, decompose_coe, coe_mul_of_apply_of_le]\n\n"}
{"name":"DirectSum.coe_decompose_mul_of_left_mem","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœÂ¹Â¹ : Semiring A\ninstâœÂ¹â° : DecidableEq Î¹\ninstâœâ¹ : AddCommMonoid Î¹\ninstâœâ¸ : PartialOrder Î¹\ninstâœâ· : CanonicallyOrderedAdd Î¹\ninstâœâ¶ : SetLike Ïƒ A\ninstâœâµ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœâ´ : GradedRing ğ’œ\na b : A\ni : Î¹\ninstâœÂ³ : Sub Î¹\ninstâœÂ² : OrderedSub Î¹\ninstâœÂ¹ : AddLeftReflectLE Î¹\nn : Î¹\ninstâœ : Decidable (LE.le i n)\na_mem : Membership.mem (ğ’œ i) a\nâŠ¢ Eq (â†‘(((DirectSum.decompose ğ’œ) (HMul.hMul a b)) n)) (ite (LE.le i n) (HMul.hMul a â†‘(((DirectSum.decompose ğ’œ) b) (HSub.hSub n i))) 0)","decl":"theorem coe_decompose_mul_of_left_mem (n) [Decidable (i â‰¤ n)] (a_mem : a âˆˆ ğ’œ i) :\n    (decompose ğ’œ (a * b) n : A) = if i â‰¤ n then a * decompose ğ’œ b (n - i) else 0 := by\n  lift a to ğ’œ i using a_mem\n  rw [decompose_mul, decompose_coe, coe_of_mul_apply]\n\n"}
{"name":"DirectSum.coe_decompose_mul_of_right_mem","module":"Mathlib.RingTheory.GradedAlgebra.Basic","initialProofState":"Î¹ : Type u_1\nA : Type u_3\nÏƒ : Type u_4\ninstâœÂ¹Â¹ : Semiring A\ninstâœÂ¹â° : DecidableEq Î¹\ninstâœâ¹ : AddCommMonoid Î¹\ninstâœâ¸ : PartialOrder Î¹\ninstâœâ· : CanonicallyOrderedAdd Î¹\ninstâœâ¶ : SetLike Ïƒ A\ninstâœâµ : AddSubmonoidClass Ïƒ A\nğ’œ : Î¹ â†’ Ïƒ\ninstâœâ´ : GradedRing ğ’œ\na b : A\ni : Î¹\ninstâœÂ³ : Sub Î¹\ninstâœÂ² : OrderedSub Î¹\ninstâœÂ¹ : AddLeftReflectLE Î¹\nn : Î¹\ninstâœ : Decidable (LE.le i n)\nb_mem : Membership.mem (ğ’œ i) b\nâŠ¢ Eq (â†‘(((DirectSum.decompose ğ’œ) (HMul.hMul a b)) n)) (ite (LE.le i n) (HMul.hMul (â†‘(((DirectSum.decompose ğ’œ) a) (HSub.hSub n i))) b) 0)","decl":"theorem coe_decompose_mul_of_right_mem (n) [Decidable (i â‰¤ n)] (b_mem : b âˆˆ ğ’œ i) :\n    (decompose ğ’œ (a * b) n : A) = if i â‰¤ n then decompose ğ’œ a (n - i) * b else 0 := by\n  lift b to ğ’œ i using b_mem\n  rw [decompose_mul, decompose_coe, coe_mul_of_apply]\n\n"}
