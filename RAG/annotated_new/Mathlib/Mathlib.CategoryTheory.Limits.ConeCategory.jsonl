{"name":"CategoryTheory.Limits.Cone.toStructuredArrow_obj","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nj : J\n‚ä¢ Eq (c.toStructuredArrow.obj j) (CategoryTheory.StructuredArrow.mk (c.œÄ.app j))","decl":"/-- Given a cone `c` over `F`, we can interpret the legs of `c` as structured arrows\n    `c.pt ‚ü∂ F.obj -`. -/\n@[simps]\ndef Cone.toStructuredArrow {F : J ‚•§ C} (c : Cone F) : J ‚•§ StructuredArrow c.pt F where\n  obj j := StructuredArrow.mk (c.œÄ.app j)\n  map f := StructuredArrow.homMk f\n\n"}
{"name":"CategoryTheory.Limits.Cone.toStructuredArrow_map","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nX‚úù Y‚úù : J\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (c.toStructuredArrow.map f) (CategoryTheory.StructuredArrow.homMk f ‚ãØ)","decl":"/-- Given a cone `c` over `F`, we can interpret the legs of `c` as structured arrows\n    `c.pt ‚ü∂ F.obj -`. -/\n@[simps]\ndef Cone.toStructuredArrow {F : J ‚•§ C} (c : Cone F) : J ‚•§ StructuredArrow c.pt F where\n  obj j := StructuredArrow.mk (c.œÄ.app j)\n  map f := StructuredArrow.homMk f\n\n"}
{"name":"CategoryTheory.Limits.limit.toStructuredArrow_obj","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ninst‚úù : CategoryTheory.Limits.HasLimit F\nj : J\n‚ä¢ Eq ((CategoryTheory.Limits.limit.toStructuredArrow F).obj j) (CategoryTheory.StructuredArrow.mk (CategoryTheory.Limits.limit.œÄ F j))","decl":"/-- If `F` has a limit, then the limit projections can be interpreted as structured arrows\n    `limit F ‚ü∂ F.obj -`. -/\n@[simps]\nnoncomputable def limit.toStructuredArrow (F : J ‚•§ C) [HasLimit F] :\n    J ‚•§ StructuredArrow (limit F) F where\n  obj j := StructuredArrow.mk (limit.œÄ F j)\n  map f := StructuredArrow.homMk f\n\n"}
{"name":"CategoryTheory.Limits.limit.toStructuredArrow_map","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ninst‚úù : CategoryTheory.Limits.HasLimit F\nX‚úù Y‚úù : J\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.limit.toStructuredArrow F).map f) (CategoryTheory.StructuredArrow.homMk f ‚ãØ)","decl":"/-- If `F` has a limit, then the limit projections can be interpreted as structured arrows\n    `limit F ‚ü∂ F.obj -`. -/\n@[simps]\nnoncomputable def limit.toStructuredArrow (F : J ‚•§ C) [HasLimit F] :\n    J ‚•§ StructuredArrow (limit F) F where\n  obj j := StructuredArrow.mk (limit.œÄ F j)\n  map f := StructuredArrow.homMk f\n\n"}
{"name":"CategoryTheory.Limits.Cone.toStructuredArrowCompProj_hom_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nX : J\n‚ä¢ Eq (c.toStructuredArrowCompProj.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Interpreting the legs of a cone as a structured arrow and then forgetting the arrow again does\n    nothing. -/\n@[simps!]\ndef Cone.toStructuredArrowCompProj {F : J ‚•§ C} (c : Cone F) :\n    c.toStructuredArrow ‚ãô StructuredArrow.proj _ _ ‚âÖ ùü≠ J :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.Cone.toStructuredArrowCompProj_inv_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nX : J\n‚ä¢ Eq (c.toStructuredArrowCompProj.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Interpreting the legs of a cone as a structured arrow and then forgetting the arrow again does\n    nothing. -/\n@[simps!]\ndef Cone.toStructuredArrowCompProj {F : J ‚•§ C} (c : Cone F) :\n    c.toStructuredArrow ‚ãô StructuredArrow.proj _ _ ‚âÖ ùü≠ J :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.Cone.toStructuredArrow_comp_proj","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (c.toStructuredArrow.comp (CategoryTheory.StructuredArrow.proj c.pt F)) (CategoryTheory.Functor.id J)","decl":"@[simp]\nlemma Cone.toStructuredArrow_comp_proj {F : J ‚•§ C} (c : Cone F) :\n    c.toStructuredArrow ‚ãô StructuredArrow.proj _ _ = ùü≠ J :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Cone.toStructuredArrowCompToUnderCompForget_inv_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nX : J\n‚ä¢ Eq (c.toStructuredArrowCompToUnderCompForget.inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- Interpreting the legs of a cone as a structured arrow, interpreting this arrow as an arrow over\n    the cone point, and finally forgetting the arrow is the same as just applying the functor the\n    cone was over. -/\n@[simps!]\ndef Cone.toStructuredArrowCompToUnderCompForget {F : J ‚•§ C} (c : Cone F) :\n    c.toStructuredArrow ‚ãô StructuredArrow.toUnder _ _ ‚ãô Under.forget _ ‚âÖ F :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.Cone.toStructuredArrowCompToUnderCompForget_hom_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nX : J\n‚ä¢ Eq (c.toStructuredArrowCompToUnderCompForget.hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- Interpreting the legs of a cone as a structured arrow, interpreting this arrow as an arrow over\n    the cone point, and finally forgetting the arrow is the same as just applying the functor the\n    cone was over. -/\n@[simps!]\ndef Cone.toStructuredArrowCompToUnderCompForget {F : J ‚•§ C} (c : Cone F) :\n    c.toStructuredArrow ‚ãô StructuredArrow.toUnder _ _ ‚ãô Under.forget _ ‚âÖ F :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.Cone.toStructuredArrow_comp_toUnder_comp_forget","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (c.toStructuredArrow.comp ((CategoryTheory.StructuredArrow.toUnder c.pt F).comp (CategoryTheory.Under.forget c.pt))) F","decl":"@[simp]\nlemma Cone.toStructuredArrow_comp_toUnder_comp_forget {F : J ‚•§ C} (c : Cone F) :\n    c.toStructuredArrow ‚ãô StructuredArrow.toUnder _ _ ‚ãô Under.forget _ = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Cone.toUnder_pt","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq c.toUnder.pt (CategoryTheory.Under.mk (CategoryTheory.CategoryStruct.id c.pt))","decl":"/-- A cone `c` on `F : J ‚•§ C` lifts to a cone in `Over c.pt` with cone point `ùüô c.pt`. -/\n@[simps]\ndef Cone.toUnder {F : J ‚•§ C} (c : Cone F) :\n    Cone (c.toStructuredArrow ‚ãô StructuredArrow.toUnder _ _) where\n  pt := Under.mk (ùüô c.pt)\n  œÄ := { app := fun j => Under.homMk (c.œÄ.app j) (by simp) }\n\n"}
{"name":"CategoryTheory.Limits.Cone.toUnder_œÄ_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nj : J\n‚ä¢ Eq (c.toUnder.œÄ.app j) (CategoryTheory.Under.homMk (c.œÄ.app j) ‚ãØ)","decl":"/-- A cone `c` on `F : J ‚•§ C` lifts to a cone in `Over c.pt` with cone point `ùüô c.pt`. -/\n@[simps]\ndef Cone.toUnder {F : J ‚•§ C} (c : Cone F) :\n    Cone (c.toStructuredArrow ‚ãô StructuredArrow.toUnder _ _) where\n  pt := Under.mk (ùüô c.pt)\n  œÄ := { app := fun j => Under.homMk (c.œÄ.app j) (by simp) }\n\n"}
{"name":"CategoryTheory.Limits.Cone.mapConeToUnder_hom_hom","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq c.mapConeToUnder.hom.hom (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- `c.toUnder` is a lift of `c` under the forgetful functor. -/\n@[simps!]\ndef Cone.mapConeToUnder {F : J ‚•§ C} (c : Cone F) : (Under.forget c.pt).mapCone c.toUnder ‚âÖ c :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.Cone.mapConeToUnder_inv_hom","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq c.mapConeToUnder.inv.hom (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- `c.toUnder` is a lift of `c` under the forgetful functor. -/\n@[simps!]\ndef Cone.mapConeToUnder {F : J ‚•§ C} (c : Cone F) : (Under.forget c.pt).mapCone c.toUnder ‚âÖ c :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.Cone.fromStructuredArrow_œÄ_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor C D\nX : D\nG : CategoryTheory.Functor J (CategoryTheory.StructuredArrow X F)\nj : J\n‚ä¢ Eq ((CategoryTheory.Limits.Cone.fromStructuredArrow F G).œÄ.app j) (G.obj j).hom","decl":"/-- Given a diagram of `StructuredArrow X F`s, we may obtain a cone with cone point `X`. -/\n@[simps!]\ndef Cone.fromStructuredArrow (F : C ‚•§ D) {X : D} (G : J ‚•§ StructuredArrow X F) :\n    Cone (G ‚ãô StructuredArrow.proj X F ‚ãô F) where\n  œÄ := { app := fun j => (G.obj j).hom }\n\n"}
{"name":"CategoryTheory.Limits.Cone.fromStructuredArrow_pt","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor C D\nX : D\nG : CategoryTheory.Functor J (CategoryTheory.StructuredArrow X F)\n‚ä¢ Eq (CategoryTheory.Limits.Cone.fromStructuredArrow F G).pt X","decl":"/-- Given a diagram of `StructuredArrow X F`s, we may obtain a cone with cone point `X`. -/\n@[simps!]\ndef Cone.fromStructuredArrow (F : C ‚•§ D) {X : D} (G : J ‚•§ StructuredArrow X F) :\n    Cone (G ‚ãô StructuredArrow.proj X F ‚ãô F) where\n  œÄ := { app := fun j => (G.obj j).hom }\n\n"}
{"name":"CategoryTheory.Limits.Cone.toStructuredArrowCone_pt","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nK : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone K\nF : CategoryTheory.Functor C D\nX : D\nf : Quiver.Hom X (F.obj c.pt)\n‚ä¢ Eq (c.toStructuredArrowCone F f).pt (CategoryTheory.StructuredArrow.mk f)","decl":"/-- Given a cone `c : Cone K` and a map `f : X ‚ü∂ F.obj c.X`, we can construct a cone of structured\narrows over `X` with `f` as the cone point.\n-/\n@[simps]\ndef Cone.toStructuredArrowCone {K : J ‚•§ C} (c : Cone K) (F : C ‚•§ D) {X : D} (f : X ‚ü∂ F.obj c.pt) :\n    Cone ((F.mapCone c).toStructuredArrow ‚ãô StructuredArrow.map f ‚ãô StructuredArrow.pre _ K F) where\n  pt := StructuredArrow.mk f\n  œÄ := { app := fun j => StructuredArrow.homMk (c.œÄ.app j) rfl }\n\n"}
{"name":"CategoryTheory.Limits.Cone.toStructuredArrowCone_œÄ_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nK : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone K\nF : CategoryTheory.Functor C D\nX : D\nf : Quiver.Hom X (F.obj c.pt)\nj : J\n‚ä¢ Eq ((c.toStructuredArrowCone F f).œÄ.app j) (CategoryTheory.StructuredArrow.homMk (c.œÄ.app j) ‚ãØ)","decl":"/-- Given a cone `c : Cone K` and a map `f : X ‚ü∂ F.obj c.X`, we can construct a cone of structured\narrows over `X` with `f` as the cone point.\n-/\n@[simps]\ndef Cone.toStructuredArrowCone {K : J ‚•§ C} (c : Cone K) (F : C ‚•§ D) {X : D} (f : X ‚ü∂ F.obj c.pt) :\n    Cone ((F.mapCone c).toStructuredArrow ‚ãô StructuredArrow.map f ‚ãô StructuredArrow.pre _ K F) where\n  pt := StructuredArrow.mk f\n  œÄ := { app := fun j => StructuredArrow.homMk (c.œÄ.app j) rfl }\n\n"}
{"name":"CategoryTheory.Limits.Cone.toCostructuredArrow_obj","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cone.toCostructuredArrow F).obj c) (CategoryTheory.CostructuredArrow.mk c.œÄ)","decl":"/-- Construct an object of the category `(Œî ‚Üì F)` from a cone on `F`. This is part of an\n    equivalence, see `Cone.equivCostructuredArrow`. -/\n@[simps]\ndef Cone.toCostructuredArrow (F : J ‚•§ C) : Cone F ‚•§ CostructuredArrow (const J) F where\n  obj c := CostructuredArrow.mk c.œÄ\n  map f := CostructuredArrow.homMk f.hom\n\n"}
{"name":"CategoryTheory.Limits.Cone.toCostructuredArrow_map","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX‚úù Y‚úù : CategoryTheory.Limits.Cone F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.Cone.toCostructuredArrow F).map f) (CategoryTheory.CostructuredArrow.homMk f.hom ‚ãØ)","decl":"/-- Construct an object of the category `(Œî ‚Üì F)` from a cone on `F`. This is part of an\n    equivalence, see `Cone.equivCostructuredArrow`. -/\n@[simps]\ndef Cone.toCostructuredArrow (F : J ‚•§ C) : Cone F ‚•§ CostructuredArrow (const J) F where\n  obj c := CostructuredArrow.mk c.œÄ\n  map f := CostructuredArrow.homMk f.hom\n\n"}
{"name":"CategoryTheory.Limits.Cone.fromCostructuredArrow_map_hom","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (CategoryTheory.Functor.const J) F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.Cone.fromCostructuredArrow F).map f).hom f.left","decl":"/-- Construct a cone on `F` from an object of the category `(Œî ‚Üì F)`. This is part of an\n    equivalence, see `Cone.equivCostructuredArrow`. -/\n@[simps]\ndef Cone.fromCostructuredArrow (F : J ‚•§ C) : CostructuredArrow (const J) F ‚•§ Cone F where\n  obj c := ‚ü®c.left, c.hom‚ü©\n  map f :=\n    { hom := f.left\n      w := fun j => by\n        convert congr_fun (congr_arg NatTrans.app f.w) j\n        dsimp\n        simp }\n\n"}
{"name":"CategoryTheory.Limits.Cone.fromCostructuredArrow_obj_œÄ","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.CostructuredArrow (CategoryTheory.Functor.const J) F\n‚ä¢ Eq ((CategoryTheory.Limits.Cone.fromCostructuredArrow F).obj c).œÄ c.hom","decl":"/-- Construct a cone on `F` from an object of the category `(Œî ‚Üì F)`. This is part of an\n    equivalence, see `Cone.equivCostructuredArrow`. -/\n@[simps]\ndef Cone.fromCostructuredArrow (F : J ‚•§ C) : CostructuredArrow (const J) F ‚•§ Cone F where\n  obj c := ‚ü®c.left, c.hom‚ü©\n  map f :=\n    { hom := f.left\n      w := fun j => by\n        convert congr_fun (congr_arg NatTrans.app f.w) j\n        dsimp\n        simp }\n\n"}
{"name":"CategoryTheory.Limits.Cone.fromCostructuredArrow_obj_pt","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.CostructuredArrow (CategoryTheory.Functor.const J) F\n‚ä¢ Eq ((CategoryTheory.Limits.Cone.fromCostructuredArrow F).obj c).pt c.left","decl":"/-- Construct a cone on `F` from an object of the category `(Œî ‚Üì F)`. This is part of an\n    equivalence, see `Cone.equivCostructuredArrow`. -/\n@[simps]\ndef Cone.fromCostructuredArrow (F : J ‚•§ C) : CostructuredArrow (const J) F ‚•§ Cone F where\n  obj c := ‚ü®c.left, c.hom‚ü©\n  map f :=\n    { hom := f.left\n      w := fun j => by\n        convert congr_fun (congr_arg NatTrans.app f.w) j\n        dsimp\n        simp }\n\n"}
{"name":"CategoryTheory.Limits.Cone.equivCostructuredArrow_counitIso","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\n‚ä¢ Eq (CategoryTheory.Limits.Cone.equivCostructuredArrow F).counitIso (CategoryTheory.NatIso.ofComponents (fun x => x.eta.symm) ‚ãØ)","decl":"/-- The category of cones on `F` is just the comma category `(Œî ‚Üì F)`, where `Œî` is the constant\n    functor. -/\n@[simps]\ndef Cone.equivCostructuredArrow (F : J ‚•§ C) : Cone F ‚âå CostructuredArrow (const J) F where\n  functor := Cone.toCostructuredArrow F\n  inverse := Cone.fromCostructuredArrow F\n  unitIso := NatIso.ofComponents Cones.eta\n  counitIso := NatIso.ofComponents fun _ => (CostructuredArrow.eta _).symm\n\n"}
{"name":"CategoryTheory.Limits.Cone.equivCostructuredArrow_functor","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\n‚ä¢ Eq (CategoryTheory.Limits.Cone.equivCostructuredArrow F).functor (CategoryTheory.Limits.Cone.toCostructuredArrow F)","decl":"/-- The category of cones on `F` is just the comma category `(Œî ‚Üì F)`, where `Œî` is the constant\n    functor. -/\n@[simps]\ndef Cone.equivCostructuredArrow (F : J ‚•§ C) : Cone F ‚âå CostructuredArrow (const J) F where\n  functor := Cone.toCostructuredArrow F\n  inverse := Cone.fromCostructuredArrow F\n  unitIso := NatIso.ofComponents Cones.eta\n  counitIso := NatIso.ofComponents fun _ => (CostructuredArrow.eta _).symm\n\n"}
{"name":"CategoryTheory.Limits.Cone.equivCostructuredArrow_inverse","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\n‚ä¢ Eq (CategoryTheory.Limits.Cone.equivCostructuredArrow F).inverse (CategoryTheory.Limits.Cone.fromCostructuredArrow F)","decl":"/-- The category of cones on `F` is just the comma category `(Œî ‚Üì F)`, where `Œî` is the constant\n    functor. -/\n@[simps]\ndef Cone.equivCostructuredArrow (F : J ‚•§ C) : Cone F ‚âå CostructuredArrow (const J) F where\n  functor := Cone.toCostructuredArrow F\n  inverse := Cone.fromCostructuredArrow F\n  unitIso := NatIso.ofComponents Cones.eta\n  counitIso := NatIso.ofComponents fun _ => (CostructuredArrow.eta _).symm\n\n"}
{"name":"CategoryTheory.Limits.Cone.equivCostructuredArrow_unitIso","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\n‚ä¢ Eq (CategoryTheory.Limits.Cone.equivCostructuredArrow F).unitIso (CategoryTheory.NatIso.ofComponents CategoryTheory.Limits.Cones.eta ‚ãØ)","decl":"/-- The category of cones on `F` is just the comma category `(Œî ‚Üì F)`, where `Œî` is the constant\n    functor. -/\n@[simps]\ndef Cone.equivCostructuredArrow (F : J ‚•§ C) : Cone F ‚âå CostructuredArrow (const J) F where\n  functor := Cone.toCostructuredArrow F\n  inverse := Cone.fromCostructuredArrow F\n  unitIso := NatIso.ofComponents Cones.eta\n  counitIso := NatIso.ofComponents fun _ => (CostructuredArrow.eta _).symm\n\n"}
{"name":"CategoryTheory.Limits.hasLimit_iff_hasTerminal_cone","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\n‚ä¢ Iff (CategoryTheory.Limits.HasLimit F) (CategoryTheory.Limits.HasTerminal (CategoryTheory.Limits.Cone F))","decl":"theorem hasLimit_iff_hasTerminal_cone (F : J ‚•§ C) : HasLimit F ‚Üî HasTerminal (Cone F) :=\n  ‚ü®fun _ => (Cone.isLimitEquivIsTerminal _ (limit.isLimit F)).hasTerminal, fun h =>\n    haveI : HasTerminal (Cone F) := h\n    ‚ü®‚ü®‚ü®‚ä§_ _, (Cone.isLimitEquivIsTerminal _).symm terminalIsTerminal‚ü©‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfShape_iff_isLeftAdjoint_const","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\n‚ä¢ Iff (CategoryTheory.Limits.HasLimitsOfShape J C) (CategoryTheory.Functor.const J).IsLeftAdjoint","decl":"theorem hasLimitsOfShape_iff_isLeftAdjoint_const :\n    HasLimitsOfShape J C ‚Üî IsLeftAdjoint (const J : C ‚•§ _) :=\n  calc\n    HasLimitsOfShape J C ‚Üî ‚àÄ F : J ‚•§ C, HasLimit F :=\n      ‚ü®fun h => h.has_limit, fun h => HasLimitsOfShape.mk‚ü©\n    _ ‚Üî ‚àÄ F : J ‚•§ C, HasTerminal (Cone F) := forall_congr' hasLimit_iff_hasTerminal_cone\n    _ ‚Üî ‚àÄ F : J ‚•§ C, HasTerminal (CostructuredArrow (const J) F) :=\n      (forall_congr' fun F => (Cone.equivCostructuredArrow F).hasTerminal_iff)\n    _ ‚Üî (IsLeftAdjoint (const J : C ‚•§ _)) :=\n      isLeftAdjoint_iff_hasTerminal_costructuredArrow.symm\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.liftConeMorphism_eq_isTerminal_from","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (hc.liftConeMorphism s) ((c.isLimitEquivIsTerminal hc).from s)","decl":"theorem IsLimit.liftConeMorphism_eq_isTerminal_from {F : J ‚•§ C} {c : Cone F} (hc : IsLimit c)\n    (s : Cone F) : hc.liftConeMorphism s = IsTerminal.from (Cone.isLimitEquivIsTerminal _ hc) _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.from_eq_liftConeMorphism","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsTerminal c\ns : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (hc.from s) ((c.isLimitEquivIsTerminal.symm hc).liftConeMorphism s)","decl":"theorem IsTerminal.from_eq_liftConeMorphism {F : J ‚•§ C} {c : Cone F} (hc : IsTerminal c)\n    (s : Cone F) :\n    IsTerminal.from hc s = ((Cone.isLimitEquivIsTerminal _).symm hc).liftConeMorphism s :=\n  (IsLimit.liftConeMorphism_eq_isTerminal_from (c.isLimitEquivIsTerminal.symm hc) s).symm\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toCostructuredArrow_map","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX‚úù Y‚úù : J\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (c.toCostructuredArrow.map f) (CategoryTheory.CostructuredArrow.homMk f ‚ãØ)","decl":"/-- Given a cocone `c` over `F`, we can interpret the legs of `c` as costructured arrows\n    `F.obj - ‚ü∂ c.pt`. -/\n@[simps]\ndef Cocone.toCostructuredArrow {F : J ‚•§ C} (c : Cocone F) : J ‚•§ CostructuredArrow F c.pt where\n  obj j := CostructuredArrow.mk (c.Œπ.app j)\n  map f := CostructuredArrow.homMk f\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toCostructuredArrow_obj","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nj : J\n‚ä¢ Eq (c.toCostructuredArrow.obj j) (CategoryTheory.CostructuredArrow.mk (c.Œπ.app j))","decl":"/-- Given a cocone `c` over `F`, we can interpret the legs of `c` as costructured arrows\n    `F.obj - ‚ü∂ c.pt`. -/\n@[simps]\ndef Cocone.toCostructuredArrow {F : J ‚•§ C} (c : Cocone F) : J ‚•§ CostructuredArrow F c.pt where\n  obj j := CostructuredArrow.mk (c.Œπ.app j)\n  map f := CostructuredArrow.homMk f\n\n"}
{"name":"CategoryTheory.Limits.colimit.toCostructuredArrow_obj","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ninst‚úù : CategoryTheory.Limits.HasColimit F\nj : J\n‚ä¢ Eq ((CategoryTheory.Limits.colimit.toCostructuredArrow F).obj j) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.Limits.colimit.Œπ F j))","decl":"/-- If `F` has a colimit, then the colimit inclusions can be interpreted as costructured arrows\n    `F.obj - ‚ü∂ colimit F`. -/\n@[simps]\nnoncomputable def colimit.toCostructuredArrow (F : J ‚•§ C) [HasColimit F] :\n    J ‚•§ CostructuredArrow F (colimit F) where\n  obj j := CostructuredArrow.mk (colimit.Œπ F j)\n  map f := CostructuredArrow.homMk f\n\n"}
{"name":"CategoryTheory.Limits.colimit.toCostructuredArrow_map","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ninst‚úù : CategoryTheory.Limits.HasColimit F\nX‚úù Y‚úù : J\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.colimit.toCostructuredArrow F).map f) (CategoryTheory.CostructuredArrow.homMk f ‚ãØ)","decl":"/-- If `F` has a colimit, then the colimit inclusions can be interpreted as costructured arrows\n    `F.obj - ‚ü∂ colimit F`. -/\n@[simps]\nnoncomputable def colimit.toCostructuredArrow (F : J ‚•§ C) [HasColimit F] :\n    J ‚•§ CostructuredArrow F (colimit F) where\n  obj j := CostructuredArrow.mk (colimit.Œπ F j)\n  map f := CostructuredArrow.homMk f\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toCostructuredArrowCompProj_hom_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX : J\n‚ä¢ Eq (c.toCostructuredArrowCompProj.hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Interpreting the legs of a cocone as a costructured arrow and then forgetting the arrow again\n    does nothing. -/\n@[simps!]\ndef Cocone.toCostructuredArrowCompProj {F : J ‚•§ C} (c : Cocone F) :\n    c.toCostructuredArrow ‚ãô CostructuredArrow.proj _ _ ‚âÖ ùü≠ J :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toCostructuredArrowCompProj_inv_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX : J\n‚ä¢ Eq (c.toCostructuredArrowCompProj.inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Interpreting the legs of a cocone as a costructured arrow and then forgetting the arrow again\n    does nothing. -/\n@[simps!]\ndef Cocone.toCostructuredArrowCompProj {F : J ‚•§ C} (c : Cocone F) :\n    c.toCostructuredArrow ‚ãô CostructuredArrow.proj _ _ ‚âÖ ùü≠ J :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toCostructuredArrow_comp_proj","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (c.toCostructuredArrow.comp (CategoryTheory.CostructuredArrow.proj F c.pt)) (CategoryTheory.Functor.id J)","decl":"@[simp]\nlemma Cocone.toCostructuredArrow_comp_proj {F : J ‚•§ C} (c : Cocone F) :\n    c.toCostructuredArrow ‚ãô CostructuredArrow.proj _ _ = ùü≠ J :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toCostructuredArrowCompToOverCompForget_hom_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX : J\n‚ä¢ Eq (c.toCostructuredArrowCompToOverCompForget.hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- Interpreting the legs of a cocone as a costructured arrow, interpreting this arrow as an arrow\n    over the cocone point, and finally forgetting the arrow is the same as just applying the\n    functor the cocone was over. -/\n@[simps!]\ndef Cocone.toCostructuredArrowCompToOverCompForget {F : J ‚•§ C} (c : Cocone F) :\n    c.toCostructuredArrow ‚ãô CostructuredArrow.toOver _ _ ‚ãô Over.forget _ ‚âÖ F :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toCostructuredArrowCompToOverCompForget_inv_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nX : J\n‚ä¢ Eq (c.toCostructuredArrowCompToOverCompForget.inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- Interpreting the legs of a cocone as a costructured arrow, interpreting this arrow as an arrow\n    over the cocone point, and finally forgetting the arrow is the same as just applying the\n    functor the cocone was over. -/\n@[simps!]\ndef Cocone.toCostructuredArrowCompToOverCompForget {F : J ‚•§ C} (c : Cocone F) :\n    c.toCostructuredArrow ‚ãô CostructuredArrow.toOver _ _ ‚ãô Over.forget _ ‚âÖ F :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toCostructuredArrow_comp_toOver_comp_forget","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (c.toCostructuredArrow.comp ((CategoryTheory.CostructuredArrow.toOver F c.pt).comp (CategoryTheory.Over.forget c.pt))) F","decl":"@[simp]\nlemma Cocone.toCostructuredArrow_comp_toOver_comp_forget {F : J ‚•§ C} (c : Cocone F) :\n    c.toCostructuredArrow ‚ãô CostructuredArrow.toOver _ _ ‚ãô Over.forget _ = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toOver_pt","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq c.toOver.pt (CategoryTheory.Over.mk (CategoryTheory.CategoryStruct.id c.pt))","decl":"/-- A cocone `c` on `F : J ‚•§ C` lifts to a cocone in `Over c.pt` with cone point `ùüô c.pt`. -/\n@[simps]\ndef Cocone.toOver {F : J ‚•§ C} (c : Cocone F) :\n    Cocone (c.toCostructuredArrow ‚ãô CostructuredArrow.toOver _ _) where\n  pt := Over.mk (ùüô c.pt)\n  Œπ := { app := fun j => Over.homMk (c.Œπ.app j) (by simp) }\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toOver_Œπ_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nj : J\n‚ä¢ Eq (c.toOver.Œπ.app j) (CategoryTheory.Over.homMk (c.Œπ.app j) ‚ãØ)","decl":"/-- A cocone `c` on `F : J ‚•§ C` lifts to a cocone in `Over c.pt` with cone point `ùüô c.pt`. -/\n@[simps]\ndef Cocone.toOver {F : J ‚•§ C} (c : Cocone F) :\n    Cocone (c.toCostructuredArrow ‚ãô CostructuredArrow.toOver _ _) where\n  pt := Over.mk (ùüô c.pt)\n  Œπ := { app := fun j => Over.homMk (c.Œπ.app j) (by simp) }\n\n"}
{"name":"CategoryTheory.Limits.colimit.toOver_pt","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ninst‚úù : CategoryTheory.Limits.HasColimit F\n‚ä¢ Eq (CategoryTheory.Limits.colimit.toOver F).pt (CategoryTheory.Over.mk (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.colimit F)))","decl":"/-- The colimit cocone for `F : J ‚•§ C` lifts to a cocone in `Over (colimit F)` with cone point\n    `ùüô (colimit F)`. This is automatically also a colimit cocone. -/\n@[simps]\nnoncomputable def colimit.toOver (F : J ‚•§ C) [HasColimit F] :\n    Cocone (colimit.toCostructuredArrow F ‚ãô CostructuredArrow.toOver _ _) where\n  pt := Over.mk (ùüô (colimit F))\n  Œπ := { app := fun j => Over.homMk (colimit.Œπ F j) (by simp) }\n\n"}
{"name":"CategoryTheory.Limits.colimit.toOver_Œπ_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\ninst‚úù : CategoryTheory.Limits.HasColimit F\nj : J\n‚ä¢ Eq ((CategoryTheory.Limits.colimit.toOver F).Œπ.app j) (CategoryTheory.Over.homMk (CategoryTheory.Limits.colimit.Œπ F j) ‚ãØ)","decl":"/-- The colimit cocone for `F : J ‚•§ C` lifts to a cocone in `Over (colimit F)` with cone point\n    `ùüô (colimit F)`. This is automatically also a colimit cocone. -/\n@[simps]\nnoncomputable def colimit.toOver (F : J ‚•§ C) [HasColimit F] :\n    Cocone (colimit.toCostructuredArrow F ‚ãô CostructuredArrow.toOver _ _) where\n  pt := Over.mk (ùüô (colimit F))\n  Œπ := { app := fun j => Over.homMk (colimit.Œπ F j) (by simp) }\n\n"}
{"name":"CategoryTheory.Limits.Cocone.mapCoconeToOver_hom_hom","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq c.mapCoconeToOver.hom.hom (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- `c.toOver` is a lift of `c` under the forgetful functor. -/\n@[simps!]\ndef Cocone.mapCoconeToOver {F : J ‚•§ C} (c : Cocone F) : (Over.forget c.pt).mapCocone c.toOver ‚âÖ c :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.Cocone.mapCoconeToOver_inv_hom","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq c.mapCoconeToOver.inv.hom (CategoryTheory.CategoryStruct.id c.pt)","decl":"/-- `c.toOver` is a lift of `c` under the forgetful functor. -/\n@[simps!]\ndef Cocone.mapCoconeToOver {F : J ‚•§ C} (c : Cocone F) : (Over.forget c.pt).mapCocone c.toOver ‚âÖ c :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.Cocone.fromCostructuredArrow_Œπ_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor C D\nX : D\nG : CategoryTheory.Functor J (CategoryTheory.CostructuredArrow F X)\nj : J\n‚ä¢ Eq ((CategoryTheory.Limits.Cocone.fromCostructuredArrow F G).Œπ.app j) (G.obj j).hom","decl":"/-- Given a diagram `CostructuredArrow F X`s, we may obtain a cocone with cone point `X`. -/\n@[simps!]\ndef Cocone.fromCostructuredArrow (F : C ‚•§ D) {X : D} (G : J ‚•§ CostructuredArrow F X) :\n    Cocone (G ‚ãô CostructuredArrow.proj F X ‚ãô F) where\n  Œπ := { app := fun j => (G.obj j).hom }\n\n"}
{"name":"CategoryTheory.Limits.Cocone.fromCostructuredArrow_pt","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor C D\nX : D\nG : CategoryTheory.Functor J (CategoryTheory.CostructuredArrow F X)\n‚ä¢ Eq (CategoryTheory.Limits.Cocone.fromCostructuredArrow F G).pt X","decl":"/-- Given a diagram `CostructuredArrow F X`s, we may obtain a cocone with cone point `X`. -/\n@[simps!]\ndef Cocone.fromCostructuredArrow (F : C ‚•§ D) {X : D} (G : J ‚•§ CostructuredArrow F X) :\n    Cocone (G ‚ãô CostructuredArrow.proj F X ‚ãô F) where\n  Œπ := { app := fun j => (G.obj j).hom }\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toCostructuredArrowCocone_Œπ_app","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nK : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone K\nF : CategoryTheory.Functor C D\nX : D\nf : Quiver.Hom (F.obj c.pt) X\nj : J\n‚ä¢ Eq ((c.toCostructuredArrowCocone F f).Œπ.app j) (CategoryTheory.CostructuredArrow.homMk (c.Œπ.app j) ‚ãØ)","decl":"/-- Given a cocone `c : Cocone K` and a map `f : F.obj c.X ‚ü∂ X`, we can construct a cocone of\n    costructured arrows over `X` with `f` as the cone point. -/\n@[simps]\ndef Cocone.toCostructuredArrowCocone {K : J ‚•§ C} (c : Cocone K) (F : C ‚•§ D) {X : D}\n    (f : F.obj c.pt ‚ü∂ X) : Cocone ((F.mapCocone c).toCostructuredArrow ‚ãô\n      CostructuredArrow.map f ‚ãô CostructuredArrow.pre _ _ _) where\n  pt := CostructuredArrow.mk f\n  Œπ := { app := fun j => CostructuredArrow.homMk (c.Œπ.app j) rfl }\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toCostructuredArrowCocone_pt","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nK : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone K\nF : CategoryTheory.Functor C D\nX : D\nf : Quiver.Hom (F.obj c.pt) X\n‚ä¢ Eq (c.toCostructuredArrowCocone F f).pt (CategoryTheory.CostructuredArrow.mk f)","decl":"/-- Given a cocone `c : Cocone K` and a map `f : F.obj c.X ‚ü∂ X`, we can construct a cocone of\n    costructured arrows over `X` with `f` as the cone point. -/\n@[simps]\ndef Cocone.toCostructuredArrowCocone {K : J ‚•§ C} (c : Cocone K) (F : C ‚•§ D) {X : D}\n    (f : F.obj c.pt ‚ü∂ X) : Cocone ((F.mapCocone c).toCostructuredArrow ‚ãô\n      CostructuredArrow.map f ‚ãô CostructuredArrow.pre _ _ _) where\n  pt := CostructuredArrow.mk f\n  Œπ := { app := fun j => CostructuredArrow.homMk (c.Œπ.app j) rfl }\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toStructuredArrow_obj","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((CategoryTheory.Limits.Cocone.toStructuredArrow F).obj c) (CategoryTheory.StructuredArrow.mk c.Œπ)","decl":"/-- Construct an object of the category `(F ‚Üì Œî)` from a cocone on `F`. This is part of an\n    equivalence, see `Cocone.equivStructuredArrow`. -/\n@[simps]\ndef Cocone.toStructuredArrow (F : J ‚•§ C) : Cocone F ‚•§ StructuredArrow F (const J) where\n  obj c := StructuredArrow.mk c.Œπ\n  map f := StructuredArrow.homMk f.hom\n\n"}
{"name":"CategoryTheory.Limits.Cocone.toStructuredArrow_map","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX‚úù Y‚úù : CategoryTheory.Limits.Cocone F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.Cocone.toStructuredArrow F).map f) (CategoryTheory.StructuredArrow.homMk f.hom ‚ãØ)","decl":"/-- Construct an object of the category `(F ‚Üì Œî)` from a cocone on `F`. This is part of an\n    equivalence, see `Cocone.equivStructuredArrow`. -/\n@[simps]\ndef Cocone.toStructuredArrow (F : J ‚•§ C) : Cocone F ‚•§ StructuredArrow F (const J) where\n  obj c := StructuredArrow.mk c.Œπ\n  map f := StructuredArrow.homMk f.hom\n\n"}
{"name":"CategoryTheory.Limits.Cocone.fromStructuredArrow_obj_Œπ","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.StructuredArrow F (CategoryTheory.Functor.const J)\n‚ä¢ Eq ((CategoryTheory.Limits.Cocone.fromStructuredArrow F).obj c).Œπ c.hom","decl":"/-- Construct a cocone on `F` from an object of the category `(F ‚Üì Œî)`. This is part of an\n    equivalence, see `Cocone.equivStructuredArrow`. -/\n@[simps]\ndef Cocone.fromStructuredArrow (F : J ‚•§ C) : StructuredArrow F (const J) ‚•§ Cocone F where\n  obj c := ‚ü®c.right, c.hom‚ü©\n  map f :=\n    { hom := f.right\n      w := fun j => by\n        convert (congr_fun (congr_arg NatTrans.app f.w) j).symm\n        dsimp\n        simp }\n\n"}
{"name":"CategoryTheory.Limits.Cocone.fromStructuredArrow_map_hom","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nX‚úù Y‚úù : CategoryTheory.StructuredArrow F (CategoryTheory.Functor.const J)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.Cocone.fromStructuredArrow F).map f).hom f.right","decl":"/-- Construct a cocone on `F` from an object of the category `(F ‚Üì Œî)`. This is part of an\n    equivalence, see `Cocone.equivStructuredArrow`. -/\n@[simps]\ndef Cocone.fromStructuredArrow (F : J ‚•§ C) : StructuredArrow F (const J) ‚•§ Cocone F where\n  obj c := ‚ü®c.right, c.hom‚ü©\n  map f :=\n    { hom := f.right\n      w := fun j => by\n        convert (congr_fun (congr_arg NatTrans.app f.w) j).symm\n        dsimp\n        simp }\n\n"}
{"name":"CategoryTheory.Limits.Cocone.fromStructuredArrow_obj_pt","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.StructuredArrow F (CategoryTheory.Functor.const J)\n‚ä¢ Eq ((CategoryTheory.Limits.Cocone.fromStructuredArrow F).obj c).pt c.right","decl":"/-- Construct a cocone on `F` from an object of the category `(F ‚Üì Œî)`. This is part of an\n    equivalence, see `Cocone.equivStructuredArrow`. -/\n@[simps]\ndef Cocone.fromStructuredArrow (F : J ‚•§ C) : StructuredArrow F (const J) ‚•§ Cocone F where\n  obj c := ‚ü®c.right, c.hom‚ü©\n  map f :=\n    { hom := f.right\n      w := fun j => by\n        convert (congr_fun (congr_arg NatTrans.app f.w) j).symm\n        dsimp\n        simp }\n\n"}
{"name":"CategoryTheory.Limits.Cocone.equivStructuredArrow_functor","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\n‚ä¢ Eq (CategoryTheory.Limits.Cocone.equivStructuredArrow F).functor (CategoryTheory.Limits.Cocone.toStructuredArrow F)","decl":"/-- The category of cocones on `F` is just the comma category `(F ‚Üì Œî)`, where `Œî` is the constant\n    functor. -/\n@[simps]\ndef Cocone.equivStructuredArrow (F : J ‚•§ C) : Cocone F ‚âå StructuredArrow F (const J) where\n  functor := Cocone.toStructuredArrow F\n  inverse := Cocone.fromStructuredArrow F\n  unitIso := NatIso.ofComponents Cocones.eta\n  counitIso := NatIso.ofComponents fun _ => (StructuredArrow.eta _).symm\n\n"}
{"name":"CategoryTheory.Limits.Cocone.equivStructuredArrow_counitIso","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\n‚ä¢ Eq (CategoryTheory.Limits.Cocone.equivStructuredArrow F).counitIso (CategoryTheory.NatIso.ofComponents (fun x => x.eta.symm) ‚ãØ)","decl":"/-- The category of cocones on `F` is just the comma category `(F ‚Üì Œî)`, where `Œî` is the constant\n    functor. -/\n@[simps]\ndef Cocone.equivStructuredArrow (F : J ‚•§ C) : Cocone F ‚âå StructuredArrow F (const J) where\n  functor := Cocone.toStructuredArrow F\n  inverse := Cocone.fromStructuredArrow F\n  unitIso := NatIso.ofComponents Cocones.eta\n  counitIso := NatIso.ofComponents fun _ => (StructuredArrow.eta _).symm\n\n"}
{"name":"CategoryTheory.Limits.Cocone.equivStructuredArrow_inverse","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\n‚ä¢ Eq (CategoryTheory.Limits.Cocone.equivStructuredArrow F).inverse (CategoryTheory.Limits.Cocone.fromStructuredArrow F)","decl":"/-- The category of cocones on `F` is just the comma category `(F ‚Üì Œî)`, where `Œî` is the constant\n    functor. -/\n@[simps]\ndef Cocone.equivStructuredArrow (F : J ‚•§ C) : Cocone F ‚âå StructuredArrow F (const J) where\n  functor := Cocone.toStructuredArrow F\n  inverse := Cocone.fromStructuredArrow F\n  unitIso := NatIso.ofComponents Cocones.eta\n  counitIso := NatIso.ofComponents fun _ => (StructuredArrow.eta _).symm\n\n"}
{"name":"CategoryTheory.Limits.Cocone.equivStructuredArrow_unitIso","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\n‚ä¢ Eq (CategoryTheory.Limits.Cocone.equivStructuredArrow F).unitIso (CategoryTheory.NatIso.ofComponents CategoryTheory.Limits.Cocones.eta ‚ãØ)","decl":"/-- The category of cocones on `F` is just the comma category `(F ‚Üì Œî)`, where `Œî` is the constant\n    functor. -/\n@[simps]\ndef Cocone.equivStructuredArrow (F : J ‚•§ C) : Cocone F ‚âå StructuredArrow F (const J) where\n  functor := Cocone.toStructuredArrow F\n  inverse := Cocone.fromStructuredArrow F\n  unitIso := NatIso.ofComponents Cocones.eta\n  counitIso := NatIso.ofComponents fun _ => (StructuredArrow.eta _).symm\n\n"}
{"name":"CategoryTheory.Limits.hasColimit_iff_hasInitial_cocone","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\n‚ä¢ Iff (CategoryTheory.Limits.HasColimit F) (CategoryTheory.Limits.HasInitial (CategoryTheory.Limits.Cocone F))","decl":"theorem hasColimit_iff_hasInitial_cocone (F : J ‚•§ C) : HasColimit F ‚Üî HasInitial (Cocone F) :=\n  ‚ü®fun _ => (Cocone.isColimitEquivIsInitial _ (colimit.isColimit F)).hasInitial, fun h =>\n    haveI : HasInitial (Cocone F) := h\n    ‚ü®‚ü®‚ü®‚ä•_ _, (Cocone.isColimitEquivIsInitial _).symm initialIsInitial‚ü©‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShape_iff_isRightAdjoint_const","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\n‚ä¢ Iff (CategoryTheory.Limits.HasColimitsOfShape J C) (CategoryTheory.Functor.const J).IsRightAdjoint","decl":"theorem hasColimitsOfShape_iff_isRightAdjoint_const :\n    HasColimitsOfShape J C ‚Üî IsRightAdjoint (const J : C ‚•§ _) :=\n  calc\n    HasColimitsOfShape J C ‚Üî ‚àÄ F : J ‚•§ C, HasColimit F :=\n      ‚ü®fun h => h.has_colimit, fun h => HasColimitsOfShape.mk‚ü©\n    _ ‚Üî ‚àÄ F : J ‚•§ C, HasInitial (Cocone F) := forall_congr' hasColimit_iff_hasInitial_cocone\n    _ ‚Üî ‚àÄ F : J ‚•§ C, HasInitial (StructuredArrow F (const J)) :=\n      (forall_congr' fun F => (Cocone.equivStructuredArrow F).hasInitial_iff)\n    _ ‚Üî (IsRightAdjoint (const J : C ‚•§ _)) :=\n      isRightAdjoint_iff_hasInitial_structuredArrow.symm\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.descCoconeMorphism_eq_isInitial_to","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\ns : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (hc.descCoconeMorphism s) ((c.isColimitEquivIsInitial hc).to s)","decl":"theorem IsColimit.descCoconeMorphism_eq_isInitial_to {F : J ‚•§ C} {c : Cocone F} (hc : IsColimit c)\n    (s : Cocone F) :\n    hc.descCoconeMorphism s = IsInitial.to (Cocone.isColimitEquivIsInitial _ hc) _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.to_eq_descCoconeMorphism","module":"Mathlib.CategoryTheory.Limits.ConeCategory","initialProofState":"J : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsInitial c\ns : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (hc.to s) ((c.isColimitEquivIsInitial.symm hc).descCoconeMorphism s)","decl":"theorem IsInitial.to_eq_descCoconeMorphism {F : J ‚•§ C} {c : Cocone F} (hc : IsInitial c)\n    (s : Cocone F) :\n    IsInitial.to hc s = ((Cocone.isColimitEquivIsInitial _).symm hc).descCoconeMorphism s :=\n  (IsColimit.descCoconeMorphism_eq_isInitial_to (c.isColimitEquivIsInitial.symm hc) s).symm\n\n"}
