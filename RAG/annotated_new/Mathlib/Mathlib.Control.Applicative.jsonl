{"name":"Applicative.map_seq_map","module":"Mathlib.Control.Applicative","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\ninst✝ : LawfulApplicative F\nα β γ σ : Type u\nf : α → β → γ\ng : σ → β\nx : F α\ny : F σ\n⊢ Eq (Seq.seq (Functor.map f x) fun x => Functor.map g y) (Seq.seq (Functor.map (Function.comp (fun x => Function.comp x g) f) x) fun x => y)","decl":"theorem Applicative.map_seq_map (f : α → β → γ) (g : σ → β) (x : F α) (y : F σ) :\n    f <$> x <*> g <$> y = ((· ∘ g) ∘ f) <$> x <*> y := by\n  simp [flip, functor_norm, Function.comp_def]\n\n"}
{"name":"Applicative.pure_seq_eq_map'","module":"Mathlib.Control.Applicative","initialProofState":"F : Type u → Type v\ninst✝¹ : Applicative F\ninst✝ : LawfulApplicative F\nα β : Type u\nf : α → β\n⊢ Eq (fun x => Seq.seq (Pure.pure f) fun x_1 => x) fun x => Functor.map f x","decl":"theorem Applicative.pure_seq_eq_map' (f : α → β) : ((pure f : F (α → β)) <*> ·) = (f <$> ·) := by\n  ext; simp [functor_norm]\n\n"}
{"name":"Applicative.ext","module":"Mathlib.Control.Applicative","initialProofState":"F : Type u → Type u_1\nA1 A2 : Applicative F\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative F\na✝¹ : ∀ {α : Type u} (x : α), Eq (Pure.pure x) (Pure.pure x)\na✝ : ∀ {α β : Type u} (f : F (α → β)) (x : F α), Eq (Seq.seq f fun x_1 => x) (Seq.seq f fun x_1 => x)\n⊢ Eq A1 A2","decl":"theorem Applicative.ext {F} :\n    ∀ {A1 : Applicative F} {A2 : Applicative F} [@LawfulApplicative F A1] [@LawfulApplicative F A2],\n      (∀ {α : Type u} (x : α), @Pure.pure _ A1.toPure _ x = @Pure.pure _ A2.toPure _ x) →\n      (∀ {α β : Type u} (f : F (α → β)) (x : F α),\n          @Seq.seq _ A1.toSeq _ _ f (fun _ => x) = @Seq.seq _ A2.toSeq _ _ f (fun _ => x)) →\n      A1 = A2\n  | { toFunctor := F1, seq := s1, pure := p1, seqLeft := sl1, seqRight := sr1 },\n    { toFunctor := F2, seq := s2, pure := p2, seqLeft := sl2, seqRight := sr2 },\n    L1, L2, H1, H2 => by\n    obtain rfl : @p1 = @p2 := by\n      funext α x\n      apply H1\n    obtain rfl : @s1 = @s2 := by\n      funext α β f x\n      exact H2 f (x Unit.unit)\n    obtain ⟨seqLeft_eq1, seqRight_eq1, pure_seq1, -⟩ := L1\n    obtain ⟨seqLeft_eq2, seqRight_eq2, pure_seq2, -⟩ := L2\n    obtain rfl : F1 = F2 := by\n      apply Functor.ext\n      intros\n      exact (pure_seq1 _ _).symm.trans (pure_seq2 _ _)\n    congr <;> funext α β x y\n    · exact (seqLeft_eq1 _ (y Unit.unit)).trans (seqLeft_eq2 _ _).symm\n    · exact (seqRight_eq1 _ (y Unit.unit)).trans (seqRight_eq2 _ (y Unit.unit)).symm\n\n"}
{"name":"instCommApplicativeId","module":"Mathlib.Control.Applicative","initialProofState":"⊢ CommApplicative Id","decl":"instance : CommApplicative Id where commutative_prod _ _ := rfl\n\n"}
{"name":"Functor.Comp.map_pure","module":"Mathlib.Control.Applicative","initialProofState":"F : Type u → Type w\nG : Type v → Type u\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα β : Type v\nf : α → β\nx : α\n⊢ Eq (Functor.map f (Pure.pure x)) (Pure.pure (f x))","decl":"theorem map_pure (f : α → β) (x : α) : (f <$> pure x : Comp F G β) = pure (f x) :=\n  Comp.ext <| by simp\n\n"}
{"name":"Functor.Comp.seq_pure","module":"Mathlib.Control.Applicative","initialProofState":"F : Type u → Type w\nG : Type v → Type u\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα β : Type v\nf : Functor.Comp F G (α → β)\nx : α\n⊢ Eq (Seq.seq f fun x_1 => Pure.pure x) (Functor.map (fun g => g x) f)","decl":"theorem seq_pure (f : Comp F G (α → β)) (x : α) : f <*> pure x = (fun g : α → β => g x) <$> f :=\n  Comp.ext <| by simp [comp_def, functor_norm]\n\n"}
{"name":"Functor.Comp.seq_assoc","module":"Mathlib.Control.Applicative","initialProofState":"F : Type u → Type w\nG : Type v → Type u\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα β γ : Type v\nx : Functor.Comp F G α\nf : Functor.Comp F G (α → β)\ng : Functor.Comp F G (β → γ)\n⊢ Eq (Seq.seq g fun x_1 => Seq.seq f fun x_2 => x) (Seq.seq (Seq.seq (Functor.map Function.comp g) fun x => f) fun x_1 => x)","decl":"theorem seq_assoc (x : Comp F G α) (f : Comp F G (α → β)) (g : Comp F G (β → γ)) :\n    g <*> (f <*> x) = @Function.comp α β γ <$> g <*> f <*> x :=\n  Comp.ext <| by simp [comp_def, functor_norm]\n\n"}
{"name":"Functor.Comp.pure_seq_eq_map","module":"Mathlib.Control.Applicative","initialProofState":"F : Type u → Type w\nG : Type v → Type u\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\nα β : Type v\nf : α → β\nx : Functor.Comp F G α\n⊢ Eq (Seq.seq (Pure.pure f) fun x_1 => x) (Functor.map f x)","decl":"theorem pure_seq_eq_map (f : α → β) (x : Comp F G α) : pure f <*> x = f <$> x :=\n  Comp.ext <| by simp [Applicative.pure_seq_eq_map', functor_norm]\n\n-- TODO: the first two results were handled by `control_laws_tac` in mathlib3\n"}
{"name":"Functor.Comp.instLawfulApplicativeComp","module":"Mathlib.Control.Applicative","initialProofState":"F : Type u → Type w\nG : Type v → Type u\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative F\ninst✝ : LawfulApplicative G\n⊢ LawfulApplicative (Functor.Comp F G)","decl":"instance instLawfulApplicativeComp : LawfulApplicative (Comp F G) where\n  seqLeft_eq := by intros; rfl\n  seqRight_eq := by intros; rfl\n  pure_seq := Comp.pure_seq_eq_map\n  map_pure := Comp.map_pure\n  seq_pure := Comp.seq_pure\n  seq_assoc := Comp.seq_assoc\n\n-- Porting note: mathport wasn't aware of the new implicit parameter omission in these `fun` binders\n\n"}
{"name":"Functor.Comp.applicative_id_comp","module":"Mathlib.Control.Applicative","initialProofState":"F : Type u_1 → Type u_2\nAF : Applicative F\ninst✝ : LawfulApplicative F\n⊢ Eq Functor.Comp.instApplicativeComp AF","decl":"theorem applicative_id_comp {F} [AF : Applicative F] [LawfulApplicative F] :\n    @instApplicativeComp Id F _ _ = AF :=\n  @Applicative.ext F _ _ (instLawfulApplicativeComp (F := Id)) _\n    (fun _ => rfl) (fun _ _ => rfl)\n\n"}
{"name":"Functor.Comp.applicative_comp_id","module":"Mathlib.Control.Applicative","initialProofState":"F : Type u_1 → Type u_2\nAF : Applicative F\ninst✝ : LawfulApplicative F\n⊢ Eq Functor.Comp.instApplicativeComp AF","decl":"theorem applicative_comp_id {F} [AF : Applicative F] [LawfulApplicative F] :\n    @Comp.instApplicativeComp F Id _ _ = AF :=\n  @Applicative.ext F _ _ (instLawfulApplicativeComp (G := Id)) _\n    (fun _ => rfl) (fun f x => show id <$> f <*> x = f <*> x by rw [id_map])\n\n"}
{"name":"Functor.Comp.instCommApplicative","module":"Mathlib.Control.Applicative","initialProofState":"f : Type u → Type w\ng : Type v → Type u\ninst✝³ : Applicative f\ninst✝² : Applicative g\ninst✝¹ : CommApplicative f\ninst✝ : CommApplicative g\n⊢ CommApplicative (Functor.Comp f g)","decl":"instance {f : Type u → Type w} {g : Type v → Type u} [Applicative f] [Applicative g]\n    [CommApplicative f] [CommApplicative g] : CommApplicative (Comp f g) where\n  commutative_prod _ _ := by\n    simp! [map, Seq.seq]\n    rw [commutative_map]\n    simp only [mk, flip, seq_map_assoc, Function.comp_def, map_map]\n    congr\n    funext x y\n    rw [commutative_map]\n    congr\n\n"}
{"name":"Comp.seq_mk","module":"Mathlib.Control.Applicative","initialProofState":"α β : Type w\nf : Type u → Type v\ng : Type w → Type u\ninst✝¹ : Applicative f\ninst✝ : Applicative g\nh : f (g (α → β))\nx : f (g α)\n⊢ Eq (Seq.seq (Functor.Comp.mk h) fun x_1 => Functor.Comp.mk x) (Functor.Comp.mk (Seq.seq (Functor.map (fun x1 x2 => Seq.seq x1 fun x => x2) h) fun x_1 => x))","decl":"@[functor_norm]\ntheorem Comp.seq_mk {α β : Type w} {f : Type u → Type v} {g : Type w → Type u} [Applicative f]\n    [Applicative g] (h : f (g (α → β))) (x : f (g α)) :\n    Comp.mk h <*> Comp.mk x = Comp.mk ((· <*> ·) <$> h <*> x) :=\n  rfl\n\n-- Porting note: There is some awkwardness in the following definition now that we have `HMul`.\n\n"}
{"name":"instLawfulApplicativeConst","module":"Mathlib.Control.Applicative","initialProofState":"α : Type u_1\ninst✝ : Monoid α\n⊢ LawfulApplicative (Functor.Const α)","decl":"instance {α} [Monoid α] : LawfulApplicative (Const α) where\n  map_pure _ _ := rfl\n  seq_pure _ _ := by simp only [Seq.seq, pure, mul_one]; rfl\n  pure_seq _ _ := by simp only [Seq.seq, pure, one_mul]; rfl\n  seqLeft_eq _ _ := by simp only [Seq.seq]; rfl\n  seqRight_eq _ _ := by simp only [Seq.seq]; rfl\n  seq_assoc _ _ _ := by simp only [Seq.seq, mul_assoc]; rfl\n\n"}
{"name":"instLawfulApplicativeAddConst","module":"Mathlib.Control.Applicative","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\n⊢ LawfulApplicative (Functor.AddConst α)","decl":"instance {α} [AddMonoid α] : LawfulApplicative (AddConst α) where\n  map_pure _ _ := rfl\n  seq_pure _ _ := by simp only [Seq.seq, pure, add_zero]; rfl\n  pure_seq _ _ := by simp only [Seq.seq, pure, zero_add]; rfl\n  seqLeft_eq _ _ := by simp only [Seq.seq]; rfl\n  seqRight_eq _ _ := by simp only [Seq.seq]; rfl\n  seq_assoc _ _ _ := by simp only [Seq.seq, add_assoc]; rfl\n"}
