{"name":"Submodule.eq_smul_of_le_smul_of_le_jacobson","module":"Mathlib.RingTheory.Nakayama","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI J : Ideal R\nN : Submodule R M\nhN : N.FG\nhIN : LE.le N (HSMul.hSMul I N)\nhIjac : LE.le I J.jacobson\n⊢ Eq N (HSMul.hSMul J N)","decl":"/-- **Nakayama's Lemma** - A slightly more general version of (2) in\n[Stacks 00DV](https://stacks.math.columbia.edu/tag/00DV).\nSee also `eq_bot_of_le_smul_of_le_jacobson_bot` for the special case when `J = ⊥`. -/\n@[stacks 00DV \"(2)\"]\ntheorem eq_smul_of_le_smul_of_le_jacobson {I J : Ideal R} {N : Submodule R M} (hN : N.FG)\n    (hIN : N ≤ I • N) (hIjac : I ≤ jacobson J) : N = J • N := by\n  refine le_antisymm ?_ (Submodule.smul_le.2 fun _ _ _ => Submodule.smul_mem _ _)\n  intro n hn\n  cases' Submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul I N hN hIN with r hr\n  cases' exists_mul_sub_mem_of_sub_one_mem_jacobson r (hIjac hr.1) with s hs\n  have : n = -(s * r - 1) • n := by\n    rw [neg_sub, sub_smul, mul_smul, hr.2 n hn, one_smul, smul_zero, sub_zero]\n  rw [this]\n  exact Submodule.smul_mem_smul (Submodule.neg_mem _ hs) hn\n\n"}
{"name":"Submodule.eq_bot_of_eq_ideal_smul_of_le_jacobson_annihilator","module":"Mathlib.RingTheory.Nakayama","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nN : Submodule R M\nhN : N.FG\nhIN : Eq N (HSMul.hSMul I N)\nhIjac : LE.le I N.annihilator.jacobson\n⊢ Eq N Bot.bot","decl":"lemma eq_bot_of_eq_ideal_smul_of_le_jacobson_annihilator {I : Ideal R}\n    {N : Submodule R M} (hN : FG N) (hIN : N = I • N)\n    (hIjac : I ≤ N.annihilator.jacobson) : N = ⊥ :=\n  (eq_smul_of_le_smul_of_le_jacobson hN hIN.le hIjac).trans N.annihilator_smul\n\n"}
{"name":"Submodule.eq_bot_of_eq_pointwise_smul_of_mem_jacobson_annihilator","module":"Mathlib.RingTheory.Nakayama","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nN : Submodule R M\nhN : N.FG\nhrN : Eq N (HSMul.hSMul r N)\nhrJac : Membership.mem N.annihilator.jacobson r\n⊢ Eq N Bot.bot","decl":"open Pointwise in\nlemma eq_bot_of_eq_pointwise_smul_of_mem_jacobson_annihilator {r : R}\n    {N : Submodule R M} (hN : FG N) (hrN : N = r • N)\n    (hrJac : r ∈ N.annihilator.jacobson) : N = ⊥ :=\n  eq_bot_of_eq_ideal_smul_of_le_jacobson_annihilator hN\n    (Eq.trans hrN (ideal_span_singleton_smul r N).symm)\n    ((span_singleton_le_iff_mem r _).mpr hrJac)\n\n"}
{"name":"Submodule.eq_bot_of_set_smul_eq_of_subset_jacobson_annihilator","module":"Mathlib.RingTheory.Nakayama","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ns : Set R\nN : Submodule R M\nhN : N.FG\nhsN : Eq N (HSMul.hSMul s N)\nhsJac : HasSubset.Subset s ↑N.annihilator.jacobson\n⊢ Eq N Bot.bot","decl":"open Pointwise in\nlemma eq_bot_of_set_smul_eq_of_subset_jacobson_annihilator {s : Set R}\n    {N : Submodule R M} (hN : FG N) (hsN : N = s • N)\n    (hsJac : s ⊆ N.annihilator.jacobson) : N = ⊥ :=\n  eq_bot_of_eq_ideal_smul_of_le_jacobson_annihilator hN\n    (Eq.trans hsN (span_smul_eq s N).symm) (span_le.mpr hsJac)\n\n"}
{"name":"Submodule.top_ne_ideal_smul_of_le_jacobson_annihilator","module":"Mathlib.RingTheory.Nakayama","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial M\ninst✝ : Module.Finite R M\nI : Ideal R\nh : LE.le I (Module.annihilator R M).jacobson\n⊢ Ne Top.top (HSMul.hSMul I Top.top)","decl":"lemma top_ne_ideal_smul_of_le_jacobson_annihilator [Nontrivial M]\n    [Module.Finite R M] {I} (h : I ≤ (Module.annihilator R M).jacobson) :\n    (⊤ : Submodule R M) ≠ I • ⊤ := fun H => top_ne_bot <|\n  eq_bot_of_eq_ideal_smul_of_le_jacobson_annihilator Module.Finite.fg_top H <|\n    (congrArg (I ≤ Ideal.jacobson ·) annihilator_top).mpr h\n\n"}
{"name":"Submodule.top_ne_set_smul_of_subset_jacobson_annihilator","module":"Mathlib.RingTheory.Nakayama","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial M\ninst✝ : Module.Finite R M\ns : Set R\nh : HasSubset.Subset s ↑(Module.annihilator R M).jacobson\n⊢ Ne Top.top (HSMul.hSMul s Top.top)","decl":"open Pointwise in\nlemma top_ne_set_smul_of_subset_jacobson_annihilator [Nontrivial M]\n    [Module.Finite R M] {s : Set R}\n    (h : s ⊆ (Module.annihilator R M).jacobson) :\n    (⊤ : Submodule R M) ≠ s • ⊤ :=\n  ne_of_ne_of_eq (top_ne_ideal_smul_of_le_jacobson_annihilator (span_le.mpr h))\n    (span_smul_eq _ _)\n\n"}
{"name":"Submodule.top_ne_pointwise_smul_of_mem_jacobson_annihilator","module":"Mathlib.RingTheory.Nakayama","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial M\ninst✝ : Module.Finite R M\nr : R\nh : Membership.mem (Module.annihilator R M).jacobson r\n⊢ Ne Top.top (HSMul.hSMul r Top.top)","decl":"open Pointwise in\nlemma top_ne_pointwise_smul_of_mem_jacobson_annihilator [Nontrivial M]\n    [Module.Finite R M] {r} (h : r ∈ (Module.annihilator R M).jacobson) :\n    (⊤ : Submodule R M) ≠ r • ⊤ :=\n  ne_of_ne_of_eq (top_ne_set_smul_of_subset_jacobson_annihilator <|\n                    Set.singleton_subset_iff.mpr h) (singleton_set_smul ⊤ r)\n\n"}
{"name":"Submodule.eq_bot_of_le_smul_of_le_jacobson_bot","module":"Mathlib.RingTheory.Nakayama","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nN : Submodule R M\nhN : N.FG\nhIN : LE.le N (HSMul.hSMul I N)\nhIjac : LE.le I Bot.bot.jacobson\n⊢ Eq N Bot.bot","decl":"/-- **Nakayama's Lemma** - Statement (2) in\n[Stacks 00DV](https://stacks.math.columbia.edu/tag/00DV).\nSee also `eq_smul_of_le_smul_of_le_jacobson` for a generalisation\nto the `jacobson` of any ideal -/\n@[stacks 00DV \"(2)\"]\ntheorem eq_bot_of_le_smul_of_le_jacobson_bot (I : Ideal R) (N : Submodule R M) (hN : N.FG)\n    (hIN : N ≤ I • N) (hIjac : I ≤ jacobson ⊥) : N = ⊥ := by\n  rw [eq_smul_of_le_smul_of_le_jacobson hN hIN hIjac, Submodule.bot_smul]\n\n"}
{"name":"Submodule.sup_eq_sup_smul_of_le_smul_of_le_jacobson","module":"Mathlib.RingTheory.Nakayama","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI J : Ideal R\nN N' : Submodule R M\nhN' : N'.FG\nhIJ : LE.le I J.jacobson\nhNN : LE.le N' (Max.max N (HSMul.hSMul I N'))\n⊢ Eq (Max.max N N') (Max.max N (HSMul.hSMul J N'))","decl":"theorem sup_eq_sup_smul_of_le_smul_of_le_jacobson {I J : Ideal R} {N N' : Submodule R M}\n    (hN' : N'.FG) (hIJ : I ≤ jacobson J) (hNN : N' ≤ N ⊔ I • N') : N ⊔ N' = N ⊔ J • N' := by\n  have hNN' : N ⊔ N' = N ⊔ I • N' :=\n    le_antisymm (sup_le le_sup_left hNN)\n    (sup_le_sup_left (Submodule.smul_le.2 fun _ _ _ => Submodule.smul_mem _ _) _)\n  have h_comap :=\n    comap_injective_of_surjective (LinearMap.range_eq_top.1 N.range_mkQ)\n  have : (I • N').map N.mkQ = N'.map N.mkQ := by\n    simpa only [← h_comap.eq_iff, comap_map_mkQ, sup_comm, eq_comm] using hNN'\n  have :=\n    @Submodule.eq_smul_of_le_smul_of_le_jacobson _ _ _ _ _ I J (N'.map N.mkQ) (hN'.map _)\n      (by rw [← map_smul'', this]) hIJ\n  rwa [← map_smul'', ← h_comap.eq_iff, comap_map_eq, comap_map_eq, Submodule.ker_mkQ, sup_comm,\n    sup_comm (b := N)] at this\n\n"}
{"name":"Submodule.sup_smul_eq_sup_smul_of_le_smul_of_le_jacobson","module":"Mathlib.RingTheory.Nakayama","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI J : Ideal R\nN N' : Submodule R M\nhN' : N'.FG\nhIJ : LE.le I J.jacobson\nhNN : LE.le N' (Max.max N (HSMul.hSMul I N'))\n⊢ Eq (Max.max N (HSMul.hSMul I N')) (Max.max N (HSMul.hSMul J N'))","decl":"/-- **Nakayama's Lemma** - A slightly more general version of (4) in\n[Stacks 00DV](https://stacks.math.columbia.edu/tag/00DV).\nSee also `smul_le_of_le_smul_of_le_jacobson_bot` for the special case when `J = ⊥`. -/\n@[stacks 00DV \"(4)\"]\ntheorem sup_smul_eq_sup_smul_of_le_smul_of_le_jacobson {I J : Ideal R} {N N' : Submodule R M}\n    (hN' : N'.FG) (hIJ : I ≤ jacobson J) (hNN : N' ≤ N ⊔ I • N') : N ⊔ I • N' = N ⊔ J • N' :=\n  ((sup_le_sup_left smul_le_right _).antisymm (sup_le le_sup_left hNN)).trans\n    (sup_eq_sup_smul_of_le_smul_of_le_jacobson hN' hIJ hNN)\n\n"}
{"name":"Submodule.le_of_le_smul_of_le_jacobson_bot","module":"Mathlib.RingTheory.Nakayama","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nN N' : Submodule R M\nhN' : N'.FG\nhIJ : LE.le I Bot.bot.jacobson\nhNN : LE.le N' (Max.max N (HSMul.hSMul I N'))\n⊢ LE.le N' N","decl":"theorem le_of_le_smul_of_le_jacobson_bot {R M} [CommRing R] [AddCommGroup M] [Module R M]\n    {I : Ideal R} {N N' : Submodule R M} (hN' : N'.FG)\n    (hIJ : I ≤ jacobson ⊥) (hNN : N' ≤ N ⊔ I • N') : N' ≤ N := by\n  rw [← sup_eq_left, sup_eq_sup_smul_of_le_smul_of_le_jacobson hN' hIJ hNN, bot_smul, sup_bot_eq]\n\n"}
{"name":"Submodule.smul_le_of_le_smul_of_le_jacobson_bot","module":"Mathlib.RingTheory.Nakayama","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nN N' : Submodule R M\nhN' : N'.FG\nhIJ : LE.le I Bot.bot.jacobson\nhNN : LE.le N' (Max.max N (HSMul.hSMul I N'))\n⊢ LE.le (HSMul.hSMul I N') N","decl":"/-- **Nakayama's Lemma** - Statement (4) in\n[Stacks 00DV](https://stacks.math.columbia.edu/tag/00DV).\nSee also `sup_smul_eq_sup_smul_of_le_smul_of_le_jacobson` for a generalisation\nto the `jacobson` of any ideal -/\n@[stacks 00DV \"(4)\"]\ntheorem smul_le_of_le_smul_of_le_jacobson_bot {I : Ideal R} {N N' : Submodule R M} (hN' : N'.FG)\n    (hIJ : I ≤ jacobson ⊥) (hNN : N' ≤ N ⊔ I • N') : I • N' ≤ N :=\n  smul_le_right.trans (le_of_le_smul_of_le_jacobson_bot hN' hIJ hNN)\n\n"}
{"name":"Submodule.exists_sub_one_mem_and_smul_le_of_fg_of_le_sup","module":"Mathlib.RingTheory.Nakayama","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nI : Ideal R\nN N' P : Submodule R M\nhN' : N'.FG\nhN'le : LE.le N' P\nhNN' : LE.le P (Max.max N (HSMul.hSMul I N'))\n⊢ Exists fun r => And (Membership.mem I (HSub.hSub r 1)) (LE.le (HSMul.hSMul r P) N)","decl":"@[stacks 00DV \"(3) see `Submodule.localized₀_le_localized₀_of_smul_le` for the second conclusion.\"]\nlemma exists_sub_one_mem_and_smul_le_of_fg_of_le_sup {I : Ideal R}\n    {N N' P : Submodule R M} (hN' : N'.FG) (hN'le : N' ≤ P) (hNN' : P ≤ N ⊔ I • N') :\n    ∃ r : R, r - 1 ∈ I ∧ r • P ≤ N := by\n  have hNN'' : P ≤ N ⊔ N' := le_trans hNN' (by simpa using le_trans smul_le_right le_sup_right)\n  have h1 : P.map N.mkQ = N'.map N.mkQ := by\n    refine le_antisymm ?_ (map_mono hN'le)\n    simpa using map_mono (f := N.mkQ) hNN''\n  have h2 : P.map N.mkQ = (I • N').map N.mkQ := by\n    apply le_antisymm\n    · simpa using map_mono (f := N.mkQ) hNN'\n    · rw [h1]\n      simp [smul_le_right]\n  have hle : (P.map N.mkQ) ≤ I • P.map N.mkQ := by\n    conv_lhs => rw [h2]\n    simp [← h1]\n  obtain ⟨r, hmem, hr⟩ := exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul I _\n    (h1 ▸ hN'.map _) hle\n  refine ⟨r, hmem, fun x hx ↦ ?_⟩\n  induction' hx using Submodule.smul_inductionOn_pointwise with p hp _ _ _ h _ _ _ _ hx hy\n  · rw [← Submodule.Quotient.mk_eq_zero, Quotient.mk_smul]\n    exact hr _ ⟨p, hp, rfl⟩\n  · exact N.smul_mem _ h\n  · exact N.add_mem hx hy\n  · exact N.zero_mem\n\n"}
