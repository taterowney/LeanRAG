{"name":"wittStructureRat_prop","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Rat\nn : Nat\n⊢ Eq ((MvPolynomial.bind₁ (wittStructureRat p Φ)) (wittPolynomial p Rat n)) ((MvPolynomial.bind₁ fun i => (MvPolynomial.rename (Prod.mk i)) (wittPolynomial p Rat n)) Φ)","decl":"theorem wittStructureRat_prop (Φ : MvPolynomial idx ℚ) (n : ℕ) :\n    bind₁ (wittStructureRat p Φ) (W_ ℚ n) = bind₁ (fun i => rename (Prod.mk i) (W_ ℚ n)) Φ :=\n  calc\n    bind₁ (wittStructureRat p Φ) (W_ ℚ n) =\n        bind₁ (fun k => bind₁ (fun i => (rename (Prod.mk i)) (W_ ℚ k)) Φ)\n          (bind₁ (xInTermsOfW p ℚ) (W_ ℚ n)) := by\n      rw [bind₁_bind₁]; exact eval₂Hom_congr (RingHom.ext_rat _ _) rfl rfl\n    _ = bind₁ (fun i => rename (Prod.mk i) (W_ ℚ n)) Φ := by\n      rw [bind₁_xInTermsOfW_wittPolynomial p _ n, bind₁_X_right]\n\n"}
{"name":"wittStructureRat_existsUnique","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Rat\n⊢ ExistsUnique fun φ => ∀ (n : Nat), Eq ((MvPolynomial.bind₁ φ) (wittPolynomial p Rat n)) ((MvPolynomial.bind₁ fun i => (MvPolynomial.rename (Prod.mk i)) (wittPolynomial p Rat n)) Φ)","decl":"theorem wittStructureRat_existsUnique (Φ : MvPolynomial idx ℚ) :\n    ∃! φ : ℕ → MvPolynomial (idx × ℕ) ℚ,\n      ∀ n : ℕ, bind₁ φ (W_ ℚ n) = bind₁ (fun i => rename (Prod.mk i) (W_ ℚ n)) Φ := by\n  refine ⟨wittStructureRat p Φ, ?_, ?_⟩\n  · intro n; apply wittStructureRat_prop\n  · intro φ H\n    funext n\n    rw [show φ n = bind₁ φ (bind₁ (W_ ℚ) (xInTermsOfW p ℚ n)) by\n        rw [bind₁_wittPolynomial_xInTermsOfW p, bind₁_X_right]]\n    rw [bind₁_bind₁]\n    exact eval₂Hom_congr (RingHom.ext_rat _ _) (funext H) rfl\n\n"}
{"name":"wittStructureRat_rec_aux","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Rat\nn : Nat\n⊢ Eq (HMul.hMul (wittStructureRat p Φ n) (MvPolynomial.C (HPow.hPow (↑p) n))) (HSub.hSub ((MvPolynomial.bind₁ fun b => (MvPolynomial.rename fun i => { fst := b, snd := i }) (wittPolynomial p Rat n)) Φ) ((Finset.range n).sum fun i => HMul.hMul (MvPolynomial.C (HPow.hPow (↑p) i)) (HPow.hPow (wittStructureRat p Φ i) (HPow.hPow p (HSub.hSub n i)))))","decl":"theorem wittStructureRat_rec_aux (Φ : MvPolynomial idx ℚ) (n : ℕ) :\n    wittStructureRat p Φ n * C ((p : ℚ) ^ n) =\n      bind₁ (fun b => rename (fun i => (b, i)) (W_ ℚ n)) Φ -\n        ∑ i ∈ range n, C ((p : ℚ) ^ i) * wittStructureRat p Φ i ^ p ^ (n - i) := by\n  have := xInTermsOfW_aux p ℚ n\n  replace := congr_arg (bind₁ fun k : ℕ => bind₁ (fun i => rename (Prod.mk i) (W_ ℚ k)) Φ) this\n  rw [map_mul, bind₁_C_right] at this\n  rw [wittStructureRat, this]; clear this\n  conv_lhs => simp only [map_sub, bind₁_X_right]\n  rw [sub_right_inj]\n  simp only [map_sum, map_mul, bind₁_C_right, map_pow]\n  rfl\n\n"}
{"name":"wittStructureRat_rec","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Rat\nn : Nat\n⊢ Eq (wittStructureRat p Φ n) (HMul.hMul (MvPolynomial.C (HDiv.hDiv 1 (HPow.hPow (↑p) n))) (HSub.hSub ((MvPolynomial.bind₁ fun b => (MvPolynomial.rename fun i => { fst := b, snd := i }) (wittPolynomial p Rat n)) Φ) ((Finset.range n).sum fun i => HMul.hMul (MvPolynomial.C (HPow.hPow (↑p) i)) (HPow.hPow (wittStructureRat p Φ i) (HPow.hPow p (HSub.hSub n i))))))","decl":"/-- Write `wittStructureRat p φ n` in terms of `wittStructureRat p φ i` for `i < n`. -/\ntheorem wittStructureRat_rec (Φ : MvPolynomial idx ℚ) (n : ℕ) :\n    wittStructureRat p Φ n =\n      C (1 / (p : ℚ) ^ n) *\n        (bind₁ (fun b => rename (fun i => (b, i)) (W_ ℚ n)) Φ -\n          ∑ i ∈ range n, C ((p : ℚ) ^ i) * wittStructureRat p Φ i ^ p ^ (n - i)) := by\n  calc\n    wittStructureRat p Φ n = C (1 / (p : ℚ) ^ n) * (wittStructureRat p Φ n * C ((p : ℚ) ^ n)) := ?_\n    _ = _ := by rw [wittStructureRat_rec_aux]\n  rw [mul_left_comm, ← C_mul, div_mul_cancel₀, C_1, mul_one]\n  exact pow_ne_zero _ (Nat.cast_ne_zero.2 hp.1.ne_zero)\n\n"}
{"name":"bind₁_rename_expand_wittPolynomial","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Int\nn : Nat\nIH : ∀ (m : Nat), LT.lt m (HAdd.hAdd n 1) → Eq ((MvPolynomial.map (Int.castRingHom Rat)) (wittStructureInt p Φ m)) (wittStructureRat p ((MvPolynomial.map (Int.castRingHom Rat)) Φ) m)\n⊢ Eq ((MvPolynomial.bind₁ fun b => (MvPolynomial.rename fun i => { fst := b, snd := i }) ((MvPolynomial.expand p) (wittPolynomial p Int n))) Φ) ((MvPolynomial.bind₁ fun i => (MvPolynomial.expand p) (wittStructureInt p Φ i)) (wittPolynomial p Int n))","decl":"theorem bind₁_rename_expand_wittPolynomial (Φ : MvPolynomial idx ℤ) (n : ℕ)\n    (IH :\n      ∀ m : ℕ,\n        m < n + 1 →\n          map (Int.castRingHom ℚ) (wittStructureInt p Φ m) =\n            wittStructureRat p (map (Int.castRingHom ℚ) Φ) m) :\n    bind₁ (fun b => rename (fun i => (b, i)) (expand p (W_ ℤ n))) Φ =\n      bind₁ (fun i => expand p (wittStructureInt p Φ i)) (W_ ℤ n) := by\n  apply MvPolynomial.map_injective (Int.castRingHom ℚ) Int.cast_injective\n  simp only [map_bind₁, map_rename, map_expand, rename_expand, map_wittPolynomial]\n  have key := (wittStructureRat_prop p (map (Int.castRingHom ℚ) Φ) n).symm\n  apply_fun expand p at key\n  simp only [expand_bind₁] at key\n  rw [key]; clear key\n  apply eval₂Hom_congr' rfl _ rfl\n  rintro i hi -\n  rw [wittPolynomial_vars, Finset.mem_range] at hi\n  simp only [IH i hi]\n\n"}
{"name":"C_p_pow_dvd_bind₁_rename_wittPolynomial_sub_sum","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Int\nn : Nat\nIH : ∀ (m : Nat), LT.lt m n → Eq ((MvPolynomial.map (Int.castRingHom Rat)) (wittStructureInt p Φ m)) (wittStructureRat p ((MvPolynomial.map (Int.castRingHom Rat)) Φ) m)\n⊢ Dvd.dvd (MvPolynomial.C ↑(HPow.hPow p n)) (HSub.hSub ((MvPolynomial.bind₁ fun b => (MvPolynomial.rename fun i => { fst := b, snd := i }) (wittPolynomial p Int n)) Φ) ((Finset.range n).sum fun i => HMul.hMul (MvPolynomial.C (HPow.hPow (↑p) i)) (HPow.hPow (wittStructureInt p Φ i) (HPow.hPow p (HSub.hSub n i)))))","decl":"theorem C_p_pow_dvd_bind₁_rename_wittPolynomial_sub_sum (Φ : MvPolynomial idx ℤ) (n : ℕ)\n    (IH :\n      ∀ m : ℕ,\n        m < n →\n          map (Int.castRingHom ℚ) (wittStructureInt p Φ m) =\n            wittStructureRat p (map (Int.castRingHom ℚ) Φ) m) :\n    (C ((p ^ n :) : ℤ) : MvPolynomial (idx × ℕ) ℤ) ∣\n      bind₁ (fun b : idx => rename (fun i => (b, i)) (wittPolynomial p ℤ n)) Φ -\n        ∑ i ∈ range n, C ((p : ℤ) ^ i) * wittStructureInt p Φ i ^ p ^ (n - i) := by\n  cases' n with n\n  · simp only [isUnit_one, Int.ofNat_zero, Int.ofNat_succ, zero_add, pow_zero, C_1, IsUnit.dvd,\n      Nat.cast_one]\n  -- prepare a useful equation for rewriting\n  have key := bind₁_rename_expand_wittPolynomial Φ n IH\n  apply_fun map (Int.castRingHom (ZMod (p ^ (n + 1)))) at key\n  conv_lhs at key => simp only [map_bind₁, map_rename, map_expand, map_wittPolynomial]\n  -- clean up and massage\n  rw [C_dvd_iff_zmod, RingHom.map_sub, sub_eq_zero, map_bind₁]\n  simp only [map_rename, map_wittPolynomial, wittPolynomial_zmod_self]\n  rw [key]; clear key IH\n  rw [bind₁, aeval_wittPolynomial, map_sum, map_sum, Finset.sum_congr rfl]\n  intro k hk\n  rw [Finset.mem_range, Nat.lt_succ_iff] at hk\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11083): was much slower\n  -- simp only [← sub_eq_zero, ← RingHom.map_sub, ← C_dvd_iff_zmod, C_eq_coe_nat, ← mul_sub, ←\n  --   Nat.cast_pow]\n  rw [← sub_eq_zero, ← RingHom.map_sub, ← C_dvd_iff_zmod, C_eq_coe_nat, ← Nat.cast_pow,\n    ← Nat.cast_pow, C_eq_coe_nat, ← mul_sub]\n  have : p ^ (n + 1) = p ^ k * p ^ (n - k + 1) := by\n    rw [← pow_add, ← add_assoc]; congr 2; rw [add_comm, ← tsub_eq_iff_eq_add_of_le hk]\n  rw [this]\n  rw [Nat.cast_mul, Nat.cast_pow, Nat.cast_pow]\n  apply mul_dvd_mul_left ((p : MvPolynomial (idx × ℕ) ℤ) ^ k)\n  rw [show p ^ (n + 1 - k) = p * p ^ (n - k) by rw [← pow_succ', ← tsub_add_eq_add_tsub hk]]\n  rw [pow_mul]\n  -- the machine!\n  apply dvd_sub_pow_of_dvd_sub\n  rw [← C_eq_coe_nat, C_dvd_iff_zmod, RingHom.map_sub, sub_eq_zero, map_expand, RingHom.map_pow,\n    MvPolynomial.expand_zmod]\n\n"}
{"name":"map_wittStructureInt","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Int\nn : Nat\n⊢ Eq ((MvPolynomial.map (Int.castRingHom Rat)) (wittStructureInt p Φ n)) (wittStructureRat p ((MvPolynomial.map (Int.castRingHom Rat)) Φ) n)","decl":"@[simp]\ntheorem map_wittStructureInt (Φ : MvPolynomial idx ℤ) (n : ℕ) :\n    map (Int.castRingHom ℚ) (wittStructureInt p Φ n) =\n      wittStructureRat p (map (Int.castRingHom ℚ) Φ) n := by\n  induction n using Nat.strong_induction_on with | h n IH => ?_\n  rw [wittStructureInt, map_mapRange_eq_iff, Int.coe_castRingHom]\n  intro c\n  rw [wittStructureRat_rec, coeff_C_mul, mul_comm, mul_div_assoc', mul_one]\n  have sum_induction_steps :\n      map (Int.castRingHom ℚ)\n        (∑ i ∈ range n, C ((p : ℤ) ^ i) * wittStructureInt p Φ i ^ p ^ (n - i)) =\n      ∑ i ∈ range n,\n        C ((p : ℚ) ^ i) * wittStructureRat p (map (Int.castRingHom ℚ) Φ) i ^ p ^ (n - i) := by\n    rw [map_sum]\n    apply Finset.sum_congr rfl\n    intro i hi\n    rw [Finset.mem_range] at hi\n    simp only [IH i hi, RingHom.map_mul, RingHom.map_pow, map_C]\n    rfl\n  simp only [← sum_induction_steps, ← map_wittPolynomial p (Int.castRingHom ℚ), ← map_rename, ←\n    map_bind₁, ← RingHom.map_sub, coeff_map]\n  rw [show (p : ℚ) ^ n = ((↑(p ^ n) : ℤ) : ℚ) by norm_cast]\n  rw [← Rat.den_eq_one_iff, eq_intCast, Rat.den_div_intCast_eq_one_iff]\n  swap; · exact mod_cast pow_ne_zero n hp.1.ne_zero\n  revert c; rw [← C_dvd_iff_dvd_coeff]\n  exact C_p_pow_dvd_bind₁_rename_wittPolynomial_sub_sum Φ n IH\n\n"}
{"name":"wittStructureInt_prop","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Int\nn : Nat\n⊢ Eq ((MvPolynomial.bind₁ (wittStructureInt p Φ)) (wittPolynomial p Int n)) ((MvPolynomial.bind₁ fun i => (MvPolynomial.rename (Prod.mk i)) (wittPolynomial p Int n)) Φ)","decl":"theorem wittStructureInt_prop (Φ : MvPolynomial idx ℤ) (n) :\n    bind₁ (wittStructureInt p Φ) (wittPolynomial p ℤ n) =\n      bind₁ (fun i => rename (Prod.mk i) (W_ ℤ n)) Φ := by\n  apply MvPolynomial.map_injective (Int.castRingHom ℚ) Int.cast_injective\n  have := wittStructureRat_prop p (map (Int.castRingHom ℚ) Φ) n\n  simpa only [map_bind₁, ← eval₂Hom_map_hom, eval₂Hom_C_left, map_rename, map_wittPolynomial,\n    AlgHom.coe_toRingHom, map_wittStructureInt]\n\n"}
{"name":"eq_wittStructureInt","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Int\nφ : Nat → MvPolynomial (Prod idx Nat) Int\nh : ∀ (n : Nat), Eq ((MvPolynomial.bind₁ φ) (wittPolynomial p Int n)) ((MvPolynomial.bind₁ fun i => (MvPolynomial.rename (Prod.mk i)) (wittPolynomial p Int n)) Φ)\n⊢ Eq φ (wittStructureInt p Φ)","decl":"theorem eq_wittStructureInt (Φ : MvPolynomial idx ℤ) (φ : ℕ → MvPolynomial (idx × ℕ) ℤ)\n    (h : ∀ n, bind₁ φ (wittPolynomial p ℤ n) = bind₁ (fun i => rename (Prod.mk i) (W_ ℤ n)) Φ) :\n    φ = wittStructureInt p Φ := by\n  funext k\n  apply MvPolynomial.map_injective (Int.castRingHom ℚ) Int.cast_injective\n  rw [map_wittStructureInt]\n  -- Porting note: was `refine' congr_fun _ k`\n  revert k\n  refine congr_fun ?_\n  apply ExistsUnique.unique (wittStructureRat_existsUnique p (map (Int.castRingHom ℚ) Φ))\n  · intro n\n    specialize h n\n    apply_fun map (Int.castRingHom ℚ) at h\n    simpa only [map_bind₁, ← eval₂Hom_map_hom, eval₂Hom_C_left, map_rename, map_wittPolynomial,\n      AlgHom.coe_toRingHom] using h\n  · intro n; apply wittStructureRat_prop\n\n"}
{"name":"wittStructureInt_existsUnique","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Int\n⊢ ExistsUnique fun φ => ∀ (n : Nat), Eq ((MvPolynomial.bind₁ φ) (wittPolynomial p Int n)) ((MvPolynomial.bind₁ fun i => (MvPolynomial.rename (Prod.mk i)) (wittPolynomial p Int n)) Φ)","decl":"theorem wittStructureInt_existsUnique (Φ : MvPolynomial idx ℤ) :\n    ∃! φ : ℕ → MvPolynomial (idx × ℕ) ℤ,\n      ∀ n : ℕ,\n        bind₁ φ (wittPolynomial p ℤ n) = bind₁ (fun i : idx => rename (Prod.mk i) (W_ ℤ n)) Φ :=\n  ⟨wittStructureInt p Φ, wittStructureInt_prop _ _, eq_wittStructureInt _ _⟩\n\n"}
{"name":"witt_structure_prop","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nR : Type u_1\nidx : Type u_2\ninst✝ : CommRing R\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Int\nn : Nat\n⊢ Eq ((MvPolynomial.aeval fun i => (MvPolynomial.map (Int.castRingHom R)) (wittStructureInt p Φ i)) (wittPolynomial p Int n)) ((MvPolynomial.aeval fun i => (MvPolynomial.rename (Prod.mk i)) (wittPolynomial p R n)) Φ)","decl":"theorem witt_structure_prop (Φ : MvPolynomial idx ℤ) (n) :\n    aeval (fun i => map (Int.castRingHom R) (wittStructureInt p Φ i)) (wittPolynomial p ℤ n) =\n      aeval (fun i => rename (Prod.mk i) (W n)) Φ := by\n  convert congr_arg (map (Int.castRingHom R)) (wittStructureInt_prop p Φ n) using 1 <;>\n      rw [hom_bind₁] <;>\n    apply eval₂Hom_congr (RingHom.ext_int _ _) _ rfl\n  · rfl\n  · simp only [map_rename, map_wittPolynomial]\n\n"}
{"name":"wittStructureInt_rename","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nσ : Type u_3\nΦ : MvPolynomial idx Int\nf : idx → σ\nn : Nat\n⊢ Eq (wittStructureInt p ((MvPolynomial.rename f) Φ) n) ((MvPolynomial.rename (Prod.map f id)) (wittStructureInt p Φ n))","decl":"theorem wittStructureInt_rename {σ : Type*} (Φ : MvPolynomial idx ℤ) (f : idx → σ) (n : ℕ) :\n    wittStructureInt p (rename f Φ) n = rename (Prod.map f id) (wittStructureInt p Φ n) := by\n  apply MvPolynomial.map_injective (Int.castRingHom ℚ) Int.cast_injective\n  simp only [map_rename, map_wittStructureInt, wittStructureRat, rename_bind₁, rename_rename,\n    bind₁_rename]\n  rfl\n\n"}
{"name":"constantCoeff_wittStructureRat_zero","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Rat\n⊢ Eq (MvPolynomial.constantCoeff (wittStructureRat p Φ 0)) (MvPolynomial.constantCoeff Φ)","decl":"@[simp]\ntheorem constantCoeff_wittStructureRat_zero (Φ : MvPolynomial idx ℚ) :\n    constantCoeff (wittStructureRat p Φ 0) = constantCoeff Φ := by\n  simp only [wittStructureRat, bind₁, map_aeval, xInTermsOfW_zero, constantCoeff_rename,\n    constantCoeff_wittPolynomial, aeval_X, constantCoeff_comp_algebraMap, eval₂Hom_zero'_apply,\n    RingHom.id_apply]\n\n"}
{"name":"constantCoeff_wittStructureRat","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Rat\nh : Eq (MvPolynomial.constantCoeff Φ) 0\nn : Nat\n⊢ Eq (MvPolynomial.constantCoeff (wittStructureRat p Φ n)) 0","decl":"theorem constantCoeff_wittStructureRat (Φ : MvPolynomial idx ℚ) (h : constantCoeff Φ = 0) (n : ℕ) :\n    constantCoeff (wittStructureRat p Φ n) = 0 := by\n  simp only [wittStructureRat, eval₂Hom_zero'_apply, h, bind₁, map_aeval, constantCoeff_rename,\n    constantCoeff_wittPolynomial, constantCoeff_comp_algebraMap, RingHom.id_apply,\n    constantCoeff_xInTermsOfW]\n\n"}
{"name":"constantCoeff_wittStructureInt_zero","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Int\n⊢ Eq (MvPolynomial.constantCoeff (wittStructureInt p Φ 0)) (MvPolynomial.constantCoeff Φ)","decl":"@[simp]\ntheorem constantCoeff_wittStructureInt_zero (Φ : MvPolynomial idx ℤ) :\n    constantCoeff (wittStructureInt p Φ 0) = constantCoeff Φ := by\n  have inj : Function.Injective (Int.castRingHom ℚ) := by intro m n; exact Int.cast_inj.mp\n  apply inj\n  rw [← constantCoeff_map, map_wittStructureInt, constantCoeff_wittStructureRat_zero,\n    constantCoeff_map]\n\n"}
{"name":"constantCoeff_wittStructureInt","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\nΦ : MvPolynomial idx Int\nh : Eq (MvPolynomial.constantCoeff Φ) 0\nn : Nat\n⊢ Eq (MvPolynomial.constantCoeff (wittStructureInt p Φ n)) 0","decl":"theorem constantCoeff_wittStructureInt (Φ : MvPolynomial idx ℤ) (h : constantCoeff Φ = 0) (n : ℕ) :\n    constantCoeff (wittStructureInt p Φ n) = 0 := by\n  have inj : Function.Injective (Int.castRingHom ℚ) := by intro m n; exact Int.cast_inj.mp\n  apply inj\n  rw [← constantCoeff_map, map_wittStructureInt, constantCoeff_wittStructureRat, RingHom.map_zero]\n  rw [constantCoeff_map, h, RingHom.map_zero]\n\n"}
{"name":"wittStructureRat_vars","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\ninst✝ : Fintype idx\nΦ : MvPolynomial idx Rat\nn : Nat\n⊢ HasSubset.Subset (wittStructureRat p Φ n).vars (SProd.sprod Finset.univ (Finset.range (HAdd.hAdd n 1)))","decl":"theorem wittStructureRat_vars [Fintype idx] (Φ : MvPolynomial idx ℚ) (n : ℕ) :\n    (wittStructureRat p Φ n).vars ⊆ Finset.univ ×ˢ Finset.range (n + 1) := by\n  rw [wittStructureRat]\n  intro x hx\n  simp only [Finset.mem_product, true_and, Finset.mem_univ, Finset.mem_range]\n  obtain ⟨k, hk, hx'⟩ := mem_vars_bind₁ _ _ hx\n  obtain ⟨i, -, hx''⟩ := mem_vars_bind₁ _ _ hx'\n  obtain ⟨j, hj, rfl⟩ := mem_vars_rename _ _ hx''\n  rw [wittPolynomial_vars, Finset.mem_range] at hj\n  replace hk := xInTermsOfW_vars_subset p _ hk\n  rw [Finset.mem_range] at hk\n  exact lt_of_lt_of_le hj hk\n\n-- we could relax the fintype on `idx`, but then we need to cast from finset to set.\n-- for our applications `idx` is always finite.\n"}
{"name":"wittStructureInt_vars","module":"Mathlib.RingTheory.WittVector.StructurePolynomial","initialProofState":"p : Nat\nidx : Type u_2\nhp : Fact (Nat.Prime p)\ninst✝ : Fintype idx\nΦ : MvPolynomial idx Int\nn : Nat\n⊢ HasSubset.Subset (wittStructureInt p Φ n).vars (SProd.sprod Finset.univ (Finset.range (HAdd.hAdd n 1)))","decl":"theorem wittStructureInt_vars [Fintype idx] (Φ : MvPolynomial idx ℤ) (n : ℕ) :\n    (wittStructureInt p Φ n).vars ⊆ Finset.univ ×ˢ Finset.range (n + 1) := by\n  have : Function.Injective (Int.castRingHom ℚ) := Int.cast_injective\n  rw [← vars_map_of_injective _ this, map_wittStructureInt]\n  apply wittStructureRat_vars\n\n"}
