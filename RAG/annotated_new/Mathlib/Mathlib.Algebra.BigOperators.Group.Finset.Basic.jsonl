{"name":"Finset.sum_eq_fold","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → β\n⊢ Eq (s.sum fun x => f x) (Finset.fold (fun x1 x2 => HAdd.hAdd x1 x2) 0 f s)","decl":"@[to_additive]\ntheorem prod_eq_fold [CommMonoid β] (s : Finset α) (f : α → β) :\n    ∏ x ∈ s, f x = s.fold ((· * ·) : β → β → β) 1 f :=\n  rfl\n\n"}
{"name":"Finset.prod_eq_fold","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nf : α → β\n⊢ Eq (s.prod fun x => f x) (Finset.fold (fun x1 x2 => HMul.hMul x1 x2) 1 f s)","decl":"@[to_additive]\ntheorem prod_eq_fold [CommMonoid β] (s : Finset α) (f : α → β) :\n    ∏ x ∈ s, f x = s.fold ((· * ·) : β → β → β) 1 f :=\n  rfl\n\n"}
{"name":"MonoidHom.coe_finset_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝¹ : MulOneClass β\ninst✝ : CommMonoid γ\nf : α → MonoidHom β γ\ns : Finset α\n⊢ Eq (⇑(s.prod fun x => f x)) (s.prod fun x => ⇑(f x))","decl":"@[to_additive]\ntheorem MonoidHom.coe_finset_prod [MulOneClass β] [CommMonoid γ] (f : α → β →* γ) (s : Finset α) :\n    ⇑(∏ x ∈ s, f x) = ∏ x ∈ s, ⇑(f x) :=\n  map_prod (MonoidHom.coeFn β γ) _ _\n\n"}
{"name":"AddMonoidHom.coe_finset_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝¹ : AddZeroClass β\ninst✝ : AddCommMonoid γ\nf : α → AddMonoidHom β γ\ns : Finset α\n⊢ Eq (⇑(s.sum fun x => f x)) (s.sum fun x => ⇑(f x))","decl":"@[to_additive]\ntheorem MonoidHom.coe_finset_prod [MulOneClass β] [CommMonoid γ] (f : α → β →* γ) (s : Finset α) :\n    ⇑(∏ x ∈ s, f x) = ∏ x ∈ s, ⇑(f x) :=\n  map_prod (MonoidHom.coeFn β γ) _ _\n\n"}
{"name":"AddMonoidHom.finset_sum_apply","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝¹ : AddZeroClass β\ninst✝ : AddCommMonoid γ\nf : α → AddMonoidHom β γ\ns : Finset α\nb : β\n⊢ Eq ((s.sum fun x => f x) b) (s.sum fun x => (f x) b)","decl":"/-- See also `Finset.prod_apply`, with the same conclusion but with the weaker hypothesis\n`f : α → β → γ` -/\n@[to_additive (attr := simp)\n  \"See also `Finset.sum_apply`, with the same conclusion but with the weaker hypothesis\n  `f : α → β → γ`\"]\ntheorem MonoidHom.finset_prod_apply [MulOneClass β] [CommMonoid γ] (f : α → β →* γ) (s : Finset α)\n    (b : β) : (∏ x ∈ s, f x) b = ∏ x ∈ s, f x b :=\n  map_prod (MonoidHom.eval b) _ _\n\n"}
{"name":"MonoidHom.finset_prod_apply","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝¹ : MulOneClass β\ninst✝ : CommMonoid γ\nf : α → MonoidHom β γ\ns : Finset α\nb : β\n⊢ Eq ((s.prod fun x => f x) b) (s.prod fun x => (f x) b)","decl":"/-- See also `Finset.prod_apply`, with the same conclusion but with the weaker hypothesis\n`f : α → β → γ` -/\n@[to_additive (attr := simp)\n  \"See also `Finset.sum_apply`, with the same conclusion but with the weaker hypothesis\n  `f : α → β → γ`\"]\ntheorem MonoidHom.finset_prod_apply [MulOneClass β] [CommMonoid γ] (f : α → β →* γ) (s : Finset α)\n    (b : β) : (∏ x ∈ s, f x) b = ∏ x ∈ s, f x b :=\n  map_prod (MonoidHom.eval b) _ _\n\n"}
{"name":"Finset.sum_cons","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\na : α\nf : α → β\ninst✝ : AddCommMonoid β\nh : Not (Membership.mem s a)\n⊢ Eq ((Finset.cons a s h).sum fun x => f x) (HAdd.hAdd (f a) (s.sum fun x => f x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_cons (h : a ∉ s) : ∏ x ∈ cons a s h, f x = f a * ∏ x ∈ s, f x :=\n  fold_cons h\n\n"}
{"name":"Finset.prod_cons","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\na : α\nf : α → β\ninst✝ : CommMonoid β\nh : Not (Membership.mem s a)\n⊢ Eq ((Finset.cons a s h).prod fun x => f x) (HMul.hMul (f a) (s.prod fun x => f x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_cons (h : a ∉ s) : ∏ x ∈ cons a s h, f x = f a * ∏ x ∈ s, f x :=\n  fold_cons h\n\n"}
{"name":"Finset.sum_insert","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\na : α\nf : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\na✝ : Not (Membership.mem s a)\n⊢ Eq ((Insert.insert a s).sum fun x => f x) (HAdd.hAdd (f a) (s.sum fun x => f x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_insert [DecidableEq α] : a ∉ s → ∏ x ∈ insert a s, f x = f a * ∏ x ∈ s, f x :=\n  fold_insert\n\n"}
{"name":"Finset.prod_insert","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\na : α\nf : α → β\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\na✝ : Not (Membership.mem s a)\n⊢ Eq ((Insert.insert a s).prod fun x => f x) (HMul.hMul (f a) (s.prod fun x => f x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_insert [DecidableEq α] : a ∉ s → ∏ x ∈ insert a s, f x = f a * ∏ x ∈ s, f x :=\n  fold_insert\n\n"}
{"name":"Finset.sum_insert_of_eq_zero_if_not_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\na : α\nf : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\nh : Not (Membership.mem s a) → Eq (f a) 0\n⊢ Eq ((Insert.insert a s).sum fun x => f x) (s.sum fun x => f x)","decl":"/-- The product of `f` over `insert a s` is the same as\nthe product over `s`, as long as `a` is in `s` or `f a = 1`. -/\n@[to_additive (attr := simp) \"The sum of `f` over `insert a s` is the same as\nthe sum over `s`, as long as `a` is in `s` or `f a = 0`.\"]\ntheorem prod_insert_of_eq_one_if_not_mem [DecidableEq α] (h : a ∉ s → f a = 1) :\n    ∏ x ∈ insert a s, f x = ∏ x ∈ s, f x := by\n  by_cases hm : a ∈ s\n  · simp_rw [insert_eq_of_mem hm]\n  · rw [prod_insert hm, h hm, one_mul]\n\n"}
{"name":"Finset.prod_insert_of_eq_one_if_not_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\na : α\nf : α → β\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\nh : Not (Membership.mem s a) → Eq (f a) 1\n⊢ Eq ((Insert.insert a s).prod fun x => f x) (s.prod fun x => f x)","decl":"/-- The product of `f` over `insert a s` is the same as\nthe product over `s`, as long as `a` is in `s` or `f a = 1`. -/\n@[to_additive (attr := simp) \"The sum of `f` over `insert a s` is the same as\nthe sum over `s`, as long as `a` is in `s` or `f a = 0`.\"]\ntheorem prod_insert_of_eq_one_if_not_mem [DecidableEq α] (h : a ∉ s → f a = 1) :\n    ∏ x ∈ insert a s, f x = ∏ x ∈ s, f x := by\n  by_cases hm : a ∈ s\n  · simp_rw [insert_eq_of_mem hm]\n  · rw [prod_insert hm, h hm, one_mul]\n\n"}
{"name":"Finset.prod_insert_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\na : α\nf : α → β\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\nh : Eq (f a) 1\n⊢ Eq ((Insert.insert a s).prod fun x => f x) (s.prod fun x => f x)","decl":"/-- The product of `f` over `insert a s` is the same as\nthe product over `s`, as long as `f a = 1`. -/\n@[to_additive (attr := simp) \"The sum of `f` over `insert a s` is the same as\nthe sum over `s`, as long as `f a = 0`.\"]\ntheorem prod_insert_one [DecidableEq α] (h : f a = 1) : ∏ x ∈ insert a s, f x = ∏ x ∈ s, f x :=\n  prod_insert_of_eq_one_if_not_mem fun _ => h\n\n"}
{"name":"Finset.sum_insert_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\na : α\nf : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\nh : Eq (f a) 0\n⊢ Eq ((Insert.insert a s).sum fun x => f x) (s.sum fun x => f x)","decl":"/-- The product of `f` over `insert a s` is the same as\nthe product over `s`, as long as `f a = 1`. -/\n@[to_additive (attr := simp) \"The sum of `f` over `insert a s` is the same as\nthe sum over `s`, as long as `f a = 0`.\"]\ntheorem prod_insert_one [DecidableEq α] (h : f a = 1) : ∏ x ∈ insert a s, f x = ∏ x ∈ s, f x :=\n  prod_insert_of_eq_one_if_not_mem fun _ => h\n\n"}
{"name":"Finset.sum_insert_sub","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ns : Finset α\na : α\nM : Type u_6\ninst✝¹ : AddCommGroup M\ninst✝ : DecidableEq α\nha : Not (Membership.mem s a)\nf : α → M\n⊢ Eq (HSub.hSub ((Insert.insert a s).sum fun x => f x) (f a)) (s.sum fun x => f x)","decl":"@[to_additive]\ntheorem prod_insert_div {M : Type*} [CommGroup M] [DecidableEq α] (ha : a ∉ s) {f : α → M} :\n    (∏ x ∈ insert a s, f x) / f a = ∏ x ∈ s, f x := by simp [ha]\n\n"}
{"name":"Finset.prod_insert_div","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ns : Finset α\na : α\nM : Type u_6\ninst✝¹ : CommGroup M\ninst✝ : DecidableEq α\nha : Not (Membership.mem s a)\nf : α → M\n⊢ Eq (HDiv.hDiv ((Insert.insert a s).prod fun x => f x) (f a)) (s.prod fun x => f x)","decl":"@[to_additive]\ntheorem prod_insert_div {M : Type*} [CommGroup M] [DecidableEq α] (ha : a ∉ s) {f : α → M} :\n    (∏ x ∈ insert a s, f x) / f a = ∏ x ∈ s, f x := by simp [ha]\n\n"}
{"name":"Finset.prod_singleton","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\nf : α → β\na : α\n⊢ Eq ((Singleton.singleton a).prod fun x => f x) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem prod_singleton (f : α → β) (a : α) : ∏ x ∈ singleton a, f x = f a :=\n  Eq.trans fold_singleton <| mul_one _\n\n"}
{"name":"Finset.sum_singleton","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\nf : α → β\na : α\n⊢ Eq ((Singleton.singleton a).sum fun x => f x) (f a)","decl":"@[to_additive (attr := simp)]\ntheorem prod_singleton (f : α → β) (a : α) : ∏ x ∈ singleton a, f x = f a :=\n  Eq.trans fold_singleton <| mul_one _\n\n"}
{"name":"Finset.prod_pair","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\na b : α\nh : Ne a b\n⊢ Eq ((Insert.insert a (Singleton.singleton b)).prod fun x => f x) (HMul.hMul (f a) (f b))","decl":"@[to_additive]\ntheorem prod_pair [DecidableEq α] {a b : α} (h : a ≠ b) :\n    (∏ x ∈ ({a, b} : Finset α), f x) = f a * f b := by\n  rw [prod_insert (not_mem_singleton.2 h), prod_singleton]\n\n"}
{"name":"Finset.sum_pair","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\na b : α\nh : Ne a b\n⊢ Eq ((Insert.insert a (Singleton.singleton b)).sum fun x => f x) (HAdd.hAdd (f a) (f b))","decl":"@[to_additive]\ntheorem prod_pair [DecidableEq α] {a b : α} (h : a ≠ b) :\n    (∏ x ∈ ({a, b} : Finset α), f x) = f a * f b := by\n  rw [prod_insert (not_mem_singleton.2 h), prod_singleton]\n\n"}
{"name":"Finset.sum_image","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\nf : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset γ\ng : γ → α\na✝ : ∀ (x : γ), Membership.mem s x → ∀ (y : γ), Membership.mem s y → Eq (g x) (g y) → Eq x y\n⊢ Eq ((Finset.image g s).sum fun x => f x) (s.sum fun x => f (g x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_image [DecidableEq α] {s : Finset γ} {g : γ → α} :\n    (∀ x ∈ s, ∀ y ∈ s, g x = g y → x = y) → ∏ x ∈ s.image g, f x = ∏ x ∈ s, f (g x) :=\n  fold_image\n\n"}
{"name":"Finset.prod_image","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\nf : α → β\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset γ\ng : γ → α\na✝ : ∀ (x : γ), Membership.mem s x → ∀ (y : γ), Membership.mem s y → Eq (g x) (g y) → Eq x y\n⊢ Eq ((Finset.image g s).prod fun x => f x) (s.prod fun x => f (g x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_image [DecidableEq α] {s : Finset γ} {g : γ → α} :\n    (∀ x ∈ s, ∀ y ∈ s, g x = g y → x = y) → ∏ x ∈ s.image g, f x = ∏ x ∈ s, f (g x) :=\n  fold_image\n\n"}
{"name":"Finset.sum_attach","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → β\n⊢ Eq (s.attach.sum fun x => f ↑x) (s.sum fun x => f x)","decl":"@[to_additive]\nlemma prod_attach (s : Finset α) (f : α → β) : ∏ x ∈ s.attach, f x = ∏ x ∈ s, f x := by\n  classical rw [← prod_image Subtype.coe_injective.injOn, attach_image_val]\n\n"}
{"name":"Finset.prod_attach","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nf : α → β\n⊢ Eq (s.attach.prod fun x => f ↑x) (s.prod fun x => f x)","decl":"@[to_additive]\nlemma prod_attach (s : Finset α) (f : α → β) : ∏ x ∈ s.attach, f x = ∏ x ∈ s, f x := by\n  classical rw [← prod_image Subtype.coe_injective.injOn, attach_image_val]\n\n"}
{"name":"Finset.sum_congr","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf g : α → β\ninst✝ : AddCommMonoid β\nh : Eq s₁ s₂\na✝ : ∀ (x : α), Membership.mem s₂ x → Eq (f x) (g x)\n⊢ Eq (s₁.sum f) (s₂.sum g)","decl":"@[to_additive (attr := congr)]\ntheorem prod_congr (h : s₁ = s₂) : (∀ x ∈ s₂, f x = g x) → s₁.prod f = s₂.prod g := by\n  rw [h]; exact fold_congr\n\n"}
{"name":"Finset.prod_congr","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf g : α → β\ninst✝ : CommMonoid β\nh : Eq s₁ s₂\na✝ : ∀ (x : α), Membership.mem s₂ x → Eq (f x) (g x)\n⊢ Eq (s₁.prod f) (s₂.prod g)","decl":"@[to_additive (attr := congr)]\ntheorem prod_congr (h : s₁ = s₂) : (∀ x ∈ s₂, f x = g x) → s₁.prod f = s₂.prod g := by\n  rw [h]; exact fold_congr\n\n"}
{"name":"Finset.prod_eq_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\nf : α → β\ns : Finset α\nh : ∀ (x : α), Membership.mem s x → Eq (f x) 1\n⊢ Eq (s.prod fun x => f x) 1","decl":"@[to_additive]\ntheorem prod_eq_one {f : α → β} {s : Finset α} (h : ∀ x ∈ s, f x = 1) : ∏ x ∈ s, f x = 1 :=\n  calc\n    ∏ x ∈ s, f x = ∏ _x ∈ s, 1 := Finset.prod_congr rfl h\n    _ = 1 := Finset.prod_const_one\n\n"}
{"name":"Finset.sum_eq_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\nf : α → β\ns : Finset α\nh : ∀ (x : α), Membership.mem s x → Eq (f x) 0\n⊢ Eq (s.sum fun x => f x) 0","decl":"@[to_additive]\ntheorem prod_eq_one {f : α → β} {s : Finset α} (h : ∀ x ∈ s, f x = 1) : ∏ x ∈ s, f x = 1 :=\n  calc\n    ∏ x ∈ s, f x = ∏ _x ∈ s, 1 := Finset.prod_congr rfl h\n    _ = 1 := Finset.prod_const_one\n\n"}
{"name":"Finset.prod_disjUnion","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝ : CommMonoid β\nh : Disjoint s₁ s₂\n⊢ Eq ((s₁.disjUnion s₂ h).prod fun x => f x) (HMul.hMul (s₁.prod fun x => f x) (s₂.prod fun x => f x))","decl":"@[to_additive]\ntheorem prod_disjUnion (h) :\n    ∏ x ∈ s₁.disjUnion s₂ h, f x = (∏ x ∈ s₁, f x) * ∏ x ∈ s₂, f x := by\n  refine Eq.trans ?_ (fold_disjUnion h)\n  rw [one_mul]\n  rfl\n\n"}
{"name":"Finset.sum_disjUnion","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝ : AddCommMonoid β\nh : Disjoint s₁ s₂\n⊢ Eq ((s₁.disjUnion s₂ h).sum fun x => f x) (HAdd.hAdd (s₁.sum fun x => f x) (s₂.sum fun x => f x))","decl":"@[to_additive]\ntheorem prod_disjUnion (h) :\n    ∏ x ∈ s₁.disjUnion s₂ h, f x = (∏ x ∈ s₁, f x) * ∏ x ∈ s₂, f x := by\n  refine Eq.trans ?_ (fold_disjUnion h)\n  rw [one_mul]\n  rfl\n\n"}
{"name":"Finset.sum_disjiUnion","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\nf : α → β\ninst✝ : AddCommMonoid β\ns : Finset ι\nt : ι → Finset α\nh : (↑s).PairwiseDisjoint t\n⊢ Eq ((s.disjiUnion t h).sum fun x => f x) (s.sum fun i => (t i).sum fun x => f x)","decl":"@[to_additive]\ntheorem prod_disjiUnion (s : Finset ι) (t : ι → Finset α) (h) :\n    ∏ x ∈ s.disjiUnion t h, f x = ∏ i ∈ s, ∏ x ∈ t i, f x := by\n  refine Eq.trans ?_ (fold_disjiUnion h)\n  dsimp [Finset.prod, Multiset.prod, Multiset.fold, Finset.disjUnion, Finset.fold]\n  congr\n  exact prod_const_one.symm\n\n"}
{"name":"Finset.prod_disjiUnion","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\nf : α → β\ninst✝ : CommMonoid β\ns : Finset ι\nt : ι → Finset α\nh : (↑s).PairwiseDisjoint t\n⊢ Eq ((s.disjiUnion t h).prod fun x => f x) (s.prod fun i => (t i).prod fun x => f x)","decl":"@[to_additive]\ntheorem prod_disjiUnion (s : Finset ι) (t : ι → Finset α) (h) :\n    ∏ x ∈ s.disjiUnion t h, f x = ∏ i ∈ s, ∏ x ∈ t i, f x := by\n  refine Eq.trans ?_ (fold_disjiUnion h)\n  dsimp [Finset.prod, Multiset.prod, Multiset.fold, Finset.disjUnion, Finset.fold]\n  congr\n  exact prod_const_one.symm\n\n"}
{"name":"Finset.sum_union_inter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\n⊢ Eq (HAdd.hAdd ((Union.union s₁ s₂).sum fun x => f x) ((Inter.inter s₁ s₂).sum fun x => f x)) (HAdd.hAdd (s₁.sum fun x => f x) (s₂.sum fun x => f x))","decl":"@[to_additive]\ntheorem prod_union_inter [DecidableEq α] :\n    (∏ x ∈ s₁ ∪ s₂, f x) * ∏ x ∈ s₁ ∩ s₂, f x = (∏ x ∈ s₁, f x) * ∏ x ∈ s₂, f x :=\n  fold_union_inter\n\n"}
{"name":"Finset.prod_union_inter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\n⊢ Eq (HMul.hMul ((Union.union s₁ s₂).prod fun x => f x) ((Inter.inter s₁ s₂).prod fun x => f x)) (HMul.hMul (s₁.prod fun x => f x) (s₂.prod fun x => f x))","decl":"@[to_additive]\ntheorem prod_union_inter [DecidableEq α] :\n    (∏ x ∈ s₁ ∪ s₂, f x) * ∏ x ∈ s₁ ∩ s₂, f x = (∏ x ∈ s₁, f x) * ∏ x ∈ s₂, f x :=\n  fold_union_inter\n\n"}
{"name":"Finset.sum_union","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\nh : Disjoint s₁ s₂\n⊢ Eq ((Union.union s₁ s₂).sum fun x => f x) (HAdd.hAdd (s₁.sum fun x => f x) (s₂.sum fun x => f x))","decl":"@[to_additive]\ntheorem prod_union [DecidableEq α] (h : Disjoint s₁ s₂) :\n    ∏ x ∈ s₁ ∪ s₂, f x = (∏ x ∈ s₁, f x) * ∏ x ∈ s₂, f x := by\n  rw [← prod_union_inter, disjoint_iff_inter_eq_empty.mp h]; exact (mul_one _).symm\n\n"}
{"name":"Finset.prod_union","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\nh : Disjoint s₁ s₂\n⊢ Eq ((Union.union s₁ s₂).prod fun x => f x) (HMul.hMul (s₁.prod fun x => f x) (s₂.prod fun x => f x))","decl":"@[to_additive]\ntheorem prod_union [DecidableEq α] (h : Disjoint s₁ s₂) :\n    ∏ x ∈ s₁ ∪ s₂, f x = (∏ x ∈ s₁, f x) * ∏ x ∈ s₂, f x := by\n  rw [← prod_union_inter, disjoint_iff_inter_eq_empty.mp h]; exact (mul_one _).symm\n\n"}
{"name":"Finset.prod_filter_mul_prod_filter_not","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : CommMonoid β\ns : Finset α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : (x : α) → Decidable (Not (p x))\nf : α → β\n⊢ Eq (HMul.hMul ((Finset.filter (fun x => p x) s).prod fun x => f x) ((Finset.filter (fun x => Not (p x)) s).prod fun x => f x)) (s.prod fun x => f x)","decl":"@[to_additive]\ntheorem prod_filter_mul_prod_filter_not\n    (s : Finset α) (p : α → Prop) [DecidablePred p] [∀ x, Decidable (¬p x)] (f : α → β) :\n    (∏ x ∈ s with p x, f x) * ∏ x ∈ s with ¬p x, f x = ∏ x ∈ s, f x := by\n  have := Classical.decEq α\n  rw [← prod_union (disjoint_filter_filter_neg s s p), filter_union_filter_neg_eq]\n\n"}
{"name":"Finset.sum_filter_add_sum_filter_not","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : AddCommMonoid β\ns : Finset α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : (x : α) → Decidable (Not (p x))\nf : α → β\n⊢ Eq (HAdd.hAdd ((Finset.filter (fun x => p x) s).sum fun x => f x) ((Finset.filter (fun x => Not (p x)) s).sum fun x => f x)) (s.sum fun x => f x)","decl":"@[to_additive]\ntheorem prod_filter_mul_prod_filter_not\n    (s : Finset α) (p : α → Prop) [DecidablePred p] [∀ x, Decidable (¬p x)] (f : α → β) :\n    (∏ x ∈ s with p x, f x) * ∏ x ∈ s with ¬p x, f x = ∏ x ∈ s, f x := by\n  have := Classical.decEq α\n  rw [← prod_union (disjoint_filter_filter_neg s s p), filter_union_filter_neg_eq]\n\n"}
{"name":"Finset.sum_filter_not_add_sum_filter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : AddCommMonoid β\ns : Finset α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : (x : α) → Decidable (Not (p x))\nf : α → β\n⊢ Eq (HAdd.hAdd ((Finset.filter (fun x => Not (p x)) s).sum fun x => f x) ((Finset.filter p s).sum fun x => f x)) (s.sum fun x => f x)","decl":"@[to_additive]\nlemma prod_filter_not_mul_prod_filter (s : Finset α) (p : α → Prop) [DecidablePred p]\n    [∀ x, Decidable (¬p x)] (f : α → β) :\n    (∏ x ∈ s.filter fun x ↦ ¬p x, f x) * ∏ x ∈ s.filter p, f x = ∏ x ∈ s, f x := by\n  rw [mul_comm, prod_filter_mul_prod_filter_not]\n\n"}
{"name":"Finset.prod_filter_not_mul_prod_filter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : CommMonoid β\ns : Finset α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : (x : α) → Decidable (Not (p x))\nf : α → β\n⊢ Eq (HMul.hMul ((Finset.filter (fun x => Not (p x)) s).prod fun x => f x) ((Finset.filter p s).prod fun x => f x)) (s.prod fun x => f x)","decl":"@[to_additive]\nlemma prod_filter_not_mul_prod_filter (s : Finset α) (p : α → Prop) [DecidablePred p]\n    [∀ x, Decidable (¬p x)] (f : α → β) :\n    (∏ x ∈ s.filter fun x ↦ ¬p x, f x) * ∏ x ∈ s.filter p, f x = ∏ x ∈ s, f x := by\n  rw [mul_comm, prod_filter_mul_prod_filter_not]\n\n"}
{"name":"Finset.sum_filter_xor","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝² : AddCommMonoid β\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\n⊢ Eq ((Finset.filter (fun x => Xor' (p x) (q x)) s).sum fun x => f x) (HAdd.hAdd ((Finset.filter (fun x => And (p x) (Not (q x))) s).sum fun x => f x) ((Finset.filter (fun x => And (q x) (Not (p x))) s).sum fun x => f x))","decl":"@[to_additive]\ntheorem prod_filter_xor (p q : α → Prop) [DecidablePred p] [DecidablePred q] :\n    (∏ x ∈ s with (Xor' (p x) (q x)), f x) =\n      (∏ x ∈ s with (p x ∧ ¬ q x), f x) * (∏ x ∈ s with (q x ∧ ¬ p x), f x) := by\n  classical rw [← prod_union (disjoint_filter_and_not_filter _ _), ← filter_or]\n  simp only [Xor']\n\n"}
{"name":"Finset.prod_filter_xor","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝² : CommMonoid β\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\n⊢ Eq ((Finset.filter (fun x => Xor' (p x) (q x)) s).prod fun x => f x) (HMul.hMul ((Finset.filter (fun x => And (p x) (Not (q x))) s).prod fun x => f x) ((Finset.filter (fun x => And (q x) (Not (p x))) s).prod fun x => f x))","decl":"@[to_additive]\ntheorem prod_filter_xor (p q : α → Prop) [DecidablePred p] [DecidablePred q] :\n    (∏ x ∈ s with (Xor' (p x) (q x)), f x) =\n      (∏ x ∈ s with (p x ∧ ¬ q x), f x) * (∏ x ∈ s with (q x ∧ ¬ p x), f x) := by\n  classical rw [← prod_union (disjoint_filter_and_not_filter _ _), ← filter_or]\n  simp only [Xor']\n\n"}
{"name":"Finset.sum_powerset_insert","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\na : α\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\nha : Not (Membership.mem s a)\nf : Finset α → β\n⊢ Eq ((Insert.insert a s).powerset.sum fun t => f t) (HAdd.hAdd (s.powerset.sum fun t => f t) (s.powerset.sum fun t => f (Insert.insert a t)))","decl":"/-- A product over all subsets of `s ∪ {x}` is obtained by multiplying the product over all subsets\nof `s`, and over all subsets of `s` to which one adds `x`. -/\n@[to_additive \"A sum over all subsets of `s ∪ {x}` is obtained by summing the sum over all subsets\nof `s`, and over all subsets of `s` to which one adds `x`.\"]\nlemma prod_powerset_insert [DecidableEq α] (ha : a ∉ s) (f : Finset α → β) :\n    ∏ t ∈ (insert a s).powerset, f t =\n      (∏ t ∈ s.powerset, f t) * ∏ t ∈ s.powerset, f (insert a t) := by\n  rw [powerset_insert, prod_union, prod_image]\n  · exact insert_erase_invOn.2.injOn.mono fun t ht ↦ not_mem_mono (mem_powerset.1 ht) ha\n  · aesop (add simp [disjoint_left, insert_subset_iff])\n\n"}
{"name":"Finset.prod_powerset_insert","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\na : α\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\nha : Not (Membership.mem s a)\nf : Finset α → β\n⊢ Eq ((Insert.insert a s).powerset.prod fun t => f t) (HMul.hMul (s.powerset.prod fun t => f t) (s.powerset.prod fun t => f (Insert.insert a t)))","decl":"/-- A product over all subsets of `s ∪ {x}` is obtained by multiplying the product over all subsets\nof `s`, and over all subsets of `s` to which one adds `x`. -/\n@[to_additive \"A sum over all subsets of `s ∪ {x}` is obtained by summing the sum over all subsets\nof `s`, and over all subsets of `s` to which one adds `x`.\"]\nlemma prod_powerset_insert [DecidableEq α] (ha : a ∉ s) (f : Finset α → β) :\n    ∏ t ∈ (insert a s).powerset, f t =\n      (∏ t ∈ s.powerset, f t) * ∏ t ∈ s.powerset, f (insert a t) := by\n  rw [powerset_insert, prod_union, prod_image]\n  · exact insert_erase_invOn.2.injOn.mono fun t ht ↦ not_mem_mono (mem_powerset.1 ht) ha\n  · aesop (add simp [disjoint_left, insert_subset_iff])\n\n"}
{"name":"Finset.sum_powerset_cons","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\na : α\ninst✝ : AddCommMonoid β\nha : Not (Membership.mem s a)\nf : Finset α → β\n⊢ Eq ((Finset.cons a s ha).powerset.sum fun t => f t) (HAdd.hAdd (s.powerset.sum fun t => f t) (s.powerset.attach.sum fun t => f (Finset.cons a ↑t ⋯)))","decl":"/-- A product over all subsets of `s ∪ {x}` is obtained by multiplying the product over all subsets\nof `s`, and over all subsets of `s` to which one adds `x`. -/\n@[to_additive \"A sum over all subsets of `s ∪ {x}` is obtained by summing the sum over all subsets\nof `s`, and over all subsets of `s` to which one adds `x`.\"]\nlemma prod_powerset_cons (ha : a ∉ s) (f : Finset α → β) :\n    ∏ t ∈ (s.cons a ha).powerset, f t = (∏ t ∈ s.powerset, f t) *\n      ∏ t ∈ s.powerset.attach, f (cons a t <| not_mem_mono (mem_powerset.1 t.2) ha) := by\n  classical\n  simp_rw [cons_eq_insert]\n  rw [prod_powerset_insert ha, prod_attach _ fun t ↦ f (insert a t)]\n\n"}
{"name":"Finset.prod_powerset_cons","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\na : α\ninst✝ : CommMonoid β\nha : Not (Membership.mem s a)\nf : Finset α → β\n⊢ Eq ((Finset.cons a s ha).powerset.prod fun t => f t) (HMul.hMul (s.powerset.prod fun t => f t) (s.powerset.attach.prod fun t => f (Finset.cons a ↑t ⋯)))","decl":"/-- A product over all subsets of `s ∪ {x}` is obtained by multiplying the product over all subsets\nof `s`, and over all subsets of `s` to which one adds `x`. -/\n@[to_additive \"A sum over all subsets of `s ∪ {x}` is obtained by summing the sum over all subsets\nof `s`, and over all subsets of `s` to which one adds `x`.\"]\nlemma prod_powerset_cons (ha : a ∉ s) (f : Finset α → β) :\n    ∏ t ∈ (s.cons a ha).powerset, f t = (∏ t ∈ s.powerset, f t) *\n      ∏ t ∈ s.powerset.attach, f (cons a t <| not_mem_mono (mem_powerset.1 t.2) ha) := by\n  classical\n  simp_rw [cons_eq_insert]\n  rw [prod_powerset_insert ha, prod_attach _ fun t ↦ f (insert a t)]\n\n"}
{"name":"Finset.prod_powerset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nf : Finset α → β\n⊢ Eq (s.powerset.prod fun t => f t) ((Finset.range (HAdd.hAdd s.card 1)).prod fun j => (Finset.powersetCard j s).prod fun t => f t)","decl":"/-- A product over `powerset s` is equal to the double product over sets of subsets of `s` with\n`#s = k`, for `k = 1, ..., #s`. -/\n@[to_additive \"A sum over `powerset s` is equal to the double sum over sets of subsets of `s` with\n`#s = k`, for `k = 1, ..., #s`\"]\nlemma prod_powerset (s : Finset α) (f : Finset α → β) :\n    ∏ t ∈ powerset s, f t = ∏ j ∈ range (#s + 1), ∏ t ∈ powersetCard j s, f t := by\n  rw [powerset_card_disjiUnion, prod_disjiUnion]\n\n"}
{"name":"Finset.sum_powerset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : Finset α → β\n⊢ Eq (s.powerset.sum fun t => f t) ((Finset.range (HAdd.hAdd s.card 1)).sum fun j => (Finset.powersetCard j s).sum fun t => f t)","decl":"/-- A product over `powerset s` is equal to the double product over sets of subsets of `s` with\n`#s = k`, for `k = 1, ..., #s`. -/\n@[to_additive \"A sum over `powerset s` is equal to the double sum over sets of subsets of `s` with\n`#s = k`, for `k = 1, ..., #s`\"]\nlemma prod_powerset (s : Finset α) (f : Finset α → β) :\n    ∏ t ∈ powerset s, f t = ∏ j ∈ range (#s + 1), ∏ t ∈ powersetCard j s, f t := by\n  rw [powerset_card_disjiUnion, prod_disjiUnion]\n\n"}
{"name":"IsCompl.sum_add_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Fintype α\ninst✝ : AddCommMonoid β\ns t : Finset α\nh : IsCompl s t\nf : α → β\n⊢ Eq (HAdd.hAdd (s.sum fun i => f i) (t.sum fun i => f i)) (Finset.univ.sum fun i => f i)","decl":"@[to_additive]\ntheorem IsCompl.prod_mul_prod {s t : Finset α} (h : IsCompl s t) (f : α → β) :\n    (∏ i ∈ s, f i) * ∏ i ∈ t, f i = ∏ i, f i :=\n  (Finset.prod_disjUnion h.disjoint).symm.trans <| by\n    classical rw [Finset.disjUnion_eq_union, ← Finset.sup_eq_union, h.sup_eq_top]; rfl\n\n"}
{"name":"IsCompl.prod_mul_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Fintype α\ninst✝ : CommMonoid β\ns t : Finset α\nh : IsCompl s t\nf : α → β\n⊢ Eq (HMul.hMul (s.prod fun i => f i) (t.prod fun i => f i)) (Finset.univ.prod fun i => f i)","decl":"@[to_additive]\ntheorem IsCompl.prod_mul_prod {s t : Finset α} (h : IsCompl s t) (f : α → β) :\n    (∏ i ∈ s, f i) * ∏ i ∈ t, f i = ∏ i, f i :=\n  (Finset.prod_disjUnion h.disjoint).symm.trans <| by\n    classical rw [Finset.disjUnion_eq_union, ← Finset.sup_eq_union, h.sup_eq_top]; rfl\n\n"}
{"name":"Finset.prod_mul_prod_compl","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : CommMonoid β\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\n⊢ Eq (HMul.hMul (s.prod fun i => f i) ((HasCompl.compl s).prod fun i => f i)) (Finset.univ.prod fun i => f i)","decl":"/-- Multiplying the products of a function over `s` and over `sᶜ` gives the whole product.\nFor a version expressed with subtypes, see `Fintype.prod_subtype_mul_prod_subtype`. -/\n@[to_additive \"Adding the sums of a function over `s` and over `sᶜ` gives the whole sum.\nFor a version expressed with subtypes, see `Fintype.sum_subtype_add_sum_subtype`. \"]\ntheorem prod_mul_prod_compl [Fintype α] [DecidableEq α] (s : Finset α) (f : α → β) :\n    (∏ i ∈ s, f i) * ∏ i ∈ sᶜ, f i = ∏ i, f i :=\n  IsCompl.prod_mul_prod isCompl_compl f\n\n"}
{"name":"Finset.sum_add_sum_compl","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : AddCommMonoid β\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\n⊢ Eq (HAdd.hAdd (s.sum fun i => f i) ((HasCompl.compl s).sum fun i => f i)) (Finset.univ.sum fun i => f i)","decl":"/-- Multiplying the products of a function over `s` and over `sᶜ` gives the whole product.\nFor a version expressed with subtypes, see `Fintype.prod_subtype_mul_prod_subtype`. -/\n@[to_additive \"Adding the sums of a function over `s` and over `sᶜ` gives the whole sum.\nFor a version expressed with subtypes, see `Fintype.sum_subtype_add_sum_subtype`. \"]\ntheorem prod_mul_prod_compl [Fintype α] [DecidableEq α] (s : Finset α) (f : α → β) :\n    (∏ i ∈ s, f i) * ∏ i ∈ sᶜ, f i = ∏ i, f i :=\n  IsCompl.prod_mul_prod isCompl_compl f\n\n"}
{"name":"Finset.sum_compl_add_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : AddCommMonoid β\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\n⊢ Eq (HAdd.hAdd ((HasCompl.compl s).sum fun i => f i) (s.sum fun i => f i)) (Finset.univ.sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_compl_mul_prod [Fintype α] [DecidableEq α] (s : Finset α) (f : α → β) :\n    (∏ i ∈ sᶜ, f i) * ∏ i ∈ s, f i = ∏ i, f i :=\n  (@isCompl_compl _ s _).symm.prod_mul_prod f\n\n"}
{"name":"Finset.prod_compl_mul_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : CommMonoid β\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\n⊢ Eq (HMul.hMul ((HasCompl.compl s).prod fun i => f i) (s.prod fun i => f i)) (Finset.univ.prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_compl_mul_prod [Fintype α] [DecidableEq α] (s : Finset α) (f : α → β) :\n    (∏ i ∈ sᶜ, f i) * ∏ i ∈ s, f i = ∏ i, f i :=\n  (@isCompl_compl _ s _).symm.prod_mul_prod f\n\n"}
{"name":"Finset.prod_sdiff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\nh : HasSubset.Subset s₁ s₂\n⊢ Eq (HMul.hMul ((SDiff.sdiff s₂ s₁).prod fun x => f x) (s₁.prod fun x => f x)) (s₂.prod fun x => f x)","decl":"@[to_additive]\ntheorem prod_sdiff [DecidableEq α] (h : s₁ ⊆ s₂) :\n    (∏ x ∈ s₂ \\ s₁, f x) * ∏ x ∈ s₁, f x = ∏ x ∈ s₂, f x := by\n  rw [← prod_union sdiff_disjoint, sdiff_union_of_subset h]\n\n"}
{"name":"Finset.sum_sdiff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\nh : HasSubset.Subset s₁ s₂\n⊢ Eq (HAdd.hAdd ((SDiff.sdiff s₂ s₁).sum fun x => f x) (s₁.sum fun x => f x)) (s₂.sum fun x => f x)","decl":"@[to_additive]\ntheorem prod_sdiff [DecidableEq α] (h : s₁ ⊆ s₂) :\n    (∏ x ∈ s₂ \\ s₁, f x) * ∏ x ∈ s₁, f x = ∏ x ∈ s₂, f x := by\n  rw [← prod_union sdiff_disjoint, sdiff_union_of_subset h]\n\n"}
{"name":"Finset.sum_subset_zero_on_sdiff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf g : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\nh : HasSubset.Subset s₁ s₂\nhg : ∀ (x : α), Membership.mem (SDiff.sdiff s₂ s₁) x → Eq (g x) 0\nhfg : ∀ (x : α), Membership.mem s₁ x → Eq (f x) (g x)\n⊢ Eq (s₁.sum fun i => f i) (s₂.sum fun i => g i)","decl":"@[to_additive]\ntheorem prod_subset_one_on_sdiff [DecidableEq α] (h : s₁ ⊆ s₂) (hg : ∀ x ∈ s₂ \\ s₁, g x = 1)\n    (hfg : ∀ x ∈ s₁, f x = g x) : ∏ i ∈ s₁, f i = ∏ i ∈ s₂, g i := by\n  rw [← prod_sdiff h, prod_eq_one hg, one_mul]\n  exact prod_congr rfl hfg\n\n"}
{"name":"Finset.prod_subset_one_on_sdiff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf g : α → β\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\nh : HasSubset.Subset s₁ s₂\nhg : ∀ (x : α), Membership.mem (SDiff.sdiff s₂ s₁) x → Eq (g x) 1\nhfg : ∀ (x : α), Membership.mem s₁ x → Eq (f x) (g x)\n⊢ Eq (s₁.prod fun i => f i) (s₂.prod fun i => g i)","decl":"@[to_additive]\ntheorem prod_subset_one_on_sdiff [DecidableEq α] (h : s₁ ⊆ s₂) (hg : ∀ x ∈ s₂ \\ s₁, g x = 1)\n    (hfg : ∀ x ∈ s₁, f x = g x) : ∏ i ∈ s₁, f i = ∏ i ∈ s₂, g i := by\n  rw [← prod_sdiff h, prod_eq_one hg, one_mul]\n  exact prod_congr rfl hfg\n\n"}
{"name":"Finset.prod_subset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝ : CommMonoid β\nh : HasSubset.Subset s₁ s₂\nhf : ∀ (x : α), Membership.mem s₂ x → Not (Membership.mem s₁ x) → Eq (f x) 1\n⊢ Eq (s₁.prod fun x => f x) (s₂.prod fun x => f x)","decl":"@[to_additive]\ntheorem prod_subset (h : s₁ ⊆ s₂) (hf : ∀ x ∈ s₂, x ∉ s₁ → f x = 1) :\n    ∏ x ∈ s₁, f x = ∏ x ∈ s₂, f x :=\n  haveI := Classical.decEq α\n  prod_subset_one_on_sdiff h (by simpa) fun _ _ => rfl\n\n"}
{"name":"Finset.sum_subset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝ : AddCommMonoid β\nh : HasSubset.Subset s₁ s₂\nhf : ∀ (x : α), Membership.mem s₂ x → Not (Membership.mem s₁ x) → Eq (f x) 0\n⊢ Eq (s₁.sum fun x => f x) (s₂.sum fun x => f x)","decl":"@[to_additive]\ntheorem prod_subset (h : s₁ ⊆ s₂) (hf : ∀ x ∈ s₂, x ∉ s₁ → f x = 1) :\n    ∏ x ∈ s₁, f x = ∏ x ∈ s₂, f x :=\n  haveI := Classical.decEq α\n  prod_subset_one_on_sdiff h (by simpa) fun _ _ => rfl\n\n"}
{"name":"Finset.prod_disj_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\ns : Finset α\nt : Finset γ\nf : Sum α γ → β\n⊢ Eq ((s.disjSum t).prod fun x => f x) (HMul.hMul (s.prod fun x => f (Sum.inl x)) (t.prod fun x => f (Sum.inr x)))","decl":"@[to_additive (attr := simp)]\ntheorem prod_disj_sum (s : Finset α) (t : Finset γ) (f : α ⊕ γ → β) :\n    ∏ x ∈ s.disjSum t, f x = (∏ x ∈ s, f (Sum.inl x)) * ∏ x ∈ t, f (Sum.inr x) := by\n  rw [← map_inl_disjUnion_map_inr, prod_disjUnion, prod_map, prod_map]\n  rfl\n\n"}
{"name":"Finset.sum_disj_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\ns : Finset α\nt : Finset γ\nf : Sum α γ → β\n⊢ Eq ((s.disjSum t).sum fun x => f x) (HAdd.hAdd (s.sum fun x => f (Sum.inl x)) (t.sum fun x => f (Sum.inr x)))","decl":"@[to_additive (attr := simp)]\ntheorem prod_disj_sum (s : Finset α) (t : Finset γ) (f : α ⊕ γ → β) :\n    ∏ x ∈ s.disjSum t, f x = (∏ x ∈ s, f (Sum.inl x)) * ∏ x ∈ t, f (Sum.inr x) := by\n  rw [← map_inl_disjUnion_map_inr, prod_disjUnion, prod_map, prod_map]\n  rfl\n\n"}
{"name":"Finset.prod_sum_eq_prod_toLeft_mul_prod_toRight","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\ns : Finset (Sum α γ)\nf : Sum α γ → β\n⊢ Eq (s.prod fun x => f x) (HMul.hMul (s.toLeft.prod fun x => f (Sum.inl x)) (s.toRight.prod fun x => f (Sum.inr x)))","decl":"@[to_additive]\nlemma prod_sum_eq_prod_toLeft_mul_prod_toRight (s : Finset (α ⊕ γ)) (f : α ⊕ γ → β) :\n    ∏ x ∈ s, f x = (∏ x ∈ s.toLeft, f (Sum.inl x)) * ∏ x ∈ s.toRight, f (Sum.inr x) := by\n  rw [← Finset.toLeft_disjSum_toRight (u := s), Finset.prod_disj_sum, Finset.toLeft_disjSum,\n    Finset.toRight_disjSum]\n\n"}
{"name":"Finset.sum_sum_eq_sum_toLeft_add_sum_toRight","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\ns : Finset (Sum α γ)\nf : Sum α γ → β\n⊢ Eq (s.sum fun x => f x) (HAdd.hAdd (s.toLeft.sum fun x => f (Sum.inl x)) (s.toRight.sum fun x => f (Sum.inr x)))","decl":"@[to_additive]\nlemma prod_sum_eq_prod_toLeft_mul_prod_toRight (s : Finset (α ⊕ γ)) (f : α ⊕ γ → β) :\n    ∏ x ∈ s, f x = (∏ x ∈ s.toLeft, f (Sum.inl x)) * ∏ x ∈ s.toRight, f (Sum.inr x) := by\n  rw [← Finset.toLeft_disjSum_toRight (u := s), Finset.prod_disj_sum, Finset.toLeft_disjSum,\n    Finset.toRight_disjSum]\n\n"}
{"name":"Finset.sum_sum_elim","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\ns : Finset α\nt : Finset γ\nf : α → β\ng : γ → β\n⊢ Eq ((s.disjSum t).sum fun x => Sum.elim f g x) (HAdd.hAdd (s.sum fun x => f x) (t.sum fun x => g x))","decl":"@[to_additive]\ntheorem prod_sum_elim (s : Finset α) (t : Finset γ) (f : α → β) (g : γ → β) :\n    ∏ x ∈ s.disjSum t, Sum.elim f g x = (∏ x ∈ s, f x) * ∏ x ∈ t, g x := by simp\n\n"}
{"name":"Finset.prod_sum_elim","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\ns : Finset α\nt : Finset γ\nf : α → β\ng : γ → β\n⊢ Eq ((s.disjSum t).prod fun x => Sum.elim f g x) (HMul.hMul (s.prod fun x => f x) (t.prod fun x => g x))","decl":"@[to_additive]\ntheorem prod_sum_elim (s : Finset α) (t : Finset γ) (f : α → β) (g : γ → β) :\n    ∏ x ∈ s.disjSum t, Sum.elim f g x = (∏ x ∈ s, f x) * ∏ x ∈ t, g x := by simp\n\n"}
{"name":"Finset.sum_biUnion","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\nf : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset γ\nt : γ → Finset α\nhs : (↑s).PairwiseDisjoint t\n⊢ Eq ((s.biUnion t).sum fun x => f x) (s.sum fun x => (t x).sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_biUnion [DecidableEq α] {s : Finset γ} {t : γ → Finset α}\n    (hs : Set.PairwiseDisjoint (↑s) t) : ∏ x ∈ s.biUnion t, f x = ∏ x ∈ s, ∏ i ∈ t x, f i := by\n  rw [← disjiUnion_eq_biUnion _ _ hs, prod_disjiUnion]\n\n"}
{"name":"Finset.prod_biUnion","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\nf : α → β\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset γ\nt : γ → Finset α\nhs : (↑s).PairwiseDisjoint t\n⊢ Eq ((s.biUnion t).prod fun x => f x) (s.prod fun x => (t x).prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_biUnion [DecidableEq α] {s : Finset γ} {t : γ → Finset α}\n    (hs : Set.PairwiseDisjoint (↑s) t) : ∏ x ∈ s.biUnion t, f x = ∏ x ∈ s, ∏ i ∈ t x, f i := by\n  rw [← disjiUnion_eq_biUnion _ _ hs, prod_disjiUnion]\n\n"}
{"name":"Finset.sum_sigma","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\nσ : α → Type u_6\ns : Finset α\nt : (a : α) → Finset (σ a)\nf : Sigma σ → β\n⊢ Eq ((s.sigma t).sum fun x => f x) (s.sum fun a => (t a).sum fun s => f ⟨a, s⟩)","decl":"/-- The product over a sigma type equals the product of the fiberwise products. For rewriting\nin the reverse direction, use `Finset.prod_sigma'`. -/\n@[to_additive \"The sum over a sigma type equals the sum of the fiberwise sums. For rewriting\nin the reverse direction, use `Finset.sum_sigma'`\"]\ntheorem prod_sigma {σ : α → Type*} (s : Finset α) (t : ∀ a, Finset (σ a)) (f : Sigma σ → β) :\n    ∏ x ∈ s.sigma t, f x = ∏ a ∈ s, ∏ s ∈ t a, f ⟨a, s⟩ := by\n  simp_rw [← disjiUnion_map_sigma_mk, prod_disjiUnion, prod_map, Function.Embedding.sigmaMk_apply]\n\n"}
{"name":"Finset.prod_sigma","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\nσ : α → Type u_6\ns : Finset α\nt : (a : α) → Finset (σ a)\nf : Sigma σ → β\n⊢ Eq ((s.sigma t).prod fun x => f x) (s.prod fun a => (t a).prod fun s => f ⟨a, s⟩)","decl":"/-- The product over a sigma type equals the product of the fiberwise products. For rewriting\nin the reverse direction, use `Finset.prod_sigma'`. -/\n@[to_additive \"The sum over a sigma type equals the sum of the fiberwise sums. For rewriting\nin the reverse direction, use `Finset.sum_sigma'`\"]\ntheorem prod_sigma {σ : α → Type*} (s : Finset α) (t : ∀ a, Finset (σ a)) (f : Sigma σ → β) :\n    ∏ x ∈ s.sigma t, f x = ∏ a ∈ s, ∏ s ∈ t a, f ⟨a, s⟩ := by\n  simp_rw [← disjiUnion_map_sigma_mk, prod_disjiUnion, prod_map, Function.Embedding.sigmaMk_apply]\n\n"}
{"name":"Finset.prod_sigma'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\nσ : α → Type u_6\ns : Finset α\nt : (a : α) → Finset (σ a)\nf : (a : α) → σ a → β\n⊢ Eq (s.prod fun a => (t a).prod fun s => f a s) ((s.sigma t).prod fun x => f x.fst x.snd)","decl":"/-- The product over a sigma type equals the product of the fiberwise products. For rewriting\nin the reverse direction, use `Finset.prod_sigma`. -/\n@[to_additive \"The sum over a sigma type equals the sum of the fiberwise sums. For rewriting\nin the reverse direction, use `Finset.sum_sigma`\"]\ntheorem prod_sigma' {σ : α → Type*} (s : Finset α) (t : ∀ a, Finset (σ a)) (f : ∀ a, σ a → β) :\n    (∏ a ∈ s, ∏ s ∈ t a, f a s) = ∏ x ∈ s.sigma t, f x.1 x.2 :=\n  Eq.symm <| prod_sigma s t fun x => f x.1 x.2\n\n"}
{"name":"Finset.sum_sigma'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\nσ : α → Type u_6\ns : Finset α\nt : (a : α) → Finset (σ a)\nf : (a : α) → σ a → β\n⊢ Eq (s.sum fun a => (t a).sum fun s => f a s) ((s.sigma t).sum fun x => f x.fst x.snd)","decl":"/-- The product over a sigma type equals the product of the fiberwise products. For rewriting\nin the reverse direction, use `Finset.prod_sigma`. -/\n@[to_additive \"The sum over a sigma type equals the sum of the fiberwise sums. For rewriting\nin the reverse direction, use `Finset.sum_sigma`\"]\ntheorem prod_sigma' {σ : α → Type*} (s : Finset α) (t : ∀ a, Finset (σ a)) (f : ∀ a, σ a → β) :\n    (∏ a ∈ s, ∏ s ∈ t a, f a s) = ∏ x ∈ s.sigma t, f x.1 x.2 :=\n  Eq.symm <| prod_sigma s t fun x => f x.1 x.2\n\n"}
{"name":"Finset.prod_of_injOn","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : CommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ne : ι → κ\nhe : Set.InjOn e ↑s\nhest : Set.MapsTo e ↑s ↑t\nh' : ∀ (i : κ), Membership.mem t i → Not (Membership.mem (Set.image e ↑s) i) → Eq (g i) 1\nh : ∀ (i : ι), Membership.mem s i → Eq (f i) (g (e i))\n⊢ Eq (s.prod fun i => f i) (t.prod fun j => g j)","decl":"@[to_additive]\nlemma prod_of_injOn (e : ι → κ) (he : Set.InjOn e s) (hest : Set.MapsTo e s t)\n    (h' : ∀ i ∈ t, i ∉ e '' s → g i = 1) (h : ∀ i ∈ s, f i = g (e i))  :\n    ∏ i ∈ s, f i = ∏ j ∈ t, g j := by\n  classical\n  exact (prod_nbij e (fun a ↦ mem_image_of_mem e) he (by simp [Set.surjOn_image]) h).trans <|\n    prod_subset (image_subset_iff.2 hest) <| by simpa using h'\n\n"}
{"name":"Finset.sum_of_injOn","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝ : AddCommMonoid α\ns : Finset ι\nt : Finset κ\nf : ι → α\ng : κ → α\ne : ι → κ\nhe : Set.InjOn e ↑s\nhest : Set.MapsTo e ↑s ↑t\nh' : ∀ (i : κ), Membership.mem t i → Not (Membership.mem (Set.image e ↑s) i) → Eq (g i) 0\nh : ∀ (i : ι), Membership.mem s i → Eq (f i) (g (e i))\n⊢ Eq (s.sum fun i => f i) (t.sum fun j => g j)","decl":"@[to_additive]\nlemma prod_of_injOn (e : ι → κ) (he : Set.InjOn e s) (hest : Set.MapsTo e s t)\n    (h' : ∀ i ∈ t, i ∉ e '' s → g i = 1) (h : ∀ i ∈ s, f i = g (e i))  :\n    ∏ i ∈ s, f i = ∏ j ∈ t, g j := by\n  classical\n  exact (prod_nbij e (fun a ↦ mem_image_of_mem e) he (by simp [Set.surjOn_image]) h).trans <|\n    prod_subset (image_subset_iff.2 hest) <| by simpa using h'\n\n"}
{"name":"Finset.prod_fiberwise_eq_prod_filter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝¹ : CommMonoid α\ninst✝ : DecidableEq κ\ns : Finset ι\nt : Finset κ\ng : ι → κ\nf : ι → α\n⊢ Eq (t.prod fun j => (Finset.filter (fun i => Eq (g i) j) s).prod fun i => f i) ((Finset.filter (fun i => Membership.mem t (g i)) s).prod fun i => f i)","decl":"@[to_additive]\nlemma prod_fiberwise_eq_prod_filter (s : Finset ι) (t : Finset κ) (g : ι → κ) (f : ι → α) :\n    ∏ j ∈ t, ∏ i ∈ s with g i = j, f i = ∏ i ∈ s with g i ∈ t, f i := by\n  rw [← prod_disjiUnion, disjiUnion_filter_eq]\n\n"}
{"name":"Finset.sum_fiberwise_eq_sum_filter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝¹ : AddCommMonoid α\ninst✝ : DecidableEq κ\ns : Finset ι\nt : Finset κ\ng : ι → κ\nf : ι → α\n⊢ Eq (t.sum fun j => (Finset.filter (fun i => Eq (g i) j) s).sum fun i => f i) ((Finset.filter (fun i => Membership.mem t (g i)) s).sum fun i => f i)","decl":"@[to_additive]\nlemma prod_fiberwise_eq_prod_filter (s : Finset ι) (t : Finset κ) (g : ι → κ) (f : ι → α) :\n    ∏ j ∈ t, ∏ i ∈ s with g i = j, f i = ∏ i ∈ s with g i ∈ t, f i := by\n  rw [← prod_disjiUnion, disjiUnion_filter_eq]\n\n"}
{"name":"Finset.prod_fiberwise_eq_prod_filter'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝¹ : CommMonoid α\ninst✝ : DecidableEq κ\ns : Finset ι\nt : Finset κ\ng : ι → κ\nf : κ → α\n⊢ Eq (t.prod fun j => (Finset.filter (fun i => Eq (g i) j) s).prod fun i => f j) ((Finset.filter (fun i => Membership.mem t (g i)) s).prod fun i => f (g i))","decl":"@[to_additive]\nlemma prod_fiberwise_eq_prod_filter' (s : Finset ι) (t : Finset κ) (g : ι → κ) (f : κ → α) :\n    ∏ j ∈ t, ∏ i ∈ s with g i = j, f j = ∏ i ∈ s with g i ∈ t, f (g i) := by\n  calc\n    _ = ∏ j ∈ t, ∏ i ∈ s with g i = j, f (g i) :=\n        prod_congr rfl fun j _ ↦ prod_congr rfl fun i hi ↦ by rw [(mem_filter.1 hi).2]\n    _ = _ := prod_fiberwise_eq_prod_filter _ _ _ _\n\n"}
{"name":"Finset.sum_fiberwise_eq_sum_filter'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝¹ : AddCommMonoid α\ninst✝ : DecidableEq κ\ns : Finset ι\nt : Finset κ\ng : ι → κ\nf : κ → α\n⊢ Eq (t.sum fun j => (Finset.filter (fun i => Eq (g i) j) s).sum fun i => f j) ((Finset.filter (fun i => Membership.mem t (g i)) s).sum fun i => f (g i))","decl":"@[to_additive]\nlemma prod_fiberwise_eq_prod_filter' (s : Finset ι) (t : Finset κ) (g : ι → κ) (f : κ → α) :\n    ∏ j ∈ t, ∏ i ∈ s with g i = j, f j = ∏ i ∈ s with g i ∈ t, f (g i) := by\n  calc\n    _ = ∏ j ∈ t, ∏ i ∈ s with g i = j, f (g i) :=\n        prod_congr rfl fun j _ ↦ prod_congr rfl fun i hi ↦ by rw [(mem_filter.1 hi).2]\n    _ = _ := prod_fiberwise_eq_prod_filter _ _ _ _\n\n"}
{"name":"Finset.sum_fiberwise_of_maps_to","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝¹ : AddCommMonoid α\ns : Finset ι\nt : Finset κ\ninst✝ : DecidableEq κ\ng : ι → κ\nh : ∀ (i : ι), Membership.mem s i → Membership.mem t (g i)\nf : ι → α\n⊢ Eq (t.sum fun j => (Finset.filter (fun i => Eq (g i) j) s).sum fun i => f i) (s.sum fun i => f i)","decl":"@[to_additive]\nlemma prod_fiberwise_of_maps_to {g : ι → κ} (h : ∀ i ∈ s, g i ∈ t) (f : ι → α) :\n    ∏ j ∈ t, ∏ i ∈ s with g i = j, f i = ∏ i ∈ s, f i := by\n  rw [← prod_disjiUnion, disjiUnion_filter_eq_of_maps_to h]\n\n"}
{"name":"Finset.prod_fiberwise_of_maps_to","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝¹ : CommMonoid α\ns : Finset ι\nt : Finset κ\ninst✝ : DecidableEq κ\ng : ι → κ\nh : ∀ (i : ι), Membership.mem s i → Membership.mem t (g i)\nf : ι → α\n⊢ Eq (t.prod fun j => (Finset.filter (fun i => Eq (g i) j) s).prod fun i => f i) (s.prod fun i => f i)","decl":"@[to_additive]\nlemma prod_fiberwise_of_maps_to {g : ι → κ} (h : ∀ i ∈ s, g i ∈ t) (f : ι → α) :\n    ∏ j ∈ t, ∏ i ∈ s with g i = j, f i = ∏ i ∈ s, f i := by\n  rw [← prod_disjiUnion, disjiUnion_filter_eq_of_maps_to h]\n\n"}
{"name":"Finset.prod_fiberwise_of_maps_to'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝¹ : CommMonoid α\ns : Finset ι\nt : Finset κ\ninst✝ : DecidableEq κ\ng : ι → κ\nh : ∀ (i : ι), Membership.mem s i → Membership.mem t (g i)\nf : κ → α\n⊢ Eq (t.prod fun j => (Finset.filter (fun i => Eq (g i) j) s).prod fun i => f j) (s.prod fun i => f (g i))","decl":"@[to_additive]\nlemma prod_fiberwise_of_maps_to' {g : ι → κ} (h : ∀ i ∈ s, g i ∈ t) (f : κ → α) :\n    ∏ j ∈ t, ∏ i ∈ s with g i = j, f j = ∏ i ∈ s, f (g i) := by\n  calc\n    _ = ∏ j ∈ t, ∏ i ∈ s with g i = j, f (g i) :=\n        prod_congr rfl fun y _ ↦ prod_congr rfl fun x hx ↦ by rw [(mem_filter.1 hx).2]\n    _ = _ := prod_fiberwise_of_maps_to h _\n\n"}
{"name":"Finset.sum_fiberwise_of_maps_to'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝¹ : AddCommMonoid α\ns : Finset ι\nt : Finset κ\ninst✝ : DecidableEq κ\ng : ι → κ\nh : ∀ (i : ι), Membership.mem s i → Membership.mem t (g i)\nf : κ → α\n⊢ Eq (t.sum fun j => (Finset.filter (fun i => Eq (g i) j) s).sum fun i => f j) (s.sum fun i => f (g i))","decl":"@[to_additive]\nlemma prod_fiberwise_of_maps_to' {g : ι → κ} (h : ∀ i ∈ s, g i ∈ t) (f : κ → α) :\n    ∏ j ∈ t, ∏ i ∈ s with g i = j, f j = ∏ i ∈ s, f (g i) := by\n  calc\n    _ = ∏ j ∈ t, ∏ i ∈ s with g i = j, f (g i) :=\n        prod_congr rfl fun y _ ↦ prod_congr rfl fun x hx ↦ by rw [(mem_filter.1 hx).2]\n    _ = _ := prod_fiberwise_of_maps_to h _\n\n"}
{"name":"Finset.prod_fiberwise","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : CommMonoid α\ninst✝¹ : DecidableEq κ\ninst✝ : Fintype κ\ns : Finset ι\ng : ι → κ\nf : ι → α\n⊢ Eq (Finset.univ.prod fun j => (Finset.filter (fun i => Eq (g i) j) s).prod fun i => f i) (s.prod fun i => f i)","decl":"@[to_additive]\nlemma prod_fiberwise (s : Finset ι) (g : ι → κ) (f : ι → α) :\n    ∏ j, ∏ i ∈ s with g i = j, f i = ∏ i ∈ s, f i :=\n  prod_fiberwise_of_maps_to (fun _ _ ↦ mem_univ _) _\n\n"}
{"name":"Finset.sum_fiberwise","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : AddCommMonoid α\ninst✝¹ : DecidableEq κ\ninst✝ : Fintype κ\ns : Finset ι\ng : ι → κ\nf : ι → α\n⊢ Eq (Finset.univ.sum fun j => (Finset.filter (fun i => Eq (g i) j) s).sum fun i => f i) (s.sum fun i => f i)","decl":"@[to_additive]\nlemma prod_fiberwise (s : Finset ι) (g : ι → κ) (f : ι → α) :\n    ∏ j, ∏ i ∈ s with g i = j, f i = ∏ i ∈ s, f i :=\n  prod_fiberwise_of_maps_to (fun _ _ ↦ mem_univ _) _\n\n"}
{"name":"Finset.prod_fiberwise'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : CommMonoid α\ninst✝¹ : DecidableEq κ\ninst✝ : Fintype κ\ns : Finset ι\ng : ι → κ\nf : κ → α\n⊢ Eq (Finset.univ.prod fun j => (Finset.filter (fun i => Eq (g i) j) s).prod fun i => f j) (s.prod fun i => f (g i))","decl":"@[to_additive]\nlemma prod_fiberwise' (s : Finset ι) (g : ι → κ) (f : κ → α) :\n    ∏ j, ∏ i ∈ s with g i = j, f j = ∏ i ∈ s, f (g i) :=\n  prod_fiberwise_of_maps_to' (fun _ _ ↦ mem_univ _) _\n\n"}
{"name":"Finset.sum_fiberwise'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : AddCommMonoid α\ninst✝¹ : DecidableEq κ\ninst✝ : Fintype κ\ns : Finset ι\ng : ι → κ\nf : κ → α\n⊢ Eq (Finset.univ.sum fun j => (Finset.filter (fun i => Eq (g i) j) s).sum fun i => f j) (s.sum fun i => f (g i))","decl":"@[to_additive]\nlemma prod_fiberwise' (s : Finset ι) (g : ι → κ) (f : κ → α) :\n    ∏ j, ∏ i ∈ s with g i = j, f j = ∏ i ∈ s, f (g i) :=\n  prod_fiberwise_of_maps_to' (fun _ _ ↦ mem_univ _) _\n\n"}
{"name":"Finset.prod_univ_pi","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝² : CommMonoid β\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nκ : ι → Type u_6\nt : (i : ι) → Finset (κ i)\nf : ((i : ι) → Membership.mem Finset.univ i → κ i) → β\n⊢ Eq ((Finset.univ.pi t).prod fun x => f x) ((Fintype.piFinset t).prod fun x => f fun a x_1 => x a)","decl":"/-- Taking a product over `univ.pi t` is the same as taking the product over `Fintype.piFinset t`.\n`univ.pi t` and `Fintype.piFinset t` are essentially the same `Finset`, but differ\nin the type of their element, `univ.pi t` is a `Finset (Π a ∈ univ, t a)` and\n`Fintype.piFinset t` is a `Finset (Π a, t a)`. -/\n@[to_additive \"Taking a sum over `univ.pi t` is the same as taking the sum over\n`Fintype.piFinset t`. `univ.pi t` and `Fintype.piFinset t` are essentially the same `Finset`,\nbut differ in the type of their element, `univ.pi t` is a `Finset (Π a ∈ univ, t a)` and\n`Fintype.piFinset t` is a `Finset (Π a, t a)`.\"]\nlemma prod_univ_pi [DecidableEq ι] [Fintype ι] {κ : ι → Type*} (t : ∀ i, Finset (κ i))\n    (f : (∀ i ∈ (univ : Finset ι), κ i) → β) :\n    ∏ x ∈ univ.pi t, f x = ∏ x ∈ Fintype.piFinset t, f fun a _ ↦ x a := by\n  apply prod_nbij' (fun x i ↦ x i <| mem_univ _) (fun x i _ ↦ x i) <;> simp\n\n"}
{"name":"Finset.sum_univ_pi","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝² : AddCommMonoid β\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nκ : ι → Type u_6\nt : (i : ι) → Finset (κ i)\nf : ((i : ι) → Membership.mem Finset.univ i → κ i) → β\n⊢ Eq ((Finset.univ.pi t).sum fun x => f x) ((Fintype.piFinset t).sum fun x => f fun a x_1 => x a)","decl":"/-- Taking a product over `univ.pi t` is the same as taking the product over `Fintype.piFinset t`.\n`univ.pi t` and `Fintype.piFinset t` are essentially the same `Finset`, but differ\nin the type of their element, `univ.pi t` is a `Finset (Π a ∈ univ, t a)` and\n`Fintype.piFinset t` is a `Finset (Π a, t a)`. -/\n@[to_additive \"Taking a sum over `univ.pi t` is the same as taking the sum over\n`Fintype.piFinset t`. `univ.pi t` and `Fintype.piFinset t` are essentially the same `Finset`,\nbut differ in the type of their element, `univ.pi t` is a `Finset (Π a ∈ univ, t a)` and\n`Fintype.piFinset t` is a `Finset (Π a, t a)`.\"]\nlemma prod_univ_pi [DecidableEq ι] [Fintype ι] {κ : ι → Type*} (t : ∀ i, Finset (κ i))\n    (f : (∀ i ∈ (univ : Finset ι), κ i) → β) :\n    ∏ x ∈ univ.pi t, f x = ∏ x ∈ Fintype.piFinset t, f fun a _ ↦ x a := by\n  apply prod_nbij' (fun x i ↦ x i <| mem_univ _) (fun x i _ ↦ x i) <;> simp\n\n"}
{"name":"Finset.sum_diag","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\nf : Prod α α → β\n⊢ Eq (s.diag.sum fun i => f i) (s.sum fun i => f { fst := i, snd := i })","decl":"@[to_additive (attr := simp)]\nlemma prod_diag [DecidableEq α] (s : Finset α) (f : α × α → β) :\n    ∏ i ∈ s.diag, f i = ∏ i ∈ s, f (i, i) := by\n  apply prod_nbij' Prod.fst (fun i ↦ (i, i)) <;> simp\n\n"}
{"name":"Finset.prod_diag","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\nf : Prod α α → β\n⊢ Eq (s.diag.prod fun i => f i) (s.prod fun i => f { fst := i, snd := i })","decl":"@[to_additive (attr := simp)]\nlemma prod_diag [DecidableEq α] (s : Finset α) (f : α × α → β) :\n    ∏ i ∈ s.diag, f i = ∏ i ∈ s, f (i, i) := by\n  apply prod_nbij' Prod.fst (fun i ↦ (i, i)) <;> simp\n\n"}
{"name":"Finset.sum_finset_product","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\nr : Finset (Prod γ α)\ns : Finset γ\nt : γ → Finset α\nh : ∀ (p : Prod γ α), Iff (Membership.mem r p) (And (Membership.mem s p.1) (Membership.mem (t p.1) p.2))\nf : Prod γ α → β\n⊢ Eq (r.sum fun p => f p) (s.sum fun c => (t c).sum fun a => f { fst := c, snd := a })","decl":"@[to_additive]\ntheorem prod_finset_product (r : Finset (γ × α)) (s : Finset γ) (t : γ → Finset α)\n    (h : ∀ p : γ × α, p ∈ r ↔ p.1 ∈ s ∧ p.2 ∈ t p.1) {f : γ × α → β} :\n    ∏ p ∈ r, f p = ∏ c ∈ s, ∏ a ∈ t c, f (c, a) := by\n  refine Eq.trans ?_ (prod_sigma s t fun p => f (p.1, p.2))\n  apply prod_equiv (Equiv.sigmaEquivProd _ _).symm <;> simp [h]\n\n"}
{"name":"Finset.prod_finset_product","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\nr : Finset (Prod γ α)\ns : Finset γ\nt : γ → Finset α\nh : ∀ (p : Prod γ α), Iff (Membership.mem r p) (And (Membership.mem s p.1) (Membership.mem (t p.1) p.2))\nf : Prod γ α → β\n⊢ Eq (r.prod fun p => f p) (s.prod fun c => (t c).prod fun a => f { fst := c, snd := a })","decl":"@[to_additive]\ntheorem prod_finset_product (r : Finset (γ × α)) (s : Finset γ) (t : γ → Finset α)\n    (h : ∀ p : γ × α, p ∈ r ↔ p.1 ∈ s ∧ p.2 ∈ t p.1) {f : γ × α → β} :\n    ∏ p ∈ r, f p = ∏ c ∈ s, ∏ a ∈ t c, f (c, a) := by\n  refine Eq.trans ?_ (prod_sigma s t fun p => f (p.1, p.2))\n  apply prod_equiv (Equiv.sigmaEquivProd _ _).symm <;> simp [h]\n\n"}
{"name":"Finset.sum_finset_product'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\nr : Finset (Prod γ α)\ns : Finset γ\nt : γ → Finset α\nh : ∀ (p : Prod γ α), Iff (Membership.mem r p) (And (Membership.mem s p.1) (Membership.mem (t p.1) p.2))\nf : γ → α → β\n⊢ Eq (r.sum fun p => f p.1 p.2) (s.sum fun c => (t c).sum fun a => f c a)","decl":"@[to_additive]\ntheorem prod_finset_product' (r : Finset (γ × α)) (s : Finset γ) (t : γ → Finset α)\n    (h : ∀ p : γ × α, p ∈ r ↔ p.1 ∈ s ∧ p.2 ∈ t p.1) {f : γ → α → β} :\n    ∏ p ∈ r, f p.1 p.2 = ∏ c ∈ s, ∏ a ∈ t c, f c a :=\n  prod_finset_product r s t h\n\n"}
{"name":"Finset.prod_finset_product'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\nr : Finset (Prod γ α)\ns : Finset γ\nt : γ → Finset α\nh : ∀ (p : Prod γ α), Iff (Membership.mem r p) (And (Membership.mem s p.1) (Membership.mem (t p.1) p.2))\nf : γ → α → β\n⊢ Eq (r.prod fun p => f p.1 p.2) (s.prod fun c => (t c).prod fun a => f c a)","decl":"@[to_additive]\ntheorem prod_finset_product' (r : Finset (γ × α)) (s : Finset γ) (t : γ → Finset α)\n    (h : ∀ p : γ × α, p ∈ r ↔ p.1 ∈ s ∧ p.2 ∈ t p.1) {f : γ → α → β} :\n    ∏ p ∈ r, f p.1 p.2 = ∏ c ∈ s, ∏ a ∈ t c, f c a :=\n  prod_finset_product r s t h\n\n"}
{"name":"Finset.prod_finset_product_right","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\nr : Finset (Prod α γ)\ns : Finset γ\nt : γ → Finset α\nh : ∀ (p : Prod α γ), Iff (Membership.mem r p) (And (Membership.mem s p.2) (Membership.mem (t p.2) p.1))\nf : Prod α γ → β\n⊢ Eq (r.prod fun p => f p) (s.prod fun c => (t c).prod fun a => f { fst := a, snd := c })","decl":"@[to_additive]\ntheorem prod_finset_product_right (r : Finset (α × γ)) (s : Finset γ) (t : γ → Finset α)\n    (h : ∀ p : α × γ, p ∈ r ↔ p.2 ∈ s ∧ p.1 ∈ t p.2) {f : α × γ → β} :\n    ∏ p ∈ r, f p = ∏ c ∈ s, ∏ a ∈ t c, f (a, c) := by\n  refine Eq.trans ?_ (prod_sigma s t fun p => f (p.2, p.1))\n  apply prod_equiv ((Equiv.prodComm _ _).trans (Equiv.sigmaEquivProd _ _).symm) <;> simp [h]\n\n"}
{"name":"Finset.sum_finset_product_right","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\nr : Finset (Prod α γ)\ns : Finset γ\nt : γ → Finset α\nh : ∀ (p : Prod α γ), Iff (Membership.mem r p) (And (Membership.mem s p.2) (Membership.mem (t p.2) p.1))\nf : Prod α γ → β\n⊢ Eq (r.sum fun p => f p) (s.sum fun c => (t c).sum fun a => f { fst := a, snd := c })","decl":"@[to_additive]\ntheorem prod_finset_product_right (r : Finset (α × γ)) (s : Finset γ) (t : γ → Finset α)\n    (h : ∀ p : α × γ, p ∈ r ↔ p.2 ∈ s ∧ p.1 ∈ t p.2) {f : α × γ → β} :\n    ∏ p ∈ r, f p = ∏ c ∈ s, ∏ a ∈ t c, f (a, c) := by\n  refine Eq.trans ?_ (prod_sigma s t fun p => f (p.2, p.1))\n  apply prod_equiv ((Equiv.prodComm _ _).trans (Equiv.sigmaEquivProd _ _).symm) <;> simp [h]\n\n"}
{"name":"Finset.prod_finset_product_right'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\nr : Finset (Prod α γ)\ns : Finset γ\nt : γ → Finset α\nh : ∀ (p : Prod α γ), Iff (Membership.mem r p) (And (Membership.mem s p.2) (Membership.mem (t p.2) p.1))\nf : α → γ → β\n⊢ Eq (r.prod fun p => f p.1 p.2) (s.prod fun c => (t c).prod fun a => f a c)","decl":"@[to_additive]\ntheorem prod_finset_product_right' (r : Finset (α × γ)) (s : Finset γ) (t : γ → Finset α)\n    (h : ∀ p : α × γ, p ∈ r ↔ p.2 ∈ s ∧ p.1 ∈ t p.2) {f : α → γ → β} :\n    ∏ p ∈ r, f p.1 p.2 = ∏ c ∈ s, ∏ a ∈ t c, f a c :=\n  prod_finset_product_right r s t h\n\n"}
{"name":"Finset.sum_finset_product_right'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\nr : Finset (Prod α γ)\ns : Finset γ\nt : γ → Finset α\nh : ∀ (p : Prod α γ), Iff (Membership.mem r p) (And (Membership.mem s p.2) (Membership.mem (t p.2) p.1))\nf : α → γ → β\n⊢ Eq (r.sum fun p => f p.1 p.2) (s.sum fun c => (t c).sum fun a => f a c)","decl":"@[to_additive]\ntheorem prod_finset_product_right' (r : Finset (α × γ)) (s : Finset γ) (t : γ → Finset α)\n    (h : ∀ p : α × γ, p ∈ r ↔ p.2 ∈ s ∧ p.1 ∈ t p.2) {f : α → γ → β} :\n    ∏ p ∈ r, f p.1 p.2 = ∏ c ∈ s, ∏ a ∈ t c, f a c :=\n  prod_finset_product_right r s t h\n\n"}
{"name":"Finset.sum_image'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\nf : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset ι\ng : ι → α\nh : ι → β\neq : ∀ (i : ι), Membership.mem s i → Eq (f (g i)) ((Finset.filter (fun j => Eq (g j) (g i)) s).sum fun j => h j)\n⊢ Eq ((Finset.image g s).sum fun a => f a) (s.sum fun i => h i)","decl":"@[to_additive]\ntheorem prod_image' [DecidableEq α] {s : Finset ι} {g : ι → α} (h : ι → β)\n    (eq : ∀ i ∈ s, f (g i) = ∏ j ∈ s with g j = g i, h j) :\n    ∏ a ∈ s.image g, f a = ∏ i ∈ s, h i :=\n  calc\n    ∏ a ∈ s.image g, f a = ∏ a ∈ s.image g, ∏ j ∈ s with g j = a, h j :=\n      (prod_congr rfl) fun _a hx =>\n        let ⟨i, his, hi⟩ := mem_image.1 hx\n        hi ▸ eq i his\n    _ = ∏ i ∈ s, h i := prod_fiberwise_of_maps_to (fun _ => mem_image_of_mem g) _\n\n"}
{"name":"Finset.prod_image'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\nf : α → β\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset ι\ng : ι → α\nh : ι → β\neq : ∀ (i : ι), Membership.mem s i → Eq (f (g i)) ((Finset.filter (fun j => Eq (g j) (g i)) s).prod fun j => h j)\n⊢ Eq ((Finset.image g s).prod fun a => f a) (s.prod fun i => h i)","decl":"@[to_additive]\ntheorem prod_image' [DecidableEq α] {s : Finset ι} {g : ι → α} (h : ι → β)\n    (eq : ∀ i ∈ s, f (g i) = ∏ j ∈ s with g j = g i, h j) :\n    ∏ a ∈ s.image g, f a = ∏ i ∈ s, h i :=\n  calc\n    ∏ a ∈ s.image g, f a = ∏ a ∈ s.image g, ∏ j ∈ s with g j = a, h j :=\n      (prod_congr rfl) fun _a hx =>\n        let ⟨i, his, hi⟩ := mem_image.1 hx\n        hi ▸ eq i his\n    _ = ∏ i ∈ s, h i := prod_fiberwise_of_maps_to (fun _ => mem_image_of_mem g) _\n\n"}
{"name":"Finset.sum_add_distrib","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf g : α → β\ninst✝ : AddCommMonoid β\n⊢ Eq (s.sum fun x => HAdd.hAdd (f x) (g x)) (HAdd.hAdd (s.sum fun x => f x) (s.sum fun x => g x))","decl":"@[to_additive]\ntheorem prod_mul_distrib : ∏ x ∈ s, f x * g x = (∏ x ∈ s, f x) * ∏ x ∈ s, g x :=\n  Eq.trans (by rw [one_mul]; rfl) fold_op_distrib\n\n"}
{"name":"Finset.prod_mul_distrib","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf g : α → β\ninst✝ : CommMonoid β\n⊢ Eq (s.prod fun x => HMul.hMul (f x) (g x)) (HMul.hMul (s.prod fun x => f x) (s.prod fun x => g x))","decl":"@[to_additive]\ntheorem prod_mul_distrib : ∏ x ∈ s, f x * g x = (∏ x ∈ s, f x) * ∏ x ∈ s, g x :=\n  Eq.trans (by rw [one_mul]; rfl) fold_op_distrib\n\n"}
{"name":"Finset.prod_mul_prod_comm","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : CommMonoid β\nf g h i : α → β\n⊢ Eq (HMul.hMul (s.prod fun a => HMul.hMul (f a) (g a)) (s.prod fun a => HMul.hMul (h a) (i a))) (HMul.hMul (s.prod fun a => HMul.hMul (f a) (h a)) (s.prod fun a => HMul.hMul (g a) (i a)))","decl":"@[to_additive]\nlemma prod_mul_prod_comm (f g h i : α → β) :\n    (∏ a ∈ s, f a * g a) * ∏ a ∈ s, h a * i a = (∏ a ∈ s, f a * h a) * ∏ a ∈ s, g a * i a := by\n  simp_rw [prod_mul_distrib, mul_mul_mul_comm]\n\n"}
{"name":"Finset.sum_add_sum_comm","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : AddCommMonoid β\nf g h i : α → β\n⊢ Eq (HAdd.hAdd (s.sum fun a => HAdd.hAdd (f a) (g a)) (s.sum fun a => HAdd.hAdd (h a) (i a))) (HAdd.hAdd (s.sum fun a => HAdd.hAdd (f a) (h a)) (s.sum fun a => HAdd.hAdd (g a) (i a)))","decl":"@[to_additive]\nlemma prod_mul_prod_comm (f g h i : α → β) :\n    (∏ a ∈ s, f a * g a) * ∏ a ∈ s, h a * i a = (∏ a ∈ s, f a * h a) * ∏ a ∈ s, g a * i a := by\n  simp_rw [prod_mul_distrib, mul_mul_mul_comm]\n\n"}
{"name":"Finset.sum_product","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\ns : Finset γ\nt : Finset α\nf : Prod γ α → β\n⊢ Eq ((SProd.sprod s t).sum fun x => f x) (s.sum fun x => t.sum fun y => f { fst := x, snd := y })","decl":"/-- The product over a product set equals the product of the fiberwise products. For rewriting\nin the reverse direction, use `Finset.prod_product'`. -/\n@[to_additive \"The sum over a product set equals the sum of the fiberwise sums. For rewriting\nin the reverse direction, use `Finset.sum_product'`\"]\ntheorem prod_product (s : Finset γ) (t : Finset α) (f : γ × α → β) :\n    ∏ x ∈ s ×ˢ t, f x = ∏ x ∈ s, ∏ y ∈ t, f (x, y) :=\n  prod_finset_product (s ×ˢ t) s (fun _a => t) fun _p => mem_product\n\n"}
{"name":"Finset.prod_product","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\ns : Finset γ\nt : Finset α\nf : Prod γ α → β\n⊢ Eq ((SProd.sprod s t).prod fun x => f x) (s.prod fun x => t.prod fun y => f { fst := x, snd := y })","decl":"/-- The product over a product set equals the product of the fiberwise products. For rewriting\nin the reverse direction, use `Finset.prod_product'`. -/\n@[to_additive \"The sum over a product set equals the sum of the fiberwise sums. For rewriting\nin the reverse direction, use `Finset.sum_product'`\"]\ntheorem prod_product (s : Finset γ) (t : Finset α) (f : γ × α → β) :\n    ∏ x ∈ s ×ˢ t, f x = ∏ x ∈ s, ∏ y ∈ t, f (x, y) :=\n  prod_finset_product (s ×ˢ t) s (fun _a => t) fun _p => mem_product\n\n"}
{"name":"Finset.sum_product'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\ns : Finset γ\nt : Finset α\nf : γ → α → β\n⊢ Eq ((SProd.sprod s t).sum fun x => f x.1 x.2) (s.sum fun x => t.sum fun y => f x y)","decl":"/-- The product over a product set equals the product of the fiberwise products. For rewriting\nin the reverse direction, use `Finset.prod_product`. -/\n@[to_additive \"The sum over a product set equals the sum of the fiberwise sums. For rewriting\nin the reverse direction, use `Finset.sum_product`\"]\ntheorem prod_product' (s : Finset γ) (t : Finset α) (f : γ → α → β) :\n    ∏ x ∈ s ×ˢ t, f x.1 x.2 = ∏ x ∈ s, ∏ y ∈ t, f x y :=\n  prod_product ..\n\n"}
{"name":"Finset.prod_product'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\ns : Finset γ\nt : Finset α\nf : γ → α → β\n⊢ Eq ((SProd.sprod s t).prod fun x => f x.1 x.2) (s.prod fun x => t.prod fun y => f x y)","decl":"/-- The product over a product set equals the product of the fiberwise products. For rewriting\nin the reverse direction, use `Finset.prod_product`. -/\n@[to_additive \"The sum over a product set equals the sum of the fiberwise sums. For rewriting\nin the reverse direction, use `Finset.sum_product`\"]\ntheorem prod_product' (s : Finset γ) (t : Finset α) (f : γ → α → β) :\n    ∏ x ∈ s ×ˢ t, f x.1 x.2 = ∏ x ∈ s, ∏ y ∈ t, f x y :=\n  prod_product ..\n\n"}
{"name":"Finset.sum_product_right","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\ns : Finset γ\nt : Finset α\nf : Prod γ α → β\n⊢ Eq ((SProd.sprod s t).sum fun x => f x) (t.sum fun y => s.sum fun x => f { fst := x, snd := y })","decl":"@[to_additive]\ntheorem prod_product_right (s : Finset γ) (t : Finset α) (f : γ × α → β) :\n    ∏ x ∈ s ×ˢ t, f x = ∏ y ∈ t, ∏ x ∈ s, f (x, y) :=\n  prod_finset_product_right (s ×ˢ t) t (fun _a => s) fun _p => mem_product.trans and_comm\n\n"}
{"name":"Finset.prod_product_right","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\ns : Finset γ\nt : Finset α\nf : Prod γ α → β\n⊢ Eq ((SProd.sprod s t).prod fun x => f x) (t.prod fun y => s.prod fun x => f { fst := x, snd := y })","decl":"@[to_additive]\ntheorem prod_product_right (s : Finset γ) (t : Finset α) (f : γ × α → β) :\n    ∏ x ∈ s ×ˢ t, f x = ∏ y ∈ t, ∏ x ∈ s, f (x, y) :=\n  prod_finset_product_right (s ×ˢ t) t (fun _a => s) fun _p => mem_product.trans and_comm\n\n"}
{"name":"Finset.prod_product_right'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\ns : Finset γ\nt : Finset α\nf : γ → α → β\n⊢ Eq ((SProd.sprod s t).prod fun x => f x.1 x.2) (t.prod fun y => s.prod fun x => f x y)","decl":"/-- An uncurried version of `Finset.prod_product_right`. -/\n@[to_additive \"An uncurried version of `Finset.sum_product_right`\"]\ntheorem prod_product_right' (s : Finset γ) (t : Finset α) (f : γ → α → β) :\n    ∏ x ∈ s ×ˢ t, f x.1 x.2 = ∏ y ∈ t, ∏ x ∈ s, f x y :=\n  prod_product_right ..\n\n"}
{"name":"Finset.sum_product_right'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\ns : Finset γ\nt : Finset α\nf : γ → α → β\n⊢ Eq ((SProd.sprod s t).sum fun x => f x.1 x.2) (t.sum fun y => s.sum fun x => f x y)","decl":"/-- An uncurried version of `Finset.prod_product_right`. -/\n@[to_additive \"An uncurried version of `Finset.sum_product_right`\"]\ntheorem prod_product_right' (s : Finset γ) (t : Finset α) (f : γ → α → β) :\n    ∏ x ∈ s ×ˢ t, f x.1 x.2 = ∏ y ∈ t, ∏ x ∈ s, f x y :=\n  prod_product_right ..\n\n"}
{"name":"Finset.prod_comm'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\ns : Finset γ\nt : γ → Finset α\nt' : Finset α\ns' : α → Finset γ\nh : ∀ (x : γ) (y : α), Iff (And (Membership.mem s x) (Membership.mem (t x) y)) (And (Membership.mem (s' y) x) (Membership.mem t' y))\nf : γ → α → β\n⊢ Eq (s.prod fun x => (t x).prod fun y => f x y) (t'.prod fun y => (s' y).prod fun x => f x y)","decl":"/-- Generalization of `Finset.prod_comm` to the case when the inner `Finset`s depend on the outer\nvariable. -/\n@[to_additive \"Generalization of `Finset.sum_comm` to the case when the inner `Finset`s depend on\nthe outer variable.\"]\ntheorem prod_comm' {s : Finset γ} {t : γ → Finset α} {t' : Finset α} {s' : α → Finset γ}\n    (h : ∀ x y, x ∈ s ∧ y ∈ t x ↔ x ∈ s' y ∧ y ∈ t') {f : γ → α → β} :\n    (∏ x ∈ s, ∏ y ∈ t x, f x y) = ∏ y ∈ t', ∏ x ∈ s' y, f x y := by\n  classical\n    have : ∀ z : γ × α, (z ∈ s.biUnion fun x => (t x).map <| Function.Embedding.sectR x _) ↔\n      z.1 ∈ s ∧ z.2 ∈ t z.1 := by\n      rintro ⟨x, y⟩\n      simp only [mem_biUnion, mem_map, Function.Embedding.sectR_apply, Prod.mk.injEq,\n        exists_eq_right, ← and_assoc]\n    exact\n      (prod_finset_product' _ _ _ this).symm.trans\n        ((prod_finset_product_right' _ _ _) fun ⟨x, y⟩ => (this _).trans ((h x y).trans and_comm))\n\n"}
{"name":"Finset.sum_comm'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\ns : Finset γ\nt : γ → Finset α\nt' : Finset α\ns' : α → Finset γ\nh : ∀ (x : γ) (y : α), Iff (And (Membership.mem s x) (Membership.mem (t x) y)) (And (Membership.mem (s' y) x) (Membership.mem t' y))\nf : γ → α → β\n⊢ Eq (s.sum fun x => (t x).sum fun y => f x y) (t'.sum fun y => (s' y).sum fun x => f x y)","decl":"/-- Generalization of `Finset.prod_comm` to the case when the inner `Finset`s depend on the outer\nvariable. -/\n@[to_additive \"Generalization of `Finset.sum_comm` to the case when the inner `Finset`s depend on\nthe outer variable.\"]\ntheorem prod_comm' {s : Finset γ} {t : γ → Finset α} {t' : Finset α} {s' : α → Finset γ}\n    (h : ∀ x y, x ∈ s ∧ y ∈ t x ↔ x ∈ s' y ∧ y ∈ t') {f : γ → α → β} :\n    (∏ x ∈ s, ∏ y ∈ t x, f x y) = ∏ y ∈ t', ∏ x ∈ s' y, f x y := by\n  classical\n    have : ∀ z : γ × α, (z ∈ s.biUnion fun x => (t x).map <| Function.Embedding.sectR x _) ↔\n      z.1 ∈ s ∧ z.2 ∈ t z.1 := by\n      rintro ⟨x, y⟩\n      simp only [mem_biUnion, mem_map, Function.Embedding.sectR_apply, Prod.mk.injEq,\n        exists_eq_right, ← and_assoc]\n    exact\n      (prod_finset_product' _ _ _ this).symm.trans\n        ((prod_finset_product_right' _ _ _) fun ⟨x, y⟩ => (this _).trans ((h x y).trans and_comm))\n\n"}
{"name":"Finset.prod_comm","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\ns : Finset γ\nt : Finset α\nf : γ → α → β\n⊢ Eq (s.prod fun x => t.prod fun y => f x y) (t.prod fun y => s.prod fun x => f x y)","decl":"@[to_additive]\ntheorem prod_comm {s : Finset γ} {t : Finset α} {f : γ → α → β} :\n    (∏ x ∈ s, ∏ y ∈ t, f x y) = ∏ y ∈ t, ∏ x ∈ s, f x y :=\n  prod_comm' fun _ _ => Iff.rfl\n\n"}
{"name":"Finset.sum_comm","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\ns : Finset γ\nt : Finset α\nf : γ → α → β\n⊢ Eq (s.sum fun x => t.sum fun y => f x y) (t.sum fun y => s.sum fun x => f x y)","decl":"@[to_additive]\ntheorem prod_comm {s : Finset γ} {t : Finset α} {f : γ → α → β} :\n    (∏ x ∈ s, ∏ y ∈ t, f x y) = ∏ y ∈ t, ∏ x ∈ s, f x y :=\n  prod_comm' fun _ _ => Iff.rfl\n\n"}
{"name":"Finset.prod_filter_of_ne","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝¹ : CommMonoid β\np : α → Prop\ninst✝ : DecidablePred p\nhp : ∀ (x : α), Membership.mem s x → Ne (f x) 1 → p x\n⊢ Eq ((Finset.filter (fun x => p x) s).prod fun x => f x) (s.prod fun x => f x)","decl":"@[to_additive]\ntheorem prod_filter_of_ne {p : α → Prop} [DecidablePred p] (hp : ∀ x ∈ s, f x ≠ 1 → p x) :\n    ∏ x ∈ s with p x, f x = ∏ x ∈ s, f x :=\n  (prod_subset (filter_subset _ _)) fun x => by\n    classical\n      rw [not_imp_comm, mem_filter]\n      exact fun h₁ h₂ => ⟨h₁, by simpa using hp _ h₁ h₂⟩\n\n-- If we use `[DecidableEq β]` here, some rewrites fail because they find a wrong `Decidable`\n-- instance first; `{∀ x, Decidable (f x ≠ 1)}` doesn't work with `rw ← prod_filter_ne_one`\n"}
{"name":"Finset.sum_filter_of_ne","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝¹ : AddCommMonoid β\np : α → Prop\ninst✝ : DecidablePred p\nhp : ∀ (x : α), Membership.mem s x → Ne (f x) 0 → p x\n⊢ Eq ((Finset.filter (fun x => p x) s).sum fun x => f x) (s.sum fun x => f x)","decl":"@[to_additive]\ntheorem prod_filter_of_ne {p : α → Prop} [DecidablePred p] (hp : ∀ x ∈ s, f x ≠ 1 → p x) :\n    ∏ x ∈ s with p x, f x = ∏ x ∈ s, f x :=\n  (prod_subset (filter_subset _ _)) fun x => by\n    classical\n      rw [not_imp_comm, mem_filter]\n      exact fun h₁ h₂ => ⟨h₁, by simpa using hp _ h₁ h₂⟩\n\n-- If we use `[DecidableEq β]` here, some rewrites fail because they find a wrong `Decidable`\n-- instance first; `{∀ x, Decidable (f x ≠ 1)}` doesn't work with `rw ← prod_filter_ne_one`\n"}
{"name":"Finset.prod_filter_ne_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ninst✝¹ : CommMonoid β\ns : Finset α\ninst✝ : (x : α) → Decidable (Ne (f x) 1)\n⊢ Eq ((Finset.filter (fun x => Ne (f x) 1) s).prod fun x => f x) (s.prod fun x => f x)","decl":"@[to_additive]\ntheorem prod_filter_ne_one (s : Finset α) [∀ x, Decidable (f x ≠ 1)] :\n    ∏ x ∈ s with f x ≠ 1, f x = ∏ x ∈ s, f x :=\n  prod_filter_of_ne fun _ _ => id\n\n"}
{"name":"Finset.sum_filter_ne_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ninst✝¹ : AddCommMonoid β\ns : Finset α\ninst✝ : (x : α) → Decidable (Ne (f x) 0)\n⊢ Eq ((Finset.filter (fun x => Ne (f x) 0) s).sum fun x => f x) (s.sum fun x => f x)","decl":"@[to_additive]\ntheorem prod_filter_ne_one (s : Finset α) [∀ x, Decidable (f x ≠ 1)] :\n    ∏ x ∈ s with f x ≠ 1, f x = ∏ x ∈ s, f x :=\n  prod_filter_of_ne fun _ _ => id\n\n"}
{"name":"Finset.prod_filter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝¹ : CommMonoid β\np : α → Prop\ninst✝ : DecidablePred p\nf : α → β\n⊢ Eq ((Finset.filter (fun a => p a) s).prod fun a => f a) (s.prod fun a => ite (p a) (f a) 1)","decl":"@[to_additive]\ntheorem prod_filter (p : α → Prop) [DecidablePred p] (f : α → β) :\n    ∏ a ∈ s with p a, f a = ∏ a ∈ s, if p a then f a else 1 :=\n  calc\n    ∏ a ∈ s with p a, f a = ∏ a ∈ s with p a, if p a then f a else 1 :=\n      prod_congr rfl fun a h => by rw [if_pos]; simpa using (mem_filter.1 h).2\n    _ = ∏ a ∈ s, if p a then f a else 1 := by\n      { refine prod_subset (filter_subset _ s) fun x hs h => ?_\n        rw [mem_filter, not_and] at h\n        exact if_neg (by simpa using h hs) }\n\n"}
{"name":"Finset.sum_filter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝¹ : AddCommMonoid β\np : α → Prop\ninst✝ : DecidablePred p\nf : α → β\n⊢ Eq ((Finset.filter (fun a => p a) s).sum fun a => f a) (s.sum fun a => ite (p a) (f a) 0)","decl":"@[to_additive]\ntheorem prod_filter (p : α → Prop) [DecidablePred p] (f : α → β) :\n    ∏ a ∈ s with p a, f a = ∏ a ∈ s, if p a then f a else 1 :=\n  calc\n    ∏ a ∈ s with p a, f a = ∏ a ∈ s with p a, if p a then f a else 1 :=\n      prod_congr rfl fun a h => by rw [if_pos]; simpa using (mem_filter.1 h).2\n    _ = ∏ a ∈ s, if p a then f a else 1 := by\n      { refine prod_subset (filter_subset _ s) fun x hs h => ?_\n        rw [mem_filter, not_and] at h\n        exact if_neg (by simpa using h hs) }\n\n"}
{"name":"Finset.sum_eq_single_of_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → β\na : α\nh : Membership.mem s a\nh₀ : ∀ (b : α), Membership.mem s b → Ne b a → Eq (f b) 0\n⊢ Eq (s.sum fun x => f x) (f a)","decl":"@[to_additive]\ntheorem prod_eq_single_of_mem {s : Finset α} {f : α → β} (a : α) (h : a ∈ s)\n    (h₀ : ∀ b ∈ s, b ≠ a → f b = 1) : ∏ x ∈ s, f x = f a := by\n  haveI := Classical.decEq α\n  calc\n    ∏ x ∈ s, f x = ∏ x ∈ {a}, f x := by\n      { refine (prod_subset ?_ ?_).symm\n        · intro _ H\n          rwa [mem_singleton.1 H]\n        · simpa only [mem_singleton] }\n    _ = f a := prod_singleton _ _\n\n"}
{"name":"Finset.prod_eq_single_of_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nf : α → β\na : α\nh : Membership.mem s a\nh₀ : ∀ (b : α), Membership.mem s b → Ne b a → Eq (f b) 1\n⊢ Eq (s.prod fun x => f x) (f a)","decl":"@[to_additive]\ntheorem prod_eq_single_of_mem {s : Finset α} {f : α → β} (a : α) (h : a ∈ s)\n    (h₀ : ∀ b ∈ s, b ≠ a → f b = 1) : ∏ x ∈ s, f x = f a := by\n  haveI := Classical.decEq α\n  calc\n    ∏ x ∈ s, f x = ∏ x ∈ {a}, f x := by\n      { refine (prod_subset ?_ ?_).symm\n        · intro _ H\n          rwa [mem_singleton.1 H]\n        · simpa only [mem_singleton] }\n    _ = f a := prod_singleton _ _\n\n"}
{"name":"Finset.prod_eq_single","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nf : α → β\na : α\nh₀ : ∀ (b : α), Membership.mem s b → Ne b a → Eq (f b) 1\nh₁ : Not (Membership.mem s a) → Eq (f a) 1\n⊢ Eq (s.prod fun x => f x) (f a)","decl":"@[to_additive]\ntheorem prod_eq_single {s : Finset α} {f : α → β} (a : α) (h₀ : ∀ b ∈ s, b ≠ a → f b = 1)\n    (h₁ : a ∉ s → f a = 1) : ∏ x ∈ s, f x = f a :=\n  haveI := Classical.decEq α\n  by_cases (prod_eq_single_of_mem a · h₀) fun this =>\n    (prod_congr rfl fun b hb => h₀ b hb <| by rintro rfl; exact this hb).trans <|\n      prod_const_one.trans (h₁ this).symm\n\n"}
{"name":"Finset.sum_eq_single","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → β\na : α\nh₀ : ∀ (b : α), Membership.mem s b → Ne b a → Eq (f b) 0\nh₁ : Not (Membership.mem s a) → Eq (f a) 0\n⊢ Eq (s.sum fun x => f x) (f a)","decl":"@[to_additive]\ntheorem prod_eq_single {s : Finset α} {f : α → β} (a : α) (h₀ : ∀ b ∈ s, b ≠ a → f b = 1)\n    (h₁ : a ∉ s → f a = 1) : ∏ x ∈ s, f x = f a :=\n  haveI := Classical.decEq α\n  by_cases (prod_eq_single_of_mem a · h₀) fun this =>\n    (prod_congr rfl fun b hb => h₀ b hb <| by rintro rfl; exact this hb).trans <|\n      prod_const_one.trans (h₁ this).symm\n\n"}
{"name":"Finset.sum_union_eq_left","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\nhs : ∀ (a : α), Membership.mem s₂ a → Not (Membership.mem s₁ a) → Eq (f a) 0\n⊢ Eq ((Union.union s₁ s₂).sum fun a => f a) (s₁.sum fun a => f a)","decl":"@[to_additive]\nlemma prod_union_eq_left [DecidableEq α] (hs : ∀ a ∈ s₂, a ∉ s₁ → f a = 1) :\n    ∏ a ∈ s₁ ∪ s₂, f a = ∏ a ∈ s₁, f a :=\n  Eq.symm <|\n    prod_subset subset_union_left fun _a ha ha' ↦ hs _ ((mem_union.1 ha).resolve_left ha') ha'\n\n"}
{"name":"Finset.prod_union_eq_left","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\nhs : ∀ (a : α), Membership.mem s₂ a → Not (Membership.mem s₁ a) → Eq (f a) 1\n⊢ Eq ((Union.union s₁ s₂).prod fun a => f a) (s₁.prod fun a => f a)","decl":"@[to_additive]\nlemma prod_union_eq_left [DecidableEq α] (hs : ∀ a ∈ s₂, a ∉ s₁ → f a = 1) :\n    ∏ a ∈ s₁ ∪ s₂, f a = ∏ a ∈ s₁, f a :=\n  Eq.symm <|\n    prod_subset subset_union_left fun _a ha ha' ↦ hs _ ((mem_union.1 ha).resolve_left ha') ha'\n\n"}
{"name":"Finset.sum_union_eq_right","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\nhs : ∀ (a : α), Membership.mem s₁ a → Not (Membership.mem s₂ a) → Eq (f a) 0\n⊢ Eq ((Union.union s₁ s₂).sum fun a => f a) (s₂.sum fun a => f a)","decl":"@[to_additive]\nlemma prod_union_eq_right [DecidableEq α] (hs : ∀ a ∈ s₁, a ∉ s₂ → f a = 1) :\n    ∏ a ∈ s₁ ∪ s₂, f a = ∏ a ∈ s₂, f a := by rw [union_comm, prod_union_eq_left hs]\n\n"}
{"name":"Finset.prod_union_eq_right","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\nhs : ∀ (a : α), Membership.mem s₁ a → Not (Membership.mem s₂ a) → Eq (f a) 1\n⊢ Eq ((Union.union s₁ s₂).prod fun a => f a) (s₂.prod fun a => f a)","decl":"@[to_additive]\nlemma prod_union_eq_right [DecidableEq α] (hs : ∀ a ∈ s₁, a ∉ s₂ → f a = 1) :\n    ∏ a ∈ s₁ ∪ s₂, f a = ∏ a ∈ s₂, f a := by rw [union_comm, prod_union_eq_left hs]\n\n"}
{"name":"Finset.prod_eq_mul_of_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nf : α → β\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\nhn : Ne a b\nh₀ : ∀ (c : α), Membership.mem s c → And (Ne c a) (Ne c b) → Eq (f c) 1\n⊢ Eq (s.prod fun x => f x) (HMul.hMul (f a) (f b))","decl":"@[to_additive]\ntheorem prod_eq_mul_of_mem {s : Finset α} {f : α → β} (a b : α) (ha : a ∈ s) (hb : b ∈ s)\n    (hn : a ≠ b) (h₀ : ∀ c ∈ s, c ≠ a ∧ c ≠ b → f c = 1) : ∏ x ∈ s, f x = f a * f b := by\n  haveI := Classical.decEq α; let s' := ({a, b} : Finset α)\n  have hu : s' ⊆ s := by\n    refine insert_subset_iff.mpr ?_\n    apply And.intro ha\n    apply singleton_subset_iff.mpr hb\n  have hf : ∀ c ∈ s, c ∉ s' → f c = 1 := by\n    intro c hc hcs\n    apply h₀ c hc\n    apply not_or.mp\n    intro hab\n    apply hcs\n    rw [mem_insert, mem_singleton]\n    exact hab\n  rw [← prod_subset hu hf]\n  exact Finset.prod_pair hn\n\n"}
{"name":"Finset.sum_eq_add_of_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → β\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\nhn : Ne a b\nh₀ : ∀ (c : α), Membership.mem s c → And (Ne c a) (Ne c b) → Eq (f c) 0\n⊢ Eq (s.sum fun x => f x) (HAdd.hAdd (f a) (f b))","decl":"@[to_additive]\ntheorem prod_eq_mul_of_mem {s : Finset α} {f : α → β} (a b : α) (ha : a ∈ s) (hb : b ∈ s)\n    (hn : a ≠ b) (h₀ : ∀ c ∈ s, c ≠ a ∧ c ≠ b → f c = 1) : ∏ x ∈ s, f x = f a * f b := by\n  haveI := Classical.decEq α; let s' := ({a, b} : Finset α)\n  have hu : s' ⊆ s := by\n    refine insert_subset_iff.mpr ?_\n    apply And.intro ha\n    apply singleton_subset_iff.mpr hb\n  have hf : ∀ c ∈ s, c ∉ s' → f c = 1 := by\n    intro c hc hcs\n    apply h₀ c hc\n    apply not_or.mp\n    intro hab\n    apply hcs\n    rw [mem_insert, mem_singleton]\n    exact hab\n  rw [← prod_subset hu hf]\n  exact Finset.prod_pair hn\n\n"}
{"name":"Finset.prod_eq_mul","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nf : α → β\na b : α\nhn : Ne a b\nh₀ : ∀ (c : α), Membership.mem s c → And (Ne c a) (Ne c b) → Eq (f c) 1\nha : Not (Membership.mem s a) → Eq (f a) 1\nhb : Not (Membership.mem s b) → Eq (f b) 1\n⊢ Eq (s.prod fun x => f x) (HMul.hMul (f a) (f b))","decl":"@[to_additive]\ntheorem prod_eq_mul {s : Finset α} {f : α → β} (a b : α) (hn : a ≠ b)\n    (h₀ : ∀ c ∈ s, c ≠ a ∧ c ≠ b → f c = 1) (ha : a ∉ s → f a = 1) (hb : b ∉ s → f b = 1) :\n    ∏ x ∈ s, f x = f a * f b := by\n  haveI := Classical.decEq α; by_cases h₁ : a ∈ s <;> by_cases h₂ : b ∈ s\n  · exact prod_eq_mul_of_mem a b h₁ h₂ hn h₀\n  · rw [hb h₂, mul_one]\n    apply prod_eq_single_of_mem a h₁\n    exact fun c hc hca => h₀ c hc ⟨hca, ne_of_mem_of_not_mem hc h₂⟩\n  · rw [ha h₁, one_mul]\n    apply prod_eq_single_of_mem b h₂\n    exact fun c hc hcb => h₀ c hc ⟨ne_of_mem_of_not_mem hc h₁, hcb⟩\n  · rw [ha h₁, hb h₂, mul_one]\n    exact\n      _root_.trans\n        (prod_congr rfl fun c hc =>\n          h₀ c hc ⟨ne_of_mem_of_not_mem hc h₁, ne_of_mem_of_not_mem hc h₂⟩)\n        prod_const_one\n\n"}
{"name":"Finset.sum_eq_add","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → β\na b : α\nhn : Ne a b\nh₀ : ∀ (c : α), Membership.mem s c → And (Ne c a) (Ne c b) → Eq (f c) 0\nha : Not (Membership.mem s a) → Eq (f a) 0\nhb : Not (Membership.mem s b) → Eq (f b) 0\n⊢ Eq (s.sum fun x => f x) (HAdd.hAdd (f a) (f b))","decl":"@[to_additive]\ntheorem prod_eq_mul {s : Finset α} {f : α → β} (a b : α) (hn : a ≠ b)\n    (h₀ : ∀ c ∈ s, c ≠ a ∧ c ≠ b → f c = 1) (ha : a ∉ s → f a = 1) (hb : b ∉ s → f b = 1) :\n    ∏ x ∈ s, f x = f a * f b := by\n  haveI := Classical.decEq α; by_cases h₁ : a ∈ s <;> by_cases h₂ : b ∈ s\n  · exact prod_eq_mul_of_mem a b h₁ h₂ hn h₀\n  · rw [hb h₂, mul_one]\n    apply prod_eq_single_of_mem a h₁\n    exact fun c hc hca => h₀ c hc ⟨hca, ne_of_mem_of_not_mem hc h₂⟩\n  · rw [ha h₁, one_mul]\n    apply prod_eq_single_of_mem b h₂\n    exact fun c hc hcb => h₀ c hc ⟨ne_of_mem_of_not_mem hc h₁, hcb⟩\n  · rw [ha h₁, hb h₂, mul_one]\n    exact\n      _root_.trans\n        (prod_congr rfl fun c hc =>\n          h₀ c hc ⟨ne_of_mem_of_not_mem hc h₁, ne_of_mem_of_not_mem hc h₂⟩)\n        prod_const_one\n\n"}
{"name":"Finset.prod_subtype_eq_prod_filter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝¹ : CommMonoid β\nf : α → β\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq ((Finset.subtype p s).prod fun x => f ↑x) ((Finset.filter (fun x => p x) s).prod fun x => f x)","decl":"/-- A product over `s.subtype p` equals one over `{x ∈ s | p x}`. -/\n@[to_additive (attr := simp)\n\"A sum over `s.subtype p` equals one over `{x ∈ s | p x}`.\"]\ntheorem prod_subtype_eq_prod_filter (f : α → β) {p : α → Prop} [DecidablePred p] :\n    ∏ x ∈ s.subtype p, f x = ∏ x ∈ s with p x, f x := by\n  have := prod_map (s.subtype p) (Function.Embedding.subtype _) f\n  simp_all\n\n"}
{"name":"Finset.sum_subtype_eq_sum_filter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝¹ : AddCommMonoid β\nf : α → β\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq ((Finset.subtype p s).sum fun x => f ↑x) ((Finset.filter (fun x => p x) s).sum fun x => f x)","decl":"/-- A product over `s.subtype p` equals one over `{x ∈ s | p x}`. -/\n@[to_additive (attr := simp)\n\"A sum over `s.subtype p` equals one over `{x ∈ s | p x}`.\"]\ntheorem prod_subtype_eq_prod_filter (f : α → β) {p : α → Prop} [DecidablePred p] :\n    ∏ x ∈ s.subtype p, f x = ∏ x ∈ s with p x, f x := by\n  have := prod_map (s.subtype p) (Function.Embedding.subtype _) f\n  simp_all\n\n"}
{"name":"Finset.sum_subtype_of_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝¹ : AddCommMonoid β\nf : α → β\np : α → Prop\ninst✝ : DecidablePred p\nh : ∀ (x : α), Membership.mem s x → p x\n⊢ Eq ((Finset.subtype p s).sum fun x => f ↑x) (s.sum fun x => f x)","decl":"/-- If all elements of a `Finset` satisfy the predicate `p`, a product\nover `s.subtype p` equals that product over `s`. -/\n@[to_additive \"If all elements of a `Finset` satisfy the predicate `p`, a sum\nover `s.subtype p` equals that sum over `s`.\"]\ntheorem prod_subtype_of_mem (f : α → β) {p : α → Prop} [DecidablePred p] (h : ∀ x ∈ s, p x) :\n    ∏ x ∈ s.subtype p, f x = ∏ x ∈ s, f x := by\n  rw [prod_subtype_eq_prod_filter, filter_true_of_mem]\n  simpa using h\n\n"}
{"name":"Finset.prod_subtype_of_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝¹ : CommMonoid β\nf : α → β\np : α → Prop\ninst✝ : DecidablePred p\nh : ∀ (x : α), Membership.mem s x → p x\n⊢ Eq ((Finset.subtype p s).prod fun x => f ↑x) (s.prod fun x => f x)","decl":"/-- If all elements of a `Finset` satisfy the predicate `p`, a product\nover `s.subtype p` equals that product over `s`. -/\n@[to_additive \"If all elements of a `Finset` satisfy the predicate `p`, a sum\nover `s.subtype p` equals that sum over `s`.\"]\ntheorem prod_subtype_of_mem (f : α → β) {p : α → Prop} [DecidablePred p] (h : ∀ x ∈ s, p x) :\n    ∏ x ∈ s.subtype p, f x = ∏ x ∈ s, f x := by\n  rw [prod_subtype_eq_prod_filter, filter_true_of_mem]\n  simpa using h\n\n"}
{"name":"Finset.sum_subtype_map_embedding","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\np : α → Prop\ns : Finset (Subtype fun x => p x)\nf : (Subtype fun x => p x) → β\ng : α → β\nh : ∀ (x : Subtype fun x => p x), Membership.mem s x → Eq (g ↑x) (f x)\n⊢ Eq ((Finset.map (Function.Embedding.subtype fun x => p x) s).sum fun x => g x) (s.sum fun x => f x)","decl":"/-- A product of a function over a `Finset` in a subtype equals a\nproduct in the main type of a function that agrees with the first\nfunction on that `Finset`. -/\n@[to_additive \"A sum of a function over a `Finset` in a subtype equals a\nsum in the main type of a function that agrees with the first\nfunction on that `Finset`.\"]\ntheorem prod_subtype_map_embedding {p : α → Prop} {s : Finset { x // p x }} {f : { x // p x } → β}\n    {g : α → β} (h : ∀ x : { x // p x }, x ∈ s → g x = f x) :\n    (∏ x ∈ s.map (Function.Embedding.subtype _), g x) = ∏ x ∈ s, f x := by\n  rw [Finset.prod_map]\n  exact Finset.prod_congr rfl h\n\n"}
{"name":"Finset.prod_subtype_map_embedding","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\np : α → Prop\ns : Finset (Subtype fun x => p x)\nf : (Subtype fun x => p x) → β\ng : α → β\nh : ∀ (x : Subtype fun x => p x), Membership.mem s x → Eq (g ↑x) (f x)\n⊢ Eq ((Finset.map (Function.Embedding.subtype fun x => p x) s).prod fun x => g x) (s.prod fun x => f x)","decl":"/-- A product of a function over a `Finset` in a subtype equals a\nproduct in the main type of a function that agrees with the first\nfunction on that `Finset`. -/\n@[to_additive \"A sum of a function over a `Finset` in a subtype equals a\nsum in the main type of a function that agrees with the first\nfunction on that `Finset`.\"]\ntheorem prod_subtype_map_embedding {p : α → Prop} {s : Finset { x // p x }} {f : { x // p x } → β}\n    {g : α → β} (h : ∀ x : { x // p x }, x ∈ s → g x = f x) :\n    (∏ x ∈ s.map (Function.Embedding.subtype _), g x) = ∏ x ∈ s, f x := by\n  rw [Finset.prod_map]\n  exact Finset.prod_congr rfl h\n\n"}
{"name":"Finset.prod_coe_sort","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : CommMonoid β\n⊢ Eq (Finset.univ.prod fun i => f ↑i) (s.prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_coe_sort : ∏ i : s, f i = ∏ i ∈ s, f i := prod_attach _ _\n\n"}
{"name":"Finset.sum_coe_sort","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : AddCommMonoid β\n⊢ Eq (Finset.univ.sum fun i => f ↑i) (s.sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_coe_sort : ∏ i : s, f i = ∏ i ∈ s, f i := prod_attach _ _\n\n"}
{"name":"Finset.sum_finset_coe","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\nf : α → β\ns : Finset α\n⊢ Eq (Finset.univ.sum fun i => f ↑i) (s.sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_finset_coe (f : α → β) (s : Finset α) : (∏ i : (s : Set α), f i) = ∏ i ∈ s, f i :=\n  prod_coe_sort s f\n\n"}
{"name":"Finset.prod_finset_coe","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\nf : α → β\ns : Finset α\n⊢ Eq (Finset.univ.prod fun i => f ↑i) (s.prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_finset_coe (f : α → β) (s : Finset α) : (∏ i : (s : Set α), f i) = ∏ i ∈ s, f i :=\n  prod_coe_sort s f\n\n"}
{"name":"Finset.sum_subtype","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\np : α → Prop\nF : Fintype (Subtype p)\ns : Finset α\nh : ∀ (x : α), Iff (Membership.mem s x) (p x)\nf : α → β\n⊢ Eq (s.sum fun a => f a) (Finset.univ.sum fun a => f ↑a)","decl":"@[to_additive]\ntheorem prod_subtype {p : α → Prop} {F : Fintype (Subtype p)} (s : Finset α) (h : ∀ x, x ∈ s ↔ p x)\n    (f : α → β) : ∏ a ∈ s, f a = ∏ a : Subtype p, f a := by\n  have : (· ∈ s) = p := Set.ext h\n  subst p\n  rw [← prod_coe_sort]\n  congr!\n\n"}
{"name":"Finset.prod_subtype","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\np : α → Prop\nF : Fintype (Subtype p)\ns : Finset α\nh : ∀ (x : α), Iff (Membership.mem s x) (p x)\nf : α → β\n⊢ Eq (s.prod fun a => f a) (Finset.univ.prod fun a => f ↑a)","decl":"@[to_additive]\ntheorem prod_subtype {p : α → Prop} {F : Fintype (Subtype p)} (s : Finset α) (h : ∀ x, x ∈ s ↔ p x)\n    (f : α → β) : ∏ a ∈ s, f a = ∏ a : Subtype p, f a := by\n  have : (· ∈ s) = p := Set.ext h\n  subst p\n  rw [← prod_coe_sort]\n  congr!\n\n"}
{"name":"Finset.prod_preimage'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nκ : Type u_2\nβ : Type u_4\ninst✝¹ : CommMonoid β\nf : ι → κ\ninst✝ : DecidablePred fun x => Membership.mem (Set.range f) x\ns : Finset κ\nhf : Set.InjOn f (Set.preimage f ↑s)\ng : κ → β\n⊢ Eq ((s.preimage f hf).prod fun x => g (f x)) ((Finset.filter (fun x => Membership.mem (Set.range f) x) s).prod fun x => g x)","decl":"@[to_additive]\nlemma prod_preimage' (f : ι → κ) [DecidablePred (· ∈ Set.range f)] (s : Finset κ) (hf) (g : κ → β) :\n    ∏ x ∈ s.preimage f hf, g (f x) = ∏ x ∈ s with x ∈ Set.range f, g x := by\n  classical\n  calc\n    ∏ x ∈ preimage s f hf, g (f x) = ∏ x ∈ image f (preimage s f hf), g x :=\n      Eq.symm <| prod_image <| by simpa only [mem_preimage, Set.InjOn] using hf\n    _ = ∏ x ∈ s with x ∈ Set.range f, g x := by rw [image_preimage]\n\n"}
{"name":"Finset.sum_preimage'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nκ : Type u_2\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\nf : ι → κ\ninst✝ : DecidablePred fun x => Membership.mem (Set.range f) x\ns : Finset κ\nhf : Set.InjOn f (Set.preimage f ↑s)\ng : κ → β\n⊢ Eq ((s.preimage f hf).sum fun x => g (f x)) ((Finset.filter (fun x => Membership.mem (Set.range f) x) s).sum fun x => g x)","decl":"@[to_additive]\nlemma prod_preimage' (f : ι → κ) [DecidablePred (· ∈ Set.range f)] (s : Finset κ) (hf) (g : κ → β) :\n    ∏ x ∈ s.preimage f hf, g (f x) = ∏ x ∈ s with x ∈ Set.range f, g x := by\n  classical\n  calc\n    ∏ x ∈ preimage s f hf, g (f x) = ∏ x ∈ image f (preimage s f hf), g x :=\n      Eq.symm <| prod_image <| by simpa only [mem_preimage, Set.InjOn] using hf\n    _ = ∏ x ∈ s with x ∈ Set.range f, g x := by rw [image_preimage]\n\n"}
{"name":"Finset.sum_preimage","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nκ : Type u_2\nβ : Type u_4\ninst✝ : AddCommMonoid β\nf : ι → κ\ns : Finset κ\nhf : Set.InjOn f (Set.preimage f ↑s)\ng : κ → β\nhg : ∀ (x : κ), Membership.mem s x → Not (Membership.mem (Set.range f) x) → Eq (g x) 0\n⊢ Eq ((s.preimage f hf).sum fun x => g (f x)) (s.sum fun x => g x)","decl":"@[to_additive]\nlemma prod_preimage (f : ι → κ) (s : Finset κ) (hf) (g : κ → β)\n    (hg : ∀ x ∈ s, x ∉ Set.range f → g x = 1) :\n    ∏ x ∈ s.preimage f hf, g (f x) = ∏ x ∈ s, g x := by\n  classical rw [prod_preimage', prod_filter_of_ne]; exact fun x hx ↦ Not.imp_symm (hg x hx)\n\n"}
{"name":"Finset.prod_preimage","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nκ : Type u_2\nβ : Type u_4\ninst✝ : CommMonoid β\nf : ι → κ\ns : Finset κ\nhf : Set.InjOn f (Set.preimage f ↑s)\ng : κ → β\nhg : ∀ (x : κ), Membership.mem s x → Not (Membership.mem (Set.range f) x) → Eq (g x) 1\n⊢ Eq ((s.preimage f hf).prod fun x => g (f x)) (s.prod fun x => g x)","decl":"@[to_additive]\nlemma prod_preimage (f : ι → κ) (s : Finset κ) (hf) (g : κ → β)\n    (hg : ∀ x ∈ s, x ∉ Set.range f → g x = 1) :\n    ∏ x ∈ s.preimage f hf, g (f x) = ∏ x ∈ s, g x := by\n  classical rw [prod_preimage', prod_filter_of_ne]; exact fun x hx ↦ Not.imp_symm (hg x hx)\n\n"}
{"name":"Finset.prod_preimage_of_bij","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nκ : Type u_2\nβ : Type u_4\ninst✝ : CommMonoid β\nf : ι → κ\ns : Finset κ\nhf : Set.BijOn f (Set.preimage f ↑s) ↑s\ng : κ → β\n⊢ Eq ((s.preimage f ⋯).prod fun x => g (f x)) (s.prod fun x => g x)","decl":"@[to_additive]\nlemma prod_preimage_of_bij (f : ι → κ) (s : Finset κ) (hf : Set.BijOn f (f ⁻¹' ↑s) ↑s) (g : κ → β) :\n    ∏ x ∈ s.preimage f hf.injOn, g (f x) = ∏ x ∈ s, g x :=\n  prod_preimage _ _ hf.injOn g fun _ hs h_f ↦ (h_f <| hf.subset_range hs).elim\n\n"}
{"name":"Finset.sum_preimage_of_bij","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nκ : Type u_2\nβ : Type u_4\ninst✝ : AddCommMonoid β\nf : ι → κ\ns : Finset κ\nhf : Set.BijOn f (Set.preimage f ↑s) ↑s\ng : κ → β\n⊢ Eq ((s.preimage f ⋯).sum fun x => g (f x)) (s.sum fun x => g x)","decl":"@[to_additive]\nlemma prod_preimage_of_bij (f : ι → κ) (s : Finset κ) (hf : Set.BijOn f (f ⁻¹' ↑s) ↑s) (g : κ → β) :\n    ∏ x ∈ s.preimage f hf.injOn, g (f x) = ∏ x ∈ s, g x :=\n  prod_preimage _ _ hf.injOn g fun _ hs h_f ↦ (h_f <| hf.subset_range hs).elim\n\n"}
{"name":"Finset.sum_set_coe","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ninst✝¹ : AddCommMonoid β\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Eq (Finset.univ.sum fun i => f ↑i) (s.toFinset.sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_set_coe (s : Set α) [Fintype s] : (∏ i : s, f i) = ∏ i ∈ s.toFinset, f i :=\n(Finset.prod_subtype s.toFinset (fun _ ↦ Set.mem_toFinset) f).symm\n\n"}
{"name":"Finset.prod_set_coe","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ninst✝¹ : CommMonoid β\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Eq (Finset.univ.prod fun i => f ↑i) (s.toFinset.prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_set_coe (s : Set α) [Fintype s] : (∏ i : s, f i) = ∏ i ∈ s.toFinset, f i :=\n(Finset.prod_subtype s.toFinset (fun _ ↦ Set.mem_toFinset) f).symm\n\n"}
{"name":"Finset.prod_congr_set","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\ninst✝² : CommMonoid α\nβ : Type u_7\ninst✝¹ : Fintype β\ns : Set β\ninst✝ : DecidablePred fun x => Membership.mem s x\nf : β → α\ng : ↑s → α\nw : ∀ (x : β) (h : Membership.mem s x), Eq (f x) (g ⟨x, h⟩)\nw' : ∀ (x : β), Not (Membership.mem s x) → Eq (f x) 1\n⊢ Eq (Finset.univ.prod f) (Finset.univ.prod g)","decl":"/-- The product of a function `g` defined only on a set `s` is equal to\nthe product of a function `f` defined everywhere,\nas long as `f` and `g` agree on `s`, and `f = 1` off `s`. -/\n@[to_additive \"The sum of a function `g` defined only on a set `s` is equal to\nthe sum of a function `f` defined everywhere,\nas long as `f` and `g` agree on `s`, and `f = 0` off `s`.\"]\ntheorem prod_congr_set {α : Type*} [CommMonoid α] {β : Type*} [Fintype β] (s : Set β)\n    [DecidablePred (· ∈ s)] (f : β → α) (g : s → α) (w : ∀ (x : β) (h : x ∈ s), f x = g ⟨x, h⟩)\n    (w' : ∀ x : β, x ∉ s → f x = 1) : Finset.univ.prod f = Finset.univ.prod g := by\n  rw [← @Finset.prod_subset _ _ s.toFinset Finset.univ f _ (by simp)]\n  · rw [Finset.prod_subtype]\n    · apply Finset.prod_congr rfl\n      exact fun ⟨x, h⟩ _ => w x h\n    · simp\n  · rintro x _ h\n    exact w' x (by simpa using h)\n\n"}
{"name":"Finset.sum_congr_set","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\ninst✝² : AddCommMonoid α\nβ : Type u_7\ninst✝¹ : Fintype β\ns : Set β\ninst✝ : DecidablePred fun x => Membership.mem s x\nf : β → α\ng : ↑s → α\nw : ∀ (x : β) (h : Membership.mem s x), Eq (f x) (g ⟨x, h⟩)\nw' : ∀ (x : β), Not (Membership.mem s x) → Eq (f x) 0\n⊢ Eq (Finset.univ.sum f) (Finset.univ.sum g)","decl":"/-- The product of a function `g` defined only on a set `s` is equal to\nthe product of a function `f` defined everywhere,\nas long as `f` and `g` agree on `s`, and `f = 1` off `s`. -/\n@[to_additive \"The sum of a function `g` defined only on a set `s` is equal to\nthe sum of a function `f` defined everywhere,\nas long as `f` and `g` agree on `s`, and `f = 0` off `s`.\"]\ntheorem prod_congr_set {α : Type*} [CommMonoid α] {β : Type*} [Fintype β] (s : Set β)\n    [DecidablePred (· ∈ s)] (f : β → α) (g : s → α) (w : ∀ (x : β) (h : x ∈ s), f x = g ⟨x, h⟩)\n    (w' : ∀ x : β, x ∉ s → f x = 1) : Finset.univ.prod f = Finset.univ.prod g := by\n  rw [← @Finset.prod_subset _ _ s.toFinset Finset.univ f _ (by simp)]\n  · rw [Finset.prod_subtype]\n    · apply Finset.prod_congr rfl\n      exact fun ⟨x, h⟩ _ => w x h\n    · simp\n  · rintro x _ h\n    exact w' x (by simpa using h)\n\n"}
{"name":"Finset.prod_apply_dite","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝¹ : CommMonoid β\ns : Finset α\np : α → Prop\nhp : DecidablePred p\ninst✝ : DecidablePred fun x => Not (p x)\nf : (x : α) → p x → γ\ng : (x : α) → Not (p x) → γ\nh : γ → β\n⊢ Eq (s.prod fun x => h (dite (p x) (fun hx => f x hx) fun hx => g x hx)) (HMul.hMul (Finset.univ.prod fun x => h (f ↑x ⋯)) (Finset.univ.prod fun x => h (g ↑x ⋯)))","decl":"@[to_additive]\ntheorem prod_apply_dite {s : Finset α} {p : α → Prop} {hp : DecidablePred p}\n    [DecidablePred fun x => ¬p x] (f : ∀ x : α, p x → γ) (g : ∀ x : α, ¬p x → γ) (h : γ → β) :\n    (∏ x ∈ s, h (if hx : p x then f x hx else g x hx)) =\n      (∏ x : {x ∈ s | p x}, h (f x.1 <| by simpa using (mem_filter.mp x.2).2)) *\n        ∏ x : {x ∈ s | ¬p x}, h (g x.1 <| by simpa using (mem_filter.mp x.2).2) :=\n  calc\n    (∏ x ∈ s, h (if hx : p x then f x hx else g x hx)) =\n        (∏ x ∈ s with p x, h (if hx : p x then f x hx else g x hx)) *\n          ∏ x ∈ s with ¬p x, h (if hx : p x then f x hx else g x hx) :=\n      (prod_filter_mul_prod_filter_not s p _).symm\n    _ = (∏ x : {x ∈ s | p x}, h (if hx : p x.1 then f x.1 hx else g x.1 hx)) *\n          ∏ x : {x ∈ s | ¬p x}, h (if hx : p x.1 then f x.1 hx else g x.1 hx) :=\n      congr_arg₂ _ (prod_attach _ _).symm (prod_attach _ _).symm\n    _ = (∏ x : {x ∈ s | p x}, h (f x.1 <| by simpa using (mem_filter.mp x.2).2)) *\n          ∏ x : {x ∈ s | ¬p x}, h (g x.1 <| by simpa using (mem_filter.mp x.2).2) :=\n      congr_arg₂ _ (prod_congr rfl fun x _hx ↦\n        congr_arg h (dif_pos <| by simpa using (mem_filter.mp x.2).2))\n        (prod_congr rfl fun x _hx => congr_arg h (dif_neg <| by simpa using (mem_filter.mp x.2).2))\n\n"}
{"name":"Finset.sum_apply_dite","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝¹ : AddCommMonoid β\ns : Finset α\np : α → Prop\nhp : DecidablePred p\ninst✝ : DecidablePred fun x => Not (p x)\nf : (x : α) → p x → γ\ng : (x : α) → Not (p x) → γ\nh : γ → β\n⊢ Eq (s.sum fun x => h (dite (p x) (fun hx => f x hx) fun hx => g x hx)) (HAdd.hAdd (Finset.univ.sum fun x => h (f ↑x ⋯)) (Finset.univ.sum fun x => h (g ↑x ⋯)))","decl":"@[to_additive]\ntheorem prod_apply_dite {s : Finset α} {p : α → Prop} {hp : DecidablePred p}\n    [DecidablePred fun x => ¬p x] (f : ∀ x : α, p x → γ) (g : ∀ x : α, ¬p x → γ) (h : γ → β) :\n    (∏ x ∈ s, h (if hx : p x then f x hx else g x hx)) =\n      (∏ x : {x ∈ s | p x}, h (f x.1 <| by simpa using (mem_filter.mp x.2).2)) *\n        ∏ x : {x ∈ s | ¬p x}, h (g x.1 <| by simpa using (mem_filter.mp x.2).2) :=\n  calc\n    (∏ x ∈ s, h (if hx : p x then f x hx else g x hx)) =\n        (∏ x ∈ s with p x, h (if hx : p x then f x hx else g x hx)) *\n          ∏ x ∈ s with ¬p x, h (if hx : p x then f x hx else g x hx) :=\n      (prod_filter_mul_prod_filter_not s p _).symm\n    _ = (∏ x : {x ∈ s | p x}, h (if hx : p x.1 then f x.1 hx else g x.1 hx)) *\n          ∏ x : {x ∈ s | ¬p x}, h (if hx : p x.1 then f x.1 hx else g x.1 hx) :=\n      congr_arg₂ _ (prod_attach _ _).symm (prod_attach _ _).symm\n    _ = (∏ x : {x ∈ s | p x}, h (f x.1 <| by simpa using (mem_filter.mp x.2).2)) *\n          ∏ x : {x ∈ s | ¬p x}, h (g x.1 <| by simpa using (mem_filter.mp x.2).2) :=\n      congr_arg₂ _ (prod_congr rfl fun x _hx ↦\n        congr_arg h (dif_pos <| by simpa using (mem_filter.mp x.2).2))\n        (prod_congr rfl fun x _hx => congr_arg h (dif_neg <| by simpa using (mem_filter.mp x.2).2))\n\n"}
{"name":"Finset.sum_apply_ite","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\ns : Finset α\np : α → Prop\n_hp : DecidablePred p\nf g : α → γ\nh : γ → β\n⊢ Eq (s.sum fun x => h (ite (p x) (f x) (g x))) (HAdd.hAdd ((Finset.filter (fun x => p x) s).sum fun x => h (f x)) ((Finset.filter (fun x => Not (p x)) s).sum fun x => h (g x)))","decl":"@[to_additive]\ntheorem prod_apply_ite {s : Finset α} {p : α → Prop} {_hp : DecidablePred p} (f g : α → γ)\n    (h : γ → β) :\n    (∏ x ∈ s, h (if p x then f x else g x)) =\n      (∏ x ∈ s with p x, h (f x)) * ∏ x ∈ s with ¬p x, h (g x) :=\n  (prod_apply_dite _ _ _).trans <| congr_arg₂ _ (prod_attach _ (h ∘ f)) (prod_attach _ (h ∘ g))\n\n"}
{"name":"Finset.prod_apply_ite","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\ns : Finset α\np : α → Prop\n_hp : DecidablePred p\nf g : α → γ\nh : γ → β\n⊢ Eq (s.prod fun x => h (ite (p x) (f x) (g x))) (HMul.hMul ((Finset.filter (fun x => p x) s).prod fun x => h (f x)) ((Finset.filter (fun x => Not (p x)) s).prod fun x => h (g x)))","decl":"@[to_additive]\ntheorem prod_apply_ite {s : Finset α} {p : α → Prop} {_hp : DecidablePred p} (f g : α → γ)\n    (h : γ → β) :\n    (∏ x ∈ s, h (if p x then f x else g x)) =\n      (∏ x ∈ s with p x, h (f x)) * ∏ x ∈ s with ¬p x, h (g x) :=\n  (prod_apply_dite _ _ _).trans <| congr_arg₂ _ (prod_attach _ (h ∘ f)) (prod_attach _ (h ∘ g))\n\n"}
{"name":"Finset.sum_dite","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\np : α → Prop\nhp : DecidablePred p\nf : (x : α) → p x → β\ng : (x : α) → Not (p x) → β\n⊢ Eq (s.sum fun x => dite (p x) (fun hx => f x hx) fun hx => g x hx) (HAdd.hAdd (Finset.univ.sum fun x => f ↑x ⋯) (Finset.univ.sum fun x => g ↑x ⋯))","decl":"@[to_additive]\ntheorem prod_dite {s : Finset α} {p : α → Prop} {hp : DecidablePred p} (f : ∀ x : α, p x → β)\n    (g : ∀ x : α, ¬p x → β) :\n    ∏ x ∈ s, (if hx : p x then f x hx else g x hx) =\n      (∏ x : {x ∈ s | p x}, f x.1 (by simpa using (mem_filter.mp x.2).2)) *\n        ∏ x : {x ∈ s | ¬p x}, g x.1 (by simpa using (mem_filter.mp x.2).2) := by\n  simp [prod_apply_dite _ _ fun x => x]\n\n"}
{"name":"Finset.prod_dite","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\np : α → Prop\nhp : DecidablePred p\nf : (x : α) → p x → β\ng : (x : α) → Not (p x) → β\n⊢ Eq (s.prod fun x => dite (p x) (fun hx => f x hx) fun hx => g x hx) (HMul.hMul (Finset.univ.prod fun x => f ↑x ⋯) (Finset.univ.prod fun x => g ↑x ⋯))","decl":"@[to_additive]\ntheorem prod_dite {s : Finset α} {p : α → Prop} {hp : DecidablePred p} (f : ∀ x : α, p x → β)\n    (g : ∀ x : α, ¬p x → β) :\n    ∏ x ∈ s, (if hx : p x then f x hx else g x hx) =\n      (∏ x : {x ∈ s | p x}, f x.1 (by simpa using (mem_filter.mp x.2).2)) *\n        ∏ x : {x ∈ s | ¬p x}, g x.1 (by simpa using (mem_filter.mp x.2).2) := by\n  simp [prod_apply_dite _ _ fun x => x]\n\n"}
{"name":"Finset.sum_ite","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\np : α → Prop\nhp : DecidablePred p\nf g : α → β\n⊢ Eq (s.sum fun x => ite (p x) (f x) (g x)) (HAdd.hAdd ((Finset.filter (fun x => p x) s).sum fun x => f x) ((Finset.filter (fun x => Not (p x)) s).sum fun x => g x))","decl":"@[to_additive]\ntheorem prod_ite {s : Finset α} {p : α → Prop} {hp : DecidablePred p} (f g : α → β) :\n    ∏ x ∈ s, (if p x then f x else g x) = (∏ x ∈ s with p x, f x) * ∏ x ∈ s with ¬p x, g x := by\n  simp [prod_apply_ite _ _ fun x => x]\n\n"}
{"name":"Finset.prod_ite","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\np : α → Prop\nhp : DecidablePred p\nf g : α → β\n⊢ Eq (s.prod fun x => ite (p x) (f x) (g x)) (HMul.hMul ((Finset.filter (fun x => p x) s).prod fun x => f x) ((Finset.filter (fun x => Not (p x)) s).prod fun x => g x))","decl":"@[to_additive]\ntheorem prod_ite {s : Finset α} {p : α → Prop} {hp : DecidablePred p} (f g : α → β) :\n    ∏ x ∈ s, (if p x then f x else g x) = (∏ x ∈ s with p x, f x) * ∏ x ∈ s with ¬p x, g x := by\n  simp [prod_apply_ite _ _ fun x => x]\n\n"}
{"name":"Finset.prod_dite_of_false","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : CommMonoid β\np : α → Prop\nx✝ : DecidablePred p\nh : ∀ (i : α), Membership.mem s i → Not (p i)\nf : (i : α) → p i → β\ng : (i : α) → Not (p i) → β\n⊢ Eq (s.prod fun i => dite (p i) (fun hi => f i hi) fun hi => g i hi) (Finset.univ.prod fun i => g ↑i ⋯)","decl":"@[to_additive]\nlemma prod_dite_of_false {p : α → Prop} {_ : DecidablePred p} (h : ∀ i ∈ s, ¬ p i)\n    (f : ∀ i, p i → β) (g : ∀ i, ¬ p i → β) :\n    ∏ i ∈ s, (if hi : p i then f i hi else g i hi) = ∏ i : s, g i.1 (h _ i.2) := by\n  refine prod_bij' (fun x hx => ⟨x, hx⟩) (fun x _ ↦ x) ?_ ?_ ?_ ?_ ?_ <;> aesop\n\n"}
{"name":"Finset.sum_dite_of_false","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : AddCommMonoid β\np : α → Prop\nx✝ : DecidablePred p\nh : ∀ (i : α), Membership.mem s i → Not (p i)\nf : (i : α) → p i → β\ng : (i : α) → Not (p i) → β\n⊢ Eq (s.sum fun i => dite (p i) (fun hi => f i hi) fun hi => g i hi) (Finset.univ.sum fun i => g ↑i ⋯)","decl":"@[to_additive]\nlemma prod_dite_of_false {p : α → Prop} {_ : DecidablePred p} (h : ∀ i ∈ s, ¬ p i)\n    (f : ∀ i, p i → β) (g : ∀ i, ¬ p i → β) :\n    ∏ i ∈ s, (if hi : p i then f i hi else g i hi) = ∏ i : s, g i.1 (h _ i.2) := by\n  refine prod_bij' (fun x hx => ⟨x, hx⟩) (fun x _ ↦ x) ?_ ?_ ?_ ?_ ?_ <;> aesop\n\n"}
{"name":"Finset.sum_ite_of_false","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : AddCommMonoid β\np : α → Prop\nx✝ : DecidablePred p\nh : ∀ (x : α), Membership.mem s x → Not (p x)\nf g : α → β\n⊢ Eq (s.sum fun x => ite (p x) (f x) (g x)) (s.sum fun x => g x)","decl":"@[to_additive]\nlemma prod_ite_of_false {p : α → Prop} {_ : DecidablePred p} (h : ∀ x ∈ s, ¬p x) (f g : α → β) :\n    ∏ x ∈ s, (if p x then f x else g x) = ∏ x ∈ s, g x :=\n  (prod_dite_of_false h _ _).trans (prod_attach _ _)\n\n"}
{"name":"Finset.prod_ite_of_false","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : CommMonoid β\np : α → Prop\nx✝ : DecidablePred p\nh : ∀ (x : α), Membership.mem s x → Not (p x)\nf g : α → β\n⊢ Eq (s.prod fun x => ite (p x) (f x) (g x)) (s.prod fun x => g x)","decl":"@[to_additive]\nlemma prod_ite_of_false {p : α → Prop} {_ : DecidablePred p} (h : ∀ x ∈ s, ¬p x) (f g : α → β) :\n    ∏ x ∈ s, (if p x then f x else g x) = ∏ x ∈ s, g x :=\n  (prod_dite_of_false h _ _).trans (prod_attach _ _)\n\n"}
{"name":"Finset.sum_dite_of_true","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : AddCommMonoid β\np : α → Prop\nx✝ : DecidablePred p\nh : ∀ (i : α), Membership.mem s i → p i\nf : (i : α) → p i → β\ng : (i : α) → Not (p i) → β\n⊢ Eq (s.sum fun i => dite (p i) (fun hi => f i hi) fun hi => g i hi) (Finset.univ.sum fun i => f ↑i ⋯)","decl":"@[to_additive]\nlemma prod_dite_of_true {p : α → Prop} {_ : DecidablePred p} (h : ∀ i ∈ s, p i) (f : ∀ i, p i → β)\n    (g : ∀ i, ¬ p i → β) :\n    ∏ i ∈ s, (if hi : p i then f i hi else g i hi) = ∏ i : s, f i.1 (h _ i.2) := by\n  refine prod_bij' (fun x hx => ⟨x, hx⟩) (fun x _ ↦ x) ?_ ?_ ?_ ?_ ?_ <;> aesop\n\n"}
{"name":"Finset.prod_dite_of_true","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : CommMonoid β\np : α → Prop\nx✝ : DecidablePred p\nh : ∀ (i : α), Membership.mem s i → p i\nf : (i : α) → p i → β\ng : (i : α) → Not (p i) → β\n⊢ Eq (s.prod fun i => dite (p i) (fun hi => f i hi) fun hi => g i hi) (Finset.univ.prod fun i => f ↑i ⋯)","decl":"@[to_additive]\nlemma prod_dite_of_true {p : α → Prop} {_ : DecidablePred p} (h : ∀ i ∈ s, p i) (f : ∀ i, p i → β)\n    (g : ∀ i, ¬ p i → β) :\n    ∏ i ∈ s, (if hi : p i then f i hi else g i hi) = ∏ i : s, f i.1 (h _ i.2) := by\n  refine prod_bij' (fun x hx => ⟨x, hx⟩) (fun x _ ↦ x) ?_ ?_ ?_ ?_ ?_ <;> aesop\n\n"}
{"name":"Finset.sum_ite_of_true","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : AddCommMonoid β\np : α → Prop\nx✝ : DecidablePred p\nh : ∀ (x : α), Membership.mem s x → p x\nf g : α → β\n⊢ Eq (s.sum fun x => ite (p x) (f x) (g x)) (s.sum fun x => f x)","decl":"@[to_additive]\nlemma prod_ite_of_true {p : α → Prop} {_ : DecidablePred p} (h : ∀ x ∈ s, p x) (f g : α → β) :\n    ∏ x ∈ s, (if p x then f x else g x) = ∏ x ∈ s, f x :=\n  (prod_dite_of_true h _ _).trans (prod_attach _ _)\n\n"}
{"name":"Finset.prod_ite_of_true","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : CommMonoid β\np : α → Prop\nx✝ : DecidablePred p\nh : ∀ (x : α), Membership.mem s x → p x\nf g : α → β\n⊢ Eq (s.prod fun x => ite (p x) (f x) (g x)) (s.prod fun x => f x)","decl":"@[to_additive]\nlemma prod_ite_of_true {p : α → Prop} {_ : DecidablePred p} (h : ∀ x ∈ s, p x) (f g : α → β) :\n    ∏ x ∈ s, (if p x then f x else g x) = ∏ x ∈ s, f x :=\n  (prod_dite_of_true h _ _).trans (prod_attach _ _)\n\n"}
{"name":"Finset.sum_apply_ite_of_false","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ns : Finset α\ninst✝ : AddCommMonoid β\np : α → Prop\nhp : DecidablePred p\nf g : α → γ\nk : γ → β\nh : ∀ (x : α), Membership.mem s x → Not (p x)\n⊢ Eq (s.sum fun x => k (ite (p x) (f x) (g x))) (s.sum fun x => k (g x))","decl":"@[to_additive]\ntheorem prod_apply_ite_of_false {p : α → Prop} {hp : DecidablePred p} (f g : α → γ) (k : γ → β)\n    (h : ∀ x ∈ s, ¬p x) : (∏ x ∈ s, k (if p x then f x else g x)) = ∏ x ∈ s, k (g x) := by\n  simp_rw [apply_ite k]\n  exact prod_ite_of_false h _ _\n\n"}
{"name":"Finset.prod_apply_ite_of_false","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ns : Finset α\ninst✝ : CommMonoid β\np : α → Prop\nhp : DecidablePred p\nf g : α → γ\nk : γ → β\nh : ∀ (x : α), Membership.mem s x → Not (p x)\n⊢ Eq (s.prod fun x => k (ite (p x) (f x) (g x))) (s.prod fun x => k (g x))","decl":"@[to_additive]\ntheorem prod_apply_ite_of_false {p : α → Prop} {hp : DecidablePred p} (f g : α → γ) (k : γ → β)\n    (h : ∀ x ∈ s, ¬p x) : (∏ x ∈ s, k (if p x then f x else g x)) = ∏ x ∈ s, k (g x) := by\n  simp_rw [apply_ite k]\n  exact prod_ite_of_false h _ _\n\n"}
{"name":"Finset.sum_apply_ite_of_true","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ns : Finset α\ninst✝ : AddCommMonoid β\np : α → Prop\nhp : DecidablePred p\nf g : α → γ\nk : γ → β\nh : ∀ (x : α), Membership.mem s x → p x\n⊢ Eq (s.sum fun x => k (ite (p x) (f x) (g x))) (s.sum fun x => k (f x))","decl":"@[to_additive]\ntheorem prod_apply_ite_of_true {p : α → Prop} {hp : DecidablePred p} (f g : α → γ) (k : γ → β)\n    (h : ∀ x ∈ s, p x) : (∏ x ∈ s, k (if p x then f x else g x)) = ∏ x ∈ s, k (f x) := by\n  simp_rw [apply_ite k]\n  exact prod_ite_of_true h _ _\n\n"}
{"name":"Finset.prod_apply_ite_of_true","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ns : Finset α\ninst✝ : CommMonoid β\np : α → Prop\nhp : DecidablePred p\nf g : α → γ\nk : γ → β\nh : ∀ (x : α), Membership.mem s x → p x\n⊢ Eq (s.prod fun x => k (ite (p x) (f x) (g x))) (s.prod fun x => k (f x))","decl":"@[to_additive]\ntheorem prod_apply_ite_of_true {p : α → Prop} {hp : DecidablePred p} (f g : α → γ) (k : γ → β)\n    (h : ∀ x ∈ s, p x) : (∏ x ∈ s, k (if p x then f x else g x)) = ∏ x ∈ s, k (f x) := by\n  simp_rw [apply_ite k]\n  exact prod_ite_of_true h _ _\n\n"}
{"name":"Finset.prod_extend_by_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\n⊢ Eq (s.prod fun i => ite (Membership.mem s i) (f i) 1) (s.prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_extend_by_one [DecidableEq α] (s : Finset α) (f : α → β) :\n    ∏ i ∈ s, (if i ∈ s then f i else 1) = ∏ i ∈ s, f i :=\n  (prod_congr rfl) fun _i hi => if_pos hi\n\n"}
{"name":"Finset.sum_extend_by_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\n⊢ Eq (s.sum fun i => ite (Membership.mem s i) (f i) 0) (s.sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_extend_by_one [DecidableEq α] (s : Finset α) (f : α → β) :\n    ∏ i ∈ s, (if i ∈ s then f i else 1) = ∏ i ∈ s, f i :=\n  (prod_congr rfl) fun _i hi => if_pos hi\n\n"}
{"name":"Finset.prod_ite_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns t : Finset α\nf : α → β\n⊢ Eq (s.prod fun i => ite (Membership.mem t i) (f i) 1) ((Inter.inter s t).prod fun i => f i)","decl":"@[to_additive (attr := simp)]\ntheorem prod_ite_mem [DecidableEq α] (s t : Finset α) (f : α → β) :\n    ∏ i ∈ s, (if i ∈ t then f i else 1) = ∏ i ∈ s ∩ t, f i := by\n  rw [← Finset.prod_filter, Finset.filter_mem_eq_inter]\n\n"}
{"name":"Finset.sum_ite_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns t : Finset α\nf : α → β\n⊢ Eq (s.sum fun i => ite (Membership.mem t i) (f i) 0) ((Inter.inter s t).sum fun i => f i)","decl":"@[to_additive (attr := simp)]\ntheorem prod_ite_mem [DecidableEq α] (s t : Finset α) (f : α → β) :\n    ∏ i ∈ s, (if i ∈ t then f i else 1) = ∏ i ∈ s ∩ t, f i := by\n  rw [← Finset.prod_filter, Finset.filter_mem_eq_inter]\n\n"}
{"name":"Finset.sum_dite_eq","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nb : (x : α) → Eq a x → β\n⊢ Eq (s.sum fun x => dite (Eq a x) (fun h => b x h) fun h => 0) (ite (Membership.mem s a) (b a ⋯) 0)","decl":"@[to_additive (attr := simp)]\ntheorem prod_dite_eq [DecidableEq α] (s : Finset α) (a : α) (b : ∀ x : α, a = x → β) :\n    ∏ x ∈ s, (if h : a = x then b x h else 1) = ite (a ∈ s) (b a rfl) 1 := by\n  split_ifs with h\n  · rw [Finset.prod_eq_single a, dif_pos rfl]\n    · intros _ _ h\n      rw [dif_neg]\n      exact h.symm\n    · simp [h]\n  · rw [Finset.prod_eq_one]\n    intros\n    rw [dif_neg]\n    rintro rfl\n    contradiction\n\n"}
{"name":"Finset.prod_dite_eq","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nb : (x : α) → Eq a x → β\n⊢ Eq (s.prod fun x => dite (Eq a x) (fun h => b x h) fun h => 1) (ite (Membership.mem s a) (b a ⋯) 1)","decl":"@[to_additive (attr := simp)]\ntheorem prod_dite_eq [DecidableEq α] (s : Finset α) (a : α) (b : ∀ x : α, a = x → β) :\n    ∏ x ∈ s, (if h : a = x then b x h else 1) = ite (a ∈ s) (b a rfl) 1 := by\n  split_ifs with h\n  · rw [Finset.prod_eq_single a, dif_pos rfl]\n    · intros _ _ h\n      rw [dif_neg]\n      exact h.symm\n    · simp [h]\n  · rw [Finset.prod_eq_one]\n    intros\n    rw [dif_neg]\n    rintro rfl\n    contradiction\n\n"}
{"name":"Finset.sum_dite_eq'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nb : (x : α) → Eq x a → β\n⊢ Eq (s.sum fun x => dite (Eq x a) (fun h => b x h) fun h => 0) (ite (Membership.mem s a) (b a ⋯) 0)","decl":"@[to_additive (attr := simp)]\ntheorem prod_dite_eq' [DecidableEq α] (s : Finset α) (a : α) (b : ∀ x : α, x = a → β) :\n    ∏ x ∈ s, (if h : x = a then b x h else 1) = ite (a ∈ s) (b a rfl) 1 := by\n  split_ifs with h\n  · rw [Finset.prod_eq_single a, dif_pos rfl]\n    · intros _ _ h\n      rw [dif_neg]\n      exact h\n    · simp [h]\n  · rw [Finset.prod_eq_one]\n    intros\n    rw [dif_neg]\n    rintro rfl\n    contradiction\n\n"}
{"name":"Finset.prod_dite_eq'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nb : (x : α) → Eq x a → β\n⊢ Eq (s.prod fun x => dite (Eq x a) (fun h => b x h) fun h => 1) (ite (Membership.mem s a) (b a ⋯) 1)","decl":"@[to_additive (attr := simp)]\ntheorem prod_dite_eq' [DecidableEq α] (s : Finset α) (a : α) (b : ∀ x : α, x = a → β) :\n    ∏ x ∈ s, (if h : x = a then b x h else 1) = ite (a ∈ s) (b a rfl) 1 := by\n  split_ifs with h\n  · rw [Finset.prod_eq_single a, dif_pos rfl]\n    · intros _ _ h\n      rw [dif_neg]\n      exact h\n    · simp [h]\n  · rw [Finset.prod_eq_one]\n    intros\n    rw [dif_neg]\n    rintro rfl\n    contradiction\n\n"}
{"name":"Finset.sum_ite_eq","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nb : α → β\n⊢ Eq (s.sum fun x => ite (Eq a x) (b x) 0) (ite (Membership.mem s a) (b a) 0)","decl":"@[to_additive (attr := simp)]\ntheorem prod_ite_eq [DecidableEq α] (s : Finset α) (a : α) (b : α → β) :\n    (∏ x ∈ s, ite (a = x) (b x) 1) = ite (a ∈ s) (b a) 1 :=\n  prod_dite_eq s a fun x _ => b x\n\n"}
{"name":"Finset.prod_ite_eq","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nb : α → β\n⊢ Eq (s.prod fun x => ite (Eq a x) (b x) 1) (ite (Membership.mem s a) (b a) 1)","decl":"@[to_additive (attr := simp)]\ntheorem prod_ite_eq [DecidableEq α] (s : Finset α) (a : α) (b : α → β) :\n    (∏ x ∈ s, ite (a = x) (b x) 1) = ite (a ∈ s) (b a) 1 :=\n  prod_dite_eq s a fun x _ => b x\n\n"}
{"name":"Finset.prod_ite_eq'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nb : α → β\n⊢ Eq (s.prod fun x => ite (Eq x a) (b x) 1) (ite (Membership.mem s a) (b a) 1)","decl":"/-- A product taken over a conditional whose condition is an equality test on the index and whose\nalternative is `1` has value either the term at that index or `1`.\n\nThe difference with `Finset.prod_ite_eq` is that the arguments to `Eq` are swapped. -/\n@[to_additive (attr := simp) \"A sum taken over a conditional whose condition is an equality\ntest on the index and whose alternative is `0` has value either the term at that index or `0`.\n\nThe difference with `Finset.sum_ite_eq` is that the arguments to `Eq` are swapped.\"]\ntheorem prod_ite_eq' [DecidableEq α] (s : Finset α) (a : α) (b : α → β) :\n    (∏ x ∈ s, ite (x = a) (b x) 1) = ite (a ∈ s) (b a) 1 :=\n  prod_dite_eq' s a fun x _ => b x\n\n"}
{"name":"Finset.sum_ite_eq'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nb : α → β\n⊢ Eq (s.sum fun x => ite (Eq x a) (b x) 0) (ite (Membership.mem s a) (b a) 0)","decl":"/-- A product taken over a conditional whose condition is an equality test on the index and whose\nalternative is `1` has value either the term at that index or `1`.\n\nThe difference with `Finset.prod_ite_eq` is that the arguments to `Eq` are swapped. -/\n@[to_additive (attr := simp) \"A sum taken over a conditional whose condition is an equality\ntest on the index and whose alternative is `0` has value either the term at that index or `0`.\n\nThe difference with `Finset.sum_ite_eq` is that the arguments to `Eq` are swapped.\"]\ntheorem prod_ite_eq' [DecidableEq α] (s : Finset α) (a : α) (b : α → β) :\n    (∏ x ∈ s, ite (x = a) (b x) 1) = ite (a ∈ s) (b a) 1 :=\n  prod_dite_eq' s a fun x _ => b x\n\n"}
{"name":"Finset.prod_ite_eq_of_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nb : α → β\nh : Membership.mem s a\n⊢ Eq (s.prod fun x => ite (Eq a x) (b x) 1) (b a)","decl":"@[to_additive]\ntheorem prod_ite_eq_of_mem [DecidableEq α] (s : Finset α) (a : α) (b : α → β) (h : a ∈ s) :\n    (∏ x ∈ s, if a = x then b x else 1) = b a := by\n  simp only [prod_ite_eq, if_pos h]\n\n"}
{"name":"Finset.sum_ite_eq_of_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nb : α → β\nh : Membership.mem s a\n⊢ Eq (s.sum fun x => ite (Eq a x) (b x) 0) (b a)","decl":"@[to_additive]\ntheorem prod_ite_eq_of_mem [DecidableEq α] (s : Finset α) (a : α) (b : α → β) (h : a ∈ s) :\n    (∏ x ∈ s, if a = x then b x else 1) = b a := by\n  simp only [prod_ite_eq, if_pos h]\n\n"}
{"name":"Finset.sum_ite_eq_of_mem'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nb : α → β\nh : Membership.mem s a\n⊢ Eq (s.sum fun x => ite (Eq x a) (b x) 0) (b a)","decl":"/-- The difference with `Finset.prod_ite_eq_of_mem` is that the arguments to `Eq` are swapped. -/\n@[to_additive]\ntheorem prod_ite_eq_of_mem' [DecidableEq α] (s : Finset α) (a : α) (b : α → β) (h : a ∈ s) :\n    (∏ x ∈ s, if x = a then b x else 1) = b a := by\n  simp only [prod_ite_eq', if_pos h]\n\n"}
{"name":"Finset.prod_ite_eq_of_mem'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\na : α\nb : α → β\nh : Membership.mem s a\n⊢ Eq (s.prod fun x => ite (Eq x a) (b x) 1) (b a)","decl":"/-- The difference with `Finset.prod_ite_eq_of_mem` is that the arguments to `Eq` are swapped. -/\n@[to_additive]\ntheorem prod_ite_eq_of_mem' [DecidableEq α] (s : Finset α) (a : α) (b : α → β) (h : a ∈ s) :\n    (∏ x ∈ s, if x = a then b x else 1) = b a := by\n  simp only [prod_ite_eq', if_pos h]\n\n"}
{"name":"Finset.prod_pi_mulSingle'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\na : α\nx : β\ns : Finset α\n⊢ Eq (s.prod fun a' => Pi.mulSingle a x a') (ite (Membership.mem s a) x 1)","decl":"@[to_additive (attr := simp)]\ntheorem prod_pi_mulSingle' [DecidableEq α] (a : α) (x : β) (s : Finset α) :\n    ∏ a' ∈ s, Pi.mulSingle a x a' = if a ∈ s then x else 1 :=\n  prod_dite_eq' _ _ _\n\n"}
{"name":"Finset.sum_pi_single'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\na : α\nx : β\ns : Finset α\n⊢ Eq (s.sum fun a' => Pi.single a x a') (ite (Membership.mem s a) x 0)","decl":"@[to_additive (attr := simp)]\ntheorem prod_pi_mulSingle' [DecidableEq α] (a : α) (x : β) (s : Finset α) :\n    ∏ a' ∈ s, Pi.mulSingle a x a' = if a ∈ s then x else 1 :=\n  prod_dite_eq' _ _ _\n\n"}
{"name":"Finset.prod_pi_mulSingle","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : α → Type u_6\ninst✝¹ : DecidableEq α\ninst✝ : (a : α) → CommMonoid (β a)\na : α\nf : (a : α) → β a\ns : Finset α\n⊢ Eq (s.prod fun a' => Pi.mulSingle a' (f a') a) (ite (Membership.mem s a) (f a) 1)","decl":"@[to_additive (attr := simp)]\ntheorem prod_pi_mulSingle {β : α → Type*} [DecidableEq α] [∀ a, CommMonoid (β a)] (a : α)\n    (f : ∀ a, β a) (s : Finset α) :\n    (∏ a' ∈ s, Pi.mulSingle a' (f a') a) = if a ∈ s then f a else 1 :=\n  prod_dite_eq _ _ _\n\n"}
{"name":"Finset.sum_pi_single","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : α → Type u_6\ninst✝¹ : DecidableEq α\ninst✝ : (a : α) → AddCommMonoid (β a)\na : α\nf : (a : α) → β a\ns : Finset α\n⊢ Eq (s.sum fun a' => Pi.single a' (f a') a) (ite (Membership.mem s a) (f a) 0)","decl":"@[to_additive (attr := simp)]\ntheorem prod_pi_mulSingle {β : α → Type*} [DecidableEq α] [∀ a, CommMonoid (β a)] (a : α)\n    (f : ∀ a, β a) (s : Finset α) :\n    (∏ a' ∈ s, Pi.mulSingle a' (f a') a) = if a ∈ s then f a else 1 :=\n  prod_dite_eq _ _ _\n\n"}
{"name":"Finset.mulSupport_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset ι\nf : ι → α → β\n⊢ HasSubset.Subset (Function.mulSupport fun x => s.prod fun i => f i x) (Set.iUnion fun i => Set.iUnion fun h => Function.mulSupport (f i))","decl":"@[to_additive]\nlemma mulSupport_prod (s : Finset ι) (f : ι → α → β) :\n    mulSupport (fun x ↦ ∏ i ∈ s, f i x) ⊆ ⋃ i ∈ s, mulSupport (f i) := by\n  simp only [mulSupport_subset_iff', Set.mem_iUnion, not_exists, nmem_mulSupport]\n  exact fun x ↦ prod_eq_one\n\n"}
{"name":"Finset.support_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset ι\nf : ι → α → β\n⊢ HasSubset.Subset (Function.support fun x => s.sum fun i => f i x) (Set.iUnion fun i => Set.iUnion fun h => Function.support (f i))","decl":"@[to_additive]\nlemma mulSupport_prod (s : Finset ι) (f : ι → α → β) :\n    mulSupport (fun x ↦ ∏ i ∈ s, f i x) ⊆ ⋃ i ∈ s, mulSupport (f i) := by\n  simp only [mulSupport_subset_iff', Set.mem_iUnion, not_exists, nmem_mulSupport]\n  exact fun x ↦ prod_eq_one\n\n"}
{"name":"Finset.prod_mulIndicator_subset_of_eq_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : One α\nf : ι → α\ng : ι → α → β\ns t : Finset ι\nh : HasSubset.Subset s t\nhg : ∀ (a : ι), Eq (g a 1) 1\n⊢ Eq (t.prod fun i => g i ((↑s).mulIndicator f i)) (s.prod fun i => g i (f i))","decl":"/-- Consider a product of `g i (f i)` over a finset.  Suppose `g` is a function such as\n`n ↦ (· ^ n)`, which maps a second argument of `1` to `1`. Then if `f` is replaced by the\ncorresponding multiplicative indicator function, the finset may be replaced by a possibly larger\nfinset without changing the value of the product. -/\n@[to_additive \"Consider a sum of `g i (f i)` over a finset.  Suppose `g` is a function such as\n`n ↦ (n • ·)`, which maps a second argument of `0` to `0` (or a weighted sum of `f i * h i` or\n`f i • h i`, where `f` gives the weights that are multiplied by some other function `h`). Then if\n`f` is replaced by the corresponding indicator function, the finset may be replaced by a possibly\nlarger finset without changing the value of the sum.\"]\nlemma prod_mulIndicator_subset_of_eq_one [One α] (f : ι → α) (g : ι → α → β) {s t : Finset ι}\n    (h : s ⊆ t) (hg : ∀ a, g a 1 = 1) :\n    ∏ i ∈ t, g i (mulIndicator ↑s f i) = ∏ i ∈ s, g i (f i) := by\n  calc\n    _ = ∏ i ∈ s, g i (mulIndicator ↑s f i) := by rw [prod_subset h fun i _ hn ↦ by simp [hn, hg]]\n    _ = _ := prod_congr rfl fun i hi ↦ congr_arg _ <| mulIndicator_of_mem hi f\n\n"}
{"name":"Finset.sum_indicator_subset_of_eq_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : Zero α\nf : ι → α\ng : ι → α → β\ns t : Finset ι\nh : HasSubset.Subset s t\nhg : ∀ (a : ι), Eq (g a 0) 0\n⊢ Eq (t.sum fun i => g i ((↑s).indicator f i)) (s.sum fun i => g i (f i))","decl":"/-- Consider a product of `g i (f i)` over a finset.  Suppose `g` is a function such as\n`n ↦ (· ^ n)`, which maps a second argument of `1` to `1`. Then if `f` is replaced by the\ncorresponding multiplicative indicator function, the finset may be replaced by a possibly larger\nfinset without changing the value of the product. -/\n@[to_additive \"Consider a sum of `g i (f i)` over a finset.  Suppose `g` is a function such as\n`n ↦ (n • ·)`, which maps a second argument of `0` to `0` (or a weighted sum of `f i * h i` or\n`f i • h i`, where `f` gives the weights that are multiplied by some other function `h`). Then if\n`f` is replaced by the corresponding indicator function, the finset may be replaced by a possibly\nlarger finset without changing the value of the sum.\"]\nlemma prod_mulIndicator_subset_of_eq_one [One α] (f : ι → α) (g : ι → α → β) {s t : Finset ι}\n    (h : s ⊆ t) (hg : ∀ a, g a 1 = 1) :\n    ∏ i ∈ t, g i (mulIndicator ↑s f i) = ∏ i ∈ s, g i (f i) := by\n  calc\n    _ = ∏ i ∈ s, g i (mulIndicator ↑s f i) := by rw [prod_subset h fun i _ hn ↦ by simp [hn, hg]]\n    _ = _ := prod_congr rfl fun i hi ↦ congr_arg _ <| mulIndicator_of_mem hi f\n\n"}
{"name":"Finset.sum_indicator_subset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝ : AddCommMonoid β\nf : ι → β\ns t : Finset ι\nh : HasSubset.Subset s t\n⊢ Eq (t.sum fun i => (↑s).indicator f i) (s.sum fun i => f i)","decl":"/-- Taking the product of an indicator function over a possibly larger finset is the same as\ntaking the original function over the original finset. -/\n@[to_additive \"Summing an indicator function over a possibly larger `Finset` is the same as summing\n  the original function over the original finset.\"]\nlemma prod_mulIndicator_subset (f : ι → β) {s t : Finset ι} (h : s ⊆ t) :\n    ∏ i ∈ t, mulIndicator (↑s) f i = ∏ i ∈ s, f i :=\n  prod_mulIndicator_subset_of_eq_one _ (fun _ ↦ id) h fun _ ↦ rfl\n\n"}
{"name":"Finset.prod_mulIndicator_subset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝ : CommMonoid β\nf : ι → β\ns t : Finset ι\nh : HasSubset.Subset s t\n⊢ Eq (t.prod fun i => (↑s).mulIndicator f i) (s.prod fun i => f i)","decl":"/-- Taking the product of an indicator function over a possibly larger finset is the same as\ntaking the original function over the original finset. -/\n@[to_additive \"Summing an indicator function over a possibly larger `Finset` is the same as summing\n  the original function over the original finset.\"]\nlemma prod_mulIndicator_subset (f : ι → β) {s t : Finset ι} (h : s ⊆ t) :\n    ∏ i ∈ t, mulIndicator (↑s) f i = ∏ i ∈ s, f i :=\n  prod_mulIndicator_subset_of_eq_one _ (fun _ ↦ id) h fun _ ↦ rfl\n\n"}
{"name":"Finset.sum_indicator_eq_sum_filter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\nκ : Type u_6\ns : Finset ι\nf : ι → κ → β\nt : ι → Set κ\ng : ι → κ\ninst✝ : DecidablePred fun i => Membership.mem (t i) (g i)\n⊢ Eq (s.sum fun i => (t i).indicator (f i) (g i)) ((Finset.filter (fun i => Membership.mem (t i) (g i)) s).sum fun i => f i (g i))","decl":"@[to_additive]\nlemma prod_mulIndicator_eq_prod_filter (s : Finset ι) (f : ι → κ → β) (t : ι → Set κ) (g : ι → κ)\n    [DecidablePred fun i ↦ g i ∈ t i] :\n    ∏ i ∈ s, mulIndicator (t i) (f i) (g i) = ∏ i ∈ s with g i ∈ t i, f i (g i) := by\n  refine (prod_filter_mul_prod_filter_not s (fun i ↦ g i ∈ t i) _).symm.trans <|\n     Eq.trans (congr_arg₂ (· * ·) ?_ ?_) (mul_one _)\n  · exact prod_congr rfl fun x hx ↦ mulIndicator_of_mem (mem_filter.1 hx).2 _\n  · exact prod_eq_one fun x hx ↦ mulIndicator_of_not_mem (mem_filter.1 hx).2 _\n\n"}
{"name":"Finset.prod_mulIndicator_eq_prod_filter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝¹ : CommMonoid β\nκ : Type u_6\ns : Finset ι\nf : ι → κ → β\nt : ι → Set κ\ng : ι → κ\ninst✝ : DecidablePred fun i => Membership.mem (t i) (g i)\n⊢ Eq (s.prod fun i => (t i).mulIndicator (f i) (g i)) ((Finset.filter (fun i => Membership.mem (t i) (g i)) s).prod fun i => f i (g i))","decl":"@[to_additive]\nlemma prod_mulIndicator_eq_prod_filter (s : Finset ι) (f : ι → κ → β) (t : ι → Set κ) (g : ι → κ)\n    [DecidablePred fun i ↦ g i ∈ t i] :\n    ∏ i ∈ s, mulIndicator (t i) (f i) (g i) = ∏ i ∈ s with g i ∈ t i, f i (g i) := by\n  refine (prod_filter_mul_prod_filter_not s (fun i ↦ g i ∈ t i) _).symm.trans <|\n     Eq.trans (congr_arg₂ (· * ·) ?_ ?_) (mul_one _)\n  · exact prod_congr rfl fun x hx ↦ mulIndicator_of_mem (mem_filter.1 hx).2 _\n  · exact prod_eq_one fun x hx ↦ mulIndicator_of_not_mem (mem_filter.1 hx).2 _\n\n"}
{"name":"Finset.prod_mulIndicator_eq_prod_inter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq ι\ns t : Finset ι\nf : ι → β\n⊢ Eq (s.prod fun i => (↑t).mulIndicator f i) ((Inter.inter s t).prod fun i => f i)","decl":"@[to_additive]\nlemma prod_mulIndicator_eq_prod_inter [DecidableEq ι] (s t : Finset ι) (f : ι → β) :\n    ∏ i ∈ s, (t : Set ι).mulIndicator f i = ∏ i ∈ s ∩ t, f i := by\n  rw [← filter_mem_eq_inter, prod_mulIndicator_eq_prod_filter]; rfl\n\n"}
{"name":"Finset.sum_indicator_eq_sum_inter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq ι\ns t : Finset ι\nf : ι → β\n⊢ Eq (s.sum fun i => (↑t).indicator f i) ((Inter.inter s t).sum fun i => f i)","decl":"@[to_additive]\nlemma prod_mulIndicator_eq_prod_inter [DecidableEq ι] (s t : Finset ι) (f : ι → β) :\n    ∏ i ∈ s, (t : Set ι).mulIndicator f i = ∏ i ∈ s ∩ t, f i := by\n  rw [← filter_mem_eq_inter, prod_mulIndicator_eq_prod_filter]; rfl\n\n"}
{"name":"Finset.mulIndicator_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝ : CommMonoid β\nκ : Type u_6\ns : Finset ι\nt : Set κ\nf : ι → κ → β\n⊢ Eq (t.mulIndicator (s.prod fun i => f i)) (s.prod fun i => t.mulIndicator (f i))","decl":"@[to_additive]\nlemma mulIndicator_prod (s : Finset ι) (t : Set κ) (f : ι → κ → β) :\n    mulIndicator t (∏ i ∈ s, f i) = ∏ i ∈ s, mulIndicator t (f i) :=\n  map_prod (mulIndicatorHom _ _) _ _\n\n"}
{"name":"Finset.indicator_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝ : AddCommMonoid β\nκ : Type u_6\ns : Finset ι\nt : Set κ\nf : ι → κ → β\n⊢ Eq (t.indicator (s.sum fun i => f i)) (s.sum fun i => t.indicator (f i))","decl":"@[to_additive]\nlemma mulIndicator_prod (s : Finset ι) (t : Set κ) (f : ι → κ → β) :\n    mulIndicator t (∏ i ∈ s, f i) = ∏ i ∈ s, mulIndicator t (f i) :=\n  map_prod (mulIndicatorHom _ _) _ _\n\n"}
{"name":"Finset.indicator_biUnion","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝ : AddCommMonoid β\nκ : Type u_7\ns : Finset ι\nt : ι → Set κ\nf : κ → β\nhs : (↑s).PairwiseDisjoint t\n⊢ Eq ((Set.iUnion fun i => Set.iUnion fun h => t i).indicator f) fun a => s.sum fun i => (t i).indicator f a","decl":"@[to_additive]\nlemma mulIndicator_biUnion (s : Finset ι) (t : ι → Set κ) {f : κ → β}\n    (hs : (s : Set ι).PairwiseDisjoint t) :\n    mulIndicator (⋃ i ∈ s, t i) f = fun a ↦ ∏ i ∈ s, mulIndicator (t i) f a := by\n  induction s using Finset.cons_induction with\n  | empty => simp\n  | cons i s hi ih =>\n    ext j\n    rw [coe_cons, Set.pairwiseDisjoint_insert_of_not_mem (Finset.mem_coe.not.2 hi)] at hs\n    classical\n    rw [prod_cons, cons_eq_insert, set_biUnion_insert, mulIndicator_union_of_not_mem_inter, ih hs.1]\n    exact (Set.disjoint_iff.mp (Set.disjoint_iUnion₂_right.mpr hs.2) ·)\n\n"}
{"name":"Finset.mulIndicator_biUnion","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝ : CommMonoid β\nκ : Type u_7\ns : Finset ι\nt : ι → Set κ\nf : κ → β\nhs : (↑s).PairwiseDisjoint t\n⊢ Eq ((Set.iUnion fun i => Set.iUnion fun h => t i).mulIndicator f) fun a => s.prod fun i => (t i).mulIndicator f a","decl":"@[to_additive]\nlemma mulIndicator_biUnion (s : Finset ι) (t : ι → Set κ) {f : κ → β}\n    (hs : (s : Set ι).PairwiseDisjoint t) :\n    mulIndicator (⋃ i ∈ s, t i) f = fun a ↦ ∏ i ∈ s, mulIndicator (t i) f a := by\n  induction s using Finset.cons_induction with\n  | empty => simp\n  | cons i s hi ih =>\n    ext j\n    rw [coe_cons, Set.pairwiseDisjoint_insert_of_not_mem (Finset.mem_coe.not.2 hi)] at hs\n    classical\n    rw [prod_cons, cons_eq_insert, set_biUnion_insert, mulIndicator_union_of_not_mem_inter, ih hs.1]\n    exact (Set.disjoint_iff.mp (Set.disjoint_iUnion₂_right.mpr hs.2) ·)\n\n"}
{"name":"Finset.indicator_biUnion_apply","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝ : AddCommMonoid β\nκ : Type u_7\ns : Finset ι\nt : ι → Set κ\nf : κ → β\nh : (↑s).PairwiseDisjoint t\nx : κ\n⊢ Eq ((Set.iUnion fun i => Set.iUnion fun h => t i).indicator f x) (s.sum fun i => (t i).indicator f x)","decl":"@[to_additive]\nlemma mulIndicator_biUnion_apply (s : Finset ι) (t : ι → Set κ) {f : κ → β}\n    (h : (s : Set ι).PairwiseDisjoint t) (x : κ) :\n    mulIndicator (⋃ i ∈ s, t i) f x = ∏ i ∈ s, mulIndicator (t i) f x := by\n  rw [mulIndicator_biUnion s t h]\n\n"}
{"name":"Finset.mulIndicator_biUnion_apply","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝ : CommMonoid β\nκ : Type u_7\ns : Finset ι\nt : ι → Set κ\nf : κ → β\nh : (↑s).PairwiseDisjoint t\nx : κ\n⊢ Eq ((Set.iUnion fun i => Set.iUnion fun h => t i).mulIndicator f x) (s.prod fun i => (t i).mulIndicator f x)","decl":"@[to_additive]\nlemma mulIndicator_biUnion_apply (s : Finset ι) (t : ι → Set κ) {f : κ → β}\n    (h : (s : Set ι).PairwiseDisjoint t) (x : κ) :\n    mulIndicator (⋃ i ∈ s, t i) f x = ∏ i ∈ s, mulIndicator (t i) f x := by\n  rw [mulIndicator_biUnion s t h]\n\n"}
{"name":"Finset.prod_bij_ne_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : CommMonoid β\ns : Finset α\nt : Finset γ\nf : α → β\ng : γ → β\ni : (a : α) → Membership.mem s a → Ne (f a) 1 → γ\nhi : ∀ (a : α) (h₁ : Membership.mem s a) (h₂ : Ne (f a) 1), Membership.mem t (i a h₁ h₂)\ni_inj : ∀ (a₁ : α) (h₁₁ : Membership.mem s a₁) (h₁₂ : Ne (f a₁) 1) (a₂ : α) (h₂₁ : Membership.mem s a₂) (h₂₂ : Ne (f a₂) 1), Eq (i a₁ h₁₁ h₁₂) (i a₂ h₂₁ h₂₂) → Eq a₁ a₂\ni_surj : ∀ (b : γ), Membership.mem t b → Ne (g b) 1 → Exists fun a => Exists fun h₁ => Exists fun h₂ => Eq (i a h₁ h₂) b\nh : ∀ (a : α) (h₁ : Membership.mem s a) (h₂ : Ne (f a) 1), Eq (f a) (g (i a h₁ h₂))\n⊢ Eq (s.prod fun x => f x) (t.prod fun x => g x)","decl":"@[to_additive]\ntheorem prod_bij_ne_one {s : Finset α} {t : Finset γ} {f : α → β} {g : γ → β}\n    (i : ∀ a ∈ s, f a ≠ 1 → γ) (hi : ∀ a h₁ h₂, i a h₁ h₂ ∈ t)\n    (i_inj : ∀ a₁ h₁₁ h₁₂ a₂ h₂₁ h₂₂, i a₁ h₁₁ h₁₂ = i a₂ h₂₁ h₂₂ → a₁ = a₂)\n    (i_surj : ∀ b ∈ t, g b ≠ 1 → ∃ a h₁ h₂, i a h₁ h₂ = b) (h : ∀ a h₁ h₂, f a = g (i a h₁ h₂)) :\n    ∏ x ∈ s, f x = ∏ x ∈ t, g x := by\n  classical\n  calc\n    ∏ x ∈ s, f x = ∏ x ∈ s with f x ≠ 1, f x := by rw [prod_filter_ne_one]\n    _ = ∏ x ∈ t with g x ≠ 1, g x :=\n      prod_bij (fun a ha => i a (mem_filter.mp ha).1 <| by simpa using (mem_filter.mp ha).2)\n        ?_ ?_ ?_ ?_\n    _ = ∏ x ∈ t, g x := prod_filter_ne_one _\n  · intros a ha\n    refine (mem_filter.mp ha).elim ?_\n    intros h₁ h₂\n    refine (mem_filter.mpr ⟨hi a h₁ _, ?_⟩)\n    specialize h a h₁ fun H ↦ by rw [H] at h₂; simp at h₂\n    rwa [← h]\n  · intros a₁ ha₁ a₂ ha₂\n    refine (mem_filter.mp ha₁).elim fun _ha₁₁ _ha₁₂ ↦ ?_\n    refine (mem_filter.mp ha₂).elim fun _ha₂₁ _ha₂₂ ↦ ?_\n    apply i_inj\n  · intros b hb\n    refine (mem_filter.mp hb).elim fun h₁ h₂ ↦ ?_\n    obtain ⟨a, ha₁, ha₂, eq⟩ := i_surj b h₁ fun H ↦ by rw [H] at h₂; simp at h₂\n    exact ⟨a, mem_filter.mpr ⟨ha₁, ha₂⟩, eq⟩\n  · refine (fun a ha => (mem_filter.mp ha).elim fun h₁ h₂ ↦ ?_)\n    exact h a h₁ fun H ↦ by rw [H] at h₂; simp at h₂\n\n"}
{"name":"Finset.sum_bij_ne_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ninst✝ : AddCommMonoid β\ns : Finset α\nt : Finset γ\nf : α → β\ng : γ → β\ni : (a : α) → Membership.mem s a → Ne (f a) 0 → γ\nhi : ∀ (a : α) (h₁ : Membership.mem s a) (h₂ : Ne (f a) 0), Membership.mem t (i a h₁ h₂)\ni_inj : ∀ (a₁ : α) (h₁₁ : Membership.mem s a₁) (h₁₂ : Ne (f a₁) 0) (a₂ : α) (h₂₁ : Membership.mem s a₂) (h₂₂ : Ne (f a₂) 0), Eq (i a₁ h₁₁ h₁₂) (i a₂ h₂₁ h₂₂) → Eq a₁ a₂\ni_surj : ∀ (b : γ), Membership.mem t b → Ne (g b) 0 → Exists fun a => Exists fun h₁ => Exists fun h₂ => Eq (i a h₁ h₂) b\nh : ∀ (a : α) (h₁ : Membership.mem s a) (h₂ : Ne (f a) 0), Eq (f a) (g (i a h₁ h₂))\n⊢ Eq (s.sum fun x => f x) (t.sum fun x => g x)","decl":"@[to_additive]\ntheorem prod_bij_ne_one {s : Finset α} {t : Finset γ} {f : α → β} {g : γ → β}\n    (i : ∀ a ∈ s, f a ≠ 1 → γ) (hi : ∀ a h₁ h₂, i a h₁ h₂ ∈ t)\n    (i_inj : ∀ a₁ h₁₁ h₁₂ a₂ h₂₁ h₂₂, i a₁ h₁₁ h₁₂ = i a₂ h₂₁ h₂₂ → a₁ = a₂)\n    (i_surj : ∀ b ∈ t, g b ≠ 1 → ∃ a h₁ h₂, i a h₁ h₂ = b) (h : ∀ a h₁ h₂, f a = g (i a h₁ h₂)) :\n    ∏ x ∈ s, f x = ∏ x ∈ t, g x := by\n  classical\n  calc\n    ∏ x ∈ s, f x = ∏ x ∈ s with f x ≠ 1, f x := by rw [prod_filter_ne_one]\n    _ = ∏ x ∈ t with g x ≠ 1, g x :=\n      prod_bij (fun a ha => i a (mem_filter.mp ha).1 <| by simpa using (mem_filter.mp ha).2)\n        ?_ ?_ ?_ ?_\n    _ = ∏ x ∈ t, g x := prod_filter_ne_one _\n  · intros a ha\n    refine (mem_filter.mp ha).elim ?_\n    intros h₁ h₂\n    refine (mem_filter.mpr ⟨hi a h₁ _, ?_⟩)\n    specialize h a h₁ fun H ↦ by rw [H] at h₂; simp at h₂\n    rwa [← h]\n  · intros a₁ ha₁ a₂ ha₂\n    refine (mem_filter.mp ha₁).elim fun _ha₁₁ _ha₁₂ ↦ ?_\n    refine (mem_filter.mp ha₂).elim fun _ha₂₁ _ha₂₂ ↦ ?_\n    apply i_inj\n  · intros b hb\n    refine (mem_filter.mp hb).elim fun h₁ h₂ ↦ ?_\n    obtain ⟨a, ha₁, ha₂, eq⟩ := i_surj b h₁ fun H ↦ by rw [H] at h₂; simp at h₂\n    exact ⟨a, mem_filter.mpr ⟨ha₁, ha₂⟩, eq⟩\n  · refine (fun a ha => (mem_filter.mp ha).elim fun h₁ h₂ ↦ ?_)\n    exact h a h₁ fun H ↦ by rw [H] at h₂; simp at h₂\n\n"}
{"name":"Finset.exists_ne_zero_of_sum_ne_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : AddCommMonoid β\nh : Ne (s.sum fun x => f x) 0\n⊢ Exists fun a => And (Membership.mem s a) (Ne (f a) 0)","decl":"@[to_additive]\ntheorem exists_ne_one_of_prod_ne_one (h : ∏ x ∈ s, f x ≠ 1) : ∃ a ∈ s, f a ≠ 1 := by\n  classical\n    rw [← prod_filter_ne_one] at h\n    rcases nonempty_of_prod_ne_one h with ⟨x, hx⟩\n    exact ⟨x, (mem_filter.1 hx).1, by simpa using (mem_filter.1 hx).2⟩\n\n"}
{"name":"Finset.exists_ne_one_of_prod_ne_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : CommMonoid β\nh : Ne (s.prod fun x => f x) 1\n⊢ Exists fun a => And (Membership.mem s a) (Ne (f a) 1)","decl":"@[to_additive]\ntheorem exists_ne_one_of_prod_ne_one (h : ∏ x ∈ s, f x ≠ 1) : ∃ a ∈ s, f a ≠ 1 := by\n  classical\n    rw [← prod_filter_ne_one] at h\n    rcases nonempty_of_prod_ne_one h with ⟨x, hx⟩\n    exact ⟨x, (mem_filter.1 hx).1, by simpa using (mem_filter.1 hx).2⟩\n\n"}
{"name":"Finset.prod_range_succ_comm","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : CommMonoid β\nf : Nat → β\nn : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).prod fun x => f x) (HMul.hMul (f n) ((Finset.range n).prod fun x => f x))","decl":"@[to_additive]\ntheorem prod_range_succ_comm (f : ℕ → β) (n : ℕ) :\n    (∏ x ∈ range (n + 1), f x) = f n * ∏ x ∈ range n, f x := by\n  rw [range_succ, prod_insert not_mem_range_self]\n\n"}
{"name":"Finset.sum_range_succ_comm","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : AddCommMonoid β\nf : Nat → β\nn : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun x => f x) (HAdd.hAdd (f n) ((Finset.range n).sum fun x => f x))","decl":"@[to_additive]\ntheorem prod_range_succ_comm (f : ℕ → β) (n : ℕ) :\n    (∏ x ∈ range (n + 1), f x) = f n * ∏ x ∈ range n, f x := by\n  rw [range_succ, prod_insert not_mem_range_self]\n\n"}
{"name":"Finset.prod_range_succ","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : CommMonoid β\nf : Nat → β\nn : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).prod fun x => f x) (HMul.hMul ((Finset.range n).prod fun x => f x) (f n))","decl":"@[to_additive]\ntheorem prod_range_succ (f : ℕ → β) (n : ℕ) :\n    (∏ x ∈ range (n + 1), f x) = (∏ x ∈ range n, f x) * f n := by\n  simp only [mul_comm, prod_range_succ_comm]\n\n"}
{"name":"Finset.sum_range_succ","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : AddCommMonoid β\nf : Nat → β\nn : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun x => f x) (HAdd.hAdd ((Finset.range n).sum fun x => f x) (f n))","decl":"@[to_additive]\ntheorem prod_range_succ (f : ℕ → β) (n : ℕ) :\n    (∏ x ∈ range (n + 1), f x) = (∏ x ∈ range n, f x) * f n := by\n  simp only [mul_comm, prod_range_succ_comm]\n\n"}
{"name":"Finset.sum_range_succ'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : AddCommMonoid β\nf : Nat → β\nn : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun k => f k) (HAdd.hAdd ((Finset.range n).sum fun k => f (HAdd.hAdd k 1)) (f 0))","decl":"@[to_additive]\ntheorem prod_range_succ' (f : ℕ → β) :\n    ∀ n : ℕ, (∏ k ∈ range (n + 1), f k) = (∏ k ∈ range n, f (k + 1)) * f 0\n  | 0 => prod_range_succ _ _\n  | n + 1 => by rw [prod_range_succ _ n, mul_right_comm, ← prod_range_succ' _ n, prod_range_succ]\n\n"}
{"name":"Finset.prod_range_succ'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : CommMonoid β\nf : Nat → β\nn : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).prod fun k => f k) (HMul.hMul ((Finset.range n).prod fun k => f (HAdd.hAdd k 1)) (f 0))","decl":"@[to_additive]\ntheorem prod_range_succ' (f : ℕ → β) :\n    ∀ n : ℕ, (∏ k ∈ range (n + 1), f k) = (∏ k ∈ range n, f (k + 1)) * f 0\n  | 0 => prod_range_succ _ _\n  | n + 1 => by rw [prod_range_succ _ n, mul_right_comm, ← prod_range_succ' _ n, prod_range_succ]\n\n"}
{"name":"Finset.eventually_constant_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : CommMonoid β\nu : Nat → β\nN : Nat\nhu : ∀ (n : Nat), GE.ge n N → Eq (u n) 1\nn : Nat\nhn : LE.le N n\n⊢ Eq ((Finset.range n).prod fun k => u k) ((Finset.range N).prod fun k => u k)","decl":"@[to_additive]\ntheorem eventually_constant_prod {u : ℕ → β} {N : ℕ} (hu : ∀ n ≥ N, u n = 1) {n : ℕ} (hn : N ≤ n) :\n    (∏ k ∈ range n, u k) = ∏ k ∈ range N, u k := by\n  obtain ⟨m, rfl : n = N + m⟩ := Nat.exists_eq_add_of_le hn\n  clear hn\n  induction m with\n  | zero => simp\n  | succ m hm => simp [← add_assoc, prod_range_succ, hm, hu]\n\n"}
{"name":"Finset.eventually_constant_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : AddCommMonoid β\nu : Nat → β\nN : Nat\nhu : ∀ (n : Nat), GE.ge n N → Eq (u n) 0\nn : Nat\nhn : LE.le N n\n⊢ Eq ((Finset.range n).sum fun k => u k) ((Finset.range N).sum fun k => u k)","decl":"@[to_additive]\ntheorem eventually_constant_prod {u : ℕ → β} {N : ℕ} (hu : ∀ n ≥ N, u n = 1) {n : ℕ} (hn : N ≤ n) :\n    (∏ k ∈ range n, u k) = ∏ k ∈ range N, u k := by\n  obtain ⟨m, rfl : n = N + m⟩ := Nat.exists_eq_add_of_le hn\n  clear hn\n  induction m with\n  | zero => simp\n  | succ m hm => simp [← add_assoc, prod_range_succ, hm, hu]\n\n"}
{"name":"Finset.prod_range_add","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : CommMonoid β\nf : Nat → β\nn m : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n m)).prod fun x => f x) (HMul.hMul ((Finset.range n).prod fun x => f x) ((Finset.range m).prod fun x => f (HAdd.hAdd n x)))","decl":"@[to_additive]\ntheorem prod_range_add (f : ℕ → β) (n m : ℕ) :\n    (∏ x ∈ range (n + m), f x) = (∏ x ∈ range n, f x) * ∏ x ∈ range m, f (n + x) := by\n  induction m with\n  | zero => simp\n  | succ m hm => rw [Nat.add_succ, prod_range_succ, prod_range_succ, hm, mul_assoc]\n\n"}
{"name":"Finset.sum_range_add","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : AddCommMonoid β\nf : Nat → β\nn m : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n m)).sum fun x => f x) (HAdd.hAdd ((Finset.range n).sum fun x => f x) ((Finset.range m).sum fun x => f (HAdd.hAdd n x)))","decl":"@[to_additive]\ntheorem prod_range_add (f : ℕ → β) (n m : ℕ) :\n    (∏ x ∈ range (n + m), f x) = (∏ x ∈ range n, f x) * ∏ x ∈ range m, f (n + x) := by\n  induction m with\n  | zero => simp\n  | succ m hm => rw [Nat.add_succ, prod_range_succ, prod_range_succ, hm, mul_assoc]\n\n"}
{"name":"Finset.sum_range_add_sub_sum_range","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\ninst✝ : AddCommGroup α\nf : Nat → α\nn m : Nat\n⊢ Eq (HSub.hSub ((Finset.range (HAdd.hAdd n m)).sum fun k => f k) ((Finset.range n).sum fun k => f k)) ((Finset.range m).sum fun k => f (HAdd.hAdd n k))","decl":"@[to_additive]\ntheorem prod_range_add_div_prod_range {α : Type*} [CommGroup α] (f : ℕ → α) (n m : ℕ) :\n    (∏ k ∈ range (n + m), f k) / ∏ k ∈ range n, f k = ∏ k ∈ Finset.range m, f (n + k) :=\n  div_eq_of_eq_mul' (prod_range_add f n m)\n\n"}
{"name":"Finset.prod_range_add_div_prod_range","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\ninst✝ : CommGroup α\nf : Nat → α\nn m : Nat\n⊢ Eq (HDiv.hDiv ((Finset.range (HAdd.hAdd n m)).prod fun k => f k) ((Finset.range n).prod fun k => f k)) ((Finset.range m).prod fun k => f (HAdd.hAdd n k))","decl":"@[to_additive]\ntheorem prod_range_add_div_prod_range {α : Type*} [CommGroup α] (f : ℕ → α) (n m : ℕ) :\n    (∏ k ∈ range (n + m), f k) / ∏ k ∈ range n, f k = ∏ k ∈ Finset.range m, f (n + k) :=\n  div_eq_of_eq_mul' (prod_range_add f n m)\n\n"}
{"name":"Finset.prod_range_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : CommMonoid β\nf : Nat → β\n⊢ Eq ((Finset.range 1).prod fun k => f k) (f 0)","decl":"@[to_additive sum_range_one]\ntheorem prod_range_one (f : ℕ → β) : ∏ k ∈ range 1, f k = f 0 := by\n  rw [range_one, prod_singleton]\n\n"}
{"name":"Finset.sum_range_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : AddCommMonoid β\nf : Nat → β\n⊢ Eq ((Finset.range 1).sum fun k => f k) (f 0)","decl":"@[to_additive sum_range_one]\ntheorem prod_range_one (f : ℕ → β) : ∏ k ∈ range 1, f k = f 0 := by\n  rw [range_one, prod_singleton]\n\n"}
{"name":"Finset.prod_list_map_count","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\nl : List α\nM : Type u_6\ninst✝ : CommMonoid M\nf : α → M\n⊢ Eq (List.map f l).prod (l.toFinset.prod fun m => HPow.hPow (f m) (List.count m l))","decl":"@[to_additive]\ntheorem prod_list_map_count [DecidableEq α] (l : List α) {M : Type*} [CommMonoid M] (f : α → M) :\n    (l.map f).prod = ∏ m ∈ l.toFinset, f m ^ l.count m := by\n  induction l with\n  | nil => simp only [map_nil, prod_nil, count_nil, pow_zero, prod_const_one]\n  | cons a s IH =>\n  simp only [List.map, List.prod_cons, toFinset_cons, IH]\n  by_cases has : a ∈ s.toFinset\n  · rw [insert_eq_of_mem has, ← insert_erase has, prod_insert (not_mem_erase _ _),\n      prod_insert (not_mem_erase _ _), ← mul_assoc, count_cons_self, pow_succ']\n    congr 1\n    refine prod_congr rfl fun x hx => ?_\n    rw [count_cons_of_ne (ne_of_mem_erase hx)]\n  rw [prod_insert has, count_cons_self, count_eq_zero_of_not_mem (mt mem_toFinset.2 has), pow_one]\n  congr 1\n  refine prod_congr rfl fun x hx => ?_\n  rw [count_cons_of_ne]\n  rintro rfl\n  exact has hx\n\n"}
{"name":"Finset.sum_list_map_count","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\nl : List α\nM : Type u_6\ninst✝ : AddCommMonoid M\nf : α → M\n⊢ Eq (List.map f l).sum (l.toFinset.sum fun m => HSMul.hSMul (List.count m l) (f m))","decl":"@[to_additive]\ntheorem prod_list_map_count [DecidableEq α] (l : List α) {M : Type*} [CommMonoid M] (f : α → M) :\n    (l.map f).prod = ∏ m ∈ l.toFinset, f m ^ l.count m := by\n  induction l with\n  | nil => simp only [map_nil, prod_nil, count_nil, pow_zero, prod_const_one]\n  | cons a s IH =>\n  simp only [List.map, List.prod_cons, toFinset_cons, IH]\n  by_cases has : a ∈ s.toFinset\n  · rw [insert_eq_of_mem has, ← insert_erase has, prod_insert (not_mem_erase _ _),\n      prod_insert (not_mem_erase _ _), ← mul_assoc, count_cons_self, pow_succ']\n    congr 1\n    refine prod_congr rfl fun x hx => ?_\n    rw [count_cons_of_ne (ne_of_mem_erase hx)]\n  rw [prod_insert has, count_cons_self, count_eq_zero_of_not_mem (mt mem_toFinset.2 has), pow_one]\n  congr 1\n  refine prod_congr rfl fun x hx => ?_\n  rw [count_cons_of_ne]\n  rintro rfl\n  exact has hx\n\n"}
{"name":"Finset.sum_list_count","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\ninst✝ : AddCommMonoid α\ns : List α\n⊢ Eq s.sum (s.toFinset.sum fun m => HSMul.hSMul (List.count m s) m)","decl":"@[to_additive]\ntheorem prod_list_count [DecidableEq α] [CommMonoid α] (s : List α) :\n    s.prod = ∏ m ∈ s.toFinset, m ^ s.count m := by simpa using prod_list_map_count s id\n\n"}
{"name":"Finset.prod_list_count","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\ninst✝ : CommMonoid α\ns : List α\n⊢ Eq s.prod (s.toFinset.prod fun m => HPow.hPow m (List.count m s))","decl":"@[to_additive]\ntheorem prod_list_count [DecidableEq α] [CommMonoid α] (s : List α) :\n    s.prod = ∏ m ∈ s.toFinset, m ^ s.count m := by simpa using prod_list_map_count s id\n\n"}
{"name":"Finset.prod_list_count_of_subset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\ninst✝ : CommMonoid α\nm : List α\ns : Finset α\nhs : HasSubset.Subset m.toFinset s\n⊢ Eq m.prod (s.prod fun i => HPow.hPow i (List.count i m))","decl":"@[to_additive]\ntheorem prod_list_count_of_subset [DecidableEq α] [CommMonoid α] (m : List α) (s : Finset α)\n    (hs : m.toFinset ⊆ s) : m.prod = ∏ i ∈ s, i ^ m.count i := by\n  rw [prod_list_count]\n  refine prod_subset hs fun x _ hx => ?_\n  rw [mem_toFinset] at hx\n  rw [count_eq_zero_of_not_mem hx, pow_zero]\n\n"}
{"name":"Finset.sum_list_count_of_subset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\ninst✝ : AddCommMonoid α\nm : List α\ns : Finset α\nhs : HasSubset.Subset m.toFinset s\n⊢ Eq m.sum (s.sum fun i => HSMul.hSMul (List.count i m) i)","decl":"@[to_additive]\ntheorem prod_list_count_of_subset [DecidableEq α] [CommMonoid α] (m : List α) (s : Finset α)\n    (hs : m.toFinset ⊆ s) : m.prod = ∏ i ∈ s, i ^ m.count i := by\n  rw [prod_list_count]\n  refine prod_subset hs fun x _ hx => ?_\n  rw [mem_toFinset] at hx\n  rw [count_eq_zero_of_not_mem hx, pow_zero]\n\n"}
{"name":"Finset.prod_multiset_map_count","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\ns : Multiset α\nM : Type u_6\ninst✝ : CommMonoid M\nf : α → M\n⊢ Eq (Multiset.map f s).prod (s.toFinset.prod fun m => HPow.hPow (f m) (Multiset.count m s))","decl":"@[to_additive]\ntheorem prod_multiset_map_count [DecidableEq α] (s : Multiset α) {M : Type*} [CommMonoid M]\n    (f : α → M) : (s.map f).prod = ∏ m ∈ s.toFinset, f m ^ s.count m := by\n  refine Quot.induction_on s fun l => ?_\n  simp [prod_list_map_count l f]\n\n"}
{"name":"Finset.sum_multiset_map_count","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\ns : Multiset α\nM : Type u_6\ninst✝ : AddCommMonoid M\nf : α → M\n⊢ Eq (Multiset.map f s).sum (s.toFinset.sum fun m => HSMul.hSMul (Multiset.count m s) (f m))","decl":"@[to_additive]\ntheorem prod_multiset_map_count [DecidableEq α] (s : Multiset α) {M : Type*} [CommMonoid M]\n    (f : α → M) : (s.map f).prod = ∏ m ∈ s.toFinset, f m ^ s.count m := by\n  refine Quot.induction_on s fun l => ?_\n  simp [prod_list_map_count l f]\n\n"}
{"name":"Finset.prod_multiset_count","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\ninst✝ : CommMonoid α\ns : Multiset α\n⊢ Eq s.prod (s.toFinset.prod fun m => HPow.hPow m (Multiset.count m s))","decl":"@[to_additive]\ntheorem prod_multiset_count [DecidableEq α] [CommMonoid α] (s : Multiset α) :\n    s.prod = ∏ m ∈ s.toFinset, m ^ s.count m := by\n  convert prod_multiset_map_count s id\n  rw [Multiset.map_id]\n\n"}
{"name":"Finset.sum_multiset_count","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\ninst✝ : AddCommMonoid α\ns : Multiset α\n⊢ Eq s.sum (s.toFinset.sum fun m => HSMul.hSMul (Multiset.count m s) m)","decl":"@[to_additive]\ntheorem prod_multiset_count [DecidableEq α] [CommMonoid α] (s : Multiset α) :\n    s.prod = ∏ m ∈ s.toFinset, m ^ s.count m := by\n  convert prod_multiset_map_count s id\n  rw [Multiset.map_id]\n\n"}
{"name":"Finset.sum_multiset_count_of_subset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\ninst✝ : AddCommMonoid α\nm : Multiset α\ns : Finset α\nhs : HasSubset.Subset m.toFinset s\n⊢ Eq m.sum (s.sum fun i => HSMul.hSMul (Multiset.count i m) i)","decl":"@[to_additive]\ntheorem prod_multiset_count_of_subset [DecidableEq α] [CommMonoid α] (m : Multiset α) (s : Finset α)\n    (hs : m.toFinset ⊆ s) : m.prod = ∏ i ∈ s, i ^ m.count i := by\n  revert hs\n  refine Quot.induction_on m fun l => ?_\n  simp only [quot_mk_to_coe'', prod_coe, coe_count]\n  apply prod_list_count_of_subset l s\n\n"}
{"name":"Finset.prod_multiset_count_of_subset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : DecidableEq α\ninst✝ : CommMonoid α\nm : Multiset α\ns : Finset α\nhs : HasSubset.Subset m.toFinset s\n⊢ Eq m.prod (s.prod fun i => HPow.hPow i (Multiset.count i m))","decl":"@[to_additive]\ntheorem prod_multiset_count_of_subset [DecidableEq α] [CommMonoid α] (m : Multiset α) (s : Finset α)\n    (hs : m.toFinset ⊆ s) : m.prod = ∏ i ∈ s, i ^ m.count i := by\n  revert hs\n  refine Quot.induction_on m fun l => ?_\n  simp only [quot_mk_to_coe'', prod_coe, coe_count]\n  apply prod_list_count_of_subset l s\n\n"}
{"name":"Finset.sum_range_induction","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : AddCommMonoid β\nf s : Nat → β\nbase : Eq (s 0) 0\nstep : ∀ (n : Nat), Eq (s (HAdd.hAdd n 1)) (HAdd.hAdd (s n) (f n))\nn : Nat\n⊢ Eq ((Finset.range n).sum fun k => f k) (s n)","decl":"/-- For any product along `{0, ..., n - 1}` of a commutative-monoid-valued function, we can verify\nthat it's equal to a different function just by checking ratios of adjacent terms.\n\nThis is a multiplicative discrete analogue of the fundamental theorem of calculus. -/\n@[to_additive \"For any sum along `{0, ..., n - 1}` of a commutative-monoid-valued function, we can\nverify that it's equal to a different function just by checking differences of adjacent terms.\n\nThis is a discrete analogue of the fundamental theorem of calculus.\"]\ntheorem prod_range_induction (f s : ℕ → β) (base : s 0 = 1)\n    (step : ∀ n, s (n + 1) = s n * f n) (n : ℕ) :\n    ∏ k ∈ Finset.range n, f k = s n := by\n  induction n with\n  | zero => rw [Finset.prod_range_zero, base]\n  | succ k hk => simp only [hk, Finset.prod_range_succ, step, mul_comm]\n\n"}
{"name":"Finset.prod_range_induction","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : CommMonoid β\nf s : Nat → β\nbase : Eq (s 0) 1\nstep : ∀ (n : Nat), Eq (s (HAdd.hAdd n 1)) (HMul.hMul (s n) (f n))\nn : Nat\n⊢ Eq ((Finset.range n).prod fun k => f k) (s n)","decl":"/-- For any product along `{0, ..., n - 1}` of a commutative-monoid-valued function, we can verify\nthat it's equal to a different function just by checking ratios of adjacent terms.\n\nThis is a multiplicative discrete analogue of the fundamental theorem of calculus. -/\n@[to_additive \"For any sum along `{0, ..., n - 1}` of a commutative-monoid-valued function, we can\nverify that it's equal to a different function just by checking differences of adjacent terms.\n\nThis is a discrete analogue of the fundamental theorem of calculus.\"]\ntheorem prod_range_induction (f s : ℕ → β) (base : s 0 = 1)\n    (step : ∀ n, s (n + 1) = s n * f n) (n : ℕ) :\n    ∏ k ∈ Finset.range n, f k = s n := by\n  induction n with\n  | zero => rw [Finset.prod_range_zero, base]\n  | succ k hk => simp only [hk, Finset.prod_range_succ, step, mul_comm]\n\n"}
{"name":"Finset.sum_range_sub","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"M : Type u_6\ninst✝ : AddCommGroup M\nf : Nat → M\nn : Nat\n⊢ Eq ((Finset.range n).sum fun i => HSub.hSub (f (HAdd.hAdd i 1)) (f i)) (HSub.hSub (f n) (f 0))","decl":"/-- A telescoping product along `{0, ..., n - 1}` of a commutative group valued function reduces to\nthe ratio of the last and first factors. -/\n@[to_additive \"A telescoping sum along `{0, ..., n - 1}` of an additive commutative group valued\nfunction reduces to the difference of the last and first terms.\"]\ntheorem prod_range_div {M : Type*} [CommGroup M] (f : ℕ → M) (n : ℕ) :\n    (∏ i ∈ range n, f (i + 1) / f i) = f n / f 0 := by apply prod_range_induction <;> simp\n\n"}
{"name":"Finset.prod_range_div","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"M : Type u_6\ninst✝ : CommGroup M\nf : Nat → M\nn : Nat\n⊢ Eq ((Finset.range n).prod fun i => HDiv.hDiv (f (HAdd.hAdd i 1)) (f i)) (HDiv.hDiv (f n) (f 0))","decl":"/-- A telescoping product along `{0, ..., n - 1}` of a commutative group valued function reduces to\nthe ratio of the last and first factors. -/\n@[to_additive \"A telescoping sum along `{0, ..., n - 1}` of an additive commutative group valued\nfunction reduces to the difference of the last and first terms.\"]\ntheorem prod_range_div {M : Type*} [CommGroup M] (f : ℕ → M) (n : ℕ) :\n    (∏ i ∈ range n, f (i + 1) / f i) = f n / f 0 := by apply prod_range_induction <;> simp\n\n"}
{"name":"Finset.prod_range_div'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"M : Type u_6\ninst✝ : CommGroup M\nf : Nat → M\nn : Nat\n⊢ Eq ((Finset.range n).prod fun i => HDiv.hDiv (f i) (f (HAdd.hAdd i 1))) (HDiv.hDiv (f 0) (f n))","decl":"@[to_additive]\ntheorem prod_range_div' {M : Type*} [CommGroup M] (f : ℕ → M) (n : ℕ) :\n    (∏ i ∈ range n, f i / f (i + 1)) = f 0 / f n := by apply prod_range_induction <;> simp\n\n"}
{"name":"Finset.sum_range_sub'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"M : Type u_6\ninst✝ : AddCommGroup M\nf : Nat → M\nn : Nat\n⊢ Eq ((Finset.range n).sum fun i => HSub.hSub (f i) (f (HAdd.hAdd i 1))) (HSub.hSub (f 0) (f n))","decl":"@[to_additive]\ntheorem prod_range_div' {M : Type*} [CommGroup M] (f : ℕ → M) (n : ℕ) :\n    (∏ i ∈ range n, f i / f (i + 1)) = f 0 / f n := by apply prod_range_induction <;> simp\n\n"}
{"name":"Finset.eq_prod_range_div","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"M : Type u_6\ninst✝ : CommGroup M\nf : Nat → M\nn : Nat\n⊢ Eq (f n) (HMul.hMul (f 0) ((Finset.range n).prod fun i => HDiv.hDiv (f (HAdd.hAdd i 1)) (f i)))","decl":"@[to_additive]\ntheorem eq_prod_range_div {M : Type*} [CommGroup M] (f : ℕ → M) (n : ℕ) :\n    f n = f 0 * ∏ i ∈ range n, f (i + 1) / f i := by rw [prod_range_div, mul_div_cancel]\n\n"}
{"name":"Finset.eq_sum_range_sub","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"M : Type u_6\ninst✝ : AddCommGroup M\nf : Nat → M\nn : Nat\n⊢ Eq (f n) (HAdd.hAdd (f 0) ((Finset.range n).sum fun i => HSub.hSub (f (HAdd.hAdd i 1)) (f i)))","decl":"@[to_additive]\ntheorem eq_prod_range_div {M : Type*} [CommGroup M] (f : ℕ → M) (n : ℕ) :\n    f n = f 0 * ∏ i ∈ range n, f (i + 1) / f i := by rw [prod_range_div, mul_div_cancel]\n\n"}
{"name":"Finset.eq_prod_range_div'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"M : Type u_6\ninst✝ : CommGroup M\nf : Nat → M\nn : Nat\n⊢ Eq (f n) ((Finset.range (HAdd.hAdd n 1)).prod fun i => ite (Eq i 0) (f 0) (HDiv.hDiv (f i) (f (HSub.hSub i 1))))","decl":"@[to_additive]\ntheorem eq_prod_range_div' {M : Type*} [CommGroup M] (f : ℕ → M) (n : ℕ) :\n    f n = ∏ i ∈ range (n + 1), if i = 0 then f 0 else f i / f (i - 1) := by\n  conv_lhs => rw [Finset.eq_prod_range_div f]\n  simp [Finset.prod_range_succ', mul_comm]\n\n"}
{"name":"Finset.eq_sum_range_sub'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"M : Type u_6\ninst✝ : AddCommGroup M\nf : Nat → M\nn : Nat\n⊢ Eq (f n) ((Finset.range (HAdd.hAdd n 1)).sum fun i => ite (Eq i 0) (f 0) (HSub.hSub (f i) (f (HSub.hSub i 1))))","decl":"@[to_additive]\ntheorem eq_prod_range_div' {M : Type*} [CommGroup M] (f : ℕ → M) (n : ℕ) :\n    f n = ∏ i ∈ range (n + 1), if i = 0 then f 0 else f i / f (i - 1) := by\n  conv_lhs => rw [Finset.eq_prod_range_div f]\n  simp [Finset.prod_range_succ', mul_comm]\n\n"}
{"name":"Finset.sum_range_tsub","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝⁶ : AddCommMonoid α\ninst✝⁵ : PartialOrder α\ninst✝⁴ : Sub α\ninst✝³ : OrderedSub α\ninst✝² : AddLeftMono α\ninst✝¹ : AddLeftReflectLE α\ninst✝ : ExistsAddOfLE α\nf : Nat → α\nh : Monotone f\nn : Nat\n⊢ Eq ((Finset.range n).sum fun i => HSub.hSub (f (HAdd.hAdd i 1)) (f i)) (HSub.hSub (f n) (f 0))","decl":"/-- A telescoping sum along `{0, ..., n-1}` of an `ℕ`-valued function\nreduces to the difference of the last and first terms\nwhen the function we are summing is monotone.\n-/\ntheorem sum_range_tsub [AddCommMonoid α] [PartialOrder α] [Sub α] [OrderedSub α]\n    [AddLeftMono α] [AddLeftReflectLE α] [ExistsAddOfLE α]\n    {f : ℕ → α} (h : Monotone f) (n : ℕ) :\n    ∑ i ∈ range n, (f (i + 1) - f i) = f n - f 0 := by\n  apply sum_range_induction\n  case base => apply tsub_eq_of_eq_add; rw [zero_add]\n  case step =>\n    intro n\n    have h₁ : f n ≤ f (n + 1) := h (Nat.le_succ _)\n    have h₂ : f 0 ≤ f n := h (Nat.zero_le _)\n    rw [tsub_add_eq_add_tsub h₂, add_tsub_cancel_of_le h₁]\n\n"}
{"name":"Finset.sum_tsub_distrib","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝⁶ : AddCommMonoid α\ninst✝⁵ : PartialOrder α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : CovariantClass α α (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\ninst✝² : ContravariantClass α α (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\ninst✝¹ : Sub α\ninst✝ : OrderedSub α\ns : Finset ι\nf g : ι → α\nhfg : ∀ (x : ι), Membership.mem s x → LE.le (g x) (f x)\n⊢ Eq (s.sum fun x => HSub.hSub (f x) (g x)) (HSub.hSub (s.sum fun x => f x) (s.sum fun x => g x))","decl":"theorem sum_tsub_distrib [AddCommMonoid α] [PartialOrder α] [ExistsAddOfLE α]\n    [CovariantClass α α (· + ·) (· ≤ ·)] [ContravariantClass α α (· + ·) (· ≤ ·)] [Sub α]\n    [OrderedSub α] (s : Finset ι) {f g : ι → α} (hfg : ∀ x ∈ s, g x ≤ f x) :\n    ∑ x ∈ s, (f x - g x) = ∑ x ∈ s, f x - ∑ x ∈ s, g x := sum_map_tsub _ hfg\n\n"}
{"name":"Finset.prod_const","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : CommMonoid β\nb : β\n⊢ Eq (s.prod fun _x => b) (HPow.hPow b s.card)","decl":"@[to_additive (attr := simp)]\ntheorem prod_const (b : β) : ∏ _x ∈ s, b = b ^ #s :=\n  (congr_arg _ <| s.val.map_const b).trans <| Multiset.prod_replicate #s b\n\n"}
{"name":"Finset.sum_const","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\ninst✝ : AddCommMonoid β\nb : β\n⊢ Eq (s.sum fun _x => b) (HSMul.hSMul s.card b)","decl":"@[to_additive (attr := simp)]\ntheorem prod_const (b : β) : ∏ _x ∈ s, b = b ^ #s :=\n  (congr_arg _ <| s.val.map_const b).trans <| Multiset.prod_replicate #s b\n\n"}
{"name":"Finset.prod_eq_pow_card","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : CommMonoid β\nb : β\nhf : ∀ (a : α), Membership.mem s a → Eq (f a) b\n⊢ Eq (s.prod fun a => f a) (HPow.hPow b s.card)","decl":"@[to_additive sum_eq_card_nsmul]\ntheorem prod_eq_pow_card {b : β} (hf : ∀ a ∈ s, f a = b) : ∏ a ∈ s, f a = b ^ #s :=\n  (prod_congr rfl hf).trans <| prod_const _\n\n"}
{"name":"Finset.sum_eq_card_nsmul","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : AddCommMonoid β\nb : β\nhf : ∀ (a : α), Membership.mem s a → Eq (f a) b\n⊢ Eq (s.sum fun a => f a) (HSMul.hSMul s.card b)","decl":"@[to_additive sum_eq_card_nsmul]\ntheorem prod_eq_pow_card {b : β} (hf : ∀ a ∈ s, f a = b) : ∏ a ∈ s, f a = b ^ #s :=\n  (prod_congr rfl hf).trans <| prod_const _\n\n"}
{"name":"Finset.pow_card_mul_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : CommMonoid β\nb : β\n⊢ Eq (HMul.hMul (HPow.hPow b s.card) (s.prod fun a => f a)) (s.prod fun a => HMul.hMul b (f a))","decl":"@[to_additive card_nsmul_add_sum]\ntheorem pow_card_mul_prod {b : β} : b ^ #s * ∏ a ∈ s, f a = ∏ a ∈ s, b * f a :=\n  (Finset.prod_const b).symm ▸ prod_mul_distrib.symm\n\n"}
{"name":"Finset.card_nsmul_add_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : AddCommMonoid β\nb : β\n⊢ Eq (HAdd.hAdd (HSMul.hSMul s.card b) (s.sum fun a => f a)) (s.sum fun a => HAdd.hAdd b (f a))","decl":"@[to_additive card_nsmul_add_sum]\ntheorem pow_card_mul_prod {b : β} : b ^ #s * ∏ a ∈ s, f a = ∏ a ∈ s, b * f a :=\n  (Finset.prod_const b).symm ▸ prod_mul_distrib.symm\n\n"}
{"name":"Finset.prod_mul_pow_card","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : CommMonoid β\nb : β\n⊢ Eq (HMul.hMul (s.prod fun a => f a) (HPow.hPow b s.card)) (s.prod fun a => HMul.hMul (f a) b)","decl":"@[to_additive sum_add_card_nsmul]\ntheorem prod_mul_pow_card {b : β} : (∏ a ∈ s, f a) * b ^ #s = ∏ a ∈ s, f a * b :=\n  (Finset.prod_const b).symm ▸ prod_mul_distrib.symm\n\n"}
{"name":"Finset.sum_add_card_nsmul","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : AddCommMonoid β\nb : β\n⊢ Eq (HAdd.hAdd (s.sum fun a => f a) (HSMul.hSMul s.card b)) (s.sum fun a => HAdd.hAdd (f a) b)","decl":"@[to_additive sum_add_card_nsmul]\ntheorem prod_mul_pow_card {b : β} : (∏ a ∈ s, f a) * b ^ #s = ∏ a ∈ s, f a * b :=\n  (Finset.prod_const b).symm ▸ prod_mul_distrib.symm\n\n"}
{"name":"Finset.pow_eq_prod_const","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : CommMonoid β\nb : β\nn : Nat\n⊢ Eq (HPow.hPow b n) ((Finset.range n).prod fun _k => b)","decl":"@[to_additive]\ntheorem pow_eq_prod_const (b : β) : ∀ n, b ^ n = ∏ _k ∈ range n, b := by simp\n\n"}
{"name":"Finset.nsmul_eq_sum_const","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : AddCommMonoid β\nb : β\nn : Nat\n⊢ Eq (HSMul.hSMul n b) ((Finset.range n).sum fun _k => b)","decl":"@[to_additive]\ntheorem pow_eq_prod_const (b : β) : ∀ n, b ^ n = ∏ _k ∈ range n, b := by simp\n\n"}
{"name":"Finset.sum_nsmul_assoc","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset ι\nf : ι → Nat\na : β\n⊢ Eq (s.sum fun i => HSMul.hSMul (f i) a) (HSMul.hSMul (s.sum fun i => f i) a)","decl":"@[to_additive sum_nsmul_assoc]\nlemma prod_pow_eq_pow_sum (s : Finset ι) (f : ι → ℕ) (a : β) :\n    ∏ i ∈ s, a ^ f i = a ^ ∑ i ∈ s, f i :=\n  cons_induction (by simp) (fun _ _ _ _ ↦ by simp [prod_cons, sum_cons, pow_add, *]) s\n\n"}
{"name":"Finset.prod_pow_eq_pow_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset ι\nf : ι → Nat\na : β\n⊢ Eq (s.prod fun i => HPow.hPow a (f i)) (HPow.hPow a (s.sum fun i => f i))","decl":"@[to_additive sum_nsmul_assoc]\nlemma prod_pow_eq_pow_sum (s : Finset ι) (f : ι → ℕ) (a : β) :\n    ∏ i ∈ s, a ^ f i = a ^ ∑ i ∈ s, f i :=\n  cons_induction (by simp) (fun _ _ _ _ ↦ by simp [prod_cons, sum_cons, pow_add, *]) s\n\n"}
{"name":"Finset.sum_powersetCard","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\nn : Nat\ns : Finset α\nf : Nat → β\n⊢ Eq ((Finset.powersetCard n s).sum fun t => f t.card) (HSMul.hSMul (s.card.choose n) (f n))","decl":"/-- A product over `Finset.powersetCard` which only depends on the size of the sets is constant. -/\n@[to_additive\n\"A sum over `Finset.powersetCard` which only depends on the size of the sets is constant.\"]\nlemma prod_powersetCard (n : ℕ) (s : Finset α) (f : ℕ → β) :\n    ∏ t ∈ powersetCard n s, f #t = f n ^ (#s).choose n := by\n  rw [prod_eq_pow_card, card_powersetCard]; rintro a ha; rw [(mem_powersetCard.1 ha).2]\n\n"}
{"name":"Finset.prod_powersetCard","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\nn : Nat\ns : Finset α\nf : Nat → β\n⊢ Eq ((Finset.powersetCard n s).prod fun t => f t.card) (HPow.hPow (f n) (s.card.choose n))","decl":"/-- A product over `Finset.powersetCard` which only depends on the size of the sets is constant. -/\n@[to_additive\n\"A sum over `Finset.powersetCard` which only depends on the size of the sets is constant.\"]\nlemma prod_powersetCard (n : ℕ) (s : Finset α) (f : ℕ → β) :\n    ∏ t ∈ powersetCard n s, f #t = f n ^ (#s).choose n := by\n  rw [prod_eq_pow_card, card_powersetCard]; rintro a ha; rw [(mem_powersetCard.1 ha).2]\n\n"}
{"name":"Finset.prod_flip","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : CommMonoid β\nn : Nat\nf : Nat → β\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).prod fun r => f (HSub.hSub n r)) ((Finset.range (HAdd.hAdd n 1)).prod fun k => f k)","decl":"@[to_additive]\ntheorem prod_flip {n : ℕ} (f : ℕ → β) :\n    (∏ r ∈ range (n + 1), f (n - r)) = ∏ k ∈ range (n + 1), f k := by\n  induction n with\n  | zero => rw [prod_range_one, prod_range_one]\n  | succ n ih =>\n    rw [prod_range_succ', prod_range_succ _ (Nat.succ n)]\n    simp [← ih]\n\n"}
{"name":"Finset.sum_flip","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_4\ninst✝ : AddCommMonoid β\nn : Nat\nf : Nat → β\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun r => f (HSub.hSub n r)) ((Finset.range (HAdd.hAdd n 1)).sum fun k => f k)","decl":"@[to_additive]\ntheorem prod_flip {n : ℕ} (f : ℕ → β) :\n    (∏ r ∈ range (n + 1), f (n - r)) = ∏ k ∈ range (n + 1), f k := by\n  induction n with\n  | zero => rw [prod_range_one, prod_range_one]\n  | succ n ih =>\n    rw [prod_range_succ', prod_range_succ _ (Nat.succ n)]\n    simp [← ih]\n\n"}
{"name":"Finset.sum_involution","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : AddCommMonoid β\ng : (a : α) → Membership.mem s a → α\nhg₁ : ∀ (a : α) (ha : Membership.mem s a), Eq (HAdd.hAdd (f a) (f (g a ha))) 0\nhg₃ : ∀ (a : α) (ha : Membership.mem s a), Ne (f a) 0 → Ne (g a ha) a\ng_mem : ∀ (a : α) (ha : Membership.mem s a), Membership.mem s (g a ha)\nhg₄ : ∀ (a : α) (ha : Membership.mem s a), Eq (g (g a ha) ⋯) a\n⊢ Eq (s.sum fun x => f x) 0","decl":"/-- The difference with `Finset.prod_ninvolution` is that the involution is allowed to use\nmembership of the domain of the product, rather than being a non-dependent function. -/\n@[to_additive \"The difference with `Finset.sum_ninvolution` is that the involution is allowed to use\nmembership of the domain of the sum, rather than being a non-dependent function.\"]\nlemma prod_involution (g : ∀ a ∈ s, α) (hg₁ : ∀ a ha, f a * f (g a ha) = 1)\n    (hg₃ : ∀ a ha, f a ≠ 1 → g a ha ≠ a)\n    (g_mem : ∀ a ha, g a ha ∈ s) (hg₄ : ∀ a ha, g (g a ha) (g_mem a ha) = a) :\n    ∏ x ∈ s, f x = 1 := by\n  classical\n  induction s using Finset.strongInduction with | H s ih => ?_\n  obtain rfl | ⟨x, hx⟩ := s.eq_empty_or_nonempty\n  · simp\n  have : {x, g x hx} ⊆ s := by simp [insert_subset_iff, hx, g_mem]\n  suffices h : ∏ x ∈ s \\ {x, g x hx}, f x = 1 by\n    rw [← prod_sdiff this, h, one_mul]\n    cases eq_or_ne (g x hx) x with\n    | inl hx' => simpa [hx'] using hg₃ x hx\n    | inr hx' => rw [prod_pair hx'.symm, hg₁]\n  suffices h₃ : ∀ a (ha : a ∈ s \\ {x, g x hx}), g a (sdiff_subset ha) ∈ s \\ {x, g x hx} from\n    ih (s \\ {x, g x hx}) (ssubset_iff.2 ⟨x, by simp [insert_subset_iff, hx]⟩) _\n      (by simp [hg₁]) (fun _ _ => hg₃ _ _) h₃ (fun _ _ => hg₄ _ _)\n  simp only [mem_sdiff, mem_insert, mem_singleton, not_or, g_mem, true_and]\n  rintro a ⟨ha₁, ha₂, ha₃⟩\n  refine ⟨fun h => by simp [← h, hg₄] at ha₃, fun h => ?_⟩\n  have : g (g a ha₁) (g_mem _ _) = g (g x hx) (g_mem _ _) := by simp only [h]\n  exact ha₂ (by simpa [hg₄] using this)\n\n"}
{"name":"Finset.prod_involution","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : CommMonoid β\ng : (a : α) → Membership.mem s a → α\nhg₁ : ∀ (a : α) (ha : Membership.mem s a), Eq (HMul.hMul (f a) (f (g a ha))) 1\nhg₃ : ∀ (a : α) (ha : Membership.mem s a), Ne (f a) 1 → Ne (g a ha) a\ng_mem : ∀ (a : α) (ha : Membership.mem s a), Membership.mem s (g a ha)\nhg₄ : ∀ (a : α) (ha : Membership.mem s a), Eq (g (g a ha) ⋯) a\n⊢ Eq (s.prod fun x => f x) 1","decl":"/-- The difference with `Finset.prod_ninvolution` is that the involution is allowed to use\nmembership of the domain of the product, rather than being a non-dependent function. -/\n@[to_additive \"The difference with `Finset.sum_ninvolution` is that the involution is allowed to use\nmembership of the domain of the sum, rather than being a non-dependent function.\"]\nlemma prod_involution (g : ∀ a ∈ s, α) (hg₁ : ∀ a ha, f a * f (g a ha) = 1)\n    (hg₃ : ∀ a ha, f a ≠ 1 → g a ha ≠ a)\n    (g_mem : ∀ a ha, g a ha ∈ s) (hg₄ : ∀ a ha, g (g a ha) (g_mem a ha) = a) :\n    ∏ x ∈ s, f x = 1 := by\n  classical\n  induction s using Finset.strongInduction with | H s ih => ?_\n  obtain rfl | ⟨x, hx⟩ := s.eq_empty_or_nonempty\n  · simp\n  have : {x, g x hx} ⊆ s := by simp [insert_subset_iff, hx, g_mem]\n  suffices h : ∏ x ∈ s \\ {x, g x hx}, f x = 1 by\n    rw [← prod_sdiff this, h, one_mul]\n    cases eq_or_ne (g x hx) x with\n    | inl hx' => simpa [hx'] using hg₃ x hx\n    | inr hx' => rw [prod_pair hx'.symm, hg₁]\n  suffices h₃ : ∀ a (ha : a ∈ s \\ {x, g x hx}), g a (sdiff_subset ha) ∈ s \\ {x, g x hx} from\n    ih (s \\ {x, g x hx}) (ssubset_iff.2 ⟨x, by simp [insert_subset_iff, hx]⟩) _\n      (by simp [hg₁]) (fun _ _ => hg₃ _ _) h₃ (fun _ _ => hg₄ _ _)\n  simp only [mem_sdiff, mem_insert, mem_singleton, not_or, g_mem, true_and]\n  rintro a ⟨ha₁, ha₂, ha₃⟩\n  refine ⟨fun h => by simp [← h, hg₄] at ha₃, fun h => ?_⟩\n  have : g (g a ha₁) (g_mem _ _) = g (g x hx) (g_mem _ _) := by simp only [h]\n  exact ha₂ (by simpa [hg₄] using this)\n\n"}
{"name":"Finset.sum_ninvolution","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : AddCommMonoid β\ng : α → α\nhg₁ : ∀ (a : α), Eq (HAdd.hAdd (f a) (f (g a))) 0\nhg₂ : ∀ (a : α), Ne (f a) 0 → Ne (g a) a\ng_mem : ∀ (a : α), Membership.mem s (g a)\nhg₃ : ∀ (a : α), Eq (g (g a)) a\n⊢ Eq (s.sum fun x => f x) 0","decl":"/-- The difference with `Finset.prod_involution` is that the involution is a non-dependent function,\nrather than being allowed to use membership of the domain of the product. -/\n@[to_additive \"The difference with `Finset.sum_involution` is that the involution is a non-dependent\nfunction, rather than being allowed to use membership of the domain of the sum.\"]\nlemma prod_ninvolution (g : α → α) (hg₁ : ∀ a, f a * f (g a) = 1) (hg₂ : ∀ a, f a ≠ 1 → g a ≠ a)\n    (g_mem : ∀ a, g a ∈ s) (hg₃ : ∀ a, g (g a) = a) : ∏ x ∈ s, f x = 1 :=\n  prod_involution (fun i _ => g i) (fun i _ => hg₁ i) (fun _ _ hi => hg₂ _ hi)\n    (fun i _ => g_mem i) (fun i _ => hg₃ i)\n\n"}
{"name":"Finset.prod_ninvolution","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : CommMonoid β\ng : α → α\nhg₁ : ∀ (a : α), Eq (HMul.hMul (f a) (f (g a))) 1\nhg₂ : ∀ (a : α), Ne (f a) 1 → Ne (g a) a\ng_mem : ∀ (a : α), Membership.mem s (g a)\nhg₃ : ∀ (a : α), Eq (g (g a)) a\n⊢ Eq (s.prod fun x => f x) 1","decl":"/-- The difference with `Finset.prod_involution` is that the involution is a non-dependent function,\nrather than being allowed to use membership of the domain of the product. -/\n@[to_additive \"The difference with `Finset.sum_involution` is that the involution is a non-dependent\nfunction, rather than being allowed to use membership of the domain of the sum.\"]\nlemma prod_ninvolution (g : α → α) (hg₁ : ∀ a, f a * f (g a) = 1) (hg₂ : ∀ a, f a ≠ 1 → g a ≠ a)\n    (g_mem : ∀ a, g a ∈ s) (hg₃ : ∀ a, g (g a) = a) : ∏ x ∈ s, f x = 1 :=\n  prod_involution (fun i _ => g i) (fun i _ => hg₁ i) (fun _ _ hi => hg₂ _ hi)\n    (fun i _ => g_mem i) (fun i _ => hg₃ i)\n\n"}
{"name":"Finset.sum_comp","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ns : Finset α\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq γ\nf : γ → β\ng : α → γ\n⊢ Eq (s.sum fun a => f (g a)) ((Finset.image g s).sum fun b => HSMul.hSMul (Finset.filter (fun a => Eq (g a) b) s).card (f b))","decl":"/-- The product of the composition of functions `f` and `g`, is the product over `b ∈ s.image g` of\n`f b` to the power of the cardinality of the fibre of `b`. See also `Finset.prod_image`. -/\n@[to_additive \"The sum of the composition of functions `f` and `g`, is the sum over `b ∈ s.image g`\nof `f b` times of the cardinality of the fibre of `b`. See also `Finset.sum_image`.\"]\ntheorem prod_comp [DecidableEq γ] (f : γ → β) (g : α → γ) :\n    ∏ a ∈ s, f (g a) = ∏ b ∈ s.image g, f b ^ #{a ∈ s | g a = b} := by\n  simp_rw [← prod_const, prod_fiberwise_of_maps_to' fun _ ↦ mem_image_of_mem _]\n\n"}
{"name":"Finset.prod_comp","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\ns : Finset α\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq γ\nf : γ → β\ng : α → γ\n⊢ Eq (s.prod fun a => f (g a)) ((Finset.image g s).prod fun b => HPow.hPow (f b) (Finset.filter (fun a => Eq (g a) b) s).card)","decl":"/-- The product of the composition of functions `f` and `g`, is the product over `b ∈ s.image g` of\n`f b` to the power of the cardinality of the fibre of `b`. See also `Finset.prod_image`. -/\n@[to_additive \"The sum of the composition of functions `f` and `g`, is the sum over `b ∈ s.image g`\nof `f b` times of the cardinality of the fibre of `b`. See also `Finset.sum_image`.\"]\ntheorem prod_comp [DecidableEq γ] (f : γ → β) (g : α → γ) :\n    ∏ a ∈ s, f (g a) = ∏ b ∈ s.image g, f b ^ #{a ∈ s | g a = b} := by\n  simp_rw [← prod_const, prod_fiberwise_of_maps_to' fun _ ↦ mem_image_of_mem _]\n\n"}
{"name":"Finset.prod_piecewise","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns t : Finset α\nf g : α → β\n⊢ Eq (s.prod fun x => t.piecewise f g x) (HMul.hMul ((Inter.inter s t).prod fun x => f x) ((SDiff.sdiff s t).prod fun x => g x))","decl":"@[to_additive]\ntheorem prod_piecewise [DecidableEq α] (s t : Finset α) (f g : α → β) :\n    (∏ x ∈ s, (t.piecewise f g) x) = (∏ x ∈ s ∩ t, f x) * ∏ x ∈ s \\ t, g x := by\n  erw [prod_ite, filter_mem_eq_inter, ← sdiff_eq_filter]\n\n"}
{"name":"Finset.sum_piecewise","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns t : Finset α\nf g : α → β\n⊢ Eq (s.sum fun x => t.piecewise f g x) (HAdd.hAdd ((Inter.inter s t).sum fun x => f x) ((SDiff.sdiff s t).sum fun x => g x))","decl":"@[to_additive]\ntheorem prod_piecewise [DecidableEq α] (s t : Finset α) (f g : α → β) :\n    (∏ x ∈ s, (t.piecewise f g) x) = (∏ x ∈ s ∩ t, f x) * ∏ x ∈ s \\ t, g x := by\n  erw [prod_ite, filter_mem_eq_inter, ← sdiff_eq_filter]\n\n"}
{"name":"Finset.prod_inter_mul_prod_diff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns t : Finset α\nf : α → β\n⊢ Eq (HMul.hMul ((Inter.inter s t).prod fun x => f x) ((SDiff.sdiff s t).prod fun x => f x)) (s.prod fun x => f x)","decl":"@[to_additive]\ntheorem prod_inter_mul_prod_diff [DecidableEq α] (s t : Finset α) (f : α → β) :\n    (∏ x ∈ s ∩ t, f x) * ∏ x ∈ s \\ t, f x = ∏ x ∈ s, f x := by\n  convert (s.prod_piecewise t f f).symm\n  simp (config := { unfoldPartialApp := true }) [Finset.piecewise]\n\n"}
{"name":"Finset.sum_inter_add_sum_diff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns t : Finset α\nf : α → β\n⊢ Eq (HAdd.hAdd ((Inter.inter s t).sum fun x => f x) ((SDiff.sdiff s t).sum fun x => f x)) (s.sum fun x => f x)","decl":"@[to_additive]\ntheorem prod_inter_mul_prod_diff [DecidableEq α] (s t : Finset α) (f : α → β) :\n    (∏ x ∈ s ∩ t, f x) * ∏ x ∈ s \\ t, f x = ∏ x ∈ s, f x := by\n  convert (s.prod_piecewise t f f).symm\n  simp (config := { unfoldPartialApp := true }) [Finset.piecewise]\n\n"}
{"name":"Finset.prod_eq_mul_prod_diff_singleton","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\ni : α\nh : Membership.mem s i\nf : α → β\n⊢ Eq (s.prod fun x => f x) (HMul.hMul (f i) ((SDiff.sdiff s (Singleton.singleton i)).prod fun x => f x))","decl":"@[to_additive]\ntheorem prod_eq_mul_prod_diff_singleton [DecidableEq α] {s : Finset α} {i : α} (h : i ∈ s)\n    (f : α → β) : ∏ x ∈ s, f x = f i * ∏ x ∈ s \\ {i}, f x := by\n  convert (s.prod_inter_mul_prod_diff {i} f).symm\n  simp [h]\n\n"}
{"name":"Finset.sum_eq_add_sum_diff_singleton","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\ni : α\nh : Membership.mem s i\nf : α → β\n⊢ Eq (s.sum fun x => f x) (HAdd.hAdd (f i) ((SDiff.sdiff s (Singleton.singleton i)).sum fun x => f x))","decl":"@[to_additive]\ntheorem prod_eq_mul_prod_diff_singleton [DecidableEq α] {s : Finset α} {i : α} (h : i ∈ s)\n    (f : α → β) : ∏ x ∈ s, f x = f i * ∏ x ∈ s \\ {i}, f x := by\n  convert (s.prod_inter_mul_prod_diff {i} f).symm\n  simp [h]\n\n"}
{"name":"Finset.prod_eq_prod_diff_singleton_mul","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\ni : α\nh : Membership.mem s i\nf : α → β\n⊢ Eq (s.prod fun x => f x) (HMul.hMul ((SDiff.sdiff s (Singleton.singleton i)).prod fun x => f x) (f i))","decl":"@[to_additive]\ntheorem prod_eq_prod_diff_singleton_mul [DecidableEq α] {s : Finset α} {i : α} (h : i ∈ s)\n    (f : α → β) : ∏ x ∈ s, f x = (∏ x ∈ s \\ {i}, f x) * f i := by\n  rw [prod_eq_mul_prod_diff_singleton h, mul_comm]\n\n"}
{"name":"Finset.sum_eq_sum_diff_singleton_add","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\ni : α\nh : Membership.mem s i\nf : α → β\n⊢ Eq (s.sum fun x => f x) (HAdd.hAdd ((SDiff.sdiff s (Singleton.singleton i)).sum fun x => f x) (f i))","decl":"@[to_additive]\ntheorem prod_eq_prod_diff_singleton_mul [DecidableEq α] {s : Finset α} {i : α} (h : i ∈ s)\n    (f : α → β) : ∏ x ∈ s, f x = (∏ x ∈ s \\ {i}, f x) * f i := by\n  rw [prod_eq_mul_prod_diff_singleton h, mul_comm]\n\n"}
{"name":"Fintype.sum_eq_add_sum_compl","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : AddCommMonoid β\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\na : α\nf : α → β\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (f a) ((HasCompl.compl (Singleton.singleton a)).sum fun i => f i))","decl":"@[to_additive]\ntheorem _root_.Fintype.prod_eq_mul_prod_compl [DecidableEq α] [Fintype α] (a : α) (f : α → β) :\n    ∏ i, f i = f a * ∏ i ∈ {a}ᶜ, f i :=\n  prod_eq_mul_prod_diff_singleton (mem_univ a) f\n\n"}
{"name":"Fintype.prod_eq_mul_prod_compl","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : CommMonoid β\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\na : α\nf : α → β\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul (f a) ((HasCompl.compl (Singleton.singleton a)).prod fun i => f i))","decl":"@[to_additive]\ntheorem _root_.Fintype.prod_eq_mul_prod_compl [DecidableEq α] [Fintype α] (a : α) (f : α → β) :\n    ∏ i, f i = f a * ∏ i ∈ {a}ᶜ, f i :=\n  prod_eq_mul_prod_diff_singleton (mem_univ a) f\n\n"}
{"name":"Fintype.sum_eq_sum_compl_add","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : AddCommMonoid β\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\na : α\nf : α → β\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd ((HasCompl.compl (Singleton.singleton a)).sum fun i => f i) (f a))","decl":"@[to_additive]\ntheorem _root_.Fintype.prod_eq_prod_compl_mul [DecidableEq α] [Fintype α] (a : α) (f : α → β) :\n    ∏ i, f i = (∏ i ∈ {a}ᶜ, f i) * f a :=\n  prod_eq_prod_diff_singleton_mul (mem_univ a) f\n\n"}
{"name":"Fintype.prod_eq_prod_compl_mul","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : CommMonoid β\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\na : α\nf : α → β\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul ((HasCompl.compl (Singleton.singleton a)).prod fun i => f i) (f a))","decl":"@[to_additive]\ntheorem _root_.Fintype.prod_eq_prod_compl_mul [DecidableEq α] [Fintype α] (a : α) (f : α → β) :\n    ∏ i, f i = (∏ i ∈ {a}ᶜ, f i) * f a :=\n  prod_eq_prod_diff_singleton_mul (mem_univ a) f\n\n"}
{"name":"Finset.dvd_prod_of_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\nf : α → β\na : α\ns : Finset α\nha : Membership.mem s a\n⊢ Dvd.dvd (f a) (s.prod fun i => f i)","decl":"theorem dvd_prod_of_mem (f : α → β) {a : α} {s : Finset α} (ha : a ∈ s) : f a ∣ ∏ i ∈ s, f i := by\n  classical\n    rw [Finset.prod_eq_mul_prod_diff_singleton ha]\n    exact dvd_mul_right _ _\n\n"}
{"name":"Finset.prod_partition","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝¹ : CommMonoid β\nR : Setoid α\ninst✝ : DecidableRel ⇑R\n⊢ Eq (s.prod fun x => f x) ((Finset.image (Quotient.mk R) s).prod fun xbar => (Finset.filter (fun y => Eq (Quotient.mk R y) xbar) s).prod fun y => f y)","decl":"/-- A product can be partitioned into a product of products, each equivalent under a setoid. -/\n@[to_additive \"A sum can be partitioned into a sum of sums, each equivalent under a setoid.\"]\ntheorem prod_partition (R : Setoid α) [DecidableRel R.r] :\n    ∏ x ∈ s, f x = ∏ xbar ∈ s.image (Quotient.mk _), ∏ y ∈ s with ⟦y⟧ = xbar, f y := by\n  refine (Finset.prod_image' f fun x _hx => ?_).symm\n  rfl\n\n"}
{"name":"Finset.sum_partition","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝¹ : AddCommMonoid β\nR : Setoid α\ninst✝ : DecidableRel ⇑R\n⊢ Eq (s.sum fun x => f x) ((Finset.image (Quotient.mk R) s).sum fun xbar => (Finset.filter (fun y => Eq (Quotient.mk R y) xbar) s).sum fun y => f y)","decl":"/-- A product can be partitioned into a product of products, each equivalent under a setoid. -/\n@[to_additive \"A sum can be partitioned into a sum of sums, each equivalent under a setoid.\"]\ntheorem prod_partition (R : Setoid α) [DecidableRel R.r] :\n    ∏ x ∈ s, f x = ∏ xbar ∈ s.image (Quotient.mk _), ∏ y ∈ s with ⟦y⟧ = xbar, f y := by\n  refine (Finset.prod_image' f fun x _hx => ?_).symm\n  rfl\n\n"}
{"name":"Finset.sum_cancels_of_partition_cancels","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝¹ : AddCommMonoid β\nR : Setoid α\ninst✝ : DecidableRel ⇑R\nh : ∀ (x : α), Membership.mem s x → Eq ((Finset.filter (fun a => R a x) s).sum fun a => f a) 0\n⊢ Eq (s.sum fun x => f x) 0","decl":"/-- If we can partition a product into subsets that cancel out, then the whole product cancels. -/\n@[to_additive \"If we can partition a sum into subsets that cancel out, then the whole sum cancels.\"]\ntheorem prod_cancels_of_partition_cancels (R : Setoid α) [DecidableRel R]\n    (h : ∀ x ∈ s, ∏ a ∈ s with R a x, f a = 1) : ∏ x ∈ s, f x = 1 := by\n  rw [prod_partition R, ← Finset.prod_eq_one]\n  intro xbar xbar_in_s\n  obtain ⟨x, x_in_s, rfl⟩ := mem_image.mp xbar_in_s\n  simp only [← Quotient.eq] at h\n  exact h x x_in_s\n\n"}
{"name":"Finset.prod_cancels_of_partition_cancels","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝¹ : CommMonoid β\nR : Setoid α\ninst✝ : DecidableRel ⇑R\nh : ∀ (x : α), Membership.mem s x → Eq ((Finset.filter (fun a => R a x) s).prod fun a => f a) 1\n⊢ Eq (s.prod fun x => f x) 1","decl":"/-- If we can partition a product into subsets that cancel out, then the whole product cancels. -/\n@[to_additive \"If we can partition a sum into subsets that cancel out, then the whole sum cancels.\"]\ntheorem prod_cancels_of_partition_cancels (R : Setoid α) [DecidableRel R]\n    (h : ∀ x ∈ s, ∏ a ∈ s with R a x, f a = 1) : ∏ x ∈ s, f x = 1 := by\n  rw [prod_partition R, ← Finset.prod_eq_one]\n  intro xbar xbar_in_s\n  obtain ⟨x, x_in_s, rfl⟩ := mem_image.mp xbar_in_s\n  simp only [← Quotient.eq] at h\n  exact h x x_in_s\n\n"}
{"name":"Finset.prod_update_of_not_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\ni : α\nh : Not (Membership.mem s i)\nf : α → β\nb : β\n⊢ Eq (s.prod fun x => Function.update f i b x) (s.prod fun x => f x)","decl":"@[to_additive]\ntheorem prod_update_of_not_mem [DecidableEq α] {s : Finset α} {i : α} (h : i ∉ s) (f : α → β)\n    (b : β) : ∏ x ∈ s, Function.update f i b x = ∏ x ∈ s, f x := by\n  apply prod_congr rfl\n  intros j hj\n  have : j ≠ i := by\n    rintro rfl\n    exact h hj\n  simp [this]\n\n"}
{"name":"Finset.sum_update_of_not_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\ni : α\nh : Not (Membership.mem s i)\nf : α → β\nb : β\n⊢ Eq (s.sum fun x => Function.update f i b x) (s.sum fun x => f x)","decl":"@[to_additive]\ntheorem prod_update_of_not_mem [DecidableEq α] {s : Finset α} {i : α} (h : i ∉ s) (f : α → β)\n    (b : β) : ∏ x ∈ s, Function.update f i b x = ∏ x ∈ s, f x := by\n  apply prod_congr rfl\n  intros j hj\n  have : j ≠ i := by\n    rintro rfl\n    exact h hj\n  simp [this]\n\n"}
{"name":"Finset.sum_update_of_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\ni : α\nh : Membership.mem s i\nf : α → β\nb : β\n⊢ Eq (s.sum fun x => Function.update f i b x) (HAdd.hAdd b ((SDiff.sdiff s (Singleton.singleton i)).sum fun x => f x))","decl":"@[to_additive]\ntheorem prod_update_of_mem [DecidableEq α] {s : Finset α} {i : α} (h : i ∈ s) (f : α → β) (b : β) :\n    ∏ x ∈ s, Function.update f i b x = b * ∏ x ∈ s \\ singleton i, f x := by\n  rw [update_eq_piecewise, prod_piecewise]\n  simp [h]\n\n"}
{"name":"Finset.prod_update_of_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\ni : α\nh : Membership.mem s i\nf : α → β\nb : β\n⊢ Eq (s.prod fun x => Function.update f i b x) (HMul.hMul b ((SDiff.sdiff s (Singleton.singleton i)).prod fun x => f x))","decl":"@[to_additive]\ntheorem prod_update_of_mem [DecidableEq α] {s : Finset α} {i : α} (h : i ∈ s) (f : α → β) (b : β) :\n    ∏ x ∈ s, Function.update f i b x = b * ∏ x ∈ s \\ singleton i, f x := by\n  rw [update_eq_piecewise, prod_piecewise]\n  simp [h]\n\n"}
{"name":"Finset.eq_of_card_le_one_of_sum_eq","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nhc : LE.le s.card 1\nf : α → β\nb : β\nh : Eq (s.sum fun x => f x) b\nx : α\na✝ : Membership.mem s x\n⊢ Eq (f x) b","decl":"/-- If a product of a `Finset` of size at most 1 has a given value, so\ndo the terms in that product. -/\n@[to_additive eq_of_card_le_one_of_sum_eq \"If a sum of a `Finset` of size at most 1 has a given\nvalue, so do the terms in that sum.\"]\ntheorem eq_of_card_le_one_of_prod_eq {s : Finset α} (hc : #s ≤ 1) {f : α → β} {b : β}\n    (h : ∏ x ∈ s, f x = b) : ∀ x ∈ s, f x = b := by\n  intro x hx\n  by_cases hc0 : #s = 0\n  · exact False.elim (card_ne_zero_of_mem hx hc0)\n  · have h1 : #s = 1 := le_antisymm hc (Nat.one_le_of_lt (Nat.pos_of_ne_zero hc0))\n    rw [card_eq_one] at h1\n    obtain ⟨x2, hx2⟩ := h1\n    rw [hx2, mem_singleton] at hx\n    simp_rw [hx2] at h\n    rw [hx]\n    rw [prod_singleton] at h\n    exact h\n\n"}
{"name":"Finset.eq_of_card_le_one_of_prod_eq","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nhc : LE.le s.card 1\nf : α → β\nb : β\nh : Eq (s.prod fun x => f x) b\nx : α\na✝ : Membership.mem s x\n⊢ Eq (f x) b","decl":"/-- If a product of a `Finset` of size at most 1 has a given value, so\ndo the terms in that product. -/\n@[to_additive eq_of_card_le_one_of_sum_eq \"If a sum of a `Finset` of size at most 1 has a given\nvalue, so do the terms in that sum.\"]\ntheorem eq_of_card_le_one_of_prod_eq {s : Finset α} (hc : #s ≤ 1) {f : α → β} {b : β}\n    (h : ∏ x ∈ s, f x = b) : ∀ x ∈ s, f x = b := by\n  intro x hx\n  by_cases hc0 : #s = 0\n  · exact False.elim (card_ne_zero_of_mem hx hc0)\n  · have h1 : #s = 1 := le_antisymm hc (Nat.one_le_of_lt (Nat.pos_of_ne_zero hc0))\n    rw [card_eq_one] at h1\n    obtain ⟨x2, hx2⟩ := h1\n    rw [hx2, mem_singleton] at hx\n    simp_rw [hx2] at h\n    rw [hx]\n    rw [prod_singleton] at h\n    exact h\n\n"}
{"name":"Finset.add_sum_erase","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\na : α\nh : Membership.mem s a\n⊢ Eq (HAdd.hAdd (f a) ((s.erase a).sum fun x => f x)) (s.sum fun x => f x)","decl":"/-- Taking a product over `s : Finset α` is the same as multiplying the value on a single element\n`f a` by the product of `s.erase a`.\n\nSee `Multiset.prod_map_erase` for the `Multiset` version. -/\n@[to_additive \"Taking a sum over `s : Finset α` is the same as adding the value on a single element\n`f a` to the sum over `s.erase a`.\n\nSee `Multiset.sum_map_erase` for the `Multiset` version.\"]\ntheorem mul_prod_erase [DecidableEq α] (s : Finset α) (f : α → β) {a : α} (h : a ∈ s) :\n    (f a * ∏ x ∈ s.erase a, f x) = ∏ x ∈ s, f x := by\n  rw [← prod_insert (not_mem_erase a s), insert_erase h]\n\n"}
{"name":"Finset.mul_prod_erase","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\na : α\nh : Membership.mem s a\n⊢ Eq (HMul.hMul (f a) ((s.erase a).prod fun x => f x)) (s.prod fun x => f x)","decl":"/-- Taking a product over `s : Finset α` is the same as multiplying the value on a single element\n`f a` by the product of `s.erase a`.\n\nSee `Multiset.prod_map_erase` for the `Multiset` version. -/\n@[to_additive \"Taking a sum over `s : Finset α` is the same as adding the value on a single element\n`f a` to the sum over `s.erase a`.\n\nSee `Multiset.sum_map_erase` for the `Multiset` version.\"]\ntheorem mul_prod_erase [DecidableEq α] (s : Finset α) (f : α → β) {a : α} (h : a ∈ s) :\n    (f a * ∏ x ∈ s.erase a, f x) = ∏ x ∈ s, f x := by\n  rw [← prod_insert (not_mem_erase a s), insert_erase h]\n\n"}
{"name":"Finset.prod_erase_mul","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\na : α\nh : Membership.mem s a\n⊢ Eq (HMul.hMul ((s.erase a).prod fun x => f x) (f a)) (s.prod fun x => f x)","decl":"/-- A variant of `Finset.mul_prod_erase` with the multiplication swapped. -/\n@[to_additive \"A variant of `Finset.add_sum_erase` with the addition swapped.\"]\ntheorem prod_erase_mul [DecidableEq α] (s : Finset α) (f : α → β) {a : α} (h : a ∈ s) :\n    (∏ x ∈ s.erase a, f x) * f a = ∏ x ∈ s, f x := by rw [mul_comm, mul_prod_erase s f h]\n\n"}
{"name":"Finset.sum_erase_add","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\na : α\nh : Membership.mem s a\n⊢ Eq (HAdd.hAdd ((s.erase a).sum fun x => f x) (f a)) (s.sum fun x => f x)","decl":"/-- A variant of `Finset.mul_prod_erase` with the multiplication swapped. -/\n@[to_additive \"A variant of `Finset.add_sum_erase` with the addition swapped.\"]\ntheorem prod_erase_mul [DecidableEq α] (s : Finset α) (f : α → β) {a : α} (h : a ∈ s) :\n    (∏ x ∈ s.erase a, f x) * f a = ∏ x ∈ s, f x := by rw [mul_comm, mul_prod_erase s f h]\n\n"}
{"name":"Finset.sum_erase","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\na : α\nh : Eq (f a) 0\n⊢ Eq ((s.erase a).sum fun x => f x) (s.sum fun x => f x)","decl":"/-- If a function applied at a point is 1, a product is unchanged by\nremoving that point, if present, from a `Finset`. -/\n@[to_additive \"If a function applied at a point is 0, a sum is unchanged by\nremoving that point, if present, from a `Finset`.\"]\ntheorem prod_erase [DecidableEq α] (s : Finset α) {f : α → β} {a : α} (h : f a = 1) :\n    ∏ x ∈ s.erase a, f x = ∏ x ∈ s, f x := by\n  rw [← sdiff_singleton_eq_erase]\n  refine prod_subset sdiff_subset fun x hx hnx => ?_\n  rw [sdiff_singleton_eq_erase] at hnx\n  rwa [eq_of_mem_of_not_mem_erase hx hnx]\n\n"}
{"name":"Finset.prod_erase","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\na : α\nh : Eq (f a) 1\n⊢ Eq ((s.erase a).prod fun x => f x) (s.prod fun x => f x)","decl":"/-- If a function applied at a point is 1, a product is unchanged by\nremoving that point, if present, from a `Finset`. -/\n@[to_additive \"If a function applied at a point is 0, a sum is unchanged by\nremoving that point, if present, from a `Finset`.\"]\ntheorem prod_erase [DecidableEq α] (s : Finset α) {f : α → β} {a : α} (h : f a = 1) :\n    ∏ x ∈ s.erase a, f x = ∏ x ∈ s, f x := by\n  rw [← sdiff_singleton_eq_erase]\n  refine prod_subset sdiff_subset fun x hx hnx => ?_\n  rw [sdiff_singleton_eq_erase] at hnx\n  rwa [eq_of_mem_of_not_mem_erase hx hnx]\n\n"}
{"name":"Finset.sum_ite_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ns : Finset α\np : α → Prop\ninst✝ : DecidablePred p\nh : ∀ (i : α), Membership.mem s i → ∀ (j : α), Membership.mem s j → p i → p j → Eq i j\na : β\n⊢ Eq (s.sum fun i => ite (p i) a 0) (ite (Exists fun i => And (Membership.mem s i) (p i)) a 0)","decl":"/-- See also `Finset.prod_ite_zero`. -/\n@[to_additive \"See also `Finset.sum_boole`.\"]\ntheorem prod_ite_one (s : Finset α) (p : α → Prop) [DecidablePred p]\n    (h : ∀ i ∈ s, ∀ j ∈ s, p i → p j → i = j) (a : β) :\n    ∏ i ∈ s, ite (p i) a 1 = ite (∃ i ∈ s, p i) a 1 := by\n  split_ifs with h\n  · obtain ⟨i, hi, hpi⟩ := h\n    rw [prod_eq_single_of_mem _ hi, if_pos hpi]\n    exact fun j hj hji ↦ if_neg fun hpj ↦ hji <| h _ hj _ hi hpj hpi\n  · push_neg at h\n    rw [prod_eq_one]\n    exact fun i hi => if_neg (h i hi)\n\n"}
{"name":"Finset.prod_ite_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ns : Finset α\np : α → Prop\ninst✝ : DecidablePred p\nh : ∀ (i : α), Membership.mem s i → ∀ (j : α), Membership.mem s j → p i → p j → Eq i j\na : β\n⊢ Eq (s.prod fun i => ite (p i) a 1) (ite (Exists fun i => And (Membership.mem s i) (p i)) a 1)","decl":"/-- See also `Finset.prod_ite_zero`. -/\n@[to_additive \"See also `Finset.sum_boole`.\"]\ntheorem prod_ite_one (s : Finset α) (p : α → Prop) [DecidablePred p]\n    (h : ∀ i ∈ s, ∀ j ∈ s, p i → p j → i = j) (a : β) :\n    ∏ i ∈ s, ite (p i) a 1 = ite (∃ i ∈ s, p i) a 1 := by\n  split_ifs with h\n  · obtain ⟨i, hi, hpi⟩ := h\n    rw [prod_eq_single_of_mem _ hi, if_pos hpi]\n    exact fun j hj hji ↦ if_neg fun hpj ↦ hji <| h _ hj _ hi hpj hpi\n  · push_neg at h\n    rw [prod_eq_one]\n    exact fun i hi => if_neg (h i hi)\n\n"}
{"name":"Finset.prod_erase_lt_of_one_lt","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nγ : Type u_6\ninst✝³ : DecidableEq α\ninst✝² : CommMonoid γ\ninst✝¹ : Preorder γ\ninst✝ : MulLeftStrictMono γ\ns : Finset α\nd : α\nhd : Membership.mem s d\nf : α → γ\nhdf : LT.lt 1 (f d)\n⊢ LT.lt ((s.erase d).prod fun m => f m) (s.prod fun m => f m)","decl":"@[to_additive]\ntheorem prod_erase_lt_of_one_lt {γ : Type*} [DecidableEq α] [CommMonoid γ] [Preorder γ]\n    [MulLeftStrictMono γ] {s : Finset α} {d : α} (hd : d ∈ s) {f : α → γ}\n    (hdf : 1 < f d) : ∏ m ∈ s.erase d, f m < ∏ m ∈ s, f m := by\n  conv in ∏ m ∈ s, f m => rw [← Finset.insert_erase hd]\n  rw [Finset.prod_insert (Finset.not_mem_erase d s)]\n  exact lt_mul_of_one_lt_left' _ hdf\n\n"}
{"name":"Finset.sum_erase_lt_of_pos","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nγ : Type u_6\ninst✝³ : DecidableEq α\ninst✝² : AddCommMonoid γ\ninst✝¹ : Preorder γ\ninst✝ : AddLeftStrictMono γ\ns : Finset α\nd : α\nhd : Membership.mem s d\nf : α → γ\nhdf : LT.lt 0 (f d)\n⊢ LT.lt ((s.erase d).sum fun m => f m) (s.sum fun m => f m)","decl":"@[to_additive]\ntheorem prod_erase_lt_of_one_lt {γ : Type*} [DecidableEq α] [CommMonoid γ] [Preorder γ]\n    [MulLeftStrictMono γ] {s : Finset α} {d : α} (hd : d ∈ s) {f : α → γ}\n    (hdf : 1 < f d) : ∏ m ∈ s.erase d, f m < ∏ m ∈ s, f m := by\n  conv in ∏ m ∈ s, f m => rw [← Finset.insert_erase hd]\n  rw [Finset.prod_insert (Finset.not_mem_erase d s)]\n  exact lt_mul_of_one_lt_left' _ hdf\n\n"}
{"name":"Finset.eq_one_of_prod_eq_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nf : α → β\na : α\nhp : Eq (s.prod fun x => f x) 1\nh1 : ∀ (x : α), Membership.mem s x → Ne x a → Eq (f x) 1\nx : α\na✝ : Membership.mem s x\n⊢ Eq (f x) 1","decl":"/-- If a product is 1 and the function is 1 except possibly at one\npoint, it is 1 everywhere on the `Finset`. -/\n@[to_additive \"If a sum is 0 and the function is 0 except possibly at one\npoint, it is 0 everywhere on the `Finset`.\"]\ntheorem eq_one_of_prod_eq_one {s : Finset α} {f : α → β} {a : α} (hp : ∏ x ∈ s, f x = 1)\n    (h1 : ∀ x ∈ s, x ≠ a → f x = 1) : ∀ x ∈ s, f x = 1 := by\n  intro x hx\n  classical\n    by_cases h : x = a\n    · rw [h]\n      rw [h] at hx\n      rw [← prod_subset (singleton_subset_iff.2 hx) fun t ht ha => h1 t ht (not_mem_singleton.1 ha),\n        prod_singleton] at hp\n      exact hp\n    · exact h1 x hx h\n\n"}
{"name":"Finset.eq_zero_of_sum_eq_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → β\na : α\nhp : Eq (s.sum fun x => f x) 0\nh1 : ∀ (x : α), Membership.mem s x → Ne x a → Eq (f x) 0\nx : α\na✝ : Membership.mem s x\n⊢ Eq (f x) 0","decl":"/-- If a product is 1 and the function is 1 except possibly at one\npoint, it is 1 everywhere on the `Finset`. -/\n@[to_additive \"If a sum is 0 and the function is 0 except possibly at one\npoint, it is 0 everywhere on the `Finset`.\"]\ntheorem eq_one_of_prod_eq_one {s : Finset α} {f : α → β} {a : α} (hp : ∏ x ∈ s, f x = 1)\n    (h1 : ∀ x ∈ s, x ≠ a → f x = 1) : ∀ x ∈ s, f x = 1 := by\n  intro x hx\n  classical\n    by_cases h : x = a\n    · rw [h]\n      rw [h] at hx\n      rw [← prod_subset (singleton_subset_iff.2 hx) fun t ht ha => h1 t ht (not_mem_singleton.1 ha),\n        prod_singleton] at hp\n      exact hp\n    · exact h1 x hx h\n\n"}
{"name":"Finset.sum_boole_nsmul","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\na : α\n⊢ Eq (s.sum fun x => HSMul.hSMul (ite (Eq a x) 1 0) (f x)) (ite (Membership.mem s a) (f a) 0)","decl":"@[to_additive sum_boole_nsmul]\ntheorem prod_pow_boole [DecidableEq α] (s : Finset α) (f : α → β) (a : α) :\n    (∏ x ∈ s, f x ^ ite (a = x) 1 0) = ite (a ∈ s) (f a) 1 := by simp\n\n"}
{"name":"Finset.prod_pow_boole","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq α\ns : Finset α\nf : α → β\na : α\n⊢ Eq (s.prod fun x => HPow.hPow (f x) (ite (Eq a x) 1 0)) (ite (Membership.mem s a) (f a) 1)","decl":"@[to_additive sum_boole_nsmul]\ntheorem prod_pow_boole [DecidableEq α] (s : Finset α) (f : α → β) (a : α) :\n    (∏ x ∈ s, f x ^ ite (a = x) 1 0) = ite (a ∈ s) (f a) 1 := by simp\n\n"}
{"name":"Finset.prod_dvd_prod_of_dvd","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\nS : Finset α\ng1 g2 : α → β\nh : ∀ (a : α), Membership.mem S a → Dvd.dvd (g1 a) (g2 a)\n⊢ Dvd.dvd (S.prod g1) (S.prod g2)","decl":"theorem prod_dvd_prod_of_dvd {S : Finset α} (g1 g2 : α → β) (h : ∀ a ∈ S, g1 a ∣ g2 a) :\n    S.prod g1 ∣ S.prod g2 := by\n  induction S using Finset.cons_induction with\n  | empty => simp\n  | cons a T haT IH =>\n    rw [Finset.prod_cons, Finset.prod_cons]\n    rw [Finset.forall_mem_cons] at h\n    exact mul_dvd_mul h.1 <| IH h.2\n\n"}
{"name":"Finset.sum_add_eq_sum_add_of_exists","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : AddCommMonoid β\ns : Finset α\nf : α → β\nb₁ b₂ : β\na : α\nha : Membership.mem s a\nh : Eq (HAdd.hAdd (f a) b₁) (HAdd.hAdd (f a) b₂)\n⊢ Eq (HAdd.hAdd (s.sum fun a => f a) b₁) (HAdd.hAdd (s.sum fun a => f a) b₂)","decl":"@[to_additive]\nlemma prod_mul_eq_prod_mul_of_exists {s : Finset α} {f : α → β} {b₁ b₂ : β}\n    (a : α) (ha : a ∈ s) (h : f a * b₁ = f a * b₂) :\n    (∏ a ∈ s, f a) * b₁ = (∏ a ∈ s, f a) * b₂ := by\n  classical\n  rw [← insert_erase ha]\n  simp only [mem_erase, ne_eq, not_true_eq_false, false_and, not_false_eq_true, prod_insert]\n  rw [mul_assoc, mul_comm, mul_assoc, mul_comm b₁, h, ← mul_assoc, mul_comm _ (f a)]\n\n"}
{"name":"Finset.prod_mul_eq_prod_mul_of_exists","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\ns : Finset α\nf : α → β\nb₁ b₂ : β\na : α\nha : Membership.mem s a\nh : Eq (HMul.hMul (f a) b₁) (HMul.hMul (f a) b₂)\n⊢ Eq (HMul.hMul (s.prod fun a => f a) b₁) (HMul.hMul (s.prod fun a => f a) b₂)","decl":"@[to_additive]\nlemma prod_mul_eq_prod_mul_of_exists {s : Finset α} {f : α → β} {b₁ b₂ : β}\n    (a : α) (ha : a ∈ s) (h : f a * b₁ = f a * b₂) :\n    (∏ a ∈ s, f a) * b₁ = (∏ a ∈ s, f a) * b₂ := by\n  classical\n  rw [← insert_erase ha]\n  simp only [mem_erase, ne_eq, not_true_eq_false, false_and, not_false_eq_true, prod_insert]\n  rw [mul_assoc, mul_comm, mul_assoc, mul_comm b₁, h, ← mul_assoc, mul_comm _ (f a)]\n\n"}
{"name":"Finset.even_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\ns : Finset ι\ninst✝ : AddCommMonoid α\nf : ι → α\nh : ∀ (c : ι), Membership.mem s c → Even (f c)\n⊢ Even (s.sum fun i => f i)","decl":"@[to_additive]\nlemma isSquare_prod {s : Finset ι} [CommMonoid α] (f : ι → α)\n    (h : ∀ c ∈ s, IsSquare (f c)) : IsSquare (∏ i ∈ s, f i) := by\n  rw [isSquare_iff_exists_sq]\n  use (∏ (x : s), ((isSquare_iff_exists_sq _).mp (h _ x.2)).choose)\n  rw [@sq, ← Finset.prod_mul_distrib, ← Finset.prod_coe_sort]\n  congr\n  ext i\n  rw [← @sq]\n  exact ((isSquare_iff_exists_sq _).mp (h _ i.2)).choose_spec\n\n"}
{"name":"Finset.isSquare_prod","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\ns : Finset ι\ninst✝ : CommMonoid α\nf : ι → α\nh : ∀ (c : ι), Membership.mem s c → IsSquare (f c)\n⊢ IsSquare (s.prod fun i => f i)","decl":"@[to_additive]\nlemma isSquare_prod {s : Finset ι} [CommMonoid α] (f : ι → α)\n    (h : ∀ c ∈ s, IsSquare (f c)) : IsSquare (∏ i ∈ s, f i) := by\n  rw [isSquare_iff_exists_sq]\n  use (∏ (x : s), ((isSquare_iff_exists_sq _).mp (h _ x.2)).choose)\n  rw [@sq, ← Finset.prod_mul_distrib, ← Finset.prod_coe_sort]\n  congr\n  ext i\n  rw [← @sq]\n  exact ((isSquare_iff_exists_sq _).mp (h _ i.2)).choose_spec\n\n"}
{"name":"Finset.sum_sdiff_eq_sum_sdiff_iff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : DecidableEq ι\ninst✝ : AddCancelCommMonoid α\ns t : Finset ι\nf : ι → α\n⊢ Iff (Eq ((SDiff.sdiff s t).sum fun i => f i) ((SDiff.sdiff t s).sum fun i => f i)) (Eq (s.sum fun i => f i) (t.sum fun i => f i))","decl":"@[to_additive]\nlemma prod_sdiff_eq_prod_sdiff_iff :\n    ∏ i ∈ s \\ t, f i = ∏ i ∈ t \\ s, f i ↔ ∏ i ∈ s, f i = ∏ i ∈ t, f i :=\n  eq_comm.trans <| eq_iff_eq_of_mul_eq_mul <| by\n    rw [← prod_union disjoint_sdiff_self_left, ← prod_union disjoint_sdiff_self_left,\n      sdiff_union_self_eq_union, sdiff_union_self_eq_union, union_comm]\n\n"}
{"name":"Finset.prod_sdiff_eq_prod_sdiff_iff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : DecidableEq ι\ninst✝ : CancelCommMonoid α\ns t : Finset ι\nf : ι → α\n⊢ Iff (Eq ((SDiff.sdiff s t).prod fun i => f i) ((SDiff.sdiff t s).prod fun i => f i)) (Eq (s.prod fun i => f i) (t.prod fun i => f i))","decl":"@[to_additive]\nlemma prod_sdiff_eq_prod_sdiff_iff :\n    ∏ i ∈ s \\ t, f i = ∏ i ∈ t \\ s, f i ↔ ∏ i ∈ s, f i = ∏ i ∈ t, f i :=\n  eq_comm.trans <| eq_iff_eq_of_mul_eq_mul <| by\n    rw [← prod_union disjoint_sdiff_self_left, ← prod_union disjoint_sdiff_self_left,\n      sdiff_union_self_eq_union, sdiff_union_self_eq_union, union_comm]\n\n"}
{"name":"Finset.sum_sdiff_ne_sum_sdiff_iff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : DecidableEq ι\ninst✝ : AddCancelCommMonoid α\ns t : Finset ι\nf : ι → α\n⊢ Iff (Ne ((SDiff.sdiff s t).sum fun i => f i) ((SDiff.sdiff t s).sum fun i => f i)) (Ne (s.sum fun i => f i) (t.sum fun i => f i))","decl":"@[to_additive]\nlemma prod_sdiff_ne_prod_sdiff_iff :\n    ∏ i ∈ s \\ t, f i ≠ ∏ i ∈ t \\ s, f i ↔ ∏ i ∈ s, f i ≠ ∏ i ∈ t, f i :=\n  prod_sdiff_eq_prod_sdiff_iff.not\n\n"}
{"name":"Finset.prod_sdiff_ne_prod_sdiff_iff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\ninst✝¹ : DecidableEq ι\ninst✝ : CancelCommMonoid α\ns t : Finset ι\nf : ι → α\n⊢ Iff (Ne ((SDiff.sdiff s t).prod fun i => f i) ((SDiff.sdiff t s).prod fun i => f i)) (Ne (s.prod fun i => f i) (t.prod fun i => f i))","decl":"@[to_additive]\nlemma prod_sdiff_ne_prod_sdiff_iff :\n    ∏ i ∈ s \\ t, f i ≠ ∏ i ∈ t \\ s, f i ↔ ∏ i ∈ s, f i ≠ ∏ i ∈ t, f i :=\n  prod_sdiff_eq_prod_sdiff_iff.not\n\n"}
{"name":"Finset.card_eq_sum_ones","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ns : Finset α\n⊢ Eq s.card (s.sum fun x => 1)","decl":"theorem card_eq_sum_ones (s : Finset α) : #s = ∑ _ ∈ s, 1 := by simp\n\n"}
{"name":"Finset.sum_const_nat","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ns : Finset α\nm : Nat\nf : α → Nat\nh₁ : ∀ (x : α), Membership.mem s x → Eq (f x) m\n⊢ Eq (s.sum fun x => f x) (HMul.hMul s.card m)","decl":"theorem sum_const_nat {m : ℕ} {f : α → ℕ} (h₁ : ∀ x ∈ s, f x = m) : ∑ x ∈ s, f x = #s * m := by\n  rw [← Nat.nsmul_eq_mul, ← sum_const]\n  apply sum_congr rfl h₁\n\n"}
{"name":"Finset.sum_card_fiberwise_eq_card_filter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nκ : Type u_6\ninst✝ : DecidableEq κ\ns : Finset ι\nt : Finset κ\ng : ι → κ\n⊢ Eq (t.sum fun j => (Finset.filter (fun i => Eq (g i) j) s).card) (Finset.filter (fun i => Membership.mem t (g i)) s).card","decl":"lemma sum_card_fiberwise_eq_card_filter {κ : Type*} [DecidableEq κ] (s : Finset ι) (t : Finset κ)\n    (g : ι → κ) : ∑ j ∈ t, #{i ∈ s | g i = j} = #{i ∈ s | g i ∈ t} := by\n  simpa only [card_eq_sum_ones] using sum_fiberwise_eq_sum_filter _ _ _ _\n\n"}
{"name":"Finset.card_filter","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\np : ι → Prop\ninst✝ : DecidablePred p\ns : Finset ι\n⊢ Eq (Finset.filter (fun i => p i) s).card (s.sum fun i => ite (p i) 1 0)","decl":"lemma card_filter (p) [DecidablePred p] (s : Finset ι) :\n    #{i ∈ s | p i} = ∑ i ∈ s, ite (p i) 1 0 := by simp [sum_ite]\n\n"}
{"name":"Finset.sum_sdiff_eq_sub","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : AddCommGroup β\ninst✝ : DecidableEq α\nh : HasSubset.Subset s₁ s₂\n⊢ Eq ((SDiff.sdiff s₂ s₁).sum fun x => f x) (HSub.hSub (s₂.sum fun x => f x) (s₁.sum fun x => f x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_sdiff_eq_div (h : s₁ ⊆ s₂) :\n    ∏ x ∈ s₂ \\ s₁, f x = (∏ x ∈ s₂, f x) / ∏ x ∈ s₁, f x := by\n  rw [eq_div_iff_mul_eq', prod_sdiff h]\n\n"}
{"name":"Finset.prod_sdiff_eq_div","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : CommGroup β\ninst✝ : DecidableEq α\nh : HasSubset.Subset s₁ s₂\n⊢ Eq ((SDiff.sdiff s₂ s₁).prod fun x => f x) (HDiv.hDiv (s₂.prod fun x => f x) (s₁.prod fun x => f x))","decl":"@[to_additive (attr := simp)]\ntheorem prod_sdiff_eq_div (h : s₁ ⊆ s₂) :\n    ∏ x ∈ s₂ \\ s₁, f x = (∏ x ∈ s₂, f x) / ∏ x ∈ s₁, f x := by\n  rw [eq_div_iff_mul_eq', prod_sdiff h]\n\n"}
{"name":"Finset.prod_sdiff_div_prod_sdiff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : CommGroup β\ninst✝ : DecidableEq α\n⊢ Eq (HDiv.hDiv ((SDiff.sdiff s₂ s₁).prod fun x => f x) ((SDiff.sdiff s₁ s₂).prod fun x => f x)) (HDiv.hDiv (s₂.prod fun x => f x) (s₁.prod fun x => f x))","decl":"@[to_additive]\ntheorem prod_sdiff_div_prod_sdiff :\n    (∏ x ∈ s₂ \\ s₁, f x) / ∏ x ∈ s₁ \\ s₂, f x = (∏ x ∈ s₂, f x) / ∏ x ∈ s₁, f x := by\n  simp [← Finset.prod_sdiff (@inf_le_left _ _ s₁ s₂), ← Finset.prod_sdiff (@inf_le_right _ _ s₁ s₂)]\n\n"}
{"name":"Finset.sum_sdiff_sub_sum_sdiff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns₁ s₂ : Finset α\nf : α → β\ninst✝¹ : AddCommGroup β\ninst✝ : DecidableEq α\n⊢ Eq (HSub.hSub ((SDiff.sdiff s₂ s₁).sum fun x => f x) ((SDiff.sdiff s₁ s₂).sum fun x => f x)) (HSub.hSub (s₂.sum fun x => f x) (s₁.sum fun x => f x))","decl":"@[to_additive]\ntheorem prod_sdiff_div_prod_sdiff :\n    (∏ x ∈ s₂ \\ s₁, f x) / ∏ x ∈ s₁ \\ s₂, f x = (∏ x ∈ s₂, f x) / ∏ x ∈ s₁, f x := by\n  simp [← Finset.prod_sdiff (@inf_le_left _ _ s₁ s₂), ← Finset.prod_sdiff (@inf_le_right _ _ s₁ s₂)]\n\n"}
{"name":"Finset.sum_erase_eq_sub","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝¹ : AddCommGroup β\ninst✝ : DecidableEq α\na : α\nh : Membership.mem s a\n⊢ Eq ((s.erase a).sum fun x => f x) (HSub.hSub (s.sum fun x => f x) (f a))","decl":"@[to_additive (attr := simp)]\ntheorem prod_erase_eq_div {a : α} (h : a ∈ s) :\n    ∏ x ∈ s.erase a, f x = (∏ x ∈ s, f x) / f a := by\n  rw [eq_div_iff_mul_eq', prod_erase_mul _ _ h]\n\n"}
{"name":"Finset.prod_erase_eq_div","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝¹ : CommGroup β\ninst✝ : DecidableEq α\na : α\nh : Membership.mem s a\n⊢ Eq ((s.erase a).prod fun x => f x) (HDiv.hDiv (s.prod fun x => f x) (f a))","decl":"@[to_additive (attr := simp)]\ntheorem prod_erase_eq_div {a : α} (h : a ∈ s) :\n    ∏ x ∈ s.erase a, f x = (∏ x ∈ s, f x) / f a := by\n  rw [eq_div_iff_mul_eq', prod_erase_mul _ _ h]\n\n"}
{"name":"Finset.card_sigma","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nσ : α → Type u_6\ns : Finset α\nt : (a : α) → Finset (σ a)\n⊢ Eq (s.sigma t).card (s.sum fun a => (t a).card)","decl":"@[simp]\ntheorem card_sigma {σ : α → Type*} (s : Finset α) (t : ∀ a, Finset (σ a)) :\n    #(s.sigma t) = ∑ a ∈ s, #(t a) :=\n  Multiset.card_sigma _ _\n\n"}
{"name":"Finset.card_disjiUnion","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nt : α → Finset β\nh : (↑s).PairwiseDisjoint t\n⊢ Eq (s.disjiUnion t h).card (s.sum fun a => (t a).card)","decl":"@[simp]\ntheorem card_disjiUnion (s : Finset α) (t : α → Finset β) (h) :\n    #(s.disjiUnion t h) = ∑ a ∈ s, #(t a) :=\n  Multiset.card_bind _ _\n\n"}
{"name":"Finset.card_biUnion","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : DecidableEq β\ns : Finset α\nt : α → Finset β\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → Ne x y → Disjoint (t x) (t y)\n⊢ Eq (s.biUnion t).card (s.sum fun u => (t u).card)","decl":"theorem card_biUnion [DecidableEq β] {s : Finset α} {t : α → Finset β}\n    (h : ∀ x ∈ s, ∀ y ∈ s, x ≠ y → Disjoint (t x) (t y)) : #(s.biUnion t) = ∑ u ∈ s, #(t u) := by\n  simpa using sum_biUnion h (β := ℕ) (f := 1)\n\n"}
{"name":"Finset.card_biUnion_le","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : DecidableEq β\ns : Finset α\nt : α → Finset β\n⊢ LE.le (s.biUnion t).card (s.sum fun a => (t a).card)","decl":"theorem card_biUnion_le [DecidableEq β] {s : Finset α} {t : α → Finset β} :\n    #(s.biUnion t) ≤ ∑ a ∈ s, #(t a) :=\n  haveI := Classical.decEq α\n  Finset.induction_on s (by simp) fun a s has ih =>\n    calc\n      #((insert a s).biUnion t) ≤ #(t a) + #(s.biUnion t) := by\n        rw [biUnion_insert]; exact card_union_le ..\n      _ ≤ ∑ a ∈ insert a s, #(t a) := by rw [sum_insert has]; exact Nat.add_le_add_left ih _\n\n"}
{"name":"Finset.card_eq_sum_card_fiberwise","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\nt : Finset β\nH : ∀ (x : α), Membership.mem s x → Membership.mem t (f x)\n⊢ Eq s.card (t.sum fun b => (Finset.filter (fun a => Eq (f a) b) s).card)","decl":"theorem card_eq_sum_card_fiberwise [DecidableEq β] {f : α → β} {s : Finset α} {t : Finset β}\n    (H : ∀ x ∈ s, f x ∈ t) : #s = ∑ b ∈ t, #{a ∈ s | f a = b} := by\n  simp only [card_eq_sum_ones, sum_fiberwise_of_maps_to H]\n\n"}
{"name":"Finset.card_eq_sum_card_image","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : DecidableEq β\nf : α → β\ns : Finset α\n⊢ Eq s.card ((Finset.image f s).sum fun b => (Finset.filter (fun a => Eq (f a) b) s).card)","decl":"theorem card_eq_sum_card_image [DecidableEq β] (f : α → β) (s : Finset α) :\n    #s = ∑ b ∈ s.image f, #{a ∈ s | f a = b} :=\n  card_eq_sum_card_fiberwise fun _ => mem_image_of_mem _\n\n"}
{"name":"Finset.mem_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → Multiset β\ns : Finset α\nb : β\n⊢ Iff (Membership.mem (s.sum fun x => f x) b) (Exists fun a => And (Membership.mem s a) (Membership.mem (f a) b))","decl":"theorem mem_sum {f : α → Multiset β} (s : Finset α) (b : β) :\n    (b ∈ ∑ x ∈ s, f x) ↔ ∃ a ∈ s, b ∈ f a := by\n  induction s using Finset.cons_induction with\n  | empty => simp\n  | cons a t hi ih => simp [sum_cons, ih, or_and_right, exists_or]\n\n"}
{"name":"Finset.prod_unique_nonempty","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : CommMonoid β\ninst✝ : Unique α\ns : Finset α\nf : α → β\nh : s.Nonempty\n⊢ Eq (s.prod fun x => f x) (f Inhabited.default)","decl":"@[to_additive]\ntheorem prod_unique_nonempty {α β : Type*} [CommMonoid β] [Unique α] (s : Finset α) (f : α → β)\n    (h : s.Nonempty) : ∏ x ∈ s, f x = f default := by\n  rw [h.eq_singleton_default, Finset.prod_singleton]\n\n"}
{"name":"Finset.sum_unique_nonempty","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : AddCommMonoid β\ninst✝ : Unique α\ns : Finset α\nf : α → β\nh : s.Nonempty\n⊢ Eq (s.sum fun x => f x) (f Inhabited.default)","decl":"@[to_additive]\ntheorem prod_unique_nonempty {α β : Type*} [CommMonoid β] [Unique α] (s : Finset α) (f : α → β)\n    (h : s.Nonempty) : ∏ x ∈ s, f x = f default := by\n  rw [h.eq_singleton_default, Finset.prod_singleton]\n\n"}
{"name":"Finset.prod_filter_of_pairwise_eq_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\nι : Type u_8\ninst✝² : DecidableEq ι\ninst✝¹ : DecidableEq α\ninst✝ : CommMonoid β\nf : ι → α\ng : α → β\nn : ι\nI : Finset ι\nhn : Membership.mem I n\nhf : (↑I).Pairwise fun i j => Eq (f i) (f j) → Eq (g (f i)) 1\n⊢ Eq ((Finset.filter (fun j => Eq (f j) (f n)) I).prod fun j => g (f j)) (g (f n))","decl":"@[to_additive]\nlemma prod_filter_of_pairwise_eq_one [CommMonoid β] {f : ι → α} {g : α → β} {n : ι} {I : Finset ι}\n    (hn : n ∈ I) (hf : (I : Set ι).Pairwise fun i j ↦ f i = f j → g (f i) = 1) :\n    ∏ j ∈ filter (fun j ↦ f j = f n) I, g (f j) = g (f n) := by\n  have h j (hj : j ∈ (filter (fun i ↦ f i = f n) I).erase n) : g (f j) = 1 := by\n    simp only [mem_erase, mem_filter] at hj\n    exact hf hj.2.1 hn hj.1 hj.2.2\n  rw [← mul_one (g (f n)), ← prod_eq_one h,\n    ← mul_prod_erase (filter (f · = f n) I) (fun i ↦ g (f i)) <| mem_filter.mpr ⟨hn, by rfl⟩]\n\n"}
{"name":"Finset.sum_filter_of_pairwise_eq_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\nι : Type u_8\ninst✝² : DecidableEq ι\ninst✝¹ : DecidableEq α\ninst✝ : AddCommMonoid β\nf : ι → α\ng : α → β\nn : ι\nI : Finset ι\nhn : Membership.mem I n\nhf : (↑I).Pairwise fun i j => Eq (f i) (f j) → Eq (g (f i)) 0\n⊢ Eq ((Finset.filter (fun j => Eq (f j) (f n)) I).sum fun j => g (f j)) (g (f n))","decl":"@[to_additive]\nlemma prod_filter_of_pairwise_eq_one [CommMonoid β] {f : ι → α} {g : α → β} {n : ι} {I : Finset ι}\n    (hn : n ∈ I) (hf : (I : Set ι).Pairwise fun i j ↦ f i = f j → g (f i) = 1) :\n    ∏ j ∈ filter (fun j ↦ f j = f n) I, g (f j) = g (f n) := by\n  have h j (hj : j ∈ (filter (fun i ↦ f i = f n) I).erase n) : g (f j) = 1 := by\n    simp only [mem_erase, mem_filter] at hj\n    exact hf hj.2.1 hn hj.1 hj.2.2\n  rw [← mul_one (g (f n)), ← prod_eq_one h,\n    ← mul_prod_erase (filter (f · = f n) I) (fun i ↦ g (f i)) <| mem_filter.mpr ⟨hn, by rfl⟩]\n\n"}
{"name":"Finset.sum_image_of_pairwise_eq_zero","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\nι : Type u_8\ninst✝² : DecidableEq ι\ninst✝¹ : DecidableEq α\ninst✝ : AddCommMonoid β\nf : ι → α\ng : α → β\nI : Finset ι\nhf : (↑I).Pairwise fun i j => Eq (f i) (f j) → Eq (g (f i)) 0\n⊢ Eq ((Finset.image f I).sum fun s => g s) (I.sum fun i => g (f i))","decl":"/-- A version of `Finset.prod_map` and `Finset.prod_image`, but we do not assume that `f` is\ninjective. Rather, we assume that the image of `f` on `I` only overlaps where `g (f i) = 1`.\nThe conclusion is the same as in `prod_image`.-/\n@[to_additive (attr := simp)\n\"A version of `Finset.sum_map` and `Finset.sum_image`, but we do not assume that `f` is\ninjective. Rather, we assume that the image of `f` on `I` only overlaps where `g (f i) = 0`.\nThe conclusion is the same as in `sum_image`.\"]\nlemma prod_image_of_pairwise_eq_one [CommMonoid β] {f : ι → α} {g : α → β} {I : Finset ι}\n    (hf : (I : Set ι).Pairwise fun i j ↦ f i = f j → g (f i) = 1) :\n    ∏ s ∈ I.image f, g s = ∏ i ∈ I, g (f i) := by\n  rw [prod_image']\n  exact fun n hnI => (prod_filter_of_pairwise_eq_one hnI hf).symm\n\n"}
{"name":"Finset.prod_image_of_pairwise_eq_one","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\nι : Type u_8\ninst✝² : DecidableEq ι\ninst✝¹ : DecidableEq α\ninst✝ : CommMonoid β\nf : ι → α\ng : α → β\nI : Finset ι\nhf : (↑I).Pairwise fun i j => Eq (f i) (f j) → Eq (g (f i)) 1\n⊢ Eq ((Finset.image f I).prod fun s => g s) (I.prod fun i => g (f i))","decl":"/-- A version of `Finset.prod_map` and `Finset.prod_image`, but we do not assume that `f` is\ninjective. Rather, we assume that the image of `f` on `I` only overlaps where `g (f i) = 1`.\nThe conclusion is the same as in `prod_image`.-/\n@[to_additive (attr := simp)\n\"A version of `Finset.sum_map` and `Finset.sum_image`, but we do not assume that `f` is\ninjective. Rather, we assume that the image of `f` on `I` only overlaps where `g (f i) = 0`.\nThe conclusion is the same as in `sum_image`.\"]\nlemma prod_image_of_pairwise_eq_one [CommMonoid β] {f : ι → α} {g : α → β} {I : Finset ι}\n    (hf : (I : Set ι).Pairwise fun i j ↦ f i = f j → g (f i) = 1) :\n    ∏ s ∈ I.image f, g s = ∏ i ∈ I, g (f i) := by\n  rw [prod_image']\n  exact fun n hnI => (prod_filter_of_pairwise_eq_one hnI hf).symm\n\n"}
{"name":"Finset.prod_image_of_disjoint","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\nι : Type u_8\ninst✝⁴ : DecidableEq ι\ninst✝³ : DecidableEq α\ninst✝² : CommMonoid β\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\nf : ι → α\ng : α → β\nhg_bot : Eq (g Bot.bot) 1\nI : Finset ι\nhf_disj : (↑I).PairwiseDisjoint f\n⊢ Eq ((Finset.image f I).prod fun s => g s) (I.prod fun i => g (f i))","decl":"/-- A version of `Finset.prod_map` and `Finset.prod_image`, but we do not assume that `f` is\ninjective. Rather, we assume that the images of `f` are disjoint on `I`, and `g ⊥ = 1`. The\nconclusion is the same as in `prod_image`.-/\n@[to_additive (attr := simp)\n\"A version of `Finset.sum_map` and `Finset.sum_image`, but we do not assume that `f` is\ninjective. Rather, we assume that the images of `f` are disjoint on `I`, and `g ⊥ = 0`. The\nconclusion is the same as in `sum_image`.\"\n]\nlemma prod_image_of_disjoint [CommMonoid β] [PartialOrder α] [OrderBot α] {f : ι → α} {g : α → β}\n    (hg_bot : g ⊥ = 1) {I : Finset ι} (hf_disj : (I : Set ι).PairwiseDisjoint f) :\n    ∏ s ∈ I.image f, g s = ∏ i ∈ I, g (f i) := by\n  refine prod_image_of_pairwise_eq_one <| hf_disj.imp fun i j (hdisj : Disjoint _ _) hfij ↦ ?_\n  rw [← hfij, disjoint_self] at hdisj\n  rw [hdisj, hg_bot]\n\n"}
{"name":"Finset.sum_image_of_disjoint","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\nβ : Type u_7\nι : Type u_8\ninst✝⁴ : DecidableEq ι\ninst✝³ : DecidableEq α\ninst✝² : AddCommMonoid β\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\nf : ι → α\ng : α → β\nhg_bot : Eq (g Bot.bot) 0\nI : Finset ι\nhf_disj : (↑I).PairwiseDisjoint f\n⊢ Eq ((Finset.image f I).sum fun s => g s) (I.sum fun i => g (f i))","decl":"/-- A version of `Finset.prod_map` and `Finset.prod_image`, but we do not assume that `f` is\ninjective. Rather, we assume that the images of `f` are disjoint on `I`, and `g ⊥ = 1`. The\nconclusion is the same as in `prod_image`.-/\n@[to_additive (attr := simp)\n\"A version of `Finset.sum_map` and `Finset.sum_image`, but we do not assume that `f` is\ninjective. Rather, we assume that the images of `f` are disjoint on `I`, and `g ⊥ = 0`. The\nconclusion is the same as in `sum_image`.\"\n]\nlemma prod_image_of_disjoint [CommMonoid β] [PartialOrder α] [OrderBot α] {f : ι → α} {g : α → β}\n    (hg_bot : g ⊥ = 1) {I : Finset ι} (hf_disj : (I : Set ι).PairwiseDisjoint f) :\n    ∏ s ∈ I.image f, g s = ∏ i ∈ I, g (f i) := by\n  refine prod_image_of_pairwise_eq_one <| hf_disj.imp fun i j (hdisj : Disjoint _ _) hfij ↦ ?_\n  rw [← hfij, disjoint_self] at hdisj\n  rw [hdisj, hg_bot]\n\n"}
{"name":"Fintype.sum_of_injective","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : Fintype κ\ninst✝ : AddCommMonoid α\ne : ι → κ\nhe : Function.Injective e\nf : ι → α\ng : κ → α\nh' : ∀ (i : κ), Not (Membership.mem (Set.range e) i) → Eq (g i) 0\nh : ∀ (i : ι), Eq (f i) (g (e i))\n⊢ Eq (Finset.univ.sum fun i => f i) (Finset.univ.sum fun j => g j)","decl":"@[to_additive]\nlemma prod_of_injective (e : ι → κ) (he : Injective e) (f : ι → α) (g : κ → α)\n    (h' : ∀ i ∉ Set.range e, g i = 1) (h : ∀ i, f i = g (e i)) : ∏ i, f i = ∏ j, g j :=\n  prod_of_injOn e he.injOn (by simp) (by simpa using h') (fun i _ ↦ h i)\n\n"}
{"name":"Fintype.prod_of_injective","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : Fintype κ\ninst✝ : CommMonoid α\ne : ι → κ\nhe : Function.Injective e\nf : ι → α\ng : κ → α\nh' : ∀ (i : κ), Not (Membership.mem (Set.range e) i) → Eq (g i) 1\nh : ∀ (i : ι), Eq (f i) (g (e i))\n⊢ Eq (Finset.univ.prod fun i => f i) (Finset.univ.prod fun j => g j)","decl":"@[to_additive]\nlemma prod_of_injective (e : ι → κ) (he : Injective e) (f : ι → α) (g : κ → α)\n    (h' : ∀ i ∉ Set.range e, g i = 1) (h : ∀ i, f i = g (e i)) : ∏ i, f i = ∏ j, g j :=\n  prod_of_injOn e he.injOn (by simp) (by simpa using h') (fun i _ ↦ h i)\n\n"}
{"name":"Fintype.prod_fiberwise","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝³ : Fintype ι\ninst✝² : Fintype κ\ninst✝¹ : CommMonoid α\ninst✝ : DecidableEq κ\ng : ι → κ\nf : ι → α\n⊢ Eq (Finset.univ.prod fun j => Finset.univ.prod fun i => f ↑i) (Finset.univ.prod fun i => f i)","decl":"@[to_additive]\nlemma prod_fiberwise [DecidableEq κ] (g : ι → κ) (f : ι → α) :\n    ∏ j, ∏ i : {i // g i = j}, f i = ∏ i, f i := by\n  rw [← Finset.prod_fiberwise _ g f]\n  congr with j\n  exact (prod_subtype _ (by simp) _).symm\n\n"}
{"name":"Fintype.sum_fiberwise","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝³ : Fintype ι\ninst✝² : Fintype κ\ninst✝¹ : AddCommMonoid α\ninst✝ : DecidableEq κ\ng : ι → κ\nf : ι → α\n⊢ Eq (Finset.univ.sum fun j => Finset.univ.sum fun i => f ↑i) (Finset.univ.sum fun i => f i)","decl":"@[to_additive]\nlemma prod_fiberwise [DecidableEq κ] (g : ι → κ) (f : ι → α) :\n    ∏ j, ∏ i : {i // g i = j}, f i = ∏ i, f i := by\n  rw [← Finset.prod_fiberwise _ g f]\n  congr with j\n  exact (prod_subtype _ (by simp) _).symm\n\n"}
{"name":"Fintype.prod_fiberwise'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝³ : Fintype ι\ninst✝² : Fintype κ\ninst✝¹ : CommMonoid α\ninst✝ : DecidableEq κ\ng : ι → κ\nf : κ → α\n⊢ Eq (Finset.univ.prod fun j => Finset.univ.prod fun _i => f j) (Finset.univ.prod fun i => f (g i))","decl":"@[to_additive]\nlemma prod_fiberwise' [DecidableEq κ] (g : ι → κ) (f : κ → α) :\n    ∏ j, ∏ _i : {i // g i = j}, f j = ∏ i, f (g i) := by\n  rw [← Finset.prod_fiberwise' _ g f]\n  congr with j\n  exact (prod_subtype _ (by simp) fun _ ↦ _).symm\n\n"}
{"name":"Fintype.sum_fiberwise'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nκ : Type u_7\nα : Type u_8\ninst✝³ : Fintype ι\ninst✝² : Fintype κ\ninst✝¹ : AddCommMonoid α\ninst✝ : DecidableEq κ\ng : ι → κ\nf : κ → α\n⊢ Eq (Finset.univ.sum fun j => Finset.univ.sum fun _i => f j) (Finset.univ.sum fun i => f (g i))","decl":"@[to_additive]\nlemma prod_fiberwise' [DecidableEq κ] (g : ι → κ) (f : κ → α) :\n    ∏ j, ∏ _i : {i // g i = j}, f j = ∏ i, f (g i) := by\n  rw [← Finset.prod_fiberwise' _ g f]\n  congr with j\n  exact (prod_subtype _ (by simp) fun _ ↦ _).symm\n\n"}
{"name":"Fintype.sum_unique","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : AddCommMonoid β\ninst✝¹ : Unique α\ninst✝ : Fintype α\nf : α → β\n⊢ Eq (Finset.univ.sum fun x => f x) (f Inhabited.default)","decl":"@[to_additive]\ntheorem prod_unique {α β : Type*} [CommMonoid β] [Unique α] [Fintype α] (f : α → β) :\n    ∏ x : α, f x = f default := by rw [univ_unique, prod_singleton]\n\n"}
{"name":"Fintype.prod_unique","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : CommMonoid β\ninst✝¹ : Unique α\ninst✝ : Fintype α\nf : α → β\n⊢ Eq (Finset.univ.prod fun x => f x) (f Inhabited.default)","decl":"@[to_additive]\ntheorem prod_unique {α β : Type*} [CommMonoid β] [Unique α] [Fintype α] (f : α → β) :\n    ∏ x : α, f x = f default := by rw [univ_unique, prod_singleton]\n\n"}
{"name":"Fintype.sum_subsingleton","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : AddCommMonoid β\ninst✝¹ : Subsingleton α\ninst✝ : Fintype α\nf : α → β\na : α\n⊢ Eq (Finset.univ.sum fun x => f x) (f a)","decl":"@[to_additive]\ntheorem prod_subsingleton {α β : Type*} [CommMonoid β] [Subsingleton α] [Fintype α] (f : α → β)\n    (a : α) : ∏ x : α, f x = f a := by\n  have : Unique α := uniqueOfSubsingleton a\n  rw [prod_unique f, Subsingleton.elim default a]\n\n"}
{"name":"Fintype.prod_subsingleton","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : CommMonoid β\ninst✝¹ : Subsingleton α\ninst✝ : Fintype α\nf : α → β\na : α\n⊢ Eq (Finset.univ.prod fun x => f x) (f a)","decl":"@[to_additive]\ntheorem prod_subsingleton {α β : Type*} [CommMonoid β] [Subsingleton α] [Fintype α] (f : α → β)\n    (a : α) : ∏ x : α, f x = f a := by\n  have : Unique α := uniqueOfSubsingleton a\n  rw [prod_unique f, Subsingleton.elim default a]\n\n"}
{"name":"Fintype.prod_Prop","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_9\ninst✝ : CommMonoid β\nf : Prop → β\n⊢ Eq (Finset.univ.prod fun p => f p) (HMul.hMul (f True) (f False))","decl":"@[to_additive] theorem prod_Prop {β} [CommMonoid β] (f : Prop → β) :\n    ∏ p, f p = f True * f False := by simp\n\n"}
{"name":"Fintype.sum_Prop","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"β : Type u_9\ninst✝ : AddCommMonoid β\nf : Prop → β\n⊢ Eq (Finset.univ.sum fun p => f p) (HAdd.hAdd (f True) (f False))","decl":"@[to_additive] theorem prod_Prop {β} [CommMonoid β] (f : Prop → β) :\n    ∏ p, f p = f True * f False := by simp\n\n"}
{"name":"Fintype.prod_subtype_mul_prod_subtype","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : Fintype α\ninst✝¹ : CommMonoid β\np : α → Prop\nf : α → β\ninst✝ : DecidablePred p\n⊢ Eq (HMul.hMul (Finset.univ.prod fun i => f ↑i) (Finset.univ.prod fun i => f ↑i)) (Finset.univ.prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_subtype_mul_prod_subtype {α β : Type*} [Fintype α] [CommMonoid β] (p : α → Prop)\n    (f : α → β) [DecidablePred p] :\n    (∏ i : { x // p x }, f i) * ∏ i : { x // ¬p x }, f i = ∏ i, f i := by\n  classical\n    let s := { x | p x }.toFinset\n    rw [← Finset.prod_subtype s, ← Finset.prod_subtype sᶜ]\n    · exact Finset.prod_mul_prod_compl _ _\n    · simp [s]\n    · simp [s]\n\n"}
{"name":"Fintype.sum_subtype_add_sum_subtype","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝² : Fintype α\ninst✝¹ : AddCommMonoid β\np : α → Prop\nf : α → β\ninst✝ : DecidablePred p\n⊢ Eq (HAdd.hAdd (Finset.univ.sum fun i => f ↑i) (Finset.univ.sum fun i => f ↑i)) (Finset.univ.sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_subtype_mul_prod_subtype {α β : Type*} [Fintype α] [CommMonoid β] (p : α → Prop)\n    (f : α → β) [DecidablePred p] :\n    (∏ i : { x // p x }, f i) * ∏ i : { x // ¬p x }, f i = ∏ i, f i := by\n  classical\n    let s := { x | p x }.toFinset\n    rw [← Finset.prod_subtype s, ← Finset.prod_subtype sᶜ]\n    · exact Finset.prod_mul_prod_compl _ _\n    · simp [s]\n    · simp [s]\n\n"}
{"name":"Fintype.sum_subset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝¹ : Fintype ι\ninst✝ : AddCommMonoid α\ns : Finset ι\nf : ι → α\nh : ∀ (i : ι), Ne (f i) 0 → Membership.mem s i\n⊢ Eq (s.sum fun i => f i) (Finset.univ.sum fun i => f i)","decl":"@[to_additive] lemma prod_subset {s : Finset ι} {f : ι → α} (h : ∀ i, f i ≠ 1 → i ∈ s) :\n    ∏ i ∈ s, f i = ∏ i, f i :=\n  Finset.prod_subset s.subset_univ <| by simpa [not_imp_comm (a := _ ∈ s)]\n\n"}
{"name":"Fintype.prod_subset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝¹ : Fintype ι\ninst✝ : CommMonoid α\ns : Finset ι\nf : ι → α\nh : ∀ (i : ι), Ne (f i) 1 → Membership.mem s i\n⊢ Eq (s.prod fun i => f i) (Finset.univ.prod fun i => f i)","decl":"@[to_additive] lemma prod_subset {s : Finset ι} {f : ι → α} (h : ∀ i, f i ≠ 1 → i ∈ s) :\n    ∏ i ∈ s, f i = ∏ i, f i :=\n  Finset.prod_subset s.subset_univ <| by simpa [not_imp_comm (a := _ ∈ s)]\n\n"}
{"name":"Fintype.sum_ite_eq_ite_exists","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : AddCommMonoid α\np : ι → Prop\ninst✝ : DecidablePred p\nh : ∀ (i j : ι), p i → p j → Eq i j\na : α\n⊢ Eq (Finset.univ.sum fun i => ite (p i) a 0) (ite (Exists fun i => p i) a 0)","decl":"@[to_additive]\nlemma prod_ite_eq_ite_exists (p : ι → Prop) [DecidablePred p] (h : ∀ i j, p i → p j → i = j)\n    (a : α) : ∏ i, ite (p i) a 1 = ite (∃ i, p i) a 1 := by\n  simp [prod_ite_one univ p (by simpa using h)]\n\n"}
{"name":"Fintype.prod_ite_eq_ite_exists","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : CommMonoid α\np : ι → Prop\ninst✝ : DecidablePred p\nh : ∀ (i j : ι), p i → p j → Eq i j\na : α\n⊢ Eq (Finset.univ.prod fun i => ite (p i) a 1) (ite (Exists fun i => p i) a 1)","decl":"@[to_additive]\nlemma prod_ite_eq_ite_exists (p : ι → Prop) [DecidablePred p] (h : ∀ i j, p i → p j → i = j)\n    (a : α) : ∏ i, ite (p i) a 1 = ite (∃ i, p i) a 1 := by\n  simp [prod_ite_one univ p (by simpa using h)]\n\n"}
{"name":"Fintype.prod_ite_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : CommMonoid α\ninst✝ : DecidableEq ι\ns : Finset ι\nf : ι → α\n⊢ Eq (Finset.univ.prod fun i => ite (Membership.mem s i) (f i) 1) (s.prod fun i => f i)","decl":"@[to_additive]\nlemma prod_ite_mem (s : Finset ι) (f : ι → α) : ∏ i, (if i ∈ s then f i else 1) = ∏ i ∈ s, f i := by\n  simp\n\n"}
{"name":"Fintype.sum_ite_mem","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : AddCommMonoid α\ninst✝ : DecidableEq ι\ns : Finset ι\nf : ι → α\n⊢ Eq (Finset.univ.sum fun i => ite (Membership.mem s i) (f i) 0) (s.sum fun i => f i)","decl":"@[to_additive]\nlemma prod_ite_mem (s : Finset ι) (f : ι → α) : ∏ i, (if i ∈ s then f i else 1) = ∏ i ∈ s, f i := by\n  simp\n\n"}
{"name":"Fintype.prod_dite_eq","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : CommMonoid α\ninst✝ : DecidableEq ι\ni : ι\nf : (j : ι) → Eq i j → α\n⊢ Eq (Finset.univ.prod fun j => dite (Eq i j) (fun h => f j h) fun h => 1) (f i ⋯)","decl":"/-- See also `Finset.prod_dite_eq`. -/\n@[to_additive \"See also `Finset.sum_dite_eq`.\"] lemma prod_dite_eq (i : ι) (f : ∀ j, i = j → α) :\n    ∏ j, (if h : i = j then f j h else 1) = f i rfl := by\n  rw [Finset.prod_dite_eq, if_pos (mem_univ _)]\n\n"}
{"name":"Fintype.sum_dite_eq","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : AddCommMonoid α\ninst✝ : DecidableEq ι\ni : ι\nf : (j : ι) → Eq i j → α\n⊢ Eq (Finset.univ.sum fun j => dite (Eq i j) (fun h => f j h) fun h => 0) (f i ⋯)","decl":"/-- See also `Finset.prod_dite_eq`. -/\n@[to_additive \"See also `Finset.sum_dite_eq`.\"] lemma prod_dite_eq (i : ι) (f : ∀ j, i = j → α) :\n    ∏ j, (if h : i = j then f j h else 1) = f i rfl := by\n  rw [Finset.prod_dite_eq, if_pos (mem_univ _)]\n\n"}
{"name":"Fintype.sum_dite_eq'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : AddCommMonoid α\ninst✝ : DecidableEq ι\ni : ι\nf : (j : ι) → Eq j i → α\n⊢ Eq (Finset.univ.sum fun j => dite (Eq j i) (fun h => f j h) fun h => 0) (f i ⋯)","decl":"/-- See also `Finset.prod_dite_eq'`. -/\n@[to_additive \"See also `Finset.sum_dite_eq'`.\"] lemma prod_dite_eq' (i : ι) (f : ∀ j, j = i → α) :\n    ∏ j, (if h : j = i then f j h else 1) = f i rfl := by\n  rw [Finset.prod_dite_eq', if_pos (mem_univ _)]\n\n"}
{"name":"Fintype.prod_dite_eq'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : CommMonoid α\ninst✝ : DecidableEq ι\ni : ι\nf : (j : ι) → Eq j i → α\n⊢ Eq (Finset.univ.prod fun j => dite (Eq j i) (fun h => f j h) fun h => 1) (f i ⋯)","decl":"/-- See also `Finset.prod_dite_eq'`. -/\n@[to_additive \"See also `Finset.sum_dite_eq'`.\"] lemma prod_dite_eq' (i : ι) (f : ∀ j, j = i → α) :\n    ∏ j, (if h : j = i then f j h else 1) = f i rfl := by\n  rw [Finset.prod_dite_eq', if_pos (mem_univ _)]\n\n"}
{"name":"Fintype.sum_ite_eq","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : AddCommMonoid α\ninst✝ : DecidableEq ι\ni : ι\nf : ι → α\n⊢ Eq (Finset.univ.sum fun j => ite (Eq i j) (f j) 0) (f i)","decl":"/-- See also `Finset.prod_ite_eq`. -/\n@[to_additive \"See also `Finset.sum_ite_eq`.\"]\nlemma prod_ite_eq (i : ι) (f : ι → α) : ∏ j, (if i = j then f j else 1) = f i := by\n  rw [Finset.prod_ite_eq, if_pos (mem_univ _)]\n\n"}
{"name":"Fintype.prod_ite_eq","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : CommMonoid α\ninst✝ : DecidableEq ι\ni : ι\nf : ι → α\n⊢ Eq (Finset.univ.prod fun j => ite (Eq i j) (f j) 1) (f i)","decl":"/-- See also `Finset.prod_ite_eq`. -/\n@[to_additive \"See also `Finset.sum_ite_eq`.\"]\nlemma prod_ite_eq (i : ι) (f : ι → α) : ∏ j, (if i = j then f j else 1) = f i := by\n  rw [Finset.prod_ite_eq, if_pos (mem_univ _)]\n\n"}
{"name":"Fintype.sum_ite_eq'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : AddCommMonoid α\ninst✝ : DecidableEq ι\ni : ι\nf : ι → α\n⊢ Eq (Finset.univ.sum fun j => ite (Eq j i) (f j) 0) (f i)","decl":"/-- See also `Finset.prod_ite_eq'`. -/\n@[to_additive \"See also `Finset.sum_ite_eq'`.\"]\nlemma prod_ite_eq' (i : ι) (f : ι → α) : ∏ j, (if j = i then f j else 1) = f i := by\n  rw [Finset.prod_ite_eq', if_pos (mem_univ _)]\n\n"}
{"name":"Fintype.prod_ite_eq'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : CommMonoid α\ninst✝ : DecidableEq ι\ni : ι\nf : ι → α\n⊢ Eq (Finset.univ.prod fun j => ite (Eq j i) (f j) 1) (f i)","decl":"/-- See also `Finset.prod_ite_eq'`. -/\n@[to_additive \"See also `Finset.sum_ite_eq'`.\"]\nlemma prod_ite_eq' (i : ι) (f : ι → α) : ∏ j, (if j = i then f j else 1) = f i := by\n  rw [Finset.prod_ite_eq', if_pos (mem_univ _)]\n\n"}
{"name":"Fintype.sum_pi_single","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\nα : ι → Type u_9\ninst✝ : (i : ι) → AddCommMonoid (α i)\ni : ι\nf : (i : ι) → α i\n⊢ Eq (Finset.univ.sum fun j => Pi.single j (f j) i) (f i)","decl":"/-- See also `Finset.prod_pi_mulSingle`. -/\n@[to_additive \"See also `Finset.sum_pi_single`.\"]\nlemma prod_pi_mulSingle {α : ι → Type*} [∀ i, CommMonoid (α i)] (i : ι) (f : ∀ i, α i) :\n    ∏ j, Pi.mulSingle j (f j) i = f i := prod_dite_eq _ _\n\n"}
{"name":"Fintype.prod_pi_mulSingle","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\nα : ι → Type u_9\ninst✝ : (i : ι) → CommMonoid (α i)\ni : ι\nf : (i : ι) → α i\n⊢ Eq (Finset.univ.prod fun j => Pi.mulSingle j (f j) i) (f i)","decl":"/-- See also `Finset.prod_pi_mulSingle`. -/\n@[to_additive \"See also `Finset.sum_pi_single`.\"]\nlemma prod_pi_mulSingle {α : ι → Type*} [∀ i, CommMonoid (α i)] (i : ι) (f : ∀ i, α i) :\n    ∏ j, Pi.mulSingle j (f j) i = f i := prod_dite_eq _ _\n\n"}
{"name":"Fintype.prod_pi_mulSingle'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : CommMonoid α\ninst✝ : DecidableEq ι\ni : ι\na : α\n⊢ Eq (Finset.univ.prod fun j => Pi.mulSingle i a j) a","decl":"/-- See also `Finset.prod_pi_mulSingle'`. -/\n@[to_additive \"See also `Finset.sum_pi_single'`.\"]\nlemma prod_pi_mulSingle' (i : ι) (a : α) : ∏ j, Pi.mulSingle i a j = a := prod_dite_eq' _ _\n\n"}
{"name":"Fintype.sum_pi_single'","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\nα : Type u_8\ninst✝² : Fintype ι\ninst✝¹ : AddCommMonoid α\ninst✝ : DecidableEq ι\ni : ι\na : α\n⊢ Eq (Finset.univ.sum fun j => Pi.single i a j) a","decl":"/-- See also `Finset.prod_pi_mulSingle'`. -/\n@[to_additive \"See also `Finset.sum_pi_single'`.\"]\nlemma prod_pi_mulSingle' (i : ι) (a : α) : ∏ j, Pi.mulSingle i a j = a := prod_dite_eq' _ _\n\n"}
{"name":"List.sum_toFinset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nM : Type u_6\ninst✝¹ : DecidableEq α\ninst✝ : AddCommMonoid M\nf : α → M\nl : List α\n_hl : l.Nodup\n⊢ Eq (l.toFinset.sum f) (List.map f l).sum","decl":"@[to_additive]\ntheorem prod_toFinset {M : Type*} [DecidableEq α] [CommMonoid M] (f : α → M) :\n    ∀ {l : List α} (_hl : l.Nodup), l.toFinset.prod f = (l.map f).prod\n  | [], _ => by simp\n  | a :: l, hl => by\n    let ⟨not_mem, hl⟩ := List.nodup_cons.mp hl\n    simp [Finset.prod_insert (mt List.mem_toFinset.mp not_mem), prod_toFinset _ hl]\n\n"}
{"name":"List.prod_toFinset","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nM : Type u_6\ninst✝¹ : DecidableEq α\ninst✝ : CommMonoid M\nf : α → M\nl : List α\n_hl : l.Nodup\n⊢ Eq (l.toFinset.prod f) (List.map f l).prod","decl":"@[to_additive]\ntheorem prod_toFinset {M : Type*} [DecidableEq α] [CommMonoid M] (f : α → M) :\n    ∀ {l : List α} (_hl : l.Nodup), l.toFinset.prod f = (l.map f).prod\n  | [], _ => by simp\n  | a :: l, hl => by\n    let ⟨not_mem, hl⟩ := List.nodup_cons.mp hl\n    simp [Finset.prod_insert (mt List.mem_toFinset.mp not_mem), prod_toFinset _ hl]\n\n"}
{"name":"List.sum_toFinset_count_eq_length","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (l.toFinset.sum fun a => List.count a l) l.length","decl":"@[simp]\ntheorem sum_toFinset_count_eq_length [DecidableEq α] (l : List α) :\n    ∑ a ∈ l.toFinset, l.count a = l.length := by\n  simpa [List.map_const'] using (Finset.sum_list_map_count l fun _ => (1 : ℕ)).symm\n\n"}
{"name":"Multiset.mem_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_1\nα : Type u_3\na : α\ns : Finset ι\nm : ι → Multiset α\n⊢ Iff (Membership.mem (s.sum fun i => m i) a) (Exists fun i => And (Membership.mem s i) (Membership.mem (m i) a))","decl":"@[simp]\nlemma mem_sum {s : Finset ι} {m : ι → Multiset α} : a ∈ ∑ i ∈ s, m i ↔ ∃ i ∈ s, a ∈ m i := by\n  induction s using Finset.cons_induction <;> simp [*]\n\n"}
{"name":"Multiset.toFinset_sum_count_eq","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq (s.toFinset.sum fun a => Multiset.count a s) s.card","decl":"theorem toFinset_sum_count_eq (s : Multiset α) : ∑ a ∈ s.toFinset, s.count a = card s := by\n  simpa using (Finset.sum_multiset_map_count s (fun _ => (1 : ℕ))).symm\n\n"}
{"name":"Multiset.sum_count_eq_card","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝ : DecidableEq α\ns : Finset α\nm : Multiset α\nhms : ∀ (a : α), Membership.mem m a → Membership.mem s a\n⊢ Eq (s.sum fun a => Multiset.count a m) m.card","decl":"@[simp] lemma sum_count_eq_card {s : Finset α} {m : Multiset α} (hms : ∀ a ∈ m, a ∈ s) :\n    ∑ a ∈ s, m.count a = card m := by\n  rw [← toFinset_sum_count_eq, ← Finset.sum_filter_ne_zero]\n  congr with a\n  simpa using hms a\n\n"}
{"name":"Multiset.toFinset_sum_count_nsmul_eq","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq (s.toFinset.sum fun a => HSMul.hSMul (Multiset.count a s) (Singleton.singleton a)) s","decl":"@[simp]\ntheorem toFinset_sum_count_nsmul_eq (s : Multiset α) :\n    ∑ a ∈ s.toFinset, s.count a • {a} = s := by\n  rw [← Finset.sum_multiset_map_count, Multiset.sum_map_singleton]\n\n"}
{"name":"Multiset.exists_smul_of_dvd_count","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\ninst✝ : DecidableEq α\ns : Multiset α\nk : Nat\nh : ∀ (a : α), Membership.mem s a → Dvd.dvd k (Multiset.count a s)\n⊢ Exists fun u => Eq s (HSMul.hSMul k u)","decl":"theorem exists_smul_of_dvd_count (s : Multiset α) {k : ℕ}\n    (h : ∀ a : α, a ∈ s → k ∣ Multiset.count a s) : ∃ u : Multiset α, s = k • u := by\n  use ∑ a ∈ s.toFinset, (s.count a / k) • {a}\n  have h₂ :\n    (∑ x ∈ s.toFinset, k • (count x s / k) • ({x} : Multiset α)) =\n      ∑ x ∈ s.toFinset, count x s • {x} := by\n    apply Finset.sum_congr rfl\n    intro x hx\n    rw [← mul_nsmul', Nat.mul_div_cancel' (h x (mem_toFinset.mp hx))]\n  rw [← Finset.sum_nsmul, h₂, toFinset_sum_count_nsmul_eq]\n\n"}
{"name":"Multiset.sum_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\nι : Type u_7\ninst✝ : AddCommMonoid α\nf : ι → Multiset α\ns : Finset ι\n⊢ Eq (s.sum fun x => f x).sum (s.sum fun x => (f x).sum)","decl":"@[to_additive]\ntheorem prod_sum {α : Type*} {ι : Type*} [CommMonoid α] (f : ι → Multiset α) (s : Finset ι) :\n    (∑ x ∈ s, f x).prod = ∏ x ∈ s, (f x).prod := by\n  induction s using Finset.cons_induction with\n  | empty => rw [Finset.sum_empty, Finset.prod_empty, Multiset.prod_zero]\n  | cons a s has ih => rw [Finset.sum_cons, Finset.prod_cons, Multiset.prod_add, ih]\n\n"}
{"name":"Multiset.prod_sum","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_6\nι : Type u_7\ninst✝ : CommMonoid α\nf : ι → Multiset α\ns : Finset ι\n⊢ Eq (s.sum fun x => f x).prod (s.prod fun x => (f x).prod)","decl":"@[to_additive]\ntheorem prod_sum {α : Type*} {ι : Type*} [CommMonoid α] (f : ι → Multiset α) (s : Finset ι) :\n    (∑ x ∈ s, f x).prod = ∏ x ∈ s, (f x).prod := by\n  induction s using Finset.cons_induction with\n  | empty => rw [Finset.sum_empty, Finset.prod_empty, Multiset.prod_zero]\n  | cons a s has ih => rw [Finset.sum_cons, Finset.prod_cons, Multiset.prod_add, ih]\n\n"}
{"name":"IsAddUnit.sum_iff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : AddCommMonoid β\n⊢ Iff (IsAddUnit (s.sum fun a => f a)) (∀ (a : α), Membership.mem s a → IsAddUnit (f a))","decl":"@[to_additive (attr := simp)]\nlemma IsUnit.prod_iff [CommMonoid β] : IsUnit (∏ a ∈ s, f a) ↔ ∀ a ∈ s, IsUnit (f a) := by\n  induction s using Finset.cons_induction with\n  | empty => simp\n  | cons a s ha hs => rw [Finset.prod_cons, IsUnit.mul_iff, hs, Finset.forall_mem_cons]\n\n"}
{"name":"IsUnit.prod_iff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ns : Finset α\nf : α → β\ninst✝ : CommMonoid β\n⊢ Iff (IsUnit (s.prod fun a => f a)) (∀ (a : α), Membership.mem s a → IsUnit (f a))","decl":"@[to_additive (attr := simp)]\nlemma IsUnit.prod_iff [CommMonoid β] : IsUnit (∏ a ∈ s, f a) ↔ ∀ a ∈ s, IsUnit (f a) := by\n  induction s using Finset.cons_induction with\n  | empty => simp\n  | cons a s ha hs => rw [Finset.prod_cons, IsUnit.mul_iff, hs, Finset.forall_mem_cons]\n\n"}
{"name":"IsAddUnit.sum_univ_iff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ninst✝¹ : Fintype α\ninst✝ : AddCommMonoid β\n⊢ Iff (IsAddUnit (Finset.univ.sum fun a => f a)) (∀ (a : α), IsAddUnit (f a))","decl":"@[to_additive]\nlemma IsUnit.prod_univ_iff [Fintype α] [CommMonoid β] : IsUnit (∏ a, f a) ↔ ∀ a, IsUnit (f a) := by\n  simp\n\n"}
{"name":"IsUnit.prod_univ_iff","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ninst✝¹ : Fintype α\ninst✝ : CommMonoid β\n⊢ Iff (IsUnit (Finset.univ.prod fun a => f a)) (∀ (a : α), IsUnit (f a))","decl":"@[to_additive]\nlemma IsUnit.prod_univ_iff [Fintype α] [CommMonoid β] : IsUnit (∏ a, f a) ↔ ∀ a, IsUnit (f a) := by\n  simp\n\n"}
{"name":"nat_abs_sum_le","module":"Mathlib.Algebra.BigOperators.Group.Finset.Basic","initialProofState":"ι : Type u_6\ns : Finset ι\nf : ι → Int\n⊢ LE.le (s.sum fun i => f i).natAbs (s.sum fun i => (f i).natAbs)","decl":"theorem nat_abs_sum_le {ι : Type*} (s : Finset ι) (f : ι → ℤ) :\n    (∑ i ∈ s, f i).natAbs ≤ ∑ i ∈ s, (f i).natAbs := by\n  induction s using Finset.cons_induction with\n  | empty => simp only [Finset.sum_empty, Int.natAbs_zero, le_refl]\n  | cons i s his IH =>\n    simp only [Finset.sum_cons, not_false_iff]\n    exact (Int.natAbs_add_le _ _).trans (Nat.add_le_add_left IH _)\n\n"}
