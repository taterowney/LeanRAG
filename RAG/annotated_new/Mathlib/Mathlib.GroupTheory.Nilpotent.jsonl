{"name":"mem_upperCentralSeriesStep","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.Normal\nx : G\n⊢ Iff (Membership.mem (upperCentralSeriesStep H) x) (∀ (y : G), Membership.mem H (HMul.hMul (HMul.hMul (HMul.hMul x y) (Inv.inv x)) (Inv.inv y)))","decl":"theorem mem_upperCentralSeriesStep (x : G) :\n    x ∈ upperCentralSeriesStep H ↔ ∀ y, x * y * x⁻¹ * y⁻¹ ∈ H := Iff.rfl\n\n"}
{"name":"upperCentralSeriesStep_eq_comap_center","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.Normal\n⊢ Eq (upperCentralSeriesStep H) (Subgroup.comap (QuotientGroup.mk' H) (Subgroup.center (HasQuotient.Quotient G H)))","decl":"/-- The proof that `upperCentralSeriesStep H` is the preimage of the centre of `G/H` under\nthe canonical surjection. -/\ntheorem upperCentralSeriesStep_eq_comap_center :\n    upperCentralSeriesStep H = Subgroup.comap (mk' H) (center (G ⧸ H)) := by\n  ext\n  rw [mem_comap, mem_center_iff, forall_mk]\n  apply forall_congr'\n  intro y\n  rw [coe_mk', ← QuotientGroup.mk_mul, ← QuotientGroup.mk_mul, eq_comm, eq_iff_div_mem,\n    div_eq_mul_inv, mul_inv_rev, mul_assoc]\n\n"}
{"name":"instNormalUpperCentralSeriesStep","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ (upperCentralSeriesStep H).Normal","decl":"instance : Normal (upperCentralSeriesStep H) := by\n  rw [upperCentralSeriesStep_eq_comap_center]\n  infer_instance\n\n"}
{"name":"upperCentralSeries_normal","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nn : Nat\n⊢ (upperCentralSeries G n).Normal","decl":"instance upperCentralSeries_normal (n : ℕ) : Normal (upperCentralSeries G n) :=\n  (upperCentralSeriesAux G n).2\n\n"}
{"name":"upperCentralSeries_zero","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (upperCentralSeries G 0) Bot.bot","decl":"@[simp]\ntheorem upperCentralSeries_zero : upperCentralSeries G 0 = ⊥ := rfl\n\n"}
{"name":"upperCentralSeries_one","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (upperCentralSeries G 1) (Subgroup.center G)","decl":"@[simp]\ntheorem upperCentralSeries_one : upperCentralSeries G 1 = center G := by\n  ext\n  simp only [upperCentralSeries, upperCentralSeriesAux, upperCentralSeriesStep,\n    Subgroup.mem_center_iff, mem_mk, mem_bot, Set.mem_setOf_eq]\n  exact forall_congr' fun y => by rw [mul_inv_eq_one, mul_inv_eq_iff_eq_mul, eq_comm]\n\n"}
{"name":"mem_upperCentralSeries_succ_iff","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nn : Nat\nx : G\n⊢ Iff (Membership.mem (upperCentralSeries G (HAdd.hAdd n 1)) x) (∀ (y : G), Membership.mem (upperCentralSeries G n) (HMul.hMul (HMul.hMul (HMul.hMul x y) (Inv.inv x)) (Inv.inv y)))","decl":"/-- The `n+1`st term of the upper central series `H i` has underlying set equal to the `x` such\nthat `⁅x,G⁆ ⊆ H n`-/\ntheorem mem_upperCentralSeries_succ_iff {n : ℕ} {x : G} :\n    x ∈ upperCentralSeries G (n + 1) ↔ ∀ y : G, x * y * x⁻¹ * y⁻¹ ∈ upperCentralSeries G n :=\n  Iff.rfl\n\n"}
{"name":"comap_upperCentralSeries","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Type u_2\ninst✝ : Group H\ne : MulEquiv H G\nn : Nat\n⊢ Eq (Subgroup.comap (↑e) (upperCentralSeries G n)) (upperCentralSeries H n)","decl":"@[simp] lemma comap_upperCentralSeries {H : Type*} [Group H] (e : H ≃* G) :\n    ∀ n, (upperCentralSeries G n).comap e = upperCentralSeries H n\n  | 0 => by simpa [MonoidHom.ker_eq_bot_iff] using e.injective\n  | n + 1 => by\n    ext\n    simp [mem_upperCentralSeries_succ_iff, ← comap_upperCentralSeries e n,\n      ← e.toEquiv.forall_congr_right]\n\n"}
{"name":"Group.IsNilpotent.nilpotent'","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_2\ninst✝ : Group G\nself : Group.IsNilpotent G\n⊢ Exists fun n => Eq (upperCentralSeries G n) Top.top","decl":"variable (G) in\n-- `IsNilpotent` is already defined in the root namespace (for elements of rings).\n-- TODO: Rename it to `IsNilpotentElement`?\n/-- A group `G` is nilpotent if its upper central series is eventually `G`. -/\n@[mk_iff]\nclass IsNilpotent (G : Type*) [Group G] : Prop where\n  nilpotent' : ∃ n : ℕ, upperCentralSeries G n = ⊤\n\n-- Porting note: add lemma since infer kinds are unsupported in the definition of `IsNilpotent`\n"}
{"name":"Group.isNilpotent_iff","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_2\ninst✝ : Group G\n⊢ Iff (Group.IsNilpotent G) (Exists fun n => Eq (upperCentralSeries G n) Top.top)","decl":"variable (G) in\n-- `IsNilpotent` is already defined in the root namespace (for elements of rings).\n-- TODO: Rename it to `IsNilpotentElement`?\n/-- A group `G` is nilpotent if its upper central series is eventually `G`. -/\n@[mk_iff]\nclass IsNilpotent (G : Type*) [Group G] : Prop where\n  nilpotent' : ∃ n : ℕ, upperCentralSeries G n = ⊤\n\n-- Porting note: add lemma since infer kinds are unsupported in the definition of `IsNilpotent`\n"}
{"name":"Group.IsNilpotent.nilpotent","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_2\ninst✝¹ : Group G\ninst✝ : Group.IsNilpotent G\n⊢ Exists fun n => Eq (upperCentralSeries G n) Top.top","decl":"lemma IsNilpotent.nilpotent (G : Type*) [Group G] [IsNilpotent G] :\n    ∃ n : ℕ, upperCentralSeries G n = ⊤ := Group.IsNilpotent.nilpotent'\n\n"}
{"name":"Group.isNilpotent_congr","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Type u_2\ninst✝ : Group H\ne : MulEquiv G H\n⊢ Iff (Group.IsNilpotent G) (Group.IsNilpotent H)","decl":"lemma isNilpotent_congr {H : Type*} [Group H] (e : G ≃* H) : IsNilpotent G ↔ IsNilpotent H := by\n  simp_rw [isNilpotent_iff]\n  refine exists_congr fun n ↦ ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · simp [← Subgroup.comap_top e.symm.toMonoidHom, ← h]\n  · simp [← Subgroup.comap_top e.toMonoidHom, ← h]\n\n"}
{"name":"Group.isNilpotent_top","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Iff (Group.IsNilpotent (Subtype fun x => Membership.mem Top.top x)) (Group.IsNilpotent G)","decl":"@[simp] lemma isNilpotent_top : IsNilpotent (⊤ : Subgroup G) ↔ IsNilpotent G :=\n  isNilpotent_congr Subgroup.topEquiv\n\n"}
{"name":"Group.IsNilpotent.isVirtuallyNilpotent","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nhG : Group.IsNilpotent G\n⊢ Group.IsVirtuallyNilpotent G","decl":"lemma IsNilpotent.isVirtuallyNilpotent (hG : IsNilpotent G) : IsVirtuallyNilpotent G :=\n  ⟨⊤, by simpa, inferInstance⟩\n\n"}
{"name":"ascending_central_series_le_upper","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Nat → Subgroup G\nhH : IsAscendingCentralSeries H\nn : Nat\n⊢ LE.le (H n) (upperCentralSeries G n)","decl":"/-- Any ascending central series for a group is bounded above by the upper central series. -/\ntheorem ascending_central_series_le_upper (H : ℕ → Subgroup G) (hH : IsAscendingCentralSeries H) :\n    ∀ n : ℕ, H n ≤ upperCentralSeries G n\n  | 0 => hH.1.symm ▸ le_refl ⊥\n  | n + 1 => by\n    intro x hx\n    rw [mem_upperCentralSeries_succ_iff]\n    exact fun y => ascending_central_series_le_upper H hH n (hH.2 x n hx y)\n\n"}
{"name":"upperCentralSeries_isAscendingCentralSeries","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ IsAscendingCentralSeries (upperCentralSeries G)","decl":"/-- The upper central series of a group is an ascending central series. -/\ntheorem upperCentralSeries_isAscendingCentralSeries :\n    IsAscendingCentralSeries (upperCentralSeries G) :=\n  ⟨rfl, fun _x _n h => h⟩\n\n"}
{"name":"upperCentralSeries_mono","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Monotone (upperCentralSeries G)","decl":"theorem upperCentralSeries_mono : Monotone (upperCentralSeries G) := by\n  refine monotone_nat_of_le_succ ?_\n  intro n x hx y\n  rw [mul_assoc, mul_assoc, ← mul_assoc y x⁻¹ y⁻¹]\n  exact mul_mem hx (Normal.conj_mem (upperCentralSeries_normal G n) x⁻¹ (inv_mem hx) y)\n\n"}
{"name":"nilpotent_iff_finite_ascending_central_series","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Iff (Group.IsNilpotent G) (Exists fun n => Exists fun H => And (IsAscendingCentralSeries H) (Eq (H n) Top.top))","decl":"/-- A group `G` is nilpotent iff there exists an ascending central series which reaches `G` in\n  finitely many steps. -/\ntheorem nilpotent_iff_finite_ascending_central_series :\n    IsNilpotent G ↔ ∃ n : ℕ, ∃ H : ℕ → Subgroup G, IsAscendingCentralSeries H ∧ H n = ⊤ := by\n  constructor\n  · rintro ⟨n, nH⟩\n    exact ⟨_, _, upperCentralSeries_isAscendingCentralSeries G, nH⟩\n  · rintro ⟨n, H, hH, hn⟩\n    use n\n    rw [eq_top_iff, ← hn]\n    exact ascending_central_series_le_upper H hH n\n\n"}
{"name":"is_descending_rev_series_of_is_ascending","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Nat → Subgroup G\nn : Nat\nhn : Eq (H n) Top.top\nhasc : IsAscendingCentralSeries H\n⊢ IsDescendingCentralSeries fun m => H (HSub.hSub n m)","decl":"theorem is_descending_rev_series_of_is_ascending {H : ℕ → Subgroup G} {n : ℕ} (hn : H n = ⊤)\n    (hasc : IsAscendingCentralSeries H) : IsDescendingCentralSeries fun m : ℕ => H (n - m) := by\n  cases' hasc with h0 hH\n  refine ⟨hn, fun x m hx g => ?_⟩\n  dsimp at hx\n  by_cases hm : n ≤ m\n  · rw [tsub_eq_zero_of_le hm, h0, Subgroup.mem_bot] at hx\n    subst hx\n    rw [show (1 : G) * g * (1⁻¹ : G) * g⁻¹ = 1 by group]\n    exact Subgroup.one_mem _\n  · push_neg at hm\n    apply hH\n    convert hx using 1\n    rw [tsub_add_eq_add_tsub (Nat.succ_le_of_lt hm), Nat.succ_eq_add_one, Nat.add_sub_add_right]\n\n"}
{"name":"is_decending_rev_series_of_is_ascending","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Nat → Subgroup G\nn : Nat\nhn : Eq (H n) Top.top\nhasc : IsAscendingCentralSeries H\n⊢ IsDescendingCentralSeries fun m => H (HSub.hSub n m)","decl":"@[deprecated (since := \"2024-12-25\")]\nalias is_decending_rev_series_of_is_ascending := is_descending_rev_series_of_is_ascending\n\n"}
{"name":"is_ascending_rev_series_of_is_descending","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Nat → Subgroup G\nn : Nat\nhn : Eq (H n) Bot.bot\nhdesc : IsDescendingCentralSeries H\n⊢ IsAscendingCentralSeries fun m => H (HSub.hSub n m)","decl":"theorem is_ascending_rev_series_of_is_descending {H : ℕ → Subgroup G} {n : ℕ} (hn : H n = ⊥)\n    (hdesc : IsDescendingCentralSeries H) : IsAscendingCentralSeries fun m : ℕ => H (n - m) := by\n  cases' hdesc with h0 hH\n  refine ⟨hn, fun x m hx g => ?_⟩\n  dsimp only at hx ⊢\n  by_cases hm : n ≤ m\n  · have hnm : n - m = 0 := tsub_eq_zero_iff_le.mpr hm\n    rw [hnm, h0]\n    exact mem_top _\n  · push_neg at hm\n    convert hH x _ hx g using 1\n    rw [tsub_add_eq_add_tsub (Nat.succ_le_of_lt hm), Nat.succ_eq_add_one, Nat.add_sub_add_right]\n\n"}
{"name":"nilpotent_iff_finite_descending_central_series","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Iff (Group.IsNilpotent G) (Exists fun n => Exists fun H => And (IsDescendingCentralSeries H) (Eq (H n) Bot.bot))","decl":"/-- A group `G` is nilpotent iff there exists a descending central series which reaches the\n  trivial group in a finite time. -/\ntheorem nilpotent_iff_finite_descending_central_series :\n    IsNilpotent G ↔ ∃ n : ℕ, ∃ H : ℕ → Subgroup G, IsDescendingCentralSeries H ∧ H n = ⊥ := by\n  rw [nilpotent_iff_finite_ascending_central_series]\n  constructor\n  · rintro ⟨n, H, hH, hn⟩\n    refine ⟨n, fun m => H (n - m), is_descending_rev_series_of_is_ascending G hn hH, ?_⟩\n    dsimp only\n    rw [tsub_self]\n    exact hH.1\n  · rintro ⟨n, H, hH, hn⟩\n    refine ⟨n, fun m => H (n - m), is_ascending_rev_series_of_is_descending G hn hH, ?_⟩\n    dsimp only\n    rw [tsub_self]\n    exact hH.1\n\n"}
{"name":"lowerCentralSeries_zero","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (lowerCentralSeries G 0) Top.top","decl":"@[simp]\ntheorem lowerCentralSeries_zero : lowerCentralSeries G 0 = ⊤ := rfl\n\n"}
{"name":"lowerCentralSeries_one","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (lowerCentralSeries G 1) (commutator G)","decl":"@[simp]\ntheorem lowerCentralSeries_one : lowerCentralSeries G 1 = commutator G := rfl\n\n"}
{"name":"mem_lowerCentralSeries_succ_iff","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nn : Nat\nq : G\n⊢ Iff (Membership.mem (lowerCentralSeries G (HAdd.hAdd n 1)) q) (Membership.mem (Subgroup.closure (setOf fun x => Exists fun p => And (Membership.mem (lowerCentralSeries G n) p) (Exists fun q => And (Membership.mem Top.top q) (Eq (HMul.hMul (HMul.hMul (HMul.hMul p q) (Inv.inv p)) (Inv.inv q)) x)))) q)","decl":"theorem mem_lowerCentralSeries_succ_iff (n : ℕ) (q : G) :\n    q ∈ lowerCentralSeries G (n + 1) ↔\n    q ∈ closure { x | ∃ p ∈ lowerCentralSeries G n,\n                        ∃ q ∈ (⊤ : Subgroup G), p * q * p⁻¹ * q⁻¹ = x } := Iff.rfl\n\n"}
{"name":"lowerCentralSeries_succ","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nn : Nat\n⊢ Eq (lowerCentralSeries G (HAdd.hAdd n 1)) (Subgroup.closure (setOf fun x => Exists fun p => And (Membership.mem (lowerCentralSeries G n) p) (Exists fun q => And (Membership.mem Top.top q) (Eq (HMul.hMul (HMul.hMul (HMul.hMul p q) (Inv.inv p)) (Inv.inv q)) x))))","decl":"theorem lowerCentralSeries_succ (n : ℕ) :\n    lowerCentralSeries G (n + 1) =\n      closure { x | ∃ p ∈ lowerCentralSeries G n, ∃ q ∈ (⊤ : Subgroup G), p * q * p⁻¹ * q⁻¹ = x } :=\n  rfl\n\n"}
{"name":"lowerCentralSeries_normal","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nn : Nat\n⊢ (lowerCentralSeries G n).Normal","decl":"instance lowerCentralSeries_normal (n : ℕ) : Normal (lowerCentralSeries G n) := by\n  induction' n with d hd\n  · exact (⊤ : Subgroup G).normal_of_characteristic\n  · exact @Subgroup.commutator_normal _ _ (lowerCentralSeries G d) ⊤ hd _\n\n"}
{"name":"lowerCentralSeries_antitone","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Antitone (lowerCentralSeries G)","decl":"theorem lowerCentralSeries_antitone : Antitone (lowerCentralSeries G) := by\n  refine antitone_nat_of_succ_le fun n x hx => ?_\n  simp only [mem_lowerCentralSeries_succ_iff, exists_prop, mem_top, exists_true_left,\n    true_and] at hx\n  refine\n    closure_induction ?_ (Subgroup.one_mem _) (fun _ _ _ _ ↦ mul_mem) (fun _ _ ↦ inv_mem) hx\n  rintro y ⟨z, hz, a, ha⟩\n  rw [← ha, mul_assoc, mul_assoc, ← mul_assoc a z⁻¹ a⁻¹]\n  exact mul_mem hz (Normal.conj_mem (lowerCentralSeries_normal n) z⁻¹ (inv_mem hz) a)\n\n\n"}
{"name":"lowerCentralSeries_isDescendingCentralSeries","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ IsDescendingCentralSeries (lowerCentralSeries G)","decl":"/-- The lower central series of a group is a descending central series. -/\ntheorem lowerCentralSeries_isDescendingCentralSeries :\n    IsDescendingCentralSeries (lowerCentralSeries G) := by\n  constructor\n  · rfl\n  intro x n hxn g\n  exact commutator_mem_commutator hxn (mem_top g)\n\n"}
{"name":"descending_central_series_ge_lower","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Nat → Subgroup G\nhH : IsDescendingCentralSeries H\nn : Nat\n⊢ LE.le (lowerCentralSeries G n) (H n)","decl":"/-- Any descending central series for a group is bounded below by the lower central series. -/\ntheorem descending_central_series_ge_lower (H : ℕ → Subgroup G) (hH : IsDescendingCentralSeries H) :\n    ∀ n : ℕ, lowerCentralSeries G n ≤ H n\n  | 0 => hH.1.symm ▸ le_refl ⊤\n  | n + 1 => commutator_le.mpr fun x hx q _ =>\n      hH.2 x n (descending_central_series_ge_lower H hH n hx) q\n\n"}
{"name":"nilpotent_iff_lowerCentralSeries","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Iff (Group.IsNilpotent G) (Exists fun n => Eq (lowerCentralSeries G n) Bot.bot)","decl":"/-- A group is nilpotent if and only if its lower central series eventually reaches\n  the trivial subgroup. -/\ntheorem nilpotent_iff_lowerCentralSeries : IsNilpotent G ↔ ∃ n, lowerCentralSeries G n = ⊥ := by\n  rw [nilpotent_iff_finite_descending_central_series]\n  constructor\n  · rintro ⟨n, H, ⟨h0, hs⟩, hn⟩\n    use n\n    rw [eq_bot_iff, ← hn]\n    exact descending_central_series_ge_lower H ⟨h0, hs⟩ n\n  · rintro ⟨n, hn⟩\n    exact ⟨n, lowerCentralSeries G, lowerCentralSeries_isDescendingCentralSeries, hn⟩\n\n"}
{"name":"upperCentralSeries_nilpotencyClass","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nhG : Group.IsNilpotent G\n⊢ Eq (upperCentralSeries G (Group.nilpotencyClass G)) Top.top","decl":"open scoped Classical in\n@[simp]\ntheorem upperCentralSeries_nilpotencyClass : upperCentralSeries G (Group.nilpotencyClass G) = ⊤ :=\n  Nat.find_spec (IsNilpotent.nilpotent G)\n\n"}
{"name":"upperCentralSeries_eq_top_iff_nilpotencyClass_le","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nhG : Group.IsNilpotent G\nn : Nat\n⊢ Iff (Eq (upperCentralSeries G n) Top.top) (LE.le (Group.nilpotencyClass G) n)","decl":"theorem upperCentralSeries_eq_top_iff_nilpotencyClass_le {n : ℕ} :\n    upperCentralSeries G n = ⊤ ↔ Group.nilpotencyClass G ≤ n := by\n  classical\n  constructor\n  · intro h\n    exact Nat.find_le h\n  · intro h\n    rw [eq_top_iff, ← upperCentralSeries_nilpotencyClass]\n    exact upperCentralSeries_mono _ h\n\n"}
{"name":"least_ascending_central_series_length_eq_nilpotencyClass","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nhG : Group.IsNilpotent G\n⊢ Eq (Nat.find ⋯) (Group.nilpotencyClass G)","decl":"open scoped Classical in\n/-- The nilpotency class of a nilpotent `G` is equal to the smallest `n` for which an ascending\ncentral series reaches `G` in its `n`'th term. -/\ntheorem least_ascending_central_series_length_eq_nilpotencyClass :\n    Nat.find ((nilpotent_iff_finite_ascending_central_series G).mp hG) =\n    Group.nilpotencyClass G := by\n  refine le_antisymm (Nat.find_mono ?_) (Nat.find_mono ?_)\n  · intro n hn\n    exact ⟨upperCentralSeries G, upperCentralSeries_isAscendingCentralSeries G, hn⟩\n  · rintro n ⟨H, ⟨hH, hn⟩⟩\n    rw [← top_le_iff, ← hn]\n    exact ascending_central_series_le_upper H hH n\n\n"}
{"name":"least_descending_central_series_length_eq_nilpotencyClass","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nhG : Group.IsNilpotent G\n⊢ Eq (Nat.find ⋯) (Group.nilpotencyClass G)","decl":"open scoped Classical in\n/-- The nilpotency class of a nilpotent `G` is equal to the smallest `n` for which the descending\ncentral series reaches `⊥` in its `n`'th term. -/\ntheorem least_descending_central_series_length_eq_nilpotencyClass :\n    Nat.find ((nilpotent_iff_finite_descending_central_series G).mp hG) =\n    Group.nilpotencyClass G := by\n  rw [← least_ascending_central_series_length_eq_nilpotencyClass]\n  refine le_antisymm (Nat.find_mono ?_) (Nat.find_mono ?_)\n  · rintro n ⟨H, ⟨hH, hn⟩⟩\n    refine ⟨fun m => H (n - m), is_descending_rev_series_of_is_ascending G hn hH, ?_⟩\n    dsimp only\n    rw [tsub_self]\n    exact hH.1\n  · rintro n ⟨H, ⟨hH, hn⟩⟩\n    refine ⟨fun m => H (n - m), is_ascending_rev_series_of_is_descending G hn hH, ?_⟩\n    dsimp only\n    rw [tsub_self]\n    exact hH.1\n\n"}
{"name":"lowerCentralSeries_length_eq_nilpotencyClass","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nhG : Group.IsNilpotent G\n⊢ Eq (Nat.find ⋯) (Group.nilpotencyClass G)","decl":"open scoped Classical in\n/-- The nilpotency class of a nilpotent `G` is equal to the length of the lower central series. -/\ntheorem lowerCentralSeries_length_eq_nilpotencyClass :\n    Nat.find (nilpotent_iff_lowerCentralSeries.mp hG) = Group.nilpotencyClass (G := G) := by\n  rw [← least_descending_central_series_length_eq_nilpotencyClass]\n  refine le_antisymm (Nat.find_mono ?_) (Nat.find_mono ?_)\n  · rintro n ⟨H, ⟨hH, hn⟩⟩\n    rw [← le_bot_iff, ← hn]\n    exact descending_central_series_ge_lower H hH n\n  · rintro n h\n    exact ⟨lowerCentralSeries G, ⟨lowerCentralSeries_isDescendingCentralSeries, h⟩⟩\n\n"}
{"name":"lowerCentralSeries_nilpotencyClass","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nhG : Group.IsNilpotent G\n⊢ Eq (lowerCentralSeries G (Group.nilpotencyClass G)) Bot.bot","decl":"@[simp]\ntheorem lowerCentralSeries_nilpotencyClass :\n    lowerCentralSeries G (Group.nilpotencyClass G) = ⊥ := by\n  classical\n  rw [← lowerCentralSeries_length_eq_nilpotencyClass]\n  exact Nat.find_spec (nilpotent_iff_lowerCentralSeries.mp hG)\n\n"}
{"name":"lowerCentralSeries_eq_bot_iff_nilpotencyClass_le","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nhG : Group.IsNilpotent G\nn : Nat\n⊢ Iff (Eq (lowerCentralSeries G n) Bot.bot) (LE.le (Group.nilpotencyClass G) n)","decl":"theorem lowerCentralSeries_eq_bot_iff_nilpotencyClass_le {n : ℕ} :\n    lowerCentralSeries G n = ⊥ ↔ Group.nilpotencyClass G ≤ n := by\n  classical\n  constructor\n  · intro h\n    rw [← lowerCentralSeries_length_eq_nilpotencyClass]\n    exact Nat.find_le h\n  · intro h\n    rw [eq_bot_iff, ← lowerCentralSeries_nilpotencyClass]\n    exact lowerCentralSeries_antitone h\n\n"}
{"name":"lowerCentralSeries_map_subtype_le","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nn : Nat\n⊢ LE.le (Subgroup.map H.subtype (lowerCentralSeries (Subtype fun x => Membership.mem H x) n)) (lowerCentralSeries G n)","decl":"theorem lowerCentralSeries_map_subtype_le (H : Subgroup G) (n : ℕ) :\n    (lowerCentralSeries H n).map H.subtype ≤ lowerCentralSeries G n := by\n  induction' n with d hd\n  · simp\n  · rw [lowerCentralSeries_succ, lowerCentralSeries_succ, MonoidHom.map_closure]\n    apply Subgroup.closure_mono\n    rintro x1 ⟨x2, ⟨x3, hx3, x4, _hx4, rfl⟩, rfl⟩\n    exact ⟨x3, hd (mem_map.mpr ⟨x3, hx3, rfl⟩), x4, by simp⟩\n\n"}
{"name":"Subgroup.isNilpotent","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nhG : Group.IsNilpotent G\n⊢ Group.IsNilpotent (Subtype fun x => Membership.mem H x)","decl":"/-- A subgroup of a nilpotent group is nilpotent -/\ninstance Subgroup.isNilpotent (H : Subgroup G) [hG : IsNilpotent G] : IsNilpotent H := by\n  rw [nilpotent_iff_lowerCentralSeries] at *\n  rcases hG with ⟨n, hG⟩\n  use n\n  have := lowerCentralSeries_map_subtype_le H n\n  simp only [hG, SetLike.le_def, mem_map, forall_apply_eq_imp_iff₂, exists_imp] at this\n  exact eq_bot_iff.mpr fun x hx => Subtype.ext (this x ⟨hx, rfl⟩)\n\n"}
{"name":"Subgroup.nilpotencyClass_le","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nhG : Group.IsNilpotent G\n⊢ LE.le (Group.nilpotencyClass (Subtype fun x => Membership.mem H x)) (Group.nilpotencyClass G)","decl":"/-- The nilpotency class of a subgroup is less or equal to the nilpotency class of the group -/\ntheorem Subgroup.nilpotencyClass_le (H : Subgroup G) [hG : IsNilpotent G] :\n    Group.nilpotencyClass H ≤ Group.nilpotencyClass G := by\n  repeat rw [← lowerCentralSeries_length_eq_nilpotencyClass]\n  --- Porting note: Lean needs to be told that predicates are decidable\n  refine @Nat.find_mono _ _ (Classical.decPred _) (Classical.decPred _) ?_ _ _\n  intro n hG\n  have := lowerCentralSeries_map_subtype_le H n\n  simp only [hG, SetLike.le_def, mem_map, forall_apply_eq_imp_iff₂, exists_imp] at this\n  exact eq_bot_iff.mpr fun x hx => Subtype.ext (this x ⟨hx, rfl⟩)\n\n"}
{"name":"Group.isNilpotent_of_subsingleton","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Subsingleton G\n⊢ Group.IsNilpotent G","decl":"instance (priority := 100) Group.isNilpotent_of_subsingleton [Subsingleton G] : IsNilpotent G :=\n  nilpotent_iff_lowerCentralSeries.2 ⟨0, Subsingleton.elim ⊤ ⊥⟩\n\n"}
{"name":"upperCentralSeries.map","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Type u_2\ninst✝ : Group H\nf : MonoidHom G H\nh : Function.Surjective ⇑f\nn : Nat\n⊢ LE.le (Subgroup.map f (upperCentralSeries G n)) (upperCentralSeries H n)","decl":"theorem upperCentralSeries.map {H : Type*} [Group H] {f : G →* H} (h : Function.Surjective f)\n    (n : ℕ) : Subgroup.map f (upperCentralSeries G n) ≤ upperCentralSeries H n := by\n  induction' n with d hd\n  · simp\n  · rintro _ ⟨x, hx : x ∈ upperCentralSeries G d.succ, rfl⟩ y'\n    rcases h y' with ⟨y, rfl⟩\n    simpa using hd (mem_map_of_mem f (hx y))\n\n"}
{"name":"lowerCentralSeries.map","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Type u_2\ninst✝ : Group H\nf : MonoidHom G H\nn : Nat\n⊢ LE.le (Subgroup.map f (lowerCentralSeries G n)) (lowerCentralSeries H n)","decl":"theorem lowerCentralSeries.map {H : Type*} [Group H] (f : G →* H) (n : ℕ) :\n    Subgroup.map f (lowerCentralSeries G n) ≤ lowerCentralSeries H n := by\n  induction' n with d hd\n  · simp\n  · rintro a ⟨x, hx : x ∈ lowerCentralSeries G d.succ, rfl⟩\n    refine closure_induction (hx := hx) ?_ (by simp [f.map_one, Subgroup.one_mem _])\n      (fun y z _ _ hy hz => by simp [MonoidHom.map_mul, Subgroup.mul_mem _ hy hz]) (fun y _ hy => by\n        rw [f.map_inv]; exact Subgroup.inv_mem _ hy)\n    rintro a ⟨y, hy, z, ⟨-, rfl⟩⟩\n    apply mem_closure.mpr\n    exact fun K hK => hK ⟨f y, hd (mem_map_of_mem f hy), by simp [commutatorElement_def]⟩\n\n"}
{"name":"lowerCentralSeries_succ_eq_bot","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nn : Nat\nh : LE.le (lowerCentralSeries G n) (Subgroup.center G)\n⊢ Eq (lowerCentralSeries G (HAdd.hAdd n 1)) Bot.bot","decl":"theorem lowerCentralSeries_succ_eq_bot {n : ℕ} (h : lowerCentralSeries G n ≤ center G) :\n    lowerCentralSeries G (n + 1) = ⊥ := by\n  rw [lowerCentralSeries_succ, closure_eq_bot_iff, Set.subset_singleton_iff]\n  rintro x ⟨y, hy1, z, ⟨⟩, rfl⟩\n  rw [mul_assoc, ← mul_inv_rev, mul_inv_eq_one, eq_comm]\n  exact mem_center_iff.mp (h hy1) z\n\n"}
{"name":"isNilpotent_of_ker_le_center","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Type u_2\ninst✝ : Group H\nf : MonoidHom G H\nhf1 : LE.le f.ker (Subgroup.center G)\nhH : Group.IsNilpotent H\n⊢ Group.IsNilpotent G","decl":"/-- The preimage of a nilpotent group is nilpotent if the kernel of the homomorphism is contained\nin the center -/\ntheorem isNilpotent_of_ker_le_center {H : Type*} [Group H] (f : G →* H) (hf1 : f.ker ≤ center G)\n    (hH : IsNilpotent H) : IsNilpotent G := by\n  rw [nilpotent_iff_lowerCentralSeries] at *\n  rcases hH with ⟨n, hn⟩\n  use n + 1\n  refine lowerCentralSeries_succ_eq_bot (le_trans ((Subgroup.map_eq_bot_iff _).mp ?_) hf1)\n  exact eq_bot_iff.mpr (hn ▸ lowerCentralSeries.map f n)\n\n"}
{"name":"nilpotencyClass_le_of_ker_le_center","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Type u_2\ninst✝ : Group H\nf : MonoidHom G H\nhf1 : LE.le f.ker (Subgroup.center G)\nhH : Group.IsNilpotent H\n⊢ LE.le (Group.nilpotencyClass G) (HAdd.hAdd (Group.nilpotencyClass H) 1)","decl":"theorem nilpotencyClass_le_of_ker_le_center {H : Type*} [Group H] (f : G →* H)\n    (hf1 : f.ker ≤ center G) (hH : IsNilpotent H) :\n    Group.nilpotencyClass (hG := isNilpotent_of_ker_le_center f hf1 hH) ≤\n      Group.nilpotencyClass H + 1 := by\n  haveI : IsNilpotent G := isNilpotent_of_ker_le_center f hf1 hH\n  rw [← lowerCentralSeries_length_eq_nilpotencyClass]\n  -- Porting note: Lean needs to be told that predicates are decidable\n  refine @Nat.find_min' _ (Classical.decPred _) _ _ ?_\n  refine lowerCentralSeries_succ_eq_bot (le_trans ((Subgroup.map_eq_bot_iff _).mp ?_) hf1)\n  rw [eq_bot_iff]\n  apply le_trans (lowerCentralSeries.map f _)\n  simp only [lowerCentralSeries_nilpotencyClass, le_bot_iff]\n\n"}
{"name":"nilpotent_of_surjective","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nG' : Type u_2\ninst✝ : Group G'\nh : Group.IsNilpotent G\nf : MonoidHom G G'\nhf : Function.Surjective ⇑f\n⊢ Group.IsNilpotent G'","decl":"/-- The range of a surjective homomorphism from a nilpotent group is nilpotent -/\ntheorem nilpotent_of_surjective {G' : Type*} [Group G'] [h : IsNilpotent G] (f : G →* G')\n    (hf : Function.Surjective f) : IsNilpotent G' := by\n  rcases h with ⟨n, hn⟩\n  use n\n  apply eq_top_iff.mpr\n  calc\n    ⊤ = f.range := symm (f.range_eq_top_of_surjective hf)\n    _ = Subgroup.map f ⊤ := MonoidHom.range_eq_map _\n    _ = Subgroup.map f (upperCentralSeries G n) := by rw [hn]\n    _ ≤ upperCentralSeries G' n := upperCentralSeries.map hf n\n\n"}
{"name":"nilpotencyClass_le_of_surjective","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nG' : Type u_2\ninst✝ : Group G'\nf : MonoidHom G G'\nhf : Function.Surjective ⇑f\nh : Group.IsNilpotent G\n⊢ LE.le (Group.nilpotencyClass G') (Group.nilpotencyClass G)","decl":"/-- The nilpotency class of the range of a surjective homomorphism from a\nnilpotent group is less or equal the nilpotency class of the domain -/\ntheorem nilpotencyClass_le_of_surjective {G' : Type*} [Group G'] (f : G →* G')\n    (hf : Function.Surjective f) [h : IsNilpotent G] :\n    Group.nilpotencyClass (hG := nilpotent_of_surjective _ hf) ≤ Group.nilpotencyClass G := by\n  -- Porting note: Lean needs to be told that predicates are decidable\n  refine @Nat.find_mono _ _ (Classical.decPred _) (Classical.decPred _) ?_ _ _\n  intro n hn\n  rw [eq_top_iff]\n  calc\n    ⊤ = f.range := symm (f.range_eq_top_of_surjective hf)\n    _ = Subgroup.map f ⊤ := MonoidHom.range_eq_map _\n    _ = Subgroup.map f (upperCentralSeries G n) := by rw [hn]\n    _ ≤ upperCentralSeries G' n := upperCentralSeries.map hf n\n\n"}
{"name":"nilpotent_of_mulEquiv","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nG' : Type u_2\ninst✝ : Group G'\n_h : Group.IsNilpotent G\nf : MulEquiv G G'\n⊢ Group.IsNilpotent G'","decl":"/-- Nilpotency respects isomorphisms -/\ntheorem nilpotent_of_mulEquiv {G' : Type*} [Group G'] [_h : IsNilpotent G] (f : G ≃* G') :\n    IsNilpotent G' :=\n  nilpotent_of_surjective f.toMonoidHom (MulEquiv.surjective f)\n\n"}
{"name":"nilpotent_quotient_of_nilpotent","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.Normal\n_h : Group.IsNilpotent G\n⊢ Group.IsNilpotent (HasQuotient.Quotient G H)","decl":"/-- A quotient of a nilpotent group is nilpotent -/\ninstance nilpotent_quotient_of_nilpotent (H : Subgroup G) [H.Normal] [_h : IsNilpotent G] :\n    IsNilpotent (G ⧸ H) :=\n  nilpotent_of_surjective (QuotientGroup.mk' H) QuotientGroup.mk_surjective\n\n"}
{"name":"nilpotencyClass_quotient_le","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.Normal\n_h : Group.IsNilpotent G\n⊢ LE.le (Group.nilpotencyClass (HasQuotient.Quotient G H)) (Group.nilpotencyClass G)","decl":"/-- The nilpotency class of a quotient of `G` is less or equal the nilpotency class of `G` -/\ntheorem nilpotencyClass_quotient_le (H : Subgroup G) [H.Normal] [_h : IsNilpotent G] :\n    Group.nilpotencyClass (G ⧸ H) ≤ Group.nilpotencyClass G :=\n  nilpotencyClass_le_of_surjective (QuotientGroup.mk' H) QuotientGroup.mk_surjective\n\n-- This technical lemma helps with rewriting the subgroup, which occurs in indices\n"}
{"name":"comap_upperCentralSeries_quotient_center","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nn : Nat\n⊢ Eq (Subgroup.comap (QuotientGroup.mk' (Subgroup.center G)) (upperCentralSeries (HasQuotient.Quotient G (Subgroup.center G)) n)) (upperCentralSeries G n.succ)","decl":"theorem comap_upperCentralSeries_quotient_center (n : ℕ) :\n    comap (mk' (center G)) (upperCentralSeries (G ⧸ center G) n) = upperCentralSeries G n.succ := by\n  induction' n with n ih\n  · simp only [upperCentralSeries_zero, MonoidHom.comap_bot, ker_mk',\n      (upperCentralSeries_one G).symm]\n  · let Hn := upperCentralSeries (G ⧸ center G) n\n    calc\n      comap (mk' (center G)) (upperCentralSeriesStep Hn) =\n          comap (mk' (center G)) (comap (mk' Hn) (center ((G ⧸ center G) ⧸ Hn))) := by\n        rw [upperCentralSeriesStep_eq_comap_center]\n      _ = comap (mk' (comap (mk' (center G)) Hn)) (center (G ⧸ comap (mk' (center G)) Hn)) :=\n        QuotientGroup.comap_comap_center\n      _ = comap (mk' (upperCentralSeries G n.succ)) (center (G ⧸ upperCentralSeries G n.succ)) :=\n        (comap_center_subst ih)\n      _ = upperCentralSeriesStep (upperCentralSeries G n.succ) :=\n        symm (upperCentralSeriesStep_eq_comap_center _)\n\n"}
{"name":"nilpotencyClass_zero_iff_subsingleton","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Group.IsNilpotent G\n⊢ Iff (Eq (Group.nilpotencyClass G) 0) (Subsingleton G)","decl":"theorem nilpotencyClass_zero_iff_subsingleton [IsNilpotent G] :\n    Group.nilpotencyClass G = 0 ↔ Subsingleton G := by\n  -- Porting note: Lean needs to be told that predicates are decidable\n  rw [Group.nilpotencyClass, @Nat.find_eq_zero _ (Classical.decPred _), upperCentralSeries_zero,\n    subsingleton_iff_bot_eq_top, Subgroup.subsingleton_iff]\n\n"}
{"name":"nilpotencyClass_quotient_center","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nhH : Group.IsNilpotent G\n⊢ Eq (Group.nilpotencyClass (HasQuotient.Quotient G (Subgroup.center G))) (HSub.hSub (Group.nilpotencyClass G) 1)","decl":"/-- Quotienting the `center G` reduces the nilpotency class by 1 -/\ntheorem nilpotencyClass_quotient_center [hH : IsNilpotent G] :\n    Group.nilpotencyClass (G ⧸ center G) = Group.nilpotencyClass G - 1 := by\n  generalize hn : Group.nilpotencyClass G = n\n  rcases n with (rfl | n)\n  · simp [nilpotencyClass_zero_iff_subsingleton] at *\n    exact Quotient.instSubsingletonQuotient (leftRel (center G))\n  · suffices Group.nilpotencyClass (G ⧸ center G) = n by simpa\n    apply le_antisymm\n    · apply upperCentralSeries_eq_top_iff_nilpotencyClass_le.mp\n      apply comap_injective (f := (mk' (center G))) Quot.mk_surjective\n      rw [comap_upperCentralSeries_quotient_center, comap_top, Nat.succ_eq_add_one, ← hn]\n      exact upperCentralSeries_nilpotencyClass\n    · apply le_of_add_le_add_right\n      calc\n        n + 1 = Group.nilpotencyClass G := hn.symm\n        _ ≤ Group.nilpotencyClass (G ⧸ center G) + 1 :=\n          nilpotencyClass_le_of_ker_le_center _ (le_of_eq (ker_mk' _)) _\n\n"}
{"name":"nilpotencyClass_eq_quotient_center_plus_one","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nhH : Group.IsNilpotent G\ninst✝ : Nontrivial G\n⊢ Eq (Group.nilpotencyClass G) (HAdd.hAdd (Group.nilpotencyClass (HasQuotient.Quotient G (Subgroup.center G))) 1)","decl":"/-- The nilpotency class of a non-trivial group is one more than its quotient by the center -/\ntheorem nilpotencyClass_eq_quotient_center_plus_one [hH : IsNilpotent G] [Nontrivial G] :\n    Group.nilpotencyClass G = Group.nilpotencyClass (G ⧸ center G) + 1 := by\n  rw [nilpotencyClass_quotient_center]\n  rcases h : Group.nilpotencyClass G with ⟨⟩\n  · exfalso\n    rw [nilpotencyClass_zero_iff_subsingleton] at h\n    apply false_of_nontrivial_of_subsingleton G\n  · simp\n\n"}
{"name":"of_quotient_center_nilpotent","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nh : Group.IsNilpotent (HasQuotient.Quotient G (Subgroup.center G))\n⊢ Group.IsNilpotent G","decl":"/-- If the quotient by `center G` is nilpotent, then so is G. -/\ntheorem of_quotient_center_nilpotent (h : IsNilpotent (G ⧸ center G)) : IsNilpotent G := by\n  obtain ⟨n, hn⟩ := h.nilpotent\n  use n.succ\n  simp [← comap_upperCentralSeries_quotient_center, hn]\n\n"}
{"name":"nilpotent_center_quotient_ind","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"P : (G : Type u_2) → [inst : Group G] → [inst : Group.IsNilpotent G] → Prop\nG : Type u_2\ninst✝¹ : Group G\ninst✝ : Group.IsNilpotent G\nhbase : ∀ (G : Type u_2) [inst : Group G] [inst_1 : Subsingleton G], P G\nhstep : ∀ (G : Type u_2) [inst : Group G] [inst_1 : Group.IsNilpotent G], P (HasQuotient.Quotient G (Subgroup.center G)) → P G\n⊢ P G","decl":"/-- A custom induction principle for nilpotent groups. The base case is a trivial group\n(`subsingleton G`), and in the induction step, one can assume the hypothesis for\nthe group quotiented by its center. -/\n@[elab_as_elim]\ntheorem nilpotent_center_quotient_ind {P : ∀ (G) [Group G] [IsNilpotent G], Prop}\n    (G : Type*) [Group G] [IsNilpotent G]\n    (hbase : ∀ (G) [Group G] [Subsingleton G], P G)\n    (hstep : ∀ (G) [Group G] [IsNilpotent G], P (G ⧸ center G) → P G) : P G := by\n  obtain ⟨n, h⟩ : ∃ n, Group.nilpotencyClass G = n := ⟨_, rfl⟩\n  induction' n with n ih generalizing G\n  · haveI := nilpotencyClass_zero_iff_subsingleton.mp h\n    exact hbase _\n  · have hn : Group.nilpotencyClass (G ⧸ center G) = n := by\n      simp [nilpotencyClass_quotient_center, h]\n    exact hstep _ (ih _ hn)\n\n"}
{"name":"derived_le_lower_central","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nn : Nat\n⊢ LE.le (derivedSeries G n) (lowerCentralSeries G n)","decl":"theorem derived_le_lower_central (n : ℕ) : derivedSeries G n ≤ lowerCentralSeries G n := by\n  induction' n with i ih\n  · simp\n  · apply commutator_mono ih\n    simp\n\n"}
{"name":"CommGroup.isNilpotent","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_2\ninst✝ : CommGroup G\n⊢ Group.IsNilpotent G","decl":"/-- Abelian groups are nilpotent -/\ninstance (priority := 100) CommGroup.isNilpotent {G : Type*} [CommGroup G] : IsNilpotent G := by\n  use 1\n  rw [upperCentralSeries_one]\n  apply CommGroup.center_eq_top\n\n"}
{"name":"CommGroup.nilpotencyClass_le_one","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_2\ninst✝ : CommGroup G\n⊢ LE.le (Group.nilpotencyClass G) 1","decl":"/-- Abelian groups have nilpotency class at most one -/\ntheorem CommGroup.nilpotencyClass_le_one {G : Type*} [CommGroup G] :\n    Group.nilpotencyClass G ≤ 1 := by\n  rw [← upperCentralSeries_eq_top_iff_nilpotencyClass_le, upperCentralSeries_one]\n  apply CommGroup.center_eq_top\n\n"}
{"name":"lowerCentralSeries_prod","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G₁ : Type u_2\nG₂ : Type u_3\ninst✝¹ : Group G₁\ninst✝ : Group G₂\nn : Nat\n⊢ Eq (lowerCentralSeries (Prod G₁ G₂) n) ((lowerCentralSeries G₁ n).prod (lowerCentralSeries G₂ n))","decl":"theorem lowerCentralSeries_prod (n : ℕ) :\n    lowerCentralSeries (G₁ × G₂) n = (lowerCentralSeries G₁ n).prod (lowerCentralSeries G₂ n) := by\n  induction' n with n ih\n  · simp\n  · calc\n      lowerCentralSeries (G₁ × G₂) n.succ = ⁅lowerCentralSeries (G₁ × G₂) n, ⊤⁆ := rfl\n      _ = ⁅(lowerCentralSeries G₁ n).prod (lowerCentralSeries G₂ n), ⊤⁆ := by rw [ih]\n      _ = ⁅(lowerCentralSeries G₁ n).prod (lowerCentralSeries G₂ n), (⊤ : Subgroup G₁).prod ⊤⁆ := by\n        simp\n      _ = ⁅lowerCentralSeries G₁ n, (⊤ : Subgroup G₁)⁆.prod ⁅lowerCentralSeries G₂ n, ⊤⁆ :=\n        (commutator_prod_prod _ _ _ _)\n      _ = (lowerCentralSeries G₁ n.succ).prod (lowerCentralSeries G₂ n.succ) := rfl\n\n"}
{"name":"isNilpotent_prod","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G₁ : Type u_2\nG₂ : Type u_3\ninst✝³ : Group G₁\ninst✝² : Group G₂\ninst✝¹ : Group.IsNilpotent G₁\ninst✝ : Group.IsNilpotent G₂\n⊢ Group.IsNilpotent (Prod G₁ G₂)","decl":"/-- Products of nilpotent groups are nilpotent -/\ninstance isNilpotent_prod [IsNilpotent G₁] [IsNilpotent G₂] : IsNilpotent (G₁ × G₂) := by\n  rw [nilpotent_iff_lowerCentralSeries]\n  refine ⟨max (Group.nilpotencyClass G₁) (Group.nilpotencyClass G₂), ?_⟩\n  rw [lowerCentralSeries_prod,\n    lowerCentralSeries_eq_bot_iff_nilpotencyClass_le.mpr (le_max_left _ _),\n    lowerCentralSeries_eq_bot_iff_nilpotencyClass_le.mpr (le_max_right _ _), bot_prod_bot]\n\n"}
{"name":"nilpotencyClass_prod","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G₁ : Type u_2\nG₂ : Type u_3\ninst✝³ : Group G₁\ninst✝² : Group G₂\ninst✝¹ : Group.IsNilpotent G₁\ninst✝ : Group.IsNilpotent G₂\n⊢ Eq (Group.nilpotencyClass (Prod G₁ G₂)) (Max.max (Group.nilpotencyClass G₁) (Group.nilpotencyClass G₂))","decl":"/-- The nilpotency class of a product is the max of the nilpotency classes of the factors -/\ntheorem nilpotencyClass_prod [IsNilpotent G₁] [IsNilpotent G₂] :\n    Group.nilpotencyClass (G₁ × G₂) =\n    max (Group.nilpotencyClass G₁) (Group.nilpotencyClass G₂) := by\n  refine eq_of_forall_ge_iff fun k => ?_\n  simp only [max_le_iff, ← lowerCentralSeries_eq_bot_iff_nilpotencyClass_le,\n    lowerCentralSeries_prod, prod_eq_bot_iff]\n\n"}
{"name":"lowerCentralSeries_pi_le","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"η : Type u_2\nGs : η → Type u_3\ninst✝ : (i : η) → Group (Gs i)\nn : Nat\n⊢ LE.le (lowerCentralSeries ((i : η) → Gs i) n) (Subgroup.pi Set.univ fun i => lowerCentralSeries (Gs i) n)","decl":"theorem lowerCentralSeries_pi_le (n : ℕ) :\n    lowerCentralSeries (∀ i, Gs i) n ≤ Subgroup.pi Set.univ\n      fun i => lowerCentralSeries (Gs i) n := by\n  let pi := fun f : ∀ i, Subgroup (Gs i) => Subgroup.pi Set.univ f\n  induction' n with n ih\n  · simp [pi_top]\n  · calc\n      lowerCentralSeries (∀ i, Gs i) n.succ = ⁅lowerCentralSeries (∀ i, Gs i) n, ⊤⁆ := rfl\n      _ ≤ ⁅pi fun i => lowerCentralSeries (Gs i) n, ⊤⁆ := commutator_mono ih (le_refl _)\n      _ = ⁅pi fun i => lowerCentralSeries (Gs i) n, pi fun i => ⊤⁆ := by simp [pi, pi_top]\n      _ ≤ pi fun i => ⁅lowerCentralSeries (Gs i) n, ⊤⁆ := commutator_pi_pi_le _ _\n      _ = pi fun i => lowerCentralSeries (Gs i) n.succ := rfl\n\n"}
{"name":"isNilpotent_pi_of_bounded_class","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"η : Type u_2\nGs : η → Type u_3\ninst✝¹ : (i : η) → Group (Gs i)\ninst✝ : ∀ (i : η), Group.IsNilpotent (Gs i)\nn : Nat\nh : ∀ (i : η), LE.le (Group.nilpotencyClass (Gs i)) n\n⊢ Group.IsNilpotent ((i : η) → Gs i)","decl":"/-- products of nilpotent groups are nilpotent if their nilpotency class is bounded -/\ntheorem isNilpotent_pi_of_bounded_class [∀ i, IsNilpotent (Gs i)] (n : ℕ)\n    (h : ∀ i, Group.nilpotencyClass (Gs i) ≤ n) : IsNilpotent (∀ i, Gs i) := by\n  rw [nilpotent_iff_lowerCentralSeries]\n  refine ⟨n, ?_⟩\n  rw [eq_bot_iff]\n  apply le_trans (lowerCentralSeries_pi_le _)\n  rw [← eq_bot_iff, pi_eq_bot_iff]\n  intro i\n  apply lowerCentralSeries_eq_bot_iff_nilpotencyClass_le.mpr (h i)\n\n"}
{"name":"lowerCentralSeries_pi_of_finite","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"η : Type u_2\nGs : η → Type u_3\ninst✝¹ : (i : η) → Group (Gs i)\ninst✝ : Finite η\nn : Nat\n⊢ Eq (lowerCentralSeries ((i : η) → Gs i) n) (Subgroup.pi Set.univ fun i => lowerCentralSeries (Gs i) n)","decl":"theorem lowerCentralSeries_pi_of_finite [Finite η] (n : ℕ) :\n    lowerCentralSeries (∀ i, Gs i) n = Subgroup.pi Set.univ\n      fun i => lowerCentralSeries (Gs i) n := by\n  let pi := fun f : ∀ i, Subgroup (Gs i) => Subgroup.pi Set.univ f\n  induction' n with n ih\n  · simp [pi_top]\n  · calc\n      lowerCentralSeries (∀ i, Gs i) n.succ = ⁅lowerCentralSeries (∀ i, Gs i) n, ⊤⁆ := rfl\n      _ = ⁅pi fun i => lowerCentralSeries (Gs i) n, ⊤⁆ := by rw [ih]\n      _ = ⁅pi fun i => lowerCentralSeries (Gs i) n, pi fun i => ⊤⁆ := by simp [pi, pi_top]\n      _ = pi fun i => ⁅lowerCentralSeries (Gs i) n, ⊤⁆ := commutator_pi_pi_of_finite _ _\n      _ = pi fun i => lowerCentralSeries (Gs i) n.succ := rfl\n\n"}
{"name":"isNilpotent_pi","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"η : Type u_2\nGs : η → Type u_3\ninst✝² : (i : η) → Group (Gs i)\ninst✝¹ : Finite η\ninst✝ : ∀ (i : η), Group.IsNilpotent (Gs i)\n⊢ Group.IsNilpotent ((i : η) → Gs i)","decl":"/-- n-ary products of nilpotent groups are nilpotent -/\ninstance isNilpotent_pi [Finite η] [∀ i, IsNilpotent (Gs i)] : IsNilpotent (∀ i, Gs i) := by\n  cases nonempty_fintype η\n  rw [nilpotent_iff_lowerCentralSeries]\n  refine ⟨Finset.univ.sup fun i => Group.nilpotencyClass (Gs i), ?_⟩\n  rw [lowerCentralSeries_pi_of_finite, pi_eq_bot_iff]\n  intro i\n  rw [lowerCentralSeries_eq_bot_iff_nilpotencyClass_le]\n  exact Finset.le_sup (f := fun i => Group.nilpotencyClass (Gs i)) (Finset.mem_univ i)\n\n"}
{"name":"nilpotencyClass_pi","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"η : Type u_2\nGs : η → Type u_3\ninst✝² : (i : η) → Group (Gs i)\ninst✝¹ : Fintype η\ninst✝ : ∀ (i : η), Group.IsNilpotent (Gs i)\n⊢ Eq (Group.nilpotencyClass ((i : η) → Gs i)) (Finset.univ.sup fun i => Group.nilpotencyClass (Gs i))","decl":"/-- The nilpotency class of an n-ary product is the sup of the nilpotency classes of the factors -/\ntheorem nilpotencyClass_pi [Fintype η] [∀ i, IsNilpotent (Gs i)] :\n    Group.nilpotencyClass (∀ i, Gs i) = Finset.univ.sup fun i => Group.nilpotencyClass (Gs i) := by\n  apply eq_of_forall_ge_iff\n  intro k\n  simp only [Finset.sup_le_iff, ← lowerCentralSeries_eq_bot_iff_nilpotencyClass_le,\n    lowerCentralSeries_pi_of_finite, pi_eq_bot_iff, Finset.mem_univ, true_imp_iff]\n\n"}
{"name":"IsNilpotent.to_isSolvable","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nh : Group.IsNilpotent G\n⊢ IsSolvable G","decl":"/-- A nilpotent subgroup is solvable -/\ninstance (priority := 100) IsNilpotent.to_isSolvable [h : IsNilpotent G] : IsSolvable G := by\n  obtain ⟨n, hn⟩ := nilpotent_iff_lowerCentralSeries.1 h\n  use n\n  rw [eq_bot_iff, ← hn]\n  exact derived_le_lower_central n\n\n"}
{"name":"normalizerCondition_of_isNilpotent","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\ninst✝ : Group G\nh : Group.IsNilpotent G\n⊢ NormalizerCondition G","decl":"theorem normalizerCondition_of_isNilpotent [h : IsNilpotent G] : NormalizerCondition G := by\n  -- roughly based on https://groupprops.subwiki.org/wiki/Nilpotent_implies_normalizer_condition\n  rw [normalizerCondition_iff_only_full_group_self_normalizing]\n  apply @nilpotent_center_quotient_ind _ G _ _ <;> clear! G\n  · intro G _ _ H _\n    exact @Subsingleton.elim _ Unique.instSubsingleton _ _\n  · intro G _ _ ih H hH\n    have hch : center G ≤ H := Subgroup.center_le_normalizer.trans (le_of_eq hH)\n    have hkh : (mk' (center G)).ker ≤ H := by simpa using hch\n    have hsur : Function.Surjective (mk' (center G)) := Quot.mk_surjective\n    let H' := H.map (mk' (center G))\n    have hH' : H'.normalizer = H' := by\n      apply comap_injective hsur\n      rw [comap_normalizer_eq_of_surjective _ hsur, comap_map_eq_self hkh]\n      exact hH\n    apply map_injective_of_ker_le (mk' (center G)) hkh le_top\n    exact (ih H' hH').trans (symm (map_top_of_surjective _ hsur))\n\n"}
{"name":"IsPGroup.isNilpotent","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\nhG : Group G\ninst✝ : Finite G\np : Nat\nhp : Fact (Nat.Prime p)\nh : IsPGroup p G\n⊢ Group.IsNilpotent G","decl":"/-- A p-group is nilpotent -/\ntheorem IsPGroup.isNilpotent [Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)] (h : IsPGroup p G) :\n    IsNilpotent G := by\n  cases' nonempty_fintype G\n  classical\n    revert hG\n    apply @Fintype.induction_subsingleton_or_nontrivial _ G _\n    · intro _ _ _ _\n      infer_instance\n    · intro G _ _ ih _ h\n      have hcq : Fintype.card (G ⧸ center G) < Fintype.card G := by\n        simp only [← Nat.card_eq_fintype_card]\n        rw [card_eq_card_quotient_mul_card_subgroup (center G)]\n        simp only [Nat.card_eq_fintype_card]\n        apply lt_mul_of_one_lt_right\n        · exact Fintype.card_pos_iff.mpr One.instNonempty\n        · simp only [← Nat.card_eq_fintype_card]\n          exact (Subgroup.one_lt_card_iff_ne_bot _).mpr (ne_of_gt h.bot_lt_center)\n      have hnq : IsNilpotent (G ⧸ center G) := ih _ hcq (h.to_quotient (center G))\n      exact of_quotient_center_nilpotent hnq\n\n"}
{"name":"isNilpotent_of_product_of_sylow_group","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\nhG : Group G\ninst✝ : Finite G\ne : MulEquiv ((p : Subtype fun x => Membership.mem (Nat.card G).primeFactors x) → (P : Sylow (↑p) G) → Subtype fun x => Membership.mem (↑P) x) G\n⊢ Group.IsNilpotent G","decl":"/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem isNilpotent_of_product_of_sylow_group\n    (e : (∀ p : (Nat.card G).primeFactors, ∀ P : Sylow p G, (↑P : Subgroup G)) ≃* G) :\n    IsNilpotent G := by\n  classical\n    let ps := (Nat.card G).primeFactors\n    have : ∀ (p : ps) (P : Sylow p G), IsNilpotent (↑P : Subgroup G) := by\n      intro p P\n      haveI : Fact (Nat.Prime ↑p) := Fact.mk <| Nat.prime_of_mem_primeFactors p.2\n      exact P.isPGroup'.isNilpotent\n    exact nilpotent_of_mulEquiv e\n\n"}
{"name":"isNilpotent_of_finite_tfae","module":"Mathlib.GroupTheory.Nilpotent","initialProofState":"G : Type u_1\nhG : Group G\ninst✝ : Finite G\n⊢ (List.cons (Group.IsNilpotent G) (List.cons (NormalizerCondition G) (List.cons (∀ (H : Subgroup G), IsCoatom H → H.Normal) (List.cons (∀ (p : Nat), Fact (Nat.Prime p) → ∀ (P : Sylow p G), (↑P).Normal) (List.cons (Nonempty (MulEquiv ((p : Subtype fun x => Membership.mem (Nat.card G).primeFactors x) → (P : Sylow (↑p) G) → Subtype fun x => Membership.mem (↑P) x) G)) List.nil))))).TFAE","decl":"/-- A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\nnormal and iff all Sylow groups are normal and iff the group is the direct product of its Sylow\ngroups. -/\ntheorem isNilpotent_of_finite_tfae :\n    List.TFAE\n      [IsNilpotent G, NormalizerCondition G, ∀ H : Subgroup G, IsCoatom H → H.Normal,\n        ∀ (p : ℕ) (_hp : Fact p.Prime) (P : Sylow p G), (↑P : Subgroup G).Normal,\n        Nonempty\n          ((∀ p : (Nat.card G).primeFactors, ∀ P : Sylow p G, (↑P : Subgroup G)) ≃* G)] := by\n  tfae_have 1 → 2 := @normalizerCondition_of_isNilpotent _ _\n  tfae_have 2 → 3\n  | h, H => NormalizerCondition.normal_of_coatom H h\n  tfae_have 3 → 4\n  | h, p, _, P => Sylow.normal_of_all_max_subgroups_normal h _\n  tfae_have 4 → 5\n  | h => Nonempty.intro (Sylow.directProductOfNormal fun {p hp hP} => h p hp hP)\n  tfae_have 5 → 1\n  | ⟨e⟩ => isNilpotent_of_product_of_sylow_group e\n  tfae_finish\n\n"}
