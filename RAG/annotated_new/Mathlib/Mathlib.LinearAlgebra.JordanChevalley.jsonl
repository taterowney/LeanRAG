{"name":"Module.End.exists_isNilpotent_isSemisimple_of_separable_of_dvd_pow","module":"Mathlib.LinearAlgebra.JordanChevalley","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : Module.End K V\nP : Polynomial K\nk : Nat\nsep : P.Separable\nnil : Dvd.dvd (minpoly K f) (HPow.hPow P k)\n⊢ Exists fun n => And (Membership.mem (Algebra.adjoin K (Singleton.singleton f)) n) (Exists fun s => And (Membership.mem (Algebra.adjoin K (Singleton.singleton f)) s) (And (IsNilpotent n) (And s.IsSemisimple (Eq f (HAdd.hAdd n s)))))","decl":"theorem exists_isNilpotent_isSemisimple_of_separable_of_dvd_pow {P : K[X]} {k : ℕ}\n    (sep : P.Separable) (nil : minpoly K f ∣ P ^ k) :\n    ∃ᵉ (n ∈ adjoin K {f}) (s ∈ adjoin K {f}), IsNilpotent n ∧ IsSemisimple s ∧ f = n + s := by\n  set ff : adjoin K {f} := ⟨f, self_mem_adjoin_singleton K f⟩\n  set P' := derivative P\n  have nil' : IsNilpotent (aeval ff P) := by\n    use k\n    obtain ⟨q, hq⟩ := nil\n    rw [← map_pow, Subtype.ext_iff]\n    simp [ff, hq]\n  have sep' : IsUnit (aeval ff P') := by\n    obtain ⟨a, b, h⟩ : IsCoprime (P ^ k) P' := sep.pow_left\n    replace h : (aeval f b) * (aeval f P') = 1 := by\n      simpa only [map_add, map_mul, map_one, minpoly.dvd_iff.mp nil, mul_zero, zero_add]\n        using (aeval f).congr_arg h\n    refine isUnit_of_mul_eq_one_right (aeval ff b) _ (Subtype.ext_iff.mpr ?_)\n    simpa [ff, coe_aeval_mk_apply] using h\n  obtain ⟨⟨s, mem⟩, ⟨⟨k, hk⟩, hss⟩, -⟩ := existsUnique_nilpotent_sub_and_aeval_eq_zero nil' sep'\n  refine ⟨f - s, ?_, s, mem, ⟨k, ?_⟩, ?_, (sub_add_cancel f s).symm⟩\n  · exact sub_mem (self_mem_adjoin_singleton K f) mem\n  · rw [Subtype.ext_iff] at hk\n    simpa using hk\n  · replace hss : aeval s P = 0 := by rwa [Subtype.ext_iff, coe_aeval_mk_apply] at hss\n    exact isSemisimple_of_squarefree_aeval_eq_zero sep.squarefree hss\n\n"}
{"name":"Module.End.exists_isNilpotent_isSemisimple","module":"Mathlib.LinearAlgebra.JordanChevalley","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝⁴ : Field K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\nf : Module.End K V\ninst✝¹ : FiniteDimensional K V\ninst✝ : PerfectField K\n⊢ Exists fun n => And (Membership.mem (Algebra.adjoin K (Singleton.singleton f)) n) (Exists fun s => And (Membership.mem (Algebra.adjoin K (Singleton.singleton f)) s) (And (IsNilpotent n) (And s.IsSemisimple (Eq f (HAdd.hAdd n s)))))","decl":"/-- **Jordan-Chevalley-Dunford decomposition**: an endomorphism of a finite-dimensional vector space\nover a perfect field may be written as a sum of nilpotent and semisimple endomorphisms. Moreover\nthese nilpotent and semisimple components are polynomial expressions in the original endomorphism.\n-/\ntheorem exists_isNilpotent_isSemisimple [PerfectField K] :\n    ∃ᵉ (n ∈ adjoin K {f}) (s ∈ adjoin K {f}), IsNilpotent n ∧ IsSemisimple s ∧ f = n + s := by\n  obtain ⟨g, k, sep, -, nil⟩ := exists_squarefree_dvd_pow_of_ne_zero (minpoly.ne_zero_of_finite K f)\n  rw [← PerfectField.separable_iff_squarefree] at sep\n  exact exists_isNilpotent_isSemisimple_of_separable_of_dvd_pow sep nil\n\n"}
