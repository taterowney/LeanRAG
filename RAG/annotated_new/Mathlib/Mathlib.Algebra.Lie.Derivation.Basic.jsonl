{"name":"LieDerivation.mk.injEq","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\ntoLinearMap✝ : LinearMap (RingHom.id R) L M\nleibniz'✝ : ∀ (a b : L), Eq (toLinearMap✝ (Bracket.bracket a b)) (HSub.hSub (Bracket.bracket a (toLinearMap✝ b)) (Bracket.bracket b (toLinearMap✝ a)))\ntoLinearMap : LinearMap (RingHom.id R) L M\nleibniz' : ∀ (a b : L), Eq (toLinearMap (Bracket.bracket a b)) (HSub.hSub (Bracket.bracket a (toLinearMap b)) (Bracket.bracket b (toLinearMap a)))\n⊢ Eq (Eq { toLinearMap := toLinearMap✝, leibniz' := leibniz'✝ } { toLinearMap := toLinearMap, leibniz' := leibniz' }) (Eq toLinearMap✝ toLinearMap)","decl":"/-- A Lie derivation `D` from the Lie `R`-algebra `L` to the `L`-module `M` is an `R`-linear map\nthat satisfies the Leibniz rule `D [a, b] = [a, D b] - [b, D a]`. -/\nstructure LieDerivation (R L M : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]\n    [AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]\n    extends L →ₗ[R] M where\n  protected leibniz' (a b : L) : toLinearMap ⁅a, b⁆ = ⁅a, toLinearMap b⁆ - ⁅b, toLinearMap a⁆\n\n"}
{"name":"LieDerivation.mk.sizeOf_spec","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : LieAlgebra R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : LieRingModule L M\ninst✝³ : LieModule R L M\ninst✝² : SizeOf R\ninst✝¹ : SizeOf L\ninst✝ : SizeOf M\ntoLinearMap : LinearMap (RingHom.id R) L M\nleibniz' : ∀ (a b : L), Eq (toLinearMap (Bracket.bracket a b)) (HSub.hSub (Bracket.bracket a (toLinearMap b)) (Bracket.bracket b (toLinearMap a)))\n⊢ Eq (SizeOf.sizeOf { toLinearMap := toLinearMap, leibniz' := leibniz' }) (HAdd.hAdd 1 (SizeOf.sizeOf toLinearMap))","decl":"/-- A Lie derivation `D` from the Lie `R`-algebra `L` to the `L`-module `M` is an `R`-linear map\nthat satisfies the Leibniz rule `D [a, b] = [a, D b] - [b, D a]`. -/\nstructure LieDerivation (R L M : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]\n    [AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]\n    extends L →ₗ[R] M where\n  protected leibniz' (a b : L) : toLinearMap ⁅a, b⁆ = ⁅a, toLinearMap b⁆ - ⁅b, toLinearMap a⁆\n\n"}
{"name":"LieDerivation.leibniz'","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nself : LieDerivation R L M\na b : L\n⊢ Eq (self.toLinearMap (Bracket.bracket a b)) (HSub.hSub (Bracket.bracket a (self.toLinearMap b)) (Bracket.bracket b (self.toLinearMap a)))","decl":"/-- A Lie derivation `D` from the Lie `R`-algebra `L` to the `L`-module `M` is an `R`-linear map\nthat satisfies the Leibniz rule `D [a, b] = [a, D b] - [b, D a]`. -/\nstructure LieDerivation (R L M : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]\n    [AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]\n    extends L →ₗ[R] M where\n  protected leibniz' (a b : L) : toLinearMap ⁅a, b⁆ = ⁅a, toLinearMap b⁆ - ⁅b, toLinearMap a⁆\n\n"}
{"name":"LieDerivation.mk.inj","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\ntoLinearMap✝ : LinearMap (RingHom.id R) L M\nleibniz'✝ : ∀ (a b : L), Eq (toLinearMap✝ (Bracket.bracket a b)) (HSub.hSub (Bracket.bracket a (toLinearMap✝ b)) (Bracket.bracket b (toLinearMap✝ a)))\ntoLinearMap : LinearMap (RingHom.id R) L M\nleibniz' : ∀ (a b : L), Eq (toLinearMap (Bracket.bracket a b)) (HSub.hSub (Bracket.bracket a (toLinearMap b)) (Bracket.bracket b (toLinearMap a)))\nx✝ : Eq { toLinearMap := toLinearMap✝, leibniz' := leibniz'✝ } { toLinearMap := toLinearMap, leibniz' := leibniz' }\n⊢ Eq toLinearMap✝ toLinearMap","decl":"/-- A Lie derivation `D` from the Lie `R`-algebra `L` to the `L`-module `M` is an `R`-linear map\nthat satisfies the Leibniz rule `D [a, b] = [a, D b] - [b, D a]`. -/\nstructure LieDerivation (R L M : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]\n    [AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]\n    extends L →ₗ[R] M where\n  protected leibniz' (a b : L) : toLinearMap ⁅a, b⁆ = ⁅a, toLinearMap b⁆ - ⁅b, toLinearMap a⁆\n\n"}
{"name":"LieDerivation.instLinearMapClass","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ LinearMapClass (LieDerivation R L M) R L M","decl":"instance instLinearMapClass : LinearMapClass (LieDerivation R L M) R L M where\n  map_add D := D.toLinearMap.map_add'\n  map_smulₛₗ D := D.toLinearMap.map_smul\n\n"}
{"name":"LieDerivation.toFun_eq_coe","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD : LieDerivation R L M\n⊢ Eq D.toFun ⇑D","decl":"theorem toFun_eq_coe : D.toFun = ⇑D := rfl\n\n"}
{"name":"LieDerivation.mk_coe","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nf : LinearMap (RingHom.id R) L M\nh₁ : ∀ (a b : L), Eq (f (Bracket.bracket a b)) (HSub.hSub (Bracket.bracket a (f b)) (Bracket.bracket b (f a)))\n⊢ Eq ⇑{ toLinearMap := f, leibniz' := h₁ } ⇑f","decl":"@[simp]\ntheorem mk_coe (f : L →ₗ[R] M) (h₁) : ((⟨f, h₁⟩ : LieDerivation R L M) : L → M) = f :=\n  rfl\n\n"}
{"name":"LieDerivation.coeFn_coe","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nf : LieDerivation R L M\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\ntheorem coeFn_coe (f : LieDerivation R L M) : ⇑(f : L →ₗ[R] M) = f :=\n  rfl\n\n"}
{"name":"LieDerivation.coe_injective","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : @Function.Injective (LieDerivation R L M) (L → M) DFunLike.coe :=\n  DFunLike.coe_injective\n\n"}
{"name":"LieDerivation.ext_iff","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD1 D2 : LieDerivation R L M\n⊢ Iff (Eq D1 D2) (∀ (a : L), Eq (D1 a) (D2 a))","decl":"@[ext]\ntheorem ext (H : ∀ a, D1 a = D2 a) : D1 = D2 :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"LieDerivation.ext","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD1 D2 : LieDerivation R L M\nH : ∀ (a : L), Eq (D1 a) (D2 a)\n⊢ Eq D1 D2","decl":"@[ext]\ntheorem ext (H : ∀ a, D1 a = D2 a) : D1 = D2 :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"LieDerivation.congr_fun","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD1 D2 : LieDerivation R L M\nh : Eq D1 D2\na : L\n⊢ Eq (D1 a) (D2 a)","decl":"theorem congr_fun (h : D1 = D2) (a : L) : D1 a = D2 a :=\n  DFunLike.congr_fun h a\n\n"}
{"name":"LieDerivation.apply_lie_eq_sub","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD : LieDerivation R L M\na b : L\n⊢ Eq (D (Bracket.bracket a b)) (HSub.hSub (Bracket.bracket a (D b)) (Bracket.bracket b (D a)))","decl":"@[simp]\nlemma apply_lie_eq_sub (D : LieDerivation R L M) (a b : L) :\n    D ⁅a, b⁆ = ⁅a, D b⁆ - ⁅b, D a⁆ :=\n  D.leibniz' a b\n\n"}
{"name":"LieDerivation.apply_lie_eq_add","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nD : LieDerivation R L L\na b : L\n⊢ Eq (D (Bracket.bracket a b)) (HAdd.hAdd (Bracket.bracket a (D b)) (Bracket.bracket (D a) b))","decl":"/-- For a Lie derivation from a Lie algebra to itself, the usual Leibniz rule holds. -/\nlemma apply_lie_eq_add (D : LieDerivation R L L) (a b : L) :\n    D ⁅a, b⁆ = ⁅a, D b⁆ + ⁅D a, b⁆ := by\n  rw [LieDerivation.apply_lie_eq_sub, sub_eq_add_neg, lie_skew]\n\n"}
{"name":"LieDerivation.eqOn_lieSpan","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD1 D2 : LieDerivation R L M\ns : Set L\nh : Set.EqOn (⇑D1) (⇑D2) s\n⊢ Set.EqOn ⇑D1 ⇑D2 ↑(LieSubalgebra.lieSpan R L s)","decl":"/-- Two Lie derivations equal on a set are equal on its Lie span. -/\ntheorem eqOn_lieSpan {s : Set L} (h : Set.EqOn D1 D2 s) :\n    Set.EqOn D1 D2 (LieSubalgebra.lieSpan R L s) :=\n    fun _ hz =>\n      have zero : D1 0 = D2 0 := by simp only [map_zero]\n      have smul : ∀ (r : R), ∀ {x : L}, D1 x = D2 x → D1 (r • x) = D2 (r • x) :=\n        fun _ _ hx => by simp only [map_smul, hx]\n      have add : ∀ x y, D1 x = D2 x → D1 y = D2 y → D1 (x + y) = D2 (x + y) :=\n        fun _ _ hx hy => by simp only [map_add, hx, hy]\n      have lie : ∀ x y, D1 x = D2 x → D1 y = D2 y → D1 ⁅x, y⁆ = D2 ⁅x, y⁆ :=\n        fun _ _ hx hy => by simp only [apply_lie_eq_sub, hx, hy]\n      LieSubalgebra.lieSpan_induction R (p := fun x => D1 x = D2 x) hz h zero smul add lie\n\n"}
{"name":"LieDerivation.ext_of_lieSpan_eq_top","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD1 D2 : LieDerivation R L M\ns : Set L\nhs : Eq (LieSubalgebra.lieSpan R L s) Top.top\nh : Set.EqOn (⇑D1) (⇑D2) s\n⊢ Eq D1 D2","decl":"/-- If the Lie span of a set is the whole Lie algebra, then two Lie derivations equal on this set\nare equal on the whole Lie algebra. -/\ntheorem ext_of_lieSpan_eq_top (s : Set L) (hs : LieSubalgebra.lieSpan R L s = ⊤)\n    (h : Set.EqOn D1 D2 s) : D1 = D2 :=\n  ext fun _ => eqOn_lieSpan h <| hs.symm ▸ trivial\n\n"}
{"name":"LieDerivation.iterate_apply_lie","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nD : LieDerivation R L L\nn : Nat\na b : L\n⊢ Eq (Nat.iterate (⇑D) n (Bracket.bracket a b)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun ij => HSMul.hSMul (n.choose ij.1) (Bracket.bracket (Nat.iterate (⇑D) ij.1 a) (Nat.iterate (⇑D) ij.2 b)))","decl":"/-- The general Leibniz rule for Lie derivatives. -/\ntheorem iterate_apply_lie (D : LieDerivation R L L) (n : ℕ) (a b : L) :\n    D^[n] ⁅a, b⁆ = ∑ ij ∈ antidiagonal n, choose n ij.1 • ⁅D^[ij.1] a, D^[ij.2] b⁆ := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rw [sum_antidiagonal_choose_succ_nsmul (M := L) (fun i j => ⁅D^[i] a, D^[j] b⁆) n]\n    simp only [Function.iterate_succ_apply', ih, map_sum, map_nsmul, apply_lie_eq_add, smul_add,\n      sum_add_distrib, add_right_inj]\n    refine sum_congr rfl fun ⟨i, j⟩ hij ↦ ?_\n    rw [n.choose_symm_of_eq_add (mem_antidiagonal.1 hij).symm]\n\n"}
{"name":"LieDerivation.iterate_apply_lie'","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nD : LieDerivation R L L\nn : Nat\na b : L\n⊢ Eq (Nat.iterate (⇑D) n (Bracket.bracket a b)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HSMul.hSMul (n.choose i) (Bracket.bracket (Nat.iterate (⇑D) i a) (Nat.iterate (⇑D) (HSub.hSub n i) b)))","decl":"/-- Alternate version of the general Leibniz rule for Lie derivatives. -/\ntheorem iterate_apply_lie' (D : LieDerivation R L L) (n : ℕ) (a b : L) :\n    D^[n] ⁅a, b⁆ = ∑ i ∈ range (n + 1), n.choose i • ⁅D^[i] a, D^[n - i] b⁆ := by\n  rw [iterate_apply_lie D n a b]\n  exact sum_antidiagonal_eq_sum_range_succ (fun i j ↦ n.choose i • ⁅D^[i] a, D^[j] b⁆) n\n\n"}
{"name":"LieDerivation.coe_zero","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Eq (⇑0) 0","decl":"@[simp]\ntheorem coe_zero : ⇑(0 : LieDerivation R L M) = 0 :=\n  rfl\n\n"}
{"name":"LieDerivation.coe_zero_linearMap","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Eq (↑0) 0","decl":"@[simp]\ntheorem coe_zero_linearMap : ↑(0 : LieDerivation R L M) = (0 : L →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"LieDerivation.zero_apply","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\na : L\n⊢ Eq (0 a) 0","decl":"theorem zero_apply (a : L) : (0 : LieDerivation R L M) a = 0 :=\n  rfl\n\n"}
{"name":"LieDerivation.coe_add","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD1 D2 : LieDerivation R L M\n⊢ Eq (⇑(HAdd.hAdd D1 D2)) (HAdd.hAdd ⇑D1 ⇑D2)","decl":"@[simp]\ntheorem coe_add (D1 D2 : LieDerivation R L M) : ⇑(D1 + D2) = D1 + D2 :=\n  rfl\n\n"}
{"name":"LieDerivation.coe_add_linearMap","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD1 D2 : LieDerivation R L M\n⊢ Eq (↑(HAdd.hAdd D1 D2)) (HAdd.hAdd ↑D1 ↑D2)","decl":"@[simp]\ntheorem coe_add_linearMap (D1 D2 : LieDerivation R L M) : ↑(D1 + D2) = (D1 + D2 : L →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"LieDerivation.add_apply","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD1 D2 : LieDerivation R L M\na : L\n⊢ Eq ((HAdd.hAdd D1 D2) a) (HAdd.hAdd (D1 a) (D2 a))","decl":"theorem add_apply : (D1 + D2) a = D1 a + D2 a :=\n  rfl\n\n"}
{"name":"LieDerivation.map_neg","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD : LieDerivation R L M\na : L\n⊢ Eq (D (Neg.neg a)) (Neg.neg (D a))","decl":"protected theorem map_neg : D (-a) = -D a :=\n  map_neg D a\n\n"}
{"name":"LieDerivation.map_sub","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD : LieDerivation R L M\na b : L\n⊢ Eq (D (HSub.hSub a b)) (HSub.hSub (D a) (D b))","decl":"protected theorem map_sub : D (a - b) = D a - D b :=\n  map_sub D a b\n\n"}
{"name":"LieDerivation.coe_neg","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD : LieDerivation R L M\n⊢ Eq (⇑(Neg.neg D)) (Neg.neg ⇑D)","decl":"@[simp]\ntheorem coe_neg (D : LieDerivation R L M) : ⇑(-D) = -D :=\n  rfl\n\n"}
{"name":"LieDerivation.coe_neg_linearMap","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD : LieDerivation R L M\n⊢ Eq (↑(Neg.neg D)) (Neg.neg ↑D)","decl":"@[simp]\ntheorem coe_neg_linearMap (D : LieDerivation R L M) : ↑(-D) = (-D : L →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"LieDerivation.neg_apply","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD : LieDerivation R L M\na : L\n⊢ Eq ((Neg.neg D) a) (Neg.neg (D a))","decl":"theorem neg_apply : (-D) a = -D a :=\n  rfl\n\n"}
{"name":"LieDerivation.coe_sub","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD1 D2 : LieDerivation R L M\n⊢ Eq (⇑(HSub.hSub D1 D2)) (HSub.hSub ⇑D1 ⇑D2)","decl":"@[simp]\ntheorem coe_sub (D1 D2 : LieDerivation R L M) : ⇑(D1 - D2) = D1 - D2 :=\n  rfl\n\n"}
{"name":"LieDerivation.coe_sub_linearMap","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nD1 D2 : LieDerivation R L M\n⊢ Eq (↑(HSub.hSub D1 D2)) (HSub.hSub ↑D1 ↑D2)","decl":"@[simp]\ntheorem coe_sub_linearMap (D1 D2 : LieDerivation R L M) : ↑(D1 - D2) = (D1 - D2 : L →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"LieDerivation.sub_apply","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\na : L\nD1 D2 : LieDerivation R L M\n⊢ Eq ((HSub.hSub D1 D2) a) (HSub.hSub (D1 a) (D2 a))","decl":"theorem sub_apply {D1 D2 : LieDerivation R L M} : (D1 - D2) a = D1 a - D2 a :=\n  rfl\n\n"}
{"name":"LieDerivation.SMulBracketCommClass.smul_bracket_comm","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"S : Type u_4\nL : Type u_5\nα : Type u_6\ninst✝³ : SMul S α\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup α\ninst✝ : LieRingModule L α\nself : LieDerivation.SMulBracketCommClass S L α\ns : S\nl : L\na : α\n⊢ Eq (HSMul.hSMul s (Bracket.bracket l a)) (Bracket.bracket l (HSMul.hSMul s a))","decl":"/-- A typeclass mixin saying that scalar multiplication and Lie bracket are left commutative. -/\nclass SMulBracketCommClass (S L α : Type*) [SMul S α] [LieRing L] [AddCommGroup α]\n    [LieRingModule L α] : Prop where\n  /-- `•` and `⁅⬝, ⬝⁆`  are left commutative -/\n  smul_bracket_comm : ∀ (s : S) (l : L) (a : α), s • ⁅l, a⁆ = ⁅l, s • a⁆\n\n"}
{"name":"LieDerivation.coe_smul","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\nS : Type u_4\ninst✝³ : Monoid S\ninst✝² : DistribMulAction S M\ninst✝¹ : SMulCommClass R S M\ninst✝ : LieDerivation.SMulBracketCommClass S L M\nr : S\nD : LieDerivation R L M\n⊢ Eq (⇑(HSMul.hSMul r D)) (HSMul.hSMul r ⇑D)","decl":"@[simp]\ntheorem coe_smul (r : S) (D : LieDerivation R L M) : ⇑(r • D) = r • ⇑D :=\n  rfl\n\n"}
{"name":"LieDerivation.coe_smul_linearMap","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\nS : Type u_4\ninst✝³ : Monoid S\ninst✝² : DistribMulAction S M\ninst✝¹ : SMulCommClass R S M\ninst✝ : LieDerivation.SMulBracketCommClass S L M\nr : S\nD : LieDerivation R L M\n⊢ Eq (↑(HSMul.hSMul r D)) (HSMul.hSMul r ↑D)","decl":"@[simp]\ntheorem coe_smul_linearMap (r : S) (D : LieDerivation R L M) : ↑(r • D) = r • (D : L →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"LieDerivation.smul_apply","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\na : L\nS : Type u_4\ninst✝³ : Monoid S\ninst✝² : DistribMulAction S M\ninst✝¹ : SMulCommClass R S M\ninst✝ : LieDerivation.SMulBracketCommClass S L M\nr : S\nD : LieDerivation R L M\n⊢ Eq ((HSMul.hSMul r D) a) (HSMul.hSMul r (D a))","decl":"theorem smul_apply (r : S) (D : LieDerivation R L M) : (r • D) a = r • D a :=\n  rfl\n\n"}
{"name":"LieDerivation.instSMulBase","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ LieDerivation.SMulBracketCommClass R L M","decl":"instance instSMulBase : SMulBracketCommClass R L M := ⟨fun s l a ↦ (lie_smul s l a).symm⟩\n\n"}
{"name":"LieDerivation.instSMulNat","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"L : Type u_2\nM : Type u_3\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\n⊢ LieDerivation.SMulBracketCommClass Nat L M","decl":"instance instSMulNat : SMulBracketCommClass ℕ L M := ⟨fun s l a => (lie_nsmul l a s).symm⟩\n\n"}
{"name":"LieDerivation.instSMulInt","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"L : Type u_2\nM : Type u_3\ninst✝² : LieRing L\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\n⊢ LieDerivation.SMulBracketCommClass Int L M","decl":"instance instSMulInt : SMulBracketCommClass ℤ L M := ⟨fun s l a => (lie_zsmul l a s).symm⟩\n\n"}
{"name":"LieDerivation.instIsScalarTower","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝¹⁴ : CommRing R\ninst✝¹³ : LieRing L\ninst✝¹² : LieAlgebra R L\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : LieRingModule L M\ninst✝⁸ : LieModule R L M\nS : Type u_4\nT : Type u_5\ninst✝⁷ : Monoid S\ninst✝⁶ : DistribMulAction S M\ninst✝⁵ : SMulCommClass R S M\ninst✝⁴ : Monoid T\ninst✝³ : DistribMulAction T M\ninst✝² : SMulCommClass R T M\ninst✝¹ : SMul S T\ninst✝ : IsScalarTower S T M\n⊢ IsScalarTower S T (LieDerivation R L M)","decl":"instance [SMul S T] [IsScalarTower S T M] : IsScalarTower S T (LieDerivation R L M) :=\n  ⟨fun _ _ _ => ext fun _ => smul_assoc _ _ _⟩\n\n"}
{"name":"LieDerivation.instSMulCommClass","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝¹³ : CommRing R\ninst✝¹² : LieRing L\ninst✝¹¹ : LieAlgebra R L\ninst✝¹⁰ : AddCommGroup M\ninst✝⁹ : Module R M\ninst✝⁸ : LieRingModule L M\ninst✝⁷ : LieModule R L M\nS : Type u_4\nT : Type u_5\ninst✝⁶ : Monoid S\ninst✝⁵ : DistribMulAction S M\ninst✝⁴ : SMulCommClass R S M\ninst✝³ : Monoid T\ninst✝² : DistribMulAction T M\ninst✝¹ : SMulCommClass R T M\ninst✝ : SMulCommClass S T M\n⊢ SMulCommClass S T (LieDerivation R L M)","decl":"instance [SMulCommClass S T M] : SMulCommClass S T (LieDerivation R L M) :=\n  ⟨fun _ _ _ => ext fun _ => smul_comm _ _ _⟩\n\n"}
{"name":"LieDerivation.commutator_coe_linear_map","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nD1 D2 : LieDerivation R L L\n⊢ Eq (↑(Bracket.bracket D1 D2)) (Bracket.bracket ↑D1 ↑D2)","decl":"@[simp]\nlemma commutator_coe_linear_map : ↑⁅D1, D2⁆ = ⁅(D1 : Module.End R L), (D2 : Module.End R L)⁆ :=\n  rfl\n\n"}
{"name":"LieDerivation.commutator_apply","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nD1 D2 : LieDerivation R L L\na : L\n⊢ Eq ((Bracket.bracket D1 D2) a) (HSub.hSub (D1 (D2 a)) (D2 (D1 a)))","decl":"lemma commutator_apply (a : L) : ⁅D1, D2⁆ a = D1 (D2 a) - D2 (D1 a) :=\n  rfl\n\n"}
{"name":"LieDerivation.lie_apply","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nD₁ D₂ : LieDerivation R L L\nx : L\n⊢ Eq ((Bracket.bracket D₁ D₂) x) (HSub.hSub (D₁ (D₂ x)) (D₂ (D₁ x)))","decl":"@[simp] lemma lie_apply (D₁ D₂ : LieDerivation R L L) (x : L) :\n    ⁅D₁, D₂⁆ x = D₁ (D₂ x) - D₂ (D₁ x) :=\n  rfl\n\n"}
{"name":"LieDerivation.toLinearMapLieHom_injective","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Function.Injective ⇑(LieDerivation.toLinearMapLieHom R L)","decl":"/-- The map from Lie derivations to linear endormophisms is injective. -/\nlemma toLinearMapLieHom_injective : Function.Injective (toLinearMapLieHom R L) :=\n  fun _ _ h ↦ ext fun a ↦ congrFun (congrArg DFunLike.coe h) a\n\n"}
{"name":"LieDerivation.instNoetherian","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : IsNoetherian R L\n⊢ IsNoetherian R (LieDerivation R L L)","decl":"/-- Lie derivations over a Noetherian Lie algebra form a Noetherian module. -/\ninstance instNoetherian [IsNoetherian R L] : IsNoetherian R (LieDerivation R L L) :=\n  isNoetherian_of_linearEquiv (LinearEquiv.ofInjective _ (toLinearMapLieHom_injective R L)).symm\n\n"}
{"name":"LieDerivation.inner_apply_apply","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nm✝ : M\nm : L\n⊢ Eq (((LieDerivation.inner R L M) m✝) m) (Bracket.bracket m m✝)","decl":"/-- The natural map from a Lie module to the derivations taking values in it. -/\n@[simps!]\ndef inner : M →ₗ[R] LieDerivation R L M where\n  toFun m :=\n    { __ := (LieModule.toEnd R L M : L →ₗ[R] Module.End R M).flip m\n      leibniz' := by simp }\n  map_add' m n := by ext; simp\n  map_smul' t m := by ext; simp\n\n"}
{"name":"LieDerivation.lie_lieDerivation_apply","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx y : L\nD : LieDerivation R L M\n⊢ Eq ((Bracket.bracket x D) y) (Bracket.bracket y (D x))","decl":"@[simp] lemma lie_lieDerivation_apply (x y : L) (D : LieDerivation R L M) :\n    ⁅x, D⁆ y = ⁅y, D x⁆ :=\n  rfl\n\n"}
{"name":"LieDerivation.lie_coe_lieDerivation_apply","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nx : L\nD : LieDerivation R L M\n⊢ Eq (Bracket.bracket x ↑D) ↑(Bracket.bracket x D)","decl":"@[simp] lemma lie_coe_lieDerivation_apply (x : L) (D : LieDerivation R L M) :\n    ⁅x, (D : L →ₗ[R] M)⁆ = ⁅x, D⁆ := by\n  ext; simp\n\n"}
{"name":"LieDerivation.instLieModule","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ LieModule R L (LieDerivation R L M)","decl":"instance instLieModule : LieModule R L (LieDerivation R L M) where\n  smul_lie t x D := by ext; simp\n  lie_smul t x D := by ext; simp\n\n"}
{"name":"LieDerivation.leibniz_lie","module":"Mathlib.Algebra.Lie.Derivation.Basic","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nx : L\nD₁ D₂ : LieDerivation R L L\n⊢ Eq (Bracket.bracket x (Bracket.bracket D₁ D₂)) (HAdd.hAdd (Bracket.bracket (Bracket.bracket x D₁) D₂) (Bracket.bracket D₁ (Bracket.bracket x D₂)))","decl":"protected lemma leibniz_lie (x : L) (D₁ D₂ : LieDerivation R L L) :\n    ⁅x, ⁅D₁, D₂⁆⁆ = ⁅⁅x, D₁⁆, D₂⁆ + ⁅D₁, ⁅x, D₂⁆⁆ := by\n  ext y\n  simp [-lie_skew, ← lie_skew (D₁ x) (D₂ y), ← lie_skew (D₂ x) (D₁ y), sub_eq_neg_add]\n\n"}
