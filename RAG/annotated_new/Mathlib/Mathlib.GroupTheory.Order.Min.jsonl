{"name":"AddMonoid.minOrder_eq_top","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\n⊢ Iff (Eq (AddMonoid.minOrder α) Top.top) (AddMonoid.IsTorsionFree α)","decl":"@[to_additive (attr := simp)]\nlemma minOrder_eq_top : minOrder α = ⊤ ↔ IsTorsionFree α := by simp [minOrder, IsTorsionFree]\n\n"}
{"name":"Monoid.minOrder_eq_top","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"α : Type u_1\ninst✝ : Monoid α\n⊢ Iff (Eq (Monoid.minOrder α) Top.top) (Monoid.IsTorsionFree α)","decl":"@[to_additive (attr := simp)]\nlemma minOrder_eq_top : minOrder α = ⊤ ↔ IsTorsionFree α := by simp [minOrder, IsTorsionFree]\n\n"}
{"name":"Monoid.IsTorsionFree.minOrder","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na✝ : Monoid.IsTorsionFree α\n⊢ Eq (Monoid.minOrder α) Top.top","decl":"@[to_additive (attr := simp)] protected alias ⟨_, IsTorsionFree.minOrder⟩ := minOrder_eq_top\n\n"}
{"name":"AddMonoid.IsTorsionFree.minOrder","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\na✝ : AddMonoid.IsTorsionFree α\n⊢ Eq (AddMonoid.minOrder α) Top.top","decl":"@[to_additive (attr := simp)] protected alias ⟨_, IsTorsionFree.minOrder⟩ := minOrder_eq_top\n\n"}
{"name":"AddMonoid.le_minOrder","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\nn : ENat\n⊢ Iff (LE.le n (AddMonoid.minOrder α)) (∀ ⦃a : α⦄, Ne a 0 → IsOfFinAddOrder a → LE.le n ↑(addOrderOf a))","decl":"@[to_additive (attr := simp)]\nlemma le_minOrder {n : ℕ∞} :\n    n ≤ minOrder α ↔ ∀ ⦃a : α⦄, a ≠ 1 → IsOfFinOrder a → n ≤ orderOf a := by simp [minOrder]\n\n"}
{"name":"Monoid.le_minOrder","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"α : Type u_1\ninst✝ : Monoid α\nn : ENat\n⊢ Iff (LE.le n (Monoid.minOrder α)) (∀ ⦃a : α⦄, Ne a 1 → IsOfFinOrder a → LE.le n ↑(orderOf a))","decl":"@[to_additive (attr := simp)]\nlemma le_minOrder {n : ℕ∞} :\n    n ≤ minOrder α ↔ ∀ ⦃a : α⦄, a ≠ 1 → IsOfFinOrder a → n ≤ orderOf a := by simp [minOrder]\n\n"}
{"name":"Monoid.minOrder_le_orderOf","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na : α\nha : Ne a 1\nha' : IsOfFinOrder a\n⊢ LE.le (Monoid.minOrder α) ↑(orderOf a)","decl":"@[to_additive]\nlemma minOrder_le_orderOf (ha : a ≠ 1) (ha' : IsOfFinOrder a) : minOrder α ≤ orderOf a :=\n  le_minOrder.1 le_rfl ha ha'\n\n"}
{"name":"AddMonoid.minOrder_le_addOrderOf","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\na : α\nha : Ne a 0\nha' : IsOfFinAddOrder a\n⊢ LE.le (AddMonoid.minOrder α) ↑(addOrderOf a)","decl":"@[to_additive]\nlemma minOrder_le_orderOf (ha : a ≠ 1) (ha' : IsOfFinOrder a) : minOrder α ≤ orderOf a :=\n  le_minOrder.1 le_rfl ha ha'\n\n"}
{"name":"Monoid.le_minOrder_iff_forall_subgroup","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"α : Type u_1\ninst✝ : Group α\nn : ENat\n⊢ Iff (LE.le n (Monoid.minOrder α)) (∀ ⦃s : Subgroup α⦄, Ne s Bot.bot → (↑s).Finite → LE.le n ↑(Nat.card (Subtype fun x => Membership.mem s x)))","decl":"@[to_additive]\nlemma le_minOrder_iff_forall_subgroup {n : ℕ∞} :\n    n ≤ minOrder α ↔ ∀ ⦃s : Subgroup α⦄, s ≠ ⊥ → (s : Set α).Finite → n ≤ Nat.card s := by\n  rw [le_minOrder]\n  refine ⟨fun h s hs hs' ↦ ?_, fun h a ha ha' ↦ ?_⟩\n  · obtain ⟨a, has, ha⟩ := s.bot_or_exists_ne_one.resolve_left hs\n    exact\n      (h ha <| finite_zpowers.1 <| hs'.subset <| zpowers_le.2 has).trans\n        (WithTop.coe_le_coe.2 <| s.orderOf_le_card hs' has)\n  · simpa using h (zpowers_ne_bot.2 ha) ha'.finite_zpowers\n\n"}
{"name":"AddMonoid.le_minOrder_iff_forall_addSubgroup","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nn : ENat\n⊢ Iff (LE.le n (AddMonoid.minOrder α)) (∀ ⦃s : AddSubgroup α⦄, Ne s Bot.bot → (↑s).Finite → LE.le n ↑(Nat.card (Subtype fun x => Membership.mem s x)))","decl":"@[to_additive]\nlemma le_minOrder_iff_forall_subgroup {n : ℕ∞} :\n    n ≤ minOrder α ↔ ∀ ⦃s : Subgroup α⦄, s ≠ ⊥ → (s : Set α).Finite → n ≤ Nat.card s := by\n  rw [le_minOrder]\n  refine ⟨fun h s hs hs' ↦ ?_, fun h a ha ha' ↦ ?_⟩\n  · obtain ⟨a, has, ha⟩ := s.bot_or_exists_ne_one.resolve_left hs\n    exact\n      (h ha <| finite_zpowers.1 <| hs'.subset <| zpowers_le.2 has).trans\n        (WithTop.coe_le_coe.2 <| s.orderOf_le_card hs' has)\n  · simpa using h (zpowers_ne_bot.2 ha) ha'.finite_zpowers\n\n"}
{"name":"AddMonoid.minOrder_le_natCard","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nhs : Ne s Bot.bot\nhs' : (↑s).Finite\n⊢ LE.le (AddMonoid.minOrder α) ↑(Nat.card (Subtype fun x => Membership.mem s x))","decl":"@[to_additive]\nlemma minOrder_le_natCard (hs : s ≠ ⊥) (hs' : (s : Set α).Finite) : minOrder α ≤ Nat.card s :=\n  le_minOrder_iff_forall_subgroup.1 le_rfl hs hs'\n\n"}
{"name":"Monoid.minOrder_le_natCard","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nhs : Ne s Bot.bot\nhs' : (↑s).Finite\n⊢ LE.le (Monoid.minOrder α) ↑(Nat.card (Subtype fun x => Membership.mem s x))","decl":"@[to_additive]\nlemma minOrder_le_natCard (hs : s ≠ ⊥) (hs' : (s : Set α).Finite) : minOrder α ≤ Nat.card s :=\n  le_minOrder_iff_forall_subgroup.1 le_rfl hs hs'\n\n"}
{"name":"ZMod.minOrder","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"n : Nat\nhn : Ne n 0\nhn₁ : Ne n 1\n⊢ Eq (AddMonoid.minOrder (ZMod n)) ↑n.minFac","decl":"@[simp]\nprotected lemma minOrder {n : ℕ} (hn : n ≠ 0) (hn₁ : n ≠ 1) : minOrder (ZMod n) = n.minFac := by\n  have : Fact (1 < n) := ⟨one_lt_iff_ne_zero_and_ne_one.mpr ⟨hn, hn₁⟩⟩\n  classical\n  have : (↑(n / n.minFac) : ZMod n) ≠ 0 := by\n    rw [Ne, ringChar.spec, ringChar.eq (ZMod n) n]\n    exact\n      not_dvd_of_pos_of_lt (Nat.div_pos (minFac_le hn.bot_lt) n.minFac_pos)\n        (div_lt_self hn.bot_lt (minFac_prime hn₁).one_lt)\n  refine ((minOrder_le_natCard (zmultiples_eq_bot.not.2 this) <| toFinite _).trans ?_).antisymm <|\n    le_minOrder_iff_forall_addSubgroup.2 fun s hs _ ↦ ?_\n  · rw [Nat.card_zmultiples, ZMod.addOrderOf_coe _ hn,\n      gcd_eq_right (div_dvd_of_dvd n.minFac_dvd), Nat.div_div_self n.minFac_dvd hn]\n  · haveI : Nontrivial s := s.bot_or_nontrivial.resolve_left hs\n    exact WithTop.coe_le_coe.2 <| minFac_le_of_dvd Finite.one_lt_card <|\n      (card_addSubgroup_dvd_card _).trans n.card_zmod.dvd\n\n"}
{"name":"ZMod.minOrder_of_prime","module":"Mathlib.GroupTheory.Order.Min","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Eq (AddMonoid.minOrder (ZMod p)) ↑p","decl":"@[simp]\nlemma minOrder_of_prime {p : ℕ} (hp : p.Prime) : minOrder (ZMod p) = p := by\n  rw [ZMod.minOrder hp.ne_zero hp.ne_one, hp.minFac_eq]\n\n"}
