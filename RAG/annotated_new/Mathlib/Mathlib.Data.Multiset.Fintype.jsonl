{"name":"Multiset.coe_mk","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\nx : α\ni : Fin (Multiset.count x m)\n⊢ Eq (m.mkToType x i).fst x","decl":"theorem coe_mk {x : α} {i : Fin (m.count x)} : ↑(m.mkToType x i) = x :=\n  rfl\n\n"}
{"name":"Multiset.coe_mem","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\nx : m.ToType\n⊢ Membership.mem m x.fst","decl":"@[simp] lemma coe_mem {x : m} : ↑x ∈ m := Multiset.count_pos.mp (by have := x.2.2; omega)\n\n"}
{"name":"Multiset.forall_coe","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\np : m.ToType → Prop\n⊢ Iff (∀ (x : m.ToType), p x) (∀ (x : α) (i : Fin (Multiset.count x m)), p ⟨x, i⟩)","decl":"@[simp]\nprotected theorem forall_coe (p : m → Prop) :\n    (∀ x : m, p x) ↔ ∀ (x : α) (i : Fin (m.count x)), p ⟨x, i⟩ :=\n  Sigma.forall\n\n"}
{"name":"Multiset.exists_coe","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\np : m.ToType → Prop\n⊢ Iff (Exists fun x => p x) (Exists fun x => Exists fun i => p ⟨x, i⟩)","decl":"@[simp]\nprotected theorem exists_coe (p : m → Prop) :\n    (∃ x : m, p x) ↔ ∃ (x : α) (i : Fin (m.count x)), p ⟨x, i⟩ :=\n  Sigma.exists\n\n"}
{"name":"Multiset.mem_toEnumFinset","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\np : Prod α Nat\n⊢ Iff (Membership.mem m.toEnumFinset p) (LT.lt p.2 (Multiset.count p.1 m))","decl":"@[simp]\ntheorem mem_toEnumFinset (m : Multiset α) (p : α × ℕ) :\n    p ∈ m.toEnumFinset ↔ p.2 < m.count p.1 :=\n  Set.mem_toFinset\n\n"}
{"name":"Multiset.mem_of_mem_toEnumFinset","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\np : Prod α Nat\nh : Membership.mem m.toEnumFinset p\n⊢ Membership.mem m p.1","decl":"theorem mem_of_mem_toEnumFinset {p : α × ℕ} (h : p ∈ m.toEnumFinset) : p.1 ∈ m :=\n  have := (m.mem_toEnumFinset p).mp h; Multiset.count_pos.mp (by omega)\n\n"}
{"name":"Multiset.toEnumFinset_filter_eq","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\na : α\n⊢ Eq (Finset.filter (fun x => Eq x.1 a) m.toEnumFinset) (SProd.sprod (Singleton.singleton a) (Finset.range (Multiset.count a m)))","decl":"@[simp] lemma toEnumFinset_filter_eq (m : Multiset α) (a : α) :\n    m.toEnumFinset.filter (·.1 = a) = {a} ×ˢ Finset.range (m.count a) := by aesop\n\n"}
{"name":"Multiset.map_toEnumFinset_fst","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Eq (Multiset.map Prod.fst m.toEnumFinset.val) m","decl":"@[simp] lemma map_toEnumFinset_fst (m : Multiset α) : m.toEnumFinset.val.map Prod.fst = m := by\n  ext a; simp [count_map, ← Finset.filter_val, eq_comm (a := a)]\n\n"}
{"name":"Multiset.image_toEnumFinset_fst","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Eq (Finset.image Prod.fst m.toEnumFinset) m.toFinset","decl":"@[simp] lemma image_toEnumFinset_fst (m : Multiset α) :\n    m.toEnumFinset.image Prod.fst = m.toFinset := by\n  rw [Finset.image, Multiset.map_toEnumFinset_fst]\n\n"}
{"name":"Multiset.map_fst_le_of_subset_toEnumFinset","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\ns : Finset (Prod α Nat)\nhsm : HasSubset.Subset s m.toEnumFinset\n⊢ LE.le (Multiset.map Prod.fst s.val) m","decl":"@[simp] lemma map_fst_le_of_subset_toEnumFinset {s : Finset (α × ℕ)} (hsm : s ⊆ m.toEnumFinset) :\n    s.1.map Prod.fst ≤ m := by\n  simp_rw [le_iff_count, count_map]\n  rintro a\n  obtain ha | ha := (s.1.filter fun x ↦ a = x.1).card.eq_zero_or_pos\n  · rw [ha]\n    exact Nat.zero_le _\n  obtain ⟨n, han, hn⟩ : ∃ n ≥ card (s.1.filter fun x ↦ a = x.1) - 1, (a, n) ∈ s := by\n    by_contra! h\n    replace h : s.filter (·.1 = a) ⊆ {a} ×ˢ .range (card (s.1.filter fun x ↦ a = x.1) - 1) := by\n      simpa (config := { contextual := true }) [forall_swap (β := _ = a), Finset.subset_iff,\n        imp_not_comm, not_le, Nat.lt_sub_iff_add_lt] using h\n    have : card (s.1.filter fun x ↦ a = x.1) ≤ card (s.1.filter fun x ↦ a = x.1) - 1 := by\n      simpa [Finset.card, eq_comm] using Finset.card_mono h\n    omega\n  exact Nat.le_of_pred_lt (han.trans_lt <| by simpa using hsm hn)\n\n"}
{"name":"Multiset.toEnumFinset_mono","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm₁ m₂ : Multiset α\nh : LE.le m₁ m₂\n⊢ HasSubset.Subset m₁.toEnumFinset m₂.toEnumFinset","decl":"@[mono]\ntheorem toEnumFinset_mono {m₁ m₂ : Multiset α} (h : m₁ ≤ m₂) :\n    m₁.toEnumFinset ⊆ m₂.toEnumFinset := by\n  intro p\n  simp only [Multiset.mem_toEnumFinset]\n  exact gt_of_ge_of_gt (Multiset.le_iff_count.mp h p.1)\n\n"}
{"name":"Multiset.toEnumFinset_subset_iff","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm₁ m₂ : Multiset α\n⊢ Iff (HasSubset.Subset m₁.toEnumFinset m₂.toEnumFinset) (LE.le m₁ m₂)","decl":"@[simp]\ntheorem toEnumFinset_subset_iff {m₁ m₂ : Multiset α} :\n    m₁.toEnumFinset ⊆ m₂.toEnumFinset ↔ m₁ ≤ m₂ :=\n  ⟨fun h ↦ by simpa using map_fst_le_of_subset_toEnumFinset h, Multiset.toEnumFinset_mono⟩\n\n"}
{"name":"Multiset.coeEmbedding_apply","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\nx : m.ToType\n⊢ Eq (m.coeEmbedding x) { fst := x.fst, snd := ↑x.snd }","decl":"/-- The embedding from a multiset into `α × ℕ` where the second coordinate enumerates repeats.\nIf you are looking for the function `m → α`, that would be plain `(↑)`. -/\n@[simps]\ndef coeEmbedding (m : Multiset α) : m ↪ α × ℕ where\n  toFun x := (x, x.2)\n  inj' := by\n    intro ⟨x, i, hi⟩ ⟨y, j, hj⟩\n    rintro ⟨⟩\n    rfl\n\n"}
{"name":"Multiset.coeEquiv_apply_coe","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\nx : m.ToType\n⊢ Eq (↑(m.coeEquiv x)) (m.coeEmbedding x)","decl":"/-- Another way to coerce a `Multiset` to a type is to go through `m.toEnumFinset` and coerce\nthat `Finset` to a type. -/\n@[simps]\ndef coeEquiv (m : Multiset α) : m ≃ m.toEnumFinset where\n  toFun x :=\n    ⟨m.coeEmbedding x, by\n      rw [Multiset.mem_toEnumFinset]\n      exact x.2.2⟩\n  invFun x :=\n    ⟨x.1.1, x.1.2, by\n      rw [← Multiset.mem_toEnumFinset]\n      exact x.2⟩\n  left_inv := by\n    rintro ⟨x, i, h⟩\n    rfl\n  right_inv := by\n    rintro ⟨⟨x, i⟩, h⟩\n    rfl\n\n"}
{"name":"Multiset.coeEquiv_symm_apply_snd_val","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\nx : Subtype fun x => Membership.mem m.toEnumFinset x\n⊢ Eq (↑(m.coeEquiv.symm x).snd) (↑x).2","decl":"/-- Another way to coerce a `Multiset` to a type is to go through `m.toEnumFinset` and coerce\nthat `Finset` to a type. -/\n@[simps]\ndef coeEquiv (m : Multiset α) : m ≃ m.toEnumFinset where\n  toFun x :=\n    ⟨m.coeEmbedding x, by\n      rw [Multiset.mem_toEnumFinset]\n      exact x.2.2⟩\n  invFun x :=\n    ⟨x.1.1, x.1.2, by\n      rw [← Multiset.mem_toEnumFinset]\n      exact x.2⟩\n  left_inv := by\n    rintro ⟨x, i, h⟩\n    rfl\n  right_inv := by\n    rintro ⟨⟨x, i⟩, h⟩\n    rfl\n\n"}
{"name":"Multiset.coeEquiv_symm_apply_fst","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\nx : Subtype fun x => Membership.mem m.toEnumFinset x\n⊢ Eq (m.coeEquiv.symm x).fst (↑x).1","decl":"/-- Another way to coerce a `Multiset` to a type is to go through `m.toEnumFinset` and coerce\nthat `Finset` to a type. -/\n@[simps]\ndef coeEquiv (m : Multiset α) : m ≃ m.toEnumFinset where\n  toFun x :=\n    ⟨m.coeEmbedding x, by\n      rw [Multiset.mem_toEnumFinset]\n      exact x.2.2⟩\n  invFun x :=\n    ⟨x.1.1, x.1.2, by\n      rw [← Multiset.mem_toEnumFinset]\n      exact x.2⟩\n  left_inv := by\n    rintro ⟨x, i, h⟩\n    rfl\n  right_inv := by\n    rintro ⟨⟨x, i⟩, h⟩\n    rfl\n\n"}
{"name":"Multiset.toEmbedding_coeEquiv_trans","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Eq (m.coeEquiv.toEmbedding.trans (Function.Embedding.subtype fun x => Membership.mem m.toEnumFinset x)) m.coeEmbedding","decl":"@[simp]\ntheorem toEmbedding_coeEquiv_trans (m : Multiset α) :\n    m.coeEquiv.toEmbedding.trans (Function.Embedding.subtype _) = m.coeEmbedding := by ext <;> rfl\n\n"}
{"name":"Multiset.map_univ_coeEmbedding","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Eq (Finset.map m.coeEmbedding Finset.univ) m.toEnumFinset","decl":"theorem map_univ_coeEmbedding (m : Multiset α) :\n    (Finset.univ : Finset m).map m.coeEmbedding = m.toEnumFinset := by\n  ext ⟨x, i⟩\n  simp only [Fin.exists_iff, Finset.mem_map, Finset.mem_univ, Multiset.coeEmbedding_apply,\n    Prod.mk.inj_iff, exists_true_left, Multiset.exists_coe, Multiset.coe_mk, Fin.val_mk,\n    exists_prop, exists_eq_right_right, exists_eq_right, Multiset.mem_toEnumFinset, true_and]\n\n"}
{"name":"Multiset.map_univ_coe","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Eq (Multiset.map (fun x => x.fst) Finset.univ.val) m","decl":"@[simp]\ntheorem map_univ_coe (m : Multiset α) :\n    (Finset.univ : Finset m).val.map (fun x : m ↦ (x : α)) = m := by\n  have := m.map_toEnumFinset_fst\n  rw [← m.map_univ_coeEmbedding] at this\n  simpa only [Finset.map_val, Multiset.coeEmbedding_apply, Multiset.map_map,\n    Function.comp_apply] using this\n\n"}
{"name":"Multiset.map_univ","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nβ : Type u_3\nm : Multiset α\nf : α → β\n⊢ Eq (Multiset.map (fun x => f x.fst) Finset.univ.val) (Multiset.map f m)","decl":"@[simp]\ntheorem map_univ {β : Type*} (m : Multiset α) (f : α → β) :\n    ((Finset.univ : Finset m).val.map fun (x : m) ↦ f (x : α)) = m.map f := by\n  erw [← Multiset.map_map, Multiset.map_univ_coe]\n\n"}
{"name":"Multiset.card_toEnumFinset","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Eq m.toEnumFinset.card m.card","decl":"@[simp]\ntheorem card_toEnumFinset (m : Multiset α) : m.toEnumFinset.card = Multiset.card m := by\n  rw [Finset.card, ← Multiset.card_map Prod.fst m.toEnumFinset.val]\n  congr\n  exact m.map_toEnumFinset_fst\n\n"}
{"name":"Multiset.card_coe","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Eq (Fintype.card m.ToType) m.card","decl":"@[simp]\ntheorem card_coe (m : Multiset α) : Fintype.card m = Multiset.card m := by\n  rw [Fintype.card_congr m.coeEquiv]\n  simp only [Fintype.card_coe, card_toEnumFinset]\n\n"}
{"name":"Multiset.prod_eq_prod_coe","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : CommMonoid α\nm : Multiset α\n⊢ Eq m.prod (Finset.univ.prod fun x => x.fst)","decl":"@[to_additive]\ntheorem prod_eq_prod_coe [CommMonoid α] (m : Multiset α) : m.prod = ∏ x : m, (x : α) := by\n  congr\n  simp\n\n"}
{"name":"Multiset.sum_eq_sum_coe","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddCommMonoid α\nm : Multiset α\n⊢ Eq m.sum (Finset.univ.sum fun x => x.fst)","decl":"@[to_additive]\ntheorem prod_eq_prod_coe [CommMonoid α] (m : Multiset α) : m.prod = ∏ x : m, (x : α) := by\n  congr\n  simp\n\n"}
{"name":"Multiset.sum_eq_sum_toEnumFinset","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : AddCommMonoid α\nm : Multiset α\n⊢ Eq m.sum (m.toEnumFinset.sum fun x => x.1)","decl":"@[to_additive]\ntheorem prod_eq_prod_toEnumFinset [CommMonoid α] (m : Multiset α) :\n    m.prod = ∏ x ∈ m.toEnumFinset, x.1 := by\n  congr\n  simp\n\n"}
{"name":"Multiset.prod_eq_prod_toEnumFinset","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : CommMonoid α\nm : Multiset α\n⊢ Eq m.prod (m.toEnumFinset.prod fun x => x.1)","decl":"@[to_additive]\ntheorem prod_eq_prod_toEnumFinset [CommMonoid α] (m : Multiset α) :\n    m.prod = ∏ x ∈ m.toEnumFinset, x.1 := by\n  congr\n  simp\n\n"}
{"name":"Multiset.prod_toEnumFinset","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nβ : Type u_3\ninst✝ : CommMonoid β\nm : Multiset α\nf : α → Nat → β\n⊢ Eq (m.toEnumFinset.prod fun x => f x.1 x.2) (Finset.univ.prod fun x => f x.fst ↑x.snd)","decl":"@[to_additive]\ntheorem prod_toEnumFinset {β : Type*} [CommMonoid β] (m : Multiset α) (f : α → ℕ → β) :\n    ∏ x ∈ m.toEnumFinset, f x.1 x.2 = ∏ x : m, f x x.2 := by\n  rw [Fintype.prod_equiv m.coeEquiv (fun x ↦ f x x.2) fun x ↦ f x.1.1 x.1.2]\n  · rw [← m.toEnumFinset.prod_coe_sort fun x ↦ f x.1 x.2]\n  · intro x\n    rfl\n\n"}
{"name":"Multiset.sum_toEnumFinset","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nβ : Type u_3\ninst✝ : AddCommMonoid β\nm : Multiset α\nf : α → Nat → β\n⊢ Eq (m.toEnumFinset.sum fun x => f x.1 x.2) (Finset.univ.sum fun x => f x.fst ↑x.snd)","decl":"@[to_additive]\ntheorem prod_toEnumFinset {β : Type*} [CommMonoid β] (m : Multiset α) (f : α → ℕ → β) :\n    ∏ x ∈ m.toEnumFinset, f x.1 x.2 = ∏ x : m, f x x.2 := by\n  rw [Fintype.prod_equiv m.coeEquiv (fun x ↦ f x x.2) fun x ↦ f x.1.1 x.1.2]\n  · rw [← m.toEnumFinset.prod_coe_sort fun x ↦ f x.1 x.2]\n  · intro x\n    rfl\n\n"}
{"name":"Multiset.cast_apply_snd","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : Eq s t\nx : s.ToType\n⊢ Eq ((Multiset.cast h) x).snd (Fin.cast ⋯ x.snd)","decl":"/--\nIf `s = t` then there's an equivalence between the appropriate types.\n-/\n@[simps]\ndef cast {s t : Multiset α} (h : s = t) : s ≃ t where\n  toFun x := ⟨x.1, x.2.cast (by simp [h])⟩\n  invFun x := ⟨x.1, x.2.cast (by simp [h])⟩\n  left_inv x := rfl\n  right_inv x := rfl\n\n"}
{"name":"Multiset.cast_symm_apply_fst","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : Eq s t\nx : t.ToType\n⊢ Eq ((Multiset.cast h).symm x).fst x.fst","decl":"/--\nIf `s = t` then there's an equivalence between the appropriate types.\n-/\n@[simps]\ndef cast {s t : Multiset α} (h : s = t) : s ≃ t where\n  toFun x := ⟨x.1, x.2.cast (by simp [h])⟩\n  invFun x := ⟨x.1, x.2.cast (by simp [h])⟩\n  left_inv x := rfl\n  right_inv x := rfl\n\n"}
{"name":"Multiset.cast_apply_fst","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : Eq s t\nx : s.ToType\n⊢ Eq ((Multiset.cast h) x).fst x.fst","decl":"/--\nIf `s = t` then there's an equivalence between the appropriate types.\n-/\n@[simps]\ndef cast {s t : Multiset α} (h : s = t) : s ≃ t where\n  toFun x := ⟨x.1, x.2.cast (by simp [h])⟩\n  invFun x := ⟨x.1, x.2.cast (by simp [h])⟩\n  left_inv x := rfl\n  right_inv x := rfl\n\n"}
{"name":"Multiset.cast_symm_apply_snd","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : Eq s t\nx : t.ToType\n⊢ Eq ((Multiset.cast h).symm x).snd (Fin.cast ⋯ x.snd)","decl":"/--\nIf `s = t` then there's an equivalence between the appropriate types.\n-/\n@[simps]\ndef cast {s t : Multiset α} (h : s = t) : s ≃ t where\n  toFun x := ⟨x.1, x.2.cast (by simp [h])⟩\n  invFun x := ⟨x.1, x.2.cast (by simp [h])⟩\n  left_inv x := rfl\n  right_inv x := rfl\n\n"}
{"name":"Multiset.instIsEmptyToTypeOfNat","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ IsEmpty (Multiset.ToType 0)","decl":"instance : IsEmpty (0 : Multiset α) := Fintype.card_eq_zero_iff.mp (by simp)\n\n"}
{"name":"Multiset.instIsEmptyToTypeEmptyCollection","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ IsEmpty EmptyCollection.emptyCollection.ToType","decl":"instance : IsEmpty (∅ : Multiset α) := Fintype.card_eq_zero_iff.mp (by simp)\n\n"}
{"name":"Multiset.consEquiv_symm_none","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\nv : α\n⊢ Eq (Multiset.consEquiv.symm Option.none) ⟨v, ⟨Multiset.count v m, ⋯⟩⟩","decl":"@[simp]\nlemma consEquiv_symm_none {v : α} :\n    (consEquiv (m := m) (v := v)).symm none =\n      ⟨v, ⟨m.count v, (count_cons_self v m) ▸ (Nat.lt_add_one _)⟩⟩ :=\n  rfl\n\n"}
{"name":"Multiset.consEquiv_symm_some","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\nv : α\nx : m.ToType\n⊢ Eq (Multiset.consEquiv.symm (Option.some x)) ⟨x.fst, Fin.castLE ⋯ x.snd⟩","decl":"@[simp]\nlemma consEquiv_symm_some {v : α} {x : m} :\n    (consEquiv (v := v)).symm (some x) =\n      ⟨x, x.2.castLE (count_le_count_cons ..)⟩ :=\n  rfl\n\n"}
{"name":"Multiset.coe_consEquiv_of_ne","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\nv : α\nx : (Multiset.cons v m).ToType\nhx : Ne x.fst v\n⊢ Eq (Multiset.consEquiv x) (Option.some ⟨x.fst, Fin.cast ⋯ x.snd⟩)","decl":"lemma coe_consEquiv_of_ne {v : α} (x : v ::ₘ m) (hx : ↑x ≠ v) :\n    consEquiv x = some ⟨x.1, x.2.cast (by simp [hx])⟩ := by\n  simp [consEquiv, hx]\n  rfl\n\n"}
{"name":"Multiset.coe_consEquiv_of_eq_of_eq","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\nv : α\nx : (Multiset.cons v m).ToType\nhx : Eq x.fst v\nhx2 : Eq (↑x.snd) (Multiset.count v m)\n⊢ Eq (Multiset.consEquiv x) Option.none","decl":"lemma coe_consEquiv_of_eq_of_eq {v : α} (x : v ::ₘ m) (hx : ↑x = v) (hx2 : x.2 = m.count v) :\n    consEquiv x = none := by simp [consEquiv, hx, hx2]\n\n"}
{"name":"Multiset.coe_consEquiv_of_eq_of_lt","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\nv : α\nx : (Multiset.cons v m).ToType\nhx : Eq x.fst v\nhx2 : LT.lt (↑x.snd) (Multiset.count v m)\n⊢ Eq (Multiset.consEquiv x) (Option.some ⟨x.fst, ⟨↑x.snd, ⋯⟩⟩)","decl":"lemma coe_consEquiv_of_eq_of_lt {v : α} (x : v ::ₘ m) (hx : ↑x = v) (hx2 : x.2 < m.count v) :\n    consEquiv x = some ⟨x.1, ⟨x.2, by simpa [hx]⟩⟩ := by simp [consEquiv, hx, hx2.ne]\n\n"}
{"name":"Multiset.mapEquiv_apply","module":"Mathlib.Data.Multiset.Fintype","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\ns : Multiset α\nf : α → β\nv : s.ToType\n⊢ Eq ((s.mapEquiv f) v).fst (f v.fst)","decl":"@[simp]\ntheorem mapEquiv_apply (s : Multiset α) (f : α → β) (v : s) : s.mapEquiv f v = f v :=\n  (Multiset.mapEquiv_aux s f).out.2 v\n\n"}
