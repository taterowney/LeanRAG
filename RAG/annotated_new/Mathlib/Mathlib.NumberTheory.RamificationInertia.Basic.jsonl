{"name":"Ideal.ramificationIdx_eq_find","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nS : Type v\ninst✝¹ : CommRing S\nf : RingHom R S\np : Ideal R\nP : Ideal S\ninst✝ : DecidablePred fun n => ∀ (k : Nat), LE.le (Ideal.map f p) (HPow.hPow P k) → LE.le k n\nh : Exists fun n => ∀ (k : Nat), LE.le (Ideal.map f p) (HPow.hPow P k) → LE.le k n\n⊢ Eq (Ideal.ramificationIdx f p P) (Nat.find h)","decl":"theorem ramificationIdx_eq_find [DecidablePred fun n ↦ ∀ (k : ℕ), map f p ≤ P ^ k → k ≤ n]\n    (h : ∃ n, ∀ k, map f p ≤ P ^ k → k ≤ n) :\n    ramificationIdx f p P = Nat.find h := by\n  convert Nat.sSup_def h\n\n"}
{"name":"Ideal.ramificationIdx_eq_zero","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\np : Ideal R\nP : Ideal S\nh : ∀ (n : Nat), Exists fun k => And (LE.le (Ideal.map f p) (HPow.hPow P k)) (LT.lt n k)\n⊢ Eq (Ideal.ramificationIdx f p P) 0","decl":"theorem ramificationIdx_eq_zero (h : ∀ n : ℕ, ∃ k, map f p ≤ P ^ k ∧ n < k) :\n    ramificationIdx f p P = 0 :=\n  dif_neg (by push_neg; exact h)\n\n"}
{"name":"Ideal.ramificationIdx_spec","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\np : Ideal R\nP : Ideal S\nn : Nat\nhle : LE.le (Ideal.map f p) (HPow.hPow P n)\nhgt : Not (LE.le (Ideal.map f p) (HPow.hPow P (HAdd.hAdd n 1)))\n⊢ Eq (Ideal.ramificationIdx f p P) n","decl":"theorem ramificationIdx_spec {n : ℕ} (hle : map f p ≤ P ^ n) (hgt : ¬map f p ≤ P ^ (n + 1)) :\n    ramificationIdx f p P = n := by\n  classical\n  let Q : ℕ → Prop := fun m => ∀ k : ℕ, map f p ≤ P ^ k → k ≤ m\n  have : Q n := by\n    intro k hk\n    refine le_of_not_lt fun hnk => ?_\n    exact hgt (hk.trans (Ideal.pow_le_pow_right hnk))\n  rw [ramificationIdx_eq_find ⟨n, this⟩]\n  refine le_antisymm (Nat.find_min' _ this) (le_of_not_gt fun h : Nat.find _ < n => ?_)\n  obtain this' := Nat.find_spec ⟨n, this⟩\n  exact h.not_le (this' _ hle)\n\n"}
{"name":"Ideal.ramificationIdx_lt","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\np : Ideal R\nP : Ideal S\nn : Nat\nhgt : Not (LE.le (Ideal.map f p) (HPow.hPow P n))\n⊢ LT.lt (Ideal.ramificationIdx f p P) n","decl":"theorem ramificationIdx_lt {n : ℕ} (hgt : ¬map f p ≤ P ^ n) : ramificationIdx f p P < n := by\n  classical\n  cases' n with n n\n  · simp at hgt\n  · rw [Nat.lt_succ_iff]\n    have : ∀ k, map f p ≤ P ^ k → k ≤ n := by\n      refine fun k hk => le_of_not_lt fun hnk => ?_\n      exact hgt (hk.trans (Ideal.pow_le_pow_right hnk))\n    rw [ramificationIdx_eq_find ⟨n, this⟩]\n    exact Nat.find_min' ⟨n, this⟩ this\n\n"}
{"name":"Ideal.ramificationIdx_bot","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\nP : Ideal S\n⊢ Eq (Ideal.ramificationIdx f Bot.bot P) 0","decl":"@[simp]\ntheorem ramificationIdx_bot : ramificationIdx f ⊥ P = 0 :=\n  dif_neg <| not_exists.mpr fun n hn => n.lt_succ_self.not_le (hn _ (by simp))\n\n"}
{"name":"Ideal.ramificationIdx_of_not_le","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\np : Ideal R\nP : Ideal S\nh : Not (LE.le (Ideal.map f p) P)\n⊢ Eq (Ideal.ramificationIdx f p P) 0","decl":"@[simp]\ntheorem ramificationIdx_of_not_le (h : ¬map f p ≤ P) : ramificationIdx f p P = 0 :=\n  ramificationIdx_spec (by simp) (by simpa using h)\n\n"}
{"name":"Ideal.ramificationIdx_ne_zero","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\np : Ideal R\nP : Ideal S\ne : Nat\nhe : Ne e 0\nhle : LE.le (Ideal.map f p) (HPow.hPow P e)\nhnle : Not (LE.le (Ideal.map f p) (HPow.hPow P (HAdd.hAdd e 1)))\n⊢ Ne (Ideal.ramificationIdx f p P) 0","decl":"theorem ramificationIdx_ne_zero {e : ℕ} (he : e ≠ 0) (hle : map f p ≤ P ^ e)\n    (hnle : ¬map f p ≤ P ^ (e + 1)) : ramificationIdx f p P ≠ 0 := by\n  rwa [ramificationIdx_spec hle hnle]\n\n"}
{"name":"Ideal.le_pow_of_le_ramificationIdx","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\np : Ideal R\nP : Ideal S\nn : Nat\nhn : LE.le n (Ideal.ramificationIdx f p P)\n⊢ LE.le (Ideal.map f p) (HPow.hPow P n)","decl":"theorem le_pow_of_le_ramificationIdx {n : ℕ} (hn : n ≤ ramificationIdx f p P) :\n    map f p ≤ P ^ n := by\n  contrapose! hn\n  exact ramificationIdx_lt hn\n\n"}
{"name":"Ideal.le_pow_ramificationIdx","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\np : Ideal R\nP : Ideal S\n⊢ LE.le (Ideal.map f p) (HPow.hPow P (Ideal.ramificationIdx f p P))","decl":"theorem le_pow_ramificationIdx : map f p ≤ P ^ ramificationIdx f p P :=\n  le_pow_of_le_ramificationIdx (le_refl _)\n\n"}
{"name":"Ideal.le_comap_pow_ramificationIdx","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\np : Ideal R\nP : Ideal S\n⊢ LE.le p (Ideal.comap f (HPow.hPow P (Ideal.ramificationIdx f p P)))","decl":"theorem le_comap_pow_ramificationIdx : p ≤ comap f (P ^ ramificationIdx f p P) :=\n  map_le_iff_le_comap.mp le_pow_ramificationIdx\n\n"}
{"name":"Ideal.le_comap_of_ramificationIdx_ne_zero","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nf : RingHom R S\np : Ideal R\nP : Ideal S\nh : Ne (Ideal.ramificationIdx f p P) 0\n⊢ LE.le p (Ideal.comap f P)","decl":"theorem le_comap_of_ramificationIdx_ne_zero (h : ramificationIdx f p P ≠ 0) : p ≤ comap f P :=\n  Ideal.map_le_iff_le_comap.mp <| le_pow_ramificationIdx.trans <| Ideal.pow_le_self <| h\n\n"}
{"name":"Ideal.ramificationIdx_comap_eq","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nS : Type v\ninst✝³ : CommRing S\np : Ideal R\nS₁ : Type u_1\ninst✝² : CommRing S₁\ninst✝¹ : Algebra R S₁\ninst✝ : Algebra R S\ne : AlgEquiv R S S₁\nP : Ideal S₁\n⊢ Eq (Ideal.ramificationIdx (algebraMap R S) p (Ideal.comap e P)) (Ideal.ramificationIdx (algebraMap R S₁) p P)","decl":"variable (p) in\nlemma ramificationIdx_comap_eq [Algebra R S] (e : S ≃ₐ[R] S₁) (P : Ideal S₁) :\n    ramificationIdx (algebraMap R S) p (P.comap e) = ramificationIdx (algebraMap R S₁) p P := by\n  dsimp only [ramificationIdx]\n  congr\n  ext n\n  simp only [Set.mem_setOf_eq, Ideal.map_le_iff_le_comap]\n  rw [← comap_coe e, ← e.toRingEquiv_toRingHom, comap_coe, ← RingEquiv.symm_symm (e : S ≃+* S₁),\n    ← map_comap_of_equiv, ← Ideal.map_pow, map_comap_of_equiv, ← comap_coe (RingEquiv.symm _),\n    comap_comap, RingEquiv.symm_symm, e.toRingEquiv_toRingHom, ← e.toAlgHom_toRingHom,\n    AlgHom.comp_algebraMap]\n\n"}
{"name":"Ideal.ramificationIdx_map_eq","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nS : Type v\ninst✝⁵ : CommRing S\np : Ideal R\nS₁ : Type u_1\ninst✝⁴ : CommRing S₁\ninst✝³ : Algebra R S₁\ninst✝² : Algebra R S\nE : Type u_2\ninst✝¹ : EquivLike E S S₁\ninst✝ : AlgEquivClass E R S S₁\nP : Ideal S\ne : E\n⊢ Eq (Ideal.ramificationIdx (algebraMap R S₁) p (Ideal.map e P)) (Ideal.ramificationIdx (algebraMap R S) p P)","decl":"variable (p) in\nlemma ramificationIdx_map_eq [Algebra R S] {E : Type*} [EquivLike E S S₁] [AlgEquivClass E R S S₁]\n    (P : Ideal S) (e : E) :\n    ramificationIdx (algebraMap R S₁) p (P.map e) = ramificationIdx (algebraMap R S) p P := by\n  rw [show P.map e = _ from P.map_comap_of_equiv (e : S ≃+* S₁)]\n  exact p.ramificationIdx_comap_eq (e : S ≃ₐ[R] S₁).symm P\n\n"}
{"name":"Ideal.IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nS : Type v\ninst✝² : CommRing S\nf : RingHom R S\np : Ideal R\nP : Ideal S\ninst✝¹ : IsDedekindDomain S\ninst✝ : DecidableEq (Ideal S)\nhp0 : Ne (Ideal.map f p) Bot.bot\nhP : P.IsPrime\nhP0 : Ne P Bot.bot\n⊢ Eq (Ideal.ramificationIdx f p P) (Multiset.count P (UniqueFactorizationMonoid.normalizedFactors (Ideal.map f p)))","decl":"theorem ramificationIdx_eq_normalizedFactors_count [DecidableEq (Ideal S)]\n    (hp0 : map f p ≠ ⊥) (hP : P.IsPrime)\n    (hP0 : P ≠ ⊥) : ramificationIdx f p P = (normalizedFactors (map f p)).count P := by\n  have hPirr := (Ideal.prime_of_isPrime hP0 hP).irreducible\n  refine ramificationIdx_spec (Ideal.le_of_dvd ?_) (mt Ideal.dvd_iff_le.mpr ?_) <;>\n    rw [dvd_iff_normalizedFactors_le_normalizedFactors (pow_ne_zero _ hP0) hp0,\n      normalizedFactors_pow, normalizedFactors_irreducible hPirr, normalize_eq,\n      Multiset.nsmul_singleton, ← Multiset.le_count_iff_replicate_le]\n  exact (Nat.lt_succ_self _).not_le\n\n"}
{"name":"Ideal.IsDedekindDomain.ramificationIdx_eq_factors_count","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nS : Type v\ninst✝² : CommRing S\nf : RingHom R S\np : Ideal R\nP : Ideal S\ninst✝¹ : IsDedekindDomain S\ninst✝ : DecidableEq (Ideal S)\nhp0 : Ne (Ideal.map f p) Bot.bot\nhP : P.IsPrime\nhP0 : Ne P Bot.bot\n⊢ Eq (Ideal.ramificationIdx f p P) (Multiset.count P (UniqueFactorizationMonoid.factors (Ideal.map f p)))","decl":"theorem ramificationIdx_eq_factors_count [DecidableEq (Ideal S)]\n    (hp0 : map f p ≠ ⊥) (hP : P.IsPrime) (hP0 : P ≠ ⊥) :\n    ramificationIdx f p P = (factors (map f p)).count P := by\n  rw [IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hp0 hP hP0,\n    factors_eq_normalizedFactors]\n\n"}
{"name":"Ideal.IsDedekindDomain.ramificationIdx_ne_zero","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nS : Type v\ninst✝¹ : CommRing S\nf : RingHom R S\np : Ideal R\nP : Ideal S\ninst✝ : IsDedekindDomain S\nhp0 : Ne (Ideal.map f p) Bot.bot\nhP : P.IsPrime\nle : LE.le (Ideal.map f p) P\n⊢ Ne (Ideal.ramificationIdx f p P) 0","decl":"theorem ramificationIdx_ne_zero (hp0 : map f p ≠ ⊥) (hP : P.IsPrime) (le : map f p ≤ P) :\n    ramificationIdx f p P ≠ 0 := by\n  classical\n  have hP0 : P ≠ ⊥ := by\n    rintro rfl\n    exact hp0 (le_bot_iff.mp le)\n  have hPirr := (Ideal.prime_of_isPrime hP0 hP).irreducible\n  rw [IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hp0 hP hP0]\n  obtain ⟨P', hP', P'_eq⟩ :=\n    exists_mem_normalizedFactors_of_dvd hp0 hPirr (Ideal.dvd_iff_le.mpr le)\n  rwa [Multiset.count_ne_zero, associated_iff_eq.mp P'_eq]\n\n"}
{"name":"Ideal.inertiaDeg_of_subsingleton","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nS : Type v\ninst✝¹ : CommRing S\np : Ideal R\nP : Ideal S\ninst✝ : Algebra R S\nhp : p.IsMaximal\nhQ : Subsingleton (HasQuotient.Quotient S P)\n⊢ Eq (p.inertiaDeg P) 0","decl":"@[simp]\ntheorem inertiaDeg_of_subsingleton [hp : p.IsMaximal] [hQ : Subsingleton (S ⧸ P)] :\n    inertiaDeg p P = 0 := by\n  have := Ideal.Quotient.subsingleton_iff.mp hQ\n  subst this\n  exact dif_neg fun h => hp.ne_top <| h.symm.trans comap_top\n\n"}
{"name":"Ideal.inertiaDeg_algebraMap","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nS : Type v\ninst✝³ : CommRing S\np : Ideal R\nP : Ideal S\ninst✝² : Algebra R S\ninst✝¹ : P.LiesOver p\ninst✝ : p.IsMaximal\n⊢ Eq (p.inertiaDeg P) (Module.finrank (HasQuotient.Quotient R p) (HasQuotient.Quotient S P))","decl":"@[simp]\ntheorem inertiaDeg_algebraMap [P.LiesOver p] [p.IsMaximal] :\n    inertiaDeg p P = finrank (R ⧸ p) (S ⧸ P) := by\n  nontriviality S ⧸ P using inertiaDeg_of_subsingleton, finrank_zero_of_subsingleton\n  rw [inertiaDeg, dif_pos (over_def P p).symm]\n\n"}
{"name":"Ideal.inertiaDeg_pos","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nS : Type v\ninst✝⁴ : CommRing S\np : Ideal R\nP : Ideal S\ninst✝³ : Algebra R S\ninst✝² : p.IsMaximal\ninst✝¹ : Module.Finite R S\ninst✝ : P.LiesOver p\n⊢ LT.lt 0 (p.inertiaDeg P)","decl":"theorem inertiaDeg_pos [p.IsMaximal] [Module.Finite R S]\n    [P.LiesOver p] : 0 < inertiaDeg p P :=\n  haveI : Nontrivial (S ⧸ P) := Quotient.nontrivial_of_liesOver_of_isPrime P p\n  finrank_pos.trans_eq (inertiaDeg_algebraMap p P).symm\n\n"}
{"name":"Ideal.inertiaDeg_comap_eq","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nS : Type v\ninst✝⁴ : CommRing S\np : Ideal R\nS₁ : Type u_1\ninst✝³ : CommRing S₁\ninst✝² : Algebra R S₁\ninst✝¹ : Algebra R S\ne : AlgEquiv R S S₁\nP : Ideal S₁\ninst✝ : p.IsMaximal\n⊢ Eq (p.inertiaDeg (Ideal.comap e P)) (p.inertiaDeg P)","decl":"lemma inertiaDeg_comap_eq (e : S ≃ₐ[R] S₁) (P : Ideal S₁) [p.IsMaximal] :\n    inertiaDeg p (P.comap e) = inertiaDeg p P := by\n  have he : (P.comap e).comap (algebraMap R S) = p ↔ P.comap (algebraMap R S₁) = p := by\n    rw [← comap_coe e, comap_comap, ← e.toAlgHom_toRingHom, AlgHom.comp_algebraMap]\n  by_cases h : P.LiesOver p\n  · rw [inertiaDeg_algebraMap, inertiaDeg_algebraMap]\n    exact (Quotient.algEquivOfEqComap p e rfl).toLinearEquiv.finrank_eq\n  · rw [inertiaDeg, dif_neg (fun eq => h ⟨(he.mp eq).symm⟩)]\n    rw [inertiaDeg, dif_neg (fun eq => h ⟨eq.symm⟩)]\n\n"}
{"name":"Ideal.inertiaDeg_map_eq","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁷ : CommRing R\nS : Type v\ninst✝⁶ : CommRing S\np : Ideal R\nS₁ : Type u_1\ninst✝⁵ : CommRing S₁\ninst✝⁴ : Algebra R S₁\ninst✝³ : Algebra R S\ninst✝² : p.IsMaximal\nP : Ideal S\nE : Type u_2\ninst✝¹ : EquivLike E S S₁\ninst✝ : AlgEquivClass E R S S₁\ne : E\n⊢ Eq (p.inertiaDeg (Ideal.map e P)) (p.inertiaDeg P)","decl":"lemma inertiaDeg_map_eq [p.IsMaximal] (P : Ideal S)\n    {E : Type*} [EquivLike E S S₁] [AlgEquivClass E R S S₁] (e : E) :\n    inertiaDeg p (P.map e) = inertiaDeg p P := by\n  rw [show P.map e = _ from map_comap_of_equiv (e : S ≃+* S₁)]\n  exact p.inertiaDeg_comap_eq (e : S ≃ₐ[R] S₁).symm P\n\n"}
{"name":"Ideal.FinrankQuotientMap.span_eq_top","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹⁶ : CommRing R\nS : Type v\ninst✝¹⁵ : CommRing S\np : Ideal R\ninst✝¹⁴ : Algebra R S\nK : Type u_1\ninst✝¹³ : Field K\ninst✝¹² : Algebra R K\nL : Type u_2\ninst✝¹¹ : Field L\ninst✝¹⁰ : Algebra S L\ninst✝⁹ : IsFractionRing S L\ninst✝⁸ : IsDomain R\ninst✝⁷ : IsDomain S\ninst✝⁶ : Algebra K L\ninst✝⁵ : Module.Finite R S\ninst✝⁴ : Algebra R L\ninst✝³ : IsScalarTower R S L\ninst✝² : IsScalarTower R K L\ninst✝¹ : Algebra.IsAlgebraic R S\ninst✝ : NoZeroSMulDivisors R K\nhp : Ne p Top.top\nb : Set S\nhb' : Eq (Max.max (Submodule.span R b) (Submodule.restrictScalars R (Ideal.map (algebraMap R S) p))) Top.top\n⊢ Eq (Submodule.span K (Set.image (⇑(algebraMap S L)) b)) Top.top","decl":"/-- If `b` mod `p` spans `S/p` as `R/p`-space, then `b` itself spans `Frac(S)` as `K`-space.\n\nHere,\n * `p` is an ideal of `R` such that `R / p` is nontrivial\n * `K` is a field that has an embedding of `R` (in particular we can take `K = Frac(R)`)\n * `L` is a field extension of `K`\n * `S` is the integral closure of `R` in `L`\n\nMore precisely, we avoid quotients in this statement and instead require that `b ∪ pS` spans `S`.\n-/\ntheorem FinrankQuotientMap.span_eq_top [IsDomain R] [IsDomain S] [Algebra K L] [Module.Finite R S]\n    [Algebra R L] [IsScalarTower R S L] [IsScalarTower R K L] [Algebra.IsAlgebraic R S]\n    [NoZeroSMulDivisors R K] (hp : p ≠ ⊤) (b : Set S)\n    (hb' : Submodule.span R b ⊔ (p.map (algebraMap R S)).restrictScalars R = ⊤) :\n    Submodule.span K (algebraMap S L '' b) = ⊤ := by\n  have hRL : Function.Injective (algebraMap R L) := by\n    rw [IsScalarTower.algebraMap_eq R K L]\n    exact (algebraMap K L).injective.comp (NoZeroSMulDivisors.algebraMap_injective R K)\n  -- Let `M` be the `R`-module spanned by the proposed basis elements.\n  let M : Submodule R S := Submodule.span R b\n  -- Then `S / M` is generated by some finite set of `n` vectors `a`.\n  obtain ⟨n, a, ha⟩ := @Module.Finite.exists_fin R (S ⧸ M) _ _ _ _\n  -- Because the image of `p` in `S / M` is `⊤`,\n  have smul_top_eq : p • (⊤ : Submodule R (S ⧸ M)) = ⊤ := by\n    calc\n      p • ⊤ = Submodule.map M.mkQ (p • ⊤) := by\n        rw [Submodule.map_smul'', Submodule.map_top, M.range_mkQ]\n      _ = ⊤ := by rw [Ideal.smul_top_eq_map, (Submodule.map_mkQ_eq_top M _).mpr hb']\n  -- we can write the elements of `a` as `p`-linear combinations of other elements of `a`.\n  have exists_sum : ∀ x : S ⧸ M, ∃ a' : Fin n → R, (∀ i, a' i ∈ p) ∧ ∑ i, a' i • a i = x := by\n    intro x\n    obtain ⟨a'', ha'', hx⟩ := (Submodule.mem_ideal_smul_span_iff_exists_sum p a x).1\n      (by { rw [ha, smul_top_eq]; exact Submodule.mem_top } :\n        x ∈ p • Submodule.span R (Set.range a))\n    · refine ⟨fun i => a'' i, fun i => ha'' _, ?_⟩\n      rw [← hx, Finsupp.sum_fintype]\n      exact fun _ => zero_smul _ _\n  choose A' hA'p hA' using fun i => exists_sum (a i)\n  -- This gives us a(n invertible) matrix `A` such that `det A ∈ (M = span R b)`,\n  let A : Matrix (Fin n) (Fin n) R := Matrix.of A' - 1\n  let B := A.adjugate\n  have A_smul : ∀ i, ∑ j, A i j • a j = 0 := by\n    intros\n    simp [A, Matrix.sub_apply, Matrix.of_apply, ne_eq, Matrix.one_apply, sub_smul,\n      Finset.sum_sub_distrib, hA', sub_self]\n  -- since `span S {det A} / M = 0`.\n  have d_smul : ∀ i, A.det • a i = 0 := by\n    intro i\n    calc\n      A.det • a i = ∑ j, (B * A) i j • a j := ?_\n      _ = ∑ k, B i k • ∑ j, A k j • a j := ?_\n      _ = 0 := Finset.sum_eq_zero fun k _ => ?_\n    · simp only [B, Matrix.adjugate_mul, Matrix.smul_apply, Matrix.one_apply, smul_eq_mul, ite_true,\n        mul_ite, mul_one, mul_zero, ite_smul, zero_smul, Finset.sum_ite_eq, Finset.mem_univ]\n    · simp only [Matrix.mul_apply, Finset.smul_sum, Finset.sum_smul, smul_smul]\n      rw [Finset.sum_comm]\n    · rw [A_smul, smul_zero]\n  -- In the rings of integers we have the desired inclusion.\n  have span_d : (Submodule.span S ({algebraMap R S A.det} : Set S)).restrictScalars R ≤ M := by\n    intro x hx\n    rw [Submodule.restrictScalars_mem] at hx\n    obtain ⟨x', rfl⟩ := Submodule.mem_span_singleton.mp hx\n    rw [smul_eq_mul, mul_comm, ← Algebra.smul_def] at hx ⊢\n    rw [← Submodule.Quotient.mk_eq_zero, Submodule.Quotient.mk_smul]\n    obtain ⟨a', _, quot_x_eq⟩ := exists_sum (Submodule.Quotient.mk x')\n    rw [← quot_x_eq, Finset.smul_sum]\n    conv =>\n      lhs; congr; next => skip\n      intro x; rw [smul_comm A.det, d_smul, smul_zero]\n    exact Finset.sum_const_zero\n  refine top_le_iff.mp\n      (calc\n        ⊤ = (Ideal.span {algebraMap R L A.det}).restrictScalars K := ?_\n        _ ≤ Submodule.span K (algebraMap S L '' b) := ?_)\n  -- Because `det A ≠ 0`, we have `span L {det A} = ⊤`.\n  · rw [eq_comm, Submodule.restrictScalars_eq_top_iff, Ideal.span_singleton_eq_top]\n    refine IsUnit.mk0 _ ((map_ne_zero_iff (algebraMap R L) hRL).mpr ?_)\n    refine ne_zero_of_map (f := Ideal.Quotient.mk p) ?_\n    haveI := Ideal.Quotient.nontrivial hp\n    calc\n      Ideal.Quotient.mk p A.det = Matrix.det ((Ideal.Quotient.mk p).mapMatrix A) := by\n        rw [RingHom.map_det]\n      _ = Matrix.det ((Ideal.Quotient.mk p).mapMatrix (Matrix.of A' - 1)) := rfl\n      _ = Matrix.det fun i j =>\n          (Ideal.Quotient.mk p) (A' i j) - (1 : Matrix (Fin n) (Fin n) (R ⧸ p)) i j := ?_\n      _ = Matrix.det (-1 : Matrix (Fin n) (Fin n) (R ⧸ p)) := ?_\n      _ = (-1 : R ⧸ p) ^ n := by rw [Matrix.det_neg, Fintype.card_fin, Matrix.det_one, mul_one]\n      _ ≠ 0 := IsUnit.ne_zero (isUnit_one.neg.pow _)\n    · refine congr_arg Matrix.det (Matrix.ext fun i j => ?_)\n      rw [map_sub, RingHom.mapMatrix_apply, map_one]\n      rfl\n    · refine congr_arg Matrix.det (Matrix.ext fun i j => ?_)\n      rw [Ideal.Quotient.eq_zero_iff_mem.mpr (hA'p i j), zero_sub]\n      rfl\n  -- And we conclude `L = span L {det A} ≤ span K b`, so `span K b` spans everything.\n  · intro x hx\n    rw [Submodule.restrictScalars_mem, IsScalarTower.algebraMap_apply R S L] at hx\n    exact IsFractionRing.ideal_span_singleton_map_subset R hRL span_d hx\n\n"}
{"name":"Ideal.FinrankQuotientMap.linearIndependent_of_nontrivial","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹⁵ : CommRing R\nS : Type v\ninst✝¹⁴ : CommRing S\ninst✝¹³ : Algebra R S\nK : Type u_1\ninst✝¹² : Field K\ninst✝¹¹ : Algebra R K\nV : Type u_3\nV' : Type u_4\nV'' : Type u_5\ninst✝¹⁰ : AddCommGroup V\ninst✝⁹ : Module R V\ninst✝⁸ : Module K V\ninst✝⁷ : IsScalarTower R K V\ninst✝⁶ : AddCommGroup V'\ninst✝⁵ : Module R V'\ninst✝⁴ : Module S V'\ninst✝³ : IsScalarTower R S V'\ninst✝² : AddCommGroup V''\ninst✝¹ : Module R V''\nhRK : IsFractionRing R K\ninst✝ : IsDedekindDomain R\nhRS : Ne (RingHom.ker (algebraMap R S)) Top.top\nf : LinearMap (RingHom.id R) V'' V\nhf : Function.Injective ⇑f\nf' : LinearMap (RingHom.id R) V'' V'\nι : Type u_6\nb : ι → V''\nhb' : LinearIndependent S (Function.comp (⇑f') b)\n⊢ LinearIndependent K (Function.comp (⇑f) b)","decl":"/-- Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\n\nThe statement we prove is actually slightly more general:\n * it suffices that the inclusion `algebraMap R S : R → S` is nontrivial\n * the function `f' : V'' → V'` doesn't need to be injective\n-/\ntheorem FinrankQuotientMap.linearIndependent_of_nontrivial [IsDedekindDomain R]\n    (hRS : RingHom.ker (algebraMap R S) ≠ ⊤) (f : V'' →ₗ[R] V) (hf : Function.Injective f)\n    (f' : V'' →ₗ[R] V') {ι : Type*} {b : ι → V''} (hb' : LinearIndependent S (f' ∘ b)) :\n    LinearIndependent K (f ∘ b) := by\n  contrapose! hb' with hb\n  -- Informally, if we have a nontrivial linear dependence with coefficients `g` in `K`,\n  -- then we can find a linear dependence with coefficients `I.Quotient.mk g'` in `R/I`,\n  -- where `I = ker (algebraMap R S)`.\n  -- We make use of the same principle but stay in `R` everywhere.\n  simp only [linearIndependent_iff', not_forall] at hb ⊢\n  obtain ⟨s, g, eq, j', hj's, hj'g⟩ := hb\n  use s\n  obtain ⟨a, hag, j, hjs, hgI⟩ := Ideal.exist_integer_multiples_not_mem hRS s g hj's hj'g\n  choose g'' hg'' using hag\n  letI := Classical.propDecidable\n  let g' i := if h : i ∈ s then g'' i h else 0\n  have hg' : ∀ i ∈ s, algebraMap _ _ (g' i) = a * g i := by\n    intro i hi; exact (congr_arg _ (dif_pos hi)).trans (hg'' i hi)\n  -- Because `R/I` is nontrivial, we can lift `g` to a nontrivial linear dependence in `S`.\n  have hgI : algebraMap R S (g' j) ≠ 0 := by\n    simp only [FractionalIdeal.mem_coeIdeal, not_exists, not_and'] at hgI\n    exact hgI _ (hg' j hjs)\n  refine ⟨fun i => algebraMap R S (g' i), ?_, j, hjs, hgI⟩\n  have eq : f (∑ i ∈ s, g' i • b i) = 0 := by\n    rw [map_sum, ← smul_zero a, ← eq, Finset.smul_sum]\n    refine Finset.sum_congr rfl ?_\n    intro i hi\n    rw [LinearMap.map_smul, ← IsScalarTower.algebraMap_smul K, hg' i hi, ← smul_assoc,\n      smul_eq_mul, Function.comp_apply]\n  simp only [IsScalarTower.algebraMap_smul, ← map_smul, ← map_sum,\n    (f.map_eq_zero_iff hf).mp eq, LinearMap.map_zero, (· ∘ ·)]\n\n"}
{"name":"Ideal.finrank_quotient_map","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹⁴ : CommRing R\nS : Type v\ninst✝¹³ : CommRing S\np : Ideal R\ninst✝¹² : Algebra R S\nK : Type u_1\ninst✝¹¹ : Field K\ninst✝¹⁰ : Algebra R K\nL : Type u_2\ninst✝⁹ : Field L\ninst✝⁸ : Algebra S L\ninst✝⁷ : IsFractionRing S L\nhRK : IsFractionRing R K\ninst✝⁶ : IsDomain S\ninst✝⁵ : IsDedekindDomain R\ninst✝⁴ : Algebra K L\ninst✝³ : Algebra R L\ninst✝² : IsScalarTower R K L\ninst✝¹ : IsScalarTower R S L\nhp : p.IsMaximal\ninst✝ : Module.Finite R S\n⊢ Eq (Module.finrank (HasQuotient.Quotient R p) (HasQuotient.Quotient S (Ideal.map (algebraMap R S) p))) (Module.finrank K L)","decl":"/-- If `p` is a maximal ideal of `R`, and `S` is the integral closure of `R` in `L`,\nthen the dimension `[S/pS : R/p]` is equal to `[Frac(S) : Frac(R)]`. -/\ntheorem finrank_quotient_map [IsDomain S] [IsDedekindDomain R] [Algebra K L]\n    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L]\n    [hp : p.IsMaximal] [Module.Finite R S] :\n    finrank (R ⧸ p) (S ⧸ map (algebraMap R S) p) = finrank K L := by\n  -- Choose an arbitrary basis `b` for `[S/pS : R/p]`.\n  -- We'll use the previous results to turn it into a basis on `[Frac(S) : Frac(R)]`.\n  let ι := Module.Free.ChooseBasisIndex (R ⧸ p) (S ⧸ map (algebraMap R S) p)\n  let b : Basis ι (R ⧸ p) (S ⧸ map (algebraMap R S) p) := Module.Free.chooseBasis _ _\n  -- Namely, choose a representative `b' i : S` for each `b i : S / pS`.\n  let b' : ι → S := fun i => (Ideal.Quotient.mk_surjective (b i)).choose\n  have b_eq_b' : ⇑b = (Submodule.mkQ (map (algebraMap R S) p)).restrictScalars R ∘ b' :=\n    funext fun i => (Ideal.Quotient.mk_surjective (b i)).choose_spec.symm\n  -- We claim `b'` is a basis for `Frac(S)` over `Frac(R)` because it is linear independent\n  -- and spans the whole of `Frac(S)`.\n  let b'' : ι → L := algebraMap S L ∘ b'\n  have b''_li : LinearIndependent K b'' := ?_\n  · have b''_sp : Submodule.span K (Set.range b'') = ⊤ := ?_\n    -- Since the two bases have the same index set, the spaces have the same dimension.\n    · let c : Basis ι K L := Basis.mk b''_li b''_sp.ge\n      rw [finrank_eq_card_basis b, finrank_eq_card_basis c]\n    -- It remains to show that the basis is indeed linear independent and spans the whole space.\n    · rw [Set.range_comp]\n      refine FinrankQuotientMap.span_eq_top p hp.ne_top _ (top_le_iff.mp ?_)\n      -- The nicest way to show `S ≤ span b' ⊔ pS` is by reducing both sides modulo pS.\n      -- However, this would imply distinguishing between `pS` as `S`-ideal,\n      -- and `pS` as `R`-submodule, since they have different (non-defeq) quotients.\n      -- Instead we'll lift `x mod pS ∈ span b` to `y ∈ span b'` for some `y - x ∈ pS`.\n      intro x _\n      have mem_span_b : ((Submodule.mkQ (map (algebraMap R S) p)) x : S ⧸ map (algebraMap R S) p) ∈\n          Submodule.span (R ⧸ p) (Set.range b) := b.mem_span _\n      rw [← @Submodule.restrictScalars_mem R,\n        Submodule.restrictScalars_span R (R ⧸ p) Ideal.Quotient.mk_surjective, b_eq_b',\n        Set.range_comp, ← Submodule.map_span] at mem_span_b\n      obtain ⟨y, y_mem, y_eq⟩ := Submodule.mem_map.mp mem_span_b\n      suffices y + -(y - x) ∈ _ by simpa\n      rw [LinearMap.restrictScalars_apply, Submodule.mkQ_apply, Submodule.mkQ_apply,\n        Submodule.Quotient.eq] at y_eq\n      exact add_mem (Submodule.mem_sup_left y_mem) (neg_mem <| Submodule.mem_sup_right y_eq)\n  · have := b.linearIndependent; rw [b_eq_b'] at this\n    convert FinrankQuotientMap.linearIndependent_of_nontrivial K _\n        ((Algebra.linearMap S L).restrictScalars R) _ ((Submodule.mkQ _).restrictScalars R) this\n    · rw [Quotient.algebraMap_eq, Ideal.mk_ker]\n      exact hp.ne_top\n    · exact IsFractionRing.injective S L\n\n"}
{"name":"Ideal.Quotient.algebraMap_quotient_pow_ramificationIdx","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nS : Type v\ninst✝¹ : CommRing S\np : Ideal R\nP : Ideal S\ninst✝ : Algebra R S\nx : R\n⊢ Eq ((algebraMap (HasQuotient.Quotient R p) (HasQuotient.Quotient S (HPow.hPow P (Ideal.ramificationIdx (algebraMap R S) p P)))) ((Ideal.Quotient.mk p) x)) ((Ideal.Quotient.mk (HPow.hPow P (Ideal.ramificationIdx (algebraMap R S) p P))) ((algebraMap R S) x))","decl":"@[simp]\ntheorem Quotient.algebraMap_quotient_pow_ramificationIdx (x : R) :\n    algebraMap (R ⧸ p) (S ⧸ P ^ e) (Ideal.Quotient.mk p x) = Ideal.Quotient.mk (P ^ e) (f x) := rfl\n\n"}
{"name":"Ideal.Quotient.algebraMap_quotient_of_ramificationIdx_neZero","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nS : Type v\ninst✝² : CommRing S\np : Ideal R\nP : Ideal S\ninst✝¹ : Algebra R S\ninst✝ : NeZero (Ideal.ramificationIdx (algebraMap R S) p P)\nx : R\n⊢ Eq ((algebraMap (HasQuotient.Quotient R p) (HasQuotient.Quotient S P)) ((Ideal.Quotient.mk p) x)) ((Ideal.Quotient.mk P) ((algebraMap R S) x))","decl":"@[simp]\ntheorem Quotient.algebraMap_quotient_of_ramificationIdx_neZero\n    [NeZero e] (x : R) :\n    algebraMap (R ⧸ p) (S ⧸ P) (Ideal.Quotient.mk p x) = Ideal.Quotient.mk P (f x) := rfl\n\n"}
{"name":"Ideal.powQuotSuccInclusion_apply_coe","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nS : Type v\ninst✝¹ : CommRing S\np : Ideal R\nP : Ideal S\ninst✝ : Algebra R S\ni : Nat\nx : Subtype fun x => Membership.mem (Ideal.map (Ideal.Quotient.mk (HPow.hPow P (Ideal.ramificationIdx (algebraMap R S) p P))) (HPow.hPow P (HAdd.hAdd i 1))) x\n⊢ Eq ↑((p.powQuotSuccInclusion P i) x) ↑x","decl":"/-- The inclusion `(P^(i + 1) / P^e) ⊂ (P^i / P^e)`. -/\n@[simps]\ndef powQuotSuccInclusion (i : ℕ) :\n    Ideal.map (Ideal.Quotient.mk (P ^ e)) (P ^ (i + 1)) →ₗ[R ⧸ p]\n    Ideal.map (Ideal.Quotient.mk (P ^ e)) (P ^ i) where\n  toFun x := ⟨x, Ideal.map_mono (Ideal.pow_le_pow_right i.le_succ) x.2⟩\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"Ideal.powQuotSuccInclusion_injective","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nS : Type v\ninst✝¹ : CommRing S\np : Ideal R\nP : Ideal S\ninst✝ : Algebra R S\ni : Nat\n⊢ Function.Injective ⇑(p.powQuotSuccInclusion P i)","decl":"theorem powQuotSuccInclusion_injective (i : ℕ) :\n    Function.Injective (powQuotSuccInclusion p P i) := by\n  rw [← LinearMap.ker_eq_bot, LinearMap.ker_eq_bot']\n  rintro ⟨x, hx⟩ hx0\n  rw [Subtype.ext_iff] at hx0 ⊢\n  rwa [powQuotSuccInclusion_apply_coe] at hx0\n\n"}
{"name":"Ideal.quotientToQuotientRangePowQuotSuccAux_mk","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nS : Type v\ninst✝¹ : CommRing S\np : Ideal R\nP : Ideal S\ninst✝ : Algebra R S\ni : Nat\na : S\na_mem : Membership.mem (HPow.hPow P i) a\nx : S\n⊢ Eq (p.quotientToQuotientRangePowQuotSuccAux P a_mem (Submodule.Quotient.mk x)) (Submodule.Quotient.mk ⟨(Ideal.Quotient.mk (HPow.hPow P (Ideal.ramificationIdx (algebraMap R S) p P))) (HMul.hMul a x), ⋯⟩)","decl":"theorem quotientToQuotientRangePowQuotSuccAux_mk {i : ℕ} {a : S} (a_mem : a ∈ P ^ i) (x : S) :\n    quotientToQuotientRangePowQuotSuccAux p P a_mem (Submodule.Quotient.mk x) =\n      Submodule.Quotient.mk ⟨_, Ideal.mem_map_of_mem _ (Ideal.mul_mem_right x _ a_mem)⟩ := by\n  apply Quotient.map'_mk''\n\n"}
{"name":"Ideal.quotientToQuotientRangePowQuotSucc_mk","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nS : Type v\ninst✝¹ : CommRing S\np : Ideal R\nP : Ideal S\ninst✝ : Algebra R S\nhfp : NeZero (Ideal.ramificationIdx (algebraMap R S) p P)\ni : Nat\na : S\na_mem : Membership.mem (HPow.hPow P i) a\nx : S\n⊢ Eq ((p.quotientToQuotientRangePowQuotSucc P a_mem) (Submodule.Quotient.mk x)) (Submodule.Quotient.mk ⟨(Ideal.Quotient.mk (HPow.hPow P (Ideal.ramificationIdx (algebraMap R S) p P))) (HMul.hMul a x), ⋯⟩)","decl":"theorem quotientToQuotientRangePowQuotSucc_mk {i : ℕ} {a : S} (a_mem : a ∈ P ^ i) (x : S) :\n    quotientToQuotientRangePowQuotSucc p P a_mem (Submodule.Quotient.mk x) =\n      Submodule.Quotient.mk ⟨_, Ideal.mem_map_of_mem _ (Ideal.mul_mem_right x _ a_mem)⟩ :=\n  quotientToQuotientRangePowQuotSuccAux_mk p P a_mem x\n\n"}
{"name":"Ideal.quotientToQuotientRangePowQuotSucc_injective","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nS : Type v\ninst✝³ : CommRing S\np : Ideal R\nP : Ideal S\ninst✝² : Algebra R S\nhfp : NeZero (Ideal.ramificationIdx (algebraMap R S) p P)\ninst✝¹ : IsDedekindDomain S\ninst✝ : P.IsPrime\ni : Nat\nhi : LT.lt i (Ideal.ramificationIdx (algebraMap R S) p P)\na : S\na_mem : Membership.mem (HPow.hPow P i) a\na_not_mem : Not (Membership.mem (HPow.hPow P (HAdd.hAdd i 1)) a)\n⊢ Function.Injective ⇑(p.quotientToQuotientRangePowQuotSucc P a_mem)","decl":"theorem quotientToQuotientRangePowQuotSucc_injective [IsDedekindDomain S] [P.IsPrime]\n    {i : ℕ} (hi : i < e) {a : S} (a_mem : a ∈ P ^ i) (a_not_mem : a ∉ P ^ (i + 1)) :\n    Function.Injective (quotientToQuotientRangePowQuotSucc p P a_mem) := fun x =>\n  Quotient.inductionOn' x fun x y =>\n    Quotient.inductionOn' y fun y h => by\n      have Pe_le_Pi1 : P ^ e ≤ P ^ (i + 1) := Ideal.pow_le_pow_right hi\n      simp only [Submodule.Quotient.mk''_eq_mk, quotientToQuotientRangePowQuotSucc_mk,\n        Submodule.Quotient.eq, LinearMap.mem_range, Subtype.ext_iff, Subtype.coe_mk,\n        Submodule.coe_sub] at h ⊢\n      rcases h with ⟨⟨⟨z⟩, hz⟩, h⟩\n      rw [Submodule.Quotient.quot_mk_eq_mk, Ideal.Quotient.mk_eq_mk, Ideal.mem_quotient_iff_mem_sup,\n        sup_eq_left.mpr Pe_le_Pi1] at hz\n      rw [powQuotSuccInclusion_apply_coe, Subtype.coe_mk, Submodule.Quotient.quot_mk_eq_mk,\n        Ideal.Quotient.mk_eq_mk, ← map_sub, Ideal.Quotient.eq, ← mul_sub] at h\n      exact\n        (Ideal.IsPrime.mem_pow_mul _\n              ((Submodule.sub_mem_iff_right _ hz).mp (Pe_le_Pi1 h))).resolve_left\n          a_not_mem\n\n"}
{"name":"Ideal.quotientToQuotientRangePowQuotSucc_surjective","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nS : Type v\ninst✝² : CommRing S\np : Ideal R\nP : Ideal S\ninst✝¹ : Algebra R S\nhfp : NeZero (Ideal.ramificationIdx (algebraMap R S) p P)\ninst✝ : IsDedekindDomain S\nhP0 : Ne P Bot.bot\nhP : P.IsPrime\ni : Nat\nhi : LT.lt i (Ideal.ramificationIdx (algebraMap R S) p P)\na : S\na_mem : Membership.mem (HPow.hPow P i) a\na_not_mem : Not (Membership.mem (HPow.hPow P (HAdd.hAdd i 1)) a)\n⊢ Function.Surjective ⇑(p.quotientToQuotientRangePowQuotSucc P a_mem)","decl":"theorem quotientToQuotientRangePowQuotSucc_surjective [IsDedekindDomain S]\n    (hP0 : P ≠ ⊥) [hP : P.IsPrime] {i : ℕ} (hi : i < e) {a : S} (a_mem : a ∈ P ^ i)\n    (a_not_mem : a ∉ P ^ (i + 1)) :\n    Function.Surjective (quotientToQuotientRangePowQuotSucc p P a_mem) := by\n  rintro ⟨⟨⟨x⟩, hx⟩⟩\n  have Pe_le_Pi : P ^ e ≤ P ^ i := Ideal.pow_le_pow_right hi.le\n  rw [Submodule.Quotient.quot_mk_eq_mk, Ideal.Quotient.mk_eq_mk, Ideal.mem_quotient_iff_mem_sup,\n    sup_eq_left.mpr Pe_le_Pi] at hx\n  suffices hx' : x ∈ Ideal.span {a} ⊔ P ^ (i + 1) by\n    obtain ⟨y', hy', z, hz, rfl⟩ := Submodule.mem_sup.mp hx'\n    obtain ⟨y, rfl⟩ := Ideal.mem_span_singleton.mp hy'\n    refine ⟨Submodule.Quotient.mk y, ?_⟩\n    simp only [Submodule.Quotient.quot_mk_eq_mk, quotientToQuotientRangePowQuotSucc_mk,\n      Submodule.Quotient.eq, LinearMap.mem_range, Subtype.ext_iff, Subtype.coe_mk,\n      Submodule.coe_sub]\n    refine ⟨⟨_, Ideal.mem_map_of_mem _ (Submodule.neg_mem _ hz)⟩, ?_⟩\n    rw [powQuotSuccInclusion_apply_coe, Subtype.coe_mk, Ideal.Quotient.mk_eq_mk, map_add,\n      sub_add_cancel_left, map_neg]\n  letI := Classical.decEq (Ideal S)\n  rw [sup_eq_prod_inf_factors _ (pow_ne_zero _ hP0), normalizedFactors_pow,\n    normalizedFactors_irreducible ((Ideal.prime_iff_isPrime hP0).mpr hP).irreducible, normalize_eq,\n    Multiset.nsmul_singleton, Multiset.inter_replicate, Multiset.prod_replicate]\n  · rw [← Submodule.span_singleton_le_iff_mem, Ideal.submodule_span_eq] at a_mem a_not_mem\n    rwa [Ideal.count_normalizedFactors_eq a_mem a_not_mem, min_eq_left i.le_succ]\n  · intro ha\n    rw [Ideal.span_singleton_eq_bot.mp ha] at a_not_mem\n    have := (P ^ (i + 1)).zero_mem\n    contradiction\n\n"}
{"name":"Ideal.rank_pow_quot_aux","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nS : Type v\ninst✝⁴ : CommRing S\np : Ideal R\nP : Ideal S\ninst✝³ : Algebra R S\nhfp : NeZero (Ideal.ramificationIdx (algebraMap R S) p P)\ninst✝² : IsDedekindDomain S\ninst✝¹ : p.IsMaximal\ninst✝ : P.IsPrime\nhP0 : Ne P Bot.bot\ni : Nat\nhi : LT.lt i (Ideal.ramificationIdx (algebraMap R S) p P)\n⊢ Eq (Module.rank (HasQuotient.Quotient R p) (Subtype fun x => Membership.mem (Ideal.map (Ideal.Quotient.mk (HPow.hPow P (Ideal.ramificationIdx (algebraMap R S) p P))) (HPow.hPow P i)) x)) (HAdd.hAdd (Module.rank (HasQuotient.Quotient R p) (HasQuotient.Quotient S P)) (Module.rank (HasQuotient.Quotient R p) (Subtype fun x => Membership.mem (Ideal.map (Ideal.Quotient.mk (HPow.hPow P (Ideal.ramificationIdx (algebraMap R S) p P))) (HPow.hPow P (HAdd.hAdd i 1))) x)))","decl":"/-- Since the inclusion `(P^(i + 1) / P^e) ⊂ (P^i / P^e)` has a kernel isomorphic to `P / S`,\n`[P^i / P^e : R / p] = [P^(i+1) / P^e : R / p] + [P / S : R / p]` -/\ntheorem rank_pow_quot_aux [IsDedekindDomain S] [p.IsMaximal] [P.IsPrime] (hP0 : P ≠ ⊥)\n    {i : ℕ} (hi : i < e) :\n    Module.rank (R ⧸ p) (Ideal.map (Ideal.Quotient.mk (P ^ e)) (P ^ i)) =\n      Module.rank (R ⧸ p) (S ⧸ P) +\n        Module.rank (R ⧸ p) (Ideal.map (Ideal.Quotient.mk (P ^ e)) (P ^ (i + 1))) := by\n  rw [← rank_range_of_injective _ (powQuotSuccInclusion_injective p P i),\n    (quotientRangePowQuotSuccInclusionEquiv p P hP0 hi).symm.rank_eq]\n  exact (Submodule.rank_quotient_add_rank (LinearMap.range (powQuotSuccInclusion p P i))).symm\n\n"}
{"name":"Ideal.rank_pow_quot","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nS : Type v\ninst✝⁴ : CommRing S\np : Ideal R\nP : Ideal S\ninst✝³ : Algebra R S\nhfp : NeZero (Ideal.ramificationIdx (algebraMap R S) p P)\ninst✝² : IsDedekindDomain S\ninst✝¹ : p.IsMaximal\ninst✝ : P.IsPrime\nhP0 : Ne P Bot.bot\ni : Nat\nhi : LE.le i (Ideal.ramificationIdx (algebraMap R S) p P)\n⊢ Eq (Module.rank (HasQuotient.Quotient R p) (Subtype fun x => Membership.mem (Ideal.map (Ideal.Quotient.mk (HPow.hPow P (Ideal.ramificationIdx (algebraMap R S) p P))) (HPow.hPow P i)) x)) (HSMul.hSMul (HSub.hSub (Ideal.ramificationIdx (algebraMap R S) p P) i) (Module.rank (HasQuotient.Quotient R p) (HasQuotient.Quotient S P)))","decl":"theorem rank_pow_quot [IsDedekindDomain S] [p.IsMaximal] [P.IsPrime] (hP0 : P ≠ ⊥)\n    (i : ℕ) (hi : i ≤ e) :\n    Module.rank (R ⧸ p) (Ideal.map (Ideal.Quotient.mk (P ^ e)) (P ^ i)) =\n      (e - i) • Module.rank (R ⧸ p) (S ⧸ P) := by\n-- Porting note: Lean cannot figure out what to prove by itself\n  let Q : ℕ → Prop :=\n    fun i => Module.rank (R ⧸ p) { x // x ∈ map (Quotient.mk (P ^ e)) (P ^ i) }\n      = (e - i) • Module.rank (R ⧸ p) (S ⧸ P)\n  refine Nat.decreasingInduction' (P := Q) (fun j lt_e _le_j ih => ?_) hi ?_\n  · dsimp only [Q]\n    rw [rank_pow_quot_aux p P _ lt_e, ih, ← succ_nsmul', Nat.sub_succ, ← Nat.succ_eq_add_one,\n      Nat.succ_pred_eq_of_pos (Nat.sub_pos_of_lt lt_e)]\n    assumption\n  · dsimp only [Q]\n    rw [Nat.sub_self, zero_nsmul, map_quotient_self]\n    exact rank_bot (R ⧸ p) (S ⧸ P ^ e)\n\n"}
{"name":"Ideal.rank_prime_pow_ramificationIdx","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nS : Type v\ninst✝⁴ : CommRing S\np : Ideal R\nP : Ideal S\ninst✝³ : Algebra R S\ninst✝² : IsDedekindDomain S\ninst✝¹ : p.IsMaximal\ninst✝ : P.IsPrime\nhP0 : Ne P Bot.bot\nhe : Ne (Ideal.ramificationIdx (algebraMap R S) p P) 0\n⊢ Eq (Module.rank (HasQuotient.Quotient R p) (HasQuotient.Quotient S (HPow.hPow P (Ideal.ramificationIdx (algebraMap R S) p P)))) (HSMul.hSMul (Ideal.ramificationIdx (algebraMap R S) p P) (Module.rank (HasQuotient.Quotient R p) (HasQuotient.Quotient S P)))","decl":"/-- If `p` is a maximal ideal of `R`, `S` extends `R` and `P^e` lies over `p`,\nthen the dimension `[S/(P^e) : R/p]` is equal to `e * [S/P : R/p]`. -/\ntheorem rank_prime_pow_ramificationIdx [IsDedekindDomain S] [p.IsMaximal] [P.IsPrime]\n    (hP0 : P ≠ ⊥) (he : e ≠ 0) :\n    Module.rank (R ⧸ p) (S ⧸ P ^ e) =\n      e •\n        @Module.rank (R ⧸ p) (S ⧸ P) _ _\n          (@Algebra.toModule _ _ _ _ <|\n            @Quotient.algebraQuotientOfRamificationIdxNeZero _ _ _ _ _ _ _ ⟨he⟩) := by\n  letI : NeZero e := ⟨he⟩\n  have := rank_pow_quot p P hP0 0 (Nat.zero_le e)\n  rw [pow_zero, Nat.sub_zero, Ideal.one_eq_top, Ideal.map_top] at this\n  exact (rank_top (R ⧸ p) _).symm.trans this\n\n"}
{"name":"Ideal.finrank_prime_pow_ramificationIdx","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nS : Type v\ninst✝⁴ : CommRing S\np : Ideal R\nP : Ideal S\ninst✝³ : Algebra R S\ninst✝² : IsDedekindDomain S\nhP0 : Ne P Bot.bot\ninst✝¹ : p.IsMaximal\ninst✝ : P.IsPrime\nhe : Ne (Ideal.ramificationIdx (algebraMap R S) p P) 0\n⊢ Eq (Module.finrank (HasQuotient.Quotient R p) (HasQuotient.Quotient S (HPow.hPow P (Ideal.ramificationIdx (algebraMap R S) p P)))) (HMul.hMul (Ideal.ramificationIdx (algebraMap R S) p P) (Module.finrank (HasQuotient.Quotient R p) (HasQuotient.Quotient S P)))","decl":"/-- If `p` is a maximal ideal of `R`, `S` extends `R` and `P^e` lies over `p`,\nthen the dimension `[S/(P^e) : R/p]`, as a natural number, is equal to `e * [S/P : R/p]`. -/\ntheorem finrank_prime_pow_ramificationIdx [IsDedekindDomain S] (hP0 : P ≠ ⊥)\n    [p.IsMaximal] [P.IsPrime] (he : e ≠ 0) :\n    finrank (R ⧸ p) (S ⧸ P ^ e) =\n      e *\n        @finrank (R ⧸ p) (S ⧸ P) _ _\n          (@Algebra.toModule _ _ _ _ <|\n            @Quotient.algebraQuotientOfRamificationIdxNeZero _ _ _ _ _ _ _ ⟨he⟩) := by\n  letI : NeZero e := ⟨he⟩\n  letI : Algebra (R ⧸ p) (S ⧸ P) := Quotient.algebraQuotientOfRamificationIdxNeZero p P\n  have hdim := rank_prime_pow_ramificationIdx _ _ hP0 he\n  by_cases hP : FiniteDimensional (R ⧸ p) (S ⧸ P)\n  · haveI := hP\n    haveI := (finiteDimensional_iff_of_rank_eq_nsmul he hdim).mpr hP\n    apply @Nat.cast_injective Cardinal\n    rw [finrank_eq_rank', Nat.cast_mul, finrank_eq_rank', hdim, nsmul_eq_mul]\n  have hPe := mt (finiteDimensional_iff_of_rank_eq_nsmul he hdim).mp hP\n  simp only [finrank_of_infinite_dimensional hP, finrank_of_infinite_dimensional hPe,\n    mul_zero]\n\n"}
{"name":"Ideal.Factors.ne_bot","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nS : Type v\ninst✝² : CommRing S\np : Ideal R\ninst✝¹ : IsDedekindDomain S\ninst✝ : Algebra R S\nP : Subtype fun x => Membership.mem (UniqueFactorizationMonoid.factors (Ideal.map (algebraMap R S) p)).toFinset x\n⊢ Ne (↑P) Bot.bot","decl":"open scoped Classical in\ntheorem Factors.ne_bot (P : (factors (map (algebraMap R S) p)).toFinset) : (P : Ideal S) ≠ ⊥ :=\n  (prime_of_factor _ (Multiset.mem_toFinset.mp P.2)).ne_zero\n\n"}
{"name":"Ideal.Factors.isPrime","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nS : Type v\ninst✝² : CommRing S\np : Ideal R\ninst✝¹ : IsDedekindDomain S\ninst✝ : Algebra R S\nP : Subtype fun x => Membership.mem (UniqueFactorizationMonoid.factors (Ideal.map (algebraMap R S) p)).toFinset x\n⊢ (↑P).IsPrime","decl":"open scoped Classical in\ninstance Factors.isPrime (P : (factors (map (algebraMap R S) p)).toFinset) :\n    IsPrime (P : Ideal S) :=\n  Ideal.isPrime_of_prime (prime_of_factor _ (Multiset.mem_toFinset.mp P.2))\n\n"}
{"name":"Ideal.Factors.ramificationIdx_ne_zero","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nS : Type v\ninst✝² : CommRing S\np : Ideal R\ninst✝¹ : IsDedekindDomain S\ninst✝ : Algebra R S\nP : Subtype fun x => Membership.mem (UniqueFactorizationMonoid.factors (Ideal.map (algebraMap R S) p)).toFinset x\n⊢ Ne (Ideal.ramificationIdx (algebraMap R S) p ↑P) 0","decl":"open scoped Classical in\ntheorem Factors.ramificationIdx_ne_zero (P : (factors (map (algebraMap R S) p)).toFinset) :\n    ramificationIdx (algebraMap R S) p P ≠ 0 :=\n  IsDedekindDomain.ramificationIdx_ne_zero (ne_zero_of_mem_factors (Multiset.mem_toFinset.mp P.2))\n    (Factors.isPrime p P) (Ideal.le_of_dvd (dvd_of_mem_factors (Multiset.mem_toFinset.mp P.2)))\n\n"}
{"name":"Ideal.Factors.fact_ramificationIdx_neZero","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nS : Type v\ninst✝² : CommRing S\np : Ideal R\ninst✝¹ : IsDedekindDomain S\ninst✝ : Algebra R S\nP : Subtype fun x => Membership.mem (UniqueFactorizationMonoid.factors (Ideal.map (algebraMap R S) p)).toFinset x\n⊢ NeZero (Ideal.ramificationIdx (algebraMap R S) p ↑P)","decl":"open scoped Classical in\ninstance Factors.fact_ramificationIdx_neZero (P : (factors (map (algebraMap R S) p)).toFinset) :\n    NeZero (ramificationIdx (algebraMap R S) p P) :=\n  ⟨Factors.ramificationIdx_ne_zero p P⟩\n\n"}
{"name":"Ideal.Factors.isScalarTower","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nS : Type v\ninst✝² : CommRing S\np : Ideal R\ninst✝¹ : IsDedekindDomain S\ninst✝ : Algebra R S\nP : Subtype fun x => Membership.mem (UniqueFactorizationMonoid.factors (Ideal.map (algebraMap R S) p)).toFinset x\n⊢ IsScalarTower R (HasQuotient.Quotient R p) (HasQuotient.Quotient S ↑P)","decl":"open scoped Classical in\ninstance Factors.isScalarTower (P : (factors (map (algebraMap R S) p)).toFinset) :\n    IsScalarTower R (R ⧸ p) (S ⧸ (P : Ideal S)) :=\n  IsScalarTower.of_algebraMap_eq' rfl\n\n"}
{"name":"Ideal.Factors.liesOver","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nS : Type v\ninst✝³ : CommRing S\np : Ideal R\ninst✝² : IsDedekindDomain S\ninst✝¹ : Algebra R S\ninst✝ : p.IsMaximal\nP : Subtype fun x => Membership.mem (UniqueFactorizationMonoid.factors (Ideal.map (algebraMap R S) p)).toFinset x\n⊢ (↑P).LiesOver p","decl":"open scoped Classical in\ninstance Factors.liesOver [p.IsMaximal] (P : (factors (map (algebraMap R S) p)).toFinset) :\n    P.1.LiesOver p :=\n  ⟨(comap_eq_of_scalar_tower_quotient (algebraMap (R ⧸ p) (S ⧸ P.1)).injective).symm⟩\n\n"}
{"name":"Ideal.Factors.finrank_pow_ramificationIdx","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nS : Type v\ninst✝³ : CommRing S\np : Ideal R\ninst✝² : IsDedekindDomain S\ninst✝¹ : Algebra R S\ninst✝ : p.IsMaximal\nP : Subtype fun x => Membership.mem (UniqueFactorizationMonoid.factors (Ideal.map (algebraMap R S) p)).toFinset x\n⊢ Eq (Module.finrank (HasQuotient.Quotient R p) (HasQuotient.Quotient S (HPow.hPow (↑P) (Ideal.ramificationIdx (algebraMap R S) p ↑P)))) (HMul.hMul (Ideal.ramificationIdx (algebraMap R S) p ↑P) (p.inertiaDeg ↑P))","decl":"open scoped Classical in\ntheorem Factors.finrank_pow_ramificationIdx [p.IsMaximal]\n    (P : (factors (map (algebraMap R S) p)).toFinset) :\n    finrank (R ⧸ p) (S ⧸ (P : Ideal S) ^ ramificationIdx (algebraMap R S) p P) =\n      ramificationIdx (algebraMap R S) p P * inertiaDeg p (P : Ideal S) := by\n  rw [finrank_prime_pow_ramificationIdx, inertiaDeg_algebraMap]\n  exacts [Factors.ne_bot p P, NeZero.ne _]\n\n"}
{"name":"Ideal.Factors.finiteDimensional_quotient_pow","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nS : Type v\ninst✝⁴ : CommRing S\np : Ideal R\ninst✝³ : IsDedekindDomain S\ninst✝² : Algebra R S\ninst✝¹ : Module.Finite R S\ninst✝ : p.IsMaximal\nP : Subtype fun x => Membership.mem (UniqueFactorizationMonoid.factors (Ideal.map (algebraMap R S) p)).toFinset x\n⊢ FiniteDimensional (HasQuotient.Quotient R p) (HasQuotient.Quotient S (HPow.hPow (↑P) (Ideal.ramificationIdx (algebraMap R S) p ↑P)))","decl":"open scoped Classical in\ninstance Factors.finiteDimensional_quotient_pow [Module.Finite R S] [p.IsMaximal]\n    (P : (factors (map (algebraMap R S) p)).toFinset) :\n    FiniteDimensional (R ⧸ p) (S ⧸ (P : Ideal S) ^ ramificationIdx (algebraMap R S) p P) := by\n  refine .of_finrank_pos ?_\n  rw [pos_iff_ne_zero, Factors.finrank_pow_ramificationIdx]\n  exact mul_ne_zero (Factors.ramificationIdx_ne_zero p P) (inertiaDeg_pos p P.1).ne'\n\n"}
{"name":"Ideal.Factors.piQuotientEquiv_mk","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nS : Type v\ninst✝² : CommRing S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Algebra R S\np : Ideal R\nhp : Ne (Ideal.map (algebraMap R S) p) Bot.bot\nx : S\n⊢ Eq ((Ideal.Factors.piQuotientEquiv p hp) ((Ideal.Quotient.mk (Ideal.map (algebraMap R S) p)) x)) fun x_1 => (Ideal.Quotient.mk (HPow.hPow (↑x_1) (Ideal.ramificationIdx (algebraMap R S) p ↑x_1))) x","decl":"@[simp]\ntheorem Factors.piQuotientEquiv_mk (p : Ideal R) (hp : map (algebraMap R S) p ≠ ⊥) (x : S) :\n    Factors.piQuotientEquiv p hp (Ideal.Quotient.mk _ x) = fun _ => Ideal.Quotient.mk _ x := rfl\n\n"}
{"name":"Ideal.Factors.piQuotientEquiv_map","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nS : Type v\ninst✝² : CommRing S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Algebra R S\np : Ideal R\nhp : Ne (Ideal.map (algebraMap R S) p) Bot.bot\nx : R\n⊢ Eq ((Ideal.Factors.piQuotientEquiv p hp) ((algebraMap R (HasQuotient.Quotient S (Ideal.map (algebraMap R S) p))) x)) fun x_1 => (Ideal.Quotient.mk (HPow.hPow (↑x_1) (Ideal.ramificationIdx (algebraMap R S) p ↑x_1))) ((algebraMap R S) x)","decl":"@[simp]\ntheorem Factors.piQuotientEquiv_map (p : Ideal R) (hp : map (algebraMap R S) p ≠ ⊥) (x : R) :\n    Factors.piQuotientEquiv p hp (algebraMap _ _ x) = fun _ =>\n      Ideal.Quotient.mk _ (algebraMap _ _ x) := rfl\n\n"}
{"name":"Ideal.sum_ramification_inertia","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u\ninst✝¹⁶ : CommRing R\nS : Type v\ninst✝¹⁵ : CommRing S\np : Ideal R\ninst✝¹⁴ : IsDedekindDomain S\ninst✝¹³ : Algebra R S\nK : Type u_1\nL : Type u_2\ninst✝¹² : Field K\ninst✝¹¹ : Field L\ninst✝¹⁰ : IsDedekindDomain R\ninst✝⁹ : Algebra R K\ninst✝⁸ : IsFractionRing R K\ninst✝⁷ : Algebra S L\ninst✝⁶ : IsFractionRing S L\ninst✝⁵ : Algebra K L\ninst✝⁴ : Algebra R L\ninst✝³ : IsScalarTower R S L\ninst✝² : IsScalarTower R K L\ninst✝¹ : Module.Finite R S\ninst✝ : p.IsMaximal\nhp0 : Ne p Bot.bot\n⊢ Eq ((UniqueFactorizationMonoid.factors (Ideal.map (algebraMap R S) p)).toFinset.sum fun P => HMul.hMul (Ideal.ramificationIdx (algebraMap R S) p P) (p.inertiaDeg P)) (Module.finrank K L)","decl":"open scoped Classical in\n/-- The **fundamental identity** of ramification index `e` and inertia degree `f`:\nfor `P` ranging over the primes lying over `p`, `∑ P, e P * f P = [Frac(S) : Frac(R)]`;\nhere `S` is a finite `R`-module (and thus `Frac(S) : Frac(R)` is a finite extension) and `p`\nis maximal. -/\ntheorem sum_ramification_inertia (K L : Type*) [Field K] [Field L] [IsDedekindDomain R]\n    [Algebra R K] [IsFractionRing R K] [Algebra S L] [IsFractionRing S L] [Algebra K L]\n    [Algebra R L] [IsScalarTower R S L] [IsScalarTower R K L] [Module.Finite R S]\n    [p.IsMaximal] (hp0 : p ≠ ⊥) :\n    (∑ P ∈ (factors (map (algebraMap R S) p)).toFinset,\n        ramificationIdx (algebraMap R S) p P * inertiaDeg p P) =\n      finrank K L := by\n  set e := ramificationIdx (algebraMap R S) p\n  set f := inertiaDeg p (S := S)\n  calc\n    (∑ P ∈ (factors (map (algebraMap R S) p)).toFinset, e P * f P) =\n        ∑ P ∈ (factors (map (algebraMap R S) p)).toFinset.attach,\n          finrank (R ⧸ p) (S ⧸ (P : Ideal S) ^ e P) := ?_\n    _ = finrank (R ⧸ p)\n          (∀ P : (factors (map (algebraMap R S) p)).toFinset, S ⧸ (P : Ideal S) ^ e P) :=\n      (finrank_pi_fintype (R ⧸ p)).symm\n    _ = finrank (R ⧸ p) (S ⧸ map (algebraMap R S) p) := ?_\n    _ = finrank K L := ?_\n  · rw [← Finset.sum_attach]\n    refine Finset.sum_congr rfl fun P _ => ?_\n    rw [Factors.finrank_pow_ramificationIdx]\n  · refine LinearEquiv.finrank_eq (Factors.piQuotientLinearEquiv S p ?_).symm\n    rwa [Ne, Ideal.map_eq_bot_iff_le_ker, (RingHom.injective_iff_ker_eq_bot _).mp <|\n      algebraMap_injective_of_field_isFractionRing R S K L, le_bot_iff]\n  · exact finrank_quotient_map p K L\n\n"}
{"name":"Ideal.ramificationIdx_tower","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing T\ninst✝¹ : IsDedekindDomain S\ninst✝ : IsDedekindDomain T\nf : RingHom R S\ng : RingHom S T\np : Ideal R\nP : Ideal S\nQ : Ideal T\nhpm : P.IsPrime\nhqm : Q.IsPrime\nhg0 : Ne (Ideal.map g P) Bot.bot\nhfg : Ne (Ideal.map (g.comp f) p) Bot.bot\nhg : LE.le (Ideal.map g P) Q\n⊢ Eq (Ideal.ramificationIdx (g.comp f) p Q) (HMul.hMul (Ideal.ramificationIdx f p P) (Ideal.ramificationIdx g P Q))","decl":"theorem ramificationIdx_tower [IsDedekindDomain S] [IsDedekindDomain T] {f : R →+* S} {g : S →+* T}\n    {p : Ideal R} {P : Ideal S} {Q : Ideal T} [hpm : P.IsPrime] [hqm : Q.IsPrime]\n    (hg0 : map g P ≠ ⊥) (hfg : map (g.comp f) p ≠ ⊥) (hg : map g P ≤ Q) :\n    ramificationIdx (g.comp f) p Q = ramificationIdx f p P * ramificationIdx g P Q := by\n  classical\n  have hf0 : map f p ≠ ⊥ :=\n    ne_bot_of_map_ne_bot (Eq.mp (congrArg (fun I ↦ I ≠ ⊥) (map_map f g).symm) hfg)\n  have hp0 : P ≠ ⊥ := ne_bot_of_map_ne_bot hg0\n  have hq0 : Q ≠ ⊥ := ne_bot_of_le_ne_bot hg0 hg\n  letI : P.IsMaximal := Ring.DimensionLEOne.maximalOfPrime hp0 hpm\n  rw [IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hf0 hpm hp0,\n    IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hg0 hqm hq0,\n    IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hfg hqm hq0, ← map_map]\n  rcases eq_prime_pow_mul_coprime hf0 P with ⟨I, hcp, heq⟩\n  have hcp : ⊤ = map g P ⊔ map g I := by rw [← map_sup, hcp, map_top g]\n  have hntq : ¬ ⊤ ≤ Q := fun ht ↦ IsPrime.ne_top hqm (Iff.mpr (eq_top_iff_one Q) (ht trivial))\n  nth_rw 1 [heq, map_mul, Ideal.map_pow, normalizedFactors_mul (pow_ne_zero _ hg0) <| by\n    by_contra h\n    simp only [h, Submodule.zero_eq_bot, bot_le, sup_of_le_left] at hcp\n    exact hntq (hcp.trans_le hg), Multiset.count_add, normalizedFactors_pow, Multiset.count_nsmul]\n  exact add_right_eq_self.mpr <| Decidable.byContradiction fun h ↦ hntq <| hcp.trans_le <|\n    sup_le hg <| le_of_dvd <| dvd_of_mem_normalizedFactors <| Multiset.count_ne_zero.mp h\n\n"}
{"name":"Ideal.ramificationIdx_algebra_tower","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : CommRing T\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra S T\ninst✝³ : Algebra R T\ninst✝² : IsScalarTower R S T\ninst✝¹ : IsDedekindDomain S\ninst✝ : IsDedekindDomain T\np : Ideal R\nP : Ideal S\nQ : Ideal T\nhpm : P.IsPrime\nhqm : Q.IsPrime\nhg0 : Ne (Ideal.map (algebraMap S T) P) Bot.bot\nhfg : Ne (Ideal.map (algebraMap R T) p) Bot.bot\nhg : LE.le (Ideal.map (algebraMap S T) P) Q\n⊢ Eq (Ideal.ramificationIdx (algebraMap R T) p Q) (HMul.hMul (Ideal.ramificationIdx (algebraMap R S) p P) (Ideal.ramificationIdx (algebraMap S T) P Q))","decl":"/-- Let `T / S / R` be a tower of algebras, `p, P, Q` be ideals in `R, S, T` respectively,\n  and `P` and `Q` are prime. If `P = Q ∩ S`, then `e (Q | p) = e (P | p) * e (Q | P)`. -/\ntheorem ramificationIdx_algebra_tower [IsDedekindDomain S] [IsDedekindDomain T]\n    {p : Ideal R} {P : Ideal S} {Q : Ideal T} [hpm : P.IsPrime] [hqm : Q.IsPrime]\n    (hg0 : map (algebraMap S T) P ≠ ⊥)\n    (hfg : map (algebraMap R T) p ≠ ⊥) (hg : map (algebraMap S T) P ≤ Q) :\n    ramificationIdx (algebraMap R T) p Q =\n    ramificationIdx (algebraMap R S) p P * ramificationIdx (algebraMap S T) P Q := by\n  rw [IsScalarTower.algebraMap_eq R S T] at hfg ⊢\n  exact ramificationIdx_tower hg0 hfg hg\n\n"}
{"name":"Ideal.inertiaDeg_algebra_tower","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : CommRing T\ninst✝⁷ : Algebra R S\ninst✝⁶ : Algebra S T\ninst✝⁵ : Algebra R T\ninst✝⁴ : IsScalarTower R S T\np : Ideal R\nP : Ideal S\nI : Ideal T\ninst✝³ : p.IsMaximal\ninst✝² : P.IsMaximal\ninst✝¹ : P.LiesOver p\ninst✝ : I.LiesOver P\n⊢ Eq (p.inertiaDeg I) (HMul.hMul (p.inertiaDeg P) (P.inertiaDeg I))","decl":"/-- Let `T / S / R` be a tower of algebras, `p, P, I` be ideals in `R, S, T`, respectively,\n  and `p` and `P` are maximal. If `p = P ∩ S` and `P = I ∩ S`,\n  then `f (I | p) = f (P | p) * f (I | P)`. -/\ntheorem inertiaDeg_algebra_tower (p : Ideal R) (P : Ideal S) (I : Ideal T) [p.IsMaximal]\n    [P.IsMaximal] [P.LiesOver p] [I.LiesOver P] : inertiaDeg p I =\n    inertiaDeg p P * inertiaDeg P I := by\n  have h₁ := P.over_def p\n  have h₂ := I.over_def P\n  have h₃ := (LiesOver.trans I P p).over\n  simp only [inertiaDeg, dif_pos h₁.symm, dif_pos h₂.symm, dif_pos h₃.symm]\n  letI : Algebra (R ⧸ p) (S ⧸ P) := Ideal.Quotient.algebraQuotientOfLEComap h₁.le\n  letI : Algebra (S ⧸ P) (T ⧸ I) := Ideal.Quotient.algebraQuotientOfLEComap h₂.le\n  letI : Algebra (R ⧸ p) (T ⧸ I) := Ideal.Quotient.algebraQuotientOfLEComap h₃.le\n  letI : IsScalarTower (R ⧸ p) (S ⧸ P) (T ⧸ I) := IsScalarTower.of_algebraMap_eq <| by\n    rintro ⟨x⟩; exact congr_arg _ (IsScalarTower.algebraMap_apply R S T x)\n  exact (finrank_mul_finrank (R ⧸ p) (S ⧸ P) (T ⧸ I)).symm\n\n"}
{"name":"Ideal.inertiaDeg_tower","module":"Mathlib.NumberTheory.RamificationInertia.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : CommRing T\ninst✝⁷ : Algebra R S\ninst✝⁶ : Algebra S T\ninst✝⁵ : Algebra R T\ninst✝⁴ : IsScalarTower R S T\np : Ideal R\nP : Ideal S\nI : Ideal T\ninst✝³ : p.IsMaximal\ninst✝² : P.IsMaximal\ninst✝¹ : P.LiesOver p\ninst✝ : I.LiesOver P\n⊢ Eq (p.inertiaDeg I) (HMul.hMul (p.inertiaDeg P) (P.inertiaDeg I))","decl":"@[deprecated (since := \"2024-12-09\")] alias inertiaDeg_tower := inertiaDeg_algebra_tower\n\n"}
