{"name":"measurableSet_integrable","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : MeasurableSpace Î²\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : MeasureTheory.SFinite Î½\nf : Î± â†’ Î² â†’ E\nhf : MeasureTheory.StronglyMeasurable (Function.uncurry f)\nâŠ¢ MeasurableSet (setOf fun x => MeasureTheory.Integrable (f x) Î½)","decl":"theorem measurableSet_integrable [SFinite Î½] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„\n    (hf : StronglyMeasurable (uncurry f)) : MeasurableSet {x | Integrable (f x) Î½} := by\n  simp_rw [Integrable, hf.of_uncurry_left.aestronglyMeasurable, true_and]\n  exact measurableSet_lt (Measurable.lintegral_prod_right hf.enorm) measurable_const\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_prod_right","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î½\nf : Î± â†’ Î² â†’ E\nhf : MeasureTheory.StronglyMeasurable (Function.uncurry f)\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => MeasureTheory.integral Î½ fun y => f x y","decl":"/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)\n  Fubini's theorem is measurable.\n  This version has `f` in curried form. -/\ntheorem MeasureTheory.StronglyMeasurable.integral_prod_right [SFinite Î½] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„\n    (hf : StronglyMeasurable (uncurry f)) : StronglyMeasurable fun x => âˆ« y, f x y âˆ‚Î½ := by\n  classical\n  by_cases hE : CompleteSpace E; swap; Â· simp [integral, hE, stronglyMeasurable_const]\n  borelize E\n  haveI : SeparableSpace (range (uncurry f) âˆª {0} : Set E) :=\n    hf.separableSpace_range_union_singleton\n  let s : â„• â†’ SimpleFunc (Î± Ã— Î²) E :=\n    SimpleFunc.approxOn _ hf.measurable (range (uncurry f) âˆª {0}) 0 (by simp)\n  let s' : â„• â†’ Î± â†’ SimpleFunc Î² E := fun n x => (s n).comp (Prod.mk x) measurable_prod_mk_left\n  let f' : â„• â†’ Î± â†’ E := fun n => {x | Integrable (f x) Î½}.indicator fun x => (s' n x).integral Î½\n  have hf' : âˆ€ n, StronglyMeasurable (f' n) := by\n    intro n; refine StronglyMeasurable.indicator ?_ (measurableSet_integrable hf)\n    have : âˆ€ x, ((s' n x).range.filter fun x => x â‰  0) âŠ† (s n).range := by\n      intro x; refine Finset.Subset.trans (Finset.filter_subset _ _) ?_; intro y\n      simp_rw [SimpleFunc.mem_range]; rintro âŸ¨z, rflâŸ©; exact âŸ¨(x, z), rflâŸ©\n    simp only [SimpleFunc.integral_eq_sum_of_subset (this _)]\n    refine Finset.stronglyMeasurable_sum _ fun x _ => ?_\n    refine (Measurable.ennreal_toReal ?_).stronglyMeasurable.smul_const _\n    simp only [s', SimpleFunc.coe_comp, preimage_comp]\n    apply measurable_measure_prod_mk_left\n    exact (s n).measurableSet_fiber x\n  have h2f' : Tendsto f' atTop (ð“ fun x : Î± => âˆ« y : Î², f x y âˆ‚Î½) := by\n    rw [tendsto_pi_nhds]; intro x\n    by_cases hfx : Integrable (f x) Î½\n    Â· have (n) : Integrable (s' n x) Î½ := by\n        apply (hfx.norm.add hfx.norm).mono' (s' n x).aestronglyMeasurable\n        filter_upwards with y\n        simp_rw [s', SimpleFunc.coe_comp]; exact SimpleFunc.norm_approxOn_zero_le _ _ (x, y) n\n      simp only [f', hfx, SimpleFunc.integral_eq_integral _ (this _), indicator_of_mem,\n        mem_setOf_eq]\n      refine\n        tendsto_integral_of_dominated_convergence (fun y => â€–f x yâ€– + â€–f x yâ€–)\n          (fun n => (s' n x).aestronglyMeasurable) (hfx.norm.add hfx.norm) ?_ ?_\n      Â· refine fun n => Eventually.of_forall fun y =>\n          SimpleFunc.norm_approxOn_zero_le ?_ ?_ (x, y) n\n        -- Porting note: Lean 3 solved the following two subgoals on its own\n        Â· exact hf.measurable\n        Â· simp\n      Â· refine Eventually.of_forall fun y => SimpleFunc.tendsto_approxOn ?_ ?_ ?_\n        -- Porting note: Lean 3 solved the following two subgoals on its own\n        Â· exact hf.measurable.of_uncurry_left\n        Â· simp\n        apply subset_closure\n        simp [-uncurry_apply_pair]\n    Â· simp [f', hfx, integral_undef]\n  exact stronglyMeasurable_of_tendsto _ hf' h2f'\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_prod_right'","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î½\nf : Prod Î± Î² â†’ E\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => MeasureTheory.integral Î½ fun y => f { fst := x, snd := y }","decl":"/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)\n  Fubini's theorem is measurable. -/\ntheorem MeasureTheory.StronglyMeasurable.integral_prod_right' [SFinite Î½] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„\n    (hf : StronglyMeasurable f) : StronglyMeasurable fun x => âˆ« y, f (x, y) âˆ‚Î½ := by\n  rw [â† uncurry_curry f] at hf; exact hf.integral_prod_right\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_prod_left","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf : Î± â†’ Î² â†’ E\nhf : MeasureTheory.StronglyMeasurable (Function.uncurry f)\nâŠ¢ MeasureTheory.StronglyMeasurable fun y => MeasureTheory.integral Î¼ fun x => f x y","decl":"/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)\n  the symmetric version of Fubini's theorem is measurable.\n  This version has `f` in curried form. -/\ntheorem MeasureTheory.StronglyMeasurable.integral_prod_left [SFinite Î¼] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„\n    (hf : StronglyMeasurable (uncurry f)) : StronglyMeasurable fun y => âˆ« x, f x y âˆ‚Î¼ :=\n  (hf.comp_measurable measurable_swap).integral_prod_right'\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_prod_left'","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf : Prod Î± Î² â†’ E\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun y => MeasureTheory.integral Î¼ fun x => f { fst := x, snd := y }","decl":"/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)\n  the symmetric version of Fubini's theorem is measurable. -/\ntheorem MeasureTheory.StronglyMeasurable.integral_prod_left' [SFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„\n    (hf : StronglyMeasurable f) : StronglyMeasurable fun y => âˆ« x, f (x, y) âˆ‚Î¼ :=\n  (hf.comp_measurable measurable_swap).integral_prod_right'\n\n"}
{"name":"MeasureTheory.Measure.integrable_measure_prod_mk_left","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœ : MeasureTheory.SFinite Î½\ns : Set (Prod Î± Î²)\nhs : MeasurableSet s\nh2s : Ne ((Î¼.prod Î½) s) Top.top\nâŠ¢ MeasureTheory.Integrable (fun x => (Î½ (Set.preimage (Prod.mk x) s)).toReal) Î¼","decl":"theorem integrable_measure_prod_mk_left {s : Set (Î± Ã— Î²)} (hs : MeasurableSet s)\n    (h2s : (Î¼.prod Î½) s â‰  âˆž) : Integrable (fun x => (Î½ (Prod.mk x â»Â¹' s)).toReal) Î¼ := by\n  refine âŸ¨(measurable_measure_prod_mk_left hs).ennreal_toReal.aemeasurable.aestronglyMeasurable, ?_âŸ©\n  simp_rw [hasFiniteIntegral_iff_enorm, enorm_eq_ofReal toReal_nonneg]\n  convert h2s.lt_top using 1\n  rw [prod_apply hs]\n  apply lintegral_congr_ae\n  filter_upwards [ae_measure_lt_top hs h2s] with x hx\n  rw [lt_top_iff_ne_top] at hx; simp [ofReal_toReal, hx]\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.prod_swap","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\nÎ³ : Type u_4\ninstâœÂ² : TopologicalSpace Î³\ninstâœÂ¹ : MeasureTheory.SFinite Î¼\ninstâœ : MeasureTheory.SFinite Î½\nf : Prod Î² Î± â†’ Î³\nhf : MeasureTheory.AEStronglyMeasurable f (Î½.prod Î¼)\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun z => f z.swap) (Î¼.prod Î½)","decl":"nonrec theorem MeasureTheory.AEStronglyMeasurable.prod_swap {Î³ : Type*} [TopologicalSpace Î³]\n    [SFinite Î¼] [SFinite Î½] {f : Î² Ã— Î± â†’ Î³} (hf : AEStronglyMeasurable f (Î½.prod Î¼)) :\n    AEStronglyMeasurable (fun z : Î± Ã— Î² => f z.swap) (Î¼.prod Î½) := by\n  rw [â† prod_swap] at hf\n  exact hf.comp_measurable measurable_swap\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.fst","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\nÎ³ : Type u_4\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : MeasureTheory.SFinite Î½\nf : Î± â†’ Î³\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun z => f z.1) (Î¼.prod Î½)","decl":"theorem MeasureTheory.AEStronglyMeasurable.fst {Î³} [TopologicalSpace Î³] [SFinite Î½] {f : Î± â†’ Î³}\n    (hf : AEStronglyMeasurable f Î¼) : AEStronglyMeasurable (fun z : Î± Ã— Î² => f z.1) (Î¼.prod Î½) :=\n  hf.comp_quasiMeasurePreserving quasiMeasurePreserving_fst\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.snd","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\nÎ³ : Type u_4\ninstâœÂ¹ : TopologicalSpace Î³\ninstâœ : MeasureTheory.SFinite Î½\nf : Î² â†’ Î³\nhf : MeasureTheory.AEStronglyMeasurable f Î½\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun z => f z.2) (Î¼.prod Î½)","decl":"theorem MeasureTheory.AEStronglyMeasurable.snd {Î³} [TopologicalSpace Î³] [SFinite Î½] {f : Î² â†’ Î³}\n    (hf : AEStronglyMeasurable f Î½) : AEStronglyMeasurable (fun z : Î± Ã— Î² => f z.2) (Î¼.prod Î½) :=\n  hf.comp_quasiMeasurePreserving quasiMeasurePreserving_snd\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.integral_prod_right'","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : MeasureTheory.SFinite Î½\ninstâœ : NormedSpace Real E\nf : Prod Î± Î² â†’ E\nhf : MeasureTheory.AEStronglyMeasurable f (Î¼.prod Î½)\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun x => MeasureTheory.integral Î½ fun y => f { fst := x, snd := y }) Î¼","decl":"/-- The Bochner integral is a.e.-measurable.\n  This shows that the integrand of (the right-hand-side of) Fubini's theorem is a.e.-measurable. -/\ntheorem MeasureTheory.AEStronglyMeasurable.integral_prod_right' [SFinite Î½] [NormedSpace â„ E]\n    â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : AEStronglyMeasurable f (Î¼.prod Î½)) :\n    AEStronglyMeasurable (fun x => âˆ« y, f (x, y) âˆ‚Î½) Î¼ :=\n  âŸ¨fun x => âˆ« y, hf.mk f (x, y) âˆ‚Î½, hf.stronglyMeasurable_mk.integral_prod_right', by\n    filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with _ hx using integral_congr_ae hxâŸ©\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.prod_mk_left","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\nÎ³ : Type u_4\ninstâœÂ¹ : MeasureTheory.SFinite Î½\ninstâœ : TopologicalSpace Î³\nf : Prod Î± Î² â†’ Î³\nhf : MeasureTheory.AEStronglyMeasurable f (Î¼.prod Î½)\nâŠ¢ Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (fun y => f { fst := x, snd := y }) Î½) (MeasureTheory.ae Î¼)","decl":"theorem MeasureTheory.AEStronglyMeasurable.prod_mk_left {Î³ : Type*} [SFinite Î½]\n    [TopologicalSpace Î³] {f : Î± Ã— Î² â†’ Î³} (hf : AEStronglyMeasurable f (Î¼.prod Î½)) :\n    âˆ€áµ x âˆ‚Î¼, AEStronglyMeasurable (fun y => f (x, y)) Î½ := by\n  filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with x hx\n  exact\n    âŸ¨fun y => hf.mk f (x, y), hf.stronglyMeasurable_mk.comp_measurable measurable_prod_mk_left, hxâŸ©\n\n"}
{"name":"MeasureTheory.integrable_swap_iff","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : MeasureTheory.SFinite Î½\ninstâœ : MeasureTheory.SFinite Î¼\nf : Prod Î± Î² â†’ E\nâŠ¢ Iff (MeasureTheory.Integrable (Function.comp f Prod.swap) (Î½.prod Î¼)) (MeasureTheory.Integrable f (Î¼.prod Î½))","decl":"theorem integrable_swap_iff [SFinite Î¼] {f : Î± Ã— Î² â†’ E} :\n    Integrable (f âˆ˜ Prod.swap) (Î½.prod Î¼) â†” Integrable f (Î¼.prod Î½) :=\n  measurePreserving_swap.integrable_comp_emb MeasurableEquiv.prodComm.measurableEmbedding\n\n"}
{"name":"MeasureTheory.Integrable.swap","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : MeasureTheory.SFinite Î½\ninstâœ : MeasureTheory.SFinite Î¼\nf : Prod Î± Î² â†’ E\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nâŠ¢ MeasureTheory.Integrable (Function.comp f Prod.swap) (Î½.prod Î¼)","decl":"theorem Integrable.swap [SFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.prod Î½)) :\n    Integrable (f âˆ˜ Prod.swap) (Î½.prod Î¼) :=\n  integrable_swap_iff.2 hf\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_prod_iff","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : MeasureTheory.SFinite Î½\nf : Prod Î± Î² â†’ E\nh1f : MeasureTheory.StronglyMeasurable f\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f (Î¼.prod Î½)) (And (Filter.Eventually (fun x => MeasureTheory.HasFiniteIntegral (fun y => f { fst := x, snd := y }) Î½) (MeasureTheory.ae Î¼)) (MeasureTheory.HasFiniteIntegral (fun x => MeasureTheory.integral Î½ fun y => Norm.norm (f { fst := x, snd := y })) Î¼))","decl":"theorem hasFiniteIntegral_prod_iff â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : StronglyMeasurable f) :\n    HasFiniteIntegral f (Î¼.prod Î½) â†”\n      (âˆ€áµ x âˆ‚Î¼, HasFiniteIntegral (fun y => f (x, y)) Î½) âˆ§\n        HasFiniteIntegral (fun x => âˆ« y, â€–f (x, y)â€– âˆ‚Î½) Î¼ := by\n  simp only [hasFiniteIntegral_iff_enorm, lintegral_prod_of_measurable _ h1f.enorm]\n  have (x) : âˆ€áµ y âˆ‚Î½, 0 â‰¤ â€–f (x, y)â€– := by filter_upwards with y using norm_nonneg _\n  simp_rw [integral_eq_lintegral_of_nonneg_ae (this _)\n      (h1f.norm.comp_measurable measurable_prod_mk_left).aestronglyMeasurable,\n    enorm_eq_ofReal toReal_nonneg, ofReal_norm_eq_enorm]\n  -- this fact is probably too specialized to be its own lemma\n  have : âˆ€ {p q r : Prop} (_ : r â†’ p), (r â†” p âˆ§ q) â†” p â†’ (r â†” q) := fun {p q r} h1 => by\n    rw [â† and_congr_right_iff, and_iff_right_of_imp h1]\n  rw [this]\n  Â· intro h2f; rw [lintegral_congr_ae]\n    filter_upwards [h2f] with x hx\n    rw [ofReal_toReal]; rw [â† lt_top_iff_ne_top]; exact hx\n  Â· intro h2f; refine ae_lt_top ?_ h2f.ne; exact h1f.enorm.lintegral_prod_right'\n\n"}
{"name":"MeasureTheory.hasFiniteIntegral_prod_iff'","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : MeasureTheory.SFinite Î½\nf : Prod Î± Î² â†’ E\nh1f : MeasureTheory.AEStronglyMeasurable f (Î¼.prod Î½)\nâŠ¢ Iff (MeasureTheory.HasFiniteIntegral f (Î¼.prod Î½)) (And (Filter.Eventually (fun x => MeasureTheory.HasFiniteIntegral (fun y => f { fst := x, snd := y }) Î½) (MeasureTheory.ae Î¼)) (MeasureTheory.HasFiniteIntegral (fun x => MeasureTheory.integral Î½ fun y => Norm.norm (f { fst := x, snd := y })) Î¼))","decl":"theorem hasFiniteIntegral_prod_iff' â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : AEStronglyMeasurable f (Î¼.prod Î½)) :\n    HasFiniteIntegral f (Î¼.prod Î½) â†”\n      (âˆ€áµ x âˆ‚Î¼, HasFiniteIntegral (fun y => f (x, y)) Î½) âˆ§\n        HasFiniteIntegral (fun x => âˆ« y, â€–f (x, y)â€– âˆ‚Î½) Î¼ := by\n  rw [hasFiniteIntegral_congr h1f.ae_eq_mk,\n    hasFiniteIntegral_prod_iff h1f.stronglyMeasurable_mk]\n  apply and_congr\n  Â· apply eventually_congr\n    filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm]\n    intro x hx\n    exact hasFiniteIntegral_congr hx\n  Â· apply hasFiniteIntegral_congr\n    filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm] with _ hx using\n      integral_congr_ae (EventuallyEq.fun_comp hx _)\n\n"}
{"name":"MeasureTheory.integrable_prod_iff","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : MeasureTheory.SFinite Î½\nf : Prod Î± Î² â†’ E\nh1f : MeasureTheory.AEStronglyMeasurable f (Î¼.prod Î½)\nâŠ¢ Iff (MeasureTheory.Integrable f (Î¼.prod Î½)) (And (Filter.Eventually (fun x => MeasureTheory.Integrable (fun y => f { fst := x, snd := y }) Î½) (MeasureTheory.ae Î¼)) (MeasureTheory.Integrable (fun x => MeasureTheory.integral Î½ fun y => Norm.norm (f { fst := x, snd := y })) Î¼))","decl":"/-- A binary function is integrable if the function `y â†¦ f (x, y)` is integrable for almost every\n  `x` and the function `x â†¦ âˆ« â€–f (x, y)â€– dy` is integrable. -/\ntheorem integrable_prod_iff â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : AEStronglyMeasurable f (Î¼.prod Î½)) :\n    Integrable f (Î¼.prod Î½) â†”\n      (âˆ€áµ x âˆ‚Î¼, Integrable (fun y => f (x, y)) Î½) âˆ§ Integrable (fun x => âˆ« y, â€–f (x, y)â€– âˆ‚Î½) Î¼ := by\n  simp [Integrable, h1f, hasFiniteIntegral_prod_iff', h1f.norm.integral_prod_right',\n    h1f.prod_mk_left]\n\n"}
{"name":"MeasureTheory.integrable_prod_iff'","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : MeasureTheory.SFinite Î½\ninstâœ : MeasureTheory.SFinite Î¼\nf : Prod Î± Î² â†’ E\nh1f : MeasureTheory.AEStronglyMeasurable f (Î¼.prod Î½)\nâŠ¢ Iff (MeasureTheory.Integrable f (Î¼.prod Î½)) (And (Filter.Eventually (fun y => MeasureTheory.Integrable (fun x => f { fst := x, snd := y }) Î¼) (MeasureTheory.ae Î½)) (MeasureTheory.Integrable (fun y => MeasureTheory.integral Î¼ fun x => Norm.norm (f { fst := x, snd := y })) Î½))","decl":"/-- A binary function is integrable if the function `x â†¦ f (x, y)` is integrable for almost every\n  `y` and the function `y â†¦ âˆ« â€–f (x, y)â€– dx` is integrable. -/\ntheorem integrable_prod_iff' [SFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„\n    (h1f : AEStronglyMeasurable f (Î¼.prod Î½)) :\n    Integrable f (Î¼.prod Î½) â†”\n      (âˆ€áµ y âˆ‚Î½, Integrable (fun x => f (x, y)) Î¼) âˆ§ Integrable (fun y => âˆ« x, â€–f (x, y)â€– âˆ‚Î¼) Î½ := by\n  convert integrable_prod_iff h1f.prod_swap using 1\n  rw [funext fun _ => Function.comp_apply.symm, integrable_swap_iff]\n\n"}
{"name":"MeasureTheory.Integrable.prod_left_ae","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : MeasureTheory.SFinite Î½\ninstâœ : MeasureTheory.SFinite Î¼\nf : Prod Î± Î² â†’ E\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nâŠ¢ Filter.Eventually (fun y => MeasureTheory.Integrable (fun x => f { fst := x, snd := y }) Î¼) (MeasureTheory.ae Î½)","decl":"theorem Integrable.prod_left_ae [SFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.prod Î½)) :\n    âˆ€áµ y âˆ‚Î½, Integrable (fun x => f (x, y)) Î¼ :=\n  ((integrable_prod_iff' hf.aestronglyMeasurable).mp hf).1\n\n"}
{"name":"MeasureTheory.Integrable.prod_right_ae","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : MeasureTheory.SFinite Î½\ninstâœ : MeasureTheory.SFinite Î¼\nf : Prod Î± Î² â†’ E\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nâŠ¢ Filter.Eventually (fun x => MeasureTheory.Integrable (fun y => f { fst := x, snd := y }) Î½) (MeasureTheory.ae Î¼)","decl":"theorem Integrable.prod_right_ae [SFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.prod Î½)) :\n    âˆ€áµ x âˆ‚Î¼, Integrable (fun y => f (x, y)) Î½ :=\n  hf.swap.prod_left_ae\n\n"}
{"name":"MeasureTheory.Integrable.integral_norm_prod_left","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : MeasureTheory.SFinite Î½\nf : Prod Î± Î² â†’ E\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nâŠ¢ MeasureTheory.Integrable (fun x => MeasureTheory.integral Î½ fun y => Norm.norm (f { fst := x, snd := y })) Î¼","decl":"theorem Integrable.integral_norm_prod_left â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.prod Î½)) :\n    Integrable (fun x => âˆ« y, â€–f (x, y)â€– âˆ‚Î½) Î¼ :=\n  ((integrable_prod_iff hf.aestronglyMeasurable).mp hf).2\n\n"}
{"name":"MeasureTheory.Integrable.integral_norm_prod_right","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : MeasureTheory.SFinite Î½\ninstâœ : MeasureTheory.SFinite Î¼\nf : Prod Î± Î² â†’ E\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nâŠ¢ MeasureTheory.Integrable (fun y => MeasureTheory.integral Î¼ fun x => Norm.norm (f { fst := x, snd := y })) Î½","decl":"theorem Integrable.integral_norm_prod_right [SFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„\n    (hf : Integrable f (Î¼.prod Î½)) : Integrable (fun y => âˆ« x, â€–f (x, y)â€– âˆ‚Î¼) Î½ :=\n  hf.swap.integral_norm_prod_left\n\n"}
{"name":"MeasureTheory.Integrable.prod_smul","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\nð•œ : Type u_4\ninstâœÂ¹ : NontriviallyNormedField ð•œ\ninstâœ : NormedSpace ð•œ E\nf : Î± â†’ ð•œ\ng : Î² â†’ E\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î½\nâŠ¢ MeasureTheory.Integrable (fun z => HSMul.hSMul (f z.1) (g z.2)) (Î¼.prod Î½)","decl":"theorem Integrable.prod_smul {ð•œ : Type*} [NontriviallyNormedField ð•œ] [NormedSpace ð•œ E]\n    {f : Î± â†’ ð•œ} {g : Î² â†’ E} (hf : Integrable f Î¼) (hg : Integrable g Î½) :\n    Integrable (fun z : Î± Ã— Î² => f z.1 â€¢ g z.2) (Î¼.prod Î½) := by\n  refine (integrable_prod_iff ?_).2 âŸ¨?_, ?_âŸ©\n  Â· exact hf.1.fst.smul hg.1.snd\n  Â· exact Eventually.of_forall fun x => hg.smul (f x)\n  Â· simpa only [norm_smul, integral_mul_left] using hf.norm.mul_const _\n\n"}
{"name":"MeasureTheory.Integrable.prod_mul","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ¹ : MeasureTheory.SFinite Î½\nL : Type u_4\ninstâœ : RCLike L\nf : Î± â†’ L\ng : Î² â†’ L\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î½\nâŠ¢ MeasureTheory.Integrable (fun z => HMul.hMul (f z.1) (g z.2)) (Î¼.prod Î½)","decl":"theorem Integrable.prod_mul {L : Type*} [RCLike L] {f : Î± â†’ L} {g : Î² â†’ L} (hf : Integrable f Î¼)\n    (hg : Integrable g Î½) : Integrable (fun z : Î± Ã— Î² => f z.1 * g z.2) (Î¼.prod Î½) :=\n  hf.prod_smul hg\n\n"}
{"name":"MeasureTheory.Integrable.integral_prod_left","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : MeasureTheory.SFinite Î½\ninstâœ : NormedSpace Real E\nf : Prod Î± Î² â†’ E\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nâŠ¢ MeasureTheory.Integrable (fun x => MeasureTheory.integral Î½ fun y => f { fst := x, snd := y }) Î¼","decl":"theorem Integrable.integral_prod_left â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.prod Î½)) :\n    Integrable (fun x => âˆ« y, f (x, y) âˆ‚Î½) Î¼ :=\n  Integrable.mono hf.integral_norm_prod_left hf.aestronglyMeasurable.integral_prod_right' <|\n    Eventually.of_forall fun x =>\n      (norm_integral_le_integral_norm _).trans_eq <|\n        (norm_of_nonneg <|\n            integral_nonneg_of_ae <|\n              Eventually.of_forall fun y => (norm_nonneg (f (x, y)) :)).symm\n\n"}
{"name":"MeasureTheory.Integrable.integral_prod_right","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf : Prod Î± Î² â†’ E\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nâŠ¢ MeasureTheory.Integrable (fun y => MeasureTheory.integral Î¼ fun x => f { fst := x, snd := y }) Î½","decl":"theorem Integrable.integral_prod_right [SFinite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„\n    (hf : Integrable f (Î¼.prod Î½)) : Integrable (fun y => âˆ« x, f (x, y) âˆ‚Î¼) Î½ :=\n  hf.swap.integral_prod_left\n\n"}
{"name":"MeasureTheory.integral_prod_swap","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf : Prod Î± Î² â†’ E\nâŠ¢ Eq (MeasureTheory.integral (Î½.prod Î¼) fun z => f z.swap) (MeasureTheory.integral (Î¼.prod Î½) fun z => f z)","decl":"theorem integral_prod_swap (f : Î± Ã— Î² â†’ E) :\n    âˆ« z, f z.swap âˆ‚Î½.prod Î¼ = âˆ« z, f z âˆ‚Î¼.prod Î½ :=\n  measurePreserving_swap.integral_comp MeasurableEquiv.prodComm.measurableEmbedding _\n\n"}
{"name":"MeasureTheory.integral_fn_integral_add","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ· : MeasurableSpace Î±\ninstâœâ¶ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : MeasureTheory.SFinite Î½\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : MeasureTheory.SFinite Î¼\nE' : Type u_4\ninstâœÂ¹ : NormedAddCommGroup E'\ninstâœ : NormedSpace Real E'\nf g : Prod Î± Î² â†’ E\nF : E â†’ E'\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nhg : MeasureTheory.Integrable g (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => F (MeasureTheory.integral Î½ fun y => HAdd.hAdd (f { fst := x, snd := y }) (g { fst := x, snd := y }))) (MeasureTheory.integral Î¼ fun x => F (HAdd.hAdd (MeasureTheory.integral Î½ fun y => f { fst := x, snd := y }) (MeasureTheory.integral Î½ fun y => g { fst := x, snd := y })))","decl":"/-- Integrals commute with addition inside another integral. `F` can be any function. -/\ntheorem integral_fn_integral_add â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ E') (hf : Integrable f (Î¼.prod Î½))\n    (hg : Integrable g (Î¼.prod Î½)) :\n    (âˆ« x, F (âˆ« y, f (x, y) + g (x, y) âˆ‚Î½) âˆ‚Î¼) =\n      âˆ« x, F ((âˆ« y, f (x, y) âˆ‚Î½) + âˆ« y, g (x, y) âˆ‚Î½) âˆ‚Î¼ := by\n  refine integral_congr_ae ?_\n  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g\n  simp [integral_add h2f h2g]\n\n"}
{"name":"MeasureTheory.integral_fn_integral_sub","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ· : MeasurableSpace Î±\ninstâœâ¶ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : MeasureTheory.SFinite Î½\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : MeasureTheory.SFinite Î¼\nE' : Type u_4\ninstâœÂ¹ : NormedAddCommGroup E'\ninstâœ : NormedSpace Real E'\nf g : Prod Î± Î² â†’ E\nF : E â†’ E'\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nhg : MeasureTheory.Integrable g (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => F (MeasureTheory.integral Î½ fun y => HSub.hSub (f { fst := x, snd := y }) (g { fst := x, snd := y }))) (MeasureTheory.integral Î¼ fun x => F (HSub.hSub (MeasureTheory.integral Î½ fun y => f { fst := x, snd := y }) (MeasureTheory.integral Î½ fun y => g { fst := x, snd := y })))","decl":"/-- Integrals commute with subtraction inside another integral.\n  `F` can be any measurable function. -/\ntheorem integral_fn_integral_sub â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ E') (hf : Integrable f (Î¼.prod Î½))\n    (hg : Integrable g (Î¼.prod Î½)) :\n    (âˆ« x, F (âˆ« y, f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼) =\n      âˆ« x, F ((âˆ« y, f (x, y) âˆ‚Î½) - âˆ« y, g (x, y) âˆ‚Î½) âˆ‚Î¼ := by\n  refine integral_congr_ae ?_\n  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g\n  simp [integral_sub h2f h2g]\n\n"}
{"name":"MeasureTheory.lintegral_fn_integral_sub","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf g : Prod Î± Î² â†’ E\nF : E â†’ ENNReal\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nhg : MeasureTheory.Integrable g (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun x => F (MeasureTheory.integral Î½ fun y => HSub.hSub (f { fst := x, snd := y }) (g { fst := x, snd := y }))) (MeasureTheory.lintegral Î¼ fun x => F (HSub.hSub (MeasureTheory.integral Î½ fun y => f { fst := x, snd := y }) (MeasureTheory.integral Î½ fun y => g { fst := x, snd := y })))","decl":"/-- Integrals commute with subtraction inside a lower Lebesgue integral.\n  `F` can be any function. -/\ntheorem lintegral_fn_integral_sub â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ â„â‰¥0âˆž) (hf : Integrable f (Î¼.prod Î½))\n    (hg : Integrable g (Î¼.prod Î½)) :\n    (âˆ«â» x, F (âˆ« y, f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼) =\n      âˆ«â» x, F ((âˆ« y, f (x, y) âˆ‚Î½) - âˆ« y, g (x, y) âˆ‚Î½) âˆ‚Î¼ := by\n  refine lintegral_congr_ae ?_\n  filter_upwards [hf.prod_right_ae, hg.prod_right_ae] with _ h2f h2g\n  simp [integral_sub h2f h2g]\n\n"}
{"name":"MeasureTheory.integral_integral_add","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf g : Prod Î± Î² â†’ E\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nhg : MeasureTheory.Integrable g (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => HAdd.hAdd (f { fst := x, snd := y }) (g { fst := x, snd := y })) (HAdd.hAdd (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => f { fst := x, snd := y }) (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => g { fst := x, snd := y }))","decl":"/-- Double integrals commute with addition. -/\ntheorem integral_integral_add â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.prod Î½))\n    (hg : Integrable g (Î¼.prod Î½)) :\n    (âˆ« x, âˆ« y, f (x, y) + g (x, y) âˆ‚Î½ âˆ‚Î¼) = (âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼) + âˆ« x, âˆ« y, g (x, y) âˆ‚Î½ âˆ‚Î¼ :=\n  (integral_fn_integral_add id hf hg).trans <|\n    integral_add hf.integral_prod_left hg.integral_prod_left\n\n"}
{"name":"MeasureTheory.integral_integral_add'","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf g : Prod Î± Î² â†’ E\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nhg : MeasureTheory.Integrable g (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => HAdd.hAdd f g { fst := x, snd := y }) (HAdd.hAdd (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => f { fst := x, snd := y }) (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => g { fst := x, snd := y }))","decl":"/-- Double integrals commute with addition. This is the version with `(f + g) (x, y)`\n  (instead of `f (x, y) + g (x, y)`) in the LHS. -/\ntheorem integral_integral_add' â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.prod Î½))\n    (hg : Integrable g (Î¼.prod Î½)) :\n    (âˆ« x, âˆ« y, (f + g) (x, y) âˆ‚Î½ âˆ‚Î¼) = (âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼) + âˆ« x, âˆ« y, g (x, y) âˆ‚Î½ âˆ‚Î¼ :=\n  integral_integral_add hf hg\n\n"}
{"name":"MeasureTheory.integral_integral_sub","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf g : Prod Î± Î² â†’ E\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nhg : MeasureTheory.Integrable g (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => HSub.hSub (f { fst := x, snd := y }) (g { fst := x, snd := y })) (HSub.hSub (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => f { fst := x, snd := y }) (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => g { fst := x, snd := y }))","decl":"/-- Double integrals commute with subtraction. -/\ntheorem integral_integral_sub â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.prod Î½))\n    (hg : Integrable g (Î¼.prod Î½)) :\n    (âˆ« x, âˆ« y, f (x, y) - g (x, y) âˆ‚Î½ âˆ‚Î¼) = (âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼) - âˆ« x, âˆ« y, g (x, y) âˆ‚Î½ âˆ‚Î¼ :=\n  (integral_fn_integral_sub id hf hg).trans <|\n    integral_sub hf.integral_prod_left hg.integral_prod_left\n\n"}
{"name":"MeasureTheory.integral_integral_sub'","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf g : Prod Î± Î² â†’ E\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nhg : MeasureTheory.Integrable g (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => HSub.hSub f g { fst := x, snd := y }) (HSub.hSub (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => f { fst := x, snd := y }) (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => g { fst := x, snd := y }))","decl":"/-- Double integrals commute with subtraction. This is the version with `(f - g) (x, y)`\n  (instead of `f (x, y) - g (x, y)`) in the LHS. -/\ntheorem integral_integral_sub' â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (hf : Integrable f (Î¼.prod Î½))\n    (hg : Integrable g (Î¼.prod Î½)) :\n    (âˆ« x, âˆ« y, (f - g) (x, y) âˆ‚Î½ âˆ‚Î¼) = (âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼) - âˆ« x, âˆ« y, g (x, y) âˆ‚Î½ âˆ‚Î¼ :=\n  integral_integral_sub hf hg\n\n"}
{"name":"MeasureTheory.continuous_integral_integral","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nâŠ¢ Continuous fun f => MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => â†‘â†‘f { fst := x, snd := y }","decl":"/-- The map that sends an LÂ¹-function `f : Î± Ã— Î² â†’ E` to `âˆ«âˆ«f` is continuous. -/\ntheorem continuous_integral_integral :\n    Continuous fun f : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E => âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼ := by\n  rw [continuous_iff_continuousAt]; intro g\n  refine\n    tendsto_integral_of_L1 _ (L1.integrable_coeFn g).integral_prod_left\n      (Eventually.of_forall fun h => (L1.integrable_coeFn h).integral_prod_left) ?_\n  simp_rw [â† lintegral_fn_integral_sub _ (L1.integrable_coeFn _) (L1.integrable_coeFn g)]\n  apply tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds _ (fun i => zero_le _) _\n  Â· exact fun i => âˆ«â» x, âˆ«â» y, â€–i (x, y) - g (x, y)â€–â‚‘ âˆ‚Î½ âˆ‚Î¼\n  swap; Â· exact fun i => lintegral_mono fun x => enorm_integral_le_lintegral_enorm _\n  show\n    Tendsto (fun i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E => âˆ«â» x, âˆ«â» y : Î², â€–i (x, y) - g (x, y)â€–â‚‘ âˆ‚Î½ âˆ‚Î¼) (ð“ g)\n      (ð“ 0)\n  have this (i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E) : Measurable fun z => â€–i z - g zâ€–â‚‘ :=\n    ((Lp.stronglyMeasurable i).sub (Lp.stronglyMeasurable g)).enorm\n  -- Porting note: was\n  -- simp_rw [â† lintegral_prod_of_measurable _ (this _), â† L1.ofReal_norm_sub_eq_lintegral, â†\n  --   ofReal_zero]\n  conv =>\n    congr\n    ext\n    rw [â† lintegral_prod_of_measurable _ (this _), â† L1.ofReal_norm_sub_eq_lintegral]\n  rw [â† ofReal_zero]\n  refine (continuous_ofReal.tendsto 0).comp ?_\n  rw [â† tendsto_iff_norm_sub_tendsto_zero]; exact tendsto_id\n\n"}
{"name":"MeasureTheory.integral_prod","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf : Prod Î± Î² â†’ E\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.integral (Î¼.prod Î½) fun z => f z) (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => f { fst := x, snd := y })","decl":"/-- **Fubini's Theorem**: For integrable functions on `Î± Ã— Î²`,\n  the Bochner integral of `f` is equal to the iterated Bochner integral.\n  `integrable_prod_iff` can be useful to show that the function in question in integrable.\n  `MeasureTheory.Integrable.integral_prod_right` is useful to show that the inner integral\n  of the right-hand side is integrable. -/\ntheorem integral_prod (f : Î± Ã— Î² â†’ E) (hf : Integrable f (Î¼.prod Î½)) :\n    âˆ« z, f z âˆ‚Î¼.prod Î½ = âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼ := by\n  by_cases hE : CompleteSpace E; swap; Â· simp only [integral, dif_neg hE]\n  revert f\n  apply Integrable.induction\n  Â· intro c s hs h2s\n    simp_rw [integral_indicator hs, â† indicator_comp_right, Function.comp_def,\n      integral_indicator (measurable_prod_mk_left hs), setIntegral_const, integral_smul_const,\n      integral_toReal (measurable_measure_prod_mk_left hs).aemeasurable\n        (ae_measure_lt_top hs h2s.ne)]\n    rw [prod_apply hs]\n  Â· rintro f g - i_f i_g hf hg\n    simp_rw [integral_add' i_f i_g, integral_integral_add' i_f i_g, hf, hg]\n  Â· exact isClosed_eq continuous_integral continuous_integral_integral\n  Â· rintro f g hfg - hf; convert hf using 1\n    Â· exact integral_congr_ae hfg.symm\n    Â· apply integral_congr_ae\n      filter_upwards [ae_ae_of_ae_prod hfg] with x hfgx using integral_congr_ae (ae_eq_symm hfgx)\n\n"}
{"name":"MeasureTheory.integral_prod_symm","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf : Prod Î± Î² â†’ E\nhf : MeasureTheory.Integrable f (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.integral (Î¼.prod Î½) fun z => f z) (MeasureTheory.integral Î½ fun y => MeasureTheory.integral Î¼ fun x => f { fst := x, snd := y })","decl":"/-- Symmetric version of **Fubini's Theorem**: For integrable functions on `Î± Ã— Î²`,\n  the Bochner integral of `f` is equal to the iterated Bochner integral.\n  This version has the integrals on the right-hand side in the other order. -/\ntheorem integral_prod_symm (f : Î± Ã— Î² â†’ E) (hf : Integrable f (Î¼.prod Î½)) :\n    âˆ« z, f z âˆ‚Î¼.prod Î½ = âˆ« y, âˆ« x, f (x, y) âˆ‚Î¼ âˆ‚Î½ := by\n  rw [â† integral_prod_swap f]; exact integral_prod _ hf.swap\n\n"}
{"name":"MeasureTheory.integral_integral","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf : Î± â†’ Î² â†’ E\nhf : MeasureTheory.Integrable (Function.uncurry f) (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => f x y) (MeasureTheory.integral (Î¼.prod Î½) fun z => f z.1 z.2)","decl":"/-- Reversed version of **Fubini's Theorem**. -/\ntheorem integral_integral {f : Î± â†’ Î² â†’ E} (hf : Integrable (uncurry f) (Î¼.prod Î½)) :\n    âˆ« x, âˆ« y, f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« z, f z.1 z.2 âˆ‚Î¼.prod Î½ :=\n  (integral_prod _ hf).symm\n\n"}
{"name":"MeasureTheory.integral_integral_symm","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf : Î± â†’ Î² â†’ E\nhf : MeasureTheory.Integrable (Function.uncurry f) (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => f x y) (MeasureTheory.integral (Î½.prod Î¼) fun z => f z.2 z.1)","decl":"/-- Reversed version of **Fubini's Theorem** (symmetric version). -/\ntheorem integral_integral_symm {f : Î± â†’ Î² â†’ E} (hf : Integrable (uncurry f) (Î¼.prod Î½)) :\n    âˆ« x, âˆ« y, f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« z, f z.2 z.1 âˆ‚Î½.prod Î¼ :=\n  (integral_prod_symm _ hf.swap).symm\n\n"}
{"name":"MeasureTheory.integral_integral_swap","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf : Î± â†’ Î² â†’ E\nhf : MeasureTheory.Integrable (Function.uncurry f) (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => f x y) (MeasureTheory.integral Î½ fun y => MeasureTheory.integral Î¼ fun x => f x y)","decl":"/-- Change the order of Bochner integration. -/\ntheorem integral_integral_swap â¦ƒf : Î± â†’ Î² â†’ Eâ¦„ (hf : Integrable (uncurry f) (Î¼.prod Î½)) :\n    âˆ« x, âˆ« y, f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« y, âˆ« x, f x y âˆ‚Î¼ âˆ‚Î½ :=\n  (integral_integral hf).trans (integral_prod_symm _ hf)\n\n"}
{"name":"MeasureTheory.setIntegral_prod","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf : Prod Î± Î² â†’ E\ns : Set Î±\nt : Set Î²\nhf : MeasureTheory.IntegrableOn f (SProd.sprod s t) (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.integral ((Î¼.prod Î½).restrict (SProd.sprod s t)) fun z => f z) (MeasureTheory.integral (Î¼.restrict s) fun x => MeasureTheory.integral (Î½.restrict t) fun y => f { fst := x, snd := y })","decl":"/-- **Fubini's Theorem** for set integrals. -/\ntheorem setIntegral_prod (f : Î± Ã— Î² â†’ E) {s : Set Î±} {t : Set Î²}\n    (hf : IntegrableOn f (s Ã—Ë¢ t) (Î¼.prod Î½)) :\n    âˆ« z in s Ã—Ë¢ t, f z âˆ‚Î¼.prod Î½ = âˆ« x in s, âˆ« y in t, f (x, y) âˆ‚Î½ âˆ‚Î¼ := by\n  simp only [â† Measure.prod_restrict s t, IntegrableOn] at hf âŠ¢\n  exact integral_prod f hf\n\n"}
{"name":"MeasureTheory.integral_prod_smul","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâ· : MeasurableSpace Î±\ninstâœâ¶ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : MeasureTheory.SFinite Î½\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : MeasureTheory.SFinite Î¼\nð•œ : Type u_5\ninstâœÂ¹ : RCLike ð•œ\ninstâœ : NormedSpace ð•œ E\nf : Î± â†’ ð•œ\ng : Î² â†’ E\nâŠ¢ Eq (MeasureTheory.integral (Î¼.prod Î½) fun z => HSMul.hSMul (f z.1) (g z.2)) (HSMul.hSMul (MeasureTheory.integral Î¼ fun x => f x) (MeasureTheory.integral Î½ fun y => g y))","decl":"theorem integral_prod_smul {ð•œ : Type*} [RCLike ð•œ] [NormedSpace ð•œ E] (f : Î± â†’ ð•œ) (g : Î² â†’ E) :\n    âˆ« z, f z.1 â€¢ g z.2 âˆ‚Î¼.prod Î½ = (âˆ« x, f x âˆ‚Î¼) â€¢ âˆ« y, g y âˆ‚Î½ := by\n  by_cases hE : CompleteSpace E; swap; Â· simp [integral, hE]\n  by_cases h : Integrable (fun z : Î± Ã— Î² => f z.1 â€¢ g z.2) (Î¼.prod Î½)\n  Â· rw [integral_prod _ h]\n    simp_rw [integral_smul, integral_smul_const]\n  have H : Â¬Integrable f Î¼ âˆ¨ Â¬Integrable g Î½ := by\n    contrapose! h\n    exact h.1.prod_smul h.2\n  cases' H with H H <;> simp [integral_undef h, integral_undef H]\n\n"}
{"name":"MeasureTheory.integral_prod_mul","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : MeasureTheory.SFinite Î¼\nL : Type u_5\ninstâœ : RCLike L\nf : Î± â†’ L\ng : Î² â†’ L\nâŠ¢ Eq (MeasureTheory.integral (Î¼.prod Î½) fun z => HMul.hMul (f z.1) (g z.2)) (HMul.hMul (MeasureTheory.integral Î¼ fun x => f x) (MeasureTheory.integral Î½ fun y => g y))","decl":"theorem integral_prod_mul {L : Type*} [RCLike L] (f : Î± â†’ L) (g : Î² â†’ L) :\n    âˆ« z, f z.1 * g z.2 âˆ‚Î¼.prod Î½ = (âˆ« x, f x âˆ‚Î¼) * âˆ« y, g y âˆ‚Î½ :=\n  integral_prod_smul f g\n\n"}
{"name":"MeasureTheory.setIntegral_prod_mul","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : MeasureTheory.SFinite Î¼\nL : Type u_5\ninstâœ : RCLike L\nf : Î± â†’ L\ng : Î² â†’ L\ns : Set Î±\nt : Set Î²\nâŠ¢ Eq (MeasureTheory.integral ((Î¼.prod Î½).restrict (SProd.sprod s t)) fun z => HMul.hMul (f z.1) (g z.2)) (HMul.hMul (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î½.restrict t) fun y => g y))","decl":"theorem setIntegral_prod_mul {L : Type*} [RCLike L] (f : Î± â†’ L) (g : Î² â†’ L) (s : Set Î±)\n    (t : Set Î²) :\n    âˆ« z in s Ã—Ë¢ t, f z.1 * g z.2 âˆ‚Î¼.prod Î½ = (âˆ« x in s, f x âˆ‚Î¼) * âˆ« y in t, g y âˆ‚Î½ := by\n  -- Porting note: added\n  rw [â† Measure.prod_restrict s t]\n  apply integral_prod_mul\n\n"}
{"name":"MeasureTheory.integral_fun_snd","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf : Î² â†’ E\nâŠ¢ Eq (MeasureTheory.integral (Î¼.prod Î½) fun z => f z.2) (HSMul.hSMul (Î¼ Set.univ).toReal (MeasureTheory.integral Î½ fun y => f y))","decl":"theorem integral_fun_snd (f : Î² â†’ E) : âˆ« z, f z.2 âˆ‚Î¼.prod Î½ = (Î¼ univ).toReal â€¢ âˆ« y, f y âˆ‚Î½ := by\n  simpa using integral_prod_smul (1 : Î± â†’ â„) f\n\n"}
{"name":"MeasureTheory.integral_fun_fst","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nÎ½ : MeasureTheory.Measure Î²\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.integral (Î¼.prod Î½) fun z => f z.1) (HSMul.hSMul (Î½ Set.univ).toReal (MeasureTheory.integral Î¼ fun x => f x))","decl":"theorem integral_fun_fst (f : Î± â†’ E) : âˆ« z, f z.1 âˆ‚Î¼.prod Î½ = (Î½ univ).toReal â€¢ âˆ« x, f x âˆ‚Î¼ := by\n  rw [â† integral_prod_swap]\n  apply integral_fun_snd\n\n"}
{"name":"MeasureTheory.integral_integral_swap_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Integral.Prod","initialProofState":"E : Type u_3\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Real E\nX : Type u_5\nY : Type u_6\ninstâœâ· : TopologicalSpace X\ninstâœâ¶ : TopologicalSpace Y\ninstâœâµ : MeasurableSpace X\ninstâœâ´ : MeasurableSpace Y\ninstâœÂ³ : OpensMeasurableSpace X\ninstâœÂ² : OpensMeasurableSpace Y\nf : X â†’ Y â†’ E\nhf : Continuous (Function.uncurry f)\nh'f : HasCompactSupport (Function.uncurry f)\nÎ¼ : MeasureTheory.Measure X\nÎ½ : MeasureTheory.Measure Y\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼\ninstâœ : MeasureTheory.IsFiniteMeasureOnCompacts Î½\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => MeasureTheory.integral Î½ fun y => f x y) (MeasureTheory.integral Î½ fun y => MeasureTheory.integral Î¼ fun x => f x y)","decl":"/-- A version of *Fubini theorem* for continuous functions with compact support: one may swap\nthe order of integration with respect to locally finite measures. One does not assume that the\nmeasures are Ïƒ-finite, contrary to the usual Fubini theorem. -/\nlemma integral_integral_swap_of_hasCompactSupport\n    {f : X â†’ Y â†’ E} (hf : Continuous f.uncurry) (h'f : HasCompactSupport f.uncurry)\n    {Î¼ : Measure X} {Î½ : Measure Y} [IsFiniteMeasureOnCompacts Î¼] [IsFiniteMeasureOnCompacts Î½] :\n    âˆ« x, (âˆ« y, f x y âˆ‚Î½) âˆ‚Î¼ = âˆ« y, (âˆ« x, f x y âˆ‚Î¼) âˆ‚Î½ := by\n  let U := Prod.fst '' (tsupport f.uncurry)\n  have : Fact (Î¼ U < âˆž) := âŸ¨(IsCompact.image h'f continuous_fst).measure_lt_topâŸ©\n  let V := Prod.snd '' (tsupport f.uncurry)\n  have : Fact (Î½ V < âˆž) := âŸ¨(IsCompact.image h'f continuous_snd).measure_lt_topâŸ©\n  calc\n  âˆ« x, (âˆ« y, f x y âˆ‚Î½) âˆ‚Î¼ = âˆ« x, (âˆ« y in V, f x y âˆ‚Î½) âˆ‚Î¼ := by\n    congr 1 with x\n    apply (setIntegral_eq_integral_of_forall_compl_eq_zero (fun y hy â†¦ ?_)).symm\n    contrapose! hy\n    have : (x, y) âˆˆ Function.support f.uncurry := hy\n    exact mem_image_of_mem _ (subset_tsupport _ this)\n  _ = âˆ« x in U, (âˆ« y in V, f x y âˆ‚Î½) âˆ‚Î¼ := by\n    apply (setIntegral_eq_integral_of_forall_compl_eq_zero (fun x hx â†¦ ?_)).symm\n    have : âˆ€ y, f x y = 0 := by\n      intro y\n      contrapose! hx\n      have : (x, y) âˆˆ Function.support f.uncurry := hx\n      exact mem_image_of_mem _ (subset_tsupport _ this)\n    simp [this]\n  _ = âˆ« y in V, (âˆ« x in U, f x y âˆ‚Î¼) âˆ‚Î½ := by\n    apply integral_integral_swap\n    apply (integrableOn_iff_integrable_of_support_subset (subset_tsupport f.uncurry)).mp\n    refine âŸ¨(h'f.stronglyMeasurable_of_prod hf).aestronglyMeasurable, ?_âŸ©\n    obtain âŸ¨C, hCâŸ© : âˆƒ C, âˆ€ p, â€–f.uncurry pâ€– â‰¤ C := hf.bounded_above_of_compact_support h'f\n    exact hasFiniteIntegral_of_bounded (C := C) (Eventually.of_forall hC)\n  _ = âˆ« y, (âˆ« x in U, f x y âˆ‚Î¼) âˆ‚Î½ := by\n    apply setIntegral_eq_integral_of_forall_compl_eq_zero (fun y hy â†¦ ?_)\n    have : âˆ€ x, f x y = 0 := by\n      intro x\n      contrapose! hy\n      have : (x, y) âˆˆ Function.support f.uncurry := hy\n      exact mem_image_of_mem _ (subset_tsupport _ this)\n    simp [this]\n  _ = âˆ« y, (âˆ« x, f x y âˆ‚Î¼) âˆ‚Î½ := by\n    congr 1 with y\n    apply setIntegral_eq_integral_of_forall_compl_eq_zero (fun x hx â†¦ ?_)\n    contrapose! hx\n    have : (x, y) âˆˆ Function.support f.uncurry := hx\n    exact mem_image_of_mem _ (subset_tsupport _ this)\n\n"}
