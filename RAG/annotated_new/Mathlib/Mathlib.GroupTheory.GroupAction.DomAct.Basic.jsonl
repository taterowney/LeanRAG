{"name":"DomAddAct.instIsAddLeftCancelOfAddOpposite","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝¹ : Add (AddOpposite M)\ninst✝ : IsLeftCancelAdd (AddOpposite M)\n⊢ IsLeftCancelAdd (DomAddAct M)","decl":"@[to_additive] instance [Mul Mᵐᵒᵖ] [IsLeftCancelMul Mᵐᵒᵖ] : IsLeftCancelMul Mᵈᵐᵃ := ‹_›\n"}
{"name":"DomMulAct.instIsLeftCancelMulOfMulOpposite","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝¹ : Mul (MulOpposite M)\ninst✝ : IsLeftCancelMul (MulOpposite M)\n⊢ IsLeftCancelMul (DomMulAct M)","decl":"@[to_additive] instance [Mul Mᵐᵒᵖ] [IsLeftCancelMul Mᵐᵒᵖ] : IsLeftCancelMul Mᵈᵐᵃ := ‹_›\n"}
{"name":"DomAddAct.instIsAddRightCancelOfAddOpposite","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝¹ : Add (AddOpposite M)\ninst✝ : IsRightCancelAdd (AddOpposite M)\n⊢ IsRightCancelAdd (DomAddAct M)","decl":"@[to_additive] instance [Mul Mᵐᵒᵖ] [IsRightCancelMul Mᵐᵒᵖ] : IsRightCancelMul Mᵈᵐᵃ := ‹_›\n"}
{"name":"DomMulAct.instIsRightCancelMulOfMulOpposite","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝¹ : Mul (MulOpposite M)\ninst✝ : IsRightCancelMul (MulOpposite M)\n⊢ IsRightCancelMul (DomMulAct M)","decl":"@[to_additive] instance [Mul Mᵐᵒᵖ] [IsRightCancelMul Mᵐᵒᵖ] : IsRightCancelMul Mᵈᵐᵃ := ‹_›\n"}
{"name":"DomMulAct.instIsCancelMulOfMulOpposite","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝¹ : Mul (MulOpposite M)\ninst✝ : IsCancelMul (MulOpposite M)\n⊢ IsCancelMul (DomMulAct M)","decl":"@[to_additive] instance [Mul Mᵐᵒᵖ] [IsCancelMul Mᵐᵒᵖ] : IsCancelMul Mᵈᵐᵃ := ‹_›\n\n"}
{"name":"DomAddAct.instIsAddCancelOfAddOpposite","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝¹ : Add (AddOpposite M)\ninst✝ : IsCancelAdd (AddOpposite M)\n⊢ IsCancelAdd (DomAddAct M)","decl":"@[to_additive] instance [Mul Mᵐᵒᵖ] [IsCancelMul Mᵐᵒᵖ] : IsCancelMul Mᵈᵐᵃ := ‹_›\n\n"}
{"name":"DomAddAct.mk_zero","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : Zero M\n⊢ Eq (DomAddAct.mk 0) 0","decl":"@[to_additive (attr := simp)]\nlemma mk_one [One M] : mk (1 : M) = 1 := rfl\n\n"}
{"name":"DomMulAct.mk_one","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : One M\n⊢ Eq (DomMulAct.mk 1) 1","decl":"@[to_additive (attr := simp)]\nlemma mk_one [One M] : mk (1 : M) = 1 := rfl\n\n"}
{"name":"DomMulAct.symm_mk_one","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : One M\n⊢ Eq (DomMulAct.mk.symm 1) 1","decl":"@[to_additive (attr := simp)]\nlemma symm_mk_one [One M] : mk.symm (1 : Mᵈᵐᵃ) = 1 := rfl\n\n"}
{"name":"DomAddAct.symm_mk_zero","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : Zero M\n⊢ Eq (DomAddAct.mk.symm 0) 0","decl":"@[to_additive (attr := simp)]\nlemma symm_mk_one [One M] : mk.symm (1 : Mᵈᵐᵃ) = 1 := rfl\n\n"}
{"name":"DomAddAct.mk_add","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\na b : M\n⊢ Eq (DomAddAct.mk (HAdd.hAdd a b)) (HAdd.hAdd (DomAddAct.mk b) (DomAddAct.mk a))","decl":"@[to_additive (attr := simp)]\nlemma mk_mul [Mul M] (a b : M) : mk (a * b) = mk b * mk a := rfl\n\n"}
{"name":"DomMulAct.mk_mul","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\na b : M\n⊢ Eq (DomMulAct.mk (HMul.hMul a b)) (HMul.hMul (DomMulAct.mk b) (DomMulAct.mk a))","decl":"@[to_additive (attr := simp)]\nlemma mk_mul [Mul M] (a b : M) : mk (a * b) = mk b * mk a := rfl\n\n"}
{"name":"DomMulAct.symm_mk_mul","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : Mul M\na b : DomMulAct M\n⊢ Eq (DomMulAct.mk.symm (HMul.hMul a b)) (HMul.hMul (DomMulAct.mk.symm b) (DomMulAct.mk.symm a))","decl":"@[to_additive (attr := simp)]\nlemma symm_mk_mul [Mul M] (a b : Mᵈᵐᵃ) : mk.symm (a * b) = mk.symm b * mk.symm a := rfl\n\n"}
{"name":"DomAddAct.symm_mk_add","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : Add M\na b : DomAddAct M\n⊢ Eq (DomAddAct.mk.symm (HAdd.hAdd a b)) (HAdd.hAdd (DomAddAct.mk.symm b) (DomAddAct.mk.symm a))","decl":"@[to_additive (attr := simp)]\nlemma symm_mk_mul [Mul M] (a b : Mᵈᵐᵃ) : mk.symm (a * b) = mk.symm b * mk.symm a := rfl\n\n"}
{"name":"DomMulAct.mk_inv","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : Inv M\na : M\n⊢ Eq (DomMulAct.mk (Inv.inv a)) (Inv.inv (DomMulAct.mk a))","decl":"@[to_additive (attr := simp)]\nlemma mk_inv [Inv M] (a : M) : mk (a⁻¹) = (mk a)⁻¹ := rfl\n\n"}
{"name":"DomAddAct.mk_neg","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : Neg M\na : M\n⊢ Eq (DomAddAct.mk (Neg.neg a)) (Neg.neg (DomAddAct.mk a))","decl":"@[to_additive (attr := simp)]\nlemma mk_inv [Inv M] (a : M) : mk (a⁻¹) = (mk a)⁻¹ := rfl\n\n"}
{"name":"DomAddAct.symm_mk_neg","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : Neg M\na : DomAddAct M\n⊢ Eq (DomAddAct.mk.symm (Neg.neg a)) (Neg.neg (DomAddAct.mk.symm a))","decl":"@[to_additive (attr := simp)]\nlemma symm_mk_inv [Inv M] (a : Mᵈᵐᵃ) : mk.symm (a⁻¹) = (mk.symm a)⁻¹ := rfl\n\n"}
{"name":"DomMulAct.symm_mk_inv","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : Inv M\na : DomMulAct M\n⊢ Eq (DomMulAct.mk.symm (Inv.inv a)) (Inv.inv (DomMulAct.mk.symm a))","decl":"@[to_additive (attr := simp)]\nlemma symm_mk_inv [Inv M] (a : Mᵈᵐᵃ) : mk.symm (a⁻¹) = (mk.symm a)⁻¹ := rfl\n\n"}
{"name":"DomAddAct.mk_nsmul","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : M\nn : Nat\n⊢ Eq (DomAddAct.mk (HSMul.hSMul n a)) (HSMul.hSMul n (DomAddAct.mk a))","decl":"@[to_additive (attr := simp)]\nlemma mk_pow [Monoid M] (a : M) (n : ℕ) : mk (a ^ n) = mk a ^ n := rfl\n\n"}
{"name":"DomMulAct.mk_pow","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nn : Nat\n⊢ Eq (DomMulAct.mk (HPow.hPow a n)) (HPow.hPow (DomMulAct.mk a) n)","decl":"@[to_additive (attr := simp)]\nlemma mk_pow [Monoid M] (a : M) (n : ℕ) : mk (a ^ n) = mk a ^ n := rfl\n\n"}
{"name":"DomAddAct.symm_mk_nsmul","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\na : DomAddAct M\nn : Nat\n⊢ Eq (DomAddAct.mk.symm (HSMul.hSMul n a)) (HSMul.hSMul n (DomAddAct.mk.symm a))","decl":"@[to_additive (attr := simp)]\nlemma symm_mk_pow [Monoid M] (a : Mᵈᵐᵃ) (n : ℕ) : mk.symm (a ^ n) = mk.symm a ^ n := rfl\n\n"}
{"name":"DomMulAct.symm_mk_pow","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : DomMulAct M\nn : Nat\n⊢ Eq (DomMulAct.mk.symm (HPow.hPow a n)) (HPow.hPow (DomMulAct.mk.symm a) n)","decl":"@[to_additive (attr := simp)]\nlemma symm_mk_pow [Monoid M] (a : Mᵈᵐᵃ) (n : ℕ) : mk.symm (a ^ n) = mk.symm a ^ n := rfl\n\n"}
{"name":"DomAddAct.mk_zsmul","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : SubNegMonoid M\na : M\nn : Int\n⊢ Eq (DomAddAct.mk (HSMul.hSMul n a)) (HSMul.hSMul n (DomAddAct.mk a))","decl":"@[to_additive (attr := simp)]\nlemma mk_zpow [DivInvMonoid M] (a : M) (n : ℤ) : mk (a ^ n) = mk a ^ n := rfl\n\n"}
{"name":"DomMulAct.mk_zpow","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : DivInvMonoid M\na : M\nn : Int\n⊢ Eq (DomMulAct.mk (HPow.hPow a n)) (HPow.hPow (DomMulAct.mk a) n)","decl":"@[to_additive (attr := simp)]\nlemma mk_zpow [DivInvMonoid M] (a : M) (n : ℤ) : mk (a ^ n) = mk a ^ n := rfl\n\n"}
{"name":"DomAddAct.symm_mk_zsmul","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : SubNegMonoid M\na : DomAddAct M\nn : Int\n⊢ Eq (DomAddAct.mk.symm (HSMul.hSMul n a)) (HSMul.hSMul n (DomAddAct.mk.symm a))","decl":"@[to_additive (attr := simp)]\nlemma symm_mk_zpow [DivInvMonoid M] (a : Mᵈᵐᵃ) (n : ℤ) : mk.symm (a ^ n) = mk.symm a ^ n := rfl\n\n"}
{"name":"DomMulAct.symm_mk_zpow","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\ninst✝ : DivInvMonoid M\na : DomMulAct M\nn : Int\n⊢ Eq (DomMulAct.mk.symm (HPow.hPow a n)) (HPow.hPow (DomMulAct.mk.symm a) n)","decl":"@[to_additive (attr := simp)]\nlemma symm_mk_zpow [DivInvMonoid M] (a : Mᵈᵐᵃ) (n : ℤ) : mk.symm (a ^ n) = mk.symm a ^ n := rfl\n\n"}
{"name":"DomMulAct.smul_apply","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\nβ : Type u_2\nα : Type u_3\ninst✝ : SMul M α\nc : DomMulAct M\nf : α → β\na : α\n⊢ Eq (HSMul.hSMul c f a) (f (HSMul.hSMul (DomMulAct.mk.symm c) a))","decl":"@[to_additive]\ntheorem smul_apply [SMul M α] (c : Mᵈᵐᵃ) (f : α → β) (a : α) : (c • f) a = f (mk.symm c • a) := rfl\n\n"}
{"name":"DomAddAct.vadd_apply","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\nβ : Type u_2\nα : Type u_3\ninst✝ : VAdd M α\nc : DomAddAct M\nf : α → β\na : α\n⊢ Eq (HVAdd.hVAdd c f a) (f (HVAdd.hVAdd (DomAddAct.mk.symm c) a))","decl":"@[to_additive]\ntheorem smul_apply [SMul M α] (c : Mᵈᵐᵃ) (f : α → β) (a : α) : (c • f) a = f (mk.symm c • a) := rfl\n\n"}
{"name":"DomMulAct.instSMulCommClassForall","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\nβ : Type u_2\nα : Type u_3\nN : Type u_4\ninst✝¹ : SMul M α\ninst✝ : SMul N β\n⊢ SMulCommClass (DomMulAct M) N (α → β)","decl":"@[to_additive]\ninstance [SMul M α] [SMul N β] : SMulCommClass Mᵈᵐᵃ N (α → β) where\n  smul_comm _ _ _ := rfl\n\n"}
{"name":"DomAddAct.instVAddCommClassForall","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\nβ : Type u_2\nα : Type u_3\nN : Type u_4\ninst✝¹ : VAdd M α\ninst✝ : VAdd N β\n⊢ VAddCommClass (DomAddAct M) N (α → β)","decl":"@[to_additive]\ninstance [SMul M α] [SMul N β] : SMulCommClass Mᵈᵐᵃ N (α → β) where\n  smul_comm _ _ _ := rfl\n\n"}
{"name":"DomMulAct.instSMulCommClassForall_1","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\nβ : Type u_2\nα : Type u_3\nN : Type u_4\ninst✝¹ : SMul M α\ninst✝ : SMul N β\n⊢ SMulCommClass N (DomMulAct M) (α → β)","decl":"@[to_additive]\ninstance [SMul M α] [SMul N β] : SMulCommClass N Mᵈᵐᵃ (α → β) where\n  smul_comm _ _ _ := rfl\n\n"}
{"name":"DomAddAct.instVAddCommClassForall_1","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\nβ : Type u_2\nα : Type u_3\nN : Type u_4\ninst✝¹ : VAdd M α\ninst✝ : VAdd N β\n⊢ VAddCommClass N (DomAddAct M) (α → β)","decl":"@[to_additive]\ninstance [SMul M α] [SMul N β] : SMulCommClass N Mᵈᵐᵃ (α → β) where\n  smul_comm _ _ _ := rfl\n\n"}
{"name":"DomMulAct.instSMulCommClassForall_2","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\nβ : Type u_2\nα : Type u_3\nN : Type u_4\ninst✝² : SMul M α\ninst✝¹ : SMul N α\ninst✝ : SMulCommClass M N α\n⊢ SMulCommClass (DomMulAct M) (DomMulAct N) (α → β)","decl":"@[to_additive]\ninstance [SMul M α] [SMul N α] [SMulCommClass M N α] : SMulCommClass Mᵈᵐᵃ Nᵈᵐᵃ (α → β) where\n  smul_comm _ _ f := funext fun _ ↦ congr_arg f (smul_comm _ _ _).symm\n\n"}
{"name":"DomAddAct.instVAddCommClassForall_2","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\nβ : Type u_2\nα : Type u_3\nN : Type u_4\ninst✝² : VAdd M α\ninst✝¹ : VAdd N α\ninst✝ : VAddCommClass M N α\n⊢ VAddCommClass (DomAddAct M) (DomAddAct N) (α → β)","decl":"@[to_additive]\ninstance [SMul M α] [SMul N α] [SMulCommClass M N α] : SMulCommClass Mᵈᵐᵃ Nᵈᵐᵃ (α → β) where\n  smul_comm _ _ f := funext fun _ ↦ congr_arg f (smul_comm _ _ _).symm\n\n"}
{"name":"DomMulAct.instFaithfulSMulForallOfNontrivial","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\nβ : Type u_2\nα : Type u_3\ninst✝² : SMul M α\ninst✝¹ : FaithfulSMul M α\ninst✝ : Nontrivial β\n⊢ FaithfulSMul (DomMulAct M) (α → β)","decl":"@[to_additive]\ninstance [SMul M α] [FaithfulSMul M α] [Nontrivial β] : FaithfulSMul Mᵈᵐᵃ (α → β) where\n  eq_of_smul_eq_smul {c₁ c₂} h := mk.symm.injective <| eq_of_smul_eq_smul fun a : α ↦ by\n    rcases exists_pair_ne β with ⟨x, y, hne⟩\n    contrapose! hne\n    haveI := Classical.decEq α\n    replace h := congr_fun (h (update (const α x) (mk.symm c₂ • a) y)) a\n    simpa [smul_apply, hne] using h\n\n"}
{"name":"DomAddAct.instFaithfulVAddForallOfNontrivial","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_1\nβ : Type u_2\nα : Type u_3\ninst✝² : VAdd M α\ninst✝¹ : FaithfulVAdd M α\ninst✝ : Nontrivial β\n⊢ FaithfulVAdd (DomAddAct M) (α → β)","decl":"@[to_additive]\ninstance [SMul M α] [FaithfulSMul M α] [Nontrivial β] : FaithfulSMul Mᵈᵐᵃ (α → β) where\n  eq_of_smul_eq_smul {c₁ c₂} h := mk.symm.injective <| eq_of_smul_eq_smul fun a : α ↦ by\n    rcases exists_pair_ne β with ⟨x, y, hne⟩\n    contrapose! hne\n    haveI := Classical.decEq α\n    replace h := congr_fun (h (update (const α x) (mk.symm c₂ • a) y)) a\n    simpa [smul_apply, hne] using h\n\n"}
{"name":"DomMulAct.instSMulCommClassMonoidHom","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_5\nM' : Type u_6\nA : Type u_7\nB : Type u_8\ninst✝⁶ : Monoid M\ninst✝⁵ : Monoid A\ninst✝⁴ : MulDistribMulAction M A\ninst✝³ : MulOneClass B\ninst✝² : Monoid M'\ninst✝¹ : MulDistribMulAction M' A\ninst✝ : SMulCommClass M M' A\n⊢ SMulCommClass (DomMulAct M) (DomMulAct M') (MonoidHom A B)","decl":"instance [Monoid M'] [MulDistribMulAction M' A] [SMulCommClass M M' A] :\n    SMulCommClass Mᵈᵐᵃ M'ᵈᵐᵃ (A →* B) :=\n  DFunLike.coe_injective.smulCommClass (fun _ _ ↦ rfl) (fun _ _ ↦ rfl)\n\n"}
{"name":"DomMulAct.smul_monoidHom_apply","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_5\nA : Type u_7\nB : Type u_8\ninst✝³ : Monoid M\ninst✝² : Monoid A\ninst✝¹ : MulDistribMulAction M A\ninst✝ : MulOneClass B\nc : DomMulAct M\nf : MonoidHom A B\na : A\n⊢ Eq ((HSMul.hSMul c f) a) (f (HSMul.hSMul (DomMulAct.mk.symm c) a))","decl":"theorem smul_monoidHom_apply (c : Mᵈᵐᵃ) (f : A →* B) (a : A) : (c • f) a = f (mk.symm c • a) :=\n  rfl\n\n"}
{"name":"DomMulAct.mk_smul_monoidHom_apply","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"M : Type u_5\nA : Type u_7\nB : Type u_8\ninst✝³ : Monoid M\ninst✝² : Monoid A\ninst✝¹ : MulDistribMulAction M A\ninst✝ : MulOneClass B\nc : M\nf : MonoidHom A B\na : A\n⊢ Eq ((HSMul.hSMul (DomMulAct.mk c) f) a) (f (HSMul.hSMul c a))","decl":"@[simp]\ntheorem mk_smul_monoidHom_apply (c : M) (f : A →* B) (a : A) : (mk c • f) a = f (c • a) := rfl\n\n"}
{"name":"DomMulAct.instSMulCommClassAddMonoidHom","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"A : Type u_5\nB : Type u_6\nM : Type u_7\nM' : Type u_8\ninst✝⁴ : AddMonoid A\ninst✝³ : DistribSMul M A\ninst✝² : AddZeroClass B\ninst✝¹ : DistribSMul M' A\ninst✝ : SMulCommClass M M' A\n⊢ SMulCommClass (DomMulAct M) (DomMulAct M') (AddMonoidHom A B)","decl":"instance [DistribSMul M' A] [SMulCommClass M M' A] : SMulCommClass Mᵈᵐᵃ M'ᵈᵐᵃ (A →+ B) :=\n  DFunLike.coe_injective.smulCommClass (fun _ _ ↦ rfl) (fun _ _ ↦ rfl)\n\n"}
{"name":"DomMulAct.instSMulCommClassAddMonoidHom_1","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"A : Type u_5\nB : Type u_6\nM : Type u_7\nM' : Type u_8\ninst✝³ : AddMonoid A\ninst✝² : DistribSMul M A\ninst✝¹ : AddZeroClass B\ninst✝ : DistribSMul M' B\n⊢ SMulCommClass (DomMulAct M) M' (AddMonoidHom A B)","decl":"instance [DistribSMul M' B] : SMulCommClass Mᵈᵐᵃ M' (A →+ B) :=\n  DFunLike.coe_injective.smulCommClass (fun _ _ ↦ rfl) (fun _ _ ↦ rfl)\n\n"}
{"name":"DomMulAct.smul_addMonoidHom_apply","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"A : Type u_5\nB : Type u_6\nM : Type u_7\ninst✝² : AddMonoid A\ninst✝¹ : DistribSMul M A\ninst✝ : AddZeroClass B\nc : DomMulAct M\nf : AddMonoidHom A B\na : A\n⊢ Eq ((HSMul.hSMul c f) a) (f (HSMul.hSMul (DomMulAct.mk.symm c) a))","decl":"theorem smul_addMonoidHom_apply (c : Mᵈᵐᵃ) (f : A →+ B) (a : A) : (c • f) a = f (mk.symm c • a) :=\n  rfl\n\n"}
{"name":"DomMulAct.mk_smul_addMonoidHom_apply","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"A : Type u_5\nB : Type u_6\nM : Type u_7\ninst✝² : AddMonoid A\ninst✝¹ : DistribSMul M A\ninst✝ : AddZeroClass B\nc : M\nf : AddMonoidHom A B\na : A\n⊢ Eq ((HSMul.hSMul (DomMulAct.mk c) f) a) (f (HSMul.hSMul c a))","decl":"@[simp]\ntheorem mk_smul_addMonoidHom_apply (c : M) (f : A →+ B) (a : A) : (mk c • f) a = f (c • a) := rfl\n\n"}
{"name":"DomMulAct.coe_smul_addMonoidHom","module":"Mathlib.GroupTheory.GroupAction.DomAct.Basic","initialProofState":"A : Type u_5\nB : Type u_6\nM : Type u_7\ninst✝² : AddMonoid A\ninst✝¹ : DistribSMul M A\ninst✝ : AddZeroClass B\nc : DomMulAct M\nf : AddMonoidHom A B\n⊢ Eq (⇑(HSMul.hSMul c f)) (HSMul.hSMul c ⇑f)","decl":"theorem coe_smul_addMonoidHom (c : Mᵈᵐᵃ) (f : A →+ B) : ⇑(c • f) = c • ⇑f :=\n  rfl\n\n"}
