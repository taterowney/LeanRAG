{"name":"Finset.Nat.antidiagonal_eq_map","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Finset.HasAntidiagonal.antidiagonal n) (Finset.map { toFun := fun i => { fst := i, snd := HSub.hSub n i }, inj' := ⋯ } (Finset.range (HAdd.hAdd n 1)))","decl":"lemma antidiagonal_eq_map (n : ℕ) :\n    antidiagonal n = (range (n + 1)).map ⟨fun i ↦ (i, n - i), fun _ _ h ↦ (Prod.ext_iff.1 h).1⟩ :=\n  rfl\n\n"}
{"name":"Finset.Nat.antidiagonal_eq_map'","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Finset.HasAntidiagonal.antidiagonal n) (Finset.map { toFun := fun i => { fst := HSub.hSub n i, snd := i }, inj' := ⋯ } (Finset.range (HAdd.hAdd n 1)))","decl":"lemma antidiagonal_eq_map' (n : ℕ) :\n    antidiagonal n =\n      (range (n + 1)).map ⟨fun i ↦ (n - i, i), fun _ _ h ↦ (Prod.ext_iff.1 h).2⟩ := by\n  rw [← map_swap_antidiagonal, antidiagonal_eq_map, map_map]; rfl\n\n"}
{"name":"Finset.Nat.antidiagonal_eq_image","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Finset.HasAntidiagonal.antidiagonal n) (Finset.image (fun i => { fst := i, snd := HSub.hSub n i }) (Finset.range (HAdd.hAdd n 1)))","decl":"lemma antidiagonal_eq_image (n : ℕ) :\n    antidiagonal n = (range (n + 1)).image fun i ↦ (i, n - i) := by\n  simp only [antidiagonal_eq_map, map_eq_image, Function.Embedding.coeFn_mk]\n\n"}
{"name":"Finset.Nat.antidiagonal_eq_image'","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Finset.HasAntidiagonal.antidiagonal n) (Finset.image (fun i => { fst := HSub.hSub n i, snd := i }) (Finset.range (HAdd.hAdd n 1)))","decl":"lemma antidiagonal_eq_image' (n : ℕ) :\n    antidiagonal n = (range (n + 1)).image fun i ↦ (n - i, i) := by\n  simp only [antidiagonal_eq_map', map_eq_image, Function.Embedding.coeFn_mk]\n\n"}
{"name":"Finset.Nat.card_antidiagonal","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Finset.HasAntidiagonal.antidiagonal n).card (HAdd.hAdd n 1)","decl":"/-- The cardinality of the antidiagonal of `n` is `n + 1`. -/\n@[simp]\ntheorem card_antidiagonal (n : ℕ) : (antidiagonal n).card = n + 1 := by simp [antidiagonal]\n\n"}
{"name":"Finset.Nat.antidiagonal_zero","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"⊢ Eq (Finset.HasAntidiagonal.antidiagonal 0) (Singleton.singleton { fst := 0, snd := 0 })","decl":"/-- The antidiagonal of `0` is the list `[(0, 0)]` -/\n@[simp]\ntheorem antidiagonal_zero : antidiagonal 0 = {(0, 0)} := rfl\n\n"}
{"name":"Finset.Nat.antidiagonal_succ","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Finset.HasAntidiagonal.antidiagonal (HAdd.hAdd n 1)) (Finset.cons { fst := 0, snd := HAdd.hAdd n 1 } (Finset.map ({ toFun := Nat.succ, inj' := Nat.succ_injective }.prodMap (Function.Embedding.refl Nat)) (Finset.HasAntidiagonal.antidiagonal n)) ⋯)","decl":"theorem antidiagonal_succ (n : ℕ) :\n    antidiagonal (n + 1) =\n      cons (0, n + 1)\n        ((antidiagonal n).map\n          (Embedding.prodMap ⟨Nat.succ, Nat.succ_injective⟩ (Embedding.refl _)))\n        (by simp) := by\n  apply eq_of_veq\n  rw [cons_val, map_val]\n  apply Multiset.Nat.antidiagonal_succ\n\n"}
{"name":"Finset.Nat.antidiagonal_succ'","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Finset.HasAntidiagonal.antidiagonal (HAdd.hAdd n 1)) (Finset.cons { fst := HAdd.hAdd n 1, snd := 0 } (Finset.map ((Function.Embedding.refl Nat).prodMap { toFun := Nat.succ, inj' := Nat.succ_injective }) (Finset.HasAntidiagonal.antidiagonal n)) ⋯)","decl":"theorem antidiagonal_succ' (n : ℕ) :\n    antidiagonal (n + 1) =\n      cons (n + 1, 0)\n        ((antidiagonal n).map\n          (Embedding.prodMap (Embedding.refl _) ⟨Nat.succ, Nat.succ_injective⟩))\n        (by simp) := by\n  apply eq_of_veq\n  rw [cons_val, map_val]\n  exact Multiset.Nat.antidiagonal_succ'\n\n"}
{"name":"Finset.Nat.antidiagonal_succ_succ'","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (Finset.HasAntidiagonal.antidiagonal (HAdd.hAdd n 2)) (Finset.cons { fst := 0, snd := HAdd.hAdd n 2 } (Finset.cons { fst := HAdd.hAdd n 2, snd := 0 } (Finset.map ({ toFun := Nat.succ, inj' := Nat.succ_injective }.prodMap { toFun := Nat.succ, inj' := Nat.succ_injective }) (Finset.HasAntidiagonal.antidiagonal n)) ⋯) ⋯)","decl":"theorem antidiagonal_succ_succ' {n : ℕ} :\n    antidiagonal (n + 2) =\n      cons (0, n + 2)\n        (cons (n + 2, 0)\n            ((antidiagonal n).map\n              (Embedding.prodMap ⟨Nat.succ, Nat.succ_injective⟩\n                ⟨Nat.succ, Nat.succ_injective⟩)) <|\n          by simp)\n        (by simp) := by\n  simp_rw [antidiagonal_succ (n + 1), antidiagonal_succ', Finset.map_cons, map_map]\n  rfl\n\n"}
{"name":"Finset.Nat.antidiagonal.fst_lt","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n : Nat\nkl : Prod Nat Nat\nhlk : Membership.mem (Finset.HasAntidiagonal.antidiagonal n) kl\n⊢ LT.lt kl.1 (HAdd.hAdd n 1)","decl":"theorem antidiagonal.fst_lt {n : ℕ} {kl : ℕ × ℕ} (hlk : kl ∈ antidiagonal n) : kl.1 < n + 1 :=\n  Nat.lt_succ_of_le <| antidiagonal.fst_le hlk\n\n"}
{"name":"Finset.Nat.antidiagonal.snd_lt","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n : Nat\nkl : Prod Nat Nat\nhlk : Membership.mem (Finset.HasAntidiagonal.antidiagonal n) kl\n⊢ LT.lt kl.2 (HAdd.hAdd n 1)","decl":"theorem antidiagonal.snd_lt {n : ℕ} {kl : ℕ × ℕ} (hlk : kl ∈ antidiagonal n) : kl.2 < n + 1 :=\n  Nat.lt_succ_of_le <| antidiagonal.snd_le hlk\n\n"}
{"name":"Finset.Nat.antidiagonal_filter_snd_le_of_le","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n k : Nat\nh : LE.le k n\n⊢ Eq (Finset.filter (fun a => LE.le a.2 k) (Finset.HasAntidiagonal.antidiagonal n)) (Finset.map ({ toFun := fun x => HAdd.hAdd x (HSub.hSub n k), inj' := ⋯ }.prodMap (Function.Embedding.refl Nat)) (Finset.HasAntidiagonal.antidiagonal k))","decl":"@[simp] lemma antidiagonal_filter_snd_le_of_le {n k : ℕ} (h : k ≤ n) :\n    (antidiagonal n).filter (fun a ↦ a.snd ≤ k) = (antidiagonal k).map\n      (Embedding.prodMap ⟨_, add_left_injective (n - k)⟩ (Embedding.refl ℕ)) := by\n  ext ⟨i, j⟩\n  suffices i + j = n ∧ j ≤ k ↔ ∃ a, a + j = k ∧ a + (n - k) = i by simpa\n  refine ⟨fun hi ↦ ⟨k - j, tsub_add_cancel_of_le hi.2, ?_⟩, ?_⟩\n  · rw [add_comm, tsub_add_eq_add_tsub h, ← hi.1, add_assoc, Nat.add_sub_of_le hi.2,\n      add_tsub_cancel_right]\n  · rintro ⟨l, hl, rfl⟩\n    refine ⟨?_, hl ▸ Nat.le_add_left j l⟩\n    rw [add_assoc, add_comm, add_assoc, add_comm j l, hl]\n    exact Nat.sub_add_cancel h\n\n"}
{"name":"Finset.Nat.antidiagonal_filter_fst_le_of_le","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n k : Nat\nh : LE.le k n\n⊢ Eq (Finset.filter (fun a => LE.le a.1 k) (Finset.HasAntidiagonal.antidiagonal n)) (Finset.map ((Function.Embedding.refl Nat).prodMap { toFun := fun x => HAdd.hAdd x (HSub.hSub n k), inj' := ⋯ }) (Finset.HasAntidiagonal.antidiagonal k))","decl":"@[simp] lemma antidiagonal_filter_fst_le_of_le {n k : ℕ} (h : k ≤ n) :\n    (antidiagonal n).filter (fun a ↦ a.fst ≤ k) = (antidiagonal k).map\n      (Embedding.prodMap (Embedding.refl ℕ) ⟨_, add_left_injective (n - k)⟩) := by\n  have aux₁ : fun a ↦ a.fst ≤ k = (fun a ↦ a.snd ≤ k) ∘ (Equiv.prodComm ℕ ℕ).symm := rfl\n  have aux₂ : ∀ i j, (∃ a b, a + b = k ∧ b = i ∧ a + (n - k) = j) ↔\n                      ∃ a b, a + b = k ∧ a = i ∧ b + (n - k) = j :=\n    fun i j ↦ by rw [exists_comm]; exact exists₂_congr (fun a b ↦ by rw [add_comm])\n  rw [← map_prodComm_antidiagonal]\n  simp_rw [aux₁, ← map_filter, antidiagonal_filter_snd_le_of_le h, map_map]\n  ext ⟨i, j⟩\n  simpa using aux₂ i j\n\n"}
{"name":"Finset.Nat.antidiagonal_filter_le_fst_of_le","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n k : Nat\nh : LE.le k n\n⊢ Eq (Finset.filter (fun a => LE.le k a.1) (Finset.HasAntidiagonal.antidiagonal n)) (Finset.map ({ toFun := fun x => HAdd.hAdd x k, inj' := ⋯ }.prodMap (Function.Embedding.refl Nat)) (Finset.HasAntidiagonal.antidiagonal (HSub.hSub n k)))","decl":"@[simp] lemma antidiagonal_filter_le_fst_of_le {n k : ℕ} (h : k ≤ n) :\n    (antidiagonal n).filter (fun a ↦ k ≤ a.fst) = (antidiagonal (n - k)).map\n      (Embedding.prodMap ⟨_, add_left_injective k⟩ (Embedding.refl ℕ)) := by\n  ext ⟨i, j⟩\n  suffices i + j = n ∧ k ≤ i ↔ ∃ a, a + j = n - k ∧ a + k = i by simpa\n  refine ⟨fun hi ↦ ⟨i - k, ?_, tsub_add_cancel_of_le hi.2⟩, ?_⟩\n  · rw [← Nat.sub_add_comm hi.2, hi.1]\n  · rintro ⟨l, hl, rfl⟩\n    refine ⟨?_, Nat.le_add_left k l⟩\n    rw [add_right_comm, hl]\n    exact tsub_add_cancel_of_le h\n\n"}
{"name":"Finset.Nat.antidiagonal_filter_le_snd_of_le","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n k : Nat\nh : LE.le k n\n⊢ Eq (Finset.filter (fun a => LE.le k a.2) (Finset.HasAntidiagonal.antidiagonal n)) (Finset.map ((Function.Embedding.refl Nat).prodMap { toFun := fun x => HAdd.hAdd x k, inj' := ⋯ }) (Finset.HasAntidiagonal.antidiagonal (HSub.hSub n k)))","decl":"@[simp] lemma antidiagonal_filter_le_snd_of_le {n k : ℕ} (h : k ≤ n) :\n    (antidiagonal n).filter (fun a ↦ k ≤ a.snd) = (antidiagonal (n - k)).map\n      (Embedding.prodMap (Embedding.refl ℕ) ⟨_, add_left_injective k⟩) := by\n  have aux₁ : fun a ↦ k ≤ a.snd = (fun a ↦ k ≤ a.fst) ∘ (Equiv.prodComm ℕ ℕ).symm := rfl\n  have aux₂ : ∀ i j, (∃ a b, a + b = n - k ∧ b = i ∧ a + k = j) ↔\n                      ∃ a b, a + b = n - k ∧ a = i ∧ b + k = j :=\n    fun i j ↦ by rw [exists_comm]; exact exists₂_congr (fun a b ↦ by rw [add_comm])\n  rw [← map_prodComm_antidiagonal]\n  simp_rw [aux₁, ← map_filter, antidiagonal_filter_le_fst_of_le h, map_map]\n  ext ⟨i, j⟩\n  simpa using aux₂ i j\n\n"}
{"name":"Finset.Nat.antidiagonalEquivFin_symm_apply_coe","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n : Nat\nx✝ : Fin (HAdd.hAdd n 1)\n⊢ Eq ↑((Finset.Nat.antidiagonalEquivFin n).symm x✝) { fst := ↑x✝, snd := HSub.hSub n ↑x✝ }","decl":"/-- The set `antidiagonal n` is equivalent to `Fin (n+1)`, via the first projection. --/\n@[simps]\ndef antidiagonalEquivFin (n : ℕ) : antidiagonal n ≃ Fin (n + 1) where\n  toFun := fun ⟨⟨i, _⟩, h⟩ ↦ ⟨i, antidiagonal.fst_lt h⟩\n  invFun := fun ⟨i, h⟩ ↦ ⟨⟨i, n - i⟩, by\n    rw [mem_antidiagonal, add_comm, Nat.sub_add_cancel]\n    exact Nat.le_of_lt_succ h⟩\n  left_inv := by rintro ⟨⟨i, j⟩, h⟩; ext; rfl\n  right_inv _ := rfl\n\n"}
{"name":"Finset.Nat.antidiagonalEquivFin_apply_val","module":"Mathlib.Data.Finset.NatAntidiagonal","initialProofState":"n : Nat\nx✝ : Subtype fun x => Membership.mem (Finset.HasAntidiagonal.antidiagonal n) x\n⊢ Eq (↑((Finset.Nat.antidiagonalEquivFin n) x✝)) x✝.1.1","decl":"/-- The set `antidiagonal n` is equivalent to `Fin (n+1)`, via the first projection. --/\n@[simps]\ndef antidiagonalEquivFin (n : ℕ) : antidiagonal n ≃ Fin (n + 1) where\n  toFun := fun ⟨⟨i, _⟩, h⟩ ↦ ⟨i, antidiagonal.fst_lt h⟩\n  invFun := fun ⟨i, h⟩ ↦ ⟨⟨i, n - i⟩, by\n    rw [mem_antidiagonal, add_comm, Nat.sub_add_cancel]\n    exact Nat.le_of_lt_succ h⟩\n  left_inv := by rintro ⟨⟨i, j⟩, h⟩; ext; rfl\n  right_inv _ := rfl\n\n"}
