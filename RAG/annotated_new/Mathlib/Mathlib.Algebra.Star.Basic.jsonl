{"name":"StarMemClass.star_mem","module":"Mathlib.Algebra.Star.Basic","initialProofState":"S : Type u_1\nR : Type u_2\ninst✝¹ : Star R\ninst✝ : SetLike S R\nself : StarMemClass S R\ns : S\nr : R\na✝ : Membership.mem s r\n⊢ Membership.mem s (Star.star r)","decl":"/-- `StarMemClass S G` states `S` is a type of subsets `s ⊆ G` closed under star. -/\nclass StarMemClass (S R : Type*) [Star R] [SetLike S R] : Prop where\n  /-- Closure under star. -/\n  star_mem : ∀ {s : S} {r : R}, r ∈ s → star r ∈ s\n\n"}
{"name":"StarMemClass.coe_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\nS : Type w\ninst✝¹ : Star R\ninst✝ : SetLike S R\nhS : StarMemClass S R\ns : S\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(Star.star x)) (Star.star ↑x)","decl":"@[simp] lemma coe_star (x : s) : star x = star (x : R) := rfl\n\n"}
{"name":"InvolutiveStar.star_involutive","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\nself : InvolutiveStar R\n⊢ Function.Involutive Star.star","decl":"/-- Typeclass for a star operation with is involutive.\n-/\nclass InvolutiveStar (R : Type u) extends Star R where\n  /-- Involutive condition. -/\n  star_involutive : Function.Involutive star\n\n"}
{"name":"star_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝ : InvolutiveStar R\nr : R\n⊢ Eq (Star.star (Star.star r)) r","decl":"@[simp]\ntheorem star_star [InvolutiveStar R] (r : R) : star (star r) = r :=\n  star_involutive _\n\n"}
{"name":"star_injective","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝ : InvolutiveStar R\n⊢ Function.Injective Star.star","decl":"theorem star_injective [InvolutiveStar R] : Function.Injective (star : R → R) :=\n  Function.Involutive.injective star_involutive\n\n"}
{"name":"star_inj","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝ : InvolutiveStar R\nx y : R\n⊢ Iff (Eq (Star.star x) (Star.star y)) (Eq x y)","decl":"@[simp]\ntheorem star_inj [InvolutiveStar R] {x y : R} : star x = star y ↔ x = y :=\n  star_injective.eq_iff\n\n"}
{"name":"eq_star_of_eq_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝ : InvolutiveStar R\nr s : R\nh : Eq r (Star.star s)\n⊢ Eq s (Star.star r)","decl":"theorem eq_star_of_eq_star [InvolutiveStar R] {r s : R} (h : r = star s) : s = star r := by\n  simp [h]\n\n"}
{"name":"eq_star_iff_eq_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝ : InvolutiveStar R\nr s : R\n⊢ Iff (Eq r (Star.star s)) (Eq s (Star.star r))","decl":"theorem eq_star_iff_eq_star [InvolutiveStar R] {r s : R} : r = star s ↔ s = star r :=\n  ⟨eq_star_of_eq_star, eq_star_of_eq_star⟩\n\n"}
{"name":"star_eq_iff_star_eq","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝ : InvolutiveStar R\nr s : R\n⊢ Iff (Eq (Star.star r) s) (Eq (Star.star s) r)","decl":"theorem star_eq_iff_star_eq [InvolutiveStar R] {r s : R} : star r = s ↔ star s = r :=\n  eq_comm.trans <| eq_star_iff_eq_star.trans eq_comm\n\n"}
{"name":"TrivialStar.star_trivial","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝ : Star R\nself : TrivialStar R\nr : R\n⊢ Eq (Star.star r) r","decl":"/-- Typeclass for a trivial star operation. This is mostly meant for `ℝ`.\n-/\nclass TrivialStar (R : Type u) [Star R] : Prop where\n  /-- Condition that star is trivial -/\n  star_trivial : ∀ r : R, star r = r\n\n"}
{"name":"StarMul.star_mul","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝ : Mul R\nself : StarMul R\nr s : R\n⊢ Eq (Star.star (HMul.hMul r s)) (HMul.hMul (Star.star s) (Star.star r))","decl":"/-- A `*`-magma is a magma `R` with an involutive operation `star`\nsuch that `star (r * s) = star s * star r`.\n-/\nclass StarMul (R : Type u) [Mul R] extends InvolutiveStar R where\n  /-- `star` skew-distributes over multiplication. -/\n  star_mul : ∀ r s : R, star (r * s) = star s * star r\n\n"}
{"name":"star_star_mul","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx y : R\n⊢ Eq (Star.star (HMul.hMul (Star.star x) y)) (HMul.hMul (Star.star y) x)","decl":"theorem star_star_mul (x y : R) : star (star x * y) = star y * x := by rw [star_mul, star_star]\n\n"}
{"name":"star_mul_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx y : R\n⊢ Eq (Star.star (HMul.hMul x (Star.star y))) (HMul.hMul y (Star.star x))","decl":"theorem star_mul_star (x y : R) : star (x * star y) = y * star x := by rw [star_mul, star_star]\n\n"}
{"name":"semiconjBy_star_star_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx y z : R\n⊢ Iff (SemiconjBy (Star.star x) (Star.star z) (Star.star y)) (SemiconjBy x y z)","decl":"@[simp]\ntheorem semiconjBy_star_star_star {x y z : R} :\n    SemiconjBy (star x) (star z) (star y) ↔ SemiconjBy x y z := by\n  simp_rw [SemiconjBy, ← star_mul, star_inj, eq_comm]\n\n"}
{"name":"SemiconjBy.star_star_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx y z : R\na✝ : SemiconjBy x y z\n⊢ SemiconjBy (Star.star x) (Star.star z) (Star.star y)","decl":"alias ⟨_, SemiconjBy.star_star_star⟩ := semiconjBy_star_star_star\n\n"}
{"name":"commute_star_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx y : R\n⊢ Iff (Commute (Star.star x) (Star.star y)) (Commute x y)","decl":"@[simp]\ntheorem commute_star_star {x y : R} : Commute (star x) (star y) ↔ Commute x y :=\n  semiconjBy_star_star_star\n\n"}
{"name":"Commute.star_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx y : R\na✝ : Commute x y\n⊢ Commute (Star.star x) (Star.star y)","decl":"alias ⟨_, Commute.star_star⟩ := commute_star_star\n\n"}
{"name":"commute_star_comm","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx y : R\n⊢ Iff (Commute (Star.star x) y) (Commute x (Star.star y))","decl":"theorem commute_star_comm {x y : R} : Commute (star x) y ↔ Commute x (star y) := by\n  rw [← commute_star_star, star_star]\n\n"}
{"name":"star_mul'","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemigroup R\ninst✝ : StarMul R\nx y : R\n⊢ Eq (Star.star (HMul.hMul x y)) (HMul.hMul (Star.star x) (Star.star y))","decl":"/-- In a commutative ring, make `simp` prefer leaving the order unchanged. -/\n@[simp]\ntheorem star_mul' [CommSemigroup R] [StarMul R] (x y : R) : star (x * y) = star x * star y :=\n  (star_mul x y).trans (mul_comm _ _)\n\n"}
{"name":"starMulEquiv_apply","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx : R\n⊢ Eq (starMulEquiv x) (MulOpposite.op (Star.star x))","decl":"/-- `star` as a `MulEquiv` from `R` to `Rᵐᵒᵖ` -/\n@[simps apply]\ndef starMulEquiv [Mul R] [StarMul R] : R ≃* Rᵐᵒᵖ :=\n  { (InvolutiveStar.star_involutive.toPerm star).trans opEquiv with\n    toFun := fun x => MulOpposite.op (star x)\n    map_mul' := fun x y => by simp only [star_mul, op_mul] }\n\n"}
{"name":"starMulAut_apply","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemigroup R\ninst✝ : StarMul R\na✝ : R\n⊢ Eq (starMulAut a✝) (Star.star a✝)","decl":"/-- `star` as a `MulAut` for commutative `R`. -/\n@[simps apply]\ndef starMulAut [CommSemigroup R] [StarMul R] : MulAut R :=\n  { InvolutiveStar.star_involutive.toPerm star with\n    toFun := star\n    map_mul' := star_mul' }\n\n"}
{"name":"star_one","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : MulOneClass R\ninst✝ : StarMul R\n⊢ Eq (Star.star 1) 1","decl":"@[simp]\ntheorem star_one [MulOneClass R] [StarMul R] : star (1 : R) = 1 :=\n  op_injective <| (starMulEquiv : R ≃* Rᵐᵒᵖ).map_one.trans op_one.symm\n\n"}
{"name":"star_pow","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Monoid R\ninst✝ : StarMul R\nx : R\nn : Nat\n⊢ Eq (Star.star (HPow.hPow x n)) (HPow.hPow (Star.star x) n)","decl":"@[simp]\ntheorem star_pow [Monoid R] [StarMul R] (x : R) (n : ℕ) : star (x ^ n) = star x ^ n :=\n  op_injective <|\n    ((starMulEquiv : R ≃* Rᵐᵒᵖ).toMonoidHom.map_pow x n).trans (op_pow (star x) n).symm\n\n"}
{"name":"star_inv","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Group R\ninst✝ : StarMul R\nx : R\n⊢ Eq (Star.star (Inv.inv x)) (Inv.inv (Star.star x))","decl":"@[simp]\ntheorem star_inv [Group R] [StarMul R] (x : R) : star x⁻¹ = (star x)⁻¹ :=\n  op_injective <| ((starMulEquiv : R ≃* Rᵐᵒᵖ).toMonoidHom.map_inv x).trans (op_inv (star x)).symm\n\n"}
{"name":"star_zpow","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Group R\ninst✝ : StarMul R\nx : R\nz : Int\n⊢ Eq (Star.star (HPow.hPow x z)) (HPow.hPow (Star.star x) z)","decl":"@[simp]\ntheorem star_zpow [Group R] [StarMul R] (x : R) (z : ℤ) : star (x ^ z) = star x ^ z :=\n  op_injective <|\n    ((starMulEquiv : R ≃* Rᵐᵒᵖ).toMonoidHom.map_zpow x z).trans (op_zpow (star x) z).symm\n\n"}
{"name":"star_div","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : CommGroup R\ninst✝ : StarMul R\nx y : R\n⊢ Eq (Star.star (HDiv.hDiv x y)) (HDiv.hDiv (Star.star x) (Star.star y))","decl":"/-- When multiplication is commutative, `star` preserves division. -/\n@[simp]\ntheorem star_div [CommGroup R] [StarMul R] (x y : R) : star (x / y) = star x / star y :=\n  map_div (starMulAut : R ≃* R) _ _\n\n"}
{"name":"star_id_of_comm","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx : R\n⊢ Eq (Star.star x) x","decl":"/-- Note that since `starMulOfComm` is reducible, `simp` can already prove this. -/\ntheorem star_id_of_comm {R : Type*} [CommSemiring R] {x : R} : star x = x :=\n  rfl\n\n"}
{"name":"StarAddMonoid.star_add","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝ : AddMonoid R\nself : StarAddMonoid R\nr s : R\n⊢ Eq (Star.star (HAdd.hAdd r s)) (HAdd.hAdd (Star.star r) (Star.star s))","decl":"/-- A `*`-additive monoid `R` is an additive monoid with an involutive `star` operation which\npreserves addition. -/\nclass StarAddMonoid (R : Type u) [AddMonoid R] extends InvolutiveStar R where\n  /-- `star` commutes with addition -/\n  star_add : ∀ r s : R, star (r + s) = star r + star s\n\n"}
{"name":"starAddEquiv_apply","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : AddMonoid R\ninst✝ : StarAddMonoid R\na✝ : R\n⊢ Eq (starAddEquiv a✝) (Star.star a✝)","decl":"/-- `star` as an `AddEquiv` -/\n@[simps apply]\ndef starAddEquiv [AddMonoid R] [StarAddMonoid R] : R ≃+ R :=\n  { InvolutiveStar.star_involutive.toPerm star with\n    toFun := star\n    map_add' := star_add }\n\n"}
{"name":"star_zero","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : AddMonoid R\ninst✝ : StarAddMonoid R\n⊢ Eq (Star.star 0) 0","decl":"@[simp]\ntheorem star_zero [AddMonoid R] [StarAddMonoid R] : star (0 : R) = 0 :=\n  (starAddEquiv : R ≃+ R).map_zero\n\n"}
{"name":"star_eq_zero","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : AddMonoid R\ninst✝ : StarAddMonoid R\nx : R\n⊢ Iff (Eq (Star.star x) 0) (Eq x 0)","decl":"@[simp]\ntheorem star_eq_zero [AddMonoid R] [StarAddMonoid R] {x : R} : star x = 0 ↔ x = 0 :=\n  starAddEquiv.map_eq_zero_iff (M := R)\n\n"}
{"name":"star_ne_zero","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : AddMonoid R\ninst✝ : StarAddMonoid R\nx : R\n⊢ Iff (Ne (Star.star x) 0) (Ne x 0)","decl":"theorem star_ne_zero [AddMonoid R] [StarAddMonoid R] {x : R} : star x ≠ 0 ↔ x ≠ 0 := by\n  simp only [ne_eq, star_eq_zero]\n\n"}
{"name":"star_neg","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : AddGroup R\ninst✝ : StarAddMonoid R\nr : R\n⊢ Eq (Star.star (Neg.neg r)) (Neg.neg (Star.star r))","decl":"@[simp]\ntheorem star_neg [AddGroup R] [StarAddMonoid R] (r : R) : star (-r) = -star r :=\n  (starAddEquiv : R ≃+ R).map_neg _\n\n"}
{"name":"star_sub","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : AddGroup R\ninst✝ : StarAddMonoid R\nr s : R\n⊢ Eq (Star.star (HSub.hSub r s)) (HSub.hSub (Star.star r) (Star.star s))","decl":"@[simp]\ntheorem star_sub [AddGroup R] [StarAddMonoid R] (r s : R) : star (r - s) = star r - star s :=\n  (starAddEquiv : R ≃+ R).map_sub _ _\n\n"}
{"name":"star_nsmul","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : AddMonoid R\ninst✝ : StarAddMonoid R\nn : Nat\nx : R\n⊢ Eq (Star.star (HSMul.hSMul n x)) (HSMul.hSMul n (Star.star x))","decl":"@[simp]\ntheorem star_nsmul [AddMonoid R] [StarAddMonoid R] (n : ℕ) (x : R) : star (n • x) = n • star x :=\n  (starAddEquiv : R ≃+ R).toAddMonoidHom.map_nsmul _ _\n\n"}
{"name":"star_zsmul","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : AddGroup R\ninst✝ : StarAddMonoid R\nn : Int\nx : R\n⊢ Eq (Star.star (HSMul.hSMul n x)) (HSMul.hSMul n (Star.star x))","decl":"@[simp]\ntheorem star_zsmul [AddGroup R] [StarAddMonoid R] (n : ℤ) (x : R) : star (n • x) = n • star x :=\n  (starAddEquiv : R ≃+ R).toAddMonoidHom.map_zsmul _ _\n\n"}
{"name":"StarRing.star_add","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nself : StarRing R\nr s : R\n⊢ Eq (Star.star (HAdd.hAdd r s)) (HAdd.hAdd (Star.star r) (Star.star s))","decl":"/-- A `*`-ring `R` is a non-unital, non-associative (semi)ring with an involutive `star` operation\nwhich is additive which makes `R` with its multiplicative structure into a `*`-multiplication\n(i.e. `star (r * s) = star s * star r`). -/\nclass StarRing (R : Type u) [NonUnitalNonAssocSemiring R] extends StarMul R where\n  /-- `star` commutes with addition -/\n  star_add : ∀ r s : R, star (r + s) = star r + star s\n\n"}
{"name":"starRingEquiv_apply","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : StarRing R\nx : R\n⊢ Eq (starRingEquiv x) (MulOpposite.op (Star.star x))","decl":"/-- `star` as a `RingEquiv` from `R` to `Rᵐᵒᵖ` -/\n@[simps apply]\ndef starRingEquiv [NonUnitalNonAssocSemiring R] [StarRing R] : R ≃+* Rᵐᵒᵖ :=\n  { starAddEquiv.trans (MulOpposite.opAddEquiv : R ≃+ Rᵐᵒᵖ), starMulEquiv with\n    toFun := fun x => MulOpposite.op (star x) }\n\n"}
{"name":"star_natCast","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : NonAssocSemiring R\ninst✝ : StarRing R\nn : Nat\n⊢ Eq (Star.star ↑n) ↑n","decl":"@[simp, norm_cast]\ntheorem star_natCast [NonAssocSemiring R] [StarRing R] (n : ℕ) : star (n : R) = n :=\n  (congr_arg unop (map_natCast (starRingEquiv : R ≃+* Rᵐᵒᵖ) n)).trans (unop_natCast _)\n\n"}
{"name":"star_ofNat","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝² : NonAssocSemiring R\ninst✝¹ : StarRing R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Star.star (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem star_ofNat [NonAssocSemiring R] [StarRing R] (n : ℕ) [n.AtLeastTwo] :\n    star (ofNat(n) : R) = ofNat(n) :=\n  star_natCast _\n\n"}
{"name":"star_intCast","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Ring R\ninst✝ : StarRing R\nz : Int\n⊢ Eq (Star.star ↑z) ↑z","decl":"@[simp, norm_cast]\ntheorem star_intCast [Ring R] [StarRing R] (z : ℤ) : star (z : R) = z :=\n  (congr_arg unop <| map_intCast (starRingEquiv : R ≃+* Rᵐᵒᵖ) z).trans (unop_intCast _)\n\n"}
{"name":"starRingAut_apply","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : StarRing R\na✝ : R\n⊢ Eq (starRingAut a✝) (Star.star a✝)","decl":"/-- `star` as a ring automorphism, for commutative `R`. -/\n@[simps apply]\ndef starRingAut : RingAut R := { starAddEquiv, starMulAut (R := R) with toFun := star }\n\n"}
{"name":"starRingEnd_apply","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : StarRing R\nx : R\n⊢ Eq ((starRingEnd R) x) (Star.star x)","decl":"/-- This is not a simp lemma, since we usually want simp to keep `starRingEnd` bundled.\n For example, for complex conjugation, we don't want simp to turn `conj x`\n into the bare function `star x` automatically since most lemmas are about `conj x`. -/\ntheorem starRingEnd_apply (x : R) : starRingEnd R x = star x := rfl\n\n/- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): removed `simp` attribute due to report by linter:\n\nsimp can prove this:\n  by simp only [RingHomCompTriple.comp_apply, RingHom.id_apply]\nOne of the lemmas above could be a duplicate.\nIf that's not the case try reordering lemmas or adding @[priority].\n -/\n-- @[simp]\n"}
{"name":"starRingEnd_self_apply","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : StarRing R\nx : R\n⊢ Eq ((starRingEnd R) ((starRingEnd R) x)) x","decl":"theorem starRingEnd_self_apply (x : R) : starRingEnd R (starRingEnd R x) = x := star_star x\n\n"}
{"name":"RingHom.star_def","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\ninst✝¹ : StarRing R\nS : Type u_1\ninst✝ : NonAssocSemiring S\nf : RingHom S R\n⊢ Eq (Star.star f) ((starRingEnd R).comp f)","decl":"theorem RingHom.star_def {S : Type*} [NonAssocSemiring S] (f : S →+* R) :\n    Star.star f = RingHom.comp (starRingEnd R) f := rfl\n\n"}
{"name":"RingHom.star_apply","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\ninst✝¹ : StarRing R\nS : Type u_1\ninst✝ : NonAssocSemiring S\nf : RingHom S R\ns : S\n⊢ Eq ((Star.star f) s) (Star.star (f s))","decl":"theorem RingHom.star_apply {S : Type*} [NonAssocSemiring S] (f : S →+* R) (s : S) :\n    star f s = star (f s) := rfl\n\n-- A more convenient name for complex conjugation\n"}
{"name":"Complex.conj_conj","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : StarRing R\nx : R\n⊢ Eq ((starRingEnd R) ((starRingEnd R) x)) x","decl":"alias Complex.conj_conj := starRingEnd_self_apply\n\n"}
{"name":"RCLike.conj_conj","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : StarRing R\nx : R\n⊢ Eq ((starRingEnd R) ((starRingEnd R) x)) x","decl":"alias RCLike.conj_conj := starRingEnd_self_apply\n\n"}
{"name":"conj_trivial","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\ninst✝¹ : StarRing R\ninst✝ : TrivialStar R\na : R\n⊢ Eq ((starRingEnd R) a) a","decl":"@[simp] lemma conj_trivial [TrivialStar R] (a : R) : conj a = a := star_trivial _\n\n"}
{"name":"star_inv₀","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : GroupWithZero R\ninst✝ : StarMul R\nx : R\n⊢ Eq (Star.star (Inv.inv x)) (Inv.inv (Star.star x))","decl":"@[simp]\ntheorem star_inv₀ [GroupWithZero R] [StarMul R] (x : R) : star x⁻¹ = (star x)⁻¹ :=\n  op_injective <| (map_inv₀ (starMulEquiv : R ≃* Rᵐᵒᵖ) x).trans (op_inv (star x)).symm\n\n"}
{"name":"star_inv'","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : GroupWithZero R\ninst✝ : StarMul R\nx : R\n⊢ Eq (Star.star (Inv.inv x)) (Inv.inv (Star.star x))","decl":"@[deprecated (since := \"2024-11-18\")] alias star_inv' := star_inv₀\n\n"}
{"name":"star_zpow₀","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : GroupWithZero R\ninst✝ : StarMul R\nx : R\nz : Int\n⊢ Eq (Star.star (HPow.hPow x z)) (HPow.hPow (Star.star x) z)","decl":"@[simp]\ntheorem star_zpow₀ [GroupWithZero R] [StarMul R] (x : R) (z : ℤ) : star (x ^ z) = star x ^ z :=\n  op_injective <| (map_zpow₀ (starMulEquiv : R ≃* Rᵐᵒᵖ) x z).trans (op_zpow (star x) z).symm\n\n"}
{"name":"star_div₀","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : CommGroupWithZero R\ninst✝ : StarMul R\nx y : R\n⊢ Eq (Star.star (HDiv.hDiv x y)) (HDiv.hDiv (Star.star x) (Star.star y))","decl":"/-- When multiplication is commutative, `star` preserves division. -/\n@[simp]\ntheorem star_div₀ [CommGroupWithZero R] [StarMul R] (x y : R) : star (x / y) = star x / star y := by\n  apply op_injective\n  rw [division_def, op_div, mul_comm, star_mul, star_inv₀, op_mul, op_inv]\n\n"}
{"name":"star_div'","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : CommGroupWithZero R\ninst✝ : StarMul R\nx y : R\n⊢ Eq (Star.star (HDiv.hDiv x y)) (HDiv.hDiv (Star.star x) (Star.star y))","decl":"@[deprecated (since := \"2024-11-18\")] alias star_div' := star_div₀\n\n"}
{"name":"Nat.instTrivialStar","module":"Mathlib.Algebra.Star.Basic","initialProofState":"⊢ TrivialStar Nat","decl":"instance Nat.instTrivialStar : TrivialStar ℕ := ⟨fun _ ↦ rfl⟩\n"}
{"name":"Int.instTrivialStar","module":"Mathlib.Algebra.Star.Basic","initialProofState":"⊢ TrivialStar Int","decl":"instance Int.instTrivialStar : TrivialStar ℤ := ⟨fun _ ↦ rfl⟩\n\n"}
{"name":"StarModule.star_smul","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : Star R\ninst✝¹ : Star A\ninst✝ : SMul R A\nself : StarModule R A\nr : R\na : A\n⊢ Eq (Star.star (HSMul.hSMul r a)) (HSMul.hSMul (Star.star r) (Star.star a))","decl":"/-- A star module `A` over a star ring `R` is a module which is a star add monoid,\nand the two star structures are compatible in the sense\n`star (r • a) = star r • star a`.\n\nNote that it is up to the user of this typeclass to enforce\n`[Semiring R] [StarRing R] [AddCommMonoid A] [StarAddMonoid A] [Module R A]`, and that\nthe statement only requires `[Star R] [Star A] [SMul R A]`.\n\nIf used as `[CommRing R] [StarRing R] [Semiring A] [StarRing A] [Algebra R A]`, this represents a\nstar algebra.\n-/\n\nclass StarModule (R : Type u) (A : Type v) [Star R] [Star A] [SMul R A] : Prop where\n  /-- `star` commutes with scalar multiplication -/\n  star_smul : ∀ (r : R) (a : A), star (r • a) = star r • star a\n\n"}
{"name":"StarMul.toStarModule","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : CommMonoid R\ninst✝ : StarMul R\n⊢ StarModule R R","decl":"/-- A commutative star monoid is a star module over itself via `Monoid.toMulAction`. -/\ninstance StarMul.toStarModule [CommMonoid R] [StarMul R] : StarModule R R :=\n  ⟨star_mul'⟩\n\n"}
{"name":"StarAddMonoid.toStarModuleNat","module":"Mathlib.Algebra.Star.Basic","initialProofState":"α : Type u_1\ninst✝¹ : AddCommMonoid α\ninst✝ : StarAddMonoid α\n⊢ StarModule Nat α","decl":"instance StarAddMonoid.toStarModuleNat {α} [AddCommMonoid α] [StarAddMonoid α] :\n    StarModule ℕ α where star_smul := star_nsmul\n\n"}
{"name":"StarAddMonoid.toStarModuleInt","module":"Mathlib.Algebra.Star.Basic","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\ninst✝ : StarAddMonoid α\n⊢ StarModule Int α","decl":"instance StarAddMonoid.toStarModuleInt {α} [AddCommGroup α] [StarAddMonoid α] : StarModule ℤ α where\n  star_smul := star_zsmul\n\n"}
{"name":"RingHomInvPair.instStarRingEnd","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : StarRing R\n⊢ RingHomInvPair (starRingEnd R) (starRingEnd R)","decl":"/-- Instance needed to define star-linear maps over a commutative star ring\n(ex: conjugate-linear maps when R = ℂ). -/\ninstance [CommSemiring R] [StarRing R] : RingHomInvPair (starRingEnd R) (starRingEnd R) :=\n  ⟨RingHom.ext star_star, RingHom.ext star_star⟩\n\n"}
{"name":"StarHomClass.map_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"F : Type u_1\nR : outParam (Type u_2)\nS : outParam (Type u_3)\ninst✝² : Star R\ninst✝¹ : Star S\ninst✝ : FunLike F R S\nself : StarHomClass F R S\nf : F\nr : R\n⊢ Eq (f (Star.star r)) (Star.star (f r))","decl":"/-- `StarHomClass F R S` states that `F` is a type of `star`-preserving maps from `R` to `S`. -/\nclass StarHomClass (F : Type*) (R S : outParam Type*) [Star R] [Star S] [FunLike F R S] : Prop where\n  /-- the maps preserve star -/\n  map_star : ∀ (f : F) (r : R), f (star r) = star (f r)\n\n"}
{"name":"Units.coe_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Monoid R\ninst✝ : StarMul R\nu : Units R\n⊢ Eq (↑(Star.star u)) (Star.star ↑u)","decl":"@[simp]\ntheorem coe_star (u : Rˣ) : ↑(star u) = (star ↑u : R) :=\n  rfl\n\n"}
{"name":"Units.coe_star_inv","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Monoid R\ninst✝ : StarMul R\nu : Units R\n⊢ Eq (↑(Inv.inv (Star.star u))) (Star.star ↑(Inv.inv u))","decl":"@[simp]\ntheorem coe_star_inv (u : Rˣ) : ↑(star u)⁻¹ = (star ↑u⁻¹ : R) :=\n  rfl\n\n"}
{"name":"Units.instStarModule","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝⁴ : Monoid R\ninst✝³ : StarMul R\nA : Type u_1\ninst✝² : Star A\ninst✝¹ : SMul R A\ninst✝ : StarModule R A\n⊢ StarModule (Units R) A","decl":"instance {A : Type*} [Star A] [SMul R A] [StarModule R A] : StarModule Rˣ A :=\n  ⟨fun u a => star_smul (u : R) a⟩\n\n"}
{"name":"IsUnit.star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Monoid R\ninst✝ : StarMul R\na : R\na✝ : IsUnit a\n⊢ IsUnit (Star.star a)","decl":"protected theorem IsUnit.star [Monoid R] [StarMul R] {a : R} : IsUnit a → IsUnit (star a)\n  | ⟨u, hu⟩ => ⟨Star.star u, hu ▸ rfl⟩\n\n"}
{"name":"isUnit_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Monoid R\ninst✝ : StarMul R\na : R\n⊢ Iff (IsUnit (Star.star a)) (IsUnit a)","decl":"@[simp]\ntheorem isUnit_star [Monoid R] [StarMul R] {a : R} : IsUnit (star a) ↔ IsUnit a :=\n  ⟨fun h => star_star a ▸ h.star, IsUnit.star⟩\n\n"}
{"name":"Ring.inverse_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : StarRing R\na : R\n⊢ Eq (Ring.inverse (Star.star a)) (Star.star (Ring.inverse a))","decl":"theorem Ring.inverse_star [Semiring R] [StarRing R] (a : R) :\n    Ring.inverse (star a) = star (Ring.inverse a) := by\n  by_cases ha : IsUnit a\n  · obtain ⟨u, rfl⟩ := ha\n    rw [Ring.inverse_unit, ← Units.coe_star, Ring.inverse_unit, ← Units.coe_star_inv]\n  rw [Ring.inverse_non_unit _ ha, Ring.inverse_non_unit _ (mt isUnit_star.mp ha), star_zero]\n\n"}
{"name":"star_invOf","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u_1\ninst✝³ : Monoid R\ninst✝² : StarMul R\nr : R\ninst✝¹ : Invertible r\ninst✝ : Invertible (Star.star r)\n⊢ Eq (Star.star (Invertible.invOf r)) (Invertible.invOf (Star.star r))","decl":"theorem star_invOf {R : Type*} [Monoid R] [StarMul R] (r : R) [Invertible r]\n    [Invertible (star r)] : star (⅟ r) = ⅟ (star r) := by\n  have : star (⅟ r) = star (⅟ r) * ((star r) * ⅟ (star r)) := by\n    simp only [mul_invOf_self, mul_one]\n  rw [this, ← mul_assoc]\n  have : (star (⅟ r)) * (star r) = star 1 := by rw [← star_mul, mul_invOf_self]\n  rw [this, star_one, one_mul]\n\n\n"}
{"name":"IsLeftRegular.star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx : R\nhx : IsLeftRegular x\n⊢ IsRightRegular (Star.star x)","decl":"protected theorem IsLeftRegular.star [Mul R] [StarMul R] {x : R} (hx : IsLeftRegular x) :\n    IsRightRegular (star x) :=\n  fun a b h => star_injective <| hx <| by simpa using congr_arg Star.star h\n\n"}
{"name":"IsRightRegular.star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx : R\nhx : IsRightRegular x\n⊢ IsLeftRegular (Star.star x)","decl":"protected theorem IsRightRegular.star [Mul R] [StarMul R] {x : R} (hx : IsRightRegular x) :\n    IsLeftRegular (star x) :=\n  fun a b h => star_injective <| hx <| by simpa using congr_arg Star.star h\n\n"}
{"name":"IsRegular.star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx : R\nhx : IsRegular x\n⊢ IsRegular (Star.star x)","decl":"protected theorem IsRegular.star [Mul R] [StarMul R] {x : R} (hx : IsRegular x) :\n    IsRegular (star x) :=\n  ⟨hx.right.star, hx.left.star⟩\n\n"}
{"name":"isRightRegular_star_iff","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx : R\n⊢ Iff (IsRightRegular (Star.star x)) (IsLeftRegular x)","decl":"@[simp]\ntheorem isRightRegular_star_iff [Mul R] [StarMul R] {x : R} :\n    IsRightRegular (star x) ↔ IsLeftRegular x :=\n  ⟨fun h => star_star x ▸ h.star, (·.star)⟩\n\n"}
{"name":"isLeftRegular_star_iff","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx : R\n⊢ Iff (IsLeftRegular (Star.star x)) (IsRightRegular x)","decl":"@[simp]\ntheorem isLeftRegular_star_iff [Mul R] [StarMul R] {x : R} :\n    IsLeftRegular (star x) ↔ IsRightRegular x :=\n  ⟨fun h => star_star x ▸ h.star, (·.star)⟩\n\n"}
{"name":"isRegular_star_iff","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx : R\n⊢ Iff (IsRegular (Star.star x)) (IsRegular x)","decl":"@[simp]\ntheorem isRegular_star_iff [Mul R] [StarMul R] {x : R} :\n    IsRegular (star x) ↔ IsRegular x := by\n  rw [isRegular_iff, isRegular_iff, isRightRegular_star_iff, isLeftRegular_star_iff, and_comm]\n\n"}
{"name":"MulOpposite.unop_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝ : Star R\nr : MulOpposite R\n⊢ Eq (MulOpposite.unop (Star.star r)) (Star.star (MulOpposite.unop r))","decl":"@[simp]\ntheorem unop_star [Star R] (r : Rᵐᵒᵖ) : unop (star r) = star (unop r) :=\n  rfl\n\n"}
{"name":"MulOpposite.op_star","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝ : Star R\nr : R\n⊢ Eq (MulOpposite.op (Star.star r)) (Star.star (MulOpposite.op r))","decl":"@[simp]\ntheorem op_star [Star R] (r : R) : op (star r) = star (op r) :=\n  rfl\n\n"}
{"name":"StarSemigroup.toOpposite_starModule","module":"Mathlib.Algebra.Star.Basic","initialProofState":"R : Type u\ninst✝¹ : CommMonoid R\ninst✝ : StarMul R\n⊢ StarModule (MulOpposite R) R","decl":"/-- A commutative star monoid is a star module over its opposite via\n`Monoid.toOppositeMulAction`. -/\ninstance StarSemigroup.toOpposite_starModule [CommMonoid R] [StarMul R] :\n    StarModule Rᵐᵒᵖ R :=\n  ⟨fun r s => star_mul' s r.unop⟩\n"}
