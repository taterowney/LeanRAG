{"name":"WittVector.coeff_select","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p : Nat\nR : Type u_1\ninst✝ : CommRing R\nP : Nat → Prop\nx : WittVector p R\nn : Nat\n⊢ Eq ((WittVector.select P x).coeff n) ((MvPolynomial.aeval x.coeff) (WittVector.selectPoly P n))","decl":"theorem coeff_select (x : 𝕎 R) (n : ℕ) :\n    (select P x).coeff n = aeval x.coeff (selectPoly P n) := by\n  dsimp [select, selectPoly]\n  split_ifs with hi\n  · rw [aeval_X, mk]; simp only [hi, if_true]\n  · rw [map_zero, mk]; simp only [hi, if_false]\n\n-- Porting note: replaced `@[is_poly]` with `instance`. Made the argument `P` implicit in doing so.\n"}
{"name":"WittVector.select_isPoly","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p : Nat\nP : Nat → Prop\n⊢ WittVector.IsPoly p fun x x_1 x_2 => WittVector.select P x_2","decl":"instance select_isPoly {P : ℕ → Prop} : IsPoly p fun _ _ x => select P x := by\n  use selectPoly P\n  rintro R _Rcr x\n  funext i\n  apply coeff_select\n\n"}
{"name":"WittVector.select_add_select_not","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p : Nat\nR : Type u_1\ninst✝ : CommRing R\nP : Nat → Prop\nhp : Fact (Nat.Prime p)\nx : WittVector p R\n⊢ Eq (HAdd.hAdd (WittVector.select P x) (WittVector.select (fun i => Not (P i)) x)) x","decl":"theorem select_add_select_not : ∀ x : 𝕎 R, select P x + select (fun i => ¬P i) x = x := by\n  -- Porting note: TC search was insufficient to find this instance, even though all required\n  -- instances exist. See zulip: [https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/WittVector.20saga/near/370073526]\n  have : IsPoly p fun {R} [CommRing R] x ↦ select P x + select (fun i ↦ ¬P i) x :=\n    IsPoly₂.diag (hf := IsPoly₂.comp)\n  ghost_calc x\n  intro n\n  simp only [RingHom.map_add]\n  suffices\n    (bind₁ (selectPoly P)) (wittPolynomial p ℤ n) +\n        (bind₁ (selectPoly fun i => ¬P i)) (wittPolynomial p ℤ n) =\n      wittPolynomial p ℤ n by\n    apply_fun aeval x.coeff at this\n    simpa only [map_add, aeval_bind₁, ← coeff_select]\n  simp only [wittPolynomial_eq_sum_C_mul_X_pow, selectPoly, map_sum, map_pow, map_mul,\n    bind₁_X_right, bind₁_C_right, ← Finset.sum_add_distrib, ← mul_add]\n  apply Finset.sum_congr rfl\n  refine fun m _ => mul_eq_mul_left_iff.mpr (Or.inl ?_)\n  rw [ite_pow, zero_pow (pow_ne_zero _ hp.out.ne_zero)]\n  by_cases Pm : P m\n  · rw [if_pos Pm, if_neg <| not_not_intro Pm, zero_pow Fin.pos'.ne', add_zero]\n  · rwa [if_neg Pm, if_pos, zero_add]\n\n"}
{"name":"WittVector.coeff_add_of_disjoint","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p n : Nat\nR : Type u_1\ninst✝ : CommRing R\nhp : Fact (Nat.Prime p)\nx y : WittVector p R\nh : ∀ (n : Nat), Or (Eq (x.coeff n) 0) (Eq (y.coeff n) 0)\n⊢ Eq ((HAdd.hAdd x y).coeff n) (HAdd.hAdd (x.coeff n) (y.coeff n))","decl":"theorem coeff_add_of_disjoint (x y : 𝕎 R) (h : ∀ n, x.coeff n = 0 ∨ y.coeff n = 0) :\n    (x + y).coeff n = x.coeff n + y.coeff n := by\n  let P : ℕ → Prop := fun n => y.coeff n = 0\n  haveI : DecidablePred P := Classical.decPred P\n  set z := mk p fun n => if P n then x.coeff n else y.coeff n\n  have hx : select P z = x := by\n    ext1 n; rw [select, coeff_mk, coeff_mk]\n    split_ifs with hn\n    · rfl\n    · rw [(h n).resolve_right hn]\n  have hy : select (fun i => ¬P i) z = y := by\n    ext1 n; rw [select, coeff_mk, coeff_mk]\n    split_ifs with hn\n    · exact hn.symm\n    · rfl\n  calc\n    (x + y).coeff n = z.coeff n := by rw [← hx, ← hy, select_add_select_not P z]\n    _ = x.coeff n + y.coeff n := by\n      simp only [z, mk.eq_1]\n      split_ifs with y0\n      · rw [y0, add_zero]\n      · rw [h n |>.resolve_right y0, zero_add]\n\n"}
{"name":"WittVector.init_add_tail","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx : WittVector p R\nn : Nat\n⊢ Eq (HAdd.hAdd (WittVector.init n x) (WittVector.tail n x)) x","decl":"@[simp]\ntheorem init_add_tail (x : 𝕎 R) (n : ℕ) : init n x + tail n x = x := by\n  simp only [init, tail, ← not_lt, select_add_select_not]\n\n"}
{"name":"WittVector.init_init","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p : Nat\nR : Type u_1\ninst✝ : CommRing R\nx : WittVector p R\nn : Nat\n⊢ Eq (WittVector.init n (WittVector.init n x)) (WittVector.init n x)","decl":"@[simp]\ntheorem init_init (x : 𝕎 R) (n : ℕ) : init n (init n x) = init n x := by\n  rw [WittVector.ext_iff]\n  intro i\n  simp only [WittVector.init, WittVector.select, WittVector.coeff_mk]\n  by_cases hi : i < n <;> simp [hi]\n\n"}
{"name":"WittVector.init_add","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx y : WittVector p R\nn : Nat\n⊢ Eq (WittVector.init n (HAdd.hAdd x y)) (WittVector.init n (HAdd.hAdd (WittVector.init n x) (WittVector.init n y)))","decl":"theorem init_add (x y : 𝕎 R) (n : ℕ) : init n (x + y) = init n (init n x + init n y) := by\n  init_ring using wittAdd_vars\n\n"}
{"name":"WittVector.init_mul","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx y : WittVector p R\nn : Nat\n⊢ Eq (WittVector.init n (HMul.hMul x y)) (WittVector.init n (HMul.hMul (WittVector.init n x) (WittVector.init n y)))","decl":"theorem init_mul (x y : 𝕎 R) (n : ℕ) : init n (x * y) = init n (init n x * init n y) := by\n  init_ring using wittMul_vars\n\n"}
{"name":"WittVector.init_neg","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx : WittVector p R\nn : Nat\n⊢ Eq (WittVector.init n (Neg.neg x)) (WittVector.init n (Neg.neg (WittVector.init n x)))","decl":"theorem init_neg (x : 𝕎 R) (n : ℕ) : init n (-x) = init n (-init n x) := by\n  init_ring using wittNeg_vars\n\n"}
{"name":"WittVector.init_sub","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx y : WittVector p R\nn : Nat\n⊢ Eq (WittVector.init n (HSub.hSub x y)) (WittVector.init n (HSub.hSub (WittVector.init n x) (WittVector.init n y)))","decl":"theorem init_sub (x y : 𝕎 R) (n : ℕ) : init n (x - y) = init n (init n x - init n y) := by\n  init_ring using wittSub_vars\n\n"}
{"name":"WittVector.init_nsmul","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nm : Nat\nx : WittVector p R\nn : Nat\n⊢ Eq (WittVector.init n (HSMul.hSMul m x)) (WittVector.init n (HSMul.hSMul m (WittVector.init n x)))","decl":"theorem init_nsmul (m : ℕ) (x : 𝕎 R) (n : ℕ) : init n (m • x) = init n (m • init n x) := by\n  init_ring using fun p [Fact (Nat.Prime p)] n => wittNSMul_vars p m n\n\n"}
{"name":"WittVector.init_zsmul","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nm : Int\nx : WittVector p R\nn : Nat\n⊢ Eq (WittVector.init n (HSMul.hSMul m x)) (WittVector.init n (HSMul.hSMul m (WittVector.init n x)))","decl":"theorem init_zsmul (m : ℤ) (x : 𝕎 R) (n : ℕ) : init n (m • x) = init n (m • init n x) := by\n  init_ring using fun p [Fact (Nat.Prime p)] n => wittZSMul_vars p m n\n\n"}
{"name":"WittVector.init_pow","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nm : Nat\nx : WittVector p R\nn : Nat\n⊢ Eq (WittVector.init n (HPow.hPow x m)) (WittVector.init n (HPow.hPow (WittVector.init n x) m))","decl":"theorem init_pow (m : ℕ) (x : 𝕎 R) (n : ℕ) : init n (x ^ m) = init n (init n x ^ m) := by\n  init_ring using fun p [Fact (Nat.Prime p)] n => wittPow_vars p m n\n\n"}
{"name":"WittVector.init_isPoly","module":"Mathlib.RingTheory.WittVector.InitTail","initialProofState":"p n : Nat\n⊢ WittVector.IsPoly p fun x x_1 => WittVector.init n","decl":"/-- `WittVector.init n x` is polynomial in the coefficients of `x`. -/\ntheorem init_isPoly (n : ℕ) : IsPoly p fun _ _ => init n :=\n  select_isPoly (P := fun i => i < n)\n\n"}
