{"name":"BoxIntegral.Box.measure_Icc_lt_top","module":"Mathlib.Analysis.BoxIntegral.Partition.Measure","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nμ : MeasureTheory.Measure (ι → Real)\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\n⊢ LT.lt (μ (BoxIntegral.Box.Icc I)) Top.top","decl":"theorem measure_Icc_lt_top (μ : Measure (ι → ℝ)) [IsLocallyFiniteMeasure μ] : μ (Box.Icc I) < ∞ :=\n  show μ (Icc I.lower I.upper) < ∞ from I.isCompact_Icc.measure_lt_top\n\n"}
{"name":"BoxIntegral.Box.measure_coe_lt_top","module":"Mathlib.Analysis.BoxIntegral.Partition.Measure","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nμ : MeasureTheory.Measure (ι → Real)\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\n⊢ LT.lt (μ ↑I) Top.top","decl":"theorem measure_coe_lt_top (μ : Measure (ι → ℝ)) [IsLocallyFiniteMeasure μ] : μ I < ∞ :=\n  (measure_mono <| coe_subset_Icc).trans_lt (I.measure_Icc_lt_top μ)\n\n"}
{"name":"BoxIntegral.Box.measurableSet_coe","module":"Mathlib.Analysis.BoxIntegral.Partition.Measure","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Countable ι\n⊢ MeasurableSet ↑I","decl":"theorem measurableSet_coe : MeasurableSet (I : Set (ι → ℝ)) := by\n  rw [coe_eq_pi]\n  exact MeasurableSet.univ_pi fun i => measurableSet_Ioc\n\n"}
{"name":"BoxIntegral.Box.measurableSet_Icc","module":"Mathlib.Analysis.BoxIntegral.Partition.Measure","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Countable ι\n⊢ MeasurableSet (BoxIntegral.Box.Icc I)","decl":"theorem measurableSet_Icc : MeasurableSet (Box.Icc I) :=\n  _root_.measurableSet_Icc\n\n"}
{"name":"BoxIntegral.Box.measurableSet_Ioo","module":"Mathlib.Analysis.BoxIntegral.Partition.Measure","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Countable ι\n⊢ MeasurableSet (BoxIntegral.Box.Ioo I)","decl":"theorem measurableSet_Ioo : MeasurableSet (Box.Ioo I) :=\n  MeasurableSet.univ_pi fun _ => _root_.measurableSet_Ioo\n\n"}
{"name":"BoxIntegral.Box.coe_ae_eq_Icc","module":"Mathlib.Analysis.BoxIntegral.Partition.Measure","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\n⊢ (MeasureTheory.ae MeasureTheory.MeasureSpace.volume).EventuallyEq (↑I) (BoxIntegral.Box.Icc I)","decl":"theorem coe_ae_eq_Icc : (I : Set (ι → ℝ)) =ᵐ[volume] Box.Icc I := by\n  rw [coe_eq_pi]\n  exact Measure.univ_pi_Ioc_ae_eq_Icc\n\n"}
{"name":"BoxIntegral.Box.Ioo_ae_eq_Icc","module":"Mathlib.Analysis.BoxIntegral.Partition.Measure","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\n⊢ (MeasureTheory.ae MeasureTheory.MeasureSpace.volume).EventuallyEq (BoxIntegral.Box.Ioo I) (BoxIntegral.Box.Icc I)","decl":"theorem Ioo_ae_eq_Icc : Box.Ioo I =ᵐ[volume] Box.Icc I :=\n  Measure.univ_pi_Ioo_ae_eq_Icc\n\n"}
{"name":"BoxIntegral.Prepartition.measure_iUnion_toReal","module":"Mathlib.Analysis.BoxIntegral.Partition.Measure","initialProofState":"ι : Type u_1\ninst✝¹ : Finite ι\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nμ : MeasureTheory.Measure (ι → Real)\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\n⊢ Eq (μ π.iUnion).toReal (π.boxes.sum fun J => (μ ↑J).toReal)","decl":"theorem Prepartition.measure_iUnion_toReal [Finite ι] {I : Box ι} (π : Prepartition I)\n    (μ : Measure (ι → ℝ)) [IsLocallyFiniteMeasure μ] :\n    (μ π.iUnion).toReal = ∑ J ∈ π.boxes, (μ J).toReal := by\n  erw [← ENNReal.toReal_sum, π.iUnion_def, measure_biUnion_finset π.pairwiseDisjoint]\n  exacts [fun J _ => J.measurableSet_coe, fun J _ => (J.measure_coe_lt_top μ).ne]\n\n"}
{"name":"MeasureTheory.Measure.toBoxAdditive_apply","module":"Mathlib.Analysis.BoxIntegral.Partition.Measure","initialProofState":"ι : Type u_1\ninst✝¹ : Finite ι\nμ : MeasureTheory.Measure (ι → Real)\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nJ : BoxIntegral.Box ι\n⊢ Eq (μ.toBoxAdditive J) (μ ↑J).toReal","decl":"/-- If `μ` is a locally finite measure on `ℝⁿ`, then `fun J ↦ (μ J).toReal` is a box-additive\nfunction. -/\n@[simps]\ndef toBoxAdditive [Finite ι] (μ : Measure (ι → ℝ)) [IsLocallyFiniteMeasure μ] : ι →ᵇᵃ[⊤] ℝ where\n  toFun J := (μ J).toReal\n  sum_partition_boxes' J _ π hπ := by rw [← π.measure_iUnion_toReal, hπ.iUnion_eq]\n\n"}
{"name":"BoxIntegral.Box.volume_apply","module":"Mathlib.Analysis.BoxIntegral.Partition.Measure","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\n⊢ Eq (MeasureTheory.MeasureSpace.volume.toBoxAdditive I) (Finset.univ.prod fun i => HSub.hSub (I.upper i) (I.lower i))","decl":"theorem volume_apply (I : Box ι) :\n    (volume : Measure (ι → ℝ)).toBoxAdditive I = ∏ i, (I.upper i - I.lower i) := by\n  rw [Measure.toBoxAdditive_apply, coe_eq_pi, Real.volume_pi_Ioc_toReal I.lower_le_upper]\n\n"}
{"name":"BoxIntegral.Box.volume_apply'","module":"Mathlib.Analysis.BoxIntegral.Partition.Measure","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nI : BoxIntegral.Box ι\n⊢ Eq (MeasureTheory.MeasureSpace.volume ↑I).toReal (Finset.univ.prod fun i => HSub.hSub (I.upper i) (I.lower i))","decl":"@[simp]\ntheorem volume_apply' (I : Box ι) :\n    ((volume : Measure (ι → ℝ)) I).toReal = ∏ i, (I.upper i - I.lower i) := by\n  rw [coe_eq_pi, Real.volume_pi_Ioc_toReal I.lower_le_upper]\n\n"}
{"name":"BoxIntegral.Box.volume_face_mul","module":"Mathlib.Analysis.BoxIntegral.Partition.Measure","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\n⊢ Eq (HMul.hMul (Finset.univ.prod fun j => HSub.hSub ((I.face i).upper j) ((I.face i).lower j)) (HSub.hSub (I.upper i) (I.lower i))) (Finset.univ.prod fun j => HSub.hSub (I.upper j) (I.lower j))","decl":"theorem volume_face_mul {n} (i : Fin (n + 1)) (I : Box (Fin (n + 1))) :\n    (∏ j, ((I.face i).upper j - (I.face i).lower j)) * (I.upper i - I.lower i) =\n      ∏ j, (I.upper j - I.lower j) := by\n  simp only [face_lower, face_upper, (· ∘ ·), Fin.prod_univ_succAbove _ i, mul_comm]\n\n"}
{"name":"BoxIntegral.BoxAdditiveMap.volume_apply","module":"Mathlib.Analysis.BoxIntegral.Partition.Measure","initialProofState":"ι : Type u_1\ninst✝² : Fintype ι\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nI : BoxIntegral.Box ι\nx : E\n⊢ Eq ((BoxIntegral.BoxAdditiveMap.volume I) x) (HSMul.hSMul (Finset.univ.prod fun j => HSub.hSub (I.upper j) (I.lower j)) x)","decl":"theorem volume_apply {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E] (I : Box ι) (x : E) :\n    BoxAdditiveMap.volume I x = (∏ j, (I.upper j - I.lower j)) • x := by\n  rw [BoxAdditiveMap.volume, toSMul_apply]\n  exact congr_arg₂ (· • ·) I.volume_apply rfl\n\n"}
