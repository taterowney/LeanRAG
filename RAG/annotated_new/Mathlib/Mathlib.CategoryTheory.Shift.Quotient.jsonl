{"name":"HomRel.IsCompatibleWithShift.condition","module":"Mathlib.CategoryTheory.Shift.Quotient","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nr : HomRel C\nA : Type w\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\nself : r.IsCompatibleWithShift A\na : A\nX Y : C\nf g : Quiver.Hom X Y\na✝ : r f g\n⊢ r ((CategoryTheory.shiftFunctor C a).map f) ((CategoryTheory.shiftFunctor C a).map g)","decl":"/-- A relation on morphisms is compatible with the shift by a monoid `A` when the\nrelation if preserved by the shift. -/\nclass IsCompatibleWithShift : Prop where\n  /-- the condition that the relation is preserved by the shift -/\n  condition : ∀ (a : A) ⦃X Y : C⦄ (f g : X ⟶ Y), r f g → r (f⟦a⟧') (g⟦a⟧')\n\n"}
{"name":"CategoryTheory.Quotient.LiftCommShift.iso_hom_app","module":"Mathlib.CategoryTheory.Shift.Quotient","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nr : HomRel C\nA : Type w\ninst✝⁴ : AddMonoid A\ninst✝³ : CategoryTheory.HasShift C A\ninst✝² : CategoryTheory.HasShift D A\ninst✝¹ : r.IsCompatibleWithShift A\ninst✝ : F.CommShift A\nhF : ∀ (x y : C) (f₁ f₂ : Quiver.Hom x y), r f₁ f₂ → Eq (F.map f₁) (F.map f₂)\na : A\nX : C\n⊢ Eq ((CategoryTheory.Quotient.LiftCommShift.iso F r hF a).hom.app ((CategoryTheory.Quotient.functor r).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Quotient.lift r F hF).map (((CategoryTheory.Quotient.functor r).commShiftIso a).inv.app X)) ((F.commShiftIso a).hom.app X))","decl":"@[simp]\nlemma iso_hom_app (a : A) (X : C) :\n    (iso F r hF a).hom.app ((functor r).obj X) =\n      (lift r F hF).map (((functor r).commShiftIso a).inv.app X) ≫\n      (F.commShiftIso a).hom.app X := by\n  dsimp only [iso, natIsoLift]\n  rw [natTransLift_app]\n  dsimp\n  erw [comp_id, id_comp, id_comp, id_comp, Functor.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Quotient.LiftCommShift.iso_inv_app","module":"Mathlib.CategoryTheory.Shift.Quotient","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nr : HomRel C\nA : Type w\ninst✝⁴ : AddMonoid A\ninst✝³ : CategoryTheory.HasShift C A\ninst✝² : CategoryTheory.HasShift D A\ninst✝¹ : r.IsCompatibleWithShift A\ninst✝ : F.CommShift A\nhF : ∀ (x y : C) (f₁ f₂ : Quiver.Hom x y), r f₁ f₂ → Eq (F.map f₁) (F.map f₂)\na : A\nX : C\n⊢ Eq ((CategoryTheory.Quotient.LiftCommShift.iso F r hF a).inv.app ((CategoryTheory.Quotient.functor r).obj X)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app X) ((CategoryTheory.Quotient.lift r F hF).map (((CategoryTheory.Quotient.functor r).commShiftIso a).hom.app X)))","decl":"@[simp]\nlemma iso_inv_app (a : A) (X : C) :\n    (iso F r hF a).inv.app ((functor r).obj X) =\n      (F.commShiftIso a).inv.app X ≫\n      (lift r F hF).map (((functor r).commShiftIso a).hom.app X) := by\n  dsimp only [iso, natIsoLift]\n  rw [natTransLift_app]\n  dsimp\n  erw [id_comp, comp_id, comp_id, comp_id, Functor.map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Quotient.liftCommShift_compatibility","module":"Mathlib.CategoryTheory.Shift.Quotient","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁵ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nr : HomRel C\nA : Type w\ninst✝⁴ : AddMonoid A\ninst✝³ : CategoryTheory.HasShift C A\ninst✝² : CategoryTheory.HasShift D A\ninst✝¹ : r.IsCompatibleWithShift A\ninst✝ : F.CommShift A\nhF : ∀ (x y : C) (f₁ f₂ : Quiver.Hom x y), r f₁ f₂ → Eq (F.map f₁) (F.map f₂)\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.Quotient.lift.isLift r F hF).hom A","decl":"instance liftCommShift_compatibility :\n    NatTrans.CommShift (Quotient.lift.isLift r F hF).hom A where\n  shift_comm a := by\n    ext X\n    dsimp\n    erw [Functor.map_id, id_comp, comp_id]\n    rw [Functor.commShiftIso_comp_hom_app]\n    erw [LiftCommShift.iso_hom_app]\n    rw [← Functor.map_comp_assoc, Iso.hom_inv_id_app, Functor.map_id, id_comp]\n\n"}
