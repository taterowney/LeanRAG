{"name":"Ideal.decomposition_erase_inf","module":"Mathlib.RingTheory.Lasker","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq (Ideal R)\nI : Ideal R\ns : Finset (Ideal R)\nhs : Eq (s.inf id) I\n⊢ Exists fun t => And (HasSubset.Subset t s) (And (Eq (t.inf id) I) (∀ ⦃J : Ideal R⦄, Membership.mem t J → Not (LE.le ((t.erase J).inf id) J)))","decl":"lemma decomposition_erase_inf [DecidableEq (Ideal R)] {I : Ideal R}\n    {s : Finset (Ideal R)} (hs : s.inf id = I) :\n    ∃ t : Finset (Ideal R), t ⊆ s ∧ t.inf id = I ∧ (∀ ⦃J⦄, J ∈ t → ¬ (t.erase J).inf id ≤ J) := by\n  induction s using Finset.strongInductionOn\n  rename_i _ s IH\n  by_cases H : ∀ J ∈ s, ¬ (s.erase J).inf id ≤ J\n  · exact ⟨s, Finset.Subset.rfl, hs, H⟩\n  push_neg at H\n  obtain ⟨J, hJ, hJ'⟩ := H\n  refine (IH (s.erase J) (Finset.erase_ssubset hJ) ?_).imp\n    fun t ↦ And.imp_left (fun ht ↦ ht.trans (Finset.erase_subset _ _))\n  rw [← Finset.insert_erase hJ] at hs\n  simp [← hs, hJ']\n\n"}
{"name":"Ideal.isPrimary_decomposition_pairwise_ne_radical","module":"Mathlib.RingTheory.Lasker","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\ns : Finset (Ideal R)\nhs : Eq (s.inf id) I\nhs' : ∀ ⦃J : Ideal R⦄, Membership.mem s J → J.IsPrimary\n⊢ Exists fun t => And (Eq (t.inf id) I) (And (∀ ⦃J : Ideal R⦄, Membership.mem t J → J.IsPrimary) ((↑t).Pairwise (Function.onFun (fun x1 x2 => Ne x1 x2) Ideal.radical)))","decl":"lemma isPrimary_decomposition_pairwise_ne_radical {I : Ideal R}\n    {s : Finset (Ideal R)} (hs : s.inf id = I) (hs' : ∀ ⦃J⦄, J ∈ s → J.IsPrimary) :\n    ∃ t : Finset (Ideal R), t.inf id = I ∧ (∀ ⦃J⦄, J ∈ t → J.IsPrimary) ∧\n      (t : Set (Ideal R)).Pairwise ((· ≠ ·) on radical) := by\n  classical\n  refine ⟨(s.image (fun J ↦ s.filter (fun I ↦ I.radical = J.radical))).image fun t ↦ t.inf id,\n    ?_, ?_, ?_⟩\n  · rw [← hs]\n    refine le_antisymm ?_ ?_ <;> intro x hx\n    · simp only [Finset.inf_image, CompTriple.comp_eq, Submodule.mem_finset_inf,\n      Function.comp_apply, Finset.mem_filter, id_eq, and_imp] at hx ⊢\n      intro J hJ\n      exact hx J hJ J hJ rfl\n    · simp only [Submodule.mem_finset_inf, id_eq, Finset.inf_image, CompTriple.comp_eq,\n      Function.comp_apply, Finset.mem_filter, and_imp] at hx ⊢\n      intro J _ K hK _\n      exact hx K hK\n  · simp only [Finset.mem_image, exists_exists_and_eq_and, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff₂]\n    intro J hJ\n    refine isPrimary_finset_inf (i := J) ?_ ?_ (by simp)\n    · simp [hJ]\n    · simp only [Finset.mem_filter, id_eq, and_imp]\n      intro y hy\n      simp [hs' hy]\n  · intro I hI J hJ hIJ\n    simp only [Finset.coe_image, Set.mem_image, Finset.mem_coe, exists_exists_and_eq_and] at hI hJ\n    obtain ⟨I', hI', hI⟩ := hI\n    obtain ⟨J', hJ', hJ⟩ := hJ\n    simp only [Function.onFun, ne_eq]\n    contrapose! hIJ\n    suffices I'.radical = J'.radical by\n      rw [← hI, ← hJ, this]\n    · rw [← hI, radical_finset_inf (i := I') (by simp [hI']) (by simp), id_eq] at hIJ\n      rw [hIJ, ← hJ, radical_finset_inf (i := J') (by simp [hJ']) (by simp), id_eq]\n\n"}
{"name":"Ideal.exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition","module":"Mathlib.RingTheory.Lasker","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq (Ideal R)\nI : Ideal R\ns : Finset (Ideal R)\nhs : Eq (s.inf id) I\nhs' : ∀ ⦃J : Ideal R⦄, Membership.mem s J → J.IsPrimary\n⊢ Exists fun t => And (Eq (t.inf id) I) (And (∀ ⦃J : Ideal R⦄, Membership.mem t J → J.IsPrimary) (And ((↑t).Pairwise (Function.onFun (fun x1 x2 => Ne x1 x2) Ideal.radical)) (∀ ⦃J : Ideal R⦄, Membership.mem t J → Not (LE.le ((t.erase J).inf id) J))))","decl":"lemma exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition [DecidableEq (Ideal R)]\n    {I : Ideal R} {s : Finset (Ideal R)} (hs : s.inf id = I) (hs' : ∀ ⦃J⦄, J ∈ s → J.IsPrimary) :\n    ∃ t : Finset (Ideal R), t.inf id = I ∧ (∀ ⦃J⦄, J ∈ t → J.IsPrimary) ∧\n      ((t : Set (Ideal R)).Pairwise ((· ≠ ·) on radical)) ∧\n      (∀ ⦃J⦄, J ∈ t → ¬ (t.erase J).inf id ≤ J) := by\n  obtain ⟨t, ht, ht', ht''⟩ := isPrimary_decomposition_pairwise_ne_radical hs hs'\n  obtain ⟨u, hut, hu, hu'⟩ := decomposition_erase_inf ht\n  exact ⟨u, hu, fun _ hi ↦ ht' (hut hi), ht''.mono hut, hu'⟩\n\n"}
{"name":"Ideal.IsLasker.minimal","module":"Mathlib.RingTheory.Lasker","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq (Ideal R)\nh : IsLasker R\nI : Ideal R\n⊢ Exists fun t => And (Eq (t.inf id) I) (And (∀ ⦃J : Ideal R⦄, Membership.mem t J → J.IsPrimary) (And ((↑t).Pairwise (Function.onFun (fun x1 x2 => Ne x1 x2) Ideal.radical)) (∀ ⦃J : Ideal R⦄, Membership.mem t J → Not (LE.le ((t.erase J).inf id) J))))","decl":"lemma IsLasker.minimal [DecidableEq (Ideal R)] (h : IsLasker R) (I : Ideal R) :\n    ∃ t : Finset (Ideal R), t.inf id = I ∧ (∀ ⦃J⦄, J ∈ t → J.IsPrimary) ∧\n      ((t : Set (Ideal R)).Pairwise ((· ≠ ·) on radical)) ∧\n      (∀ ⦃J⦄, J ∈ t → ¬ (t.erase J).inf id ≤ J) := by\n  obtain ⟨s, hs, hs'⟩ := h I\n  exact exists_minimal_isPrimary_decomposition_of_isPrimary_decomposition hs hs'\n\n"}
{"name":"InfIrred.isPrimary","module":"Mathlib.RingTheory.Lasker","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsNoetherianRing R\nI : Ideal R\nh : InfIrred I\n⊢ I.IsPrimary","decl":"lemma _root_.InfIrred.isPrimary {I : Ideal R} (h : InfIrred I) : I.IsPrimary := by\n  rw [Ideal.isPrimary_iff]\n  refine ⟨h.ne_top, fun {a b} hab ↦ ?_⟩\n  let f : ℕ → Ideal R := fun n ↦ (I.colon (span {b ^ n}))\n  have hf : Monotone f := by\n    intro n m hnm\n    simp_rw [f]\n    exact (Submodule.colon_mono le_rfl (Ideal.span_singleton_le_span_singleton.mpr\n      (pow_dvd_pow b hnm)))\n  obtain ⟨n, hn⟩ := monotone_stabilizes_iff_noetherian.mpr ‹_› ⟨f, hf⟩\n  rcases h with ⟨-, h⟩\n  specialize @h (I.colon (span {b ^ n})) (I + (span {b ^ n})) ?_\n  · refine le_antisymm (fun r ↦ ?_) (le_inf (fun _ ↦ ?_) ?_)\n    · simp only [Submodule.add_eq_sup, sup_comm I, mem_inf, mem_colon_singleton,\n        mem_span_singleton_sup, and_imp, forall_exists_index]\n      rintro hrb t s hs rfl\n      refine add_mem ?_ hs\n      have := hn (n + n) (by simp)\n      simp only [OrderHom.coe_mk, f] at this\n      rw [add_mul, mul_assoc, ← pow_add] at hrb\n      rwa [← mem_colon_singleton, this, mem_colon_singleton,\n           ← Ideal.add_mem_iff_left _ (Ideal.mul_mem_right _ _ hs)]\n    · simpa only [mem_colon_singleton] using mul_mem_right _ _\n    · simp\n  rcases h with (h|h)\n  · replace h : I = I.colon (span {b}) := by\n      rcases eq_or_ne n 0 with rfl|hn'\n      · simpa [f] using hn 1 zero_le_one\n      refine le_antisymm ?_ (h.le.trans' (Submodule.colon_mono le_rfl ?_))\n      · intro\n        simpa only [mem_colon_singleton] using mul_mem_right _ _\n      · exact span_singleton_le_span_singleton.mpr (dvd_pow_self b hn')\n    rw [← mem_colon_singleton, ← h] at hab\n    exact Or.inl hab\n  · rw [← h]\n    refine Or.inr ⟨n, ?_⟩\n    simpa using mem_sup_right (mem_span_singleton_self _)\n\n"}
{"name":"Ideal.isLasker","module":"Mathlib.RingTheory.Lasker","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsNoetherianRing R\n⊢ IsLasker R","decl":"variable (R) in\n/-- The Lasker--Noether theorem: every ideal in a Noetherian ring admits a decomposition into\n  primary ideals. -/\nlemma isLasker : IsLasker R := fun I ↦\n  (exists_infIrred_decomposition I).imp fun _ h ↦ h.imp_right fun h' _ ht ↦ (h' ht).isPrimary\n\n"}
