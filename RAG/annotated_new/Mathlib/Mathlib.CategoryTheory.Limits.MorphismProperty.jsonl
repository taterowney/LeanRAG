{"name":"CategoryTheory.MorphismProperty.Comma.hasLimit_of_closedUnderLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_8, u_1} T\nP : CategoryTheory.MorphismProperty T\nA : Type u_2\nB : Type u_3\nJ : Type u_4\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} A\ninstâœÂ² : CategoryTheory.Category.{u_7, u_3} B\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} J\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nD : CategoryTheory.Functor J (CategoryTheory.MorphismProperty.Comma L R P Top.top Top.top)\nh : CategoryTheory.Limits.ClosedUnderLimitsOfShape J fun f => P f.hom\ninstâœ : CategoryTheory.Limits.HasLimit (D.comp (CategoryTheory.MorphismProperty.Comma.forget L R P Top.top Top.top))\nâŠ¢ CategoryTheory.Limits.HasLimit D","decl":"lemma hasLimit_of_closedUnderLimitsOfShape\n    (h : ClosedUnderLimitsOfShape J (fun f : Comma L R â†¦ P f.hom))\n    [HasLimit (D â‹™ forget L R P âŠ¤ âŠ¤)] :\n    HasLimit D :=\n  haveI : CreatesLimit D (forget L R P âŠ¤ âŠ¤) := forgetCreatesLimitOfClosed _ D h\n  hasLimit_of_created D (forget L R P âŠ¤ âŠ¤)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.hasLimitsOfShape_of_closedUnderLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_8, u_1} T\nP : CategoryTheory.MorphismProperty T\nA : Type u_2\nB : Type u_3\nJ : Type u_4\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} A\ninstâœÂ² : CategoryTheory.Category.{u_7, u_3} B\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} J\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.Comma L R)\nh : CategoryTheory.Limits.ClosedUnderLimitsOfShape J fun f => P f.hom\nâŠ¢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.MorphismProperty.Comma L R P Top.top Top.top)","decl":"lemma hasLimitsOfShape_of_closedUnderLimitsOfShape [HasLimitsOfShape J (Comma L R)]\n    (h : ClosedUnderLimitsOfShape J (fun f : Comma L R â†¦ P f.hom)) :\n    HasLimitsOfShape J (P.Comma L R âŠ¤ âŠ¤) where\n  has_limit _ := hasLimit_of_closedUnderLimitsOfShape _ _ h\n\n"}
{"name":"CategoryTheory.CostructuredArrow.closedUnderLimitsOfShape_discrete_empty","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_4, u_1} T\nP : CategoryTheory.MorphismProperty T\nA : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_3, u_2} A\nL : CategoryTheory.Functor A T\ninstâœÂ³ : L.Faithful\ninstâœÂ² : L.Full\nY : A\ninstâœÂ¹ : P.ContainsIdentities\ninstâœ : P.RespectsIso\nâŠ¢ CategoryTheory.Limits.ClosedUnderLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) fun f => P f.hom","decl":"lemma CostructuredArrow.closedUnderLimitsOfShape_discrete_empty [L.Faithful] [L.Full] {Y : A}\n    [P.ContainsIdentities] [P.RespectsIso] :\n    ClosedUnderLimitsOfShape (Discrete PEmpty.{1})\n      (fun f : CostructuredArrow L (L.obj Y) â†¦ P f.hom) := by\n  rintro D c hc -\n  have : D = Functor.empty _ := Functor.empty_ext' _ _\n  subst this\n  let e : c.pt â‰… CostructuredArrow.mk (ðŸ™ (L.obj Y)) :=\n    hc.conePointUniqueUpToIso CostructuredArrow.mkIdTerminal\n  rw [P.costructuredArrow_iso_iff e]\n  simpa using P.id_mem (L.obj Y)\n\n"}
{"name":"CategoryTheory.Over.closedUnderLimitsOfShape_discrete_empty","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\ninstâœÂ¹ : P.ContainsIdentities\ninstâœ : P.RespectsIso\nâŠ¢ CategoryTheory.Limits.ClosedUnderLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) fun f => P f.hom","decl":"lemma Over.closedUnderLimitsOfShape_discrete_empty [P.ContainsIdentities] [P.RespectsIso] :\n    ClosedUnderLimitsOfShape (Discrete PEmpty.{1}) (fun f : Over X â†¦ P f.hom) :=\n  CostructuredArrow.closedUnderLimitsOfShape_discrete_empty P\n\n"}
{"name":"CategoryTheory.Over.closedUnderLimitsOfShape_pullback","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\ninstâœÂ³ : CategoryTheory.Limits.HasPullbacks T\ninstâœÂ² : P.IsStableUnderComposition\ninstâœÂ¹ : P.IsStableUnderBaseChange\ninstâœ : P.HasOfPostcompProperty P\nâŠ¢ CategoryTheory.Limits.ClosedUnderLimitsOfShape CategoryTheory.Limits.WalkingCospan fun f => P f.hom","decl":"/-- Let `P` be stable under composition and base change. If `P` satisfies cancellation on the right,\nthe subcategory of `Over X` defined by `P` is closed under pullbacks.\n\nWithout the cancellation property, this does not in general. Consider for example\n`P = Function.Surjective` on `Type`. -/\nlemma Over.closedUnderLimitsOfShape_pullback [HasPullbacks T]\n    [P.IsStableUnderComposition] [P.IsStableUnderBaseChange] [P.HasOfPostcompProperty P] :\n    ClosedUnderLimitsOfShape WalkingCospan (fun f : Over X â†¦ P f.hom) := by\n  intro D c hc hf\n  have h : IsPullback (c.Ï€.app .left).left (c.Ï€.app .right).left (D.map WalkingCospan.Hom.inl).left\n        (D.map WalkingCospan.Hom.inr).left := IsPullback.of_isLimit_cone <|\n    Limits.isLimitOfPreserves (CategoryTheory.Over.forget X) hc\n  rw [show c.pt.hom = (c.Ï€.app .left).left â‰« (D.obj .left).hom by simp]\n  apply P.comp_mem _ _ (P.of_isPullback h.flip ?_) (hf _)\n  exact P.of_postcomp _ (D.obj WalkingCospan.one).hom (hf .one) (by simpa using hf .right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.instHasTerminalTopOfContainsIdentities","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\ninstâœ : P.ContainsIdentities\nâŠ¢ CategoryTheory.Limits.HasTerminal (P.Over Top.top X)","decl":"instance [P.ContainsIdentities] : HasTerminal (P.Over âŠ¤ X) :=\n  let h : IsTerminal (Over.mk âŠ¤ (ðŸ™ X) (P.id_mem X)) := Over.mkIdTerminal P X\n  h.hasTerminal\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.hasPullbacks","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\ninstâœÂ³ : CategoryTheory.Limits.HasPullbacks T\ninstâœÂ² : P.IsStableUnderComposition\ninstâœÂ¹ : P.IsStableUnderBaseChange\ninstâœ : P.HasOfPostcompProperty P\nâŠ¢ CategoryTheory.Limits.HasPullbacks (P.Over Top.top X)","decl":"/-- If `P` is stable under composition, base change and satisfies post-cancellation,\n`P.Over âŠ¤ X` has pullbacks -/\ninstance (priority := 900) hasPullbacks [HasPullbacks T] [P.IsStableUnderComposition]\n    [P.IsStableUnderBaseChange] [P.HasOfPostcompProperty P] : HasPullbacks (P.Over âŠ¤ X) :=\n  haveI : HasLimitsOfShape WalkingCospan (Comma (ðŸ­ T) (Functor.fromPUnit X)) :=\n    inferInstanceAs <| HasLimitsOfShape WalkingCospan (Over X)\n  hasLimitsOfShape_of_closedUnderLimitsOfShape P\n    (Over.closedUnderLimitsOfShape_pullback P)\n\n"}
