{"name":"CategoryTheory.MorphismProperty.Comma.hasLimit_of_closedUnderLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_8, u_1} T\nP : CategoryTheory.MorphismProperty T\nA : Type u_2\nB : Type u_3\nJ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\ninst✝² : CategoryTheory.Category.{u_7, u_3} B\ninst✝¹ : CategoryTheory.Category.{u_5, u_4} J\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nD : CategoryTheory.Functor J (CategoryTheory.MorphismProperty.Comma L R P Top.top Top.top)\nh : CategoryTheory.Limits.ClosedUnderLimitsOfShape J fun f => P f.hom\ninst✝ : CategoryTheory.Limits.HasLimit (D.comp (CategoryTheory.MorphismProperty.Comma.forget L R P Top.top Top.top))\n⊢ CategoryTheory.Limits.HasLimit D","decl":"lemma hasLimit_of_closedUnderLimitsOfShape\n    (h : ClosedUnderLimitsOfShape J (fun f : Comma L R ↦ P f.hom))\n    [HasLimit (D ⋙ forget L R P ⊤ ⊤)] :\n    HasLimit D :=\n  haveI : CreatesLimit D (forget L R P ⊤ ⊤) := forgetCreatesLimitOfClosed _ D h\n  hasLimit_of_created D (forget L R P ⊤ ⊤)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.hasLimitsOfShape_of_closedUnderLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_8, u_1} T\nP : CategoryTheory.MorphismProperty T\nA : Type u_2\nB : Type u_3\nJ : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_2} A\ninst✝² : CategoryTheory.Category.{u_7, u_3} B\ninst✝¹ : CategoryTheory.Category.{u_5, u_4} J\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.Comma L R)\nh : CategoryTheory.Limits.ClosedUnderLimitsOfShape J fun f => P f.hom\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.MorphismProperty.Comma L R P Top.top Top.top)","decl":"lemma hasLimitsOfShape_of_closedUnderLimitsOfShape [HasLimitsOfShape J (Comma L R)]\n    (h : ClosedUnderLimitsOfShape J (fun f : Comma L R ↦ P f.hom)) :\n    HasLimitsOfShape J (P.Comma L R ⊤ ⊤) where\n  has_limit _ := hasLimit_of_closedUnderLimitsOfShape _ _ h\n\n"}
{"name":"CategoryTheory.CostructuredArrow.closedUnderLimitsOfShape_discrete_empty","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} T\nP : CategoryTheory.MorphismProperty T\nA : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} A\nL : CategoryTheory.Functor A T\ninst✝³ : L.Faithful\ninst✝² : L.Full\nY : A\ninst✝¹ : P.ContainsIdentities\ninst✝ : P.RespectsIso\n⊢ CategoryTheory.Limits.ClosedUnderLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) fun f => P f.hom","decl":"lemma CostructuredArrow.closedUnderLimitsOfShape_discrete_empty [L.Faithful] [L.Full] {Y : A}\n    [P.ContainsIdentities] [P.RespectsIso] :\n    ClosedUnderLimitsOfShape (Discrete PEmpty.{1})\n      (fun f : CostructuredArrow L (L.obj Y) ↦ P f.hom) := by\n  rintro D c hc -\n  have : D = Functor.empty _ := Functor.empty_ext' _ _\n  subst this\n  let e : c.pt ≅ CostructuredArrow.mk (𝟙 (L.obj Y)) :=\n    hc.conePointUniqueUpToIso CostructuredArrow.mkIdTerminal\n  rw [P.costructuredArrow_iso_iff e]\n  simpa using P.id_mem (L.obj Y)\n\n"}
{"name":"CategoryTheory.Over.closedUnderLimitsOfShape_discrete_empty","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\ninst✝¹ : P.ContainsIdentities\ninst✝ : P.RespectsIso\n⊢ CategoryTheory.Limits.ClosedUnderLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) fun f => P f.hom","decl":"lemma Over.closedUnderLimitsOfShape_discrete_empty [P.ContainsIdentities] [P.RespectsIso] :\n    ClosedUnderLimitsOfShape (Discrete PEmpty.{1}) (fun f : Over X ↦ P f.hom) :=\n  CostructuredArrow.closedUnderLimitsOfShape_discrete_empty P\n\n"}
{"name":"CategoryTheory.Over.closedUnderLimitsOfShape_pullback","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\ninst✝³ : CategoryTheory.Limits.HasPullbacks T\ninst✝² : P.IsStableUnderComposition\ninst✝¹ : P.IsStableUnderBaseChange\ninst✝ : P.HasOfPostcompProperty P\n⊢ CategoryTheory.Limits.ClosedUnderLimitsOfShape CategoryTheory.Limits.WalkingCospan fun f => P f.hom","decl":"/-- Let `P` be stable under composition and base change. If `P` satisfies cancellation on the right,\nthe subcategory of `Over X` defined by `P` is closed under pullbacks.\n\nWithout the cancellation property, this does not in general. Consider for example\n`P = Function.Surjective` on `Type`. -/\nlemma Over.closedUnderLimitsOfShape_pullback [HasPullbacks T]\n    [P.IsStableUnderComposition] [P.IsStableUnderBaseChange] [P.HasOfPostcompProperty P] :\n    ClosedUnderLimitsOfShape WalkingCospan (fun f : Over X ↦ P f.hom) := by\n  intro D c hc hf\n  have h : IsPullback (c.π.app .left).left (c.π.app .right).left (D.map WalkingCospan.Hom.inl).left\n        (D.map WalkingCospan.Hom.inr).left := IsPullback.of_isLimit_cone <|\n    Limits.isLimitOfPreserves (CategoryTheory.Over.forget X) hc\n  rw [show c.pt.hom = (c.π.app .left).left ≫ (D.obj .left).hom by simp]\n  apply P.comp_mem _ _ (P.of_isPullback h.flip ?_) (hf _)\n  exact P.of_postcomp _ (D.obj WalkingCospan.one).hom (hf .one) (by simpa using hf .right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.instHasTerminalTopOfContainsIdentities","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\ninst✝ : P.ContainsIdentities\n⊢ CategoryTheory.Limits.HasTerminal (P.Over Top.top X)","decl":"instance [P.ContainsIdentities] : HasTerminal (P.Over ⊤ X) :=\n  let h : IsTerminal (Over.mk ⊤ (𝟙 X) (P.id_mem X)) := Over.mkIdTerminal P X\n  h.hasTerminal\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.hasPullbacks","module":"Mathlib.CategoryTheory.Limits.MorphismProperty","initialProofState":"T : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\ninst✝³ : CategoryTheory.Limits.HasPullbacks T\ninst✝² : P.IsStableUnderComposition\ninst✝¹ : P.IsStableUnderBaseChange\ninst✝ : P.HasOfPostcompProperty P\n⊢ CategoryTheory.Limits.HasPullbacks (P.Over Top.top X)","decl":"/-- If `P` is stable under composition, base change and satisfies post-cancellation,\n`P.Over ⊤ X` has pullbacks -/\ninstance (priority := 900) hasPullbacks [HasPullbacks T] [P.IsStableUnderComposition]\n    [P.IsStableUnderBaseChange] [P.HasOfPostcompProperty P] : HasPullbacks (P.Over ⊤ X) :=\n  haveI : HasLimitsOfShape WalkingCospan (Comma (𝟭 T) (Functor.fromPUnit X)) :=\n    inferInstanceAs <| HasLimitsOfShape WalkingCospan (Over X)\n  hasLimitsOfShape_of_closedUnderLimitsOfShape P\n    (Over.closedUnderLimitsOfShape_pullback P)\n\n"}
