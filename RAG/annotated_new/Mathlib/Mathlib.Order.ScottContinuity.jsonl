{"name":"ScottContinuousOn.mono","module":"Mathlib.Order.ScottContinuity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nD₁ D₂ : Set (Set α)\nf : α → β\nhD : HasSubset.Subset D₁ D₂\nhf : ScottContinuousOn D₂ f\n⊢ ScottContinuousOn D₁ f","decl":"lemma ScottContinuousOn.mono (hD : D₁ ⊆ D₂) (hf : ScottContinuousOn D₂ f) :\n    ScottContinuousOn D₁ f := fun _  hdD₁ hd₁ hd₂ _ hda => hf (hD hdD₁) hd₁ hd₂ hda\n\n"}
{"name":"ScottContinuousOn.monotone","module":"Mathlib.Order.ScottContinuity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nD : Set (Set α)\nhD : ∀ (a b : α), LE.le a b → Membership.mem D (Insert.insert a (Singleton.singleton b))\nh : ScottContinuousOn D f\n⊢ Monotone f","decl":"protected theorem ScottContinuousOn.monotone (D : Set (Set α)) (hD : ∀ a b : α, a ≤ b → {a, b} ∈ D)\n    (h : ScottContinuousOn D f) : Monotone f := by\n  refine fun a b hab =>\n    (h (hD a b hab) (insert_nonempty _ _) (directedOn_pair le_refl hab) ?_).1\n      (mem_image_of_mem _ <| mem_insert _ _)\n  rw [IsLUB, upperBounds_insert, upperBounds_singleton,\n    inter_eq_self_of_subset_right (Ici_subset_Ici.2 hab)]\n  exact isLeast_Ici\n\n"}
{"name":"ScottContinuousOn.id","module":"Mathlib.Order.ScottContinuity","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nD : Set (Set α)\n⊢ ScottContinuousOn D id","decl":"@[simp] lemma ScottContinuousOn.id : ScottContinuousOn D (id : α → α) := by simp [ScottContinuousOn]\n\n"}
{"name":"ScottContinuousOn.prodMk","module":"Mathlib.Order.ScottContinuity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nD : Set (Set α)\nf g : α → β\nhD : ∀ (a b : α), LE.le a b → Membership.mem D (Insert.insert a (Singleton.singleton b))\nhf : ScottContinuousOn D f\nhg : ScottContinuousOn D g\n⊢ ScottContinuousOn D fun x => { fst := f x, snd := g x }","decl":"lemma ScottContinuousOn.prodMk (hD : ∀ a b : α, a ≤ b → {a, b} ∈ D)\n    (hf : ScottContinuousOn D f) (hg : ScottContinuousOn D g) :\n    ScottContinuousOn D fun x => (f x, g x) := fun d hd₁ hd₂ hd₃ a hda => by\n  rw [IsLUB, IsLeast, upperBounds]\n  constructor\n  · simp only [mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, mem_setOf_eq,\n      Prod.mk_le_mk]\n    intro b hb\n    exact ⟨hf.monotone D hD (hda.1 hb), hg.monotone D hD (hda.1 hb)⟩\n  · intro ⟨p₁, p₂⟩ hp\n    simp only [mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, mem_setOf_eq,\n      Prod.mk_le_mk] at hp\n    constructor\n    · rw [isLUB_le_iff (hf hd₁ hd₂ hd₃ hda), upperBounds]\n      simp only [mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, mem_setOf_eq]\n      intro _ hb\n      exact (hp _ hb).1\n    · rw [isLUB_le_iff (hg hd₁ hd₂ hd₃ hda), upperBounds]\n      simp only [mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, mem_setOf_eq]\n      intro _ hb\n      exact (hp _ hb).2\n\n"}
{"name":"scottContinuousOn_univ","module":"Mathlib.Order.ScottContinuity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (ScottContinuousOn Set.univ f) (ScottContinuous f)","decl":"@[simp] lemma scottContinuousOn_univ : ScottContinuousOn univ f ↔ ScottContinuous f := by\n  simp [ScottContinuousOn, ScottContinuous]\n\n"}
{"name":"ScottContinuous.scottContinuousOn","module":"Mathlib.Order.ScottContinuity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nD : Set (Set α)\na✝ : ScottContinuous f\n⊢ ScottContinuousOn D f","decl":"lemma ScottContinuous.scottContinuousOn {D : Set (Set α)} :\n    ScottContinuous f → ScottContinuousOn D f := fun h _ _ d₂ d₃ _ hda => h d₂ d₃ hda\n\n"}
{"name":"ScottContinuous.monotone","module":"Mathlib.Order.ScottContinuity","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nh : ScottContinuous f\n⊢ Monotone f","decl":"protected theorem ScottContinuous.monotone (h : ScottContinuous f) : Monotone f :=\n  h.scottContinuousOn.monotone univ (fun _ _ _ ↦ mem_univ _)\n\n"}
{"name":"ScottContinuous.id","module":"Mathlib.Order.ScottContinuity","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ ScottContinuous id","decl":"@[simp] lemma ScottContinuous.id : ScottContinuous (id : α → α) := by simp [ScottContinuous]\n\n"}
{"name":"ScottContinuousOn.sup₂","module":"Mathlib.Order.ScottContinuity","initialProofState":"β : Type u_2\ninst✝ : SemilatticeSup β\nD : Set (Set (Prod β β))\n⊢ ScottContinuousOn D fun x => ScottContinuousOn.sup₂.match_1 (fun x => β) x fun a b => Max.max a b","decl":"lemma ScottContinuousOn.sup₂ {D : Set (Set (β × β))} :\n    ScottContinuousOn D fun (a, b) => (a ⊔ b : β) := by\n  simp only\n  intro d _ _ _ ⟨p₁, p₂⟩ hdp\n  rw [IsLUB, IsLeast, upperBounds] at hdp\n  simp only [Prod.forall, mem_setOf_eq, Prod.mk_le_mk] at hdp\n  rw [IsLUB, IsLeast, upperBounds]\n  constructor\n  · simp only [mem_image, Prod.exists, forall_exists_index, and_imp, mem_setOf_eq]\n    intro a b₁ b₂ hbd hba\n    rw [← hba]\n    exact sup_le_sup (hdp.1 _ _ hbd).1 (hdp.1 _ _ hbd).2\n  · simp only [mem_image, Prod.exists, forall_exists_index, and_imp]\n    intro b hb\n    simp only [sup_le_iff]\n    have e1 : (p₁, p₂) ∈ lowerBounds {x | ∀ (b₁ b₂ : β), (b₁, b₂) ∈ d → (b₁, b₂) ≤ x} := hdp.2\n    rw [lowerBounds] at e1\n    simp only [mem_setOf_eq, Prod.forall, Prod.mk_le_mk] at e1\n    apply e1\n    intro b₁ b₂ hb'\n    exact sup_le_iff.mp (hb b₁ b₂ hb' rfl)\n\n"}
