{"name":"DivisionSemiring.nnqsmul_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionSemiring K\nq : NNRat\na : K\n⊢ Eq (DivisionSemiring.nnqsmul q a) (HMul.hMul (↑q) a)","decl":"/-- A `DivisionSemiring` is a `Semiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionSemiring K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the division semiring has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionSemiring (K : Type*) extends Semiring K, GroupWithZero K, NNRatCast K where\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be propositionally equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n\n"}
{"name":"DivisionSemiring.zpow_neg'","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionSemiring K\nn : Nat\na : K\n⊢ Eq (DivisionSemiring.zpow (Int.negSucc n) a) (Inv.inv (DivisionSemiring.zpow (↑n.succ) a))","decl":"/-- A `DivisionSemiring` is a `Semiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionSemiring K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the division semiring has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionSemiring (K : Type*) extends Semiring K, GroupWithZero K, NNRatCast K where\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be propositionally equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n\n"}
{"name":"DivisionSemiring.toNontrivial","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionSemiring K\n⊢ Nontrivial K","decl":"/-- A `DivisionSemiring` is a `Semiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionSemiring K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the division semiring has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionSemiring (K : Type*) extends Semiring K, GroupWithZero K, NNRatCast K where\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be propositionally equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n\n"}
{"name":"DivisionSemiring.zpow_zero'","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionSemiring K\na : K\n⊢ Eq (DivisionSemiring.zpow 0 a) 1","decl":"/-- A `DivisionSemiring` is a `Semiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionSemiring K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the division semiring has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionSemiring (K : Type*) extends Semiring K, GroupWithZero K, NNRatCast K where\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be propositionally equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n\n"}
{"name":"DivisionSemiring.zpow_succ'","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionSemiring K\nn : Nat\na : K\n⊢ Eq (DivisionSemiring.zpow (↑n.succ) a) (HMul.hMul (DivisionSemiring.zpow (↑n) a) a)","decl":"/-- A `DivisionSemiring` is a `Semiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionSemiring K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the division semiring has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionSemiring (K : Type*) extends Semiring K, GroupWithZero K, NNRatCast K where\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be propositionally equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n\n"}
{"name":"DivisionSemiring.div_eq_mul_inv","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionSemiring K\na b : K\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))","decl":"/-- A `DivisionSemiring` is a `Semiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionSemiring K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the division semiring has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionSemiring (K : Type*) extends Semiring K, GroupWithZero K, NNRatCast K where\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be propositionally equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n\n"}
{"name":"DivisionSemiring.nnratCast_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionSemiring K\nq : NNRat\n⊢ Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)","decl":"/-- A `DivisionSemiring` is a `Semiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionSemiring K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the division semiring has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionSemiring (K : Type*) extends Semiring K, GroupWithZero K, NNRatCast K where\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be propositionally equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n\n"}
{"name":"DivisionSemiring.inv_zero","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionSemiring K\n⊢ Eq (Inv.inv 0) 0","decl":"/-- A `DivisionSemiring` is a `Semiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionSemiring K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the division semiring has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionSemiring (K : Type*) extends Semiring K, GroupWithZero K, NNRatCast K where\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be propositionally equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n\n"}
{"name":"DivisionSemiring.mul_inv_cancel","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionSemiring K\na : K\na✝ : Ne a 0\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"/-- A `DivisionSemiring` is a `Semiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionSemiring K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the division semiring has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionSemiring (K : Type*) extends Semiring K, GroupWithZero K, NNRatCast K where\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be propositionally equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n\n"}
{"name":"DivisionRing.inv_zero","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionRing K\n⊢ Eq (Inv.inv 0) 0","decl":"/-- A `DivisionRing` is a `Ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionRing K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance]. Similarly, there are maps `nnratCast ℚ≥0 → K` and\n`nnqsmul : ℚ≥0 → K → K` to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance.\n\nIf the division ring has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionRing (K : Type*)\n  extends Ring K, DivInvMonoid K, Nontrivial K, NNRatCast K, RatCast K where\n  /-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\n  protected mul_inv_cancel : ∀ (a : K), a ≠ 0 → a * a⁻¹ = 1\n  /-- The inverse of `0` is `0` by convention. -/\n  protected inv_zero : (0 : K)⁻¹ = 0\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n  protected ratCast := Rat.castRec\n  /-- However `Rat.cast q` is defined, it must be propositionally equal to `q.num / q.den`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected ratCast_def (q : ℚ) : (Rat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a rational number.\n\n  Unless there is a risk of a `Module ℚ _` instance diamond, write `qsmul := _`. This will set\n  `qsmul` to `(Rat.cast · * ·)` thanks to unification in the default proof of `qsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected qsmul : ℚ → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected qsmul_def (a : ℚ) (x : K) : qsmul a x = Rat.cast a * x := by intros; rfl\n\n-- see Note [lower instance priority]\n"}
{"name":"DivisionRing.ratCast_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionRing K\nq : Rat\n⊢ Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)","decl":"/-- A `DivisionRing` is a `Ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionRing K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance]. Similarly, there are maps `nnratCast ℚ≥0 → K` and\n`nnqsmul : ℚ≥0 → K → K` to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance.\n\nIf the division ring has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionRing (K : Type*)\n  extends Ring K, DivInvMonoid K, Nontrivial K, NNRatCast K, RatCast K where\n  /-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\n  protected mul_inv_cancel : ∀ (a : K), a ≠ 0 → a * a⁻¹ = 1\n  /-- The inverse of `0` is `0` by convention. -/\n  protected inv_zero : (0 : K)⁻¹ = 0\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n  protected ratCast := Rat.castRec\n  /-- However `Rat.cast q` is defined, it must be propositionally equal to `q.num / q.den`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected ratCast_def (q : ℚ) : (Rat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a rational number.\n\n  Unless there is a risk of a `Module ℚ _` instance diamond, write `qsmul := _`. This will set\n  `qsmul` to `(Rat.cast · * ·)` thanks to unification in the default proof of `qsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected qsmul : ℚ → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected qsmul_def (a : ℚ) (x : K) : qsmul a x = Rat.cast a * x := by intros; rfl\n\n-- see Note [lower instance priority]\n"}
{"name":"DivisionRing.mul_inv_cancel","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionRing K\na : K\na✝ : Ne a 0\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"/-- A `DivisionRing` is a `Ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionRing K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance]. Similarly, there are maps `nnratCast ℚ≥0 → K` and\n`nnqsmul : ℚ≥0 → K → K` to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance.\n\nIf the division ring has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionRing (K : Type*)\n  extends Ring K, DivInvMonoid K, Nontrivial K, NNRatCast K, RatCast K where\n  /-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\n  protected mul_inv_cancel : ∀ (a : K), a ≠ 0 → a * a⁻¹ = 1\n  /-- The inverse of `0` is `0` by convention. -/\n  protected inv_zero : (0 : K)⁻¹ = 0\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n  protected ratCast := Rat.castRec\n  /-- However `Rat.cast q` is defined, it must be propositionally equal to `q.num / q.den`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected ratCast_def (q : ℚ) : (Rat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a rational number.\n\n  Unless there is a risk of a `Module ℚ _` instance diamond, write `qsmul := _`. This will set\n  `qsmul` to `(Rat.cast · * ·)` thanks to unification in the default proof of `qsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected qsmul : ℚ → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected qsmul_def (a : ℚ) (x : K) : qsmul a x = Rat.cast a * x := by intros; rfl\n\n-- see Note [lower instance priority]\n"}
{"name":"DivisionRing.zpow_neg'","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionRing K\nn : Nat\na : K\n⊢ Eq (DivisionRing.zpow (Int.negSucc n) a) (Inv.inv (DivisionRing.zpow (↑n.succ) a))","decl":"/-- A `DivisionRing` is a `Ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionRing K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance]. Similarly, there are maps `nnratCast ℚ≥0 → K` and\n`nnqsmul : ℚ≥0 → K → K` to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance.\n\nIf the division ring has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionRing (K : Type*)\n  extends Ring K, DivInvMonoid K, Nontrivial K, NNRatCast K, RatCast K where\n  /-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\n  protected mul_inv_cancel : ∀ (a : K), a ≠ 0 → a * a⁻¹ = 1\n  /-- The inverse of `0` is `0` by convention. -/\n  protected inv_zero : (0 : K)⁻¹ = 0\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n  protected ratCast := Rat.castRec\n  /-- However `Rat.cast q` is defined, it must be propositionally equal to `q.num / q.den`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected ratCast_def (q : ℚ) : (Rat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a rational number.\n\n  Unless there is a risk of a `Module ℚ _` instance diamond, write `qsmul := _`. This will set\n  `qsmul` to `(Rat.cast · * ·)` thanks to unification in the default proof of `qsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected qsmul : ℚ → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected qsmul_def (a : ℚ) (x : K) : qsmul a x = Rat.cast a * x := by intros; rfl\n\n-- see Note [lower instance priority]\n"}
{"name":"DivisionRing.nnqsmul_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionRing K\nq : NNRat\na : K\n⊢ Eq (DivisionRing.nnqsmul q a) (HMul.hMul (↑q) a)","decl":"/-- A `DivisionRing` is a `Ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionRing K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance]. Similarly, there are maps `nnratCast ℚ≥0 → K` and\n`nnqsmul : ℚ≥0 → K → K` to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance.\n\nIf the division ring has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionRing (K : Type*)\n  extends Ring K, DivInvMonoid K, Nontrivial K, NNRatCast K, RatCast K where\n  /-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\n  protected mul_inv_cancel : ∀ (a : K), a ≠ 0 → a * a⁻¹ = 1\n  /-- The inverse of `0` is `0` by convention. -/\n  protected inv_zero : (0 : K)⁻¹ = 0\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n  protected ratCast := Rat.castRec\n  /-- However `Rat.cast q` is defined, it must be propositionally equal to `q.num / q.den`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected ratCast_def (q : ℚ) : (Rat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a rational number.\n\n  Unless there is a risk of a `Module ℚ _` instance diamond, write `qsmul := _`. This will set\n  `qsmul` to `(Rat.cast · * ·)` thanks to unification in the default proof of `qsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected qsmul : ℚ → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected qsmul_def (a : ℚ) (x : K) : qsmul a x = Rat.cast a * x := by intros; rfl\n\n-- see Note [lower instance priority]\n"}
{"name":"DivisionRing.qsmul_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionRing K\na : Rat\nx : K\n⊢ Eq (DivisionRing.qsmul a x) (HMul.hMul (↑a) x)","decl":"/-- A `DivisionRing` is a `Ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionRing K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance]. Similarly, there are maps `nnratCast ℚ≥0 → K` and\n`nnqsmul : ℚ≥0 → K → K` to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance.\n\nIf the division ring has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionRing (K : Type*)\n  extends Ring K, DivInvMonoid K, Nontrivial K, NNRatCast K, RatCast K where\n  /-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\n  protected mul_inv_cancel : ∀ (a : K), a ≠ 0 → a * a⁻¹ = 1\n  /-- The inverse of `0` is `0` by convention. -/\n  protected inv_zero : (0 : K)⁻¹ = 0\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n  protected ratCast := Rat.castRec\n  /-- However `Rat.cast q` is defined, it must be propositionally equal to `q.num / q.den`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected ratCast_def (q : ℚ) : (Rat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a rational number.\n\n  Unless there is a risk of a `Module ℚ _` instance diamond, write `qsmul := _`. This will set\n  `qsmul` to `(Rat.cast · * ·)` thanks to unification in the default proof of `qsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected qsmul : ℚ → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected qsmul_def (a : ℚ) (x : K) : qsmul a x = Rat.cast a * x := by intros; rfl\n\n-- see Note [lower instance priority]\n"}
{"name":"DivisionRing.zpow_zero'","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionRing K\na : K\n⊢ Eq (DivisionRing.zpow 0 a) 1","decl":"/-- A `DivisionRing` is a `Ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionRing K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance]. Similarly, there are maps `nnratCast ℚ≥0 → K` and\n`nnqsmul : ℚ≥0 → K → K` to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance.\n\nIf the division ring has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionRing (K : Type*)\n  extends Ring K, DivInvMonoid K, Nontrivial K, NNRatCast K, RatCast K where\n  /-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\n  protected mul_inv_cancel : ∀ (a : K), a ≠ 0 → a * a⁻¹ = 1\n  /-- The inverse of `0` is `0` by convention. -/\n  protected inv_zero : (0 : K)⁻¹ = 0\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n  protected ratCast := Rat.castRec\n  /-- However `Rat.cast q` is defined, it must be propositionally equal to `q.num / q.den`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected ratCast_def (q : ℚ) : (Rat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a rational number.\n\n  Unless there is a risk of a `Module ℚ _` instance diamond, write `qsmul := _`. This will set\n  `qsmul` to `(Rat.cast · * ·)` thanks to unification in the default proof of `qsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected qsmul : ℚ → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected qsmul_def (a : ℚ) (x : K) : qsmul a x = Rat.cast a * x := by intros; rfl\n\n-- see Note [lower instance priority]\n"}
{"name":"DivisionRing.toNontrivial","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionRing K\n⊢ Nontrivial K","decl":"/-- A `DivisionRing` is a `Ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionRing K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance]. Similarly, there are maps `nnratCast ℚ≥0 → K` and\n`nnqsmul : ℚ≥0 → K → K` to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance.\n\nIf the division ring has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionRing (K : Type*)\n  extends Ring K, DivInvMonoid K, Nontrivial K, NNRatCast K, RatCast K where\n  /-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\n  protected mul_inv_cancel : ∀ (a : K), a ≠ 0 → a * a⁻¹ = 1\n  /-- The inverse of `0` is `0` by convention. -/\n  protected inv_zero : (0 : K)⁻¹ = 0\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n  protected ratCast := Rat.castRec\n  /-- However `Rat.cast q` is defined, it must be propositionally equal to `q.num / q.den`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected ratCast_def (q : ℚ) : (Rat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a rational number.\n\n  Unless there is a risk of a `Module ℚ _` instance diamond, write `qsmul := _`. This will set\n  `qsmul` to `(Rat.cast · * ·)` thanks to unification in the default proof of `qsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected qsmul : ℚ → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected qsmul_def (a : ℚ) (x : K) : qsmul a x = Rat.cast a * x := by intros; rfl\n\n-- see Note [lower instance priority]\n"}
{"name":"DivisionRing.zpow_succ'","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionRing K\nn : Nat\na : K\n⊢ Eq (DivisionRing.zpow (↑n.succ) a) (HMul.hMul (DivisionRing.zpow (↑n) a) a)","decl":"/-- A `DivisionRing` is a `Ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionRing K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance]. Similarly, there are maps `nnratCast ℚ≥0 → K` and\n`nnqsmul : ℚ≥0 → K → K` to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance.\n\nIf the division ring has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionRing (K : Type*)\n  extends Ring K, DivInvMonoid K, Nontrivial K, NNRatCast K, RatCast K where\n  /-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\n  protected mul_inv_cancel : ∀ (a : K), a ≠ 0 → a * a⁻¹ = 1\n  /-- The inverse of `0` is `0` by convention. -/\n  protected inv_zero : (0 : K)⁻¹ = 0\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n  protected ratCast := Rat.castRec\n  /-- However `Rat.cast q` is defined, it must be propositionally equal to `q.num / q.den`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected ratCast_def (q : ℚ) : (Rat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a rational number.\n\n  Unless there is a risk of a `Module ℚ _` instance diamond, write `qsmul := _`. This will set\n  `qsmul` to `(Rat.cast · * ·)` thanks to unification in the default proof of `qsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected qsmul : ℚ → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected qsmul_def (a : ℚ) (x : K) : qsmul a x = Rat.cast a * x := by intros; rfl\n\n-- see Note [lower instance priority]\n"}
{"name":"DivisionRing.div_eq_mul_inv","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionRing K\na b : K\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))","decl":"/-- A `DivisionRing` is a `Ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionRing K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance]. Similarly, there are maps `nnratCast ℚ≥0 → K` and\n`nnqsmul : ℚ≥0 → K → K` to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance.\n\nIf the division ring has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionRing (K : Type*)\n  extends Ring K, DivInvMonoid K, Nontrivial K, NNRatCast K, RatCast K where\n  /-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\n  protected mul_inv_cancel : ∀ (a : K), a ≠ 0 → a * a⁻¹ = 1\n  /-- The inverse of `0` is `0` by convention. -/\n  protected inv_zero : (0 : K)⁻¹ = 0\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n  protected ratCast := Rat.castRec\n  /-- However `Rat.cast q` is defined, it must be propositionally equal to `q.num / q.den`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected ratCast_def (q : ℚ) : (Rat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a rational number.\n\n  Unless there is a risk of a `Module ℚ _` instance diamond, write `qsmul := _`. This will set\n  `qsmul` to `(Rat.cast · * ·)` thanks to unification in the default proof of `qsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected qsmul : ℚ → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected qsmul_def (a : ℚ) (x : K) : qsmul a x = Rat.cast a * x := by intros; rfl\n\n-- see Note [lower instance priority]\n"}
{"name":"DivisionRing.nnratCast_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : DivisionRing K\nq : NNRat\n⊢ Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)","decl":"/-- A `DivisionRing` is a `Ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `DivisionRing K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance]. Similarly, there are maps `nnratCast ℚ≥0 → K` and\n`nnqsmul : ℚ≥0 → K → K` to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance.\n\nIf the division ring has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\nclass DivisionRing (K : Type*)\n  extends Ring K, DivInvMonoid K, Nontrivial K, NNRatCast K, RatCast K where\n  /-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\n  protected mul_inv_cancel : ∀ (a : K), a ≠ 0 → a * a⁻¹ = 1\n  /-- The inverse of `0` is `0` by convention. -/\n  protected inv_zero : (0 : K)⁻¹ = 0\n  protected nnratCast := NNRat.castRec\n  /-- However `NNRat.cast` is defined, it must be equal to `a / b`.\n\n  Do not use this lemma directly. Use `NNRat.cast_def` instead. -/\n  protected nnratCast_def (q : ℚ≥0) : (NNRat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a nonnegative rational number.\n\n  Unless there is a risk of a `Module ℚ≥0 _` instance diamond, write `nnqsmul := _`. This will set\n  `nnqsmul` to `(NNRat.cast · * ·)` thanks to unification in the default proof of `nnqsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected nnqsmul : ℚ≥0 → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `NNRat.smul_def` instead. -/\n  protected nnqsmul_def (q : ℚ≥0) (a : K) : nnqsmul q a = NNRat.cast q * a := by intros; rfl\n  protected ratCast := Rat.castRec\n  /-- However `Rat.cast q` is defined, it must be propositionally equal to `q.num / q.den`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected ratCast_def (q : ℚ) : (Rat.cast q : K) = q.num / q.den := by intros; rfl\n  /-- Scalar multiplication by a rational number.\n\n  Unless there is a risk of a `Module ℚ _` instance diamond, write `qsmul := _`. This will set\n  `qsmul` to `(Rat.cast · * ·)` thanks to unification in the default proof of `qsmul_def`.\n\n  Do not use directly. Instead use the `•` notation. -/\n  protected qsmul : ℚ → K → K\n  /-- However `qsmul` is defined, it must be propositionally equal to multiplication by `Rat.cast`.\n\n  Do not use this lemma directly. Use `Rat.cast_def` instead. -/\n  protected qsmul_def (a : ℚ) (x : K) : qsmul a x = Rat.cast a * x := by intros; rfl\n\n-- see Note [lower instance priority]\n"}
{"name":"Semifield.inv_zero","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : Semifield K\n⊢ Eq (Inv.inv 0) 0","decl":"/-- A `Semifield` is a `CommSemiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `Semifield K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the semifield has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass Semifield (K : Type*) extends CommSemiring K, DivisionSemiring K, CommGroupWithZero K\n\n"}
{"name":"Semifield.nnratCast_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : Semifield K\nq : NNRat\n⊢ Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)","decl":"/-- A `Semifield` is a `CommSemiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `Semifield K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the semifield has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass Semifield (K : Type*) extends CommSemiring K, DivisionSemiring K, CommGroupWithZero K\n\n"}
{"name":"Semifield.div_eq_mul_inv","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : Semifield K\na b : K\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))","decl":"/-- A `Semifield` is a `CommSemiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `Semifield K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the semifield has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass Semifield (K : Type*) extends CommSemiring K, DivisionSemiring K, CommGroupWithZero K\n\n"}
{"name":"Semifield.zpow_succ'","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : Semifield K\nn : Nat\na : K\n⊢ Eq (Semifield.zpow (↑n.succ) a) (HMul.hMul (Semifield.zpow (↑n) a) a)","decl":"/-- A `Semifield` is a `CommSemiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `Semifield K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the semifield has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass Semifield (K : Type*) extends CommSemiring K, DivisionSemiring K, CommGroupWithZero K\n\n"}
{"name":"Semifield.toNontrivial","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : Semifield K\n⊢ Nontrivial K","decl":"/-- A `Semifield` is a `CommSemiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `Semifield K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the semifield has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass Semifield (K : Type*) extends CommSemiring K, DivisionSemiring K, CommGroupWithZero K\n\n"}
{"name":"Semifield.zpow_zero'","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : Semifield K\na : K\n⊢ Eq (Semifield.zpow 0 a) 1","decl":"/-- A `Semifield` is a `CommSemiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `Semifield K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the semifield has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass Semifield (K : Type*) extends CommSemiring K, DivisionSemiring K, CommGroupWithZero K\n\n"}
{"name":"Semifield.nnqsmul_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : Semifield K\nq : NNRat\na : K\n⊢ Eq (Semifield.nnqsmul q a) (HMul.hMul (↑q) a)","decl":"/-- A `Semifield` is a `CommSemiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `Semifield K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the semifield has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass Semifield (K : Type*) extends CommSemiring K, DivisionSemiring K, CommGroupWithZero K\n\n"}
{"name":"Semifield.zpow_neg'","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : Semifield K\nn : Nat\na : K\n⊢ Eq (Semifield.zpow (Int.negSucc n) a) (Inv.inv (Semifield.zpow (↑n.succ) a))","decl":"/-- A `Semifield` is a `CommSemiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `Semifield K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the semifield has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass Semifield (K : Type*) extends CommSemiring K, DivisionSemiring K, CommGroupWithZero K\n\n"}
{"name":"Semifield.mul_inv_cancel","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_2\nself : Semifield K\na : K\na✝ : Ne a 0\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"/-- A `Semifield` is a `CommSemiring` with multiplicative inverses for nonzero elements.\n\nAn instance of `Semifield K` includes maps `nnratCast : ℚ≥0 → K` and `nnqsmul : ℚ≥0 → K → K`.\nThose two fields are needed to implement the `DivisionSemiring K → Algebra ℚ≥0 K` instance since we\nneed to control the specific definitions for some special cases of `K` (in particular `K = ℚ≥0`\nitself). See also note [forgetful inheritance].\n\nIf the semifield has positive characteristic `p`, our division by zero convention forces\n`nnratCast (1 / p) = 1 / 0 = 0`. -/\nclass Semifield (K : Type*) extends CommSemiring K, DivisionSemiring K, CommGroupWithZero K\n\n"}
{"name":"Field.div_eq_mul_inv","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u\nself : Field K\na b : K\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))","decl":"/-- A `Field` is a `CommRing` with multiplicative inverses for nonzero elements.\n\nAn instance of `Field K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance].\n\nIf the field has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\n@[stacks 09FD \"first part\"]\nclass Field (K : Type u) extends CommRing K, DivisionRing K\n\n-- see Note [lower instance priority]\n"}
{"name":"Field.nnratCast_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u\nself : Field K\nq : NNRat\n⊢ Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)","decl":"/-- A `Field` is a `CommRing` with multiplicative inverses for nonzero elements.\n\nAn instance of `Field K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance].\n\nIf the field has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\n@[stacks 09FD \"first part\"]\nclass Field (K : Type u) extends CommRing K, DivisionRing K\n\n-- see Note [lower instance priority]\n"}
{"name":"Field.inv_zero","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u\nself : Field K\n⊢ Eq (Inv.inv 0) 0","decl":"/-- A `Field` is a `CommRing` with multiplicative inverses for nonzero elements.\n\nAn instance of `Field K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance].\n\nIf the field has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\n@[stacks 09FD \"first part\"]\nclass Field (K : Type u) extends CommRing K, DivisionRing K\n\n-- see Note [lower instance priority]\n"}
{"name":"Field.mul_inv_cancel","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u\nself : Field K\na : K\na✝ : Ne a 0\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"/-- A `Field` is a `CommRing` with multiplicative inverses for nonzero elements.\n\nAn instance of `Field K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance].\n\nIf the field has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\n@[stacks 09FD \"first part\"]\nclass Field (K : Type u) extends CommRing K, DivisionRing K\n\n-- see Note [lower instance priority]\n"}
{"name":"Field.ratCast_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u\nself : Field K\nq : Rat\n⊢ Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)","decl":"/-- A `Field` is a `CommRing` with multiplicative inverses for nonzero elements.\n\nAn instance of `Field K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance].\n\nIf the field has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\n@[stacks 09FD \"first part\"]\nclass Field (K : Type u) extends CommRing K, DivisionRing K\n\n-- see Note [lower instance priority]\n"}
{"name":"Field.nnqsmul_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u\nself : Field K\nq : NNRat\na : K\n⊢ Eq (Field.nnqsmul q a) (HMul.hMul (↑q) a)","decl":"/-- A `Field` is a `CommRing` with multiplicative inverses for nonzero elements.\n\nAn instance of `Field K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance].\n\nIf the field has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\n@[stacks 09FD \"first part\"]\nclass Field (K : Type u) extends CommRing K, DivisionRing K\n\n-- see Note [lower instance priority]\n"}
{"name":"Field.zpow_neg'","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u\nself : Field K\nn : Nat\na : K\n⊢ Eq (Field.zpow (Int.negSucc n) a) (Inv.inv (Field.zpow (↑n.succ) a))","decl":"/-- A `Field` is a `CommRing` with multiplicative inverses for nonzero elements.\n\nAn instance of `Field K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance].\n\nIf the field has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\n@[stacks 09FD \"first part\"]\nclass Field (K : Type u) extends CommRing K, DivisionRing K\n\n-- see Note [lower instance priority]\n"}
{"name":"Field.toNontrivial","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u\nself : Field K\n⊢ Nontrivial K","decl":"/-- A `Field` is a `CommRing` with multiplicative inverses for nonzero elements.\n\nAn instance of `Field K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance].\n\nIf the field has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\n@[stacks 09FD \"first part\"]\nclass Field (K : Type u) extends CommRing K, DivisionRing K\n\n-- see Note [lower instance priority]\n"}
{"name":"Field.zpow_zero'","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u\nself : Field K\na : K\n⊢ Eq (Field.zpow 0 a) 1","decl":"/-- A `Field` is a `CommRing` with multiplicative inverses for nonzero elements.\n\nAn instance of `Field K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance].\n\nIf the field has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\n@[stacks 09FD \"first part\"]\nclass Field (K : Type u) extends CommRing K, DivisionRing K\n\n-- see Note [lower instance priority]\n"}
{"name":"Field.qsmul_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u\nself : Field K\na : Rat\nx : K\n⊢ Eq (Field.qsmul a x) (HMul.hMul (↑a) x)","decl":"/-- A `Field` is a `CommRing` with multiplicative inverses for nonzero elements.\n\nAn instance of `Field K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance].\n\nIf the field has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\n@[stacks 09FD \"first part\"]\nclass Field (K : Type u) extends CommRing K, DivisionRing K\n\n-- see Note [lower instance priority]\n"}
{"name":"Field.zpow_succ'","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u\nself : Field K\nn : Nat\na : K\n⊢ Eq (Field.zpow (↑n.succ) a) (HMul.hMul (Field.zpow (↑n) a) a)","decl":"/-- A `Field` is a `CommRing` with multiplicative inverses for nonzero elements.\n\nAn instance of `Field K` includes maps `ratCast : ℚ → K` and `qsmul : ℚ → K → K`.\nThose two fields are needed to implement the `DivisionRing K → Algebra ℚ K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ℚ` itself).\nSee also note [forgetful inheritance].\n\nIf the field has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. -/\n@[stacks 09FD \"first part\"]\nclass Field (K : Type u) extends CommRing K, DivisionRing K\n\n-- see Note [lower instance priority]\n"}
{"name":"NNRat.cast_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\nq : NNRat\n⊢ Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)","decl":"lemma cast_def (q : ℚ≥0) : (q : K) = q.num / q.den := DivisionSemiring.nnratCast_def _\n"}
{"name":"NNRat.smul_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\nq : NNRat\na : K\n⊢ Eq (HSMul.hSMul q a) (HMul.hMul (↑q) a)","decl":"lemma smul_def (q : ℚ≥0) (a : K) : q • a = q * a := DivisionSemiring.nnqsmul_def q a\n\n"}
{"name":"NNRat.smul_one_eq_cast","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\nq : NNRat\n⊢ Eq (HSMul.hSMul q 1) ↑q","decl":"@[simp] lemma smul_one_eq_cast (q : ℚ≥0) : q • (1 : K) = q := by rw [NNRat.smul_def, mul_one]\n\n"}
{"name":"Rat.cast_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\nq : Rat\n⊢ Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)","decl":"lemma cast_def (q : ℚ) : (q : K) = q.num / q.den := DivisionRing.ratCast_def _\n\n"}
{"name":"Rat.cast_mk'","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na : Int\nb : Nat\nh1 : Ne b 0\nh2 : a.natAbs.Coprime b\n⊢ Eq (↑{ num := a, den := b, den_nz := h1, reduced := h2 }) (HDiv.hDiv ↑a ↑b)","decl":"lemma cast_mk' (a b h1 h2) : ((⟨a, b, h1, h2⟩ : ℚ) : K) = a / b := cast_def _\n\n"}
{"name":"Rat.smul_def","module":"Mathlib.Algebra.Field.Defs","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na : Rat\nx : K\n⊢ Eq (HSMul.hSMul a x) (HMul.hMul (↑a) x)","decl":"theorem smul_def (a : ℚ) (x : K) : a • x = ↑a * x := DivisionRing.qsmul_def a x\n\n"}
{"name":"Rat.smul_one_eq_cast","module":"Mathlib.Algebra.Field.Defs","initialProofState":"A : Type u_2\ninst✝ : DivisionRing A\nm : Rat\n⊢ Eq (HSMul.hSMul m 1) ↑m","decl":"@[simp]\ntheorem smul_one_eq_cast (A : Type*) [DivisionRing A] (m : ℚ) : m • (1 : A) = ↑m := by\n  rw [Rat.smul_def, mul_one]\n\n"}
{"name":"Rat.ofScientific_eq_ofScientific","module":"Mathlib.Algebra.Field.Defs","initialProofState":"m : Nat\ns : Bool\ne : Nat\n⊢ Eq (Rat.ofScientific (OfNat.ofNat m) s (OfNat.ofNat e)) (OfScientific.ofScientific m s e)","decl":"/-- `OfScientific.ofScientific` is the simp-normal form. -/\n@[simp]\ntheorem Rat.ofScientific_eq_ofScientific (m : ℕ) (s : Bool) (e : ℕ) :\n    Rat.ofScientific (OfNat.ofNat m) s (OfNat.ofNat e) = OfScientific.ofScientific m s e := rfl\n"}
