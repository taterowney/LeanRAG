{"name":"Pell.is_pell_solution_iff_mem_unitary","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Zsqrtd d\n⊢ Iff (Eq (HSub.hSub (HPow.hPow a.re 2) (HMul.hMul d (HPow.hPow a.im 2))) 1) (Membership.mem (unitary (Zsqrtd d)) a)","decl":"/-- An element of `ℤ√d` has norm one (i.e., `a.re^2 - d*a.im^2 = 1`) if and only if\nit is contained in the submonoid of unitary elements.\n\nTODO: merge this result with `Pell.isPell_iff_mem_unitary`. -/\ntheorem is_pell_solution_iff_mem_unitary {d : ℤ} {a : ℤ√d} :\n    a.re ^ 2 - d * a.im ^ 2 = 1 ↔ a ∈ unitary (ℤ√d) := by\n  rw [← norm_eq_one_iff_mem_unitary, norm_def, sq, sq, ← mul_assoc]\n\n-- We use `solution₁ d` to allow for a more general structure `solution d m` that\n-- encodes solutions to `x^2 - d*y^2 = m` to be added later.\n"}
{"name":"Pell.Solution₁.prop","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\n⊢ Eq (HSub.hSub (HPow.hPow a.x 2) (HMul.hMul d (HPow.hPow a.y 2))) 1","decl":"/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem prop (a : Solution₁ d) : a.x ^ 2 - d * a.y ^ 2 = 1 :=\n  is_pell_solution_iff_mem_unitary.mpr a.property\n\n"}
{"name":"Pell.Solution₁.prop_x","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\n⊢ Eq (HPow.hPow a.x 2) (HAdd.hAdd 1 (HMul.hMul d (HPow.hPow a.y 2)))","decl":"/-- An alternative form of the equation, suitable for rewriting `x^2`. -/\ntheorem prop_x (a : Solution₁ d) : a.x ^ 2 = 1 + d * a.y ^ 2 := by rw [← a.prop]; ring\n\n"}
{"name":"Pell.Solution₁.prop_y","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\n⊢ Eq (HMul.hMul d (HPow.hPow a.y 2)) (HSub.hSub (HPow.hPow a.x 2) 1)","decl":"/-- An alternative form of the equation, suitable for rewriting `d * y^2`. -/\ntheorem prop_y (a : Solution₁ d) : d * a.y ^ 2 = a.x ^ 2 - 1 := by rw [← a.prop]; ring\n\n"}
{"name":"Pell.Solution₁.ext","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na b : Pell.Solution₁ d\nhx : Eq a.x b.x\nhy : Eq a.y b.y\n⊢ Eq a b","decl":"/-- Two solutions are equal if their `x` and `y` components are equal. -/\n@[ext]\ntheorem ext {a b : Solution₁ d} (hx : a.x = b.x) (hy : a.y = b.y) : a = b :=\n  Subtype.ext <| Zsqrtd.ext hx hy\n\n"}
{"name":"Pell.Solution₁.ext_iff","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na b : Pell.Solution₁ d\n⊢ Iff (Eq a b) (And (Eq a.x b.x) (Eq a.y b.y))","decl":"/-- Two solutions are equal if their `x` and `y` components are equal. -/\n@[ext]\ntheorem ext {a b : Solution₁ d} (hx : a.x = b.x) (hy : a.y = b.y) : a = b :=\n  Subtype.ext <| Zsqrtd.ext hx hy\n\n"}
{"name":"Pell.Solution₁.x_mk","module":"Mathlib.NumberTheory.Pell","initialProofState":"d x y : Int\nprop : Eq (HSub.hSub (HPow.hPow x 2) (HMul.hMul d (HPow.hPow y 2))) 1\n⊢ Eq (Pell.Solution₁.mk x y prop).x x","decl":"@[simp]\ntheorem x_mk (x y : ℤ) (prop : x ^ 2 - d * y ^ 2 = 1) : (mk x y prop).x = x :=\n  rfl\n\n"}
{"name":"Pell.Solution₁.y_mk","module":"Mathlib.NumberTheory.Pell","initialProofState":"d x y : Int\nprop : Eq (HSub.hSub (HPow.hPow x 2) (HMul.hMul d (HPow.hPow y 2))) 1\n⊢ Eq (Pell.Solution₁.mk x y prop).y y","decl":"@[simp]\ntheorem y_mk (x y : ℤ) (prop : x ^ 2 - d * y ^ 2 = 1) : (mk x y prop).y = y :=\n  rfl\n\n"}
{"name":"Pell.Solution₁.coe_mk","module":"Mathlib.NumberTheory.Pell","initialProofState":"d x y : Int\nprop : Eq (HSub.hSub (HPow.hPow x 2) (HMul.hMul d (HPow.hPow y 2))) 1\n⊢ Eq ↑(Pell.Solution₁.mk x y prop) { re := x, im := y }","decl":"@[simp]\ntheorem coe_mk (x y : ℤ) (prop : x ^ 2 - d * y ^ 2 = 1) : (↑(mk x y prop) : ℤ√d) = ⟨x, y⟩ :=\n  Zsqrtd.ext (x_mk x y prop) (y_mk x y prop)\n\n"}
{"name":"Pell.Solution₁.x_one","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\n⊢ Eq (Pell.Solution₁.x 1) 1","decl":"@[simp]\ntheorem x_one : (1 : Solution₁ d).x = 1 :=\n  rfl\n\n"}
{"name":"Pell.Solution₁.y_one","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\n⊢ Eq (Pell.Solution₁.y 1) 0","decl":"@[simp]\ntheorem y_one : (1 : Solution₁ d).y = 0 :=\n  rfl\n\n"}
{"name":"Pell.Solution₁.x_mul","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na b : Pell.Solution₁ d\n⊢ Eq (HMul.hMul a b).x (HAdd.hAdd (HMul.hMul a.x b.x) (HMul.hMul d (HMul.hMul a.y b.y)))","decl":"@[simp]\ntheorem x_mul (a b : Solution₁ d) : (a * b).x = a.x * b.x + d * (a.y * b.y) := by\n  rw [← mul_assoc]\n  rfl\n\n"}
{"name":"Pell.Solution₁.y_mul","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na b : Pell.Solution₁ d\n⊢ Eq (HMul.hMul a b).y (HAdd.hAdd (HMul.hMul a.x b.y) (HMul.hMul a.y b.x))","decl":"@[simp]\ntheorem y_mul (a b : Solution₁ d) : (a * b).y = a.x * b.y + a.y * b.x :=\n  rfl\n\n"}
{"name":"Pell.Solution₁.x_inv","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\n⊢ Eq (Inv.inv a).x a.x","decl":"@[simp]\ntheorem x_inv (a : Solution₁ d) : a⁻¹.x = a.x :=\n  rfl\n\n"}
{"name":"Pell.Solution₁.y_inv","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\n⊢ Eq (Inv.inv a).y (Neg.neg a.y)","decl":"@[simp]\ntheorem y_inv (a : Solution₁ d) : a⁻¹.y = -a.y :=\n  rfl\n\n"}
{"name":"Pell.Solution₁.x_neg","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\n⊢ Eq (Neg.neg a).x (Neg.neg a.x)","decl":"@[simp]\ntheorem x_neg (a : Solution₁ d) : (-a).x = -a.x :=\n  rfl\n\n"}
{"name":"Pell.Solution₁.y_neg","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\n⊢ Eq (Neg.neg a).y (Neg.neg a.y)","decl":"@[simp]\ntheorem y_neg (a : Solution₁ d) : (-a).y = -a.y :=\n  rfl\n\n"}
{"name":"Pell.Solution₁.eq_zero_of_d_neg","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\nh₀ : LT.lt d 0\na : Pell.Solution₁ d\n⊢ Or (Eq a.x 0) (Eq a.y 0)","decl":"/-- When `d` is negative, then `x` or `y` must be zero in a solution. -/\ntheorem eq_zero_of_d_neg (h₀ : d < 0) (a : Solution₁ d) : a.x = 0 ∨ a.y = 0 := by\n  have h := a.prop\n  contrapose! h\n  have h1 := sq_pos_of_ne_zero h.1\n  have h2 := sq_pos_of_ne_zero h.2\n  nlinarith\n\n"}
{"name":"Pell.Solution₁.x_ne_zero","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\nh₀ : LE.le 0 d\na : Pell.Solution₁ d\n⊢ Ne a.x 0","decl":"/-- A solution has `x ≠ 0`. -/\ntheorem x_ne_zero (h₀ : 0 ≤ d) (a : Solution₁ d) : a.x ≠ 0 := by\n  intro hx\n  have h : 0 ≤ d * a.y ^ 2 := mul_nonneg h₀ (sq_nonneg _)\n  rw [a.prop_y, hx, sq, zero_mul, zero_sub] at h\n  exact not_le.mpr (neg_one_lt_zero : (-1 : ℤ) < 0) h\n\n"}
{"name":"Pell.Solution₁.y_ne_zero_of_one_lt_x","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nha : LT.lt 1 a.x\n⊢ Ne a.y 0","decl":"/-- A solution with `x > 1` must have `y ≠ 0`. -/\ntheorem y_ne_zero_of_one_lt_x {a : Solution₁ d} (ha : 1 < a.x) : a.y ≠ 0 := by\n  intro hy\n  have prop := a.prop\n  rw [hy, sq (0 : ℤ), zero_mul, mul_zero, sub_zero] at prop\n  exact lt_irrefl _ (((one_lt_sq_iff₀ <| zero_le_one.trans ha.le).mpr ha).trans_eq prop)\n\n"}
{"name":"Pell.Solution₁.d_pos_of_one_lt_x","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nha : LT.lt 1 a.x\n⊢ LT.lt 0 d","decl":"/-- If a solution has `x > 1`, then `d` is positive. -/\ntheorem d_pos_of_one_lt_x {a : Solution₁ d} (ha : 1 < a.x) : 0 < d := by\n  refine pos_of_mul_pos_left ?_ (sq_nonneg a.y)\n  rw [a.prop_y, sub_pos]\n  exact one_lt_pow₀ ha two_ne_zero\n\n"}
{"name":"Pell.Solution₁.d_nonsquare_of_one_lt_x","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nha : LT.lt 1 a.x\n⊢ Not (IsSquare d)","decl":"/-- If a solution has `x > 1`, then `d` is not a square. -/\ntheorem d_nonsquare_of_one_lt_x {a : Solution₁ d} (ha : 1 < a.x) : ¬IsSquare d := by\n  have hp := a.prop\n  rintro ⟨b, rfl⟩\n  simp_rw [← sq, ← mul_pow, sq_sub_sq, Int.mul_eq_one_iff_eq_one_or_neg_one] at hp\n  omega\n\n"}
{"name":"Pell.Solution₁.eq_one_of_x_eq_one","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\nh₀ : Ne d 0\na : Pell.Solution₁ d\nha : Eq a.x 1\n⊢ Eq a 1","decl":"/-- A solution with `x = 1` is trivial. -/\ntheorem eq_one_of_x_eq_one (h₀ : d ≠ 0) {a : Solution₁ d} (ha : a.x = 1) : a = 1 := by\n  have prop := a.prop_y\n  rw [ha, one_pow, sub_self, mul_eq_zero, or_iff_right h₀, sq_eq_zero_iff] at prop\n  exact ext ha prop\n\n"}
{"name":"Pell.Solution₁.eq_one_or_neg_one_iff_y_eq_zero","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\n⊢ Iff (Or (Eq a 1) (Eq a (-1))) (Eq a.y 0)","decl":"/-- A solution is `1` or `-1` if and only if `y = 0`. -/\ntheorem eq_one_or_neg_one_iff_y_eq_zero {a : Solution₁ d} : a = 1 ∨ a = -1 ↔ a.y = 0 := by\n  refine ⟨fun H => H.elim (fun h => by simp [h]) fun h => by simp [h], fun H => ?_⟩\n  have prop := a.prop\n  rw [H, sq (0 : ℤ), mul_zero, mul_zero, sub_zero, sq_eq_one_iff] at prop\n  exact prop.imp (fun h => ext h H) fun h => ext h H\n\n"}
{"name":"Pell.Solution₁.x_mul_pos","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na b : Pell.Solution₁ d\nha : LT.lt 0 a.x\nhb : LT.lt 0 b.x\n⊢ LT.lt 0 (HMul.hMul a b).x","decl":"/-- The set of solutions with `x > 0` is closed under multiplication. -/\ntheorem x_mul_pos {a b : Solution₁ d} (ha : 0 < a.x) (hb : 0 < b.x) : 0 < (a * b).x := by\n  simp only [x_mul]\n  refine neg_lt_iff_pos_add'.mp (abs_lt.mp ?_).1\n  rw [← abs_of_pos ha, ← abs_of_pos hb, ← abs_mul, ← sq_lt_sq, mul_pow a.x, a.prop_x, b.prop_x, ←\n    sub_pos]\n  ring_nf\n  rcases le_or_lt 0 d with h | h\n  · positivity\n  · rw [(eq_zero_of_d_neg h a).resolve_left ha.ne', (eq_zero_of_d_neg h b).resolve_left hb.ne']\n    -- Porting note: was\n    -- rw [zero_pow two_ne_zero, zero_add, zero_mul, zero_add]\n    -- exact one_pos\n    -- but this relied on the exact output of `ring_nf`\n    simp\n\n"}
{"name":"Pell.Solution₁.y_mul_pos","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na b : Pell.Solution₁ d\nhax : LT.lt 0 a.x\nhay : LT.lt 0 a.y\nhbx : LT.lt 0 b.x\nhby : LT.lt 0 b.y\n⊢ LT.lt 0 (HMul.hMul a b).y","decl":"/-- The set of solutions with `x` and `y` positive is closed under multiplication. -/\ntheorem y_mul_pos {a b : Solution₁ d} (hax : 0 < a.x) (hay : 0 < a.y) (hbx : 0 < b.x)\n    (hby : 0 < b.y) : 0 < (a * b).y := by\n  simp only [y_mul]\n  positivity\n\n"}
{"name":"Pell.Solution₁.x_pow_pos","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nhax : LT.lt 0 a.x\nn : Nat\n⊢ LT.lt 0 (HPow.hPow a n).x","decl":"/-- If `(x, y)` is a solution with `x` positive, then all its powers with natural exponents\nhave positive `x`. -/\ntheorem x_pow_pos {a : Solution₁ d} (hax : 0 < a.x) (n : ℕ) : 0 < (a ^ n).x := by\n  induction' n with n ih\n  · simp only [pow_zero, x_one, zero_lt_one]\n  · rw [pow_succ]\n    exact x_mul_pos ih hax\n\n"}
{"name":"Pell.Solution₁.y_pow_succ_pos","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nhax : LT.lt 0 a.x\nhay : LT.lt 0 a.y\nn : Nat\n⊢ LT.lt 0 (HPow.hPow a n.succ).y","decl":"/-- If `(x, y)` is a solution with `x` and `y` positive, then all its powers with positive\nnatural exponents have positive `y`. -/\ntheorem y_pow_succ_pos {a : Solution₁ d} (hax : 0 < a.x) (hay : 0 < a.y) (n : ℕ) :\n    0 < (a ^ n.succ).y := by\n  induction' n with n ih\n  · simp only [pow_one, hay]\n  · rw [pow_succ']\n    exact y_mul_pos hax hay (x_pow_pos hax _) ih\n\n"}
{"name":"Pell.Solution₁.y_zpow_pos","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nhax : LT.lt 0 a.x\nhay : LT.lt 0 a.y\nn : Int\nhn : LT.lt 0 n\n⊢ LT.lt 0 (HPow.hPow a n).y","decl":"/-- If `(x, y)` is a solution with `x` and `y` positive, then all its powers with positive\nexponents have positive `y`. -/\ntheorem y_zpow_pos {a : Solution₁ d} (hax : 0 < a.x) (hay : 0 < a.y) {n : ℤ} (hn : 0 < n) :\n    0 < (a ^ n).y := by\n  lift n to ℕ using hn.le\n  norm_cast at hn ⊢\n  rw [← Nat.succ_pred_eq_of_pos hn]\n  exact y_pow_succ_pos hax hay _\n\n"}
{"name":"Pell.Solution₁.x_zpow_pos","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nhax : LT.lt 0 a.x\nn : Int\n⊢ LT.lt 0 (HPow.hPow a n).x","decl":"/-- If `(x, y)` is a solution with `x` positive, then all its powers have positive `x`. -/\ntheorem x_zpow_pos {a : Solution₁ d} (hax : 0 < a.x) (n : ℤ) : 0 < (a ^ n).x := by\n  cases n with\n  | ofNat n =>\n    rw [Int.ofNat_eq_coe, zpow_natCast]\n    exact x_pow_pos hax n\n  | negSucc n =>\n    rw [zpow_negSucc]\n    exact x_pow_pos hax (n + 1)\n\n"}
{"name":"Pell.Solution₁.sign_y_zpow_eq_sign_of_x_pos_of_y_pos","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nhax : LT.lt 0 a.x\nhay : LT.lt 0 a.y\nn : Int\n⊢ Eq (HPow.hPow a n).y.sign n.sign","decl":"/-- If `(x, y)` is a solution with `x` and `y` positive, then the `y` component of any power\nhas the same sign as the exponent. -/\ntheorem sign_y_zpow_eq_sign_of_x_pos_of_y_pos {a : Solution₁ d} (hax : 0 < a.x) (hay : 0 < a.y)\n    (n : ℤ) : (a ^ n).y.sign = n.sign := by\n  rcases n with ((_ | n) | n)\n  · rfl\n  · rw [Int.ofNat_eq_coe, zpow_natCast]\n    exact Int.sign_eq_one_of_pos (y_pow_succ_pos hax hay n)\n  · rw [zpow_negSucc]\n    exact Int.sign_eq_neg_one_of_neg (neg_neg_of_pos (y_pow_succ_pos hax hay n))\n\n"}
{"name":"Pell.Solution₁.exists_pos_variant","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\nh₀ : LT.lt 0 d\na : Pell.Solution₁ d\n⊢ Exists fun b => And (LT.lt 0 b.x) (And (LE.le 0 b.y) (Membership.mem (Insert.insert b (Insert.insert (Inv.inv b) (Insert.insert (Neg.neg b) (Singleton.singleton (Neg.neg (Inv.inv b)))))) a))","decl":"/-- If `a` is any solution, then one of `a`, `a⁻¹`, `-a`, `-a⁻¹` has\npositive `x` and nonnegative `y`. -/\ntheorem exists_pos_variant (h₀ : 0 < d) (a : Solution₁ d) :\n    ∃ b : Solution₁ d, 0 < b.x ∧ 0 ≤ b.y ∧ a ∈ ({b, b⁻¹, -b, -b⁻¹} : Set (Solution₁ d)) := by\n  refine\n        (lt_or_gt_of_ne (a.x_ne_zero h₀.le)).elim\n          ((le_total 0 a.y).elim (fun hy hx => ⟨-a⁻¹, ?_, ?_, ?_⟩) fun hy hx => ⟨-a, ?_, ?_, ?_⟩)\n          ((le_total 0 a.y).elim (fun hy hx => ⟨a, hx, hy, ?_⟩) fun hy hx => ⟨a⁻¹, hx, ?_, ?_⟩) <;>\n      simp only [neg_neg, inv_inv, neg_inv, Set.mem_insert_iff, Set.mem_singleton_iff, true_or,\n        eq_self_iff_true, x_neg, x_inv, y_neg, y_inv, neg_pos, neg_nonneg, or_true] <;>\n    assumption\n\n"}
{"name":"Pell.exists_of_not_isSquare","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\nh₀ : LT.lt 0 d\nhd : Not (IsSquare d)\n⊢ Exists fun x => Exists fun y => And (Eq (HSub.hSub (HPow.hPow x 2) (HMul.hMul d (HPow.hPow y 2))) 1) (Ne y 0)","decl":"/-- If `d` is a positive integer that is not a square, then there is a nontrivial solution\nto the Pell equation `x^2 - d*y^2 = 1`. -/\ntheorem exists_of_not_isSquare (h₀ : 0 < d) (hd : ¬IsSquare d) :\n    ∃ x y : ℤ, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0 := by\n  let ξ : ℝ := √d\n  have hξ : Irrational ξ := by\n    refine irrational_nrt_of_notint_nrt 2 d (sq_sqrt <| Int.cast_nonneg.mpr h₀.le) ?_ two_pos\n    rintro ⟨x, hx⟩\n    refine hd ⟨x, @Int.cast_injective ℝ _ _ d (x * x) ?_⟩\n    rw [← sq_sqrt <| Int.cast_nonneg.mpr h₀.le, Int.cast_mul, ← hx, sq]\n  obtain ⟨M, hM₁⟩ := exists_int_gt (2 * |ξ| + 1)\n  have hM : {q : ℚ | |q.1 ^ 2 - d * (q.2 : ℤ) ^ 2| < M}.Infinite := by\n    refine Infinite.mono (fun q h => ?_) (infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational hξ)\n    have h0 : 0 < (q.2 : ℝ) ^ 2 := pow_pos (Nat.cast_pos.mpr q.pos) 2\n    have h1 : (q.num : ℝ) / (q.den : ℝ) = q := mod_cast q.num_div_den\n    rw [mem_setOf, abs_sub_comm, ← @Int.cast_lt ℝ,\n      ← div_lt_div_iff_of_pos_right (abs_pos_of_pos h0)]\n    push_cast\n    rw [← abs_div, abs_sq, sub_div, mul_div_cancel_right₀ _ h0.ne', ← div_pow, h1, ←\n      sq_sqrt (Int.cast_pos.mpr h₀).le, sq_sub_sq, abs_mul, ← mul_one_div]\n    refine mul_lt_mul'' (((abs_add ξ q).trans ?_).trans_lt hM₁) h (abs_nonneg _) (abs_nonneg _)\n    rw [two_mul, add_assoc, add_le_add_iff_left, ← sub_le_iff_le_add']\n    rw [mem_setOf, abs_sub_comm] at h\n    refine (abs_sub_abs_le_abs_sub (q : ℝ) ξ).trans (h.le.trans ?_)\n    rw [div_le_one h0, one_le_sq_iff_one_le_abs, Nat.abs_cast, Nat.one_le_cast]\n    exact q.pos\n  obtain ⟨m, hm⟩ : ∃ m : ℤ, {q : ℚ | q.1 ^ 2 - d * (q.den : ℤ) ^ 2 = m}.Infinite := by\n    contrapose! hM\n    simp only [not_infinite] at hM ⊢\n    refine (congr_arg _ (ext fun x => ?_)).mp (Finite.biUnion (finite_Ioo (-M) M) fun m _ => hM m)\n    simp only [abs_lt, mem_setOf, mem_Ioo, mem_iUnion, exists_prop, exists_eq_right']\n  have hm₀ : m ≠ 0 := by\n    rintro rfl\n    obtain ⟨q, hq⟩ := hm.nonempty\n    rw [mem_setOf, sub_eq_zero, mul_comm] at hq\n    obtain ⟨a, ha⟩ := (Int.pow_dvd_pow_iff two_ne_zero).mp ⟨d, hq⟩\n    rw [ha, mul_pow, mul_right_inj' (pow_pos (Int.natCast_pos.mpr q.pos) 2).ne'] at hq\n    exact hd ⟨a, sq a ▸ hq.symm⟩\n  haveI := neZero_iff.mpr (Int.natAbs_ne_zero.mpr hm₀)\n  let f : ℚ → ZMod m.natAbs × ZMod m.natAbs := fun q => (q.num, q.den)\n  obtain ⟨q₁, h₁ : q₁.num ^ 2 - d * (q₁.den : ℤ) ^ 2 = m,\n      q₂, h₂ : q₂.num ^ 2 - d * (q₂.den : ℤ) ^ 2 = m, hne, hqf⟩ :=\n    hm.exists_ne_map_eq_of_mapsTo (mapsTo_univ f _) finite_univ\n  obtain ⟨hq1 : (q₁.num : ZMod m.natAbs) = q₂.num, hq2 : (q₁.den : ZMod m.natAbs) = q₂.den⟩ :=\n    Prod.ext_iff.mp hqf\n  have hd₁ : m ∣ q₁.num * q₂.num - d * (q₁.den * q₂.den) := by\n    rw [← Int.natAbs_dvd, ← ZMod.intCast_zmod_eq_zero_iff_dvd]\n    push_cast\n    rw [hq1, hq2, ← sq, ← sq]\n    norm_cast\n    rw [ZMod.intCast_zmod_eq_zero_iff_dvd, Int.natAbs_dvd, Nat.cast_pow, ← h₂]\n  have hd₂ : m ∣ q₁.num * q₂.den - q₂.num * q₁.den := by\n    rw [← Int.natAbs_dvd, ← ZMod.intCast_eq_intCast_iff_dvd_sub]\n    push_cast\n    rw [hq1, hq2]\n  replace hm₀ : (m : ℚ) ≠ 0 := Int.cast_ne_zero.mpr hm₀\n  refine ⟨(q₁.num * q₂.num - d * (q₁.den * q₂.den)) / m, (q₁.num * q₂.den - q₂.num * q₁.den) / m,\n      ?_, ?_⟩\n  · qify [hd₁, hd₂]\n    field_simp [hm₀]\n    norm_cast\n    conv_rhs =>\n      rw [sq]\n      congr\n      · rw [← h₁]\n      · rw [← h₂]\n    push_cast\n    ring\n  · qify [hd₂]\n    refine div_ne_zero_iff.mpr ⟨?_, hm₀⟩\n    exact mod_cast mt sub_eq_zero.mp (mt Rat.eq_iff_mul_eq_mul.mpr hne)\n\n"}
{"name":"Pell.exists_iff_not_isSquare","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\nh₀ : LT.lt 0 d\n⊢ Iff (Exists fun x => Exists fun y => And (Eq (HSub.hSub (HPow.hPow x 2) (HMul.hMul d (HPow.hPow y 2))) 1) (Ne y 0)) (Not (IsSquare d))","decl":"/-- If `d` is a positive integer, then there is a nontrivial solution\nto the Pell equation `x^2 - d*y^2 = 1` if and only if `d` is not a square. -/\ntheorem exists_iff_not_isSquare (h₀ : 0 < d) :\n    (∃ x y : ℤ, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0) ↔ ¬IsSquare d := by\n  refine ⟨?_, exists_of_not_isSquare h₀⟩\n  rintro ⟨x, y, hxy, hy⟩ ⟨a, rfl⟩\n  rw [← sq, ← mul_pow, sq_sub_sq] at hxy\n  simpa [hy, mul_self_pos.mp h₀, sub_eq_add_neg, eq_neg_self_iff] using Int.eq_of_mul_eq_one hxy\n\n"}
{"name":"Pell.Solution₁.exists_nontrivial_of_not_isSquare","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\nh₀ : LT.lt 0 d\nhd : Not (IsSquare d)\n⊢ Exists fun a => And (Ne a 1) (Ne a (-1))","decl":"/-- If `d` is a positive integer that is not a square, then there exists a nontrivial solution\nto the Pell equation `x^2 - d*y^2 = 1`. -/\ntheorem exists_nontrivial_of_not_isSquare (h₀ : 0 < d) (hd : ¬IsSquare d) :\n    ∃ a : Solution₁ d, a ≠ 1 ∧ a ≠ -1 := by\n  obtain ⟨x, y, prop, hy⟩ := exists_of_not_isSquare h₀ hd\n  refine ⟨mk x y prop, fun H => ?_, fun H => ?_⟩ <;> apply_fun Solution₁.y at H <;>\n    simp [hy] at H\n\n"}
{"name":"Pell.Solution₁.exists_pos_of_not_isSquare","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\nh₀ : LT.lt 0 d\nhd : Not (IsSquare d)\n⊢ Exists fun a => And (LT.lt 1 a.x) (LT.lt 0 a.y)","decl":"/-- If `d` is a positive integer that is not a square, then there exists a solution\nto the Pell equation `x^2 - d*y^2 = 1` with `x > 1` and `y > 0`. -/\ntheorem exists_pos_of_not_isSquare (h₀ : 0 < d) (hd : ¬IsSquare d) :\n    ∃ a : Solution₁ d, 1 < a.x ∧ 0 < a.y := by\n  obtain ⟨x, y, h, hy⟩ := exists_of_not_isSquare h₀ hd\n  refine ⟨mk |x| |y| (by rwa [sq_abs, sq_abs]), ?_, abs_pos.mpr hy⟩\n  rw [x_mk, ← one_lt_sq_iff_one_lt_abs, eq_add_of_sub_eq h, lt_add_iff_pos_right]\n  exact mul_pos h₀ (sq_pos_of_ne_zero hy)\n\n"}
{"name":"Pell.IsFundamental.x_pos","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nh : Pell.IsFundamental a\n⊢ LT.lt 0 a.x","decl":"/-- A fundamental solution has positive `x`. -/\ntheorem x_pos {a : Solution₁ d} (h : IsFundamental a) : 0 < a.x :=\n  zero_lt_one.trans h.1\n\n"}
{"name":"Pell.IsFundamental.d_pos","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nh : Pell.IsFundamental a\n⊢ LT.lt 0 d","decl":"/-- If a fundamental solution exists, then `d` must be positive. -/\ntheorem d_pos {a : Solution₁ d} (h : IsFundamental a) : 0 < d :=\n  d_pos_of_one_lt_x h.1\n\n"}
{"name":"Pell.IsFundamental.d_nonsquare","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nh : Pell.IsFundamental a\n⊢ Not (IsSquare d)","decl":"/-- If a fundamental solution exists, then `d` must be a non-square. -/\ntheorem d_nonsquare {a : Solution₁ d} (h : IsFundamental a) : ¬IsSquare d :=\n  d_nonsquare_of_one_lt_x h.1\n\n"}
{"name":"Pell.IsFundamental.subsingleton","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na b : Pell.Solution₁ d\nha : Pell.IsFundamental a\nhb : Pell.IsFundamental b\n⊢ Eq a b","decl":"/-- If there is a fundamental solution, it is unique. -/\ntheorem subsingleton {a b : Solution₁ d} (ha : IsFundamental a) (hb : IsFundamental b) : a = b := by\n  have hx := le_antisymm (ha.2.2 hb.1) (hb.2.2 ha.1)\n  refine Solution₁.ext hx ?_\n  have : d * a.y ^ 2 = d * b.y ^ 2 := by rw [a.prop_y, b.prop_y, hx]\n  exact (sq_eq_sq₀ ha.2.1.le hb.2.1.le).mp (Int.eq_of_mul_eq_mul_left ha.d_pos.ne' this)\n\n"}
{"name":"Pell.IsFundamental.exists_of_not_isSquare","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\nh₀ : LT.lt 0 d\nhd : Not (IsSquare d)\n⊢ Exists fun a => Pell.IsFundamental a","decl":"/-- If `d` is positive and not a square, then a fundamental solution exists. -/\ntheorem exists_of_not_isSquare (h₀ : 0 < d) (hd : ¬IsSquare d) :\n    ∃ a : Solution₁ d, IsFundamental a := by\n  obtain ⟨a, ha₁, ha₂⟩ := exists_pos_of_not_isSquare h₀ hd\n  -- convert to `x : ℕ` to be able to use `Nat.find`\n  have P : ∃ x' : ℕ, 1 < x' ∧ ∃ y' : ℤ, 0 < y' ∧ (x' : ℤ) ^ 2 - d * y' ^ 2 = 1 := by\n    have hax := a.prop\n    lift a.x to ℕ using by positivity with ax\n    norm_cast at ha₁\n    exact ⟨ax, ha₁, a.y, ha₂, hax⟩\n  classical\n  -- to avoid having to show that the predicate is decidable\n  let x₁ := Nat.find P\n  obtain ⟨hx, y₁, hy₀, hy₁⟩ := Nat.find_spec P\n  refine ⟨mk x₁ y₁ hy₁, by rw [x_mk]; exact mod_cast hx, hy₀, fun {b} hb => ?_⟩\n  rw [x_mk]\n  have hb' := (Int.toNat_of_nonneg <| zero_le_one.trans hb.le).symm\n  have hb'' := hb\n  rw [hb'] at hb ⊢\n  norm_cast at hb ⊢\n  refine Nat.find_min' P ⟨hb, |b.y|, abs_pos.mpr <| y_ne_zero_of_one_lt_x hb'', ?_⟩\n  rw [← hb', sq_abs]\n  exact b.prop\n\n"}
{"name":"Pell.IsFundamental.y_strictMono","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nh : Pell.IsFundamental a\n⊢ StrictMono fun n => (HPow.hPow a n).y","decl":"/-- The map sending an integer `n` to the `y`-coordinate of `a^n` for a fundamental\nsolution `a` is stritcly increasing. -/\ntheorem y_strictMono {a : Solution₁ d} (h : IsFundamental a) :\n    StrictMono fun n : ℤ => (a ^ n).y := by\n  have H : ∀ n : ℤ, 0 ≤ n → (a ^ n).y < (a ^ (n + 1)).y := by\n    intro n hn\n    rw [← sub_pos, zpow_add, zpow_one, y_mul, add_sub_assoc]\n    rw [show (a ^ n).y * a.x - (a ^ n).y = (a ^ n).y * (a.x - 1) by ring]\n    refine\n      add_pos_of_pos_of_nonneg (mul_pos (x_zpow_pos h.x_pos _) h.2.1)\n        (mul_nonneg ?_ (by rw [sub_nonneg]; exact h.1.le))\n    rcases hn.eq_or_lt with (rfl | hn)\n    · simp only [zpow_zero, y_one, le_refl]\n    · exact (y_zpow_pos h.x_pos h.2.1 hn).le\n  refine strictMono_int_of_lt_succ fun n => ?_\n  rcases le_or_lt 0 n with hn | hn\n  · exact H n hn\n  · let m : ℤ := -n - 1\n    have hm : n = -m - 1 := by simp only [m, neg_sub, sub_neg_eq_add, add_tsub_cancel_left]\n    rw [hm, sub_add_cancel, ← neg_add', zpow_neg, zpow_neg, y_inv, y_inv, neg_lt_neg_iff]\n    exact H _ (by omega)\n\n"}
{"name":"Pell.IsFundamental.zpow_y_lt_iff_lt","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nh : Pell.IsFundamental a\nm n : Int\n⊢ Iff (LT.lt (HPow.hPow a m).y (HPow.hPow a n).y) (LT.lt m n)","decl":"/-- If `a` is a fundamental solution, then `(a^m).y < (a^n).y` if and only if `m < n`. -/\ntheorem zpow_y_lt_iff_lt {a : Solution₁ d} (h : IsFundamental a) (m n : ℤ) :\n    (a ^ m).y < (a ^ n).y ↔ m < n := by\n  refine ⟨fun H => ?_, fun H => h.y_strictMono H⟩\n  contrapose! H\n  exact h.y_strictMono.monotone H\n\n"}
{"name":"Pell.IsFundamental.zpow_eq_one_iff","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nh : Pell.IsFundamental a\nn : Int\n⊢ Iff (Eq (HPow.hPow a n) 1) (Eq n 0)","decl":"/-- The `n`th power of a fundamental solution is trivial if and only if `n = 0`. -/\ntheorem zpow_eq_one_iff {a : Solution₁ d} (h : IsFundamental a) (n : ℤ) : a ^ n = 1 ↔ n = 0 := by\n  rw [← zpow_zero a]\n  exact ⟨fun H => h.y_strictMono.injective (congr_arg Solution₁.y H), fun H => H ▸ rfl⟩\n\n"}
{"name":"Pell.IsFundamental.zpow_ne_neg_zpow","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\nh : Pell.IsFundamental a\nn n' : Int\n⊢ Ne (HPow.hPow a n) (Neg.neg (HPow.hPow a n'))","decl":"/-- A power of a fundamental solution is never equal to the negative of a power of this\nfundamental solution. -/\ntheorem zpow_ne_neg_zpow {a : Solution₁ d} (h : IsFundamental a) {n n' : ℤ} : a ^ n ≠ -a ^ n' := by\n  intro hf\n  apply_fun Solution₁.x at hf\n  have H := x_zpow_pos h.x_pos n\n  rw [hf, x_neg, lt_neg, neg_zero] at H\n  exact lt_irrefl _ ((x_zpow_pos h.x_pos n').trans H)\n\n"}
{"name":"Pell.IsFundamental.x_le_x","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na₁ : Pell.Solution₁ d\nh : Pell.IsFundamental a₁\na : Pell.Solution₁ d\nhax : LT.lt 1 a.x\n⊢ LE.le a₁.x a.x","decl":"/-- The `x`-coordinate of a fundamental solution is a lower bound for the `x`-coordinate\nof any positive solution. -/\ntheorem x_le_x {a₁ : Solution₁ d} (h : IsFundamental a₁) {a : Solution₁ d} (hax : 1 < a.x) :\n    a₁.x ≤ a.x :=\n  h.2.2 hax\n\n"}
{"name":"Pell.IsFundamental.y_le_y","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na₁ : Pell.Solution₁ d\nh : Pell.IsFundamental a₁\na : Pell.Solution₁ d\nhax : LT.lt 1 a.x\nhay : LT.lt 0 a.y\n⊢ LE.le a₁.y a.y","decl":"/-- The `y`-coordinate of a fundamental solution is a lower bound for the `y`-coordinate\nof any positive solution. -/\ntheorem y_le_y {a₁ : Solution₁ d} (h : IsFundamental a₁) {a : Solution₁ d} (hax : 1 < a.x)\n    (hay : 0 < a.y) : a₁.y ≤ a.y := by\n  have H : d * (a₁.y ^ 2 - a.y ^ 2) = a₁.x ^ 2 - a.x ^ 2 := by rw [a.prop_x, a₁.prop_x]; ring\n  rw [← abs_of_pos hay, ← abs_of_pos h.2.1, ← sq_le_sq, ← mul_le_mul_left h.d_pos, ← sub_nonpos, ←\n    mul_sub, H, sub_nonpos, sq_le_sq, abs_of_pos (zero_lt_one.trans h.1),\n    abs_of_pos (zero_lt_one.trans hax)]\n  exact h.x_le_x hax\n\n-- helper lemma for the next three results\n"}
{"name":"Pell.IsFundamental.x_mul_y_le_y_mul_x","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na₁ : Pell.Solution₁ d\nh : Pell.IsFundamental a₁\na : Pell.Solution₁ d\nhax : LT.lt 1 a.x\nhay : LT.lt 0 a.y\n⊢ LE.le (HMul.hMul a.x a₁.y) (HMul.hMul a.y a₁.x)","decl":"theorem x_mul_y_le_y_mul_x {a₁ : Solution₁ d} (h : IsFundamental a₁) {a : Solution₁ d}\n    (hax : 1 < a.x) (hay : 0 < a.y) : a.x * a₁.y ≤ a.y * a₁.x := by\n  rw [← abs_of_pos <| zero_lt_one.trans hax, ← abs_of_pos hay, ← abs_of_pos h.x_pos, ←\n    abs_of_pos h.2.1, ← abs_mul, ← abs_mul, ← sq_le_sq, mul_pow, mul_pow, a.prop_x, a₁.prop_x, ←\n    sub_nonneg]\n  ring_nf\n  rw [sub_nonneg, sq_le_sq, abs_of_pos hay, abs_of_pos h.2.1]\n  exact h.y_le_y hax hay\n\n"}
{"name":"Pell.IsFundamental.mul_inv_y_nonneg","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na₁ : Pell.Solution₁ d\nh : Pell.IsFundamental a₁\na : Pell.Solution₁ d\nhax : LT.lt 1 a.x\nhay : LT.lt 0 a.y\n⊢ LE.le 0 (HMul.hMul a (Inv.inv a₁)).y","decl":"/-- If we multiply a positive solution with the inverse of a fundamental solution,\nthe `y`-coordinate remains nonnegative. -/\ntheorem mul_inv_y_nonneg {a₁ : Solution₁ d} (h : IsFundamental a₁) {a : Solution₁ d} (hax : 1 < a.x)\n    (hay : 0 < a.y) : 0 ≤ (a * a₁⁻¹).y := by\n  simpa only [y_inv, mul_neg, y_mul, le_neg_add_iff_add_le, add_zero] using\n    h.x_mul_y_le_y_mul_x hax hay\n\n"}
{"name":"Pell.IsFundamental.mul_inv_x_pos","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na₁ : Pell.Solution₁ d\nh : Pell.IsFundamental a₁\na : Pell.Solution₁ d\nhax : LT.lt 1 a.x\nhay : LT.lt 0 a.y\n⊢ LT.lt 0 (HMul.hMul a (Inv.inv a₁)).x","decl":"/-- If we multiply a positive solution with the inverse of a fundamental solution,\nthe `x`-coordinate stays positive. -/\ntheorem mul_inv_x_pos {a₁ : Solution₁ d} (h : IsFundamental a₁) {a : Solution₁ d} (hax : 1 < a.x)\n    (hay : 0 < a.y) : 0 < (a * a₁⁻¹).x := by\n  simp only [x_mul, x_inv, y_inv, mul_neg, lt_add_neg_iff_add_lt, zero_add]\n  refine (mul_lt_mul_left <| zero_lt_one.trans hax).mp ?_\n  rw [(by ring : a.x * (d * (a.y * a₁.y)) = d * a.y * (a.x * a₁.y))]\n  refine ((mul_le_mul_left <| mul_pos h.d_pos hay).mpr <| x_mul_y_le_y_mul_x h hax hay).trans_lt ?_\n  rw [← mul_assoc, mul_assoc d, ← sq, a.prop_y, ← sub_pos]\n  ring_nf\n  exact zero_lt_one.trans h.1\n\n"}
{"name":"Pell.IsFundamental.mul_inv_x_lt_x","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na₁ : Pell.Solution₁ d\nh : Pell.IsFundamental a₁\na : Pell.Solution₁ d\nhax : LT.lt 1 a.x\nhay : LT.lt 0 a.y\n⊢ LT.lt (HMul.hMul a (Inv.inv a₁)).x a.x","decl":"/-- If we multiply a positive solution with the inverse of a fundamental solution,\nthe `x`-coordinate decreases. -/\ntheorem mul_inv_x_lt_x {a₁ : Solution₁ d} (h : IsFundamental a₁) {a : Solution₁ d} (hax : 1 < a.x)\n    (hay : 0 < a.y) : (a * a₁⁻¹).x < a.x := by\n  simp only [x_mul, x_inv, y_inv, mul_neg, add_neg_lt_iff_le_add']\n  refine (mul_lt_mul_left h.2.1).mp ?_\n  rw [(by ring : a₁.y * (a.x * a₁.x) = a.x * a₁.y * a₁.x)]\n  refine\n    ((mul_le_mul_right <| zero_lt_one.trans h.1).mpr <| x_mul_y_le_y_mul_x h hax hay).trans_lt ?_\n  rw [mul_assoc, ← sq, a₁.prop_x, ← sub_neg]\n  -- Porting note: was `ring_nf`\n  suffices a.y - a.x * a₁.y < 0 by convert this using 1; ring\n  rw [sub_neg, ← abs_of_pos hay, ← abs_of_pos h.2.1, ← abs_of_pos <| zero_lt_one.trans hax, ←\n    abs_mul, ← sq_lt_sq, mul_pow, a.prop_x]\n  calc\n    a.y ^ 2 = 1 * a.y ^ 2 := (one_mul _).symm\n    _ ≤ d * a.y ^ 2 := (mul_le_mul_right <| sq_pos_of_pos hay).mpr h.d_pos\n    _ < d * a.y ^ 2 + 1 := lt_add_one _\n    _ = (1 + d * a.y ^ 2) * 1 := by rw [add_comm, mul_one]\n    _ ≤ (1 + d * a.y ^ 2) * a₁.y ^ 2 :=\n      (mul_le_mul_left (by have := h.d_pos; positivity)).mpr (sq_pos_of_pos h.2.1)\n\n"}
{"name":"Pell.IsFundamental.eq_pow_of_nonneg","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na₁ : Pell.Solution₁ d\nh : Pell.IsFundamental a₁\na : Pell.Solution₁ d\nhax : LT.lt 0 a.x\nhay : LE.le 0 a.y\n⊢ Exists fun n => Eq a (HPow.hPow a₁ n)","decl":"/-- Any nonnegative solution is a power with nonnegative exponent of a fundamental solution. -/\ntheorem eq_pow_of_nonneg {a₁ : Solution₁ d} (h : IsFundamental a₁) {a : Solution₁ d} (hax : 0 < a.x)\n    (hay : 0 ≤ a.y) : ∃ n : ℕ, a = a₁ ^ n := by\n  lift a.x to ℕ using hax.le with ax hax'\n  -- Porting note: added\n  clear hax\n  induction' ax using Nat.strong_induction_on with x ih generalizing a\n  rcases hay.eq_or_lt with hy | hy\n  · -- case 1: `a = 1`\n    refine ⟨0, ?_⟩\n    simp only [pow_zero]\n    ext <;> simp only [x_one, y_one]\n    · have prop := a.prop\n      rw [← hy, sq (0 : ℤ), zero_mul, mul_zero, sub_zero,\n        sq_eq_one_iff] at prop\n      refine prop.resolve_right fun hf => ?_\n      have := (hax.trans_eq hax').le.trans_eq hf\n      norm_num at this\n    · exact hy.symm\n  · -- case 2: `a ≥ a₁`\n    have hx₁ : 1 < a.x := by nlinarith [a.prop, h.d_pos]\n    have hxx₁ := h.mul_inv_x_pos hx₁ hy\n    have hxx₂ := h.mul_inv_x_lt_x hx₁ hy\n    have hyy := h.mul_inv_y_nonneg hx₁ hy\n    lift (a * a₁⁻¹).x to ℕ using hxx₁.le with x' hx'\n    -- Porting note: `ih` has its arguments in a different order compared to lean 3.\n    obtain ⟨n, hn⟩ := ih x' (mod_cast hxx₂.trans_eq hax'.symm) hyy hx' hxx₁\n    exact ⟨n + 1, by rw [pow_succ', ← hn, mul_comm a, ← mul_assoc, mul_inv_cancel, one_mul]⟩\n\n"}
{"name":"Pell.IsFundamental.eq_zpow_or_neg_zpow","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na₁ : Pell.Solution₁ d\nh : Pell.IsFundamental a₁\na : Pell.Solution₁ d\n⊢ Exists fun n => Or (Eq a (HPow.hPow a₁ n)) (Eq a (Neg.neg (HPow.hPow a₁ n)))","decl":"/-- Every solution is, up to a sign, a power of a given fundamental solution. -/\ntheorem eq_zpow_or_neg_zpow {a₁ : Solution₁ d} (h : IsFundamental a₁) (a : Solution₁ d) :\n    ∃ n : ℤ, a = a₁ ^ n ∨ a = -a₁ ^ n := by\n  obtain ⟨b, hbx, hby, hb⟩ := exists_pos_variant h.d_pos a\n  obtain ⟨n, hn⟩ := h.eq_pow_of_nonneg hbx hby\n  rcases hb with (rfl | rfl | rfl | hb)\n  · exact ⟨n, Or.inl (mod_cast hn)⟩\n  · exact ⟨-n, Or.inl (by simp [hn])⟩\n  · exact ⟨n, Or.inr (by simp [hn])⟩\n  · rw [Set.mem_singleton_iff] at hb\n    rw [hb]\n    exact ⟨-n, Or.inr (by simp [hn])⟩\n\n"}
{"name":"Pell.existsUnique_pos_generator","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\nh₀ : LT.lt 0 d\nhd : Not (IsSquare d)\n⊢ ExistsUnique fun a₁ => And (LT.lt 1 a₁.x) (And (LT.lt 0 a₁.y) (∀ (a : Pell.Solution₁ d), Exists fun n => Or (Eq a (HPow.hPow a₁ n)) (Eq a (Neg.neg (HPow.hPow a₁ n)))))","decl":"/-- When `d` is positive and not a square, then the group of solutions to the Pell equation\n`x^2 - d*y^2 = 1` has a unique positive generator (up to sign). -/\ntheorem existsUnique_pos_generator (h₀ : 0 < d) (hd : ¬IsSquare d) :\n    ∃! a₁ : Solution₁ d,\n      1 < a₁.x ∧ 0 < a₁.y ∧ ∀ a : Solution₁ d, ∃ n : ℤ, a = a₁ ^ n ∨ a = -a₁ ^ n := by\n  obtain ⟨a₁, ha₁⟩ := IsFundamental.exists_of_not_isSquare h₀ hd\n  refine ⟨a₁, ⟨ha₁.1, ha₁.2.1, ha₁.eq_zpow_or_neg_zpow⟩, fun a (H : 1 < _ ∧ _) => ?_⟩\n  obtain ⟨Hx, Hy, H⟩ := H\n  obtain ⟨n₁, hn₁⟩ := H a₁\n  obtain ⟨n₂, hn₂⟩ := ha₁.eq_zpow_or_neg_zpow a\n  rcases hn₂ with (rfl | rfl)\n  · rw [← zpow_mul, eq_comm, @eq_comm _ a₁, ← mul_inv_eq_one, ← @mul_inv_eq_one _ _ _ a₁, ←\n      zpow_neg_one, neg_mul, ← zpow_add, ← sub_eq_add_neg] at hn₁\n    cases' hn₁ with hn₁ hn₁\n    · rcases Int.isUnit_iff.mp\n          (isUnit_of_mul_eq_one _ _ <|\n            sub_eq_zero.mp <| (ha₁.zpow_eq_one_iff (n₂ * n₁ - 1)).mp hn₁) with\n        (rfl | rfl)\n      · rw [zpow_one]\n      · rw [zpow_neg_one, y_inv, lt_neg, neg_zero] at Hy\n        exact False.elim (lt_irrefl _ <| ha₁.2.1.trans Hy)\n    · rw [← zpow_zero a₁, eq_comm] at hn₁\n      exact False.elim (ha₁.zpow_ne_neg_zpow hn₁)\n  · rw [x_neg, lt_neg] at Hx\n    have := (x_zpow_pos (zero_lt_one.trans ha₁.1) n₂).trans Hx\n    norm_num at this\n\n"}
{"name":"Pell.pos_generator_iff_fundamental","module":"Mathlib.NumberTheory.Pell","initialProofState":"d : Int\na : Pell.Solution₁ d\n⊢ Iff (And (LT.lt 1 a.x) (And (LT.lt 0 a.y) (∀ (b : Pell.Solution₁ d), Exists fun n => Or (Eq b (HPow.hPow a n)) (Eq b (Neg.neg (HPow.hPow a n)))))) (Pell.IsFundamental a)","decl":"/-- A positive solution is a generator (up to sign) of the group of all solutions to the\nPell equation `x^2 - d*y^2 = 1` if and only if it is a fundamental solution. -/\ntheorem pos_generator_iff_fundamental (a : Solution₁ d) :\n    (1 < a.x ∧ 0 < a.y ∧ ∀ b : Solution₁ d, ∃ n : ℤ, b = a ^ n ∨ b = -a ^ n) ↔ IsFundamental a := by\n  refine ⟨fun h => ?_, fun H => ⟨H.1, H.2.1, H.eq_zpow_or_neg_zpow⟩⟩\n  have h₀ := d_pos_of_one_lt_x h.1\n  have hd := d_nonsquare_of_one_lt_x h.1\n  obtain ⟨a₁, ha₁⟩ := IsFundamental.exists_of_not_isSquare h₀ hd\n  obtain ⟨b, -, hb₂⟩ := existsUnique_pos_generator h₀ hd\n  rwa [hb₂ a h, ← hb₂ a₁ ⟨ha₁.1, ha₁.2.1, ha₁.eq_zpow_or_neg_zpow⟩]\n\n"}
