{"name":"FirstOrder.Field.realize_eqZero","module":"Mathlib.ModelTheory.Algebra.Field.CharP","initialProofState":"K : Type u_1\ninst✝¹ : CommRing K\ninst✝ : FirstOrder.Ring.CompatibleRing K\nn : Nat\nv : Empty → K\n⊢ Iff (FirstOrder.Language.Formula.Realize (FirstOrder.Field.eqZero n) v) (Eq (↑n) 0)","decl":"@[simp] theorem realize_eqZero [CommRing K] [CompatibleRing K] (n : ℕ)\n    (v : Empty → K) : (Formula.Realize (eqZero n) v) ↔ ((n : K) = 0) := by\n  simp [eqZero, Term.realize]\n\n"}
{"name":"FirstOrder.Field.model_hasChar_of_charP","module":"Mathlib.ModelTheory.Algebra.Field.CharP","initialProofState":"p : Nat\nK : Type u_1\ninst✝² : Field K\ninst✝¹ : FirstOrder.Ring.CompatibleRing K\ninst✝ : CharP K p\n⊢ FirstOrder.Language.Theory.Model K (FirstOrder.Language.Theory.fieldOfChar p)","decl":"instance model_hasChar_of_charP [Field K] [CompatibleRing K] [CharP K p] :\n    (Theory.fieldOfChar p).Model K := by\n  refine Language.Theory.model_union_iff.2 ⟨inferInstance, ?_⟩\n  cases CharP.char_is_prime_or_zero K p with\n  | inl hp =>\n    simp [hp.ne_zero, hp, Sentence.Realize]\n  | inr hp =>\n    subst hp\n    simp only [ite_false, ite_true, Theory.model_iff, Set.mem_image, Set.mem_setOf_eq,\n      Sentence.Realize, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂,\n      Formula.realize_not, realize_eqZero, ← CharZero.charZero_iff_forall_prime_ne_zero]\n    exact CharP.charP_to_charZero K\n\n"}
{"name":"FirstOrder.Field.charP_iff_model_fieldOfChar","module":"Mathlib.ModelTheory.Algebra.Field.CharP","initialProofState":"p : Nat\nK : Type u_1\ninst✝¹ : Field K\ninst✝ : FirstOrder.Ring.CompatibleRing K\n⊢ Iff (FirstOrder.Language.Theory.Model K (FirstOrder.Language.Theory.fieldOfChar p)) (CharP K p)","decl":"theorem charP_iff_model_fieldOfChar [Field K] [CompatibleRing K] :\n    (Theory.fieldOfChar p).Model K ↔ CharP K p := by\n  simp only [Theory.fieldOfChar, Theory.model_union_iff,\n    (show (Theory.field.Model K) by infer_instance), true_and]\n  split_ifs with hp0 hp\n  · subst hp0\n    simp only [Theory.model_iff, Set.mem_image, Set.mem_setOf_eq, Sentence.Realize,\n      forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, Formula.realize_not,\n      realize_eqZero, ← CharZero.charZero_iff_forall_prime_ne_zero]\n    exact ⟨fun _ => CharP.ofCharZero _, fun _ => CharP.charP_to_charZero K⟩\n  · simp only [Theory.model_iff, Set.mem_singleton_iff, Sentence.Realize, forall_eq,\n      realize_eqZero, ← CharP.charP_iff_prime_eq_zero hp]\n  · simp only [Theory.model_iff, Set.mem_singleton_iff, Sentence.Realize,\n      forall_eq, Formula.realize_bot, false_iff]\n    intro H\n    cases (CharP.char_is_prime_or_zero K p) <;> simp_all\n\n"}
{"name":"FirstOrder.Field.model_fieldOfChar_of_charP","module":"Mathlib.ModelTheory.Algebra.Field.CharP","initialProofState":"p : Nat\nK : Type u_1\ninst✝² : Field K\ninst✝¹ : FirstOrder.Ring.CompatibleRing K\ninst✝ : CharP K p\n⊢ FirstOrder.Language.Theory.Model K (FirstOrder.Language.Theory.fieldOfChar p)","decl":"instance model_fieldOfChar_of_charP [Field K] [CompatibleRing K]\n    [CharP K p] : (Theory.fieldOfChar p).Model K :=\n  charP_iff_model_fieldOfChar.2 inferInstance\n\n"}
{"name":"FirstOrder.Field.charP_of_model_fieldOfChar","module":"Mathlib.ModelTheory.Algebra.Field.CharP","initialProofState":"p : Nat\nK : Type u_1\ninst✝¹ : Field K\ninst✝ : FirstOrder.Ring.CompatibleRing K\nh : FirstOrder.Language.Theory.Model K (FirstOrder.Language.Theory.fieldOfChar p)\n⊢ CharP K p","decl":"theorem charP_of_model_fieldOfChar [Field K] [CompatibleRing K]\n    [h : (Theory.fieldOfChar p).Model K] : CharP K p :=\n  charP_iff_model_fieldOfChar.1 h\n\n"}
