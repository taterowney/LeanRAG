{"name":"RingHom.finiteType_stableUnderComposition","module":"Mathlib.RingTheory.RingHom.FiniteType","initialProofState":"⊢ RingHom.StableUnderComposition @RingHom.FiniteType","decl":"theorem finiteType_stableUnderComposition : StableUnderComposition @FiniteType := by\n  introv R hf hg\n  exact hg.comp hf\n\n"}
{"name":"RingHom.finiteType_localizationPreserves","module":"Mathlib.RingTheory.RingHom.FiniteType","initialProofState":"⊢ RingHom.LocalizationPreserves @RingHom.FiniteType","decl":"/-- If `S` is a finite type `R`-algebra, then `S' = M⁻¹S` is a finite type `R' = M⁻¹R`-algebra. -/\ntheorem finiteType_localizationPreserves : RingHom.LocalizationPreserves @RingHom.FiniteType := by\n  classical\n  introv R hf\n  -- mirrors the proof of `localization_map_finite`\n  letI := f.toAlgebra\n  letI := ((algebraMap S S').comp f).toAlgebra\n  let f' : R' →+* S' := IsLocalization.map S' f (Submonoid.le_comap_map M)\n  letI := f'.toAlgebra\n  haveI : IsScalarTower R R' S' :=\n    IsScalarTower.of_algebraMap_eq' (IsLocalization.map_comp M.le_comap_map).symm\n  let fₐ : S →ₐ[R] S' := AlgHom.mk' (algebraMap S S') fun c x => RingHom.map_mul _ _ _\n  obtain ⟨T, hT⟩ := hf\n  use T.image (algebraMap S S')\n  rw [eq_top_iff]\n  rintro x -\n  obtain ⟨y, ⟨_, ⟨r, hr, rfl⟩⟩, rfl⟩ := IsLocalization.mk'_surjective (M.map f) x\n  rw [IsLocalization.mk'_eq_mul_mk'_one, mul_comm, Finset.coe_image]\n  have hy : y ∈ Algebra.adjoin R (T : Set S) := by rw [hT]; trivial\n  replace hy : algebraMap S S' y ∈ (Algebra.adjoin R (T : Set S)).map fₐ :=\n    Subalgebra.mem_map.mpr ⟨_, hy, rfl⟩\n  rw [fₐ.map_adjoin T] at hy\n  have H : Algebra.adjoin R (algebraMap S S' '' T) ≤\n      (Algebra.adjoin R' (algebraMap S S' '' T)).restrictScalars R := by\n    rw [Algebra.adjoin_le_iff]; exact Algebra.subset_adjoin\n  convert (Algebra.adjoin R' (algebraMap S S' '' T)).smul_mem (H hy)\n    (IsLocalization.mk' R' (1 : R) ⟨r, hr⟩) using 1\n  rw [Algebra.smul_def]\n  erw [IsLocalization.map_mk' M.le_comap_map]\n  rw [map_one]\n\n"}
{"name":"RingHom.localization_away_map_finiteType","module":"Mathlib.RingTheory.RingHom.FiniteType","initialProofState":"R S : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\nf : RingHom R S\nR' S' : Type u\ninst✝⁵ : CommRing R'\ninst✝⁴ : CommRing S'\ninst✝³ : Algebra R R'\ninst✝² : Algebra S S'\nr : R\ninst✝¹ : IsLocalization.Away r R'\ninst✝ : IsLocalization.Away (f r) S'\nhf : f.FiniteType\n⊢ (IsLocalization.Away.map R' S' f r).FiniteType","decl":"theorem localization_away_map_finiteType (r : R) [IsLocalization.Away r R']\n    [IsLocalization.Away (f r) S'] (hf : f.FiniteType) :\n    (IsLocalization.Away.map R' S' f r).FiniteType :=\n  finiteType_localizationPreserves.away _ r _ _ hf\n\n"}
{"name":"RingHom.IsLocalization.exists_smul_mem_of_mem_adjoin","module":"Mathlib.RingTheory.RingHom.FiniteType","initialProofState":"R S : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\nS' : Type u\ninst✝⁵ : CommRing S'\ninst✝⁴ : Algebra S S'\ninst✝³ : Algebra R S\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R S S'\nM : Submonoid S\ninst✝ : IsLocalization M S'\nx : S\ns : Finset S'\nA : Subalgebra R S\nhA₁ : HasSubset.Subset ↑(IsLocalization.finsetIntegerMultiple M s) ↑A\nhA₂ : LE.le M A.toSubmonoid\nhx : Membership.mem (Algebra.adjoin R ↑s) ((algebraMap S S') x)\n⊢ Exists fun m => Membership.mem A (HSMul.hSMul m x)","decl":"open scoped Classical in\n/-- Let `S` be an `R`-algebra, `M` a submonoid of `S`, `S' = M⁻¹S`.\nSuppose the image of some `x : S` falls in the adjoin of some finite `s ⊆ S'` over `R`,\nand `A` is an `R`-subalgebra of `S` containing both `M` and the numerators of `s`.\nThen, there exists some `m : M` such that `m • x` falls in `A`.\n-/\ntheorem IsLocalization.exists_smul_mem_of_mem_adjoin [Algebra R S] [Algebra R S']\n    [IsScalarTower R S S'] (M : Submonoid S) [IsLocalization M S'] (x : S) (s : Finset S')\n    (A : Subalgebra R S) (hA₁ : (IsLocalization.finsetIntegerMultiple M s : Set S) ⊆ A)\n    (hA₂ : M ≤ A.toSubmonoid) (hx : algebraMap S S' x ∈ Algebra.adjoin R (s : Set S')) :\n    ∃ m : M, m • x ∈ A := by\n  let g : S →ₐ[R] S' := IsScalarTower.toAlgHom R S S'\n  let y := IsLocalization.commonDenomOfFinset M s\n  have hx₁ : (y : S) • (s : Set S') = g '' _ :=\n    (IsLocalization.finsetIntegerMultiple_image _ s).symm\n  obtain ⟨n, hn⟩ :=\n    Algebra.pow_smul_mem_of_smul_subset_of_mem_adjoin (y : S) (s : Set S') (A.map g)\n      (by rw [hx₁]; exact Set.image_subset _ hA₁) hx (Set.mem_image_of_mem _ (hA₂ y.2))\n  obtain ⟨x', hx', hx''⟩ := hn n (le_of_eq rfl)\n  rw [Algebra.smul_def, ← _root_.map_mul] at hx''\n  obtain ⟨a, ha₂⟩ := (IsLocalization.eq_iff_exists M S').mp hx''\n  use a * y ^ n\n  convert A.mul_mem hx' (hA₂ a.prop) using 1\n  rw [Submonoid.smul_def, smul_eq_mul, Submonoid.coe_mul, SubmonoidClass.coe_pow, mul_assoc, ← ha₂,\n    mul_comm]\n\n"}
{"name":"RingHom.IsLocalization.lift_mem_adjoin_finsetIntegerMultiple","module":"Mathlib.RingTheory.RingHom.FiniteType","initialProofState":"R S : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\nM : Submonoid R\nS' : Type u\ninst✝⁵ : CommRing S'\ninst✝⁴ : Algebra S S'\ninst✝³ : Algebra R S\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R S S'\ninst✝ : IsLocalization (Submonoid.map (algebraMap R S) M) S'\nx : S\ns : Finset S'\nhx : Membership.mem (Algebra.adjoin R ↑s) ((algebraMap S S') x)\n⊢ Exists fun m => Membership.mem (Algebra.adjoin R ↑(IsLocalization.finsetIntegerMultiple (Submonoid.map (algebraMap R S) M) s)) (HSMul.hSMul m x)","decl":"open scoped Classical in\n/-- Let `S` be an `R`-algebra, `M` a submonoid of `R`, and `S' = M⁻¹S`.\nIf the image of some `x : S` falls in the adjoin of some finite `s ⊆ S'` over `R`,\nthen there exists some `m : M` such that `m • x` falls in the\nadjoin of `IsLocalization.finsetIntegerMultiple _ s` over `R`.\n-/\ntheorem IsLocalization.lift_mem_adjoin_finsetIntegerMultiple [Algebra R S] [Algebra R S']\n    [IsScalarTower R S S'] [IsLocalization (M.map (algebraMap R S)) S'] (x : S) (s : Finset S')\n    (hx : algebraMap S S' x ∈ Algebra.adjoin R (s : Set S')) :\n    ∃ m : M, m • x ∈\n      Algebra.adjoin R\n        (IsLocalization.finsetIntegerMultiple (M.map (algebraMap R S)) s : Set S) := by\n  obtain ⟨⟨_, a, ha, rfl⟩, e⟩ :=\n    IsLocalization.exists_smul_mem_of_mem_adjoin (M.map (algebraMap R S)) x s (Algebra.adjoin R _)\n      Algebra.subset_adjoin (by rintro _ ⟨a, _, rfl⟩; exact Subalgebra.algebraMap_mem _ a) hx\n  refine ⟨⟨a, ha⟩, ?_⟩\n  simpa only [Submonoid.smul_def, algebraMap_smul] using e\n\n"}
{"name":"RingHom.finiteType_ofLocalizationSpan","module":"Mathlib.RingTheory.RingHom.FiniteType","initialProofState":"⊢ RingHom.OfLocalizationSpan @RingHom.FiniteType","decl":"theorem finiteType_ofLocalizationSpan : RingHom.OfLocalizationSpan @RingHom.FiniteType := by\n  classical\n  rw [RingHom.ofLocalizationSpan_iff_finite]\n  introv R hs H\n  -- mirrors the proof of `finite_ofLocalizationSpan`\n  letI := f.toAlgebra\n  letI := fun r : s => (Localization.awayMap f r).toAlgebra\n  have : ∀ r : s,\n      IsLocalization ((Submonoid.powers (r : R)).map (algebraMap R S)) (Localization.Away (f r)) :=\n    by intro r; rw [Submonoid.map_powers]; exact Localization.isLocalization\n  haveI : ∀ r : s, IsScalarTower R (Localization.Away (r : R)) (Localization.Away (f r)) :=\n    fun r => IsScalarTower.of_algebraMap_eq'\n      (IsLocalization.map_comp (Submonoid.powers (r : R)).le_comap_map).symm\n  constructor\n  replace H := fun r => (H r).1\n  choose s₁ s₂ using H\n  let sf := fun x : s => IsLocalization.finsetIntegerMultiple (Submonoid.powers (f x)) (s₁ x)\n  use s.attach.biUnion sf\n  convert (Algebra.adjoin_attach_biUnion (R := R) sf).trans _\n  rw [eq_top_iff]\n  rintro x -\n  apply (⨆ x : s, Algebra.adjoin R (sf x : Set S)).toSubmodule.mem_of_span_eq_top_of_smul_pow_mem\n    _ hs _ _\n  intro r\n  obtain ⟨⟨_, n₁, rfl⟩, hn₁⟩ :=\n    multiple_mem_adjoin_of_mem_localization_adjoin (Submonoid.powers (r : R))\n      (Localization.Away (r : R)) (s₁ r : Set (Localization.Away (f r)))\n      (algebraMap S (Localization.Away (f r)) x) (by rw [s₂ r]; trivial)\n  rw [Submonoid.smul_def, Algebra.smul_def, IsScalarTower.algebraMap_apply R S, ← map_mul] at hn₁\n  obtain ⟨⟨_, n₂, rfl⟩, hn₂⟩ :=\n    IsLocalization.lift_mem_adjoin_finsetIntegerMultiple (Submonoid.powers (r : R)) _ (s₁ r) hn₁\n  rw [Submonoid.smul_def, ← Algebra.smul_def, smul_smul, ← pow_add] at hn₂\n  simp_rw [Submonoid.map_powers] at hn₂\n  use n₂ + n₁\n  exact le_iSup (fun x : s => Algebra.adjoin R (sf x : Set S)) r hn₂\n\n"}
{"name":"RingHom.finiteType_holdsForLocalizationAway","module":"Mathlib.RingTheory.RingHom.FiniteType","initialProofState":"⊢ RingHom.HoldsForLocalizationAway @RingHom.FiniteType","decl":"theorem finiteType_holdsForLocalizationAway : HoldsForLocalizationAway @FiniteType := by\n  introv R _\n  suffices Algebra.FiniteType R S by\n    rw [RingHom.FiniteType]\n    convert this; ext\n    rw [Algebra.smul_def]; rfl\n  exact IsLocalization.finiteType_of_monoid_fg (Submonoid.powers r) S\n\n"}
{"name":"RingHom.finiteType_ofLocalizationSpanTarget","module":"Mathlib.RingTheory.RingHom.FiniteType","initialProofState":"⊢ RingHom.OfLocalizationSpanTarget @RingHom.FiniteType","decl":"theorem finiteType_ofLocalizationSpanTarget : OfLocalizationSpanTarget @FiniteType := by\n  -- Setup algebra instances.\n  rw [ofLocalizationSpanTarget_iff_finite]\n  introv R hs H\n  classical\n  letI := f.toAlgebra\n  replace H : ∀ r : s, Algebra.FiniteType R (Localization.Away (r : S)) := by\n    intro r; simp_rw [RingHom.FiniteType] at H; convert H r; ext; simp_rw [Algebra.smul_def]; rfl\n  replace H := fun r => (H r).1\n  constructor\n  -- Suppose `s : Finset S` spans `S`, and each `Sᵣ` is finitely generated as an `R`-algebra.\n  -- Say `t r : Finset Sᵣ` generates `Sᵣ`. By assumption, we may find `lᵢ` such that\n  -- `∑ lᵢ * sᵢ = 1`. I claim that all `s` and `l` and the numerators of `t` and generates `S`.\n  choose t ht using H\n  obtain ⟨l, hl⟩ :=\n    (Finsupp.mem_span_iff_linearCombination S (s : Set S) 1).mp\n      (show (1 : S) ∈ Ideal.span (s : Set S) by rw [hs]; trivial)\n  let sf := fun x : s => IsLocalization.finsetIntegerMultiple (Submonoid.powers (x : S)) (t x)\n  use s.attach.biUnion sf ∪ s ∪ l.support.image l\n  rw [eq_top_iff]\n  -- We need to show that every `x` falls in the subalgebra generated by those elements.\n  -- Since all `s` and `l` are in the subalgebra, it suffices to check that `sᵢ ^ nᵢ • x` falls in\n  -- the algebra for each `sᵢ` and some `nᵢ`.\n  rintro x -\n  apply Subalgebra.mem_of_span_eq_top_of_smul_pow_mem _ (s : Set S) l hl _ _ x _\n  · intro x hx\n    apply Algebra.subset_adjoin\n    rw [Finset.coe_union, Finset.coe_union]\n    exact Or.inl (Or.inr hx)\n  · intro i\n    by_cases h : l i = 0; · rw [h]; exact zero_mem _\n    apply Algebra.subset_adjoin\n    rw [Finset.coe_union, Finset.coe_image]\n    exact Or.inr (Set.mem_image_of_mem _ (Finsupp.mem_support_iff.mpr h))\n  · intro r\n    rw [Finset.coe_union, Finset.coe_union, Finset.coe_biUnion]\n    -- Since all `sᵢ` and numerators of `t r` are in the algebra, it suffices to show that the\n    -- image of `x` in `Sᵣ` falls in the `R`-adjoin of `t r`, which is of course true.\n    -- Porting note: The following `obtain` fails because Lean wants to know right away what the\n    -- placeholders are, so we need to provide a little more guidance\n    -- obtain ⟨⟨_, n₂, rfl⟩, hn₂⟩ := IsLocalization.exists_smul_mem_of_mem_adjoin\n    --   (Submonoid.powers (r : S)) x (t r) (Algebra.adjoin R _) _ _ _\n    rw [show ∀ A : Set S, (∃ n, (r : S) ^ n • x ∈ Algebra.adjoin R A) ↔\n      (∃ m : (Submonoid.powers (r : S)), (m : S) • x ∈ Algebra.adjoin R A) by\n      { exact fun _ => by simp [Submonoid.mem_powers_iff] }]\n    refine IsLocalization.exists_smul_mem_of_mem_adjoin\n      (Submonoid.powers (r : S)) x (t r) (Algebra.adjoin R _) ?_ ?_ ?_\n    · intro x hx\n      apply Algebra.subset_adjoin\n      exact Or.inl (Or.inl ⟨_, ⟨r, rfl⟩, _, ⟨s.mem_attach r, rfl⟩, hx⟩)\n    · rw [Submonoid.powers_eq_closure, Submonoid.closure_le, Set.singleton_subset_iff]\n      apply Algebra.subset_adjoin\n      exact Or.inl (Or.inr r.2)\n    · rw [ht]; trivial\n\n"}
{"name":"RingHom.finiteType_is_local","module":"Mathlib.RingTheory.RingHom.FiniteType","initialProofState":"⊢ RingHom.PropertyIsLocal @RingHom.FiniteType","decl":"theorem finiteType_is_local : PropertyIsLocal @FiniteType :=\n  ⟨finiteType_localizationPreserves.away,\n    finiteType_ofLocalizationSpanTarget,\n    finiteType_ofLocalizationSpanTarget.ofLocalizationSpan\n      (finiteType_stableUnderComposition.stableUnderCompositionWithLocalizationAway\n        finiteType_holdsForLocalizationAway).left,\n    (finiteType_stableUnderComposition.stableUnderCompositionWithLocalizationAway\n      finiteType_holdsForLocalizationAway).right⟩\n\n"}
{"name":"RingHom.finiteType_respectsIso","module":"Mathlib.RingTheory.RingHom.FiniteType","initialProofState":"⊢ RingHom.RespectsIso @RingHom.FiniteType","decl":"theorem finiteType_respectsIso : RingHom.RespectsIso @RingHom.FiniteType :=\n  RingHom.finiteType_is_local.respectsIso\n\n"}
{"name":"RingHom.finiteType_isStableUnderBaseChange","module":"Mathlib.RingTheory.RingHom.FiniteType","initialProofState":"⊢ RingHom.IsStableUnderBaseChange @RingHom.FiniteType","decl":"theorem finiteType_isStableUnderBaseChange : IsStableUnderBaseChange @FiniteType := by\n  apply IsStableUnderBaseChange.mk\n  · exact finiteType_respectsIso\n  · introv h\n    replace h : Algebra.FiniteType R T := by\n      rw [RingHom.FiniteType] at h; convert h; ext; simp_rw [Algebra.smul_def]; rfl\n    suffices Algebra.FiniteType S (S ⊗[R] T) by\n      rw [RingHom.FiniteType]; convert this; ext; simp_rw [Algebra.smul_def]; rfl\n    infer_instance\n\n"}
