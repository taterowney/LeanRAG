{"name":"LocalizedModule.subsingleton_iff_disjoint","module":"Mathlib.RingTheory.Spectrum.Prime.Module","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : R\n⊢ Iff (Subsingleton (LocalizedModule (Submonoid.powers f) M)) (Disjoint (↑(PrimeSpectrum.basicOpen f)) (Module.support R M))","decl":"/-- `M[1/f] = 0` if and only if `D(f) ∩ Supp M = 0`. -/\nlemma LocalizedModule.subsingleton_iff_disjoint {f : R} :\n    Subsingleton (LocalizedModule (.powers f) M) ↔\n      Disjoint ↑(PrimeSpectrum.basicOpen f) (Module.support R M) := by\n  rw [subsingleton_iff_support_subset, PrimeSpectrum.basicOpen_eq_zeroLocus_compl,\n    disjoint_compl_left_iff, Set.le_iff_subset]\n\n"}
{"name":"Module.stableUnderSpecialization_support","module":"Mathlib.RingTheory.Spectrum.Prime.Module","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ StableUnderSpecialization (Module.support R M)","decl":"lemma Module.stableUnderSpecialization_support :\n    StableUnderSpecialization (Module.support R M) := by\n  intros x y e H\n  rw [mem_support_iff_exists_annihilator] at H ⊢\n  obtain ⟨m, hm⟩ := H\n  exact ⟨m, hm.trans ((PrimeSpectrum.le_iff_specializes _ _).mpr e)⟩\n\n"}
{"name":"Module.isClosed_support","module":"Mathlib.RingTheory.Spectrum.Prime.Module","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.Finite R M\n⊢ IsClosed (Module.support R M)","decl":"lemma Module.isClosed_support [Module.Finite R M] :\n    IsClosed (Module.support R M) := by\n  rw [support_eq_zeroLocus]\n  apply PrimeSpectrum.isClosed_zeroLocus\n\n"}
{"name":"Module.support_subset_preimage_comap","module":"Mathlib.RingTheory.Spectrum.Prime.Module","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : CommRing A\ninst✝² : Algebra R A\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\n⊢ HasSubset.Subset (Module.support A M) (Set.preimage (⇑(PrimeSpectrum.comap (algebraMap R A))) (Module.support R M))","decl":"lemma Module.support_subset_preimage_comap [IsScalarTower R A M] :\n    Module.support A M ⊆ PrimeSpectrum.comap (algebraMap R A) ⁻¹' Module.support R M := by\n  intro x hx\n  simp only [Set.mem_preimage, mem_support_iff', PrimeSpectrum.comap_asIdeal, Ideal.mem_comap,\n    ne_eq, not_imp_not] at hx ⊢\n  obtain ⟨m, hm⟩ := hx\n  exact ⟨m, fun r e ↦ hm _ (by simpa)⟩\n\n"}
