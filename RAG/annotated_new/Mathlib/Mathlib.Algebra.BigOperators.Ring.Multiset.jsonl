{"name":"Multiset.prod_map_neg","module":"Mathlib.Algebra.BigOperators.Ring.Multiset","initialProofState":"α : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : HasDistribNeg α\ns : Multiset α\n⊢ Eq (Multiset.map Neg.neg s).prod (HMul.hMul (HPow.hPow (-1) s.card) s.prod)","decl":"@[simp] lemma prod_map_neg (s : Multiset α) : (s.map Neg.neg).prod = (-1) ^ card s * s.prod :=\n  Quotient.inductionOn s (by simp)\n\n"}
{"name":"Multiset.prod_eq_zero","module":"Mathlib.Algebra.BigOperators.Ring.Multiset","initialProofState":"α : Type u_2\ninst✝ : CommMonoidWithZero α\ns : Multiset α\nh : Membership.mem s 0\n⊢ Eq s.prod 0","decl":"lemma prod_eq_zero (h : (0 : α) ∈ s) : s.prod = 0 := by\n  rcases Multiset.exists_cons_of_mem h with ⟨s', hs'⟩; simp [hs', Multiset.prod_cons]\n\n"}
{"name":"Multiset.prod_eq_zero_iff","module":"Mathlib.Algebra.BigOperators.Ring.Multiset","initialProofState":"α : Type u_2\ninst✝² : CommMonoidWithZero α\ninst✝¹ : NoZeroDivisors α\ninst✝ : Nontrivial α\ns : Multiset α\n⊢ Iff (Eq s.prod 0) (Membership.mem s 0)","decl":"@[simp] lemma prod_eq_zero_iff : s.prod = 0 ↔ (0 : α) ∈ s :=\n  Quotient.inductionOn s fun l ↦ by rw [quot_mk_to_coe, prod_coe]; exact List.prod_eq_zero_iff\n\n"}
{"name":"Multiset.prod_ne_zero","module":"Mathlib.Algebra.BigOperators.Ring.Multiset","initialProofState":"α : Type u_2\ninst✝² : CommMonoidWithZero α\ninst✝¹ : NoZeroDivisors α\ninst✝ : Nontrivial α\ns : Multiset α\nh : Not (Membership.mem s 0)\n⊢ Ne s.prod 0","decl":"lemma prod_ne_zero (h : (0 : α) ∉ s) : s.prod ≠ 0 := mt prod_eq_zero_iff.1 h\n\n"}
{"name":"Multiset.sum_map_mul_left","module":"Mathlib.Algebra.BigOperators.Ring.Multiset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : NonUnitalNonAssocSemiring α\na : α\ns : Multiset ι\nf : ι → α\n⊢ Eq (Multiset.map (fun i => HMul.hMul a (f i)) s).sum (HMul.hMul a (Multiset.map f s).sum)","decl":"lemma sum_map_mul_left : sum (s.map fun i ↦ a * f i) = a * sum (s.map f) :=\n  Multiset.induction_on s (by simp) fun i s ih => by simp [ih, mul_add]\n\n"}
{"name":"Multiset.sum_map_mul_right","module":"Mathlib.Algebra.BigOperators.Ring.Multiset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : NonUnitalNonAssocSemiring α\na : α\ns : Multiset ι\nf : ι → α\n⊢ Eq (Multiset.map (fun i => HMul.hMul (f i) a) s).sum (HMul.hMul (Multiset.map f s).sum a)","decl":"lemma sum_map_mul_right : sum (s.map fun i ↦ f i * a) = sum (s.map f) * a :=\n  Multiset.induction_on s (by simp) fun a s ih => by simp [ih, add_mul]\n\n"}
{"name":"Multiset.dvd_sum","module":"Mathlib.Algebra.BigOperators.Ring.Multiset","initialProofState":"α : Type u_2\ninst✝ : NonUnitalSemiring α\ns : Multiset α\na : α\na✝ : ∀ (x : α), Membership.mem s x → Dvd.dvd a x\n⊢ Dvd.dvd a s.sum","decl":"lemma dvd_sum : (∀ x ∈ s, a ∣ x) → a ∣ s.sum :=\n  Multiset.induction_on s (fun _ ↦ dvd_zero _) fun x s ih h ↦ by\n    rw [sum_cons]\n    exact dvd_add (h _ (mem_cons_self _ _)) (ih fun y hy ↦ h _ <| mem_cons.2 <| Or.inr hy)\n\n"}
{"name":"Multiset.prod_map_sum","module":"Mathlib.Algebra.BigOperators.Ring.Multiset","initialProofState":"α : Type u_2\ninst✝ : CommSemiring α\ns : Multiset (Multiset α)\n⊢ Eq (Multiset.map Multiset.sum s).prod (Multiset.map Multiset.prod s.Sections).sum","decl":"lemma prod_map_sum {s : Multiset (Multiset α)} :\n    prod (s.map sum) = sum ((Sections s).map prod) :=\n  Multiset.induction_on s (by simp) fun a s ih ↦ by\n    simp [ih, map_bind, sum_map_mul_left, sum_map_mul_right]\n\n"}
{"name":"Multiset.prod_map_add","module":"Mathlib.Algebra.BigOperators.Ring.Multiset","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : CommSemiring α\ns : Multiset ι\nf g : ι → α\n⊢ Eq (Multiset.map (fun i => HAdd.hAdd (f i) (g i)) s).prod (Multiset.map (fun p => HMul.hMul (Multiset.map f p.1).prod (Multiset.map g p.2).prod) s.antidiagonal).sum","decl":"lemma prod_map_add {s : Multiset ι} {f g : ι → α} :\n    prod (s.map fun i ↦ f i + g i) =\n      sum ((antidiagonal s).map fun p ↦ (p.1.map f).prod * (p.2.map g).prod) := by\n  refine s.induction_on ?_ fun a s ih ↦ ?_\n  · simp only [map_zero, prod_zero, antidiagonal_zero, map_singleton, mul_one, sum_singleton]\n  · simp only [map_cons, prod_cons, ih, sum_map_mul_left.symm, add_mul, mul_left_comm (f a),\n      mul_left_comm (g a), sum_map_add, antidiagonal_cons, Prod.map_fst, Prod.map_snd,\n      id_eq, map_add, map_map, Function.comp_apply, mul_assoc, sum_add]\n    exact add_comm _ _\n\n"}
{"name":"Commute.multiset_sum_right","module":"Mathlib.Algebra.BigOperators.Ring.Multiset","initialProofState":"α : Type u_2\ninst✝ : NonUnitalNonAssocSemiring α\ns : Multiset α\na : α\nh : ∀ (b : α), Membership.mem s b → Commute a b\n⊢ Commute a s.sum","decl":"theorem multiset_sum_right (a : α) (h : ∀ b ∈ s, Commute a b) : Commute a s.sum := by\n  induction s using Quotient.inductionOn\n  rw [quot_mk_to_coe, sum_coe]\n  exact Commute.list_sum_right _ _ h\n\n"}
{"name":"Commute.multiset_sum_left","module":"Mathlib.Algebra.BigOperators.Ring.Multiset","initialProofState":"α : Type u_2\ninst✝ : NonUnitalNonAssocSemiring α\ns : Multiset α\nb : α\nh : ∀ (a : α), Membership.mem s a → Commute a b\n⊢ Commute s.sum b","decl":"theorem multiset_sum_left (b : α) (h : ∀ a ∈ s, Commute a b) : Commute s.sum b :=\n  ((Commute.multiset_sum_right _ _) fun _ ha => (h _ ha).symm).symm\n\n"}
