{"name":"Filter.mem_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\na : Œ±\n‚ä¢ Membership.mem Filter.atTop (setOf fun b => LE.le a b)","decl":"theorem mem_atTop [Preorder Œ±] (a : Œ±) : { b : Œ± | a ‚â§ b } ‚àà @atTop Œ± _ :=\n  mem_iInf_of_mem a <| Subset.refl _\n\n"}
{"name":"Filter.Ici_mem_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\na : Œ±\n‚ä¢ Membership.mem Filter.atTop (Set.Ici a)","decl":"theorem Ici_mem_atTop [Preorder Œ±] (a : Œ±) : Ici a ‚àà (atTop : Filter Œ±) :=\n  mem_atTop a\n\n"}
{"name":"Filter.Ioi_mem_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : NoMaxOrder Œ±\nx : Œ±\n‚ä¢ Membership.mem Filter.atTop (Set.Ioi x)","decl":"theorem Ioi_mem_atTop [Preorder Œ±] [NoMaxOrder Œ±] (x : Œ±) : Ioi x ‚àà (atTop : Filter Œ±) :=\n  let ‚ü®z, hz‚ü© := exists_gt x\n  mem_of_superset (mem_atTop z) fun _ h => lt_of_lt_of_le hz h\n\n"}
{"name":"Filter.mem_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\na : Œ±\n‚ä¢ Membership.mem Filter.atBot (setOf fun b => LE.le b a)","decl":"theorem mem_atBot [Preorder Œ±] (a : Œ±) : { b : Œ± | b ‚â§ a } ‚àà @atBot Œ± _ :=\n  mem_iInf_of_mem a <| Subset.refl _\n\n"}
{"name":"Filter.Iic_mem_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\na : Œ±\n‚ä¢ Membership.mem Filter.atBot (Set.Iic a)","decl":"theorem Iic_mem_atBot [Preorder Œ±] (a : Œ±) : Iic a ‚àà (atBot : Filter Œ±) :=\n  mem_atBot a\n\n"}
{"name":"Filter.Iio_mem_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : NoMinOrder Œ±\nx : Œ±\n‚ä¢ Membership.mem Filter.atBot (Set.Iio x)","decl":"theorem Iio_mem_atBot [Preorder Œ±] [NoMinOrder Œ±] (x : Œ±) : Iio x ‚àà (atBot : Filter Œ±) :=\n  let ‚ü®z, hz‚ü© := exists_lt x\n  mem_of_superset (mem_atBot z) fun _ h => lt_of_le_of_lt h hz\n\n"}
{"name":"Filter.disjoint_atBot_principal_Ioi","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\nx : Œ±\n‚ä¢ Disjoint Filter.atBot (Filter.principal (Set.Ioi x))","decl":"theorem disjoint_atBot_principal_Ioi [Preorder Œ±] (x : Œ±) : Disjoint atBot (ùìü (Ioi x)) :=\n  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl) (Iic_mem_atBot x) (mem_principal_self _)\n\n"}
{"name":"Filter.disjoint_atTop_principal_Iio","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\nx : Œ±\n‚ä¢ Disjoint Filter.atTop (Filter.principal (Set.Iio x))","decl":"theorem disjoint_atTop_principal_Iio [Preorder Œ±] (x : Œ±) : Disjoint atTop (ùìü (Iio x)) :=\n  @disjoint_atBot_principal_Ioi Œ±·µí·µà _ _\n\n"}
{"name":"Filter.disjoint_atTop_principal_Iic","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : NoMaxOrder Œ±\nx : Œ±\n‚ä¢ Disjoint Filter.atTop (Filter.principal (Set.Iic x))","decl":"theorem disjoint_atTop_principal_Iic [Preorder Œ±] [NoMaxOrder Œ±] (x : Œ±) :\n    Disjoint atTop (ùìü (Iic x)) :=\n  disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl).symm (Ioi_mem_atTop x)\n    (mem_principal_self _)\n\n"}
{"name":"Filter.disjoint_atBot_principal_Ici","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : NoMinOrder Œ±\nx : Œ±\n‚ä¢ Disjoint Filter.atBot (Filter.principal (Set.Ici x))","decl":"theorem disjoint_atBot_principal_Ici [Preorder Œ±] [NoMinOrder Œ±] (x : Œ±) :\n    Disjoint atBot (ùìü (Ici x)) :=\n  @disjoint_atTop_principal_Iic Œ±·µí·µà _ _ _\n\n"}
{"name":"Filter.disjoint_pure_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : NoMaxOrder Œ±\nx : Œ±\n‚ä¢ Disjoint (Pure.pure x) Filter.atTop","decl":"theorem disjoint_pure_atTop [Preorder Œ±] [NoMaxOrder Œ±] (x : Œ±) : Disjoint (pure x) atTop :=\n  Disjoint.symm <| (disjoint_atTop_principal_Iic x).mono_right <| le_principal_iff.2 <|\n    mem_pure.2 right_mem_Iic\n\n"}
{"name":"Filter.disjoint_pure_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : NoMinOrder Œ±\nx : Œ±\n‚ä¢ Disjoint (Pure.pure x) Filter.atBot","decl":"theorem disjoint_pure_atBot [Preorder Œ±] [NoMinOrder Œ±] (x : Œ±) : Disjoint (pure x) atBot :=\n  @disjoint_pure_atTop Œ±·µí·µà _ _ _\n\n"}
{"name":"Filter.not_tendsto_const_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : NoMaxOrder Œ±\nx : Œ±\nl : Filter Œ≤\ninst‚úù : l.NeBot\n‚ä¢ Not (Filter.Tendsto (fun x_1 => x) l Filter.atTop)","decl":"theorem not_tendsto_const_atTop [Preorder Œ±] [NoMaxOrder Œ±] (x : Œ±) (l : Filter Œ≤) [l.NeBot] :\n    ¬¨Tendsto (fun _ => x) l atTop :=\n  tendsto_const_pure.not_tendsto (disjoint_pure_atTop x)\n\n"}
{"name":"Filter.not_tendsto_const_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : NoMinOrder Œ±\nx : Œ±\nl : Filter Œ≤\ninst‚úù : l.NeBot\n‚ä¢ Not (Filter.Tendsto (fun x_1 => x) l Filter.atBot)","decl":"theorem not_tendsto_const_atBot [Preorder Œ±] [NoMinOrder Œ±] (x : Œ±) (l : Filter Œ≤) [l.NeBot] :\n    ¬¨Tendsto (fun _ => x) l atBot :=\n  tendsto_const_pure.not_tendsto (disjoint_pure_atBot x)\n\n"}
{"name":"Filter.disjoint_atBot_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : PartialOrder Œ±\ninst‚úù : Nontrivial Œ±\n‚ä¢ Disjoint Filter.atBot Filter.atTop","decl":"theorem disjoint_atBot_atTop [PartialOrder Œ±] [Nontrivial Œ±] :\n    Disjoint (atBot : Filter Œ±) atTop := by\n  rcases exists_pair_ne Œ± with ‚ü®x, y, hne‚ü©\n  by_cases hle : x ‚â§ y\n  ¬∑ refine disjoint_of_disjoint_of_mem ?_ (Iic_mem_atBot x) (Ici_mem_atTop y)\n    exact Iic_disjoint_Ici.2 (hle.lt_of_ne hne).not_le\n  ¬∑ refine disjoint_of_disjoint_of_mem ?_ (Iic_mem_atBot y) (Ici_mem_atTop x)\n    exact Iic_disjoint_Ici.2 hle\n\n"}
{"name":"Filter.disjoint_atTop_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : PartialOrder Œ±\ninst‚úù : Nontrivial Œ±\n‚ä¢ Disjoint Filter.atTop Filter.atBot","decl":"theorem disjoint_atTop_atBot [PartialOrder Œ±] [Nontrivial Œ±] : Disjoint (atTop : Filter Œ±) atBot :=\n  disjoint_atBot_atTop.symm\n\n"}
{"name":"Filter.eventually_ge_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\na : Œ±\n‚ä¢ Filter.Eventually (fun x => LE.le a x) Filter.atTop","decl":"theorem eventually_ge_atTop [Preorder Œ±] (a : Œ±) : ‚àÄ·∂† x in atTop, a ‚â§ x :=\n  mem_atTop a\n\n"}
{"name":"Filter.eventually_le_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\na : Œ±\n‚ä¢ Filter.Eventually (fun x => LE.le x a) Filter.atBot","decl":"theorem eventually_le_atBot [Preorder Œ±] (a : Œ±) : ‚àÄ·∂† x in atBot, x ‚â§ a :=\n  mem_atBot a\n\n"}
{"name":"Filter.eventually_gt_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\n‚ä¢ Filter.Eventually (fun x => LT.lt a x) Filter.atTop","decl":"theorem eventually_gt_atTop [Preorder Œ±] [NoMaxOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atTop, a < x :=\n  Ioi_mem_atTop a\n\n"}
{"name":"Filter.eventually_ne_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\n‚ä¢ Filter.Eventually (fun x => Ne x a) Filter.atTop","decl":"theorem eventually_ne_atTop [Preorder Œ±] [NoMaxOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atTop, x ‚â† a :=\n  (eventually_gt_atTop a).mono fun _ => ne_of_gt\n\n"}
{"name":"Filter.Tendsto.eventually_gt_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : NoMaxOrder Œ≤\nf : Œ± ‚Üí Œ≤\nl : Filter Œ±\nhf : Filter.Tendsto f l Filter.atTop\nc : Œ≤\n‚ä¢ Filter.Eventually (fun x => LT.lt c (f x)) l","decl":"protected theorem Tendsto.eventually_gt_atTop [Preorder Œ≤] [NoMaxOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}\n    (hf : Tendsto f l atTop) (c : Œ≤) : ‚àÄ·∂† x in l, c < f x :=\n  hf.eventually (eventually_gt_atTop c)\n\n"}
{"name":"Filter.Tendsto.eventually_ge_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù : Preorder Œ≤\nf : Œ± ‚Üí Œ≤\nl : Filter Œ±\nhf : Filter.Tendsto f l Filter.atTop\nc : Œ≤\n‚ä¢ Filter.Eventually (fun x => LE.le c (f x)) l","decl":"protected theorem Tendsto.eventually_ge_atTop [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}\n    (hf : Tendsto f l atTop) (c : Œ≤) : ‚àÄ·∂† x in l, c ‚â§ f x :=\n  hf.eventually (eventually_ge_atTop c)\n\n"}
{"name":"Filter.Tendsto.eventually_ne_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : NoMaxOrder Œ≤\nf : Œ± ‚Üí Œ≤\nl : Filter Œ±\nhf : Filter.Tendsto f l Filter.atTop\nc : Œ≤\n‚ä¢ Filter.Eventually (fun x => Ne (f x) c) l","decl":"protected theorem Tendsto.eventually_ne_atTop [Preorder Œ≤] [NoMaxOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}\n    (hf : Tendsto f l atTop) (c : Œ≤) : ‚àÄ·∂† x in l, f x ‚â† c :=\n  hf.eventually (eventually_ne_atTop c)\n\n"}
{"name":"Filter.Tendsto.eventually_ne_atTop'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : NoMaxOrder Œ≤\nf : Œ± ‚Üí Œ≤\nl : Filter Œ±\nhf : Filter.Tendsto f l Filter.atTop\nc : Œ±\n‚ä¢ Filter.Eventually (fun x => Ne x c) l","decl":"protected theorem Tendsto.eventually_ne_atTop' [Preorder Œ≤] [NoMaxOrder Œ≤] {f : Œ± ‚Üí Œ≤}\n    {l : Filter Œ±} (hf : Tendsto f l atTop) (c : Œ±) : ‚àÄ·∂† x in l, x ‚â† c :=\n  (hf.eventually_ne_atTop (f c)).mono fun _ => ne_of_apply_ne f\n\n"}
{"name":"Filter.eventually_lt_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : NoMinOrder Œ±\na : Œ±\n‚ä¢ Filter.Eventually (fun x => LT.lt x a) Filter.atBot","decl":"theorem eventually_lt_atBot [Preorder Œ±] [NoMinOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atBot, x < a :=\n  Iio_mem_atBot a\n\n"}
{"name":"Filter.eventually_ne_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : NoMinOrder Œ±\na : Œ±\n‚ä¢ Filter.Eventually (fun x => Ne x a) Filter.atBot","decl":"theorem eventually_ne_atBot [Preorder Œ±] [NoMinOrder Œ±] (a : Œ±) : ‚àÄ·∂† x in atBot, x ‚â† a :=\n  (eventually_lt_atBot a).mono fun _ => ne_of_lt\n\n"}
{"name":"Filter.Tendsto.eventually_lt_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : NoMinOrder Œ≤\nf : Œ± ‚Üí Œ≤\nl : Filter Œ±\nhf : Filter.Tendsto f l Filter.atBot\nc : Œ≤\n‚ä¢ Filter.Eventually (fun x => LT.lt (f x) c) l","decl":"protected theorem Tendsto.eventually_lt_atBot [Preorder Œ≤] [NoMinOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}\n    (hf : Tendsto f l atBot) (c : Œ≤) : ‚àÄ·∂† x in l, f x < c :=\n  hf.eventually (eventually_lt_atBot c)\n\n"}
{"name":"Filter.Tendsto.eventually_le_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù : Preorder Œ≤\nf : Œ± ‚Üí Œ≤\nl : Filter Œ±\nhf : Filter.Tendsto f l Filter.atBot\nc : Œ≤\n‚ä¢ Filter.Eventually (fun x => LE.le (f x) c) l","decl":"protected theorem Tendsto.eventually_le_atBot [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}\n    (hf : Tendsto f l atBot) (c : Œ≤) : ‚àÄ·∂† x in l, f x ‚â§ c :=\n  hf.eventually (eventually_le_atBot c)\n\n"}
{"name":"Filter.Tendsto.eventually_ne_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : NoMinOrder Œ≤\nf : Œ± ‚Üí Œ≤\nl : Filter Œ±\nhf : Filter.Tendsto f l Filter.atBot\nc : Œ≤\n‚ä¢ Filter.Eventually (fun x => Ne (f x) c) l","decl":"protected theorem Tendsto.eventually_ne_atBot [Preorder Œ≤] [NoMinOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}\n    (hf : Tendsto f l atBot) (c : Œ≤) : ‚àÄ·∂† x in l, f x ‚â† c :=\n  hf.eventually (eventually_ne_atBot c)\n\n"}
{"name":"Filter.eventually_forall_ge_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\np : Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun x => ‚àÄ (y : Œ±), LE.le x y ‚Üí p y) Filter.atTop) (Filter.Eventually (fun x => p x) Filter.atTop)","decl":"theorem eventually_forall_ge_atTop [Preorder Œ±] {p : Œ± ‚Üí Prop} :\n    (‚àÄ·∂† x in atTop, ‚àÄ y, x ‚â§ y ‚Üí p y) ‚Üî ‚àÄ·∂† x in atTop, p x := by\n  refine ‚ü®fun h ‚Ü¶ h.mono fun x hx ‚Ü¶ hx x le_rfl, fun h ‚Ü¶ ?_‚ü©\n  rcases (hasBasis_iInf_principal_finite _).eventually_iff.1 h with ‚ü®S, hSf, hS‚ü©\n  refine mem_iInf_of_iInter hSf (V := fun x ‚Ü¶ Ici x.1) (fun _ ‚Ü¶ Subset.rfl) fun x hx y hy ‚Ü¶ ?_\n  simp only [mem_iInter] at hS hx\n  exact hS fun z hz ‚Ü¶ le_trans (hx ‚ü®z, hz‚ü©) hy\n\n"}
{"name":"Filter.eventually_forall_le_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\np : Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun x => ‚àÄ (y : Œ±), LE.le y x ‚Üí p y) Filter.atBot) (Filter.Eventually (fun x => p x) Filter.atBot)","decl":"theorem eventually_forall_le_atBot [Preorder Œ±] {p : Œ± ‚Üí Prop} :\n    (‚àÄ·∂† x in atBot, ‚àÄ y, y ‚â§ x ‚Üí p y) ‚Üî ‚àÄ·∂† x in atBot, p x :=\n  eventually_forall_ge_atTop (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.Tendsto.eventually_forall_ge_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù : Preorder Œ≤\nl : Filter Œ±\np : Œ≤ ‚Üí Prop\nf : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f l Filter.atTop\nh_evtl : Filter.Eventually (fun x => p x) Filter.atTop\n‚ä¢ Filter.Eventually (fun x => ‚àÄ (y : Œ≤), LE.le (f x) y ‚Üí p y) l","decl":"theorem Tendsto.eventually_forall_ge_atTop [Preorder Œ≤] {l : Filter Œ±}\n    {p : Œ≤ ‚Üí Prop} {f : Œ± ‚Üí Œ≤} (hf : Tendsto f l atTop) (h_evtl : ‚àÄ·∂† x in atTop, p x) :\n    ‚àÄ·∂† x in l, ‚àÄ y, f x ‚â§ y ‚Üí p y := by\n  rw [‚Üê Filter.eventually_forall_ge_atTop] at h_evtl; exact (h_evtl.comap f).filter_mono hf.le_comap\n\n"}
{"name":"Filter.Tendsto.eventually_forall_le_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù : Preorder Œ≤\nl : Filter Œ±\np : Œ≤ ‚Üí Prop\nf : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f l Filter.atBot\nh_evtl : Filter.Eventually (fun x => p x) Filter.atBot\n‚ä¢ Filter.Eventually (fun x => ‚àÄ (y : Œ≤), LE.le y (f x) ‚Üí p y) l","decl":"theorem Tendsto.eventually_forall_le_atBot [Preorder Œ≤] {l : Filter Œ±}\n    {p : Œ≤ ‚Üí Prop} {f : Œ± ‚Üí Œ≤} (hf : Tendsto f l atBot) (h_evtl : ‚àÄ·∂† x in atBot, p x) :\n    ‚àÄ·∂† x in l, ‚àÄ y, y ‚â§ f x ‚Üí p y := by\n  rw [‚Üê Filter.eventually_forall_le_atBot] at h_evtl; exact (h_evtl.comap f).filter_mono hf.le_comap\n\n"}
{"name":"IsTop.atTop_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\na : Œ±\nha : IsTop a\n‚ä¢ Eq Filter.atTop (Filter.principal (Set.Ici a))","decl":"theorem _root_.IsTop.atTop_eq [Preorder Œ±] {a : Œ±} (ha : IsTop a) : atTop = ùìü (Ici a) :=\n  (iInf_le _ _).antisymm <| le_iInf fun b ‚Ü¶ principal_mono.2 <| Ici_subset_Ici.2 <| ha b\n\n"}
{"name":"IsBot.atBot_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\na : Œ±\nha : IsBot a\n‚ä¢ Eq Filter.atBot (Filter.principal (Set.Iic a))","decl":"theorem _root_.IsBot.atBot_eq [Preorder Œ±] {a : Œ±} (ha : IsBot a) : atBot = ùìü (Iic a) :=\n  ha.toDual.atTop_eq\n\n"}
{"name":"Filter.OrderTop.atTop_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_6\ninst‚úù¬π : PartialOrder Œ±\ninst‚úù : OrderTop Œ±\n‚ä¢ Eq Filter.atTop (Pure.pure Top.top)","decl":"theorem OrderTop.atTop_eq (Œ±) [PartialOrder Œ±] [OrderTop Œ±] : (atTop : Filter Œ±) = pure ‚ä§ := by\n  rw [isTop_top.atTop_eq, Ici_top, principal_singleton]\n\n"}
{"name":"Filter.OrderBot.atBot_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_6\ninst‚úù¬π : PartialOrder Œ±\ninst‚úù : OrderBot Œ±\n‚ä¢ Eq Filter.atBot (Pure.pure Bot.bot)","decl":"theorem OrderBot.atBot_eq (Œ±) [PartialOrder Œ±] [OrderBot Œ±] : (atBot : Filter Œ±) = pure ‚ä• :=\n  @OrderTop.atTop_eq Œ±·µí·µà _ _\n\n"}
{"name":"Filter.Subsingleton.atTop_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_6\ninst‚úù¬π : Subsingleton Œ±\ninst‚úù : Preorder Œ±\n‚ä¢ Eq Filter.atTop Top.top","decl":"@[nontriviality]\ntheorem Subsingleton.atTop_eq (Œ±) [Subsingleton Œ±] [Preorder Œ±] : (atTop : Filter Œ±) = ‚ä§ := by\n  refine top_unique fun s hs x => ?_\n  rw [atTop, ciInf_subsingleton x, mem_principal] at hs\n  exact hs left_mem_Ici\n\n"}
{"name":"Filter.Subsingleton.atBot_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_6\ninst‚úù¬π : Subsingleton Œ±\ninst‚úù : Preorder Œ±\n‚ä¢ Eq Filter.atBot Top.top","decl":"@[nontriviality]\ntheorem Subsingleton.atBot_eq (Œ±) [Subsingleton Œ±] [Preorder Œ±] : (atBot : Filter Œ±) = ‚ä§ :=\n  @Subsingleton.atTop_eq Œ±·µí·µà _ _\n\n"}
{"name":"Filter.tendsto_atTop_pure","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : PartialOrder Œ±\ninst‚úù : OrderTop Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Filter.Tendsto f Filter.atTop (Pure.pure (f Top.top))","decl":"theorem tendsto_atTop_pure [PartialOrder Œ±] [OrderTop Œ±] (f : Œ± ‚Üí Œ≤) :\n    Tendsto f atTop (pure <| f ‚ä§) :=\n  (OrderTop.atTop_eq Œ±).symm ‚ñ∏ tendsto_pure_pure _ _\n\n"}
{"name":"Filter.tendsto_atBot_pure","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : PartialOrder Œ±\ninst‚úù : OrderBot Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Filter.Tendsto f Filter.atBot (Pure.pure (f Bot.bot))","decl":"theorem tendsto_atBot_pure [PartialOrder Œ±] [OrderBot Œ±] (f : Œ± ‚Üí Œ≤) :\n    Tendsto f atBot (pure <| f ‚ä•) :=\n  @tendsto_atTop_pure Œ±·µí·µà _ _ _ _\n\n"}
{"name":"Filter.atTop_eq_generate_Ici","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\n‚ä¢ Eq Filter.atTop (Filter.generate (Set.range Set.Ici))","decl":"theorem atTop_eq_generate_Ici [Preorder Œ±] : atTop = generate (range (Ici (Œ± := Œ±))) := by\n  simp only [generate_eq_biInf, atTop, iInf_range]\n\n"}
{"name":"Filter.Frequently.forall_exists_of_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\np : Œ± ‚Üí Prop\nh : Filter.Frequently (fun x => p x) Filter.atTop\na : Œ±\n‚ä¢ Exists fun b => And (GE.ge b a) (p b)","decl":"theorem Frequently.forall_exists_of_atTop [Preorder Œ±] {p : Œ± ‚Üí Prop}\n    (h : ‚àÉ·∂† x in atTop, p x) (a : Œ±) : ‚àÉ b ‚â• a, p b := by\n  rw [Filter.Frequently] at h\n  contrapose! h\n  exact (eventually_ge_atTop a).mono h\n\n"}
{"name":"Filter.Frequently.forall_exists_of_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\np : Œ± ‚Üí Prop\nh : Filter.Frequently (fun x => p x) Filter.atBot\na : Œ±\n‚ä¢ Exists fun b => And (LE.le b a) (p b)","decl":"theorem Frequently.forall_exists_of_atBot [Preorder Œ±] {p : Œ± ‚Üí Prop}\n    (h : ‚àÉ·∂† x in atBot, p x) (a : Œ±) : ‚àÉ b ‚â§ a, p b :=\n  Frequently.forall_exists_of_atTop (Œ± := Œ±·µí·µà) h _\n\n"}
{"name":"Filter.hasAntitoneBasis_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty Œ±\n‚ä¢ Filter.atTop.HasAntitoneBasis Set.Ici","decl":"theorem hasAntitoneBasis_atTop [Nonempty Œ±] : (@atTop Œ± _).HasAntitoneBasis Ici :=\n  .iInf_principal fun _ _ ‚Ü¶ Ici_subset_Ici.2\n\n"}
{"name":"Filter.atTop_basis","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty Œ±\n‚ä¢ Filter.atTop.HasBasis (fun x => True) Set.Ici","decl":"theorem atTop_basis [Nonempty Œ±] : (@atTop Œ± _).HasBasis (fun _ => True) Ici :=\n  hasAntitoneBasis_atTop.1\n\n"}
{"name":"Filter.atTop_basis_Ioi","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : NoMaxOrder Œ±\n‚ä¢ Filter.atTop.HasBasis (fun x => True) Set.Ioi","decl":"lemma atTop_basis_Ioi [Nonempty Œ±] [NoMaxOrder Œ±] : (@atTop Œ± _).HasBasis (fun _ => True) Ioi :=\n  atTop_basis.to_hasBasis (fun a ha => ‚ü®a, ha, Ioi_subset_Ici_self‚ü©) fun a ha =>\n    (exists_gt a).imp fun _b hb => ‚ü®ha, Ici_subset_Ioi.2 hb‚ü©\n\n"}
{"name":"Filter.atTop_basis_Ioi'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù : NoMaxOrder Œ±\na : Œ±\n‚ä¢ Filter.atTop.HasBasis (fun x => LT.lt a x) Set.Ioi","decl":"lemma atTop_basis_Ioi' [NoMaxOrder Œ±] (a : Œ±) : atTop.HasBasis (a < ¬∑) Ioi := by\n  have : Nonempty Œ± := ‚ü®a‚ü©\n  refine atTop_basis_Ioi.to_hasBasis (fun b _ ‚Ü¶ ?_) fun b _ ‚Ü¶ ‚ü®b, trivial, Subset.rfl‚ü©\n  obtain ‚ü®c, hac, hbc‚ü© := exists_ge_ge a b\n  obtain ‚ü®d, hcd‚ü© := exists_gt c\n  exact ‚ü®d, hac.trans_lt hcd, Ioi_subset_Ioi (hbc.trans hcd.le)‚ü©\n\n"}
{"name":"Filter.atTop_basis'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\na : Œ±\n‚ä¢ Filter.atTop.HasBasis (fun x => LE.le a x) Set.Ici","decl":"theorem atTop_basis' (a : Œ±) : atTop.HasBasis (a ‚â§ ¬∑) Ici := by\n  have : Nonempty Œ± := ‚ü®a‚ü©\n  refine atTop_basis.to_hasBasis (fun b _ ‚Ü¶ ?_) fun b _ ‚Ü¶ ‚ü®b, trivial, Subset.rfl‚ü©\n  obtain ‚ü®c, hac, hbc‚ü© := exists_ge_ge a b\n  exact ‚ü®c, hac, Ici_subset_Ici.2 hbc‚ü©\n\n"}
{"name":"Filter.atTop_neBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty Œ±\n‚ä¢ Filter.atTop.NeBot","decl":"@[instance]\nlemma atTop_neBot : NeBot (atTop : Filter Œ±) := atTop_basis.neBot_iff.2 fun _ => nonempty_Ici\n\n"}
{"name":"Filter.atTop_neBot_iff","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_6\ninst‚úù : Preorder Œ±\n‚ä¢ Iff Filter.atTop.NeBot (And (Nonempty Œ±) (IsDirected Œ± fun x1 x2 => LE.le x1 x2))","decl":"theorem atTop_neBot_iff {Œ± : Type*} [Preorder Œ±] :\n    (atTop : Filter Œ±).NeBot ‚Üî Nonempty Œ± ‚àß IsDirected Œ± (¬∑ ‚â§ ¬∑) := by\n  refine ‚ü®fun h ‚Ü¶ ‚ü®nonempty_of_neBot atTop, ‚ü®fun x y ‚Ü¶ ?_‚ü©‚ü©, fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ atTop_neBot‚ü©\n  exact ((eventually_ge_atTop x).and (eventually_ge_atTop y)).exists\n\n"}
{"name":"Filter.atBot_neBot_iff","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_6\ninst‚úù : Preorder Œ±\n‚ä¢ Iff Filter.atBot.NeBot (And (Nonempty Œ±) (IsDirected Œ± fun x1 x2 => GE.ge x1 x2))","decl":"theorem atBot_neBot_iff {Œ± : Type*} [Preorder Œ±] :\n    (atBot : Filter Œ±).NeBot ‚Üî Nonempty Œ± ‚àß IsDirected Œ± (¬∑ ‚â• ¬∑) :=\n  atTop_neBot_iff (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.mem_atTop_sets","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem Filter.atTop s) (Exists fun a => ‚àÄ (b : Œ±), GE.ge b a ‚Üí Membership.mem s b)","decl":"@[simp] lemma mem_atTop_sets {s : Set Œ±} : s ‚àà (atTop : Filter Œ±) ‚Üî ‚àÉ a : Œ±, ‚àÄ b ‚â• a, b ‚àà s :=\n  atTop_basis.mem_iff.trans <| exists_congr fun _ => iff_of_eq (true_and _)\n\n"}
{"name":"Filter.eventually_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\np : Œ± ‚Üí Prop\ninst‚úù : Nonempty Œ±\n‚ä¢ Iff (Filter.Eventually (fun x => p x) Filter.atTop) (Exists fun a => ‚àÄ (b : Œ±), GE.ge b a ‚Üí p b)","decl":"@[simp] lemma eventually_atTop : (‚àÄ·∂† x in atTop, p x) ‚Üî ‚àÉ a, ‚àÄ b ‚â• a, p b := mem_atTop_sets\n\n"}
{"name":"Filter.frequently_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\np : Œ± ‚Üí Prop\ninst‚úù : Nonempty Œ±\n‚ä¢ Iff (Filter.Frequently (fun x => p x) Filter.atTop) (‚àÄ (a : Œ±), Exists fun b => And (GE.ge b a) (p b))","decl":"theorem frequently_atTop : (‚àÉ·∂† x in atTop, p x) ‚Üî ‚àÄ a, ‚àÉ b ‚â• a, p b :=\n  atTop_basis.frequently_iff.trans <| by simp\n\n"}
{"name":"Filter.Eventually.exists_forall_of_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\np : Œ± ‚Üí Prop\ninst‚úù : Nonempty Œ±\na‚úù : Filter.Eventually (fun x => p x) Filter.atTop\n‚ä¢ Exists fun a => ‚àÄ (b : Œ±), GE.ge b a ‚Üí p b","decl":"alias ‚ü®Eventually.exists_forall_of_atTop, _‚ü© := eventually_atTop\n\n"}
{"name":"Filter.exists_eventually_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty Œ±\nr : Œ± ‚Üí Œ≤ ‚Üí Prop\n‚ä¢ Iff (Exists fun b => Filter.Eventually (fun a => r a b) Filter.atTop) (Filter.Eventually (fun a‚ÇÄ => Exists fun b => ‚àÄ (a : Œ±), GE.ge a a‚ÇÄ ‚Üí r a b) Filter.atTop)","decl":"lemma exists_eventually_atTop {r : Œ± ‚Üí Œ≤ ‚Üí Prop} :\n    (‚àÉ b, ‚àÄ·∂† a in atTop, r a b) ‚Üî ‚àÄ·∂† a‚ÇÄ in atTop, ‚àÉ b, ‚àÄ a ‚â• a‚ÇÄ, r a b := by\n  simp_rw [eventually_atTop, ‚Üê exists_swap (Œ± := Œ±)]\n  exact exists_congr fun a ‚Ü¶ .symm <| forall_ge_iff <| Monotone.exists fun _ _ _ hb H n hn ‚Ü¶\n    H n (hb.trans hn)\n\n"}
{"name":"Filter.map_atTop_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Eq (Filter.map f Filter.atTop) (iInf fun a => Filter.principal (Set.image f (setOf fun a' => LE.le a a')))","decl":"theorem map_atTop_eq {f : Œ± ‚Üí Œ≤} : atTop.map f = ‚®Ö a, ùìü (f '' { a' | a ‚â§ a' }) :=\n  (atTop_basis.map f).eq_iInf\n\n"}
{"name":"Filter.frequently_atTop'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => LE.le x1 x2\np : Œ± ‚Üí Prop\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : NoMaxOrder Œ±\n‚ä¢ Iff (Filter.Frequently (fun x => p x) Filter.atTop) (‚àÄ (a : Œ±), Exists fun b => And (GT.gt b a) (p b))","decl":"theorem frequently_atTop' [NoMaxOrder Œ±] : (‚àÉ·∂† x in atTop, p x) ‚Üî ‚àÄ a, ‚àÉ b > a, p b :=\n  atTop_basis_Ioi.frequently_iff.trans <| by simp\n\n"}
{"name":"Filter.atBot_basis_Iio","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : NoMinOrder Œ±\n‚ä¢ Filter.atBot.HasBasis (fun x => True) Set.Iio","decl":"lemma atBot_basis_Iio [Nonempty Œ±] [NoMinOrder Œ±] : (@atBot Œ± _).HasBasis (fun _ => True) Iio :=\n  atTop_basis_Ioi (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.atBot_basis_Iio'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù : NoMinOrder Œ±\na : Œ±\n‚ä¢ Filter.atBot.HasBasis (fun x => LT.lt x a) Set.Iio","decl":"lemma atBot_basis_Iio' [NoMinOrder Œ±] (a : Œ±) : atBot.HasBasis (¬∑ < a) Iio :=\n  atTop_basis_Ioi' (Œ± := Œ±·µí·µà) a\n\n"}
{"name":"Filter.atBot_basis'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\na : Œ±\n‚ä¢ Filter.atBot.HasBasis (fun x => LE.le x a) Set.Iic","decl":"lemma atBot_basis' (a : Œ±) : (@atBot Œ± _).HasBasis (fun x => x ‚â§ a) Iic := atTop_basis' (Œ± := Œ±·µí·µà) _\n\n"}
{"name":"Filter.atBot_basis","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù : Nonempty Œ±\n‚ä¢ Filter.atBot.HasBasis (fun x => True) Set.Iic","decl":"lemma atBot_basis : (@atBot Œ± _).HasBasis (fun _ => True) Iic := atTop_basis (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.atBot_neBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù : Nonempty Œ±\n‚ä¢ Filter.atBot.NeBot","decl":"@[instance] lemma atBot_neBot : NeBot (atBot : Filter Œ±) := atTop_neBot (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.mem_atBot_sets","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù : Nonempty Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem Filter.atBot s) (Exists fun a => ‚àÄ (b : Œ±), LE.le b a ‚Üí Membership.mem s b)","decl":"@[simp] lemma mem_atBot_sets {s : Set Œ±} : s ‚àà (atBot : Filter Œ±) ‚Üî ‚àÉ a : Œ±, ‚àÄ b ‚â§ a, b ‚àà s :=\n  mem_atTop_sets (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.eventually_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\np : Œ± ‚Üí Prop\ninst‚úù : Nonempty Œ±\n‚ä¢ Iff (Filter.Eventually (fun x => p x) Filter.atBot) (Exists fun a => ‚àÄ (b : Œ±), LE.le b a ‚Üí p b)","decl":"@[simp] lemma eventually_atBot : (‚àÄ·∂† x in atBot, p x) ‚Üî ‚àÉ a, ‚àÄ b ‚â§ a, p b := mem_atBot_sets\n\n"}
{"name":"Filter.frequently_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\np : Œ± ‚Üí Prop\ninst‚úù : Nonempty Œ±\n‚ä¢ Iff (Filter.Frequently (fun x => p x) Filter.atBot) (‚àÄ (a : Œ±), Exists fun b => And (LE.le b a) (p b))","decl":"theorem frequently_atBot : (‚àÉ·∂† x in atBot, p x) ‚Üî ‚àÄ a, ‚àÉ b ‚â§ a, p b := frequently_atTop (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.Eventually.exists_forall_of_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\np : Œ± ‚Üí Prop\ninst‚úù : Nonempty Œ±\na‚úù : Filter.Eventually (fun x => p x) Filter.atBot\n‚ä¢ Exists fun a => ‚àÄ (b : Œ±), LE.le b a ‚Üí p b","decl":"alias ‚ü®Eventually.exists_forall_of_atBot, _‚ü© := eventually_atBot\n\n"}
{"name":"Filter.exists_eventually_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù : Nonempty Œ±\nr : Œ± ‚Üí Œ≤ ‚Üí Prop\n‚ä¢ Iff (Exists fun b => Filter.Eventually (fun a => r a b) Filter.atBot) (Filter.Eventually (fun a‚ÇÄ => Exists fun b => ‚àÄ (a : Œ±), LE.le a a‚ÇÄ ‚Üí r a b) Filter.atBot)","decl":"lemma exists_eventually_atBot {r : Œ± ‚Üí Œ≤ ‚Üí Prop} :\n    (‚àÉ b, ‚àÄ·∂† a in atBot, r a b) ‚Üî ‚àÄ·∂† a‚ÇÄ in atBot, ‚àÉ b, ‚àÄ a ‚â§ a‚ÇÄ, r a b :=\n  exists_eventually_atTop (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.map_atBot_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù : Nonempty Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Eq (Filter.map f Filter.atBot) (iInf fun a => Filter.principal (Set.image f (setOf fun a' => LE.le a' a)))","decl":"theorem map_atBot_eq {f : Œ± ‚Üí Œ≤} : atBot.map f = ‚®Ö a, ùìü (f '' { a' | a' ‚â§ a }) :=\n  map_atTop_eq (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.frequently_atBot'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\np : Œ± ‚Üí Prop\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : NoMinOrder Œ±\n‚ä¢ Iff (Filter.Frequently (fun x => p x) Filter.atBot) (‚àÄ (a : Œ±), Exists fun b => And (LT.lt b a) (p b))","decl":"theorem frequently_atBot' [NoMinOrder Œ±] : (‚àÉ·∂† x in atBot, p x) ‚Üî ‚àÄ a, ‚àÉ b < a, p b :=\n  frequently_atTop' (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù : Preorder Œ≤\nm : Œ± ‚Üí Œ≤\nf : Filter Œ±\n‚ä¢ Iff (Filter.Tendsto m f Filter.atTop) (‚àÄ (b : Œ≤), Filter.Eventually (fun a => LE.le b (m a)) f)","decl":"theorem tendsto_atTop [Preorder Œ≤] {m : Œ± ‚Üí Œ≤} {f : Filter Œ±} :\n    Tendsto m f atTop ‚Üî ‚àÄ b, ‚àÄ·∂† a in f, b ‚â§ m a := by\n  simp only [atTop, tendsto_iInf, tendsto_principal, mem_Ici]\n\n"}
{"name":"Filter.tendsto_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù : Preorder Œ≤\nm : Œ± ‚Üí Œ≤\nf : Filter Œ±\n‚ä¢ Iff (Filter.Tendsto m f Filter.atBot) (‚àÄ (b : Œ≤), Filter.Eventually (fun a => LE.le (m a) b) f)","decl":"theorem tendsto_atBot [Preorder Œ≤] {m : Œ± ‚Üí Œ≤} {f : Filter Œ±} :\n    Tendsto m f atBot ‚Üî ‚àÄ b, ‚àÄ·∂† a in f, m a ‚â§ b :=\n  @tendsto_atTop Œ± Œ≤·µí·µà _ m f\n\n"}
{"name":"Filter.tendsto_atTop_mono'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù : Preorder Œ≤\nl : Filter Œ±\nf‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤\nh : l.EventuallyLE f‚ÇÅ f‚ÇÇ\nh‚ÇÅ : Filter.Tendsto f‚ÇÅ l Filter.atTop\n‚ä¢ Filter.Tendsto f‚ÇÇ l Filter.atTop","decl":"theorem tendsto_atTop_mono' [Preorder Œ≤] (l : Filter Œ±) ‚¶Éf‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤‚¶Ñ (h : f‚ÇÅ ‚â§·∂†[l] f‚ÇÇ)\n    (h‚ÇÅ : Tendsto f‚ÇÅ l atTop) : Tendsto f‚ÇÇ l atTop :=\n  tendsto_atTop.2 fun b => by filter_upwards [tendsto_atTop.1 h‚ÇÅ b, h] with x using le_trans\n\n"}
{"name":"Filter.tendsto_atBot_mono'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù : Preorder Œ≤\nl : Filter Œ±\nf‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤\nh : l.EventuallyLE f‚ÇÅ f‚ÇÇ\na‚úù : Filter.Tendsto f‚ÇÇ l Filter.atBot\n‚ä¢ Filter.Tendsto f‚ÇÅ l Filter.atBot","decl":"theorem tendsto_atBot_mono' [Preorder Œ≤] (l : Filter Œ±) ‚¶Éf‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤‚¶Ñ (h : f‚ÇÅ ‚â§·∂†[l] f‚ÇÇ) :\n    Tendsto f‚ÇÇ l atBot ‚Üí Tendsto f‚ÇÅ l atBot :=\n  @tendsto_atTop_mono' _ Œ≤·µí·µà _ _ _ _ h\n\n"}
{"name":"Filter.tendsto_atTop_mono","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù : Preorder Œ≤\nl : Filter Œ±\nf g : Œ± ‚Üí Œ≤\nh : ‚àÄ (n : Œ±), LE.le (f n) (g n)\na‚úù : Filter.Tendsto f l Filter.atTop\n‚ä¢ Filter.Tendsto g l Filter.atTop","decl":"theorem tendsto_atTop_mono [Preorder Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (h : ‚àÄ n, f n ‚â§ g n) :\n    Tendsto f l atTop ‚Üí Tendsto g l atTop :=\n  tendsto_atTop_mono' l <| Eventually.of_forall h\n\n"}
{"name":"Filter.tendsto_atBot_mono","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù : Preorder Œ≤\nl : Filter Œ±\nf g : Œ± ‚Üí Œ≤\nh : ‚àÄ (n : Œ±), LE.le (f n) (g n)\na‚úù : Filter.Tendsto g l Filter.atBot\n‚ä¢ Filter.Tendsto f l Filter.atBot","decl":"theorem tendsto_atBot_mono [Preorder Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (h : ‚àÄ n, f n ‚â§ g n) :\n    Tendsto g l atBot ‚Üí Tendsto f l atBot :=\n  @tendsto_atTop_mono _ Œ≤·µí·µà _ _ _ _ h\n\n"}
{"name":"Filter.atTop_eq_generate_of_forall_exists_le","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : LinearOrder Œ±\ns : Set Œ±\nhs : ‚àÄ (x : Œ±), Exists fun y => And (Membership.mem s y) (LE.le x y)\n‚ä¢ Eq Filter.atTop (Filter.generate (Set.image Set.Ici s))","decl":"lemma atTop_eq_generate_of_forall_exists_le [LinearOrder Œ±] {s : Set Œ±} (hs : ‚àÄ x, ‚àÉ y ‚àà s, x ‚â§ y) :\n    (atTop : Filter Œ±) = generate (Ici '' s) := by\n  rw [atTop_eq_generate_Ici]\n  apply le_antisymm\n  ¬∑ rw [le_generate_iff]\n    rintro - ‚ü®y, -, rfl‚ü©\n    exact mem_generate_of_mem ‚ü®y, rfl‚ü©\n  ¬∑ rw [le_generate_iff]\n    rintro - ‚ü®x, -, -, rfl‚ü©\n    rcases hs x with ‚ü®y, ys, hy‚ü©\n    have A : Ici y ‚àà generate (Ici '' s) := mem_generate_of_mem (mem_image_of_mem _ ys)\n    have B : Ici y ‚äÜ Ici x := Ici_subset_Ici.2 hy\n    exact sets_of_superset (generate (Ici '' s)) A B\n\n"}
{"name":"Filter.atTop_eq_generate_of_not_bddAbove","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : LinearOrder Œ±\ns : Set Œ±\nhs : Not (BddAbove s)\n‚ä¢ Eq Filter.atTop (Filter.generate (Set.image Set.Ici s))","decl":"lemma atTop_eq_generate_of_not_bddAbove [LinearOrder Œ±] {s : Set Œ±} (hs : ¬¨ BddAbove s) :\n    (atTop : Filter Œ±) = generate (Ici '' s) := by\n  refine atTop_eq_generate_of_forall_exists_le fun x ‚Ü¶ ?_\n  obtain ‚ü®y, hy, hy'‚ü© := not_bddAbove_iff.mp hs x\n  exact ‚ü®y, hy, hy'.le‚ü©\n\n"}
{"name":"OrderIso.comap_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\ne : OrderIso Œ± Œ≤\n‚ä¢ Eq (Filter.comap (‚áëe) Filter.atTop) Filter.atTop","decl":"@[simp]\ntheorem comap_atTop (e : Œ± ‚âÉo Œ≤) : comap e atTop = atTop := by\n  simp [atTop, ‚Üê e.surjective.iInf_comp]\n\n"}
{"name":"OrderIso.comap_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\ne : OrderIso Œ± Œ≤\n‚ä¢ Eq (Filter.comap (‚áëe) Filter.atBot) Filter.atBot","decl":"@[simp]\ntheorem comap_atBot (e : Œ± ‚âÉo Œ≤) : comap e atBot = atBot :=\n  e.dual.comap_atTop\n\n"}
{"name":"OrderIso.map_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\ne : OrderIso Œ± Œ≤\n‚ä¢ Eq (Filter.map (‚áëe) Filter.atTop) Filter.atTop","decl":"@[simp]\ntheorem map_atTop (e : Œ± ‚âÉo Œ≤) : map (e : Œ± ‚Üí Œ≤) atTop = atTop := by\n  rw [‚Üê e.comap_atTop, map_comap_of_surjective e.surjective]\n\n"}
{"name":"OrderIso.map_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\ne : OrderIso Œ± Œ≤\n‚ä¢ Eq (Filter.map (‚áëe) Filter.atBot) Filter.atBot","decl":"@[simp]\ntheorem map_atBot (e : Œ± ‚âÉo Œ≤) : map (e : Œ± ‚Üí Œ≤) atBot = atBot :=\n  e.dual.map_atTop\n\n"}
{"name":"OrderIso.tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\ne : OrderIso Œ± Œ≤\n‚ä¢ Filter.Tendsto (‚áëe) Filter.atTop Filter.atTop","decl":"theorem tendsto_atTop (e : Œ± ‚âÉo Œ≤) : Tendsto e atTop atTop :=\n  e.map_atTop.le\n\n"}
{"name":"OrderIso.tendsto_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\ne : OrderIso Œ± Œ≤\n‚ä¢ Filter.Tendsto (‚áëe) Filter.atBot Filter.atBot","decl":"theorem tendsto_atBot (e : Œ± ‚âÉo Œ≤) : Tendsto e atBot atBot :=\n  e.map_atBot.le\n\n"}
{"name":"OrderIso.tendsto_atTop_iff","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\nl : Filter Œ≥\nf : Œ≥ ‚Üí Œ±\ne : OrderIso Œ± Œ≤\n‚ä¢ Iff (Filter.Tendsto (fun x => e (f x)) l Filter.atTop) (Filter.Tendsto f l Filter.atTop)","decl":"@[simp]\ntheorem tendsto_atTop_iff {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} (e : Œ± ‚âÉo Œ≤) :\n    Tendsto (fun x => e (f x)) l atTop ‚Üî Tendsto f l atTop := by\n  rw [‚Üê e.comap_atTop, tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"OrderIso.tendsto_atBot_iff","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\nl : Filter Œ≥\nf : Œ≥ ‚Üí Œ±\ne : OrderIso Œ± Œ≤\n‚ä¢ Iff (Filter.Tendsto (fun x => e (f x)) l Filter.atBot) (Filter.Tendsto f l Filter.atBot)","decl":"@[simp]\ntheorem tendsto_atBot_iff {l : Filter Œ≥} {f : Œ≥ ‚Üí Œ±} (e : Œ± ‚âÉo Œ≤) :\n    Tendsto (fun x => e (f x)) l atBot ‚Üî Tendsto f l atBot :=\n  e.dual.tendsto_atTop_iff\n\n"}
{"name":"Filter.extraction_of_frequently_atTop'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"P : Nat ‚Üí Prop\nh : ‚àÄ (N : Nat), Exists fun n => And (GT.gt n N) (P n)\n‚ä¢ Exists fun œÜ => And (StrictMono œÜ) (‚àÄ (n : Nat), P (œÜ n))","decl":"theorem extraction_of_frequently_atTop' {P : ‚Ñï ‚Üí Prop} (h : ‚àÄ N, ‚àÉ n > N, P n) :\n    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P (œÜ n) := by\n  choose u hu hu' using h\n  refine ‚ü®fun n => u^[n + 1] 0, strictMono_nat_of_lt_succ fun n => ?_, fun n => ?_‚ü©\n  ¬∑ exact Trans.trans (hu _) (Function.iterate_succ_apply' _ _ _).symm\n  ¬∑ simpa only [Function.iterate_succ_apply'] using hu' _\n\n"}
{"name":"Filter.extraction_of_frequently_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"P : Nat ‚Üí Prop\nh : Filter.Frequently (fun n => P n) Filter.atTop\n‚ä¢ Exists fun œÜ => And (StrictMono œÜ) (‚àÄ (n : Nat), P (œÜ n))","decl":"theorem extraction_of_frequently_atTop {P : ‚Ñï ‚Üí Prop} (h : ‚àÉ·∂† n in atTop, P n) :\n    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P (œÜ n) := by\n  rw [frequently_atTop'] at h\n  exact extraction_of_frequently_atTop' h\n\n"}
{"name":"Filter.extraction_of_eventually_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"P : Nat ‚Üí Prop\nh : Filter.Eventually (fun n => P n) Filter.atTop\n‚ä¢ Exists fun œÜ => And (StrictMono œÜ) (‚àÄ (n : Nat), P (œÜ n))","decl":"theorem extraction_of_eventually_atTop {P : ‚Ñï ‚Üí Prop} (h : ‚àÄ·∂† n in atTop, P n) :\n    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P (œÜ n) :=\n  extraction_of_frequently_atTop h.frequently\n\n"}
{"name":"Filter.extraction_forall_of_frequently","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"P : Nat ‚Üí Nat ‚Üí Prop\nh : ‚àÄ (n : Nat), Filter.Frequently (fun k => P n k) Filter.atTop\n‚ä¢ Exists fun œÜ => And (StrictMono œÜ) (‚àÄ (n : Nat), P n (œÜ n))","decl":"theorem extraction_forall_of_frequently {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÉ·∂† k in atTop, P n k) :\n    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P n (œÜ n) := by\n  simp only [frequently_atTop'] at h\n  choose u hu hu' using h\n  use (fun n => Nat.recOn n (u 0 0) fun n v => u (n + 1) v : ‚Ñï ‚Üí ‚Ñï)\n  constructor\n  ¬∑ apply strictMono_nat_of_lt_succ\n    intro n\n    apply hu\n  ¬∑ intro n\n    cases n <;> simp [hu']\n\n"}
{"name":"Filter.extraction_forall_of_eventually","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"P : Nat ‚Üí Nat ‚Üí Prop\nh : ‚àÄ (n : Nat), Filter.Eventually (fun k => P n k) Filter.atTop\n‚ä¢ Exists fun œÜ => And (StrictMono œÜ) (‚àÄ (n : Nat), P n (œÜ n))","decl":"theorem extraction_forall_of_eventually {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÄ·∂† k in atTop, P n k) :\n    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P n (œÜ n) :=\n  extraction_forall_of_frequently fun n => (h n).frequently\n\n"}
{"name":"Filter.extraction_forall_of_eventually'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"P : Nat ‚Üí Nat ‚Üí Prop\nh : ‚àÄ (n : Nat), Exists fun N => ‚àÄ (k : Nat), GE.ge k N ‚Üí P n k\n‚ä¢ Exists fun œÜ => And (StrictMono œÜ) (‚àÄ (n : Nat), P n (œÜ n))","decl":"theorem extraction_forall_of_eventually' {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÉ N, ‚àÄ k ‚â• N, P n k) :\n    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, P n (œÜ n) :=\n  extraction_forall_of_eventually (by simp [eventually_atTop, h])\n\n"}
{"name":"Filter.Eventually.atTop_of_arithmetic","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"p : Nat ‚Üí Prop\nn : Nat\nhn : Ne n 0\nhp : ‚àÄ (k : Nat), LT.lt k n ‚Üí Filter.Eventually (fun a => p (HAdd.hAdd (HMul.hMul n a) k)) Filter.atTop\n‚ä¢ Filter.Eventually (fun a => p a) Filter.atTop","decl":"theorem Eventually.atTop_of_arithmetic {p : ‚Ñï ‚Üí Prop} {n : ‚Ñï} (hn : n ‚â† 0)\n    (hp : ‚àÄ k < n, ‚àÄ·∂† a in atTop, p (n * a + k)) : ‚àÄ·∂† a in atTop, p a := by\n  simp only [eventually_atTop] at hp ‚ä¢\n  choose! N hN using hp\n  refine ‚ü®(Finset.range n).sup (n * N ¬∑), fun b hb => ?_‚ü©\n  rw [‚Üê Nat.div_add_mod b n]\n  have hlt := Nat.mod_lt b hn.bot_lt\n  refine hN _ hlt _ ?_\n  rw [ge_iff_le, Nat.le_div_iff_mul_le hn.bot_lt, mul_comm]\n  exact (Finset.le_sup (f := (n * N ¬∑)) (Finset.mem_range.2 hlt)).trans hb\n\n"}
{"name":"Filter.inf_map_atTop_neBot_iff","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nF : Filter Œ≤\nu : Œ± ‚Üí Œ≤\ninst‚úù : Nonempty Œ±\n‚ä¢ Iff (Min.min F (Filter.map u Filter.atTop)).NeBot (‚àÄ (U : Set Œ≤), Membership.mem F U ‚Üí ‚àÄ (N : Œ±), Exists fun n => And (GE.ge n N) (Membership.mem U (u n)))","decl":"theorem inf_map_atTop_neBot_iff [Nonempty Œ±] :\n    NeBot (F ‚äì map u atTop) ‚Üî ‚àÄ U ‚àà F, ‚àÄ N, ‚àÉ n ‚â• N, u n ‚àà U := by\n  simp_rw [inf_neBot_iff_frequently_left, frequently_map, frequently_atTop]; rfl\n\n"}
{"name":"Filter.exists_le_of_tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nu : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œ≤\nh : Filter.Tendsto u Filter.atTop Filter.atTop\na : Œ±\nb : Œ≤\n‚ä¢ Exists fun a' => And (GE.ge a' a) (LE.le b (u a'))","decl":"lemma exists_le_of_tendsto_atTop (h : Tendsto u atTop atTop) (a : Œ±) (b : Œ≤) :\n    ‚àÉ a' ‚â• a, b ‚â§ u a' := by\n  have : Nonempty Œ± := ‚ü®a‚ü©\n  have : ‚àÄ·∂† x in atTop, a ‚â§ x ‚àß b ‚â§ u x :=\n    (eventually_ge_atTop a).and (h.eventually <| eventually_ge_atTop b)\n  exact this.exists\n\n-- @[nolint ge_or_gt] -- Porting note: restore attribute\n"}
{"name":"Filter.exists_le_of_tendsto_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nu : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œ≤\nh : Filter.Tendsto u Filter.atTop Filter.atBot\na : Œ±\nb : Œ≤\n‚ä¢ Exists fun a' => And (GE.ge a' a) (LE.le (u a') b)","decl":"theorem exists_le_of_tendsto_atBot (h : Tendsto u atTop atBot) :\n    ‚àÄ a b, ‚àÉ a' ‚â• a, u a' ‚â§ b := exists_le_of_tendsto_atTop (Œ≤ := Œ≤·µí·µà) h\n\n"}
{"name":"Filter.exists_lt_of_tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nu : Œ± ‚Üí Œ≤\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : NoMaxOrder Œ≤\nh : Filter.Tendsto u Filter.atTop Filter.atTop\na : Œ±\nb : Œ≤\n‚ä¢ Exists fun a' => And (GE.ge a' a) (LT.lt b (u a'))","decl":"theorem exists_lt_of_tendsto_atTop [NoMaxOrder Œ≤] (h : Tendsto u atTop atTop) (a : Œ±) (b : Œ≤) :\n    ‚àÉ a' ‚â• a, b < u a' := by\n  cases' exists_gt b with b' hb'\n  rcases exists_le_of_tendsto_atTop h a b' with ‚ü®a', ha', ha''‚ü©\n  exact ‚ü®a', ha', lt_of_lt_of_le hb' ha''‚ü©\n\n-- @[nolint ge_or_gt] -- Porting note: restore attribute\n"}
{"name":"Filter.exists_lt_of_tendsto_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nu : Œ± ‚Üí Œ≤\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : NoMinOrder Œ≤\nh : Filter.Tendsto u Filter.atTop Filter.atBot\na : Œ±\nb : Œ≤\n‚ä¢ Exists fun a' => And (GE.ge a' a) (LT.lt (u a') b)","decl":"theorem exists_lt_of_tendsto_atBot [NoMinOrder Œ≤] (h : Tendsto u atTop atBot) :\n    ‚àÄ a b, ‚àÉ a' ‚â• a, u a' < b := exists_lt_of_tendsto_atTop (Œ≤ := Œ≤·µí·µà) h\n\n"}
{"name":"Filter.inf_map_atBot_neBot_iff","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Nonempty Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\nF : Filter Œ≤\nu : Œ± ‚Üí Œ≤\n‚ä¢ Iff (Min.min F (Filter.map u Filter.atBot)).NeBot (‚àÄ (U : Set Œ≤), Membership.mem F U ‚Üí ‚àÄ (N : Œ±), Exists fun n => And (LE.le n N) (Membership.mem U (u n)))","decl":"theorem inf_map_atBot_neBot_iff : NeBot (F ‚äì map u atBot) ‚Üî ‚àÄ U ‚àà F, ‚àÄ N, ‚àÉ n ‚â§ N, u n ‚àà U :=\n  inf_map_atTop_neBot_iff (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.high_scores","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ≤ : Type u_4\ninst‚úù¬π : LinearOrder Œ≤\ninst‚úù : NoMaxOrder Œ≤\nu : Nat ‚Üí Œ≤\nhu : Filter.Tendsto u Filter.atTop Filter.atTop\nN : Nat\n‚ä¢ Exists fun n => And (GE.ge n N) (‚àÄ (k : Nat), LT.lt k n ‚Üí LT.lt (u k) (u n))","decl":"/-- If `u` is a sequence which is unbounded above,\nthen after any point, it reaches a value strictly greater than all previous values.\n-/\ntheorem high_scores [LinearOrder Œ≤] [NoMaxOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : Tendsto u atTop atTop) :\n    ‚àÄ N, ‚àÉ n ‚â• N, ‚àÄ k < n, u k < u n := by\n  intro N\n  obtain ‚ü®k : ‚Ñï, - : k ‚â§ N, hku : ‚àÄ l ‚â§ N, u l ‚â§ u k‚ü© : ‚àÉ k ‚â§ N, ‚àÄ l ‚â§ N, u l ‚â§ u k :=\n    exists_max_image _ u (finite_le_nat N) ‚ü®N, le_refl N‚ü©\n  have ex : ‚àÉ n ‚â• N, u k < u n := exists_lt_of_tendsto_atTop hu _ _\n  obtain ‚ü®n : ‚Ñï, hnN : n ‚â• N, hnk : u k < u n, hn_min : ‚àÄ m, m < n ‚Üí N ‚â§ m ‚Üí u m ‚â§ u k‚ü© :\n      ‚àÉ n ‚â• N, u k < u n ‚àß ‚àÄ m, m < n ‚Üí N ‚â§ m ‚Üí u m ‚â§ u k := by\n    rcases Nat.findX ex with ‚ü®n, ‚ü®hnN, hnk‚ü©, hn_min‚ü©\n    push_neg at hn_min\n    exact ‚ü®n, hnN, hnk, hn_min‚ü©\n  use n, hnN\n  rintro (l : ‚Ñï) (hl : l < n)\n  have hlk : u l ‚â§ u k := by\n    cases' (le_total l N : l ‚â§ N ‚à® N ‚â§ l) with H H\n    ¬∑ exact hku l H\n    ¬∑ exact hn_min l hl H\n  calc\n    u l ‚â§ u k := hlk\n    _ < u n := hnk\n\n-- see Note [nolint_ge]\n"}
{"name":"Filter.low_scores","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ≤ : Type u_4\ninst‚úù¬π : LinearOrder Œ≤\ninst‚úù : NoMinOrder Œ≤\nu : Nat ‚Üí Œ≤\nhu : Filter.Tendsto u Filter.atTop Filter.atBot\nN : Nat\n‚ä¢ Exists fun n => And (GE.ge n N) (‚àÄ (k : Nat), LT.lt k n ‚Üí LT.lt (u n) (u k))","decl":"/-- If `u` is a sequence which is unbounded below,\nthen after any point, it reaches a value strictly smaller than all previous values.\n-/\n-- @[nolint ge_or_gt] Porting note: restore attribute\ntheorem low_scores [LinearOrder Œ≤] [NoMinOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤} (hu : Tendsto u atTop atBot) :\n    ‚àÄ N, ‚àÉ n ‚â• N, ‚àÄ k < n, u n < u k :=\n  @high_scores Œ≤·µí·µà _ _ _ hu\n\n"}
{"name":"Filter.frequently_high_scores","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ≤ : Type u_4\ninst‚úù¬π : LinearOrder Œ≤\ninst‚úù : NoMaxOrder Œ≤\nu : Nat ‚Üí Œ≤\nhu : Filter.Tendsto u Filter.atTop Filter.atTop\n‚ä¢ Filter.Frequently (fun n => ‚àÄ (k : Nat), LT.lt k n ‚Üí LT.lt (u k) (u n)) Filter.atTop","decl":"/-- If `u` is a sequence which is unbounded above,\nthen it `Frequently` reaches a value strictly greater than all previous values.\n-/\ntheorem frequently_high_scores [LinearOrder Œ≤] [NoMaxOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤}\n    (hu : Tendsto u atTop atTop) : ‚àÉ·∂† n in atTop, ‚àÄ k < n, u k < u n := by\n  simpa [frequently_atTop] using high_scores hu\n\n"}
{"name":"Filter.frequently_low_scores","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ≤ : Type u_4\ninst‚úù¬π : LinearOrder Œ≤\ninst‚úù : NoMinOrder Œ≤\nu : Nat ‚Üí Œ≤\nhu : Filter.Tendsto u Filter.atTop Filter.atBot\n‚ä¢ Filter.Frequently (fun n => ‚àÄ (k : Nat), LT.lt k n ‚Üí LT.lt (u n) (u k)) Filter.atTop","decl":"/-- If `u` is a sequence which is unbounded below,\nthen it `Frequently` reaches a value strictly smaller than all previous values.\n-/\ntheorem frequently_low_scores [LinearOrder Œ≤] [NoMinOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤}\n    (hu : Tendsto u atTop atBot) : ‚àÉ·∂† n in atTop, ‚àÄ k < n, u n < u k :=\n  @frequently_high_scores Œ≤·µí·µà _ _ _ hu\n\n"}
{"name":"Filter.strictMono_subseq_of_tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ≤ : Type u_4\ninst‚úù¬π : LinearOrder Œ≤\ninst‚úù : NoMaxOrder Œ≤\nu : Nat ‚Üí Œ≤\nhu : Filter.Tendsto u Filter.atTop Filter.atTop\n‚ä¢ Exists fun œÜ => And (StrictMono œÜ) (StrictMono (Function.comp u œÜ))","decl":"theorem strictMono_subseq_of_tendsto_atTop [LinearOrder Œ≤] [NoMaxOrder Œ≤] {u : ‚Ñï ‚Üí Œ≤}\n    (hu : Tendsto u atTop atTop) : ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß StrictMono (u ‚àò œÜ) :=\n  let ‚ü®œÜ, h, h'‚ü© := extraction_of_frequently_atTop (frequently_high_scores hu)\n  ‚ü®œÜ, h, fun _ m hnm => h' m _ (h hnm)‚ü©\n\n"}
{"name":"Filter.strictMono_subseq_of_id_le","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"u : Nat ‚Üí Nat\nhu : ‚àÄ (n : Nat), LE.le n (u n)\n‚ä¢ Exists fun œÜ => And (StrictMono œÜ) (StrictMono (Function.comp u œÜ))","decl":"theorem strictMono_subseq_of_id_le {u : ‚Ñï ‚Üí ‚Ñï} (hu : ‚àÄ n, n ‚â§ u n) :\n    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß StrictMono (u ‚àò œÜ) :=\n  strictMono_subseq_of_tendsto_atTop (tendsto_atTop_mono hu tendsto_id)\n\n"}
{"name":"StrictMono.tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"œÜ : Nat ‚Üí Nat\nh : StrictMono œÜ\n‚ä¢ Filter.Tendsto œÜ Filter.atTop Filter.atTop","decl":"theorem _root_.StrictMono.tendsto_atTop {œÜ : ‚Ñï ‚Üí ‚Ñï} (h : StrictMono œÜ) : Tendsto œÜ atTop atTop :=\n  tendsto_atTop_mono h.id_le tendsto_id\n\n"}
{"name":"Monotone.upperBounds_range_comp_tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : Preorder Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Monotone f\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atTop\n‚ä¢ Eq (upperBounds (Set.range (Function.comp f g))) (upperBounds (Set.range f))","decl":"/-- If `f` is a monotone function and `g` tends to `atTop` along a nontrivial filter.\nthen the upper bounds of the range of `f ‚àò g`\nare the same as the upper bounds of the range of `f`.\n\nThis lemma together with `exists_seq_monotone_tendsto_atTop_atTop` below\nis useful to reduce a statement\nabout a monotone family indexed by a type with countably generated `atTop` (e.g., `‚Ñù`)\nto the case of a family indexed by natural numbers. -/\ntheorem _root_.Monotone.upperBounds_range_comp_tendsto_atTop [Preorder Œ≤] [Preorder Œ≥]\n    {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Monotone f) {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atTop) :\n    upperBounds (range (f ‚àò g)) = upperBounds (range f) := by\n  refine Subset.antisymm ?_ (upperBounds_mono_set <| range_comp_subset_range _ _)\n  rintro c hc _ ‚ü®b, rfl‚ü©\n  obtain ‚ü®a, ha‚ü© : ‚àÉ a, b ‚â§ g a := (hg.eventually_ge_atTop b).exists\n  exact (hf ha).trans <| hc <| mem_range_self _\n\n"}
{"name":"Monotone.lowerBounds_range_comp_tendsto_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : Preorder Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Monotone f\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atBot\n‚ä¢ Eq (lowerBounds (Set.range (Function.comp f g))) (lowerBounds (Set.range f))","decl":"/-- If `f` is a monotone function and `g` tends to `atBot` along a nontrivial filter.\nthen the lower bounds of the range of `f ‚àò g`\nare the same as the lower bounds of the range of `f`. -/\ntheorem _root_.Monotone.lowerBounds_range_comp_tendsto_atBot [Preorder Œ≤] [Preorder Œ≥]\n    {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Monotone f) {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atBot) :\n    lowerBounds (range (f ‚àò g)) = lowerBounds (range f) :=\n  hf.dual.upperBounds_range_comp_tendsto_atTop hg\n\n"}
{"name":"Antitone.lowerBounds_range_comp_tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : Preorder Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Antitone f\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atTop\n‚ä¢ Eq (lowerBounds (Set.range (Function.comp f g))) (lowerBounds (Set.range f))","decl":"/-- If `f` is an antitone function and `g` tends to `atTop` along a nontrivial filter.\nthen the upper bounds of the range of `f ‚àò g`\nare the same as the upper bounds of the range of `f`. -/\ntheorem _root_.Antitone.lowerBounds_range_comp_tendsto_atTop [Preorder Œ≤] [Preorder Œ≥]\n    {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Antitone f) {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atTop) :\n    lowerBounds (range (f ‚àò g)) = lowerBounds (range f) :=\n  hf.dual_left.lowerBounds_range_comp_tendsto_atBot hg\n\n"}
{"name":"Antitone.upperBounds_range_comp_tendsto_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : Preorder Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Antitone f\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atBot\n‚ä¢ Eq (upperBounds (Set.range (Function.comp f g))) (upperBounds (Set.range f))","decl":"/-- If `f` is an antitone function and `g` tends to `atBot` along a nontrivial filter.\nthen the upper bounds of the range of `f ‚àò g`\nare the same as the upper bounds of the range of `f`. -/\ntheorem _root_.Antitone.upperBounds_range_comp_tendsto_atBot [Preorder Œ≤] [Preorder Œ≥]\n    {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Antitone f) {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atBot) :\n    upperBounds (range (f ‚àò g)) = upperBounds (range f) :=\n  hf.dual.lowerBounds_range_comp_tendsto_atTop hg\n\n"}
{"name":"Monotone.ciSup_comp_tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : ConditionallyCompleteLattice Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Monotone f\nhb : BddAbove (Set.range f)\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atTop\n‚ä¢ Eq (iSup fun a => f (g a)) (iSup fun b => f b)","decl":"/-- If `f` is a monotone function with bounded range\nand `g` tends to `atTop` along a nontrivial filter,\nthen the indexed supremum of `f ‚àò g` is equal to the indexed supremum of `f`.\n\nThe assumption `BddAbove (range f)` can be omitted,\nif the codomain of `f` is a conditionally complete linear order or a complete lattice, see below.\n-/\ntheorem _root_.Monotone.ciSup_comp_tendsto_atTop [Preorder Œ≤] [ConditionallyCompleteLattice Œ≥]\n    {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Monotone f) (hb : BddAbove (range f))\n    {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atTop) : ‚®Ü a, f (g a) = ‚®Ü b, f b := by\n  have : Nonempty Œ± := nonempty_of_neBot l\n  have : Nonempty Œ≤ := .map g ‚Äπ_‚Ä∫\n  rw [‚Üê csInf_upperBounds_range, ‚Üê csInf_upperBounds_range,\n    ‚Üê hf.upperBounds_range_comp_tendsto_atTop hg, Function.comp_def]\n  exacts [hb, hb.mono <| range_comp_subset_range _ _]\n\n"}
{"name":"Monotone.ciInf_comp_tendsto_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : ConditionallyCompleteLattice Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Monotone f\nhb : BddBelow (Set.range f)\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atBot\n‚ä¢ Eq (iInf fun a => f (g a)) (iInf fun b => f b)","decl":"/-- If `f` is a monotone function with bounded range\nand `g` tends to `atBot` along a nontrivial filter,\nthen the indexed infimum of `f ‚àò g` is equal to the indexed infimum of `f`.\n\nThe assumption `BddBelow (range f)` can be omitted,\nif the codomain of `f` is a conditionally complete linear order or a complete lattice, see below.\n-/\ntheorem _root_.Monotone.ciInf_comp_tendsto_atBot [Preorder Œ≤] [ConditionallyCompleteLattice Œ≥]\n    {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Monotone f) (hb : BddBelow (range f))\n    {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atBot) : ‚®Ö a, f (g a) = ‚®Ö b, f b :=\n  hf.dual.ciSup_comp_tendsto_atTop hb hg\n\n"}
{"name":"Antitone.ciSup_comp_tendsto_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : ConditionallyCompleteLattice Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Antitone f\nhb : BddAbove (Set.range f)\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atBot\n‚ä¢ Eq (iSup fun a => f (g a)) (iSup fun b => f b)","decl":"/-- If `f` is an antitone function with bounded range\nand `g` tends to `atBot` along a nontrivial filter,\nthen the indexed supremum of `f ‚àò g` is equal to the indexed supremum of `f`.\n\nThe assumption `BddAbove (range f)` can be omitted,\nif the codomain of `f` is a conditionally complete linear order or a complete lattice, see below.\n-/\ntheorem _root_.Antitone.ciSup_comp_tendsto_atBot [Preorder Œ≤] [ConditionallyCompleteLattice Œ≥]\n    {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Antitone f) (hb : BddAbove (range f))\n    {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atBot) : ‚®Ü a, f (g a) = ‚®Ü b, f b :=\n  hf.dual_left.ciSup_comp_tendsto_atTop hb hg\n\n"}
{"name":"Antitone.ciInf_comp_tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : ConditionallyCompleteLattice Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Antitone f\nhb : BddBelow (Set.range f)\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atTop\n‚ä¢ Eq (iInf fun a => f (g a)) (iInf fun b => f b)","decl":"/-- If `f` is an antitone function with bounded range\nand `g` tends to `atTop` along a nontrivial filter,\nthen the indexed infimum of `f ‚àò g` is equal to the indexed infimum of `f`.\n\nThe assumption `BddBelow (range f)` can be omitted,\nif the codomain of `f` is a conditionally complete linear order or a complete lattice, see below.\n-/\ntheorem _root_.Antitone.ciInf_comp_tendsto_atTop [Preorder Œ≤] [ConditionallyCompleteLattice Œ≥]\n    {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Antitone f) (hb : BddBelow (range f))\n    {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atTop) : ‚®Ö a, f (g a) = ‚®Ö b, f b :=\n  hf.dual.ciSup_comp_tendsto_atBot hb hg\n\n"}
{"name":"Monotone.ciSup_comp_tendsto_atTop_of_linearOrder","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : ConditionallyCompleteLinearOrder Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Monotone f\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atTop\n‚ä¢ Eq (iSup fun a => f (g a)) (iSup fun b => f b)","decl":"/-- If `f` is a monotone function taking values in a conditionally complete linear order\nand `g` tends to `atTop` along a nontrivial filter,\nthen the indexed supremum of `f ‚àò g` is equal to the indexed supremum of `f`. -/\ntheorem _root_.Monotone.ciSup_comp_tendsto_atTop_of_linearOrder [Preorder Œ≤]\n    [ConditionallyCompleteLinearOrder Œ≥] {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Monotone f)\n    {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atTop) : ‚®Ü a, f (g a) = ‚®Ü b, f b := by\n  if hb : BddAbove (range f) then\n    exact hf.ciSup_comp_tendsto_atTop hb hg\n  else\n    rw [iSup, iSup, csSup_of_not_bddAbove, csSup_of_not_bddAbove hb]\n    rwa [BddAbove, ‚Üê Function.comp_def f g, hf.upperBounds_range_comp_tendsto_atTop hg]\n\n"}
{"name":"Monotone.ciInf_comp_tendsto_atBot_of_linearOrder","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : ConditionallyCompleteLinearOrder Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Monotone f\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atBot\n‚ä¢ Eq (iInf fun a => f (g a)) (iInf fun b => f b)","decl":"/-- If `f` is a monotone function taking values in a conditionally complete linear order\nand `g` tends to `atBot` along a nontrivial filter,\nthen the indexed infimum of `f ‚àò g` is equal to the indexed infimum of `f`. -/\ntheorem _root_.Monotone.ciInf_comp_tendsto_atBot_of_linearOrder [Preorder Œ≤]\n    [ConditionallyCompleteLinearOrder Œ≥] {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Monotone f)\n    {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atBot) : ‚®Ö a, f (g a) = ‚®Ö b, f b :=\n  hf.dual.ciSup_comp_tendsto_atTop_of_linearOrder hg\n\n"}
{"name":"Antitone.ciInf_comp_tendsto_atTop_of_linearOrder","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : ConditionallyCompleteLinearOrder Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Antitone f\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atTop\n‚ä¢ Eq (iInf fun a => f (g a)) (iInf fun b => f b)","decl":"/-- If `f` is an antitone function taking values in a conditionally complete linear order\nand `g` tends to `atTop` along a nontrivial filter,\nthen the indexed infimum of `f ‚àò g` is equal to the indexed infimum of `f`. -/\ntheorem _root_.Antitone.ciInf_comp_tendsto_atTop_of_linearOrder [Preorder Œ≤]\n    [ConditionallyCompleteLinearOrder Œ≥] {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Antitone f)\n    {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atTop) : ‚®Ö a, f (g a) = ‚®Ö b, f b :=\n  hf.dual_left.ciInf_comp_tendsto_atBot_of_linearOrder hg\n\n"}
{"name":"Antitone.ciSup_comp_tendsto_atBot_of_linearOrder","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : ConditionallyCompleteLinearOrder Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Antitone f\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atBot\n‚ä¢ Eq (iSup fun a => f (g a)) (iSup fun b => f b)","decl":"/-- If `f` is an antitone function taking values in a conditionally complete linear order\nand `g` tends to `atBot` along a nontrivial filter,\nthen the indexed supremum of `f ‚àò g` is equal to the indexed supremum of `f`. -/\ntheorem _root_.Antitone.ciSup_comp_tendsto_atBot_of_linearOrder [Preorder Œ≤]\n    [ConditionallyCompleteLinearOrder Œ≥] {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Antitone f)\n    {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atBot) : ‚®Ü a, f (g a) = ‚®Ü b, f b :=\n  hf.dual_left.ciSup_comp_tendsto_atTop_of_linearOrder hg\n\n"}
{"name":"Monotone.iSup_comp_tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≥ : Preorder Œ≤\ninst‚úù¬≤ : ConditionallyCompleteLattice Œ≥\ninst‚úù¬π : OrderTop Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Monotone f\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atTop\n‚ä¢ Eq (iSup fun a => f (g a)) (iSup fun b => f b)","decl":"/-- If `f` is a monotone function taking values in a complete lattice\nand `g` tends to `atTop` along a nontrivial filter,\nthen the indexed supremum of `f ‚àò g` is equal to the indexed supremum of `f`. -/\ntheorem _root_.Monotone.iSup_comp_tendsto_atTop\n    [Preorder Œ≤] [ConditionallyCompleteLattice Œ≥] [OrderTop Œ≥]\n    {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Monotone f) {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atTop) :\n    ‚®Ü a, f (g a) = ‚®Ü b, f b :=\n  hf.ciSup_comp_tendsto_atTop (OrderTop.bddAbove _) hg\n\n"}
{"name":"Monotone.iInf_comp_tendsto_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≥ : Preorder Œ≤\ninst‚úù¬≤ : ConditionallyCompleteLattice Œ≥\ninst‚úù¬π : OrderBot Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Monotone f\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atBot\n‚ä¢ Eq (iInf fun a => f (g a)) (iInf fun b => f b)","decl":"/-- If `f` is a monotone function taking values in a complete lattice\nand `g` tends to `atBot` along a nontrivial filter,\nthen the indexed infimum of `f ‚àò g` is equal to the indexed infimum of `f`. -/\ntheorem _root_.Monotone.iInf_comp_tendsto_atBot\n    [Preorder Œ≤] [ConditionallyCompleteLattice Œ≥] [OrderBot Œ≥]\n    {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Monotone f) {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atBot) :\n    ‚®Ö a, f (g a) = ‚®Ö b, f b :=\n  hf.ciInf_comp_tendsto_atBot (OrderBot.bddBelow _) hg\n\n"}
{"name":"Antitone.iSup_comp_tendsto_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≥ : Preorder Œ≤\ninst‚úù¬≤ : ConditionallyCompleteLattice Œ≥\ninst‚úù¬π : OrderTop Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Antitone f\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atBot\n‚ä¢ Eq (iSup fun a => f (g a)) (iSup fun b => f b)","decl":"/-- If `f` is an antitone function taking values in a complete lattice\nand `g` tends to `atBot` along a nontrivial filter,\nthen the indexed supremum of `f ‚àò g` is equal to the indexed supremum of `f`. -/\ntheorem _root_.Antitone.iSup_comp_tendsto_atBot\n    [Preorder Œ≤] [ConditionallyCompleteLattice Œ≥] [OrderTop Œ≥]\n    {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Antitone f) {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atBot) :\n    ‚®Ü a, f (g a) = ‚®Ü b, f b :=\n  hf.ciSup_comp_tendsto_atBot (OrderTop.bddAbove _) hg\n\n"}
{"name":"Antitone.iInf_comp_tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬≥ : Preorder Œ≤\ninst‚úù¬≤ : ConditionallyCompleteLattice Œ≥\ninst‚úù¬π : OrderBot Œ≥\nl : Filter Œ±\ninst‚úù : l.NeBot\nf : Œ≤ ‚Üí Œ≥\nhf : Antitone f\ng : Œ± ‚Üí Œ≤\nhg : Filter.Tendsto g l Filter.atTop\n‚ä¢ Eq (iInf fun a => f (g a)) (iInf fun b => f b)","decl":"/-- If `f` is an antitone function taking values in a complete lattice\nand `g` tends to `atTop` along a nontrivial filter,\nthen the indexed infimum of `f ‚àò g` is equal to the indexed infimum of `f`. -/\ntheorem _root_.Antitone.iInf_comp_tendsto_atTop\n    [Preorder Œ≤] [ConditionallyCompleteLattice Œ≥] [OrderBot Œ≥]\n    {l : Filter Œ±} [l.NeBot] {f : Œ≤ ‚Üí Œ≥} (hf : Antitone f) {g : Œ± ‚Üí Œ≤} (hg : Tendsto g l atTop) :\n    ‚®Ö a, f (g a) = ‚®Ö b, f b :=\n  hf.ciInf_comp_tendsto_atTop (OrderBot.bddBelow _) hg\n\n"}
{"name":"Monotone.iUnion_comp_tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬π : Preorder Œ≤\nl : Filter Œ±\ninst‚úù : l.NeBot\ns : Œ≤ ‚Üí Set Œ≥\nhs : Monotone s\nf : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f l Filter.atTop\n‚ä¢ Eq (Set.iUnion fun a => s (f a)) (Set.iUnion fun b => s b)","decl":"/-- If `s` is a monotone family of sets and `f` tends to `atTop` along a nontrivial filter,\nthen the indexed union of `s ‚àò f` is equal to the indexed union of `s`. -/\ntheorem _root_.Monotone.iUnion_comp_tendsto_atTop [Preorder Œ≤] {l : Filter Œ±} [l.NeBot]\n    {s : Œ≤ ‚Üí Set Œ≥} (hs : Monotone s) {f : Œ± ‚Üí Œ≤} (hf : Tendsto f l atTop) :\n    ‚ãÉ a, s (f a) = ‚ãÉ b, s b :=\n  hs.iSup_comp_tendsto_atTop hf\n\n"}
{"name":"Monotone.iInter_comp_tendsto_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬π : Preorder Œ≤\nl : Filter Œ±\ninst‚úù : l.NeBot\ns : Œ≤ ‚Üí Set Œ≥\nhs : Monotone s\nf : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f l Filter.atBot\n‚ä¢ Eq (Set.iInter fun a => s (f a)) (Set.iInter fun b => s b)","decl":"/-- If `s` is a monotone family of sets and `f` tends to `atBot` along a nontrivial filter,\nthen the indexed intersection of `s ‚àò f` is equal to the indexed intersection of `s`. -/\ntheorem _root_.Monotone.iInter_comp_tendsto_atBot [Preorder Œ≤] {l : Filter Œ±} [l.NeBot]\n    {s : Œ≤ ‚Üí Set Œ≥} (hs : Monotone s) {f : Œ± ‚Üí Œ≤} (hf : Tendsto f l atBot) :\n    ‚ãÇ a, s (f a) = ‚ãÇ b, s b :=\n  hs.iInf_comp_tendsto_atBot hf\n\n"}
{"name":"Antitone.iInter_comp_tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬π : Preorder Œ≤\nl : Filter Œ±\ninst‚úù : l.NeBot\ns : Œ≤ ‚Üí Set Œ≥\nhs : Antitone s\nf : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f l Filter.atTop\n‚ä¢ Eq (Set.iInter fun a => s (f a)) (Set.iInter fun b => s b)","decl":"/-- If `s` is an antitone family of sets and `f` tends to `atTop` along a nontrivial filter,\nthen the indexed intersection of `s ‚àò f` is equal to the indexed intersection of `s`. -/\ntheorem _root_.Antitone.iInter_comp_tendsto_atTop [Preorder Œ≤] {l : Filter Œ±} [l.NeBot]\n    {s : Œ≤ ‚Üí Set Œ≥} (hs : Antitone s) {f : Œ± ‚Üí Œ≤} (hf : Tendsto f l atTop) :\n    ‚ãÇ a, s (f a) = ‚ãÇ b, s b :=\n  hs.iInf_comp_tendsto_atTop hf\n\n"}
{"name":"Antitone.iUnion_comp_tendsto_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬π : Preorder Œ≤\nl : Filter Œ±\ninst‚úù : l.NeBot\ns : Œ≤ ‚Üí Set Œ≥\nhs : Antitone s\nf : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f l Filter.atBot\n‚ä¢ Eq (Set.iUnion fun a => s (f a)) (Set.iUnion fun b => s b)","decl":"/-- If `s` is a monotone family of sets and `f` tends to `atBot` along a nontrivial filter,\nthen the indexed union of `s ‚àò f` is equal to the indexed union of `s`. -/\ntheorem _root_.Antitone.iUnion_comp_tendsto_atBot [Preorder Œ≤] {l : Filter Œ±} [l.NeBot]\n    {s : Œ≤ ‚Üí Set Œ≥} (hs : Antitone s) {f : Œ± ‚Üí Œ≤} (hf : Tendsto f l atBot) :\n    ‚ãÉ a, s (f a) = ‚ãÉ b, s b :=\n  hs.iSup_comp_tendsto_atBot hf\n\n"}
{"name":"Filter.tendsto_atTop_atTop_of_monotone","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Monotone f\nh : ‚àÄ (b : Œ≤), Exists fun a => LE.le b (f a)\n‚ä¢ Filter.Tendsto f Filter.atTop Filter.atTop","decl":"theorem tendsto_atTop_atTop_of_monotone [Preorder Œ±] [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Monotone f)\n    (h : ‚àÄ b, ‚àÉ a, b ‚â§ f a) : Tendsto f atTop atTop :=\n  tendsto_iInf.2 fun b =>\n    tendsto_principal.2 <|\n      let ‚ü®a, ha‚ü© := h b\n      mem_of_superset (mem_atTop a) fun _a' ha' => le_trans ha (hf ha')\n\n"}
{"name":"Filter.tendsto_atTop_atBot_of_antitone","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Antitone f\nh : ‚àÄ (b : Œ≤), Exists fun a => LE.le (f a) b\n‚ä¢ Filter.Tendsto f Filter.atTop Filter.atBot","decl":"theorem tendsto_atTop_atBot_of_antitone [Preorder Œ±] [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Antitone f)\n    (h : ‚àÄ b, ‚àÉ a, f a ‚â§ b) : Tendsto f atTop atBot :=\n  @tendsto_atTop_atTop_of_monotone _ Œ≤·µí·µà _ _ _ hf h\n\n"}
{"name":"Filter.tendsto_atBot_atBot_of_monotone","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Monotone f\nh : ‚àÄ (b : Œ≤), Exists fun a => LE.le (f a) b\n‚ä¢ Filter.Tendsto f Filter.atBot Filter.atBot","decl":"theorem tendsto_atBot_atBot_of_monotone [Preorder Œ±] [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Monotone f)\n    (h : ‚àÄ b, ‚àÉ a, f a ‚â§ b) : Tendsto f atBot atBot :=\n  tendsto_iInf.2 fun b => tendsto_principal.2 <|\n    let ‚ü®a, ha‚ü© := h b; mem_of_superset (mem_atBot a) fun _a' ha' => le_trans (hf ha') ha\n\n"}
{"name":"Filter.tendsto_atBot_atTop_of_antitone","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Antitone f\nh : ‚àÄ (b : Œ≤), Exists fun a => LE.le b (f a)\n‚ä¢ Filter.Tendsto f Filter.atBot Filter.atTop","decl":"theorem tendsto_atBot_atTop_of_antitone [Preorder Œ±] [Preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : Antitone f)\n    (h : ‚àÄ b, ‚àÉ a, b ‚â§ f a) : Tendsto f atBot atTop :=\n  @tendsto_atBot_atBot_of_monotone _ Œ≤·µí·µà _ _ _ hf h\n\n"}
{"name":"Filter.tendsto_atTop'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Nonempty Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nf : Œ± ‚Üí Œ≤\nl : Filter Œ≤\n‚ä¢ Iff (Filter.Tendsto f Filter.atTop l) (‚àÄ (s : Set Œ≤), Membership.mem l s ‚Üí Exists fun a => ‚àÄ (b : Œ±), GE.ge b a ‚Üí Membership.mem s (f b))","decl":"theorem tendsto_atTop' : Tendsto f atTop l ‚Üî ‚àÄ s ‚àà l, ‚àÉ a, ‚àÄ b ‚â• a, f b ‚àà s := by\n  simp only [tendsto_def, mem_atTop_sets, mem_preimage]\n\n"}
{"name":"Filter.tendsto_atTop_principal","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Nonempty Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nf : Œ± ‚Üí Œ≤\ns : Set Œ≤\n‚ä¢ Iff (Filter.Tendsto f Filter.atTop (Filter.principal s)) (Exists fun N => ‚àÄ (n : Œ±), GE.ge n N ‚Üí Membership.mem s (f n))","decl":"theorem tendsto_atTop_principal {s : Set Œ≤} : Tendsto f atTop (ùìü s) ‚Üî ‚àÉ N, ‚àÄ n ‚â• N, f n ‚àà s := by\n  simp_rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_atTop_sets, mem_preimage]\n\n"}
{"name":"Filter.tendsto_atTop_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Nonempty Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nf : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œ≤\n‚ä¢ Iff (Filter.Tendsto f Filter.atTop Filter.atTop) (‚àÄ (b : Œ≤), Exists fun i => ‚àÄ (a : Œ±), LE.le i a ‚Üí LE.le b (f a))","decl":"/-- A function `f` grows to `+‚àû` independent of an order-preserving embedding `e`. -/\ntheorem tendsto_atTop_atTop : Tendsto f atTop atTop ‚Üî ‚àÄ b : Œ≤, ‚àÉ i : Œ±, ‚àÄ a : Œ±, i ‚â§ a ‚Üí b ‚â§ f a :=\n  tendsto_iInf.trans <| forall_congr' fun _ => tendsto_atTop_principal\n\n"}
{"name":"Filter.tendsto_atTop_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Nonempty Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nf : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œ≤\n‚ä¢ Iff (Filter.Tendsto f Filter.atTop Filter.atBot) (‚àÄ (b : Œ≤), Exists fun i => ‚àÄ (a : Œ±), LE.le i a ‚Üí LE.le (f a) b)","decl":"theorem tendsto_atTop_atBot : Tendsto f atTop atBot ‚Üî ‚àÄ b : Œ≤, ‚àÉ i : Œ±, ‚àÄ a : Œ±, i ‚â§ a ‚Üí f a ‚â§ b :=\n  tendsto_atTop_atTop (Œ≤ := Œ≤·µí·µà)\n\n"}
{"name":"Filter.tendsto_atTop_atTop_iff_of_monotone","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Nonempty Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nf : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œ≤\nhf : Monotone f\n‚ä¢ Iff (Filter.Tendsto f Filter.atTop Filter.atTop) (‚àÄ (b : Œ≤), Exists fun a => LE.le b (f a))","decl":"theorem tendsto_atTop_atTop_iff_of_monotone (hf : Monotone f) :\n    Tendsto f atTop atTop ‚Üî ‚àÄ b : Œ≤, ‚àÉ a, b ‚â§ f a :=\n  tendsto_atTop_atTop.trans <| forall_congr' fun _ => exists_congr fun a =>\n    ‚ü®fun h => h a (le_refl a), fun h _a' ha' => le_trans h <| hf ha'‚ü©\n\n"}
{"name":"Filter.tendsto_atTop_atBot_iff_of_antitone","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Nonempty Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nf : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œ≤\nhf : Antitone f\n‚ä¢ Iff (Filter.Tendsto f Filter.atTop Filter.atBot) (‚àÄ (b : Œ≤), Exists fun a => LE.le (f a) b)","decl":"theorem tendsto_atTop_atBot_iff_of_antitone (hf : Antitone f) :\n    Tendsto f atTop atBot ‚Üî ‚àÄ b : Œ≤, ‚àÉ a, f a ‚â§ b :=\n  tendsto_atTop_atTop_iff_of_monotone (Œ≤ := Œ≤·µí·µà) hf\n\n"}
{"name":"Filter.tendsto_atBot'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Nonempty Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\nf : Œ± ‚Üí Œ≤\nl : Filter Œ≤\n‚ä¢ Iff (Filter.Tendsto f Filter.atBot l) (‚àÄ (s : Set Œ≤), Membership.mem l s ‚Üí Exists fun a => ‚àÄ (b : Œ±), LE.le b a ‚Üí Membership.mem s (f b))","decl":"theorem tendsto_atBot' : Tendsto f atBot l ‚Üî ‚àÄ s ‚àà l, ‚àÉ a, ‚àÄ b ‚â§ a, f b ‚àà s :=\n  tendsto_atTop' (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.tendsto_atBot_principal","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Nonempty Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\nf : Œ± ‚Üí Œ≤\ns : Set Œ≤\n‚ä¢ Iff (Filter.Tendsto f Filter.atBot (Filter.principal s)) (Exists fun N => ‚àÄ (n : Œ±), LE.le n N ‚Üí Membership.mem s (f n))","decl":"theorem tendsto_atBot_principal {s : Set Œ≤} : Tendsto f atBot (ùìü s) ‚Üî ‚àÉ N, ‚àÄ n ‚â§ N, f n ‚àà s :=\n  tendsto_atTop_principal (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà)\n\n"}
{"name":"Filter.tendsto_atBot_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Nonempty Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\nf : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œ≤\n‚ä¢ Iff (Filter.Tendsto f Filter.atBot Filter.atTop) (‚àÄ (b : Œ≤), Exists fun i => ‚àÄ (a : Œ±), LE.le a i ‚Üí LE.le b (f a))","decl":"theorem tendsto_atBot_atTop : Tendsto f atBot atTop ‚Üî ‚àÄ b : Œ≤, ‚àÉ i : Œ±, ‚àÄ a : Œ±, a ‚â§ i ‚Üí b ‚â§ f a :=\n  tendsto_atTop_atTop (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.tendsto_atBot_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Nonempty Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\nf : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œ≤\n‚ä¢ Iff (Filter.Tendsto f Filter.atBot Filter.atBot) (‚àÄ (b : Œ≤), Exists fun i => ‚àÄ (a : Œ±), LE.le a i ‚Üí LE.le (f a) b)","decl":"theorem tendsto_atBot_atBot : Tendsto f atBot atBot ‚Üî ‚àÄ b : Œ≤, ‚àÉ i : Œ±, ‚àÄ a : Œ±, a ‚â§ i ‚Üí f a ‚â§ b :=\n  tendsto_atTop_atTop (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà)\n\n"}
{"name":"Filter.tendsto_atBot_atBot_iff_of_monotone","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Nonempty Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\nf : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œ≤\nhf : Monotone f\n‚ä¢ Iff (Filter.Tendsto f Filter.atBot Filter.atBot) (‚àÄ (b : Œ≤), Exists fun a => LE.le (f a) b)","decl":"theorem tendsto_atBot_atBot_iff_of_monotone (hf : Monotone f) :\n    Tendsto f atBot atBot ‚Üî ‚àÄ b : Œ≤, ‚àÉ a, f a ‚â§ b :=\n  tendsto_atBot_atBot.trans <| forall_congr' fun _ => exists_congr fun a =>\n    ‚ü®fun h => h a (le_refl a), fun h _a' ha' => le_trans (hf ha') h‚ü©\n\n"}
{"name":"Filter.tendsto_atBot_atTop_iff_of_antitone","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Nonempty Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\nf : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œ≤\nhf : Antitone f\n‚ä¢ Iff (Filter.Tendsto f Filter.atBot Filter.atTop) (‚àÄ (b : Œ≤), Exists fun a => LE.le b (f a))","decl":"theorem tendsto_atBot_atTop_iff_of_antitone (hf : Antitone f) :\n    Tendsto f atBot atTop ‚Üî ‚àÄ b : Œ≤, ‚àÉ a, b ‚â§ f a :=\n  tendsto_atBot_atBot_iff_of_monotone (Œ≤ := Œ≤·µí·µà) hf\n\n"}
{"name":"Monotone.tendsto_atTop_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Monotone f\nh : ‚àÄ (b : Œ≤), Exists fun a => LE.le b (f a)\n‚ä¢ Filter.Tendsto f Filter.atTop Filter.atTop","decl":"alias _root_.Monotone.tendsto_atTop_atTop := tendsto_atTop_atTop_of_monotone\n\n"}
{"name":"Monotone.tendsto_atBot_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Monotone f\nh : ‚àÄ (b : Œ≤), Exists fun a => LE.le (f a) b\n‚ä¢ Filter.Tendsto f Filter.atBot Filter.atBot","decl":"alias _root_.Monotone.tendsto_atBot_atBot := tendsto_atBot_atBot_of_monotone\n\n"}
{"name":"Monotone.tendsto_atTop_atTop_iff","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Nonempty Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nf : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œ≤\nhf : Monotone f\n‚ä¢ Iff (Filter.Tendsto f Filter.atTop Filter.atTop) (‚àÄ (b : Œ≤), Exists fun a => LE.le b (f a))","decl":"alias _root_.Monotone.tendsto_atTop_atTop_iff := tendsto_atTop_atTop_iff_of_monotone\n\n"}
{"name":"Monotone.tendsto_atBot_atBot_iff","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Nonempty Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\nf : Œ± ‚Üí Œ≤\ninst‚úù : Preorder Œ≤\nhf : Monotone f\n‚ä¢ Iff (Filter.Tendsto f Filter.atBot Filter.atBot) (‚àÄ (b : Œ≤), Exists fun a => LE.le (f a) b)","decl":"alias _root_.Monotone.tendsto_atBot_atBot_iff := tendsto_atBot_atBot_iff_of_monotone\n\n"}
{"name":"Filter.comap_embedding_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : Preorder Œ≥\ne : Œ≤ ‚Üí Œ≥\nhm : ‚àÄ (b‚ÇÅ b‚ÇÇ : Œ≤), Iff (LE.le (e b‚ÇÅ) (e b‚ÇÇ)) (LE.le b‚ÇÅ b‚ÇÇ)\nhu : ‚àÄ (c : Œ≥), Exists fun b => LE.le c (e b)\n‚ä¢ Eq (Filter.comap e Filter.atTop) Filter.atTop","decl":"theorem comap_embedding_atTop [Preorder Œ≤] [Preorder Œ≥] {e : Œ≤ ‚Üí Œ≥}\n    (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄ c, ‚àÉ b, c ‚â§ e b) : comap e atTop = atTop :=\n  le_antisymm\n    (le_iInf fun b =>\n      le_principal_iff.2 <| mem_comap.2 ‚ü®Ici (e b), mem_atTop _, fun _ => (hm _ _).1‚ü©)\n    (tendsto_atTop_atTop_of_monotone (fun _ _ => (hm _ _).2) hu).le_comap\n\n"}
{"name":"Filter.comap_embedding_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : Preorder Œ≥\ne : Œ≤ ‚Üí Œ≥\nhm : ‚àÄ (b‚ÇÅ b‚ÇÇ : Œ≤), Iff (LE.le (e b‚ÇÅ) (e b‚ÇÇ)) (LE.le b‚ÇÅ b‚ÇÇ)\nhu : ‚àÄ (c : Œ≥), Exists fun b => LE.le (e b) c\n‚ä¢ Eq (Filter.comap e Filter.atBot) Filter.atBot","decl":"theorem comap_embedding_atBot [Preorder Œ≤] [Preorder Œ≥] {e : Œ≤ ‚Üí Œ≥}\n    (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄ c, ‚àÉ b, e b ‚â§ c) : comap e atBot = atBot :=\n  @comap_embedding_atTop Œ≤·µí·µà Œ≥·µí·µà _ _ e (Function.swap hm) hu\n\n"}
{"name":"Filter.tendsto_atTop_embedding","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : Preorder Œ≥\nf : Œ± ‚Üí Œ≤\ne : Œ≤ ‚Üí Œ≥\nl : Filter Œ±\nhm : ‚àÄ (b‚ÇÅ b‚ÇÇ : Œ≤), Iff (LE.le (e b‚ÇÅ) (e b‚ÇÇ)) (LE.le b‚ÇÅ b‚ÇÇ)\nhu : ‚àÄ (c : Œ≥), Exists fun b => LE.le c (e b)\n‚ä¢ Iff (Filter.Tendsto (Function.comp e f) l Filter.atTop) (Filter.Tendsto f l Filter.atTop)","decl":"theorem tendsto_atTop_embedding [Preorder Œ≤] [Preorder Œ≥] {f : Œ± ‚Üí Œ≤} {e : Œ≤ ‚Üí Œ≥} {l : Filter Œ±}\n    (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄ c, ‚àÉ b, c ‚â§ e b) :\n    Tendsto (e ‚àò f) l atTop ‚Üî Tendsto f l atTop := by\n  rw [‚Üê comap_embedding_atTop hm hu, tendsto_comap_iff]\n\n"}
{"name":"Filter.tendsto_atBot_embedding","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : Preorder Œ≥\nf : Œ± ‚Üí Œ≤\ne : Œ≤ ‚Üí Œ≥\nl : Filter Œ±\nhm : ‚àÄ (b‚ÇÅ b‚ÇÇ : Œ≤), Iff (LE.le (e b‚ÇÅ) (e b‚ÇÇ)) (LE.le b‚ÇÅ b‚ÇÇ)\nhu : ‚àÄ (c : Œ≥), Exists fun b => LE.le (e b) c\n‚ä¢ Iff (Filter.Tendsto (Function.comp e f) l Filter.atBot) (Filter.Tendsto f l Filter.atBot)","decl":"/-- A function `f` goes to `-‚àû` independent of an order-preserving embedding `e`. -/\ntheorem tendsto_atBot_embedding [Preorder Œ≤] [Preorder Œ≥] {f : Œ± ‚Üí Œ≤} {e : Œ≤ ‚Üí Œ≥} {l : Filter Œ±}\n    (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄ c, ‚àÉ b, e b ‚â§ c) :\n    Tendsto (e ‚àò f) l atBot ‚Üî Tendsto f l atBot :=\n  @tendsto_atTop_embedding Œ± Œ≤·µí·µà Œ≥·µí·µà _ _ f e l (Function.swap hm) hu\n\n"}
{"name":"Filter.tendsto_finset_range","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"‚ä¢ Filter.Tendsto Finset.range Filter.atTop Filter.atTop","decl":"theorem tendsto_finset_range : Tendsto Finset.range atTop atTop :=\n  Finset.range_mono.tendsto_atTop_atTop Finset.exists_nat_subset_range\n\n"}
{"name":"Filter.atTop_finset_eq_iInf","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\n‚ä¢ Eq Filter.atTop (iInf fun x => Filter.principal (Set.Ici (Singleton.singleton x)))","decl":"theorem atTop_finset_eq_iInf : (atTop : Filter (Finset Œ±)) = ‚®Ö x : Œ±, ùìü (Ici {x}) := by\n  refine le_antisymm (le_iInf fun i => le_principal_iff.2 <| mem_atTop ({i} : Finset Œ±)) ?_\n  refine\n    le_iInf fun s =>\n      le_principal_iff.2 <| mem_iInf_of_iInter s.finite_toSet (fun i => mem_principal_self _) ?_\n  simp only [subset_def, mem_iInter, SetCoe.forall, mem_Ici, Finset.le_iff_subset,\n    Finset.mem_singleton, Finset.subset_iff, forall_eq]\n  exact fun t => id\n\n"}
{"name":"Filter.tendsto_atTop_finset_of_monotone","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù : Preorder Œ≤\nf : Œ≤ ‚Üí Finset Œ±\nh : Monotone f\nh' : ‚àÄ (x : Œ±), Exists fun n => Membership.mem (f n) x\n‚ä¢ Filter.Tendsto f Filter.atTop Filter.atTop","decl":"/-- If `f` is a monotone sequence of `Finset`s and each `x` belongs to one of `f n`, then\n`Tendsto f atTop atTop`. -/\ntheorem tendsto_atTop_finset_of_monotone [Preorder Œ≤] {f : Œ≤ ‚Üí Finset Œ±} (h : Monotone f)\n    (h' : ‚àÄ x : Œ±, ‚àÉ n, x ‚àà f n) : Tendsto f atTop atTop := by\n  simp only [atTop_finset_eq_iInf, tendsto_iInf, tendsto_principal]\n  intro a\n  rcases h' a with ‚ü®b, hb‚ü©\n  exact (eventually_ge_atTop b).mono fun b' hb' => (Finset.singleton_subset_iff.2 hb).trans (h hb')\n\n"}
{"name":"Monotone.tendsto_atTop_finset","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù : Preorder Œ≤\nf : Œ≤ ‚Üí Finset Œ±\nh : Monotone f\nh' : ‚àÄ (x : Œ±), Exists fun n => Membership.mem (f n) x\n‚ä¢ Filter.Tendsto f Filter.atTop Filter.atTop","decl":"alias _root_.Monotone.tendsto_atTop_finset := tendsto_atTop_finset_of_monotone\n\n-- Porting note: add assumption `DecidableEq Œ≤` so that the lemma applies to any instance\n"}
{"name":"Filter.tendsto_finset_image_atTop_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù : DecidableEq Œ≤\ni : Œ≤ ‚Üí Œ≥\nj : Œ≥ ‚Üí Œ≤\nh : Function.LeftInverse j i\n‚ä¢ Filter.Tendsto (Finset.image j) Filter.atTop Filter.atTop","decl":"theorem tendsto_finset_image_atTop_atTop [DecidableEq Œ≤] {i : Œ≤ ‚Üí Œ≥} {j : Œ≥ ‚Üí Œ≤}\n    (h : Function.LeftInverse j i) : Tendsto (Finset.image j) atTop atTop :=\n  (Finset.image_mono j).tendsto_atTop_finset fun a =>\n    ‚ü®{i a}, by simp only [Finset.image_singleton, h a, Finset.mem_singleton]‚ü©\n\n"}
{"name":"Filter.tendsto_finset_preimage_atTop_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nf : Œ± ‚Üí Œ≤\nhf : Function.Injective f\n‚ä¢ Filter.Tendsto (fun s => s.preimage f ‚ãØ) Filter.atTop Filter.atTop","decl":"theorem tendsto_finset_preimage_atTop_atTop {f : Œ± ‚Üí Œ≤} (hf : Function.Injective f) :\n    Tendsto (fun s : Finset Œ≤ => s.preimage f (hf.injOn)) atTop atTop :=\n  (Finset.monotone_preimage hf).tendsto_atTop_finset fun x =>\n    ‚ü®{f x}, Finset.mem_preimage.2 <| Finset.mem_singleton_self _‚ü©\n\n"}
{"name":"Filter.prod_atTop_atTop_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\n‚ä¢ Eq (SProd.sprod Filter.atTop Filter.atTop) Filter.atTop","decl":"theorem prod_atTop_atTop_eq [Preorder Œ±] [Preorder Œ≤] :\n    (atTop : Filter Œ±) √óÀ¢ (atTop : Filter Œ≤) = (atTop : Filter (Œ± √ó Œ≤)) := by\n  cases isEmpty_or_nonempty Œ±\n  ¬∑ subsingleton\n  cases isEmpty_or_nonempty Œ≤\n  ¬∑ subsingleton\n  simpa [atTop, prod_iInf_left, prod_iInf_right, iInf_prod] using iInf_comm\n\n"}
{"name":"Filter.tendsto_finset_prod_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\n‚ä¢ Filter.Tendsto (fun p => SProd.sprod p.1 p.2) Filter.atTop Filter.atTop","decl":"lemma tendsto_finset_prod_atTop :\n    Tendsto (fun (p : Finset Œπ √ó Finset Œπ') ‚Ü¶ p.1 √óÀ¢ p.2) atTop atTop := by\n  classical\n  apply Monotone.tendsto_atTop_atTop\n  ¬∑ intro p q hpq\n    simpa using Finset.product_subset_product hpq.1 hpq.2\n  ¬∑ intro b\n    use (Finset.image Prod.fst b, Finset.image Prod.snd b)\n    exact Finset.subset_product\n\n"}
{"name":"Filter.prod_atBot_atBot_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\n‚ä¢ Eq (SProd.sprod Filter.atBot Filter.atBot) Filter.atBot","decl":"theorem prod_atBot_atBot_eq [Preorder Œ±] [Preorder Œ≤] :\n    (atBot : Filter Œ±) √óÀ¢ (atBot : Filter Œ≤) = (atBot : Filter (Œ± √ó Œ≤)) :=\n  @prod_atTop_atTop_eq Œ±·µí·µà Œ≤·µí·µà _ _\n\n"}
{"name":"Filter.prod_map_atTop_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ±‚ÇÅ : Type u_6\nŒ±‚ÇÇ : Type u_7\nŒ≤‚ÇÅ : Type u_8\nŒ≤‚ÇÇ : Type u_9\ninst‚úù¬π : Preorder Œ≤‚ÇÅ\ninst‚úù : Preorder Œ≤‚ÇÇ\nu‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ\nu‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ\n‚ä¢ Eq (SProd.sprod (Filter.map u‚ÇÅ Filter.atTop) (Filter.map u‚ÇÇ Filter.atTop)) (Filter.map (Prod.map u‚ÇÅ u‚ÇÇ) Filter.atTop)","decl":"theorem prod_map_atTop_eq {Œ±‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ : Type*} [Preorder Œ≤‚ÇÅ] [Preorder Œ≤‚ÇÇ]\n    (u‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ) (u‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ) : map u‚ÇÅ atTop √óÀ¢ map u‚ÇÇ atTop = map (Prod.map u‚ÇÅ u‚ÇÇ) atTop := by\n  rw [prod_map_map_eq, prod_atTop_atTop_eq, Prod.map_def]\n\n"}
{"name":"Filter.prod_map_atBot_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ±‚ÇÅ : Type u_6\nŒ±‚ÇÇ : Type u_7\nŒ≤‚ÇÅ : Type u_8\nŒ≤‚ÇÇ : Type u_9\ninst‚úù¬π : Preorder Œ≤‚ÇÅ\ninst‚úù : Preorder Œ≤‚ÇÇ\nu‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ\nu‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ\n‚ä¢ Eq (SProd.sprod (Filter.map u‚ÇÅ Filter.atBot) (Filter.map u‚ÇÇ Filter.atBot)) (Filter.map (Prod.map u‚ÇÅ u‚ÇÇ) Filter.atBot)","decl":"theorem prod_map_atBot_eq {Œ±‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ : Type*} [Preorder Œ≤‚ÇÅ] [Preorder Œ≤‚ÇÇ]\n    (u‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ) (u‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ) : map u‚ÇÅ atBot √óÀ¢ map u‚ÇÇ atBot = map (Prod.map u‚ÇÅ u‚ÇÇ) atBot :=\n  @prod_map_atTop_eq _ _ Œ≤‚ÇÅ·µí·µà Œ≤‚ÇÇ·µí·µà _ _ _ _\n\n"}
{"name":"Filter.Tendsto.subseq_mem","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nF : Filter Œ±\nV : Nat ‚Üí Set Œ±\nh : ‚àÄ (n : Nat), Membership.mem F (V n)\nu : Nat ‚Üí Œ±\nhu : Filter.Tendsto u Filter.atTop F\n‚ä¢ Exists fun œÜ => And (StrictMono œÜ) (‚àÄ (n : Nat), Membership.mem (V n) (u (œÜ n)))","decl":"theorem Tendsto.subseq_mem {F : Filter Œ±} {V : ‚Ñï ‚Üí Set Œ±} (h : ‚àÄ n, V n ‚àà F) {u : ‚Ñï ‚Üí Œ±}\n    (hu : Tendsto u atTop F) : ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ n, u (œÜ n) ‚àà V n :=\n  extraction_forall_of_eventually'\n    (fun n => tendsto_atTop'.mp hu _ (h n) : ‚àÄ n, ‚àÉ N, ‚àÄ k ‚â• N, u k ‚àà V n)\n\n"}
{"name":"Filter.tendsto_atBot_diagonal","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\n‚ä¢ Filter.Tendsto (fun a => { fst := a, snd := a }) Filter.atBot Filter.atBot","decl":"theorem tendsto_atBot_diagonal [Preorder Œ±] : Tendsto (fun a : Œ± => (a, a)) atBot atBot := by\n  rw [‚Üê prod_atBot_atBot_eq]\n  exact tendsto_id.prod_mk tendsto_id\n\n"}
{"name":"Filter.tendsto_atTop_diagonal","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù : Preorder Œ±\n‚ä¢ Filter.Tendsto (fun a => { fst := a, snd := a }) Filter.atTop Filter.atTop","decl":"theorem tendsto_atTop_diagonal [Preorder Œ±] : Tendsto (fun a : Œ± => (a, a)) atTop atTop := by\n  rw [‚Üê prod_atTop_atTop_eq]\n  exact tendsto_id.prod_mk tendsto_id\n\n"}
{"name":"Filter.Tendsto.prod_map_prod_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù : Preorder Œ≥\nF : Filter Œ±\nG : Filter Œ≤\nf : Œ± ‚Üí Œ≥\ng : Œ≤ ‚Üí Œ≥\nhf : Filter.Tendsto f F Filter.atBot\nhg : Filter.Tendsto g G Filter.atBot\n‚ä¢ Filter.Tendsto (Prod.map f g) (SProd.sprod F G) Filter.atBot","decl":"theorem Tendsto.prod_map_prod_atBot [Preorder Œ≥] {F : Filter Œ±} {G : Filter Œ≤} {f : Œ± ‚Üí Œ≥}\n    {g : Œ≤ ‚Üí Œ≥} (hf : Tendsto f F atBot) (hg : Tendsto g G atBot) :\n    Tendsto (Prod.map f g) (F √óÀ¢ G) atBot := by\n  rw [‚Üê prod_atBot_atBot_eq]\n  exact hf.prod_map hg\n\n"}
{"name":"Filter.Tendsto.prod_map_prod_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\nŒ≥ : Type u_5\ninst‚úù : Preorder Œ≥\nF : Filter Œ±\nG : Filter Œ≤\nf : Œ± ‚Üí Œ≥\ng : Œ≤ ‚Üí Œ≥\nhf : Filter.Tendsto f F Filter.atTop\nhg : Filter.Tendsto g G Filter.atTop\n‚ä¢ Filter.Tendsto (Prod.map f g) (SProd.sprod F G) Filter.atTop","decl":"theorem Tendsto.prod_map_prod_atTop [Preorder Œ≥] {F : Filter Œ±} {G : Filter Œ≤} {f : Œ± ‚Üí Œ≥}\n    {g : Œ≤ ‚Üí Œ≥} (hf : Tendsto f F atTop) (hg : Tendsto g G atTop) :\n    Tendsto (Prod.map f g) (F √óÀ¢ G) atTop := by\n  rw [‚Üê prod_atTop_atTop_eq]\n  exact hf.prod_map hg\n\n"}
{"name":"Filter.Tendsto.prod_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≥ : Type u_5\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≥\nf g : Œ± ‚Üí Œ≥\nhf : Filter.Tendsto f Filter.atBot Filter.atBot\nhg : Filter.Tendsto g Filter.atBot Filter.atBot\n‚ä¢ Filter.Tendsto (Prod.map f g) Filter.atBot Filter.atBot","decl":"theorem Tendsto.prod_atBot [Preorder Œ±] [Preorder Œ≥] {f g : Œ± ‚Üí Œ≥}\n    (hf : Tendsto f atBot atBot) (hg : Tendsto g atBot atBot) :\n    Tendsto (Prod.map f g) atBot atBot := by\n  rw [‚Üê prod_atBot_atBot_eq]\n  exact hf.prod_map_prod_atBot hg\n\n"}
{"name":"Filter.Tendsto.prod_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≥ : Type u_5\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≥\nf g : Œ± ‚Üí Œ≥\nhf : Filter.Tendsto f Filter.atTop Filter.atTop\nhg : Filter.Tendsto g Filter.atTop Filter.atTop\n‚ä¢ Filter.Tendsto (Prod.map f g) Filter.atTop Filter.atTop","decl":"theorem Tendsto.prod_atTop [Preorder Œ±] [Preorder Œ≥] {f g : Œ± ‚Üí Œ≥}\n    (hf : Tendsto f atTop atTop) (hg : Tendsto g atTop atTop) :\n    Tendsto (Prod.map f g) atTop atTop := by\n  rw [‚Üê prod_atTop_atTop_eq]\n  exact hf.prod_map_prod_atTop hg\n\n"}
{"name":"Filter.eventually_atBot_prod_self","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Nonempty Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\np : Prod Œ± Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun x => p x) Filter.atBot) (Exists fun a => ‚àÄ (k l : Œ±), LE.le k a ‚Üí LE.le l a ‚Üí p { fst := k, snd := l })","decl":"theorem eventually_atBot_prod_self [Nonempty Œ±] [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â• ¬∑)]\n    {p : Œ± √ó Œ± ‚Üí Prop} : (‚àÄ·∂† x in atBot, p x) ‚Üî ‚àÉ a, ‚àÄ k l, k ‚â§ a ‚Üí l ‚â§ a ‚Üí p (k, l) := by\n  simp [‚Üê prod_atBot_atBot_eq, (@atBot_basis Œ± _ _).prod_self.eventually_iff]\n\n"}
{"name":"Filter.eventually_atTop_prod_self","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Nonempty Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\np : Prod Œ± Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun x => p x) Filter.atTop) (Exists fun a => ‚àÄ (k l : Œ±), LE.le a k ‚Üí LE.le a l ‚Üí p { fst := k, snd := l })","decl":"theorem eventually_atTop_prod_self [Nonempty Œ±] [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)]\n    {p : Œ± √ó Œ± ‚Üí Prop} : (‚àÄ·∂† x in atTop, p x) ‚Üî ‚àÉ a, ‚àÄ k l, a ‚â§ k ‚Üí a ‚â§ l ‚Üí p (k, l) :=\n  eventually_atBot_prod_self (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.eventually_atBot_prod_self'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Nonempty Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\np : Prod Œ± Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun x => p x) Filter.atBot) (Exists fun a => ‚àÄ (k : Œ±), LE.le k a ‚Üí ‚àÄ (l : Œ±), LE.le l a ‚Üí p { fst := k, snd := l })","decl":"theorem eventually_atBot_prod_self'  [Nonempty Œ±] [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â• ¬∑)]\n    {p : Œ± √ó Œ± ‚Üí Prop} : (‚àÄ·∂† x in atBot, p x) ‚Üî ‚àÉ a, ‚àÄ k ‚â§ a, ‚àÄ l ‚â§ a, p (k, l) := by\n  simp only [eventually_atBot_prod_self, forall_cond_comm]\n\n"}
{"name":"Filter.eventually_atTop_prod_self'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Nonempty Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\np : Prod Œ± Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun x => p x) Filter.atTop) (Exists fun a => ‚àÄ (k : Œ±), GE.ge k a ‚Üí ‚àÄ (l : Œ±), GE.ge l a ‚Üí p { fst := k, snd := l })","decl":"theorem eventually_atTop_prod_self' [Nonempty Œ±] [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)]\n    {p : Œ± √ó Œ± ‚Üí Prop} : (‚àÄ·∂† x in atTop, p x) ‚Üî ‚àÉ a, ‚àÄ k ‚â• a, ‚àÄ l ‚â• a, p (k, l) := by\n  simp only [eventually_atTop_prod_self, forall_cond_comm]\n\n"}
{"name":"Filter.eventually_atTop_curry","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\np : Prod Œ± Œ≤ ‚Üí Prop\nhp : Filter.Eventually (fun x => p x) Filter.atTop\n‚ä¢ Filter.Eventually (fun k => Filter.Eventually (fun l => p { fst := k, snd := l }) Filter.atTop) Filter.atTop","decl":"theorem eventually_atTop_curry [Preorder Œ±] [Preorder Œ≤] {p : Œ± √ó Œ≤ ‚Üí Prop}\n    (hp : ‚àÄ·∂† x : Œ± √ó Œ≤ in Filter.atTop, p x) : ‚àÄ·∂† k in atTop, ‚àÄ·∂† l in atTop, p (k, l) := by\n  rw [‚Üê prod_atTop_atTop_eq] at hp\n  exact hp.curry\n\n"}
{"name":"Filter.eventually_atBot_curry","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\np : Prod Œ± Œ≤ ‚Üí Prop\nhp : Filter.Eventually (fun x => p x) Filter.atBot\n‚ä¢ Filter.Eventually (fun k => Filter.Eventually (fun l => p { fst := k, snd := l }) Filter.atBot) Filter.atBot","decl":"theorem eventually_atBot_curry [Preorder Œ±] [Preorder Œ≤] {p : Œ± √ó Œ≤ ‚Üí Prop}\n    (hp : ‚àÄ·∂† x : Œ± √ó Œ≤ in Filter.atBot, p x) : ‚àÄ·∂† k in atBot, ‚àÄ·∂† l in atBot, p (k, l) :=\n  @eventually_atTop_curry Œ±·µí·µà Œ≤·µí·µà _ _ _ hp\n\n"}
{"name":"Filter.map_atTop_eq_of_gc_preorder","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : IsDirected Œ≤ fun x1 x2 => LE.le x1 x2\nf : Œ± ‚Üí Œ≤\nhf : Monotone f\nb : Œ≤\nhgi : ‚àÄ (c : Œ≤), GE.ge c b ‚Üí Exists fun x => And (Eq (f x) c) (‚àÄ (a : Œ±), Iff (LE.le (f a) c) (LE.le a x))\n‚ä¢ Eq (Filter.map f Filter.atTop) Filter.atTop","decl":"/-- A function `f` maps upwards closed sets (atTop sets) to upwards closed sets when it is a\nGalois insertion. The Galois \"insertion\" and \"connection\" is weakened to only require it to be an\ninsertion and a connection above `b`. -/\ntheorem map_atTop_eq_of_gc_preorder\n    [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)] [Preorder Œ≤] [IsDirected Œ≤ (¬∑ ‚â§ ¬∑)] {f : Œ± ‚Üí Œ≤}\n    (hf : Monotone f) (b : Œ≤)\n    (hgi : ‚àÄ c ‚â• b, ‚àÉ x, f x = c ‚àß ‚àÄ a, f a ‚â§ c ‚Üî a ‚â§ x) : map f atTop = atTop := by\n  have : Nonempty Œ± := (hgi b le_rfl).nonempty\n  choose! g hfg hgle using hgi\n  refine le_antisymm (hf.tendsto_atTop_atTop fun c ‚Ü¶ ?_) ?_\n  ¬∑ rcases exists_ge_ge c b with ‚ü®d, hcd, hbd‚ü©\n    exact ‚ü®g d, hcd.trans (hfg d hbd).ge‚ü©\n  ¬∑ have : Nonempty Œ± := ‚ü®g b‚ü©\n    rw [(atTop_basis.map f).ge_iff]\n    intro a _\n    filter_upwards [eventually_ge_atTop (f a), eventually_ge_atTop b] with c hac hbc\n    exact ‚ü®g c, (hgle _ hbc _).1 hac, hfg _ hbc‚ü©\n\n\n"}
{"name":"Filter.map_atTop_eq_of_gc","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù¬π : PartialOrder Œ≤\ninst‚úù : IsDirected Œ≤ fun x1 x2 => LE.le x1 x2\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ±\nb : Œ≤\nhf : Monotone f\ngc : ‚àÄ (a : Œ±) (c : Œ≤), GE.ge c b ‚Üí Iff (LE.le (f a) c) (LE.le a (g c))\nhgi : ‚àÄ (c : Œ≤), GE.ge c b ‚Üí LE.le c (f (g c))\n‚ä¢ Eq (Filter.map f Filter.atTop) Filter.atTop","decl":"/-- A function `f` maps upwards closed sets (atTop sets) to upwards closed sets when it is a\nGalois insertion. The Galois \"insertion\" and \"connection\" is weakened to only require it to be an\ninsertion and a connection above `b`. -/\ntheorem map_atTop_eq_of_gc\n    [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)] [PartialOrder Œ≤] [IsDirected Œ≤ (¬∑ ‚â§ ¬∑)]\n    {f : Œ± ‚Üí Œ≤} (g : Œ≤ ‚Üí Œ±) (b : Œ≤) (hf : Monotone f)\n    (gc : ‚àÄ a, ‚àÄ c ‚â• b, f a ‚â§ c ‚Üî a ‚â§ g c) (hgi : ‚àÄ c ‚â• b, c ‚â§ f (g c)) :\n    map f atTop = atTop :=\n  map_atTop_eq_of_gc_preorder hf b fun c hc ‚Ü¶\n    ‚ü®g c, le_antisymm ((gc _ _ hc).2 le_rfl) (hgi c hc), (gc ¬∑ c hc)‚ü©\n\n"}
{"name":"Filter.map_atBot_eq_of_gc_preorder","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : IsDirected Œ≤ fun x1 x2 => GE.ge x1 x2\nf : Œ± ‚Üí Œ≤\nhf : Monotone f\nb : Œ≤\nhgi : ‚àÄ (c : Œ≤), LE.le c b ‚Üí Exists fun x => And (Eq (f x) c) (‚àÄ (a : Œ±), Iff (LE.le c (f a)) (LE.le x a))\n‚ä¢ Eq (Filter.map f Filter.atBot) Filter.atBot","decl":"theorem map_atBot_eq_of_gc_preorder\n    [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â• ¬∑)] [Preorder Œ≤] [IsDirected Œ≤ (¬∑ ‚â• ¬∑)] {f : Œ± ‚Üí Œ≤}\n    (hf : Monotone f) (b : Œ≤)\n    (hgi : ‚àÄ c ‚â§ b, ‚àÉ x, f x = c ‚àß ‚àÄ a, c ‚â§ f a ‚Üî x ‚â§ a) : map f atBot = atBot :=\n  map_atTop_eq_of_gc_preorder (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) hf.dual _ hgi\n\n"}
{"name":"Filter.map_atBot_eq_of_gc","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù¬π : PartialOrder Œ≤\ninst‚úù : IsDirected Œ≤ fun x1 x2 => GE.ge x1 x2\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ±\nb' : Œ≤\nhf : Monotone f\ngc : ‚àÄ (a : Œ±) (b : Œ≤), LE.le b b' ‚Üí Iff (LE.le b (f a)) (LE.le (g b) a)\nhgi : ‚àÄ (b : Œ≤), LE.le b b' ‚Üí LE.le (f (g b)) b\n‚ä¢ Eq (Filter.map f Filter.atBot) Filter.atBot","decl":"theorem map_atBot_eq_of_gc [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â• ¬∑)]\n    [PartialOrder Œ≤] [IsDirected Œ≤ (¬∑ ‚â• ¬∑)] {f : Œ± ‚Üí Œ≤} (g : Œ≤ ‚Üí Œ±) (b' : Œ≤)\n    (hf : Monotone f) (gc : ‚àÄ a, ‚àÄ b ‚â§ b', b ‚â§ f a ‚Üî g b ‚â§ a) (hgi : ‚àÄ b ‚â§ b', f (g b) ‚â§ b) :\n    map f atBot = atBot :=\n  map_atTop_eq_of_gc (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) _ _ hf.dual gc hgi\n\n"}
{"name":"Filter.map_val_atTop_of_Ici_subset","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\na : Œ±\ns : Set Œ±\nh : HasSubset.Subset (Set.Ici a) s\n‚ä¢ Eq (Filter.map Subtype.val Filter.atTop) Filter.atTop","decl":"theorem map_val_atTop_of_Ici_subset [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)] {a : Œ±} {s : Set Œ±}\n    (h : Ici a ‚äÜ s) : map ((‚Üë) : s ‚Üí Œ±) atTop = atTop := by\n  choose f hl hr using exists_ge_ge (Œ± := Œ±)\n  have : DirectedOn (¬∑ ‚â§ ¬∑) s := fun x _ y _ ‚Ü¶\n    ‚ü®f a (f x y), h <| hl _ _, (hl x y).trans (hr _ _), (hr x y).trans (hr _ _)‚ü©\n  have : IsDirected s (¬∑ ‚â§ ¬∑) := by\n    rw [directedOn_iff_directed] at this\n    rwa [‚Üê directed_id_iff]\n  refine map_atTop_eq_of_gc_preorder (Subtype.mono_coe _) a fun c hc ‚Ü¶ ?_\n  exact ‚ü®‚ü®c, h hc‚ü©, rfl, fun _ ‚Ü¶ .rfl‚ü©\n\n"}
{"name":"Nat.map_cast_int_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"‚ä¢ Eq (Filter.map Nat.cast Filter.atTop) Filter.atTop","decl":"@[simp]\ntheorem _root_.Nat.map_cast_int_atTop : map ((‚Üë) : ‚Ñï ‚Üí ‚Ñ§) atTop = atTop := by\n  refine map_atTop_eq_of_gc_preorder (fun _ _ ‚Ü¶ Int.ofNat_le.2) 0 fun n hn ‚Ü¶ ?_\n  lift n to ‚Ñï using hn\n  exact ‚ü®n, rfl, fun _ ‚Ü¶ Int.ofNat_le‚ü©\n\n"}
{"name":"Filter.map_val_Ici_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\na : Œ±\n‚ä¢ Eq (Filter.map Subtype.val Filter.atTop) Filter.atTop","decl":"/-- The image of the filter `atTop` on `Ici a` under the coercion equals `atTop`. -/\n@[simp]\ntheorem map_val_Ici_atTop [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)] (a : Œ±) :\n    map ((‚Üë) : Ici a ‚Üí Œ±) atTop = atTop :=\n  map_val_atTop_of_Ici_subset Subset.rfl\n\n"}
{"name":"Filter.map_val_Ioi_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù : NoMaxOrder Œ±\na : Œ±\n‚ä¢ Eq (Filter.map Subtype.val Filter.atTop) Filter.atTop","decl":"/-- The image of the filter `atTop` on `Ioi a` under the coercion equals `atTop`. -/\n@[simp]\ntheorem map_val_Ioi_atTop [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)] [NoMaxOrder Œ±] (a : Œ±) :\n    map ((‚Üë) : Ioi a ‚Üí Œ±) atTop = atTop :=\n  let ‚ü®_b, hb‚ü© := exists_gt a\n  map_val_atTop_of_Ici_subset <| Ici_subset_Ioi.2 hb\n\n"}
{"name":"Filter.atTop_Ioi_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\na : Œ±\n‚ä¢ Eq Filter.atTop (Filter.comap Subtype.val Filter.atTop)","decl":"/-- The `atTop` filter for an open interval `Ioi a` comes from the `atTop` filter in the ambient\norder. -/\ntheorem atTop_Ioi_eq [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)] (a : Œ±) :\n    atTop = comap ((‚Üë) : Ioi a ‚Üí Œ±) atTop := by\n  rcases isEmpty_or_nonempty (Ioi a) with h|‚ü®‚ü®b, hb‚ü©‚ü©\n  ¬∑ subsingleton\n  ¬∑ rw [‚Üê map_val_atTop_of_Ici_subset (Ici_subset_Ioi.2 hb), comap_map Subtype.coe_injective]\n\n"}
{"name":"Filter.atTop_Ici_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\na : Œ±\n‚ä¢ Eq Filter.atTop (Filter.comap Subtype.val Filter.atTop)","decl":"/-- The `atTop` filter for an open interval `Ici a` comes from the `atTop` filter in the ambient\norder. -/\ntheorem atTop_Ici_eq [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)] (a : Œ±) :\n    atTop = comap ((‚Üë) : Ici a ‚Üí Œ±) atTop := by\n  rw [‚Üê map_val_Ici_atTop a, comap_map Subtype.coe_injective]\n\n"}
{"name":"Filter.map_val_Iio_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù : NoMinOrder Œ±\na : Œ±\n‚ä¢ Eq (Filter.map Subtype.val Filter.atBot) Filter.atBot","decl":"/-- The `atBot` filter for an open interval `Iio a` comes from the `atBot` filter in the ambient\norder. -/\n@[simp]\ntheorem map_val_Iio_atBot [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â• ¬∑)] [NoMinOrder Œ±] (a : Œ±) :\n    map ((‚Üë) : Iio a ‚Üí Œ±) atBot = atBot :=\n  map_val_Ioi_atTop (OrderDual.toDual a)\n\n"}
{"name":"Filter.atBot_Iio_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\na : Œ±\n‚ä¢ Eq Filter.atBot (Filter.comap Subtype.val Filter.atBot)","decl":"/-- The `atBot` filter for an open interval `Iio a` comes from the `atBot` filter in the ambient\norder. -/\ntheorem atBot_Iio_eq [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â• ¬∑)] (a : Œ±) :\n    atBot = comap ((‚Üë) : Iio a ‚Üí Œ±) atBot :=\n  atTop_Ioi_eq (OrderDual.toDual a)\n\n"}
{"name":"Filter.map_val_Iic_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\na : Œ±\n‚ä¢ Eq (Filter.map Subtype.val Filter.atBot) Filter.atBot","decl":"/-- The `atBot` filter for an open interval `Iic a` comes from the `atBot` filter in the ambient\norder. -/\n@[simp]\ntheorem map_val_Iic_atBot [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â• ¬∑)] (a : Œ±) :\n    map ((‚Üë) : Iic a ‚Üí Œ±) atBot = atBot :=\n  map_val_Ici_atTop (OrderDual.toDual a)\n\n"}
{"name":"Filter.atBot_Iic_eq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\na : Œ±\n‚ä¢ Eq Filter.atBot (Filter.comap Subtype.val Filter.atBot)","decl":"/-- The `atBot` filter for an open interval `Iic a` comes from the `atBot` filter in the ambient\norder. -/\ntheorem atBot_Iic_eq [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â• ¬∑)] (a : Œ±) :\n    atBot = comap ((‚Üë) : Iic a ‚Üí Œ±) atBot :=\n  atTop_Ici_eq (OrderDual.toDual a)\n\n"}
{"name":"Filter.tendsto_Ioi_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\na : Œ±\nf : Œ≤ ‚Üí ‚Üë(Set.Ioi a)\nl : Filter Œ≤\n‚ä¢ Iff (Filter.Tendsto f l Filter.atTop) (Filter.Tendsto (fun x => ‚Üë(f x)) l Filter.atTop)","decl":"theorem tendsto_Ioi_atTop [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)]\n    {a : Œ±} {f : Œ≤ ‚Üí Ioi a} {l : Filter Œ≤} :\n    Tendsto f l atTop ‚Üî Tendsto (fun x => (f x : Œ±)) l atTop := by\n  rw [atTop_Ioi_eq, tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"Filter.tendsto_Iio_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\na : Œ±\nf : Œ≤ ‚Üí ‚Üë(Set.Iio a)\nl : Filter Œ≤\n‚ä¢ Iff (Filter.Tendsto f l Filter.atBot) (Filter.Tendsto (fun x => ‚Üë(f x)) l Filter.atBot)","decl":"theorem tendsto_Iio_atBot [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â• ¬∑)]\n    {a : Œ±} {f : Œ≤ ‚Üí Iio a} {l : Filter Œ≤} :\n    Tendsto f l atBot ‚Üî Tendsto (fun x => (f x : Œ±)) l atBot :=\n  tendsto_Ioi_atTop (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.tendsto_Ici_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\na : Œ±\nf : Œ≤ ‚Üí ‚Üë(Set.Ici a)\nl : Filter Œ≤\n‚ä¢ Iff (Filter.Tendsto f l Filter.atTop) (Filter.Tendsto (fun x => ‚Üë(f x)) l Filter.atTop)","decl":"theorem tendsto_Ici_atTop [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)]\n    {a : Œ±} {f : Œ≤ ‚Üí Ici a} {l : Filter Œ≤} :\n    Tendsto f l atTop ‚Üî Tendsto (fun x => (f x : Œ±)) l atTop := by\n  rw [atTop_Ici_eq, tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"Filter.tendsto_Iic_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\na : Œ±\nf : Œ≤ ‚Üí ‚Üë(Set.Iic a)\nl : Filter Œ≤\n‚ä¢ Iff (Filter.Tendsto f l Filter.atBot) (Filter.Tendsto (fun x => ‚Üë(f x)) l Filter.atBot)","decl":"theorem tendsto_Iic_atBot [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â• ¬∑)]\n    {a : Œ±} {f : Œ≤ ‚Üí Iic a} {l : Filter Œ≤} :\n    Tendsto f l atBot ‚Üî Tendsto (fun x => (f x : Œ±)) l atBot :=\n  tendsto_Ici_atTop (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.tendsto_comp_val_Ioi_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù : NoMaxOrder Œ±\na : Œ±\nf : Œ± ‚Üí Œ≤\nl : Filter Œ≤\n‚ä¢ Iff (Filter.Tendsto (fun x => f ‚Üëx) Filter.atTop l) (Filter.Tendsto f Filter.atTop l)","decl":"@[simp]\ntheorem tendsto_comp_val_Ioi_atTop [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)] [NoMaxOrder Œ±]\n    {a : Œ±} {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :\n    Tendsto (fun x : Ioi a => f x) atTop l ‚Üî Tendsto f atTop l := by\n  rw [‚Üê map_val_Ioi_atTop a, tendsto_map'_iff, Function.comp_def]\n\n"}
{"name":"Filter.tendsto_comp_val_Ici_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\na : Œ±\nf : Œ± ‚Üí Œ≤\nl : Filter Œ≤\n‚ä¢ Iff (Filter.Tendsto (fun x => f ‚Üëx) Filter.atTop l) (Filter.Tendsto f Filter.atTop l)","decl":"@[simp]\ntheorem tendsto_comp_val_Ici_atTop [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)]\n    {a : Œ±} {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :\n    Tendsto (fun x : Ici a => f x) atTop l ‚Üî Tendsto f atTop l := by\n  rw [‚Üê map_val_Ici_atTop a, tendsto_map'_iff, Function.comp_def]\n\n"}
{"name":"Filter.tendsto_comp_val_Iio_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù : NoMinOrder Œ±\na : Œ±\nf : Œ± ‚Üí Œ≤\nl : Filter Œ≤\n‚ä¢ Iff (Filter.Tendsto (fun x => f ‚Üëx) Filter.atBot l) (Filter.Tendsto f Filter.atBot l)","decl":"@[simp]\ntheorem tendsto_comp_val_Iio_atBot [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â• ¬∑)] [NoMinOrder Œ±]\n    {a : Œ±} {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :\n    Tendsto (fun x : Iio a => f x) atBot l ‚Üî Tendsto f atBot l :=\n  tendsto_comp_val_Ioi_atTop (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.tendsto_comp_val_Iic_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù¬π : Preorder Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\na : Œ±\nf : Œ± ‚Üí Œ≤\nl : Filter Œ≤\n‚ä¢ Iff (Filter.Tendsto (fun x => f ‚Üëx) Filter.atBot l) (Filter.Tendsto f Filter.atBot l)","decl":"@[simp]\ntheorem tendsto_comp_val_Iic_atBot [Preorder Œ±] [IsDirected Œ± (¬∑ ‚â• ¬∑)]\n    {a : Œ±} {f : Œ± ‚Üí Œ≤} {l : Filter Œ≤} :\n    Tendsto (fun x : Iic a => f x) atBot l ‚Üî Tendsto f atBot l :=\n  tendsto_comp_val_Ici_atTop (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.map_add_atTop_eq_nat","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"k : Nat\n‚ä¢ Eq (Filter.map (fun a => HAdd.hAdd a k) Filter.atTop) Filter.atTop","decl":"theorem map_add_atTop_eq_nat (k : ‚Ñï) : map (fun a => a + k) atTop = atTop :=\n  map_atTop_eq_of_gc (¬∑ - k) k (fun _ _ h => Nat.add_le_add_right h k)\n    (fun _ _ h => (Nat.le_sub_iff_add_le h).symm) fun a h => by rw [Nat.sub_add_cancel h]\n\n"}
{"name":"Filter.map_sub_atTop_eq_nat","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"k : Nat\n‚ä¢ Eq (Filter.map (fun a => HSub.hSub a k) Filter.atTop) Filter.atTop","decl":"theorem map_sub_atTop_eq_nat (k : ‚Ñï) : map (fun a => a - k) atTop = atTop :=\n  map_atTop_eq_of_gc (¬∑ + k) 0 (fun _ _ h => Nat.sub_le_sub_right h _)\n    (fun _ _ _ => Nat.sub_le_iff_le_add) fun b _ => by rw [Nat.add_sub_cancel_right]\n\n"}
{"name":"Filter.tendsto_add_atTop_nat","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"k : Nat\n‚ä¢ Filter.Tendsto (fun a => HAdd.hAdd a k) Filter.atTop Filter.atTop","decl":"theorem tendsto_add_atTop_nat (k : ‚Ñï) : Tendsto (fun a => a + k) atTop atTop :=\n  le_of_eq (map_add_atTop_eq_nat k)\n\n"}
{"name":"Filter.tendsto_sub_atTop_nat","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"k : Nat\n‚ä¢ Filter.Tendsto (fun a => HSub.hSub a k) Filter.atTop Filter.atTop","decl":"theorem tendsto_sub_atTop_nat (k : ‚Ñï) : Tendsto (fun a => a - k) atTop atTop :=\n  le_of_eq (map_sub_atTop_eq_nat k)\n\n"}
{"name":"Filter.tendsto_add_atTop_iff_nat","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nf : Nat ‚Üí Œ±\nl : Filter Œ±\nk : Nat\n‚ä¢ Iff (Filter.Tendsto (fun n => f (HAdd.hAdd n k)) Filter.atTop l) (Filter.Tendsto f Filter.atTop l)","decl":"theorem tendsto_add_atTop_iff_nat {f : ‚Ñï ‚Üí Œ±} {l : Filter Œ±} (k : ‚Ñï) :\n    Tendsto (fun n => f (n + k)) atTop l ‚Üî Tendsto f atTop l :=\n  show Tendsto (f ‚àò fun n => n + k) atTop l ‚Üî Tendsto f atTop l by\n    rw [‚Üê tendsto_map'_iff, map_add_atTop_eq_nat]\n\n"}
{"name":"Filter.map_div_atTop_eq_nat","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"k : Nat\nhk : LT.lt 0 k\n‚ä¢ Eq (Filter.map (fun a => HDiv.hDiv a k) Filter.atTop) Filter.atTop","decl":"theorem map_div_atTop_eq_nat (k : ‚Ñï) (hk : 0 < k) : map (fun a => a / k) atTop = atTop :=\n  map_atTop_eq_of_gc (fun b => k * b + (k - 1)) 1 (fun _ _ h => Nat.div_le_div_right h)\n    -- Porting note: there was a parse error in `calc`, use `simp` instead\n    (fun a b _ => by rw [Nat.div_le_iff_le_mul_add_pred hk])\n    fun b _ => by rw [Nat.mul_add_div hk, Nat.div_eq_of_lt, add_zero]; omega\n\n"}
{"name":"Filter.tendsto_atTop_atTop_of_monotone'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œπ : Type u_1\nŒ± : Type u_3\ninst‚úù¬π : Preorder Œπ\ninst‚úù : LinearOrder Œ±\nu : Œπ ‚Üí Œ±\nh : Monotone u\nH : Not (BddAbove (Set.range u))\n‚ä¢ Filter.Tendsto u Filter.atTop Filter.atTop","decl":"/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded\nabove, then `Tendsto u atTop atTop`. -/\ntheorem tendsto_atTop_atTop_of_monotone' [Preorder Œπ] [LinearOrder Œ±] {u : Œπ ‚Üí Œ±} (h : Monotone u)\n    (H : ¬¨BddAbove (range u)) : Tendsto u atTop atTop := by\n  apply h.tendsto_atTop_atTop\n  intro b\n  rcases not_bddAbove_iff.1 H b with ‚ü®_, ‚ü®N, rfl‚ü©, hN‚ü©\n  exact ‚ü®N, le_of_lt hN‚ü©\n\n"}
{"name":"Filter.tendsto_atBot_atBot_of_monotone'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œπ : Type u_1\nŒ± : Type u_3\ninst‚úù¬π : Preorder Œπ\ninst‚úù : LinearOrder Œ±\nu : Œπ ‚Üí Œ±\nh : Monotone u\nH : Not (BddBelow (Set.range u))\n‚ä¢ Filter.Tendsto u Filter.atBot Filter.atBot","decl":"/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded\nbelow, then `Tendsto u atBot atBot`. -/\ntheorem tendsto_atBot_atBot_of_monotone' [Preorder Œπ] [LinearOrder Œ±] {u : Œπ ‚Üí Œ±} (h : Monotone u)\n    (H : ¬¨BddBelow (range u)) : Tendsto u atBot atBot :=\n  @tendsto_atTop_atTop_of_monotone' Œπ·µí·µà Œ±·µí·µà _ _ _ h.dual H\n\n"}
{"name":"Filter.unbounded_of_tendsto_atTop","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù‚Å¥ : Nonempty Œ±\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù¬π : Preorder Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : NoMaxOrder Œ≤\nh : Filter.Tendsto f Filter.atTop Filter.atTop\n‚ä¢ Not (BddAbove (Set.range f))","decl":"theorem unbounded_of_tendsto_atTop [NoMaxOrder Œ≤] (h : Tendsto f atTop atTop) :\n    ¬¨BddAbove (range f) := by\n  rintro ‚ü®M, hM‚ü©\n  cases' mem_atTop_sets.mp (h <| Ioi_mem_atTop M) with a ha\n  apply lt_irrefl M\n  calc\n    M < f a := ha a le_rfl\n    _ ‚â§ M := hM (Set.mem_range_self a)\n\n"}
{"name":"Filter.unbounded_of_tendsto_atBot","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù‚Å¥ : Nonempty Œ±\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù¬π : Preorder Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : NoMinOrder Œ≤\nh : Filter.Tendsto f Filter.atTop Filter.atBot\n‚ä¢ Not (BddBelow (Set.range f))","decl":"theorem unbounded_of_tendsto_atBot [NoMinOrder Œ≤] (h : Tendsto f atTop atBot) :\n    ¬¨BddBelow (range f) := unbounded_of_tendsto_atTop (Œ≤ := Œ≤·µí·µà) h\n\n"}
{"name":"Filter.unbounded_of_tendsto_atTop'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù‚Å¥ : Nonempty Œ±\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù¬π : Preorder Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : NoMaxOrder Œ≤\nh : Filter.Tendsto f Filter.atBot Filter.atTop\n‚ä¢ Not (BddAbove (Set.range f))","decl":"theorem unbounded_of_tendsto_atTop' [NoMaxOrder Œ≤] (h : Tendsto f atBot atTop) :\n    ¬¨BddAbove (range f) := unbounded_of_tendsto_atTop (Œ± := Œ±·µí·µà) h\n\n"}
{"name":"Filter.unbounded_of_tendsto_atBot'","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nŒ≤ : Type u_4\ninst‚úù‚Å¥ : Nonempty Œ±\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù¬π : Preorder Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : NoMinOrder Œ≤\nh : Filter.Tendsto f Filter.atBot Filter.atBot\n‚ä¢ Not (BddBelow (Set.range f))","decl":"theorem unbounded_of_tendsto_atBot' [NoMinOrder Œ≤] (h : Tendsto f atBot atBot) :\n    ¬¨BddBelow (range f) := unbounded_of_tendsto_atTop (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) h\n\n"}
{"name":"Filter.tendsto_atTop_of_monotone_of_filter","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œπ : Type u_1\nŒ± : Type u_3\ninst‚úù¬≤ : Preorder Œπ\ninst‚úù¬π : Preorder Œ±\nl : Filter Œπ\nu : Œπ ‚Üí Œ±\nh : Monotone u\ninst‚úù : l.NeBot\nhu : Filter.Tendsto u l Filter.atTop\n‚ä¢ Filter.Tendsto u Filter.atTop Filter.atTop","decl":"/-- If a monotone function `u : Œπ ‚Üí Œ±` tends to `atTop` along *some* non-trivial filter `l`, then\nit tends to `atTop` along `atTop`. -/\ntheorem tendsto_atTop_of_monotone_of_filter [Preorder Œπ] [Preorder Œ±] {l : Filter Œπ} {u : Œπ ‚Üí Œ±}\n    (h : Monotone u) [NeBot l] (hu : Tendsto u l atTop) : Tendsto u atTop atTop :=\n  h.tendsto_atTop_atTop fun b => (hu.eventually (mem_atTop b)).exists\n\n"}
{"name":"Filter.tendsto_atBot_of_monotone_of_filter","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œπ : Type u_1\nŒ± : Type u_3\ninst‚úù¬≤ : Preorder Œπ\ninst‚úù¬π : Preorder Œ±\nl : Filter Œπ\nu : Œπ ‚Üí Œ±\nh : Monotone u\ninst‚úù : l.NeBot\nhu : Filter.Tendsto u l Filter.atBot\n‚ä¢ Filter.Tendsto u Filter.atBot Filter.atBot","decl":"/-- If a monotone function `u : Œπ ‚Üí Œ±` tends to `atBot` along *some* non-trivial filter `l`, then\nit tends to `atBot` along `atBot`. -/\ntheorem tendsto_atBot_of_monotone_of_filter [Preorder Œπ] [Preorder Œ±] {l : Filter Œπ} {u : Œπ ‚Üí Œ±}\n    (h : Monotone u) [NeBot l] (hu : Tendsto u l atBot) : Tendsto u atBot atBot :=\n  @tendsto_atTop_of_monotone_of_filter Œπ·µí·µà Œ±·µí·µà _ _ _ _ h.dual _ hu\n\n"}
{"name":"Filter.tendsto_atTop_of_monotone_of_subseq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nŒ± : Type u_3\ninst‚úù¬≤ : Preorder Œπ\ninst‚úù¬π : Preorder Œ±\nu : Œπ ‚Üí Œ±\nœÜ : Œπ' ‚Üí Œπ\nh : Monotone u\nl : Filter Œπ'\ninst‚úù : l.NeBot\nH : Filter.Tendsto (Function.comp u œÜ) l Filter.atTop\n‚ä¢ Filter.Tendsto u Filter.atTop Filter.atTop","decl":"theorem tendsto_atTop_of_monotone_of_subseq [Preorder Œπ] [Preorder Œ±] {u : Œπ ‚Üí Œ±} {œÜ : Œπ' ‚Üí Œπ}\n    (h : Monotone u) {l : Filter Œπ'} [NeBot l] (H : Tendsto (u ‚àò œÜ) l atTop) :\n    Tendsto u atTop atTop :=\n  tendsto_atTop_of_monotone_of_filter h (tendsto_map' H)\n\n"}
{"name":"Filter.tendsto_atBot_of_monotone_of_subseq","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nŒ± : Type u_3\ninst‚úù¬≤ : Preorder Œπ\ninst‚úù¬π : Preorder Œ±\nu : Œπ ‚Üí Œ±\nœÜ : Œπ' ‚Üí Œπ\nh : Monotone u\nl : Filter Œπ'\ninst‚úù : l.NeBot\nH : Filter.Tendsto (Function.comp u œÜ) l Filter.atBot\n‚ä¢ Filter.Tendsto u Filter.atBot Filter.atBot","decl":"theorem tendsto_atBot_of_monotone_of_subseq [Preorder Œπ] [Preorder Œ±] {u : Œπ ‚Üí Œ±} {œÜ : Œπ' ‚Üí Œπ}\n    (h : Monotone u) {l : Filter Œπ'} [NeBot l] (H : Tendsto (u ‚àò œÜ) l atBot) :\n    Tendsto u atBot atBot :=\n  tendsto_atBot_of_monotone_of_filter h (tendsto_map' H)\n\n"}
{"name":"Filter.HasAntitoneBasis.eventually_subset","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œπ : Type u_1\nŒ± : Type u_3\ninst‚úù : Preorder Œπ\nl : Filter Œ±\ns : Œπ ‚Üí Set Œ±\nhl : l.HasAntitoneBasis s\nt : Set Œ±\nht : Membership.mem l t\n‚ä¢ Filter.Eventually (fun i => HasSubset.Subset (s i) t) Filter.atTop","decl":"theorem HasAntitoneBasis.eventually_subset [Preorder Œπ] {l : Filter Œ±} {s : Œπ ‚Üí Set Œ±}\n    (hl : l.HasAntitoneBasis s) {t : Set Œ±} (ht : t ‚àà l) : ‚àÄ·∂† i in atTop, s i ‚äÜ t :=\n  let ‚ü®i, _, hi‚ü© := hl.1.mem_iff.1 ht\n  (eventually_ge_atTop i).mono fun _j hj => (hl.antitone hj).trans hi\n\n"}
{"name":"Filter.HasAntitoneBasis.tendsto","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œπ : Type u_1\nŒ± : Type u_3\ninst‚úù : Preorder Œπ\nl : Filter Œ±\ns : Œπ ‚Üí Set Œ±\nhl : l.HasAntitoneBasis s\nœÜ : Œπ ‚Üí Œ±\nh : ‚àÄ (i : Œπ), Membership.mem (s i) (œÜ i)\n‚ä¢ Filter.Tendsto œÜ Filter.atTop l","decl":"protected theorem HasAntitoneBasis.tendsto [Preorder Œπ] {l : Filter Œ±} {s : Œπ ‚Üí Set Œ±}\n    (hl : l.HasAntitoneBasis s) {œÜ : Œπ ‚Üí Œ±} (h : ‚àÄ i : Œπ, œÜ i ‚àà s i) : Tendsto œÜ atTop l :=\n  fun _t ht => mem_map.2 <| (hl.eventually_subset ht).mono fun i hi => hi (h i)\n\n"}
{"name":"Filter.HasAntitoneBasis.comp_mono","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nŒ± : Type u_3\ninst‚úù¬≥ : Nonempty Œπ\ninst‚úù¬≤ : Preorder Œπ\ninst‚úù¬π : IsDirected Œπ fun x1 x2 => LE.le x1 x2\ninst‚úù : Preorder Œπ'\nl : Filter Œ±\ns : Œπ' ‚Üí Set Œ±\nhs : l.HasAntitoneBasis s\nœÜ : Œπ ‚Üí Œπ'\nœÜ_mono : Monotone œÜ\nhœÜ : Filter.Tendsto œÜ Filter.atTop Filter.atTop\n‚ä¢ l.HasAntitoneBasis (Function.comp s œÜ)","decl":"theorem HasAntitoneBasis.comp_mono [Nonempty Œπ] [Preorder Œπ] [IsDirected Œπ (¬∑ ‚â§ ¬∑)] [Preorder Œπ']\n    {l : Filter Œ±}\n    {s : Œπ' ‚Üí Set Œ±} (hs : l.HasAntitoneBasis s) {œÜ : Œπ ‚Üí Œπ'} (œÜ_mono : Monotone œÜ)\n    (hœÜ : Tendsto œÜ atTop atTop) : l.HasAntitoneBasis (s ‚àò œÜ) :=\n  ‚ü®hs.1.to_hasBasis\n      (fun n _ => (hœÜ.eventually_ge_atTop n).exists.imp fun _m hm => ‚ü®trivial, hs.antitone hm‚ü©)\n      fun n _ => ‚ü®œÜ n, trivial, Subset.rfl‚ü©,\n    hs.antitone.comp_monotone œÜ_mono‚ü©\n\n"}
{"name":"Filter.HasAntitoneBasis.comp_strictMono","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nl : Filter Œ±\ns : Nat ‚Üí Set Œ±\nhs : l.HasAntitoneBasis s\nœÜ : Nat ‚Üí Nat\nhœÜ : StrictMono œÜ\n‚ä¢ l.HasAntitoneBasis (Function.comp s œÜ)","decl":"theorem HasAntitoneBasis.comp_strictMono {l : Filter Œ±} {s : ‚Ñï ‚Üí Set Œ±} (hs : l.HasAntitoneBasis s)\n    {œÜ : ‚Ñï ‚Üí ‚Ñï} (hœÜ : StrictMono œÜ) : l.HasAntitoneBasis (s ‚àò œÜ) :=\n  hs.comp_mono hœÜ.monotone hœÜ.tendsto_atTop\n\n"}
{"name":"Filter.HasAntitoneBasis.subbasis_with_rel","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\ns : Nat ‚Üí Set Œ±\nhs : f.HasAntitoneBasis s\nr : Nat ‚Üí Nat ‚Üí Prop\nhr : ‚àÄ (m : Nat), Filter.Eventually (fun n => r m n) Filter.atTop\n‚ä¢ Exists fun œÜ => And (StrictMono œÜ) (And (‚àÄ ‚¶Ém n : Nat‚¶Ñ, LT.lt m n ‚Üí r (œÜ m) (œÜ n)) (f.HasAntitoneBasis (Function.comp s œÜ)))","decl":"/-- Given an antitone basis `s : ‚Ñï ‚Üí Set Œ±` of a filter, extract an antitone subbasis `s ‚àò œÜ`,\n`œÜ : ‚Ñï ‚Üí ‚Ñï`, such that `m < n` implies `r (œÜ m) (œÜ n)`. This lemma can be used to extract an\nantitone basis with basis sets decreasing \"sufficiently fast\". -/\ntheorem HasAntitoneBasis.subbasis_with_rel {f : Filter Œ±} {s : ‚Ñï ‚Üí Set Œ±}\n    (hs : f.HasAntitoneBasis s) {r : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (hr : ‚àÄ m, ‚àÄ·∂† n in atTop, r m n) :\n    ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß (‚àÄ ‚¶Ém n‚¶Ñ, m < n ‚Üí r (œÜ m) (œÜ n)) ‚àß f.HasAntitoneBasis (s ‚àò œÜ) := by\n  rsuffices ‚ü®œÜ, hœÜ, hrœÜ‚ü© : ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, StrictMono œÜ ‚àß ‚àÄ m n, m < n ‚Üí r (œÜ m) (œÜ n)\n  ¬∑ exact ‚ü®œÜ, hœÜ, hrœÜ, hs.comp_strictMono hœÜ‚ü©\n  have : ‚àÄ t : Set ‚Ñï, t.Finite ‚Üí ‚àÄ·∂† n in atTop, ‚àÄ m ‚àà t, m < n ‚àß r m n := fun t ht =>\n    (eventually_all_finite ht).2 fun m _ => (eventually_gt_atTop m).and (hr _)\n  rcases seq_of_forall_finite_exists fun t ht => (this t ht).exists with ‚ü®œÜ, hœÜ‚ü©\n  simp only [forall_mem_image, forall_and, mem_Iio] at hœÜ\n  exact ‚ü®œÜ, forall_swap.2 hœÜ.1, forall_swap.2 hœÜ.2‚ü©\n\n"}
{"name":"Filter.subseq_forall_of_frequently","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œπ : Type u_6\nx : Nat ‚Üí Œπ\np : Œπ ‚Üí Prop\nl : Filter Œπ\nh_tendsto : Filter.Tendsto x Filter.atTop l\nh : Filter.Frequently (fun n => p (x n)) Filter.atTop\n‚ä¢ Exists fun ns => And (Filter.Tendsto (fun n => x (ns n)) Filter.atTop l) (‚àÄ (n : Nat), p (x (ns n)))","decl":"theorem subseq_forall_of_frequently {Œπ : Type*} {x : ‚Ñï ‚Üí Œπ} {p : Œπ ‚Üí Prop} {l : Filter Œπ}\n    (h_tendsto : Tendsto x atTop l) (h : ‚àÉ·∂† n in atTop, p (x n)) :\n    ‚àÉ ns : ‚Ñï ‚Üí ‚Ñï, Tendsto (fun n => x (ns n)) atTop l ‚àß ‚àÄ n, p (x (ns n)) := by\n  choose ns hge hns using frequently_atTop.1 h\n  exact ‚ü®ns, h_tendsto.comp (tendsto_atTop_mono hge tendsto_id), hns‚ü©\n\n"}
{"name":"Monotone.piecewise_eventually_eq_iUnion","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œπ : Type u_1\nŒ± : Type u_3\nŒ≤ : Œ± ‚Üí Type u_6\ninst‚úù¬≤ : Preorder Œπ\ns : Œπ ‚Üí Set Œ±\ninst‚úù¬π : (i : Œπ) ‚Üí DecidablePred fun x => Membership.mem (s i) x\ninst‚úù : DecidablePred fun x => Membership.mem (Set.iUnion fun i => s i) x\nhs : Monotone s\nf g : (a : Œ±) ‚Üí Œ≤ a\na : Œ±\n‚ä¢ Filter.Eventually (fun i => Eq ((s i).piecewise f g a) ((Set.iUnion fun i => s i).piecewise f g a)) Filter.atTop","decl":"theorem Monotone.piecewise_eventually_eq_iUnion {Œ≤ : Œ± ‚Üí Type*} [Preorder Œπ] {s : Œπ ‚Üí Set Œ±}\n    [‚àÄ i, DecidablePred (¬∑ ‚àà s i)] [DecidablePred (¬∑ ‚àà ‚ãÉ i, s i)]\n    (hs : Monotone s) (f g : (a : Œ±) ‚Üí Œ≤ a) (a : Œ±) :\n    ‚àÄ·∂† i in atTop, (s i).piecewise f g a = (‚ãÉ i, s i).piecewise f g a := by\n  rcases em (‚àÉ i, a ‚àà s i) with ‚ü®i, hi‚ü© | ha\n  ¬∑ refine (eventually_ge_atTop i).mono fun j hij ‚Ü¶ ?_\n    simp only [Set.piecewise_eq_of_mem, hs hij hi, subset_iUnion _ _ hi]\n  ¬∑ filter_upwards with i\n    simp only [Set.piecewise_eq_of_not_mem, not_exists.1 ha i, mt mem_iUnion.1 ha,\n      not_false_eq_true, exists_false]\n\n"}
{"name":"Antitone.piecewise_eventually_eq_iInter","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"Œπ : Type u_1\nŒ± : Type u_3\nŒ≤ : Œ± ‚Üí Type u_6\ninst‚úù¬≤ : Preorder Œπ\ns : Œπ ‚Üí Set Œ±\ninst‚úù¬π : (i : Œπ) ‚Üí DecidablePred fun x => Membership.mem (s i) x\ninst‚úù : DecidablePred fun x => Membership.mem (Set.iInter fun i => s i) x\nhs : Antitone s\nf g : (a : Œ±) ‚Üí Œ≤ a\na : Œ±\n‚ä¢ Filter.Eventually (fun i => Eq ((s i).piecewise f g a) ((Set.iInter fun i => s i).piecewise f g a)) Filter.atTop","decl":"theorem Antitone.piecewise_eventually_eq_iInter {Œ≤ : Œ± ‚Üí Type*} [Preorder Œπ] {s : Œπ ‚Üí Set Œ±}\n    [‚àÄ i, DecidablePred (¬∑ ‚àà s i)] [DecidablePred (¬∑ ‚àà ‚ãÇ i, s i)]\n    (hs : Antitone s) (f g : (a : Œ±) ‚Üí Œ≤ a) (a : Œ±) :\n    ‚àÄ·∂† i in atTop, (s i).piecewise f g a = (‚ãÇ i, s i).piecewise f g a := by\n  classical\n  convert ‚Üê (compl_anti.comp hs).piecewise_eventually_eq_iUnion g f a using 3\n  ¬∑ convert congr_fun (Set.piecewise_compl (s _) g f) a\n  ¬∑ simp only [(¬∑ ‚àò ¬∑), ‚Üê compl_iInter, Set.piecewise_compl]\n\n"}
{"name":"Nat.eventually_pow_lt_factorial_sub","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"c d : Nat\n‚ä¢ Filter.Eventually (fun n => LT.lt (HPow.hPow c n) (HSub.hSub n d).factorial) Filter.atTop","decl":"theorem eventually_pow_lt_factorial_sub (c d : ‚Ñï) : ‚àÄ·∂† n in atTop, c ^ n < (n - d)! := by\n  rw [eventually_atTop]\n  refine ‚ü®2 * (c ^ 2 + d + 1), ?_‚ü©\n  intro n hn\n  obtain ‚ü®d', rfl‚ü© := Nat.exists_eq_add_of_le hn\n  obtain (rfl | c0) := c.eq_zero_or_pos\n  ¬∑ simp [Nat.two_mul, ‚Üê Nat.add_assoc, Nat.add_right_comm _ 1, Nat.factorial_pos]\n  refine (Nat.le_mul_of_pos_right _ (Nat.pow_pos (n := d') c0)).trans_lt ?_\n  convert_to (c ^ 2) ^ (c ^ 2 + d' + d + 1) < (c ^ 2 + (c ^ 2 + d' + d + 1) + 1)!\n  ¬∑ rw [‚Üê pow_mul, ‚Üê pow_add]\n    congr 1\n    omega\n  ¬∑ congr 1\n    omega\n  refine (lt_of_lt_of_le ?_ Nat.factorial_mul_pow_le_factorial).trans_le <|\n    (factorial_le (Nat.le_succ _))\n  rw [‚Üê one_mul (_ ^ _ : ‚Ñï)]\n  apply Nat.mul_lt_mul_of_le_of_lt\n  ¬∑ exact Nat.one_le_of_lt (Nat.factorial_pos _)\n  ¬∑ exact Nat.pow_lt_pow_left (Nat.lt_succ_self _) (Nat.succ_ne_zero _)\n  ¬∑ exact (Nat.factorial_pos _)\n\n"}
{"name":"Nat.eventually_mul_pow_lt_factorial_sub","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"a c d : Nat\n‚ä¢ Filter.Eventually (fun n => LT.lt (HMul.hMul a (HPow.hPow c n)) (HSub.hSub n d).factorial) Filter.atTop","decl":"theorem eventually_mul_pow_lt_factorial_sub (a c d : ‚Ñï) :\n    ‚àÄ·∂† n in atTop, a * c ^ n < (n - d)! := by\n  filter_upwards [Nat.eventually_pow_lt_factorial_sub (a * c) d, Filter.eventually_gt_atTop 0]\n    with n hn hn0\n  rw [mul_pow] at hn\n  exact (Nat.mul_le_mul_right _ (Nat.le_self_pow hn0.ne' _)).trans_lt hn\n\n"}
{"name":"Nat.exists_pow_lt_factorial","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"c : Nat\n‚ä¢ Exists fun n0 => And (GT.gt n0 1) (‚àÄ (n : Nat), GE.ge n n0 ‚Üí LT.lt (HPow.hPow c n) (HSub.hSub n 1).factorial)","decl":"@[deprecated eventually_pow_lt_factorial_sub (since := \"2024-09-25\")]\ntheorem exists_pow_lt_factorial (c : ‚Ñï) : ‚àÉ n0 > 1, ‚àÄ n ‚â• n0, c ^ n < (n - 1)! :=\n  let ‚ü®n0, h‚ü© := (eventually_pow_lt_factorial_sub c 1).exists_forall_of_atTop\n  ‚ü®max n0 2, by omega, fun n hn ‚Ü¶ h n (by omega)‚ü©\n\n"}
{"name":"Nat.exists_mul_pow_lt_factorial","module":"Mathlib.Order.Filter.AtTopBot","initialProofState":"a c : Nat\n‚ä¢ Exists fun n0 => ‚àÄ (n : Nat), GE.ge n n0 ‚Üí LT.lt (HMul.hMul a (HPow.hPow c n)) (HSub.hSub n 1).factorial","decl":"@[deprecated eventually_mul_pow_lt_factorial_sub (since := \"2024-09-25\")]\ntheorem exists_mul_pow_lt_factorial (a : ‚Ñï) (c : ‚Ñï) : ‚àÉ n0, ‚àÄ n ‚â• n0, a * c ^ n < (n - 1)! :=\n  (eventually_mul_pow_lt_factorial_sub a c 1).exists_forall_of_atTop\n\n"}
