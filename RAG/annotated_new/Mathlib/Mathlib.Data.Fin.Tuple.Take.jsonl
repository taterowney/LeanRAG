{"name":"Fin.take_apply","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n : Nat\nα : Fin n → Sort u_1\nm : Nat\nh : LE.le m n\nv : (i : Fin n) → α i\ni : Fin m\n⊢ Eq (Fin.take m h v i) (v (Fin.castLE h i))","decl":"@[simp]\ntheorem take_apply (m : ℕ) (h : m ≤ n) (v : (i : Fin n) → α i) (i : Fin m) :\n    (take m h v) i = v (castLE h i) := rfl\n\n"}
{"name":"Fin.take_zero","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n : Nat\nα : Fin n → Sort u_1\nv : (i : Fin n) → α i\n⊢ Eq (Fin.take 0 ⋯ v) fun i => i.elim0","decl":"@[simp]\ntheorem take_zero (v : (i : Fin n) → α i) : take 0 n.zero_le v = fun i ↦ elim0 i := by\n  ext i; exact elim0 i\n\n"}
{"name":"Fin.take_one","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_2\nv : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq (Fin.take 1 ⋯ v) fun i => v (Fin.castLE ⋯ i)","decl":"@[simp]\ntheorem take_one {α : Fin (n + 1) → Sort*} (v : (i : Fin (n + 1)) → α i) :\n    take 1 (Nat.le_add_left 1 n) v = (fun i => v (castLE (Nat.le_add_left 1 n) i)) := by\n  ext i\n  simp only [take]\n\n"}
{"name":"Fin.take_eq_init","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_2\nv : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq (Fin.take n ⋯ v) (Fin.init v)","decl":"@[simp]\ntheorem take_eq_init {α : Fin (n + 1) → Sort*} (v : (i : Fin (n + 1)) → α i) :\n    take n n.le_succ v = init v := by\n  ext i\n  simp only [Nat.succ_eq_add_one, take, init]\n  congr\n\n"}
{"name":"Fin.take_eq_self","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n : Nat\nα : Fin n → Sort u_1\nv : (i : Fin n) → α i\n⊢ Eq (Fin.take n ⋯ v) v","decl":"@[simp]\ntheorem take_eq_self (v : (i : Fin n) → α i) : take n (le_refl n) v = v := by\n  ext i\n  simp [take]\n\n"}
{"name":"Fin.take_take","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n : Nat\nα : Fin n → Sort u_1\nm n' : Nat\nh : LE.le m n'\nh' : LE.le n' n\nv : (i : Fin n) → α i\n⊢ Eq (Fin.take m h (Fin.take n' h' v)) (Fin.take m ⋯ v)","decl":"@[simp]\ntheorem take_take {m n' : ℕ} (h : m ≤ n') (h' : n' ≤ n) (v : (i : Fin n) → α i) :\n    take m h (take n' h' v) = take m (Nat.le_trans h h') v := by\n  ext i\n  simp only [take]\n  congr\n\n"}
{"name":"Fin.take_init","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_2\nm : Nat\nh : LE.le m n\nv : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq (Fin.take m h (Fin.init v)) (Fin.take m ⋯ v)","decl":"@[simp]\ntheorem take_init {α : Fin (n + 1) → Sort*} (m : ℕ) (h : m ≤ n) (v : (i : Fin (n + 1)) → α i) :\n    take m h (init v) = take m (Nat.le_succ_of_le h) v := by\n  ext i\n  simp only [take, init]\n  congr\n\n"}
{"name":"Fin.take_repeat","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n : Nat\nα : Type u_2\nn' m : Nat\nh : LE.le m n\na : Fin n' → α\n⊢ Eq (Fin.take (HMul.hMul m n') ⋯ (Fin.repeat n a)) (Fin.repeat m a)","decl":"theorem take_repeat {α : Type*} {n' : ℕ} (m : ℕ) (h : m ≤ n) (a : Fin n' → α) :\n    take (m * n') (Nat.mul_le_mul_right n' h) (Fin.repeat n a) = Fin.repeat m a := by\n  ext i\n  simp only [take, repeat_apply, modNat, coe_castLE]\n\n"}
{"name":"Fin.take_succ_eq_snoc","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n : Nat\nα : Fin n → Sort u_1\nm : Nat\nh : LT.lt m n\nv : (i : Fin n) → α i\n⊢ Eq (Fin.take m.succ h v) (Fin.snoc (Fin.take m ⋯ v) (v ⟨m, h⟩))","decl":"/-- Taking `m + 1` elements is equal to taking `m` elements and adding the `(m + 1)`th one. -/\ntheorem take_succ_eq_snoc (m : ℕ) (h : m < n) (v : (i : Fin n) → α i) :\n    take m.succ h v = snoc (take m h.le v) (v ⟨m, h⟩) := by\n  ext i\n  induction m with\n  | zero =>\n    have h' : i = 0 := by ext; simp\n    subst h'\n    simp [take, snoc, castLE]\n  | succ m _ =>\n    induction i using reverseInduction with\n    | last => simp [take, snoc, castLT]; congr\n    | cast i _ => simp [snoc_cast_add]\n\n"}
{"name":"Fin.take_update_of_lt","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n : Nat\nα : Fin n → Sort u_1\nm : Nat\nh : LE.le m n\nv : (i : Fin n) → α i\ni : Fin m\nx : α (Fin.castLE h i)\n⊢ Eq (Fin.take m h (Function.update v (Fin.castLE h i) x)) (Function.update (Fin.take m h v) i x)","decl":"/-- `take` commutes with `update` for indices in the range of `take`. -/\n@[simp]\ntheorem take_update_of_lt (m : ℕ) (h : m ≤ n) (v : (i : Fin n) → α i) (i : Fin m)\n    (x : α (castLE h i)) : take m h (update v (castLE h i) x) = update (take m h v) i x := by\n  ext j\n  by_cases h' : j = i\n  · rw [h']\n    simp only [take, update_self]\n  · have : castLE h j ≠ castLE h i := by simp [h']\n    simp only [take, update_of_ne h', update_of_ne this]\n\n"}
{"name":"Fin.take_update_of_ge","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n : Nat\nα : Fin n → Sort u_1\nm : Nat\nh : LE.le m n\nv : (i : Fin n) → α i\ni : Fin n\nhi : GE.ge (↑i) m\nx : α i\n⊢ Eq (Fin.take m h (Function.update v i x)) (Fin.take m h v)","decl":"/-- `take` is the same after `update` for indices outside the range of `take`. -/\n@[simp]\ntheorem take_update_of_ge (m : ℕ) (h : m ≤ n) (v : (i : Fin n) → α i) (i : Fin n) (hi : i ≥ m)\n    (x : α i) : take m h (update v i x) = take m h v := by\n  ext j\n  have : castLE h j ≠ i := by\n    refine ne_of_val_ne ?_\n    simp only [coe_castLE]\n    exact Nat.ne_of_lt (lt_of_lt_of_le j.isLt hi)\n  simp only [take, update_of_ne this]\n\n"}
{"name":"Fin.take_addCases_left","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n n' : Nat\nmotive : Fin (HAdd.hAdd n n') → Sort u_2\nm : Nat\nh : LE.le m n\nu : (i : Fin n) → motive (Fin.castAdd n' i)\nv : (i : Fin n') → motive (Fin.natAdd n i)\n⊢ Eq (Fin.take m ⋯ fun i => Fin.addCases u v i) (Fin.take m h u)","decl":"/-- Taking the first `m ≤ n` elements of an `addCases u v`, where `u` is a `n`-tuple, is the same as\ntaking the first `m` elements of `u`. -/\ntheorem take_addCases_left {n' : ℕ} {motive : Fin (n + n') → Sort*} (m : ℕ) (h : m ≤ n)\n    (u : (i : Fin n) → motive (castAdd n' i)) (v : (i : Fin n') → motive (natAdd n i)) :\n      take m (Nat.le_add_right_of_le h) (addCases u v) = take m h u := by\n  ext i\n  have : i < n := Nat.lt_of_lt_of_le i.isLt h\n  simp only [take, addCases, this, coe_castLE, ↓reduceDIte]\n  congr\n\n"}
{"name":"Fin.take_append_left","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n n' : Nat\nα : Sort u_2\nm : Nat\nh : LE.le m n\nu : Fin n → α\nv : Fin n' → α\n⊢ Eq (Fin.take m ⋯ (Fin.append u v)) (Fin.take m h u)","decl":"/-- Version of `take_addCases_left` that specializes `addCases` to `append`. -/\ntheorem take_append_left {n' : ℕ} {α : Sort*} (m : ℕ) (h : m ≤ n) (u : (i : Fin n) → α)\n    (v : (i : Fin n') → α) : take m (Nat.le_add_right_of_le h) (append u v) = take m h u :=\n  take_addCases_left m h _ _\n\n"}
{"name":"Fin.take_addCases_right","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n n' : Nat\nmotive : Fin (HAdd.hAdd n n') → Sort u_2\nm : Nat\nh : LE.le m n'\nu : (i : Fin n) → motive (Fin.castAdd n' i)\nv : (i : Fin n') → motive (Fin.natAdd n i)\n⊢ Eq (Fin.take (HAdd.hAdd n m) ⋯ fun i => Fin.addCases u v i) fun i => Fin.addCases u (Fin.take m h v) i","decl":"/-- Taking the first `n + m` elements of an `addCases u v`, where `v` is a `n'`-tuple and `m ≤ n'`,\nis the same as appending `u` with the first `m` elements of `v`. -/\ntheorem take_addCases_right {n' : ℕ} {motive : Fin (n + n') → Sort*} (m : ℕ) (h : m ≤ n')\n    (u : (i : Fin n) → motive (castAdd n' i)) (v : (i : Fin n') → motive (natAdd n i)) :\n      take (n + m) (Nat.add_le_add_left h n) (addCases u v) = addCases u (take m h v) := by\n  ext i\n  simp only [take, addCases, coe_castLE]\n  by_cases h' : i < n\n  · simp only [h', ↓reduceDIte]\n    congr\n  · simp only [h', ↓reduceDIte, subNat, castLE, Fin.cast, eqRec_eq_cast]\n\n"}
{"name":"Fin.take_append_right","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n n' : Nat\nα : Sort u_2\nm : Nat\nh : LE.le m n'\nu : Fin n → α\nv : Fin n' → α\n⊢ Eq (Fin.take (HAdd.hAdd n m) ⋯ (Fin.append u v)) (Fin.append u (Fin.take m h v))","decl":"/-- Version of `take_addCases_right` that specializes `addCases` to `append`. -/\ntheorem take_append_right {n' : ℕ} {α : Sort*} (m : ℕ) (h : m ≤ n') (u : (i : Fin n) → α)\n    (v : (i : Fin n') → α) : take (n + m) (Nat.add_le_add_left h n) (append u v)\n        = append u (take m h v) :=\n  take_addCases_right m h _ _\n\n"}
{"name":"Fin.ofFn_take_eq_take_ofFn","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n : Nat\nα : Type u_2\nm : Nat\nh : LE.le m n\nv : Fin n → α\n⊢ Eq (List.ofFn (Fin.take m h v)) (List.take m (List.ofFn v))","decl":"/-- `Fin.take` intertwines with `List.take` via `List.ofFn`. -/\ntheorem ofFn_take_eq_take_ofFn {α : Type*} {m : ℕ} (h : m ≤ n) (v : Fin n → α) :\n    List.ofFn (take m h v) = (List.ofFn v).take m :=\n  List.ext_get (by simp [h]) (fun n h1 h2 => by simp)\n\n"}
{"name":"Fin.ofFn_take_get","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"α : Type u_2\nm : Nat\nl : List α\nh : LE.le m l.length\n⊢ Eq (List.ofFn (Fin.take m h l.get)) (List.take m l)","decl":"/-- Alternative version of `take_eq_take_list_ofFn` with `l : List α` instead of `v : Fin n → α`. -/\ntheorem ofFn_take_get {α : Type*} {m : ℕ} (l : List α) (h : m ≤ l.length) :\n    List.ofFn (take m h l.get) = l.take m :=\n  List.ext_get (by simp [h]) (fun n h1 h2 => by simp)\n\n"}
{"name":"Fin.get_take_eq_take_get_comp_cast","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"α : Type u_2\nm : Nat\nl : List α\nh : LE.le m l.length\n⊢ Eq (List.take m l).get (Function.comp (Fin.take m h l.get) (Fin.cast ⋯))","decl":"/-- `Fin.take` intertwines with `List.take` via `List.get`. -/\ntheorem get_take_eq_take_get_comp_cast {α : Type*} {m : ℕ} (l : List α) (h : m ≤ l.length) :\n    (l.take m).get = take m h l.get ∘ Fin.cast (List.length_take_of_le h) := by\n  ext i\n  simp only [List.get_eq_getElem, List.getElem_take, comp_apply, take_apply, coe_castLE, coe_cast]\n\n"}
{"name":"Fin.get_take_ofFn_eq_take_comp_cast","module":"Mathlib.Data.Fin.Tuple.Take","initialProofState":"n : Nat\nα : Type u_2\nm : Nat\nv : Fin n → α\nh : LE.le m n\n⊢ Eq (List.take m (List.ofFn v)).get (Function.comp (Fin.take m h v) (Fin.cast ⋯))","decl":"/-- Alternative version of `take_eq_take_list_get` with `v : Fin n → α` instead of `l : List α`. -/\ntheorem get_take_ofFn_eq_take_comp_cast {α : Type*} {m : ℕ} (v : Fin n → α) (h : m ≤ n) :\n    ((List.ofFn v).take m).get = take m h v ∘ Fin.cast (by simp [h]) := by\n  ext i\n  simp [castLE]\n\n"}
