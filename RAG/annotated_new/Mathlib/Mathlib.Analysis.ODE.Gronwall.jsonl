{"name":"gronwallBound_K0","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"Œ¥ Œµ : Real\n‚ä¢ Eq (gronwallBound Œ¥ 0 Œµ) fun x => HAdd.hAdd Œ¥ (HMul.hMul Œµ x)","decl":"theorem gronwallBound_K0 (Œ¥ Œµ : ‚Ñù) : gronwallBound Œ¥ 0 Œµ = fun x => Œ¥ + Œµ * x :=\n  funext fun _ => if_pos rfl\n\n"}
{"name":"gronwallBound_of_K_ne_0","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"Œ¥ K Œµ : Real\nhK : Ne K 0\n‚ä¢ Eq (gronwallBound Œ¥ K Œµ) fun x => HAdd.hAdd (HMul.hMul Œ¥ (Real.exp (HMul.hMul K x))) (HMul.hMul (HDiv.hDiv Œµ K) (HSub.hSub (Real.exp (HMul.hMul K x)) 1))","decl":"theorem gronwallBound_of_K_ne_0 {Œ¥ K Œµ : ‚Ñù} (hK : K ‚â† 0) :\n    gronwallBound Œ¥ K Œµ = fun x => Œ¥ * exp (K * x) + Œµ / K * (exp (K * x) - 1) :=\n  funext fun _ => if_neg hK\n\n"}
{"name":"hasDerivAt_gronwallBound","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"Œ¥ K Œµ x : Real\n‚ä¢ HasDerivAt (gronwallBound Œ¥ K Œµ) (HAdd.hAdd (HMul.hMul K (gronwallBound Œ¥ K Œµ x)) Œµ) x","decl":"theorem hasDerivAt_gronwallBound (Œ¥ K Œµ x : ‚Ñù) :\n    HasDerivAt (gronwallBound Œ¥ K Œµ) (K * gronwallBound Œ¥ K Œµ x + Œµ) x := by\n  by_cases hK : K = 0\n  ¬∑ subst K\n    simp only [gronwallBound_K0, zero_mul, zero_add]\n    convert ((hasDerivAt_id x).const_mul Œµ).const_add Œ¥\n    rw [mul_one]\n  ¬∑ simp only [gronwallBound_of_K_ne_0 hK]\n    convert (((hasDerivAt_id x).const_mul K).exp.const_mul Œ¥).add\n      ((((hasDerivAt_id x).const_mul K).exp.sub_const 1).const_mul (Œµ / K)) using 1\n    simp only [id, mul_add, (mul_assoc _ _ _).symm, mul_comm _ K, mul_div_cancel‚ÇÄ _ hK]\n    ring\n\n"}
{"name":"hasDerivAt_gronwallBound_shift","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"Œ¥ K Œµ x a : Real\n‚ä¢ HasDerivAt (fun y => gronwallBound Œ¥ K Œµ (HSub.hSub y a)) (HAdd.hAdd (HMul.hMul K (gronwallBound Œ¥ K Œµ (HSub.hSub x a))) Œµ) x","decl":"theorem hasDerivAt_gronwallBound_shift (Œ¥ K Œµ x a : ‚Ñù) :\n    HasDerivAt (fun y => gronwallBound Œ¥ K Œµ (y - a)) (K * gronwallBound Œ¥ K Œµ (x - a) + Œµ) x := by\n  convert (hasDerivAt_gronwallBound Œ¥ K Œµ _).comp x ((hasDerivAt_id x).sub_const a) using 1\n  rw [id, mul_one]\n\n"}
{"name":"gronwallBound_x0","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"Œ¥ K Œµ : Real\n‚ä¢ Eq (gronwallBound Œ¥ K Œµ 0) Œ¥","decl":"theorem gronwallBound_x0 (Œ¥ K Œµ : ‚Ñù) : gronwallBound Œ¥ K Œµ 0 = Œ¥ := by\n  by_cases hK : K = 0\n  ¬∑ simp only [gronwallBound, if_pos hK, mul_zero, add_zero]\n  ¬∑ simp only [gronwallBound, if_neg hK, mul_zero, exp_zero, sub_self, mul_one,\n      add_zero]\n\n"}
{"name":"gronwallBound_Œµ0","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"Œ¥ K x : Real\n‚ä¢ Eq (gronwallBound Œ¥ K 0 x) (HMul.hMul Œ¥ (Real.exp (HMul.hMul K x)))","decl":"theorem gronwallBound_Œµ0 (Œ¥ K x : ‚Ñù) : gronwallBound Œ¥ K 0 x = Œ¥ * exp (K * x) := by\n  by_cases hK : K = 0\n  ¬∑ simp only [gronwallBound_K0, hK, zero_mul, exp_zero, add_zero, mul_one]\n  ¬∑ simp only [gronwallBound_of_K_ne_0 hK, zero_div, zero_mul, add_zero]\n\n"}
{"name":"gronwallBound_Œµ0_Œ¥0","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"K x : Real\n‚ä¢ Eq (gronwallBound 0 K 0 x) 0","decl":"theorem gronwallBound_Œµ0_Œ¥0 (K x : ‚Ñù) : gronwallBound 0 K 0 x = 0 := by\n  simp only [gronwallBound_Œµ0, zero_mul]\n\n"}
{"name":"gronwallBound_continuous_Œµ","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"Œ¥ K x : Real\n‚ä¢ Continuous fun Œµ => gronwallBound Œ¥ K Œµ x","decl":"theorem gronwallBound_continuous_Œµ (Œ¥ K x : ‚Ñù) : Continuous fun Œµ => gronwallBound Œ¥ K Œµ x := by\n  by_cases hK : K = 0\n  ¬∑ simp only [gronwallBound_K0, hK]\n    exact continuous_const.add (continuous_id.mul continuous_const)\n  ¬∑ simp only [gronwallBound_of_K_ne_0 hK]\n    exact continuous_const.add ((continuous_id.mul continuous_const).mul continuous_const)\n\n"}
{"name":"le_gronwallBound_of_liminf_deriv_right_le","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"f f' : Real ‚Üí Real\nŒ¥ K Œµ a b : Real\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí ‚àÄ (r : Real), LT.lt (f' x) r ‚Üí Filter.Frequently (fun z => LT.lt (HMul.hMul (Inv.inv (HSub.hSub z x)) (HSub.hSub (f z) (f x))) r) (nhdsWithin x (Set.Ioi x))\nha : LE.le (f a) Œ¥\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí LE.le (f' x) (HAdd.hAdd (HMul.hMul K (f x)) Œµ)\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (f x) (gronwallBound Œ¥ K Œµ (HSub.hSub x a))","decl":"/-- A Gr√∂nwall-like inequality: if `f : ‚Ñù ‚Üí ‚Ñù` is continuous on `[a, b]` and satisfies\nthe inequalities `f a ‚â§ Œ¥` and\n`‚àÄ x ‚àà [a, b), liminf_{z‚Üíx+0} (f z - f x)/(z - x) ‚â§ K * (f x) + Œµ`, then `f x`\nis bounded by `gronwallBound Œ¥ K Œµ (x - a)` on `[a, b]`.\n\nSee also `norm_le_gronwallBound_of_norm_deriv_right_le` for a version bounding `‚Äñf x‚Äñ`,\n`f : ‚Ñù ‚Üí E`. -/\ntheorem le_gronwallBound_of_liminf_deriv_right_le {f f' : ‚Ñù ‚Üí ‚Ñù} {Œ¥ K Œµ : ‚Ñù} {a b : ‚Ñù}\n    (hf : ContinuousOn f (Icc a b))\n    (hf' : ‚àÄ x ‚àà Ico a b, ‚àÄ r, f' x < r ‚Üí ‚àÉ·∂† z in ùìù[>] x, (z - x)‚Åª¬π * (f z - f x) < r)\n    (ha : f a ‚â§ Œ¥) (bound : ‚àÄ x ‚àà Ico a b, f' x ‚â§ K * f x + Œµ) :\n    ‚àÄ x ‚àà Icc a b, f x ‚â§ gronwallBound Œ¥ K Œµ (x - a) := by\n  have H : ‚àÄ x ‚àà Icc a b, ‚àÄ Œµ' ‚àà Ioi Œµ, f x ‚â§ gronwallBound Œ¥ K Œµ' (x - a) := by\n    intro x hx Œµ' hŒµ'\n    apply image_le_of_liminf_slope_right_lt_deriv_boundary hf hf'\n    ¬∑ rwa [sub_self, gronwallBound_x0]\n    ¬∑ exact fun x => hasDerivAt_gronwallBound_shift Œ¥ K Œµ' x a\n    ¬∑ intro x hx hfB\n      rw [‚Üê hfB]\n      apply lt_of_le_of_lt (bound x hx)\n      exact add_lt_add_left (mem_Ioi.1 hŒµ') _\n    ¬∑ exact hx\n  intro x hx\n  change f x ‚â§ (fun Œµ' => gronwallBound Œ¥ K Œµ' (x - a)) Œµ\n  convert continuousWithinAt_const.closure_le _ _ (H x hx)\n  ¬∑ simp only [closure_Ioi, left_mem_Ici]\n  exact (gronwallBound_continuous_Œµ Œ¥ K (x - a)).continuousWithinAt\n\n"}
{"name":"norm_le_gronwallBound_of_norm_deriv_right_le","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf f' : Real ‚Üí E\nŒ¥ K Œµ a b : Real\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt f (f' x) (Set.Ici x) x\nha : LE.le (Norm.norm (f a)) Œ¥\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí LE.le (Norm.norm (f' x)) (HAdd.hAdd (HMul.hMul K (Norm.norm (f x))) Œµ)\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (Norm.norm (f x)) (gronwallBound Œ¥ K Œµ (HSub.hSub x a))","decl":"/-- A Gr√∂nwall-like inequality: if `f : ‚Ñù ‚Üí E` is continuous on `[a, b]`, has right derivative\n`f' x` at every point `x ‚àà [a, b)`, and satisfies the inequalities `‚Äñf a‚Äñ ‚â§ Œ¥`,\n`‚àÄ x ‚àà [a, b), ‚Äñf' x‚Äñ ‚â§ K * ‚Äñf x‚Äñ + Œµ`, then `‚Äñf x‚Äñ` is bounded by `gronwallBound Œ¥ K Œµ (x - a)`\non `[a, b]`. -/\ntheorem norm_le_gronwallBound_of_norm_deriv_right_le {f f' : ‚Ñù ‚Üí E} {Œ¥ K Œµ : ‚Ñù} {a b : ‚Ñù}\n    (hf : ContinuousOn f (Icc a b)) (hf' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt f (f' x) (Ici x) x)\n    (ha : ‚Äñf a‚Äñ ‚â§ Œ¥) (bound : ‚àÄ x ‚àà Ico a b, ‚Äñf' x‚Äñ ‚â§ K * ‚Äñf x‚Äñ + Œµ) :\n    ‚àÄ x ‚àà Icc a b, ‚Äñf x‚Äñ ‚â§ gronwallBound Œ¥ K Œµ (x - a) :=\n  le_gronwallBound_of_liminf_deriv_right_le (continuous_norm.comp_continuousOn hf)\n    (fun x hx _r hr => (hf' x hx).liminf_right_slope_norm_le hr) ha bound\n\n"}
{"name":"dist_le_of_approx_trajectories_ODE_of_mem","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nv : Real ‚Üí E ‚Üí E\ns : Real ‚Üí Set E\nK : NNReal\nf g f' g' : Real ‚Üí E\na b Œµf Œµg Œ¥ : Real\nhv : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí LipschitzOnWith K (v t) (s t)\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí HasDerivWithinAt f (f' t) (Set.Ici t) t\nf_bound : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí LE.le (Dist.dist (f' t) (v t (f t))) Œµf\nhfs : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí Membership.mem (s t) (f t)\nhg : ContinuousOn g (Set.Icc a b)\nhg' : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí HasDerivWithinAt g (g' t) (Set.Ici t) t\ng_bound : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí LE.le (Dist.dist (g' t) (v t (g t))) Œµg\nhgs : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí Membership.mem (s t) (g t)\nha : LE.le (Dist.dist (f a) (g a)) Œ¥\nt : Real\na‚úù : Membership.mem (Set.Icc a b) t\n‚ä¢ LE.le (Dist.dist (f t) (g t)) (gronwallBound Œ¥ (‚ÜëK) (HAdd.hAdd Œµf Œµg) (HSub.hSub t a))","decl":"/-- If `f` and `g` are two approximate solutions of the same ODE, then the distance between them\ncan't grow faster than exponentially. This is a simple corollary of Gr√∂nwall's inequality, and some\npeople call this Gr√∂nwall's inequality too.\n\nThis version assumes all inequalities to be true in some time-dependent set `s t`,\nand assumes that the solutions never leave this set. -/\ntheorem dist_le_of_approx_trajectories_ODE_of_mem\n    (hv : ‚àÄ t ‚àà Ico a b, LipschitzOnWith K (v t) (s t))\n    (hf : ContinuousOn f (Icc a b))\n    (hf' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt f (f' t) (Ici t) t)\n    (f_bound : ‚àÄ t ‚àà Ico a b, dist (f' t) (v t (f t)) ‚â§ Œµf)\n    (hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà s t)\n    (hg : ContinuousOn g (Icc a b))\n    (hg' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt g (g' t) (Ici t) t)\n    (g_bound : ‚àÄ t ‚àà Ico a b, dist (g' t) (v t (g t)) ‚â§ Œµg)\n    (hgs : ‚àÄ t ‚àà Ico a b, g t ‚àà s t)\n    (ha : dist (f a) (g a) ‚â§ Œ¥) :\n    ‚àÄ t ‚àà Icc a b, dist (f t) (g t) ‚â§ gronwallBound Œ¥ K (Œµf + Œµg) (t - a) := by\n  simp only [dist_eq_norm] at ha ‚ä¢\n  have h_deriv : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt (fun t => f t - g t) (f' t - g' t) (Ici t) t :=\n    fun t ht => (hf' t ht).sub (hg' t ht)\n  apply norm_le_gronwallBound_of_norm_deriv_right_le (hf.sub hg) h_deriv ha\n  intro t ht\n  have := dist_triangle4_right (f' t) (g' t) (v t (f t)) (v t (g t))\n  have hv := (hv t ht).dist_le_mul _ (hfs t ht) _ (hgs t ht)\n  rw [‚Üê dist_eq_norm, ‚Üê dist_eq_norm]\n  refine this.trans ((add_le_add (add_le_add (f_bound t ht) (g_bound t ht)) hv).trans ?_)\n  rw [add_comm]\n\n"}
{"name":"dist_le_of_approx_trajectories_ODE","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nv : Real ‚Üí E ‚Üí E\nK : NNReal\nf g f' g' : Real ‚Üí E\na b Œµf Œµg Œ¥ : Real\nhv : ‚àÄ (t : Real), LipschitzWith K (v t)\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí HasDerivWithinAt f (f' t) (Set.Ici t) t\nf_bound : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí LE.le (Dist.dist (f' t) (v t (f t))) Œµf\nhg : ContinuousOn g (Set.Icc a b)\nhg' : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí HasDerivWithinAt g (g' t) (Set.Ici t) t\ng_bound : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí LE.le (Dist.dist (g' t) (v t (g t))) Œµg\nha : LE.le (Dist.dist (f a) (g a)) Œ¥\nt : Real\na‚úù : Membership.mem (Set.Icc a b) t\n‚ä¢ LE.le (Dist.dist (f t) (g t)) (gronwallBound Œ¥ (‚ÜëK) (HAdd.hAdd Œµf Œµg) (HSub.hSub t a))","decl":"/-- If `f` and `g` are two approximate solutions of the same ODE, then the distance between them\ncan't grow faster than exponentially. This is a simple corollary of Gr√∂nwall's inequality, and some\npeople call this Gr√∂nwall's inequality too.\n\nThis version assumes all inequalities to be true in the whole space. -/\ntheorem dist_le_of_approx_trajectories_ODE\n    (hv : ‚àÄ t, LipschitzWith K (v t))\n    (hf : ContinuousOn f (Icc a b))\n    (hf' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt f (f' t) (Ici t) t)\n    (f_bound : ‚àÄ t ‚àà Ico a b, dist (f' t) (v t (f t)) ‚â§ Œµf)\n    (hg : ContinuousOn g (Icc a b))\n    (hg' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt g (g' t) (Ici t) t)\n    (g_bound : ‚àÄ t ‚àà Ico a b, dist (g' t) (v t (g t)) ‚â§ Œµg)\n    (ha : dist (f a) (g a) ‚â§ Œ¥) :\n    ‚àÄ t ‚àà Icc a b, dist (f t) (g t) ‚â§ gronwallBound Œ¥ K (Œµf + Œµg) (t - a) :=\n  have hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà @univ E := fun _ _ => trivial\n  dist_le_of_approx_trajectories_ODE_of_mem (fun t _ => (hv t).lipschitzOnWith) hf hf'\n    f_bound hfs hg hg' g_bound (fun _ _ => trivial) ha\n\n"}
{"name":"dist_le_of_trajectories_ODE_of_mem","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nv : Real ‚Üí E ‚Üí E\ns : Real ‚Üí Set E\nK : NNReal\nf g : Real ‚Üí E\na b Œ¥ : Real\nhv : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí LipschitzOnWith K (v t) (s t)\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí HasDerivWithinAt f (v t (f t)) (Set.Ici t) t\nhfs : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí Membership.mem (s t) (f t)\nhg : ContinuousOn g (Set.Icc a b)\nhg' : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí HasDerivWithinAt g (v t (g t)) (Set.Ici t) t\nhgs : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí Membership.mem (s t) (g t)\nha : LE.le (Dist.dist (f a) (g a)) Œ¥\nt : Real\na‚úù : Membership.mem (Set.Icc a b) t\n‚ä¢ LE.le (Dist.dist (f t) (g t)) (HMul.hMul Œ¥ (Real.exp (HMul.hMul (‚ÜëK) (HSub.hSub t a))))","decl":"/-- If `f` and `g` are two exact solutions of the same ODE, then the distance between them\ncan't grow faster than exponentially. This is a simple corollary of Gr√∂nwall's inequality, and some\npeople call this Gr√∂nwall's inequality too.\n\nThis version assumes all inequalities to be true in some time-dependent set `s t`,\nand assumes that the solutions never leave this set. -/\ntheorem dist_le_of_trajectories_ODE_of_mem\n    (hv : ‚àÄ t ‚àà Ico a b, LipschitzOnWith K (v t) (s t))\n    (hf : ContinuousOn f (Icc a b))\n    (hf' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t)\n    (hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà s t)\n    (hg : ContinuousOn g (Icc a b)) (hg' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t)\n    (hgs : ‚àÄ t ‚àà Ico a b, g t ‚àà s t) (ha : dist (f a) (g a) ‚â§ Œ¥) :\n    ‚àÄ t ‚àà Icc a b, dist (f t) (g t) ‚â§ Œ¥ * exp (K * (t - a)) := by\n  have f_bound : ‚àÄ t ‚àà Ico a b, dist (v t (f t)) (v t (f t)) ‚â§ 0 := by intros; rw [dist_self]\n  have g_bound : ‚àÄ t ‚àà Ico a b, dist (v t (g t)) (v t (g t)) ‚â§ 0 := by intros; rw [dist_self]\n  intro t ht\n  have :=\n    dist_le_of_approx_trajectories_ODE_of_mem hv hf hf' f_bound hfs hg hg' g_bound hgs ha t ht\n  rwa [zero_add, gronwallBound_Œµ0] at this\n\n"}
{"name":"dist_le_of_trajectories_ODE","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nv : Real ‚Üí E ‚Üí E\nK : NNReal\nf g : Real ‚Üí E\na b Œ¥ : Real\nhv : ‚àÄ (t : Real), LipschitzWith K (v t)\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí HasDerivWithinAt f (v t (f t)) (Set.Ici t) t\nhg : ContinuousOn g (Set.Icc a b)\nhg' : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí HasDerivWithinAt g (v t (g t)) (Set.Ici t) t\nha : LE.le (Dist.dist (f a) (g a)) Œ¥\nt : Real\na‚úù : Membership.mem (Set.Icc a b) t\n‚ä¢ LE.le (Dist.dist (f t) (g t)) (HMul.hMul Œ¥ (Real.exp (HMul.hMul (‚ÜëK) (HSub.hSub t a))))","decl":"/-- If `f` and `g` are two exact solutions of the same ODE, then the distance between them\ncan't grow faster than exponentially. This is a simple corollary of Gr√∂nwall's inequality, and some\npeople call this Gr√∂nwall's inequality too.\n\nThis version assumes all inequalities to be true in the whole space. -/\ntheorem dist_le_of_trajectories_ODE\n    (hv : ‚àÄ t, LipschitzWith K (v t))\n    (hf : ContinuousOn f (Icc a b))\n    (hf' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t)\n    (hg : ContinuousOn g (Icc a b))\n    (hg' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t)\n    (ha : dist (f a) (g a) ‚â§ Œ¥) :\n    ‚àÄ t ‚àà Icc a b, dist (f t) (g t) ‚â§ Œ¥ * exp (K * (t - a)) :=\n  have hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà @univ E := fun _ _ => trivial\n  dist_le_of_trajectories_ODE_of_mem (fun t _ => (hv t).lipschitzOnWith) hf hf' hfs hg\n    hg' (fun _ _ => trivial) ha\n\n"}
{"name":"ODE_solution_unique_of_mem_Icc_right","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nv : Real ‚Üí E ‚Üí E\ns : Real ‚Üí Set E\nK : NNReal\nf g : Real ‚Üí E\na b : Real\nhv : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí LipschitzOnWith K (v t) (s t)\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí HasDerivWithinAt f (v t (f t)) (Set.Ici t) t\nhfs : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí Membership.mem (s t) (f t)\nhg : ContinuousOn g (Set.Icc a b)\nhg' : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí HasDerivWithinAt g (v t (g t)) (Set.Ici t) t\nhgs : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí Membership.mem (s t) (g t)\nha : Eq (f a) (g a)\n‚ä¢ Set.EqOn f g (Set.Icc a b)","decl":"/-- There exists only one solution of an ODE \\(\\dot x=v(t, x)\\) in a set `s ‚äÜ ‚Ñù √ó E` with\na given initial value provided that the RHS is Lipschitz continuous in `x` within `s`,\nand we consider only solutions included in `s`.\n\nThis version shows uniqueness in a closed interval `Icc a b`, where `a` is the initial time. -/\ntheorem ODE_solution_unique_of_mem_Icc_right\n    (hv : ‚àÄ t ‚àà Ico a b, LipschitzOnWith K (v t) (s t))\n    (hf : ContinuousOn f (Icc a b))\n    (hf' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t)\n    (hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà s t)\n    (hg : ContinuousOn g (Icc a b))\n    (hg' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t)\n    (hgs : ‚àÄ t ‚àà Ico a b, g t ‚àà s t)\n    (ha : f a = g a) :\n    EqOn f g (Icc a b) := fun t ht ‚Ü¶ by\n  have := dist_le_of_trajectories_ODE_of_mem hv hf hf' hfs hg hg' hgs (dist_le_zero.2 ha) t ht\n  rwa [zero_mul, dist_le_zero] at this\n\n"}
{"name":"ODE_solution_unique_of_mem_Icc_left","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nv : Real ‚Üí E ‚Üí E\ns : Real ‚Üí Set E\nK : NNReal\nf g : Real ‚Üí E\na b : Real\nhv : ‚àÄ (t : Real), Membership.mem (Set.Ioc a b) t ‚Üí LipschitzOnWith K (v t) (s t)\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (t : Real), Membership.mem (Set.Ioc a b) t ‚Üí HasDerivWithinAt f (v t (f t)) (Set.Iic t) t\nhfs : ‚àÄ (t : Real), Membership.mem (Set.Ioc a b) t ‚Üí Membership.mem (s t) (f t)\nhg : ContinuousOn g (Set.Icc a b)\nhg' : ‚àÄ (t : Real), Membership.mem (Set.Ioc a b) t ‚Üí HasDerivWithinAt g (v t (g t)) (Set.Iic t) t\nhgs : ‚àÄ (t : Real), Membership.mem (Set.Ioc a b) t ‚Üí Membership.mem (s t) (g t)\nhb : Eq (f b) (g b)\n‚ä¢ Set.EqOn f g (Set.Icc a b)","decl":"/-- A time-reversed version of `ODE_solution_unique_of_mem_Icc_right`. Uniqueness is shown in a\nclosed interval `Icc a b`, where `b` is the \"initial\" time. -/\ntheorem ODE_solution_unique_of_mem_Icc_left\n    (hv : ‚àÄ t ‚àà Ioc a b, LipschitzOnWith K (v t) (s t))\n    (hf : ContinuousOn f (Icc a b))\n    (hf' : ‚àÄ t ‚àà Ioc a b, HasDerivWithinAt f (v t (f t)) (Iic t) t)\n    (hfs : ‚àÄ t ‚àà Ioc a b, f t ‚àà s t)\n    (hg : ContinuousOn g (Icc a b))\n    (hg' : ‚àÄ t ‚àà Ioc a b, HasDerivWithinAt g (v t (g t)) (Iic t) t)\n    (hgs : ‚àÄ t ‚àà Ioc a b, g t ‚àà s t)\n    (hb : f b = g b) :\n    EqOn f g (Icc a b) := by\n  have hv' : ‚àÄ t ‚àà Ico (-b) (-a), LipschitzOnWith K (Neg.neg ‚àò (v (-t))) (s (-t)) := by\n    intro t ht\n    replace ht : -t ‚àà Ioc a b := by\n      simp at ht ‚ä¢\n      constructor <;> linarith\n    rw [‚Üê one_mul K]\n    exact LipschitzWith.id.neg.comp_lipschitzOnWith (hv _ ht)\n  have hmt1 : MapsTo Neg.neg (Icc (-b) (-a)) (Icc a b) :=\n    fun _ ht ‚Ü¶ ‚ü®le_neg.mp ht.2, neg_le.mp ht.1‚ü©\n  have hmt2 : MapsTo Neg.neg (Ico (-b) (-a)) (Ioc a b) :=\n    fun _ ht ‚Ü¶ ‚ü®lt_neg.mp ht.2, neg_le.mp ht.1‚ü©\n  have hmt3 (t : ‚Ñù) : MapsTo Neg.neg (Ici t) (Iic (-t)) :=\n    fun _ ht' ‚Ü¶ mem_Iic.mpr <| neg_le_neg ht'\n  suffices EqOn (f ‚àò Neg.neg) (g ‚àò Neg.neg) (Icc (-b) (-a)) by\n    rw [eqOn_comp_right_iff] at this\n    convert this\n    simp\n  apply ODE_solution_unique_of_mem_Icc_right hv'\n    (hf.comp continuousOn_neg hmt1) _ (fun _ ht ‚Ü¶ hfs _ (hmt2 ht))\n    (hg.comp continuousOn_neg hmt1) _ (fun _ ht ‚Ü¶ hgs _ (hmt2 ht)) (by simp [hb])\n  ¬∑ intros t ht\n    convert HasFDerivWithinAt.comp_hasDerivWithinAt t (hf' (-t) (hmt2 ht))\n      (hasDerivAt_neg t).hasDerivWithinAt (hmt3 t)\n    simp\n  ¬∑ intros t ht\n    convert HasFDerivWithinAt.comp_hasDerivWithinAt t (hg' (-t) (hmt2 ht))\n      (hasDerivAt_neg t).hasDerivWithinAt (hmt3 t)\n    simp\n\n"}
{"name":"ODE_solution_unique_of_mem_Icc","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nv : Real ‚Üí E ‚Üí E\ns : Real ‚Üí Set E\nK : NNReal\nf g : Real ‚Üí E\na b t‚ÇÄ : Real\nhv : ‚àÄ (t : Real), Membership.mem (Set.Ioo a b) t ‚Üí LipschitzOnWith K (v t) (s t)\nht : Membership.mem (Set.Ioo a b) t‚ÇÄ\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (t : Real), Membership.mem (Set.Ioo a b) t ‚Üí HasDerivAt f (v t (f t)) t\nhfs : ‚àÄ (t : Real), Membership.mem (Set.Ioo a b) t ‚Üí Membership.mem (s t) (f t)\nhg : ContinuousOn g (Set.Icc a b)\nhg' : ‚àÄ (t : Real), Membership.mem (Set.Ioo a b) t ‚Üí HasDerivAt g (v t (g t)) t\nhgs : ‚àÄ (t : Real), Membership.mem (Set.Ioo a b) t ‚Üí Membership.mem (s t) (g t)\nheq : Eq (f t‚ÇÄ) (g t‚ÇÄ)\n‚ä¢ Set.EqOn f g (Set.Icc a b)","decl":"/-- A version of `ODE_solution_unique_of_mem_Icc_right` for uniqueness in a closed interval whose\ninterior contains the initial time. -/\ntheorem ODE_solution_unique_of_mem_Icc\n    (hv : ‚àÄ t ‚àà Ioo a b, LipschitzOnWith K (v t) (s t))\n    (ht : t‚ÇÄ ‚àà Ioo a b)\n    (hf : ContinuousOn f (Icc a b))\n    (hf' : ‚àÄ t ‚àà Ioo a b, HasDerivAt f (v t (f t)) t)\n    (hfs : ‚àÄ t ‚àà Ioo a b, f t ‚àà s t)\n    (hg : ContinuousOn g (Icc a b))\n    (hg' : ‚àÄ t ‚àà Ioo a b, HasDerivAt g (v t (g t)) t)\n    (hgs : ‚àÄ t ‚àà Ioo a b, g t ‚àà s t)\n    (heq : f t‚ÇÄ = g t‚ÇÄ) :\n    EqOn f g (Icc a b) := by\n  rw [‚Üê Icc_union_Icc_eq_Icc (le_of_lt ht.1) (le_of_lt ht.2)]\n  apply EqOn.union\n  ¬∑ have hss : Ioc a t‚ÇÄ ‚äÜ Ioo a b := Ioc_subset_Ioo_right ht.2\n    exact ODE_solution_unique_of_mem_Icc_left (fun t ht ‚Ü¶ hv t (hss ht))\n      (hf.mono <| Icc_subset_Icc_right <| le_of_lt ht.2)\n      (fun _ ht' ‚Ü¶ (hf' _ (hss ht')).hasDerivWithinAt) (fun _ ht' ‚Ü¶ (hfs _ (hss ht')))\n      (hg.mono <| Icc_subset_Icc_right <| le_of_lt ht.2)\n      (fun _ ht' ‚Ü¶ (hg' _ (hss ht')).hasDerivWithinAt) (fun _ ht' ‚Ü¶ (hgs _ (hss ht'))) heq\n  ¬∑ have hss : Ico t‚ÇÄ b ‚äÜ Ioo a b := Ico_subset_Ioo_left ht.1\n    exact ODE_solution_unique_of_mem_Icc_right (fun t ht ‚Ü¶ hv t (hss ht))\n      (hf.mono <| Icc_subset_Icc_left <| le_of_lt ht.1)\n      (fun _ ht' ‚Ü¶ (hf' _ (hss ht')).hasDerivWithinAt) (fun _ ht' ‚Ü¶ (hfs _ (hss ht')))\n      (hg.mono <| Icc_subset_Icc_left <| le_of_lt ht.1)\n      (fun _ ht' ‚Ü¶ (hg' _ (hss ht')).hasDerivWithinAt) (fun _ ht' ‚Ü¶ (hgs _ (hss ht'))) heq\n\n"}
{"name":"ODE_solution_unique_of_mem_Ioo","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nv : Real ‚Üí E ‚Üí E\ns : Real ‚Üí Set E\nK : NNReal\nf g : Real ‚Üí E\na b t‚ÇÄ : Real\nhv : ‚àÄ (t : Real), Membership.mem (Set.Ioo a b) t ‚Üí LipschitzOnWith K (v t) (s t)\nht : Membership.mem (Set.Ioo a b) t‚ÇÄ\nhf : ‚àÄ (t : Real), Membership.mem (Set.Ioo a b) t ‚Üí And (HasDerivAt f (v t (f t)) t) (Membership.mem (s t) (f t))\nhg : ‚àÄ (t : Real), Membership.mem (Set.Ioo a b) t ‚Üí And (HasDerivAt g (v t (g t)) t) (Membership.mem (s t) (g t))\nheq : Eq (f t‚ÇÄ) (g t‚ÇÄ)\n‚ä¢ Set.EqOn f g (Set.Ioo a b)","decl":"/-- A version of `ODE_solution_unique_of_mem_Icc` for uniqueness in an open interval. -/\ntheorem ODE_solution_unique_of_mem_Ioo\n    (hv : ‚àÄ t ‚àà Ioo a b, LipschitzOnWith K (v t) (s t))\n    (ht : t‚ÇÄ ‚àà Ioo a b)\n    (hf : ‚àÄ t ‚àà Ioo a b, HasDerivAt f (v t (f t)) t ‚àß f t ‚àà s t)\n    (hg : ‚àÄ t ‚àà Ioo a b, HasDerivAt g (v t (g t)) t ‚àß g t ‚àà s t)\n    (heq : f t‚ÇÄ = g t‚ÇÄ) :\n    EqOn f g (Ioo a b) := by\n  intros t' ht'\n  rcases lt_or_le t' t‚ÇÄ with (h | h)\n  ¬∑ have hss : Icc t' t‚ÇÄ ‚äÜ Ioo a b :=\n      fun _ ht'' ‚Ü¶ ‚ü®lt_of_lt_of_le ht'.1 ht''.1, lt_of_le_of_lt ht''.2 ht.2‚ü©\n    exact ODE_solution_unique_of_mem_Icc_left\n      (fun t'' ht'' ‚Ü¶ hv t'' ((Ioc_subset_Icc_self.trans hss) ht''))\n      (continuousOn_of_forall_continuousAt fun _ ht'' ‚Ü¶ (hf _ <| hss ht'').1.continuousAt)\n      (fun _ ht'' ‚Ü¶ (hf _ <| hss <| Ioc_subset_Icc_self ht'').1.hasDerivWithinAt)\n      (fun _ ht'' ‚Ü¶ (hf _ <| hss <| Ioc_subset_Icc_self ht'').2)\n      (continuousOn_of_forall_continuousAt fun _ ht'' ‚Ü¶ (hg _ <| hss ht'').1.continuousAt)\n      (fun _ ht'' ‚Ü¶ (hg _ <| hss <| Ioc_subset_Icc_self ht'').1.hasDerivWithinAt)\n      (fun _ ht'' ‚Ü¶ (hg _ <| hss <| Ioc_subset_Icc_self ht'').2) heq\n      ‚ü®le_rfl, le_of_lt h‚ü©\n  ¬∑ have hss : Icc t‚ÇÄ t' ‚äÜ Ioo a b :=\n      fun _ ht'' ‚Ü¶ ‚ü®lt_of_lt_of_le ht.1 ht''.1, lt_of_le_of_lt ht''.2 ht'.2‚ü©\n    exact ODE_solution_unique_of_mem_Icc_right\n      (fun t'' ht'' ‚Ü¶ hv t'' ((Ico_subset_Icc_self.trans hss) ht''))\n      (continuousOn_of_forall_continuousAt fun _ ht'' ‚Ü¶ (hf _ <| hss ht'').1.continuousAt)\n      (fun _ ht'' ‚Ü¶ (hf _ <| hss <| Ico_subset_Icc_self ht'').1.hasDerivWithinAt)\n      (fun _ ht'' ‚Ü¶ (hf _ <| hss <| Ico_subset_Icc_self ht'').2)\n      (continuousOn_of_forall_continuousAt fun _ ht'' ‚Ü¶ (hg _ <| hss ht'').1.continuousAt)\n      (fun _ ht'' ‚Ü¶ (hg _ <| hss <| Ico_subset_Icc_self ht'').1.hasDerivWithinAt)\n      (fun _ ht'' ‚Ü¶ (hg _ <| hss <| Ico_subset_Icc_self ht'').2) heq\n      ‚ü®h, le_rfl‚ü©\n\n"}
{"name":"ODE_solution_unique_of_eventually","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nv : Real ‚Üí E ‚Üí E\ns : Real ‚Üí Set E\nK : NNReal\nf g : Real ‚Üí E\nt‚ÇÄ : Real\nhv : Filter.Eventually (fun t => LipschitzOnWith K (v t) (s t)) (nhds t‚ÇÄ)\nhf : Filter.Eventually (fun t => And (HasDerivAt f (v t (f t)) t) (Membership.mem (s t) (f t))) (nhds t‚ÇÄ)\nhg : Filter.Eventually (fun t => And (HasDerivAt g (v t (g t)) t) (Membership.mem (s t) (g t))) (nhds t‚ÇÄ)\nheq : Eq (f t‚ÇÄ) (g t‚ÇÄ)\n‚ä¢ (nhds t‚ÇÄ).EventuallyEq f g","decl":"/-- Local unqueness of ODE solutions. -/\ntheorem ODE_solution_unique_of_eventually\n    (hv : ‚àÄ·∂† t in ùìù t‚ÇÄ, LipschitzOnWith K (v t) (s t))\n    (hf : ‚àÄ·∂† t in ùìù t‚ÇÄ, HasDerivAt f (v t (f t)) t ‚àß f t ‚àà s t)\n    (hg : ‚àÄ·∂† t in ùìù t‚ÇÄ, HasDerivAt g (v t (g t)) t ‚àß g t ‚àà s t)\n    (heq : f t‚ÇÄ = g t‚ÇÄ) : f =·∂†[ùìù t‚ÇÄ] g := by\n  obtain ‚ü®Œµ, hŒµ, h‚ü© := eventually_nhds_iff_ball.mp (hv.and (hf.and hg))\n  rw [Filter.eventuallyEq_iff_exists_mem]\n  refine ‚ü®ball t‚ÇÄ Œµ, ball_mem_nhds _ hŒµ, ?_‚ü©\n  simp_rw [Real.ball_eq_Ioo] at *\n  apply ODE_solution_unique_of_mem_Ioo (fun _ ht ‚Ü¶ (h _ ht).1)\n    (Real.ball_eq_Ioo t‚ÇÄ Œµ ‚ñ∏ mem_ball_self hŒµ)\n    (fun _ ht ‚Ü¶ (h _ ht).2.1) (fun _ ht ‚Ü¶ (h _ ht).2.2) heq\n\n"}
{"name":"ODE_solution_unique","module":"Mathlib.Analysis.ODE.Gronwall","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nv : Real ‚Üí E ‚Üí E\nK : NNReal\nf g : Real ‚Üí E\na b : Real\nhv : ‚àÄ (t : Real), LipschitzWith K (v t)\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí HasDerivWithinAt f (v t (f t)) (Set.Ici t) t\nhg : ContinuousOn g (Set.Icc a b)\nhg' : ‚àÄ (t : Real), Membership.mem (Set.Ico a b) t ‚Üí HasDerivWithinAt g (v t (g t)) (Set.Ici t) t\nha : Eq (f a) (g a)\n‚ä¢ Set.EqOn f g (Set.Icc a b)","decl":"/-- There exists only one solution of an ODE \\(\\dot x=v(t, x)\\) with\na given initial value provided that the RHS is Lipschitz continuous in `x`. -/\ntheorem ODE_solution_unique\n    (hv : ‚àÄ t, LipschitzWith K (v t))\n    (hf : ContinuousOn f (Icc a b))\n    (hf' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t)\n    (hg : ContinuousOn g (Icc a b))\n    (hg' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t)\n    (ha : f a = g a) :\n    EqOn f g (Icc a b) :=\n  have hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà @univ E := fun _ _ => trivial\n  ODE_solution_unique_of_mem_Icc_right (fun t _ => (hv t).lipschitzOnWith) hf hf' hfs hg hg'\n    (fun _ _ => trivial) ha\n"}
