{"name":"Matroid.dualIndepMatroid_E","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Eq M.dualIndepMatroid.E M.E","decl":"/-- Given `M : Matroid α`, the `IndepMatroid α` whose independent sets are\n  the subsets of `M.E` that are disjoint from some base of `M` -/\n@[simps] def dualIndepMatroid (M : Matroid α) : IndepMatroid α where\n  E := M.E\n  Indep I := I ⊆ M.E ∧ ∃ B, M.Base B ∧ Disjoint I B\n  indep_empty := ⟨empty_subset M.E, M.exists_base.imp (fun _ hB ↦ ⟨hB, empty_disjoint _⟩)⟩\n  indep_subset := by\n    rintro I J ⟨hJE, B, hB, hJB⟩ hIJ\n    exact ⟨hIJ.trans hJE, ⟨B, hB, disjoint_of_subset_left hIJ hJB⟩⟩\n  indep_aug := by\n    rintro I X ⟨hIE, B, hB, hIB⟩ hI_not_max hX_max\n    have hXE := hX_max.1.1\n    have hB' := (base_compl_iff_maximal_disjoint_base hXE).mpr hX_max\n\n    set B' := M.E \\ X with hX\n    have hI := (not_iff_not.mpr (base_compl_iff_maximal_disjoint_base)).mpr hI_not_max\n    obtain ⟨B'', hB'', hB''₁, hB''₂⟩ := (hB'.indep.diff I).exists_base_subset_union_base hB\n    rw [← compl_subset_compl, ← hIB.sdiff_eq_right, ← union_diff_distrib, diff_eq, compl_inter,\n      compl_compl, union_subset_iff, compl_subset_compl] at hB''₂\n\n    have hssu := (subset_inter (hB''₂.2) hIE).ssubset_of_ne\n      (by { rintro rfl; apply hI; convert hB''; simp [hB''.subset_ground] })\n\n    obtain ⟨e, ⟨(heB'' : e ∉ _), heE⟩, heI⟩ := exists_of_ssubset hssu\n    use e\n    simp_rw [mem_diff, insert_subset_iff, and_iff_left heI, and_iff_right heE, and_iff_right hIE]\n    refine ⟨by_contra (fun heX ↦ heB'' (hB''₁ ⟨?_, heI⟩)), ⟨B'', hB'', ?_⟩⟩\n    · rw [hX]; exact ⟨heE, heX⟩\n    rw [← union_singleton, disjoint_union_left, disjoint_singleton_left, and_iff_left heB'']\n    exact disjoint_of_subset_left hB''₂.2 disjoint_compl_left\n  indep_maximal := by\n    rintro X - I' ⟨hI'E, B, hB, hI'B⟩ hI'X\n    obtain ⟨I, hI⟩ := M.exists_basis (M.E \\ X)\n    obtain ⟨B', hB', hIB', hB'IB⟩ := hI.indep.exists_base_subset_union_base hB\n\n    obtain rfl : I = B' \\ X := hI.eq_of_subset_indep (hB'.indep.diff _)\n      (subset_diff.2 ⟨hIB', (subset_diff.1 hI.subset).2⟩)\n      (diff_subset_diff_left hB'.subset_ground)\n    simp_rw [maximal_subset_iff']\n    refine ⟨(X \\ B') ∩ M.E, ?_, ⟨⟨inter_subset_right, ?_⟩, ?_⟩, ?_⟩\n    · rw [subset_inter_iff, and_iff_left hI'E, subset_diff, and_iff_right hI'X]\n      exact Disjoint.mono_right hB'IB <| disjoint_union_right.2\n        ⟨disjoint_sdiff_right.mono_left hI'X  , hI'B⟩\n    · exact ⟨B', hB', (disjoint_sdiff_left (t := X)).mono_left inter_subset_left⟩\n    · exact inter_subset_left.trans diff_subset\n    simp only [subset_inter_iff, subset_diff, and_imp, forall_exists_index]\n    refine fun J hJE B'' hB'' hdj hJX hXJ ↦ ⟨⟨hJX, ?_⟩, hJE⟩\n\n    have hI' : (B'' ∩ X) ∪ (B' \\ X) ⊆ B' := by\n      rw [union_subset_iff, and_iff_left diff_subset, ← union_diff_cancel hJX,\n        inter_union_distrib_left, hdj.symm.inter_eq, empty_union, diff_eq, ← inter_assoc,\n        ← diff_eq, diff_subset_comm, diff_eq, inter_assoc, ← diff_eq, inter_comm]\n      exact subset_trans (inter_subset_inter_right _ hB''.subset_ground) hXJ\n\n    obtain ⟨B₁,hB₁,hI'B₁,hB₁I⟩ := (hB'.indep.subset hI').exists_base_subset_union_base hB''\n    rw [union_comm, ← union_assoc, union_eq_self_of_subset_right inter_subset_left] at hB₁I\n\n    obtain rfl : B₁ = B' := by\n      refine hB₁.eq_of_subset_indep hB'.indep (fun e he ↦ ?_)\n      refine (hB₁I he).elim (fun heB'' ↦ ?_) (fun h ↦ h.1)\n      refine (em (e ∈ X)).elim (fun heX ↦ hI' (Or.inl ⟨heB'', heX⟩)) (fun heX ↦ hIB' ?_)\n      refine hI.mem_of_insert_indep ⟨hB₁.subset_ground he, heX⟩ ?_\n      exact hB₁.indep.subset (insert_subset he (subset_union_right.trans hI'B₁))\n    by_contra hdj'\n    obtain ⟨e, heJ, heB'⟩ := not_disjoint_iff.mp hdj'\n    obtain (heB'' | ⟨-,heX⟩ ) := hB₁I heB'\n    · exact hdj.ne_of_mem heJ heB'' rfl\n    exact heX (hJX heJ)\n  subset_ground := by tauto\n\n"}
{"name":"Matroid.dualIndepMatroid_Indep","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\n⊢ Eq (M.dualIndepMatroid.Indep I) (And (HasSubset.Subset I M.E) (Exists fun B => And (M.Base B) (Disjoint I B)))","decl":"/-- Given `M : Matroid α`, the `IndepMatroid α` whose independent sets are\n  the subsets of `M.E` that are disjoint from some base of `M` -/\n@[simps] def dualIndepMatroid (M : Matroid α) : IndepMatroid α where\n  E := M.E\n  Indep I := I ⊆ M.E ∧ ∃ B, M.Base B ∧ Disjoint I B\n  indep_empty := ⟨empty_subset M.E, M.exists_base.imp (fun _ hB ↦ ⟨hB, empty_disjoint _⟩)⟩\n  indep_subset := by\n    rintro I J ⟨hJE, B, hB, hJB⟩ hIJ\n    exact ⟨hIJ.trans hJE, ⟨B, hB, disjoint_of_subset_left hIJ hJB⟩⟩\n  indep_aug := by\n    rintro I X ⟨hIE, B, hB, hIB⟩ hI_not_max hX_max\n    have hXE := hX_max.1.1\n    have hB' := (base_compl_iff_maximal_disjoint_base hXE).mpr hX_max\n\n    set B' := M.E \\ X with hX\n    have hI := (not_iff_not.mpr (base_compl_iff_maximal_disjoint_base)).mpr hI_not_max\n    obtain ⟨B'', hB'', hB''₁, hB''₂⟩ := (hB'.indep.diff I).exists_base_subset_union_base hB\n    rw [← compl_subset_compl, ← hIB.sdiff_eq_right, ← union_diff_distrib, diff_eq, compl_inter,\n      compl_compl, union_subset_iff, compl_subset_compl] at hB''₂\n\n    have hssu := (subset_inter (hB''₂.2) hIE).ssubset_of_ne\n      (by { rintro rfl; apply hI; convert hB''; simp [hB''.subset_ground] })\n\n    obtain ⟨e, ⟨(heB'' : e ∉ _), heE⟩, heI⟩ := exists_of_ssubset hssu\n    use e\n    simp_rw [mem_diff, insert_subset_iff, and_iff_left heI, and_iff_right heE, and_iff_right hIE]\n    refine ⟨by_contra (fun heX ↦ heB'' (hB''₁ ⟨?_, heI⟩)), ⟨B'', hB'', ?_⟩⟩\n    · rw [hX]; exact ⟨heE, heX⟩\n    rw [← union_singleton, disjoint_union_left, disjoint_singleton_left, and_iff_left heB'']\n    exact disjoint_of_subset_left hB''₂.2 disjoint_compl_left\n  indep_maximal := by\n    rintro X - I' ⟨hI'E, B, hB, hI'B⟩ hI'X\n    obtain ⟨I, hI⟩ := M.exists_basis (M.E \\ X)\n    obtain ⟨B', hB', hIB', hB'IB⟩ := hI.indep.exists_base_subset_union_base hB\n\n    obtain rfl : I = B' \\ X := hI.eq_of_subset_indep (hB'.indep.diff _)\n      (subset_diff.2 ⟨hIB', (subset_diff.1 hI.subset).2⟩)\n      (diff_subset_diff_left hB'.subset_ground)\n    simp_rw [maximal_subset_iff']\n    refine ⟨(X \\ B') ∩ M.E, ?_, ⟨⟨inter_subset_right, ?_⟩, ?_⟩, ?_⟩\n    · rw [subset_inter_iff, and_iff_left hI'E, subset_diff, and_iff_right hI'X]\n      exact Disjoint.mono_right hB'IB <| disjoint_union_right.2\n        ⟨disjoint_sdiff_right.mono_left hI'X  , hI'B⟩\n    · exact ⟨B', hB', (disjoint_sdiff_left (t := X)).mono_left inter_subset_left⟩\n    · exact inter_subset_left.trans diff_subset\n    simp only [subset_inter_iff, subset_diff, and_imp, forall_exists_index]\n    refine fun J hJE B'' hB'' hdj hJX hXJ ↦ ⟨⟨hJX, ?_⟩, hJE⟩\n\n    have hI' : (B'' ∩ X) ∪ (B' \\ X) ⊆ B' := by\n      rw [union_subset_iff, and_iff_left diff_subset, ← union_diff_cancel hJX,\n        inter_union_distrib_left, hdj.symm.inter_eq, empty_union, diff_eq, ← inter_assoc,\n        ← diff_eq, diff_subset_comm, diff_eq, inter_assoc, ← diff_eq, inter_comm]\n      exact subset_trans (inter_subset_inter_right _ hB''.subset_ground) hXJ\n\n    obtain ⟨B₁,hB₁,hI'B₁,hB₁I⟩ := (hB'.indep.subset hI').exists_base_subset_union_base hB''\n    rw [union_comm, ← union_assoc, union_eq_self_of_subset_right inter_subset_left] at hB₁I\n\n    obtain rfl : B₁ = B' := by\n      refine hB₁.eq_of_subset_indep hB'.indep (fun e he ↦ ?_)\n      refine (hB₁I he).elim (fun heB'' ↦ ?_) (fun h ↦ h.1)\n      refine (em (e ∈ X)).elim (fun heX ↦ hI' (Or.inl ⟨heB'', heX⟩)) (fun heX ↦ hIB' ?_)\n      refine hI.mem_of_insert_indep ⟨hB₁.subset_ground he, heX⟩ ?_\n      exact hB₁.indep.subset (insert_subset he (subset_union_right.trans hI'B₁))\n    by_contra hdj'\n    obtain ⟨e, heJ, heB'⟩ := not_disjoint_iff.mp hdj'\n    obtain (heB'' | ⟨-,heX⟩ ) := hB₁I heB'\n    · exact hdj.ne_of_mem heJ heB'' rfl\n    exact heX (hJX heJ)\n  subset_ground := by tauto\n\n"}
{"name":"Matroid.dual_indep_iff_exists'","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\n⊢ Iff (M.dual.Indep I) (And (HasSubset.Subset I M.E) (Exists fun B => And (M.Base B) (Disjoint I B)))","decl":"theorem dual_indep_iff_exists' : (M✶.Indep I) ↔ I ⊆ M.E ∧ (∃ B, M.Base B ∧ Disjoint I B) := Iff.rfl\n\n"}
{"name":"Matroid.dual_ground","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Eq M.dual.E M.E","decl":"@[simp] theorem dual_ground : M✶.E = M.E := rfl\n\n"}
{"name":"Matroid.dual_indep_iff_exists","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : autoParam (HasSubset.Subset I M.E) _auto✝\n⊢ Iff (M.dual.Indep I) (Exists fun B => And (M.Base B) (Disjoint I B))","decl":"@[simp] theorem dual_indep_iff_exists (hI : I ⊆ M.E := by aesop_mat) :\n    M✶.Indep I ↔ (∃ B, M.Base B ∧ Disjoint I B) := by\n  rw [dual_indep_iff_exists', and_iff_right hI]\n\n"}
{"name":"Matroid.dual_dep_iff_forall","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\n⊢ Iff (M.dual.Dep I) (And (∀ (B : Set α), M.Base B → (Inter.inter I B).Nonempty) (HasSubset.Subset I M.E))","decl":"theorem dual_dep_iff_forall : (M✶.Dep I) ↔ (∀ B, M.Base B → (I ∩ B).Nonempty) ∧ I ⊆ M.E := by\n  simp_rw [dep_iff, dual_indep_iff_exists', dual_ground, and_congr_left_iff, not_and,\n    not_exists, not_and, not_disjoint_iff_nonempty_inter, Classical.imp_iff_right_iff,\n    iff_true_intro Or.inl]\n\n"}
{"name":"Matroid.dual_finite","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.Finite\n⊢ M.dual.Finite","decl":"instance dual_finite [M.Finite] : M✶.Finite :=\n  ⟨M.ground_finite⟩\n\n"}
{"name":"Matroid.dual_nonempty","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.Nonempty\n⊢ M.dual.Nonempty","decl":"instance dual_nonempty [M.Nonempty] : M✶.Nonempty :=\n  ⟨M.ground_nonempty⟩\n\n"}
{"name":"Matroid.dual_base_iff","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\nhB : autoParam (HasSubset.Subset B M.E) _auto✝\n⊢ Iff (M.dual.Base B) (M.Base (SDiff.sdiff M.E B))","decl":"@[simp] theorem dual_base_iff (hB : B ⊆ M.E := by aesop_mat) : M✶.Base B ↔ M.Base (M.E \\ B) := by\n  rw [base_compl_iff_maximal_disjoint_base, base_iff_maximal_indep, maximal_subset_iff,\n    maximal_subset_iff]\n  simp [dual_indep_iff_exists', hB]\n\n"}
{"name":"Matroid.dual_base_iff'","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\n⊢ Iff (M.dual.Base B) (And (M.Base (SDiff.sdiff M.E B)) (HasSubset.Subset B M.E))","decl":"theorem dual_base_iff' : M✶.Base B ↔ M.Base (M.E \\ B) ∧ B ⊆ M.E :=\n  (em (B ⊆ M.E)).elim (fun h ↦ by rw [dual_base_iff, and_iff_left h])\n    (fun h ↦ iff_of_false (h ∘ (fun h' ↦ h'.subset_ground)) (h ∘ And.right))\n\n"}
{"name":"Matroid.setOf_dual_base_eq","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Eq (setOf fun B => M.dual.Base B) (Set.image (fun X => SDiff.sdiff M.E X) (setOf fun B => M.Base B))","decl":"theorem setOf_dual_base_eq : {B | M✶.Base B} = (fun X ↦ M.E \\ X) '' {B | M.Base B} := by\n  ext B\n  simp only [mem_setOf_eq, mem_image, dual_base_iff']\n  refine ⟨fun h ↦ ⟨_, h.1, diff_diff_cancel_left h.2⟩,\n    fun ⟨B', hB', h⟩ ↦ ⟨?_,h.symm.trans_subset diff_subset⟩⟩\n  rwa [← h, diff_diff_cancel_left hB'.subset_ground]\n\n"}
{"name":"Matroid.dual_dual","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Eq M.dual.dual M","decl":"@[simp] theorem dual_dual (M : Matroid α) : M✶✶ = M :=\n  ext_base rfl (fun B (h : B ⊆ M.E) ↦\n    by rw [dual_base_iff, dual_base_iff, dual_ground, diff_diff_cancel_left h])\n\n"}
{"name":"Matroid.dual_involutive","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\n⊢ Function.Involutive Matroid.dual","decl":"theorem dual_involutive : Function.Involutive (dual : Matroid α → Matroid α) := dual_dual\n\n"}
{"name":"Matroid.dual_injective","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\n⊢ Function.Injective Matroid.dual","decl":"theorem dual_injective : Function.Injective (dual : Matroid α → Matroid α) :=\n  dual_involutive.injective\n\n"}
{"name":"Matroid.dual_inj","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\n⊢ Iff (Eq M₁.dual M₂.dual) (Eq M₁ M₂)","decl":"@[simp] theorem dual_inj {M₁ M₂ : Matroid α} : M₁✶ = M₂✶ ↔ M₁ = M₂ :=\n  dual_injective.eq_iff\n\n"}
{"name":"Matroid.eq_dual_comm","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\n⊢ Iff (Eq M₁ M₂.dual) (Eq M₂ M₁.dual)","decl":"theorem eq_dual_comm {M₁ M₂ : Matroid α} : M₁ = M₂✶ ↔ M₂ = M₁✶ := by\n  rw [← dual_inj, dual_dual, eq_comm]\n\n"}
{"name":"Matroid.eq_dual_iff_dual_eq","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\n⊢ Iff (Eq M₁ M₂.dual) (Eq M₁.dual M₂)","decl":"theorem eq_dual_iff_dual_eq {M₁ M₂ : Matroid α} : M₁ = M₂✶ ↔ M₁✶ = M₂ :=\n  dual_involutive.eq_iff.symm\n\n"}
{"name":"Matroid.Base.compl_base_of_dual","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\nh : M.dual.Base B\n⊢ M.Base (SDiff.sdiff M.E B)","decl":"theorem Base.compl_base_of_dual (h : M✶.Base B) : M.Base (M.E \\ B) :=\n  (dual_base_iff'.1 h).1\n\n"}
{"name":"Matroid.Base.compl_base_dual","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\nh : M.Base B\n⊢ M.dual.Base (SDiff.sdiff M.E B)","decl":"theorem Base.compl_base_dual (h : M.Base B) : M✶.Base (M.E \\ B) := by\n  rwa [dual_base_iff, diff_diff_cancel_left h.subset_ground]\n\n"}
{"name":"Matroid.Base.compl_inter_basis_of_inter_basis","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nB X : Set α\nhB : M.Base B\nhBX : M.Basis (Inter.inter B X) X\n⊢ M.dual.Basis (Inter.inter (SDiff.sdiff M.E B) (SDiff.sdiff M.E X)) (SDiff.sdiff M.E X)","decl":"theorem Base.compl_inter_basis_of_inter_basis (hB : M.Base B) (hBX : M.Basis (B ∩ X) X) :\n    M✶.Basis ((M.E \\ B) ∩ (M.E \\ X)) (M.E \\ X) := by\n  refine Indep.basis_of_forall_insert ?_ inter_subset_right (fun e he ↦ ?_)\n  · rw [dual_indep_iff_exists]\n    exact ⟨B, hB, disjoint_of_subset_left inter_subset_left disjoint_sdiff_left⟩\n  simp only [diff_inter_self_eq_diff, mem_diff, not_and, not_not, imp_iff_right he.1.1] at he\n  simp_rw [dual_dep_iff_forall, insert_subset_iff, and_iff_right he.1.1,\n    and_iff_left (inter_subset_left.trans diff_subset)]\n  refine fun B' hB' ↦ by_contra (fun hem ↦ ?_)\n  rw [nonempty_iff_ne_empty, not_ne_iff, ← union_singleton, diff_inter_diff,\n   union_inter_distrib_right, union_empty_iff, singleton_inter_eq_empty, diff_eq,\n   inter_right_comm, inter_eq_self_of_subset_right hB'.subset_ground, ← diff_eq,\n   diff_eq_empty] at hem\n  obtain ⟨f, hfb, hBf⟩ := hB.exchange hB' ⟨he.2, hem.2⟩\n\n  have hi : M.Indep (insert f (B ∩ X)) := by\n    refine hBf.indep.subset (insert_subset_insert ?_)\n    simp_rw [subset_diff, and_iff_right inter_subset_left, disjoint_singleton_right,\n      mem_inter_iff, iff_false_intro he.1.2, and_false, not_false_iff]\n  exact hfb.2 (hBX.mem_of_insert_indep (Or.elim (hem.1 hfb.1) (False.elim ∘ hfb.2) id) hi).1\n\n"}
{"name":"Matroid.Base.inter_basis_iff_compl_inter_basis_dual","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nB X : Set α\nhB : M.Base B\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff (M.Basis (Inter.inter B X) X) (M.dual.Basis (Inter.inter (SDiff.sdiff M.E B) (SDiff.sdiff M.E X)) (SDiff.sdiff M.E X))","decl":"theorem Base.inter_basis_iff_compl_inter_basis_dual (hB : M.Base B) (hX : X ⊆ M.E := by aesop_mat) :\n    M.Basis (B ∩ X) X ↔ M✶.Basis ((M.E \\ B) ∩ (M.E \\ X)) (M.E \\ X) := by\n  refine ⟨hB.compl_inter_basis_of_inter_basis, fun h ↦ ?_⟩\n  simpa [inter_eq_self_of_subset_right hX, inter_eq_self_of_subset_right hB.subset_ground] using\n    hB.compl_base_dual.compl_inter_basis_of_inter_basis h\n\n"}
{"name":"Matroid.base_iff_dual_base_compl","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\nhB : autoParam (HasSubset.Subset B M.E) _auto✝\n⊢ Iff (M.Base B) (M.dual.Base (SDiff.sdiff M.E B))","decl":"theorem base_iff_dual_base_compl (hB : B ⊆ M.E := by aesop_mat) :\n    M.Base B ↔ M✶.Base (M.E \\ B) := by\n  rw [dual_base_iff, diff_diff_cancel_left hB]\n\n"}
{"name":"Matroid.ground_not_base","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nh : M.dual.RkPos\n⊢ Not (M.Base M.E)","decl":"theorem ground_not_base (M : Matroid α) [h : RkPos M✶] : ¬M.Base M.E := by\n  rwa [rkPos_iff, dual_base_iff, diff_empty] at h\n\n"}
{"name":"Matroid.Base.ssubset_ground","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\nh : M.dual.RkPos\nhB : M.Base B\n⊢ HasSSubset.SSubset B M.E","decl":"theorem Base.ssubset_ground [h : RkPos M✶] (hB : M.Base B) : B ⊂ M.E :=\n  hB.subset_ground.ssubset_of_ne (by rintro rfl; exact M.ground_not_base hB)\n\n"}
{"name":"Matroid.Indep.ssubset_ground","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nh : M.dual.RkPos\nhI : M.Indep I\n⊢ HasSSubset.SSubset I M.E","decl":"theorem Indep.ssubset_ground [h : RkPos M✶] (hI : M.Indep I) : I ⊂ M.E := by\n  obtain ⟨B, hB⟩ := hI.exists_base_superset; exact hB.2.trans_ssubset hB.1.ssubset_ground\n\n"}
{"name":"Matroid.coindep_def","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\n⊢ Iff (M.Coindep X) (M.dual.Indep X)","decl":"theorem coindep_def : M.Coindep X ↔ M✶.Indep X := Iff.rfl\n\n"}
{"name":"Matroid.Coindep.indep","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nhX : M.Coindep X\n⊢ M.dual.Indep X","decl":"theorem Coindep.indep (hX : M.Coindep X) : M✶.Indep X :=\n  hX\n\n"}
{"name":"Matroid.dual_coindep_iff","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\n⊢ Iff (M.dual.Coindep X) (M.Indep X)","decl":"@[simp] theorem dual_coindep_iff : M✶.Coindep X ↔ M.Indep X := by\n  rw [Coindep, dual_dual]\n\n"}
{"name":"Matroid.Indep.coindep","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : M.Indep I\n⊢ M.dual.Coindep I","decl":"theorem Indep.coindep (hI : M.Indep I) : M✶.Coindep I :=\n  dual_coindep_iff.2 hI\n\n"}
{"name":"Matroid.coindep_iff_exists'","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\n⊢ Iff (M.Coindep X) (And (Exists fun B => And (M.Base B) (HasSubset.Subset B (SDiff.sdiff M.E X))) (HasSubset.Subset X M.E))","decl":"theorem coindep_iff_exists' : M.Coindep X ↔ (∃ B, M.Base B ∧ B ⊆ M.E \\ X) ∧ X ⊆ M.E := by\n  simp_rw [Coindep, dual_indep_iff_exists', and_comm (a := _ ⊆ _), and_congr_left_iff, subset_diff]\n  exact fun _ ↦ ⟨fun ⟨B, hB, hXB⟩ ↦ ⟨B, hB, hB.subset_ground, hXB.symm⟩,\n    fun ⟨B, hB, _, hBX⟩ ↦ ⟨B, hB, hBX.symm⟩⟩\n\n"}
{"name":"Matroid.coindep_iff_exists","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff (M.Coindep X) (Exists fun B => And (M.Base B) (HasSubset.Subset B (SDiff.sdiff M.E X)))","decl":"theorem coindep_iff_exists (hX : X ⊆ M.E := by aesop_mat) :\n    M.Coindep X ↔ ∃ B, M.Base B ∧ B ⊆ M.E \\ X := by\n  rw [coindep_iff_exists', and_iff_left hX]\n\n"}
{"name":"Matroid.coindep_iff_subset_compl_base","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\n⊢ Iff (M.Coindep X) (Exists fun B => And (M.Base B) (HasSubset.Subset X (SDiff.sdiff M.E B)))","decl":"theorem coindep_iff_subset_compl_base : M.Coindep X ↔ ∃ B, M.Base B ∧ X ⊆ M.E \\ B := by\n  simp_rw [coindep_iff_exists', subset_diff]\n  exact ⟨fun ⟨⟨B, hB, _, hBX⟩, hX⟩ ↦ ⟨B, hB, hX, hBX.symm⟩,\n    fun ⟨B, hB, hXE, hXB⟩ ↦ ⟨⟨B, hB, hB.subset_ground,  hXB.symm⟩, hXE⟩⟩\n\n"}
{"name":"Matroid.Coindep.subset_ground","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nhX : M.Coindep X\n⊢ HasSubset.Subset X M.E","decl":"@[aesop unsafe 10% (rule_sets := [Matroid])]\ntheorem Coindep.subset_ground (hX : M.Coindep X) : X ⊆ M.E :=\n  hX.indep.subset_ground\n\n"}
{"name":"Matroid.Coindep.exists_base_subset_compl","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nh : M.Coindep X\n⊢ Exists fun B => And (M.Base B) (HasSubset.Subset B (SDiff.sdiff M.E X))","decl":"theorem Coindep.exists_base_subset_compl (h : M.Coindep X) : ∃ B, M.Base B ∧ B ⊆ M.E \\ X :=\n  (coindep_iff_exists h.subset_ground).1 h\n\n"}
{"name":"Matroid.Coindep.exists_subset_compl_base","module":"Mathlib.Data.Matroid.Dual","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nh : M.Coindep X\n⊢ Exists fun B => And (M.Base B) (HasSubset.Subset X (SDiff.sdiff M.E B))","decl":"theorem Coindep.exists_subset_compl_base (h : M.Coindep X) : ∃ B, M.Base B ∧ X ⊆ M.E \\ B :=\n  coindep_iff_subset_compl_base.1 h\n\n"}
