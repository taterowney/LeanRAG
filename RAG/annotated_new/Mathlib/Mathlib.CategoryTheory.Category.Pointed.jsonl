{"name":"Pointed.mk.inj","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X‚úù : Type u\npoint‚úù : X‚úù\nX : Type u\npoint : X\nx‚úù : Eq { X := X‚úù, point := point‚úù } { X := X, point := point }\n‚ä¢ And (Eq X‚úù X) (HEq point‚úù point)","decl":"/-- The category of pointed types. -/\nstructure Pointed : Type (u + 1) where\n  /-- the underlying type -/\n  protected X : Type u\n  /-- the distinguished element -/\n  point : X\n\n"}
{"name":"Pointed.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X : Type u\npoint : X\n‚ä¢ Eq (SizeOf.sizeOf { X := X, point := point }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf point))","decl":"/-- The category of pointed types. -/\nstructure Pointed : Type (u + 1) where\n  /-- the underlying type -/\n  protected X : Type u\n  /-- the distinguished element -/\n  point : X\n\n"}
{"name":"Pointed.mk.injEq","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X‚úù : Type u\npoint‚úù : X‚úù\nX : Type u\npoint : X\n‚ä¢ Eq (Eq { X := X‚úù, point := point‚úù } { X := X, point := point }) (And (Eq X‚úù X) (HEq point‚úù point))","decl":"/-- The category of pointed types. -/\nstructure Pointed : Type (u + 1) where\n  /-- the underlying type -/\n  protected X : Type u\n  /-- the distinguished element -/\n  point : X\n\n"}
{"name":"Pointed.coe_of","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X : Type u_1\npoint : X\n‚ä¢ Eq (Pointed.of point).X X","decl":"@[simp]\ntheorem coe_of {X : Type*} (point : X) : ‚Ü•(of point) = X :=\n  rfl\n\n"}
{"name":"Pointed.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X Y : Pointed\ntoFun : X.X ‚Üí Y.X\nmap_point : Eq (toFun X.point) Y.point\n‚ä¢ Eq (SizeOf.sizeOf { toFun := toFun, map_point := map_point }) (HAdd.hAdd 1 (SizeOf.sizeOf map_point))","decl":"/-- Morphisms in `Pointed`. -/\n@[ext]\nprotected structure Hom (X Y : Pointed.{u}) : Type u where\n  /-- the underlying map -/\n  toFun : X ‚Üí Y\n  /-- compatibility with the distinguished points -/\n  map_point : toFun X.point = Y.point\n\n"}
{"name":"Pointed.Hom.mk.inj","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X Y : Pointed\ntoFun‚úù : X.X ‚Üí Y.X\nmap_point‚úù : Eq (toFun‚úù X.point) Y.point\ntoFun : X.X ‚Üí Y.X\nmap_point : Eq (toFun X.point) Y.point\nx‚úù : Eq { toFun := toFun‚úù, map_point := map_point‚úù } { toFun := toFun, map_point := map_point }\n‚ä¢ Eq toFun‚úù toFun","decl":"/-- Morphisms in `Pointed`. -/\n@[ext]\nprotected structure Hom (X Y : Pointed.{u}) : Type u where\n  /-- the underlying map -/\n  toFun : X ‚Üí Y\n  /-- compatibility with the distinguished points -/\n  map_point : toFun X.point = Y.point\n\n"}
{"name":"Pointed.Hom.map_point","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X Y : Pointed\nself : X.Hom Y\n‚ä¢ Eq (self.toFun X.point) Y.point","decl":"/-- Morphisms in `Pointed`. -/\n@[ext]\nprotected structure Hom (X Y : Pointed.{u}) : Type u where\n  /-- the underlying map -/\n  toFun : X ‚Üí Y\n  /-- compatibility with the distinguished points -/\n  map_point : toFun X.point = Y.point\n\n"}
{"name":"Pointed.Hom.ext_iff","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X Y : Pointed\nx y : X.Hom Y\n‚ä¢ Iff (Eq x y) (Eq x.toFun y.toFun)","decl":"/-- Morphisms in `Pointed`. -/\n@[ext]\nprotected structure Hom (X Y : Pointed.{u}) : Type u where\n  /-- the underlying map -/\n  toFun : X ‚Üí Y\n  /-- compatibility with the distinguished points -/\n  map_point : toFun X.point = Y.point\n\n"}
{"name":"Pointed.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X Y : Pointed\ntoFun‚úù : X.X ‚Üí Y.X\nmap_point‚úù : Eq (toFun‚úù X.point) Y.point\ntoFun : X.X ‚Üí Y.X\nmap_point : Eq (toFun X.point) Y.point\n‚ä¢ Eq (Eq { toFun := toFun‚úù, map_point := map_point‚úù } { toFun := toFun, map_point := map_point }) (Eq toFun‚úù toFun)","decl":"/-- Morphisms in `Pointed`. -/\n@[ext]\nprotected structure Hom (X Y : Pointed.{u}) : Type u where\n  /-- the underlying map -/\n  toFun : X ‚Üí Y\n  /-- compatibility with the distinguished points -/\n  map_point : toFun X.point = Y.point\n\n"}
{"name":"Pointed.Hom.ext","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X Y : Pointed\nx y : X.Hom Y\ntoFun : Eq x.toFun y.toFun\n‚ä¢ Eq x y","decl":"/-- Morphisms in `Pointed`. -/\n@[ext]\nprotected structure Hom (X Y : Pointed.{u}) : Type u where\n  /-- the underlying map -/\n  toFun : X ‚Üí Y\n  /-- compatibility with the distinguished points -/\n  map_point : toFun X.point = Y.point\n\n"}
{"name":"Pointed.Hom.id_toFun","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X : Pointed\na : X.X\n‚ä¢ Eq ((Pointed.Hom.id X).toFun a) (id a)","decl":"/-- The identity morphism of `X : Pointed`. -/\n@[simps]\ndef id (X : Pointed) : Pointed.Hom X X :=\n  ‚ü®_root_.id, rfl‚ü©\n\n"}
{"name":"Pointed.Hom.comp_toFun","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X Y Z : Pointed\nf : X.Hom Y\ng : Y.Hom Z\na‚úù : X.X\n‚ä¢ Eq ((f.comp g).toFun a‚úù) (Function.comp g.toFun f.toFun a‚úù)","decl":"/-- Composition of morphisms of `Pointed`. -/\n@[simps]\ndef comp {X Y Z : Pointed.{u}} (f : Pointed.Hom X Y) (g : Pointed.Hom Y Z) : Pointed.Hom X Z :=\n  ‚ü®g.toFun ‚àò f.toFun, by rw [Function.comp_apply, f.map_point, g.map_point]‚ü©\n\n"}
{"name":"Pointed.Hom.id_toFun'","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X : Pointed\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).toFun id","decl":"@[simp] lemma Hom.id_toFun' (X : Pointed.{u}) : (ùüô X : X ‚ü∂ X).toFun = _root_.id := rfl\n\n"}
{"name":"Pointed.Hom.comp_toFun'","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X Y Z : Pointed\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).toFun (Function.comp g.toFun f.toFun)","decl":"@[simp] lemma Hom.comp_toFun' {X Y Z : Pointed.{u}} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).toFun = g.toFun ‚àò f.toFun := rfl\n\n"}
{"name":"Pointed.Iso.mk_hom_toFun","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"Œ± Œ≤ : Pointed\ne : Equiv Œ±.X Œ≤.X\nhe : Eq (e Œ±.point) Œ≤.point\na : Œ±.X\n‚ä¢ Eq ((Pointed.Iso.mk e he).hom.toFun a) (e a)","decl":"/-- Constructs an isomorphism between pointed types from an equivalence that preserves the point\nbetween them. -/\n@[simps]\ndef Iso.mk {Œ± Œ≤ : Pointed} (e : Œ± ‚âÉ Œ≤) (he : e Œ±.point = Œ≤.point) : Œ± ‚âÖ Œ≤ where\n  hom := ‚ü®e, he‚ü©\n  inv := ‚ü®e.symm, e.symm_apply_eq.2 he.symm‚ü©\n  hom_inv_id := Pointed.Hom.ext e.symm_comp_self\n  inv_hom_id := Pointed.Hom.ext e.self_comp_symm\n\n"}
{"name":"Pointed.Iso.mk_inv_toFun","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"Œ± Œ≤ : Pointed\ne : Equiv Œ±.X Œ≤.X\nhe : Eq (e Œ±.point) Œ≤.point\na : Œ≤.X\n‚ä¢ Eq ((Pointed.Iso.mk e he).inv.toFun a) (e.symm a)","decl":"/-- Constructs an isomorphism between pointed types from an equivalence that preserves the point\nbetween them. -/\n@[simps]\ndef Iso.mk {Œ± Œ≤ : Pointed} (e : Œ± ‚âÉ Œ≤) (he : e Œ±.point = Œ≤.point) : Œ± ‚âÖ Œ≤ where\n  hom := ‚ü®e, he‚ü©\n  inv := ‚ü®e.symm, e.symm_apply_eq.2 he.symm‚ü©\n  hom_inv_id := Pointed.Hom.ext e.symm_comp_self\n  inv_hom_id := Pointed.Hom.ext e.self_comp_symm\n\n"}
{"name":"typeToPointed_map_toFun","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X‚úù Y‚úù : Type u\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : Option X‚úù\n‚ä¢ Eq ((typeToPointed.map f).toFun a‚úù) (Option.map f a‚úù)","decl":"/-- `Option` as a functor from types to pointed types. This is the free functor. -/\n@[simps]\ndef typeToPointed : Type u ‚•§ Pointed.{u} where\n  obj X := ‚ü®Option X, none‚ü©\n  map f := ‚ü®Option.map f, rfl‚ü©\n  map_id _ := Pointed.Hom.ext Option.map_id\n  map_comp _ _ := Pointed.Hom.ext (Option.map_comp_map _ _).symm\n\n"}
{"name":"typeToPointed_obj_point","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X : Type u\n‚ä¢ Eq (typeToPointed.obj X).point Option.none","decl":"/-- `Option` as a functor from types to pointed types. This is the free functor. -/\n@[simps]\ndef typeToPointed : Type u ‚•§ Pointed.{u} where\n  obj X := ‚ü®Option X, none‚ü©\n  map f := ‚ü®Option.map f, rfl‚ü©\n  map_id _ := Pointed.Hom.ext Option.map_id\n  map_comp _ _ := Pointed.Hom.ext (Option.map_comp_map _ _).symm\n\n"}
{"name":"typeToPointed_obj_X","module":"Mathlib.CategoryTheory.Category.Pointed","initialProofState":"X : Type u\n‚ä¢ Eq (typeToPointed.obj X).X (Option X)","decl":"/-- `Option` as a functor from types to pointed types. This is the free functor. -/\n@[simps]\ndef typeToPointed : Type u ‚•§ Pointed.{u} where\n  obj X := ‚ü®Option X, none‚ü©\n  map f := ‚ü®Option.map f, rfl‚ü©\n  map_id _ := Pointed.Hom.ext Option.map_id\n  map_comp _ _ := Pointed.Hom.ext (Option.map_comp_map _ _).symm\n\n"}
