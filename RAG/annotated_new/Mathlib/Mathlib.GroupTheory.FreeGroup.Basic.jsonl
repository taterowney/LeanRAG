{"name":"FreeAddGroup.Red.refl","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\n⊢ FreeAddGroup.Red L L","decl":"@[to_additive (attr := refl)]\ntheorem Red.refl : Red L L :=\n  ReflTransGen.refl\n\n"}
{"name":"FreeGroup.Red.refl","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\n⊢ FreeGroup.Red L L","decl":"@[to_additive (attr := refl)]\ntheorem Red.refl : Red L L :=\n  ReflTransGen.refl\n\n"}
{"name":"FreeAddGroup.Red.trans","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ : List (Prod α Bool)\na✝¹ : FreeAddGroup.Red L₁ L₂\na✝ : FreeAddGroup.Red L₂ L₃\n⊢ FreeAddGroup.Red L₁ L₃","decl":"@[to_additive (attr := trans)]\ntheorem Red.trans : Red L₁ L₂ → Red L₂ L₃ → Red L₁ L₃ :=\n  ReflTransGen.trans\n\n"}
{"name":"FreeGroup.Red.trans","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ : List (Prod α Bool)\na✝¹ : FreeGroup.Red L₁ L₂\na✝ : FreeGroup.Red L₂ L₃\n⊢ FreeGroup.Red L₁ L₃","decl":"@[to_additive (attr := trans)]\ntheorem Red.trans : Red L₁ L₂ → Red L₂ L₃ → Red L₁ L₃ :=\n  ReflTransGen.trans\n\n"}
{"name":"FreeAddGroup.Red.Step.length","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\na✝ : FreeAddGroup.Red.Step L₁ L₂\n⊢ Eq (HAdd.hAdd L₂.length 2) L₁.length","decl":"/-- Predicate asserting that the word `w₁` can be reduced to `w₂` in one step, i.e. there are words\n`w₃ w₄` and letter `x` such that `w₁ = w₃xx⁻¹w₄` and `w₂ = w₃w₄`  -/\n@[to_additive \"Predicate asserting that the word `w₁` can be reduced to `w₂` in one step, i.e. there\n  are words `w₃ w₄` and letter `x` such that `w₁ = w₃ + x + (-x) + w₄` and `w₂ = w₃w₄`\"]\ntheorem Step.length : ∀ {L₁ L₂ : List (α × Bool)}, Step L₁ L₂ → L₂.length + 2 = L₁.length\n  | _, _, @Red.Step.not _ L1 L2 x b => by rw [List.length_append, List.length_append]; rfl\n\n"}
{"name":"FreeGroup.Red.Step.length","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\na✝ : FreeGroup.Red.Step L₁ L₂\n⊢ Eq (HAdd.hAdd L₂.length 2) L₁.length","decl":"/-- Predicate asserting that the word `w₁` can be reduced to `w₂` in one step, i.e. there are words\n`w₃ w₄` and letter `x` such that `w₁ = w₃xx⁻¹w₄` and `w₂ = w₃w₄`  -/\n@[to_additive \"Predicate asserting that the word `w₁` can be reduced to `w₂` in one step, i.e. there\n  are words `w₃ w₄` and letter `x` such that `w₁ = w₃ + x + (-x) + w₄` and `w₂ = w₃w₄`\"]\ntheorem Step.length : ∀ {L₁ L₂ : List (α × Bool)}, Step L₁ L₂ → L₂.length + 2 = L₁.length\n  | _, _, @Red.Step.not _ L1 L2 x b => by rw [List.length_append, List.length_append]; rfl\n\n"}
{"name":"FreeAddGroup.Red.Step.not_rev","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nx : α\nb : Bool\n⊢ FreeAddGroup.Red.Step (HAppend.hAppend L₁ (List.cons { fst := x, snd := b.not } (List.cons { fst := x, snd := b } L₂))) (HAppend.hAppend L₁ L₂)","decl":"@[to_additive (attr := simp)]\ntheorem Step.not_rev {x b} : Step (L₁ ++ (x, !b) :: (x, b) :: L₂) (L₁ ++ L₂) := by\n  cases b <;> exact Step.not\n\n"}
{"name":"FreeGroup.Red.Step.not_rev","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nx : α\nb : Bool\n⊢ FreeGroup.Red.Step (HAppend.hAppend L₁ (List.cons { fst := x, snd := b.not } (List.cons { fst := x, snd := b } L₂))) (HAppend.hAppend L₁ L₂)","decl":"@[to_additive (attr := simp)]\ntheorem Step.not_rev {x b} : Step (L₁ ++ (x, !b) :: (x, b) :: L₂) (L₁ ++ L₂) := by\n  cases b <;> exact Step.not\n\n"}
{"name":"FreeAddGroup.Red.Step.cons_not","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nx : α\nb : Bool\n⊢ FreeAddGroup.Red.Step (List.cons { fst := x, snd := b } (List.cons { fst := x, snd := b.not } L)) L","decl":"@[to_additive (attr := simp)]\ntheorem Step.cons_not {x b} : Red.Step ((x, b) :: (x, !b) :: L) L :=\n  @Step.not _ [] _ _ _\n\n"}
{"name":"FreeGroup.Red.Step.cons_not","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nx : α\nb : Bool\n⊢ FreeGroup.Red.Step (List.cons { fst := x, snd := b } (List.cons { fst := x, snd := b.not } L)) L","decl":"@[to_additive (attr := simp)]\ntheorem Step.cons_not {x b} : Red.Step ((x, b) :: (x, !b) :: L) L :=\n  @Step.not _ [] _ _ _\n\n"}
{"name":"FreeGroup.Red.Step.cons_not_rev","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nx : α\nb : Bool\n⊢ FreeGroup.Red.Step (List.cons { fst := x, snd := b.not } (List.cons { fst := x, snd := b } L)) L","decl":"@[to_additive (attr := simp)]\ntheorem Step.cons_not_rev {x b} : Red.Step ((x, !b) :: (x, b) :: L) L :=\n  @Red.Step.not_rev _ [] _ _ _\n\n"}
{"name":"FreeAddGroup.Red.Step.cons_not_rev","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nx : α\nb : Bool\n⊢ FreeAddGroup.Red.Step (List.cons { fst := x, snd := b.not } (List.cons { fst := x, snd := b } L)) L","decl":"@[to_additive (attr := simp)]\ntheorem Step.cons_not_rev {x b} : Red.Step ((x, !b) :: (x, b) :: L) L :=\n  @Red.Step.not_rev _ [] _ _ _\n\n"}
{"name":"FreeGroup.Red.Step.append_left","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ : List (Prod α Bool)\na✝ : FreeGroup.Red.Step L₂ L₃\n⊢ FreeGroup.Red.Step (HAppend.hAppend L₁ L₂) (HAppend.hAppend L₁ L₃)","decl":"@[to_additive]\ntheorem Step.append_left : ∀ {L₁ L₂ L₃ : List (α × Bool)}, Step L₂ L₃ → Step (L₁ ++ L₂) (L₁ ++ L₃)\n  | _, _, _, Red.Step.not => by rw [← List.append_assoc, ← List.append_assoc]; constructor\n\n"}
{"name":"FreeAddGroup.Red.Step.append_left","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ : List (Prod α Bool)\na✝ : FreeAddGroup.Red.Step L₂ L₃\n⊢ FreeAddGroup.Red.Step (HAppend.hAppend L₁ L₂) (HAppend.hAppend L₁ L₃)","decl":"@[to_additive]\ntheorem Step.append_left : ∀ {L₁ L₂ L₃ : List (α × Bool)}, Step L₂ L₃ → Step (L₁ ++ L₂) (L₁ ++ L₃)\n  | _, _, _, Red.Step.not => by rw [← List.append_assoc, ← List.append_assoc]; constructor\n\n"}
{"name":"FreeAddGroup.Red.Step.cons","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nx : Prod α Bool\nH : FreeAddGroup.Red.Step L₁ L₂\n⊢ FreeAddGroup.Red.Step (List.cons x L₁) (List.cons x L₂)","decl":"@[to_additive]\ntheorem Step.cons {x} (H : Red.Step L₁ L₂) : Red.Step (x :: L₁) (x :: L₂) :=\n  @Step.append_left _ [x] _ _ H\n\n"}
{"name":"FreeGroup.Red.Step.cons","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nx : Prod α Bool\nH : FreeGroup.Red.Step L₁ L₂\n⊢ FreeGroup.Red.Step (List.cons x L₁) (List.cons x L₂)","decl":"@[to_additive]\ntheorem Step.cons {x} (H : Red.Step L₁ L₂) : Red.Step (x :: L₁) (x :: L₂) :=\n  @Step.append_left _ [x] _ _ H\n\n"}
{"name":"FreeGroup.Red.Step.append_right","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ : List (Prod α Bool)\na✝ : FreeGroup.Red.Step L₁ L₂\n⊢ FreeGroup.Red.Step (HAppend.hAppend L₁ L₃) (HAppend.hAppend L₂ L₃)","decl":"@[to_additive]\ntheorem Step.append_right : ∀ {L₁ L₂ L₃ : List (α × Bool)}, Step L₁ L₂ → Step (L₁ ++ L₃) (L₂ ++ L₃)\n  | _, _, _, Red.Step.not => by simp\n\n"}
{"name":"FreeAddGroup.Red.Step.append_right","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ : List (Prod α Bool)\na✝ : FreeAddGroup.Red.Step L₁ L₂\n⊢ FreeAddGroup.Red.Step (HAppend.hAppend L₁ L₃) (HAppend.hAppend L₂ L₃)","decl":"@[to_additive]\ntheorem Step.append_right : ∀ {L₁ L₂ L₃ : List (α × Bool)}, Step L₁ L₂ → Step (L₁ ++ L₃) (L₂ ++ L₃)\n  | _, _, _, Red.Step.not => by simp\n\n"}
{"name":"FreeGroup.Red.not_step_nil","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\n⊢ Not (FreeGroup.Red.Step List.nil L)","decl":"@[to_additive]\ntheorem not_step_nil : ¬Step [] L := by\n  generalize h' : [] = L'\n  intro h\n  cases' h with L₁ L₂\n  simp [List.nil_eq_append_iff] at h'\n\n"}
{"name":"FreeAddGroup.Red.not_step_nil","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\n⊢ Not (FreeAddGroup.Red.Step List.nil L)","decl":"@[to_additive]\ntheorem not_step_nil : ¬Step [] L := by\n  generalize h' : [] = L'\n  intro h\n  cases' h with L₁ L₂\n  simp [List.nil_eq_append_iff] at h'\n\n"}
{"name":"FreeAddGroup.Red.Step.cons_left_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\na : α\nb : Bool\n⊢ Iff (FreeAddGroup.Red.Step (List.cons { fst := a, snd := b } L₁) L₂) (Or (Exists fun L => And (FreeAddGroup.Red.Step L₁ L) (Eq L₂ (List.cons { fst := a, snd := b } L))) (Eq L₁ (List.cons { fst := a, snd := b.not } L₂)))","decl":"@[to_additive]\ntheorem Step.cons_left_iff {a : α} {b : Bool} :\n    Step ((a, b) :: L₁) L₂ ↔ (∃ L, Step L₁ L ∧ L₂ = (a, b) :: L) ∨ L₁ = (a, ! b) :: L₂ := by\n  constructor\n  · generalize hL : ((a, b) :: L₁ : List _) = L\n    rintro @⟨_ | ⟨p, s'⟩, e, a', b'⟩\n    · simp at hL\n      simp [*]\n    · simp at hL\n      rcases hL with ⟨rfl, rfl⟩\n      refine Or.inl ⟨s' ++ e, Step.not, ?_⟩\n      simp\n  · rintro (⟨L, h, rfl⟩ | rfl)\n    · exact Step.cons h\n    · exact Step.cons_not\n\n"}
{"name":"FreeGroup.Red.Step.cons_left_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\na : α\nb : Bool\n⊢ Iff (FreeGroup.Red.Step (List.cons { fst := a, snd := b } L₁) L₂) (Or (Exists fun L => And (FreeGroup.Red.Step L₁ L) (Eq L₂ (List.cons { fst := a, snd := b } L))) (Eq L₁ (List.cons { fst := a, snd := b.not } L₂)))","decl":"@[to_additive]\ntheorem Step.cons_left_iff {a : α} {b : Bool} :\n    Step ((a, b) :: L₁) L₂ ↔ (∃ L, Step L₁ L ∧ L₂ = (a, b) :: L) ∨ L₁ = (a, ! b) :: L₂ := by\n  constructor\n  · generalize hL : ((a, b) :: L₁ : List _) = L\n    rintro @⟨_ | ⟨p, s'⟩, e, a', b'⟩\n    · simp at hL\n      simp [*]\n    · simp at hL\n      rcases hL with ⟨rfl, rfl⟩\n      refine Or.inl ⟨s' ++ e, Step.not, ?_⟩\n      simp\n  · rintro (⟨L, h, rfl⟩ | rfl)\n    · exact Step.cons h\n    · exact Step.cons_not\n\n"}
{"name":"FreeGroup.Red.not_step_singleton","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\np : Prod α Bool\n⊢ Not (FreeGroup.Red.Step (List.cons p List.nil) L)","decl":"@[to_additive]\ntheorem not_step_singleton : ∀ {p : α × Bool}, ¬Step [p] L\n  | (a, b) => by simp [Step.cons_left_iff, not_step_nil]\n\n"}
{"name":"FreeAddGroup.Red.not_step_singleton","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\np : Prod α Bool\n⊢ Not (FreeAddGroup.Red.Step (List.cons p List.nil) L)","decl":"@[to_additive]\ntheorem not_step_singleton : ∀ {p : α × Bool}, ¬Step [p] L\n  | (a, b) => by simp [Step.cons_left_iff, not_step_nil]\n\n"}
{"name":"FreeGroup.Red.Step.cons_cons_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\np : Prod α Bool\n⊢ Iff (FreeGroup.Red.Step (List.cons p L₁) (List.cons p L₂)) (FreeGroup.Red.Step L₁ L₂)","decl":"@[to_additive]\ntheorem Step.cons_cons_iff : ∀ {p : α × Bool}, Step (p :: L₁) (p :: L₂) ↔ Step L₁ L₂ := by\n  simp +contextual [Step.cons_left_iff, iff_def, or_imp]\n\n"}
{"name":"FreeAddGroup.Red.Step.cons_cons_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\np : Prod α Bool\n⊢ Iff (FreeAddGroup.Red.Step (List.cons p L₁) (List.cons p L₂)) (FreeAddGroup.Red.Step L₁ L₂)","decl":"@[to_additive]\ntheorem Step.cons_cons_iff : ∀ {p : α × Bool}, Step (p :: L₁) (p :: L₂) ↔ Step L₁ L₂ := by\n  simp +contextual [Step.cons_left_iff, iff_def, or_imp]\n\n"}
{"name":"FreeGroup.Red.Step.append_left_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L : List (Prod α Bool)\n⊢ Iff (FreeGroup.Red.Step (HAppend.hAppend L L₁) (HAppend.hAppend L L₂)) (FreeGroup.Red.Step L₁ L₂)","decl":"@[to_additive]\ntheorem Step.append_left_iff : ∀ L, Step (L ++ L₁) (L ++ L₂) ↔ Step L₁ L₂\n  | [] => by simp\n  | p :: l => by simp [Step.append_left_iff l, Step.cons_cons_iff]\n\n"}
{"name":"FreeAddGroup.Red.Step.append_left_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L : List (Prod α Bool)\n⊢ Iff (FreeAddGroup.Red.Step (HAppend.hAppend L L₁) (HAppend.hAppend L L₂)) (FreeAddGroup.Red.Step L₁ L₂)","decl":"@[to_additive]\ntheorem Step.append_left_iff : ∀ L, Step (L ++ L₁) (L ++ L₂) ↔ Step L₁ L₂\n  | [] => by simp\n  | p :: l => by simp [Step.append_left_iff l, Step.cons_cons_iff]\n\n"}
{"name":"FreeGroup.Red.Step.diamond_aux","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ L₄ : List (Prod α Bool)\nx1 : α\nb1 : Bool\nx2 : α\nb2 : Bool\na✝ : Eq (HAppend.hAppend L₁ (List.cons { fst := x1, snd := b1 } (List.cons { fst := x1, snd := b1.not } L₂))) (HAppend.hAppend L₃ (List.cons { fst := x2, snd := b2 } (List.cons { fst := x2, snd := b2.not } L₄)))\n⊢ Or (Eq (HAppend.hAppend L₁ L₂) (HAppend.hAppend L₃ L₄)) (Exists fun L₅ => And (FreeGroup.Red.Step (HAppend.hAppend L₁ L₂) L₅) (FreeGroup.Red.Step (HAppend.hAppend L₃ L₄) L₅))","decl":"@[to_additive]\ntheorem Step.diamond_aux :\n    ∀ {L₁ L₂ L₃ L₄ : List (α × Bool)} {x1 b1 x2 b2},\n      L₁ ++ (x1, b1) :: (x1, !b1) :: L₂ = L₃ ++ (x2, b2) :: (x2, !b2) :: L₄ →\n        L₁ ++ L₂ = L₃ ++ L₄ ∨ ∃ L₅, Red.Step (L₁ ++ L₂) L₅ ∧ Red.Step (L₃ ++ L₄) L₅\n  | [], _, [], _, _, _, _, _, H => by injections; subst_vars; simp\n  | [], _, [(x3, b3)], _, _, _, _, _, H => by injections; subst_vars; simp\n  | [(x3, b3)], _, [], _, _, _, _, _, H => by injections; subst_vars; simp\n  | [], _, (x3, b3) :: (x4, b4) :: tl, _, _, _, _, _, H => by\n    injections; subst_vars; right; exact ⟨_, Red.Step.not, Red.Step.cons_not⟩\n  | (x3, b3) :: (x4, b4) :: tl, _, [], _, _, _, _, _, H => by\n    injections; subst_vars; right; simpa using ⟨_, Red.Step.cons_not, Red.Step.not⟩\n  | (x3, b3) :: tl, _, (x4, b4) :: tl2, _, _, _, _, _, H =>\n    let ⟨H1, H2⟩ := List.cons.inj H\n    match Step.diamond_aux H2 with\n    | Or.inl H3 => Or.inl <| by simp [H1, H3]\n    | Or.inr ⟨L₅, H3, H4⟩ => Or.inr ⟨_, Step.cons H3, by simpa [H1] using Step.cons H4⟩\n\n"}
{"name":"FreeAddGroup.Red.Step.diamond_aux","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ L₄ : List (Prod α Bool)\nx1 : α\nb1 : Bool\nx2 : α\nb2 : Bool\na✝ : Eq (HAppend.hAppend L₁ (List.cons { fst := x1, snd := b1 } (List.cons { fst := x1, snd := b1.not } L₂))) (HAppend.hAppend L₃ (List.cons { fst := x2, snd := b2 } (List.cons { fst := x2, snd := b2.not } L₄)))\n⊢ Or (Eq (HAppend.hAppend L₁ L₂) (HAppend.hAppend L₃ L₄)) (Exists fun L₅ => And (FreeAddGroup.Red.Step (HAppend.hAppend L₁ L₂) L₅) (FreeAddGroup.Red.Step (HAppend.hAppend L₃ L₄) L₅))","decl":"@[to_additive]\ntheorem Step.diamond_aux :\n    ∀ {L₁ L₂ L₃ L₄ : List (α × Bool)} {x1 b1 x2 b2},\n      L₁ ++ (x1, b1) :: (x1, !b1) :: L₂ = L₃ ++ (x2, b2) :: (x2, !b2) :: L₄ →\n        L₁ ++ L₂ = L₃ ++ L₄ ∨ ∃ L₅, Red.Step (L₁ ++ L₂) L₅ ∧ Red.Step (L₃ ++ L₄) L₅\n  | [], _, [], _, _, _, _, _, H => by injections; subst_vars; simp\n  | [], _, [(x3, b3)], _, _, _, _, _, H => by injections; subst_vars; simp\n  | [(x3, b3)], _, [], _, _, _, _, _, H => by injections; subst_vars; simp\n  | [], _, (x3, b3) :: (x4, b4) :: tl, _, _, _, _, _, H => by\n    injections; subst_vars; right; exact ⟨_, Red.Step.not, Red.Step.cons_not⟩\n  | (x3, b3) :: (x4, b4) :: tl, _, [], _, _, _, _, _, H => by\n    injections; subst_vars; right; simpa using ⟨_, Red.Step.cons_not, Red.Step.not⟩\n  | (x3, b3) :: tl, _, (x4, b4) :: tl2, _, _, _, _, _, H =>\n    let ⟨H1, H2⟩ := List.cons.inj H\n    match Step.diamond_aux H2 with\n    | Or.inl H3 => Or.inl <| by simp [H1, H3]\n    | Or.inr ⟨L₅, H3, H4⟩ => Or.inr ⟨_, Step.cons H3, by simpa [H1] using Step.cons H4⟩\n\n"}
{"name":"FreeGroup.Red.Step.diamond","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ L₄ : List (Prod α Bool)\na✝² : FreeGroup.Red.Step L₁ L₃\na✝¹ : FreeGroup.Red.Step L₂ L₄\na✝ : Eq L₁ L₂\n⊢ Or (Eq L₃ L₄) (Exists fun L₅ => And (FreeGroup.Red.Step L₃ L₅) (FreeGroup.Red.Step L₄ L₅))","decl":"@[to_additive]\ntheorem Step.diamond :\n    ∀ {L₁ L₂ L₃ L₄ : List (α × Bool)},\n      Red.Step L₁ L₃ → Red.Step L₂ L₄ → L₁ = L₂ → L₃ = L₄ ∨ ∃ L₅, Red.Step L₃ L₅ ∧ Red.Step L₄ L₅\n  | _, _, _, _, Red.Step.not, Red.Step.not, H => Step.diamond_aux H\n\n"}
{"name":"FreeAddGroup.Red.Step.diamond","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ L₄ : List (Prod α Bool)\na✝² : FreeAddGroup.Red.Step L₁ L₃\na✝¹ : FreeAddGroup.Red.Step L₂ L₄\na✝ : Eq L₁ L₂\n⊢ Or (Eq L₃ L₄) (Exists fun L₅ => And (FreeAddGroup.Red.Step L₃ L₅) (FreeAddGroup.Red.Step L₄ L₅))","decl":"@[to_additive]\ntheorem Step.diamond :\n    ∀ {L₁ L₂ L₃ L₄ : List (α × Bool)},\n      Red.Step L₁ L₃ → Red.Step L₂ L₄ → L₁ = L₂ → L₃ = L₄ ∨ ∃ L₅, Red.Step L₃ L₅ ∧ Red.Step L₄ L₅\n  | _, _, _, _, Red.Step.not, Red.Step.not, H => Step.diamond_aux H\n\n"}
{"name":"FreeGroup.Red.Step.to_red","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\na✝ : FreeGroup.Red.Step L₁ L₂\n⊢ FreeGroup.Red L₁ L₂","decl":"@[to_additive]\ntheorem Step.to_red : Step L₁ L₂ → Red L₁ L₂ :=\n  ReflTransGen.single\n\n"}
{"name":"FreeAddGroup.Red.Step.to_red","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\na✝ : FreeAddGroup.Red.Step L₁ L₂\n⊢ FreeAddGroup.Red L₁ L₂","decl":"@[to_additive]\ntheorem Step.to_red : Step L₁ L₂ → Red L₁ L₂ :=\n  ReflTransGen.single\n\n"}
{"name":"FreeAddGroup.Red.church_rosser","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ : List (Prod α Bool)\na✝¹ : FreeAddGroup.Red L₁ L₂\na✝ : FreeAddGroup.Red L₁ L₃\n⊢ Relation.Join FreeAddGroup.Red L₂ L₃","decl":"/-- **Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces\nto `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4`\nrespectively. This is also known as Newman's diamond lemma. -/\n@[to_additive\n  \"**Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces\n  to `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4`\n  respectively. This is also known as Newman's diamond lemma.\"]\ntheorem church_rosser : Red L₁ L₂ → Red L₁ L₃ → Join Red L₂ L₃ :=\n  Relation.church_rosser fun _ b c hab hac =>\n    match b, c, Red.Step.diamond hab hac rfl with\n    | b, _, Or.inl rfl => ⟨b, by rfl, by rfl⟩\n    | _, _, Or.inr ⟨d, hbd, hcd⟩ => ⟨d, ReflGen.single hbd, hcd.to_red⟩\n\n"}
{"name":"FreeGroup.Red.church_rosser","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ : List (Prod α Bool)\na✝¹ : FreeGroup.Red L₁ L₂\na✝ : FreeGroup.Red L₁ L₃\n⊢ Relation.Join FreeGroup.Red L₂ L₃","decl":"/-- **Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces\nto `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4`\nrespectively. This is also known as Newman's diamond lemma. -/\n@[to_additive\n  \"**Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces\n  to `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4`\n  respectively. This is also known as Newman's diamond lemma.\"]\ntheorem church_rosser : Red L₁ L₂ → Red L₁ L₃ → Join Red L₂ L₃ :=\n  Relation.church_rosser fun _ b c hab hac =>\n    match b, c, Red.Step.diamond hab hac rfl with\n    | b, _, Or.inl rfl => ⟨b, by rfl, by rfl⟩\n    | _, _, Or.inr ⟨d, hbd, hcd⟩ => ⟨d, ReflGen.single hbd, hcd.to_red⟩\n\n"}
{"name":"FreeGroup.Red.cons_cons","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\np : Prod α Bool\na✝ : FreeGroup.Red L₁ L₂\n⊢ FreeGroup.Red (List.cons p L₁) (List.cons p L₂)","decl":"@[to_additive]\ntheorem cons_cons {p} : Red L₁ L₂ → Red (p :: L₁) (p :: L₂) :=\n  ReflTransGen.lift (List.cons p) fun _ _ => Step.cons\n\n"}
{"name":"FreeAddGroup.Red.cons_cons","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\np : Prod α Bool\na✝ : FreeAddGroup.Red L₁ L₂\n⊢ FreeAddGroup.Red (List.cons p L₁) (List.cons p L₂)","decl":"@[to_additive]\ntheorem cons_cons {p} : Red L₁ L₂ → Red (p :: L₁) (p :: L₂) :=\n  ReflTransGen.lift (List.cons p) fun _ _ => Step.cons\n\n"}
{"name":"FreeGroup.Red.cons_cons_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\np : Prod α Bool\n⊢ Iff (FreeGroup.Red (List.cons p L₁) (List.cons p L₂)) (FreeGroup.Red L₁ L₂)","decl":"@[to_additive]\ntheorem cons_cons_iff (p) : Red (p :: L₁) (p :: L₂) ↔ Red L₁ L₂ :=\n  Iff.intro\n    (by\n      generalize eq₁ : (p :: L₁ : List _) = LL₁\n      generalize eq₂ : (p :: L₂ : List _) = LL₂\n      intro h\n      induction' h using Relation.ReflTransGen.head_induction_on\n        with L₁ L₂ h₁₂ h ih\n        generalizing L₁ L₂\n      · subst_vars\n        cases eq₂\n        constructor\n      · subst_vars\n        cases' p with a b\n        rw [Step.cons_left_iff] at h₁₂\n        rcases h₁₂ with (⟨L, h₁₂, rfl⟩ | rfl)\n        · exact (ih rfl rfl).head h₁₂\n        · exact (cons_cons h).tail Step.cons_not_rev)\n    cons_cons\n\n"}
{"name":"FreeAddGroup.Red.cons_cons_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\np : Prod α Bool\n⊢ Iff (FreeAddGroup.Red (List.cons p L₁) (List.cons p L₂)) (FreeAddGroup.Red L₁ L₂)","decl":"@[to_additive]\ntheorem cons_cons_iff (p) : Red (p :: L₁) (p :: L₂) ↔ Red L₁ L₂ :=\n  Iff.intro\n    (by\n      generalize eq₁ : (p :: L₁ : List _) = LL₁\n      generalize eq₂ : (p :: L₂ : List _) = LL₂\n      intro h\n      induction' h using Relation.ReflTransGen.head_induction_on\n        with L₁ L₂ h₁₂ h ih\n        generalizing L₁ L₂\n      · subst_vars\n        cases eq₂\n        constructor\n      · subst_vars\n        cases' p with a b\n        rw [Step.cons_left_iff] at h₁₂\n        rcases h₁₂ with (⟨L, h₁₂, rfl⟩ | rfl)\n        · exact (ih rfl rfl).head h₁₂\n        · exact (cons_cons h).tail Step.cons_not_rev)\n    cons_cons\n\n"}
{"name":"FreeGroup.Red.append_append_left_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L : List (Prod α Bool)\n⊢ Iff (FreeGroup.Red (HAppend.hAppend L L₁) (HAppend.hAppend L L₂)) (FreeGroup.Red L₁ L₂)","decl":"@[to_additive]\ntheorem append_append_left_iff : ∀ L, Red (L ++ L₁) (L ++ L₂) ↔ Red L₁ L₂\n  | [] => Iff.rfl\n  | p :: L => by simp [append_append_left_iff L, cons_cons_iff]\n\n"}
{"name":"FreeAddGroup.Red.append_append_left_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L : List (Prod α Bool)\n⊢ Iff (FreeAddGroup.Red (HAppend.hAppend L L₁) (HAppend.hAppend L L₂)) (FreeAddGroup.Red L₁ L₂)","decl":"@[to_additive]\ntheorem append_append_left_iff : ∀ L, Red (L ++ L₁) (L ++ L₂) ↔ Red L₁ L₂\n  | [] => Iff.rfl\n  | p :: L => by simp [append_append_left_iff L, cons_cons_iff]\n\n"}
{"name":"FreeGroup.Red.append_append","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ L₄ : List (Prod α Bool)\nh₁ : FreeGroup.Red L₁ L₃\nh₂ : FreeGroup.Red L₂ L₄\n⊢ FreeGroup.Red (HAppend.hAppend L₁ L₂) (HAppend.hAppend L₃ L₄)","decl":"@[to_additive]\ntheorem append_append (h₁ : Red L₁ L₃) (h₂ : Red L₂ L₄) : Red (L₁ ++ L₂) (L₃ ++ L₄) :=\n  (h₁.lift (fun L => L ++ L₂) fun _ _ => Step.append_right).trans ((append_append_left_iff _).2 h₂)\n\n"}
{"name":"FreeAddGroup.Red.append_append","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ L₃ L₄ : List (Prod α Bool)\nh₁ : FreeAddGroup.Red L₁ L₃\nh₂ : FreeAddGroup.Red L₂ L₄\n⊢ FreeAddGroup.Red (HAppend.hAppend L₁ L₂) (HAppend.hAppend L₃ L₄)","decl":"@[to_additive]\ntheorem append_append (h₁ : Red L₁ L₃) (h₂ : Red L₂ L₄) : Red (L₁ ++ L₂) (L₃ ++ L₄) :=\n  (h₁.lift (fun L => L ++ L₂) fun _ _ => Step.append_right).trans ((append_append_left_iff _).2 h₂)\n\n"}
{"name":"FreeAddGroup.Red.to_append_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL L₁ L₂ : List (Prod α Bool)\n⊢ Iff (FreeAddGroup.Red L (HAppend.hAppend L₁ L₂)) (Exists fun L₃ => Exists fun L₄ => And (Eq L (HAppend.hAppend L₃ L₄)) (And (FreeAddGroup.Red L₃ L₁) (FreeAddGroup.Red L₄ L₂)))","decl":"@[to_additive]\ntheorem to_append_iff : Red L (L₁ ++ L₂) ↔ ∃ L₃ L₄, L = L₃ ++ L₄ ∧ Red L₃ L₁ ∧ Red L₄ L₂ :=\n  Iff.intro\n    (by\n      generalize eq : L₁ ++ L₂ = L₁₂\n      intro h\n      induction' h with L' L₁₂ hLL' h ih generalizing L₁ L₂\n      · exact ⟨_, _, eq.symm, by rfl, by rfl⟩\n      · cases' h with s e a b\n        rcases List.append_eq_append_iff.1 eq with (⟨s', rfl, rfl⟩ | ⟨e', rfl, rfl⟩)\n        · have : L₁ ++ (s' ++ (a, b) :: (a, not b) :: e) = L₁ ++ s' ++ (a, b) :: (a, not b) :: e :=\n            by simp\n          rcases ih this with ⟨w₁, w₂, rfl, h₁, h₂⟩\n          exact ⟨w₁, w₂, rfl, h₁, h₂.tail Step.not⟩\n        · have : s ++ (a, b) :: (a, not b) :: e' ++ L₂ = s ++ (a, b) :: (a, not b) :: (e' ++ L₂) :=\n            by simp\n          rcases ih this with ⟨w₁, w₂, rfl, h₁, h₂⟩\n          exact ⟨w₁, w₂, rfl, h₁.tail Step.not, h₂⟩)\n    fun ⟨_, _, Eq, h₃, h₄⟩ => Eq.symm ▸ append_append h₃ h₄\n\n"}
{"name":"FreeGroup.Red.to_append_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL L₁ L₂ : List (Prod α Bool)\n⊢ Iff (FreeGroup.Red L (HAppend.hAppend L₁ L₂)) (Exists fun L₃ => Exists fun L₄ => And (Eq L (HAppend.hAppend L₃ L₄)) (And (FreeGroup.Red L₃ L₁) (FreeGroup.Red L₄ L₂)))","decl":"@[to_additive]\ntheorem to_append_iff : Red L (L₁ ++ L₂) ↔ ∃ L₃ L₄, L = L₃ ++ L₄ ∧ Red L₃ L₁ ∧ Red L₄ L₂ :=\n  Iff.intro\n    (by\n      generalize eq : L₁ ++ L₂ = L₁₂\n      intro h\n      induction' h with L' L₁₂ hLL' h ih generalizing L₁ L₂\n      · exact ⟨_, _, eq.symm, by rfl, by rfl⟩\n      · cases' h with s e a b\n        rcases List.append_eq_append_iff.1 eq with (⟨s', rfl, rfl⟩ | ⟨e', rfl, rfl⟩)\n        · have : L₁ ++ (s' ++ (a, b) :: (a, not b) :: e) = L₁ ++ s' ++ (a, b) :: (a, not b) :: e :=\n            by simp\n          rcases ih this with ⟨w₁, w₂, rfl, h₁, h₂⟩\n          exact ⟨w₁, w₂, rfl, h₁, h₂.tail Step.not⟩\n        · have : s ++ (a, b) :: (a, not b) :: e' ++ L₂ = s ++ (a, b) :: (a, not b) :: (e' ++ L₂) :=\n            by simp\n          rcases ih this with ⟨w₁, w₂, rfl, h₁, h₂⟩\n          exact ⟨w₁, w₂, rfl, h₁.tail Step.not, h₂⟩)\n    fun ⟨_, _, Eq, h₃, h₄⟩ => Eq.symm ▸ append_append h₃ h₄\n\n"}
{"name":"FreeGroup.Red.nil_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\n⊢ Iff (FreeGroup.Red List.nil L) (Eq L List.nil)","decl":"/-- The empty word `[]` only reduces to itself. -/\n@[to_additive \"The empty word `[]` only reduces to itself.\"]\ntheorem nil_iff : Red [] L ↔ L = [] :=\n  reflTransGen_iff_eq fun _ => Red.not_step_nil\n\n"}
{"name":"FreeAddGroup.Red.nil_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\n⊢ Iff (FreeAddGroup.Red List.nil L) (Eq L List.nil)","decl":"/-- The empty word `[]` only reduces to itself. -/\n@[to_additive \"The empty word `[]` only reduces to itself.\"]\ntheorem nil_iff : Red [] L ↔ L = [] :=\n  reflTransGen_iff_eq fun _ => Red.not_step_nil\n\n"}
{"name":"FreeAddGroup.Red.singleton_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ : List (Prod α Bool)\nx : Prod α Bool\n⊢ Iff (FreeAddGroup.Red (List.cons x List.nil) L₁) (Eq L₁ (List.cons x List.nil))","decl":"/-- A letter only reduces to itself. -/\n@[to_additive \"A letter only reduces to itself.\"]\ntheorem singleton_iff {x} : Red [x] L₁ ↔ L₁ = [x] :=\n  reflTransGen_iff_eq fun _ => not_step_singleton\n\n"}
{"name":"FreeGroup.Red.singleton_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ : List (Prod α Bool)\nx : Prod α Bool\n⊢ Iff (FreeGroup.Red (List.cons x List.nil) L₁) (Eq L₁ (List.cons x List.nil))","decl":"/-- A letter only reduces to itself. -/\n@[to_additive \"A letter only reduces to itself.\"]\ntheorem singleton_iff {x} : Red [x] L₁ ↔ L₁ = [x] :=\n  reflTransGen_iff_eq fun _ => not_step_singleton\n\n"}
{"name":"FreeAddGroup.Red.cons_nil_iff_singleton","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nx : α\nb : Bool\n⊢ Iff (FreeAddGroup.Red (List.cons { fst := x, snd := b } L) List.nil) (FreeAddGroup.Red L (List.cons { fst := x, snd := b.not } List.nil))","decl":"/-- If `x` is a letter and `w` is a word such that `xw` reduces to the empty word, then `w` reduces\nto `x⁻¹` -/\n@[to_additive\n  \"If `x` is a letter and `w` is a word such that `x + w` reduces to the empty word, then `w`\n  reduces to `-x`.\"]\ntheorem cons_nil_iff_singleton {x b} : Red ((x, b) :: L) [] ↔ Red L [(x, not b)] :=\n  Iff.intro\n    (fun h => by\n      have h₁ : Red ((x, not b) :: (x, b) :: L) [(x, not b)] := cons_cons h\n      have h₂ : Red ((x, not b) :: (x, b) :: L) L := ReflTransGen.single Step.cons_not_rev\n      let ⟨L', h₁, h₂⟩ := church_rosser h₁ h₂\n      rw [singleton_iff] at h₁\n      subst L'\n      assumption)\n    fun h => (cons_cons h).tail Step.cons_not\n\n"}
{"name":"FreeGroup.Red.cons_nil_iff_singleton","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nx : α\nb : Bool\n⊢ Iff (FreeGroup.Red (List.cons { fst := x, snd := b } L) List.nil) (FreeGroup.Red L (List.cons { fst := x, snd := b.not } List.nil))","decl":"/-- If `x` is a letter and `w` is a word such that `xw` reduces to the empty word, then `w` reduces\nto `x⁻¹` -/\n@[to_additive\n  \"If `x` is a letter and `w` is a word such that `x + w` reduces to the empty word, then `w`\n  reduces to `-x`.\"]\ntheorem cons_nil_iff_singleton {x b} : Red ((x, b) :: L) [] ↔ Red L [(x, not b)] :=\n  Iff.intro\n    (fun h => by\n      have h₁ : Red ((x, not b) :: (x, b) :: L) [(x, not b)] := cons_cons h\n      have h₂ : Red ((x, not b) :: (x, b) :: L) L := ReflTransGen.single Step.cons_not_rev\n      let ⟨L', h₁, h₂⟩ := church_rosser h₁ h₂\n      rw [singleton_iff] at h₁\n      subst L'\n      assumption)\n    fun h => (cons_cons h).tail Step.cons_not\n\n"}
{"name":"FreeAddGroup.Red.red_iff_irreducible","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nx1 : α\nb1 : Bool\nx2 : α\nb2 : Bool\nh : Ne { fst := x1, snd := b1 } { fst := x2, snd := b2 }\n⊢ Iff (FreeAddGroup.Red (List.cons { fst := x1, snd := b1.not } (List.cons { fst := x2, snd := b2 } List.nil)) L) (Eq L (List.cons { fst := x1, snd := b1.not } (List.cons { fst := x2, snd := b2 } List.nil)))","decl":"@[to_additive]\ntheorem red_iff_irreducible {x1 b1 x2 b2} (h : (x1, b1) ≠ (x2, b2)) :\n    Red [(x1, !b1), (x2, b2)] L ↔ L = [(x1, !b1), (x2, b2)] := by\n  apply reflTransGen_iff_eq\n  generalize eq : [(x1, not b1), (x2, b2)] = L'\n  intro L h'\n  cases h'\n  simp only [List.cons_eq_append_iff, List.cons.injEq, Prod.mk.injEq, and_false,\n    List.nil_eq_append_iff, exists_const, or_self, or_false, List.cons_ne_nil] at eq\n  rcases eq with ⟨rfl, ⟨rfl, rfl⟩, ⟨rfl, rfl⟩, rfl⟩\n  simp at h\n\n"}
{"name":"FreeGroup.Red.red_iff_irreducible","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nx1 : α\nb1 : Bool\nx2 : α\nb2 : Bool\nh : Ne { fst := x1, snd := b1 } { fst := x2, snd := b2 }\n⊢ Iff (FreeGroup.Red (List.cons { fst := x1, snd := b1.not } (List.cons { fst := x2, snd := b2 } List.nil)) L) (Eq L (List.cons { fst := x1, snd := b1.not } (List.cons { fst := x2, snd := b2 } List.nil)))","decl":"@[to_additive]\ntheorem red_iff_irreducible {x1 b1 x2 b2} (h : (x1, b1) ≠ (x2, b2)) :\n    Red [(x1, !b1), (x2, b2)] L ↔ L = [(x1, !b1), (x2, b2)] := by\n  apply reflTransGen_iff_eq\n  generalize eq : [(x1, not b1), (x2, b2)] = L'\n  intro L h'\n  cases h'\n  simp only [List.cons_eq_append_iff, List.cons.injEq, Prod.mk.injEq, and_false,\n    List.nil_eq_append_iff, exists_const, or_self, or_false, List.cons_ne_nil] at eq\n  rcases eq with ⟨rfl, ⟨rfl, rfl⟩, ⟨rfl, rfl⟩, rfl⟩\n  simp at h\n\n"}
{"name":"FreeAddGroup.Red.neg_of_red_of_ne","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nx1 : α\nb1 : Bool\nx2 : α\nb2 : Bool\nH1 : Ne { fst := x1, snd := b1 } { fst := x2, snd := b2 }\nH2 : FreeAddGroup.Red (List.cons { fst := x1, snd := b1 } L₁) (List.cons { fst := x2, snd := b2 } L₂)\n⊢ FreeAddGroup.Red L₁ (List.cons { fst := x1, snd := b1.not } (List.cons { fst := x2, snd := b2 } L₂))","decl":"/-- If `x` and `y` are distinct letters and `w₁ w₂` are words such that `xw₁` reduces to `yw₂`, then\n`w₁` reduces to `x⁻¹yw₂`. -/\n@[to_additive \"If `x` and `y` are distinct letters and `w₁ w₂` are words such that `x + w₁` reduces\n  to `y + w₂`, then `w₁` reduces to `-x + y + w₂`.\"]\ntheorem inv_of_red_of_ne {x1 b1 x2 b2} (H1 : (x1, b1) ≠ (x2, b2))\n    (H2 : Red ((x1, b1) :: L₁) ((x2, b2) :: L₂)) : Red L₁ ((x1, not b1) :: (x2, b2) :: L₂) := by\n  have : Red ((x1, b1) :: L₁) ([(x2, b2)] ++ L₂) := H2\n  rcases to_append_iff.1 this with ⟨_ | ⟨p, L₃⟩, L₄, eq, h₁, h₂⟩\n  · simp [nil_iff] at h₁\n  · cases eq\n    show Red (L₃ ++ L₄) ([(x1, not b1), (x2, b2)] ++ L₂)\n    apply append_append _ h₂\n    have h₁ : Red ((x1, not b1) :: (x1, b1) :: L₃) [(x1, not b1), (x2, b2)] := cons_cons h₁\n    have h₂ : Red ((x1, not b1) :: (x1, b1) :: L₃) L₃ := Step.cons_not_rev.to_red\n    rcases church_rosser h₁ h₂ with ⟨L', h₁, h₂⟩\n    rw [red_iff_irreducible H1] at h₁\n    rwa [h₁] at h₂\n\n"}
{"name":"FreeGroup.Red.inv_of_red_of_ne","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nx1 : α\nb1 : Bool\nx2 : α\nb2 : Bool\nH1 : Ne { fst := x1, snd := b1 } { fst := x2, snd := b2 }\nH2 : FreeGroup.Red (List.cons { fst := x1, snd := b1 } L₁) (List.cons { fst := x2, snd := b2 } L₂)\n⊢ FreeGroup.Red L₁ (List.cons { fst := x1, snd := b1.not } (List.cons { fst := x2, snd := b2 } L₂))","decl":"/-- If `x` and `y` are distinct letters and `w₁ w₂` are words such that `xw₁` reduces to `yw₂`, then\n`w₁` reduces to `x⁻¹yw₂`. -/\n@[to_additive \"If `x` and `y` are distinct letters and `w₁ w₂` are words such that `x + w₁` reduces\n  to `y + w₂`, then `w₁` reduces to `-x + y + w₂`.\"]\ntheorem inv_of_red_of_ne {x1 b1 x2 b2} (H1 : (x1, b1) ≠ (x2, b2))\n    (H2 : Red ((x1, b1) :: L₁) ((x2, b2) :: L₂)) : Red L₁ ((x1, not b1) :: (x2, b2) :: L₂) := by\n  have : Red ((x1, b1) :: L₁) ([(x2, b2)] ++ L₂) := H2\n  rcases to_append_iff.1 this with ⟨_ | ⟨p, L₃⟩, L₄, eq, h₁, h₂⟩\n  · simp [nil_iff] at h₁\n  · cases eq\n    show Red (L₃ ++ L₄) ([(x1, not b1), (x2, b2)] ++ L₂)\n    apply append_append _ h₂\n    have h₁ : Red ((x1, not b1) :: (x1, b1) :: L₃) [(x1, not b1), (x2, b2)] := cons_cons h₁\n    have h₂ : Red ((x1, not b1) :: (x1, b1) :: L₃) L₃ := Step.cons_not_rev.to_red\n    rcases church_rosser h₁ h₂ with ⟨L', h₁, h₂⟩\n    rw [red_iff_irreducible H1] at h₁\n    rwa [h₁] at h₂\n\n"}
{"name":"FreeAddGroup.Red.Step.sublist","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nH : FreeAddGroup.Red.Step L₁ L₂\n⊢ L₂.Sublist L₁","decl":"@[to_additive]\ntheorem Step.sublist (H : Red.Step L₁ L₂) : L₂ <+ L₁ := by\n  cases H; simp\n\n"}
{"name":"FreeGroup.Red.Step.sublist","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nH : FreeGroup.Red.Step L₁ L₂\n⊢ L₂.Sublist L₁","decl":"@[to_additive]\ntheorem Step.sublist (H : Red.Step L₁ L₂) : L₂ <+ L₁ := by\n  cases H; simp\n\n"}
{"name":"FreeAddGroup.Red.sublist","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\na✝ : FreeAddGroup.Red L₁ L₂\n⊢ L₂.Sublist L₁","decl":"/-- If `w₁ w₂` are words such that `w₁` reduces to `w₂`, then `w₂` is a sublist of `w₁`. -/\n@[to_additive \"If `w₁ w₂` are words such that `w₁` reduces to `w₂`, then `w₂` is a sublist of\n  `w₁`.\"]\nprotected theorem sublist : Red L₁ L₂ → L₂ <+ L₁ :=\n  @reflTransGen_of_transitive_reflexive\n    _ (fun a b => b <+ a) _ _ _\n    (fun l => List.Sublist.refl l)\n    (fun _a _b _c hab hbc => List.Sublist.trans hbc hab)\n    (fun _ _ => Red.Step.sublist)\n\n"}
{"name":"FreeGroup.Red.sublist","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\na✝ : FreeGroup.Red L₁ L₂\n⊢ L₂.Sublist L₁","decl":"/-- If `w₁ w₂` are words such that `w₁` reduces to `w₂`, then `w₂` is a sublist of `w₁`. -/\n@[to_additive \"If `w₁ w₂` are words such that `w₁` reduces to `w₂`, then `w₂` is a sublist of\n  `w₁`.\"]\nprotected theorem sublist : Red L₁ L₂ → L₂ <+ L₁ :=\n  @reflTransGen_of_transitive_reflexive\n    _ (fun a b => b <+ a) _ _ _\n    (fun l => List.Sublist.refl l)\n    (fun _a _b _c hab hbc => List.Sublist.trans hbc hab)\n    (fun _ _ => Red.Step.sublist)\n\n"}
{"name":"FreeGroup.Red.length_le","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nh : FreeGroup.Red L₁ L₂\n⊢ LE.le L₂.length L₁.length","decl":"@[to_additive]\ntheorem length_le (h : Red L₁ L₂) : L₂.length ≤ L₁.length :=\n  h.sublist.length_le\n\n\n"}
{"name":"FreeAddGroup.Red.length_le","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nh : FreeAddGroup.Red L₁ L₂\n⊢ LE.le L₂.length L₁.length","decl":"@[to_additive]\ntheorem length_le (h : Red L₁ L₂) : L₂.length ≤ L₁.length :=\n  h.sublist.length_le\n\n\n"}
{"name":"FreeGroup.Red.sizeof_of_step","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\na✝ : FreeGroup.Red.Step L₁ L₂\n⊢ LT.lt (SizeOf.sizeOf L₂) (SizeOf.sizeOf L₁)","decl":"@[to_additive]\ntheorem sizeof_of_step : ∀ {L₁ L₂ : List (α × Bool)},\n    Step L₁ L₂ → sizeOf L₂ < sizeOf L₁\n  | _, _, @Step.not _ L1 L2 x b => by\n    induction L1 with\n    | nil =>\n      dsimp\n      omega\n    | cons hd tl ih =>\n      dsimp\n      exact Nat.add_lt_add_left ih _\n\n"}
{"name":"FreeAddGroup.Red.sizeof_of_step","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\na✝ : FreeAddGroup.Red.Step L₁ L₂\n⊢ LT.lt (SizeOf.sizeOf L₂) (SizeOf.sizeOf L₁)","decl":"@[to_additive]\ntheorem sizeof_of_step : ∀ {L₁ L₂ : List (α × Bool)},\n    Step L₁ L₂ → sizeOf L₂ < sizeOf L₁\n  | _, _, @Step.not _ L1 L2 x b => by\n    induction L1 with\n    | nil =>\n      dsimp\n      omega\n    | cons hd tl ih =>\n      dsimp\n      exact Nat.add_lt_add_left ih _\n\n"}
{"name":"FreeAddGroup.Red.length","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nh : FreeAddGroup.Red L₁ L₂\n⊢ Exists fun n => Eq L₁.length (HAdd.hAdd L₂.length (HMul.hMul 2 n))","decl":"@[to_additive]\ntheorem length (h : Red L₁ L₂) : ∃ n, L₁.length = L₂.length + 2 * n := by\n  induction' h with L₂ L₃ _h₁₂ h₂₃ ih\n  · exact ⟨0, rfl⟩\n  · rcases ih with ⟨n, eq⟩\n    exists 1 + n\n    simp [Nat.mul_add, eq, (Step.length h₂₃).symm, add_assoc]\n\n"}
{"name":"FreeGroup.Red.length","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nh : FreeGroup.Red L₁ L₂\n⊢ Exists fun n => Eq L₁.length (HAdd.hAdd L₂.length (HMul.hMul 2 n))","decl":"@[to_additive]\ntheorem length (h : Red L₁ L₂) : ∃ n, L₁.length = L₂.length + 2 * n := by\n  induction' h with L₂ L₃ _h₁₂ h₂₃ ih\n  · exact ⟨0, rfl⟩\n  · rcases ih with ⟨n, eq⟩\n    exists 1 + n\n    simp [Nat.mul_add, eq, (Step.length h₂₃).symm, add_assoc]\n\n"}
{"name":"FreeAddGroup.Red.antisymm","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nh₁₂ : FreeAddGroup.Red L₁ L₂\nh₂₁ : FreeAddGroup.Red L₂ L₁\n⊢ Eq L₁ L₂","decl":"@[to_additive]\ntheorem antisymm (h₁₂ : Red L₁ L₂) (h₂₁ : Red L₂ L₁) : L₁ = L₂ :=\n  h₂₁.sublist.antisymm h₁₂.sublist\n\n"}
{"name":"FreeGroup.Red.antisymm","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nh₁₂ : FreeGroup.Red L₁ L₂\nh₂₁ : FreeGroup.Red L₂ L₁\n⊢ Eq L₁ L₂","decl":"@[to_additive]\ntheorem antisymm (h₁₂ : Red L₁ L₂) (h₂₁ : Red L₂ L₁) : L₁ = L₂ :=\n  h₂₁.sublist.antisymm h₁₂.sublist\n\n"}
{"name":"FreeGroup.equivalence_join_red","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Equivalence (Relation.Join FreeGroup.Red)","decl":"@[to_additive FreeAddGroup.equivalence_join_red]\ntheorem equivalence_join_red : Equivalence (Join (@Red α)) :=\n  equivalence_join_reflTransGen fun _ b c hab hac =>\n    match b, c, Red.Step.diamond hab hac rfl with\n    | b, _, Or.inl rfl => ⟨b, by rfl, by rfl⟩\n    | _, _, Or.inr ⟨d, hbd, hcd⟩ => ⟨d, ReflGen.single hbd, ReflTransGen.single hcd⟩\n\n"}
{"name":"FreeAddGroup.equivalence_join_red","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Equivalence (Relation.Join FreeAddGroup.Red)","decl":"@[to_additive FreeAddGroup.equivalence_join_red]\ntheorem equivalence_join_red : Equivalence (Join (@Red α)) :=\n  equivalence_join_reflTransGen fun _ b c hab hac =>\n    match b, c, Red.Step.diamond hab hac rfl with\n    | b, _, Or.inl rfl => ⟨b, by rfl, by rfl⟩\n    | _, _, Or.inr ⟨d, hbd, hcd⟩ => ⟨d, ReflGen.single hbd, ReflTransGen.single hcd⟩\n\n"}
{"name":"FreeGroup.join_red_of_step","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nh : FreeGroup.Red.Step L₁ L₂\n⊢ Relation.Join FreeGroup.Red L₁ L₂","decl":"@[to_additive FreeAddGroup.join_red_of_step]\ntheorem join_red_of_step (h : Red.Step L₁ L₂) : Join Red L₁ L₂ :=\n  join_of_single reflexive_reflTransGen h.to_red\n\n"}
{"name":"FreeAddGroup.join_red_of_step","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nh : FreeAddGroup.Red.Step L₁ L₂\n⊢ Relation.Join FreeAddGroup.Red L₁ L₂","decl":"@[to_additive FreeAddGroup.join_red_of_step]\ntheorem join_red_of_step (h : Red.Step L₁ L₂) : Join Red L₁ L₂ :=\n  join_of_single reflexive_reflTransGen h.to_red\n\n"}
{"name":"FreeAddGroup.eqvGen_step_iff_join_red","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\n⊢ Iff (Relation.EqvGen FreeAddGroup.Red.Step L₁ L₂) (Relation.Join FreeAddGroup.Red L₁ L₂)","decl":"@[to_additive FreeAddGroup.eqvGen_step_iff_join_red]\ntheorem eqvGen_step_iff_join_red : EqvGen Red.Step L₁ L₂ ↔ Join Red L₁ L₂ :=\n  Iff.intro\n    (fun h =>\n      have : EqvGen (Join Red) L₁ L₂ := h.mono fun _ _ => join_red_of_step\n      equivalence_join_red.eqvGen_iff.1 this)\n    (join_of_equivalence (Relation.EqvGen.is_equivalence _) fun _ _ =>\n      reflTransGen_of_equivalence (Relation.EqvGen.is_equivalence _) EqvGen.rel)\n\n"}
{"name":"FreeGroup.eqvGen_step_iff_join_red","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\n⊢ Iff (Relation.EqvGen FreeGroup.Red.Step L₁ L₂) (Relation.Join FreeGroup.Red L₁ L₂)","decl":"@[to_additive FreeAddGroup.eqvGen_step_iff_join_red]\ntheorem eqvGen_step_iff_join_red : EqvGen Red.Step L₁ L₂ ↔ Join Red L₁ L₂ :=\n  Iff.intro\n    (fun h =>\n      have : EqvGen (Join Red) L₁ L₂ := h.mono fun _ _ => join_red_of_step\n      equivalence_join_red.eqvGen_iff.1 this)\n    (join_of_equivalence (Relation.EqvGen.is_equivalence _) fun _ _ =>\n      reflTransGen_of_equivalence (Relation.EqvGen.is_equivalence _) EqvGen.rel)\n\n"}
{"name":"FreeGroup.quot_mk_eq_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\n⊢ Eq (Quot.mk FreeGroup.Red.Step L) (FreeGroup.mk L)","decl":"@[to_additive (attr := simp)]\ntheorem quot_mk_eq_mk : Quot.mk Red.Step L = mk L :=\n  rfl\n\n"}
{"name":"FreeAddGroup.quot_mk_eq_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\n⊢ Eq (Quot.mk FreeAddGroup.Red.Step L) (FreeAddGroup.mk L)","decl":"@[to_additive (attr := simp)]\ntheorem quot_mk_eq_mk : Quot.mk Red.Step L = mk L :=\n  rfl\n\n"}
{"name":"FreeAddGroup.quot_lift_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nβ : Type v\nf : List (Prod α Bool) → β\nH : ∀ (L₁ L₂ : List (Prod α Bool)), FreeAddGroup.Red.Step L₁ L₂ → Eq (f L₁) (f L₂)\n⊢ Eq (Quot.lift f H (FreeAddGroup.mk L)) (f L)","decl":"@[to_additive (attr := simp)]\ntheorem quot_lift_mk (β : Type v) (f : List (α × Bool) → β)\n    (H : ∀ L₁ L₂, Red.Step L₁ L₂ → f L₁ = f L₂) : Quot.lift f H (mk L) = f L :=\n  rfl\n\n"}
{"name":"FreeGroup.quot_lift_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nβ : Type v\nf : List (Prod α Bool) → β\nH : ∀ (L₁ L₂ : List (Prod α Bool)), FreeGroup.Red.Step L₁ L₂ → Eq (f L₁) (f L₂)\n⊢ Eq (Quot.lift f H (FreeGroup.mk L)) (f L)","decl":"@[to_additive (attr := simp)]\ntheorem quot_lift_mk (β : Type v) (f : List (α × Bool) → β)\n    (H : ∀ L₁ L₂, Red.Step L₁ L₂ → f L₁ = f L₂) : Quot.lift f H (mk L) = f L :=\n  rfl\n\n"}
{"name":"FreeGroup.quot_liftOn_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nβ : Type v\nf : List (Prod α Bool) → β\nH : ∀ (L₁ L₂ : List (Prod α Bool)), FreeGroup.Red.Step L₁ L₂ → Eq (f L₁) (f L₂)\n⊢ Eq (Quot.liftOn (FreeGroup.mk L) f H) (f L)","decl":"@[to_additive (attr := simp)]\ntheorem quot_liftOn_mk (β : Type v) (f : List (α × Bool) → β)\n    (H : ∀ L₁ L₂, Red.Step L₁ L₂ → f L₁ = f L₂) : Quot.liftOn (mk L) f H = f L :=\n  rfl\n\n"}
{"name":"FreeAddGroup.quot_liftOn_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nβ : Type v\nf : List (Prod α Bool) → β\nH : ∀ (L₁ L₂ : List (Prod α Bool)), FreeAddGroup.Red.Step L₁ L₂ → Eq (f L₁) (f L₂)\n⊢ Eq (Quot.liftOn (FreeAddGroup.mk L) f H) (f L)","decl":"@[to_additive (attr := simp)]\ntheorem quot_liftOn_mk (β : Type v) (f : List (α × Bool) → β)\n    (H : ∀ L₁ L₂, Red.Step L₁ L₂ → f L₁ = f L₂) : Quot.liftOn (mk L) f H = f L :=\n  rfl\n\n"}
{"name":"FreeAddGroup.quot_map_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nβ : Type v\nf : List (Prod α Bool) → List (Prod β Bool)\nH : Relator.LiftFun FreeAddGroup.Red.Step FreeAddGroup.Red.Step f f\n⊢ Eq (Quot.map f H (FreeAddGroup.mk L)) (FreeAddGroup.mk (f L))","decl":"@[to_additive (attr := simp)]\ntheorem quot_map_mk (β : Type v) (f : List (α × Bool) → List (β × Bool))\n    (H : (Red.Step ⇒ Red.Step) f f) : Quot.map f H (mk L) = mk (f L) :=\n  rfl\n\n"}
{"name":"FreeGroup.quot_map_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nβ : Type v\nf : List (Prod α Bool) → List (Prod β Bool)\nH : Relator.LiftFun FreeGroup.Red.Step FreeGroup.Red.Step f f\n⊢ Eq (Quot.map f H (FreeGroup.mk L)) (FreeGroup.mk (f L))","decl":"@[to_additive (attr := simp)]\ntheorem quot_map_mk (β : Type v) (f : List (α × Bool) → List (β × Bool))\n    (H : (Red.Step ⇒ Red.Step) f f) : Quot.map f H (mk L) = mk (f L) :=\n  rfl\n\n"}
{"name":"FreeAddGroup.zero_eq_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Eq 0 (FreeAddGroup.mk List.nil)","decl":"@[to_additive]\ntheorem one_eq_mk : (1 : FreeGroup α) = mk [] :=\n  rfl\n\n"}
{"name":"FreeGroup.one_eq_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Eq 1 (FreeGroup.mk List.nil)","decl":"@[to_additive]\ntheorem one_eq_mk : (1 : FreeGroup α) = mk [] :=\n  rfl\n\n"}
{"name":"FreeGroup.mul_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\n⊢ Eq (HMul.hMul (FreeGroup.mk L₁) (FreeGroup.mk L₂)) (FreeGroup.mk (HAppend.hAppend L₁ L₂))","decl":"@[to_additive (attr := simp)]\ntheorem mul_mk : mk L₁ * mk L₂ = mk (L₁ ++ L₂) :=\n  rfl\n\n"}
{"name":"FreeAddGroup.add_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\n⊢ Eq (HAdd.hAdd (FreeAddGroup.mk L₁) (FreeAddGroup.mk L₂)) (FreeAddGroup.mk (HAppend.hAppend L₁ L₂))","decl":"@[to_additive (attr := simp)]\ntheorem mul_mk : mk L₁ * mk L₂ = mk (L₁ ++ L₂) :=\n  rfl\n\n"}
{"name":"FreeGroup.invRev_length","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ : List (Prod α Bool)\n⊢ Eq (FreeGroup.invRev L₁).length L₁.length","decl":"@[to_additive (attr := simp)]\ntheorem invRev_length : (invRev L₁).length = L₁.length := by simp [invRev]\n\n"}
{"name":"FreeAddGroup.negRev_length","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ : List (Prod α Bool)\n⊢ Eq (FreeAddGroup.negRev L₁).length L₁.length","decl":"@[to_additive (attr := simp)]\ntheorem invRev_length : (invRev L₁).length = L₁.length := by simp [invRev]\n\n"}
{"name":"FreeGroup.invRev_invRev","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ : List (Prod α Bool)\n⊢ Eq (FreeGroup.invRev (FreeGroup.invRev L₁)) L₁","decl":"@[to_additive (attr := simp)]\ntheorem invRev_invRev : invRev (invRev L₁) = L₁ := by\n  simp [invRev, List.map_reverse, Function.comp_def]\n\n"}
{"name":"FreeAddGroup.negRev_negRev","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ : List (Prod α Bool)\n⊢ Eq (FreeAddGroup.negRev (FreeAddGroup.negRev L₁)) L₁","decl":"@[to_additive (attr := simp)]\ntheorem invRev_invRev : invRev (invRev L₁) = L₁ := by\n  simp [invRev, List.map_reverse, Function.comp_def]\n\n"}
{"name":"FreeAddGroup.negRev_empty","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Eq (FreeAddGroup.negRev List.nil) List.nil","decl":"@[to_additive (attr := simp)]\ntheorem invRev_empty : invRev ([] : List (α × Bool)) = [] :=\n  rfl\n\n"}
{"name":"FreeGroup.invRev_empty","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Eq (FreeGroup.invRev List.nil) List.nil","decl":"@[to_additive (attr := simp)]\ntheorem invRev_empty : invRev ([] : List (α × Bool)) = [] :=\n  rfl\n\n"}
{"name":"FreeGroup.invRev_involutive","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Function.Involutive FreeGroup.invRev","decl":"@[to_additive]\ntheorem invRev_involutive : Function.Involutive (@invRev α) := fun _ => invRev_invRev\n\n"}
{"name":"FreeAddGroup.negRev_involutive","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Function.Involutive FreeAddGroup.negRev","decl":"@[to_additive]\ntheorem invRev_involutive : Function.Involutive (@invRev α) := fun _ => invRev_invRev\n\n"}
{"name":"FreeAddGroup.negRev_injective","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Function.Injective FreeAddGroup.negRev","decl":"@[to_additive]\ntheorem invRev_injective : Function.Injective (@invRev α) :=\n  invRev_involutive.injective\n\n"}
{"name":"FreeGroup.invRev_injective","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Function.Injective FreeGroup.invRev","decl":"@[to_additive]\ntheorem invRev_injective : Function.Injective (@invRev α) :=\n  invRev_involutive.injective\n\n"}
{"name":"FreeAddGroup.negRev_surjective","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Function.Surjective FreeAddGroup.negRev","decl":"@[to_additive]\ntheorem invRev_surjective : Function.Surjective (@invRev α) :=\n  invRev_involutive.surjective\n\n"}
{"name":"FreeGroup.invRev_surjective","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Function.Surjective FreeGroup.invRev","decl":"@[to_additive]\ntheorem invRev_surjective : Function.Surjective (@invRev α) :=\n  invRev_involutive.surjective\n\n"}
{"name":"FreeAddGroup.negRev_bijective","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Function.Bijective FreeAddGroup.negRev","decl":"@[to_additive]\ntheorem invRev_bijective : Function.Bijective (@invRev α) :=\n  invRev_involutive.bijective\n\n"}
{"name":"FreeGroup.invRev_bijective","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Function.Bijective FreeGroup.invRev","decl":"@[to_additive]\ntheorem invRev_bijective : Function.Bijective (@invRev α) :=\n  invRev_involutive.bijective\n\n"}
{"name":"FreeGroup.inv_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\n⊢ Eq (Inv.inv (FreeGroup.mk L)) (FreeGroup.mk (FreeGroup.invRev L))","decl":"@[to_additive (attr := simp)]\ntheorem inv_mk : (mk L)⁻¹ = mk (invRev L) :=\n  rfl\n\n"}
{"name":"FreeAddGroup.neg_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\n⊢ Eq (Neg.neg (FreeAddGroup.mk L)) (FreeAddGroup.mk (FreeAddGroup.negRev L))","decl":"@[to_additive (attr := simp)]\ntheorem inv_mk : (mk L)⁻¹ = mk (invRev L) :=\n  rfl\n\n"}
{"name":"FreeGroup.Red.Step.invRev","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nh : FreeGroup.Red.Step L₁ L₂\n⊢ FreeGroup.Red.Step (FreeGroup.invRev L₁) (FreeGroup.invRev L₂)","decl":"@[to_additive]\ntheorem Red.Step.invRev {L₁ L₂ : List (α × Bool)} (h : Red.Step L₁ L₂) :\n    Red.Step (FreeGroup.invRev L₁) (FreeGroup.invRev L₂) := by\n  cases' h with a b x y\n  simp [FreeGroup.invRev]\n\n"}
{"name":"FreeAddGroup.Red.Step.negRev","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nh : FreeAddGroup.Red.Step L₁ L₂\n⊢ FreeAddGroup.Red.Step (FreeAddGroup.negRev L₁) (FreeAddGroup.negRev L₂)","decl":"@[to_additive]\ntheorem Red.Step.invRev {L₁ L₂ : List (α × Bool)} (h : Red.Step L₁ L₂) :\n    Red.Step (FreeGroup.invRev L₁) (FreeGroup.invRev L₂) := by\n  cases' h with a b x y\n  simp [FreeGroup.invRev]\n\n"}
{"name":"FreeGroup.Red.invRev","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nh : FreeGroup.Red L₁ L₂\n⊢ FreeGroup.Red (FreeGroup.invRev L₁) (FreeGroup.invRev L₂)","decl":"@[to_additive]\ntheorem Red.invRev {L₁ L₂ : List (α × Bool)} (h : Red L₁ L₂) : Red (invRev L₁) (invRev L₂) :=\n  Relation.ReflTransGen.lift _ (fun _a _b => Red.Step.invRev) h\n\n"}
{"name":"FreeAddGroup.Red.negRev","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nh : FreeAddGroup.Red L₁ L₂\n⊢ FreeAddGroup.Red (FreeAddGroup.negRev L₁) (FreeAddGroup.negRev L₂)","decl":"@[to_additive]\ntheorem Red.invRev {L₁ L₂ : List (α × Bool)} (h : Red L₁ L₂) : Red (invRev L₁) (invRev L₂) :=\n  Relation.ReflTransGen.lift _ (fun _a _b => Red.Step.invRev) h\n\n"}
{"name":"FreeAddGroup.Red.step_negRev_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\n⊢ Iff (FreeAddGroup.Red.Step (FreeAddGroup.negRev L₁) (FreeAddGroup.negRev L₂)) (FreeAddGroup.Red.Step L₁ L₂)","decl":"@[to_additive (attr := simp)]\ntheorem Red.step_invRev_iff :\n    Red.Step (FreeGroup.invRev L₁) (FreeGroup.invRev L₂) ↔ Red.Step L₁ L₂ :=\n  ⟨fun h => by simpa only [invRev_invRev] using h.invRev, fun h => h.invRev⟩\n\n"}
{"name":"FreeGroup.Red.step_invRev_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\n⊢ Iff (FreeGroup.Red.Step (FreeGroup.invRev L₁) (FreeGroup.invRev L₂)) (FreeGroup.Red.Step L₁ L₂)","decl":"@[to_additive (attr := simp)]\ntheorem Red.step_invRev_iff :\n    Red.Step (FreeGroup.invRev L₁) (FreeGroup.invRev L₂) ↔ Red.Step L₁ L₂ :=\n  ⟨fun h => by simpa only [invRev_invRev] using h.invRev, fun h => h.invRev⟩\n\n"}
{"name":"FreeGroup.red_invRev_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\n⊢ Iff (FreeGroup.Red (FreeGroup.invRev L₁) (FreeGroup.invRev L₂)) (FreeGroup.Red L₁ L₂)","decl":"@[to_additive (attr := simp)]\ntheorem red_invRev_iff : Red (invRev L₁) (invRev L₂) ↔ Red L₁ L₂ :=\n  ⟨fun h => by simpa only [invRev_invRev] using h.invRev, fun h => h.invRev⟩\n\n"}
{"name":"FreeAddGroup.red_negRev_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\n⊢ Iff (FreeAddGroup.Red (FreeAddGroup.negRev L₁) (FreeAddGroup.negRev L₂)) (FreeAddGroup.Red L₁ L₂)","decl":"@[to_additive (attr := simp)]\ntheorem red_invRev_iff : Red (invRev L₁) (invRev L₂) ↔ Red L₁ L₂ :=\n  ⟨fun h => by simpa only [invRev_invRev] using h.invRev, fun h => h.invRev⟩\n\n"}
{"name":"FreeAddGroup.nsmul_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nn : Nat\n⊢ Eq (HSMul.hSMul n (FreeAddGroup.mk L)) (FreeAddGroup.mk (List.replicate n L).flatten)","decl":"@[to_additive (attr := simp)]\ntheorem pow_mk (n : ℕ) : mk L ^ n = mk (List.flatten <| List.replicate n L) :=\n  match n with\n  | 0 => rfl\n  | n + 1 => by rw [pow_succ', pow_mk, mul_mk, List.replicate_succ, List.flatten_cons]\n\n"}
{"name":"FreeGroup.pow_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nn : Nat\n⊢ Eq (HPow.hPow (FreeGroup.mk L) n) (FreeGroup.mk (List.replicate n L).flatten)","decl":"@[to_additive (attr := simp)]\ntheorem pow_mk (n : ℕ) : mk L ^ n = mk (List.flatten <| List.replicate n L) :=\n  match n with\n  | 0 => rfl\n  | n + 1 => by rw [pow_succ', pow_mk, mul_mk, List.replicate_succ, List.flatten_cons]\n\n"}
{"name":"FreeGroup.Red.exact","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\n⊢ Iff (Eq (FreeGroup.mk L₁) (FreeGroup.mk L₂)) (Relation.Join FreeGroup.Red L₁ L₂)","decl":"@[to_additive]\ntheorem Red.exact : mk L₁ = mk L₂ ↔ Join Red L₁ L₂ :=\n  calc\n    mk L₁ = mk L₂ ↔ EqvGen Red.Step L₁ L₂ := Iff.intro Quot.eqvGen_exact Quot.eqvGen_sound\n    _ ↔ Join Red L₁ L₂ := eqvGen_step_iff_join_red\n\n"}
{"name":"FreeAddGroup.Red.exact","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\n⊢ Iff (Eq (FreeAddGroup.mk L₁) (FreeAddGroup.mk L₂)) (Relation.Join FreeAddGroup.Red L₁ L₂)","decl":"@[to_additive]\ntheorem Red.exact : mk L₁ = mk L₂ ↔ Join Red L₁ L₂ :=\n  calc\n    mk L₁ = mk L₂ ↔ EqvGen Red.Step L₁ L₂ := Iff.intro Quot.eqvGen_exact Quot.eqvGen_sound\n    _ ↔ Join Red L₁ L₂ := eqvGen_step_iff_join_red\n\n"}
{"name":"FreeGroup.of_injective","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Function.Injective FreeGroup.of","decl":"/-- The canonical map from the type to the free group is an injection. -/\n@[to_additive \"The canonical map from the type to the additive free group is an injection.\"]\ntheorem of_injective : Function.Injective (@of α) := fun _ _ H => by\n  let ⟨L₁, hx, hy⟩ := Red.exact.1 H\n  simp [Red.singleton_iff] at hx hy; aesop\n\n"}
{"name":"FreeAddGroup.of_injective","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Function.Injective FreeAddGroup.of","decl":"/-- The canonical map from the type to the free group is an injection. -/\n@[to_additive \"The canonical map from the type to the additive free group is an injection.\"]\ntheorem of_injective : Function.Injective (@of α) := fun _ _ H => by\n  let ⟨L₁, hx, hy⟩ := Red.exact.1 H\n  simp [Red.singleton_iff] at hx hy; aesop\n\n"}
{"name":"FreeGroup.Red.Step.lift","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nβ : Type v\ninst✝ : Group β\nf : α → β\nH : FreeGroup.Red.Step L₁ L₂\n⊢ Eq (FreeGroup.Lift.aux f L₁) (FreeGroup.Lift.aux f L₂)","decl":"@[to_additive]\ntheorem Red.Step.lift {f : α → β} (H : Red.Step L₁ L₂) : Lift.aux f L₁ = Lift.aux f L₂ := by\n  cases' H with _ _ _ b; cases b <;> simp [Lift.aux]\n\n"}
{"name":"FreeAddGroup.Red.Step.lift","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL₁ L₂ : List (Prod α Bool)\nβ : Type v\ninst✝ : AddGroup β\nf : α → β\nH : FreeAddGroup.Red.Step L₁ L₂\n⊢ Eq (FreeAddGroup.Lift.aux f L₁) (FreeAddGroup.Lift.aux f L₂)","decl":"@[to_additive]\ntheorem Red.Step.lift {f : α → β} (H : Red.Step L₁ L₂) : Lift.aux f L₁ = Lift.aux f L₂ := by\n  cases' H with _ _ _ b; cases b <;> simp [Lift.aux]\n\n"}
{"name":"FreeGroup.lift_symm_apply","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Group β\ng : MonoidHom (FreeGroup α) β\na✝ : α\n⊢ Eq (FreeGroup.lift.symm g a✝) (Function.comp (⇑g) FreeGroup.of a✝)","decl":"/-- If `β` is a group, then any function from `α` to `β` extends uniquely to a group homomorphism\nfrom the free group over `α` to `β` -/\n@[to_additive (attr := simps symm_apply)\n  \"If `β` is an additive group, then any function from `α` to `β` extends uniquely to an\n  additive group homomorphism from the free additive group over `α` to `β`\"]\ndef lift : (α → β) ≃ (FreeGroup α →* β) where\n  toFun f :=\n    MonoidHom.mk' (Quot.lift (Lift.aux f) fun _ _ => Red.Step.lift) <| by\n      rintro ⟨L₁⟩ ⟨L₂⟩; simp [Lift.aux]\n  invFun g := g ∘ of\n  left_inv f := List.prod_singleton\n  right_inv g :=\n    MonoidHom.ext <| by\n      rintro ⟨L⟩\n      exact List.recOn L\n        (g.map_one.symm)\n        (by\n        rintro ⟨x, _ | _⟩ t (ih : _ = g (mk t))\n        · show _ = g ((of x)⁻¹ * mk t)\n          simpa [Lift.aux] using ih\n        · show _ = g (of x * mk t)\n          simpa [Lift.aux] using ih)\n\n"}
{"name":"FreeAddGroup.lift_symm_apply","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddGroup β\ng : AddMonoidHom (FreeAddGroup α) β\na✝ : α\n⊢ Eq (FreeAddGroup.lift.symm g a✝) (Function.comp (⇑g) FreeAddGroup.of a✝)","decl":"/-- If `β` is a group, then any function from `α` to `β` extends uniquely to a group homomorphism\nfrom the free group over `α` to `β` -/\n@[to_additive (attr := simps symm_apply)\n  \"If `β` is an additive group, then any function from `α` to `β` extends uniquely to an\n  additive group homomorphism from the free additive group over `α` to `β`\"]\ndef lift : (α → β) ≃ (FreeGroup α →* β) where\n  toFun f :=\n    MonoidHom.mk' (Quot.lift (Lift.aux f) fun _ _ => Red.Step.lift) <| by\n      rintro ⟨L₁⟩ ⟨L₂⟩; simp [Lift.aux]\n  invFun g := g ∘ of\n  left_inv f := List.prod_singleton\n  right_inv g :=\n    MonoidHom.ext <| by\n      rintro ⟨L⟩\n      exact List.recOn L\n        (g.map_one.symm)\n        (by\n        rintro ⟨x, _ | _⟩ t (ih : _ = g (mk t))\n        · show _ = g ((of x)⁻¹ * mk t)\n          simpa [Lift.aux] using ih\n        · show _ = g (of x * mk t)\n          simpa [Lift.aux] using ih)\n\n"}
{"name":"FreeAddGroup.lift.mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nβ : Type v\ninst✝ : AddGroup β\nf : α → β\n⊢ Eq ((FreeAddGroup.lift f) (FreeAddGroup.mk L)) (List.map (fun x => cond x.2 (f x.1) (Neg.neg (f x.1))) L).sum","decl":"@[to_additive (attr := simp)]\ntheorem lift.mk : lift f (mk L) = List.prod (L.map fun x => cond x.2 (f x.1) (f x.1)⁻¹) :=\n  rfl\n\n"}
{"name":"FreeGroup.lift.mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nβ : Type v\ninst✝ : Group β\nf : α → β\n⊢ Eq ((FreeGroup.lift f) (FreeGroup.mk L)) (List.map (fun x => cond x.2 (f x.1) (Inv.inv (f x.1))) L).prod","decl":"@[to_additive (attr := simp)]\ntheorem lift.mk : lift f (mk L) = List.prod (L.map fun x => cond x.2 (f x.1) (f x.1)⁻¹) :=\n  rfl\n\n"}
{"name":"FreeAddGroup.lift.of","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddGroup β\nf : α → β\nx : α\n⊢ Eq ((FreeAddGroup.lift f) (FreeAddGroup.of x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift.of {x} : lift f (of x) = f x :=\n  List.prod_singleton\n\n"}
{"name":"FreeGroup.lift.of","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Group β\nf : α → β\nx : α\n⊢ Eq ((FreeGroup.lift f) (FreeGroup.of x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift.of {x} : lift f (of x) = f x :=\n  List.prod_singleton\n\n"}
{"name":"FreeGroup.lift.unique","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Group β\nf : α → β\ng : MonoidHom (FreeGroup α) β\nhg : ∀ (x : α), Eq (g (FreeGroup.of x)) (f x)\nx : FreeGroup α\n⊢ Eq (g x) ((FreeGroup.lift f) x)","decl":"@[to_additive]\ntheorem lift.unique (g : FreeGroup α →* β) (hg : ∀ x, g (FreeGroup.of x) = f x) {x} :\n    g x = FreeGroup.lift f x :=\n  DFunLike.congr_fun (lift.symm_apply_eq.mp (funext hg : g ∘ FreeGroup.of = f)) x\n\n"}
{"name":"FreeAddGroup.lift.unique","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddGroup β\nf : α → β\ng : AddMonoidHom (FreeAddGroup α) β\nhg : ∀ (x : α), Eq (g (FreeAddGroup.of x)) (f x)\nx : FreeAddGroup α\n⊢ Eq (g x) ((FreeAddGroup.lift f) x)","decl":"@[to_additive]\ntheorem lift.unique (g : FreeGroup α →* β) (hg : ∀ x, g (FreeGroup.of x) = f x) {x} :\n    g x = FreeGroup.lift f x :=\n  DFunLike.congr_fun (lift.symm_apply_eq.mp (funext hg : g ∘ FreeGroup.of = f)) x\n\n"}
{"name":"FreeAddGroup.ext_hom","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nG : Type u_1\ninst✝ : AddGroup G\nf g : AddMonoidHom (FreeAddGroup α) G\nh : ∀ (a : α), Eq (f (FreeAddGroup.of a)) (g (FreeAddGroup.of a))\n⊢ Eq f g","decl":"/-- Two homomorphisms out of a free group are equal if they are equal on generators.\n\nSee note [partially-applied ext lemmas]. -/\n@[to_additive (attr := ext) \"Two homomorphisms out of a free additive group are equal if they are\n  equal on generators. See note [partially-applied ext lemmas].\"]\ntheorem ext_hom {G : Type*} [Group G] (f g : FreeGroup α →* G) (h : ∀ a, f (of a) = g (of a)) :\n    f = g :=\n  lift.symm.injective <| funext h\n\n"}
{"name":"FreeGroup.ext_hom_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nG : Type u_1\ninst✝ : Group G\nf g : MonoidHom (FreeGroup α) G\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f (FreeGroup.of a)) (g (FreeGroup.of a)))","decl":"/-- Two homomorphisms out of a free group are equal if they are equal on generators.\n\nSee note [partially-applied ext lemmas]. -/\n@[to_additive (attr := ext) \"Two homomorphisms out of a free additive group are equal if they are\n  equal on generators. See note [partially-applied ext lemmas].\"]\ntheorem ext_hom {G : Type*} [Group G] (f g : FreeGroup α →* G) (h : ∀ a, f (of a) = g (of a)) :\n    f = g :=\n  lift.symm.injective <| funext h\n\n"}
{"name":"FreeGroup.ext_hom","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nG : Type u_1\ninst✝ : Group G\nf g : MonoidHom (FreeGroup α) G\nh : ∀ (a : α), Eq (f (FreeGroup.of a)) (g (FreeGroup.of a))\n⊢ Eq f g","decl":"/-- Two homomorphisms out of a free group are equal if they are equal on generators.\n\nSee note [partially-applied ext lemmas]. -/\n@[to_additive (attr := ext) \"Two homomorphisms out of a free additive group are equal if they are\n  equal on generators. See note [partially-applied ext lemmas].\"]\ntheorem ext_hom {G : Type*} [Group G] (f g : FreeGroup α →* G) (h : ∀ a, f (of a) = g (of a)) :\n    f = g :=\n  lift.symm.injective <| funext h\n\n"}
{"name":"FreeAddGroup.ext_hom_iff","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nG : Type u_1\ninst✝ : AddGroup G\nf g : AddMonoidHom (FreeAddGroup α) G\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f (FreeAddGroup.of a)) (g (FreeAddGroup.of a)))","decl":"/-- Two homomorphisms out of a free group are equal if they are equal on generators.\n\nSee note [partially-applied ext lemmas]. -/\n@[to_additive (attr := ext) \"Two homomorphisms out of a free additive group are equal if they are\n  equal on generators. See note [partially-applied ext lemmas].\"]\ntheorem ext_hom {G : Type*} [Group G] (f g : FreeGroup α →* G) (h : ∀ a, f (of a) = g (of a)) :\n    f = g :=\n  lift.symm.injective <| funext h\n\n"}
{"name":"FreeAddGroup.lift_of_eq_id","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u_1\n⊢ Eq (FreeAddGroup.lift FreeAddGroup.of) (AddMonoidHom.id (FreeAddGroup α))","decl":"@[to_additive]\ntheorem lift_of_eq_id (α) : lift of = MonoidHom.id (FreeGroup α) :=\n  lift.apply_symm_apply (MonoidHom.id _)\n\n"}
{"name":"FreeGroup.lift_of_eq_id","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u_1\n⊢ Eq (FreeGroup.lift FreeGroup.of) (MonoidHom.id (FreeGroup α))","decl":"@[to_additive]\ntheorem lift_of_eq_id (α) : lift of = MonoidHom.id (FreeGroup α) :=\n  lift.apply_symm_apply (MonoidHom.id _)\n\n"}
{"name":"FreeAddGroup.lift.of_eq","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nx : FreeAddGroup α\n⊢ Eq ((FreeAddGroup.lift FreeAddGroup.of) x) x","decl":"@[to_additive]\ntheorem lift.of_eq (x : FreeGroup α) : lift FreeGroup.of x = x :=\n  DFunLike.congr_fun (lift_of_eq_id α) x\n\n"}
{"name":"FreeGroup.lift.of_eq","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nx : FreeGroup α\n⊢ Eq ((FreeGroup.lift FreeGroup.of) x) x","decl":"@[to_additive]\ntheorem lift.of_eq (x : FreeGroup α) : lift FreeGroup.of x = x :=\n  DFunLike.congr_fun (lift_of_eq_id α) x\n\n"}
{"name":"FreeGroup.lift.range_le","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Group β\nf : α → β\ns : Subgroup β\nH : HasSubset.Subset (Set.range f) ↑s\n⊢ LE.le (FreeGroup.lift f).range s","decl":"@[to_additive]\ntheorem lift.range_le {s : Subgroup β} (H : Set.range f ⊆ s) : (lift f).range ≤ s := by\n  rintro _ ⟨⟨L⟩, rfl⟩;\n  exact List.recOn L s.one_mem fun ⟨x, b⟩ tl ih ↦\n    Bool.recOn b (by simpa using s.mul_mem (s.inv_mem <| H ⟨x, rfl⟩) ih)\n      (by simpa using s.mul_mem (H ⟨x, rfl⟩) ih)\n\n"}
{"name":"FreeAddGroup.lift.range_le","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddGroup β\nf : α → β\ns : AddSubgroup β\nH : HasSubset.Subset (Set.range f) ↑s\n⊢ LE.le (FreeAddGroup.lift f).range s","decl":"@[to_additive]\ntheorem lift.range_le {s : Subgroup β} (H : Set.range f ⊆ s) : (lift f).range ≤ s := by\n  rintro _ ⟨⟨L⟩, rfl⟩;\n  exact List.recOn L s.one_mem fun ⟨x, b⟩ tl ih ↦\n    Bool.recOn b (by simpa using s.mul_mem (s.inv_mem <| H ⟨x, rfl⟩) ih)\n      (by simpa using s.mul_mem (H ⟨x, rfl⟩) ih)\n\n"}
{"name":"FreeAddGroup.lift.range_eq_closure","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddGroup β\nf : α → β\n⊢ Eq (FreeAddGroup.lift f).range (AddSubgroup.closure (Set.range f))","decl":"@[to_additive]\ntheorem lift.range_eq_closure : (lift f).range = Subgroup.closure (Set.range f) := by\n  apply le_antisymm (lift.range_le Subgroup.subset_closure)\n  rw [Subgroup.closure_le]\n  rintro _ ⟨a, rfl⟩\n  exact ⟨FreeGroup.of a, by simp only [lift.of]⟩\n\n"}
{"name":"FreeGroup.lift.range_eq_closure","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Group β\nf : α → β\n⊢ Eq (FreeGroup.lift f).range (Subgroup.closure (Set.range f))","decl":"@[to_additive]\ntheorem lift.range_eq_closure : (lift f).range = Subgroup.closure (Set.range f) := by\n  apply le_antisymm (lift.range_le Subgroup.subset_closure)\n  rw [Subgroup.closure_le]\n  rintro _ ⟨a, rfl⟩\n  exact ⟨FreeGroup.of a, by simp only [lift.of]⟩\n\n"}
{"name":"FreeGroup.closure_range_of","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u_1\n⊢ Eq (Subgroup.closure (Set.range FreeGroup.of)) Top.top","decl":"/-- The generators of `FreeGroup α` generate `FreeGroup α`. That is, the subgroup closure of the\nset of generators equals `⊤`. -/\n@[to_additive (attr := simp)]\ntheorem closure_range_of (α) :\n    Subgroup.closure (Set.range (FreeGroup.of : α → FreeGroup α)) = ⊤ := by\n  rw [← lift.range_eq_closure, lift_of_eq_id]\n  exact MonoidHom.range_eq_top.2 Function.surjective_id\n\n"}
{"name":"FreeAddGroup.closure_range_of","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u_1\n⊢ Eq (AddSubgroup.closure (Set.range FreeAddGroup.of)) Top.top","decl":"/-- The generators of `FreeGroup α` generate `FreeGroup α`. That is, the subgroup closure of the\nset of generators equals `⊤`. -/\n@[to_additive (attr := simp)]\ntheorem closure_range_of (α) :\n    Subgroup.closure (Set.range (FreeGroup.of : α → FreeGroup α)) = ⊤ := by\n  rw [← lift.range_eq_closure, lift_of_eq_id]\n  exact MonoidHom.range_eq_top.2 Function.surjective_id\n\n"}
{"name":"FreeAddGroup.map.mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nβ : Type v\nf : α → β\n⊢ Eq ((FreeAddGroup.map f) (FreeAddGroup.mk L)) (FreeAddGroup.mk (List.map (fun x => { fst := f x.1, snd := x.2 }) L))","decl":"@[to_additive (attr := simp)]\ntheorem map.mk : map f (mk L) = mk (L.map fun x => (f x.1, x.2)) :=\n  rfl\n\n"}
{"name":"FreeGroup.map.mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\nβ : Type v\nf : α → β\n⊢ Eq ((FreeGroup.map f) (FreeGroup.mk L)) (FreeGroup.mk (List.map (fun x => { fst := f x.1, snd := x.2 }) L))","decl":"@[to_additive (attr := simp)]\ntheorem map.mk : map f (mk L) = mk (L.map fun x => (f x.1, x.2)) :=\n  rfl\n\n"}
{"name":"FreeAddGroup.map.id","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nx : FreeAddGroup α\n⊢ Eq ((FreeAddGroup.map id) x) x","decl":"@[to_additive (attr := simp)]\ntheorem map.id (x : FreeGroup α) : map id x = x := by rcases x with ⟨L⟩; simp [List.map_id']\n\n"}
{"name":"FreeGroup.map.id","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nx : FreeGroup α\n⊢ Eq ((FreeGroup.map id) x) x","decl":"@[to_additive (attr := simp)]\ntheorem map.id (x : FreeGroup α) : map id x = x := by rcases x with ⟨L⟩; simp [List.map_id']\n\n"}
{"name":"FreeGroup.map.id'","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nx : FreeGroup α\n⊢ Eq ((FreeGroup.map fun z => z) x) x","decl":"@[to_additive (attr := simp)]\ntheorem map.id' (x : FreeGroup α) : map (fun z => z) x = x :=\n  map.id x\n\n"}
{"name":"FreeAddGroup.map.id'","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nx : FreeAddGroup α\n⊢ Eq ((FreeAddGroup.map fun z => z) x) x","decl":"@[to_additive (attr := simp)]\ntheorem map.id' (x : FreeGroup α) : map (fun z => z) x = x :=\n  map.id x\n\n"}
{"name":"FreeAddGroup.map.comp","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → β\ng : β → γ\nx : FreeAddGroup α\n⊢ Eq ((FreeAddGroup.map g) ((FreeAddGroup.map f) x)) ((FreeAddGroup.map (Function.comp g f)) x)","decl":"@[to_additive]\ntheorem map.comp {γ : Type w} (f : α → β) (g : β → γ) (x) :\n    map g (map f x) = map (g ∘ f) x := by\n  rcases x with ⟨L⟩; simp [Function.comp_def]\n\n"}
{"name":"FreeGroup.map.comp","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → β\ng : β → γ\nx : FreeGroup α\n⊢ Eq ((FreeGroup.map g) ((FreeGroup.map f) x)) ((FreeGroup.map (Function.comp g f)) x)","decl":"@[to_additive]\ntheorem map.comp {γ : Type w} (f : α → β) (g : β → γ) (x) :\n    map g (map f x) = map (g ∘ f) x := by\n  rcases x with ⟨L⟩; simp [Function.comp_def]\n\n"}
{"name":"FreeAddGroup.map.of","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : α\n⊢ Eq ((FreeAddGroup.map f) (FreeAddGroup.of x)) (FreeAddGroup.of (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map.of {x} : map f (of x) = of (f x) :=\n  rfl\n\n"}
{"name":"FreeGroup.map.of","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : α\n⊢ Eq ((FreeGroup.map f) (FreeGroup.of x)) (FreeGroup.of (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map.of {x} : map f (of x) = of (f x) :=\n  rfl\n\n"}
{"name":"FreeAddGroup.map.unique","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : AddMonoidHom (FreeAddGroup α) (FreeAddGroup β)\nhg : ∀ (x : α), Eq (g (FreeAddGroup.of x)) (FreeAddGroup.of (f x))\nx : FreeAddGroup α\n⊢ Eq (g x) ((FreeAddGroup.map f) x)","decl":"@[to_additive]\ntheorem map.unique (g : FreeGroup α →* FreeGroup β)\n    (hg : ∀ x, g (FreeGroup.of x) = FreeGroup.of (f x)) :\n    ∀ {x}, g x = map f x := by\n  rintro ⟨L⟩\n  exact List.recOn L g.map_one fun ⟨x, b⟩ t (ih : g (FreeGroup.mk t) = map f (FreeGroup.mk t)) =>\n    Bool.recOn b\n      (show g ((FreeGroup.of x)⁻¹ * FreeGroup.mk t) =\n          FreeGroup.map f ((FreeGroup.of x)⁻¹ * FreeGroup.mk t) by\n        simp [g.map_mul, g.map_inv, hg, ih])\n      (show g (FreeGroup.of x * FreeGroup.mk t) =\n          FreeGroup.map f (FreeGroup.of x * FreeGroup.mk t) by simp [g.map_mul, hg, ih])\n\n"}
{"name":"FreeGroup.map.unique","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : MonoidHom (FreeGroup α) (FreeGroup β)\nhg : ∀ (x : α), Eq (g (FreeGroup.of x)) (FreeGroup.of (f x))\nx : FreeGroup α\n⊢ Eq (g x) ((FreeGroup.map f) x)","decl":"@[to_additive]\ntheorem map.unique (g : FreeGroup α →* FreeGroup β)\n    (hg : ∀ x, g (FreeGroup.of x) = FreeGroup.of (f x)) :\n    ∀ {x}, g x = map f x := by\n  rintro ⟨L⟩\n  exact List.recOn L g.map_one fun ⟨x, b⟩ t (ih : g (FreeGroup.mk t) = map f (FreeGroup.mk t)) =>\n    Bool.recOn b\n      (show g ((FreeGroup.of x)⁻¹ * FreeGroup.mk t) =\n          FreeGroup.map f ((FreeGroup.of x)⁻¹ * FreeGroup.mk t) by\n        simp [g.map_mul, g.map_inv, hg, ih])\n      (show g (FreeGroup.of x * FreeGroup.mk t) =\n          FreeGroup.map f (FreeGroup.of x * FreeGroup.mk t) by simp [g.map_mul, hg, ih])\n\n"}
{"name":"FreeGroup.map_eq_lift","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : FreeGroup α\n⊢ Eq ((FreeGroup.map f) x) ((FreeGroup.lift (Function.comp FreeGroup.of f)) x)","decl":"@[to_additive]\ntheorem map_eq_lift : map f x = lift (of ∘ f) x :=\n  Eq.symm <| map.unique _ fun x => by simp\n\n"}
{"name":"FreeAddGroup.map_eq_lift","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nx : FreeAddGroup α\n⊢ Eq ((FreeAddGroup.map f) x) ((FreeAddGroup.lift (Function.comp FreeAddGroup.of f)) x)","decl":"@[to_additive]\ntheorem map_eq_lift : map f x = lift (of ∘ f) x :=\n  Eq.symm <| map.unique _ fun x => by simp\n\n"}
{"name":"FreeGroup.freeGroupCongr_apply","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\na : FreeGroup α\n⊢ Eq ((FreeGroup.freeGroupCongr e) a) ((FreeGroup.map ⇑e) a)","decl":"/-- Equivalent types give rise to multiplicatively equivalent free groups.\n\nThe converse can be found in `GroupTheory.FreeAbelianGroupFinsupp`,\nas `Equiv.of_freeGroupEquiv`\n -/\n@[to_additive (attr := simps apply)\n  \"Equivalent types give rise to additively equivalent additive free groups.\"]\ndef freeGroupCongr {α β} (e : α ≃ β) : FreeGroup α ≃* FreeGroup β where\n  toFun := map e\n  invFun := map e.symm\n  left_inv x := by simp [Function.comp, map.comp]\n  right_inv x := by simp [Function.comp, map.comp]\n  map_mul' := MonoidHom.map_mul _\n\n"}
{"name":"FreeAddGroup.freeAddGroupCongr_apply","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\na : FreeAddGroup α\n⊢ Eq ((FreeAddGroup.freeAddGroupCongr e) a) ((FreeAddGroup.map ⇑e) a)","decl":"/-- Equivalent types give rise to multiplicatively equivalent free groups.\n\nThe converse can be found in `GroupTheory.FreeAbelianGroupFinsupp`,\nas `Equiv.of_freeGroupEquiv`\n -/\n@[to_additive (attr := simps apply)\n  \"Equivalent types give rise to additively equivalent additive free groups.\"]\ndef freeGroupCongr {α β} (e : α ≃ β) : FreeGroup α ≃* FreeGroup β where\n  toFun := map e\n  invFun := map e.symm\n  left_inv x := by simp [Function.comp, map.comp]\n  right_inv x := by simp [Function.comp, map.comp]\n  map_mul' := MonoidHom.map_mul _\n\n"}
{"name":"FreeGroup.freeGroupCongr_refl","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Eq (FreeGroup.freeGroupCongr (Equiv.refl α)) (MulEquiv.refl (FreeGroup α))","decl":"@[to_additive (attr := simp)]\ntheorem freeGroupCongr_refl : freeGroupCongr (Equiv.refl α) = MulEquiv.refl _ :=\n  MulEquiv.ext map.id\n\n"}
{"name":"FreeAddGroup.freeAddGroupCongr_refl","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\n⊢ Eq (FreeAddGroup.freeAddGroupCongr (Equiv.refl α)) (AddEquiv.refl (FreeAddGroup α))","decl":"@[to_additive (attr := simp)]\ntheorem freeGroupCongr_refl : freeGroupCongr (Equiv.refl α) = MulEquiv.refl _ :=\n  MulEquiv.ext map.id\n\n"}
{"name":"FreeGroup.freeGroupCongr_symm","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Eq (FreeGroup.freeGroupCongr e).symm (FreeGroup.freeGroupCongr e.symm)","decl":"@[to_additive (attr := simp)]\ntheorem freeGroupCongr_symm {α β} (e : α ≃ β) : (freeGroupCongr e).symm = freeGroupCongr e.symm :=\n  rfl\n\n"}
{"name":"FreeAddGroup.freeAddGroupCongr_symm","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Eq (FreeAddGroup.freeAddGroupCongr e).symm (FreeAddGroup.freeAddGroupCongr e.symm)","decl":"@[to_additive (attr := simp)]\ntheorem freeGroupCongr_symm {α β} (e : α ≃ β) : (freeGroupCongr e).symm = freeGroupCongr e.symm :=\n  rfl\n\n"}
{"name":"FreeGroup.freeGroupCongr_trans","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : Equiv α β\nf : Equiv β γ\n⊢ Eq ((FreeGroup.freeGroupCongr e).trans (FreeGroup.freeGroupCongr f)) (FreeGroup.freeGroupCongr (e.trans f))","decl":"@[to_additive]\ntheorem freeGroupCongr_trans {α β γ} (e : α ≃ β) (f : β ≃ γ) :\n    (freeGroupCongr e).trans (freeGroupCongr f) = freeGroupCongr (e.trans f) :=\n  MulEquiv.ext <| map.comp _ _\n\n"}
{"name":"FreeAddGroup.freeAddGroupCongr_trans","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : Equiv α β\nf : Equiv β γ\n⊢ Eq ((FreeAddGroup.freeAddGroupCongr e).trans (FreeAddGroup.freeAddGroupCongr f)) (FreeAddGroup.freeAddGroupCongr (e.trans f))","decl":"@[to_additive]\ntheorem freeGroupCongr_trans {α β γ} (e : α ≃ β) (f : β ≃ γ) :\n    (freeGroupCongr e).trans (freeGroupCongr f) = freeGroupCongr (e.trans f) :=\n  MulEquiv.ext <| map.comp _ _\n\n"}
{"name":"FreeGroup.prod_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\ninst✝ : Group α\n⊢ Eq (FreeGroup.prod (FreeGroup.mk L)) (List.map (fun x => cond x.2 x.1 (Inv.inv x.1)) L).prod","decl":"@[to_additive (attr := simp)]\ntheorem prod_mk : prod (mk L) = List.prod (L.map fun x => cond x.2 x.1 x.1⁻¹) :=\n  rfl\n\n"}
{"name":"FreeAddGroup.sum_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\ninst✝ : AddGroup α\n⊢ Eq (FreeAddGroup.sum (FreeAddGroup.mk L)) (List.map (fun x => cond x.2 x.1 (Neg.neg x.1)) L).sum","decl":"@[to_additive (attr := simp)]\ntheorem prod_mk : prod (mk L) = List.prod (L.map fun x => cond x.2 x.1 x.1⁻¹) :=\n  rfl\n\n"}
{"name":"FreeGroup.prod.of","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\ninst✝ : Group α\nx : α\n⊢ Eq (FreeGroup.prod (FreeGroup.of x)) x","decl":"@[to_additive (attr := simp)]\ntheorem prod.of {x : α} : prod (of x) = x :=\n  lift.of\n\n"}
{"name":"FreeAddGroup.sum.of","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\nx : α\n⊢ Eq (FreeAddGroup.sum (FreeAddGroup.of x)) x","decl":"@[to_additive (attr := simp)]\ntheorem prod.of {x : α} : prod (of x) = x :=\n  lift.of\n\n"}
{"name":"FreeGroup.prod.unique","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\ninst✝ : Group α\ng : MonoidHom (FreeGroup α) α\nhg : ∀ (x : α), Eq (g (FreeGroup.of x)) x\nx : FreeGroup α\n⊢ Eq (g x) (FreeGroup.prod x)","decl":"@[to_additive]\ntheorem prod.unique (g : FreeGroup α →* α) (hg : ∀ x, g (FreeGroup.of x) = x) {x} : g x = prod x :=\n  lift.unique g hg\n\n"}
{"name":"FreeAddGroup.sum.unique","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\ng : AddMonoidHom (FreeAddGroup α) α\nhg : ∀ (x : α), Eq (g (FreeAddGroup.of x)) x\nx : FreeAddGroup α\n⊢ Eq (g x) (FreeAddGroup.sum x)","decl":"@[to_additive]\ntheorem prod.unique (g : FreeGroup α →* α) (hg : ∀ x, g (FreeGroup.of x) = x) {x} : g x = prod x :=\n  lift.unique g hg\n\n"}
{"name":"FreeAddGroup.lift_eq_sum_map","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : AddGroup β\nf : α → β\nx : FreeAddGroup α\n⊢ Eq ((FreeAddGroup.lift f) x) (FreeAddGroup.sum ((FreeAddGroup.map f) x))","decl":"@[to_additive]\ntheorem lift_eq_prod_map {β : Type v} [Group β] {f : α → β} {x} : lift f x = prod (map f x) := by\n  rw [← lift.unique (prod.comp (map f))]\n  · rfl\n  · simp\n\n"}
{"name":"FreeGroup.lift_eq_prod_map","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Group β\nf : α → β\nx : FreeGroup α\n⊢ Eq ((FreeGroup.lift f) x) (FreeGroup.prod ((FreeGroup.map f) x))","decl":"@[to_additive]\ntheorem lift_eq_prod_map {β : Type v} [Group β] {f : α → β} {x} : lift f x = prod (map f x) := by\n  rw [← lift.unique (prod.comp (map f))]\n  · rfl\n  · simp\n\n"}
{"name":"FreeGroup.sum_mk","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nL : List (Prod α Bool)\ninst✝ : AddGroup α\n⊢ Eq (FreeGroup.mk L).sum (List.map (fun x => cond x.2 x.1 (Neg.neg x.1)) L).sum","decl":"@[simp]\ntheorem sum_mk : sum (mk L) = List.sum (L.map fun x => cond x.2 x.1 (-x.1)) :=\n  rfl\n\n"}
{"name":"FreeGroup.sum.of","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\nx : α\n⊢ Eq (FreeGroup.of x).sum x","decl":"@[simp]\ntheorem sum.of {x : α} : sum (of x) = x :=\n  @prod.of _ (_) _\n\n-- note: there are no bundled homs with different notation in the domain and codomain, so we copy\n-- these manually\n"}
{"name":"FreeGroup.sum.map_mul","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\nx y : FreeGroup α\n⊢ Eq (HMul.hMul x y).sum (HAdd.hAdd x.sum y.sum)","decl":"@[simp]\ntheorem sum.map_mul : sum (x * y) = sum x + sum y :=\n  (@prod (Multiplicative _) _).map_mul _ _\n\n"}
{"name":"FreeGroup.sum.map_one","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\n⊢ Eq (FreeGroup.sum 1) 0","decl":"@[simp]\ntheorem sum.map_one : sum (1 : FreeGroup α) = 0 :=\n  (@prod (Multiplicative _) _).map_one\n\n"}
{"name":"FreeGroup.sum.map_inv","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\nx : FreeGroup α\n⊢ Eq (Inv.inv x).sum (Neg.neg x.sum)","decl":"@[simp]\ntheorem sum.map_inv : sum x⁻¹ = -sum x :=\n  (prod : FreeGroup (Multiplicative α) →* Multiplicative α).map_inv _\n\n"}
{"name":"FreeGroup.induction_on","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nC : FreeGroup α → Prop\nz : FreeGroup α\nC1 : C 1\nCp : ∀ (x : α), C (Pure.pure x)\nCi : ∀ (x : α), C (Pure.pure x) → C (Inv.inv (Pure.pure x))\nCm : ∀ (x y : FreeGroup α), C x → C y → C (HMul.hMul x y)\n⊢ C z","decl":"@[to_additive (attr := elab_as_elim, induction_eliminator)]\nprotected theorem induction_on {C : FreeGroup α → Prop} (z : FreeGroup α) (C1 : C 1)\n    (Cp : ∀ x, C <| pure x) (Ci : ∀ x, C (pure x) → C (pure x)⁻¹)\n    (Cm : ∀ x y, C x → C y → C (x * y)) : C z :=\n  Quot.inductionOn z fun L =>\n    List.recOn L C1 fun ⟨x, b⟩ _tl ih => Bool.recOn b (Cm _ _ (Ci _ <| Cp x) ih) (Cm _ _ (Cp x) ih)\n\n"}
{"name":"FreeAddGroup.induction_on","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α : Type u\nC : FreeAddGroup α → Prop\nz : FreeAddGroup α\nC1 : C 0\nCp : ∀ (x : α), C (Pure.pure x)\nCi : ∀ (x : α), C (Pure.pure x) → C (Neg.neg (Pure.pure x))\nCm : ∀ (x y : FreeAddGroup α), C x → C y → C (HAdd.hAdd x y)\n⊢ C z","decl":"@[to_additive (attr := elab_as_elim, induction_eliminator)]\nprotected theorem induction_on {C : FreeGroup α → Prop} (z : FreeGroup α) (C1 : C 1)\n    (Cp : ∀ x, C <| pure x) (Ci : ∀ x, C (pure x) → C (pure x)⁻¹)\n    (Cm : ∀ x y, C x → C y → C (x * y)) : C z :=\n  Quot.inductionOn z fun L =>\n    List.recOn L C1 fun ⟨x, b⟩ _tl ih => Bool.recOn b (Cm _ _ (Ci _ <| Cp x) ih) (Cm _ _ (Cp x) ih)\n\n"}
{"name":"FreeAddGroup.map_pure","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → β\nx : α\n⊢ Eq (Functor.map f (Pure.pure x)) (Pure.pure (f x))","decl":"@[to_additive]\ntheorem map_pure (f : α → β) (x : α) : f <$> (pure x : FreeGroup α) = pure (f x) :=\n  map.of\n\n"}
{"name":"FreeGroup.map_pure","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → β\nx : α\n⊢ Eq (Functor.map f (Pure.pure x)) (Pure.pure (f x))","decl":"@[to_additive]\ntheorem map_pure (f : α → β) (x : α) : f <$> (pure x : FreeGroup α) = pure (f x) :=\n  map.of\n\n"}
{"name":"FreeGroup.map_one","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → β\n⊢ Eq (Functor.map f 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem map_one (f : α → β) : f <$> (1 : FreeGroup α) = 1 :=\n  (map f).map_one\n\n"}
{"name":"FreeAddGroup.map_zero","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → β\n⊢ Eq (Functor.map f 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem map_one (f : α → β) : f <$> (1 : FreeGroup α) = 1 :=\n  (map f).map_one\n\n"}
{"name":"FreeGroup.map_mul","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → β\nx y : FreeGroup α\n⊢ Eq (Functor.map f (HMul.hMul x y)) (HMul.hMul (Functor.map f x) (Functor.map f y))","decl":"@[to_additive (attr := simp)]\ntheorem map_mul (f : α → β) (x y : FreeGroup α) : f <$> (x * y) = f <$> x * f <$> y :=\n  (map f).map_mul x y\n\n"}
{"name":"FreeAddGroup.map_add","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → β\nx y : FreeAddGroup α\n⊢ Eq (Functor.map f (HAdd.hAdd x y)) (HAdd.hAdd (Functor.map f x) (Functor.map f y))","decl":"@[to_additive (attr := simp)]\ntheorem map_mul (f : α → β) (x y : FreeGroup α) : f <$> (x * y) = f <$> x * f <$> y :=\n  (map f).map_mul x y\n\n"}
{"name":"FreeGroup.map_inv","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → β\nx : FreeGroup α\n⊢ Eq (Functor.map f (Inv.inv x)) (Inv.inv (Functor.map f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_inv (f : α → β) (x : FreeGroup α) : f <$> x⁻¹ = (f <$> x)⁻¹ :=\n  (map f).map_inv x\n\n"}
{"name":"FreeAddGroup.map_neg","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → β\nx : FreeAddGroup α\n⊢ Eq (Functor.map f (Neg.neg x)) (Neg.neg (Functor.map f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_inv (f : α → β) (x : FreeGroup α) : f <$> x⁻¹ = (f <$> x)⁻¹ :=\n  (map f).map_inv x\n\n"}
{"name":"FreeAddGroup.pure_bind","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → FreeAddGroup β\nx : α\n⊢ Eq (Bind.bind (Pure.pure x) f) (f x)","decl":"@[to_additive]\ntheorem pure_bind (f : α → FreeGroup β) (x) : pure x >>= f = f x :=\n  lift.of\n\n"}
{"name":"FreeGroup.pure_bind","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → FreeGroup β\nx : α\n⊢ Eq (Bind.bind (Pure.pure x) f) (f x)","decl":"@[to_additive]\ntheorem pure_bind (f : α → FreeGroup β) (x) : pure x >>= f = f x :=\n  lift.of\n\n"}
{"name":"FreeAddGroup.zero_bind","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → FreeAddGroup β\n⊢ Eq (Bind.bind 0 f) 0","decl":"@[to_additive (attr := simp)]\ntheorem one_bind (f : α → FreeGroup β) : 1 >>= f = 1 :=\n  (lift f).map_one\n\n"}
{"name":"FreeGroup.one_bind","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → FreeGroup β\n⊢ Eq (Bind.bind 1 f) 1","decl":"@[to_additive (attr := simp)]\ntheorem one_bind (f : α → FreeGroup β) : 1 >>= f = 1 :=\n  (lift f).map_one\n\n"}
{"name":"FreeGroup.mul_bind","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → FreeGroup β\nx y : FreeGroup α\n⊢ Eq (Bind.bind (HMul.hMul x y) f) (HMul.hMul (Bind.bind x f) (Bind.bind y f))","decl":"@[to_additive (attr := simp)]\ntheorem mul_bind (f : α → FreeGroup β) (x y : FreeGroup α) : x * y >>= f = (x >>= f) * (y >>= f) :=\n  (lift f).map_mul _ _\n\n"}
{"name":"FreeAddGroup.add_bind","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → FreeAddGroup β\nx y : FreeAddGroup α\n⊢ Eq (Bind.bind (HAdd.hAdd x y) f) (HAdd.hAdd (Bind.bind x f) (Bind.bind y f))","decl":"@[to_additive (attr := simp)]\ntheorem mul_bind (f : α → FreeGroup β) (x y : FreeGroup α) : x * y >>= f = (x >>= f) * (y >>= f) :=\n  (lift f).map_mul _ _\n\n"}
{"name":"FreeGroup.inv_bind","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → FreeGroup β\nx : FreeGroup α\n⊢ Eq (Bind.bind (Inv.inv x) f) (Inv.inv (Bind.bind x f))","decl":"@[to_additive (attr := simp)]\ntheorem inv_bind (f : α → FreeGroup β) (x : FreeGroup α) : x⁻¹ >>= f = (x >>= f)⁻¹ :=\n  (lift f).map_inv _\n\n"}
{"name":"FreeAddGroup.neg_bind","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"α β : Type u\nf : α → FreeAddGroup β\nx : FreeAddGroup α\n⊢ Eq (Bind.bind (Neg.neg x) f) (Neg.neg (Bind.bind x f))","decl":"@[to_additive (attr := simp)]\ntheorem inv_bind (f : α → FreeGroup β) (x : FreeGroup α) : x⁻¹ >>= f = (x >>= f)⁻¹ :=\n  (lift f).map_inv _\n\n"}
{"name":"FreeGroup.instLawfulMonad","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"⊢ LawfulMonad FreeGroup","decl":"@[to_additive]\ninstance : LawfulMonad FreeGroup.{u} := LawfulMonad.mk'\n  (id_map := fun x =>\n    FreeGroup.induction_on x (map_one id) (fun x => map_pure id x) (fun x ih => by rw [map_inv, ih])\n      fun x y ihx ihy => by rw [map_mul, ihx, ihy])\n  (pure_bind := fun x f => pure_bind f x)\n  (bind_assoc := fun x =>\n    FreeGroup.induction_on x\n      (by intros; iterate 3 rw [one_bind])\n      (fun x => by intros; iterate 2 rw [pure_bind])\n      (fun x ih => by intros; (iterate 3 rw [inv_bind]); rw [ih])\n      (fun x y ihx ihy => by intros; (iterate 3 rw [mul_bind]); rw [ihx, ihy]))\n  (bind_pure_comp := fun f x =>\n    FreeGroup.induction_on x (by rw [one_bind, map_one]) (fun x => by rw [pure_bind, map_pure])\n      (fun x ih => by rw [inv_bind, map_inv, ih]) fun x y ihx ihy => by\n      rw [mul_bind, map_mul, ihx, ihy])\n\n"}
{"name":"FreeAddGroup.instLawfulMonad","module":"Mathlib.GroupTheory.FreeGroup.Basic","initialProofState":"⊢ LawfulMonad FreeAddGroup","decl":"@[to_additive]\ninstance : LawfulMonad FreeGroup.{u} := LawfulMonad.mk'\n  (id_map := fun x =>\n    FreeGroup.induction_on x (map_one id) (fun x => map_pure id x) (fun x ih => by rw [map_inv, ih])\n      fun x y ihx ihy => by rw [map_mul, ihx, ihy])\n  (pure_bind := fun x f => pure_bind f x)\n  (bind_assoc := fun x =>\n    FreeGroup.induction_on x\n      (by intros; iterate 3 rw [one_bind])\n      (fun x => by intros; iterate 2 rw [pure_bind])\n      (fun x ih => by intros; (iterate 3 rw [inv_bind]); rw [ih])\n      (fun x y ihx ihy => by intros; (iterate 3 rw [mul_bind]); rw [ihx, ihy]))\n  (bind_pure_comp := fun f x =>\n    FreeGroup.induction_on x (by rw [one_bind, map_one]) (fun x => by rw [pure_bind, map_pure])\n      (fun x ih => by rw [inv_bind, map_inv, ih]) fun x y ihx ihy => by\n      rw [mul_bind, map_mul, ihx, ihy])\n\n"}
