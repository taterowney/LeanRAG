{"name":"bot_isPrincipal","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Bot.bot.IsPrincipal","decl":"instance bot_isPrincipal : (⊥ : Submodule R M).IsPrincipal :=\n  ⟨⟨0, by simp⟩⟩\n\n"}
{"name":"top_isPrincipal","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Top.top.IsPrincipal","decl":"instance top_isPrincipal : (⊤ : Submodule R R).IsPrincipal :=\n  ⟨⟨1, Ideal.span_singleton_one.symm⟩⟩\n\n"}
{"name":"IsBezout.isPrincipal_of_FG","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝ : Semiring R\nself : IsBezout R\nI : Ideal R\na✝ : I.FG\n⊢ Submodule.IsPrincipal I","decl":"/-- A Bézout ring is a ring whose finitely generated ideals are principal. -/\nclass IsBezout : Prop where\n  /-- Any finitely generated ideal is principal. -/\n  isPrincipal_of_FG : ∀ I : Ideal R, I.FG → I.IsPrincipal\n\n"}
{"name":"IsBezout.of_isPrincipalIdealRing","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : IsPrincipalIdealRing R\n⊢ IsBezout R","decl":"instance (priority := 100) IsBezout.of_isPrincipalIdealRing [IsPrincipalIdealRing R] : IsBezout R :=\n  ⟨fun I _ => IsPrincipalIdealRing.principal I⟩\n\n"}
{"name":"DivisionRing.isPrincipalIdealRing","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"K : Type u\ninst✝ : DivisionRing K\n⊢ IsPrincipalIdealRing K","decl":"instance (priority := 100) DivisionRing.isPrincipalIdealRing (K : Type u) [DivisionRing K] :\n    IsPrincipalIdealRing K where\n  principal S := by\n    rcases Ideal.eq_bot_or_top S with (rfl | rfl)\n    · apply bot_isPrincipal\n    · apply top_isPrincipal\n\n"}
{"name":"Submodule.IsPrincipal.span_singleton_generator","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\nM : Type v\ninst✝³ : AddCommMonoid M\ninst✝² : Semiring R\ninst✝¹ : Module R M\nS : Submodule R M\ninst✝ : S.IsPrincipal\n⊢ Eq (Submodule.span R (Singleton.singleton (Submodule.IsPrincipal.generator S))) S","decl":"theorem span_singleton_generator (S : Submodule R M) [S.IsPrincipal] : span R {generator S} = S :=\n  Eq.symm (Classical.choose_spec (principal S))\n\n"}
{"name":"Ideal.span_singleton_generator","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nI : Ideal R\ninst✝ : Submodule.IsPrincipal I\n⊢ Eq (Ideal.span (Singleton.singleton (Submodule.IsPrincipal.generator I))) I","decl":"@[simp]\ntheorem _root_.Ideal.span_singleton_generator (I : Ideal R) [I.IsPrincipal] :\n    Ideal.span ({generator I} : Set R) = I :=\n  Eq.symm (Classical.choose_spec (principal I))\n\n"}
{"name":"Submodule.IsPrincipal.generator_mem","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\nM : Type v\ninst✝³ : AddCommMonoid M\ninst✝² : Semiring R\ninst✝¹ : Module R M\nS : Submodule R M\ninst✝ : S.IsPrincipal\n⊢ Membership.mem S (Submodule.IsPrincipal.generator S)","decl":"@[simp]\ntheorem generator_mem (S : Submodule R M) [S.IsPrincipal] : generator S ∈ S := by\n  have : generator S ∈ span R {generator S} := subset_span (mem_singleton _)\n  convert this\n  exact span_singleton_generator S |>.symm\n\n"}
{"name":"Submodule.IsPrincipal.mem_iff_eq_smul_generator","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\nM : Type v\ninst✝³ : AddCommMonoid M\ninst✝² : Semiring R\ninst✝¹ : Module R M\nS : Submodule R M\ninst✝ : S.IsPrincipal\nx : M\n⊢ Iff (Membership.mem S x) (Exists fun s => Eq x (HSMul.hSMul s (Submodule.IsPrincipal.generator S)))","decl":"theorem mem_iff_eq_smul_generator (S : Submodule R M) [S.IsPrincipal] {x : M} :\n    x ∈ S ↔ ∃ s : R, x = s • generator S := by\n  simp_rw [@eq_comm _ x, ← mem_span_singleton, span_singleton_generator]\n\n"}
{"name":"Submodule.IsPrincipal.eq_bot_iff_generator_eq_zero","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\nM : Type v\ninst✝³ : AddCommMonoid M\ninst✝² : Semiring R\ninst✝¹ : Module R M\nS : Submodule R M\ninst✝ : S.IsPrincipal\n⊢ Iff (Eq S Bot.bot) (Eq (Submodule.IsPrincipal.generator S) 0)","decl":"theorem eq_bot_iff_generator_eq_zero (S : Submodule R M) [S.IsPrincipal] :\n    S = ⊥ ↔ generator S = 0 := by rw [← @span_singleton_eq_bot R M, span_singleton_generator]\n\n"}
{"name":"Submodule.IsPrincipal.fg","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\nM : Type v\ninst✝² : AddCommMonoid M\ninst✝¹ : Semiring R\ninst✝ : Module R M\nS : Submodule R M\nh : S.IsPrincipal\n⊢ S.FG","decl":"protected lemma fg {S : Submodule R M} (h : S.IsPrincipal) : S.FG :=\n  ⟨{h.generator}, by simp only [Finset.coe_singleton, span_singleton_generator]⟩\n\n-- See note [lower instance priority]\n"}
{"name":"PrincipalIdealRing.isNoetherianRing","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : IsPrincipalIdealRing R\n⊢ IsNoetherianRing R","decl":"instance (priority := 100) _root_.PrincipalIdealRing.isNoetherianRing [IsPrincipalIdealRing R] :\n    IsNoetherianRing R where\n  noetherian S := (IsPrincipalIdealRing.principal S).fg\n\n-- See note [lower instance priority]\n"}
{"name":"IsPrincipalIdealRing.of_isNoetherianRing_of_isBezout","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝² : Semiring R\ninst✝¹ : IsNoetherianRing R\ninst✝ : IsBezout R\n⊢ IsPrincipalIdealRing R","decl":"instance (priority := 100) _root_.IsPrincipalIdealRing.of_isNoetherianRing_of_isBezout\n    [IsNoetherianRing R] [IsBezout R] : IsPrincipalIdealRing R where\n  principal S := IsBezout.isPrincipal_of_FG S (IsNoetherian.noetherian S)\n\n"}
{"name":"Submodule.IsPrincipal.associated_generator_span_self","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsPrincipalIdealRing R\ninst✝ : IsDomain R\nr : R\n⊢ Associated (Submodule.IsPrincipal.generator (Ideal.span (Singleton.singleton r))) r","decl":"theorem associated_generator_span_self [IsPrincipalIdealRing R] [IsDomain R] (r : R) :\n    Associated (generator <| Ideal.span {r}) r := by\n  rw [← Ideal.span_singleton_eq_span_singleton]\n  exact Ideal.span_singleton_generator _\n\n"}
{"name":"Submodule.IsPrincipal.mem_iff_generator_dvd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Ideal R\ninst✝ : Submodule.IsPrincipal S\nx : R\n⊢ Iff (Membership.mem S x) (Dvd.dvd (Submodule.IsPrincipal.generator S) x)","decl":"theorem mem_iff_generator_dvd (S : Ideal R) [S.IsPrincipal] {x : R} : x ∈ S ↔ generator S ∣ x :=\n  (mem_iff_eq_smul_generator S).trans (exists_congr fun a => by simp only [mul_comm, smul_eq_mul])\n\n"}
{"name":"Submodule.IsPrincipal.prime_generator_of_isPrime","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Ideal R\ninst✝ : Submodule.IsPrincipal S\nis_prime : S.IsPrime\nne_bot : Ne S Bot.bot\n⊢ Prime (Submodule.IsPrincipal.generator S)","decl":"theorem prime_generator_of_isPrime (S : Ideal R) [S.IsPrincipal] [is_prime : S.IsPrime]\n    (ne_bot : S ≠ ⊥) : Prime (generator S) :=\n  ⟨fun h => ne_bot ((eq_bot_iff_generator_eq_zero S).2 h), fun h =>\n    is_prime.ne_top (S.eq_top_of_isUnit_mem (generator_mem S) h), fun _ _ => by\n    simpa only [← mem_iff_generator_dvd S] using is_prime.2⟩\n\n-- Note that the converse may not hold if `ϕ` is not injective.\n"}
{"name":"Submodule.IsPrincipal.generator_map_dvd_of_mem","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\nM : Type v\ninst✝³ : AddCommMonoid M\ninst✝² : CommRing R\ninst✝¹ : Module R M\nN : Submodule R M\nϕ : LinearMap (RingHom.id R) M R\ninst✝ : (Submodule.map ϕ N).IsPrincipal\nx : M\nhx : Membership.mem N x\n⊢ Dvd.dvd (Submodule.IsPrincipal.generator (Submodule.map ϕ N)) (ϕ x)","decl":"theorem generator_map_dvd_of_mem {N : Submodule R M} (ϕ : M →ₗ[R] R) [(N.map ϕ).IsPrincipal] {x : M}\n    (hx : x ∈ N) : generator (N.map ϕ) ∣ ϕ x := by\n  rw [← mem_iff_generator_dvd, Submodule.mem_map]\n  exact ⟨x, hx, rfl⟩\n\n-- Note that the converse may not hold if `ϕ` is not injective.\n"}
{"name":"Submodule.IsPrincipal.generator_submoduleImage_dvd_of_mem","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\nM : Type v\ninst✝³ : AddCommMonoid M\ninst✝² : CommRing R\ninst✝¹ : Module R M\nN O : Submodule R M\nhNO : LE.le N O\nϕ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem O x) R\ninst✝ : (ϕ.submoduleImage N).IsPrincipal\nx : M\nhx : Membership.mem N x\n⊢ Dvd.dvd (Submodule.IsPrincipal.generator (ϕ.submoduleImage N)) (ϕ ⟨x, ⋯⟩)","decl":"theorem generator_submoduleImage_dvd_of_mem {N O : Submodule R M} (hNO : N ≤ O) (ϕ : O →ₗ[R] R)\n    [(ϕ.submoduleImage N).IsPrincipal] {x : M} (hx : x ∈ N) :\n    generator (ϕ.submoduleImage N) ∣ ϕ ⟨x, hNO hx⟩ := by\n  rw [← mem_iff_generator_dvd, LinearMap.mem_submoduleImage_of_le hNO]\n  exact ⟨x, hx, rfl⟩\n\n"}
{"name":"IsBezout.span_pair_isPrincipal","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : Ring R\ninst✝ : IsBezout R\nx y : R\n⊢ Submodule.IsPrincipal (Ideal.span (Insert.insert x (Singleton.singleton y)))","decl":"instance span_pair_isPrincipal [IsBezout R] (x y : R) : (Ideal.span {x, y}).IsPrincipal := by\n  classical exact isPrincipal_of_FG (Ideal.span {x, y}) ⟨{x, y}, by simp⟩\n\n"}
{"name":"IsBezout.span_gcd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : Ring R\nx y : R\ninst✝ : Submodule.IsPrincipal (Ideal.span (Insert.insert x (Singleton.singleton y)))\n⊢ Eq (Ideal.span (Singleton.singleton (IsBezout.gcd x y))) (Ideal.span (Insert.insert x (Singleton.singleton y)))","decl":"theorem span_gcd : Ideal.span {gcd x y} = Ideal.span {x, y} :=\n  Ideal.span_singleton_generator _\n\n"}
{"name":"IsBezout.gcd_dvd_left","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nx y : R\ninst✝ : Submodule.IsPrincipal (Ideal.span (Insert.insert x (Singleton.singleton y)))\n⊢ Dvd.dvd (IsBezout.gcd x y) x","decl":"theorem gcd_dvd_left : gcd x y ∣ x :=\n  (Submodule.IsPrincipal.mem_iff_generator_dvd _).mp (Ideal.subset_span (by simp))\n\n"}
{"name":"IsBezout.gcd_dvd_right","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nx y : R\ninst✝ : Submodule.IsPrincipal (Ideal.span (Insert.insert x (Singleton.singleton y)))\n⊢ Dvd.dvd (IsBezout.gcd x y) y","decl":"theorem gcd_dvd_right : gcd x y ∣ y :=\n  (Submodule.IsPrincipal.mem_iff_generator_dvd _).mp (Ideal.subset_span (by simp))\n\n"}
{"name":"IsBezout.dvd_gcd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nx y z : R\ninst✝ : Submodule.IsPrincipal (Ideal.span (Insert.insert x (Singleton.singleton y)))\nhx : Dvd.dvd z x\nhy : Dvd.dvd z y\n⊢ Dvd.dvd z (IsBezout.gcd x y)","decl":"variable {x y z} in\ntheorem dvd_gcd (hx : z ∣ x) (hy : z ∣ y) : z ∣ gcd x y := by\n  rw [← Ideal.span_singleton_le_span_singleton] at hx hy ⊢\n  rw [span_gcd, Ideal.span_insert, sup_le_iff]\n  exact ⟨hx, hy⟩\n\n"}
{"name":"IsBezout.gcd_eq_sum","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nx y : R\ninst✝ : Submodule.IsPrincipal (Ideal.span (Insert.insert x (Singleton.singleton y)))\n⊢ Exists fun a => Exists fun b => Eq (HAdd.hAdd (HMul.hMul a x) (HMul.hMul b y)) (IsBezout.gcd x y)","decl":"theorem gcd_eq_sum : ∃ a b : R, a * x + b * y = gcd x y :=\n  Ideal.mem_span_pair.mp (by rw [← span_gcd]; apply Ideal.subset_span; simp)\n\n"}
{"name":"IsRelPrime.isCoprime","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nx y : R\ninst✝ : Submodule.IsPrincipal (Ideal.span (Insert.insert x (Singleton.singleton y)))\nh : IsRelPrime x y\n⊢ IsCoprime x y","decl":"theorem _root_.IsRelPrime.isCoprime (h : IsRelPrime x y) : IsCoprime x y := by\n  rw [← Ideal.isCoprime_span_singleton_iff, Ideal.isCoprime_iff_sup_eq, ← Ideal.span_union,\n    Set.singleton_union, ← span_gcd, Ideal.span_singleton_eq_top]\n  exact h (gcd_dvd_left x y) (gcd_dvd_right x y)\n\n"}
{"name":"isRelPrime_iff_isCoprime","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nx y : R\ninst✝ : Submodule.IsPrincipal (Ideal.span (Insert.insert x (Singleton.singleton y)))\n⊢ Iff (IsRelPrime x y) (IsCoprime x y)","decl":"theorem _root_.isRelPrime_iff_isCoprime : IsRelPrime x y ↔ IsCoprime x y :=\n  ⟨IsRelPrime.isCoprime, IsCoprime.isRelPrime⟩\n\n"}
{"name":"IsBezout.nonemptyGCDMonoid","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsBezout R\ninst✝ : IsDomain R\n⊢ Nonempty (GCDMonoid R)","decl":"instance nonemptyGCDMonoid [IsBezout R] [IsDomain R] : Nonempty (GCDMonoid R) := by\n  classical exact ⟨toGCDDomain R⟩\n\n"}
{"name":"IsBezout.associated_gcd_gcd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝³ : CommRing R\nx y : R\ninst✝² : Submodule.IsPrincipal (Ideal.span (Insert.insert x (Singleton.singleton y)))\ninst✝¹ : IsDomain R\ninst✝ : GCDMonoid R\n⊢ Associated (IsBezout.gcd x y) (GCDMonoid.gcd x y)","decl":"theorem associated_gcd_gcd [IsDomain R] [GCDMonoid R] :\n    Associated (IsBezout.gcd x y) (GCDMonoid.gcd x y) :=\n  gcd_greatest_associated (gcd_dvd_left _ _ ) (gcd_dvd_right _ _) (fun _ => dvd_gcd)\n\n"}
{"name":"IsPrime.to_maximal_ideal","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\nS : Ideal R\nhpi : S.IsPrime\nhS : Ne S Bot.bot\n⊢ S.IsMaximal","decl":"theorem to_maximal_ideal [CommRing R] [IsDomain R] [IsPrincipalIdealRing R] {S : Ideal R}\n    [hpi : IsPrime S] (hS : S ≠ ⊥) : IsMaximal S :=\n  isMaximal_iff.2\n    ⟨(ne_top_iff_one S).1 hpi.1, by\n      intro T x hST hxS hxT\n      cases' (mem_iff_generator_dvd _).1 (hST <| generator_mem S) with z hz\n      cases hpi.mem_or_mem (show generator T * z ∈ S from hz ▸ generator_mem S) with\n      | inl h =>\n        have hTS : T ≤ S := by\n          rwa [← T.span_singleton_generator, Ideal.span_le, singleton_subset_iff]\n        exact (hxS <| hTS hxT).elim\n      | inr h =>\n        cases' (mem_iff_generator_dvd _).1 h with y hy\n        have : generator S ≠ 0 := mt (eq_bot_iff_generator_eq_zero _).2 hS\n        rw [← mul_one (generator S), hy, mul_left_comm, mul_right_inj' this] at hz\n        exact hz.symm ▸ T.mul_mem_right _ (generator_mem T)⟩\n\n"}
{"name":"mod_mem_iff","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\nS : Ideal R\nx y : R\nhy : Membership.mem S y\n⊢ Iff (Membership.mem S (HMod.hMod x y)) (Membership.mem S x)","decl":"theorem mod_mem_iff {S : Ideal R} {x y : R} (hy : y ∈ S) : x % y ∈ S ↔ x ∈ S :=\n  ⟨fun hxy => div_add_mod x y ▸ S.add_mem (S.mul_mem_right _ hy) hxy, fun hx =>\n    (mod_eq_sub_mul_div x y).symm ▸ S.sub_mem hx (S.mul_mem_right _ hy)⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"EuclideanDomain.to_principal_ideal_domain","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝ : EuclideanDomain R\n⊢ IsPrincipalIdealRing R","decl":"instance (priority := 100) EuclideanDomain.to_principal_ideal_domain : IsPrincipalIdealRing R where\n  principal S := by classical exact\n    ⟨if h : { x : R | x ∈ S ∧ x ≠ 0 }.Nonempty then\n        have wf : WellFounded (EuclideanDomain.r : R → R → Prop) := EuclideanDomain.r_wellFounded\n        have hmin : WellFounded.min wf { x : R | x ∈ S ∧ x ≠ 0 } h ∈ S ∧\n            WellFounded.min wf { x : R | x ∈ S ∧ x ≠ 0 } h ≠ 0 :=\n          WellFounded.min_mem wf { x : R | x ∈ S ∧ x ≠ 0 } h\n        ⟨WellFounded.min wf { x : R | x ∈ S ∧ x ≠ 0 } h,\n          Submodule.ext fun x => ⟨fun hx =>\n            div_add_mod x (WellFounded.min wf { x : R | x ∈ S ∧ x ≠ 0 } h) ▸\n              (Ideal.mem_span_singleton.2 <| dvd_add (dvd_mul_right _ _) <| by\n                have : x % WellFounded.min wf { x : R | x ∈ S ∧ x ≠ 0 } h ∉\n                    { x : R | x ∈ S ∧ x ≠ 0 } :=\n                  fun h₁ => WellFounded.not_lt_min wf _ h h₁ (mod_lt x hmin.2)\n                have : x % WellFounded.min wf { x : R | x ∈ S ∧ x ≠ 0 } h = 0 := by\n                  simp only [not_and_or, Set.mem_setOf_eq, not_ne_iff] at this\n                  exact this.neg_resolve_left <| (mod_mem_iff hmin.1).2 hx\n                simp [*]),\n              fun hx =>\n                let ⟨y, hy⟩ := Ideal.mem_span_singleton.1 hx\n                hy.symm ▸ S.mul_mem_right _ hmin.1⟩⟩\n      else ⟨0, Submodule.ext fun a => by\n            rw [← @Submodule.bot_coe R R _ _ _, span_eq, Submodule.mem_bot]\n            exact ⟨fun haS => by_contra fun ha0 => h ⟨a, ⟨haS, ha0⟩⟩,\n              fun h₁ => h₁.symm ▸ S.zero_mem⟩⟩⟩\n\n"}
{"name":"IsField.isPrincipalIdealRing","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nh : IsField R\n⊢ IsPrincipalIdealRing R","decl":"theorem IsField.isPrincipalIdealRing {R : Type*} [CommRing R] (h : IsField R) :\n    IsPrincipalIdealRing R :=\n  @EuclideanDomain.to_principal_ideal_domain R (@Field.toEuclideanDomain R h.toField)\n\n"}
{"name":"PrincipalIdealRing.isMaximal_of_irreducible","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsPrincipalIdealRing R\np : R\nhp : Irreducible p\n⊢ Ideal.IsMaximal (Submodule.span R (Singleton.singleton p))","decl":"theorem isMaximal_of_irreducible [CommRing R] [IsPrincipalIdealRing R] {p : R}\n    (hp : Irreducible p) : Ideal.IsMaximal (span R ({p} : Set R)) :=\n  ⟨⟨mt Ideal.span_singleton_eq_top.1 hp.1, fun I hI => by\n      rcases principal I with ⟨a, rfl⟩\n      erw [Ideal.span_singleton_eq_top]\n      rcases Ideal.span_singleton_le_span_singleton.1 (le_of_lt hI) with ⟨b, rfl⟩\n      refine (of_irreducible_mul hp).resolve_right (mt (fun hb => ?_) (not_le_of_lt hI))\n      erw [Ideal.span_singleton_le_span_singleton, IsUnit.mul_right_dvd hb]⟩⟩\n\n"}
{"name":"PrincipalIdealRing.factors_spec","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\na : R\nh : Ne a 0\n⊢ And (∀ (b : R), Membership.mem (PrincipalIdealRing.factors a) b → Irreducible b) (Associated (PrincipalIdealRing.factors a).prod a)","decl":"theorem factors_spec (a : R) (h : a ≠ 0) :\n    (∀ b ∈ factors a, Irreducible b) ∧ Associated (factors a).prod a := by\n  unfold factors; rw [dif_neg h]\n  exact Classical.choose_spec (WfDvdMonoid.exists_factors a h)\n\n"}
{"name":"PrincipalIdealRing.ne_zero_of_mem_factors","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type v\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\na b : R\nha : Ne a 0\nhb : Membership.mem (PrincipalIdealRing.factors a) b\n⊢ Ne b 0","decl":"theorem ne_zero_of_mem_factors {R : Type v} [CommRing R] [IsDomain R] [IsPrincipalIdealRing R]\n    {a b : R} (ha : a ≠ 0) (hb : b ∈ factors a) : b ≠ 0 :=\n  Irreducible.ne_zero ((factors_spec a ha).1 b hb)\n\n"}
{"name":"PrincipalIdealRing.mem_submonoid_of_factors_subset_of_units_subset","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\ns : Submonoid R\na : R\nha : Ne a 0\nhfac : ∀ (b : R), Membership.mem (PrincipalIdealRing.factors a) b → Membership.mem s b\nhunit : ∀ (c : Units R), Membership.mem s ↑c\n⊢ Membership.mem s a","decl":"theorem mem_submonoid_of_factors_subset_of_units_subset (s : Submonoid R) {a : R} (ha : a ≠ 0)\n    (hfac : ∀ b ∈ factors a, b ∈ s) (hunit : ∀ c : Rˣ, (c : R) ∈ s) : a ∈ s := by\n  rcases (factors_spec a ha).2 with ⟨c, hc⟩\n  rw [← hc]\n  exact mul_mem (multiset_prod_mem _ hfac) (hunit _)\n\n"}
{"name":"PrincipalIdealRing.ringHom_mem_submonoid_of_factors_subset_of_units_subset","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : IsPrincipalIdealRing R\ninst✝ : Semiring S\nf : RingHom R S\ns : Submonoid S\na : R\nha : Ne a 0\nh : ∀ (b : R), Membership.mem (PrincipalIdealRing.factors a) b → Membership.mem s (f b)\nhf : ∀ (c : Units R), Membership.mem s (f ↑c)\n⊢ Membership.mem s (f a)","decl":"/-- If a `RingHom` maps all units and all factors of an element `a` into a submonoid `s`, then it\nalso maps `a` into that submonoid. -/\ntheorem ringHom_mem_submonoid_of_factors_subset_of_units_subset {R S : Type*} [CommRing R]\n    [IsDomain R] [IsPrincipalIdealRing R] [Semiring S] (f : R →+* S) (s : Submonoid S) (a : R)\n    (ha : a ≠ 0) (h : ∀ b ∈ factors a, f b ∈ s) (hf : ∀ c : Rˣ, f c ∈ s) : f a ∈ s :=\n  mem_submonoid_of_factors_subset_of_units_subset (s.comap f.toMonoidHom) ha h hf\n\n-- see Note [lower instance priority]\n"}
{"name":"PrincipalIdealRing.to_uniqueFactorizationMonoid","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\n⊢ UniqueFactorizationMonoid R","decl":"/-- A principal ideal domain has unique factorization -/\ninstance (priority := 100) to_uniqueFactorizationMonoid : UniqueFactorizationMonoid R :=\n  { (IsNoetherianRing.wfDvdMonoid : WfDvdMonoid R) with\n    irreducible_iff_prime := irreducible_iff_prime }\n\n"}
{"name":"Submodule.IsPrincipal.map","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\nM : Type v\nN : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\nS : Submodule R M\nhI : S.IsPrincipal\n⊢ (Submodule.map f S).IsPrincipal","decl":"theorem Submodule.IsPrincipal.map (f : M →ₗ[R] N) {S : Submodule R M}\n    (hI : IsPrincipal S) : IsPrincipal (map f S) :=\n  ⟨⟨f (IsPrincipal.generator S), by\n      rw [← Set.image_singleton, ← map_span, span_singleton_generator]⟩⟩\n\n"}
{"name":"Submodule.IsPrincipal.of_comap","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\nM : Type v\nN : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\nhf : Function.Surjective ⇑f\nS : Submodule R N\nhI : (Submodule.comap f S).IsPrincipal\n⊢ S.IsPrincipal","decl":"theorem Submodule.IsPrincipal.of_comap (f : M →ₗ[R] N) (hf : Function.Surjective f)\n    (S : Submodule R N) [hI : IsPrincipal (S.comap f)] : IsPrincipal S := by\n  rw [← Submodule.map_comap_eq_of_surjective hf S]\n  exact hI.map f\n\n"}
{"name":"Submodule.IsPrincipal.map_ringHom","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\nS : Type u_1\nF : Type u_3\ninst✝³ : Ring R\ninst✝² : Ring S\ninst✝¹ : FunLike F R S\ninst✝ : RingHomClass F R S\nf : F\nI : Ideal R\nhI : Submodule.IsPrincipal I\n⊢ Submodule.IsPrincipal (Ideal.map f I)","decl":"theorem Submodule.IsPrincipal.map_ringHom (f : F) {I : Ideal R}\n    (hI : IsPrincipal I) : IsPrincipal (Ideal.map f I) :=\n  ⟨⟨f (IsPrincipal.generator I), by\n      rw [Ideal.submodule_span_eq, ← Set.image_singleton, ← Ideal.map_span,\n      Ideal.span_singleton_generator]⟩⟩\n\n"}
{"name":"Ideal.IsPrincipal.of_comap","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\nS : Type u_1\nF : Type u_3\ninst✝³ : Ring R\ninst✝² : Ring S\ninst✝¹ : FunLike F R S\ninst✝ : RingHomClass F R S\nf : F\nhf : Function.Surjective ⇑f\nI : Ideal S\nhI : Submodule.IsPrincipal (Ideal.comap f I)\n⊢ Submodule.IsPrincipal I","decl":"theorem Ideal.IsPrincipal.of_comap (f : F) (hf : Function.Surjective f) (I : Ideal S)\n    [hI : IsPrincipal (I.comap f)] : IsPrincipal I := by\n  rw [← map_comap_of_surjective f hf I]\n  exact hI.map_ringHom f\n\n"}
{"name":"IsPrincipalIdealRing.of_surjective","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\nS : Type u_1\nF : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : Ring S\ninst✝² : FunLike F R S\ninst✝¹ : RingHomClass F R S\ninst✝ : IsPrincipalIdealRing R\nf : F\nhf : Function.Surjective ⇑f\n⊢ IsPrincipalIdealRing S","decl":"/-- The surjective image of a principal ideal ring is again a principal ideal ring. -/\ntheorem IsPrincipalIdealRing.of_surjective [IsPrincipalIdealRing R] (f : F)\n    (hf : Function.Surjective f) : IsPrincipalIdealRing S :=\n  ⟨fun I => Ideal.IsPrincipal.of_comap f hf I⟩\n\n"}
{"name":"isCoprime_of_dvd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsBezout R\nx y : R\nnonzero : Not (And (Eq x 0) (Eq y 0))\nH : ∀ (z : R), Membership.mem (nonunits R) z → Ne z 0 → Dvd.dvd z x → Not (Dvd.dvd z y)\n⊢ IsCoprime x y","decl":"theorem isCoprime_of_dvd (x y : R) (nonzero : ¬(x = 0 ∧ y = 0))\n    (H : ∀ z ∈ nonunits R, z ≠ 0 → z ∣ x → ¬z ∣ y) : IsCoprime x y :=\n  (isRelPrime_of_no_nonunits_factors nonzero H).isCoprime\n\n"}
{"name":"dvd_or_isCoprime","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsBezout R\nx y : R\nh : Irreducible x\n⊢ Or (Dvd.dvd x y) (IsCoprime x y)","decl":"theorem dvd_or_isCoprime (x y : R) (h : Irreducible x) : x ∣ y ∨ IsCoprime x y :=\n  h.dvd_or_isRelPrime.imp_right IsRelPrime.isCoprime\n\n"}
{"name":"dvd_or_coprime","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsBezout R\nx y : R\nh : Irreducible x\n⊢ Or (Dvd.dvd x y) (IsCoprime x y)","decl":"@[deprecated (since := \"2025-01-23\")] alias dvd_or_coprime := dvd_or_isCoprime\n\n"}
{"name":"Irreducible.coprime_iff_not_dvd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsBezout R\np n : R\nhp : Irreducible p\n⊢ Iff (IsCoprime p n) (Not (Dvd.dvd p n))","decl":"/-- See also `Irreducible.isRelPrime_iff_not_dvd`. -/\ntheorem Irreducible.coprime_iff_not_dvd {p n : R} (hp : Irreducible p) :\n    IsCoprime p n ↔ ¬p ∣ n := by rw [← isRelPrime_iff_isCoprime, hp.isRelPrime_iff_not_dvd]\n\n"}
{"name":"Irreducible.dvd_iff_not_isCoprime","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsBezout R\np n : R\nhp : Irreducible p\n⊢ Iff (Dvd.dvd p n) (Not (IsCoprime p n))","decl":"/-- See also `Irreducible.coprime_iff_not_dvd'`. -/\ntheorem Irreducible.dvd_iff_not_isCoprime {p n : R} (hp : Irreducible p) : p ∣ n ↔ ¬IsCoprime p n :=\n  iff_not_comm.2 hp.coprime_iff_not_dvd\n\n"}
{"name":"Irreducible.dvd_iff_not_coprime","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsBezout R\np n : R\nhp : Irreducible p\n⊢ Iff (Dvd.dvd p n) (Not (IsCoprime p n))","decl":"@[deprecated (since := \"2025-01-23\")]\nalias Irreducible.dvd_iff_not_coprime := Irreducible.dvd_iff_not_isCoprime\n\n"}
{"name":"Irreducible.coprime_pow_of_not_dvd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsBezout R\np a : R\nm : Nat\nhp : Irreducible p\nh : Not (Dvd.dvd p a)\n⊢ IsCoprime a (HPow.hPow p m)","decl":"theorem Irreducible.coprime_pow_of_not_dvd {p a : R} (m : ℕ) (hp : Irreducible p) (h : ¬p ∣ a) :\n    IsCoprime a (p ^ m) :=\n  (hp.coprime_iff_not_dvd.2 h).symm.pow_right\n\n"}
{"name":"Irreducible.isCoprime_or_dvd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsBezout R\np : R\nhp : Irreducible p\ni : R\n⊢ Or (IsCoprime p i) (Dvd.dvd p i)","decl":"theorem Irreducible.isCoprime_or_dvd {p : R} (hp : Irreducible p) (i : R) : IsCoprime p i ∨ p ∣ i :=\n  (_root_.em _).imp_right hp.dvd_iff_not_isCoprime.2\n\n"}
{"name":"Irreducible.coprime_or_dvd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsBezout R\np : R\nhp : Irreducible p\ni : R\n⊢ Or (IsCoprime p i) (Dvd.dvd p i)","decl":"@[deprecated (since := \"2025-01-23\")]\nalias Irreducible.coprime_or_dvd := Irreducible.isCoprime_or_dvd\n\n"}
{"name":"IsBezout.span_gcd_eq_span_gcd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝³ : CommRing R\ninst✝² : IsBezout R\ninst✝¹ : IsDomain R\ninst✝ : GCDMonoid R\nx y : R\n⊢ Eq (Ideal.span (Singleton.singleton (GCDMonoid.gcd x y))) (Ideal.span (Singleton.singleton (IsBezout.gcd x y)))","decl":"theorem IsBezout.span_gcd_eq_span_gcd (x y : R) :\n    span {GCDMonoid.gcd x y} = span {IsBezout.gcd x y} := by\n  rw [Ideal.span_singleton_eq_span_singleton]\n  exact associated_of_dvd_dvd\n    (IsBezout.dvd_gcd (GCDMonoid.gcd_dvd_left _ _) <| GCDMonoid.gcd_dvd_right _ _)\n    (GCDMonoid.dvd_gcd (IsBezout.gcd_dvd_left _ _) <| IsBezout.gcd_dvd_right _ _)\n\n"}
{"name":"span_gcd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝³ : CommRing R\ninst✝² : IsBezout R\ninst✝¹ : IsDomain R\ninst✝ : GCDMonoid R\nx y : R\n⊢ Eq (Ideal.span (Singleton.singleton (GCDMonoid.gcd x y))) (Ideal.span (Insert.insert x (Singleton.singleton y)))","decl":"theorem span_gcd (x y : R) : span {gcd x y} = span {x, y} := by\n  rw [← IsBezout.span_gcd, IsBezout.span_gcd_eq_span_gcd]\n\n"}
{"name":"gcd_dvd_iff_exists","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝³ : CommRing R\ninst✝² : IsBezout R\ninst✝¹ : IsDomain R\ninst✝ : GCDMonoid R\na b z : R\n⊢ Iff (Dvd.dvd (GCDMonoid.gcd a b) z) (Exists fun x => Exists fun y => Eq z (HAdd.hAdd (HMul.hMul a x) (HMul.hMul b y)))","decl":"theorem gcd_dvd_iff_exists (a b : R) {z} : gcd a b ∣ z ↔ ∃ x y, z = a * x + b * y := by\n  simp_rw [mul_comm a, mul_comm b, @eq_comm _ z, ← Ideal.mem_span_pair, ← span_gcd,\n    Ideal.mem_span_singleton]\n\n"}
{"name":"exists_gcd_eq_mul_add_mul","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝³ : CommRing R\ninst✝² : IsBezout R\ninst✝¹ : IsDomain R\ninst✝ : GCDMonoid R\na b : R\n⊢ Exists fun x => Exists fun y => Eq (GCDMonoid.gcd a b) (HAdd.hAdd (HMul.hMul a x) (HMul.hMul b y))","decl":"/-- **Bézout's lemma** -/\ntheorem exists_gcd_eq_mul_add_mul (a b : R) : ∃ x y, gcd a b = a * x + b * y := by\n  rw [← gcd_dvd_iff_exists]\n\n"}
{"name":"gcd_isUnit_iff","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝³ : CommRing R\ninst✝² : IsBezout R\ninst✝¹ : IsDomain R\ninst✝ : GCDMonoid R\nx y : R\n⊢ Iff (IsUnit (GCDMonoid.gcd x y)) (IsCoprime x y)","decl":"theorem gcd_isUnit_iff (x y : R) : IsUnit (gcd x y) ↔ IsCoprime x y := by\n  rw [IsCoprime, ← Ideal.mem_span_pair, ← span_gcd, ← span_singleton_eq_top, eq_top_iff_one]\n\n"}
{"name":"Prime.coprime_iff_not_dvd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsBezout R\ninst✝ : IsDomain R\np n : R\nhp : Prime p\n⊢ Iff (IsCoprime p n) (Not (Dvd.dvd p n))","decl":"theorem Prime.coprime_iff_not_dvd {p n : R} (hp : Prime p) : IsCoprime p n ↔ ¬p ∣ n :=\n  hp.irreducible.coprime_iff_not_dvd\n\n"}
{"name":"exists_associated_pow_of_mul_eq_pow'","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsBezout R\ninst✝ : IsDomain R\na b c : R\nhab : IsCoprime a b\nk : Nat\nh : Eq (HMul.hMul a b) (HPow.hPow c k)\n⊢ Exists fun d => Associated (HPow.hPow d k) a","decl":"theorem exists_associated_pow_of_mul_eq_pow' {a b c : R} (hab : IsCoprime a b) {k : ℕ}\n    (h : a * b = c ^ k) : ∃ d : R, Associated (d ^ k) a := by\n  classical\n  letI := IsBezout.toGCDDomain R\n  exact exists_associated_pow_of_mul_eq_pow ((gcd_isUnit_iff _ _).mpr hab) h\n\n"}
{"name":"exists_associated_pow_of_associated_pow_mul","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsBezout R\ninst✝ : IsDomain R\na b c : R\nhab : IsCoprime a b\nk : Nat\nh : Associated (HPow.hPow c k) (HMul.hMul a b)\n⊢ Exists fun d => Associated (HPow.hPow d k) a","decl":"theorem exists_associated_pow_of_associated_pow_mul {a b c : R} (hab : IsCoprime a b) {k : ℕ}\n    (h : Associated (c ^ k) (a * b)) : ∃ d : R, Associated (d ^ k) a := by\n  obtain ⟨u, hu⟩ := h.symm\n  exact exists_associated_pow_of_mul_eq_pow'\n    ((isCoprime_mul_unit_right_right u.isUnit a b).mpr hab) <| mul_assoc a _ _ ▸ hu\n\n"}
{"name":"isCoprime_of_irreducible_dvd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\nx y : R\nnonzero : Not (And (Eq x 0) (Eq y 0))\nH : ∀ (z : R), Irreducible z → Dvd.dvd z x → Not (Dvd.dvd z y)\n⊢ IsCoprime x y","decl":"theorem isCoprime_of_irreducible_dvd {x y : R} (nonzero : ¬(x = 0 ∧ y = 0))\n    (H : ∀ z : R, Irreducible z → z ∣ x → ¬z ∣ y) : IsCoprime x y :=\n  (WfDvdMonoid.isRelPrime_of_no_irreducible_factors nonzero H).isCoprime\n\n"}
{"name":"isCoprime_of_prime_dvd","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsPrincipalIdealRing R\nx y : R\nnonzero : Not (And (Eq x 0) (Eq y 0))\nH : ∀ (z : R), Prime z → Dvd.dvd z x → Not (Dvd.dvd z y)\n⊢ IsCoprime x y","decl":"theorem isCoprime_of_prime_dvd {x y : R} (nonzero : ¬(x = 0 ∧ y = 0))\n    (H : ∀ z : R, Prime z → z ∣ x → ¬z ∣ y) : IsCoprime x y :=\n  isCoprime_of_irreducible_dvd nonzero fun z zi ↦ H z zi.prime\n\n"}
{"name":"nonPrincipals_def","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Iff (Membership.mem (nonPrincipals R) I) (Not (Submodule.IsPrincipal I))","decl":"theorem nonPrincipals_def {I : Ideal R} : I ∈ nonPrincipals R ↔ ¬I.IsPrincipal :=\n  Iff.rfl\n\n"}
{"name":"nonPrincipals_eq_empty_iff","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Iff (Eq (nonPrincipals R) EmptyCollection.emptyCollection) (IsPrincipalIdealRing R)","decl":"theorem nonPrincipals_eq_empty_iff : nonPrincipals R = ∅ ↔ IsPrincipalIdealRing R := by\n  simp [Set.eq_empty_iff_forall_not_mem, isPrincipalIdealRing_iff, nonPrincipals_def]\n\n"}
{"name":"nonPrincipals_zorn","module":"Mathlib.RingTheory.PrincipalIdealDomain","initialProofState":"R : Type u\ninst✝ : CommRing R\nc : Set (Ideal R)\nhs : HasSubset.Subset c (nonPrincipals R)\nhchain : IsChain (fun x1 x2 => LE.le x1 x2) c\nK : Ideal R\nhKmem : Membership.mem c K\n⊢ Exists fun I => And (Membership.mem (nonPrincipals R) I) (∀ (J : Ideal R), Membership.mem c J → LE.le J I)","decl":"/-- Any chain in the set of non-principal ideals has an upper bound which is non-principal.\n(Namely, the union of the chain is such an upper bound.)\n-/\ntheorem nonPrincipals_zorn (c : Set (Ideal R)) (hs : c ⊆ nonPrincipals R)\n    (hchain : IsChain (· ≤ ·) c) {K : Ideal R} (hKmem : K ∈ c) :\n    ∃ I ∈ nonPrincipals R, ∀ J ∈ c, J ≤ I := by\n  refine ⟨sSup c, ?_, fun J hJ => le_sSup hJ⟩\n  rintro ⟨x, hx⟩\n  have hxmem : x ∈ sSup c := hx.symm ▸ Submodule.mem_span_singleton_self x\n  obtain ⟨J, hJc, hxJ⟩ := (Submodule.mem_sSup_of_directed ⟨K, hKmem⟩ hchain.directedOn).1 hxmem\n  have hsSupJ : sSup c = J := le_antisymm (by simp [hx, Ideal.span_le, hxJ]) (le_sSup hJc)\n  specialize hs hJc\n  rw [← hsSupJ, hx, nonPrincipals_def] at hs\n  exact hs ⟨⟨x, rfl⟩⟩\n\n"}
