{"name":"Projectivization.mk'_eq_mk","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : Subtype fun v => Ne v 0\n⊢ Eq (Projectivization.mk' K v) (Projectivization.mk K ↑v ⋯)","decl":"@[simp]\ntheorem mk'_eq_mk (v : { v : V // v ≠ 0 }) : mk' K v = mk K ↑v v.2 := rfl\n\n"}
{"name":"Projectivization.instNonemptyOfNontrivial","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Nontrivial V\n⊢ Nonempty (Projectivization K V)","decl":"instance [Nontrivial V] : Nonempty (ℙ K V) :=\n  let ⟨v, hv⟩ := exists_ne (0 : V)\n  ⟨mk K v hv⟩\n\n"}
{"name":"Projectivization.lift_mk","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nα : Type u_3\nf : (Subtype fun v => Ne v 0) → α\nhf : ∀ (a b : Subtype fun v => Ne v 0) (t : K), Eq (↑a) (HSMul.hSMul t ↑b) → Eq (f a) (f b)\nv : V\nhv : Ne v 0\n⊢ Eq (Projectivization.lift f hf (Projectivization.mk K v hv)) (f ⟨v, hv⟩)","decl":"@[simp]\nprotected lemma lift_mk {α : Type*} (f : { v : V // v ≠ 0 } → α)\n    (hf : ∀ (a b : { v : V // v ≠ 0 }) (t : K), a = t • (b : V) → f a = f b)\n    (v : V) (hv : v ≠ 0) :\n    Projectivization.lift f hf (mk K v hv) = f ⟨v, hv⟩ :=\n  rfl\n\n"}
{"name":"Projectivization.rep_nonzero","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : Projectivization K V\n⊢ Ne v.rep 0","decl":"theorem rep_nonzero (v : ℙ K V) : v.rep ≠ 0 :=\n  v.out.2\n\n"}
{"name":"Projectivization.mk_rep","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : Projectivization K V\n⊢ Eq (Projectivization.mk K v.rep ⋯) v","decl":"@[simp]\ntheorem mk_rep (v : ℙ K V) : mk K v.rep v.rep_nonzero = v := Quotient.out_eq' _\n\n"}
{"name":"Projectivization.mk_eq_mk_iff","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv w : V\nhv : Ne v 0\nhw : Ne w 0\n⊢ Iff (Eq (Projectivization.mk K v hv) (Projectivization.mk K w hw)) (Exists fun a => Eq (HSMul.hSMul a w) v)","decl":"theorem mk_eq_mk_iff (v w : V) (hv : v ≠ 0) (hw : w ≠ 0) :\n    mk K v hv = mk K w hw ↔ ∃ a : Kˣ, a • w = v :=\n  Quotient.eq''\n\n"}
{"name":"Projectivization.mk_eq_mk_iff'","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv w : V\nhv : Ne v 0\nhw : Ne w 0\n⊢ Iff (Eq (Projectivization.mk K v hv) (Projectivization.mk K w hw)) (Exists fun a => Eq (HSMul.hSMul a w) v)","decl":"/-- Two nonzero vectors go to the same point in projective space if and only if one is\na scalar multiple of the other. -/\ntheorem mk_eq_mk_iff' (v w : V) (hv : v ≠ 0) (hw : w ≠ 0) :\n    mk K v hv = mk K w hw ↔ ∃ a : K, a • w = v := by\n  rw [mk_eq_mk_iff K v w hv hw]\n  constructor\n  · rintro ⟨a, ha⟩\n    exact ⟨a, ha⟩\n  · rintro ⟨a, ha⟩\n    refine ⟨Units.mk0 a fun c => hv.symm ?_, ha⟩\n    rwa [c, zero_smul] at ha\n\n"}
{"name":"Projectivization.exists_smul_eq_mk_rep","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : V\nhv : Ne v 0\n⊢ Exists fun a => Eq (HSMul.hSMul a v) (Projectivization.mk K v hv).rep","decl":"theorem exists_smul_eq_mk_rep (v : V) (hv : v ≠ 0) : ∃ a : Kˣ, a • v = (mk K v hv).rep :=\n  (mk_eq_mk_iff K _ _ (rep_nonzero _) hv).1 (mk_rep _)\n\n"}
{"name":"Projectivization.ind","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nP : Projectivization K V → Prop\nh : ∀ (v : V) (h : Ne v 0), P (Projectivization.mk K v h)\np : Projectivization K V\n⊢ P p","decl":"/-- An induction principle for `Projectivization`. Use as `induction v`. -/\n@[elab_as_elim, cases_eliminator, induction_eliminator]\ntheorem ind {P : ℙ K V → Prop} (h : ∀ (v : V) (h : v ≠ 0), P (mk K v h)) : ∀ p, P p :=\n  Quotient.ind' <| Subtype.rec <| h\n\n"}
{"name":"Projectivization.submodule_mk","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : V\nhv : Ne v 0\n⊢ Eq (Projectivization.mk K v hv).submodule (Submodule.span K (Singleton.singleton v))","decl":"@[simp]\ntheorem submodule_mk (v : V) (hv : v ≠ 0) : (mk K v hv).submodule = K ∙ v :=\n  rfl\n\n"}
{"name":"Projectivization.submodule_eq","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : Projectivization K V\n⊢ Eq v.submodule (Submodule.span K (Singleton.singleton v.rep))","decl":"theorem submodule_eq (v : ℙ K V) : v.submodule = K ∙ v.rep := by\n  conv_lhs => rw [← v.mk_rep]\n  rfl\n\n"}
{"name":"Projectivization.finrank_submodule","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : Projectivization K V\n⊢ Eq (Module.finrank K (Subtype fun x => Membership.mem v.submodule x)) 1","decl":"theorem finrank_submodule (v : ℙ K V) : finrank K v.submodule = 1 := by\n  rw [submodule_eq]\n  exact finrank_span_singleton v.rep_nonzero\n\n"}
{"name":"Projectivization.instFiniteDimensionalSubtypeMemSubmoduleSubmodule","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : Projectivization K V\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem v.submodule x)","decl":"instance (v : ℙ K V) : FiniteDimensional K v.submodule := by\n  rw [← v.mk_rep]\n  change FiniteDimensional K (K ∙ v.rep)\n  infer_instance\n\n"}
{"name":"Projectivization.submodule_injective","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\n⊢ Function.Injective Projectivization.submodule","decl":"theorem submodule_injective :\n    Function.Injective (Projectivization.submodule : ℙ K V → Submodule K V) := fun u v h ↦ by\n  induction' u using ind with u hu\n  induction' v using ind with v hv\n  rw [submodule_mk, submodule_mk, Submodule.span_singleton_eq_span_singleton] at h\n  exact ((mk_eq_mk_iff K v u hv hu).2 h).symm\n\n"}
{"name":"Projectivization.submodule_mk''","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nH : Submodule K V\nh : Eq (Module.finrank K (Subtype fun x => Membership.mem H x)) 1\n⊢ Eq (Projectivization.mk'' H h).submodule H","decl":"@[simp]\ntheorem submodule_mk'' (H : Submodule K V) (h : finrank K H = 1) : (mk'' H h).submodule = H :=\n  congr_arg Subtype.val <| (equivSubmodule K V).apply_symm_apply ⟨H, h⟩\n\n"}
{"name":"Projectivization.mk''_submodule","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : Projectivization K V\n⊢ Eq (Projectivization.mk'' v.submodule ⋯) v","decl":"@[simp]\ntheorem mk''_submodule (v : ℙ K V) : mk'' v.submodule v.finrank_submodule = v :=\n  (equivSubmodule K V).symm_apply_apply v\n\n"}
{"name":"Projectivization.map_mk","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝⁵ : DivisionRing K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\nL : Type u_3\nW : Type u_4\ninst✝² : DivisionRing L\ninst✝¹ : AddCommGroup W\ninst✝ : Module L W\nσ : RingHom K L\nf : LinearMap σ V W\nhf : Function.Injective ⇑f\nv : V\nhv : Ne v 0\n⊢ Eq (Projectivization.map f hf (Projectivization.mk K v hv)) (Projectivization.mk L (f v) ⋯)","decl":"theorem map_mk {σ : K →+* L} (f : V →ₛₗ[σ] W) (hf : Function.Injective f) (v : V) (hv : v ≠ 0) :\n    map f hf (mk K v hv) = mk L (f v) (map_zero f ▸ hf.ne hv) :=\n  rfl\n\n"}
{"name":"Projectivization.map_injective","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝⁶ : DivisionRing K\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module K V\nL : Type u_3\nW : Type u_4\ninst✝³ : DivisionRing L\ninst✝² : AddCommGroup W\ninst✝¹ : Module L W\nσ : RingHom K L\nτ : RingHom L K\ninst✝ : RingHomInvPair σ τ\nf : LinearMap σ V W\nhf : Function.Injective ⇑f\n⊢ Function.Injective (Projectivization.map f hf)","decl":"/-- Mapping with respect to a semilinear map over an isomorphism of fields yields\nan injective map on projective spaces. -/\ntheorem map_injective {σ : K →+* L} {τ : L →+* K} [RingHomInvPair σ τ] (f : V →ₛₗ[σ] W)\n    (hf : Function.Injective f) : Function.Injective (map f hf) := fun u v h ↦ by\n  induction' u using ind with u hu; induction' v using ind with v hv\n  simp only [map_mk, mk_eq_mk_iff'] at h ⊢\n  rcases h with ⟨a, ha⟩\n  refine ⟨τ a, hf ?_⟩\n  rwa [f.map_smulₛₗ, RingHomInvPair.comp_apply_eq₂]\n\n"}
{"name":"Projectivization.map_id","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\n⊢ Eq (Projectivization.map LinearMap.id ⋯) id","decl":"@[simp]\ntheorem map_id : map (LinearMap.id : V →ₗ[K] V) (LinearEquiv.refl K V).injective = id := by\n  ext ⟨v⟩\n  rfl\n\n-- Porting note: removed `@[simp]` because of unusable `hg.comp hf` in the LHS\n"}
{"name":"Projectivization.map_comp","module":"Mathlib.LinearAlgebra.Projectivization.Basic","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝⁹ : DivisionRing K\ninst✝⁸ : AddCommGroup V\ninst✝⁷ : Module K V\nL : Type u_3\nW : Type u_4\ninst✝⁶ : DivisionRing L\ninst✝⁵ : AddCommGroup W\ninst✝⁴ : Module L W\nF : Type u_5\nU : Type u_6\ninst✝³ : Field F\ninst✝² : AddCommGroup U\ninst✝¹ : Module F U\nσ : RingHom K L\nτ : RingHom L F\nγ : RingHom K F\ninst✝ : RingHomCompTriple σ τ γ\nf : LinearMap σ V W\nhf : Function.Injective ⇑f\ng : LinearMap τ W U\nhg : Function.Injective ⇑g\n⊢ Eq (Projectivization.map (g.comp f) ⋯) (Function.comp (Projectivization.map g hg) (Projectivization.map f hf))","decl":"theorem map_comp {F U : Type*} [Field F] [AddCommGroup U] [Module F U] {σ : K →+* L} {τ : L →+* F}\n    {γ : K →+* F} [RingHomCompTriple σ τ γ] (f : V →ₛₗ[σ] W) (hf : Function.Injective f)\n    (g : W →ₛₗ[τ] U) (hg : Function.Injective g) :\n    map (g.comp f) (hg.comp hf) = map g hg ∘ map f hf := by\n  ext ⟨v⟩\n  rfl\n\n"}
