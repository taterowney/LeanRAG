{"name":"Field.exists_primitive_element_of_finite_top","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Finite E\n⊢ Exists fun α => Eq (IntermediateField.adjoin F (Singleton.singleton α)) Top.top","decl":"/-- **Primitive element theorem** assuming E is finite. -/\n@[stacks 09HY \"second part\"]\ntheorem exists_primitive_element_of_finite_top [Finite E] : ∃ α : E, F⟮α⟯ = ⊤ := by\n  obtain ⟨α, hα⟩ := @IsCyclic.exists_generator Eˣ _ _\n  use α\n  rw [eq_top_iff]\n  rintro x -\n  by_cases hx : x = 0\n  · rw [hx]\n    exact F⟮α.val⟯.zero_mem\n  · obtain ⟨n, hn⟩ := Set.mem_range.mp (hα (Units.mk0 x hx))\n    rw [show x = α ^ n by norm_cast; rw [hn, Units.val_mk0]]\n    exact zpow_mem (mem_adjoin_simple_self F (E := E) ↑α) n\n\n"}
{"name":"Field.exists_primitive_element_of_finite_bot","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\ninst✝⁴ : Field F\nE : Type u_2\ninst✝³ : Field E\ninst✝² : Algebra F E\ninst✝¹ : Finite F\ninst✝ : FiniteDimensional F E\n⊢ Exists fun α => Eq (IntermediateField.adjoin F (Singleton.singleton α)) Top.top","decl":"/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem exists_primitive_element_of_finite_bot [Finite F] [FiniteDimensional F E] :\n    ∃ α : E, F⟮α⟯ = ⊤ :=\n  haveI : Finite E := Module.finite_of_finite F\n  exists_primitive_element_of_finite_top F E\n\n"}
{"name":"Field.primitive_element_inf_aux_exists_c","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Infinite F\nE : Type u_2\ninst✝ : Field E\nϕ : RingHom F E\nα β : E\nf g : Polynomial F\n⊢ Exists fun c => ∀ (α' : E), Membership.mem (Polynomial.map ϕ f).roots α' → ∀ (β' : E), Membership.mem (Polynomial.map ϕ g).roots β' → Ne (HDiv.hDiv (Neg.neg (HSub.hSub α' α)) (HSub.hSub β' β)) (ϕ c)","decl":"theorem primitive_element_inf_aux_exists_c (f g : F[X]) :\n    ∃ c : F, ∀ α' ∈ (f.map ϕ).roots, ∀ β' ∈ (g.map ϕ).roots, -(α' - α) / (β' - β) ≠ ϕ c := by\n  classical\n  let sf := (f.map ϕ).roots\n  let sg := (g.map ϕ).roots\n  classical\n  let s := (sf.bind fun α' => sg.map fun β' => -(α' - α) / (β' - β)).toFinset\n  let s' := s.preimage ϕ fun x _ y _ h => ϕ.injective h\n  obtain ⟨c, hc⟩ := Infinite.exists_not_mem_finset s'\n  simp_rw [s', s, Finset.mem_preimage, Multiset.mem_toFinset, Multiset.mem_bind, Multiset.mem_map]\n    at hc\n  push_neg at hc\n  exact ⟨c, hc⟩\n\n"}
{"name":"Field.primitive_element_inf_aux","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\ninst✝⁴ : Field F\ninst✝³ : Infinite F\nE : Type u_2\ninst✝² : Field E\nα β : E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsSeparable F E\n⊢ Exists fun γ => Eq (IntermediateField.adjoin F (Insert.insert α (Singleton.singleton β))) (IntermediateField.adjoin F (Singleton.singleton γ))","decl":"/-- This is the heart of the proof of the primitive element theorem. It shows that if `F` is\ninfinite and `α` and `β` are separable over `F` then `F⟮α, β⟯` is generated by a single element. -/\ntheorem primitive_element_inf_aux [Algebra.IsSeparable F E] : ∃ γ : E, F⟮α, β⟯ = F⟮γ⟯ := by\n  classical\n  have hα := Algebra.IsSeparable.isIntegral F α\n  have hβ := Algebra.IsSeparable.isIntegral F β\n  let f := minpoly F α\n  let g := minpoly F β\n  let ιFE := algebraMap F E\n  let ιEE' := algebraMap E (SplittingField (g.map ιFE))\n  obtain ⟨c, hc⟩ := primitive_element_inf_aux_exists_c (ιEE'.comp ιFE) (ιEE' α) (ιEE' β) f g\n  let γ := α + c • β\n  suffices β_in_Fγ : β ∈ F⟮γ⟯ by\n    use γ\n    apply le_antisymm\n    · rw [adjoin_le_iff]\n      have α_in_Fγ : α ∈ F⟮γ⟯ := by\n        rw [← add_sub_cancel_right α (c • β)]\n        exact F⟮γ⟯.sub_mem (mem_adjoin_simple_self F γ) (F⟮γ⟯.toSubalgebra.smul_mem β_in_Fγ c)\n      rintro x (rfl | rfl) <;> assumption\n    · rw [adjoin_simple_le_iff]\n      have α_in_Fαβ : α ∈ F⟮α, β⟯ := subset_adjoin F {α, β} (Set.mem_insert α {β})\n      have β_in_Fαβ : β ∈ F⟮α, β⟯ := subset_adjoin F {α, β} (Set.mem_insert_of_mem α rfl)\n      exact F⟮α, β⟯.add_mem α_in_Fαβ (F⟮α, β⟯.smul_mem β_in_Fαβ)\n  classical\n  let p := EuclideanDomain.gcd ((f.map (algebraMap F F⟮γ⟯)).comp\n    (C (AdjoinSimple.gen F γ) - (C ↑c : F⟮γ⟯[X]) * X)) (g.map (algebraMap F F⟮γ⟯))\n  let h := EuclideanDomain.gcd ((f.map ιFE).comp (C γ - C (ιFE c) * X)) (g.map ιFE)\n  have map_g_ne_zero : g.map ιFE ≠ 0 := map_ne_zero (minpoly.ne_zero hβ)\n  have h_ne_zero : h ≠ 0 :=\n    mt EuclideanDomain.gcd_eq_zero_iff.mp (not_and.mpr fun _ => map_g_ne_zero)\n  suffices p_linear : p.map (algebraMap F⟮γ⟯ E) = C h.leadingCoeff * (X - C β) by\n    have finale : β = algebraMap F⟮γ⟯ E (-p.coeff 0 / p.coeff 1) := by\n      rw [map_div₀, RingHom.map_neg, ← coeff_map, ← coeff_map, p_linear]\n      -- Porting note: had to add `-map_add` to avoid going in the wrong direction.\n      simp [mul_sub, coeff_C, mul_div_cancel_left₀ β (mt leadingCoeff_eq_zero.mp h_ne_zero),\n        -map_add]\n      -- Porting note: an alternative solution is:\n      -- simp_rw [Polynomial.coeff_C_mul, Polynomial.coeff_sub, mul_sub,\n      --   Polynomial.coeff_X_zero, Polynomial.coeff_X_one, mul_zero, mul_one, zero_sub, neg_neg,\n      --   Polynomial.coeff_C, eq_self_iff_true, Nat.one_ne_zero, if_true, if_false, mul_zero,\n      --   sub_zero, mul_div_cancel_left β (mt leadingCoeff_eq_zero.mp h_ne_zero)]\n    rw [finale]\n    exact Subtype.mem (-p.coeff 0 / p.coeff 1)\n  have h_sep : h.Separable := separable_gcd_right _ (Algebra.IsSeparable.isSeparable F β).map\n  have h_root : h.eval β = 0 := by\n    apply eval_gcd_eq_zero\n    · rw [eval_comp, eval_sub, eval_mul, eval_C, eval_C, eval_X, eval_map, ← aeval_def, ←\n        Algebra.smul_def, add_sub_cancel_right, minpoly.aeval]\n    · rw [eval_map, ← aeval_def, minpoly.aeval]\n  have h_splits : Splits ιEE' h :=\n    splits_of_splits_gcd_right ιEE' map_g_ne_zero (SplittingField.splits _)\n  have h_roots : ∀ x ∈ (h.map ιEE').roots, x = ιEE' β := by\n    intro x hx\n    rw [mem_roots_map h_ne_zero] at hx\n    specialize hc (ιEE' γ - ιEE' (ιFE c) * x) (by\n      have f_root := root_left_of_root_gcd hx\n      rw [eval₂_comp, eval₂_sub, eval₂_mul, eval₂_C, eval₂_C, eval₂_X, eval₂_map] at f_root\n      exact (mem_roots_map (minpoly.ne_zero hα)).mpr f_root)\n    specialize hc x (by\n      rw [mem_roots_map (minpoly.ne_zero hβ), ← eval₂_map]\n      exact root_right_of_root_gcd hx)\n    by_contra a\n    apply hc\n    apply (div_eq_iff (sub_ne_zero.mpr a)).mpr\n    simp only [γ, Algebra.smul_def, RingHom.map_add, RingHom.map_mul, RingHom.comp_apply]\n    ring\n  rw [← eq_X_sub_C_of_separable_of_root_eq h_sep h_root h_splits h_roots]\n  trans EuclideanDomain.gcd (?_ : E[X]) (?_ : E[X])\n  · dsimp only [γ]\n    convert (gcd_map (algebraMap F⟮γ⟯ E)).symm\n  · simp only [map_comp, Polynomial.map_map, ← IsScalarTower.algebraMap_eq, Polynomial.map_sub,\n      map_C, AdjoinSimple.algebraMap_gen, map_add, Polynomial.map_mul, map_X]\n    congr\n\n-- If `F` is infinite and `E/F` has only finitely many intermediate fields, then for any\n-- `α` and `β` in `E`, `F⟮α, β⟯` is generated by a single element.\n-- Marked as private since it's a special case of\n-- `exists_primitive_element_of_finite_intermediateField`.\n"}
{"name":"Field.exists_primitive_element","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\ninst✝¹ : FiniteDimensional F E\ninst✝ : Algebra.IsSeparable F E\n⊢ Exists fun α => Eq (IntermediateField.adjoin F (Singleton.singleton α)) Top.top","decl":"/-- **Primitive element theorem**: a finite separable field extension `E` of `F` has a\n  primitive element, i.e. there is an `α ∈ E` such that `F⟮α⟯ = (⊤ : Subalgebra F E)`. -/\n@[stacks 030N \"The moreover part\"]\ntheorem exists_primitive_element : ∃ α : E, F⟮α⟯ = ⊤ := by\n  rcases isEmpty_or_nonempty (Fintype F) with (F_inf | ⟨⟨F_finite⟩⟩)\n  · let P : IntermediateField F E → Prop := fun K => ∃ α : E, F⟮α⟯ = K\n    have base : P ⊥ := ⟨0, adjoin_zero⟩\n    have ih : ∀ (K : IntermediateField F E) (x : E), P K → P (K⟮x⟯.restrictScalars F) := by\n      intro K β hK\n      cases' hK with α hK\n      rw [← hK, adjoin_simple_adjoin_simple]\n      haveI : Infinite F := isEmpty_fintype.mp F_inf\n      cases' primitive_element_inf_aux F α β with γ hγ\n      exact ⟨γ, hγ.symm⟩\n    exact induction_on_adjoin P base ih ⊤\n  · exact exists_primitive_element_of_finite_bot F E\n\n"}
{"name":"Field.isAlgebraic_of_adjoin_eq_adjoin","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : E\nm n : Nat\nhneq : Ne m n\nheq : Eq (IntermediateField.adjoin F (Singleton.singleton (HPow.hPow α m))) (IntermediateField.adjoin F (Singleton.singleton (HPow.hPow α n)))\n⊢ IsAlgebraic F α","decl":"theorem isAlgebraic_of_adjoin_eq_adjoin {α : E} {m n : ℕ} (hneq : m ≠ n)\n    (heq : F⟮α ^ m⟯ = F⟮α ^ n⟯) : IsAlgebraic F α := by\n  wlog hmn : m < n\n  · exact this F E hneq.symm heq.symm (hneq.lt_or_lt.resolve_left hmn)\n  by_cases hm : m = 0\n  · rw [hm] at heq hmn\n    simp only [pow_zero, adjoin_one] at heq\n    obtain ⟨y, h⟩ := mem_bot.1 (heq.symm ▸ mem_adjoin_simple_self F (α ^ n))\n    refine ⟨X ^ n - C y, X_pow_sub_C_ne_zero hmn y, ?_⟩\n    simp only [map_sub, map_pow, aeval_X, aeval_C, h, sub_self]\n  obtain ⟨r, s, h⟩ := (mem_adjoin_simple_iff F _).1 (heq ▸ mem_adjoin_simple_self F (α ^ m))\n  by_cases hzero : aeval (α ^ n) s = 0\n  · simp only [hzero, div_zero, pow_eq_zero_iff hm] at h\n    exact h.symm ▸ isAlgebraic_zero\n  replace hm : 0 < m := Nat.pos_of_ne_zero hm\n  rw [eq_div_iff hzero, ← sub_eq_zero] at h\n  replace hzero : s ≠ 0 := by rintro rfl; simp only [map_zero, not_true_eq_false] at hzero\n  let f : F[X] := X ^ m * expand F n s - expand F n r\n  refine ⟨f, ?_, ?_⟩\n  · have : f.coeff (n * s.natDegree + m) ≠ 0 := by\n      have hn : 0 < n := by linarith only [hm, hmn]\n      have hndvd : ¬ n ∣ n * s.natDegree + m := by\n        rw [← Nat.dvd_add_iff_right (n.dvd_mul_right s.natDegree)]\n        exact Nat.not_dvd_of_pos_of_lt hm hmn\n      simp only [f, coeff_sub, coeff_X_pow_mul, s.coeff_expand_mul' hn, coeff_natDegree,\n        coeff_expand hn r, hndvd, ite_false, sub_zero]\n      exact leadingCoeff_ne_zero.2 hzero\n    intro h\n    simp only [h, coeff_zero, ne_eq, not_true_eq_false] at this\n  · simp only [f, map_sub, map_mul, map_pow, aeval_X, expand_aeval, h]\n\n"}
{"name":"Field.isAlgebraic_of_finite_intermediateField","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Finite (IntermediateField F E)\n⊢ Algebra.IsAlgebraic F E","decl":"theorem isAlgebraic_of_finite_intermediateField\n    [Finite (IntermediateField F E)] : Algebra.IsAlgebraic F E := ⟨fun α ↦\n  have ⟨_m, _n, hneq, heq⟩ := Finite.exists_ne_map_eq_of_infinite fun n ↦ F⟮α ^ n⟯\n  isAlgebraic_of_adjoin_eq_adjoin F E hneq heq⟩\n\n"}
{"name":"Field.FiniteDimensional.of_finite_intermediateField","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Finite (IntermediateField F E)\n⊢ FiniteDimensional F E","decl":"theorem FiniteDimensional.of_finite_intermediateField\n    [Finite (IntermediateField F E)] : FiniteDimensional F E := by\n  let IF := { K : IntermediateField F E // ∃ x, K = F⟮x⟯ }\n  have := isAlgebraic_of_finite_intermediateField F E\n  haveI : ∀ K : IF, FiniteDimensional F K.1 := fun ⟨_, x, rfl⟩ ↦ adjoin.finiteDimensional\n    (Algebra.IsIntegral.isIntegral _)\n  have hfin := finiteDimensional_iSup_of_finite (t := fun K : IF ↦ K.1)\n  have htop : ⨆ K : IF, K.1 = ⊤ := le_top.antisymm fun x _ ↦\n    le_iSup (fun K : IF ↦ K.1) ⟨F⟮x⟯, x, rfl⟩ <| mem_adjoin_simple_self F x\n  rw [htop] at hfin\n  exact topEquiv.toLinearEquiv.finiteDimensional\n\n"}
{"name":"Field.exists_primitive_element_of_finite_intermediateField","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Finite (IntermediateField F E)\nK : IntermediateField F E\n⊢ Exists fun α => Eq (IntermediateField.adjoin F (Singleton.singleton α)) K","decl":"theorem exists_primitive_element_of_finite_intermediateField\n    [Finite (IntermediateField F E)] (K : IntermediateField F E) : ∃ α : E, F⟮α⟯ = K := by\n  haveI := FiniteDimensional.of_finite_intermediateField F E\n  rcases finite_or_infinite F with (_ | _)\n  · obtain ⟨α, h⟩ := exists_primitive_element_of_finite_bot F K\n    exact ⟨α, by simpa only [lift_adjoin_simple, lift_top] using congr_arg lift h⟩\n  · apply induction_on_adjoin (fun K ↦ ∃ α : E, F⟮α⟯ = K) ⟨0, adjoin_zero⟩\n    rintro K β ⟨α, rfl⟩\n    simp_rw [adjoin_simple_adjoin_simple, eq_comm]\n    exact primitive_element_inf_aux_of_finite_intermediateField F α β\n\n"}
{"name":"Field.FiniteDimensional.of_exists_primitive_element","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsAlgebraic F E\nh : Exists fun α => Eq (IntermediateField.adjoin F (Singleton.singleton α)) Top.top\n⊢ FiniteDimensional F E","decl":"theorem FiniteDimensional.of_exists_primitive_element [Algebra.IsAlgebraic F E]\n    (h : ∃ α : E, F⟮α⟯ = ⊤) : FiniteDimensional F E := by\n  obtain ⟨α, hprim⟩ := h\n  have hfin := adjoin.finiteDimensional (Algebra.IsIntegral.isIntegral (R := F) α)\n  rw [hprim] at hfin\n  exact topEquiv.toLinearEquiv.finiteDimensional\n\n-- A finite simple extension has only finitely many intermediate fields\n"}
{"name":"Field.finite_intermediateField_of_exists_primitive_element","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsAlgebraic F E\nh : Exists fun α => Eq (IntermediateField.adjoin F (Singleton.singleton α)) Top.top\n⊢ Finite (IntermediateField F E)","decl":"theorem finite_intermediateField_of_exists_primitive_element [Algebra.IsAlgebraic F E]\n    (h : ∃ α : E, F⟮α⟯ = ⊤) : Finite (IntermediateField F E) := by\n  haveI := FiniteDimensional.of_exists_primitive_element F E h\n  obtain ⟨α, hprim⟩ := h\n  -- Let `f` be the minimal polynomial of `α ∈ E` over `F`\n  let f : F[X] := minpoly F α\n  let G := { g : E[X] // g.Monic ∧ g ∣ f.map (algebraMap F E) }\n  -- Then `f` has only finitely many monic factors\n  have hfin : Finite G := @Finite.of_fintype _ <| fintypeSubtypeMonicDvd\n    (f.map (algebraMap F E)) <| map_ne_zero (minpoly.ne_zero_of_finite F α)\n  -- If `K` is an intermediate field of `E/F`, let `g` be the minimal polynomial of `α` over `K`\n  -- which is a monic factor of `f`\n  let g : IntermediateField F E → G := fun K ↦\n    ⟨(minpoly K α).map (algebraMap K E), (minpoly.monic <| .of_finite K α).map _, by\n      convert Polynomial.map_dvd (algebraMap K E) (minpoly.dvd_map_of_isScalarTower F K α)\n      rw [Polynomial.map_map]; rfl⟩\n  -- The map `K ↦ g` is injective\n  have hinj : Function.Injective g := fun K K' heq ↦ by\n    rw [Subtype.mk.injEq] at heq\n    apply_fun fun f : E[X] ↦ adjoin F (f.coeffs : Set E) at heq\n    simpa only [adjoin_minpoly_coeff_of_exists_primitive_element F hprim] using heq\n  -- Therefore there are only finitely many intermediate fields\n  exact Finite.of_injective g hinj\n\n"}
{"name":"Field.exists_primitive_element_iff_finite_intermediateField","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Iff (And (Algebra.IsAlgebraic F E) (Exists fun α => Eq (IntermediateField.adjoin F (Singleton.singleton α)) Top.top)) (Finite (IntermediateField F E))","decl":"/-- **Steinitz theorem**: an algebraic extension `E` of `F` has a\n  primitive element (i.e. there is an `α ∈ E` such that `F⟮α⟯ = (⊤ : Subalgebra F E)`)\n  if and only if there exist only finitely many intermediate fields between `E` and `F`. -/\n@[stacks 030N \"Equivalence of (1) & (2)\"]\ntheorem exists_primitive_element_iff_finite_intermediateField :\n    (Algebra.IsAlgebraic F E ∧ ∃ α : E, F⟮α⟯ = ⊤) ↔ Finite (IntermediateField F E) :=\n  ⟨fun ⟨_, h⟩ ↦ finite_intermediateField_of_exists_primitive_element F E h,\n    fun _ ↦ ⟨isAlgebraic_of_finite_intermediateField F E,\n      exists_primitive_element_of_finite_intermediateField F E _⟩⟩\n\n"}
{"name":"AlgHom.card_of_splits","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\ninst✝³ : FiniteDimensional F E\ninst✝² : Algebra.IsSeparable F E\nL : Type u_3\ninst✝¹ : Field L\ninst✝ : Algebra F L\nhL : ∀ (x : E), Polynomial.Splits (algebraMap F L) (minpoly F x)\n⊢ Eq (Fintype.card (AlgHom F E L)) (Module.finrank F E)","decl":"@[simp]\ntheorem AlgHom.card_of_splits (L : Type*) [Field L] [Algebra F L]\n    (hL : ∀ x : E, (minpoly F x).Splits (algebraMap F L)) :\n    Fintype.card (E →ₐ[F] L) = finrank F E := by\n  convert (AlgHom.card_of_powerBasis (L := L) (Field.powerBasisOfFiniteOfSeparable F E)\n    (Algebra.IsSeparable.isSeparable _ _) <| hL _).trans\n      (PowerBasis.finrank _).symm\n\n"}
{"name":"AlgHom.card","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\ninst✝⁴ : FiniteDimensional F E\ninst✝³ : Algebra.IsSeparable F E\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : IsAlgClosed K\ninst✝ : Algebra F K\n⊢ Eq (Fintype.card (AlgHom F E K)) (Module.finrank F E)","decl":"@[simp]\ntheorem AlgHom.card (K : Type*) [Field K] [IsAlgClosed K] [Algebra F K] :\n    Fintype.card (E →ₐ[F] K) = finrank F E :=\n  AlgHom.card_of_splits _ _ _ (fun _ ↦ IsAlgClosed.splits_codomain _)\n\n"}
{"name":"Field.primitive_element_iff_minpoly_natDegree_eq","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_3\nE : Type u_4\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : FiniteDimensional F E\nα : E\n⊢ Iff (Eq (IntermediateField.adjoin F (Singleton.singleton α)) Top.top) (Eq (minpoly F α).natDegree (Module.finrank F E))","decl":"theorem primitive_element_iff_minpoly_natDegree_eq (α : E) :\n    F⟮α⟯ = ⊤ ↔ (minpoly F α).natDegree = finrank F E := by\n  rw [← adjoin.finrank (IsIntegral.of_finite F α), ← finrank_top F E]\n  refine ⟨fun h => ?_, fun h => eq_of_le_of_finrank_eq le_top h⟩\n  exact congr_arg (fun K : IntermediateField F E => finrank F K) h\n\n"}
{"name":"Field.primitive_element_iff_minpoly_degree_eq","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_3\nE : Type u_4\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : FiniteDimensional F E\nα : E\n⊢ Iff (Eq (IntermediateField.adjoin F (Singleton.singleton α)) Top.top) (Eq (minpoly F α).degree ↑(Module.finrank F E))","decl":"theorem primitive_element_iff_minpoly_degree_eq (α : E) :\n    F⟮α⟯ = ⊤ ↔ (minpoly F α).degree = finrank F E := by\n  rw [degree_eq_iff_natDegree_eq, primitive_element_iff_minpoly_natDegree_eq]\n  exact minpoly.ne_zero_of_finite F α\n\n"}
{"name":"Field.primitive_element_iff_algHom_eq_of_eval'","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_3\nE : Type u_4\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\ninst✝³ : FiniteDimensional F E\ninst✝² : Algebra.IsSeparable F E\nA : Type u_5\ninst✝¹ : Field A\ninst✝ : Algebra F A\nhA : ∀ (x : E), Polynomial.Splits (algebraMap F A) (minpoly F x)\nα : E\n⊢ Iff (Eq (IntermediateField.adjoin F (Singleton.singleton α)) Top.top) (Function.Injective fun φ => φ α)","decl":"theorem primitive_element_iff_algHom_eq_of_eval' (α : E) :\n    F⟮α⟯ = ⊤ ↔ Function.Injective fun φ : E →ₐ[F] A ↦ φ α := by\n  classical\n  simp_rw [primitive_element_iff_minpoly_natDegree_eq, ← card_rootSet_eq_natDegree (K := A)\n    (Algebra.IsSeparable.isSeparable F α) (hA _), ← toFinset_card,\n    ← (Algebra.IsAlgebraic.of_finite F E).range_eval_eq_rootSet_minpoly_of_splits _ hA α,\n    ← AlgHom.card_of_splits F E A hA, Fintype.card, toFinset_range, Finset.card_image_iff,\n    Finset.coe_univ, ← injective_iff_injOn_univ]\n\n"}
{"name":"Field.primitive_element_iff_algHom_eq_of_eval","module":"Mathlib.FieldTheory.PrimitiveElement","initialProofState":"F : Type u_3\nE : Type u_4\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\ninst✝³ : FiniteDimensional F E\ninst✝² : Algebra.IsSeparable F E\nA : Type u_5\ninst✝¹ : Field A\ninst✝ : Algebra F A\nhA : ∀ (x : E), Polynomial.Splits (algebraMap F A) (minpoly F x)\nα : E\nφ : AlgHom F E A\n⊢ Iff (Eq (IntermediateField.adjoin F (Singleton.singleton α)) Top.top) (∀ (ψ : AlgHom F E A), Eq (φ α) (ψ α) → Eq φ ψ)","decl":"theorem primitive_element_iff_algHom_eq_of_eval (α : E)\n    (φ : E →ₐ[F] A) : F⟮α⟯ = ⊤ ↔ ∀ ψ : E →ₐ[F] A, φ α = ψ α → φ = ψ := by\n  refine ⟨fun h ψ hψ ↦ (Field.primitive_element_iff_algHom_eq_of_eval' F A hA α).mp h hψ,\n    fun h ↦ eq_of_le_of_finrank_eq' le_top ?_⟩\n  letI : Algebra F⟮α⟯ A := (φ.comp F⟮α⟯.val).toAlgebra\n  haveI := Algebra.isSeparable_tower_top_of_isSeparable F F⟮α⟯ E\n  rw [IntermediateField.finrank_top, ← AlgHom.card_of_splits _ _ A, Fintype.card_eq_one_iff]\n  · exact ⟨{ __ := φ, commutes' := fun _ ↦ rfl }, fun ψ ↦ AlgHom.restrictScalars_injective F <|\n      Eq.symm <| h _ (ψ.commutes <| AdjoinSimple.gen F α).symm⟩\n  · exact fun x ↦ (IsIntegral.of_finite F x).minpoly_splits_tower_top (hA x)\n\n"}
