{"name":"Finsupp.single_apply","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\na a' : α\nb : M\ninst✝ : Decidable (Eq a a')\n⊢ Eq ((Finsupp.single a b) a') (ite (Eq a a') b 0)","decl":"theorem single_apply [Decidable (a = a')] : single a b a' = if a = a' then b else 0 := by\n  classical\n  simp_rw [@eq_comm _ a a']\n  convert Pi.single_apply a b a'\n\n"}
{"name":"Finsupp.single_apply_left","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : α → β\nhf : Function.Injective f\nx z : α\ny : M\n⊢ Eq ((Finsupp.single (f x) y) (f z)) ((Finsupp.single x y) z)","decl":"theorem single_apply_left {f : α → β} (hf : Function.Injective f) (x z : α) (y : M) :\n    single (f x) y (f z) = single x y z := by classical simp only [single_apply, hf.eq_iff]\n\n"}
{"name":"Finsupp.single_eq_set_indicator","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\nb : M\n⊢ Eq (⇑(Finsupp.single a b)) ((Singleton.singleton a).indicator fun x => b)","decl":"theorem single_eq_set_indicator : ⇑(single a b) = Set.indicator {a} fun _ => b := by\n  classical\n  ext\n  simp [single_apply, Set.indicator, @eq_comm _ a]\n\n"}
{"name":"Finsupp.single_eq_same","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\nb : M\n⊢ Eq ((Finsupp.single a b) a) b","decl":"@[simp]\ntheorem single_eq_same : (single a b : α →₀ M) a = b := by\n  classical exact Pi.single_eq_same (f := fun _ ↦ M) a b\n\n"}
{"name":"Finsupp.single_eq_of_ne","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na a' : α\nb : M\nh : Ne a a'\n⊢ Eq ((Finsupp.single a b) a') 0","decl":"@[simp]\ntheorem single_eq_of_ne (h : a ≠ a') : (single a b : α →₀ M) a' = 0 := by\n  classical exact Pi.single_eq_of_ne' h _\n\n"}
{"name":"Finsupp.single_eq_update","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : DecidableEq α\na : α\nb : M\n⊢ Eq (⇑(Finsupp.single a b)) (Function.update 0 a b)","decl":"theorem single_eq_update [DecidableEq α] (a : α) (b : M) :\n    ⇑(single a b) = Function.update (0 : _) a b := by\n  classical rw [single_eq_set_indicator, ← Set.piecewise_eq_indicator, Set.piecewise_singleton]\n\n"}
{"name":"Finsupp.single_eq_pi_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : DecidableEq α\na : α\nb : M\n⊢ Eq (⇑(Finsupp.single a b)) (Pi.single a b)","decl":"theorem single_eq_pi_single [DecidableEq α] (a : α) (b : M) : ⇑(single a b) = Pi.single a b :=\n  single_eq_update a b\n\n"}
{"name":"Finsupp.single_zero","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\n⊢ Eq (Finsupp.single a 0) 0","decl":"@[simp]\ntheorem single_zero (a : α) : (single a 0 : α →₀ M) = 0 :=\n  DFunLike.coe_injective <| by\n    classical simpa only [single_eq_update, coe_zero] using Function.update_eq_self a (0 : α → M)\n\n"}
{"name":"Finsupp.single_of_single_apply","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na a' : α\nb : M\n⊢ Eq (Finsupp.single a ((Finsupp.single a' b) a)) ((Finsupp.single a' (Finsupp.single a' b)) a)","decl":"theorem single_of_single_apply (a a' : α) (b : M) :\n    single a ((single a' b) a) = single a' (single a' b) a := by\n  classical\n  rw [single_apply, single_apply]\n  ext\n  split_ifs with h\n  · rw [h]\n  · rw [zero_apply, single_apply, ite_self]\n\n"}
{"name":"Finsupp.support_single_ne_zero","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nb : M\na : α\nhb : Ne b 0\n⊢ Eq (Finsupp.single a b).support (Singleton.singleton a)","decl":"theorem support_single_ne_zero (a : α) (hb : b ≠ 0) : (single a b).support = {a} :=\n  if_neg hb\n\n"}
{"name":"Finsupp.support_single_subset","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\nb : M\n⊢ HasSubset.Subset (Finsupp.single a b).support (Singleton.singleton a)","decl":"theorem support_single_subset : (single a b).support ⊆ {a} := by\n  classical show ite _ _ _ ⊆ _; split_ifs <;> [exact empty_subset _; exact Subset.refl _]\n\n"}
{"name":"Finsupp.single_apply_mem","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\nb : M\nx : α\n⊢ Membership.mem (Insert.insert 0 (Singleton.singleton b)) ((Finsupp.single a b) x)","decl":"theorem single_apply_mem (x) : single a b x ∈ ({0, b} : Set M) := by\n  rcases em (a = x) with (rfl | hx) <;> [simp; simp [single_eq_of_ne hx]]\n\n"}
{"name":"Finsupp.range_single_subset","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\nb : M\n⊢ HasSubset.Subset (Set.range ⇑(Finsupp.single a b)) (Insert.insert 0 (Singleton.singleton b))","decl":"theorem range_single_subset : Set.range (single a b) ⊆ {0, b} :=\n  Set.range_subset_iff.2 single_apply_mem\n\n"}
{"name":"Finsupp.single_injective","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\n⊢ Function.Injective (Finsupp.single a)","decl":"/-- `Finsupp.single a b` is injective in `b`. For the statement that it is injective in `a`, see\n`Finsupp.single_left_injective` -/\ntheorem single_injective (a : α) : Function.Injective (single a : M → α →₀ M) := fun b₁ b₂ eq => by\n  have : (single a b₁ : α →₀ M) a = (single a b₂ : α →₀ M) a := by rw [eq]\n  rwa [single_eq_same, single_eq_same] at this\n\n"}
{"name":"Finsupp.single_apply_eq_zero","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na x : α\nb : M\n⊢ Iff (Eq ((Finsupp.single a b) x) 0) (Eq x a → Eq b 0)","decl":"theorem single_apply_eq_zero {a x : α} {b : M} : single a b x = 0 ↔ x = a → b = 0 := by\n  simp [single_eq_set_indicator]\n\n"}
{"name":"Finsupp.single_apply_ne_zero","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na x : α\nb : M\n⊢ Iff (Ne ((Finsupp.single a b) x) 0) (And (Eq x a) (Ne b 0))","decl":"theorem single_apply_ne_zero {a x : α} {b : M} : single a b x ≠ 0 ↔ x = a ∧ b ≠ 0 := by\n  simp [single_apply_eq_zero]\n\n"}
{"name":"Finsupp.mem_support_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na a' : α\nb : M\n⊢ Iff (Membership.mem (Finsupp.single a' b).support a) (And (Eq a a') (Ne b 0))","decl":"theorem mem_support_single (a a' : α) (b : M) : a ∈ (single a' b).support ↔ a = a' ∧ b ≠ 0 := by\n  simp [single_apply_eq_zero, not_or]\n\n"}
{"name":"Finsupp.eq_single_iff","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\nb : M\n⊢ Iff (Eq f (Finsupp.single a b)) (And (HasSubset.Subset f.support (Singleton.singleton a)) (Eq (f a) b))","decl":"theorem eq_single_iff {f : α →₀ M} {a b} : f = single a b ↔ f.support ⊆ {a} ∧ f a = b := by\n  refine ⟨fun h => h.symm ▸ ⟨support_single_subset, single_eq_same⟩, ?_⟩\n  rintro ⟨h, rfl⟩\n  ext x\n  by_cases hx : a = x <;> simp only [hx, single_eq_same, single_eq_of_ne, Ne, not_false_iff]\n  exact not_mem_support_iff.1 (mt (fun hx => (mem_singleton.1 (h hx)).symm) hx)\n\n"}
{"name":"Finsupp.single_eq_single_iff","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na₁ a₂ : α\nb₁ b₂ : M\n⊢ Iff (Eq (Finsupp.single a₁ b₁) (Finsupp.single a₂ b₂)) (Or (And (Eq a₁ a₂) (Eq b₁ b₂)) (And (Eq b₁ 0) (Eq b₂ 0)))","decl":"theorem single_eq_single_iff (a₁ a₂ : α) (b₁ b₂ : M) :\n    single a₁ b₁ = single a₂ b₂ ↔ a₁ = a₂ ∧ b₁ = b₂ ∨ b₁ = 0 ∧ b₂ = 0 := by\n  constructor\n  · intro eq\n    by_cases h : a₁ = a₂\n    · refine Or.inl ⟨h, ?_⟩\n      rwa [h, (single_injective a₂).eq_iff] at eq\n    · rw [DFunLike.ext_iff] at eq\n      have h₁ := eq a₁\n      have h₂ := eq a₂\n      simp only [single_eq_same, single_eq_of_ne h, single_eq_of_ne (Ne.symm h)] at h₁ h₂\n      exact Or.inr ⟨h₁, h₂.symm⟩\n  · rintro (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩)\n    · rfl\n    · rw [single_zero, single_zero]\n\n"}
{"name":"Finsupp.single_left_injective","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nb : M\nh : Ne b 0\n⊢ Function.Injective fun a => Finsupp.single a b","decl":"/-- `Finsupp.single a b` is injective in `a`. For the statement that it is injective in `b`, see\n`Finsupp.single_injective` -/\ntheorem single_left_injective (h : b ≠ 0) : Function.Injective fun a : α => single a b :=\n  fun _a _a' H => (((single_eq_single_iff _ _ _ _).mp H).resolve_right fun hb => h hb.1).left\n\n"}
{"name":"Finsupp.single_left_inj","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na a' : α\nb : M\nh : Ne b 0\n⊢ Iff (Eq (Finsupp.single a b) (Finsupp.single a' b)) (Eq a a')","decl":"theorem single_left_inj (h : b ≠ 0) : single a b = single a' b ↔ a = a' :=\n  (single_left_injective h).eq_iff\n\n"}
{"name":"Finsupp.support_single_ne_bot","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nb : M\ni : α\nh : Ne b 0\n⊢ Ne (Finsupp.single i b).support Bot.bot","decl":"theorem support_single_ne_bot (i : α) (h : b ≠ 0) : (single i b).support ≠ ⊥ := by\n  simpa only [support_single_ne_zero _ h] using singleton_ne_empty _\n\n"}
{"name":"Finsupp.support_single_disjoint","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nb b' : M\nhb : Ne b 0\nhb' : Ne b' 0\ni j : α\n⊢ Iff (Disjoint (Finsupp.single i b).support (Finsupp.single j b').support) (Ne i j)","decl":"theorem support_single_disjoint {b' : M} (hb : b ≠ 0) (hb' : b' ≠ 0) {i j : α} :\n    Disjoint (single i b).support (single j b').support ↔ i ≠ j := by\n  rw [support_single_ne_zero _ hb, support_single_ne_zero _ hb', disjoint_singleton]\n\n"}
{"name":"Finsupp.single_eq_zero","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\nb : M\n⊢ Iff (Eq (Finsupp.single a b) 0) (Eq b 0)","decl":"@[simp]\ntheorem single_eq_zero : single a b = 0 ↔ b = 0 := by\n  simp [DFunLike.ext_iff, single_eq_set_indicator]\n\n"}
{"name":"Finsupp.single_swap","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na₁ a₂ : α\nb : M\n⊢ Eq ((Finsupp.single a₁ b) a₂) ((Finsupp.single a₂ b) a₁)","decl":"theorem single_swap (a₁ a₂ : α) (b : M) : single a₁ b a₂ = single a₂ b a₁ := by\n  classical simp only [single_apply, eq_comm]\n\n"}
{"name":"Finsupp.instNontrivial","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : Zero M\ninst✝¹ : Nonempty α\ninst✝ : Nontrivial M\n⊢ Nontrivial (Finsupp α M)","decl":"instance instNontrivial [Nonempty α] [Nontrivial M] : Nontrivial (α →₀ M) := by\n  inhabit α\n  rcases exists_ne (0 : M) with ⟨x, hx⟩\n  exact nontrivial_of_ne (single default x) 0 (mt single_eq_zero.1 hx)\n\n"}
{"name":"Finsupp.unique_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : Unique α\nx : Finsupp α M\n⊢ Eq x (Finsupp.single Inhabited.default (x Inhabited.default))","decl":"theorem unique_single [Unique α] (x : α →₀ M) : x = single default (x default) :=\n  ext <| Unique.forall_iff.2 single_eq_same.symm\n\n"}
{"name":"Finsupp.unique_single_eq_iff","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\na a' : α\nb : M\ninst✝ : Unique α\nb' : M\n⊢ Iff (Eq (Finsupp.single a b) (Finsupp.single a' b')) (Eq b b')","decl":"@[simp]\ntheorem unique_single_eq_iff [Unique α] {b' : M} : single a b = single a' b' ↔ b = b' := by\n  rw [Finsupp.unique_ext_iff, Unique.eq_default a, Unique.eq_default a', single_eq_same,\n    single_eq_same]\n\n"}
{"name":"Finsupp.apply_single'","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nN : Type u_7\nP : Type u_8\ninst✝¹ : Zero N\ninst✝ : Zero P\ne : N → P\nhe : Eq (e 0) 0\na : α\nn : N\nb : α\n⊢ Eq (e ((Finsupp.single a n) b)) ((Finsupp.single a (e n)) b)","decl":"lemma apply_single' [Zero N] [Zero P] (e : N → P) (he : e 0 = 0) (a : α) (n : N) (b : α) :\n    e ((single a n) b) = single a (e n) b := by\n  classical\n  simp only [single_apply]\n  split_ifs\n  · rfl\n  · exact he\n\n"}
{"name":"Finsupp.apply_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nN : Type u_7\nP : Type u_8\ninst✝³ : Zero N\ninst✝² : Zero P\nF : Type u_13\ninst✝¹ : FunLike F N P\ninst✝ : ZeroHomClass F N P\ne : F\na : α\nn : N\nb : α\n⊢ Eq (e ((Finsupp.single a n) b)) ((Finsupp.single a (e n)) b)","decl":"lemma apply_single [Zero N] [Zero P] {F : Type*} [FunLike F N P] [ZeroHomClass F N P]\n    (e : F) (a : α) (n : N) (b : α) :\n    e ((single a n) b) = single a (e n) b :=\n  apply_single' e (map_zero e) a n b\n\n"}
{"name":"Finsupp.support_eq_singleton","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\n⊢ Iff (Eq f.support (Singleton.singleton a)) (And (Ne (f a) 0) (Eq f (Finsupp.single a (f a))))","decl":"theorem support_eq_singleton {f : α →₀ M} {a : α} :\n    f.support = {a} ↔ f a ≠ 0 ∧ f = single a (f a) :=\n  ⟨fun h =>\n    ⟨mem_support_iff.1 <| h.symm ▸ Finset.mem_singleton_self a,\n      eq_single_iff.2 ⟨subset_of_eq h, rfl⟩⟩,\n    fun h => h.2.symm ▸ support_single_ne_zero _ h.1⟩\n\n"}
{"name":"Finsupp.support_eq_singleton'","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\n⊢ Iff (Eq f.support (Singleton.singleton a)) (Exists fun b => And (Ne b 0) (Eq f (Finsupp.single a b)))","decl":"theorem support_eq_singleton' {f : α →₀ M} {a : α} :\n    f.support = {a} ↔ ∃ b ≠ 0, f = single a b :=\n  ⟨fun h =>\n    let h := support_eq_singleton.1 h\n    ⟨_, h.1, h.2⟩,\n    fun ⟨_b, hb, hf⟩ => hf.symm ▸ support_single_ne_zero _ hb⟩\n\n"}
{"name":"Finsupp.card_support_eq_one","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\n⊢ Iff (Eq f.support.card 1) (Exists fun a => And (Ne (f a) 0) (Eq f (Finsupp.single a (f a))))","decl":"theorem card_support_eq_one {f : α →₀ M} :\n    #f.support = 1 ↔ ∃ a, f a ≠ 0 ∧ f = single a (f a) := by\n  simp only [card_eq_one, support_eq_singleton]\n\n"}
{"name":"Finsupp.card_support_eq_one'","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\n⊢ Iff (Eq f.support.card 1) (Exists fun a => Exists fun b => And (Ne b 0) (Eq f (Finsupp.single a b)))","decl":"theorem card_support_eq_one' {f : α →₀ M} :\n    #f.support = 1 ↔ ∃ a, ∃ b ≠ 0, f = single a b := by\n  simp only [card_eq_one, support_eq_singleton']\n\n"}
{"name":"Finsupp.support_subset_singleton","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\n⊢ Iff (HasSubset.Subset f.support (Singleton.singleton a)) (Eq f (Finsupp.single a (f a)))","decl":"theorem support_subset_singleton {f : α →₀ M} {a : α} : f.support ⊆ {a} ↔ f = single a (f a) :=\n  ⟨fun h => eq_single_iff.mpr ⟨h, rfl⟩, fun h => (eq_single_iff.mp h).left⟩\n\n"}
{"name":"Finsupp.support_subset_singleton'","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\n⊢ Iff (HasSubset.Subset f.support (Singleton.singleton a)) (Exists fun b => Eq f (Finsupp.single a b))","decl":"theorem support_subset_singleton' {f : α →₀ M} {a : α} : f.support ⊆ {a} ↔ ∃ b, f = single a b :=\n  ⟨fun h => ⟨f a, support_subset_singleton.mp h⟩, fun ⟨b, hb⟩ => by\n    rw [hb, support_subset_singleton, single_eq_same]⟩\n\n"}
{"name":"Finsupp.card_support_le_one","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : Nonempty α\nf : Finsupp α M\n⊢ Iff (LE.le f.support.card 1) (Exists fun a => Eq f (Finsupp.single a (f a)))","decl":"theorem card_support_le_one [Nonempty α] {f : α →₀ M} :\n    #f.support ≤ 1 ↔ ∃ a, f = single a (f a) := by\n  simp only [card_le_one_iff_subset_singleton, support_subset_singleton]\n\n"}
{"name":"Finsupp.card_support_le_one'","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : Nonempty α\nf : Finsupp α M\n⊢ Iff (LE.le f.support.card 1) (Exists fun a => Exists fun b => Eq f (Finsupp.single a b))","decl":"theorem card_support_le_one' [Nonempty α] {f : α →₀ M} :\n    #f.support ≤ 1 ↔ ∃ a b, f = single a b := by\n  simp only [card_le_one_iff_subset_singleton, support_subset_singleton']\n\n"}
{"name":"Finsupp.equivFunOnFinite_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : Zero M\ninst✝¹ : DecidableEq α\ninst✝ : Finite α\nx : α\nm : M\n⊢ Eq (Finsupp.equivFunOnFinite (Finsupp.single x m)) (Pi.single x m)","decl":"@[simp]\ntheorem equivFunOnFinite_single [DecidableEq α] [Finite α] (x : α) (m : M) :\n    Finsupp.equivFunOnFinite (Finsupp.single x m) = Pi.single x m := by\n  ext\n  simp [Finsupp.single_eq_pi_single, equivFunOnFinite]\n\n"}
{"name":"Finsupp.equivFunOnFinite_symm_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : Zero M\ninst✝¹ : DecidableEq α\ninst✝ : Finite α\nx : α\nm : M\n⊢ Eq (Finsupp.equivFunOnFinite.symm (Pi.single x m)) (Finsupp.single x m)","decl":"@[simp]\ntheorem equivFunOnFinite_symm_single [DecidableEq α] [Finite α] (x : α) (m : M) :\n    Finsupp.equivFunOnFinite.symm (Pi.single x m) = Finsupp.single x m := by\n  rw [← equivFunOnFinite_single, Equiv.symm_apply_apply]\n\n"}
{"name":"Finsupp.coe_update","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\nf : Finsupp α M\na : α\nb : M\ninst✝ : DecidableEq α\n⊢ Eq (⇑(f.update a b)) (Function.update (⇑f) a b)","decl":"@[simp, norm_cast]\ntheorem coe_update [DecidableEq α] : (f.update a b : α → M) = Function.update f a b := by\n  delta update Function.update\n  ext\n  dsimp\n  split_ifs <;> simp\n\n"}
{"name":"Finsupp.update_self","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\n⊢ Eq (f.update a (f a)) f","decl":"@[simp]\ntheorem update_self : f.update a (f a) = f := by\n  classical\n    ext\n    simp\n\n"}
{"name":"Finsupp.zero_update","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\nb : M\n⊢ Eq (Finsupp.update 0 a b) (Finsupp.single a b)","decl":"@[simp]\ntheorem zero_update : update 0 a b = single a b := by\n  classical\n    ext\n    rw [single_eq_update]\n    rfl\n\n"}
{"name":"Finsupp.support_update","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : Zero M\nf : Finsupp α M\na : α\nb : M\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq M\n⊢ Eq (f.update a b).support (ite (Eq b 0) (f.support.erase a) (Insert.insert a f.support))","decl":"theorem support_update [DecidableEq α] [DecidableEq M] :\n    support (f.update a b) = if b = 0 then f.support.erase a else insert a f.support := by\n  classical\n  dsimp only [update]\n  congr!\n\n"}
{"name":"Finsupp.support_update_zero","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\nf : Finsupp α M\na : α\ninst✝ : DecidableEq α\n⊢ Eq (f.update a 0).support (f.support.erase a)","decl":"@[simp]\ntheorem support_update_zero [DecidableEq α] : support (f.update a 0) = f.support.erase a := by\n  classical\n  simp only [update, ite_true, mem_support_iff, ne_eq, not_not]\n  congr!\n\n"}
{"name":"Finsupp.support_update_ne_zero","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\nf : Finsupp α M\na : α\nb : M\ninst✝ : DecidableEq α\nh : Ne b 0\n⊢ Eq (f.update a b).support (Insert.insert a f.support)","decl":"theorem support_update_ne_zero [DecidableEq α] (h : b ≠ 0) :\n    support (f.update a b) = insert a f.support := by\n  classical\n  simp only [update, h, ite_false, mem_support_iff, ne_eq]\n  congr!\n\n"}
{"name":"Finsupp.support_update_subset","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\nf : Finsupp α M\na : α\nb : M\ninst✝ : DecidableEq α\n⊢ HasSubset.Subset (f.update a b).support (Insert.insert a f.support)","decl":"theorem support_update_subset [DecidableEq α] :\n    support (f.update a b) ⊆ insert a f.support := by\n  classical\n  rw [support_update]\n  split_ifs\n  · exact (erase_subset _ _).trans (subset_insert _ _)\n  · rfl\n\n"}
{"name":"Finsupp.update_comm","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na₁ a₂ : α\nh : Ne a₁ a₂\nm₁ m₂ : M\n⊢ Eq ((f.update a₁ m₁).update a₂ m₂) ((f.update a₂ m₂).update a₁ m₁)","decl":"theorem update_comm (f : α →₀ M) {a₁ a₂ : α} (h : a₁ ≠ a₂) (m₁ m₂ : M) :\n    update (update f a₁ m₁) a₂ m₂ = update (update f a₂ m₂) a₁ m₁ :=\n  letI := Classical.decEq α\n  DFunLike.coe_injective <| Function.update_comm h _ _ _\n\n"}
{"name":"Finsupp.update_idem","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\nb c : M\n⊢ Eq ((f.update a b).update a c) (f.update a c)","decl":"@[simp] theorem update_idem (f : α →₀ M) (a : α) (b c : M) :\n    update (update f a b) a c = update f a c :=\n  letI := Classical.decEq α\n  DFunLike.coe_injective <| Function.update_idem _ _ _\n\n"}
{"name":"Finsupp.support_erase","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : DecidableEq α\na : α\nf : Finsupp α M\n⊢ Eq (Finsupp.erase a f).support (f.support.erase a)","decl":"@[simp]\ntheorem support_erase [DecidableEq α] {a : α} {f : α →₀ M} :\n    (f.erase a).support = f.support.erase a := by\n  classical\n  dsimp only [erase]\n  congr!\n\n"}
{"name":"Finsupp.erase_same","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\nf : Finsupp α M\n⊢ Eq ((Finsupp.erase a f) a) 0","decl":"@[simp]\ntheorem erase_same {a : α} {f : α →₀ M} : (f.erase a) a = 0 := by\n  classical simp only [erase, coe_mk, ite_true]\n\n"}
{"name":"Finsupp.erase_ne","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na a' : α\nf : Finsupp α M\nh : Ne a' a\n⊢ Eq ((Finsupp.erase a f) a') (f a')","decl":"@[simp]\ntheorem erase_ne {a a' : α} {f : α →₀ M} (h : a' ≠ a) : (f.erase a) a' = f a' := by\n  classical simp only [erase, coe_mk, h, ite_false]\n\n"}
{"name":"Finsupp.erase_apply","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : DecidableEq α\na a' : α\nf : Finsupp α M\n⊢ Eq ((Finsupp.erase a f) a') (ite (Eq a' a) 0 (f a'))","decl":"theorem erase_apply [DecidableEq α] {a a' : α} {f : α →₀ M} :\n    f.erase a a' = if a' = a then 0 else f a' := by\n  rw [erase, coe_mk]\n  convert rfl\n\n"}
{"name":"Finsupp.erase_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\nb : M\n⊢ Eq (Finsupp.erase a (Finsupp.single a b)) 0","decl":"@[simp]\ntheorem erase_single {a : α} {b : M} : erase a (single a b) = 0 := by\n  ext s; by_cases hs : s = a\n  · rw [hs, erase_same]\n    rfl\n  · rw [erase_ne hs]\n    exact single_eq_of_ne (Ne.symm hs)\n\n"}
{"name":"Finsupp.erase_single_ne","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na a' : α\nb : M\nh : Ne a a'\n⊢ Eq (Finsupp.erase a (Finsupp.single a' b)) (Finsupp.single a' b)","decl":"theorem erase_single_ne {a a' : α} {b : M} (h : a ≠ a') : erase a (single a' b) = single a' b := by\n  ext s; by_cases hs : s = a\n  · rw [hs, erase_same, single_eq_of_ne h.symm]\n  · rw [erase_ne hs]\n\n"}
{"name":"Finsupp.erase_of_not_mem_support","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\nhaf : Not (Membership.mem f.support a)\n⊢ Eq (Finsupp.erase a f) f","decl":"@[simp]\ntheorem erase_of_not_mem_support {f : α →₀ M} {a} (haf : a ∉ f.support) : erase a f = f := by\n  ext b; by_cases hab : b = a\n  · rwa [hab, erase_same, eq_comm, ← not_mem_support_iff]\n  · rw [erase_ne hab]\n\n"}
{"name":"Finsupp.erase_zero","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\na : α\n⊢ Eq (Finsupp.erase a 0) 0","decl":"theorem erase_zero (a : α) : erase a (0 : α →₀ M) = 0 := by\n  simp\n\n"}
{"name":"Finsupp.erase_eq_update_zero","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\n⊢ Eq (Finsupp.erase a f) (f.update a 0)","decl":"theorem erase_eq_update_zero (f : α →₀ M) (a : α) : f.erase a = update f a 0 :=\n  letI := Classical.decEq α\n  ext fun _ => (Function.update_apply _ _ _ _).symm\n\n-- The name matches `Finset.erase_insert_of_ne`\n"}
{"name":"Finsupp.erase_update_of_ne","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na a' : α\nha : Ne a a'\nb : M\n⊢ Eq (Finsupp.erase a (f.update a' b)) ((Finsupp.erase a f).update a' b)","decl":"theorem erase_update_of_ne (f : α →₀ M) {a a' : α} (ha : a ≠ a') (b : M) :\n    erase a (update f a' b) = update (erase a f) a' b := by\n  rw [erase_eq_update_zero, erase_eq_update_zero, update_comm _ ha]\n\n-- not `simp` as `erase_of_not_mem_support` can prove this\n"}
{"name":"Finsupp.erase_idem","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\n⊢ Eq (Finsupp.erase a (Finsupp.erase a f)) (Finsupp.erase a f)","decl":"theorem erase_idem (f : α →₀ M) (a : α) :\n    erase a (erase a f) = erase a f := by\n  rw [erase_eq_update_zero, erase_eq_update_zero, update_idem]\n\n"}
{"name":"Finsupp.update_erase_eq_update","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\nb : M\n⊢ Eq ((Finsupp.erase a f).update a b) (f.update a b)","decl":"@[simp] theorem update_erase_eq_update (f : α →₀ M) (a : α) (b : M) :\n    update (erase a f) a b = update f a b := by\n  rw [erase_eq_update_zero, update_idem]\n\n"}
{"name":"Finsupp.erase_update_eq_erase","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : Finsupp α M\na : α\nb : M\n⊢ Eq (Finsupp.erase a (f.update a b)) (Finsupp.erase a f)","decl":"@[simp] theorem erase_update_eq_erase (f : α →₀ M) (a : α) (b : M) :\n    erase a (update f a b) = erase a f := by\n  rw [erase_eq_update_zero, erase_eq_update_zero, update_idem]\n\n"}
{"name":"Finsupp.mapRange_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : M → N\nhf : Eq (f 0) 0\na : α\nb : M\n⊢ Eq (Finsupp.mapRange f hf (Finsupp.single a b)) (Finsupp.single a (f b))","decl":"@[simp]\ntheorem mapRange_single {f : M → N} {hf : f 0 = 0} {a : α} {b : M} :\n    mapRange f hf (single a b) = single a (f b) :=\n  ext fun a' => by\n    classical simpa only [single_eq_pi_single] using Pi.apply_single _ (fun _ => hf) a _ a'\n\n"}
{"name":"Finsupp.single_of_embDomain_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nl : Finsupp α M\nf : Function.Embedding α β\na : β\nb : M\nhb : Ne b 0\nh : Eq (Finsupp.embDomain f l) (Finsupp.single a b)\n⊢ Exists fun x => And (Eq l (Finsupp.single x b)) (Eq (f x) a)","decl":"theorem single_of_embDomain_single (l : α →₀ M) (f : α ↪ β) (a : β) (b : M) (hb : b ≠ 0)\n    (h : l.embDomain f = single a b) : ∃ x, l = single x b ∧ f x = a := by\n  classical\n    have h_map_support : Finset.map f l.support = {a} := by\n      rw [← support_embDomain, h, support_single_ne_zero _ hb]\n    have ha : a ∈ Finset.map f l.support := by simp only [h_map_support, Finset.mem_singleton]\n    rcases Finset.mem_map.1 ha with ⟨c, _hc₁, hc₂⟩\n    use c\n    constructor\n    · ext d\n      rw [← embDomain_apply f l, h]\n      by_cases h_cases : c = d\n      · simp only [Eq.symm h_cases, hc₂, single_eq_same]\n      · rw [single_apply, single_apply, if_neg, if_neg h_cases]\n        by_contra hfd\n        exact h_cases (f.injective (hc₂.trans hfd))\n    · exact hc₂\n\n"}
{"name":"Finsupp.embDomain_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Function.Embedding α β\na : α\nm : M\n⊢ Eq (Finsupp.embDomain f (Finsupp.single a m)) (Finsupp.single (f a) m)","decl":"@[simp]\ntheorem embDomain_single (f : α ↪ β) (a : α) (m : M) :\n    embDomain f (single a m) = single (f a) m := by\n  classical\n    ext b\n    by_cases h : b ∈ Set.range f\n    · rcases h with ⟨a', rfl⟩\n      simp [single_apply]\n    · simp only [embDomain_notin_range, h, single_apply, not_false_iff]\n      rw [if_neg]\n      rintro rfl\n      simp at h\n\n"}
{"name":"Finsupp.zipWith_single_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\nP : Type u_8\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\nf : M → N → P\nhf : Eq (f 0 0) 0\na : α\nm : M\nn : N\n⊢ Eq (Finsupp.zipWith f hf (Finsupp.single a m) (Finsupp.single a n)) (Finsupp.single a (f m n))","decl":"@[simp]\ntheorem zipWith_single_single (f : M → N → P) (hf : f 0 0 = 0) (a : α) (m : M) (n : N) :\n    zipWith f hf (single a m) (single a n) = single a (f m n) := by\n  ext a'\n  rw [zipWith_apply]\n  obtain rfl | ha' := eq_or_ne a a'\n  · rw [single_eq_same, single_eq_same, single_eq_same]\n  · rw [single_eq_of_ne ha', single_eq_of_ne ha', single_eq_of_ne ha', hf]\n\n"}
{"name":"Finsupp.single_add","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\na : α\nb₁ b₂ : M\n⊢ Eq (Finsupp.single a (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (Finsupp.single a b₁) (Finsupp.single a b₂))","decl":"@[simp]\ntheorem single_add (a : α) (b₁ b₂ : M) : single a (b₁ + b₂) = single a b₁ + single a b₂ :=\n  (zipWith_single_single _ _ _ _ _).symm\n\n"}
{"name":"Finsupp.support_single_add","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\na : α\nb : M\nf : Finsupp α M\nha : Not (Membership.mem f.support a)\nhb : Ne b 0\n⊢ Eq (HAdd.hAdd (Finsupp.single a b) f).support (Finset.cons a f.support ha)","decl":"theorem support_single_add {a : α} {b : M} {f : α →₀ M} (ha : a ∉ f.support) (hb : b ≠ 0) :\n    support (single a b + f) = cons a f.support ha := by\n  classical\n  have H := support_single_ne_zero a hb\n  rw [support_add_eq, H, cons_eq_insert, insert_eq]\n  rwa [H, disjoint_singleton_left]\n\n"}
{"name":"Finsupp.support_add_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\na : α\nb : M\nf : Finsupp α M\nha : Not (Membership.mem f.support a)\nhb : Ne b 0\n⊢ Eq (HAdd.hAdd f (Finsupp.single a b)).support (Finset.cons a f.support ha)","decl":"theorem support_add_single {a : α} {b : M} {f : α →₀ M} (ha : a ∉ f.support) (hb : b ≠ 0) :\n    support (f + single a b) = cons a f.support ha := by\n  classical\n  have H := support_single_ne_zero a hb\n  rw [support_add_eq, H, union_comm, cons_eq_insert, insert_eq]\n  rwa [H, disjoint_singleton_right]\n\n"}
{"name":"AddEquiv.finsuppUnique_symm","module":"Mathlib.Data.Finsupp.Single","initialProofState":"M : Type u_13\ninst✝ : AddZeroClass M\nd : M\n⊢ Eq (AddEquiv.finsuppUnique.symm d) (Finsupp.single Unit.unit d)","decl":"lemma _root_.AddEquiv.finsuppUnique_symm {M : Type*} [AddZeroClass M] (d : M) :\n    AddEquiv.finsuppUnique.symm d = single () d := by\n  rw [Finsupp.unique_single (AddEquiv.finsuppUnique.symm d), Finsupp.unique_single_eq_iff]\n  simp [AddEquiv.finsuppUnique]\n\n"}
{"name":"Finsupp.singleAddHom_apply","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\na : α\nb : M\n⊢ Eq ((Finsupp.singleAddHom a) b) (Finsupp.single a b)","decl":"/-- `Finsupp.single` as an `AddMonoidHom`.\n\nSee `Finsupp.lsingle` in `LinearAlgebra/Finsupp` for the stronger version as a linear map. -/\n@[simps]\ndef singleAddHom (a : α) : M →+ α →₀ M where\n  toFun := single a\n  map_zero' := single_zero a\n  map_add' := single_add a\n\n"}
{"name":"Finsupp.update_eq_single_add_erase","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\nf : Finsupp α M\na : α\nb : M\n⊢ Eq (f.update a b) (HAdd.hAdd (Finsupp.single a b) (Finsupp.erase a f))","decl":"theorem update_eq_single_add_erase (f : α →₀ M) (a : α) (b : M) :\n    f.update a b = single a b + f.erase a := by\n  classical\n    ext j\n    rcases eq_or_ne a j with (rfl | h)\n    · simp\n    · simp [Function.update_of_ne h.symm, single_apply, h, erase_ne, h.symm]\n\n"}
{"name":"Finsupp.update_eq_erase_add_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\nf : Finsupp α M\na : α\nb : M\n⊢ Eq (f.update a b) (HAdd.hAdd (Finsupp.erase a f) (Finsupp.single a b))","decl":"theorem update_eq_erase_add_single (f : α →₀ M) (a : α) (b : M) :\n    f.update a b = f.erase a + single a b := by\n  classical\n    ext j\n    rcases eq_or_ne a j with (rfl | h)\n    · simp\n    · simp [Function.update_of_ne h.symm, single_apply, h, erase_ne, h.symm]\n\n"}
{"name":"Finsupp.single_add_erase","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\na : α\nf : Finsupp α M\n⊢ Eq (HAdd.hAdd (Finsupp.single a (f a)) (Finsupp.erase a f)) f","decl":"theorem single_add_erase (a : α) (f : α →₀ M) : single a (f a) + f.erase a = f := by\n  rw [← update_eq_single_add_erase, update_self]\n\n"}
{"name":"Finsupp.erase_add_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\na : α\nf : Finsupp α M\n⊢ Eq (HAdd.hAdd (Finsupp.erase a f) (Finsupp.single a (f a))) f","decl":"theorem erase_add_single (a : α) (f : α →₀ M) : f.erase a + single a (f a) = f := by\n  rw [← update_eq_erase_add_single, update_self]\n\n"}
{"name":"Finsupp.erase_add","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\na : α\nf f' : Finsupp α M\n⊢ Eq (Finsupp.erase a (HAdd.hAdd f f')) (HAdd.hAdd (Finsupp.erase a f) (Finsupp.erase a f'))","decl":"@[simp]\ntheorem erase_add (a : α) (f f' : α →₀ M) : erase a (f + f') = erase a f + erase a f' := by\n  ext s; by_cases hs : s = a\n  · rw [hs, add_apply, erase_same, erase_same, erase_same, add_zero]\n  rw [add_apply, erase_ne hs, erase_ne hs, erase_ne hs, add_apply]\n\n"}
{"name":"Finsupp.eraseAddHom_apply","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\na : α\nf : Finsupp α M\n⊢ Eq ((Finsupp.eraseAddHom a) f) (Finsupp.erase a f)","decl":"/-- `Finsupp.erase` as an `AddMonoidHom`. -/\n@[simps]\ndef eraseAddHom (a : α) : (α →₀ M) →+ α →₀ M where\n  toFun := erase a\n  map_zero' := erase_zero a\n  map_add' := erase_add a\n\n"}
{"name":"Finsupp.induction","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\np : Finsupp α M → Prop\nf : Finsupp α M\nh0 : p 0\nha : ∀ (a : α) (b : M) (f : Finsupp α M), Not (Membership.mem f.support a) → Ne b 0 → p f → p (HAdd.hAdd (Finsupp.single a b) f)\n⊢ p f","decl":"@[elab_as_elim]\nprotected theorem induction {p : (α →₀ M) → Prop} (f : α →₀ M) (h0 : p 0)\n    (ha : ∀ (a b) (f : α →₀ M), a ∉ f.support → b ≠ 0 → p f → p (single a b + f)) : p f :=\n  suffices ∀ (s) (f : α →₀ M), f.support = s → p f from this _ _ rfl\n  fun s =>\n  Finset.cons_induction_on s (fun f hf => by rwa [support_eq_empty.1 hf]) fun a s has ih f hf => by\n    suffices p (single a (f a) + f.erase a) by rwa [single_add_erase] at this\n    classical\n      apply ha\n      · rw [support_erase, mem_erase]\n        exact fun H => H.1 rfl\n      · rw [← mem_support_iff, hf]\n        exact mem_cons_self _ _\n      · apply ih _ _\n        rw [support_erase, hf, Finset.erase_cons]\n\n"}
{"name":"Finsupp.induction₂","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\np : Finsupp α M → Prop\nf : Finsupp α M\nh0 : p 0\nha : ∀ (a : α) (b : M) (f : Finsupp α M), Not (Membership.mem f.support a) → Ne b 0 → p f → p (HAdd.hAdd f (Finsupp.single a b))\n⊢ p f","decl":"theorem induction₂ {p : (α →₀ M) → Prop} (f : α →₀ M) (h0 : p 0)\n    (ha : ∀ (a b) (f : α →₀ M), a ∉ f.support → b ≠ 0 → p f → p (f + single a b)) : p f :=\n  suffices ∀ (s) (f : α →₀ M), f.support = s → p f from this _ _ rfl\n  fun s =>\n  Finset.cons_induction_on s (fun f hf => by rwa [support_eq_empty.1 hf]) fun a s has ih f hf => by\n    suffices p (f.erase a + single a (f a)) by rwa [erase_add_single] at this\n    classical\n      apply ha\n      · rw [support_erase, mem_erase]\n        exact fun H => H.1 rfl\n      · rw [← mem_support_iff, hf]\n        exact mem_cons_self _ _\n      · apply ih _ _\n        rw [support_erase, hf, Finset.erase_cons]\n\n"}
{"name":"Finsupp.induction_linear","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\np : Finsupp α M → Prop\nf : Finsupp α M\nh0 : p 0\nhadd : ∀ (f g : Finsupp α M), p f → p g → p (HAdd.hAdd f g)\nhsingle : ∀ (a : α) (b : M), p (Finsupp.single a b)\n⊢ p f","decl":"theorem induction_linear {p : (α →₀ M) → Prop} (f : α →₀ M) (h0 : p 0)\n    (hadd : ∀ f g : α →₀ M, p f → p g → p (f + g)) (hsingle : ∀ a b, p (single a b)) : p f :=\n  induction₂ f h0 fun _a _b _f _ _ w => hadd _ _ w (hsingle _ _)\n\n"}
{"name":"Finsupp.induction_on_max","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : LinearOrder α\np : Finsupp α M → Prop\nf : Finsupp α M\nh0 : p 0\nha : ∀ (a : α) (b : M) (f : Finsupp α M), (∀ (c : α), Membership.mem f.support c → LT.lt c a) → Ne b 0 → p f → p (HAdd.hAdd (Finsupp.single a b) f)\n⊢ p f","decl":"/-- A finitely supported function can be built by adding up `single a b` for increasing `a`.\n\nThe theorem `induction_on_max₂` swaps the argument order in the sum. -/\ntheorem induction_on_max (f : α →₀ M) (h0 : p 0)\n    (ha : ∀ (a b) (f : α →₀ M), (∀ c ∈ f.support, c < a) → b ≠ 0 → p f → p (single a b + f)) :\n    p f := by\n  suffices ∀ (s) (f : α →₀ M), f.support = s → p f from this _ _ rfl\n  refine fun s => s.induction_on_max (fun f h => ?_) (fun a s hm hf f hs => ?_)\n  · rwa [support_eq_empty.1 h]\n  · have hs' : (erase a f).support = s := by\n      rw [support_erase, hs, erase_insert (fun ha => (hm a ha).false)]\n    rw [← single_add_erase a f]\n    refine ha _ _ _ (fun c hc => hm _ <| hs'.symm ▸ hc) ?_ (hf _ hs')\n    rw [← mem_support_iff, hs]\n    exact mem_insert_self a s\n\n"}
{"name":"Finsupp.induction_on_min","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : LinearOrder α\np : Finsupp α M → Prop\nf : Finsupp α M\nh0 : p 0\nha : ∀ (a : α) (b : M) (f : Finsupp α M), (∀ (c : α), Membership.mem f.support c → LT.lt a c) → Ne b 0 → p f → p (HAdd.hAdd (Finsupp.single a b) f)\n⊢ p f","decl":"/-- A finitely supported function can be built by adding up `single a b` for decreasing `a`.\n\nThe theorem `induction_on_min₂` swaps the argument order in the sum. -/\ntheorem induction_on_min (f : α →₀ M) (h0 : p 0)\n    (ha : ∀ (a b) (f : α →₀ M), (∀ c ∈ f.support, a < c) → b ≠ 0 → p f → p (single a b + f)) :\n    p f :=\n  induction_on_max (α := αᵒᵈ) f h0 ha\n\n"}
{"name":"Finsupp.induction_on_max₂","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : LinearOrder α\np : Finsupp α M → Prop\nf : Finsupp α M\nh0 : p 0\nha : ∀ (a : α) (b : M) (f : Finsupp α M), (∀ (c : α), Membership.mem f.support c → LT.lt c a) → Ne b 0 → p f → p (HAdd.hAdd f (Finsupp.single a b))\n⊢ p f","decl":"/-- A finitely supported function can be built by adding up `single a b` for increasing `a`.\n\nThe theorem `induction_on_max` swaps the argument order in the sum. -/\ntheorem induction_on_max₂ (f : α →₀ M) (h0 : p 0)\n    (ha : ∀ (a b) (f : α →₀ M), (∀ c ∈ f.support, c < a) → b ≠ 0 → p f → p (f + single a b)) :\n    p f := by\n  suffices ∀ (s) (f : α →₀ M), f.support = s → p f from this _ _ rfl\n  refine fun s => s.induction_on_max (fun f h => ?_) (fun a s hm hf f hs => ?_)\n  · rwa [support_eq_empty.1 h]\n  · have hs' : (erase a f).support = s := by\n      rw [support_erase, hs, erase_insert (fun ha => (hm a ha).false)]\n    rw [← erase_add_single a f]\n    refine ha _ _ _ (fun c hc => hm _ <| hs'.symm ▸ hc) ?_ (hf _ hs')\n    rw [← mem_support_iff, hs]\n    exact mem_insert_self a s\n\n"}
{"name":"Finsupp.induction_on_min₂","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : LinearOrder α\np : Finsupp α M → Prop\nf : Finsupp α M\nh0 : p 0\nha : ∀ (a : α) (b : M) (f : Finsupp α M), (∀ (c : α), Membership.mem f.support c → LT.lt a c) → Ne b 0 → p f → p (HAdd.hAdd f (Finsupp.single a b))\n⊢ p f","decl":"/-- A finitely supported function can be built by adding up `single a b` for decreasing `a`.\n\nThe theorem `induction_on_min` swaps the argument order in the sum. -/\ntheorem induction_on_min₂ (f : α →₀ M) (h0 : p 0)\n    (ha : ∀ (a b) (f : α →₀ M), (∀ c ∈ f.support, a < c) → b ≠ 0 → p f → p (f + single a b)) :\n    p f :=\n  induction_on_max₂ (α := αᵒᵈ) f h0 ha\n\n"}
{"name":"Finsupp.single_add_single_eq_single_add_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddCommMonoid M\nk l m n : α\nu v : M\nhu : Ne u 0\nhv : Ne v 0\n⊢ Iff (Eq (HAdd.hAdd (Finsupp.single k u) (Finsupp.single l v)) (HAdd.hAdd (Finsupp.single m u) (Finsupp.single n v))) (Or (And (Eq k m) (Eq l n)) (Or (And (Eq u v) (And (Eq k n) (Eq l m))) (And (Eq (HAdd.hAdd u v) 0) (And (Eq k l) (Eq m n)))))","decl":"theorem single_add_single_eq_single_add_single [AddCommMonoid M] {k l m n : α} {u v : M}\n    (hu : u ≠ 0) (hv : v ≠ 0) :\n    single k u + single l v = single m u + single n v ↔\n      (k = m ∧ l = n) ∨ (u = v ∧ k = n ∧ l = m) ∨ (u + v = 0 ∧ k = l ∧ m = n) := by\n  classical\n    simp_rw [DFunLike.ext_iff, coe_add, single_eq_pi_single, ← funext_iff]\n    exact Pi.single_add_single_eq_single_add_single hu hv\n\n"}
{"name":"Finsupp.erase_eq_sub_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : AddGroup G\nf : Finsupp α G\na : α\n⊢ Eq (Finsupp.erase a f) (HSub.hSub f (Finsupp.single a (f a)))","decl":"theorem erase_eq_sub_single [AddGroup G] (f : α →₀ G) (a : α) : f.erase a = f - single a (f a) := by\n  ext a'\n  rcases eq_or_ne a a' with (rfl | h)\n  · simp\n  · simp [erase_ne h.symm, single_eq_of_ne h]\n\n"}
{"name":"Finsupp.update_eq_sub_add_single","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : AddGroup G\nf : Finsupp α G\na : α\nb : G\n⊢ Eq (f.update a b) (HAdd.hAdd (HSub.hSub f (Finsupp.single a (f a))) (Finsupp.single a b))","decl":"theorem update_eq_sub_add_single [AddGroup G] (f : α →₀ G) (a : α) (b : G) :\n    f.update a b = f - single a (f a) + single a b := by\n  rw [update_eq_erase_add_single, erase_eq_sub_single]\n\n"}
{"name":"Finsupp.single_neg","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : AddGroup G\na : α\nb : G\n⊢ Eq (Finsupp.single a (Neg.neg b)) (Neg.neg (Finsupp.single a b))","decl":"@[simp]\ntheorem single_neg (a : α) (b : G) : single a (-b) = -single a b :=\n  (singleAddHom a : G →+ _).map_neg b\n\n"}
{"name":"Finsupp.single_sub","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : AddGroup G\na : α\nb₁ b₂ : G\n⊢ Eq (Finsupp.single a (HSub.hSub b₁ b₂)) (HSub.hSub (Finsupp.single a b₁) (Finsupp.single a b₂))","decl":"@[simp]\ntheorem single_sub (a : α) (b₁ b₂ : G) : single a (b₁ - b₂) = single a b₁ - single a b₂ :=\n  (singleAddHom a : G →+ _).map_sub b₁ b₂\n\n"}
{"name":"Finsupp.erase_neg","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : AddGroup G\na : α\nf : Finsupp α G\n⊢ Eq (Finsupp.erase a (Neg.neg f)) (Neg.neg (Finsupp.erase a f))","decl":"@[simp]\ntheorem erase_neg (a : α) (f : α →₀ G) : erase a (-f) = -erase a f :=\n  (eraseAddHom a : (_ →₀ G) →+ _).map_neg f\n\n"}
{"name":"Finsupp.erase_sub","module":"Mathlib.Data.Finsupp.Single","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : AddGroup G\na : α\nf₁ f₂ : Finsupp α G\n⊢ Eq (Finsupp.erase a (HSub.hSub f₁ f₂)) (HSub.hSub (Finsupp.erase a f₁) (Finsupp.erase a f₂))","decl":"@[simp]\ntheorem erase_sub (a : α) (f₁ f₂ : α →₀ G) : erase a (f₁ - f₂) = erase a f₁ - erase a f₂ :=\n  (eraseAddHom a : (_ →₀ G) →+ _).map_sub f₁ f₂\n\n"}
