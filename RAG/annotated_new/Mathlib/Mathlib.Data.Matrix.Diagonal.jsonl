{"name":"Matrix.diagonal_apply","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\nd : n → α\ni j : n\n⊢ Eq (Matrix.diagonal d i j) (ite (Eq i j) (d i) 0)","decl":"theorem diagonal_apply [Zero α] (d : n → α) (i j) : diagonal d i j = if i = j then d i else 0 :=\n  rfl\n\n"}
{"name":"Matrix.diagonal_apply_eq","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\nd : n → α\ni : n\n⊢ Eq (Matrix.diagonal d i i) (d i)","decl":"@[simp]\ntheorem diagonal_apply_eq [Zero α] (d : n → α) (i : n) : (diagonal d) i i = d i := by\n  simp [diagonal]\n\n"}
{"name":"Matrix.diagonal_apply_ne","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\nd : n → α\ni j : n\nh : Ne i j\n⊢ Eq (Matrix.diagonal d i j) 0","decl":"@[simp]\ntheorem diagonal_apply_ne [Zero α] (d : n → α) {i j : n} (h : i ≠ j) : (diagonal d) i j = 0 := by\n  simp [diagonal, h]\n\n"}
{"name":"Matrix.diagonal_apply_ne'","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\nd : n → α\ni j : n\nh : Ne j i\n⊢ Eq (Matrix.diagonal d i j) 0","decl":"theorem diagonal_apply_ne' [Zero α] (d : n → α) {i j : n} (h : j ≠ i) : (diagonal d) i j = 0 :=\n  diagonal_apply_ne d h.symm\n\n"}
{"name":"Matrix.diagonal_eq_diagonal_iff","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\nd₁ d₂ : n → α\n⊢ Iff (Eq (Matrix.diagonal d₁) (Matrix.diagonal d₂)) (∀ (i : n), Eq (d₁ i) (d₂ i))","decl":"@[simp]\ntheorem diagonal_eq_diagonal_iff [Zero α] {d₁ d₂ : n → α} :\n    diagonal d₁ = diagonal d₂ ↔ ∀ i, d₁ i = d₂ i :=\n  ⟨fun h i => by simpa using congr_arg (fun m : Matrix n n α => m i i) h, fun h => by\n    rw [show d₁ = d₂ from funext h]⟩\n\n"}
{"name":"Matrix.diagonal_injective","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\n⊢ Function.Injective Matrix.diagonal","decl":"theorem diagonal_injective [Zero α] : Function.Injective (diagonal : (n → α) → Matrix n n α) :=\n  fun d₁ d₂ h => funext fun i => by simpa using Matrix.ext_iff.mpr h i i\n\n"}
{"name":"Matrix.diagonal_zero","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\n⊢ Eq (Matrix.diagonal fun x => 0) 0","decl":"@[simp]\ntheorem diagonal_zero [Zero α] : (diagonal fun _ => 0 : Matrix n n α) = 0 := by\n  ext\n  simp [diagonal]\n\n"}
{"name":"Matrix.diagonal_transpose","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\nv : n → α\n⊢ Eq (Matrix.diagonal v).transpose (Matrix.diagonal v)","decl":"@[simp]\ntheorem diagonal_transpose [Zero α] (v : n → α) : (diagonal v)ᵀ = diagonal v := by\n  ext i j\n  by_cases h : i = j\n  · simp [h, transpose]\n  · simp [h, transpose, diagonal_apply_ne' _ h]\n\n"}
{"name":"Matrix.diagonal_add","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : AddZeroClass α\nd₁ d₂ : n → α\n⊢ Eq (HAdd.hAdd (Matrix.diagonal d₁) (Matrix.diagonal d₂)) (Matrix.diagonal fun i => HAdd.hAdd (d₁ i) (d₂ i))","decl":"@[simp]\ntheorem diagonal_add [AddZeroClass α] (d₁ d₂ : n → α) :\n    diagonal d₁ + diagonal d₂ = diagonal fun i => d₁ i + d₂ i := by\n  ext i j\n  by_cases h : i = j <;>\n  simp [h]\n\n"}
{"name":"Matrix.diagonal_smul","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nR : Type u_7\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : SMulZeroClass R α\nr : R\nd : n → α\n⊢ Eq (Matrix.diagonal (HSMul.hSMul r d)) (HSMul.hSMul r (Matrix.diagonal d))","decl":"@[simp]\ntheorem diagonal_smul [Zero α] [SMulZeroClass R α] (r : R) (d : n → α) :\n    diagonal (r • d) = r • diagonal d := by\n  ext i j\n  by_cases h : i = j <;> simp [h]\n\n"}
{"name":"Matrix.diagonal_neg","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : NegZeroClass α\nd : n → α\n⊢ Eq (Neg.neg (Matrix.diagonal d)) (Matrix.diagonal fun i => Neg.neg (d i))","decl":"@[simp]\ntheorem diagonal_neg [NegZeroClass α] (d : n → α) :\n    -diagonal d = diagonal fun i => -d i := by\n  ext i j\n  by_cases h : i = j <;>\n  simp [h]\n\n"}
{"name":"Matrix.diagonal_sub","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : SubNegZeroMonoid α\nd₁ d₂ : n → α\n⊢ Eq (HSub.hSub (Matrix.diagonal d₁) (Matrix.diagonal d₂)) (Matrix.diagonal fun i => HSub.hSub (d₁ i) (d₂ i))","decl":"@[simp]\ntheorem diagonal_sub [SubNegZeroMonoid α] (d₁ d₂ : n → α) :\n    diagonal d₁ - diagonal d₂ = diagonal fun i => d₁ i - d₂ i := by\n  ext i j\n  by_cases h : i = j <;>\n  simp [h]\n\n"}
{"name":"Matrix.diagonal_natCast","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : NatCast α\nm : Nat\n⊢ Eq (Matrix.diagonal fun x => ↑m) ↑m","decl":"@[norm_cast]\ntheorem diagonal_natCast [Zero α] [NatCast α] (m : ℕ) : diagonal (fun _ : n => (m : α)) = m := rfl\n\n"}
{"name":"Matrix.diagonal_natCast'","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : NatCast α\nm : Nat\n⊢ Eq (Matrix.diagonal ↑m) ↑m","decl":"@[norm_cast]\ntheorem diagonal_natCast' [Zero α] [NatCast α] (m : ℕ) : diagonal ((m : n → α)) = m := rfl\n\n"}
{"name":"Matrix.diagonal_ofNat","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝³ : DecidableEq n\ninst✝² : Zero α\ninst✝¹ : NatCast α\nm : Nat\ninst✝ : m.AtLeastTwo\n⊢ Eq (Matrix.diagonal fun x => OfNat.ofNat m) (OfNat.ofNat m)","decl":"theorem diagonal_ofNat [Zero α] [NatCast α] (m : ℕ) [m.AtLeastTwo] :\n    diagonal (fun _ : n => (ofNat(m) : α)) = OfNat.ofNat m := rfl\n\n"}
{"name":"Matrix.diagonal_ofNat'","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝³ : DecidableEq n\ninst✝² : Zero α\ninst✝¹ : NatCast α\nm : Nat\ninst✝ : m.AtLeastTwo\n⊢ Eq (Matrix.diagonal (OfNat.ofNat m)) (OfNat.ofNat m)","decl":"theorem diagonal_ofNat' [Zero α] [NatCast α] (m : ℕ) [m.AtLeastTwo] :\n    diagonal (ofNat(m) : n → α) = OfNat.ofNat m := rfl\n\n"}
{"name":"Matrix.diagonal_intCast","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : IntCast α\nm : Int\n⊢ Eq (Matrix.diagonal fun x => ↑m) ↑m","decl":"@[norm_cast]\ntheorem diagonal_intCast [Zero α] [IntCast α] (m : ℤ) : diagonal (fun _ : n => (m : α)) = m := rfl\n\n"}
{"name":"Matrix.diagonal_intCast'","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : IntCast α\nm : Int\n⊢ Eq (Matrix.diagonal ↑m) ↑m","decl":"@[norm_cast]\ntheorem diagonal_intCast' [Zero α] [IntCast α] (m : ℤ) : diagonal ((m : n → α)) = m := rfl\n\n"}
{"name":"Matrix.diagonal_map","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\nβ : Type w\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : Zero β\nf : α → β\nh : Eq (f 0) 0\nd : n → α\n⊢ Eq ((Matrix.diagonal d).map f) (Matrix.diagonal fun m => f (d m))","decl":"@[simp]\ntheorem diagonal_map [Zero α] [Zero β] {f : α → β} (h : f 0 = 0) {d : n → α} :\n    (diagonal d).map f = diagonal fun m => f (d m) := by\n  ext\n  simp only [diagonal_apply, map_apply]\n  split_ifs <;> simp [h]\n\n"}
{"name":"Matrix.map_natCast","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\nβ : Type w\ninst✝² : DecidableEq n\ninst✝¹ : AddMonoidWithOne α\ninst✝ : AddMonoidWithOne β\nf : α → β\nh : Eq (f 0) 0\nd : Nat\n⊢ Eq ((↑d).map f) (Matrix.diagonal fun x => f ↑d)","decl":"protected theorem map_natCast [AddMonoidWithOne α] [AddMonoidWithOne β]\n    {f : α → β} (h : f 0 = 0) (d : ℕ) :\n    (d : Matrix n n α).map f = diagonal (fun _ => f d) :=\n  diagonal_map h\n\n"}
{"name":"Matrix.map_ofNat","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\nβ : Type w\ninst✝³ : DecidableEq n\ninst✝² : AddMonoidWithOne α\ninst✝¹ : AddMonoidWithOne β\nf : α → β\nh : Eq (f 0) 0\nd : Nat\ninst✝ : d.AtLeastTwo\n⊢ Eq ((OfNat.ofNat d).map f) (Matrix.diagonal fun x => f (OfNat.ofNat d))","decl":"protected theorem map_ofNat [AddMonoidWithOne α] [AddMonoidWithOne β]\n    {f : α → β} (h : f 0 = 0) (d : ℕ) [d.AtLeastTwo] :\n    (ofNat(d) : Matrix n n α).map f = diagonal (fun _ => f (OfNat.ofNat d)) :=\n  diagonal_map h\n\n"}
{"name":"Matrix.map_intCast","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\nβ : Type w\ninst✝² : DecidableEq n\ninst✝¹ : AddGroupWithOne α\ninst✝ : AddGroupWithOne β\nf : α → β\nh : Eq (f 0) 0\nd : Int\n⊢ Eq ((↑d).map f) (Matrix.diagonal fun x => f ↑d)","decl":"protected theorem map_intCast [AddGroupWithOne α] [AddGroupWithOne β]\n    {f : α → β} (h : f 0 = 0) (d : ℤ) :\n    (d : Matrix n n α).map f = diagonal (fun _ => f d) :=\n  diagonal_map h\n\n"}
{"name":"Matrix.diagonal_unique","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Unique m\ninst✝¹ : DecidableEq m\ninst✝ : Zero α\nd : m → α\n⊢ Eq (Matrix.diagonal d) (Matrix.of fun x x => d Inhabited.default)","decl":"theorem diagonal_unique [Unique m] [DecidableEq m] [Zero α] (d : m → α) :\n    diagonal d = of fun _ _ => d default := by\n  ext i j\n  rw [Subsingleton.elim i default, Subsingleton.elim j default, diagonal_apply_eq _ _, of_apply]\n\n"}
{"name":"Matrix.diagonal_one","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ Eq (Matrix.diagonal fun x => 1) 1","decl":"@[simp]\ntheorem diagonal_one : (diagonal fun _ => 1 : Matrix n n α) = 1 :=\n  rfl\n\n"}
{"name":"Matrix.one_apply","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\ni j : n\n⊢ Eq (1 i j) (ite (Eq i j) 1 0)","decl":"theorem one_apply {i j} : (1 : Matrix n n α) i j = if i = j then 1 else 0 :=\n  rfl\n\n"}
{"name":"Matrix.one_apply_eq","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\ni : n\n⊢ Eq (1 i i) 1","decl":"@[simp]\ntheorem one_apply_eq (i) : (1 : Matrix n n α) i i = 1 :=\n  diagonal_apply_eq _ i\n\n"}
{"name":"Matrix.one_apply_ne","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\ni j : n\na✝ : Ne i j\n⊢ Eq (1 i j) 0","decl":"@[simp]\ntheorem one_apply_ne {i j} : i ≠ j → (1 : Matrix n n α) i j = 0 :=\n  diagonal_apply_ne _\n\n"}
{"name":"Matrix.one_apply_ne'","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\ni j : n\na✝ : Ne j i\n⊢ Eq (1 i j) 0","decl":"theorem one_apply_ne' {i j} : j ≠ i → (1 : Matrix n n α) i j = 0 :=\n  diagonal_apply_ne' _\n\n"}
{"name":"Matrix.map_one","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\nβ : Type w\ninst✝⁴ : DecidableEq n\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : Zero β\ninst✝ : One β\nf : α → β\nh₀ : Eq (f 0) 0\nh₁ : Eq (f 1) 1\n⊢ Eq (Matrix.map 1 f) 1","decl":"@[simp]\ntheorem map_one [Zero β] [One β] (f : α → β) (h₀ : f 0 = 0) (h₁ : f 1 = 1) :\n    (1 : Matrix n n α).map f = (1 : Matrix n n β) := by\n  ext\n  simp only [one_apply, map_apply]\n  split_ifs <;> simp [h₀, h₁]\n\n-- Porting note: added implicit argument `(f := fun_ => α)`, why is that needed?\n"}
{"name":"Matrix.one_eq_pi_single","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\ni j : n\n⊢ Eq (1 i j) (Pi.single i 1 j)","decl":"theorem one_eq_pi_single {i j} : (1 : Matrix n n α) i j = Pi.single (f := fun _ => α) i 1 j := by\n  simp only [one_apply, Pi.single_apply, eq_comm]\n\n"}
{"name":"Matrix.diag_apply","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\nA : Matrix n n α\ni : n\n⊢ Eq (A.diag i) (A i i)","decl":"@[simp]\ntheorem diag_apply (A : Matrix n n α) (i) : diag A i = A i i :=\n  rfl\n\n"}
{"name":"Matrix.diag_diagonal","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\na : n → α\n⊢ Eq (Matrix.diagonal a).diag a","decl":"@[simp]\ntheorem diag_diagonal [DecidableEq n] [Zero α] (a : n → α) : diag (diagonal a) = a :=\n  funext <| @diagonal_apply_eq _ _ _ _ a\n\n"}
{"name":"Matrix.diag_transpose","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\nA : Matrix n n α\n⊢ Eq A.transpose.diag A.diag","decl":"@[simp]\ntheorem diag_transpose (A : Matrix n n α) : diag Aᵀ = diag A :=\n  rfl\n\n"}
{"name":"Matrix.diag_zero","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝ : Zero α\n⊢ Eq (Matrix.diag 0) 0","decl":"@[simp]\ntheorem diag_zero [Zero α] : diag (0 : Matrix n n α) = 0 :=\n  rfl\n\n"}
{"name":"Matrix.diag_add","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝ : Add α\nA B : Matrix n n α\n⊢ Eq (HAdd.hAdd A B).diag (HAdd.hAdd A.diag B.diag)","decl":"@[simp]\ntheorem diag_add [Add α] (A B : Matrix n n α) : diag (A + B) = diag A + diag B :=\n  rfl\n\n"}
{"name":"Matrix.diag_sub","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝ : Sub α\nA B : Matrix n n α\n⊢ Eq (HSub.hSub A B).diag (HSub.hSub A.diag B.diag)","decl":"@[simp]\ntheorem diag_sub [Sub α] (A B : Matrix n n α) : diag (A - B) = diag A - diag B :=\n  rfl\n\n"}
{"name":"Matrix.diag_neg","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝ : Neg α\nA : Matrix n n α\n⊢ Eq (Neg.neg A).diag (Neg.neg A.diag)","decl":"@[simp]\ntheorem diag_neg [Neg α] (A : Matrix n n α) : diag (-A) = -diag A :=\n  rfl\n\n"}
{"name":"Matrix.diag_smul","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nR : Type u_7\nα : Type v\ninst✝ : SMul R α\nr : R\nA : Matrix n n α\n⊢ Eq (HSMul.hSMul r A).diag (HSMul.hSMul r A.diag)","decl":"@[simp]\ntheorem diag_smul [SMul R α] (r : R) (A : Matrix n n α) : diag (r • A) = r • diag A :=\n  rfl\n\n"}
{"name":"Matrix.diag_one","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ Eq (Matrix.diag 1) 1","decl":"@[simp]\ntheorem diag_one [DecidableEq n] [Zero α] [One α] : diag (1 : Matrix n n α) = 1 :=\n  diag_diagonal _\n\n"}
{"name":"Matrix.diag_map","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\nβ : Type w\nf : α → β\nA : Matrix n n α\n⊢ Eq (A.map f).diag (Function.comp f A.diag)","decl":"theorem diag_map {f : α → β} {A : Matrix n n α} : diag (A.map f) = f ∘ diag A :=\n  rfl\n\n"}
{"name":"Matrix.transpose_eq_diagonal","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : Zero α\nM : Matrix n n α\nv : n → α\n⊢ Iff (Eq M.transpose (Matrix.diagonal v)) (Eq M (Matrix.diagonal v))","decl":"@[simp]\ntheorem transpose_eq_diagonal [DecidableEq n] [Zero α] {M : Matrix n n α} {v : n → α} :\n    Mᵀ = diagonal v ↔ M = diagonal v :=\n  (Function.Involutive.eq_iff transpose_transpose).trans <|\n    by rw [diagonal_transpose]\n\n"}
{"name":"Matrix.transpose_one","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ Eq (Matrix.transpose 1) 1","decl":"@[simp]\ntheorem transpose_one [DecidableEq n] [Zero α] [One α] : (1 : Matrix n n α)ᵀ = 1 :=\n  diagonal_transpose _\n\n"}
{"name":"Matrix.transpose_eq_one","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\nM : Matrix n n α\n⊢ Iff (Eq M.transpose 1) (Eq M 1)","decl":"@[simp]\ntheorem transpose_eq_one [DecidableEq n] [Zero α] [One α] {M : Matrix n n α} : Mᵀ = 1 ↔ M = 1 :=\n  transpose_eq_diagonal\n\n"}
{"name":"Matrix.transpose_natCast","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : AddMonoidWithOne α\nd : Nat\n⊢ Eq (↑d).transpose ↑d","decl":"@[simp]\ntheorem transpose_natCast [DecidableEq n] [AddMonoidWithOne α] (d : ℕ) :\n    (d : Matrix n n α)ᵀ = d :=\n  diagonal_transpose _\n\n"}
{"name":"Matrix.transpose_eq_natCast","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : AddMonoidWithOne α\nM : Matrix n n α\nd : Nat\n⊢ Iff (Eq M.transpose ↑d) (Eq M ↑d)","decl":"@[simp]\ntheorem transpose_eq_natCast [DecidableEq n] [AddMonoidWithOne α] {M : Matrix n n α} {d : ℕ} :\n    Mᵀ = d ↔ M = d :=\n  transpose_eq_diagonal\n\n"}
{"name":"Matrix.transpose_ofNat","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : AddMonoidWithOne α\nd : Nat\ninst✝ : d.AtLeastTwo\n⊢ Eq (OfNat.ofNat d).transpose (OfNat.ofNat d)","decl":"@[simp]\ntheorem transpose_ofNat [DecidableEq n] [AddMonoidWithOne α] (d : ℕ) [d.AtLeastTwo] :\n    (ofNat(d) : Matrix n n α)ᵀ = OfNat.ofNat d :=\n  transpose_natCast _\n\n"}
{"name":"Matrix.transpose_eq_ofNat","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : DecidableEq n\ninst✝¹ : AddMonoidWithOne α\nM : Matrix n n α\nd : Nat\ninst✝ : d.AtLeastTwo\n⊢ Iff (Eq M.transpose (OfNat.ofNat d)) (Eq M (OfNat.ofNat d))","decl":"@[simp]\ntheorem transpose_eq_ofNat [DecidableEq n] [AddMonoidWithOne α]\n    {M : Matrix n n α} {d : ℕ} [d.AtLeastTwo] :\n    Mᵀ = ofNat(d) ↔ M = OfNat.ofNat d :=\n  transpose_eq_diagonal\n\n"}
{"name":"Matrix.transpose_intCast","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : AddGroupWithOne α\nd : Int\n⊢ Eq (↑d).transpose ↑d","decl":"@[simp]\ntheorem transpose_intCast [DecidableEq n] [AddGroupWithOne α] (d : ℤ) :\n    (d : Matrix n n α)ᵀ = d :=\n  diagonal_transpose _\n\n"}
{"name":"Matrix.transpose_eq_intCast","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : DecidableEq n\ninst✝ : AddGroupWithOne α\nM : Matrix n n α\nd : Int\n⊢ Iff (Eq M.transpose ↑d) (Eq M ↑d)","decl":"@[simp]\ntheorem transpose_eq_intCast [DecidableEq n] [AddGroupWithOne α]\n    {M : Matrix n n α} {d : ℤ} :\n    Mᵀ = d ↔ M = d :=\n  transpose_eq_diagonal\n\n"}
{"name":"Matrix.submatrix_diagonal","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"l : Type u_1\nm : Type u_2\nα : Type v\ninst✝² : Zero α\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq l\nd : m → α\ne : l → m\nhe : Function.Injective e\n⊢ Eq ((Matrix.diagonal d).submatrix e e) (Matrix.diagonal (Function.comp d e))","decl":"/-- Given a `(m × m)` diagonal matrix defined by a map `d : m → α`, if the reindexing map `e` is\n  injective, then the resulting matrix is again diagonal. -/\ntheorem submatrix_diagonal [Zero α] [DecidableEq m] [DecidableEq l] (d : m → α) (e : l → m)\n    (he : Function.Injective e) : (diagonal d).submatrix e e = diagonal (d ∘ e) :=\n  ext fun i j => by\n    rw [submatrix_apply]\n    by_cases h : i = j\n    · rw [h, diagonal_apply_eq, diagonal_apply_eq]\n      simp only [Function.comp_apply] -- Porting note: (simp) added this\n    · rw [diagonal_apply_ne _ h, diagonal_apply_ne _ (he.ne h)]\n\n"}
{"name":"Matrix.submatrix_one","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"l : Type u_1\nm : Type u_2\nα : Type v\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq l\ne : l → m\nhe : Function.Injective e\n⊢ Eq (Matrix.submatrix 1 e e) 1","decl":"theorem submatrix_one [Zero α] [One α] [DecidableEq m] [DecidableEq l] (e : l → m)\n    (he : Function.Injective e) : (1 : Matrix m m α).submatrix e e = 1 :=\n  submatrix_diagonal _ e he\n\n"}
{"name":"Matrix.diag_submatrix","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"l : Type u_1\nm : Type u_2\nα : Type v\nA : Matrix m m α\ne : l → m\n⊢ Eq (A.submatrix e e).diag (Function.comp A.diag e)","decl":"theorem diag_submatrix (A : Matrix m m α) (e : l → m) : diag (A.submatrix e e) = A.diag ∘ e :=\n  rfl\n\n"}
{"name":"Matrix.submatrix_diagonal_embedding","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"l : Type u_1\nm : Type u_2\nα : Type v\ninst✝² : Zero α\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq l\nd : m → α\ne : Function.Embedding l m\n⊢ Eq ((Matrix.diagonal d).submatrix ⇑e ⇑e) (Matrix.diagonal (Function.comp d ⇑e))","decl":"@[simp]\ntheorem submatrix_diagonal_embedding [Zero α] [DecidableEq m] [DecidableEq l] (d : m → α)\n    (e : l ↪ m) : (diagonal d).submatrix e e = diagonal (d ∘ e) :=\n  submatrix_diagonal d e e.injective\n\n"}
{"name":"Matrix.submatrix_diagonal_equiv","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"l : Type u_1\nm : Type u_2\nα : Type v\ninst✝² : Zero α\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq l\nd : m → α\ne : Equiv l m\n⊢ Eq ((Matrix.diagonal d).submatrix ⇑e ⇑e) (Matrix.diagonal (Function.comp d ⇑e))","decl":"@[simp]\ntheorem submatrix_diagonal_equiv [Zero α] [DecidableEq m] [DecidableEq l] (d : m → α) (e : l ≃ m) :\n    (diagonal d).submatrix e e = diagonal (d ∘ e) :=\n  submatrix_diagonal d e e.injective\n\n"}
{"name":"Matrix.submatrix_one_embedding","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"l : Type u_1\nm : Type u_2\nα : Type v\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq l\ne : Function.Embedding l m\n⊢ Eq (Matrix.submatrix 1 ⇑e ⇑e) 1","decl":"@[simp]\ntheorem submatrix_one_embedding [Zero α] [One α] [DecidableEq m] [DecidableEq l] (e : l ↪ m) :\n    (1 : Matrix m m α).submatrix e e = 1 :=\n  submatrix_one e e.injective\n\n"}
{"name":"Matrix.submatrix_one_equiv","module":"Mathlib.Data.Matrix.Diagonal","initialProofState":"l : Type u_1\nm : Type u_2\nα : Type v\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq l\ne : Equiv l m\n⊢ Eq (Matrix.submatrix 1 ⇑e ⇑e) 1","decl":"@[simp]\ntheorem submatrix_one_equiv [Zero α] [One α] [DecidableEq m] [DecidableEq l] (e : l ≃ m) :\n    (1 : Matrix m m α).submatrix e e = 1 :=\n  submatrix_one e e.injective\n\n"}
