{"name":"CategoryTheory.Functor.relativelyRepresentable.map_fst'","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\ninst‚úù : F.Full\n‚ä¢ Eq (F.map (hf'.fst' g)) (hf'.fst g)","decl":"lemma map_fst' [Full F] : F.map (hf'.fst' g) = hf'.fst g :=\n  F.map_preimage _\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.isPullback","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\n‚ä¢ CategoryTheory.IsPullback (hf.fst g) (F.map (hf.snd g)) f g","decl":"lemma isPullback : IsPullback (hf.fst g) (F.map (hf.snd g)) f g :=\n  (hf g).choose_spec.choose_spec.choose_spec\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.w","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf.fst g) f) (CategoryTheory.CategoryStruct.comp (F.map (hf.snd g)) g)","decl":"@[reassoc]\nlemma w : hf.fst g ‚â´ f = F.map (hf.snd g) ‚â´ g := (hf.isPullback g).w\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.w_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\nZ : D\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf.fst g) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (F.map (hf.snd g)) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\nlemma w : hf.fst g ‚â´ f = F.map (hf.snd g) ‚â´ g := (hf.isPullback g).w\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.isPullback'","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\ninst‚úù : F.Full\n‚ä¢ CategoryTheory.IsPullback (F.map (hf'.fst' g)) (F.map (hf'.snd g)) f' g","decl":"/-- Variant of the pullback square when `F` is full, and given `f' : F.obj b ‚ü∂ Y`. -/\nlemma isPullback' [Full F] : IsPullback (F.map (hf'.fst' g)) (F.map (hf'.snd g)) f' g :=\n  (hf'.map_fst' _) ‚ñ∏ hf'.isPullback g\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.w'","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\nhf : F.relativelyRepresentable (F.map f)\ng : Quiver.Hom Y Z\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf.fst' (F.map g)) f) (CategoryTheory.CategoryStruct.comp (hf.snd (F.map g)) g)","decl":"@[reassoc]\nlemma w' {X Y Z : C} {f : X ‚ü∂ Z} (hf : F.relativelyRepresentable (F.map f)) (g : Y ‚ü∂ Z)\n    [Full F] [Faithful F] : hf.fst' (F.map g) ‚â´ f = hf.snd (F.map g) ‚â´ g :=\n  F.map_injective <| by simp [(hf.w (F.map g))]\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.w'_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y Z‚úù : C\nf : Quiver.Hom X Z‚úù\nhf : F.relativelyRepresentable (F.map f)\ng : Quiver.Hom Y Z‚úù\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nZ : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf.fst' (F.map g)) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (hf.snd (F.map g)) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\nlemma w' {X Y Z : C} {f : X ‚ü∂ Z} (hf : F.relativelyRepresentable (F.map f)) (g : Y ‚ü∂ Z)\n    [Full F] [Faithful F] : hf.fst' (F.map g) ‚â´ f = hf.snd (F.map g) ‚â´ g :=\n  F.map_injective <| by simp [(hf.w (F.map g))]\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.isPullback_of_map","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\nhf : F.relativelyRepresentable (F.map f)\ng : Quiver.Hom Y Z\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ CategoryTheory.IsPullback (hf.fst' (F.map g)) (hf.snd (F.map g)) f g","decl":"lemma isPullback_of_map {X Y Z : C} {f : X ‚ü∂ Z} (hf : F.relativelyRepresentable (F.map f))\n    (g : Y ‚ü∂ Z) [Full F] [Faithful F] :\n    IsPullback (hf.fst' (F.map g)) (hf.snd (F.map g)) f g :=\n  IsPullback.of_map F (hf.w' g) (hf.isPullback' (F.map g))\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.hom_ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na‚úù : C\ng : Quiver.Hom (F.obj a‚úù) Y\ninst‚úù : F.Faithful\nc : C\na b : Quiver.Hom c (hf.pullback g)\n‚ä¢ Iff (Eq a b) (And (Eq (CategoryTheory.CategoryStruct.comp (F.map a) (hf.fst g)) (CategoryTheory.CategoryStruct.comp (F.map b) (hf.fst g))) (Eq (CategoryTheory.CategoryStruct.comp a (hf.snd g)) (CategoryTheory.CategoryStruct.comp b (hf.snd g))))","decl":"/-- Two morphisms `a b : c ‚ü∂ hf.pullback g` are equal if\n* Their compositions (in `C`) with `hf.snd g : hf.pullback  ‚ü∂ X` are equal.\n* The compositions of `F.map a` and `F.map b` with `hf.fst g` are equal. -/\n@[ext 100]\nlemma hom_ext [Faithful F] {c : C} {a b : c ‚ü∂ hf.pullback g}\n    (h‚ÇÅ : F.map a ‚â´ hf.fst g = F.map b ‚â´ hf.fst g)\n    (h‚ÇÇ : a ‚â´ hf.snd g = b ‚â´ hf.snd g) : a = b :=\n  F.map_injective <|\n    PullbackCone.IsLimit.hom_ext (hf.isPullback g).isLimit h‚ÇÅ (by simpa using F.congr_map h‚ÇÇ)\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.hom_ext","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na‚úù : C\ng : Quiver.Hom (F.obj a‚úù) Y\ninst‚úù : F.Faithful\nc : C\na b : Quiver.Hom c (hf.pullback g)\nh‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (F.map a) (hf.fst g)) (CategoryTheory.CategoryStruct.comp (F.map b) (hf.fst g))\nh‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp a (hf.snd g)) (CategoryTheory.CategoryStruct.comp b (hf.snd g))\n‚ä¢ Eq a b","decl":"/-- Two morphisms `a b : c ‚ü∂ hf.pullback g` are equal if\n* Their compositions (in `C`) with `hf.snd g : hf.pullback  ‚ü∂ X` are equal.\n* The compositions of `F.map a` and `F.map b` with `hf.fst g` are equal. -/\n@[ext 100]\nlemma hom_ext [Faithful F] {c : C} {a b : c ‚ü∂ hf.pullback g}\n    (h‚ÇÅ : F.map a ‚â´ hf.fst g = F.map b ‚â´ hf.fst g)\n    (h‚ÇÇ : a ‚â´ hf.snd g = b ‚â´ hf.snd g) : a = b :=\n  F.map_injective <|\n    PullbackCone.IsLimit.hom_ext (hf.isPullback g).isLimit h‚ÇÅ (by simpa using F.congr_map h‚ÇÇ)\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.hom_ext'","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb‚úù : C\nf' : Quiver.Hom (F.obj b‚úù) Y\nhf' : F.relativelyRepresentable f'\na‚úù : C\ng : Quiver.Hom (F.obj a‚úù) Y\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nc : C\na b : Quiver.Hom c (hf'.pullback g)\nh‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp a (hf'.fst' g)) (CategoryTheory.CategoryStruct.comp b (hf'.fst' g))\nh‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp a (hf'.snd g)) (CategoryTheory.CategoryStruct.comp b (hf'.snd g))\n‚ä¢ Eq a b","decl":"/-- In the case of a representable morphism `f' : F.obj Y ‚ü∂ G`, whose codomain lies\nin the image of `F`, we get that two morphism `a b : Z ‚ü∂ hf.pullback g` are equal if\n* Their compositions (in `C`) with `hf'.snd g : hf.pullback  ‚ü∂ X` are equal.\n* Their compositions (in `C`) with `hf'.fst' g : hf.pullback  ‚ü∂ Y` are equal. -/\n@[ext]\nlemma hom_ext' [Full F] [Faithful F] {c : C} {a b : c ‚ü∂ hf'.pullback g}\n    (h‚ÇÅ : a ‚â´ hf'.fst' g = b ‚â´ hf'.fst' g)\n    (h‚ÇÇ : a ‚â´ hf'.snd g = b ‚â´ hf'.snd g) : a = b :=\n  hf'.hom_ext (by simpa [map_fst'] using F.congr_map h‚ÇÅ) h‚ÇÇ\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.hom_ext'_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb‚úù : C\nf' : Quiver.Hom (F.obj b‚úù) Y\nhf' : F.relativelyRepresentable f'\na‚úù : C\ng : Quiver.Hom (F.obj a‚úù) Y\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nc : C\na b : Quiver.Hom c (hf'.pullback g)\n‚ä¢ Iff (Eq a b) (And (Eq (CategoryTheory.CategoryStruct.comp a (hf'.fst' g)) (CategoryTheory.CategoryStruct.comp b (hf'.fst' g))) (Eq (CategoryTheory.CategoryStruct.comp a (hf'.snd g)) (CategoryTheory.CategoryStruct.comp b (hf'.snd g))))","decl":"/-- In the case of a representable morphism `f' : F.obj Y ‚ü∂ G`, whose codomain lies\nin the image of `F`, we get that two morphism `a b : Z ‚ü∂ hf.pullback g` are equal if\n* Their compositions (in `C`) with `hf'.snd g : hf.pullback  ‚ü∂ X` are equal.\n* Their compositions (in `C`) with `hf'.fst' g : hf.pullback  ‚ü∂ Y` are equal. -/\n@[ext]\nlemma hom_ext' [Full F] [Faithful F] {c : C} {a b : c ‚ü∂ hf'.pullback g}\n    (h‚ÇÅ : a ‚â´ hf'.fst' g = b ‚â´ hf'.fst' g)\n    (h‚ÇÇ : a ‚â´ hf'.snd g = b ‚â´ hf'.snd g) : a = b :=\n  hf'.hom_ext (by simpa [map_fst'] using F.congr_map h‚ÇÅ) h‚ÇÇ\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift_fst","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom (F.obj c) X\nh : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp i f) (CategoryTheory.CategoryStruct.comp (F.map h) g)\ninst‚úù : F.Full\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (hf.lift i h hi)) (hf.fst g)) i","decl":"@[reassoc (attr := simp)]\nlemma lift_fst [Full F] : F.map (hf.lift i h hi) ‚â´ hf.fst g = i := by\n  simpa [lift] using PullbackCone.IsLimit.lift_fst _ _ _ _\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift_fst_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom (F.obj c) X\nh‚úù : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp i f) (CategoryTheory.CategoryStruct.comp (F.map h‚úù) g)\ninst‚úù : F.Full\nZ : D\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (hf.lift i h‚úù hi)) (CategoryTheory.CategoryStruct.comp (hf.fst g) h)) (CategoryTheory.CategoryStruct.comp i h)","decl":"@[reassoc (attr := simp)]\nlemma lift_fst [Full F] : F.map (hf.lift i h hi) ‚â´ hf.fst g = i := by\n  simpa [lift] using PullbackCone.IsLimit.lift_fst _ _ _ _\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift_snd_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom (F.obj c) X\nh‚úù : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp i f) (CategoryTheory.CategoryStruct.comp (F.map h‚úù) g)\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nZ : C\nh : Quiver.Hom a Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf.lift i h‚úù hi) (CategoryTheory.CategoryStruct.comp (hf.snd g) h)) (CategoryTheory.CategoryStruct.comp h‚úù h)","decl":"@[reassoc (attr := simp)]\nlemma lift_snd [Full F] [Faithful F] : hf.lift i h hi ‚â´ hf.snd g = h :=\n  F.map_injective <| by simpa [lift] using PullbackCone.IsLimit.lift_snd _ _ _ _\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift_snd","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom (F.obj c) X\nh : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp i f) (CategoryTheory.CategoryStruct.comp (F.map h) g)\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf.lift i h hi) (hf.snd g)) h","decl":"@[reassoc (attr := simp)]\nlemma lift_snd [Full F] [Faithful F] : hf.lift i h hi ‚â´ hf.snd g = h :=\n  F.map_injective <| by simpa [lift] using PullbackCone.IsLimit.lift_snd _ _ _ _\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift'_fst","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom c b\nh : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp (F.map i) f') (CategoryTheory.CategoryStruct.comp (F.map h) g)\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf'.lift' i h hi) (hf'.fst' g)) i","decl":"@[reassoc (attr := simp)]\nlemma lift'_fst [Full F] [Faithful F] : hf'.lift' i h hi ‚â´ hf'.fst' g = i :=\n  F.map_injective (by simp [map_fst', lift'])\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift'_fst_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom c b\nh‚úù : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp (F.map i) f') (CategoryTheory.CategoryStruct.comp (F.map h‚úù) g)\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nZ : C\nh : Quiver.Hom b Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf'.lift' i h‚úù hi) (CategoryTheory.CategoryStruct.comp (hf'.fst' g) h)) (CategoryTheory.CategoryStruct.comp i h)","decl":"@[reassoc (attr := simp)]\nlemma lift'_fst [Full F] [Faithful F] : hf'.lift' i h hi ‚â´ hf'.fst' g = i :=\n  F.map_injective (by simp [map_fst', lift'])\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift'_snd","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom c b\nh : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp (F.map i) f') (CategoryTheory.CategoryStruct.comp (F.map h) g)\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf'.lift' i h hi) (hf'.snd g)) h","decl":"@[reassoc (attr := simp)]\nlemma lift'_snd [Full F] [Faithful F] : hf'.lift' i h hi ‚â´ hf'.snd g = h := by\n  simp [lift']\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift'_snd_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom c b\nh‚úù : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp (F.map i) f') (CategoryTheory.CategoryStruct.comp (F.map h‚úù) g)\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nZ : C\nh : Quiver.Hom a Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf'.lift' i h‚úù hi) (CategoryTheory.CategoryStruct.comp (hf'.snd g) h)) (CategoryTheory.CategoryStruct.comp h‚úù h)","decl":"@[reassoc (attr := simp)]\nlemma lift'_snd [Full F] [Faithful F] : hf'.lift' i h hi ‚â´ hf'.snd g = h := by\n  simp [lift']\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetry_fst","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (hg.fst' f')) (hf'.snd g)","decl":"@[reassoc (attr := simp)]\nlemma symmetry_fst [Full F] [Faithful F] : hf'.symmetry hg ‚â´ hg.fst' f' = hf'.snd g := by\n  simp [symmetry]\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetry_fst_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nZ : C\nh : Quiver.Hom a Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (CategoryTheory.CategoryStruct.comp (hg.fst' f') h)) (CategoryTheory.CategoryStruct.comp (hf'.snd g) h)","decl":"@[reassoc (attr := simp)]\nlemma symmetry_fst [Full F] [Faithful F] : hf'.symmetry hg ‚â´ hg.fst' f' = hf'.snd g := by\n  simp [symmetry]\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetry_snd_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nZ : C\nh : Quiver.Hom b Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (CategoryTheory.CategoryStruct.comp (hg.snd f') h)) (CategoryTheory.CategoryStruct.comp (hf'.fst' g) h)","decl":"@[reassoc (attr := simp)]\nlemma symmetry_snd [Full F] [Faithful F] : hf'.symmetry hg ‚â´ hg.snd f' = hf'.fst' g := by\n  simp [symmetry]\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetry_snd","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (hg.snd f')) (hf'.fst' g)","decl":"@[reassoc (attr := simp)]\nlemma symmetry_snd [Full F] [Faithful F] : hf'.symmetry hg ‚â´ hg.snd f' = hf'.fst' g := by\n  simp [symmetry]\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetry_symmetry","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (hg.symmetry hf')) (CategoryTheory.CategoryStruct.id (hf'.pullback g))","decl":"@[reassoc (attr := simp)]\nlemma symmetry_symmetry [Full F] [Faithful F] : hf'.symmetry hg ‚â´ hg.symmetry hf' = ùüô _ :=\n  hom_ext' hf' (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetry_symmetry_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nZ : C\nh : Quiver.Hom (hf'.pullback g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (CategoryTheory.CategoryStruct.comp (hg.symmetry hf') h)) h","decl":"@[reassoc (attr := simp)]\nlemma symmetry_symmetry [Full F] [Faithful F] : hf'.symmetry hg ‚â´ hg.symmetry hf' = ùüô _ :=\n  hom_ext' hf' (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetryIso_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ Eq (hf'.symmetryIso hg).hom (hf'.symmetry hg)","decl":"/-- The isomorphism given by `Presheaf.representable.symmetry`. -/\n@[simps]\nnoncomputable def symmetryIso [Full F] [Faithful F] : hf'.pullback g ‚âÖ hg.pullback f' where\n  hom := hf'.symmetry hg\n  inv := hg.symmetry hf'\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetryIso_inv","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ Eq (hf'.symmetryIso hg).inv (hg.symmetry hf')","decl":"/-- The isomorphism given by `Presheaf.representable.symmetry`. -/\n@[simps]\nnoncomputable def symmetryIso [Full F] [Faithful F] : hf'.pullback g ‚âÖ hg.pullback f' where\n  hom := hf'.symmetry hg\n  inv := hg.symmetry hf'\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.instIsIsoSymmetryOfFaithful","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ CategoryTheory.IsIso (hf'.symmetry hg)","decl":"instance [Full F] [Faithful F] : IsIso (hf'.symmetry hg) :=\n  (hf'.symmetryIso hg).isIso_hom\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.map","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : F.Full\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\na b : C\nf : Quiver.Hom a b\ninst‚úù : ‚àÄ (c : C) (g : Quiver.Hom c b), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) F\n‚ä¢ F.relativelyRepresentable (F.map f)","decl":"/-- When `C` has pullbacks, then `F.map f` is representable with respect to `F` for any\n`f : a ‚ü∂ b` in `C`. -/\nlemma map [Full F] [HasPullbacks C] {a b : C} (f : a ‚ü∂ b)\n    [‚àÄ c (g : c ‚ü∂ b), PreservesLimit (cospan f g) F] :\n    F.relativelyRepresentable (F.map f) := fun c g ‚Ü¶ by\n  obtain ‚ü®g, rfl‚ü© := F.map_surjective g\n  refine ‚ü®Limits.pullback f g, Limits.pullback.snd f g, F.map (Limits.pullback.fst f g), ?_‚ü©\n  apply F.map_isPullback <| IsPullback.of_hasPullback f g\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.of_isIso","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ F.relativelyRepresentable f","decl":"lemma of_isIso {X Y : D} (f : X ‚ü∂ Y) [IsIso f] : F.relativelyRepresentable f :=\n  fun a g ‚Ü¶ ‚ü®a, ùüô a, g ‚â´ CategoryTheory.inv f, IsPullback.of_vert_isIso ‚ü®by simp‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.isomorphisms_le","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ LE.le (CategoryTheory.MorphismProperty.isomorphisms D) F.relativelyRepresentable","decl":"lemma isomorphisms_le : MorphismProperty.isomorphisms D ‚â§ F.relativelyRepresentable :=\n  fun _ _ f hf ‚Ü¶ letI : IsIso f := hf; of_isIso F f\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.isMultiplicative","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ F.relativelyRepresentable.IsMultiplicative","decl":"instance isMultiplicative : IsMultiplicative F.relativelyRepresentable where\n  id_mem _ := of_isIso F _\n  comp_mem {F G H} f g hf hg := fun X h ‚Ü¶\n    ‚ü®hf.pullback (hg.fst h), hf.snd (hg.fst h) ‚â´ hg.snd h, hf.fst (hg.fst h),\n      by simpa using IsPullback.paste_vert (hf.isPullback (hg.fst h)) (hg.isPullback h)‚ü©\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.isStableUnderBaseChange","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ F.relativelyRepresentable.IsStableUnderBaseChange","decl":"instance isStableUnderBaseChange : IsStableUnderBaseChange F.relativelyRepresentable where\n  of_isPullback {X Y Y' X' f g f' g'} P‚ÇÅ hg a h := by\n    refine ‚ü®hg.pullback (h ‚â´ f), hg.snd (h ‚â´ f), ?_, ?_‚ü©\n    ¬∑ apply P‚ÇÅ.lift (hg.fst (h ‚â´ f)) (F.map (hg.snd (h ‚â´ f)) ‚â´ h) (by simpa using hg.w (h ‚â´ f))\n    ¬∑ apply IsPullback.of_right' (hg.isPullback (h ‚â´ f)) P‚ÇÅ\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ F.relativelyRepresentable.RespectsIso","decl":"instance respectsIso : RespectsIso F.relativelyRepresentable :=\n  (isStableUnderBaseChange F).respectsIso\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative.rep","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nP : CategoryTheory.MorphismProperty C\nf : Quiver.Hom X Y\nhf : CategoryTheory.MorphismProperty.relative F P f\n‚ä¢ F.relativelyRepresentable f","decl":"/-- A morphism satisfying `P.relative` is representable. -/\nlemma relative.rep {f : X ‚ü∂ Y} (hf : P.relative F f) : F.relativelyRepresentable f :=\n  hf.1\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative.property","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nP : CategoryTheory.MorphismProperty C\nf : Quiver.Hom X Y\nhf : CategoryTheory.MorphismProperty.relative F P f\na b : C\ng : Quiver.Hom (F.obj a) Y\nfst : Quiver.Hom (F.obj b) X\nsnd : Quiver.Hom b a\nx‚úù : CategoryTheory.IsPullback fst (F.map snd) f g\n‚ä¢ P snd","decl":"lemma relative.property {f : X ‚ü∂ Y} (hf : P.relative F f) :\n    ‚àÄ ‚¶Éa b : C‚¶Ñ (g : F.obj a ‚ü∂ Y) (fst : F.obj b ‚ü∂ X) (snd : b ‚ü∂ a)\n    (_ : IsPullback fst (F.map snd) f g), P snd :=\n  hf.2\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative.property_snd","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nP : CategoryTheory.MorphismProperty C\nf : Quiver.Hom X Y\nhf : CategoryTheory.MorphismProperty.relative F P f\na : C\ng : Quiver.Hom (F.obj a) Y\n‚ä¢ P (‚ãØ.snd g)","decl":"lemma relative.property_snd {f : X ‚ü∂ Y} (hf : P.relative F f) {a : C} (g : F.obj a ‚ü∂ Y) :\n    P (hf.rep.snd g) :=\n  hf.property g _ _ (hf.rep.isPullback g)\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative.of_exists","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬≤ : F.Faithful\ninst‚úù¬π : F.Full\ninst‚úù : P.RespectsIso\nf : Quiver.Hom X Y\nh‚ÇÄ : ‚àÄ ‚¶Éa : C‚¶Ñ (g : Quiver.Hom (F.obj a) Y), Exists fun b => Exists fun fst => Exists fun snd => Exists fun x => P snd\n‚ä¢ CategoryTheory.MorphismProperty.relative F P f","decl":"/-- Given a morphism property `P` which respects isomorphisms, then to show that a morphism\n`f : X ‚ü∂ Y` satisfies `P.relative` it suffices to show that:\n* The morphism is representable.\n* For any morphism `g : F.obj a ‚ü∂ G`, the property `P` holds for *some* represented pullback\nof `f` by `g`. -/\nlemma relative.of_exists [F.Faithful] [F.Full] [P.RespectsIso] {f : X ‚ü∂ Y}\n    (h‚ÇÄ : ‚àÄ ‚¶Éa : C‚¶Ñ (g : F.obj a ‚ü∂ Y), ‚àÉ (b : C) (fst : F.obj b ‚ü∂ X) (snd : b ‚ü∂ a)\n      (_ : IsPullback fst (F.map snd) f g), P snd) : P.relative F f := by\n  refine ‚ü®fun a g ‚Ü¶ ?_, fun a b g fst snd h ‚Ü¶ ?_‚ü©\n  all_goals obtain ‚ü®c, g_fst, g_snd, BC, H‚ü© := h‚ÇÄ g\n  ¬∑ refine ‚ü®c, g_snd, g_fst, BC‚ü©\n  ¬∑ refine (P.arrow_mk_iso_iff ?_).2 H\n    exact Arrow.isoMk (F.preimageIso (h.isoIsPullback X (F.obj a) BC)) (Iso.refl _)\n      (F.map_injective (by simp))\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_of_snd","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : D\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬≤ : F.Faithful\ninst‚úù¬π : F.Full\ninst‚úù : P.RespectsIso\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\nh : ‚àÄ ‚¶Éa : C‚¶Ñ (g : Quiver.Hom (F.obj a) Y), P (hf.snd g)\n‚ä¢ CategoryTheory.MorphismProperty.relative F P f","decl":"lemma relative_of_snd [F.Faithful] [F.Full] [P.RespectsIso] {f : X ‚ü∂ Y}\n    (hf : F.relativelyRepresentable f) (h : ‚àÄ ‚¶Éa : C‚¶Ñ (g : F.obj a ‚ü∂ Y), P (hf.snd g)) :\n    P.relative F f :=\n  relative.of_exists (fun _ g ‚Ü¶ ‚ü®hf.pullback g, hf.fst g, hf.snd g, hf.isPullback g, h g‚ü©)\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_map","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\ninst‚úù‚Å¥ : F.Faithful\ninst‚úù¬≥ : F.Full\ninst‚úù¬≤ : CategoryTheory.Limits.HasPullbacks C\ninst‚úù¬π : P.IsStableUnderBaseChange\na b : C\nf : Quiver.Hom a b\ninst‚úù : ‚àÄ (c : C) (g : Quiver.Hom c b), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) F\nhf : P f\n‚ä¢ CategoryTheory.MorphismProperty.relative F P (F.map f)","decl":"/-- If `P : MorphismProperty C` is stable under base change, `F` is fully faithful and preserves\npullbacks, and `C` has all pullbacks, then for any `f : a ‚ü∂ b` in `C`, `F.map f` satisfies\n`P.relative` if `f` satisfies `P`. -/\nlemma relative_map [F.Faithful] [F.Full] [HasPullbacks C] [IsStableUnderBaseChange P]\n    {a b : C} {f : a ‚ü∂ b} [‚àÄ c (g : c ‚ü∂ b), PreservesLimit (cospan f g) F]\n    (hf : P f) : P.relative F (F.map f) := by\n  apply relative.of_exists\n  intro Y' g\n  obtain ‚ü®g, rfl‚ü© := F.map_surjective g\n  exact ‚ü®_, _, _, (IsPullback.of_hasPullback f g).map F, P.pullback_snd _ _ hf‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.of_relative_map","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\na b : C\nf : Quiver.Hom a b\nhf : CategoryTheory.MorphismProperty.relative F P (F.map f)\n‚ä¢ P f","decl":"lemma of_relative_map {a b : C} {f : a ‚ü∂ b} (hf : P.relative F (F.map f)) : P f :=\n  hf.property (ùüô _) (ùüô _) f (IsPullback.id_horiz (F.map f))\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_map_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\ninst‚úù‚Å¥ : F.Faithful\ninst‚úù¬≥ : F.Full\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan F\ninst‚úù¬π : CategoryTheory.Limits.HasPullbacks C\ninst‚úù : P.IsStableUnderBaseChange\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.MorphismProperty.relative F P (F.map f)) (P f)","decl":"lemma relative_map_iff [F.Faithful] [F.Full] [PreservesLimitsOfShape WalkingCospan F]\n    [HasPullbacks C] [IsStableUnderBaseChange P] {X Y : C} {f : X ‚ü∂ Y} :\n    P.relative F (F.map f) ‚Üî P f :=\n  ‚ü®fun hf ‚Ü¶ of_relative_map hf, fun hf ‚Ü¶ relative_map hf‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_monotone","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nP P' : CategoryTheory.MorphismProperty C\nh : LE.le P P'\n‚ä¢ LE.le (CategoryTheory.MorphismProperty.relative F P) (CategoryTheory.MorphismProperty.relative F P')","decl":"/-- If `P' : MorphismProperty C` is satisfied whenever `P` is, then also `P'.relative` is\nsatisfied whenever `P.relative` is. -/\nlemma relative_monotone {P' : MorphismProperty C} (h : P ‚â§ P') :\n    P.relative F ‚â§ P'.relative F := fun _ _ _ hf ‚Ü¶\n  ‚ü®hf.rep, fun _ _ g fst snd BC ‚Ü¶ h _ (hf.property g fst snd BC)‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_isStableUnderBaseChange","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\n‚ä¢ (CategoryTheory.MorphismProperty.relative F P).IsStableUnderBaseChange","decl":"lemma relative_isStableUnderBaseChange : IsStableUnderBaseChange (P.relative F) where\n  of_isPullback hfBC hg :=\n    ‚ü®of_isPullback hfBC hg.rep,\n      fun _ _ _ _ _ BC ‚Ü¶ hg.property _ _ _ (IsPullback.paste_horiz BC hfBC)‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_isStableUnderComposition","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬≤ : F.Faithful\ninst‚úù¬π : F.Full\ninst‚úù : P.IsStableUnderComposition\n‚ä¢ (CategoryTheory.MorphismProperty.relative F P).IsStableUnderComposition","decl":"instance relative_isStableUnderComposition [F.Faithful] [F.Full] [P.IsStableUnderComposition] :\n    IsStableUnderComposition (P.relative F) where\n  comp_mem {F G H} f g hf hg := by\n    refine ‚ü®comp_mem _ _ _ hf.1 hg.1, fun Z X p fst snd h ‚Ü¶ ?_‚ü©\n    rw [‚Üê hg.1.lift_snd (fst ‚â´ f) snd (by simpa using h.w)]\n    refine comp_mem _ _ _ (hf.property (hg.1.fst p) fst _\n      (IsPullback.of_bot ?_ ?_ (hg.1.isPullback p))) (hg.property_snd p)\n    ¬∑ rw [‚Üê Functor.map_comp, lift_snd]\n      exact h\n    ¬∑ symm\n      apply hg.1.lift_fst\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\n‚ä¢ (CategoryTheory.MorphismProperty.relative F P).RespectsIso","decl":"instance relative_respectsIso : RespectsIso (P.relative F) :=\n  (relative_isStableUnderBaseChange P).respectsIso\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_isMultiplicative","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬≥ : F.Faithful\ninst‚úù¬≤ : F.Full\ninst‚úù¬π : P.IsMultiplicative\ninst‚úù : P.RespectsIso\n‚ä¢ (CategoryTheory.MorphismProperty.relative F P).IsMultiplicative","decl":"instance relative_isMultiplicative [F.Faithful] [F.Full] [P.IsMultiplicative] [P.RespectsIso] :\n    IsMultiplicative (P.relative F) where\n  id_mem X := relative.of_exists\n    (fun Y g ‚Ü¶ ‚ü®Y, g, ùüô Y, by simpa using IsPullback.of_id_snd, id_mem _ _‚ü©)\n\n"}
{"name":"CategoryTheory.MorphismProperty.presheaf_monomorphisms_le_monomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ LE.le (CategoryTheory.MorphismProperty.monomorphisms C).presheaf (CategoryTheory.MorphismProperty.monomorphisms (CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)))","decl":"/-- Morphisms satisfying `(monomorphism C).presheaf` are in particular monomorphisms. -/\nlemma presheaf_monomorphisms_le_monomorphisms :\n    (monomorphisms C).presheaf ‚â§ monomorphisms _ := fun F G f hf ‚Ü¶ by\n  suffices ‚àÄ {X : C} {a b : yoneda.obj X ‚ü∂ F}, a ‚â´ f = b ‚â´ f ‚Üí a = b from\n    ‚ü®fun _ _ h ‚Ü¶ hom_ext_yoneda (fun _ _ ‚Ü¶ this (by simp only [assoc, h]))‚ü©\n  intro X a b h\n  /- It suffices to show that the lifts of `a` and `b` to morphisms\n  `X ‚ü∂ hf.rep.pullback g` are equal, where `g = a ‚â´ f = a ‚â´ f`. -/\n  suffices hf.rep.lift (g := a ‚â´ f) a (ùüô X) (by simp) =\n      hf.rep.lift b (ùüô X) (by simp [‚Üê h]) by\n    simpa using yoneda.congr_map this =‚â´ (hf.rep.fst (a ‚â´ f))\n  -- This follows from the fact that the induced maps `hf.rep.pullback g ‚ü∂ X` are mono.\n  have : Mono (hf.rep.snd (a ‚â´ f)) := hf.property_snd (a ‚â´ f)\n  simp only [‚Üê cancel_mono (hf.rep.snd (a ‚â´ f)), lift_snd]\n\n"}
