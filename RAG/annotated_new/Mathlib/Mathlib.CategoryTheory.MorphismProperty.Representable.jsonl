{"name":"CategoryTheory.Functor.relativelyRepresentable.map_fst'","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\ninst✝ : F.Full\n⊢ Eq (F.map (hf'.fst' g)) (hf'.fst g)","decl":"lemma map_fst' [Full F] : F.map (hf'.fst' g) = hf'.fst g :=\n  F.map_preimage _\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.isPullback","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\n⊢ CategoryTheory.IsPullback (hf.fst g) (F.map (hf.snd g)) f g","decl":"lemma isPullback : IsPullback (hf.fst g) (F.map (hf.snd g)) f g :=\n  (hf g).choose_spec.choose_spec.choose_spec\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.w","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf.fst g) f) (CategoryTheory.CategoryStruct.comp (F.map (hf.snd g)) g)","decl":"@[reassoc]\nlemma w : hf.fst g ≫ f = F.map (hf.snd g) ≫ g := (hf.isPullback g).w\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.w_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\nZ : D\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf.fst g) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (F.map (hf.snd g)) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\nlemma w : hf.fst g ≫ f = F.map (hf.snd g) ≫ g := (hf.isPullback g).w\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.isPullback'","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\ninst✝ : F.Full\n⊢ CategoryTheory.IsPullback (F.map (hf'.fst' g)) (F.map (hf'.snd g)) f' g","decl":"/-- Variant of the pullback square when `F` is full, and given `f' : F.obj b ⟶ Y`. -/\nlemma isPullback' [Full F] : IsPullback (F.map (hf'.fst' g)) (F.map (hf'.snd g)) f' g :=\n  (hf'.map_fst' _) ▸ hf'.isPullback g\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.w'","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\nhf : F.relativelyRepresentable (F.map f)\ng : Quiver.Hom Y Z\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf.fst' (F.map g)) f) (CategoryTheory.CategoryStruct.comp (hf.snd (F.map g)) g)","decl":"@[reassoc]\nlemma w' {X Y Z : C} {f : X ⟶ Z} (hf : F.relativelyRepresentable (F.map f)) (g : Y ⟶ Z)\n    [Full F] [Faithful F] : hf.fst' (F.map g) ≫ f = hf.snd (F.map g) ≫ g :=\n  F.map_injective <| by simp [(hf.w (F.map g))]\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.w'_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\nhf : F.relativelyRepresentable (F.map f)\ng : Quiver.Hom Y Z✝\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nZ : C\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf.fst' (F.map g)) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp (hf.snd (F.map g)) (CategoryTheory.CategoryStruct.comp g h))","decl":"@[reassoc]\nlemma w' {X Y Z : C} {f : X ⟶ Z} (hf : F.relativelyRepresentable (F.map f)) (g : Y ⟶ Z)\n    [Full F] [Faithful F] : hf.fst' (F.map g) ≫ f = hf.snd (F.map g) ≫ g :=\n  F.map_injective <| by simp [(hf.w (F.map g))]\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.isPullback_of_map","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\nhf : F.relativelyRepresentable (F.map f)\ng : Quiver.Hom Y Z\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ CategoryTheory.IsPullback (hf.fst' (F.map g)) (hf.snd (F.map g)) f g","decl":"lemma isPullback_of_map {X Y Z : C} {f : X ⟶ Z} (hf : F.relativelyRepresentable (F.map f))\n    (g : Y ⟶ Z) [Full F] [Faithful F] :\n    IsPullback (hf.fst' (F.map g)) (hf.snd (F.map g)) f g :=\n  IsPullback.of_map F (hf.w' g) (hf.isPullback' (F.map g))\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.hom_ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na✝ : C\ng : Quiver.Hom (F.obj a✝) Y\ninst✝ : F.Faithful\nc : C\na b : Quiver.Hom c (hf.pullback g)\n⊢ Iff (Eq a b) (And (Eq (CategoryTheory.CategoryStruct.comp (F.map a) (hf.fst g)) (CategoryTheory.CategoryStruct.comp (F.map b) (hf.fst g))) (Eq (CategoryTheory.CategoryStruct.comp a (hf.snd g)) (CategoryTheory.CategoryStruct.comp b (hf.snd g))))","decl":"/-- Two morphisms `a b : c ⟶ hf.pullback g` are equal if\n* Their compositions (in `C`) with `hf.snd g : hf.pullback  ⟶ X` are equal.\n* The compositions of `F.map a` and `F.map b` with `hf.fst g` are equal. -/\n@[ext 100]\nlemma hom_ext [Faithful F] {c : C} {a b : c ⟶ hf.pullback g}\n    (h₁ : F.map a ≫ hf.fst g = F.map b ≫ hf.fst g)\n    (h₂ : a ≫ hf.snd g = b ≫ hf.snd g) : a = b :=\n  F.map_injective <|\n    PullbackCone.IsLimit.hom_ext (hf.isPullback g).isLimit h₁ (by simpa using F.congr_map h₂)\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.hom_ext","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na✝ : C\ng : Quiver.Hom (F.obj a✝) Y\ninst✝ : F.Faithful\nc : C\na b : Quiver.Hom c (hf.pullback g)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp (F.map a) (hf.fst g)) (CategoryTheory.CategoryStruct.comp (F.map b) (hf.fst g))\nh₂ : Eq (CategoryTheory.CategoryStruct.comp a (hf.snd g)) (CategoryTheory.CategoryStruct.comp b (hf.snd g))\n⊢ Eq a b","decl":"/-- Two morphisms `a b : c ⟶ hf.pullback g` are equal if\n* Their compositions (in `C`) with `hf.snd g : hf.pullback  ⟶ X` are equal.\n* The compositions of `F.map a` and `F.map b` with `hf.fst g` are equal. -/\n@[ext 100]\nlemma hom_ext [Faithful F] {c : C} {a b : c ⟶ hf.pullback g}\n    (h₁ : F.map a ≫ hf.fst g = F.map b ≫ hf.fst g)\n    (h₂ : a ≫ hf.snd g = b ≫ hf.snd g) : a = b :=\n  F.map_injective <|\n    PullbackCone.IsLimit.hom_ext (hf.isPullback g).isLimit h₁ (by simpa using F.congr_map h₂)\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.hom_ext'","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb✝ : C\nf' : Quiver.Hom (F.obj b✝) Y\nhf' : F.relativelyRepresentable f'\na✝ : C\ng : Quiver.Hom (F.obj a✝) Y\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nc : C\na b : Quiver.Hom c (hf'.pullback g)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp a (hf'.fst' g)) (CategoryTheory.CategoryStruct.comp b (hf'.fst' g))\nh₂ : Eq (CategoryTheory.CategoryStruct.comp a (hf'.snd g)) (CategoryTheory.CategoryStruct.comp b (hf'.snd g))\n⊢ Eq a b","decl":"/-- In the case of a representable morphism `f' : F.obj Y ⟶ G`, whose codomain lies\nin the image of `F`, we get that two morphism `a b : Z ⟶ hf.pullback g` are equal if\n* Their compositions (in `C`) with `hf'.snd g : hf.pullback  ⟶ X` are equal.\n* Their compositions (in `C`) with `hf'.fst' g : hf.pullback  ⟶ Y` are equal. -/\n@[ext]\nlemma hom_ext' [Full F] [Faithful F] {c : C} {a b : c ⟶ hf'.pullback g}\n    (h₁ : a ≫ hf'.fst' g = b ≫ hf'.fst' g)\n    (h₂ : a ≫ hf'.snd g = b ≫ hf'.snd g) : a = b :=\n  hf'.hom_ext (by simpa [map_fst'] using F.congr_map h₁) h₂\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.hom_ext'_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb✝ : C\nf' : Quiver.Hom (F.obj b✝) Y\nhf' : F.relativelyRepresentable f'\na✝ : C\ng : Quiver.Hom (F.obj a✝) Y\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nc : C\na b : Quiver.Hom c (hf'.pullback g)\n⊢ Iff (Eq a b) (And (Eq (CategoryTheory.CategoryStruct.comp a (hf'.fst' g)) (CategoryTheory.CategoryStruct.comp b (hf'.fst' g))) (Eq (CategoryTheory.CategoryStruct.comp a (hf'.snd g)) (CategoryTheory.CategoryStruct.comp b (hf'.snd g))))","decl":"/-- In the case of a representable morphism `f' : F.obj Y ⟶ G`, whose codomain lies\nin the image of `F`, we get that two morphism `a b : Z ⟶ hf.pullback g` are equal if\n* Their compositions (in `C`) with `hf'.snd g : hf.pullback  ⟶ X` are equal.\n* Their compositions (in `C`) with `hf'.fst' g : hf.pullback  ⟶ Y` are equal. -/\n@[ext]\nlemma hom_ext' [Full F] [Faithful F] {c : C} {a b : c ⟶ hf'.pullback g}\n    (h₁ : a ≫ hf'.fst' g = b ≫ hf'.fst' g)\n    (h₂ : a ≫ hf'.snd g = b ≫ hf'.snd g) : a = b :=\n  hf'.hom_ext (by simpa [map_fst'] using F.congr_map h₁) h₂\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift_fst","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom (F.obj c) X\nh : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp i f) (CategoryTheory.CategoryStruct.comp (F.map h) g)\ninst✝ : F.Full\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (hf.lift i h hi)) (hf.fst g)) i","decl":"@[reassoc (attr := simp)]\nlemma lift_fst [Full F] : F.map (hf.lift i h hi) ≫ hf.fst g = i := by\n  simpa [lift] using PullbackCone.IsLimit.lift_fst _ _ _ _\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift_fst_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom (F.obj c) X\nh✝ : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp i f) (CategoryTheory.CategoryStruct.comp (F.map h✝) g)\ninst✝ : F.Full\nZ : D\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (hf.lift i h✝ hi)) (CategoryTheory.CategoryStruct.comp (hf.fst g) h)) (CategoryTheory.CategoryStruct.comp i h)","decl":"@[reassoc (attr := simp)]\nlemma lift_fst [Full F] : F.map (hf.lift i h hi) ≫ hf.fst g = i := by\n  simpa [lift] using PullbackCone.IsLimit.lift_fst _ _ _ _\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift_snd_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom (F.obj c) X\nh✝ : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp i f) (CategoryTheory.CategoryStruct.comp (F.map h✝) g)\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nZ : C\nh : Quiver.Hom a Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf.lift i h✝ hi) (CategoryTheory.CategoryStruct.comp (hf.snd g) h)) (CategoryTheory.CategoryStruct.comp h✝ h)","decl":"@[reassoc (attr := simp)]\nlemma lift_snd [Full F] [Faithful F] : hf.lift i h hi ≫ hf.snd g = h :=\n  F.map_injective <| by simpa [lift] using PullbackCone.IsLimit.lift_snd _ _ _ _\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift_snd","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom (F.obj c) X\nh : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp i f) (CategoryTheory.CategoryStruct.comp (F.map h) g)\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf.lift i h hi) (hf.snd g)) h","decl":"@[reassoc (attr := simp)]\nlemma lift_snd [Full F] [Faithful F] : hf.lift i h hi ≫ hf.snd g = h :=\n  F.map_injective <| by simpa [lift] using PullbackCone.IsLimit.lift_snd _ _ _ _\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift'_fst","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom c b\nh : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp (F.map i) f') (CategoryTheory.CategoryStruct.comp (F.map h) g)\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf'.lift' i h hi) (hf'.fst' g)) i","decl":"@[reassoc (attr := simp)]\nlemma lift'_fst [Full F] [Faithful F] : hf'.lift' i h hi ≫ hf'.fst' g = i :=\n  F.map_injective (by simp [map_fst', lift'])\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift'_fst_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom c b\nh✝ : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp (F.map i) f') (CategoryTheory.CategoryStruct.comp (F.map h✝) g)\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nZ : C\nh : Quiver.Hom b Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf'.lift' i h✝ hi) (CategoryTheory.CategoryStruct.comp (hf'.fst' g) h)) (CategoryTheory.CategoryStruct.comp i h)","decl":"@[reassoc (attr := simp)]\nlemma lift'_fst [Full F] [Faithful F] : hf'.lift' i h hi ≫ hf'.fst' g = i :=\n  F.map_injective (by simp [map_fst', lift'])\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift'_snd","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom c b\nh : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp (F.map i) f') (CategoryTheory.CategoryStruct.comp (F.map h) g)\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf'.lift' i h hi) (hf'.snd g)) h","decl":"@[reassoc (attr := simp)]\nlemma lift'_snd [Full F] [Faithful F] : hf'.lift' i h hi ≫ hf'.snd g = h := by\n  simp [lift']\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.lift'_snd_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nc : C\ni : Quiver.Hom c b\nh✝ : Quiver.Hom c a\nhi : Eq (CategoryTheory.CategoryStruct.comp (F.map i) f') (CategoryTheory.CategoryStruct.comp (F.map h✝) g)\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nZ : C\nh : Quiver.Hom a Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf'.lift' i h✝ hi) (CategoryTheory.CategoryStruct.comp (hf'.snd g) h)) (CategoryTheory.CategoryStruct.comp h✝ h)","decl":"@[reassoc (attr := simp)]\nlemma lift'_snd [Full F] [Faithful F] : hf'.lift' i h hi ≫ hf'.snd g = h := by\n  simp [lift']\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetry_fst","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (hg.fst' f')) (hf'.snd g)","decl":"@[reassoc (attr := simp)]\nlemma symmetry_fst [Full F] [Faithful F] : hf'.symmetry hg ≫ hg.fst' f' = hf'.snd g := by\n  simp [symmetry]\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetry_fst_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nZ : C\nh : Quiver.Hom a Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (CategoryTheory.CategoryStruct.comp (hg.fst' f') h)) (CategoryTheory.CategoryStruct.comp (hf'.snd g) h)","decl":"@[reassoc (attr := simp)]\nlemma symmetry_fst [Full F] [Faithful F] : hf'.symmetry hg ≫ hg.fst' f' = hf'.snd g := by\n  simp [symmetry]\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetry_snd_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nZ : C\nh : Quiver.Hom b Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (CategoryTheory.CategoryStruct.comp (hg.snd f') h)) (CategoryTheory.CategoryStruct.comp (hf'.fst' g) h)","decl":"@[reassoc (attr := simp)]\nlemma symmetry_snd [Full F] [Faithful F] : hf'.symmetry hg ≫ hg.snd f' = hf'.fst' g := by\n  simp [symmetry]\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetry_snd","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (hg.snd f')) (hf'.fst' g)","decl":"@[reassoc (attr := simp)]\nlemma symmetry_snd [Full F] [Faithful F] : hf'.symmetry hg ≫ hg.snd f' = hf'.fst' g := by\n  simp [symmetry]\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetry_symmetry","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (hg.symmetry hf')) (CategoryTheory.CategoryStruct.id (hf'.pullback g))","decl":"@[reassoc (attr := simp)]\nlemma symmetry_symmetry [Full F] [Faithful F] : hf'.symmetry hg ≫ hg.symmetry hf' = 𝟙 _ :=\n  hom_ext' hf' (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetry_symmetry_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nZ : C\nh : Quiver.Hom (hf'.pullback g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (CategoryTheory.CategoryStruct.comp (hg.symmetry hf') h)) h","decl":"@[reassoc (attr := simp)]\nlemma symmetry_symmetry [Full F] [Faithful F] : hf'.symmetry hg ≫ hg.symmetry hf' = 𝟙 _ :=\n  hom_ext' hf' (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetryIso_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ Eq (hf'.symmetryIso hg).hom (hf'.symmetry hg)","decl":"/-- The isomorphism given by `Presheaf.representable.symmetry`. -/\n@[simps]\nnoncomputable def symmetryIso [Full F] [Faithful F] : hf'.pullback g ≅ hg.pullback f' where\n  hom := hf'.symmetry hg\n  inv := hg.symmetry hf'\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.symmetryIso_inv","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ Eq (hf'.symmetryIso hg).inv (hg.symmetry hf')","decl":"/-- The isomorphism given by `Presheaf.representable.symmetry`. -/\n@[simps]\nnoncomputable def symmetryIso [Full F] [Faithful F] : hf'.pullback g ≅ hg.pullback f' where\n  hom := hf'.symmetry hg\n  inv := hg.symmetry hf'\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.instIsIsoSymmetryOfFaithful","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nY : D\nb : C\nf' : Quiver.Hom (F.obj b) Y\nhf' : F.relativelyRepresentable f'\na : C\ng : Quiver.Hom (F.obj a) Y\nhg : F.relativelyRepresentable g\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ CategoryTheory.IsIso (hf'.symmetry hg)","decl":"instance [Full F] [Faithful F] : IsIso (hf'.symmetry hg) :=\n  (hf'.symmetryIso hg).isIso_hom\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.map","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : F.Full\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\na b : C\nf : Quiver.Hom a b\ninst✝ : ∀ (c : C) (g : Quiver.Hom c b), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) F\n⊢ F.relativelyRepresentable (F.map f)","decl":"/-- When `C` has pullbacks, then `F.map f` is representable with respect to `F` for any\n`f : a ⟶ b` in `C`. -/\nlemma map [Full F] [HasPullbacks C] {a b : C} (f : a ⟶ b)\n    [∀ c (g : c ⟶ b), PreservesLimit (cospan f g) F] :\n    F.relativelyRepresentable (F.map f) := fun c g ↦ by\n  obtain ⟨g, rfl⟩ := F.map_surjective g\n  refine ⟨Limits.pullback f g, Limits.pullback.snd f g, F.map (Limits.pullback.fst f g), ?_⟩\n  apply F.map_isPullback <| IsPullback.of_hasPullback f g\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.of_isIso","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ F.relativelyRepresentable f","decl":"lemma of_isIso {X Y : D} (f : X ⟶ Y) [IsIso f] : F.relativelyRepresentable f :=\n  fun a g ↦ ⟨a, 𝟙 a, g ≫ CategoryTheory.inv f, IsPullback.of_vert_isIso ⟨by simp⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.isomorphisms_le","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ LE.le (CategoryTheory.MorphismProperty.isomorphisms D) F.relativelyRepresentable","decl":"lemma isomorphisms_le : MorphismProperty.isomorphisms D ≤ F.relativelyRepresentable :=\n  fun _ _ f hf ↦ letI : IsIso f := hf; of_isIso F f\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.isMultiplicative","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ F.relativelyRepresentable.IsMultiplicative","decl":"instance isMultiplicative : IsMultiplicative F.relativelyRepresentable where\n  id_mem _ := of_isIso F _\n  comp_mem {F G H} f g hf hg := fun X h ↦\n    ⟨hf.pullback (hg.fst h), hf.snd (hg.fst h) ≫ hg.snd h, hf.fst (hg.fst h),\n      by simpa using IsPullback.paste_vert (hf.isPullback (hg.fst h)) (hg.isPullback h)⟩\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.isStableUnderBaseChange","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ F.relativelyRepresentable.IsStableUnderBaseChange","decl":"instance isStableUnderBaseChange : IsStableUnderBaseChange F.relativelyRepresentable where\n  of_isPullback {X Y Y' X' f g f' g'} P₁ hg a h := by\n    refine ⟨hg.pullback (h ≫ f), hg.snd (h ≫ f), ?_, ?_⟩\n    · apply P₁.lift (hg.fst (h ≫ f)) (F.map (hg.snd (h ≫ f)) ≫ h) (by simpa using hg.w (h ≫ f))\n    · apply IsPullback.of_right' (hg.isPullback (h ≫ f)) P₁\n\n"}
{"name":"CategoryTheory.Functor.relativelyRepresentable.respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\n⊢ F.relativelyRepresentable.RespectsIso","decl":"instance respectsIso : RespectsIso F.relativelyRepresentable :=\n  (isStableUnderBaseChange F).respectsIso\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative.rep","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nP : CategoryTheory.MorphismProperty C\nf : Quiver.Hom X Y\nhf : CategoryTheory.MorphismProperty.relative F P f\n⊢ F.relativelyRepresentable f","decl":"/-- A morphism satisfying `P.relative` is representable. -/\nlemma relative.rep {f : X ⟶ Y} (hf : P.relative F f) : F.relativelyRepresentable f :=\n  hf.1\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative.property","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nP : CategoryTheory.MorphismProperty C\nf : Quiver.Hom X Y\nhf : CategoryTheory.MorphismProperty.relative F P f\na b : C\ng : Quiver.Hom (F.obj a) Y\nfst : Quiver.Hom (F.obj b) X\nsnd : Quiver.Hom b a\nx✝ : CategoryTheory.IsPullback fst (F.map snd) f g\n⊢ P snd","decl":"lemma relative.property {f : X ⟶ Y} (hf : P.relative F f) :\n    ∀ ⦃a b : C⦄ (g : F.obj a ⟶ Y) (fst : F.obj b ⟶ X) (snd : b ⟶ a)\n    (_ : IsPullback fst (F.map snd) f g), P snd :=\n  hf.2\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative.property_snd","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nP : CategoryTheory.MorphismProperty C\nf : Quiver.Hom X Y\nhf : CategoryTheory.MorphismProperty.relative F P f\na : C\ng : Quiver.Hom (F.obj a) Y\n⊢ P (⋯.snd g)","decl":"lemma relative.property_snd {f : X ⟶ Y} (hf : P.relative F f) {a : C} (g : F.obj a ⟶ Y) :\n    P (hf.rep.snd g) :=\n  hf.property g _ _ (hf.rep.isPullback g)\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative.of_exists","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nP : CategoryTheory.MorphismProperty C\ninst✝² : F.Faithful\ninst✝¹ : F.Full\ninst✝ : P.RespectsIso\nf : Quiver.Hom X Y\nh₀ : ∀ ⦃a : C⦄ (g : Quiver.Hom (F.obj a) Y), Exists fun b => Exists fun fst => Exists fun snd => Exists fun x => P snd\n⊢ CategoryTheory.MorphismProperty.relative F P f","decl":"/-- Given a morphism property `P` which respects isomorphisms, then to show that a morphism\n`f : X ⟶ Y` satisfies `P.relative` it suffices to show that:\n* The morphism is representable.\n* For any morphism `g : F.obj a ⟶ G`, the property `P` holds for *some* represented pullback\nof `f` by `g`. -/\nlemma relative.of_exists [F.Faithful] [F.Full] [P.RespectsIso] {f : X ⟶ Y}\n    (h₀ : ∀ ⦃a : C⦄ (g : F.obj a ⟶ Y), ∃ (b : C) (fst : F.obj b ⟶ X) (snd : b ⟶ a)\n      (_ : IsPullback fst (F.map snd) f g), P snd) : P.relative F f := by\n  refine ⟨fun a g ↦ ?_, fun a b g fst snd h ↦ ?_⟩\n  all_goals obtain ⟨c, g_fst, g_snd, BC, H⟩ := h₀ g\n  · refine ⟨c, g_snd, g_fst, BC⟩\n  · refine (P.arrow_mk_iso_iff ?_).2 H\n    exact Arrow.isoMk (F.preimageIso (h.isoIsPullback X (F.obj a) BC)) (Iso.refl _)\n      (F.map_injective (by simp))\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_of_snd","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : D\nP : CategoryTheory.MorphismProperty C\ninst✝² : F.Faithful\ninst✝¹ : F.Full\ninst✝ : P.RespectsIso\nf : Quiver.Hom X Y\nhf : F.relativelyRepresentable f\nh : ∀ ⦃a : C⦄ (g : Quiver.Hom (F.obj a) Y), P (hf.snd g)\n⊢ CategoryTheory.MorphismProperty.relative F P f","decl":"lemma relative_of_snd [F.Faithful] [F.Full] [P.RespectsIso] {f : X ⟶ Y}\n    (hf : F.relativelyRepresentable f) (h : ∀ ⦃a : C⦄ (g : F.obj a ⟶ Y), P (hf.snd g)) :\n    P.relative F f :=\n  relative.of_exists (fun _ g ↦ ⟨hf.pullback g, hf.fst g, hf.snd g, hf.isPullback g, h g⟩)\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_map","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\ninst✝⁴ : F.Faithful\ninst✝³ : F.Full\ninst✝² : CategoryTheory.Limits.HasPullbacks C\ninst✝¹ : P.IsStableUnderBaseChange\na b : C\nf : Quiver.Hom a b\ninst✝ : ∀ (c : C) (g : Quiver.Hom c b), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) F\nhf : P f\n⊢ CategoryTheory.MorphismProperty.relative F P (F.map f)","decl":"/-- If `P : MorphismProperty C` is stable under base change, `F` is fully faithful and preserves\npullbacks, and `C` has all pullbacks, then for any `f : a ⟶ b` in `C`, `F.map f` satisfies\n`P.relative` if `f` satisfies `P`. -/\nlemma relative_map [F.Faithful] [F.Full] [HasPullbacks C] [IsStableUnderBaseChange P]\n    {a b : C} {f : a ⟶ b} [∀ c (g : c ⟶ b), PreservesLimit (cospan f g) F]\n    (hf : P f) : P.relative F (F.map f) := by\n  apply relative.of_exists\n  intro Y' g\n  obtain ⟨g, rfl⟩ := F.map_surjective g\n  exact ⟨_, _, _, (IsPullback.of_hasPullback f g).map F, P.pullback_snd _ _ hf⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.of_relative_map","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\na b : C\nf : Quiver.Hom a b\nhf : CategoryTheory.MorphismProperty.relative F P (F.map f)\n⊢ P f","decl":"lemma of_relative_map {a b : C} {f : a ⟶ b} (hf : P.relative F (F.map f)) : P f :=\n  hf.property (𝟙 _) (𝟙 _) f (IsPullback.id_horiz (F.map f))\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_map_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\ninst✝⁴ : F.Faithful\ninst✝³ : F.Full\ninst✝² : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan F\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\ninst✝ : P.IsStableUnderBaseChange\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.MorphismProperty.relative F P (F.map f)) (P f)","decl":"lemma relative_map_iff [F.Faithful] [F.Full] [PreservesLimitsOfShape WalkingCospan F]\n    [HasPullbacks C] [IsStableUnderBaseChange P] {X Y : C} {f : X ⟶ Y} :\n    P.relative F (F.map f) ↔ P f :=\n  ⟨fun hf ↦ of_relative_map hf, fun hf ↦ relative_map hf⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_monotone","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nP P' : CategoryTheory.MorphismProperty C\nh : LE.le P P'\n⊢ LE.le (CategoryTheory.MorphismProperty.relative F P) (CategoryTheory.MorphismProperty.relative F P')","decl":"/-- If `P' : MorphismProperty C` is satisfied whenever `P` is, then also `P'.relative` is\nsatisfied whenever `P.relative` is. -/\nlemma relative_monotone {P' : MorphismProperty C} (h : P ≤ P') :\n    P.relative F ≤ P'.relative F := fun _ _ _ hf ↦\n  ⟨hf.rep, fun _ _ g fst snd BC ↦ h _ (hf.property g fst snd BC)⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_isStableUnderBaseChange","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\n⊢ (CategoryTheory.MorphismProperty.relative F P).IsStableUnderBaseChange","decl":"lemma relative_isStableUnderBaseChange : IsStableUnderBaseChange (P.relative F) where\n  of_isPullback hfBC hg :=\n    ⟨of_isPullback hfBC hg.rep,\n      fun _ _ _ _ _ BC ↦ hg.property _ _ _ (IsPullback.paste_horiz BC hfBC)⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_isStableUnderComposition","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\ninst✝² : F.Faithful\ninst✝¹ : F.Full\ninst✝ : P.IsStableUnderComposition\n⊢ (CategoryTheory.MorphismProperty.relative F P).IsStableUnderComposition","decl":"instance relative_isStableUnderComposition [F.Faithful] [F.Full] [P.IsStableUnderComposition] :\n    IsStableUnderComposition (P.relative F) where\n  comp_mem {F G H} f g hf hg := by\n    refine ⟨comp_mem _ _ _ hf.1 hg.1, fun Z X p fst snd h ↦ ?_⟩\n    rw [← hg.1.lift_snd (fst ≫ f) snd (by simpa using h.w)]\n    refine comp_mem _ _ _ (hf.property (hg.1.fst p) fst _\n      (IsPullback.of_bot ?_ ?_ (hg.1.isPullback p))) (hg.property_snd p)\n    · rw [← Functor.map_comp, lift_snd]\n      exact h\n    · symm\n      apply hg.1.lift_fst\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\n⊢ (CategoryTheory.MorphismProperty.relative F P).RespectsIso","decl":"instance relative_respectsIso : RespectsIso (P.relative F) :=\n  (relative_isStableUnderBaseChange P).respectsIso\n\n"}
{"name":"CategoryTheory.MorphismProperty.relative_isMultiplicative","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nP : CategoryTheory.MorphismProperty C\ninst✝³ : F.Faithful\ninst✝² : F.Full\ninst✝¹ : P.IsMultiplicative\ninst✝ : P.RespectsIso\n⊢ (CategoryTheory.MorphismProperty.relative F P).IsMultiplicative","decl":"instance relative_isMultiplicative [F.Faithful] [F.Full] [P.IsMultiplicative] [P.RespectsIso] :\n    IsMultiplicative (P.relative F) where\n  id_mem X := relative.of_exists\n    (fun Y g ↦ ⟨Y, g, 𝟙 Y, by simpa using IsPullback.of_id_snd, id_mem _ _⟩)\n\n"}
{"name":"CategoryTheory.MorphismProperty.presheaf_monomorphisms_le_monomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Representable","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ LE.le (CategoryTheory.MorphismProperty.monomorphisms C).presheaf (CategoryTheory.MorphismProperty.monomorphisms (CategoryTheory.Functor (Opposite C) (Type v₁)))","decl":"/-- Morphisms satisfying `(monomorphism C).presheaf` are in particular monomorphisms. -/\nlemma presheaf_monomorphisms_le_monomorphisms :\n    (monomorphisms C).presheaf ≤ monomorphisms _ := fun F G f hf ↦ by\n  suffices ∀ {X : C} {a b : yoneda.obj X ⟶ F}, a ≫ f = b ≫ f → a = b from\n    ⟨fun _ _ h ↦ hom_ext_yoneda (fun _ _ ↦ this (by simp only [assoc, h]))⟩\n  intro X a b h\n  /- It suffices to show that the lifts of `a` and `b` to morphisms\n  `X ⟶ hf.rep.pullback g` are equal, where `g = a ≫ f = a ≫ f`. -/\n  suffices hf.rep.lift (g := a ≫ f) a (𝟙 X) (by simp) =\n      hf.rep.lift b (𝟙 X) (by simp [← h]) by\n    simpa using yoneda.congr_map this =≫ (hf.rep.fst (a ≫ f))\n  -- This follows from the fact that the induced maps `hf.rep.pullback g ⟶ X` are mono.\n  have : Mono (hf.rep.snd (a ≫ f)) := hf.property_snd (a ≫ f)\n  simp only [← cancel_mono (hf.rep.snd (a ≫ f)), lift_snd]\n\n"}
