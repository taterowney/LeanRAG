{"name":"OrderHom.lfp_le","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\na : α\nh : LE.le (f a) a\n⊢ LE.le (OrderHom.lfp f) a","decl":"theorem lfp_le {a : α} (h : f a ≤ a) : f.lfp ≤ a :=\n  sInf_le h\n\n"}
{"name":"OrderHom.lfp_le_fixed","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\na : α\nh : Eq (f a) a\n⊢ LE.le (OrderHom.lfp f) a","decl":"theorem lfp_le_fixed {a : α} (h : f a = a) : f.lfp ≤ a :=\n  f.lfp_le h.le\n\n"}
{"name":"OrderHom.le_lfp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\na : α\nh : ∀ (b : α), LE.le (f b) b → LE.le a b\n⊢ LE.le a (OrderHom.lfp f)","decl":"theorem le_lfp {a : α} (h : ∀ b, f b ≤ b → a ≤ b) : a ≤ f.lfp :=\n  le_sInf h\n\n"}
{"name":"OrderHom.map_le_lfp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\na : α\nha : LE.le a (OrderHom.lfp f)\n⊢ LE.le (f a) (OrderHom.lfp f)","decl":"theorem map_le_lfp {a : α} (ha : a ≤ f.lfp) : f a ≤ f.lfp :=\n  f.le_lfp fun _ hb => (f.mono <| le_sInf_iff.1 ha _ hb).trans hb\n\n"}
{"name":"OrderHom.map_lfp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\n⊢ Eq (f (OrderHom.lfp f)) (OrderHom.lfp f)","decl":"@[simp]\ntheorem map_lfp : f f.lfp = f.lfp :=\n  have h : f f.lfp ≤ f.lfp := f.map_le_lfp le_rfl\n  h.antisymm <| f.lfp_le <| f.mono h\n\n"}
{"name":"OrderHom.isFixedPt_lfp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\n⊢ Function.IsFixedPt (⇑f) (OrderHom.lfp f)","decl":"theorem isFixedPt_lfp : IsFixedPt f f.lfp :=\n  f.map_lfp\n\n"}
{"name":"OrderHom.lfp_le_map","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\na : α\nha : LE.le (OrderHom.lfp f) a\n⊢ LE.le (OrderHom.lfp f) (f a)","decl":"theorem lfp_le_map {a : α} (ha : f.lfp ≤ a) : f.lfp ≤ f a :=\n  calc\n    f.lfp = f f.lfp := f.map_lfp.symm\n    _ ≤ f a := f.mono ha\n\n"}
{"name":"OrderHom.isLeast_lfp_le","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\n⊢ IsLeast (setOf fun a => LE.le (f a) a) (OrderHom.lfp f)","decl":"theorem isLeast_lfp_le : IsLeast { a | f a ≤ a } f.lfp :=\n  ⟨f.map_lfp.le, fun _ => f.lfp_le⟩\n\n"}
{"name":"OrderHom.isLeast_lfp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\n⊢ IsLeast (Function.fixedPoints ⇑f) (OrderHom.lfp f)","decl":"theorem isLeast_lfp : IsLeast (fixedPoints f) f.lfp :=\n  ⟨f.isFixedPt_lfp, fun _ => f.lfp_le_fixed⟩\n\n"}
{"name":"OrderHom.lfp_induction","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\np : α → Prop\nstep : ∀ (a : α), p a → LE.le a (OrderHom.lfp f) → p (f a)\nhSup : ∀ (s : Set α), (∀ (a : α), Membership.mem s a → p a) → p (SupSet.sSup s)\n⊢ p (OrderHom.lfp f)","decl":"theorem lfp_induction {p : α → Prop} (step : ∀ a, p a → a ≤ f.lfp → p (f a))\n    (hSup : ∀ s, (∀ a ∈ s, p a) → p (sSup s)) : p f.lfp := by\n  set s := { a | a ≤ f.lfp ∧ p a }\n  specialize hSup s fun a => And.right\n  suffices sSup s = f.lfp from this ▸ hSup\n  have h : sSup s ≤ f.lfp := sSup_le fun b => And.left\n  have hmem : f (sSup s) ∈ s := ⟨f.map_le_lfp h, step _ hSup h⟩\n  exact h.antisymm (f.lfp_le <| le_sSup hmem)\n\n"}
{"name":"OrderHom.le_gfp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\na : α\nh : LE.le a (f a)\n⊢ LE.le a (OrderHom.gfp f)","decl":"theorem le_gfp {a : α} (h : a ≤ f a) : a ≤ f.gfp :=\n  le_sSup h\n\n"}
{"name":"OrderHom.gfp_le","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\na : α\nh : ∀ (b : α), LE.le b (f b) → LE.le b a\n⊢ LE.le (OrderHom.gfp f) a","decl":"theorem gfp_le {a : α} (h : ∀ b, b ≤ f b → b ≤ a) : f.gfp ≤ a :=\n  sSup_le h\n\n"}
{"name":"OrderHom.isFixedPt_gfp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\n⊢ Function.IsFixedPt (⇑f) (OrderHom.gfp f)","decl":"theorem isFixedPt_gfp : IsFixedPt f f.gfp :=\n  f.dual.isFixedPt_lfp\n\n"}
{"name":"OrderHom.map_gfp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\n⊢ Eq (f (OrderHom.gfp f)) (OrderHom.gfp f)","decl":"@[simp]\ntheorem map_gfp : f f.gfp = f.gfp :=\n  f.dual.map_lfp\n\n"}
{"name":"OrderHom.map_le_gfp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\na : α\nha : LE.le a (OrderHom.gfp f)\n⊢ LE.le (f a) (OrderHom.gfp f)","decl":"theorem map_le_gfp {a : α} (ha : a ≤ f.gfp) : f a ≤ f.gfp :=\n  f.dual.lfp_le_map ha\n\n"}
{"name":"OrderHom.gfp_le_map","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\na : α\nha : LE.le (OrderHom.gfp f) a\n⊢ LE.le (OrderHom.gfp f) (f a)","decl":"theorem gfp_le_map {a : α} (ha : f.gfp ≤ a) : f.gfp ≤ f a :=\n  f.dual.map_le_lfp ha\n\n"}
{"name":"OrderHom.isGreatest_gfp_le","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\n⊢ IsGreatest (setOf fun a => LE.le a (f a)) (OrderHom.gfp f)","decl":"theorem isGreatest_gfp_le : IsGreatest { a | a ≤ f a } f.gfp :=\n  f.dual.isLeast_lfp_le\n\n"}
{"name":"OrderHom.isGreatest_gfp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\n⊢ IsGreatest (Function.fixedPoints ⇑f) (OrderHom.gfp f)","decl":"theorem isGreatest_gfp : IsGreatest (fixedPoints f) f.gfp :=\n  f.dual.isLeast_lfp\n\n"}
{"name":"OrderHom.gfp_induction","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\np : α → Prop\nstep : ∀ (a : α), p a → LE.le (OrderHom.gfp f) a → p (f a)\nhInf : ∀ (s : Set α), (∀ (a : α), Membership.mem s a → p a) → p (InfSet.sInf s)\n⊢ p (OrderHom.gfp f)","decl":"theorem gfp_induction {p : α → Prop} (step : ∀ a, p a → f.gfp ≤ a → p (f a))\n    (hInf : ∀ s, (∀ a ∈ s, p a) → p (sInf s)) : p f.gfp :=\n  f.dual.lfp_induction step hInf\n\n"}
{"name":"OrderHom.map_lfp_comp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : OrderHom β α\ng : OrderHom α β\n⊢ Eq (f (OrderHom.lfp (g.comp f))) (OrderHom.lfp (f.comp g))","decl":"theorem map_lfp_comp : f (g.comp f).lfp = (f.comp g).lfp :=\n  le_antisymm ((f.comp g).map_lfp ▸ f.mono (lfp_le_fixed _ <| congr_arg g (f.comp g).map_lfp)) <|\n    lfp_le _ (congr_arg f (g.comp f).map_lfp).le\n\n"}
{"name":"OrderHom.map_gfp_comp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : OrderHom β α\ng : OrderHom α β\n⊢ Eq (f (OrderHom.gfp (g.comp f))) (OrderHom.gfp (f.comp g))","decl":"theorem map_gfp_comp : f (g.comp f).gfp = (f.comp g).gfp :=\n  f.dual.map_lfp_comp g.dual\n\n-- Diagonal rule\n"}
{"name":"OrderHom.lfp_lfp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nh : OrderHom α (OrderHom α α)\n⊢ Eq (OrderHom.lfp (OrderHom.lfp.comp h)) (OrderHom.lfp h.onDiag)","decl":"theorem lfp_lfp (h : α →o α →o α) : (lfp.comp h).lfp = h.onDiag.lfp := by\n  let a := (lfp.comp h).lfp\n  refine (lfp_le _ ?_).antisymm (lfp_le _ (Eq.le ?_))\n  · exact lfp_le _ h.onDiag.map_lfp.le\n  have ha : (lfp ∘ h) a = a := (lfp.comp h).map_lfp\n  calc\n    h a a = h a (h a).lfp := congr_arg (h a) ha.symm\n    _ = (h a).lfp := (h a).map_lfp\n    _ = a := ha\n\n"}
{"name":"OrderHom.gfp_gfp","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nh : OrderHom α (OrderHom α α)\n⊢ Eq (OrderHom.gfp (OrderHom.gfp.comp h)) (OrderHom.gfp h.onDiag)","decl":"theorem gfp_gfp (h : α →o α →o α) : (gfp.comp h).gfp = h.onDiag.gfp :=\n  @lfp_lfp αᵒᵈ _ <| (OrderHom.dualIso αᵒᵈ αᵒᵈ).symm.toOrderEmbedding.toOrderHom.comp h.dual\n\n"}
{"name":"OrderHom.gfp_const_inf_le","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\nx : α\n⊢ LE.le (OrderHom.gfp (Min.min ((OrderHom.const α) x) f)) x","decl":"theorem gfp_const_inf_le (x : α) : (const α x ⊓ f).gfp ≤ x :=\n  (gfp_le _) fun _ hb => hb.trans inf_le_left\n\n"}
{"name":"OrderHom.prevFixed_le","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\nx : α\nhx : LE.le (f x) x\n⊢ LE.le (↑(f.prevFixed x hx)) x","decl":"theorem prevFixed_le {x : α} (hx : f x ≤ x) : ↑(f.prevFixed x hx) ≤ x :=\n  f.gfp_const_inf_le x\n\n"}
{"name":"OrderHom.le_nextFixed","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\nx : α\nhx : LE.le x (f x)\n⊢ LE.le x ↑(f.nextFixed x hx)","decl":"theorem le_nextFixed {x : α} (hx : x ≤ f x) : x ≤ f.nextFixed x hx :=\n  f.dual.prevFixed_le hx\n\n"}
{"name":"OrderHom.nextFixed_le","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\nx : α\nhx : LE.le x (f x)\ny : ↑(Function.fixedPoints ⇑f)\nh : LE.le x ↑y\n⊢ LE.le (f.nextFixed x hx) y","decl":"theorem nextFixed_le {x : α} (hx : x ≤ f x) {y : fixedPoints f} (h : x ≤ y) :\n    f.nextFixed x hx ≤ y :=\n  Subtype.coe_le_coe.1 <| lfp_le _ <| sup_le h y.2.le\n\n"}
{"name":"OrderHom.nextFixed_le_iff","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\nx : α\nhx : LE.le x (f x)\ny : ↑(Function.fixedPoints ⇑f)\n⊢ Iff (LE.le (f.nextFixed x hx) y) (LE.le x ↑y)","decl":"@[simp]\ntheorem nextFixed_le_iff {x : α} (hx : x ≤ f x) {y : fixedPoints f} :\n    f.nextFixed x hx ≤ y ↔ x ≤ y :=\n  ⟨fun h => (f.le_nextFixed hx).trans h, f.nextFixed_le hx⟩\n\n"}
{"name":"OrderHom.le_prevFixed_iff","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\nx : α\nhx : LE.le (f x) x\ny : ↑(Function.fixedPoints ⇑f)\n⊢ Iff (LE.le y (f.prevFixed x hx)) (LE.le (↑y) x)","decl":"@[simp]\ntheorem le_prevFixed_iff {x : α} (hx : f x ≤ x) {y : fixedPoints f} :\n    y ≤ f.prevFixed x hx ↔ ↑y ≤ x :=\n  f.dual.nextFixed_le_iff hx\n\n"}
{"name":"OrderHom.le_prevFixed","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\nx : α\nhx : LE.le (f x) x\ny : ↑(Function.fixedPoints ⇑f)\nh : LE.le (↑y) x\n⊢ LE.le y (f.prevFixed x hx)","decl":"theorem le_prevFixed {x : α} (hx : f x ≤ x) {y : fixedPoints f} (h : ↑y ≤ x) :\n    y ≤ f.prevFixed x hx :=\n  (f.le_prevFixed_iff hx).2 h\n\n"}
{"name":"OrderHom.le_map_sup_fixedPoints","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\nx y : ↑(Function.fixedPoints ⇑f)\n⊢ LE.le (Max.max ↑x ↑y) (f (Max.max ↑x ↑y))","decl":"theorem le_map_sup_fixedPoints (x y : fixedPoints f) : (x ⊔ y : α) ≤ f (x ⊔ y) :=\n  calc\n    (x ⊔ y : α) = f x ⊔ f y := congr_arg₂ (· ⊔ ·) x.2.symm y.2.symm\n    _ ≤ f (x ⊔ y) := f.mono.le_map_sup x y\n\n-- Porting note: `x ⊓ y` without the `.val`sw fails to synthesize `Inf` instance\n"}
{"name":"OrderHom.map_inf_fixedPoints_le","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\nx y : ↑(Function.fixedPoints ⇑f)\n⊢ LE.le (f (Min.min ↑x ↑y)) (Min.min ↑x ↑y)","decl":"theorem map_inf_fixedPoints_le (x y : fixedPoints f) : f (x ⊓ y) ≤ x.val ⊓ y.val :=\n  f.dual.le_map_sup_fixedPoints x y\n\n"}
{"name":"OrderHom.le_map_sSup_subset_fixedPoints","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\nA : Set α\nhA : HasSubset.Subset A (Function.fixedPoints ⇑f)\n⊢ LE.le (SupSet.sSup A) (f (SupSet.sSup A))","decl":"theorem le_map_sSup_subset_fixedPoints (A : Set α) (hA : A ⊆ fixedPoints f) :\n    sSup A ≤ f (sSup A) :=\n  sSup_le fun _ hx => hA hx ▸ (f.mono <| le_sSup hx)\n\n"}
{"name":"OrderHom.map_sInf_subset_fixedPoints_le","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\nA : Set α\nhA : HasSubset.Subset A (Function.fixedPoints ⇑f)\n⊢ LE.le (f (InfSet.sInf A)) (InfSet.sInf A)","decl":"theorem map_sInf_subset_fixedPoints_le (A : Set α) (hA : A ⊆ fixedPoints f) :\n    f (sInf A) ≤ sInf A :=\n  le_sInf fun _ hx => hA hx ▸ (f.mono <| sInf_le hx)\n\n"}
{"name":"fixedPoints.lfp_eq_sSup_iterate","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\nh : OmegaCompletePartialOrder.ωScottContinuous ⇑f\n⊢ Eq (OrderHom.lfp f) (iSup fun n => Nat.iterate (⇑f) n Bot.bot)","decl":"/-- **Kleene's fixed point Theorem**: The least fixed point in a complete lattice is\nthe supremum of iterating a function on bottom arbitrary often. -/\ntheorem lfp_eq_sSup_iterate (h : ωScottContinuous f) :\n    f.lfp = ⨆ n, f^[n] ⊥ := by\n  apply le_antisymm\n  · apply lfp_le_fixed\n    exact Function.mem_fixedPoints.mp (ωSup_iterate_mem_fixedPoint\n      ⟨f, h.map_ωSup_of_orderHom⟩ ⊥ bot_le)\n  · apply le_lfp\n    intro a h_a\n    exact ωSup_iterate_le_prefixedPoint ⟨f, h.map_ωSup_of_orderHom⟩ ⊥ bot_le h_a bot_le\n\n"}
{"name":"fixedPoints.gfp_eq_sInf_iterate","module":"Mathlib.Order.FixedPoints","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\nf : OrderHom α α\nh : OmegaCompletePartialOrder.ωScottContinuous ⇑(OrderHom.dual f)\n⊢ Eq (OrderHom.gfp f) (iInf fun n => Nat.iterate (⇑f) n Top.top)","decl":"theorem gfp_eq_sInf_iterate (h : ωScottContinuous f.dual) :\n    f.gfp = ⨅ n, f^[n] ⊤ :=\n  lfp_eq_sSup_iterate f.dual h\n\n"}
