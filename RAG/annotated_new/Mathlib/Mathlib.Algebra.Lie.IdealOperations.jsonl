{"name":"LieSubmodule.map_comap_le","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM₂ : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₂\ninst✝ : LieRingModule L M₂\nN₂ : LieSubmodule R L M₂\nf : LieModuleHom R L M M₂\n⊢ LE.le (LieSubmodule.map f (LieSubmodule.comap f N₂)) N₂","decl":"theorem map_comap_le : map f (comap f N₂) ≤ N₂ :=\n  (N₂ : Set M₂).image_preimage_subset f\n\n"}
{"name":"LieSubmodule.map_comap_eq","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM₂ : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₂\ninst✝ : LieRingModule L M₂\nN₂ : LieSubmodule R L M₂\nf : LieModuleHom R L M M₂\nhf : LE.le N₂ f.range\n⊢ Eq (LieSubmodule.map f (LieSubmodule.comap f N₂)) N₂","decl":"theorem map_comap_eq (hf : N₂ ≤ f.range) : map f (comap f N₂) = N₂ := by\n  rw [SetLike.ext'_iff]\n  exact Set.image_preimage_eq_of_subset hf\n\n"}
{"name":"LieSubmodule.le_comap_map","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM₂ : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₂\ninst✝ : LieRingModule L M₂\nN : LieSubmodule R L M\nf : LieModuleHom R L M M₂\n⊢ LE.le N (LieSubmodule.comap f (LieSubmodule.map f N))","decl":"theorem le_comap_map : N ≤ comap f (map f N) :=\n  (N : Set M).subset_preimage_image f\n\n"}
{"name":"LieSubmodule.comap_map_eq","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM₂ : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₂\ninst✝ : LieRingModule L M₂\nN : LieSubmodule R L M\nf : LieModuleHom R L M M₂\nhf : Eq f.ker Bot.bot\n⊢ Eq (LieSubmodule.comap f (LieSubmodule.map f N)) N","decl":"theorem comap_map_eq (hf : f.ker = ⊥) : comap f (map f N) = N := by\n  rw [SetLike.ext'_iff]\n  exact (N : Set M).preimage_image_eq (f.ker_eq_bot.mp hf)\n\n"}
{"name":"LieSubmodule.map_comap_incl","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Eq (LieSubmodule.map N.incl (LieSubmodule.comap N.incl N')) (Min.min N N')","decl":"@[simp]\ntheorem map_comap_incl : map N.incl (comap N.incl N') = N ⊓ N' := by\n  rw [← toSubmodule_inj]\n  exact (N : Submodule R M).map_comap_subtype N'\n\n"}
{"name":"LieSubmodule.lieIdeal_oper_eq_span","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq (Bracket.bracket I N) (LieSubmodule.lieSpan R L (setOf fun x => Exists fun x_1 => Exists fun n => Eq (Bracket.bracket ↑x_1 ↑n) x))","decl":"theorem lieIdeal_oper_eq_span :\n    ⁅I, N⁆ = lieSpan R L { ⁅(x : L), (n : M)⁆ | (x : I) (n : N) } :=\n  rfl\n\n"}
{"name":"LieSubmodule.lieIdeal_oper_eq_linear_span","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\nN : LieSubmodule R L M\ninst✝¹ : LieAlgebra R L\nI : LieIdeal R L\ninst✝ : LieModule R L M\n⊢ Eq (↑(Bracket.bracket I N)) (Submodule.span R (setOf fun x => Exists fun x_1 => Exists fun n => Eq (Bracket.bracket ↑x_1 ↑n) x))","decl":"/-- See also `LieSubmodule.lieIdeal_oper_eq_linear_span'` and\n`LieSubmodule.lieIdeal_oper_eq_tensor_map_range`. -/\ntheorem lieIdeal_oper_eq_linear_span [LieModule R L M] :\n    (↑⁅I, N⁆ : Submodule R M) = Submodule.span R { ⁅(x : L), (n : M)⁆ | (x : I) (n : N) } := by\n  apply le_antisymm\n  · let s := { ⁅(x : L), (n : M)⁆ | (x : I) (n : N) }\n    have aux : ∀ (y : L), ∀ m' ∈ Submodule.span R s, ⁅y, m'⁆ ∈ Submodule.span R s := by\n      intro y m' hm'\n      refine Submodule.span_induction (R := R) (M := M) (s := s)\n        (p := fun m' _ ↦ ⁅y, m'⁆ ∈ Submodule.span R s) ?_ ?_ ?_ ?_ hm'\n      · rintro m'' ⟨x, n, hm''⟩; rw [← hm'', leibniz_lie]\n        refine Submodule.add_mem _ ?_ ?_ <;> apply Submodule.subset_span\n        · use ⟨⁅y, ↑x⁆, I.lie_mem x.property⟩, n\n        · use x, ⟨⁅y, ↑n⁆, N.lie_mem n.property⟩\n      · simp only [lie_zero, Submodule.zero_mem]\n      · intro m₁ m₂ _ _ hm₁ hm₂; rw [lie_add]; exact Submodule.add_mem _ hm₁ hm₂\n      · intro t m'' _ hm''; rw [lie_smul]; exact Submodule.smul_mem _ t hm''\n    change _ ≤ ({ Submodule.span R s with lie_mem := fun hm' => aux _ _ hm' } : LieSubmodule R L M)\n    rw [lieIdeal_oper_eq_span, lieSpan_le]\n    exact Submodule.subset_span\n  · rw [lieIdeal_oper_eq_span]; apply submodule_span_le_lieSpan\n\n"}
{"name":"LieSubmodule.lieIdeal_oper_eq_linear_span'","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\nN : LieSubmodule R L M\ninst✝¹ : LieAlgebra R L\nI : LieIdeal R L\ninst✝ : LieModule R L M\n⊢ Eq (↑(Bracket.bracket I N)) (Submodule.span R (setOf fun x => Exists fun x_1 => And (Membership.mem I x_1) (Exists fun n => And (Membership.mem N n) (Eq (Bracket.bracket x_1 n) x))))","decl":"theorem lieIdeal_oper_eq_linear_span' [LieModule R L M] :\n    (↑⁅I, N⁆ : Submodule R M) = Submodule.span R { ⁅x, n⁆ | (x ∈ I) (n ∈ N) } := by\n  rw [lieIdeal_oper_eq_linear_span]\n  congr\n  ext m\n  constructor\n  · rintro ⟨⟨x, hx⟩, ⟨n, hn⟩, rfl⟩\n    exact ⟨x, hx, n, hn, rfl⟩\n  · rintro ⟨x, hx, n, hn, rfl⟩\n    exact ⟨⟨x, hx⟩, ⟨n, hn⟩, rfl⟩\n\n"}
{"name":"LieSubmodule.lie_le_iff","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN N' : LieSubmodule R L M\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Iff (LE.le (Bracket.bracket I N) N') (∀ (x : L), Membership.mem I x → ∀ (m : M), Membership.mem N m → Membership.mem N' (Bracket.bracket x m))","decl":"theorem lie_le_iff : ⁅I, N⁆ ≤ N' ↔ ∀ x ∈ I, ∀ m ∈ N, ⁅x, m⁆ ∈ N' := by\n  rw [lieIdeal_oper_eq_span, LieSubmodule.lieSpan_le]\n  refine ⟨fun h x hx m hm => h ⟨⟨x, hx⟩, ⟨m, hm⟩, rfl⟩, ?_⟩\n  rintro h _ ⟨⟨x, hx⟩, ⟨m, hm⟩, rfl⟩\n  exact h x hx m hm\n\n"}
{"name":"LieSubmodule.lie_coe_mem_lie","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nx : Subtype fun x => Membership.mem I x\nm : Subtype fun x => Membership.mem N x\n⊢ Membership.mem (Bracket.bracket I N) (Bracket.bracket ↑x ↑m)","decl":"variable {N I} in\ntheorem lie_coe_mem_lie (x : I) (m : N) : ⁅(x : L), (m : M)⁆ ∈ ⁅I, N⁆ := by\n  rw [lieIdeal_oper_eq_span]; apply subset_lieSpan; use x, m\n\n"}
{"name":"LieSubmodule.lie_mem_lie","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nx : L\nm : M\nhx : Membership.mem I x\nhm : Membership.mem N m\n⊢ Membership.mem (Bracket.bracket I N) (Bracket.bracket x m)","decl":"variable {N I} in\ntheorem lie_mem_lie {x : L} {m : M} (hx : x ∈ I) (hm : m ∈ N) : ⁅x, m⁆ ∈ ⁅I, N⁆ :=\n  lie_coe_mem_lie ⟨x, hx⟩ ⟨m, hm⟩\n\n"}
{"name":"LieSubmodule.lie_comm","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI J : LieIdeal R L\n⊢ Eq (Bracket.bracket I J) (Bracket.bracket J I)","decl":"theorem lie_comm : ⁅I, J⁆ = ⁅J, I⁆ := by\n  suffices ∀ I J : LieIdeal R L, ⁅I, J⁆ ≤ ⁅J, I⁆ by exact le_antisymm (this I J) (this J I)\n  clear! I J; intro I J\n  rw [lieIdeal_oper_eq_span, lieSpan_le]; rintro x ⟨y, z, h⟩; rw [← h]\n  rw [← lie_skew, ← lie_neg, ← LieSubmodule.coe_neg]\n  apply lie_coe_mem_lie\n\n"}
{"name":"LieSubmodule.lie_le_right","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ LE.le (Bracket.bracket I N) N","decl":"theorem lie_le_right : ⁅I, N⁆ ≤ N := by\n  rw [lieIdeal_oper_eq_span, lieSpan_le]; rintro m ⟨x, n, hn⟩; rw [← hn]\n  exact N.lie_mem n.property\n\n"}
{"name":"LieSubmodule.lie_le_left","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI J : LieIdeal R L\n⊢ LE.le (Bracket.bracket I J) I","decl":"theorem lie_le_left : ⁅I, J⁆ ≤ I := by rw [lie_comm]; exact lie_le_right I J\n\n"}
{"name":"LieSubmodule.lie_le_inf","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI J : LieIdeal R L\n⊢ LE.le (Bracket.bracket I J) (Min.min I J)","decl":"theorem lie_le_inf : ⁅I, J⁆ ≤ I ⊓ J := by rw [le_inf_iff]; exact ⟨lie_le_left I J, lie_le_right J I⟩\n\n"}
{"name":"LieSubmodule.lie_bot","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq (Bracket.bracket I Bot.bot) Bot.bot","decl":"@[simp]\ntheorem lie_bot : ⁅I, (⊥ : LieSubmodule R L M)⁆ = ⊥ := by rw [eq_bot_iff]; apply lie_le_right\n\n"}
{"name":"LieSubmodule.bot_lie","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieAlgebra R L\n⊢ Eq (Bracket.bracket Bot.bot N) Bot.bot","decl":"@[simp]\ntheorem bot_lie : ⁅(⊥ : LieIdeal R L), N⁆ = ⊥ := by\n  suffices ⁅(⊥ : LieIdeal R L), N⁆ ≤ ⊥ by exact le_bot_iff.mp this\n  rw [lieIdeal_oper_eq_span, lieSpan_le]; rintro m ⟨⟨x, hx⟩, n, hn⟩; rw [← hn]\n  change x ∈ (⊥ : LieIdeal R L) at hx; rw [mem_bot] at hx; simp [hx]\n\n"}
{"name":"LieSubmodule.lie_eq_bot_iff","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Iff (Eq (Bracket.bracket I N) Bot.bot) (∀ (x : L), Membership.mem I x → ∀ (m : M), Membership.mem N m → Eq (Bracket.bracket x m) 0)","decl":"theorem lie_eq_bot_iff : ⁅I, N⁆ = ⊥ ↔ ∀ x ∈ I, ∀ m ∈ N, ⁅(x : L), m⁆ = 0 := by\n  rw [lieIdeal_oper_eq_span, LieSubmodule.lieSpan_eq_bot_iff]\n  refine ⟨fun h x hx m hm => h ⁅x, m⁆ ⟨⟨x, hx⟩, ⟨m, hm⟩, rfl⟩, ?_⟩\n  rintro h - ⟨⟨x, hx⟩, ⟨⟨n, hn⟩, rfl⟩⟩\n  exact h x hx n hn\n\n"}
{"name":"LieSubmodule.mono_lie","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN N' : LieSubmodule R L M\ninst✝ : LieAlgebra R L\nI J : LieIdeal R L\nh₁ : LE.le I J\nh₂ : LE.le N N'\n⊢ LE.le (Bracket.bracket I N) (Bracket.bracket J N')","decl":"variable {I J N N'} in\ntheorem mono_lie (h₁ : I ≤ J) (h₂ : N ≤ N') : ⁅I, N⁆ ≤ ⁅J, N'⁆ := by\n  intro m h\n  rw [lieIdeal_oper_eq_span, mem_lieSpan] at h; rw [lieIdeal_oper_eq_span, mem_lieSpan]\n  intro N hN; apply h; rintro m' ⟨⟨x, hx⟩, ⟨n, hn⟩, hm⟩; rw [← hm]; apply hN\n  use ⟨x, h₁ hx⟩, ⟨n, h₂ hn⟩\n\n"}
{"name":"LieSubmodule.mono_lie_left","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieAlgebra R L\nI J : LieIdeal R L\nh : LE.le I J\n⊢ LE.le (Bracket.bracket I N) (Bracket.bracket J N)","decl":"variable {I J} in\ntheorem mono_lie_left (h : I ≤ J) : ⁅I, N⁆ ≤ ⁅J, N⁆ :=\n  mono_lie h (le_refl N)\n\n"}
{"name":"LieSubmodule.mono_lie_right","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN N' : LieSubmodule R L M\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nh : LE.le N N'\n⊢ LE.le (Bracket.bracket I N) (Bracket.bracket I N')","decl":"variable {N N'} in\ntheorem mono_lie_right (h : N ≤ N') : ⁅I, N⁆ ≤ ⁅I, N'⁆ :=\n  mono_lie (le_refl I) h\n\n"}
{"name":"LieSubmodule.lie_sup","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN N' : LieSubmodule R L M\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq (Bracket.bracket I (Max.max N N')) (Max.max (Bracket.bracket I N) (Bracket.bracket I N'))","decl":"@[simp]\ntheorem lie_sup : ⁅I, N ⊔ N'⁆ = ⁅I, N⁆ ⊔ ⁅I, N'⁆ := by\n  have h : ⁅I, N⁆ ⊔ ⁅I, N'⁆ ≤ ⁅I, N ⊔ N'⁆ := by\n    rw [sup_le_iff]; constructor <;>\n    apply mono_lie_right <;> [exact le_sup_left; exact le_sup_right]\n  suffices ⁅I, N ⊔ N'⁆ ≤ ⁅I, N⁆ ⊔ ⁅I, N'⁆ by exact le_antisymm this h\n  rw [lieIdeal_oper_eq_span, lieSpan_le]; rintro m ⟨x, ⟨n, hn⟩, h⟩; erw [LieSubmodule.mem_sup]\n  rw [LieSubmodule.mem_sup] at hn; rcases hn with ⟨n₁, hn₁, n₂, hn₂, hn'⟩\n  use ⁅(x : L), (⟨n₁, hn₁⟩ : N)⁆; constructor; · apply lie_coe_mem_lie\n  use ⁅(x : L), (⟨n₂, hn₂⟩ : N')⁆; constructor; · apply lie_coe_mem_lie\n  simp [← h, ← hn']\n\n"}
{"name":"LieSubmodule.sup_lie","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieAlgebra R L\nI J : LieIdeal R L\n⊢ Eq (Bracket.bracket (Max.max I J) N) (Max.max (Bracket.bracket I N) (Bracket.bracket J N))","decl":"@[simp]\ntheorem sup_lie : ⁅I ⊔ J, N⁆ = ⁅I, N⁆ ⊔ ⁅J, N⁆ := by\n  have h : ⁅I, N⁆ ⊔ ⁅J, N⁆ ≤ ⁅I ⊔ J, N⁆ := by\n    rw [sup_le_iff]; constructor <;>\n    apply mono_lie_left <;> [exact le_sup_left; exact le_sup_right]\n  suffices ⁅I ⊔ J, N⁆ ≤ ⁅I, N⁆ ⊔ ⁅J, N⁆ by exact le_antisymm this h\n  rw [lieIdeal_oper_eq_span, lieSpan_le]; rintro m ⟨⟨x, hx⟩, n, h⟩; erw [LieSubmodule.mem_sup]\n  rw [LieSubmodule.mem_sup] at hx; rcases hx with ⟨x₁, hx₁, x₂, hx₂, hx'⟩\n  use ⁅((⟨x₁, hx₁⟩ : I) : L), (n : N)⁆; constructor; · apply lie_coe_mem_lie\n  use ⁅((⟨x₂, hx₂⟩ : J) : L), (n : N)⁆; constructor; · apply lie_coe_mem_lie\n  simp [← h, ← hx']\n\n"}
{"name":"LieSubmodule.lie_inf","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN N' : LieSubmodule R L M\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ LE.le (Bracket.bracket I (Min.min N N')) (Min.min (Bracket.bracket I N) (Bracket.bracket I N'))","decl":"theorem lie_inf : ⁅I, N ⊓ N'⁆ ≤ ⁅I, N⁆ ⊓ ⁅I, N'⁆ := by\n  rw [le_inf_iff]; constructor <;>\n  apply mono_lie_right <;> [exact inf_le_left; exact inf_le_right]\n\n"}
{"name":"LieSubmodule.inf_lie","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieAlgebra R L\nI J : LieIdeal R L\n⊢ LE.le (Bracket.bracket (Min.min I J) N) (Min.min (Bracket.bracket I N) (Bracket.bracket J N))","decl":"theorem inf_lie : ⁅I ⊓ J, N⁆ ≤ ⁅I, N⁆ ⊓ ⁅J, N⁆ := by\n  rw [le_inf_iff]; constructor <;>\n  apply mono_lie_left <;> [exact inf_le_left; exact inf_le_right]\n\n"}
{"name":"LieSubmodule.map_bracket_eq","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM₂ : Type w₁\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R M₂\ninst✝³ : LieRingModule L M₂\nN : LieSubmodule R L M\nf : LieModuleHom R L M M₂\ninst✝² : LieAlgebra R L\ninst✝¹ : LieModule R L M₂\nI : LieIdeal R L\ninst✝ : LieModule R L M\n⊢ Eq (LieSubmodule.map f (Bracket.bracket I N)) (Bracket.bracket I (LieSubmodule.map f N))","decl":"theorem map_bracket_eq [LieModule R L M] : map f ⁅I, N⁆ = ⁅I, map f N⁆ := by\n  rw [← toSubmodule_inj, toSubmodule_map, lieIdeal_oper_eq_linear_span,\n    lieIdeal_oper_eq_linear_span, Submodule.map_span]\n  congr\n  ext m\n  constructor\n  · rintro ⟨-, ⟨⟨x, ⟨n, hn⟩, rfl⟩, hm⟩⟩\n    simp only [LieModuleHom.coe_toLinearMap, LieModuleHom.map_lie] at hm\n    exact ⟨x, ⟨f n, (mem_map (f n)).mpr ⟨n, hn, rfl⟩⟩, hm⟩\n  · rintro ⟨x, ⟨m₂, hm₂ : m₂ ∈ map f N⟩, rfl⟩\n    obtain ⟨n, hn, rfl⟩ := (mem_map m₂).mp hm₂\n    exact ⟨⁅x, n⁆, ⟨x, ⟨n, hn⟩, rfl⟩, by simp⟩\n\n"}
{"name":"LieSubmodule.comap_bracket_eq","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM₂ : Type w₁\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module R M₂\ninst✝³ : LieRingModule L M₂\nN₂ : LieSubmodule R L M₂\nf : LieModuleHom R L M M₂\ninst✝² : LieAlgebra R L\ninst✝¹ : LieModule R L M₂\nI : LieIdeal R L\ninst✝ : LieModule R L M\nhf₁ : Eq f.ker Bot.bot\nhf₂ : LE.le N₂ f.range\n⊢ Eq (LieSubmodule.comap f (Bracket.bracket I N₂)) (Bracket.bracket I (LieSubmodule.comap f N₂))","decl":"theorem comap_bracket_eq [LieModule R L M] (hf₁ : f.ker = ⊥) (hf₂ : N₂ ≤ f.range) :\n    comap f ⁅I, N₂⁆ = ⁅I, comap f N₂⁆ := by\n  conv_lhs => rw [← map_comap_eq N₂ f hf₂]\n  rw [← map_bracket_eq, comap_map_eq _ f hf₁]\n\n"}
{"name":"LieIdeal.map_bracket_le","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nf : LieHom R L L'\nI₁ I₂ : LieIdeal R L\n⊢ LE.le (LieIdeal.map f (Bracket.bracket I₁ I₂)) (Bracket.bracket (LieIdeal.map f I₁) (LieIdeal.map f I₂))","decl":"/-- Note that the inequality can be strict; e.g., the inclusion of an Abelian subalgebra of a\nsimple algebra. -/\ntheorem map_bracket_le {I₁ I₂ : LieIdeal R L} : map f ⁅I₁, I₂⁆ ≤ ⁅map f I₁, map f I₂⁆ := by\n  rw [map_le_iff_le_comap]; erw [LieSubmodule.lieSpan_le]\n  intro x hx; obtain ⟨⟨y₁, hy₁⟩, ⟨y₂, hy₂⟩, hx⟩ := hx; rw [← hx]\n  let fy₁ : ↥(map f I₁) := ⟨f y₁, mem_map hy₁⟩\n  let fy₂ : ↥(map f I₂) := ⟨f y₂, mem_map hy₂⟩\n  change _ ∈ comap f ⁅map f I₁, map f I₂⁆\n  simp only [Submodule.coe_mk, mem_comap, LieHom.map_lie]\n  exact LieSubmodule.lie_coe_mem_lie fy₁ fy₂\n\n"}
{"name":"LieIdeal.map_bracket_eq","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nf : LieHom R L L'\nI₁ I₂ : LieIdeal R L\nh : Function.Surjective ⇑f\n⊢ Eq (LieIdeal.map f (Bracket.bracket I₁ I₂)) (Bracket.bracket (LieIdeal.map f I₁) (LieIdeal.map f I₂))","decl":"theorem map_bracket_eq {I₁ I₂ : LieIdeal R L} (h : Function.Surjective f) :\n    map f ⁅I₁, I₂⁆ = ⁅map f I₁, map f I₂⁆ := by\n  suffices ⁅map f I₁, map f I₂⁆ ≤ map f ⁅I₁, I₂⁆ by exact le_antisymm (map_bracket_le f) this\n  rw [← LieSubmodule.toSubmodule_le_toSubmodule, coe_map_of_surjective h,\n    LieSubmodule.lieIdeal_oper_eq_linear_span, LieSubmodule.lieIdeal_oper_eq_linear_span,\n    LinearMap.map_span]\n  apply Submodule.span_mono\n  rintro x ⟨⟨z₁, h₁⟩, ⟨z₂, h₂⟩, rfl⟩\n  obtain ⟨y₁, rfl⟩ := mem_map_of_surjective h h₁\n  obtain ⟨y₂, rfl⟩ := mem_map_of_surjective h h₂\n  exact ⟨⁅(y₁ : L), (y₂ : L)⁆, ⟨y₁, y₂, rfl⟩, by apply f.map_lie⟩\n\n"}
{"name":"LieIdeal.comap_bracket_le","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nf : LieHom R L L'\nJ₁ J₂ : LieIdeal R L'\n⊢ LE.le (Bracket.bracket (LieIdeal.comap f J₁) (LieIdeal.comap f J₂)) (LieIdeal.comap f (Bracket.bracket J₁ J₂))","decl":"theorem comap_bracket_le {J₁ J₂ : LieIdeal R L'} : ⁅comap f J₁, comap f J₂⁆ ≤ comap f ⁅J₁, J₂⁆ := by\n  rw [← map_le_iff_le_comap]\n  exact le_trans (map_bracket_le f) (LieSubmodule.mono_lie map_comap_le map_comap_le)\n\n"}
{"name":"LieIdeal.map_comap_incl","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI₁ I₂ : LieIdeal R L\n⊢ Eq (LieIdeal.map I₁.incl (LieIdeal.comap I₁.incl I₂)) (Min.min I₁ I₂)","decl":"theorem map_comap_incl {I₁ I₂ : LieIdeal R L} : map I₁.incl (comap I₁.incl I₂) = I₁ ⊓ I₂ := by\n  conv_rhs => rw [← I₁.incl_idealRange]\n  rw [← map_comap_eq]\n  exact I₁.incl_isIdealMorphism\n\n"}
{"name":"LieIdeal.comap_bracket_eq","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nf : LieHom R L L'\nJ₁ J₂ : LieIdeal R L'\nh : f.IsIdealMorphism\n⊢ Eq (LieIdeal.comap f (Bracket.bracket (Min.min f.idealRange J₁) (Min.min f.idealRange J₂))) (Max.max (Bracket.bracket (LieIdeal.comap f J₁) (LieIdeal.comap f J₂)) f.ker)","decl":"theorem comap_bracket_eq {J₁ J₂ : LieIdeal R L'} (h : f.IsIdealMorphism) :\n    comap f ⁅f.idealRange ⊓ J₁, f.idealRange ⊓ J₂⁆ = ⁅comap f J₁, comap f J₂⁆ ⊔ f.ker := by\n  rw [← LieSubmodule.toSubmodule_inj, comap_toSubmodule,\n    LieSubmodule.sup_toSubmodule, f.ker_toSubmodule, ← Submodule.comap_map_eq,\n    LieSubmodule.lieIdeal_oper_eq_linear_span, LieSubmodule.lieIdeal_oper_eq_linear_span,\n    LinearMap.map_span]\n  congr; simp only [LieHom.coe_toLinearMap, Set.mem_setOf_eq]; ext y\n  constructor\n  · rintro ⟨⟨x₁, hx₁⟩, ⟨x₂, hx₂⟩, hy⟩; rw [← hy]\n    rw [LieSubmodule.mem_inf, f.mem_idealRange_iff h] at hx₁ hx₂\n    obtain ⟨⟨z₁, hz₁⟩, hz₁'⟩ := hx₁; rw [← hz₁] at hz₁'\n    obtain ⟨⟨z₂, hz₂⟩, hz₂'⟩ := hx₂; rw [← hz₂] at hz₂'\n    refine ⟨⁅z₁, z₂⁆, ⟨⟨z₁, hz₁'⟩, ⟨z₂, hz₂'⟩, rfl⟩, ?_⟩\n    simp only [hz₁, hz₂, Submodule.coe_mk, LieHom.map_lie]\n  · rintro ⟨x, ⟨⟨z₁, hz₁⟩, ⟨z₂, hz₂⟩, hx⟩, hy⟩; rw [← hy, ← hx]\n    have hz₁' : f z₁ ∈ f.idealRange ⊓ J₁ := by\n      rw [LieSubmodule.mem_inf]; exact ⟨f.mem_idealRange z₁, hz₁⟩\n    have hz₂' : f z₂ ∈ f.idealRange ⊓ J₂ := by\n      rw [LieSubmodule.mem_inf]; exact ⟨f.mem_idealRange z₂, hz₂⟩\n    use ⟨f z₁, hz₁'⟩, ⟨f z₂, hz₂'⟩; simp only [Submodule.coe_mk, LieHom.map_lie]\n\n"}
{"name":"LieIdeal.map_comap_bracket_eq","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nf : LieHom R L L'\nJ₁ J₂ : LieIdeal R L'\nh : f.IsIdealMorphism\n⊢ Eq (LieIdeal.map f (Bracket.bracket (LieIdeal.comap f J₁) (LieIdeal.comap f J₂))) (Bracket.bracket (Min.min f.idealRange J₁) (Min.min f.idealRange J₂))","decl":"theorem map_comap_bracket_eq {J₁ J₂ : LieIdeal R L'} (h : f.IsIdealMorphism) :\n    map f ⁅comap f J₁, comap f J₂⁆ = ⁅f.idealRange ⊓ J₁, f.idealRange ⊓ J₂⁆ := by\n  rw [← map_sup_ker_eq_map, ← comap_bracket_eq h, map_comap_eq h, inf_eq_right]\n  exact le_trans (LieSubmodule.lie_le_left _ _) inf_le_left\n\n"}
{"name":"LieIdeal.comap_bracket_incl","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI I₁ I₂ : LieIdeal R L\n⊢ Eq (Bracket.bracket (LieIdeal.comap I.incl I₁) (LieIdeal.comap I.incl I₂)) (LieIdeal.comap I.incl (Bracket.bracket (Min.min I I₁) (Min.min I I₂)))","decl":"theorem comap_bracket_incl {I₁ I₂ : LieIdeal R L} :\n    ⁅comap I.incl I₁, comap I.incl I₂⁆ = comap I.incl ⁅I ⊓ I₁, I ⊓ I₂⁆ := by\n  conv_rhs =>\n    congr\n    next => skip\n    rw [← I.incl_idealRange]\n  rw [comap_bracket_eq]\n  · simp only [ker_incl, sup_bot_eq]\n  · exact I.incl_isIdealMorphism\n\n"}
{"name":"LieIdeal.comap_bracket_incl_of_le","module":"Mathlib.Algebra.Lie.IdealOperations","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI I₁ I₂ : LieIdeal R L\nh₁ : LE.le I₁ I\nh₂ : LE.le I₂ I\n⊢ Eq (Bracket.bracket (LieIdeal.comap I.incl I₁) (LieIdeal.comap I.incl I₂)) (LieIdeal.comap I.incl (Bracket.bracket I₁ I₂))","decl":"/-- This is a very useful result; it allows us to use the fact that inclusion distributes over the\nLie bracket operation on ideals, subject to the conditions shown. -/\ntheorem comap_bracket_incl_of_le {I₁ I₂ : LieIdeal R L} (h₁ : I₁ ≤ I) (h₂ : I₂ ≤ I) :\n    ⁅comap I.incl I₁, comap I.incl I₂⁆ = comap I.incl ⁅I₁, I₂⁆ := by\n    rw [comap_bracket_incl]; rw [← inf_eq_right] at h₁ h₂; rw [h₁, h₂]\n\n"}
