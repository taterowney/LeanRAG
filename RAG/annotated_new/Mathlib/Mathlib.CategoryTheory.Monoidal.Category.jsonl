{"name":"CategoryTheory.MonoidalCategory.associator_naturality","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX₁ X₂ X₃ Y₁ Y₂ Y₃ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\nf₃ : Quiver.Hom X₃ Y₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ f₂) f₃) (CategoryTheory.MonoidalCategoryStruct.associator Y₁ Y₂ Y₃).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X₁ X₂ X₃).hom (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ (CategoryTheory.MonoidalCategoryStruct.tensorHom f₂ f₃)))","decl":"/--\nIn a monoidal category, we can take the tensor product of objects, `X ⊗ Y` and of morphisms `f ⊗ g`.\nTensor product does not need to be strictly associative on objects, but there is a\nspecified associator, `α_ X Y Z : (X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)`. There is a tensor unit `𝟙_ C`,\nwith specified left and right unitor isomorphisms `λ_ X : 𝟙_ C ⊗ X ≅ X` and `ρ_ X : X ⊗ 𝟙_ C ≅ X`.\nThese associators and unitors satisfy the pentagon and triangle equations. -/\n@[stacks 0FFK]\n-- Porting note: The Mathport did not translate the temporary notation\nclass MonoidalCategory (C : Type u) [𝒞 : Category.{v} C] extends MonoidalCategoryStruct C where\n  tensorHom_def {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) :\n    f ⊗ g = (f ▷ X₂) ≫ (Y₁ ◁ g) := by\n      aesop_cat\n  /-- Tensor product of identity maps is the identity: `(𝟙 X₁ ⊗ 𝟙 X₂) = 𝟙 (X₁ ⊗ X₂)` -/\n  tensor_id : ∀ X₁ X₂ : C, 𝟙 X₁ ⊗ 𝟙 X₂ = 𝟙 (X₁ ⊗ X₂) := by aesop_cat\n  /--\n  Composition of tensor products is tensor product of compositions:\n  `(f₁ ⊗ g₁) ∘ (f₂ ⊗ g₂) = (f₁ ∘ f₂) ⊗ (g₁ ⊗ g₂)`\n  -/\n  tensor_comp :\n    ∀ {X₁ Y₁ Z₁ X₂ Y₂ Z₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂),\n      (f₁ ≫ g₁) ⊗ (f₂ ≫ g₂) = (f₁ ⊗ f₂) ≫ (g₁ ⊗ g₂) := by\n    aesop_cat\n  whiskerLeft_id : ∀ (X Y : C), X ◁ 𝟙 Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  id_whiskerRight : ∀ (X Y : C), 𝟙 X ▷ Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  /-- Naturality of the associator isomorphism: `(f₁ ⊗ f₂) ⊗ f₃ ≃ f₁ ⊗ (f₂ ⊗ f₃)` -/\n  associator_naturality :\n    ∀ {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃),\n      ((f₁ ⊗ f₂) ⊗ f₃) ≫ (α_ Y₁ Y₂ Y₃).hom = (α_ X₁ X₂ X₃).hom ≫ (f₁ ⊗ (f₂ ⊗ f₃)) := by\n    aesop_cat\n  /--\n  Naturality of the left unitor, commutativity of `𝟙_ C ⊗ X ⟶ 𝟙_ C ⊗ Y ⟶ Y` and `𝟙_ C ⊗ X ⟶ X ⟶ Y`\n  -/\n  leftUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), 𝟙_ _ ◁ f ≫ (λ_ Y).hom = (λ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  Naturality of the right unitor: commutativity of `X ⊗ 𝟙_ C ⟶ Y ⊗ 𝟙_ C ⟶ Y` and `X ⊗ 𝟙_ C ⟶ X ⟶ Y`\n  -/\n  rightUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), f ▷ 𝟙_ _ ≫ (ρ_ Y).hom = (ρ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  The pentagon identity relating the isomorphism between `X ⊗ (Y ⊗ (Z ⊗ W))` and `((X ⊗ Y) ⊗ Z) ⊗ W`\n  -/\n  pentagon :\n    ∀ W X Y Z : C,\n      (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom =\n        (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom := by\n    aesop_cat\n  /--\n  The identity relating the isomorphisms between `X ⊗ (𝟙_ C ⊗ Y)`, `(X ⊗ 𝟙_ C) ⊗ Y` and `X ⊗ Y`\n  -/\n  triangle :\n    ∀ X Y : C, (α_ X (𝟙_ _) Y).hom ≫ X ◁ (λ_ Y).hom = (ρ_ X).hom ▷ Y := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_naturality","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit f) (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom f)","decl":"/--\nIn a monoidal category, we can take the tensor product of objects, `X ⊗ Y` and of morphisms `f ⊗ g`.\nTensor product does not need to be strictly associative on objects, but there is a\nspecified associator, `α_ X Y Z : (X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)`. There is a tensor unit `𝟙_ C`,\nwith specified left and right unitor isomorphisms `λ_ X : 𝟙_ C ⊗ X ≅ X` and `ρ_ X : X ⊗ 𝟙_ C ≅ X`.\nThese associators and unitors satisfy the pentagon and triangle equations. -/\n@[stacks 0FFK]\n-- Porting note: The Mathport did not translate the temporary notation\nclass MonoidalCategory (C : Type u) [𝒞 : Category.{v} C] extends MonoidalCategoryStruct C where\n  tensorHom_def {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) :\n    f ⊗ g = (f ▷ X₂) ≫ (Y₁ ◁ g) := by\n      aesop_cat\n  /-- Tensor product of identity maps is the identity: `(𝟙 X₁ ⊗ 𝟙 X₂) = 𝟙 (X₁ ⊗ X₂)` -/\n  tensor_id : ∀ X₁ X₂ : C, 𝟙 X₁ ⊗ 𝟙 X₂ = 𝟙 (X₁ ⊗ X₂) := by aesop_cat\n  /--\n  Composition of tensor products is tensor product of compositions:\n  `(f₁ ⊗ g₁) ∘ (f₂ ⊗ g₂) = (f₁ ∘ f₂) ⊗ (g₁ ⊗ g₂)`\n  -/\n  tensor_comp :\n    ∀ {X₁ Y₁ Z₁ X₂ Y₂ Z₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂),\n      (f₁ ≫ g₁) ⊗ (f₂ ≫ g₂) = (f₁ ⊗ f₂) ≫ (g₁ ⊗ g₂) := by\n    aesop_cat\n  whiskerLeft_id : ∀ (X Y : C), X ◁ 𝟙 Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  id_whiskerRight : ∀ (X Y : C), 𝟙 X ▷ Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  /-- Naturality of the associator isomorphism: `(f₁ ⊗ f₂) ⊗ f₃ ≃ f₁ ⊗ (f₂ ⊗ f₃)` -/\n  associator_naturality :\n    ∀ {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃),\n      ((f₁ ⊗ f₂) ⊗ f₃) ≫ (α_ Y₁ Y₂ Y₃).hom = (α_ X₁ X₂ X₃).hom ≫ (f₁ ⊗ (f₂ ⊗ f₃)) := by\n    aesop_cat\n  /--\n  Naturality of the left unitor, commutativity of `𝟙_ C ⊗ X ⟶ 𝟙_ C ⊗ Y ⟶ Y` and `𝟙_ C ⊗ X ⟶ X ⟶ Y`\n  -/\n  leftUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), 𝟙_ _ ◁ f ≫ (λ_ Y).hom = (λ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  Naturality of the right unitor: commutativity of `X ⊗ 𝟙_ C ⟶ Y ⊗ 𝟙_ C ⟶ Y` and `X ⊗ 𝟙_ C ⟶ X ⟶ Y`\n  -/\n  rightUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), f ▷ 𝟙_ _ ≫ (ρ_ Y).hom = (ρ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  The pentagon identity relating the isomorphism between `X ⊗ (Y ⊗ (Z ⊗ W))` and `((X ⊗ Y) ⊗ Z) ⊗ W`\n  -/\n  pentagon :\n    ∀ W X Y Z : C,\n      (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom =\n        (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom := by\n    aesop_cat\n  /--\n  The identity relating the isomorphisms between `X ⊗ (𝟙_ C ⊗ Y)`, `(X ⊗ 𝟙_ C) ⊗ Y` and `X ⊗ Y`\n  -/\n  triangle :\n    ∀ X Y : C, (α_ X (𝟙_ _) Y).hom ≫ X ◁ (λ_ Y).hom = (ρ_ X).hom ▷ Y := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalCategory.rightUnitor_naturality","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom f)","decl":"/--\nIn a monoidal category, we can take the tensor product of objects, `X ⊗ Y` and of morphisms `f ⊗ g`.\nTensor product does not need to be strictly associative on objects, but there is a\nspecified associator, `α_ X Y Z : (X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)`. There is a tensor unit `𝟙_ C`,\nwith specified left and right unitor isomorphisms `λ_ X : 𝟙_ C ⊗ X ≅ X` and `ρ_ X : X ⊗ 𝟙_ C ≅ X`.\nThese associators and unitors satisfy the pentagon and triangle equations. -/\n@[stacks 0FFK]\n-- Porting note: The Mathport did not translate the temporary notation\nclass MonoidalCategory (C : Type u) [𝒞 : Category.{v} C] extends MonoidalCategoryStruct C where\n  tensorHom_def {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) :\n    f ⊗ g = (f ▷ X₂) ≫ (Y₁ ◁ g) := by\n      aesop_cat\n  /-- Tensor product of identity maps is the identity: `(𝟙 X₁ ⊗ 𝟙 X₂) = 𝟙 (X₁ ⊗ X₂)` -/\n  tensor_id : ∀ X₁ X₂ : C, 𝟙 X₁ ⊗ 𝟙 X₂ = 𝟙 (X₁ ⊗ X₂) := by aesop_cat\n  /--\n  Composition of tensor products is tensor product of compositions:\n  `(f₁ ⊗ g₁) ∘ (f₂ ⊗ g₂) = (f₁ ∘ f₂) ⊗ (g₁ ⊗ g₂)`\n  -/\n  tensor_comp :\n    ∀ {X₁ Y₁ Z₁ X₂ Y₂ Z₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂),\n      (f₁ ≫ g₁) ⊗ (f₂ ≫ g₂) = (f₁ ⊗ f₂) ≫ (g₁ ⊗ g₂) := by\n    aesop_cat\n  whiskerLeft_id : ∀ (X Y : C), X ◁ 𝟙 Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  id_whiskerRight : ∀ (X Y : C), 𝟙 X ▷ Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  /-- Naturality of the associator isomorphism: `(f₁ ⊗ f₂) ⊗ f₃ ≃ f₁ ⊗ (f₂ ⊗ f₃)` -/\n  associator_naturality :\n    ∀ {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃),\n      ((f₁ ⊗ f₂) ⊗ f₃) ≫ (α_ Y₁ Y₂ Y₃).hom = (α_ X₁ X₂ X₃).hom ≫ (f₁ ⊗ (f₂ ⊗ f₃)) := by\n    aesop_cat\n  /--\n  Naturality of the left unitor, commutativity of `𝟙_ C ⊗ X ⟶ 𝟙_ C ⊗ Y ⟶ Y` and `𝟙_ C ⊗ X ⟶ X ⟶ Y`\n  -/\n  leftUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), 𝟙_ _ ◁ f ≫ (λ_ Y).hom = (λ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  Naturality of the right unitor: commutativity of `X ⊗ 𝟙_ C ⟶ Y ⊗ 𝟙_ C ⟶ Y` and `X ⊗ 𝟙_ C ⟶ X ⟶ Y`\n  -/\n  rightUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), f ▷ 𝟙_ _ ≫ (ρ_ Y).hom = (ρ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  The pentagon identity relating the isomorphism between `X ⊗ (Y ⊗ (Z ⊗ W))` and `((X ⊗ Y) ⊗ Z) ⊗ W`\n  -/\n  pentagon :\n    ∀ W X Y Z : C,\n      (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom =\n        (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom := by\n    aesop_cat\n  /--\n  The identity relating the isomorphisms between `X ⊗ (𝟙_ C ⊗ Y)`, `(X ⊗ 𝟙_ C) ⊗ Y` and `X ⊗ Y`\n  -/\n  triangle :\n    ∀ X Y : C, (α_ X (𝟙_ _) Y).hom ≫ X ◁ (λ_ Y).hom = (ρ_ X).hom ▷ Y := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_id","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX₁ X₂ : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id X₁) (CategoryTheory.CategoryStruct.id X₂)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂))","decl":"/--\nIn a monoidal category, we can take the tensor product of objects, `X ⊗ Y` and of morphisms `f ⊗ g`.\nTensor product does not need to be strictly associative on objects, but there is a\nspecified associator, `α_ X Y Z : (X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)`. There is a tensor unit `𝟙_ C`,\nwith specified left and right unitor isomorphisms `λ_ X : 𝟙_ C ⊗ X ≅ X` and `ρ_ X : X ⊗ 𝟙_ C ≅ X`.\nThese associators and unitors satisfy the pentagon and triangle equations. -/\n@[stacks 0FFK]\n-- Porting note: The Mathport did not translate the temporary notation\nclass MonoidalCategory (C : Type u) [𝒞 : Category.{v} C] extends MonoidalCategoryStruct C where\n  tensorHom_def {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) :\n    f ⊗ g = (f ▷ X₂) ≫ (Y₁ ◁ g) := by\n      aesop_cat\n  /-- Tensor product of identity maps is the identity: `(𝟙 X₁ ⊗ 𝟙 X₂) = 𝟙 (X₁ ⊗ X₂)` -/\n  tensor_id : ∀ X₁ X₂ : C, 𝟙 X₁ ⊗ 𝟙 X₂ = 𝟙 (X₁ ⊗ X₂) := by aesop_cat\n  /--\n  Composition of tensor products is tensor product of compositions:\n  `(f₁ ⊗ g₁) ∘ (f₂ ⊗ g₂) = (f₁ ∘ f₂) ⊗ (g₁ ⊗ g₂)`\n  -/\n  tensor_comp :\n    ∀ {X₁ Y₁ Z₁ X₂ Y₂ Z₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂),\n      (f₁ ≫ g₁) ⊗ (f₂ ≫ g₂) = (f₁ ⊗ f₂) ≫ (g₁ ⊗ g₂) := by\n    aesop_cat\n  whiskerLeft_id : ∀ (X Y : C), X ◁ 𝟙 Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  id_whiskerRight : ∀ (X Y : C), 𝟙 X ▷ Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  /-- Naturality of the associator isomorphism: `(f₁ ⊗ f₂) ⊗ f₃ ≃ f₁ ⊗ (f₂ ⊗ f₃)` -/\n  associator_naturality :\n    ∀ {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃),\n      ((f₁ ⊗ f₂) ⊗ f₃) ≫ (α_ Y₁ Y₂ Y₃).hom = (α_ X₁ X₂ X₃).hom ≫ (f₁ ⊗ (f₂ ⊗ f₃)) := by\n    aesop_cat\n  /--\n  Naturality of the left unitor, commutativity of `𝟙_ C ⊗ X ⟶ 𝟙_ C ⊗ Y ⟶ Y` and `𝟙_ C ⊗ X ⟶ X ⟶ Y`\n  -/\n  leftUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), 𝟙_ _ ◁ f ≫ (λ_ Y).hom = (λ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  Naturality of the right unitor: commutativity of `X ⊗ 𝟙_ C ⟶ Y ⊗ 𝟙_ C ⟶ Y` and `X ⊗ 𝟙_ C ⟶ X ⟶ Y`\n  -/\n  rightUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), f ▷ 𝟙_ _ ≫ (ρ_ Y).hom = (ρ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  The pentagon identity relating the isomorphism between `X ⊗ (Y ⊗ (Z ⊗ W))` and `((X ⊗ Y) ⊗ Z) ⊗ W`\n  -/\n  pentagon :\n    ∀ W X Y Z : C,\n      (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom =\n        (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom := by\n    aesop_cat\n  /--\n  The identity relating the isomorphisms between `X ⊗ (𝟙_ C ⊗ Y)`, `(X ⊗ 𝟙_ C) ⊗ Y` and `X ⊗ Y`\n  -/\n  triangle :\n    ∀ X Y : C, (α_ X (𝟙_ _) Y).hom ≫ X ◁ (λ_ Y).hom = (ρ_ X).hom ▷ Y := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorHom_def","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX₁ Y₁ X₂ Y₂ : C\nf : Quiver.Hom X₁ Y₁\ng : Quiver.Hom X₂ Y₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X₂) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y₁ g))","decl":"/--\nIn a monoidal category, we can take the tensor product of objects, `X ⊗ Y` and of morphisms `f ⊗ g`.\nTensor product does not need to be strictly associative on objects, but there is a\nspecified associator, `α_ X Y Z : (X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)`. There is a tensor unit `𝟙_ C`,\nwith specified left and right unitor isomorphisms `λ_ X : 𝟙_ C ⊗ X ≅ X` and `ρ_ X : X ⊗ 𝟙_ C ≅ X`.\nThese associators and unitors satisfy the pentagon and triangle equations. -/\n@[stacks 0FFK]\n-- Porting note: The Mathport did not translate the temporary notation\nclass MonoidalCategory (C : Type u) [𝒞 : Category.{v} C] extends MonoidalCategoryStruct C where\n  tensorHom_def {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) :\n    f ⊗ g = (f ▷ X₂) ≫ (Y₁ ◁ g) := by\n      aesop_cat\n  /-- Tensor product of identity maps is the identity: `(𝟙 X₁ ⊗ 𝟙 X₂) = 𝟙 (X₁ ⊗ X₂)` -/\n  tensor_id : ∀ X₁ X₂ : C, 𝟙 X₁ ⊗ 𝟙 X₂ = 𝟙 (X₁ ⊗ X₂) := by aesop_cat\n  /--\n  Composition of tensor products is tensor product of compositions:\n  `(f₁ ⊗ g₁) ∘ (f₂ ⊗ g₂) = (f₁ ∘ f₂) ⊗ (g₁ ⊗ g₂)`\n  -/\n  tensor_comp :\n    ∀ {X₁ Y₁ Z₁ X₂ Y₂ Z₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂),\n      (f₁ ≫ g₁) ⊗ (f₂ ≫ g₂) = (f₁ ⊗ f₂) ≫ (g₁ ⊗ g₂) := by\n    aesop_cat\n  whiskerLeft_id : ∀ (X Y : C), X ◁ 𝟙 Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  id_whiskerRight : ∀ (X Y : C), 𝟙 X ▷ Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  /-- Naturality of the associator isomorphism: `(f₁ ⊗ f₂) ⊗ f₃ ≃ f₁ ⊗ (f₂ ⊗ f₃)` -/\n  associator_naturality :\n    ∀ {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃),\n      ((f₁ ⊗ f₂) ⊗ f₃) ≫ (α_ Y₁ Y₂ Y₃).hom = (α_ X₁ X₂ X₃).hom ≫ (f₁ ⊗ (f₂ ⊗ f₃)) := by\n    aesop_cat\n  /--\n  Naturality of the left unitor, commutativity of `𝟙_ C ⊗ X ⟶ 𝟙_ C ⊗ Y ⟶ Y` and `𝟙_ C ⊗ X ⟶ X ⟶ Y`\n  -/\n  leftUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), 𝟙_ _ ◁ f ≫ (λ_ Y).hom = (λ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  Naturality of the right unitor: commutativity of `X ⊗ 𝟙_ C ⟶ Y ⊗ 𝟙_ C ⟶ Y` and `X ⊗ 𝟙_ C ⟶ X ⟶ Y`\n  -/\n  rightUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), f ▷ 𝟙_ _ ≫ (ρ_ Y).hom = (ρ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  The pentagon identity relating the isomorphism between `X ⊗ (Y ⊗ (Z ⊗ W))` and `((X ⊗ Y) ⊗ Z) ⊗ W`\n  -/\n  pentagon :\n    ∀ W X Y Z : C,\n      (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom =\n        (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom := by\n    aesop_cat\n  /--\n  The identity relating the isomorphisms between `X ⊗ (𝟙_ C ⊗ Y)`, `(X ⊗ 𝟙_ C) ⊗ Y` and `X ⊗ Y`\n  -/\n  triangle :\n    ∀ X Y : C, (α_ X (𝟙_ _) Y).hom ≫ X ◁ (λ_ Y).hom = (ρ_ X).hom ▷ Y := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_id","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))","decl":"/--\nIn a monoidal category, we can take the tensor product of objects, `X ⊗ Y` and of morphisms `f ⊗ g`.\nTensor product does not need to be strictly associative on objects, but there is a\nspecified associator, `α_ X Y Z : (X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)`. There is a tensor unit `𝟙_ C`,\nwith specified left and right unitor isomorphisms `λ_ X : 𝟙_ C ⊗ X ≅ X` and `ρ_ X : X ⊗ 𝟙_ C ≅ X`.\nThese associators and unitors satisfy the pentagon and triangle equations. -/\n@[stacks 0FFK]\n-- Porting note: The Mathport did not translate the temporary notation\nclass MonoidalCategory (C : Type u) [𝒞 : Category.{v} C] extends MonoidalCategoryStruct C where\n  tensorHom_def {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) :\n    f ⊗ g = (f ▷ X₂) ≫ (Y₁ ◁ g) := by\n      aesop_cat\n  /-- Tensor product of identity maps is the identity: `(𝟙 X₁ ⊗ 𝟙 X₂) = 𝟙 (X₁ ⊗ X₂)` -/\n  tensor_id : ∀ X₁ X₂ : C, 𝟙 X₁ ⊗ 𝟙 X₂ = 𝟙 (X₁ ⊗ X₂) := by aesop_cat\n  /--\n  Composition of tensor products is tensor product of compositions:\n  `(f₁ ⊗ g₁) ∘ (f₂ ⊗ g₂) = (f₁ ∘ f₂) ⊗ (g₁ ⊗ g₂)`\n  -/\n  tensor_comp :\n    ∀ {X₁ Y₁ Z₁ X₂ Y₂ Z₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂),\n      (f₁ ≫ g₁) ⊗ (f₂ ≫ g₂) = (f₁ ⊗ f₂) ≫ (g₁ ⊗ g₂) := by\n    aesop_cat\n  whiskerLeft_id : ∀ (X Y : C), X ◁ 𝟙 Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  id_whiskerRight : ∀ (X Y : C), 𝟙 X ▷ Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  /-- Naturality of the associator isomorphism: `(f₁ ⊗ f₂) ⊗ f₃ ≃ f₁ ⊗ (f₂ ⊗ f₃)` -/\n  associator_naturality :\n    ∀ {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃),\n      ((f₁ ⊗ f₂) ⊗ f₃) ≫ (α_ Y₁ Y₂ Y₃).hom = (α_ X₁ X₂ X₃).hom ≫ (f₁ ⊗ (f₂ ⊗ f₃)) := by\n    aesop_cat\n  /--\n  Naturality of the left unitor, commutativity of `𝟙_ C ⊗ X ⟶ 𝟙_ C ⊗ Y ⟶ Y` and `𝟙_ C ⊗ X ⟶ X ⟶ Y`\n  -/\n  leftUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), 𝟙_ _ ◁ f ≫ (λ_ Y).hom = (λ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  Naturality of the right unitor: commutativity of `X ⊗ 𝟙_ C ⟶ Y ⊗ 𝟙_ C ⟶ Y` and `X ⊗ 𝟙_ C ⟶ X ⟶ Y`\n  -/\n  rightUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), f ▷ 𝟙_ _ ≫ (ρ_ Y).hom = (ρ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  The pentagon identity relating the isomorphism between `X ⊗ (Y ⊗ (Z ⊗ W))` and `((X ⊗ Y) ⊗ Z) ⊗ W`\n  -/\n  pentagon :\n    ∀ W X Y Z : C,\n      (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom =\n        (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom := by\n    aesop_cat\n  /--\n  The identity relating the isomorphisms between `X ⊗ (𝟙_ C ⊗ Y)`, `(X ⊗ 𝟙_ C) ⊗ Y` and `X ⊗ Y`\n  -/\n  triangle :\n    ∀ X Y : C, (α_ X (𝟙_ _) Y).hom ≫ X ◁ (λ_ Y).hom = (ρ_ X).hom ▷ Y := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).hom Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z).hom (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom)","decl":"/--\nIn a monoidal category, we can take the tensor product of objects, `X ⊗ Y` and of morphisms `f ⊗ g`.\nTensor product does not need to be strictly associative on objects, but there is a\nspecified associator, `α_ X Y Z : (X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)`. There is a tensor unit `𝟙_ C`,\nwith specified left and right unitor isomorphisms `λ_ X : 𝟙_ C ⊗ X ≅ X` and `ρ_ X : X ⊗ 𝟙_ C ≅ X`.\nThese associators and unitors satisfy the pentagon and triangle equations. -/\n@[stacks 0FFK]\n-- Porting note: The Mathport did not translate the temporary notation\nclass MonoidalCategory (C : Type u) [𝒞 : Category.{v} C] extends MonoidalCategoryStruct C where\n  tensorHom_def {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) :\n    f ⊗ g = (f ▷ X₂) ≫ (Y₁ ◁ g) := by\n      aesop_cat\n  /-- Tensor product of identity maps is the identity: `(𝟙 X₁ ⊗ 𝟙 X₂) = 𝟙 (X₁ ⊗ X₂)` -/\n  tensor_id : ∀ X₁ X₂ : C, 𝟙 X₁ ⊗ 𝟙 X₂ = 𝟙 (X₁ ⊗ X₂) := by aesop_cat\n  /--\n  Composition of tensor products is tensor product of compositions:\n  `(f₁ ⊗ g₁) ∘ (f₂ ⊗ g₂) = (f₁ ∘ f₂) ⊗ (g₁ ⊗ g₂)`\n  -/\n  tensor_comp :\n    ∀ {X₁ Y₁ Z₁ X₂ Y₂ Z₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂),\n      (f₁ ≫ g₁) ⊗ (f₂ ≫ g₂) = (f₁ ⊗ f₂) ≫ (g₁ ⊗ g₂) := by\n    aesop_cat\n  whiskerLeft_id : ∀ (X Y : C), X ◁ 𝟙 Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  id_whiskerRight : ∀ (X Y : C), 𝟙 X ▷ Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  /-- Naturality of the associator isomorphism: `(f₁ ⊗ f₂) ⊗ f₃ ≃ f₁ ⊗ (f₂ ⊗ f₃)` -/\n  associator_naturality :\n    ∀ {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃),\n      ((f₁ ⊗ f₂) ⊗ f₃) ≫ (α_ Y₁ Y₂ Y₃).hom = (α_ X₁ X₂ X₃).hom ≫ (f₁ ⊗ (f₂ ⊗ f₃)) := by\n    aesop_cat\n  /--\n  Naturality of the left unitor, commutativity of `𝟙_ C ⊗ X ⟶ 𝟙_ C ⊗ Y ⟶ Y` and `𝟙_ C ⊗ X ⟶ X ⟶ Y`\n  -/\n  leftUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), 𝟙_ _ ◁ f ≫ (λ_ Y).hom = (λ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  Naturality of the right unitor: commutativity of `X ⊗ 𝟙_ C ⟶ Y ⊗ 𝟙_ C ⟶ Y` and `X ⊗ 𝟙_ C ⟶ X ⟶ Y`\n  -/\n  rightUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), f ▷ 𝟙_ _ ≫ (ρ_ Y).hom = (ρ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  The pentagon identity relating the isomorphism between `X ⊗ (Y ⊗ (Z ⊗ W))` and `((X ⊗ Y) ⊗ Z) ⊗ W`\n  -/\n  pentagon :\n    ∀ W X Y Z : C,\n      (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom =\n        (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom := by\n    aesop_cat\n  /--\n  The identity relating the isomorphisms between `X ⊗ (𝟙_ C ⊗ Y)`, `(X ⊗ 𝟙_ C) ⊗ Y` and `X ⊗ Y`\n  -/\n  triangle :\n    ∀ X Y : C, (α_ X (𝟙_ _) Y).hom ≫ X ◁ (λ_ Y).hom = (ρ_ X).hom ▷ Y := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalCategory.triangle","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X CategoryTheory.MonoidalCategoryStruct.tensorUnit Y).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).hom)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom Y)","decl":"/--\nIn a monoidal category, we can take the tensor product of objects, `X ⊗ Y` and of morphisms `f ⊗ g`.\nTensor product does not need to be strictly associative on objects, but there is a\nspecified associator, `α_ X Y Z : (X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)`. There is a tensor unit `𝟙_ C`,\nwith specified left and right unitor isomorphisms `λ_ X : 𝟙_ C ⊗ X ≅ X` and `ρ_ X : X ⊗ 𝟙_ C ≅ X`.\nThese associators and unitors satisfy the pentagon and triangle equations. -/\n@[stacks 0FFK]\n-- Porting note: The Mathport did not translate the temporary notation\nclass MonoidalCategory (C : Type u) [𝒞 : Category.{v} C] extends MonoidalCategoryStruct C where\n  tensorHom_def {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) :\n    f ⊗ g = (f ▷ X₂) ≫ (Y₁ ◁ g) := by\n      aesop_cat\n  /-- Tensor product of identity maps is the identity: `(𝟙 X₁ ⊗ 𝟙 X₂) = 𝟙 (X₁ ⊗ X₂)` -/\n  tensor_id : ∀ X₁ X₂ : C, 𝟙 X₁ ⊗ 𝟙 X₂ = 𝟙 (X₁ ⊗ X₂) := by aesop_cat\n  /--\n  Composition of tensor products is tensor product of compositions:\n  `(f₁ ⊗ g₁) ∘ (f₂ ⊗ g₂) = (f₁ ∘ f₂) ⊗ (g₁ ⊗ g₂)`\n  -/\n  tensor_comp :\n    ∀ {X₁ Y₁ Z₁ X₂ Y₂ Z₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂),\n      (f₁ ≫ g₁) ⊗ (f₂ ≫ g₂) = (f₁ ⊗ f₂) ≫ (g₁ ⊗ g₂) := by\n    aesop_cat\n  whiskerLeft_id : ∀ (X Y : C), X ◁ 𝟙 Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  id_whiskerRight : ∀ (X Y : C), 𝟙 X ▷ Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  /-- Naturality of the associator isomorphism: `(f₁ ⊗ f₂) ⊗ f₃ ≃ f₁ ⊗ (f₂ ⊗ f₃)` -/\n  associator_naturality :\n    ∀ {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃),\n      ((f₁ ⊗ f₂) ⊗ f₃) ≫ (α_ Y₁ Y₂ Y₃).hom = (α_ X₁ X₂ X₃).hom ≫ (f₁ ⊗ (f₂ ⊗ f₃)) := by\n    aesop_cat\n  /--\n  Naturality of the left unitor, commutativity of `𝟙_ C ⊗ X ⟶ 𝟙_ C ⊗ Y ⟶ Y` and `𝟙_ C ⊗ X ⟶ X ⟶ Y`\n  -/\n  leftUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), 𝟙_ _ ◁ f ≫ (λ_ Y).hom = (λ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  Naturality of the right unitor: commutativity of `X ⊗ 𝟙_ C ⟶ Y ⊗ 𝟙_ C ⟶ Y` and `X ⊗ 𝟙_ C ⟶ X ⟶ Y`\n  -/\n  rightUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), f ▷ 𝟙_ _ ≫ (ρ_ Y).hom = (ρ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  The pentagon identity relating the isomorphism between `X ⊗ (Y ⊗ (Z ⊗ W))` and `((X ⊗ Y) ⊗ Z) ⊗ W`\n  -/\n  pentagon :\n    ∀ W X Y Z : C,\n      (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom =\n        (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom := by\n    aesop_cat\n  /--\n  The identity relating the isomorphisms between `X ⊗ (𝟙_ C ⊗ Y)`, `(X ⊗ 𝟙_ C) ⊗ Y` and `X ⊗ Y`\n  -/\n  triangle :\n    ∀ X Y : C, (α_ X (𝟙_ _) Y).hom ≫ X ◁ (λ_ Y).hom = (ρ_ X).hom ▷ Y := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalCategory.id_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.CategoryStruct.id X) Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))","decl":"/--\nIn a monoidal category, we can take the tensor product of objects, `X ⊗ Y` and of morphisms `f ⊗ g`.\nTensor product does not need to be strictly associative on objects, but there is a\nspecified associator, `α_ X Y Z : (X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)`. There is a tensor unit `𝟙_ C`,\nwith specified left and right unitor isomorphisms `λ_ X : 𝟙_ C ⊗ X ≅ X` and `ρ_ X : X ⊗ 𝟙_ C ≅ X`.\nThese associators and unitors satisfy the pentagon and triangle equations. -/\n@[stacks 0FFK]\n-- Porting note: The Mathport did not translate the temporary notation\nclass MonoidalCategory (C : Type u) [𝒞 : Category.{v} C] extends MonoidalCategoryStruct C where\n  tensorHom_def {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) :\n    f ⊗ g = (f ▷ X₂) ≫ (Y₁ ◁ g) := by\n      aesop_cat\n  /-- Tensor product of identity maps is the identity: `(𝟙 X₁ ⊗ 𝟙 X₂) = 𝟙 (X₁ ⊗ X₂)` -/\n  tensor_id : ∀ X₁ X₂ : C, 𝟙 X₁ ⊗ 𝟙 X₂ = 𝟙 (X₁ ⊗ X₂) := by aesop_cat\n  /--\n  Composition of tensor products is tensor product of compositions:\n  `(f₁ ⊗ g₁) ∘ (f₂ ⊗ g₂) = (f₁ ∘ f₂) ⊗ (g₁ ⊗ g₂)`\n  -/\n  tensor_comp :\n    ∀ {X₁ Y₁ Z₁ X₂ Y₂ Z₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂),\n      (f₁ ≫ g₁) ⊗ (f₂ ≫ g₂) = (f₁ ⊗ f₂) ≫ (g₁ ⊗ g₂) := by\n    aesop_cat\n  whiskerLeft_id : ∀ (X Y : C), X ◁ 𝟙 Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  id_whiskerRight : ∀ (X Y : C), 𝟙 X ▷ Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  /-- Naturality of the associator isomorphism: `(f₁ ⊗ f₂) ⊗ f₃ ≃ f₁ ⊗ (f₂ ⊗ f₃)` -/\n  associator_naturality :\n    ∀ {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃),\n      ((f₁ ⊗ f₂) ⊗ f₃) ≫ (α_ Y₁ Y₂ Y₃).hom = (α_ X₁ X₂ X₃).hom ≫ (f₁ ⊗ (f₂ ⊗ f₃)) := by\n    aesop_cat\n  /--\n  Naturality of the left unitor, commutativity of `𝟙_ C ⊗ X ⟶ 𝟙_ C ⊗ Y ⟶ Y` and `𝟙_ C ⊗ X ⟶ X ⟶ Y`\n  -/\n  leftUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), 𝟙_ _ ◁ f ≫ (λ_ Y).hom = (λ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  Naturality of the right unitor: commutativity of `X ⊗ 𝟙_ C ⟶ Y ⊗ 𝟙_ C ⟶ Y` and `X ⊗ 𝟙_ C ⟶ X ⟶ Y`\n  -/\n  rightUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), f ▷ 𝟙_ _ ≫ (ρ_ Y).hom = (ρ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  The pentagon identity relating the isomorphism between `X ⊗ (Y ⊗ (Z ⊗ W))` and `((X ⊗ Y) ⊗ Z) ⊗ W`\n  -/\n  pentagon :\n    ∀ W X Y Z : C,\n      (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom =\n        (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom := by\n    aesop_cat\n  /--\n  The identity relating the isomorphisms between `X ⊗ (𝟙_ C ⊗ Y)`, `(X ⊗ 𝟙_ C) ⊗ Y` and `X ⊗ Y`\n  -/\n  triangle :\n    ∀ X Y : C, (α_ X (𝟙_ _) Y).hom ≫ X ◁ (λ_ Y).hom = (ρ_ X).hom ▷ Y := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_comp","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX₁ Y₁ Z₁ X₂ Y₂ Z₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\ng₁ : Quiver.Hom Y₁ Z₁\ng₂ : Quiver.Hom Y₂ Z₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.comp f₁ g₁) (CategoryTheory.CategoryStruct.comp f₂ g₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ f₂) (CategoryTheory.MonoidalCategoryStruct.tensorHom g₁ g₂))","decl":"/--\nIn a monoidal category, we can take the tensor product of objects, `X ⊗ Y` and of morphisms `f ⊗ g`.\nTensor product does not need to be strictly associative on objects, but there is a\nspecified associator, `α_ X Y Z : (X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)`. There is a tensor unit `𝟙_ C`,\nwith specified left and right unitor isomorphisms `λ_ X : 𝟙_ C ⊗ X ≅ X` and `ρ_ X : X ⊗ 𝟙_ C ≅ X`.\nThese associators and unitors satisfy the pentagon and triangle equations. -/\n@[stacks 0FFK]\n-- Porting note: The Mathport did not translate the temporary notation\nclass MonoidalCategory (C : Type u) [𝒞 : Category.{v} C] extends MonoidalCategoryStruct C where\n  tensorHom_def {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) :\n    f ⊗ g = (f ▷ X₂) ≫ (Y₁ ◁ g) := by\n      aesop_cat\n  /-- Tensor product of identity maps is the identity: `(𝟙 X₁ ⊗ 𝟙 X₂) = 𝟙 (X₁ ⊗ X₂)` -/\n  tensor_id : ∀ X₁ X₂ : C, 𝟙 X₁ ⊗ 𝟙 X₂ = 𝟙 (X₁ ⊗ X₂) := by aesop_cat\n  /--\n  Composition of tensor products is tensor product of compositions:\n  `(f₁ ⊗ g₁) ∘ (f₂ ⊗ g₂) = (f₁ ∘ f₂) ⊗ (g₁ ⊗ g₂)`\n  -/\n  tensor_comp :\n    ∀ {X₁ Y₁ Z₁ X₂ Y₂ Z₂ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂),\n      (f₁ ≫ g₁) ⊗ (f₂ ≫ g₂) = (f₁ ⊗ f₂) ≫ (g₁ ⊗ g₂) := by\n    aesop_cat\n  whiskerLeft_id : ∀ (X Y : C), X ◁ 𝟙 Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  id_whiskerRight : ∀ (X Y : C), 𝟙 X ▷ Y = 𝟙 (X ⊗ Y) := by\n    aesop_cat\n  /-- Naturality of the associator isomorphism: `(f₁ ⊗ f₂) ⊗ f₃ ≃ f₁ ⊗ (f₂ ⊗ f₃)` -/\n  associator_naturality :\n    ∀ {X₁ X₂ X₃ Y₁ Y₂ Y₃ : C} (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃),\n      ((f₁ ⊗ f₂) ⊗ f₃) ≫ (α_ Y₁ Y₂ Y₃).hom = (α_ X₁ X₂ X₃).hom ≫ (f₁ ⊗ (f₂ ⊗ f₃)) := by\n    aesop_cat\n  /--\n  Naturality of the left unitor, commutativity of `𝟙_ C ⊗ X ⟶ 𝟙_ C ⊗ Y ⟶ Y` and `𝟙_ C ⊗ X ⟶ X ⟶ Y`\n  -/\n  leftUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), 𝟙_ _ ◁ f ≫ (λ_ Y).hom = (λ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  Naturality of the right unitor: commutativity of `X ⊗ 𝟙_ C ⟶ Y ⊗ 𝟙_ C ⟶ Y` and `X ⊗ 𝟙_ C ⟶ X ⟶ Y`\n  -/\n  rightUnitor_naturality :\n    ∀ {X Y : C} (f : X ⟶ Y), f ▷ 𝟙_ _ ≫ (ρ_ Y).hom = (ρ_ X).hom ≫ f := by\n    aesop_cat\n  /--\n  The pentagon identity relating the isomorphism between `X ⊗ (Y ⊗ (Z ⊗ W))` and `((X ⊗ Y) ⊗ Z) ⊗ W`\n  -/\n  pentagon :\n    ∀ W X Y Z : C,\n      (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom =\n        (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom := by\n    aesop_cat\n  /--\n  The identity relating the isomorphisms between `X ⊗ (𝟙_ C ⊗ Y)`, `(X ⊗ 𝟙_ C) ⊗ Y` and `X ⊗ Y`\n  -/\n  triangle :\n    ∀ X Y : C, (α_ X (𝟙_ _) Y).hom ≫ X ◁ (λ_ Y).hom = (ρ_ X).hom ▷ Y := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorHom_def_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX₁ Y₁ X₂ Y₂ : C\nf : Quiver.Hom X₁ Y₁\ng : Quiver.Hom X₂ Y₂\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ Y₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y₁ g) h))","decl":"attribute [reassoc] MonoidalCategory.tensorHom_def\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_id_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.CategoryStruct.id Y)) h) h","decl":"attribute [reassoc, simp] MonoidalCategory.whiskerLeft_id\n"}
{"name":"CategoryTheory.MonoidalCategory.id_whiskerRight_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.CategoryStruct.id X) Y) h) h","decl":"attribute [reassoc, simp] MonoidalCategory.id_whiskerRight\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_comp_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX₁ Y₁ Z₁ X₂ Y₂ Z₂ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\ng₁ : Quiver.Hom Y₁ Z₁\ng₂ : Quiver.Hom Y₂ Z₂\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z₁ Z₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.comp f₁ g₁) (CategoryTheory.CategoryStruct.comp f₂ g₂)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ f₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g₁ g₂) h))","decl":"attribute [reassoc] MonoidalCategory.tensor_comp\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX₁ X₂ X₃ Y₁ Y₂ Y₃ : C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\nf₃ : Quiver.Hom X₃ Y₃\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₂ Y₃)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ f₂) f₃) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Y₁ Y₂ Y₃).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X₁ X₂ X₃).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f₁ (CategoryTheory.MonoidalCategoryStruct.tensorHom f₂ f₃)) h))","decl":"attribute [reassoc] MonoidalCategory.associator_naturality\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom (CategoryTheory.CategoryStruct.comp f h))","decl":"attribute [reassoc] MonoidalCategory.leftUnitor_naturality\n"}
{"name":"CategoryTheory.MonoidalCategory.rightUnitor_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom (CategoryTheory.CategoryStruct.comp f h))","decl":"attribute [reassoc] MonoidalCategory.rightUnitor_naturality\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nW X Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj W (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).hom Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).hom h))","decl":"attribute [reassoc (attr := simp)] MonoidalCategory.pentagon\n"}
{"name":"CategoryTheory.MonoidalCategory.triangle_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X CategoryTheory.MonoidalCategoryStruct.tensorUnit Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).hom) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom Y) h)","decl":"attribute [reassoc (attr := simp)] MonoidalCategory.triangle\n\n"}
{"name":"CategoryTheory.MonoidalCategory.id_tensorHom","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y₁ Y₂ : C\nf : Quiver.Hom Y₁ Y₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id X) f) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)","decl":"@[simp]\ntheorem id_tensorHom (X : C) {Y₁ Y₂ : C} (f : Y₁ ⟶ Y₂) :\n    𝟙 X ⊗ f = X ◁ f := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorHom_id","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX₁ X₂ : C\nf : Quiver.Hom X₁ X₂\nY : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)","decl":"@[simp]\ntheorem tensorHom_id {X₁ X₂ : C} (f : X₁ ⟶ X₂) (Y : C) :\n    f ⊗ 𝟙 Y = f ▷ Y := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_comp_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj W Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W g) h))","decl":"@[reassoc, simp]\ntheorem whiskerLeft_comp (W : C) {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    W ◁ (f ≫ g) = W ◁ f ≫ W ◁ g := by\n  simp only [← id_tensorHom, ← tensor_comp, comp_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_comp","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W f) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W g))","decl":"@[reassoc, simp]\ntheorem whiskerLeft_comp (W : C) {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    W ◁ (f ≫ g) = W ◁ f ≫ W ◁ g := by\n  simp only [← id_tensorHom, ← tensor_comp, comp_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.id_whiskerLeft_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit f) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv h)))","decl":"@[reassoc, simp]\ntheorem id_whiskerLeft {X Y : C} (f : X ⟶ Y) :\n    𝟙_ C ◁ f = (λ_ X).hom ≫ f ≫ (λ_ Y).inv := by\n  rw [← assoc, ← leftUnitor_naturality]; simp [id_tensorHom]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.id_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv))","decl":"@[reassoc, simp]\ntheorem id_whiskerLeft {X Y : C} (f : X ⟶ Y) :\n    𝟙_ C ◁ f = (λ_ X).hom ≫ f ≫ (λ_ Y).inv := by\n  rw [← assoc, ← leftUnitor_naturality]; simp [id_tensorHom]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z Z' : C\nf : Quiver.Hom Z Z'\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y f)) (CategoryTheory.MonoidalCategoryStruct.associator X Y Z').inv))","decl":"@[reassoc, simp]\ntheorem tensor_whiskerLeft (X Y : C) {Z Z' : C} (f : Z ⟶ Z') :\n    (X ⊗ Y) ◁ f = (α_ X Y Z).hom ≫ X ◁ Y ◁ f ≫ (α_ X Y Z').inv := by\n  simp only [← id_tensorHom, ← tensorHom_id]\n  rw [← assoc, ← associator_naturality]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_whiskerLeft_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z✝ Z' : C\nf : Quiver.Hom Z✝ Z'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) f) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z').inv h)))","decl":"@[reassoc, simp]\ntheorem tensor_whiskerLeft (X Y : C) {Z Z' : C} (f : Z ⟶ Z') :\n    (X ⊗ Y) ◁ f = (α_ X Y Z).hom ≫ X ◁ Y ◁ f ≫ (α_ X Y Z').inv := by\n  simp only [← id_tensorHom, ← tensorHom_id]\n  rw [← assoc, ← associator_naturality]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.comp_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\nZ : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.CategoryStruct.comp f g) Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z) (CategoryTheory.MonoidalCategoryStruct.whiskerRight g Z))","decl":"@[reassoc, simp]\ntheorem comp_whiskerRight {W X Y : C} (f : W ⟶ X) (g : X ⟶ Y) (Z : C) :\n    (f ≫ g) ▷ Z = f ▷ Z ≫ g ▷ Z := by\n  simp only [← tensorHom_id, ← tensor_comp, id_comp]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.comp_whiskerRight_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\nZ✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.CategoryStruct.comp f g) Z✝) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight g Z✝) h))","decl":"@[reassoc, simp]\ntheorem comp_whiskerRight {W X Y : C} (f : W ⟶ X) (g : X ⟶ Y) (Z : C) :\n    (f ≫ g) ▷ Z = f ▷ Z ≫ g ▷ Z := by\n  simp only [← tensorHom_id, ← tensor_comp, id_comp]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRight_id","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).inv))","decl":"@[reassoc, simp]\ntheorem whiskerRight_id {X Y : C} (f : X ⟶ Y) :\n    f ▷ 𝟙_ C = (ρ_ X).hom ≫ f ≫ (ρ_ Y).inv := by\n  rw [← assoc, ← rightUnitor_naturality]; simp [tensorHom_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRight_id_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f CategoryTheory.MonoidalCategoryStruct.tensorUnit) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).inv h)))","decl":"@[reassoc, simp]\ntheorem whiskerRight_id {X Y : C} (f : X ⟶ Y) :\n    f ▷ 𝟙_ C = (ρ_ X).hom ≫ f ≫ (ρ_ Y).inv := by\n  rw [← assoc, ← rightUnitor_naturality]; simp [tensorHom_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRight_tensor","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' : C\nf : Quiver.Hom X X'\nY Z : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) Z) (CategoryTheory.MonoidalCategoryStruct.associator X' Y Z).hom))","decl":"@[reassoc, simp]\ntheorem whiskerRight_tensor {X X' : C} (f : X ⟶ X') (Y Z : C) :\n    f ▷ (Y ⊗ Z) = (α_ X Y Z).inv ≫ f ▷ Y ▷ Z ≫ (α_ X' Y Z).hom := by\n  simp only [← id_tensorHom, ← tensorHom_id]\n  rw [associator_naturality]\n  simp [tensor_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRight_tensor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' : C\nf : Quiver.Hom X X'\nY Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X' (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X' Y Z✝).hom h)))","decl":"@[reassoc, simp]\ntheorem whiskerRight_tensor {X X' : C} (f : X ⟶ X') (Y Z : C) :\n    f ▷ (Y ⊗ Z) = (α_ X Y Z).inv ≫ f ▷ Y ▷ Z ≫ (α_ X' Y Z).hom := by\n  simp only [← id_tensorHom, ← tensorHom_id]\n  rw [associator_naturality]\n  simp [tensor_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whisker_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Y' : C\nf : Quiver.Hom Y Y'\nZ : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z)) (CategoryTheory.MonoidalCategoryStruct.associator X Y' Z).inv))","decl":"@[reassoc, simp]\ntheorem whisker_assoc (X : C) {Y Y' : C} (f : Y ⟶ Y') (Z : C) :\n    (X ◁ f) ▷ Z = (α_ X Y Z).hom ≫ X ◁ f ▷ Z ≫ (α_ X Y' Z).inv := by\n  simp only [← id_tensorHom, ← tensorHom_id]\n  rw [← assoc, ← associator_naturality]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whisker_assoc_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Y' : C\nf : Quiver.Hom Y Y'\nZ✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y') Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) Z✝) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y' Z✝).inv h)))","decl":"@[reassoc, simp]\ntheorem whisker_assoc (X : C) {Y Y' : C} (f : Y ⟶ Y') (Z : C) :\n    (X ◁ f) ▷ Z = (α_ X Y Z).hom ≫ X ◁ f ▷ Z ≫ (α_ X Y' Z).inv := by\n  simp only [← id_tensorHom, ← tensorHom_id]\n  rw [← assoc, ← associator_naturality]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whisker_exchange","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W g) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X g))","decl":"@[reassoc]\ntheorem whisker_exchange {W X Y Z : C} (f : W ⟶ X) (g : Y ⟶ Z) :\n    W ◁ g ≫ f ▷ Z = f ▷ Y ≫ X ◁ g := by\n  simp only [← id_tensorHom, ← tensorHom_id, ← tensor_comp, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whisker_exchange_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ : C\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z✝) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X g) h))","decl":"@[reassoc]\ntheorem whisker_exchange {W X Y Z : C} (f : W ⟶ X) (g : Y ⟶ Z) :\n    W ◁ g ≫ f ▷ Z = f ▷ Y ≫ X ◁ g := by\n  simp only [← id_tensorHom, ← tensorHom_id, ← tensor_comp, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorHom_def'","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX₁ Y₁ X₂ Y₂ : C\nf : Quiver.Hom X₁ Y₁\ng : Quiver.Hom X₂ Y₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X₁ g) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y₂))","decl":"@[reassoc]\ntheorem tensorHom_def' {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) :\n    f ⊗ g = X₁ ◁ g ≫ f ▷ Y₂ :=\n  whisker_exchange f g ▸ tensorHom_def f g\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorHom_def'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX₁ Y₁ X₂ Y₂ : C\nf : Quiver.Hom X₁ Y₁\ng : Quiver.Hom X₂ Y₂\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y₁ Y₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X₁ g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y₂) h))","decl":"@[reassoc]\ntheorem tensorHom_def' {X₁ Y₁ X₂ Y₂ : C} (f : X₁ ⟶ Y₁) (g : X₂ ⟶ Y₂) :\n    f ⊗ g = X₁ ◁ g ≫ f ▷ Y₂ :=\n  whisker_exchange f g ▸ tensorHom_def f g\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_hom_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nf : CategoryTheory.Iso Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f.hom) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f.inv)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_hom_inv (X : C) {Y Z : C} (f : Y ≅ Z) :\n    X ◁ f.hom ≫ X ◁ f.inv = 𝟙 (X ⊗ Y) := by\n  rw [← whiskerLeft_comp, hom_inv_id, whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_hom_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z✝ : C\nf : CategoryTheory.Iso Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f.inv) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_hom_inv (X : C) {Y Z : C} (f : Y ≅ Z) :\n    X ◁ f.hom ≫ X ◁ f.inv = 𝟙 (X ⊗ Y) := by\n  rw [← whiskerLeft_comp, hom_inv_id, whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.hom_inv_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : CategoryTheory.Iso X Y\nZ : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom Z) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.inv Z)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X Z))","decl":"@[reassoc (attr := simp)]\ntheorem hom_inv_whiskerRight {X Y : C} (f : X ≅ Y) (Z : C) :\n    f.hom ▷ Z ≫ f.inv ▷ Z = 𝟙 (X ⊗ Z) := by\n  rw [← comp_whiskerRight, hom_inv_id, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.hom_inv_whiskerRight_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : CategoryTheory.Iso X Y\nZ✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.inv Z✝) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem hom_inv_whiskerRight {X Y : C} (f : X ≅ Y) (Z : C) :\n    f.hom ▷ Z ≫ f.inv ▷ Z = 𝟙 (X ⊗ Z) := by\n  rw [← comp_whiskerRight, hom_inv_id, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nf : CategoryTheory.Iso Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f.inv) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f.hom)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X Z))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_inv_hom (X : C) {Y Z : C} (f : Y ≅ Z) :\n    X ◁ f.inv ≫ X ◁ f.hom = 𝟙 (X ⊗ Z) := by\n  rw [← whiskerLeft_comp, inv_hom_id, whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_inv_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z✝ : C\nf : CategoryTheory.Iso Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f.inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f.hom) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_inv_hom (X : C) {Y Z : C} (f : Y ≅ Z) :\n    X ◁ f.inv ≫ X ◁ f.hom = 𝟙 (X ⊗ Z) := by\n  rw [← whiskerLeft_comp, inv_hom_id, whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.inv_hom_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : CategoryTheory.Iso X Y\nZ : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.inv Z) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom Z)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))","decl":"@[reassoc (attr := simp)]\ntheorem inv_hom_whiskerRight {X Y : C} (f : X ≅ Y) (Z : C) :\n    f.inv ▷ Z ≫ f.hom ▷ Z = 𝟙 (Y ⊗ Z) := by\n  rw [← comp_whiskerRight, inv_hom_id, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.inv_hom_whiskerRight_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : CategoryTheory.Iso X Y\nZ✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.inv Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom Z✝) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem inv_hom_whiskerRight {X Y : C} (f : X ≅ Y) (Z : C) :\n    f.inv ▷ Z ≫ f.hom ▷ Z = 𝟙 (Y ⊗ Z) := by\n  rw [← comp_whiskerRight, inv_hom_id, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_hom_inv'","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nf : Quiver.Hom Y Z\ninst✝ : CategoryTheory.IsIso f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.inv f))) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_hom_inv' (X : C) {Y Z : C} (f : Y ⟶ Z) [IsIso f] :\n    X ◁ f ≫ X ◁ inv f = 𝟙 (X ⊗ Y) := by\n  rw [← whiskerLeft_comp, IsIso.hom_inv_id, whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_hom_inv'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y Z✝ : C\nf : Quiver.Hom Y Z✝\ninst✝ : CategoryTheory.IsIso f\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.inv f)) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_hom_inv' (X : C) {Y Z : C} (f : Y ⟶ Z) [IsIso f] :\n    X ◁ f ≫ X ◁ inv f = 𝟙 (X ⊗ Y) := by\n  rw [← whiskerLeft_comp, IsIso.hom_inv_id, whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.hom_inv_whiskerRight'","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\nZ : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.inv f) Z)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X Z))","decl":"@[reassoc (attr := simp)]\ntheorem hom_inv_whiskerRight' {X Y : C} (f : X ⟶ Y) [IsIso f] (Z : C) :\n    f ▷ Z ≫ inv f ▷ Z = 𝟙 (X ⊗ Z) := by\n  rw [← comp_whiskerRight, IsIso.hom_inv_id, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.hom_inv_whiskerRight'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\nZ✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.inv f) Z✝) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem hom_inv_whiskerRight' {X Y : C} (f : X ⟶ Y) [IsIso f] (Z : C) :\n    f ▷ Z ≫ inv f ▷ Z = 𝟙 (X ⊗ Z) := by\n  rw [← comp_whiskerRight, IsIso.hom_inv_id, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_inv_hom'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y Z✝ : C\nf : Quiver.Hom Y Z✝\ninst✝ : CategoryTheory.IsIso f\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.inv f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_inv_hom' (X : C) {Y Z : C} (f : Y ⟶ Z) [IsIso f] :\n    X ◁ inv f ≫ X ◁ f = 𝟙 (X ⊗ Z) := by\n  rw [← whiskerLeft_comp, IsIso.inv_hom_id, whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_inv_hom'","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nf : Quiver.Hom Y Z\ninst✝ : CategoryTheory.IsIso f\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.inv f)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X Z))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_inv_hom' (X : C) {Y Z : C} (f : Y ⟶ Z) [IsIso f] :\n    X ◁ inv f ≫ X ◁ f = 𝟙 (X ⊗ Z) := by\n  rw [← whiskerLeft_comp, IsIso.inv_hom_id, whiskerLeft_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.inv_hom_whiskerRight'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\nZ✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.inv f) Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z✝) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem inv_hom_whiskerRight' {X Y : C} (f : X ⟶ Y) [IsIso f] (Z : C) :\n    inv f ▷ Z ≫ f ▷ Z = 𝟙 (Y ⊗ Z) := by\n  rw [← comp_whiskerRight, IsIso.inv_hom_id, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.inv_hom_whiskerRight'","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\nZ : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.inv f) Z) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))","decl":"@[reassoc (attr := simp)]\ntheorem inv_hom_whiskerRight' {X Y : C} (f : X ⟶ Y) [IsIso f] (Z : C) :\n    inv f ▷ Z ≫ f ▷ Z = 𝟙 (Y ⊗ Z) := by\n  rw [← comp_whiskerRight, IsIso.inv_hom_id, id_whiskerRight]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeftIso_hom","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nf : CategoryTheory.Iso Y Z\n⊢ Eq (CategoryTheory.MonoidalCategory.whiskerLeftIso X f).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f.hom)","decl":"/-- The left whiskering of an isomorphism is an isomorphism. -/\n@[simps]\ndef whiskerLeftIso (X : C) {Y Z : C} (f : Y ≅ Z) : X ⊗ Y ≅ X ⊗ Z where\n  hom := X ◁ f.hom\n  inv := X ◁ f.inv\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeftIso_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nf : CategoryTheory.Iso Y Z\n⊢ Eq (CategoryTheory.MonoidalCategory.whiskerLeftIso X f).inv (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f.inv)","decl":"/-- The left whiskering of an isomorphism is an isomorphism. -/\n@[simps]\ndef whiskerLeftIso (X : C) {Y Z : C} (f : Y ≅ Z) : X ⊗ Y ≅ X ⊗ Z where\n  hom := X ◁ f.hom\n  inv := X ◁ f.inv\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_isIso","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nf : Quiver.Hom Y Z\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.IsIso (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)","decl":"instance whiskerLeft_isIso (X : C) {Y Z : C} (f : Y ⟶ Z) [IsIso f] : IsIso (X ◁ f) :=\n  (whiskerLeftIso X (asIso f)).isIso_hom\n\n"}
{"name":"CategoryTheory.MonoidalCategory.inv_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nf : Quiver.Hom Y Z\ninst✝ : CategoryTheory.IsIso f\n⊢ Eq (CategoryTheory.inv (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.inv f))","decl":"@[simp]\ntheorem inv_whiskerLeft (X : C) {Y Z : C} (f : Y ⟶ Z) [IsIso f] :\n    inv (X ◁ f) = X ◁ inv f := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeftIso_refl","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X : C\n⊢ Eq (CategoryTheory.MonoidalCategory.whiskerLeftIso W (CategoryTheory.Iso.refl X)) (CategoryTheory.Iso.refl (CategoryTheory.MonoidalCategoryStruct.tensorObj W X))","decl":"@[simp]\nlemma whiskerLeftIso_refl (W X : C) :\n    whiskerLeftIso W (Iso.refl X) = Iso.refl (W ⊗ X) :=\n  Iso.ext (whiskerLeft_id W X)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeftIso_trans","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\nf : CategoryTheory.Iso X Y\ng : CategoryTheory.Iso Y Z\n⊢ Eq (CategoryTheory.MonoidalCategory.whiskerLeftIso W (f.trans g)) ((CategoryTheory.MonoidalCategory.whiskerLeftIso W f).trans (CategoryTheory.MonoidalCategory.whiskerLeftIso W g))","decl":"@[simp]\nlemma whiskerLeftIso_trans (W : C) {X Y Z : C} (f : X ≅ Y) (g : Y ≅ Z) :\n    whiskerLeftIso W (f ≪≫ g) = whiskerLeftIso W f ≪≫ whiskerLeftIso W g :=\n  Iso.ext (whiskerLeft_comp W f.hom g.hom)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeftIso_symm","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y : C\nf : CategoryTheory.Iso X Y\n⊢ Eq (CategoryTheory.MonoidalCategory.whiskerLeftIso W f).symm (CategoryTheory.MonoidalCategory.whiskerLeftIso W f.symm)","decl":"@[simp]\nlemma whiskerLeftIso_symm (W : C) {X Y : C} (f : X ≅ Y) :\n    (whiskerLeftIso W f).symm = whiskerLeftIso W f.symm := rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRightIso_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : CategoryTheory.Iso X Y\nZ : C\n⊢ Eq (CategoryTheory.MonoidalCategory.whiskerRightIso f Z).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.inv Z)","decl":"/-- The right whiskering of an isomorphism is an isomorphism. -/\n@[simps!]\ndef whiskerRightIso {X Y : C} (f : X ≅ Y) (Z : C) : X ⊗ Z ≅ Y ⊗ Z where\n  hom := f.hom ▷ Z\n  inv := f.inv ▷ Z\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRightIso_hom","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : CategoryTheory.Iso X Y\nZ : C\n⊢ Eq (CategoryTheory.MonoidalCategory.whiskerRightIso f Z).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom Z)","decl":"/-- The right whiskering of an isomorphism is an isomorphism. -/\n@[simps!]\ndef whiskerRightIso {X Y : C} (f : X ≅ Y) (Z : C) : X ⊗ Z ≅ Y ⊗ Z where\n  hom := f.hom ▷ Z\n  inv := f.inv ▷ Z\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRight_isIso","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.IsIso (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z)","decl":"instance whiskerRight_isIso {X Y : C} (f : X ⟶ Y) (Z : C) [IsIso f] : IsIso (f ▷ Z) :=\n  (whiskerRightIso (asIso f) Z).isIso_hom\n\n"}
{"name":"CategoryTheory.MonoidalCategory.inv_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ninst✝ : CategoryTheory.IsIso f\n⊢ Eq (CategoryTheory.inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.inv f) Z)","decl":"@[simp]\ntheorem inv_whiskerRight {X Y : C} (f : X ⟶ Y) (Z : C) [IsIso f] :\n    inv (f ▷ Z) = inv f ▷ Z := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRightIso_refl","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX W : C\n⊢ Eq (CategoryTheory.MonoidalCategory.whiskerRightIso (CategoryTheory.Iso.refl X) W) (CategoryTheory.Iso.refl (CategoryTheory.MonoidalCategoryStruct.tensorObj X W))","decl":"@[simp]\nlemma whiskerRightIso_refl (X W : C) :\n    whiskerRightIso (Iso.refl X) W = Iso.refl (X ⊗ W) :=\n  Iso.ext (id_whiskerRight X W)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRightIso_trans","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nf : CategoryTheory.Iso X Y\ng : CategoryTheory.Iso Y Z\nW : C\n⊢ Eq (CategoryTheory.MonoidalCategory.whiskerRightIso (f.trans g) W) ((CategoryTheory.MonoidalCategory.whiskerRightIso f W).trans (CategoryTheory.MonoidalCategory.whiskerRightIso g W))","decl":"@[simp]\nlemma whiskerRightIso_trans {X Y Z : C} (f : X ≅ Y) (g : Y ≅ Z) (W : C) :\n    whiskerRightIso (f ≪≫ g) W = whiskerRightIso f W ≪≫ whiskerRightIso g W :=\n  Iso.ext (comp_whiskerRight f.hom g.hom W)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRightIso_symm","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : CategoryTheory.Iso X Y\nW : C\n⊢ Eq (CategoryTheory.MonoidalCategory.whiskerRightIso f W).symm (CategoryTheory.MonoidalCategory.whiskerRightIso f.symm W)","decl":"@[simp]\nlemma whiskerRightIso_symm {X Y : C} (f : X ≅ Y) (W : C) :\n    (whiskerRightIso f W).symm = whiskerRightIso f.symm W := rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorIso_hom","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y X' Y' : C\nf : CategoryTheory.Iso X Y\ng : CategoryTheory.Iso X' Y'\n⊢ Eq (CategoryTheory.MonoidalCategory.tensorIso f g).hom (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom g.hom)","decl":"/-- The tensor product of two isomorphisms is an isomorphism. -/\n@[simps]\ndef tensorIso {X Y X' Y' : C} (f : X ≅ Y)\n    (g : X' ≅ Y') : X ⊗ X' ≅ Y ⊗ Y' where\n  hom := f.hom ⊗ g.hom\n  inv := f.inv ⊗ g.inv\n  hom_inv_id := by rw [← tensor_comp, Iso.hom_inv_id, Iso.hom_inv_id, ← tensor_id]\n  inv_hom_id := by rw [← tensor_comp, Iso.inv_hom_id, Iso.inv_hom_id, ← tensor_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorIso_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y X' Y' : C\nf : CategoryTheory.Iso X Y\ng : CategoryTheory.Iso X' Y'\n⊢ Eq (CategoryTheory.MonoidalCategory.tensorIso f g).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom f.inv g.inv)","decl":"/-- The tensor product of two isomorphisms is an isomorphism. -/\n@[simps]\ndef tensorIso {X Y X' Y' : C} (f : X ≅ Y)\n    (g : X' ≅ Y') : X ⊗ X' ≅ Y ⊗ Y' where\n  hom := f.hom ⊗ g.hom\n  inv := f.inv ⊗ g.inv\n  hom_inv_id := by rw [← tensor_comp, Iso.hom_inv_id, Iso.hom_inv_id, ← tensor_id]\n  inv_hom_id := by rw [← tensor_comp, Iso.inv_hom_id, Iso.inv_hom_id, ← tensor_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorIso_def","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y X' Y' : C\nf : CategoryTheory.Iso X Y\ng : CategoryTheory.Iso X' Y'\n⊢ Eq (CategoryTheory.MonoidalCategory.tensorIso f g) ((CategoryTheory.MonoidalCategory.whiskerRightIso f X').trans (CategoryTheory.MonoidalCategory.whiskerLeftIso Y g))","decl":"theorem tensorIso_def {X Y X' Y' : C} (f : X ≅ Y) (g : X' ≅ Y') :\n    f ⊗ g = whiskerRightIso f X' ≪≫ whiskerLeftIso Y g :=\n  Iso.ext (tensorHom_def f.hom g.hom)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorIso_def'","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y X' Y' : C\nf : CategoryTheory.Iso X Y\ng : CategoryTheory.Iso X' Y'\n⊢ Eq (CategoryTheory.MonoidalCategory.tensorIso f g) ((CategoryTheory.MonoidalCategory.whiskerLeftIso X g).trans (CategoryTheory.MonoidalCategory.whiskerRightIso f Y'))","decl":"theorem tensorIso_def' {X Y X' Y' : C} (f : X ≅ Y) (g : X' ≅ Y') :\n    f ⊗ g = whiskerLeftIso X g ≪≫ whiskerRightIso f Y' :=\n  Iso.ext (tensorHom_def' f.hom g.hom)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_isIso","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.MonoidalCategory C\nW X Y Z : C\nf : Quiver.Hom W X\ninst✝¹ : CategoryTheory.IsIso f\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.IsIso g\n⊢ CategoryTheory.IsIso (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)","decl":"instance tensor_isIso {W X Y Z : C} (f : W ⟶ X) [IsIso f] (g : Y ⟶ Z) [IsIso g] : IsIso (f ⊗ g) :=\n  (asIso f ⊗ asIso g).isIso_hom\n\n"}
{"name":"CategoryTheory.MonoidalCategory.inv_tensor","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.MonoidalCategory C\nW X Y Z : C\nf : Quiver.Hom W X\ninst✝¹ : CategoryTheory.IsIso f\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.IsIso g\n⊢ Eq (CategoryTheory.inv (CategoryTheory.MonoidalCategoryStruct.tensorHom f g)) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.inv f) (CategoryTheory.inv g))","decl":"@[simp]\ntheorem inv_tensor {W X Y Z : C} (f : W ⟶ X) [IsIso f] (g : Y ⟶ Z) [IsIso g] :\n    inv (f ⊗ g) = inv f ⊗ inv g := by\n  simp [tensorHom_def ,whisker_exchange]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_dite","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nP : Prop\ninst✝ : Decidable P\nX Y Z : C\nf : P → Quiver.Hom Y Z\nf' : Not P → Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (dite P (fun h => f h) fun h => f' h)) (dite P (fun h => CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (f h)) fun h => CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (f' h))","decl":"theorem whiskerLeft_dite {P : Prop} [Decidable P]\n    (X : C) {Y Z : C} (f : P → (Y ⟶ Z)) (f' : ¬P → (Y ⟶ Z)) :\n      X ◁ (if h : P then f h else f' h) = if h : P then X ◁ f h else X ◁ f' h := by\n  split_ifs <;> rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.dite_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nP : Prop\ninst✝ : Decidable P\nX Y : C\nf : P → Quiver.Hom X Y\nf' : Not P → Quiver.Hom X Y\nZ : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight (dite P (fun h => f h) fun h => f' h) Z) (dite P (fun h => CategoryTheory.MonoidalCategoryStruct.whiskerRight (f h) Z) fun h => CategoryTheory.MonoidalCategoryStruct.whiskerRight (f' h) Z)","decl":"theorem dite_whiskerRight {P : Prop} [Decidable P]\n    {X Y : C} (f : P → (X ⟶ Y)) (f' : ¬P → (X ⟶ Y)) (Z : C) :\n      (if h : P then f h else f' h) ▷ Z = if h : P then f h ▷ Z else f' h ▷ Z := by\n  split_ifs <;> rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_dite","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nP : Prop\ninst✝ : Decidable P\nW X Y Z : C\nf : Quiver.Hom W X\ng : P → Quiver.Hom Y Z\ng' : Not P → Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f (dite P (fun h => g h) fun h => g' h)) (dite P (fun h => CategoryTheory.MonoidalCategoryStruct.tensorHom f (g h)) fun h => CategoryTheory.MonoidalCategoryStruct.tensorHom f (g' h))","decl":"theorem tensor_dite {P : Prop} [Decidable P] {W X Y Z : C} (f : W ⟶ X) (g : P → (Y ⟶ Z))\n    (g' : ¬P → (Y ⟶ Z)) : (f ⊗ if h : P then g h else g' h) =\n    if h : P then f ⊗ g h else f ⊗ g' h := by split_ifs <;> rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.dite_tensor","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nP : Prop\ninst✝ : Decidable P\nW X Y Z : C\nf : Quiver.Hom W X\ng : P → Quiver.Hom Y Z\ng' : Not P → Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (dite P (fun h => g h) fun h => g' h) f) (dite P (fun h => CategoryTheory.MonoidalCategoryStruct.tensorHom (g h) f) fun h => CategoryTheory.MonoidalCategoryStruct.tensorHom (g' h) f)","decl":"theorem dite_tensor {P : Prop} [Decidable P] {W X Y Z : C} (f : W ⟶ X) (g : P → (Y ⟶ Z))\n    (g' : ¬P → (Y ⟶ Z)) : (if h : P then g h else g' h) ⊗ f =\n    if h : P then g h ⊗ f else g' h ⊗ f := by split_ifs <;> rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_eqToHom","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nf : Eq Y Z\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.eqToHom f)) (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem whiskerLeft_eqToHom (X : C) {Y Z : C} (f : Y = Z) :\n    X ◁ eqToHom f = eqToHom (congr_arg₂ tensorObj rfl f) := by\n  cases f\n  simp only [whiskerLeft_id, eqToHom_refl]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.eqToHom_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Eq X Y\nZ : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eqToHom f) Z) (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem eqToHom_whiskerRight {X Y : C} (f : X = Y) (Z : C) :\n    eqToHom f ▷ Z = eqToHom (congr_arg₂ tensorObj f rfl) := by\n  cases f\n  simp only [id_whiskerRight, eqToHom_refl]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_naturality_left","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' : C\nf : Quiver.Hom X X'\nY Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) Z) (CategoryTheory.MonoidalCategoryStruct.associator X' Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)))","decl":"@[reassoc]\ntheorem associator_naturality_left {X X' : C} (f : X ⟶ X') (Y Z : C) :\n    f ▷ Y ▷ Z ≫ (α_ X' Y Z).hom = (α_ X Y Z).hom ≫ f ▷ (Y ⊗ Z) := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_naturality_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' : C\nf : Quiver.Hom X X'\nY Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X' (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X' Y Z✝).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) h))","decl":"@[reassoc]\ntheorem associator_naturality_left {X X' : C} (f : X ⟶ X') (Y Z : C) :\n    f ▷ Y ▷ Z ≫ (α_ X' Y Z).hom = (α_ X Y Z).hom ≫ f ▷ (Y ⊗ Z) := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_inv_naturality_left","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' : C\nf : Quiver.Hom X X'\nY Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.MonoidalCategoryStruct.associator X' Y Z).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) Z))","decl":"@[reassoc]\ntheorem associator_inv_naturality_left {X X' : C} (f : X ⟶ X') (Y Z : C) :\n    f ▷ (Y ⊗ Z) ≫ (α_ X' Y Z).inv = (α_ X Y Z).inv ≫ f ▷ Y ▷ Z := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_inv_naturality_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' : C\nf : Quiver.Hom X X'\nY Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X' Y) Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X' Y Z✝).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) Z✝) h))","decl":"@[reassoc]\ntheorem associator_inv_naturality_left {X X' : C} (f : X ⟶ X') (Y Z : C) :\n    f ▷ (Y ⊗ Z) ≫ (α_ X' Y Z).inv = (α_ X Y Z).inv ≫ f ▷ Y ▷ Z := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRight_tensor_symm","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' : C\nf : Quiver.Hom X X'\nY Z : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)) (CategoryTheory.MonoidalCategoryStruct.associator X' Y Z).inv))","decl":"@[reassoc]\ntheorem whiskerRight_tensor_symm {X X' : C} (f : X ⟶ X') (Y Z : C) :\n    f ▷ Y ▷ Z = (α_ X Y Z).hom ≫ f ▷ (Y ⊗ Z) ≫ (α_ X' Y Z).inv := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRight_tensor_symm_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' : C\nf : Quiver.Hom X X'\nY Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X' Y) Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y) Z✝) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X' Y Z✝).inv h)))","decl":"@[reassoc]\ntheorem whiskerRight_tensor_symm {X X' : C} (f : X ⟶ X') (Y Z : C) :\n    f ▷ Y ▷ Z = (α_ X Y Z).hom ≫ f ▷ (Y ⊗ Z) ≫ (α_ X' Y Z).inv := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_naturality_middle_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Y' : C\nf : Quiver.Hom Y Y'\nZ✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y' Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y' Z✝).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z✝)) h))","decl":"@[reassoc]\ntheorem associator_naturality_middle (X : C) {Y Y' : C} (f : Y ⟶ Y') (Z : C) :\n    (X ◁ f) ▷ Z ≫ (α_ X Y' Z).hom = (α_ X Y Z).hom ≫ X ◁ f ▷ Z := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_naturality_middle","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Y' : C\nf : Quiver.Hom Y Y'\nZ : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) Z) (CategoryTheory.MonoidalCategoryStruct.associator X Y' Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z)))","decl":"@[reassoc]\ntheorem associator_naturality_middle (X : C) {Y Y' : C} (f : Y ⟶ Y') (Z : C) :\n    (X ◁ f) ▷ Z ≫ (α_ X Y' Z).hom = (α_ X Y Z).hom ≫ X ◁ f ▷ Z := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_inv_naturality_middle","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Y' : C\nf : Quiver.Hom Y Y'\nZ : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z)) (CategoryTheory.MonoidalCategoryStruct.associator X Y' Z).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) Z))","decl":"@[reassoc]\ntheorem associator_inv_naturality_middle (X : C) {Y Y' : C} (f : Y ⟶ Y') (Z : C) :\n    X ◁ f ▷ Z ≫ (α_ X Y' Z).inv = (α_ X Y Z).inv ≫ (X ◁ f) ▷ Z := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_inv_naturality_middle_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Y' : C\nf : Quiver.Hom Y Y'\nZ✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y') Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y' Z✝).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) Z✝) h))","decl":"@[reassoc]\ntheorem associator_inv_naturality_middle (X : C) {Y Y' : C} (f : Y ⟶ Y') (Z : C) :\n    X ◁ f ▷ Z ≫ (α_ X Y' Z).inv = (α_ X Y Z).inv ≫ (X ◁ f) ▷ Z := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whisker_assoc_symm_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Y' : C\nf : Quiver.Hom Y Y'\nZ✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y' Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z✝)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y' Z✝).hom h)))","decl":"@[reassoc]\ntheorem whisker_assoc_symm (X : C) {Y Y' : C} (f : Y ⟶ Y') (Z : C) :\n    X ◁ f ▷ Z = (α_ X Y Z).inv ≫ (X ◁ f) ▷ Z ≫ (α_ X Y' Z).hom := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whisker_assoc_symm","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Y' : C\nf : Quiver.Hom Y Y'\nZ : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) Z) (CategoryTheory.MonoidalCategoryStruct.associator X Y' Z).hom))","decl":"@[reassoc]\ntheorem whisker_assoc_symm (X : C) {Y Y' : C} (f : Y ⟶ Y') (Z : C) :\n    X ◁ f ▷ Z = (α_ X Y Z).inv ≫ (X ◁ f) ▷ Z ≫ (α_ X Y' Z).hom := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_naturality_right","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z Z' : C\nf : Quiver.Hom Z Z'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) f) (CategoryTheory.MonoidalCategoryStruct.associator X Y Z').hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y f)))","decl":"@[reassoc]\ntheorem associator_naturality_right (X Y : C) {Z Z' : C} (f : Z ⟶ Z') :\n    (X ⊗ Y) ◁ f ≫ (α_ X Y Z').hom = (α_ X Y Z).hom ≫ X ◁ Y ◁ f := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_naturality_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z✝ Z' : C\nf : Quiver.Hom Z✝ Z'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z').hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y f)) h))","decl":"@[reassoc]\ntheorem associator_naturality_right (X Y : C) {Z Z' : C} (f : Z ⟶ Z') :\n    (X ⊗ Y) ◁ f ≫ (α_ X Y Z').hom = (α_ X Y Z).hom ≫ X ◁ Y ◁ f := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_inv_naturality_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z✝ Z' : C\nf : Quiver.Hom Z✝ Z'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z').inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) f) h))","decl":"@[reassoc]\ntheorem associator_inv_naturality_right (X Y : C) {Z Z' : C} (f : Z ⟶ Z') :\n    X ◁ Y ◁ f ≫ (α_ X Y Z').inv = (α_ X Y Z).inv ≫ (X ⊗ Y) ◁ f := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_inv_naturality_right","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z Z' : C\nf : Quiver.Hom Z Z'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y f)) (CategoryTheory.MonoidalCategoryStruct.associator X Y Z').inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) f))","decl":"@[reassoc]\ntheorem associator_inv_naturality_right (X Y : C) {Z Z' : C} (f : Z ⟶ Z') :\n    X ◁ Y ◁ f ≫ (α_ X Y Z').inv = (α_ X Y Z).inv ≫ (X ⊗ Y) ◁ f := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_whiskerLeft_symm","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z Z' : C\nf : Quiver.Hom Z Z'\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) f) (CategoryTheory.MonoidalCategoryStruct.associator X Y Z').hom))","decl":"@[reassoc]\ntheorem tensor_whiskerLeft_symm (X Y : C) {Z Z' : C} (f : Z ⟶ Z') :\n    X ◁ Y ◁ f = (α_ X Y Z).inv ≫ (X ⊗ Y) ◁ f ≫ (α_ X Y Z').hom := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_whiskerLeft_symm_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z✝ Z' : C\nf : Quiver.Hom Z✝ Z'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y f)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z').hom h)))","decl":"@[reassoc]\ntheorem tensor_whiskerLeft_symm (X Y : C) {Z Z' : C} (f : Z ⟶ Z') :\n    X ◁ Y ◁ f = (α_ X Y Z).inv ≫ (X ⊗ Y) ◁ f ≫ (α_ X Y Z').hom := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit f) h))","decl":"@[reassoc]\ntheorem leftUnitor_inv_naturality {X Y : C} (f : X ⟶ Y) :\n    f ≫ (λ_ Y).inv = (λ_ X).inv ≫ _ ◁ f := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_inv_naturality","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit f))","decl":"@[reassoc]\ntheorem leftUnitor_inv_naturality {X Y : C} (f : X ⟶ Y) :\n    f ≫ (λ_ Y).inv = (λ_ X).inv ≫ _ ◁ f := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.id_whiskerLeft_symm_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' : C\nf : Quiver.Hom X X'\nZ : C\nh : Quiver.Hom X' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X').hom h)))","decl":"@[reassoc]\ntheorem id_whiskerLeft_symm {X X' : C} (f : X ⟶ X') :\n    f = (λ_ X).inv ≫ 𝟙_ C ◁ f ≫ (λ_ X').hom := by\n  simp only [id_whiskerLeft, assoc, inv_hom_id, comp_id, inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.id_whiskerLeft_symm","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' : C\nf : Quiver.Hom X X'\n⊢ Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit f) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X').hom))","decl":"@[reassoc]\ntheorem id_whiskerLeft_symm {X X' : C} (f : X ⟶ X') :\n    f = (λ_ X).inv ≫ 𝟙_ C ◁ f ≫ (λ_ X').hom := by\n  simp only [id_whiskerLeft, assoc, inv_hom_id, comp_id, inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.rightUnitor_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' : C\nf : Quiver.Hom X X'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X' CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X').inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f CategoryTheory.MonoidalCategoryStruct.tensorUnit) h))","decl":"@[reassoc]\ntheorem rightUnitor_inv_naturality {X X' : C} (f : X ⟶ X') :\n    f ≫ (ρ_ X').inv = (ρ_ X).inv ≫ f ▷ _ := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.rightUnitor_inv_naturality","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' : C\nf : Quiver.Hom X X'\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.MonoidalCategoryStruct.rightUnitor X').inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight f CategoryTheory.MonoidalCategoryStruct.tensorUnit))","decl":"@[reassoc]\ntheorem rightUnitor_inv_naturality {X X' : C} (f : X ⟶ X') :\n    f ≫ (ρ_ X').inv = (ρ_ X).inv ≫ f ▷ _ := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRight_id_symm_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom h)))","decl":"@[reassoc]\ntheorem whiskerRight_id_symm {X Y : C} (f : X ⟶ Y) :\n    f = (ρ_ X).inv ≫ f ▷ 𝟙_ C ≫ (ρ_ Y).hom := by\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRight_id_symm","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq f (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom))","decl":"@[reassoc]\ntheorem whiskerRight_id_symm {X Y : C} (f : X ⟶ Y) :\n    f = (ρ_ X).inv ≫ f ▷ 𝟙_ C ≫ (ρ_ Y).hom := by\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_iff","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf g : Quiver.Hom X Y\n⊢ Iff (Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit f) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft CategoryTheory.MonoidalCategoryStruct.tensorUnit g)) (Eq f g)","decl":"theorem whiskerLeft_iff {X Y : C} (f g : X ⟶ Y) : 𝟙_ C ◁ f = 𝟙_ C ◁ g ↔ f = g := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerRight_iff","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf g : Quiver.Hom X Y\n⊢ Iff (Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f CategoryTheory.MonoidalCategoryStruct.tensorUnit) (CategoryTheory.MonoidalCategoryStruct.whiskerRight g CategoryTheory.MonoidalCategoryStruct.tensorUnit)) (Eq f g)","decl":"theorem whiskerRight_iff {X Y : C} (f g : X ⟶ Y) : f ▷ 𝟙_ C = g ▷ 𝟙_ C ↔ f = g := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y) Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).inv Z✝) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z✝).inv h))","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_inv :\n    W ◁ (α_ X Y Z).inv ≫ (α_ W (X ⊗ Y) Z).inv ≫ (α_ W X Y).inv ▷ Z =\n      (α_ W X (Y ⊗ Z)).inv ≫ (α_ (W ⊗ X) Y Z).inv :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).inv Z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).inv (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z).inv)","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_inv :\n    W ◁ (α_ X Y Z).inv ≫ (α_ W (X ⊗ Y) Z).inv ≫ (α_ W X Y).inv ▷ Z =\n      (α_ W X (Y ⊗ Z)).inv ≫ (α_ (W ⊗ X) Y Z).inv :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_inv_inv_hom_hom_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).inv Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z✝).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).inv h))","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_inv_inv_hom_hom_inv :\n    (α_ W (X ⊗ Y) Z).inv ≫ (α_ W X Y).inv ▷ Z ≫ (α_ (W ⊗ X) Y Z).hom =\n      W ◁ (α_ X Y Z).hom ≫ (α_ W X (Y ⊗ Z)).inv := by\n  rw [← cancel_epi (W ◁ (α_ X Y Z).inv), ← cancel_mono (α_ (W ⊗ X) Y Z).inv]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_inv_inv_hom_hom_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).inv Z) (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).inv)","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_inv_inv_hom_hom_inv :\n    (α_ W (X ⊗ Y) Z).inv ≫ (α_ W X Y).inv ▷ Z ≫ (α_ (W ⊗ X) Y Z).hom =\n      W ◁ (α_ X Y Z).hom ≫ (α_ W X (Y ⊗ Z)).inv := by\n  rw [← cancel_epi (W ◁ (α_ X Y Z).inv), ← cancel_mono (α_ (W ⊗ X) Y Z).inv]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_inv_hom_hom_hom_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).hom Z) (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv))","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_inv_hom_hom_hom_inv :\n    (α_ (W ⊗ X) Y Z).inv ≫ (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom =\n      (α_ W X (Y ⊗ Z)).hom ≫ W ◁ (α_ X Y Z).inv :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_inv_hom_hom_hom_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj W (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).hom Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv) h))","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_inv_hom_hom_hom_inv :\n    (α_ (W ⊗ X) Y Z).inv ≫ (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom =\n      (α_ W X (Y ⊗ Z)).hom ≫ W ◁ (α_ X Y Z).inv :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_hom_inv_inv_inv_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).inv (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z).inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).inv Z))","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_hom_inv_inv_inv_inv :\n    W ◁ (α_ X Y Z).hom ≫ (α_ W X (Y ⊗ Z)).inv ≫ (α_ (W ⊗ X) Y Z).inv =\n      (α_ W (X ⊗ Y) Z).inv ≫ (α_ W X Y).inv ▷ Z := by\n  simp [← cancel_epi (W ◁ (α_ X Y Z).inv)]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_hom_inv_inv_inv_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y) Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z✝).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).inv Z✝) h))","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_hom_inv_inv_inv_inv :\n    W ◁ (α_ X Y Z).hom ≫ (α_ W X (Y ⊗ Z)).inv ≫ (α_ (W ⊗ X) Y Z).inv =\n      (α_ W (X ⊗ Y) Z).inv ≫ (α_ W X Y).inv ▷ Z := by\n  simp [← cancel_epi (W ◁ (α_ X Y Z).inv)]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_hom_hom_inv_hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).hom Z) (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom)","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_hom_hom_inv_hom_hom :\n    (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom ≫ W ◁ (α_ X Y Z).inv =\n      (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_hom_hom_inv_hom_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj W (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).hom Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).hom h))","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_hom_hom_inv_hom_hom :\n    (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom ≫ W ◁ (α_ X Y Z).inv =\n      (α_ W X Y).hom ▷ Z ≫ (α_ W (X ⊗ Y) Z).hom :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_hom_inv_inv_inv_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).hom Z✝) h))","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_hom_inv_inv_inv_hom :\n    (α_ W X (Y ⊗ Z)).hom ≫ W ◁ (α_ X Y Z).inv ≫ (α_ W (X ⊗ Y) Z).inv =\n      (α_ (W ⊗ X) Y Z).inv ≫ (α_ W X Y).hom ▷ Z := by\n  rw [← cancel_epi (α_ W X (Y ⊗ Z)).inv, ← cancel_mono ((α_ W X Y).inv ▷ Z)]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_hom_inv_inv_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv) (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).hom Z))","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_hom_inv_inv_inv_hom :\n    (α_ W X (Y ⊗ Z)).hom ≫ W ◁ (α_ X Y Z).inv ≫ (α_ W (X ⊗ Y) Z).inv =\n      (α_ (W ⊗ X) Y Z).inv ≫ (α_ W X Y).hom ▷ Z := by\n  rw [← cancel_epi (α_ W X (Y ⊗ Z)).inv, ← cancel_mono ((α_ W X Y).inv ▷ Z)]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_hom_hom_inv_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom) (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).inv Z) (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z).hom)","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_hom_hom_inv_inv_hom :\n    (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom ≫ (α_ W X (Y ⊗ Z)).inv =\n      (α_ W X Y).inv ▷ Z ≫ (α_ (W ⊗ X) Y Z).hom :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_hom_hom_inv_inv_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).inv Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z✝).hom h))","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_hom_hom_inv_inv_hom :\n    (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom ≫ (α_ W X (Y ⊗ Z)).inv =\n      (α_ W X Y).inv ▷ Z ≫ (α_ (W ⊗ X) Y Z).hom :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_inv_hom_hom_hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).inv Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z).hom (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom))","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_inv_hom_hom_hom_hom :\n    (α_ W X Y).inv ▷ Z ≫ (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom =\n      (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom := by\n  simp [← cancel_epi ((α_ W X Y).hom ▷ Z)]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_inv_hom_hom_hom_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj W (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).inv Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom) h))","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_inv_hom_hom_hom_hom :\n    (α_ W X Y).inv ▷ Z ≫ (α_ (W ⊗ X) Y Z).hom ≫ (α_ W X (Y ⊗ Z)).hom =\n      (α_ W (X ⊗ Y) Z).hom ≫ W ◁ (α_ X Y Z).hom := by\n  simp [← cancel_epi ((α_ W X Y).hom ▷ Z)]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_inv_inv_hom_inv_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).hom Z✝) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z✝).inv h))","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_inv_inv_hom_inv_inv :\n    (α_ W X (Y ⊗ Z)).inv ≫ (α_ (W ⊗ X) Y Z).inv ≫ (α_ W X Y).hom ▷ Z =\n      W ◁ (α_ X Y Z).inv ≫ (α_ W (X ⊗ Y) Z).inv :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.pentagon_inv_inv_hom_inv_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator W X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.MonoidalCategoryStruct.tensorObj W X) Y Z).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator W X Y).hom Z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft W (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv) (CategoryTheory.MonoidalCategoryStruct.associator W (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z).inv)","decl":"@[reassoc (attr := simp)]\ntheorem pentagon_inv_inv_hom_inv_inv :\n    (α_ W X (Y ⊗ Z)).inv ≫ (α_ (W ⊗ X) Y Z).inv ≫ (α_ W X Y).hom ▷ Z =\n      W ◁ (α_ X Y Z).inv ≫ (α_ W (X ⊗ Y) Z).inv :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.triangle_assoc_comp_right","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X CategoryTheory.MonoidalCategoryStruct.tensorUnit Y).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom Y)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).hom)","decl":"@[reassoc (attr := simp)]\ntheorem triangle_assoc_comp_right (X Y : C) :\n    (α_ X (𝟙_ C) Y).inv ≫ ((ρ_ X).hom ▷ Y) = X ◁ (λ_ Y).hom := by\n  rw [← triangle, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.triangle_assoc_comp_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X CategoryTheory.MonoidalCategoryStruct.tensorUnit Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom Y) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).hom) h)","decl":"@[reassoc (attr := simp)]\ntheorem triangle_assoc_comp_right (X Y : C) :\n    (α_ X (𝟙_ C) Y).inv ≫ ((ρ_ X).hom ▷ Y) = X ◁ (λ_ Y).hom := by\n  rw [← triangle, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.triangle_assoc_comp_right_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv Y) (CategoryTheory.MonoidalCategoryStruct.associator X CategoryTheory.MonoidalCategoryStruct.tensorUnit Y).hom) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv)","decl":"@[reassoc (attr := simp)]\ntheorem triangle_assoc_comp_right_inv (X Y : C) :\n    (ρ_ X).inv ▷ Y ≫ (α_ X (𝟙_ C) Y).hom = X ◁ (λ_ Y).inv := by\n  simp [← cancel_mono (X ◁ (λ_ Y).hom)]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.triangle_assoc_comp_right_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X CategoryTheory.MonoidalCategoryStruct.tensorUnit Y).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv) h)","decl":"@[reassoc (attr := simp)]\ntheorem triangle_assoc_comp_right_inv (X Y : C) :\n    (ρ_ X).inv ▷ Y ≫ (α_ X (𝟙_ C) Y).hom = X ◁ (λ_ Y).inv := by\n  simp [← cancel_mono (X ◁ (λ_ Y).hom)]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.triangle_assoc_comp_left_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv) (CategoryTheory.MonoidalCategoryStruct.associator X CategoryTheory.MonoidalCategoryStruct.tensorUnit Y).inv) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv Y)","decl":"@[reassoc (attr := simp)]\ntheorem triangle_assoc_comp_left_inv (X Y : C) :\n    (X ◁ (λ_ Y).inv) ≫ (α_ X (𝟙_ C) Y).inv = (ρ_ X).inv ▷ Y := by\n  simp [← cancel_mono ((ρ_ X).hom ▷ Y)]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.triangle_assoc_comp_left_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X CategoryTheory.MonoidalCategoryStruct.tensorUnit) Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X CategoryTheory.MonoidalCategoryStruct.tensorUnit Y).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv Y) h)","decl":"@[reassoc (attr := simp)]\ntheorem triangle_assoc_comp_left_inv (X Y : C) :\n    (X ◁ (λ_ Y).inv) ≫ (α_ X (𝟙_ C) Y).inv = (ρ_ X).inv ▷ Y := by\n  simp [← cancel_mono ((ρ_ X).hom ▷ Y)]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator CategoryTheory.MonoidalCategoryStruct.tensorUnit X Y).hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).hom)","decl":"/-- We state it as a simp lemma, which is regarded as an involved version of\n`id_whiskerRight X Y : 𝟙 X ▷ Y = 𝟙 (X ⊗ Y)`.\n-/\n@[reassoc, simp]\ntheorem leftUnitor_whiskerRight (X Y : C) :\n    (λ_ X).hom ▷ Y = (α_ (𝟙_ C) X Y).hom ≫ (λ_ (X ⊗ Y)).hom := by\n  rw [← whiskerLeft_iff, whiskerLeft_comp, ← cancel_epi (α_ _ _ _).hom, ←\n      cancel_epi ((α_ _ _ _).hom ▷ _), pentagon_assoc, triangle, ← associator_naturality_middle, ←\n      comp_whiskerRight_assoc, triangle, associator_naturality_left]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_whiskerRight_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom Y) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator CategoryTheory.MonoidalCategoryStruct.tensorUnit X Y).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).hom h))","decl":"/-- We state it as a simp lemma, which is regarded as an involved version of\n`id_whiskerRight X Y : 𝟙 X ▷ Y = 𝟙 (X ⊗ Y)`.\n-/\n@[reassoc, simp]\ntheorem leftUnitor_whiskerRight (X Y : C) :\n    (λ_ X).hom ▷ Y = (α_ (𝟙_ C) X Y).hom ≫ (λ_ (X ⊗ Y)).hom := by\n  rw [← whiskerLeft_iff, whiskerLeft_comp, ← cancel_epi (α_ _ _ _).hom, ←\n      cancel_epi ((α_ _ _ _).hom ▷ _), pentagon_assoc, triangle, ← associator_naturality_middle, ←\n      comp_whiskerRight_assoc, triangle, associator_naturality_left]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_inv_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).inv (CategoryTheory.MonoidalCategoryStruct.associator CategoryTheory.MonoidalCategoryStruct.tensorUnit X Y).inv)","decl":"@[reassoc, simp]\ntheorem leftUnitor_inv_whiskerRight (X Y : C) :\n    (λ_ X).inv ▷ Y = (λ_ (X ⊗ Y)).inv ≫ (α_ (𝟙_ C) X Y).inv :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_inv_whiskerRight_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit X) Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv Y) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator CategoryTheory.MonoidalCategoryStruct.tensorUnit X Y).inv h))","decl":"@[reassoc, simp]\ntheorem leftUnitor_inv_whiskerRight (X Y : C) :\n    (λ_ X).inv ▷ Y = (λ_ (X ⊗ Y)).inv ≫ (α_ (𝟙_ C) X Y).inv :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_rightUnitor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).hom h))","decl":"@[reassoc, simp]\ntheorem whiskerLeft_rightUnitor (X Y : C) :\n    X ◁ (ρ_ Y).hom = (α_ X Y (𝟙_ C)).inv ≫ (ρ_ (X ⊗ Y)).hom := by\n  rw [← whiskerRight_iff, comp_whiskerRight, ← cancel_epi (α_ _ _ _).inv, ←\n      cancel_epi (X ◁ (α_ _ _ _).inv), pentagon_inv_assoc, triangle_assoc_comp_right, ←\n      associator_inv_naturality_middle, ← whiskerLeft_comp_assoc, triangle_assoc_comp_right,\n      associator_inv_naturality_right]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_rightUnitor","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).hom)","decl":"@[reassoc, simp]\ntheorem whiskerLeft_rightUnitor (X Y : C) :\n    X ◁ (ρ_ Y).hom = (α_ X Y (𝟙_ C)).inv ≫ (ρ_ (X ⊗ Y)).hom := by\n  rw [← whiskerRight_iff, comp_whiskerRight, ← cancel_epi (α_ _ _ _).inv, ←\n      cancel_epi (X ◁ (α_ _ _ _).inv), pentagon_inv_assoc, triangle_assoc_comp_right, ←\n      associator_inv_naturality_middle, ← whiskerLeft_comp_assoc, triangle_assoc_comp_right,\n      associator_inv_naturality_right]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_rightUnitor_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).inv (CategoryTheory.MonoidalCategoryStruct.associator X Y CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom)","decl":"@[reassoc, simp]\ntheorem whiskerLeft_rightUnitor_inv (X Y : C) :\n    X ◁ (ρ_ Y).inv = (ρ_ (X ⊗ Y)).inv ≫ (α_ X Y (𝟙_ C)).hom :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.whiskerLeft_rightUnitor_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y CategoryTheory.MonoidalCategoryStruct.tensorUnit)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).inv) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom h))","decl":"@[reassoc, simp]\ntheorem whiskerLeft_rightUnitor_inv (X Y : C) :\n    X ◁ (ρ_ Y).inv = (ρ_ (X ⊗ Y)).inv ≫ (α_ X Y (𝟙_ C)).hom :=\n  eq_of_inv_eq_inv (by simp)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_tensor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator CategoryTheory.MonoidalCategoryStruct.tensorUnit X Y).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom Y) h))","decl":"@[reassoc]\ntheorem leftUnitor_tensor (X Y : C) :\n    (λ_ (X ⊗ Y)).hom = (α_ (𝟙_ C) X Y).inv ≫ (λ_ X).hom ▷ Y := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_tensor","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator CategoryTheory.MonoidalCategoryStruct.tensorUnit X Y).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom Y))","decl":"@[reassoc]\ntheorem leftUnitor_tensor (X Y : C) :\n    (λ_ (X ⊗ Y)).hom = (α_ (𝟙_ C) X Y).inv ≫ (λ_ X).hom ▷ Y := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_tensor_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv Y) (CategoryTheory.MonoidalCategoryStruct.associator CategoryTheory.MonoidalCategoryStruct.tensorUnit X Y).hom)","decl":"@[reassoc]\ntheorem leftUnitor_tensor_inv (X Y : C) :\n    (λ_ (X ⊗ Y)).inv = (λ_ X).inv ▷ Y ≫ (α_ (𝟙_ C) X Y).hom := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitor_tensor_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).inv h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator CategoryTheory.MonoidalCategoryStruct.tensorUnit X Y).hom h))","decl":"@[reassoc]\ntheorem leftUnitor_tensor_inv (X Y : C) :\n    (λ_ (X ⊗ Y)).inv = (λ_ X).inv ▷ Y ≫ (α_ (𝟙_ C) X Y).hom := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.rightUnitor_tensor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom) h))","decl":"@[reassoc]\ntheorem rightUnitor_tensor (X Y : C) :\n    (ρ_ (X ⊗ Y)).hom = (α_ X Y (𝟙_ C)).hom ≫ X ◁ (ρ_ Y).hom := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.rightUnitor_tensor","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom))","decl":"@[reassoc]\ntheorem rightUnitor_tensor (X Y : C) :\n    (ρ_ (X ⊗ Y)).hom = (α_ X Y (𝟙_ C)).hom ≫ X ◁ (ρ_ Y).hom := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.rightUnitor_tensor_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) CategoryTheory.MonoidalCategoryStruct.tensorUnit) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).inv h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv h))","decl":"@[reassoc]\ntheorem rightUnitor_tensor_inv (X Y : C) :\n    (ρ_ (X ⊗ Y)).inv = X ◁ (ρ_ Y).inv ≫ (α_ X Y (𝟙_ C)).inv := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.rightUnitor_tensor_inv","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).inv) (CategoryTheory.MonoidalCategoryStruct.associator X Y CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv)","decl":"@[reassoc]\ntheorem rightUnitor_tensor_inv (X Y : C) :\n    (ρ_ (X ⊗ Y)).inv = X ◁ (ρ_ Y).inv ≫ (α_ X Y (𝟙_ C)).inv := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z✝ X' Y' Z' : C\nf : Quiver.Hom X X'\ng : Quiver.Hom Y Y'\nh✝ : Quiver.Hom Z✝ Z'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X' Y') Z') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.MonoidalCategoryStruct.tensorHom g h✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X' Y' Z').inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) h✝) h))","decl":"@[reassoc]\ntheorem associator_inv_naturality {X Y Z X' Y' Z' : C} (f : X ⟶ X') (g : Y ⟶ Y') (h : Z ⟶ Z') :\n    (f ⊗ g ⊗ h) ≫ (α_ X' Y' Z').inv = (α_ X Y Z).inv ≫ ((f ⊗ g) ⊗ h) := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_inv_naturality","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z X' Y' Z' : C\nf : Quiver.Hom X X'\ng : Quiver.Hom Y Y'\nh : Quiver.Hom Z Z'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.MonoidalCategoryStruct.tensorHom g h)) (CategoryTheory.MonoidalCategoryStruct.associator X' Y' Z').inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) h))","decl":"@[reassoc]\ntheorem associator_inv_naturality {X Y Z X' Y' Z' : C} (f : X ⟶ X') (g : Y ⟶ Y') (h : Z ⟶ Z') :\n    (f ⊗ g ⊗ h) ≫ (α_ X' Y' Z').inv = (α_ X Y Z).inv ≫ ((f ⊗ g) ⊗ h) := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_conjugation","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' Y Y' Z Z' : C\nf : Quiver.Hom X X'\ng : Quiver.Hom Y Y'\nh : Quiver.Hom Z Z'\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.MonoidalCategoryStruct.tensorHom g h)) (CategoryTheory.MonoidalCategoryStruct.associator X' Y' Z').inv))","decl":"@[reassoc, simp]\ntheorem associator_conjugation {X X' Y Y' Z Z' : C} (f : X ⟶ X') (g : Y ⟶ Y') (h : Z ⟶ Z') :\n    (f ⊗ g) ⊗ h = (α_ X Y Z).hom ≫ (f ⊗ g ⊗ h) ≫ (α_ X' Y' Z').inv := by\n  rw [associator_inv_naturality, hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_conjugation_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' Y Y' Z✝ Z' : C\nf : Quiver.Hom X X'\ng : Quiver.Hom Y Y'\nh✝ : Quiver.Hom Z✝ Z'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X' Y') Z') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) h✝) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.MonoidalCategoryStruct.tensorHom g h✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X' Y' Z').inv h)))","decl":"@[reassoc, simp]\ntheorem associator_conjugation {X X' Y Y' Z Z' : C} (f : X ⟶ X') (g : Y ⟶ Y') (h : Z ⟶ Z') :\n    (f ⊗ g) ⊗ h = (α_ X Y Z).hom ≫ (f ⊗ g ⊗ h) ≫ (α_ X' Y' Z').inv := by\n  rw [associator_inv_naturality, hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_inv_conjugation","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' Y Y' Z Z' : C\nf : Quiver.Hom X X'\ng : Quiver.Hom Y Y'\nh : Quiver.Hom Z Z'\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.MonoidalCategoryStruct.tensorHom g h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) h) (CategoryTheory.MonoidalCategoryStruct.associator X' Y' Z').hom))","decl":"@[reassoc]\ntheorem associator_inv_conjugation {X X' Y Y' Z Z' : C} (f : X ⟶ X') (g : Y ⟶ Y') (h : Z ⟶ Z') :\n    f ⊗ g ⊗ h = (α_ X Y Z).inv ≫ ((f ⊗ g) ⊗ h) ≫ (α_ X' Y' Z').hom := by\n  rw [associator_naturality, inv_hom_id_assoc]\n\n-- TODO these next two lemmas aren't so fundamental, and perhaps could be removed\n-- (replacing their usages by their proofs).\n"}
{"name":"CategoryTheory.MonoidalCategory.associator_inv_conjugation_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X' Y Y' Z✝ Z' : C\nf : Quiver.Hom X X'\ng : Quiver.Hom Y Y'\nh✝ : Quiver.Hom Z✝ Z'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X' (CategoryTheory.MonoidalCategoryStruct.tensorObj Y' Z')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.MonoidalCategoryStruct.tensorHom g h✝)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X' Y' Z').hom h)))","decl":"@[reassoc]\ntheorem associator_inv_conjugation {X X' Y Y' Z Z' : C} (f : X ⟶ X') (g : Y ⟶ Y') (h : Z ⟶ Z') :\n    f ⊗ g ⊗ h = (α_ X Y Z).inv ≫ ((f ⊗ g) ⊗ h) ≫ (α_ X' Y' Z').hom := by\n  rw [associator_naturality, inv_hom_id_assoc]\n\n-- TODO these next two lemmas aren't so fundamental, and perhaps could be removed\n-- (replacing their usages by their proofs).\n"}
{"name":"CategoryTheory.MonoidalCategory.id_tensor_associator_naturality","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z Z' : C\nh : Quiver.Hom Z Z'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) h) (CategoryTheory.MonoidalCategoryStruct.associator X Y Z').hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id X) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id Y) h)))","decl":"@[reassoc]\ntheorem id_tensor_associator_naturality {X Y Z Z' : C} (h : Z ⟶ Z') :\n    (𝟙 (X ⊗ Y) ⊗ h) ≫ (α_ X Y Z').hom = (α_ X Y Z).hom ≫ (𝟙 X ⊗ 𝟙 Y ⊗ h) := by\n  rw [← tensor_id, associator_naturality]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.id_tensor_associator_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z✝ Z' : C\nh✝ : Quiver.Hom Z✝ Z'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)) h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z').hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id X) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id Y) h✝)) h))","decl":"@[reassoc]\ntheorem id_tensor_associator_naturality {X Y Z Z' : C} (h : Z ⟶ Z') :\n    (𝟙 (X ⊗ Y) ⊗ h) ≫ (α_ X Y Z').hom = (α_ X Y Z).hom ≫ (𝟙 X ⊗ 𝟙 Y ⊗ h) := by\n  rw [← tensor_id, associator_naturality]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.id_tensor_associator_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z✝ X' : C\nf : Quiver.Hom X X'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X' Y) Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X' Y Z✝).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.CategoryStruct.id Z✝)) h))","decl":"@[reassoc]\ntheorem id_tensor_associator_inv_naturality {X Y Z X' : C} (f : X ⟶ X') :\n    (f ⊗ 𝟙 (Y ⊗ Z)) ≫ (α_ X' Y Z).inv = (α_ X Y Z).inv ≫ ((f ⊗ 𝟙 Y) ⊗ 𝟙 Z) := by\n  rw [← tensor_id, associator_inv_naturality]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.id_tensor_associator_inv_naturality","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z X' : C\nf : Quiver.Hom X X'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z))) (CategoryTheory.MonoidalCategoryStruct.associator X' Y Z).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.CategoryStruct.id Z)))","decl":"@[reassoc]\ntheorem id_tensor_associator_inv_naturality {X Y Z X' : C} (f : X ⟶ X') :\n    (f ⊗ 𝟙 (Y ⊗ Z)) ≫ (α_ X' Y Z).inv = (α_ X Y Z).inv ≫ ((f ⊗ 𝟙 Y) ⊗ 𝟙 Z) := by\n  rw [← tensor_id, associator_inv_naturality]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.hom_inv_id_tensor","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nV W X Y Z : C\nf : CategoryTheory.Iso V W\ng : Quiver.Hom X Y\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom g) (CategoryTheory.MonoidalCategoryStruct.tensorHom f.inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id V) g) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id V) h))","decl":"@[reassoc (attr := simp)]\ntheorem hom_inv_id_tensor {V W X Y Z : C} (f : V ≅ W) (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (f.hom ⊗ g) ≫ (f.inv ⊗ h) = (𝟙 V ⊗ g) ≫ (𝟙 V ⊗ h) := by\n  rw [← tensor_comp, f.hom_inv_id]; simp [id_tensorHom]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.hom_inv_id_tensor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nV W X Y Z✝ : C\nf : CategoryTheory.Iso V W\ng : Quiver.Hom X Y\nh✝ : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj V Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f.inv h✝) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id V) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id V) h✝) h))","decl":"@[reassoc (attr := simp)]\ntheorem hom_inv_id_tensor {V W X Y Z : C} (f : V ≅ W) (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (f.hom ⊗ g) ≫ (f.inv ⊗ h) = (𝟙 V ⊗ g) ≫ (𝟙 V ⊗ h) := by\n  rw [← tensor_comp, f.hom_inv_id]; simp [id_tensorHom]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.inv_hom_id_tensor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nV W X Y Z✝ : C\nf : CategoryTheory.Iso V W\ng : Quiver.Hom X Y\nh✝ : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj W Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f.inv g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom h✝) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id W) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id W) h✝) h))","decl":"@[reassoc (attr := simp)]\ntheorem inv_hom_id_tensor {V W X Y Z : C} (f : V ≅ W) (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (f.inv ⊗ g) ≫ (f.hom ⊗ h) = (𝟙 W ⊗ g) ≫ (𝟙 W ⊗ h) := by\n  rw [← tensor_comp, f.inv_hom_id]; simp [id_tensorHom]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.inv_hom_id_tensor","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nV W X Y Z : C\nf : CategoryTheory.Iso V W\ng : Quiver.Hom X Y\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f.inv g) (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id W) g) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id W) h))","decl":"@[reassoc (attr := simp)]\ntheorem inv_hom_id_tensor {V W X Y Z : C} (f : V ≅ W) (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (f.inv ⊗ g) ≫ (f.hom ⊗ h) = (𝟙 W ⊗ g) ≫ (𝟙 W ⊗ h) := by\n  rw [← tensor_comp, f.inv_hom_id]; simp [id_tensorHom]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_hom_inv_id_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nV W X Y Z✝ : C\nf : CategoryTheory.Iso V W\ng : Quiver.Hom X Y\nh✝ : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ V) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom h✝ f.inv) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id V)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom h✝ (CategoryTheory.CategoryStruct.id V)) h))","decl":"@[reassoc (attr := simp)]\ntheorem tensor_hom_inv_id {V W X Y Z : C} (f : V ≅ W) (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (g ⊗ f.hom) ≫ (h ⊗ f.inv) = (g ⊗ 𝟙 V) ≫ (h ⊗ 𝟙 V) := by\n  rw [← tensor_comp, f.hom_inv_id]; simp [tensorHom_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_hom_inv_id","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nV W X Y Z : C\nf : CategoryTheory.Iso V W\ng : Quiver.Hom X Y\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f.hom) (CategoryTheory.MonoidalCategoryStruct.tensorHom h f.inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id V)) (CategoryTheory.MonoidalCategoryStruct.tensorHom h (CategoryTheory.CategoryStruct.id V)))","decl":"@[reassoc (attr := simp)]\ntheorem tensor_hom_inv_id {V W X Y Z : C} (f : V ≅ W) (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (g ⊗ f.hom) ≫ (h ⊗ f.inv) = (g ⊗ 𝟙 V) ≫ (h ⊗ 𝟙 V) := by\n  rw [← tensor_comp, f.hom_inv_id]; simp [tensorHom_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_inv_hom_id","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nV W X Y Z : C\nf : CategoryTheory.Iso V W\ng : Quiver.Hom X Y\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f.inv) (CategoryTheory.MonoidalCategoryStruct.tensorHom h f.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.MonoidalCategoryStruct.tensorHom h (CategoryTheory.CategoryStruct.id W)))","decl":"@[reassoc (attr := simp)]\ntheorem tensor_inv_hom_id {V W X Y Z : C} (f : V ≅ W) (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (g ⊗ f.inv) ≫ (h ⊗ f.hom) = (g ⊗ 𝟙 W) ≫ (h ⊗ 𝟙 W) := by\n  rw [← tensor_comp, f.inv_hom_id]; simp [tensorHom_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_inv_hom_id_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nV W X Y Z✝ : C\nf : CategoryTheory.Iso V W\ng : Quiver.Hom X Y\nh✝ : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ W) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f.inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom h✝ f.hom) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom h✝ (CategoryTheory.CategoryStruct.id W)) h))","decl":"@[reassoc (attr := simp)]\ntheorem tensor_inv_hom_id {V W X Y Z : C} (f : V ≅ W) (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (g ⊗ f.inv) ≫ (h ⊗ f.hom) = (g ⊗ 𝟙 W) ≫ (h ⊗ 𝟙 W) := by\n  rw [← tensor_comp, f.inv_hom_id]; simp [tensorHom_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.hom_inv_id_tensor'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nV W X Y Z✝ : C\nf : Quiver.Hom V W\ninst✝ : CategoryTheory.IsIso f\ng : Quiver.Hom X Y\nh✝ : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj V Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.inv f) h✝) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id V) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id V) h✝) h))","decl":"@[reassoc (attr := simp)]\ntheorem hom_inv_id_tensor' {V W X Y Z : C} (f : V ⟶ W) [IsIso f] (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (f ⊗ g) ≫ (inv f ⊗ h) = (𝟙 V ⊗ g) ≫ (𝟙 V ⊗ h) := by\n  rw [← tensor_comp, IsIso.hom_inv_id]; simp [id_tensorHom]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.hom_inv_id_tensor'","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nV W X Y Z : C\nf : Quiver.Hom V W\ninst✝ : CategoryTheory.IsIso f\ng : Quiver.Hom X Y\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.inv f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id V) g) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id V) h))","decl":"@[reassoc (attr := simp)]\ntheorem hom_inv_id_tensor' {V W X Y Z : C} (f : V ⟶ W) [IsIso f] (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (f ⊗ g) ≫ (inv f ⊗ h) = (𝟙 V ⊗ g) ≫ (𝟙 V ⊗ h) := by\n  rw [← tensor_comp, IsIso.hom_inv_id]; simp [id_tensorHom]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.inv_hom_id_tensor'","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nV W X Y Z : C\nf : Quiver.Hom V W\ninst✝ : CategoryTheory.IsIso f\ng : Quiver.Hom X Y\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.inv f) g) (CategoryTheory.MonoidalCategoryStruct.tensorHom f h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id W) g) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id W) h))","decl":"@[reassoc (attr := simp)]\ntheorem inv_hom_id_tensor' {V W X Y Z : C} (f : V ⟶ W) [IsIso f] (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (inv f ⊗ g) ≫ (f ⊗ h) = (𝟙 W ⊗ g) ≫ (𝟙 W ⊗ h) := by\n  rw [← tensor_comp, IsIso.inv_hom_id]; simp [id_tensorHom]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.inv_hom_id_tensor'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nV W X Y Z✝ : C\nf : Quiver.Hom V W\ninst✝ : CategoryTheory.IsIso f\ng : Quiver.Hom X Y\nh✝ : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj W Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.inv f) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f h✝) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id W) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id W) h✝) h))","decl":"@[reassoc (attr := simp)]\ntheorem inv_hom_id_tensor' {V W X Y Z : C} (f : V ⟶ W) [IsIso f] (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (inv f ⊗ g) ≫ (f ⊗ h) = (𝟙 W ⊗ g) ≫ (𝟙 W ⊗ h) := by\n  rw [← tensor_comp, IsIso.inv_hom_id]; simp [id_tensorHom]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_hom_inv_id'","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nV W X Y Z : C\nf : Quiver.Hom V W\ninst✝ : CategoryTheory.IsIso f\ng : Quiver.Hom X Y\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f) (CategoryTheory.MonoidalCategoryStruct.tensorHom h (CategoryTheory.inv f))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id V)) (CategoryTheory.MonoidalCategoryStruct.tensorHom h (CategoryTheory.CategoryStruct.id V)))","decl":"@[reassoc (attr := simp)]\ntheorem tensor_hom_inv_id' {V W X Y Z : C} (f : V ⟶ W) [IsIso f] (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (g ⊗ f) ≫ (h ⊗ inv f) = (g ⊗ 𝟙 V) ≫ (h ⊗ 𝟙 V) := by\n  rw [← tensor_comp, IsIso.hom_inv_id]; simp [tensorHom_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_hom_inv_id'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nV W X Y Z✝ : C\nf : Quiver.Hom V W\ninst✝ : CategoryTheory.IsIso f\ng : Quiver.Hom X Y\nh✝ : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ V) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom h✝ (CategoryTheory.inv f)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id V)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom h✝ (CategoryTheory.CategoryStruct.id V)) h))","decl":"@[reassoc (attr := simp)]\ntheorem tensor_hom_inv_id' {V W X Y Z : C} (f : V ⟶ W) [IsIso f] (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (g ⊗ f) ≫ (h ⊗ inv f) = (g ⊗ 𝟙 V) ≫ (h ⊗ 𝟙 V) := by\n  rw [← tensor_comp, IsIso.hom_inv_id]; simp [tensorHom_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_inv_hom_id'","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nV W X Y Z : C\nf : Quiver.Hom V W\ninst✝ : CategoryTheory.IsIso f\ng : Quiver.Hom X Y\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.inv f)) (CategoryTheory.MonoidalCategoryStruct.tensorHom h f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.MonoidalCategoryStruct.tensorHom h (CategoryTheory.CategoryStruct.id W)))","decl":"@[reassoc (attr := simp)]\ntheorem tensor_inv_hom_id' {V W X Y Z : C} (f : V ⟶ W) [IsIso f] (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (g ⊗ inv f) ≫ (h ⊗ f) = (g ⊗ 𝟙 W) ≫ (h ⊗ 𝟙 W) := by\n  rw [← tensor_comp, IsIso.inv_hom_id]; simp [tensorHom_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_inv_hom_id'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nV W X Y Z✝ : C\nf : Quiver.Hom V W\ninst✝ : CategoryTheory.IsIso f\ng : Quiver.Hom X Y\nh✝ : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ W) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.inv f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom h✝ f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom h✝ (CategoryTheory.CategoryStruct.id W)) h))","decl":"@[reassoc (attr := simp)]\ntheorem tensor_inv_hom_id' {V W X Y Z : C} (f : V ⟶ W) [IsIso f] (g : X ⟶ Y) (h : Y ⟶ Z) :\n    (g ⊗ inv f) ≫ (h ⊗ f) = (g ⊗ 𝟙 W) ≫ (h ⊗ 𝟙 W) := by\n  rw [← tensor_comp, IsIso.inv_hom_id]; simp [tensorHom_id]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.comp_tensor_id_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ : C\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id Z✝)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.CategoryStruct.id Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id Z✝)) h))","decl":"@[reassoc]\ntheorem comp_tensor_id (f : W ⟶ X) (g : X ⟶ Y) : f ≫ g ⊗ 𝟙 Z = (f ⊗ 𝟙 Z) ≫ (g ⊗ 𝟙 Z) := by\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.comp_tensor_id","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.id Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.CategoryStruct.id Z)) (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id Z)))","decl":"@[reassoc]\ntheorem comp_tensor_id (f : W ⟶ X) (g : X ⟶ Y) : f ≫ g ⊗ 𝟙 Z = (f ⊗ 𝟙 Z) ≫ (g ⊗ 𝟙 Z) := by\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.id_tensor_comp","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id Z) (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id Z) f) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id Z) g))","decl":"@[reassoc]\ntheorem id_tensor_comp (f : W ⟶ X) (g : X ⟶ Y) : 𝟙 Z ⊗ f ≫ g = (𝟙 Z ⊗ f) ≫ (𝟙 Z ⊗ g) := by\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.id_tensor_comp_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ : C\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id Z✝) (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id Z✝) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id Z✝) g) h))","decl":"@[reassoc]\ntheorem id_tensor_comp (f : W ⟶ X) (g : X ⟶ Y) : 𝟙 Z ⊗ f ≫ g = (𝟙 Z ⊗ f) ≫ (𝟙 Z ⊗ g) := by\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.id_tensor_comp_tensor_id","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id Y) f) (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id X))) (CategoryTheory.MonoidalCategoryStruct.tensorHom g f)","decl":"@[reassoc]\ntheorem id_tensor_comp_tensor_id (f : W ⟶ X) (g : Y ⟶ Z) : (𝟙 Y ⊗ f) ≫ (g ⊗ 𝟙 X) = g ⊗ f := by\n  rw [← tensor_comp]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.id_tensor_comp_tensor_id_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ : C\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id Y) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id X)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f) h)","decl":"@[reassoc]\ntheorem id_tensor_comp_tensor_id (f : W ⟶ X) (g : Y ⟶ Z) : (𝟙 Y ⊗ f) ≫ (g ⊗ 𝟙 X) = g ⊗ f := by\n  rw [← tensor_comp]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_id_comp_id_tensor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z✝ : C\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z✝ X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id Z✝) f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g f) h)","decl":"@[reassoc]\ntheorem tensor_id_comp_id_tensor (f : W ⟶ X) (g : Y ⟶ Z) : (g ⊗ 𝟙 W) ≫ (𝟙 Z ⊗ f) = g ⊗ f := by\n  rw [← tensor_comp]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_id_comp_id_tensor","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id W)) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id Z) f)) (CategoryTheory.MonoidalCategoryStruct.tensorHom g f)","decl":"@[reassoc]\ntheorem tensor_id_comp_id_tensor (f : W ⟶ X) (g : Y ⟶ Z) : (g ⊗ 𝟙 W) ≫ (𝟙 Z ⊗ f) = g ⊗ f := by\n  rw [← tensor_comp]\n  simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_left_iff","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf g : Quiver.Hom X Y\n⊢ Iff (Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit) f) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit) g)) (Eq f g)","decl":"theorem tensor_left_iff {X Y : C} (f g : X ⟶ Y) : 𝟙 (𝟙_ C) ⊗ f = 𝟙 (𝟙_ C) ⊗ g ↔ f = g := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_right_iff","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\nf g : Quiver.Hom X Y\n⊢ Iff (Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)) (CategoryTheory.MonoidalCategoryStruct.tensorHom g (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit))) (Eq f g)","decl":"theorem tensor_right_iff {X Y : C} (f g : X ⟶ Y) : f ⊗ 𝟙 (𝟙_ C) = g ⊗ 𝟙 (𝟙_ C) ↔ f = g := by simp\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_obj","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : Prod C C\n⊢ Eq ((CategoryTheory.MonoidalCategory.tensor C).obj X) (CategoryTheory.MonoidalCategoryStruct.tensorObj X.1 X.2)","decl":"/-- The tensor product expressed as a functor. -/\n@[simps]\ndef tensor : C × C ⥤ C where\n  obj X := X.1 ⊗ X.2\n  map {X Y : C × C} (f : X ⟶ Y) := f.1 ⊗ f.2\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensor_map","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : Prod C C\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.MonoidalCategory.tensor C).map f) (CategoryTheory.MonoidalCategoryStruct.tensorHom f.1 f.2)","decl":"/-- The tensor product expressed as a functor. -/\n@[simps]\ndef tensor : C × C ⥤ C where\n  obj X := X.1 ⊗ X.2\n  map {X Y : C × C} (f : X ⟶ Y) := f.1 ⊗ f.2\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftAssocTensor_obj","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : Prod C (Prod C C)\n⊢ Eq ((CategoryTheory.MonoidalCategory.leftAssocTensor C).obj X) (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj X.1 X.2.1) X.2.2)","decl":"@[simp]\ntheorem leftAssocTensor_obj (X) : (leftAssocTensor C).obj X = (X.1 ⊗ X.2.1) ⊗ X.2.2 :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftAssocTensor_map","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : Prod C (Prod C C)\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.MonoidalCategory.leftAssocTensor C).map f) (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.MonoidalCategoryStruct.tensorHom f.1 f.2.1) f.2.2)","decl":"@[simp]\ntheorem leftAssocTensor_map {X Y} (f : X ⟶ Y) : (leftAssocTensor C).map f = (f.1 ⊗ f.2.1) ⊗ f.2.2 :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.rightAssocTensor_obj","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : Prod C (Prod C C)\n⊢ Eq ((CategoryTheory.MonoidalCategory.rightAssocTensor C).obj X) (CategoryTheory.MonoidalCategoryStruct.tensorObj X.1 (CategoryTheory.MonoidalCategoryStruct.tensorObj X.2.1 X.2.2))","decl":"@[simp]\ntheorem rightAssocTensor_obj (X) : (rightAssocTensor C).obj X = X.1 ⊗ X.2.1 ⊗ X.2.2 :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.rightAssocTensor_map","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : Prod C (Prod C C)\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.MonoidalCategory.rightAssocTensor C).map f) (CategoryTheory.MonoidalCategoryStruct.tensorHom f.1 (CategoryTheory.MonoidalCategoryStruct.tensorHom f.2.1 f.2.2))","decl":"@[simp]\ntheorem rightAssocTensor_map {X Y} (f : X ⟶ Y) : (rightAssocTensor C).map f = f.1 ⊗ f.2.1 ⊗ f.2.2 :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.curriedTensor_obj_obj","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq (((CategoryTheory.MonoidalCategory.curriedTensor C).obj X).obj Y) (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)","decl":"/-- The tensor product bifunctor `C ⥤ C ⥤ C` of a monoidal category. -/\n@[simps]\ndef curriedTensor : C ⥤ C ⥤ C where\n  obj X :=\n    { obj := fun Y => X ⊗ Y\n      map := fun g => X ◁ g }\n  map f :=\n    { app := fun Y => f ▷ Y }\n\n"}
{"name":"CategoryTheory.MonoidalCategory.curriedTensor_obj_map","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X✝ Y✝ : C\ng : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.MonoidalCategory.curriedTensor C).obj X).map g) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X g)","decl":"/-- The tensor product bifunctor `C ⥤ C ⥤ C` of a monoidal category. -/\n@[simps]\ndef curriedTensor : C ⥤ C ⥤ C where\n  obj X :=\n    { obj := fun Y => X ⊗ Y\n      map := fun g => X ◁ g }\n  map f :=\n    { app := fun Y => f ▷ Y }\n\n"}
{"name":"CategoryTheory.MonoidalCategory.curriedTensor_map_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\nY : C\n⊢ Eq (((CategoryTheory.MonoidalCategory.curriedTensor C).map f).app Y) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y)","decl":"/-- The tensor product bifunctor `C ⥤ C ⥤ C` of a monoidal category. -/\n@[simps]\ndef curriedTensor : C ⥤ C ⥤ C where\n  obj X :=\n    { obj := fun Y => X ⊗ Y\n      map := fun g => X ◁ g }\n  map f :=\n    { app := fun Y => f ▷ Y }\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorLeft_obj","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : C\n⊢ Eq ((CategoryTheory.MonoidalCategory.tensorLeft X).obj Y) (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)","decl":"/-- Tensoring on the left with a fixed object, as a functor. -/\n@[simps!]\ndef tensorLeft (X : C) : C ⥤ C := (curriedTensor C).obj X\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorLeft_map","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X✝ Y✝ : C\ng : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.MonoidalCategory.tensorLeft X).map g) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X g)","decl":"/-- Tensoring on the left with a fixed object, as a functor. -/\n@[simps!]\ndef tensorLeft (X : C) : C ⥤ C := (curriedTensor C).obj X\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorRight_obj","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX j : C\n⊢ Eq ((CategoryTheory.MonoidalCategory.tensorRight X).obj j) (CategoryTheory.MonoidalCategoryStruct.tensorObj j X)","decl":"/-- Tensoring on the right with a fixed object, as a functor. -/\n@[simps!]\ndef tensorRight (X : C) : C ⥤ C := (curriedTensor C).flip.obj X\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorRight_map","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX X✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.MonoidalCategory.tensorRight X).map f) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X)","decl":"/-- Tensoring on the right with a fixed object, as a functor. -/\n@[simps!]\ndef tensorRight (X : C) : C ⥤ C := (curriedTensor C).flip.obj X\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associatorNatIso_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : Prod C (Prod C C)\n⊢ Eq ((CategoryTheory.MonoidalCategory.associatorNatIso C).inv.app X) (CategoryTheory.MonoidalCategoryStruct.associator X.1 X.2.1 X.2.2).inv","decl":"/-- The associator as a natural isomorphism. -/\n@[simps!]\ndef associatorNatIso : leftAssocTensor C ≅ rightAssocTensor C :=\n  NatIso.ofComponents (fun _ => MonoidalCategory.associator _ _ _)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.associatorNatIso_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : Prod C (Prod C C)\n⊢ Eq ((CategoryTheory.MonoidalCategory.associatorNatIso C).hom.app X) (CategoryTheory.MonoidalCategoryStruct.associator X.1 X.2.1 X.2.2).hom","decl":"/-- The associator as a natural isomorphism. -/\n@[simps!]\ndef associatorNatIso : leftAssocTensor C ≅ rightAssocTensor C :=\n  NatIso.ofComponents (fun _ => MonoidalCategory.associator _ _ _)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitorNatIso_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : C\n⊢ Eq ((CategoryTheory.MonoidalCategory.leftUnitorNatIso C).inv.app X) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv","decl":"/-- The left unitor as a natural isomorphism. -/\n@[simps!]\ndef leftUnitorNatIso : tensorUnitLeft C ≅ 𝟭 C :=\n  NatIso.ofComponents MonoidalCategory.leftUnitor\n\n"}
{"name":"CategoryTheory.MonoidalCategory.leftUnitorNatIso_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : C\n⊢ Eq ((CategoryTheory.MonoidalCategory.leftUnitorNatIso C).hom.app X) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom","decl":"/-- The left unitor as a natural isomorphism. -/\n@[simps!]\ndef leftUnitorNatIso : tensorUnitLeft C ≅ 𝟭 C :=\n  NatIso.ofComponents MonoidalCategory.leftUnitor\n\n"}
{"name":"CategoryTheory.MonoidalCategory.rightUnitorNatIso_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : C\n⊢ Eq ((CategoryTheory.MonoidalCategory.rightUnitorNatIso C).inv.app X) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv","decl":"/-- The right unitor as a natural isomorphism. -/\n@[simps!]\ndef rightUnitorNatIso : tensorUnitRight C ≅ 𝟭 C :=\n  NatIso.ofComponents MonoidalCategory.rightUnitor\n\n"}
{"name":"CategoryTheory.MonoidalCategory.rightUnitorNatIso_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX : C\n⊢ Eq ((CategoryTheory.MonoidalCategory.rightUnitorNatIso C).hom.app X) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom","decl":"/-- The right unitor as a natural isomorphism. -/\n@[simps!]\ndef rightUnitorNatIso : tensorUnitRight C ≅ 𝟭 C :=\n  NatIso.ofComponents MonoidalCategory.rightUnitor\n\n"}
{"name":"CategoryTheory.MonoidalCategory.curriedAssociatorNatIso_hom_app_app_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX✝¹ X✝ X : C\n⊢ Eq ((((CategoryTheory.MonoidalCategory.curriedAssociatorNatIso C).hom.app X✝¹).app X✝).app X) (CategoryTheory.MonoidalCategoryStruct.associator X✝¹ X✝ X).hom","decl":"/-- The associator as a natural isomorphism between trifunctors `C ⥤ C ⥤ C ⥤ C`. -/\n@[simps!]\ndef curriedAssociatorNatIso :\n    bifunctorComp₁₂ (curriedTensor C) (curriedTensor C) ≅\n      bifunctorComp₂₃ (curriedTensor C) (curriedTensor C) :=\n  NatIso.ofComponents (fun X₁ => NatIso.ofComponents (fun X₂ => NatIso.ofComponents\n    (fun X₃ => α_ X₁ X₂ X₃)))\n\n"}
{"name":"CategoryTheory.MonoidalCategory.curriedAssociatorNatIso_inv_app_app_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX✝¹ X✝ X : C\n⊢ Eq ((((CategoryTheory.MonoidalCategory.curriedAssociatorNatIso C).inv.app X✝¹).app X✝).app X) (CategoryTheory.MonoidalCategoryStruct.associator X✝¹ X✝ X).inv","decl":"/-- The associator as a natural isomorphism between trifunctors `C ⥤ C ⥤ C ⥤ C`. -/\n@[simps!]\ndef curriedAssociatorNatIso :\n    bifunctorComp₁₂ (curriedTensor C) (curriedTensor C) ≅\n      bifunctorComp₂₃ (curriedTensor C) (curriedTensor C) :=\n  NatIso.ofComponents (fun X₁ => NatIso.ofComponents (fun X₂ => NatIso.ofComponents\n    (fun X₃ => α_ X₁ X₂ X₃)))\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorLeftTensor_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\n⊢ Eq ((CategoryTheory.MonoidalCategory.tensorLeftTensor X Y).hom.app Z) (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom","decl":"@[simp]\ntheorem tensorLeftTensor_hom_app (X Y Z : C) :\n    (tensorLeftTensor X Y).hom.app Z = (associator X Y Z).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorLeftTensor_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\n⊢ Eq ((CategoryTheory.MonoidalCategory.tensorLeftTensor X Y).inv.app Z) (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv","decl":"@[simp]\ntheorem tensorLeftTensor_inv_app (X Y Z : C) :\n    (tensorLeftTensor X Y).inv.app Z = (associator X Y Z).inv := by simp [tensorLeftTensor]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.instFaithfulFunctorTensoringLeft","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\n⊢ (CategoryTheory.MonoidalCategory.tensoringLeft C).Faithful","decl":"instance : (tensoringLeft C).Faithful where\n  map_injective {X} {Y} f g h := by\n    injections h\n    replace h := congr_fun h (𝟙_ C)\n    simpa using h\n\n"}
{"name":"CategoryTheory.MonoidalCategory.instFaithfulFunctorTensoringRight","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\n⊢ (CategoryTheory.MonoidalCategory.tensoringRight C).Faithful","decl":"instance : (tensoringRight C).Faithful where\n  map_injective {X} {Y} f g h := by\n    injections h\n    replace h := congr_fun h (𝟙_ C)\n    simpa using h\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorRightTensor_hom_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\n⊢ Eq ((CategoryTheory.MonoidalCategory.tensorRightTensor X Y).hom.app Z) (CategoryTheory.MonoidalCategoryStruct.associator Z X Y).inv","decl":"@[simp]\ntheorem tensorRightTensor_hom_app (X Y Z : C) :\n    (tensorRightTensor X Y).hom.app Z = (associator Z X Y).inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.tensorRightTensor_inv_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C : Type u\n𝒞 : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y Z : C\n⊢ Eq ((CategoryTheory.MonoidalCategory.tensorRightTensor X Y).inv.app Z) (CategoryTheory.MonoidalCategoryStruct.associator Z X Y).hom","decl":"@[simp]\ntheorem tensorRightTensor_inv_app (X Y Z : C) :\n    (tensorRightTensor X Y).inv.app Z = (associator Z X Y).hom := by simp [tensorRightTensor]\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_tensorUnit","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\n⊢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit { fst := CategoryTheory.MonoidalCategoryStruct.tensorUnit, snd := CategoryTheory.MonoidalCategoryStruct.tensorUnit }","decl":"@[simps! tensorObj tensorHom tensorUnit whiskerLeft whiskerRight associator]\ninstance prodMonoidal : MonoidalCategory (C₁ × C₂) where\n  tensorObj X Y := (X.1 ⊗ Y.1, X.2 ⊗ Y.2)\n  tensorHom f g := (f.1 ⊗ g.1, f.2 ⊗ g.2)\n  whiskerLeft X _ _ f := (whiskerLeft X.1 f.1, whiskerLeft X.2 f.2)\n  whiskerRight f X := (whiskerRight f.1 X.1, whiskerRight f.2 X.2)\n  tensorHom_def := by simp [tensorHom_def]\n  tensorUnit := (𝟙_ C₁, 𝟙_ C₂)\n  associator X Y Z := (α_ X.1 Y.1 Z.1).prod (α_ X.2 Y.2 Z.2)\n  leftUnitor := fun ⟨X₁, X₂⟩ => (λ_ X₁).prod (λ_ X₂)\n  rightUnitor := fun ⟨X₁, X₂⟩ => (ρ_ X₁).prod (ρ_ X₂)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_associator","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\nX Y Z : Prod C₁ C₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z) ((CategoryTheory.MonoidalCategoryStruct.associator X.1 Y.1 Z.1).prod (CategoryTheory.MonoidalCategoryStruct.associator X.2 Y.2 Z.2))","decl":"@[simps! tensorObj tensorHom tensorUnit whiskerLeft whiskerRight associator]\ninstance prodMonoidal : MonoidalCategory (C₁ × C₂) where\n  tensorObj X Y := (X.1 ⊗ Y.1, X.2 ⊗ Y.2)\n  tensorHom f g := (f.1 ⊗ g.1, f.2 ⊗ g.2)\n  whiskerLeft X _ _ f := (whiskerLeft X.1 f.1, whiskerLeft X.2 f.2)\n  whiskerRight f X := (whiskerRight f.1 X.1, whiskerRight f.2 X.2)\n  tensorHom_def := by simp [tensorHom_def]\n  tensorUnit := (𝟙_ C₁, 𝟙_ C₂)\n  associator X Y Z := (α_ X.1 Y.1 Z.1).prod (α_ X.2 Y.2 Z.2)\n  leftUnitor := fun ⟨X₁, X₂⟩ => (λ_ X₁).prod (λ_ X₂)\n  rightUnitor := fun ⟨X₁, X₂⟩ => (ρ_ X₁).prod (ρ_ X₂)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\nX₁✝ X₂✝ : Prod C₁ C₂\nf : Quiver.Hom X₁✝ X₂✝\nX : Prod C₁ C₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X) { fst := CategoryTheory.MonoidalCategoryStruct.whiskerRight f.1 X.1, snd := CategoryTheory.MonoidalCategoryStruct.whiskerRight f.2 X.2 }","decl":"@[simps! tensorObj tensorHom tensorUnit whiskerLeft whiskerRight associator]\ninstance prodMonoidal : MonoidalCategory (C₁ × C₂) where\n  tensorObj X Y := (X.1 ⊗ Y.1, X.2 ⊗ Y.2)\n  tensorHom f g := (f.1 ⊗ g.1, f.2 ⊗ g.2)\n  whiskerLeft X _ _ f := (whiskerLeft X.1 f.1, whiskerLeft X.2 f.2)\n  whiskerRight f X := (whiskerRight f.1 X.1, whiskerRight f.2 X.2)\n  tensorHom_def := by simp [tensorHom_def]\n  tensorUnit := (𝟙_ C₁, 𝟙_ C₂)\n  associator X Y Z := (α_ X.1 Y.1 Z.1).prod (α_ X.2 Y.2 Z.2)\n  leftUnitor := fun ⟨X₁, X₂⟩ => (λ_ X₁).prod (λ_ X₂)\n  rightUnitor := fun ⟨X₁, X₂⟩ => (ρ_ X₁).prod (ρ_ X₂)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_tensorObj","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\nX Y : Prod C₁ C₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) { fst := CategoryTheory.MonoidalCategoryStruct.tensorObj X.1 Y.1, snd := CategoryTheory.MonoidalCategoryStruct.tensorObj X.2 Y.2 }","decl":"@[simps! tensorObj tensorHom tensorUnit whiskerLeft whiskerRight associator]\ninstance prodMonoidal : MonoidalCategory (C₁ × C₂) where\n  tensorObj X Y := (X.1 ⊗ Y.1, X.2 ⊗ Y.2)\n  tensorHom f g := (f.1 ⊗ g.1, f.2 ⊗ g.2)\n  whiskerLeft X _ _ f := (whiskerLeft X.1 f.1, whiskerLeft X.2 f.2)\n  whiskerRight f X := (whiskerRight f.1 X.1, whiskerRight f.2 X.2)\n  tensorHom_def := by simp [tensorHom_def]\n  tensorUnit := (𝟙_ C₁, 𝟙_ C₂)\n  associator X Y Z := (α_ X.1 Y.1 Z.1).prod (α_ X.2 Y.2 Z.2)\n  leftUnitor := fun ⟨X₁, X₂⟩ => (λ_ X₁).prod (λ_ X₂)\n  rightUnitor := fun ⟨X₁, X₂⟩ => (ρ_ X₁).prod (ρ_ X₂)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_whiskerLeft","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\nX x✝¹ x✝ : Prod C₁ C₂\nf : Quiver.Hom x✝¹ x✝\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) { fst := CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.1 f.1, snd := CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.2 f.2 }","decl":"@[simps! tensorObj tensorHom tensorUnit whiskerLeft whiskerRight associator]\ninstance prodMonoidal : MonoidalCategory (C₁ × C₂) where\n  tensorObj X Y := (X.1 ⊗ Y.1, X.2 ⊗ Y.2)\n  tensorHom f g := (f.1 ⊗ g.1, f.2 ⊗ g.2)\n  whiskerLeft X _ _ f := (whiskerLeft X.1 f.1, whiskerLeft X.2 f.2)\n  whiskerRight f X := (whiskerRight f.1 X.1, whiskerRight f.2 X.2)\n  tensorHom_def := by simp [tensorHom_def]\n  tensorUnit := (𝟙_ C₁, 𝟙_ C₂)\n  associator X Y Z := (α_ X.1 Y.1 Z.1).prod (α_ X.2 Y.2 Z.2)\n  leftUnitor := fun ⟨X₁, X₂⟩ => (λ_ X₁).prod (λ_ X₂)\n  rightUnitor := fun ⟨X₁, X₂⟩ => (ρ_ X₁).prod (ρ_ X₂)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_tensorHom","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\nX₁✝ Y₁✝ X₂✝ Y₂✝ : Prod C₁ C₂\nf : Quiver.Hom X₁✝ Y₁✝\ng : Quiver.Hom X₂✝ Y₂✝\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) { fst := CategoryTheory.MonoidalCategoryStruct.tensorHom f.1 g.1, snd := CategoryTheory.MonoidalCategoryStruct.tensorHom f.2 g.2 }","decl":"@[simps! tensorObj tensorHom tensorUnit whiskerLeft whiskerRight associator]\ninstance prodMonoidal : MonoidalCategory (C₁ × C₂) where\n  tensorObj X Y := (X.1 ⊗ Y.1, X.2 ⊗ Y.2)\n  tensorHom f g := (f.1 ⊗ g.1, f.2 ⊗ g.2)\n  whiskerLeft X _ _ f := (whiskerLeft X.1 f.1, whiskerLeft X.2 f.2)\n  whiskerRight f X := (whiskerRight f.1 X.1, whiskerRight f.2 X.2)\n  tensorHom_def := by simp [tensorHom_def]\n  tensorUnit := (𝟙_ C₁, 𝟙_ C₂)\n  associator X Y Z := (α_ X.1 Y.1 Z.1).prod (α_ X.2 Y.2 Z.2)\n  leftUnitor := fun ⟨X₁, X₂⟩ => (λ_ X₁).prod (λ_ X₂)\n  rightUnitor := fun ⟨X₁, X₂⟩ => (ρ_ X₁).prod (ρ_ X₂)\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_leftUnitor_hom_fst","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\nX : Prod C₁ C₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.1 (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.1).hom","decl":"@[simp]\ntheorem prodMonoidal_leftUnitor_hom_fst (X : C₁ × C₂) :\n    ((λ_ X).hom : 𝟙_ _ ⊗ X ⟶ X).1 = (λ_ X.1).hom := by\n  cases X\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_leftUnitor_hom_snd","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\nX : Prod C₁ C₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.2 (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.2).hom","decl":"@[simp]\ntheorem prodMonoidal_leftUnitor_hom_snd (X : C₁ × C₂) :\n    ((λ_ X).hom : 𝟙_ _ ⊗ X ⟶ X).2 = (λ_ X.2).hom := by\n  cases X\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_leftUnitor_inv_fst","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\nX : Prod C₁ C₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.1 (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.1).inv","decl":"@[simp]\ntheorem prodMonoidal_leftUnitor_inv_fst (X : C₁ × C₂) :\n    ((λ_ X).inv : X ⟶ 𝟙_ _ ⊗ X).1 = (λ_ X.1).inv := by\n  cases X\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_leftUnitor_inv_snd","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\nX : Prod C₁ C₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.2 (CategoryTheory.MonoidalCategoryStruct.leftUnitor X.2).inv","decl":"@[simp]\ntheorem prodMonoidal_leftUnitor_inv_snd (X : C₁ × C₂) :\n    ((λ_ X).inv : X ⟶ 𝟙_ _ ⊗ X).2 = (λ_ X.2).inv := by\n  cases X\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_rightUnitor_hom_fst","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\nX : Prod C₁ C₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.1 (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.1).hom","decl":"@[simp]\ntheorem prodMonoidal_rightUnitor_hom_fst (X : C₁ × C₂) :\n    ((ρ_ X).hom : X ⊗ 𝟙_ _ ⟶ X).1 = (ρ_ X.1).hom := by\n  cases X\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_rightUnitor_hom_snd","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\nX : Prod C₁ C₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.2 (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.2).hom","decl":"@[simp]\ntheorem prodMonoidal_rightUnitor_hom_snd (X : C₁ × C₂) :\n    ((ρ_ X).hom : X ⊗ 𝟙_ _ ⟶ X).2 = (ρ_ X.2).hom := by\n  cases X\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_rightUnitor_inv_fst","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\nX : Prod C₁ C₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.1 (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.1).inv","decl":"@[simp]\ntheorem prodMonoidal_rightUnitor_inv_fst (X : C₁ × C₂) :\n    ((ρ_ X).inv : X ⟶ X ⊗ 𝟙_ _).1 = (ρ_ X.1).inv := by\n  cases X\n  rfl\n\n"}
{"name":"CategoryTheory.MonoidalCategory.prodMonoidal_rightUnitor_inv_snd","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"C₁ : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.MonoidalCategory C₁\nC₂ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝ : CategoryTheory.MonoidalCategory C₂\nX : Prod C₁ C₂\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.2 (CategoryTheory.MonoidalCategoryStruct.rightUnitor X.2).inv","decl":"@[simp]\ntheorem prodMonoidal_rightUnitor_inv_snd (X : C₁ × C₂) :\n    ((ρ_ X).inv : X ⟶ X ⊗ 𝟙_ _).2 = (ρ_ X.2).inv := by\n  cases X\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.tensor_naturality_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.MonoidalCategory C\nF G F' G' : CategoryTheory.Functor J C\nα : Quiver.Hom F F'\nβ : Quiver.Hom G G'\nX Y X' Y' : J\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F'.obj Y) (G'.obj Y')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (G.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (α.app Y) (β.app Y')) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (α.app X) (β.app X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F'.map f) (G'.map g)) h))","decl":"@[reassoc]\nlemma tensor_naturality {X Y X' Y' : J} (f : X ⟶ Y) (g : X' ⟶ Y') :\n    (F.map f ⊗ G.map g) ≫ (α.app Y ⊗ β.app Y') =\n      (α.app X ⊗ β.app X') ≫ (F'.map f ⊗ G'.map g) := by\n  simp only [← tensor_comp, naturality]\n\n"}
{"name":"CategoryTheory.NatTrans.tensor_naturality","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.MonoidalCategory C\nF G F' G' : CategoryTheory.Functor J C\nα : Quiver.Hom F F'\nβ : Quiver.Hom G G'\nX Y X' Y' : J\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map f) (G.map g)) (CategoryTheory.MonoidalCategoryStruct.tensorHom (α.app Y) (β.app Y'))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (α.app X) (β.app X')) (CategoryTheory.MonoidalCategoryStruct.tensorHom (F'.map f) (G'.map g)))","decl":"@[reassoc]\nlemma tensor_naturality {X Y X' Y' : J} (f : X ⟶ Y) (g : X' ⟶ Y') :\n    (F.map f ⊗ G.map g) ≫ (α.app Y ⊗ β.app Y') =\n      (α.app X ⊗ β.app X') ≫ (F'.map f ⊗ G'.map g) := by\n  simp only [← tensor_comp, naturality]\n\n"}
{"name":"CategoryTheory.NatTrans.whiskerRight_app_tensor_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.MonoidalCategory C\nF G F' G' : CategoryTheory.Functor J C\nα : Quiver.Hom F F'\nβ : Quiver.Hom G G'\nX Y : J\nf : Quiver.Hom X Y\nX' : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (G.obj X')) (CategoryTheory.MonoidalCategoryStruct.tensorHom (α.app Y) (β.app X'))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (α.app X) (β.app X')) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F'.map f) (G'.obj X')))","decl":"@[reassoc]\nlemma whiskerRight_app_tensor_app {X Y : J} (f : X ⟶ Y) (X' : J) :\n    F.map f ▷ G.obj X' ≫ (α.app Y ⊗ β.app X') =\n      (α.app X ⊗ β.app X') ≫ F'.map f ▷ (G'.obj X') := by\n  simpa using tensor_naturality α β f (𝟙 X')\n\n"}
{"name":"CategoryTheory.NatTrans.whiskerRight_app_tensor_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.MonoidalCategory C\nF G F' G' : CategoryTheory.Functor J C\nα : Quiver.Hom F F'\nβ : Quiver.Hom G G'\nX Y : J\nf : Quiver.Hom X Y\nX' : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F'.obj Y) (G'.obj X')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F.map f) (G.obj X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (α.app Y) (β.app X')) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (α.app X) (β.app X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (F'.map f) (G'.obj X')) h))","decl":"@[reassoc]\nlemma whiskerRight_app_tensor_app {X Y : J} (f : X ⟶ Y) (X' : J) :\n    F.map f ▷ G.obj X' ≫ (α.app Y ⊗ β.app X') =\n      (α.app X ⊗ β.app X') ≫ F'.map f ▷ (G'.obj X') := by\n  simpa using tensor_naturality α β f (𝟙 X')\n\n"}
{"name":"CategoryTheory.NatTrans.whiskerLeft_app_tensor_app","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.MonoidalCategory C\nF G F' G' : CategoryTheory.Functor J C\nα : Quiver.Hom F F'\nβ : Quiver.Hom G G'\nX' Y' : J\nf : Quiver.Hom X' Y'\nX : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (G.map f)) (CategoryTheory.MonoidalCategoryStruct.tensorHom (α.app X) (β.app Y'))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (α.app X) (β.app X')) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F'.obj X) (G'.map f)))","decl":"@[reassoc]\nlemma whiskerLeft_app_tensor_app {X' Y' : J} (f : X' ⟶ Y') (X : J) :\n    F.obj X ◁ G.map f ≫ (α.app X ⊗ β.app Y') =\n      (α.app X ⊗ β.app X') ≫ F'.obj X ◁ G'.map f := by\n  simpa using tensor_naturality α β (𝟙 X) f\n\n"}
{"name":"CategoryTheory.NatTrans.whiskerLeft_app_tensor_app_assoc","module":"Mathlib.CategoryTheory.Monoidal.Category","initialProofState":"J : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\nC : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.MonoidalCategory C\nF G F' G' : CategoryTheory.Functor J C\nα : Quiver.Hom F F'\nβ : Quiver.Hom G G'\nX' Y' : J\nf : Quiver.Hom X' Y'\nX : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (F'.obj X) (G'.obj Y')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F.obj X) (G.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (α.app X) (β.app Y')) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (α.app X) (β.app X')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (F'.obj X) (G'.map f)) h))","decl":"@[reassoc]\nlemma whiskerLeft_app_tensor_app {X' Y' : J} (f : X' ⟶ Y') (X : J) :\n    F.obj X ◁ G.map f ≫ (α.app X ⊗ β.app Y') =\n      (α.app X ⊗ β.app X') ≫ F'.obj X ◁ G'.map f := by\n  simpa using tensor_naturality α β (𝟙 X) f\n\n"}
