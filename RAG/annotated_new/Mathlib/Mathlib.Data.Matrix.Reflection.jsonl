{"name":"Matrix.forall_iff","module":"Mathlib.Data.Matrix.Reflection","initialProofState":"α : Type u_1\nm n : Nat\nP : Matrix (Fin m) (Fin n) α → Prop\n⊢ Iff (Matrix.Forall P) (∀ (x : Matrix (Fin m) (Fin n) α), P x)","decl":"/-- This can be used to prove\n```lean\nexample (P : Matrix (Fin 2) (Fin 3) α → Prop) :\n  (∀ x, P x) ↔ ∀ a b c d e f, P !![a, b, c; d, e, f] :=\n(forall_iff _).symm\n```\n-/\ntheorem forall_iff : ∀ {m n} (P : Matrix (Fin m) (Fin n) α → Prop), Forall P ↔ ∀ x, P x\n  | 0, _, _ => Iff.symm Fin.forall_fin_zero_pi\n  | m + 1, n, P => by\n    simp only [Forall, FinVec.forall_iff, forall_iff]\n    exact Iff.symm Fin.forall_fin_succ_pi\n\n"}
{"name":"Matrix.exists_iff","module":"Mathlib.Data.Matrix.Reflection","initialProofState":"α : Type u_1\nm n : Nat\nP : Matrix (Fin m) (Fin n) α → Prop\n⊢ Iff (Matrix.Exists P) (Exists fun x => P x)","decl":"/-- This can be used to prove\n```lean\nexample (P : Matrix (Fin 2) (Fin 3) α → Prop) :\n  (∃ x, P x) ↔ ∃ a b c d e f, P !![a, b, c; d, e, f] :=\n(exists_iff _).symm\n```\n-/\ntheorem exists_iff : ∀ {m n} (P : Matrix (Fin m) (Fin n) α → Prop), Exists P ↔ ∃ x, P x\n  | 0, _, _ => Iff.symm Fin.exists_fin_zero_pi\n  | m + 1, n, P => by\n    simp only [Exists, FinVec.exists_iff, exists_iff]\n    exact Iff.symm Fin.exists_fin_succ_pi\n\n"}
{"name":"Matrix.transposeᵣ_eq","module":"Mathlib.Data.Matrix.Reflection","initialProofState":"α : Type u_1\nm n : Nat\nA : Matrix (Fin m) (Fin n) α\n⊢ Eq A.transposeᵣ A.transpose","decl":"/-- This can be used to prove\n```lean\nexample (a b c d : α) : transpose !![a, b; c, d] = !![a, c; b, d] := (transposeᵣ_eq _).symm\n```\n-/\n@[simp]\ntheorem transposeᵣ_eq : ∀ {m n} (A : Matrix (Fin m) (Fin n) α), transposeᵣ A = transpose A\n  | _, 0, _ => Subsingleton.elim _ _\n  | m, n + 1, A =>\n    Matrix.ext fun i j => by\n      simp_rw [transposeᵣ, transposeᵣ_eq]\n      refine i.cases ?_ fun i => ?_\n      · dsimp\n        rw [FinVec.map_eq, Function.comp_apply]\n      · simp only [of_apply, Matrix.cons_val_succ]\n        rfl\n\n"}
{"name":"Matrix.dotProductᵣ_eq","module":"Mathlib.Data.Matrix.Reflection","initialProofState":"α : Type u_1\ninst✝¹ : Mul α\ninst✝ : AddCommMonoid α\nm : Nat\na b : Fin m → α\n⊢ Eq (Matrix.dotProductᵣ a b) (dotProduct a b)","decl":"/-- This can be used to prove\n```lean\nexample (a b c d : α) [Mul α] [AddCommMonoid α] :\n  dot_product ![a, b] ![c, d] = a * c + b * d :=\n(dot_productᵣ_eq _ _).symm\n```\n-/\n@[simp]\ntheorem dotProductᵣ_eq [Mul α] [AddCommMonoid α] {m} (a b : Fin m → α) :\n    dotProductᵣ a b = dotProduct a b := by\n  simp_rw [dotProductᵣ, dotProduct, FinVec.sum_eq, FinVec.seq_eq, FinVec.map_eq,\n      Function.comp_apply]\n\n"}
{"name":"Matrix.mulᵣ_eq","module":"Mathlib.Data.Matrix.Reflection","initialProofState":"l m n : Nat\nα : Type u_1\ninst✝¹ : Mul α\ninst✝ : AddCommMonoid α\nA : Matrix (Fin l) (Fin m) α\nB : Matrix (Fin m) (Fin n) α\n⊢ Eq (A.mulᵣ B) (HMul.hMul A B)","decl":"/-- This can be used to prove\n```lean\nexample [AddCommMonoid α] [Mul α] (a₁₁ a₁₂ a₂₁ a₂₂ b₁₁ b₁₂ b₂₁ b₂₂ : α) :\n  !![a₁₁, a₁₂;\n     a₂₁, a₂₂] * !![b₁₁, b₁₂;\n                    b₂₁, b₂₂] =\n  !![a₁₁*b₁₁ + a₁₂*b₂₁, a₁₁*b₁₂ + a₁₂*b₂₂;\n     a₂₁*b₁₁ + a₂₂*b₂₁, a₂₁*b₁₂ + a₂₂*b₂₂] :=\n(mulᵣ_eq _ _).symm\n```\n-/\n@[simp]\ntheorem mulᵣ_eq [Mul α] [AddCommMonoid α] (A : Matrix (Fin l) (Fin m) α)\n    (B : Matrix (Fin m) (Fin n) α) : mulᵣ A B = A * B := by\n  simp [mulᵣ, Function.comp, Matrix.transpose]\n  rfl\n\n"}
{"name":"Matrix.mulVecᵣ_eq","module":"Mathlib.Data.Matrix.Reflection","initialProofState":"l m : Nat\nα : Type u_1\ninst✝ : NonUnitalNonAssocSemiring α\nA : Matrix (Fin l) (Fin m) α\nv : Fin m → α\n⊢ Eq (A.mulVecᵣ v) (A.mulVec v)","decl":"/-- This can be used to prove\n```lean\nexample [NonUnitalNonAssocSemiring α] (a₁₁ a₁₂ a₂₁ a₂₂ b₁ b₂ : α) :\n  !![a₁₁, a₁₂;\n     a₂₁, a₂₂] *ᵥ ![b₁, b₂] = ![a₁₁*b₁ + a₁₂*b₂, a₂₁*b₁ + a₂₂*b₂] :=\n(mulVecᵣ_eq _ _).symm\n```\n-/\n@[simp]\ntheorem mulVecᵣ_eq [NonUnitalNonAssocSemiring α] (A : Matrix (Fin l) (Fin m) α) (v : Fin m → α) :\n    mulVecᵣ A v = A *ᵥ v := by\n  simp [mulVecᵣ, Function.comp]\n  rfl\n\n"}
{"name":"Matrix.vecMulᵣ_eq","module":"Mathlib.Data.Matrix.Reflection","initialProofState":"l m : Nat\nα : Type u_1\ninst✝ : NonUnitalNonAssocSemiring α\nv : Fin l → α\nA : Matrix (Fin l) (Fin m) α\n⊢ Eq (Matrix.vecMulᵣ v A) (Matrix.vecMul v A)","decl":"/-- This can be used to prove\n```lean\nexample [NonUnitalNonAssocSemiring α] (a₁₁ a₁₂ a₂₁ a₂₂ b₁ b₂ : α) :\n  ![b₁, b₂] ᵥ* !![a₁₁, a₁₂;\n                       a₂₁, a₂₂] = ![b₁*a₁₁ + b₂*a₂₁, b₁*a₁₂ + b₂*a₂₂] :=\n(vecMulᵣ_eq _ _).symm\n```\n-/\n@[simp]\ntheorem vecMulᵣ_eq [NonUnitalNonAssocSemiring α] (v : Fin l → α) (A : Matrix (Fin l) (Fin m) α) :\n    vecMulᵣ v A = v ᵥ* A := by\n  simp [vecMulᵣ, Function.comp]\n  rfl\n\n"}
{"name":"Matrix.etaExpand_eq","module":"Mathlib.Data.Matrix.Reflection","initialProofState":"α : Type u_1\nm n : Nat\nA : Matrix (Fin m) (Fin n) α\n⊢ Eq A.etaExpand A","decl":"/-- This can be used to prove\n```lean\nexample (A : Matrix (Fin 2) (Fin 2) α) :\n  A = !![A 0 0, A 0 1;\n         A 1 0, A 1 1] :=\n(etaExpand_eq _).symm\n```\n-/\ntheorem etaExpand_eq {m n} (A : Matrix (Fin m) (Fin n) α) : etaExpand A = A := by\n  simp_rw [etaExpand, FinVec.etaExpand_eq, Matrix.of]\n  -- This to be in the above `simp_rw` before https://github.com/leanprover/lean4/pull/2644\n  erw [Equiv.refl_apply]\n\n"}
