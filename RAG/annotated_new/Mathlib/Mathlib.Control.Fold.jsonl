{"name":"Monoid.Foldl.ofFreeMonoid_apply","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nf : β → α → β\nxs : FreeMonoid α\n⊢ Eq ((Monoid.Foldl.ofFreeMonoid f) xs) (MulOpposite.op (flip (List.foldl f) (FreeMonoid.toList xs)))","decl":"@[simps]\ndef Foldl.ofFreeMonoid (f : β → α → β) : FreeMonoid α →* Monoid.Foldl β where\n  toFun xs := op <| flip (List.foldl f) (FreeMonoid.toList xs)\n  map_one' := rfl\n  map_mul' := by\n    intros\n    simp only [FreeMonoid.toList_mul, unop_op, List.foldl_append, op_inj, Function.flip_def]\n    rfl\n\n"}
{"name":"Monoid.Foldr.ofFreeMonoid_apply","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nf : α → β → β\nxs : FreeMonoid α\na✝ : β\n⊢ Eq ((Monoid.Foldr.ofFreeMonoid f) xs a✝) (flip (List.foldr f) (FreeMonoid.toList xs) a✝)","decl":"@[simps]\ndef Foldr.ofFreeMonoid (f : α → β → β) : FreeMonoid α →* Monoid.Foldr β where\n  toFun xs := flip (List.foldr f) (FreeMonoid.toList xs)\n  map_one' := rfl\n  map_mul' _ _ := funext fun _ => List.foldr_append _ _ _ _\n\n"}
{"name":"Monoid.foldlM.ofFreeMonoid_apply","module":"Mathlib.Control.Fold","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\nα β : Type u\ninst✝ : LawfulMonad m\nf : β → α → m β\nxs : FreeMonoid α\n⊢ Eq ((Monoid.foldlM.ofFreeMonoid f) xs) (MulOpposite.op (flip (List.foldlM f) (FreeMonoid.toList xs)))","decl":"@[simps]\ndef foldlM.ofFreeMonoid [LawfulMonad m] (f : β → α → m β) : FreeMonoid α →* Monoid.foldlM m β where\n  toFun xs := op <| flip (List.foldlM f) (FreeMonoid.toList xs)\n  map_one' := rfl\n  map_mul' := by intros; apply unop_injective; funext; apply List.foldlM_append\n\n"}
{"name":"Monoid.foldrM.ofFreeMonoid_apply","module":"Mathlib.Control.Fold","initialProofState":"m : Type u → Type u\ninst✝¹ : Monad m\nα β : Type u\ninst✝ : LawfulMonad m\nf : α → β → m β\nxs : FreeMonoid α\na✝ : CategoryTheory.KleisliCat.mk m β\n⊢ Eq ((Monoid.foldrM.ofFreeMonoid f) xs a✝) (flip (List.foldrM f) (FreeMonoid.toList xs) a✝)","decl":"@[simps]\ndef foldrM.ofFreeMonoid [LawfulMonad m] (f : α → β → m β) : FreeMonoid α →* Monoid.foldrM m β where\n  toFun xs := flip (List.foldrM f) (FreeMonoid.toList xs)\n  map_one' := rfl\n  map_mul' := by intros; funext; apply List.foldrM_append\n\n"}
{"name":"Traversable.Free.map_eq_map","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nf : α → β\nxs : List α\n⊢ Eq (Functor.map f xs) (FreeMonoid.toList ((FreeMonoid.map f) (FreeMonoid.ofList xs)))","decl":"theorem Free.map_eq_map (f : α → β) (xs : List α) :\n    f <$> xs = (FreeMonoid.toList (FreeMonoid.map f (FreeMonoid.ofList xs))) :=\n  rfl\n\n"}
{"name":"Traversable.foldl.unop_ofFreeMonoid","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nf : β → α → β\nxs : FreeMonoid α\na : β\n⊢ Eq (MulOpposite.unop ((Monoid.Foldl.ofFreeMonoid f) xs) a) (List.foldl f a (FreeMonoid.toList xs))","decl":"theorem foldl.unop_ofFreeMonoid (f : β → α → β) (xs : FreeMonoid α) (a : β) :\n    unop (Foldl.ofFreeMonoid f xs) a = List.foldl f a (FreeMonoid.toList xs) :=\n  rfl\n\n"}
{"name":"Traversable.foldMap_hom","module":"Mathlib.Control.Fold","initialProofState":"α β γ : Type u\nt : Type u → Type u\ninst✝³ : Traversable t\ninst✝² : LawfulTraversable t\ninst✝¹ : Monoid α\ninst✝ : Monoid β\nf : MonoidHom α β\ng : γ → α\nx : t γ\n⊢ Eq (f (Traversable.foldMap g x)) (Traversable.foldMap (Function.comp (⇑f) g) x)","decl":"theorem foldMap_hom [Monoid α] [Monoid β] (f : α →* β) (g : γ → α) (x : t γ) :\n    f (foldMap g x) = foldMap (f ∘ g) x :=\n  calc\n    f (foldMap g x) = f (traverse (Const.mk' ∘ g) x) := rfl\n    _ = (mapFold f).app _ (traverse (Const.mk' ∘ g) x) := rfl\n    _ = traverse ((mapFold f).app _ ∘ Const.mk' ∘ g) x := naturality (mapFold f) _ _\n    _ = foldMap (f ∘ g) x := rfl\n\n"}
{"name":"Traversable.foldMap_hom_free","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nt : Type u → Type u\ninst✝² : Traversable t\ninst✝¹ : LawfulTraversable t\ninst✝ : Monoid β\nf : MonoidHom (FreeMonoid α) β\nx : t α\n⊢ Eq (f (Traversable.foldMap FreeMonoid.of x)) (Traversable.foldMap (Function.comp (⇑f) FreeMonoid.of) x)","decl":"theorem foldMap_hom_free [Monoid β] (f : FreeMonoid α →* β) (x : t α) :\n    f (foldMap FreeMonoid.of x) = foldMap (f ∘ FreeMonoid.of) x :=\n  foldMap_hom f _ x\n\n"}
{"name":"Traversable.foldl.ofFreeMonoid_comp_of","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nf : α → β → α\n⊢ Eq (Function.comp (⇑(Monoid.Foldl.ofFreeMonoid f)) FreeMonoid.of) (Function.comp Monoid.Foldl.mk (flip f))","decl":"@[simp]\ntheorem foldl.ofFreeMonoid_comp_of (f : α → β → α) :\n    Foldl.ofFreeMonoid f ∘ FreeMonoid.of = Foldl.mk ∘ flip f :=\n  rfl\n\n"}
{"name":"Traversable.foldr.ofFreeMonoid_comp_of","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nf : β → α → α\n⊢ Eq (Function.comp (⇑(Monoid.Foldr.ofFreeMonoid f)) FreeMonoid.of) (Function.comp Monoid.Foldr.mk f)","decl":"@[simp]\ntheorem foldr.ofFreeMonoid_comp_of (f : β → α → α) :\n    Foldr.ofFreeMonoid f ∘ FreeMonoid.of = Foldr.mk ∘ f :=\n  rfl\n\n"}
{"name":"Traversable.foldlm.ofFreeMonoid_comp_of","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nf : α → β → m α\n⊢ Eq (Function.comp (⇑(Monoid.foldlM.ofFreeMonoid f)) FreeMonoid.of) (Function.comp Monoid.foldlM.mk (flip f))","decl":"@[simp]\ntheorem foldlm.ofFreeMonoid_comp_of {m} [Monad m] [LawfulMonad m] (f : α → β → m α) :\n    foldlM.ofFreeMonoid f ∘ FreeMonoid.of = foldlM.mk ∘ flip f := by\n  ext1 x\n  simp only [foldlM.ofFreeMonoid, Function.flip_def, MonoidHom.coe_mk, OneHom.coe_mk,\n    Function.comp_apply, FreeMonoid.toList_of, List.foldlM_cons, List.foldlM_nil, bind_pure,\n    foldlM.mk, op_inj]\n  rfl\n\n"}
{"name":"Traversable.foldrm.ofFreeMonoid_comp_of","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nm : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nf : β → α → m α\n⊢ Eq (Function.comp (⇑(Monoid.foldrM.ofFreeMonoid f)) FreeMonoid.of) (Function.comp Monoid.foldrM.mk f)","decl":"@[simp]\ntheorem foldrm.ofFreeMonoid_comp_of {m} [Monad m] [LawfulMonad m] (f : β → α → m α) :\n    foldrM.ofFreeMonoid f ∘ FreeMonoid.of = foldrM.mk ∘ f := by\n  ext\n  simp [(· ∘ ·), foldrM.ofFreeMonoid, foldrM.mk, Function.flip_def]\n\n"}
{"name":"Traversable.toList_spec","module":"Mathlib.Control.Fold","initialProofState":"α : Type u\nt : Type u → Type u\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\nxs : t α\n⊢ Eq (Traversable.toList xs) (FreeMonoid.toList (Traversable.foldMap FreeMonoid.of xs))","decl":"theorem toList_spec (xs : t α) : toList xs = FreeMonoid.toList (foldMap FreeMonoid.of xs) :=\n  Eq.symm <|\n    calc\n      FreeMonoid.toList (foldMap FreeMonoid.of xs) =\n          FreeMonoid.toList (foldMap FreeMonoid.of xs).reverse.reverse := by\n          simp only [FreeMonoid.reverse_reverse]\n      _ = (List.foldr cons [] (foldMap FreeMonoid.of xs).toList.reverse).reverse := by\n          simp only [FreeMonoid.reverse_reverse, List.foldr_reverse, List.foldl_flip_cons_eq_append,\n            List.append_nil, List.reverse_reverse]\n      _ = (unop (Foldl.ofFreeMonoid (flip cons) (foldMap FreeMonoid.of xs)) []).reverse := by\n            simp [Function.flip_def, List.foldr_reverse, Foldl.ofFreeMonoid, unop_op]\n      _ = toList xs := by\n            rw [foldMap_hom_free (Foldl.ofFreeMonoid (flip <| @cons α))]\n            simp only [toList, foldl, List.reverse_inj, Foldl.get, foldl.ofFreeMonoid_comp_of,\n              Function.comp_apply]\n\n"}
{"name":"Traversable.foldMap_map","module":"Mathlib.Control.Fold","initialProofState":"α β γ : Type u\nt : Type u → Type u\ninst✝² : Traversable t\ninst✝¹ : LawfulTraversable t\ninst✝ : Monoid γ\nf : α → β\ng : β → γ\nxs : t α\n⊢ Eq (Traversable.foldMap g (Functor.map f xs)) (Traversable.foldMap (Function.comp g f) xs)","decl":"theorem foldMap_map [Monoid γ] (f : α → β) (g : β → γ) (xs : t α) :\n    foldMap g (f <$> xs) = foldMap (g ∘ f) xs := by\n  simp only [foldMap, traverse_map, Function.comp_def]\n\n"}
{"name":"Traversable.foldl_toList","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nt : Type u → Type u\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\nf : α → β → α\nxs : t β\nx : α\n⊢ Eq (Traversable.foldl f x xs) (List.foldl f x (Traversable.toList xs))","decl":"theorem foldl_toList (f : α → β → α) (xs : t β) (x : α) :\n    foldl f x xs = List.foldl f x (toList xs) := by\n  rw [← FreeMonoid.toList_ofList (toList xs), ← foldl.unop_ofFreeMonoid]\n  simp only [foldl, toList_spec, foldMap_hom_free, foldl.ofFreeMonoid_comp_of, Foldl.get,\n    FreeMonoid.ofList_toList]\n\n"}
{"name":"Traversable.foldr_toList","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nt : Type u → Type u\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\nf : α → β → β\nxs : t α\nx : β\n⊢ Eq (Traversable.foldr f x xs) (List.foldr f x (Traversable.toList xs))","decl":"theorem foldr_toList (f : α → β → β) (xs : t α) (x : β) :\n    foldr f x xs = List.foldr f x (toList xs) := by\n  change _ = Foldr.ofFreeMonoid _ (FreeMonoid.ofList <| toList xs) _\n  rw [toList_spec, foldr, Foldr.get, FreeMonoid.ofList_toList, foldMap_hom_free,\n    foldr.ofFreeMonoid_comp_of]\n\n"}
{"name":"Traversable.toList_map","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nt : Type u → Type u\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\nf : α → β\nxs : t α\n⊢ Eq (Traversable.toList (Functor.map f xs)) (Functor.map f (Traversable.toList xs))","decl":"theorem toList_map (f : α → β) (xs : t α) : toList (f <$> xs) = f <$> toList xs := by\n  simp only [toList_spec, Free.map_eq_map, foldMap_hom, foldMap_map, FreeMonoid.ofList_toList,\n    FreeMonoid.map_of, Function.comp_def]\n\n"}
{"name":"Traversable.foldl_map","module":"Mathlib.Control.Fold","initialProofState":"α β γ : Type u\nt : Type u → Type u\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\ng : β → γ\nf : α → γ → α\na : α\nl : t β\n⊢ Eq (Traversable.foldl f a (Functor.map g l)) (Traversable.foldl (fun x y => f x (g y)) a l)","decl":"@[simp]\ntheorem foldl_map (g : β → γ) (f : α → γ → α) (a : α) (l : t β) :\n    foldl f a (g <$> l) = foldl (fun x y => f x (g y)) a l := by\n  simp only [foldl, foldMap_map, Function.comp_def, Function.flip_def]\n\n"}
{"name":"Traversable.foldr_map","module":"Mathlib.Control.Fold","initialProofState":"α β γ : Type u\nt : Type u → Type u\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\ng : β → γ\nf : γ → α → α\na : α\nl : t β\n⊢ Eq (Traversable.foldr f a (Functor.map g l)) (Traversable.foldr (Function.comp f g) a l)","decl":"@[simp]\ntheorem foldr_map (g : β → γ) (f : γ → α → α) (a : α) (l : t β) :\n    foldr f a (g <$> l) = foldr (f ∘ g) a l := by\n  simp only [foldr, foldMap_map, Function.comp_def, flip]\n\n"}
{"name":"Traversable.toList_eq_self","module":"Mathlib.Control.Fold","initialProofState":"α : Type u\nxs : List α\n⊢ Eq (Traversable.toList xs) xs","decl":"@[simp]\ntheorem toList_eq_self {xs : List α} : toList xs = xs := by\n  simp only [toList_spec, foldMap, traverse]\n  induction xs with\n  | nil => rfl\n  | cons _ _ ih => (conv_rhs => rw [← ih]); rfl\n\n"}
{"name":"Traversable.length_toList","module":"Mathlib.Control.Fold","initialProofState":"α : Type u\nt : Type u → Type u\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\nxs : t α\n⊢ Eq (Traversable.length xs) (Traversable.toList xs).length","decl":"theorem length_toList {xs : t α} : length xs = List.length (toList xs) := by\n  unfold length\n  rw [foldl_toList]\n  generalize toList xs = ys\n  rw [← Nat.add_zero ys.length]\n  generalize 0 = n\n  induction ys generalizing n with\n  | nil => simp\n  | cons _ _ ih => simp_arith [ih]\n\n"}
{"name":"Traversable.foldlm_toList","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nt : Type u → Type u\ninst✝³ : Traversable t\ninst✝² : LawfulTraversable t\nm : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nf : α → β → m α\nx : α\nxs : t β\n⊢ Eq (Traversable.foldlm f x xs) (List.foldlM f x (Traversable.toList xs))","decl":"theorem foldlm_toList {f : α → β → m α} {x : α} {xs : t β} :\n    foldlm f x xs = List.foldlM f x (toList xs) :=\n  calc foldlm f x xs\n    _ = unop (foldlM.ofFreeMonoid f (FreeMonoid.ofList <| toList xs)) x := by\n      simp only [foldlm, toList_spec, foldMap_hom_free (foldlM.ofFreeMonoid f),\n        foldlm.ofFreeMonoid_comp_of, foldlM.get, FreeMonoid.ofList_toList]\n    _ = List.foldlM f x (toList xs) := by simp [foldlM.ofFreeMonoid, unop_op, flip]\n\n"}
{"name":"Traversable.foldrm_toList","module":"Mathlib.Control.Fold","initialProofState":"α β : Type u\nt : Type u → Type u\ninst✝³ : Traversable t\ninst✝² : LawfulTraversable t\nm : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nf : α → β → m β\nx : β\nxs : t α\n⊢ Eq (Traversable.foldrm f x xs) (List.foldrM f x (Traversable.toList xs))","decl":"theorem foldrm_toList (f : α → β → m β) (x : β) (xs : t α) :\n    foldrm f x xs = List.foldrM f x (toList xs) := by\n  change _ = foldrM.ofFreeMonoid f (FreeMonoid.ofList <| toList xs) x\n  simp only [foldrm, toList_spec, foldMap_hom_free (foldrM.ofFreeMonoid f),\n    foldrm.ofFreeMonoid_comp_of, foldrM.get, FreeMonoid.ofList_toList]\n\n"}
{"name":"Traversable.foldlm_map","module":"Mathlib.Control.Fold","initialProofState":"α β γ : Type u\nt : Type u → Type u\ninst✝³ : Traversable t\ninst✝² : LawfulTraversable t\nm : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\ng : β → γ\nf : α → γ → m α\na : α\nl : t β\n⊢ Eq (Traversable.foldlm f a (Functor.map g l)) (Traversable.foldlm (fun x y => f x (g y)) a l)","decl":"@[simp]\ntheorem foldlm_map (g : β → γ) (f : α → γ → m α) (a : α) (l : t β) :\n    foldlm f a (g <$> l) = foldlm (fun x y => f x (g y)) a l := by\n  simp only [foldlm, foldMap_map, Function.comp_def, Function.flip_def]\n\n"}
{"name":"Traversable.foldrm_map","module":"Mathlib.Control.Fold","initialProofState":"α β γ : Type u\nt : Type u → Type u\ninst✝³ : Traversable t\ninst✝² : LawfulTraversable t\nm : Type u → Type u\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\ng : β → γ\nf : γ → α → m α\na : α\nl : t β\n⊢ Eq (Traversable.foldrm f a (Functor.map g l)) (Traversable.foldrm (Function.comp f g) a l)","decl":"@[simp]\ntheorem foldrm_map (g : β → γ) (f : γ → α → m α) (a : α) (l : t β) :\n    foldrm f a (g <$> l) = foldrm (f ∘ g) a l := by\n  simp only [foldrm, foldMap_map, Function.comp_def, flip]\n\n"}
