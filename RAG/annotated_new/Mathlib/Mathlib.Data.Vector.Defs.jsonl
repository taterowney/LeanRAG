{"name":"List.Vector.head_cons","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n\n⊢ Eq (List.Vector.cons a v).head a","decl":"/-- The head of a vector obtained by prepending is the element prepended. -/\ntheorem head_cons (a : α) : ∀ v : Vector α n, head (cons a v) = a\n  | ⟨_, _⟩ => rfl\n\n"}
{"name":"List.Vector.tail_cons","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n\n⊢ Eq (List.Vector.cons a v).tail v","decl":"/-- The tail of a vector obtained by prepending is the vector prepended. to -/\ntheorem tail_cons (a : α) : ∀ v : Vector α n, tail (cons a v) = v\n  | ⟨_, _⟩ => rfl\n\n"}
{"name":"List.Vector.cons_head_tail","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n.succ\n⊢ Eq (List.Vector.cons v.head v.tail) v","decl":"/-- Prepending the head of a vector to its tail gives the vector. -/\n@[simp]\ntheorem cons_head_tail : ∀ v : Vector α (succ n), cons (head v) (tail v) = v\n  | ⟨[], h⟩ => by contradiction\n  | ⟨_ :: _, _⟩ => rfl\n\n"}
{"name":"List.Vector.map_nil","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (List.Vector.map f List.Vector.nil) List.Vector.nil","decl":"/-- A `nil` vector maps to a `nil` vector. -/\n@[simp]\ntheorem map_nil (f : α → β) : map f nil = nil :=\n  rfl\n\n"}
{"name":"List.Vector.map_cons","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\nf : α → β\na : α\nv : List.Vector α n\n⊢ Eq (List.Vector.map f (List.Vector.cons a v)) (List.Vector.cons (f a) (List.Vector.map f v))","decl":"/-- `map` is natural with respect to `cons`. -/\n@[simp]\ntheorem map_cons (f : α → β) (a : α) : ∀ v : Vector α n, map f (cons a v) = cons (f a) (map f v)\n  | ⟨_, _⟩ => rfl\n\n"}
{"name":"List.Vector.pmap_nil","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\np : α → Prop\nf : (a : α) → p a → β\nhp : ∀ (x : α), Membership.mem List.Vector.nil.toList x → p x\n⊢ Eq (List.Vector.pmap f List.Vector.nil hp) List.Vector.nil","decl":"@[simp]\ntheorem pmap_nil (f : (a : α) → p a → β) (hp : ∀ x ∈ nil.toList, p x) :\n    nil.pmap f hp = nil := rfl\n\n"}
{"name":"List.Vector.eq","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nn : Nat\na1 a2 : List.Vector α n\na✝ : Eq a1.toList a2.toList\n⊢ Eq a1 a2","decl":"/-- Vector is determined by the underlying list. -/\nprotected theorem eq {n : ℕ} : ∀ a1 a2 : Vector α n, toList a1 = toList a2 → a1 = a2\n  | ⟨_, _⟩, ⟨_, _⟩, rfl => rfl\n\n"}
{"name":"List.Vector.eq_nil","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nv : List.Vector α 0\n⊢ Eq v List.Vector.nil","decl":"/-- A vector of length `0` is a `nil` vector. -/\nprotected theorem eq_nil (v : Vector α 0) : v = nil :=\n  v.eq nil (List.eq_nil_of_length_eq_zero v.2)\n\n"}
{"name":"List.Vector.toList_mk","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nn : Nat\nv : List α\nP : Eq v.length n\n⊢ Eq (List.Vector.toList ⟨v, P⟩) v","decl":"/-- Vector of length from a list `v`\nwith witness that `v` has length `n` maps to `v` under `toList`. -/\n@[simp]\ntheorem toList_mk (v : List α) (P : List.length v = n) : toList (Subtype.mk v P) = v :=\n  rfl\n\n"}
{"name":"List.Vector.toList_nil","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\n⊢ Eq List.Vector.nil.toList List.nil","decl":"/-- A nil vector maps to a nil list. -/\n@[simp]\ntheorem toList_nil : toList nil = @List.nil α :=\n  rfl\n\n"}
{"name":"List.Vector.toList_length","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\n⊢ Eq v.toList.length n","decl":"/-- The length of the list to which a vector of length `n` maps is `n`. -/\n@[simp]\ntheorem toList_length (v : Vector α n) : (toList v).length = n :=\n  v.2\n\n"}
{"name":"List.Vector.toList_cons","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n\n⊢ Eq (List.Vector.cons a v).toList (List.cons a v.toList)","decl":"/-- `toList` of `cons` of a vector and an element is\nthe `cons` of the list obtained by `toList` and the element -/\n@[simp]\ntheorem toList_cons (a : α) (v : Vector α n) : toList (cons a v) = a :: toList v := by\n  cases v; rfl\n\n"}
{"name":"List.Vector.toList_append","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nn m : Nat\nv : List.Vector α n\nw : List.Vector α m\n⊢ Eq (v.append w).toList (HAppend.hAppend v.toList w.toList)","decl":"/-- Appending of vectors corresponds under `toList` to appending of lists. -/\n@[simp]\ntheorem toList_append {n m : ℕ} (v : Vector α n) (w : Vector α m) :\n    toList (append v w) = toList v ++ toList w := by\n  cases v\n  cases w\n  rfl\n\n"}
{"name":"List.Vector.toList_drop","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nn m : Nat\nv : List.Vector α m\n⊢ Eq (List.Vector.drop n v).toList (List.drop n v.toList)","decl":"/-- `drop` of vectors corresponds under `toList` to `drop` of lists. -/\n@[simp]\ntheorem toList_drop {n m : ℕ} (v : Vector α m) : toList (drop n v) = List.drop n (toList v) := by\n  cases v\n  rfl\n\n"}
{"name":"List.Vector.toList_take","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nn m : Nat\nv : List.Vector α m\n⊢ Eq (List.Vector.take n v).toList (List.take n v.toList)","decl":"/-- `take` of vectors corresponds under `toList` to `take` of lists. -/\n@[simp]\ntheorem toList_take {n m : ℕ} (v : Vector α m) : toList (take n v) = List.take n (toList v) := by\n  cases v\n  rfl\n\n"}
{"name":"List.Vector.getElem_def","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\ni : Nat\nhi : LT.lt i n\n⊢ Eq (GetElem.getElem v i ⋯) (GetElem.getElem v.toList i ⋯)","decl":"lemma getElem_def (v : Vector α n) (i : ℕ) {hi : i < n} :\n    v[i] = v.toList[i]'(by simpa) := rfl\n\n"}
{"name":"List.Vector.toList_getElem","module":"Mathlib.Data.Vector.Defs","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\ni : Nat\nhi : LT.lt i v.toList.length\n⊢ Eq (GetElem.getElem v.toList i ⋯) (GetElem.getElem v i ⋯)","decl":"lemma toList_getElem (v : Vector α n) (i : ℕ) {hi : i < v.toList.length} :\n    v.toList[i] = v[i]'(by simp_all) := rfl\n\n"}
