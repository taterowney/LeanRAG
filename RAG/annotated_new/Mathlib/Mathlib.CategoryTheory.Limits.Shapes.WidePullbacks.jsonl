{"name":"CategoryTheory.Limits.WidePullbackShape.subsingleton_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\n‚ä¢ Quiver.IsThin (CategoryTheory.Limits.WidePullbackShape J)","decl":"instance subsingleton_hom : Quiver.IsThin (WidePullbackShape J) := fun _ _ => by\n  constructor\n  intro a b\n  casesm* WidePullbackShape _, (_ : WidePullbackShape _) ‚ü∂ (_ : WidePullbackShape _)\n  ¬∑ rfl\n  ¬∑ rfl\n  ¬∑ rfl\n\n"}
{"name":"CategoryTheory.Limits.WidePullbackShape.hom_id","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX : CategoryTheory.Limits.WidePullbackShape J\n‚ä¢ Eq (CategoryTheory.Limits.WidePullbackShape.Hom.id X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem hom_id (X : WidePullbackShape J) : Hom.id X = ùüô X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WidePullbackShape.wideCospan_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom (objs j) B\nj : CategoryTheory.Limits.WidePullbackShape J\n‚ä¢ Eq ((CategoryTheory.Limits.WidePullbackShape.wideCospan B objs arrows).obj j) (Option.casesOn j B objs)","decl":"/-- Construct a functor out of the wide pullback shape given a J-indexed collection of arrows to a\nfixed object.\n-/\n@[simps]\ndef wideCospan (B : C) (objs : J ‚Üí C) (arrows : ‚àÄ j : J, objs j ‚ü∂ B) : WidePullbackShape J ‚•§ C where\n  obj j := Option.casesOn j B objs\n  map f := by\n    cases' f with _ j\n    ¬∑ apply ùüô _\n    ¬∑ exact arrows j\n\n"}
{"name":"CategoryTheory.Limits.WidePullbackShape.wideCospan_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom (objs j) B\nX‚úù Y‚úù : CategoryTheory.Limits.WidePullbackShape J\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.WidePullbackShape.wideCospan B objs arrows).map f) (CategoryTheory.Limits.WidePullbackShape.Hom.casesOn (motive := fun a a_1 t => Eq X‚úù a ‚Üí Eq Y‚úù a_1 ‚Üí HEq f t ‚Üí Quiver.Hom ((fun j => Option.casesOn j B objs) X‚úù) ((fun j => Option.casesOn j B objs) Y‚úù)) f (fun X h => Eq.ndrec (motive := fun X => Eq Y‚úù X ‚Üí HEq f (CategoryTheory.Limits.WidePullbackShape.Hom.id X) ‚Üí Quiver.Hom ((fun j => Option.casesOn j B objs) X‚úù) ((fun j => Option.casesOn j B objs) Y‚úù)) (fun h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom X‚úù Y) ‚Üí HEq f (CategoryTheory.Limits.WidePullbackShape.Hom.id X‚úù) ‚Üí Quiver.Hom ((fun j => Option.casesOn j B objs) X‚úù) ((fun j => Option.casesOn j B objs) Y)) (fun f h => CategoryTheory.CategoryStruct.id ((fun j => Option.casesOn j B objs) X‚úù)) ‚ãØ f) h) (fun j h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Y‚úù) ‚Üí Eq Y‚úù Option.none ‚Üí HEq f (CategoryTheory.Limits.WidePullbackShape.Hom.term j) ‚Üí Quiver.Hom ((fun j => Option.casesOn j B objs) X) ((fun j => Option.casesOn j B objs) Y‚úù)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom (Option.some j) Y) ‚Üí HEq f (CategoryTheory.Limits.WidePullbackShape.Hom.term j) ‚Üí Quiver.Hom ((fun j => Option.casesOn j B objs) (Option.some j)) ((fun j => Option.casesOn j B objs) Y)) (fun f h => arrows j) ‚ãØ f) ‚ãØ f) ‚ãØ ‚ãØ ‚ãØ)","decl":"/-- Construct a functor out of the wide pullback shape given a J-indexed collection of arrows to a\nfixed object.\n-/\n@[simps]\ndef wideCospan (B : C) (objs : J ‚Üí C) (arrows : ‚àÄ j : J, objs j ‚ü∂ B) : WidePullbackShape J ‚•§ C where\n  obj j := Option.casesOn j B objs\n  map f := by\n    cases' f with _ j\n    ¬∑ apply ùüô _\n    ¬∑ exact arrows j\n\n"}
{"name":"CategoryTheory.Limits.WidePullbackShape.mkCone_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WidePullbackShape J) C\nX : C\nf : Quiver.Hom X (F.obj Option.none)\nœÄ : (j : J) ‚Üí Quiver.Hom X (F.obj (Option.some j))\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (œÄ j) (F.map (CategoryTheory.Limits.WidePullbackShape.Hom.term j))) f\nj : CategoryTheory.Limits.WidePullbackShape J\n‚ä¢ Eq ((CategoryTheory.Limits.WidePullbackShape.mkCone f œÄ w).œÄ.app j) (CategoryTheory.Limits.WidePullbackShape.mkCone.match_1 (fun j => Quiver.Hom (((CategoryTheory.Functor.const (CategoryTheory.Limits.WidePullbackShape J)).obj X).obj j) (F.obj j)) j (fun _ => f) fun j => œÄ j)","decl":"/-- Construct a cone over a wide cospan. -/\n@[simps]\ndef mkCone {F : WidePullbackShape J ‚•§ C} {X : C} (f : X ‚ü∂ F.obj none) (œÄ : ‚àÄ j, X ‚ü∂ F.obj (some j))\n    (w : ‚àÄ j, œÄ j ‚â´ F.map (Hom.term j) = f) : Cone F :=\n  { pt := X\n    œÄ :=\n      { app := fun j =>\n          match j with\n          | none => f\n          | some j => œÄ j\n        naturality := fun j j' f => by\n          cases j <;> cases j' <;> cases f <;> dsimp <;> simp [w] } }\n\n"}
{"name":"CategoryTheory.Limits.WidePullbackShape.mkCone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WidePullbackShape J) C\nX : C\nf : Quiver.Hom X (F.obj Option.none)\nœÄ : (j : J) ‚Üí Quiver.Hom X (F.obj (Option.some j))\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (œÄ j) (F.map (CategoryTheory.Limits.WidePullbackShape.Hom.term j))) f\n‚ä¢ Eq (CategoryTheory.Limits.WidePullbackShape.mkCone f œÄ w).pt X","decl":"/-- Construct a cone over a wide cospan. -/\n@[simps]\ndef mkCone {F : WidePullbackShape J ‚•§ C} {X : C} (f : X ‚ü∂ F.obj none) (œÄ : ‚àÄ j, X ‚ü∂ F.obj (some j))\n    (w : ‚àÄ j, œÄ j ‚â´ F.map (Hom.term j) = f) : Cone F :=\n  { pt := X\n    œÄ :=\n      { app := fun j =>\n          match j with\n          | none => f\n          | some j => œÄ j\n        naturality := fun j j' f => by\n          cases j <;> cases j' <;> cases f <;> dsimp <;> simp [w] } }\n\n"}
{"name":"CategoryTheory.Limits.WidePushoutShape.subsingleton_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\n‚ä¢ Quiver.IsThin (CategoryTheory.Limits.WidePushoutShape J)","decl":"instance subsingleton_hom : Quiver.IsThin (WidePushoutShape J) := fun _ _ => by\n  constructor\n  intro a b\n  casesm* WidePushoutShape _, (_ : WidePushoutShape _) ‚ü∂ (_ : WidePushoutShape _)\n  repeat rfl\n\n"}
{"name":"CategoryTheory.Limits.WidePushoutShape.hom_id","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX : CategoryTheory.Limits.WidePushoutShape J\n‚ä¢ Eq (CategoryTheory.Limits.WidePushoutShape.Hom.id X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem hom_id (X : WidePushoutShape J) : Hom.id X = ùüô X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WidePushoutShape.wideSpan_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom B (objs j)\nX‚úù Y‚úù : CategoryTheory.Limits.WidePushoutShape J\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.WidePushoutShape.wideSpan B objs arrows).map f) (CategoryTheory.Limits.WidePushoutShape.Hom.casesOn (motive := fun a a_1 t => Eq X‚úù a ‚Üí Eq Y‚úù a_1 ‚Üí HEq f t ‚Üí Quiver.Hom ((fun j => Option.casesOn j B objs) X‚úù) ((fun j => Option.casesOn j B objs) Y‚úù)) f (fun X h => Eq.ndrec (motive := fun X => Eq Y‚úù X ‚Üí HEq f (CategoryTheory.Limits.WidePushoutShape.Hom.id X) ‚Üí Quiver.Hom ((fun j => Option.casesOn j B objs) X‚úù) ((fun j => Option.casesOn j B objs) Y‚úù)) (fun h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom X‚úù Y) ‚Üí HEq f (CategoryTheory.Limits.WidePushoutShape.Hom.id X‚úù) ‚Üí Quiver.Hom ((fun j => Option.casesOn j B objs) X‚úù) ((fun j => Option.casesOn j B objs) Y)) (fun f h => CategoryTheory.CategoryStruct.id ((fun j => Option.casesOn j B objs) X‚úù)) ‚ãØ f) h) (fun j h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Y‚úù) ‚Üí Eq Y‚úù (Option.some j) ‚Üí HEq f (CategoryTheory.Limits.WidePushoutShape.Hom.init j) ‚Üí Quiver.Hom ((fun j => Option.casesOn j B objs) X) ((fun j => Option.casesOn j B objs) Y‚úù)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom Option.none Y) ‚Üí HEq f (CategoryTheory.Limits.WidePushoutShape.Hom.init j) ‚Üí Quiver.Hom ((fun j => Option.casesOn j B objs) Option.none) ((fun j => Option.casesOn j B objs) Y)) (fun f h => arrows j) ‚ãØ f) ‚ãØ f) ‚ãØ ‚ãØ ‚ãØ)","decl":"/-- Construct a functor out of the wide pushout shape given a J-indexed collection of arrows from a\nfixed object.\n-/\n@[simps]\ndef wideSpan (B : C) (objs : J ‚Üí C) (arrows : ‚àÄ j : J, B ‚ü∂ objs j) : WidePushoutShape J ‚•§ C where\n  obj j := Option.casesOn j B objs\n  map f := by\n    cases' f with _ j\n    ¬∑ apply ùüô _\n    ¬∑ exact arrows j\n  map_comp := fun f g => by\n    cases f\n    ¬∑ simp only [Eq.ndrec, hom_id, eq_rec_constant, Category.id_comp]; congr\n    ¬∑ cases g\n      simp only [Eq.ndrec, hom_id, eq_rec_constant, Category.comp_id]; congr\n\n"}
{"name":"CategoryTheory.Limits.WidePushoutShape.wideSpan_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom B (objs j)\nj : CategoryTheory.Limits.WidePushoutShape J\n‚ä¢ Eq ((CategoryTheory.Limits.WidePushoutShape.wideSpan B objs arrows).obj j) (Option.casesOn j B objs)","decl":"/-- Construct a functor out of the wide pushout shape given a J-indexed collection of arrows from a\nfixed object.\n-/\n@[simps]\ndef wideSpan (B : C) (objs : J ‚Üí C) (arrows : ‚àÄ j : J, B ‚ü∂ objs j) : WidePushoutShape J ‚•§ C where\n  obj j := Option.casesOn j B objs\n  map f := by\n    cases' f with _ j\n    ¬∑ apply ùüô _\n    ¬∑ exact arrows j\n  map_comp := fun f g => by\n    cases f\n    ¬∑ simp only [Eq.ndrec, hom_id, eq_rec_constant, Category.id_comp]; congr\n    ¬∑ cases g\n      simp only [Eq.ndrec, hom_id, eq_rec_constant, Category.comp_id]; congr\n\n"}
{"name":"CategoryTheory.Limits.WidePushoutShape.mkCocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WidePushoutShape J) C\nX : C\nf : Quiver.Hom (F.obj Option.none) X\nŒπ : (j : J) ‚Üí Quiver.Hom (F.obj (Option.some j)) X\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.WidePushoutShape.Hom.init j)) (Œπ j)) f\n‚ä¢ Eq (CategoryTheory.Limits.WidePushoutShape.mkCocone f Œπ w).pt X","decl":"/-- Construct a cocone over a wide span. -/\n@[simps]\ndef mkCocone {F : WidePushoutShape J ‚•§ C} {X : C} (f : F.obj none ‚ü∂ X) (Œπ : ‚àÄ j, F.obj (some j) ‚ü∂ X)\n    (w : ‚àÄ j, F.map (Hom.init j) ‚â´ Œπ j = f) : Cocone F :=\n  { pt := X\n    Œπ :=\n      { app := fun j =>\n          match j with\n          | none => f\n          | some j => Œπ j\n        naturality := fun j j' f => by\n          cases j <;> cases j' <;> cases f <;> dsimp <;> simp [w] } }\n\n"}
{"name":"CategoryTheory.Limits.WidePushoutShape.mkCocone_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WidePushoutShape J) C\nX : C\nf : Quiver.Hom (F.obj Option.none) X\nŒπ : (j : J) ‚Üí Quiver.Hom (F.obj (Option.some j)) X\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.WidePushoutShape.Hom.init j)) (Œπ j)) f\nj : CategoryTheory.Limits.WidePushoutShape J\n‚ä¢ Eq ((CategoryTheory.Limits.WidePushoutShape.mkCocone f Œπ w).Œπ.app j) (CategoryTheory.Limits.WidePushoutShape.mkCocone.match_1 (fun j => Quiver.Hom (F.obj j) (((CategoryTheory.Functor.const (CategoryTheory.Limits.WidePushoutShape J)).obj X).obj j)) j (fun _ => f) fun j => Œπ j)","decl":"/-- Construct a cocone over a wide span. -/\n@[simps]\ndef mkCocone {F : WidePushoutShape J ‚•§ C} {X : C} (f : F.obj none ‚ü∂ X) (Œπ : ‚àÄ j, F.obj (some j) ‚ü∂ X)\n    (w : ‚àÄ j, F.map (Hom.init j) ‚â´ Œπ j = f) : Cocone F :=\n  { pt := X\n    Œπ :=\n      { app := fun j =>\n          match j with\n          | none => f\n          | some j => Œπ j\n        naturality := fun j j' f => by\n          cases j <;> cases j' <;> cases f <;> dsimp <;> simp [w] } }\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.œÄ_arrow","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom (objs j) B\ninst‚úù : CategoryTheory.Limits.HasWidePullback B objs arrows\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.œÄ arrows j) (arrows j)) (CategoryTheory.Limits.WidePullback.base arrows)","decl":"@[reassoc (attr := simp)]\ntheorem œÄ_arrow (j : J) : œÄ arrows j ‚â´ arrows _ = base arrows := by\n  apply limit.w (WidePullbackShape.wideCospan _ _ _) (WidePullbackShape.Hom.term j)\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.œÄ_arrow_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom (objs j) B\ninst‚úù : CategoryTheory.Limits.HasWidePullback B objs arrows\nj : J\nZ : C\nh : Quiver.Hom B Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.œÄ arrows j) (CategoryTheory.CategoryStruct.comp (arrows j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.base arrows) h)","decl":"@[reassoc (attr := simp)]\ntheorem œÄ_arrow (j : J) : œÄ arrows j ‚â´ arrows _ = base arrows := by\n  apply limit.w (WidePullbackShape.wideCospan _ _ _) (WidePullbackShape.Hom.term j)\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.lift_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom (objs j) B\ninst‚úù : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\nf : Quiver.Hom X B\nfs : (j : J) ‚Üí Quiver.Hom X (objs j)\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (fs j) (arrows j)) f\nj : J\nZ : C\nh : Quiver.Hom (objs j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.lift f fs w) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.œÄ arrows j) h)) (CategoryTheory.CategoryStruct.comp (fs j) h)","decl":"@[reassoc]\ntheorem lift_œÄ (j : J) : lift f fs w ‚â´ œÄ arrows j = fs _ := by\n  simp only [limit.lift_œÄ, WidePullbackShape.mkCone_pt, WidePullbackShape.mkCone_œÄ_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.lift_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom (objs j) B\ninst‚úù : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\nf : Quiver.Hom X B\nfs : (j : J) ‚Üí Quiver.Hom X (objs j)\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (fs j) (arrows j)) f\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.lift f fs w) (CategoryTheory.Limits.WidePullback.œÄ arrows j)) (fs j)","decl":"@[reassoc]\ntheorem lift_œÄ (j : J) : lift f fs w ‚â´ œÄ arrows j = fs _ := by\n  simp only [limit.lift_œÄ, WidePullbackShape.mkCone_pt, WidePullbackShape.mkCone_œÄ_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.lift_base","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom (objs j) B\ninst‚úù : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\nf : Quiver.Hom X B\nfs : (j : J) ‚Üí Quiver.Hom X (objs j)\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (fs j) (arrows j)) f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.lift f fs w) (CategoryTheory.Limits.WidePullback.base arrows)) f","decl":"@[reassoc]\ntheorem lift_base : lift f fs w ‚â´ base arrows = f := by\n  simp only [limit.lift_œÄ, WidePullbackShape.mkCone_pt, WidePullbackShape.mkCone_œÄ_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.lift_base_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom (objs j) B\ninst‚úù : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\nf : Quiver.Hom X B\nfs : (j : J) ‚Üí Quiver.Hom X (objs j)\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (fs j) (arrows j)) f\nZ : C\nh : Quiver.Hom B Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.lift f fs w) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.base arrows) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc]\ntheorem lift_base : lift f fs w ‚â´ base arrows = f := by\n  simp only [limit.lift_œÄ, WidePullbackShape.mkCone_pt, WidePullbackShape.mkCone_œÄ_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.eq_lift_of_comp_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom (objs j) B\ninst‚úù : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\nf : Quiver.Hom X B\nfs : (j : J) ‚Üí Quiver.Hom X (objs j)\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (fs j) (arrows j)) f\ng : Quiver.Hom X (CategoryTheory.Limits.widePullback B objs arrows)\na‚úù¬π : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.WidePullback.œÄ arrows j)) (fs j)\na‚úù : Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.WidePullback.base arrows)) f\n‚ä¢ Eq g (CategoryTheory.Limits.WidePullback.lift f fs w)","decl":"theorem eq_lift_of_comp_eq (g : X ‚ü∂ widePullback _ _ arrows) :\n    (‚àÄ j : J, g ‚â´ œÄ arrows j = fs j) ‚Üí g ‚â´ base arrows = f ‚Üí g = lift f fs w := by\n  intro h1 h2\n  apply\n    (limit.isLimit (WidePullbackShape.wideCospan B objs arrows)).uniq\n      (WidePullbackShape.mkCone f fs <| w)\n  rintro (_ | _)\n  ¬∑ apply h2\n  ¬∑ apply h1\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.hom_eq_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom (objs j) B\ninst‚úù : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\ng : Quiver.Hom X (CategoryTheory.Limits.widePullback B objs arrows)\n‚ä¢ Eq g (CategoryTheory.Limits.WidePullback.lift (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.WidePullback.base arrows)) (fun j => CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.WidePullback.œÄ arrows j)) ‚ãØ)","decl":"theorem hom_eq_lift (g : X ‚ü∂ widePullback _ _ arrows) :\n    g = lift (g ‚â´ base arrows) (fun j => g ‚â´ œÄ arrows j) (by simp) := by\n  apply eq_lift_of_comp_eq\n  ¬∑ simp\n  ¬∑ rfl  -- Porting note: quite a few missing refl's in aesop_cat now\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom (objs j) B\ninst‚úù : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\ng1 g2 : Quiver.Hom X (CategoryTheory.Limits.widePullback B objs arrows)\na‚úù¬π : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp g1 (CategoryTheory.Limits.WidePullback.œÄ arrows j)) (CategoryTheory.CategoryStruct.comp g2 (CategoryTheory.Limits.WidePullback.œÄ arrows j))\na‚úù : Eq (CategoryTheory.CategoryStruct.comp g1 (CategoryTheory.Limits.WidePullback.base arrows)) (CategoryTheory.CategoryStruct.comp g2 (CategoryTheory.Limits.WidePullback.base arrows))\n‚ä¢ Eq g1 g2","decl":"@[ext 1100]\ntheorem hom_ext (g1 g2 : X ‚ü∂ widePullback _ _ arrows) : (‚àÄ j : J,\n    g1 ‚â´ œÄ arrows j = g2 ‚â´ œÄ arrows j) ‚Üí g1 ‚â´ base arrows = g2 ‚â´ base arrows ‚Üí g1 = g2 := by\n  intro h1 h2\n  apply limit.hom_ext\n  rintro (_ | _)\n  ¬∑ apply h2\n  ¬∑ apply h1\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom (objs j) B\ninst‚úù : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\ng1 g2 : Quiver.Hom X (CategoryTheory.Limits.widePullback B objs arrows)\n‚ä¢ Iff (Eq g1 g2) (And (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp g1 (CategoryTheory.Limits.WidePullback.œÄ arrows j)) (CategoryTheory.CategoryStruct.comp g2 (CategoryTheory.Limits.WidePullback.œÄ arrows j))) (Eq (CategoryTheory.CategoryStruct.comp g1 (CategoryTheory.Limits.WidePullback.base arrows)) (CategoryTheory.CategoryStruct.comp g2 (CategoryTheory.Limits.WidePullback.base arrows))))","decl":"@[ext 1100]\ntheorem hom_ext (g1 g2 : X ‚ü∂ widePullback _ _ arrows) : (‚àÄ j : J,\n    g1 ‚â´ œÄ arrows j = g2 ‚â´ œÄ arrows j) ‚Üí g1 ‚â´ base arrows = g2 ‚â´ base arrows ‚Üí g1 = g2 := by\n  intro h1 h2\n  apply limit.hom_ext\n  rintro (_ | _)\n  ¬∑ apply h2\n  ¬∑ apply h1\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.arrow_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom B (objs j)\ninst‚úù : CategoryTheory.Limits.HasWidePushout B objs arrows\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.widePushout B objs arrows) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (arrows j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Œπ arrows j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) h)","decl":"@[reassoc, simp]\ntheorem arrow_Œπ (j : J) : arrows j ‚â´ Œπ arrows j = head arrows := by\n  apply colimit.w (WidePushoutShape.wideSpan _ _ _) (WidePushoutShape.Hom.init j)\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.arrow_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom B (objs j)\ninst‚úù : CategoryTheory.Limits.HasWidePushout B objs arrows\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (arrows j) (CategoryTheory.Limits.WidePushout.Œπ arrows j)) (CategoryTheory.Limits.WidePushout.head arrows)","decl":"@[reassoc, simp]\ntheorem arrow_Œπ (j : J) : arrows j ‚â´ Œπ arrows j = head arrows := by\n  apply colimit.w (WidePushoutShape.wideSpan _ _ _) (WidePushoutShape.Hom.init j)\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.Œπ_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom B (objs j)\ninst‚úù : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\nf : Quiver.Hom B X\nfs : (j : J) ‚Üí Quiver.Hom (objs j) X\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (arrows j) (fs j)) f\nj : J\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Œπ arrows j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.desc f fs w) h)) (CategoryTheory.CategoryStruct.comp (fs j) h)","decl":"@[reassoc]\ntheorem Œπ_desc (j : J) : Œπ arrows j ‚â´ desc f fs w = fs _ := by\n  simp only [colimit.Œπ_desc, WidePushoutShape.mkCocone_pt, WidePushoutShape.mkCocone_Œπ_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.Œπ_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom B (objs j)\ninst‚úù : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\nf : Quiver.Hom B X\nfs : (j : J) ‚Üí Quiver.Hom (objs j) X\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (arrows j) (fs j)) f\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Œπ arrows j) (CategoryTheory.Limits.WidePushout.desc f fs w)) (fs j)","decl":"@[reassoc]\ntheorem Œπ_desc (j : J) : Œπ arrows j ‚â´ desc f fs w = fs _ := by\n  simp only [colimit.Œπ_desc, WidePushoutShape.mkCocone_pt, WidePushoutShape.mkCocone_Œπ_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.head_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom B (objs j)\ninst‚úù : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\nf : Quiver.Hom B X\nfs : (j : J) ‚Üí Quiver.Hom (objs j) X\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (arrows j) (fs j)) f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) (CategoryTheory.Limits.WidePushout.desc f fs w)) f","decl":"@[reassoc]\ntheorem head_desc : head arrows ‚â´ desc f fs w = f := by\n  simp only [colimit.Œπ_desc, WidePushoutShape.mkCocone_pt, WidePushoutShape.mkCocone_Œπ_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.head_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom B (objs j)\ninst‚úù : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\nf : Quiver.Hom B X\nfs : (j : J) ‚Üí Quiver.Hom (objs j) X\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (arrows j) (fs j)) f\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.desc f fs w) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc]\ntheorem head_desc : head arrows ‚â´ desc f fs w = f := by\n  simp only [colimit.Œπ_desc, WidePushoutShape.mkCocone_pt, WidePushoutShape.mkCocone_Œπ_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.eq_desc_of_comp_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom B (objs j)\ninst‚úù : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\nf : Quiver.Hom B X\nfs : (j : J) ‚Üí Quiver.Hom (objs j) X\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (arrows j) (fs j)) f\ng : Quiver.Hom (CategoryTheory.Limits.widePushout B objs arrows) X\na‚úù¬π : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Œπ arrows j) g) (fs j)\na‚úù : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) g) f\n‚ä¢ Eq g (CategoryTheory.Limits.WidePushout.desc f fs w)","decl":"theorem eq_desc_of_comp_eq (g : widePushout _ _ arrows ‚ü∂ X) :\n    (‚àÄ j : J, Œπ arrows j ‚â´ g = fs j) ‚Üí head arrows ‚â´ g = f ‚Üí g = desc f fs w := by\n  intro h1 h2\n  apply\n    (colimit.isColimit (WidePushoutShape.wideSpan B objs arrows)).uniq\n      (WidePushoutShape.mkCocone f fs <| w)\n  rintro (_ | _)\n  ¬∑ apply h2\n  ¬∑ apply h1\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.hom_eq_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom B (objs j)\ninst‚úù : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\ng : Quiver.Hom (CategoryTheory.Limits.widePushout B objs arrows) X\n‚ä¢ Eq g (CategoryTheory.Limits.WidePushout.desc (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) g) (fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Œπ arrows j) g) ‚ãØ)","decl":"theorem hom_eq_desc (g : widePushout _ _ arrows ‚ü∂ X) :\n    g =\n      desc (head arrows ‚â´ g) (fun j => Œπ arrows j ‚â´ g) fun j => by\n        rw [‚Üê Category.assoc]\n        simp := by\n  apply eq_desc_of_comp_eq\n  ¬∑ simp\n  ¬∑ rfl -- Porting note: another missing rfl\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom B (objs j)\ninst‚úù : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\ng1 g2 : Quiver.Hom (CategoryTheory.Limits.widePushout B objs arrows) X\n‚ä¢ Iff (Eq g1 g2) (And (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Œπ arrows j) g1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Œπ arrows j) g2)) (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) g1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) g2)))","decl":"@[ext 1100]\ntheorem hom_ext (g1 g2 : widePushout _ _ arrows ‚ü∂ X) : (‚àÄ j : J,\n    Œπ arrows j ‚â´ g1 = Œπ arrows j ‚â´ g2) ‚Üí head arrows ‚â´ g1 = head arrows ‚â´ g2 ‚Üí g1 = g2 := by\n  intro h1 h2\n  apply colimit.hom_ext\n  rintro (_ | _)\n  ¬∑ apply h2\n  ¬∑ apply h1\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J ‚Üí C\narrows : (j : J) ‚Üí Quiver.Hom B (objs j)\ninst‚úù : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\ng1 g2 : Quiver.Hom (CategoryTheory.Limits.widePushout B objs arrows) X\na‚úù¬π : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Œπ arrows j) g1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Œπ arrows j) g2)\na‚úù : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) g1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) g2)\n‚ä¢ Eq g1 g2","decl":"@[ext 1100]\ntheorem hom_ext (g1 g2 : widePushout _ _ arrows ‚ü∂ X) : (‚àÄ j : J,\n    Œπ arrows j ‚â´ g1 = Œπ arrows j ‚â´ g2) ‚Üí head arrows ‚â´ g1 = head arrows ‚â´ g2 ‚Üí g1 = g2 := by\n  intro h1 h2\n  apply colimit.hom_ext\n  rintro (_ | _)\n  ¬∑ apply h2\n  ¬∑ apply h1\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeOp_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX : CategoryTheory.Limits.WidePullbackShape J\n‚ä¢ Eq ((CategoryTheory.Limits.widePullbackShapeOp J).obj X) { unop := X }","decl":"/-- The obvious functor `WidePullbackShape J ‚•§ (WidePushoutShape J)·µí·µñ` -/\n@[simps]\ndef widePullbackShapeOp : WidePullbackShape J ‚•§ (WidePushoutShape J)·µí·µñ where\n  obj X := op X\n  map {X‚ÇÅ} {X‚ÇÇ} := widePullbackShapeOpMap J X‚ÇÅ X‚ÇÇ\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeOp_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX‚ÇÅ X‚ÇÇ : CategoryTheory.Limits.WidePullbackShape J\na‚úù : Quiver.Hom X‚ÇÅ X‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.Limits.widePullbackShapeOp J).map a‚úù) (CategoryTheory.Limits.widePullbackShapeOpMap J X‚ÇÅ X‚ÇÇ a‚úù)","decl":"/-- The obvious functor `WidePullbackShape J ‚•§ (WidePushoutShape J)·µí·µñ` -/\n@[simps]\ndef widePullbackShapeOp : WidePullbackShape J ‚•§ (WidePushoutShape J)·µí·µñ where\n  obj X := op X\n  map {X‚ÇÅ} {X‚ÇÇ} := widePullbackShapeOpMap J X‚ÇÅ X‚ÇÇ\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeOp_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX Y : CategoryTheory.Limits.WidePushoutShape J\na‚úù : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Limits.widePushoutShapeOp J).map a‚úù) (CategoryTheory.Limits.widePushoutShapeOpMap J X Y a‚úù)","decl":"/-- The obvious functor `WidePushoutShape J ‚•§ (WidePullbackShape J)·µí·µñ` -/\n@[simps]\ndef widePushoutShapeOp : WidePushoutShape J ‚•§ (WidePullbackShape J)·µí·µñ where\n  obj X := op X\n  map := fun {X} {Y} => widePushoutShapeOpMap J X Y\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeOp_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX : CategoryTheory.Limits.WidePushoutShape J\n‚ä¢ Eq ((CategoryTheory.Limits.widePushoutShapeOp J).obj X) { unop := X }","decl":"/-- The obvious functor `WidePushoutShape J ‚•§ (WidePullbackShape J)·µí·µñ` -/\n@[simps]\ndef widePushoutShapeOp : WidePushoutShape J ‚•§ (WidePullbackShape J)·µí·µñ where\n  obj X := op X\n  map := fun {X} {Y} => widePushoutShapeOpMap J X Y\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeUnop_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX‚úù Y‚úù : Opposite (CategoryTheory.Limits.WidePullbackShape J)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.widePullbackShapeUnop J).map f) (CategoryTheory.Limits.widePullbackShapeOpMap J (Opposite.unop Y‚úù) (Opposite.unop X‚úù) f.unop).unop","decl":"/-- The obvious functor `(WidePullbackShape J)·µí·µñ ‚•§ WidePushoutShape J`-/\n@[simps!]\ndef widePullbackShapeUnop : (WidePullbackShape J)·µí·µñ ‚•§ WidePushoutShape J :=\n  (widePullbackShapeOp J).leftOp\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeUnop_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX : Opposite (CategoryTheory.Limits.WidePullbackShape J)\n‚ä¢ Eq ((CategoryTheory.Limits.widePullbackShapeUnop J).obj X) (Opposite.unop X)","decl":"/-- The obvious functor `(WidePullbackShape J)·µí·µñ ‚•§ WidePushoutShape J`-/\n@[simps!]\ndef widePullbackShapeUnop : (WidePullbackShape J)·µí·µñ ‚•§ WidePushoutShape J :=\n  (widePullbackShapeOp J).leftOp\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeUnop_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX : Opposite (CategoryTheory.Limits.WidePushoutShape J)\n‚ä¢ Eq ((CategoryTheory.Limits.widePushoutShapeUnop J).obj X) (Opposite.unop X)","decl":"/-- The obvious functor `(WidePushoutShape J)·µí·µñ ‚•§ WidePullbackShape J` -/\n@[simps!]\ndef widePushoutShapeUnop : (WidePushoutShape J)·µí·µñ ‚•§ WidePullbackShape J :=\n  (widePushoutShapeOp J).leftOp\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeUnop_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX‚úù Y‚úù : Opposite (CategoryTheory.Limits.WidePushoutShape J)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Limits.widePushoutShapeUnop J).map f) (CategoryTheory.Limits.widePushoutShapeOpMap J (Opposite.unop Y‚úù) (Opposite.unop X‚úù) f.unop).unop","decl":"/-- The obvious functor `(WidePushoutShape J)·µí·µñ ‚•§ WidePullbackShape J` -/\n@[simps!]\ndef widePushoutShapeUnop : (WidePushoutShape J)·µí·µñ ‚•§ WidePullbackShape J :=\n  (widePushoutShapeOp J).leftOp\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeOpEquiv_unitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\n‚ä¢ Eq (CategoryTheory.Limits.widePushoutShapeOpEquiv J).unitIso (CategoryTheory.Limits.widePushoutShapeOpUnop J).symm","decl":"/-- The duality equivalence `(WidePushoutShape J)·µí·µñ ‚âå WidePullbackShape J` -/\n@[simps]\ndef widePushoutShapeOpEquiv : (WidePushoutShape J)·µí·µñ ‚âå WidePullbackShape J where\n  functor := widePushoutShapeUnop J\n  inverse := widePullbackShapeOp J\n  unitIso := (widePushoutShapeOpUnop J).symm\n  counitIso := widePullbackShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeOpEquiv_functor","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\n‚ä¢ Eq (CategoryTheory.Limits.widePushoutShapeOpEquiv J).functor (CategoryTheory.Limits.widePushoutShapeUnop J)","decl":"/-- The duality equivalence `(WidePushoutShape J)·µí·µñ ‚âå WidePullbackShape J` -/\n@[simps]\ndef widePushoutShapeOpEquiv : (WidePushoutShape J)·µí·µñ ‚âå WidePullbackShape J where\n  functor := widePushoutShapeUnop J\n  inverse := widePullbackShapeOp J\n  unitIso := (widePushoutShapeOpUnop J).symm\n  counitIso := widePullbackShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeOpEquiv_counitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\n‚ä¢ Eq (CategoryTheory.Limits.widePushoutShapeOpEquiv J).counitIso (CategoryTheory.Limits.widePullbackShapeUnopOp J)","decl":"/-- The duality equivalence `(WidePushoutShape J)·µí·µñ ‚âå WidePullbackShape J` -/\n@[simps]\ndef widePushoutShapeOpEquiv : (WidePushoutShape J)·µí·µñ ‚âå WidePullbackShape J where\n  functor := widePushoutShapeUnop J\n  inverse := widePullbackShapeOp J\n  unitIso := (widePushoutShapeOpUnop J).symm\n  counitIso := widePullbackShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeOpEquiv_inverse","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\n‚ä¢ Eq (CategoryTheory.Limits.widePushoutShapeOpEquiv J).inverse (CategoryTheory.Limits.widePullbackShapeOp J)","decl":"/-- The duality equivalence `(WidePushoutShape J)·µí·µñ ‚âå WidePullbackShape J` -/\n@[simps]\ndef widePushoutShapeOpEquiv : (WidePushoutShape J)·µí·µñ ‚âå WidePullbackShape J where\n  functor := widePushoutShapeUnop J\n  inverse := widePullbackShapeOp J\n  unitIso := (widePushoutShapeOpUnop J).symm\n  counitIso := widePullbackShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeOpEquiv_functor","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\n‚ä¢ Eq (CategoryTheory.Limits.widePullbackShapeOpEquiv J).functor (CategoryTheory.Limits.widePullbackShapeUnop J)","decl":"/-- The duality equivalence `(WidePullbackShape J)·µí·µñ ‚âå WidePushoutShape J` -/\n@[simps]\ndef widePullbackShapeOpEquiv : (WidePullbackShape J)·µí·µñ ‚âå WidePushoutShape J where\n  functor := widePullbackShapeUnop J\n  inverse := widePushoutShapeOp J\n  unitIso := (widePullbackShapeOpUnop J).symm\n  counitIso := widePushoutShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeOpEquiv_unitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\n‚ä¢ Eq (CategoryTheory.Limits.widePullbackShapeOpEquiv J).unitIso (CategoryTheory.Limits.widePullbackShapeOpUnop J).symm","decl":"/-- The duality equivalence `(WidePullbackShape J)·µí·µñ ‚âå WidePushoutShape J` -/\n@[simps]\ndef widePullbackShapeOpEquiv : (WidePullbackShape J)·µí·µñ ‚âå WidePushoutShape J where\n  functor := widePullbackShapeUnop J\n  inverse := widePushoutShapeOp J\n  unitIso := (widePullbackShapeOpUnop J).symm\n  counitIso := widePushoutShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeOpEquiv_counitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\n‚ä¢ Eq (CategoryTheory.Limits.widePullbackShapeOpEquiv J).counitIso (CategoryTheory.Limits.widePushoutShapeUnopOp J)","decl":"/-- The duality equivalence `(WidePullbackShape J)·µí·µñ ‚âå WidePushoutShape J` -/\n@[simps]\ndef widePullbackShapeOpEquiv : (WidePullbackShape J)·µí·µñ ‚âå WidePushoutShape J where\n  functor := widePullbackShapeUnop J\n  inverse := widePushoutShapeOp J\n  unitIso := (widePullbackShapeOpUnop J).symm\n  counitIso := widePushoutShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeOpEquiv_inverse","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\n‚ä¢ Eq (CategoryTheory.Limits.widePullbackShapeOpEquiv J).inverse (CategoryTheory.Limits.widePushoutShapeOp J)","decl":"/-- The duality equivalence `(WidePullbackShape J)·µí·µñ ‚âå WidePushoutShape J` -/\n@[simps]\ndef widePullbackShapeOpEquiv : (WidePullbackShape J)·µí·µñ ‚âå WidePushoutShape J where\n  functor := widePullbackShapeUnop J\n  inverse := widePushoutShapeOp J\n  unitIso := (widePullbackShapeOpUnop J).symm\n  counitIso := widePushoutShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.hasWidePushouts_shrink","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasWidePushouts C\n‚ä¢ CategoryTheory.Limits.HasWidePushouts C","decl":"/-- If a category has wide pushouts on a higher universe level it also has wide pushouts\non a lower universe level. -/\ntheorem hasWidePushouts_shrink [HasWidePushouts.{max w w'} C] : HasWidePushouts.{w} C := fun _ =>\n  hasColimitsOfShape_of_equivalence (WidePushoutShape.equivalenceOfEquiv _ Equiv.ulift.{w'})\n\n"}
{"name":"CategoryTheory.Limits.hasWidePullbacks_shrink","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasWidePullbacks C\n‚ä¢ CategoryTheory.Limits.HasWidePullbacks C","decl":"/-- If a category has wide pullbacks on a higher universe level it also has wide pullbacks\non a lower universe level. -/\ntheorem hasWidePullbacks_shrink [HasWidePullbacks.{max w w'} C] : HasWidePullbacks.{w} C := fun _ =>\n  hasLimitsOfShape_of_equivalence (WidePullbackShape.equivalenceOfEquiv _ Equiv.ulift.{w'})\n\n"}
