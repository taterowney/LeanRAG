{"name":"CategoryTheory.Limits.WidePullbackShape.subsingleton_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nâŠ¢ Quiver.IsThin (CategoryTheory.Limits.WidePullbackShape J)","decl":"instance subsingleton_hom : Quiver.IsThin (WidePullbackShape J) := fun _ _ => by\n  constructor\n  intro a b\n  casesm* WidePullbackShape _, (_ : WidePullbackShape _) âŸ¶ (_ : WidePullbackShape _)\n  Â· rfl\n  Â· rfl\n  Â· rfl\n\n"}
{"name":"CategoryTheory.Limits.WidePullbackShape.hom_id","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX : CategoryTheory.Limits.WidePullbackShape J\nâŠ¢ Eq (CategoryTheory.Limits.WidePullbackShape.Hom.id X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem hom_id (X : WidePullbackShape J) : Hom.id X = ğŸ™ X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WidePullbackShape.wideCospan_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom (objs j) B\nj : CategoryTheory.Limits.WidePullbackShape J\nâŠ¢ Eq ((CategoryTheory.Limits.WidePullbackShape.wideCospan B objs arrows).obj j) (Option.casesOn j B objs)","decl":"/-- Construct a functor out of the wide pullback shape given a J-indexed collection of arrows to a\nfixed object.\n-/\n@[simps]\ndef wideCospan (B : C) (objs : J â†’ C) (arrows : âˆ€ j : J, objs j âŸ¶ B) : WidePullbackShape J â¥¤ C where\n  obj j := Option.casesOn j B objs\n  map f := by\n    cases' f with _ j\n    Â· apply ğŸ™ _\n    Â· exact arrows j\n\n"}
{"name":"CategoryTheory.Limits.WidePullbackShape.wideCospan_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom (objs j) B\nXâœ Yâœ : CategoryTheory.Limits.WidePullbackShape J\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Limits.WidePullbackShape.wideCospan B objs arrows).map f) (CategoryTheory.Limits.WidePullbackShape.Hom.casesOn (motive := fun a a_1 t => Eq Xâœ a â†’ Eq Yâœ a_1 â†’ HEq f t â†’ Quiver.Hom ((fun j => Option.casesOn j B objs) Xâœ) ((fun j => Option.casesOn j B objs) Yâœ)) f (fun X h => Eq.ndrec (motive := fun X => Eq Yâœ X â†’ HEq f (CategoryTheory.Limits.WidePullbackShape.Hom.id X) â†’ Quiver.Hom ((fun j => Option.casesOn j B objs) Xâœ) ((fun j => Option.casesOn j B objs) Yâœ)) (fun h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom Xâœ Y) â†’ HEq f (CategoryTheory.Limits.WidePullbackShape.Hom.id Xâœ) â†’ Quiver.Hom ((fun j => Option.casesOn j B objs) Xâœ) ((fun j => Option.casesOn j B objs) Y)) (fun f h => CategoryTheory.CategoryStruct.id ((fun j => Option.casesOn j B objs) Xâœ)) â‹¯ f) h) (fun j h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Yâœ) â†’ Eq Yâœ Option.none â†’ HEq f (CategoryTheory.Limits.WidePullbackShape.Hom.term j) â†’ Quiver.Hom ((fun j => Option.casesOn j B objs) X) ((fun j => Option.casesOn j B objs) Yâœ)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom (Option.some j) Y) â†’ HEq f (CategoryTheory.Limits.WidePullbackShape.Hom.term j) â†’ Quiver.Hom ((fun j => Option.casesOn j B objs) (Option.some j)) ((fun j => Option.casesOn j B objs) Y)) (fun f h => arrows j) â‹¯ f) â‹¯ f) â‹¯ â‹¯ â‹¯)","decl":"/-- Construct a functor out of the wide pullback shape given a J-indexed collection of arrows to a\nfixed object.\n-/\n@[simps]\ndef wideCospan (B : C) (objs : J â†’ C) (arrows : âˆ€ j : J, objs j âŸ¶ B) : WidePullbackShape J â¥¤ C where\n  obj j := Option.casesOn j B objs\n  map f := by\n    cases' f with _ j\n    Â· apply ğŸ™ _\n    Â· exact arrows j\n\n"}
{"name":"CategoryTheory.Limits.WidePullbackShape.mkCone_Ï€_app","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WidePullbackShape J) C\nX : C\nf : Quiver.Hom X (F.obj Option.none)\nÏ€ : (j : J) â†’ Quiver.Hom X (F.obj (Option.some j))\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (Ï€ j) (F.map (CategoryTheory.Limits.WidePullbackShape.Hom.term j))) f\nj : CategoryTheory.Limits.WidePullbackShape J\nâŠ¢ Eq ((CategoryTheory.Limits.WidePullbackShape.mkCone f Ï€ w).Ï€.app j) (CategoryTheory.Limits.WidePullbackShape.mkCone.match_1 (fun j => Quiver.Hom (((CategoryTheory.Functor.const (CategoryTheory.Limits.WidePullbackShape J)).obj X).obj j) (F.obj j)) j (fun _ => f) fun j => Ï€ j)","decl":"/-- Construct a cone over a wide cospan. -/\n@[simps]\ndef mkCone {F : WidePullbackShape J â¥¤ C} {X : C} (f : X âŸ¶ F.obj none) (Ï€ : âˆ€ j, X âŸ¶ F.obj (some j))\n    (w : âˆ€ j, Ï€ j â‰« F.map (Hom.term j) = f) : Cone F :=\n  { pt := X\n    Ï€ :=\n      { app := fun j =>\n          match j with\n          | none => f\n          | some j => Ï€ j\n        naturality := fun j j' f => by\n          cases j <;> cases j' <;> cases f <;> dsimp <;> simp [w] } }\n\n"}
{"name":"CategoryTheory.Limits.WidePullbackShape.mkCone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WidePullbackShape J) C\nX : C\nf : Quiver.Hom X (F.obj Option.none)\nÏ€ : (j : J) â†’ Quiver.Hom X (F.obj (Option.some j))\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (Ï€ j) (F.map (CategoryTheory.Limits.WidePullbackShape.Hom.term j))) f\nâŠ¢ Eq (CategoryTheory.Limits.WidePullbackShape.mkCone f Ï€ w).pt X","decl":"/-- Construct a cone over a wide cospan. -/\n@[simps]\ndef mkCone {F : WidePullbackShape J â¥¤ C} {X : C} (f : X âŸ¶ F.obj none) (Ï€ : âˆ€ j, X âŸ¶ F.obj (some j))\n    (w : âˆ€ j, Ï€ j â‰« F.map (Hom.term j) = f) : Cone F :=\n  { pt := X\n    Ï€ :=\n      { app := fun j =>\n          match j with\n          | none => f\n          | some j => Ï€ j\n        naturality := fun j j' f => by\n          cases j <;> cases j' <;> cases f <;> dsimp <;> simp [w] } }\n\n"}
{"name":"CategoryTheory.Limits.WidePushoutShape.subsingleton_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nâŠ¢ Quiver.IsThin (CategoryTheory.Limits.WidePushoutShape J)","decl":"instance subsingleton_hom : Quiver.IsThin (WidePushoutShape J) := fun _ _ => by\n  constructor\n  intro a b\n  casesm* WidePushoutShape _, (_ : WidePushoutShape _) âŸ¶ (_ : WidePushoutShape _)\n  repeat rfl\n\n"}
{"name":"CategoryTheory.Limits.WidePushoutShape.hom_id","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX : CategoryTheory.Limits.WidePushoutShape J\nâŠ¢ Eq (CategoryTheory.Limits.WidePushoutShape.Hom.id X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\ntheorem hom_id (X : WidePushoutShape J) : Hom.id X = ğŸ™ X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.WidePushoutShape.wideSpan_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom B (objs j)\nXâœ Yâœ : CategoryTheory.Limits.WidePushoutShape J\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Limits.WidePushoutShape.wideSpan B objs arrows).map f) (CategoryTheory.Limits.WidePushoutShape.Hom.casesOn (motive := fun a a_1 t => Eq Xâœ a â†’ Eq Yâœ a_1 â†’ HEq f t â†’ Quiver.Hom ((fun j => Option.casesOn j B objs) Xâœ) ((fun j => Option.casesOn j B objs) Yâœ)) f (fun X h => Eq.ndrec (motive := fun X => Eq Yâœ X â†’ HEq f (CategoryTheory.Limits.WidePushoutShape.Hom.id X) â†’ Quiver.Hom ((fun j => Option.casesOn j B objs) Xâœ) ((fun j => Option.casesOn j B objs) Yâœ)) (fun h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom Xâœ Y) â†’ HEq f (CategoryTheory.Limits.WidePushoutShape.Hom.id Xâœ) â†’ Quiver.Hom ((fun j => Option.casesOn j B objs) Xâœ) ((fun j => Option.casesOn j B objs) Y)) (fun f h => CategoryTheory.CategoryStruct.id ((fun j => Option.casesOn j B objs) Xâœ)) â‹¯ f) h) (fun j h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Yâœ) â†’ Eq Yâœ (Option.some j) â†’ HEq f (CategoryTheory.Limits.WidePushoutShape.Hom.init j) â†’ Quiver.Hom ((fun j => Option.casesOn j B objs) X) ((fun j => Option.casesOn j B objs) Yâœ)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom Option.none Y) â†’ HEq f (CategoryTheory.Limits.WidePushoutShape.Hom.init j) â†’ Quiver.Hom ((fun j => Option.casesOn j B objs) Option.none) ((fun j => Option.casesOn j B objs) Y)) (fun f h => arrows j) â‹¯ f) â‹¯ f) â‹¯ â‹¯ â‹¯)","decl":"/-- Construct a functor out of the wide pushout shape given a J-indexed collection of arrows from a\nfixed object.\n-/\n@[simps]\ndef wideSpan (B : C) (objs : J â†’ C) (arrows : âˆ€ j : J, B âŸ¶ objs j) : WidePushoutShape J â¥¤ C where\n  obj j := Option.casesOn j B objs\n  map f := by\n    cases' f with _ j\n    Â· apply ğŸ™ _\n    Â· exact arrows j\n  map_comp := fun f g => by\n    cases f\n    Â· simp only [Eq.ndrec, hom_id, eq_rec_constant, Category.id_comp]; congr\n    Â· cases g\n      simp only [Eq.ndrec, hom_id, eq_rec_constant, Category.comp_id]; congr\n\n"}
{"name":"CategoryTheory.Limits.WidePushoutShape.wideSpan_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom B (objs j)\nj : CategoryTheory.Limits.WidePushoutShape J\nâŠ¢ Eq ((CategoryTheory.Limits.WidePushoutShape.wideSpan B objs arrows).obj j) (Option.casesOn j B objs)","decl":"/-- Construct a functor out of the wide pushout shape given a J-indexed collection of arrows from a\nfixed object.\n-/\n@[simps]\ndef wideSpan (B : C) (objs : J â†’ C) (arrows : âˆ€ j : J, B âŸ¶ objs j) : WidePushoutShape J â¥¤ C where\n  obj j := Option.casesOn j B objs\n  map f := by\n    cases' f with _ j\n    Â· apply ğŸ™ _\n    Â· exact arrows j\n  map_comp := fun f g => by\n    cases f\n    Â· simp only [Eq.ndrec, hom_id, eq_rec_constant, Category.id_comp]; congr\n    Â· cases g\n      simp only [Eq.ndrec, hom_id, eq_rec_constant, Category.comp_id]; congr\n\n"}
{"name":"CategoryTheory.Limits.WidePushoutShape.mkCocone_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WidePushoutShape J) C\nX : C\nf : Quiver.Hom (F.obj Option.none) X\nÎ¹ : (j : J) â†’ Quiver.Hom (F.obj (Option.some j)) X\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.WidePushoutShape.Hom.init j)) (Î¹ j)) f\nâŠ¢ Eq (CategoryTheory.Limits.WidePushoutShape.mkCocone f Î¹ w).pt X","decl":"/-- Construct a cocone over a wide span. -/\n@[simps]\ndef mkCocone {F : WidePushoutShape J â¥¤ C} {X : C} (f : F.obj none âŸ¶ X) (Î¹ : âˆ€ j, F.obj (some j) âŸ¶ X)\n    (w : âˆ€ j, F.map (Hom.init j) â‰« Î¹ j = f) : Cocone F :=\n  { pt := X\n    Î¹ :=\n      { app := fun j =>\n          match j with\n          | none => f\n          | some j => Î¹ j\n        naturality := fun j j' f => by\n          cases j <;> cases j' <;> cases f <;> dsimp <;> simp [w] } }\n\n"}
{"name":"CategoryTheory.Limits.WidePushoutShape.mkCocone_Î¹_app","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (CategoryTheory.Limits.WidePushoutShape J) C\nX : C\nf : Quiver.Hom (F.obj Option.none) X\nÎ¹ : (j : J) â†’ Quiver.Hom (F.obj (Option.some j)) X\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.WidePushoutShape.Hom.init j)) (Î¹ j)) f\nj : CategoryTheory.Limits.WidePushoutShape J\nâŠ¢ Eq ((CategoryTheory.Limits.WidePushoutShape.mkCocone f Î¹ w).Î¹.app j) (CategoryTheory.Limits.WidePushoutShape.mkCocone.match_1 (fun j => Quiver.Hom (F.obj j) (((CategoryTheory.Functor.const (CategoryTheory.Limits.WidePushoutShape J)).obj X).obj j)) j (fun _ => f) fun j => Î¹ j)","decl":"/-- Construct a cocone over a wide span. -/\n@[simps]\ndef mkCocone {F : WidePushoutShape J â¥¤ C} {X : C} (f : F.obj none âŸ¶ X) (Î¹ : âˆ€ j, F.obj (some j) âŸ¶ X)\n    (w : âˆ€ j, F.map (Hom.init j) â‰« Î¹ j = f) : Cocone F :=\n  { pt := X\n    Î¹ :=\n      { app := fun j =>\n          match j with\n          | none => f\n          | some j => Î¹ j\n        naturality := fun j j' f => by\n          cases j <;> cases j' <;> cases f <;> dsimp <;> simp [w] } }\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.Ï€_arrow","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom (objs j) B\ninstâœ : CategoryTheory.Limits.HasWidePullback B objs arrows\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.Ï€ arrows j) (arrows j)) (CategoryTheory.Limits.WidePullback.base arrows)","decl":"@[reassoc (attr := simp)]\ntheorem Ï€_arrow (j : J) : Ï€ arrows j â‰« arrows _ = base arrows := by\n  apply limit.w (WidePullbackShape.wideCospan _ _ _) (WidePullbackShape.Hom.term j)\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.Ï€_arrow_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom (objs j) B\ninstâœ : CategoryTheory.Limits.HasWidePullback B objs arrows\nj : J\nZ : C\nh : Quiver.Hom B Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.Ï€ arrows j) (CategoryTheory.CategoryStruct.comp (arrows j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.base arrows) h)","decl":"@[reassoc (attr := simp)]\ntheorem Ï€_arrow (j : J) : Ï€ arrows j â‰« arrows _ = base arrows := by\n  apply limit.w (WidePullbackShape.wideCospan _ _ _) (WidePullbackShape.Hom.term j)\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.lift_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom (objs j) B\ninstâœ : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\nf : Quiver.Hom X B\nfs : (j : J) â†’ Quiver.Hom X (objs j)\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (fs j) (arrows j)) f\nj : J\nZ : C\nh : Quiver.Hom (objs j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.lift f fs w) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.Ï€ arrows j) h)) (CategoryTheory.CategoryStruct.comp (fs j) h)","decl":"@[reassoc]\ntheorem lift_Ï€ (j : J) : lift f fs w â‰« Ï€ arrows j = fs _ := by\n  simp only [limit.lift_Ï€, WidePullbackShape.mkCone_pt, WidePullbackShape.mkCone_Ï€_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.lift_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom (objs j) B\ninstâœ : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\nf : Quiver.Hom X B\nfs : (j : J) â†’ Quiver.Hom X (objs j)\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (fs j) (arrows j)) f\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.lift f fs w) (CategoryTheory.Limits.WidePullback.Ï€ arrows j)) (fs j)","decl":"@[reassoc]\ntheorem lift_Ï€ (j : J) : lift f fs w â‰« Ï€ arrows j = fs _ := by\n  simp only [limit.lift_Ï€, WidePullbackShape.mkCone_pt, WidePullbackShape.mkCone_Ï€_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.lift_base","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom (objs j) B\ninstâœ : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\nf : Quiver.Hom X B\nfs : (j : J) â†’ Quiver.Hom X (objs j)\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (fs j) (arrows j)) f\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.lift f fs w) (CategoryTheory.Limits.WidePullback.base arrows)) f","decl":"@[reassoc]\ntheorem lift_base : lift f fs w â‰« base arrows = f := by\n  simp only [limit.lift_Ï€, WidePullbackShape.mkCone_pt, WidePullbackShape.mkCone_Ï€_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.lift_base_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom (objs j) B\ninstâœ : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\nf : Quiver.Hom X B\nfs : (j : J) â†’ Quiver.Hom X (objs j)\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (fs j) (arrows j)) f\nZ : C\nh : Quiver.Hom B Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.lift f fs w) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.base arrows) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc]\ntheorem lift_base : lift f fs w â‰« base arrows = f := by\n  simp only [limit.lift_Ï€, WidePullbackShape.mkCone_pt, WidePullbackShape.mkCone_Ï€_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.eq_lift_of_comp_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom (objs j) B\ninstâœ : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\nf : Quiver.Hom X B\nfs : (j : J) â†’ Quiver.Hom X (objs j)\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (fs j) (arrows j)) f\ng : Quiver.Hom X (CategoryTheory.Limits.widePullback B objs arrows)\naâœÂ¹ : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.WidePullback.Ï€ arrows j)) (fs j)\naâœ : Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.WidePullback.base arrows)) f\nâŠ¢ Eq g (CategoryTheory.Limits.WidePullback.lift f fs w)","decl":"theorem eq_lift_of_comp_eq (g : X âŸ¶ widePullback _ _ arrows) :\n    (âˆ€ j : J, g â‰« Ï€ arrows j = fs j) â†’ g â‰« base arrows = f â†’ g = lift f fs w := by\n  intro h1 h2\n  apply\n    (limit.isLimit (WidePullbackShape.wideCospan B objs arrows)).uniq\n      (WidePullbackShape.mkCone f fs <| w)\n  rintro (_ | _)\n  Â· apply h2\n  Â· apply h1\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.hom_eq_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom (objs j) B\ninstâœ : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\ng : Quiver.Hom X (CategoryTheory.Limits.widePullback B objs arrows)\nâŠ¢ Eq g (CategoryTheory.Limits.WidePullback.lift (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.WidePullback.base arrows)) (fun j => CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.WidePullback.Ï€ arrows j)) â‹¯)","decl":"theorem hom_eq_lift (g : X âŸ¶ widePullback _ _ arrows) :\n    g = lift (g â‰« base arrows) (fun j => g â‰« Ï€ arrows j) (by simp) := by\n  apply eq_lift_of_comp_eq\n  Â· simp\n  Â· rfl  -- Porting note: quite a few missing refl's in aesop_cat now\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom (objs j) B\ninstâœ : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\ng1 g2 : Quiver.Hom X (CategoryTheory.Limits.widePullback B objs arrows)\naâœÂ¹ : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp g1 (CategoryTheory.Limits.WidePullback.Ï€ arrows j)) (CategoryTheory.CategoryStruct.comp g2 (CategoryTheory.Limits.WidePullback.Ï€ arrows j))\naâœ : Eq (CategoryTheory.CategoryStruct.comp g1 (CategoryTheory.Limits.WidePullback.base arrows)) (CategoryTheory.CategoryStruct.comp g2 (CategoryTheory.Limits.WidePullback.base arrows))\nâŠ¢ Eq g1 g2","decl":"@[ext 1100]\ntheorem hom_ext (g1 g2 : X âŸ¶ widePullback _ _ arrows) : (âˆ€ j : J,\n    g1 â‰« Ï€ arrows j = g2 â‰« Ï€ arrows j) â†’ g1 â‰« base arrows = g2 â‰« base arrows â†’ g1 = g2 := by\n  intro h1 h2\n  apply limit.hom_ext\n  rintro (_ | _)\n  Â· apply h2\n  Â· apply h1\n\n"}
{"name":"CategoryTheory.Limits.WidePullback.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom (objs j) B\ninstâœ : CategoryTheory.Limits.HasWidePullback B objs arrows\nX : C\ng1 g2 : Quiver.Hom X (CategoryTheory.Limits.widePullback B objs arrows)\nâŠ¢ Iff (Eq g1 g2) (And (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp g1 (CategoryTheory.Limits.WidePullback.Ï€ arrows j)) (CategoryTheory.CategoryStruct.comp g2 (CategoryTheory.Limits.WidePullback.Ï€ arrows j))) (Eq (CategoryTheory.CategoryStruct.comp g1 (CategoryTheory.Limits.WidePullback.base arrows)) (CategoryTheory.CategoryStruct.comp g2 (CategoryTheory.Limits.WidePullback.base arrows))))","decl":"@[ext 1100]\ntheorem hom_ext (g1 g2 : X âŸ¶ widePullback _ _ arrows) : (âˆ€ j : J,\n    g1 â‰« Ï€ arrows j = g2 â‰« Ï€ arrows j) â†’ g1 â‰« base arrows = g2 â‰« base arrows â†’ g1 = g2 := by\n  intro h1 h2\n  apply limit.hom_ext\n  rintro (_ | _)\n  Â· apply h2\n  Â· apply h1\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.arrow_Î¹_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom B (objs j)\ninstâœ : CategoryTheory.Limits.HasWidePushout B objs arrows\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.widePushout B objs arrows) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (arrows j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Î¹ arrows j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) h)","decl":"@[reassoc, simp]\ntheorem arrow_Î¹ (j : J) : arrows j â‰« Î¹ arrows j = head arrows := by\n  apply colimit.w (WidePushoutShape.wideSpan _ _ _) (WidePushoutShape.Hom.init j)\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.arrow_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom B (objs j)\ninstâœ : CategoryTheory.Limits.HasWidePushout B objs arrows\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (arrows j) (CategoryTheory.Limits.WidePushout.Î¹ arrows j)) (CategoryTheory.Limits.WidePushout.head arrows)","decl":"@[reassoc, simp]\ntheorem arrow_Î¹ (j : J) : arrows j â‰« Î¹ arrows j = head arrows := by\n  apply colimit.w (WidePushoutShape.wideSpan _ _ _) (WidePushoutShape.Hom.init j)\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.Î¹_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom B (objs j)\ninstâœ : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\nf : Quiver.Hom B X\nfs : (j : J) â†’ Quiver.Hom (objs j) X\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (arrows j) (fs j)) f\nj : J\nZ : C\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Î¹ arrows j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.desc f fs w) h)) (CategoryTheory.CategoryStruct.comp (fs j) h)","decl":"@[reassoc]\ntheorem Î¹_desc (j : J) : Î¹ arrows j â‰« desc f fs w = fs _ := by\n  simp only [colimit.Î¹_desc, WidePushoutShape.mkCocone_pt, WidePushoutShape.mkCocone_Î¹_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.Î¹_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom B (objs j)\ninstâœ : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\nf : Quiver.Hom B X\nfs : (j : J) â†’ Quiver.Hom (objs j) X\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (arrows j) (fs j)) f\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Î¹ arrows j) (CategoryTheory.Limits.WidePushout.desc f fs w)) (fs j)","decl":"@[reassoc]\ntheorem Î¹_desc (j : J) : Î¹ arrows j â‰« desc f fs w = fs _ := by\n  simp only [colimit.Î¹_desc, WidePushoutShape.mkCocone_pt, WidePushoutShape.mkCocone_Î¹_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.head_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom B (objs j)\ninstâœ : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\nf : Quiver.Hom B X\nfs : (j : J) â†’ Quiver.Hom (objs j) X\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (arrows j) (fs j)) f\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) (CategoryTheory.Limits.WidePushout.desc f fs w)) f","decl":"@[reassoc]\ntheorem head_desc : head arrows â‰« desc f fs w = f := by\n  simp only [colimit.Î¹_desc, WidePushoutShape.mkCocone_pt, WidePushoutShape.mkCocone_Î¹_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.head_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom B (objs j)\ninstâœ : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\nf : Quiver.Hom B X\nfs : (j : J) â†’ Quiver.Hom (objs j) X\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (arrows j) (fs j)) f\nZ : C\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.desc f fs w) h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc]\ntheorem head_desc : head arrows â‰« desc f fs w = f := by\n  simp only [colimit.Î¹_desc, WidePushoutShape.mkCocone_pt, WidePushoutShape.mkCocone_Î¹_app]\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.eq_desc_of_comp_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom B (objs j)\ninstâœ : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\nf : Quiver.Hom B X\nfs : (j : J) â†’ Quiver.Hom (objs j) X\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (arrows j) (fs j)) f\ng : Quiver.Hom (CategoryTheory.Limits.widePushout B objs arrows) X\naâœÂ¹ : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Î¹ arrows j) g) (fs j)\naâœ : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) g) f\nâŠ¢ Eq g (CategoryTheory.Limits.WidePushout.desc f fs w)","decl":"theorem eq_desc_of_comp_eq (g : widePushout _ _ arrows âŸ¶ X) :\n    (âˆ€ j : J, Î¹ arrows j â‰« g = fs j) â†’ head arrows â‰« g = f â†’ g = desc f fs w := by\n  intro h1 h2\n  apply\n    (colimit.isColimit (WidePushoutShape.wideSpan B objs arrows)).uniq\n      (WidePushoutShape.mkCocone f fs <| w)\n  rintro (_ | _)\n  Â· apply h2\n  Â· apply h1\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.hom_eq_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom B (objs j)\ninstâœ : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\ng : Quiver.Hom (CategoryTheory.Limits.widePushout B objs arrows) X\nâŠ¢ Eq g (CategoryTheory.Limits.WidePushout.desc (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) g) (fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Î¹ arrows j) g) â‹¯)","decl":"theorem hom_eq_desc (g : widePushout _ _ arrows âŸ¶ X) :\n    g =\n      desc (head arrows â‰« g) (fun j => Î¹ arrows j â‰« g) fun j => by\n        rw [â† Category.assoc]\n        simp := by\n  apply eq_desc_of_comp_eq\n  Â· simp\n  Â· rfl -- Porting note: another missing rfl\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.hom_ext_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom B (objs j)\ninstâœ : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\ng1 g2 : Quiver.Hom (CategoryTheory.Limits.widePushout B objs arrows) X\nâŠ¢ Iff (Eq g1 g2) (And (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Î¹ arrows j) g1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Î¹ arrows j) g2)) (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) g1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) g2)))","decl":"@[ext 1100]\ntheorem hom_ext (g1 g2 : widePushout _ _ arrows âŸ¶ X) : (âˆ€ j : J,\n    Î¹ arrows j â‰« g1 = Î¹ arrows j â‰« g2) â†’ head arrows â‰« g1 = head arrows â‰« g2 â†’ g1 = g2 := by\n  intro h1 h2\n  apply colimit.hom_ext\n  rintro (_ | _)\n  Â· apply h2\n  Â· apply h1\n\n"}
{"name":"CategoryTheory.Limits.WidePushout.hom_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nB : C\nobjs : J â†’ C\narrows : (j : J) â†’ Quiver.Hom B (objs j)\ninstâœ : CategoryTheory.Limits.HasWidePushout B objs arrows\nX : C\ng1 g2 : Quiver.Hom (CategoryTheory.Limits.widePushout B objs arrows) X\naâœÂ¹ : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Î¹ arrows j) g1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.Î¹ arrows j) g2)\naâœ : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) g1) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePushout.head arrows) g2)\nâŠ¢ Eq g1 g2","decl":"@[ext 1100]\ntheorem hom_ext (g1 g2 : widePushout _ _ arrows âŸ¶ X) : (âˆ€ j : J,\n    Î¹ arrows j â‰« g1 = Î¹ arrows j â‰« g2) â†’ head arrows â‰« g1 = head arrows â‰« g2 â†’ g1 = g2 := by\n  intro h1 h2\n  apply colimit.hom_ext\n  rintro (_ | _)\n  Â· apply h2\n  Â· apply h1\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeOp_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX : CategoryTheory.Limits.WidePullbackShape J\nâŠ¢ Eq ((CategoryTheory.Limits.widePullbackShapeOp J).obj X) { unop := X }","decl":"/-- The obvious functor `WidePullbackShape J â¥¤ (WidePushoutShape J)áµ’áµ–` -/\n@[simps]\ndef widePullbackShapeOp : WidePullbackShape J â¥¤ (WidePushoutShape J)áµ’áµ– where\n  obj X := op X\n  map {Xâ‚} {Xâ‚‚} := widePullbackShapeOpMap J Xâ‚ Xâ‚‚\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeOp_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nXâ‚ Xâ‚‚ : CategoryTheory.Limits.WidePullbackShape J\naâœ : Quiver.Hom Xâ‚ Xâ‚‚\nâŠ¢ Eq ((CategoryTheory.Limits.widePullbackShapeOp J).map aâœ) (CategoryTheory.Limits.widePullbackShapeOpMap J Xâ‚ Xâ‚‚ aâœ)","decl":"/-- The obvious functor `WidePullbackShape J â¥¤ (WidePushoutShape J)áµ’áµ–` -/\n@[simps]\ndef widePullbackShapeOp : WidePullbackShape J â¥¤ (WidePushoutShape J)áµ’áµ– where\n  obj X := op X\n  map {Xâ‚} {Xâ‚‚} := widePullbackShapeOpMap J Xâ‚ Xâ‚‚\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeOp_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX Y : CategoryTheory.Limits.WidePushoutShape J\naâœ : Quiver.Hom X Y\nâŠ¢ Eq ((CategoryTheory.Limits.widePushoutShapeOp J).map aâœ) (CategoryTheory.Limits.widePushoutShapeOpMap J X Y aâœ)","decl":"/-- The obvious functor `WidePushoutShape J â¥¤ (WidePullbackShape J)áµ’áµ–` -/\n@[simps]\ndef widePushoutShapeOp : WidePushoutShape J â¥¤ (WidePullbackShape J)áµ’áµ– where\n  obj X := op X\n  map := fun {X} {Y} => widePushoutShapeOpMap J X Y\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeOp_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX : CategoryTheory.Limits.WidePushoutShape J\nâŠ¢ Eq ((CategoryTheory.Limits.widePushoutShapeOp J).obj X) { unop := X }","decl":"/-- The obvious functor `WidePushoutShape J â¥¤ (WidePullbackShape J)áµ’áµ–` -/\n@[simps]\ndef widePushoutShapeOp : WidePushoutShape J â¥¤ (WidePullbackShape J)áµ’áµ– where\n  obj X := op X\n  map := fun {X} {Y} => widePushoutShapeOpMap J X Y\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeUnop_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nXâœ Yâœ : Opposite (CategoryTheory.Limits.WidePullbackShape J)\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Limits.widePullbackShapeUnop J).map f) (CategoryTheory.Limits.widePullbackShapeOpMap J (Opposite.unop Yâœ) (Opposite.unop Xâœ) f.unop).unop","decl":"/-- The obvious functor `(WidePullbackShape J)áµ’áµ– â¥¤ WidePushoutShape J`-/\n@[simps!]\ndef widePullbackShapeUnop : (WidePullbackShape J)áµ’áµ– â¥¤ WidePushoutShape J :=\n  (widePullbackShapeOp J).leftOp\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeUnop_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX : Opposite (CategoryTheory.Limits.WidePullbackShape J)\nâŠ¢ Eq ((CategoryTheory.Limits.widePullbackShapeUnop J).obj X) (Opposite.unop X)","decl":"/-- The obvious functor `(WidePullbackShape J)áµ’áµ– â¥¤ WidePushoutShape J`-/\n@[simps!]\ndef widePullbackShapeUnop : (WidePullbackShape J)áµ’áµ– â¥¤ WidePushoutShape J :=\n  (widePullbackShapeOp J).leftOp\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeUnop_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nX : Opposite (CategoryTheory.Limits.WidePushoutShape J)\nâŠ¢ Eq ((CategoryTheory.Limits.widePushoutShapeUnop J).obj X) (Opposite.unop X)","decl":"/-- The obvious functor `(WidePushoutShape J)áµ’áµ– â¥¤ WidePullbackShape J` -/\n@[simps!]\ndef widePushoutShapeUnop : (WidePushoutShape J)áµ’áµ– â¥¤ WidePullbackShape J :=\n  (widePushoutShapeOp J).leftOp\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeUnop_map","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nXâœ Yâœ : Opposite (CategoryTheory.Limits.WidePushoutShape J)\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Limits.widePushoutShapeUnop J).map f) (CategoryTheory.Limits.widePushoutShapeOpMap J (Opposite.unop Yâœ) (Opposite.unop Xâœ) f.unop).unop","decl":"/-- The obvious functor `(WidePushoutShape J)áµ’áµ– â¥¤ WidePullbackShape J` -/\n@[simps!]\ndef widePushoutShapeUnop : (WidePushoutShape J)áµ’áµ– â¥¤ WidePullbackShape J :=\n  (widePushoutShapeOp J).leftOp\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeOpEquiv_unitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nâŠ¢ Eq (CategoryTheory.Limits.widePushoutShapeOpEquiv J).unitIso (CategoryTheory.Limits.widePushoutShapeOpUnop J).symm","decl":"/-- The duality equivalence `(WidePushoutShape J)áµ’áµ– â‰Œ WidePullbackShape J` -/\n@[simps]\ndef widePushoutShapeOpEquiv : (WidePushoutShape J)áµ’áµ– â‰Œ WidePullbackShape J where\n  functor := widePushoutShapeUnop J\n  inverse := widePullbackShapeOp J\n  unitIso := (widePushoutShapeOpUnop J).symm\n  counitIso := widePullbackShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeOpEquiv_functor","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nâŠ¢ Eq (CategoryTheory.Limits.widePushoutShapeOpEquiv J).functor (CategoryTheory.Limits.widePushoutShapeUnop J)","decl":"/-- The duality equivalence `(WidePushoutShape J)áµ’áµ– â‰Œ WidePullbackShape J` -/\n@[simps]\ndef widePushoutShapeOpEquiv : (WidePushoutShape J)áµ’áµ– â‰Œ WidePullbackShape J where\n  functor := widePushoutShapeUnop J\n  inverse := widePullbackShapeOp J\n  unitIso := (widePushoutShapeOpUnop J).symm\n  counitIso := widePullbackShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeOpEquiv_counitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nâŠ¢ Eq (CategoryTheory.Limits.widePushoutShapeOpEquiv J).counitIso (CategoryTheory.Limits.widePullbackShapeUnopOp J)","decl":"/-- The duality equivalence `(WidePushoutShape J)áµ’áµ– â‰Œ WidePullbackShape J` -/\n@[simps]\ndef widePushoutShapeOpEquiv : (WidePushoutShape J)áµ’áµ– â‰Œ WidePullbackShape J where\n  functor := widePushoutShapeUnop J\n  inverse := widePullbackShapeOp J\n  unitIso := (widePushoutShapeOpUnop J).symm\n  counitIso := widePullbackShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePushoutShapeOpEquiv_inverse","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nâŠ¢ Eq (CategoryTheory.Limits.widePushoutShapeOpEquiv J).inverse (CategoryTheory.Limits.widePullbackShapeOp J)","decl":"/-- The duality equivalence `(WidePushoutShape J)áµ’áµ– â‰Œ WidePullbackShape J` -/\n@[simps]\ndef widePushoutShapeOpEquiv : (WidePushoutShape J)áµ’áµ– â‰Œ WidePullbackShape J where\n  functor := widePushoutShapeUnop J\n  inverse := widePullbackShapeOp J\n  unitIso := (widePushoutShapeOpUnop J).symm\n  counitIso := widePullbackShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeOpEquiv_functor","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nâŠ¢ Eq (CategoryTheory.Limits.widePullbackShapeOpEquiv J).functor (CategoryTheory.Limits.widePullbackShapeUnop J)","decl":"/-- The duality equivalence `(WidePullbackShape J)áµ’áµ– â‰Œ WidePushoutShape J` -/\n@[simps]\ndef widePullbackShapeOpEquiv : (WidePullbackShape J)áµ’áµ– â‰Œ WidePushoutShape J where\n  functor := widePullbackShapeUnop J\n  inverse := widePushoutShapeOp J\n  unitIso := (widePullbackShapeOpUnop J).symm\n  counitIso := widePushoutShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeOpEquiv_unitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nâŠ¢ Eq (CategoryTheory.Limits.widePullbackShapeOpEquiv J).unitIso (CategoryTheory.Limits.widePullbackShapeOpUnop J).symm","decl":"/-- The duality equivalence `(WidePullbackShape J)áµ’áµ– â‰Œ WidePushoutShape J` -/\n@[simps]\ndef widePullbackShapeOpEquiv : (WidePullbackShape J)áµ’áµ– â‰Œ WidePushoutShape J where\n  functor := widePullbackShapeUnop J\n  inverse := widePushoutShapeOp J\n  unitIso := (widePullbackShapeOpUnop J).symm\n  counitIso := widePushoutShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeOpEquiv_counitIso","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nâŠ¢ Eq (CategoryTheory.Limits.widePullbackShapeOpEquiv J).counitIso (CategoryTheory.Limits.widePushoutShapeUnopOp J)","decl":"/-- The duality equivalence `(WidePullbackShape J)áµ’áµ– â‰Œ WidePushoutShape J` -/\n@[simps]\ndef widePullbackShapeOpEquiv : (WidePullbackShape J)áµ’áµ– â‰Œ WidePushoutShape J where\n  functor := widePullbackShapeUnop J\n  inverse := widePushoutShapeOp J\n  unitIso := (widePullbackShapeOpUnop J).symm\n  counitIso := widePushoutShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.widePullbackShapeOpEquiv_inverse","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"J : Type w\nâŠ¢ Eq (CategoryTheory.Limits.widePullbackShapeOpEquiv J).inverse (CategoryTheory.Limits.widePushoutShapeOp J)","decl":"/-- The duality equivalence `(WidePullbackShape J)áµ’áµ– â‰Œ WidePushoutShape J` -/\n@[simps]\ndef widePullbackShapeOpEquiv : (WidePullbackShape J)áµ’áµ– â‰Œ WidePushoutShape J where\n  functor := widePullbackShapeUnop J\n  inverse := widePushoutShapeOp J\n  unitIso := (widePullbackShapeOpUnop J).symm\n  counitIso := widePushoutShapeUnopOp J\n\n"}
{"name":"CategoryTheory.Limits.hasWidePushouts_shrink","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasWidePushouts C\nâŠ¢ CategoryTheory.Limits.HasWidePushouts C","decl":"/-- If a category has wide pushouts on a higher universe level it also has wide pushouts\non a lower universe level. -/\ntheorem hasWidePushouts_shrink [HasWidePushouts.{max w w'} C] : HasWidePushouts.{w} C := fun _ =>\n  hasColimitsOfShape_of_equivalence (WidePushoutShape.equivalenceOfEquiv _ Equiv.ulift.{w'})\n\n"}
{"name":"CategoryTheory.Limits.hasWidePullbacks_shrink","module":"Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasWidePullbacks C\nâŠ¢ CategoryTheory.Limits.HasWidePullbacks C","decl":"/-- If a category has wide pullbacks on a higher universe level it also has wide pullbacks\non a lower universe level. -/\ntheorem hasWidePullbacks_shrink [HasWidePullbacks.{max w w'} C] : HasWidePullbacks.{w} C := fun _ =>\n  hasLimitsOfShape_of_equivalence (WidePullbackShape.equivalenceOfEquiv _ Equiv.ulift.{w'})\n\n"}
