{"name":"TensorProduct.AlgebraTensorModule.smul_eq_lsmul_rTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\na : A\nx : TensorProduct R M N\n⊢ Eq (HSMul.hSMul a x) ((LinearMap.rTensor N ((Algebra.lsmul R R M) a)) x)","decl":"theorem smul_eq_lsmul_rTensor (a : A) (x : M ⊗[R] N) : a • x = (lsmul R R M a).rTensor N x :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.curry_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Module A M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R P\ninst✝¹ : Module A P\ninst✝ : IsScalarTower R A P\nf : LinearMap (RingHom.id A) (TensorProduct R M N) P\na : M\n⊢ Eq ((TensorProduct.AlgebraTensorModule.curry f) a) ((TensorProduct.curry (↑R f)) a)","decl":"/-- Heterobasic version of `TensorProduct.curry`:\n\nGiven a linear map `M ⊗[R] N →[A] P`, compose it with the canonical\nbilinear map `M →[A] N →[R] M ⊗[R] N` to form a bilinear map `M →[A] N →[R] P`. -/\n@[simps]\nnonrec def curry (f : M ⊗[R] N →ₗ[A] P) : M →ₗ[A] N →ₗ[R] P :=\n  { curry (f.restrictScalars R) with\n    toFun := curry (f.restrictScalars R)\n    map_smul' := fun c x => LinearMap.ext fun y => f.map_smul c (x ⊗ₜ y) }\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.restrictScalars_curry","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Module A M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R P\ninst✝¹ : Module A P\ninst✝ : IsScalarTower R A P\nf : LinearMap (RingHom.id A) (TensorProduct R M N) P\n⊢ Eq (↑R (TensorProduct.AlgebraTensorModule.curry f)) (TensorProduct.curry (↑R f))","decl":"theorem restrictScalars_curry (f : M ⊗[R] N →ₗ[A] P) :\n    restrictScalars R (curry f) = TensorProduct.curry (f.restrictScalars R) :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.curry_injective_iff","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Module A M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R P\ninst✝¹ : Module A P\ninst✝ : IsScalarTower R A P\na₁ a₂ : LinearMap (RingHom.id A) (TensorProduct R M N) P\n⊢ Iff (Eq a₁ a₂) (Eq (TensorProduct.AlgebraTensorModule.curry a₁) (TensorProduct.AlgebraTensorModule.curry a₂))","decl":"/-- Just as `TensorProduct.ext` is marked `ext` instead of `TensorProduct.ext'`, this is\na better `ext` lemma than `TensorProduct.AlgebraTensorModule.ext` below.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext high]\nnonrec theorem curry_injective : Function.Injective (curry : (M ⊗ N →ₗ[A] P) → M →ₗ[A] N →ₗ[R] P) :=\n  fun _ _ h =>\n  LinearMap.restrictScalars_injective R <|\n    curry_injective <| (congr_arg (LinearMap.restrictScalars R) h :)\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.curry_injective","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Module A M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R P\ninst✝¹ : Module A P\ninst✝ : IsScalarTower R A P\n⊢ Function.Injective TensorProduct.AlgebraTensorModule.curry","decl":"/-- Just as `TensorProduct.ext` is marked `ext` instead of `TensorProduct.ext'`, this is\na better `ext` lemma than `TensorProduct.AlgebraTensorModule.ext` below.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext high]\nnonrec theorem curry_injective : Function.Injective (curry : (M ⊗ N →ₗ[A] P) → M →ₗ[A] N →ₗ[R] P) :=\n  fun _ _ h =>\n  LinearMap.restrictScalars_injective R <|\n    curry_injective <| (congr_arg (LinearMap.restrictScalars R) h :)\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.ext","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Module A M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R P\ninst✝¹ : Module A P\ninst✝ : IsScalarTower R A P\ng h : LinearMap (RingHom.id A) (TensorProduct R M N) P\nH : ∀ (x : M) (y : N), Eq (g (TensorProduct.tmul R x y)) (h (TensorProduct.tmul R x y))\n⊢ Eq g h","decl":"theorem ext {g h : M ⊗[R] N →ₗ[A] P} (H : ∀ x y, g (x ⊗ₜ y) = h (x ⊗ₜ y)) : g = h :=\n  curry_injective <| LinearMap.ext₂ H\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.lift_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Module A M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R P\ninst✝¹ : Module A P\ninst✝ : IsScalarTower R A P\nf : LinearMap (RingHom.id A) M (LinearMap (RingHom.id R) N P)\na : TensorProduct R M N\n⊢ Eq ((TensorProduct.AlgebraTensorModule.lift f) a) ((TensorProduct.lift (↑R f)) a)","decl":"@[simp]\ntheorem lift_apply (f : M →ₗ[A] N →ₗ[R] P) (a : M ⊗[R] N) :\n    AlgebraTensorModule.lift f a = TensorProduct.lift (LinearMap.restrictScalars R f) a :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.lift_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Module A M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R P\ninst✝¹ : Module A P\ninst✝ : IsScalarTower R A P\nf : LinearMap (RingHom.id A) M (LinearMap (RingHom.id R) N P)\nx : M\ny : N\n⊢ Eq ((TensorProduct.AlgebraTensorModule.lift f) (TensorProduct.tmul R x y)) ((f x) y)","decl":"@[simp]\ntheorem lift_tmul (f : M →ₗ[A] N →ₗ[R] P) (x : M) (y : N) : lift f (x ⊗ₜ y) = f x y :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.uncurry_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nM : Type uM\nN : Type uN\nP : Type uP\ninst✝¹⁷ : CommSemiring R\ninst✝¹⁶ : Semiring A\ninst✝¹⁵ : Semiring B\ninst✝¹⁴ : Algebra R A\ninst✝¹³ : Algebra R B\ninst✝¹² : AddCommMonoid M\ninst✝¹¹ : Module R M\ninst✝¹⁰ : Module A M\ninst✝⁹ : IsScalarTower R A M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : Module R N\ninst✝⁶ : AddCommMonoid P\ninst✝⁵ : Module R P\ninst✝⁴ : Module A P\ninst✝³ : IsScalarTower R A P\ninst✝² : Module B P\ninst✝¹ : IsScalarTower R B P\ninst✝ : SMulCommClass A B P\nf : LinearMap (RingHom.id A) M (LinearMap (RingHom.id R) N P)\n⊢ Eq ((TensorProduct.AlgebraTensorModule.uncurry R A B M N P) f) (TensorProduct.AlgebraTensorModule.lift f)","decl":"/-- Heterobasic version of `TensorProduct.uncurry`:\n\nLinearly constructing a linear map `M ⊗[R] N →[A] P` given a bilinear map `M →[A] N →[R] P`\nwith the property that its composition with the canonical bilinear map `M →[A] N →[R] M ⊗[R] N` is\nthe given bilinear map `M →[A] N →[R] P`. -/\n@[simps]\ndef uncurry : (M →ₗ[A] N →ₗ[R] P) →ₗ[B] M ⊗[R] N →ₗ[A] P where\n  toFun := lift\n  map_add' _ _ := ext fun x y => by simp only [lift_tmul, add_apply]\n  map_smul' _ _ := ext fun x y => by simp only [lift_tmul, smul_apply, RingHom.id_apply]\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.lcurry_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nM : Type uM\nN : Type uN\nP : Type uP\ninst✝¹⁷ : CommSemiring R\ninst✝¹⁶ : Semiring A\ninst✝¹⁵ : Semiring B\ninst✝¹⁴ : Algebra R A\ninst✝¹³ : Algebra R B\ninst✝¹² : AddCommMonoid M\ninst✝¹¹ : Module R M\ninst✝¹⁰ : Module A M\ninst✝⁹ : IsScalarTower R A M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : Module R N\ninst✝⁶ : AddCommMonoid P\ninst✝⁵ : Module R P\ninst✝⁴ : Module A P\ninst✝³ : IsScalarTower R A P\ninst✝² : Module B P\ninst✝¹ : IsScalarTower R B P\ninst✝ : SMulCommClass A B P\nf : LinearMap (RingHom.id A) (TensorProduct R M N) P\n⊢ Eq ((TensorProduct.AlgebraTensorModule.lcurry R A B M N P) f) (TensorProduct.AlgebraTensorModule.curry f)","decl":"/-- Heterobasic version of `TensorProduct.lcurry`:\n\nGiven a linear map `M ⊗[R] N →[A] P`, compose it with the canonical\nbilinear map `M →[A] N →[R] M ⊗[R] N` to form a bilinear map `M →[A] N →[R] P`. -/\n@[simps]\ndef lcurry : (M ⊗[R] N →ₗ[A] P) →ₗ[B] M →ₗ[A] N →ₗ[R] P where\n  toFun := curry\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.mk_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nm : M\n⊢ Eq ((TensorProduct.AlgebraTensorModule.mk R A M N) m) { toFun := fun x2 => TensorProduct.tmul R m x2, map_add' := ⋯, map_smul' := ⋯ }","decl":"/-- Heterobasic version of `TensorProduct.mk`:\n\nThe canonical bilinear map `M →[A] N →[R] M ⊗[R] N`. -/\n@[simps! apply]\nnonrec def mk : M →ₗ[A] N →ₗ[R] M ⊗[R] N :=\n  { mk R M N with map_smul' := fun _ _ => rfl }\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.map_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : Semiring A\ninst✝¹² : Algebra R A\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\ninst✝⁹ : Module A M\ninst✝⁸ : IsScalarTower R A M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R P\ninst✝³ : Module A P\ninst✝² : IsScalarTower R A P\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module R Q\nf : LinearMap (RingHom.id A) M P\ng : LinearMap (RingHom.id R) N Q\nm : M\nn : N\n⊢ Eq ((TensorProduct.AlgebraTensorModule.map f g) (TensorProduct.tmul R m n)) (TensorProduct.tmul R (f m) (g n))","decl":"@[simp] theorem map_tmul (f : M →ₗ[A] P) (g : N →ₗ[R] Q) (m : M) (n : N) :\n    map f g (m ⊗ₜ n) = f m ⊗ₜ g n :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.map_id","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n⊢ Eq (TensorProduct.AlgebraTensorModule.map LinearMap.id LinearMap.id) LinearMap.id","decl":"@[simp]\ntheorem map_id : map (id : M →ₗ[A] M) (id : N →ₗ[R] N) = .id :=\n  ext fun _ _ => rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.map_comp","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\nP' : Type uP'\nQ' : Type uQ'\ninst✝²⁰ : CommSemiring R\ninst✝¹⁹ : Semiring A\ninst✝¹⁸ : Algebra R A\ninst✝¹⁷ : AddCommMonoid M\ninst✝¹⁶ : Module R M\ninst✝¹⁵ : Module A M\ninst✝¹⁴ : IsScalarTower R A M\ninst✝¹³ : AddCommMonoid N\ninst✝¹² : Module R N\ninst✝¹¹ : AddCommMonoid P\ninst✝¹⁰ : Module R P\ninst✝⁹ : Module A P\ninst✝⁸ : IsScalarTower R A P\ninst✝⁷ : AddCommMonoid Q\ninst✝⁶ : Module R Q\ninst✝⁵ : AddCommMonoid P'\ninst✝⁴ : Module R P'\ninst✝³ : Module A P'\ninst✝² : IsScalarTower R A P'\ninst✝¹ : AddCommMonoid Q'\ninst✝ : Module R Q'\nf₂ : LinearMap (RingHom.id A) P P'\nf₁ : LinearMap (RingHom.id A) M P\ng₂ : LinearMap (RingHom.id R) Q Q'\ng₁ : LinearMap (RingHom.id R) N Q\n⊢ Eq (TensorProduct.AlgebraTensorModule.map (f₂.comp f₁) (g₂.comp g₁)) ((TensorProduct.AlgebraTensorModule.map f₂ g₂).comp (TensorProduct.AlgebraTensorModule.map f₁ g₁))","decl":"theorem map_comp (f₂ : P →ₗ[A] P') (f₁ : M →ₗ[A] P) (g₂ : Q →ₗ[R] Q') (g₁ : N →ₗ[R] Q) :\n    map (f₂.comp f₁) (g₂.comp g₁) = (map f₂ g₂).comp (map f₁ g₁) :=\n  ext fun _ _ => rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.map_one","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n⊢ Eq (TensorProduct.AlgebraTensorModule.map 1 1) 1","decl":"@[simp]\nprotected theorem map_one : map (1 : M →ₗ[A] M) (1 : N →ₗ[R] N) = 1 := map_id\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.map_mul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf₁ f₂ : LinearMap (RingHom.id A) M M\ng₁ g₂ : LinearMap (RingHom.id R) N N\n⊢ Eq (TensorProduct.AlgebraTensorModule.map (HMul.hMul f₁ f₂) (HMul.hMul g₁ g₂)) (HMul.hMul (TensorProduct.AlgebraTensorModule.map f₁ g₁) (TensorProduct.AlgebraTensorModule.map f₂ g₂))","decl":"protected theorem map_mul (f₁ f₂ : M →ₗ[A] M) (g₁ g₂ : N →ₗ[R] N) :\n    map (f₁ * f₂) (g₁ * g₂) = map f₁ g₁ * map f₂ g₂ := map_comp _ _ _ _\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.map_add_left","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : Semiring A\ninst✝¹² : Algebra R A\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\ninst✝⁹ : Module A M\ninst✝⁸ : IsScalarTower R A M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R P\ninst✝³ : Module A P\ninst✝² : IsScalarTower R A P\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module R Q\nf₁ f₂ : LinearMap (RingHom.id A) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq (TensorProduct.AlgebraTensorModule.map (HAdd.hAdd f₁ f₂) g) (HAdd.hAdd (TensorProduct.AlgebraTensorModule.map f₁ g) (TensorProduct.AlgebraTensorModule.map f₂ g))","decl":"theorem map_add_left (f₁ f₂ : M →ₗ[A] P) (g : N →ₗ[R] Q) :\n    map (f₁ + f₂) g = map f₁ g + map f₂ g := by\n  ext\n  simp_rw [curry_apply, TensorProduct.curry_apply, restrictScalars_apply, add_apply, map_tmul,\n    add_apply, add_tmul]\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.map_add_right","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : Semiring A\ninst✝¹² : Algebra R A\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\ninst✝⁹ : Module A M\ninst✝⁸ : IsScalarTower R A M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R P\ninst✝³ : Module A P\ninst✝² : IsScalarTower R A P\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module R Q\nf : LinearMap (RingHom.id A) M P\ng₁ g₂ : LinearMap (RingHom.id R) N Q\n⊢ Eq (TensorProduct.AlgebraTensorModule.map f (HAdd.hAdd g₁ g₂)) (HAdd.hAdd (TensorProduct.AlgebraTensorModule.map f g₁) (TensorProduct.AlgebraTensorModule.map f g₂))","decl":"theorem map_add_right (f : M →ₗ[A] P) (g₁ g₂ : N →ₗ[R] Q) :\n    map f (g₁ + g₂) = map f g₁ + map f g₂ := by\n  ext\n  simp_rw [curry_apply, TensorProduct.curry_apply, restrictScalars_apply, add_apply, map_tmul,\n    add_apply, tmul_add]\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.map_smul_right","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : Semiring A\ninst✝¹² : Algebra R A\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\ninst✝⁹ : Module A M\ninst✝⁸ : IsScalarTower R A M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R P\ninst✝³ : Module A P\ninst✝² : IsScalarTower R A P\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module R Q\nr : R\nf : LinearMap (RingHom.id A) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq (TensorProduct.AlgebraTensorModule.map f (HSMul.hSMul r g)) (HSMul.hSMul r (TensorProduct.AlgebraTensorModule.map f g))","decl":"theorem map_smul_right (r : R) (f : M →ₗ[A] P) (g : N →ₗ[R] Q) : map f (r • g) = r • map f g := by\n  ext\n  simp_rw [curry_apply, TensorProduct.curry_apply, restrictScalars_apply, smul_apply, map_tmul,\n    smul_apply, tmul_smul]\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.map_smul_left","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝¹⁹ : CommSemiring R\ninst✝¹⁸ : Semiring A\ninst✝¹⁷ : Semiring B\ninst✝¹⁶ : Algebra R A\ninst✝¹⁵ : Algebra R B\ninst✝¹⁴ : AddCommMonoid M\ninst✝¹³ : Module R M\ninst✝¹² : Module A M\ninst✝¹¹ : IsScalarTower R A M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : Module R N\ninst✝⁸ : AddCommMonoid P\ninst✝⁷ : Module R P\ninst✝⁶ : Module A P\ninst✝⁵ : IsScalarTower R A P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R Q\ninst✝² : Module B P\ninst✝¹ : IsScalarTower R B P\ninst✝ : SMulCommClass A B P\nb : B\nf : LinearMap (RingHom.id A) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq (TensorProduct.AlgebraTensorModule.map (HSMul.hSMul b f) g) (HSMul.hSMul b (TensorProduct.AlgebraTensorModule.map f g))","decl":"theorem map_smul_left (b : B) (f : M →ₗ[A] P) (g : N →ₗ[R] Q) : map (b • f) g = b • map f g := by\n  ext\n  simp_rw [curry_apply, TensorProduct.curry_apply, restrictScalars_apply, smul_apply, map_tmul,\n    smul_apply, smul_tmul']\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.coe_lTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nQ : Type uQ\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : Semiring A\ninst✝⁸ : Algebra R A\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module A M\ninst✝⁴ : IsScalarTower R A M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module R Q\nf : LinearMap (RingHom.id R) N Q\n⊢ Eq ⇑((TensorProduct.AlgebraTensorModule.lTensor A M) f) ⇑(LinearMap.lTensor M f)","decl":"@[simp]\nlemma coe_lTensor (f : N →ₗ[R] Q) :\n    (lTensor A M f : M ⊗[R] N → M ⊗[R] Q) = f.lTensor M := rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.restrictScalars_lTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nQ : Type uQ\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : Semiring A\ninst✝⁸ : Algebra R A\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module A M\ninst✝⁴ : IsScalarTower R A M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module R Q\nf : LinearMap (RingHom.id R) N Q\n⊢ Eq (↑R ((TensorProduct.AlgebraTensorModule.lTensor A M) f)) (LinearMap.lTensor M f)","decl":"@[simp]\nlemma restrictScalars_lTensor (f : N →ₗ[R] Q) :\n    (lTensor A M f).restrictScalars R = f.lTensor M := rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.lTensor_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nQ : Type uQ\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : Semiring A\ninst✝⁸ : Algebra R A\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module A M\ninst✝⁴ : IsScalarTower R A M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module R Q\nf : LinearMap (RingHom.id R) N Q\nm : M\nn : N\n⊢ Eq (((TensorProduct.AlgebraTensorModule.lTensor A M) f) (TensorProduct.tmul R m n)) (TensorProduct.tmul R m (f n))","decl":"@[simp] lemma lTensor_tmul (f : N →ₗ[R] Q) (m : M) (n : N) :\n    lTensor A M f (m ⊗ₜ[R] n) = m ⊗ₜ f n :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.lTensor_id","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n⊢ Eq ((TensorProduct.AlgebraTensorModule.lTensor A M) LinearMap.id) LinearMap.id","decl":"@[simp] lemma lTensor_id : lTensor A M (id : N →ₗ[R] N) = .id :=\n  ext fun _ _ => rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.lTensor_comp","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nQ : Type uQ\nQ' : Type uQ'\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Module A M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R Q\ninst✝¹ : AddCommMonoid Q'\ninst✝ : Module R Q'\nf₂ : LinearMap (RingHom.id R) Q Q'\nf₁ : LinearMap (RingHom.id R) N Q\n⊢ Eq ((TensorProduct.AlgebraTensorModule.lTensor A M) (f₂.comp f₁)) (((TensorProduct.AlgebraTensorModule.lTensor A M) f₂).comp ((TensorProduct.AlgebraTensorModule.lTensor A M) f₁))","decl":"lemma lTensor_comp (f₂ : Q →ₗ[R] Q') (f₁ : N →ₗ[R] Q) :\n    lTensor A M (f₂.comp f₁) = (lTensor A M f₂).comp (lTensor A M f₁) :=\n  ext fun _ _ => rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.lTensor_one","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n⊢ Eq ((TensorProduct.AlgebraTensorModule.lTensor A M) 1) 1","decl":"@[simp]\nlemma lTensor_one : lTensor A M (1 : N →ₗ[R] N) = 1 := map_id\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.lTensor_mul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf₁ f₂ : LinearMap (RingHom.id R) N N\n⊢ Eq ((TensorProduct.AlgebraTensorModule.lTensor A M) (HMul.hMul f₁ f₂)) (HMul.hMul ((TensorProduct.AlgebraTensorModule.lTensor A M) f₁) ((TensorProduct.AlgebraTensorModule.lTensor A M) f₂))","decl":"lemma lTensor_mul (f₁ f₂ : N →ₗ[R] N) :\n    lTensor A M (f₁ * f₂) = lTensor A M f₁ * lTensor A M f₂ := lTensor_comp _ _\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.coe_rTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Module A M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R P\ninst✝¹ : Module A P\ninst✝ : IsScalarTower R A P\nf : LinearMap (RingHom.id A) M P\n⊢ Eq ⇑((TensorProduct.AlgebraTensorModule.rTensor R N) f) ⇑(LinearMap.rTensor N (↑R f))","decl":"@[simp]\nlemma coe_rTensor (f : M →ₗ[A] P) :\n    (rTensor R N f : M ⊗[R] N → P ⊗[R] N) = f.rTensor N := rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.restrictScalars_rTensor","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Module A M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R P\ninst✝¹ : Module A P\ninst✝ : IsScalarTower R A P\nf : LinearMap (RingHom.id A) M P\n⊢ Eq (↑R ((TensorProduct.AlgebraTensorModule.rTensor R N) f)) (LinearMap.rTensor N (↑R f))","decl":"@[simp]\nlemma restrictScalars_rTensor (f : M →ₗ[A] P) :\n    (rTensor R N f).restrictScalars R = f.rTensor N := rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.rTensor_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Module A M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R P\ninst✝¹ : Module A P\ninst✝ : IsScalarTower R A P\nf : LinearMap (RingHom.id A) M P\nm : M\nn : N\n⊢ Eq (((TensorProduct.AlgebraTensorModule.rTensor R N) f) (TensorProduct.tmul R m n)) (TensorProduct.tmul R (f m) n)","decl":"@[simp] lemma rTensor_tmul (f : M →ₗ[A] P) (m : M) (n : N) :\n    rTensor R N f (m ⊗ₜ[R] n) = f m ⊗ₜ n :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.rTensor_id","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n⊢ Eq ((TensorProduct.AlgebraTensorModule.rTensor R N) LinearMap.id) LinearMap.id","decl":"@[simp] lemma rTensor_id : rTensor R N (id : M →ₗ[A] M) = .id :=\n  ext fun _ _ => rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.rTensor_comp","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\nP' : Type uP'\ninst✝¹⁶ : CommSemiring R\ninst✝¹⁵ : Semiring A\ninst✝¹⁴ : Algebra R A\ninst✝¹³ : AddCommMonoid M\ninst✝¹² : Module R M\ninst✝¹¹ : Module A M\ninst✝¹⁰ : IsScalarTower R A M\ninst✝⁹ : AddCommMonoid N\ninst✝⁸ : Module R N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : Module R P\ninst✝⁵ : Module A P\ninst✝⁴ : IsScalarTower R A P\ninst✝³ : AddCommMonoid P'\ninst✝² : Module R P'\ninst✝¹ : Module A P'\ninst✝ : IsScalarTower R A P'\nf₂ : LinearMap (RingHom.id A) P P'\nf₁ : LinearMap (RingHom.id A) M P\n⊢ Eq ((TensorProduct.AlgebraTensorModule.rTensor R N) (f₂.comp f₁)) (((TensorProduct.AlgebraTensorModule.rTensor R N) f₂).comp ((TensorProduct.AlgebraTensorModule.rTensor R N) f₁))","decl":"lemma rTensor_comp (f₂ : P →ₗ[A] P') (f₁ : M →ₗ[A] P) :\n    rTensor R N (f₂.comp f₁) = (rTensor R N f₂).comp (rTensor R N f₁) :=\n  ext fun _ _ => rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.rTensor_one","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n⊢ Eq ((TensorProduct.AlgebraTensorModule.rTensor R N) 1) 1","decl":"@[simp]\nlemma rTensor_one : rTensor R N (1 : M →ₗ[A] M) = 1 := map_id\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.rTensor_mul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nf₁ f₂ : LinearMap (RingHom.id A) M M\n⊢ Eq ((TensorProduct.AlgebraTensorModule.rTensor R M) (HMul.hMul f₁ f₂)) (HMul.hMul ((TensorProduct.AlgebraTensorModule.rTensor R M) f₁) ((TensorProduct.AlgebraTensorModule.rTensor R M) f₂))","decl":"lemma rTensor_mul (f₁ f₂ : M →ₗ[A] M) :\n    rTensor R M (f₁ * f₂) = rTensor R M f₁ * rTensor R M f₂ := rTensor_comp _ _\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.mapBilinear_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝¹⁹ : CommSemiring R\ninst✝¹⁸ : Semiring A\ninst✝¹⁷ : Semiring B\ninst✝¹⁶ : Algebra R A\ninst✝¹⁵ : Algebra R B\ninst✝¹⁴ : AddCommMonoid M\ninst✝¹³ : Module R M\ninst✝¹² : Module A M\ninst✝¹¹ : IsScalarTower R A M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : Module R N\ninst✝⁸ : AddCommMonoid P\ninst✝⁷ : Module R P\ninst✝⁶ : Module A P\ninst✝⁵ : IsScalarTower R A P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R Q\ninst✝² : Module B P\ninst✝¹ : IsScalarTower R B P\ninst✝ : SMulCommClass A B P\nf : LinearMap (RingHom.id A) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq (((TensorProduct.AlgebraTensorModule.mapBilinear R A B M N P Q) f) g) (TensorProduct.AlgebraTensorModule.map f g)","decl":"@[simp]\ntheorem mapBilinear_apply (f : M →ₗ[A] P) (g : N →ₗ[R] Q) :\n    mapBilinear R A B M N P Q f g = map f g :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.homTensorHomMap_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝¹⁹ : CommSemiring R\ninst✝¹⁸ : Semiring A\ninst✝¹⁷ : Semiring B\ninst✝¹⁶ : Algebra R A\ninst✝¹⁵ : Algebra R B\ninst✝¹⁴ : AddCommMonoid M\ninst✝¹³ : Module R M\ninst✝¹² : Module A M\ninst✝¹¹ : IsScalarTower R A M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : Module R N\ninst✝⁸ : AddCommMonoid P\ninst✝⁷ : Module R P\ninst✝⁶ : Module A P\ninst✝⁵ : IsScalarTower R A P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R Q\ninst✝² : Module B P\ninst✝¹ : IsScalarTower R B P\ninst✝ : SMulCommClass A B P\nf : LinearMap (RingHom.id A) M P\ng : LinearMap (RingHom.id R) N Q\n⊢ Eq ((TensorProduct.AlgebraTensorModule.homTensorHomMap R A B M N P Q) (TensorProduct.tmul R f g)) (TensorProduct.AlgebraTensorModule.map f g)","decl":"@[simp] theorem homTensorHomMap_apply (f : M →ₗ[A] P) (g : N →ₗ[R] Q) :\n    homTensorHomMap R A B M N P Q (f ⊗ₜ g) = map f g :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.congr_refl","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n⊢ Eq (TensorProduct.AlgebraTensorModule.congr (LinearEquiv.refl A M) (LinearEquiv.refl R N)) (LinearEquiv.refl A (TensorProduct R M N))","decl":"@[simp]\ntheorem congr_refl : congr (.refl A M) (.refl R N) = .refl A _ :=\n  LinearEquiv.toLinearMap_injective <| map_id\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.congr_trans","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\nP' : Type uP'\nQ' : Type uQ'\ninst✝²⁰ : CommSemiring R\ninst✝¹⁹ : Semiring A\ninst✝¹⁸ : Algebra R A\ninst✝¹⁷ : AddCommMonoid M\ninst✝¹⁶ : Module R M\ninst✝¹⁵ : Module A M\ninst✝¹⁴ : IsScalarTower R A M\ninst✝¹³ : AddCommMonoid N\ninst✝¹² : Module R N\ninst✝¹¹ : AddCommMonoid P\ninst✝¹⁰ : Module R P\ninst✝⁹ : Module A P\ninst✝⁸ : IsScalarTower R A P\ninst✝⁷ : AddCommMonoid Q\ninst✝⁶ : Module R Q\ninst✝⁵ : AddCommMonoid P'\ninst✝⁴ : Module R P'\ninst✝³ : Module A P'\ninst✝² : IsScalarTower R A P'\ninst✝¹ : AddCommMonoid Q'\ninst✝ : Module R Q'\nf₁ : LinearEquiv (RingHom.id A) M P\nf₂ : LinearEquiv (RingHom.id A) P P'\ng₁ : LinearEquiv (RingHom.id R) N Q\ng₂ : LinearEquiv (RingHom.id R) Q Q'\n⊢ Eq (TensorProduct.AlgebraTensorModule.congr (f₁.trans f₂) (g₁.trans g₂)) ((TensorProduct.AlgebraTensorModule.congr f₁ g₁).trans (TensorProduct.AlgebraTensorModule.congr f₂ g₂))","decl":"theorem congr_trans (f₁ : M ≃ₗ[A] P) (f₂ : P ≃ₗ[A] P') (g₁ : N ≃ₗ[R] Q) (g₂ : Q ≃ₗ[R] Q') :\n    congr (f₁.trans f₂) (g₁.trans g₂) = (congr f₁ g₁).trans (congr f₂ g₂) :=\n  LinearEquiv.toLinearMap_injective <| map_comp _ _ _ _\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.congr_symm","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : Semiring A\ninst✝¹² : Algebra R A\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\ninst✝⁹ : Module A M\ninst✝⁸ : IsScalarTower R A M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R P\ninst✝³ : Module A P\ninst✝² : IsScalarTower R A P\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module R Q\nf : LinearEquiv (RingHom.id A) M P\ng : LinearEquiv (RingHom.id R) N Q\n⊢ Eq (TensorProduct.AlgebraTensorModule.congr f.symm g.symm) (TensorProduct.AlgebraTensorModule.congr f g).symm","decl":"theorem congr_symm (f : M ≃ₗ[A] P) (g : N ≃ₗ[R] Q) : congr f.symm g.symm = (congr f g).symm := rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.congr_one","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n⊢ Eq (TensorProduct.AlgebraTensorModule.congr 1 1) 1","decl":"@[simp]\ntheorem congr_one : congr (1 : M ≃ₗ[A] M) (1 : N ≃ₗ[R] N) = 1 := congr_refl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.congr_mul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf₁ f₂ : LinearEquiv (RingHom.id A) M M\ng₁ g₂ : LinearEquiv (RingHom.id R) N N\n⊢ Eq (TensorProduct.AlgebraTensorModule.congr (HMul.hMul f₁ f₂) (HMul.hMul g₁ g₂)) (HMul.hMul (TensorProduct.AlgebraTensorModule.congr f₁ g₁) (TensorProduct.AlgebraTensorModule.congr f₂ g₂))","decl":"theorem congr_mul (f₁ f₂ : M ≃ₗ[A] M) (g₁ g₂ : N ≃ₗ[R] N) :\n    congr (f₁ * f₂) (g₁ * g₂) = congr f₁ g₁ * congr f₂ g₂ := congr_trans _ _ _ _\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.congr_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : Semiring A\ninst✝¹² : Algebra R A\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\ninst✝⁹ : Module A M\ninst✝⁸ : IsScalarTower R A M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R P\ninst✝³ : Module A P\ninst✝² : IsScalarTower R A P\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module R Q\nf : LinearEquiv (RingHom.id A) M P\ng : LinearEquiv (RingHom.id R) N Q\nm : M\nn : N\n⊢ Eq ((TensorProduct.AlgebraTensorModule.congr f g) (TensorProduct.tmul R m n)) (TensorProduct.tmul R (f m) (g n))","decl":"@[simp] theorem congr_tmul (f : M ≃ₗ[A] P) (g : N ≃ₗ[R] Q) (m : M) (n : N) :\n    congr f g (m ⊗ₜ n) = f m ⊗ₜ g n :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.congr_symm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : Semiring A\ninst✝¹² : Algebra R A\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\ninst✝⁹ : Module A M\ninst✝⁸ : IsScalarTower R A M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R P\ninst✝³ : Module A P\ninst✝² : IsScalarTower R A P\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module R Q\nf : LinearEquiv (RingHom.id A) M P\ng : LinearEquiv (RingHom.id R) N Q\np : P\nq : Q\n⊢ Eq ((TensorProduct.AlgebraTensorModule.congr f g).symm (TensorProduct.tmul R p q)) (TensorProduct.tmul R (f.symm p) (g.symm q))","decl":"@[simp] theorem congr_symm_tmul (f : M ≃ₗ[A] P) (g : N ≃ₗ[R] Q) (p : P) (q : Q) :\n    (congr f g).symm (p ⊗ₜ q) = f.symm p ⊗ₜ g.symm q :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.rid_eq_rid","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nM : Type uM\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (TensorProduct.AlgebraTensorModule.rid R R M) (TensorProduct.rid R M)","decl":"theorem rid_eq_rid : AlgebraTensorModule.rid R R M = TensorProduct.rid R M :=\n  LinearEquiv.toLinearMap_injective <| TensorProduct.ext' fun _ _ => rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.rid_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nr : R\nm : M\n⊢ Eq ((TensorProduct.AlgebraTensorModule.rid R A M) (TensorProduct.tmul R m r)) (HSMul.hSMul r m)","decl":"variable {R M} in\n@[simp]\ntheorem rid_tmul (r : R) (m : M) : AlgebraTensorModule.rid R A M (m ⊗ₜ r) = r • m := rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.rid_symm_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nm : M\n⊢ Eq ((TensorProduct.AlgebraTensorModule.rid R A M).symm m) (TensorProduct.tmul R m 1)","decl":"variable {M} in\n@[simp]\ntheorem rid_symm_apply (m : M) : (AlgebraTensorModule.rid R A M).symm m = m ⊗ₜ 1 := rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.assoc_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nM : Type uM\nP : Type uP\nQ : Type uQ\ninst✝¹⁹ : CommSemiring R\ninst✝¹⁸ : CommSemiring A\ninst✝¹⁷ : Semiring B\ninst✝¹⁶ : Algebra R A\ninst✝¹⁵ : Algebra R B\ninst✝¹⁴ : AddCommMonoid M\ninst✝¹³ : Module R M\ninst✝¹² : Module A M\ninst✝¹¹ : Module B M\ninst✝¹⁰ : IsScalarTower R A M\ninst✝⁹ : IsScalarTower R B M\ninst✝⁸ : SMulCommClass A B M\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : Module A P\ninst✝⁵ : AddCommMonoid Q\ninst✝⁴ : Module R Q\ninst✝³ : Module R P\ninst✝² : IsScalarTower R A P\ninst✝¹ : Algebra A B\ninst✝ : IsScalarTower A B M\nm : M\np : P\nq : Q\n⊢ Eq ((TensorProduct.AlgebraTensorModule.assoc R A B M P Q) (TensorProduct.tmul R (TensorProduct.tmul A m p) q)) (TensorProduct.tmul A m (TensorProduct.tmul R p q))","decl":"@[simp]\ntheorem assoc_tmul (m : M) (p : P) (q : Q) :\n    assoc R A B M P Q ((m ⊗ₜ p) ⊗ₜ q) = m ⊗ₜ (p ⊗ₜ q) :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.assoc_symm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nM : Type uM\nP : Type uP\nQ : Type uQ\ninst✝¹⁹ : CommSemiring R\ninst✝¹⁸ : CommSemiring A\ninst✝¹⁷ : Semiring B\ninst✝¹⁶ : Algebra R A\ninst✝¹⁵ : Algebra R B\ninst✝¹⁴ : AddCommMonoid M\ninst✝¹³ : Module R M\ninst✝¹² : Module A M\ninst✝¹¹ : Module B M\ninst✝¹⁰ : IsScalarTower R A M\ninst✝⁹ : IsScalarTower R B M\ninst✝⁸ : SMulCommClass A B M\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : Module A P\ninst✝⁵ : AddCommMonoid Q\ninst✝⁴ : Module R Q\ninst✝³ : Module R P\ninst✝² : IsScalarTower R A P\ninst✝¹ : Algebra A B\ninst✝ : IsScalarTower A B M\nm : M\np : P\nq : Q\n⊢ Eq ((TensorProduct.AlgebraTensorModule.assoc R A B M P Q).symm (TensorProduct.tmul A m (TensorProduct.tmul R p q))) (TensorProduct.tmul R (TensorProduct.tmul A m p) q)","decl":"@[simp]\ntheorem assoc_symm_tmul (m : M) (p : P) (q : Q) :\n    (assoc R A B M P Q).symm (m ⊗ₜ (p ⊗ₜ q)) = (m ⊗ₜ p) ⊗ₜ q :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.rTensor_tensor","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\nP' : Type uP'\ninst✝¹⁶ : CommSemiring R\ninst✝¹⁵ : CommSemiring A\ninst✝¹⁴ : Algebra R A\ninst✝¹³ : AddCommMonoid M\ninst✝¹² : Module R M\ninst✝¹¹ : Module A M\ninst✝¹⁰ : IsScalarTower R A M\ninst✝⁹ : AddCommMonoid N\ninst✝⁸ : Module R N\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : Module A P\ninst✝⁵ : AddCommMonoid P'\ninst✝⁴ : Module A P'\ninst✝³ : Module R P\ninst✝² : IsScalarTower R A P\ninst✝¹ : Module R P'\ninst✝ : IsScalarTower R A P'\ng : LinearMap (RingHom.id A) P P'\n⊢ Eq (LinearMap.rTensor (TensorProduct R M N) g) ((↑(TensorProduct.AlgebraTensorModule.assoc R A A P' M N)).comp ((TensorProduct.AlgebraTensorModule.map (LinearMap.rTensor M g) LinearMap.id).comp ↑(TensorProduct.AlgebraTensorModule.assoc R A A P M N).symm))","decl":"theorem rTensor_tensor [Module R P'] [IsScalarTower R A P'] (g : P →ₗ[A] P') :\n    g.rTensor (M ⊗[R] N) =\n      assoc R A A P' M N ∘ₗ map (g.rTensor M) id ∘ₗ (assoc R A A P M N).symm.toLinearMap :=\n  TensorProduct.ext <| LinearMap.ext fun _ ↦ ext fun _ _ ↦ rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.cancelBaseChange_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nM : Type uM\nN : Type uN\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : CommSemiring A\ninst✝¹³ : Semiring B\ninst✝¹² : Algebra R A\ninst✝¹¹ : Algebra R B\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : Module R M\ninst✝⁸ : Module A M\ninst✝⁷ : Module B M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : IsScalarTower R B M\ninst✝⁴ : SMulCommClass A B M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Algebra A B\ninst✝ : IsScalarTower A B M\nm : M\nn : N\na : A\n⊢ Eq ((TensorProduct.AlgebraTensorModule.cancelBaseChange R A B M N) (TensorProduct.tmul A m (TensorProduct.tmul R a n))) (TensorProduct.tmul R (HSMul.hSMul a m) n)","decl":"@[simp]\ntheorem cancelBaseChange_tmul (m : M) (n : N) (a : A) :\n    cancelBaseChange R A B M N (m ⊗ₜ (a ⊗ₜ n)) = (a • m) ⊗ₜ n :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.cancelBaseChange_symm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nM : Type uM\nN : Type uN\ninst✝¹⁵ : CommSemiring R\ninst✝¹⁴ : CommSemiring A\ninst✝¹³ : Semiring B\ninst✝¹² : Algebra R A\ninst✝¹¹ : Algebra R B\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : Module R M\ninst✝⁸ : Module A M\ninst✝⁷ : Module B M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : IsScalarTower R B M\ninst✝⁴ : SMulCommClass A B M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Algebra A B\ninst✝ : IsScalarTower A B M\nm : M\nn : N\n⊢ Eq ((TensorProduct.AlgebraTensorModule.cancelBaseChange R A B M N).symm (TensorProduct.tmul R m n)) (TensorProduct.tmul A m (TensorProduct.tmul R 1 n))","decl":"@[simp]\ntheorem cancelBaseChange_symm_tmul (m : M) (n : N) :\n    (cancelBaseChange R A B M N).symm (m ⊗ₜ n) = m ⊗ₜ (1 ⊗ₜ n) :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.lTensor_comp_cancelBaseChange","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nM : Type uM\nN : Type uN\nQ : Type uQ\ninst✝¹⁷ : CommSemiring R\ninst✝¹⁶ : CommSemiring A\ninst✝¹⁵ : Semiring B\ninst✝¹⁴ : Algebra R A\ninst✝¹³ : Algebra R B\ninst✝¹² : AddCommMonoid M\ninst✝¹¹ : Module R M\ninst✝¹⁰ : Module A M\ninst✝⁹ : Module B M\ninst✝⁸ : IsScalarTower R A M\ninst✝⁷ : IsScalarTower R B M\ninst✝⁶ : SMulCommClass A B M\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R Q\ninst✝¹ : Algebra A B\ninst✝ : IsScalarTower A B M\nf : LinearMap (RingHom.id R) N Q\n⊢ Eq (((TensorProduct.AlgebraTensorModule.lTensor B M) f).comp ↑(TensorProduct.AlgebraTensorModule.cancelBaseChange R A B M N)) ((↑(TensorProduct.AlgebraTensorModule.cancelBaseChange R A B M Q)).comp ((TensorProduct.AlgebraTensorModule.lTensor B M) ((TensorProduct.AlgebraTensorModule.lTensor A A) f)))","decl":"theorem lTensor_comp_cancelBaseChange (f : N →ₗ[R] Q) :\n    lTensor _ _ f ∘ₗ cancelBaseChange R A B M N =\n      (cancelBaseChange R A B M Q).toLinearMap ∘ₗ lTensor _ _ (lTensor _ _ f) := by\n  ext; simp\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.leftComm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nP : Type uP\nQ : Type uQ\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Module A M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module A P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R Q\ninst✝¹ : Module R P\ninst✝ : IsScalarTower R A P\nm : M\np : P\nq : Q\n⊢ Eq ((TensorProduct.AlgebraTensorModule.leftComm R A M P Q) (TensorProduct.tmul A m (TensorProduct.tmul R p q))) (TensorProduct.tmul A p (TensorProduct.tmul R m q))","decl":"@[simp]\ntheorem leftComm_tmul (m : M) (p : P) (q : Q) :\n    leftComm R A M P Q (m ⊗ₜ (p ⊗ₜ q)) = p ⊗ₜ (m ⊗ₜ q) :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.leftComm_symm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nP : Type uP\nQ : Type uQ\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Module A M\ninst✝⁶ : IsScalarTower R A M\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module A P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R Q\ninst✝¹ : Module R P\ninst✝ : IsScalarTower R A P\nm : M\np : P\nq : Q\n⊢ Eq ((TensorProduct.AlgebraTensorModule.leftComm R A M P Q).symm (TensorProduct.tmul A p (TensorProduct.tmul R m q))) (TensorProduct.tmul A m (TensorProduct.tmul R p q))","decl":"@[simp]\ntheorem leftComm_symm_tmul (m : M) (p : P) (q : Q) :\n    (leftComm R A M P Q).symm (p ⊗ₜ (m ⊗ₜ q)) = m ⊗ₜ (p ⊗ₜ q) :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.rightComm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nP : Type uP\nQ : Type uQ\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring A\ninst✝⁸ : Algebra R A\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module A M\ninst✝⁴ : IsScalarTower R A M\ninst✝³ : AddCommMonoid P\ninst✝² : Module A P\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module R Q\nm : M\np : P\nq : Q\n⊢ Eq ((TensorProduct.AlgebraTensorModule.rightComm R A M P Q) (TensorProduct.tmul R (TensorProduct.tmul A m p) q)) (TensorProduct.tmul A (TensorProduct.tmul R m q) p)","decl":"@[simp]\ntheorem rightComm_tmul (m : M) (p : P) (q : Q) :\n    rightComm R A M P Q ((m ⊗ₜ p) ⊗ₜ q) = (m ⊗ₜ q) ⊗ₜ p :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.rightComm_symm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nP : Type uP\nQ : Type uQ\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring A\ninst✝⁸ : Algebra R A\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module A M\ninst✝⁴ : IsScalarTower R A M\ninst✝³ : AddCommMonoid P\ninst✝² : Module A P\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module R Q\nm : M\np : P\nq : Q\n⊢ Eq ((TensorProduct.AlgebraTensorModule.rightComm R A M P Q).symm (TensorProduct.tmul A (TensorProduct.tmul R m q) p)) (TensorProduct.tmul R (TensorProduct.tmul A m p) q)","decl":"@[simp]\ntheorem rightComm_symm_tmul (m : M) (p : P) (q : Q) :\n    (rightComm R A M P Q).symm ((m ⊗ₜ q) ⊗ₜ p) = (m ⊗ₜ p) ⊗ₜ q :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.tensorTensorTensorComm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : CommSemiring A\ninst✝¹² : Algebra R A\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\ninst✝⁹ : Module A M\ninst✝⁸ : IsScalarTower R A M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module A P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R Q\ninst✝¹ : Module R P\ninst✝ : IsScalarTower R A P\nm : M\nn : N\np : P\nq : Q\n⊢ Eq ((TensorProduct.AlgebraTensorModule.tensorTensorTensorComm R A M N P Q) (TensorProduct.tmul A (TensorProduct.tmul R m n) (TensorProduct.tmul R p q))) (TensorProduct.tmul R (TensorProduct.tmul A m p) (TensorProduct.tmul R n q))","decl":"@[simp]\ntheorem tensorTensorTensorComm_tmul (m : M) (n : N) (p : P) (q : Q) :\n    tensorTensorTensorComm R A M N P Q ((m ⊗ₜ n) ⊗ₜ (p ⊗ₜ q)) = (m ⊗ₜ p) ⊗ₜ (n ⊗ₜ q) :=\n  rfl\n\n"}
{"name":"TensorProduct.AlgebraTensorModule.tensorTensorTensorComm_symm_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type uR\nA : Type uA\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : CommSemiring A\ninst✝¹² : Algebra R A\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\ninst✝⁹ : Module A M\ninst✝⁸ : IsScalarTower R A M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : Module R N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module A P\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R Q\ninst✝¹ : Module R P\ninst✝ : IsScalarTower R A P\nm : M\nn : N\np : P\nq : Q\n⊢ Eq ((TensorProduct.AlgebraTensorModule.tensorTensorTensorComm R A M N P Q).symm (TensorProduct.tmul R (TensorProduct.tmul A m p) (TensorProduct.tmul R n q))) (TensorProduct.tmul A (TensorProduct.tmul R m n) (TensorProduct.tmul R p q))","decl":"@[simp]\ntheorem tensorTensorTensorComm_symm_tmul (m : M) (n : N) (p : P) (q : Q) :\n    (tensorTensorTensorComm R A M N P Q).symm ((m ⊗ₜ p) ⊗ₜ (n ⊗ₜ q)) = (m ⊗ₜ n) ⊗ₜ (p ⊗ₜ q) :=\n  rfl\n\n"}
{"name":"Submodule.baseChange_bot","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type u_1\nM : Type u_2\nA : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Submodule.baseChange A Bot.bot) Bot.bot","decl":"@[simp]\nlemma baseChange_bot : (⊥ : Submodule R M).baseChange A = ⊥ := by simp [baseChange]\n\n"}
{"name":"Submodule.baseChange_top","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type u_1\nM : Type u_2\nA : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Submodule.baseChange A Top.top) Top.top","decl":"@[simp]\nlemma baseChange_top : (⊤ : Submodule R M).baseChange A = ⊤ := by\n  rw [baseChange, map_top, eq_top_iff']\n  intro x\n  refine x.induction_on (by simp) (fun a y ↦ ?_) (fun _ _ ↦ Submodule.add_mem _)\n  rw [← mul_one a, ← smul_eq_mul, ← smul_tmul']\n  refine smul_mem _ _ (subset_span ?_)\n  simp\n\n"}
{"name":"Submodule.tmul_mem_baseChange_of_mem","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type u_1\nM : Type u_2\nA : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\na : A\nm : M\nhm : Membership.mem p m\n⊢ Membership.mem (Submodule.baseChange A p) (TensorProduct.tmul R a m)","decl":"variable {A p} in\nlemma tmul_mem_baseChange_of_mem (a : A) {m : M} (hm : m ∈ p) :\n    a ⊗ₜ[R] m ∈ p.baseChange A := by\n  rw [← mul_one a, ← smul_eq_mul, ← smul_tmul']\n  exact smul_mem (baseChange A p) a (subset_span ⟨m, hm, rfl⟩)\n\n"}
{"name":"Submodule.baseChange_span","module":"Mathlib.LinearAlgebra.TensorProduct.Tower","initialProofState":"R : Type u_1\nM : Type u_2\nA : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ Eq (Submodule.baseChange A (Submodule.span R s)) (Submodule.span A (Set.image (⇑((TensorProduct.mk R A M) 1)) s))","decl":"@[simp]\nlemma baseChange_span (s : Set M) :\n    (span R s).baseChange A = span A (TensorProduct.mk R A M 1 '' s) := by\n  simp only [baseChange, map_coe]\n  refine le_antisymm (span_le.mpr ?_) (span_mono <| Set.image_subset _ subset_span)\n  rintro - ⟨m : M, hm : m ∈ span R s, rfl⟩\n  apply span_induction (p := fun m' _ ↦ (1 : A) ⊗ₜ[R] m' ∈ span A (TensorProduct.mk R A M 1 '' s))\n    (hx := hm)\n  · intro m hm\n    exact subset_span ⟨m, hm, rfl⟩\n  · simp\n  · intro m₁ m₂ _ _ hm₁ hm₂\n    rw [tmul_add]\n    exact Submodule.add_mem _ hm₁ hm₂\n  · intro r m' _ hm'\n    rw [tmul_smul, ← one_smul A ((1 : A) ⊗ₜ[R] m'), ← smul_assoc]\n    exact smul_mem _ (r • 1) hm'\n\n"}
