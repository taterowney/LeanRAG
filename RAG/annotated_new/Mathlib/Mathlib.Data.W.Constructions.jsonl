{"name":"WType.Natα.succ.sizeOf_spec","module":"Mathlib.Data.W.Constructions","initialProofState":"⊢ Eq (SizeOf.sizeOf WType.Natα.succ) 1","decl":"/-- The constructors for the naturals -/\ninductive Natα : Type\n  | zero : Natα\n  | succ : Natα\n\n"}
{"name":"WType.Natα.zero.sizeOf_spec","module":"Mathlib.Data.W.Constructions","initialProofState":"⊢ Eq (SizeOf.sizeOf WType.Natα.zero) 1","decl":"/-- The constructors for the naturals -/\ninductive Natα : Type\n  | zero : Natα\n  | succ : Natα\n\n"}
{"name":"WType.leftInverse_nat","module":"Mathlib.Data.W.Constructions","initialProofState":"⊢ Function.LeftInverse WType.ofNat WType.toNat","decl":"theorem leftInverse_nat : Function.LeftInverse ofNat toNat\n  | WType.mk Natα.zero f => by\n    rw [toNat, ofNat]\n    congr\n    ext x\n    cases x\n  | WType.mk Natα.succ f => by\n    simp only [toNat, ofNat, leftInverse_nat (f ()), mk.injEq, heq_eq_eq, true_and]\n    rfl\n\n"}
{"name":"WType.rightInverse_nat","module":"Mathlib.Data.W.Constructions","initialProofState":"⊢ Function.RightInverse WType.ofNat WType.toNat","decl":"theorem rightInverse_nat : Function.RightInverse ofNat toNat\n  | Nat.zero => rfl\n  | Nat.succ n => by rw [ofNat, toNat, rightInverse_nat n]\n\n"}
{"name":"WType.NatαEquivPUnitSumPUnit_apply","module":"Mathlib.Data.W.Constructions","initialProofState":"c : WType.Natα\n⊢ Eq (WType.NatαEquivPUnitSumPUnit c) (WType.Natβ.match_1 (fun c => Sum PUnit.{u + 1} PUnit.{u_1 + 1}) c (fun _ => Sum.inl PUnit.unit) fun _ => Sum.inr PUnit.unit)","decl":"/-- `WType.Natα` is equivalent to `PUnit ⊕ PUnit`.\nThis is useful when considering the associated polynomial endofunctor.\n-/\n@[simps]\ndef NatαEquivPUnitSumPUnit : Natα ≃ PUnit.{u + 1} ⊕ PUnit where\n  toFun c :=\n    match c with\n    | Natα.zero => inl unit\n    | Natα.succ => inr unit\n  invFun b :=\n    match b with\n    | inl _ => Natα.zero\n    | inr _ => Natα.succ\n  left_inv c :=\n    match c with\n    | Natα.zero => rfl\n    | Natα.succ => rfl\n  right_inv b :=\n    match b with\n    | inl _ => rfl\n    | inr _ => rfl\n\n"}
{"name":"WType.NatαEquivPUnitSumPUnit_symm_apply","module":"Mathlib.Data.W.Constructions","initialProofState":"b : Sum PUnit.{u + 1} PUnit.{u_1 + 1}\n⊢ Eq (WType.NatαEquivPUnitSumPUnit.symm b) (WType.NatαEquivPUnitSumPUnit.match_1 (fun b => WType.Natα) b (fun val => WType.Natα.zero) fun val => WType.Natα.succ)","decl":"/-- `WType.Natα` is equivalent to `PUnit ⊕ PUnit`.\nThis is useful when considering the associated polynomial endofunctor.\n-/\n@[simps]\ndef NatαEquivPUnitSumPUnit : Natα ≃ PUnit.{u + 1} ⊕ PUnit where\n  toFun c :=\n    match c with\n    | Natα.zero => inl unit\n    | Natα.succ => inr unit\n  invFun b :=\n    match b with\n    | inl _ => Natα.zero\n    | inr _ => Natα.succ\n  left_inv c :=\n    match c with\n    | Natα.zero => rfl\n    | Natα.succ => rfl\n  right_inv b :=\n    match b with\n    | inl _ => rfl\n    | inr _ => rfl\n\n"}
{"name":"WType.Listα.cons.injEq","module":"Mathlib.Data.W.Constructions","initialProofState":"γ : Type u\na✝¹ a✝ : γ\n⊢ Eq (Eq (WType.Listα.cons a✝¹) (WType.Listα.cons a✝)) (Eq a✝¹ a✝)","decl":"/-- The constructors for lists.\nThere is \"one constructor `cons x` for each `x : γ`\",\nsince we view `List γ` as\n```\n| nil : List γ\n| cons x₀ : List γ → List γ\n| cons x₁ : List γ → List γ\n|   ⋮      γ many times\n```\n-/\ninductive Listα : Type u\n  | nil : Listα\n  | cons : γ → Listα\n\n"}
{"name":"WType.Listα.cons.inj","module":"Mathlib.Data.W.Constructions","initialProofState":"γ : Type u\na✝¹ a✝ : γ\nx✝ : Eq (WType.Listα.cons a✝¹) (WType.Listα.cons a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The constructors for lists.\nThere is \"one constructor `cons x` for each `x : γ`\",\nsince we view `List γ` as\n```\n| nil : List γ\n| cons x₀ : List γ → List γ\n| cons x₁ : List γ → List γ\n|   ⋮      γ many times\n```\n-/\ninductive Listα : Type u\n  | nil : Listα\n  | cons : γ → Listα\n\n"}
{"name":"WType.Listα.cons.sizeOf_spec","module":"Mathlib.Data.W.Constructions","initialProofState":"γ : Type u\ninst✝ : SizeOf γ\na✝ : γ\n⊢ Eq (SizeOf.sizeOf (WType.Listα.cons a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The constructors for lists.\nThere is \"one constructor `cons x` for each `x : γ`\",\nsince we view `List γ` as\n```\n| nil : List γ\n| cons x₀ : List γ → List γ\n| cons x₁ : List γ → List γ\n|   ⋮      γ many times\n```\n-/\ninductive Listα : Type u\n  | nil : Listα\n  | cons : γ → Listα\n\n"}
{"name":"WType.Listα.nil.sizeOf_spec","module":"Mathlib.Data.W.Constructions","initialProofState":"γ : Type u\ninst✝ : SizeOf γ\n⊢ Eq (SizeOf.sizeOf WType.Listα.nil) 1","decl":"/-- The constructors for lists.\nThere is \"one constructor `cons x` for each `x : γ`\",\nsince we view `List γ` as\n```\n| nil : List γ\n| cons x₀ : List γ → List γ\n| cons x₁ : List γ → List γ\n|   ⋮      γ many times\n```\n-/\ninductive Listα : Type u\n  | nil : Listα\n  | cons : γ → Listα\n\n"}
{"name":"WType.leftInverse_list","module":"Mathlib.Data.W.Constructions","initialProofState":"γ : Type u\n⊢ Function.LeftInverse (WType.ofList γ) (WType.toList γ)","decl":"theorem leftInverse_list : Function.LeftInverse (ofList γ) (toList _)\n  | WType.mk Listα.nil f => by\n    simp only [toList, ofList, mk.injEq, heq_eq_eq, true_and]\n    ext x\n    cases x\n  | WType.mk (Listα.cons x) f => by\n    simp only [toList, ofList, leftInverse_list (f PUnit.unit), mk.injEq, heq_eq_eq, true_and]\n    rfl\n\n"}
{"name":"WType.rightInverse_list","module":"Mathlib.Data.W.Constructions","initialProofState":"γ : Type u\n⊢ Function.RightInverse (WType.ofList γ) (WType.toList γ)","decl":"theorem rightInverse_list : Function.RightInverse (ofList γ) (toList _)\n  | List.nil => rfl\n  | List.cons hd tl => by simp [rightInverse_list tl]\n\n"}
