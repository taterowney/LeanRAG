{"name":"Finset.box_zero","module":"Mathlib.Order.Interval.Finset.Box","initialProofState":"α : Type u_1\ninst✝² : OrderedRing α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\n⊢ Eq (Finset.box 0) (Singleton.singleton 0)","decl":"@[simp] lemma box_zero : (box 0 : Finset α) = {0} := by simp [box]\n\n"}
{"name":"Finset.box_succ_eq_sdiff","module":"Mathlib.Order.Interval.Finset.Box","initialProofState":"α : Type u_1\ninst✝² : OrderedRing α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\nn : Nat\n⊢ Eq (Finset.box (HAdd.hAdd n 1)) (SDiff.sdiff (Finset.Icc (Neg.neg ↑n.succ) ↑n.succ) (Finset.Icc (Neg.neg ↑n) ↑n))","decl":"lemma box_succ_eq_sdiff (n : ℕ) :\n    box (n + 1) = Icc (-n.succ : α) n.succ \\ Icc (-n) n := by\n  rw [box, Icc_neg_mono.disjointed_add_one]\n  simp only [Nat.cast_add_one, Nat.succ_eq_add_one]\n\n"}
{"name":"Finset.disjoint_box_succ_prod","module":"Mathlib.Order.Interval.Finset.Box","initialProofState":"α : Type u_1\ninst✝² : OrderedRing α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\nn : Nat\n⊢ Disjoint (Finset.box (HAdd.hAdd n 1)) (Finset.Icc (Neg.neg ↑n) ↑n)","decl":"lemma disjoint_box_succ_prod (n : ℕ) : Disjoint (box (n + 1)) (Icc (-n : α) n) := by\n  rw [box_succ_eq_sdiff]; exact disjoint_sdiff_self_left\n\n"}
{"name":"Finset.box_succ_union_prod","module":"Mathlib.Order.Interval.Finset.Box","initialProofState":"α : Type u_1\ninst✝² : OrderedRing α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\nn : Nat\n⊢ Eq (Union.union (Finset.box (HAdd.hAdd n 1)) (Finset.Icc (Neg.neg ↑n) ↑n)) (Finset.Icc (Neg.neg ↑n.succ) ↑n.succ)","decl":"@[simp] lemma box_succ_union_prod (n : ℕ) :\n    box (n + 1) ∪ Icc (-n : α) n = Icc (-n.succ : α) n.succ :=\n  Icc_neg_mono.disjointed_add_one_sup _\n\n"}
{"name":"Finset.box_succ_disjUnion","module":"Mathlib.Order.Interval.Finset.Box","initialProofState":"α : Type u_1\ninst✝² : OrderedRing α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\nn : Nat\n⊢ Eq ((Finset.box (HAdd.hAdd n 1)).disjUnion (Finset.Icc (Neg.neg ↑n) ↑n) ⋯) (Finset.Icc (Neg.neg ↑n.succ) ↑n.succ)","decl":"lemma box_succ_disjUnion (n : ℕ) :\n    (box (n + 1)).disjUnion (Icc (-n : α) n) (disjoint_box_succ_prod _) =\n      Icc (-n.succ : α) n.succ := by rw [disjUnion_eq_union, box_succ_union_prod]\n\n"}
{"name":"Finset.zero_mem_box","module":"Mathlib.Order.Interval.Finset.Box","initialProofState":"α : Type u_1\ninst✝² : OrderedRing α\ninst✝¹ : LocallyFiniteOrder α\nn : Nat\ninst✝ : DecidableEq α\n⊢ Iff (Membership.mem (Finset.box n) 0) (Eq n 0)","decl":"@[simp] lemma zero_mem_box : (0 : α) ∈ box n ↔ n = 0 := by cases n <;> simp [box_succ_eq_sdiff]\n\n"}
{"name":"Finset.eq_zero_iff_eq_zero_of_mem_box","module":"Mathlib.Order.Interval.Finset.Box","initialProofState":"α : Type u_1\ninst✝² : OrderedRing α\ninst✝¹ : LocallyFiniteOrder α\nn : Nat\ninst✝ : DecidableEq α\nx : α\nhx : Membership.mem (Finset.box n) x\n⊢ Iff (Eq x 0) (Eq n 0)","decl":"lemma eq_zero_iff_eq_zero_of_mem_box  {x : α} (hx : x ∈ box n) : x = 0 ↔ n = 0 :=\n  ⟨zero_mem_box.mp ∘ (· ▸ hx), fun hn ↦ by rwa [hn, box_zero, mem_singleton] at hx⟩\n\n"}
{"name":"Prod.card_box_succ","module":"Mathlib.Order.Interval.Finset.Box","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁶ : OrderedRing α\ninst✝⁵ : OrderedRing β\ninst✝⁴ : LocallyFiniteOrder α\ninst✝³ : LocallyFiniteOrder β\ninst✝² : DecidableEq α\ninst✝¹ : DecidableEq β\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nn : Nat\n⊢ Eq (Finset.box (HAdd.hAdd n 1)).card (HSub.hSub (HMul.hMul (Finset.Icc (Neg.neg ↑n.succ) ↑n.succ).card (Finset.Icc (Neg.neg ↑n.succ) ↑n.succ).card) (HMul.hMul (Finset.Icc (Neg.neg ↑n) ↑n).card (Finset.Icc (Neg.neg ↑n) ↑n).card))","decl":"@[simp] lemma card_box_succ (n : ℕ) :\n    #(box (n + 1) : Finset (α × β)) =\n      #(Icc (-n.succ : α) n.succ) * #(Icc (-n.succ : β) n.succ) -\n        #(Icc (-n : α) n) * #(Icc (-n : β) n) := by\n  rw [box_succ_eq_sdiff, card_sdiff (Icc_neg_mono n.le_succ), Finset.card_Icc_prod,\n    Finset.card_Icc_prod]\n  rfl\n\n"}
{"name":"Int.card_box","module":"Mathlib.Order.Interval.Finset.Box","initialProofState":"n : Nat\na✝ : Ne n 0\n⊢ Eq (Finset.box n).card (HMul.hMul 8 n)","decl":"lemma card_box : ∀ {n}, n ≠ 0 → #(box n : Finset (ℤ × ℤ)) = 8 * n\n  | n + 1, _ => by\n    simp_rw [Prod.card_box_succ, card_Icc, sub_neg_eq_add]\n    norm_cast\n    refine tsub_eq_of_eq_add ?_\n    zify\n    ring\n\n"}
{"name":"Int.mem_box","module":"Mathlib.Order.Interval.Finset.Box","initialProofState":"x : Prod Int Int\nn : Nat\n⊢ Iff (Membership.mem (Finset.box n) x) (Eq (Max.max x.1.natAbs x.2.natAbs) n)","decl":"@[simp] lemma mem_box : ∀ {n}, x ∈ box n ↔ max x.1.natAbs x.2.natAbs = n\n  | 0 => by simp [Prod.ext_iff]\n  | n + 1 => by\n    simp [box_succ_eq_sdiff, Prod.le_def]\n    omega\n\n-- TODO: Can this be generalised to locally finite archimedean ordered rings?\n"}
{"name":"Int.existsUnique_mem_box","module":"Mathlib.Order.Interval.Finset.Box","initialProofState":"x : Prod Int Int\n⊢ ExistsUnique fun n => Membership.mem (Finset.box n) x","decl":"lemma existsUnique_mem_box (x : ℤ × ℤ) : ∃! n : ℕ, x ∈ box n := by\n  use max x.1.natAbs x.2.natAbs; simp only [mem_box, and_self_iff, forall_eq']\n\n"}
