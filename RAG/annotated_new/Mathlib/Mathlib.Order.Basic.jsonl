{"name":"le_trans'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : LE.le b c\na✝ : LE.le a b\n⊢ LE.le a c","decl":"theorem le_trans' : b ≤ c → a ≤ b → a ≤ c :=\n  flip le_trans\n\n"}
{"name":"lt_trans'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : LT.lt b c\na✝ : LT.lt a b\n⊢ LT.lt a c","decl":"theorem lt_trans' : b < c → a < b → a < c :=\n  flip lt_trans\n\n"}
{"name":"lt_of_le_of_lt'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : LE.le b c\na✝ : LT.lt a b\n⊢ LT.lt a c","decl":"theorem lt_of_le_of_lt' : b ≤ c → a < b → a < c :=\n  flip lt_of_lt_of_le\n\n"}
{"name":"lt_of_lt_of_le'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : LT.lt b c\na✝ : LE.le a b\n⊢ LT.lt a c","decl":"theorem lt_of_lt_of_le' : b < c → a ≤ b → a < c :=\n  flip lt_of_le_of_lt\n\n"}
{"name":"not_lt_iff_not_le_or_ge","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b : α\n⊢ Iff (Not (LT.lt a b)) (Or (Not (LE.le a b)) (LE.le b a))","decl":"theorem not_lt_iff_not_le_or_ge : ¬a < b ↔ ¬a ≤ b ∨ b ≤ a := by\n  rw [lt_iff_le_not_le, Classical.not_and_iff_or_not_not, Classical.not_not]\n\n"}
{"name":"ge_antisymm","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\na✝¹ : LE.le a b\na✝ : LE.le b a\n⊢ Eq b a","decl":"theorem ge_antisymm : a ≤ b → b ≤ a → b = a :=\n  flip le_antisymm\n\n"}
{"name":"lt_of_le_of_ne'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\na✝¹ : LE.le a b\na✝ : Ne b a\n⊢ LT.lt a b","decl":"theorem lt_of_le_of_ne' : a ≤ b → b ≠ a → a < b := fun h₁ h₂ ↦ lt_of_le_of_ne h₁ h₂.symm\n\n"}
{"name":"Ne.lt_of_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\na✝¹ : Ne a b\na✝ : LE.le a b\n⊢ LT.lt a b","decl":"theorem Ne.lt_of_le : a ≠ b → a ≤ b → a < b :=\n  flip lt_of_le_of_ne\n\n"}
{"name":"Ne.lt_of_le'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\na✝¹ : Ne b a\na✝ : LE.le a b\n⊢ LT.lt a b","decl":"theorem Ne.lt_of_le' : b ≠ a → a ≤ b → a < b :=\n  flip lt_of_le_of_ne'\n\n"}
{"name":"LE.ext_iff","module":"Mathlib.Order.Basic","initialProofState":"α : Type u\nx y : LE α\n⊢ Iff (Eq x y) (Eq LE.le LE.le)","decl":"attribute [ext] LE\n\n"}
{"name":"LE.ext","module":"Mathlib.Order.Basic","initialProofState":"α : Type u\nx y : LE α\nle : Eq LE.le LE.le\n⊢ Eq x y","decl":"attribute [ext] LE\n\n"}
{"name":"LE.le.trans","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\na✝¹ : LE.le a b\na✝ : LE.le b c\n⊢ LE.le a c","decl":"alias LE.le.trans := le_trans\n\n"}
{"name":"LE.le.trans'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : LE.le b c\na✝ : LE.le a b\n⊢ LE.le a c","decl":"alias LE.le.trans' := le_trans'\n\n"}
{"name":"LE.le.trans_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : LE.le a b\nhbc : LT.lt b c\n⊢ LT.lt a c","decl":"alias LE.le.trans_lt := lt_of_le_of_lt\n\n"}
{"name":"LE.le.trans_lt'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : LE.le b c\na✝ : LT.lt a b\n⊢ LT.lt a c","decl":"alias LE.le.trans_lt' := lt_of_le_of_lt'\n\n"}
{"name":"LE.le.antisymm","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\na✝¹ : LE.le a b\na✝ : LE.le b a\n⊢ Eq a b","decl":"alias LE.le.antisymm := le_antisymm\n\n"}
{"name":"LE.le.antisymm'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\na✝¹ : LE.le a b\na✝ : LE.le b a\n⊢ Eq b a","decl":"alias LE.le.antisymm' := ge_antisymm\n\n"}
{"name":"LE.le.lt_of_ne","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\na✝¹ : LE.le a b\na✝ : Ne a b\n⊢ LT.lt a b","decl":"alias LE.le.lt_of_ne := lt_of_le_of_ne\n\n"}
{"name":"LE.le.lt_of_ne'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\na✝¹ : LE.le a b\na✝ : Ne b a\n⊢ LT.lt a b","decl":"alias LE.le.lt_of_ne' := lt_of_le_of_ne'\n\n"}
{"name":"LE.le.lt_of_not_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LE.le a b\nhba : Not (LE.le b a)\n⊢ LT.lt a b","decl":"alias LE.le.lt_of_not_le := lt_of_le_not_le\n\n"}
{"name":"LE.le.lt_or_eq","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\na✝ : LE.le a b\n⊢ Or (LT.lt a b) (Eq a b)","decl":"alias LE.le.lt_or_eq := lt_or_eq_of_le\n\n"}
{"name":"LE.le.lt_or_eq_dec","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\na b : α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nhab : LE.le a b\n⊢ Or (LT.lt a b) (Eq a b)","decl":"alias LE.le.lt_or_eq_dec := Decidable.lt_or_eq_of_le\n\n"}
{"name":"LT.lt.le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LT.lt a b\n⊢ LE.le a b","decl":"alias LT.lt.le := le_of_lt\n\n"}
{"name":"LT.lt.trans","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : LT.lt a b\nhbc : LT.lt b c\n⊢ LT.lt a c","decl":"alias LT.lt.trans := lt_trans\n\n"}
{"name":"LT.lt.trans'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : LT.lt b c\na✝ : LT.lt a b\n⊢ LT.lt a c","decl":"alias LT.lt.trans' := lt_trans'\n\n"}
{"name":"LT.lt.trans_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : LT.lt a b\nhbc : LE.le b c\n⊢ LT.lt a c","decl":"alias LT.lt.trans_le := lt_of_lt_of_le\n\n"}
{"name":"LT.lt.trans_le'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : LT.lt b c\na✝ : LE.le a b\n⊢ LT.lt a c","decl":"alias LT.lt.trans_le' := lt_of_lt_of_le'\n\n"}
{"name":"LT.lt.ne","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ Ne a b","decl":"alias LT.lt.ne := ne_of_lt\n\n"}
{"name":"LT.lt.asymm","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ Not (LT.lt b a)","decl":"alias LT.lt.asymm := lt_asymm\n\n"}
{"name":"LT.lt.not_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ Not (LT.lt b a)","decl":"alias LT.lt.not_lt := lt_asymm\n\n"}
{"name":"Eq.le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : Eq a b\n⊢ LE.le a b","decl":"alias Eq.le := le_of_eq\n\n-- Porting note: no `decidable_classical` linter\n-- attribute [nolint decidable_classical] LE.le.lt_or_eq_dec\n\n"}
{"name":"lt_self_iff_false","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\nx : α\n⊢ Iff (LT.lt x x) False","decl":"@[simp]\ntheorem lt_self_iff_false (x : α) : x < x ↔ False :=\n  ⟨lt_irrefl x, False.elim⟩\n\n"}
{"name":"le_of_le_of_eq'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : LE.le b c\na✝ : Eq a b\n⊢ LE.le a c","decl":"theorem le_of_le_of_eq' : b ≤ c → a = b → a ≤ c :=\n  flip le_of_eq_of_le\n\n"}
{"name":"le_of_eq_of_le'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : Eq b c\na✝ : LE.le a b\n⊢ LE.le a c","decl":"theorem le_of_eq_of_le' : b = c → a ≤ b → a ≤ c :=\n  flip le_of_le_of_eq\n\n"}
{"name":"lt_of_lt_of_eq'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : LT.lt b c\na✝ : Eq a b\n⊢ LT.lt a c","decl":"theorem lt_of_lt_of_eq' : b < c → a = b → a < c :=\n  flip lt_of_eq_of_lt\n\n"}
{"name":"lt_of_eq_of_lt'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : Eq b c\na✝ : LT.lt a b\n⊢ LT.lt a c","decl":"theorem lt_of_eq_of_lt' : b = c → a < b → a < c :=\n  flip lt_of_lt_of_eq\n\n"}
{"name":"LE.le.trans_eq","module":"Mathlib.Order.Basic","initialProofState":"α : Type u\na b c : α\ninst✝ : LE α\nh₁ : LE.le a b\nh₂ : Eq b c\n⊢ LE.le a c","decl":"alias LE.le.trans_eq := le_of_le_of_eq\n\n"}
{"name":"LE.le.trans_eq'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : LE.le b c\na✝ : Eq a b\n⊢ LE.le a c","decl":"alias LE.le.trans_eq' := le_of_le_of_eq'\n\n"}
{"name":"LT.lt.trans_eq","module":"Mathlib.Order.Basic","initialProofState":"α : Type u\na b c : α\ninst✝ : LT α\nh₁ : LT.lt a b\nh₂ : Eq b c\n⊢ LT.lt a c","decl":"alias LT.lt.trans_eq := lt_of_lt_of_eq\n\n"}
{"name":"LT.lt.trans_eq'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : LT.lt b c\na✝ : Eq a b\n⊢ LT.lt a c","decl":"alias LT.lt.trans_eq' := lt_of_lt_of_eq'\n\n"}
{"name":"Eq.trans_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u\na b c : α\ninst✝ : LE α\nh₁ : Eq a b\nh₂ : LE.le b c\n⊢ LE.le a c","decl":"alias Eq.trans_le := le_of_eq_of_le\n\n"}
{"name":"Eq.trans_ge","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : Eq b c\na✝ : LE.le a b\n⊢ LE.le a c","decl":"alias Eq.trans_ge := le_of_eq_of_le'\n\n"}
{"name":"Eq.trans_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u\na b c : α\ninst✝ : LT α\nh₁ : Eq a b\nh₂ : LT.lt b c\n⊢ LT.lt a c","decl":"alias Eq.trans_lt := lt_of_eq_of_lt\n\n"}
{"name":"Eq.trans_gt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b c : α\na✝¹ : Eq b c\na✝ : LT.lt a b\n⊢ LT.lt a c","decl":"alias Eq.trans_gt := lt_of_eq_of_lt'\n\n"}
{"name":"Eq.ge","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\nx y : α\nh : Eq x y\n⊢ LE.le y x","decl":"/-- If `x = y` then `y ≤ x`. Note: this lemma uses `y ≤ x` instead of `x ≥ y`, because `le` is used\nalmost exclusively in mathlib. -/\nprotected theorem ge (h : x = y) : y ≤ x :=\n  h.symm.le\n\n"}
{"name":"Eq.not_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\nx y : α\nh : Eq x y\n⊢ Not (LT.lt x y)","decl":"theorem not_lt (h : x = y) : ¬x < y := fun h' ↦ h'.ne h\n\n"}
{"name":"Eq.not_gt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\nx y : α\nh : Eq x y\n⊢ Not (LT.lt y x)","decl":"theorem not_gt (h : x = y) : ¬y < x :=\n  h.symm.not_lt\n\n"}
{"name":"le_of_subsingleton","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\na b : α\ninst✝ : Subsingleton α\n⊢ LE.le a b","decl":"@[simp] lemma le_of_subsingleton [Subsingleton α] : a ≤ b := (Subsingleton.elim a b).le\n\n-- Making this a @[simp] lemma causes confluences problems downstream.\n"}
{"name":"not_lt_of_subsingleton","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\na b : α\ninst✝ : Subsingleton α\n⊢ Not (LT.lt a b)","decl":"lemma not_lt_of_subsingleton [Subsingleton α] : ¬a < b := (Subsingleton.elim a b).not_lt\n\n"}
{"name":"LE.le.ge","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\nx y : α\nh : LE.le x y\n⊢ GE.ge y x","decl":"protected theorem ge [LE α] {x y : α} (h : x ≤ y) : y ≥ x :=\n  h\n\n"}
{"name":"LE.le.lt_iff_ne","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Iff (LT.lt a b) (Ne a b)","decl":"theorem lt_iff_ne (h : a ≤ b) : a < b ↔ a ≠ b :=\n  ⟨fun h ↦ h.ne, h.lt_of_ne⟩\n\n"}
{"name":"LE.le.gt_iff_ne","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Iff (LT.lt a b) (Ne b a)","decl":"theorem gt_iff_ne (h : a ≤ b) : a < b ↔ b ≠ a :=\n  ⟨fun h ↦ h.ne.symm, h.lt_of_ne'⟩\n\n"}
{"name":"LE.le.not_lt_iff_eq","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Iff (Not (LT.lt a b)) (Eq a b)","decl":"theorem not_lt_iff_eq (h : a ≤ b) : ¬a < b ↔ a = b :=\n  h.lt_iff_ne.not_left\n\n"}
{"name":"LE.le.not_gt_iff_eq","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Iff (Not (LT.lt a b)) (Eq b a)","decl":"theorem not_gt_iff_eq (h : a ≤ b) : ¬a < b ↔ b = a :=\n  h.gt_iff_ne.not_left\n\n"}
{"name":"LE.le.le_iff_eq","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Iff (LE.le b a) (Eq b a)","decl":"theorem le_iff_eq (h : a ≤ b) : b ≤ a ↔ b = a :=\n  ⟨fun h' ↦ h'.antisymm h, Eq.le⟩\n\n"}
{"name":"LE.le.ge_iff_eq","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Iff (LE.le b a) (Eq a b)","decl":"theorem ge_iff_eq (h : a ≤ b) : b ≤ a ↔ a = b :=\n  ⟨h.antisymm, Eq.ge⟩\n\n"}
{"name":"LE.le.lt_or_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nc : α\n⊢ Or (LT.lt a c) (LE.le c b)","decl":"theorem lt_or_le [LinearOrder α] {a b : α} (h : a ≤ b) (c : α) : a < c ∨ c ≤ b :=\n  ((lt_or_ge a c).imp id) fun hc ↦ le_trans hc h\n\n"}
{"name":"LE.le.le_or_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nc : α\n⊢ Or (LE.le a c) (LT.lt c b)","decl":"theorem le_or_lt [LinearOrder α] {a b : α} (h : a ≤ b) (c : α) : a ≤ c ∨ c < b :=\n  ((le_or_gt a c).imp id) fun hc ↦ lt_of_lt_of_le hc h\n\n"}
{"name":"LE.le.le_or_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nc : α\n⊢ Or (LE.le a c) (LE.le c b)","decl":"theorem le_or_le [LinearOrder α] {a b : α} (h : a ≤ b) (c : α) : a ≤ c ∨ c ≤ b :=\n  (h.le_or_lt c).elim Or.inl fun h ↦ Or.inr <| le_of_lt h\n\n"}
{"name":"LT.lt.gt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LT α\nx y : α\nh : LT.lt x y\n⊢ GT.gt y x","decl":"protected theorem gt [LT α] {x y : α} (h : x < y) : y > x :=\n  h\n\n"}
{"name":"LT.lt.false","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\nx : α\na✝ : LT.lt x x\n⊢ False","decl":"protected theorem false [Preorder α] {x : α} : x < x → False :=\n  lt_irrefl x\n\n"}
{"name":"LT.lt.ne'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\nx y : α\nh : LT.lt x y\n⊢ Ne y x","decl":"theorem ne' [Preorder α] {x y : α} (h : x < y) : y ≠ x :=\n  h.ne.symm\n\n"}
{"name":"LT.lt.lt_or_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx y : α\nh : LT.lt x y\nz : α\n⊢ Or (LT.lt x z) (LT.lt z y)","decl":"theorem lt_or_lt [LinearOrder α] {x y : α} (h : x < y) (z : α) : x < z ∨ z < y :=\n  (lt_or_ge z y).elim Or.inr fun hz ↦ Or.inl <| h.trans_le hz\n\n"}
{"name":"GE.ge.le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\nx y : α\nh : GE.ge x y\n⊢ LE.le y x","decl":"protected theorem GE.ge.le [LE α] {x y : α} (h : x ≥ y) : y ≤ x :=\n  h\n\n-- see Note [nolint_ge]\n-- Porting note: linter not found @[nolint ge_or_gt]\n"}
{"name":"GT.gt.lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LT α\nx y : α\nh : GT.gt x y\n⊢ LT.lt y x","decl":"protected theorem GT.gt.lt [LT α] {x y : α} (h : x > y) : y < x :=\n  h\n\n-- see Note [nolint_ge]\n-- Porting note: linter not found @[nolint ge_or_gt]\n"}
{"name":"ge_of_eq","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b : α\nh : Eq a b\n⊢ GE.ge a b","decl":"theorem ge_of_eq [Preorder α] {a b : α} (h : a = b) : a ≥ b :=\n  h.ge\n\n"}
{"name":"ne_of_not_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b : α\nh : Not (LE.le a b)\n⊢ Ne a b","decl":"theorem ne_of_not_le [Preorder α] {a b : α} (h : ¬a ≤ b) : a ≠ b := fun hab ↦ h (le_of_eq hab)\n\n"}
{"name":"Decidable.le_iff_eq_or_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\na b : α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\n⊢ Iff (LE.le a b) (Or (Eq a b) (LT.lt a b))","decl":"protected theorem Decidable.le_iff_eq_or_lt [DecidableRel (α := α) (· ≤ ·)] :\n    a ≤ b ↔ a = b ∨ a < b :=\n  Decidable.le_iff_lt_or_eq.trans or_comm\n\n"}
{"name":"le_iff_eq_or_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (LE.le a b) (Or (Eq a b) (LT.lt a b))","decl":"theorem le_iff_eq_or_lt : a ≤ b ↔ a = b ∨ a < b := le_iff_lt_or_eq.trans or_comm\n\n"}
{"name":"lt_iff_le_and_ne","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (LT.lt a b) (And (LE.le a b) (Ne a b))","decl":"theorem lt_iff_le_and_ne : a < b ↔ a ≤ b ∧ a ≠ b :=\n  ⟨fun h ↦ ⟨le_of_lt h, ne_of_lt h⟩, fun ⟨h1, h2⟩ ↦ h1.lt_of_ne h2⟩\n\n"}
{"name":"eq_iff_not_lt_of_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nhab : LE.le a b\n⊢ Iff (Eq a b) (Not (LT.lt a b))","decl":"lemma eq_iff_not_lt_of_le (hab : a ≤ b) : a = b ↔ ¬ a < b := by simp [hab, lt_iff_le_and_ne]\n\n"}
{"name":"LE.le.eq_iff_not_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nhab : LE.le a b\n⊢ Iff (Eq a b) (Not (LT.lt a b))","decl":"alias LE.le.eq_iff_not_lt := eq_iff_not_lt_of_le\n\n-- See Note [decidable namespace]\n"}
{"name":"Decidable.eq_iff_le_not_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\na b : α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\n⊢ Iff (Eq a b) (And (LE.le a b) (Not (LT.lt a b)))","decl":"protected theorem Decidable.eq_iff_le_not_lt [DecidableRel (α := α) (· ≤ ·)] :\n    a = b ↔ a ≤ b ∧ ¬a < b :=\n  ⟨fun h ↦ ⟨h.le, h ▸ lt_irrefl _⟩, fun ⟨h₁, h₂⟩ ↦\n    h₁.antisymm <| Decidable.byContradiction fun h₃ ↦ h₂ (h₁.lt_of_not_le h₃)⟩\n\n"}
{"name":"eq_iff_le_not_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (Eq a b) (And (LE.le a b) (Not (LT.lt a b)))","decl":"theorem eq_iff_le_not_lt : a = b ↔ a ≤ b ∧ ¬a < b :=\n  haveI := Classical.dec\n  Decidable.eq_iff_le_not_lt\n\n"}
{"name":"eq_or_lt_of_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Or (Eq a b) (LT.lt a b)","decl":"theorem eq_or_lt_of_le (h : a ≤ b) : a = b ∨ a < b := h.lt_or_eq.symm\n"}
{"name":"eq_or_gt_of_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Or (Eq b a) (LT.lt a b)","decl":"theorem eq_or_gt_of_le (h : a ≤ b) : b = a ∨ a < b := h.lt_or_eq.symm.imp Eq.symm id\n"}
{"name":"gt_or_eq_of_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Or (LT.lt a b) (Eq b a)","decl":"theorem gt_or_eq_of_le (h : a ≤ b) : a < b ∨ b = a := (eq_or_gt_of_le h).symm\n\n"}
{"name":"LE.le.eq_or_lt_dec","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\na b : α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nhab : LE.le a b\n⊢ Or (Eq a b) (LT.lt a b)","decl":"alias LE.le.eq_or_lt_dec := Decidable.eq_or_lt_of_le\n"}
{"name":"LE.le.eq_or_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Or (Eq a b) (LT.lt a b)","decl":"alias LE.le.eq_or_lt := eq_or_lt_of_le\n"}
{"name":"LE.le.eq_or_gt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Or (Eq b a) (LT.lt a b)","decl":"alias LE.le.eq_or_gt := eq_or_gt_of_le\n"}
{"name":"LE.le.gt_or_eq","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Or (LT.lt a b) (Eq b a)","decl":"alias LE.le.gt_or_eq := gt_or_eq_of_le\n\n-- Porting note: no `decidable_classical` linter\n-- attribute [nolint decidable_classical] LE.le.eq_or_lt_dec\n\n"}
{"name":"eq_of_le_of_not_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nhab : LE.le a b\nhba : Not (LT.lt a b)\n⊢ Eq a b","decl":"theorem eq_of_le_of_not_lt (hab : a ≤ b) (hba : ¬a < b) : a = b := hab.eq_or_lt.resolve_right hba\n"}
{"name":"eq_of_ge_of_not_gt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nhab : LE.le a b\nhba : Not (LT.lt a b)\n⊢ Eq b a","decl":"theorem eq_of_ge_of_not_gt (hab : a ≤ b) (hba : ¬a < b) : b = a := (eq_of_le_of_not_lt hab hba).symm\n\n"}
{"name":"LE.le.eq_of_not_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nhab : LE.le a b\nhba : Not (LT.lt a b)\n⊢ Eq a b","decl":"alias LE.le.eq_of_not_lt := eq_of_le_of_not_lt\n"}
{"name":"LE.le.eq_of_not_gt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nhab : LE.le a b\nhba : Not (LT.lt a b)\n⊢ Eq b a","decl":"alias LE.le.eq_of_not_gt := eq_of_ge_of_not_gt\n\n"}
{"name":"Ne.le_iff_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : Ne a b\n⊢ Iff (LE.le a b) (LT.lt a b)","decl":"theorem Ne.le_iff_lt (h : a ≠ b) : a ≤ b ↔ a < b := ⟨fun h' ↦ lt_of_le_of_ne h' h, fun h ↦ h.le⟩\n\n"}
{"name":"Ne.not_le_or_not_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nh : Ne a b\n⊢ Or (Not (LE.le a b)) (Not (LE.le b a))","decl":"theorem Ne.not_le_or_not_le (h : a ≠ b) : ¬a ≤ b ∨ ¬b ≤ a := not_and_or.1 <| le_antisymm_iff.not.1 h\n\n-- See Note [decidable namespace]\n"}
{"name":"Decidable.ne_iff_lt_iff_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\na b : α\ninst✝ : DecidableEq α\n⊢ Iff (Iff (Ne a b) (LT.lt a b)) (LE.le a b)","decl":"protected theorem Decidable.ne_iff_lt_iff_le [DecidableEq α] : (a ≠ b ↔ a < b) ↔ a ≤ b :=\n  ⟨fun h ↦ Decidable.byCases le_of_eq (le_of_lt ∘ h.mp), fun h ↦ ⟨lt_of_le_of_ne h, ne_of_lt⟩⟩\n\n"}
{"name":"ne_iff_lt_iff_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (Iff (Ne a b) (LT.lt a b)) (LE.le a b)","decl":"@[simp]\ntheorem ne_iff_lt_iff_le : (a ≠ b ↔ a < b) ↔ a ≤ b :=\n  haveI := Classical.dec\n  Decidable.ne_iff_lt_iff_le\n\n"}
{"name":"min_def'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Min.min a b) (ite (LE.le b a) b a)","decl":"theorem min_def' [LinearOrder α] (a b : α) : min a b = if b ≤ a then b else a := by\n  rw [min_def]\n  rcases lt_trichotomy a b with (lt | eq | gt)\n  · rw [if_pos lt.le, if_neg (not_le.mpr lt)]\n  · rw [if_pos eq.le, if_pos eq.ge, eq]\n  · rw [if_neg (not_le.mpr gt.gt), if_pos gt.le]\n\n-- Variant of `min_def` with the branches reversed.\n-- This is sometimes useful as it used to be the default.\n"}
{"name":"max_def'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Max.max a b) (ite (LE.le b a) a b)","decl":"theorem max_def' [LinearOrder α] (a b : α) : max a b = if b ≤ a then a else b := by\n  rw [max_def]\n  rcases lt_trichotomy a b with (lt | eq | gt)\n  · rw [if_pos lt.le, if_neg (not_le.mpr lt)]\n  · rw [if_pos eq.le, if_pos eq.ge, eq]\n  · rw [if_neg (not_le.mpr gt.gt), if_pos gt.le]\n\n"}
{"name":"lt_of_not_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : Not (LE.le b a)\n⊢ LT.lt a b","decl":"theorem lt_of_not_le [LinearOrder α] {a b : α} (h : ¬b ≤ a) : a < b :=\n  ((le_total _ _).resolve_right h).lt_of_not_le h\n\n"}
{"name":"lt_iff_not_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx y : α\n⊢ Iff (LT.lt x y) (Not (LE.le y x))","decl":"theorem lt_iff_not_le [LinearOrder α] {x y : α} : x < y ↔ ¬y ≤ x :=\n  ⟨not_le_of_lt, lt_of_not_le⟩\n\n"}
{"name":"Ne.lt_or_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx y : α\nh : Ne x y\n⊢ Or (LT.lt x y) (LT.lt y x)","decl":"theorem Ne.lt_or_lt [LinearOrder α] {x y : α} (h : x ≠ y) : x < y ∨ y < x :=\n  lt_or_gt_of_ne h\n\n"}
{"name":"lt_or_lt_iff_ne","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx y : α\n⊢ Iff (Or (LT.lt x y) (LT.lt y x)) (Ne x y)","decl":"/-- A version of `ne_iff_lt_or_gt` with LHS and RHS reversed. -/\n@[simp]\ntheorem lt_or_lt_iff_ne [LinearOrder α] {x y : α} : x < y ∨ y < x ↔ x ≠ y :=\n  ne_iff_lt_or_gt.symm\n\n"}
{"name":"not_lt_iff_eq_or_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Not (LT.lt a b)) (Or (Eq a b) (LT.lt b a))","decl":"theorem not_lt_iff_eq_or_lt [LinearOrder α] {a b : α} : ¬a < b ↔ a = b ∨ b < a :=\n  not_lt.trans <| Decidable.le_iff_eq_or_lt.trans <| or_congr eq_comm Iff.rfl\n\n"}
{"name":"exists_ge_of_linear","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\n⊢ Exists fun c => And (LE.le a c) (LE.le b c)","decl":"theorem exists_ge_of_linear [LinearOrder α] (a b : α) : ∃ c, a ≤ c ∧ b ≤ c :=\n  match le_total a b with\n  | Or.inl h => ⟨_, h, le_rfl⟩\n  | Or.inr h => ⟨_, le_rfl, h⟩\n\n"}
{"name":"exists_forall_ge_and","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\np q : α → Prop\na✝¹ : Exists fun i => ∀ (j : α), GE.ge j i → p j\na✝ : Exists fun i => ∀ (j : α), GE.ge j i → q j\n⊢ Exists fun i => ∀ (j : α), GE.ge j i → And (p j) (q j)","decl":"lemma exists_forall_ge_and [LinearOrder α] {p q : α → Prop} :\n    (∃ i, ∀ j ≥ i, p j) → (∃ i, ∀ j ≥ i, q j) → ∃ i, ∀ j ≥ i, p j ∧ q j\n  | ⟨a, ha⟩, ⟨b, hb⟩ =>\n    let ⟨c, hac, hbc⟩ := exists_ge_of_linear a b\n    ⟨c, fun _d hcd ↦ ⟨ha _ <| hac.trans hcd, hb _ <| hbc.trans hcd⟩⟩\n\n"}
{"name":"lt_imp_lt_of_le_imp_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\na b : α\nc d : β\nH : LE.le a b → LE.le c d\nh : LT.lt d c\n⊢ LT.lt b a","decl":"theorem lt_imp_lt_of_le_imp_le {β} [LinearOrder α] [Preorder β] {a b : α} {c d : β}\n    (H : a ≤ b → c ≤ d) (h : d < c) : b < a :=\n  lt_of_not_le fun h' ↦ (H h').not_lt h\n\n"}
{"name":"le_imp_le_iff_lt_imp_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\na b : α\nc d : β\n⊢ Iff (LE.le a b → LE.le c d) (LT.lt d c → LT.lt b a)","decl":"theorem le_imp_le_iff_lt_imp_lt {β} [LinearOrder α] [LinearOrder β] {a b : α} {c d : β} :\n    a ≤ b → c ≤ d ↔ d < c → b < a :=\n  ⟨lt_imp_lt_of_le_imp_le, le_imp_le_of_lt_imp_lt⟩\n\n"}
{"name":"lt_iff_lt_of_le_iff_le'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_5\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na b : α\nc d : β\nH : Iff (LE.le a b) (LE.le c d)\nH' : Iff (LE.le b a) (LE.le d c)\n⊢ Iff (LT.lt b a) (LT.lt d c)","decl":"theorem lt_iff_lt_of_le_iff_le' {β} [Preorder α] [Preorder β] {a b : α} {c d : β}\n    (H : a ≤ b ↔ c ≤ d) (H' : b ≤ a ↔ d ≤ c) : b < a ↔ d < c :=\n  lt_iff_le_not_le.trans <| (and_congr H' (not_congr H)).trans lt_iff_le_not_le.symm\n\n"}
{"name":"lt_iff_lt_of_le_iff_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\na b : α\nc d : β\nH : Iff (LE.le a b) (LE.le c d)\n⊢ Iff (LT.lt b a) (LT.lt d c)","decl":"theorem lt_iff_lt_of_le_iff_le {β} [LinearOrder α] [LinearOrder β] {a b : α} {c d : β}\n    (H : a ≤ b ↔ c ≤ d) : b < a ↔ d < c :=\n  not_le.symm.trans <| (not_congr H).trans <| not_le\n\n"}
{"name":"le_iff_le_iff_lt_iff_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_5\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\na b : α\nc d : β\n⊢ Iff (Iff (LE.le a b) (LE.le c d)) (Iff (LT.lt b a) (LT.lt d c))","decl":"theorem le_iff_le_iff_lt_iff_lt {β} [LinearOrder α] [LinearOrder β] {a b : α} {c d : β} :\n    (a ≤ b ↔ c ≤ d) ↔ (b < a ↔ d < c) :=\n  ⟨lt_iff_lt_of_le_iff_le, fun H ↦ not_lt.symm.trans <| (not_congr H).trans <| not_lt⟩\n\n"}
{"name":"eq_of_forall_le_iff","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nH : ∀ (c : α), Iff (LE.le c a) (LE.le c b)\n⊢ Eq a b","decl":"theorem eq_of_forall_le_iff [PartialOrder α] {a b : α} (H : ∀ c, c ≤ a ↔ c ≤ b) : a = b :=\n  ((H _).1 le_rfl).antisymm ((H _).2 le_rfl)\n\n"}
{"name":"le_of_forall_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b : α\nH : ∀ (c : α), LE.le c a → LE.le c b\n⊢ LE.le a b","decl":"theorem le_of_forall_le [Preorder α] {a b : α} (H : ∀ c, c ≤ a → c ≤ b) : a ≤ b :=\n  H _ le_rfl\n\n"}
{"name":"le_of_forall_ge","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b : α\nH : ∀ (c : α), LE.le a c → LE.le b c\n⊢ LE.le b a","decl":"theorem le_of_forall_ge [Preorder α] {a b : α} (H : ∀ c, a ≤ c → b ≤ c) : b ≤ a :=\n  H _ le_rfl\n\n"}
{"name":"le_of_forall_le'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b : α\nH : ∀ (c : α), LE.le a c → LE.le b c\n⊢ LE.le b a","decl":"@[deprecated (since := \"2025-01-30\")] alias le_of_forall_le' := le_of_forall_ge\n\n"}
{"name":"forall_le_iff_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b : α\n⊢ Iff (∀ ⦃c : α⦄, LE.le c a → LE.le c b) (LE.le a b)","decl":"theorem forall_le_iff_le [Preorder α] {a b : α} : (∀ ⦃c⦄, c ≤ a → c ≤ b) ↔ a ≤ b :=\n  ⟨le_of_forall_le, fun h _ hca ↦ le_trans hca h⟩\n\n"}
{"name":"forall_le_iff_ge","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na b : α\n⊢ Iff (∀ ⦃c : α⦄, LE.le a c → LE.le b c) (LE.le b a)","decl":"theorem forall_le_iff_ge [Preorder α] {a b : α} : (∀ ⦃c⦄, a ≤ c → b ≤ c) ↔ b ≤ a :=\n  ⟨le_of_forall_ge, fun h _ hca ↦ le_trans h hca⟩\n\n"}
{"name":"le_of_forall_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\nH : ∀ (c : α), LT.lt c a → LT.lt c b\n⊢ LE.le a b","decl":"theorem le_of_forall_lt [LinearOrder α] {a b : α} (H : ∀ c, c < a → c < b) : a ≤ b :=\n  le_of_not_lt fun h ↦ lt_irrefl _ (H _ h)\n\n"}
{"name":"forall_lt_iff_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (∀ ⦃c : α⦄, LT.lt c a → LT.lt c b) (LE.le a b)","decl":"theorem forall_lt_iff_le [LinearOrder α] {a b : α} : (∀ ⦃c⦄, c < a → c < b) ↔ a ≤ b :=\n  ⟨le_of_forall_lt, fun h _ hca ↦ lt_of_lt_of_le hca h⟩\n\n"}
{"name":"le_of_forall_lt'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\nH : ∀ (c : α), LT.lt a c → LT.lt b c\n⊢ LE.le b a","decl":"theorem le_of_forall_lt' [LinearOrder α] {a b : α} (H : ∀ c, a < c → b < c) : b ≤ a :=\n  le_of_not_lt fun h ↦ lt_irrefl _ (H _ h)\n\n"}
{"name":"forall_lt_iff_le'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (∀ ⦃c : α⦄, LT.lt a c → LT.lt b c) (LE.le b a)","decl":"theorem forall_lt_iff_le' [LinearOrder α] {a b : α} : (∀ ⦃c⦄, a < c → b < c) ↔ b ≤ a :=\n  ⟨le_of_forall_lt', fun h _ hac ↦ lt_of_le_of_lt h hac⟩\n\n"}
{"name":"eq_of_forall_ge_iff","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\na b : α\nH : ∀ (c : α), Iff (LE.le a c) (LE.le b c)\n⊢ Eq a b","decl":"theorem eq_of_forall_ge_iff [PartialOrder α] {a b : α} (H : ∀ c, a ≤ c ↔ b ≤ c) : a = b :=\n  ((H _).2 le_rfl).antisymm ((H _).1 le_rfl)\n\n"}
{"name":"eq_of_forall_lt_iff","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : ∀ (c : α), Iff (LT.lt c a) (LT.lt c b)\n⊢ Eq a b","decl":"theorem eq_of_forall_lt_iff [LinearOrder α] {a b : α} (h : ∀ c, c < a ↔ c < b) : a = b :=\n  (le_of_forall_lt fun _ ↦ (h _).1).antisymm <| le_of_forall_lt fun _ ↦ (h _).2\n\n"}
{"name":"eq_of_forall_gt_iff","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : ∀ (c : α), Iff (LT.lt a c) (LT.lt b c)\n⊢ Eq a b","decl":"theorem eq_of_forall_gt_iff [LinearOrder α] {a b : α} (h : ∀ c, a < c ↔ b < c) : a = b :=\n  (le_of_forall_lt' fun _ ↦ (h _).2).antisymm <| le_of_forall_lt' fun _ ↦ (h _).1\n\n"}
{"name":"rel_imp_eq_of_rel_imp_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PartialOrder β\nr : α → α → Prop\ninst✝ : IsSymm α r\nf : α → β\nh : ∀ (a b : α), r a b → LE.le (f a) (f b)\na b : α\na✝ : r a b\n⊢ Eq (f a) (f b)","decl":"/-- A symmetric relation implies two values are equal, when it implies they're less-equal. -/\ntheorem rel_imp_eq_of_rel_imp_le [PartialOrder β] (r : α → α → Prop) [IsSymm α r] {f : α → β}\n    (h : ∀ a b, r a b → f a ≤ f b) {a b : α} : r a b → f a = f b := fun hab ↦\n  le_antisymm (h a b hab) (h b a <| symm hab)\n\n"}
{"name":"le_implies_le_of_le_of_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\na b c d : α\ninst✝ : Preorder α\nhca : LE.le c a\nhbd : LE.le b d\na✝ : LE.le a b\n⊢ LE.le c d","decl":"/-- monotonicity of `≤` with respect to `→` -/\ntheorem le_implies_le_of_le_of_le {a b c d : α} [Preorder α] (hca : c ≤ a) (hbd : b ≤ d) :\n    a ≤ b → c ≤ d :=\n  fun hab ↦ (hca.trans hab).trans hbd\n\n"}
{"name":"commutative_of_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : PartialOrder α\nf : β → β → α\ncomm : ∀ (a b : β), LE.le (f a b) (f b a)\na b : β\n⊢ Eq (f a b) (f b a)","decl":"/-- To prove commutativity of a binary operation `○`, we only to check `a ○ b ≤ b ○ a` for all `a`,\n`b`. -/\ntheorem commutative_of_le {f : β → β → α} (comm : ∀ a b, f a b ≤ f b a) : ∀ a b, f a b = f b a :=\n  fun _ _ ↦ (comm _ _).antisymm <| comm _ _\n\n"}
{"name":"associative_of_commutative_of_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\nf : α → α → α\ncomm : Std.Commutative f\nassoc : ∀ (a b c : α), LE.le (f (f a b) c) (f a (f b c))\n⊢ Std.Associative f","decl":"/-- To prove associativity of a commutative binary operation `○`, we only to check\n`(a ○ b) ○ c ≤ a ○ (b ○ c)` for all `a`, `b`, `c`. -/\ntheorem associative_of_commutative_of_le {f : α → α → α} (comm : Std.Commutative f)\n    (assoc : ∀ a b c, f (f a b) c ≤ f a (f b c)) : Std.Associative f where\n  assoc a b c :=\n    le_antisymm (assoc _ _ _) <| by\n      rw [comm.comm, comm.comm b, comm.comm _ c, comm.comm a]\n      exact assoc _ _ _\n\n"}
{"name":"Preorder.toLE_injective","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\n⊢ Function.Injective (@Preorder.toLE α)","decl":"@[ext]\ntheorem Preorder.toLE_injective : Function.Injective (@Preorder.toLE α) :=\n  fun A B h ↦ match A, B with\n  | { lt := A_lt, lt_iff_le_not_le := A_iff, .. },\n    { lt := B_lt, lt_iff_le_not_le := B_iff, .. } => by\n    cases h\n    have : A_lt = B_lt := by\n      funext a b\n      show (LT.mk A_lt).lt a b = (LT.mk B_lt).lt a b\n      rw [A_iff, B_iff]\n    cases this\n    congr\n\n"}
{"name":"Preorder.toLE_injective_iff","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\na₁ a₂ : Preorder α\n⊢ Iff (Eq a₁ a₂) (Eq Preorder.toLE Preorder.toLE)","decl":"@[ext]\ntheorem Preorder.toLE_injective : Function.Injective (@Preorder.toLE α) :=\n  fun A B h ↦ match A, B with\n  | { lt := A_lt, lt_iff_le_not_le := A_iff, .. },\n    { lt := B_lt, lt_iff_le_not_le := B_iff, .. } => by\n    cases h\n    have : A_lt = B_lt := by\n      funext a b\n      show (LT.mk A_lt).lt a b = (LT.mk B_lt).lt a b\n      rw [A_iff, B_iff]\n    cases this\n    congr\n\n"}
{"name":"PartialOrder.toPreorder_injective_iff","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\na₁ a₂ : PartialOrder α\n⊢ Iff (Eq a₁ a₂) (Eq PartialOrder.toPreorder PartialOrder.toPreorder)","decl":"@[ext]\ntheorem PartialOrder.toPreorder_injective :\n    Function.Injective (@PartialOrder.toPreorder α) := fun A B h ↦ by\n  cases A\n  cases B\n  cases h\n  congr\n\n"}
{"name":"PartialOrder.toPreorder_injective","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\n⊢ Function.Injective (@PartialOrder.toPreorder α)","decl":"@[ext]\ntheorem PartialOrder.toPreorder_injective :\n    Function.Injective (@PartialOrder.toPreorder α) := fun A B h ↦ by\n  cases A\n  cases B\n  cases h\n  congr\n\n"}
{"name":"LinearOrder.toPartialOrder_injective_iff","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\na₁ a₂ : LinearOrder α\n⊢ Iff (Eq a₁ a₂) (Eq LinearOrder.toPartialOrder LinearOrder.toPartialOrder)","decl":"@[ext]\ntheorem LinearOrder.toPartialOrder_injective :\n    Function.Injective (@LinearOrder.toPartialOrder α) :=\n  fun A B h ↦ match A, B with\n  | { le := A_le, lt := A_lt,\n      decidableLE := A_decidableLE, decidableEq := A_decidableEq, decidableLT := A_decidableLT\n      min := A_min, max := A_max, min_def := A_min_def, max_def := A_max_def,\n      compare := A_compare, compare_eq_compareOfLessAndEq := A_compare_canonical, .. },\n    { le := B_le, lt := B_lt,\n      decidableLE := B_decidableLE, decidableEq := B_decidableEq, decidableLT := B_decidableLT\n      min := B_min, max := B_max, min_def := B_min_def, max_def := B_max_def,\n      compare := B_compare, compare_eq_compareOfLessAndEq := B_compare_canonical, .. } => by\n    cases h\n    obtain rfl : A_decidableLE = B_decidableLE := Subsingleton.elim _ _\n    obtain rfl : A_decidableEq = B_decidableEq := Subsingleton.elim _ _\n    obtain rfl : A_decidableLT = B_decidableLT := Subsingleton.elim _ _\n    have : A_min = B_min := by\n      funext a b\n      exact (A_min_def _ _).trans (B_min_def _ _).symm\n    cases this\n    have : A_max = B_max := by\n      funext a b\n      exact (A_max_def _ _).trans (B_max_def _ _).symm\n    cases this\n    have : A_compare = B_compare := by\n      funext a b\n      exact (A_compare_canonical _ _).trans (B_compare_canonical _ _).symm\n    congr\n\n"}
{"name":"LinearOrder.toPartialOrder_injective","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\n⊢ Function.Injective (@LinearOrder.toPartialOrder α)","decl":"@[ext]\ntheorem LinearOrder.toPartialOrder_injective :\n    Function.Injective (@LinearOrder.toPartialOrder α) :=\n  fun A B h ↦ match A, B with\n  | { le := A_le, lt := A_lt,\n      decidableLE := A_decidableLE, decidableEq := A_decidableEq, decidableLT := A_decidableLT\n      min := A_min, max := A_max, min_def := A_min_def, max_def := A_max_def,\n      compare := A_compare, compare_eq_compareOfLessAndEq := A_compare_canonical, .. },\n    { le := B_le, lt := B_lt,\n      decidableLE := B_decidableLE, decidableEq := B_decidableEq, decidableLT := B_decidableLT\n      min := B_min, max := B_max, min_def := B_min_def, max_def := B_max_def,\n      compare := B_compare, compare_eq_compareOfLessAndEq := B_compare_canonical, .. } => by\n    cases h\n    obtain rfl : A_decidableLE = B_decidableLE := Subsingleton.elim _ _\n    obtain rfl : A_decidableEq = B_decidableEq := Subsingleton.elim _ _\n    obtain rfl : A_decidableLT = B_decidableLT := Subsingleton.elim _ _\n    have : A_min = B_min := by\n      funext a b\n      exact (A_min_def _ _).trans (B_min_def _ _).symm\n    cases this\n    have : A_max = B_max := by\n      funext a b\n      exact (A_max_def _ _).trans (B_max_def _ _).symm\n    cases this\n    have : A_compare = B_compare := by\n      funext a b\n      exact (A_compare_canonical _ _).trans (B_compare_canonical _ _).symm\n    congr\n\n"}
{"name":"Preorder.ext","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nA B : Preorder α\nH : ∀ (x y : α), Iff (LE.le x y) (LE.le x y)\n⊢ Eq A B","decl":"theorem Preorder.ext {A B : Preorder α}\n    (H : ∀ x y : α, (haveI := A; x ≤ y) ↔ x ≤ y) : A = B := by\n  ext x y\n  exact H x y\n\n"}
{"name":"PartialOrder.ext","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nA B : PartialOrder α\nH : ∀ (x y : α), Iff (LE.le x y) (LE.le x y)\n⊢ Eq A B","decl":"theorem PartialOrder.ext {A B : PartialOrder α}\n    (H : ∀ x y : α, (haveI := A; x ≤ y) ↔ x ≤ y) : A = B := by\n  ext x y\n  exact H x y\n\n"}
{"name":"PartialOrder.ext_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nA B : PartialOrder α\nH : ∀ (x y : α), Iff (LT.lt x y) (LT.lt x y)\n⊢ Eq A B","decl":"theorem PartialOrder.ext_lt {A B : PartialOrder α}\n    (H : ∀ x y : α, (haveI := A; x < y) ↔ x < y) : A = B := by\n  ext x y\n  rw [le_iff_lt_or_eq, @le_iff_lt_or_eq _ A, H]\n\n"}
{"name":"LinearOrder.ext","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nA B : LinearOrder α\nH : ∀ (x y : α), Iff (LE.le x y) (LE.le x y)\n⊢ Eq A B","decl":"theorem LinearOrder.ext {A B : LinearOrder α}\n    (H : ∀ x y : α, (haveI := A; x ≤ y) ↔ x ≤ y) : A = B := by\n  ext x y\n  exact H x y\n\n"}
{"name":"LinearOrder.ext_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nA B : LinearOrder α\nH : ∀ (x y : α), Iff (LT.lt x y) (LT.lt x y)\n⊢ Eq A B","decl":"theorem LinearOrder.ext_lt {A B : LinearOrder α}\n    (H : ∀ x y : α, (haveI := A; x < y) ↔ x < y) : A = B :=\n  LinearOrder.toPartialOrder_injective (PartialOrder.ext_lt H)\n\n"}
{"name":"ltByCases_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\nh : LT.lt x y\nh₁ : LT.lt x y → P\nh₂ : Eq x y → P\nh₃ : LT.lt y x → P\n⊢ Eq (ltByCases x y h₁ h₂ h₃) (h₁ h)","decl":"@[simp]\nlemma ltByCases_lt (h : x < y) {h₁ : x < y → P} {h₂ : x = y → P} {h₃ : y < x → P} :\n    ltByCases x y h₁ h₂ h₃ = h₁ h := dif_pos h\n\n"}
{"name":"ltByCases_gt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\nh : LT.lt y x\nh₁ : LT.lt x y → P\nh₂ : Eq x y → P\nh₃ : LT.lt y x → P\n⊢ Eq (ltByCases x y h₁ h₂ h₃) (h₃ h)","decl":"@[simp]\nlemma ltByCases_gt (h : y < x) {h₁ : x < y → P} {h₂ : x = y → P} {h₃ : y < x → P} :\n    ltByCases x y h₁ h₂ h₃ = h₃ h := (dif_neg h.not_lt).trans (dif_pos h)\n\n"}
{"name":"ltByCases_eq","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\nh : Eq x y\nh₁ : LT.lt x y → P\nh₂ : Eq x y → P\nh₃ : LT.lt y x → P\n⊢ Eq (ltByCases x y h₁ h₂ h₃) (h₂ h)","decl":"@[simp]\nlemma ltByCases_eq (h : x = y) {h₁ : x < y → P} {h₂ : x = y → P} {h₃ : y < x → P} :\n    ltByCases x y h₁ h₂ h₃ = h₂ h := (dif_neg h.not_lt).trans (dif_neg h.not_gt)\n\n"}
{"name":"ltByCases_not_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\nh : Not (LT.lt x y)\nh₁ : LT.lt x y → P\nh₂ : Eq x y → P\nh₃ : LT.lt y x → P\np : optParam (Not (LT.lt y x) → Eq x y) ⋯\n⊢ Eq (ltByCases x y h₁ h₂ h₃) (dite (LT.lt y x) (fun h' => h₃ h') fun h' => h₂ ⋯)","decl":"lemma ltByCases_not_lt (h : ¬ x < y) {h₁ : x < y → P} {h₂ : x = y → P} {h₃ : y < x → P}\n    (p : ¬ y < x → x = y := fun h' => (le_antisymm (le_of_not_gt h') (le_of_not_gt h))) :\n    ltByCases x y h₁ h₂ h₃ = if h' : y < x then h₃ h' else h₂ (p h') := dif_neg h\n\n"}
{"name":"ltByCases_not_gt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\nh : Not (LT.lt y x)\nh₁ : LT.lt x y → P\nh₂ : Eq x y → P\nh₃ : LT.lt y x → P\np : optParam (Not (LT.lt x y) → Eq x y) ⋯\n⊢ Eq (ltByCases x y h₁ h₂ h₃) (dite (LT.lt x y) (fun h' => h₁ h') fun h' => h₂ ⋯)","decl":"lemma ltByCases_not_gt (h : ¬ y < x) {h₁ : x < y → P} {h₂ : x = y → P} {h₃ : y < x → P}\n    (p : ¬ x < y → x = y := fun h' => (le_antisymm (le_of_not_gt h) (le_of_not_gt h'))) :\n    ltByCases x y h₁ h₂ h₃ = if h' : x < y then h₁ h' else h₂ (p h') :=\n  dite_congr rfl (fun _ => rfl) (fun _ => dif_neg h)\n\n"}
{"name":"ltByCases_ne","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\nh : Ne x y\nh₁ : LT.lt x y → P\nh₂ : Eq x y → P\nh₃ : LT.lt y x → P\np : optParam (Not (LT.lt x y) → LT.lt y x) ⋯\n⊢ Eq (ltByCases x y h₁ h₂ h₃) (dite (LT.lt x y) (fun h' => h₁ h') fun h' => h₃ ⋯)","decl":"lemma ltByCases_ne (h : x ≠ y) {h₁ : x < y → P} {h₂ : x = y → P} {h₃ : y < x → P}\n    (p : ¬ x < y → y < x := fun h' => h.lt_or_lt.resolve_left h') :\n    ltByCases x y h₁ h₂ h₃ = if h' : x < y then h₁ h' else h₃ (p h') :=\n  dite_congr rfl (fun _ => rfl) (fun _ => dif_pos _)\n\n"}
{"name":"ltByCases_comm","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\nh₁ : LT.lt x y → P\nh₂ : Eq x y → P\nh₃ : LT.lt y x → P\np : optParam (Eq y x → Eq x y) ⋯\n⊢ Eq (ltByCases x y h₁ h₂ h₃) (ltByCases y x h₃ (Function.comp h₂ p) h₁)","decl":"lemma ltByCases_comm {h₁ : x < y → P} {h₂ : x = y → P} {h₃ : y < x → P}\n    (p : y = x → x = y := fun h' => h'.symm) :\n    ltByCases x y h₁ h₂ h₃ = ltByCases y x h₃ (h₂ ∘ p) h₁ := by\n  refine ltByCases x y (fun h => ?_) (fun h => ?_) (fun h => ?_)\n  · rw [ltByCases_lt h, ltByCases_gt h]\n  · rw [ltByCases_eq h, ltByCases_eq h.symm, comp_apply]\n  · rw [ltByCases_lt h, ltByCases_gt h]\n\n"}
{"name":"eq_iff_eq_of_lt_iff_lt_of_gt_iff_gt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx y x' y' : α\nltc : Iff (LT.lt x y) (LT.lt x' y')\ngtc : Iff (LT.lt y x) (LT.lt y' x')\n⊢ Iff (Eq x y) (Eq x' y')","decl":"lemma eq_iff_eq_of_lt_iff_lt_of_gt_iff_gt {x' y' : α}\n    (ltc : (x < y) ↔ (x' < y')) (gtc : (y < x) ↔ (y' < x')) :\n    x = y ↔ x' = y' := by simp_rw [eq_iff_le_not_lt, ← not_lt, ltc, gtc]\n\n"}
{"name":"ltByCases_rec","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\nh₁ : LT.lt x y → P\nh₂ : Eq x y → P\nh₃ : LT.lt y x → P\np : P\nhlt : ∀ (h : LT.lt x y), Eq (h₁ h) p\nheq : ∀ (h : Eq x y), Eq (h₂ h) p\nhgt : ∀ (h : LT.lt y x), Eq (h₃ h) p\n⊢ Eq (ltByCases x y h₁ h₂ h₃) p","decl":"lemma ltByCases_rec {h₁ : x < y → P} {h₂ : x = y → P} {h₃ : y < x → P} (p : P)\n    (hlt : (h : x < y) → h₁ h = p) (heq : (h : x = y) → h₂ h = p)\n    (hgt : (h : y < x) → h₃ h = p) :\n    ltByCases x y h₁ h₂ h₃ = p :=\n  ltByCases x y\n    (fun h => ltByCases_lt h ▸ hlt h)\n    (fun h => ltByCases_eq h ▸ heq h)\n    (fun h => ltByCases_gt h ▸ hgt h)\n\n"}
{"name":"ltByCases_eq_iff","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\nh₁ : LT.lt x y → P\nh₂ : Eq x y → P\nh₃ : LT.lt y x → P\np : P\n⊢ Iff (Eq (ltByCases x y h₁ h₂ h₃) p) (Or (Exists fun h => Eq (h₁ h) p) (Or (Exists fun h => Eq (h₂ h) p) (Exists fun h => Eq (h₃ h) p)))","decl":"lemma ltByCases_eq_iff {h₁ : x < y → P} {h₂ : x = y → P} {h₃ : y < x → P} {p : P} :\n    ltByCases x y h₁ h₂ h₃ = p ↔ (∃ h, h₁ h = p) ∨ (∃ h, h₂ h = p) ∨ (∃ h, h₃ h = p) := by\n  refine ltByCases x y (fun h => ?_) (fun h => ?_) (fun h => ?_)\n  · simp only [ltByCases_lt, exists_prop_of_true, h, h.not_lt, not_false_eq_true,\n    exists_prop_of_false, or_false, h.ne]\n  · simp only [h, lt_self_iff_false, ltByCases_eq, not_false_eq_true,\n    exists_prop_of_false, exists_prop_of_true, or_false, false_or]\n  · simp only [ltByCases_gt, exists_prop_of_true, h, h.not_lt, not_false_eq_true,\n    exists_prop_of_false, false_or, h.ne']\n\n"}
{"name":"ltByCases_congr","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y x' y' : α\nh₁ : LT.lt x y → P\nh₂ : Eq x y → P\nh₃ : LT.lt y x → P\nh₁' : LT.lt x' y' → P\nh₂' : Eq x' y' → P\nh₃' : LT.lt y' x' → P\nltc : Iff (LT.lt x y) (LT.lt x' y')\ngtc : Iff (LT.lt y x) (LT.lt y' x')\nhh'₁ : ∀ (h : LT.lt x' y'), Eq (h₁ ⋯) (h₁' h)\nhh'₂ : ∀ (h : Eq x' y'), Eq (h₂ ⋯) (h₂' h)\nhh'₃ : ∀ (h : LT.lt y' x'), Eq (h₃ ⋯) (h₃' h)\n⊢ Eq (ltByCases x y h₁ h₂ h₃) (ltByCases x' y' h₁' h₂' h₃')","decl":"lemma ltByCases_congr {x' y' : α} {h₁ : x < y → P} {h₂ : x = y → P} {h₃ : y < x → P}\n    {h₁' : x' < y' → P} {h₂' : x' = y' → P} {h₃' : y' < x' → P} (ltc : (x < y) ↔ (x' < y'))\n    (gtc : (y < x) ↔ (y' < x')) (hh'₁ : ∀ (h : x' < y'), h₁ (ltc.mpr h) = h₁' h)\n    (hh'₂ : ∀ (h : x' = y'), h₂ ((eq_iff_eq_of_lt_iff_lt_of_gt_iff_gt ltc gtc).mpr h) = h₂' h)\n    (hh'₃ : ∀ (h : y' < x'), h₃ (gtc.mpr h) = h₃' h) :\n    ltByCases x y h₁ h₂ h₃ = ltByCases x' y' h₁' h₂' h₃' := by\n  refine ltByCases_rec _ (fun h => ?_) (fun h => ?_) (fun h => ?_)\n  · rw [ltByCases_lt (ltc.mp h), hh'₁]\n  · rw [eq_iff_eq_of_lt_iff_lt_of_gt_iff_gt ltc gtc] at h\n    rw [ltByCases_eq h, hh'₂]\n  · rw [ltByCases_gt (gtc.mp h), hh'₃]\n\n"}
{"name":"ltTrichotomy_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\np q r : P\nh : LT.lt x y\n⊢ Eq (ltTrichotomy x y p q r) p","decl":"@[simp]\nlemma ltTrichotomy_lt (h : x < y) : ltTrichotomy x y p q r = p := ltByCases_lt h\n\n"}
{"name":"ltTrichotomy_gt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\np q r : P\nh : LT.lt y x\n⊢ Eq (ltTrichotomy x y p q r) r","decl":"@[simp]\nlemma ltTrichotomy_gt (h : y < x) : ltTrichotomy x y p q r = r := ltByCases_gt h\n\n"}
{"name":"ltTrichotomy_eq","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\np q r : P\nh : Eq x y\n⊢ Eq (ltTrichotomy x y p q r) q","decl":"@[simp]\nlemma ltTrichotomy_eq (h : x = y) : ltTrichotomy x y p q r = q := ltByCases_eq h\n\n"}
{"name":"ltTrichotomy_not_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\np q r : P\nh : Not (LT.lt x y)\n⊢ Eq (ltTrichotomy x y p q r) (ite (LT.lt y x) r q)","decl":"lemma ltTrichotomy_not_lt (h : ¬ x < y) :\n    ltTrichotomy x y p q r = if y < x then r else q := ltByCases_not_lt h\n\n"}
{"name":"ltTrichotomy_not_gt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\np q r : P\nh : Not (LT.lt y x)\n⊢ Eq (ltTrichotomy x y p q r) (ite (LT.lt x y) p q)","decl":"lemma ltTrichotomy_not_gt (h : ¬ y < x) :\n    ltTrichotomy x y p q r = if x < y then p else q := ltByCases_not_gt h\n\n"}
{"name":"ltTrichotomy_ne","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\np q r : P\nh : Ne x y\n⊢ Eq (ltTrichotomy x y p q r) (ite (LT.lt x y) p r)","decl":"lemma ltTrichotomy_ne (h : x ≠ y) :\n    ltTrichotomy x y p q r = if x < y then p else r := ltByCases_ne h\n\n"}
{"name":"ltTrichotomy_comm","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\np q r : P\n⊢ Eq (ltTrichotomy x y p q r) (ltTrichotomy y x r q p)","decl":"lemma ltTrichotomy_comm : ltTrichotomy x y p q r = ltTrichotomy y x r q p := ltByCases_comm\n\n"}
{"name":"ltTrichotomy_self","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\np : P\n⊢ Eq (ltTrichotomy x y p p p) p","decl":"lemma ltTrichotomy_self {p : P} : ltTrichotomy x y p p p = p :=\n  ltByCases_rec p (fun _ => rfl) (fun _ => rfl) (fun _ => rfl)\n\n"}
{"name":"ltTrichotomy_eq_iff","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\np q r s : P\n⊢ Iff (Eq (ltTrichotomy x y p q r) s) (Or (And (LT.lt x y) (Eq p s)) (Or (And (Eq x y) (Eq q s)) (And (LT.lt y x) (Eq r s))))","decl":"lemma ltTrichotomy_eq_iff : ltTrichotomy x y p q r = s ↔\n    (x < y ∧ p = s) ∨ (x = y ∧ q = s) ∨ (y < x ∧ r = s) := by\n  refine ltByCases x y (fun h => ?_) (fun h => ?_) (fun h => ?_)\n  · simp only [ltTrichotomy_lt, false_and, true_and, or_false, h, h.not_lt, h.ne]\n  · simp only [ltTrichotomy_eq, false_and, true_and, or_false, false_or, h, lt_irrefl]\n  · simp only [ltTrichotomy_gt, false_and, true_and, false_or, h, h.not_lt, h.ne']\n\n"}
{"name":"ltTrichotomy_congr","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nP : Sort u_5\nx y : α\np q r : P\nx' y' : α\np' q' r' : P\nltc : Iff (LT.lt x y) (LT.lt x' y')\ngtc : Iff (LT.lt y x) (LT.lt y' x')\nhh'₁ : LT.lt x' y' → Eq p p'\nhh'₂ : Eq x' y' → Eq q q'\nhh'₃ : LT.lt y' x' → Eq r r'\n⊢ Eq (ltTrichotomy x y p q r) (ltTrichotomy x' y' p' q' r')","decl":"lemma ltTrichotomy_congr {x' y' : α} {p' q' r' : P} (ltc : (x < y) ↔ (x' < y'))\n    (gtc : (y < x) ↔ (y' < x')) (hh'₁ : x' < y' → p = p')\n    (hh'₂ : x' = y' → q = q') (hh'₃ : y' < x' → r = r') :\n    ltTrichotomy x y p q r = ltTrichotomy x' y' p' q' r' :=\n  ltByCases_congr ltc gtc hh'₁ hh'₂ hh'₃\n\n"}
{"name":"OrderDual.instNonempty","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_5\nh : Nonempty α\n⊢ Nonempty (OrderDual α)","decl":"instance (α : Type*) [h : Nonempty α] : Nonempty αᵒᵈ :=\n  h\n\n"}
{"name":"OrderDual.instSubsingleton","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_5\nh : Subsingleton α\n⊢ Subsingleton (OrderDual α)","decl":"instance (α : Type*) [h : Subsingleton α] : Subsingleton αᵒᵈ :=\n  h\n\n"}
{"name":"OrderDual.Ord.dual_dual","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_5\nH : Ord α\n⊢ Eq (OrderDual.instOrd (OrderDual α)) H","decl":"theorem Ord.dual_dual (α : Type*) [H : Ord α] : OrderDual.instOrd αᵒᵈ = H :=\n  rfl\n\n"}
{"name":"OrderDual.Preorder.dual_dual","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_5\nH : Preorder α\n⊢ Eq (OrderDual.instPreorder (OrderDual α)) H","decl":"theorem Preorder.dual_dual (α : Type*) [H : Preorder α] : OrderDual.instPreorder αᵒᵈ = H :=\n  rfl\n\n"}
{"name":"OrderDual.instPartialOrder.dual_dual","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_5\nH : PartialOrder α\n⊢ Eq (OrderDual.instPartialOrder (OrderDual α)) H","decl":"theorem instPartialOrder.dual_dual (α : Type*) [H : PartialOrder α] :\n    OrderDual.instPartialOrder αᵒᵈ = H :=\n  rfl\n\n"}
{"name":"OrderDual.instLinearOrder.dual_dual","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_5\nH : LinearOrder α\n⊢ Eq (OrderDual.instLinearOrder (OrderDual α)) H","decl":"theorem instLinearOrder.dual_dual (α : Type*) [H : LinearOrder α] :\n    OrderDual.instLinearOrder αᵒᵈ = H :=\n  rfl\n\n"}
{"name":"Pi.compl_def","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝ : (i : ι) → HasCompl (π i)\nx : (i : ι) → π i\n⊢ Eq (HasCompl.compl x) fun i => HasCompl.compl (x i)","decl":"theorem Pi.compl_def [∀ i, HasCompl (π i)] (x : ∀ i, π i) :\n    xᶜ = fun i ↦ (x i)ᶜ :=\n  rfl\n\n"}
{"name":"Pi.compl_apply","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝ : (i : ι) → HasCompl (π i)\nx : (i : ι) → π i\ni : ι\n⊢ Eq (HasCompl.compl x i) (HasCompl.compl (x i))","decl":"@[simp]\ntheorem Pi.compl_apply [∀ i, HasCompl (π i)] (x : ∀ i, π i) (i : ι) :\n    xᶜ i = (x i)ᶜ :=\n  rfl\n\n"}
{"name":"IsIrrefl.compl","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsIrrefl α r\n⊢ IsRefl α (HasCompl.compl r)","decl":"instance IsIrrefl.compl (r) [IsIrrefl α r] : IsRefl α rᶜ :=\n  ⟨@irrefl α r _⟩\n\n"}
{"name":"IsRefl.compl","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsRefl α r\n⊢ IsIrrefl α (HasCompl.compl r)","decl":"instance IsRefl.compl (r) [IsRefl α r] : IsIrrefl α rᶜ :=\n  ⟨fun a ↦ not_not_intro (refl a)⟩\n\n"}
{"name":"compl_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\n⊢ Eq (HasCompl.compl fun x1 x2 => LT.lt x1 x2) fun x1 x2 => GE.ge x1 x2","decl":"theorem compl_lt [LinearOrder α] : (· < · : α → α → _)ᶜ = (· ≥ ·) := by ext; simp [compl]\n"}
{"name":"compl_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\n⊢ Eq (HasCompl.compl fun x1 x2 => LE.le x1 x2) fun x1 x2 => GT.gt x1 x2","decl":"theorem compl_le [LinearOrder α] : (· ≤ · : α → α → _)ᶜ = (· > ·) := by ext; simp [compl]\n"}
{"name":"compl_gt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\n⊢ Eq (HasCompl.compl fun x1 x2 => GT.gt x1 x2) fun x1 x2 => LE.le x1 x2","decl":"theorem compl_gt [LinearOrder α] : (· > · : α → α → _)ᶜ = (· ≤ ·) := by ext; simp [compl]\n"}
{"name":"compl_ge","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\n⊢ Eq (HasCompl.compl fun x1 x2 => GE.ge x1 x2) fun x1 x2 => LT.lt x1 x2","decl":"theorem compl_ge [LinearOrder α] : (· ≥ · : α → α → _)ᶜ = (· < ·) := by ext; simp [compl]\n\n"}
{"name":"Ne.instIsEquiv_compl","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\n⊢ IsEquiv α (HasCompl.compl fun x1 x2 => Ne x1 x2)","decl":"instance Ne.instIsEquiv_compl : IsEquiv α (· ≠ ·)ᶜ := by\n  convert eq_isEquiv α\n  simp [compl]\n\n"}
{"name":"Pi.le_def","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝ : (i : ι) → LE (π i)\nx y : (i : ι) → π i\n⊢ Iff (LE.le x y) (∀ (i : ι), LE.le (x i) (y i))","decl":"theorem Pi.le_def [∀ i, LE (π i)] {x y : ∀ i, π i} :\n    x ≤ y ↔ ∀ i, x i ≤ y i :=\n  Iff.rfl\n\n"}
{"name":"Pi.lt_def","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝ : (i : ι) → Preorder (π i)\nx y : (i : ι) → π i\n⊢ Iff (LT.lt x y) (And (LE.le x y) (Exists fun i => LT.lt (x i) (y i)))","decl":"theorem Pi.lt_def [∀ i, Preorder (π i)] {x y : ∀ i, π i} :\n    x < y ↔ x ≤ y ∧ ∃ i, x i < y i := by\n  simp +contextual [lt_iff_le_not_le, Pi.le_def]\n\n"}
{"name":"Sum.elim_le_elim_iff","module":"Mathlib.Order.Basic","initialProofState":"β : Type u_3\nα₁ : Type u_5\nα₂ : Type u_6\ninst✝ : LE β\nu₁ v₁ : α₁ → β\nu₂ v₂ : α₂ → β\n⊢ Iff (LE.le (Sum.elim u₁ u₂) (Sum.elim v₁ v₂)) (And (LE.le u₁ v₁) (LE.le u₂ v₂))","decl":"@[simp]\nlemma elim_le_elim_iff {u₁ v₁ : α₁ → β} {u₂ v₂ : α₂ → β} :\n    Sum.elim u₁ u₂ ≤ Sum.elim v₁ v₂ ↔ u₁ ≤ v₁ ∧ u₂ ≤ v₂ :=\n  Sum.forall\n\n"}
{"name":"Sum.const_le_elim_iff","module":"Mathlib.Order.Basic","initialProofState":"β : Type u_3\nα₁ : Type u_5\nα₂ : Type u_6\ninst✝ : LE β\nb : β\nv₁ : α₁ → β\nv₂ : α₂ → β\n⊢ Iff (LE.le (Function.const (Sum α₁ α₂) b) (Sum.elim v₁ v₂)) (And (LE.le (Function.const α₁ b) v₁) (LE.le (Function.const α₂ b) v₂))","decl":"lemma const_le_elim_iff {b : β} {v₁ : α₁ → β} {v₂ : α₂ → β} :\n    Function.const _ b ≤ Sum.elim v₁ v₂ ↔ Function.const _ b ≤ v₁ ∧ Function.const _ b ≤ v₂ :=\n  elim_const_const b ▸ elim_le_elim_iff ..\n\n"}
{"name":"Sum.elim_le_const_iff","module":"Mathlib.Order.Basic","initialProofState":"β : Type u_3\nα₁ : Type u_5\nα₂ : Type u_6\ninst✝ : LE β\nb : β\nu₁ : α₁ → β\nu₂ : α₂ → β\n⊢ Iff (LE.le (Sum.elim u₁ u₂) (Function.const (Sum α₁ α₂) b)) (And (LE.le u₁ (Function.const α₁ b)) (LE.le u₂ (Function.const α₂ b)))","decl":"lemma elim_le_const_iff {b : β} {u₁ : α₁ → β} {u₂ : α₂ → β} :\n    Sum.elim u₁ u₂ ≤ Function.const _ b ↔ u₁ ≤ Function.const _ b ∧ u₂ ≤ Function.const _ b :=\n  elim_const_const b ▸ elim_le_elim_iff ..\n\n"}
{"name":"le_of_strongLT","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝ : (i : ι) → Preorder (π i)\na b : (i : ι) → π i\nh : StrongLT a b\n⊢ LE.le a b","decl":"theorem le_of_strongLT (h : a ≺ b) : a ≤ b := fun _ ↦ (h _).le\n\n"}
{"name":"lt_of_strongLT","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : (i : ι) → Preorder (π i)\na b : (i : ι) → π i\ninst✝ : Nonempty ι\nh : StrongLT a b\n⊢ LT.lt a b","decl":"theorem lt_of_strongLT [Nonempty ι] (h : a ≺ b) : a < b := by\n  inhabit ι\n  exact Pi.lt_def.2 ⟨le_of_strongLT h, default, h _⟩\n\n"}
{"name":"strongLT_of_strongLT_of_le","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝ : (i : ι) → Preorder (π i)\na b c : (i : ι) → π i\nhab : StrongLT a b\nhbc : LE.le b c\n⊢ StrongLT a c","decl":"theorem strongLT_of_strongLT_of_le (hab : a ≺ b) (hbc : b ≤ c) : a ≺ c := fun _ ↦\n  (hab _).trans_le <| hbc _\n\n"}
{"name":"strongLT_of_le_of_strongLT","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝ : (i : ι) → Preorder (π i)\na b c : (i : ι) → π i\nhab : LE.le a b\nhbc : StrongLT b c\n⊢ StrongLT a c","decl":"theorem strongLT_of_le_of_strongLT (hab : a ≤ b) (hbc : b ≺ c) : a ≺ c := fun _ ↦\n  (hab _).trans_lt <| hbc _\n\n"}
{"name":"StrongLT.le","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝ : (i : ι) → Preorder (π i)\na b : (i : ι) → π i\nh : StrongLT a b\n⊢ LE.le a b","decl":"alias StrongLT.le := le_of_strongLT\n\n"}
{"name":"StrongLT.lt","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : (i : ι) → Preorder (π i)\na b : (i : ι) → π i\ninst✝ : Nonempty ι\nh : StrongLT a b\n⊢ LT.lt a b","decl":"alias StrongLT.lt := lt_of_strongLT\n\n"}
{"name":"StrongLT.trans_le","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝ : (i : ι) → Preorder (π i)\na b c : (i : ι) → π i\nhab : StrongLT a b\nhbc : LE.le b c\n⊢ StrongLT a c","decl":"alias StrongLT.trans_le := strongLT_of_strongLT_of_le\n\n"}
{"name":"LE.le.trans_strongLT","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝ : (i : ι) → Preorder (π i)\na b c : (i : ι) → π i\nhab : LE.le a b\nhbc : StrongLT b c\n⊢ StrongLT a c","decl":"alias LE.le.trans_strongLT := strongLT_of_le_of_strongLT\n\n"}
{"name":"le_update_iff","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Preorder (π i)\nx y : (i : ι) → π i\ni : ι\na : π i\n⊢ Iff (LE.le x (Function.update y i a)) (And (LE.le (x i) a) (∀ (j : ι), Ne j i → LE.le (x j) (y j)))","decl":"theorem le_update_iff : x ≤ Function.update y i a ↔ x i ≤ a ∧ ∀ (j) (_ : j ≠ i), x j ≤ y j :=\n  Function.forall_update_iff _ fun j z ↦ x j ≤ z\n\n"}
{"name":"update_le_iff","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Preorder (π i)\nx y : (i : ι) → π i\ni : ι\na : π i\n⊢ Iff (LE.le (Function.update x i a) y) (And (LE.le a (y i)) (∀ (j : ι), Ne j i → LE.le (x j) (y j)))","decl":"theorem update_le_iff : Function.update x i a ≤ y ↔ a ≤ y i ∧ ∀ (j) (_ : j ≠ i), x j ≤ y j :=\n  Function.forall_update_iff _ fun j z ↦ z ≤ y j\n\n"}
{"name":"update_le_update_iff","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Preorder (π i)\nx y : (i : ι) → π i\ni : ι\na b : π i\n⊢ Iff (LE.le (Function.update x i a) (Function.update y i b)) (And (LE.le a b) (∀ (j : ι), Ne j i → LE.le (x j) (y j)))","decl":"theorem update_le_update_iff :\n    Function.update x i a ≤ Function.update y i b ↔ a ≤ b ∧ ∀ (j) (_ : j ≠ i), x j ≤ y j := by\n  simp +contextual [update_le_iff]\n\n"}
{"name":"update_le_update_iff'","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Preorder (π i)\nx : (i : ι) → π i\ni : ι\na b : π i\n⊢ Iff (LE.le (Function.update x i a) (Function.update x i b)) (LE.le a b)","decl":"@[simp]\ntheorem update_le_update_iff' : update x i a ≤ update x i b ↔ a ≤ b := by\n  simp [update_le_update_iff]\n\n"}
{"name":"update_lt_update_iff","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Preorder (π i)\nx : (i : ι) → π i\ni : ι\na b : π i\n⊢ Iff (LT.lt (Function.update x i a) (Function.update x i b)) (LT.lt a b)","decl":"@[simp]\ntheorem update_lt_update_iff : update x i a < update x i b ↔ a < b :=\n  lt_iff_lt_of_le_iff_le' update_le_update_iff' update_le_update_iff'\n\n"}
{"name":"le_update_self_iff","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Preorder (π i)\nx : (i : ι) → π i\ni : ι\na : π i\n⊢ Iff (LE.le x (Function.update x i a)) (LE.le (x i) a)","decl":"@[simp]\ntheorem le_update_self_iff : x ≤ update x i a ↔ x i ≤ a := by simp [le_update_iff]\n\n"}
{"name":"update_le_self_iff","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Preorder (π i)\nx : (i : ι) → π i\ni : ι\na : π i\n⊢ Iff (LE.le (Function.update x i a) x) (LE.le a (x i))","decl":"@[simp]\ntheorem update_le_self_iff : update x i a ≤ x ↔ a ≤ x i := by simp [update_le_iff]\n\n"}
{"name":"lt_update_self_iff","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Preorder (π i)\nx : (i : ι) → π i\ni : ι\na : π i\n⊢ Iff (LT.lt x (Function.update x i a)) (LT.lt (x i) a)","decl":"@[simp]\ntheorem lt_update_self_iff : x < update x i a ↔ x i < a := by simp [lt_iff_le_not_le]\n\n"}
{"name":"update_lt_self_iff","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → Preorder (π i)\nx : (i : ι) → π i\ni : ι\na : π i\n⊢ Iff (LT.lt (Function.update x i a) x) (LT.lt a (x i))","decl":"@[simp]\ntheorem update_lt_self_iff : update x i a < x ↔ a < x i := by simp [lt_iff_le_not_le]\n\n"}
{"name":"Pi.sdiff_def","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝ : (i : ι) → SDiff (π i)\nx y : (i : ι) → π i\n⊢ Eq (SDiff.sdiff x y) fun i => SDiff.sdiff (x i) (y i)","decl":"theorem Pi.sdiff_def [∀ i, SDiff (π i)] (x y : ∀ i, π i) :\n    x \\ y = fun i ↦ x i \\ y i :=\n  rfl\n\n"}
{"name":"Pi.sdiff_apply","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝ : (i : ι) → SDiff (π i)\nx y : (i : ι) → π i\ni : ι\n⊢ Eq (SDiff.sdiff x y i) (SDiff.sdiff (x i) (y i))","decl":"@[simp]\ntheorem Pi.sdiff_apply [∀ i, SDiff (π i)] (x y : ∀ i, π i) (i : ι) :\n    (x \\ y) i = x i \\ y i :=\n  rfl\n\n"}
{"name":"Function.const_le_const","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Nonempty β\na b : α\n⊢ Iff (LE.le (Function.const β a) (Function.const β b)) (LE.le a b)","decl":"@[simp]\ntheorem const_le_const : const β a ≤ const β b ↔ a ≤ b := by simp [Pi.le_def]\n\n"}
{"name":"Function.const_lt_const","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Nonempty β\na b : α\n⊢ Iff (LT.lt (Function.const β a) (Function.const β b)) (LT.lt a b)","decl":"@[simp]\ntheorem const_lt_const : const β a < const β b ↔ a < b := by simpa [Pi.lt_def] using le_of_lt\n\n"}
{"name":"min_rec","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\np : α → Prop\nx y : α\nhx : LE.le x y → p x\nhy : LE.le y x → p y\n⊢ p (Min.min x y)","decl":"theorem min_rec (hx : x ≤ y → p x) (hy : y ≤ x → p y) : p (min x y) :=\n  (le_total x y).rec (fun h ↦ (min_eq_left h).symm.subst (hx h)) fun h ↦\n    (min_eq_right h).symm.subst (hy h)\n\n"}
{"name":"max_rec","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\np : α → Prop\nx y : α\nhx : LE.le y x → p x\nhy : LE.le x y → p y\n⊢ p (Max.max x y)","decl":"theorem max_rec (hx : y ≤ x → p x) (hy : x ≤ y → p y) : p (max x y) :=\n  @min_rec αᵒᵈ _ _ _ _ hx hy\n\n"}
{"name":"min_rec'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx y : α\np : α → Prop\nhx : p x\nhy : p y\n⊢ p (Min.min x y)","decl":"theorem min_rec' (p : α → Prop) (hx : p x) (hy : p y) : p (min x y) :=\n  min_rec (fun _ ↦ hx) fun _ ↦ hy\n\n"}
{"name":"max_rec'","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx y : α\np : α → Prop\nhx : p x\nhy : p y\n⊢ p (Max.max x y)","decl":"theorem max_rec' (p : α → Prop) (hx : p x) (hy : p y) : p (max x y) :=\n  max_rec (fun _ ↦ hx) fun _ ↦ hy\n\n"}
{"name":"min_def_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx y : α\n⊢ Eq (Min.min x y) (ite (LT.lt x y) x y)","decl":"theorem min_def_lt (x y : α) : min x y = if x < y then x else y := by\n  rw [min_comm, min_def, ← ite_not]\n  simp only [not_le]\n\n"}
{"name":"max_def_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nx y : α\n⊢ Eq (Max.max x y) (ite (LT.lt x y) y x)","decl":"theorem max_def_lt (x y : α) : max x y = if x < y then y else x := by\n  rw [max_comm, max_def, ← ite_not]\n  simp only [not_le]\n\n"}
{"name":"compare_of_injective_eq_compareOfLessAndEq","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\na b : α\ninst✝² : LinearOrder β\ninst✝¹ : DecidableEq α\nf : α → β\ninj : Function.Injective f\ninst✝ : Decidable (LT.lt a b)\n⊢ Eq (Ord.compare (f a) (f b)) (compareOfLessAndEq a b)","decl":"theorem compare_of_injective_eq_compareOfLessAndEq (a b : α) [LinearOrder β]\n    [DecidableEq α] (f : α → β) (inj : Injective f)\n    [Decidable (LT.lt (self := PartialOrder.lift f inj |>.toLT) a b)] :\n    compare (f a) (f b) =\n      @compareOfLessAndEq _ a b (PartialOrder.lift f inj |>.toLT) _ _ := by\n  have h := LinearOrder.compare_eq_compareOfLessAndEq (f a) (f b)\n  simp only [h, compareOfLessAndEq]\n  split_ifs <;> try (first | rfl | contradiction)\n  · have : ¬ f a = f b := by rename_i h; exact inj.ne h\n    contradiction\n  · have : f a = f b := by rename_i h; exact congrArg f h\n    contradiction\n\n"}
{"name":"Subtype.mk_le_mk","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\np : α → Prop\nx y : α\nhx : p x\nhy : p y\n⊢ Iff (LE.le ⟨x, hx⟩ ⟨y, hy⟩) (LE.le x y)","decl":"@[simp]\ntheorem mk_le_mk [LE α] {p : α → Prop} {x y : α} {hx : p x} {hy : p y} :\n    (⟨x, hx⟩ : Subtype p) ≤ ⟨y, hy⟩ ↔ x ≤ y :=\n  Iff.rfl\n\n"}
{"name":"Subtype.mk_lt_mk","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LT α\np : α → Prop\nx y : α\nhx : p x\nhy : p y\n⊢ Iff (LT.lt ⟨x, hx⟩ ⟨y, hy⟩) (LT.lt x y)","decl":"@[simp]\ntheorem mk_lt_mk [LT α] {p : α → Prop} {x y : α} {hx : p x} {hy : p y} :\n    (⟨x, hx⟩ : Subtype p) < ⟨y, hy⟩ ↔ x < y :=\n  Iff.rfl\n\n"}
{"name":"Subtype.coe_le_coe","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\np : α → Prop\nx y : Subtype p\n⊢ Iff (LE.le ↑x ↑y) (LE.le x y)","decl":"@[simp, norm_cast]\ntheorem coe_le_coe [LE α] {p : α → Prop} {x y : Subtype p} : (x : α) ≤ y ↔ x ≤ y :=\n  Iff.rfl\n\n"}
{"name":"Subtype.GCongr.coe_le_coe","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LE α\np : α → Prop\nx y : Subtype p\na✝ : LE.le x y\n⊢ LE.le ↑x ↑y","decl":"@[gcongr] alias ⟨_, GCongr.coe_le_coe⟩ := coe_le_coe\n\n"}
{"name":"Subtype.coe_lt_coe","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LT α\np : α → Prop\nx y : Subtype p\n⊢ Iff (LT.lt ↑x ↑y) (LT.lt x y)","decl":"@[simp, norm_cast]\ntheorem coe_lt_coe [LT α] {p : α → Prop} {x y : Subtype p} : (x : α) < y ↔ x < y :=\n  Iff.rfl\n\n"}
{"name":"Subtype.GCongr.coe_lt_coe","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LT α\np : α → Prop\nx y : Subtype p\na✝ : LT.lt x y\n⊢ LT.lt ↑x ↑y","decl":"@[gcongr] alias ⟨_, GCongr.coe_lt_coe⟩ := coe_lt_coe\n\n"}
{"name":"Prod.le_def","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\nx y : Prod α β\n⊢ Iff (LE.le x y) (And (LE.le x.fst y.fst) (LE.le x.snd y.snd))","decl":"theorem le_def [LE α] [LE β] {x y : α × β} : x ≤ y ↔ x.1 ≤ y.1 ∧ x.2 ≤ y.2 :=\n  Iff.rfl\n\n"}
{"name":"Prod.mk_le_mk","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\nx₁ x₂ : α\ny₁ y₂ : β\n⊢ Iff (LE.le { fst := x₁, snd := y₁ } { fst := x₂, snd := y₂ }) (And (LE.le x₁ x₂) (LE.le y₁ y₂))","decl":"@[simp]\ntheorem mk_le_mk [LE α] [LE β] {x₁ x₂ : α} {y₁ y₂ : β} : (x₁, y₁) ≤ (x₂, y₂) ↔ x₁ ≤ x₂ ∧ y₁ ≤ y₂ :=\n  Iff.rfl\n\n"}
{"name":"Prod.swap_le_swap","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : LE α\ninst✝ : LE β\nx y : Prod α β\n⊢ Iff (LE.le x.swap y.swap) (LE.le x y)","decl":"@[simp]\ntheorem swap_le_swap [LE α] [LE β] {x y : α × β} : x.swap ≤ y.swap ↔ x ≤ y :=\n  and_comm\n\n"}
{"name":"Prod.swap_lt_swap","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx y : Prod α β\n⊢ Iff (LT.lt x.swap y.swap) (LT.lt x y)","decl":"@[simp]\ntheorem swap_lt_swap : x.swap < y.swap ↔ x < y :=\n  and_congr swap_le_swap (not_congr swap_le_swap)\n\n"}
{"name":"Prod.mk_le_mk_iff_left","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na₁ a₂ : α\nb : β\n⊢ Iff (LE.le { fst := a₁, snd := b } { fst := a₂, snd := b }) (LE.le a₁ a₂)","decl":"theorem mk_le_mk_iff_left : (a₁, b) ≤ (a₂, b) ↔ a₁ ≤ a₂ :=\n  and_iff_left le_rfl\n\n"}
{"name":"Prod.mk_le_mk_iff_right","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : α\nb₁ b₂ : β\n⊢ Iff (LE.le { fst := a, snd := b₁ } { fst := a, snd := b₂ }) (LE.le b₁ b₂)","decl":"theorem mk_le_mk_iff_right : (a, b₁) ≤ (a, b₂) ↔ b₁ ≤ b₂ :=\n  and_iff_right le_rfl\n\n"}
{"name":"Prod.mk_lt_mk_iff_left","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na₁ a₂ : α\nb : β\n⊢ Iff (LT.lt { fst := a₁, snd := b } { fst := a₂, snd := b }) (LT.lt a₁ a₂)","decl":"theorem mk_lt_mk_iff_left : (a₁, b) < (a₂, b) ↔ a₁ < a₂ :=\n  lt_iff_lt_of_le_iff_le' mk_le_mk_iff_left mk_le_mk_iff_left\n\n"}
{"name":"Prod.mk_lt_mk_iff_right","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : α\nb₁ b₂ : β\n⊢ Iff (LT.lt { fst := a, snd := b₁ } { fst := a, snd := b₂ }) (LT.lt b₁ b₂)","decl":"theorem mk_lt_mk_iff_right : (a, b₁) < (a, b₂) ↔ b₁ < b₂ :=\n  lt_iff_lt_of_le_iff_le' mk_le_mk_iff_right mk_le_mk_iff_right\n\n"}
{"name":"Prod.lt_iff","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx y : Prod α β\n⊢ Iff (LT.lt x y) (Or (And (LT.lt x.fst y.fst) (LE.le x.snd y.snd)) (And (LE.le x.fst y.fst) (LT.lt x.snd y.snd)))","decl":"theorem lt_iff : x < y ↔ x.1 < y.1 ∧ x.2 ≤ y.2 ∨ x.1 ≤ y.1 ∧ x.2 < y.2 := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · by_cases h₁ : y.1 ≤ x.1\n    · exact Or.inr ⟨h.1.1, LE.le.lt_of_not_le h.1.2 fun h₂ ↦ h.2 ⟨h₁, h₂⟩⟩\n    · exact Or.inl ⟨LE.le.lt_of_not_le h.1.1 h₁, h.1.2⟩\n  · rintro (⟨h₁, h₂⟩ | ⟨h₁, h₂⟩)\n    · exact ⟨⟨h₁.le, h₂⟩, fun h ↦ h₁.not_le h.1⟩\n    · exact ⟨⟨h₁, h₂.le⟩, fun h ↦ h₂.not_le h.2⟩\n\n"}
{"name":"Prod.mk_lt_mk","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Iff (LT.lt { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) (Or (And (LT.lt a₁ a₂) (LE.le b₁ b₂)) (And (LE.le a₁ a₂) (LT.lt b₁ b₂)))","decl":"@[simp]\ntheorem mk_lt_mk : (a₁, b₁) < (a₂, b₂) ↔ a₁ < a₂ ∧ b₁ ≤ b₂ ∨ a₁ ≤ a₂ ∧ b₁ < b₂ :=\n  lt_iff\n\n"}
{"name":"Prod.lt_of_lt_of_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx y : Prod α β\nh₁ : LT.lt x.fst y.fst\nh₂ : LE.le x.snd y.snd\n⊢ LT.lt x y","decl":"protected lemma lt_of_lt_of_le (h₁ : x.1 < y.1) (h₂ : x.2 ≤ y.2) : x < y := by simp [lt_iff, *]\n"}
{"name":"Prod.lt_of_le_of_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nx y : Prod α β\nh₁ : LE.le x.fst y.fst\nh₂ : LT.lt x.snd y.snd\n⊢ LT.lt x y","decl":"protected lemma lt_of_le_of_lt (h₁ : x.1 ≤ y.1) (h₂ : x.2 < y.2) : x < y := by simp [lt_iff, *]\n\n"}
{"name":"Prod.mk_lt_mk_of_lt_of_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na₁ a₂ : α\nb₁ b₂ : β\nh₁ : LT.lt a₁ a₂\nh₂ : LE.le b₁ b₂\n⊢ LT.lt { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }","decl":"lemma mk_lt_mk_of_lt_of_le (h₁ : a₁ < a₂) (h₂ : b₁ ≤ b₂) : (a₁, b₁) < (a₂, b₂) := by\n  simp [lt_iff, *]\n\n"}
{"name":"Prod.mk_lt_mk_of_le_of_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na₁ a₂ : α\nb₁ b₂ : β\nh₁ : LE.le a₁ a₂\nh₂ : LT.lt b₁ b₂\n⊢ LT.lt { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }","decl":"lemma mk_lt_mk_of_le_of_lt (h₁ : a₁ ≤ a₂) (h₂ : b₁ < b₂) : (a₁, b₁) < (a₂, b₂) := by\n  simp [lt_iff, *]\n\n"}
{"name":"DenselyOrdered.dense","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_5\ninst✝ : LT α\nself : DenselyOrdered α\na₁ a₂ : α\na✝ : LT.lt a₁ a₂\n⊢ Exists fun a => And (LT.lt a₁ a) (LT.lt a a₂)","decl":"/-- An order is dense if there is an element between any pair of distinct comparable elements. -/\nclass DenselyOrdered (α : Type*) [LT α] : Prop where\n  /-- An order is dense if there is an element between any pair of distinct elements. -/\n  dense : ∀ a₁ a₂ : α, a₁ < a₂ → ∃ a, a₁ < a ∧ a < a₂\n\n"}
{"name":"exists_between","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LT α\ninst✝ : DenselyOrdered α\na₁ a₂ : α\na✝ : LT.lt a₁ a₂\n⊢ Exists fun a => And (LT.lt a₁ a) (LT.lt a a₂)","decl":"theorem exists_between [LT α] [DenselyOrdered α] : ∀ {a₁ a₂ : α}, a₁ < a₂ → ∃ a, a₁ < a ∧ a < a₂ :=\n  DenselyOrdered.dense _ _\n\n"}
{"name":"OrderDual.denselyOrdered","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_5\ninst✝ : LT α\nh : DenselyOrdered α\n⊢ DenselyOrdered (OrderDual α)","decl":"instance OrderDual.denselyOrdered (α : Type*) [LT α] [h : DenselyOrdered α] :\n    DenselyOrdered αᵒᵈ :=\n  ⟨fun _ _ ha ↦ (@exists_between α _ h _ _ ha).imp fun _ ↦ And.symm⟩\n\n"}
{"name":"denselyOrdered_orderDual","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LT α\n⊢ Iff (DenselyOrdered (OrderDual α)) (DenselyOrdered α)","decl":"@[simp]\ntheorem denselyOrdered_orderDual [LT α] : DenselyOrdered αᵒᵈ ↔ DenselyOrdered α :=\n  ⟨by convert @OrderDual.denselyOrdered αᵒᵈ _, @OrderDual.denselyOrdered α _⟩\n\n"}
{"name":"Subsingleton.instDenselyOrdered","module":"Mathlib.Order.Basic","initialProofState":"X : Type u_5\ninst✝¹ : Subsingleton X\ninst✝ : Preorder X\n⊢ DenselyOrdered X","decl":"/-- Any ordered subsingleton is densely ordered. Not an instance to avoid a heavy subsingleton\ntypeclass search. -/\nlemma Subsingleton.instDenselyOrdered {X : Type*} [Subsingleton X] [Preorder X] :\n    DenselyOrdered X :=\n  ⟨fun _ _ h ↦ (not_lt_of_subsingleton h).elim⟩\n\n"}
{"name":"instDenselyOrderedProd","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : DenselyOrdered α\ninst✝ : DenselyOrdered β\n⊢ DenselyOrdered (Prod α β)","decl":"instance [Preorder α] [Preorder β] [DenselyOrdered α] [DenselyOrdered β] : DenselyOrdered (α × β) :=\n  ⟨fun a b ↦ by\n    simp_rw [Prod.lt_iff]\n    rintro (⟨h₁, h₂⟩ | ⟨h₁, h₂⟩)\n    · obtain ⟨c, ha, hb⟩ := exists_between h₁\n      exact ⟨(c, _), Or.inl ⟨ha, h₂⟩, Or.inl ⟨hb, le_rfl⟩⟩\n    · obtain ⟨c, ha, hb⟩ := exists_between h₂\n      exact ⟨(_, c), Or.inr ⟨h₁, ha⟩, Or.inr ⟨le_rfl, hb⟩⟩⟩\n\n"}
{"name":"instDenselyOrderedForall","module":"Mathlib.Order.Basic","initialProofState":"ι : Type u_1\nπ : ι → Type u_4\ninst✝¹ : (i : ι) → Preorder (π i)\ninst✝ : ∀ (i : ι), DenselyOrdered (π i)\n⊢ DenselyOrdered ((i : ι) → π i)","decl":"instance [∀ i, Preorder (π i)] [∀ i, DenselyOrdered (π i)] :\n    DenselyOrdered (∀ i, π i) :=\n  ⟨fun a b ↦ by\n    classical\n      simp_rw [Pi.lt_def]\n      rintro ⟨hab, i, hi⟩\n      obtain ⟨c, ha, hb⟩ := exists_between hi\n      exact\n        ⟨Function.update a i c,\n          ⟨le_update_iff.2 ⟨ha.le, fun _ _ ↦ le_rfl⟩, i, by rwa [update_self]⟩,\n          update_le_iff.2 ⟨hb.le, fun _ _ ↦ hab _⟩, i, by rwa [update_self]⟩⟩\n\n"}
{"name":"le_of_forall_gt_imp_ge_of_dense","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DenselyOrdered α\na₁ a₂ : α\nh : ∀ (a : α), LT.lt a₂ a → LE.le a₁ a\n⊢ LE.le a₁ a₂","decl":"theorem le_of_forall_gt_imp_ge_of_dense (h : ∀ a, a₂ < a → a₁ ≤ a) : a₁ ≤ a₂ :=\n  le_of_not_gt fun ha ↦\n    let ⟨a, ha₁, ha₂⟩ := exists_between ha\n    lt_irrefl a <| lt_of_lt_of_le ‹a < a₁› (h _ ‹a₂ < a›)\n\n"}
{"name":"forall_gt_imp_ge_iff_le_of_dense","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DenselyOrdered α\na₁ a₂ : α\n⊢ Iff (∀ (a : α), LT.lt a₂ a → LE.le a₁ a) (LE.le a₁ a₂)","decl":"lemma forall_gt_imp_ge_iff_le_of_dense : (∀ a, a₂ < a → a₁ ≤ a) ↔ a₁ ≤ a₂ :=\n  ⟨le_of_forall_gt_imp_ge_of_dense, fun ha _a ha₂ ↦ ha.trans ha₂.le⟩\n\n"}
{"name":"eq_of_le_of_forall_lt_imp_le_of_dense","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DenselyOrdered α\na₁ a₂ : α\nh₁ : LE.le a₂ a₁\nh₂ : ∀ (a : α), LT.lt a₂ a → LE.le a₁ a\n⊢ Eq a₁ a₂","decl":"lemma eq_of_le_of_forall_lt_imp_le_of_dense (h₁ : a₂ ≤ a₁) (h₂ : ∀ a, a₂ < a → a₁ ≤ a) : a₁ = a₂ :=\n  le_antisymm (le_of_forall_gt_imp_ge_of_dense h₂) h₁\n\n"}
{"name":"le_of_forall_lt_imp_le_of_dense","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DenselyOrdered α\na₁ a₂ : α\nh : ∀ (a : α), LT.lt a a₁ → LE.le a a₂\n⊢ LE.le a₁ a₂","decl":"theorem le_of_forall_lt_imp_le_of_dense (h : ∀ a < a₁, a ≤ a₂) : a₁ ≤ a₂ :=\n  le_of_not_gt fun ha ↦\n    let ⟨a, ha₁, ha₂⟩ := exists_between ha\n    lt_irrefl a <| lt_of_le_of_lt (h _ ‹a < a₁›) ‹a₂ < a›\n\n"}
{"name":"forall_lt_imp_le_iff_le_of_dense","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DenselyOrdered α\na₁ a₂ : α\n⊢ Iff (∀ (a : α), LT.lt a a₁ → LE.le a a₂) (LE.le a₁ a₂)","decl":"lemma forall_lt_imp_le_iff_le_of_dense : (∀ a < a₁, a ≤ a₂) ↔ a₁ ≤ a₂ :=\n  ⟨le_of_forall_lt_imp_le_of_dense, fun ha _a ha₁ ↦ ha₁.le.trans ha⟩\n\n"}
{"name":"eq_of_le_of_forall_gt_imp_ge_of_dense","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DenselyOrdered α\na₁ a₂ : α\nh₁ : LE.le a₂ a₁\nh₂ : ∀ (a : α), LT.lt a a₁ → LE.le a a₂\n⊢ Eq a₁ a₂","decl":"theorem eq_of_le_of_forall_gt_imp_ge_of_dense (h₁ : a₂ ≤ a₁) (h₂ : ∀ a < a₁, a ≤ a₂) : a₁ = a₂ :=\n  (le_of_forall_lt_imp_le_of_dense h₂).antisymm h₁\n\n"}
{"name":"le_of_forall_le_of_dense","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DenselyOrdered α\na₁ a₂ : α\nh : ∀ (a : α), LT.lt a₂ a → LE.le a₁ a\n⊢ LE.le a₁ a₂","decl":"@[deprecated (since := \"2025-01-21\")]\nalias le_of_forall_le_of_dense := le_of_forall_gt_imp_ge_of_dense\n\n"}
{"name":"le_of_forall_ge_of_dense","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DenselyOrdered α\na₁ a₂ : α\nh : ∀ (a : α), LT.lt a a₁ → LE.le a a₂\n⊢ LE.le a₁ a₂","decl":"@[deprecated (since := \"2025-01-21\")]\nalias le_of_forall_ge_of_dense := le_of_forall_lt_imp_le_of_dense\n\n"}
{"name":"forall_lt_le_iff","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DenselyOrdered α\na₁ a₂ : α\n⊢ Iff (∀ (a : α), LT.lt a a₁ → LE.le a a₂) (LE.le a₁ a₂)","decl":"@[deprecated (since := \"2025-01-21\")] alias forall_lt_le_iff := forall_lt_imp_le_iff_le_of_dense\n"}
{"name":"forall_gt_ge_iff","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DenselyOrdered α\na₁ a₂ : α\n⊢ Iff (∀ (a : α), LT.lt a₂ a → LE.le a₁ a) (LE.le a₁ a₂)","decl":"@[deprecated (since := \"2025-01-21\")] alias forall_gt_ge_iff := forall_gt_imp_ge_iff_le_of_dense\n\n"}
{"name":"eq_of_le_of_forall_le_of_dense","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DenselyOrdered α\na₁ a₂ : α\nh₁ : LE.le a₂ a₁\nh₂ : ∀ (a : α), LT.lt a₂ a → LE.le a₁ a\n⊢ Eq a₁ a₂","decl":"@[deprecated (since := \"2025-01-21\")]\nalias eq_of_le_of_forall_le_of_dense := eq_of_le_of_forall_lt_imp_le_of_dense\n\n"}
{"name":"eq_of_le_of_forall_ge_of_dense","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : DenselyOrdered α\na₁ a₂ : α\nh₁ : LE.le a₂ a₁\nh₂ : ∀ (a : α), LT.lt a a₁ → LE.le a a₂\n⊢ Eq a₁ a₂","decl":"@[deprecated (since := \"2025-01-21\")]\nalias eq_of_le_of_forall_ge_of_dense := eq_of_le_of_forall_gt_imp_ge_of_dense\n\n"}
{"name":"dense_or_discrete","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\na₁ a₂ : α\n⊢ Or (Exists fun a => And (LT.lt a₁ a) (LT.lt a a₂)) (And (∀ (a : α), LT.lt a₁ a → LE.le a₂ a) (∀ (a : α), LT.lt a a₂ → LE.le a a₁))","decl":"theorem dense_or_discrete [LinearOrder α] (a₁ a₂ : α) :\n    (∃ a, a₁ < a ∧ a < a₂) ∨ (∀ a, a₁ < a → a₂ ≤ a) ∧ ∀ a < a₂, a ≤ a₁ :=\n  or_iff_not_imp_left.2 fun h ↦\n    ⟨fun a ha₁ ↦ le_of_not_gt fun ha₂ ↦ h ⟨a, ha₁, ha₂⟩,\n     fun a ha₂ ↦ le_of_not_gt fun ha₁ ↦ h ⟨a, ha₁, ha₂⟩⟩\n\n"}
{"name":"eq_or_eq_or_eq_of_forall_not_lt_lt","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\nh : ∀ ⦃x y z : α⦄, LT.lt x y → LT.lt y z → False\nx y z : α\n⊢ Or (Eq x y) (Or (Eq y z) (Eq x z))","decl":"/-- If a linear order has no elements `x < y < z`, then it has at most two elements. -/\nlemma eq_or_eq_or_eq_of_forall_not_lt_lt [LinearOrder α]\n    (h : ∀ ⦃x y z : α⦄, x < y → y < z → False) (x y z : α) : x = y ∨ y = z ∨ x = z := by\n  by_contra hne\n  simp only [not_or, ← Ne.eq_def] at hne\n  rcases hne.1.lt_or_lt with h₁ | h₁ <;>\n  rcases hne.2.1.lt_or_lt with h₂ | h₂ <;>\n  rcases hne.2.2.lt_or_lt with h₃ | h₃\n  exacts [h h₁ h₂, h h₂ h₃, h h₃ h₂, h h₃ h₁, h h₁ h₃, h h₂ h₃, h h₁ h₃, h h₂ h₁]\n\n"}
{"name":"PUnit.max_eq","module":"Mathlib.Order.Basic","initialProofState":"a b : PUnit.{u_5 + 1}\n⊢ Eq (Max.max a b) PUnit.unit","decl":"theorem max_eq : max a b = unit :=\n  rfl\n\n"}
{"name":"PUnit.min_eq","module":"Mathlib.Order.Basic","initialProofState":"a b : PUnit.{u_5 + 1}\n⊢ Eq (Min.min a b) PUnit.unit","decl":"theorem min_eq : min a b = unit :=\n  rfl\n\n"}
{"name":"PUnit.le","module":"Mathlib.Order.Basic","initialProofState":"a b : PUnit.{u_5 + 1}\n⊢ LE.le a b","decl":"protected theorem le : a ≤ b :=\n  trivial\n\n"}
{"name":"PUnit.not_lt","module":"Mathlib.Order.Basic","initialProofState":"a b : PUnit.{u_5 + 1}\n⊢ Not (LT.lt a b)","decl":"theorem not_lt : ¬a < b :=\n  not_false\n\n"}
{"name":"PUnit.instDenselyOrdered","module":"Mathlib.Order.Basic","initialProofState":"⊢ DenselyOrdered PUnit.{u_5 + 1}","decl":"instance : DenselyOrdered PUnit :=\n  ⟨fun _ _ ↦ False.elim⟩\n\n"}
{"name":"le_Prop_eq","module":"Mathlib.Order.Basic","initialProofState":"⊢ Eq (fun x1 x2 => LE.le x1 x2) fun x1 x2 => x1 → x2","decl":"@[simp]\ntheorem le_Prop_eq : ((· ≤ ·) : Prop → Prop → Prop) = (· → ·) :=\n  rfl\n\n"}
{"name":"subrelation_iff_le","module":"Mathlib.Order.Basic","initialProofState":"α : Type u_2\nr s : α → α → Prop\n⊢ Iff (Subrelation r s) (LE.le r s)","decl":"theorem subrelation_iff_le {r s : α → α → Prop} : Subrelation r s ↔ r ≤ s :=\n  Iff.rfl\n\n"}
