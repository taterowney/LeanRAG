{"name":"MulAction.fst_mem_orbit_of_mem_orbit","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"M : Type u\ninst✝² : Monoid M\nα : Type v\ninst✝¹ : MulAction M α\nβ : Type u_1\ninst✝ : MulAction M β\nx y : Prod α β\nh : Membership.mem (MulAction.orbit M y) x\n⊢ Membership.mem (MulAction.orbit M y.1) x.1","decl":"@[to_additive]\nlemma fst_mem_orbit_of_mem_orbit {x y : α × β} (h : x ∈ MulAction.orbit M y) :\n    x.1 ∈ MulAction.orbit M y.1 := by\n  rcases h with ⟨g, rfl⟩\n  exact mem_orbit _ _\n\n"}
{"name":"AddAction.fst_mem_orbit_of_mem_orbit","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"M : Type u\ninst✝² : AddMonoid M\nα : Type v\ninst✝¹ : AddAction M α\nβ : Type u_1\ninst✝ : AddAction M β\nx y : Prod α β\nh : Membership.mem (AddAction.orbit M y) x\n⊢ Membership.mem (AddAction.orbit M y.1) x.1","decl":"@[to_additive]\nlemma fst_mem_orbit_of_mem_orbit {x y : α × β} (h : x ∈ MulAction.orbit M y) :\n    x.1 ∈ MulAction.orbit M y.1 := by\n  rcases h with ⟨g, rfl⟩\n  exact mem_orbit _ _\n\n"}
{"name":"MulAction.snd_mem_orbit_of_mem_orbit","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"M : Type u\ninst✝² : Monoid M\nα : Type v\ninst✝¹ : MulAction M α\nβ : Type u_1\ninst✝ : MulAction M β\nx y : Prod α β\nh : Membership.mem (MulAction.orbit M y) x\n⊢ Membership.mem (MulAction.orbit M y.2) x.2","decl":"@[to_additive]\nlemma snd_mem_orbit_of_mem_orbit {x y : α × β} (h : x ∈ MulAction.orbit M y) :\n    x.2 ∈ MulAction.orbit M y.2 := by\n  rcases h with ⟨g, rfl⟩\n  exact mem_orbit _ _\n\n"}
{"name":"AddAction.snd_mem_orbit_of_mem_orbit","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"M : Type u\ninst✝² : AddMonoid M\nα : Type v\ninst✝¹ : AddAction M α\nβ : Type u_1\ninst✝ : AddAction M β\nx y : Prod α β\nh : Membership.mem (AddAction.orbit M y) x\n⊢ Membership.mem (AddAction.orbit M y.2) x.2","decl":"@[to_additive]\nlemma snd_mem_orbit_of_mem_orbit {x y : α × β} (h : x ∈ MulAction.orbit M y) :\n    x.2 ∈ MulAction.orbit M y.2 := by\n  rcases h with ⟨g, rfl⟩\n  exact mem_orbit _ _\n\n"}
{"name":"Finite.finite_addAction_orbit","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"M : Type u\ninst✝² : AddMonoid M\nα : Type v\ninst✝¹ : AddAction M α\ninst✝ : Finite M\na : α\n⊢ (AddAction.orbit M a).Finite","decl":"@[to_additive]\nlemma _root_.Finite.finite_mulAction_orbit [Finite M] (a : α) : Set.Finite (orbit M a) :=\n  Set.finite_range _\n\n"}
{"name":"Finite.finite_mulAction_orbit","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"M : Type u\ninst✝² : Monoid M\nα : Type v\ninst✝¹ : MulAction M α\ninst✝ : Finite M\na : α\n⊢ (MulAction.orbit M a).Finite","decl":"@[to_additive]\nlemma _root_.Finite.finite_mulAction_orbit [Finite M] (a : α) : Set.Finite (orbit M a) :=\n  Set.finite_range _\n\n"}
{"name":"MulAction.orbit_eq_univ","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"M : Type u\ninst✝² : Monoid M\nα : Type v\ninst✝¹ : MulAction M α\ninst✝ : MulAction.IsPretransitive M α\na : α\n⊢ Eq (MulAction.orbit M a) Set.univ","decl":"@[to_additive]\ntheorem orbit_eq_univ [IsPretransitive M α] (a : α) : orbit M a = Set.univ :=\n  (surjective_smul M a).range_eq\n\n"}
{"name":"AddAction.orbit_eq_univ","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"M : Type u\ninst✝² : AddMonoid M\nα : Type v\ninst✝¹ : AddAction M α\ninst✝ : AddAction.IsPretransitive M α\na : α\n⊢ Eq (AddAction.orbit M a) Set.univ","decl":"@[to_additive]\ntheorem orbit_eq_univ [IsPretransitive M α] (a : α) : orbit M a = Set.univ :=\n  (surjective_smul M a).range_eq\n\n"}
{"name":"AddAction.mem_fixedPoints_iff_card_orbit_eq_one","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"M : Type u\ninst✝² : AddMonoid M\nα : Type v\ninst✝¹ : AddAction M α\na : α\ninst✝ : Fintype ↑(AddAction.orbit M a)\n⊢ Iff (Membership.mem (AddAction.fixedPoints M α) a) (Eq (Fintype.card ↑(AddAction.orbit M a)) 1)","decl":"@[to_additive mem_fixedPoints_iff_card_orbit_eq_one]\ntheorem mem_fixedPoints_iff_card_orbit_eq_one {a : α} [Fintype (orbit M a)] :\n    a ∈ fixedPoints M α ↔ Fintype.card (orbit M a) = 1 := by\n  rw [Fintype.card_eq_one_iff, mem_fixedPoints]\n  constructor\n  · exact fun h => ⟨⟨a, mem_orbit_self _⟩, fun ⟨a, ⟨x, hx⟩⟩ => Subtype.eq <| by simp [h x, hx.symm]⟩\n  · intro h x\n    rcases h with ⟨⟨z, hz⟩, hz₁⟩\n    calc\n      x • a = z := Subtype.mk.inj (hz₁ ⟨x • a, mem_orbit _ _⟩)\n      _ = a := (Subtype.mk.inj (hz₁ ⟨a, mem_orbit_self _⟩)).symm\n\n"}
{"name":"MulAction.mem_fixedPoints_iff_card_orbit_eq_one","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"M : Type u\ninst✝² : Monoid M\nα : Type v\ninst✝¹ : MulAction M α\na : α\ninst✝ : Fintype ↑(MulAction.orbit M a)\n⊢ Iff (Membership.mem (MulAction.fixedPoints M α) a) (Eq (Fintype.card ↑(MulAction.orbit M a)) 1)","decl":"@[to_additive mem_fixedPoints_iff_card_orbit_eq_one]\ntheorem mem_fixedPoints_iff_card_orbit_eq_one {a : α} [Fintype (orbit M a)] :\n    a ∈ fixedPoints M α ↔ Fintype.card (orbit M a) = 1 := by\n  rw [Fintype.card_eq_one_iff, mem_fixedPoints]\n  constructor\n  · exact fun h => ⟨⟨a, mem_orbit_self _⟩, fun ⟨a, ⟨x, hx⟩⟩ => Subtype.eq <| by simp [h x, hx.symm]⟩\n  · intro h x\n    rcases h with ⟨⟨z, hz⟩, hz₁⟩\n    calc\n      x • a = z := Subtype.mk.inj (hz₁ ⟨x • a, mem_orbit _ _⟩)\n      _ = a := (Subtype.mk.inj (hz₁ ⟨a, mem_orbit_self _⟩)).symm\n\n"}
{"name":"smul_cancel_of_non_zero_divisor","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"M : Type u_1\nR : Type u_2\ninst✝² : Monoid M\ninst✝¹ : NonUnitalNonAssocRing R\ninst✝ : DistribMulAction M R\nk : M\nh : ∀ (x : R), Eq (HSMul.hSMul k x) 0 → Eq x 0\na b : R\nh' : Eq (HSMul.hSMul k a) (HSMul.hSMul k b)\n⊢ Eq a b","decl":"/-- `smul` by a `k : M` over a ring is injective, if `k` is not a zero divisor.\nThe general theory of such `k` is elaborated by `IsSMulRegular`.\nThe typeclass that restricts all terms of `M` to have this property is `NoZeroSMulDivisors`. -/\ntheorem smul_cancel_of_non_zero_divisor {M R : Type*} [Monoid M] [NonUnitalNonAssocRing R]\n    [DistribMulAction M R] (k : M) (h : ∀ x : R, k • x = 0 → x = 0) {a b : R} (h' : k • a = k • b) :\n    a = b := by\n  rw [← sub_eq_zero]\n  refine h _ ?_\n  rw [smul_sub, h', sub_self]\n\n"}
{"name":"AddAction.vadd_orbit","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng : G\na : α\n⊢ Eq (HVAdd.hVAdd g (AddAction.orbit G a)) (AddAction.orbit G a)","decl":"@[to_additive (attr := simp)]\ntheorem smul_orbit (g : G) (a : α) : g • orbit G a = orbit G a :=\n  (smul_orbit_subset g a).antisymm <|\n    calc\n      orbit G a = g • g⁻¹ • orbit G a := (smul_inv_smul _ _).symm\n      _ ⊆ g • orbit G a := Set.image_subset _ (smul_orbit_subset _ _)\n\n"}
{"name":"MulAction.smul_orbit","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng : G\na : α\n⊢ Eq (HSMul.hSMul g (MulAction.orbit G a)) (MulAction.orbit G a)","decl":"@[to_additive (attr := simp)]\ntheorem smul_orbit (g : G) (a : α) : g • orbit G a = orbit G a :=\n  (smul_orbit_subset g a).antisymm <|\n    calc\n      orbit G a = g • g⁻¹ • orbit G a := (smul_inv_smul _ _).symm\n      _ ⊆ g • orbit G a := Set.image_subset _ (smul_orbit_subset _ _)\n\n"}
{"name":"MulAction.instIsPretransitiveElemOrbit","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\na : α\n⊢ MulAction.IsPretransitive G ↑(MulAction.orbit G a)","decl":"/-- The action of a group on an orbit is transitive. -/\n@[to_additive \"The action of an additive group on an orbit is transitive.\"]\ninstance (a : α) : IsPretransitive G (orbit G a) :=\n  ⟨by\n    rintro ⟨_, g, rfl⟩ ⟨_, h, rfl⟩\n    use h * g⁻¹\n    ext1\n    simp [mul_smul]⟩\n\n"}
{"name":"AddAction.instIsPretransitiveElemOrbit","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\na : α\n⊢ AddAction.IsPretransitive G ↑(AddAction.orbit G a)","decl":"/-- The action of a group on an orbit is transitive. -/\n@[to_additive \"The action of an additive group on an orbit is transitive.\"]\ninstance (a : α) : IsPretransitive G (orbit G a) :=\n  ⟨by\n    rintro ⟨_, g, rfl⟩ ⟨_, h, rfl⟩\n    use h * g⁻¹\n    ext1\n    simp [mul_smul]⟩\n\n"}
{"name":"MulAction.orbitRel_subgroup_le","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nH : Subgroup G\n⊢ LE.le (MulAction.orbitRel (Subtype fun x => Membership.mem H x) α) (MulAction.orbitRel G α)","decl":"@[to_additive]\nlemma orbitRel_subgroup_le (H : Subgroup G) : orbitRel H α ≤ orbitRel G α :=\n  Setoid.le_def.2 mem_orbit_of_mem_orbit_subgroup\n\n"}
{"name":"AddAction.orbitRel_addSubgroup_le","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nH : AddSubgroup G\n⊢ LE.le (AddAction.orbitRel (Subtype fun x => Membership.mem H x) α) (AddAction.orbitRel G α)","decl":"@[to_additive]\nlemma orbitRel_subgroup_le (H : Subgroup G) : orbitRel H α ≤ orbitRel G α :=\n  Setoid.le_def.2 mem_orbit_of_mem_orbit_subgroup\n\n"}
{"name":"MulAction.orbitRel_subgroupOf","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nH K : Subgroup G\n⊢ Eq (MulAction.orbitRel (Subtype fun x => Membership.mem (H.subgroupOf K) x) α) (MulAction.orbitRel (Subtype fun x => Membership.mem (Min.min H K) x) α)","decl":"@[to_additive]\nlemma orbitRel_subgroupOf (H K : Subgroup G) :\n    orbitRel (H.subgroupOf K) α = orbitRel (H ⊓ K : Subgroup G) α := by\n  rw [← Subgroup.subgroupOf_map_subtype]\n  ext x\n  simp_rw [orbitRel_apply]\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rcases h with ⟨⟨gv, gp⟩, rfl⟩\n    simp only [Submonoid.mk_smul]\n    refine mem_orbit _ (⟨gv, ?_⟩ : Subgroup.map K.subtype (H.subgroupOf K))\n    simpa using gp\n  · rcases h with ⟨⟨gv, gp⟩, rfl⟩\n    simp only [Submonoid.mk_smul]\n    simp only [Subgroup.subgroupOf_map_subtype, Subgroup.mem_inf] at gp\n    refine mem_orbit _ (⟨⟨gv, ?_⟩, ?_⟩ : H.subgroupOf K)\n    · exact gp.2\n    · simp only [Subgroup.mem_subgroupOf]\n      exact gp.1\n\n"}
{"name":"AddAction.orbitRel_addSubgroupOf","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nH K : AddSubgroup G\n⊢ Eq (AddAction.orbitRel (Subtype fun x => Membership.mem (H.addSubgroupOf K) x) α) (AddAction.orbitRel (Subtype fun x => Membership.mem (Min.min H K) x) α)","decl":"@[to_additive]\nlemma orbitRel_subgroupOf (H K : Subgroup G) :\n    orbitRel (H.subgroupOf K) α = orbitRel (H ⊓ K : Subgroup G) α := by\n  rw [← Subgroup.subgroupOf_map_subtype]\n  ext x\n  simp_rw [orbitRel_apply]\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rcases h with ⟨⟨gv, gp⟩, rfl⟩\n    simp only [Submonoid.mk_smul]\n    refine mem_orbit _ (⟨gv, ?_⟩ : Subgroup.map K.subtype (H.subgroupOf K))\n    simpa using gp\n  · rcases h with ⟨⟨gv, gp⟩, rfl⟩\n    simp only [Submonoid.mk_smul]\n    simp only [Subgroup.subgroupOf_map_subtype, Subgroup.mem_inf] at gp\n    refine mem_orbit _ (⟨⟨gv, ?_⟩, ?_⟩ : H.subgroupOf K)\n    · exact gp.2\n    · simp only [Subgroup.mem_subgroupOf]\n      exact gp.1\n\n"}
{"name":"AddAction.pretransitive_iff_subsingleton_quotient","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\n⊢ Iff (AddAction.IsPretransitive G α) (Subsingleton (AddAction.orbitRel.Quotient G α))","decl":"/-- An action is pretransitive if and only if the quotient by `MulAction.orbitRel` is a\nsubsingleton. -/\n@[to_additive \"An additive action is pretransitive if and only if the quotient by\n`AddAction.orbitRel` is a subsingleton.\"]\ntheorem pretransitive_iff_subsingleton_quotient :\n    IsPretransitive G α ↔ Subsingleton (orbitRel.Quotient G α) := by\n  refine ⟨fun _ ↦ ⟨fun a b ↦ ?_⟩, fun _ ↦ ⟨fun a b ↦ ?_⟩⟩\n  · refine Quot.inductionOn a (fun x ↦ ?_)\n    exact Quot.inductionOn b (fun y ↦ Quot.sound <| exists_smul_eq G y x)\n  · have h : Quotient.mk (orbitRel G α) b = ⟦a⟧ := Subsingleton.elim _ _\n    exact Quotient.eq''.mp h\n\n"}
{"name":"MulAction.pretransitive_iff_subsingleton_quotient","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\n⊢ Iff (MulAction.IsPretransitive G α) (Subsingleton (MulAction.orbitRel.Quotient G α))","decl":"/-- An action is pretransitive if and only if the quotient by `MulAction.orbitRel` is a\nsubsingleton. -/\n@[to_additive \"An additive action is pretransitive if and only if the quotient by\n`AddAction.orbitRel` is a subsingleton.\"]\ntheorem pretransitive_iff_subsingleton_quotient :\n    IsPretransitive G α ↔ Subsingleton (orbitRel.Quotient G α) := by\n  refine ⟨fun _ ↦ ⟨fun a b ↦ ?_⟩, fun _ ↦ ⟨fun a b ↦ ?_⟩⟩\n  · refine Quot.inductionOn a (fun x ↦ ?_)\n    exact Quot.inductionOn b (fun y ↦ Quot.sound <| exists_smul_eq G y x)\n  · have h : Quotient.mk (orbitRel G α) b = ⟦a⟧ := Subsingleton.elim _ _\n    exact Quotient.eq''.mp h\n\n"}
{"name":"AddAction.pretransitive_iff_unique_quotient_of_nonempty","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : Nonempty α\n⊢ Iff (AddAction.IsPretransitive G α) (Nonempty (Unique (AddAction.orbitRel.Quotient G α)))","decl":"/-- If `α` is non-empty, an action is pretransitive if and only if the quotient has exactly one\nelement. -/\n@[to_additive \"If `α` is non-empty, an additive action is pretransitive if and only if the\nquotient has exactly one element.\"]\ntheorem pretransitive_iff_unique_quotient_of_nonempty [Nonempty α] :\n    IsPretransitive G α ↔ Nonempty (Unique <| orbitRel.Quotient G α) := by\n  rw [unique_iff_subsingleton_and_nonempty, pretransitive_iff_subsingleton_quotient, iff_self_and]\n  exact fun _ ↦ (nonempty_quotient_iff _).mpr inferInstance\n\n"}
{"name":"MulAction.pretransitive_iff_unique_quotient_of_nonempty","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : Nonempty α\n⊢ Iff (MulAction.IsPretransitive G α) (Nonempty (Unique (MulAction.orbitRel.Quotient G α)))","decl":"/-- If `α` is non-empty, an action is pretransitive if and only if the quotient has exactly one\nelement. -/\n@[to_additive \"If `α` is non-empty, an additive action is pretransitive if and only if the\nquotient has exactly one element.\"]\ntheorem pretransitive_iff_unique_quotient_of_nonempty [Nonempty α] :\n    IsPretransitive G α ↔ Nonempty (Unique <| orbitRel.Quotient G α) := by\n  rw [unique_iff_subsingleton_and_nonempty, pretransitive_iff_subsingleton_quotient, iff_self_and]\n  exact fun _ ↦ (nonempty_quotient_iff _).mpr inferInstance\n\n"}
{"name":"MulAction.instIsPretransitiveElemOrbit_1","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\nx : MulAction.orbitRel.Quotient G α\n⊢ MulAction.IsPretransitive G ↑x.orbit","decl":"@[to_additive]\ninstance (x : orbitRel.Quotient G α) : IsPretransitive G x.orbit where\n  exists_smul_eq := by\n    induction x using Quotient.inductionOn'\n    rintro ⟨y, yh⟩ ⟨z, zh⟩\n    rw [orbitRel.Quotient.mem_orbit, Quotient.eq''] at yh zh\n    rcases yh with ⟨g, rfl⟩\n    rcases zh with ⟨h, rfl⟩\n    refine ⟨h * g⁻¹, ?_⟩\n    ext\n    simp [mul_smul]\n\n"}
{"name":"AddAction.instIsPretransitiveElemOrbit_1","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\nx : AddAction.orbitRel.Quotient G α\n⊢ AddAction.IsPretransitive G ↑x.orbit","decl":"@[to_additive]\ninstance (x : orbitRel.Quotient G α) : IsPretransitive G x.orbit where\n  exists_smul_eq := by\n    induction x using Quotient.inductionOn'\n    rintro ⟨y, yh⟩ ⟨z, zh⟩\n    rw [orbitRel.Quotient.mem_orbit, Quotient.eq''] at yh zh\n    rcases yh with ⟨g, rfl⟩\n    rcases zh with ⟨h, rfl⟩\n    refine ⟨h * g⁻¹, ?_⟩\n    ext\n    simp [mul_smul]\n\n"}
{"name":"Finite.of_finite_mulAction_orbitRel_quotient","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝³ : Group G\ninst✝² : MulAction G α\ninst✝¹ : Finite G\ninst✝ : Finite (MulAction.orbitRel.Quotient G α)\n⊢ Finite α","decl":"@[to_additive]\nlemma _root_.Finite.of_finite_mulAction_orbitRel_quotient [Finite G] [Finite Ω] : Finite α := by\n  rw [(selfEquivSigmaOrbits' G _).finite_iff]\n  have : ∀ g : Ω, Finite g.orbit := by\n    intro g\n    induction g using Quotient.inductionOn'\n    simpa [Set.finite_coe_iff] using Finite.finite_mulAction_orbit _\n  exact Finite.instSigma\n\n"}
{"name":"Finite.of_finite_addAction_orbitRel_quotient","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝³ : AddGroup G\ninst✝² : AddAction G α\ninst✝¹ : Finite G\ninst✝ : Finite (AddAction.orbitRel.Quotient G α)\n⊢ Finite α","decl":"@[to_additive]\nlemma _root_.Finite.of_finite_mulAction_orbitRel_quotient [Finite G] [Finite Ω] : Finite α := by\n  rw [(selfEquivSigmaOrbits' G _).finite_iff]\n  have : ∀ g : Ω, Finite g.orbit := by\n    intro g\n    induction g using Quotient.inductionOn'\n    simpa [Set.finite_coe_iff] using Finite.finite_mulAction_orbit _\n  exact Finite.instSigma\n\n"}
{"name":"AddAction.orbitRel_le_fst","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : AddAction G β\n⊢ LE.le (AddAction.orbitRel G (Prod α β)) (Setoid.comap Prod.fst (AddAction.orbitRel G α))","decl":"@[to_additive]\nlemma orbitRel_le_fst :\n    orbitRel G (α × β) ≤ (orbitRel G α).comap Prod.fst :=\n  Setoid.le_def.2 fst_mem_orbit_of_mem_orbit\n\n"}
{"name":"MulAction.orbitRel_le_fst","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MulAction G β\n⊢ LE.le (MulAction.orbitRel G (Prod α β)) (Setoid.comap Prod.fst (MulAction.orbitRel G α))","decl":"@[to_additive]\nlemma orbitRel_le_fst :\n    orbitRel G (α × β) ≤ (orbitRel G α).comap Prod.fst :=\n  Setoid.le_def.2 fst_mem_orbit_of_mem_orbit\n\n"}
{"name":"MulAction.orbitRel_le_snd","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝² : Group G\ninst✝¹ : MulAction G α\ninst✝ : MulAction G β\n⊢ LE.le (MulAction.orbitRel G (Prod α β)) (Setoid.comap Prod.snd (MulAction.orbitRel G β))","decl":"@[to_additive]\nlemma orbitRel_le_snd :\n    orbitRel G (α × β) ≤ (orbitRel G β).comap Prod.snd :=\n  Setoid.le_def.2 snd_mem_orbit_of_mem_orbit\n\n"}
{"name":"AddAction.orbitRel_le_snd","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\ninst✝ : AddAction G β\n⊢ LE.le (AddAction.orbitRel G (Prod α β)) (Setoid.comap Prod.snd (AddAction.orbitRel G β))","decl":"@[to_additive]\nlemma orbitRel_le_snd :\n    orbitRel G (α × β) ≤ (orbitRel G β).comap Prod.snd :=\n  Setoid.le_def.2 snd_mem_orbit_of_mem_orbit\n\n"}
{"name":"MulAction.stabilizer_smul_eq_stabilizer_map_conj","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng : G\na : α\n⊢ Eq (MulAction.stabilizer G (HSMul.hSMul g a)) (Subgroup.map (MulEquiv.toMonoidHom (MulAut.conj g)) (MulAction.stabilizer G a))","decl":"/-- If the stabilizer of `a` is `S`, then the stabilizer of `g • a` is `gSg⁻¹`. -/\ntheorem stabilizer_smul_eq_stabilizer_map_conj (g : G) (a : α) :\n    stabilizer G (g • a) = (stabilizer G a).map (MulAut.conj g).toMonoidHom := by\n  ext h\n  rw [mem_stabilizer_iff, ← smul_left_cancel_iff g⁻¹, smul_smul, smul_smul, smul_smul,\n    inv_mul_cancel, one_smul, ← mem_stabilizer_iff, Subgroup.mem_map_equiv, MulAut.conj_symm_apply]\n\n"}
{"name":"AddAction.stabilizer_vadd_eq_stabilizer_map_conj","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\nα : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng : G\na : α\n⊢ Eq (AddAction.stabilizer G (HVAdd.hVAdd g a)) (AddSubgroup.map (AddEquiv.toAddMonoidHom (AddAut.conj g)) (AddAction.stabilizer G a))","decl":"/-- If the stabilizer of `x` is `S`, then the stabilizer of `g +ᵥ x` is `g + S + (-g)`. -/\ntheorem stabilizer_vadd_eq_stabilizer_map_conj (g : G) (a : α) :\n    stabilizer G (g +ᵥ a) = (stabilizer G a).map (AddAut.conj g).toAddMonoidHom := by\n  ext h\n  rw [mem_stabilizer_iff, ← vadd_left_cancel_iff (-g), vadd_vadd, vadd_vadd, vadd_vadd,\n    neg_add_cancel, zero_vadd, ← mem_stabilizer_iff, AddSubgroup.mem_map_equiv,\n    AddAut.conj_symm_apply]\n\n"}
{"name":"Equiv.swap_mem_stabilizer","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nS : Set α\na b : α\n⊢ Iff (Membership.mem (MulAction.stabilizer (Equiv.Perm α) S) (Equiv.swap a b)) (Iff (Membership.mem S a) (Membership.mem S b))","decl":"theorem Equiv.swap_mem_stabilizer {α : Type*} [DecidableEq α] {S : Set α} {a b : α} :\n    Equiv.swap a b ∈ MulAction.stabilizer (Equiv.Perm α) S ↔ (a ∈ S ↔ b ∈ S) := by\n  rw [MulAction.mem_stabilizer_iff, Set.ext_iff, ← swap_inv]\n  simp_rw [Set.mem_inv_smul_set_iff, Perm.smul_def, swap_apply_def]\n  exact ⟨fun h ↦ by simpa [Iff.comm] using h a, by intros; split_ifs <;> simp [*]⟩\n\n\n"}
{"name":"AddAction.le_stabilizer_iff_vadd_le","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nα : Type u_2\ninst✝ : AddAction G α\ns : Set α\nH : AddSubgroup G\n⊢ Iff (LE.le H (AddAction.stabilizer G s)) (∀ (g : G), Membership.mem H g → HasSubset.Subset (HVAdd.hVAdd g s) s)","decl":"/-- To prove inclusion of a *subgroup* in a stabilizer, it is enough to prove inclusions.-/\n@[to_additive\n  \"To prove inclusion of a *subgroup* in a stabilizer, it is enough to prove inclusions.\"]\ntheorem le_stabilizer_iff_smul_le (s : Set α) (H : Subgroup G) :\n    H ≤ stabilizer G s ↔ ∀ g ∈ H, g • s ⊆ s := by\n  constructor\n  · intro hyp g hg\n    apply Eq.subset\n    rw [← mem_stabilizer_iff]\n    exact hyp hg\n  · intro hyp g hg\n    rw [mem_stabilizer_iff]\n    apply subset_antisymm (hyp g hg)\n    intro x hx\n    use g⁻¹ • x\n    constructor\n    · apply hyp g⁻¹ (inv_mem hg)\n      simp only [Set.smul_mem_smul_set_iff, hx]\n    · simp only [smul_inv_smul]\n\n"}
{"name":"MulAction.le_stabilizer_iff_smul_le","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nα : Type u_2\ninst✝ : MulAction G α\ns : Set α\nH : Subgroup G\n⊢ Iff (LE.le H (MulAction.stabilizer G s)) (∀ (g : G), Membership.mem H g → HasSubset.Subset (HSMul.hSMul g s) s)","decl":"/-- To prove inclusion of a *subgroup* in a stabilizer, it is enough to prove inclusions.-/\n@[to_additive\n  \"To prove inclusion of a *subgroup* in a stabilizer, it is enough to prove inclusions.\"]\ntheorem le_stabilizer_iff_smul_le (s : Set α) (H : Subgroup G) :\n    H ≤ stabilizer G s ↔ ∀ g ∈ H, g • s ⊆ s := by\n  constructor\n  · intro hyp g hg\n    apply Eq.subset\n    rw [← mem_stabilizer_iff]\n    exact hyp hg\n  · intro hyp g hg\n    rw [mem_stabilizer_iff]\n    apply subset_antisymm (hyp g hg)\n    intro x hx\n    use g⁻¹ • x\n    constructor\n    · apply hyp g⁻¹ (inv_mem hg)\n      simp only [Set.smul_mem_smul_set_iff, hx]\n    · simp only [smul_inv_smul]\n\n"}
{"name":"Module.stabilizer_units_eq_bot_of_ne_zero","module":"Mathlib.GroupTheory.GroupAction.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nx : M\nhx : Ne x 0\n⊢ Eq (MulAction.stabilizer (Units R) x) Bot.bot","decl":"variable {M} in\nlemma Module.stabilizer_units_eq_bot_of_ne_zero {x : M} (hx : x ≠ 0) :\n    MulAction.stabilizer Rˣ x = ⊥ := by\n  rw [eq_bot_iff]\n  intro g (hg : g.val • x = x)\n  ext\n  rw [← sub_eq_zero, ← smul_eq_zero_iff_left hx, Units.val_one, sub_smul, hg, one_smul, sub_self]\n\n"}
