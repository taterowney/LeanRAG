{"name":"MvPolynomial.pUnitAlgEquiv_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : MvPolynomial PUnit.{u_2 + 1} R\n⊢ Eq ((MvPolynomial.pUnitAlgEquiv R) p) (MvPolynomial.eval₂ Polynomial.C (fun x => Polynomial.X) p)","decl":"/-- The ring isomorphism between multivariable polynomials in a single variable and\npolynomials over the ground ring.\n-/\n@[simps]\ndef pUnitAlgEquiv : MvPolynomial PUnit R ≃ₐ[R] R[X] where\n  toFun := eval₂ Polynomial.C fun _ => Polynomial.X\n  invFun := Polynomial.eval₂ MvPolynomial.C (X PUnit.unit)\n  left_inv := by\n    let f : R[X] →+* MvPolynomial PUnit R := Polynomial.eval₂RingHom MvPolynomial.C (X PUnit.unit)\n    let g : MvPolynomial PUnit R →+* R[X] := eval₂Hom Polynomial.C fun _ => Polynomial.X\n    show ∀ p, f.comp g p = p\n    apply is_id\n    · ext a\n      dsimp [f, g]\n      rw [eval₂_C, Polynomial.eval₂_C]\n    · rintro ⟨⟩\n      dsimp [f, g]\n      rw [eval₂_X, Polynomial.eval₂_X]\n  right_inv p :=\n    Polynomial.induction_on p (fun a => by rw [Polynomial.eval₂_C, MvPolynomial.eval₂_C])\n    (fun p q hp hq => by rw [Polynomial.eval₂_add, MvPolynomial.eval₂_add, hp, hq]) fun p n _ => by\n      rw [Polynomial.eval₂_mul, Polynomial.eval₂_pow, Polynomial.eval₂_X, Polynomial.eval₂_C,\n        eval₂_mul, eval₂_C, eval₂_pow, eval₂_X]\n  map_mul' _ _ := eval₂_mul _ _\n  map_add' _ _ := eval₂_add _ _\n  commutes' _ := eval₂_C _ _ _\n\n"}
{"name":"MvPolynomial.pUnitAlgEquiv_symm_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Polynomial R\n⊢ Eq ((MvPolynomial.pUnitAlgEquiv R).symm p) (Polynomial.eval₂ MvPolynomial.C (MvPolynomial.X PUnit.unit) p)","decl":"/-- The ring isomorphism between multivariable polynomials in a single variable and\npolynomials over the ground ring.\n-/\n@[simps]\ndef pUnitAlgEquiv : MvPolynomial PUnit R ≃ₐ[R] R[X] where\n  toFun := eval₂ Polynomial.C fun _ => Polynomial.X\n  invFun := Polynomial.eval₂ MvPolynomial.C (X PUnit.unit)\n  left_inv := by\n    let f : R[X] →+* MvPolynomial PUnit R := Polynomial.eval₂RingHom MvPolynomial.C (X PUnit.unit)\n    let g : MvPolynomial PUnit R →+* R[X] := eval₂Hom Polynomial.C fun _ => Polynomial.X\n    show ∀ p, f.comp g p = p\n    apply is_id\n    · ext a\n      dsimp [f, g]\n      rw [eval₂_C, Polynomial.eval₂_C]\n    · rintro ⟨⟩\n      dsimp [f, g]\n      rw [eval₂_X, Polynomial.eval₂_X]\n  right_inv p :=\n    Polynomial.induction_on p (fun a => by rw [Polynomial.eval₂_C, MvPolynomial.eval₂_C])\n    (fun p q hp hq => by rw [Polynomial.eval₂_add, MvPolynomial.eval₂_add, hp, hq]) fun p n _ => by\n      rw [Polynomial.eval₂_mul, Polynomial.eval₂_pow, Polynomial.eval₂_X, Polynomial.eval₂_C,\n        eval₂_mul, eval₂_C, eval₂_pow, eval₂_X]\n  map_mul' _ _ := eval₂_mul _ _\n  map_add' _ _ := eval₂_add _ _\n  commutes' _ := eval₂_C _ _ _\n\n"}
{"name":"MvPolynomial.mapEquiv_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"S₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝¹ : CommSemiring S₁\ninst✝ : CommSemiring S₂\ne : RingEquiv S₁ S₂\na : MvPolynomial σ S₁\n⊢ Eq ((MvPolynomial.mapEquiv σ e) a) ((MvPolynomial.map ↑e) a)","decl":"/-- If `e : A ≃+* B` is an isomorphism of rings, then so is `map e`. -/\n@[simps apply]\ndef mapEquiv [CommSemiring S₁] [CommSemiring S₂] (e : S₁ ≃+* S₂) :\n    MvPolynomial σ S₁ ≃+* MvPolynomial σ S₂ :=\n  { map (e : S₁ →+* S₂) with\n    toFun := map (e : S₁ →+* S₂)\n    invFun := map (e.symm : S₂ →+* S₁)\n    left_inv := map_leftInverse e.left_inv\n    right_inv := map_rightInverse e.right_inv }\n\n"}
{"name":"MvPolynomial.mapEquiv_refl","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.mapEquiv σ (RingEquiv.refl R)) (RingEquiv.refl (MvPolynomial σ R))","decl":"@[simp]\ntheorem mapEquiv_refl : mapEquiv σ (RingEquiv.refl R) = RingEquiv.refl _ :=\n  RingEquiv.ext map_id\n\n"}
{"name":"MvPolynomial.mapEquiv_symm","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"S₁ : Type v\nS₂ : Type w\nσ : Type u_1\ninst✝¹ : CommSemiring S₁\ninst✝ : CommSemiring S₂\ne : RingEquiv S₁ S₂\n⊢ Eq (MvPolynomial.mapEquiv σ e).symm (MvPolynomial.mapEquiv σ e.symm)","decl":"@[simp]\ntheorem mapEquiv_symm [CommSemiring S₁] [CommSemiring S₂] (e : S₁ ≃+* S₂) :\n    (mapEquiv σ e).symm = mapEquiv σ e.symm :=\n  rfl\n\n"}
{"name":"MvPolynomial.mapEquiv_trans","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"S₁ : Type v\nS₂ : Type w\nS₃ : Type x\nσ : Type u_1\ninst✝² : CommSemiring S₁\ninst✝¹ : CommSemiring S₂\ninst✝ : CommSemiring S₃\ne : RingEquiv S₁ S₂\nf : RingEquiv S₂ S₃\n⊢ Eq ((MvPolynomial.mapEquiv σ e).trans (MvPolynomial.mapEquiv σ f)) (MvPolynomial.mapEquiv σ (e.trans f))","decl":"@[simp]\ntheorem mapEquiv_trans [CommSemiring S₁] [CommSemiring S₂] [CommSemiring S₃] (e : S₁ ≃+* S₂)\n    (f : S₂ ≃+* S₃) : (mapEquiv σ e).trans (mapEquiv σ f) = mapEquiv σ (e.trans f) :=\n  RingEquiv.ext fun p => by\n    simp only [RingEquiv.coe_trans, comp_apply, mapEquiv_apply, RingEquiv.coe_ringHom_trans,\n      map_map]\n\n"}
{"name":"MvPolynomial.mapAlgEquiv_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nσ : Type u_1\ninst✝⁴ : CommSemiring R\nA₁ : Type u_2\nA₂ : Type u_3\ninst✝³ : CommSemiring A₁\ninst✝² : CommSemiring A₂\ninst✝¹ : Algebra R A₁\ninst✝ : Algebra R A₂\ne : AlgEquiv R A₁ A₂\na : MvPolynomial σ A₁\n⊢ Eq ((MvPolynomial.mapAlgEquiv σ e) a) ((MvPolynomial.map ↑e) a)","decl":"/-- If `e : A ≃ₐ[R] B` is an isomorphism of `R`-algebras, then so is `map e`. -/\n@[simps apply]\ndef mapAlgEquiv (e : A₁ ≃ₐ[R] A₂) : MvPolynomial σ A₁ ≃ₐ[R] MvPolynomial σ A₂ :=\n  { mapAlgHom (e : A₁ →ₐ[R] A₂), mapEquiv σ (e : A₁ ≃+* A₂) with toFun := map (e : A₁ →+* A₂) }\n\n"}
{"name":"MvPolynomial.mapAlgEquiv_refl","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nσ : Type u_1\ninst✝² : CommSemiring R\nA₁ : Type u_2\ninst✝¹ : CommSemiring A₁\ninst✝ : Algebra R A₁\n⊢ Eq (MvPolynomial.mapAlgEquiv σ AlgEquiv.refl) AlgEquiv.refl","decl":"@[simp]\ntheorem mapAlgEquiv_refl : mapAlgEquiv σ (AlgEquiv.refl : A₁ ≃ₐ[R] A₁) = AlgEquiv.refl :=\n  AlgEquiv.ext map_id\n\n"}
{"name":"MvPolynomial.mapAlgEquiv_symm","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nσ : Type u_1\ninst✝⁴ : CommSemiring R\nA₁ : Type u_2\nA₂ : Type u_3\ninst✝³ : CommSemiring A₁\ninst✝² : CommSemiring A₂\ninst✝¹ : Algebra R A₁\ninst✝ : Algebra R A₂\ne : AlgEquiv R A₁ A₂\n⊢ Eq (MvPolynomial.mapAlgEquiv σ e).symm (MvPolynomial.mapAlgEquiv σ e.symm)","decl":"@[simp]\ntheorem mapAlgEquiv_symm (e : A₁ ≃ₐ[R] A₂) : (mapAlgEquiv σ e).symm = mapAlgEquiv σ e.symm :=\n  rfl\n\n"}
{"name":"MvPolynomial.mapAlgEquiv_trans","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nσ : Type u_1\ninst✝⁶ : CommSemiring R\nA₁ : Type u_2\nA₂ : Type u_3\nA₃ : Type u_4\ninst✝⁵ : CommSemiring A₁\ninst✝⁴ : CommSemiring A₂\ninst✝³ : CommSemiring A₃\ninst✝² : Algebra R A₁\ninst✝¹ : Algebra R A₂\ninst✝ : Algebra R A₃\ne : AlgEquiv R A₁ A₂\nf : AlgEquiv R A₂ A₃\n⊢ Eq ((MvPolynomial.mapAlgEquiv σ e).trans (MvPolynomial.mapAlgEquiv σ f)) (MvPolynomial.mapAlgEquiv σ (e.trans f))","decl":"@[simp]\ntheorem mapAlgEquiv_trans (e : A₁ ≃ₐ[R] A₂) (f : A₂ ≃ₐ[R] A₃) :\n    (mapAlgEquiv σ e).trans (mapAlgEquiv σ f) = mapAlgEquiv σ (e.trans f) := by\n  ext\n  simp only [AlgEquiv.trans_apply, mapAlgEquiv_apply, map_map]\n  rfl\n\n"}
{"name":"MvPolynomial.sumToIter_C","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\ninst✝ : CommSemiring R\na : R\n⊢ Eq ((MvPolynomial.sumToIter R S₁ S₂) (MvPolynomial.C a)) (MvPolynomial.C (MvPolynomial.C a))","decl":"@[simp]\ntheorem sumToIter_C (a : R) : sumToIter R S₁ S₂ (C a) = C (C a) :=\n  eval₂_C _ _ a\n\n"}
{"name":"MvPolynomial.sumToIter_Xl","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\ninst✝ : CommSemiring R\nb : S₁\n⊢ Eq ((MvPolynomial.sumToIter R S₁ S₂) (MvPolynomial.X (Sum.inl b))) (MvPolynomial.X b)","decl":"@[simp]\ntheorem sumToIter_Xl (b : S₁) : sumToIter R S₁ S₂ (X (Sum.inl b)) = X b :=\n  eval₂_X _ _ (Sum.inl b)\n\n"}
{"name":"MvPolynomial.sumToIter_Xr","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\ninst✝ : CommSemiring R\nc : S₂\n⊢ Eq ((MvPolynomial.sumToIter R S₁ S₂) (MvPolynomial.X (Sum.inr c))) (MvPolynomial.C (MvPolynomial.X c))","decl":"@[simp]\ntheorem sumToIter_Xr (c : S₂) : sumToIter R S₁ S₂ (X (Sum.inr c)) = C (X c) :=\n  eval₂_X _ _ (Sum.inr c)\n\n"}
{"name":"MvPolynomial.iterToSum_C_C","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\ninst✝ : CommSemiring R\na : R\n⊢ Eq ((MvPolynomial.iterToSum R S₁ S₂) (MvPolynomial.C (MvPolynomial.C a))) (MvPolynomial.C a)","decl":"@[simp]\ntheorem iterToSum_C_C (a : R) : iterToSum R S₁ S₂ (C (C a)) = C a :=\n  Eq.trans (eval₂_C _ _ (C a)) (eval₂_C _ _ _)\n\n"}
{"name":"MvPolynomial.iterToSum_X","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\ninst✝ : CommSemiring R\nb : S₁\n⊢ Eq ((MvPolynomial.iterToSum R S₁ S₂) (MvPolynomial.X b)) (MvPolynomial.X (Sum.inl b))","decl":"@[simp]\ntheorem iterToSum_X (b : S₁) : iterToSum R S₁ S₂ (X b) = X (Sum.inl b) :=\n  eval₂_X _ _ _\n\n"}
{"name":"MvPolynomial.iterToSum_C_X","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\ninst✝ : CommSemiring R\nc : S₂\n⊢ Eq ((MvPolynomial.iterToSum R S₁ S₂) (MvPolynomial.C (MvPolynomial.X c))) (MvPolynomial.X (Sum.inr c))","decl":"@[simp]\ntheorem iterToSum_C_X (c : S₂) : iterToSum R S₁ S₂ (C (X c)) = X (Sum.inr c) :=\n  Eq.trans (eval₂_C _ _ (X c)) (eval₂_X _ _ _)\n\n"}
{"name":"MvPolynomial.isEmptyAlgEquiv_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : IsEmpty σ\na : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.isEmptyAlgEquiv R σ) a) ((MvPolynomial.aeval fun a => isEmptyElim a) a)","decl":"variable (σ) in\n/-- The algebra isomorphism between multivariable polynomials in no variables\nand the ground ring. -/\n@[simps! apply]\ndef isEmptyAlgEquiv : MvPolynomial σ R ≃ₐ[R] R :=\n  .ofAlgHom (aeval isEmptyElim) (Algebra.ofId _ _) (by ext) (by ext i m; exact isEmptyElim i)\n\n"}
{"name":"MvPolynomial.aeval_injective_iff_of_isEmpty","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\nσ : Type u_1\ninst✝³ : CommSemiring R\ninst✝² : IsEmpty σ\ninst✝¹ : CommSemiring S₁\ninst✝ : Algebra R S₁\nf : σ → S₁\n⊢ Iff (Function.Injective ⇑(MvPolynomial.aeval f)) (Function.Injective ⇑(algebraMap R S₁))","decl":"variable {R S₁} in\n@[simp]\nlemma aeval_injective_iff_of_isEmpty [CommSemiring S₁] [Algebra R S₁] {f : σ → S₁} :\n    Function.Injective (aeval f : MvPolynomial σ R →ₐ[R] S₁) ↔\n      Function.Injective (algebraMap R S₁) := by\n  have : aeval f = (Algebra.ofId R S₁).comp (@isEmptyAlgEquiv R σ _ _).toAlgHom := by\n    ext i\n    exact IsEmpty.elim' ‹IsEmpty σ› i\n  rw [this, ← Injective.of_comp_iff' _ (@isEmptyAlgEquiv R σ _ _).bijective]\n  rfl\n\n"}
{"name":"MvPolynomial.isEmptyRingEquiv_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : IsEmpty σ\na : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.isEmptyRingEquiv R σ) a) ((MvPolynomial.aeval fun a => isEmptyElim a) a)","decl":"variable (σ) in\n/-- The ring isomorphism between multivariable polynomials in no variables\nand the ground ring. -/\n@[simps! apply]\ndef isEmptyRingEquiv : MvPolynomial σ R ≃+* R := (isEmptyAlgEquiv R σ).toRingEquiv\n\n"}
{"name":"MvPolynomial.isEmptyRingEquiv_symm_toRingHom","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : IsEmpty σ\n⊢ Eq (MvPolynomial.isEmptyRingEquiv R σ).symm.toRingHom MvPolynomial.C","decl":"lemma isEmptyRingEquiv_symm_toRingHom : (isEmptyRingEquiv R σ).symm.toRingHom = C := rfl\n"}
{"name":"MvPolynomial.isEmptyRingEquiv_symm_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nσ : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : IsEmpty σ\nr : R\n⊢ Eq ((MvPolynomial.isEmptyRingEquiv R σ).symm r) (MvPolynomial.C r)","decl":"@[simp] lemma isEmptyRingEquiv_symm_apply (r : R) : (isEmptyRingEquiv R σ).symm r = C r := rfl\n\n"}
{"name":"MvPolynomial.isEmptyRingEquiv_eq_coeff_zero","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"σ : Type u_2\nR : Type u_3\ninst✝¹ : CommSemiring R\ninst✝ : IsEmpty σ\nx : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.isEmptyRingEquiv R σ) x) (MvPolynomial.coeff 0 x)","decl":"lemma isEmptyRingEquiv_eq_coeff_zero {σ R : Type*} [CommSemiring R] [IsEmpty σ] {x} :\n    isEmptyRingEquiv R σ x = x.coeff 0 := by\n  obtain ⟨x, rfl⟩ := (isEmptyRingEquiv R σ).symm.surjective x; simp\n\n"}
{"name":"MvPolynomial.mvPolynomialEquivMvPolynomial_symm_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nS₃ : Type x\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₃\nf : RingHom (MvPolynomial S₁ R) (MvPolynomial S₂ S₃)\ng : RingHom (MvPolynomial S₂ S₃) (MvPolynomial S₁ R)\nhfgC : Eq ((f.comp g).comp MvPolynomial.C) MvPolynomial.C\nhfgX : ∀ (n : S₂), Eq (f (g (MvPolynomial.X n))) (MvPolynomial.X n)\nhgfC : Eq ((g.comp f).comp MvPolynomial.C) MvPolynomial.C\nhgfX : ∀ (n : S₁), Eq (g (f (MvPolynomial.X n))) (MvPolynomial.X n)\na : MvPolynomial S₂ S₃\n⊢ Eq ((MvPolynomial.mvPolynomialEquivMvPolynomial R S₁ S₂ S₃ f g hfgC hfgX hgfC hgfX).symm a) (g a)","decl":"/-- A helper function for `sumRingEquiv`. -/\n@[simps]\ndef mvPolynomialEquivMvPolynomial [CommSemiring S₃] (f : MvPolynomial S₁ R →+* MvPolynomial S₂ S₃)\n    (g : MvPolynomial S₂ S₃ →+* MvPolynomial S₁ R) (hfgC : (f.comp g).comp C = C)\n    (hfgX : ∀ n, f (g (X n)) = X n) (hgfC : (g.comp f).comp C = C) (hgfX : ∀ n, g (f (X n)) = X n) :\n    MvPolynomial S₁ R ≃+* MvPolynomial S₂ S₃ where\n  toFun := f\n  invFun := g\n  left_inv := is_id (RingHom.comp _ _) hgfC hgfX\n  right_inv := is_id (RingHom.comp _ _) hfgC hfgX\n  map_mul' := f.map_mul\n  map_add' := f.map_add\n\n"}
{"name":"MvPolynomial.mvPolynomialEquivMvPolynomial_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\nS₃ : Type x\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S₃\nf : RingHom (MvPolynomial S₁ R) (MvPolynomial S₂ S₃)\ng : RingHom (MvPolynomial S₂ S₃) (MvPolynomial S₁ R)\nhfgC : Eq ((f.comp g).comp MvPolynomial.C) MvPolynomial.C\nhfgX : ∀ (n : S₂), Eq (f (g (MvPolynomial.X n))) (MvPolynomial.X n)\nhgfC : Eq ((g.comp f).comp MvPolynomial.C) MvPolynomial.C\nhgfX : ∀ (n : S₁), Eq (g (f (MvPolynomial.X n))) (MvPolynomial.X n)\na : MvPolynomial S₁ R\n⊢ Eq ((MvPolynomial.mvPolynomialEquivMvPolynomial R S₁ S₂ S₃ f g hfgC hfgX hgfC hgfX) a) (f a)","decl":"/-- A helper function for `sumRingEquiv`. -/\n@[simps]\ndef mvPolynomialEquivMvPolynomial [CommSemiring S₃] (f : MvPolynomial S₁ R →+* MvPolynomial S₂ S₃)\n    (g : MvPolynomial S₂ S₃ →+* MvPolynomial S₁ R) (hfgC : (f.comp g).comp C = C)\n    (hfgX : ∀ n, f (g (X n)) = X n) (hgfC : (g.comp f).comp C = C) (hgfX : ∀ n, g (f (X n)) = X n) :\n    MvPolynomial S₁ R ≃+* MvPolynomial S₂ S₃ where\n  toFun := f\n  invFun := g\n  left_inv := is_id (RingHom.comp _ _) hgfC hgfX\n  right_inv := is_id (RingHom.comp _ _) hfgC hfgX\n  map_mul' := f.map_mul\n  map_add' := f.map_add\n\n"}
{"name":"MvPolynomial.sumAlgEquiv_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\ninst✝ : CommSemiring R\na : MvPolynomial (Sum S₁ S₂) R\n⊢ Eq ((MvPolynomial.sumAlgEquiv R S₁ S₂) a) ((MvPolynomial.sumToIter R S₁ S₂) a)","decl":"/-- The algebra isomorphism between multivariable polynomials in a sum of two types,\nand multivariable polynomials in one of the types,\nwith coefficients in multivariable polynomials in the other type.\n-/\n@[simps!]\ndef sumAlgEquiv : MvPolynomial (S₁ ⊕ S₂) R ≃ₐ[R] MvPolynomial S₁ (MvPolynomial S₂ R) :=\n  { sumRingEquiv R S₁ S₂ with\n    commutes' := by\n      intro r\n      have A : algebraMap R (MvPolynomial S₁ (MvPolynomial S₂ R)) r = (C (C r) :) := rfl\n      have B : algebraMap R (MvPolynomial (S₁ ⊕ S₂) R) r = C r := rfl\n      simp only [sumRingEquiv, mvPolynomialEquivMvPolynomial, Equiv.toFun_as_coe,\n        Equiv.coe_fn_mk, B, sumToIter_C, A] }\n\n"}
{"name":"MvPolynomial.sumAlgEquiv_symm_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\ninst✝ : CommSemiring R\na : MvPolynomial S₁ (MvPolynomial S₂ R)\n⊢ Eq ((MvPolynomial.sumAlgEquiv R S₁ S₂).symm a) ((MvPolynomial.iterToSum R S₁ S₂) a)","decl":"/-- The algebra isomorphism between multivariable polynomials in a sum of two types,\nand multivariable polynomials in one of the types,\nwith coefficients in multivariable polynomials in the other type.\n-/\n@[simps!]\ndef sumAlgEquiv : MvPolynomial (S₁ ⊕ S₂) R ≃ₐ[R] MvPolynomial S₁ (MvPolynomial S₂ R) :=\n  { sumRingEquiv R S₁ S₂ with\n    commutes' := by\n      intro r\n      have A : algebraMap R (MvPolynomial S₁ (MvPolynomial S₂ R)) r = (C (C r) :) := rfl\n      have B : algebraMap R (MvPolynomial (S₁ ⊕ S₂) R) r = C r := rfl\n      simp only [sumRingEquiv, mvPolynomialEquivMvPolynomial, Equiv.toFun_as_coe,\n        Equiv.coe_fn_mk, B, sumToIter_C, A] }\n\n"}
{"name":"MvPolynomial.sumAlgEquiv_comp_rename_inr","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\ninst✝ : CommSemiring R\n⊢ Eq ((↑(MvPolynomial.sumAlgEquiv R S₁ S₂)).comp (MvPolynomial.rename Sum.inr)) (IsScalarTower.toAlgHom R (MvPolynomial S₂ R) (MvPolynomial S₁ (MvPolynomial S₂ R)))","decl":"lemma sumAlgEquiv_comp_rename_inr :\n    (sumAlgEquiv R S₁ S₂).toAlgHom.comp (rename Sum.inr) = IsScalarTower.toAlgHom R\n        (MvPolynomial S₂ R) (MvPolynomial S₁ (MvPolynomial S₂ R)) := by\n  ext i\n  simp\n\n"}
{"name":"MvPolynomial.sumAlgEquiv_comp_rename_inl","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\nS₂ : Type w\ninst✝ : CommSemiring R\n⊢ Eq ((↑(MvPolynomial.sumAlgEquiv R S₁ S₂)).comp (MvPolynomial.rename Sum.inl)) (MvPolynomial.mapAlgHom (Algebra.ofId R (MvPolynomial S₂ R)))","decl":"lemma sumAlgEquiv_comp_rename_inl :\n    (sumAlgEquiv R S₁ S₂).toAlgHom.comp (rename Sum.inl) =\n      MvPolynomial.mapAlgHom (Algebra.ofId _ _) := by\n  ext i\n  simp\n\n"}
{"name":"MvPolynomial.commAlgEquiv_C","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u_2\nS₁ : Type u_3\nS₂ : Type u_4\ninst✝ : CommSemiring R\np : MvPolynomial S₂ R\n⊢ Eq ((MvPolynomial.commAlgEquiv R S₁ S₂) (MvPolynomial.C p)) ((MvPolynomial.map MvPolynomial.C) p)","decl":"@[simp] lemma commAlgEquiv_C (p) : commAlgEquiv R S₁ S₂ (.C p) = .map C p := by\n  suffices (commAlgEquiv R S₁ S₂).toAlgHom.comp\n      (IsScalarTower.toAlgHom R (MvPolynomial S₂ R) _) = mapAlgHom (Algebra.ofId _ _) by\n    exact DFunLike.congr_fun this p\n  ext x : 1\n  simp [commAlgEquiv]\n\n"}
{"name":"MvPolynomial.commAlgEquiv_C_X","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u_2\nS₁ : Type u_3\nS₂ : Type u_4\ninst✝ : CommSemiring R\ni : S₂\n⊢ Eq ((MvPolynomial.commAlgEquiv R S₁ S₂) (MvPolynomial.C (MvPolynomial.X i))) (MvPolynomial.X i)","decl":"lemma commAlgEquiv_C_X (i) : commAlgEquiv R S₁ S₂ (.C (.X i)) = .X i := by simp\n\n"}
{"name":"MvPolynomial.commAlgEquiv_X","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u_2\nS₁ : Type u_3\nS₂ : Type u_4\ninst✝ : CommSemiring R\ni : S₁\n⊢ Eq ((MvPolynomial.commAlgEquiv R S₁ S₂) (MvPolynomial.X i)) (MvPolynomial.C (MvPolynomial.X i))","decl":"@[simp] lemma commAlgEquiv_X (i) : commAlgEquiv R S₁ S₂ (.X i) = .C (.X i) := by simp [commAlgEquiv]\n\n"}
{"name":"MvPolynomial.optionEquivLeft_symm_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\ninst✝ : CommSemiring R\na : Polynomial (MvPolynomial S₁ R)\n⊢ Eq ((MvPolynomial.optionEquivLeft R S₁).symm a) ((Polynomial.aevalTower (MvPolynomial.rename Option.some) (MvPolynomial.X Option.none)) a)","decl":"/-- The algebra isomorphism between multivariable polynomials in `Option S₁` and\npolynomials with coefficients in `MvPolynomial S₁ R`.\n-/\n@[simps!]\ndef optionEquivLeft : MvPolynomial (Option S₁) R ≃ₐ[R] Polynomial (MvPolynomial S₁ R) :=\n  AlgEquiv.ofAlgHom (MvPolynomial.aeval fun o => o.elim Polynomial.X fun s => Polynomial.C (X s))\n    (Polynomial.aevalTower (MvPolynomial.rename some) (X none))\n    (by ext : 2 <;> simp) (by ext i : 2; cases i <;> simp)\n\n"}
{"name":"MvPolynomial.optionEquivLeft_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\ninst✝ : CommSemiring R\na : MvPolynomial (Option S₁) R\n⊢ Eq ((MvPolynomial.optionEquivLeft R S₁) a) ((MvPolynomial.aeval fun o => o.elim Polynomial.X fun s => Polynomial.C (MvPolynomial.X s)) a)","decl":"/-- The algebra isomorphism between multivariable polynomials in `Option S₁` and\npolynomials with coefficients in `MvPolynomial S₁ R`.\n-/\n@[simps!]\ndef optionEquivLeft : MvPolynomial (Option S₁) R ≃ₐ[R] Polynomial (MvPolynomial S₁ R) :=\n  AlgEquiv.ofAlgHom (MvPolynomial.aeval fun o => o.elim Polynomial.X fun s => Polynomial.C (X s))\n    (Polynomial.aevalTower (MvPolynomial.rename some) (X none))\n    (by ext : 2 <;> simp) (by ext i : 2; cases i <;> simp)\n\n"}
{"name":"MvPolynomial.optionEquivLeft_X_some","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\ninst✝ : CommSemiring R\nx : S₁\n⊢ Eq ((MvPolynomial.optionEquivLeft R S₁) (MvPolynomial.X (Option.some x))) (Polynomial.C (MvPolynomial.X x))","decl":"lemma optionEquivLeft_X_some (x : S₁) : optionEquivLeft R S₁ (X (some x)) = Polynomial.C (X x) := by\n  simp [optionEquivLeft_apply, aeval_X]\n\n"}
{"name":"MvPolynomial.optionEquivLeft_X_none","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\ninst✝ : CommSemiring R\n⊢ Eq ((MvPolynomial.optionEquivLeft R S₁) (MvPolynomial.X Option.none)) Polynomial.X","decl":"lemma optionEquivLeft_X_none : optionEquivLeft R S₁ (X none) = Polynomial.X := by\n  simp [optionEquivLeft_apply, aeval_X]\n\n"}
{"name":"MvPolynomial.optionEquivLeft_C","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\ninst✝ : CommSemiring R\nr : R\n⊢ Eq ((MvPolynomial.optionEquivLeft R S₁) (MvPolynomial.C r)) (Polynomial.C (MvPolynomial.C r))","decl":"lemma optionEquivLeft_C (r : R) : optionEquivLeft R S₁ (C r) = Polynomial.C (C r) := by\n  simp only [optionEquivLeft_apply, aeval_C, Polynomial.algebraMap_apply, algebraMap_eq]\n\n"}
{"name":"MvPolynomial.optionEquivRight_symm_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\ninst✝ : CommSemiring R\na : MvPolynomial S₁ (Polynomial R)\n⊢ Eq ((MvPolynomial.optionEquivRight R S₁).symm a) ((MvPolynomial.aevalTower (Polynomial.aeval (MvPolynomial.X Option.none)) fun i => MvPolynomial.X (Option.some i)) a)","decl":"/-- The algebra isomorphism between multivariable polynomials in `Option S₁` and\nmultivariable polynomials with coefficients in polynomials.\n-/\n@[simps!]\ndef optionEquivRight : MvPolynomial (Option S₁) R ≃ₐ[R] MvPolynomial S₁ R[X] :=\n  AlgEquiv.ofAlgHom (MvPolynomial.aeval fun o => o.elim (C Polynomial.X) X)\n    (MvPolynomial.aevalTower (Polynomial.aeval (X none)) fun i => X (Option.some i))\n    (by\n      ext : 2 <;>\n        simp only [MvPolynomial.algebraMap_eq, Option.elim, AlgHom.coe_comp, AlgHom.id_comp,\n          IsScalarTower.coe_toAlgHom', comp_apply, aevalTower_C, Polynomial.aeval_X, aeval_X,\n          Option.elim', aevalTower_X, AlgHom.coe_id, id, eq_self_iff_true, imp_true_iff])\n    (by\n      ext ⟨i⟩ : 2 <;>\n        simp only [Option.elim, AlgHom.coe_comp, comp_apply, aeval_X, aevalTower_C,\n          Polynomial.aeval_X, AlgHom.coe_id, id, aevalTower_X])\n\n"}
{"name":"MvPolynomial.optionEquivRight_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\ninst✝ : CommSemiring R\na : MvPolynomial (Option S₁) R\n⊢ Eq ((MvPolynomial.optionEquivRight R S₁) a) ((MvPolynomial.aeval fun o => o.elim (MvPolynomial.C Polynomial.X) MvPolynomial.X) a)","decl":"/-- The algebra isomorphism between multivariable polynomials in `Option S₁` and\nmultivariable polynomials with coefficients in polynomials.\n-/\n@[simps!]\ndef optionEquivRight : MvPolynomial (Option S₁) R ≃ₐ[R] MvPolynomial S₁ R[X] :=\n  AlgEquiv.ofAlgHom (MvPolynomial.aeval fun o => o.elim (C Polynomial.X) X)\n    (MvPolynomial.aevalTower (Polynomial.aeval (X none)) fun i => X (Option.some i))\n    (by\n      ext : 2 <;>\n        simp only [MvPolynomial.algebraMap_eq, Option.elim, AlgHom.coe_comp, AlgHom.id_comp,\n          IsScalarTower.coe_toAlgHom', comp_apply, aevalTower_C, Polynomial.aeval_X, aeval_X,\n          Option.elim', aevalTower_X, AlgHom.coe_id, id, eq_self_iff_true, imp_true_iff])\n    (by\n      ext ⟨i⟩ : 2 <;>\n        simp only [Option.elim, AlgHom.coe_comp, comp_apply, aeval_X, aevalTower_C,\n          Polynomial.aeval_X, AlgHom.coe_id, id, aevalTower_X])\n\n"}
{"name":"MvPolynomial.optionEquivRight_X_some","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\ninst✝ : CommSemiring R\nx : S₁\n⊢ Eq ((MvPolynomial.optionEquivRight R S₁) (MvPolynomial.X (Option.some x))) (MvPolynomial.X x)","decl":"lemma optionEquivRight_X_some (x : S₁) : optionEquivRight R S₁ (X (some x)) = X x := by\n  simp [optionEquivRight_apply, aeval_X]\n\n"}
{"name":"MvPolynomial.optionEquivRight_X_none","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\ninst✝ : CommSemiring R\n⊢ Eq ((MvPolynomial.optionEquivRight R S₁) (MvPolynomial.X Option.none)) (MvPolynomial.C Polynomial.X)","decl":"lemma optionEquivRight_X_none : optionEquivRight R S₁ (X none) = C Polynomial.X := by\n  simp [optionEquivRight_apply, aeval_X]\n\n"}
{"name":"MvPolynomial.optionEquivRight_C","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nS₁ : Type v\ninst✝ : CommSemiring R\nr : R\n⊢ Eq ((MvPolynomial.optionEquivRight R S₁) (MvPolynomial.C r)) (MvPolynomial.C (Polynomial.C r))","decl":"lemma optionEquivRight_C (r : R) : optionEquivRight R S₁ (C r) = C (Polynomial.C r) := by\n  simp only [optionEquivRight_apply, aeval_C, algebraMap_apply, Polynomial.algebraMap_eq]\n\n"}
{"name":"MvPolynomial.finSuccEquiv_eq","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\n⊢ Eq (↑(MvPolynomial.finSuccEquiv R n)) (MvPolynomial.eval₂Hom (Polynomial.C.comp MvPolynomial.C) fun i => Fin.cases Polynomial.X (fun k => Polynomial.C (MvPolynomial.X k)) i)","decl":"theorem finSuccEquiv_eq :\n    (finSuccEquiv R n : MvPolynomial (Fin (n + 1)) R →+* Polynomial (MvPolynomial (Fin n) R)) =\n      eval₂Hom (Polynomial.C.comp (C : R →+* MvPolynomial (Fin n) R)) fun i : Fin (n + 1) =>\n        Fin.cases Polynomial.X (fun k => Polynomial.C (X k)) i := by\n  ext i : 2\n  · simp only [finSuccEquiv, optionEquivLeft_apply, aeval_C, AlgEquiv.coe_trans, RingHom.coe_coe,\n      coe_eval₂Hom, comp_apply, renameEquiv_apply, eval₂_C, RingHom.coe_comp, rename_C]\n    rfl\n  · refine Fin.cases ?_ ?_ i <;> simp [finSuccEquiv]\n\n"}
{"name":"MvPolynomial.finSuccEquiv_apply","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\np : MvPolynomial (Fin (HAdd.hAdd n 1)) R\n⊢ Eq ((MvPolynomial.finSuccEquiv R n) p) ((MvPolynomial.eval₂Hom (Polynomial.C.comp MvPolynomial.C) fun i => Fin.cases Polynomial.X (fun k => Polynomial.C (MvPolynomial.X k)) i) p)","decl":"theorem finSuccEquiv_apply (p : MvPolynomial (Fin (n + 1)) R) :\n    finSuccEquiv R n p =\n      eval₂Hom (Polynomial.C.comp (C : R →+* MvPolynomial (Fin n) R))\n        (fun i : Fin (n + 1) => Fin.cases Polynomial.X (fun k => Polynomial.C (X k)) i) p := by\n  rw [← finSuccEquiv_eq, RingHom.coe_coe]\n\n"}
{"name":"MvPolynomial.finSuccEquiv_comp_C_eq_C","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\n⊢ Eq ((↑(MvPolynomial.finSuccEquiv R n).symm).comp (Polynomial.C.comp MvPolynomial.C)) MvPolynomial.C","decl":"theorem finSuccEquiv_comp_C_eq_C {R : Type u} [CommSemiring R] (n : ℕ) :\n    (↑(MvPolynomial.finSuccEquiv R n).symm : Polynomial (MvPolynomial (Fin n) R) →+* _).comp\n        (Polynomial.C.comp MvPolynomial.C) =\n      (MvPolynomial.C : R →+* MvPolynomial (Fin n.succ) R) := by\n  refine RingHom.ext fun x => ?_\n  rw [RingHom.comp_apply]\n  refine\n    (MvPolynomial.finSuccEquiv R n).injective\n      (Trans.trans ((MvPolynomial.finSuccEquiv R n).apply_symm_apply _) ?_)\n  simp only [MvPolynomial.finSuccEquiv_apply, MvPolynomial.eval₂Hom_C]\n\n"}
{"name":"MvPolynomial.finSuccEquiv_X_zero","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\n⊢ Eq ((MvPolynomial.finSuccEquiv R n) (MvPolynomial.X 0)) Polynomial.X","decl":"theorem finSuccEquiv_X_zero : finSuccEquiv R n (X 0) = Polynomial.X := by simp [finSuccEquiv_apply]\n\n"}
{"name":"MvPolynomial.finSuccEquiv_X_succ","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nj : Fin n\n⊢ Eq ((MvPolynomial.finSuccEquiv R n) (MvPolynomial.X j.succ)) (Polynomial.C (MvPolynomial.X j))","decl":"theorem finSuccEquiv_X_succ {j : Fin n} : finSuccEquiv R n (X j.succ) = Polynomial.C (X j) := by\n  simp [finSuccEquiv_apply]\n\n"}
{"name":"MvPolynomial.finSuccEquiv_coeff_coeff","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nm : Finsupp (Fin n) Nat\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\ni : Nat\n⊢ Eq (MvPolynomial.coeff m (((MvPolynomial.finSuccEquiv R n) f).coeff i)) (MvPolynomial.coeff (Finsupp.cons i m) f)","decl":"/-- The coefficient of `m` in the `i`-th coefficient of `finSuccEquiv R n f` equals the\n    coefficient of `Finsupp.cons i m` in `f`. -/\ntheorem finSuccEquiv_coeff_coeff (m : Fin n →₀ ℕ) (f : MvPolynomial (Fin (n + 1)) R) (i : ℕ) :\n    coeff m (Polynomial.coeff (finSuccEquiv R n f) i) = coeff (m.cons i) f := by\n  induction' f using MvPolynomial.induction_on' with j r p q hp hq generalizing i m\n  swap\n  · simp only [map_add, Polynomial.coeff_add, coeff_add, hp, hq]\n  simp only [finSuccEquiv_apply, coe_eval₂Hom, eval₂_monomial, RingHom.coe_comp, Finsupp.prod_pow,\n    Polynomial.coeff_C_mul, coeff_C_mul, coeff_monomial, Fin.prod_univ_succ, Fin.cases_zero,\n    Fin.cases_succ, ← map_prod, ← RingHom.map_pow, Function.comp_apply]\n  rw [← mul_boole, mul_comm (Polynomial.X ^ j 0), Polynomial.coeff_C_mul_X_pow]; congr 1\n  obtain rfl | hjmi := eq_or_ne j (m.cons i)\n  · simpa only [cons_zero, cons_succ, if_pos rfl, monomial_eq, C_1, one_mul, Finsupp.prod_pow] using\n      coeff_monomial m m (1 : R)\n  · simp only [hjmi, if_false]\n    obtain hij | rfl := ne_or_eq i (j 0)\n    · simp only [hij, if_false, coeff_zero]\n    simp only [eq_self_iff_true, if_true]\n    have hmj : m ≠ j.tail := by\n      rintro rfl\n      rw [cons_tail] at hjmi\n      contradiction\n    simpa only [monomial_eq, C_1, one_mul, Finsupp.prod_pow, tail_apply, if_neg hmj.symm] using\n      coeff_monomial m j.tail (1 : R)\n\n"}
{"name":"MvPolynomial.eval_eq_eval_mv_eval'","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\ns : Fin n → R\ny : R\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\n⊢ Eq ((MvPolynomial.eval (Fin.cons y s)) f) (Polynomial.eval y (Polynomial.map (MvPolynomial.eval s) ((MvPolynomial.finSuccEquiv R n) f)))","decl":"theorem eval_eq_eval_mv_eval' (s : Fin n → R) (y : R) (f : MvPolynomial (Fin (n + 1)) R) :\n    eval (Fin.cons y s : Fin (n + 1) → R) f =\n      Polynomial.eval y (Polynomial.map (eval s) (finSuccEquiv R n f)) := by\n  -- turn this into a def `Polynomial.mapAlgHom`\n  let φ : (MvPolynomial (Fin n) R)[X] →ₐ[R] R[X] :=\n    { Polynomial.mapRingHom (eval s) with\n      commutes' := fun r => by\n        convert Polynomial.map_C (eval s)\n        exact (eval_C _).symm }\n  show\n    aeval (Fin.cons y s : Fin (n + 1) → R) f =\n      (Polynomial.aeval y).comp (φ.comp (finSuccEquiv R n).toAlgHom) f\n  congr 2\n  apply MvPolynomial.algHom_ext\n  rw [Fin.forall_iff_succ]\n  simp only [φ, aeval_X, Fin.cons_zero, AlgEquiv.toAlgHom_eq_coe, AlgHom.coe_comp,\n    Polynomial.coe_aeval_eq_eval, Polynomial.map_C, AlgHom.coe_mk, RingHom.toFun_eq_coe,\n    Polynomial.coe_mapRingHom, comp_apply, finSuccEquiv_apply, eval₂Hom_X',\n    Fin.cases_zero, Polynomial.map_X, Polynomial.eval_X, Fin.cons_succ,\n    Fin.cases_succ, eval_X, Polynomial.eval_C,\n    RingHom.coe_mk, MonoidHom.coe_coe, AlgHom.coe_coe, implies_true, and_self,\n    RingHom.toMonoidHom_eq_coe]\n\n"}
{"name":"MvPolynomial.coeff_eval_eq_eval_coeff","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\ns' : Fin n → R\nf : Polynomial (MvPolynomial (Fin n) R)\ni : Nat\n⊢ Eq ((Polynomial.map (MvPolynomial.eval s') f).coeff i) ((MvPolynomial.eval s') (f.coeff i))","decl":"theorem coeff_eval_eq_eval_coeff (s' : Fin n → R) (f : Polynomial (MvPolynomial (Fin n) R))\n    (i : ℕ) : Polynomial.coeff (Polynomial.map (eval s') f) i = eval s' (Polynomial.coeff f i) := by\n  simp only [Polynomial.coeff_map]\n\n"}
{"name":"MvPolynomial.support_coeff_finSuccEquiv","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\ni : Nat\nm : Finsupp (Fin n) Nat\n⊢ Iff (Membership.mem (((MvPolynomial.finSuccEquiv R n) f).coeff i).support m) (Membership.mem f.support (Finsupp.cons i m))","decl":"theorem support_coeff_finSuccEquiv {f : MvPolynomial (Fin (n + 1)) R} {i : ℕ} {m : Fin n →₀ ℕ} :\n    m ∈ ((finSuccEquiv R n f).coeff i).support ↔ m.cons i ∈ f.support := by\n  apply Iff.intro\n  · intro h\n    simpa [← finSuccEquiv_coeff_coeff] using h\n  · intro h\n    simpa [mem_support_iff, ← finSuccEquiv_coeff_coeff m f i] using h\n\n"}
{"name":"MvPolynomial.totalDegree_coeff_finSuccEquiv_add_le","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\ni : Nat\nhi : Ne (((MvPolynomial.finSuccEquiv R n) f).coeff i) 0\n⊢ LE.le (HAdd.hAdd (((MvPolynomial.finSuccEquiv R n) f).coeff i).totalDegree i) f.totalDegree","decl":"/--\nThe `totalDegree` of a multivariable polynomial `p` is at least `i` more than the `totalDegree` of\nthe `i`th coefficient of `finSuccEquiv` applied to `p`, if this is nonzero.\n-/\nlemma totalDegree_coeff_finSuccEquiv_add_le (f : MvPolynomial (Fin (n + 1)) R) (i : ℕ)\n    (hi : (finSuccEquiv R n f).coeff i ≠ 0) :\n    totalDegree ((finSuccEquiv R n f).coeff i) + i ≤ totalDegree f := by\n  have hf'_sup : ((finSuccEquiv R n f).coeff i).support.Nonempty := by\n    rw [Finset.nonempty_iff_ne_empty, ne_eq, support_eq_empty]\n    exact hi\n  -- Let σ be a monomial index of ((finSuccEquiv R n p).coeff i) of maximal total degree\n  have ⟨σ, hσ1, hσ2⟩ := Finset.exists_mem_eq_sup (support _) hf'_sup\n                          (fun s => Finsupp.sum s fun _ e => e)\n  -- Then cons i σ is a monomial index of p with total degree equal to the desired bound\n  let σ' : Fin (n+1) →₀ ℕ := cons i σ\n  convert le_totalDegree (s := σ') _\n  · rw [totalDegree, hσ2, sum_cons, add_comm]\n  · rw [← support_coeff_finSuccEquiv]\n    exact hσ1\n\n"}
{"name":"MvPolynomial.support_finSuccEquiv","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\n⊢ Eq ((MvPolynomial.finSuccEquiv R n) f).support (Finset.image (fun m => m 0) f.support)","decl":"theorem support_finSuccEquiv (f : MvPolynomial (Fin (n + 1)) R) :\n    (finSuccEquiv R n f).support = Finset.image (fun m : Fin (n + 1) →₀ ℕ => m 0) f.support := by\n  ext i\n  rw [Polynomial.mem_support_iff, Finset.mem_image, Finsupp.ne_iff]\n  constructor\n  · rintro ⟨m, hm⟩\n    refine ⟨cons i m, ?_, cons_zero _ _⟩\n    rw [← support_coeff_finSuccEquiv]\n    simpa using hm\n  · rintro ⟨m, h, rfl⟩\n    refine ⟨tail m, ?_⟩\n    rwa [← coeff, zero_apply, ← mem_support_iff, support_coeff_finSuccEquiv, cons_tail]\n\n"}
{"name":"MvPolynomial.finSuccEquiv_support","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\n⊢ Eq ((MvPolynomial.finSuccEquiv R n) f).support (Finset.image (fun m => m 0) f.support)","decl":"@[deprecated (since := \"2024-11-05\")] alias finSuccEquiv_support := support_finSuccEquiv\n\n"}
{"name":"MvPolynomial.mem_support_finSuccEquiv","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\nx : Nat\n⊢ Iff (Membership.mem ((MvPolynomial.finSuccEquiv R n) f).support x) (Membership.mem (Set.image (fun m => m 0) ↑f.support) x)","decl":"theorem mem_support_finSuccEquiv {f : MvPolynomial (Fin (n + 1)) R} {x} :\n    x ∈ (finSuccEquiv R n f).support ↔ x ∈ (fun m : Fin (n + 1) →₀ _ ↦ m 0) '' f.support := by\n  simpa using congr(x ∈ $(support_finSuccEquiv f))\n\n"}
{"name":"MvPolynomial.image_support_finSuccEquiv","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\ni : Nat\n⊢ Eq (Finset.image (Finsupp.cons i) (((MvPolynomial.finSuccEquiv R n) f).coeff i).support) (Finset.filter (fun m => Eq (m 0) i) f.support)","decl":"theorem image_support_finSuccEquiv {f : MvPolynomial (Fin (n + 1)) R} {i : ℕ} :\n    ((finSuccEquiv R n f).coeff i).support.image (Finsupp.cons i) = {m ∈ f.support | m 0 = i} := by\n  ext m\n  rw [Finset.mem_filter, Finset.mem_image, mem_support_iff]\n  conv_lhs =>\n    congr\n    ext\n    rw [mem_support_iff, finSuccEquiv_coeff_coeff, Ne]\n  constructor\n  · rintro ⟨m', ⟨h, hm'⟩⟩\n    simp only [← hm']\n    exact ⟨h, by rw [cons_zero]⟩\n  · intro h\n    use tail m\n    rw [← h.2, cons_tail]\n    simp [h.1]\n\n"}
{"name":"MvPolynomial.finSuccEquiv_support'","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\ni : Nat\n⊢ Eq (Finset.image (Finsupp.cons i) (((MvPolynomial.finSuccEquiv R n) f).coeff i).support) (Finset.filter (fun m => Eq (m 0) i) f.support)","decl":"@[deprecated (since := \"2024-11-05\")] alias finSuccEquiv_support' := image_support_finSuccEquiv\n\n"}
{"name":"MvPolynomial.mem_image_support_coeff_finSuccEquiv","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\ni : Nat\nx : Finsupp (Fin (HAdd.hAdd n 1)) Nat\n⊢ Iff (Membership.mem (Set.image (Finsupp.cons i) ↑(((MvPolynomial.finSuccEquiv R n) f).coeff i).support) x) (And (Membership.mem f.support x) (Eq (x 0) i))","decl":"lemma mem_image_support_coeff_finSuccEquiv {f : MvPolynomial (Fin (n + 1)) R} {i : ℕ} {x} :\n    x ∈ Finsupp.cons i '' ((finSuccEquiv R n f).coeff i).support ↔\n      x ∈ f.support ∧ x 0 = i := by\n  simpa using congr(x ∈ $image_support_finSuccEquiv)\n\n"}
{"name":"MvPolynomial.mem_support_coeff_finSuccEquiv","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\ni : Nat\nx : Finsupp (Fin n) Nat\n⊢ Iff (Membership.mem (((MvPolynomial.finSuccEquiv R n) f).coeff i).support x) (Membership.mem f.support (Finsupp.cons i x))","decl":"lemma mem_support_coeff_finSuccEquiv {f : MvPolynomial (Fin (n + 1)) R} {i : ℕ} {x} :\n    x ∈ ((finSuccEquiv R n f).coeff i).support ↔ x.cons i ∈ f.support := by\n  rw [← (Finsupp.cons_right_injective i).mem_finset_image (a := x),\n    image_support_finSuccEquiv]\n  simp only [Finset.mem_filter, mem_support_iff, ne_eq, cons_zero, and_true]\n\n-- TODO: generalize `finSuccEquiv R n` to an arbitrary ZeroHom\n"}
{"name":"MvPolynomial.support_finSuccEquiv_nonempty","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\nh : Ne f 0\n⊢ ((MvPolynomial.finSuccEquiv R n) f).support.Nonempty","decl":"theorem support_finSuccEquiv_nonempty {f : MvPolynomial (Fin (n + 1)) R} (h : f ≠ 0) :\n    (finSuccEquiv R n f).support.Nonempty := by\n  rwa [Polynomial.support_nonempty, EmbeddingLike.map_ne_zero_iff]\n\n"}
{"name":"MvPolynomial.degree_finSuccEquiv","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\nh : Ne f 0\n⊢ Eq ((MvPolynomial.finSuccEquiv R n) f).degree ↑(MvPolynomial.degreeOf 0 f)","decl":"theorem degree_finSuccEquiv {f : MvPolynomial (Fin (n + 1)) R} (h : f ≠ 0) :\n    (finSuccEquiv R n f).degree = degreeOf 0 f := by\n  -- TODO: these should be lemmas\n  have h₀ : ∀ {α β : Type _} (f : α → β), (fun x => x) ∘ f = f := fun f => rfl\n  have h₁ : ∀ {α β : Type _} (f : α → β), f ∘ (fun x => x) = f := fun f => rfl\n  have h₂ : WithBot.some = Nat.cast := rfl\n\n  have h' : ((finSuccEquiv R n f).support.sup fun x => x) = degreeOf 0 f := by\n    rw [degreeOf_eq_sup, support_finSuccEquiv, Finset.sup_image, h₀]\n  rw [Polynomial.degree, ← h', ← h₂, Finset.coe_sup_of_nonempty (support_finSuccEquiv_nonempty h),\n    Finset.max_eq_sup_coe, h₁]\n\n"}
{"name":"MvPolynomial.natDegree_finSuccEquiv","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nf : MvPolynomial (Fin (HAdd.hAdd n 1)) R\n⊢ Eq ((MvPolynomial.finSuccEquiv R n) f).natDegree (MvPolynomial.degreeOf 0 f)","decl":"theorem natDegree_finSuccEquiv (f : MvPolynomial (Fin (n + 1)) R) :\n    (finSuccEquiv R n f).natDegree = degreeOf 0 f := by\n  by_cases c : f = 0\n  · rw [c, map_zero, Polynomial.natDegree_zero, degreeOf_zero]\n  · rw [Polynomial.natDegree, degree_finSuccEquiv (by simpa only [Ne] )]\n    erw [WithBot.unbot'_coe]\n    simp\n\n"}
{"name":"MvPolynomial.degreeOf_coeff_finSuccEquiv","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\np : MvPolynomial (Fin (HAdd.hAdd n 1)) R\nj : Fin n\ni : Nat\n⊢ LE.le (MvPolynomial.degreeOf j (((MvPolynomial.finSuccEquiv R n) p).coeff i)) (MvPolynomial.degreeOf j.succ p)","decl":"theorem degreeOf_coeff_finSuccEquiv (p : MvPolynomial (Fin (n + 1)) R) (j : Fin n) (i : ℕ) :\n    degreeOf j (Polynomial.coeff (finSuccEquiv R n p) i) ≤ degreeOf j.succ p := by\n  rw [degreeOf_eq_sup, degreeOf_eq_sup, Finset.sup_le_iff]\n  intro m hm\n  rw [← Finsupp.cons_succ j i m]\n  exact Finset.le_sup\n    (f := fun (g : Fin (Nat.succ n) →₀ ℕ) => g (Fin.succ j))\n    (support_coeff_finSuccEquiv.1 hm)\n\n"}
{"name":"MvPolynomial.finSuccEquiv_rename_finSuccEquiv","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\nσ : Type u_1\ninst✝ : CommSemiring R\nn : Nat\ne : Equiv σ (Fin n)\nφ : MvPolynomial (Option σ) R\n⊢ Eq ((MvPolynomial.finSuccEquiv R n) ((MvPolynomial.rename ⇑(e.optionCongr.trans (finSuccEquiv n).symm)) φ)) (Polynomial.map (MvPolynomial.rename ⇑e).toRingHom ((MvPolynomial.optionEquivLeft R σ) φ))","decl":"/-- Consider a multivariate polynomial `φ` whose variables are indexed by `Option σ`,\nand suppose that `σ ≃ Fin n`.\nThen one may view `φ` as a polynomial over `MvPolynomial (Fin n) R`, by\n\n1. renaming the variables via `Option σ ≃ Fin (n+1)`, and then singling out the `0`-th variable\n    via `MvPolynomial.finSuccEquiv`;\n2. first viewing it as polynomial over `MvPolynomial σ R` via `MvPolynomial.optionEquivLeft`,\n    and then renaming the variables.\n\nThis lemma shows that both constructions are the same. -/\nlemma finSuccEquiv_rename_finSuccEquiv (e : σ ≃ Fin n) (φ : MvPolynomial (Option σ) R) :\n    ((finSuccEquiv R n) ((rename ((Equiv.optionCongr e).trans (_root_.finSuccEquiv n).symm)) φ)) =\n      Polynomial.map (rename e).toRingHom (optionEquivLeft R σ φ) := by\n  suffices (finSuccEquiv R n).toRingEquiv.toRingHom.comp (rename ((Equiv.optionCongr e).trans\n        (_root_.finSuccEquiv n).symm)).toRingHom =\n      (Polynomial.mapRingHom (rename e).toRingHom).comp (optionEquivLeft R σ) by\n    exact DFunLike.congr_fun this φ\n  apply ringHom_ext\n  · simp [Polynomial.algebraMap_apply, algebraMap_eq, finSuccEquiv_apply]\n  · rintro (i|i) <;> simp [finSuccEquiv_apply]\n\n"}
{"name":"MvPolynomial.rename_polynomial_aeval_X","module":"Mathlib.Algebra.MvPolynomial.Equiv","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nσ : Type u_2\nτ : Type u_3\nf : σ → τ\ni : σ\np : Polynomial R\n⊢ Eq ((MvPolynomial.rename f) ((Polynomial.aeval (MvPolynomial.X i)) p)) ((Polynomial.aeval (MvPolynomial.X (f i))) p)","decl":"@[simp]\ntheorem rename_polynomial_aeval_X {σ τ : Type*} (f : σ → τ) (i : σ) (p : R[X]) :\n    rename f (Polynomial.aeval (X i) p) = Polynomial.aeval (X (f i) : MvPolynomial τ R) p := by\n  rw [← aeval_algHom_apply, rename_X]\n\n"}
