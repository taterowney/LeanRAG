{"name":"Algebra.Extension.isScalarTower","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nself : Algebra.Extension R S\n⊢ IsScalarTower R self.Ring S","decl":"/--\nAn extension of an `R`-algebra `S` is an `R` algebra `P` together with a surjection `P →ₐ[R] S`.\nAlso see `Algebra.Extension.ofSurjective`.\n-/\nstructure Algebra.Extension where\n  /-- The underlying algebra of an extension. -/\n  Ring : Type w\n  [commRing : CommRing Ring]\n  [algebra₁ : Algebra R Ring]\n  [algebra₂ : Algebra Ring S]\n  [isScalarTower : IsScalarTower R Ring S]\n  /-- A chosen (set-theoretic) section of an extension. -/\n  σ : S → Ring\n  algebraMap_σ : ∀ x, algebraMap Ring S (σ x) = x\n\n"}
{"name":"Algebra.Extension.mk.injEq","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nRing✝ : Type w\ncommRing✝ : CommRing Ring✝\nalgebra₁✝ : Algebra R Ring✝\nalgebra₂✝ : Algebra Ring✝ S\nisScalarTower✝ : IsScalarTower R Ring✝ S\nσ✝ : S → Ring✝\nalgebraMap_σ✝ : ∀ (x : S), Eq ((algebraMap Ring✝ S) (σ✝ x)) x\nRing : Type w\ncommRing : CommRing Ring\nalgebra₁ : Algebra R Ring\nalgebra₂ : Algebra Ring S\nisScalarTower : IsScalarTower R Ring S\nσ : S → Ring\nalgebraMap_σ : ∀ (x : S), Eq ((algebraMap Ring S) (σ x)) x\n⊢ Eq (Eq (Algebra.Extension.mk Ring✝ σ✝ algebraMap_σ✝) (Algebra.Extension.mk Ring σ algebraMap_σ)) (And (Eq Ring✝ Ring) (And (HEq commRing✝ commRing) (And (HEq algebra₁✝ algebra₁) (And (HEq algebra₂✝ algebra₂) (HEq σ✝ σ)))))","decl":"/--\nAn extension of an `R`-algebra `S` is an `R` algebra `P` together with a surjection `P →ₐ[R] S`.\nAlso see `Algebra.Extension.ofSurjective`.\n-/\nstructure Algebra.Extension where\n  /-- The underlying algebra of an extension. -/\n  Ring : Type w\n  [commRing : CommRing Ring]\n  [algebra₁ : Algebra R Ring]\n  [algebra₂ : Algebra Ring S]\n  [isScalarTower : IsScalarTower R Ring S]\n  /-- A chosen (set-theoretic) section of an extension. -/\n  σ : S → Ring\n  algebraMap_σ : ∀ x, algebraMap Ring S (σ x) = x\n\n"}
{"name":"Algebra.Extension.mk.sizeOf_spec","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : SizeOf R\ninst✝ : SizeOf S\nRing : Type w\ncommRing : CommRing Ring\nalgebra₁ : Algebra R Ring\nalgebra₂ : Algebra Ring S\nisScalarTower : IsScalarTower R Ring S\nσ : S → Ring\nalgebraMap_σ : ∀ (x : S), Eq ((algebraMap Ring S) (σ x)) x\n⊢ Eq (SizeOf.sizeOf (Algebra.Extension.mk Ring σ algebraMap_σ)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Ring)) (SizeOf.sizeOf commRing)) (SizeOf.sizeOf algebra₁)) (SizeOf.sizeOf algebra₂)) (SizeOf.sizeOf isScalarTower))","decl":"/--\nAn extension of an `R`-algebra `S` is an `R` algebra `P` together with a surjection `P →ₐ[R] S`.\nAlso see `Algebra.Extension.ofSurjective`.\n-/\nstructure Algebra.Extension where\n  /-- The underlying algebra of an extension. -/\n  Ring : Type w\n  [commRing : CommRing Ring]\n  [algebra₁ : Algebra R Ring]\n  [algebra₂ : Algebra Ring S]\n  [isScalarTower : IsScalarTower R Ring S]\n  /-- A chosen (set-theoretic) section of an extension. -/\n  σ : S → Ring\n  algebraMap_σ : ∀ x, algebraMap Ring S (σ x) = x\n\n"}
{"name":"Algebra.Extension.mk.inj","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nRing✝ : Type w\ncommRing✝ : CommRing Ring✝\nalgebra₁✝ : Algebra R Ring✝\nalgebra₂✝ : Algebra Ring✝ S\nisScalarTower✝ : IsScalarTower R Ring✝ S\nσ✝ : S → Ring✝\nalgebraMap_σ✝ : ∀ (x : S), Eq ((algebraMap Ring✝ S) (σ✝ x)) x\nRing : Type w\ncommRing : CommRing Ring\nalgebra₁ : Algebra R Ring\nalgebra₂ : Algebra Ring S\nisScalarTower : IsScalarTower R Ring S\nσ : S → Ring\nalgebraMap_σ : ∀ (x : S), Eq ((algebraMap Ring S) (σ x)) x\nx✝ : Eq (Algebra.Extension.mk Ring✝ σ✝ algebraMap_σ✝) (Algebra.Extension.mk Ring σ algebraMap_σ)\n⊢ And (Eq Ring✝ Ring) (And (HEq commRing✝ commRing) (And (HEq algebra₁✝ algebra₁) (And (HEq algebra₂✝ algebra₂) (HEq σ✝ σ))))","decl":"/--\nAn extension of an `R`-algebra `S` is an `R` algebra `P` together with a surjection `P →ₐ[R] S`.\nAlso see `Algebra.Extension.ofSurjective`.\n-/\nstructure Algebra.Extension where\n  /-- The underlying algebra of an extension. -/\n  Ring : Type w\n  [commRing : CommRing Ring]\n  [algebra₁ : Algebra R Ring]\n  [algebra₂ : Algebra Ring S]\n  [isScalarTower : IsScalarTower R Ring S]\n  /-- A chosen (set-theoretic) section of an extension. -/\n  σ : S → Ring\n  algebraMap_σ : ∀ x, algebraMap Ring S (σ x) = x\n\n"}
{"name":"Algebra.Extension.algebraMap_σ","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nself : Algebra.Extension R S\nx : S\n⊢ Eq ((algebraMap self.Ring S) (self.σ x)) x","decl":"/--\nAn extension of an `R`-algebra `S` is an `R` algebra `P` together with a surjection `P →ₐ[R] S`.\nAlso see `Algebra.Extension.ofSurjective`.\n-/\nstructure Algebra.Extension where\n  /-- The underlying algebra of an extension. -/\n  Ring : Type w\n  [commRing : CommRing Ring]\n  [algebra₁ : Algebra R Ring]\n  [algebra₂ : Algebra Ring S]\n  [isScalarTower : IsScalarTower R Ring S]\n  /-- A chosen (set-theoretic) section of an extension. -/\n  σ : S → Ring\n  algebraMap_σ : ∀ x, algebraMap Ring S (σ x) = x\n\n"}
{"name":"Algebra.Extension.instIsScalarTowerRing","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nP : Algebra.Extension R S\nR₀ : Type u_1\ninst✝³ : CommRing R₀\ninst✝² : Algebra R₀ R\ninst✝¹ : Algebra R₀ S\ninst✝ : IsScalarTower R₀ R S\n⊢ IsScalarTower R₀ R P.Ring","decl":"instance {R₀} [CommRing R₀] [Algebra R₀ R] [Algebra R₀ S] [IsScalarTower R₀ R S] :\n    IsScalarTower R₀ R P.Ring := IsScalarTower.of_algebraMap_eq' rfl\n\n"}
{"name":"Algebra.Extension.instIsScalarTowerRing_1","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝¹² : CommRing R\ninst✝¹¹ : CommRing S\ninst✝¹⁰ : Algebra R S\nP : Algebra.Extension R S\nR₀ : Type u_1\ninst✝⁹ : CommRing R₀\ninst✝⁸ : Algebra R₀ R\ninst✝⁷ : Algebra R₀ S\ninst✝⁶ : IsScalarTower R₀ R S\nR₁ : Type u_2\ninst✝⁵ : CommRing R₁\ninst✝⁴ : Algebra R₁ R\ninst✝³ : Algebra R₁ S\ninst✝² : IsScalarTower R₁ R S\ninst✝¹ : Algebra R₀ R₁\ninst✝ : IsScalarTower R₀ R₁ R\n⊢ IsScalarTower R₀ R₁ P.Ring","decl":"instance {R₀} [CommRing R₀] [Algebra R₀ R] [Algebra R₀ S] [IsScalarTower R₀ R S]\n    {R₁} [CommRing R₁] [Algebra R₁ R] [Algebra R₁ S] [IsScalarTower R₁ R S]\n    [Algebra R₀ R₁] [IsScalarTower R₀ R₁ R] :\n    IsScalarTower R₀ R₁ P.Ring := IsScalarTower.of_algebraMap_eq' <| by\n  rw [IsScalarTower.algebraMap_eq R₀ R, IsScalarTower.algebraMap_eq R₁ R,\n    RingHom.comp_assoc, ← IsScalarTower.algebraMap_eq R₀ R₁ R]\n\n"}
{"name":"Algebra.Extension.instIsScalarTowerRing_2","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nP : Algebra.Extension R S\nR₀ : Type u_1\ninst✝³ : CommRing R₀\ninst✝² : Algebra R₀ R\ninst✝¹ : Algebra R₀ S\ninst✝ : IsScalarTower R₀ R S\n⊢ IsScalarTower R₀ P.Ring S","decl":"instance {R₀} [CommRing R₀] [Algebra R₀ R] [Algebra R₀ S] [IsScalarTower R₀ R S] :\n    IsScalarTower R₀ P.Ring S := IsScalarTower.of_algebraMap_eq' <| by\n  rw [IsScalarTower.algebraMap_eq R₀ R P.Ring, ← RingHom.comp_assoc,\n    ← IsScalarTower.algebraMap_eq, ← IsScalarTower.algebraMap_eq]\n\n"}
{"name":"Algebra.Extension.σ_smul","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nx y : S\n⊢ Eq (HSMul.hSMul (P.σ x) y) (HMul.hMul x y)","decl":"@[simp]\nlemma σ_smul (x y) : P.σ x • y = x * y := by\n  rw [Algebra.smul_def, algebraMap_σ]\n\n"}
{"name":"Algebra.Extension.σ_injective","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Function.Injective P.σ","decl":"lemma σ_injective : P.σ.Injective := by\n  intro x y e\n  rw [← P.algebraMap_σ x, ← P.algebraMap_σ y, e]\n\n"}
{"name":"Algebra.Extension.algebraMap_surjective","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Function.Surjective ⇑(algebraMap P.Ring S)","decl":"lemma algebraMap_surjective : Function.Surjective (algebraMap P.Ring S) := (⟨_, P.algebraMap_σ ·⟩)\n\n"}
{"name":"Algebra.Extension.ofSurjective_σ","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nP : Type w\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nf : AlgHom R P S\nh : Function.Surjective ⇑f\nx : S\n⊢ Eq ((Algebra.Extension.ofSurjective f h).σ x) ⋯.choose","decl":"/-- Construct `Extension` from a surjective algebra homomorphism. -/\n@[simps (config := .lemmasOnly) Ring σ]\nnoncomputable\ndef ofSurjective {P : Type w} [CommRing P] [Algebra R P] (f : P →ₐ[R] S)\n    (h : Function.Surjective f) : Extension.{w} R S where\n  Ring := P\n  algebra₂ := f.toAlgebra\n  isScalarTower := letI := f.toAlgebra; IsScalarTower.of_algebraMap_eq' f.comp_algebraMap.symm\n  σ x := (h x).choose\n  algebraMap_σ x := (h x).choose_spec\n\n"}
{"name":"Algebra.Extension.ofSurjective_Ring","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nP : Type w\ninst✝¹ : CommRing P\ninst✝ : Algebra R P\nf : AlgHom R P S\nh : Function.Surjective ⇑f\n⊢ Eq (Algebra.Extension.ofSurjective f h).Ring P","decl":"/-- Construct `Extension` from a surjective algebra homomorphism. -/\n@[simps (config := .lemmasOnly) Ring σ]\nnoncomputable\ndef ofSurjective {P : Type w} [CommRing P] [Algebra R P] (f : P →ₐ[R] S)\n    (h : Function.Surjective f) : Extension.{w} R S where\n  Ring := P\n  algebra₂ := f.toAlgebra\n  isScalarTower := letI := f.toAlgebra; IsScalarTower.of_algebraMap_eq' f.comp_algebraMap.symm\n  σ x := (h x).choose\n  algebraMap_σ x := (h x).choose_spec\n\n"}
{"name":"Algebra.Extension.self_σ","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\na : S\n⊢ Eq ((Algebra.Extension.self R S).σ a) (id a)","decl":"variable (R S) in\n/-- The trivial extension of `S`. -/\n@[simps (config := .lemmasOnly) Ring σ]\nnoncomputable\ndef self : Extension R S where\n  Ring := S\n  σ := _root_.id\n  algebraMap_σ _ := rfl\n\n"}
{"name":"Algebra.Extension.self_Ring","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Eq (Algebra.Extension.self R S).Ring S","decl":"variable (R S) in\n/-- The trivial extension of `S`. -/\n@[simps (config := .lemmasOnly) Ring σ]\nnoncomputable\ndef self : Extension R S where\n  Ring := S\n  σ := _root_.id\n  algebraMap_σ _ := rfl\n\n"}
{"name":"Algebra.Extension.Hom.ext_iff","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁴ : CommRing R'\ninst✝³ : CommRing S'\ninst✝² : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝¹ : Algebra R R'\ninst✝ : Algebra S S'\nx y : P.Hom P'\n⊢ Iff (Eq x y) (Eq x.toRingHom y.toRingHom)","decl":"/-- Given a commuting square\n```\nR --→ P -→ S\n|          |\n↓          ↓\nR' -→ P' → S\n```\nA hom between `P` and `P'` is a ring homomorphism that makes the two squares commute.\n-/\n@[ext]\nstructure Hom where\n  /-- The underlying ring homomorphism of a hom between extensions. -/\n  toRingHom : P.Ring →+* P'.Ring\n  toRingHom_algebraMap :\n    ∀ x, toRingHom (algebraMap R P.Ring x) = algebraMap R' P'.Ring (algebraMap R R' x)\n  algebraMap_toRingHom :\n    ∀ x, (algebraMap P'.Ring S' (toRingHom x)) = algebraMap S S' (algebraMap P.Ring S x)\n\n"}
{"name":"Algebra.Extension.Hom.mk.sizeOf_spec","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁸ : CommRing R'\ninst✝⁷ : CommRing S'\ninst✝⁶ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝⁵ : Algebra R R'\ninst✝⁴ : Algebra S S'\ninst✝³ : SizeOf R\ninst✝² : SizeOf S\ninst✝¹ : SizeOf R'\ninst✝ : SizeOf S'\ntoRingHom : RingHom P.Ring P'.Ring\ntoRingHom_algebraMap : ∀ (x : R), Eq (toRingHom ((algebraMap R P.Ring) x)) ((algebraMap R' P'.Ring) ((algebraMap R R') x))\nalgebraMap_toRingHom : ∀ (x : P.Ring), Eq ((algebraMap P'.Ring S') (toRingHom x)) ((algebraMap S S') ((algebraMap P.Ring S) x))\n⊢ Eq (SizeOf.sizeOf { toRingHom := toRingHom, toRingHom_algebraMap := toRingHom_algebraMap, algebraMap_toRingHom := algebraMap_toRingHom }) (HAdd.hAdd 1 (SizeOf.sizeOf toRingHom))","decl":"/-- Given a commuting square\n```\nR --→ P -→ S\n|          |\n↓          ↓\nR' -→ P' → S\n```\nA hom between `P` and `P'` is a ring homomorphism that makes the two squares commute.\n-/\n@[ext]\nstructure Hom where\n  /-- The underlying ring homomorphism of a hom between extensions. -/\n  toRingHom : P.Ring →+* P'.Ring\n  toRingHom_algebraMap :\n    ∀ x, toRingHom (algebraMap R P.Ring x) = algebraMap R' P'.Ring (algebraMap R R' x)\n  algebraMap_toRingHom :\n    ∀ x, (algebraMap P'.Ring S' (toRingHom x)) = algebraMap S S' (algebraMap P.Ring S x)\n\n"}
{"name":"Algebra.Extension.Hom.mk.injEq","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁴ : CommRing R'\ninst✝³ : CommRing S'\ninst✝² : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝¹ : Algebra R R'\ninst✝ : Algebra S S'\ntoRingHom✝ : RingHom P.Ring P'.Ring\ntoRingHom_algebraMap✝ : ∀ (x : R), Eq (toRingHom✝ ((algebraMap R P.Ring) x)) ((algebraMap R' P'.Ring) ((algebraMap R R') x))\nalgebraMap_toRingHom✝ : ∀ (x : P.Ring), Eq ((algebraMap P'.Ring S') (toRingHom✝ x)) ((algebraMap S S') ((algebraMap P.Ring S) x))\ntoRingHom : RingHom P.Ring P'.Ring\ntoRingHom_algebraMap : ∀ (x : R), Eq (toRingHom ((algebraMap R P.Ring) x)) ((algebraMap R' P'.Ring) ((algebraMap R R') x))\nalgebraMap_toRingHom : ∀ (x : P.Ring), Eq ((algebraMap P'.Ring S') (toRingHom x)) ((algebraMap S S') ((algebraMap P.Ring S) x))\n⊢ Eq (Eq { toRingHom := toRingHom✝, toRingHom_algebraMap := toRingHom_algebraMap✝, algebraMap_toRingHom := algebraMap_toRingHom✝ } { toRingHom := toRingHom, toRingHom_algebraMap := toRingHom_algebraMap, algebraMap_toRingHom := algebraMap_toRingHom }) (Eq toRingHom✝ toRingHom)","decl":"/-- Given a commuting square\n```\nR --→ P -→ S\n|          |\n↓          ↓\nR' -→ P' → S\n```\nA hom between `P` and `P'` is a ring homomorphism that makes the two squares commute.\n-/\n@[ext]\nstructure Hom where\n  /-- The underlying ring homomorphism of a hom between extensions. -/\n  toRingHom : P.Ring →+* P'.Ring\n  toRingHom_algebraMap :\n    ∀ x, toRingHom (algebraMap R P.Ring x) = algebraMap R' P'.Ring (algebraMap R R' x)\n  algebraMap_toRingHom :\n    ∀ x, (algebraMap P'.Ring S' (toRingHom x)) = algebraMap S S' (algebraMap P.Ring S x)\n\n"}
{"name":"Algebra.Extension.Hom.toRingHom_algebraMap","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁴ : CommRing R'\ninst✝³ : CommRing S'\ninst✝² : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝¹ : Algebra R R'\ninst✝ : Algebra S S'\nself : P.Hom P'\nx : R\n⊢ Eq (self.toRingHom ((algebraMap R P.Ring) x)) ((algebraMap R' P'.Ring) ((algebraMap R R') x))","decl":"/-- Given a commuting square\n```\nR --→ P -→ S\n|          |\n↓          ↓\nR' -→ P' → S\n```\nA hom between `P` and `P'` is a ring homomorphism that makes the two squares commute.\n-/\n@[ext]\nstructure Hom where\n  /-- The underlying ring homomorphism of a hom between extensions. -/\n  toRingHom : P.Ring →+* P'.Ring\n  toRingHom_algebraMap :\n    ∀ x, toRingHom (algebraMap R P.Ring x) = algebraMap R' P'.Ring (algebraMap R R' x)\n  algebraMap_toRingHom :\n    ∀ x, (algebraMap P'.Ring S' (toRingHom x)) = algebraMap S S' (algebraMap P.Ring S x)\n\n"}
{"name":"Algebra.Extension.Hom.mk.inj","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁴ : CommRing R'\ninst✝³ : CommRing S'\ninst✝² : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝¹ : Algebra R R'\ninst✝ : Algebra S S'\ntoRingHom✝ : RingHom P.Ring P'.Ring\ntoRingHom_algebraMap✝ : ∀ (x : R), Eq (toRingHom✝ ((algebraMap R P.Ring) x)) ((algebraMap R' P'.Ring) ((algebraMap R R') x))\nalgebraMap_toRingHom✝ : ∀ (x : P.Ring), Eq ((algebraMap P'.Ring S') (toRingHom✝ x)) ((algebraMap S S') ((algebraMap P.Ring S) x))\ntoRingHom : RingHom P.Ring P'.Ring\ntoRingHom_algebraMap : ∀ (x : R), Eq (toRingHom ((algebraMap R P.Ring) x)) ((algebraMap R' P'.Ring) ((algebraMap R R') x))\nalgebraMap_toRingHom : ∀ (x : P.Ring), Eq ((algebraMap P'.Ring S') (toRingHom x)) ((algebraMap S S') ((algebraMap P.Ring S) x))\nx✝ : Eq { toRingHom := toRingHom✝, toRingHom_algebraMap := toRingHom_algebraMap✝, algebraMap_toRingHom := algebraMap_toRingHom✝ } { toRingHom := toRingHom, toRingHom_algebraMap := toRingHom_algebraMap, algebraMap_toRingHom := algebraMap_toRingHom }\n⊢ Eq toRingHom✝ toRingHom","decl":"/-- Given a commuting square\n```\nR --→ P -→ S\n|          |\n↓          ↓\nR' -→ P' → S\n```\nA hom between `P` and `P'` is a ring homomorphism that makes the two squares commute.\n-/\n@[ext]\nstructure Hom where\n  /-- The underlying ring homomorphism of a hom between extensions. -/\n  toRingHom : P.Ring →+* P'.Ring\n  toRingHom_algebraMap :\n    ∀ x, toRingHom (algebraMap R P.Ring x) = algebraMap R' P'.Ring (algebraMap R R' x)\n  algebraMap_toRingHom :\n    ∀ x, (algebraMap P'.Ring S' (toRingHom x)) = algebraMap S S' (algebraMap P.Ring S x)\n\n"}
{"name":"Algebra.Extension.Hom.ext","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁴ : CommRing R'\ninst✝³ : CommRing S'\ninst✝² : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝¹ : Algebra R R'\ninst✝ : Algebra S S'\nx y : P.Hom P'\ntoRingHom : Eq x.toRingHom y.toRingHom\n⊢ Eq x y","decl":"/-- Given a commuting square\n```\nR --→ P -→ S\n|          |\n↓          ↓\nR' -→ P' → S\n```\nA hom between `P` and `P'` is a ring homomorphism that makes the two squares commute.\n-/\n@[ext]\nstructure Hom where\n  /-- The underlying ring homomorphism of a hom between extensions. -/\n  toRingHom : P.Ring →+* P'.Ring\n  toRingHom_algebraMap :\n    ∀ x, toRingHom (algebraMap R P.Ring x) = algebraMap R' P'.Ring (algebraMap R R' x)\n  algebraMap_toRingHom :\n    ∀ x, (algebraMap P'.Ring S' (toRingHom x)) = algebraMap S S' (algebraMap P.Ring S x)\n\n"}
{"name":"Algebra.Extension.Hom.algebraMap_toRingHom","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁴ : CommRing R'\ninst✝³ : CommRing S'\ninst✝² : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝¹ : Algebra R R'\ninst✝ : Algebra S S'\nself : P.Hom P'\nx : P.Ring\n⊢ Eq ((algebraMap P'.Ring S') (self.toRingHom x)) ((algebraMap S S') ((algebraMap P.Ring S) x))","decl":"/-- Given a commuting square\n```\nR --→ P -→ S\n|          |\n↓          ↓\nR' -→ P' → S\n```\nA hom between `P` and `P'` is a ring homomorphism that makes the two squares commute.\n-/\n@[ext]\nstructure Hom where\n  /-- The underlying ring homomorphism of a hom between extensions. -/\n  toRingHom : P.Ring →+* P'.Ring\n  toRingHom_algebraMap :\n    ∀ x, toRingHom (algebraMap R P.Ring x) = algebraMap R' P'.Ring (algebraMap R R' x)\n  algebraMap_toRingHom :\n    ∀ x, (algebraMap P'.Ring S' (toRingHom x)) = algebraMap S S' (algebraMap P.Ring S x)\n\n"}
{"name":"Algebra.Extension.Hom.toAlgHom_apply","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_2\nS' : Type u_1\ninst✝⁶ : CommRing R'\ninst✝⁵ : CommRing S'\ninst✝⁴ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝³ : Algebra R R'\ninst✝² : Algebra S S'\ninst✝¹ : Algebra R S'\ninst✝ : IsScalarTower R R' S'\nf : P.Hom P'\nx : P.Ring\n⊢ Eq (f.toAlgHom x) (f.toRingHom x)","decl":"@[simp]\nlemma Hom.toAlgHom_apply [Algebra R S'] [IsScalarTower R R' S'] (f : Hom P P') (x) :\n    f.toAlgHom x = f.toRingHom x := rfl\n\n"}
{"name":"Algebra.Extension.Hom.id_toRingHom","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Eq (Algebra.Extension.Hom.id P).toRingHom (RingHom.id P.Ring)","decl":"/-- The identity hom. -/\n@[simps]\nprotected noncomputable def Hom.id : Hom P P := ⟨RingHom.id _, by simp, by simp⟩\n\n"}
{"name":"Algebra.Extension.Hom.toAlgHom_id","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Eq (Algebra.Extension.Hom.id P).toAlgHom (AlgHom.id R P.Ring)","decl":"@[simp]\nlemma Hom.toAlgHom_id : Hom.toAlgHom (.id P) = AlgHom.id _ _ := by ext1; simp\n\n"}
{"name":"Algebra.Extension.Hom.comp_toRingHom","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁴ : CommRing R\ninst✝¹³ : CommRing S\ninst✝¹² : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_1\nS' : Type u_2\ninst✝¹¹ : CommRing R'\ninst✝¹⁰ : CommRing S'\ninst✝⁹ : Algebra R' S'\nP' : Algebra.Extension R' S'\nR'' : Type u_4\nS'' : Type u_5\ninst✝⁸ : CommRing R''\ninst✝⁷ : CommRing S''\ninst✝⁶ : Algebra R'' S''\nP'' : Algebra.Extension R'' S''\ninst✝⁵ : Algebra R R'\ninst✝⁴ : Algebra R' R''\ninst✝³ : Algebra R R''\ninst✝² : Algebra S S'\ninst✝¹ : Algebra S' S''\ninst✝ : Algebra S S''\nf : P'.Hom P''\ng : P.Hom P'\n⊢ Eq (f.comp g).toRingHom (f.toRingHom.comp g.toRingHom)","decl":"variable [IsScalarTower R R' R''] [IsScalarTower S S' S''] in\n/-- The composition of two homs. -/\n@[simps]\nnoncomputable def Hom.comp (f : Hom P' P'') (g : Hom P P') : Hom P P'' where\n  toRingHom := f.toRingHom.comp g.toRingHom\n  toRingHom_algebraMap := by simp [← IsScalarTower.algebraMap_apply]\n  algebraMap_toRingHom := by simp [← IsScalarTower.algebraMap_apply]\n\n"}
{"name":"Algebra.Extension.Hom.comp_id","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁴ : CommRing R'\ninst✝³ : CommRing S'\ninst✝² : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝¹ : Algebra R R'\ninst✝ : Algebra S S'\nf : P.Hom P'\n⊢ Eq (f.comp (Algebra.Extension.Hom.id P)) f","decl":"@[simp]\nlemma Hom.comp_id (f : Hom P P') : f.comp (Hom.id P) = f := by ext; simp\n\n"}
{"name":"Algebra.Extension.Hom.id_comp","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁴ : CommRing R'\ninst✝³ : CommRing S'\ninst✝² : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝¹ : Algebra R R'\ninst✝ : Algebra S S'\nf : P.Hom P'\n⊢ Eq ((Algebra.Extension.Hom.id P').comp f) f","decl":"@[simp]\nlemma Hom.id_comp (f : Hom P P') : (Hom.id P').comp f = f := by\n  ext; simp [Hom.id, aeval_X_left]\n\n"}
{"name":"Algebra.Extension.Hom.mapKer_apply_coe","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁴ : CommRing R'\ninst✝³ : CommRing S'\ninst✝² : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝¹ : Algebra R R'\ninst✝ : Algebra S S'\nf : P.Hom P'\nalg : Algebra P.Ring P'.Ring\nhalg : Eq (algebraMap P.Ring P'.Ring) f.toRingHom\nx : Subtype fun x => Membership.mem P.ker x\n⊢ Eq (↑((f.mapKer halg) x)) (f.toRingHom ↑x)","decl":"/-- A map between extensions induce a map between kernels. -/\n@[simps]\ndef Hom.mapKer (f : P.Hom P')\n    [alg : Algebra P.Ring P'.Ring] (halg : algebraMap P.Ring P'.Ring = f.toRingHom) :\n    P.ker →ₗ[P.Ring] P'.ker where\n  toFun x := ⟨f.toRingHom x, by simp [show algebraMap P.Ring S x = 0 from x.2]⟩\n  map_add' _ _ := Subtype.ext (map_add _ _ _)\n  map_smul' := by simp [Algebra.smul_def, ← halg]\n\n"}
{"name":"Algebra.Extension.ker_infinitesimal","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Eq P.infinitesimal.ker P.ker.cotangentIdeal","decl":"lemma ker_infinitesimal (P : Extension R S) :\n    P.infinitesimal.ker = P.ker.cotangentIdeal :=\n  AlgHom.ker_kerSquareLift _\n\n"}
{"name":"Algebra.Extension.Cotangent.ext_iff","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nx y : P.Cotangent\n⊢ Iff (Eq x y) (Eq x.val y.val)","decl":"@[ext]\nlemma Cotangent.ext {x y : P.Cotangent} (e : x.val = y.val) : x = y := e\n\n"}
{"name":"Algebra.Extension.Cotangent.ext","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nx y : P.Cotangent\ne : Eq x.val y.val\n⊢ Eq x y","decl":"@[ext]\nlemma Cotangent.ext {x y : P.Cotangent} (e : x.val = y.val) : x = y := e\n\n"}
{"name":"Algebra.Extension.Cotangent.val_add","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nx y : P.Cotangent\n⊢ Eq (HAdd.hAdd x y).val (HAdd.hAdd x.val y.val)","decl":"@[simp] lemma val_add : (x + y).val = x.val + y.val := rfl\n"}
{"name":"Algebra.Extension.Cotangent.val_zero","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Eq (Algebra.Extension.Cotangent.val 0) 0","decl":"@[simp] lemma val_zero : (0 : P.Cotangent).val = 0 := rfl\n"}
{"name":"Algebra.Extension.Cotangent.of_add","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nw z : P.ker.Cotangent\n⊢ Eq (Algebra.Extension.Cotangent.of (HAdd.hAdd w z)) (HAdd.hAdd (Algebra.Extension.Cotangent.of w) (Algebra.Extension.Cotangent.of z))","decl":"@[simp] lemma of_add : of (w + z) = of w + of z := rfl\n"}
{"name":"Algebra.Extension.Cotangent.of_zero","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Eq (Algebra.Extension.Cotangent.of 0) 0","decl":"@[simp] lemma of_zero : (of 0 : P.Cotangent) = 0 := rfl\n"}
{"name":"Algebra.Extension.Cotangent.of_val","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nx : P.Cotangent\n⊢ Eq (Algebra.Extension.Cotangent.of x.val) x","decl":"@[simp] lemma of_val : of x.val = x := rfl\n"}
{"name":"Algebra.Extension.Cotangent.val_of","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nw : P.ker.Cotangent\n⊢ Eq (Algebra.Extension.Cotangent.of w).val w","decl":"@[simp] lemma val_of : (of w).val = w := rfl\n"}
{"name":"Algebra.Extension.Cotangent.val_sub","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nx y : P.Cotangent\n⊢ Eq (HSub.hSub x y).val (HSub.hSub x.val y.val)","decl":"@[simp] lemma val_sub : (x - y).val = x.val - y.val := rfl\n\n"}
{"name":"Algebra.Extension.Cotangent.smul_eq_zero_of_mem","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\np : P.Ring\nhp : Membership.mem P.ker p\nm : P.ker.Cotangent\n⊢ Eq (HSMul.hSMul p m) 0","decl":"lemma Cotangent.smul_eq_zero_of_mem (p : P.Ring) (hp : p ∈ P.ker) (m : P.ker.Cotangent) :\n    p • m = 0 := by\n  obtain ⟨x, rfl⟩ := Ideal.toCotangent_surjective _ m\n  rw [← map_smul, Ideal.toCotangent_eq_zero, Submodule.coe_smul, smul_eq_mul, pow_two]\n  exact Ideal.mul_mem_mul hp x.2\n\n"}
{"name":"Algebra.Extension.instIsScalarTowerCotangent","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Algebra R S\nP : Algebra.Extension R S\nR₁ : Type u_1\nR₂ : Type u_2\ninst✝⁵ : CommRing R₁\ninst✝⁴ : CommRing R₂\ninst✝³ : Algebra R₁ S\ninst✝² : Algebra R₂ S\ninst✝¹ : Algebra R₁ R₂\ninst✝ : IsScalarTower R₁ R₂ S\n⊢ IsScalarTower R₁ R₂ P.Cotangent","decl":"instance {R₁ R₂} [CommRing R₁] [CommRing R₂] [Algebra R₁ S] [Algebra R₂ S] [Algebra R₁ R₂]\n    [IsScalarTower R₁ R₂ S] :\n  IsScalarTower R₁ R₂ P.Cotangent := by\n  constructor\n  intros r s m\n  show algebraMap R₂ S (r • s) • m = (algebraMap _ S r) • (algebraMap _ S s) • m\n  rw [Algebra.smul_def, map_mul, mul_smul, ← IsScalarTower.algebraMap_apply]\n\n"}
{"name":"Algebra.Extension.Cotangent.val_smul'''","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nP : Algebra.Extension R S\nR₀ : Type u_1\ninst✝¹ : CommRing R₀\ninst✝ : Algebra R₀ S\nr : R₀\nx : P.Cotangent\n⊢ Eq (HSMul.hSMul r x).val (HSMul.hSMul (P.σ ((algebraMap R₀ S) r)) x.val)","decl":"/-- The action of `R₀` on `P.Cotangent` for an extension `P → S`, if `S` is an `R₀` algebra. -/\nlemma Cotangent.val_smul''' {R₀} [CommRing R₀] [Algebra R₀ S] (r : R₀) (x : P.Cotangent) :\n    (r • x).val = P.σ (algebraMap R₀ S r) • x.val := rfl\n\n"}
{"name":"Algebra.Extension.Cotangent.val_smul","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nr : S\nx : P.Cotangent\n⊢ Eq (HSMul.hSMul r x).val (HSMul.hSMul (P.σ r) x.val)","decl":"/-- The action of `S` on `P.Cotangent` for an extension `P → S`. -/\n@[simp]\nlemma Cotangent.val_smul (r : S) (x : P.Cotangent) : (r • x).val = P.σ r • x.val := rfl\n\n"}
{"name":"Algebra.Extension.Cotangent.val_smul'","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nr : P.Ring\nx : P.Cotangent\n⊢ Eq (HSMul.hSMul r x).val (HSMul.hSMul r x.val)","decl":"/-- The action of `P` on `P.Cotangent` for an extension `P → S`. -/\n@[simp]\nlemma Cotangent.val_smul' (r : P.Ring) (x : P.Cotangent) : (r • x).val = r • x.val := by\n  rw [val_smul''', ← sub_eq_zero, ← sub_smul]\n  exact Cotangent.smul_eq_zero_of_mem _ (by simp) _\n\n"}
{"name":"Algebra.Extension.Cotangent.val_smul''","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nr : R\nx : P.Cotangent\n⊢ Eq (HSMul.hSMul r x).val (HSMul.hSMul r x.val)","decl":"/-- The action of `R` on `P.Cotangent` for an `R`-extension `P → S`. -/\n@[simp]\nlemma Cotangent.val_smul'' (r : R) (x : P.Cotangent) : (r • x).val = r • x.val := by\n  rw [← algebraMap_smul P.Ring, val_smul', algebraMap_smul]\n\n"}
{"name":"Algebra.Extension.Cotangent.val_mk","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nx : Subtype fun x => Membership.mem P.ker x\n⊢ Eq (Algebra.Extension.Cotangent.mk x).val (P.ker.toCotangent x)","decl":"@[simp]\nlemma Cotangent.val_mk (x : P.ker) : (mk x).val = Ideal.toCotangent _ x := rfl\n\n"}
{"name":"Algebra.Extension.Cotangent.mk_surjective","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Function.Surjective ⇑Algebra.Extension.Cotangent.mk","decl":"lemma Cotangent.mk_surjective : Function.Surjective (mk (P := P)) :=\n  fun x ↦ Ideal.toCotangent_surjective P.ker x.val\n\n"}
{"name":"Algebra.Extension.Cotangent.mk_eq_zero_iff","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nx : Subtype fun x => Membership.mem P.ker x\n⊢ Iff (Eq (Algebra.Extension.Cotangent.mk x) 0) (Membership.mem (HPow.hPow P.ker 2) ↑x)","decl":"lemma Cotangent.mk_eq_zero_iff {P : Extension R S} (x : P.ker) :\n    Cotangent.mk x = 0 ↔ x.val ∈ P.ker ^ 2 := by\n  simp [Cotangent.ext_iff, Ideal.toCotangent_eq_zero]\n\n"}
{"name":"Algebra.Extension.Cotangent.map_mk","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁶ : CommRing R'\ninst✝⁵ : CommRing S'\ninst✝⁴ : Algebra R' S'\nP' : Algebra.Extension R' S'\ninst✝³ : Algebra R R'\ninst✝² : Algebra S S'\ninst✝¹ : Algebra R S'\ninst✝ : IsScalarTower R R' S'\nf : P.Hom P'\nx : Subtype fun x => Membership.mem P.ker x\n⊢ Eq ((Algebra.Extension.Cotangent.map f) (Algebra.Extension.Cotangent.mk x)) (Algebra.Extension.Cotangent.mk ⟨f.toAlgHom ↑x, ⋯⟩)","decl":"@[simp]\nlemma Cotangent.map_mk (f : Hom P P') (x) :\n    Cotangent.map f (.mk x) =\n      .mk ⟨f.toAlgHom x, by simpa [-map_aeval] using RingHom.congr_arg (algebraMap S S') x.2⟩ :=\n  rfl\n\n"}
{"name":"Algebra.Extension.Cotangent.map_id","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Eq (Algebra.Extension.Cotangent.map (Algebra.Extension.Hom.id P)) LinearMap.id","decl":"@[simp]\nlemma Cotangent.map_id :\n    Cotangent.map (.id P) = LinearMap.id := by\n  ext x\n  obtain ⟨x, rfl⟩ := Cotangent.mk_surjective x\n  simp only [map_mk, Hom.toAlgHom_id, AlgHom.coe_id, id_eq, Subtype.coe_eta, val_mk,\n    LinearMap.id_coe]\n\n"}
{"name":"Algebra.Extension.Cotangent.map_comp","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝²² : CommRing R\ninst✝²¹ : CommRing S\ninst✝²⁰ : Algebra R S\nP : Algebra.Extension R S\nR' : Type u_1\nS' : Type u_2\ninst✝¹⁹ : CommRing R'\ninst✝¹⁸ : CommRing S'\ninst✝¹⁷ : Algebra R' S'\nP' : Algebra.Extension R' S'\nR'' : Type u_4\nS'' : Type u_5\ninst✝¹⁶ : CommRing R''\ninst✝¹⁵ : CommRing S''\ninst✝¹⁴ : Algebra R'' S''\nP'' : Algebra.Extension R'' S''\ninst✝¹³ : Algebra R R'\ninst✝¹² : Algebra R' R''\ninst✝¹¹ : Algebra R' S''\ninst✝¹⁰ : Algebra S S'\ninst✝⁹ : Algebra S' S''\ninst✝⁸ : Algebra S S''\ninst✝⁷ : Algebra R S'\ninst✝⁶ : IsScalarTower R R' S'\ninst✝⁵ : Algebra R R''\ninst✝⁴ : IsScalarTower R R' R''\ninst✝³ : IsScalarTower R' R'' S''\ninst✝² : Algebra R S''\ninst✝¹ : IsScalarTower R R'' S''\ninst✝ : IsScalarTower S S' S''\nf : P.Hom P'\ng : P'.Hom P''\n⊢ Eq (Algebra.Extension.Cotangent.map (g.comp f)) ((↑S (Algebra.Extension.Cotangent.map g)).comp (Algebra.Extension.Cotangent.map f))","decl":"lemma Cotangent.map_comp (f : Hom P P') (g : Hom P' P'') :\n    Cotangent.map (g.comp f) = (map g).restrictScalars S ∘ₗ map f := by\n  ext x\n  obtain ⟨x, rfl⟩ := Cotangent.mk_surjective x\n  simp only [map_mk, Hom.toAlgHom_apply, Hom.comp_toRingHom, RingHom.coe_comp, Function.comp_apply,\n    val_mk, LinearMap.coe_comp, LinearMap.coe_restrictScalars]\n\n"}
{"name":"Algebra.Extension.Cotangent.finite","module":"Mathlib.RingTheory.Extension","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\nhP : P.ker.FG\n⊢ Module.Finite S P.Cotangent","decl":"lemma Cotangent.finite (hP : P.ker.FG) :\n    Module.Finite S P.Cotangent := by\n  refine ⟨.of_restrictScalars (R := P.Ring) _ ?_⟩\n  rw [Submodule.restrictScalars_top, ← LinearMap.range_eq_top.mpr Extension.Cotangent.mk_surjective,\n    ← Submodule.map_top]\n  exact (P.ker.fg_top.mpr hP).map _\n\n"}
