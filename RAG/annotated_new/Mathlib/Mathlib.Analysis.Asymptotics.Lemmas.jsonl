{"name":"Asymptotics.isBigOWith_principal","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝¹ : Norm E\ninst✝ : Norm F\nc : Real\nf : α → E\ng : α → F\ns : Set α\n⊢ Iff (Asymptotics.IsBigOWith c (Filter.principal s) f g) (∀ (x : α), Membership.mem s x → LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm (g x))))","decl":"@[simp]\ntheorem isBigOWith_principal {s : Set α} : IsBigOWith c (𝓟 s) f g ↔ ∀ x ∈ s, ‖f x‖ ≤ c * ‖g x‖ := by\n  rw [IsBigOWith_def, eventually_principal]\n\n"}
{"name":"Asymptotics.isBigO_principal","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝¹ : Norm E\ninst✝ : Norm F\nf : α → E\ng : α → F\ns : Set α\n⊢ Iff (Asymptotics.IsBigO (Filter.principal s) f g) (Exists fun c => ∀ (x : α), Membership.mem s x → LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm (g x))))","decl":"theorem isBigO_principal {s : Set α} : f =O[𝓟 s] g ↔ ∃ c, ∀ x ∈ s, ‖f x‖ ≤ c * ‖g x‖ := by\n  simp_rw [isBigO_iff, eventually_principal]\n\n"}
{"name":"Asymptotics.isLittleO_principal","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nF' : Type u_7\nE'' : Type u_9\ninst✝¹ : SeminormedAddCommGroup F'\ninst✝ : NormedAddCommGroup E''\ng' : α → F'\nf'' : α → E''\ns : Set α\n⊢ Iff (Asymptotics.IsLittleO (Filter.principal s) f'' g') (∀ (x : α), Membership.mem s x → Eq (f'' x) 0)","decl":"@[simp]\ntheorem isLittleO_principal {s : Set α} : f'' =o[𝓟 s] g' ↔ ∀ x ∈ s, f'' x = 0 := by\n  refine ⟨fun h x hx ↦ norm_le_zero_iff.1 ?_, fun h ↦ ?_⟩\n  · simp only [isLittleO_iff, isBigOWith_principal] at h\n    have : Tendsto (fun c : ℝ => c * ‖g' x‖) (𝓝[>] 0) (𝓝 0) :=\n      ((continuous_id.mul continuous_const).tendsto' _ _ (zero_mul _)).mono_left\n        inf_le_left\n    apply le_of_tendsto_of_tendsto tendsto_const_nhds this\n    apply eventually_nhdsWithin_iff.2 (Eventually.of_forall (fun c hc ↦ ?_))\n    exact eventually_principal.1 (h hc) x hx\n  · apply (isLittleO_zero g' _).congr' ?_ EventuallyEq.rfl\n    exact fun x hx ↦ (h x hx).symm\n\n"}
{"name":"Asymptotics.isBigOWith_top","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝¹ : Norm E\ninst✝ : Norm F\nc : Real\nf : α → E\ng : α → F\n⊢ Iff (Asymptotics.IsBigOWith c Top.top f g) (∀ (x : α), LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm (g x))))","decl":"@[simp]\ntheorem isBigOWith_top : IsBigOWith c ⊤ f g ↔ ∀ x, ‖f x‖ ≤ c * ‖g x‖ := by\n  rw [IsBigOWith_def, eventually_top]\n\n"}
{"name":"Asymptotics.isBigO_top","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝¹ : Norm E\ninst✝ : Norm F\nf : α → E\ng : α → F\n⊢ Iff (Asymptotics.IsBigO Top.top f g) (Exists fun C => ∀ (x : α), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm (g x))))","decl":"@[simp]\ntheorem isBigO_top : f =O[⊤] g ↔ ∃ C, ∀ x, ‖f x‖ ≤ C * ‖g x‖ := by\n  simp_rw [isBigO_iff, eventually_top]\n\n"}
{"name":"Asymptotics.isLittleO_top","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nF' : Type u_7\nE'' : Type u_9\ninst✝¹ : SeminormedAddCommGroup F'\ninst✝ : NormedAddCommGroup E''\ng' : α → F'\nf'' : α → E''\n⊢ Iff (Asymptotics.IsLittleO Top.top f'' g') (∀ (x : α), Eq (f'' x) 0)","decl":"@[simp]\ntheorem isLittleO_top : f'' =o[⊤] g' ↔ ∀ x, f'' x = 0 := by\n  simp only [← principal_univ, isLittleO_principal, mem_univ, forall_true_left]\n\n"}
{"name":"Asymptotics.isBigOWith_const_one","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝³ : Norm E\ninst✝² : Norm F\ninst✝¹ : One F\ninst✝ : NormOneClass F\nc : E\nl : Filter α\n⊢ Asymptotics.IsBigOWith (Norm.norm c) l (fun _x => c) fun _x => 1","decl":"theorem isBigOWith_const_one (c : E) (l : Filter α) :\n    IsBigOWith ‖c‖ l (fun _x : α => c) fun _x => (1 : F) := by simp [isBigOWith_iff]\n\n"}
{"name":"Asymptotics.isBigO_const_one","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝³ : Norm E\ninst✝² : Norm F\ninst✝¹ : One F\ninst✝ : NormOneClass F\nc : E\nl : Filter α\n⊢ Asymptotics.IsBigO l (fun _x => c) fun _x => 1","decl":"theorem isBigO_const_one (c : E) (l : Filter α) : (fun _x : α => c) =O[l] fun _x => (1 : F) :=\n  (isBigOWith_const_one F c l).isBigO\n\n"}
{"name":"Asymptotics.isLittleO_const_iff_isLittleO_one","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\nF'' : Type u_10\ninst✝⁴ : Norm E\ninst✝³ : Norm F\ninst✝² : NormedAddCommGroup F''\nf : α → E\nl : Filter α\ninst✝¹ : One F\ninst✝ : NormOneClass F\nc : F''\nhc : Ne c 0\n⊢ Iff (Asymptotics.IsLittleO l f fun _x => c) (Asymptotics.IsLittleO l f fun _x => 1)","decl":"theorem isLittleO_const_iff_isLittleO_one {c : F''} (hc : c ≠ 0) :\n    (f =o[l] fun _x => c) ↔ f =o[l] fun _x => (1 : F) :=\n  ⟨fun h => h.trans_isBigOWith (isBigOWith_const_one _ _ _) (norm_pos_iff.2 hc),\n   fun h => h.trans_isBigO <| isBigO_const_const _ hc _⟩\n\n"}
{"name":"Asymptotics.isLittleO_one_iff","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nF : Type u_4\nE''' : Type u_12\ninst✝³ : Norm F\ninst✝² : SeminormedAddGroup E'''\nl : Filter α\ninst✝¹ : One F\ninst✝ : NormOneClass F\nf : α → E'''\n⊢ Iff (Asymptotics.IsLittleO l f fun _x => 1) (Filter.Tendsto f l (nhds 0))","decl":"@[simp]\ntheorem isLittleO_one_iff {f : α → E'''} : f =o[l] (fun _x => 1 : α → F) ↔ Tendsto f l (𝓝 0) := by\n  simp only [isLittleO_iff, norm_one, mul_one, Metric.nhds_basis_closedBall.tendsto_right_iff,\n    Metric.mem_closedBall, dist_zero_right]\n\n"}
{"name":"Asymptotics.isBigO_one_iff","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝³ : Norm E\ninst✝² : Norm F\nf : α → E\nl : Filter α\ninst✝¹ : One F\ninst✝ : NormOneClass F\n⊢ Iff (Asymptotics.IsBigO l f fun _x => 1) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => Norm.norm (f x))","decl":"@[simp]\ntheorem isBigO_one_iff : f =O[l] (fun _x => 1 : α → F) ↔\n    IsBoundedUnder (· ≤ ·) l fun x => ‖f x‖ := by\n  simp only [isBigO_iff, norm_one, mul_one, IsBoundedUnder, IsBounded, eventually_map]\n\n"}
{"name":"Filter.IsBoundedUnder.isBigO_one","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝³ : Norm E\ninst✝² : Norm F\nf : α → E\nl : Filter α\ninst✝¹ : One F\ninst✝ : NormOneClass F\na✝ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => Norm.norm (f x)\n⊢ Asymptotics.IsBigO l f fun _x => 1","decl":"alias ⟨_, _root_.Filter.IsBoundedUnder.isBigO_one⟩ := isBigO_one_iff\n\n"}
{"name":"Asymptotics.isLittleO_one_left_iff","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝³ : Norm E\ninst✝² : Norm F\nf : α → E\nl : Filter α\ninst✝¹ : One F\ninst✝ : NormOneClass F\n⊢ Iff (Asymptotics.IsLittleO l (fun _x => 1) f) (Filter.Tendsto (fun x => Norm.norm (f x)) l Filter.atTop)","decl":"@[simp]\ntheorem isLittleO_one_left_iff : (fun _x => 1 : α → F) =o[l] f ↔ Tendsto (fun x => ‖f x‖) l atTop :=\n  calc\n    (fun _x => 1 : α → F) =o[l] f ↔ ∀ n : ℕ, ∀ᶠ x in l, ↑n * ‖(1 : F)‖ ≤ ‖f x‖ :=\n      isLittleO_iff_nat_mul_le_aux <| Or.inl fun _x => by simp only [norm_one, zero_le_one]\n    _ ↔ ∀ n : ℕ, True → ∀ᶠ x in l, ‖f x‖ ∈ Ici (n : ℝ) := by\n      simp only [norm_one, mul_one, true_imp_iff, mem_Ici]\n    _ ↔ Tendsto (fun x => ‖f x‖) l atTop :=\n      atTop_hasCountableBasis_of_archimedean.1.tendsto_right_iff.symm\n\n"}
{"name":"Filter.Tendsto.isBigO_one","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nF : Type u_4\nE' : Type u_6\ninst✝³ : Norm F\ninst✝² : SeminormedAddCommGroup E'\nf' : α → E'\nl : Filter α\ninst✝¹ : One F\ninst✝ : NormOneClass F\nc : E'\nh : Filter.Tendsto f' l (nhds c)\n⊢ Asymptotics.IsBigO l f' fun _x => 1","decl":"theorem _root_.Filter.Tendsto.isBigO_one {c : E'} (h : Tendsto f' l (𝓝 c)) :\n    f' =O[l] (fun _x => 1 : α → F) :=\n  h.norm.isBoundedUnder_le.isBigO_one F\n\n"}
{"name":"Asymptotics.IsBigO.trans_tendsto_nhds","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\nF' : Type u_7\ninst✝⁴ : Norm E\ninst✝³ : Norm F\ninst✝² : SeminormedAddCommGroup F'\nf : α → E\ng' : α → F'\nl : Filter α\ninst✝¹ : One F\ninst✝ : NormOneClass F\nhfg : Asymptotics.IsBigO l f g'\ny : F'\nhg : Filter.Tendsto g' l (nhds y)\n⊢ Asymptotics.IsBigO l f fun _x => 1","decl":"theorem IsBigO.trans_tendsto_nhds (hfg : f =O[l] g') {y : F'} (hg : Tendsto g' l (𝓝 y)) :\n    f =O[l] (fun _x => 1 : α → F) :=\n  hfg.trans <| hg.isBigO_one F\n\n"}
{"name":"Asymptotics.isBigO_one_nhds_ne_iff","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁴ : Norm E\ninst✝³ : Norm F\nf : α → E\ninst✝² : One F\ninst✝¹ : NormOneClass F\ninst✝ : TopologicalSpace α\na : α\n⊢ Iff (Asymptotics.IsBigO (nhdsWithin a (HasCompl.compl (Singleton.singleton a))) f fun x => 1) (Asymptotics.IsBigO (nhds a) f fun x => 1)","decl":"/-- The condition `f = O[𝓝[≠] a] 1` is equivalent to `f = O[𝓝 a] 1`. -/\nlemma isBigO_one_nhds_ne_iff [TopologicalSpace α] {a : α} :\n    f =O[𝓝[≠] a] (fun _ ↦ 1 : α → F) ↔ f =O[𝓝 a] (fun _ ↦ 1 : α → F) := by\n  refine ⟨fun h ↦ ?_, fun h ↦ h.mono nhdsWithin_le_nhds⟩\n  simp only [isBigO_one_iff, IsBoundedUnder, IsBounded, eventually_map] at h ⊢\n  obtain ⟨c, hc⟩ := h\n  use max c ‖f a‖\n  filter_upwards [eventually_nhdsWithin_iff.mp hc] with b hb\n  rcases eq_or_ne b a with rfl | hb'\n  · apply le_max_right\n  · exact (hb hb').trans (le_max_left ..)\n\n"}
{"name":"Asymptotics.isLittleO_const_iff","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE'' : Type u_9\nF'' : Type u_10\ninst✝¹ : NormedAddCommGroup E''\ninst✝ : NormedAddCommGroup F''\nf'' : α → E''\nl : Filter α\nc : F''\nhc : Ne c 0\n⊢ Iff (Asymptotics.IsLittleO l f'' fun _x => c) (Filter.Tendsto f'' l (nhds 0))","decl":"theorem isLittleO_const_iff {c : F''} (hc : c ≠ 0) :\n    (f'' =o[l] fun _x => c) ↔ Tendsto f'' l (𝓝 0) :=\n  (isLittleO_const_iff_isLittleO_one ℝ hc).trans (isLittleO_one_iff _)\n\n"}
{"name":"Asymptotics.isLittleO_id_const","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E'' : Type u_9\nF'' : Type u_10\ninst✝¹ : NormedAddCommGroup E''\ninst✝ : NormedAddCommGroup F''\nc : F''\nhc : Ne c 0\n⊢ Asymptotics.IsLittleO (nhds 0) (fun x => x) fun _x => c","decl":"theorem isLittleO_id_const {c : F''} (hc : c ≠ 0) : (fun x : E'' => x) =o[𝓝 0] fun _x => c :=\n  (isLittleO_const_iff hc).mpr (continuous_id.tendsto 0)\n\n"}
{"name":"Filter.IsBoundedUnder.isBigO_const","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF'' : Type u_10\ninst✝¹ : Norm E\ninst✝ : NormedAddCommGroup F''\nf : α → E\nl : Filter α\nh : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm f)\nc : F''\nhc : Ne c 0\n⊢ Asymptotics.IsBigO l f fun _x => c","decl":"theorem _root_.Filter.IsBoundedUnder.isBigO_const (h : IsBoundedUnder (· ≤ ·) l (norm ∘ f))\n    {c : F''} (hc : c ≠ 0) : f =O[l] fun _x => c :=\n  (h.isBigO_one ℝ).trans (isBigO_const_const _ hc _)\n\n"}
{"name":"Asymptotics.isBigO_const_of_tendsto","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE'' : Type u_9\nF'' : Type u_10\ninst✝¹ : NormedAddCommGroup E''\ninst✝ : NormedAddCommGroup F''\nf'' : α → E''\nl : Filter α\ny : E''\nh : Filter.Tendsto f'' l (nhds y)\nc : F''\nhc : Ne c 0\n⊢ Asymptotics.IsBigO l f'' fun _x => c","decl":"theorem isBigO_const_of_tendsto {y : E''} (h : Tendsto f'' l (𝓝 y)) {c : F''} (hc : c ≠ 0) :\n    f'' =O[l] fun _x => c :=\n  h.norm.isBoundedUnder_le.isBigO_const hc\n\n"}
{"name":"Asymptotics.IsBigO.isBoundedUnder_le","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝¹ : Norm E\ninst✝ : Norm F\nf : α → E\nl : Filter α\nc : F\nh : Asymptotics.IsBigO l f fun _x => c\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm f)","decl":"theorem IsBigO.isBoundedUnder_le {c : F} (h : f =O[l] fun _x => c) :\n    IsBoundedUnder (· ≤ ·) l (norm ∘ f) :=\n  let ⟨c', hc'⟩ := h.bound\n  ⟨c' * ‖c‖, eventually_map.2 hc'⟩\n\n"}
{"name":"Asymptotics.isBigO_const_of_ne","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF'' : Type u_10\ninst✝¹ : Norm E\ninst✝ : NormedAddCommGroup F''\nf : α → E\nl : Filter α\nc : F''\nhc : Ne c 0\n⊢ Iff (Asymptotics.IsBigO l f fun _x => c) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm f))","decl":"theorem isBigO_const_of_ne {c : F''} (hc : c ≠ 0) :\n    (f =O[l] fun _x => c) ↔ IsBoundedUnder (· ≤ ·) l (norm ∘ f) :=\n  ⟨fun h => h.isBoundedUnder_le, fun h => h.isBigO_const hc⟩\n\n"}
{"name":"Asymptotics.isBigO_const_iff","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE'' : Type u_9\nF'' : Type u_10\ninst✝¹ : NormedAddCommGroup E''\ninst✝ : NormedAddCommGroup F''\nf'' : α → E''\nl : Filter α\nc : F''\n⊢ Iff (Asymptotics.IsBigO l f'' fun _x => c) (And (Eq c 0 → l.EventuallyEq f'' 0) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => Norm.norm (f'' x)))","decl":"theorem isBigO_const_iff {c : F''} : (f'' =O[l] fun _x => c) ↔\n    (c = 0 → f'' =ᶠ[l] 0) ∧ IsBoundedUnder (· ≤ ·) l fun x => ‖f'' x‖ := by\n  refine ⟨fun h => ⟨fun hc => isBigO_zero_right_iff.1 (by rwa [← hc]), h.isBoundedUnder_le⟩, ?_⟩\n  rintro ⟨hcf, hf⟩\n  rcases eq_or_ne c 0 with (hc | hc)\n  exacts [(hcf hc).trans_isBigO (isBigO_zero _ _), hf.isBigO_const hc]\n\n"}
{"name":"Asymptotics.isBigO_iff_isBoundedUnder_le_div","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF'' : Type u_10\ninst✝¹ : Norm E\ninst✝ : NormedAddCommGroup F''\nf : α → E\ng'' : α → F''\nl : Filter α\nh : Filter.Eventually (fun x => Ne (g'' x) 0) l\n⊢ Iff (Asymptotics.IsBigO l f g'') (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => HDiv.hDiv (Norm.norm (f x)) (Norm.norm (g'' x)))","decl":"theorem isBigO_iff_isBoundedUnder_le_div (h : ∀ᶠ x in l, g'' x ≠ 0) :\n    f =O[l] g'' ↔ IsBoundedUnder (· ≤ ·) l fun x => ‖f x‖ / ‖g'' x‖ := by\n  simp only [isBigO_iff, IsBoundedUnder, IsBounded, eventually_map]\n  exact\n    exists_congr fun c =>\n      eventually_congr <| h.mono fun x hx => (div_le_iff₀ <| norm_pos_iff.2 hx).symm\n\n"}
{"name":"Asymptotics.isBigO_const_left_iff_pos_le_norm","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\nE'' : Type u_9\ninst✝¹ : SeminormedAddCommGroup E'\ninst✝ : NormedAddCommGroup E''\nf' : α → E'\nl : Filter α\nc : E''\nhc : Ne c 0\n⊢ Iff (Asymptotics.IsBigO l (fun _x => c) f') (Exists fun b => And (LT.lt 0 b) (Filter.Eventually (fun x => LE.le b (Norm.norm (f' x))) l))","decl":"/-- `(fun x ↦ c) =O[l] f` if and only if `f` is bounded away from zero. -/\ntheorem isBigO_const_left_iff_pos_le_norm {c : E''} (hc : c ≠ 0) :\n    (fun _x => c) =O[l] f' ↔ ∃ b, 0 < b ∧ ∀ᶠ x in l, b ≤ ‖f' x‖ := by\n  constructor\n  · intro h\n    rcases h.exists_pos with ⟨C, hC₀, hC⟩\n    refine ⟨‖c‖ / C, div_pos (norm_pos_iff.2 hc) hC₀, ?_⟩\n    exact hC.bound.mono fun x => (div_le_iff₀' hC₀).2\n  · rintro ⟨b, hb₀, hb⟩\n    refine IsBigO.of_bound (‖c‖ / b) (hb.mono fun x hx => ?_)\n    rw [div_mul_eq_mul_div, mul_div_assoc]\n    exact le_mul_of_one_le_right (norm_nonneg _) ((one_le_div hb₀).2 hx)\n\n"}
{"name":"Asymptotics.IsBigO.trans_tendsto","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE'' : Type u_9\nF'' : Type u_10\ninst✝¹ : NormedAddCommGroup E''\ninst✝ : NormedAddCommGroup F''\nf'' : α → E''\ng'' : α → F''\nl : Filter α\nhfg : Asymptotics.IsBigO l f'' g''\nhg : Filter.Tendsto g'' l (nhds 0)\n⊢ Filter.Tendsto f'' l (nhds 0)","decl":"theorem IsBigO.trans_tendsto (hfg : f'' =O[l] g'') (hg : Tendsto g'' l (𝓝 0)) :\n    Tendsto f'' l (𝓝 0) :=\n  (isLittleO_one_iff ℝ).1 <| hfg.trans_isLittleO <| (isLittleO_one_iff ℝ).2 hg\n\n"}
{"name":"Asymptotics.IsLittleO.trans_tendsto","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE'' : Type u_9\nF'' : Type u_10\ninst✝¹ : NormedAddCommGroup E''\ninst✝ : NormedAddCommGroup F''\nf'' : α → E''\ng'' : α → F''\nl : Filter α\nhfg : Asymptotics.IsLittleO l f'' g''\nhg : Filter.Tendsto g'' l (nhds 0)\n⊢ Filter.Tendsto f'' l (nhds 0)","decl":"theorem IsLittleO.trans_tendsto (hfg : f'' =o[l] g'') (hg : Tendsto g'' l (𝓝 0)) :\n    Tendsto f'' l (𝓝 0) :=\n  hfg.isBigO.trans_tendsto hg\n\n"}
{"name":"Asymptotics.isLittleO_id_one","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E'' : Type u_9\nF'' : Type u_10\ninst✝³ : NormedAddCommGroup E''\ninst✝² : NormedAddCommGroup F''\ninst✝¹ : One F''\ninst✝ : NeZero 1\n⊢ Asymptotics.IsLittleO (nhds 0) (fun x => x) 1","decl":"lemma isLittleO_id_one [One F''] [NeZero (1 : F'')] : (fun x : E'' => x) =o[𝓝 0] (1 : E'' → F'') :=\n  isLittleO_id_const one_ne_zero\n\n"}
{"name":"Asymptotics.continuousAt_iff_isLittleO","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_17\nE : Type u_18\ninst✝² : NormedRing E\ninst✝¹ : NormOneClass E\ninst✝ : TopologicalSpace α\nf : α → E\nx : α\n⊢ Iff (ContinuousAt f x) (Asymptotics.IsLittleO (nhds x) (fun y => HSub.hSub (f y) (f x)) fun x => 1)","decl":"theorem continuousAt_iff_isLittleO {α : Type*} {E : Type*} [NormedRing E] [NormOneClass E]\n    [TopologicalSpace α] {f : α → E} {x : α} :\n    (ContinuousAt f x) ↔ (fun (y : α) ↦ f y - f x) =o[𝓝 x] (fun (_ : α) ↦ (1 : E)) := by\n  simp [ContinuousAt, ← tendsto_sub_nhds_zero_iff]\n\n"}
{"name":"Asymptotics.IsBigO.of_pow","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nR : Type u_13\n𝕜 : Type u_15\ninst✝¹ : SeminormedRing R\ninst✝ : NormedDivisionRing 𝕜\nl : Filter α\nf : α → 𝕜\ng : α → R\nn : Nat\nhn : Ne n 0\nh : Asymptotics.IsBigO l (HPow.hPow f n) (HPow.hPow g n)\n⊢ Asymptotics.IsBigO l f g","decl":"theorem IsBigO.of_pow {f : α → 𝕜} {g : α → R} {n : ℕ} (hn : n ≠ 0) (h : (f ^ n) =O[l] (g ^ n)) :\n    f =O[l] g := by\n  rcases h.exists_pos with ⟨C, _hC₀, hC⟩\n  obtain ⟨c : ℝ, hc₀ : 0 ≤ c, hc : C ≤ c ^ n⟩ :=\n    ((eventually_ge_atTop _).and <| (tendsto_pow_atTop hn).eventually_ge_atTop C).exists\n  exact (hC.of_pow hn hc hc₀).isBigO\n\n"}
{"name":"Asymptotics.IsBigOWith.const_smul_self","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\nR : Type u_13\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : SeminormedRing R\nf' : α → E'\nl : Filter α\ninst✝¹ : Module R E'\ninst✝ : BoundedSMul R E'\nc' : R\n⊢ Asymptotics.IsBigOWith (Norm.norm c') l (fun x => HSMul.hSMul c' (f' x)) f'","decl":"theorem IsBigOWith.const_smul_self (c' : R) :\n    IsBigOWith (‖c'‖) l (fun x => c' • f' x) f' :=\n  isBigOWith_of_le' _ fun _ => norm_smul_le _ _\n\n"}
{"name":"Asymptotics.IsBigO.const_smul_self","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\nR : Type u_13\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : SeminormedRing R\nf' : α → E'\nl : Filter α\ninst✝¹ : Module R E'\ninst✝ : BoundedSMul R E'\nc' : R\n⊢ Asymptotics.IsBigO l (fun x => HSMul.hSMul c' (f' x)) f'","decl":"theorem IsBigO.const_smul_self (c' : R) : (fun x => c' • f' x) =O[l] f' :=\n  (IsBigOWith.const_smul_self _).isBigO\n\n"}
{"name":"Asymptotics.IsBigOWith.const_smul_left","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nF : Type u_4\nE' : Type u_6\nR : Type u_13\ninst✝⁴ : Norm F\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : SeminormedRing R\nc : Real\ng : α → F\nf' : α → E'\nl : Filter α\ninst✝¹ : Module R E'\ninst✝ : BoundedSMul R E'\nh : Asymptotics.IsBigOWith c l f' g\nc' : R\n⊢ Asymptotics.IsBigOWith (HMul.hMul (Norm.norm c') c) l (fun x => HSMul.hSMul c' (f' x)) g","decl":"theorem IsBigOWith.const_smul_left (h : IsBigOWith c l f' g) (c' : R) :\n    IsBigOWith (‖c'‖ * c) l (fun x => c' • f' x) g :=\n  .trans (.const_smul_self _) h (norm_nonneg _)\n\n"}
{"name":"Asymptotics.IsBigO.const_smul_left","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nF : Type u_4\nE' : Type u_6\nR : Type u_13\ninst✝⁴ : Norm F\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : SeminormedRing R\ng : α → F\nf' : α → E'\nl : Filter α\ninst✝¹ : Module R E'\ninst✝ : BoundedSMul R E'\nh : Asymptotics.IsBigO l f' g\nc : R\n⊢ Asymptotics.IsBigO l (HSMul.hSMul c f') g","decl":"theorem IsBigO.const_smul_left (h : f' =O[l] g) (c : R) : (c • f') =O[l] g :=\n  let ⟨_b, hb⟩ := h.isBigOWith\n  (hb.const_smul_left _).isBigO\n\n"}
{"name":"Asymptotics.IsLittleO.const_smul_left","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nF : Type u_4\nE' : Type u_6\nR : Type u_13\ninst✝⁴ : Norm F\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : SeminormedRing R\ng : α → F\nf' : α → E'\nl : Filter α\ninst✝¹ : Module R E'\ninst✝ : BoundedSMul R E'\nh : Asymptotics.IsLittleO l f' g\nc : R\n⊢ Asymptotics.IsLittleO l (HSMul.hSMul c f') g","decl":"theorem IsLittleO.const_smul_left (h : f' =o[l] g) (c : R) : (c • f') =o[l] g :=\n  (IsBigO.const_smul_self _).trans_isLittleO h\n\n"}
{"name":"Asymptotics.isBigO_const_smul_left","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nF : Type u_4\nE' : Type u_6\n𝕜 : Type u_15\ninst✝⁴ : Norm F\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : NormedDivisionRing 𝕜\ng : α → F\nf' : α → E'\nl : Filter α\ninst✝¹ : Module 𝕜 E'\ninst✝ : BoundedSMul 𝕜 E'\nc : 𝕜\nhc : Ne c 0\n⊢ Iff (Asymptotics.IsBigO l (fun x => HSMul.hSMul c (f' x)) g) (Asymptotics.IsBigO l f' g)","decl":"theorem isBigO_const_smul_left {c : 𝕜} (hc : c ≠ 0) : (fun x => c • f' x) =O[l] g ↔ f' =O[l] g := by\n  have cne0 : ‖c‖ ≠ 0 := norm_ne_zero_iff.mpr hc\n  rw [← isBigO_norm_left]\n  simp only [norm_smul]\n  rw [isBigO_const_mul_left_iff cne0, isBigO_norm_left]\n\n"}
{"name":"Asymptotics.isLittleO_const_smul_left","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nF : Type u_4\nE' : Type u_6\n𝕜 : Type u_15\ninst✝⁴ : Norm F\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : NormedDivisionRing 𝕜\ng : α → F\nf' : α → E'\nl : Filter α\ninst✝¹ : Module 𝕜 E'\ninst✝ : BoundedSMul 𝕜 E'\nc : 𝕜\nhc : Ne c 0\n⊢ Iff (Asymptotics.IsLittleO l (fun x => HSMul.hSMul c (f' x)) g) (Asymptotics.IsLittleO l f' g)","decl":"theorem isLittleO_const_smul_left {c : 𝕜} (hc : c ≠ 0) :\n    (fun x => c • f' x) =o[l] g ↔ f' =o[l] g := by\n  have cne0 : ‖c‖ ≠ 0 := norm_ne_zero_iff.mpr hc\n  rw [← isLittleO_norm_left]\n  simp only [norm_smul]\n  rw [isLittleO_const_mul_left_iff cne0, isLittleO_norm_left]\n\n"}
{"name":"Asymptotics.isBigO_const_smul_right","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nE' : Type u_6\n𝕜 : Type u_15\ninst✝⁴ : Norm E\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : NormedDivisionRing 𝕜\nf : α → E\nf' : α → E'\nl : Filter α\ninst✝¹ : Module 𝕜 E'\ninst✝ : BoundedSMul 𝕜 E'\nc : 𝕜\nhc : Ne c 0\n⊢ Iff (Asymptotics.IsBigO l f fun x => HSMul.hSMul c (f' x)) (Asymptotics.IsBigO l f f')","decl":"theorem isBigO_const_smul_right {c : 𝕜} (hc : c ≠ 0) :\n    (f =O[l] fun x => c • f' x) ↔ f =O[l] f' := by\n  have cne0 : ‖c‖ ≠ 0 := norm_ne_zero_iff.mpr hc\n  rw [← isBigO_norm_right]\n  simp only [norm_smul]\n  rw [isBigO_const_mul_right_iff cne0, isBigO_norm_right]\n\n"}
{"name":"Asymptotics.isLittleO_const_smul_right","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nE' : Type u_6\n𝕜 : Type u_15\ninst✝⁴ : Norm E\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : NormedDivisionRing 𝕜\nf : α → E\nf' : α → E'\nl : Filter α\ninst✝¹ : Module 𝕜 E'\ninst✝ : BoundedSMul 𝕜 E'\nc : 𝕜\nhc : Ne c 0\n⊢ Iff (Asymptotics.IsLittleO l f fun x => HSMul.hSMul c (f' x)) (Asymptotics.IsLittleO l f f')","decl":"theorem isLittleO_const_smul_right {c : 𝕜} (hc : c ≠ 0) :\n    (f =o[l] fun x => c • f' x) ↔ f =o[l] f' := by\n  have cne0 : ‖c‖ ≠ 0 := norm_ne_zero_iff.mpr hc\n  rw [← isLittleO_norm_right]\n  simp only [norm_smul]\n  rw [isLittleO_const_mul_right_iff cne0, isLittleO_norm_right]\n\n"}
{"name":"Asymptotics.IsBigOWith.smul","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\nF' : Type u_7\nR : Type u_13\n𝕜' : Type u_16\ninst✝⁷ : SeminormedAddCommGroup E'\ninst✝⁶ : SeminormedAddCommGroup F'\ninst✝⁵ : SeminormedRing R\ninst✝⁴ : NormedDivisionRing 𝕜'\nc c' : Real\nf' : α → E'\ng' : α → F'\nl : Filter α\ninst✝³ : Module R E'\ninst✝² : BoundedSMul R E'\ninst✝¹ : Module 𝕜' F'\ninst✝ : BoundedSMul 𝕜' F'\nk₁ : α → R\nk₂ : α → 𝕜'\nh₁ : Asymptotics.IsBigOWith c l k₁ k₂\nh₂ : Asymptotics.IsBigOWith c' l f' g'\n⊢ Asymptotics.IsBigOWith (HMul.hMul c c') l (fun x => HSMul.hSMul (k₁ x) (f' x)) fun x => HSMul.hSMul (k₂ x) (g' x)","decl":"theorem IsBigOWith.smul (h₁ : IsBigOWith c l k₁ k₂) (h₂ : IsBigOWith c' l f' g') :\n    IsBigOWith (c * c') l (fun x => k₁ x • f' x) fun x => k₂ x • g' x := by\n  simp only [IsBigOWith_def] at *\n  filter_upwards [h₁, h₂] with _ hx₁ hx₂\n  apply le_trans (norm_smul_le _ _)\n  convert mul_le_mul hx₁ hx₂ (norm_nonneg _) (le_trans (norm_nonneg _) hx₁) using 1\n  rw [norm_smul, mul_mul_mul_comm]\n\n"}
{"name":"Asymptotics.IsBigO.smul","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\nF' : Type u_7\nR : Type u_13\n𝕜' : Type u_16\ninst✝⁷ : SeminormedAddCommGroup E'\ninst✝⁶ : SeminormedAddCommGroup F'\ninst✝⁵ : SeminormedRing R\ninst✝⁴ : NormedDivisionRing 𝕜'\nf' : α → E'\ng' : α → F'\nl : Filter α\ninst✝³ : Module R E'\ninst✝² : BoundedSMul R E'\ninst✝¹ : Module 𝕜' F'\ninst✝ : BoundedSMul 𝕜' F'\nk₁ : α → R\nk₂ : α → 𝕜'\nh₁ : Asymptotics.IsBigO l k₁ k₂\nh₂ : Asymptotics.IsBigO l f' g'\n⊢ Asymptotics.IsBigO l (fun x => HSMul.hSMul (k₁ x) (f' x)) fun x => HSMul.hSMul (k₂ x) (g' x)","decl":"theorem IsBigO.smul (h₁ : k₁ =O[l] k₂) (h₂ : f' =O[l] g') :\n    (fun x => k₁ x • f' x) =O[l] fun x => k₂ x • g' x := by\n  obtain ⟨c₁, h₁⟩ := h₁.isBigOWith\n  obtain ⟨c₂, h₂⟩ := h₂.isBigOWith\n  exact (h₁.smul h₂).isBigO\n\n"}
{"name":"Asymptotics.IsBigO.smul_isLittleO","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\nF' : Type u_7\nR : Type u_13\n𝕜' : Type u_16\ninst✝⁷ : SeminormedAddCommGroup E'\ninst✝⁶ : SeminormedAddCommGroup F'\ninst✝⁵ : SeminormedRing R\ninst✝⁴ : NormedDivisionRing 𝕜'\nf' : α → E'\ng' : α → F'\nl : Filter α\ninst✝³ : Module R E'\ninst✝² : BoundedSMul R E'\ninst✝¹ : Module 𝕜' F'\ninst✝ : BoundedSMul 𝕜' F'\nk₁ : α → R\nk₂ : α → 𝕜'\nh₁ : Asymptotics.IsBigO l k₁ k₂\nh₂ : Asymptotics.IsLittleO l f' g'\n⊢ Asymptotics.IsLittleO l (fun x => HSMul.hSMul (k₁ x) (f' x)) fun x => HSMul.hSMul (k₂ x) (g' x)","decl":"theorem IsBigO.smul_isLittleO (h₁ : k₁ =O[l] k₂) (h₂ : f' =o[l] g') :\n    (fun x => k₁ x • f' x) =o[l] fun x => k₂ x • g' x := by\n  simp only [IsLittleO_def] at *\n  intro c cpos\n  rcases h₁.exists_pos with ⟨c', c'pos, hc'⟩\n  exact (hc'.smul (h₂ (div_pos cpos c'pos))).congr_const (mul_div_cancel₀ _ (ne_of_gt c'pos))\n\n"}
{"name":"Asymptotics.IsLittleO.smul_isBigO","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\nF' : Type u_7\nR : Type u_13\n𝕜' : Type u_16\ninst✝⁷ : SeminormedAddCommGroup E'\ninst✝⁶ : SeminormedAddCommGroup F'\ninst✝⁵ : SeminormedRing R\ninst✝⁴ : NormedDivisionRing 𝕜'\nf' : α → E'\ng' : α → F'\nl : Filter α\ninst✝³ : Module R E'\ninst✝² : BoundedSMul R E'\ninst✝¹ : Module 𝕜' F'\ninst✝ : BoundedSMul 𝕜' F'\nk₁ : α → R\nk₂ : α → 𝕜'\nh₁ : Asymptotics.IsLittleO l k₁ k₂\nh₂ : Asymptotics.IsBigO l f' g'\n⊢ Asymptotics.IsLittleO l (fun x => HSMul.hSMul (k₁ x) (f' x)) fun x => HSMul.hSMul (k₂ x) (g' x)","decl":"theorem IsLittleO.smul_isBigO (h₁ : k₁ =o[l] k₂) (h₂ : f' =O[l] g') :\n    (fun x => k₁ x • f' x) =o[l] fun x => k₂ x • g' x := by\n  simp only [IsLittleO_def] at *\n  intro c cpos\n  rcases h₂.exists_pos with ⟨c', c'pos, hc'⟩\n  exact ((h₁ (div_pos cpos c'pos)).smul hc').congr_const (div_mul_cancel₀ _ (ne_of_gt c'pos))\n\n"}
{"name":"Asymptotics.IsLittleO.smul","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\nF' : Type u_7\nR : Type u_13\n𝕜' : Type u_16\ninst✝⁷ : SeminormedAddCommGroup E'\ninst✝⁶ : SeminormedAddCommGroup F'\ninst✝⁵ : SeminormedRing R\ninst✝⁴ : NormedDivisionRing 𝕜'\nf' : α → E'\ng' : α → F'\nl : Filter α\ninst✝³ : Module R E'\ninst✝² : BoundedSMul R E'\ninst✝¹ : Module 𝕜' F'\ninst✝ : BoundedSMul 𝕜' F'\nk₁ : α → R\nk₂ : α → 𝕜'\nh₁ : Asymptotics.IsLittleO l k₁ k₂\nh₂ : Asymptotics.IsLittleO l f' g'\n⊢ Asymptotics.IsLittleO l (fun x => HSMul.hSMul (k₁ x) (f' x)) fun x => HSMul.hSMul (k₂ x) (g' x)","decl":"theorem IsLittleO.smul (h₁ : k₁ =o[l] k₂) (h₂ : f' =o[l] g') :\n    (fun x => k₁ x • f' x) =o[l] fun x => k₂ x • g' x :=\n  h₁.smul_isBigO h₂.isBigO\n\n"}
{"name":"Asymptotics.IsBigO.listProd","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nR : Type u_13\n𝕜 : Type u_15\ninst✝¹ : SeminormedRing R\ninst✝ : NormedDivisionRing 𝕜\nl : Filter α\nι : Type u_17\nL : List ι\nf : ι → α → R\ng : ι → α → 𝕜\nhf : ∀ (i : ι), Membership.mem L i → Asymptotics.IsBigO l (f i) (g i)\n⊢ Asymptotics.IsBigO l (fun x => (List.map (fun x_1 => f x_1 x) L).prod) fun x => (List.map (fun x_1 => g x_1 x) L).prod","decl":"theorem IsBigO.listProd {L : List ι} {f : ι → α → R} {g : ι → α → 𝕜}\n    (hf : ∀ i ∈ L, f i =O[l] g i) :\n    (fun x ↦ (L.map (f · x)).prod) =O[l] (fun x ↦ (L.map (g · x)).prod) := by\n  induction L with\n  | nil => simp [isBoundedUnder_const]\n  | cons i L ihL =>\n    simp only [List.map_cons, List.prod_cons, List.forall_mem_cons] at hf ⊢\n    exact hf.1.mul (ihL hf.2)\n\n"}
{"name":"Asymptotics.IsBigO.multisetProd","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nl : Filter α\nι : Type u_17\nR : Type u_18\n𝕜 : Type u_19\ninst✝¹ : SeminormedCommRing R\ninst✝ : NormedField 𝕜\ns : Multiset ι\nf : ι → α → R\ng : ι → α → 𝕜\nhf : ∀ (i : ι), Membership.mem s i → Asymptotics.IsBigO l (f i) (g i)\n⊢ Asymptotics.IsBigO l (fun x => (Multiset.map (fun x_1 => f x_1 x) s).prod) fun x => (Multiset.map (fun x_1 => g x_1 x) s).prod","decl":"theorem IsBigO.multisetProd {R 𝕜 : Type*} [SeminormedCommRing R] [NormedField 𝕜]\n    {s : Multiset ι} {f : ι → α → R} {g : ι → α → 𝕜} (hf : ∀ i ∈ s, f i =O[l] g i) :\n    (fun x ↦ (s.map (f · x)).prod) =O[l] (fun x ↦ (s.map (g · x)).prod) := by\n  obtain ⟨l, rfl⟩ : ∃ l : List ι, ↑l = s := Quotient.mk_surjective s\n  exact mod_cast IsBigO.listProd hf\n\n"}
{"name":"Asymptotics.IsBigO.finsetProd","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nl : Filter α\nι : Type u_17\nR : Type u_18\n𝕜 : Type u_19\ninst✝¹ : SeminormedCommRing R\ninst✝ : NormedField 𝕜\ns : Finset ι\nf : ι → α → R\ng : ι → α → 𝕜\nhf : ∀ (i : ι), Membership.mem s i → Asymptotics.IsBigO l (f i) (g i)\n⊢ Asymptotics.IsBigO l (fun x => s.prod fun i => f i x) fun x => s.prod fun i => g i x","decl":"theorem IsBigO.finsetProd {R 𝕜 : Type*} [SeminormedCommRing R] [NormedField 𝕜]\n    {s : Finset ι} {f : ι → α → R} {g : ι → α → 𝕜}\n    (hf : ∀ i ∈ s, f i =O[l] g i) : (∏ i ∈ s, f i ·) =O[l] (∏ i ∈ s, g i ·) :=\n  .multisetProd hf\n\n"}
{"name":"Asymptotics.IsLittleO.listProd","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nR : Type u_13\n𝕜 : Type u_15\ninst✝¹ : SeminormedRing R\ninst✝ : NormedDivisionRing 𝕜\nl : Filter α\nι : Type u_17\nL : List ι\nf : ι → α → R\ng : ι → α → 𝕜\nh₁ : ∀ (i : ι), Membership.mem L i → Asymptotics.IsBigO l (f i) (g i)\nh₂ : Exists fun i => And (Membership.mem L i) (Asymptotics.IsLittleO l (f i) (g i))\n⊢ Asymptotics.IsLittleO l (fun x => (List.map (fun x_1 => f x_1 x) L).prod) fun x => (List.map (fun x_1 => g x_1 x) L).prod","decl":"theorem IsLittleO.listProd {L : List ι} {f : ι → α → R} {g : ι → α → 𝕜}\n    (h₁ : ∀ i ∈ L, f i =O[l] g i) (h₂ : ∃ i ∈ L, f i =o[l] g i) :\n    (fun x ↦ (L.map (f · x)).prod) =o[l] (fun x ↦ (L.map (g · x)).prod) := by\n  induction L with\n  | nil => simp at h₂\n  | cons i L ihL =>\n    simp only [List.map_cons, List.prod_cons, List.forall_mem_cons, List.exists_mem_cons_iff]\n      at h₁ h₂ ⊢\n    cases h₂ with\n    | inl hi => exact hi.mul_isBigO <| .listProd h₁.2\n    | inr hL => exact h₁.1.mul_isLittleO <| ihL h₁.2 hL\n\n"}
{"name":"Asymptotics.IsLittleO.multisetProd","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nl : Filter α\nι : Type u_17\nR : Type u_18\n𝕜 : Type u_19\ninst✝¹ : SeminormedCommRing R\ninst✝ : NormedField 𝕜\ns : Multiset ι\nf : ι → α → R\ng : ι → α → 𝕜\nh₁ : ∀ (i : ι), Membership.mem s i → Asymptotics.IsBigO l (f i) (g i)\nh₂ : Exists fun i => And (Membership.mem s i) (Asymptotics.IsLittleO l (f i) (g i))\n⊢ Asymptotics.IsLittleO l (fun x => (Multiset.map (fun x_1 => f x_1 x) s).prod) fun x => (Multiset.map (fun x_1 => g x_1 x) s).prod","decl":"theorem IsLittleO.multisetProd {R 𝕜 : Type*} [SeminormedCommRing R] [NormedField 𝕜]\n    {s : Multiset ι} {f : ι → α → R} {g : ι → α → 𝕜} (h₁ : ∀ i ∈ s, f i =O[l] g i)\n    (h₂ : ∃ i ∈ s, f i =o[l] g i) :\n    (fun x ↦ (s.map (f · x)).prod) =o[l] (fun x ↦ (s.map (g · x)).prod) := by\n  obtain ⟨l, rfl⟩ : ∃ l : List ι, ↑l = s := Quotient.mk_surjective s\n  exact mod_cast IsLittleO.listProd h₁ h₂\n\n"}
{"name":"Asymptotics.IsLittleO.finsetProd","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nl : Filter α\nι : Type u_17\nR : Type u_18\n𝕜 : Type u_19\ninst✝¹ : SeminormedCommRing R\ninst✝ : NormedField 𝕜\ns : Finset ι\nf : ι → α → R\ng : ι → α → 𝕜\nh₁ : ∀ (i : ι), Membership.mem s i → Asymptotics.IsBigO l (f i) (g i)\nh₂ : Exists fun i => And (Membership.mem s i) (Asymptotics.IsLittleO l (f i) (g i))\n⊢ Asymptotics.IsLittleO l (fun x => s.prod fun i => f i x) fun x => s.prod fun i => g i x","decl":"theorem IsLittleO.finsetProd {R 𝕜 : Type*} [SeminormedCommRing R] [NormedField 𝕜]\n    {s : Finset ι} {f : ι → α → R} {g : ι → α → 𝕜} (h₁ : ∀ i ∈ s, f i =O[l] g i)\n    (h₂ : ∃ i ∈ s, f i =o[l] g i) : (∏ i ∈ s, f i ·) =o[l] (∏ i ∈ s, g i ·) :=\n  .multisetProd h₁ h₂\n\n"}
{"name":"Asymptotics.IsLittleO.tendsto_div_nhds_zero","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\n𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nl : Filter α\nf g : α → 𝕜\nh : Asymptotics.IsLittleO l f g\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds 0)","decl":"theorem IsLittleO.tendsto_div_nhds_zero {f g : α → 𝕜} (h : f =o[l] g) :\n    Tendsto (fun x => f x / g x) l (𝓝 0) :=\n  (isLittleO_one_iff 𝕜).mp <| by\n    calc\n      (fun x => f x / g x) =o[l] fun x => g x / g x := by\n        simpa only [div_eq_mul_inv] using h.mul_isBigO (isBigO_refl _ _)\n      _ =O[l] fun _x => (1 : 𝕜) := isBigO_of_le _ fun x => by simp [div_self_le_one]\n\n"}
{"name":"Asymptotics.IsLittleO.tendsto_inv_smul_nhds_zero","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\n𝕜 : Type u_15\ninst✝³ : SeminormedAddCommGroup E'\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : Module 𝕜 E'\ninst✝ : BoundedSMul 𝕜 E'\nf : α → E'\ng : α → 𝕜\nl : Filter α\nh : Asymptotics.IsLittleO l f g\n⊢ Filter.Tendsto (fun x => HSMul.hSMul (Inv.inv (g x)) (f x)) l (nhds 0)","decl":"theorem IsLittleO.tendsto_inv_smul_nhds_zero [Module 𝕜 E'] [BoundedSMul 𝕜 E']\n    {f : α → E'} {g : α → 𝕜}\n    {l : Filter α} (h : f =o[l] g) : Tendsto (fun x => (g x)⁻¹ • f x) l (𝓝 0) := by\n  simpa only [div_eq_inv_mul, ← norm_inv, ← norm_smul, ← tendsto_zero_iff_norm_tendsto_zero] using\n    h.norm_norm.tendsto_div_nhds_zero\n\n"}
{"name":"Asymptotics.isLittleO_iff_tendsto'","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\n𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nl : Filter α\nf g : α → 𝕜\nhgf : Filter.Eventually (fun x => Eq (g x) 0 → Eq (f x) 0) l\n⊢ Iff (Asymptotics.IsLittleO l f g) (Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds 0))","decl":"theorem isLittleO_iff_tendsto' {f g : α → 𝕜} (hgf : ∀ᶠ x in l, g x = 0 → f x = 0) :\n    f =o[l] g ↔ Tendsto (fun x => f x / g x) l (𝓝 0) :=\n  ⟨IsLittleO.tendsto_div_nhds_zero, fun h =>\n    (((isLittleO_one_iff _).mpr h).mul_isBigO (isBigO_refl g l)).congr'\n      (hgf.mono fun _x => div_mul_cancel_of_imp) (Eventually.of_forall fun _x => one_mul _)⟩\n\n"}
{"name":"Asymptotics.isLittleO_iff_tendsto","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\n𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nl : Filter α\nf g : α → 𝕜\nhgf : ∀ (x : α), Eq (g x) 0 → Eq (f x) 0\n⊢ Iff (Asymptotics.IsLittleO l f g) (Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds 0))","decl":"theorem isLittleO_iff_tendsto {f g : α → 𝕜} (hgf : ∀ x, g x = 0 → f x = 0) :\n    f =o[l] g ↔ Tendsto (fun x => f x / g x) l (𝓝 0) :=\n  isLittleO_iff_tendsto' (Eventually.of_forall hgf)\n\n"}
{"name":"Asymptotics.isLittleO_of_tendsto'","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\n𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nl : Filter α\nf g : α → 𝕜\nhgf : Filter.Eventually (fun x => Eq (g x) 0 → Eq (f x) 0) l\na✝ : Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds 0)\n⊢ Asymptotics.IsLittleO l f g","decl":"alias ⟨_, isLittleO_of_tendsto'⟩ := isLittleO_iff_tendsto'\n\n"}
{"name":"Asymptotics.isLittleO_of_tendsto","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\n𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nl : Filter α\nf g : α → 𝕜\nhgf : ∀ (x : α), Eq (g x) 0 → Eq (f x) 0\na✝ : Filter.Tendsto (fun x => HDiv.hDiv (f x) (g x)) l (nhds 0)\n⊢ Asymptotics.IsLittleO l f g","decl":"alias ⟨_, isLittleO_of_tendsto⟩ := isLittleO_iff_tendsto\n\n"}
{"name":"Asymptotics.isLittleO_const_left_of_ne","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nF : Type u_4\nE'' : Type u_9\ninst✝¹ : Norm F\ninst✝ : NormedAddCommGroup E''\ng : α → F\nl : Filter α\nc : E''\nhc : Ne c 0\n⊢ Iff (Asymptotics.IsLittleO l (fun _x => c) g) (Filter.Tendsto (fun x => Norm.norm (g x)) l Filter.atTop)","decl":"theorem isLittleO_const_left_of_ne {c : E''} (hc : c ≠ 0) :\n    (fun _x => c) =o[l] g ↔ Tendsto (fun x => ‖g x‖) l atTop := by\n  simp only [← isLittleO_one_left_iff ℝ]\n  exact ⟨(isBigO_const_const (1 : ℝ) hc l).trans_isLittleO,\n    (isBigO_const_one ℝ c l).trans_isLittleO⟩\n\n"}
{"name":"Asymptotics.isLittleO_const_left","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE'' : Type u_9\nF'' : Type u_10\ninst✝¹ : NormedAddCommGroup E''\ninst✝ : NormedAddCommGroup F''\ng'' : α → F''\nl : Filter α\nc : E''\n⊢ Iff (Asymptotics.IsLittleO l (fun _x => c) g'') (Or (Eq c 0) (Filter.Tendsto (Function.comp Norm.norm g'') l Filter.atTop))","decl":"@[simp]\ntheorem isLittleO_const_left {c : E''} :\n    (fun _x => c) =o[l] g'' ↔ c = 0 ∨ Tendsto (norm ∘ g'') l atTop := by\n  rcases eq_or_ne c 0 with (rfl | hc)\n  · simp only [isLittleO_zero, eq_self_iff_true, true_or]\n  · simp only [hc, false_or, isLittleO_const_left_of_ne hc]; rfl\n\n"}
{"name":"Asymptotics.isLittleO_const_const_iff","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE'' : Type u_9\nF'' : Type u_10\ninst✝² : NormedAddCommGroup E''\ninst✝¹ : NormedAddCommGroup F''\nl : Filter α\ninst✝ : l.NeBot\nd : E''\nc : F''\n⊢ Iff (Asymptotics.IsLittleO l (fun _x => d) fun _x => c) (Eq d 0)","decl":"@[simp 1001] -- Porting note: increase priority so that this triggers before `isLittleO_const_left`\ntheorem isLittleO_const_const_iff [NeBot l] {d : E''} {c : F''} :\n    ((fun _x => d) =o[l] fun _x => c) ↔ d = 0 := by\n  have : ¬Tendsto (Function.const α ‖c‖) l atTop :=\n    not_tendsto_atTop_of_tendsto_nhds tendsto_const_nhds\n  simp only [isLittleO_const_left, or_iff_left_iff_imp]\n  exact fun h => (this h).elim\n\n"}
{"name":"Asymptotics.isLittleO_pure","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE'' : Type u_9\nF'' : Type u_10\ninst✝¹ : NormedAddCommGroup E''\ninst✝ : NormedAddCommGroup F''\nf'' : α → E''\ng'' : α → F''\nx : α\n⊢ Iff (Asymptotics.IsLittleO (Pure.pure x) f'' g'') (Eq (f'' x) 0)","decl":"@[simp]\ntheorem isLittleO_pure {x} : f'' =o[pure x] g'' ↔ f'' x = 0 :=\n  calc\n    f'' =o[pure x] g'' ↔ (fun _y : α => f'' x) =o[pure x] fun _ => g'' x := isLittleO_congr rfl rfl\n    _ ↔ f'' x = 0 := isLittleO_const_const_iff\n\n"}
{"name":"Asymptotics.isLittleO_const_id_cobounded","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E'' : Type u_9\nF'' : Type u_10\ninst✝¹ : NormedAddCommGroup E''\ninst✝ : NormedAddCommGroup F''\nc : F''\n⊢ Asymptotics.IsLittleO (Bornology.cobounded E'') (fun x => c) id","decl":"theorem isLittleO_const_id_cobounded (c : F'') :\n    (fun _ => c) =o[Bornology.cobounded E''] id :=\n  isLittleO_const_left.2 <| .inr tendsto_norm_cobounded_atTop\n\n"}
{"name":"Asymptotics.isLittleO_const_id_atTop","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E'' : Type u_9\ninst✝ : NormedAddCommGroup E''\nc : E''\n⊢ Asymptotics.IsLittleO Filter.atTop (fun _x => c) id","decl":"theorem isLittleO_const_id_atTop (c : E'') : (fun _x : ℝ => c) =o[atTop] id :=\n  isLittleO_const_left.2 <| Or.inr tendsto_abs_atTop_atTop\n\n"}
{"name":"Asymptotics.isLittleO_const_id_atBot","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E'' : Type u_9\ninst✝ : NormedAddCommGroup E''\nc : E''\n⊢ Asymptotics.IsLittleO Filter.atBot (fun _x => c) id","decl":"theorem isLittleO_const_id_atBot (c : E'') : (fun _x : ℝ => c) =o[atBot] id :=\n  isLittleO_const_left.2 <| Or.inr tendsto_abs_atBot_atTop\n\n"}
{"name":"Asymptotics.isBigOWith_of_eq_mul","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nR : Type u_13\ninst✝ : SeminormedRing R\nc : Real\nl : Filter α\nu v φ : α → R\nhφ : Filter.Eventually (fun x => LE.le (Norm.norm (φ x)) c) l\nh : l.EventuallyEq u (HMul.hMul φ v)\n⊢ Asymptotics.IsBigOWith c l u v","decl":"/-- If `‖φ‖` is eventually bounded by `c`, and `u =ᶠ[l] φ * v`, then we have `IsBigOWith c u v l`.\n    This does not require any assumptions on `c`, which is why we keep this version along with\n    `IsBigOWith_iff_exists_eq_mul`. -/\ntheorem isBigOWith_of_eq_mul {u v : α → R} (φ : α → R) (hφ : ∀ᶠ x in l, ‖φ x‖ ≤ c)\n    (h : u =ᶠ[l] φ * v) :\n    IsBigOWith c l u v := by\n  simp only [IsBigOWith_def]\n  refine h.symm.rw (fun x a => ‖a‖ ≤ c * ‖v x‖) (hφ.mono fun x hx => ?_)\n  simp only [Pi.mul_apply]\n  refine (norm_mul_le _ _).trans ?_\n  gcongr\n\n"}
{"name":"Asymptotics.isBigOWith_iff_exists_eq_mul","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\n𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nc : Real\nl : Filter α\nu v : α → 𝕜\nhc : LE.le 0 c\n⊢ Iff (Asymptotics.IsBigOWith c l u v) (Exists fun φ => And (Filter.Eventually (fun x => LE.le (Norm.norm (φ x)) c) l) (l.EventuallyEq u (HMul.hMul φ v)))","decl":"theorem isBigOWith_iff_exists_eq_mul (hc : 0 ≤ c) :\n    IsBigOWith c l u v ↔ ∃ φ : α → 𝕜, (∀ᶠ x in l, ‖φ x‖ ≤ c) ∧ u =ᶠ[l] φ * v := by\n  constructor\n  · intro h\n    use fun x => u x / v x\n    refine ⟨Eventually.mono h.bound fun y hy => ?_, h.eventually_mul_div_cancel.symm⟩\n    simpa using div_le_of_le_mul₀ (norm_nonneg _) hc hy\n  · rintro ⟨φ, hφ, h⟩\n    exact isBigOWith_of_eq_mul φ hφ h\n\n"}
{"name":"Asymptotics.IsBigOWith.exists_eq_mul","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\n𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nc : Real\nl : Filter α\nu v : α → 𝕜\nh : Asymptotics.IsBigOWith c l u v\nhc : LE.le 0 c\n⊢ Exists fun φ => And (Filter.Eventually (fun x => LE.le (Norm.norm (φ x)) c) l) (l.EventuallyEq u (HMul.hMul φ v))","decl":"theorem IsBigOWith.exists_eq_mul (h : IsBigOWith c l u v) (hc : 0 ≤ c) :\n    ∃ φ : α → 𝕜, (∀ᶠ x in l, ‖φ x‖ ≤ c) ∧ u =ᶠ[l] φ * v :=\n  (isBigOWith_iff_exists_eq_mul hc).mp h\n\n"}
{"name":"Asymptotics.isBigO_iff_exists_eq_mul","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\n𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nl : Filter α\nu v : α → 𝕜\n⊢ Iff (Asymptotics.IsBigO l u v) (Exists fun φ => And (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm φ)) (l.EventuallyEq u (HMul.hMul φ v)))","decl":"theorem isBigO_iff_exists_eq_mul :\n    u =O[l] v ↔ ∃ φ : α → 𝕜, l.IsBoundedUnder (· ≤ ·) (norm ∘ φ) ∧ u =ᶠ[l] φ * v := by\n  constructor\n  · rintro h\n    rcases h.exists_nonneg with ⟨c, hnnc, hc⟩\n    rcases hc.exists_eq_mul hnnc with ⟨φ, hφ, huvφ⟩\n    exact ⟨φ, ⟨c, hφ⟩, huvφ⟩\n  · rintro ⟨φ, ⟨c, hφ⟩, huvφ⟩\n    exact isBigO_iff_isBigOWith.2 ⟨c, isBigOWith_of_eq_mul φ hφ huvφ⟩\n\n"}
{"name":"Asymptotics.IsBigO.exists_eq_mul","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\n𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nl : Filter α\nu v : α → 𝕜\na✝ : Asymptotics.IsBigO l u v\n⊢ Exists fun φ => And (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm φ)) (l.EventuallyEq u (HMul.hMul φ v))","decl":"alias ⟨IsBigO.exists_eq_mul, _⟩ := isBigO_iff_exists_eq_mul\n\n"}
{"name":"Asymptotics.isLittleO_iff_exists_eq_mul","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\n𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nl : Filter α\nu v : α → 𝕜\n⊢ Iff (Asymptotics.IsLittleO l u v) (Exists fun φ => And (Filter.Tendsto φ l (nhds 0)) (l.EventuallyEq u (HMul.hMul φ v)))","decl":"theorem isLittleO_iff_exists_eq_mul :\n    u =o[l] v ↔ ∃ φ : α → 𝕜, Tendsto φ l (𝓝 0) ∧ u =ᶠ[l] φ * v := by\n  constructor\n  · exact fun h => ⟨fun x => u x / v x, h.tendsto_div_nhds_zero, h.eventually_mul_div_cancel.symm⟩\n  · simp only [IsLittleO_def]\n    rintro ⟨φ, hφ, huvφ⟩ c hpos\n    rw [NormedAddCommGroup.tendsto_nhds_zero] at hφ\n    exact isBigOWith_of_eq_mul _ ((hφ c hpos).mono fun x => le_of_lt) huvφ\n\n"}
{"name":"Asymptotics.IsLittleO.exists_eq_mul","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\n𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nl : Filter α\nu v : α → 𝕜\na✝ : Asymptotics.IsLittleO l u v\n⊢ Exists fun φ => And (Filter.Tendsto φ l (nhds 0)) (l.EventuallyEq u (HMul.hMul φ v))","decl":"alias ⟨IsLittleO.exists_eq_mul, _⟩ := isLittleO_iff_exists_eq_mul\n\n"}
{"name":"Asymptotics.div_isBoundedUnder_of_isBigO","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nα : Type u_17\nl : Filter α\nf g : α → 𝕜\nh : Asymptotics.IsBigO l f g\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => Norm.norm (HDiv.hDiv (f x) (g x))","decl":"theorem div_isBoundedUnder_of_isBigO {α : Type*} {l : Filter α} {f g : α → 𝕜} (h : f =O[l] g) :\n    IsBoundedUnder (· ≤ ·) l fun x => ‖f x / g x‖ := by\n  obtain ⟨c, h₀, hc⟩ := h.exists_nonneg\n  refine ⟨c, eventually_map.2 (hc.bound.mono fun x hx => ?_)⟩\n  rw [norm_div]\n  exact div_le_of_le_mul₀ (norm_nonneg _) h₀ hx\n\n"}
{"name":"Asymptotics.isBigO_iff_div_isBoundedUnder","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nα : Type u_17\nl : Filter α\nf g : α → 𝕜\nhgf : Filter.Eventually (fun x => Eq (g x) 0 → Eq (f x) 0) l\n⊢ Iff (Asymptotics.IsBigO l f g) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => Norm.norm (HDiv.hDiv (f x) (g x)))","decl":"theorem isBigO_iff_div_isBoundedUnder {α : Type*} {l : Filter α} {f g : α → 𝕜}\n    (hgf : ∀ᶠ x in l, g x = 0 → f x = 0) :\n    f =O[l] g ↔ IsBoundedUnder (· ≤ ·) l fun x => ‖f x / g x‖ := by\n  refine ⟨div_isBoundedUnder_of_isBigO, fun h => ?_⟩\n  obtain ⟨c, hc⟩ := h\n  simp only [eventually_map, norm_div] at hc\n  refine IsBigO.of_bound c (hc.mp <| hgf.mono fun x hx₁ hx₂ => ?_)\n  by_cases hgx : g x = 0\n  · simp [hx₁ hgx, hgx]\n  · exact (div_le_iff₀ (norm_pos_iff.2 hgx)).mp hx₂\n\n"}
{"name":"Asymptotics.isBigO_of_div_tendsto_nhds","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nα : Type u_17\nl : Filter α\nf g : α → 𝕜\nhgf : Filter.Eventually (fun x => Eq (g x) 0 → Eq (f x) 0) l\nc : 𝕜\nH : Filter.Tendsto (HDiv.hDiv f g) l (nhds c)\n⊢ Asymptotics.IsBigO l f g","decl":"theorem isBigO_of_div_tendsto_nhds {α : Type*} {l : Filter α} {f g : α → 𝕜}\n    (hgf : ∀ᶠ x in l, g x = 0 → f x = 0) (c : 𝕜) (H : Filter.Tendsto (f / g) l (𝓝 c)) :\n    f =O[l] g :=\n  (isBigO_iff_div_isBoundedUnder hgf).2 <| H.norm.isBoundedUnder_le\n\n"}
{"name":"Asymptotics.IsLittleO.tendsto_zero_of_tendsto","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_17\nE : Type u_18\n𝕜 : Type u_19\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedField 𝕜\nu : α → E\nv : α → 𝕜\nl : Filter α\ny : 𝕜\nhuv : Asymptotics.IsLittleO l u v\nhv : Filter.Tendsto v l (nhds y)\n⊢ Filter.Tendsto u l (nhds 0)","decl":"theorem IsLittleO.tendsto_zero_of_tendsto {α E 𝕜 : Type*} [NormedAddCommGroup E] [NormedField 𝕜]\n    {u : α → E} {v : α → 𝕜} {l : Filter α} {y : 𝕜} (huv : u =o[l] v) (hv : Tendsto v l (𝓝 y)) :\n    Tendsto u l (𝓝 0) := by\n  suffices h : u =o[l] fun _x => (1 : 𝕜) by\n    rwa [isLittleO_one_iff] at h\n  exact huv.trans_isBigO (hv.isBigO_one 𝕜)\n\n"}
{"name":"Asymptotics.isLittleO_pow_pow","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nm n : Nat\nh : LT.lt m n\n⊢ Asymptotics.IsLittleO (nhds 0) (fun x => HPow.hPow x n) fun x => HPow.hPow x m","decl":"theorem isLittleO_pow_pow {m n : ℕ} (h : m < n) : (fun x : 𝕜 => x ^ n) =o[𝓝 0] fun x => x ^ m := by\n  rcases lt_iff_exists_add.1 h with ⟨p, hp0 : 0 < p, rfl⟩\n  suffices (fun x : 𝕜 => x ^ m * x ^ p) =o[𝓝 0] fun x => x ^ m * 1 ^ p by\n    simpa only [pow_add, one_pow, mul_one]\n  exact IsBigO.mul_isLittleO (isBigO_refl _ _)\n    (IsLittleO.pow ((isLittleO_one_iff _).2 tendsto_id) hp0)\n\n"}
{"name":"Asymptotics.isLittleO_norm_pow_norm_pow","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E' : Type u_6\ninst✝ : SeminormedAddCommGroup E'\nm n : Nat\nh : LT.lt m n\n⊢ Asymptotics.IsLittleO (nhds 0) (fun x => HPow.hPow (Norm.norm x) n) fun x => HPow.hPow (Norm.norm x) m","decl":"theorem isLittleO_norm_pow_norm_pow {m n : ℕ} (h : m < n) :\n    (fun x : E' => ‖x‖ ^ n) =o[𝓝 0] fun x => ‖x‖ ^ m :=\n  (isLittleO_pow_pow h).comp_tendsto tendsto_norm_zero\n\n"}
{"name":"Asymptotics.isLittleO_pow_id","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nn : Nat\nh : LT.lt 1 n\n⊢ Asymptotics.IsLittleO (nhds 0) (fun x => HPow.hPow x n) fun x => x","decl":"theorem isLittleO_pow_id {n : ℕ} (h : 1 < n) : (fun x : 𝕜 => x ^ n) =o[𝓝 0] fun x => x := by\n  convert isLittleO_pow_pow h (𝕜 := 𝕜)\n  simp only [pow_one]\n\n"}
{"name":"Asymptotics.isLittleO_norm_pow_id","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E' : Type u_6\ninst✝ : SeminormedAddCommGroup E'\nn : Nat\nh : LT.lt 1 n\n⊢ Asymptotics.IsLittleO (nhds 0) (fun x => HPow.hPow (Norm.norm x) n) fun x => x","decl":"theorem isLittleO_norm_pow_id {n : ℕ} (h : 1 < n) :\n    (fun x : E' => ‖x‖ ^ n) =o[𝓝 0] fun x => x := by\n  have := @isLittleO_norm_pow_norm_pow E' _ _ _ h\n  simp only [pow_one] at this\n  exact isLittleO_norm_right.mp this\n\n"}
{"name":"Asymptotics.IsBigO.eq_zero_of_norm_pow_within","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E'' : Type u_9\nF'' : Type u_10\ninst✝¹ : NormedAddCommGroup E''\ninst✝ : NormedAddCommGroup F''\nf : E'' → F''\ns : Set E''\nx₀ : E''\nn : Nat\nh : Asymptotics.IsBigO (nhdsWithin x₀ s) f fun x => HPow.hPow (Norm.norm (HSub.hSub x x₀)) n\nhx₀ : Membership.mem s x₀\nhn : Ne n 0\n⊢ Eq (f x₀) 0","decl":"theorem IsBigO.eq_zero_of_norm_pow_within {f : E'' → F''} {s : Set E''} {x₀ : E''} {n : ℕ}\n    (h : f =O[𝓝[s] x₀] fun x => ‖x - x₀‖ ^ n) (hx₀ : x₀ ∈ s) (hn : n ≠ 0) : f x₀ = 0 :=\n  mem_of_mem_nhdsWithin hx₀ h.eq_zero_imp <| by simp_rw [sub_self, norm_zero, zero_pow hn]\n\n"}
{"name":"Asymptotics.IsBigO.eq_zero_of_norm_pow","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E'' : Type u_9\nF'' : Type u_10\ninst✝¹ : NormedAddCommGroup E''\ninst✝ : NormedAddCommGroup F''\nf : E'' → F''\nx₀ : E''\nn : Nat\nh : Asymptotics.IsBigO (nhds x₀) f fun x => HPow.hPow (Norm.norm (HSub.hSub x x₀)) n\nhn : Ne n 0\n⊢ Eq (f x₀) 0","decl":"theorem IsBigO.eq_zero_of_norm_pow {f : E'' → F''} {x₀ : E''} {n : ℕ}\n    (h : f =O[𝓝 x₀] fun x => ‖x - x₀‖ ^ n) (hn : n ≠ 0) : f x₀ = 0 := by\n  rw [← nhdsWithin_univ] at h\n  exact h.eq_zero_of_norm_pow_within (mem_univ _) hn\n\n"}
{"name":"Asymptotics.isLittleO_pow_sub_pow_sub","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E' : Type u_6\ninst✝ : SeminormedAddCommGroup E'\nx₀ : E'\nn m : Nat\nh : LT.lt n m\n⊢ Asymptotics.IsLittleO (nhds x₀) (fun x => HPow.hPow (Norm.norm (HSub.hSub x x₀)) m) fun x => HPow.hPow (Norm.norm (HSub.hSub x x₀)) n","decl":"theorem isLittleO_pow_sub_pow_sub (x₀ : E') {n m : ℕ} (h : n < m) :\n    (fun x => ‖x - x₀‖ ^ m) =o[𝓝 x₀] fun x => ‖x - x₀‖ ^ n :=\n  haveI : Tendsto (fun x => ‖x - x₀‖) (𝓝 x₀) (𝓝 0) := by\n    apply tendsto_norm_zero.comp\n    rw [← sub_self x₀]\n    exact tendsto_id.sub tendsto_const_nhds\n  (isLittleO_pow_pow h).comp_tendsto this\n\n"}
{"name":"Asymptotics.isLittleO_pow_sub_sub","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E' : Type u_6\ninst✝ : SeminormedAddCommGroup E'\nx₀ : E'\nm : Nat\nh : LT.lt 1 m\n⊢ Asymptotics.IsLittleO (nhds x₀) (fun x => HPow.hPow (Norm.norm (HSub.hSub x x₀)) m) fun x => HSub.hSub x x₀","decl":"theorem isLittleO_pow_sub_sub (x₀ : E') {m : ℕ} (h : 1 < m) :\n    (fun x => ‖x - x₀‖ ^ m) =o[𝓝 x₀] fun x => x - x₀ := by\n  simpa only [isLittleO_norm_right, pow_one] using isLittleO_pow_sub_pow_sub x₀ h\n\n"}
{"name":"Asymptotics.IsBigOWith.right_le_sub_of_lt_one","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\ninst✝ : SeminormedAddCommGroup E'\nc : Real\nl : Filter α\nf₁ f₂ : α → E'\nh : Asymptotics.IsBigOWith c l f₁ f₂\nhc : LT.lt c 1\n⊢ Asymptotics.IsBigOWith (HDiv.hDiv 1 (HSub.hSub 1 c)) l f₂ fun x => HSub.hSub (f₂ x) (f₁ x)","decl":"theorem IsBigOWith.right_le_sub_of_lt_one {f₁ f₂ : α → E'} (h : IsBigOWith c l f₁ f₂) (hc : c < 1) :\n    IsBigOWith (1 / (1 - c)) l f₂ fun x => f₂ x - f₁ x :=\n  IsBigOWith.of_bound <|\n    mem_of_superset h.bound fun x hx => by\n      simp only [mem_setOf_eq] at hx ⊢\n      rw [mul_comm, one_div, ← div_eq_mul_inv, le_div_iff₀, mul_sub, mul_one, mul_comm]\n      · exact le_trans (sub_le_sub_left hx _) (norm_sub_norm_le _ _)\n      · exact sub_pos.2 hc\n\n"}
{"name":"Asymptotics.IsBigOWith.right_le_add_of_lt_one","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\ninst✝ : SeminormedAddCommGroup E'\nc : Real\nl : Filter α\nf₁ f₂ : α → E'\nh : Asymptotics.IsBigOWith c l f₁ f₂\nhc : LT.lt c 1\n⊢ Asymptotics.IsBigOWith (HDiv.hDiv 1 (HSub.hSub 1 c)) l f₂ fun x => HAdd.hAdd (f₁ x) (f₂ x)","decl":"theorem IsBigOWith.right_le_add_of_lt_one {f₁ f₂ : α → E'} (h : IsBigOWith c l f₁ f₂) (hc : c < 1) :\n    IsBigOWith (1 / (1 - c)) l f₂ fun x => f₁ x + f₂ x :=\n  (h.neg_right.right_le_sub_of_lt_one hc).neg_right.of_neg_left.congr rfl (fun _ ↦ rfl) fun x ↦ by\n    rw [neg_sub, sub_neg_eq_add]\n\n"}
{"name":"Asymptotics.IsLittleO.right_isBigO_sub","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\ninst✝ : SeminormedAddCommGroup E'\nl : Filter α\nf₁ f₂ : α → E'\nh : Asymptotics.IsLittleO l f₁ f₂\n⊢ Asymptotics.IsBigO l f₂ fun x => HSub.hSub (f₂ x) (f₁ x)","decl":"theorem IsLittleO.right_isBigO_sub {f₁ f₂ : α → E'} (h : f₁ =o[l] f₂) :\n    f₂ =O[l] fun x => f₂ x - f₁ x :=\n  ((h.def' one_half_pos).right_le_sub_of_lt_one one_half_lt_one).isBigO\n\n"}
{"name":"Asymptotics.IsLittleO.right_isBigO_add","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\ninst✝ : SeminormedAddCommGroup E'\nl : Filter α\nf₁ f₂ : α → E'\nh : Asymptotics.IsLittleO l f₁ f₂\n⊢ Asymptotics.IsBigO l f₂ fun x => HAdd.hAdd (f₁ x) (f₂ x)","decl":"theorem IsLittleO.right_isBigO_add {f₁ f₂ : α → E'} (h : f₁ =o[l] f₂) :\n    f₂ =O[l] fun x => f₁ x + f₂ x :=\n  ((h.def' one_half_pos).right_le_add_of_lt_one one_half_lt_one).isBigO\n\n"}
{"name":"Asymptotics.IsLittleO.right_isBigO_add'","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE' : Type u_6\ninst✝ : SeminormedAddCommGroup E'\nl : Filter α\nf₁ f₂ : α → E'\nh : Asymptotics.IsLittleO l f₁ f₂\n⊢ Asymptotics.IsBigO l f₂ (HAdd.hAdd f₂ f₁)","decl":"theorem IsLittleO.right_isBigO_add' {f₁ f₂ : α → E'} (h : f₁ =o[l] f₂) :\n    f₂ =O[l] (f₂ + f₁) :=\n  add_comm f₁ f₂ ▸ h.right_isBigO_add\n\n"}
{"name":"Asymptotics.bound_of_isBigO_cofinite","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_3\nF'' : Type u_10\ninst✝¹ : Norm E\ninst✝ : NormedAddCommGroup F''\nf : α → E\ng'' : α → F''\nh : Asymptotics.IsBigO Filter.cofinite f g''\n⊢ Exists fun C => And (GT.gt C 0) (∀ ⦃x : α⦄, Ne (g'' x) 0 → LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm (g'' x))))","decl":"/-- If `f x = O(g x)` along `cofinite`, then there exists a positive constant `C` such that\n`‖f x‖ ≤ C * ‖g x‖` whenever `g x ≠ 0`. -/\ntheorem bound_of_isBigO_cofinite (h : f =O[cofinite] g'') :\n    ∃ C > 0, ∀ ⦃x⦄, g'' x ≠ 0 → ‖f x‖ ≤ C * ‖g'' x‖ := by\n  rcases h.exists_pos with ⟨C, C₀, hC⟩\n  rw [IsBigOWith_def, eventually_cofinite] at hC\n  rcases (hC.toFinset.image fun x => ‖f x‖ / ‖g'' x‖).exists_le with ⟨C', hC'⟩\n  have : ∀ x, C * ‖g'' x‖ < ‖f x‖ → ‖f x‖ / ‖g'' x‖ ≤ C' := by simpa using hC'\n  refine ⟨max C C', lt_max_iff.2 (Or.inl C₀), fun x h₀ => ?_⟩\n  rw [max_mul_of_nonneg _ _ (norm_nonneg _), le_max_iff, or_iff_not_imp_left, not_le]\n  exact fun hx => (div_le_iff₀ (norm_pos_iff.2 h₀)).1 (this _ hx)\n\n"}
{"name":"Asymptotics.isBigO_cofinite_iff","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE'' : Type u_9\nF'' : Type u_10\ninst✝¹ : NormedAddCommGroup E''\ninst✝ : NormedAddCommGroup F''\nf'' : α → E''\ng'' : α → F''\nh : ∀ (x : α), Eq (g'' x) 0 → Eq (f'' x) 0\n⊢ Iff (Asymptotics.IsBigO Filter.cofinite f'' g'') (Exists fun C => ∀ (x : α), LE.le (Norm.norm (f'' x)) (HMul.hMul C (Norm.norm (g'' x))))","decl":"theorem isBigO_cofinite_iff (h : ∀ x, g'' x = 0 → f'' x = 0) :\n    f'' =O[cofinite] g'' ↔ ∃ C, ∀ x, ‖f'' x‖ ≤ C * ‖g'' x‖ := by\n  classical\n  exact ⟨fun h' =>\n    let ⟨C, _C₀, hC⟩ := bound_of_isBigO_cofinite h'\n    ⟨C, fun x => if hx : g'' x = 0 then by simp [h _ hx, hx] else hC hx⟩,\n    fun h => (isBigO_top.2 h).mono le_top⟩\n\n"}
{"name":"Asymptotics.bound_of_isBigO_nat_atTop","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E : Type u_3\nE'' : Type u_9\ninst✝¹ : Norm E\ninst✝ : NormedAddCommGroup E''\nf : Nat → E\ng'' : Nat → E''\nh : Asymptotics.IsBigO Filter.atTop f g''\n⊢ Exists fun C => And (GT.gt C 0) (∀ ⦃x : Nat⦄, Ne (g'' x) 0 → LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm (g'' x))))","decl":"theorem bound_of_isBigO_nat_atTop {f : ℕ → E} {g'' : ℕ → E''} (h : f =O[atTop] g'') :\n    ∃ C > 0, ∀ ⦃x⦄, g'' x ≠ 0 → ‖f x‖ ≤ C * ‖g'' x‖ :=\n  bound_of_isBigO_cofinite <| by rwa [Nat.cofinite_eq_atTop]\n\n"}
{"name":"Asymptotics.isBigO_nat_atTop_iff","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E'' : Type u_9\nF'' : Type u_10\ninst✝¹ : NormedAddCommGroup E''\ninst✝ : NormedAddCommGroup F''\nf : Nat → E''\ng : Nat → F''\nh : ∀ (x : Nat), Eq (g x) 0 → Eq (f x) 0\n⊢ Iff (Asymptotics.IsBigO Filter.atTop f g) (Exists fun C => ∀ (x : Nat), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm (g x))))","decl":"theorem isBigO_nat_atTop_iff {f : ℕ → E''} {g : ℕ → F''} (h : ∀ x, g x = 0 → f x = 0) :\n    f =O[atTop] g ↔ ∃ C, ∀ x, ‖f x‖ ≤ C * ‖g x‖ := by\n  rw [← Nat.cofinite_eq_atTop, isBigO_cofinite_iff h]\n\n"}
{"name":"Asymptotics.isBigO_one_nat_atTop_iff","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E'' : Type u_9\ninst✝ : NormedAddCommGroup E''\nf : Nat → E''\n⊢ Iff (Asymptotics.IsBigO Filter.atTop f fun _n => 1) (Exists fun C => ∀ (n : Nat), LE.le (Norm.norm (f n)) C)","decl":"theorem isBigO_one_nat_atTop_iff {f : ℕ → E''} :\n    f =O[atTop] (fun _n => 1 : ℕ → ℝ) ↔ ∃ C, ∀ n, ‖f n‖ ≤ C :=\n  Iff.trans (isBigO_nat_atTop_iff fun _ h => (one_ne_zero h).elim) <| by\n    simp only [norm_one, mul_one]\n\n"}
{"name":"Asymptotics.isBigOWith_pi","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nF' : Type u_7\ninst✝² : SeminormedAddCommGroup F'\ng' : α → F'\nl : Filter α\nι : Type u_17\ninst✝¹ : Fintype ι\nE' : ι → Type u_18\ninst✝ : (i : ι) → NormedAddCommGroup (E' i)\nf : α → (i : ι) → E' i\nC : Real\nhC : LE.le 0 C\n⊢ Iff (Asymptotics.IsBigOWith C l f g') (∀ (i : ι), Asymptotics.IsBigOWith C l (fun x => f x i) g')","decl":"theorem isBigOWith_pi {ι : Type*} [Fintype ι] {E' : ι → Type*} [∀ i, NormedAddCommGroup (E' i)]\n    {f : α → ∀ i, E' i} {C : ℝ} (hC : 0 ≤ C) :\n    IsBigOWith C l f g' ↔ ∀ i, IsBigOWith C l (fun x => f x i) g' := by\n  have : ∀ x, 0 ≤ C * ‖g' x‖ := fun x => mul_nonneg hC (norm_nonneg _)\n  simp only [isBigOWith_iff, pi_norm_le_iff_of_nonneg (this _), eventually_all]\n\n"}
{"name":"Asymptotics.isBigO_pi","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nF' : Type u_7\ninst✝² : SeminormedAddCommGroup F'\ng' : α → F'\nl : Filter α\nι : Type u_17\ninst✝¹ : Fintype ι\nE' : ι → Type u_18\ninst✝ : (i : ι) → NormedAddCommGroup (E' i)\nf : α → (i : ι) → E' i\n⊢ Iff (Asymptotics.IsBigO l f g') (∀ (i : ι), Asymptotics.IsBigO l (fun x => f x i) g')","decl":"@[simp]\ntheorem isBigO_pi {ι : Type*} [Fintype ι] {E' : ι → Type*} [∀ i, NormedAddCommGroup (E' i)]\n    {f : α → ∀ i, E' i} : f =O[l] g' ↔ ∀ i, (fun x => f x i) =O[l] g' := by\n  simp only [isBigO_iff_eventually_isBigOWith, ← eventually_all]\n  exact eventually_congr (eventually_atTop.2 ⟨0, fun c => isBigOWith_pi⟩)\n\n"}
{"name":"Asymptotics.isLittleO_pi","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nF' : Type u_7\ninst✝² : SeminormedAddCommGroup F'\ng' : α → F'\nl : Filter α\nι : Type u_17\ninst✝¹ : Fintype ι\nE' : ι → Type u_18\ninst✝ : (i : ι) → NormedAddCommGroup (E' i)\nf : α → (i : ι) → E' i\n⊢ Iff (Asymptotics.IsLittleO l f g') (∀ (i : ι), Asymptotics.IsLittleO l (fun x => f x i) g')","decl":"@[simp]\ntheorem isLittleO_pi {ι : Type*} [Fintype ι] {E' : ι → Type*} [∀ i, NormedAddCommGroup (E' i)]\n    {f : α → ∀ i, E' i} : f =o[l] g' ↔ ∀ i, (fun x => f x i) =o[l] g' := by\n  simp +contextual only [IsLittleO_def, isBigOWith_pi, le_of_lt]\n  exact ⟨fun h i c hc => h hc i, fun h c hc i => h i hc⟩\n\n"}
{"name":"Asymptotics.IsBigO.natCast_atTop","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝³ : Norm E\ninst✝² : Norm F\nR : Type u_17\ninst✝¹ : StrictOrderedSemiring R\ninst✝ : Archimedean R\nf : R → E\ng : R → F\nh : Asymptotics.IsBigO Filter.atTop f g\n⊢ Asymptotics.IsBigO Filter.atTop (fun n => f ↑n) fun n => g ↑n","decl":"theorem IsBigO.natCast_atTop {R : Type*} [StrictOrderedSemiring R] [Archimedean R]\n    {f : R → E} {g : R → F} (h : f =O[atTop] g) :\n    (fun (n : ℕ) => f n) =O[atTop] (fun n => g n) :=\n  IsBigO.comp_tendsto h tendsto_natCast_atTop_atTop\n\n"}
{"name":"Asymptotics.IsLittleO.natCast_atTop","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝³ : Norm E\ninst✝² : Norm F\nR : Type u_17\ninst✝¹ : StrictOrderedSemiring R\ninst✝ : Archimedean R\nf : R → E\ng : R → F\nh : Asymptotics.IsLittleO Filter.atTop f g\n⊢ Asymptotics.IsLittleO Filter.atTop (fun n => f ↑n) fun n => g ↑n","decl":"theorem IsLittleO.natCast_atTop {R : Type*} [StrictOrderedSemiring R] [Archimedean R]\n    {f : R → E} {g : R → F} (h : f =o[atTop] g) :\n    (fun (n : ℕ) => f n) =o[atTop] (fun n => g n) :=\n  IsLittleO.comp_tendsto h tendsto_natCast_atTop_atTop\n\n"}
{"name":"Asymptotics.isBigO_atTop_iff_eventually_exists","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝³ : Norm E\ninst✝² : Norm F\nα : Type u_17\ninst✝¹ : SemilatticeSup α\ninst✝ : Nonempty α\nf : α → E\ng : α → F\n⊢ Iff (Asymptotics.IsBigO Filter.atTop f g) (Filter.Eventually (fun n₀ => Exists fun c => ∀ (n : α), GE.ge n n₀ → LE.le (Norm.norm (f n)) (HMul.hMul c (Norm.norm (g n)))) Filter.atTop)","decl":"theorem isBigO_atTop_iff_eventually_exists {α : Type*} [SemilatticeSup α] [Nonempty α]\n    {f : α → E} {g : α → F} : f =O[atTop] g ↔ ∀ᶠ n₀ in atTop, ∃ c, ∀ n ≥ n₀, ‖f n‖ ≤ c * ‖g n‖ := by\n  rw [isBigO_iff, exists_eventually_atTop]\n\n"}
{"name":"Asymptotics.isBigO_atTop_iff_eventually_exists_pos","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"G : Type u_5\nG' : Type u_8\ninst✝³ : Norm G\ninst✝² : SeminormedAddCommGroup G'\nα : Type u_17\ninst✝¹ : SemilatticeSup α\ninst✝ : Nonempty α\nf : α → G\ng : α → G'\n⊢ Iff (Asymptotics.IsBigO Filter.atTop f g) (Filter.Eventually (fun n₀ => Exists fun c => And (GT.gt c 0) (∀ (n : α), GE.ge n n₀ → LE.le (HMul.hMul c (Norm.norm (f n))) (Norm.norm (g n)))) Filter.atTop)","decl":"theorem isBigO_atTop_iff_eventually_exists_pos {α : Type*}\n    [SemilatticeSup α] [Nonempty α] {f : α → G} {g : α → G'} :\n    f =O[atTop] g ↔ ∀ᶠ n₀ in atTop, ∃ c > 0, ∀ n ≥ n₀, c * ‖f n‖ ≤ ‖g n‖ := by\n  simp_rw [isBigO_iff'', ← exists_prop, Subtype.exists', exists_eventually_atTop]\n\n"}
{"name":"Asymptotics.isBigO_mul_iff_isBigO_div","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\n𝕜 : Type u_15\ninst✝ : NormedDivisionRing 𝕜\nl : Filter α\nf g h : α → 𝕜\nhf : Filter.Eventually (fun x => Ne (f x) 0) l\n⊢ Iff (Asymptotics.IsBigO l (fun x => HMul.hMul (f x) (g x)) h) (Asymptotics.IsBigO l g fun x => HDiv.hDiv (h x) (f x))","decl":"lemma isBigO_mul_iff_isBigO_div {f g h : α → 𝕜} (hf : ∀ᶠ x in l, f x ≠ 0) :\n    (fun x ↦ f x * g x) =O[l] h ↔ g =O[l] (fun x ↦ h x / f x) := by\n  rw [isBigO_iff', isBigO_iff']\n  refine ⟨fun ⟨c, hc, H⟩ ↦ ⟨c, hc, ?_⟩, fun ⟨c, hc, H⟩ ↦ ⟨c, hc, ?_⟩⟩ <;>\n  · refine H.congr <| Eventually.mp hf <| Eventually.of_forall fun x hx ↦ ?_\n    rw [norm_mul, norm_div, ← mul_div_assoc, le_div_iff₀' (norm_pos_iff.mpr hx)]\n\n"}
{"name":"summable_of_isBigO","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : CompleteSpace E\nf : ι → E\ng : ι → Real\nhg : Summable g\nh : Asymptotics.IsBigO Filter.cofinite f g\n⊢ Summable f","decl":"theorem summable_of_isBigO {ι E} [SeminormedAddCommGroup E] [CompleteSpace E]\n    {f : ι → E} {g : ι → ℝ} (hg : Summable g) (h : f =O[cofinite] g) : Summable f :=\n  let ⟨C, hC⟩ := h.isBigOWith\n  .of_norm_bounded_eventually (fun x => C * ‖g x‖) (hg.abs.mul_left _) hC.bound\n\n"}
{"name":"summable_of_isBigO_nat","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"E : Type u_1\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : CompleteSpace E\nf : Nat → E\ng : Nat → Real\nhg : Summable g\nh : Asymptotics.IsBigO Filter.atTop f g\n⊢ Summable f","decl":"theorem summable_of_isBigO_nat {E} [SeminormedAddCommGroup E] [CompleteSpace E]\n    {f : ℕ → E} {g : ℕ → ℝ} (hg : Summable g) (h : f =O[atTop] g) : Summable f :=\n  summable_of_isBigO hg <| Nat.cofinite_eq_atTop.symm ▸ h\n\n"}
{"name":"Asymptotics.IsBigO.comp_summable_norm","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"ι : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : SeminormedAddCommGroup F\nf : E → F\ng : ι → E\nhf : Asymptotics.IsBigO (nhds 0) f id\nhg : Summable fun x => Norm.norm (g x)\n⊢ Summable fun x => Norm.norm (f (g x))","decl":"lemma Asymptotics.IsBigO.comp_summable_norm {ι E F : Type*}\n    [SeminormedAddCommGroup E] [SeminormedAddCommGroup F] {f : E → F} {g : ι → E}\n    (hf : f =O[𝓝 0] id) (hg : Summable (‖g ·‖)) : Summable (‖f <| g ·‖) :=\n  summable_of_isBigO hg <| hf.norm_norm.comp_tendsto <|\n    tendsto_zero_iff_norm_tendsto_zero.2 hg.tendsto_cofinite_zero\n\n"}
{"name":"PartialHomeomorph.isBigOWith_congr","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\nE : Type u_3\ninst✝¹ : Norm E\nF : Type u_4\ninst✝ : Norm F\ne : PartialHomeomorph α β\nb : β\nhb : Membership.mem e.target b\nf : β → E\ng : β → F\nC : Real\n⊢ Iff (Asymptotics.IsBigOWith C (nhds b) f g) (Asymptotics.IsBigOWith C (nhds (↑e.symm b)) (Function.comp f ↑e) (Function.comp g ↑e))","decl":"/-- Transfer `IsBigOWith` over a `PartialHomeomorph`. -/\ntheorem isBigOWith_congr (e : PartialHomeomorph α β) {b : β} (hb : b ∈ e.target) {f : β → E}\n    {g : β → F} {C : ℝ} : IsBigOWith C (𝓝 b) f g ↔ IsBigOWith C (𝓝 (e.symm b)) (f ∘ e) (g ∘ e) :=\n  ⟨fun h =>\n    h.comp_tendsto <| by\n      have := e.continuousAt (e.map_target hb)\n      rwa [ContinuousAt, e.rightInvOn hb] at this,\n    fun h =>\n    (h.comp_tendsto (e.continuousAt_symm hb)).congr' rfl\n      ((e.eventually_right_inverse hb).mono fun _ hx => congr_arg f hx)\n      ((e.eventually_right_inverse hb).mono fun _ hx => congr_arg g hx)⟩\n\n"}
{"name":"PartialHomeomorph.isBigO_congr","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\nE : Type u_3\ninst✝¹ : Norm E\nF : Type u_4\ninst✝ : Norm F\ne : PartialHomeomorph α β\nb : β\nhb : Membership.mem e.target b\nf : β → E\ng : β → F\n⊢ Iff (Asymptotics.IsBigO (nhds b) f g) (Asymptotics.IsBigO (nhds (↑e.symm b)) (Function.comp f ↑e) (Function.comp g ↑e))","decl":"/-- Transfer `IsBigO` over a `PartialHomeomorph`. -/\ntheorem isBigO_congr (e : PartialHomeomorph α β) {b : β} (hb : b ∈ e.target) {f : β → E}\n    {g : β → F} : f =O[𝓝 b] g ↔ (f ∘ e) =O[𝓝 (e.symm b)] (g ∘ e) := by\n  simp only [IsBigO_def]\n  exact exists_congr fun C => e.isBigOWith_congr hb\n\n"}
{"name":"PartialHomeomorph.isLittleO_congr","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\nE : Type u_3\ninst✝¹ : Norm E\nF : Type u_4\ninst✝ : Norm F\ne : PartialHomeomorph α β\nb : β\nhb : Membership.mem e.target b\nf : β → E\ng : β → F\n⊢ Iff (Asymptotics.IsLittleO (nhds b) f g) (Asymptotics.IsLittleO (nhds (↑e.symm b)) (Function.comp f ↑e) (Function.comp g ↑e))","decl":"/-- Transfer `IsLittleO` over a `PartialHomeomorph`. -/\ntheorem isLittleO_congr (e : PartialHomeomorph α β) {b : β} (hb : b ∈ e.target) {f : β → E}\n    {g : β → F} : f =o[𝓝 b] g ↔ (f ∘ e) =o[𝓝 (e.symm b)] (g ∘ e) := by\n  simp only [IsLittleO_def]\n  exact forall₂_congr fun c _hc => e.isBigOWith_congr hb\n\n"}
{"name":"Homeomorph.isBigOWith_congr","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\nE : Type u_3\ninst✝¹ : Norm E\nF : Type u_4\ninst✝ : Norm F\ne : Homeomorph α β\nb : β\nf : β → E\ng : β → F\nC : Real\n⊢ Iff (Asymptotics.IsBigOWith C (nhds b) f g) (Asymptotics.IsBigOWith C (nhds (e.symm b)) (Function.comp f ⇑e) (Function.comp g ⇑e))","decl":"/-- Transfer `IsBigOWith` over a `Homeomorph`. -/\ntheorem isBigOWith_congr (e : α ≃ₜ β) {b : β} {f : β → E} {g : β → F} {C : ℝ} :\n    IsBigOWith C (𝓝 b) f g ↔ IsBigOWith C (𝓝 (e.symm b)) (f ∘ e) (g ∘ e) :=\n  e.toPartialHomeomorph.isBigOWith_congr trivial\n\n"}
{"name":"Homeomorph.isBigO_congr","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\nE : Type u_3\ninst✝¹ : Norm E\nF : Type u_4\ninst✝ : Norm F\ne : Homeomorph α β\nb : β\nf : β → E\ng : β → F\n⊢ Iff (Asymptotics.IsBigO (nhds b) f g) (Asymptotics.IsBigO (nhds (e.symm b)) (Function.comp f ⇑e) (Function.comp g ⇑e))","decl":"/-- Transfer `IsBigO` over a `Homeomorph`. -/\ntheorem isBigO_congr (e : α ≃ₜ β) {b : β} {f : β → E} {g : β → F} :\n    f =O[𝓝 b] g ↔ (f ∘ e) =O[𝓝 (e.symm b)] (g ∘ e) := by\n  simp only [IsBigO_def]\n  exact exists_congr fun C => e.isBigOWith_congr\n\n"}
{"name":"Homeomorph.isLittleO_congr","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\nE : Type u_3\ninst✝¹ : Norm E\nF : Type u_4\ninst✝ : Norm F\ne : Homeomorph α β\nb : β\nf : β → E\ng : β → F\n⊢ Iff (Asymptotics.IsLittleO (nhds b) f g) (Asymptotics.IsLittleO (nhds (e.symm b)) (Function.comp f ⇑e) (Function.comp g ⇑e))","decl":"/-- Transfer `IsLittleO` over a `Homeomorph`. -/\ntheorem isLittleO_congr (e : α ≃ₜ β) {b : β} {f : β → E} {g : β → F} :\n    f =o[𝓝 b] g ↔ (f ∘ e) =o[𝓝 (e.symm b)] (g ∘ e) := by\n  simp only [IsLittleO_def]\n  exact forall₂_congr fun c _hc => e.isBigOWith_congr\n\n"}
{"name":"ContinuousOn.isBigOWith_principal","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝² : TopologicalSpace α\ns : Set α\nf : α → E\nc : F\ninst✝¹ : SeminormedAddGroup E\ninst✝ : Norm F\nhf : ContinuousOn f s\nhs : IsCompact s\nhc : Ne (Norm.norm c) 0\n⊢ Asymptotics.IsBigOWith (HDiv.hDiv (SupSet.sSup (Set.image Norm.norm (Set.image f s))) (Norm.norm c)) (Filter.principal s) f fun x => c","decl":"protected theorem isBigOWith_principal\n    (hf : ContinuousOn f s) (hs : IsCompact s) (hc : ‖c‖ ≠ 0) :\n    IsBigOWith (sSup (Norm.norm '' (f '' s)) / ‖c‖) (𝓟 s) f fun _ => c := by\n  rw [isBigOWith_principal, div_mul_cancel₀ _ hc]\n  exact fun x hx ↦ hs.image_of_continuousOn hf |>.image continuous_norm\n   |>.isLUB_sSup (Set.image_nonempty.mpr <| Set.image_nonempty.mpr ⟨x, hx⟩)\n   |>.left <| Set.mem_image_of_mem _ <| Set.mem_image_of_mem _ hx\n\n"}
{"name":"ContinuousOn.isBigO_principal","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝² : TopologicalSpace α\ns : Set α\nf : α → E\nc : F\ninst✝¹ : SeminormedAddGroup E\ninst✝ : Norm F\nhf : ContinuousOn f s\nhs : IsCompact s\nhc : Ne (Norm.norm c) 0\n⊢ Asymptotics.IsBigO (Filter.principal s) f fun x => c","decl":"protected theorem isBigO_principal (hf : ContinuousOn f s) (hs : IsCompact s)\n    (hc : ‖c‖ ≠ 0) : f =O[𝓟 s] fun _ => c :=\n  (hf.isBigOWith_principal hs hc).isBigO\n\n"}
{"name":"ContinuousOn.isBigOWith_rev_principal","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝² : TopologicalSpace α\ns : Set α\nf : α → E\ninst✝¹ : NormedAddGroup E\ninst✝ : SeminormedAddGroup F\nhf : ContinuousOn f s\nhs : IsCompact s\nhC : ∀ (i : α), Membership.mem s i → Ne (f i) 0\nc : F\n⊢ Asymptotics.IsBigOWith (HDiv.hDiv (Norm.norm c) (InfSet.sInf (Set.image Norm.norm (Set.image f s)))) (Filter.principal s) (fun x => c) f","decl":"protected theorem isBigOWith_rev_principal\n    (hf : ContinuousOn f s) (hs : IsCompact s) (hC : ∀ i ∈ s, f i ≠ 0) (c : F) :\n    IsBigOWith (‖c‖ / sInf (Norm.norm '' (f '' s))) (𝓟 s) (fun _ => c) f := by\n  refine isBigOWith_principal.mpr fun x hx ↦ ?_\n  rw [mul_comm_div]\n  replace hs := hs.image_of_continuousOn hf |>.image continuous_norm\n  have h_sInf := hs.isGLB_sInf <| Set.image_nonempty.mpr <| Set.image_nonempty.mpr ⟨x, hx⟩\n  refine le_mul_of_one_le_right (norm_nonneg c) <| (one_le_div ?_).mpr <|\n    h_sInf.1 <| Set.mem_image_of_mem _ <| Set.mem_image_of_mem _ hx\n  obtain ⟨_, ⟨x, hx, hCx⟩, hnormCx⟩ := hs.sInf_mem h_sInf.nonempty\n  rw [← hnormCx, ← hCx]\n  exact (norm_ne_zero_iff.mpr (hC x hx)).symm.lt_of_le (norm_nonneg _)\n\n"}
{"name":"ContinuousOn.isBigO_rev_principal","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"α : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝² : TopologicalSpace α\ns : Set α\nf : α → E\ninst✝¹ : NormedAddGroup E\ninst✝ : SeminormedAddGroup F\nhf : ContinuousOn f s\nhs : IsCompact s\nhC : ∀ (i : α), Membership.mem s i → Ne (f i) 0\nc : F\n⊢ Asymptotics.IsBigO (Filter.principal s) (fun x => c) f","decl":"protected theorem isBigO_rev_principal (hf : ContinuousOn f s)\n    (hs : IsCompact s) (hC : ∀ i ∈ s, f i ≠ 0) (c : F) : (fun _ => c) =O[𝓟 s] f :=\n  (hf.isBigOWith_rev_principal hs hC c).isBigO\n\n"}
{"name":"NormedField.tendsto_zero_smul_of_tendsto_zero_of_bounded","module":"Mathlib.Analysis.Asymptotics.Lemmas","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\n𝔸 : Type u_3\ninst✝³ : NormedDivisionRing 𝕜\ninst✝² : NormedAddCommGroup 𝔸\ninst✝¹ : Module 𝕜 𝔸\ninst✝ : BoundedSMul 𝕜 𝔸\nl : Filter ι\nε : ι → 𝕜\nf : ι → 𝔸\nhε : Filter.Tendsto ε l (nhds 0)\nhf : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm f)\n⊢ Filter.Tendsto (HSMul.hSMul ε f) l (nhds 0)","decl":"/-- The (scalar) product of a sequence that tends to zero with a bounded one also tends to zero. -/\nlemma NormedField.tendsto_zero_smul_of_tendsto_zero_of_bounded {ι 𝕜 𝔸 : Type*}\n    [NormedDivisionRing 𝕜] [NormedAddCommGroup 𝔸] [Module 𝕜 𝔸] [BoundedSMul 𝕜 𝔸] {l : Filter ι}\n    {ε : ι → 𝕜} {f : ι → 𝔸} (hε : Tendsto ε l (𝓝 0)) (hf : IsBoundedUnder (· ≤ ·) l (norm ∘ f)) :\n    Tendsto (ε • f) l (𝓝 0) := by\n  rw [← isLittleO_one_iff 𝕜] at hε ⊢\n  simpa using IsLittleO.smul_isBigO hε (hf.isBigO_const (one_ne_zero : (1 : 𝕜) ≠ 0))\n"}
