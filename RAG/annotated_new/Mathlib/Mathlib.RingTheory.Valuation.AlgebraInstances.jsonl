{"name":"ValuationSubring.algebraMap_injective","module":"Mathlib.RingTheory.Valuation.AlgebraInstances","initialProofState":"K : Type u_1\ninst✝² : Field K\nv : Valuation K (WithZero (Multiplicative Int))\nL : Type u_2\ninst✝¹ : Field L\ninst✝ : Algebra K L\n⊢ Function.Injective ⇑(algebraMap (Subtype fun x => Membership.mem v.valuationSubring x) L)","decl":"theorem algebraMap_injective : Injective (algebraMap v.valuationSubring L) :=\n  (NoZeroSMulDivisors.algebraMap_injective K L).comp (IsFractionRing.injective _ _)\n\n"}
{"name":"ValuationSubring.isIntegral_of_mem_ringOfIntegers","module":"Mathlib.RingTheory.Valuation.AlgebraInstances","initialProofState":"K : Type u_1\ninst✝² : Field K\nv : Valuation K (WithZero (Multiplicative Int))\nL : Type u_2\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nhx : Membership.mem (integralClosure (Subtype fun x => Membership.mem v.valuationSubring x) L) x\n⊢ IsIntegral (Subtype fun x => Membership.mem v.valuationSubring x) ⟨x, hx⟩","decl":"theorem isIntegral_of_mem_ringOfIntegers {x : L} (hx : x ∈ integralClosure v.valuationSubring L) :\n    IsIntegral v.valuationSubring (⟨x, hx⟩ : integralClosure v.valuationSubring L) := by\n  obtain ⟨P, hPm, hP⟩ := hx\n  refine ⟨P, hPm, ?_⟩\n  rw [← Polynomial.aeval_def, ← Subalgebra.coe_eq_zero, Polynomial.aeval_subalgebra_coe,\n    Polynomial.aeval_def, Subtype.coe_mk, hP]\n\n"}
{"name":"ValuationSubring.isIntegral_of_mem_ringOfIntegers'","module":"Mathlib.RingTheory.Valuation.AlgebraInstances","initialProofState":"K : Type u_1\ninst✝² : Field K\nv : Valuation K (WithZero (Multiplicative Int))\nL : Type u_2\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : Subtype fun x => Membership.mem (integralClosure (Subtype fun x => Membership.mem v.valuationSubring x) L) x\n⊢ IsIntegral (Subtype fun x => Membership.mem v.valuationSubring x) x","decl":"theorem isIntegral_of_mem_ringOfIntegers' {x : (integralClosure v.valuationSubring L)} :\n    IsIntegral v.valuationSubring (x : integralClosure v.valuationSubring L) := by\n  apply isIntegral_of_mem_ringOfIntegers\n\n"}
{"name":"ValuationSubring.instIsScalarTowerSubtypeMemValuationSubringWithZeroMultiplicativeInt","module":"Mathlib.RingTheory.Valuation.AlgebraInstances","initialProofState":"K : Type u_1\ninst✝⁶ : Field K\nv : Valuation K (WithZero (Multiplicative Int))\nL : Type u_2\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K L\nE : Type u_3\ninst✝³ : Field E\ninst✝² : Algebra K E\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower K L E\n⊢ IsScalarTower (Subtype fun x => Membership.mem v.valuationSubring x) L E","decl":"instance : IsScalarTower v.valuationSubring L E := Subring.instIsScalarTowerSubtypeMem _\n\n"}
{"name":"ValuationSubring.integralClosure_algebraMap_injective","module":"Mathlib.RingTheory.Valuation.AlgebraInstances","initialProofState":"K : Type u_1\ninst✝² : Field K\nv : Valuation K (WithZero (Multiplicative Int))\nL : Type u_2\ninst✝¹ : Field L\ninst✝ : Algebra K L\n⊢ Function.Injective ⇑(algebraMap (Subtype fun x => Membership.mem v.valuationSubring x) (Subtype fun x => Membership.mem (integralClosure (Subtype fun x => Membership.mem v.valuationSubring x) L) x))","decl":"theorem integralClosure_algebraMap_injective :\n    Injective (algebraMap v.valuationSubring (integralClosure v.valuationSubring L)) := by\n  have hinj : Injective ⇑(algebraMap v.valuationSubring L) :=\n    ValuationSubring.algebraMap_injective v L\n  rw [injective_iff_map_eq_zero (algebraMap v.valuationSubring _)]\n  intro x hx\n  rw [← Subtype.coe_inj, Subalgebra.coe_zero] at hx\n  rw [injective_iff_map_eq_zero (algebraMap v.valuationSubring L)] at hinj\n  exact hinj x hx\n\n"}
