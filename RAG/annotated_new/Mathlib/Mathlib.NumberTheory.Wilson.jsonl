{"name":"ZMod.wilsons_lemma","module":"Mathlib.NumberTheory.Wilson","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (↑(HSub.hSub p 1).factorial) (-1)","decl":"/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\n@[simp]\ntheorem wilsons_lemma : ((p - 1)! : ZMod p) = -1 := by\n  refine\n    calc\n      ((p - 1)! : ZMod p) = ∏ x ∈ Ico 1 (succ (p - 1)), (x : ZMod p) := by\n        rw [← Finset.prod_Ico_id_eq_factorial, prod_natCast]\n      _ = ∏ x : (ZMod p)ˣ, (x : ZMod p) := ?_\n      _ = -1 := by\n        -- Porting note: `simp` is less powerful.\n        -- simp_rw [← Units.coeHom_apply, ← (Units.coeHom (ZMod p)).map_prod,\n        --   prod_univ_units_id_eq_neg_one, Units.coeHom_apply, Units.val_neg, Units.val_one]\n        simp_rw [← Units.coeHom_apply]\n        rw [← map_prod (Units.coeHom (ZMod p))]\n        simp_rw [prod_univ_units_id_eq_neg_one, Units.coeHom_apply, Units.val_neg, Units.val_one]\n  have hp : 0 < p := (Fact.out (p := p.Prime)).pos\n  symm\n  refine prod_bij (fun a _ => (a : ZMod p).val) ?_ ?_ ?_ ?_\n  · intro a ha\n    rw [mem_Ico, ← Nat.succ_sub hp, Nat.add_one_sub_one]\n    constructor\n    · apply Nat.pos_of_ne_zero; rw [← @val_zero p]\n      intro h; apply Units.ne_zero a (val_injective p h)\n    · exact val_lt _\n  · intro _ _ _ _ h; rw [Units.ext_iff]; exact val_injective p h\n  · intro b hb\n    rw [mem_Ico, Nat.succ_le_iff, ← succ_sub hp, Nat.add_one_sub_one, pos_iff_ne_zero] at hb\n    refine ⟨Units.mk0 b ?_, Finset.mem_univ _, ?_⟩\n    · intro h; apply hb.1; apply_fun val at h\n      simpa only [val_cast_of_lt hb.right, val_zero] using h\n    · simp only [val_cast_of_lt hb.right, Units.val_mk0]\n  · rintro a -; simp only [cast_id, natCast_val]\n\n"}
{"name":"ZMod.prod_Ico_one_prime","module":"Mathlib.NumberTheory.Wilson","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq ((Finset.Ico 1 p).prod fun x => ↑x) (-1)","decl":"@[simp]\ntheorem prod_Ico_one_prime : ∏ x ∈ Ico 1 p, (x : ZMod p) = -1 := by\n  -- Porting note: was `conv in Ico 1 p =>`\n  conv =>\n    congr\n    congr\n    rw [← Nat.add_one_sub_one p, succ_sub (Fact.out (p := p.Prime)).pos]\n  rw [← prod_natCast, Finset.prod_Ico_id_eq_factorial, wilsons_lemma]\n\n"}
{"name":"Nat.prime_of_fac_equiv_neg_one","module":"Mathlib.NumberTheory.Wilson","initialProofState":"n : Nat\nh : Eq (↑(HSub.hSub n 1).factorial) (-1)\nh1 : Ne n 1\n⊢ Nat.Prime n","decl":"/-- For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem prime_of_fac_equiv_neg_one (h : ((n - 1)! : ZMod n) = -1) (h1 : n ≠ 1) : Prime n := by\n  rcases eq_or_ne n 0 with (rfl | h0)\n  · norm_num at h\n  replace h1 : 1 < n := n.two_le_iff.mpr ⟨h0, h1⟩\n  by_contra h2\n  obtain ⟨m, hm1, hm2 : 1 < m, hm3⟩ := exists_dvd_of_not_prime2 h1 h2\n  have hm : m ∣ (n - 1)! := Nat.dvd_factorial (pos_of_gt hm2) (le_pred_of_lt hm3)\n  refine hm2.ne' (Nat.dvd_one.mp ((Nat.dvd_add_right hm).mp (hm1.trans ?_)))\n  rw [← ZMod.natCast_zmod_eq_zero_iff_dvd, cast_add, cast_one, h, neg_add_cancel]\n\n"}
{"name":"Nat.prime_iff_fac_equiv_neg_one","module":"Mathlib.NumberTheory.Wilson","initialProofState":"n : Nat\nh : Ne n 1\n⊢ Iff (Nat.Prime n) (Eq (↑(HSub.hSub n 1).factorial) (-1))","decl":"/-- **Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem prime_iff_fac_equiv_neg_one (h : n ≠ 1) : Prime n ↔ ((n - 1)! : ZMod n) = -1 := by\n  refine ⟨fun h1 => ?_, fun h2 => prime_of_fac_equiv_neg_one h2 h⟩\n  haveI := Fact.mk h1\n  exact ZMod.wilsons_lemma n\n\n"}
