{"name":"MvPolynomial.mem_zeroLocus_iff","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\nI : Ideal (MvPolynomial σ k)\nx : σ → k\n⊢ Iff (Membership.mem (MvPolynomial.zeroLocus I) x) (∀ (p : MvPolynomial σ k), Membership.mem I p → Eq ((MvPolynomial.eval x) p) 0)","decl":"@[simp]\ntheorem mem_zeroLocus_iff {I : Ideal (MvPolynomial σ k)} {x : σ → k} :\n    x ∈ zeroLocus I ↔ ∀ p ∈ I, eval x p = 0 :=\n  Iff.rfl\n\n"}
{"name":"MvPolynomial.zeroLocus_anti_mono","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\nI J : Ideal (MvPolynomial σ k)\nh : LE.le I J\n⊢ LE.le (MvPolynomial.zeroLocus J) (MvPolynomial.zeroLocus I)","decl":"theorem zeroLocus_anti_mono {I J : Ideal (MvPolynomial σ k)} (h : I ≤ J) :\n    zeroLocus J ≤ zeroLocus I := fun _ hx p hp => hx p <| h hp\n\n"}
{"name":"MvPolynomial.zeroLocus_bot","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\n⊢ Eq (MvPolynomial.zeroLocus Bot.bot) Top.top","decl":"@[simp]\ntheorem zeroLocus_bot : zeroLocus (⊥ : Ideal (MvPolynomial σ k)) = ⊤ :=\n  eq_top_iff.2 fun x _ _ hp => Trans.trans (congr_arg (eval x) (mem_bot.1 hp)) (eval x).map_zero\n\n"}
{"name":"MvPolynomial.zeroLocus_top","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\n⊢ Eq (MvPolynomial.zeroLocus Top.top) Bot.bot","decl":"@[simp]\ntheorem zeroLocus_top : zeroLocus (⊤ : Ideal (MvPolynomial σ k)) = ⊥ :=\n  eq_bot_iff.2 fun x hx => one_ne_zero ((eval x).map_one ▸ hx 1 Submodule.mem_top : (1 : k) = 0)\n\n"}
{"name":"MvPolynomial.mem_vanishingIdeal_iff","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\nV : Set (σ → k)\np : MvPolynomial σ k\n⊢ Iff (Membership.mem (MvPolynomial.vanishingIdeal V) p) (∀ (x : σ → k), Membership.mem V x → Eq ((MvPolynomial.eval x) p) 0)","decl":"@[simp]\ntheorem mem_vanishingIdeal_iff {V : Set (σ → k)} {p : MvPolynomial σ k} :\n    p ∈ vanishingIdeal V ↔ ∀ x ∈ V, eval x p = 0 :=\n  Iff.rfl\n\n"}
{"name":"MvPolynomial.vanishingIdeal_anti_mono","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\nA B : Set (σ → k)\nh : LE.le A B\n⊢ LE.le (MvPolynomial.vanishingIdeal B) (MvPolynomial.vanishingIdeal A)","decl":"theorem vanishingIdeal_anti_mono {A B : Set (σ → k)} (h : A ≤ B) :\n    vanishingIdeal B ≤ vanishingIdeal A := fun _ hp x hx => hp x <| h hx\n\n"}
{"name":"MvPolynomial.vanishingIdeal_empty","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\n⊢ Eq (MvPolynomial.vanishingIdeal EmptyCollection.emptyCollection) Top.top","decl":"theorem vanishingIdeal_empty : vanishingIdeal (∅ : Set (σ → k)) = ⊤ :=\n  le_antisymm le_top fun _ _ x hx => absurd hx (Set.not_mem_empty x)\n\n"}
{"name":"MvPolynomial.le_vanishingIdeal_zeroLocus","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\nI : Ideal (MvPolynomial σ k)\n⊢ LE.le I (MvPolynomial.vanishingIdeal (MvPolynomial.zeroLocus I))","decl":"theorem le_vanishingIdeal_zeroLocus (I : Ideal (MvPolynomial σ k)) :\n    I ≤ vanishingIdeal (zeroLocus I) := fun p hp _ hx => hx p hp\n\n"}
{"name":"MvPolynomial.zeroLocus_vanishingIdeal_le","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\nV : Set (σ → k)\n⊢ LE.le V (MvPolynomial.zeroLocus (MvPolynomial.vanishingIdeal V))","decl":"theorem zeroLocus_vanishingIdeal_le (V : Set (σ → k)) : V ≤ zeroLocus (vanishingIdeal V) :=\n  fun V hV _ hp => hp V hV\n\n"}
{"name":"MvPolynomial.zeroLocus_vanishingIdeal_galoisConnection","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\n⊢ GaloisConnection MvPolynomial.zeroLocus MvPolynomial.vanishingIdeal","decl":"theorem zeroLocus_vanishingIdeal_galoisConnection :\n    @GaloisConnection (Ideal (MvPolynomial σ k)) (Set (σ → k))ᵒᵈ _ _ zeroLocus vanishingIdeal :=\n  GaloisConnection.monotone_intro (fun _ _ ↦ vanishingIdeal_anti_mono)\n    (fun _ _ ↦ zeroLocus_anti_mono) le_vanishingIdeal_zeroLocus zeroLocus_vanishingIdeal_le\n\n"}
{"name":"MvPolynomial.le_zeroLocus_iff_le_vanishingIdeal","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\nV : Set (σ → k)\nI : Ideal (MvPolynomial σ k)\n⊢ Iff (LE.le V (MvPolynomial.zeroLocus I)) (LE.le I (MvPolynomial.vanishingIdeal V))","decl":"theorem le_zeroLocus_iff_le_vanishingIdeal {V : Set (σ → k)} {I : Ideal (MvPolynomial σ k)} :\n    V ≤ zeroLocus I ↔ I ≤ vanishingIdeal V :=\n  zeroLocus_vanishingIdeal_galoisConnection.le_iff_le\n\n"}
{"name":"MvPolynomial.zeroLocus_span","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\nS : Set (MvPolynomial σ k)\n⊢ Eq (MvPolynomial.zeroLocus (Ideal.span S)) (setOf fun x => ∀ (p : MvPolynomial σ k), Membership.mem S p → Eq ((MvPolynomial.eval x) p) 0)","decl":"theorem zeroLocus_span (S : Set (MvPolynomial σ k)) :\n    zeroLocus (Ideal.span S) = { x | ∀ p ∈ S, eval x p = 0 } :=\n  eq_of_forall_le_iff fun _ => le_zeroLocus_iff_le_vanishingIdeal.trans <|\n    Ideal.span_le.trans forall₂_swap\n\n"}
{"name":"MvPolynomial.mem_vanishingIdeal_singleton_iff","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\nx : σ → k\np : MvPolynomial σ k\n⊢ Iff (Membership.mem (MvPolynomial.vanishingIdeal (Singleton.singleton x)) p) (Eq ((MvPolynomial.eval x) p) 0)","decl":"theorem mem_vanishingIdeal_singleton_iff (x : σ → k) (p : MvPolynomial σ k) :\n    p ∈ (vanishingIdeal {x} : Ideal (MvPolynomial σ k)) ↔ eval x p = 0 :=\n  ⟨fun h => h x rfl, fun hpx _ hy => hy.symm ▸ hpx⟩\n\n"}
{"name":"MvPolynomial.vanishingIdeal_singleton_isMaximal","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\nx : σ → k\n⊢ (MvPolynomial.vanishingIdeal (Singleton.singleton x)).IsMaximal","decl":"instance vanishingIdeal_singleton_isMaximal {x : σ → k} :\n    (vanishingIdeal {x} : Ideal (MvPolynomial σ k)).IsMaximal := by\n  have : Function.Bijective\n      (Ideal.Quotient.lift _ (eval x) fun p h ↦ (mem_vanishingIdeal_singleton_iff x p).mp h) := by\n    refine ⟨(injective_iff_map_eq_zero _).mpr fun p hp ↦ ?_, fun z ↦\n      ⟨(Ideal.Quotient.mk (vanishingIdeal {x} : Ideal (MvPolynomial σ k))) (C z), by simp⟩⟩\n    obtain ⟨q, rfl⟩ := Ideal.Quotient.mk_surjective p\n    rwa [Ideal.Quotient.lift_mk, ← mem_vanishingIdeal_singleton_iff,\n      ← Quotient.eq_zero_iff_mem] at hp\n  rw [← bot_quotient_isMaximal_iff, isMaximal_iff_of_bijective _ this]\n  exact bot_isMaximal\n\n"}
{"name":"MvPolynomial.radical_le_vanishingIdeal_zeroLocus","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\nI : Ideal (MvPolynomial σ k)\n⊢ LE.le I.radical (MvPolynomial.vanishingIdeal (MvPolynomial.zeroLocus I))","decl":"theorem radical_le_vanishingIdeal_zeroLocus (I : Ideal (MvPolynomial σ k)) :\n    I.radical ≤ vanishingIdeal (zeroLocus I) := by\n  intro p hp x hx\n  rw [← mem_vanishingIdeal_singleton_iff]\n  rw [radical_eq_sInf] at hp\n  refine\n    (mem_sInf.mp hp)\n      ⟨le_trans (le_vanishingIdeal_zeroLocus I)\n          (vanishingIdeal_anti_mono fun y hy => hy.symm ▸ hx),\n        IsMaximal.isPrime' _⟩\n\n"}
{"name":"MvPolynomial.vanishingIdeal_pointToPoint","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\nV : Set (σ → k)\n⊢ Eq (PrimeSpectrum.vanishingIdeal (Set.image MvPolynomial.pointToPoint V)) (MvPolynomial.vanishingIdeal V)","decl":"@[simp]\ntheorem vanishingIdeal_pointToPoint (V : Set (σ → k)) :\n    PrimeSpectrum.vanishingIdeal (pointToPoint '' V) = MvPolynomial.vanishingIdeal V :=\n  le_antisymm\n    (fun _ hp x hx =>\n      (((PrimeSpectrum.mem_vanishingIdeal _ _).1 hp) ⟨vanishingIdeal {x}, by infer_instance⟩ <| by\n          exact ⟨x, ⟨hx, rfl⟩⟩) -- Porting note: tactic mode code compiles but term mode does not\n        x rfl)\n    fun _ hp =>\n    (PrimeSpectrum.mem_vanishingIdeal _ _).2 fun _ hI =>\n      let ⟨x, hx⟩ := hI\n      hx.2 ▸ fun _ hx' => (Set.mem_singleton_iff.1 hx').symm ▸ hp x hx.1\n\n"}
{"name":"MvPolynomial.pointToPoint_zeroLocus_le","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝ : Field k\nσ : Type u_2\nI : Ideal (MvPolynomial σ k)\n⊢ LE.le (Set.image MvPolynomial.pointToPoint (MvPolynomial.zeroLocus I)) (PrimeSpectrum.zeroLocus ↑I)","decl":"theorem pointToPoint_zeroLocus_le (I : Ideal (MvPolynomial σ k)) :\n    pointToPoint '' MvPolynomial.zeroLocus I ≤ PrimeSpectrum.zeroLocus ↑I := fun J hJ =>\n  let ⟨_, hx⟩ := hJ\n  (le_trans (le_vanishingIdeal_zeroLocus I)\n      (hx.2 ▸ vanishingIdeal_anti_mono (Set.singleton_subset_iff.2 hx.1)) :\n    I ≤ J.asIdeal)\n\n"}
{"name":"MvPolynomial.isMaximal_iff_eq_vanishingIdeal_singleton","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝² : Field k\nσ : Type u_2\ninst✝¹ : IsAlgClosed k\ninst✝ : Finite σ\nI : Ideal (MvPolynomial σ k)\n⊢ Iff I.IsMaximal (Exists fun x => Eq I (MvPolynomial.vanishingIdeal (Singleton.singleton x)))","decl":"theorem isMaximal_iff_eq_vanishingIdeal_singleton (I : Ideal (MvPolynomial σ k)) :\n    I.IsMaximal ↔ ∃ x : σ → k, I = vanishingIdeal {x} := by\n  cases nonempty_fintype σ\n  refine\n    ⟨fun hI => ?_, fun h =>\n      let ⟨x, hx⟩ := h\n      hx.symm ▸ MvPolynomial.vanishingIdeal_singleton_isMaximal⟩\n  letI : I.IsMaximal := hI\n  letI : Field (MvPolynomial σ k ⧸ I) := Quotient.field I\n  let ϕ : k →+* MvPolynomial σ k ⧸ I := (Ideal.Quotient.mk I).comp C\n  have hϕ : Function.Bijective ϕ :=\n    ⟨quotient_mk_comp_C_injective _ _ I hI.ne_top,\n      IsAlgClosed.algebraMap_surjective_of_isIntegral' ϕ\n        (MvPolynomial.comp_C_integral_of_surjective_of_isJacobsonRing _ Quotient.mk_surjective)⟩\n  obtain ⟨φ, hφ⟩ := Function.Surjective.hasRightInverse hϕ.2\n  let x : σ → k := fun s => φ ((Ideal.Quotient.mk I) (X s))\n  have hx : ∀ s : σ, ϕ (x s) = (Ideal.Quotient.mk I) (X s) := fun s =>\n    hφ ((Ideal.Quotient.mk I) (X s))\n  refine ⟨x, (IsMaximal.eq_of_le (by infer_instance) hI.ne_top ?_).symm⟩\n  intro p hp\n  rw [← Quotient.eq_zero_iff_mem, map_mvPolynomial_eq_eval₂ (Ideal.Quotient.mk I) p, eval₂_eq']\n  rw [mem_vanishingIdeal_singleton_iff, eval_eq'] at hp\n  simpa only [map_sum ϕ, ϕ.map_mul, map_prod ϕ, ϕ.map_pow, ϕ.map_zero, hx] using congr_arg ϕ hp\n\n"}
{"name":"MvPolynomial.vanishingIdeal_zeroLocus_eq_radical","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝² : Field k\nσ : Type u_2\ninst✝¹ : IsAlgClosed k\ninst✝ : Finite σ\nI : Ideal (MvPolynomial σ k)\n⊢ Eq (MvPolynomial.vanishingIdeal (MvPolynomial.zeroLocus I)) I.radical","decl":"/-- Main statement of the Nullstellensatz -/\n@[simp]\ntheorem vanishingIdeal_zeroLocus_eq_radical (I : Ideal (MvPolynomial σ k)) :\n    vanishingIdeal (zeroLocus I) = I.radical := by\n  rw [I.radical_eq_jacobson]\n  refine le_antisymm (le_sInf ?_) fun p hp x hx => ?_\n  · rintro J ⟨hJI, hJ⟩\n    obtain ⟨x, hx⟩ := (isMaximal_iff_eq_vanishingIdeal_singleton J).1 hJ\n    refine hx.symm ▸ vanishingIdeal_anti_mono fun y hy p hp => ?_\n    rw [← mem_vanishingIdeal_singleton_iff, Set.mem_singleton_iff.1 hy, ← hx]\n    exact hJI hp\n  · rw [← mem_vanishingIdeal_singleton_iff x p]\n    refine (mem_sInf.mp hp)\n      ⟨le_trans (le_vanishingIdeal_zeroLocus I) (vanishingIdeal_anti_mono fun y hy => hy.symm ▸ hx),\n        MvPolynomial.vanishingIdeal_singleton_isMaximal⟩\n\n-- Porting note: marked this as high priority to short cut simplifier\n"}
{"name":"MvPolynomial.IsPrime.vanishingIdeal_zeroLocus","module":"Mathlib.RingTheory.Nullstellensatz","initialProofState":"k : Type u_1\ninst✝² : Field k\nσ : Type u_2\ninst✝¹ : IsAlgClosed k\ninst✝ : Finite σ\nP : Ideal (MvPolynomial σ k)\nh : P.IsPrime\n⊢ Eq (MvPolynomial.vanishingIdeal (MvPolynomial.zeroLocus P)) P","decl":"@[simp (high)]\ntheorem IsPrime.vanishingIdeal_zeroLocus (P : Ideal (MvPolynomial σ k)) [h : P.IsPrime] :\n    vanishingIdeal (zeroLocus P) = P :=\n  Trans.trans (vanishingIdeal_zeroLocus_eq_radical P) h.radical\n\n"}
