{"name":"periodic_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nâŠ¢ Function.Periodic (circleMap c R) (HMul.hMul 2 Real.pi)","decl":"/-- `circleMap` is `2Ï€`-periodic. -/\ntheorem periodic_circleMap (c : â„‚) (R : â„) : Periodic (circleMap c R) (2 * Ï€) := fun Î¸ => by\n  simp [circleMap, add_mul, exp_periodic _]\n\n"}
{"name":"Set.Countable.preimage_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"s : Set Complex\nhs : s.Countable\nc : Complex\nR : Real\nhR : Ne R 0\nâŠ¢ (Set.preimage (circleMap c R) s).Countable","decl":"theorem Set.Countable.preimage_circleMap {s : Set â„‚} (hs : s.Countable) (c : â„‚) {R : â„}\n    (hR : R â‰  0) : (circleMap c R â»Â¹' s).Countable :=\n  show (((â†‘) : â„ â†’ â„‚) â»Â¹' ((Â· * I) â»Â¹'\n      (exp â»Â¹' ((R * Â·) â»Â¹' ((c + Â·) â»Â¹' s))))).Countable from\n    (((hs.preimage (add_right_injective _)).preimage <|\n      mul_right_injectiveâ‚€ <| ofReal_ne_zero.2 hR).preimage_cexp.preimage <|\n        mul_left_injectiveâ‚€ I_ne_zero).preimage ofReal_injective\n\n"}
{"name":"circleMap_sub_center","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR Î¸ : Real\nâŠ¢ Eq (HSub.hSub (circleMap c R Î¸) c) (circleMap 0 R Î¸)","decl":"@[simp]\ntheorem circleMap_sub_center (c : â„‚) (R : â„) (Î¸ : â„) : circleMap c R Î¸ - c = circleMap 0 R Î¸ := by\n  simp [circleMap]\n\n"}
{"name":"circleMap_zero","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"R Î¸ : Real\nâŠ¢ Eq (circleMap 0 R Î¸) (HMul.hMul (â†‘R) (Complex.exp (HMul.hMul (â†‘Î¸) Complex.I)))","decl":"theorem circleMap_zero (R Î¸ : â„) : circleMap 0 R Î¸ = R * exp (Î¸ * I) :=\n  zero_add _\n\n"}
{"name":"abs_circleMap_zero","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"R Î¸ : Real\nâŠ¢ Eq (Complex.abs (circleMap 0 R Î¸)) (abs R)","decl":"@[simp]\ntheorem abs_circleMap_zero (R : â„) (Î¸ : â„) : abs (circleMap 0 R Î¸) = |R| := by simp [circleMap]\n\n"}
{"name":"circleMap_mem_sphere'","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR Î¸ : Real\nâŠ¢ Membership.mem (Metric.sphere c (abs R)) (circleMap c R Î¸)","decl":"theorem circleMap_mem_sphere' (c : â„‚) (R : â„) (Î¸ : â„) : circleMap c R Î¸ âˆˆ sphere c |R| := by simp\n\n"}
{"name":"circleMap_mem_sphere","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nhR : LE.le 0 R\nÎ¸ : Real\nâŠ¢ Membership.mem (Metric.sphere c R) (circleMap c R Î¸)","decl":"theorem circleMap_mem_sphere (c : â„‚) {R : â„} (hR : 0 â‰¤ R) (Î¸ : â„) :\n    circleMap c R Î¸ âˆˆ sphere c R := by\n  simpa only [_root_.abs_of_nonneg hR] using circleMap_mem_sphere' c R Î¸\n\n"}
{"name":"circleMap_mem_closedBall","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nhR : LE.le 0 R\nÎ¸ : Real\nâŠ¢ Membership.mem (Metric.closedBall c R) (circleMap c R Î¸)","decl":"theorem circleMap_mem_closedBall (c : â„‚) {R : â„} (hR : 0 â‰¤ R) (Î¸ : â„) :\n    circleMap c R Î¸ âˆˆ closedBall c R :=\n  sphere_subset_closedBall (circleMap_mem_sphere c hR Î¸)\n\n"}
{"name":"circleMap_not_mem_ball","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR Î¸ : Real\nâŠ¢ Not (Membership.mem (Metric.ball c R) (circleMap c R Î¸))","decl":"theorem circleMap_not_mem_ball (c : â„‚) (R : â„) (Î¸ : â„) : circleMap c R Î¸ âˆ‰ ball c R := by\n  simp [dist_eq, le_abs_self]\n\n"}
{"name":"circleMap_ne_mem_ball","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nw : Complex\nhw : Membership.mem (Metric.ball c R) w\nÎ¸ : Real\nâŠ¢ Ne (circleMap c R Î¸) w","decl":"theorem circleMap_ne_mem_ball {c : â„‚} {R : â„} {w : â„‚} (hw : w âˆˆ ball c R) (Î¸ : â„) :\n    circleMap c R Î¸ â‰  w :=\n  (ne_of_mem_of_not_mem hw (circleMap_not_mem_ball _ _ _)).symm\n\n"}
{"name":"range_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nâŠ¢ Eq (Set.range (circleMap c R)) (Metric.sphere c (abs R))","decl":"/-- The range of `circleMap c R` is the circle with center `c` and radius `|R|`. -/\n@[simp]\ntheorem range_circleMap (c : â„‚) (R : â„) : range (circleMap c R) = sphere c |R| :=\n  calc\n    range (circleMap c R) = c +áµ¥ R â€¢ range fun Î¸ : â„ => exp (Î¸ * I) := by\n      simp (config := { unfoldPartialApp := true }) only [â† image_vadd, â† image_smul, â† range_comp,\n        vadd_eq_add, circleMap, Function.comp_def, real_smul]\n    _ = sphere c |R| := by\n      rw [Complex.range_exp_mul_I, smul_sphere R 0 zero_le_one]\n      simp\n\n"}
{"name":"image_circleMap_Ioc","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nâŠ¢ Eq (Set.image (circleMap c R) (Set.Ioc 0 (HMul.hMul 2 Real.pi))) (Metric.sphere c (abs R))","decl":"/-- The image of `(0, 2Ï€]` under `circleMap c R` is the circle with center `c` and radius `|R|`. -/\n@[simp]\ntheorem image_circleMap_Ioc (c : â„‚) (R : â„) : circleMap c R '' Ioc 0 (2 * Ï€) = sphere c |R| := by\n  rw [â† range_circleMap, â† (periodic_circleMap c R).image_Ioc Real.two_pi_pos 0, zero_add]\n\n"}
{"name":"circleMap_eq_center_iff","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR Î¸ : Real\nâŠ¢ Iff (Eq (circleMap c R Î¸) c) (Eq R 0)","decl":"@[simp]\ntheorem circleMap_eq_center_iff {c : â„‚} {R : â„} {Î¸ : â„} : circleMap c R Î¸ = c â†” R = 0 := by\n  simp [circleMap, exp_ne_zero]\n\n"}
{"name":"circleMap_zero_radius","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nâŠ¢ Eq (circleMap c 0) (Function.const Real c)","decl":"@[simp]\ntheorem circleMap_zero_radius (c : â„‚) : circleMap c 0 = const â„ c :=\n  funext fun _ => circleMap_eq_center_iff.2 rfl\n\n"}
{"name":"circleMap_ne_center","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nhR : Ne R 0\nÎ¸ : Real\nâŠ¢ Ne (circleMap c R Î¸) c","decl":"theorem circleMap_ne_center {c : â„‚} {R : â„} (hR : R â‰  0) {Î¸ : â„} : circleMap c R Î¸ â‰  c :=\n  mt circleMap_eq_center_iff.1 hR\n\n"}
{"name":"hasDerivAt_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR Î¸ : Real\nâŠ¢ HasDerivAt (circleMap c R) (HMul.hMul (circleMap 0 R Î¸) Complex.I) Î¸","decl":"theorem hasDerivAt_circleMap (c : â„‚) (R : â„) (Î¸ : â„) :\n    HasDerivAt (circleMap c R) (circleMap 0 R Î¸ * I) Î¸ := by\n  simpa only [mul_assoc, one_mul, ofRealCLM_apply, circleMap, ofReal_one, zero_add]\n    using (((ofRealCLM.hasDerivAt (x := Î¸)).mul_const I).cexp.const_mul (R : â„‚)).const_add c\n\n/- TODO: prove `ContDiff â„ (circleMap c R)`. This needs a version of `ContDiff.mul`\nfor multiplication in a normed algebra over the base field. -/\n"}
{"name":"differentiable_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nâŠ¢ Differentiable Real (circleMap c R)","decl":"theorem differentiable_circleMap (c : â„‚) (R : â„) : Differentiable â„ (circleMap c R) := fun Î¸ =>\n  (hasDerivAt_circleMap c R Î¸).differentiableAt\n\n"}
{"name":"continuous_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nâŠ¢ Continuous (circleMap c R)","decl":"@[continuity, fun_prop]\ntheorem continuous_circleMap (c : â„‚) (R : â„) : Continuous (circleMap c R) :=\n  (differentiable_circleMap c R).continuous\n\n"}
{"name":"measurable_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nâŠ¢ Measurable (circleMap c R)","decl":"@[fun_prop, measurability]\ntheorem measurable_circleMap (c : â„‚) (R : â„) : Measurable (circleMap c R) :=\n  (continuous_circleMap c R).measurable\n\n"}
{"name":"deriv_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR Î¸ : Real\nâŠ¢ Eq (deriv (circleMap c R) Î¸) (HMul.hMul (circleMap 0 R Î¸) Complex.I)","decl":"@[simp]\ntheorem deriv_circleMap (c : â„‚) (R : â„) (Î¸ : â„) : deriv (circleMap c R) Î¸ = circleMap 0 R Î¸ * I :=\n  (hasDerivAt_circleMap _ _ _).deriv\n\n"}
{"name":"deriv_circleMap_eq_zero_iff","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR Î¸ : Real\nâŠ¢ Iff (Eq (deriv (circleMap c R) Î¸) 0) (Eq R 0)","decl":"theorem deriv_circleMap_eq_zero_iff {c : â„‚} {R : â„} {Î¸ : â„} :\n    deriv (circleMap c R) Î¸ = 0 â†” R = 0 := by simp [I_ne_zero]\n\n"}
{"name":"deriv_circleMap_ne_zero","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR Î¸ : Real\nhR : Ne R 0\nâŠ¢ Ne (deriv (circleMap c R) Î¸) 0","decl":"theorem deriv_circleMap_ne_zero {c : â„‚} {R : â„} {Î¸ : â„} (hR : R â‰  0) :\n    deriv (circleMap c R) Î¸ â‰  0 :=\n  mt deriv_circleMap_eq_zero_iff.1 hR\n\n"}
{"name":"lipschitzWith_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nâŠ¢ LipschitzWith (Real.nnabs R) (circleMap c R)","decl":"theorem lipschitzWith_circleMap (c : â„‚) (R : â„) : LipschitzWith (Real.nnabs R) (circleMap c R) :=\n  lipschitzWith_of_nnnorm_deriv_le (differentiable_circleMap _ _) fun Î¸ =>\n    NNReal.coe_le_coe.1 <| by simp\n\n"}
{"name":"continuous_circleMap_inv","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"R : Real\nz w : Complex\nhw : Membership.mem (Metric.ball z R) w\nâŠ¢ Continuous fun Î¸ => Inv.inv (HSub.hSub (circleMap z R Î¸) w)","decl":"theorem continuous_circleMap_inv {R : â„} {z w : â„‚} (hw : w âˆˆ ball z R) :\n    Continuous fun Î¸ => (circleMap z R Î¸ - w)â»Â¹ := by\n  have : âˆ€ Î¸, circleMap z R Î¸ - w â‰  0 := by\n    simp_rw [sub_ne_zero]\n    exact fun Î¸ => circleMap_ne_mem_ball hw Î¸\n  -- Porting note: was `continuity`\n  exact Continuous.invâ‚€ (by fun_prop) this\n\n"}
{"name":"circleIntegrable_const","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœ : NormedAddCommGroup E\na : E\nc : Complex\nR : Real\nâŠ¢ CircleIntegrable (fun x => a) c R","decl":"@[simp]\ntheorem circleIntegrable_const (a : E) (c : â„‚) (R : â„) : CircleIntegrable (fun _ => a) c R :=\n  intervalIntegrable_const\n\n"}
{"name":"CircleIntegrable.add","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœ : NormedAddCommGroup E\nf g : Complex â†’ E\nc : Complex\nR : Real\nhf : CircleIntegrable f c R\nhg : CircleIntegrable g c R\nâŠ¢ CircleIntegrable (HAdd.hAdd f g) c R","decl":"nonrec theorem add (hf : CircleIntegrable f c R) (hg : CircleIntegrable g c R) :\n    CircleIntegrable (f + g) c R :=\n  hf.add hg\n\n"}
{"name":"CircleIntegrable.neg","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœ : NormedAddCommGroup E\nf : Complex â†’ E\nc : Complex\nR : Real\nhf : CircleIntegrable f c R\nâŠ¢ CircleIntegrable (Neg.neg f) c R","decl":"nonrec theorem neg (hf : CircleIntegrable f c R) : CircleIntegrable (-f) c R :=\n  hf.neg\n\n"}
{"name":"CircleIntegrable.out","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\nf : Complex â†’ E\nc : Complex\nR : Real\ninstâœ : NormedSpace Complex E\nhf : CircleIntegrable f c R\nâŠ¢ IntervalIntegrable (fun Î¸ => HSMul.hSMul (deriv (circleMap c R) Î¸) (f (circleMap c R Î¸))) MeasureTheory.MeasureSpace.volume 0 (HMul.hMul 2 Real.pi)","decl":"/-- The function we actually integrate over `[0, 2Ï€]` in the definition of `circleIntegral` is\nintegrable. -/\ntheorem out [NormedSpace â„‚ E] (hf : CircleIntegrable f c R) :\n    IntervalIntegrable (fun Î¸ : â„ => deriv (circleMap c R) Î¸ â€¢ f (circleMap c R Î¸)) volume 0\n      (2 * Ï€) := by\n  simp only [CircleIntegrable, deriv_circleMap, intervalIntegrable_iff] at *\n  refine (hf.norm.const_mul |R|).mono' ?_ ?_\n  Â· exact ((continuous_circleMap _ _).aestronglyMeasurable.mul_const I).smul hf.aestronglyMeasurable\n  Â· simp [norm_smul]\n\n"}
{"name":"circleIntegrable_zero_radius","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœ : NormedAddCommGroup E\nf : Complex â†’ E\nc : Complex\nâŠ¢ CircleIntegrable f c 0","decl":"@[simp]\ntheorem circleIntegrable_zero_radius {f : â„‚ â†’ E} {c : â„‚} : CircleIntegrable f c 0 := by\n  simp [CircleIntegrable]\n\n"}
{"name":"circleIntegrable_iff","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR : Real\nâŠ¢ Iff (CircleIntegrable f c R) (IntervalIntegrable (fun Î¸ => HSMul.hSMul (deriv (circleMap c R) Î¸) (f (circleMap c R Î¸))) MeasureTheory.MeasureSpace.volume 0 (HMul.hMul 2 Real.pi))","decl":"theorem circleIntegrable_iff [NormedSpace â„‚ E] {f : â„‚ â†’ E} {c : â„‚} (R : â„) :\n    CircleIntegrable f c R â†” IntervalIntegrable (fun Î¸ : â„ =>\n      deriv (circleMap c R) Î¸ â€¢ f (circleMap c R Î¸)) volume 0 (2 * Ï€) := by\n  by_cases hâ‚€ : R = 0\n  Â· simp (config := { unfoldPartialApp := true }) [hâ‚€, const]\n  refine âŸ¨fun h => h.out, fun h => ?_âŸ©\n  simp only [CircleIntegrable, intervalIntegrable_iff, deriv_circleMap] at h âŠ¢\n  refine (h.norm.const_mul |R|â»Â¹).mono' ?_ ?_\n  Â· have H : âˆ€ {Î¸}, circleMap 0 R Î¸ * I â‰  0 := fun {Î¸} => by simp [hâ‚€, I_ne_zero]\n    simpa only [inv_smul_smulâ‚€ H]\n      using ((continuous_circleMap 0 R).aestronglyMeasurable.mul_const\n        I).aemeasurable.inv.aestronglyMeasurable.smul h.aestronglyMeasurable\n  Â· simp [norm_smul, hâ‚€]\n\n"}
{"name":"ContinuousOn.circleIntegrable'","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœ : NormedAddCommGroup E\nf : Complex â†’ E\nc : Complex\nR : Real\nhf : ContinuousOn f (Metric.sphere c (abs R))\nâŠ¢ CircleIntegrable f c R","decl":"theorem ContinuousOn.circleIntegrable' {f : â„‚ â†’ E} {c : â„‚} {R : â„}\n    (hf : ContinuousOn f (sphere c |R|)) : CircleIntegrable f c R :=\n  (hf.comp_continuous (continuous_circleMap _ _) (circleMap_mem_sphere' _ _)).intervalIntegrable _ _\n\n"}
{"name":"ContinuousOn.circleIntegrable","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœ : NormedAddCommGroup E\nf : Complex â†’ E\nc : Complex\nR : Real\nhR : LE.le 0 R\nhf : ContinuousOn f (Metric.sphere c R)\nâŠ¢ CircleIntegrable f c R","decl":"theorem ContinuousOn.circleIntegrable {f : â„‚ â†’ E} {c : â„‚} {R : â„} (hR : 0 â‰¤ R)\n    (hf : ContinuousOn f (sphere c R)) : CircleIntegrable f c R :=\n  ContinuousOn.circleIntegrable' <| (_root_.abs_of_nonneg hR).symm â–¸ hf\n\n"}
{"name":"circleIntegrable_sub_zpow_iff","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c w : Complex\nR : Real\nn : Int\nâŠ¢ Iff (CircleIntegrable (fun z => HPow.hPow (HSub.hSub z w) n) c R) (Or (Eq R 0) (Or (LE.le 0 n) (Not (Membership.mem (Metric.sphere c (abs R)) w))))","decl":"/-- The function `fun z â†¦ (z - w) ^ n`, `n : â„¤`, is circle integrable on the circle with center `c`\nand radius `|R|` if and only if `R = 0` or `0 â‰¤ n`, or `w` does not belong to this circle. -/\n@[simp]\ntheorem circleIntegrable_sub_zpow_iff {c w : â„‚} {R : â„} {n : â„¤} :\n    CircleIntegrable (fun z => (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ w âˆ‰ sphere c |R| := by\n  constructor\n  Â· intro h; contrapose! h; rcases h with âŸ¨hR, hn, hwâŸ©\n    simp only [circleIntegrable_iff R, deriv_circleMap]\n    rw [â† image_circleMap_Ioc] at hw; rcases hw with âŸ¨Î¸, hÎ¸, rflâŸ©\n    replace hÎ¸ : Î¸ âˆˆ [[0, 2 * Ï€]] := Icc_subset_uIcc (Ioc_subset_Icc_self hÎ¸)\n    refine not_intervalIntegrable_of_sub_inv_isBigO_punctured ?_ Real.two_pi_pos.ne hÎ¸\n    set f : â„ â†’ â„‚ := fun Î¸' => circleMap c R Î¸' - circleMap c R Î¸\n    have : âˆ€á¶  Î¸' in ğ“[â‰ ] Î¸, f Î¸' âˆˆ ball (0 : â„‚) 1 \\ {0} := by\n      suffices âˆ€á¶  z in ğ“[â‰ ] circleMap c R Î¸, z - circleMap c R Î¸ âˆˆ ball (0 : â„‚) 1 \\ {0} from\n        ((differentiable_circleMap c R Î¸).hasDerivAt.tendsto_punctured_nhds\n          (deriv_circleMap_ne_zero hR)).eventually this\n      filter_upwards [self_mem_nhdsWithin, mem_nhdsWithin_of_mem_nhds (ball_mem_nhds _ zero_lt_one)]\n      simp_all [dist_eq, sub_eq_zero]\n    refine (((hasDerivAt_circleMap c R Î¸).isBigO_sub.mono inf_le_left).inv_rev\n      (this.mono fun Î¸' hâ‚ hâ‚‚ => absurd hâ‚‚ hâ‚.2)).trans ?_\n    refine IsBigO.of_bound |R|â»Â¹ (this.mono fun Î¸' hÎ¸' => ?_)\n    set x := abs (f Î¸')\n    suffices xâ»Â¹ â‰¤ x ^ n by\n      simpa only [inv_mul_cancel_leftâ‚€, abs_eq_zero.not.2 hR, norm_eq_abs, map_invâ‚€,\n        Algebra.id.smul_eq_mul, map_mul, abs_circleMap_zero, abs_I, mul_one, abs_zpow, Ne,\n        not_false_iff] using this\n    have : x âˆˆ Ioo (0 : â„) 1 := by simpa [x, and_comm] using hÎ¸'\n    rw [â† zpow_neg_one]\n    refine (zpow_right_strictAntiâ‚€ this.1 this.2).le_iff_le.2 (Int.lt_add_one_iff.1 ?_); exact hn\n  Â· rintro (rfl | H)\n    exacts [circleIntegrable_zero_radius,\n      ((continuousOn_id.sub continuousOn_const).zpowâ‚€ _ fun z hz =>\n        H.symm.imp_left fun (hw : w âˆ‰ sphere c |R|) =>\n          sub_ne_zero.2 <| ne_of_mem_of_not_mem hz hw).circleIntegrable']\n\n"}
{"name":"circleIntegrable_sub_inv_iff","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c w : Complex\nR : Real\nâŠ¢ Iff (CircleIntegrable (fun z => Inv.inv (HSub.hSub z w)) c R) (Or (Eq R 0) (Not (Membership.mem (Metric.sphere c (abs R)) w)))","decl":"@[simp]\ntheorem circleIntegrable_sub_inv_iff {c w : â„‚} {R : â„} :\n    CircleIntegrable (fun z => (z - w)â»Â¹) c R â†” R = 0 âˆ¨ w âˆ‰ sphere c |R| := by\n  simp only [â† zpow_neg_one, circleIntegrable_sub_zpow_iff]; norm_num\n\n"}
{"name":"circleIntegral_def_Icc","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR : Real\nâŠ¢ Eq (circleIntegral (fun z => f z) c R) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc 0 (HMul.hMul 2 Real.pi))) fun Î¸ => HSMul.hSMul (deriv (circleMap c R) Î¸) (f (circleMap c R Î¸)))","decl":"theorem circleIntegral_def_Icc (f : â„‚ â†’ E) (c : â„‚) (R : â„) :\n    (âˆ® z in C(c, R), f z) = âˆ« Î¸ in Icc 0 (2 * Ï€),\n    deriv (circleMap c R) Î¸ â€¢ f (circleMap c R Î¸) := by\n  rw [circleIntegral, intervalIntegral.integral_of_le Real.two_pi_pos.le,\n    Measure.restrict_congr_set Ioc_ae_eq_Icc]\n\n"}
{"name":"circleIntegral.integral_radius_zero","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nâŠ¢ Eq (circleIntegral (fun z => f z) c 0) 0","decl":"@[simp]\ntheorem integral_radius_zero (f : â„‚ â†’ E) (c : â„‚) : (âˆ® z in C(c, 0), f z) = 0 := by\n  simp (config := { unfoldPartialApp := true }) [circleIntegral, const]\n\n"}
{"name":"circleIntegral.integral_congr","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf g : Complex â†’ E\nc : Complex\nR : Real\nhR : LE.le 0 R\nh : Set.EqOn f g (Metric.sphere c R)\nâŠ¢ Eq (circleIntegral (fun z => f z) c R) (circleIntegral (fun z => g z) c R)","decl":"theorem integral_congr {f g : â„‚ â†’ E} {c : â„‚} {R : â„} (hR : 0 â‰¤ R) (h : EqOn f g (sphere c R)) :\n    (âˆ® z in C(c, R), f z) = âˆ® z in C(c, R), g z :=\n  intervalIntegral.integral_congr fun Î¸ _ => by simp only [h (circleMap_mem_sphere _ hR _)]\n\n"}
{"name":"circleIntegral.integral_sub_inv_smul_sub_smul","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc w : Complex\nR : Real\nâŠ¢ Eq (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z w)) (HSMul.hSMul (HSub.hSub z w) (f z))) c R) (circleIntegral (fun z => f z) c R)","decl":"theorem integral_sub_inv_smul_sub_smul (f : â„‚ â†’ E) (c w : â„‚) (R : â„) :\n    (âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ (z - w) â€¢ f z) = âˆ® z in C(c, R), f z := by\n  rcases eq_or_ne R 0 with (rfl | hR); Â· simp only [integral_radius_zero]\n  have : (circleMap c R â»Â¹' {w}).Countable := (countable_singleton _).preimage_circleMap c hR\n  refine intervalIntegral.integral_congr_ae ((this.ae_not_mem _).mono fun Î¸ hÎ¸ _' => ?_)\n  change circleMap c R Î¸ â‰  w at hÎ¸\n  simp only [inv_smul_smulâ‚€ (sub_ne_zero.2 <| hÎ¸)]\n\n"}
{"name":"circleIntegral.integral_undef","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR : Real\nhf : Not (CircleIntegrable f c R)\nâŠ¢ Eq (circleIntegral (fun z => f z) c R) 0","decl":"theorem integral_undef {f : â„‚ â†’ E} {c : â„‚} {R : â„} (hf : Â¬CircleIntegrable f c R) :\n    (âˆ® z in C(c, R), f z) = 0 :=\n  intervalIntegral.integral_undef (mt (circleIntegrable_iff R).mpr hf)\n\n"}
{"name":"circleIntegral.integral_sub","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf g : Complex â†’ E\nc : Complex\nR : Real\nhf : CircleIntegrable f c R\nhg : CircleIntegrable g c R\nâŠ¢ Eq (circleIntegral (fun z => HSub.hSub (f z) (g z)) c R) (HSub.hSub (circleIntegral (fun z => f z) c R) (circleIntegral (fun z => g z) c R))","decl":"theorem integral_sub {f g : â„‚ â†’ E} {c : â„‚} {R : â„} (hf : CircleIntegrable f c R)\n    (hg : CircleIntegrable g c R) :\n    (âˆ® z in C(c, R), f z - g z) = (âˆ® z in C(c, R), f z) - âˆ® z in C(c, R), g z := by\n  simp only [circleIntegral, smul_sub, intervalIntegral.integral_sub hf.out hg.out]\n\n"}
{"name":"circleIntegral.norm_integral_le_of_norm_le_const'","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR C : Real\nhf : âˆ€ (z : Complex), Membership.mem (Metric.sphere c (abs R)) z â†’ LE.le (Norm.norm (f z)) C\nâŠ¢ LE.le (Norm.norm (circleIntegral (fun z => f z) c R)) (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) (abs R)) C)","decl":"theorem norm_integral_le_of_norm_le_const' {f : â„‚ â†’ E} {c : â„‚} {R C : â„}\n    (hf : âˆ€ z âˆˆ sphere c |R|, â€–f zâ€– â‰¤ C) : â€–âˆ® z in C(c, R), f zâ€– â‰¤ 2 * Ï€ * |R| * C :=\n  calc\n    â€–âˆ® z in C(c, R), f zâ€– â‰¤ |R| * C * |2 * Ï€ - 0| :=\n      intervalIntegral.norm_integral_le_of_norm_le_const fun Î¸ _ =>\n        calc\n          â€–deriv (circleMap c R) Î¸ â€¢ f (circleMap c R Î¸)â€– = |R| * â€–f (circleMap c R Î¸)â€– := by\n            simp [norm_smul]\n          _ â‰¤ |R| * C :=\n            mul_le_mul_of_nonneg_left (hf _ <| circleMap_mem_sphere' _ _ _) (abs_nonneg _)\n    _ = 2 * Ï€ * |R| * C := by rw [sub_zero, _root_.abs_of_pos Real.two_pi_pos]; ac_rfl\n\n"}
{"name":"circleIntegral.norm_integral_le_of_norm_le_const","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR C : Real\nhR : LE.le 0 R\nhf : âˆ€ (z : Complex), Membership.mem (Metric.sphere c R) z â†’ LE.le (Norm.norm (f z)) C\nâŠ¢ LE.le (Norm.norm (circleIntegral (fun z => f z) c R)) (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) R) C)","decl":"theorem norm_integral_le_of_norm_le_const {f : â„‚ â†’ E} {c : â„‚} {R C : â„} (hR : 0 â‰¤ R)\n    (hf : âˆ€ z âˆˆ sphere c R, â€–f zâ€– â‰¤ C) : â€–âˆ® z in C(c, R), f zâ€– â‰¤ 2 * Ï€ * R * C :=\n  have : |R| = R := abs_of_nonneg hR\n  calc\n    â€–âˆ® z in C(c, R), f zâ€– â‰¤ 2 * Ï€ * |R| * C := norm_integral_le_of_norm_le_const' <| by rwa [this]\n    _ = 2 * Ï€ * R * C := by rw [this]\n\n"}
{"name":"circleIntegral.norm_two_pi_i_inv_smul_integral_le_of_norm_le_const","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR C : Real\nhR : LE.le 0 R\nhf : âˆ€ (z : Complex), Membership.mem (Metric.sphere c R) z â†’ LE.le (Norm.norm (f z)) C\nâŠ¢ LE.le (Norm.norm (HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I)) (circleIntegral (fun z => f z) c R))) (HMul.hMul R C)","decl":"theorem norm_two_pi_i_inv_smul_integral_le_of_norm_le_const {f : â„‚ â†’ E} {c : â„‚} {R C : â„}\n    (hR : 0 â‰¤ R) (hf : âˆ€ z âˆˆ sphere c R, â€–f zâ€– â‰¤ C) :\n    â€–(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), f zâ€– â‰¤ R * C := by\n  have : â€–(2 * Ï€ * I : â„‚)â»Â¹â€– = (2 * Ï€)â»Â¹ := by simp [Real.pi_pos.le]\n  rw [norm_smul, this, â† div_eq_inv_mul, div_le_iffâ‚€ Real.two_pi_pos, mul_comm (R * C), â† mul_assoc]\n  exact norm_integral_le_of_norm_le_const hR hf\n\n"}
{"name":"circleIntegral.norm_integral_lt_of_norm_le_const_of_lt","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR C : Real\nhR : LT.lt 0 R\nhc : ContinuousOn f (Metric.sphere c R)\nhf : âˆ€ (z : Complex), Membership.mem (Metric.sphere c R) z â†’ LE.le (Norm.norm (f z)) C\nhlt : Exists fun z => And (Membership.mem (Metric.sphere c R) z) (LT.lt (Norm.norm (f z)) C)\nâŠ¢ LT.lt (Norm.norm (circleIntegral (fun z => f z) c R)) (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) R) C)","decl":"/-- If `f` is continuous on the circle `|z - c| = R`, `R > 0`, the `â€–f zâ€–` is less than or equal to\n`C : â„` on this circle, and this norm is strictly less than `C` at some point `z` of the circle,\nthen `â€–âˆ® z in C(c, R), f zâ€– < 2 * Ï€ * R * C`. -/\ntheorem norm_integral_lt_of_norm_le_const_of_lt {f : â„‚ â†’ E} {c : â„‚} {R C : â„} (hR : 0 < R)\n    (hc : ContinuousOn f (sphere c R)) (hf : âˆ€ z âˆˆ sphere c R, â€–f zâ€– â‰¤ C)\n    (hlt : âˆƒ z âˆˆ sphere c R, â€–f zâ€– < C) : â€–âˆ® z in C(c, R), f zâ€– < 2 * Ï€ * R * C := by\n  rw [â† _root_.abs_of_pos hR, â† image_circleMap_Ioc] at hlt\n  rcases hlt with âŸ¨_, âŸ¨Î¸â‚€, hmem, rflâŸ©, hltâŸ©\n  calc\n    â€–âˆ® z in C(c, R), f zâ€– â‰¤ âˆ« Î¸ in (0)..2 * Ï€, â€–deriv (circleMap c R) Î¸ â€¢ f (circleMap c R Î¸)â€– :=\n      intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le\n    _ < âˆ« _ in (0)..2 * Ï€, R * C := by\n      simp only [norm_smul, deriv_circleMap, norm_eq_abs, map_mul, abs_I, mul_one,\n        abs_circleMap_zero, abs_of_pos hR]\n      refine intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt\n          Real.two_pi_pos ?_ continuousOn_const (fun Î¸ _ => ?_) âŸ¨Î¸â‚€, Ioc_subset_Icc_self hmem, ?_âŸ©\n      Â· exact continuousOn_const.mul (hc.comp (continuous_circleMap _ _).continuousOn fun Î¸ _ =>\n          circleMap_mem_sphere _ hR.le _).norm\n      Â· exact mul_le_mul_of_nonneg_left (hf _ <| circleMap_mem_sphere _ hR.le _) hR.le\n      Â· exact (mul_lt_mul_left hR).2 hlt\n    _ = 2 * Ï€ * R * C := by simp [mul_assoc]; ring\n\n"}
{"name":"circleIntegral.integral_smul","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Complex E\nğ•œ : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : SMulCommClass ğ•œ Complex E\na : ğ•œ\nf : Complex â†’ E\nc : Complex\nR : Real\nâŠ¢ Eq (circleIntegral (fun z => HSMul.hSMul a (f z)) c R) (HSMul.hSMul a (circleIntegral (fun z => f z) c R))","decl":"@[simp]\ntheorem integral_smul {ğ•œ : Type*} [RCLike ğ•œ] [NormedSpace ğ•œ E] [SMulCommClass ğ•œ â„‚ E] (a : ğ•œ)\n    (f : â„‚ â†’ E) (c : â„‚) (R : â„) : (âˆ® z in C(c, R), a â€¢ f z) = a â€¢ âˆ® z in C(c, R), f z := by\n  simp only [circleIntegral, â† smul_comm a (_ : â„‚) (_ : E), intervalIntegral.integral_smul]\n\n"}
{"name":"circleIntegral.integral_smul_const","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nf : Complex â†’ Complex\na : E\nc : Complex\nR : Real\nâŠ¢ Eq (circleIntegral (fun z => HSMul.hSMul (f z) a) c R) (HSMul.hSMul (circleIntegral (fun z => f z) c R) a)","decl":"@[simp]\ntheorem integral_smul_const [CompleteSpace E] (f : â„‚ â†’ â„‚) (a : E) (c : â„‚) (R : â„) :\n    (âˆ® z in C(c, R), f z â€¢ a) = (âˆ® z in C(c, R), f z) â€¢ a := by\n  simp only [circleIntegral, intervalIntegral.integral_smul_const, â† smul_assoc]\n\n"}
{"name":"circleIntegral.integral_const_mul","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"a : Complex\nf : Complex â†’ Complex\nc : Complex\nR : Real\nâŠ¢ Eq (circleIntegral (fun z => HMul.hMul a (f z)) c R) (HMul.hMul a (circleIntegral (fun z => f z) c R))","decl":"@[simp]\ntheorem integral_const_mul (a : â„‚) (f : â„‚ â†’ â„‚) (c : â„‚) (R : â„) :\n    (âˆ® z in C(c, R), a * f z) = a * âˆ® z in C(c, R), f z :=\n  integral_smul a f c R\n\n"}
{"name":"circleIntegral.integral_sub_center_inv","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nhR : Ne R 0\nâŠ¢ Eq (circleIntegral (fun z => Inv.inv (HSub.hSub z c)) c R) (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I)","decl":"@[simp]\ntheorem integral_sub_center_inv (c : â„‚) {R : â„} (hR : R â‰  0) :\n    (âˆ® z in C(c, R), (z - c)â»Â¹) = 2 * Ï€ * I := by\n  simp [circleIntegral, â† div_eq_mul_inv, mul_div_cancel_leftâ‚€ _ (circleMap_ne_center hR),\n    -- Porting note: `simp` didn't need a hint to apply `integral_const` here\n    intervalIntegral.integral_const I]\n\n"}
{"name":"circleIntegral.integral_eq_zero_of_hasDerivWithinAt'","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nf f' : Complex â†’ E\nc : Complex\nR : Real\nh : âˆ€ (z : Complex), Membership.mem (Metric.sphere c (abs R)) z â†’ HasDerivWithinAt f (f' z) (Metric.sphere c (abs R)) z\nâŠ¢ Eq (circleIntegral (fun z => f' z) c R) 0","decl":"/-- If `f' : â„‚ â†’ E` is a derivative of a complex differentiable function on the circle\n`Metric.sphere c |R|`, then `âˆ® z in C(c, R), f' z = 0`. -/\ntheorem integral_eq_zero_of_hasDerivWithinAt' [CompleteSpace E] {f f' : â„‚ â†’ E} {c : â„‚} {R : â„}\n    (h : âˆ€ z âˆˆ sphere c |R|, HasDerivWithinAt f (f' z) (sphere c |R|) z) :\n    (âˆ® z in C(c, R), f' z) = 0 := by\n  by_cases hi : CircleIntegrable f' c R\n  Â· rw [â† sub_eq_zero.2 ((periodic_circleMap c R).comp f).eq]\n    refine intervalIntegral.integral_eq_sub_of_hasDerivAt (fun Î¸ _ => ?_) hi.out\n    exact (h _ (circleMap_mem_sphere' _ _ _)).scomp_hasDerivAt Î¸\n      (differentiable_circleMap _ _ _).hasDerivAt (circleMap_mem_sphere' _ _)\n  Â· exact integral_undef hi\n\n"}
{"name":"circleIntegral.integral_eq_zero_of_hasDerivWithinAt","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Complex E\ninstâœ : CompleteSpace E\nf f' : Complex â†’ E\nc : Complex\nR : Real\nhR : LE.le 0 R\nh : âˆ€ (z : Complex), Membership.mem (Metric.sphere c R) z â†’ HasDerivWithinAt f (f' z) (Metric.sphere c R) z\nâŠ¢ Eq (circleIntegral (fun z => f' z) c R) 0","decl":"/-- If `f' : â„‚ â†’ E` is a derivative of a complex differentiable function on the circle\n`Metric.sphere c R`, then `âˆ® z in C(c, R), f' z = 0`. -/\ntheorem integral_eq_zero_of_hasDerivWithinAt [CompleteSpace E]\n    {f f' : â„‚ â†’ E} {c : â„‚} {R : â„} (hR : 0 â‰¤ R)\n    (h : âˆ€ z âˆˆ sphere c R, HasDerivWithinAt f (f' z) (sphere c R) z) : (âˆ® z in C(c, R), f' z) = 0 :=\n  integral_eq_zero_of_hasDerivWithinAt' <| (_root_.abs_of_nonneg hR).symm â–¸ h\n\n"}
{"name":"circleIntegral.integral_sub_zpow_of_undef","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"n : Int\nc w : Complex\nR : Real\nhn : LT.lt n 0\nhw : Membership.mem (Metric.sphere c (abs R)) w\nâŠ¢ Eq (circleIntegral (fun z => HPow.hPow (HSub.hSub z w) n) c R) 0","decl":"/-- If `n < 0` and `|w - c| = |R|`, then `(z - w) ^ n` is not circle integrable on the circle with\ncenter `c` and radius `|R|`, so the integral `âˆ® z in C(c, R), (z - w) ^ n` is equal to zero. -/\ntheorem integral_sub_zpow_of_undef {n : â„¤} {c w : â„‚} {R : â„} (hn : n < 0)\n    (hw : w âˆˆ sphere c |R|) : (âˆ® z in C(c, R), (z - w) ^ n) = 0 := by\n  rcases eq_or_ne R 0 with (rfl | h0)\n  Â· apply integral_radius_zero\n  Â· apply integral_undef\n    simpa [circleIntegrable_sub_zpow_iff, *, not_or]\n\n"}
{"name":"circleIntegral.integral_sub_zpow_of_ne","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"n : Int\nhn : Ne n (-1)\nc w : Complex\nR : Real\nâŠ¢ Eq (circleIntegral (fun z => HPow.hPow (HSub.hSub z w) n) c R) 0","decl":"/-- If `n â‰  -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem integral_sub_zpow_of_ne {n : â„¤} (hn : n â‰  -1) (c w : â„‚) (R : â„) :\n    (âˆ® z in C(c, R), (z - w) ^ n) = 0 := by\n  rcases em (w âˆˆ sphere c |R| âˆ§ n < -1) with (âŸ¨hw, hnâŸ© | H)\n  Â· exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw\n  push_neg at H\n  have hd : âˆ€ z, z â‰  w âˆ¨ -1 â‰¤ n â†’\n      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by\n    intro z hne\n    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z\n      ((hasDerivAt_id z).sub_const w)).div_const _ using 1\n    Â· have hn' : (n + 1 : â„‚) â‰  0 := by\n        rwa [Ne, â† eq_neg_iff_add_eq_zero, â† Int.cast_one, â† Int.cast_neg, Int.cast_inj]\n      simp [mul_assoc, mul_div_cancel_leftâ‚€ _ hn']\n    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]\n  refine integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z ?_).hasDerivWithinAt\n  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h â–¸ hz\n\n"}
{"name":"cauchyPowerSeries_apply","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR : Real\nn : Nat\nw : Complex\nâŠ¢ Eq ((cauchyPowerSeries f c R n) fun x => w) (HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I)) (circleIntegral (fun z => HSMul.hSMul (HPow.hPow (HDiv.hDiv w (HSub.hSub z c)) n) (HSMul.hSMul (Inv.inv (HSub.hSub z c)) (f z))) c R))","decl":"theorem cauchyPowerSeries_apply (f : â„‚ â†’ E) (c : â„‚) (R : â„) (n : â„•) (w : â„‚) :\n    (cauchyPowerSeries f c R n fun _ => w) =\n      (2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z := by\n  simp only [cauchyPowerSeries, ContinuousMultilinearMap.mkPiRing_apply, Fin.prod_const,\n    div_eq_mul_inv, mul_pow, mul_smul, circleIntegral.integral_smul]\n  rw [â† smul_comm (w ^ n)]\n\n"}
{"name":"norm_cauchyPowerSeries_le","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR : Real\nn : Nat\nâŠ¢ LE.le (Norm.norm (cauchyPowerSeries f c R n)) (HMul.hMul (HMul.hMul (Inv.inv (HMul.hMul 2 Real.pi)) (intervalIntegral (fun Î¸ => Norm.norm (f (circleMap c R Î¸))) 0 (HMul.hMul 2 Real.pi) MeasureTheory.MeasureSpace.volume)) (HPow.hPow (Inv.inv (abs R)) n))","decl":"theorem norm_cauchyPowerSeries_le (f : â„‚ â†’ E) (c : â„‚) (R : â„) (n : â„•) :\n    â€–cauchyPowerSeries f c R nâ€– â‰¤\n      ((2 * Ï€)â»Â¹ * âˆ« Î¸ : â„ in (0)..2 * Ï€, â€–f (circleMap c R Î¸)â€–) * |R|â»Â¹ ^ n :=\n  calc â€–cauchyPowerSeries f c R nâ€–\n    _ = (2 * Ï€)â»Â¹ * â€–âˆ® z in C(c, R), (z - c)â»Â¹ ^ n â€¢ (z - c)â»Â¹ â€¢ f zâ€– := by\n      simp [cauchyPowerSeries, norm_smul, Real.pi_pos.le]\n    _ â‰¤ (2 * Ï€)â»Â¹ * âˆ« Î¸ in (0)..2 * Ï€, â€–deriv (circleMap c R) Î¸ â€¢\n        (circleMap c R Î¸ - c)â»Â¹ ^ n â€¢ (circleMap c R Î¸ - c)â»Â¹ â€¢ f (circleMap c R Î¸)â€– :=\n      (mul_le_mul_of_nonneg_left\n        (intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le)\n        (by simp [Real.pi_pos.le]))\n    _ = (2 * Ï€)â»Â¹ *\n        (|R|â»Â¹ ^ n * (|R| * (|R|â»Â¹ * âˆ« x : â„ in (0)..2 * Ï€, â€–f (circleMap c R x)â€–))) := by\n      simp [norm_smul, mul_left_comm |R|]\n    _ â‰¤ ((2 * Ï€)â»Â¹ * âˆ« Î¸ : â„ in (0)..2 * Ï€, â€–f (circleMap c R Î¸)â€–) * |R|â»Â¹ ^ n := by\n      rcases eq_or_ne R 0 with (rfl | hR)\n      Â· cases n <;> simp [-mul_inv_rev]\n        rw [â† mul_assoc, inv_mul_cancelâ‚€ (Real.two_pi_pos.ne.symm), one_mul]\n        apply norm_nonneg\n      Â· rw [mul_inv_cancel_leftâ‚€, mul_assoc, mul_comm (|R|â»Â¹ ^ n)]\n        rwa [Ne, _root_.abs_eq_zero]\n\n"}
{"name":"le_radius_cauchyPowerSeries","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR : NNReal\nâŠ¢ LE.le (â†‘R) (cauchyPowerSeries f c â†‘R).radius","decl":"theorem le_radius_cauchyPowerSeries (f : â„‚ â†’ E) (c : â„‚) (R : â„â‰¥0) :\n    â†‘R â‰¤ (cauchyPowerSeries f c R).radius := by\n  refine\n    (cauchyPowerSeries f c R).le_radius_of_bound\n      ((2 * Ï€)â»Â¹ * âˆ« Î¸ : â„ in (0)..2 * Ï€, â€–f (circleMap c R Î¸)â€–) fun n => ?_\n  refine (mul_le_mul_of_nonneg_right (norm_cauchyPowerSeries_le _ _ _ _)\n    (pow_nonneg R.coe_nonneg _)).trans ?_\n  rw [_root_.abs_of_nonneg R.coe_nonneg]\n  rcases eq_or_ne (R ^ n : â„) 0 with hR | hR\n  Â· rw_mod_cast [hR, mul_zero]\n    exact mul_nonneg (inv_nonneg.2 Real.two_pi_pos.le)\n      (intervalIntegral.integral_nonneg Real.two_pi_pos.le fun _ _ => norm_nonneg _)\n  Â· rw [inv_pow]\n    have : (R : â„) ^ n â‰  0 := by norm_cast at hR âŠ¢\n    rw [inv_mul_cancel_rightâ‚€ this]\n\n"}
{"name":"hasSum_two_pi_I_cauchyPowerSeries_integral","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR : Real\nw : Complex\nhf : CircleIntegrable f c R\nhw : LT.lt (Complex.abs w) R\nâŠ¢ HasSum (fun n => circleIntegral (fun z => HSMul.hSMul (HPow.hPow (HDiv.hDiv w (HSub.hSub z c)) n) (HSMul.hSMul (Inv.inv (HSub.hSub z c)) (f z))) c R) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z (HAdd.hAdd c w))) (f z)) c R)","decl":"/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\nby `2Ï€I` converges to the integral `âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open disc\n`Metric.ball c R`. -/\ntheorem hasSum_two_pi_I_cauchyPowerSeries_integral {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚}\n    (hf : CircleIntegrable f c R) (hw : abs w < R) :\n    HasSum (fun n : â„• => âˆ® z in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z)\n      (âˆ® z in C(c, R), (z - (c + w))â»Â¹ â€¢ f z) := by\n  have hR : 0 < R := (Complex.abs.nonneg w).trans_lt hw\n  have hwR : abs w / R âˆˆ Ico (0 : â„) 1 :=\n    âŸ¨div_nonneg (Complex.abs.nonneg w) hR.le, (div_lt_one hR).2 hwâŸ©\n  refine intervalIntegral.hasSum_integral_of_dominated_convergence\n      (fun n Î¸ => â€–f (circleMap c R Î¸)â€– * (abs w / R) ^ n) (fun n => ?_) (fun n => ?_) ?_ ?_ ?_\n  Â· simp only [deriv_circleMap]\n    apply_rules [AEStronglyMeasurable.smul, hf.def'.1] <;> apply Measurable.aestronglyMeasurable\n    Â· fun_prop\n    Â· fun_prop\n    Â· fun_prop\n  Â· simp [norm_smul, abs_of_pos hR, mul_left_comm R, inv_mul_cancel_leftâ‚€ hR.ne', mul_comm â€–_â€–]\n  Â· exact Eventually.of_forall fun _ _ => (summable_geometric_of_lt_one hwR.1 hwR.2).mul_left _\n  Â· simpa only [tsum_mul_left, tsum_geometric_of_lt_one hwR.1 hwR.2] using\n      hf.norm.mul_continuousOn continuousOn_const\n  Â· refine Eventually.of_forall fun Î¸ _ => HasSum.const_smul _ ?_\n    simp only [smul_smul]\n    refine HasSum.smul_const ?_ _\n    have : â€–w / (circleMap c R Î¸ - c)â€– < 1 := by simpa [abs_of_pos hR] using hwR.2\n    convert (hasSum_geometric_of_norm_lt_one this).mul_right _ using 1\n    simp [â† sub_sub, â† mul_inv, sub_mul, div_mul_cancelâ‚€ _ (circleMap_ne_center hR.ne')]\n\n"}
{"name":"hasSum_cauchyPowerSeries_integral","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR : Real\nw : Complex\nhf : CircleIntegrable f c R\nhw : LT.lt (Complex.abs w) R\nâŠ¢ HasSum (fun n => (cauchyPowerSeries f c R n) fun x => w) (HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I)) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z (HAdd.hAdd c w))) (f z)) c R))","decl":"/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\nconverges to the Cauchy integral `(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open\ndisc `Metric.ball c R`. -/\ntheorem hasSum_cauchyPowerSeries_integral {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚}\n    (hf : CircleIntegrable f c R) (hw : abs w < R) :\n    HasSum (fun n => cauchyPowerSeries f c R n fun _ => w)\n      ((2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - (c + w))â»Â¹ â€¢ f z) := by\n  simp only [cauchyPowerSeries_apply]\n  exact (hasSum_two_pi_I_cauchyPowerSeries_integral hf hw).const_smul _\n\n"}
{"name":"sum_cauchyPowerSeries_eq_integral","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR : Real\nw : Complex\nhf : CircleIntegrable f c R\nhw : LT.lt (Complex.abs w) R\nâŠ¢ Eq ((cauchyPowerSeries f c R).sum w) (HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I)) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z (HAdd.hAdd c w))) (f z)) c R))","decl":"/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\nconverges to the Cauchy integral `(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open\ndisc `Metric.ball c R`. -/\ntheorem sum_cauchyPowerSeries_eq_integral {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚}\n    (hf : CircleIntegrable f c R) (hw : abs w < R) :\n    (cauchyPowerSeries f c R).sum w = (2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - (c + w))â»Â¹ â€¢ f z :=\n  (hasSum_cauchyPowerSeries_integral hf hw).tsum_eq\n\n"}
{"name":"hasFPowerSeriesOn_cauchy_integral","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Complex E\nf : Complex â†’ E\nc : Complex\nR : NNReal\nhf : CircleIntegrable f c â†‘R\nhR : LT.lt 0 R\nâŠ¢ HasFPowerSeriesOnBall (fun w => HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I)) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z w)) (f z)) c â†‘R)) (cauchyPowerSeries f c â†‘R) c â†‘R","decl":"/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\nconverges to the Cauchy integral `(2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z` on the open\ndisc `Metric.ball c R`. -/\ntheorem hasFPowerSeriesOn_cauchy_integral {f : â„‚ â†’ E} {c : â„‚} {R : â„â‰¥0}\n    (hf : CircleIntegrable f c R) (hR : 0 < R) :\n    HasFPowerSeriesOnBall (fun w => (2 * Ï€ * I : â„‚)â»Â¹ â€¢ âˆ® z in C(c, R), (z - w)â»Â¹ â€¢ f z)\n      (cauchyPowerSeries f c R) c R :=\n  { r_le := le_radius_cauchyPowerSeries _ _ _\n    r_pos := ENNReal.coe_pos.2 hR\n    hasSum := fun hy â†¦ hasSum_cauchyPowerSeries_integral hf <| by simpa using hy }\n\n"}
{"name":"circleIntegral.integral_sub_inv_of_mem_ball","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c w : Complex\nR : Real\nhw : Membership.mem (Metric.ball c R) w\nâŠ¢ Eq (circleIntegral (fun z => Inv.inv (HSub.hSub z w)) c R) (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I)","decl":"/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2Ï€i$ whenever $|w-c| < R$. -/\ntheorem integral_sub_inv_of_mem_ball {c w : â„‚} {R : â„} (hw : w âˆˆ ball c R) :\n    (âˆ® z in C(c, R), (z - w)â»Â¹) = 2 * Ï€ * I := by\n  have hR : 0 < R := dist_nonneg.trans_lt hw\n  suffices H : HasSum (fun n : â„• => âˆ® z in C(c, R), ((w - c) / (z - c)) ^ n * (z - c)â»Â¹)\n      (2 * Ï€ * I) by\n    have A : CircleIntegrable (fun _ => (1 : â„‚)) c R := continuousOn_const.circleIntegrable'\n    refine (H.unique ?_).symm\n    simpa only [smul_eq_mul, mul_one, add_sub_cancel] using\n      hasSum_two_pi_I_cauchyPowerSeries_integral A hw\n  have H : âˆ€ n : â„•, n â‰  0 â†’ (âˆ® z in C(c, R), (z - c) ^ (-n - 1 : â„¤)) = 0 := by\n    refine fun n hn => integral_sub_zpow_of_ne ?_ _ _ _; simpa\n  have : (âˆ® z in C(c, R), ((w - c) / (z - c)) ^ 0 * (z - c)â»Â¹) = 2 * Ï€ * I := by simp [hR.ne']\n  refine this â–¸ hasSum_single _ fun n hn => ?_\n  simp only [div_eq_mul_inv, mul_pow, integral_const_mul, mul_assoc]\n  rw [(integral_congr hR.le fun z hz => _).trans (H n hn), mul_zero]\n  intro z _\n  rw [â† pow_succ, â† zpow_natCast, inv_zpow, â† zpow_neg, Int.ofNat_succ, neg_add,\n    sub_eq_add_neg _ (1 : â„¤)]\n\n"}
