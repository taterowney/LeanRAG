{"name":"periodic_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\n⊢ Function.Periodic (circleMap c R) (HMul.hMul 2 Real.pi)","decl":"/-- `circleMap` is `2π`-periodic. -/\ntheorem periodic_circleMap (c : ℂ) (R : ℝ) : Periodic (circleMap c R) (2 * π) := fun θ => by\n  simp [circleMap, add_mul, exp_periodic _]\n\n"}
{"name":"Set.Countable.preimage_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"s : Set Complex\nhs : s.Countable\nc : Complex\nR : Real\nhR : Ne R 0\n⊢ (Set.preimage (circleMap c R) s).Countable","decl":"theorem Set.Countable.preimage_circleMap {s : Set ℂ} (hs : s.Countable) (c : ℂ) {R : ℝ}\n    (hR : R ≠ 0) : (circleMap c R ⁻¹' s).Countable :=\n  show (((↑) : ℝ → ℂ) ⁻¹' ((· * I) ⁻¹'\n      (exp ⁻¹' ((R * ·) ⁻¹' ((c + ·) ⁻¹' s))))).Countable from\n    (((hs.preimage (add_right_injective _)).preimage <|\n      mul_right_injective₀ <| ofReal_ne_zero.2 hR).preimage_cexp.preimage <|\n        mul_left_injective₀ I_ne_zero).preimage ofReal_injective\n\n"}
{"name":"circleMap_sub_center","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR θ : Real\n⊢ Eq (HSub.hSub (circleMap c R θ) c) (circleMap 0 R θ)","decl":"@[simp]\ntheorem circleMap_sub_center (c : ℂ) (R : ℝ) (θ : ℝ) : circleMap c R θ - c = circleMap 0 R θ := by\n  simp [circleMap]\n\n"}
{"name":"circleMap_zero","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"R θ : Real\n⊢ Eq (circleMap 0 R θ) (HMul.hMul (↑R) (Complex.exp (HMul.hMul (↑θ) Complex.I)))","decl":"theorem circleMap_zero (R θ : ℝ) : circleMap 0 R θ = R * exp (θ * I) :=\n  zero_add _\n\n"}
{"name":"abs_circleMap_zero","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"R θ : Real\n⊢ Eq (Complex.abs (circleMap 0 R θ)) (abs R)","decl":"@[simp]\ntheorem abs_circleMap_zero (R : ℝ) (θ : ℝ) : abs (circleMap 0 R θ) = |R| := by simp [circleMap]\n\n"}
{"name":"circleMap_mem_sphere'","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR θ : Real\n⊢ Membership.mem (Metric.sphere c (abs R)) (circleMap c R θ)","decl":"theorem circleMap_mem_sphere' (c : ℂ) (R : ℝ) (θ : ℝ) : circleMap c R θ ∈ sphere c |R| := by simp\n\n"}
{"name":"circleMap_mem_sphere","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nhR : LE.le 0 R\nθ : Real\n⊢ Membership.mem (Metric.sphere c R) (circleMap c R θ)","decl":"theorem circleMap_mem_sphere (c : ℂ) {R : ℝ} (hR : 0 ≤ R) (θ : ℝ) :\n    circleMap c R θ ∈ sphere c R := by\n  simpa only [_root_.abs_of_nonneg hR] using circleMap_mem_sphere' c R θ\n\n"}
{"name":"circleMap_mem_closedBall","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nhR : LE.le 0 R\nθ : Real\n⊢ Membership.mem (Metric.closedBall c R) (circleMap c R θ)","decl":"theorem circleMap_mem_closedBall (c : ℂ) {R : ℝ} (hR : 0 ≤ R) (θ : ℝ) :\n    circleMap c R θ ∈ closedBall c R :=\n  sphere_subset_closedBall (circleMap_mem_sphere c hR θ)\n\n"}
{"name":"circleMap_not_mem_ball","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR θ : Real\n⊢ Not (Membership.mem (Metric.ball c R) (circleMap c R θ))","decl":"theorem circleMap_not_mem_ball (c : ℂ) (R : ℝ) (θ : ℝ) : circleMap c R θ ∉ ball c R := by\n  simp [dist_eq, le_abs_self]\n\n"}
{"name":"circleMap_ne_mem_ball","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nw : Complex\nhw : Membership.mem (Metric.ball c R) w\nθ : Real\n⊢ Ne (circleMap c R θ) w","decl":"theorem circleMap_ne_mem_ball {c : ℂ} {R : ℝ} {w : ℂ} (hw : w ∈ ball c R) (θ : ℝ) :\n    circleMap c R θ ≠ w :=\n  (ne_of_mem_of_not_mem hw (circleMap_not_mem_ball _ _ _)).symm\n\n"}
{"name":"range_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\n⊢ Eq (Set.range (circleMap c R)) (Metric.sphere c (abs R))","decl":"/-- The range of `circleMap c R` is the circle with center `c` and radius `|R|`. -/\n@[simp]\ntheorem range_circleMap (c : ℂ) (R : ℝ) : range (circleMap c R) = sphere c |R| :=\n  calc\n    range (circleMap c R) = c +ᵥ R • range fun θ : ℝ => exp (θ * I) := by\n      simp (config := { unfoldPartialApp := true }) only [← image_vadd, ← image_smul, ← range_comp,\n        vadd_eq_add, circleMap, Function.comp_def, real_smul]\n    _ = sphere c |R| := by\n      rw [Complex.range_exp_mul_I, smul_sphere R 0 zero_le_one]\n      simp\n\n"}
{"name":"image_circleMap_Ioc","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\n⊢ Eq (Set.image (circleMap c R) (Set.Ioc 0 (HMul.hMul 2 Real.pi))) (Metric.sphere c (abs R))","decl":"/-- The image of `(0, 2π]` under `circleMap c R` is the circle with center `c` and radius `|R|`. -/\n@[simp]\ntheorem image_circleMap_Ioc (c : ℂ) (R : ℝ) : circleMap c R '' Ioc 0 (2 * π) = sphere c |R| := by\n  rw [← range_circleMap, ← (periodic_circleMap c R).image_Ioc Real.two_pi_pos 0, zero_add]\n\n"}
{"name":"circleMap_eq_center_iff","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR θ : Real\n⊢ Iff (Eq (circleMap c R θ) c) (Eq R 0)","decl":"@[simp]\ntheorem circleMap_eq_center_iff {c : ℂ} {R : ℝ} {θ : ℝ} : circleMap c R θ = c ↔ R = 0 := by\n  simp [circleMap, exp_ne_zero]\n\n"}
{"name":"circleMap_zero_radius","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\n⊢ Eq (circleMap c 0) (Function.const Real c)","decl":"@[simp]\ntheorem circleMap_zero_radius (c : ℂ) : circleMap c 0 = const ℝ c :=\n  funext fun _ => circleMap_eq_center_iff.2 rfl\n\n"}
{"name":"circleMap_ne_center","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nhR : Ne R 0\nθ : Real\n⊢ Ne (circleMap c R θ) c","decl":"theorem circleMap_ne_center {c : ℂ} {R : ℝ} (hR : R ≠ 0) {θ : ℝ} : circleMap c R θ ≠ c :=\n  mt circleMap_eq_center_iff.1 hR\n\n"}
{"name":"hasDerivAt_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR θ : Real\n⊢ HasDerivAt (circleMap c R) (HMul.hMul (circleMap 0 R θ) Complex.I) θ","decl":"theorem hasDerivAt_circleMap (c : ℂ) (R : ℝ) (θ : ℝ) :\n    HasDerivAt (circleMap c R) (circleMap 0 R θ * I) θ := by\n  simpa only [mul_assoc, one_mul, ofRealCLM_apply, circleMap, ofReal_one, zero_add]\n    using (((ofRealCLM.hasDerivAt (x := θ)).mul_const I).cexp.const_mul (R : ℂ)).const_add c\n\n/- TODO: prove `ContDiff ℝ (circleMap c R)`. This needs a version of `ContDiff.mul`\nfor multiplication in a normed algebra over the base field. -/\n"}
{"name":"differentiable_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\n⊢ Differentiable Real (circleMap c R)","decl":"theorem differentiable_circleMap (c : ℂ) (R : ℝ) : Differentiable ℝ (circleMap c R) := fun θ =>\n  (hasDerivAt_circleMap c R θ).differentiableAt\n\n"}
{"name":"continuous_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\n⊢ Continuous (circleMap c R)","decl":"@[continuity, fun_prop]\ntheorem continuous_circleMap (c : ℂ) (R : ℝ) : Continuous (circleMap c R) :=\n  (differentiable_circleMap c R).continuous\n\n"}
{"name":"measurable_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\n⊢ Measurable (circleMap c R)","decl":"@[fun_prop, measurability]\ntheorem measurable_circleMap (c : ℂ) (R : ℝ) : Measurable (circleMap c R) :=\n  (continuous_circleMap c R).measurable\n\n"}
{"name":"deriv_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR θ : Real\n⊢ Eq (deriv (circleMap c R) θ) (HMul.hMul (circleMap 0 R θ) Complex.I)","decl":"@[simp]\ntheorem deriv_circleMap (c : ℂ) (R : ℝ) (θ : ℝ) : deriv (circleMap c R) θ = circleMap 0 R θ * I :=\n  (hasDerivAt_circleMap _ _ _).deriv\n\n"}
{"name":"deriv_circleMap_eq_zero_iff","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR θ : Real\n⊢ Iff (Eq (deriv (circleMap c R) θ) 0) (Eq R 0)","decl":"theorem deriv_circleMap_eq_zero_iff {c : ℂ} {R : ℝ} {θ : ℝ} :\n    deriv (circleMap c R) θ = 0 ↔ R = 0 := by simp [I_ne_zero]\n\n"}
{"name":"deriv_circleMap_ne_zero","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR θ : Real\nhR : Ne R 0\n⊢ Ne (deriv (circleMap c R) θ) 0","decl":"theorem deriv_circleMap_ne_zero {c : ℂ} {R : ℝ} {θ : ℝ} (hR : R ≠ 0) :\n    deriv (circleMap c R) θ ≠ 0 :=\n  mt deriv_circleMap_eq_zero_iff.1 hR\n\n"}
{"name":"lipschitzWith_circleMap","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\n⊢ LipschitzWith (Real.nnabs R) (circleMap c R)","decl":"theorem lipschitzWith_circleMap (c : ℂ) (R : ℝ) : LipschitzWith (Real.nnabs R) (circleMap c R) :=\n  lipschitzWith_of_nnnorm_deriv_le (differentiable_circleMap _ _) fun θ =>\n    NNReal.coe_le_coe.1 <| by simp\n\n"}
{"name":"continuous_circleMap_inv","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"R : Real\nz w : Complex\nhw : Membership.mem (Metric.ball z R) w\n⊢ Continuous fun θ => Inv.inv (HSub.hSub (circleMap z R θ) w)","decl":"theorem continuous_circleMap_inv {R : ℝ} {z w : ℂ} (hw : w ∈ ball z R) :\n    Continuous fun θ => (circleMap z R θ - w)⁻¹ := by\n  have : ∀ θ, circleMap z R θ - w ≠ 0 := by\n    simp_rw [sub_ne_zero]\n    exact fun θ => circleMap_ne_mem_ball hw θ\n  -- Porting note: was `continuity`\n  exact Continuous.inv₀ (by fun_prop) this\n\n"}
{"name":"circleIntegrable_const","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\na : E\nc : Complex\nR : Real\n⊢ CircleIntegrable (fun x => a) c R","decl":"@[simp]\ntheorem circleIntegrable_const (a : E) (c : ℂ) (R : ℝ) : CircleIntegrable (fun _ => a) c R :=\n  intervalIntegrable_const\n\n"}
{"name":"CircleIntegrable.add","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf g : Complex → E\nc : Complex\nR : Real\nhf : CircleIntegrable f c R\nhg : CircleIntegrable g c R\n⊢ CircleIntegrable (HAdd.hAdd f g) c R","decl":"nonrec theorem add (hf : CircleIntegrable f c R) (hg : CircleIntegrable g c R) :\n    CircleIntegrable (f + g) c R :=\n  hf.add hg\n\n"}
{"name":"CircleIntegrable.neg","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nc : Complex\nR : Real\nhf : CircleIntegrable f c R\n⊢ CircleIntegrable (Neg.neg f) c R","decl":"nonrec theorem neg (hf : CircleIntegrable f c R) : CircleIntegrable (-f) c R :=\n  hf.neg\n\n"}
{"name":"CircleIntegrable.out","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\nf : Complex → E\nc : Complex\nR : Real\ninst✝ : NormedSpace Complex E\nhf : CircleIntegrable f c R\n⊢ IntervalIntegrable (fun θ => HSMul.hSMul (deriv (circleMap c R) θ) (f (circleMap c R θ))) MeasureTheory.MeasureSpace.volume 0 (HMul.hMul 2 Real.pi)","decl":"/-- The function we actually integrate over `[0, 2π]` in the definition of `circleIntegral` is\nintegrable. -/\ntheorem out [NormedSpace ℂ E] (hf : CircleIntegrable f c R) :\n    IntervalIntegrable (fun θ : ℝ => deriv (circleMap c R) θ • f (circleMap c R θ)) volume 0\n      (2 * π) := by\n  simp only [CircleIntegrable, deriv_circleMap, intervalIntegrable_iff] at *\n  refine (hf.norm.const_mul |R|).mono' ?_ ?_\n  · exact ((continuous_circleMap _ _).aestronglyMeasurable.mul_const I).smul hf.aestronglyMeasurable\n  · simp [norm_smul]\n\n"}
{"name":"circleIntegrable_zero_radius","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nc : Complex\n⊢ CircleIntegrable f c 0","decl":"@[simp]\ntheorem circleIntegrable_zero_radius {f : ℂ → E} {c : ℂ} : CircleIntegrable f c 0 := by\n  simp [CircleIntegrable]\n\n"}
{"name":"circleIntegrable_iff","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR : Real\n⊢ Iff (CircleIntegrable f c R) (IntervalIntegrable (fun θ => HSMul.hSMul (deriv (circleMap c R) θ) (f (circleMap c R θ))) MeasureTheory.MeasureSpace.volume 0 (HMul.hMul 2 Real.pi))","decl":"theorem circleIntegrable_iff [NormedSpace ℂ E] {f : ℂ → E} {c : ℂ} (R : ℝ) :\n    CircleIntegrable f c R ↔ IntervalIntegrable (fun θ : ℝ =>\n      deriv (circleMap c R) θ • f (circleMap c R θ)) volume 0 (2 * π) := by\n  by_cases h₀ : R = 0\n  · simp (config := { unfoldPartialApp := true }) [h₀, const]\n  refine ⟨fun h => h.out, fun h => ?_⟩\n  simp only [CircleIntegrable, intervalIntegrable_iff, deriv_circleMap] at h ⊢\n  refine (h.norm.const_mul |R|⁻¹).mono' ?_ ?_\n  · have H : ∀ {θ}, circleMap 0 R θ * I ≠ 0 := fun {θ} => by simp [h₀, I_ne_zero]\n    simpa only [inv_smul_smul₀ H]\n      using ((continuous_circleMap 0 R).aestronglyMeasurable.mul_const\n        I).aemeasurable.inv.aestronglyMeasurable.smul h.aestronglyMeasurable\n  · simp [norm_smul, h₀]\n\n"}
{"name":"ContinuousOn.circleIntegrable'","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nc : Complex\nR : Real\nhf : ContinuousOn f (Metric.sphere c (abs R))\n⊢ CircleIntegrable f c R","decl":"theorem ContinuousOn.circleIntegrable' {f : ℂ → E} {c : ℂ} {R : ℝ}\n    (hf : ContinuousOn f (sphere c |R|)) : CircleIntegrable f c R :=\n  (hf.comp_continuous (continuous_circleMap _ _) (circleMap_mem_sphere' _ _)).intervalIntegrable _ _\n\n"}
{"name":"ContinuousOn.circleIntegrable","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : Complex → E\nc : Complex\nR : Real\nhR : LE.le 0 R\nhf : ContinuousOn f (Metric.sphere c R)\n⊢ CircleIntegrable f c R","decl":"theorem ContinuousOn.circleIntegrable {f : ℂ → E} {c : ℂ} {R : ℝ} (hR : 0 ≤ R)\n    (hf : ContinuousOn f (sphere c R)) : CircleIntegrable f c R :=\n  ContinuousOn.circleIntegrable' <| (_root_.abs_of_nonneg hR).symm ▸ hf\n\n"}
{"name":"circleIntegrable_sub_zpow_iff","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c w : Complex\nR : Real\nn : Int\n⊢ Iff (CircleIntegrable (fun z => HPow.hPow (HSub.hSub z w) n) c R) (Or (Eq R 0) (Or (LE.le 0 n) (Not (Membership.mem (Metric.sphere c (abs R)) w))))","decl":"/-- The function `fun z ↦ (z - w) ^ n`, `n : ℤ`, is circle integrable on the circle with center `c`\nand radius `|R|` if and only if `R = 0` or `0 ≤ n`, or `w` does not belong to this circle. -/\n@[simp]\ntheorem circleIntegrable_sub_zpow_iff {c w : ℂ} {R : ℝ} {n : ℤ} :\n    CircleIntegrable (fun z => (z - w) ^ n) c R ↔ R = 0 ∨ 0 ≤ n ∨ w ∉ sphere c |R| := by\n  constructor\n  · intro h; contrapose! h; rcases h with ⟨hR, hn, hw⟩\n    simp only [circleIntegrable_iff R, deriv_circleMap]\n    rw [← image_circleMap_Ioc] at hw; rcases hw with ⟨θ, hθ, rfl⟩\n    replace hθ : θ ∈ [[0, 2 * π]] := Icc_subset_uIcc (Ioc_subset_Icc_self hθ)\n    refine not_intervalIntegrable_of_sub_inv_isBigO_punctured ?_ Real.two_pi_pos.ne hθ\n    set f : ℝ → ℂ := fun θ' => circleMap c R θ' - circleMap c R θ\n    have : ∀ᶠ θ' in 𝓝[≠] θ, f θ' ∈ ball (0 : ℂ) 1 \\ {0} := by\n      suffices ∀ᶠ z in 𝓝[≠] circleMap c R θ, z - circleMap c R θ ∈ ball (0 : ℂ) 1 \\ {0} from\n        ((differentiable_circleMap c R θ).hasDerivAt.tendsto_punctured_nhds\n          (deriv_circleMap_ne_zero hR)).eventually this\n      filter_upwards [self_mem_nhdsWithin, mem_nhdsWithin_of_mem_nhds (ball_mem_nhds _ zero_lt_one)]\n      simp_all [dist_eq, sub_eq_zero]\n    refine (((hasDerivAt_circleMap c R θ).isBigO_sub.mono inf_le_left).inv_rev\n      (this.mono fun θ' h₁ h₂ => absurd h₂ h₁.2)).trans ?_\n    refine IsBigO.of_bound |R|⁻¹ (this.mono fun θ' hθ' => ?_)\n    set x := abs (f θ')\n    suffices x⁻¹ ≤ x ^ n by\n      simpa only [inv_mul_cancel_left₀, abs_eq_zero.not.2 hR, norm_eq_abs, map_inv₀,\n        Algebra.id.smul_eq_mul, map_mul, abs_circleMap_zero, abs_I, mul_one, abs_zpow, Ne,\n        not_false_iff] using this\n    have : x ∈ Ioo (0 : ℝ) 1 := by simpa [x, and_comm] using hθ'\n    rw [← zpow_neg_one]\n    refine (zpow_right_strictAnti₀ this.1 this.2).le_iff_le.2 (Int.lt_add_one_iff.1 ?_); exact hn\n  · rintro (rfl | H)\n    exacts [circleIntegrable_zero_radius,\n      ((continuousOn_id.sub continuousOn_const).zpow₀ _ fun z hz =>\n        H.symm.imp_left fun (hw : w ∉ sphere c |R|) =>\n          sub_ne_zero.2 <| ne_of_mem_of_not_mem hz hw).circleIntegrable']\n\n"}
{"name":"circleIntegrable_sub_inv_iff","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c w : Complex\nR : Real\n⊢ Iff (CircleIntegrable (fun z => Inv.inv (HSub.hSub z w)) c R) (Or (Eq R 0) (Not (Membership.mem (Metric.sphere c (abs R)) w)))","decl":"@[simp]\ntheorem circleIntegrable_sub_inv_iff {c w : ℂ} {R : ℝ} :\n    CircleIntegrable (fun z => (z - w)⁻¹) c R ↔ R = 0 ∨ w ∉ sphere c |R| := by\n  simp only [← zpow_neg_one, circleIntegrable_sub_zpow_iff]; norm_num\n\n"}
{"name":"circleIntegral_def_Icc","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR : Real\n⊢ Eq (circleIntegral (fun z => f z) c R) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc 0 (HMul.hMul 2 Real.pi))) fun θ => HSMul.hSMul (deriv (circleMap c R) θ) (f (circleMap c R θ)))","decl":"theorem circleIntegral_def_Icc (f : ℂ → E) (c : ℂ) (R : ℝ) :\n    (∮ z in C(c, R), f z) = ∫ θ in Icc 0 (2 * π),\n    deriv (circleMap c R) θ • f (circleMap c R θ) := by\n  rw [circleIntegral, intervalIntegral.integral_of_le Real.two_pi_pos.le,\n    Measure.restrict_congr_set Ioc_ae_eq_Icc]\n\n"}
{"name":"circleIntegral.integral_radius_zero","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\n⊢ Eq (circleIntegral (fun z => f z) c 0) 0","decl":"@[simp]\ntheorem integral_radius_zero (f : ℂ → E) (c : ℂ) : (∮ z in C(c, 0), f z) = 0 := by\n  simp (config := { unfoldPartialApp := true }) [circleIntegral, const]\n\n"}
{"name":"circleIntegral.integral_congr","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf g : Complex → E\nc : Complex\nR : Real\nhR : LE.le 0 R\nh : Set.EqOn f g (Metric.sphere c R)\n⊢ Eq (circleIntegral (fun z => f z) c R) (circleIntegral (fun z => g z) c R)","decl":"theorem integral_congr {f g : ℂ → E} {c : ℂ} {R : ℝ} (hR : 0 ≤ R) (h : EqOn f g (sphere c R)) :\n    (∮ z in C(c, R), f z) = ∮ z in C(c, R), g z :=\n  intervalIntegral.integral_congr fun θ _ => by simp only [h (circleMap_mem_sphere _ hR _)]\n\n"}
{"name":"circleIntegral.integral_sub_inv_smul_sub_smul","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc w : Complex\nR : Real\n⊢ Eq (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z w)) (HSMul.hSMul (HSub.hSub z w) (f z))) c R) (circleIntegral (fun z => f z) c R)","decl":"theorem integral_sub_inv_smul_sub_smul (f : ℂ → E) (c w : ℂ) (R : ℝ) :\n    (∮ z in C(c, R), (z - w)⁻¹ • (z - w) • f z) = ∮ z in C(c, R), f z := by\n  rcases eq_or_ne R 0 with (rfl | hR); · simp only [integral_radius_zero]\n  have : (circleMap c R ⁻¹' {w}).Countable := (countable_singleton _).preimage_circleMap c hR\n  refine intervalIntegral.integral_congr_ae ((this.ae_not_mem _).mono fun θ hθ _' => ?_)\n  change circleMap c R θ ≠ w at hθ\n  simp only [inv_smul_smul₀ (sub_ne_zero.2 <| hθ)]\n\n"}
{"name":"circleIntegral.integral_undef","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR : Real\nhf : Not (CircleIntegrable f c R)\n⊢ Eq (circleIntegral (fun z => f z) c R) 0","decl":"theorem integral_undef {f : ℂ → E} {c : ℂ} {R : ℝ} (hf : ¬CircleIntegrable f c R) :\n    (∮ z in C(c, R), f z) = 0 :=\n  intervalIntegral.integral_undef (mt (circleIntegrable_iff R).mpr hf)\n\n"}
{"name":"circleIntegral.integral_sub","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf g : Complex → E\nc : Complex\nR : Real\nhf : CircleIntegrable f c R\nhg : CircleIntegrable g c R\n⊢ Eq (circleIntegral (fun z => HSub.hSub (f z) (g z)) c R) (HSub.hSub (circleIntegral (fun z => f z) c R) (circleIntegral (fun z => g z) c R))","decl":"theorem integral_sub {f g : ℂ → E} {c : ℂ} {R : ℝ} (hf : CircleIntegrable f c R)\n    (hg : CircleIntegrable g c R) :\n    (∮ z in C(c, R), f z - g z) = (∮ z in C(c, R), f z) - ∮ z in C(c, R), g z := by\n  simp only [circleIntegral, smul_sub, intervalIntegral.integral_sub hf.out hg.out]\n\n"}
{"name":"circleIntegral.norm_integral_le_of_norm_le_const'","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR C : Real\nhf : ∀ (z : Complex), Membership.mem (Metric.sphere c (abs R)) z → LE.le (Norm.norm (f z)) C\n⊢ LE.le (Norm.norm (circleIntegral (fun z => f z) c R)) (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) (abs R)) C)","decl":"theorem norm_integral_le_of_norm_le_const' {f : ℂ → E} {c : ℂ} {R C : ℝ}\n    (hf : ∀ z ∈ sphere c |R|, ‖f z‖ ≤ C) : ‖∮ z in C(c, R), f z‖ ≤ 2 * π * |R| * C :=\n  calc\n    ‖∮ z in C(c, R), f z‖ ≤ |R| * C * |2 * π - 0| :=\n      intervalIntegral.norm_integral_le_of_norm_le_const fun θ _ =>\n        calc\n          ‖deriv (circleMap c R) θ • f (circleMap c R θ)‖ = |R| * ‖f (circleMap c R θ)‖ := by\n            simp [norm_smul]\n          _ ≤ |R| * C :=\n            mul_le_mul_of_nonneg_left (hf _ <| circleMap_mem_sphere' _ _ _) (abs_nonneg _)\n    _ = 2 * π * |R| * C := by rw [sub_zero, _root_.abs_of_pos Real.two_pi_pos]; ac_rfl\n\n"}
{"name":"circleIntegral.norm_integral_le_of_norm_le_const","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR C : Real\nhR : LE.le 0 R\nhf : ∀ (z : Complex), Membership.mem (Metric.sphere c R) z → LE.le (Norm.norm (f z)) C\n⊢ LE.le (Norm.norm (circleIntegral (fun z => f z) c R)) (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) R) C)","decl":"theorem norm_integral_le_of_norm_le_const {f : ℂ → E} {c : ℂ} {R C : ℝ} (hR : 0 ≤ R)\n    (hf : ∀ z ∈ sphere c R, ‖f z‖ ≤ C) : ‖∮ z in C(c, R), f z‖ ≤ 2 * π * R * C :=\n  have : |R| = R := abs_of_nonneg hR\n  calc\n    ‖∮ z in C(c, R), f z‖ ≤ 2 * π * |R| * C := norm_integral_le_of_norm_le_const' <| by rwa [this]\n    _ = 2 * π * R * C := by rw [this]\n\n"}
{"name":"circleIntegral.norm_two_pi_i_inv_smul_integral_le_of_norm_le_const","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR C : Real\nhR : LE.le 0 R\nhf : ∀ (z : Complex), Membership.mem (Metric.sphere c R) z → LE.le (Norm.norm (f z)) C\n⊢ LE.le (Norm.norm (HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)) (circleIntegral (fun z => f z) c R))) (HMul.hMul R C)","decl":"theorem norm_two_pi_i_inv_smul_integral_le_of_norm_le_const {f : ℂ → E} {c : ℂ} {R C : ℝ}\n    (hR : 0 ≤ R) (hf : ∀ z ∈ sphere c R, ‖f z‖ ≤ C) :\n    ‖(2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), f z‖ ≤ R * C := by\n  have : ‖(2 * π * I : ℂ)⁻¹‖ = (2 * π)⁻¹ := by simp [Real.pi_pos.le]\n  rw [norm_smul, this, ← div_eq_inv_mul, div_le_iff₀ Real.two_pi_pos, mul_comm (R * C), ← mul_assoc]\n  exact norm_integral_le_of_norm_le_const hR hf\n\n"}
{"name":"circleIntegral.norm_integral_lt_of_norm_le_const_of_lt","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR C : Real\nhR : LT.lt 0 R\nhc : ContinuousOn f (Metric.sphere c R)\nhf : ∀ (z : Complex), Membership.mem (Metric.sphere c R) z → LE.le (Norm.norm (f z)) C\nhlt : Exists fun z => And (Membership.mem (Metric.sphere c R) z) (LT.lt (Norm.norm (f z)) C)\n⊢ LT.lt (Norm.norm (circleIntegral (fun z => f z) c R)) (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) R) C)","decl":"/-- If `f` is continuous on the circle `|z - c| = R`, `R > 0`, the `‖f z‖` is less than or equal to\n`C : ℝ` on this circle, and this norm is strictly less than `C` at some point `z` of the circle,\nthen `‖∮ z in C(c, R), f z‖ < 2 * π * R * C`. -/\ntheorem norm_integral_lt_of_norm_le_const_of_lt {f : ℂ → E} {c : ℂ} {R C : ℝ} (hR : 0 < R)\n    (hc : ContinuousOn f (sphere c R)) (hf : ∀ z ∈ sphere c R, ‖f z‖ ≤ C)\n    (hlt : ∃ z ∈ sphere c R, ‖f z‖ < C) : ‖∮ z in C(c, R), f z‖ < 2 * π * R * C := by\n  rw [← _root_.abs_of_pos hR, ← image_circleMap_Ioc] at hlt\n  rcases hlt with ⟨_, ⟨θ₀, hmem, rfl⟩, hlt⟩\n  calc\n    ‖∮ z in C(c, R), f z‖ ≤ ∫ θ in (0)..2 * π, ‖deriv (circleMap c R) θ • f (circleMap c R θ)‖ :=\n      intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le\n    _ < ∫ _ in (0)..2 * π, R * C := by\n      simp only [norm_smul, deriv_circleMap, norm_eq_abs, map_mul, abs_I, mul_one,\n        abs_circleMap_zero, abs_of_pos hR]\n      refine intervalIntegral.integral_lt_integral_of_continuousOn_of_le_of_exists_lt\n          Real.two_pi_pos ?_ continuousOn_const (fun θ _ => ?_) ⟨θ₀, Ioc_subset_Icc_self hmem, ?_⟩\n      · exact continuousOn_const.mul (hc.comp (continuous_circleMap _ _).continuousOn fun θ _ =>\n          circleMap_mem_sphere _ hR.le _).norm\n      · exact mul_le_mul_of_nonneg_left (hf _ <| circleMap_mem_sphere _ hR.le _) hR.le\n      · exact (mul_lt_mul_left hR).2 hlt\n    _ = 2 * π * R * C := by simp [mul_assoc]; ring\n\n"}
{"name":"circleIntegral.integral_smul","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Complex E\n𝕜 : Type u_2\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : SMulCommClass 𝕜 Complex E\na : 𝕜\nf : Complex → E\nc : Complex\nR : Real\n⊢ Eq (circleIntegral (fun z => HSMul.hSMul a (f z)) c R) (HSMul.hSMul a (circleIntegral (fun z => f z) c R))","decl":"@[simp]\ntheorem integral_smul {𝕜 : Type*} [RCLike 𝕜] [NormedSpace 𝕜 E] [SMulCommClass 𝕜 ℂ E] (a : 𝕜)\n    (f : ℂ → E) (c : ℂ) (R : ℝ) : (∮ z in C(c, R), a • f z) = a • ∮ z in C(c, R), f z := by\n  simp only [circleIntegral, ← smul_comm a (_ : ℂ) (_ : E), intervalIntegral.integral_smul]\n\n"}
{"name":"circleIntegral.integral_smul_const","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf : Complex → Complex\na : E\nc : Complex\nR : Real\n⊢ Eq (circleIntegral (fun z => HSMul.hSMul (f z) a) c R) (HSMul.hSMul (circleIntegral (fun z => f z) c R) a)","decl":"@[simp]\ntheorem integral_smul_const [CompleteSpace E] (f : ℂ → ℂ) (a : E) (c : ℂ) (R : ℝ) :\n    (∮ z in C(c, R), f z • a) = (∮ z in C(c, R), f z) • a := by\n  simp only [circleIntegral, intervalIntegral.integral_smul_const, ← smul_assoc]\n\n"}
{"name":"circleIntegral.integral_const_mul","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"a : Complex\nf : Complex → Complex\nc : Complex\nR : Real\n⊢ Eq (circleIntegral (fun z => HMul.hMul a (f z)) c R) (HMul.hMul a (circleIntegral (fun z => f z) c R))","decl":"@[simp]\ntheorem integral_const_mul (a : ℂ) (f : ℂ → ℂ) (c : ℂ) (R : ℝ) :\n    (∮ z in C(c, R), a * f z) = a * ∮ z in C(c, R), f z :=\n  integral_smul a f c R\n\n"}
{"name":"circleIntegral.integral_sub_center_inv","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c : Complex\nR : Real\nhR : Ne R 0\n⊢ Eq (circleIntegral (fun z => Inv.inv (HSub.hSub z c)) c R) (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)","decl":"@[simp]\ntheorem integral_sub_center_inv (c : ℂ) {R : ℝ} (hR : R ≠ 0) :\n    (∮ z in C(c, R), (z - c)⁻¹) = 2 * π * I := by\n  simp [circleIntegral, ← div_eq_mul_inv, mul_div_cancel_left₀ _ (circleMap_ne_center hR),\n    -- Porting note: `simp` didn't need a hint to apply `integral_const` here\n    intervalIntegral.integral_const I]\n\n"}
{"name":"circleIntegral.integral_eq_zero_of_hasDerivWithinAt'","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf f' : Complex → E\nc : Complex\nR : Real\nh : ∀ (z : Complex), Membership.mem (Metric.sphere c (abs R)) z → HasDerivWithinAt f (f' z) (Metric.sphere c (abs R)) z\n⊢ Eq (circleIntegral (fun z => f' z) c R) 0","decl":"/-- If `f' : ℂ → E` is a derivative of a complex differentiable function on the circle\n`Metric.sphere c |R|`, then `∮ z in C(c, R), f' z = 0`. -/\ntheorem integral_eq_zero_of_hasDerivWithinAt' [CompleteSpace E] {f f' : ℂ → E} {c : ℂ} {R : ℝ}\n    (h : ∀ z ∈ sphere c |R|, HasDerivWithinAt f (f' z) (sphere c |R|) z) :\n    (∮ z in C(c, R), f' z) = 0 := by\n  by_cases hi : CircleIntegrable f' c R\n  · rw [← sub_eq_zero.2 ((periodic_circleMap c R).comp f).eq]\n    refine intervalIntegral.integral_eq_sub_of_hasDerivAt (fun θ _ => ?_) hi.out\n    exact (h _ (circleMap_mem_sphere' _ _ _)).scomp_hasDerivAt θ\n      (differentiable_circleMap _ _ _).hasDerivAt (circleMap_mem_sphere' _ _)\n  · exact integral_undef hi\n\n"}
{"name":"circleIntegral.integral_eq_zero_of_hasDerivWithinAt","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Complex E\ninst✝ : CompleteSpace E\nf f' : Complex → E\nc : Complex\nR : Real\nhR : LE.le 0 R\nh : ∀ (z : Complex), Membership.mem (Metric.sphere c R) z → HasDerivWithinAt f (f' z) (Metric.sphere c R) z\n⊢ Eq (circleIntegral (fun z => f' z) c R) 0","decl":"/-- If `f' : ℂ → E` is a derivative of a complex differentiable function on the circle\n`Metric.sphere c R`, then `∮ z in C(c, R), f' z = 0`. -/\ntheorem integral_eq_zero_of_hasDerivWithinAt [CompleteSpace E]\n    {f f' : ℂ → E} {c : ℂ} {R : ℝ} (hR : 0 ≤ R)\n    (h : ∀ z ∈ sphere c R, HasDerivWithinAt f (f' z) (sphere c R) z) : (∮ z in C(c, R), f' z) = 0 :=\n  integral_eq_zero_of_hasDerivWithinAt' <| (_root_.abs_of_nonneg hR).symm ▸ h\n\n"}
{"name":"circleIntegral.integral_sub_zpow_of_undef","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"n : Int\nc w : Complex\nR : Real\nhn : LT.lt n 0\nhw : Membership.mem (Metric.sphere c (abs R)) w\n⊢ Eq (circleIntegral (fun z => HPow.hPow (HSub.hSub z w) n) c R) 0","decl":"/-- If `n < 0` and `|w - c| = |R|`, then `(z - w) ^ n` is not circle integrable on the circle with\ncenter `c` and radius `|R|`, so the integral `∮ z in C(c, R), (z - w) ^ n` is equal to zero. -/\ntheorem integral_sub_zpow_of_undef {n : ℤ} {c w : ℂ} {R : ℝ} (hn : n < 0)\n    (hw : w ∈ sphere c |R|) : (∮ z in C(c, R), (z - w) ^ n) = 0 := by\n  rcases eq_or_ne R 0 with (rfl | h0)\n  · apply integral_radius_zero\n  · apply integral_undef\n    simpa [circleIntegrable_sub_zpow_iff, *, not_or]\n\n"}
{"name":"circleIntegral.integral_sub_zpow_of_ne","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"n : Int\nhn : Ne n (-1)\nc w : Complex\nR : Real\n⊢ Eq (circleIntegral (fun z => HPow.hPow (HSub.hSub z w) n) c R) 0","decl":"/-- If `n ≠ -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem integral_sub_zpow_of_ne {n : ℤ} (hn : n ≠ -1) (c w : ℂ) (R : ℝ) :\n    (∮ z in C(c, R), (z - w) ^ n) = 0 := by\n  rcases em (w ∈ sphere c |R| ∧ n < -1) with (⟨hw, hn⟩ | H)\n  · exact integral_sub_zpow_of_undef (hn.trans (by decide)) hw\n  push_neg at H\n  have hd : ∀ z, z ≠ w ∨ -1 ≤ n →\n      HasDerivAt (fun z => (z - w) ^ (n + 1) / (n + 1)) ((z - w) ^ n) z := by\n    intro z hne\n    convert ((hasDerivAt_zpow (n + 1) _ (hne.imp _ _)).comp z\n      ((hasDerivAt_id z).sub_const w)).div_const _ using 1\n    · have hn' : (n + 1 : ℂ) ≠ 0 := by\n        rwa [Ne, ← eq_neg_iff_add_eq_zero, ← Int.cast_one, ← Int.cast_neg, Int.cast_inj]\n      simp [mul_assoc, mul_div_cancel_left₀ _ hn']\n    exacts [sub_ne_zero.2, neg_le_iff_add_nonneg.1]\n  refine integral_eq_zero_of_hasDerivWithinAt' fun z hz => (hd z ?_).hasDerivWithinAt\n  exact (ne_or_eq z w).imp_right fun (h : z = w) => H <| h ▸ hz\n\n"}
{"name":"cauchyPowerSeries_apply","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR : Real\nn : Nat\nw : Complex\n⊢ Eq ((cauchyPowerSeries f c R n) fun x => w) (HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)) (circleIntegral (fun z => HSMul.hSMul (HPow.hPow (HDiv.hDiv w (HSub.hSub z c)) n) (HSMul.hSMul (Inv.inv (HSub.hSub z c)) (f z))) c R))","decl":"theorem cauchyPowerSeries_apply (f : ℂ → E) (c : ℂ) (R : ℝ) (n : ℕ) (w : ℂ) :\n    (cauchyPowerSeries f c R n fun _ => w) =\n      (2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), (w / (z - c)) ^ n • (z - c)⁻¹ • f z := by\n  simp only [cauchyPowerSeries, ContinuousMultilinearMap.mkPiRing_apply, Fin.prod_const,\n    div_eq_mul_inv, mul_pow, mul_smul, circleIntegral.integral_smul]\n  rw [← smul_comm (w ^ n)]\n\n"}
{"name":"norm_cauchyPowerSeries_le","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR : Real\nn : Nat\n⊢ LE.le (Norm.norm (cauchyPowerSeries f c R n)) (HMul.hMul (HMul.hMul (Inv.inv (HMul.hMul 2 Real.pi)) (intervalIntegral (fun θ => Norm.norm (f (circleMap c R θ))) 0 (HMul.hMul 2 Real.pi) MeasureTheory.MeasureSpace.volume)) (HPow.hPow (Inv.inv (abs R)) n))","decl":"theorem norm_cauchyPowerSeries_le (f : ℂ → E) (c : ℂ) (R : ℝ) (n : ℕ) :\n    ‖cauchyPowerSeries f c R n‖ ≤\n      ((2 * π)⁻¹ * ∫ θ : ℝ in (0)..2 * π, ‖f (circleMap c R θ)‖) * |R|⁻¹ ^ n :=\n  calc ‖cauchyPowerSeries f c R n‖\n    _ = (2 * π)⁻¹ * ‖∮ z in C(c, R), (z - c)⁻¹ ^ n • (z - c)⁻¹ • f z‖ := by\n      simp [cauchyPowerSeries, norm_smul, Real.pi_pos.le]\n    _ ≤ (2 * π)⁻¹ * ∫ θ in (0)..2 * π, ‖deriv (circleMap c R) θ •\n        (circleMap c R θ - c)⁻¹ ^ n • (circleMap c R θ - c)⁻¹ • f (circleMap c R θ)‖ :=\n      (mul_le_mul_of_nonneg_left\n        (intervalIntegral.norm_integral_le_integral_norm Real.two_pi_pos.le)\n        (by simp [Real.pi_pos.le]))\n    _ = (2 * π)⁻¹ *\n        (|R|⁻¹ ^ n * (|R| * (|R|⁻¹ * ∫ x : ℝ in (0)..2 * π, ‖f (circleMap c R x)‖))) := by\n      simp [norm_smul, mul_left_comm |R|]\n    _ ≤ ((2 * π)⁻¹ * ∫ θ : ℝ in (0)..2 * π, ‖f (circleMap c R θ)‖) * |R|⁻¹ ^ n := by\n      rcases eq_or_ne R 0 with (rfl | hR)\n      · cases n <;> simp [-mul_inv_rev]\n        rw [← mul_assoc, inv_mul_cancel₀ (Real.two_pi_pos.ne.symm), one_mul]\n        apply norm_nonneg\n      · rw [mul_inv_cancel_left₀, mul_assoc, mul_comm (|R|⁻¹ ^ n)]\n        rwa [Ne, _root_.abs_eq_zero]\n\n"}
{"name":"le_radius_cauchyPowerSeries","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR : NNReal\n⊢ LE.le (↑R) (cauchyPowerSeries f c ↑R).radius","decl":"theorem le_radius_cauchyPowerSeries (f : ℂ → E) (c : ℂ) (R : ℝ≥0) :\n    ↑R ≤ (cauchyPowerSeries f c R).radius := by\n  refine\n    (cauchyPowerSeries f c R).le_radius_of_bound\n      ((2 * π)⁻¹ * ∫ θ : ℝ in (0)..2 * π, ‖f (circleMap c R θ)‖) fun n => ?_\n  refine (mul_le_mul_of_nonneg_right (norm_cauchyPowerSeries_le _ _ _ _)\n    (pow_nonneg R.coe_nonneg _)).trans ?_\n  rw [_root_.abs_of_nonneg R.coe_nonneg]\n  rcases eq_or_ne (R ^ n : ℝ) 0 with hR | hR\n  · rw_mod_cast [hR, mul_zero]\n    exact mul_nonneg (inv_nonneg.2 Real.two_pi_pos.le)\n      (intervalIntegral.integral_nonneg Real.two_pi_pos.le fun _ _ => norm_nonneg _)\n  · rw [inv_pow]\n    have : (R : ℝ) ^ n ≠ 0 := by norm_cast at hR ⊢\n    rw [inv_mul_cancel_right₀ this]\n\n"}
{"name":"hasSum_two_pi_I_cauchyPowerSeries_integral","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR : Real\nw : Complex\nhf : CircleIntegrable f c R\nhw : LT.lt (Complex.abs w) R\n⊢ HasSum (fun n => circleIntegral (fun z => HSMul.hSMul (HPow.hPow (HDiv.hDiv w (HSub.hSub z c)) n) (HSMul.hSMul (Inv.inv (HSub.hSub z c)) (f z))) c R) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z (HAdd.hAdd c w))) (f z)) c R)","decl":"/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\nby `2πI` converges to the integral `∮ z in C(c, R), (z - w)⁻¹ • f z` on the open disc\n`Metric.ball c R`. -/\ntheorem hasSum_two_pi_I_cauchyPowerSeries_integral {f : ℂ → E} {c : ℂ} {R : ℝ} {w : ℂ}\n    (hf : CircleIntegrable f c R) (hw : abs w < R) :\n    HasSum (fun n : ℕ => ∮ z in C(c, R), (w / (z - c)) ^ n • (z - c)⁻¹ • f z)\n      (∮ z in C(c, R), (z - (c + w))⁻¹ • f z) := by\n  have hR : 0 < R := (Complex.abs.nonneg w).trans_lt hw\n  have hwR : abs w / R ∈ Ico (0 : ℝ) 1 :=\n    ⟨div_nonneg (Complex.abs.nonneg w) hR.le, (div_lt_one hR).2 hw⟩\n  refine intervalIntegral.hasSum_integral_of_dominated_convergence\n      (fun n θ => ‖f (circleMap c R θ)‖ * (abs w / R) ^ n) (fun n => ?_) (fun n => ?_) ?_ ?_ ?_\n  · simp only [deriv_circleMap]\n    apply_rules [AEStronglyMeasurable.smul, hf.def'.1] <;> apply Measurable.aestronglyMeasurable\n    · fun_prop\n    · fun_prop\n    · fun_prop\n  · simp [norm_smul, abs_of_pos hR, mul_left_comm R, inv_mul_cancel_left₀ hR.ne', mul_comm ‖_‖]\n  · exact Eventually.of_forall fun _ _ => (summable_geometric_of_lt_one hwR.1 hwR.2).mul_left _\n  · simpa only [tsum_mul_left, tsum_geometric_of_lt_one hwR.1 hwR.2] using\n      hf.norm.mul_continuousOn continuousOn_const\n  · refine Eventually.of_forall fun θ _ => HasSum.const_smul _ ?_\n    simp only [smul_smul]\n    refine HasSum.smul_const ?_ _\n    have : ‖w / (circleMap c R θ - c)‖ < 1 := by simpa [abs_of_pos hR] using hwR.2\n    convert (hasSum_geometric_of_norm_lt_one this).mul_right _ using 1\n    simp [← sub_sub, ← mul_inv, sub_mul, div_mul_cancel₀ _ (circleMap_ne_center hR.ne')]\n\n"}
{"name":"hasSum_cauchyPowerSeries_integral","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR : Real\nw : Complex\nhf : CircleIntegrable f c R\nhw : LT.lt (Complex.abs w) R\n⊢ HasSum (fun n => (cauchyPowerSeries f c R n) fun x => w) (HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z (HAdd.hAdd c w))) (f z)) c R))","decl":"/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\nconverges to the Cauchy integral `(2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), (z - w)⁻¹ • f z` on the open\ndisc `Metric.ball c R`. -/\ntheorem hasSum_cauchyPowerSeries_integral {f : ℂ → E} {c : ℂ} {R : ℝ} {w : ℂ}\n    (hf : CircleIntegrable f c R) (hw : abs w < R) :\n    HasSum (fun n => cauchyPowerSeries f c R n fun _ => w)\n      ((2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), (z - (c + w))⁻¹ • f z) := by\n  simp only [cauchyPowerSeries_apply]\n  exact (hasSum_two_pi_I_cauchyPowerSeries_integral hf hw).const_smul _\n\n"}
{"name":"sum_cauchyPowerSeries_eq_integral","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR : Real\nw : Complex\nhf : CircleIntegrable f c R\nhw : LT.lt (Complex.abs w) R\n⊢ Eq ((cauchyPowerSeries f c R).sum w) (HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z (HAdd.hAdd c w))) (f z)) c R))","decl":"/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\nconverges to the Cauchy integral `(2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), (z - w)⁻¹ • f z` on the open\ndisc `Metric.ball c R`. -/\ntheorem sum_cauchyPowerSeries_eq_integral {f : ℂ → E} {c : ℂ} {R : ℝ} {w : ℂ}\n    (hf : CircleIntegrable f c R) (hw : abs w < R) :\n    (cauchyPowerSeries f c R).sum w = (2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), (z - (c + w))⁻¹ • f z :=\n  (hasSum_cauchyPowerSeries_integral hf hw).tsum_eq\n\n"}
{"name":"hasFPowerSeriesOn_cauchy_integral","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : Complex → E\nc : Complex\nR : NNReal\nhf : CircleIntegrable f c ↑R\nhR : LT.lt 0 R\n⊢ HasFPowerSeriesOnBall (fun w => HSMul.hSMul (Inv.inv (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)) (circleIntegral (fun z => HSMul.hSMul (Inv.inv (HSub.hSub z w)) (f z)) c ↑R)) (cauchyPowerSeries f c ↑R) c ↑R","decl":"/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\nconverges to the Cauchy integral `(2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), (z - w)⁻¹ • f z` on the open\ndisc `Metric.ball c R`. -/\ntheorem hasFPowerSeriesOn_cauchy_integral {f : ℂ → E} {c : ℂ} {R : ℝ≥0}\n    (hf : CircleIntegrable f c R) (hR : 0 < R) :\n    HasFPowerSeriesOnBall (fun w => (2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), (z - w)⁻¹ • f z)\n      (cauchyPowerSeries f c R) c R :=\n  { r_le := le_radius_cauchyPowerSeries _ _ _\n    r_pos := ENNReal.coe_pos.2 hR\n    hasSum := fun hy ↦ hasSum_cauchyPowerSeries_integral hf <| by simpa using hy }\n\n"}
{"name":"circleIntegral.integral_sub_inv_of_mem_ball","module":"Mathlib.MeasureTheory.Integral.CircleIntegral","initialProofState":"c w : Complex\nR : Real\nhw : Membership.mem (Metric.ball c R) w\n⊢ Eq (circleIntegral (fun z => Inv.inv (HSub.hSub z w)) c R) (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)","decl":"/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. -/\ntheorem integral_sub_inv_of_mem_ball {c w : ℂ} {R : ℝ} (hw : w ∈ ball c R) :\n    (∮ z in C(c, R), (z - w)⁻¹) = 2 * π * I := by\n  have hR : 0 < R := dist_nonneg.trans_lt hw\n  suffices H : HasSum (fun n : ℕ => ∮ z in C(c, R), ((w - c) / (z - c)) ^ n * (z - c)⁻¹)\n      (2 * π * I) by\n    have A : CircleIntegrable (fun _ => (1 : ℂ)) c R := continuousOn_const.circleIntegrable'\n    refine (H.unique ?_).symm\n    simpa only [smul_eq_mul, mul_one, add_sub_cancel] using\n      hasSum_two_pi_I_cauchyPowerSeries_integral A hw\n  have H : ∀ n : ℕ, n ≠ 0 → (∮ z in C(c, R), (z - c) ^ (-n - 1 : ℤ)) = 0 := by\n    refine fun n hn => integral_sub_zpow_of_ne ?_ _ _ _; simpa\n  have : (∮ z in C(c, R), ((w - c) / (z - c)) ^ 0 * (z - c)⁻¹) = 2 * π * I := by simp [hR.ne']\n  refine this ▸ hasSum_single _ fun n hn => ?_\n  simp only [div_eq_mul_inv, mul_pow, integral_const_mul, mul_assoc]\n  rw [(integral_congr hR.le fun z hz => _).trans (H n hn), mul_zero]\n  intro z _\n  rw [← pow_succ, ← zpow_natCast, inv_zpow, ← zpow_neg, Int.ofNat_succ, neg_add,\n    sub_eq_add_neg _ (1 : ℤ)]\n\n"}
