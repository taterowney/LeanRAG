{"name":"Fin.tuple0_le","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Fin 0 → Type u_1\ninst✝ : (i : Fin 0) → Preorder (α i)\nf g : (i : Fin 0) → α i\n⊢ LE.le f g","decl":"theorem tuple0_le {α : Fin 0 → Type*} [∀ i, Preorder (α i)] (f g : ∀ i, α i) : f ≤ g :=\n  finZeroElim\n\n"}
{"name":"Fin.tail_def","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nq : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq (Fin.tail fun k => q k) fun k => q k.succ","decl":"theorem tail_def {n : ℕ} {α : Fin (n + 1) → Sort*} {q : ∀ i, α i} :\n    (tail fun k : Fin (n + 1) ↦ q k) = fun k : Fin n ↦ q k.succ :=\n  rfl\n\n"}
{"name":"Fin.tail_cons","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nx : α 0\np : (i : Fin n) → α i.succ\n⊢ Eq (Fin.tail (Fin.cons x p)) p","decl":"@[simp]\ntheorem tail_cons : tail (cons x p) = p := by\n  simp (config := { unfoldPartialApp := true }) [tail, cons]\n\n"}
{"name":"Fin.cons_succ","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nx : α 0\np : (i : Fin n) → α i.succ\ni : Fin n\n⊢ Eq (Fin.cons x p i.succ) (p i)","decl":"@[simp]\ntheorem cons_succ : cons x p i.succ = p i := by simp [cons]\n\n"}
{"name":"Fin.cons_zero","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nx : α 0\np : (i : Fin n) → α i.succ\n⊢ Eq (Fin.cons x p 0) x","decl":"@[simp]\ntheorem cons_zero : cons x p 0 = x := by simp [cons]\n\n"}
{"name":"Fin.cons_one","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 2) → Sort u_1\nx : α 0\np : (i : Fin n.succ) → α i.succ\n⊢ Eq (Fin.cons x p 1) (p 0)","decl":"@[simp]\ntheorem cons_one {α : Fin (n + 2) → Sort*} (x : α 0) (p : ∀ i : Fin n.succ, α i.succ) :\n    cons x p 1 = p 0 := by\n  rw [← cons_succ x p]; rfl\n\n"}
{"name":"Fin.cons_update","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nx : α 0\np : (i : Fin n) → α i.succ\ni : Fin n\ny : α i.succ\n⊢ Eq (Fin.cons x (Function.update p i y)) (Function.update (Fin.cons x p) i.succ y)","decl":"/-- Updating a tuple and adding an element at the beginning commute. -/\n@[simp]\ntheorem cons_update : cons x (update p i y) = update (cons x p) i.succ y := by\n  ext j\n  by_cases h : j = 0\n  · rw [h]\n    simp [Ne.symm (succ_ne_zero i)]\n  · let j' := pred j h\n    have : j'.succ = j := succ_pred j h\n    rw [← this, cons_succ]\n    by_cases h' : j' = i\n    · rw [h']\n      simp\n    · have : j'.succ ≠ i.succ := by rwa [Ne, succ_inj]\n      rw [update_of_ne h', update_of_ne this, cons_succ]\n\n"}
{"name":"Fin.cons_injective2","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\n⊢ Function.Injective2 Fin.cons","decl":"/-- As a binary function, `Fin.cons` is injective. -/\ntheorem cons_injective2 : Function.Injective2 (@cons n α) := fun x₀ y₀ x y h ↦\n  ⟨congr_fun h 0, funext fun i ↦ by simpa using congr_fun h (Fin.succ i)⟩\n\n"}
{"name":"Fin.cons_inj","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nx₀ y₀ : α 0\nx y : (i : Fin n) → α i.succ\n⊢ Iff (Eq (Fin.cons x₀ x) (Fin.cons y₀ y)) (And (Eq x₀ y₀) (Eq x y))","decl":"@[simp]\ntheorem cons_inj {x₀ y₀ : α 0} {x y : ∀ i : Fin n, α i.succ} :\n    cons x₀ x = cons y₀ y ↔ x₀ = y₀ ∧ x = y :=\n  cons_injective2.eq_iff\n\n"}
{"name":"Fin.cons_left_injective","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nx : (i : Fin n) → α i.succ\n⊢ Function.Injective fun x₀ => Fin.cons x₀ x","decl":"theorem cons_left_injective (x : ∀ i : Fin n, α i.succ) : Function.Injective fun x₀ ↦ cons x₀ x :=\n  cons_injective2.left _\n\n"}
{"name":"Fin.cons_right_injective","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nx₀ : α 0\n⊢ Function.Injective (Fin.cons x₀)","decl":"theorem cons_right_injective (x₀ : α 0) : Function.Injective (cons x₀) :=\n  cons_injective2.right _\n\n"}
{"name":"Fin.update_cons_zero","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nx : α 0\np : (i : Fin n) → α i.succ\nz : α 0\n⊢ Eq (Function.update (Fin.cons x p) 0 z) (Fin.cons z p)","decl":"/-- Adding an element at the beginning of a tuple and then updating it amounts to adding it\ndirectly. -/\ntheorem update_cons_zero : update (cons x p) 0 z = cons z p := by\n  ext j\n  by_cases h : j = 0\n  · rw [h]\n    simp\n  · simp only [h, update_of_ne, Ne, not_false_iff]\n    let j' := pred j h\n    have : j'.succ = j := succ_pred j h\n    rw [← this, cons_succ, cons_succ]\n\n"}
{"name":"Fin.cons_self_tail","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nq : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq (Fin.cons (q 0) (Fin.tail q)) q","decl":"/-- Concatenating the first element of a tuple with its tail gives back the original tuple -/\n@[simp]\ntheorem cons_self_tail : cons (q 0) (tail q) = q := by\n  ext j\n  by_cases h : j = 0\n  · rw [h]\n    simp\n  · let j' := pred j h\n    have : j'.succ = j := succ_pred j h\n    rw [← this]\n    unfold tail\n    rw [cons_succ]\n\n"}
{"name":"Fin.consEquiv_apply","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nf : Prod (α 0) ((i : Fin n) → α i.succ)\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq ((Fin.consEquiv α) f i) (Fin.cons f.1 f.2 i)","decl":"/-- Equivalence between tuples of length `n + 1` and pairs of an element and a tuple of length `n`\ngiven by separating out the first element of the tuple.\n\nThis is `Fin.cons` as an `Equiv`. -/\n@[simps]\ndef consEquiv (α : Fin (n + 1) → Type*) : α 0 × (∀ i, α (succ i)) ≃ ∀ i, α i where\n  toFun f := cons f.1 f.2\n  invFun f := (f 0, tail f)\n  left_inv f := by simp\n  right_inv f := by simp\n\n\n-- Porting note: Mathport removes `_root_`?\n"}
{"name":"Fin.consEquiv_symm_apply","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\nf : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq ((Fin.consEquiv α).symm f) { fst := f 0, snd := Fin.tail f }","decl":"/-- Equivalence between tuples of length `n + 1` and pairs of an element and a tuple of length `n`\ngiven by separating out the first element of the tuple.\n\nThis is `Fin.cons` as an `Equiv`. -/\n@[simps]\ndef consEquiv (α : Fin (n + 1) → Type*) : α 0 × (∀ i, α (succ i)) ≃ ∀ i, α i where\n  toFun f := cons f.1 f.2\n  invFun f := (f 0, tail f)\n  left_inv f := by simp\n  right_inv f := by simp\n\n\n-- Porting note: Mathport removes `_root_`?\n"}
{"name":"Fin.consCases_cons","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nP : ((i : Fin n.succ) → α i) → Sort v\nh : (x₀ : α 0) → (x : (i : Fin n) → α i.succ) → P (Fin.cons x₀ x)\nx₀ : α 0\nx : (i : Fin n) → α i.succ\n⊢ Eq (Fin.consCases h (Fin.cons x₀ x)) (h x₀ x)","decl":"@[simp]\ntheorem consCases_cons {P : (∀ i : Fin n.succ, α i) → Sort v} (h : ∀ x₀ x, P (Fin.cons x₀ x))\n    (x₀ : α 0) (x : ∀ i : Fin n, α i.succ) : @consCases _ _ _ h (cons x₀ x) = h x₀ x := by\n  rw [consCases, cast_eq]\n  congr\n\n"}
{"name":"Fin.cons_injective_of_injective","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Type u_1\nx₀ : α\nx : Fin n → α\nhx₀ : Not (Membership.mem (Set.range x) x₀)\nhx : Function.Injective x\n⊢ Function.Injective (Fin.cons x₀ x)","decl":"theorem cons_injective_of_injective {α} {x₀ : α} {x : Fin n → α} (hx₀ : x₀ ∉ Set.range x)\n    (hx : Function.Injective x) : Function.Injective (cons x₀ x : Fin n.succ → α) := by\n  refine Fin.cases ?_ ?_\n  · refine Fin.cases ?_ ?_\n    · intro\n      rfl\n    · intro j h\n      rw [cons_zero, cons_succ] at h\n      exact hx₀.elim ⟨_, h.symm⟩\n  · intro i\n    refine Fin.cases ?_ ?_\n    · intro h\n      rw [cons_zero, cons_succ] at h\n      exact hx₀.elim ⟨_, h⟩\n    · intro j h\n      rw [cons_succ, cons_succ] at h\n      exact congr_arg _ (hx h)\n\n"}
{"name":"Fin.cons_injective_iff","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Type u_1\nx₀ : α\nx : Fin n → α\n⊢ Iff (Function.Injective (Fin.cons x₀ x)) (And (Not (Membership.mem (Set.range x) x₀)) (Function.Injective x))","decl":"theorem cons_injective_iff {α} {x₀ : α} {x : Fin n → α} :\n    Function.Injective (cons x₀ x : Fin n.succ → α) ↔ x₀ ∉ Set.range x ∧ Function.Injective x := by\n  refine ⟨fun h ↦ ⟨?_, ?_⟩, fun h ↦ cons_injective_of_injective h.1 h.2⟩\n  · rintro ⟨i, hi⟩\n    replace h := @h i.succ 0\n    simp [hi, succ_ne_zero] at h\n  · simpa [Function.comp] using h.comp (Fin.succ_injective _)\n\n"}
{"name":"Fin.forall_fin_zero_pi","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Fin 0 → Sort u_1\nP : ((i : Fin 0) → α i) → Prop\n⊢ Iff (∀ (x : (i : Fin 0) → α i), P x) (P finZeroElim)","decl":"@[simp]\ntheorem forall_fin_zero_pi {α : Fin 0 → Sort*} {P : (∀ i, α i) → Prop} :\n    (∀ x, P x) ↔ P finZeroElim :=\n  ⟨fun h ↦ h _, fun h x ↦ Subsingleton.elim finZeroElim x ▸ h⟩\n\n"}
{"name":"Fin.exists_fin_zero_pi","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Fin 0 → Sort u_1\nP : ((i : Fin 0) → α i) → Prop\n⊢ Iff (Exists fun x => P x) (P finZeroElim)","decl":"@[simp]\ntheorem exists_fin_zero_pi {α : Fin 0 → Sort*} {P : (∀ i, α i) → Prop} :\n    (∃ x, P x) ↔ P finZeroElim :=\n  ⟨fun ⟨x, h⟩ ↦ Subsingleton.elim x finZeroElim ▸ h, fun h ↦ ⟨_, h⟩⟩\n\n"}
{"name":"Fin.forall_fin_succ_pi","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nP : ((i : Fin (HAdd.hAdd n 1)) → α i) → Prop\n⊢ Iff (∀ (x : (i : Fin (HAdd.hAdd n 1)) → α i), P x) (∀ (a : α 0) (v : (i : Fin n) → α i.succ), P (Fin.cons a v))","decl":"theorem forall_fin_succ_pi {P : (∀ i, α i) → Prop} : (∀ x, P x) ↔ ∀ a v, P (Fin.cons a v) :=\n  ⟨fun h a v ↦ h (Fin.cons a v), consCases⟩\n\n"}
{"name":"Fin.exists_fin_succ_pi","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nP : ((i : Fin (HAdd.hAdd n 1)) → α i) → Prop\n⊢ Iff (Exists fun x => P x) (Exists fun a => Exists fun v => P (Fin.cons a v))","decl":"theorem exists_fin_succ_pi {P : (∀ i, α i) → Prop} : (∃ x, P x) ↔ ∃ a v, P (Fin.cons a v) :=\n  ⟨fun ⟨x, h⟩ ↦ ⟨x 0, tail x, (cons_self_tail x).symm ▸ h⟩, fun ⟨_, _, h⟩ ↦ ⟨_, h⟩⟩\n\n"}
{"name":"Fin.tail_update_zero","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nq : (i : Fin (HAdd.hAdd n 1)) → α i\nz : α 0\n⊢ Eq (Fin.tail (Function.update q 0 z)) (Fin.tail q)","decl":"/-- Updating the first element of a tuple does not change the tail. -/\n@[simp]\ntheorem tail_update_zero : tail (update q 0 z) = tail q := by\n  ext j\n  simp [tail, Fin.succ_ne_zero]\n\n"}
{"name":"Fin.tail_update_succ","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u\nq : (i : Fin (HAdd.hAdd n 1)) → α i\ni : Fin n\ny : α i.succ\n⊢ Eq (Fin.tail (Function.update q i.succ y)) (Function.update (Fin.tail q) i y)","decl":"/-- Updating a nonzero element and taking the tail commute. -/\n@[simp]\ntheorem tail_update_succ : tail (update q i.succ y) = update (tail q) i y := by\n  ext j\n  by_cases h : j = i\n  · rw [h]\n    simp [tail]\n  · simp [tail, (Fin.succ_injective n).ne h, h]\n\n"}
{"name":"Fin.comp_cons","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_1\nβ : Sort u_2\ng : α → β\ny : α\nq : Fin n → α\n⊢ Eq (Function.comp g (Fin.cons y q)) (Fin.cons (g y) (Function.comp g q))","decl":"theorem comp_cons {α : Sort*} {β : Sort*} (g : α → β) (y : α) (q : Fin n → α) :\n    g ∘ cons y q = cons (g y) (g ∘ q) := by\n  ext j\n  by_cases h : j = 0\n  · rw [h]\n    rfl\n  · let j' := pred j h\n    have : j'.succ = j := succ_pred j h\n    rw [← this, cons_succ, comp_apply, comp_apply, cons_succ]\n\n"}
{"name":"Fin.comp_tail","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_1\nβ : Sort u_2\ng : α → β\nq : Fin n.succ → α\n⊢ Eq (Function.comp g (Fin.tail q)) (Fin.tail (Function.comp g q))","decl":"theorem comp_tail {α : Sort*} {β : Sort*} (g : α → β) (q : Fin n.succ → α) :\n    g ∘ tail q = tail (g ∘ q) := by\n  ext j\n  simp [tail]\n\n"}
{"name":"Fin.le_cons","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → Preorder (α i)\nx : α 0\nq : (i : Fin (HAdd.hAdd n 1)) → α i\np : (i : Fin n) → α i.succ\n⊢ Iff (LE.le q (Fin.cons x p)) (And (LE.le (q 0) x) (LE.le (Fin.tail q) p))","decl":"theorem le_cons [∀ i, Preorder (α i)] {x : α 0} {q : ∀ i, α i} {p : ∀ i : Fin n, α i.succ} :\n    q ≤ cons x p ↔ q 0 ≤ x ∧ tail q ≤ p :=\n  forall_fin_succ.trans <| and_congr Iff.rfl <| forall_congr' fun j ↦ by simp [tail]\n\n"}
{"name":"Fin.cons_le","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → Preorder (α i)\nx : α 0\nq : (i : Fin (HAdd.hAdd n 1)) → α i\np : (i : Fin n) → α i.succ\n⊢ Iff (LE.le (Fin.cons x p) q) (And (LE.le x (q 0)) (LE.le p (Fin.tail q)))","decl":"theorem cons_le [∀ i, Preorder (α i)] {x : α 0} {q : ∀ i, α i} {p : ∀ i : Fin n, α i.succ} :\n    cons x p ≤ q ↔ x ≤ q 0 ∧ p ≤ tail q :=\n  @le_cons _ (fun i ↦ (α i)ᵒᵈ) _ x q p\n\n"}
{"name":"Fin.cons_le_cons","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → Preorder (α i)\nx₀ y₀ : α 0\nx y : (i : Fin n) → α i.succ\n⊢ Iff (LE.le (Fin.cons x₀ x) (Fin.cons y₀ y)) (And (LE.le x₀ y₀) (LE.le x y))","decl":"theorem cons_le_cons [∀ i, Preorder (α i)] {x₀ y₀ : α 0} {x y : ∀ i : Fin n, α i.succ} :\n    cons x₀ x ≤ cons y₀ y ↔ x₀ ≤ y₀ ∧ x ≤ y :=\n  forall_fin_succ.trans <| and_congr_right' <| by simp only [cons_succ, Pi.le_def]\n\n"}
{"name":"Fin.range_fin_succ","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Type u_1\nf : Fin (HAdd.hAdd n 1) → α\n⊢ Eq (Set.range f) (Insert.insert (f 0) (Set.range (Fin.tail f)))","decl":"theorem range_fin_succ {α} (f : Fin (n + 1) → α) :\n    Set.range f = insert (f 0) (Set.range (Fin.tail f)) :=\n  Set.ext fun _ ↦ exists_fin_succ.trans <| eq_comm.or Iff.rfl\n\n"}
{"name":"Fin.range_cons","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Type u_1\nn : Nat\nx : α\nb : Fin n → α\n⊢ Eq (Set.range (Fin.cons x b)) (Insert.insert x (Set.range b))","decl":"@[simp]\ntheorem range_cons {α} {n : ℕ} (x : α) (b : Fin n → α) :\n    Set.range (Fin.cons x b : Fin n.succ → α) = insert x (Set.range b) := by\n  rw [range_fin_succ, cons_zero, tail_cons]\n\n"}
{"name":"Fin.append_left","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"m n : Nat\nα : Sort u_1\nu : Fin m → α\nv : Fin n → α\ni : Fin m\n⊢ Eq (Fin.append u v (Fin.castAdd n i)) (u i)","decl":"@[simp]\ntheorem append_left (u : Fin m → α) (v : Fin n → α) (i : Fin m) :\n    append u v (Fin.castAdd n i) = u i :=\n  addCases_left _\n\n"}
{"name":"Fin.append_right","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"m n : Nat\nα : Sort u_1\nu : Fin m → α\nv : Fin n → α\ni : Fin n\n⊢ Eq (Fin.append u v (Fin.natAdd m i)) (v i)","decl":"@[simp]\ntheorem append_right (u : Fin m → α) (v : Fin n → α) (i : Fin n) :\n    append u v (natAdd m i) = v i :=\n  addCases_right _\n\n"}
{"name":"Fin.append_right_nil","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"m n : Nat\nα : Sort u_1\nu : Fin m → α\nv : Fin n → α\nhv : Eq n 0\n⊢ Eq (Fin.append u v) (Function.comp u (Fin.cast ⋯))","decl":"theorem append_right_nil (u : Fin m → α) (v : Fin n → α) (hv : n = 0) :\n    append u v = u ∘ Fin.cast (by rw [hv, Nat.add_zero]) := by\n  refine funext (Fin.addCases (fun l => ?_) fun r => ?_)\n  · rw [append_left, Function.comp_apply]\n    refine congr_arg u (Fin.ext ?_)\n    simp\n  · exact (Fin.cast hv r).elim0\n\n"}
{"name":"Fin.append_elim0","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"m : Nat\nα : Sort u_1\nu : Fin m → α\n⊢ Eq (Fin.append u Fin.elim0) (Function.comp u (Fin.cast ⋯))","decl":"@[simp]\ntheorem append_elim0 (u : Fin m → α) :\n    append u Fin.elim0 = u ∘ Fin.cast (Nat.add_zero _) :=\n  append_right_nil _ _ rfl\n\n"}
{"name":"Fin.append_left_nil","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"m n : Nat\nα : Sort u_1\nu : Fin m → α\nv : Fin n → α\nhu : Eq m 0\n⊢ Eq (Fin.append u v) (Function.comp v (Fin.cast ⋯))","decl":"theorem append_left_nil (u : Fin m → α) (v : Fin n → α) (hu : m = 0) :\n    append u v = v ∘ Fin.cast (by rw [hu, Nat.zero_add]) := by\n  refine funext (Fin.addCases (fun l => ?_) fun r => ?_)\n  · exact (Fin.cast hu l).elim0\n  · rw [append_right, Function.comp_apply]\n    refine congr_arg v (Fin.ext ?_)\n    simp [hu]\n\n"}
{"name":"Fin.elim0_append","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_1\nv : Fin n → α\n⊢ Eq (Fin.append Fin.elim0 v) (Function.comp v (Fin.cast ⋯))","decl":"@[simp]\ntheorem elim0_append (v : Fin n → α) :\n    append Fin.elim0 v = v ∘ Fin.cast (Nat.zero_add _) :=\n  append_left_nil _ _ rfl\n\n"}
{"name":"Fin.append_assoc","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"m n : Nat\nα : Sort u_1\np : Nat\na : Fin m → α\nb : Fin n → α\nc : Fin p → α\n⊢ Eq (Fin.append (Fin.append a b) c) (Function.comp (Fin.append a (Fin.append b c)) (Fin.cast ⋯))","decl":"theorem append_assoc {p : ℕ} (a : Fin m → α) (b : Fin n → α) (c : Fin p → α) :\n    append (append a b) c = append a (append b c) ∘ Fin.cast (Nat.add_assoc ..) := by\n  ext i\n  rw [Function.comp_apply]\n  refine Fin.addCases (fun l => ?_) (fun r => ?_) i\n  · rw [append_left]\n    refine Fin.addCases (fun ll => ?_) (fun lr => ?_) l\n    · rw [append_left]\n      simp [castAdd_castAdd]\n    · rw [append_right]\n      simp [castAdd_natAdd]\n  · rw [append_right]\n    simp [← natAdd_natAdd]\n\n"}
{"name":"Fin.append_left_eq_cons","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Sort u_1\nn : Nat\nx₀ : Fin 1 → α\nx : Fin n → α\n⊢ Eq (Fin.append x₀ x) (Function.comp (Fin.cons (x₀ 0) x) (Fin.cast ⋯))","decl":"/-- Appending a one-tuple to the left is the same as `Fin.cons`. -/\ntheorem append_left_eq_cons {n : ℕ} (x₀ : Fin 1 → α) (x : Fin n → α) :\n    Fin.append x₀ x = Fin.cons (x₀ 0) x ∘ Fin.cast (Nat.add_comm ..) := by\n  ext i\n  refine Fin.addCases ?_ ?_ i <;> clear i\n  · intro i\n    rw [Subsingleton.elim i 0, Fin.append_left, Function.comp_apply, eq_comm]\n    exact Fin.cons_zero _ _\n  · intro i\n    rw [Fin.append_right, Function.comp_apply, Fin.cast_natAdd, eq_comm, Fin.addNat_one]\n    exact Fin.cons_succ _ _ _\n\n"}
{"name":"Fin.cons_eq_append","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_1\nx : α\nxs : Fin n → α\n⊢ Eq (Fin.cons x xs) (Function.comp (Fin.append (Fin.cons x Fin.elim0) xs) (Fin.cast ⋯))","decl":"/-- `Fin.cons` is the same as appending a one-tuple to the left. -/\ntheorem cons_eq_append (x : α) (xs : Fin n → α) :\n    cons x xs = append (cons x Fin.elim0) xs ∘ Fin.cast (Nat.add_comm ..) := by\n  funext i; simp [append_left_eq_cons]\n\n"}
{"name":"Fin.append_cast_left","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Sort u_1\nn m : Nat\nxs : Fin n → α\nys : Fin m → α\nn' : Nat\nh : Eq n' n\n⊢ Eq (Fin.append (Function.comp xs (Fin.cast h)) ys) (Function.comp (Fin.append xs ys) (Fin.cast ⋯))","decl":"@[simp] lemma append_cast_left {n m} (xs : Fin n → α) (ys : Fin m → α) (n' : ℕ)\n    (h : n' = n) :\n    Fin.append (xs ∘ Fin.cast h) ys = Fin.append xs ys ∘ (Fin.cast <| by rw [h]) := by\n  subst h; simp\n\n"}
{"name":"Fin.append_cast_right","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Sort u_1\nn m : Nat\nxs : Fin n → α\nys : Fin m → α\nm' : Nat\nh : Eq m' m\n⊢ Eq (Fin.append xs (Function.comp ys (Fin.cast h))) (Function.comp (Fin.append xs ys) (Fin.cast ⋯))","decl":"@[simp] lemma append_cast_right {n m} (xs : Fin n → α) (ys : Fin m → α) (m' : ℕ)\n    (h : m' = m) :\n    Fin.append xs (ys ∘ Fin.cast h) = Fin.append xs ys ∘ (Fin.cast <| by rw [h]) := by\n  subst h; simp\n\n"}
{"name":"Fin.append_rev","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Sort u_1\nm n : Nat\nxs : Fin m → α\nys : Fin n → α\ni : Fin (HAdd.hAdd m n)\n⊢ Eq (Fin.append xs ys i.rev) (Fin.append (Function.comp ys Fin.rev) (Function.comp xs Fin.rev) (Fin.cast ⋯ i))","decl":"lemma append_rev {m n} (xs : Fin m → α) (ys : Fin n → α) (i : Fin (m + n)) :\n    append xs ys (rev i) = append (ys ∘ rev) (xs ∘ rev) (i.cast (Nat.add_comm ..)) := by\n  rcases rev_surjective i with ⟨i, rfl⟩\n  rw [rev_rev]\n  induction i using Fin.addCases\n  · simp [rev_castAdd]\n  · simp [cast_rev, rev_addNat]\n\n"}
{"name":"Fin.append_comp_rev","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Sort u_1\nm n : Nat\nxs : Fin m → α\nys : Fin n → α\n⊢ Eq (Function.comp (Fin.append xs ys) Fin.rev) (Function.comp (Fin.append (Function.comp ys Fin.rev) (Function.comp xs Fin.rev)) (Fin.cast ⋯))","decl":"lemma append_comp_rev {m n} (xs : Fin m → α) (ys : Fin n → α) :\n    append xs ys ∘ rev = append (ys ∘ rev) (xs ∘ rev) ∘ Fin.cast (Nat.add_comm ..) :=\n  funext <| append_rev xs ys\n\n"}
{"name":"Fin.append_castAdd_natAdd","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"m n : Nat\nα : Sort u_1\nf : Fin (HAdd.hAdd m n) → α\n⊢ Eq (Fin.append (fun i => f (Fin.castAdd n i)) fun i => f (Fin.natAdd m i)) f","decl":"theorem append_castAdd_natAdd {f : Fin (m + n) → α} :\n    append (fun i ↦ f (castAdd n i)) (fun i ↦ f (natAdd m i)) = f := by\n  unfold append addCases\n  simp\n\n"}
{"name":"Fin.repeat_apply","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"m n : Nat\nα : Sort u_1\na : Fin n → α\ni : Fin (HMul.hMul m n)\n⊢ Eq (Fin.repeat m a i) (a i.modNat)","decl":"@[simp]\ntheorem repeat_apply (a : Fin n → α) (i : Fin (m * n)) :\n    Fin.repeat m a i = a i.modNat :=\n  rfl\n\n"}
{"name":"Fin.repeat_zero","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_1\na : Fin n → α\n⊢ Eq (Fin.repeat 0 a) (Function.comp Fin.elim0 (Fin.cast ⋯))","decl":"@[simp]\ntheorem repeat_zero (a : Fin n → α) :\n    Fin.repeat 0 a = Fin.elim0 ∘ Fin.cast (Nat.zero_mul _) :=\n  funext fun x => (x.cast (Nat.zero_mul _)).elim0\n\n"}
{"name":"Fin.repeat_one","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_1\na : Fin n → α\n⊢ Eq (Fin.repeat 1 a) (Function.comp a (Fin.cast ⋯))","decl":"@[simp]\ntheorem repeat_one (a : Fin n → α) : Fin.repeat 1 a = a ∘ Fin.cast (Nat.one_mul _) := by\n  generalize_proofs h\n  apply funext\n  rw [(Fin.rightInverse_cast h.symm).surjective.forall]\n  intro i\n  simp [modNat, Nat.mod_eq_of_lt i.is_lt]\n\n"}
{"name":"Fin.repeat_succ","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_1\na : Fin n → α\nm : Nat\n⊢ Eq (Fin.repeat m.succ a) (Function.comp (Fin.append a (Fin.repeat m a)) (Fin.cast ⋯))","decl":"theorem repeat_succ (a : Fin n → α) (m : ℕ) :\n    Fin.repeat m.succ a =\n      append a (Fin.repeat m a) ∘ Fin.cast ((Nat.succ_mul _ _).trans (Nat.add_comm ..)) := by\n  generalize_proofs h\n  apply funext\n  rw [(Fin.rightInverse_cast h.symm).surjective.forall]\n  refine Fin.addCases (fun l => ?_) fun r => ?_\n  · simp [modNat, Nat.mod_eq_of_lt l.is_lt]\n  · simp [modNat]\n\n"}
{"name":"Fin.repeat_add","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_1\na : Fin n → α\nm₁ m₂ : Nat\n⊢ Eq (Fin.repeat (HAdd.hAdd m₁ m₂) a) (Function.comp (Fin.append (Fin.repeat m₁ a) (Fin.repeat m₂ a)) (Fin.cast ⋯))","decl":"@[simp]\ntheorem repeat_add (a : Fin n → α) (m₁ m₂ : ℕ) : Fin.repeat (m₁ + m₂) a =\n    append (Fin.repeat m₁ a) (Fin.repeat m₂ a) ∘ Fin.cast (Nat.add_mul ..) := by\n  generalize_proofs h\n  apply funext\n  rw [(Fin.rightInverse_cast h.symm).surjective.forall]\n  refine Fin.addCases (fun l => ?_) fun r => ?_\n  · simp [modNat, Nat.mod_eq_of_lt l.is_lt]\n  · simp [modNat, Nat.add_mod]\n\n"}
{"name":"Fin.repeat_rev","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"m n : Nat\nα : Sort u_1\na : Fin n → α\nk : Fin (HMul.hMul m n)\n⊢ Eq (Fin.repeat m a k.rev) (Fin.repeat m (Function.comp a Fin.rev) k)","decl":"theorem repeat_rev (a : Fin n → α) (k : Fin (m * n)) :\n    Fin.repeat m a k.rev = Fin.repeat m (a ∘ Fin.rev) k :=\n  congr_arg a k.modNat_rev\n\n"}
{"name":"Fin.repeat_comp_rev","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"m n : Nat\nα : Sort u_1\na : Fin n → α\n⊢ Eq (Function.comp (Fin.repeat m a) Fin.rev) (Fin.repeat m (Function.comp a Fin.rev))","decl":"theorem repeat_comp_rev (a : Fin n → α) :\n    Fin.repeat m a ∘ Fin.rev = Fin.repeat m (a ∘ Fin.rev) :=\n  funext <| repeat_rev a\n\n"}
{"name":"Fin.init_def","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nq : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq (Fin.init fun k => q k) fun k => q k.castSucc","decl":"theorem init_def {q : ∀ i, α i} :\n    (init fun k : Fin (n + 1) ↦ q k) = fun k : Fin n ↦ q k.castSucc :=\n  rfl\n\n"}
{"name":"Fin.init_snoc","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nx : α (Fin.last n)\np : (i : Fin n) → α i.castSucc\n⊢ Eq (Fin.init (Fin.snoc p x)) p","decl":"@[simp]\ntheorem init_snoc : init (snoc p x) = p := by\n  ext i\n  simp only [init, snoc, coe_castSucc, is_lt, cast_eq, dite_true]\n  convert cast_eq rfl (p i)\n\n"}
{"name":"Fin.snoc_castSucc","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nx : α (Fin.last n)\np : (i : Fin n) → α i.castSucc\ni : Fin n\n⊢ Eq (Fin.snoc p x i.castSucc) (p i)","decl":"@[simp]\ntheorem snoc_castSucc : snoc p x i.castSucc = p i := by\n  simp only [snoc, coe_castSucc, is_lt, cast_eq, dite_true]\n  convert cast_eq rfl (p i)\n\n"}
{"name":"Fin.snoc_comp_castSucc","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_2\na : α\nf : Fin n → α\n⊢ Eq (Function.comp (Fin.snoc f a) Fin.castSucc) f","decl":"@[simp]\ntheorem snoc_comp_castSucc {α : Sort*} {a : α} {f : Fin n → α} :\n    (snoc f a : Fin (n + 1) → α) ∘ castSucc = f :=\n  funext fun i ↦ by rw [Function.comp_apply, snoc_castSucc]\n\n"}
{"name":"Fin.snoc_last","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nx : α (Fin.last n)\np : (i : Fin n) → α i.castSucc\n⊢ Eq (Fin.snoc p x (Fin.last n)) x","decl":"@[simp]\ntheorem snoc_last : snoc p x (last n) = x := by simp [snoc]\n\n"}
{"name":"Fin.snoc_zero","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Sort u_2\np : Fin 0 → α\nx : α\n⊢ Eq (Fin.snoc p x) fun x_1 => x","decl":"lemma snoc_zero {α : Sort*} (p : Fin 0 → α) (x : α) :\n    Fin.snoc p x = fun _ ↦ x := by\n  ext y\n  have : Subsingleton (Fin (0 + 1)) := Fin.subsingleton_one\n  simp only [Subsingleton.elim y (Fin.last 0), snoc_last]\n\n"}
{"name":"Fin.snoc_comp_nat_add","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n m : Nat\nα : Sort u_2\nf : Fin (HAdd.hAdd m n) → α\na : α\n⊢ Eq (Function.comp (Fin.snoc f a) (Fin.natAdd m)) (Fin.snoc (Function.comp f (Fin.natAdd m)) a)","decl":"@[simp]\ntheorem snoc_comp_nat_add {n m : ℕ} {α : Sort*} (f : Fin (m + n) → α) (a : α) :\n    (snoc f a : Fin _ → α) ∘ (natAdd m : Fin (n + 1) → Fin (m + n + 1)) =\n      snoc (f ∘ natAdd m) a := by\n  ext i\n  refine Fin.lastCases ?_ (fun i ↦ ?_) i\n  · simp only [Function.comp_apply]\n    rw [snoc_last, natAdd_last, snoc_last]\n  · simp only [comp_apply, snoc_castSucc]\n    rw [natAdd_castSucc, snoc_castSucc]\n\n"}
{"name":"Fin.snoc_cast_add","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"m n : Nat\nα : Fin (HAdd.hAdd (HAdd.hAdd n m) 1) → Sort u_2\nf : (i : Fin (HAdd.hAdd n m)) → α i.castSucc\na : α (Fin.last (HAdd.hAdd n m))\ni : Fin n\n⊢ Eq (Fin.snoc f a (Fin.castAdd (HAdd.hAdd m 1) i)) (f (Fin.castAdd m i))","decl":"@[simp]\ntheorem snoc_cast_add {α : Fin (n + m + 1) → Sort*} (f : ∀ i : Fin (n + m), α i.castSucc)\n    (a : α (last (n + m))) (i : Fin n) : (snoc f a) (castAdd (m + 1) i) = f (castAdd m i) :=\n  dif_pos _\n\n-- Porting note: Had to `unfold comp`\n"}
{"name":"Fin.snoc_comp_cast_add","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n m : Nat\nα : Sort u_2\nf : Fin (HAdd.hAdd n m) → α\na : α\n⊢ Eq (Function.comp (Fin.snoc f a) (Fin.castAdd (HAdd.hAdd m 1))) (Function.comp f (Fin.castAdd m))","decl":"@[simp]\ntheorem snoc_comp_cast_add {n m : ℕ} {α : Sort*} (f : Fin (n + m) → α) (a : α) :\n    (snoc f a : Fin _ → α) ∘ castAdd (m + 1) = f ∘ castAdd m :=\n  funext (by unfold comp; exact snoc_cast_add _ _)\n\n"}
{"name":"Fin.snoc_update","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nx : α (Fin.last n)\np : (i : Fin n) → α i.castSucc\ni : Fin n\ny : α i.castSucc\n⊢ Eq (Fin.snoc (Function.update p i y) x) (Function.update (Fin.snoc p x) i.castSucc y)","decl":"/-- Updating a tuple and adding an element at the end commute. -/\n@[simp]\ntheorem snoc_update : snoc (update p i y) x = update (snoc p x) i.castSucc y := by\n  ext j\n  by_cases h : j.val < n\n  · rw [snoc]\n    simp only [h]\n    simp only [dif_pos]\n    by_cases h' : j = castSucc i\n    · have C1 : α i.castSucc = α j := by rw [h']\n      have E1 : update (snoc p x) i.castSucc y j = _root_.cast C1 y := by\n        have : update (snoc p x) j (_root_.cast C1 y) j = _root_.cast C1 y := by simp\n        convert this\n        · exact h'.symm\n        · exact heq_of_cast_eq (congr_arg α (Eq.symm h')) rfl\n      have C2 : α i.castSucc = α (castLT j h).castSucc := by rw [castSucc_castLT, h']\n      have E2 : update p i y (castLT j h) = _root_.cast C2 y := by\n        have : update p (castLT j h) (_root_.cast C2 y) (castLT j h) = _root_.cast C2 y := by simp\n        convert this\n        · simp [h, h']\n        · exact heq_of_cast_eq C2 rfl\n      rw [E1, E2]\n      rfl\n    · have : ¬castLT j h = i := by\n        intro E\n        apply h'\n        rw [← E, castSucc_castLT]\n      simp [h', this, snoc, h]\n  · rw [eq_last_of_not_lt h]\n    simp [Fin.ne_of_gt i.castSucc_lt_last]\n\n"}
{"name":"Fin.update_snoc_last","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nx : α (Fin.last n)\np : (i : Fin n) → α i.castSucc\nz : α (Fin.last n)\n⊢ Eq (Function.update (Fin.snoc p x) (Fin.last n) z) (Fin.snoc p z)","decl":"/-- Adding an element at the beginning of a tuple and then updating it amounts to adding it\ndirectly. -/\ntheorem update_snoc_last : update (snoc p x) (last n) z = snoc p z := by\n  ext j\n  by_cases h : j.val < n\n  · have : j ≠ last n := Fin.ne_of_lt h\n    simp [h, update_of_ne, this, snoc]\n  · rw [eq_last_of_not_lt h]\n    simp\n\n"}
{"name":"Fin.snoc_injective2","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\n⊢ Function.Injective2 Fin.snoc","decl":"/-- As a binary function, `Fin.snoc` is injective. -/\ntheorem snoc_injective2 : Function.Injective2 (@snoc n α) := fun x y xₙ yₙ h ↦\n  ⟨funext fun i ↦ by simpa using congr_fun h (castSucc i), by simpa using congr_fun h (last n)⟩\n\n"}
{"name":"Fin.snoc_inj","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nx y : (i : Fin n) → α i.castSucc\nxₙ yₙ : α (Fin.last n)\n⊢ Iff (Eq (Fin.snoc x xₙ) (Fin.snoc y yₙ)) (And (Eq x y) (Eq xₙ yₙ))","decl":"@[simp]\ntheorem snoc_inj {x y : ∀ i : Fin n, α i.castSucc} {xₙ yₙ : α (last n)} :\n    snoc x xₙ = snoc y yₙ ↔ x = y ∧ xₙ = yₙ :=\n  snoc_injective2.eq_iff\n\n"}
{"name":"Fin.snoc_right_injective","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nx : (i : Fin n) → α i.castSucc\n⊢ Function.Injective (Fin.snoc x)","decl":"theorem snoc_right_injective (x : ∀ i : Fin n, α i.castSucc) :\n    Function.Injective (snoc x) :=\n  snoc_injective2.right _\n\n"}
{"name":"Fin.snoc_left_injective","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nxₙ : α (Fin.last n)\n⊢ Function.Injective fun x => Fin.snoc x xₙ","decl":"theorem snoc_left_injective (xₙ : α (last n)) : Function.Injective (snoc · xₙ) :=\n  snoc_injective2.left _\n\n"}
{"name":"Fin.snoc_init_self","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nq : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq (Fin.snoc (Fin.init q) (q (Fin.last n))) q","decl":"/-- Concatenating the first element of a tuple with its tail gives back the original tuple -/\n@[simp]\ntheorem snoc_init_self : snoc (init q) (q (last n)) = q := by\n  ext j\n  by_cases h : j.val < n\n  · simp only [init, snoc, h, cast_eq, dite_true, castSucc_castLT]\n  · rw [eq_last_of_not_lt h]\n    simp\n\n"}
{"name":"Fin.init_update_last","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nq : (i : Fin (HAdd.hAdd n 1)) → α i\nz : α (Fin.last n)\n⊢ Eq (Fin.init (Function.update q (Fin.last n) z)) (Fin.init q)","decl":"/-- Updating the last element of a tuple does not change the beginning. -/\n@[simp]\ntheorem init_update_last : init (update q (last n) z) = init q := by\n  ext j\n  simp [init, Fin.ne_of_lt, castSucc_lt_last]\n\n"}
{"name":"Fin.init_update_castSucc","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nq : (i : Fin (HAdd.hAdd n 1)) → α i\ni : Fin n\ny : α i.castSucc\n⊢ Eq (Fin.init (Function.update q i.castSucc y)) (Function.update (Fin.init q) i y)","decl":"/-- Updating an element and taking the beginning commute. -/\n@[simp]\ntheorem init_update_castSucc : init (update q i.castSucc y) = update (init q) i y := by\n  ext j\n  by_cases h : j = i\n  · rw [h]\n    simp [init]\n  · simp [init, h, castSucc_inj]\n\n"}
{"name":"Fin.tail_init_eq_init_tail","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nβ : Sort u_2\nq : Fin (HAdd.hAdd n 2) → β\n⊢ Eq (Fin.tail (Fin.init q)) (Fin.init (Fin.tail q))","decl":"/-- `tail` and `init` commute. We state this lemma in a non-dependent setting, as otherwise it\nwould involve a cast to convince Lean that the two types are equal, making it harder to use. -/\ntheorem tail_init_eq_init_tail {β : Sort*} (q : Fin (n + 2) → β) :\n    tail (init q) = init (tail q) := by\n  ext i\n  simp [tail, init, castSucc_fin_succ]\n\n"}
{"name":"Fin.cons_snoc_eq_snoc_cons","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nβ : Sort u_2\na : β\nq : Fin n → β\nb : β\n⊢ Eq (Fin.cons a (Fin.snoc q b)) (Fin.snoc (Fin.cons a q) b)","decl":"/-- `cons` and `snoc` commute. We state this lemma in a non-dependent setting, as otherwise it\nwould involve a cast to convince Lean that the two types are equal, making it harder to use. -/\ntheorem cons_snoc_eq_snoc_cons {β : Sort*} (a : β) (q : Fin n → β) (b : β) :\n    @cons n.succ (fun _ ↦ β) a (snoc q b) = snoc (cons a q) b := by\n  ext i\n  by_cases h : i = 0\n  · rw [h]\n    -- Porting note: `refl` finished it here in Lean 3, but I had to add more.\n    simp [snoc, castLT]\n  set j := pred i h with ji\n  have : i = j.succ := by rw [ji, succ_pred]\n  rw [this, cons_succ]\n  by_cases h' : j.val < n\n  · set k := castLT j h' with jk\n    have : j = castSucc k := by rw [jk, castSucc_castLT]\n    rw [this, ← castSucc_fin_succ, snoc]\n    simp [pred, snoc, cons]\n  rw [eq_last_of_not_lt h', succ_last]\n  simp\n\n"}
{"name":"Fin.comp_snoc","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_2\nβ : Sort u_3\ng : α → β\nq : Fin n → α\ny : α\n⊢ Eq (Function.comp g (Fin.snoc q y)) (Fin.snoc (Function.comp g q) (g y))","decl":"theorem comp_snoc {α : Sort*} {β : Sort*} (g : α → β) (q : Fin n → α) (y : α) :\n    g ∘ snoc q y = snoc (g ∘ q) (g y) := by\n  ext j\n  by_cases h : j.val < n\n  · simp [h, snoc, castSucc_castLT]\n  · rw [eq_last_of_not_lt h]\n    simp\n\n"}
{"name":"Fin.append_right_eq_snoc","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Sort u_2\nn : Nat\nx : Fin n → α\nx₀ : Fin 1 → α\n⊢ Eq (Fin.append x x₀) (Fin.snoc x (x₀ 0))","decl":"/-- Appending a one-tuple to the right is the same as `Fin.snoc`. -/\ntheorem append_right_eq_snoc {α : Sort*} {n : ℕ} (x : Fin n → α) (x₀ : Fin 1 → α) :\n    Fin.append x x₀ = Fin.snoc x (x₀ 0) := by\n  ext i\n  refine Fin.addCases ?_ ?_ i <;> clear i\n  · intro i\n    rw [Fin.append_left]\n    exact (@snoc_castSucc _ (fun _ => α) _ _ i).symm\n  · intro i\n    rw [Subsingleton.elim i 0, Fin.append_right]\n    exact (@snoc_last _ (fun _ => α) _ _).symm\n\n"}
{"name":"Fin.snoc_eq_append","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_2\nxs : Fin n → α\nx : α\n⊢ Eq (Fin.snoc xs x) (Fin.append xs (Fin.cons x Fin.elim0))","decl":"/-- `Fin.snoc` is the same as appending a one-tuple -/\ntheorem snoc_eq_append {α : Sort*} (xs : Fin n → α) (x : α) :\n    snoc xs x = append xs (cons x Fin.elim0) :=\n  (append_right_eq_snoc xs (cons x Fin.elim0)).symm\n\n"}
{"name":"Fin.append_left_snoc","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n m : Nat\nα : Sort u_2\nxs : Fin n → α\nx : α\nys : Fin m → α\n⊢ Eq (Fin.append (Fin.snoc xs x) ys) (Function.comp (Fin.append xs (Fin.cons x ys)) (Fin.cast ⋯))","decl":"theorem append_left_snoc {n m} {α : Sort*} (xs : Fin n → α) (x : α) (ys : Fin m → α) :\n    Fin.append (Fin.snoc xs x) ys =\n      Fin.append xs (Fin.cons x ys) ∘ Fin.cast (Nat.succ_add_eq_add_succ ..) := by\n  rw [snoc_eq_append, append_assoc, append_left_eq_cons, append_cast_right]; rfl\n\n"}
{"name":"Fin.append_right_cons","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n m : Nat\nα : Sort u_2\nxs : Fin n → α\ny : α\nys : Fin m → α\n⊢ Eq (Fin.append xs (Fin.cons y ys)) (Function.comp (Fin.append (Fin.snoc xs y) ys) (Fin.cast ⋯))","decl":"theorem append_right_cons {n m} {α : Sort*} (xs : Fin n → α) (y : α) (ys : Fin m → α) :\n    Fin.append xs (Fin.cons y ys) =\n      Fin.append (Fin.snoc xs y) ys ∘ Fin.cast (Nat.succ_add_eq_add_succ ..).symm := by\n  rw [append_left_snoc]; rfl\n\n"}
{"name":"Fin.append_cons","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"m n : Nat\nα : Sort u_2\na : α\nas : Fin n → α\nbs : Fin m → α\n⊢ Eq (Fin.append (Fin.cons a as) bs) (Function.comp (Fin.cons a (Fin.append as bs)) (Fin.cast ⋯))","decl":"theorem append_cons {α : Sort*} (a : α) (as : Fin n → α) (bs : Fin m → α) :\n    Fin.append (cons a as) bs\n    = cons a (Fin.append as bs) ∘ (Fin.cast <| Nat.add_right_comm n 1 m) := by\n  funext i\n  rcases i with ⟨i, -⟩\n  simp only [append, addCases, cons, castLT, cast, comp_apply]\n  cases' i with i\n  · simp\n  · split_ifs with h\n    · have : i < n := Nat.lt_of_succ_lt_succ h\n      simp [addCases, this]\n    · have : ¬i < n := Nat.not_le.mpr <| Nat.lt_succ.mp <| Nat.not_le.mp h\n      simp [addCases, this]\n\n"}
{"name":"Fin.append_snoc","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"m n : Nat\nα : Sort u_2\nas : Fin n → α\nbs : Fin m → α\nb : α\n⊢ Eq (Fin.append as (Fin.snoc bs b)) (Fin.snoc (Fin.append as bs) b)","decl":"theorem append_snoc {α : Sort*} (as : Fin n → α) (bs : Fin m → α) (b : α) :\n    Fin.append as (snoc bs b) = snoc (Fin.append as bs) b := by\n  funext i\n  rcases i with ⟨i, isLt⟩\n  simp only [append, addCases, castLT, cast_mk, subNat_mk, natAdd_mk, cast, snoc.eq_1,\n    cast_eq, eq_rec_constant, Nat.add_eq, Nat.add_zero, castLT_mk]\n  split_ifs with lt_n lt_add sub_lt nlt_add lt_add <;> (try rfl)\n  · have := Nat.lt_add_right m lt_n\n    contradiction\n  · obtain rfl := Nat.eq_of_le_of_lt_succ (Nat.not_lt.mp nlt_add) isLt\n    simp [Nat.add_comm n m] at sub_lt\n  · have := Nat.sub_lt_left_of_lt_add (Nat.not_lt.mp lt_n) lt_add\n    contradiction\n\n"}
{"name":"Fin.comp_init","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_2\nβ : Sort u_3\ng : α → β\nq : Fin n.succ → α\n⊢ Eq (Function.comp g (Fin.init q)) (Fin.init (Function.comp g q))","decl":"theorem comp_init {α : Sort*} {β : Sort*} (g : α → β) (q : Fin n.succ → α) :\n    g ∘ init q = init (g ∘ q) := by\n  ext j\n  simp [init]\n\n"}
{"name":"Fin.snocEquiv_symm_apply","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_2\nf : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq ((Fin.snocEquiv α).symm f) { fst := f (Fin.last n), snd := Fin.init f }","decl":"/-- Equivalence between tuples of length `n + 1` and pairs of an element and a tuple of length `n`\ngiven by separating out the last element of the tuple.\n\nThis is `Fin.snoc` as an `Equiv`. -/\n@[simps]\ndef snocEquiv (α : Fin (n + 1) → Type*) : α (last n) × (∀ i, α (castSucc i)) ≃ ∀ i, α i where\n  toFun f _ := Fin.snoc f.2 f.1 _\n  invFun f := ⟨f _, Fin.init f⟩\n  left_inv f := by simp\n  right_inv f := by simp\n\n"}
{"name":"Fin.snocEquiv_apply","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_2\nf : Prod (α (Fin.last n)) ((i : Fin n) → α i.castSucc)\nx✝ : Fin (HAdd.hAdd n 1)\n⊢ Eq ((Fin.snocEquiv α) f x✝) (Fin.snoc f.2 f.1 x✝)","decl":"/-- Equivalence between tuples of length `n + 1` and pairs of an element and a tuple of length `n`\ngiven by separating out the last element of the tuple.\n\nThis is `Fin.snoc` as an `Equiv`. -/\n@[simps]\ndef snocEquiv (α : Fin (n + 1) → Type*) : α (last n) × (∀ i, α (castSucc i)) ≃ ∀ i, α i where\n  toFun f _ := Fin.snoc f.2 f.1 _\n  invFun f := ⟨f _, Fin.init f⟩\n  left_inv f := by simp\n  right_inv f := by simp\n\n"}
{"name":"Fin.snocCases_snoc","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nP : ((i : Fin (HAdd.hAdd n 1)) → α i) → Sort u_2\nh : (x : (i : Fin n) → α i.castSucc) → (x₀ : α (Fin.last n)) → P (Fin.snoc x x₀)\nx : (i : Fin n) → Fin.init α i\nx₀ : α (Fin.last n)\n⊢ Eq (Fin.snocCases h (Fin.snoc x x₀)) (h x x₀)","decl":"@[simp] lemma snocCases_snoc\n    {P : (∀ i : Fin (n+1), α i) → Sort*} (h : ∀ x x₀, P (Fin.snoc x x₀))\n    (x : ∀ i : Fin n, (Fin.init α) i) (x₀ : α (Fin.last _)) :\n    snocCases h (Fin.snoc x x₀) = h x x₀ := by\n  rw [snocCases, cast_eq_iff_heq, Fin.init_snoc, Fin.snoc_last]\n\n"}
{"name":"Fin.forall_iff_succ","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nP : Fin (HAdd.hAdd n 1) → Prop\n⊢ Iff (∀ (i : Fin (HAdd.hAdd n 1)), P i) (And (P 0) (∀ (i : Fin n), P i.succ))","decl":"alias forall_iff_succ := forall_fin_succ\n\n-- This is a duplicate of `Fin.exists_fin_succ` in Core. We should upstream the name change.\n"}
{"name":"Fin.exists_iff_succ","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nP : Fin (HAdd.hAdd n 1) → Prop\n⊢ Iff (Exists fun i => P i) (Or (P 0) (Exists fun i => P i.succ))","decl":"alias exists_iff_succ := exists_fin_succ\n\n"}
{"name":"Fin.forall_iff_castSucc","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nP : Fin (HAdd.hAdd n 1) → Prop\n⊢ Iff (∀ (i : Fin (HAdd.hAdd n 1)), P i) (And (P (Fin.last n)) (∀ (i : Fin n), P i.castSucc))","decl":"lemma forall_iff_castSucc {P : Fin (n + 1) → Prop} :\n    (∀ i, P i) ↔ P (last n) ∧ ∀ i : Fin n, P i.castSucc :=\n  ⟨fun h ↦ ⟨h _, fun _ ↦ h _⟩, fun h ↦ lastCases h.1 h.2⟩\n\n"}
{"name":"Fin.exists_iff_castSucc","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nP : Fin (HAdd.hAdd n 1) → Prop\n⊢ Iff (Exists fun i => P i) (Or (P (Fin.last n)) (Exists fun i => P i.castSucc))","decl":"lemma exists_iff_castSucc {P : Fin (n + 1) → Prop} :\n    (∃ i, P i) ↔ P (last n) ∨ ∃ i : Fin n, P i.castSucc where\n  mp := by\n    rintro ⟨i, hi⟩\n    induction' i using lastCases\n    · exact .inl hi\n    · exact .inr ⟨_, hi⟩\n  mpr := by rintro (h | ⟨i, hi⟩) <;> exact ⟨_, ‹_›⟩\n\n"}
{"name":"Fin.forall_iff_succAbove","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nP : Fin (HAdd.hAdd n 1) → Prop\np : Fin (HAdd.hAdd n 1)\n⊢ Iff (∀ (i : Fin (HAdd.hAdd n 1)), P i) (And (P p) (∀ (i : Fin n), P (p.succAbove i)))","decl":"theorem forall_iff_succAbove {P : Fin (n + 1) → Prop} (p : Fin (n + 1)) :\n    (∀ i, P i) ↔ P p ∧ ∀ i, P (p.succAbove i) :=\n  ⟨fun h ↦ ⟨h _, fun _ ↦ h _⟩, fun h ↦ succAboveCases p h.1 h.2⟩\n\n"}
{"name":"Fin.exists_iff_succAbove","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nP : Fin (HAdd.hAdd n 1) → Prop\np : Fin (HAdd.hAdd n 1)\n⊢ Iff (Exists fun i => P i) (Or (P p) (Exists fun i => P (p.succAbove i)))","decl":"lemma exists_iff_succAbove {P : Fin (n + 1) → Prop} (p : Fin (n + 1)) :\n    (∃ i, P i) ↔ P p ∨ ∃ i, P (p.succAbove i) where\n  mp := by\n    rintro ⟨i, hi⟩\n    induction' i using p.succAboveCases\n    · exact .inl hi\n    · exact .inr ⟨_, hi⟩\n  mpr := by rintro (h | ⟨i, hi⟩) <;> exact ⟨_, ‹_›⟩\n\n"}
{"name":"Fin.eq_self_or_eq_succAbove","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\np i : Fin (HAdd.hAdd n 1)\n⊢ Or (Eq i p) (Exists fun j => Eq i (p.succAbove j))","decl":"/-- Analogue of `Fin.eq_zero_or_eq_succ` for `succAbove`. -/\ntheorem eq_self_or_eq_succAbove (p i : Fin (n + 1)) : i = p ∨ ∃ j, i = p.succAbove j :=\n  succAboveCases p (.inl rfl) (fun j => .inr ⟨j, rfl⟩) i\n\n"}
{"name":"Fin.insertNth_apply_same","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\ni : Fin (HAdd.hAdd n 1)\nx : α i\np : (j : Fin n) → α (i.succAbove j)\n⊢ Eq (i.insertNth x p i) x","decl":"@[simp]\ntheorem insertNth_apply_same (i : Fin (n + 1)) (x : α i) (p : ∀ j, α (i.succAbove j)) :\n    insertNth i x p i = x := by simp [insertNth, succAboveCases]\n\n"}
{"name":"Fin.insertNth_apply_succAbove","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\ni : Fin (HAdd.hAdd n 1)\nx : α i\np : (j : Fin n) → α (i.succAbove j)\nj : Fin n\n⊢ Eq (i.insertNth x p (i.succAbove j)) (p j)","decl":"@[simp]\ntheorem insertNth_apply_succAbove (i : Fin (n + 1)) (x : α i) (p : ∀ j, α (i.succAbove j))\n    (j : Fin n) : insertNth i x p (i.succAbove j) = p j := by\n  simp only [insertNth, succAboveCases, dif_neg (succAbove_ne _ _), succAbove_lt_iff_castSucc_lt]\n  split_ifs with hlt\n  · generalize_proofs H₁ H₂; revert H₂\n    generalize hk : castPred ((succAbove i) j) H₁ = k\n    rw [castPred_succAbove _ _ hlt] at hk; cases hk\n    intro; rfl\n  · generalize_proofs H₀ H₁ H₂; revert H₂\n    generalize hk : pred (succAbove i j) H₁ = k\n    rw [pred_succAbove _ _ (Fin.not_lt.1 hlt)] at hk; cases hk\n    intro; rfl\n\n"}
{"name":"Fin.succAbove_cases_eq_insertNth","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"⊢ Eq @Fin.succAboveCases @Fin.insertNth","decl":"@[simp]\ntheorem succAbove_cases_eq_insertNth : @succAboveCases = @insertNth :=\n  rfl\n\n"}
{"name":"Fin.removeNth_insertNth","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\np : Fin (HAdd.hAdd n 1)\na : α p\nf : (i : Fin n) → α (p.succAbove i)\n⊢ Eq (p.removeNth (p.insertNth a f)) f","decl":"@[simp] lemma removeNth_insertNth (p : Fin (n + 1)) (a : α p) (f : ∀ i, α (succAbove p i)) :\n    removeNth p (insertNth p a f) = f := by ext; unfold removeNth; simp\n\n"}
{"name":"Fin.removeNth_zero","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nf : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq (Fin.removeNth 0 f) (Fin.tail f)","decl":"@[simp] lemma removeNth_zero (f : ∀ i, α i) : removeNth 0 f = tail f := by\n  ext; simp [tail, removeNth]\n\n"}
{"name":"Fin.removeNth_last","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Type u_3\nf : Fin (HAdd.hAdd n 1) → α\n⊢ Eq ((Fin.last n).removeNth f) (Fin.init f)","decl":"@[simp] lemma removeNth_last {α : Type*} (f : Fin (n + 1) → α) : removeNth (last n) f = init f := by\n  ext; simp [init, removeNth]\n\n/- Porting note: Had to `unfold comp`. Sometimes, when I use a placeholder, if I try to insert\nwhat Lean says it synthesized, it gives me a type error anyway. In this case, it's `x` and `p`. -/\n"}
{"name":"Fin.insertNth_comp_succAbove","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nβ : Sort u_2\ni : Fin (HAdd.hAdd n 1)\nx : β\np : Fin n → β\n⊢ Eq (Function.comp (i.insertNth x p) i.succAbove) p","decl":"@[simp]\ntheorem insertNth_comp_succAbove (i : Fin (n + 1)) (x : β) (p : Fin n → β) :\n    insertNth i x p ∘ i.succAbove = p :=\n  funext (by unfold comp; exact insertNth_apply_succAbove i _ _)\n\n"}
{"name":"Fin.insertNth_eq_iff","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\np : Fin (HAdd.hAdd n 1)\na : α p\nf : (i : Fin n) → α (p.succAbove i)\ng : (j : Fin (HAdd.hAdd n 1)) → α j\n⊢ Iff (Eq (p.insertNth a f) g) (And (Eq a (g p)) (Eq f (p.removeNth g)))","decl":"theorem insertNth_eq_iff {p : Fin (n + 1)} {a : α p} {f : ∀ i, α (p.succAbove i)} {g : ∀ j, α j} :\n    insertNth p a f = g ↔ a = g p ∧ f = removeNth p g := by\n  simp [funext_iff, forall_iff_succAbove p, removeNth]\n\n"}
{"name":"Fin.eq_insertNth_iff","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\np : Fin (HAdd.hAdd n 1)\na : α p\nf : (i : Fin n) → α (p.succAbove i)\ng : (j : Fin (HAdd.hAdd n 1)) → α j\n⊢ Iff (Eq g (p.insertNth a f)) (And (Eq (g p) a) (Eq (p.removeNth g) f))","decl":"theorem eq_insertNth_iff {p : Fin (n + 1)} {a : α p} {f : ∀ i, α (p.succAbove i)} {g : ∀ j, α j} :\n    g = insertNth p a f ↔ g p = a ∧ removeNth p g = f := by\n  simpa [eq_comm] using insertNth_eq_iff\n\n"}
{"name":"Fin.insertNth_injective2","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\np : Fin (HAdd.hAdd n 1)\n⊢ Function.Injective2 p.insertNth","decl":"/-- As a binary function, `Fin.insertNth` is injective. -/\ntheorem insertNth_injective2 {p : Fin (n + 1)} :\n    Function.Injective2 (@insertNth n α p) := fun xₚ yₚ x y h ↦\n  ⟨by simpa using congr_fun h p, funext fun i ↦ by simpa using congr_fun h (succAbove p i)⟩\n\n"}
{"name":"Fin.insertNth_inj","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\np : Fin (HAdd.hAdd n 1)\nx y : (i : Fin n) → α (p.succAbove i)\nxₚ yₚ : α p\n⊢ Iff (Eq (p.insertNth xₚ x) (p.insertNth yₚ y)) (And (Eq xₚ yₚ) (Eq x y))","decl":"@[simp]\ntheorem insertNth_inj {p : Fin (n + 1)} {x y : ∀ i, α (succAbove p i)} {xₚ yₚ : α p} :\n    insertNth p xₚ x = insertNth p yₚ y ↔ xₚ = yₚ ∧ x = y :=\n  insertNth_injective2.eq_iff\n\n"}
{"name":"Fin.insertNth_left_injective","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\np : Fin (HAdd.hAdd n 1)\nx : (i : Fin n) → α (p.succAbove i)\n⊢ Function.Injective fun x_1 => p.insertNth x_1 x","decl":"theorem insertNth_left_injective {p : Fin (n + 1)} (x : ∀ i, α (succAbove p i)) :\n    Function.Injective (insertNth p · x) :=\n  insertNth_injective2.left _\n\n"}
{"name":"Fin.insertNth_right_injective","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\np : Fin (HAdd.hAdd n 1)\nx : α p\n⊢ Function.Injective (p.insertNth x)","decl":"theorem insertNth_right_injective {p : Fin (n + 1)} (x : α p) :\n    Function.Injective (insertNth p x) :=\n  insertNth_injective2.right _\n\n/- Porting note: Once again, Lean told me `(fun x x_1 ↦ α x)` was an invalid motive, but disabling\nautomatic insertion and specifying that motive seems to work. -/\n"}
{"name":"Fin.insertNth_apply_below","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\ni j : Fin (HAdd.hAdd n 1)\nh : LT.lt j i\nx : α i\np : (k : Fin n) → α (i.succAbove k)\n⊢ Eq (i.insertNth x p j) (Eq.recOn ⋯ (p (j.castPred ⋯)))","decl":"theorem insertNth_apply_below {i j : Fin (n + 1)} (h : j < i) (x : α i)\n    (p : ∀ k, α (i.succAbove k)) :\n    i.insertNth x p j = @Eq.recOn _ _ (fun x _ ↦ α x) _\n    (succAbove_castPred_of_lt _ _ h) (p <| j.castPred _) := by\n  rw [insertNth, succAboveCases, dif_neg (Fin.ne_of_lt h), dif_pos h]\n\n/- Porting note: Once again, Lean told me `(fun x x_1 ↦ α x)` was an invalid motive, but disabling\nautomatic insertion and specifying that motive seems to work. -/\n"}
{"name":"Fin.insertNth_apply_above","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\ni j : Fin (HAdd.hAdd n 1)\nh : LT.lt i j\nx : α i\np : (k : Fin n) → α (i.succAbove k)\n⊢ Eq (i.insertNth x p j) (Eq.recOn ⋯ (p (j.pred ⋯)))","decl":"theorem insertNth_apply_above {i j : Fin (n + 1)} (h : i < j) (x : α i)\n    (p : ∀ k, α (i.succAbove k)) :\n    i.insertNth x p j = @Eq.recOn _ _ (fun x _ ↦ α x) _\n    (succAbove_pred_of_lt _ _ h) (p <| j.pred _) := by\n  rw [insertNth, succAboveCases, dif_neg (Fin.ne_of_gt h), dif_neg (Fin.lt_asymm h)]\n\n"}
{"name":"Fin.insertNth_zero","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nx : α 0\np : (j : Fin n) → α (Fin.succAbove 0 j)\n⊢ Eq (Fin.insertNth 0 x p) (Fin.cons x fun j => cast ⋯ (p j))","decl":"theorem insertNth_zero (x : α 0) (p : ∀ j : Fin n, α (succAbove 0 j)) :\n    insertNth 0 x p =\n      cons x fun j ↦ _root_.cast (congr_arg α (congr_fun succAbove_zero j)) (p j) := by\n  refine insertNth_eq_iff.2 ⟨by simp, ?_⟩\n  ext j\n  convert (cons_succ x p j).symm\n\n"}
{"name":"Fin.insertNth_zero'","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nβ : Sort u_2\nx : β\np : Fin n → β\n⊢ Eq (Fin.insertNth 0 x p) (Fin.cons x p)","decl":"@[simp]\ntheorem insertNth_zero' (x : β) (p : Fin n → β) : @insertNth _ (fun _ ↦ β) 0 x p = cons x p := by\n  simp [insertNth_zero]\n\n"}
{"name":"Fin.insertNth_last","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nx : α (Fin.last n)\np : (j : Fin n) → α ((Fin.last n).succAbove j)\n⊢ Eq ((Fin.last n).insertNth x p) (Fin.snoc (fun j => cast ⋯ (p j)) x)","decl":"theorem insertNth_last (x : α (last n)) (p : ∀ j : Fin n, α ((last n).succAbove j)) :\n    insertNth (last n) x p =\n      snoc (fun j ↦ _root_.cast (congr_arg α (succAbove_last_apply j)) (p j)) x := by\n  refine insertNth_eq_iff.2 ⟨by simp, ?_⟩\n  ext j\n  apply eq_of_heq\n  trans snoc (fun j ↦ _root_.cast (congr_arg α (succAbove_last_apply j)) (p j)) x j.castSucc\n  · rw [snoc_castSucc]\n    exact (cast_heq _ _).symm\n  · apply congr_arg_heq\n    rw [succAbove_last]\n\n"}
{"name":"Fin.insertNth_last'","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nβ : Sort u_2\nx : β\np : Fin n → β\n⊢ Eq ((Fin.last n).insertNth x p) (Fin.snoc p x)","decl":"@[simp]\ntheorem insertNth_last' (x : β) (p : Fin n → β) :\n    @insertNth _ (fun _ ↦ β) (last n) x p = snoc p x := by simp [insertNth_last]\n\n"}
{"name":"Fin.insertNth_rev","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_3\ni : Fin (HAdd.hAdd n 1)\na : α\nf : Fin n → α\nj : Fin (HAdd.hAdd n 1)\n⊢ Eq (i.insertNth a f j.rev) (i.rev.insertNth a (Function.comp f Fin.rev) j)","decl":"lemma insertNth_rev {α : Sort*} (i : Fin (n + 1)) (a : α) (f : Fin n → α) (j : Fin (n + 1)) :\n    insertNth (α := fun _ ↦ α) i a f (rev j) = insertNth (α := fun _ ↦ α) i.rev a (f ∘ rev) j := by\n  induction j using Fin.succAboveCases\n  · exact rev i\n  · simp\n  · simp [rev_succAbove]\n\n"}
{"name":"Fin.insertNth_comp_rev","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_3\ni : Fin (HAdd.hAdd n 1)\nx : α\np : Fin n → α\n⊢ Eq (Function.comp (i.insertNth x p) Fin.rev) (i.rev.insertNth x (Function.comp p Fin.rev))","decl":"theorem insertNth_comp_rev {α} (i : Fin (n + 1)) (x : α) (p : Fin n → α) :\n    (Fin.insertNth i x p) ∘ Fin.rev = Fin.insertNth (Fin.rev i) x (p ∘ Fin.rev) := by\n  funext x\n  apply insertNth_rev\n\n"}
{"name":"Fin.cons_rev","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Sort u_3\nn : Nat\na : α\nf : Fin n → α\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (Fin.cons a f i.rev) (Fin.snoc (Function.comp f Fin.rev) a i)","decl":"theorem cons_rev {α n} (a : α) (f : Fin n → α) (i : Fin <| n + 1) :\n    cons (α := fun _ => α) a f i.rev = snoc (α := fun _ => α) (f ∘ Fin.rev : Fin _ → α) a i := by\n  simpa using insertNth_rev 0 a f i\n\n"}
{"name":"Fin.cons_comp_rev","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Sort u_3\nn : Nat\na : α\nf : Fin n → α\n⊢ Eq (Function.comp (Fin.cons a f) Fin.rev) (Fin.snoc (Function.comp f Fin.rev) a)","decl":"theorem cons_comp_rev {α n} (a : α) (f : Fin n → α) :\n    Fin.cons a f ∘ Fin.rev = Fin.snoc (f ∘ Fin.rev) a := by\n  funext i; exact cons_rev ..\n\n"}
{"name":"Fin.snoc_rev","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Sort u_3\nn : Nat\na : α\nf : Fin n → α\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (Fin.snoc f a i.rev) (Fin.cons a (Function.comp f Fin.rev) i)","decl":"theorem snoc_rev {α n} (a : α) (f : Fin n → α) (i : Fin <| n + 1) :\n    snoc (α := fun _ => α) f a i.rev = cons (α := fun _ => α) a (f ∘ Fin.rev : Fin _ → α) i := by\n  simpa using insertNth_rev (last n) a f i\n\n"}
{"name":"Fin.snoc_comp_rev","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Sort u_3\nn : Nat\na : α\nf : Fin n → α\n⊢ Eq (Function.comp (Fin.snoc f a) Fin.rev) (Fin.cons a (Function.comp f Fin.rev))","decl":"theorem snoc_comp_rev {α n} (a : α) (f : Fin n → α) :\n    Fin.snoc f a ∘ Fin.rev = Fin.cons a (f ∘ Fin.rev) :=\n  funext <| snoc_rev a f\n\n"}
{"name":"Fin.insertNth_binop","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\nop : (j : Fin (HAdd.hAdd n 1)) → α j → α j → α j\ni : Fin (HAdd.hAdd n 1)\nx y : α i\np q : (j : Fin n) → α (i.succAbove j)\n⊢ Eq (i.insertNth (op i x y) fun j => op (i.succAbove j) (p j) (q j)) fun j => op j (i.insertNth x p j) (i.insertNth y q j)","decl":"theorem insertNth_binop (op : ∀ j, α j → α j → α j) (i : Fin (n + 1)) (x y : α i)\n    (p q : ∀ j, α (i.succAbove j)) :\n    (i.insertNth (op i x y) fun j ↦ op _ (p j) (q j)) = fun j ↦\n      op j (i.insertNth x p j) (i.insertNth y q j) :=\n  insertNth_eq_iff.2 <| by unfold removeNth; simp\n\n"}
{"name":"Fin.insertNth_le_iff","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_3\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → Preorder (α i)\ni : Fin (HAdd.hAdd n 1)\nx : α i\np : (j : Fin n) → α (i.succAbove j)\nq : (j : Fin (HAdd.hAdd n 1)) → α j\n⊢ Iff (LE.le (i.insertNth x p) q) (And (LE.le x (q i)) (LE.le p fun j => q (i.succAbove j)))","decl":"theorem insertNth_le_iff {i : Fin (n + 1)} {x : α i} {p : ∀ j, α (i.succAbove j)} {q : ∀ j, α j} :\n    i.insertNth x p ≤ q ↔ x ≤ q i ∧ p ≤ fun j ↦ q (i.succAbove j) := by\n  simp [Pi.le_def, forall_iff_succAbove i]\n\n"}
{"name":"Fin.le_insertNth_iff","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_3\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → Preorder (α i)\ni : Fin (HAdd.hAdd n 1)\nx : α i\np : (j : Fin n) → α (i.succAbove j)\nq : (j : Fin (HAdd.hAdd n 1)) → α j\n⊢ Iff (LE.le q (i.insertNth x p)) (And (LE.le (q i) x) (LE.le (fun j => q (i.succAbove j)) p))","decl":"theorem le_insertNth_iff {i : Fin (n + 1)} {x : α i} {p : ∀ j, α (i.succAbove j)} {q : ∀ j, α j} :\n    q ≤ i.insertNth x p ↔ q i ≤ x ∧ (fun j ↦ q (i.succAbove j)) ≤ p := by\n  simp [Pi.le_def, forall_iff_succAbove i]\n\n"}
{"name":"Fin.removeNth_update","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\np : Fin (HAdd.hAdd n 1)\nx : α p\nf : (j : Fin (HAdd.hAdd n 1)) → α j\n⊢ Eq (p.removeNth (Function.update f p x)) (p.removeNth f)","decl":"@[simp] lemma removeNth_update (p : Fin (n + 1)) (x) (f : ∀ j, α j) :\n    removeNth p (update f p x) = removeNth p f := by ext i; simp [removeNth, succAbove_ne]\n\n"}
{"name":"Fin.insertNth_removeNth","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\np : Fin (HAdd.hAdd n 1)\nx : α p\nf : (j : Fin (HAdd.hAdd n 1)) → α j\n⊢ Eq (p.insertNth x (p.removeNth f)) (Function.update f p x)","decl":"@[simp] lemma insertNth_removeNth (p : Fin (n + 1)) (x) (f : ∀ j, α j) :\n    insertNth p x (removeNth p f) = update f p x := by simp [Fin.insertNth_eq_iff]\n\n"}
{"name":"Fin.insertNth_self_removeNth","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\np : Fin (HAdd.hAdd n 1)\nf : (j : Fin (HAdd.hAdd n 1)) → α j\n⊢ Eq (p.insertNth (f p) (p.removeNth f)) f","decl":"lemma insertNth_self_removeNth (p : Fin (n + 1)) (f : ∀ j, α j) :\n    insertNth p (f p) (removeNth p f) = f := by simp\n\n"}
{"name":"Fin.update_insertNth","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Sort u_1\np : Fin (HAdd.hAdd n 1)\nx y : α p\nf : (i : Fin n) → α (p.succAbove i)\n⊢ Eq (Function.update (p.insertNth x f) p y) (p.insertNth y f)","decl":"@[simp]\ntheorem update_insertNth (p : Fin (n + 1)) (x y : α p) (f : ∀ i, α (p.succAbove i)) :\n    update (p.insertNth x f) p y = p.insertNth y f := by\n  ext i\n  cases i using p.succAboveCases <;> simp [succAbove_ne]\n\n"}
{"name":"Fin.insertNthEquiv_symm_apply","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u\np : Fin (HAdd.hAdd n 1)\nf : (i : Fin (HAdd.hAdd n 1)) → α i\n⊢ Eq ((Fin.insertNthEquiv α p).symm f) { fst := f p, snd := p.removeNth f }","decl":"/-- Equivalence between tuples of length `n + 1` and pairs of an element and a tuple of length `n`\ngiven by separating out the `p`-th element of the tuple.\n\nThis is `Fin.insertNth` as an `Equiv`. -/\n@[simps]\ndef insertNthEquiv (α : Fin (n + 1) → Type u) (p : Fin (n + 1)) :\n    α p × (∀ i, α (p.succAbove i)) ≃ ∀ i, α i where\n  toFun f := insertNth p f.1 f.2\n  invFun f := (f p, removeNth p f)\n  left_inv f := by ext <;> simp\n  right_inv f := by simp\n\n"}
{"name":"Fin.insertNthEquiv_apply","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u\np : Fin (HAdd.hAdd n 1)\nf : Prod (α p) ((i : Fin n) → α (p.succAbove i))\nj : Fin (HAdd.hAdd n 1)\n⊢ Eq ((Fin.insertNthEquiv α p) f j) (p.insertNth f.1 f.2 j)","decl":"/-- Equivalence between tuples of length `n + 1` and pairs of an element and a tuple of length `n`\ngiven by separating out the `p`-th element of the tuple.\n\nThis is `Fin.insertNth` as an `Equiv`. -/\n@[simps]\ndef insertNthEquiv (α : Fin (n + 1) → Type u) (p : Fin (n + 1)) :\n    α p × (∀ i, α (p.succAbove i)) ≃ ∀ i, α i where\n  toFun f := insertNth p f.1 f.2\n  invFun f := (f p, removeNth p f)\n  left_inv f := by ext <;> simp\n  right_inv f := by simp\n\n"}
{"name":"Fin.insertNthEquiv_zero","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_3\n⊢ Eq (Fin.insertNthEquiv α 0) (Fin.consEquiv α)","decl":"@[simp] lemma insertNthEquiv_zero (α : Fin (n + 1) → Type*) : insertNthEquiv α 0 = consEquiv α :=\n  Equiv.symm_bijective.injective <| by ext <;> rfl\n\n"}
{"name":"Fin.insertNthEquiv_last","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Type u_3\n⊢ Eq (Fin.insertNthEquiv (fun x => α) (Fin.last n)) (Fin.snocEquiv fun x => α)","decl":"/-- Note this lemma can only be written about non-dependent tuples as `insertNth (last n) = snoc` is\nnot a definitional equality. -/\n@[simp] lemma insertNthEquiv_last (n : ℕ) (α : Type*) :\n    insertNthEquiv (fun _ ↦ α) (last n) = snocEquiv (fun _ ↦ α) := by ext; simp\n\n"}
{"name":"Fin.find_spec","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\np : Fin n → Prop\ninst✝ : DecidablePred p\ni : Fin n\nx✝ : Membership.mem (Fin.find p) i\n⊢ p i","decl":"/-- If `find p = some i`, then `p i` holds -/\ntheorem find_spec :\n    ∀ {n : ℕ} (p : Fin n → Prop) [DecidablePred p] {i : Fin n} (_ : i ∈ Fin.find p), p i\n  | 0, _, _, _, hi => Option.noConfusion hi\n  | n + 1, p, I, i, hi => by\n    rw [find] at hi\n    cases' h : find fun i : Fin n ↦ p (i.castLT (Nat.lt_succ_of_lt i.2)) with j\n    · rw [h] at hi\n      dsimp at hi\n      split_ifs at hi with hl\n      · simp only [Option.mem_def, Option.some.injEq] at hi\n        exact hi ▸ hl\n      · exact (Option.not_mem_none _ hi).elim\n    · rw [h] at hi\n      dsimp at hi\n      rw [← Option.some_inj.1 hi]\n      exact @find_spec n (fun i ↦ p (i.castLT (Nat.lt_succ_of_lt i.2))) _ _ h\n\n"}
{"name":"Fin.isSome_find_iff","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\np : Fin n → Prop\ninst✝ : DecidablePred p\n⊢ Iff (Eq (Fin.find p).isSome Bool.true) (Exists fun i => p i)","decl":"/-- `find p` does not return `none` if and only if `p i` holds at some index `i`. -/\ntheorem isSome_find_iff :\n    ∀ {n : ℕ} {p : Fin n → Prop} [DecidablePred p], (find p).isSome ↔ ∃ i, p i\n  | 0, _, _ => iff_of_false (fun h ↦ Bool.noConfusion h) fun ⟨i, _⟩ ↦ Fin.elim0 i\n  | n + 1, p, _ =>\n    ⟨fun h ↦ by\n      rw [Option.isSome_iff_exists] at h\n      cases' h with i hi\n      exact ⟨i, find_spec _ hi⟩, fun ⟨⟨i, hin⟩, hi⟩ ↦ by\n      dsimp [find]\n      cases' h : find fun i : Fin n ↦ p (i.castLT (Nat.lt_succ_of_lt i.2)) with j\n      · split_ifs with hl\n        · exact Option.isSome_some\n        · have := (@isSome_find_iff n (fun x ↦ p (x.castLT (Nat.lt_succ_of_lt x.2))) _).2\n              ⟨⟨i, lt_of_le_of_ne (Nat.le_of_lt_succ hin) fun h ↦ by cases h; exact hl hi⟩, hi⟩\n          rw [h] at this\n          exact this\n      · simp⟩\n\n"}
{"name":"Fin.find_eq_none_iff","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\np : Fin n → Prop\ninst✝ : DecidablePred p\n⊢ Iff (Eq (Fin.find p) Option.none) (∀ (i : Fin n), Not (p i))","decl":"/-- `find p` returns `none` if and only if `p i` never holds. -/\ntheorem find_eq_none_iff {n : ℕ} {p : Fin n → Prop} [DecidablePred p] :\n    find p = none ↔ ∀ i, ¬p i := by rw [← not_exists, ← isSome_find_iff]; cases find p <;> simp\n\n"}
{"name":"Fin.find_min","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\np : Fin n → Prop\ninst✝ : DecidablePred p\ni : Fin n\nx✝¹ : Membership.mem (Fin.find p) i\nj : Fin n\nx✝ : LT.lt j i\n⊢ Not (p j)","decl":"/-- If `find p` returns `some i`, then `p j` does not hold for `j < i`, i.e., `i` is minimal among\nthe indices where `p` holds. -/\ntheorem find_min :\n    ∀ {n : ℕ} {p : Fin n → Prop} [DecidablePred p] {i : Fin n} (_ : i ∈ Fin.find p) {j : Fin n}\n      (_ : j < i), ¬p j\n  | 0, _, _, _, hi, _, _, _ => Option.noConfusion hi\n  | n + 1, p, _, i, hi, ⟨j, hjn⟩, hj, hpj => by\n    rw [find] at hi\n    cases' h : find fun i : Fin n ↦ p (i.castLT (Nat.lt_succ_of_lt i.2)) with k\n    · simp only [h] at hi\n      split_ifs at hi with hl\n      · cases hi\n        rw [find_eq_none_iff] at h\n        exact h ⟨j, hj⟩ hpj\n      · exact Option.not_mem_none _ hi\n    · rw [h] at hi\n      dsimp at hi\n      obtain rfl := Option.some_inj.1 hi\n      exact find_min h (show (⟨j, lt_trans hj k.2⟩ : Fin n) < k from hj) hpj\n\n"}
{"name":"Fin.find_min'","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\np : Fin n → Prop\ninst✝ : DecidablePred p\ni : Fin n\nh : Membership.mem (Fin.find p) i\nj : Fin n\nhj : p j\n⊢ LE.le i j","decl":"theorem find_min' {p : Fin n → Prop} [DecidablePred p] {i : Fin n} (h : i ∈ Fin.find p) {j : Fin n}\n    (hj : p j) : i ≤ j := Fin.not_lt.1 fun hij ↦ find_min h hij hj\n\n"}
{"name":"Fin.nat_find_mem_find","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\np : Fin n → Prop\ninst✝ : DecidablePred p\nh : Exists fun i => Exists fun hin => p ⟨i, hin⟩\n⊢ Membership.mem (Fin.find p) ⟨Nat.find h, ⋯⟩","decl":"theorem nat_find_mem_find {p : Fin n → Prop} [DecidablePred p]\n    (h : ∃ i, ∃ hin : i < n, p ⟨i, hin⟩) :\n    (⟨Nat.find h, (Nat.find_spec h).fst⟩ : Fin n) ∈ find p := by\n  let ⟨i, hin, hi⟩ := h\n  cases' hf : find p with f\n  · rw [find_eq_none_iff] at hf\n    exact (hf ⟨i, hin⟩ hi).elim\n  · refine Option.some_inj.2 (Fin.le_antisymm ?_ ?_)\n    · exact find_min' hf (Nat.find_spec h).snd\n    · exact Nat.find_min' _ ⟨f.2, by convert find_spec p hf⟩\n\n"}
{"name":"Fin.mem_find_iff","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\np : Fin n → Prop\ninst✝ : DecidablePred p\ni : Fin n\n⊢ Iff (Membership.mem (Fin.find p) i) (And (p i) (∀ (j : Fin n), p j → LE.le i j))","decl":"theorem mem_find_iff {p : Fin n → Prop} [DecidablePred p] {i : Fin n} :\n    i ∈ Fin.find p ↔ p i ∧ ∀ j, p j → i ≤ j :=\n  ⟨fun hi ↦ ⟨find_spec _ hi, fun _ ↦ find_min' hi⟩, by\n    rintro ⟨hpi, hj⟩\n    cases hfp : Fin.find p\n    · rw [find_eq_none_iff] at hfp\n      exact (hfp _ hpi).elim\n    · exact Option.some_inj.2 (Fin.le_antisymm (find_min' hfp hpi) (hj _ (find_spec _ hfp)))⟩\n\n"}
{"name":"Fin.find_eq_some_iff","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\np : Fin n → Prop\ninst✝ : DecidablePred p\ni : Fin n\n⊢ Iff (Eq (Fin.find p) (Option.some i)) (And (p i) (∀ (j : Fin n), p j → LE.le i j))","decl":"theorem find_eq_some_iff {p : Fin n → Prop} [DecidablePred p] {i : Fin n} :\n    Fin.find p = some i ↔ p i ∧ ∀ j, p j → i ≤ j :=\n  mem_find_iff\n\n"}
{"name":"Fin.mem_find_of_unique","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\np : Fin n → Prop\ninst✝ : DecidablePred p\nh : ∀ (i j : Fin n), p i → p j → Eq i j\ni : Fin n\nhi : p i\n⊢ Membership.mem (Fin.find p) i","decl":"theorem mem_find_of_unique {p : Fin n → Prop} [DecidablePred p] (h : ∀ i j, p i → p j → i = j)\n    {i : Fin n} (hi : p i) : i ∈ Fin.find p :=\n  mem_find_iff.2 ⟨hi, fun j hj ↦ Fin.le_of_eq <| h i j hi hj⟩\n\n"}
{"name":"Fin.contractNth_apply_of_lt","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_1\nj : Fin (HAdd.hAdd n 1)\nop : α → α → α\ng : Fin (HAdd.hAdd n 1) → α\nk : Fin n\nh : LT.lt ↑k ↑j\n⊢ Eq (j.contractNth op g k) (g k.castSucc)","decl":"theorem contractNth_apply_of_lt (j : Fin (n + 1)) (op : α → α → α) (g : Fin (n + 1) → α) (k : Fin n)\n    (h : (k : ℕ) < j) : contractNth j op g k = g (Fin.castSucc k) :=\n  if_pos h\n\n"}
{"name":"Fin.contractNth_apply_of_eq","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_1\nj : Fin (HAdd.hAdd n 1)\nop : α → α → α\ng : Fin (HAdd.hAdd n 1) → α\nk : Fin n\nh : Eq ↑k ↑j\n⊢ Eq (j.contractNth op g k) (op (g k.castSucc) (g k.succ))","decl":"theorem contractNth_apply_of_eq (j : Fin (n + 1)) (op : α → α → α) (g : Fin (n + 1) → α) (k : Fin n)\n    (h : (k : ℕ) = j) : contractNth j op g k = op (g (Fin.castSucc k)) (g k.succ) := by\n  have : ¬(k : ℕ) < j := not_lt.2 (le_of_eq h.symm)\n  rw [contractNth, if_neg this, if_pos h]\n\n"}
{"name":"Fin.contractNth_apply_of_gt","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_1\nj : Fin (HAdd.hAdd n 1)\nop : α → α → α\ng : Fin (HAdd.hAdd n 1) → α\nk : Fin n\nh : LT.lt ↑j ↑k\n⊢ Eq (j.contractNth op g k) (g k.succ)","decl":"theorem contractNth_apply_of_gt (j : Fin (n + 1)) (op : α → α → α) (g : Fin (n + 1) → α) (k : Fin n)\n    (h : (j : ℕ) < k) : contractNth j op g k = g k.succ := by\n  rw [contractNth, if_neg (not_lt_of_gt h), if_neg (Ne.symm <| ne_of_lt h)]\n\n"}
{"name":"Fin.contractNth_apply_of_ne","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"n : Nat\nα : Sort u_1\nj : Fin (HAdd.hAdd n 1)\nop : α → α → α\ng : Fin (HAdd.hAdd n 1) → α\nk : Fin n\nhjk : Ne ↑j ↑k\n⊢ Eq (j.contractNth op g k) (g (j.succAbove k))","decl":"theorem contractNth_apply_of_ne (j : Fin (n + 1)) (op : α → α → α) (g : Fin (n + 1) → α) (k : Fin n)\n    (hjk : (j : ℕ) ≠ k) : contractNth j op g k = g (j.succAbove k) := by\n  rcases lt_trichotomy (k : ℕ) j with (h | h | h)\n  · rwa [j.succAbove_of_castSucc_lt, contractNth_apply_of_lt]\n    · rwa [Fin.lt_iff_val_lt_val]\n  · exact False.elim (hjk h.symm)\n  · rwa [j.succAbove_of_le_castSucc, contractNth_apply_of_gt]\n    · exact Fin.le_iff_val_le_val.2 (le_of_lt h)\n\n"}
{"name":"Fin.sigma_eq_of_eq_comp_cast","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Type u_1\na b : Sigma fun ii => Fin ii → α\nh : Eq a.fst b.fst\na✝ : Eq a.snd (Function.comp b.snd (Fin.cast h))\n⊢ Eq a b","decl":"/-- To show two sigma pairs of tuples agree, it to show the second elements are related via\n`Fin.cast`. -/\ntheorem sigma_eq_of_eq_comp_cast {α : Type*} :\n    ∀ {a b : Σii, Fin ii → α} (h : a.fst = b.fst), a.snd = b.snd ∘ Fin.cast h → a = b\n  | ⟨ai, a⟩, ⟨bi, b⟩, hi, h => by\n    dsimp only at hi\n    subst hi\n    simpa using h\n\n"}
{"name":"Fin.sigma_eq_iff_eq_comp_cast","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Type u_1\na b : Sigma fun ii => Fin ii → α\n⊢ Iff (Eq a b) (Exists fun h => Eq a.snd (Function.comp b.snd (Fin.cast h)))","decl":"/-- `Fin.sigma_eq_of_eq_comp_cast` as an `iff`. -/\ntheorem sigma_eq_iff_eq_comp_cast {α : Type*} {a b : Σii, Fin ii → α} :\n    a = b ↔ ∃ h : a.fst = b.fst, a.snd = b.snd ∘ Fin.cast h :=\n  ⟨fun h ↦ h ▸ ⟨rfl, funext <| Fin.rec fun _ _ ↦ rfl⟩, fun ⟨_, h'⟩ ↦\n    sigma_eq_of_eq_comp_cast _ h'⟩\n\n"}
{"name":"piFinTwoEquiv_symm_apply","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Fin 2 → Type u\n⊢ Eq ⇑(piFinTwoEquiv α).symm fun p => Fin.cons p.1 (Fin.cons p.2 finZeroElim)","decl":"/-- `Π i : Fin 2, α i` is equivalent to `α 0 × α 1`. See also `finTwoArrowEquiv` for a\nnon-dependent version and `prodEquivPiFinTwo` for a version with inputs `α β : Type u`. -/\n@[simps (config := .asFn)]\ndef piFinTwoEquiv (α : Fin 2 → Type u) : (∀ i, α i) ≃ α 0 × α 1 where\n  toFun f := (f 0, f 1)\n  invFun p := Fin.cons p.1 <| Fin.cons p.2 finZeroElim\n  left_inv _ := funext <| Fin.forall_fin_two.2 ⟨rfl, rfl⟩\n  right_inv := fun _ => rfl\n"}
{"name":"piFinTwoEquiv_apply","module":"Mathlib.Data.Fin.Tuple.Basic","initialProofState":"α : Fin 2 → Type u\n⊢ Eq ⇑(piFinTwoEquiv α) fun f => { fst := f 0, snd := f 1 }","decl":"/-- `Π i : Fin 2, α i` is equivalent to `α 0 × α 1`. See also `finTwoArrowEquiv` for a\nnon-dependent version and `prodEquivPiFinTwo` for a version with inputs `α β : Type u`. -/\n@[simps (config := .asFn)]\ndef piFinTwoEquiv (α : Fin 2 → Type u) : (∀ i, α i) ≃ α 0 × α 1 where\n  toFun f := (f 0, f 1)\n  invFun p := Fin.cons p.1 <| Fin.cons p.2 finZeroElim\n  left_inv _ := funext <| Fin.forall_fin_two.2 ⟨rfl, rfl⟩\n  right_inv := fun _ => rfl\n"}
