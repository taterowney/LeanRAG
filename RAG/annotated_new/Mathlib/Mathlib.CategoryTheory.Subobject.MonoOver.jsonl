{"name":"CategoryTheory.MonoOver.mk'_obj","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX A : C\nf : Quiver.Hom A X\nhf : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.MonoOver.mk' f).obj (CategoryTheory.Over.mk f)","decl":"/-- Construct a `MonoOver X`. -/\n@[simps]\ndef mk' {X A : C} (f : A ⟶ X) [hf : Mono f] : MonoOver X where\n  obj := Over.mk f\n  property := hf\n\n"}
{"name":"CategoryTheory.MonoOver.forget_obj_left","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nf : CategoryTheory.MonoOver X\n⊢ Eq ((CategoryTheory.MonoOver.forget X).obj f).left f.obj.left","decl":"@[simp]\ntheorem forget_obj_left {f} : ((forget X).obj f).left = (f : C) :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.mk'_coe'","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX A : C\nf : Quiver.Hom A X\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.MonoOver.mk' f).obj.left A","decl":"@[simp]\ntheorem mk'_coe' {X A : C} (f : A ⟶ X) [Mono f] : (mk' f : C) = A :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.mk'_arrow","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX A : C\nf : Quiver.Hom A X\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.MonoOver.mk' f).arrow f","decl":"@[simp]\ntheorem mk'_arrow {X A : C} (f : A ⟶ X) [Mono f] : (mk' f).arrow = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.forget_obj_hom","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nf : CategoryTheory.MonoOver X\n⊢ Eq ((CategoryTheory.MonoOver.forget X).obj f).hom f.arrow","decl":"@[simp]\ntheorem forget_obj_hom {f} : ((forget X).obj f).hom = f.arrow :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.instFullOverForget","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ (CategoryTheory.MonoOver.forget X).Full","decl":"instance : (forget X).Full :=\n  FullSubcategory.full _\n\n"}
{"name":"CategoryTheory.MonoOver.instFaithfulOverForget","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ (CategoryTheory.MonoOver.forget X).Faithful","decl":"instance : (forget X).Faithful :=\n  FullSubcategory.faithful _\n\n"}
{"name":"CategoryTheory.MonoOver.mono","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nf : CategoryTheory.MonoOver X\n⊢ CategoryTheory.Mono f.arrow","decl":"instance mono (f : MonoOver X) : Mono f.arrow :=\n  f.property\n\n"}
{"name":"CategoryTheory.MonoOver.isThin","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ Quiver.IsThin (CategoryTheory.MonoOver X)","decl":"/-- The category of monomorphisms over X is a thin category,\nwhich makes defining its skeleton easy. -/\ninstance isThin {X : C} : Quiver.IsThin (MonoOver X) := fun f g =>\n  ⟨by\n    intro h₁ h₂\n    apply Over.OverMorphism.ext\n    erw [← cancel_mono g.arrow, Over.w h₁, Over.w h₂]⟩\n\n"}
{"name":"CategoryTheory.MonoOver.w","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nf g : CategoryTheory.MonoOver X\nk : Quiver.Hom f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp k.left g.arrow) f.arrow","decl":"@[reassoc]\ntheorem w {f g : MonoOver X} (k : f ⟶ g) : k.left ≫ g.arrow = f.arrow :=\n  Over.w _\n\n"}
{"name":"CategoryTheory.MonoOver.w_assoc","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nf g : CategoryTheory.MonoOver X\nk : Quiver.Hom f g\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp k.left (CategoryTheory.CategoryStruct.comp g.arrow h)) (CategoryTheory.CategoryStruct.comp f.arrow h)","decl":"@[reassoc]\ntheorem w {f g : MonoOver X} (k : f ⟶ g) : k.left ≫ g.arrow = f.arrow :=\n  Over.w _\n\n"}
{"name":"CategoryTheory.MonoOver.isoMk_hom","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nf g : CategoryTheory.MonoOver X\nh : CategoryTheory.Iso f.obj.left g.obj.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp h.hom g.arrow) f.arrow) _auto✝\n⊢ Eq (CategoryTheory.MonoOver.isoMk h w).hom (CategoryTheory.MonoOver.homMk h.hom w)","decl":"/-- Convenience constructor for an isomorphism in monomorphisms over `X`. -/\n@[simps]\ndef isoMk {f g : MonoOver X} (h : f.obj.left ≅ g.obj.left)\n    (w : h.hom ≫ g.arrow = f.arrow := by aesop_cat) : f ≅ g where\n  hom := homMk h.hom w\n  inv := homMk h.inv (by rw [h.inv_comp_eq, w])\n\n"}
{"name":"CategoryTheory.MonoOver.isoMk_inv","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nf g : CategoryTheory.MonoOver X\nh : CategoryTheory.Iso f.obj.left g.obj.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp h.hom g.arrow) f.arrow) _auto✝\n⊢ Eq (CategoryTheory.MonoOver.isoMk h w).inv (CategoryTheory.MonoOver.homMk h.inv ⋯)","decl":"/-- Convenience constructor for an isomorphism in monomorphisms over `X`. -/\n@[simps]\ndef isoMk {f g : MonoOver X} (h : f.obj.left ≅ g.obj.left)\n    (w : h.hom ≫ g.arrow = f.arrow := by aesop_cat) : f ≅ g where\n  hom := homMk h.hom w\n  inv := homMk h.inv (by rw [h.inv_comp_eq, w])\n\n"}
{"name":"CategoryTheory.MonoOver.lift_obj_obj","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nY : D\nF : CategoryTheory.Functor (CategoryTheory.Over Y) (CategoryTheory.Over X)\nh : ∀ (f : CategoryTheory.MonoOver Y), CategoryTheory.Mono (F.obj ((CategoryTheory.MonoOver.forget Y).obj f)).hom\nf : CategoryTheory.MonoOver Y\n⊢ Eq ((CategoryTheory.MonoOver.lift F h).obj f).obj (F.obj ((CategoryTheory.MonoOver.forget Y).obj f))","decl":"/-- Lift a functor between over categories to a functor between `MonoOver` categories,\ngiven suitable evidence that morphisms are taken to monomorphisms.\n-/\n@[simps]\ndef lift {Y : D} (F : Over Y ⥤ Over X)\n    (h : ∀ f : MonoOver Y, Mono (F.obj ((MonoOver.forget Y).obj f)).hom) :\n    MonoOver Y ⥤ MonoOver X where\n  obj f := ⟨_, h f⟩\n  map k := (MonoOver.forget Y ⋙ F).map k\n\n"}
{"name":"CategoryTheory.MonoOver.lift_map","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nY : D\nF : CategoryTheory.Functor (CategoryTheory.Over Y) (CategoryTheory.Over X)\nh : ∀ (f : CategoryTheory.MonoOver Y), CategoryTheory.Mono (F.obj ((CategoryTheory.MonoOver.forget Y).obj f)).hom\nX✝ Y✝ : CategoryTheory.MonoOver Y\nk : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.MonoOver.lift F h).map k) (((CategoryTheory.MonoOver.forget Y).comp F).map k)","decl":"/-- Lift a functor between over categories to a functor between `MonoOver` categories,\ngiven suitable evidence that morphisms are taken to monomorphisms.\n-/\n@[simps]\ndef lift {Y : D} (F : Over Y ⥤ Over X)\n    (h : ∀ f : MonoOver Y, Mono (F.obj ((MonoOver.forget Y).obj f)).hom) :\n    MonoOver Y ⥤ MonoOver X where\n  obj f := ⟨_, h f⟩\n  map k := (MonoOver.forget Y ⋙ F).map k\n\n"}
{"name":"CategoryTheory.MonoOver.lift_comm","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nF : CategoryTheory.Functor (CategoryTheory.Over Y) (CategoryTheory.Over X)\nh : ∀ (f : CategoryTheory.MonoOver Y), CategoryTheory.Mono (F.obj ((CategoryTheory.MonoOver.forget Y).obj f)).hom\n⊢ Eq ((CategoryTheory.MonoOver.lift F h).comp (CategoryTheory.MonoOver.forget X)) ((CategoryTheory.MonoOver.forget Y).comp F)","decl":"@[simp]\ntheorem lift_comm (F : Over Y ⥤ Over X)\n    (h : ∀ f : MonoOver Y, Mono (F.obj ((MonoOver.forget Y).obj f)).hom) :\n    lift F h ⋙ MonoOver.forget X = MonoOver.forget Y ⋙ F :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.lift_obj_arrow","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nY : D\nF : CategoryTheory.Functor (CategoryTheory.Over Y) (CategoryTheory.Over X)\nh : ∀ (f : CategoryTheory.MonoOver Y), CategoryTheory.Mono (F.obj ((CategoryTheory.MonoOver.forget Y).obj f)).hom\nf : CategoryTheory.MonoOver Y\n⊢ Eq ((CategoryTheory.MonoOver.lift F h).obj f).arrow (F.obj ((CategoryTheory.MonoOver.forget Y).obj f)).hom","decl":"@[simp]\ntheorem lift_obj_arrow {Y : D} (F : Over Y ⥤ Over X)\n    (h : ∀ f : MonoOver Y, Mono (F.obj ((MonoOver.forget Y).obj f)).hom) (f : MonoOver Y) :\n    ((lift F h).obj f).arrow = (F.obj ((forget Y).obj f)).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.pullback_obj_left","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nf : Quiver.Hom X Y\ng : CategoryTheory.MonoOver Y\n⊢ Eq ((CategoryTheory.MonoOver.pullback f).obj g).obj.left (CategoryTheory.Limits.pullback g.arrow f)","decl":"@[simp]\ntheorem pullback_obj_left (f : X ⟶ Y) (g : MonoOver Y) :\n    ((pullback f).obj g : C) = Limits.pullback g.arrow f :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.pullback_obj_arrow","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nf : Quiver.Hom X Y\ng : CategoryTheory.MonoOver Y\n⊢ Eq ((CategoryTheory.MonoOver.pullback f).obj g).arrow (CategoryTheory.Limits.pullback.snd ((CategoryTheory.MonoOver.forget Y).obj g).hom f)","decl":"@[simp]\ntheorem pullback_obj_arrow (f : X ⟶ Y) (g : MonoOver Y) :\n    ((pullback f).obj g).arrow = pullback.snd _ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.map_obj_left","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\ng : CategoryTheory.MonoOver X\n⊢ Eq ((CategoryTheory.MonoOver.map f).obj g).obj.left g.obj.left","decl":"@[simp]\ntheorem map_obj_left (f : X ⟶ Y) [Mono f] (g : MonoOver X) : ((map f).obj g : C) = g.obj.left :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.map_obj_arrow","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\ng : CategoryTheory.MonoOver X\n⊢ Eq ((CategoryTheory.MonoOver.map f).obj g).arrow (CategoryTheory.CategoryStruct.comp g.arrow f)","decl":"@[simp]\ntheorem map_obj_arrow (f : X ⟶ Y) [Mono f] (g : MonoOver X) : ((map f).obj g).arrow = g.arrow ≫ f :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.full_map","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ (CategoryTheory.MonoOver.map f).Full","decl":"instance full_map (f : X ⟶ Y) [Mono f] : Functor.Full (map f) where\n  map_surjective {g h} e := by\n    refine ⟨homMk e.left ?_, rfl⟩\n    · rw [← cancel_mono f, assoc]\n      apply w e\n\n"}
{"name":"CategoryTheory.MonoOver.faithful_map","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ (CategoryTheory.MonoOver.map f).Faithful","decl":"instance faithful_map (f : X ⟶ Y) [Mono f] : Functor.Faithful (map f) where\n\n"}
{"name":"CategoryTheory.MonoOver.mapIso_unitIso","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ne : CategoryTheory.Iso A B\n⊢ Eq (CategoryTheory.MonoOver.mapIso e).unitIso ((CategoryTheory.MonoOver.mapComp e.hom e.inv).symm.trans ((CategoryTheory.eqToIso ⋯).trans (CategoryTheory.MonoOver.mapId A))).symm","decl":"/-- Isomorphic objects have equivalent `MonoOver` categories.\n-/\n@[simps]\ndef mapIso {A B : C} (e : A ≅ B) : MonoOver A ≌ MonoOver B where\n  functor := map e.hom\n  inverse := map e.inv\n  unitIso := ((mapComp _ _).symm ≪≫ eqToIso (by simp) ≪≫ (mapId _)).symm\n  counitIso := (mapComp _ _).symm ≪≫ eqToIso (by simp) ≪≫ (mapId _)\n\n"}
{"name":"CategoryTheory.MonoOver.mapIso_counitIso","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ne : CategoryTheory.Iso A B\n⊢ Eq (CategoryTheory.MonoOver.mapIso e).counitIso ((CategoryTheory.MonoOver.mapComp e.inv e.hom).symm.trans ((CategoryTheory.eqToIso ⋯).trans (CategoryTheory.MonoOver.mapId B)))","decl":"/-- Isomorphic objects have equivalent `MonoOver` categories.\n-/\n@[simps]\ndef mapIso {A B : C} (e : A ≅ B) : MonoOver A ≌ MonoOver B where\n  functor := map e.hom\n  inverse := map e.inv\n  unitIso := ((mapComp _ _).symm ≪≫ eqToIso (by simp) ≪≫ (mapId _)).symm\n  counitIso := (mapComp _ _).symm ≪≫ eqToIso (by simp) ≪≫ (mapId _)\n\n"}
{"name":"CategoryTheory.MonoOver.mapIso_inverse","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ne : CategoryTheory.Iso A B\n⊢ Eq (CategoryTheory.MonoOver.mapIso e).inverse (CategoryTheory.MonoOver.map e.inv)","decl":"/-- Isomorphic objects have equivalent `MonoOver` categories.\n-/\n@[simps]\ndef mapIso {A B : C} (e : A ≅ B) : MonoOver A ≌ MonoOver B where\n  functor := map e.hom\n  inverse := map e.inv\n  unitIso := ((mapComp _ _).symm ≪≫ eqToIso (by simp) ≪≫ (mapId _)).symm\n  counitIso := (mapComp _ _).symm ≪≫ eqToIso (by simp) ≪≫ (mapId _)\n\n"}
{"name":"CategoryTheory.MonoOver.mapIso_functor","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : C\ne : CategoryTheory.Iso A B\n⊢ Eq (CategoryTheory.MonoOver.mapIso e).functor (CategoryTheory.MonoOver.map e.hom)","decl":"/-- Isomorphic objects have equivalent `MonoOver` categories.\n-/\n@[simps]\ndef mapIso {A B : C} (e : A ≅ B) : MonoOver A ≌ MonoOver B where\n  functor := map e.hom\n  inverse := map e.inv\n  unitIso := ((mapComp _ _).symm ≪≫ eqToIso (by simp) ≪≫ (mapId _)).symm\n  counitIso := (mapComp _ _).symm ≪≫ eqToIso (by simp) ≪≫ (mapId _)\n\n"}
{"name":"CategoryTheory.MonoOver.congr_counitIso","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.MonoOver.congr X e).counitIso (CategoryTheory.NatIso.ofComponents (fun Y => CategoryTheory.MonoOver.isoMk (e.counitIso.app Y.obj.left) ⋯) ⋯)","decl":"/-- An equivalence of categories `e` between `C` and `D` induces an equivalence between\n    `MonoOver X` and `MonoOver (e.functor.obj X)` whenever `X` is an object of `C`. -/\n@[simps]\ndef congr (e : C ≌ D) : MonoOver X ≌ MonoOver (e.functor.obj X) where\n  functor :=\n    lift (Over.post e.functor) fun f => by\n      dsimp\n      infer_instance\n  inverse :=\n    (lift (Over.post e.inverse) fun f => by\n        dsimp\n        infer_instance) ⋙\n      (mapIso (e.unitIso.symm.app X)).functor\n  unitIso := NatIso.ofComponents fun Y => isoMk (e.unitIso.app Y)\n  counitIso := NatIso.ofComponents fun Y => isoMk (e.counitIso.app Y)\n\n"}
{"name":"CategoryTheory.MonoOver.congr_unitIso","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.MonoOver.congr X e).unitIso (CategoryTheory.NatIso.ofComponents (fun Y => CategoryTheory.MonoOver.isoMk (e.unitIso.app Y.obj.left) ⋯) ⋯)","decl":"/-- An equivalence of categories `e` between `C` and `D` induces an equivalence between\n    `MonoOver X` and `MonoOver (e.functor.obj X)` whenever `X` is an object of `C`. -/\n@[simps]\ndef congr (e : C ≌ D) : MonoOver X ≌ MonoOver (e.functor.obj X) where\n  functor :=\n    lift (Over.post e.functor) fun f => by\n      dsimp\n      infer_instance\n  inverse :=\n    (lift (Over.post e.inverse) fun f => by\n        dsimp\n        infer_instance) ⋙\n      (mapIso (e.unitIso.symm.app X)).functor\n  unitIso := NatIso.ofComponents fun Y => isoMk (e.unitIso.app Y)\n  counitIso := NatIso.ofComponents fun Y => isoMk (e.counitIso.app Y)\n\n"}
{"name":"CategoryTheory.MonoOver.congr_inverse","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.MonoOver.congr X e).inverse ((CategoryTheory.MonoOver.lift (CategoryTheory.Over.post e.inverse) ⋯).comp (CategoryTheory.MonoOver.mapIso (e.unitIso.symm.app X)).functor)","decl":"/-- An equivalence of categories `e` between `C` and `D` induces an equivalence between\n    `MonoOver X` and `MonoOver (e.functor.obj X)` whenever `X` is an object of `C`. -/\n@[simps]\ndef congr (e : C ≌ D) : MonoOver X ≌ MonoOver (e.functor.obj X) where\n  functor :=\n    lift (Over.post e.functor) fun f => by\n      dsimp\n      infer_instance\n  inverse :=\n    (lift (Over.post e.inverse) fun f => by\n        dsimp\n        infer_instance) ⋙\n      (mapIso (e.unitIso.symm.app X)).functor\n  unitIso := NatIso.ofComponents fun Y => isoMk (e.unitIso.app Y)\n  counitIso := NatIso.ofComponents fun Y => isoMk (e.counitIso.app Y)\n\n"}
{"name":"CategoryTheory.MonoOver.congr_functor","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.MonoOver.congr X e).functor (CategoryTheory.MonoOver.lift (CategoryTheory.Over.post e.functor) ⋯)","decl":"/-- An equivalence of categories `e` between `C` and `D` induces an equivalence between\n    `MonoOver X` and `MonoOver (e.functor.obj X)` whenever `X` is an object of `C`. -/\n@[simps]\ndef congr (e : C ≌ D) : MonoOver X ≌ MonoOver (e.functor.obj X) where\n  functor :=\n    lift (Over.post e.functor) fun f => by\n      dsimp\n      infer_instance\n  inverse :=\n    (lift (Over.post e.inverse) fun f => by\n        dsimp\n        infer_instance) ⋙\n      (mapIso (e.unitIso.symm.app X)).functor\n  unitIso := NatIso.ofComponents fun Y => isoMk (e.unitIso.app Y)\n  counitIso := NatIso.ofComponents fun Y => isoMk (e.counitIso.app Y)\n\n"}
{"name":"CategoryTheory.MonoOver.imageMonoOver_arrow","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasImage f\n⊢ Eq (CategoryTheory.MonoOver.imageMonoOver f).arrow (CategoryTheory.Limits.image.ι f)","decl":"@[simp]\ntheorem imageMonoOver_arrow (f : X ⟶ Y) [HasImage f] : (imageMonoOver f).arrow = image.ι f :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonoOver.image_map","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\ninst✝ : CategoryTheory.Limits.HasImages C\nf g : CategoryTheory.Over X\nk : Quiver.Hom f g\n⊢ Eq (CategoryTheory.MonoOver.image.map k) ((CategoryTheory.MonoOver.forget X).preimage (CategoryTheory.Over.homMk (CategoryTheory.Limits.image.lift (CategoryTheory.Limits.MonoFactorisation.mk (CategoryTheory.Limits.image g.hom) (CategoryTheory.Limits.image.ι g.hom) (CategoryTheory.CategoryStruct.comp k.left (CategoryTheory.Limits.factorThruImage g.hom)) ⋯)) ⋯))","decl":"/-- Taking the image of a morphism gives a functor `Over X ⥤ MonoOver X`.\n-/\n@[simps]\ndef image : Over X ⥤ MonoOver X where\n  obj f := imageMonoOver f.hom\n  map {f g} k := by\n    apply (forget X).preimage _\n    apply Over.homMk _ _\n    · exact\n        image.lift\n          { I := Limits.image _\n            m := image.ι g.hom\n            e := k.left ≫ factorThruImage g.hom }\n    · apply image.lift_fac\n\n"}
{"name":"CategoryTheory.MonoOver.image_obj","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\ninst✝ : CategoryTheory.Limits.HasImages C\nf : CategoryTheory.Over X\n⊢ Eq (CategoryTheory.MonoOver.image.obj f) (CategoryTheory.MonoOver.imageMonoOver f.hom)","decl":"/-- Taking the image of a morphism gives a functor `Over X ⥤ MonoOver X`.\n-/\n@[simps]\ndef image : Over X ⥤ MonoOver X where\n  obj f := imageMonoOver f.hom\n  map {f g} k := by\n    apply (forget X).preimage _\n    apply Over.homMk _ _\n    · exact\n        image.lift\n          { I := Limits.image _\n            m := image.ι g.hom\n            e := k.left ≫ factorThruImage g.hom }\n    · apply image.lift_fac\n\n"}
{"name":"CategoryTheory.MonoOver.instIsRightAdjointOverForget","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\ninst✝ : CategoryTheory.Limits.HasImages C\n⊢ (CategoryTheory.MonoOver.forget X).IsRightAdjoint","decl":"instance : (forget X).IsRightAdjoint :=\n  ⟨_, ⟨imageForgetAdj⟩⟩\n\n"}
{"name":"CategoryTheory.MonoOver.faithful_exists","module":"Mathlib.CategoryTheory.Subobject.MonoOver","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\ninst✝ : CategoryTheory.Limits.HasImages C\nf : Quiver.Hom X Y\n⊢ (CategoryTheory.MonoOver.exists f).Faithful","decl":"instance faithful_exists (f : X ⟶ Y) : Functor.Faithful («exists» f) where\n\n"}
