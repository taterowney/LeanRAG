{"name":"Hopf_Class.antipode_right'","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\nself : Hopf_Class X\n⊢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Hopf_Class.antipode) Mon_Class.mul)) (CategoryTheory.CategoryStruct.comp Comon_Class.counit Mon_Class.one)","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nclass Hopf_Class (X : C) extends Bimon_Class X where\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X ⟶ X\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `X` is explicit. -/\n  antipode_left' : Δ ≫ antipode ▷ X ≫ μ = ε ≫ η := by aesop_cat\n  antipode_right' : Δ ≫ X ◁ antipode ≫ μ = ε ≫ η := by aesop_cat\n\n"}
{"name":"Hopf_Class.antipode_left'","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\nself : Hopf_Class X\n⊢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Hopf_Class.antipode X) Mon_Class.mul)) (CategoryTheory.CategoryStruct.comp Comon_Class.counit Mon_Class.one)","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nclass Hopf_Class (X : C) extends Bimon_Class X where\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X ⟶ X\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `X` is explicit. -/\n  antipode_left' : Δ ≫ antipode ▷ X ≫ μ = ε ≫ η := by aesop_cat\n  antipode_right' : Δ ≫ X ◁ antipode ≫ μ = ε ≫ η := by aesop_cat\n\n"}
{"name":"Hopf_Class.antipode_left'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\nself : Hopf_Class X\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Hopf_Class.antipode X) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h))) (CategoryTheory.CategoryStruct.comp Comon_Class.counit (CategoryTheory.CategoryStruct.comp Mon_Class.one h))","decl":"attribute [reassoc] antipode_left' antipode_right'\n\n"}
{"name":"Hopf_Class.antipode_right'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX : C\nself : Hopf_Class X\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Hopf_Class.antipode) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h))) (CategoryTheory.CategoryStruct.comp Comon_Class.counit (CategoryTheory.CategoryStruct.comp Mon_Class.one h))","decl":"attribute [reassoc] antipode_left' antipode_right'\n\n"}
{"name":"Hopf_Class.antipode_left","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.BraidedCategory C\nX : C\ninst✝ : Hopf_Class X\n⊢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Hopf_Class.antipode X) Mon_Class.mul)) (CategoryTheory.CategoryStruct.comp Comon_Class.counit Mon_Class.one)","decl":"/-- The object is provided as an explicit argument. -/\n@[reassoc (attr := simp)]\ntheorem antipode_left (X : C) [Hopf_Class X] : Δ ≫ 𝒮 ▷ X ≫ μ = ε ≫ η := antipode_left'\n\n"}
{"name":"Hopf_Class.antipode_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.BraidedCategory C\nX : C\ninst✝ : Hopf_Class X\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Hopf_Class.antipode X) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h))) (CategoryTheory.CategoryStruct.comp Comon_Class.counit (CategoryTheory.CategoryStruct.comp Mon_Class.one h))","decl":"/-- The object is provided as an explicit argument. -/\n@[reassoc (attr := simp)]\ntheorem antipode_left (X : C) [Hopf_Class X] : Δ ≫ 𝒮 ▷ X ≫ μ = ε ≫ η := antipode_left'\n\n"}
{"name":"Hopf_Class.antipode_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.BraidedCategory C\nX : C\ninst✝ : Hopf_Class X\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Hopf_Class.antipode) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h))) (CategoryTheory.CategoryStruct.comp Comon_Class.counit (CategoryTheory.CategoryStruct.comp Mon_Class.one h))","decl":"/-- The object is provided as an explicit argument. -/\n@[reassoc (attr := simp)]\ntheorem antipode_right (X : C) [Hopf_Class X] : Δ ≫ X ◁ 𝒮 ≫ μ = ε ≫ η := antipode_right'\n\n"}
{"name":"Hopf_Class.antipode_right","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.BraidedCategory C\nX : C\ninst✝ : Hopf_Class X\n⊢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Hopf_Class.antipode) Mon_Class.mul)) (CategoryTheory.CategoryStruct.comp Comon_Class.counit Mon_Class.one)","decl":"/-- The object is provided as an explicit argument. -/\n@[reassoc (attr := simp)]\ntheorem antipode_right (X : C) [Hopf_Class X] : Δ ≫ X ◁ 𝒮 ≫ μ = ε ≫ η := antipode_right'\n\n"}
{"name":"Hopf_.antipode_right","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nself : Hopf_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X.X.X self.antipode) self.X.X.mul)) (CategoryTheory.CategoryStruct.comp self.X.counit.hom self.X.X.one)","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nstructure Hopf_ where\n  /-- The underlying bimonoid of a Hopf monoid. -/\n  X : Bimon_ C\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X.X.X ⟶ X.X.X\n  antipode_left : X.comul.hom ≫ (antipode ▷ X.X.X) ≫ X.X.mul = X.counit.hom ≫ X.X.one\n  antipode_right : X.comul.hom ≫ (X.X.X ◁ antipode) ≫ X.X.mul = X.counit.hom ≫ X.X.one\n\n"}
{"name":"Hopf_.antipode_left","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nself : Hopf_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.antipode self.X.X.X) self.X.X.mul)) (CategoryTheory.CategoryStruct.comp self.X.counit.hom self.X.X.one)","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nstructure Hopf_ where\n  /-- The underlying bimonoid of a Hopf monoid. -/\n  X : Bimon_ C\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X.X.X ⟶ X.X.X\n  antipode_left : X.comul.hom ≫ (antipode ▷ X.X.X) ≫ X.X.mul = X.counit.hom ≫ X.X.one\n  antipode_right : X.comul.hom ≫ (X.X.X ◁ antipode) ≫ X.X.mul = X.counit.hom ≫ X.X.one\n\n"}
{"name":"Hopf_.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.BraidedCategory C\ninst✝ : SizeOf C\nX : Bimon_ C\nantipode : Quiver.Hom X.X.X X.X.X\nantipode_left : Eq (CategoryTheory.CategoryStruct.comp X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight antipode X.X.X) X.X.mul)) (CategoryTheory.CategoryStruct.comp X.counit.hom X.X.one)\nantipode_right : Eq (CategoryTheory.CategoryStruct.comp X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.X.X antipode) X.X.mul)) (CategoryTheory.CategoryStruct.comp X.counit.hom X.X.one)\n⊢ Eq (SizeOf.sizeOf { X := X, antipode := antipode, antipode_left := antipode_left, antipode_right := antipode_right }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf antipode)) (SizeOf.sizeOf antipode_left)) (SizeOf.sizeOf antipode_right))","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nstructure Hopf_ where\n  /-- The underlying bimonoid of a Hopf monoid. -/\n  X : Bimon_ C\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X.X.X ⟶ X.X.X\n  antipode_left : X.comul.hom ≫ (antipode ▷ X.X.X) ≫ X.X.mul = X.counit.hom ≫ X.X.one\n  antipode_right : X.comul.hom ≫ (X.X.X ◁ antipode) ≫ X.X.mul = X.counit.hom ≫ X.X.one\n\n"}
{"name":"Hopf_.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX✝ : Bimon_ C\nantipode✝ : Quiver.Hom X✝.X.X X✝.X.X\nantipode_left✝ : Eq (CategoryTheory.CategoryStruct.comp X✝.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight antipode✝ X✝.X.X) X✝.X.mul)) (CategoryTheory.CategoryStruct.comp X✝.counit.hom X✝.X.one)\nantipode_right✝ : Eq (CategoryTheory.CategoryStruct.comp X✝.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X✝.X.X antipode✝) X✝.X.mul)) (CategoryTheory.CategoryStruct.comp X✝.counit.hom X✝.X.one)\nX : Bimon_ C\nantipode : Quiver.Hom X.X.X X.X.X\nantipode_left : Eq (CategoryTheory.CategoryStruct.comp X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight antipode X.X.X) X.X.mul)) (CategoryTheory.CategoryStruct.comp X.counit.hom X.X.one)\nantipode_right : Eq (CategoryTheory.CategoryStruct.comp X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.X.X antipode) X.X.mul)) (CategoryTheory.CategoryStruct.comp X.counit.hom X.X.one)\nx✝ : Eq { X := X✝, antipode := antipode✝, antipode_left := antipode_left✝, antipode_right := antipode_right✝ } { X := X, antipode := antipode, antipode_left := antipode_left, antipode_right := antipode_right }\n⊢ And (Eq X✝ X) (HEq antipode✝ antipode)","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nstructure Hopf_ where\n  /-- The underlying bimonoid of a Hopf monoid. -/\n  X : Bimon_ C\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X.X.X ⟶ X.X.X\n  antipode_left : X.comul.hom ≫ (antipode ▷ X.X.X) ≫ X.X.mul = X.counit.hom ≫ X.X.one\n  antipode_right : X.comul.hom ≫ (X.X.X ◁ antipode) ≫ X.X.mul = X.counit.hom ≫ X.X.one\n\n"}
{"name":"Hopf_.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX✝ : Bimon_ C\nantipode✝ : Quiver.Hom X✝.X.X X✝.X.X\nantipode_left✝ : Eq (CategoryTheory.CategoryStruct.comp X✝.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight antipode✝ X✝.X.X) X✝.X.mul)) (CategoryTheory.CategoryStruct.comp X✝.counit.hom X✝.X.one)\nantipode_right✝ : Eq (CategoryTheory.CategoryStruct.comp X✝.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X✝.X.X antipode✝) X✝.X.mul)) (CategoryTheory.CategoryStruct.comp X✝.counit.hom X✝.X.one)\nX : Bimon_ C\nantipode : Quiver.Hom X.X.X X.X.X\nantipode_left : Eq (CategoryTheory.CategoryStruct.comp X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight antipode X.X.X) X.X.mul)) (CategoryTheory.CategoryStruct.comp X.counit.hom X.X.one)\nantipode_right : Eq (CategoryTheory.CategoryStruct.comp X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.X.X antipode) X.X.mul)) (CategoryTheory.CategoryStruct.comp X.counit.hom X.X.one)\n⊢ Eq (Eq { X := X✝, antipode := antipode✝, antipode_left := antipode_left✝, antipode_right := antipode_right✝ } { X := X, antipode := antipode, antipode_left := antipode_left, antipode_right := antipode_right }) (And (Eq X✝ X) (HEq antipode✝ antipode))","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nstructure Hopf_ where\n  /-- The underlying bimonoid of a Hopf monoid. -/\n  X : Bimon_ C\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X.X.X ⟶ X.X.X\n  antipode_left : X.comul.hom ≫ (antipode ▷ X.X.X) ≫ X.X.mul = X.counit.hom ≫ X.X.one\n  antipode_right : X.comul.hom ≫ (X.X.X ◁ antipode) ≫ X.X.mul = X.counit.hom ≫ X.X.one\n\n"}
{"name":"Hopf_.antipode_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nself : Hopf_ C\nZ : C\nh : Quiver.Hom self.X.X.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X.X.X self.antipode) (CategoryTheory.CategoryStruct.comp self.X.X.mul h))) (CategoryTheory.CategoryStruct.comp self.X.counit.hom (CategoryTheory.CategoryStruct.comp self.X.X.one h))","decl":"attribute [reassoc (attr := simp)] Hopf_.antipode_left Hopf_.antipode_right\n\n"}
{"name":"Hopf_.antipode_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nself : Hopf_ C\nZ : C\nh : Quiver.Hom self.X.X.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.antipode self.X.X.X) (CategoryTheory.CategoryStruct.comp self.X.X.mul h))) (CategoryTheory.CategoryStruct.comp self.X.counit.hom (CategoryTheory.CategoryStruct.comp self.X.X.one h))","decl":"attribute [reassoc (attr := simp)] Hopf_.antipode_left Hopf_.antipode_right\n\n"}
{"name":"Hopf_.hom_antipode","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA B : Hopf_ C\nf : Quiver.Hom A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.hom.hom B.antipode) (CategoryTheory.CategoryStruct.comp A.antipode f.hom.hom)","decl":"/-- Morphisms of Hopf monoids intertwine the antipodes. -/\ntheorem hom_antipode {A B : Hopf_ C} (f : A ⟶ B) :\n    f.hom.hom ≫ B.antipode = A.antipode ≫ f.hom.hom := by\n  -- We show these elements are equal by exhibiting an element in the convolution algebra\n  -- between `A` (as a comonoid) and `B` (as a monoid),\n  -- such that the LHS is a left inverse, and the RHS is a right inverse.\n  apply left_inv_eq_right_inv\n    (M := Conv ((Bimon_.toComon_ C).obj A.X) B.X.X)\n    (a := f.hom.hom)\n  · erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Bimon_.toComon__obj_X, Bimon_.toComon__obj_comul, comp_whiskerRight, Category.assoc,\n      Bimon_.toComon__obj_counit]\n    slice_lhs 3 4 =>\n      rw [← whisker_exchange]\n    slice_lhs 2 3 =>\n      rw [← tensorHom_def]\n    slice_lhs 1 2 =>\n      rw [← Bimon_.hom_comul_hom f]\n    slice_lhs 2 4 =>\n      rw [B.antipode_left]\n    slice_lhs 1 2 =>\n      rw [Bimon_.hom_counit_hom f]\n  · erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Bimon_.toComon__obj_X, Bimon_.toComon__obj_comul, MonoidalCategory.whiskerLeft_comp,\n      Category.assoc, Bimon_.toComon__obj_counit]\n    slice_lhs 2 3 =>\n      rw [← whisker_exchange]\n    slice_lhs 3 4 =>\n      rw [← tensorHom_def]\n    slice_lhs 3 4 =>\n      rw [← f.hom.mul_hom]\n    slice_lhs 1 3 =>\n      rw [A.antipode_right]\n    slice_lhs 2 3 =>\n      rw [f.hom.one_hom]\n\n"}
{"name":"Hopf_.one_antipode_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Hopf_ C\nZ : C\nh : Quiver.Hom A.X.X.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.X.X.one (CategoryTheory.CategoryStruct.comp A.antipode h)) (CategoryTheory.CategoryStruct.comp A.X.X.one h)","decl":"@[reassoc (attr := simp)]\ntheorem one_antipode (A : Hopf_ C) : A.X.X.one ≫ A.antipode = A.X.X.one := by\n  have := (rfl : A.X.X.one ≫ A.X.comul.hom ≫ (A.antipode ▷ A.X.X.X) ≫ A.X.X.mul = _)\n  conv at this =>\n    rhs\n    rw [A.antipode_left]\n  rw [A.X.one_comul_assoc, tensorHom_def, Category.assoc, whisker_exchange_assoc] at this\n  simpa [unitors_inv_equal]\n\n"}
{"name":"Hopf_.one_antipode","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.X.X.one A.antipode) A.X.X.one","decl":"@[reassoc (attr := simp)]\ntheorem one_antipode (A : Hopf_ C) : A.X.X.one ≫ A.antipode = A.X.X.one := by\n  have := (rfl : A.X.X.one ≫ A.X.comul.hom ≫ (A.antipode ▷ A.X.X.X) ≫ A.X.X.mul = _)\n  conv at this =>\n    rhs\n    rw [A.antipode_left]\n  rw [A.X.one_comul_assoc, tensorHom_def, Category.assoc, whisker_exchange_assoc] at this\n  simpa [unitors_inv_equal]\n\n"}
{"name":"Hopf_.antipode_counit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Hopf_ C\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.antipode (CategoryTheory.CategoryStruct.comp A.X.counit.hom h)) (CategoryTheory.CategoryStruct.comp A.X.counit.hom h)","decl":"@[reassoc (attr := simp)]\ntheorem antipode_counit (A : Hopf_ C) : A.antipode ≫ A.X.counit.hom = A.X.counit.hom := by\n  have := (rfl : A.X.comul.hom ≫ (A.antipode ▷ A.X.X.X) ≫ A.X.X.mul ≫ A.X.counit.hom = _)\n  conv at this =>\n    rhs\n    rw [A.antipode_left_assoc]\n  rw [A.X.mul_counit, tensorHom_def', Category.assoc, ← whisker_exchange_assoc] at this\n  simpa [unitors_equal]\n\n"}
{"name":"Hopf_.antipode_counit","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.antipode A.X.counit.hom) A.X.counit.hom","decl":"@[reassoc (attr := simp)]\ntheorem antipode_counit (A : Hopf_ C) : A.antipode ≫ A.X.counit.hom = A.X.counit.hom := by\n  have := (rfl : A.X.comul.hom ≫ (A.antipode ▷ A.X.X.X) ≫ A.X.X.mul ≫ A.X.counit.hom = _)\n  conv at this =>\n    rhs\n    rw [A.antipode_left_assoc]\n  rw [A.X.mul_counit, tensorHom_def', Category.assoc, ← whisker_exchange_assoc] at this\n  simpa [unitors_equal]\n\n"}
{"name":"Hopf_.antipode_comul₁","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.antipode A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.X.comul.hom A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X A.X.comul.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom A.X.X.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X.X.X A.X.X.X)).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.X.mul A.X.X.mul)))))))))) (CategoryTheory.CategoryStruct.comp A.X.counit.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.X.one A.X.X.one)))","decl":"theorem antipode_comul₁ (A : Hopf_ C) :\n    A.X.comul.hom ≫\n      A.antipode ▷ A.X.X.X ≫\n      A.X.comul.hom ▷ A.X.X.X ≫\n      (α_ A.X.X.X A.X.X.X A.X.X.X).hom ≫\n      A.X.X.X ◁ A.X.X.X ◁ A.X.comul.hom ≫\n      A.X.X.X ◁ (α_ A.X.X.X A.X.X.X A.X.X.X).inv ≫\n      A.X.X.X ◁ (β_ A.X.X.X A.X.X.X).hom ▷ A.X.X.X ≫\n      A.X.X.X ◁ (α_ A.X.X.X A.X.X.X A.X.X.X).hom ≫\n      (α_ A.X.X.X A.X.X.X (A.X.X.X ⊗ A.X.X.X)).inv ≫\n      (A.X.X.mul ⊗ A.X.X.mul) =\n    A.X.counit.hom ≫ (λ_ (𝟙_ C)).inv ≫ (A.X.X.one ⊗ A.X.X.one) := by\n  dsimp\n  slice_lhs 3 5 =>\n    rw [← associator_naturality_right, ← Category.assoc, ← tensorHom_def]\n  slice_lhs 3 9 =>\n    erw [Bimon_.compatibility]\n  slice_lhs 1 3 =>\n    erw [A.antipode_left]\n  simp\n\n"}
{"name":"Hopf_.antipode_comul₂","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.X.comul.hom A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X A.X.comul.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorHom A.antipode A.antipode))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom A.X.X.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X.X.X A.X.X.X)).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.X.mul A.X.X.mul))))))))))) (CategoryTheory.CategoryStruct.comp A.X.counit.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.X.one A.X.X.one)))","decl":"/--\nAuxiliary calculation for `antipode_comul`.\nThis calculation calls for some ASCII art out of This Week's Finds.\n\n```\n   |   |\n   n   n\n  | \\ / |\n  |  /  |\n  | / \\ |\n  | | S S\n  | | \\ /\n  | |  /\n  | | / \\\n  \\ / \\ /\n   v   v\n    \\ /\n     v\n     |\n```\n\nWe move the left antipode up through the crossing,\nthe right antipode down through the crossing,\nthe right multiplication down across the strand,\nreassociate the comultiplications,\nthen use `antipode_right` then `antipode_left` to simplify.\n-/\ntheorem antipode_comul₂ (A : Hopf_ C) :\n    A.X.comul.hom ≫\n      A.X.comul.hom ▷ A.X.X.X ≫\n      (α_ A.X.X.X A.X.X.X A.X.X.X).hom ≫\n      A.X.X.X ◁ A.X.X.X ◁ A.X.comul.hom ≫\n      A.X.X.X ◁ A.X.X.X ◁ (β_ A.X.X.X A.X.X.X).hom ≫\n      A.X.X.X ◁ A.X.X.X ◁ (A.antipode ⊗ A.antipode) ≫\n      A.X.X.X ◁ (α_ A.X.X.X A.X.X.X A.X.X.X).inv ≫\n      A.X.X.X ◁ (β_ A.X.X.X A.X.X.X).hom ▷ A.X.X.X ≫\n      A.X.X.X ◁ (α_ A.X.X.X A.X.X.X A.X.X.X).hom ≫\n      (α_ A.X.X.X A.X.X.X (A.X.X.X ⊗ A.X.X.X)).inv ≫\n      (A.X.X.mul ⊗ A.X.X.mul) =\n    A.X.counit.hom ≫ (λ_ (𝟙_ C)).inv ≫ (A.X.X.one ⊗ A.X.X.one) := by\n  -- We should write a version of `slice_lhs` that zooms through whiskerings.\n  slice_lhs 6 6 =>\n    simp only [tensorHom_def', MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 7 8 =>\n    rw [← MonoidalCategory.whiskerLeft_comp, associator_inv_naturality_middle,\n      MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 8 9 =>\n    rw [← MonoidalCategory.whiskerLeft_comp, ← comp_whiskerRight,\n      BraidedCategory.braiding_naturality_right,\n      comp_whiskerRight, MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 9 10 =>\n    rw [← MonoidalCategory.whiskerLeft_comp,\n      associator_naturality_left,\n      MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 5 6 =>\n    rw [← MonoidalCategory.whiskerLeft_comp, ← MonoidalCategory.whiskerLeft_comp,\n      ← BraidedCategory.braiding_naturality_left,\n      MonoidalCategory.whiskerLeft_comp, MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 11 12 =>\n    rw [tensorHom_def', ← Category.assoc, ← associator_inv_naturality_right]\n  slice_lhs 10 11 =>\n    rw [← MonoidalCategory.whiskerLeft_comp, ← whisker_exchange,\n      MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 6 10 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [← BraidedCategory.hexagon_reverse_assoc, Iso.inv_hom_id_assoc,\n      ← BraidedCategory.braiding_naturality_left]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  rw [Bimon_.comul_assoc_flip_hom_assoc, Iso.inv_hom_id_assoc]\n  slice_lhs 2 3 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [Bimon_.comul_assoc_hom]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 3 7 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [← associator_naturality_middle_assoc, Iso.hom_inv_id_assoc]\n    simp only [← comp_whiskerRight]\n    rw [antipode_right]\n    simp only [comp_whiskerRight]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 2 3 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [Bimon_.counit_comul_hom]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 3 4 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [BraidedCategory.braiding_naturality_left]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 4 5 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [whisker_exchange]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 5 7 =>\n    rw [associator_inv_naturality_right_assoc, whisker_exchange]\n  simp only [Mon_.monMonoidalStruct_tensorObj_X, Mon_.tensorUnit_X, braiding_tensorUnit_left,\n    MonoidalCategory.whiskerLeft_comp, whiskerLeft_rightUnitor_inv,\n    MonoidalCategory.whiskerRight_id, whiskerLeft_rightUnitor, Category.assoc, Iso.hom_inv_id_assoc,\n    Iso.inv_hom_id_assoc, whiskerLeft_inv_hom_assoc, antipode_right_assoc]\n  rw [rightUnitor_inv_naturality_assoc, tensorHom_def]\n  monoidal\n\n"}
{"name":"Hopf_.antipode_comul","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.antipode A.X.comul.hom) (CategoryTheory.CategoryStruct.comp A.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom (CategoryTheory.MonoidalCategoryStruct.tensorHom A.antipode A.antipode)))","decl":"theorem antipode_comul (A : Hopf_ C) :\n    A.antipode ≫ A.X.comul.hom = A.X.comul.hom ≫ (β_ _ _).hom ≫ (A.antipode ⊗ A.antipode) := by\n  -- Again, it is a \"left inverse equals right inverse\" argument in the convolution monoid.\n  apply left_inv_eq_right_inv\n    (M := Conv ((Bimon_.toComon_ C).obj A.X) (A.X.X ⊗ A.X.X))\n    (a := A.X.comul.hom)\n  · erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Bimon_.toComon__obj_X, Mon_.monMonoidalStruct_tensorObj_X, Bimon_.toComon__obj_comul,\n      comp_whiskerRight, tensor_whiskerLeft, Mon_.tensorObj_mul, Category.assoc,\n      Bimon_.toComon__obj_counit, Mon_.tensorObj_one]\n    simp only [tensorμ]\n    simp only [Category.assoc, Iso.inv_hom_id_assoc]\n    exact antipode_comul₁ A\n  · erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Bimon_.toComon__obj_X, Mon_.monMonoidalStruct_tensorObj_X, Bimon_.toComon__obj_comul,\n      MonoidalCategory.whiskerLeft_comp, tensor_whiskerLeft, Category.assoc, Iso.inv_hom_id_assoc,\n      Mon_.tensorObj_mul, Bimon_.toComon__obj_counit, Mon_.tensorObj_one]\n    simp only [tensorμ]\n    simp only [Category.assoc, Iso.inv_hom_id_assoc]\n    exact antipode_comul₂ A\n\n"}
{"name":"Hopf_.mul_antipode₁","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.comul.hom A.X.comul.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X.X.X A.X.X.X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom A.X.X.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X.X.X A.X.X.X) A.X.X.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).inv A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.X.X.mul A.X.X.X) A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.antipode A.X.X.X) A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X A.X.X.mul) A.X.X.mul)))))))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.counit.hom A.X.counit.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom A.X.X.one))","decl":"theorem mul_antipode₁ (A : Hopf_ C) :\n    (A.X.comul.hom ⊗ A.X.comul.hom) ≫\n      (α_ A.X.X.X A.X.X.X (A.X.X.X ⊗ A.X.X.X)).hom ≫\n      A.X.X.X ◁ (α_ A.X.X.X A.X.X.X A.X.X.X).inv ≫\n      A.X.X.X ◁ (β_ A.X.X.X A.X.X.X).hom ▷ A.X.X.X ≫\n      (α_ A.X.X.X (A.X.X.X ⊗ A.X.X.X) A.X.X.X).inv ≫\n      (α_ A.X.X.X A.X.X.X A.X.X.X).inv ▷ A.X.X.X ≫\n      A.X.X.mul ▷ A.X.X.X ▷ A.X.X.X ≫\n      A.antipode ▷ A.X.X.X ▷ A.X.X.X ≫\n      (α_ A.X.X.X A.X.X.X A.X.X.X).hom ≫\n      A.X.X.X ◁ A.X.X.mul ≫\n      A.X.X.mul =\n    (A.X.counit.hom ⊗ A.X.counit.hom) ≫ (λ_ (𝟙_ C)).hom ≫ A.X.X.one := by\n  slice_lhs 8 9 =>\n    rw [associator_naturality_left]\n  slice_lhs 9 10 =>\n    rw [← whisker_exchange]\n  slice_lhs 7 8 =>\n    rw [associator_naturality_left]\n  slice_lhs 8 9 =>\n    rw [← tensorHom_def]\n  simp only [Mon_.monMonoidalStruct_tensorObj_X, Category.assoc, pentagon_inv_inv_hom_hom_inv_assoc,\n    Mon_.tensorUnit_X]\n  slice_lhs 1 7 =>\n    erw [Bimon_.compatibility]\n  slice_lhs 2 4 =>\n    rw [antipode_left]\n  simp\n\n\n"}
{"name":"Hopf_.mul_antipode₂","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.comul.hom A.X.comul.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X.X.X A.X.X.X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom A.X.X.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X.X.X A.X.X.X) A.X.X.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).inv A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.X.X.mul A.X.X.X) A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorHom A.antipode A.antipode)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X A.X.X.mul) A.X.X.mul))))))))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.counit.hom A.X.counit.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom A.X.X.one))","decl":"/--\nAuxiliary calculation for `mul_antipode`.\n\n```\n       |\n       n\n      /  \\\n     |   n\n     |  / \\\n     |  S S\n     |  \\ /\n     n   /\n    / \\ / \\\n    |  /  |\n    \\ / \\ /\n     v   v\n     |   |\n```\n\nWe move the leftmost multiplication up, so we can reassociate.\nWe then move the rightmost comultiplication under the strand,\nand simplify using `antipode_right`.\n-/\ntheorem mul_antipode₂ (A : Hopf_ C) :\n    (A.X.comul.hom ⊗ A.X.comul.hom) ≫\n      (α_ A.X.X.X A.X.X.X (A.X.X.X ⊗ A.X.X.X)).hom ≫\n      A.X.X.X ◁ (α_ A.X.X.X A.X.X.X A.X.X.X).inv ≫\n      A.X.X.X ◁ (β_ A.X.X.X A.X.X.X).hom ▷ A.X.X.X ≫\n      (α_ A.X.X.X (A.X.X.X ⊗ A.X.X.X) A.X.X.X).inv ≫\n      (α_ A.X.X.X A.X.X.X A.X.X.X).inv ▷ A.X.X.X ≫\n      A.X.X.mul ▷ A.X.X.X ▷ A.X.X.X ≫\n      (α_ A.X.X.X A.X.X.X A.X.X.X).hom ≫\n      A.X.X.X ◁ (β_ A.X.X.X A.X.X.X).hom ≫\n      A.X.X.X ◁ (A.antipode ⊗ A.antipode) ≫\n      A.X.X.X ◁ A.X.X.mul ≫ A.X.X.mul =\n    (A.X.counit.hom ⊗ A.X.counit.hom) ≫ (λ_ (𝟙_ C)).hom ≫ A.X.X.one := by\n  slice_lhs 7 8 =>\n    rw [associator_naturality_left]\n  slice_lhs 8 9 =>\n    rw [← whisker_exchange]\n  slice_lhs 9 10 =>\n    rw [← whisker_exchange]\n  slice_lhs 11 12 =>\n    rw [Mon_.mul_assoc_flip]\n  slice_lhs 10 11 =>\n    rw [associator_inv_naturality_left]\n  slice_lhs 11 12 =>\n    simp only [← comp_whiskerRight]\n    rw [Mon_.mul_assoc]\n    simp only [comp_whiskerRight]\n  rw [tensorHom_def]\n  rw [tensor_whiskerLeft]\n  rw [pentagon_inv_inv_hom_hom_inv_assoc]\n  slice_lhs 7 8 =>\n    rw [Iso.inv_hom_id]\n  rw [Category.id_comp]\n  slice_lhs 5 7 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [← BraidedCategory.hexagon_forward]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  simp only [Mon_.monMonoidalStruct_tensorObj_X, tensor_whiskerLeft,\n    MonoidalCategory.whiskerLeft_comp, Category.assoc,\n    whiskerLeft_inv_hom, Category.comp_id, whiskerLeft_hom_inv_assoc, Iso.inv_hom_id_assoc,\n    pentagon_inv_inv_hom_inv_inv, whisker_assoc, Mon_.mul_assoc, Mon_.tensorUnit_X]\n  slice_lhs 4 5 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [Iso.inv_hom_id]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  rw [MonoidalCategory.whiskerLeft_id, Category.id_comp]\n  slice_lhs 3 4 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [BraidedCategory.braiding_naturality_right]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  rw [tensorHom_def']\n  simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 5 6 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [← associator_naturality_right]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 4 5 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [← whisker_exchange]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 5 9 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [associator_inv_naturality_middle_assoc, Iso.hom_inv_id_assoc]\n    simp only [← comp_whiskerRight]\n    rw [antipode_right]\n    simp only [comp_whiskerRight]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 6 7 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [A.X.X.one_mul]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 3 4 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [← BraidedCategory.braiding_naturality_left]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 4 5 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [← BraidedCategory.braiding_naturality_right]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  rw [← associator_naturality_middle_assoc]\n  simp only [Mon_.tensorUnit_X, braiding_tensorUnit_right, MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 6 7 =>\n    simp only [← MonoidalCategory.whiskerLeft_comp]\n    rw [Iso.inv_hom_id]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  simp only [MonoidalCategory.whiskerLeft_id, Category.id_comp]\n  slice_lhs 5 6 =>\n    rw [whiskerLeft_rightUnitor, Category.assoc, ← rightUnitor_naturality]\n  rw [associator_inv_naturality_right_assoc, Iso.hom_inv_id_assoc]\n  slice_lhs 3 4 =>\n    rw [whisker_exchange]\n  slice_lhs 1 3 =>\n    simp only [← comp_whiskerRight]\n    rw [antipode_right]\n    simp only [comp_whiskerRight]\n  slice_lhs 2 3 =>\n    rw [← whisker_exchange]\n  slice_lhs 1 2 =>\n    dsimp\n    rw [← tensorHom_def]\n  slice_lhs 2 3 =>\n    rw [rightUnitor_naturality]\n  simp only [Mon_.tensorUnit_X]\n  monoidal\n\n"}
{"name":"Hopf_.mul_antipode","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.X.X.mul A.antipode) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom A.antipode A.antipode) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom A.X.X.mul))","decl":"theorem mul_antipode (A : Hopf_ C) :\n    A.X.X.mul ≫ A.antipode = (A.antipode ⊗ A.antipode) ≫ (β_ _ _).hom ≫ A.X.X.mul := by\n  -- Again, it is a \"left inverse equals right inverse\" argument in the convolution monoid.\n  apply left_inv_eq_right_inv\n    (M := Conv (((Bimon_.toComon_ C).obj A.X) ⊗ ((Bimon_.toComon_ C).obj A.X)) A.X.X)\n    (a := A.X.X.mul)\n  · -- Unfold the algebra structure in the convolution monoid,\n    -- then `simp?, simp only [tensor_μ], simp?`.\n    erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Monoidal.transportStruct_tensorObj, Equivalence.symm_functor,\n      Comon_.Comon_EquivMon_OpOp_inverse, Equivalence.symm_inverse,\n      Comon_.Comon_EquivMon_OpOp_functor, Comon_.Comon_ToMon_OpOp_obj, Comon_.Mon_OpOpToComon__obj,\n      unop_tensorObj, Comon_.Mon_OpOpToComon_obj'_X, Mon_.monMonoidalStruct_tensorObj_X,\n      Comon_.Comon_ToMon_OpOp_obj'_X, Bimon_.toComon__obj_X, Comon_.Mon_OpOpToComon_obj'_comul,\n      Mon_.tensorObj_mul, Comon_.Comon_ToMon_OpOp_obj'_mul, Bimon_.toComon__obj_comul, unop_comp,\n      unop_tensorHom, Quiver.Hom.unop_op, whiskerRight_tensor, comp_whiskerRight, Category.assoc,\n      Comon_.Mon_OpOpToComon_obj'_counit, Mon_.tensorObj_one, Comon_.Comon_ToMon_OpOp_obj'_one,\n      Bimon_.toComon__obj_counit, unop_tensorUnit, unop_inv_leftUnitor]\n    simp only [tensorμ]\n    simp only [unop_comp, unop_tensorObj, unop_inv_associator, unop_whiskerLeft,\n      unop_hom_associator, unop_whiskerRight, unop_hom_braiding, Category.assoc,\n      pentagon_hom_inv_inv_inv_inv_assoc]\n    exact mul_antipode₁ A\n  · erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Monoidal.transportStruct_tensorObj, Equivalence.symm_functor,\n      Comon_.Comon_EquivMon_OpOp_inverse, Equivalence.symm_inverse,\n      Comon_.Comon_EquivMon_OpOp_functor, Comon_.Comon_ToMon_OpOp_obj, Comon_.Mon_OpOpToComon__obj,\n      unop_tensorObj, Comon_.Mon_OpOpToComon_obj'_X, Mon_.monMonoidalStruct_tensorObj_X,\n      Comon_.Comon_ToMon_OpOp_obj'_X, Bimon_.toComon__obj_X, Comon_.Mon_OpOpToComon_obj'_comul,\n      Mon_.tensorObj_mul, Comon_.Comon_ToMon_OpOp_obj'_mul, Bimon_.toComon__obj_comul, unop_comp,\n      unop_tensorHom, Quiver.Hom.unop_op, whiskerRight_tensor,\n      BraidedCategory.braiding_naturality_assoc, MonoidalCategory.whiskerLeft_comp, Category.assoc,\n      Comon_.Mon_OpOpToComon_obj'_counit, Mon_.tensorObj_one, Comon_.Comon_ToMon_OpOp_obj'_one,\n      Bimon_.toComon__obj_counit, unop_tensorUnit, unop_inv_leftUnitor]\n    simp only [tensorμ]\n    simp only [unop_comp, unop_tensorObj, unop_inv_associator, unop_whiskerLeft,\n      unop_hom_associator, unop_whiskerRight, unop_hom_braiding, Category.assoc,\n      pentagon_hom_inv_inv_inv_inv_assoc]\n    exact mul_antipode₂ A\n\n"}
{"name":"Hopf_.antipode_antipode","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Hopf_ C\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom A.X.X.mul) A.X.X.mul\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.antipode A.antipode) (CategoryTheory.CategoryStruct.id A.X.X.X)","decl":"/--\nIn a commutative Hopf algebra, the antipode squares to the identity.\n-/\ntheorem antipode_antipode (A : Hopf_ C) (comm : (β_ _ _).hom ≫ A.X.X.mul = A.X.X.mul) :\n    A.antipode ≫ A.antipode = 𝟙 A.X.X.X := by\n  -- Again, it is a \"left inverse equals right inverse\" argument in the convolution monoid.\n  apply left_inv_eq_right_inv\n    (M := Conv ((Bimon_.toComon_ C).obj A.X) A.X.X)\n    (a := A.antipode)\n  · -- Unfold the algebra structure in the convolution monoid,\n    -- then `simp?`.\n    erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Bimon_.toComon__obj_X, Bimon_.toComon__obj_comul, comp_whiskerRight, Category.assoc,\n      Bimon_.toComon__obj_counit]\n    rw [← comm, ← tensorHom_def_assoc, ← mul_antipode]\n    simp\n  · erw [Conv.mul_eq, Conv.one_eq]\n    simp\n\n"}
