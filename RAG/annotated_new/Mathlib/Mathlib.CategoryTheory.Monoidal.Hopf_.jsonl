{"name":"Hopf_Class.antipode_right'","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : C\nself : Hopf_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Hopf_Class.antipode) Mon_Class.mul)) (CategoryTheory.CategoryStruct.comp Comon_Class.counit Mon_Class.one)","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nclass Hopf_Class (X : C) extends Bimon_Class X where\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X ‚ü∂ X\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `X` is explicit. -/\n  antipode_left' : Œî ‚â´ antipode ‚ñ∑ X ‚â´ Œº = Œµ ‚â´ Œ∑ := by aesop_cat\n  antipode_right' : Œî ‚â´ X ‚óÅ antipode ‚â´ Œº = Œµ ‚â´ Œ∑ := by aesop_cat\n\n"}
{"name":"Hopf_Class.antipode_left'","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : C\nself : Hopf_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Hopf_Class.antipode X) Mon_Class.mul)) (CategoryTheory.CategoryStruct.comp Comon_Class.counit Mon_Class.one)","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nclass Hopf_Class (X : C) extends Bimon_Class X where\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X ‚ü∂ X\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `X` is explicit. -/\n  antipode_left' : Œî ‚â´ antipode ‚ñ∑ X ‚â´ Œº = Œµ ‚â´ Œ∑ := by aesop_cat\n  antipode_right' : Œî ‚â´ X ‚óÅ antipode ‚â´ Œº = Œµ ‚â´ Œ∑ := by aesop_cat\n\n"}
{"name":"Hopf_Class.antipode_left'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : C\nself : Hopf_Class X\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Hopf_Class.antipode X) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h))) (CategoryTheory.CategoryStruct.comp Comon_Class.counit (CategoryTheory.CategoryStruct.comp Mon_Class.one h))","decl":"attribute [reassoc] antipode_left' antipode_right'\n\n"}
{"name":"Hopf_Class.antipode_right'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX : C\nself : Hopf_Class X\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Hopf_Class.antipode) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h))) (CategoryTheory.CategoryStruct.comp Comon_Class.counit (CategoryTheory.CategoryStruct.comp Mon_Class.one h))","decl":"attribute [reassoc] antipode_left' antipode_right'\n\n"}
{"name":"Hopf_Class.antipode_left","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\nX : C\ninst‚úù : Hopf_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Hopf_Class.antipode X) Mon_Class.mul)) (CategoryTheory.CategoryStruct.comp Comon_Class.counit Mon_Class.one)","decl":"/-- The object is provided as an explicit argument. -/\n@[reassoc (attr := simp)]\ntheorem antipode_left (X : C) [Hopf_Class X] : Œî ‚â´ ùíÆ ‚ñ∑ X ‚â´ Œº = Œµ ‚â´ Œ∑ := antipode_left'\n\n"}
{"name":"Hopf_Class.antipode_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\nX : C\ninst‚úù : Hopf_Class X\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight Hopf_Class.antipode X) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h))) (CategoryTheory.CategoryStruct.comp Comon_Class.counit (CategoryTheory.CategoryStruct.comp Mon_Class.one h))","decl":"/-- The object is provided as an explicit argument. -/\n@[reassoc (attr := simp)]\ntheorem antipode_left (X : C) [Hopf_Class X] : Œî ‚â´ ùíÆ ‚ñ∑ X ‚â´ Œº = Œµ ‚â´ Œ∑ := antipode_left'\n\n"}
{"name":"Hopf_Class.antipode_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\nX : C\ninst‚úù : Hopf_Class X\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Hopf_Class.antipode) (CategoryTheory.CategoryStruct.comp Mon_Class.mul h))) (CategoryTheory.CategoryStruct.comp Comon_Class.counit (CategoryTheory.CategoryStruct.comp Mon_Class.one h))","decl":"/-- The object is provided as an explicit argument. -/\n@[reassoc (attr := simp)]\ntheorem antipode_right (X : C) [Hopf_Class X] : Œî ‚â´ X ‚óÅ ùíÆ ‚â´ Œº = Œµ ‚â´ Œ∑ := antipode_right'\n\n"}
{"name":"Hopf_Class.antipode_right","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\nX : C\ninst‚úù : Hopf_Class X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Comon_Class.comul (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X Hopf_Class.antipode) Mon_Class.mul)) (CategoryTheory.CategoryStruct.comp Comon_Class.counit Mon_Class.one)","decl":"/-- The object is provided as an explicit argument. -/\n@[reassoc (attr := simp)]\ntheorem antipode_right (X : C) [Hopf_Class X] : Œî ‚â´ X ‚óÅ ùíÆ ‚â´ Œº = Œµ ‚â´ Œ∑ := antipode_right'\n\n"}
{"name":"Hopf_.antipode_right","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nself : Hopf_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X.X.X self.antipode) self.X.X.mul)) (CategoryTheory.CategoryStruct.comp self.X.counit.hom self.X.X.one)","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nstructure Hopf_ where\n  /-- The underlying bimonoid of a Hopf monoid. -/\n  X : Bimon_ C\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X.X.X ‚ü∂ X.X.X\n  antipode_left : X.comul.hom ‚â´ (antipode ‚ñ∑ X.X.X) ‚â´ X.X.mul = X.counit.hom ‚â´ X.X.one\n  antipode_right : X.comul.hom ‚â´ (X.X.X ‚óÅ antipode) ‚â´ X.X.mul = X.counit.hom ‚â´ X.X.one\n\n"}
{"name":"Hopf_.antipode_left","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nself : Hopf_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.antipode self.X.X.X) self.X.X.mul)) (CategoryTheory.CategoryStruct.comp self.X.counit.hom self.X.X.one)","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nstructure Hopf_ where\n  /-- The underlying bimonoid of a Hopf monoid. -/\n  X : Bimon_ C\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X.X.X ‚ü∂ X.X.X\n  antipode_left : X.comul.hom ‚â´ (antipode ‚ñ∑ X.X.X) ‚â´ X.X.mul = X.counit.hom ‚â´ X.X.one\n  antipode_right : X.comul.hom ‚â´ (X.X.X ‚óÅ antipode) ‚â´ X.X.mul = X.counit.hom ‚â´ X.X.one\n\n"}
{"name":"Hopf_.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\ninst‚úù : SizeOf C\nX : Bimon_ C\nantipode : Quiver.Hom X.X.X X.X.X\nantipode_left : Eq (CategoryTheory.CategoryStruct.comp X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight antipode X.X.X) X.X.mul)) (CategoryTheory.CategoryStruct.comp X.counit.hom X.X.one)\nantipode_right : Eq (CategoryTheory.CategoryStruct.comp X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.X.X antipode) X.X.mul)) (CategoryTheory.CategoryStruct.comp X.counit.hom X.X.one)\n‚ä¢ Eq (SizeOf.sizeOf { X := X, antipode := antipode, antipode_left := antipode_left, antipode_right := antipode_right }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf antipode)) (SizeOf.sizeOf antipode_left)) (SizeOf.sizeOf antipode_right))","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nstructure Hopf_ where\n  /-- The underlying bimonoid of a Hopf monoid. -/\n  X : Bimon_ C\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X.X.X ‚ü∂ X.X.X\n  antipode_left : X.comul.hom ‚â´ (antipode ‚ñ∑ X.X.X) ‚â´ X.X.mul = X.counit.hom ‚â´ X.X.one\n  antipode_right : X.comul.hom ‚â´ (X.X.X ‚óÅ antipode) ‚â´ X.X.mul = X.counit.hom ‚â´ X.X.one\n\n"}
{"name":"Hopf_.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX‚úù : Bimon_ C\nantipode‚úù : Quiver.Hom X‚úù.X.X X‚úù.X.X\nantipode_left‚úù : Eq (CategoryTheory.CategoryStruct.comp X‚úù.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight antipode‚úù X‚úù.X.X) X‚úù.X.mul)) (CategoryTheory.CategoryStruct.comp X‚úù.counit.hom X‚úù.X.one)\nantipode_right‚úù : Eq (CategoryTheory.CategoryStruct.comp X‚úù.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X‚úù.X.X antipode‚úù) X‚úù.X.mul)) (CategoryTheory.CategoryStruct.comp X‚úù.counit.hom X‚úù.X.one)\nX : Bimon_ C\nantipode : Quiver.Hom X.X.X X.X.X\nantipode_left : Eq (CategoryTheory.CategoryStruct.comp X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight antipode X.X.X) X.X.mul)) (CategoryTheory.CategoryStruct.comp X.counit.hom X.X.one)\nantipode_right : Eq (CategoryTheory.CategoryStruct.comp X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.X.X antipode) X.X.mul)) (CategoryTheory.CategoryStruct.comp X.counit.hom X.X.one)\nx‚úù : Eq { X := X‚úù, antipode := antipode‚úù, antipode_left := antipode_left‚úù, antipode_right := antipode_right‚úù } { X := X, antipode := antipode, antipode_left := antipode_left, antipode_right := antipode_right }\n‚ä¢ And (Eq X‚úù X) (HEq antipode‚úù antipode)","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nstructure Hopf_ where\n  /-- The underlying bimonoid of a Hopf monoid. -/\n  X : Bimon_ C\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X.X.X ‚ü∂ X.X.X\n  antipode_left : X.comul.hom ‚â´ (antipode ‚ñ∑ X.X.X) ‚â´ X.X.mul = X.counit.hom ‚â´ X.X.one\n  antipode_right : X.comul.hom ‚â´ (X.X.X ‚óÅ antipode) ‚â´ X.X.mul = X.counit.hom ‚â´ X.X.one\n\n"}
{"name":"Hopf_.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX‚úù : Bimon_ C\nantipode‚úù : Quiver.Hom X‚úù.X.X X‚úù.X.X\nantipode_left‚úù : Eq (CategoryTheory.CategoryStruct.comp X‚úù.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight antipode‚úù X‚úù.X.X) X‚úù.X.mul)) (CategoryTheory.CategoryStruct.comp X‚úù.counit.hom X‚úù.X.one)\nantipode_right‚úù : Eq (CategoryTheory.CategoryStruct.comp X‚úù.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X‚úù.X.X antipode‚úù) X‚úù.X.mul)) (CategoryTheory.CategoryStruct.comp X‚úù.counit.hom X‚úù.X.one)\nX : Bimon_ C\nantipode : Quiver.Hom X.X.X X.X.X\nantipode_left : Eq (CategoryTheory.CategoryStruct.comp X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight antipode X.X.X) X.X.mul)) (CategoryTheory.CategoryStruct.comp X.counit.hom X.X.one)\nantipode_right : Eq (CategoryTheory.CategoryStruct.comp X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.X.X antipode) X.X.mul)) (CategoryTheory.CategoryStruct.comp X.counit.hom X.X.one)\n‚ä¢ Eq (Eq { X := X‚úù, antipode := antipode‚úù, antipode_left := antipode_left‚úù, antipode_right := antipode_right‚úù } { X := X, antipode := antipode, antipode_left := antipode_left, antipode_right := antipode_right }) (And (Eq X‚úù X) (HEq antipode‚úù antipode))","decl":"/--\nA Hopf monoid in a braided category `C` is a bimonoid object in `C` equipped with an antipode.\n-/\nstructure Hopf_ where\n  /-- The underlying bimonoid of a Hopf monoid. -/\n  X : Bimon_ C\n  /-- The antipode is an endomorphism of the underlying object of the Hopf monoid. -/\n  antipode : X.X.X ‚ü∂ X.X.X\n  antipode_left : X.comul.hom ‚â´ (antipode ‚ñ∑ X.X.X) ‚â´ X.X.mul = X.counit.hom ‚â´ X.X.one\n  antipode_right : X.comul.hom ‚â´ (X.X.X ‚óÅ antipode) ‚â´ X.X.mul = X.counit.hom ‚â´ X.X.one\n\n"}
{"name":"Hopf_.antipode_right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nself : Hopf_ C\nZ : C\nh : Quiver.Hom self.X.X.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X.X.X self.antipode) (CategoryTheory.CategoryStruct.comp self.X.X.mul h))) (CategoryTheory.CategoryStruct.comp self.X.counit.hom (CategoryTheory.CategoryStruct.comp self.X.X.one h))","decl":"attribute [reassoc (attr := simp)] Hopf_.antipode_left Hopf_.antipode_right\n\n"}
{"name":"Hopf_.antipode_left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nself : Hopf_ C\nZ : C\nh : Quiver.Hom self.X.X.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.antipode self.X.X.X) (CategoryTheory.CategoryStruct.comp self.X.X.mul h))) (CategoryTheory.CategoryStruct.comp self.X.counit.hom (CategoryTheory.CategoryStruct.comp self.X.X.one h))","decl":"attribute [reassoc (attr := simp)] Hopf_.antipode_left Hopf_.antipode_right\n\n"}
{"name":"Hopf_.hom_antipode","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA B : Hopf_ C\nf : Quiver.Hom A B\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.hom.hom B.antipode) (CategoryTheory.CategoryStruct.comp A.antipode f.hom.hom)","decl":"/-- Morphisms of Hopf monoids intertwine the antipodes. -/\ntheorem hom_antipode {A B : Hopf_ C} (f : A ‚ü∂ B) :\n    f.hom.hom ‚â´ B.antipode = A.antipode ‚â´ f.hom.hom := by\n  -- We show these elements are equal by exhibiting an element in the convolution algebra\n  -- between `A` (as a comonoid) and `B` (as a monoid),\n  -- such that the LHS is a left inverse, and the RHS is a right inverse.\n  apply left_inv_eq_right_inv\n    (M := Conv ((Bimon_.toComon_ C).obj A.X) B.X.X)\n    (a := f.hom.hom)\n  ¬∑ erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Bimon_.toComon__obj_X, Bimon_.toComon__obj_comul, comp_whiskerRight, Category.assoc,\n      Bimon_.toComon__obj_counit]\n    slice_lhs 3 4 =>\n      rw [‚Üê whisker_exchange]\n    slice_lhs 2 3 =>\n      rw [‚Üê tensorHom_def]\n    slice_lhs 1 2 =>\n      rw [‚Üê Bimon_.hom_comul_hom f]\n    slice_lhs 2 4 =>\n      rw [B.antipode_left]\n    slice_lhs 1 2 =>\n      rw [Bimon_.hom_counit_hom f]\n  ¬∑ erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Bimon_.toComon__obj_X, Bimon_.toComon__obj_comul, MonoidalCategory.whiskerLeft_comp,\n      Category.assoc, Bimon_.toComon__obj_counit]\n    slice_lhs 2 3 =>\n      rw [‚Üê whisker_exchange]\n    slice_lhs 3 4 =>\n      rw [‚Üê tensorHom_def]\n    slice_lhs 3 4 =>\n      rw [‚Üê f.hom.mul_hom]\n    slice_lhs 1 3 =>\n      rw [A.antipode_right]\n    slice_lhs 2 3 =>\n      rw [f.hom.one_hom]\n\n"}
{"name":"Hopf_.one_antipode_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Hopf_ C\nZ : C\nh : Quiver.Hom A.X.X.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.X.X.one (CategoryTheory.CategoryStruct.comp A.antipode h)) (CategoryTheory.CategoryStruct.comp A.X.X.one h)","decl":"@[reassoc (attr := simp)]\ntheorem one_antipode (A : Hopf_ C) : A.X.X.one ‚â´ A.antipode = A.X.X.one := by\n  have := (rfl : A.X.X.one ‚â´ A.X.comul.hom ‚â´ (A.antipode ‚ñ∑ A.X.X.X) ‚â´ A.X.X.mul = _)\n  conv at this =>\n    rhs\n    rw [A.antipode_left]\n  rw [A.X.one_comul_assoc, tensorHom_def, Category.assoc, whisker_exchange_assoc] at this\n  simpa [unitors_inv_equal]\n\n"}
{"name":"Hopf_.one_antipode","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.X.X.one A.antipode) A.X.X.one","decl":"@[reassoc (attr := simp)]\ntheorem one_antipode (A : Hopf_ C) : A.X.X.one ‚â´ A.antipode = A.X.X.one := by\n  have := (rfl : A.X.X.one ‚â´ A.X.comul.hom ‚â´ (A.antipode ‚ñ∑ A.X.X.X) ‚â´ A.X.X.mul = _)\n  conv at this =>\n    rhs\n    rw [A.antipode_left]\n  rw [A.X.one_comul_assoc, tensorHom_def, Category.assoc, whisker_exchange_assoc] at this\n  simpa [unitors_inv_equal]\n\n"}
{"name":"Hopf_.antipode_counit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Hopf_ C\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.antipode (CategoryTheory.CategoryStruct.comp A.X.counit.hom h)) (CategoryTheory.CategoryStruct.comp A.X.counit.hom h)","decl":"@[reassoc (attr := simp)]\ntheorem antipode_counit (A : Hopf_ C) : A.antipode ‚â´ A.X.counit.hom = A.X.counit.hom := by\n  have := (rfl : A.X.comul.hom ‚â´ (A.antipode ‚ñ∑ A.X.X.X) ‚â´ A.X.X.mul ‚â´ A.X.counit.hom = _)\n  conv at this =>\n    rhs\n    rw [A.antipode_left_assoc]\n  rw [A.X.mul_counit, tensorHom_def', Category.assoc, ‚Üê whisker_exchange_assoc] at this\n  simpa [unitors_equal]\n\n"}
{"name":"Hopf_.antipode_counit","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.antipode A.X.counit.hom) A.X.counit.hom","decl":"@[reassoc (attr := simp)]\ntheorem antipode_counit (A : Hopf_ C) : A.antipode ‚â´ A.X.counit.hom = A.X.counit.hom := by\n  have := (rfl : A.X.comul.hom ‚â´ (A.antipode ‚ñ∑ A.X.X.X) ‚â´ A.X.X.mul ‚â´ A.X.counit.hom = _)\n  conv at this =>\n    rhs\n    rw [A.antipode_left_assoc]\n  rw [A.X.mul_counit, tensorHom_def', Category.assoc, ‚Üê whisker_exchange_assoc] at this\n  simpa [unitors_equal]\n\n"}
{"name":"Hopf_.antipode_comul‚ÇÅ","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.antipode A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.X.comul.hom A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X A.X.comul.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom A.X.X.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X.X.X A.X.X.X)).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.X.mul A.X.X.mul)))))))))) (CategoryTheory.CategoryStruct.comp A.X.counit.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.X.one A.X.X.one)))","decl":"theorem antipode_comul‚ÇÅ (A : Hopf_ C) :\n    A.X.comul.hom ‚â´\n      A.antipode ‚ñ∑ A.X.X.X ‚â´\n      A.X.comul.hom ‚ñ∑ A.X.X.X ‚â´\n      (Œ±_ A.X.X.X A.X.X.X A.X.X.X).hom ‚â´\n      A.X.X.X ‚óÅ A.X.X.X ‚óÅ A.X.comul.hom ‚â´\n      A.X.X.X ‚óÅ (Œ±_ A.X.X.X A.X.X.X A.X.X.X).inv ‚â´\n      A.X.X.X ‚óÅ (Œ≤_ A.X.X.X A.X.X.X).hom ‚ñ∑ A.X.X.X ‚â´\n      A.X.X.X ‚óÅ (Œ±_ A.X.X.X A.X.X.X A.X.X.X).hom ‚â´\n      (Œ±_ A.X.X.X A.X.X.X (A.X.X.X ‚äó A.X.X.X)).inv ‚â´\n      (A.X.X.mul ‚äó A.X.X.mul) =\n    A.X.counit.hom ‚â´ (Œª_ (ùüô_ C)).inv ‚â´ (A.X.X.one ‚äó A.X.X.one) := by\n  dsimp\n  slice_lhs 3 5 =>\n    rw [‚Üê associator_naturality_right, ‚Üê Category.assoc, ‚Üê tensorHom_def]\n  slice_lhs 3 9 =>\n    erw [Bimon_.compatibility]\n  slice_lhs 1 3 =>\n    erw [A.antipode_left]\n  simp\n\n"}
{"name":"Hopf_.antipode_comul‚ÇÇ","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.X.comul.hom A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X A.X.comul.hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorHom A.antipode A.antipode))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom A.X.X.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X.X.X A.X.X.X)).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.X.mul A.X.X.mul))))))))))) (CategoryTheory.CategoryStruct.comp A.X.counit.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.X.one A.X.X.one)))","decl":"/--\nAuxiliary calculation for `antipode_comul`.\nThis calculation calls for some ASCII art out of This Week's Finds.\n\n```\n   |   |\n   n   n\n  | \\ / |\n  |  /  |\n  | / \\ |\n  | | S S\n  | | \\ /\n  | |  /\n  | | / \\\n  \\ / \\ /\n   v   v\n    \\ /\n     v\n     |\n```\n\nWe move the left antipode up through the crossing,\nthe right antipode down through the crossing,\nthe right multiplication down across the strand,\nreassociate the comultiplications,\nthen use `antipode_right` then `antipode_left` to simplify.\n-/\ntheorem antipode_comul‚ÇÇ (A : Hopf_ C) :\n    A.X.comul.hom ‚â´\n      A.X.comul.hom ‚ñ∑ A.X.X.X ‚â´\n      (Œ±_ A.X.X.X A.X.X.X A.X.X.X).hom ‚â´\n      A.X.X.X ‚óÅ A.X.X.X ‚óÅ A.X.comul.hom ‚â´\n      A.X.X.X ‚óÅ A.X.X.X ‚óÅ (Œ≤_ A.X.X.X A.X.X.X).hom ‚â´\n      A.X.X.X ‚óÅ A.X.X.X ‚óÅ (A.antipode ‚äó A.antipode) ‚â´\n      A.X.X.X ‚óÅ (Œ±_ A.X.X.X A.X.X.X A.X.X.X).inv ‚â´\n      A.X.X.X ‚óÅ (Œ≤_ A.X.X.X A.X.X.X).hom ‚ñ∑ A.X.X.X ‚â´\n      A.X.X.X ‚óÅ (Œ±_ A.X.X.X A.X.X.X A.X.X.X).hom ‚â´\n      (Œ±_ A.X.X.X A.X.X.X (A.X.X.X ‚äó A.X.X.X)).inv ‚â´\n      (A.X.X.mul ‚äó A.X.X.mul) =\n    A.X.counit.hom ‚â´ (Œª_ (ùüô_ C)).inv ‚â´ (A.X.X.one ‚äó A.X.X.one) := by\n  -- We should write a version of `slice_lhs` that zooms through whiskerings.\n  slice_lhs 6 6 =>\n    simp only [tensorHom_def', MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 7 8 =>\n    rw [‚Üê MonoidalCategory.whiskerLeft_comp, associator_inv_naturality_middle,\n      MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 8 9 =>\n    rw [‚Üê MonoidalCategory.whiskerLeft_comp, ‚Üê comp_whiskerRight,\n      BraidedCategory.braiding_naturality_right,\n      comp_whiskerRight, MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 9 10 =>\n    rw [‚Üê MonoidalCategory.whiskerLeft_comp,\n      associator_naturality_left,\n      MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 5 6 =>\n    rw [‚Üê MonoidalCategory.whiskerLeft_comp, ‚Üê MonoidalCategory.whiskerLeft_comp,\n      ‚Üê BraidedCategory.braiding_naturality_left,\n      MonoidalCategory.whiskerLeft_comp, MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 11 12 =>\n    rw [tensorHom_def', ‚Üê Category.assoc, ‚Üê associator_inv_naturality_right]\n  slice_lhs 10 11 =>\n    rw [‚Üê MonoidalCategory.whiskerLeft_comp, ‚Üê whisker_exchange,\n      MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 6 10 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [‚Üê BraidedCategory.hexagon_reverse_assoc, Iso.inv_hom_id_assoc,\n      ‚Üê BraidedCategory.braiding_naturality_left]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  rw [Bimon_.comul_assoc_flip_hom_assoc, Iso.inv_hom_id_assoc]\n  slice_lhs 2 3 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [Bimon_.comul_assoc_hom]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 3 7 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [‚Üê associator_naturality_middle_assoc, Iso.hom_inv_id_assoc]\n    simp only [‚Üê comp_whiskerRight]\n    rw [antipode_right]\n    simp only [comp_whiskerRight]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 2 3 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [Bimon_.counit_comul_hom]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 3 4 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [BraidedCategory.braiding_naturality_left]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 4 5 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [whisker_exchange]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 5 7 =>\n    rw [associator_inv_naturality_right_assoc, whisker_exchange]\n  simp only [Mon_.monMonoidalStruct_tensorObj_X, Mon_.tensorUnit_X, braiding_tensorUnit_left,\n    MonoidalCategory.whiskerLeft_comp, whiskerLeft_rightUnitor_inv,\n    MonoidalCategory.whiskerRight_id, whiskerLeft_rightUnitor, Category.assoc, Iso.hom_inv_id_assoc,\n    Iso.inv_hom_id_assoc, whiskerLeft_inv_hom_assoc, antipode_right_assoc]\n  rw [rightUnitor_inv_naturality_assoc, tensorHom_def]\n  monoidal\n\n"}
{"name":"Hopf_.antipode_comul","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.antipode A.X.comul.hom) (CategoryTheory.CategoryStruct.comp A.X.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom (CategoryTheory.MonoidalCategoryStruct.tensorHom A.antipode A.antipode)))","decl":"theorem antipode_comul (A : Hopf_ C) :\n    A.antipode ‚â´ A.X.comul.hom = A.X.comul.hom ‚â´ (Œ≤_ _ _).hom ‚â´ (A.antipode ‚äó A.antipode) := by\n  -- Again, it is a \"left inverse equals right inverse\" argument in the convolution monoid.\n  apply left_inv_eq_right_inv\n    (M := Conv ((Bimon_.toComon_ C).obj A.X) (A.X.X ‚äó A.X.X))\n    (a := A.X.comul.hom)\n  ¬∑ erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Bimon_.toComon__obj_X, Mon_.monMonoidalStruct_tensorObj_X, Bimon_.toComon__obj_comul,\n      comp_whiskerRight, tensor_whiskerLeft, Mon_.tensorObj_mul, Category.assoc,\n      Bimon_.toComon__obj_counit, Mon_.tensorObj_one]\n    simp only [tensorŒº]\n    simp only [Category.assoc, Iso.inv_hom_id_assoc]\n    exact antipode_comul‚ÇÅ A\n  ¬∑ erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Bimon_.toComon__obj_X, Mon_.monMonoidalStruct_tensorObj_X, Bimon_.toComon__obj_comul,\n      MonoidalCategory.whiskerLeft_comp, tensor_whiskerLeft, Category.assoc, Iso.inv_hom_id_assoc,\n      Mon_.tensorObj_mul, Bimon_.toComon__obj_counit, Mon_.tensorObj_one]\n    simp only [tensorŒº]\n    simp only [Category.assoc, Iso.inv_hom_id_assoc]\n    exact antipode_comul‚ÇÇ A\n\n"}
{"name":"Hopf_.mul_antipode‚ÇÅ","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.comul.hom A.X.comul.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X.X.X A.X.X.X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom A.X.X.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X.X.X A.X.X.X) A.X.X.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).inv A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.X.X.mul A.X.X.X) A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.antipode A.X.X.X) A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X A.X.X.mul) A.X.X.mul)))))))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.counit.hom A.X.counit.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom A.X.X.one))","decl":"theorem mul_antipode‚ÇÅ (A : Hopf_ C) :\n    (A.X.comul.hom ‚äó A.X.comul.hom) ‚â´\n      (Œ±_ A.X.X.X A.X.X.X (A.X.X.X ‚äó A.X.X.X)).hom ‚â´\n      A.X.X.X ‚óÅ (Œ±_ A.X.X.X A.X.X.X A.X.X.X).inv ‚â´\n      A.X.X.X ‚óÅ (Œ≤_ A.X.X.X A.X.X.X).hom ‚ñ∑ A.X.X.X ‚â´\n      (Œ±_ A.X.X.X (A.X.X.X ‚äó A.X.X.X) A.X.X.X).inv ‚â´\n      (Œ±_ A.X.X.X A.X.X.X A.X.X.X).inv ‚ñ∑ A.X.X.X ‚â´\n      A.X.X.mul ‚ñ∑ A.X.X.X ‚ñ∑ A.X.X.X ‚â´\n      A.antipode ‚ñ∑ A.X.X.X ‚ñ∑ A.X.X.X ‚â´\n      (Œ±_ A.X.X.X A.X.X.X A.X.X.X).hom ‚â´\n      A.X.X.X ‚óÅ A.X.X.mul ‚â´\n      A.X.X.mul =\n    (A.X.counit.hom ‚äó A.X.counit.hom) ‚â´ (Œª_ (ùüô_ C)).hom ‚â´ A.X.X.one := by\n  slice_lhs 8 9 =>\n    rw [associator_naturality_left]\n  slice_lhs 9 10 =>\n    rw [‚Üê whisker_exchange]\n  slice_lhs 7 8 =>\n    rw [associator_naturality_left]\n  slice_lhs 8 9 =>\n    rw [‚Üê tensorHom_def]\n  simp only [Mon_.monMonoidalStruct_tensorObj_X, Category.assoc, pentagon_inv_inv_hom_hom_inv_assoc,\n    Mon_.tensorUnit_X]\n  slice_lhs 1 7 =>\n    erw [Bimon_.compatibility]\n  slice_lhs 2 4 =>\n    rw [antipode_left]\n  simp\n\n\n"}
{"name":"Hopf_.mul_antipode‚ÇÇ","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.comul.hom A.X.comul.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X.X.X A.X.X.X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom A.X.X.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X.X.X A.X.X.X) A.X.X.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).inv A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.X.X.mul A.X.X.X) A.X.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X.X.X A.X.X.X A.X.X.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X (CategoryTheory.MonoidalCategoryStruct.tensorHom A.antipode A.antipode)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X.X.X A.X.X.mul) A.X.X.mul))))))))))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom A.X.counit.hom A.X.counit.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom A.X.X.one))","decl":"/--\nAuxiliary calculation for `mul_antipode`.\n\n```\n       |\n       n\n      /  \\\n     |   n\n     |  / \\\n     |  S S\n     |  \\ /\n     n   /\n    / \\ / \\\n    |  /  |\n    \\ / \\ /\n     v   v\n     |   |\n```\n\nWe move the leftmost multiplication up, so we can reassociate.\nWe then move the rightmost comultiplication under the strand,\nand simplify using `antipode_right`.\n-/\ntheorem mul_antipode‚ÇÇ (A : Hopf_ C) :\n    (A.X.comul.hom ‚äó A.X.comul.hom) ‚â´\n      (Œ±_ A.X.X.X A.X.X.X (A.X.X.X ‚äó A.X.X.X)).hom ‚â´\n      A.X.X.X ‚óÅ (Œ±_ A.X.X.X A.X.X.X A.X.X.X).inv ‚â´\n      A.X.X.X ‚óÅ (Œ≤_ A.X.X.X A.X.X.X).hom ‚ñ∑ A.X.X.X ‚â´\n      (Œ±_ A.X.X.X (A.X.X.X ‚äó A.X.X.X) A.X.X.X).inv ‚â´\n      (Œ±_ A.X.X.X A.X.X.X A.X.X.X).inv ‚ñ∑ A.X.X.X ‚â´\n      A.X.X.mul ‚ñ∑ A.X.X.X ‚ñ∑ A.X.X.X ‚â´\n      (Œ±_ A.X.X.X A.X.X.X A.X.X.X).hom ‚â´\n      A.X.X.X ‚óÅ (Œ≤_ A.X.X.X A.X.X.X).hom ‚â´\n      A.X.X.X ‚óÅ (A.antipode ‚äó A.antipode) ‚â´\n      A.X.X.X ‚óÅ A.X.X.mul ‚â´ A.X.X.mul =\n    (A.X.counit.hom ‚äó A.X.counit.hom) ‚â´ (Œª_ (ùüô_ C)).hom ‚â´ A.X.X.one := by\n  slice_lhs 7 8 =>\n    rw [associator_naturality_left]\n  slice_lhs 8 9 =>\n    rw [‚Üê whisker_exchange]\n  slice_lhs 9 10 =>\n    rw [‚Üê whisker_exchange]\n  slice_lhs 11 12 =>\n    rw [Mon_.mul_assoc_flip]\n  slice_lhs 10 11 =>\n    rw [associator_inv_naturality_left]\n  slice_lhs 11 12 =>\n    simp only [‚Üê comp_whiskerRight]\n    rw [Mon_.mul_assoc]\n    simp only [comp_whiskerRight]\n  rw [tensorHom_def]\n  rw [tensor_whiskerLeft]\n  rw [pentagon_inv_inv_hom_hom_inv_assoc]\n  slice_lhs 7 8 =>\n    rw [Iso.inv_hom_id]\n  rw [Category.id_comp]\n  slice_lhs 5 7 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [‚Üê BraidedCategory.hexagon_forward]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  simp only [Mon_.monMonoidalStruct_tensorObj_X, tensor_whiskerLeft,\n    MonoidalCategory.whiskerLeft_comp, Category.assoc,\n    whiskerLeft_inv_hom, Category.comp_id, whiskerLeft_hom_inv_assoc, Iso.inv_hom_id_assoc,\n    pentagon_inv_inv_hom_inv_inv, whisker_assoc, Mon_.mul_assoc, Mon_.tensorUnit_X]\n  slice_lhs 4 5 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [Iso.inv_hom_id]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  rw [MonoidalCategory.whiskerLeft_id, Category.id_comp]\n  slice_lhs 3 4 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [BraidedCategory.braiding_naturality_right]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  rw [tensorHom_def']\n  simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 5 6 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [‚Üê associator_naturality_right]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 4 5 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [‚Üê whisker_exchange]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 5 9 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [associator_inv_naturality_middle_assoc, Iso.hom_inv_id_assoc]\n    simp only [‚Üê comp_whiskerRight]\n    rw [antipode_right]\n    simp only [comp_whiskerRight]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 6 7 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [A.X.X.one_mul]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 3 4 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [‚Üê BraidedCategory.braiding_naturality_left]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 4 5 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [‚Üê BraidedCategory.braiding_naturality_right]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  rw [‚Üê associator_naturality_middle_assoc]\n  simp only [Mon_.tensorUnit_X, braiding_tensorUnit_right, MonoidalCategory.whiskerLeft_comp]\n  slice_lhs 6 7 =>\n    simp only [‚Üê MonoidalCategory.whiskerLeft_comp]\n    rw [Iso.inv_hom_id]\n    simp only [MonoidalCategory.whiskerLeft_comp]\n  simp only [MonoidalCategory.whiskerLeft_id, Category.id_comp]\n  slice_lhs 5 6 =>\n    rw [whiskerLeft_rightUnitor, Category.assoc, ‚Üê rightUnitor_naturality]\n  rw [associator_inv_naturality_right_assoc, Iso.hom_inv_id_assoc]\n  slice_lhs 3 4 =>\n    rw [whisker_exchange]\n  slice_lhs 1 3 =>\n    simp only [‚Üê comp_whiskerRight]\n    rw [antipode_right]\n    simp only [comp_whiskerRight]\n  slice_lhs 2 3 =>\n    rw [‚Üê whisker_exchange]\n  slice_lhs 1 2 =>\n    dsimp\n    rw [‚Üê tensorHom_def]\n  slice_lhs 2 3 =>\n    rw [rightUnitor_naturality]\n  simp only [Mon_.tensorUnit_X]\n  monoidal\n\n"}
{"name":"Hopf_.mul_antipode","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Hopf_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.X.X.mul A.antipode) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom A.antipode A.antipode) (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom A.X.X.mul))","decl":"theorem mul_antipode (A : Hopf_ C) :\n    A.X.X.mul ‚â´ A.antipode = (A.antipode ‚äó A.antipode) ‚â´ (Œ≤_ _ _).hom ‚â´ A.X.X.mul := by\n  -- Again, it is a \"left inverse equals right inverse\" argument in the convolution monoid.\n  apply left_inv_eq_right_inv\n    (M := Conv (((Bimon_.toComon_ C).obj A.X) ‚äó ((Bimon_.toComon_ C).obj A.X)) A.X.X)\n    (a := A.X.X.mul)\n  ¬∑ -- Unfold the algebra structure in the convolution monoid,\n    -- then `simp?, simp only [tensor_Œº], simp?`.\n    erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Monoidal.transportStruct_tensorObj, Equivalence.symm_functor,\n      Comon_.Comon_EquivMon_OpOp_inverse, Equivalence.symm_inverse,\n      Comon_.Comon_EquivMon_OpOp_functor, Comon_.Comon_ToMon_OpOp_obj, Comon_.Mon_OpOpToComon__obj,\n      unop_tensorObj, Comon_.Mon_OpOpToComon_obj'_X, Mon_.monMonoidalStruct_tensorObj_X,\n      Comon_.Comon_ToMon_OpOp_obj'_X, Bimon_.toComon__obj_X, Comon_.Mon_OpOpToComon_obj'_comul,\n      Mon_.tensorObj_mul, Comon_.Comon_ToMon_OpOp_obj'_mul, Bimon_.toComon__obj_comul, unop_comp,\n      unop_tensorHom, Quiver.Hom.unop_op, whiskerRight_tensor, comp_whiskerRight, Category.assoc,\n      Comon_.Mon_OpOpToComon_obj'_counit, Mon_.tensorObj_one, Comon_.Comon_ToMon_OpOp_obj'_one,\n      Bimon_.toComon__obj_counit, unop_tensorUnit, unop_inv_leftUnitor]\n    simp only [tensorŒº]\n    simp only [unop_comp, unop_tensorObj, unop_inv_associator, unop_whiskerLeft,\n      unop_hom_associator, unop_whiskerRight, unop_hom_braiding, Category.assoc,\n      pentagon_hom_inv_inv_inv_inv_assoc]\n    exact mul_antipode‚ÇÅ A\n  ¬∑ erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Monoidal.transportStruct_tensorObj, Equivalence.symm_functor,\n      Comon_.Comon_EquivMon_OpOp_inverse, Equivalence.symm_inverse,\n      Comon_.Comon_EquivMon_OpOp_functor, Comon_.Comon_ToMon_OpOp_obj, Comon_.Mon_OpOpToComon__obj,\n      unop_tensorObj, Comon_.Mon_OpOpToComon_obj'_X, Mon_.monMonoidalStruct_tensorObj_X,\n      Comon_.Comon_ToMon_OpOp_obj'_X, Bimon_.toComon__obj_X, Comon_.Mon_OpOpToComon_obj'_comul,\n      Mon_.tensorObj_mul, Comon_.Comon_ToMon_OpOp_obj'_mul, Bimon_.toComon__obj_comul, unop_comp,\n      unop_tensorHom, Quiver.Hom.unop_op, whiskerRight_tensor,\n      BraidedCategory.braiding_naturality_assoc, MonoidalCategory.whiskerLeft_comp, Category.assoc,\n      Comon_.Mon_OpOpToComon_obj'_counit, Mon_.tensorObj_one, Comon_.Comon_ToMon_OpOp_obj'_one,\n      Bimon_.toComon__obj_counit, unop_tensorUnit, unop_inv_leftUnitor]\n    simp only [tensorŒº]\n    simp only [unop_comp, unop_tensorObj, unop_inv_associator, unop_whiskerLeft,\n      unop_hom_associator, unop_whiskerRight, unop_hom_braiding, Category.assoc,\n      pentagon_hom_inv_inv_inv_inv_assoc]\n    exact mul_antipode‚ÇÇ A\n\n"}
{"name":"Hopf_.antipode_antipode","module":"Mathlib.CategoryTheory.Monoidal.Hopf_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Hopf_ C\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.BraidedCategory.braiding A.X.X.X A.X.X.X).hom A.X.X.mul) A.X.X.mul\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.antipode A.antipode) (CategoryTheory.CategoryStruct.id A.X.X.X)","decl":"/--\nIn a commutative Hopf algebra, the antipode squares to the identity.\n-/\ntheorem antipode_antipode (A : Hopf_ C) (comm : (Œ≤_ _ _).hom ‚â´ A.X.X.mul = A.X.X.mul) :\n    A.antipode ‚â´ A.antipode = ùüô A.X.X.X := by\n  -- Again, it is a \"left inverse equals right inverse\" argument in the convolution monoid.\n  apply left_inv_eq_right_inv\n    (M := Conv ((Bimon_.toComon_ C).obj A.X) A.X.X)\n    (a := A.antipode)\n  ¬∑ -- Unfold the algebra structure in the convolution monoid,\n    -- then `simp?`.\n    erw [Conv.mul_eq, Conv.one_eq]\n    simp only [Bimon_.toComon__obj_X, Bimon_.toComon__obj_comul, comp_whiskerRight, Category.assoc,\n      Bimon_.toComon__obj_counit]\n    rw [‚Üê comm, ‚Üê tensorHom_def_assoc, ‚Üê mul_antipode]\n    simp\n  ¬∑ erw [Conv.mul_eq, Conv.one_eq]\n    simp\n\n"}
