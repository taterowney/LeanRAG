{"name":"MulAction.QuotientAction.inv_mul_mem","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Group α\ninst✝¹ : Monoid β\ninst✝ : MulAction β α\nH : Subgroup α\nself : MulAction.QuotientAction β H\nb : β\na a' : α\na✝ : Membership.mem H (HMul.hMul (Inv.inv a) a')\n⊢ Membership.mem H (HMul.hMul (Inv.inv (HSMul.hSMul b a)) (HSMul.hSMul b a'))","decl":"/-- A typeclass for when a `MulAction β α` descends to the quotient `α ⧸ H`. -/\nclass QuotientAction : Prop where\n  /-- The action fulfils a normality condition on products that lie in `H`.\n    This ensures that the action descends to an action on the quotient `α ⧸ H`. -/\n  inv_mul_mem : ∀ (b : β) {a a' : α}, a⁻¹ * a' ∈ H → (b • a)⁻¹ * b • a' ∈ H\n\n"}
{"name":"AddAction.QuotientAction.inv_mul_mem","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝² : AddGroup α\ninst✝¹ : AddMonoid β\ninst✝ : AddAction β α\nH : AddSubgroup α\nself : AddAction.QuotientAction β H\nb : β\na a' : α\na✝ : Membership.mem H (HAdd.hAdd (Neg.neg a) a')\n⊢ Membership.mem H (HAdd.hAdd (Neg.neg (HVAdd.hVAdd b a)) (HVAdd.hVAdd b a'))","decl":"/-- A typeclass for when an `AddAction β α` descends to the quotient `α ⧸ H`. -/\nclass _root_.AddAction.QuotientAction {α : Type u} (β : Type v) [AddGroup α] [AddMonoid β]\n  [AddAction β α] (H : AddSubgroup α) : Prop where\n  /-- The action fulfils a normality condition on summands that lie in `H`.\n    This ensures that the action descends to an action on the quotient `α ⧸ H`. -/\n  inv_mul_mem : ∀ (b : β) {a a' : α}, -a + a' ∈ H → -(b +ᵥ a) + (b +ᵥ a') ∈ H\n\n"}
{"name":"AddAction.left_quotientAction","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\ninst✝ : AddGroup α\nH : AddSubgroup α\n⊢ AddAction.QuotientAction α H","decl":"@[to_additive]\ninstance left_quotientAction : QuotientAction α H :=\n  ⟨fun _ _ _ _ => by rwa [smul_eq_mul, smul_eq_mul, mul_inv_rev, mul_assoc, inv_mul_cancel_left]⟩\n\n"}
{"name":"MulAction.left_quotientAction","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\ninst✝ : Group α\nH : Subgroup α\n⊢ MulAction.QuotientAction α H","decl":"@[to_additive]\ninstance left_quotientAction : QuotientAction α H :=\n  ⟨fun _ _ _ _ => by rwa [smul_eq_mul, smul_eq_mul, mul_inv_rev, mul_assoc, inv_mul_cancel_left]⟩\n\n"}
{"name":"AddAction.right_quotientAction","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\ninst✝ : AddGroup α\nH : AddSubgroup α\n⊢ AddAction.QuotientAction (Subtype fun x => Membership.mem H.normalizer.op x) H","decl":"@[to_additive]\ninstance right_quotientAction : QuotientAction (normalizer H).op H :=\n  ⟨fun b c _ _ => by\n    rwa [smul_def, smul_def, smul_eq_mul_unop, smul_eq_mul_unop, mul_inv_rev, ← mul_assoc,\n      mem_normalizer_iff'.mp b.prop, mul_assoc, mul_inv_cancel_left]⟩\n\n"}
{"name":"MulAction.right_quotientAction","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\ninst✝ : Group α\nH : Subgroup α\n⊢ MulAction.QuotientAction (Subtype fun x => Membership.mem H.normalizer.op x) H","decl":"@[to_additive]\ninstance right_quotientAction : QuotientAction (normalizer H).op H :=\n  ⟨fun b c _ _ => by\n    rwa [smul_def, smul_def, smul_eq_mul_unop, smul_eq_mul_unop, mul_inv_rev, ← mul_assoc,\n      mem_normalizer_iff'.mp b.prop, mul_assoc, mul_inv_cancel_left]⟩\n\n"}
{"name":"AddAction.right_quotientAction'","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\ninst✝ : AddGroup α\nH : AddSubgroup α\nhH : H.Normal\n⊢ AddAction.QuotientAction (AddOpposite α) H","decl":"@[to_additive]\ninstance right_quotientAction' [hH : H.Normal] : QuotientAction αᵐᵒᵖ H :=\n  ⟨fun _ _ _ _ => by\n    rwa [smul_eq_mul_unop, smul_eq_mul_unop, mul_inv_rev, mul_assoc, hH.mem_comm_iff, mul_assoc,\n      mul_inv_cancel_right]⟩\n\n"}
{"name":"MulAction.right_quotientAction'","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\ninst✝ : Group α\nH : Subgroup α\nhH : H.Normal\n⊢ MulAction.QuotientAction (MulOpposite α) H","decl":"@[to_additive]\ninstance right_quotientAction' [hH : H.Normal] : QuotientAction αᵐᵒᵖ H :=\n  ⟨fun _ _ _ _ => by\n    rwa [smul_eq_mul_unop, smul_eq_mul_unop, mul_inv_rev, mul_assoc, hH.mem_comm_iff, mul_assoc,\n      mul_inv_cancel_right]⟩\n\n"}
{"name":"AddAction.Quotient.vadd_mk","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : AddGroup α\ninst✝² : AddMonoid β\ninst✝¹ : AddAction β α\nH : AddSubgroup α\ninst✝ : AddAction.QuotientAction β H\nb : β\na : α\n⊢ Eq (HVAdd.hVAdd b ↑a) ↑(HVAdd.hVAdd b a)","decl":"@[to_additive (attr := simp)]\ntheorem Quotient.smul_mk [QuotientAction β H] (b : β) (a : α) :\n    (b • QuotientGroup.mk a : α ⧸ H) = QuotientGroup.mk (b • a) :=\n  rfl\n\n"}
{"name":"MulAction.Quotient.smul_mk","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Group α\ninst✝² : Monoid β\ninst✝¹ : MulAction β α\nH : Subgroup α\ninst✝ : MulAction.QuotientAction β H\nb : β\na : α\n⊢ Eq (HSMul.hSMul b ↑a) ↑(HSMul.hSMul b a)","decl":"@[to_additive (attr := simp)]\ntheorem Quotient.smul_mk [QuotientAction β H] (b : β) (a : α) :\n    (b • QuotientGroup.mk a : α ⧸ H) = QuotientGroup.mk (b • a) :=\n  rfl\n\n"}
{"name":"MulAction.Quotient.smul_coe","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Group α\ninst✝² : Monoid β\ninst✝¹ : MulAction β α\nH : Subgroup α\ninst✝ : MulAction.QuotientAction β H\nb : β\na : α\n⊢ Eq (HSMul.hSMul b ↑a) ↑(HSMul.hSMul b a)","decl":"@[to_additive (attr := simp)]\ntheorem Quotient.smul_coe [QuotientAction β H] (b : β) (a : α) :\n    b • (a : α ⧸ H) = (↑(b • a) : α ⧸ H) :=\n  rfl\n\n"}
{"name":"AddAction.Quotient.vadd_coe","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : AddGroup α\ninst✝² : AddMonoid β\ninst✝¹ : AddAction β α\nH : AddSubgroup α\ninst✝ : AddAction.QuotientAction β H\nb : β\na : α\n⊢ Eq (HVAdd.hVAdd b ↑a) ↑(HVAdd.hVAdd b a)","decl":"@[to_additive (attr := simp)]\ntheorem Quotient.smul_coe [QuotientAction β H] (b : β) (a : α) :\n    b • (a : α ⧸ H) = (↑(b • a) : α ⧸ H) :=\n  rfl\n\n"}
{"name":"MulAction.Quotient.mk_smul_out","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Group α\ninst✝² : Monoid β\ninst✝¹ : MulAction β α\nH : Subgroup α\ninst✝ : MulAction.QuotientAction β H\nb : β\nq : HasQuotient.Quotient α H\n⊢ Eq (↑(HSMul.hSMul b (Quotient.out q))) (HSMul.hSMul b q)","decl":"@[to_additive (attr := simp)]\ntheorem Quotient.mk_smul_out [QuotientAction β H] (b : β) (q : α ⧸ H) :\n    QuotientGroup.mk (b • q.out) = b • q := by rw [← Quotient.smul_mk, QuotientGroup.out_eq']\n\n"}
{"name":"AddAction.Quotient.mk_vadd_out","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : AddGroup α\ninst✝² : AddMonoid β\ninst✝¹ : AddAction β α\nH : AddSubgroup α\ninst✝ : AddAction.QuotientAction β H\nb : β\nq : HasQuotient.Quotient α H\n⊢ Eq (↑(HVAdd.hVAdd b (Quotient.out q))) (HVAdd.hVAdd b q)","decl":"@[to_additive (attr := simp)]\ntheorem Quotient.mk_smul_out [QuotientAction β H] (b : β) (q : α ⧸ H) :\n    QuotientGroup.mk (b • q.out) = b • q := by rw [← Quotient.smul_mk, QuotientGroup.out_eq']\n\n"}
{"name":"MulAction.Quotient.coe_smul_out","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Group α\ninst✝² : Monoid β\ninst✝¹ : MulAction β α\nH : Subgroup α\ninst✝ : MulAction.QuotientAction β H\nb : β\nq : HasQuotient.Quotient α H\n⊢ Eq (↑(HSMul.hSMul b (Quotient.out q))) (HSMul.hSMul b q)","decl":"@[to_additive]\ntheorem Quotient.coe_smul_out [QuotientAction β H] (b : β) (q : α ⧸ H) : ↑(b • q.out) = b • q := by\n  simp\n\n"}
{"name":"AddAction.Quotient.coe_vadd_out","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : AddGroup α\ninst✝² : AddMonoid β\ninst✝¹ : AddAction β α\nH : AddSubgroup α\ninst✝ : AddAction.QuotientAction β H\nb : β\nq : HasQuotient.Quotient α H\n⊢ Eq (↑(HVAdd.hVAdd b (Quotient.out q))) (HVAdd.hVAdd b q)","decl":"@[to_additive]\ntheorem Quotient.coe_smul_out [QuotientAction β H] (b : β) (q : α ⧸ H) : ↑(b • q.out) = b • q := by\n  simp\n\n"}
{"name":"QuotientGroup.out_conj_pow_minimalPeriod_mem","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\ninst✝ : Group α\nH : Subgroup α\na : α\nq : HasQuotient.Quotient α H\n⊢ Membership.mem H (HMul.hMul (HMul.hMul (Inv.inv (Quotient.out q)) (HPow.hPow a (Function.minimalPeriod (fun x => HSMul.hSMul a x) q))) (Quotient.out q))","decl":"theorem _root_.QuotientGroup.out_conj_pow_minimalPeriod_mem (a : α) (q : α ⧸ H) :\n    q.out⁻¹ * a ^ Function.minimalPeriod (a • ·) q * q.out ∈ H := by\n  rw [mul_assoc, ← QuotientGroup.eq, QuotientGroup.out_eq', ← smul_eq_mul, Quotient.mk_smul_out,\n    eq_comm, pow_smul_eq_iff_minimalPeriod_dvd]\n\n"}
{"name":"MulAction.Quotient.mk_smul_out'","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Group α\ninst✝² : Monoid β\ninst✝¹ : MulAction β α\nH : Subgroup α\ninst✝ : MulAction.QuotientAction β H\nb : β\nq : HasQuotient.Quotient α H\n⊢ Eq (↑(HSMul.hSMul b (Quotient.out q))) (HSMul.hSMul b q)","decl":"@[to_additive]\nalias Quotient.mk_smul_out' := Quotient.mk_smul_out\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"AddAction.Quotient.mk_vadd_out'","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : AddGroup α\ninst✝² : AddMonoid β\ninst✝¹ : AddAction β α\nH : AddSubgroup α\ninst✝ : AddAction.QuotientAction β H\nb : β\nq : HasQuotient.Quotient α H\n⊢ Eq (↑(HVAdd.hVAdd b (Quotient.out q))) (HVAdd.hVAdd b q)","decl":"@[to_additive]\nalias Quotient.mk_smul_out' := Quotient.mk_smul_out\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"MulAction.Quotient.coe_smul_out'","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Group α\ninst✝² : Monoid β\ninst✝¹ : MulAction β α\nH : Subgroup α\ninst✝ : MulAction.QuotientAction β H\nb : β\nq : HasQuotient.Quotient α H\n⊢ Eq (↑(HSMul.hSMul b (Quotient.out q))) (HSMul.hSMul b q)","decl":"@[to_additive]\nalias Quotient.coe_smul_out' := Quotient.coe_smul_out\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"AddAction.Quotient.coe_vadd_out'","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : AddGroup α\ninst✝² : AddMonoid β\ninst✝¹ : AddAction β α\nH : AddSubgroup α\ninst✝ : AddAction.QuotientAction β H\nb : β\nq : HasQuotient.Quotient α H\n⊢ Eq (↑(HVAdd.hVAdd b (Quotient.out q))) (HVAdd.hVAdd b q)","decl":"@[to_additive]\nalias Quotient.coe_smul_out' := Quotient.coe_smul_out\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"QuotientGroup.out'_conj_pow_minimalPeriod_mem","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\ninst✝ : Group α\nH : Subgroup α\na : α\nq : HasQuotient.Quotient α H\n⊢ Membership.mem H (HMul.hMul (HMul.hMul (Inv.inv (Quotient.out q)) (HPow.hPow a (Function.minimalPeriod (fun x => HSMul.hSMul a x) q))) (Quotient.out q))","decl":"@[deprecated (since := \"2024-10-19\")]\nalias _root_.QuotientGroup.out'_conj_pow_minimalPeriod_mem :=\n  QuotientGroup.out_conj_pow_minimalPeriod_mem\n\n"}
{"name":"MulActionHom.toQuotient_apply","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\ninst✝ : Group α\nH : Subgroup α\ng : α\n⊢ Eq ((MulActionHom.toQuotient H) g) ↑g","decl":"@[simp]\ntheorem _root_.MulActionHom.toQuotient_apply (H : Subgroup α) (g : α) :\n    MulActionHom.toQuotient H g = g :=\n  rfl\n\n"}
{"name":"AddAction.ofQuotientStabilizer_mk","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\nx : β\ng : α\n⊢ Eq (AddAction.ofQuotientStabilizer α x ↑g) (HVAdd.hVAdd g x)","decl":"@[to_additive (attr := simp)]\ntheorem ofQuotientStabilizer_mk (g : α) : ofQuotientStabilizer α x (QuotientGroup.mk g) = g • x :=\n  rfl\n\n"}
{"name":"MulAction.ofQuotientStabilizer_mk","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Group α\ninst✝ : MulAction α β\nx : β\ng : α\n⊢ Eq (MulAction.ofQuotientStabilizer α x ↑g) (HSMul.hSMul g x)","decl":"@[to_additive (attr := simp)]\ntheorem ofQuotientStabilizer_mk (g : α) : ofQuotientStabilizer α x (QuotientGroup.mk g) = g • x :=\n  rfl\n\n"}
{"name":"MulAction.ofQuotientStabilizer_mem_orbit","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Group α\ninst✝ : MulAction α β\nx : β\ng : HasQuotient.Quotient α (MulAction.stabilizer α x)\n⊢ Membership.mem (MulAction.orbit α x) (MulAction.ofQuotientStabilizer α x g)","decl":"@[to_additive]\ntheorem ofQuotientStabilizer_mem_orbit (g) : ofQuotientStabilizer α x g ∈ orbit α x :=\n  Quotient.inductionOn' g fun g => ⟨g, rfl⟩\n\n"}
{"name":"AddAction.ofQuotientStabilizer_mem_orbit","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\nx : β\ng : HasQuotient.Quotient α (AddAction.stabilizer α x)\n⊢ Membership.mem (AddAction.orbit α x) (AddAction.ofQuotientStabilizer α x g)","decl":"@[to_additive]\ntheorem ofQuotientStabilizer_mem_orbit (g) : ofQuotientStabilizer α x g ∈ orbit α x :=\n  Quotient.inductionOn' g fun g => ⟨g, rfl⟩\n\n"}
{"name":"MulAction.ofQuotientStabilizer_smul","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Group α\ninst✝ : MulAction α β\nx : β\ng : α\ng' : HasQuotient.Quotient α (MulAction.stabilizer α x)\n⊢ Eq (MulAction.ofQuotientStabilizer α x (HSMul.hSMul g g')) (HSMul.hSMul g (MulAction.ofQuotientStabilizer α x g'))","decl":"@[to_additive]\ntheorem ofQuotientStabilizer_smul (g : α) (g' : α ⧸ MulAction.stabilizer α x) :\n    ofQuotientStabilizer α x (g • g') = g • ofQuotientStabilizer α x g' :=\n  Quotient.inductionOn' g' fun _ => mul_smul _ _ _\n\n"}
{"name":"AddAction.ofQuotientStabilizer_vadd","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\nx : β\ng : α\ng' : HasQuotient.Quotient α (AddAction.stabilizer α x)\n⊢ Eq (AddAction.ofQuotientStabilizer α x (HVAdd.hVAdd g g')) (HVAdd.hVAdd g (AddAction.ofQuotientStabilizer α x g'))","decl":"@[to_additive]\ntheorem ofQuotientStabilizer_smul (g : α) (g' : α ⧸ MulAction.stabilizer α x) :\n    ofQuotientStabilizer α x (g • g') = g • ofQuotientStabilizer α x g' :=\n  Quotient.inductionOn' g' fun _ => mul_smul _ _ _\n\n"}
{"name":"AddAction.injective_ofQuotientStabilizer","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\nx : β\n⊢ Function.Injective (AddAction.ofQuotientStabilizer α x)","decl":"@[to_additive]\ntheorem injective_ofQuotientStabilizer : Function.Injective (ofQuotientStabilizer α x) :=\n  fun y₁ y₂ =>\n  Quotient.inductionOn₂' y₁ y₂ fun g₁ g₂ (H : g₁ • x = g₂ • x) =>\n    Quotient.sound' <| by\n      rw [leftRel_apply]\n      show (g₁⁻¹ * g₂) • x = x\n      rw [mul_smul, ← H, inv_smul_smul]\n\n"}
{"name":"MulAction.injective_ofQuotientStabilizer","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Group α\ninst✝ : MulAction α β\nx : β\n⊢ Function.Injective (MulAction.ofQuotientStabilizer α x)","decl":"@[to_additive]\ntheorem injective_ofQuotientStabilizer : Function.Injective (ofQuotientStabilizer α x) :=\n  fun y₁ y₂ =>\n  Quotient.inductionOn₂' y₁ y₂ fun g₁ g₂ (H : g₁ • x = g₂ • x) =>\n    Quotient.sound' <| by\n      rw [leftRel_apply]\n      show (g₁⁻¹ * g₂) • x = x\n      rw [mul_smul, ← H, inv_smul_smul]\n\n"}
{"name":"AddAction.card_orbit_mul_card_stabilizer_eq_card_addGroup","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : AddGroup α\ninst✝³ : AddAction α β\nb : β\ninst✝² : Fintype α\ninst✝¹ : Fintype ↑(AddAction.orbit α b)\ninst✝ : Fintype (Subtype fun x => Membership.mem (AddAction.stabilizer α b) x)\n⊢ Eq (HMul.hMul (Fintype.card ↑(AddAction.orbit α b)) (Fintype.card (Subtype fun x => Membership.mem (AddAction.stabilizer α b) x))) (Fintype.card α)","decl":"/-- Orbit-stabilizer theorem. -/\n@[to_additive AddAction.card_orbit_mul_card_stabilizer_eq_card_addGroup \"Orbit-stabilizer theorem.\"]\ntheorem card_orbit_mul_card_stabilizer_eq_card_group (b : β) [Fintype α] [Fintype <| orbit α b]\n    [Fintype <| stabilizer α b] :\n    Fintype.card (orbit α b) * Fintype.card (stabilizer α b) = Fintype.card α := by\n  rw [← Fintype.card_prod, Fintype.card_congr (orbitProdStabilizerEquivGroup α b)]\n\n"}
{"name":"MulAction.card_orbit_mul_card_stabilizer_eq_card_group","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : Group α\ninst✝³ : MulAction α β\nb : β\ninst✝² : Fintype α\ninst✝¹ : Fintype ↑(MulAction.orbit α b)\ninst✝ : Fintype (Subtype fun x => Membership.mem (MulAction.stabilizer α b) x)\n⊢ Eq (HMul.hMul (Fintype.card ↑(MulAction.orbit α b)) (Fintype.card (Subtype fun x => Membership.mem (MulAction.stabilizer α b) x))) (Fintype.card α)","decl":"/-- Orbit-stabilizer theorem. -/\n@[to_additive AddAction.card_orbit_mul_card_stabilizer_eq_card_addGroup \"Orbit-stabilizer theorem.\"]\ntheorem card_orbit_mul_card_stabilizer_eq_card_group (b : β) [Fintype α] [Fintype <| orbit α b]\n    [Fintype <| stabilizer α b] :\n    Fintype.card (orbit α b) * Fintype.card (stabilizer α b) = Fintype.card α := by\n  rw [← Fintype.card_prod, Fintype.card_congr (orbitProdStabilizerEquivGroup α b)]\n\n"}
{"name":"AddAction.orbitEquivQuotientStabilizer_symm_apply","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : AddGroup α\ninst✝ : AddAction α β\nb : β\na : α\n⊢ Eq (↑((AddAction.orbitEquivQuotientStabilizer α b).symm ↑a)) (HVAdd.hVAdd a b)","decl":"@[to_additive (attr := simp)]\ntheorem orbitEquivQuotientStabilizer_symm_apply (b : β) (a : α) :\n    ((orbitEquivQuotientStabilizer α b).symm a : β) = a • b :=\n  rfl\n\n"}
{"name":"MulAction.orbitEquivQuotientStabilizer_symm_apply","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Group α\ninst✝ : MulAction α β\nb : β\na : α\n⊢ Eq (↑((MulAction.orbitEquivQuotientStabilizer α b).symm ↑a)) (HSMul.hSMul a b)","decl":"@[to_additive (attr := simp)]\ntheorem orbitEquivQuotientStabilizer_symm_apply (b : β) (a : α) :\n    ((orbitEquivQuotientStabilizer α b).symm a : β) = a • b :=\n  rfl\n\n"}
{"name":"AddAction.stabilizer_quotient","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (AddAction.stabilizer G ↑0) H","decl":"@[to_additive (attr := simp)]\ntheorem stabilizer_quotient {G} [Group G] (H : Subgroup G) :\n    MulAction.stabilizer G ((1 : G) : G ⧸ H) = H := by\n  ext\n  simp [QuotientGroup.eq]\n\n"}
{"name":"MulAction.stabilizer_quotient","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (MulAction.stabilizer G ↑1) H","decl":"@[to_additive (attr := simp)]\ntheorem stabilizer_quotient {G} [Group G] (H : Subgroup G) :\n    MulAction.stabilizer G ((1 : G) : G ⧸ H) = H := by\n  ext\n  simp [QuotientGroup.eq]\n\n"}
{"name":"AddAction.card_eq_sum_card_addGroup_sub_card_stabilizer'","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝⁵ : AddGroup α\ninst✝⁴ : AddAction α β\ninst✝³ : Fintype α\ninst✝² : Fintype β\ninst✝¹ : Fintype (Quotient (AddAction.orbitRel α β))\ninst✝ : (b : β) → Fintype (Subtype fun x => Membership.mem (AddAction.stabilizer α b) x)\nφ : Quotient (AddAction.orbitRel α β) → β\nhφ : Function.LeftInverse Quotient.mk'' φ\n⊢ Eq (Fintype.card β) (Finset.univ.sum fun ω => HDiv.hDiv (Fintype.card α) (Fintype.card (Subtype fun x => Membership.mem (AddAction.stabilizer α (φ ω)) x)))","decl":"/-- **Class formula** for a finite group acting on a finite type. See\n`MulAction.card_eq_sum_card_group_div_card_stabilizer` for a specialized version using\n`Quotient.out`. -/\n@[to_additive\n      \"**Class formula** for a finite group acting on a finite type. See\n      `AddAction.card_eq_sum_card_addGroup_div_card_stabilizer` for a specialized version using\n      `Quotient.out`.\"]\ntheorem card_eq_sum_card_group_div_card_stabilizer' [Fintype α] [Fintype β] [Fintype Ω]\n    [∀ b : β, Fintype <| stabilizer α b] {φ : Ω → β} (hφ : LeftInverse Quotient.mk'' φ) :\n    Fintype.card β = ∑ ω : Ω, Fintype.card α / Fintype.card (stabilizer α (φ ω)) := by\n  classical\n    have : ∀ ω : Ω, Fintype.card α / Fintype.card (stabilizer α (φ ω)) =\n        Fintype.card (α ⧸ stabilizer α (φ ω)) := by\n      intro ω\n      rw [Fintype.card_congr (@Subgroup.groupEquivQuotientProdSubgroup α _ (stabilizer α <| φ ω)),\n        Fintype.card_prod, Nat.mul_div_cancel]\n      exact Fintype.card_pos_iff.mpr (by infer_instance)\n    simp_rw [this, ← Fintype.card_sigma,\n      Fintype.card_congr (selfEquivSigmaOrbitsQuotientStabilizer' α β hφ)]\n\n"}
{"name":"MulAction.card_eq_sum_card_group_div_card_stabilizer'","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝⁵ : Group α\ninst✝⁴ : MulAction α β\ninst✝³ : Fintype α\ninst✝² : Fintype β\ninst✝¹ : Fintype (Quotient (MulAction.orbitRel α β))\ninst✝ : (b : β) → Fintype (Subtype fun x => Membership.mem (MulAction.stabilizer α b) x)\nφ : Quotient (MulAction.orbitRel α β) → β\nhφ : Function.LeftInverse Quotient.mk'' φ\n⊢ Eq (Fintype.card β) (Finset.univ.sum fun ω => HDiv.hDiv (Fintype.card α) (Fintype.card (Subtype fun x => Membership.mem (MulAction.stabilizer α (φ ω)) x)))","decl":"/-- **Class formula** for a finite group acting on a finite type. See\n`MulAction.card_eq_sum_card_group_div_card_stabilizer` for a specialized version using\n`Quotient.out`. -/\n@[to_additive\n      \"**Class formula** for a finite group acting on a finite type. See\n      `AddAction.card_eq_sum_card_addGroup_div_card_stabilizer` for a specialized version using\n      `Quotient.out`.\"]\ntheorem card_eq_sum_card_group_div_card_stabilizer' [Fintype α] [Fintype β] [Fintype Ω]\n    [∀ b : β, Fintype <| stabilizer α b] {φ : Ω → β} (hφ : LeftInverse Quotient.mk'' φ) :\n    Fintype.card β = ∑ ω : Ω, Fintype.card α / Fintype.card (stabilizer α (φ ω)) := by\n  classical\n    have : ∀ ω : Ω, Fintype.card α / Fintype.card (stabilizer α (φ ω)) =\n        Fintype.card (α ⧸ stabilizer α (φ ω)) := by\n      intro ω\n      rw [Fintype.card_congr (@Subgroup.groupEquivQuotientProdSubgroup α _ (stabilizer α <| φ ω)),\n        Fintype.card_prod, Nat.mul_div_cancel]\n      exact Fintype.card_pos_iff.mpr (by infer_instance)\n    simp_rw [this, ← Fintype.card_sigma,\n      Fintype.card_congr (selfEquivSigmaOrbitsQuotientStabilizer' α β hφ)]\n\n"}
{"name":"AddAction.card_eq_sum_card_addGroup_sub_card_stabilizer","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝⁵ : AddGroup α\ninst✝⁴ : AddAction α β\ninst✝³ : Fintype α\ninst✝² : Fintype β\ninst✝¹ : Fintype (Quotient (AddAction.orbitRel α β))\ninst✝ : (b : β) → Fintype (Subtype fun x => Membership.mem (AddAction.stabilizer α b) x)\n⊢ Eq (Fintype.card β) (Finset.univ.sum fun ω => HDiv.hDiv (Fintype.card α) (Fintype.card (Subtype fun x => Membership.mem (AddAction.stabilizer α ω.out) x)))","decl":"/-- **Class formula** for a finite group acting on a finite type. -/\n@[to_additive \"**Class formula** for a finite group acting on a finite type.\"]\ntheorem card_eq_sum_card_group_div_card_stabilizer [Fintype α] [Fintype β] [Fintype Ω]\n    [∀ b : β, Fintype <| stabilizer α b] :\n    Fintype.card β = ∑ ω : Ω, Fintype.card α / Fintype.card (stabilizer α ω.out) :=\n  card_eq_sum_card_group_div_card_stabilizer' α β Quotient.out_eq'\n\n"}
{"name":"MulAction.card_eq_sum_card_group_div_card_stabilizer","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝⁵ : Group α\ninst✝⁴ : MulAction α β\ninst✝³ : Fintype α\ninst✝² : Fintype β\ninst✝¹ : Fintype (Quotient (MulAction.orbitRel α β))\ninst✝ : (b : β) → Fintype (Subtype fun x => Membership.mem (MulAction.stabilizer α b) x)\n⊢ Eq (Fintype.card β) (Finset.univ.sum fun ω => HDiv.hDiv (Fintype.card α) (Fintype.card (Subtype fun x => Membership.mem (MulAction.stabilizer α ω.out) x)))","decl":"/-- **Class formula** for a finite group acting on a finite type. -/\n@[to_additive \"**Class formula** for a finite group acting on a finite type.\"]\ntheorem card_eq_sum_card_group_div_card_stabilizer [Fintype α] [Fintype β] [Fintype Ω]\n    [∀ b : β, Fintype <| stabilizer α b] :\n    Fintype.card β = ∑ ω : Ω, Fintype.card α / Fintype.card (stabilizer α ω.out) :=\n  card_eq_sum_card_group_div_card_stabilizer' α β Quotient.out_eq'\n\n"}
{"name":"MulAction.sum_card_fixedBy_eq_card_orbits_mul_card_group","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : Group α\ninst✝³ : MulAction α β\ninst✝² : Fintype α\ninst✝¹ : (a : α) → Fintype ↑(MulAction.fixedBy β a)\ninst✝ : Fintype (Quotient (MulAction.orbitRel α β))\n⊢ Eq (Finset.univ.sum fun a => Fintype.card ↑(MulAction.fixedBy β a)) (HMul.hMul (Fintype.card (Quotient (MulAction.orbitRel α β))) (Fintype.card α))","decl":"/-- **Burnside's lemma** : given a finite group `G` acting on a set `X`, the average number of\nelements fixed by each `g ∈ G` is the number of orbits. -/\n@[to_additive AddAction.sum_card_fixedBy_eq_card_orbits_mul_card_addGroup\n      \"**Burnside's lemma** : given a finite additive group `G` acting on a set `X`,\n      the average number of elements fixed by each `g ∈ G` is the number of orbits. \"]\ntheorem sum_card_fixedBy_eq_card_orbits_mul_card_group [Fintype α] [∀ a : α, Fintype <| fixedBy β a]\n    [Fintype Ω] : (∑ a : α, Fintype.card (fixedBy β a)) = Fintype.card Ω * Fintype.card α := by\n  rw [← Fintype.card_prod, ← Fintype.card_sigma,\n    Fintype.card_congr (sigmaFixedByEquivOrbitsProdGroup α β)]\n\n"}
{"name":"AddAction.sum_card_fixedBy_eq_card_orbits_mul_card_addGroup","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : AddGroup α\ninst✝³ : AddAction α β\ninst✝² : Fintype α\ninst✝¹ : (a : α) → Fintype ↑(AddAction.fixedBy β a)\ninst✝ : Fintype (Quotient (AddAction.orbitRel α β))\n⊢ Eq (Finset.univ.sum fun a => Fintype.card ↑(AddAction.fixedBy β a)) (HMul.hMul (Fintype.card (Quotient (AddAction.orbitRel α β))) (Fintype.card α))","decl":"/-- **Burnside's lemma** : given a finite group `G` acting on a set `X`, the average number of\nelements fixed by each `g ∈ G` is the number of orbits. -/\n@[to_additive AddAction.sum_card_fixedBy_eq_card_orbits_mul_card_addGroup\n      \"**Burnside's lemma** : given a finite additive group `G` acting on a set `X`,\n      the average number of elements fixed by each `g ∈ G` is the number of orbits. \"]\ntheorem sum_card_fixedBy_eq_card_orbits_mul_card_group [Fintype α] [∀ a : α, Fintype <| fixedBy β a]\n    [Fintype Ω] : (∑ a : α, Fintype.card (fixedBy β a)) = Fintype.card Ω * Fintype.card α := by\n  rw [← Fintype.card_prod, ← Fintype.card_sigma,\n    Fintype.card_congr (sigmaFixedByEquivOrbitsProdGroup α β)]\n\n"}
{"name":"AddAction.isPretransitive_quotient","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ AddAction.IsPretransitive G (HasQuotient.Quotient G H)","decl":"@[to_additive]\ninstance isPretransitive_quotient (G) [Group G] (H : Subgroup G) : IsPretransitive G (G ⧸ H) where\n  exists_smul_eq := by\n    { rintro ⟨x⟩ ⟨y⟩\n      refine ⟨y * x⁻¹, QuotientGroup.eq.mpr ?_⟩\n      simp only [smul_eq_mul, H.one_mem, inv_mul_cancel, inv_mul_cancel_right]}\n\n"}
{"name":"MulAction.isPretransitive_quotient","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ MulAction.IsPretransitive G (HasQuotient.Quotient G H)","decl":"@[to_additive]\ninstance isPretransitive_quotient (G) [Group G] (H : Subgroup G) : IsPretransitive G (G ⧸ H) where\n  exists_smul_eq := by\n    { rintro ⟨x⟩ ⟨y⟩\n      refine ⟨y * x⁻¹, QuotientGroup.eq.mpr ?_⟩\n      simp only [smul_eq_mul, H.one_mem, inv_mul_cancel, inv_mul_cancel_right]}\n\n"}
{"name":"AddAction.finite_quotient_of_pretransitive_of_finite_quotient","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : AddGroup α\ninst✝² : AddAction α β\ninst✝¹ : AddAction.IsPretransitive α β\nH : AddSubgroup α\ninst✝ : Finite (HasQuotient.Quotient α H)\n⊢ Finite (AddAction.orbitRel.Quotient (Subtype fun x => Membership.mem H x) β)","decl":"@[to_additive]\ninstance finite_quotient_of_pretransitive_of_finite_quotient [IsPretransitive α β] {H : Subgroup α}\n    [Finite (α ⧸ H)] : Finite <| orbitRel.Quotient H β := by\n  rcases isEmpty_or_nonempty β with he | ⟨⟨b⟩⟩\n  · exact Quotient.finite _\n  · have h' : Finite (Quotient (rightRel H)) :=\n      Finite.of_equiv _ (quotientRightRelEquivQuotientLeftRel _).symm\n    let f : Quotient (rightRel H) → orbitRel.Quotient H β :=\n      fun a ↦ Quotient.liftOn' a (fun g ↦ ⟦g • b⟧) fun g₁ g₂ r ↦ by\n        replace r := Setoid.symm' _ r\n        change (rightRel H).r _ _ at r\n        rw [rightRel_eq] at r\n        simp only [Quotient.eq]\n        change g₁ • b ∈ orbit H (g₂ • b)\n        rw [mem_orbit_iff]\n        exact ⟨⟨g₁ * g₂⁻¹, r⟩, by simp [mul_smul]⟩\n    exact Finite.of_surjective f ((Quotient.surjective_liftOn' _).2\n      (Quotient.mk''_surjective.comp (MulAction.surjective_smul _ _)))\n\n"}
{"name":"MulAction.finite_quotient_of_pretransitive_of_finite_quotient","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Group α\ninst✝² : MulAction α β\ninst✝¹ : MulAction.IsPretransitive α β\nH : Subgroup α\ninst✝ : Finite (HasQuotient.Quotient α H)\n⊢ Finite (MulAction.orbitRel.Quotient (Subtype fun x => Membership.mem H x) β)","decl":"@[to_additive]\ninstance finite_quotient_of_pretransitive_of_finite_quotient [IsPretransitive α β] {H : Subgroup α}\n    [Finite (α ⧸ H)] : Finite <| orbitRel.Quotient H β := by\n  rcases isEmpty_or_nonempty β with he | ⟨⟨b⟩⟩\n  · exact Quotient.finite _\n  · have h' : Finite (Quotient (rightRel H)) :=\n      Finite.of_equiv _ (quotientRightRelEquivQuotientLeftRel _).symm\n    let f : Quotient (rightRel H) → orbitRel.Quotient H β :=\n      fun a ↦ Quotient.liftOn' a (fun g ↦ ⟦g • b⟧) fun g₁ g₂ r ↦ by\n        replace r := Setoid.symm' _ r\n        change (rightRel H).r _ _ at r\n        rw [rightRel_eq] at r\n        simp only [Quotient.eq]\n        change g₁ • b ∈ orbit H (g₂ • b)\n        rw [mem_orbit_iff]\n        exact ⟨⟨g₁ * g₂⁻¹, r⟩, by simp [mul_smul]⟩\n    exact Finite.of_surjective f ((Quotient.surjective_liftOn' _).2\n      (Quotient.mk''_surjective.comp (MulAction.surjective_smul _ _)))\n\n"}
{"name":"MulAction.finite_quotient_of_finite_quotient_of_finite_quotient","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : Group α\ninst✝² : MulAction α β\nH : Subgroup α\ninst✝¹ : Finite (MulAction.orbitRel.Quotient α β)\ninst✝ : Finite (HasQuotient.Quotient α H)\n⊢ Finite (MulAction.orbitRel.Quotient (Subtype fun x => Membership.mem H x) β)","decl":"@[to_additive]\ninstance finite_quotient_of_finite_quotient_of_finite_quotient {H : Subgroup α}\n    [Finite (orbitRel.Quotient α β)] [Finite (α ⧸ H)] :\n    Finite <| orbitRel.Quotient H β := by\n  rw [(equivSubgroupOrbits β H).finite_iff]\n  infer_instance\n\n"}
{"name":"AddAction.finite_quotient_of_finite_quotient_of_finite_quotient","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : AddGroup α\ninst✝² : AddAction α β\nH : AddSubgroup α\ninst✝¹ : Finite (AddAction.orbitRel.Quotient α β)\ninst✝ : Finite (HasQuotient.Quotient α H)\n⊢ Finite (AddAction.orbitRel.Quotient (Subtype fun x => Membership.mem H x) β)","decl":"@[to_additive]\ninstance finite_quotient_of_finite_quotient_of_finite_quotient {H : Subgroup α}\n    [Finite (orbitRel.Quotient α β)] [Finite (α ⧸ H)] :\n    Finite <| orbitRel.Quotient H β := by\n  rw [(equivSubgroupOrbits β H).finite_iff]\n  infer_instance\n\n"}
{"name":"ConjClasses.card_carrier","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : Fintype G\ng : G\ninst✝¹ : Fintype ↑(ConjClasses.mk g).carrier\ninst✝ : Fintype (Subtype fun x => Membership.mem (MulAction.stabilizer (ConjAct G) g) x)\n⊢ Eq (Fintype.card ↑(ConjClasses.mk g).carrier) (HDiv.hDiv (Fintype.card G) (Fintype.card (Subtype fun x => Membership.mem (MulAction.stabilizer (ConjAct G) g) x)))","decl":"theorem ConjClasses.card_carrier {G : Type*} [Group G] [Fintype G] (g : G)\n    [Fintype (ConjClasses.mk g).carrier] [Fintype <| MulAction.stabilizer (ConjAct G) g] :\n    Fintype.card (ConjClasses.mk g).carrier =\n      Fintype.card G / Fintype.card (MulAction.stabilizer (ConjAct G) g) := by\n  classical\n  rw [Fintype.card_congr <| ConjAct.toConjAct (G := G) |>.toEquiv]\n  rw [← MulAction.card_orbit_mul_card_stabilizer_eq_card_group (ConjAct G) g, Nat.mul_div_cancel]\n  · simp_rw [ConjAct.orbit_eq_carrier_conjClasses]\n  · exact Fintype.card_pos_iff.mpr inferInstance\n\n"}
{"name":"Subgroup.normalCore_eq_ker","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq H.normalCore (MulAction.toPermHom G (HasQuotient.Quotient G H)).ker","decl":"theorem normalCore_eq_ker : H.normalCore = (MulAction.toPermHom G (G ⧸ H)).ker := by\n  apply le_antisymm\n  · intro g hg\n    apply Equiv.Perm.ext\n    refine fun q ↦ QuotientGroup.induction_on q ?_\n    refine fun g' => (MulAction.Quotient.smul_mk H g g').trans (QuotientGroup.eq.mpr ?_)\n    rw [smul_eq_mul, mul_inv_rev, ← inv_inv g', inv_inv]\n    exact H.normalCore.inv_mem hg g'⁻¹\n  · refine (Subgroup.normal_le_normalCore.mpr fun g hg => ?_)\n    rw [← H.inv_mem_iff, ← mul_one g⁻¹, ← QuotientGroup.eq, ← mul_one g]\n    exact (MulAction.Quotient.smul_mk H g 1).symm.trans (Equiv.Perm.ext_iff.mp hg (1 : G))\n\n"}
{"name":"Subgroup.quotientCentralizerEmbedding_apply","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"G : Type u_1\ninst✝ : Group G\ng x : G\n⊢ Eq ((Subgroup.quotientCentralizerEmbedding g) ↑x) ⟨Bracket.bracket x g, ⋯⟩","decl":"theorem quotientCentralizerEmbedding_apply (g : G) (x : G) :\n    quotientCentralizerEmbedding g x = ⟨⁅x, g⁆, x, g, rfl⟩ :=\n  rfl\n\n"}
{"name":"Subgroup.quotientCenterEmbedding_apply","module":"Mathlib.GroupTheory.GroupAction.Quotient","initialProofState":"G : Type u_1\ninst✝ : Group G\nS : Set G\nhS : Eq (Subgroup.closure S) Top.top\ng : G\ns : ↑S\n⊢ Eq ((Subgroup.quotientCenterEmbedding hS) (↑g) s) ⟨Bracket.bracket g ↑s, ⋯⟩","decl":"theorem quotientCenterEmbedding_apply {S : Set G} (hS : closure S = ⊤) (g : G) (s : S) :\n    quotientCenterEmbedding hS g s = ⟨⁅g, s⁆, g, s, rfl⟩ :=\n  rfl\n\n"}
