{"name":"LieSubmodule.mem_normalizer","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN : LieSubmodule R L M\nm : M\n⊢ Iff (Membership.mem N.normalizer m) (∀ (x : L), Membership.mem N (Bracket.bracket x m))","decl":"@[simp]\ntheorem mem_normalizer (m : M) : m ∈ N.normalizer ↔ ∀ x : L, ⁅x, m⁆ ∈ N :=\n  Iff.rfl\n\n"}
{"name":"LieSubmodule.le_normalizer","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN : LieSubmodule R L M\n⊢ LE.le N N.normalizer","decl":"@[simp]\ntheorem le_normalizer : N ≤ N.normalizer := by\n  intro m hm\n  rw [mem_normalizer]\n  exact fun x => N.lie_mem hm\n\n"}
{"name":"LieSubmodule.normalizer_inf","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN₁ N₂ : LieSubmodule R L M\n⊢ Eq (Min.min N₁ N₂).normalizer (Min.min N₁.normalizer N₂.normalizer)","decl":"theorem normalizer_inf : (N₁ ⊓ N₂).normalizer = N₁.normalizer ⊓ N₂.normalizer := by\n  ext; simp [← forall_and]\n\n"}
{"name":"LieSubmodule.normalizer_mono","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN₁ N₂ : LieSubmodule R L M\nh : LE.le N₁ N₂\n⊢ LE.le N₁.normalizer N₂.normalizer","decl":"@[gcongr, mono]\ntheorem normalizer_mono (h : N₁ ≤ N₂) : normalizer N₁ ≤ normalizer N₂ := by\n  intro m hm\n  rw [mem_normalizer] at hm ⊢\n  exact fun x ↦ h (hm x)\n\n"}
{"name":"LieSubmodule.monotone_normalizer","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Monotone LieSubmodule.normalizer","decl":"theorem monotone_normalizer : Monotone (normalizer : LieSubmodule R L M → LieSubmodule R L M) :=\n  fun _ _ ↦ normalizer_mono\n\n"}
{"name":"LieSubmodule.comap_normalizer","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\nM' : Type u_4\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M'\ninst✝¹ : LieRingModule L M'\ninst✝ : LieModule R L M'\nN : LieSubmodule R L M\nf : LieModuleHom R L M' M\n⊢ Eq (LieSubmodule.comap f N.normalizer) (LieSubmodule.comap f N).normalizer","decl":"@[simp]\ntheorem comap_normalizer (f : M' →ₗ⁅R,L⁆ M) : N.normalizer.comap f = (N.comap f).normalizer := by\n  ext; simp\n\n"}
{"name":"LieSubmodule.top_lie_le_iff_le_normalizer","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN N' : LieSubmodule R L M\n⊢ Iff (LE.le (Bracket.bracket Top.top N) N') (LE.le N N'.normalizer)","decl":"theorem top_lie_le_iff_le_normalizer (N' : LieSubmodule R L M) :\n    ⁅(⊤ : LieIdeal R L), N⁆ ≤ N' ↔ N ≤ N'.normalizer := by rw [lie_le_iff]; tauto\n\n"}
{"name":"LieSubmodule.gc_top_lie_normalizer","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ GaloisConnection (fun N => Bracket.bracket Top.top N) LieSubmodule.normalizer","decl":"theorem gc_top_lie_normalizer :\n    GaloisConnection (fun N : LieSubmodule R L M => ⁅(⊤ : LieIdeal R L), N⁆) normalizer :=\n  top_lie_le_iff_le_normalizer\n\n"}
{"name":"LieSubmodule.normalizer_bot_eq_maxTrivSubmodule","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ Eq Bot.bot.normalizer (LieModule.maxTrivSubmodule R L M)","decl":"variable (R L M) in\ntheorem normalizer_bot_eq_maxTrivSubmodule :\n    (⊥ : LieSubmodule R L M).normalizer = LieModule.maxTrivSubmodule R L M :=\n  rfl\n\n"}
{"name":"LieSubmodule.mem_idealizer","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\nN : LieSubmodule R L M\nx : L\n⊢ Iff (Membership.mem N.idealizer x) (∀ (m : M), Membership.mem N (Bracket.bracket x m))","decl":"@[simp]\nlemma mem_idealizer {x : L} : x ∈ N.idealizer ↔ ∀ m : M, ⁅x, m⁆ ∈ N := Iff.rfl\n\n"}
{"name":"LieIdeal.idealizer_eq_normalizer","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq (LieSubmodule.idealizer I) (LieSubmodule.normalizer I)","decl":"@[simp]\nlemma _root_.LieIdeal.idealizer_eq_normalizer (I : LieIdeal R L) :\n    I.idealizer = I.normalizer := by\n  ext x; exact forall_congr' fun y ↦ by simp only [← lie_skew x y, neg_mem_iff]\n\n"}
{"name":"LieSubalgebra.mem_normalizer_iff'","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nH : LieSubalgebra R L\nx : L\n⊢ Iff (Membership.mem H.normalizer x) (∀ (y : L), Membership.mem H y → Membership.mem H (Bracket.bracket y x))","decl":"theorem mem_normalizer_iff' (x : L) : x ∈ H.normalizer ↔ ∀ y : L, y ∈ H → ⁅y, x⁆ ∈ H := by\n  rw [Subtype.forall']; rfl\n\n"}
{"name":"LieSubalgebra.mem_normalizer_iff","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nH : LieSubalgebra R L\nx : L\n⊢ Iff (Membership.mem H.normalizer x) (∀ (y : L), Membership.mem H y → Membership.mem H (Bracket.bracket x y))","decl":"theorem mem_normalizer_iff (x : L) : x ∈ H.normalizer ↔ ∀ y : L, y ∈ H → ⁅x, y⁆ ∈ H := by\n  rw [mem_normalizer_iff']\n  refine forall₂_congr fun y hy => ?_\n  rw [← lie_skew, neg_mem_iff (G := L)]\n\n"}
{"name":"LieSubalgebra.le_normalizer","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nH : LieSubalgebra R L\n⊢ LE.le H H.normalizer","decl":"theorem le_normalizer : H ≤ H.normalizer :=\n  H.toLieSubmodule.le_normalizer\n\n"}
{"name":"LieSubalgebra.coe_normalizer_eq_normalizer","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nH : LieSubalgebra R L\n⊢ Eq (↑H.toLieSubmodule.normalizer) H.normalizer.toSubmodule","decl":"theorem coe_normalizer_eq_normalizer :\n    (H.toLieSubmodule.normalizer : Submodule R L) = H.normalizer :=\n  rfl\n\n"}
{"name":"LieSubalgebra.lie_mem_sup_of_mem_normalizer","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nH : LieSubalgebra R L\nx y z : L\nhx : Membership.mem H.normalizer x\nhy : Membership.mem (Max.max (Submodule.span R (Singleton.singleton x)) H.toSubmodule) y\nhz : Membership.mem (Max.max (Submodule.span R (Singleton.singleton x)) H.toSubmodule) z\n⊢ Membership.mem (Max.max (Submodule.span R (Singleton.singleton x)) H.toSubmodule) (Bracket.bracket y z)","decl":"theorem lie_mem_sup_of_mem_normalizer {x y z : L} (hx : x ∈ H.normalizer) (hy : y ∈ (R ∙ x) ⊔ ↑H)\n    (hz : z ∈ (R ∙ x) ⊔ ↑H) : ⁅y, z⁆ ∈ (R ∙ x) ⊔ ↑H := by\n  rw [Submodule.mem_sup] at hy hz\n  obtain ⟨u₁, hu₁, v, hv : v ∈ H, rfl⟩ := hy\n  obtain ⟨u₂, hu₂, w, hw : w ∈ H, rfl⟩ := hz\n  obtain ⟨t, rfl⟩ := Submodule.mem_span_singleton.mp hu₁\n  obtain ⟨s, rfl⟩ := Submodule.mem_span_singleton.mp hu₂\n  apply Submodule.mem_sup_right\n  simp only [LieSubalgebra.mem_toSubmodule, smul_lie, add_lie, zero_add, lie_add, smul_zero,\n    lie_smul, lie_self]\n  refine H.add_mem (H.smul_mem s ?_) (H.add_mem (H.smul_mem t ?_) (H.lie_mem hv hw))\n  exacts [(H.mem_normalizer_iff' x).mp hx v hv, (H.mem_normalizer_iff x).mp hx w hw]\n\n"}
{"name":"LieSubalgebra.ideal_in_normalizer","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nH : LieSubalgebra R L\nx y : L\nhx : Membership.mem H.normalizer x\nhy : Membership.mem H y\n⊢ Membership.mem H (Bracket.bracket x y)","decl":"/-- A Lie subalgebra is an ideal of its normalizer. -/\ntheorem ideal_in_normalizer {x y : L} (hx : x ∈ H.normalizer) (hy : y ∈ H) : ⁅x, y⁆ ∈ H := by\n  rw [← lie_skew, neg_mem_iff (G := L)]\n  exact hx ⟨y, hy⟩\n\n"}
{"name":"LieSubalgebra.exists_nested_lieIdeal_ofLe_normalizer","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nH K : LieSubalgebra R L\nh₁ : LE.le H K\nh₂ : LE.le K H.normalizer\n⊢ Exists fun I => Eq (LieIdeal.toLieSubalgebra R (Subtype fun x => Membership.mem K x) I) (LieSubalgebra.ofLe h₁)","decl":"/-- A Lie subalgebra `H` is an ideal of any Lie subalgebra `K` containing `H` and contained in the\nnormalizer of `H`. -/\ntheorem exists_nested_lieIdeal_ofLe_normalizer {K : LieSubalgebra R L} (h₁ : H ≤ K)\n    (h₂ : K ≤ H.normalizer) : ∃ I : LieIdeal R K, (I : LieSubalgebra R K) = ofLe h₁ := by\n  rw [exists_nested_lieIdeal_coe_eq_iff]\n  exact fun x y hx hy => ideal_in_normalizer (h₂ hx) hy\n\n"}
{"name":"LieSubalgebra.normalizer_eq_self_iff","module":"Mathlib.Algebra.Lie.Normalizer","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nH : LieSubalgebra R L\n⊢ Iff (Eq H.normalizer H) (Eq (LieModule.maxTrivSubmodule R (Subtype fun x => Membership.mem H x) (HasQuotient.Quotient L H.toLieSubmodule)) Bot.bot)","decl":"theorem normalizer_eq_self_iff :\n    H.normalizer = H ↔ (LieModule.maxTrivSubmodule R H <| L ⧸ H.toLieSubmodule) = ⊥ := by\n  rw [LieSubmodule.eq_bot_iff]\n  refine ⟨fun h => ?_, fun h => le_antisymm ?_ H.le_normalizer⟩\n  · rintro ⟨x⟩ hx\n    suffices x ∈ H by rwa [Submodule.Quotient.quot_mk_eq_mk, Submodule.Quotient.mk_eq_zero,\n      coe_toLieSubmodule, mem_toSubmodule]\n    rw [← h, H.mem_normalizer_iff']\n    intro y hy\n    replace hx : ⁅_, LieSubmodule.Quotient.mk' _ x⁆ = 0 := hx ⟨y, hy⟩\n    rwa [← LieModuleHom.map_lie, LieSubmodule.Quotient.mk_eq_zero] at hx\n  · intro x hx\n    let y := LieSubmodule.Quotient.mk' H.toLieSubmodule x\n    have hy : y ∈ LieModule.maxTrivSubmodule R H (L ⧸ H.toLieSubmodule) := by\n      rintro ⟨z, hz⟩\n      rw [← LieModuleHom.map_lie, LieSubmodule.Quotient.mk_eq_zero, coe_bracket_of_module,\n        Submodule.coe_mk, mem_toLieSubmodule]\n      exact (H.mem_normalizer_iff' x).mp hx z hz\n    simpa [y] using h y hy\n\n"}
