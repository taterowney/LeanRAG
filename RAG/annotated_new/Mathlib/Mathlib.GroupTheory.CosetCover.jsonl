{"name":"AddSubgroup.exists_leftTransversal_of_FiniteIndex","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nD H : AddSubgroup G\ninst✝ : D.FiniteIndex\nhD_le_H : LE.le D H\n⊢ Exists fun t => And (AddSubgroup.IsComplement ↑t ↑(D.addSubgroupOf H)) (Eq (Set.iUnion fun g => Set.iUnion fun h => HVAdd.hVAdd ↑g ↑D) ↑H)","decl":"@[to_additive]\ntheorem exists_leftTransversal_of_FiniteIndex\n    {D H : Subgroup G} [D.FiniteIndex] (hD_le_H : D ≤ H) :\n    ∃ t : Finset H,\n      IsComplement (t : Set H) (D.subgroupOf H) ∧\n        ⋃ g ∈ t, (g : G) • (D : Set G) = H := by\n  have ⟨t, ht⟩ := (D.subgroupOf H).exists_isComplement_left 1\n  have hf : t.Finite := ht.1.finite_left_iff.mpr inferInstance\n  refine ⟨hf.toFinset, hf.coe_toFinset.symm ▸ ht.1, ?_⟩\n  ext x\n  suffices (∃ y ∈ t, ∃ d ∈ D, y * d = x) ↔ x ∈ H by simpa using this\n  constructor\n  · rintro ⟨⟨y, hy⟩, -, d, h, rfl⟩\n    exact H.mul_mem hy (hD_le_H h)\n  · intro hx\n    exact ⟨_, (ht.1.toLeftFun ⟨x, hx⟩).2, _,\n      ht.1.inv_toLeftFun_mul_mem ⟨x, hx⟩, mul_inv_cancel_left _ _⟩\n\n"}
{"name":"Subgroup.exists_leftTransversal_of_FiniteIndex","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nD H : Subgroup G\ninst✝ : D.FiniteIndex\nhD_le_H : LE.le D H\n⊢ Exists fun t => And (Subgroup.IsComplement ↑t ↑(D.subgroupOf H)) (Eq (Set.iUnion fun g => Set.iUnion fun h => HSMul.hSMul ↑g ↑D) ↑H)","decl":"@[to_additive]\ntheorem exists_leftTransversal_of_FiniteIndex\n    {D H : Subgroup G} [D.FiniteIndex] (hD_le_H : D ≤ H) :\n    ∃ t : Finset H,\n      IsComplement (t : Set H) (D.subgroupOf H) ∧\n        ⋃ g ∈ t, (g : G) • (D : Set G) = H := by\n  have ⟨t, ht⟩ := (D.subgroupOf H).exists_isComplement_left 1\n  have hf : t.Finite := ht.1.finite_left_iff.mpr inferInstance\n  refine ⟨hf.toFinset, hf.coe_toFinset.symm ▸ ht.1, ?_⟩\n  ext x\n  suffices (∃ y ∈ t, ∃ d ∈ D, y * d = x) ↔ x ∈ H by simpa using this\n  constructor\n  · rintro ⟨⟨y, hy⟩, -, d, h, rfl⟩\n    exact H.mul_mem hy (hD_le_H h)\n  · intro hx\n    exact ⟨_, (ht.1.toLeftFun ⟨x, hx⟩).2, _,\n      ht.1.inv_toLeftFun_mul_mem ⟨x, hx⟩, mul_inv_cancel_left _ _⟩\n\n"}
{"name":"Subgroup.leftCoset_cover_const_iff_surjOn","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Type u_2\ns : Finset ι\nH : Subgroup G\ng : ι → G\n⊢ Iff (Eq (Set.iUnion fun i => Set.iUnion fun h => HSMul.hSMul (g i) ↑H) Set.univ) (Set.SurjOn (fun x => ↑(g x)) (↑s) Set.univ)","decl":"@[to_additive]\ntheorem leftCoset_cover_const_iff_surjOn :\n    ⋃ i ∈ s, g i • (H : Set G) = Set.univ ↔ Set.SurjOn (g · : ι → G ⧸ H) s Set.univ := by\n  simp [Set.eq_univ_iff_forall, mem_leftCoset_iff, Set.SurjOn,\n    QuotientGroup.forall_mk, QuotientGroup.eq]\n\n"}
{"name":"AddSubgroup.leftCoset_cover_const_iff_surjOn","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Type u_2\ns : Finset ι\nH : AddSubgroup G\ng : ι → G\n⊢ Iff (Eq (Set.iUnion fun i => Set.iUnion fun h => HVAdd.hVAdd (g i) ↑H) Set.univ) (Set.SurjOn (fun x => ↑(g x)) (↑s) Set.univ)","decl":"@[to_additive]\ntheorem leftCoset_cover_const_iff_surjOn :\n    ⋃ i ∈ s, g i • (H : Set G) = Set.univ ↔ Set.SurjOn (g · : ι → G ⧸ H) s Set.univ := by\n  simp [Set.eq_univ_iff_forall, mem_leftCoset_iff, Set.SurjOn,\n    QuotientGroup.forall_mk, QuotientGroup.eq]\n\n"}
{"name":"Subgroup.finiteIndex_of_leftCoset_cover_const","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Type u_2\ns : Finset ι\nH : Subgroup G\ng : ι → G\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HSMul.hSMul (g i) ↑H) Set.univ\n⊢ H.FiniteIndex","decl":"/-- If `H` is a subgroup of `G` and `G` is the union of a finite family of left cosets of `H`\nthen `H` has finite index. -/\n@[to_additive]\ntheorem finiteIndex_of_leftCoset_cover_const : H.FiniteIndex := by\n  simp_rw [leftCoset_cover_const_iff_surjOn] at hcovers\n  have := Set.finite_univ_iff.mp <| Set.Finite.of_surjOn _ hcovers s.finite_toSet\n  exact H.finiteIndex_of_finite_quotient\n\n"}
{"name":"AddSubgroup.finiteIndex_of_leftCoset_cover_const","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Type u_2\ns : Finset ι\nH : AddSubgroup G\ng : ι → G\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HVAdd.hVAdd (g i) ↑H) Set.univ\n⊢ H.FiniteIndex","decl":"/-- If `H` is a subgroup of `G` and `G` is the union of a finite family of left cosets of `H`\nthen `H` has finite index. -/\n@[to_additive]\ntheorem finiteIndex_of_leftCoset_cover_const : H.FiniteIndex := by\n  simp_rw [leftCoset_cover_const_iff_surjOn] at hcovers\n  have := Set.finite_univ_iff.mp <| Set.Finite.of_surjOn _ hcovers s.finite_toSet\n  exact H.finiteIndex_of_finite_quotient\n\n"}
{"name":"AddSubgroup.index_le_of_leftCoset_cover_const","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Type u_2\ns : Finset ι\nH : AddSubgroup G\ng : ι → G\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HVAdd.hVAdd (g i) ↑H) Set.univ\n⊢ LE.le H.index s.card","decl":"@[to_additive]\ntheorem index_le_of_leftCoset_cover_const : H.index ≤ s.card := by\n  cases H.index.eq_zero_or_pos with\n  | inl h => exact h ▸ s.card.zero_le\n  | inr h =>\n    rw [leftCoset_cover_const_iff_surjOn, Set.surjOn_iff_surjective] at hcovers\n    exact (Nat.card_le_card_of_surjective _ hcovers).trans_eq (Nat.card_eq_finsetCard _)\n\n"}
{"name":"Subgroup.index_le_of_leftCoset_cover_const","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Type u_2\ns : Finset ι\nH : Subgroup G\ng : ι → G\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HSMul.hSMul (g i) ↑H) Set.univ\n⊢ LE.le H.index s.card","decl":"@[to_additive]\ntheorem index_le_of_leftCoset_cover_const : H.index ≤ s.card := by\n  cases H.index.eq_zero_or_pos with\n  | inl h => exact h ▸ s.card.zero_le\n  | inr h =>\n    rw [leftCoset_cover_const_iff_surjOn, Set.surjOn_iff_surjective] at hcovers\n    exact (Nat.card_le_card_of_surjective _ hcovers).trans_eq (Nat.card_eq_finsetCard _)\n\n"}
{"name":"AddSubgroup.pairwiseDisjoint_leftCoset_cover_const_of_index_eq","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Type u_2\ns : Finset ι\nH : AddSubgroup G\ng : ι → G\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HVAdd.hVAdd (g i) ↑H) Set.univ\nhind : Eq H.index s.card\n⊢ (↑s).PairwiseDisjoint fun x => HVAdd.hVAdd (g x) ↑H","decl":"@[to_additive]\ntheorem pairwiseDisjoint_leftCoset_cover_const_of_index_eq (hind : H.index = s.card) :\n    Set.PairwiseDisjoint s (g · • (H : Set G)) := by\n  have : Fintype (G ⧸ H) := fintypeOfIndexNeZero fun h => by\n    rw [hind, Finset.card_eq_zero] at h\n    rw [h, ← Finset.set_biUnion_coe, Finset.coe_empty, Set.biUnion_empty] at hcovers\n    exact Set.empty_ne_univ hcovers\n  suffices Function.Bijective (g · : s → G ⧸ H) by\n    intro i hi j hj h' c hi' hj' x hx\n    specialize hi' hx\n    specialize hj' hx\n    rw [mem_leftCoset_iff, SetLike.mem_coe, ← QuotientGroup.eq] at hi' hj'\n    rw [ne_eq, ← Subtype.mk.injEq (p := (· ∈ (s : Set ι))) i hi j hj] at h'\n    exact h' <| this.injective <| by simp only [hi', hj']\n  rw [Fintype.bijective_iff_surjective_and_card]\n  constructor\n  · rwa [leftCoset_cover_const_iff_surjOn, Set.surjOn_iff_surjective] at hcovers\n  · simp only [Fintype.card_coe, ← hind, index_eq_card, Nat.card_eq_fintype_card]\n\n"}
{"name":"Subgroup.pairwiseDisjoint_leftCoset_cover_const_of_index_eq","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Type u_2\ns : Finset ι\nH : Subgroup G\ng : ι → G\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HSMul.hSMul (g i) ↑H) Set.univ\nhind : Eq H.index s.card\n⊢ (↑s).PairwiseDisjoint fun x => HSMul.hSMul (g x) ↑H","decl":"@[to_additive]\ntheorem pairwiseDisjoint_leftCoset_cover_const_of_index_eq (hind : H.index = s.card) :\n    Set.PairwiseDisjoint s (g · • (H : Set G)) := by\n  have : Fintype (G ⧸ H) := fintypeOfIndexNeZero fun h => by\n    rw [hind, Finset.card_eq_zero] at h\n    rw [h, ← Finset.set_biUnion_coe, Finset.coe_empty, Set.biUnion_empty] at hcovers\n    exact Set.empty_ne_univ hcovers\n  suffices Function.Bijective (g · : s → G ⧸ H) by\n    intro i hi j hj h' c hi' hj' x hx\n    specialize hi' hx\n    specialize hj' hx\n    rw [mem_leftCoset_iff, SetLike.mem_coe, ← QuotientGroup.eq] at hi' hj'\n    rw [ne_eq, ← Subtype.mk.injEq (p := (· ∈ (s : Set ι))) i hi j hj] at h'\n    exact h' <| this.injective <| by simp only [hi', hj']\n  rw [Fintype.bijective_iff_surjective_and_card]\n  constructor\n  · rwa [leftCoset_cover_const_iff_surjOn, Set.surjOn_iff_surjective] at hcovers\n  · simp only [Fintype.card_coe, ← hind, index_eq_card, Nat.card_eq_fintype_card]\n\n"}
{"name":"Subgroup.exists_finiteIndex_of_leftCoset_cover_aux","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nι : Type u_2\nH : ι → Subgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HSMul.hSMul (g i) ↑(H i)) Set.univ\ninst✝ : DecidableEq (Subgroup G)\nj : ι\nhj : Membership.mem s j\nhcovers' : Ne (Set.iUnion fun i => Set.iUnion fun h => HSMul.hSMul (g i) ↑(H i)) Set.univ\n⊢ Exists fun i => And (Membership.mem s i) (And (Ne (H i) (H j)) (H i).FiniteIndex)","decl":"@[to_additive]\ntheorem exists_finiteIndex_of_leftCoset_cover_aux [DecidableEq (Subgroup G)]\n    (j : ι) (hj : j ∈ s) (hcovers' : ⋃ i ∈ s.filter (H · = H j), g i • (H i : Set G) ≠ Set.univ) :\n    ∃ i ∈ s, H i ≠ H j ∧ (H i).FiniteIndex := by\n  classical\n  have ⟨n, hn⟩ : ∃ n, n = (s.image H).card := exists_eq\n  induction n using Nat.strongRec generalizing ι with\n  | ind n ih =>\n    -- Every left coset of `H j` is contained in a finite union of\n    -- left cosets of the other subgroups `H k ≠ H j` of the covering.\n    have ⟨x, hx⟩ : ∃ (x : G), ∀ i ∈ s, H i = H j → (g i : G ⧸ H i) ≠ ↑x := by\n      simpa [Set.eq_univ_iff_forall, mem_leftCoset_iff, ← QuotientGroup.eq] using hcovers'\n    replace hx : ∀ (y : G), y • (H j : Set G) ⊆\n        ⋃ i ∈ s.filter (H · ≠ H j), (y * x⁻¹ * g i) • (H i : Set G) := by\n      intro y z hz\n      simp_rw [Finset.mem_filter, Set.mem_iUnion]\n      have ⟨i, hi, hmem⟩ : ∃ i ∈ s, x * (y⁻¹ * z) ∈ g i • (H i : Set G) := by\n        simpa using Set.eq_univ_iff_forall.mp hcovers (x * (y⁻¹ * z))\n      rw [mem_leftCoset_iff, SetLike.mem_coe, ← QuotientGroup.eq] at hmem\n      refine ⟨i, ⟨hi, fun hij => hx i hi hij ?_⟩, ?_⟩\n      · rwa [hmem, eq_comm, QuotientGroup.eq, hij, inv_mul_cancel_left,\n          ← SetLike.mem_coe, ← mem_leftCoset_iff]\n      · simpa [mem_leftCoset_iff, SetLike.mem_coe, QuotientGroup.eq, mul_assoc] using hmem\n    -- Thus `G` can also be covered by a finite union `U k, f k • K k` of left cosets\n    -- of the subgroups `H k ≠ H j`.\n    let κ := ↥(s.filter (H · ≠ H j)) × Option ↥(s.filter (H · = H j))\n    let f : κ → G\n    | ⟨k₁, some k₂⟩ => g k₂ * x⁻¹ * g k₁\n    | ⟨k₁, none⟩ => g k₁\n    let K (k : κ) : Subgroup G := H k.1.val\n    have hK' (k : κ) : K k ∈ (s.image H).erase (H j) := by\n      have := Finset.mem_filter.mp k.1.property\n      exact Finset.mem_erase.mpr ⟨this.2, Finset.mem_image_of_mem H this.1⟩\n    have hK (k : κ) : K k ≠ H j := ((Finset.mem_erase.mp (hK' k)).left ·)\n    replace hcovers : ⋃ k ∈ Finset.univ, f k • (K k : Set G) = Set.univ :=\n        Set.iUnion₂_eq_univ_iff.mpr fun y => by\n      rw [← s.filter_union_filter_neg_eq (H · = H j), Finset.set_biUnion_union] at hcovers\n      cases (Set.mem_union _ _ _).mp (hcovers.superset (Set.mem_univ y)) with\n      | inl hy =>\n        have ⟨k, hk, hy⟩ := Set.mem_iUnion₂.mp hy\n        have hk' : H k = H j := And.right <| by simpa using hk\n        have ⟨i, hi, hy⟩ := Set.mem_iUnion₂.mp (hx (g k) (hk' ▸ hy))\n        exact ⟨⟨⟨i, hi⟩, some ⟨k, hk⟩⟩, Finset.mem_univ _, hy⟩\n      | inr hy =>\n        have ⟨i, hi, hy⟩ := Set.mem_iUnion₂.mp hy\n        exact ⟨⟨⟨i, hi⟩, none⟩, Finset.mem_univ _, hy⟩\n    -- Let `H k` be one of the subgroups in this covering.\n    have ⟨k⟩ : Nonempty κ := not_isEmpty_iff.mp fun hempty => by\n      rw [Set.iUnion_of_empty] at hcovers\n      exact Set.empty_ne_univ hcovers\n    -- If `G` is the union of the cosets of `H k` in the new covering, we are done.\n    by_cases hcovers' : ⋃ i ∈ Finset.filter (K · = K k) Finset.univ, f i • (K i : Set G) = Set.univ\n    · rw [Set.iUnion₂_congr fun i hi => by rw [(Finset.mem_filter.mp hi).right]] at hcovers'\n      exact ⟨k.1, Finset.mem_of_mem_filter k.1.1 k.1.2, hK k,\n        finiteIndex_of_leftCoset_cover_const hcovers'⟩\n    -- Otherwise, by the induction hypothesis, one of the subgroups `H k ≠ H j` has finite index.\n    have hn' : (Finset.univ.image K).card < n := hn ▸ by\n      refine ((Finset.card_le_card fun x => ?_).trans_lt <|\n        Finset.card_erase_lt_of_mem (Finset.mem_image_of_mem H hj))\n      rw [mem_image_univ_iff_mem_range, Set.mem_range]\n      exact fun ⟨k, hk⟩ => hk ▸ hK' k\n    have ⟨k', hk'⟩ := ih _ hn' hcovers k (Finset.mem_univ k) hcovers' rfl\n    exact ⟨k'.1.1, Finset.mem_of_mem_filter k'.1.1 k'.1.2, hK k', hk'.2.2⟩\n\n"}
{"name":"AddSubgroup.exists_finiteIndex_of_leftCoset_cover_aux","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nι : Type u_2\nH : ι → AddSubgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HVAdd.hVAdd (g i) ↑(H i)) Set.univ\ninst✝ : DecidableEq (AddSubgroup G)\nj : ι\nhj : Membership.mem s j\nhcovers' : Ne (Set.iUnion fun i => Set.iUnion fun h => HVAdd.hVAdd (g i) ↑(H i)) Set.univ\n⊢ Exists fun i => And (Membership.mem s i) (And (Ne (H i) (H j)) (H i).FiniteIndex)","decl":"@[to_additive]\ntheorem exists_finiteIndex_of_leftCoset_cover_aux [DecidableEq (Subgroup G)]\n    (j : ι) (hj : j ∈ s) (hcovers' : ⋃ i ∈ s.filter (H · = H j), g i • (H i : Set G) ≠ Set.univ) :\n    ∃ i ∈ s, H i ≠ H j ∧ (H i).FiniteIndex := by\n  classical\n  have ⟨n, hn⟩ : ∃ n, n = (s.image H).card := exists_eq\n  induction n using Nat.strongRec generalizing ι with\n  | ind n ih =>\n    -- Every left coset of `H j` is contained in a finite union of\n    -- left cosets of the other subgroups `H k ≠ H j` of the covering.\n    have ⟨x, hx⟩ : ∃ (x : G), ∀ i ∈ s, H i = H j → (g i : G ⧸ H i) ≠ ↑x := by\n      simpa [Set.eq_univ_iff_forall, mem_leftCoset_iff, ← QuotientGroup.eq] using hcovers'\n    replace hx : ∀ (y : G), y • (H j : Set G) ⊆\n        ⋃ i ∈ s.filter (H · ≠ H j), (y * x⁻¹ * g i) • (H i : Set G) := by\n      intro y z hz\n      simp_rw [Finset.mem_filter, Set.mem_iUnion]\n      have ⟨i, hi, hmem⟩ : ∃ i ∈ s, x * (y⁻¹ * z) ∈ g i • (H i : Set G) := by\n        simpa using Set.eq_univ_iff_forall.mp hcovers (x * (y⁻¹ * z))\n      rw [mem_leftCoset_iff, SetLike.mem_coe, ← QuotientGroup.eq] at hmem\n      refine ⟨i, ⟨hi, fun hij => hx i hi hij ?_⟩, ?_⟩\n      · rwa [hmem, eq_comm, QuotientGroup.eq, hij, inv_mul_cancel_left,\n          ← SetLike.mem_coe, ← mem_leftCoset_iff]\n      · simpa [mem_leftCoset_iff, SetLike.mem_coe, QuotientGroup.eq, mul_assoc] using hmem\n    -- Thus `G` can also be covered by a finite union `U k, f k • K k` of left cosets\n    -- of the subgroups `H k ≠ H j`.\n    let κ := ↥(s.filter (H · ≠ H j)) × Option ↥(s.filter (H · = H j))\n    let f : κ → G\n    | ⟨k₁, some k₂⟩ => g k₂ * x⁻¹ * g k₁\n    | ⟨k₁, none⟩ => g k₁\n    let K (k : κ) : Subgroup G := H k.1.val\n    have hK' (k : κ) : K k ∈ (s.image H).erase (H j) := by\n      have := Finset.mem_filter.mp k.1.property\n      exact Finset.mem_erase.mpr ⟨this.2, Finset.mem_image_of_mem H this.1⟩\n    have hK (k : κ) : K k ≠ H j := ((Finset.mem_erase.mp (hK' k)).left ·)\n    replace hcovers : ⋃ k ∈ Finset.univ, f k • (K k : Set G) = Set.univ :=\n        Set.iUnion₂_eq_univ_iff.mpr fun y => by\n      rw [← s.filter_union_filter_neg_eq (H · = H j), Finset.set_biUnion_union] at hcovers\n      cases (Set.mem_union _ _ _).mp (hcovers.superset (Set.mem_univ y)) with\n      | inl hy =>\n        have ⟨k, hk, hy⟩ := Set.mem_iUnion₂.mp hy\n        have hk' : H k = H j := And.right <| by simpa using hk\n        have ⟨i, hi, hy⟩ := Set.mem_iUnion₂.mp (hx (g k) (hk' ▸ hy))\n        exact ⟨⟨⟨i, hi⟩, some ⟨k, hk⟩⟩, Finset.mem_univ _, hy⟩\n      | inr hy =>\n        have ⟨i, hi, hy⟩ := Set.mem_iUnion₂.mp hy\n        exact ⟨⟨⟨i, hi⟩, none⟩, Finset.mem_univ _, hy⟩\n    -- Let `H k` be one of the subgroups in this covering.\n    have ⟨k⟩ : Nonempty κ := not_isEmpty_iff.mp fun hempty => by\n      rw [Set.iUnion_of_empty] at hcovers\n      exact Set.empty_ne_univ hcovers\n    -- If `G` is the union of the cosets of `H k` in the new covering, we are done.\n    by_cases hcovers' : ⋃ i ∈ Finset.filter (K · = K k) Finset.univ, f i • (K i : Set G) = Set.univ\n    · rw [Set.iUnion₂_congr fun i hi => by rw [(Finset.mem_filter.mp hi).right]] at hcovers'\n      exact ⟨k.1, Finset.mem_of_mem_filter k.1.1 k.1.2, hK k,\n        finiteIndex_of_leftCoset_cover_const hcovers'⟩\n    -- Otherwise, by the induction hypothesis, one of the subgroups `H k ≠ H j` has finite index.\n    have hn' : (Finset.univ.image K).card < n := hn ▸ by\n      refine ((Finset.card_le_card fun x => ?_).trans_lt <|\n        Finset.card_erase_lt_of_mem (Finset.mem_image_of_mem H hj))\n      rw [mem_image_univ_iff_mem_range, Set.mem_range]\n      exact fun ⟨k, hk⟩ => hk ▸ hK' k\n    have ⟨k', hk'⟩ := ih _ hn' hcovers k (Finset.mem_univ k) hcovers' rfl\n    exact ⟨k'.1.1, Finset.mem_of_mem_filter k'.1.1 k'.1.2, hK k', hk'.2.2⟩\n\n"}
{"name":"AddSubgroup.exists_finiteIndex_of_leftCoset_cover","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Type u_2\nH : ι → AddSubgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HVAdd.hVAdd (g i) ↑(H i)) Set.univ\n⊢ Exists fun k => And (Membership.mem s k) (H k).FiniteIndex","decl":"/-- Let the group `G` be the union of finitely many left cosets `g i • H i`.\nThen at least one subgroup `H i` has finite index in `G`. -/\n@[to_additive]\ntheorem exists_finiteIndex_of_leftCoset_cover : ∃ k ∈ s, (H k).FiniteIndex := by\n  classical\n  have ⟨j, hj⟩ : s.Nonempty := Finset.nonempty_iff_ne_empty.mpr fun hempty => by\n    rw [hempty, ← Finset.set_biUnion_coe, Finset.coe_empty, Set.biUnion_empty] at hcovers\n    exact Set.empty_ne_univ hcovers\n  by_cases hcovers' : ⋃ i ∈ s.filter (H · = H j), g i • (H i : Set G) = Set.univ\n  · rw [Set.iUnion₂_congr fun i hi => by rw [(Finset.mem_filter.mp hi).right]] at hcovers'\n    exact ⟨j, hj, finiteIndex_of_leftCoset_cover_const hcovers'⟩\n  · have ⟨i, hi, _, hfi⟩ :=\n      exists_finiteIndex_of_leftCoset_cover_aux hcovers j hj hcovers'\n    exact ⟨i, hi, hfi⟩\n\n-- Auxiliary to `leftCoset_cover_filter_FiniteIndex` and `one_le_sum_inv_index_of_leftCoset_cover`.\n"}
{"name":"Subgroup.exists_finiteIndex_of_leftCoset_cover","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Type u_2\nH : ι → Subgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HSMul.hSMul (g i) ↑(H i)) Set.univ\n⊢ Exists fun k => And (Membership.mem s k) (H k).FiniteIndex","decl":"/-- Let the group `G` be the union of finitely many left cosets `g i • H i`.\nThen at least one subgroup `H i` has finite index in `G`. -/\n@[to_additive]\ntheorem exists_finiteIndex_of_leftCoset_cover : ∃ k ∈ s, (H k).FiniteIndex := by\n  classical\n  have ⟨j, hj⟩ : s.Nonempty := Finset.nonempty_iff_ne_empty.mpr fun hempty => by\n    rw [hempty, ← Finset.set_biUnion_coe, Finset.coe_empty, Set.biUnion_empty] at hcovers\n    exact Set.empty_ne_univ hcovers\n  by_cases hcovers' : ⋃ i ∈ s.filter (H · = H j), g i • (H i : Set G) = Set.univ\n  · rw [Set.iUnion₂_congr fun i hi => by rw [(Finset.mem_filter.mp hi).right]] at hcovers'\n    exact ⟨j, hj, finiteIndex_of_leftCoset_cover_const hcovers'⟩\n  · have ⟨i, hi, _, hfi⟩ :=\n      exists_finiteIndex_of_leftCoset_cover_aux hcovers j hj hcovers'\n    exact ⟨i, hi, hfi⟩\n\n-- Auxiliary to `leftCoset_cover_filter_FiniteIndex` and `one_le_sum_inv_index_of_leftCoset_cover`.\n"}
{"name":"AddSubgroup.leftCoset_cover_filter_FiniteIndex_aux","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nι : Type u_2\nH : ι → AddSubgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HVAdd.hVAdd (g i) ↑(H i)) Set.univ\ninst✝ : DecidablePred AddSubgroup.FiniteIndex\n⊢ And (Eq (Set.iUnion fun k => Set.iUnion fun h => HVAdd.hVAdd (g k) ↑(H k)) Set.univ) (And (LE.le 1 (s.sum fun i => Inv.inv ↑(H i).index)) (Eq (s.sum fun i => Inv.inv ↑(H i).index) 1 → (↑(Finset.filter (fun i => (H i).FiniteIndex) s)).PairwiseDisjoint fun i => HVAdd.hVAdd (g i) ↑(H i)))","decl":"@[to_additive]\ntheorem leftCoset_cover_filter_FiniteIndex_aux\n    [DecidablePred (FiniteIndex : Subgroup G → Prop)] :\n    (⋃ k ∈ s.filter (fun i => (H i).FiniteIndex), g k • (H k : Set G) = Set.univ) ∧\n      (1 ≤ ∑ i ∈ s, ((H i).index : ℚ)⁻¹) ∧\n      (∑ i ∈ s, ((H i).index : ℚ)⁻¹ = 1 → Set.PairwiseDisjoint\n        (s.filter (fun i => (H i).FiniteIndex)) (fun i ↦ g i • (H i : Set G))) := by\n  classical\n  let D := ⨅ k ∈ s.filter (fun i => (H i).FiniteIndex), H k\n  -- `D`, as the finite intersection of subgroups of finite index, also has finite index.\n  have hD : D.FiniteIndex := finiteIndex_iInf' _ <| by simp\n  have hD_le {i} (hi : i ∈ s) (hfi : (H i).FiniteIndex) : D ≤ H i :=\n    iInf₂_le i (Finset.mem_filter.mpr ⟨hi, hfi⟩)\n  -- Each subgroup of finite index in the covering is the union of finitely many cosets of `D`.\n  choose t ht using fun i hi hfi =>\n    exists_leftTransversal_of_FiniteIndex (H := H i) (hD_le hi hfi)\n  -- We construct a cover of `G` by the cosets of subgroups of infinite index and of `D`.\n  let κ := (i : s) × { x // x ∈ if h : (H i.1).FiniteIndex then t i.1 i.2 h else {1} }\n  let f (k : κ) : G := g k.1 * k.2.val\n  let K (k : κ) : Subgroup G := if (H k.1).FiniteIndex then D else H k.1\n  have hcovers' : ⋃ k ∈ Finset.univ, f k • (K k : Set G) = Set.univ := by\n    rw [← s.filter_union_filter_neg_eq (fun i => (H i).FiniteIndex)] at hcovers\n    rw [← hcovers, ← Finset.univ.filter_union_filter_neg_eq (fun k => (H k.1).FiniteIndex),\n      Finset.set_biUnion_union, Finset.set_biUnion_union]\n    apply congrArg₂ (· ∪ ·) <;> rw [Set.iUnion_sigma, Set.iUnion_subtype] <;>\n        refine Set.iUnion_congr fun i => ?_\n    · by_cases hfi : (H i).FiniteIndex <;>\n        simp [← Set.smul_set_iUnion₂, Set.iUnion_subtype, ← leftCoset_assoc, f, K, ht, hfi]\n    · by_cases hfi : (H i).FiniteIndex <;>\n        simp [Set.iUnion_subtype, f, K, hfi]\n  -- There is at least one coset of a subgroup of finite index in the original covering.\n  -- Therefore a coset of `D` occurs in the new covering.\n  have ⟨k, hkfi, hk⟩ : ∃ k, (H k.1.1).FiniteIndex ∧ K k = D :=\n    have ⟨j, hj, hjfi⟩ := exists_finiteIndex_of_leftCoset_cover hcovers\n    have ⟨x, hx⟩ : (t j hj hjfi).Nonempty := Finset.nonempty_coe_sort.mp\n      (ht j hj hjfi).1.leftQuotientEquiv.symm.nonempty\n    ⟨⟨⟨j, hj⟩, ⟨x, dif_pos hjfi ▸ hx⟩⟩, hjfi, if_pos hjfi⟩\n  -- Since `D` is the unique subgroup of finite index whose cosets occur in the new covering,\n  -- the cosets of the other subgroups can be omitted.\n  replace hcovers' : ⋃ i ∈ Finset.univ.filter (K · = D), f i • (D : Set G) = Set.univ := by\n    rw [← hk, Set.iUnion₂_congr fun i hi => by rw [← (Finset.mem_filter.mp hi).2]]\n    by_contra! h\n    obtain ⟨i, -, hi⟩ :=\n      exists_finiteIndex_of_leftCoset_cover_aux hcovers' k (Finset.mem_univ k) h\n    by_cases hfi : (H i.1.1).FiniteIndex <;> simp [K, hfi, hkfi] at hi\n  -- The result follows by restoring the original cosets of subgroups of finite index\n  -- from the cosets of `D` into which they have been decomposed.\n  have hHD (i) : ¬(H i).FiniteIndex → H i ≠ D := fun hfi hD' => (hD' ▸ hfi) hD\n  have hdensity : ∑ i ∈ s, ((H i).index : ℚ)⁻¹ =\n      (Finset.univ.filter (K · = D)).card * (D.index : ℚ)⁻¹ := by\n    rw [eq_mul_inv_iff_mul_eq₀ (Nat.cast_ne_zero.mpr hD.finiteIndex), Finset.sum_mul,\n      ← Finset.sum_attach, eq_comm, Finset.card_filter, Nat.cast_sum, ← Finset.univ_sigma_univ,\n      Finset.sum_sigma, Finset.sum_coe_sort_eq_attach]\n    refine Finset.sum_congr rfl fun i _ => ?_\n    by_cases hfi : (H i).FiniteIndex\n    · rw [← relindex_mul_index (hD_le i.2 hfi), Nat.cast_mul, mul_comm,\n        mul_inv_cancel_right₀ (Nat.cast_ne_zero.mpr hfi.finiteIndex)]\n      simpa [K, hfi] using (ht i.1 i.2 hfi).1.card_left\n    · rw [of_not_not (FiniteIndex.mk.mt hfi), Nat.cast_zero, inv_zero, zero_mul]\n      simpa [K, hfi] using hHD i hfi\n  refine ⟨?_, ?_, ?_⟩\n  · rw [← hcovers', Set.iUnion_sigma, Set.iUnion_subtype]\n    refine Set.iUnion_congr fun i => ?_\n    rw [Finset.mem_filter, Set.iUnion_and]\n    refine Set.iUnion_congr fun hi => ?_\n    by_cases hfi : (H i).FiniteIndex <;>\n      simp [Set.smul_set_iUnion, Set.iUnion_subtype, ← leftCoset_assoc,\n        f, K, hHD, ← (ht i hi _).2, hi, hfi, hkfi]\n  · rw [hdensity]\n    refine le_of_mul_le_mul_right ?_ (Nat.cast_pos.mpr (Nat.pos_of_ne_zero hD.finiteIndex))\n    rw [one_mul, mul_assoc, inv_mul_cancel₀ (Nat.cast_ne_zero.mpr hD.finiteIndex), mul_one,\n      Nat.cast_le]\n    exact index_le_of_leftCoset_cover_const hcovers'\n  · rw [hdensity, mul_inv_eq_one₀ (Nat.cast_ne_zero.mpr hD.finiteIndex),\n      Nat.cast_inj, Finset.coe_filter]\n    intro h i hi j hj hij c hi' hj' x hx\n    have hdisjoint := pairwiseDisjoint_leftCoset_cover_const_of_index_eq hcovers' h.symm\n    -- We know the `f k • K k` are pairwise disjoint and need to prove that the `g i • H i` are.\n    rw [Set.mem_setOf_eq] at hi hj\n    have hk' (i) (hi : i ∈ s ∧ (H i).FiniteIndex) (hi' : c ≤ g i • (H i : Set G)) :\n        ∃ (k : κ), k.1.1 = i ∧ K k = D ∧ x ∈ f k • (D : Set G) := by\n      rw [← (ht i hi.1 hi.2).2] at hi'\n      suffices ∃ r : H i, r ∈ t i hi.1 hi.2 ∧ x ∈ (g i * r) • (D : Set G) by\n        have ⟨r, hr, hxr⟩ := this\n        refine ⟨⟨⟨i, hi.1⟩, ⟨r, dif_pos hi.2 ▸ hr⟩⟩, rfl, ?_⟩\n        simpa [K, f, if_pos hi.2] using hxr\n      simpa [Set.mem_smul_set_iff_inv_smul_mem, smul_eq_mul, mul_assoc] using hi' hx\n    have ⟨k₁, hik₁, hk₁, hxk₁⟩ := hk' i hi hi'\n    have ⟨k₂, hjk₂, hk₂, hxk₂⟩ := hk' j hj hj'\n    rw [← Set.singleton_subset_iff, ← Set.le_iff_subset] at hxk₁ hxk₂ ⊢\n    exact hdisjoint\n      (Finset.mem_filter.mpr ⟨Finset.mem_univ k₁, hk₁⟩)\n      (Finset.mem_filter.mpr ⟨Finset.mem_univ k₂, hk₂⟩)\n      (ne_of_apply_ne Sigma.fst (ne_of_apply_ne Subtype.val (hik₁ ▸ hjk₂ ▸ hij)))\n      hxk₁ hxk₂\n\n"}
{"name":"Subgroup.leftCoset_cover_filter_FiniteIndex_aux","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nι : Type u_2\nH : ι → Subgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HSMul.hSMul (g i) ↑(H i)) Set.univ\ninst✝ : DecidablePred Subgroup.FiniteIndex\n⊢ And (Eq (Set.iUnion fun k => Set.iUnion fun h => HSMul.hSMul (g k) ↑(H k)) Set.univ) (And (LE.le 1 (s.sum fun i => Inv.inv ↑(H i).index)) (Eq (s.sum fun i => Inv.inv ↑(H i).index) 1 → (↑(Finset.filter (fun i => (H i).FiniteIndex) s)).PairwiseDisjoint fun i => HSMul.hSMul (g i) ↑(H i)))","decl":"@[to_additive]\ntheorem leftCoset_cover_filter_FiniteIndex_aux\n    [DecidablePred (FiniteIndex : Subgroup G → Prop)] :\n    (⋃ k ∈ s.filter (fun i => (H i).FiniteIndex), g k • (H k : Set G) = Set.univ) ∧\n      (1 ≤ ∑ i ∈ s, ((H i).index : ℚ)⁻¹) ∧\n      (∑ i ∈ s, ((H i).index : ℚ)⁻¹ = 1 → Set.PairwiseDisjoint\n        (s.filter (fun i => (H i).FiniteIndex)) (fun i ↦ g i • (H i : Set G))) := by\n  classical\n  let D := ⨅ k ∈ s.filter (fun i => (H i).FiniteIndex), H k\n  -- `D`, as the finite intersection of subgroups of finite index, also has finite index.\n  have hD : D.FiniteIndex := finiteIndex_iInf' _ <| by simp\n  have hD_le {i} (hi : i ∈ s) (hfi : (H i).FiniteIndex) : D ≤ H i :=\n    iInf₂_le i (Finset.mem_filter.mpr ⟨hi, hfi⟩)\n  -- Each subgroup of finite index in the covering is the union of finitely many cosets of `D`.\n  choose t ht using fun i hi hfi =>\n    exists_leftTransversal_of_FiniteIndex (H := H i) (hD_le hi hfi)\n  -- We construct a cover of `G` by the cosets of subgroups of infinite index and of `D`.\n  let κ := (i : s) × { x // x ∈ if h : (H i.1).FiniteIndex then t i.1 i.2 h else {1} }\n  let f (k : κ) : G := g k.1 * k.2.val\n  let K (k : κ) : Subgroup G := if (H k.1).FiniteIndex then D else H k.1\n  have hcovers' : ⋃ k ∈ Finset.univ, f k • (K k : Set G) = Set.univ := by\n    rw [← s.filter_union_filter_neg_eq (fun i => (H i).FiniteIndex)] at hcovers\n    rw [← hcovers, ← Finset.univ.filter_union_filter_neg_eq (fun k => (H k.1).FiniteIndex),\n      Finset.set_biUnion_union, Finset.set_biUnion_union]\n    apply congrArg₂ (· ∪ ·) <;> rw [Set.iUnion_sigma, Set.iUnion_subtype] <;>\n        refine Set.iUnion_congr fun i => ?_\n    · by_cases hfi : (H i).FiniteIndex <;>\n        simp [← Set.smul_set_iUnion₂, Set.iUnion_subtype, ← leftCoset_assoc, f, K, ht, hfi]\n    · by_cases hfi : (H i).FiniteIndex <;>\n        simp [Set.iUnion_subtype, f, K, hfi]\n  -- There is at least one coset of a subgroup of finite index in the original covering.\n  -- Therefore a coset of `D` occurs in the new covering.\n  have ⟨k, hkfi, hk⟩ : ∃ k, (H k.1.1).FiniteIndex ∧ K k = D :=\n    have ⟨j, hj, hjfi⟩ := exists_finiteIndex_of_leftCoset_cover hcovers\n    have ⟨x, hx⟩ : (t j hj hjfi).Nonempty := Finset.nonempty_coe_sort.mp\n      (ht j hj hjfi).1.leftQuotientEquiv.symm.nonempty\n    ⟨⟨⟨j, hj⟩, ⟨x, dif_pos hjfi ▸ hx⟩⟩, hjfi, if_pos hjfi⟩\n  -- Since `D` is the unique subgroup of finite index whose cosets occur in the new covering,\n  -- the cosets of the other subgroups can be omitted.\n  replace hcovers' : ⋃ i ∈ Finset.univ.filter (K · = D), f i • (D : Set G) = Set.univ := by\n    rw [← hk, Set.iUnion₂_congr fun i hi => by rw [← (Finset.mem_filter.mp hi).2]]\n    by_contra! h\n    obtain ⟨i, -, hi⟩ :=\n      exists_finiteIndex_of_leftCoset_cover_aux hcovers' k (Finset.mem_univ k) h\n    by_cases hfi : (H i.1.1).FiniteIndex <;> simp [K, hfi, hkfi] at hi\n  -- The result follows by restoring the original cosets of subgroups of finite index\n  -- from the cosets of `D` into which they have been decomposed.\n  have hHD (i) : ¬(H i).FiniteIndex → H i ≠ D := fun hfi hD' => (hD' ▸ hfi) hD\n  have hdensity : ∑ i ∈ s, ((H i).index : ℚ)⁻¹ =\n      (Finset.univ.filter (K · = D)).card * (D.index : ℚ)⁻¹ := by\n    rw [eq_mul_inv_iff_mul_eq₀ (Nat.cast_ne_zero.mpr hD.finiteIndex), Finset.sum_mul,\n      ← Finset.sum_attach, eq_comm, Finset.card_filter, Nat.cast_sum, ← Finset.univ_sigma_univ,\n      Finset.sum_sigma, Finset.sum_coe_sort_eq_attach]\n    refine Finset.sum_congr rfl fun i _ => ?_\n    by_cases hfi : (H i).FiniteIndex\n    · rw [← relindex_mul_index (hD_le i.2 hfi), Nat.cast_mul, mul_comm,\n        mul_inv_cancel_right₀ (Nat.cast_ne_zero.mpr hfi.finiteIndex)]\n      simpa [K, hfi] using (ht i.1 i.2 hfi).1.card_left\n    · rw [of_not_not (FiniteIndex.mk.mt hfi), Nat.cast_zero, inv_zero, zero_mul]\n      simpa [K, hfi] using hHD i hfi\n  refine ⟨?_, ?_, ?_⟩\n  · rw [← hcovers', Set.iUnion_sigma, Set.iUnion_subtype]\n    refine Set.iUnion_congr fun i => ?_\n    rw [Finset.mem_filter, Set.iUnion_and]\n    refine Set.iUnion_congr fun hi => ?_\n    by_cases hfi : (H i).FiniteIndex <;>\n      simp [Set.smul_set_iUnion, Set.iUnion_subtype, ← leftCoset_assoc,\n        f, K, hHD, ← (ht i hi _).2, hi, hfi, hkfi]\n  · rw [hdensity]\n    refine le_of_mul_le_mul_right ?_ (Nat.cast_pos.mpr (Nat.pos_of_ne_zero hD.finiteIndex))\n    rw [one_mul, mul_assoc, inv_mul_cancel₀ (Nat.cast_ne_zero.mpr hD.finiteIndex), mul_one,\n      Nat.cast_le]\n    exact index_le_of_leftCoset_cover_const hcovers'\n  · rw [hdensity, mul_inv_eq_one₀ (Nat.cast_ne_zero.mpr hD.finiteIndex),\n      Nat.cast_inj, Finset.coe_filter]\n    intro h i hi j hj hij c hi' hj' x hx\n    have hdisjoint := pairwiseDisjoint_leftCoset_cover_const_of_index_eq hcovers' h.symm\n    -- We know the `f k • K k` are pairwise disjoint and need to prove that the `g i • H i` are.\n    rw [Set.mem_setOf_eq] at hi hj\n    have hk' (i) (hi : i ∈ s ∧ (H i).FiniteIndex) (hi' : c ≤ g i • (H i : Set G)) :\n        ∃ (k : κ), k.1.1 = i ∧ K k = D ∧ x ∈ f k • (D : Set G) := by\n      rw [← (ht i hi.1 hi.2).2] at hi'\n      suffices ∃ r : H i, r ∈ t i hi.1 hi.2 ∧ x ∈ (g i * r) • (D : Set G) by\n        have ⟨r, hr, hxr⟩ := this\n        refine ⟨⟨⟨i, hi.1⟩, ⟨r, dif_pos hi.2 ▸ hr⟩⟩, rfl, ?_⟩\n        simpa [K, f, if_pos hi.2] using hxr\n      simpa [Set.mem_smul_set_iff_inv_smul_mem, smul_eq_mul, mul_assoc] using hi' hx\n    have ⟨k₁, hik₁, hk₁, hxk₁⟩ := hk' i hi hi'\n    have ⟨k₂, hjk₂, hk₂, hxk₂⟩ := hk' j hj hj'\n    rw [← Set.singleton_subset_iff, ← Set.le_iff_subset] at hxk₁ hxk₂ ⊢\n    exact hdisjoint\n      (Finset.mem_filter.mpr ⟨Finset.mem_univ k₁, hk₁⟩)\n      (Finset.mem_filter.mpr ⟨Finset.mem_univ k₂, hk₂⟩)\n      (ne_of_apply_ne Sigma.fst (ne_of_apply_ne Subtype.val (hik₁ ▸ hjk₂ ▸ hij)))\n      hxk₁ hxk₂\n\n"}
{"name":"Subgroup.leftCoset_cover_filter_FiniteIndex","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nι : Type u_2\nH : ι → Subgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HSMul.hSMul (g i) ↑(H i)) Set.univ\ninst✝ : DecidablePred Subgroup.FiniteIndex\n⊢ Eq (Set.iUnion fun k => Set.iUnion fun h => HSMul.hSMul (g k) ↑(H k)) Set.univ","decl":"/-- Let the group `G` be the union of finitely many left cosets `g i • H i`.\nThen the cosets of subgroups of infinite index may be omitted from the covering. -/\n@[to_additive]\ntheorem leftCoset_cover_filter_FiniteIndex\n    [DecidablePred (FiniteIndex : Subgroup G → Prop)] :\n    ⋃ k ∈ s.filter (fun i => (H i).FiniteIndex), g k • (H k : Set G) = Set.univ :=\n  (leftCoset_cover_filter_FiniteIndex_aux hcovers).1\n\n"}
{"name":"AddSubgroup.leftCoset_cover_filter_FiniteIndex","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nι : Type u_2\nH : ι → AddSubgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HVAdd.hVAdd (g i) ↑(H i)) Set.univ\ninst✝ : DecidablePred AddSubgroup.FiniteIndex\n⊢ Eq (Set.iUnion fun k => Set.iUnion fun h => HVAdd.hVAdd (g k) ↑(H k)) Set.univ","decl":"/-- Let the group `G` be the union of finitely many left cosets `g i • H i`.\nThen the cosets of subgroups of infinite index may be omitted from the covering. -/\n@[to_additive]\ntheorem leftCoset_cover_filter_FiniteIndex\n    [DecidablePred (FiniteIndex : Subgroup G → Prop)] :\n    ⋃ k ∈ s.filter (fun i => (H i).FiniteIndex), g k • (H k : Set G) = Set.univ :=\n  (leftCoset_cover_filter_FiniteIndex_aux hcovers).1\n\n"}
{"name":"Subgroup.one_le_sum_inv_index_of_leftCoset_cover","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Type u_2\nH : ι → Subgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HSMul.hSMul (g i) ↑(H i)) Set.univ\n⊢ LE.le 1 (s.sum fun i => Inv.inv ↑(H i).index)","decl":"/-- Let the group `G` be the union of finitely many left cosets `g i • H i`. Then the\nsum of the inverses of the indexes of the subgroups `H i` is greater than or equal to 1. -/\n@[to_additive one_le_sum_inv_index_of_leftCoset_cover]\ntheorem one_le_sum_inv_index_of_leftCoset_cover :\n    1 ≤ ∑ i ∈ s, ((H i).index : ℚ)⁻¹ :=\n  have := Classical.decPred (FiniteIndex : Subgroup G → Prop)\n  (leftCoset_cover_filter_FiniteIndex_aux hcovers).2.1\n\n"}
{"name":"AddSubgroup.one_le_sum_inv_index_of_leftCoset_cover","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Type u_2\nH : ι → AddSubgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HVAdd.hVAdd (g i) ↑(H i)) Set.univ\n⊢ LE.le 1 (s.sum fun i => Inv.inv ↑(H i).index)","decl":"/-- Let the group `G` be the union of finitely many left cosets `g i • H i`. Then the\nsum of the inverses of the indexes of the subgroups `H i` is greater than or equal to 1. -/\n@[to_additive one_le_sum_inv_index_of_leftCoset_cover]\ntheorem one_le_sum_inv_index_of_leftCoset_cover :\n    1 ≤ ∑ i ∈ s, ((H i).index : ℚ)⁻¹ :=\n  have := Classical.decPred (FiniteIndex : Subgroup G → Prop)\n  (leftCoset_cover_filter_FiniteIndex_aux hcovers).2.1\n\n"}
{"name":"AddSubgroup.pairwiseDisjoint_leftCoset_cover_of_sum_neg_index_eq_zero","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nι : Type u_2\nH : ι → AddSubgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HVAdd.hVAdd (g i) ↑(H i)) Set.univ\ninst✝ : DecidablePred AddSubgroup.FiniteIndex\na✝ : Eq (s.sum fun i => Inv.inv ↑(H i).index) 1\n⊢ (↑(Finset.filter (fun i => (H i).FiniteIndex) s)).PairwiseDisjoint fun i => HVAdd.hVAdd (g i) ↑(H i)","decl":"/-- Let the group `G` be the union of finitely many left cosets `g i • H i`.\nIf the sum of the inverses of the indexes of the subgroups `H i` is equal to 1,\nthen the cosets of the subgroups of finite index are pairwise disjoint. -/\n@[to_additive]\ntheorem pairwiseDisjoint_leftCoset_cover_of_sum_inv_index_eq_one\n    [DecidablePred (FiniteIndex : Subgroup G → Prop)] :\n    ∑ i ∈ s, ((H i).index : ℚ)⁻¹ = 1 →\n      Set.PairwiseDisjoint (s.filter (fun i => (H i).FiniteIndex))\n        (fun i ↦ g i • (H i : Set G)) :=\n  (leftCoset_cover_filter_FiniteIndex_aux hcovers).2.2\n\n"}
{"name":"Subgroup.pairwiseDisjoint_leftCoset_cover_of_sum_inv_index_eq_one","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nι : Type u_2\nH : ι → Subgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HSMul.hSMul (g i) ↑(H i)) Set.univ\ninst✝ : DecidablePred Subgroup.FiniteIndex\na✝ : Eq (s.sum fun i => Inv.inv ↑(H i).index) 1\n⊢ (↑(Finset.filter (fun i => (H i).FiniteIndex) s)).PairwiseDisjoint fun i => HSMul.hSMul (g i) ↑(H i)","decl":"/-- Let the group `G` be the union of finitely many left cosets `g i • H i`.\nIf the sum of the inverses of the indexes of the subgroups `H i` is equal to 1,\nthen the cosets of the subgroups of finite index are pairwise disjoint. -/\n@[to_additive]\ntheorem pairwiseDisjoint_leftCoset_cover_of_sum_inv_index_eq_one\n    [DecidablePred (FiniteIndex : Subgroup G → Prop)] :\n    ∑ i ∈ s, ((H i).index : ℚ)⁻¹ = 1 →\n      Set.PairwiseDisjoint (s.filter (fun i => (H i).FiniteIndex))\n        (fun i ↦ g i • (H i : Set G)) :=\n  (leftCoset_cover_filter_FiniteIndex_aux hcovers).2.2\n\n"}
{"name":"Subgroup.exists_index_le_card_of_leftCoset_cover","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Type u_2\nH : ι → Subgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HSMul.hSMul (g i) ↑(H i)) Set.univ\n⊢ Exists fun i => And (Membership.mem s i) (And (H i).FiniteIndex (LE.le (H i).index s.card))","decl":"/-- B. H. Neumann Lemma :\nIf a finite family of cosets of subgroups covers the group, then at least one\nof these subgroups has index not exceeding the number of cosets. -/\n@[to_additive]\ntheorem exists_index_le_card_of_leftCoset_cover :\n    ∃ i ∈ s, (H i).FiniteIndex ∧ (H i).index ≤ s.card := by\n  by_contra! h\n  apply (one_le_sum_inv_index_of_leftCoset_cover hcovers).not_lt\n  cases s.eq_empty_or_nonempty with\n  | inl hs => simp only [hs, Finset.sum_empty, zero_lt_one]\n  | inr hs =>\n  have hs' : 0 < s.card := hs.card_pos\n  have hlt : ∀ i ∈ s, ((H i).index : ℚ)⁻¹ < (s.card : ℚ)⁻¹ := fun i hi ↦ by\n    cases eq_or_ne (H i).index 0 with\n    | inl hindex =>\n      rwa [hindex, Nat.cast_zero, inv_zero, inv_pos, Nat.cast_pos]\n    | inr hindex =>\n      exact inv_strictAnti₀ (by exact_mod_cast hs') (by exact_mod_cast h i hi ⟨hindex⟩)\n  apply (Finset.sum_lt_sum_of_nonempty hs hlt).trans_eq\n  rw [Finset.sum_const, nsmul_eq_mul, mul_inv_cancel₀ (Nat.cast_ne_zero.mpr hs'.ne')]\n\n"}
{"name":"AddSubgroup.exists_index_le_card_of_leftCoset_cover","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Type u_2\nH : ι → AddSubgroup G\ng : ι → G\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => HVAdd.hVAdd (g i) ↑(H i)) Set.univ\n⊢ Exists fun i => And (Membership.mem s i) (And (H i).FiniteIndex (LE.le (H i).index s.card))","decl":"/-- B. H. Neumann Lemma :\nIf a finite family of cosets of subgroups covers the group, then at least one\nof these subgroups has index not exceeding the number of cosets. -/\n@[to_additive]\ntheorem exists_index_le_card_of_leftCoset_cover :\n    ∃ i ∈ s, (H i).FiniteIndex ∧ (H i).index ≤ s.card := by\n  by_contra! h\n  apply (one_le_sum_inv_index_of_leftCoset_cover hcovers).not_lt\n  cases s.eq_empty_or_nonempty with\n  | inl hs => simp only [hs, Finset.sum_empty, zero_lt_one]\n  | inr hs =>\n  have hs' : 0 < s.card := hs.card_pos\n  have hlt : ∀ i ∈ s, ((H i).index : ℚ)⁻¹ < (s.card : ℚ)⁻¹ := fun i hi ↦ by\n    cases eq_or_ne (H i).index 0 with\n    | inl hindex =>\n      rwa [hindex, Nat.cast_zero, inv_zero, inv_pos, Nat.cast_pos]\n    | inr hindex =>\n      exact inv_strictAnti₀ (by exact_mod_cast hs') (by exact_mod_cast h i hi ⟨hindex⟩)\n  apply (Finset.sum_lt_sum_of_nonempty hs hlt).trans_eq\n  rw [Finset.sum_const, nsmul_eq_mul, mul_inv_cancel₀ (Nat.cast_ne_zero.mpr hs'.ne')]\n\n"}
{"name":"Submodule.exists_finiteIndex_of_cover","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\np : ι → Submodule R M\ns : Finset ι\nhcovers : Eq (Set.iUnion fun i => Set.iUnion fun h => ↑(p i)) Set.univ\n⊢ Exists fun k => And (Membership.mem s k) (p k).toAddSubgroup.FiniteIndex","decl":"theorem Submodule.exists_finiteIndex_of_cover (hcovers : ⋃ i ∈ s, (p i : Set M) = Set.univ) :\n    ∃ k ∈ s, (p k).toAddSubgroup.FiniteIndex :=\n  have hcovers' : ⋃ i ∈ s, (0 : M) +ᵥ ((p i).toAddSubgroup : Set M) = Set.univ := by\n    simpa only [zero_vadd] using hcovers\n  AddSubgroup.exists_finiteIndex_of_leftCoset_cover hcovers'\n\n"}
{"name":"Subspace.biUnion_ne_univ_of_top_nmem","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : DivisionRing k\ninst✝² : Infinite k\ninst✝¹ : AddCommGroup E\ninst✝ : Module k E\ns : Finset (Subspace k E)\nhs : Not (Membership.mem s Top.top)\n⊢ Ne (Set.iUnion fun p => Set.iUnion fun h => ↑p) Set.univ","decl":"theorem Subspace.biUnion_ne_univ_of_top_nmem (hs : ⊤ ∉ s) :\n    ⋃ p ∈ s, (p : Set E) ≠ Set.univ := by\n  intro hcovers\n  have ⟨p, hp, hfi⟩ := Submodule.exists_finiteIndex_of_cover hcovers\n  have : Finite (E ⧸ p) := AddSubgroup.finite_quotient_of_finiteIndex _\n  have : Nontrivial (E ⧸ p) :=\n    Submodule.Quotient.nontrivial_of_lt_top p (ne_of_mem_of_not_mem hp hs).lt_top\n  have : Infinite (E ⧸ p) := Module.Free.infinite k (E ⧸ p)\n  exact not_finite (E ⧸ p)\n\n/- A vector space over an infinite field cannot be a finite union of proper subspaces. -/\n"}
{"name":"Subspace.top_mem_of_biUnion_eq_univ","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : DivisionRing k\ninst✝² : Infinite k\ninst✝¹ : AddCommGroup E\ninst✝ : Module k E\ns : Finset (Subspace k E)\nhcovers : Eq (Set.iUnion fun p => Set.iUnion fun h => ↑p) Set.univ\n⊢ Membership.mem s Top.top","decl":"theorem Subspace.top_mem_of_biUnion_eq_univ (hcovers : ⋃ p ∈ s, (p : Set E) = Set.univ) :\n    ⊤ ∈ s := by\n  contrapose! hcovers\n  exact Subspace.biUnion_ne_univ_of_top_nmem hcovers\n\n"}
{"name":"Subspace.biUnion_ne_univ_of_ne_top","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : DivisionRing k\ninst✝² : Infinite k\ninst✝¹ : AddCommGroup E\ninst✝ : Module k E\ns : Finset (Subspace k E)\nhs : Not (Membership.mem s Top.top)\n⊢ Ne (Set.iUnion fun p => Set.iUnion fun h => ↑p) Set.univ","decl":"@[deprecated (since := \"2024-10-29\")]\nalias Subspace.biUnion_ne_univ_of_ne_top := Subspace.biUnion_ne_univ_of_top_nmem\n"}
{"name":"Subspace.exists_eq_top_of_biUnion_eq_univ","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝³ : DivisionRing k\ninst✝² : Infinite k\ninst✝¹ : AddCommGroup E\ninst✝ : Module k E\ns : Finset (Subspace k E)\nhcovers : Eq (Set.iUnion fun p => Set.iUnion fun h => ↑p) Set.univ\n⊢ Membership.mem s Top.top","decl":"@[deprecated (since := \"2024-10-29\")]\nalias Subspace.exists_eq_top_of_biUnion_eq_univ := Subspace.top_mem_of_biUnion_eq_univ\n\n"}
{"name":"Subspace.exists_eq_top_of_iUnion_eq_univ","module":"Mathlib.GroupTheory.CosetCover","initialProofState":"k : Type u_1\nE : Type u_2\ninst✝⁴ : DivisionRing k\ninst✝³ : Infinite k\ninst✝² : AddCommGroup E\ninst✝¹ : Module k E\nι : Sort u_3\ninst✝ : Finite ι\np : ι → Subspace k E\nhcovers : Eq (Set.iUnion fun i => ↑(p i)) Set.univ\n⊢ Exists fun i => Eq (p i) Top.top","decl":"theorem Subspace.exists_eq_top_of_iUnion_eq_univ {ι} [Finite ι] {p : ι → Subspace k E}\n    (hcovers : ⋃ i, (p i : Set E) = Set.univ) : ∃ i, p i = ⊤ := by\n  have := Fintype.ofFinite (Set.range p)\n  simp_rw [← Set.biUnion_range (f := p), ← Set.mem_toFinset] at hcovers\n  apply Set.mem_toFinset.mp (Subspace.top_mem_of_biUnion_eq_univ hcovers)\n\n"}
