{"name":"AddHom.mulLeft_apply","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝ : Distrib R\nr : R\n⊢ Eq ⇑(AddHom.mulLeft r) fun x => HMul.hMul r x","decl":"/-- Left multiplication by an element of a type with distributive multiplication is an `AddHom`. -/\n@[simps (config := .asFn)]\ndef mulLeft [Distrib R] (r : R) : AddHom R R where\n  toFun := (r * ·)\n  map_add' := mul_add r\n\n"}
{"name":"AddHom.mulRight_apply","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝ : Distrib R\nr : R\n⊢ Eq ⇑(AddHom.mulRight r) fun a => HMul.hMul a r","decl":"/-- Left multiplication by an element of a type with distributive multiplication is an `AddHom`. -/\n@[simps (config := .asFn)]\ndef mulRight [Distrib R] (r : R) : AddHom R R where\n  toFun a := a * r\n  map_add' _ _ := add_mul _ _ r\n\n"}
{"name":"AddMonoidHom.coe_mulLeft","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocSemiring R\nr : R\n⊢ Eq (⇑(AddMonoidHom.mulLeft r)) (HMul.hMul r)","decl":"@[simp]\ntheorem coe_mulLeft [NonUnitalNonAssocSemiring R] (r : R) :\n    (mulLeft r : R → R) = HMul.hMul r :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_mulRight","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocSemiring R\nr : R\n⊢ Eq ⇑(AddMonoidHom.mulRight r) fun x => HMul.hMul x r","decl":"@[simp]\ntheorem coe_mulRight [NonUnitalNonAssocSemiring R] (r : R) :\n    (mulRight r) = (· * r) :=\n  rfl\n\n"}
{"name":"AddMonoidHom.mulRight_apply","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocSemiring R\na r : R\n⊢ Eq ((AddMonoidHom.mulRight r) a) (HMul.hMul a r)","decl":"theorem mulRight_apply [NonUnitalNonAssocSemiring R] (a r : R) :\n    mulRight r a = a * r :=\n  rfl\n\n"}
{"name":"inv_neg'","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Group α\ninst✝ : HasDistribNeg α\na : α\n⊢ Eq (Inv.inv (Neg.neg a)) (Neg.neg (Inv.inv a))","decl":"@[simp]\ntheorem inv_neg' (a : α) : (-a)⁻¹ = -a⁻¹ := by\n  rw [eq_comm, eq_inv_iff_mul_eq_one, neg_mul, mul_neg, neg_neg, inv_mul_cancel]\n\n"}
{"name":"vieta_formula_quadratic","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝ : NonUnitalCommRing α\nb c x : α\nh : Eq (HAdd.hAdd (HSub.hSub (HMul.hMul x x) (HMul.hMul b x)) c) 0\n⊢ Exists fun y => And (Eq (HAdd.hAdd (HSub.hSub (HMul.hMul y y) (HMul.hMul b y)) c) 0) (And (Eq (HAdd.hAdd x y) b) (Eq (HMul.hMul x y) c))","decl":"/-- Vieta's formula for a quadratic equation, relating the coefficients of the polynomial with\n  its roots. This particular version states that if we have a root `x` of a monic quadratic\n  polynomial, then there is another root `y` such that `x + y` is negative the `a_1` coefficient\n  and `x * y` is the `a_0` coefficient. -/\ntheorem vieta_formula_quadratic {b c x : α} (h : x * x - b * x + c = 0) :\n    ∃ y : α, y * y - b * y + c = 0 ∧ x + y = b ∧ x * y = c := by\n  have : c = x * (b - x) := (eq_neg_of_add_eq_zero_right h).trans (by simp [mul_sub, mul_comm])\n  refine ⟨b - x, ?_, by simp, by rw [this]⟩\n  rw [this, sub_add, ← sub_mul, sub_self]\n\n"}
{"name":"succ_ne_self","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝¹ : NonAssocRing α\ninst✝ : Nontrivial α\na : α\n⊢ Ne (HAdd.hAdd a 1) a","decl":"theorem succ_ne_self {α : Type*} [NonAssocRing α] [Nontrivial α] (a : α) : a + 1 ≠ a := fun h =>\n  one_ne_zero ((add_right_inj a).mp (by simp [h]))\n\n"}
{"name":"pred_ne_self","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝¹ : NonAssocRing α\ninst✝ : Nontrivial α\na : α\n⊢ Ne (HSub.hSub a 1) a","decl":"theorem pred_ne_self {α : Type*} [NonAssocRing α] [Nontrivial α] (a : α) : a - 1 ≠ a := fun h ↦\n  one_ne_zero (neg_injective ((add_right_inj a).mp (by simp [← sub_eq_add_neg, h])))\n\n"}
{"name":"IsLeftCancelMulZero.to_noZeroDivisors","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : IsLeftCancelMulZero α\n⊢ NoZeroDivisors α","decl":"lemma IsLeftCancelMulZero.to_noZeroDivisors [NonUnitalNonAssocSemiring α]\n    [IsLeftCancelMulZero α] : NoZeroDivisors α where\n  eq_zero_or_eq_zero_of_mul_eq_zero {x _} h :=\n    or_iff_not_imp_left.mpr fun ne ↦ mul_left_cancel₀ ne ((mul_zero x).symm ▸ h)\n\n"}
{"name":"IsRightCancelMulZero.to_noZeroDivisors","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : IsRightCancelMulZero α\n⊢ NoZeroDivisors α","decl":"lemma IsRightCancelMulZero.to_noZeroDivisors [NonUnitalNonAssocSemiring α]\n    [IsRightCancelMulZero α] : NoZeroDivisors α where\n  eq_zero_or_eq_zero_of_mul_eq_zero {_ y} h :=\n    or_iff_not_imp_right.mpr fun ne ↦ mul_right_cancel₀ ne ((zero_mul y).symm ▸ h)\n\n"}
{"name":"NoZeroDivisors.to_isCancelMulZero","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : NoZeroDivisors α\n⊢ IsCancelMulZero α","decl":"instance (priority := 100) NoZeroDivisors.to_isCancelMulZero\n    [NonUnitalNonAssocRing α] [NoZeroDivisors α] :\n    IsCancelMulZero α where\n  mul_left_cancel_of_ne_zero ha h := by\n    rw [← sub_eq_zero, ← mul_sub] at h\n    exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_left ha)\n  mul_right_cancel_of_ne_zero hb h := by\n    rw [← sub_eq_zero, ← sub_mul] at h\n    exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_right hb)\n\n"}
{"name":"isCancelMulZero_iff_noZeroDivisors","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝ : NonUnitalNonAssocRing α\n⊢ Iff (IsCancelMulZero α) (NoZeroDivisors α)","decl":"/-- In a ring, `IsCancelMulZero` and `NoZeroDivisors` are equivalent. -/\nlemma isCancelMulZero_iff_noZeroDivisors [NonUnitalNonAssocRing α] :\n    IsCancelMulZero α ↔ NoZeroDivisors α :=\n  ⟨fun _ => IsRightCancelMulZero.to_noZeroDivisors _, fun _ => inferInstance⟩\n\n"}
{"name":"NoZeroDivisors.to_isDomain","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Ring α\nh : Nontrivial α\ninst✝ : NoZeroDivisors α\n⊢ IsDomain α","decl":"lemma NoZeroDivisors.to_isDomain [Ring α] [h : Nontrivial α] [NoZeroDivisors α] :\n    IsDomain α :=\n  { NoZeroDivisors.to_isCancelMulZero α, h with .. }\n\n"}
{"name":"IsDomain.to_noZeroDivisors","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Semiring α\ninst✝ : IsDomain α\n⊢ NoZeroDivisors α","decl":"instance (priority := 100) IsDomain.to_noZeroDivisors [Semiring α] [IsDomain α] :\n    NoZeroDivisors α :=\n  IsRightCancelMulZero.to_noZeroDivisors α\n\n"}
{"name":"Subsingleton.to_isCancelMulZero","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : Zero α\ninst✝ : Subsingleton α\n⊢ IsCancelMulZero α","decl":"instance Subsingleton.to_isCancelMulZero [Mul α] [Zero α] [Subsingleton α] : IsCancelMulZero α where\n  mul_right_cancel_of_ne_zero hb := (hb <| Subsingleton.eq_zero _).elim\n  mul_left_cancel_of_ne_zero hb := (hb <| Subsingleton.eq_zero _).elim\n\n"}
{"name":"Subsingleton.to_noZeroDivisors","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : Zero α\ninst✝ : Subsingleton α\n⊢ NoZeroDivisors α","decl":"instance Subsingleton.to_noZeroDivisors [Mul α] [Zero α] [Subsingleton α] : NoZeroDivisors α where\n  eq_zero_or_eq_zero_of_mul_eq_zero _ := .inl (Subsingleton.eq_zero _)\n\n"}
{"name":"isDomain_iff_cancelMulZero_and_nontrivial","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝ : Semiring α\n⊢ Iff (IsDomain α) (And (IsCancelMulZero α) (Nontrivial α))","decl":"lemma isDomain_iff_cancelMulZero_and_nontrivial [Semiring α] :\n    IsDomain α ↔ IsCancelMulZero α ∧ Nontrivial α :=\n  ⟨fun _ => ⟨inferInstance, inferInstance⟩, fun ⟨_, _⟩ => {}⟩\n\n"}
{"name":"isCancelMulZero_iff_isDomain_or_subsingleton","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝ : Semiring α\n⊢ Iff (IsCancelMulZero α) (Or (IsDomain α) (Subsingleton α))","decl":"lemma isCancelMulZero_iff_isDomain_or_subsingleton [Semiring α] :\n    IsCancelMulZero α ↔ IsDomain α ∨ Subsingleton α := by\n  refine ⟨fun t ↦ ?_, fun h ↦ h.elim (fun _ ↦ inferInstance) (fun _ ↦ inferInstance)⟩\n  rw [or_iff_not_imp_right, not_subsingleton_iff_nontrivial]\n  exact fun _ ↦ {}\n\n"}
{"name":"isDomain_iff_noZeroDivisors_and_nontrivial","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝ : Ring α\n⊢ Iff (IsDomain α) (And (NoZeroDivisors α) (Nontrivial α))","decl":"lemma isDomain_iff_noZeroDivisors_and_nontrivial [Ring α] :\n    IsDomain α ↔ NoZeroDivisors α ∧ Nontrivial α := by\n  rw [← isCancelMulZero_iff_noZeroDivisors, isDomain_iff_cancelMulZero_and_nontrivial]\n\n"}
{"name":"noZeroDivisors_iff_isDomain_or_subsingleton","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"α : Type u_2\ninst✝ : Ring α\n⊢ Iff (NoZeroDivisors α) (Or (IsDomain α) (Subsingleton α))","decl":"lemma noZeroDivisors_iff_isDomain_or_subsingleton [Ring α] :\n    NoZeroDivisors α ↔ IsDomain α ∨ Subsingleton α := by\n  rw [← isCancelMulZero_iff_noZeroDivisors, isCancelMulZero_iff_isDomain_or_subsingleton]\n\n"}
{"name":"one_div_neg_one_eq_neg_one","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝¹ : DivisionMonoid R\ninst✝ : HasDistribNeg R\n⊢ Eq (HDiv.hDiv 1 (-1)) (-1)","decl":"lemma one_div_neg_one_eq_neg_one : (1 : R) / -1 = -1 :=\n  have : -1 * -1 = (1 : R) := by rw [neg_mul_neg, one_mul]\n  Eq.symm (eq_one_div_of_mul_eq_one_right this)\n\n"}
{"name":"one_div_neg_eq_neg_one_div","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝¹ : DivisionMonoid R\ninst✝ : HasDistribNeg R\na : R\n⊢ Eq (HDiv.hDiv 1 (Neg.neg a)) (Neg.neg (HDiv.hDiv 1 a))","decl":"lemma one_div_neg_eq_neg_one_div (a : R) : 1 / -a = -(1 / a) :=\n  calc\n    1 / -a = 1 / (-1 * a) := by rw [neg_eq_neg_one_mul]\n    _ = 1 / a * (1 / -1) := by rw [one_div_mul_one_div_rev]\n    _ = 1 / a * -1 := by rw [one_div_neg_one_eq_neg_one]\n    _ = -(1 / a) := by rw [mul_neg, mul_one]\n\n"}
{"name":"div_neg_eq_neg_div","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝¹ : DivisionMonoid R\ninst✝ : HasDistribNeg R\na b : R\n⊢ Eq (HDiv.hDiv b (Neg.neg a)) (Neg.neg (HDiv.hDiv b a))","decl":"lemma div_neg_eq_neg_div (a b : R) : b / -a = -(b / a) :=\n  calc\n    b / -a = b * (1 / -a) := by rw [← inv_eq_one_div, division_def]\n    _ = b * -(1 / a) := by rw [one_div_neg_eq_neg_one_div]\n    _ = -(b * (1 / a)) := by rw [neg_mul_eq_mul_neg]\n    _ = -(b / a) := by rw [mul_one_div]\n\n"}
{"name":"neg_div","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝¹ : DivisionMonoid R\ninst✝ : HasDistribNeg R\na b : R\n⊢ Eq (HDiv.hDiv (Neg.neg b) a) (Neg.neg (HDiv.hDiv b a))","decl":"lemma neg_div (a b : R) : -b / a = -(b / a) := by\n  rw [neg_eq_neg_one_mul, mul_div_assoc, ← neg_eq_neg_one_mul]\n\n"}
{"name":"neg_div'","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝¹ : DivisionMonoid R\ninst✝ : HasDistribNeg R\na b : R\n⊢ Eq (Neg.neg (HDiv.hDiv b a)) (HDiv.hDiv (Neg.neg b) a)","decl":"@[field_simps]\nlemma neg_div' (a b : R) : -(b / a) = -b / a := by simp [neg_div]\n\n"}
{"name":"neg_div_neg_eq","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝¹ : DivisionMonoid R\ninst✝ : HasDistribNeg R\na b : R\n⊢ Eq (HDiv.hDiv (Neg.neg a) (Neg.neg b)) (HDiv.hDiv a b)","decl":"@[simp]\nlemma neg_div_neg_eq (a b : R) : -a / -b = a / b := by rw [div_neg_eq_neg_div, neg_div, neg_neg]\n\n"}
{"name":"neg_inv","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝¹ : DivisionMonoid R\ninst✝ : HasDistribNeg R\na : R\n⊢ Eq (Neg.neg (Inv.inv a)) (Inv.inv (Neg.neg a))","decl":"lemma neg_inv : -a⁻¹ = (-a)⁻¹ := by rw [inv_eq_one_div, inv_eq_one_div, div_neg_eq_neg_div]\n\n"}
{"name":"div_neg","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝¹ : DivisionMonoid R\ninst✝ : HasDistribNeg R\nb a : R\n⊢ Eq (HDiv.hDiv a (Neg.neg b)) (Neg.neg (HDiv.hDiv a b))","decl":"lemma div_neg (a : R) : a / -b = -(a / b) := by rw [← div_neg_eq_neg_div]\n\n"}
{"name":"inv_neg","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝¹ : DivisionMonoid R\ninst✝ : HasDistribNeg R\na : R\n⊢ Eq (Inv.inv (Neg.neg a)) (Neg.neg (Inv.inv a))","decl":"lemma inv_neg : (-a)⁻¹ = -a⁻¹ := by rw [neg_inv]\n\n"}
{"name":"inv_neg_one","module":"Mathlib.Algebra.Ring.Basic","initialProofState":"R : Type u_1\ninst✝¹ : DivisionMonoid R\ninst✝ : HasDistribNeg R\n⊢ Eq (Inv.inv (-1)) (-1)","decl":"lemma inv_neg_one : (-1 : R)⁻¹ = -1 := by rw [← neg_inv, inv_one]\n\n"}
