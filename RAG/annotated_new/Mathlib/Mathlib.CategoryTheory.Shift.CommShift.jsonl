{"name":"CategoryTheory.Functor.CommShift.isoZero_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : CategoryTheory.HasShift C A\ninstâœ : CategoryTheory.HasShift D A\nX : C\nâŠ¢ Eq ((CategoryTheory.Functor.CommShift.isoZero F A).hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorZero C A).hom.app X)) ((CategoryTheory.shiftFunctorZero D A).inv.app (F.obj X)))","decl":"/-- For any functor `F : C â¥¤ D`, this is the obvious isomorphism\n`shiftFunctor C (0 : A) â‹™ F â‰… F â‹™ shiftFunctor D (0 : A)` deduced from the\nisomorphisms `shiftFunctorZero` on both categories `C` and `D`. -/\n@[simps!]\nnoncomputable def isoZero : shiftFunctor C (0 : A) â‹™ F â‰… F â‹™ shiftFunctor D (0 : A) :=\n  isoWhiskerRight (shiftFunctorZero C A) F â‰ªâ‰« F.leftUnitor â‰ªâ‰«\n     F.rightUnitor.symm â‰ªâ‰« isoWhiskerLeft F (shiftFunctorZero D A).symm\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoZero_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : CategoryTheory.HasShift C A\ninstâœ : CategoryTheory.HasShift D A\nX : C\nâŠ¢ Eq ((CategoryTheory.Functor.CommShift.isoZero F A).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero D A).hom.app (F.obj X)) (F.map ((CategoryTheory.shiftFunctorZero C A).inv.app X)))","decl":"/-- For any functor `F : C â¥¤ D`, this is the obvious isomorphism\n`shiftFunctor C (0 : A) â‹™ F â‰… F â‹™ shiftFunctor D (0 : A)` deduced from the\nisomorphisms `shiftFunctorZero` on both categories `C` and `D`. -/\n@[simps!]\nnoncomputable def isoZero : shiftFunctor C (0 : A) â‹™ F â‰… F â‹™ shiftFunctor D (0 : A) :=\n  isoWhiskerRight (shiftFunctorZero C A) F â‰ªâ‰« F.leftUnitor â‰ªâ‰«\n     F.rightUnitor.symm â‰ªâ‰« isoWhiskerLeft F (shiftFunctorZero D A).symm\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoZero'_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : CategoryTheory.HasShift C A\ninstâœ : CategoryTheory.HasShift D A\na : A\nha : Eq a 0\nX : C\nâŠ¢ Eq ((CategoryTheory.Functor.CommShift.isoZero' F A a ha).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero' D a ha).hom.app (F.obj X)) (F.map ((CategoryTheory.shiftFunctorZero' C a ha).inv.app X)))","decl":"/-- For any functor `F : C â¥¤ D` and any `a` in `A` such that `a = 0`,\nthis is the obvious isomorphism `shiftFunctor C a â‹™ F â‰… F â‹™ shiftFunctor D a` deduced from the\nisomorphisms `shiftFunctorZero'` on both categories `C` and `D`. -/\n@[simps!]\nnoncomputable def isoZero' (a : A) (ha : a = 0) : shiftFunctor C a â‹™ F â‰… F â‹™ shiftFunctor D a :=\n  isoWhiskerRight (shiftFunctorZero' C a ha) F â‰ªâ‰« F.leftUnitor â‰ªâ‰«\n     F.rightUnitor.symm â‰ªâ‰« isoWhiskerLeft F (shiftFunctorZero' D a ha).symm\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoZero'_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : CategoryTheory.HasShift C A\ninstâœ : CategoryTheory.HasShift D A\na : A\nha : Eq a 0\nX : C\nâŠ¢ Eq ((CategoryTheory.Functor.CommShift.isoZero' F A a ha).hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorZero' C a ha).hom.app X)) ((CategoryTheory.shiftFunctorZero' D a ha).inv.app (F.obj X)))","decl":"/-- For any functor `F : C â¥¤ D` and any `a` in `A` such that `a = 0`,\nthis is the obvious isomorphism `shiftFunctor C a â‹™ F â‰… F â‹™ shiftFunctor D a` deduced from the\nisomorphisms `shiftFunctorZero'` on both categories `C` and `D`. -/\n@[simps!]\nnoncomputable def isoZero' (a : A) (ha : a = 0) : shiftFunctor C a â‹™ F â‰… F â‹™ shiftFunctor D a :=\n  isoWhiskerRight (shiftFunctorZero' C a ha) F â‰ªâ‰« F.leftUnitor â‰ªâ‰«\n     F.rightUnitor.symm â‰ªâ‰« isoWhiskerLeft F (shiftFunctorZero' D a ha).symm\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoZero'_eq_isoZero","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : CategoryTheory.HasShift C A\ninstâœ : CategoryTheory.HasShift D A\nâŠ¢ Eq (CategoryTheory.Functor.CommShift.isoZero' F A 0 â‹¯) (CategoryTheory.Functor.CommShift.isoZero F A)","decl":"@[simp]\nlemma isoZero'_eq_isoZero : isoZero' F A 0 rfl = isoZero F A := by\n  ext; simp [isoZero', shiftFunctorZero']\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoAdd'_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : CategoryTheory.HasShift C A\ninstâœ : CategoryTheory.HasShift D A\na b c : A\nh : Eq (HAdd.hAdd a b) c\neâ‚ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\neâ‚‚ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C b).comp F) (F.comp (CategoryTheory.shiftFunctor D b))\nX : C\nâŠ¢ Eq ((CategoryTheory.Functor.CommShift.isoAdd' h eâ‚ eâ‚‚).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' D a b c h).hom.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map (eâ‚.inv.app X)) (CategoryTheory.CategoryStruct.comp (eâ‚‚.inv.app ((CategoryTheory.shiftFunctor C a).obj X)) (F.map ((CategoryTheory.shiftFunctorAdd' C a b c h).inv.app X)))))","decl":"/-- If a functor `F : C â¥¤ D` is equipped with \"commutation isomorphisms\" with the\nshifts by `a` and `b`, then there is a commutation isomorphism with the shift by `c` when\n`a + b = c`. -/\n@[simps!]\nnoncomputable def isoAdd' {a b c : A} (h : a + b = c)\n    (eâ‚ : shiftFunctor C a â‹™ F â‰… F â‹™ shiftFunctor D a)\n    (eâ‚‚ : shiftFunctor C b â‹™ F â‰… F â‹™ shiftFunctor D b) :\n    shiftFunctor C c â‹™ F â‰… F â‹™ shiftFunctor D c :=\n  isoWhiskerRight (shiftFunctorAdd' C _ _ _ h) F â‰ªâ‰« Functor.associator _ _ _ â‰ªâ‰«\n    isoWhiskerLeft _ eâ‚‚ â‰ªâ‰« (Functor.associator _ _ _).symm â‰ªâ‰« isoWhiskerRight eâ‚ _ â‰ªâ‰«\n      Functor.associator _ _ _ â‰ªâ‰« isoWhiskerLeft _ (shiftFunctorAdd' D _ _ _ h).symm\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoAdd'_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : CategoryTheory.HasShift C A\ninstâœ : CategoryTheory.HasShift D A\na b c : A\nh : Eq (HAdd.hAdd a b) c\neâ‚ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\neâ‚‚ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C b).comp F) (F.comp (CategoryTheory.shiftFunctor D b))\nX : C\nâŠ¢ Eq ((CategoryTheory.Functor.CommShift.isoAdd' h eâ‚ eâ‚‚).hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorAdd' C a b c h).hom.app X)) (CategoryTheory.CategoryStruct.comp (eâ‚‚.hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map (eâ‚.hom.app X)) ((CategoryTheory.shiftFunctorAdd' D a b c h).inv.app (F.obj X)))))","decl":"/-- If a functor `F : C â¥¤ D` is equipped with \"commutation isomorphisms\" with the\nshifts by `a` and `b`, then there is a commutation isomorphism with the shift by `c` when\n`a + b = c`. -/\n@[simps!]\nnoncomputable def isoAdd' {a b c : A} (h : a + b = c)\n    (eâ‚ : shiftFunctor C a â‹™ F â‰… F â‹™ shiftFunctor D a)\n    (eâ‚‚ : shiftFunctor C b â‹™ F â‰… F â‹™ shiftFunctor D b) :\n    shiftFunctor C c â‹™ F â‰… F â‹™ shiftFunctor D c :=\n  isoWhiskerRight (shiftFunctorAdd' C _ _ _ h) F â‰ªâ‰« Functor.associator _ _ _ â‰ªâ‰«\n    isoWhiskerLeft _ eâ‚‚ â‰ªâ‰« (Functor.associator _ _ _).symm â‰ªâ‰« isoWhiskerRight eâ‚ _ â‰ªâ‰«\n      Functor.associator _ _ _ â‰ªâ‰« isoWhiskerLeft _ (shiftFunctorAdd' D _ _ _ h).symm\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoAdd_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : CategoryTheory.HasShift C A\ninstâœ : CategoryTheory.HasShift D A\na b : A\neâ‚ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\neâ‚‚ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C b).comp F) (F.comp (CategoryTheory.shiftFunctor D b))\nX : C\nâŠ¢ Eq ((CategoryTheory.Functor.CommShift.isoAdd eâ‚ eâ‚‚).hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorAdd C a b).hom.app X)) (CategoryTheory.CategoryStruct.comp (eâ‚‚.hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map (eâ‚.hom.app X)) ((CategoryTheory.shiftFunctorAdd D a b).inv.app (F.obj X)))))","decl":"@[simp]\nlemma isoAdd_hom_app {a b : A}\n    (eâ‚ : shiftFunctor C a â‹™ F â‰… F â‹™ shiftFunctor D a)\n    (eâ‚‚ : shiftFunctor C b â‹™ F â‰… F â‹™ shiftFunctor D b) (X : C) :\n      (CommShift.isoAdd eâ‚ eâ‚‚).hom.app X =\n        F.map ((shiftFunctorAdd C a b).hom.app X) â‰« eâ‚‚.hom.app ((shiftFunctor C a).obj X) â‰«\n          (shiftFunctor D b).map (eâ‚.hom.app X) â‰« (shiftFunctorAdd D a b).inv.app (F.obj X) := by\n  simp only [isoAdd, isoAdd'_hom_app, shiftFunctorAdd'_eq_shiftFunctorAdd]\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoAdd_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : CategoryTheory.HasShift C A\ninstâœ : CategoryTheory.HasShift D A\na b : A\neâ‚ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\neâ‚‚ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C b).comp F) (F.comp (CategoryTheory.shiftFunctor D b))\nX : C\nâŠ¢ Eq ((CategoryTheory.Functor.CommShift.isoAdd eâ‚ eâ‚‚).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd D a b).hom.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map (eâ‚.inv.app X)) (CategoryTheory.CategoryStruct.comp (eâ‚‚.inv.app ((CategoryTheory.shiftFunctor C a).obj X)) (F.map ((CategoryTheory.shiftFunctorAdd C a b).inv.app X)))))","decl":"@[simp]\nlemma isoAdd_inv_app {a b : A}\n    (eâ‚ : shiftFunctor C a â‹™ F â‰… F â‹™ shiftFunctor D a)\n    (eâ‚‚ : shiftFunctor C b â‹™ F â‰… F â‹™ shiftFunctor D b) (X : C) :\n      (CommShift.isoAdd eâ‚ eâ‚‚).inv.app X = (shiftFunctorAdd D a b).hom.app (F.obj X) â‰«\n        (shiftFunctor D b).map (eâ‚.inv.app X) â‰« eâ‚‚.inv.app ((shiftFunctor C a).obj X) â‰«\n        F.map ((shiftFunctorAdd C a b).inv.app X) := by\n  simp only [isoAdd, isoAdd'_inv_app, shiftFunctorAdd'_eq_shiftFunctorAdd]\n\n"}
{"name":"CategoryTheory.Functor.CommShift.zero","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : CategoryTheory.HasShift C A\ninstâœ : CategoryTheory.HasShift D A\nself : F.CommShift A\nâŠ¢ Eq (CategoryTheory.Functor.CommShift.iso 0) (CategoryTheory.Functor.CommShift.isoZero F A)","decl":"/-- A functor `F` commutes with the shift by a monoid `A` if it is equipped with\ncommutation isomorphisms with the shifts by all `a : A`, and these isomorphisms\nsatisfy coherence properties with respect to `0 : A` and the addition in `A`. -/\nclass CommShift where\n  iso (a : A) : shiftFunctor C a â‹™ F â‰… F â‹™ shiftFunctor D a\n  zero : iso 0 = CommShift.isoZero F A := by aesop_cat\n  add (a b : A) : iso (a + b) = CommShift.isoAdd (iso a) (iso b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CommShift.add","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : CategoryTheory.HasShift C A\ninstâœ : CategoryTheory.HasShift D A\nself : F.CommShift A\na b : A\nâŠ¢ Eq (CategoryTheory.Functor.CommShift.iso (HAdd.hAdd a b)) (CategoryTheory.Functor.CommShift.isoAdd (CategoryTheory.Functor.CommShift.iso a) (CategoryTheory.Functor.CommShift.iso b))","decl":"/-- A functor `F` commutes with the shift by a monoid `A` if it is equipped with\ncommutation isomorphisms with the shifts by all `a : A`, and these isomorphisms\nsatisfy coherence properties with respect to `0 : A` and the addition in `A`. -/\nclass CommShift where\n  iso (a : A) : shiftFunctor C a â‹™ F â‰… F â‹™ shiftFunctor D a\n  zero : iso 0 = CommShift.isoZero F A := by aesop_cat\n  add (a b : A) : iso (a + b) = CommShift.isoAdd (iso a) (iso b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_hom_naturality","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : F.CommShift A\nX Y : C\nf : Quiver.Hom X Y\na : A\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map f)) ((F.commShiftIso a).hom.app Y)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).hom.app X) ((CategoryTheory.shiftFunctor D a).map (F.map f)))","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_hom_naturality {X Y : C} (f : X âŸ¶ Y) (a : A) :\n    F.map (fâŸ¦aâŸ§') â‰« (F.commShiftIso a).hom.app Y =\n      (F.commShiftIso a).hom.app X â‰« (F.map f)âŸ¦aâŸ§' :=\n  (F.commShiftIso a).hom.naturality f\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : F.CommShift A\nX Y : C\nf : Quiver.Hom X Y\na : A\nZ : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj (F.obj Y)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map f)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).hom.app Y) h)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map f)) h))","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_hom_naturality {X Y : C} (f : X âŸ¶ Y) (a : A) :\n    F.map (fâŸ¦aâŸ§') â‰« (F.commShiftIso a).hom.app Y =\n      (F.commShiftIso a).hom.app X â‰« (F.map f)âŸ¦aâŸ§' :=\n  (F.commShiftIso a).hom.naturality f\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_inv_naturality","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : F.CommShift A\nX Y : C\nf : Quiver.Hom X Y\na : A\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map f)) ((F.commShiftIso a).inv.app Y)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app X) (F.map ((CategoryTheory.shiftFunctor C a).map f)))","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_inv_naturality {X Y : C} (f : X âŸ¶ Y) (a : A) :\n    (F.map f)âŸ¦aâŸ§' â‰« (F.commShiftIso a).inv.app Y =\n      (F.commShiftIso a).inv.app X â‰« F.map (fâŸ¦aâŸ§') :=\n  (F.commShiftIso a).inv.naturality f\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : F.CommShift A\nX Y : C\nf : Quiver.Hom X Y\na : A\nZ : D\nh : Quiver.Hom (F.obj ((CategoryTheory.shiftFunctor C a).obj Y)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map f)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app Y) h)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map f)) h))","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_inv_naturality {X Y : C} (f : X âŸ¶ Y) (a : A) :\n    (F.map f)âŸ¦aâŸ§' â‰« (F.commShiftIso a).inv.app Y =\n      (F.commShiftIso a).inv.app X â‰« F.map (fâŸ¦aâŸ§') :=\n  (F.commShiftIso a).inv.naturality f\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_zero","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : F.CommShift A\nâŠ¢ Eq (F.commShiftIso 0) (CategoryTheory.Functor.CommShift.isoZero F A)","decl":"lemma commShiftIso_zero :\n    F.commShiftIso (0 : A) = CommShift.isoZero F A :=\n  CommShift.zero\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_zero'","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : F.CommShift A\na : A\nh : Eq a 0\nâŠ¢ Eq (F.commShiftIso a) (CategoryTheory.Functor.CommShift.isoZero' F A a h)","decl":"set_option linter.docPrime false in\nlemma commShiftIso_zero' (a : A) (h : a = 0) :\n    F.commShiftIso a = CommShift.isoZero' F A a h := by\n  subst h; rw [CommShift.isoZero'_eq_isoZero, commShiftIso_zero]\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_add","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : F.CommShift A\na b : A\nâŠ¢ Eq (F.commShiftIso (HAdd.hAdd a b)) (CategoryTheory.Functor.CommShift.isoAdd (F.commShiftIso a) (F.commShiftIso b))","decl":"lemma commShiftIso_add (a b : A) :\n    F.commShiftIso (a + b) = CommShift.isoAdd (F.commShiftIso a) (F.commShiftIso b) :=\n  CommShift.add a b\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_add'","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : F.CommShift A\na b c : A\nh : Eq (HAdd.hAdd a b) c\nâŠ¢ Eq (F.commShiftIso c) (CategoryTheory.Functor.CommShift.isoAdd' h (F.commShiftIso a) (F.commShiftIso b))","decl":"lemma commShiftIso_add' {a b c : A} (h : a + b = c) :\n    F.commShiftIso c = CommShift.isoAdd' h (F.commShiftIso a) (F.commShiftIso b) := by\n  subst h\n  simp only [commShiftIso_add, CommShift.isoAdd]\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_id_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_6, u_1} C\nA : Type u_4\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift C A\na : A\nX : C\nâŠ¢ Eq (((CategoryTheory.Functor.id C).commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.id (((CategoryTheory.shiftFunctor C a).comp (CategoryTheory.Functor.id C)).obj X))","decl":"@[simp]\nlemma commShiftIso_id_hom_app (a : A) (X : C) :\n    (commShiftIso (ğŸ­ C) a).hom.app X = ğŸ™ _ := comp_id _\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_id_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_6, u_1} C\nA : Type u_4\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift C A\na : A\nX : C\nâŠ¢ Eq (((CategoryTheory.Functor.id C).commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.id C).comp (CategoryTheory.shiftFunctor C a)).obj X))","decl":"@[simp]\nlemma commShiftIso_id_inv_app (a : A) (X : C) :\n    (commShiftIso (ğŸ­ C) a).inv.app X = ğŸ™ _ := comp_id _\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_comp_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ¸ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ· : CategoryTheory.Category.{u_7, u_2} D\ninstâœâ¶ : CategoryTheory.Category.{u_8, u_3} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nA : Type u_4\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : CategoryTheory.HasShift E A\ninstâœÂ¹ : F.CommShift A\ninstâœ : G.CommShift A\na : A\nX : C\nâŠ¢ Eq (((F.comp G).commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp (G.map ((F.commShiftIso a).hom.app X)) ((G.commShiftIso a).hom.app (F.obj X)))","decl":"lemma commShiftIso_comp_hom_app [F.CommShift A] [G.CommShift A] (a : A) (X : C) :\n    (commShiftIso (F â‹™ G) a).hom.app X =\n      G.map ((commShiftIso F a).hom.app X) â‰« (commShiftIso G a).hom.app (F.obj X) := by\n  simp [commShiftIso, CommShift.iso]\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_comp_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ¸ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ· : CategoryTheory.Category.{u_7, u_2} D\ninstâœâ¶ : CategoryTheory.Category.{u_8, u_3} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nA : Type u_4\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : CategoryTheory.HasShift E A\ninstâœÂ¹ : F.CommShift A\ninstâœ : G.CommShift A\na : A\nX : C\nâŠ¢ Eq (((F.comp G).commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.comp ((G.commShiftIso a).inv.app (F.obj X)) (G.map ((F.commShiftIso a).inv.app X)))","decl":"lemma commShiftIso_comp_inv_app [F.CommShift A] [G.CommShift A] (a : A) (X : C) :\n    (commShiftIso (F â‹™ G) a).inv.app X =\n      (commShiftIso G a).inv.app (F.obj X) â‰« G.map ((commShiftIso F a).inv.app X) := by\n  simp [commShiftIso, CommShift.iso]\n\n"}
{"name":"CategoryTheory.Functor.map_shiftFunctorComm_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nB : Type u_5\ninstâœÂ³ : AddCommMonoid B\ninstâœÂ² : CategoryTheory.HasShift C B\ninstâœÂ¹ : CategoryTheory.HasShift D B\ninstâœ : F.CommShift B\nX : C\na b : B\nâŠ¢ Eq (F.map ((CategoryTheory.shiftFunctorComm C a b).hom.app X)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso b).hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorComm D a b).hom.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map ((F.commShiftIso b).inv.app X)) ((F.commShiftIso a).inv.app ((CategoryTheory.shiftFunctor C b).obj X))))))","decl":"lemma map_shiftFunctorComm_hom_app [F.CommShift B] (X : C) (a b : B) :\n    F.map ((shiftFunctorComm C a b).hom.app X) = (F.commShiftIso b).hom.app (XâŸ¦aâŸ§) â‰«\n      ((F.commShiftIso a).hom.app X)âŸ¦bâŸ§' â‰« (shiftFunctorComm D a b).hom.app (F.obj X) â‰«\n      ((F.commShiftIso b).inv.app X)âŸ¦aâŸ§' â‰« (F.commShiftIso a).inv.app (XâŸ¦bâŸ§) := by\n  have eq := NatTrans.congr_app (congr_arg Iso.hom (F.commShiftIso_add a b)) X\n  simp only [comp_obj, CommShift.isoAdd_hom_app,\n    â† cancel_epi (F.map ((shiftFunctorAdd C a b).inv.app X)), Category.assoc,\n    â† F.map_comp_assoc, Iso.inv_hom_id_app, F.map_id, Category.id_comp, F.map_comp] at eq\n  simp only [shiftFunctorComm_eq D a b _ rfl]\n  dsimp\n  simp only [Functor.map_comp, shiftFunctorAdd'_eq_shiftFunctorAdd, Category.assoc,\n    â† reassoc_of% eq, shiftFunctorComm_eq C a b _ rfl]\n  dsimp\n  rw [Functor.map_comp]\n  simp only [NatTrans.congr_app (congr_arg Iso.hom (F.commShiftIso_add' (add_comm b a))) X,\n    CommShift.isoAdd'_hom_app, Category.assoc, Iso.inv_hom_id_app_assoc,\n    â† Functor.map_comp_assoc, Iso.hom_inv_id_app,\n    Functor.map_id, Category.id_comp, comp_obj, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Functor.map_shiftFunctorCompIsoId_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : F.CommShift A\nX : C\na b : A\nh : Eq (HAdd.hAdd a b) 0\nâŠ¢ Eq (F.map ((CategoryTheory.shiftFunctorCompIsoId C a b h).hom.app X)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso b).hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).hom.app X)) ((CategoryTheory.shiftFunctorCompIsoId D a b h).hom.app (F.obj X))))","decl":"@[simp, reassoc]\nlemma map_shiftFunctorCompIsoId_hom_app [F.CommShift A] (X : C) (a b : A) (h : a + b = 0) :\n    F.map ((shiftFunctorCompIsoId C a b h).hom.app X) =\n      (F.commShiftIso b).hom.app (XâŸ¦aâŸ§) â‰« ((F.commShiftIso a).hom.app X)âŸ¦bâŸ§' â‰«\n        (shiftFunctorCompIsoId D a b h).hom.app (F.obj X) := by\n  dsimp [shiftFunctorCompIsoId]\n  have eq := NatTrans.congr_app (congr_arg Iso.hom (F.commShiftIso_add' h)) X\n  simp only [commShiftIso_zero, comp_obj, CommShift.isoZero_hom_app,\n    CommShift.isoAdd'_hom_app] at eq\n  rw [â† cancel_epi (F.map ((shiftFunctorAdd' C a b 0 h).hom.app X)), â† reassoc_of% eq, F.map_comp]\n  simp only [Iso.inv_hom_id_app, id_obj, Category.comp_id, â† F.map_comp_assoc, Iso.hom_inv_id_app,\n    F.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Functor.map_shiftFunctorCompIsoId_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : F.CommShift A\nX : C\na b : A\nhâœ : Eq (HAdd.hAdd a b) 0\nZ : D\nh : Quiver.Hom (F.obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorCompIsoId C a b hâœ).hom.app X)) h) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso b).hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId D a b hâœ).hom.app (F.obj X)) h)))","decl":"@[simp, reassoc]\nlemma map_shiftFunctorCompIsoId_hom_app [F.CommShift A] (X : C) (a b : A) (h : a + b = 0) :\n    F.map ((shiftFunctorCompIsoId C a b h).hom.app X) =\n      (F.commShiftIso b).hom.app (XâŸ¦aâŸ§) â‰« ((F.commShiftIso a).hom.app X)âŸ¦bâŸ§' â‰«\n        (shiftFunctorCompIsoId D a b h).hom.app (F.obj X) := by\n  dsimp [shiftFunctorCompIsoId]\n  have eq := NatTrans.congr_app (congr_arg Iso.hom (F.commShiftIso_add' h)) X\n  simp only [commShiftIso_zero, comp_obj, CommShift.isoZero_hom_app,\n    CommShift.isoAdd'_hom_app] at eq\n  rw [â† cancel_epi (F.map ((shiftFunctorAdd' C a b 0 h).hom.app X)), â† reassoc_of% eq, F.map_comp]\n  simp only [Iso.inv_hom_id_app, id_obj, Category.comp_id, â† F.map_comp_assoc, Iso.hom_inv_id_app,\n    F.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Functor.map_shiftFunctorCompIsoId_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : F.CommShift A\nX : C\na b : A\nh : Eq (HAdd.hAdd a b) 0\nâŠ¢ Eq (F.map ((CategoryTheory.shiftFunctorCompIsoId C a b h).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId D a b h).inv.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).inv.app X)) ((F.commShiftIso b).inv.app ((CategoryTheory.shiftFunctor C a).obj X))))","decl":"@[simp, reassoc]\nlemma map_shiftFunctorCompIsoId_inv_app [F.CommShift A] (X : C) (a b : A) (h : a + b = 0) :\n    F.map ((shiftFunctorCompIsoId C a b h).inv.app X) =\n      (shiftFunctorCompIsoId D a b h).inv.app (F.obj X) â‰«\n        ((F.commShiftIso a).inv.app X)âŸ¦bâŸ§' â‰« (F.commShiftIso b).inv.app (XâŸ¦aâŸ§) := by\n  rw [â† cancel_epi (F.map ((shiftFunctorCompIsoId C a b h).hom.app X)), â† F.map_comp,\n    Iso.hom_inv_id_app, F.map_id, map_shiftFunctorCompIsoId_hom_app]\n  simp only [comp_obj, id_obj, Category.assoc, Iso.hom_inv_id_app_assoc,\n    â† Functor.map_comp_assoc, Iso.hom_inv_id_app, Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Functor.map_shiftFunctorCompIsoId_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : F.CommShift A\nX : C\na b : A\nhâœ : Eq (HAdd.hAdd a b) 0\nZ : D\nh : Quiver.Hom (F.obj ((CategoryTheory.shiftFunctor C b).obj ((CategoryTheory.shiftFunctor C a).obj X))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorCompIsoId C a b hâœ).inv.app X)) h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId D a b hâœ).inv.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).inv.app X)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso b).inv.app ((CategoryTheory.shiftFunctor C a).obj X)) h)))","decl":"@[simp, reassoc]\nlemma map_shiftFunctorCompIsoId_inv_app [F.CommShift A] (X : C) (a b : A) (h : a + b = 0) :\n    F.map ((shiftFunctorCompIsoId C a b h).inv.app X) =\n      (shiftFunctorCompIsoId D a b h).inv.app (F.obj X) â‰«\n        ((F.commShiftIso a).inv.app X)âŸ¦bâŸ§' â‰« (F.commShiftIso b).inv.app (XâŸ¦aâŸ§) := by\n  rw [â† cancel_epi (F.map ((shiftFunctorCompIsoId C a b h).hom.app X)), â† F.map_comp,\n    Iso.hom_inv_id_app, F.map_id, map_shiftFunctorCompIsoId_hom_app]\n  simp only [comp_obj, id_obj, Category.assoc, Iso.hom_inv_id_app_assoc,\n    â† Functor.map_comp_assoc, Iso.hom_inv_id_app, Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.shift_comm","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_7, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâ´ : AddMonoid A\ninstâœÂ³ : CategoryTheory.HasShift C A\ninstâœÂ² : CategoryTheory.HasShift D A\ninstâœÂ¹ : Fâ‚.CommShift A\ninstâœ : Fâ‚‚.CommShift A\nself : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Fâ‚.commShiftIso a).hom (CategoryTheory.whiskerRight Ï„ (CategoryTheory.shiftFunctor D a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (CategoryTheory.shiftFunctor C a) Ï„) (Fâ‚‚.commShiftIso a).hom)","decl":"/-- If `Ï„ : Fâ‚ âŸ¶ Fâ‚‚` is a natural transformation between two functors\nwhich commute with a shift by an additive monoid `A`, this typeclass\nasserts a compatibility of `Ï„` with these shifts. -/\nclass CommShift : Prop where\n  shift_comm (a : A) : (Fâ‚.commShiftIso a).hom â‰« whiskerRight Ï„ _ =\n    whiskerLeft _ Ï„ â‰« (Fâ‚‚.commShiftIso a).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.NatTrans.shift_comm","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Fâ‚.commShiftIso a).hom (CategoryTheory.whiskerRight Ï„ (CategoryTheory.shiftFunctor D a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (CategoryTheory.shiftFunctor C a) Ï„) (Fâ‚‚.commShiftIso a).hom)","decl":"@[reassoc]\nlemma shift_comm (a : A) :\n    (Fâ‚.commShiftIso a).hom â‰« whiskerRight Ï„ _ =\n      whiskerLeft _ Ï„ â‰« (Fâ‚‚.commShiftIso a).hom := by\n  apply CommShift.shift_comm\n\n"}
{"name":"CategoryTheory.NatTrans.shift_comm_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (Fâ‚‚.comp (CategoryTheory.shiftFunctor D a)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Fâ‚.commShiftIso a).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight Ï„ (CategoryTheory.shiftFunctor D a)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (CategoryTheory.shiftFunctor C a) Ï„) (CategoryTheory.CategoryStruct.comp (Fâ‚‚.commShiftIso a).hom h))","decl":"@[reassoc]\nlemma shift_comm (a : A) :\n    (Fâ‚.commShiftIso a).hom â‰« whiskerRight Ï„ _ =\n      whiskerLeft _ Ï„ â‰« (Fâ‚‚.commShiftIso a).hom := by\n  apply CommShift.shift_comm\n\n"}
{"name":"CategoryTheory.NatTrans.shift_app_comm","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((Fâ‚.commShiftIso a).hom.app X) ((CategoryTheory.shiftFunctor D a).map (Ï„.app X))) (CategoryTheory.CategoryStruct.comp (Ï„.app ((CategoryTheory.shiftFunctor C a).obj X)) ((Fâ‚‚.commShiftIso a).hom.app X))","decl":"@[reassoc]\nlemma shift_app_comm (a : A) (X : C) :\n    (Fâ‚.commShiftIso a).hom.app X â‰« (Ï„.app X)âŸ¦aâŸ§' =\n      Ï„.app (XâŸ¦aâŸ§) â‰« (Fâ‚‚.commShiftIso a).hom.app X :=\n  congr_app (shift_comm Ï„ a) X\n\n"}
{"name":"CategoryTheory.NatTrans.shift_app_comm_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nX : C\nZ : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj (Fâ‚‚.obj X)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((Fâ‚.commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (Ï„.app X)) h)) (CategoryTheory.CategoryStruct.comp (Ï„.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((Fâ‚‚.commShiftIso a).hom.app X) h))","decl":"@[reassoc]\nlemma shift_app_comm (a : A) (X : C) :\n    (Fâ‚.commShiftIso a).hom.app X â‰« (Ï„.app X)âŸ¦aâŸ§' =\n      Ï„.app (XâŸ¦aâŸ§) â‰« (Fâ‚‚.commShiftIso a).hom.app X :=\n  congr_app (shift_comm Ï„ a) X\n\n"}
{"name":"CategoryTheory.NatTrans.shift_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nX : C\nâŠ¢ Eq ((CategoryTheory.shiftFunctor D a).map (Ï„.app X)) (CategoryTheory.CategoryStruct.comp ((Fâ‚.commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.comp (Ï„.app ((CategoryTheory.shiftFunctor C a).obj X)) ((Fâ‚‚.commShiftIso a).hom.app X)))","decl":"@[reassoc]\nlemma shift_app (a : A) (X : C) :\n    (Ï„.app X)âŸ¦aâŸ§' = (Fâ‚.commShiftIso a).inv.app X â‰«\n      Ï„.app (XâŸ¦aâŸ§) â‰« (Fâ‚‚.commShiftIso a).hom.app X := by\n  rw [â† shift_app_comm, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.NatTrans.shift_app_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nX : C\nZ : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj (Fâ‚‚.obj X)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (Ï„.app X)) h) (CategoryTheory.CategoryStruct.comp ((Fâ‚.commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.comp (Ï„.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((Fâ‚‚.commShiftIso a).hom.app X) h)))","decl":"@[reassoc]\nlemma shift_app (a : A) (X : C) :\n    (Ï„.app X)âŸ¦aâŸ§' = (Fâ‚.commShiftIso a).inv.app X â‰«\n      Ï„.app (XâŸ¦aâŸ§) â‰« (Fâ‚‚.commShiftIso a).hom.app X := by\n  rw [â† shift_app_comm, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.NatTrans.app_shift_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nX : C\nZ : D\nh : Quiver.Hom (Fâ‚‚.obj ((CategoryTheory.shiftFunctor C a).obj X)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Ï„.app ((CategoryTheory.shiftFunctor C a).obj X)) h) (CategoryTheory.CategoryStruct.comp ((Fâ‚.commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (Ï„.app X)) (CategoryTheory.CategoryStruct.comp ((Fâ‚‚.commShiftIso a).inv.app X) h)))","decl":"@[reassoc]\nlemma app_shift (a : A) (X : C) :\n    Ï„.app (XâŸ¦aâŸ§) = (Fâ‚.commShiftIso a).hom.app X â‰« (Ï„.app X)âŸ¦aâŸ§' â‰«\n      (Fâ‚‚.commShiftIso a).inv.app X := by\n  simp [shift_app_comm_assoc Ï„ a X]\n\n"}
{"name":"CategoryTheory.NatTrans.app_shift","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nX : C\nâŠ¢ Eq (Ï„.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((Fâ‚.commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (Ï„.app X)) ((Fâ‚‚.commShiftIso a).inv.app X)))","decl":"@[reassoc]\nlemma app_shift (a : A) (X : C) :\n    Ï„.app (XâŸ¦aâŸ§) = (Fâ‚.commShiftIso a).hom.app X â‰« (Ï„.app X)âŸ¦aâŸ§' â‰«\n      (Fâ‚‚.commShiftIso a).inv.app X := by\n  simp [shift_app_comm_assoc Ï„ a X]\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.comm'","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Fâ‚.commShiftIso a).hom (CategoryTheory.whiskerRight Ï„ (CategoryTheory.shiftFunctor D a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (CategoryTheory.shiftFunctor C a) Ï„) (Fâ‚‚.commShiftIso a).hom)","decl":"@[deprecated (since := \"2024-12-31\")] alias CommShift.comm' := shift_comm\n"}
{"name":"CategoryTheory.NatTrans.CommShift.comm","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Fâ‚.commShiftIso a).hom (CategoryTheory.whiskerRight Ï„ (CategoryTheory.shiftFunctor D a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (CategoryTheory.shiftFunctor C a) Ï„) (Fâ‚‚.commShiftIso a).hom)","decl":"@[deprecated (since := \"2024-12-31\")] alias CommShift.comm := shift_comm\n"}
{"name":"CategoryTheory.NatTrans.CommShift.comm_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((Fâ‚.commShiftIso a).hom.app X) ((CategoryTheory.shiftFunctor D a).map (Ï„.app X))) (CategoryTheory.CategoryStruct.comp (Ï„.app ((CategoryTheory.shiftFunctor C a).obj X)) ((Fâ‚‚.commShiftIso a).hom.app X))","decl":"@[deprecated (since := \"2024-12-31\")] alias CommShift.comm_app := shift_app_comm\n"}
{"name":"CategoryTheory.NatTrans.CommShift.shift_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nX : C\nâŠ¢ Eq ((CategoryTheory.shiftFunctor D a).map (Ï„.app X)) (CategoryTheory.CategoryStruct.comp ((Fâ‚.commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.comp (Ï„.app ((CategoryTheory.shiftFunctor C a).obj X)) ((Fâ‚‚.commShiftIso a).hom.app X)))","decl":"@[deprecated (since := \"2024-12-31\")] alias CommShift.shift_app := shift_app\n"}
{"name":"CategoryTheory.NatTrans.CommShift.app_shift","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\na : A\nX : C\nâŠ¢ Eq (Ï„.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((Fâ‚.commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (Ï„.app X)) ((Fâ‚‚.commShiftIso a).inv.app X)))","decl":"@[deprecated (since := \"2024-12-31\")] alias CommShift.app_shift := app_shift\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.of_iso_inv","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ¶ : CategoryTheory.Category.{u_7, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift C A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : Fâ‚‚.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift e.hom A\nâŠ¢ CategoryTheory.NatTrans.CommShift e.inv A","decl":"instance of_iso_inv [NatTrans.CommShift e.hom A] :\n  NatTrans.CommShift e.inv A := âŸ¨fun a => by\n  ext X\n  dsimp\n  rw [â† cancel_epi (e.hom.app (XâŸ¦aâŸ§)), e.hom_inv_id_app_assoc, â† shift_app_comm_assoc,\n    â† Functor.map_comp, e.hom_inv_id_app, Functor.map_id, Category.comp_id]âŸ©\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.of_isIso","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¸ : CategoryTheory.Category.{u_7, u_1} C\ninstâœâ· : CategoryTheory.Category.{u_6, u_2} D\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nA : Type u_5\ninstâœâ¶ : AddMonoid A\ninstâœâµ : CategoryTheory.HasShift C A\ninstâœâ´ : CategoryTheory.HasShift D A\ninstâœÂ³ : Fâ‚.CommShift A\ninstâœÂ² : Fâ‚‚.CommShift A\ninstâœÂ¹ : CategoryTheory.IsIso Ï„\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\nâŠ¢ CategoryTheory.NatTrans.CommShift (CategoryTheory.inv Ï„) A","decl":"lemma of_isIso [IsIso Ï„] [NatTrans.CommShift Ï„ A] :\n    NatTrans.CommShift (inv Ï„) A := by\n  haveI : NatTrans.CommShift (asIso Ï„).hom A := by assumption\n  change NatTrans.CommShift (asIso Ï„).inv A\n  infer_instance\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.id","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_7, u_2} D\nFâ‚ : CategoryTheory.Functor C D\nA : Type u_5\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : Fâ‚.CommShift A\nâŠ¢ CategoryTheory.NatTrans.CommShift (CategoryTheory.CategoryStruct.id Fâ‚) A","decl":"variable (Fâ‚) in\ninstance id : NatTrans.CommShift (ğŸ™ Fâ‚) A where\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.comp","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¹ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ¸ : CategoryTheory.Category.{u_7, u_2} D\nFâ‚ Fâ‚‚ Fâ‚ƒ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nÏ„' : Quiver.Hom Fâ‚‚ Fâ‚ƒ\nA : Type u_5\ninstâœâ· : AddMonoid A\ninstâœâ¶ : CategoryTheory.HasShift C A\ninstâœâµ : CategoryTheory.HasShift D A\ninstâœâ´ : Fâ‚.CommShift A\ninstâœÂ³ : Fâ‚‚.CommShift A\ninstâœÂ² : Fâ‚ƒ.CommShift A\ninstâœÂ¹ : CategoryTheory.NatTrans.CommShift Ï„ A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„' A\nâŠ¢ CategoryTheory.NatTrans.CommShift (CategoryTheory.CategoryStruct.comp Ï„ Ï„') A","decl":"instance comp [NatTrans.CommShift Ï„ A] [NatTrans.CommShift Ï„' A] :\n    NatTrans.CommShift (Ï„ â‰« Ï„') A where\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.whiskerRight","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœÂ¹â° : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ¹ : CategoryTheory.Category.{u_7, u_2} D\ninstâœâ¸ : CategoryTheory.Category.{u_8, u_3} E\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C D\nÏ„ : Quiver.Hom Fâ‚ Fâ‚‚\nG : CategoryTheory.Functor D E\nA : Type u_5\ninstâœâ· : AddMonoid A\ninstâœâ¶ : CategoryTheory.HasShift C A\ninstâœâµ : CategoryTheory.HasShift D A\ninstâœâ´ : CategoryTheory.HasShift E A\ninstâœÂ³ : Fâ‚.CommShift A\ninstâœÂ² : Fâ‚‚.CommShift A\ninstâœÂ¹ : G.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„ A\nâŠ¢ CategoryTheory.NatTrans.CommShift (CategoryTheory.whiskerRight Ï„ G) A","decl":"instance whiskerRight [NatTrans.CommShift Ï„ A] :\n    NatTrans.CommShift (whiskerRight Ï„ G) A := âŸ¨fun a => by\n  ext X\n  simp only [whiskerRight_twice, comp_app,\n    whiskerRight_app, Functor.comp_map, whiskerLeft_app,\n    Functor.commShiftIso_comp_hom_app, Category.assoc,\n    â† Functor.commShiftIso_hom_naturality,\n    â† G.map_comp_assoc, shift_app_comm]âŸ©\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.whiskerLeft","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœÂ¹â° : CategoryTheory.Category.{u_8, u_1} C\ninstâœâ¹ : CategoryTheory.Category.{u_6, u_2} D\ninstâœâ¸ : CategoryTheory.Category.{u_7, u_3} E\nFâ‚ : CategoryTheory.Functor C D\nG G' : CategoryTheory.Functor D E\nÏ„'' : Quiver.Hom G G'\nA : Type u_5\ninstâœâ· : AddMonoid A\ninstâœâ¶ : CategoryTheory.HasShift C A\ninstâœâµ : CategoryTheory.HasShift D A\ninstâœâ´ : CategoryTheory.HasShift E A\ninstâœÂ³ : Fâ‚.CommShift A\ninstâœÂ² : G.CommShift A\ninstâœÂ¹ : G'.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift Ï„'' A\nâŠ¢ CategoryTheory.NatTrans.CommShift (CategoryTheory.whiskerLeft Fâ‚ Ï„'') A","decl":"instance whiskerLeft [NatTrans.CommShift Ï„'' A] :\n    NatTrans.CommShift (whiskerLeft Fâ‚ Ï„'') A where\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.associator","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nJ : Type u_4\ninstâœÂ¹Â¹ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ¹â° : CategoryTheory.Category.{u_9, u_2} D\ninstâœâ¹ : CategoryTheory.Category.{u_8, u_3} E\ninstâœâ¸ : CategoryTheory.Category.{u_7, u_4} J\nFâ‚ : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nH : CategoryTheory.Functor E J\nA : Type u_5\ninstâœâ· : AddMonoid A\ninstâœâ¶ : CategoryTheory.HasShift C A\ninstâœâµ : CategoryTheory.HasShift D A\ninstâœâ´ : CategoryTheory.HasShift E A\ninstâœÂ³ : CategoryTheory.HasShift J A\ninstâœÂ² : Fâ‚.CommShift A\ninstâœÂ¹ : G.CommShift A\ninstâœ : H.CommShift A\nâŠ¢ CategoryTheory.NatTrans.CommShift (Fâ‚.associator G H).hom A","decl":"instance associator : CommShift (Functor.associator Fâ‚ G H).hom A where\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.leftUnitor","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_7, u_2} D\nFâ‚ : CategoryTheory.Functor C D\nA : Type u_5\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : Fâ‚.CommShift A\nâŠ¢ CategoryTheory.NatTrans.CommShift Fâ‚.leftUnitor.hom A","decl":"instance leftUnitor : CommShift Fâ‚.leftUnitor.hom A where\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.rightUnitor","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_7, u_2} D\nFâ‚ : CategoryTheory.Functor C D\nA : Type u_5\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : Fâ‚.CommShift A\nâŠ¢ CategoryTheory.NatTrans.CommShift Fâ‚.rightUnitor.hom A","decl":"instance rightUnitor : CommShift Fâ‚.rightUnitor.hom A where\n\n"}
{"name":"CategoryTheory.Functor.CommShift.ofIso_compatibility","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nF G : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F G\nA : Type u_4\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift C A\ninstâœÂ¹ : CategoryTheory.HasShift D A\ninstâœ : F.CommShift A\nâŠ¢ CategoryTheory.NatTrans.CommShift e.hom A","decl":"lemma ofIso_compatibility :\n    letI := ofIso e A\n    NatTrans.CommShift e.hom A := by\n  letI := ofIso e A\n  refine âŸ¨fun a => ?_âŸ©\n  dsimp [commShiftIso, ofIso]\n  rw [â† whiskerLeft_comp_assoc, e.hom_inv_id, whiskerLeft_id', id_comp]\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.verticalComposition","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"Câ‚ : Type u_1\nCâ‚‚ : Type u_2\nCâ‚ƒ : Type u_3\nDâ‚ : Type u_4\nDâ‚‚ : Type u_5\nDâ‚ƒ : Type u_6\ninstâœÂ²âµ : CategoryTheory.Category.{u_8, u_1} Câ‚\ninstâœÂ²â´ : CategoryTheory.Category.{u_9, u_2} Câ‚‚\ninstâœÂ²Â³ : CategoryTheory.Category.{u_10, u_3} Câ‚ƒ\ninstâœÂ²Â² : CategoryTheory.Category.{u_11, u_4} Dâ‚\ninstâœÂ²Â¹ : CategoryTheory.Category.{u_12, u_5} Dâ‚‚\ninstâœÂ²â° : CategoryTheory.Category.{u_13, u_6} Dâ‚ƒ\nFâ‚â‚‚ : CategoryTheory.Functor Câ‚ Câ‚‚\nFâ‚‚â‚ƒ : CategoryTheory.Functor Câ‚‚ Câ‚ƒ\nFâ‚â‚ƒ : CategoryTheory.Functor Câ‚ Câ‚ƒ\nÎ± : Quiver.Hom Fâ‚â‚ƒ (Fâ‚â‚‚.comp Fâ‚‚â‚ƒ)\nGâ‚â‚‚ : CategoryTheory.Functor Dâ‚ Dâ‚‚\nGâ‚‚â‚ƒ : CategoryTheory.Functor Dâ‚‚ Dâ‚ƒ\nGâ‚â‚ƒ : CategoryTheory.Functor Dâ‚ Dâ‚ƒ\nÎ² : Quiver.Hom (Gâ‚â‚‚.comp Gâ‚‚â‚ƒ) Gâ‚â‚ƒ\nLâ‚ : CategoryTheory.Functor Câ‚ Dâ‚\nLâ‚‚ : CategoryTheory.Functor Câ‚‚ Dâ‚‚\nLâ‚ƒ : CategoryTheory.Functor Câ‚ƒ Dâ‚ƒ\neâ‚â‚‚ : Quiver.Hom (Fâ‚â‚‚.comp Lâ‚‚) (Lâ‚.comp Gâ‚â‚‚)\neâ‚‚â‚ƒ : Quiver.Hom (Fâ‚‚â‚ƒ.comp Lâ‚ƒ) (Lâ‚‚.comp Gâ‚‚â‚ƒ)\neâ‚â‚ƒ : Quiver.Hom (Fâ‚â‚ƒ.comp Lâ‚ƒ) (Lâ‚.comp Gâ‚â‚ƒ)\nA : Type u_7\ninstâœÂ¹â¹ : AddMonoid A\ninstâœÂ¹â¸ : CategoryTheory.HasShift Câ‚ A\ninstâœÂ¹â· : CategoryTheory.HasShift Câ‚‚ A\ninstâœÂ¹â¶ : CategoryTheory.HasShift Câ‚ƒ A\ninstâœÂ¹âµ : CategoryTheory.HasShift Dâ‚ A\ninstâœÂ¹â´ : CategoryTheory.HasShift Dâ‚‚ A\ninstâœÂ¹Â³ : CategoryTheory.HasShift Dâ‚ƒ A\ninstâœÂ¹Â² : Fâ‚â‚‚.CommShift A\ninstâœÂ¹Â¹ : Fâ‚‚â‚ƒ.CommShift A\ninstâœÂ¹â° : Fâ‚â‚ƒ.CommShift A\ninstâœâ¹ : CategoryTheory.NatTrans.CommShift Î± A\ninstâœâ¸ : Gâ‚â‚‚.CommShift A\ninstâœâ· : Gâ‚‚â‚ƒ.CommShift A\ninstâœâ¶ : Gâ‚â‚ƒ.CommShift A\ninstâœâµ : CategoryTheory.NatTrans.CommShift Î² A\ninstâœâ´ : Lâ‚.CommShift A\ninstâœÂ³ : Lâ‚‚.CommShift A\ninstâœÂ² : Lâ‚ƒ.CommShift A\ninstâœÂ¹ : CategoryTheory.NatTrans.CommShift eâ‚â‚‚ A\ninstâœ : CategoryTheory.NatTrans.CommShift eâ‚‚â‚ƒ A\nhâ‚â‚ƒ : Eq eâ‚â‚ƒ (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight Î± Lâ‚ƒ) (CategoryTheory.CategoryStruct.comp (Fâ‚â‚‚.associator Fâ‚‚â‚ƒ Lâ‚ƒ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft Fâ‚â‚‚ eâ‚‚â‚ƒ) (CategoryTheory.CategoryStruct.comp (Fâ‚â‚‚.associator Lâ‚‚ Gâ‚‚â‚ƒ).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight eâ‚â‚‚ Gâ‚‚â‚ƒ) (CategoryTheory.CategoryStruct.comp (Lâ‚.associator Gâ‚â‚‚ Gâ‚‚â‚ƒ).hom (CategoryTheory.whiskerLeft Lâ‚ Î²)))))))\nâŠ¢ CategoryTheory.NatTrans.CommShift eâ‚â‚ƒ A","decl":"/--\nAssume that we have a diagram of categories\n```\nCâ‚ â¥¤ Dâ‚\nâ€–     â€–\nv     v\nCâ‚‚ â¥¤ Dâ‚‚\nâ€–     â€–\nv     v\nCâ‚ƒ â¥¤ Dâ‚ƒ\n```\nwith functors `Fâ‚â‚‚ : Câ‚ â¥¤ Câ‚‚`, `Fâ‚‚â‚ƒ : Câ‚‚ â¥¤ Câ‚ƒ` and `Fâ‚â‚ƒ : Câ‚ â¥¤ Câ‚ƒ` on the first\ncolumn that are related by a natural transformation `Î± : Fâ‚â‚ƒ âŸ¶ Fâ‚â‚‚ â‹™ Fâ‚‚â‚ƒ`\nand similarly `Î² : Gâ‚â‚‚ â‹™ Gâ‚‚â‚ƒ âŸ¶ Gâ‚â‚ƒ` on the second column. Assume that we have\nnatural transformations\n`eâ‚â‚‚ : Fâ‚â‚‚ â‹™ Lâ‚‚ âŸ¶ Lâ‚ â‹™ Gâ‚â‚‚` (top square), `eâ‚‚â‚ƒ : Fâ‚‚â‚ƒ â‹™ Lâ‚ƒ âŸ¶ Lâ‚‚ â‹™ Gâ‚‚â‚ƒ` (bottom square),\nand `eâ‚â‚ƒ : Fâ‚â‚ƒ â‹™ Lâ‚ƒ âŸ¶ Lâ‚ â‹™ Gâ‚â‚ƒ` (outer square), where the horizontal functors\nare denoted `Lâ‚`, `Lâ‚‚` and `Lâ‚ƒ`. Assume that `eâ‚â‚ƒ` is determined by the other\nnatural transformations `Î±`, `eâ‚‚â‚ƒ`, `eâ‚â‚‚` and `Î²`. Then, if all these categories\nare equipped with a shift by an additive monoid `A`, and all these functors commute with\nthese shifts, then the natural transformation `eâ‚â‚ƒ` of the outer square commutes with the\nshift if all `Î±`, `eâ‚‚â‚ƒ`, `eâ‚â‚‚` and `Î²` do. -/\nlemma NatTrans.CommShift.verticalComposition {Câ‚ Câ‚‚ Câ‚ƒ Dâ‚ Dâ‚‚ Dâ‚ƒ : Type*}\n    [Category Câ‚] [Category Câ‚‚] [Category Câ‚ƒ] [Category Dâ‚] [Category Dâ‚‚] [Category Dâ‚ƒ]\n    {Fâ‚â‚‚ : Câ‚ â¥¤ Câ‚‚} {Fâ‚‚â‚ƒ : Câ‚‚ â¥¤ Câ‚ƒ} {Fâ‚â‚ƒ : Câ‚ â¥¤ Câ‚ƒ} (Î± : Fâ‚â‚ƒ âŸ¶ Fâ‚â‚‚ â‹™ Fâ‚‚â‚ƒ)\n    {Gâ‚â‚‚ : Dâ‚ â¥¤ Dâ‚‚} {Gâ‚‚â‚ƒ : Dâ‚‚ â¥¤ Dâ‚ƒ} {Gâ‚â‚ƒ : Dâ‚ â¥¤ Dâ‚ƒ} (Î² : Gâ‚â‚‚ â‹™ Gâ‚‚â‚ƒ âŸ¶ Gâ‚â‚ƒ)\n    {Lâ‚ : Câ‚ â¥¤ Dâ‚} {Lâ‚‚ : Câ‚‚ â¥¤ Dâ‚‚} {Lâ‚ƒ : Câ‚ƒ â¥¤ Dâ‚ƒ}\n    (eâ‚â‚‚ : Fâ‚â‚‚ â‹™ Lâ‚‚ âŸ¶ Lâ‚ â‹™ Gâ‚â‚‚) (eâ‚‚â‚ƒ : Fâ‚‚â‚ƒ â‹™ Lâ‚ƒ âŸ¶ Lâ‚‚ â‹™ Gâ‚‚â‚ƒ) (eâ‚â‚ƒ : Fâ‚â‚ƒ â‹™ Lâ‚ƒ âŸ¶ Lâ‚ â‹™ Gâ‚â‚ƒ)\n    (A : Type*) [AddMonoid A] [HasShift Câ‚ A] [HasShift Câ‚‚ A] [HasShift Câ‚ƒ A]\n    [HasShift Dâ‚ A] [HasShift Dâ‚‚ A] [HasShift Dâ‚ƒ A]\n    [Fâ‚â‚‚.CommShift A] [Fâ‚‚â‚ƒ.CommShift A] [Fâ‚â‚ƒ.CommShift A] [CommShift Î± A]\n    [Gâ‚â‚‚.CommShift A] [Gâ‚‚â‚ƒ.CommShift A] [Gâ‚â‚ƒ.CommShift A] [CommShift Î² A]\n    [Lâ‚.CommShift A] [Lâ‚‚.CommShift A] [Lâ‚ƒ.CommShift A]\n    [CommShift eâ‚â‚‚ A] [CommShift eâ‚‚â‚ƒ A]\n    (hâ‚â‚ƒ : eâ‚â‚ƒ = CategoryTheory.whiskerRight Î± Lâ‚ƒ â‰« (Functor.associator _ _ _).hom â‰«\n      CategoryTheory.whiskerLeft Fâ‚â‚‚ eâ‚‚â‚ƒ â‰« (Functor.associator _ _ _).inv â‰«\n        CategoryTheory.whiskerRight eâ‚â‚‚ Gâ‚‚â‚ƒ â‰« (Functor.associator _ _ _).hom â‰«\n          CategoryTheory.whiskerLeft Lâ‚ Î²) : CommShift eâ‚â‚ƒ A := by\n  subst hâ‚â‚ƒ\n  infer_instance\n\n"}
