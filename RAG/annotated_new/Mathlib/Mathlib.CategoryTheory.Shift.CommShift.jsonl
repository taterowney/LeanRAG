{"name":"CategoryTheory.Functor.CommShift.isoZero_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\nX : C\n⊢ Eq ((CategoryTheory.Functor.CommShift.isoZero F A).hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorZero C A).hom.app X)) ((CategoryTheory.shiftFunctorZero D A).inv.app (F.obj X)))","decl":"/-- For any functor `F : C ⥤ D`, this is the obvious isomorphism\n`shiftFunctor C (0 : A) ⋙ F ≅ F ⋙ shiftFunctor D (0 : A)` deduced from the\nisomorphisms `shiftFunctorZero` on both categories `C` and `D`. -/\n@[simps!]\nnoncomputable def isoZero : shiftFunctor C (0 : A) ⋙ F ≅ F ⋙ shiftFunctor D (0 : A) :=\n  isoWhiskerRight (shiftFunctorZero C A) F ≪≫ F.leftUnitor ≪≫\n     F.rightUnitor.symm ≪≫ isoWhiskerLeft F (shiftFunctorZero D A).symm\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoZero_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\nX : C\n⊢ Eq ((CategoryTheory.Functor.CommShift.isoZero F A).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero D A).hom.app (F.obj X)) (F.map ((CategoryTheory.shiftFunctorZero C A).inv.app X)))","decl":"/-- For any functor `F : C ⥤ D`, this is the obvious isomorphism\n`shiftFunctor C (0 : A) ⋙ F ≅ F ⋙ shiftFunctor D (0 : A)` deduced from the\nisomorphisms `shiftFunctorZero` on both categories `C` and `D`. -/\n@[simps!]\nnoncomputable def isoZero : shiftFunctor C (0 : A) ⋙ F ≅ F ⋙ shiftFunctor D (0 : A) :=\n  isoWhiskerRight (shiftFunctorZero C A) F ≪≫ F.leftUnitor ≪≫\n     F.rightUnitor.symm ≪≫ isoWhiskerLeft F (shiftFunctorZero D A).symm\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoZero'_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\na : A\nha : Eq a 0\nX : C\n⊢ Eq ((CategoryTheory.Functor.CommShift.isoZero' F A a ha).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorZero' D a ha).hom.app (F.obj X)) (F.map ((CategoryTheory.shiftFunctorZero' C a ha).inv.app X)))","decl":"/-- For any functor `F : C ⥤ D` and any `a` in `A` such that `a = 0`,\nthis is the obvious isomorphism `shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a` deduced from the\nisomorphisms `shiftFunctorZero'` on both categories `C` and `D`. -/\n@[simps!]\nnoncomputable def isoZero' (a : A) (ha : a = 0) : shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a :=\n  isoWhiskerRight (shiftFunctorZero' C a ha) F ≪≫ F.leftUnitor ≪≫\n     F.rightUnitor.symm ≪≫ isoWhiskerLeft F (shiftFunctorZero' D a ha).symm\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoZero'_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\na : A\nha : Eq a 0\nX : C\n⊢ Eq ((CategoryTheory.Functor.CommShift.isoZero' F A a ha).hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorZero' C a ha).hom.app X)) ((CategoryTheory.shiftFunctorZero' D a ha).inv.app (F.obj X)))","decl":"/-- For any functor `F : C ⥤ D` and any `a` in `A` such that `a = 0`,\nthis is the obvious isomorphism `shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a` deduced from the\nisomorphisms `shiftFunctorZero'` on both categories `C` and `D`. -/\n@[simps!]\nnoncomputable def isoZero' (a : A) (ha : a = 0) : shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a :=\n  isoWhiskerRight (shiftFunctorZero' C a ha) F ≪≫ F.leftUnitor ≪≫\n     F.rightUnitor.symm ≪≫ isoWhiskerLeft F (shiftFunctorZero' D a ha).symm\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoZero'_eq_isoZero","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\n⊢ Eq (CategoryTheory.Functor.CommShift.isoZero' F A 0 ⋯) (CategoryTheory.Functor.CommShift.isoZero F A)","decl":"@[simp]\nlemma isoZero'_eq_isoZero : isoZero' F A 0 rfl = isoZero F A := by\n  ext; simp [isoZero', shiftFunctorZero']\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoAdd'_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\na b c : A\nh : Eq (HAdd.hAdd a b) c\ne₁ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne₂ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C b).comp F) (F.comp (CategoryTheory.shiftFunctor D b))\nX : C\n⊢ Eq ((CategoryTheory.Functor.CommShift.isoAdd' h e₁ e₂).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' D a b c h).hom.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map (e₁.inv.app X)) (CategoryTheory.CategoryStruct.comp (e₂.inv.app ((CategoryTheory.shiftFunctor C a).obj X)) (F.map ((CategoryTheory.shiftFunctorAdd' C a b c h).inv.app X)))))","decl":"/-- If a functor `F : C ⥤ D` is equipped with \"commutation isomorphisms\" with the\nshifts by `a` and `b`, then there is a commutation isomorphism with the shift by `c` when\n`a + b = c`. -/\n@[simps!]\nnoncomputable def isoAdd' {a b c : A} (h : a + b = c)\n    (e₁ : shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a)\n    (e₂ : shiftFunctor C b ⋙ F ≅ F ⋙ shiftFunctor D b) :\n    shiftFunctor C c ⋙ F ≅ F ⋙ shiftFunctor D c :=\n  isoWhiskerRight (shiftFunctorAdd' C _ _ _ h) F ≪≫ Functor.associator _ _ _ ≪≫\n    isoWhiskerLeft _ e₂ ≪≫ (Functor.associator _ _ _).symm ≪≫ isoWhiskerRight e₁ _ ≪≫\n      Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ (shiftFunctorAdd' D _ _ _ h).symm\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoAdd'_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\na b c : A\nh : Eq (HAdd.hAdd a b) c\ne₁ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne₂ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C b).comp F) (F.comp (CategoryTheory.shiftFunctor D b))\nX : C\n⊢ Eq ((CategoryTheory.Functor.CommShift.isoAdd' h e₁ e₂).hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorAdd' C a b c h).hom.app X)) (CategoryTheory.CategoryStruct.comp (e₂.hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map (e₁.hom.app X)) ((CategoryTheory.shiftFunctorAdd' D a b c h).inv.app (F.obj X)))))","decl":"/-- If a functor `F : C ⥤ D` is equipped with \"commutation isomorphisms\" with the\nshifts by `a` and `b`, then there is a commutation isomorphism with the shift by `c` when\n`a + b = c`. -/\n@[simps!]\nnoncomputable def isoAdd' {a b c : A} (h : a + b = c)\n    (e₁ : shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a)\n    (e₂ : shiftFunctor C b ⋙ F ≅ F ⋙ shiftFunctor D b) :\n    shiftFunctor C c ⋙ F ≅ F ⋙ shiftFunctor D c :=\n  isoWhiskerRight (shiftFunctorAdd' C _ _ _ h) F ≪≫ Functor.associator _ _ _ ≪≫\n    isoWhiskerLeft _ e₂ ≪≫ (Functor.associator _ _ _).symm ≪≫ isoWhiskerRight e₁ _ ≪≫\n      Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ (shiftFunctorAdd' D _ _ _ h).symm\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoAdd_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\na b : A\ne₁ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne₂ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C b).comp F) (F.comp (CategoryTheory.shiftFunctor D b))\nX : C\n⊢ Eq ((CategoryTheory.Functor.CommShift.isoAdd e₁ e₂).hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorAdd C a b).hom.app X)) (CategoryTheory.CategoryStruct.comp (e₂.hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map (e₁.hom.app X)) ((CategoryTheory.shiftFunctorAdd D a b).inv.app (F.obj X)))))","decl":"@[simp]\nlemma isoAdd_hom_app {a b : A}\n    (e₁ : shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a)\n    (e₂ : shiftFunctor C b ⋙ F ≅ F ⋙ shiftFunctor D b) (X : C) :\n      (CommShift.isoAdd e₁ e₂).hom.app X =\n        F.map ((shiftFunctorAdd C a b).hom.app X) ≫ e₂.hom.app ((shiftFunctor C a).obj X) ≫\n          (shiftFunctor D b).map (e₁.hom.app X) ≫ (shiftFunctorAdd D a b).inv.app (F.obj X) := by\n  simp only [isoAdd, isoAdd'_hom_app, shiftFunctorAdd'_eq_shiftFunctorAdd]\n\n"}
{"name":"CategoryTheory.Functor.CommShift.isoAdd_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\na b : A\ne₁ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C a).comp F) (F.comp (CategoryTheory.shiftFunctor D a))\ne₂ : CategoryTheory.Iso ((CategoryTheory.shiftFunctor C b).comp F) (F.comp (CategoryTheory.shiftFunctor D b))\nX : C\n⊢ Eq ((CategoryTheory.Functor.CommShift.isoAdd e₁ e₂).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd D a b).hom.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map (e₁.inv.app X)) (CategoryTheory.CategoryStruct.comp (e₂.inv.app ((CategoryTheory.shiftFunctor C a).obj X)) (F.map ((CategoryTheory.shiftFunctorAdd C a b).inv.app X)))))","decl":"@[simp]\nlemma isoAdd_inv_app {a b : A}\n    (e₁ : shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a)\n    (e₂ : shiftFunctor C b ⋙ F ≅ F ⋙ shiftFunctor D b) (X : C) :\n      (CommShift.isoAdd e₁ e₂).inv.app X = (shiftFunctorAdd D a b).hom.app (F.obj X) ≫\n        (shiftFunctor D b).map (e₁.inv.app X) ≫ e₂.inv.app ((shiftFunctor C a).obj X) ≫\n        F.map ((shiftFunctorAdd C a b).inv.app X) := by\n  simp only [isoAdd, isoAdd'_inv_app, shiftFunctorAdd'_eq_shiftFunctorAdd]\n\n"}
{"name":"CategoryTheory.Functor.CommShift.zero","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\nself : F.CommShift A\n⊢ Eq (CategoryTheory.Functor.CommShift.iso 0) (CategoryTheory.Functor.CommShift.isoZero F A)","decl":"/-- A functor `F` commutes with the shift by a monoid `A` if it is equipped with\ncommutation isomorphisms with the shifts by all `a : A`, and these isomorphisms\nsatisfy coherence properties with respect to `0 : A` and the addition in `A`. -/\nclass CommShift where\n  iso (a : A) : shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a\n  zero : iso 0 = CommShift.isoZero F A := by aesop_cat\n  add (a b : A) : iso (a + b) = CommShift.isoAdd (iso a) (iso b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.CommShift.add","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : CategoryTheory.HasShift D A\nself : F.CommShift A\na b : A\n⊢ Eq (CategoryTheory.Functor.CommShift.iso (HAdd.hAdd a b)) (CategoryTheory.Functor.CommShift.isoAdd (CategoryTheory.Functor.CommShift.iso a) (CategoryTheory.Functor.CommShift.iso b))","decl":"/-- A functor `F` commutes with the shift by a monoid `A` if it is equipped with\ncommutation isomorphisms with the shifts by all `a : A`, and these isomorphisms\nsatisfy coherence properties with respect to `0 : A` and the addition in `A`. -/\nclass CommShift where\n  iso (a : A) : shiftFunctor C a ⋙ F ≅ F ⋙ shiftFunctor D a\n  zero : iso 0 = CommShift.isoZero F A := by aesop_cat\n  add (a b : A) : iso (a + b) = CommShift.isoAdd (iso a) (iso b) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_hom_naturality","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\nX Y : C\nf : Quiver.Hom X Y\na : A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map f)) ((F.commShiftIso a).hom.app Y)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).hom.app X) ((CategoryTheory.shiftFunctor D a).map (F.map f)))","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_hom_naturality {X Y : C} (f : X ⟶ Y) (a : A) :\n    F.map (f⟦a⟧') ≫ (F.commShiftIso a).hom.app Y =\n      (F.commShiftIso a).hom.app X ≫ (F.map f)⟦a⟧' :=\n  (F.commShiftIso a).hom.naturality f\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\nX Y : C\nf : Quiver.Hom X Y\na : A\nZ : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj (F.obj Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map f)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).hom.app Y) h)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map f)) h))","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_hom_naturality {X Y : C} (f : X ⟶ Y) (a : A) :\n    F.map (f⟦a⟧') ≫ (F.commShiftIso a).hom.app Y =\n      (F.commShiftIso a).hom.app X ≫ (F.map f)⟦a⟧' :=\n  (F.commShiftIso a).hom.naturality f\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_inv_naturality","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\nX Y : C\nf : Quiver.Hom X Y\na : A\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map f)) ((F.commShiftIso a).inv.app Y)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app X) (F.map ((CategoryTheory.shiftFunctor C a).map f)))","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_inv_naturality {X Y : C} (f : X ⟶ Y) (a : A) :\n    (F.map f)⟦a⟧' ≫ (F.commShiftIso a).inv.app Y =\n      (F.commShiftIso a).inv.app X ≫ F.map (f⟦a⟧') :=\n  (F.commShiftIso a).inv.naturality f\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\nX Y : C\nf : Quiver.Hom X Y\na : A\nZ : D\nh : Quiver.Hom (F.obj ((CategoryTheory.shiftFunctor C a).obj Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (F.map f)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app Y) h)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor C a).map f)) h))","decl":"@[reassoc (attr := simp)]\nlemma commShiftIso_inv_naturality {X Y : C} (f : X ⟶ Y) (a : A) :\n    (F.map f)⟦a⟧' ≫ (F.commShiftIso a).inv.app Y =\n      (F.commShiftIso a).inv.app X ≫ F.map (f⟦a⟧') :=\n  (F.commShiftIso a).inv.naturality f\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_zero","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\n⊢ Eq (F.commShiftIso 0) (CategoryTheory.Functor.CommShift.isoZero F A)","decl":"lemma commShiftIso_zero :\n    F.commShiftIso (0 : A) = CommShift.isoZero F A :=\n  CommShift.zero\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_zero'","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\na : A\nh : Eq a 0\n⊢ Eq (F.commShiftIso a) (CategoryTheory.Functor.CommShift.isoZero' F A a h)","decl":"set_option linter.docPrime false in\nlemma commShiftIso_zero' (a : A) (h : a = 0) :\n    F.commShiftIso a = CommShift.isoZero' F A a h := by\n  subst h; rw [CommShift.isoZero'_eq_isoZero, commShiftIso_zero]\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_add","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\na b : A\n⊢ Eq (F.commShiftIso (HAdd.hAdd a b)) (CategoryTheory.Functor.CommShift.isoAdd (F.commShiftIso a) (F.commShiftIso b))","decl":"lemma commShiftIso_add (a b : A) :\n    F.commShiftIso (a + b) = CommShift.isoAdd (F.commShiftIso a) (F.commShiftIso b) :=\n  CommShift.add a b\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_add'","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\na b c : A\nh : Eq (HAdd.hAdd a b) c\n⊢ Eq (F.commShiftIso c) (CategoryTheory.Functor.CommShift.isoAdd' h (F.commShiftIso a) (F.commShiftIso b))","decl":"lemma commShiftIso_add' {a b c : A} (h : a + b = c) :\n    F.commShiftIso c = CommShift.isoAdd' h (F.commShiftIso a) (F.commShiftIso b) := by\n  subst h\n  simp only [commShiftIso_add, CommShift.isoAdd]\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_id_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\nA : Type u_4\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na : A\nX : C\n⊢ Eq (((CategoryTheory.Functor.id C).commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.id (((CategoryTheory.shiftFunctor C a).comp (CategoryTheory.Functor.id C)).obj X))","decl":"@[simp]\nlemma commShiftIso_id_hom_app (a : A) (X : C) :\n    (commShiftIso (𝟭 C) a).hom.app X = 𝟙 _ := comp_id _\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_id_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\nA : Type u_4\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\na : A\nX : C\n⊢ Eq (((CategoryTheory.Functor.id C).commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.id C).comp (CategoryTheory.shiftFunctor C a)).obj X))","decl":"@[simp]\nlemma commShiftIso_id_inv_app (a : A) (X : C) :\n    (commShiftIso (𝟭 C) a).inv.app X = 𝟙 _ := comp_id _\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_comp_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_7, u_2} D\ninst✝⁶ : CategoryTheory.Category.{u_8, u_3} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nA : Type u_4\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : CategoryTheory.HasShift E A\ninst✝¹ : F.CommShift A\ninst✝ : G.CommShift A\na : A\nX : C\n⊢ Eq (((F.comp G).commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp (G.map ((F.commShiftIso a).hom.app X)) ((G.commShiftIso a).hom.app (F.obj X)))","decl":"lemma commShiftIso_comp_hom_app [F.CommShift A] [G.CommShift A] (a : A) (X : C) :\n    (commShiftIso (F ⋙ G) a).hom.app X =\n      G.map ((commShiftIso F a).hom.app X) ≫ (commShiftIso G a).hom.app (F.obj X) := by\n  simp [commShiftIso, CommShift.iso]\n\n"}
{"name":"CategoryTheory.Functor.commShiftIso_comp_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_7, u_2} D\ninst✝⁶ : CategoryTheory.Category.{u_8, u_3} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nA : Type u_4\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : CategoryTheory.HasShift E A\ninst✝¹ : F.CommShift A\ninst✝ : G.CommShift A\na : A\nX : C\n⊢ Eq (((F.comp G).commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.comp ((G.commShiftIso a).inv.app (F.obj X)) (G.map ((F.commShiftIso a).inv.app X)))","decl":"lemma commShiftIso_comp_inv_app [F.CommShift A] [G.CommShift A] (a : A) (X : C) :\n    (commShiftIso (F ⋙ G) a).inv.app X =\n      (commShiftIso G a).inv.app (F.obj X) ≫ G.map ((commShiftIso F a).inv.app X) := by\n  simp [commShiftIso, CommShift.iso]\n\n"}
{"name":"CategoryTheory.Functor.map_shiftFunctorComm_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nB : Type u_5\ninst✝³ : AddCommMonoid B\ninst✝² : CategoryTheory.HasShift C B\ninst✝¹ : CategoryTheory.HasShift D B\ninst✝ : F.CommShift B\nX : C\na b : B\n⊢ Eq (F.map ((CategoryTheory.shiftFunctorComm C a b).hom.app X)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso b).hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorComm D a b).hom.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map ((F.commShiftIso b).inv.app X)) ((F.commShiftIso a).inv.app ((CategoryTheory.shiftFunctor C b).obj X))))))","decl":"lemma map_shiftFunctorComm_hom_app [F.CommShift B] (X : C) (a b : B) :\n    F.map ((shiftFunctorComm C a b).hom.app X) = (F.commShiftIso b).hom.app (X⟦a⟧) ≫\n      ((F.commShiftIso a).hom.app X)⟦b⟧' ≫ (shiftFunctorComm D a b).hom.app (F.obj X) ≫\n      ((F.commShiftIso b).inv.app X)⟦a⟧' ≫ (F.commShiftIso a).inv.app (X⟦b⟧) := by\n  have eq := NatTrans.congr_app (congr_arg Iso.hom (F.commShiftIso_add a b)) X\n  simp only [comp_obj, CommShift.isoAdd_hom_app,\n    ← cancel_epi (F.map ((shiftFunctorAdd C a b).inv.app X)), Category.assoc,\n    ← F.map_comp_assoc, Iso.inv_hom_id_app, F.map_id, Category.id_comp, F.map_comp] at eq\n  simp only [shiftFunctorComm_eq D a b _ rfl]\n  dsimp\n  simp only [Functor.map_comp, shiftFunctorAdd'_eq_shiftFunctorAdd, Category.assoc,\n    ← reassoc_of% eq, shiftFunctorComm_eq C a b _ rfl]\n  dsimp\n  rw [Functor.map_comp]\n  simp only [NatTrans.congr_app (congr_arg Iso.hom (F.commShiftIso_add' (add_comm b a))) X,\n    CommShift.isoAdd'_hom_app, Category.assoc, Iso.inv_hom_id_app_assoc,\n    ← Functor.map_comp_assoc, Iso.hom_inv_id_app,\n    Functor.map_id, Category.id_comp, comp_obj, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Functor.map_shiftFunctorCompIsoId_hom_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\nX : C\na b : A\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq (F.map ((CategoryTheory.shiftFunctorCompIsoId C a b h).hom.app X)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso b).hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).hom.app X)) ((CategoryTheory.shiftFunctorCompIsoId D a b h).hom.app (F.obj X))))","decl":"@[simp, reassoc]\nlemma map_shiftFunctorCompIsoId_hom_app [F.CommShift A] (X : C) (a b : A) (h : a + b = 0) :\n    F.map ((shiftFunctorCompIsoId C a b h).hom.app X) =\n      (F.commShiftIso b).hom.app (X⟦a⟧) ≫ ((F.commShiftIso a).hom.app X)⟦b⟧' ≫\n        (shiftFunctorCompIsoId D a b h).hom.app (F.obj X) := by\n  dsimp [shiftFunctorCompIsoId]\n  have eq := NatTrans.congr_app (congr_arg Iso.hom (F.commShiftIso_add' h)) X\n  simp only [commShiftIso_zero, comp_obj, CommShift.isoZero_hom_app,\n    CommShift.isoAdd'_hom_app] at eq\n  rw [← cancel_epi (F.map ((shiftFunctorAdd' C a b 0 h).hom.app X)), ← reassoc_of% eq, F.map_comp]\n  simp only [Iso.inv_hom_id_app, id_obj, Category.comp_id, ← F.map_comp_assoc, Iso.hom_inv_id_app,\n    F.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Functor.map_shiftFunctorCompIsoId_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\nX : C\na b : A\nh✝ : Eq (HAdd.hAdd a b) 0\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorCompIsoId C a b h✝).hom.app X)) h) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso b).hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).hom.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId D a b h✝).hom.app (F.obj X)) h)))","decl":"@[simp, reassoc]\nlemma map_shiftFunctorCompIsoId_hom_app [F.CommShift A] (X : C) (a b : A) (h : a + b = 0) :\n    F.map ((shiftFunctorCompIsoId C a b h).hom.app X) =\n      (F.commShiftIso b).hom.app (X⟦a⟧) ≫ ((F.commShiftIso a).hom.app X)⟦b⟧' ≫\n        (shiftFunctorCompIsoId D a b h).hom.app (F.obj X) := by\n  dsimp [shiftFunctorCompIsoId]\n  have eq := NatTrans.congr_app (congr_arg Iso.hom (F.commShiftIso_add' h)) X\n  simp only [commShiftIso_zero, comp_obj, CommShift.isoZero_hom_app,\n    CommShift.isoAdd'_hom_app] at eq\n  rw [← cancel_epi (F.map ((shiftFunctorAdd' C a b 0 h).hom.app X)), ← reassoc_of% eq, F.map_comp]\n  simp only [Iso.inv_hom_id_app, id_obj, Category.comp_id, ← F.map_comp_assoc, Iso.hom_inv_id_app,\n    F.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Functor.map_shiftFunctorCompIsoId_inv_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\nX : C\na b : A\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq (F.map ((CategoryTheory.shiftFunctorCompIsoId C a b h).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId D a b h).inv.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).inv.app X)) ((F.commShiftIso b).inv.app ((CategoryTheory.shiftFunctor C a).obj X))))","decl":"@[simp, reassoc]\nlemma map_shiftFunctorCompIsoId_inv_app [F.CommShift A] (X : C) (a b : A) (h : a + b = 0) :\n    F.map ((shiftFunctorCompIsoId C a b h).inv.app X) =\n      (shiftFunctorCompIsoId D a b h).inv.app (F.obj X) ≫\n        ((F.commShiftIso a).inv.app X)⟦b⟧' ≫ (F.commShiftIso b).inv.app (X⟦a⟧) := by\n  rw [← cancel_epi (F.map ((shiftFunctorCompIsoId C a b h).hom.app X)), ← F.map_comp,\n    Iso.hom_inv_id_app, F.map_id, map_shiftFunctorCompIsoId_hom_app]\n  simp only [comp_obj, id_obj, Category.assoc, Iso.hom_inv_id_app_assoc,\n    ← Functor.map_comp_assoc, Iso.hom_inv_id_app, Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.Functor.map_shiftFunctorCompIsoId_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} D\nF : CategoryTheory.Functor C D\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\nX : C\na b : A\nh✝ : Eq (HAdd.hAdd a b) 0\nZ : D\nh : Quiver.Hom (F.obj ((CategoryTheory.shiftFunctor C b).obj ((CategoryTheory.shiftFunctor C a).obj X))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctorCompIsoId C a b h✝).inv.app X)) h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorCompIsoId D a b h✝).inv.app (F.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D b).map ((F.commShiftIso a).inv.app X)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso b).inv.app ((CategoryTheory.shiftFunctor C a).obj X)) h)))","decl":"@[simp, reassoc]\nlemma map_shiftFunctorCompIsoId_inv_app [F.CommShift A] (X : C) (a b : A) (h : a + b = 0) :\n    F.map ((shiftFunctorCompIsoId C a b h).inv.app X) =\n      (shiftFunctorCompIsoId D a b h).inv.app (F.obj X) ≫\n        ((F.commShiftIso a).inv.app X)⟦b⟧' ≫ (F.commShiftIso b).inv.app (X⟦a⟧) := by\n  rw [← cancel_epi (F.map ((shiftFunctorCompIsoId C a b h).hom.app X)), ← F.map_comp,\n    Iso.hom_inv_id_app, F.map_id, map_shiftFunctorCompIsoId_hom_app]\n  simp only [comp_obj, id_obj, Category.assoc, Iso.hom_inv_id_app_assoc,\n    ← Functor.map_comp_assoc, Iso.hom_inv_id_app, Functor.map_id, Category.id_comp]\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.shift_comm","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_7, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁴ : AddMonoid A\ninst✝³ : CategoryTheory.HasShift C A\ninst✝² : CategoryTheory.HasShift D A\ninst✝¹ : F₁.CommShift A\ninst✝ : F₂.CommShift A\nself : CategoryTheory.NatTrans.CommShift τ A\na : A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F₁.commShiftIso a).hom (CategoryTheory.whiskerRight τ (CategoryTheory.shiftFunctor D a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (CategoryTheory.shiftFunctor C a) τ) (F₂.commShiftIso a).hom)","decl":"/-- If `τ : F₁ ⟶ F₂` is a natural transformation between two functors\nwhich commute with a shift by an additive monoid `A`, this typeclass\nasserts a compatibility of `τ` with these shifts. -/\nclass CommShift : Prop where\n  shift_comm (a : A) : (F₁.commShiftIso a).hom ≫ whiskerRight τ _ =\n    whiskerLeft _ τ ≫ (F₂.commShiftIso a).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.NatTrans.shift_comm","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\na : A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F₁.commShiftIso a).hom (CategoryTheory.whiskerRight τ (CategoryTheory.shiftFunctor D a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (CategoryTheory.shiftFunctor C a) τ) (F₂.commShiftIso a).hom)","decl":"@[reassoc]\nlemma shift_comm (a : A) :\n    (F₁.commShiftIso a).hom ≫ whiskerRight τ _ =\n      whiskerLeft _ τ ≫ (F₂.commShiftIso a).hom := by\n  apply CommShift.shift_comm\n\n"}
{"name":"CategoryTheory.NatTrans.shift_comm_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\na : A\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (F₂.comp (CategoryTheory.shiftFunctor D a)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F₁.commShiftIso a).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight τ (CategoryTheory.shiftFunctor D a)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (CategoryTheory.shiftFunctor C a) τ) (CategoryTheory.CategoryStruct.comp (F₂.commShiftIso a).hom h))","decl":"@[reassoc]\nlemma shift_comm (a : A) :\n    (F₁.commShiftIso a).hom ≫ whiskerRight τ _ =\n      whiskerLeft _ τ ≫ (F₂.commShiftIso a).hom := by\n  apply CommShift.shift_comm\n\n"}
{"name":"CategoryTheory.NatTrans.shift_app_comm","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\na : A\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F₁.commShiftIso a).hom.app X) ((CategoryTheory.shiftFunctor D a).map (τ.app X))) (CategoryTheory.CategoryStruct.comp (τ.app ((CategoryTheory.shiftFunctor C a).obj X)) ((F₂.commShiftIso a).hom.app X))","decl":"@[reassoc]\nlemma shift_app_comm (a : A) (X : C) :\n    (F₁.commShiftIso a).hom.app X ≫ (τ.app X)⟦a⟧' =\n      τ.app (X⟦a⟧) ≫ (F₂.commShiftIso a).hom.app X :=\n  congr_app (shift_comm τ a) X\n\n"}
{"name":"CategoryTheory.NatTrans.shift_app_comm_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\na : A\nX : C\nZ : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj (F₂.obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F₁.commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (τ.app X)) h)) (CategoryTheory.CategoryStruct.comp (τ.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((F₂.commShiftIso a).hom.app X) h))","decl":"@[reassoc]\nlemma shift_app_comm (a : A) (X : C) :\n    (F₁.commShiftIso a).hom.app X ≫ (τ.app X)⟦a⟧' =\n      τ.app (X⟦a⟧) ≫ (F₂.commShiftIso a).hom.app X :=\n  congr_app (shift_comm τ a) X\n\n"}
{"name":"CategoryTheory.NatTrans.shift_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\na : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctor D a).map (τ.app X)) (CategoryTheory.CategoryStruct.comp ((F₁.commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.comp (τ.app ((CategoryTheory.shiftFunctor C a).obj X)) ((F₂.commShiftIso a).hom.app X)))","decl":"@[reassoc]\nlemma shift_app (a : A) (X : C) :\n    (τ.app X)⟦a⟧' = (F₁.commShiftIso a).inv.app X ≫\n      τ.app (X⟦a⟧) ≫ (F₂.commShiftIso a).hom.app X := by\n  rw [← shift_app_comm, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.NatTrans.shift_app_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\na : A\nX : C\nZ : D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor D a).obj (F₂.obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (τ.app X)) h) (CategoryTheory.CategoryStruct.comp ((F₁.commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.comp (τ.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((F₂.commShiftIso a).hom.app X) h)))","decl":"@[reassoc]\nlemma shift_app (a : A) (X : C) :\n    (τ.app X)⟦a⟧' = (F₁.commShiftIso a).inv.app X ≫\n      τ.app (X⟦a⟧) ≫ (F₂.commShiftIso a).hom.app X := by\n  rw [← shift_app_comm, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.NatTrans.app_shift_assoc","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\na : A\nX : C\nZ : D\nh : Quiver.Hom (F₂.obj ((CategoryTheory.shiftFunctor C a).obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (τ.app ((CategoryTheory.shiftFunctor C a).obj X)) h) (CategoryTheory.CategoryStruct.comp ((F₁.commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (τ.app X)) (CategoryTheory.CategoryStruct.comp ((F₂.commShiftIso a).inv.app X) h)))","decl":"@[reassoc]\nlemma app_shift (a : A) (X : C) :\n    τ.app (X⟦a⟧) = (F₁.commShiftIso a).hom.app X ≫ (τ.app X)⟦a⟧' ≫\n      (F₂.commShiftIso a).inv.app X := by\n  simp [shift_app_comm_assoc τ a X]\n\n"}
{"name":"CategoryTheory.NatTrans.app_shift","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\na : A\nX : C\n⊢ Eq (τ.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((F₁.commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (τ.app X)) ((F₂.commShiftIso a).inv.app X)))","decl":"@[reassoc]\nlemma app_shift (a : A) (X : C) :\n    τ.app (X⟦a⟧) = (F₁.commShiftIso a).hom.app X ≫ (τ.app X)⟦a⟧' ≫\n      (F₂.commShiftIso a).inv.app X := by\n  simp [shift_app_comm_assoc τ a X]\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.comm'","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\na : A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F₁.commShiftIso a).hom (CategoryTheory.whiskerRight τ (CategoryTheory.shiftFunctor D a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (CategoryTheory.shiftFunctor C a) τ) (F₂.commShiftIso a).hom)","decl":"@[deprecated (since := \"2024-12-31\")] alias CommShift.comm' := shift_comm\n"}
{"name":"CategoryTheory.NatTrans.CommShift.comm","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\na : A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F₁.commShiftIso a).hom (CategoryTheory.whiskerRight τ (CategoryTheory.shiftFunctor D a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (CategoryTheory.shiftFunctor C a) τ) (F₂.commShiftIso a).hom)","decl":"@[deprecated (since := \"2024-12-31\")] alias CommShift.comm := shift_comm\n"}
{"name":"CategoryTheory.NatTrans.CommShift.comm_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\na : A\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F₁.commShiftIso a).hom.app X) ((CategoryTheory.shiftFunctor D a).map (τ.app X))) (CategoryTheory.CategoryStruct.comp (τ.app ((CategoryTheory.shiftFunctor C a).obj X)) ((F₂.commShiftIso a).hom.app X))","decl":"@[deprecated (since := \"2024-12-31\")] alias CommShift.comm_app := shift_app_comm\n"}
{"name":"CategoryTheory.NatTrans.CommShift.shift_app","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\na : A\nX : C\n⊢ Eq ((CategoryTheory.shiftFunctor D a).map (τ.app X)) (CategoryTheory.CategoryStruct.comp ((F₁.commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.comp (τ.app ((CategoryTheory.shiftFunctor C a).obj X)) ((F₂.commShiftIso a).hom.app X)))","decl":"@[deprecated (since := \"2024-12-31\")] alias CommShift.shift_app := shift_app\n"}
{"name":"CategoryTheory.NatTrans.CommShift.app_shift","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\na : A\nX : C\n⊢ Eq (τ.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((F₁.commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D a).map (τ.app X)) ((F₂.commShiftIso a).inv.app X)))","decl":"@[deprecated (since := \"2024-12-31\")] alias CommShift.app_shift := app_shift\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.of_iso_inv","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁶ : CategoryTheory.Category.{u_7, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F₁ F₂\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift C A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : F₁.CommShift A\ninst✝¹ : F₂.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift e.hom A\n⊢ CategoryTheory.NatTrans.CommShift e.inv A","decl":"instance of_iso_inv [NatTrans.CommShift e.hom A] :\n  NatTrans.CommShift e.inv A := ⟨fun a => by\n  ext X\n  dsimp\n  rw [← cancel_epi (e.hom.app (X⟦a⟧)), e.hom_inv_id_app_assoc, ← shift_app_comm_assoc,\n    ← Functor.map_comp, e.hom_inv_id_app, Functor.map_id, Category.comp_id]⟩\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.of_isIso","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_6, u_2} D\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nA : Type u_5\ninst✝⁶ : AddMonoid A\ninst✝⁵ : CategoryTheory.HasShift C A\ninst✝⁴ : CategoryTheory.HasShift D A\ninst✝³ : F₁.CommShift A\ninst✝² : F₂.CommShift A\ninst✝¹ : CategoryTheory.IsIso τ\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.inv τ) A","decl":"lemma of_isIso [IsIso τ] [NatTrans.CommShift τ A] :\n    NatTrans.CommShift (inv τ) A := by\n  haveI : NatTrans.CommShift (asIso τ).hom A := by assumption\n  change NatTrans.CommShift (asIso τ).inv A\n  infer_instance\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.id","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} D\nF₁ : CategoryTheory.Functor C D\nA : Type u_5\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F₁.CommShift A\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.CategoryStruct.id F₁) A","decl":"variable (F₁) in\ninstance id : NatTrans.CommShift (𝟙 F₁) A where\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.comp","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁹ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁸ : CategoryTheory.Category.{u_7, u_2} D\nF₁ F₂ F₃ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nτ' : Quiver.Hom F₂ F₃\nA : Type u_5\ninst✝⁷ : AddMonoid A\ninst✝⁶ : CategoryTheory.HasShift C A\ninst✝⁵ : CategoryTheory.HasShift D A\ninst✝⁴ : F₁.CommShift A\ninst✝³ : F₂.CommShift A\ninst✝² : F₃.CommShift A\ninst✝¹ : CategoryTheory.NatTrans.CommShift τ A\ninst✝ : CategoryTheory.NatTrans.CommShift τ' A\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.CategoryStruct.comp τ τ') A","decl":"instance comp [NatTrans.CommShift τ A] [NatTrans.CommShift τ' A] :\n    NatTrans.CommShift (τ ≫ τ') A where\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.whiskerRight","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_7, u_2} D\ninst✝⁸ : CategoryTheory.Category.{u_8, u_3} E\nF₁ F₂ : CategoryTheory.Functor C D\nτ : Quiver.Hom F₁ F₂\nG : CategoryTheory.Functor D E\nA : Type u_5\ninst✝⁷ : AddMonoid A\ninst✝⁶ : CategoryTheory.HasShift C A\ninst✝⁵ : CategoryTheory.HasShift D A\ninst✝⁴ : CategoryTheory.HasShift E A\ninst✝³ : F₁.CommShift A\ninst✝² : F₂.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ A\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.whiskerRight τ G) A","decl":"instance whiskerRight [NatTrans.CommShift τ A] :\n    NatTrans.CommShift (whiskerRight τ G) A := ⟨fun a => by\n  ext X\n  simp only [whiskerRight_twice, comp_app,\n    whiskerRight_app, Functor.comp_map, whiskerLeft_app,\n    Functor.commShiftIso_comp_hom_app, Category.assoc,\n    ← Functor.commShiftIso_hom_naturality,\n    ← G.map_comp_assoc, shift_app_comm]⟩\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.whiskerLeft","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝¹⁰ : CategoryTheory.Category.{u_8, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_6, u_2} D\ninst✝⁸ : CategoryTheory.Category.{u_7, u_3} E\nF₁ : CategoryTheory.Functor C D\nG G' : CategoryTheory.Functor D E\nτ'' : Quiver.Hom G G'\nA : Type u_5\ninst✝⁷ : AddMonoid A\ninst✝⁶ : CategoryTheory.HasShift C A\ninst✝⁵ : CategoryTheory.HasShift D A\ninst✝⁴ : CategoryTheory.HasShift E A\ninst✝³ : F₁.CommShift A\ninst✝² : G.CommShift A\ninst✝¹ : G'.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift τ'' A\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.whiskerLeft F₁ τ'') A","decl":"instance whiskerLeft [NatTrans.CommShift τ'' A] :\n    NatTrans.CommShift (whiskerLeft F₁ τ'') A where\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.associator","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nJ : Type u_4\ninst✝¹¹ : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹⁰ : CategoryTheory.Category.{u_9, u_2} D\ninst✝⁹ : CategoryTheory.Category.{u_8, u_3} E\ninst✝⁸ : CategoryTheory.Category.{u_7, u_4} J\nF₁ : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nH : CategoryTheory.Functor E J\nA : Type u_5\ninst✝⁷ : AddMonoid A\ninst✝⁶ : CategoryTheory.HasShift C A\ninst✝⁵ : CategoryTheory.HasShift D A\ninst✝⁴ : CategoryTheory.HasShift E A\ninst✝³ : CategoryTheory.HasShift J A\ninst✝² : F₁.CommShift A\ninst✝¹ : G.CommShift A\ninst✝ : H.CommShift A\n⊢ CategoryTheory.NatTrans.CommShift (F₁.associator G H).hom A","decl":"instance associator : CommShift (Functor.associator F₁ G H).hom A where\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.leftUnitor","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} D\nF₁ : CategoryTheory.Functor C D\nA : Type u_5\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F₁.CommShift A\n⊢ CategoryTheory.NatTrans.CommShift F₁.leftUnitor.hom A","decl":"instance leftUnitor : CommShift F₁.leftUnitor.hom A where\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.rightUnitor","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_7, u_2} D\nF₁ : CategoryTheory.Functor C D\nA : Type u_5\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F₁.CommShift A\n⊢ CategoryTheory.NatTrans.CommShift F₁.rightUnitor.hom A","decl":"instance rightUnitor : CommShift F₁.rightUnitor.hom A where\n\n"}
{"name":"CategoryTheory.Functor.CommShift.ofIso_compatibility","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} D\nF G : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F G\nA : Type u_4\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift C A\ninst✝¹ : CategoryTheory.HasShift D A\ninst✝ : F.CommShift A\n⊢ CategoryTheory.NatTrans.CommShift e.hom A","decl":"lemma ofIso_compatibility :\n    letI := ofIso e A\n    NatTrans.CommShift e.hom A := by\n  letI := ofIso e A\n  refine ⟨fun a => ?_⟩\n  dsimp [commShiftIso, ofIso]\n  rw [← whiskerLeft_comp_assoc, e.hom_inv_id, whiskerLeft_id', id_comp]\n\n"}
{"name":"CategoryTheory.NatTrans.CommShift.verticalComposition","module":"Mathlib.CategoryTheory.Shift.CommShift","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝²⁵ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝²⁴ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝²³ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝²² : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝²¹ : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝²⁰ : CategoryTheory.Category.{u_13, u_6} D₃\nF₁₂ : CategoryTheory.Functor C₁ C₂\nF₂₃ : CategoryTheory.Functor C₂ C₃\nF₁₃ : CategoryTheory.Functor C₁ C₃\nα : Quiver.Hom F₁₃ (F₁₂.comp F₂₃)\nG₁₂ : CategoryTheory.Functor D₁ D₂\nG₂₃ : CategoryTheory.Functor D₂ D₃\nG₁₃ : CategoryTheory.Functor D₁ D₃\nβ : Quiver.Hom (G₁₂.comp G₂₃) G₁₃\nL₁ : CategoryTheory.Functor C₁ D₁\nL₂ : CategoryTheory.Functor C₂ D₂\nL₃ : CategoryTheory.Functor C₃ D₃\ne₁₂ : Quiver.Hom (F₁₂.comp L₂) (L₁.comp G₁₂)\ne₂₃ : Quiver.Hom (F₂₃.comp L₃) (L₂.comp G₂₃)\ne₁₃ : Quiver.Hom (F₁₃.comp L₃) (L₁.comp G₁₃)\nA : Type u_7\ninst✝¹⁹ : AddMonoid A\ninst✝¹⁸ : CategoryTheory.HasShift C₁ A\ninst✝¹⁷ : CategoryTheory.HasShift C₂ A\ninst✝¹⁶ : CategoryTheory.HasShift C₃ A\ninst✝¹⁵ : CategoryTheory.HasShift D₁ A\ninst✝¹⁴ : CategoryTheory.HasShift D₂ A\ninst✝¹³ : CategoryTheory.HasShift D₃ A\ninst✝¹² : F₁₂.CommShift A\ninst✝¹¹ : F₂₃.CommShift A\ninst✝¹⁰ : F₁₃.CommShift A\ninst✝⁹ : CategoryTheory.NatTrans.CommShift α A\ninst✝⁸ : G₁₂.CommShift A\ninst✝⁷ : G₂₃.CommShift A\ninst✝⁶ : G₁₃.CommShift A\ninst✝⁵ : CategoryTheory.NatTrans.CommShift β A\ninst✝⁴ : L₁.CommShift A\ninst✝³ : L₂.CommShift A\ninst✝² : L₃.CommShift A\ninst✝¹ : CategoryTheory.NatTrans.CommShift e₁₂ A\ninst✝ : CategoryTheory.NatTrans.CommShift e₂₃ A\nh₁₃ : Eq e₁₃ (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight α L₃) (CategoryTheory.CategoryStruct.comp (F₁₂.associator F₂₃ L₃).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft F₁₂ e₂₃) (CategoryTheory.CategoryStruct.comp (F₁₂.associator L₂ G₂₃).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight e₁₂ G₂₃) (CategoryTheory.CategoryStruct.comp (L₁.associator G₁₂ G₂₃).hom (CategoryTheory.whiskerLeft L₁ β)))))))\n⊢ CategoryTheory.NatTrans.CommShift e₁₃ A","decl":"/--\nAssume that we have a diagram of categories\n```\nC₁ ⥤ D₁\n‖     ‖\nv     v\nC₂ ⥤ D₂\n‖     ‖\nv     v\nC₃ ⥤ D₃\n```\nwith functors `F₁₂ : C₁ ⥤ C₂`, `F₂₃ : C₂ ⥤ C₃` and `F₁₃ : C₁ ⥤ C₃` on the first\ncolumn that are related by a natural transformation `α : F₁₃ ⟶ F₁₂ ⋙ F₂₃`\nand similarly `β : G₁₂ ⋙ G₂₃ ⟶ G₁₃` on the second column. Assume that we have\nnatural transformations\n`e₁₂ : F₁₂ ⋙ L₂ ⟶ L₁ ⋙ G₁₂` (top square), `e₂₃ : F₂₃ ⋙ L₃ ⟶ L₂ ⋙ G₂₃` (bottom square),\nand `e₁₃ : F₁₃ ⋙ L₃ ⟶ L₁ ⋙ G₁₃` (outer square), where the horizontal functors\nare denoted `L₁`, `L₂` and `L₃`. Assume that `e₁₃` is determined by the other\nnatural transformations `α`, `e₂₃`, `e₁₂` and `β`. Then, if all these categories\nare equipped with a shift by an additive monoid `A`, and all these functors commute with\nthese shifts, then the natural transformation `e₁₃` of the outer square commutes with the\nshift if all `α`, `e₂₃`, `e₁₂` and `β` do. -/\nlemma NatTrans.CommShift.verticalComposition {C₁ C₂ C₃ D₁ D₂ D₃ : Type*}\n    [Category C₁] [Category C₂] [Category C₃] [Category D₁] [Category D₂] [Category D₃]\n    {F₁₂ : C₁ ⥤ C₂} {F₂₃ : C₂ ⥤ C₃} {F₁₃ : C₁ ⥤ C₃} (α : F₁₃ ⟶ F₁₂ ⋙ F₂₃)\n    {G₁₂ : D₁ ⥤ D₂} {G₂₃ : D₂ ⥤ D₃} {G₁₃ : D₁ ⥤ D₃} (β : G₁₂ ⋙ G₂₃ ⟶ G₁₃)\n    {L₁ : C₁ ⥤ D₁} {L₂ : C₂ ⥤ D₂} {L₃ : C₃ ⥤ D₃}\n    (e₁₂ : F₁₂ ⋙ L₂ ⟶ L₁ ⋙ G₁₂) (e₂₃ : F₂₃ ⋙ L₃ ⟶ L₂ ⋙ G₂₃) (e₁₃ : F₁₃ ⋙ L₃ ⟶ L₁ ⋙ G₁₃)\n    (A : Type*) [AddMonoid A] [HasShift C₁ A] [HasShift C₂ A] [HasShift C₃ A]\n    [HasShift D₁ A] [HasShift D₂ A] [HasShift D₃ A]\n    [F₁₂.CommShift A] [F₂₃.CommShift A] [F₁₃.CommShift A] [CommShift α A]\n    [G₁₂.CommShift A] [G₂₃.CommShift A] [G₁₃.CommShift A] [CommShift β A]\n    [L₁.CommShift A] [L₂.CommShift A] [L₃.CommShift A]\n    [CommShift e₁₂ A] [CommShift e₂₃ A]\n    (h₁₃ : e₁₃ = CategoryTheory.whiskerRight α L₃ ≫ (Functor.associator _ _ _).hom ≫\n      CategoryTheory.whiskerLeft F₁₂ e₂₃ ≫ (Functor.associator _ _ _).inv ≫\n        CategoryTheory.whiskerRight e₁₂ G₂₃ ≫ (Functor.associator _ _ _).hom ≫\n          CategoryTheory.whiskerLeft L₁ β) : CommShift e₁₃ A := by\n  subst h₁₃\n  infer_instance\n\n"}
