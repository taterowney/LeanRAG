{"name":"AddSubmonoid.LocalizationMap.toMap_injective_iff","module":"Mathlib.GroupTheory.MonoidLocalization.MonoidWithZero","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddCommMonoid M\nS : AddSubmonoid M\ninst✝ : AddCommMonoid N\nf : S.LocalizationMap N\n⊢ Iff (Function.Injective ⇑f.toMap) (∀ ⦃x : M⦄, Membership.mem S x → IsAddLeftRegular x)","decl":"@[to_additive]\ntheorem toMap_injective_iff\n    {M N : Type*} [CommMonoid M] {S : Submonoid M} [CommMonoid N] (f : LocalizationMap S N) :\n    Injective (LocalizationMap.toMap f) ↔ ∀ ⦃x⦄, x ∈ S → IsLeftRegular x := by\n  rw [Injective]\n  constructor <;> intro h\n  · intro x hx y z hyz\n    simp_rw [LocalizationMap.eq_iff_exists] at h\n    apply (fun y z _ => h) y z x\n    lift x to S using hx\n    use x\n  · intro a b hab\n    rw [LocalizationMap.eq_iff_exists] at hab\n    obtain ⟨c,hc⟩ := hab\n    apply (fun x a => h a) c (SetLike.coe_mem c) hc\n\n"}
{"name":"Submonoid.LocalizationMap.toMap_injective_iff","module":"Mathlib.GroupTheory.MonoidLocalization.MonoidWithZero","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : CommMonoid M\nS : Submonoid M\ninst✝ : CommMonoid N\nf : S.LocalizationMap N\n⊢ Iff (Function.Injective ⇑f.toMap) (∀ ⦃x : M⦄, Membership.mem S x → IsLeftRegular x)","decl":"@[to_additive]\ntheorem toMap_injective_iff\n    {M N : Type*} [CommMonoid M] {S : Submonoid M} [CommMonoid N] (f : LocalizationMap S N) :\n    Injective (LocalizationMap.toMap f) ↔ ∀ ⦃x⦄, x ∈ S → IsLeftRegular x := by\n  rw [Injective]\n  constructor <;> intro h\n  · intro x hx y z hyz\n    simp_rw [LocalizationMap.eq_iff_exists] at h\n    apply (fun y z _ => h) y z x\n    lift x to S using hx\n    use x\n  · intro a b hab\n    rw [LocalizationMap.eq_iff_exists] at hab\n    obtain ⟨c,hc⟩ := hab\n    apply (fun x a => h a) c (SetLike.coe_mem c) hc\n\n"}
{"name":"Submonoid.LocalizationMap.subsingleton","module":"Mathlib.GroupTheory.MonoidLocalization.MonoidWithZero","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoidWithZero M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoidWithZero N\nf : S.LocalizationMap N\nh : Membership.mem S 0\n⊢ Subsingleton N","decl":"variable {S N} in\n/-- If `S` contains `0` then the localization at `S` is trivial. -/\ntheorem LocalizationMap.subsingleton (f : Submonoid.LocalizationMap S N) (h : 0 ∈ S) :\n    Subsingleton N := by\n  refine ⟨fun a b ↦ ?_⟩\n  rw [← LocalizationMap.mk'_sec f a, ← LocalizationMap.mk'_sec f b, LocalizationMap.eq]\n  exact ⟨⟨0, h⟩, by simp only [zero_mul]⟩\n\n"}
{"name":"Submonoid.LocalizationWithZeroMap.map_zero'","module":"Mathlib.GroupTheory.MonoidLocalization.MonoidWithZero","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoidWithZero M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoidWithZero N\nself : S.LocalizationWithZeroMap N\n⊢ Eq ((↑self.toMonoidHom).toFun 0) 0","decl":"/-- The type of homomorphisms between monoids with zero satisfying the characteristic predicate:\nif `f : M →*₀ N` satisfies this predicate, then `N` is isomorphic to the localization of `M` at\n`S`. -/\nstructure LocalizationWithZeroMap extends LocalizationMap S N where\n  map_zero' : toFun 0 = 0\n\n-- Porting note: no docstrings for LocalizationWithZeroMap.map_zero'\n"}
{"name":"Submonoid.LocalizationWithZeroMap.mk.sizeOf_spec","module":"Mathlib.GroupTheory.MonoidLocalization.MonoidWithZero","initialProofState":"M : Type u_1\ninst✝³ : CommMonoidWithZero M\nS : Submonoid M\nN : Type u_2\ninst✝² : CommMonoidWithZero N\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoLocalizationMap : S.LocalizationMap N\nmap_zero' : Eq ((↑toLocalizationMap.toMonoidHom).toFun 0) 0\n⊢ Eq (SizeOf.sizeOf { toLocalizationMap := toLocalizationMap, map_zero' := map_zero' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toLocalizationMap)) (SizeOf.sizeOf map_zero'))","decl":"/-- The type of homomorphisms between monoids with zero satisfying the characteristic predicate:\nif `f : M →*₀ N` satisfies this predicate, then `N` is isomorphic to the localization of `M` at\n`S`. -/\nstructure LocalizationWithZeroMap extends LocalizationMap S N where\n  map_zero' : toFun 0 = 0\n\n-- Porting note: no docstrings for LocalizationWithZeroMap.map_zero'\n"}
{"name":"Submonoid.LocalizationWithZeroMap.mk.injEq","module":"Mathlib.GroupTheory.MonoidLocalization.MonoidWithZero","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoidWithZero M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoidWithZero N\ntoLocalizationMap✝ : S.LocalizationMap N\nmap_zero'✝ : Eq ((↑toLocalizationMap✝.toMonoidHom).toFun 0) 0\ntoLocalizationMap : S.LocalizationMap N\nmap_zero' : Eq ((↑toLocalizationMap.toMonoidHom).toFun 0) 0\n⊢ Eq (Eq { toLocalizationMap := toLocalizationMap✝, map_zero' := map_zero'✝ } { toLocalizationMap := toLocalizationMap, map_zero' := map_zero' }) (Eq toLocalizationMap✝ toLocalizationMap)","decl":"/-- The type of homomorphisms between monoids with zero satisfying the characteristic predicate:\nif `f : M →*₀ N` satisfies this predicate, then `N` is isomorphic to the localization of `M` at\n`S`. -/\nstructure LocalizationWithZeroMap extends LocalizationMap S N where\n  map_zero' : toFun 0 = 0\n\n-- Porting note: no docstrings for LocalizationWithZeroMap.map_zero'\n"}
{"name":"Submonoid.LocalizationWithZeroMap.mk.inj","module":"Mathlib.GroupTheory.MonoidLocalization.MonoidWithZero","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoidWithZero M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoidWithZero N\ntoLocalizationMap✝ : S.LocalizationMap N\nmap_zero'✝ : Eq ((↑toLocalizationMap✝.toMonoidHom).toFun 0) 0\ntoLocalizationMap : S.LocalizationMap N\nmap_zero' : Eq ((↑toLocalizationMap.toMonoidHom).toFun 0) 0\nx✝ : Eq { toLocalizationMap := toLocalizationMap✝, map_zero' := map_zero'✝ } { toLocalizationMap := toLocalizationMap, map_zero' := map_zero' }\n⊢ Eq toLocalizationMap✝ toLocalizationMap","decl":"/-- The type of homomorphisms between monoids with zero satisfying the characteristic predicate:\nif `f : M →*₀ N` satisfies this predicate, then `N` is isomorphic to the localization of `M` at\n`S`. -/\nstructure LocalizationWithZeroMap extends LocalizationMap S N where\n  map_zero' : toFun 0 = 0\n\n-- Porting note: no docstrings for LocalizationWithZeroMap.map_zero'\n"}
{"name":"Localization.mk_zero","module":"Mathlib.GroupTheory.MonoidLocalization.MonoidWithZero","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\nS : Submonoid M\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (Localization.mk 0 x) 0","decl":"theorem mk_zero (x : S) : mk 0 (x : S) = 0 := OreLocalization.zero_oreDiv' _\n\n"}
{"name":"Localization.liftOn_zero","module":"Mathlib.GroupTheory.MonoidLocalization.MonoidWithZero","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\nS : Submonoid M\np : Type u_4\nf : M → (Subtype fun x => Membership.mem S x) → p\nH : ∀ {a c : M} {b d : Subtype fun x => Membership.mem S x}, (Localization.r S) { fst := a, snd := b } { fst := c, snd := d } → Eq (f a b) (f c d)\n⊢ Eq (Localization.liftOn 0 f H) (f 0 1)","decl":"theorem liftOn_zero {p : Type*} (f : M → S → p) (H) : liftOn 0 f H = f 0 1 := by\n  rw [← mk_zero 1, liftOn_mk]\n\n"}
{"name":"Submonoid.LocalizationMap.sec_zero_fst","module":"Mathlib.GroupTheory.MonoidLocalization.MonoidWithZero","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoidWithZero M\nS : Submonoid M\nN : Type u_2\ninst✝ : CommMonoidWithZero N\nf : S.LocalizationMap N\n⊢ Eq (f.toMap (f.sec 0).1) 0","decl":"@[simp]\ntheorem LocalizationMap.sec_zero_fst {f : LocalizationMap S N} : f.toMap (f.sec 0).fst = 0 := by\n  rw [LocalizationMap.sec_spec', mul_zero]\n\n"}
{"name":"Submonoid.LocalizationWithZeroMap.leftCancelMulZero_of_le_isLeftRegular","module":"Mathlib.GroupTheory.MonoidLocalization.MonoidWithZero","initialProofState":"M : Type u_1\ninst✝² : CommMonoidWithZero M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoidWithZero N\nf : S.LocalizationWithZeroMap N\ninst✝ : IsLeftCancelMulZero M\nh : ∀ ⦃x : M⦄, Membership.mem S x → IsLeftRegular x\n⊢ IsLeftCancelMulZero N","decl":"/-- Given a Localization map `f : M →*₀ N` for a Submonoid `S ⊆ M`,\nif `M` is left cancellative monoid with zero, and all elements of `S` are\nleft regular, then N is a left cancellative monoid with zero. -/\ntheorem leftCancelMulZero_of_le_isLeftRegular\n    (f : LocalizationWithZeroMap S N) [IsLeftCancelMulZero M]\n    (h : ∀ ⦃x⦄, x ∈ S → IsLeftRegular x) : IsLeftCancelMulZero N := by\n  let fl := f.toLocalizationMap\n  let g := f.toMap\n  constructor\n  intro a z w ha hazw\n  obtain ⟨b, hb⟩ := LocalizationMap.surj fl a\n  obtain ⟨x, hx⟩ := LocalizationMap.surj fl z\n  obtain ⟨y, hy⟩ := LocalizationMap.surj fl w\n  rw [(LocalizationMap.eq_mk'_iff_mul_eq fl).mpr hx,\n    (LocalizationMap.eq_mk'_iff_mul_eq fl).mpr hy, LocalizationMap.eq]\n  use 1\n  rw [OneMemClass.coe_one, one_mul, one_mul]\n  -- The hypothesis `a ≠ 0` in `P` is equivalent to this\n  have b1ne0 : b.1 ≠ 0 := by\n    intro hb1\n    have m0 : (LocalizationMap.toMap fl) 0 = 0 := f.map_zero'\n    have a0 : a * (LocalizationMap.toMap fl) b.2 = 0 ↔ a = 0 :=\n      (f.toLocalizationMap.map_units' b.2).mul_left_eq_zero\n    rw [hb1, m0, a0] at hb\n    exact ha hb\n  have main : g (b.1 * (x.2 * y.1)) = g (b.1 * (y.2 * x.1)) :=\n    calc\n      g (b.1 * (x.2 * y.1)) = g b.1 * (g x.2 * g y.1) := by rw [map_mul g,map_mul g]\n      _ = a * g b.2 * (g x.2 * (w * g y.2)) := by rw [hb, hy]\n      _ = a * w * g b.2 * (g x.2 * g y.2) := by\n        rw [← mul_assoc, ← mul_assoc _ w, mul_comm _ w, mul_assoc w, mul_assoc,\n          ← mul_assoc w, ← mul_assoc w, mul_comm w]\n      _ = a * z * g b.2 * (g x.2 * g y.2) := by rw [hazw]\n      _ = a * g b.2 * (z * g x.2 * g y.2) := by\n        rw [mul_assoc a, mul_comm z, ← mul_assoc a, mul_assoc, mul_assoc z]\n      _ = g b.1 * g (y.2 * x.1) := by rw [hx, hb, mul_comm (g x.1), ← map_mul g]\n      _ = g (b.1 * (y.2 * x.1)) := by rw [← map_mul g]\n -- The hypothesis `h` gives that `f` (so, `g`) is injective, and we can cancel out `b.1`.\n  exact (IsLeftCancelMulZero.mul_left_cancel_of_ne_zero b1ne0\n      ((LocalizationMap.toMap_injective_iff fl).mpr h main)).symm\n\n"}
{"name":"Submonoid.LocalizationWithZeroMap.isLeftRegular_of_le_isCancelMulZero","module":"Mathlib.GroupTheory.MonoidLocalization.MonoidWithZero","initialProofState":"M : Type u_1\ninst✝² : CommMonoidWithZero M\nS : Submonoid M\nN : Type u_2\ninst✝¹ : CommMonoidWithZero N\nf : S.LocalizationWithZeroMap N\ninst✝ : IsCancelMulZero M\nh : ∀ ⦃x : M⦄, Membership.mem S x → IsRegular x\n⊢ IsCancelMulZero N","decl":"/-- Given a Localization map `f : M →*₀ N` for a Submonoid `S ⊆ M`,\nif `M` is a cancellative monoid with zero, and all elements of `S` are\nregular, then N is a cancellative monoid with zero. -/\ntheorem isLeftRegular_of_le_isCancelMulZero (f : LocalizationWithZeroMap S N)\n    [IsCancelMulZero M] (h : ∀ ⦃x⦄, x ∈ S → IsRegular x) : IsCancelMulZero N := by\n  have : IsLeftCancelMulZero N :=\n    leftCancelMulZero_of_le_isLeftRegular f (fun x h' => (h h').left)\n  exact IsLeftCancelMulZero.to_isCancelMulZero\n\n"}
