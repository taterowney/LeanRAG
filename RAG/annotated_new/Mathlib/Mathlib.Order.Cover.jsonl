{"name":"WCovBy.le","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : WCovBy a b\n⊢ LE.le a b","decl":"theorem WCovBy.le (h : a ⩿ b) : a ≤ b :=\n  h.1\n\n"}
{"name":"WCovBy.refl","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ WCovBy a a","decl":"theorem WCovBy.refl (a : α) : a ⩿ a :=\n  ⟨le_rfl, fun _ hc => hc.not_lt⟩\n\n"}
{"name":"WCovBy.rfl","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ WCovBy a a","decl":"@[simp] lemma WCovBy.rfl : a ⩿ a := WCovBy.refl a\n\n"}
{"name":"Eq.wcovBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : Eq a b\n⊢ WCovBy a b","decl":"protected theorem Eq.wcovBy (h : a = b) : a ⩿ b :=\n  h ▸ WCovBy.rfl\n\n"}
{"name":"wcovBy_of_le_of_le","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh1 : LE.le a b\nh2 : LE.le b a\n⊢ WCovBy a b","decl":"theorem wcovBy_of_le_of_le (h1 : a ≤ b) (h2 : b ≤ a) : a ⩿ b :=\n  ⟨h1, fun _ hac hcb => (hac.trans hcb).not_le h2⟩\n\n"}
{"name":"LE.le.wcovBy_of_le","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh1 : LE.le a b\nh2 : LE.le b a\n⊢ WCovBy a b","decl":"alias LE.le.wcovBy_of_le := wcovBy_of_le_of_le\n\n"}
{"name":"AntisymmRel.wcovBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : AntisymmRel (fun x1 x2 => LE.le x1 x2) a b\n⊢ WCovBy a b","decl":"theorem AntisymmRel.wcovBy (h : AntisymmRel (· ≤ ·) a b) : a ⩿ b :=\n  wcovBy_of_le_of_le h.1 h.2\n\n"}
{"name":"WCovBy.wcovBy_iff_le","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : WCovBy a b\n⊢ Iff (WCovBy b a) (LE.le b a)","decl":"theorem WCovBy.wcovBy_iff_le (hab : a ⩿ b) : b ⩿ a ↔ b ≤ a :=\n  ⟨fun h => h.le, fun h => h.wcovBy_of_le hab.le⟩\n\n"}
{"name":"wcovBy_of_eq_or_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LE.le a b\nh : ∀ (c : α), LE.le a c → LE.le c b → Or (Eq c a) (Eq c b)\n⊢ WCovBy a b","decl":"theorem wcovBy_of_eq_or_eq (hab : a ≤ b) (h : ∀ c, a ≤ c → c ≤ b → c = a ∨ c = b) : a ⩿ b :=\n  ⟨hab, fun c ha hb => (h c ha.le hb.le).elim ha.ne' hb.ne⟩\n\n"}
{"name":"AntisymmRel.trans_wcovBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : AntisymmRel (fun x1 x2 => LE.le x1 x2) a b\nhbc : WCovBy b c\n⊢ WCovBy a c","decl":"theorem AntisymmRel.trans_wcovBy (hab : AntisymmRel (· ≤ ·) a b) (hbc : b ⩿ c) : a ⩿ c :=\n  ⟨hab.1.trans hbc.le, fun _ had hdc => hbc.2 (hab.2.trans_lt had) hdc⟩\n\n"}
{"name":"wcovBy_congr_left","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : AntisymmRel (fun x1 x2 => LE.le x1 x2) a b\n⊢ Iff (WCovBy a c) (WCovBy b c)","decl":"theorem wcovBy_congr_left (hab : AntisymmRel (· ≤ ·) a b) : a ⩿ c ↔ b ⩿ c :=\n  ⟨hab.symm.trans_wcovBy, hab.trans_wcovBy⟩\n\n"}
{"name":"WCovBy.trans_antisymm_rel","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : WCovBy a b\nhbc : AntisymmRel (fun x1 x2 => LE.le x1 x2) b c\n⊢ WCovBy a c","decl":"theorem WCovBy.trans_antisymm_rel (hab : a ⩿ b) (hbc : AntisymmRel (· ≤ ·) b c) : a ⩿ c :=\n  ⟨hab.le.trans hbc.1, fun _ had hdc => hab.2 had <| hdc.trans_le hbc.2⟩\n\n"}
{"name":"wcovBy_congr_right","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : AntisymmRel (fun x1 x2 => LE.le x1 x2) a b\n⊢ Iff (WCovBy c a) (WCovBy c b)","decl":"theorem wcovBy_congr_right (hab : AntisymmRel (· ≤ ·) a b) : c ⩿ a ↔ c ⩿ b :=\n  ⟨fun h => h.trans_antisymm_rel hab, fun h => h.trans_antisymm_rel hab.symm⟩\n\n"}
{"name":"not_wcovBy_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ Iff (Not (WCovBy a b)) (Exists fun c => And (LT.lt a c) (LT.lt c b))","decl":"/-- If `a ≤ b`, then `b` does not cover `a` iff there's an element in between. -/\ntheorem not_wcovBy_iff (h : a ≤ b) : ¬a ⩿ b ↔ ∃ c, a < c ∧ c < b := by\n  simp_rw [WCovBy, h, true_and, not_forall, exists_prop, not_not]\n\n"}
{"name":"WCovBy.isRefl","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ IsRefl α fun x1 x2 => WCovBy x1 x2","decl":"instance WCovBy.isRefl : IsRefl α (· ⩿ ·) :=\n  ⟨WCovBy.refl⟩\n\n"}
{"name":"WCovBy.Ioo_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : WCovBy a b\n⊢ Eq (Set.Ioo a b) EmptyCollection.emptyCollection","decl":"theorem WCovBy.Ioo_eq (h : a ⩿ b) : Ioo a b = ∅ :=\n  eq_empty_iff_forall_not_mem.2 fun _ hx => h.2 hx.1 hx.2\n\n"}
{"name":"wcovBy_iff_Ioo_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (WCovBy a b) (And (LE.le a b) (Eq (Set.Ioo a b) EmptyCollection.emptyCollection))","decl":"theorem wcovBy_iff_Ioo_eq : a ⩿ b ↔ a ≤ b ∧ Ioo a b = ∅ :=\n  and_congr_right' <| by simp [eq_empty_iff_forall_not_mem]\n\n"}
{"name":"WCovBy.of_le_of_le","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhac : WCovBy a c\nhab : LE.le a b\nhbc : LE.le b c\n⊢ WCovBy b c","decl":"lemma WCovBy.of_le_of_le (hac : a ⩿ c) (hab : a ≤ b) (hbc : b ≤ c) : b ⩿ c :=\n  ⟨hbc, fun _x hbx hxc ↦ hac.2 (hab.trans_lt hbx) hxc⟩\n\n"}
{"name":"WCovBy.of_le_of_le'","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhac : WCovBy a c\nhab : LE.le a b\nhbc : LE.le b c\n⊢ WCovBy a b","decl":"lemma WCovBy.of_le_of_le' (hac : a ⩿ c) (hab : a ≤ b) (hbc : b ≤ c) : a ⩿ b :=\n  ⟨hab, fun _x hax hxb ↦ hac.2 hax <| hxb.trans_le hbc⟩\n\n"}
{"name":"WCovBy.of_image","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na b : α\nf : OrderEmbedding α β\nh : WCovBy (f a) (f b)\n⊢ WCovBy a b","decl":"theorem WCovBy.of_image (f : α ↪o β) (h : f a ⩿ f b) : a ⩿ b :=\n  ⟨f.le_iff_le.mp h.le, fun _ hac hcb => h.2 (f.lt_iff_lt.mpr hac) (f.lt_iff_lt.mpr hcb)⟩\n\n"}
{"name":"WCovBy.image","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na b : α\nf : OrderEmbedding α β\nhab : WCovBy a b\nh : (Set.range ⇑f).OrdConnected\n⊢ WCovBy (f a) (f b)","decl":"theorem WCovBy.image (f : α ↪o β) (hab : a ⩿ b) (h : (range f).OrdConnected) : f a ⩿ f b := by\n  refine ⟨f.monotone hab.le, fun c ha hb => ?_⟩\n  obtain ⟨c, rfl⟩ := h.out (mem_range_self _) (mem_range_self _) ⟨ha.le, hb.le⟩\n  rw [f.lt_iff_lt] at ha hb\n  exact hab.2 ha hb\n\n"}
{"name":"Set.OrdConnected.apply_wcovBy_apply_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na b : α\nf : OrderEmbedding α β\nh : (Set.range ⇑f).OrdConnected\n⊢ Iff (WCovBy (f a) (f b)) (WCovBy a b)","decl":"theorem Set.OrdConnected.apply_wcovBy_apply_iff (f : α ↪o β) (h : (range f).OrdConnected) :\n    f a ⩿ f b ↔ a ⩿ b :=\n  ⟨fun h2 => h2.of_image f, fun hab => hab.image f h⟩\n\n"}
{"name":"apply_wcovBy_apply_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\na b : α\nE : Type u_3\ninst✝¹ : EquivLike E α β\ninst✝ : OrderIsoClass E α β\ne : E\n⊢ Iff (WCovBy (e a) (e b)) (WCovBy a b)","decl":"@[simp]\ntheorem apply_wcovBy_apply_iff {E : Type*} [EquivLike E α β] [OrderIsoClass E α β] (e : E) :\n    e a ⩿ e b ↔ a ⩿ b :=\n  (ordConnected_range (e : α ≃o β)).apply_wcovBy_apply_iff ((e : α ≃o β) : α ↪o β)\n\n"}
{"name":"toDual_wcovBy_toDual_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (WCovBy (OrderDual.toDual b) (OrderDual.toDual a)) (WCovBy a b)","decl":"@[simp]\ntheorem toDual_wcovBy_toDual_iff : toDual b ⩿ toDual a ↔ a ⩿ b :=\n  and_congr_right' <| forall_congr' fun _ => forall_swap\n\n"}
{"name":"ofDual_wcovBy_ofDual_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : OrderDual α\n⊢ Iff (WCovBy (OrderDual.ofDual a) (OrderDual.ofDual b)) (WCovBy b a)","decl":"@[simp]\ntheorem ofDual_wcovBy_ofDual_iff {a b : αᵒᵈ} : ofDual a ⩿ ofDual b ↔ b ⩿ a :=\n  and_congr_right' <| forall_congr' fun _ => forall_swap\n\n"}
{"name":"WCovBy.toDual","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\na✝ : WCovBy a b\n⊢ WCovBy (OrderDual.toDual b) (OrderDual.toDual a)","decl":"alias ⟨_, WCovBy.toDual⟩ := toDual_wcovBy_toDual_iff\n\n"}
{"name":"WCovBy.ofDual","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : OrderDual α\na✝ : WCovBy b a\n⊢ WCovBy (OrderDual.ofDual a) (OrderDual.ofDual b)","decl":"alias ⟨_, WCovBy.ofDual⟩ := ofDual_wcovBy_ofDual_iff\n\n"}
{"name":"OrderEmbedding.wcovBy_of_apply","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderEmbedding α β\nx y : α\nh : WCovBy (f x) (f y)\n⊢ WCovBy x y","decl":"theorem OrderEmbedding.wcovBy_of_apply {α β : Type*} [Preorder α] [Preorder β]\n    (f : α ↪o β) {x y : α} (h : f x ⩿ f y) : x ⩿ y := by\n  use f.le_iff_le.1 h.1\n  intro a\n  rw [← f.lt_iff_lt, ← f.lt_iff_lt]\n  apply h.2\n\n"}
{"name":"OrderIso.map_wcovBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\nx y : α\n⊢ Iff (WCovBy (f x) (f y)) (WCovBy x y)","decl":"theorem OrderIso.map_wcovBy {α β : Type*} [Preorder α] [Preorder β]\n    (f : α ≃o β) {x y : α} : f x ⩿ f y ↔ x ⩿ y := by\n  use f.toOrderEmbedding.wcovBy_of_apply\n  conv_lhs => rw [← f.symm_apply_apply x, ← f.symm_apply_apply y]\n  exact f.symm.toOrderEmbedding.wcovBy_of_apply\n\n"}
{"name":"WCovBy.eq_or_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b c : α\nh : WCovBy a b\nh2 : LE.le a c\nh3 : LE.le c b\n⊢ Or (Eq c a) (Eq c b)","decl":"theorem WCovBy.eq_or_eq (h : a ⩿ b) (h2 : a ≤ c) (h3 : c ≤ b) : c = a ∨ c = b := by\n  rcases h2.eq_or_lt with (h2 | h2); · exact Or.inl h2.symm\n  rcases h3.eq_or_lt with (h3 | h3); · exact Or.inr h3\n  exact (h.2 h2 h3).elim\n\n"}
{"name":"wcovBy_iff_le_and_eq_or_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (WCovBy a b) (And (LE.le a b) (∀ (c : α), LE.le a c → LE.le c b → Or (Eq c a) (Eq c b)))","decl":"/-- An `iff` version of `WCovBy.eq_or_eq` and `wcovBy_of_eq_or_eq`. -/\ntheorem wcovBy_iff_le_and_eq_or_eq : a ⩿ b ↔ a ≤ b ∧ ∀ c, a ≤ c → c ≤ b → c = a ∨ c = b :=\n  ⟨fun h => ⟨h.le, fun _ => h.eq_or_eq⟩, And.rec wcovBy_of_eq_or_eq⟩\n\n"}
{"name":"WCovBy.le_and_le_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b c : α\nh : WCovBy a b\n⊢ Iff (And (LE.le a c) (LE.le c b)) (Or (Eq c a) (Eq c b))","decl":"theorem WCovBy.le_and_le_iff (h : a ⩿ b) : a ≤ c ∧ c ≤ b ↔ c = a ∨ c = b := by\n  refine ⟨fun h2 => h.eq_or_eq h2.1 h2.2, ?_⟩; rintro (rfl | rfl)\n  exacts [⟨le_rfl, h.le⟩, ⟨h.le, le_rfl⟩]\n\n"}
{"name":"WCovBy.Icc_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : WCovBy a b\n⊢ Eq (Set.Icc a b) (Insert.insert a (Singleton.singleton b))","decl":"theorem WCovBy.Icc_eq (h : a ⩿ b) : Icc a b = {a, b} := by\n  ext c\n  exact h.le_and_le_iff\n\n"}
{"name":"WCovBy.Ico_subset","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : WCovBy a b\n⊢ HasSubset.Subset (Set.Ico a b) (Singleton.singleton a)","decl":"theorem WCovBy.Ico_subset (h : a ⩿ b) : Ico a b ⊆ {a} := by\n  rw [← Icc_diff_right, h.Icc_eq, diff_singleton_subset_iff, pair_comm]\n\n"}
{"name":"WCovBy.Ioc_subset","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : WCovBy a b\n⊢ HasSubset.Subset (Set.Ioc a b) (Singleton.singleton b)","decl":"theorem WCovBy.Ioc_subset (h : a ⩿ b) : Ioc a b ⊆ {b} := by\n  rw [← Icc_diff_left, h.Icc_eq, diff_singleton_subset_iff]\n\n"}
{"name":"WCovBy.sup_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\na b c : α\nhac : WCovBy a c\nhbc : WCovBy b c\nhab : Ne a b\n⊢ Eq (Max.max a b) c","decl":"theorem WCovBy.sup_eq (hac : a ⩿ c) (hbc : b ⩿ c) (hab : a ≠ b) : a ⊔ b = c :=\n  (sup_le hac.le hbc.le).eq_of_not_lt fun h =>\n    hab.lt_sup_or_lt_sup.elim (fun h' => hac.2 h' h) fun h' => hbc.2 h' h\n\n"}
{"name":"WCovBy.inf_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : SemilatticeInf α\na b c : α\nhca : WCovBy c a\nhcb : WCovBy c b\nhab : Ne a b\n⊢ Eq (Min.min a b) c","decl":"theorem WCovBy.inf_eq (hca : c ⩿ a) (hcb : c ⩿ b) (hab : a ≠ b) : a ⊓ b = c :=\n  (le_inf hca.le hcb.le).eq_of_not_gt fun h => hab.inf_lt_or_inf_lt.elim (hca.2 h) (hcb.2 h)\n\n"}
{"name":"CovBy.lt","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : α\nh : CovBy a b\n⊢ LT.lt a b","decl":"theorem CovBy.lt (h : a ⋖ b) : a < b :=\n  h.1\n\n"}
{"name":"not_covBy_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : α\nh : LT.lt a b\n⊢ Iff (Not (CovBy a b)) (Exists fun c => And (LT.lt a c) (LT.lt c b))","decl":"/-- If `a < b`, then `b` does not cover `a` iff there's an element in between. -/\ntheorem not_covBy_iff (h : a < b) : ¬a ⋖ b ↔ ∃ c, a < c ∧ c < b := by\n  simp_rw [CovBy, h, true_and, not_forall, exists_prop, not_not]\n\n"}
{"name":"exists_lt_lt_of_not_covBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : α\nh : LT.lt a b\na✝ : Not (CovBy a b)\n⊢ Exists fun c => And (LT.lt a c) (LT.lt c b)","decl":"alias ⟨exists_lt_lt_of_not_covBy, _⟩ := not_covBy_iff\n\n"}
{"name":"LT.lt.exists_lt_lt","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : α\nh : LT.lt a b\na✝ : Not (CovBy a b)\n⊢ Exists fun c => And (LT.lt a c) (LT.lt c b)","decl":"alias LT.lt.exists_lt_lt := exists_lt_lt_of_not_covBy\n\n"}
{"name":"not_covBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝¹ : LT α\na b : α\ninst✝ : DenselyOrdered α\n⊢ Not (CovBy a b)","decl":"/-- In a dense order, nothing covers anything. -/\ntheorem not_covBy [DenselyOrdered α] : ¬a ⋖ b := fun h =>\n  let ⟨_, hc⟩ := exists_between h.1\n  h.2 hc.1 hc.2\n\n"}
{"name":"denselyOrdered_iff_forall_not_covBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LT α\n⊢ Iff (DenselyOrdered α) (∀ (a b : α), Not (CovBy a b))","decl":"theorem denselyOrdered_iff_forall_not_covBy : DenselyOrdered α ↔ ∀ a b : α, ¬a ⋖ b :=\n  ⟨fun h _ _ => @not_covBy _ _ _ _ h, fun h =>\n    ⟨fun _ _ hab => exists_lt_lt_of_not_covBy hab <| h _ _⟩⟩\n\n"}
{"name":"toDual_covBy_toDual_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : α\n⊢ Iff (CovBy (OrderDual.toDual b) (OrderDual.toDual a)) (CovBy a b)","decl":"@[simp]\ntheorem toDual_covBy_toDual_iff : toDual b ⋖ toDual a ↔ a ⋖ b :=\n  and_congr_right' <| forall_congr' fun _ => forall_swap\n\n"}
{"name":"ofDual_covBy_ofDual_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : OrderDual α\n⊢ Iff (CovBy (OrderDual.ofDual a) (OrderDual.ofDual b)) (CovBy b a)","decl":"@[simp]\ntheorem ofDual_covBy_ofDual_iff {a b : αᵒᵈ} : ofDual a ⋖ ofDual b ↔ b ⋖ a :=\n  and_congr_right' <| forall_congr' fun _ => forall_swap\n\n"}
{"name":"CovBy.toDual","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : α\na✝ : CovBy a b\n⊢ CovBy (OrderDual.toDual b) (OrderDual.toDual a)","decl":"alias ⟨_, CovBy.toDual⟩ := toDual_covBy_toDual_iff\n\n"}
{"name":"CovBy.ofDual","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LT α\na b : OrderDual α\na✝ : CovBy b a\n⊢ CovBy (OrderDual.ofDual a) (OrderDual.ofDual b)","decl":"alias ⟨_, CovBy.ofDual⟩ := ofDual_covBy_ofDual_iff\n\n"}
{"name":"CovBy.le","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : CovBy a b\n⊢ LE.le a b","decl":"theorem CovBy.le (h : a ⋖ b) : a ≤ b :=\n  h.1.le\n\n"}
{"name":"CovBy.ne","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : CovBy a b\n⊢ Ne a b","decl":"protected theorem CovBy.ne (h : a ⋖ b) : a ≠ b :=\n  h.lt.ne\n\n"}
{"name":"CovBy.ne'","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : CovBy a b\n⊢ Ne b a","decl":"theorem CovBy.ne' (h : a ⋖ b) : b ≠ a :=\n  h.lt.ne'\n\n"}
{"name":"CovBy.wcovBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : CovBy a b\n⊢ WCovBy a b","decl":"protected theorem CovBy.wcovBy (h : a ⋖ b) : a ⩿ b :=\n  ⟨h.le, h.2⟩\n\n"}
{"name":"WCovBy.covBy_of_not_le","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : WCovBy a b\nh2 : Not (LE.le b a)\n⊢ CovBy a b","decl":"theorem WCovBy.covBy_of_not_le (h : a ⩿ b) (h2 : ¬b ≤ a) : a ⋖ b :=\n  ⟨h.le.lt_of_not_le h2, h.2⟩\n\n"}
{"name":"WCovBy.covBy_of_lt","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : WCovBy a b\nh2 : LT.lt a b\n⊢ CovBy a b","decl":"theorem WCovBy.covBy_of_lt (h : a ⩿ b) (h2 : a < b) : a ⋖ b :=\n  ⟨h2, h.2⟩\n\n"}
{"name":"CovBy.of_le_of_lt","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhac : CovBy a c\nhab : LE.le a b\nhbc : LT.lt b c\n⊢ CovBy b c","decl":"lemma CovBy.of_le_of_lt (hac : a ⋖ c) (hab : a ≤ b) (hbc : b < c) : b ⋖ c :=\n  ⟨hbc, fun _x hbx hxc ↦ hac.2 (hab.trans_lt hbx) hxc⟩\n\n"}
{"name":"CovBy.of_lt_of_le","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhac : CovBy a c\nhab : LT.lt a b\nhbc : LE.le b c\n⊢ CovBy a b","decl":"lemma CovBy.of_lt_of_le (hac : a ⋖ c) (hab : a < b) (hbc : b ≤ c) : a ⋖ b :=\n  ⟨hab, fun _x hax hxb ↦ hac.2 hax <| hxb.trans_le hbc⟩\n\n"}
{"name":"not_covBy_of_lt_of_lt","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nh₁ : LT.lt a b\nh₂ : LT.lt b c\n⊢ Not (CovBy a c)","decl":"theorem not_covBy_of_lt_of_lt (h₁ : a < b) (h₂ : b < c) : ¬a ⋖ c :=\n  (not_covBy_iff (h₁.trans h₂)).2 ⟨b, h₁, h₂⟩\n\n"}
{"name":"covBy_iff_wcovBy_and_lt","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (CovBy a b) (And (WCovBy a b) (LT.lt a b))","decl":"theorem covBy_iff_wcovBy_and_lt : a ⋖ b ↔ a ⩿ b ∧ a < b :=\n  ⟨fun h => ⟨h.wcovBy, h.lt⟩, fun h => h.1.covBy_of_lt h.2⟩\n\n"}
{"name":"covBy_iff_wcovBy_and_not_le","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (CovBy a b) (And (WCovBy a b) (Not (LE.le b a)))","decl":"theorem covBy_iff_wcovBy_and_not_le : a ⋖ b ↔ a ⩿ b ∧ ¬b ≤ a :=\n  ⟨fun h => ⟨h.wcovBy, h.lt.not_le⟩, fun h => h.1.covBy_of_not_le h.2⟩\n\n"}
{"name":"wcovBy_iff_covBy_or_le_and_le","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (WCovBy a b) (Or (CovBy a b) (And (LE.le a b) (LE.le b a)))","decl":"theorem wcovBy_iff_covBy_or_le_and_le : a ⩿ b ↔ a ⋖ b ∨ a ≤ b ∧ b ≤ a :=\n  ⟨fun h => or_iff_not_imp_right.mpr fun h' => h.covBy_of_not_le fun hba => h' ⟨h.le, hba⟩,\n    fun h' => h'.elim (fun h => h.wcovBy) fun h => h.1.wcovBy_of_le h.2⟩\n\n"}
{"name":"WCovBy.covBy_or_le_and_le","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\na✝ : WCovBy a b\n⊢ Or (CovBy a b) (And (LE.le a b) (LE.le b a))","decl":"alias ⟨WCovBy.covBy_or_le_and_le, _⟩ := wcovBy_iff_covBy_or_le_and_le\n\n"}
{"name":"AntisymmRel.trans_covBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : AntisymmRel (fun x1 x2 => LE.le x1 x2) a b\nhbc : CovBy b c\n⊢ CovBy a c","decl":"theorem AntisymmRel.trans_covBy (hab : AntisymmRel (· ≤ ·) a b) (hbc : b ⋖ c) : a ⋖ c :=\n  ⟨hab.1.trans_lt hbc.lt, fun _ had hdc => hbc.2 (hab.2.trans_lt had) hdc⟩\n\n"}
{"name":"covBy_congr_left","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : AntisymmRel (fun x1 x2 => LE.le x1 x2) a b\n⊢ Iff (CovBy a c) (CovBy b c)","decl":"theorem covBy_congr_left (hab : AntisymmRel (· ≤ ·) a b) : a ⋖ c ↔ b ⋖ c :=\n  ⟨hab.symm.trans_covBy, hab.trans_covBy⟩\n\n"}
{"name":"CovBy.trans_antisymmRel","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : CovBy a b\nhbc : AntisymmRel (fun x1 x2 => LE.le x1 x2) b c\n⊢ CovBy a c","decl":"theorem CovBy.trans_antisymmRel (hab : a ⋖ b) (hbc : AntisymmRel (· ≤ ·) b c) : a ⋖ c :=\n  ⟨hab.lt.trans_le hbc.1, fun _ had hdb => hab.2 had <| hdb.trans_le hbc.2⟩\n\n"}
{"name":"covBy_congr_right","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhab : AntisymmRel (fun x1 x2 => LE.le x1 x2) a b\n⊢ Iff (CovBy c a) (CovBy c b)","decl":"theorem covBy_congr_right (hab : AntisymmRel (· ≤ ·) a b) : c ⋖ a ↔ c ⋖ b :=\n  ⟨fun h => h.trans_antisymmRel hab, fun h => h.trans_antisymmRel hab.symm⟩\n\n"}
{"name":"instIsNonstrictStrictOrderWCovByCovBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ IsNonstrictStrictOrder α (fun x1 x2 => WCovBy x1 x2) fun x1 x2 => CovBy x1 x2","decl":"instance : IsNonstrictStrictOrder α (· ⩿ ·) (· ⋖ ·) :=\n  ⟨fun _ _ =>\n    covBy_iff_wcovBy_and_not_le.trans <| and_congr_right fun h => h.wcovBy_iff_le.not.symm⟩\n\n"}
{"name":"CovBy.isIrrefl","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ IsIrrefl α fun x1 x2 => CovBy x1 x2","decl":"instance CovBy.isIrrefl : IsIrrefl α (· ⋖ ·) :=\n  ⟨fun _ ha => ha.ne rfl⟩\n\n"}
{"name":"CovBy.Ioo_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : CovBy a b\n⊢ Eq (Set.Ioo a b) EmptyCollection.emptyCollection","decl":"theorem CovBy.Ioo_eq (h : a ⋖ b) : Ioo a b = ∅ :=\n  h.wcovBy.Ioo_eq\n\n"}
{"name":"covBy_iff_Ioo_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (CovBy a b) (And (LT.lt a b) (Eq (Set.Ioo a b) EmptyCollection.emptyCollection))","decl":"theorem covBy_iff_Ioo_eq : a ⋖ b ↔ a < b ∧ Ioo a b = ∅ :=\n  and_congr_right' <| by simp [eq_empty_iff_forall_not_mem]\n\n"}
{"name":"CovBy.of_image","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na b : α\nf : OrderEmbedding α β\nh : CovBy (f a) (f b)\n⊢ CovBy a b","decl":"theorem CovBy.of_image (f : α ↪o β) (h : f a ⋖ f b) : a ⋖ b :=\n  ⟨f.lt_iff_lt.mp h.lt, fun _ hac hcb => h.2 (f.lt_iff_lt.mpr hac) (f.lt_iff_lt.mpr hcb)⟩\n\n"}
{"name":"CovBy.image","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na b : α\nf : OrderEmbedding α β\nhab : CovBy a b\nh : (Set.range ⇑f).OrdConnected\n⊢ CovBy (f a) (f b)","decl":"theorem CovBy.image (f : α ↪o β) (hab : a ⋖ b) (h : (range f).OrdConnected) : f a ⋖ f b :=\n  (hab.wcovBy.image f h).covBy_of_lt <| f.strictMono hab.lt\n\n"}
{"name":"Set.OrdConnected.apply_covBy_apply_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na b : α\nf : OrderEmbedding α β\nh : (Set.range ⇑f).OrdConnected\n⊢ Iff (CovBy (f a) (f b)) (CovBy a b)","decl":"theorem Set.OrdConnected.apply_covBy_apply_iff (f : α ↪o β) (h : (range f).OrdConnected) :\n    f a ⋖ f b ↔ a ⋖ b :=\n  ⟨CovBy.of_image f, fun hab => hab.image f h⟩\n\n"}
{"name":"apply_covBy_apply_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\na b : α\nE : Type u_3\ninst✝¹ : EquivLike E α β\ninst✝ : OrderIsoClass E α β\ne : E\n⊢ Iff (CovBy (e a) (e b)) (CovBy a b)","decl":"@[simp]\ntheorem apply_covBy_apply_iff {E : Type*} [EquivLike E α β] [OrderIsoClass E α β] (e : E) :\n    e a ⋖ e b ↔ a ⋖ b :=\n  (ordConnected_range (e : α ≃o β)).apply_covBy_apply_iff ((e : α ≃o β) : α ↪o β)\n\n"}
{"name":"covBy_of_eq_or_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LT.lt a b\nh : ∀ (c : α), LE.le a c → LE.le c b → Or (Eq c a) (Eq c b)\n⊢ CovBy a b","decl":"theorem covBy_of_eq_or_eq (hab : a < b) (h : ∀ c, a ≤ c → c ≤ b → c = a ∨ c = b) : a ⋖ b :=\n  ⟨hab, fun c ha hb => (h c ha.le hb.le).elim ha.ne' hb.ne⟩\n\n"}
{"name":"OrderEmbedding.covBy_of_apply","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderEmbedding α β\nx y : α\nh : CovBy (f x) (f y)\n⊢ CovBy x y","decl":"theorem OrderEmbedding.covBy_of_apply {α β : Type*} [Preorder α] [Preorder β]\n    (f : α ↪o β) {x y : α} (h : f x ⋖ f y) : x ⋖ y := by\n  use f.lt_iff_lt.1 h.1\n  intro a\n  rw [← f.lt_iff_lt, ← f.lt_iff_lt]\n  apply h.2\n\n"}
{"name":"OrderIso.map_covBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\nx y : α\n⊢ Iff (CovBy (f x) (f y)) (CovBy x y)","decl":"theorem OrderIso.map_covBy {α β : Type*} [Preorder α] [Preorder β]\n    (f : α ≃o β) {x y : α} : f x ⋖ f y ↔ x ⋖ y := by\n  use f.toOrderEmbedding.covBy_of_apply\n  conv_lhs => rw [← f.symm_apply_apply x, ← f.symm_apply_apply y]\n  exact f.symm.toOrderEmbedding.covBy_of_apply\n\n"}
{"name":"WCovBy.covBy_of_ne","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : WCovBy a b\nh2 : Ne a b\n⊢ CovBy a b","decl":"theorem WCovBy.covBy_of_ne (h : a ⩿ b) (h2 : a ≠ b) : a ⋖ b :=\n  ⟨h.le.lt_of_ne h2, h.2⟩\n\n"}
{"name":"covBy_iff_wcovBy_and_ne","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (CovBy a b) (And (WCovBy a b) (Ne a b))","decl":"theorem covBy_iff_wcovBy_and_ne : a ⋖ b ↔ a ⩿ b ∧ a ≠ b :=\n  ⟨fun h => ⟨h.wcovBy, h.ne⟩, fun h => h.1.covBy_of_ne h.2⟩\n\n"}
{"name":"wcovBy_iff_covBy_or_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (WCovBy a b) (Or (CovBy a b) (Eq a b))","decl":"theorem wcovBy_iff_covBy_or_eq : a ⩿ b ↔ a ⋖ b ∨ a = b := by\n  rw [le_antisymm_iff, wcovBy_iff_covBy_or_le_and_le]\n\n"}
{"name":"wcovBy_iff_eq_or_covBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (WCovBy a b) (Or (Eq a b) (CovBy a b))","decl":"theorem wcovBy_iff_eq_or_covBy : a ⩿ b ↔ a = b ∨ a ⋖ b :=\n  wcovBy_iff_covBy_or_eq.trans or_comm\n\n"}
{"name":"WCovBy.covBy_or_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\na✝ : WCovBy a b\n⊢ Or (CovBy a b) (Eq a b)","decl":"alias ⟨WCovBy.covBy_or_eq, _⟩ := wcovBy_iff_covBy_or_eq\n\n"}
{"name":"WCovBy.eq_or_covBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\na✝ : WCovBy a b\n⊢ Or (Eq a b) (CovBy a b)","decl":"alias ⟨WCovBy.eq_or_covBy, _⟩ := wcovBy_iff_eq_or_covBy\n\n"}
{"name":"CovBy.eq_or_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b c : α\nh : CovBy a b\nh2 : LE.le a c\nh3 : LE.le c b\n⊢ Or (Eq c a) (Eq c b)","decl":"theorem CovBy.eq_or_eq (h : a ⋖ b) (h2 : a ≤ c) (h3 : c ≤ b) : c = a ∨ c = b :=\n  h.wcovBy.eq_or_eq h2 h3\n\n"}
{"name":"covBy_iff_lt_and_eq_or_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (CovBy a b) (And (LT.lt a b) (∀ (c : α), LE.le a c → LE.le c b → Or (Eq c a) (Eq c b)))","decl":"/-- An `iff` version of `CovBy.eq_or_eq` and `covBy_of_eq_or_eq`. -/\ntheorem covBy_iff_lt_and_eq_or_eq : a ⋖ b ↔ a < b ∧ ∀ c, a ≤ c → c ≤ b → c = a ∨ c = b :=\n  ⟨fun h => ⟨h.lt, fun _ => h.eq_or_eq⟩, And.rec covBy_of_eq_or_eq⟩\n\n"}
{"name":"CovBy.Ico_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : CovBy a b\n⊢ Eq (Set.Ico a b) (Singleton.singleton a)","decl":"theorem CovBy.Ico_eq (h : a ⋖ b) : Ico a b = {a} := by\n  rw [← Ioo_union_left h.lt, h.Ioo_eq, empty_union]\n\n"}
{"name":"CovBy.Ioc_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : CovBy a b\n⊢ Eq (Set.Ioc a b) (Singleton.singleton b)","decl":"theorem CovBy.Ioc_eq (h : a ⋖ b) : Ioc a b = {b} := by\n  rw [← Ioo_union_right h.lt, h.Ioo_eq, empty_union]\n\n"}
{"name":"CovBy.Icc_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : CovBy a b\n⊢ Eq (Set.Icc a b) (Insert.insert a (Singleton.singleton b))","decl":"theorem CovBy.Icc_eq (h : a ⋖ b) : Icc a b = {a, b} :=\n  h.wcovBy.Icc_eq\n\n"}
{"name":"CovBy.Ioi_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : CovBy a b\n⊢ Eq (Set.Ioi a) (Set.Ici b)","decl":"theorem CovBy.Ioi_eq (h : a ⋖ b) : Ioi a = Ici b := by\n  rw [← Ioo_union_Ici_eq_Ioi h.lt, h.Ioo_eq, empty_union]\n\n"}
{"name":"CovBy.Iio_eq","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : CovBy a b\n⊢ Eq (Set.Iio b) (Set.Iic a)","decl":"theorem CovBy.Iio_eq (h : a ⋖ b) : Iio b = Iic a := by\n  rw [← Iic_union_Ioo_eq_Iio h.lt, h.Ioo_eq, union_empty]\n\n"}
{"name":"WCovBy.le_of_lt","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nhab : WCovBy a b\nhcb : LT.lt c b\n⊢ LE.le c a","decl":"theorem WCovBy.le_of_lt (hab : a ⩿ b) (hcb : c < b) : c ≤ a :=\n  not_lt.1 fun hac => hab.2 hac hcb\n\n"}
{"name":"WCovBy.ge_of_gt","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nhab : WCovBy a b\nhac : LT.lt a c\n⊢ LE.le b c","decl":"theorem WCovBy.ge_of_gt (hab : a ⩿ b) (hac : a < c) : b ≤ c :=\n  not_lt.1 <| hab.2 hac\n\n"}
{"name":"CovBy.le_of_lt","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nhab : CovBy a b\na✝ : LT.lt c b\n⊢ LE.le c a","decl":"theorem CovBy.le_of_lt (hab : a ⋖ b) : c < b → c ≤ a :=\n  hab.wcovBy.le_of_lt\n\n"}
{"name":"CovBy.ge_of_gt","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nhab : CovBy a b\na✝ : LT.lt a c\n⊢ LE.le b c","decl":"theorem CovBy.ge_of_gt (hab : a ⋖ b) : a < c → b ≤ c :=\n  hab.wcovBy.ge_of_gt\n\n"}
{"name":"CovBy.unique_left","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nha : CovBy a c\nhb : CovBy b c\n⊢ Eq a b","decl":"theorem CovBy.unique_left (ha : a ⋖ c) (hb : b ⋖ c) : a = b :=\n  (hb.le_of_lt ha.lt).antisymm <| ha.le_of_lt hb.lt\n\n"}
{"name":"CovBy.unique_right","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nhb : CovBy a b\nhc : CovBy a c\n⊢ Eq b c","decl":"theorem CovBy.unique_right (hb : a ⋖ b) (hc : a ⋖ c) : b = c :=\n  (hb.ge_of_gt hc.lt).antisymm <| hc.ge_of_gt hb.lt\n\n"}
{"name":"CovBy.eq_of_between","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c x : α\nhab : CovBy a b\nhbc : CovBy b c\nhax : LT.lt a x\nhxc : LT.lt x c\n⊢ Eq x b","decl":"/-- If `a`, `b`, `c` are consecutive and `a < x < c` then `x = b`. -/\ntheorem CovBy.eq_of_between {x : α} (hab : a ⋖ b) (hbc : b ⋖ c) (hax : a < x) (hxc : x < c) :\n    x = b :=\n  le_antisymm (le_of_not_lt fun h => hbc.2 h hxc) (le_of_not_lt <| hab.2 hax)\n\n"}
{"name":"covBy_iff_lt_iff_le_left","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\n⊢ Iff (CovBy x y) (∀ {z : α}, Iff (LT.lt z y) (LE.le z x))","decl":"theorem covBy_iff_lt_iff_le_left {x y : α} : x ⋖ y ↔ ∀ {z}, z < y ↔ z ≤ x where\n  mp := fun hx _z ↦ ⟨hx.le_of_lt, fun hz ↦ hz.trans_lt hx.lt⟩\n  mpr := fun H ↦ ⟨H.2 le_rfl, fun _z hx hz ↦ (H.1 hz).not_lt hx⟩\n\n"}
{"name":"covBy_iff_le_iff_lt_left","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\n⊢ Iff (CovBy x y) (∀ {z : α}, Iff (LE.le z x) (LT.lt z y))","decl":"theorem covBy_iff_le_iff_lt_left {x y : α} : x ⋖ y ↔ ∀ {z}, z ≤ x ↔ z < y := by\n  simp_rw [covBy_iff_lt_iff_le_left, iff_comm]\n\n"}
{"name":"covBy_iff_lt_iff_le_right","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\n⊢ Iff (CovBy x y) (∀ {z : α}, Iff (LT.lt x z) (LE.le y z))","decl":"theorem covBy_iff_lt_iff_le_right {x y : α} : x ⋖ y ↔ ∀ {z}, x < z ↔ y ≤ z := by\n  trans ∀ {z}, ¬ z ≤ x ↔ ¬ z < y\n  · simp_rw [covBy_iff_le_iff_lt_left, not_iff_not]\n  · simp\n\n"}
{"name":"covBy_iff_le_iff_lt_right","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\n⊢ Iff (CovBy x y) (∀ {z : α}, Iff (LE.le y z) (LT.lt x z))","decl":"theorem covBy_iff_le_iff_lt_right {x y : α} : x ⋖ y ↔ ∀ {z}, y ≤ z ↔ x < z := by\n  simp_rw [covBy_iff_lt_iff_le_right, iff_comm]\n\n"}
{"name":"CovBy.lt_iff_le_left","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\na✝ : CovBy x y\nz : α\n⊢ Iff (LT.lt z y) (LE.le z x)","decl":"alias ⟨CovBy.lt_iff_le_left, _⟩ := covBy_iff_lt_iff_le_left\n"}
{"name":"CovBy.le_iff_lt_left","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\na✝ : CovBy x y\nz : α\n⊢ Iff (LE.le z x) (LT.lt z y)","decl":"alias ⟨CovBy.le_iff_lt_left, _⟩ := covBy_iff_le_iff_lt_left\n"}
{"name":"CovBy.lt_iff_le_right","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\na✝ : CovBy x y\nz : α\n⊢ Iff (LT.lt x z) (LE.le y z)","decl":"alias ⟨CovBy.lt_iff_le_right, _⟩ := covBy_iff_lt_iff_le_right\n"}
{"name":"CovBy.le_iff_lt_right","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\na✝ : CovBy x y\nz : α\n⊢ Iff (LE.le y z) (LT.lt x z)","decl":"alias ⟨CovBy.le_iff_lt_right, _⟩ := covBy_iff_le_iff_lt_right\n\n"}
{"name":"LT.lt.exists_disjoint_Iio_Ioi","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LT.lt a b\n⊢ Exists fun a' => And (GT.gt a' a) (Exists fun b' => And (LT.lt b' b) (∀ (x : α), LT.lt x a' → ∀ (y : α), GT.gt y b' → LT.lt x y))","decl":"/-- If `a < b` then there exist `a' > a` and `b' < b` such that `Set.Iio a'` is strictly to the left\nof `Set.Ioi b'`. -/\nlemma LT.lt.exists_disjoint_Iio_Ioi (h : a < b) :\n    ∃ a' > a, ∃ b' < b, ∀ x < a', ∀ y > b', x < y := by\n  by_cases h' : a ⋖ b\n  · exact ⟨b, h, a, h, fun x hx y hy => hx.trans_le <| h'.ge_of_gt hy⟩\n  · rcases h.exists_lt_lt h' with ⟨c, ha, hb⟩\n    exact ⟨c, ha, c, hb, fun _ h₁ _ => lt_trans h₁⟩\n\n"}
{"name":"Set.wcovBy_insert","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nx : α\ns : Set α\n⊢ WCovBy s (Insert.insert x s)","decl":"@[simp] lemma wcovBy_insert (x : α) (s : Set α) : s ⩿ insert x s := by\n  refine wcovBy_of_eq_or_eq (subset_insert x s) fun t hst h2t => ?_\n  by_cases h : x ∈ t\n  · exact Or.inr (subset_antisymm h2t <| insert_subset_iff.mpr ⟨h, hst⟩)\n  · refine Or.inl (subset_antisymm ?_ hst)\n    rwa [← diff_singleton_eq_self h, diff_singleton_subset_iff]\n\n"}
{"name":"Set.sdiff_singleton_wcovBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ns : Set α\na : α\n⊢ WCovBy (SDiff.sdiff s (Singleton.singleton a)) s","decl":"@[simp] lemma sdiff_singleton_wcovBy (s : Set α) (a : α) : s \\ {a} ⩿ s := by\n  by_cases ha : a ∈ s\n  · convert wcovBy_insert a _\n    ext\n    simp [ha]\n  · simp [ha]\n\n"}
{"name":"Set.covBy_insert","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ns : Set α\na : α\nha : Not (Membership.mem s a)\n⊢ CovBy s (Insert.insert a s)","decl":"@[simp] lemma covBy_insert (ha : a ∉ s) : s ⋖ insert a s :=\n  (wcovBy_insert _ _).covBy_of_lt <| ssubset_insert ha\n\n"}
{"name":"Set.sdiff_singleton_covBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ns : Set α\na : α\nha : Membership.mem s a\n⊢ CovBy (SDiff.sdiff s (Singleton.singleton a)) s","decl":"@[simp] lemma sdiff_singleton_covBy (ha : a ∈ s) : s \\ {a} ⋖ s :=\n  ⟨sdiff_lt (singleton_subset_iff.2 ha) <| singleton_ne_empty _, (sdiff_singleton_wcovBy _ _).2⟩\n\n"}
{"name":"CovBy.exists_set_insert","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ns t : Set α\nh : CovBy s t\n⊢ Exists fun a => And (Not (Membership.mem s a)) (Eq (Insert.insert a s) t)","decl":"lemma _root_.CovBy.exists_set_insert (h : s ⋖ t) : ∃ a ∉ s, insert a s = t :=\n  let ⟨a, ha, hst⟩ := ssubset_iff_insert.1 h.lt\n  ⟨a, ha, (hst.eq_of_not_ssuperset <| h.2 <| ssubset_insert ha).symm⟩\n\n"}
{"name":"CovBy.exists_set_sdiff_singleton","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ns t : Set α\nh : CovBy s t\n⊢ Exists fun a => And (Membership.mem t a) (Eq (SDiff.sdiff t (Singleton.singleton a)) s)","decl":"lemma _root_.CovBy.exists_set_sdiff_singleton (h : s ⋖ t) : ∃ a ∈ t, t \\ {a} =  s :=\n  let ⟨a, ha, hst⟩ := ssubset_iff_sdiff_singleton.1 h.lt\n  ⟨a, ha, (hst.eq_of_not_ssubset fun h' ↦ h.2 h' <|\n    sdiff_lt (singleton_subset_iff.2 ha) <| singleton_ne_empty _).symm⟩\n\n"}
{"name":"Set.covBy_iff_exists_insert","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Iff (CovBy s t) (Exists fun a => And (Not (Membership.mem s a)) (Eq (Insert.insert a s) t))","decl":"lemma covBy_iff_exists_insert : s ⋖ t ↔ ∃ a ∉ s, insert a s = t :=\n  ⟨CovBy.exists_set_insert, by rintro ⟨a, ha, rfl⟩; exact covBy_insert ha⟩\n\n"}
{"name":"Set.covBy_iff_exists_sdiff_singleton","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Iff (CovBy s t) (Exists fun a => And (Membership.mem t a) (Eq (SDiff.sdiff t (Singleton.singleton a)) s))","decl":"lemma covBy_iff_exists_sdiff_singleton : s ⋖ t ↔ ∃ a ∈ t, t \\ {a} = s :=\n  ⟨CovBy.exists_set_sdiff_singleton, by rintro ⟨a, ha, rfl⟩; exact sdiff_singleton_covBy ha⟩\n\n"}
{"name":"wcovBy_eq_reflGen_covBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Eq (fun x1 x2 => WCovBy x1 x2) (Relation.ReflGen fun x1 x2 => CovBy x1 x2)","decl":"lemma wcovBy_eq_reflGen_covBy [PartialOrder α] : ((· : α) ⩿ ·) = ReflGen (· ⋖ ·) := by\n  ext x y; simp_rw [wcovBy_iff_eq_or_covBy, @eq_comm _ x, reflGen_iff]\n\n"}
{"name":"transGen_wcovBy_eq_reflTransGen_covBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Eq (Relation.TransGen fun x1 x2 => WCovBy x1 x2) (Relation.ReflTransGen fun x1 x2 => CovBy x1 x2)","decl":"lemma transGen_wcovBy_eq_reflTransGen_covBy [PartialOrder α] :\n    TransGen ((· : α) ⩿ ·) = ReflTransGen (· ⋖ ·) := by\n  rw [wcovBy_eq_reflGen_covBy, transGen_reflGen]\n\n"}
{"name":"reflTransGen_wcovBy_eq_reflTransGen_covBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Eq (Relation.ReflTransGen fun x1 x2 => WCovBy x1 x2) (Relation.ReflTransGen fun x1 x2 => CovBy x1 x2)","decl":"lemma reflTransGen_wcovBy_eq_reflTransGen_covBy [PartialOrder α] :\n    ReflTransGen ((· : α) ⩿ ·) = ReflTransGen (· ⋖ ·) := by\n  rw [wcovBy_eq_reflGen_covBy, reflTransGen_reflGen]\n\n"}
{"name":"Prod.swap_wcovBy_swap","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nx y : Prod α β\n⊢ Iff (WCovBy x.swap y.swap) (WCovBy x y)","decl":"@[simp]\ntheorem swap_wcovBy_swap : x.swap ⩿ y.swap ↔ x ⩿ y :=\n  apply_wcovBy_apply_iff (OrderIso.prodComm : α × β ≃o β × α)\n\n"}
{"name":"Prod.swap_covBy_swap","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nx y : Prod α β\n⊢ Iff (CovBy x.swap y.swap) (CovBy x y)","decl":"@[simp]\ntheorem swap_covBy_swap : x.swap ⋖ y.swap ↔ x ⋖ y :=\n  apply_covBy_apply_iff (OrderIso.prodComm : α × β ≃o β × α)\n\n"}
{"name":"Prod.fst_eq_or_snd_eq_of_wcovBy","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nx y : Prod α β\na✝ : WCovBy x y\n⊢ Or (Eq x.1 y.1) (Eq x.2 y.2)","decl":"theorem fst_eq_or_snd_eq_of_wcovBy : x ⩿ y → x.1 = y.1 ∨ x.2 = y.2 := by\n  refine fun h => of_not_not fun hab => ?_\n  push_neg at hab\n  exact\n    h.2 (mk_lt_mk.2 <| Or.inl ⟨hab.1.lt_of_le h.1.1, le_rfl⟩)\n      (mk_lt_mk.2 <| Or.inr ⟨le_rfl, hab.2.lt_of_le h.1.2⟩)\n\n"}
{"name":"WCovBy.fst","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nx y : Prod α β\nh : WCovBy x y\n⊢ WCovBy x.1 y.1","decl":"theorem _root_.WCovBy.fst (h : x ⩿ y) : x.1 ⩿ y.1 :=\n  ⟨h.1.1, fun _ h₁ h₂ => h.2 (mk_lt_mk_iff_left.2 h₁) ⟨⟨h₂.le, h.1.2⟩, fun hc => h₂.not_le hc.1⟩⟩\n\n"}
{"name":"WCovBy.snd","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nx y : Prod α β\nh : WCovBy x y\n⊢ WCovBy x.2 y.2","decl":"theorem _root_.WCovBy.snd (h : x ⩿ y) : x.2 ⩿ y.2 :=\n  ⟨h.1.2, fun _ h₁ h₂ => h.2 (mk_lt_mk_iff_right.2 h₁) ⟨⟨h.1.1, h₂.le⟩, fun hc => h₂.not_le hc.2⟩⟩\n\n"}
{"name":"Prod.mk_wcovBy_mk_iff_left","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\na₁ a₂ : α\nb : β\n⊢ Iff (WCovBy { fst := a₁, snd := b } { fst := a₂, snd := b }) (WCovBy a₁ a₂)","decl":"theorem mk_wcovBy_mk_iff_left : (a₁, b) ⩿ (a₂, b) ↔ a₁ ⩿ a₂ := by\n  refine ⟨WCovBy.fst, (And.imp mk_le_mk_iff_left.2) fun h c h₁ h₂ => ?_⟩\n  have : c.2 = b := h₂.le.2.antisymm h₁.le.2\n  rw [← @Prod.mk.eta _ _ c, this, mk_lt_mk_iff_left] at h₁ h₂\n  exact h h₁ h₂\n\n"}
{"name":"Prod.mk_wcovBy_mk_iff_right","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\na : α\nb₁ b₂ : β\n⊢ Iff (WCovBy { fst := a, snd := b₁ } { fst := a, snd := b₂ }) (WCovBy b₁ b₂)","decl":"theorem mk_wcovBy_mk_iff_right : (a, b₁) ⩿ (a, b₂) ↔ b₁ ⩿ b₂ :=\n  swap_wcovBy_swap.trans mk_wcovBy_mk_iff_left\n\n"}
{"name":"Prod.mk_covBy_mk_iff_left","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\na₁ a₂ : α\nb : β\n⊢ Iff (CovBy { fst := a₁, snd := b } { fst := a₂, snd := b }) (CovBy a₁ a₂)","decl":"theorem mk_covBy_mk_iff_left : (a₁, b) ⋖ (a₂, b) ↔ a₁ ⋖ a₂ := by\n  simp_rw [covBy_iff_wcovBy_and_lt, mk_wcovBy_mk_iff_left, mk_lt_mk_iff_left]\n\n"}
{"name":"Prod.mk_covBy_mk_iff_right","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\na : α\nb₁ b₂ : β\n⊢ Iff (CovBy { fst := a, snd := b₁ } { fst := a, snd := b₂ }) (CovBy b₁ b₂)","decl":"theorem mk_covBy_mk_iff_right : (a, b₁) ⋖ (a, b₂) ↔ b₁ ⋖ b₂ := by\n  simp_rw [covBy_iff_wcovBy_and_lt, mk_wcovBy_mk_iff_right, mk_lt_mk_iff_right]\n\n"}
{"name":"Prod.mk_wcovBy_mk_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Iff (WCovBy { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) (Or (And (WCovBy a₁ a₂) (Eq b₁ b₂)) (And (WCovBy b₁ b₂) (Eq a₁ a₂)))","decl":"theorem mk_wcovBy_mk_iff : (a₁, b₁) ⩿ (a₂, b₂) ↔ a₁ ⩿ a₂ ∧ b₁ = b₂ ∨ b₁ ⩿ b₂ ∧ a₁ = a₂ := by\n  refine ⟨fun h => ?_, ?_⟩\n  · obtain rfl | rfl : a₁ = a₂ ∨ b₁ = b₂ := fst_eq_or_snd_eq_of_wcovBy h\n    · exact Or.inr ⟨mk_wcovBy_mk_iff_right.1 h, rfl⟩\n    · exact Or.inl ⟨mk_wcovBy_mk_iff_left.1 h, rfl⟩\n  · rintro (⟨h, rfl⟩ | ⟨h, rfl⟩)\n    · exact mk_wcovBy_mk_iff_left.2 h\n    · exact mk_wcovBy_mk_iff_right.2 h\n\n"}
{"name":"Prod.mk_covBy_mk_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Iff (CovBy { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }) (Or (And (CovBy a₁ a₂) (Eq b₁ b₂)) (And (CovBy b₁ b₂) (Eq a₁ a₂)))","decl":"theorem mk_covBy_mk_iff : (a₁, b₁) ⋖ (a₂, b₂) ↔ a₁ ⋖ a₂ ∧ b₁ = b₂ ∨ b₁ ⋖ b₂ ∧ a₁ = a₂ := by\n  refine ⟨fun h => ?_, ?_⟩\n  · obtain rfl | rfl : a₁ = a₂ ∨ b₁ = b₂ := fst_eq_or_snd_eq_of_wcovBy h.wcovBy\n    · exact Or.inr ⟨mk_covBy_mk_iff_right.1 h, rfl⟩\n    · exact Or.inl ⟨mk_covBy_mk_iff_left.1 h, rfl⟩\n  · rintro (⟨h, rfl⟩ | ⟨h, rfl⟩)\n    · exact mk_covBy_mk_iff_left.2 h\n    · exact mk_covBy_mk_iff_right.2 h\n\n"}
{"name":"Prod.wcovBy_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nx y : Prod α β\n⊢ Iff (WCovBy x y) (Or (And (WCovBy x.1 y.1) (Eq x.2 y.2)) (And (WCovBy x.2 y.2) (Eq x.1 y.1)))","decl":"theorem wcovBy_iff : x ⩿ y ↔ x.1 ⩿ y.1 ∧ x.2 = y.2 ∨ x.2 ⩿ y.2 ∧ x.1 = y.1 := by\n  cases x\n  cases y\n  exact mk_wcovBy_mk_iff\n\n"}
{"name":"Prod.covBy_iff","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : PartialOrder β\nx y : Prod α β\n⊢ Iff (CovBy x y) (Or (And (CovBy x.1 y.1) (Eq x.2 y.2)) (And (CovBy x.2 y.2) (Eq x.1 y.1)))","decl":"theorem covBy_iff : x ⋖ y ↔ x.1 ⋖ y.1 ∧ x.2 = y.2 ∨ x.2 ⋖ y.2 ∧ x.1 = y.1 := by\n  cases x\n  cases y\n  exact mk_covBy_mk_iff\n\n"}
{"name":"WithTop.coe_wcovBy_coe","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (WCovBy ↑a ↑b) (WCovBy a b)","decl":"@[simp, norm_cast] lemma coe_wcovBy_coe : (a : WithTop α) ⩿ b ↔ a ⩿ b :=\n  Set.OrdConnected.apply_wcovBy_apply_iff OrderEmbedding.withTopCoe <| by\n    simp [WithTop.range_coe, ordConnected_Iio]\n\n"}
{"name":"WithTop.coe_covBy_coe","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (CovBy ↑a ↑b) (CovBy a b)","decl":"@[simp, norm_cast] lemma coe_covBy_coe : (a : WithTop α) ⋖ b ↔ a ⋖ b :=\n  Set.OrdConnected.apply_covBy_apply_iff OrderEmbedding.withTopCoe <| by\n    simp [WithTop.range_coe, ordConnected_Iio]\n\n"}
{"name":"WithTop.coe_covBy_top","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Iff (CovBy (↑a) Top.top) (IsMax a)","decl":"@[simp] lemma coe_covBy_top : (a : WithTop α) ⋖ ⊤ ↔ IsMax a := by\n  simp only [covBy_iff_Ioo_eq, ← image_coe_Ioi, coe_lt_top, image_eq_empty,\n    true_and, Ioi_eq_empty_iff]\n\n"}
{"name":"WithTop.coe_wcovBy_top","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Iff (WCovBy (↑a) Top.top) (IsMax a)","decl":"@[simp] lemma coe_wcovBy_top : (a : WithTop α) ⩿ ⊤ ↔ IsMax a := by\n  simp only [wcovBy_iff_Ioo_eq, ← image_coe_Ioi, le_top, image_eq_empty, true_and, Ioi_eq_empty_iff]\n\n"}
{"name":"WithBot.coe_wcovBy_coe","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (WCovBy ↑a ↑b) (WCovBy a b)","decl":"@[simp, norm_cast] lemma coe_wcovBy_coe : (a : WithBot α) ⩿ b ↔ a ⩿ b :=\n  Set.OrdConnected.apply_wcovBy_apply_iff OrderEmbedding.withBotCoe <| by\n    simp [WithBot.range_coe, ordConnected_Ioi]\n\n"}
{"name":"WithBot.coe_covBy_coe","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (CovBy ↑a ↑b) (CovBy a b)","decl":"@[simp, norm_cast] lemma coe_covBy_coe : (a : WithBot α) ⋖ b ↔ a ⋖ b :=\n  Set.OrdConnected.apply_covBy_apply_iff OrderEmbedding.withBotCoe <| by\n    simp [WithBot.range_coe, ordConnected_Ioi]\n\n"}
{"name":"WithBot.bot_covBy_coe","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Iff (CovBy Bot.bot ↑a) (IsMin a)","decl":"@[simp] lemma bot_covBy_coe : ⊥ ⋖ (a : WithBot α) ↔ IsMin a := by\n  simp only [covBy_iff_Ioo_eq, ← image_coe_Iio, bot_lt_coe, image_eq_empty,\n    true_and, Iio_eq_empty_iff]\n\n"}
{"name":"WithBot.bot_wcovBy_coe","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Iff (WCovBy Bot.bot ↑a) (IsMin a)","decl":"@[simp] lemma bot_wcovBy_coe : ⊥ ⩿ (a : WithBot α) ↔ IsMin a := by\n  simp only [wcovBy_iff_Ioo_eq, ← image_coe_Iio, bot_le, image_eq_empty, true_and, Iio_eq_empty_iff]\n\n"}
{"name":"exists_covBy_of_wellFoundedLT","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nwf : WellFoundedLT α\na : α\nh : Not (IsMax a)\n⊢ Exists fun a' => CovBy a a'","decl":"lemma exists_covBy_of_wellFoundedLT [wf : WellFoundedLT α] ⦃a : α⦄ (h : ¬ IsMax a) :\n    ∃ a', a ⋖ a' := by\n  rw [not_isMax_iff] at h\n  exact ⟨_, wellFounded_lt.min_mem _ h, fun a' ↦ wf.wf.not_lt_min _ h⟩\n\n"}
{"name":"exists_covBy_of_wellFoundedGT","module":"Mathlib.Order.Cover","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nwf : WellFoundedGT α\na : α\nh : Not (IsMin a)\n⊢ Exists fun a' => CovBy a' a","decl":"lemma exists_covBy_of_wellFoundedGT [wf : WellFoundedGT α] ⦃a : α⦄ (h : ¬ IsMin a) :\n    ∃ a', a' ⋖ a := by\n  rw [not_isMin_iff] at h\n  exact ⟨_, wf.wf.min_mem _ h, fun a' h₁ h₂ ↦ wf.wf.not_lt_min _ h h₂ h₁⟩\n\n"}
