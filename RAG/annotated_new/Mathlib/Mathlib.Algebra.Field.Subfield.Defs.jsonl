{"name":"SubfieldClass.toInvMemClass","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"S : Type u_1\nK : Type u_2\ninst✝¹ : DivisionRing K\ninst✝ : SetLike S K\nself : SubfieldClass S K\n⊢ InvMemClass S K","decl":"/-- `SubfieldClass S K` states `S` is a type of subsets `s ⊆ K` closed under field operations. -/\nclass SubfieldClass (S K : Type*) [DivisionRing K] [SetLike S K] extends SubringClass S K,\n  InvMemClass S K : Prop\n\n"}
{"name":"SubfieldClass.toSubringClass","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"S : Type u_1\nK : Type u_2\ninst✝¹ : DivisionRing K\ninst✝ : SetLike S K\nself : SubfieldClass S K\n⊢ SubringClass S K","decl":"/-- `SubfieldClass S K` states `S` is a type of subsets `s ⊆ K` closed under field operations. -/\nclass SubfieldClass (S K : Type*) [DivisionRing K] [SetLike S K] extends SubringClass S K,\n  InvMemClass S K : Prop\n\n"}
{"name":"SubfieldClass.toSubgroupClass","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nS : Type u_1\ninst✝ : SetLike S K\nh : SubfieldClass S K\n⊢ SubgroupClass S K","decl":"/-- A subfield contains `1`, products and inverses.\n\nBe assured that we're not actually proving that subfields are subgroups:\n`SubgroupClass` is really an abbreviation of `SubgroupWithOrWithoutZeroClass`.\n -/\ninstance (priority := 100) toSubgroupClass : SubgroupClass S K :=\n  { h with }\n\n"}
{"name":"SubfieldClass.nnratCast_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nS : Type u_1\ninst✝ : SetLike S K\nh : SubfieldClass S K\ns : S\nq : NNRat\n⊢ Membership.mem s ↑q","decl":"@[aesop safe apply (rule_sets := [SetLike])]\nlemma nnratCast_mem (s : S) (q : ℚ≥0) : (q : K) ∈ s := by\n  simpa only [NNRat.cast_def] using div_mem (natCast_mem s q.num) (natCast_mem s q.den)\n\n"}
{"name":"SubfieldClass.ratCast_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nS : Type u_1\ninst✝ : SetLike S K\nh : SubfieldClass S K\ns : S\nq : Rat\n⊢ Membership.mem s ↑q","decl":"@[aesop safe apply (rule_sets := [SetLike])]\nlemma ratCast_mem (s : S) (q : ℚ) : (q : K) ∈ s := by\n  simpa only [Rat.cast_def] using div_mem (intCast_mem s q.num) (natCast_mem s q.den)\n\n"}
{"name":"SubfieldClass.coe_nnratCast","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nS : Type u_1\ninst✝ : SetLike S K\nh : SubfieldClass S K\ns : S\nq : NNRat\n⊢ Eq ↑↑q ↑q","decl":"@[simp, norm_cast] lemma coe_nnratCast (s : S) (q : ℚ≥0) : ((q : s) : K) = q := rfl\n"}
{"name":"SubfieldClass.coe_ratCast","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nS : Type u_1\ninst✝ : SetLike S K\nh : SubfieldClass S K\ns : S\nx : Rat\n⊢ Eq ↑↑x ↑x","decl":"@[simp, norm_cast] lemma coe_ratCast (s : S) (x : ℚ) : ((x : s) : K) = x := rfl\n\n"}
{"name":"SubfieldClass.nnqsmul_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nS : Type u_1\ninst✝ : SetLike S K\nh : SubfieldClass S K\nx : K\ns : S\nq : NNRat\nhx : Membership.mem s x\n⊢ Membership.mem s (HSMul.hSMul q x)","decl":"@[aesop safe apply (rule_sets := [SetLike])]\nlemma nnqsmul_mem (s : S) (q : ℚ≥0) (hx : x ∈ s) : q • x ∈ s := by\n  simpa only [NNRat.smul_def] using mul_mem (nnratCast_mem _ _) hx\n\n"}
{"name":"SubfieldClass.qsmul_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nS : Type u_1\ninst✝ : SetLike S K\nh : SubfieldClass S K\nx : K\ns : S\nq : Rat\nhx : Membership.mem s x\n⊢ Membership.mem s (HSMul.hSMul q x)","decl":"@[aesop safe apply (rule_sets := [SetLike])]\nlemma qsmul_mem (s : S) (q : ℚ) (hx : x ∈ s) : q • x ∈ s := by\n  simpa only [Rat.smul_def] using mul_mem (ratCast_mem _ _) hx\n\n"}
{"name":"SubfieldClass.ofScientific_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nS : Type u_1\ninst✝ : SetLike S K\nh : SubfieldClass S K\ns : S\nb : Bool\nn m : Nat\n⊢ Membership.mem s (OfScientific.ofScientific n b m)","decl":"@[aesop safe apply (rule_sets := [SetLike])]\nlemma ofScientific_mem (s : S) {b : Bool} {n m : ℕ} :\n    (OfScientific.ofScientific n b m : K) ∈ s :=\n  SubfieldClass.nnratCast_mem s (OfScientific.ofScientific n b m)\n\n"}
{"name":"SubfieldClass.coe_nnqsmul","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nS : Type u_1\ninst✝ : SetLike S K\nh : SubfieldClass S K\ns : S\nq : NNRat\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(HSMul.hSMul q x)) (HSMul.hSMul q ↑x)","decl":"@[simp, norm_cast] lemma coe_nnqsmul (s : S) (q : ℚ≥0) (x : s) : ↑(q • x) = q • (x : K) := rfl\n"}
{"name":"SubfieldClass.coe_qsmul","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nS : Type u_1\ninst✝ : SetLike S K\nh : SubfieldClass S K\ns : S\nq : Rat\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(HSMul.hSMul q x)) (HSMul.hSMul q ↑x)","decl":"@[simp, norm_cast] lemma coe_qsmul (s : S) (q : ℚ) (x : s) : ↑(q • x) = q • (x : K) := rfl\n\n"}
{"name":"Subfield.inv_mem'","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nself : Subfield K\nx : K\na✝ : Membership.mem self.carrier x\n⊢ Membership.mem self.carrier (Inv.inv x)","decl":"/-- `Subfield R` is the type of subfields of `R`. A subfield of `R` is a subset `s` that is a\n  multiplicative submonoid and an additive subgroup. Note in particular that it shares the\n  same 0 and 1 as R. -/\n@[stacks 09FD \"second part\"]\nstructure Subfield (K : Type u) [DivisionRing K] extends Subring K where\n  /-- A subfield is closed under multiplicative inverses. -/\n  inv_mem' : ∀ x ∈ carrier, x⁻¹ ∈ carrier\n\n"}
{"name":"Subfield.mk.injEq","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ntoSubring✝ : Subring K\ninv_mem'✝ : ∀ (x : K), Membership.mem toSubring✝.carrier x → Membership.mem toSubring✝.carrier (Inv.inv x)\ntoSubring : Subring K\ninv_mem' : ∀ (x : K), Membership.mem toSubring.carrier x → Membership.mem toSubring.carrier (Inv.inv x)\n⊢ Eq (Eq { toSubring := toSubring✝, inv_mem' := inv_mem'✝ } { toSubring := toSubring, inv_mem' := inv_mem' }) (Eq toSubring✝ toSubring)","decl":"/-- `Subfield R` is the type of subfields of `R`. A subfield of `R` is a subset `s` that is a\n  multiplicative submonoid and an additive subgroup. Note in particular that it shares the\n  same 0 and 1 as R. -/\n@[stacks 09FD \"second part\"]\nstructure Subfield (K : Type u) [DivisionRing K] extends Subring K where\n  /-- A subfield is closed under multiplicative inverses. -/\n  inv_mem' : ∀ x ∈ carrier, x⁻¹ ∈ carrier\n\n"}
{"name":"Subfield.mk.inj","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ntoSubring✝ : Subring K\ninv_mem'✝ : ∀ (x : K), Membership.mem toSubring✝.carrier x → Membership.mem toSubring✝.carrier (Inv.inv x)\ntoSubring : Subring K\ninv_mem' : ∀ (x : K), Membership.mem toSubring.carrier x → Membership.mem toSubring.carrier (Inv.inv x)\nx✝ : Eq { toSubring := toSubring✝, inv_mem' := inv_mem'✝ } { toSubring := toSubring, inv_mem' := inv_mem' }\n⊢ Eq toSubring✝ toSubring","decl":"/-- `Subfield R` is the type of subfields of `R`. A subfield of `R` is a subset `s` that is a\n  multiplicative submonoid and an additive subgroup. Note in particular that it shares the\n  same 0 and 1 as R. -/\n@[stacks 09FD \"second part\"]\nstructure Subfield (K : Type u) [DivisionRing K] extends Subring K where\n  /-- A subfield is closed under multiplicative inverses. -/\n  inv_mem' : ∀ x ∈ carrier, x⁻¹ ∈ carrier\n\n"}
{"name":"Subfield.mk.sizeOf_spec","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\ninst✝ : SizeOf K\ntoSubring : Subring K\ninv_mem' : ∀ (x : K), Membership.mem toSubring.carrier x → Membership.mem toSubring.carrier (Inv.inv x)\n⊢ Eq (SizeOf.sizeOf { toSubring := toSubring, inv_mem' := inv_mem' }) (HAdd.hAdd 1 (SizeOf.sizeOf toSubring))","decl":"/-- `Subfield R` is the type of subfields of `R`. A subfield of `R` is a subset `s` that is a\n  multiplicative submonoid and an additive subgroup. Note in particular that it shares the\n  same 0 and 1 as R. -/\n@[stacks 09FD \"second part\"]\nstructure Subfield (K : Type u) [DivisionRing K] extends Subring K where\n  /-- A subfield is closed under multiplicative inverses. -/\n  inv_mem' : ∀ x ∈ carrier, x⁻¹ ∈ carrier\n\n"}
{"name":"Subfield.instSubfieldClass","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\n⊢ SubfieldClass (Subfield K) K","decl":"instance : SubfieldClass (Subfield K) K where\n  add_mem {s} := s.add_mem'\n  zero_mem s := s.zero_mem'\n  neg_mem {s} := s.neg_mem'\n  mul_mem {s} := s.mul_mem'\n  one_mem s := s.one_mem'\n  inv_mem {s} := s.inv_mem' _\n\n"}
{"name":"Subfield.mem_carrier","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx : K\n⊢ Iff (Membership.mem s.carrier x) (Membership.mem s x)","decl":"theorem mem_carrier {s : Subfield K} {x : K} : x ∈ s.carrier ↔ x ∈ s :=\n  Iff.rfl\n\n-- Porting note: in lean 3, `S` was type `Set K`\n"}
{"name":"Subfield.mem_mk","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nS : Subring K\nx : K\nh : ∀ (x : K), Membership.mem S.carrier x → Membership.mem S.carrier (Inv.inv x)\n⊢ Iff (Membership.mem { toSubring := S, inv_mem' := h } x) (Membership.mem S x)","decl":"@[simp]\ntheorem mem_mk {S : Subring K} {x : K} (h) : x ∈ (⟨S, h⟩ : Subfield K) ↔ x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"Subfield.coe_set_mk","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nS : Subring K\nh : ∀ (x : K), Membership.mem S.carrier x → Membership.mem S.carrier (Inv.inv x)\n⊢ Eq ↑{ toSubring := S, inv_mem' := h } ↑S","decl":"@[simp]\ntheorem coe_set_mk (S : Subring K) (h) : ((⟨S, h⟩ : Subfield K) : Set K) = S :=\n  rfl\n\n"}
{"name":"Subfield.mk_le_mk","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nS S' : Subring K\nh : ∀ (x : K), Membership.mem S.carrier x → Membership.mem S.carrier (Inv.inv x)\nh' : ∀ (x : K), Membership.mem S'.carrier x → Membership.mem S'.carrier (Inv.inv x)\n⊢ Iff (LE.le { toSubring := S, inv_mem' := h } { toSubring := S', inv_mem' := h' }) (LE.le S S')","decl":"@[simp]\ntheorem mk_le_mk {S S' : Subring K} (h h') : (⟨S, h⟩ : Subfield K) ≤ (⟨S', h'⟩ : Subfield K) ↔\n    S ≤ S' :=\n  Iff.rfl\n\n"}
{"name":"Subfield.ext_iff","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nS T : Subfield K\n⊢ Iff (Eq S T) (∀ (x : K), Iff (Membership.mem S x) (Membership.mem T x))","decl":"/-- Two subfields are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : Subfield K} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"Subfield.ext","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nS T : Subfield K\nh : ∀ (x : K), Iff (Membership.mem S x) (Membership.mem T x)\n⊢ Eq S T","decl":"/-- Two subfields are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : Subfield K} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"Subfield.coe_copy","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nS : Subfield K\ns : Set K\nhs : Eq s ↑S\n⊢ Eq (↑(S.copy s hs)) s","decl":"@[simp]\ntheorem coe_copy (S : Subfield K) (s : Set K) (hs : s = ↑S) : (S.copy s hs : Set K) = s :=\n  rfl\n\n"}
{"name":"Subfield.copy_eq","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nS : Subfield K\ns : Set K\nhs : Eq s ↑S\n⊢ Eq (S.copy s hs) S","decl":"theorem copy_eq (S : Subfield K) (s : Set K) (hs : s = ↑S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n\n"}
{"name":"Subfield.coe_toSubring","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\n⊢ Eq ↑s.toSubring ↑s","decl":"@[simp]\ntheorem coe_toSubring (s : Subfield K) : (s.toSubring : Set K) = s :=\n  rfl\n\n"}
{"name":"Subfield.mem_toSubring","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx : K\n⊢ Iff (Membership.mem s.toSubring x) (Membership.mem s x)","decl":"@[simp]\ntheorem mem_toSubring (s : Subfield K) (x : K) : x ∈ s.toSubring ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Subfield.one_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\n⊢ Membership.mem s 1","decl":"/-- A subfield contains the field's 1. -/\nprotected theorem one_mem : (1 : K) ∈ s :=\n  one_mem s\n\n"}
{"name":"Subfield.zero_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\n⊢ Membership.mem s 0","decl":"/-- A subfield contains the field's 0. -/\nprotected theorem zero_mem : (0 : K) ∈ s :=\n  zero_mem s\n\n"}
{"name":"Subfield.mul_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx y : K\na✝¹ : Membership.mem s x\na✝ : Membership.mem s y\n⊢ Membership.mem s (HMul.hMul x y)","decl":"/-- A subfield is closed under multiplication. -/\nprotected theorem mul_mem {x y : K} : x ∈ s → y ∈ s → x * y ∈ s :=\n  mul_mem\n\n"}
{"name":"Subfield.add_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx y : K\na✝¹ : Membership.mem s x\na✝ : Membership.mem s y\n⊢ Membership.mem s (HAdd.hAdd x y)","decl":"/-- A subfield is closed under addition. -/\nprotected theorem add_mem {x y : K} : x ∈ s → y ∈ s → x + y ∈ s :=\n  add_mem\n\n"}
{"name":"Subfield.neg_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx : K\na✝ : Membership.mem s x\n⊢ Membership.mem s (Neg.neg x)","decl":"/-- A subfield is closed under negation. -/\nprotected theorem neg_mem {x : K} : x ∈ s → -x ∈ s :=\n  neg_mem\n\n"}
{"name":"Subfield.sub_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx y : K\na✝¹ : Membership.mem s x\na✝ : Membership.mem s y\n⊢ Membership.mem s (HSub.hSub x y)","decl":"/-- A subfield is closed under subtraction. -/\nprotected theorem sub_mem {x y : K} : x ∈ s → y ∈ s → x - y ∈ s :=\n  sub_mem\n\n"}
{"name":"Subfield.inv_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx : K\na✝ : Membership.mem s x\n⊢ Membership.mem s (Inv.inv x)","decl":"/-- A subfield is closed under inverses. -/\nprotected theorem inv_mem {x : K} : x ∈ s → x⁻¹ ∈ s :=\n  inv_mem\n\n"}
{"name":"Subfield.div_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx y : K\na✝¹ : Membership.mem s x\na✝ : Membership.mem s y\n⊢ Membership.mem s (HDiv.hDiv x y)","decl":"/-- A subfield is closed under division. -/\nprotected theorem div_mem {x y : K} : x ∈ s → y ∈ s → x / y ∈ s :=\n  div_mem\n\n"}
{"name":"Subfield.pow_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx : K\nhx : Membership.mem s x\nn : Nat\n⊢ Membership.mem s (HPow.hPow x n)","decl":"protected theorem pow_mem {x : K} (hx : x ∈ s) (n : ℕ) : x ^ n ∈ s :=\n  pow_mem hx n\n\n"}
{"name":"Subfield.zsmul_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx : K\nhx : Membership.mem s x\nn : Int\n⊢ Membership.mem s (HSMul.hSMul n x)","decl":"protected theorem zsmul_mem {x : K} (hx : x ∈ s) (n : ℤ) : n • x ∈ s :=\n  zsmul_mem hx n\n\n"}
{"name":"Subfield.intCast_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nn : Int\n⊢ Membership.mem s ↑n","decl":"protected theorem intCast_mem (n : ℤ) : (n : K) ∈ s := intCast_mem s n\n\n"}
{"name":"Subfield.zpow_mem","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx : K\nhx : Membership.mem s x\nn : Int\n⊢ Membership.mem s (HPow.hPow x n)","decl":"theorem zpow_mem {x : K} (hx : x ∈ s) (n : ℤ) : x ^ n ∈ s := by\n  cases n\n  · simpa using s.pow_mem hx _\n  · simpa [pow_succ'] using s.inv_mem (s.mul_mem hx (s.pow_mem hx _))\n\n"}
{"name":"Subfield.coe_add","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx y : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_add (x y : s) : (↑(x + y) : K) = ↑x + ↑y :=\n  rfl\n\n"}
{"name":"Subfield.coe_sub","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx y : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(HSub.hSub x y)) (HSub.hSub ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_sub (x y : s) : (↑(x - y) : K) = ↑x - ↑y :=\n  rfl\n\n"}
{"name":"Subfield.coe_neg","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(Neg.neg x)) (Neg.neg ↑x)","decl":"@[simp, norm_cast]\ntheorem coe_neg (x : s) : (↑(-x) : K) = -↑x :=\n  rfl\n\n"}
{"name":"Subfield.coe_mul","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx y : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_mul (x y : s) : (↑(x * y) : K) = ↑x * ↑y :=\n  rfl\n\n"}
{"name":"Subfield.coe_div","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx y : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(HDiv.hDiv x y)) (HDiv.hDiv ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_div (x y : s) : (↑(x / y) : K) = ↑x / ↑y :=\n  rfl\n\n"}
{"name":"Subfield.coe_inv","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(Inv.inv x)) (Inv.inv ↑x)","decl":"@[simp, norm_cast]\ntheorem coe_inv (x : s) : (↑x⁻¹ : K) = (↑x)⁻¹ :=\n  rfl\n\n"}
{"name":"Subfield.coe_zero","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ((0 : s) : K) = 0 :=\n  rfl\n\n"}
{"name":"Subfield.coe_one","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coe_one : ((1 : s) : K) = 1 :=\n  rfl\n\n"}
{"name":"Subfield.coe_subtype","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\n⊢ Eq (⇑s.subtype) Subtype.val","decl":"@[simp]\ntheorem coe_subtype : ⇑(s.subtype) = ((↑) : s → K) :=\n  rfl\n\n"}
{"name":"Subfield.toSubring_subtype_eq_subtype","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\nS : Subfield K\n⊢ Eq S.subtype S.subtype","decl":"variable (K) in\ntheorem toSubring_subtype_eq_subtype (S : Subfield K) :\n    S.toSubring.subtype = S.subtype :=\n  rfl\n\n"}
{"name":"Subfield.mem_toSubmonoid","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx : K\n⊢ Iff (Membership.mem s.toSubmonoid x) (Membership.mem s x)","decl":"theorem mem_toSubmonoid {s : Subfield K} {x : K} : x ∈ s.toSubmonoid ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Subfield.coe_toSubmonoid","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\n⊢ Eq ↑s.toSubmonoid ↑s","decl":"@[simp]\ntheorem coe_toSubmonoid : (s.toSubmonoid : Set K) = s :=\n  rfl\n\n"}
{"name":"Subfield.mem_toAddSubgroup","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\nx : K\n⊢ Iff (Membership.mem s.toAddSubgroup x) (Membership.mem s x)","decl":"@[simp]\ntheorem mem_toAddSubgroup {s : Subfield K} {x : K} : x ∈ s.toAddSubgroup ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Subfield.coe_toAddSubgroup","module":"Mathlib.Algebra.Field.Subfield.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\ns : Subfield K\n⊢ Eq ↑s.toAddSubgroup ↑s","decl":"@[simp]\ntheorem coe_toAddSubgroup : (s.toAddSubgroup : Set K) = s :=\n  rfl\n\n"}
