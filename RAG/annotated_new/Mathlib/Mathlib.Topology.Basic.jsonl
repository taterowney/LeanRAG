{"name":"isOpen_mk","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\np : Set X → Prop\nh₁ : p Set.univ\nh₂ : ∀ (s t : Set X), p s → p t → p (Inter.inter s t)\nh₃ : ∀ (s : Set (Set X)), (∀ (t : Set X), Membership.mem s t → p t) → p s.sUnion\n⊢ Iff (IsOpen s) (p s)","decl":"lemma isOpen_mk {p h₁ h₂ h₃} : IsOpen[⟨p, h₁, h₂, h₃⟩] s ↔ p s := Iff.rfl\n\n"}
{"name":"TopologicalSpace.ext","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nf g : TopologicalSpace X\na✝ : Eq IsOpen IsOpen\n⊢ Eq f g","decl":"@[ext (iff := false)]\nprotected theorem TopologicalSpace.ext :\n    ∀ {f g : TopologicalSpace X}, IsOpen[f] = IsOpen[g] → f = g\n  | ⟨_, _, _, _⟩, ⟨_, _, _, _⟩, rfl => rfl\n\n"}
{"name":"TopologicalSpace.ext_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nt t' : TopologicalSpace X\n⊢ Iff (Eq t t') (∀ (s : Set X), Iff (IsOpen s) (IsOpen s))","decl":"protected theorem TopologicalSpace.ext_iff {t t' : TopologicalSpace X} :\n    t = t' ↔ ∀ s, IsOpen[t] s ↔ IsOpen[t'] s :=\n  ⟨fun h _ => h ▸ Iff.rfl, fun h => by ext; exact h _⟩\n\n"}
{"name":"isOpen_fold","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\nt : TopologicalSpace X\n⊢ Eq (TopologicalSpace.IsOpen s) (IsOpen s)","decl":"theorem isOpen_fold {t : TopologicalSpace X} : t.IsOpen s = IsOpen[t] s :=\n  rfl\n\n"}
{"name":"isOpen_iUnion","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\ninst✝ : TopologicalSpace X\nf : ι → Set X\nh : ∀ (i : ι), IsOpen (f i)\n⊢ IsOpen (Set.iUnion fun i => f i)","decl":"theorem isOpen_iUnion {f : ι → Set X} (h : ∀ i, IsOpen (f i)) : IsOpen (⋃ i, f i) :=\n  isOpen_sUnion (forall_mem_range.2 h)\n\n"}
{"name":"isOpen_biUnion","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\ns : Set α\nf : α → Set X\nh : ∀ (i : α), Membership.mem s i → IsOpen (f i)\n⊢ IsOpen (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem isOpen_biUnion {s : Set α} {f : α → Set X} (h : ∀ i ∈ s, IsOpen (f i)) :\n    IsOpen (⋃ i ∈ s, f i) :=\n  isOpen_iUnion fun i => isOpen_iUnion fun hi => h i hi\n\n"}
{"name":"IsOpen.union","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns₁ s₂ : Set X\ninst✝ : TopologicalSpace X\nh₁ : IsOpen s₁\nh₂ : IsOpen s₂\n⊢ IsOpen (Union.union s₁ s₂)","decl":"theorem IsOpen.union (h₁ : IsOpen s₁) (h₂ : IsOpen s₂) : IsOpen (s₁ ∪ s₂) := by\n  rw [union_eq_iUnion]; exact isOpen_iUnion (Bool.forall_bool.2 ⟨h₂, h₁⟩)\n\n"}
{"name":"isOpen_iff_of_cover","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ns : Set X\ninst✝ : TopologicalSpace X\nf : α → Set X\nho : ∀ (i : α), IsOpen (f i)\nhU : Eq (Set.iUnion fun i => f i) Set.univ\n⊢ Iff (IsOpen s) (∀ (i : α), IsOpen (Inter.inter (f i) s))","decl":"lemma isOpen_iff_of_cover {f : α → Set X} (ho : ∀ i, IsOpen (f i)) (hU : (⋃ i, f i) = univ) :\n    IsOpen s ↔ ∀ i, IsOpen (f i ∩ s) := by\n  refine ⟨fun h i ↦ (ho i).inter h, fun h ↦ ?_⟩\n  rw [← s.inter_univ, inter_comm, ← hU, iUnion_inter]\n  exact isOpen_iUnion fun i ↦ h i\n\n"}
{"name":"isOpen_empty","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsOpen EmptyCollection.emptyCollection","decl":"@[simp] theorem isOpen_empty : IsOpen (∅ : Set X) := by\n  rw [← sUnion_empty]; exact isOpen_sUnion fun a => False.elim\n\n"}
{"name":"Set.Finite.isOpen_sInter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set (Set X)\nhs : s.Finite\na✝ : ∀ (t : Set X), Membership.mem s t → IsOpen t\n⊢ IsOpen s.sInter","decl":"theorem Set.Finite.isOpen_sInter {s : Set (Set X)} (hs : s.Finite) :\n    (∀ t ∈ s, IsOpen t) → IsOpen (⋂₀ s) :=\n  Finite.induction_on _ hs (fun _ => by rw [sInter_empty]; exact isOpen_univ) fun _ _ ih h => by\n    simp only [sInter_insert, forall_mem_insert] at h ⊢\n    exact h.1.inter (ih h.2)\n\n"}
{"name":"Set.Finite.isOpen_biInter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\ns : Set α\nf : α → Set X\nhs : s.Finite\nh : ∀ (i : α), Membership.mem s i → IsOpen (f i)\n⊢ IsOpen (Set.iInter fun i => Set.iInter fun h => f i)","decl":"theorem Set.Finite.isOpen_biInter {s : Set α} {f : α → Set X} (hs : s.Finite)\n    (h : ∀ i ∈ s, IsOpen (f i)) :\n    IsOpen (⋂ i ∈ s, f i) :=\n  sInter_image f s ▸ (hs.image _).isOpen_sInter (forall_mem_image.2 h)\n\n"}
{"name":"isOpen_iInter_of_finite","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\ninst✝¹ : TopologicalSpace X\ninst✝ : Finite ι\ns : ι → Set X\nh : ∀ (i : ι), IsOpen (s i)\n⊢ IsOpen (Set.iInter fun i => s i)","decl":"theorem isOpen_iInter_of_finite [Finite ι] {s : ι → Set X} (h : ∀ i, IsOpen (s i)) :\n    IsOpen (⋂ i, s i) :=\n  (finite_range _).isOpen_sInter (forall_mem_range.2 h)\n\n"}
{"name":"isOpen_biInter_finset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\ns : Finset α\nf : α → Set X\nh : ∀ (i : α), Membership.mem s i → IsOpen (f i)\n⊢ IsOpen (Set.iInter fun i => Set.iInter fun h => f i)","decl":"theorem isOpen_biInter_finset {s : Finset α} {f : α → Set X} (h : ∀ i ∈ s, IsOpen (f i)) :\n    IsOpen (⋂ i ∈ s, f i) :=\n  s.finite_toSet.isOpen_biInter h\n\n"}
{"name":"isOpen_const","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : Prop\n⊢ IsOpen (setOf fun _x => p)","decl":"@[simp] -- Porting note: added `simp`\ntheorem isOpen_const {p : Prop} : IsOpen { _x : X | p } := by by_cases p <;> simp [*]\n\n"}
{"name":"IsOpen.and","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\np₁ p₂ : X → Prop\ninst✝ : TopologicalSpace X\na✝¹ : IsOpen (setOf fun x => p₁ x)\na✝ : IsOpen (setOf fun x => p₂ x)\n⊢ IsOpen (setOf fun x => And (p₁ x) (p₂ x))","decl":"theorem IsOpen.and : IsOpen { x | p₁ x } → IsOpen { x | p₂ x } → IsOpen { x | p₁ x ∧ p₂ x } :=\n  IsOpen.inter\n\n"}
{"name":"isOpen_compl_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (IsOpen (HasCompl.compl s)) (IsClosed s)","decl":"@[simp] theorem isOpen_compl_iff : IsOpen sᶜ ↔ IsClosed s :=\n  ⟨fun h => ⟨h⟩, fun h => h.isOpen_compl⟩\n\n"}
{"name":"TopologicalSpace.ext_iff_isClosed","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_3\nt₁ t₂ : TopologicalSpace X\n⊢ Iff (Eq t₁ t₂) (∀ (s : Set X), Iff (IsClosed s) (IsClosed s))","decl":"theorem TopologicalSpace.ext_iff_isClosed {X} {t₁ t₂ : TopologicalSpace X} :\n    t₁ = t₂ ↔ ∀ s, IsClosed[t₁] s ↔ IsClosed[t₂] s := by\n  rw [TopologicalSpace.ext_iff, compl_surjective.forall]\n  simp only [@isOpen_compl_iff _ _ t₁, @isOpen_compl_iff _ _ t₂]\n\n"}
{"name":"TopologicalSpace.ext_isClosed","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_3\nt₁ t₂ : TopologicalSpace X\na✝ : ∀ (s : Set X), Iff (IsClosed s) (IsClosed s)\n⊢ Eq t₁ t₂","decl":"alias ⟨_, TopologicalSpace.ext_isClosed⟩ := TopologicalSpace.ext_iff_isClosed\n\n"}
{"name":"isClosed_const","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : Prop\n⊢ IsClosed (setOf fun _x => p)","decl":"theorem isClosed_const {p : Prop} : IsClosed { _x : X | p } := ⟨isOpen_const (p := ¬p)⟩\n\n"}
{"name":"isClosed_empty","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsClosed EmptyCollection.emptyCollection","decl":"@[simp] theorem isClosed_empty : IsClosed (∅ : Set X) := isClosed_const\n\n"}
{"name":"isClosed_univ","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsClosed Set.univ","decl":"@[simp] theorem isClosed_univ : IsClosed (univ : Set X) := isClosed_const\n\n"}
{"name":"IsOpen.isLocallyClosed","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nhs : IsOpen s\n⊢ IsLocallyClosed s","decl":"lemma IsOpen.isLocallyClosed (hs : IsOpen s) : IsLocallyClosed s :=\n  ⟨_, _, hs, isClosed_univ, (inter_univ _).symm⟩\n\n"}
{"name":"IsClosed.isLocallyClosed","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nhs : IsClosed s\n⊢ IsLocallyClosed s","decl":"lemma IsClosed.isLocallyClosed (hs : IsClosed s) : IsLocallyClosed s :=\n  ⟨_, _, isOpen_univ, hs, (univ_inter _).symm⟩\n\n"}
{"name":"IsClosed.union","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns₁ s₂ : Set X\ninst✝ : TopologicalSpace X\na✝¹ : IsClosed s₁\na✝ : IsClosed s₂\n⊢ IsClosed (Union.union s₁ s₂)","decl":"theorem IsClosed.union : IsClosed s₁ → IsClosed s₂ → IsClosed (s₁ ∪ s₂) := by\n  simpa only [← isOpen_compl_iff, compl_union] using IsOpen.inter\n\n"}
{"name":"isClosed_sInter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set (Set X)\na✝ : ∀ (t : Set X), Membership.mem s t → IsClosed t\n⊢ IsClosed s.sInter","decl":"theorem isClosed_sInter {s : Set (Set X)} : (∀ t ∈ s, IsClosed t) → IsClosed (⋂₀ s) := by\n  simpa only [← isOpen_compl_iff, compl_sInter, sUnion_image] using isOpen_biUnion\n\n"}
{"name":"isClosed_iInter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\ninst✝ : TopologicalSpace X\nf : ι → Set X\nh : ∀ (i : ι), IsClosed (f i)\n⊢ IsClosed (Set.iInter fun i => f i)","decl":"theorem isClosed_iInter {f : ι → Set X} (h : ∀ i, IsClosed (f i)) : IsClosed (⋂ i, f i) :=\n  isClosed_sInter <| forall_mem_range.2 h\n\n"}
{"name":"isClosed_biInter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\ns : Set α\nf : α → Set X\nh : ∀ (i : α), Membership.mem s i → IsClosed (f i)\n⊢ IsClosed (Set.iInter fun i => Set.iInter fun h => f i)","decl":"theorem isClosed_biInter {s : Set α} {f : α → Set X} (h : ∀ i ∈ s, IsClosed (f i)) :\n    IsClosed (⋂ i ∈ s, f i) :=\n  isClosed_iInter fun i => isClosed_iInter <| h i\n\n"}
{"name":"isClosed_compl_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (IsClosed (HasCompl.compl s)) (IsOpen s)","decl":"@[simp]\ntheorem isClosed_compl_iff {s : Set X} : IsClosed sᶜ ↔ IsOpen s := by\n  rw [← isOpen_compl_iff, compl_compl]\n\n"}
{"name":"IsOpen.isClosed_compl","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\na✝ : IsOpen s\n⊢ IsClosed (HasCompl.compl s)","decl":"alias ⟨_, IsOpen.isClosed_compl⟩ := isClosed_compl_iff\n\n"}
{"name":"IsOpen.sdiff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nh₁ : IsOpen s\nh₂ : IsClosed t\n⊢ IsOpen (SDiff.sdiff s t)","decl":"theorem IsOpen.sdiff (h₁ : IsOpen s) (h₂ : IsClosed t) : IsOpen (s \\ t) :=\n  IsOpen.inter h₁ h₂.isOpen_compl\n\n"}
{"name":"IsClosed.inter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns₁ s₂ : Set X\ninst✝ : TopologicalSpace X\nh₁ : IsClosed s₁\nh₂ : IsClosed s₂\n⊢ IsClosed (Inter.inter s₁ s₂)","decl":"theorem IsClosed.inter (h₁ : IsClosed s₁) (h₂ : IsClosed s₂) : IsClosed (s₁ ∩ s₂) := by\n  rw [← isOpen_compl_iff] at *\n  rw [compl_inter]\n  exact IsOpen.union h₁ h₂\n\n"}
{"name":"IsClosed.sdiff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nh₁ : IsClosed s\nh₂ : IsOpen t\n⊢ IsClosed (SDiff.sdiff s t)","decl":"theorem IsClosed.sdiff (h₁ : IsClosed s) (h₂ : IsOpen t) : IsClosed (s \\ t) :=\n  IsClosed.inter h₁ (isClosed_compl_iff.mpr h₂)\n\n"}
{"name":"Set.Finite.isClosed_biUnion","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\ns : Set α\nf : α → Set X\nhs : s.Finite\nh : ∀ (i : α), Membership.mem s i → IsClosed (f i)\n⊢ IsClosed (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem Set.Finite.isClosed_biUnion {s : Set α} {f : α → Set X} (hs : s.Finite)\n    (h : ∀ i ∈ s, IsClosed (f i)) :\n    IsClosed (⋃ i ∈ s, f i) := by\n  simp only [← isOpen_compl_iff, compl_iUnion] at *\n  exact hs.isOpen_biInter h\n\n"}
{"name":"isClosed_biUnion_finset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\ns : Finset α\nf : α → Set X\nh : ∀ (i : α), Membership.mem s i → IsClosed (f i)\n⊢ IsClosed (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"lemma isClosed_biUnion_finset {s : Finset α} {f : α → Set X} (h : ∀ i ∈ s, IsClosed (f i)) :\n    IsClosed (⋃ i ∈ s, f i) :=\n  s.finite_toSet.isClosed_biUnion h\n\n"}
{"name":"isClosed_iUnion_of_finite","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\ninst✝¹ : TopologicalSpace X\ninst✝ : Finite ι\ns : ι → Set X\nh : ∀ (i : ι), IsClosed (s i)\n⊢ IsClosed (Set.iUnion fun i => s i)","decl":"theorem isClosed_iUnion_of_finite [Finite ι] {s : ι → Set X} (h : ∀ i, IsClosed (s i)) :\n    IsClosed (⋃ i, s i) := by\n  simp only [← isOpen_compl_iff, compl_iUnion] at *\n  exact isOpen_iInter_of_finite h\n\n"}
{"name":"isClosed_imp","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np q : X → Prop\nhp : IsOpen (setOf fun x => p x)\nhq : IsClosed (setOf fun x => q x)\n⊢ IsClosed (setOf fun x => p x → q x)","decl":"theorem isClosed_imp {p q : X → Prop} (hp : IsOpen { x | p x }) (hq : IsClosed { x | q x }) :\n    IsClosed { x | p x → q x } := by\n  simpa only [imp_iff_not_or] using hp.isClosed_compl.union hq\n\n"}
{"name":"IsClosed.not","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\np : X → Prop\ninst✝ : TopologicalSpace X\na✝ : IsClosed (setOf fun a => p a)\n⊢ IsOpen (setOf fun a => Not (p a))","decl":"theorem IsClosed.not : IsClosed { a | p a } → IsOpen { a | ¬p a } :=\n  isOpen_compl_iff.mpr\n\n"}
{"name":"mem_interior","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Membership.mem (interior s) x) (Exists fun t => And (HasSubset.Subset t s) (And (IsOpen t) (Membership.mem t x)))","decl":"theorem mem_interior : x ∈ interior s ↔ ∃ t ⊆ s, IsOpen t ∧ x ∈ t := by\n  simp only [interior, mem_sUnion, mem_setOf_eq, and_assoc, and_left_comm]\n\n"}
{"name":"isOpen_interior","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ IsOpen (interior s)","decl":"@[simp]\ntheorem isOpen_interior : IsOpen (interior s) :=\n  isOpen_sUnion fun _ => And.left\n\n"}
{"name":"interior_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ HasSubset.Subset (interior s) s","decl":"theorem interior_subset : interior s ⊆ s :=\n  sUnion_subset fun _ => And.right\n\n"}
{"name":"interior_maximal","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nh₁ : HasSubset.Subset t s\nh₂ : IsOpen t\n⊢ HasSubset.Subset t (interior s)","decl":"theorem interior_maximal (h₁ : t ⊆ s) (h₂ : IsOpen t) : t ⊆ interior s :=\n  subset_sUnion_of_mem ⟨h₂, h₁⟩\n\n"}
{"name":"IsOpen.interior_eq","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nh : IsOpen s\n⊢ Eq (interior s) s","decl":"theorem IsOpen.interior_eq (h : IsOpen s) : interior s = s :=\n  interior_subset.antisymm (interior_maximal (Subset.refl s) h)\n\n"}
{"name":"interior_eq_iff_isOpen","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Eq (interior s) s) (IsOpen s)","decl":"theorem interior_eq_iff_isOpen : interior s = s ↔ IsOpen s :=\n  ⟨fun h => h ▸ isOpen_interior, IsOpen.interior_eq⟩\n\n"}
{"name":"subset_interior_iff_isOpen","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (HasSubset.Subset s (interior s)) (IsOpen s)","decl":"theorem subset_interior_iff_isOpen : s ⊆ interior s ↔ IsOpen s := by\n  simp only [interior_eq_iff_isOpen.symm, Subset.antisymm_iff, interior_subset, true_and]\n\n"}
{"name":"IsOpen.subset_interior_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nh₁ : IsOpen s\n⊢ Iff (HasSubset.Subset s (interior t)) (HasSubset.Subset s t)","decl":"theorem IsOpen.subset_interior_iff (h₁ : IsOpen s) : s ⊆ interior t ↔ s ⊆ t :=\n  ⟨fun h => Subset.trans h interior_subset, fun h₂ => interior_maximal h₂ h₁⟩\n\n"}
{"name":"subset_interior_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (HasSubset.Subset t (interior s)) (Exists fun U => And (IsOpen U) (And (HasSubset.Subset t U) (HasSubset.Subset U s)))","decl":"theorem subset_interior_iff : t ⊆ interior s ↔ ∃ U, IsOpen U ∧ t ⊆ U ∧ U ⊆ s :=\n  ⟨fun h => ⟨interior s, isOpen_interior, h, interior_subset⟩, fun ⟨_U, hU, htU, hUs⟩ =>\n    htU.trans (interior_maximal hUs hU)⟩\n\n"}
{"name":"interior_subset_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (HasSubset.Subset (interior s) t) (∀ (U : Set X), IsOpen U → HasSubset.Subset U s → HasSubset.Subset U t)","decl":"lemma interior_subset_iff : interior s ⊆ t ↔ ∀ U, IsOpen U → U ⊆ s → U ⊆ t := by\n  simp [interior]\n\n"}
{"name":"interior_mono","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (interior s) (interior t)","decl":"@[mono, gcongr]\ntheorem interior_mono (h : s ⊆ t) : interior s ⊆ interior t :=\n  interior_maximal (Subset.trans interior_subset h) isOpen_interior\n\n"}
{"name":"interior_empty","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Eq (interior EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem interior_empty : interior (∅ : Set X) = ∅ :=\n  isOpen_empty.interior_eq\n\n"}
{"name":"interior_univ","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Eq (interior Set.univ) Set.univ","decl":"@[simp]\ntheorem interior_univ : interior (univ : Set X) = univ :=\n  isOpen_univ.interior_eq\n\n"}
{"name":"interior_eq_univ","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Eq (interior s) Set.univ) (Eq s Set.univ)","decl":"@[simp]\ntheorem interior_eq_univ : interior s = univ ↔ s = univ :=\n  ⟨fun h => univ_subset_iff.mp <| h.symm.trans_le interior_subset, fun h => h.symm ▸ interior_univ⟩\n\n"}
{"name":"interior_interior","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Eq (interior (interior s)) (interior s)","decl":"@[simp]\ntheorem interior_interior : interior (interior s) = interior s :=\n  isOpen_interior.interior_eq\n\n"}
{"name":"interior_inter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\n⊢ Eq (interior (Inter.inter s t)) (Inter.inter (interior s) (interior t))","decl":"@[simp]\ntheorem interior_inter : interior (s ∩ t) = interior s ∩ interior t :=\n  (Monotone.map_inf_le (fun _ _ ↦ interior_mono) s t).antisymm <|\n    interior_maximal (inter_subset_inter interior_subset interior_subset) <|\n      isOpen_interior.inter isOpen_interior\n\n"}
{"name":"Set.Finite.interior_biInter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nι : Type u_3\ns : Set ι\nhs : s.Finite\nf : ι → Set X\n⊢ Eq (interior (Set.iInter fun i => Set.iInter fun h => f i)) (Set.iInter fun i => Set.iInter fun h => interior (f i))","decl":"theorem Set.Finite.interior_biInter {ι : Type*} {s : Set ι} (hs : s.Finite) (f : ι → Set X) :\n    interior (⋂ i ∈ s, f i) = ⋂ i ∈ s, interior (f i) :=\n  hs.induction_on _ (by simp) <| by intros; simp [*]\n\n"}
{"name":"Set.Finite.interior_sInter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nhS : S.Finite\n⊢ Eq (interior S.sInter) (Set.iInter fun s => Set.iInter fun h => interior s)","decl":"theorem Set.Finite.interior_sInter {S : Set (Set X)} (hS : S.Finite) :\n    interior (⋂₀ S) = ⋂ s ∈ S, interior s := by\n  rw [sInter_eq_biInter, hS.interior_biInter]\n\n"}
{"name":"Finset.interior_iInter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nι : Type u_3\ns : Finset ι\nf : ι → Set X\n⊢ Eq (interior (Set.iInter fun i => Set.iInter fun h => f i)) (Set.iInter fun i => Set.iInter fun h => interior (f i))","decl":"@[simp]\ntheorem Finset.interior_iInter {ι : Type*} (s : Finset ι) (f : ι → Set X) :\n    interior (⋂ i ∈ s, f i) = ⋂ i ∈ s, interior (f i) :=\n  s.finite_toSet.interior_biInter f\n\n"}
{"name":"interior_iInter_of_finite","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\ninst✝¹ : TopologicalSpace X\ninst✝ : Finite ι\nf : ι → Set X\n⊢ Eq (interior (Set.iInter fun i => f i)) (Set.iInter fun i => interior (f i))","decl":"@[simp]\ntheorem interior_iInter_of_finite [Finite ι] (f : ι → Set X) :\n    interior (⋂ i, f i) = ⋂ i, interior (f i) := by\n  rw [← sInter_range, (finite_range f).interior_sInter, biInter_range]\n\n"}
{"name":"interior_iInter₂_lt_nat","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nn : Nat\nf : Nat → Set X\n⊢ Eq (interior (Set.iInter fun m => Set.iInter fun h => f m)) (Set.iInter fun m => Set.iInter fun h => interior (f m))","decl":"@[simp]\ntheorem interior_iInter₂_lt_nat {n : ℕ} (f : ℕ → Set X) :\n    interior (⋂ m < n, f m) = ⋂ m < n, interior (f m) :=\n  (finite_lt_nat n).interior_biInter f\n\n"}
{"name":"interior_iInter₂_le_nat","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nn : Nat\nf : Nat → Set X\n⊢ Eq (interior (Set.iInter fun m => Set.iInter fun h => f m)) (Set.iInter fun m => Set.iInter fun h => interior (f m))","decl":"@[simp]\ntheorem interior_iInter₂_le_nat {n : ℕ} (f : ℕ → Set X) :\n    interior (⋂ m ≤ n, f m) = ⋂ m ≤ n, interior (f m) :=\n  (finite_le_nat n).interior_biInter f\n\n"}
{"name":"interior_union_isClosed_of_interior_empty","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nh₁ : IsClosed s\nh₂ : Eq (interior t) EmptyCollection.emptyCollection\n⊢ Eq (interior (Union.union s t)) (interior s)","decl":"theorem interior_union_isClosed_of_interior_empty (h₁ : IsClosed s)\n    (h₂ : interior t = ∅) : interior (s ∪ t) = interior s :=\n  have : interior (s ∪ t) ⊆ s := fun x ⟨u, ⟨(hu₁ : IsOpen u), (hu₂ : u ⊆ s ∪ t)⟩, (hx₁ : x ∈ u)⟩ =>\n    by_contradiction fun hx₂ : x ∉ s =>\n      have : u \\ s ⊆ t := fun _ ⟨h₁, h₂⟩ => Or.resolve_left (hu₂ h₁) h₂\n      have : u \\ s ⊆ interior t := by rwa [(IsOpen.sdiff hu₁ h₁).subset_interior_iff]\n      have : u \\ s ⊆ ∅ := by rwa [h₂] at this\n      this ⟨hx₁, hx₂⟩\n  Subset.antisymm (interior_maximal this isOpen_interior) (interior_mono subset_union_left)\n\n"}
{"name":"isOpen_iff_forall_mem_open","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (IsOpen s) (∀ (x : X), Membership.mem s x → Exists fun t => And (HasSubset.Subset t s) (And (IsOpen t) (Membership.mem t x)))","decl":"theorem isOpen_iff_forall_mem_open : IsOpen s ↔ ∀ x ∈ s, ∃ t, t ⊆ s ∧ IsOpen t ∧ x ∈ t := by\n  rw [← subset_interior_iff_isOpen]\n  simp only [subset_def, mem_interior]\n\n"}
{"name":"interior_iInter_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\ninst✝ : TopologicalSpace X\ns : ι → Set X\n⊢ HasSubset.Subset (interior (Set.iInter fun i => s i)) (Set.iInter fun i => interior (s i))","decl":"theorem interior_iInter_subset (s : ι → Set X) : interior (⋂ i, s i) ⊆ ⋂ i, interior (s i) :=\n  subset_iInter fun _ => interior_mono <| iInter_subset _ _\n\n"}
{"name":"interior_iInter₂_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\ninst✝ : TopologicalSpace X\np : ι → Sort u_3\ns : (i : ι) → p i → Set X\n⊢ HasSubset.Subset (interior (Set.iInter fun i => Set.iInter fun j => s i j)) (Set.iInter fun i => Set.iInter fun j => interior (s i j))","decl":"theorem interior_iInter₂_subset (p : ι → Sort*) (s : ∀ i, p i → Set X) :\n    interior (⋂ (i) (j), s i j) ⊆ ⋂ (i) (j), interior (s i j) :=\n  (interior_iInter_subset _).trans <| iInter_mono fun _ => interior_iInter_subset _\n\n"}
{"name":"interior_sInter_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nS : Set (Set X)\n⊢ HasSubset.Subset (interior S.sInter) (Set.iInter fun s => Set.iInter fun h => interior s)","decl":"theorem interior_sInter_subset (S : Set (Set X)) : interior (⋂₀ S) ⊆ ⋂ s ∈ S, interior s :=\n  calc\n    interior (⋂₀ S) = interior (⋂ s ∈ S, s) := by rw [sInter_eq_biInter]\n    _ ⊆ ⋂ s ∈ S, interior s := interior_iInter₂_subset _ _\n\n"}
{"name":"Filter.HasBasis.lift'_interior","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\ninst✝ : TopologicalSpace X\nl : Filter X\np : ι → Prop\ns : ι → Set X\nh : l.HasBasis p s\n⊢ (l.lift' interior).HasBasis p fun i => interior (s i)","decl":"theorem Filter.HasBasis.lift'_interior {l : Filter X} {p : ι → Prop} {s : ι → Set X}\n    (h : l.HasBasis p s) : (l.lift' interior).HasBasis p fun i => interior (s i) :=\n  h.lift' fun _ _ ↦ interior_mono\n\n"}
{"name":"Filter.lift'_interior_le","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nl : Filter X\n⊢ LE.le (l.lift' interior) l","decl":"theorem Filter.lift'_interior_le (l : Filter X) : l.lift' interior ≤ l := fun _s hs ↦\n  mem_of_superset (mem_lift' hs) interior_subset\n\n"}
{"name":"Filter.HasBasis.lift'_interior_eq_self","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\ninst✝ : TopologicalSpace X\nl : Filter X\np : ι → Prop\ns : ι → Set X\nh : l.HasBasis p s\nho : ∀ (i : ι), p i → IsOpen (s i)\n⊢ Eq (l.lift' interior) l","decl":"theorem Filter.HasBasis.lift'_interior_eq_self {l : Filter X} {p : ι → Prop} {s : ι → Set X}\n    (h : l.HasBasis p s) (ho : ∀ i, p i → IsOpen (s i)) : l.lift' interior = l :=\n  le_antisymm l.lift'_interior_le <| h.lift'_interior.ge_iff.2 fun i hi ↦ by\n    simpa only [(ho i hi).interior_eq] using h.mem_of_mem hi\n\n"}
{"name":"isClosed_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ IsClosed (closure s)","decl":"@[simp]\ntheorem isClosed_closure : IsClosed (closure s) :=\n  isClosed_sInter fun _ => And.left\n\n"}
{"name":"subset_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ HasSubset.Subset s (closure s)","decl":"theorem subset_closure : s ⊆ closure s :=\n  subset_sInter fun _ => And.right\n\n"}
{"name":"not_mem_of_not_mem_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nP : X\nhP : Not (Membership.mem (closure s) P)\n⊢ Not (Membership.mem s P)","decl":"theorem not_mem_of_not_mem_closure {P : X} (hP : P ∉ closure s) : P ∉ s := fun h =>\n  hP (subset_closure h)\n\n"}
{"name":"closure_minimal","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nh₁ : HasSubset.Subset s t\nh₂ : IsClosed t\n⊢ HasSubset.Subset (closure s) t","decl":"theorem closure_minimal (h₁ : s ⊆ t) (h₂ : IsClosed t) : closure s ⊆ t :=\n  sInter_subset_of_mem ⟨h₂, h₁⟩\n\n"}
{"name":"Disjoint.closure_left","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nhd : Disjoint s t\nht : IsOpen t\n⊢ Disjoint (closure s) t","decl":"theorem Disjoint.closure_left (hd : Disjoint s t) (ht : IsOpen t) :\n    Disjoint (closure s) t :=\n  disjoint_compl_left.mono_left <| closure_minimal hd.subset_compl_right ht.isClosed_compl\n\n"}
{"name":"Disjoint.closure_right","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nhd : Disjoint s t\nhs : IsOpen s\n⊢ Disjoint s (closure t)","decl":"theorem Disjoint.closure_right (hd : Disjoint s t) (hs : IsOpen s) :\n    Disjoint s (closure t) :=\n  (hd.symm.closure_left hs).symm\n\n"}
{"name":"IsClosed.closure_eq","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nh : IsClosed s\n⊢ Eq (closure s) s","decl":"theorem IsClosed.closure_eq (h : IsClosed s) : closure s = s :=\n  Subset.antisymm (closure_minimal (Subset.refl s) h) subset_closure\n\n"}
{"name":"IsClosed.closure_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nhs : IsClosed s\n⊢ HasSubset.Subset (closure s) s","decl":"theorem IsClosed.closure_subset (hs : IsClosed s) : closure s ⊆ s :=\n  closure_minimal (Subset.refl _) hs\n\n"}
{"name":"IsClosed.closure_subset_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nh₁ : IsClosed t\n⊢ Iff (HasSubset.Subset (closure s) t) (HasSubset.Subset s t)","decl":"theorem IsClosed.closure_subset_iff (h₁ : IsClosed t) : closure s ⊆ t ↔ s ⊆ t :=\n  ⟨Subset.trans subset_closure, fun h => closure_minimal h h₁⟩\n\n"}
{"name":"IsClosed.mem_iff_closure_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\nhs : IsClosed s\n⊢ Iff (Membership.mem s x) (HasSubset.Subset (closure (Singleton.singleton x)) s)","decl":"theorem IsClosed.mem_iff_closure_subset (hs : IsClosed s) :\n    x ∈ s ↔ closure ({x} : Set X) ⊆ s :=\n  (hs.closure_subset_iff.trans Set.singleton_subset_iff).symm\n\n"}
{"name":"closure_mono","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (closure s) (closure t)","decl":"@[mono, gcongr]\ntheorem closure_mono (h : s ⊆ t) : closure s ⊆ closure t :=\n  closure_minimal (Subset.trans h subset_closure) isClosed_closure\n\n"}
{"name":"monotone_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_3\ninst✝ : TopologicalSpace X\n⊢ Monotone closure","decl":"theorem monotone_closure (X : Type*) [TopologicalSpace X] : Monotone (@closure X _) := fun _ _ =>\n  closure_mono\n\n"}
{"name":"diff_subset_closure_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (HasSubset.Subset (SDiff.sdiff s t) (closure t)) (HasSubset.Subset s (closure t))","decl":"theorem diff_subset_closure_iff : s \\ t ⊆ closure t ↔ s ⊆ closure t := by\n  rw [diff_subset_iff, union_eq_self_of_subset_left subset_closure]\n\n"}
{"name":"closure_inter_subset_inter_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\n⊢ HasSubset.Subset (closure (Inter.inter s t)) (Inter.inter (closure s) (closure t))","decl":"theorem closure_inter_subset_inter_closure (s t : Set X) :\n    closure (s ∩ t) ⊆ closure s ∩ closure t :=\n  (monotone_closure X).map_inf_le s t\n\n"}
{"name":"isClosed_of_closure_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nh : HasSubset.Subset (closure s) s\n⊢ IsClosed s","decl":"theorem isClosed_of_closure_subset (h : closure s ⊆ s) : IsClosed s := by\n  rw [subset_closure.antisymm h]; exact isClosed_closure\n\n"}
{"name":"closure_eq_iff_isClosed","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Eq (closure s) s) (IsClosed s)","decl":"theorem closure_eq_iff_isClosed : closure s = s ↔ IsClosed s :=\n  ⟨fun h => h ▸ isClosed_closure, IsClosed.closure_eq⟩\n\n"}
{"name":"closure_subset_iff_isClosed","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (HasSubset.Subset (closure s) s) (IsClosed s)","decl":"theorem closure_subset_iff_isClosed : closure s ⊆ s ↔ IsClosed s :=\n  ⟨isClosed_of_closure_subset, IsClosed.closure_subset⟩\n\n"}
{"name":"closure_empty","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Eq (closure EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem closure_empty : closure (∅ : Set X) = ∅ :=\n  isClosed_empty.closure_eq\n\n"}
{"name":"closure_empty_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Iff (Eq (closure s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem closure_empty_iff (s : Set X) : closure s = ∅ ↔ s = ∅ :=\n  ⟨subset_eq_empty subset_closure, fun h => h.symm ▸ closure_empty⟩\n\n"}
{"name":"closure_nonempty_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (closure s).Nonempty s.Nonempty","decl":"@[simp]\ntheorem closure_nonempty_iff : (closure s).Nonempty ↔ s.Nonempty := by\n  simp only [nonempty_iff_ne_empty, Ne, closure_empty_iff]\n\n"}
{"name":"Set.Nonempty.closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\na✝ : s.Nonempty\n⊢ (closure s).Nonempty","decl":"alias ⟨Set.Nonempty.of_closure, Set.Nonempty.closure⟩ := closure_nonempty_iff\n\n"}
{"name":"Set.Nonempty.of_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\na✝ : (closure s).Nonempty\n⊢ s.Nonempty","decl":"alias ⟨Set.Nonempty.of_closure, Set.Nonempty.closure⟩ := closure_nonempty_iff\n\n"}
{"name":"closure_univ","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Eq (closure Set.univ) Set.univ","decl":"@[simp]\ntheorem closure_univ : closure (univ : Set X) = univ :=\n  isClosed_univ.closure_eq\n\n"}
{"name":"closure_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Eq (closure (closure s)) (closure s)","decl":"@[simp]\ntheorem closure_closure : closure (closure s) = closure s :=\n  isClosed_closure.closure_eq\n\n"}
{"name":"closure_eq_compl_interior_compl","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Eq (closure s) (HasCompl.compl (interior (HasCompl.compl s)))","decl":"theorem closure_eq_compl_interior_compl : closure s = (interior sᶜ)ᶜ := by\n  rw [interior, closure, compl_sUnion, compl_image_set_of]\n  simp only [compl_subset_compl, isOpen_compl_iff]\n\n"}
{"name":"closure_union","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\n⊢ Eq (closure (Union.union s t)) (Union.union (closure s) (closure t))","decl":"@[simp]\ntheorem closure_union : closure (s ∪ t) = closure s ∪ closure t := by\n  simp [closure_eq_compl_interior_compl, compl_inter]\n\n"}
{"name":"Set.Finite.closure_biUnion","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nι : Type u_3\ns : Set ι\nhs : s.Finite\nf : ι → Set X\n⊢ Eq (closure (Set.iUnion fun i => Set.iUnion fun h => f i)) (Set.iUnion fun i => Set.iUnion fun h => closure (f i))","decl":"theorem Set.Finite.closure_biUnion {ι : Type*} {s : Set ι} (hs : s.Finite) (f : ι → Set X) :\n    closure (⋃ i ∈ s, f i) = ⋃ i ∈ s, closure (f i) := by\n  simp [closure_eq_compl_interior_compl, hs.interior_biInter]\n\n"}
{"name":"Set.Finite.closure_sUnion","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nS : Set (Set X)\nhS : S.Finite\n⊢ Eq (closure S.sUnion) (Set.iUnion fun s => Set.iUnion fun h => closure s)","decl":"theorem Set.Finite.closure_sUnion {S : Set (Set X)} (hS : S.Finite) :\n    closure (⋃₀ S) = ⋃ s ∈ S, closure s := by\n  rw [sUnion_eq_biUnion, hS.closure_biUnion]\n\n"}
{"name":"Finset.closure_biUnion","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nι : Type u_3\ns : Finset ι\nf : ι → Set X\n⊢ Eq (closure (Set.iUnion fun i => Set.iUnion fun h => f i)) (Set.iUnion fun i => Set.iUnion fun h => closure (f i))","decl":"@[simp]\ntheorem Finset.closure_biUnion {ι : Type*} (s : Finset ι) (f : ι → Set X) :\n    closure (⋃ i ∈ s, f i) = ⋃ i ∈ s, closure (f i) :=\n  s.finite_toSet.closure_biUnion f\n\n"}
{"name":"closure_iUnion_of_finite","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\ninst✝¹ : TopologicalSpace X\ninst✝ : Finite ι\nf : ι → Set X\n⊢ Eq (closure (Set.iUnion fun i => f i)) (Set.iUnion fun i => closure (f i))","decl":"@[simp]\ntheorem closure_iUnion_of_finite [Finite ι] (f : ι → Set X) :\n    closure (⋃ i, f i) = ⋃ i, closure (f i) := by\n  rw [← sUnion_range, (finite_range _).closure_sUnion, biUnion_range]\n\n"}
{"name":"closure_iUnion₂_lt_nat","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nn : Nat\nf : Nat → Set X\n⊢ Eq (closure (Set.iUnion fun m => Set.iUnion fun h => f m)) (Set.iUnion fun m => Set.iUnion fun h => closure (f m))","decl":"@[simp]\ntheorem closure_iUnion₂_lt_nat {n : ℕ} (f : ℕ → Set X) :\n    closure (⋃ m < n, f m) = ⋃ m < n, closure (f m) :=\n  (finite_lt_nat n).closure_biUnion f\n\n"}
{"name":"closure_iUnion₂_le_nat","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nn : Nat\nf : Nat → Set X\n⊢ Eq (closure (Set.iUnion fun m => Set.iUnion fun h => f m)) (Set.iUnion fun m => Set.iUnion fun h => closure (f m))","decl":"@[simp]\ntheorem closure_iUnion₂_le_nat {n : ℕ} (f : ℕ → Set X) :\n    closure (⋃ m ≤ n, f m) = ⋃ m ≤ n, closure (f m) :=\n  (finite_le_nat n).closure_biUnion f\n\n"}
{"name":"interior_subset_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ HasSubset.Subset (interior s) (closure s)","decl":"theorem interior_subset_closure : interior s ⊆ closure s :=\n  Subset.trans interior_subset subset_closure\n\n"}
{"name":"interior_compl","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Eq (interior (HasCompl.compl s)) (HasCompl.compl (closure s))","decl":"@[simp]\ntheorem interior_compl : interior sᶜ = (closure s)ᶜ := by\n  simp [closure_eq_compl_interior_compl]\n\n"}
{"name":"closure_compl","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Eq (closure (HasCompl.compl s)) (HasCompl.compl (interior s))","decl":"@[simp]\ntheorem closure_compl : closure sᶜ = (interior s)ᶜ := by\n  simp [closure_eq_compl_interior_compl]\n\n"}
{"name":"mem_closure_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Membership.mem (closure s) x) (∀ (o : Set X), IsOpen o → Membership.mem o x → (Inter.inter o s).Nonempty)","decl":"theorem mem_closure_iff :\n    x ∈ closure s ↔ ∀ o, IsOpen o → x ∈ o → (o ∩ s).Nonempty :=\n  ⟨fun h o oo ao =>\n    by_contradiction fun os =>\n      have : s ⊆ oᶜ := fun x xs xo => os ⟨x, xo, xs⟩\n      closure_minimal this (isClosed_compl_iff.2 oo) h ao,\n    fun H _ ⟨h₁, h₂⟩ =>\n    by_contradiction fun nc =>\n      let ⟨_, hc, hs⟩ := H _ h₁.isOpen_compl nc\n      hc (h₂ hs)⟩\n\n"}
{"name":"closure_inter_open_nonempty_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nh : IsOpen t\n⊢ Iff (Inter.inter (closure s) t).Nonempty (Inter.inter s t).Nonempty","decl":"theorem closure_inter_open_nonempty_iff (h : IsOpen t) :\n    (closure s ∩ t).Nonempty ↔ (s ∩ t).Nonempty :=\n  ⟨fun ⟨_x, hxcs, hxt⟩ => inter_comm t s ▸ mem_closure_iff.1 hxcs t h hxt, fun h =>\n    h.mono <| inf_le_inf_right t subset_closure⟩\n\n"}
{"name":"Filter.le_lift'_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nl : Filter X\n⊢ LE.le l (l.lift' closure)","decl":"theorem Filter.le_lift'_closure (l : Filter X) : l ≤ l.lift' closure :=\n  le_lift'.2 fun _ h => mem_of_superset h subset_closure\n\n"}
{"name":"Filter.HasBasis.lift'_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\ninst✝ : TopologicalSpace X\nl : Filter X\np : ι → Prop\ns : ι → Set X\nh : l.HasBasis p s\n⊢ (l.lift' closure).HasBasis p fun i => closure (s i)","decl":"theorem Filter.HasBasis.lift'_closure {l : Filter X} {p : ι → Prop} {s : ι → Set X}\n    (h : l.HasBasis p s) : (l.lift' closure).HasBasis p fun i => closure (s i) :=\n  h.lift' (monotone_closure X)\n\n"}
{"name":"Filter.HasBasis.lift'_closure_eq_self","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\ninst✝ : TopologicalSpace X\nl : Filter X\np : ι → Prop\ns : ι → Set X\nh : l.HasBasis p s\nhc : ∀ (i : ι), p i → IsClosed (s i)\n⊢ Eq (l.lift' closure) l","decl":"theorem Filter.HasBasis.lift'_closure_eq_self {l : Filter X} {p : ι → Prop} {s : ι → Set X}\n    (h : l.HasBasis p s) (hc : ∀ i, p i → IsClosed (s i)) : l.lift' closure = l :=\n  le_antisymm (h.ge_iff.2 fun i hi => (hc i hi).closure_eq ▸ mem_lift' (h.mem_of_mem hi))\n    l.le_lift'_closure\n\n"}
{"name":"Filter.lift'_closure_eq_bot","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nl : Filter X\n⊢ Iff (Eq (l.lift' closure) Bot.bot) (Eq l Bot.bot)","decl":"@[simp]\ntheorem Filter.lift'_closure_eq_bot {l : Filter X} : l.lift' closure = ⊥ ↔ l = ⊥ :=\n  ⟨fun h => bot_unique <| h ▸ l.le_lift'_closure, fun h =>\n    h.symm ▸ by rw [lift'_bot (monotone_closure _), closure_empty, principal_empty]⟩\n\n"}
{"name":"dense_iff_closure_eq","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Dense s) (Eq (closure s) Set.univ)","decl":"theorem dense_iff_closure_eq : Dense s ↔ closure s = univ :=\n  eq_univ_iff_forall.symm\n\n"}
{"name":"Dense.closure_eq","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\na✝ : Dense s\n⊢ Eq (closure s) Set.univ","decl":"alias ⟨Dense.closure_eq, _⟩ := dense_iff_closure_eq\n\n"}
{"name":"interior_eq_empty_iff_dense_compl","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Eq (interior s) EmptyCollection.emptyCollection) (Dense (HasCompl.compl s))","decl":"theorem interior_eq_empty_iff_dense_compl : interior s = ∅ ↔ Dense sᶜ := by\n  rw [dense_iff_closure_eq, closure_compl, compl_univ_iff]\n\n"}
{"name":"Dense.interior_compl","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nh : Dense s\n⊢ Eq (interior (HasCompl.compl s)) EmptyCollection.emptyCollection","decl":"theorem Dense.interior_compl (h : Dense s) : interior sᶜ = ∅ :=\n  interior_eq_empty_iff_dense_compl.2 <| by rwa [compl_compl]\n\n"}
{"name":"dense_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Dense (closure s)) (Dense s)","decl":"/-- The closure of a set `s` is dense if and only if `s` is dense. -/\n@[simp]\ntheorem dense_closure : Dense (closure s) ↔ Dense s := by\n  rw [Dense, Dense, closure_closure]\n\n"}
{"name":"Dense.closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\na✝ : Dense s\n⊢ Dense (closure s)","decl":"protected alias ⟨_, Dense.closure⟩ := dense_closure\n"}
{"name":"Dense.of_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\na✝ : Dense (closure s)\n⊢ Dense s","decl":"alias ⟨Dense.of_closure, _⟩ := dense_closure\n\n"}
{"name":"dense_univ","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Dense Set.univ","decl":"@[simp]\ntheorem dense_univ : Dense (univ : Set X) := fun _ => subset_closure trivial\n\n"}
{"name":"dense_iff_inter_open","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Dense s) (∀ (U : Set X), IsOpen U → U.Nonempty → (Inter.inter U s).Nonempty)","decl":"/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem dense_iff_inter_open :\n    Dense s ↔ ∀ U, IsOpen U → U.Nonempty → (U ∩ s).Nonempty := by\n  constructor <;> intro h\n  · rintro U U_op ⟨x, x_in⟩\n    exact mem_closure_iff.1 (h _) U U_op x_in\n  · intro x\n    rw [mem_closure_iff]\n    intro U U_op x_in\n    exact h U U_op ⟨_, x_in⟩\n\n"}
{"name":"Dense.inter_open_nonempty","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\na✝² : Dense s\nU : Set X\na✝¹ : IsOpen U\na✝ : U.Nonempty\n⊢ (Inter.inter U s).Nonempty","decl":"alias ⟨Dense.inter_open_nonempty, _⟩ := dense_iff_inter_open\n\n"}
{"name":"Dense.exists_mem_open","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nhs : Dense s\nU : Set X\nho : IsOpen U\nhne : U.Nonempty\n⊢ Exists fun x => And (Membership.mem s x) (Membership.mem U x)","decl":"theorem Dense.exists_mem_open (hs : Dense s) {U : Set X} (ho : IsOpen U)\n    (hne : U.Nonempty) : ∃ x ∈ s, x ∈ U :=\n  let ⟨x, hx⟩ := hs.inter_open_nonempty U ho hne\n  ⟨x, hx.2, hx.1⟩\n\n"}
{"name":"Dense.nonempty_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nhs : Dense s\n⊢ Iff s.Nonempty (Nonempty X)","decl":"theorem Dense.nonempty_iff (hs : Dense s) : s.Nonempty ↔ Nonempty X :=\n  ⟨fun ⟨x, _⟩ => ⟨x⟩, fun ⟨x⟩ =>\n    let ⟨y, hy⟩ := hs.inter_open_nonempty _ isOpen_univ ⟨x, trivial⟩\n    ⟨y, hy.2⟩⟩\n\n"}
{"name":"Dense.nonempty","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nh : Nonempty X\nhs : Dense s\n⊢ s.Nonempty","decl":"theorem Dense.nonempty [h : Nonempty X] (hs : Dense s) : s.Nonempty :=\n  hs.nonempty_iff.2 h\n\n"}
{"name":"Dense.mono","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns₁ s₂ : Set X\ninst✝ : TopologicalSpace X\nh : HasSubset.Subset s₁ s₂\nhd : Dense s₁\n⊢ Dense s₂","decl":"@[mono]\ntheorem Dense.mono (h : s₁ ⊆ s₂) (hd : Dense s₁) : Dense s₂ := fun x =>\n  closure_mono h (hd x)\n\n"}
{"name":"dense_compl_singleton_iff_not_open","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\n⊢ Iff (Dense (HasCompl.compl (Singleton.singleton x))) (Not (IsOpen (Singleton.singleton x)))","decl":"/-- Complement to a singleton is dense if and only if the singleton is not an open set. -/\ntheorem dense_compl_singleton_iff_not_open :\n    Dense ({x}ᶜ : Set X) ↔ ¬IsOpen ({x} : Set X) := by\n  constructor\n  · intro hd ho\n    exact (hd.inter_open_nonempty _ ho (singleton_nonempty _)).ne_empty (inter_compl_self _)\n  · refine fun ho => dense_iff_inter_open.2 fun U hU hne => inter_compl_nonempty_iff.2 fun hUx => ?_\n    obtain rfl : U = {x} := eq_singleton_iff_nonempty_unique_mem.2 ⟨hne, hUx⟩\n    exact ho hU\n\n"}
{"name":"Dense.induction","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nhs : Dense s\nP : X → Prop\nmem : ∀ (x : X), Membership.mem s x → P x\nisClosed : IsClosed (setOf fun x => P x)\nx : X\n⊢ P x","decl":"/-- If a closed property holds for a dense subset, it holds for the whole space. -/\n@[elab_as_elim]\nlemma Dense.induction (hs : Dense s) {P : X → Prop}\n    (mem : ∀ x ∈ s, P x) (isClosed : IsClosed { x | P x }) (x : X) : P x :=\n  hs.closure_eq.symm.subset.trans (isClosed.closure_subset_iff.mpr mem) trivial\n\n"}
{"name":"IsOpen.subset_interior_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\ns_open : IsOpen s\n⊢ HasSubset.Subset s (interior (closure s))","decl":"theorem IsOpen.subset_interior_closure {s : Set X} (s_open : IsOpen s) :\n    s ⊆ interior (closure s) := s_open.subset_interior_iff.mpr subset_closure\n\n"}
{"name":"IsClosed.closure_interior_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\ns_closed : IsClosed s\n⊢ HasSubset.Subset (closure (interior s)) s","decl":"theorem IsClosed.closure_interior_subset {s : Set X} (s_closed : IsClosed s) :\n    closure (interior s) ⊆ s := s_closed.closure_subset_iff.mpr interior_subset\n\n"}
{"name":"closure_diff_interior","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (SDiff.sdiff (closure s) (interior s)) (frontier s)","decl":"@[simp]\ntheorem closure_diff_interior (s : Set X) : closure s \\ interior s = frontier s :=\n  rfl\n\n"}
{"name":"disjoint_interior_frontier","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Disjoint (interior s) (frontier s)","decl":"/-- Interior and frontier are disjoint. -/\nlemma disjoint_interior_frontier : Disjoint (interior s) (frontier s) := by\n  rw [disjoint_iff_inter_eq_empty, ← closure_diff_interior, diff_eq,\n    ← inter_assoc, inter_comm, ← inter_assoc, compl_inter_self, empty_inter]\n\n"}
{"name":"closure_diff_frontier","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (SDiff.sdiff (closure s) (frontier s)) (interior s)","decl":"@[simp]\ntheorem closure_diff_frontier (s : Set X) : closure s \\ frontier s = interior s := by\n  rw [frontier, diff_diff_right_self, inter_eq_self_of_subset_right interior_subset_closure]\n\n"}
{"name":"self_diff_frontier","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (SDiff.sdiff s (frontier s)) (interior s)","decl":"@[simp]\ntheorem self_diff_frontier (s : Set X) : s \\ frontier s = interior s := by\n  rw [frontier, diff_diff_right, diff_eq_empty.2 subset_closure,\n    inter_eq_self_of_subset_right interior_subset, empty_union]\n\n"}
{"name":"frontier_eq_closure_inter_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Eq (frontier s) (Inter.inter (closure s) (closure (HasCompl.compl s)))","decl":"theorem frontier_eq_closure_inter_closure : frontier s = closure s ∩ closure sᶜ := by\n  rw [closure_compl, frontier, diff_eq]\n\n"}
{"name":"frontier_subset_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ HasSubset.Subset (frontier s) (closure s)","decl":"theorem frontier_subset_closure : frontier s ⊆ closure s :=\n  diff_subset\n\n"}
{"name":"frontier_subset_iff_isClosed","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (HasSubset.Subset (frontier s) s) (IsClosed s)","decl":"theorem frontier_subset_iff_isClosed : frontier s ⊆ s ↔ IsClosed s := by\n  rw [frontier, diff_subset_iff, union_eq_right.mpr interior_subset, closure_subset_iff_isClosed]\n\n"}
{"name":"IsClosed.frontier_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\na✝ : IsClosed s\n⊢ HasSubset.Subset (frontier s) s","decl":"alias ⟨_, IsClosed.frontier_subset⟩ := frontier_subset_iff_isClosed\n\n"}
{"name":"frontier_closure_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ HasSubset.Subset (frontier (closure s)) (frontier s)","decl":"theorem frontier_closure_subset : frontier (closure s) ⊆ frontier s :=\n  diff_subset_diff closure_closure.subset <| interior_mono subset_closure\n\n"}
{"name":"frontier_interior_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ HasSubset.Subset (frontier (interior s)) (frontier s)","decl":"theorem frontier_interior_subset : frontier (interior s) ⊆ frontier s :=\n  diff_subset_diff (closure_mono interior_subset) interior_interior.symm.subset\n\n"}
{"name":"frontier_compl","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (frontier (HasCompl.compl s)) (frontier s)","decl":"/-- The complement of a set has the same frontier as the original set. -/\n@[simp]\ntheorem frontier_compl (s : Set X) : frontier sᶜ = frontier s := by\n  simp only [frontier_eq_closure_inter_closure, compl_compl, inter_comm]\n\n"}
{"name":"frontier_univ","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Eq (frontier Set.univ) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem frontier_univ : frontier (univ : Set X) = ∅ := by simp [frontier]\n\n"}
{"name":"frontier_empty","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Eq (frontier EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem frontier_empty : frontier (∅ : Set X) = ∅ := by simp [frontier]\n\n"}
{"name":"frontier_inter_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\n⊢ HasSubset.Subset (frontier (Inter.inter s t)) (Union.union (Inter.inter (frontier s) (closure t)) (Inter.inter (closure s) (frontier t)))","decl":"theorem frontier_inter_subset (s t : Set X) :\n    frontier (s ∩ t) ⊆ frontier s ∩ closure t ∪ closure s ∩ frontier t := by\n  simp only [frontier_eq_closure_inter_closure, compl_inter, closure_union]\n  refine (inter_subset_inter_left _ (closure_inter_subset_inter_closure s t)).trans_eq ?_\n  simp only [inter_union_distrib_left, union_inter_distrib_right, inter_assoc,\n    inter_comm (closure t)]\n\n"}
{"name":"frontier_union_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\n⊢ HasSubset.Subset (frontier (Union.union s t)) (Union.union (Inter.inter (frontier s) (closure (HasCompl.compl t))) (Inter.inter (closure (HasCompl.compl s)) (frontier t)))","decl":"theorem frontier_union_subset (s t : Set X) :\n    frontier (s ∪ t) ⊆ frontier s ∩ closure tᶜ ∪ closure sᶜ ∩ frontier t := by\n  simpa only [frontier_compl, ← compl_union] using frontier_inter_subset sᶜ tᶜ\n\n"}
{"name":"IsClosed.frontier_eq","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nhs : IsClosed s\n⊢ Eq (frontier s) (SDiff.sdiff s (interior s))","decl":"theorem IsClosed.frontier_eq (hs : IsClosed s) : frontier s = s \\ interior s := by\n  rw [frontier, hs.closure_eq]\n\n"}
{"name":"IsOpen.frontier_eq","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nhs : IsOpen s\n⊢ Eq (frontier s) (SDiff.sdiff (closure s) s)","decl":"theorem IsOpen.frontier_eq (hs : IsOpen s) : frontier s = closure s \\ s := by\n  rw [frontier, hs.interior_eq]\n\n"}
{"name":"IsOpen.inter_frontier_eq","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nhs : IsOpen s\n⊢ Eq (Inter.inter s (frontier s)) EmptyCollection.emptyCollection","decl":"theorem IsOpen.inter_frontier_eq (hs : IsOpen s) : s ∩ frontier s = ∅ := by\n  rw [hs.frontier_eq, inter_diff_self]\n\n"}
{"name":"disjoint_frontier_iff_isOpen","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Disjoint (frontier s) s) (IsOpen s)","decl":"theorem disjoint_frontier_iff_isOpen : Disjoint (frontier s) s ↔ IsOpen s := by\n  rw [← isClosed_compl_iff, ← frontier_subset_iff_isClosed,\n    frontier_compl, subset_compl_iff_disjoint_right]\n\n"}
{"name":"isClosed_frontier","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ IsClosed (frontier s)","decl":"/-- The frontier of a set is closed. -/\ntheorem isClosed_frontier : IsClosed (frontier s) := by\n  rw [frontier_eq_closure_inter_closure]; exact IsClosed.inter isClosed_closure isClosed_closure\n\n"}
{"name":"interior_frontier","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nh : IsClosed s\n⊢ Eq (interior (frontier s)) EmptyCollection.emptyCollection","decl":"/-- The frontier of a closed set has no interior point. -/\ntheorem interior_frontier (h : IsClosed s) : interior (frontier s) = ∅ := by\n  have A : frontier s = s \\ interior s := h.frontier_eq\n  have B : interior (frontier s) ⊆ interior s := by rw [A]; exact interior_mono diff_subset\n  have C : interior (frontier s) ⊆ frontier s := interior_subset\n  have : interior (frontier s) ⊆ interior s ∩ (s \\ interior s) :=\n    subset_inter B (by simpa [A] using C)\n  rwa [inter_diff_self, subset_empty_iff] at this\n\n"}
{"name":"closure_eq_interior_union_frontier","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (closure s) (Union.union (interior s) (frontier s))","decl":"theorem closure_eq_interior_union_frontier (s : Set X) : closure s = interior s ∪ frontier s :=\n  (union_diff_cancel interior_subset_closure).symm\n\n"}
{"name":"closure_eq_self_union_frontier","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\n⊢ Eq (closure s) (Union.union s (frontier s))","decl":"theorem closure_eq_self_union_frontier (s : Set X) : closure s = s ∪ frontier s :=\n  (union_diff_cancel' interior_subset subset_closure).symm\n\n"}
{"name":"Disjoint.frontier_left","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nht : IsOpen t\nhd : Disjoint s t\n⊢ Disjoint (frontier s) t","decl":"theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=\n  subset_compl_iff_disjoint_right.1 <|\n    frontier_subset_closure.trans <| closure_minimal (disjoint_left.1 hd) <| isClosed_compl_iff.2 ht\n\n"}
{"name":"Disjoint.frontier_right","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nhs : IsOpen s\nhd : Disjoint s t\n⊢ Disjoint s (frontier t)","decl":"theorem Disjoint.frontier_right (hs : IsOpen s) (hd : Disjoint s t) : Disjoint s (frontier t) :=\n  (hd.symm.frontier_left hs).symm\n\n"}
{"name":"frontier_eq_inter_compl_interior","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Eq (frontier s) (Inter.inter (HasCompl.compl (interior s)) (HasCompl.compl (interior (HasCompl.compl s))))","decl":"theorem frontier_eq_inter_compl_interior :\n    frontier s = (interior s)ᶜ ∩ (interior sᶜ)ᶜ := by\n  rw [← frontier_compl, ← closure_compl, ← diff_eq, closure_diff_interior]\n\n"}
{"name":"compl_frontier_eq_union_interior","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Eq (HasCompl.compl (frontier s)) (Union.union (interior s) (interior (HasCompl.compl s)))","decl":"theorem compl_frontier_eq_union_interior :\n    (frontier s)ᶜ = interior s ∪ interior sᶜ := by\n  rw [frontier_eq_inter_compl_interior]\n  simp only [compl_inter, compl_compl]\n\n"}
{"name":"nhds_def'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (nhds x) (iInf fun s => iInf fun x_1 => iInf fun x => Filter.principal s)","decl":"theorem nhds_def' (x : X) : 𝓝 x = ⨅ (s : Set X) (_ : IsOpen s) (_ : x ∈ s), 𝓟 s := by\n  simp only [nhds_def, mem_setOf_eq, @and_comm (x ∈ _), iInf_and]\n\n"}
{"name":"nhds_basis_opens","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\n⊢ (nhds x).HasBasis (fun s => And (Membership.mem s x) (IsOpen s)) fun s => s","decl":"/-- The open sets containing `x` are a basis for the neighborhood filter. See `nhds_basis_opens'`\nfor a variant using open neighborhoods instead. -/\ntheorem nhds_basis_opens (x : X) :\n    (𝓝 x).HasBasis (fun s : Set X => x ∈ s ∧ IsOpen s) fun s => s := by\n  rw [nhds_def]\n  exact hasBasis_biInf_principal\n    (fun s ⟨has, hs⟩ t ⟨hat, ht⟩ =>\n      ⟨s ∩ t, ⟨⟨has, hat⟩, IsOpen.inter hs ht⟩, ⟨inter_subset_left, inter_subset_right⟩⟩)\n    ⟨univ, ⟨mem_univ x, isOpen_univ⟩⟩\n\n"}
{"name":"nhds_basis_closeds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\n⊢ (nhds x).HasBasis (fun s => And (Not (Membership.mem s x)) (IsClosed s)) HasCompl.compl","decl":"theorem nhds_basis_closeds (x : X) : (𝓝 x).HasBasis (fun s : Set X => x ∉ s ∧ IsClosed s) compl :=\n  ⟨fun t => (nhds_basis_opens x).mem_iff.trans <|\n    compl_surjective.exists.trans <| by simp only [isOpen_compl_iff, mem_compl_iff]⟩\n\n"}
{"name":"lift'_nhds_interior","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq ((nhds x).lift' interior) (nhds x)","decl":"@[simp]\ntheorem lift'_nhds_interior (x : X) : (𝓝 x).lift' interior = 𝓝 x :=\n  (nhds_basis_opens x).lift'_interior_eq_self fun _ ↦ And.right\n\n"}
{"name":"Filter.HasBasis.nhds_interior","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\ninst✝ : TopologicalSpace X\nx : X\np : ι → Prop\ns : ι → Set X\nh : (nhds x).HasBasis p s\n⊢ (nhds x).HasBasis p fun x => interior (s x)","decl":"theorem Filter.HasBasis.nhds_interior {x : X} {p : ι → Prop} {s : ι → Set X}\n    (h : (𝓝 x).HasBasis p s) : (𝓝 x).HasBasis p (interior <| s ·) :=\n  lift'_nhds_interior x ▸ h.lift'_interior\n\n"}
{"name":"le_nhds_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nf : Filter X\n⊢ Iff (LE.le f (nhds x)) (∀ (s : Set X), Membership.mem s x → IsOpen s → Membership.mem f s)","decl":"/-- A filter lies below the neighborhood filter at `x` iff it contains every open set around `x`. -/\ntheorem le_nhds_iff {f} : f ≤ 𝓝 x ↔ ∀ s : Set X, x ∈ s → IsOpen s → s ∈ f := by simp [nhds_def]\n\n"}
{"name":"nhds_le_of_le","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\nf : Filter X\nh : Membership.mem s x\no : IsOpen s\nsf : LE.le (Filter.principal s) f\n⊢ LE.le (nhds x) f","decl":"/-- To show a filter is above the neighborhood filter at `x`, it suffices to show that it is above\nthe principal filter of some open set `s` containing `x`. -/\ntheorem nhds_le_of_le {f} (h : x ∈ s) (o : IsOpen s) (sf : 𝓟 s ≤ f) : 𝓝 x ≤ f := by\n  rw [nhds_def]; exact iInf₂_le_of_le s ⟨h, o⟩ sf\n\n"}
{"name":"mem_nhds_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Membership.mem (nhds x) s) (Exists fun t => And (HasSubset.Subset t s) (And (IsOpen t) (Membership.mem t x)))","decl":"theorem mem_nhds_iff : s ∈ 𝓝 x ↔ ∃ t ⊆ s, IsOpen t ∧ x ∈ t :=\n  (nhds_basis_opens x).mem_iff.trans <| exists_congr fun _ =>\n    ⟨fun h => ⟨h.2, h.1.2, h.1.1⟩, fun h => ⟨⟨h.2.2, h.2.1⟩, h.1⟩⟩\n\n"}
{"name":"eventually_nhds_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\np : X → Prop\n⊢ Iff (Filter.Eventually (fun y => p y) (nhds x)) (Exists fun t => And (∀ (y : X), Membership.mem t y → p y) (And (IsOpen t) (Membership.mem t x)))","decl":"/-- A predicate is true in a neighborhood of `x` iff it is true for all the points in an open set\ncontaining `x`. -/\ntheorem eventually_nhds_iff {p : X → Prop} :\n    (∀ᶠ y in 𝓝 x, p y) ↔ ∃ t : Set X, (∀ y ∈ t, p y) ∧ IsOpen t ∧ x ∈ t :=\n  mem_nhds_iff.trans <| by simp only [subset_def, exists_prop, mem_setOf_eq]\n\n"}
{"name":"frequently_nhds_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\np : X → Prop\n⊢ Iff (Filter.Frequently (fun y => p y) (nhds x)) (∀ (U : Set X), Membership.mem U x → IsOpen U → Exists fun y => And (Membership.mem U y) (p y))","decl":"theorem frequently_nhds_iff {p : X → Prop} :\n    (∃ᶠ y in 𝓝 x, p y) ↔ ∀ U : Set X, x ∈ U → IsOpen U → ∃ y ∈ U, p y :=\n  (nhds_basis_opens x).frequently_iff.trans <| by simp\n\n"}
{"name":"mem_interior_iff_mem_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Membership.mem (interior s) x) (Membership.mem (nhds x) s)","decl":"theorem mem_interior_iff_mem_nhds : x ∈ interior s ↔ s ∈ 𝓝 x :=\n  mem_interior.trans mem_nhds_iff.symm\n\n"}
{"name":"map_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ninst✝ : TopologicalSpace X\nf : X → α\n⊢ Eq (Filter.map f (nhds x)) (iInf fun s => iInf fun h => Filter.principal (Set.image f s))","decl":"theorem map_nhds {f : X → α} :\n    map f (𝓝 x) = ⨅ s ∈ { s : Set X | x ∈ s ∧ IsOpen s }, 𝓟 (f '' s) :=\n  ((nhds_basis_opens x).map f).eq_biInf\n\n"}
{"name":"mem_of_mem_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\na✝ : Membership.mem (nhds x) s\n⊢ Membership.mem s x","decl":"theorem mem_of_mem_nhds : s ∈ 𝓝 x → x ∈ s := fun H =>\n  let ⟨_t, ht, _, hs⟩ := mem_nhds_iff.1 H; ht hs\n\n"}
{"name":"Filter.Eventually.self_of_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\np : X → Prop\nh : Filter.Eventually (fun y => p y) (nhds x)\n⊢ p x","decl":"/-- If a predicate is true in a neighborhood of `x`, then it is true for `x`. -/\ntheorem Filter.Eventually.self_of_nhds {p : X → Prop} (h : ∀ᶠ y in 𝓝 x, p y) : p x :=\n  mem_of_mem_nhds h\n\n"}
{"name":"IsOpen.mem_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\nhs : IsOpen s\nhx : Membership.mem s x\n⊢ Membership.mem (nhds x) s","decl":"theorem IsOpen.mem_nhds (hs : IsOpen s) (hx : x ∈ s) : s ∈ 𝓝 x :=\n  mem_nhds_iff.2 ⟨s, Subset.refl _, hs, hx⟩\n\n"}
{"name":"IsOpen.mem_nhds_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\nhs : IsOpen s\n⊢ Iff (Membership.mem (nhds x) s) (Membership.mem s x)","decl":"protected theorem IsOpen.mem_nhds_iff (hs : IsOpen s) : s ∈ 𝓝 x ↔ x ∈ s :=\n  ⟨mem_of_mem_nhds, fun hx => mem_nhds_iff.2 ⟨s, Subset.rfl, hs, hx⟩⟩\n\n"}
{"name":"IsClosed.compl_mem_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\nhs : IsClosed s\nhx : Not (Membership.mem s x)\n⊢ Membership.mem (nhds x) (HasCompl.compl s)","decl":"theorem IsClosed.compl_mem_nhds (hs : IsClosed s) (hx : x ∉ s) : sᶜ ∈ 𝓝 x :=\n  hs.isOpen_compl.mem_nhds (mem_compl hx)\n\n"}
{"name":"IsOpen.eventually_mem","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\nhs : IsOpen s\nhx : Membership.mem s x\n⊢ Filter.Eventually (fun x => Membership.mem s x) (nhds x)","decl":"theorem IsOpen.eventually_mem (hs : IsOpen s) (hx : x ∈ s) :\n    ∀ᶠ x in 𝓝 x, x ∈ s :=\n  IsOpen.mem_nhds hs hx\n\n"}
{"name":"nhds_basis_opens'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\n⊢ (nhds x).HasBasis (fun s => And (Membership.mem (nhds x) s) (IsOpen s)) fun x => x","decl":"/-- The open neighborhoods of `x` are a basis for the neighborhood filter. See `nhds_basis_opens`\nfor a variant using open sets around `x` instead. -/\ntheorem nhds_basis_opens' (x : X) :\n    (𝓝 x).HasBasis (fun s : Set X => s ∈ 𝓝 x ∧ IsOpen s) fun x => x := by\n  convert nhds_basis_opens x using 2\n  exact and_congr_left_iff.2 IsOpen.mem_nhds_iff\n\n"}
{"name":"exists_open_set_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nU : Set X\nh : ∀ (x : X), Membership.mem s x → Membership.mem (nhds x) U\n⊢ Exists fun V => And (HasSubset.Subset s V) (And (IsOpen V) (HasSubset.Subset V U))","decl":"/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem exists_open_set_nhds {U : Set X} (h : ∀ x ∈ s, U ∈ 𝓝 x) :\n    ∃ V : Set X, s ⊆ V ∧ IsOpen V ∧ V ⊆ U :=\n  ⟨interior U, fun x hx => mem_interior_iff_mem_nhds.2 <| h x hx, isOpen_interior, interior_subset⟩\n\n"}
{"name":"exists_open_set_nhds'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nU : Set X\nh : Membership.mem (iSup fun x => iSup fun h => nhds x) U\n⊢ Exists fun V => And (HasSubset.Subset s V) (And (IsOpen V) (HasSubset.Subset V U))","decl":"/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem exists_open_set_nhds' {U : Set X} (h : U ∈ ⨆ x ∈ s, 𝓝 x) :\n    ∃ V : Set X, s ⊆ V ∧ IsOpen V ∧ V ⊆ U :=\n  exists_open_set_nhds (by simpa using h)\n\n"}
{"name":"Filter.Eventually.eventually_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\np : X → Prop\nh : Filter.Eventually (fun y => p y) (nhds x)\n⊢ Filter.Eventually (fun y => Filter.Eventually (fun x => p x) (nhds y)) (nhds x)","decl":"/-- If a predicate is true in a neighbourhood of `x`, then for `y` sufficiently close\nto `x` this predicate is true in a neighbourhood of `y`. -/\ntheorem Filter.Eventually.eventually_nhds {p : X → Prop} (h : ∀ᶠ y in 𝓝 x, p y) :\n    ∀ᶠ y in 𝓝 x, ∀ᶠ x in 𝓝 y, p x :=\n  let ⟨t, htp, hto, ha⟩ := eventually_nhds_iff.1 h\n  eventually_nhds_iff.2 ⟨t, fun _x hx => eventually_nhds_iff.2 ⟨t, htp, hto, hx⟩, hto, ha⟩\n\n"}
{"name":"eventually_eventually_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\np : X → Prop\n⊢ Iff (Filter.Eventually (fun y => Filter.Eventually (fun x => p x) (nhds y)) (nhds x)) (Filter.Eventually (fun x => p x) (nhds x))","decl":"@[simp]\ntheorem eventually_eventually_nhds {p : X → Prop} :\n    (∀ᶠ y in 𝓝 x, ∀ᶠ x in 𝓝 y, p x) ↔ ∀ᶠ x in 𝓝 x, p x :=\n  ⟨fun h => h.self_of_nhds, fun h => h.eventually_nhds⟩\n\n"}
{"name":"frequently_frequently_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\np : X → Prop\n⊢ Iff (Filter.Frequently (fun x' => Filter.Frequently (fun x'' => p x'') (nhds x')) (nhds x)) (Filter.Frequently (fun x => p x) (nhds x))","decl":"@[simp]\ntheorem frequently_frequently_nhds {p : X → Prop} :\n    (∃ᶠ x' in 𝓝 x, ∃ᶠ x'' in 𝓝 x', p x'') ↔ ∃ᶠ x in 𝓝 x, p x := by\n  rw [← not_iff_not]\n  simp only [not_frequently, eventually_eventually_nhds]\n\n"}
{"name":"eventually_mem_nhds_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Filter.Eventually (fun x' => Membership.mem (nhds x') s) (nhds x)) (Membership.mem (nhds x) s)","decl":"@[simp]\ntheorem eventually_mem_nhds_iff : (∀ᶠ x' in 𝓝 x, s ∈ 𝓝 x') ↔ s ∈ 𝓝 x :=\n  eventually_eventually_nhds\n\n"}
{"name":"eventually_mem_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Filter.Eventually (fun x' => Membership.mem (nhds x') s) (nhds x)) (Membership.mem (nhds x) s)","decl":"@[deprecated (since := \"2024-10-04\")] alias eventually_mem_nhds := eventually_mem_nhds_iff\n\n"}
{"name":"nhds_bind_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\n⊢ Eq ((nhds x).bind nhds) (nhds x)","decl":"@[simp]\ntheorem nhds_bind_nhds : (𝓝 x).bind 𝓝 = 𝓝 x :=\n  Filter.ext fun _ => eventually_eventually_nhds\n\n"}
{"name":"eventually_eventuallyEq_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ninst✝ : TopologicalSpace X\nf g : X → α\n⊢ Iff (Filter.Eventually (fun y => (nhds y).EventuallyEq f g) (nhds x)) ((nhds x).EventuallyEq f g)","decl":"@[simp]\ntheorem eventually_eventuallyEq_nhds {f g : X → α} :\n    (∀ᶠ y in 𝓝 x, f =ᶠ[𝓝 y] g) ↔ f =ᶠ[𝓝 x] g :=\n  eventually_eventually_nhds\n\n"}
{"name":"Filter.EventuallyEq.eq_of_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ninst✝ : TopologicalSpace X\nf g : X → α\nh : (nhds x).EventuallyEq f g\n⊢ Eq (f x) (g x)","decl":"theorem Filter.EventuallyEq.eq_of_nhds {f g : X → α} (h : f =ᶠ[𝓝 x] g) : f x = g x :=\n  h.self_of_nhds\n\n"}
{"name":"eventually_eventuallyLE_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ninst✝¹ : TopologicalSpace X\ninst✝ : LE α\nf g : X → α\n⊢ Iff (Filter.Eventually (fun y => (nhds y).EventuallyLE f g) (nhds x)) ((nhds x).EventuallyLE f g)","decl":"@[simp]\ntheorem eventually_eventuallyLE_nhds [LE α] {f g : X → α} :\n    (∀ᶠ y in 𝓝 x, f ≤ᶠ[𝓝 y] g) ↔ f ≤ᶠ[𝓝 x] g :=\n  eventually_eventually_nhds\n\n"}
{"name":"Filter.EventuallyEq.eventuallyEq_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ninst✝ : TopologicalSpace X\nf g : X → α\nh : (nhds x).EventuallyEq f g\n⊢ Filter.Eventually (fun y => (nhds y).EventuallyEq f g) (nhds x)","decl":"/-- If two functions are equal in a neighbourhood of `x`, then for `y` sufficiently close\nto `x` these functions are equal in a neighbourhood of `y`. -/\ntheorem Filter.EventuallyEq.eventuallyEq_nhds {f g : X → α} (h : f =ᶠ[𝓝 x] g) :\n    ∀ᶠ y in 𝓝 x, f =ᶠ[𝓝 y] g :=\n  h.eventually_nhds\n\n"}
{"name":"Filter.EventuallyLE.eventuallyLE_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ninst✝¹ : TopologicalSpace X\ninst✝ : LE α\nf g : X → α\nh : (nhds x).EventuallyLE f g\n⊢ Filter.Eventually (fun y => (nhds y).EventuallyLE f g) (nhds x)","decl":"/-- If `f x ≤ g x` in a neighbourhood of `x`, then for `y` sufficiently close to `x` we have\n`f x ≤ g x` in a neighbourhood of `y`. -/\ntheorem Filter.EventuallyLE.eventuallyLE_nhds [LE α] {f g : X → α} (h : f ≤ᶠ[𝓝 x] g) :\n    ∀ᶠ y in 𝓝 x, f ≤ᶠ[𝓝 y] g :=\n  h.eventually_nhds\n\n"}
{"name":"all_mem_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\nP : Set X → Prop\nhP : ∀ (s t : Set X), HasSubset.Subset s t → P s → P t\n⊢ Iff (∀ (s : Set X), Membership.mem (nhds x) s → P s) (∀ (s : Set X), IsOpen s → Membership.mem s x → P s)","decl":"theorem all_mem_nhds (x : X) (P : Set X → Prop) (hP : ∀ s t, s ⊆ t → P s → P t) :\n    (∀ s ∈ 𝓝 x, P s) ↔ ∀ s, IsOpen s → x ∈ s → P s :=\n  ((nhds_basis_opens x).forall_iff hP).trans <| by simp only [@and_comm (x ∈ _), and_imp]\n\n"}
{"name":"all_mem_nhds_filter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\nx : X\nf : Set X → Set α\nhf : ∀ (s t : Set X), HasSubset.Subset s t → HasSubset.Subset (f s) (f t)\nl : Filter α\n⊢ Iff (∀ (s : Set X), Membership.mem (nhds x) s → Membership.mem l (f s)) (∀ (s : Set X), IsOpen s → Membership.mem s x → Membership.mem l (f s))","decl":"theorem all_mem_nhds_filter (x : X) (f : Set X → Set α) (hf : ∀ s t, s ⊆ t → f s ⊆ f t)\n    (l : Filter α) : (∀ s ∈ 𝓝 x, f s ∈ l) ↔ ∀ s, IsOpen s → x ∈ s → f s ∈ l :=\n  all_mem_nhds _ _ fun s t ssubt h => mem_of_superset h (hf s t ssubt)\n\n"}
{"name":"tendsto_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ninst✝ : TopologicalSpace X\nf : α → X\nl : Filter α\n⊢ Iff (Filter.Tendsto f l (nhds x)) (∀ (s : Set X), IsOpen s → Membership.mem s x → Membership.mem l (Set.preimage f s))","decl":"theorem tendsto_nhds {f : α → X} {l : Filter α} :\n    Tendsto f l (𝓝 x) ↔ ∀ s, IsOpen s → x ∈ s → f ⁻¹' s ∈ l :=\n  all_mem_nhds_filter _ _ (fun _ _ h => preimage_mono h) _\n\n"}
{"name":"tendsto_atTop_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ninst✝² : TopologicalSpace X\ninst✝¹ : Nonempty α\ninst✝ : SemilatticeSup α\nf : α → X\n⊢ Iff (Filter.Tendsto f Filter.atTop (nhds x)) (∀ (U : Set X), Membership.mem U x → IsOpen U → Exists fun N => ∀ (n : α), LE.le N n → Membership.mem U (f n))","decl":"theorem tendsto_atTop_nhds [Nonempty α] [SemilatticeSup α] {f : α → X} :\n    Tendsto f atTop (𝓝 x) ↔ ∀ U : Set X, x ∈ U → IsOpen U → ∃ N, ∀ n, N ≤ n → f n ∈ U :=\n  (atTop_basis.tendsto_iff (nhds_basis_opens x)).trans <| by\n    simp only [and_imp, exists_prop, true_and, mem_Ici]\n\n"}
{"name":"tendsto_const_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ninst✝ : TopologicalSpace X\nf : Filter α\n⊢ Filter.Tendsto (fun x_1 => x) f (nhds x)","decl":"theorem tendsto_const_nhds {f : Filter α} : Tendsto (fun _ : α => x) f (𝓝 x) :=\n  tendsto_nhds.mpr fun _ _ ha => univ_mem' fun _ => ha\n\n"}
{"name":"tendsto_atTop_of_eventually_const","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝¹ : TopologicalSpace X\nι : Type u_3\ninst✝ : Preorder ι\nu : ι → X\ni₀ : ι\nh : ∀ (i : ι), GE.ge i i₀ → Eq (u i) x\n⊢ Filter.Tendsto u Filter.atTop (nhds x)","decl":"theorem tendsto_atTop_of_eventually_const {ι : Type*} [Preorder ι]\n    {u : ι → X} {i₀ : ι} (h : ∀ i ≥ i₀, u i = x) : Tendsto u atTop (𝓝 x) :=\n  Tendsto.congr' (EventuallyEq.symm ((eventually_ge_atTop i₀).mono h)) tendsto_const_nhds\n\n"}
{"name":"tendsto_atBot_of_eventually_const","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝¹ : TopologicalSpace X\nι : Type u_3\ninst✝ : Preorder ι\nu : ι → X\ni₀ : ι\nh : ∀ (i : ι), LE.le i i₀ → Eq (u i) x\n⊢ Filter.Tendsto u Filter.atBot (nhds x)","decl":"theorem tendsto_atBot_of_eventually_const {ι : Type*} [Preorder ι]\n    {u : ι → X} {i₀ : ι} (h : ∀ i ≤ i₀, u i = x) : Tendsto u atBot (𝓝 x) :=\n  tendsto_atTop_of_eventually_const (ι := ιᵒᵈ) h\n\n"}
{"name":"pure_le_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ LE.le Pure.pure nhds","decl":"theorem pure_le_nhds : pure ≤ (𝓝 : X → Filter X) := fun _ _ hs => mem_pure.2 <| mem_of_mem_nhds hs\n\n"}
{"name":"tendsto_pure_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\nf : α → X\na : α\n⊢ Filter.Tendsto f (Pure.pure a) (nhds (f a))","decl":"theorem tendsto_pure_nhds (f : α → X) (a : α) : Tendsto f (pure a) (𝓝 (f a)) :=\n  (tendsto_pure_pure f a).mono_right (pure_le_nhds _)\n\n"}
{"name":"OrderTop.tendsto_atTop_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\nf : α → X\n⊢ Filter.Tendsto f Filter.atTop (nhds (f Top.top))","decl":"theorem OrderTop.tendsto_atTop_nhds [PartialOrder α] [OrderTop α] (f : α → X) :\n    Tendsto f atTop (𝓝 (f ⊤)) :=\n  (tendsto_atTop_pure f).mono_right (pure_le_nhds _)\n\n"}
{"name":"nhds_neBot","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\n⊢ (nhds x).NeBot","decl":"@[simp]\ninstance nhds_neBot : NeBot (𝓝 x) :=\n  neBot_of_le (pure_le_nhds x)\n\n"}
{"name":"tendsto_nhds_of_eventually_eq","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ninst✝ : TopologicalSpace X\nl : Filter α\nf : α → X\nh : Filter.Eventually (fun x' => Eq (f x') x) l\n⊢ Filter.Tendsto f l (nhds x)","decl":"theorem tendsto_nhds_of_eventually_eq {l : Filter α} {f : α → X} (h : ∀ᶠ x' in l, f x' = x) :\n    Tendsto f l (𝓝 x) :=\n  tendsto_const_nhds.congr' (.symm h)\n\n"}
{"name":"Filter.EventuallyEq.tendsto","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ninst✝ : TopologicalSpace X\nl : Filter α\nf : α → X\nhf : l.EventuallyEq f fun x_1 => x\n⊢ Filter.Tendsto f l (nhds x)","decl":"theorem Filter.EventuallyEq.tendsto {l : Filter α} {f : α → X} (hf : f =ᶠ[l] fun _ ↦ x) :\n    Tendsto f l (𝓝 x) :=\n  tendsto_nhds_of_eventually_eq hf\n\n"}
{"name":"ClusterPt.neBot","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nF : Filter X\nh : ClusterPt x F\n⊢ (Min.min (nhds x) F).NeBot","decl":"theorem ClusterPt.neBot {F : Filter X} (h : ClusterPt x F) : NeBot (𝓝 x ⊓ F) :=\n  h\n\n"}
{"name":"Filter.HasBasis.clusterPt_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nιX : Sort u_3\nιF : Sort u_4\npX : ιX → Prop\nsX : ιX → Set X\npF : ιF → Prop\nsF : ιF → Set X\nF : Filter X\nhX : (nhds x).HasBasis pX sX\nhF : F.HasBasis pF sF\n⊢ Iff (ClusterPt x F) (∀ ⦃i : ιX⦄, pX i → ∀ ⦃j : ιF⦄, pF j → (Inter.inter (sX i) (sF j)).Nonempty)","decl":"theorem Filter.HasBasis.clusterPt_iff {ιX ιF} {pX : ιX → Prop} {sX : ιX → Set X} {pF : ιF → Prop}\n    {sF : ιF → Set X} {F : Filter X} (hX : (𝓝 x).HasBasis pX sX) (hF : F.HasBasis pF sF) :\n    ClusterPt x F ↔ ∀ ⦃i⦄, pX i → ∀ ⦃j⦄, pF j → (sX i ∩ sF j).Nonempty :=\n  hX.inf_basis_neBot_iff hF\n\n"}
{"name":"Filter.HasBasis.clusterPt_iff_frequently","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nι : Sort u_3\np : ι → Prop\ns : ι → Set X\nF : Filter X\nhx : (nhds x).HasBasis p s\n⊢ Iff (ClusterPt x F) (∀ (i : ι), p i → Filter.Frequently (fun x => Membership.mem (s i) x) F)","decl":"theorem Filter.HasBasis.clusterPt_iff_frequently {ι} {p : ι → Prop} {s : ι → Set X} {F : Filter X}\n    (hx : (𝓝 x).HasBasis p s) : ClusterPt x F ↔ ∀ i, p i → ∃ᶠ x in F, x ∈ s i := by\n  simp only [hx.clusterPt_iff F.basis_sets, Filter.frequently_iff, inter_comm (s _),\n    Set.Nonempty, id, mem_inter_iff]\n\n"}
{"name":"clusterPt_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nF : Filter X\n⊢ Iff (ClusterPt x F) (∀ ⦃U : Set X⦄, Membership.mem (nhds x) U → ∀ ⦃V : Set X⦄, Membership.mem F V → (Inter.inter U V).Nonempty)","decl":"theorem clusterPt_iff {F : Filter X} :\n    ClusterPt x F ↔ ∀ ⦃U : Set X⦄, U ∈ 𝓝 x → ∀ ⦃V⦄, V ∈ F → (U ∩ V).Nonempty :=\n  inf_neBot_iff\n\n"}
{"name":"clusterPt_iff_not_disjoint","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nF : Filter X\n⊢ Iff (ClusterPt x F) (Not (Disjoint (nhds x) F))","decl":"theorem clusterPt_iff_not_disjoint {F : Filter X} :\n    ClusterPt x F ↔ ¬Disjoint (𝓝 x) F := by\n  rw [disjoint_iff, ClusterPt, neBot_iff]\n\n"}
{"name":"clusterPt_principal_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (ClusterPt x (Filter.principal s)) (∀ (U : Set X), Membership.mem (nhds x) U → (Inter.inter U s).Nonempty)","decl":"/-- `x` is a cluster point of a set `s` if every neighbourhood of `x` meets `s` on a nonempty\nset. See also `mem_closure_iff_clusterPt`. -/\ntheorem clusterPt_principal_iff :\n    ClusterPt x (𝓟 s) ↔ ∀ U ∈ 𝓝 x, (U ∩ s).Nonempty :=\n  inf_principal_neBot_iff\n\n"}
{"name":"clusterPt_principal_iff_frequently","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (ClusterPt x (Filter.principal s)) (Filter.Frequently (fun y => Membership.mem s y) (nhds x))","decl":"theorem clusterPt_principal_iff_frequently :\n    ClusterPt x (𝓟 s) ↔ ∃ᶠ y in 𝓝 x, y ∈ s := by\n  simp only [clusterPt_principal_iff, frequently_iff, Set.Nonempty, exists_prop, mem_inter_iff]\n\n"}
{"name":"ClusterPt.of_le_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝¹ : TopologicalSpace X\nf : Filter X\nH : LE.le f (nhds x)\ninst✝ : f.NeBot\n⊢ ClusterPt x f","decl":"theorem ClusterPt.of_le_nhds {f : Filter X} (H : f ≤ 𝓝 x) [NeBot f] : ClusterPt x f := by\n  rwa [ClusterPt, inf_eq_right.mpr H]\n\n"}
{"name":"ClusterPt.of_le_nhds'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nf : Filter X\nH : LE.le f (nhds x)\n_hf : f.NeBot\n⊢ ClusterPt x f","decl":"theorem ClusterPt.of_le_nhds' {f : Filter X} (H : f ≤ 𝓝 x) (_hf : NeBot f) :\n    ClusterPt x f :=\n  ClusterPt.of_le_nhds H\n\n"}
{"name":"ClusterPt.of_nhds_le","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nf : Filter X\nH : LE.le (nhds x) f\n⊢ ClusterPt x f","decl":"theorem ClusterPt.of_nhds_le {f : Filter X} (H : 𝓝 x ≤ f) : ClusterPt x f := by\n  simp only [ClusterPt, inf_eq_left.mpr H, nhds_neBot]\n\n"}
{"name":"ClusterPt.mono","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nf g : Filter X\nH : ClusterPt x f\nh : LE.le f g\n⊢ ClusterPt x g","decl":"theorem ClusterPt.mono {f g : Filter X} (H : ClusterPt x f) (h : f ≤ g) : ClusterPt x g :=\n  NeBot.mono H <| inf_le_inf_left _ h\n\n"}
{"name":"ClusterPt.of_inf_left","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nf g : Filter X\nH : ClusterPt x (Min.min f g)\n⊢ ClusterPt x f","decl":"theorem ClusterPt.of_inf_left {f g : Filter X} (H : ClusterPt x <| f ⊓ g) : ClusterPt x f :=\n  H.mono inf_le_left\n\n"}
{"name":"ClusterPt.of_inf_right","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nf g : Filter X\nH : ClusterPt x (Min.min f g)\n⊢ ClusterPt x g","decl":"theorem ClusterPt.of_inf_right {f g : Filter X} (H : ClusterPt x <| f ⊓ g) :\n    ClusterPt x g :=\n  H.mono inf_le_right\n\n"}
{"name":"mapClusterPt_def","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\nF : Filter α\nu : α → X\nx : X\n⊢ Iff (MapClusterPt x F u) (ClusterPt x (Filter.map u F))","decl":"theorem mapClusterPt_def : MapClusterPt x F u ↔ ClusterPt x (map u F) := Iff.rfl\n"}
{"name":"MapClusterPt.clusterPt","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\nF : Filter α\nu : α → X\nx : X\na✝ : MapClusterPt x F u\n⊢ ClusterPt x (Filter.map u F)","decl":"alias ⟨MapClusterPt.clusterPt, _⟩ := mapClusterPt_def\n\n"}
{"name":"MapClusterPt.mono","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\nF : Filter α\nu : α → X\nx : X\nG : Filter α\nh : MapClusterPt x F u\nhle : LE.le F G\n⊢ MapClusterPt x G u","decl":"theorem MapClusterPt.mono {G : Filter α} (h : MapClusterPt x F u) (hle : F ≤ G) :\n    MapClusterPt x G u :=\n  h.clusterPt.mono (map_mono hle)\n\n"}
{"name":"MapClusterPt.tendsto_comp'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nY : Type v\nα : Type u_1\ninst✝¹ : TopologicalSpace X\nF : Filter α\nu : α → X\nx : X\ninst✝ : TopologicalSpace Y\nf : X → Y\ny : Y\nhf : Filter.Tendsto f (Min.min (nhds x) (Filter.map u F)) (nhds y)\nhu : MapClusterPt x F u\n⊢ MapClusterPt y F (Function.comp f u)","decl":"theorem MapClusterPt.tendsto_comp' [TopologicalSpace Y] {f : X → Y} {y : Y}\n    (hf : Tendsto f (𝓝 x ⊓ map u F) (𝓝 y)) (hu : MapClusterPt x F u) : MapClusterPt y F (f ∘ u) :=\n  (tendsto_inf.2 ⟨hf, tendsto_map.mono_left inf_le_right⟩).neBot (hx := hu)\n\n"}
{"name":"MapClusterPt.tendsto_comp","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nY : Type v\nα : Type u_1\ninst✝¹ : TopologicalSpace X\nF : Filter α\nu : α → X\nx : X\ninst✝ : TopologicalSpace Y\nf : X → Y\ny : Y\nhf : Filter.Tendsto f (nhds x) (nhds y)\nhu : MapClusterPt x F u\n⊢ MapClusterPt y F (Function.comp f u)","decl":"theorem MapClusterPt.tendsto_comp [TopologicalSpace Y] {f : X → Y} {y : Y}\n    (hf : Tendsto f (𝓝 x) (𝓝 y)) (hu : MapClusterPt x F u) : MapClusterPt y F (f ∘ u) :=\n  hu.tendsto_comp' (hf.mono_left inf_le_left)\n\n"}
{"name":"MapClusterPt.continuousAt_comp","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nY : Type v\nα : Type u_1\ninst✝¹ : TopologicalSpace X\nF : Filter α\nu : α → X\nx : X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : ContinuousAt f x\nhu : MapClusterPt x F u\n⊢ MapClusterPt (f x) F (Function.comp f u)","decl":"theorem MapClusterPt.continuousAt_comp [TopologicalSpace Y] {f : X → Y} (hf : ContinuousAt f x)\n    (hu : MapClusterPt x F u) : MapClusterPt (f x) F (f ∘ u) :=\n  hu.tendsto_comp hf\n\n"}
{"name":"Filter.HasBasis.mapClusterPt_iff_frequently","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\nF : Filter α\nu : α → X\nx : X\nι : Sort u_3\np : ι → Prop\ns : ι → Set X\nhx : (nhds x).HasBasis p s\n⊢ Iff (MapClusterPt x F u) (∀ (i : ι), p i → Filter.Frequently (fun a => Membership.mem (s i) (u a)) F)","decl":"theorem Filter.HasBasis.mapClusterPt_iff_frequently {ι : Sort*} {p : ι → Prop} {s : ι → Set X}\n    (hx : (𝓝 x).HasBasis p s) : MapClusterPt x F u ↔ ∀ i, p i → ∃ᶠ a in F, u a ∈ s i := by\n  simp_rw [MapClusterPt, hx.clusterPt_iff_frequently, frequently_map]\n\n"}
{"name":"mapClusterPt_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\nF : Filter α\nu : α → X\nx : X\n⊢ Iff (MapClusterPt x F u) (∀ (s : Set X), Membership.mem (nhds x) s → Filter.Frequently (fun a => Membership.mem s (u a)) F)","decl":"theorem mapClusterPt_iff : MapClusterPt x F u ↔ ∀ s ∈ 𝓝 x, ∃ᶠ a in F, u a ∈ s :=\n  (𝓝 x).basis_sets.mapClusterPt_iff_frequently\n\n"}
{"name":"mapClusterPt_comp","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nβ : Type u_2\ninst✝ : TopologicalSpace X\nF : Filter α\nx : X\nφ : α → β\nu : β → X\n⊢ Iff (MapClusterPt x F (Function.comp u φ)) (MapClusterPt x (Filter.map φ F) u)","decl":"theorem mapClusterPt_comp {φ : α → β} {u : β → X} :\n    MapClusterPt x F (u ∘ φ) ↔ MapClusterPt x (map φ F) u := Iff.rfl\n\n"}
{"name":"Filter.Tendsto.mapClusterPt","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝¹ : TopologicalSpace X\nF : Filter α\nu : α → X\nx : X\ninst✝ : F.NeBot\nh : Filter.Tendsto u F (nhds x)\n⊢ MapClusterPt x F u","decl":"theorem Filter.Tendsto.mapClusterPt [NeBot F] (h : Tendsto u F (𝓝 x)) : MapClusterPt x F u :=\n  .of_le_nhds h\n\n"}
{"name":"MapClusterPt.of_comp","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nβ : Type u_2\ninst✝ : TopologicalSpace X\nF : Filter α\nu : α → X\nx : X\nφ : β → α\np : Filter β\nh : Filter.Tendsto φ p F\nH : MapClusterPt x p (Function.comp u φ)\n⊢ MapClusterPt x F u","decl":"theorem MapClusterPt.of_comp {φ : β → α} {p : Filter β} (h : Tendsto φ p F)\n    (H : MapClusterPt x p (u ∘ φ)) : MapClusterPt x F u :=\n  H.clusterPt.mono <| map_mono h\n\n"}
{"name":"mapClusterPt_of_comp","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace X\nF : Filter α\nu : α → X\nx : X\nφ : β → α\np : Filter β\ninst✝ : p.NeBot\nh : Filter.Tendsto φ p F\nH : Filter.Tendsto (Function.comp u φ) p (nhds x)\n⊢ MapClusterPt x F u","decl":"@[deprecated MapClusterPt.of_comp (since := \"2024-09-07\")]\ntheorem mapClusterPt_of_comp {φ : β → α} {p : Filter β} [NeBot p]\n    (h : Tendsto φ p F) (H : Tendsto (u ∘ φ) p (𝓝 x)) : MapClusterPt x F u :=\n  .of_comp h H.mapClusterPt\n\n"}
{"name":"accPt_sup","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\nF G : Filter X\n⊢ Iff (AccPt x (Max.max F G)) (Or (AccPt x F) (AccPt x G))","decl":"theorem accPt_sup (x : X) (F G : Filter X) :\n    AccPt x (F ⊔ G) ↔ AccPt x F ∨ AccPt x G := by\n  simp only [AccPt, inf_sup_left, sup_neBot]\n\n"}
{"name":"acc_iff_cluster","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\nF : Filter X\n⊢ Iff (AccPt x F) (ClusterPt x (Min.min (Filter.principal (HasCompl.compl (Singleton.singleton x))) F))","decl":"theorem acc_iff_cluster (x : X) (F : Filter X) : AccPt x F ↔ ClusterPt x (𝓟 {x}ᶜ ⊓ F) := by\n  rw [AccPt, nhdsWithin, ClusterPt, inf_assoc]\n\n"}
{"name":"acc_principal_iff_cluster","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\nC : Set X\n⊢ Iff (AccPt x (Filter.principal C)) (ClusterPt x (Filter.principal (SDiff.sdiff C (Singleton.singleton x))))","decl":"/-- `x` is an accumulation point of a set `C` iff it is a cluster point of `C ∖ {x}`. -/\ntheorem acc_principal_iff_cluster (x : X) (C : Set X) :\n    AccPt x (𝓟 C) ↔ ClusterPt x (𝓟 (C \\ {x})) := by\n  rw [acc_iff_cluster, inf_principal, inter_comm, diff_eq]\n\n"}
{"name":"accPt_iff_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\nC : Set X\n⊢ Iff (AccPt x (Filter.principal C)) (∀ (U : Set X), Membership.mem (nhds x) U → Exists fun y => And (Membership.mem (Inter.inter U C) y) (Ne y x))","decl":"/-- `x` is an accumulation point of a set `C` iff every neighborhood\nof `x` contains a point of `C` other than `x`. -/\ntheorem accPt_iff_nhds (x : X) (C : Set X) : AccPt x (𝓟 C) ↔ ∀ U ∈ 𝓝 x, ∃ y ∈ U ∩ C, y ≠ x := by\n  simp [acc_principal_iff_cluster, clusterPt_principal_iff, Set.Nonempty, exists_prop, and_assoc,\n    @and_comm (¬_ = x)]\n\n"}
{"name":"accPt_iff_frequently","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\nC : Set X\n⊢ Iff (AccPt x (Filter.principal C)) (Filter.Frequently (fun y => And (Ne y x) (Membership.mem C y)) (nhds x))","decl":"/-- `x` is an accumulation point of a set `C` iff\nthere are points near `x` in `C` and different from `x`. -/\ntheorem accPt_iff_frequently (x : X) (C : Set X) : AccPt x (𝓟 C) ↔ ∃ᶠ y in 𝓝 x, y ≠ x ∧ y ∈ C := by\n  simp [acc_principal_iff_cluster, clusterPt_principal_iff_frequently, and_comm]\n\n"}
{"name":"AccPt.mono","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nF G : Filter X\nh : AccPt x F\nhFG : LE.le F G\n⊢ AccPt x G","decl":"/-- If `x` is an accumulation point of `F` and `F ≤ G`, then\n`x` is an accumulation point of `G`. -/\ntheorem AccPt.mono {F G : Filter X} (h : AccPt x F) (hFG : F ≤ G) : AccPt x G :=\n  NeBot.mono h (inf_le_inf_left _ hFG)\n\n"}
{"name":"AccPt.clusterPt","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\nF : Filter X\nh : AccPt x F\n⊢ ClusterPt x F","decl":"theorem AccPt.clusterPt (x : X) (F : Filter X) (h : AccPt x F) : ClusterPt x F :=\n  ((acc_iff_cluster x F).mp h).mono inf_le_right\n\n"}
{"name":"clusterPt_principal","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\nC : Set X\n⊢ Iff (ClusterPt x (Filter.principal C)) (Or (Membership.mem C x) (AccPt x (Filter.principal C)))","decl":"theorem clusterPt_principal {x : X} {C : Set X} :\n    ClusterPt x (𝓟 C) ↔ x ∈ C ∨ AccPt x (𝓟 C) := by\n  constructor\n  · intro h\n    by_contra! hc\n    rw [acc_principal_iff_cluster] at hc\n    simp_all only [not_false_eq_true, diff_singleton_eq_self, not_true_eq_false, hc.1]\n  · rintro (h | h)\n    · exact clusterPt_principal_iff.mpr fun _ mem ↦ ⟨x, ⟨mem_of_mem_nhds mem, h⟩⟩\n    · exact h.clusterPt\n\n"}
{"name":"interior_eq_nhds'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Eq (interior s) (setOf fun x => Membership.mem (nhds x) s)","decl":"theorem interior_eq_nhds' : interior s = { x | s ∈ 𝓝 x } :=\n  Set.ext fun x => by simp only [mem_interior, mem_nhds_iff, mem_setOf_eq]\n\n"}
{"name":"interior_eq_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Eq (interior s) (setOf fun x => LE.le (nhds x) (Filter.principal s))","decl":"theorem interior_eq_nhds : interior s = { x | 𝓝 x ≤ 𝓟 s } :=\n  interior_eq_nhds'.trans <| by simp only [le_principal_iff]\n\n"}
{"name":"interior_mem_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Membership.mem (nhds x) (interior s)) (Membership.mem (nhds x) s)","decl":"@[simp]\ntheorem interior_mem_nhds : interior s ∈ 𝓝 x ↔ s ∈ 𝓝 x :=\n  ⟨fun h => mem_of_superset h interior_subset, fun h =>\n    IsOpen.mem_nhds isOpen_interior (mem_interior_iff_mem_nhds.2 h)⟩\n\n"}
{"name":"interior_setOf_eq","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : X → Prop\n⊢ Eq (interior (setOf fun x => p x)) (setOf fun x => Filter.Eventually (fun y => p y) (nhds x))","decl":"theorem interior_setOf_eq {p : X → Prop} : interior { x | p x } = { x | ∀ᶠ y in 𝓝 x, p y } :=\n  interior_eq_nhds'\n\n"}
{"name":"isOpen_setOf_eventually_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : X → Prop\n⊢ IsOpen (setOf fun x => Filter.Eventually (fun y => p y) (nhds x))","decl":"theorem isOpen_setOf_eventually_nhds {p : X → Prop} : IsOpen { x | ∀ᶠ y in 𝓝 x, p y } := by\n  simp only [← interior_setOf_eq, isOpen_interior]\n\n"}
{"name":"subset_interior_iff_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\nV : Set X\n⊢ Iff (HasSubset.Subset s (interior V)) (∀ (x : X), Membership.mem s x → Membership.mem (nhds x) V)","decl":"theorem subset_interior_iff_nhds {V : Set X} : s ⊆ interior V ↔ ∀ x ∈ s, V ∈ 𝓝 x := by\n  simp_rw [subset_def, mem_interior_iff_mem_nhds]\n\n"}
{"name":"isOpen_iff_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (IsOpen s) (∀ (x : X), Membership.mem s x → LE.le (nhds x) (Filter.principal s))","decl":"theorem isOpen_iff_nhds : IsOpen s ↔ ∀ x ∈ s, 𝓝 x ≤ 𝓟 s :=\n  calc\n    IsOpen s ↔ s ⊆ interior s := subset_interior_iff_isOpen.symm\n    _ ↔ ∀ x ∈ s, 𝓝 x ≤ 𝓟 s := by simp_rw [interior_eq_nhds, subset_def, mem_setOf]\n\n"}
{"name":"TopologicalSpace.ext_iff_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_3\nt t' : TopologicalSpace X\n⊢ Iff (Eq t t') (∀ (x : X), Eq (nhds x) (nhds x))","decl":"theorem TopologicalSpace.ext_iff_nhds {X} {t t' : TopologicalSpace X} :\n    t = t' ↔ ∀ x, @nhds _ t x = @nhds _ t' x :=\n  ⟨fun H _ ↦ congrFun (congrArg _ H) _, fun H ↦ by ext; simp_rw [@isOpen_iff_nhds _ _ _, H]⟩\n\n"}
{"name":"TopologicalSpace.ext_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_3\nt t' : TopologicalSpace X\na✝ : ∀ (x : X), Eq (nhds x) (nhds x)\n⊢ Eq t t'","decl":"alias ⟨_, TopologicalSpace.ext_nhds⟩ := TopologicalSpace.ext_iff_nhds\n\n"}
{"name":"isOpen_iff_mem_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (IsOpen s) (∀ (x : X), Membership.mem s x → Membership.mem (nhds x) s)","decl":"theorem isOpen_iff_mem_nhds : IsOpen s ↔ ∀ x ∈ s, s ∈ 𝓝 x :=\n  isOpen_iff_nhds.trans <| forall_congr' fun _ => imp_congr_right fun _ => le_principal_iff\n\n"}
{"name":"isOpen_iff_eventually","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (IsOpen s) (∀ (x : X), Membership.mem s x → Filter.Eventually (fun y => Membership.mem s y) (nhds x))","decl":"/-- A set `s` is open iff for every point `x` in `s` and every `y` close to `x`, `y` is in `s`. -/\ntheorem isOpen_iff_eventually : IsOpen s ↔ ∀ x, x ∈ s → ∀ᶠ y in 𝓝 x, y ∈ s :=\n  isOpen_iff_mem_nhds\n\n"}
{"name":"isOpen_singleton_iff_nhds_eq_pure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\n⊢ Iff (IsOpen (Singleton.singleton x)) (Eq (nhds x) (Pure.pure x))","decl":"theorem isOpen_singleton_iff_nhds_eq_pure (x : X) : IsOpen ({x} : Set X) ↔ 𝓝 x = pure x := by\n  constructor\n  · intro h\n    apply le_antisymm _ (pure_le_nhds x)\n    rw [le_pure_iff]\n    exact h.mem_nhds (mem_singleton x)\n  · intro h\n    simp [isOpen_iff_nhds, h]\n\n"}
{"name":"isOpen_singleton_iff_punctured_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\n⊢ Iff (IsOpen (Singleton.singleton x)) (Eq (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) Bot.bot)","decl":"theorem isOpen_singleton_iff_punctured_nhds (x : X) : IsOpen ({x} : Set X) ↔ 𝓝[≠] x = ⊥ := by\n  rw [isOpen_singleton_iff_nhds_eq_pure, nhdsWithin, ← mem_iff_inf_principal_compl,\n      le_antisymm_iff]\n  simp [pure_le_nhds x]\n\n"}
{"name":"mem_closure_iff_frequently","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Membership.mem (closure s) x) (Filter.Frequently (fun x => Membership.mem s x) (nhds x))","decl":"theorem mem_closure_iff_frequently : x ∈ closure s ↔ ∃ᶠ x in 𝓝 x, x ∈ s := by\n  rw [Filter.Frequently, Filter.Eventually, ← mem_interior_iff_mem_nhds,\n    closure_eq_compl_interior_compl, mem_compl_iff, compl_def]\n\n"}
{"name":"Filter.Frequently.mem_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\na✝ : Filter.Frequently (fun x => Membership.mem s x) (nhds x)\n⊢ Membership.mem (closure s) x","decl":"alias ⟨_, Filter.Frequently.mem_closure⟩ := mem_closure_iff_frequently\n\n"}
{"name":"isClosed_iff_frequently","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (IsClosed s) (∀ (x : X), Filter.Frequently (fun y => Membership.mem s y) (nhds x) → Membership.mem s x)","decl":"/-- A set `s` is closed iff for every point `x`, if there is a point `y` close to `x` that belongs\nto `s` then `x` is in `s`. -/\ntheorem isClosed_iff_frequently : IsClosed s ↔ ∀ x, (∃ᶠ y in 𝓝 x, y ∈ s) → x ∈ s := by\n  rw [← closure_subset_iff_isClosed]\n  refine forall_congr' fun x => ?_\n  rw [mem_closure_iff_frequently]\n\n"}
{"name":"isClosed_setOf_clusterPt","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nf : Filter X\n⊢ IsClosed (setOf fun x => ClusterPt x f)","decl":"/-- The set of cluster points of a filter is closed. In particular, the set of limit points\nof a sequence is closed. -/\ntheorem isClosed_setOf_clusterPt {f : Filter X} : IsClosed { x | ClusterPt x f } := by\n  simp only [ClusterPt, inf_neBot_iff_frequently_left, setOf_forall, imp_iff_not_or]\n  refine isClosed_iInter fun p => IsClosed.union ?_ ?_ <;> apply isClosed_compl_iff.2\n  exacts [isOpen_setOf_eventually_nhds, isOpen_const]\n\n"}
{"name":"mem_closure_iff_clusterPt","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Membership.mem (closure s) x) (ClusterPt x (Filter.principal s))","decl":"theorem mem_closure_iff_clusterPt : x ∈ closure s ↔ ClusterPt x (𝓟 s) :=\n  mem_closure_iff_frequently.trans clusterPt_principal_iff_frequently.symm\n\n"}
{"name":"mem_closure_iff_nhds_ne_bot","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Membership.mem (closure s) x) (Ne (Min.min (nhds x) (Filter.principal s)) Bot.bot)","decl":"theorem mem_closure_iff_nhds_ne_bot : x ∈ closure s ↔ 𝓝 x ⊓ 𝓟 s ≠ ⊥ :=\n  mem_closure_iff_clusterPt.trans neBot_iff\n\n"}
{"name":"mem_closure_iff_nhdsWithin_neBot","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Membership.mem (closure s) x) (nhdsWithin x s).NeBot","decl":"theorem mem_closure_iff_nhdsWithin_neBot : x ∈ closure s ↔ NeBot (𝓝[s] x) :=\n  mem_closure_iff_clusterPt\n\n"}
{"name":"nhdsWithin_neBot","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (nhdsWithin x s).NeBot (∀ ⦃t : Set X⦄, Membership.mem (nhds x) t → (Inter.inter t s).Nonempty)","decl":"lemma nhdsWithin_neBot : (𝓝[s] x).NeBot ↔ ∀ ⦃t⦄, t ∈ 𝓝 x → (t ∩ s).Nonempty := by\n  rw [nhdsWithin, inf_neBot_iff]\n  exact forall₂_congr fun U _ ↦\n    ⟨fun h ↦ h (mem_principal_self _), fun h u hsu ↦ h.mono <| inter_subset_inter_right _ hsu⟩\n\n"}
{"name":"nhdsWithin_mono","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\ns t : Set X\nh : HasSubset.Subset s t\n⊢ LE.le (nhdsWithin x s) (nhdsWithin x t)","decl":"@[gcongr]\ntheorem nhdsWithin_mono (x : X) {s t : Set X} (h : s ⊆ t) : 𝓝[s] x ≤ 𝓝[t] x :=\n  inf_le_inf_left _ (principal_mono.mpr h)\n\n"}
{"name":"not_mem_closure_iff_nhdsWithin_eq_bot","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Not (Membership.mem (closure s) x)) (Eq (nhdsWithin x s) Bot.bot)","decl":"lemma not_mem_closure_iff_nhdsWithin_eq_bot : x ∉ closure s ↔ 𝓝[s] x = ⊥ := by\n  rw [mem_closure_iff_nhdsWithin_neBot, not_neBot]\n\n"}
{"name":"dense_compl_singleton","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot\n⊢ Dense (HasCompl.compl (Singleton.singleton x))","decl":"/-- If `x` is not an isolated point of a topological space, then `{x}ᶜ` is dense in the whole\nspace. -/\ntheorem dense_compl_singleton (x : X) [NeBot (𝓝[≠] x)] : Dense ({x}ᶜ : Set X) := by\n  intro y\n  rcases eq_or_ne y x with (rfl | hne)\n  · rwa [mem_closure_iff_nhdsWithin_neBot]\n  · exact subset_closure hne\n\n"}
{"name":"closure_compl_singleton","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot\n⊢ Eq (closure (HasCompl.compl (Singleton.singleton x))) Set.univ","decl":"/-- If `x` is not an isolated point of a topological space, then the closure of `{x}ᶜ` is the whole\nspace. -/\ntheorem closure_compl_singleton (x : X) [NeBot (𝓝[≠] x)] : closure {x}ᶜ = (univ : Set X) :=\n  (dense_compl_singleton x).closure_eq\n\n"}
{"name":"interior_singleton","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot\n⊢ Eq (interior (Singleton.singleton x)) EmptyCollection.emptyCollection","decl":"/-- If `x` is not an isolated point of a topological space, then the interior of `{x}` is empty. -/\n@[simp]\ntheorem interior_singleton (x : X) [NeBot (𝓝[≠] x)] : interior {x} = (∅ : Set X) :=\n  interior_eq_empty_iff_dense_compl.2 (dense_compl_singleton x)\n\n"}
{"name":"not_isOpen_singleton","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot\n⊢ Not (IsOpen (Singleton.singleton x))","decl":"theorem not_isOpen_singleton (x : X) [NeBot (𝓝[≠] x)] : ¬IsOpen ({x} : Set X) :=\n  dense_compl_singleton_iff_not_open.1 (dense_compl_singleton x)\n\n"}
{"name":"closure_eq_cluster_pts","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Eq (closure s) (setOf fun a => ClusterPt a (Filter.principal s))","decl":"theorem closure_eq_cluster_pts : closure s = { a | ClusterPt a (𝓟 s) } :=\n  Set.ext fun _ => mem_closure_iff_clusterPt\n\n"}
{"name":"mem_closure_iff_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Membership.mem (closure s) x) (∀ (t : Set X), Membership.mem (nhds x) t → (Inter.inter t s).Nonempty)","decl":"theorem mem_closure_iff_nhds : x ∈ closure s ↔ ∀ t ∈ 𝓝 x, (t ∩ s).Nonempty :=\n  mem_closure_iff_clusterPt.trans clusterPt_principal_iff\n\n"}
{"name":"mem_closure_iff_nhds'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Membership.mem (closure s) x) (∀ (t : Set X), Membership.mem (nhds x) t → Exists fun y => Membership.mem t ↑y)","decl":"theorem mem_closure_iff_nhds' : x ∈ closure s ↔ ∀ t ∈ 𝓝 x, ∃ y : s, ↑y ∈ t := by\n  simp only [mem_closure_iff_nhds, Set.inter_nonempty_iff_exists_right, SetCoe.exists, exists_prop]\n\n"}
{"name":"mem_closure_iff_comap_neBot","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (Membership.mem (closure s) x) (Filter.comap Subtype.val (nhds x)).NeBot","decl":"theorem mem_closure_iff_comap_neBot :\n    x ∈ closure s ↔ NeBot (comap ((↑) : s → X) (𝓝 x)) := by\n  simp_rw [mem_closure_iff_nhds, comap_neBot_iff, Set.inter_nonempty_iff_exists_right,\n    SetCoe.exists, exists_prop]\n\n"}
{"name":"mem_closure_iff_nhds_basis'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\nx : X\nt : Set X\ninst✝ : TopologicalSpace X\np : ι → Prop\ns : ι → Set X\nh : (nhds x).HasBasis p s\n⊢ Iff (Membership.mem (closure t) x) (∀ (i : ι), p i → (Inter.inter (s i) t).Nonempty)","decl":"theorem mem_closure_iff_nhds_basis' {p : ι → Prop} {s : ι → Set X} (h : (𝓝 x).HasBasis p s) :\n    x ∈ closure t ↔ ∀ i, p i → (s i ∩ t).Nonempty :=\n  mem_closure_iff_clusterPt.trans <|\n    (h.clusterPt_iff (hasBasis_principal _)).trans <| by simp only [exists_prop, forall_const]\n\n"}
{"name":"mem_closure_iff_nhds_basis","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nι : Sort w\nx : X\nt : Set X\ninst✝ : TopologicalSpace X\np : ι → Prop\ns : ι → Set X\nh : (nhds x).HasBasis p s\n⊢ Iff (Membership.mem (closure t) x) (∀ (i : ι), p i → Exists fun y => And (Membership.mem t y) (Membership.mem (s i) y))","decl":"theorem mem_closure_iff_nhds_basis {p : ι → Prop} {s : ι → Set X} (h : (𝓝 x).HasBasis p s) :\n    x ∈ closure t ↔ ∀ i, p i → ∃ y ∈ t, y ∈ s i :=\n  (mem_closure_iff_nhds_basis' h).trans <| by\n    simp only [Set.Nonempty, mem_inter_iff, exists_prop, and_comm]\n\n"}
{"name":"clusterPt_iff_forall_mem_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nF : Filter X\n⊢ Iff (ClusterPt x F) (∀ (s : Set X), Membership.mem F s → Membership.mem (closure s) x)","decl":"theorem clusterPt_iff_forall_mem_closure {F : Filter X} :\n    ClusterPt x F ↔ ∀ s ∈ F, x ∈ closure s := by\n  simp_rw [ClusterPt, inf_neBot_iff, mem_closure_iff_nhds]\n  rw [forall₂_swap]\n\n"}
{"name":"clusterPt_iff_lift'_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nF : Filter X\n⊢ Iff (ClusterPt x F) (LE.le (Pure.pure x) (F.lift' closure))","decl":"theorem clusterPt_iff_lift'_closure {F : Filter X} :\n    ClusterPt x F ↔ pure x ≤ (F.lift' closure) := by\n  simp_rw [clusterPt_iff_forall_mem_closure,\n    (hasBasis_pure _).le_basis_iff F.basis_sets.lift'_closure, id, singleton_subset_iff, true_and,\n    exists_const]\n\n"}
{"name":"clusterPt_iff_lift'_closure'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nF : Filter X\n⊢ Iff (ClusterPt x F) (Min.min (F.lift' closure) (Pure.pure x)).NeBot","decl":"theorem clusterPt_iff_lift'_closure' {F : Filter X} :\n    ClusterPt x F ↔ (F.lift' closure ⊓ pure x).NeBot := by\n  rw [clusterPt_iff_lift'_closure, inf_comm]\n  constructor\n  · intro h\n    simp [h, pure_neBot]\n  · intro h U hU\n    simp_rw [← forall_mem_nonempty_iff_neBot, mem_inf_iff] at h\n    simpa using h ({x} ∩ U) ⟨{x}, by simp, U, hU, rfl⟩\n\n"}
{"name":"clusterPt_lift'_closure_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ninst✝ : TopologicalSpace X\nF : Filter X\n⊢ Iff (ClusterPt x (F.lift' closure)) (ClusterPt x F)","decl":"@[simp]\ntheorem clusterPt_lift'_closure_iff {F : Filter X} :\n    ClusterPt x (F.lift' closure) ↔ ClusterPt x F := by\n  simp [clusterPt_iff_lift'_closure, lift'_lift'_assoc (monotone_closure X) (monotone_closure X)]\n\n"}
{"name":"isClosed_iff_clusterPt","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (IsClosed s) (∀ (a : X), ClusterPt a (Filter.principal s) → Membership.mem s a)","decl":"theorem isClosed_iff_clusterPt : IsClosed s ↔ ∀ a, ClusterPt a (𝓟 s) → a ∈ s :=\n  calc\n    IsClosed s ↔ closure s ⊆ s := closure_subset_iff_isClosed.symm\n    _ ↔ ∀ a, ClusterPt a (𝓟 s) → a ∈ s := by simp only [subset_def, mem_closure_iff_clusterPt]\n\n"}
{"name":"isClosed_iff_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (IsClosed s) (∀ (x : X), (∀ (U : Set X), Membership.mem (nhds x) U → (Inter.inter U s).Nonempty) → Membership.mem s x)","decl":"theorem isClosed_iff_nhds :\n    IsClosed s ↔ ∀ x, (∀ U ∈ 𝓝 x, (U ∩ s).Nonempty) → x ∈ s := by\n  simp_rw [isClosed_iff_clusterPt, ClusterPt, inf_principal_neBot_iff]\n\n"}
{"name":"isClosed_iff_forall_filter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns : Set X\ninst✝ : TopologicalSpace X\n⊢ Iff (IsClosed s) (∀ (x : X) (F : Filter X), F.NeBot → LE.le F (Filter.principal s) → LE.le F (nhds x) → Membership.mem s x)","decl":"lemma isClosed_iff_forall_filter :\n    IsClosed s ↔ ∀ x, ∀ F : Filter X, F.NeBot → F ≤ 𝓟 s → F ≤ 𝓝 x → x ∈ s := by\n  simp_rw [isClosed_iff_clusterPt]\n  exact ⟨fun hs x F F_ne FS Fx ↦ hs _ <| NeBot.mono F_ne (le_inf Fx FS),\n         fun hs x hx ↦ hs x (𝓝 x ⊓ 𝓟 s) hx inf_le_right inf_le_left⟩\n\n"}
{"name":"IsClosed.interior_union_left","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nx✝ : IsClosed s\n⊢ HasSubset.Subset (interior (Union.union s t)) (Union.union s (interior t))","decl":"theorem IsClosed.interior_union_left (_ : IsClosed s) :\n    interior (s ∪ t) ⊆ s ∪ interior t := fun a ⟨u, ⟨⟨hu₁, hu₂⟩, ha⟩⟩ =>\n  (Classical.em (a ∈ s)).imp_right fun h =>\n    mem_interior.mpr\n      ⟨u ∩ sᶜ, fun _x hx => (hu₂ hx.1).resolve_left hx.2, IsOpen.inter hu₁ IsClosed.isOpen_compl,\n        ⟨ha, h⟩⟩\n\n"}
{"name":"IsClosed.interior_union_right","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nh : IsClosed t\n⊢ HasSubset.Subset (interior (Union.union s t)) (Union.union (interior s) t)","decl":"theorem IsClosed.interior_union_right (h : IsClosed t) :\n    interior (s ∪ t) ⊆ interior s ∪ t := by\n  simpa only [union_comm _ t] using h.interior_union_left\n\n"}
{"name":"IsOpen.inter_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nh : IsOpen s\n⊢ HasSubset.Subset (Inter.inter s (closure t)) (closure (Inter.inter s t))","decl":"theorem IsOpen.inter_closure (h : IsOpen s) : s ∩ closure t ⊆ closure (s ∩ t) :=\n  compl_subset_compl.mp <| by\n    simpa only [← interior_compl, compl_inter] using IsClosed.interior_union_left h.isClosed_compl\n\n"}
{"name":"IsOpen.closure_inter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nh : IsOpen t\n⊢ HasSubset.Subset (Inter.inter (closure s) t) (closure (Inter.inter s t))","decl":"theorem IsOpen.closure_inter (h : IsOpen t) : closure s ∩ t ⊆ closure (s ∩ t) := by\n  simpa only [inter_comm t] using h.inter_closure\n\n"}
{"name":"Dense.open_subset_closure_inter","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nhs : Dense s\nht : IsOpen t\n⊢ HasSubset.Subset t (closure (Inter.inter t s))","decl":"theorem Dense.open_subset_closure_inter (hs : Dense s) (ht : IsOpen t) :\n    t ⊆ closure (t ∩ s) :=\n  calc\n    t = t ∩ closure s := by rw [hs.closure_eq, inter_univ]\n    _ ⊆ closure (t ∩ s) := ht.inter_closure\n\n"}
{"name":"mem_closure_of_mem_closure_union","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns₁ s₂ : Set X\ninst✝ : TopologicalSpace X\nh : Membership.mem (closure (Union.union s₁ s₂)) x\nh₁ : Membership.mem (nhds x) (HasCompl.compl s₁)\n⊢ Membership.mem (closure s₂) x","decl":"theorem mem_closure_of_mem_closure_union (h : x ∈ closure (s₁ ∪ s₂))\n    (h₁ : s₁ᶜ ∈ 𝓝 x) : x ∈ closure s₂ := by\n  rw [mem_closure_iff_nhds_ne_bot] at *\n  rwa [← sup_principal, inf_sup_left, inf_principal_eq_bot.mpr h₁, bot_sup_eq] at h\n\n"}
{"name":"Dense.inter_of_isOpen_left","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nhs : Dense s\nht : Dense t\nhso : IsOpen s\n⊢ Dense (Inter.inter s t)","decl":"/-- The intersection of an open dense set with a dense set is a dense set. -/\ntheorem Dense.inter_of_isOpen_left (hs : Dense s) (ht : Dense t) (hso : IsOpen s) :\n    Dense (s ∩ t) := fun x =>\n  closure_minimal hso.inter_closure isClosed_closure <| by simp [hs.closure_eq, ht.closure_eq]\n\n"}
{"name":"Dense.inter_of_isOpen_right","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\nhs : Dense s\nht : Dense t\nhto : IsOpen t\n⊢ Dense (Inter.inter s t)","decl":"/-- The intersection of a dense set with an open dense set is a dense set. -/\ntheorem Dense.inter_of_isOpen_right (hs : Dense s) (ht : Dense t) (hto : IsOpen t) :\n    Dense (s ∩ t) :=\n  inter_comm t s ▸ ht.inter_of_isOpen_left hs hto\n\n"}
{"name":"Dense.inter_nhds_nonempty","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns t : Set X\ninst✝ : TopologicalSpace X\nhs : Dense s\nht : Membership.mem (nhds x) t\n⊢ (Inter.inter s t).Nonempty","decl":"theorem Dense.inter_nhds_nonempty (hs : Dense s) (ht : t ∈ 𝓝 x) :\n    (s ∩ t).Nonempty :=\n  let ⟨U, hsub, ho, hx⟩ := mem_nhds_iff.1 ht\n  (hs.inter_open_nonempty U ho ⟨x, hx⟩).mono fun _y hy => ⟨hy.2, hsub hy.1⟩\n\n"}
{"name":"closure_diff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ns t : Set X\ninst✝ : TopologicalSpace X\n⊢ HasSubset.Subset (SDiff.sdiff (closure s) (closure t)) (closure (SDiff.sdiff s t))","decl":"theorem closure_diff : closure s \\ closure t ⊆ closure (s \\ t) :=\n  calc\n    closure s \\ closure t = (closure t)ᶜ ∩ closure s := by simp only [diff_eq, inter_comm]\n    _ ⊆ closure ((closure t)ᶜ ∩ s) := (isOpen_compl_iff.mpr <| isClosed_closure).inter_closure\n    _ = closure (s \\ closure t) := by simp only [diff_eq, inter_comm]\n    _ ⊆ closure (s \\ t) := closure_mono <| diff_subset_diff (Subset.refl s) subset_closure\n\n"}
{"name":"Filter.Frequently.mem_of_closed","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\nh : Filter.Frequently (fun x => Membership.mem s x) (nhds x)\nhs : IsClosed s\n⊢ Membership.mem s x","decl":"theorem Filter.Frequently.mem_of_closed (h : ∃ᶠ x in 𝓝 x, x ∈ s)\n    (hs : IsClosed s) : x ∈ s :=\n  hs.closure_subset h.mem_closure\n\n"}
{"name":"IsClosed.mem_of_frequently_of_tendsto","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\nf : α → X\nb : Filter α\nhs : IsClosed s\nh : Filter.Frequently (fun x => Membership.mem s (f x)) b\nhf : Filter.Tendsto f b (nhds x)\n⊢ Membership.mem s x","decl":"theorem IsClosed.mem_of_frequently_of_tendsto {f : α → X} {b : Filter α}\n    (hs : IsClosed s) (h : ∃ᶠ x in b, f x ∈ s) (hf : Tendsto f b (𝓝 x)) : x ∈ s :=\n  (hf.frequently <| show ∃ᶠ x in b, (fun y => y ∈ s) (f x) from h).mem_of_closed hs\n\n"}
{"name":"IsClosed.mem_of_tendsto","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ns : Set X\ninst✝¹ : TopologicalSpace X\nf : α → X\nb : Filter α\ninst✝ : b.NeBot\nhs : IsClosed s\nhf : Filter.Tendsto f b (nhds x)\nh : Filter.Eventually (fun x => Membership.mem s (f x)) b\n⊢ Membership.mem s x","decl":"theorem IsClosed.mem_of_tendsto {f : α → X} {b : Filter α} [NeBot b]\n    (hs : IsClosed s) (hf : Tendsto f b (𝓝 x)) (h : ∀ᶠ x in b, f x ∈ s) : x ∈ s :=\n  hs.mem_of_frequently_of_tendsto h.frequently hf\n\n"}
{"name":"mem_closure_of_frequently_of_tendsto","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ns : Set X\ninst✝ : TopologicalSpace X\nf : α → X\nb : Filter α\nh : Filter.Frequently (fun x => Membership.mem s (f x)) b\nhf : Filter.Tendsto f b (nhds x)\n⊢ Membership.mem (closure s) x","decl":"theorem mem_closure_of_frequently_of_tendsto {f : α → X} {b : Filter α}\n    (h : ∃ᶠ x in b, f x ∈ s) (hf : Tendsto f b (𝓝 x)) : x ∈ closure s :=\n  (hf.frequently h).mem_closure\n\n"}
{"name":"mem_closure_of_tendsto","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ns : Set X\ninst✝¹ : TopologicalSpace X\nf : α → X\nb : Filter α\ninst✝ : b.NeBot\nhf : Filter.Tendsto f b (nhds x)\nh : Filter.Eventually (fun x => Membership.mem s (f x)) b\n⊢ Membership.mem (closure s) x","decl":"theorem mem_closure_of_tendsto {f : α → X} {b : Filter α} [NeBot b]\n    (hf : Tendsto f b (𝓝 x)) (h : ∀ᶠ x in b, f x ∈ s) : x ∈ closure s :=\n  mem_closure_of_frequently_of_tendsto h.frequently hf\n\n"}
{"name":"tendsto_inf_principal_nhds_iff_of_forall_eq","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\nx : X\ninst✝ : TopologicalSpace X\nf : α → X\nl : Filter α\ns : Set α\nh : ∀ (a : α), Not (Membership.mem s a) → Eq (f a) x\n⊢ Iff (Filter.Tendsto f (Min.min l (Filter.principal s)) (nhds x)) (Filter.Tendsto f l (nhds x))","decl":"/-- Suppose that `f` sends the complement to `s` to a single point `x`, and `l` is some filter.\nThen `f` tends to `x` along `l` restricted to `s` if and only if it tends to `x` along `l`. -/\ntheorem tendsto_inf_principal_nhds_iff_of_forall_eq {f : α → X} {l : Filter α} {s : Set α}\n    (h : ∀ a ∉ s, f a = x) : Tendsto f (l ⊓ 𝓟 s) (𝓝 x) ↔ Tendsto f l (𝓝 x) := by\n  rw [tendsto_iff_comap, tendsto_iff_comap]\n  replace h : 𝓟 sᶜ ≤ comap f (𝓝 x) := by\n    rintro U ⟨t, ht, htU⟩ x hx\n    have : f x ∈ t := (h x hx).symm ▸ mem_of_mem_nhds ht\n    exact htU this\n  refine ⟨fun h' => ?_, le_trans inf_le_left⟩\n  have := sup_le h' h\n  rw [sup_inf_right, sup_principal, union_compl_self, principal_univ, inf_top_eq, sup_le_iff]\n    at this\n  exact this.1\n\n"}
{"name":"le_nhds_lim","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nf : Filter X\nh : Exists fun x => LE.le f (nhds x)\n⊢ LE.le f (nhds (lim f))","decl":"/-- If a filter `f` is majorated by some `𝓝 x`, then it is majorated by `𝓝 (Filter.lim f)`. We\nformulate this lemma with a `[Nonempty X]` argument of `lim` derived from `h` to make it useful for\ntypes without a `[Nonempty X]` instance. Because of the built-in proof irrelevance, Lean will unify\nthis instance with any other instance. -/\ntheorem le_nhds_lim {f : Filter X} (h : ∃ x, f ≤ 𝓝 x) : f ≤ 𝓝 (@lim _ _ (nonempty_of_exists h) f) :=\n  Classical.epsilon_spec h\n\n"}
{"name":"tendsto_nhds_limUnder","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u\nα : Type u_1\ninst✝ : TopologicalSpace X\nf : Filter α\ng : α → X\nh : Exists fun x => Filter.Tendsto g f (nhds x)\n⊢ Filter.Tendsto g f (nhds (limUnder f g))","decl":"/-- If `g` tends to some `𝓝 x` along `f`, then it tends to `𝓝 (Filter.limUnder f g)`. We formulate\nthis lemma with a `[Nonempty X]` argument of `lim` derived from `h` to make it useful for types\nwithout a `[Nonempty X]` instance. Because of the built-in proof irrelevance, Lean will unify this\ninstance with any other instance. -/\ntheorem tendsto_nhds_limUnder {f : Filter α} {g : α → X} (h : ∃ x, Tendsto g f (𝓝 x)) :\n    Tendsto g f (𝓝 (@limUnder _ _ _ (nonempty_of_exists h) f g)) :=\n  le_nhds_lim h\n\n"}
{"name":"continuous_def","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nx✝¹ : TopologicalSpace X\nx✝ : TopologicalSpace Y\nf : X → Y\n⊢ Iff (Continuous f) (∀ (s : Set Y), IsOpen s → IsOpen (Set.preimage f s))","decl":"theorem continuous_def {_ : TopologicalSpace X} {_ : TopologicalSpace Y} {f : X → Y} :\n    Continuous f ↔ ∀ s, IsOpen s → IsOpen (f ⁻¹' s) :=\n  ⟨fun hf => hf.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"IsOpen.preimage","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\nt : Set Y\nh : IsOpen t\n⊢ IsOpen (Set.preimage f t)","decl":"theorem IsOpen.preimage (hf : Continuous f) {t : Set Y} (h : IsOpen t) :\n    IsOpen (f ⁻¹' t) :=\n  hf.isOpen_preimage t h\n\n"}
{"name":"Equiv.continuous_symm_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ne : Equiv X Y\n⊢ Iff (Continuous ⇑e.symm) (IsOpenMap ⇑e)","decl":"lemma Equiv.continuous_symm_iff (e : X ≃ Y) : Continuous e.symm ↔ IsOpenMap e := by\n  simp_rw [continuous_def, ← Set.image_equiv_eq_preimage_symm, IsOpenMap]\n\n"}
{"name":"Equiv.isOpenMap_symm_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ne : Equiv X Y\n⊢ Iff (IsOpenMap ⇑e.symm) (Continuous ⇑e)","decl":"lemma Equiv.isOpenMap_symm_iff (e : X ≃ Y) : IsOpenMap e.symm ↔ Continuous e := by\n  simp_rw [← Equiv.continuous_symm_iff, Equiv.symm_symm]\n\n"}
{"name":"continuous_congr","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf g : X → Y\nh : ∀ (x : X), Eq (f x) (g x)\n⊢ Iff (Continuous f) (Continuous g)","decl":"theorem continuous_congr {g : X → Y} (h : ∀ x, f x = g x) :\n    Continuous f ↔ Continuous g :=\n  .of_eq <| congrArg _ <| funext h\n\n"}
{"name":"Continuous.congr","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf g : X → Y\nh : Continuous f\nh' : ∀ (x : X), Eq (f x) (g x)\n⊢ Continuous g","decl":"theorem Continuous.congr {g : X → Y} (h : Continuous f) (h' : ∀ x, f x = g x) : Continuous g :=\n  continuous_congr h' |>.mp h\n\n"}
{"name":"ContinuousAt.tendsto","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nx : X\nh : ContinuousAt f x\n⊢ Filter.Tendsto f (nhds x) (nhds (f x))","decl":"theorem ContinuousAt.tendsto (h : ContinuousAt f x) :\n    Tendsto f (𝓝 x) (𝓝 (f x)) :=\n  h\n\n"}
{"name":"continuousAt_def","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nx : X\n⊢ Iff (ContinuousAt f x) (∀ (A : Set Y), Membership.mem (nhds (f x)) A → Membership.mem (nhds x) (Set.preimage f A))","decl":"theorem continuousAt_def : ContinuousAt f x ↔ ∀ A ∈ 𝓝 (f x), f ⁻¹' A ∈ 𝓝 x :=\n  Iff.rfl\n\n"}
{"name":"continuousAt_congr","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nx : X\ng : X → Y\nh : (nhds x).EventuallyEq f g\n⊢ Iff (ContinuousAt f x) (ContinuousAt g x)","decl":"theorem continuousAt_congr {g : X → Y} (h : f =ᶠ[𝓝 x] g) :\n    ContinuousAt f x ↔ ContinuousAt g x := by\n  simp only [ContinuousAt, tendsto_congr' h, h.eq_of_nhds]\n\n"}
{"name":"ContinuousAt.congr","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nx : X\ng : X → Y\nhf : ContinuousAt f x\nh : (nhds x).EventuallyEq f g\n⊢ ContinuousAt g x","decl":"theorem ContinuousAt.congr {g : X → Y} (hf : ContinuousAt f x) (h : f =ᶠ[𝓝 x] g) :\n    ContinuousAt g x :=\n  (continuousAt_congr h).1 hf\n\n"}
{"name":"ContinuousAt.preimage_mem_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nx : X\nt : Set Y\nh : ContinuousAt f x\nht : Membership.mem (nhds (f x)) t\n⊢ Membership.mem (nhds x) (Set.preimage f t)","decl":"theorem ContinuousAt.preimage_mem_nhds {t : Set Y} (h : ContinuousAt f x)\n    (ht : t ∈ 𝓝 (f x)) : f ⁻¹' t ∈ 𝓝 x :=\n  h ht\n\n"}
{"name":"ContinuousAt.eventually_mem","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nx : X\nhf : ContinuousAt f x\ns : Set Y\nhs : Membership.mem (nhds (f x)) s\n⊢ Filter.Eventually (fun y => Membership.mem s (f y)) (nhds x)","decl":"/-- If `f x ∈ s ∈ 𝓝 (f x)` for continuous `f`, then `f y ∈ s` near `x`.\n\nThis is essentially `Filter.Tendsto.eventually_mem`, but infers in more cases when applied. -/\ntheorem ContinuousAt.eventually_mem {f : X → Y} {x : X} (hf : ContinuousAt f x) {s : Set Y}\n    (hs : s ∈ 𝓝 (f x)) : ∀ᶠ y in 𝓝 x, f y ∈ s :=\n  hf hs\n\n"}
{"name":"not_continuousAt_of_tendsto","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\nf : X → Y\nl₁ : Filter X\nl₂ : Filter Y\nx : X\nhf : Filter.Tendsto f l₁ l₂\ninst✝ : l₁.NeBot\nhl₁ : LE.le l₁ (nhds x)\nhl₂ : Disjoint (nhds (f x)) l₂\n⊢ Not (ContinuousAt f x)","decl":"/-- If a function `f` tends to somewhere other than `𝓝 (f x)` at `x`,\nthen `f` is not continuous at `x`\n-/\nlemma not_continuousAt_of_tendsto {f : X → Y} {l₁ : Filter X} {l₂ : Filter Y} {x : X}\n    (hf : Tendsto f l₁ l₂) [l₁.NeBot] (hl₁ : l₁ ≤ 𝓝 x) (hl₂ : Disjoint (𝓝 (f x)) l₂) :\n    ¬ ContinuousAt f x := fun cont ↦\n  (cont.mono_left hl₁).not_tendsto hl₂ hf\n\n"}
{"name":"ClusterPt.map","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nx : X\nlx : Filter X\nly : Filter Y\nH : ClusterPt x lx\nhfc : ContinuousAt f x\nhf : Filter.Tendsto f lx ly\n⊢ ClusterPt (f x) ly","decl":"theorem ClusterPt.map {lx : Filter X} {ly : Filter Y} (H : ClusterPt x lx)\n    (hfc : ContinuousAt f x) (hf : Tendsto f lx ly) : ClusterPt (f x) ly :=\n  (NeBot.map H f).mono <| hfc.tendsto.inf hf\n\n"}
{"name":"preimage_interior_subset_interior_preimage","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nt : Set Y\nhf : Continuous f\n⊢ HasSubset.Subset (Set.preimage f (interior t)) (interior (Set.preimage f t))","decl":"/-- See also `interior_preimage_subset_preimage_interior`. -/\ntheorem preimage_interior_subset_interior_preimage {t : Set Y} (hf : Continuous f) :\n    f ⁻¹' interior t ⊆ interior (f ⁻¹' t) :=\n  interior_maximal (preimage_mono interior_subset) (isOpen_interior.preimage hf)\n\n"}
{"name":"continuous_id","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Continuous id","decl":"@[continuity]\ntheorem continuous_id : Continuous (id : X → X) :=\n  continuous_def.2 fun _ => id\n\n-- This is needed due to reducibility issues with the `continuity` tactic.\n"}
{"name":"continuous_id'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Continuous fun x => x","decl":"@[continuity, fun_prop]\ntheorem continuous_id' : Continuous (fun (x : X) => x) := continuous_id\n\n"}
{"name":"Continuous.comp","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y\ng : Y → Z\nhg : Continuous g\nhf : Continuous f\n⊢ Continuous (Function.comp g f)","decl":"theorem Continuous.comp {g : Y → Z} (hg : Continuous g) (hf : Continuous f) :\n    Continuous (g ∘ f) :=\n  continuous_def.2 fun _ h => (h.preimage hg).preimage hf\n\n-- This is needed due to reducibility issues with the `continuity` tactic.\n"}
{"name":"Continuous.comp'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y\ng : Y → Z\nhg : Continuous g\nhf : Continuous f\n⊢ Continuous fun x => g (f x)","decl":"@[continuity, fun_prop]\ntheorem Continuous.comp' {g : Y → Z} (hg : Continuous g) (hf : Continuous f) :\n    Continuous (fun x => g (f x)) := hg.comp hf\n\n"}
{"name":"Continuous.iterate","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nf : X → X\nh : Continuous f\nn : Nat\n⊢ Continuous (Nat.iterate f n)","decl":"theorem Continuous.iterate {f : X → X} (h : Continuous f) (n : ℕ) : Continuous f^[n] :=\n  Nat.recOn n continuous_id fun _ ihn => ihn.comp h\n\n"}
{"name":"ContinuousAt.comp","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y\nx : X\ng : Y → Z\nhg : ContinuousAt g (f x)\nhf : ContinuousAt f x\n⊢ ContinuousAt (Function.comp g f) x","decl":"nonrec theorem ContinuousAt.comp {g : Y → Z} (hg : ContinuousAt g (f x))\n    (hf : ContinuousAt f x) : ContinuousAt (g ∘ f) x :=\n  hg.comp hf\n\n"}
{"name":"ContinuousAt.comp'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y\ng : Y → Z\nx : X\nhg : ContinuousAt g (f x)\nhf : ContinuousAt f x\n⊢ ContinuousAt (fun x => g (f x)) x","decl":"@[fun_prop]\ntheorem ContinuousAt.comp' {g : Y → Z} {x : X} (hg : ContinuousAt g (f x))\n    (hf : ContinuousAt f x) : ContinuousAt (fun x => g (f x)) x := ContinuousAt.comp hg hf\n\n"}
{"name":"ContinuousAt.comp_of_eq","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y\nx : X\ny : Y\ng : Y → Z\nhg : ContinuousAt g y\nhf : ContinuousAt f x\nhy : Eq (f x) y\n⊢ ContinuousAt (Function.comp g f) x","decl":"/-- See note [comp_of_eq lemmas] -/\ntheorem ContinuousAt.comp_of_eq {g : Y → Z} (hg : ContinuousAt g y)\n    (hf : ContinuousAt f x) (hy : f x = y) : ContinuousAt (g ∘ f) x := by subst hy; exact hg.comp hf\n\n"}
{"name":"Continuous.tendsto","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\nx : X\n⊢ Filter.Tendsto f (nhds x) (nhds (f x))","decl":"theorem Continuous.tendsto (hf : Continuous f) (x) : Tendsto f (𝓝 x) (𝓝 (f x)) :=\n  ((nhds_basis_opens x).tendsto_iff <| nhds_basis_opens <| f x).2 fun t ⟨hxt, ht⟩ =>\n    ⟨f ⁻¹' t, ⟨hxt, ht.preimage hf⟩, Subset.rfl⟩\n\n"}
{"name":"Continuous.tendsto'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\nx : X\ny : Y\nh : Eq (f x) y\n⊢ Filter.Tendsto f (nhds x) (nhds y)","decl":"/-- A version of `Continuous.tendsto` that allows one to specify a simpler form of the limit.\nE.g., one can write `continuous_exp.tendsto' 0 1 exp_zero`. -/\ntheorem Continuous.tendsto' (hf : Continuous f) (x : X) (y : Y) (h : f x = y) :\n    Tendsto f (𝓝 x) (𝓝 y) :=\n  h ▸ hf.tendsto x\n\n"}
{"name":"Continuous.continuousAt","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nx : X\nh : Continuous f\n⊢ ContinuousAt f x","decl":"@[fun_prop]\ntheorem Continuous.continuousAt (h : Continuous f) : ContinuousAt f x :=\n  h.tendsto x\n\n"}
{"name":"continuous_iff_continuousAt","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\n⊢ Iff (Continuous f) (∀ (x : X), ContinuousAt f x)","decl":"theorem continuous_iff_continuousAt : Continuous f ↔ ∀ x, ContinuousAt f x :=\n  ⟨Continuous.tendsto, fun hf => continuous_def.2 fun _U hU => isOpen_iff_mem_nhds.2 fun x hx =>\n    hf x <| hU.mem_nhds hx⟩\n\n"}
{"name":"continuousAt_const","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\ny : Y\n⊢ ContinuousAt (fun x => y) x","decl":"@[fun_prop]\ntheorem continuousAt_const : ContinuousAt (fun _ : X => y) x :=\n  tendsto_const_nhds\n\n"}
{"name":"continuous_const","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ny : Y\n⊢ Continuous fun x => y","decl":"@[continuity, fun_prop]\ntheorem continuous_const : Continuous fun _ : X => y :=\n  continuous_iff_continuousAt.mpr fun _ => continuousAt_const\n\n"}
{"name":"Filter.EventuallyEq.continuousAt","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nx : X\ny : Y\nh : (nhds x).EventuallyEq f fun x => y\n⊢ ContinuousAt f x","decl":"theorem Filter.EventuallyEq.continuousAt (h : f =ᶠ[𝓝 x] fun _ => y) :\n    ContinuousAt f x :=\n  (continuousAt_congr h).2 tendsto_const_nhds\n\n"}
{"name":"continuous_of_const","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nh : ∀ (x y : X), Eq (f x) (f y)\n⊢ Continuous f","decl":"theorem continuous_of_const (h : ∀ x y, f x = f y) : Continuous f :=\n  continuous_iff_continuousAt.mpr fun x =>\n    Filter.EventuallyEq.continuousAt <| Eventually.of_forall fun y => h y x\n\n"}
{"name":"continuousAt_id","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\n⊢ ContinuousAt id x","decl":"theorem continuousAt_id : ContinuousAt id x :=\n  continuous_id.continuousAt\n\n"}
{"name":"continuousAt_id'","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ny : X\n⊢ ContinuousAt (fun x => x) y","decl":"@[fun_prop]\ntheorem continuousAt_id' (y) : ContinuousAt (fun x : X => x) y := continuousAt_id\n\n"}
{"name":"ContinuousAt.iterate","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\nf : X → X\nhf : ContinuousAt f x\nhx : Eq (f x) x\nn : Nat\n⊢ ContinuousAt (Nat.iterate f n) x","decl":"theorem ContinuousAt.iterate {f : X → X} (hf : ContinuousAt f x) (hx : f x = x) (n : ℕ) :\n    ContinuousAt f^[n] x :=\n  Nat.recOn n continuousAt_id fun _n ihn ↦ ihn.comp_of_eq hf hx\n\n"}
{"name":"continuous_iff_isClosed","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\n⊢ Iff (Continuous f) (∀ (s : Set Y), IsClosed s → IsClosed (Set.preimage f s))","decl":"theorem continuous_iff_isClosed : Continuous f ↔ ∀ s, IsClosed s → IsClosed (f ⁻¹' s) :=\n  continuous_def.trans <| compl_surjective.forall.trans <| by\n    simp only [isOpen_compl_iff, preimage_compl]\n\n"}
{"name":"IsClosed.preimage","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\nt : Set Y\nh : IsClosed t\n⊢ IsClosed (Set.preimage f t)","decl":"theorem IsClosed.preimage (hf : Continuous f) {t : Set Y} (h : IsClosed t) :\n    IsClosed (f ⁻¹' t) :=\n  continuous_iff_isClosed.mp hf t h\n\n"}
{"name":"mem_closure_image","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nx : X\nhf : ContinuousAt f x\nhx : Membership.mem (closure s) x\n⊢ Membership.mem (closure (Set.image f s)) (f x)","decl":"theorem mem_closure_image (hf : ContinuousAt f x)\n    (hx : x ∈ closure s) : f x ∈ closure (f '' s) :=\n  mem_closure_of_frequently_of_tendsto\n    ((mem_closure_iff_frequently.1 hx).mono fun _ => mem_image_of_mem _) hf\n\n"}
{"name":"Continuous.closure_preimage_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\nt : Set Y\n⊢ HasSubset.Subset (closure (Set.preimage f t)) (Set.preimage f (closure t))","decl":"theorem Continuous.closure_preimage_subset (hf : Continuous f) (t : Set Y) :\n    closure (f ⁻¹' t) ⊆ f ⁻¹' closure t := by\n  rw [← (isClosed_closure.preimage hf).closure_eq]\n  exact closure_mono (preimage_mono subset_closure)\n\n"}
{"name":"Continuous.frontier_preimage_subset","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\nt : Set Y\n⊢ HasSubset.Subset (frontier (Set.preimage f t)) (Set.preimage f (frontier t))","decl":"theorem Continuous.frontier_preimage_subset (hf : Continuous f) (t : Set Y) :\n    frontier (f ⁻¹' t) ⊆ f ⁻¹' frontier t :=\n  diff_subset_diff (hf.closure_preimage_subset t) (preimage_interior_subset_interior_preimage hf)\n\n"}
{"name":"Set.MapsTo.closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nt : Set Y\nh : Set.MapsTo f s t\nhc : Continuous f\n⊢ Set.MapsTo f (closure s) (closure t)","decl":"/-- If a continuous map `f` maps `s` to `t`, then it maps `closure s` to `closure t`. -/\nprotected theorem Set.MapsTo.closure {t : Set Y} (h : MapsTo f s t)\n    (hc : Continuous f) : MapsTo f (closure s) (closure t) := by\n  simp only [MapsTo, mem_closure_iff_clusterPt]\n  exact fun x hx => hx.map hc.continuousAt (tendsto_principal_principal.2 h)\n\n"}
{"name":"image_closure_subset_closure_image","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nh : Continuous f\n⊢ HasSubset.Subset (Set.image f (closure s)) (closure (Set.image f s))","decl":"/-- See also `IsClosedMap.closure_image_eq_of_continuous`. -/\ntheorem image_closure_subset_closure_image (h : Continuous f) :\n    f '' closure s ⊆ closure (f '' s) :=\n  ((mapsTo_image f s).closure h).image_subset\n\n"}
{"name":"closure_image_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nh : Continuous f\n⊢ Eq (closure (Set.image f (closure s))) (closure (Set.image f s))","decl":"theorem closure_image_closure (h : Continuous f) :\n    closure (f '' closure s) = closure (f '' s) :=\n  Subset.antisymm\n    (closure_minimal (image_closure_subset_closure_image h) isClosed_closure)\n    (closure_mono <| image_subset _ subset_closure)\n\n"}
{"name":"closure_subset_preimage_closure_image","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nh : Continuous f\n⊢ HasSubset.Subset (closure s) (Set.preimage f (closure (Set.image f s)))","decl":"theorem closure_subset_preimage_closure_image (h : Continuous f) :\n    closure s ⊆ f ⁻¹' closure (f '' s) :=\n  (mapsTo_image _ _).closure h\n\n"}
{"name":"map_mem_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nx : X\nt : Set Y\nhf : Continuous f\nhx : Membership.mem (closure s) x\nht : Set.MapsTo f s t\n⊢ Membership.mem (closure t) (f x)","decl":"theorem map_mem_closure {t : Set Y} (hf : Continuous f)\n    (hx : x ∈ closure s) (ht : MapsTo f s t) : f x ∈ closure t :=\n  ht.closure hf hx\n\n"}
{"name":"Set.MapsTo.closure_left","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nt : Set Y\nh : Set.MapsTo f s t\nhc : Continuous f\nht : IsClosed t\n⊢ Set.MapsTo f (closure s) t","decl":"/-- If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. -/\ntheorem Set.MapsTo.closure_left {t : Set Y} (h : MapsTo f s t)\n    (hc : Continuous f) (ht : IsClosed t) : MapsTo f (closure s) t :=\n  ht.closure_eq ▸ h.closure hc\n\n"}
{"name":"Filter.Tendsto.lift'_closure","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\nl : Filter X\nl' : Filter Y\nh : Filter.Tendsto f l l'\n⊢ Filter.Tendsto f (l.lift' closure) (l'.lift' closure)","decl":"theorem Filter.Tendsto.lift'_closure (hf : Continuous f) {l l'} (h : Tendsto f l l') :\n    Tendsto f (l.lift' closure) (l'.lift' closure) :=\n  tendsto_lift'.2 fun s hs ↦ by\n    filter_upwards [mem_lift' (h hs)] using (mapsTo_preimage _ _).closure hf\n\n"}
{"name":"tendsto_lift'_closure_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\nx : X\n⊢ Filter.Tendsto f ((nhds x).lift' closure) ((nhds (f x)).lift' closure)","decl":"theorem tendsto_lift'_closure_nhds (hf : Continuous f) (x : X) :\n    Tendsto f ((𝓝 x).lift' closure) ((𝓝 (f x)).lift' closure) :=\n  (hf.tendsto x).lift'_closure hf\n\n"}
{"name":"Function.Surjective.denseRange","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nα : Type u_4\nf : α → X\nhf : Function.Surjective f\n⊢ DenseRange f","decl":"/-- A surjective map has dense range. -/\ntheorem Function.Surjective.denseRange (hf : Function.Surjective f) : DenseRange f := fun x => by\n  simp [hf.range_eq]\n\n"}
{"name":"denseRange_id","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ DenseRange id","decl":"theorem denseRange_id : DenseRange (id : X → X) :=\n  Function.Surjective.denseRange Function.surjective_id\n\n"}
{"name":"denseRange_iff_closure_range","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nα : Type u_4\nf : α → X\n⊢ Iff (DenseRange f) (Eq (closure (Set.range f)) Set.univ)","decl":"theorem denseRange_iff_closure_range : DenseRange f ↔ closure (range f) = univ :=\n  dense_iff_closure_eq\n\n"}
{"name":"DenseRange.closure_range","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nα : Type u_4\nf : α → X\nh : DenseRange f\n⊢ Eq (closure (Set.range f)) Set.univ","decl":"theorem DenseRange.closure_range (h : DenseRange f) : closure (range f) = univ :=\n  h.closure_eq\n\n"}
{"name":"denseRange_subtype_val","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\np : X → Prop\n⊢ Iff (DenseRange Subtype.val) (Dense (setOf fun x => p x))","decl":"@[simp]\nlemma denseRange_subtype_val {p : X → Prop} : DenseRange (@Subtype.val _ p) ↔ Dense {x | p x} := by\n  simp [DenseRange]\n\n"}
{"name":"Dense.denseRange_val","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nh : Dense s\n⊢ DenseRange Subtype.val","decl":"theorem Dense.denseRange_val (h : Dense s) : DenseRange ((↑) : s → X) :=\n  denseRange_subtype_val.2 h\n\n"}
{"name":"Continuous.range_subset_closure_image_dense","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf : Continuous f\nhs : Dense s\n⊢ HasSubset.Subset (Set.range f) (closure (Set.image f s))","decl":"theorem Continuous.range_subset_closure_image_dense {f : X → Y} (hf : Continuous f)\n    (hs : Dense s) : range f ⊆ closure (f '' s) := by\n  rw [← image_univ, ← hs.closure_eq]\n  exact image_closure_subset_closure_image hf\n\n"}
{"name":"DenseRange.dense_image","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf' : DenseRange f\nhf : Continuous f\nhs : Dense s\n⊢ Dense (Set.image f s)","decl":"/-- The image of a dense set under a continuous map with dense range is a dense set. -/\ntheorem DenseRange.dense_image {f : X → Y} (hf' : DenseRange f) (hf : Continuous f)\n    (hs : Dense s) : Dense (f '' s) :=\n  (hf'.mono <| hf.range_subset_closure_image_dense hs).of_closure\n\n"}
{"name":"DenseRange.subset_closure_image_preimage_of_isOpen","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nα : Type u_4\nf : α → X\ns : Set X\nhf : DenseRange f\nhs : IsOpen s\n⊢ HasSubset.Subset s (closure (Set.image f (Set.preimage f s)))","decl":"/-- If `f` has dense range and `s` is an open set in the codomain of `f`, then the image of the\npreimage of `s` under `f` is dense in `s`. -/\ntheorem DenseRange.subset_closure_image_preimage_of_isOpen (hf : DenseRange f) (hs : IsOpen s) :\n    s ⊆ closure (f '' (f ⁻¹' s)) := by\n  rw [image_preimage_eq_inter_range]\n  exact hf.open_subset_closure_inter hs\n\n"}
{"name":"DenseRange.dense_of_mapsTo","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nf : X → Y\nhf' : DenseRange f\nhf : Continuous f\nhs : Dense s\nt : Set Y\nht : Set.MapsTo f s t\n⊢ Dense t","decl":"/-- If a continuous map with dense range maps a dense set to a subset of `t`, then `t` is a dense\nset. -/\ntheorem DenseRange.dense_of_mapsTo {f : X → Y} (hf' : DenseRange f) (hf : Continuous f)\n    (hs : Dense s) {t : Set Y} (ht : MapsTo f s t) : Dense t :=\n  (hf'.dense_image hf hs).mono ht.image_subset\n\n"}
{"name":"DenseRange.comp","module":"Mathlib.Topology.Basic","initialProofState":"Y : Type u_2\nZ : Type u_3\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nα : Type u_4\ng : Y → Z\nf : α → Y\nhg : DenseRange g\nhf : DenseRange f\ncg : Continuous g\n⊢ DenseRange (Function.comp g f)","decl":"/-- Composition of a continuous map with dense range and a function with dense range has dense\nrange. -/\ntheorem DenseRange.comp {g : Y → Z} {f : α → Y} (hg : DenseRange g) (hf : DenseRange f)\n    (cg : Continuous g) : DenseRange (g ∘ f) := by\n  rw [DenseRange, range_comp]\n  exact hg.dense_image cg hf\n\n"}
{"name":"DenseRange.nonempty_iff","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nα : Type u_4\nf : α → X\nhf : DenseRange f\n⊢ Iff (Nonempty α) (Nonempty X)","decl":"nonrec theorem DenseRange.nonempty_iff (hf : DenseRange f) : Nonempty α ↔ Nonempty X :=\n  range_nonempty_iff_nonempty.symm.trans hf.nonempty_iff\n\n"}
{"name":"DenseRange.nonempty","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nα : Type u_4\nf : α → X\nh : Nonempty X\nhf : DenseRange f\n⊢ Nonempty α","decl":"theorem DenseRange.nonempty [h : Nonempty X] (hf : DenseRange f) : Nonempty α :=\n  hf.nonempty_iff.mpr h\n\n"}
{"name":"DenseRange.exists_mem_open","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nα : Type u_4\nf : α → X\ns : Set X\nhf : DenseRange f\nho : IsOpen s\nhs : s.Nonempty\n⊢ Exists fun a => Membership.mem s (f a)","decl":"nonrec theorem DenseRange.exists_mem_open (hf : DenseRange f) (ho : IsOpen s) (hs : s.Nonempty) :\n    ∃ a, f a ∈ s :=\n  exists_range_iff.1 <| hf.exists_mem_open ho hs\n\n"}
{"name":"DenseRange.mem_nhds","module":"Mathlib.Topology.Basic","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nx : X\nα : Type u_4\nf : α → X\ns : Set X\nh : DenseRange f\nhs : Membership.mem (nhds x) s\n⊢ Exists fun a => Membership.mem s (f a)","decl":"theorem DenseRange.mem_nhds (h : DenseRange f) (hs : s ∈ 𝓝 x) :\n    ∃ a, f a ∈ s :=\n  let ⟨a, ha⟩ := h.exists_mem_open isOpen_interior ⟨x, mem_interior_iff_mem_nhds.2 hs⟩\n  ⟨a, interior_subset ha⟩\n\n"}
