{"name":"Polynomial.bernoulli_def","module":"Mathlib.NumberTheory.BernoulliPolynomials","initialProofState":"n : Nat\n⊢ Eq (Polynomial.bernoulli n) ((Finset.range (HAdd.hAdd n 1)).sum fun i => (Polynomial.monomial i) (HMul.hMul (bernoulli (HSub.hSub n i)) ↑(n.choose i)))","decl":"theorem bernoulli_def (n : ℕ) : bernoulli n =\n    ∑ i ∈ range (n + 1), Polynomial.monomial i (_root_.bernoulli (n - i) * choose n i) := by\n  rw [← sum_range_reflect, add_succ_sub_one, add_zero, bernoulli]\n  apply sum_congr rfl\n  rintro x hx\n  rw [mem_range_succ_iff] at hx\n  rw [choose_symm hx, tsub_tsub_cancel_of_le hx]\n\n/-\n### examples\n-/\n"}
{"name":"Polynomial.bernoulli_zero","module":"Mathlib.NumberTheory.BernoulliPolynomials","initialProofState":"⊢ Eq (Polynomial.bernoulli 0) 1","decl":"@[simp]\ntheorem bernoulli_zero : bernoulli 0 = 1 := by simp [bernoulli]\n\n"}
{"name":"Polynomial.bernoulli_eval_zero","module":"Mathlib.NumberTheory.BernoulliPolynomials","initialProofState":"n : Nat\n⊢ Eq (Polynomial.eval 0 (Polynomial.bernoulli n)) (bernoulli n)","decl":"@[simp]\ntheorem bernoulli_eval_zero (n : ℕ) : (bernoulli n).eval 0 = _root_.bernoulli n := by\n  rw [bernoulli, eval_finset_sum, sum_range_succ]\n  have : ∑ x ∈ range n, _root_.bernoulli x * n.choose x * 0 ^ (n - x) = 0 := by\n    apply sum_eq_zero fun x hx => _\n    intros x hx\n    simp [tsub_eq_zero_iff_le, mem_range.1 hx]\n  simp [this]\n\n"}
{"name":"Polynomial.bernoulli_eval_one","module":"Mathlib.NumberTheory.BernoulliPolynomials","initialProofState":"n : Nat\n⊢ Eq (Polynomial.eval 1 (Polynomial.bernoulli n)) (bernoulli' n)","decl":"@[simp]\ntheorem bernoulli_eval_one (n : ℕ) : (bernoulli n).eval 1 = bernoulli' n := by\n  simp only [bernoulli, eval_finset_sum]\n  simp only [← succ_eq_add_one, sum_range_succ, mul_one, cast_one, choose_self,\n    (_root_.bernoulli _).mul_comm, sum_bernoulli, one_pow, mul_one, eval_C, eval_monomial, one_mul]\n  by_cases h : n = 1\n  · norm_num [h]\n  · simp [h, bernoulli_eq_bernoulli'_of_ne_one h]\n\n"}
{"name":"Polynomial.derivative_bernoulli_add_one","module":"Mathlib.NumberTheory.BernoulliPolynomials","initialProofState":"k : Nat\n⊢ Eq (Polynomial.derivative (Polynomial.bernoulli (HAdd.hAdd k 1))) (HMul.hMul (HAdd.hAdd (↑k) 1) (Polynomial.bernoulli k))","decl":"theorem derivative_bernoulli_add_one (k : ℕ) :\n    Polynomial.derivative (bernoulli (k + 1)) = (k + 1) * bernoulli k := by\n  simp_rw [bernoulli, derivative_sum, derivative_monomial, Nat.sub_sub, Nat.add_sub_add_right]\n  -- LHS sum has an extra term, but the coefficient is zero:\n  rw [range_add_one, sum_insert not_mem_range_self, tsub_self, cast_zero, mul_zero,\n    map_zero, zero_add, mul_sum]\n  -- the rest of the sum is termwise equal:\n  refine sum_congr (by rfl) fun m _ => ?_\n  conv_rhs => rw [← Nat.cast_one, ← Nat.cast_add, ← C_eq_natCast, C_mul_monomial, mul_comm]\n  rw [mul_assoc, mul_assoc, ← Nat.cast_mul, ← Nat.cast_mul]\n  congr 3\n  rw [(choose_mul_succ_eq k m).symm]\n\n"}
{"name":"Polynomial.derivative_bernoulli","module":"Mathlib.NumberTheory.BernoulliPolynomials","initialProofState":"k : Nat\n⊢ Eq (Polynomial.derivative (Polynomial.bernoulli k)) (HMul.hMul (↑k) (Polynomial.bernoulli (HSub.hSub k 1)))","decl":"theorem derivative_bernoulli (k : ℕ) :\n    Polynomial.derivative (bernoulli k) = k * bernoulli (k - 1) := by\n  cases k with\n  | zero => rw [Nat.cast_zero, zero_mul, bernoulli_zero, derivative_one]\n  | succ k => exact mod_cast derivative_bernoulli_add_one k\n\n"}
{"name":"Polynomial.sum_bernoulli","module":"Mathlib.NumberTheory.BernoulliPolynomials","initialProofState":"n : Nat\n⊢ Eq ((Finset.range (HAdd.hAdd n 1)).sum fun k => HSMul.hSMul (↑((HAdd.hAdd n 1).choose k)) (Polynomial.bernoulli k)) ((Polynomial.monomial n) (HAdd.hAdd (↑n) 1))","decl":"@[simp]\nnonrec theorem sum_bernoulli (n : ℕ) :\n    (∑ k ∈ range (n + 1), ((n + 1).choose k : ℚ) • bernoulli k) = monomial n (n + 1 : ℚ) := by\n  simp_rw [bernoulli_def, Finset.smul_sum, Finset.range_eq_Ico, ← Finset.sum_Ico_Ico_comm,\n    Finset.sum_Ico_eq_sum_range]\n  simp only [add_tsub_cancel_left, tsub_zero, zero_add, map_add]\n  simp_rw [smul_monomial, mul_comm (_root_.bernoulli _) _, smul_eq_mul, ← mul_assoc]\n  conv_lhs =>\n    apply_congr\n    · skip\n    · conv =>\n      apply_congr\n      · skip\n      · rw [← Nat.cast_mul, choose_mul ((le_tsub_iff_left <| mem_range_le (by assumption)).1 <|\n            mem_range_le (by assumption)) (le.intro rfl),\n          Nat.cast_mul, add_tsub_cancel_left, mul_assoc, mul_comm, ← smul_eq_mul, ←\n          smul_monomial]\n  simp_rw [← sum_smul]\n  rw [sum_range_succ_comm]\n  simp only [add_right_eq_self, mul_one, cast_one, cast_add, add_tsub_cancel_left,\n    choose_succ_self_right, one_smul, _root_.bernoulli_zero, sum_singleton, zero_add,\n    map_add, range_one, bernoulli_zero, mul_one, one_mul, add_zero, choose_self]\n  apply sum_eq_zero fun x hx => _\n  have f : ∀ x ∈ range n, ¬n + 1 - x = 1 := by\n    rintro x H\n    rw [mem_range] at H\n    rw [eq_comm]\n    exact _root_.ne_of_lt (Nat.lt_of_lt_of_le one_lt_two (le_tsub_of_add_le_left (succ_le_succ H)))\n  intro x hx\n  rw [sum_bernoulli]\n  have g : ite (n + 1 - x = 1) (1 : ℚ) 0 = 0 := by\n    simp only [ite_eq_right_iff, one_ne_zero]\n    intro h₁\n    exact (f x hx) h₁\n  rw [g, zero_smul]\n\n"}
{"name":"Polynomial.bernoulli_eq_sub_sum","module":"Mathlib.NumberTheory.BernoulliPolynomials","initialProofState":"n : Nat\n⊢ Eq (HSMul.hSMul (↑n.succ) (Polynomial.bernoulli n)) (HSub.hSub ((Polynomial.monomial n) ↑n.succ) ((Finset.range n).sum fun k => HSMul.hSMul (↑((HAdd.hAdd n 1).choose k)) (Polynomial.bernoulli k)))","decl":"/-- Another version of `Polynomial.sum_bernoulli`. -/\ntheorem bernoulli_eq_sub_sum (n : ℕ) :\n    (n.succ : ℚ) • bernoulli n =\n      monomial n (n.succ : ℚ) - ∑ k ∈ Finset.range n, ((n + 1).choose k : ℚ) • bernoulli k := by\n  rw [Nat.cast_succ, ← sum_bernoulli n, sum_range_succ, add_sub_cancel_left, choose_succ_self_right,\n    Nat.cast_succ]\n\n"}
{"name":"Polynomial.sum_range_pow_eq_bernoulli_sub","module":"Mathlib.NumberTheory.BernoulliPolynomials","initialProofState":"n p : Nat\n⊢ Eq (HMul.hMul (HAdd.hAdd (↑p) 1) ((Finset.range n).sum fun k => HPow.hPow (↑k) p)) (HSub.hSub (Polynomial.eval (↑n) (Polynomial.bernoulli p.succ)) (bernoulli p.succ))","decl":"/-- Another version of `sum_range_pow`. -/\ntheorem sum_range_pow_eq_bernoulli_sub (n p : ℕ) :\n    ((p + 1 : ℚ) * ∑ k ∈ range n, (k : ℚ) ^ p) = (bernoulli p.succ).eval (n : ℚ) -\n    _root_.bernoulli p.succ := by\n  rw [sum_range_pow, bernoulli_def, eval_finset_sum, ← sum_div, mul_div_cancel₀ _ _]\n  · simp_rw [eval_monomial]\n    symm\n    rw [← sum_flip _, sum_range_succ]\n    simp only [tsub_self, tsub_zero, choose_zero_right, cast_one, mul_one, _root_.pow_zero,\n      add_tsub_cancel_right]\n    apply sum_congr rfl fun x hx => _\n    intro x hx\n    apply congr_arg₂ _ (congr_arg₂ _ _ _) rfl\n    · rw [Nat.sub_sub_self (mem_range_le hx)]\n    · rw [← choose_symm (mem_range_le hx)]\n  · norm_cast\n\n"}
{"name":"Polynomial.bernoulli_succ_eval","module":"Mathlib.NumberTheory.BernoulliPolynomials","initialProofState":"n p : Nat\n⊢ Eq (Polynomial.eval (↑n) (Polynomial.bernoulli p.succ)) (HAdd.hAdd (bernoulli p.succ) (HMul.hMul (HAdd.hAdd (↑p) 1) ((Finset.range n).sum fun k => HPow.hPow (↑k) p)))","decl":"/-- Rearrangement of `Polynomial.sum_range_pow_eq_bernoulli_sub`. -/\ntheorem bernoulli_succ_eval (n p : ℕ) : (bernoulli p.succ).eval (n : ℚ) =\n    _root_.bernoulli p.succ + (p + 1 : ℚ) * ∑ k ∈ range n, (k : ℚ) ^ p := by\n  apply eq_add_of_sub_eq'\n  rw [sum_range_pow_eq_bernoulli_sub]\n\n"}
{"name":"Polynomial.bernoulli_eval_one_add","module":"Mathlib.NumberTheory.BernoulliPolynomials","initialProofState":"n : Nat\nx : Rat\n⊢ Eq (Polynomial.eval (HAdd.hAdd 1 x) (Polynomial.bernoulli n)) (HAdd.hAdd (Polynomial.eval x (Polynomial.bernoulli n)) (HMul.hMul (↑n) (HPow.hPow x (HSub.hSub n 1))))","decl":"theorem bernoulli_eval_one_add (n : ℕ) (x : ℚ) :\n    (bernoulli n).eval (1 + x) = (bernoulli n).eval x + n * x ^ (n - 1) := by\n  refine Nat.strong_induction_on n fun d hd => ?_\n  have nz : ((d.succ : ℕ) : ℚ) ≠ 0 := by norm_cast\n  apply (mul_right_inj' nz).1\n  rw [← smul_eq_mul, ← eval_smul, bernoulli_eq_sub_sum, mul_add, ← smul_eq_mul, ← eval_smul,\n    bernoulli_eq_sub_sum, eval_sub, eval_finset_sum]\n  conv_lhs =>\n    congr\n    · skip\n    · apply_congr\n      · skip\n      · rw [eval_smul, hd _ (mem_range.1 (by assumption))]\n  rw [eval_sub, eval_finset_sum]\n  simp_rw [eval_smul, smul_add]\n  rw [sum_add_distrib, sub_add, sub_eq_sub_iff_sub_eq_sub, _root_.add_sub_sub_cancel]\n  conv_rhs =>\n    congr\n    · skip\n    · congr\n      rw [succ_eq_add_one, ← choose_succ_self_right d]\n  rw [Nat.cast_succ, ← smul_eq_mul, ← sum_range_succ _ d, eval_monomial_one_add_sub]\n  simp_rw [smul_eq_mul]\n\n"}
{"name":"Polynomial.bernoulli_generating_function","module":"Mathlib.NumberTheory.BernoulliPolynomials","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Algebra Rat A\nt : A\n⊢ Eq (HMul.hMul (PowerSeries.mk fun n => (Polynomial.aeval t) (HSMul.hSMul (HDiv.hDiv 1 ↑n.factorial) (Polynomial.bernoulli n))) (HSub.hSub (PowerSeries.exp A) 1)) (HMul.hMul PowerSeries.X ((PowerSeries.rescale t) (PowerSeries.exp A)))","decl":"/-- The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ -/\ntheorem bernoulli_generating_function (t : A) :\n    (mk fun n => aeval t ((1 / n ! : ℚ) • bernoulli n)) * (exp A - 1) =\n      PowerSeries.X * rescale t (exp A) := by\n  -- check equality of power series by checking coefficients of X^n\n  ext n\n  -- n = 0 case solved by `simp`\n  cases' n with n\n  · simp\n  -- n ≥ 1, the coefficients is a sum to n+2, so use `sum_range_succ` to write as\n  -- last term plus sum to n+1\n  rw [coeff_succ_X_mul, coeff_rescale, coeff_exp, PowerSeries.coeff_mul,\n    Nat.sum_antidiagonal_eq_sum_range_succ_mk, sum_range_succ]\n  -- last term is zero so kill with `add_zero`\n  simp only [RingHom.map_sub, tsub_self, constantCoeff_one, constantCoeff_exp,\n    coeff_zero_eq_constantCoeff, mul_zero, sub_self, add_zero]\n  -- Let's multiply both sides by (n+1)! (OK because it's a unit)\n  have hnp1 : IsUnit ((n + 1)! : ℚ) := IsUnit.mk0 _ (mod_cast factorial_ne_zero (n + 1))\n  rw [← (hnp1.map (algebraMap ℚ A)).mul_right_inj]\n  -- do trivial rearrangements to make RHS (n+1)*t^n\n  rw [mul_left_comm, ← RingHom.map_mul]\n  change _ = t ^ n * algebraMap ℚ A (((n + 1) * n ! : ℕ) * (1 / n !))\n  rw [cast_mul, mul_assoc,\n    mul_one_div_cancel (show (n ! : ℚ) ≠ 0 from cast_ne_zero.2 (factorial_ne_zero n)), mul_one,\n    mul_comm (t ^ n), ← aeval_monomial, cast_add, cast_one]\n  -- But this is the RHS of `Polynomial.sum_bernoulli`\n  rw [← sum_bernoulli, Finset.mul_sum, map_sum]\n  -- and now we have to prove a sum is a sum, but all the terms are equal.\n  apply Finset.sum_congr rfl\n  -- The rest is just trivialities, hampered by the fact that we're coercing\n  -- factorials and binomial coefficients between ℕ and ℚ and A.\n  intro i hi\n  -- deal with coefficients of e^X-1\n  simp only [Nat.cast_choose ℚ (mem_range_le hi), coeff_mk, if_neg (mem_range_sub_ne_zero hi),\n    one_div, map_smul, PowerSeries.coeff_one, coeff_exp, sub_zero, LinearMap.map_sub,\n    Algebra.smul_mul_assoc, Algebra.smul_def, mul_right_comm _ ((aeval t) _), ← mul_assoc, ←\n    RingHom.map_mul, succ_eq_add_one, ← Polynomial.C_eq_algebraMap, Polynomial.aeval_mul,\n    Polynomial.aeval_C]\n  -- finally cancel the Bernoulli polynomial and the algebra_map\n  field_simp\n\n"}
