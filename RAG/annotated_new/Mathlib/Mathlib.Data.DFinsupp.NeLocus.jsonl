{"name":"DFinsupp.mem_neLocus","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → Zero (N a)\nf g : DFinsupp fun a => N a\na : α\n⊢ Iff (Membership.mem (f.neLocus g) a) (Ne (f a) (g a))","decl":"@[simp]\ntheorem mem_neLocus {f g : Π₀ a, N a} {a : α} : a ∈ f.neLocus g ↔ f a ≠ g a := by\n  simpa only [neLocus, Finset.mem_filter, Finset.mem_union, mem_support_iff,\n    and_iff_right_iff_imp] using Ne.ne_or_ne _\n\n"}
{"name":"DFinsupp.not_mem_neLocus","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → Zero (N a)\nf g : DFinsupp fun a => N a\na : α\n⊢ Iff (Not (Membership.mem (f.neLocus g) a)) (Eq (f a) (g a))","decl":"theorem not_mem_neLocus {f g : Π₀ a, N a} {a : α} : a ∉ f.neLocus g ↔ f a = g a :=\n  mem_neLocus.not.trans not_ne_iff\n\n"}
{"name":"DFinsupp.coe_neLocus","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → Zero (N a)\nf g : DFinsupp fun a => N a\n⊢ Eq (↑(f.neLocus g)) (setOf fun x => Ne (f x) (g x))","decl":"@[simp]\ntheorem coe_neLocus : ↑(f.neLocus g) = { x | f x ≠ g x } :=\n  Set.ext fun _x ↦ mem_neLocus\n\n"}
{"name":"DFinsupp.neLocus_eq_empty","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → Zero (N a)\nf g : DFinsupp fun a => N a\n⊢ Iff (Eq (f.neLocus g) EmptyCollection.emptyCollection) (Eq f g)","decl":"@[simp]\ntheorem neLocus_eq_empty {f g : Π₀ a, N a} : f.neLocus g = ∅ ↔ f = g :=\n  ⟨fun h ↦\n    ext fun a ↦ not_not.mp (mem_neLocus.not.mp (Finset.eq_empty_iff_forall_not_mem.mp h a)),\n    fun h ↦ h ▸ by simp only [neLocus, Ne, eq_self_iff_true, not_true, Finset.filter_False]⟩\n\n"}
{"name":"DFinsupp.nonempty_neLocus_iff","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → Zero (N a)\nf g : DFinsupp fun a => N a\n⊢ Iff (f.neLocus g).Nonempty (Ne f g)","decl":"@[simp]\ntheorem nonempty_neLocus_iff {f g : Π₀ a, N a} : (f.neLocus g).Nonempty ↔ f ≠ g :=\n  Finset.nonempty_iff_ne_empty.trans neLocus_eq_empty.not\n\n"}
{"name":"DFinsupp.neLocus_comm","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → Zero (N a)\nf g : DFinsupp fun a => N a\n⊢ Eq (f.neLocus g) (g.neLocus f)","decl":"theorem neLocus_comm : f.neLocus g = g.neLocus f := by\n  simp_rw [neLocus, Finset.union_comm, ne_comm]\n\n"}
{"name":"DFinsupp.neLocus_zero_right","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → Zero (N a)\nf : DFinsupp fun a => N a\n⊢ Eq (f.neLocus 0) f.support","decl":"@[simp]\ntheorem neLocus_zero_right : f.neLocus 0 = f.support := by\n  ext\n  rw [mem_neLocus, mem_support_iff, coe_zero, Pi.zero_apply]\n\n"}
{"name":"DFinsupp.neLocus_zero_left","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → Zero (N a)\nf : DFinsupp fun a => N a\n⊢ Eq (DFinsupp.neLocus 0 f) f.support","decl":"@[simp]\ntheorem neLocus_zero_left : (0 : Π₀ a, N a).neLocus f = f.support :=\n  (neLocus_comm _ _).trans (neLocus_zero_right _)\n\n"}
{"name":"DFinsupp.subset_mapRange_neLocus","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝⁴ : DecidableEq α\nM : α → Type u_3\ninst✝³ : (a : α) → Zero (N a)\ninst✝² : (a : α) → Zero (M a)\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → DecidableEq (M a)\nf g : DFinsupp fun a => N a\nF : (a : α) → N a → M a\nF0 : ∀ (a : α), Eq (F a 0) 0\n⊢ HasSubset.Subset ((DFinsupp.mapRange F F0 f).neLocus (DFinsupp.mapRange F F0 g)) (f.neLocus g)","decl":"theorem subset_mapRange_neLocus [∀ a, DecidableEq (N a)] [∀ a, DecidableEq (M a)] (f g : Π₀ a, N a)\n    {F : ∀ a, N a → M a} (F0 : ∀ a, F a 0 = 0) :\n    (f.mapRange F F0).neLocus (g.mapRange F F0) ⊆ f.neLocus g := fun a ↦ by\n  simpa only [mem_neLocus, mapRange_apply, not_imp_not] using congr_arg (F a)\n\n"}
{"name":"DFinsupp.zipWith_neLocus_eq_left","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝⁵ : DecidableEq α\nM : α → Type u_3\nP : α → Type u_4\ninst✝⁴ : (a : α) → Zero (N a)\ninst✝³ : (a : α) → Zero (M a)\ninst✝² : (a : α) → Zero (P a)\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → DecidableEq (P a)\nF : (a : α) → M a → N a → P a\nF0 : ∀ (a : α), Eq (F a 0 0) 0\nf : DFinsupp fun a => M a\ng₁ g₂ : DFinsupp fun a => N a\nhF : ∀ (a : α) (f : M a), Function.Injective fun g => F a f g\n⊢ Eq ((DFinsupp.zipWith F F0 f g₁).neLocus (DFinsupp.zipWith F F0 f g₂)) (g₁.neLocus g₂)","decl":"theorem zipWith_neLocus_eq_left [∀ a, DecidableEq (N a)] [∀ a, DecidableEq (P a)]\n    {F : ∀ a, M a → N a → P a} (F0 : ∀ a, F a 0 0 = 0) (f : Π₀ a, M a) (g₁ g₂ : Π₀ a, N a)\n    (hF : ∀ a f, Function.Injective fun g ↦ F a f g) :\n    (zipWith F F0 f g₁).neLocus (zipWith F F0 f g₂) = g₁.neLocus g₂ := by\n  ext a\n  simpa only [mem_neLocus] using (hF a _).ne_iff\n\n"}
{"name":"DFinsupp.zipWith_neLocus_eq_right","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝⁵ : DecidableEq α\nM : α → Type u_3\nP : α → Type u_4\ninst✝⁴ : (a : α) → Zero (N a)\ninst✝³ : (a : α) → Zero (M a)\ninst✝² : (a : α) → Zero (P a)\ninst✝¹ : (a : α) → DecidableEq (M a)\ninst✝ : (a : α) → DecidableEq (P a)\nF : (a : α) → M a → N a → P a\nF0 : ∀ (a : α), Eq (F a 0 0) 0\nf₁ f₂ : DFinsupp fun a => M a\ng : DFinsupp fun a => N a\nhF : ∀ (a : α) (g : N a), Function.Injective fun f => F a f g\n⊢ Eq ((DFinsupp.zipWith F F0 f₁ g).neLocus (DFinsupp.zipWith F F0 f₂ g)) (f₁.neLocus f₂)","decl":"theorem zipWith_neLocus_eq_right [∀ a, DecidableEq (M a)] [∀ a, DecidableEq (P a)]\n    {F : ∀ a, M a → N a → P a} (F0 : ∀ a, F a 0 0 = 0) (f₁ f₂ : Π₀ a, M a) (g : Π₀ a, N a)\n    (hF : ∀ a g, Function.Injective fun f ↦ F a f g) :\n    (zipWith F F0 f₁ g).neLocus (zipWith F F0 f₂ g) = f₁.neLocus f₂ := by\n  ext a\n  simpa only [mem_neLocus] using (hF a _).ne_iff\n\n"}
{"name":"DFinsupp.mapRange_neLocus_eq","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝⁴ : DecidableEq α\nM : α → Type u_3\ninst✝³ : (a : α) → Zero (N a)\ninst✝² : (a : α) → Zero (M a)\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → DecidableEq (M a)\nf g : DFinsupp fun a => N a\nF : (a : α) → N a → M a\nF0 : ∀ (a : α), Eq (F a 0) 0\nhF : ∀ (a : α), Function.Injective (F a)\n⊢ Eq ((DFinsupp.mapRange F F0 f).neLocus (DFinsupp.mapRange F F0 g)) (f.neLocus g)","decl":"theorem mapRange_neLocus_eq [∀ a, DecidableEq (N a)] [∀ a, DecidableEq (M a)] (f g : Π₀ a, N a)\n    {F : ∀ a, N a → M a} (F0 : ∀ a, F a 0 = 0) (hF : ∀ a, Function.Injective (F a)) :\n    (f.mapRange F F0).neLocus (g.mapRange F F0) = f.neLocus g := by\n  ext a\n  simpa only [mem_neLocus] using (hF a).ne_iff\n\n"}
{"name":"DFinsupp.neLocus_add_left","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → AddLeftCancelMonoid (N a)\nf g h : DFinsupp fun a => N a\n⊢ Eq ((HAdd.hAdd f g).neLocus (HAdd.hAdd f h)) (g.neLocus h)","decl":"@[simp]\ntheorem neLocus_add_left [∀ a, AddLeftCancelMonoid (N a)] (f g h : Π₀ a, N a) :\n    (f + g).neLocus (f + h) = g.neLocus h :=\n  zipWith_neLocus_eq_left _ _ _ _ fun _a ↦ add_right_injective\n\n"}
{"name":"DFinsupp.neLocus_add_right","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → AddRightCancelMonoid (N a)\nf g h : DFinsupp fun a => N a\n⊢ Eq ((HAdd.hAdd f h).neLocus (HAdd.hAdd g h)) (f.neLocus g)","decl":"@[simp]\ntheorem neLocus_add_right [∀ a, AddRightCancelMonoid (N a)] (f g h : Π₀ a, N a) :\n    (f + h).neLocus (g + h) = f.neLocus g :=\n  zipWith_neLocus_eq_right _ _ _ _ fun _a ↦ add_left_injective\n\n"}
{"name":"DFinsupp.neLocus_neg_neg","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → AddGroup (N a)\nf g : DFinsupp fun a => N a\n⊢ Eq ((Neg.neg f).neLocus (Neg.neg g)) (f.neLocus g)","decl":"@[simp]\ntheorem neLocus_neg_neg : neLocus (-f) (-g) = f.neLocus g :=\n  mapRange_neLocus_eq _ _ (fun _a ↦ neg_zero) fun _a ↦ neg_injective\n\n"}
{"name":"DFinsupp.neLocus_neg","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → AddGroup (N a)\nf g : DFinsupp fun a => N a\n⊢ Eq ((Neg.neg f).neLocus g) (f.neLocus (Neg.neg g))","decl":"theorem neLocus_neg : neLocus (-f) g = f.neLocus (-g) := by rw [← neLocus_neg_neg, neg_neg]\n\n"}
{"name":"DFinsupp.neLocus_eq_support_sub","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → AddGroup (N a)\nf g : DFinsupp fun a => N a\n⊢ Eq (f.neLocus g) (HSub.hSub f g).support","decl":"theorem neLocus_eq_support_sub : f.neLocus g = (f - g).support := by\n  rw [← @neLocus_add_right α N _ _ _ _ _ (-g), add_neg_cancel, neLocus_zero_right, sub_eq_add_neg]\n\n"}
{"name":"DFinsupp.neLocus_sub_left","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → AddGroup (N a)\nf g₁ g₂ : DFinsupp fun a => N a\n⊢ Eq ((HSub.hSub f g₁).neLocus (HSub.hSub f g₂)) (g₁.neLocus g₂)","decl":"@[simp]\ntheorem neLocus_sub_left : neLocus (f - g₁) (f - g₂) = neLocus g₁ g₂ := by\n  simp only [sub_eq_add_neg, @neLocus_add_left α N _ _ _, neLocus_neg_neg]\n\n"}
{"name":"DFinsupp.neLocus_sub_right","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → AddGroup (N a)\nf₁ f₂ g : DFinsupp fun a => N a\n⊢ Eq ((HSub.hSub f₁ g).neLocus (HSub.hSub f₂ g)) (f₁.neLocus f₂)","decl":"@[simp]\ntheorem neLocus_sub_right : neLocus (f₁ - g) (f₂ - g) = neLocus f₁ f₂ := by\n  simpa only [sub_eq_add_neg] using @neLocus_add_right α N _ _ _ _ _ _\n\n"}
{"name":"DFinsupp.neLocus_self_add_right","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → AddGroup (N a)\nf g : DFinsupp fun a => N a\n⊢ Eq (f.neLocus (HAdd.hAdd f g)) g.support","decl":"@[simp]\ntheorem neLocus_self_add_right : neLocus f (f + g) = g.support := by\n  rw [← neLocus_zero_left, ← @neLocus_add_left α N _ _ _ f 0 g, add_zero]\n\n"}
{"name":"DFinsupp.neLocus_self_add_left","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → AddGroup (N a)\nf g : DFinsupp fun a => N a\n⊢ Eq ((HAdd.hAdd f g).neLocus f) g.support","decl":"@[simp]\ntheorem neLocus_self_add_left : neLocus (f + g) f = g.support := by\n  rw [neLocus_comm, neLocus_self_add_right]\n\n"}
{"name":"DFinsupp.neLocus_self_sub_right","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → AddGroup (N a)\nf g : DFinsupp fun a => N a\n⊢ Eq (f.neLocus (HSub.hSub f g)) g.support","decl":"@[simp]\ntheorem neLocus_self_sub_right : neLocus f (f - g) = g.support := by\n  rw [sub_eq_add_neg, neLocus_self_add_right, support_neg]\n\n"}
{"name":"DFinsupp.neLocus_self_sub_left","module":"Mathlib.Data.DFinsupp.NeLocus","initialProofState":"α : Type u_1\nN : α → Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : (a : α) → DecidableEq (N a)\ninst✝ : (a : α) → AddGroup (N a)\nf g : DFinsupp fun a => N a\n⊢ Eq ((HSub.hSub f g).neLocus f) g.support","decl":"@[simp]\ntheorem neLocus_self_sub_left : neLocus (f - g) f = g.support := by\n  rw [neLocus_comm, neLocus_self_sub_right]\n\n"}
