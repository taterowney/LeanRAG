{"name":"OrderTopology.topology_eq_generate_intervals","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u_1\nt : TopologicalSpace Œ±\ninst‚úù : Preorder Œ±\nself : OrderTopology Œ±\n‚ä¢ Eq t (TopologicalSpace.generateFrom (setOf fun s => Exists fun a => Or (Eq s (Set.Ioi a)) (Eq s (Set.Iio a))))","decl":"/-- The order topology on an ordered type is the topology generated by open intervals. We register\nit on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.\nWe define it as a mixin. If you want to introduce the order topology on a preorder, use\n`Preorder.topology`. -/\nclass OrderTopology (Œ± : Type*) [t : TopologicalSpace Œ±] [Preorder Œ±] : Prop where\n  /-- The topology is generated by open intervals `Set.Ioi _` and `Set.Iio _`. -/\n  topology_eq_generate_intervals : t = generateFrom { s | ‚àÉ a, s = Ioi a ‚à® s = Iio a }\n\n"}
{"name":"instOrderTopologyOrderDual","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Preorder Œ±\nt : OrderTopology Œ±\n‚ä¢ OrderTopology (OrderDual Œ±)","decl":"instance [t : OrderTopology Œ±] : OrderTopology Œ±·µí·µà :=\n  ‚ü®by\n    convert OrderTopology.topology_eq_generate_intervals (Œ± := Œ±) using 6\n    apply or_comm‚ü©\n\n"}
{"name":"isOpen_iff_generate_intervals","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Preorder Œ±\nt : OrderTopology Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen s) (TopologicalSpace.GenerateOpen (setOf fun s => Exists fun a => Or (Eq s (Set.Ioi a)) (Eq s (Set.Iio a))) s)","decl":"theorem isOpen_iff_generate_intervals [t : OrderTopology Œ±] {s : Set Œ±} :\n    IsOpen s ‚Üî GenerateOpen { s | ‚àÉ a, s = Ioi a ‚à® s = Iio a } s := by\n  rw [t.topology_eq_generate_intervals]; rfl\n\n"}
{"name":"isOpen_lt'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ IsOpen (setOf fun b => LT.lt a b)","decl":"theorem isOpen_lt' [OrderTopology Œ±] (a : Œ±) : IsOpen { b : Œ± | a < b } :=\n  isOpen_iff_generate_intervals.2 <| .basic _ ‚ü®a, .inl rfl‚ü©\n\n"}
{"name":"isOpen_gt'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ IsOpen (setOf fun b => LT.lt b a)","decl":"theorem isOpen_gt' [OrderTopology Œ±] (a : Œ±) : IsOpen { b : Œ± | b < a } :=\n  isOpen_iff_generate_intervals.2 <| .basic _ ‚ü®a, .inr rfl‚ü©\n\n"}
{"name":"lt_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na b : Œ±\nh : LT.lt a b\n‚ä¢ Filter.Eventually (fun x => LT.lt a x) (nhds b)","decl":"theorem lt_mem_nhds [OrderTopology Œ±] {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a < x :=\n  (isOpen_lt' _).mem_nhds h\n\n"}
{"name":"le_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na b : Œ±\nh : LT.lt a b\n‚ä¢ Filter.Eventually (fun x => LE.le a x) (nhds b)","decl":"theorem le_mem_nhds [OrderTopology Œ±] {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a ‚â§ x :=\n  (lt_mem_nhds h).mono fun _ => le_of_lt\n\n"}
{"name":"gt_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na b : Œ±\nh : LT.lt a b\n‚ä¢ Filter.Eventually (fun x => LT.lt x b) (nhds a)","decl":"theorem gt_mem_nhds [OrderTopology Œ±] {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x < b :=\n  (isOpen_gt' _).mem_nhds h\n\n"}
{"name":"ge_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na b : Œ±\nh : LT.lt a b\n‚ä¢ Filter.Eventually (fun x => LE.le x b) (nhds a)","decl":"theorem ge_mem_nhds [OrderTopology Œ±] {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x ‚â§ b :=\n  (gt_mem_nhds h).mono fun _ => le_of_lt\n\n"}
{"name":"nhds_eq_order","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Eq (nhds a) (Min.min (iInf fun b => iInf fun h => Filter.principal (Set.Ioi b)) (iInf fun b => iInf fun h => Filter.principal (Set.Iio b)))","decl":"theorem nhds_eq_order [OrderTopology Œ±] (a : Œ±) :\n    ùìù a = (‚®Ö b ‚àà Iio a, ùìü (Ioi b)) ‚äì ‚®Ö b ‚àà Ioi a, ùìü (Iio b) := by\n  rw [OrderTopology.topology_eq_generate_intervals (Œ± := Œ±), nhds_generateFrom]\n  simp_rw [mem_setOf_eq, @and_comm (a ‚àà _), exists_or, or_and_right, iInf_or, iInf_and,\n    iInf_exists, iInf_inf_eq, iInf_comm (Œπ := Set Œ±), iInf_iInf_eq_left, mem_Ioi, mem_Iio]\n\n"}
{"name":"tendsto_order","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\nf : Œ≤ ‚Üí Œ±\na : Œ±\nx : Filter Œ≤\n‚ä¢ Iff (Filter.Tendsto f x (nhds a)) (And (‚àÄ (a' : Œ±), LT.lt a' a ‚Üí Filter.Eventually (fun b => LT.lt a' (f b)) x) (‚àÄ (a' : Œ±), GT.gt a' a ‚Üí Filter.Eventually (fun b => LT.lt (f b) a') x))","decl":"theorem tendsto_order [OrderTopology Œ±] {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : Filter Œ≤} :\n    Tendsto f x (ùìù a) ‚Üî (‚àÄ a' < a, ‚àÄ·∂† b in x, a' < f b) ‚àß ‚àÄ a' > a, ‚àÄ·∂† b in x, f b < a' := by\n  simp only [nhds_eq_order a, tendsto_inf, tendsto_iInf, tendsto_principal]; rfl\n"}
{"name":"tendstoIccClassNhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Filter.TendstoIxxClass Set.Icc (nhds a) (nhds a)","decl":"instance tendstoIccClassNhds [OrderTopology Œ±] (a : Œ±) : TendstoIxxClass Icc (ùìù a) (ùìù a) := by\n  simp only [nhds_eq_order, iInf_subtype']\n  refine\n    ((hasBasis_iInf_principal_finite _).inf (hasBasis_iInf_principal_finite _)).tendstoIxxClass\n      fun s _ => ?_\n  refine ((ordConnected_biInter ?_).inter (ordConnected_biInter ?_)).out <;> intro _ _\n  exacts [ordConnected_Ioi, ordConnected_Iio]\n\n"}
{"name":"tendstoIcoClassNhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Filter.TendstoIxxClass Set.Ico (nhds a) (nhds a)","decl":"instance tendstoIcoClassNhds [OrderTopology Œ±] (a : Œ±) : TendstoIxxClass Ico (ùìù a) (ùìù a) :=\n  tendstoIxxClass_of_subset fun _ _ => Ico_subset_Icc_self\n\n"}
{"name":"tendstoIocClassNhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Filter.TendstoIxxClass Set.Ioc (nhds a) (nhds a)","decl":"instance tendstoIocClassNhds [OrderTopology Œ±] (a : Œ±) : TendstoIxxClass Ioc (ùìù a) (ùìù a) :=\n  tendstoIxxClass_of_subset fun _ _ => Ioc_subset_Icc_self\n\n"}
{"name":"tendstoIooClassNhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Filter.TendstoIxxClass Set.Ioo (nhds a) (nhds a)","decl":"instance tendstoIooClassNhds [OrderTopology Œ±] (a : Œ±) : TendstoIxxClass Ioo (ùìù a) (ùìù a) :=\n  tendstoIxxClass_of_subset fun _ _ => Ioo_subset_Icc_self\n\n"}
{"name":"tendsto_of_tendsto_of_tendsto_of_le_of_le'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\nf g h : Œ≤ ‚Üí Œ±\nb : Filter Œ≤\na : Œ±\nhg : Filter.Tendsto g b (nhds a)\nhh : Filter.Tendsto h b (nhds a)\nhgf : Filter.Eventually (fun b => LE.le (g b) (f b)) b\nhfh : Filter.Eventually (fun b => LE.le (f b) (h b)) b\n‚ä¢ Filter.Tendsto f b (nhds a)","decl":"/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities\nhold eventually for the filter. -/\ntheorem tendsto_of_tendsto_of_tendsto_of_le_of_le' [OrderTopology Œ±] {f g h : Œ≤ ‚Üí Œ±} {b : Filter Œ≤}\n    {a : Œ±} (hg : Tendsto g b (ùìù a)) (hh : Tendsto h b (ùìù a)) (hgf : ‚àÄ·∂† b in b, g b ‚â§ f b)\n    (hfh : ‚àÄ·∂† b in b, f b ‚â§ h b) : Tendsto f b (ùìù a) :=\n  (hg.Icc hh).of_smallSets <| hgf.and hfh\n\n"}
{"name":"tendsto_of_tendsto_of_tendsto_of_le_of_le","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\nf g h : Œ≤ ‚Üí Œ±\nb : Filter Œ≤\na : Œ±\nhg : Filter.Tendsto g b (nhds a)\nhh : Filter.Tendsto h b (nhds a)\nhgf : LE.le g f\nhfh : LE.le f h\n‚ä¢ Filter.Tendsto f b (nhds a)","decl":"/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities\nhold everywhere. -/\ntheorem tendsto_of_tendsto_of_tendsto_of_le_of_le [OrderTopology Œ±] {f g h : Œ≤ ‚Üí Œ±} {b : Filter Œ≤}\n    {a : Œ±} (hg : Tendsto g b (ùìù a)) (hh : Tendsto h b (ùìù a)) (hgf : g ‚â§ f) (hfh : f ‚â§ h) :\n    Tendsto f b (ùìù a) :=\n  tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh (Eventually.of_forall hgf)\n    (Eventually.of_forall hfh)\n\n"}
{"name":"nhds_order_unbounded","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nhu : Exists fun u => LT.lt a u\nhl : Exists fun l => LT.lt l a\n‚ä¢ Eq (nhds a) (iInf fun l => iInf fun x => iInf fun u => iInf fun x => Filter.principal (Set.Ioo l u))","decl":"theorem nhds_order_unbounded [OrderTopology Œ±] {a : Œ±} (hu : ‚àÉ u, a < u) (hl : ‚àÉ l, l < a) :\n    ùìù a = ‚®Ö (l) (_ : l < a) (u) (_ : a < u), ùìü (Ioo l u) := by\n  simp only [nhds_eq_order, ‚Üê inf_biInf, ‚Üê biInf_inf, *, ‚Üê inf_principal, ‚Üê Ioi_inter_Iio]; rfl\n\n"}
{"name":"tendsto_order_unbounded","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\nf : Œ≤ ‚Üí Œ±\na : Œ±\nx : Filter Œ≤\nhu : Exists fun u => LT.lt a u\nhl : Exists fun l => LT.lt l a\nh : ‚àÄ (l u : Œ±), LT.lt l a ‚Üí LT.lt a u ‚Üí Filter.Eventually (fun b => And (LT.lt l (f b)) (LT.lt (f b) u)) x\n‚ä¢ Filter.Tendsto f x (nhds a)","decl":"theorem tendsto_order_unbounded [OrderTopology Œ±] {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : Filter Œ≤}\n    (hu : ‚àÉ u, a < u) (hl : ‚àÉ l, l < a) (h : ‚àÄ l u, l < a ‚Üí a < u ‚Üí ‚àÄ·∂† b in x, l < f b ‚àß f b < u) :\n    Tendsto f x (ùìù a) := by\n  simp only [nhds_order_unbounded hu hl, tendsto_iInf, tendsto_principal]\n  exact fun l hl u => h l u hl\n\n"}
{"name":"tendstoIxxNhdsWithin","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ±\na : Œ±\ns t : Set Œ±\nIxx : Œ± ‚Üí Œ± ‚Üí Set Œ±\ninst‚úù¬π : Filter.TendstoIxxClass Ixx (nhds a) (nhds a)\ninst‚úù : Filter.TendstoIxxClass Ixx (Filter.principal s) (Filter.principal t)\n‚ä¢ Filter.TendstoIxxClass Ixx (nhdsWithin a s) (nhdsWithin a t)","decl":"instance tendstoIxxNhdsWithin {Œ± : Type*} [TopologicalSpace Œ±] (a : Œ±) {s t : Set Œ±}\n    {Ixx} [TendstoIxxClass Ixx (ùìù a) (ùìù a)] [TendstoIxxClass Ixx (ùìü s) (ùìü t)] :\n    TendstoIxxClass Ixx (ùìù[s] a) (ùìù[t] a) :=\n  Filter.tendstoIxxClass_inf\n\n"}
{"name":"tendstoIccClassNhdsPi","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œπ : Type u_1\nŒ± : Œπ ‚Üí Type u_2\ninst‚úù¬≤ : (i : Œπ) ‚Üí Preorder (Œ± i)\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (Œ± i)\ninst‚úù : ‚àÄ (i : Œπ), OrderTopology (Œ± i)\nf : (i : Œπ) ‚Üí Œ± i\n‚ä¢ Filter.TendstoIxxClass Set.Icc (nhds f) (nhds f)","decl":"instance tendstoIccClassNhdsPi {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} [‚àÄ i, Preorder (Œ± i)]\n    [‚àÄ i, TopologicalSpace (Œ± i)] [‚àÄ i, OrderTopology (Œ± i)] (f : ‚àÄ i, Œ± i) :\n    TendstoIxxClass Icc (ùìù f) (ùìù f) := by\n  constructor\n  conv in (ùìù f).smallSets => rw [nhds_pi, Filter.pi]\n  simp only [smallSets_iInf, smallSets_comap_eq_comap_image, tendsto_iInf, tendsto_comap_iff]\n  intro i\n  have : Tendsto (fun g : ‚àÄ i, Œ± i => g i) (ùìù f) (ùìù (f i)) := (continuous_apply i).tendsto f\n  refine (this.comp tendsto_fst).Icc (this.comp tendsto_snd) |>.smallSets_mono ?_\n  filter_upwards [] using fun ‚ü®f, g‚ü© ‚Ü¶ image_subset_iff.mpr fun p hp ‚Ü¶ ‚ü®hp.1 i, hp.2 i‚ü©\n\n"}
{"name":"induced_topology_le_preorder","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : OrderTopology Œ≤\nf : Œ± ‚Üí Œ≤\nhf : ‚àÄ {x y : Œ±}, Iff (LT.lt (f x) (f y)) (LT.lt x y)\n‚ä¢ LE.le (TopologicalSpace.induced f inst‚úù¬π) (Preorder.topology Œ±)","decl":"theorem induced_topology_le_preorder [Preorder Œ±] [Preorder Œ≤] [TopologicalSpace Œ≤]\n    [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y) :\n    induced f ‚ÄπTopologicalSpace Œ≤‚Ä∫ ‚â§ Preorder.topology Œ± := by\n  let _ := Preorder.topology Œ±; have : OrderTopology Œ± := ‚ü®rfl‚ü©\n  refine le_of_nhds_le_nhds fun x => ?_\n  simp only [nhds_eq_order, nhds_induced, comap_inf, comap_iInf, comap_principal, Ioi, Iio, ‚Üê hf]\n  refine inf_le_inf (le_iInf‚ÇÇ fun a ha => ?_) (le_iInf‚ÇÇ fun a ha => ?_)\n  exacts [iInf‚ÇÇ_le (f a) ha, iInf‚ÇÇ_le (f a) ha]\n\n"}
{"name":"induced_topology_eq_preorder","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : OrderTopology Œ≤\nf : Œ± ‚Üí Œ≤\nhf : ‚àÄ {x y : Œ±}, Iff (LT.lt (f x) (f y)) (LT.lt x y)\nH‚ÇÅ : ‚àÄ {a : Œ±} {b : Œ≤} {x : Œ±}, LT.lt b (f a) ‚Üí Not (LT.lt b (f x)) ‚Üí Exists fun y => And (LT.lt y a) (LE.le b (f y))\nH‚ÇÇ : ‚àÄ {a : Œ±} {b : Œ≤} {x : Œ±}, LT.lt (f a) b ‚Üí Not (LT.lt (f x) b) ‚Üí Exists fun y => And (LT.lt a y) (LE.le (f y) b)\n‚ä¢ Eq (TopologicalSpace.induced f inst‚úù¬π) (Preorder.topology Œ±)","decl":"theorem induced_topology_eq_preorder [Preorder Œ±] [Preorder Œ≤] [TopologicalSpace Œ≤]\n    [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤} (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)\n    (H‚ÇÅ : ‚àÄ {a b x}, b < f a ‚Üí ¬¨(b < f x) ‚Üí ‚àÉ y, y < a ‚àß b ‚â§ f y)\n    (H‚ÇÇ : ‚àÄ {a b x}, f a < b ‚Üí ¬¨(f x < b) ‚Üí ‚àÉ y, a < y ‚àß f y ‚â§ b) :\n    induced f ‚ÄπTopologicalSpace Œ≤‚Ä∫ = Preorder.topology Œ± := by\n  let _ := Preorder.topology Œ±; have : OrderTopology Œ± := ‚ü®rfl‚ü©\n  refine le_antisymm (induced_topology_le_preorder hf) ?_\n  refine le_of_nhds_le_nhds fun a => ?_\n  simp only [nhds_eq_order, nhds_induced, comap_inf, comap_iInf, comap_principal]\n  refine inf_le_inf (le_iInf‚ÇÇ fun b hb => ?_) (le_iInf‚ÇÇ fun b hb => ?_)\n  ¬∑ rcases em (‚àÉ x, ¬¨(b < f x)) with (‚ü®x, hx‚ü© | hb)\n    ¬∑ rcases H‚ÇÅ hb hx with ‚ü®y, hya, hyb‚ü©\n      exact iInf‚ÇÇ_le_of_le y hya (principal_mono.2 fun z hz => hyb.trans_lt (hf.2 hz))\n    ¬∑ push_neg at hb\n      exact le_principal_iff.2 (univ_mem' hb)\n  ¬∑ rcases em (‚àÉ x, ¬¨(f x < b)) with (‚ü®x, hx‚ü© | hb)\n    ¬∑ rcases H‚ÇÇ hb hx with ‚ü®y, hya, hyb‚ü©\n      exact iInf‚ÇÇ_le_of_le y hya (principal_mono.2 fun z hz => (hf.2 hz).trans_le hyb)\n    ¬∑ push_neg at hb\n      exact le_principal_iff.2 (univ_mem' hb)\n\n"}
{"name":"induced_orderTopology'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : Preorder Œ±\nta : TopologicalSpace Œ≤\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : OrderTopology Œ≤\nf : Œ± ‚Üí Œ≤\nhf : ‚àÄ {x y : Œ±}, Iff (LT.lt (f x) (f y)) (LT.lt x y)\nH‚ÇÅ : ‚àÄ {a : Œ±} {x : Œ≤}, LT.lt x (f a) ‚Üí Exists fun b => And (LT.lt b a) (LE.le x (f b))\nH‚ÇÇ : ‚àÄ {a : Œ±} {x : Œ≤}, LT.lt (f a) x ‚Üí Exists fun b => And (GT.gt b a) (LE.le (f b) x)\n‚ä¢ OrderTopology Œ±","decl":"theorem induced_orderTopology' {Œ± : Type u} {Œ≤ : Type v} [Preorder Œ±] [ta : TopologicalSpace Œ≤]\n    [Preorder Œ≤] [OrderTopology Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)\n    (H‚ÇÅ : ‚àÄ {a x}, x < f a ‚Üí ‚àÉ b < a, x ‚â§ f b) (H‚ÇÇ : ‚àÄ {a x}, f a < x ‚Üí ‚àÉ b > a, f b ‚â§ x) :\n    @OrderTopology _ (induced f ta) _ :=\n  let _ := induced f ta\n  ‚ü®induced_topology_eq_preorder hf (fun h _ => H‚ÇÅ h) (fun h _ => H‚ÇÇ h)‚ü©\n\n"}
{"name":"induced_orderTopology","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : Preorder Œ±\nta : TopologicalSpace Œ≤\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : OrderTopology Œ≤\nf : Œ± ‚Üí Œ≤\nhf : ‚àÄ {x y : Œ±}, Iff (LT.lt (f x) (f y)) (LT.lt x y)\nH : ‚àÄ {x y : Œ≤}, LT.lt x y ‚Üí Exists fun a => And (LT.lt x (f a)) (LT.lt (f a) y)\n‚ä¢ OrderTopology Œ±","decl":"theorem induced_orderTopology {Œ± : Type u} {Œ≤ : Type v} [Preorder Œ±] [ta : TopologicalSpace Œ≤]\n    [Preorder Œ≤] [OrderTopology Œ≤] (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)\n    (H : ‚àÄ {x y}, x < y ‚Üí ‚àÉ a, x < f a ‚àß f a < y) : @OrderTopology _ (induced f ta) _ :=\n  induced_orderTopology' f (hf)\n    (fun xa => let ‚ü®b, xb, ba‚ü© := H xa; ‚ü®b, hf.1 ba, le_of_lt xb‚ü©)\n    fun ax => let ‚ü®b, ab, bx‚ü© := H ax; ‚ü®b, hf.1 ab, le_of_lt bx‚ü©\n\n"}
{"name":"StrictMono.induced_topology_eq_preorder","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : LinearOrder Œ≤\nt : TopologicalSpace Œ≤\ninst‚úù : OrderTopology Œ≤\nf : Œ± ‚Üí Œ≤\nhf : StrictMono f\nhc : (Set.range f).OrdConnected\n‚ä¢ Eq (TopologicalSpace.induced f t) (Preorder.topology Œ±)","decl":"/-- The topology induced by a strictly monotone function with order-connected range is the preorder\ntopology. -/\nnonrec theorem StrictMono.induced_topology_eq_preorder {Œ± Œ≤ : Type*} [LinearOrder Œ±]\n    [LinearOrder Œ≤] [t : TopologicalSpace Œ≤] [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤}\n    (hf : StrictMono f) (hc : OrdConnected (range f)) : t.induced f = Preorder.topology Œ± := by\n  refine induced_topology_eq_preorder hf.lt_iff_lt (fun h‚ÇÅ h‚ÇÇ => ?_) fun h‚ÇÅ h‚ÇÇ => ?_\n  ¬∑ rcases hc.out (mem_range_self _) (mem_range_self _) ‚ü®not_lt.1 h‚ÇÇ, h‚ÇÅ.le‚ü© with ‚ü®y, rfl‚ü©\n    exact ‚ü®y, hf.lt_iff_lt.1 h‚ÇÅ, le_rfl‚ü©\n  ¬∑ rcases hc.out (mem_range_self _) (mem_range_self _) ‚ü®h‚ÇÅ.le, not_lt.1 h‚ÇÇ‚ü© with ‚ü®y, rfl‚ü©\n    exact ‚ü®y, hf.lt_iff_lt.1 h‚ÇÅ, le_rfl‚ü©\n\n"}
{"name":"StrictMono.isEmbedding_of_ordConnected","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : LinearOrder Œ≤\ninst‚úù¬≤ : TopologicalSpace Œ±\nh : OrderTopology Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : OrderTopology Œ≤\nf : Œ± ‚Üí Œ≤\nhf : StrictMono f\nhc : (Set.range f).OrdConnected\n‚ä¢ Topology.IsEmbedding f","decl":"/-- A strictly monotone function between linear orders with order topology is a topological\nembedding provided that the range of `f` is order-connected. -/\ntheorem StrictMono.isEmbedding_of_ordConnected {Œ± Œ≤ : Type*} [LinearOrder Œ±] [LinearOrder Œ≤]\n    [TopologicalSpace Œ±] [h : OrderTopology Œ±] [TopologicalSpace Œ≤] [OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤}\n    (hf : StrictMono f) (hc : OrdConnected (range f)) : IsEmbedding f :=\n  ‚ü®‚ü®h.1.trans <| Eq.symm <| hf.induced_topology_eq_preorder hc‚ü©, hf.injective‚ü©\n\n"}
{"name":"StrictMono.embedding_of_ordConnected","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : LinearOrder Œ≤\ninst‚úù¬≤ : TopologicalSpace Œ±\nh : OrderTopology Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : OrderTopology Œ≤\nf : Œ± ‚Üí Œ≤\nhf : StrictMono f\nhc : (Set.range f).OrdConnected\n‚ä¢ Topology.IsEmbedding f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias StrictMono.embedding_of_ordConnected := StrictMono.isEmbedding_of_ordConnected\n\n"}
{"name":"orderTopology_of_ordConnected","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\nt : Set Œ±\nht : t.OrdConnected\n‚ä¢ OrderTopology ‚Üët","decl":"/-- On a `Set.OrdConnected` subset of a linear order, the order topology for the restriction of the\norder is the same as the restriction to the subset of the order topology. -/\ninstance orderTopology_of_ordConnected {Œ± : Type u} [TopologicalSpace Œ±] [LinearOrder Œ±]\n    [OrderTopology Œ±] {t : Set Œ±} [ht : OrdConnected t] : OrderTopology t :=\n  ‚ü®(Subtype.strictMono_coe t).induced_topology_eq_preorder <| by\n    rwa [‚Üê @Subtype.range_val _ t] at ht‚ü©\n\n"}
{"name":"nhdsGE_eq_iInf_inf_principal","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Eq (nhdsWithin a (Set.Ici a)) (Min.min (iInf fun u => iInf fun x => Filter.principal (Set.Iio u)) (Filter.principal (Set.Ici a)))","decl":"theorem nhdsGE_eq_iInf_inf_principal [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] (a : Œ±) :\n    ùìù[‚â•] a = (‚®Ö (u) (_ : a < u), ùìü (Iio u)) ‚äì ùìü (Ici a) := by\n  rw [nhdsWithin, nhds_eq_order]\n  refine le_antisymm (inf_le_inf_right _ inf_le_right) (le_inf (le_inf ?_ inf_le_left) inf_le_right)\n  exact inf_le_right.trans (le_iInf‚ÇÇ fun l hl => principal_mono.2 <| Ici_subset_Ioi.2 hl)\n\n"}
{"name":"nhdsWithin_Ici_eq''","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Eq (nhdsWithin a (Set.Ici a)) (Min.min (iInf fun u => iInf fun x => Filter.principal (Set.Iio u)) (Filter.principal (Set.Ici a)))","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ici_eq'' := nhdsGE_eq_iInf_inf_principal\n\n"}
{"name":"nhdsLE_eq_iInf_inf_principal","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Eq (nhdsWithin a (Set.Iic a)) (Min.min (iInf fun l => iInf fun h => Filter.principal (Set.Ioi l)) (Filter.principal (Set.Iic a)))","decl":"theorem nhdsLE_eq_iInf_inf_principal [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] (a : Œ±) :\n    ùìù[‚â§] a = (‚®Ö l < a, ùìü (Ioi l)) ‚äì ùìü (Iic a) :=\n  nhdsGE_eq_iInf_inf_principal (toDual a)\n\n"}
{"name":"nhdsWithin_Iic_eq''","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\n‚ä¢ Eq (nhdsWithin a (Set.Iic a)) (Min.min (iInf fun l => iInf fun h => Filter.principal (Set.Ioi l)) (Filter.principal (Set.Iic a)))","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Iic_eq'' := nhdsLE_eq_iInf_inf_principal\n\n"}
{"name":"nhdsGE_eq_iInf_principal","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nha : Exists fun u => LT.lt a u\n‚ä¢ Eq (nhdsWithin a (Set.Ici a)) (iInf fun u => iInf fun x => Filter.principal (Set.Ico a u))","decl":"theorem nhdsGE_eq_iInf_principal [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] {a : Œ±}\n    (ha : ‚àÉ u, a < u) : ùìù[‚â•] a = ‚®Ö (u) (_ : a < u), ùìü (Ico a u) := by\n  simp only [nhdsGE_eq_iInf_inf_principal, biInf_inf ha, inf_principal, Iio_inter_Ici]\n\n"}
{"name":"nhdsWithin_Ici_eq'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nha : Exists fun u => LT.lt a u\n‚ä¢ Eq (nhdsWithin a (Set.Ici a)) (iInf fun u => iInf fun x => Filter.principal (Set.Ico a u))","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ici_eq' := nhdsGE_eq_iInf_principal\n\n"}
{"name":"nhdsLE_eq_iInf_principal","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nha : Exists fun l => LT.lt l a\n‚ä¢ Eq (nhdsWithin a (Set.Iic a)) (iInf fun l => iInf fun h => Filter.principal (Set.Ioc l a))","decl":"theorem nhdsLE_eq_iInf_principal [TopologicalSpace Œ±] [Preorder Œ±] [OrderTopology Œ±] {a : Œ±}\n    (ha : ‚àÉ l, l < a) : ùìù[‚â§] a = ‚®Ö l < a, ùìü (Ioc l a) := by\n  simp only [nhdsLE_eq_iInf_inf_principal, biInf_inf ha, inf_principal, Ioi_inter_Iic]\n\n"}
{"name":"nhdsWithin_Iic_eq'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nha : Exists fun l => LT.lt l a\n‚ä¢ Eq (nhdsWithin a (Set.Iic a)) (iInf fun l => iInf fun h => Filter.principal (Set.Ioc l a))","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Iic_eq' := nhdsLE_eq_iInf_principal\n\n"}
{"name":"nhdsGE_basis_of_exists_gt","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nha : Exists fun u => LT.lt a u\n‚ä¢ (nhdsWithin a (Set.Ici a)).HasBasis (fun u => LT.lt a u) fun u => Set.Ico a u","decl":"theorem nhdsGE_basis_of_exists_gt [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] {a : Œ±}\n    (ha : ‚àÉ u, a < u) : (ùìù[‚â•] a).HasBasis (fun u => a < u) fun u => Ico a u :=\n  (nhdsGE_eq_iInf_principal ha).symm ‚ñ∏\n    hasBasis_biInf_principal\n      (fun b hb c hc => ‚ü®min b c, lt_min hb hc, Ico_subset_Ico_right (min_le_left _ _),\n        Ico_subset_Ico_right (min_le_right _ _)‚ü©)\n      ha\n\n"}
{"name":"nhdsWithin_Ici_basis'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nha : Exists fun u => LT.lt a u\n‚ä¢ (nhdsWithin a (Set.Ici a)).HasBasis (fun u => LT.lt a u) fun u => Set.Ico a u","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ici_basis' := nhdsGE_basis_of_exists_gt\n\n"}
{"name":"nhdsLE_basis_of_exists_lt","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nha : Exists fun l => LT.lt l a\n‚ä¢ (nhdsWithin a (Set.Iic a)).HasBasis (fun l => LT.lt l a) fun l => Set.Ioc l a","decl":"theorem nhdsLE_basis_of_exists_lt [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] {a : Œ±}\n    (ha : ‚àÉ l, l < a) : (ùìù[‚â§] a).HasBasis (fun l => l < a) fun l => Ioc l a := by\n  convert nhdsGE_basis_of_exists_gt (Œ± := Œ±·µí·µà) ha using 2\n  exact dual_Ico.symm\n\n"}
{"name":"nhdsWithin_Iic_basis'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nha : Exists fun l => LT.lt l a\n‚ä¢ (nhdsWithin a (Set.Iic a)).HasBasis (fun l => LT.lt l a) fun l => Set.Ioc l a","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Iic_basis' := nhdsLE_basis_of_exists_lt\n\n"}
{"name":"nhdsGE_basis","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Ici a)).HasBasis (fun u => LT.lt a u) fun u => Set.Ico a u","decl":"theorem nhdsGE_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [NoMaxOrder Œ±] (a : Œ±) :\n    (ùìù[‚â•] a).HasBasis (fun u => a < u) fun u => Ico a u :=\n  nhdsGE_basis_of_exists_gt (exists_gt a)\n\n"}
{"name":"nhdsWithin_Ici_basis","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMaxOrder Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Ici a)).HasBasis (fun u => LT.lt a u) fun u => Set.Ico a u","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Ici_basis := nhdsGE_basis\n\n"}
{"name":"nhdsLE_basis","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMinOrder Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Iic a)).HasBasis (fun l => LT.lt l a) fun l => Set.Ioc l a","decl":"theorem nhdsLE_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTopology Œ±] [NoMinOrder Œ±] (a : Œ±) :\n    (ùìù[‚â§] a).HasBasis (fun l => l < a) fun l => Ioc l a :=\n  nhdsLE_basis_of_exists_lt (exists_lt a)\n\n"}
{"name":"nhdsWithin_Iic_basis","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : NoMinOrder Œ±\na : Œ±\n‚ä¢ (nhdsWithin a (Set.Iic a)).HasBasis (fun l => LT.lt l a) fun l => Set.Ioc l a","decl":"@[deprecated (since := \"2024-12-22\")] alias nhdsWithin_Iic_basis := nhdsLE_basis\n\n"}
{"name":"nhds_top_order","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : OrderTop Œ±\ninst‚úù : OrderTopology Œ±\n‚ä¢ Eq (nhds Top.top) (iInf fun l => iInf fun x => Filter.principal (Set.Ioi l))","decl":"theorem nhds_top_order [TopologicalSpace Œ±] [Preorder Œ±] [OrderTop Œ±] [OrderTopology Œ±] :\n    ùìù (‚ä§ : Œ±) = ‚®Ö (l) (_ : l < ‚ä§), ùìü (Ioi l) := by simp [nhds_eq_order (‚ä§ : Œ±)]\n\n"}
{"name":"nhds_bot_order","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : OrderBot Œ±\ninst‚úù : OrderTopology Œ±\n‚ä¢ Eq (nhds Bot.bot) (iInf fun l => iInf fun x => Filter.principal (Set.Iio l))","decl":"theorem nhds_bot_order [TopologicalSpace Œ±] [Preorder Œ±] [OrderBot Œ±] [OrderTopology Œ±] :\n    ùìù (‚ä• : Œ±) = ‚®Ö (l) (_ : ‚ä• < l), ùìü (Iio l) := by simp [nhds_eq_order (‚ä• : Œ±)]\n\n"}
{"name":"nhds_top_basis","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTop Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : Nontrivial Œ±\n‚ä¢ (nhds Top.top).HasBasis (fun a => LT.lt a Top.top) fun a => Set.Ioi a","decl":"theorem nhds_top_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTop Œ±] [OrderTopology Œ±]\n    [Nontrivial Œ±] : (ùìù ‚ä§).HasBasis (fun a : Œ± => a < ‚ä§) fun a : Œ± => Ioi a := by\n  have : ‚àÉ x : Œ±, x < ‚ä§ := (exists_ne ‚ä§).imp fun x hx => hx.lt_top\n  simpa only [Iic_top, nhdsWithin_univ, Ioc_top] using nhdsLE_basis_of_exists_lt this\n\n"}
{"name":"nhds_bot_basis","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderBot Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : Nontrivial Œ±\n‚ä¢ (nhds Bot.bot).HasBasis (fun a => LT.lt Bot.bot a) fun a => Set.Iio a","decl":"theorem nhds_bot_basis [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderBot Œ±] [OrderTopology Œ±]\n    [Nontrivial Œ±] : (ùìù ‚ä•).HasBasis (fun a : Œ± => ‚ä• < a) fun a : Œ± => Iio a :=\n  nhds_top_basis (Œ± := Œ±·µí·µà)\n\n"}
{"name":"nhds_top_basis_Ici","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Åµ : TopologicalSpace Œ±\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : OrderTop Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : Nontrivial Œ±\ninst‚úù : DenselyOrdered Œ±\n‚ä¢ (nhds Top.top).HasBasis (fun a => LT.lt a Top.top) Set.Ici","decl":"theorem nhds_top_basis_Ici [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderTop Œ±] [OrderTopology Œ±]\n    [Nontrivial Œ±] [DenselyOrdered Œ±] : (ùìù ‚ä§).HasBasis (fun a : Œ± => a < ‚ä§) Ici :=\n  nhds_top_basis.to_hasBasis\n    (fun _a ha => let ‚ü®b, hab, hb‚ü© := exists_between ha; ‚ü®b, hb, Ici_subset_Ioi.mpr hab‚ü©)\n    fun a ha => ‚ü®a, ha, Ioi_subset_Ici_self‚ü©\n\n"}
{"name":"nhds_bot_basis_Iic","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Åµ : TopologicalSpace Œ±\ninst‚úù‚Å¥ : LinearOrder Œ±\ninst‚úù¬≥ : OrderBot Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : Nontrivial Œ±\ninst‚úù : DenselyOrdered Œ±\n‚ä¢ (nhds Bot.bot).HasBasis (fun a => LT.lt Bot.bot a) Set.Iic","decl":"theorem nhds_bot_basis_Iic [TopologicalSpace Œ±] [LinearOrder Œ±] [OrderBot Œ±] [OrderTopology Œ±]\n    [Nontrivial Œ±] [DenselyOrdered Œ±] : (ùìù ‚ä•).HasBasis (fun a : Œ± => ‚ä• < a) Iic :=\n  nhds_top_basis_Ici (Œ± := Œ±·µí·µà)\n\n"}
{"name":"tendsto_nhds_top_mono","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : OrderTop Œ≤\ninst‚úù : OrderTopology Œ≤\nl : Filter Œ±\nf g : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f l (nhds Top.top)\nhg : l.EventuallyLE f g\n‚ä¢ Filter.Tendsto g l (nhds Top.top)","decl":"theorem tendsto_nhds_top_mono [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderTop Œ≤] [OrderTopology Œ≤]\n    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä§)) (hg : f ‚â§·∂†[l] g) : Tendsto g l (ùìù ‚ä§) := by\n  simp only [nhds_top_order, tendsto_iInf, tendsto_principal] at hf ‚ä¢\n  intro x hx\n  filter_upwards [hf x hx, hg] with _ using lt_of_lt_of_le\n\n"}
{"name":"tendsto_nhds_bot_mono","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : OrderBot Œ≤\ninst‚úù : OrderTopology Œ≤\nl : Filter Œ±\nf g : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f l (nhds Bot.bot)\nhg : l.EventuallyLE g f\n‚ä¢ Filter.Tendsto g l (nhds Bot.bot)","decl":"theorem tendsto_nhds_bot_mono [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderBot Œ≤] [OrderTopology Œ≤]\n    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä•)) (hg : g ‚â§·∂†[l] f) : Tendsto g l (ùìù ‚ä•) :=\n  tendsto_nhds_top_mono (Œ≤ := Œ≤·µí·µà) hf hg\n\n"}
{"name":"tendsto_nhds_top_mono'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : OrderTop Œ≤\ninst‚úù : OrderTopology Œ≤\nl : Filter Œ±\nf g : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f l (nhds Top.top)\nhg : LE.le f g\n‚ä¢ Filter.Tendsto g l (nhds Top.top)","decl":"theorem tendsto_nhds_top_mono' [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderTop Œ≤] [OrderTopology Œ≤]\n    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä§)) (hg : f ‚â§ g) : Tendsto g l (ùìù ‚ä§) :=\n  tendsto_nhds_top_mono hf (Eventually.of_forall hg)\n\n"}
{"name":"tendsto_nhds_bot_mono'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : TopologicalSpace Œ≤\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : OrderBot Œ≤\ninst‚úù : OrderTopology Œ≤\nl : Filter Œ±\nf g : Œ± ‚Üí Œ≤\nhf : Filter.Tendsto f l (nhds Bot.bot)\nhg : LE.le g f\n‚ä¢ Filter.Tendsto g l (nhds Bot.bot)","decl":"theorem tendsto_nhds_bot_mono' [TopologicalSpace Œ≤] [Preorder Œ≤] [OrderBot Œ≤] [OrderTopology Œ≤]\n    {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : Tendsto f l (ùìù ‚ä•)) (hg : g ‚â§ f) : Tendsto g l (ùìù ‚ä•) :=\n  tendsto_nhds_bot_mono hf (Eventually.of_forall hg)\n\n"}
{"name":"order_separated","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na‚ÇÅ a‚ÇÇ : Œ±\nh : LT.lt a‚ÇÅ a‚ÇÇ\n‚ä¢ Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u a‚ÇÅ) (And (Membership.mem v a‚ÇÇ) (‚àÄ (b‚ÇÅ : Œ±), Membership.mem u b‚ÇÅ ‚Üí ‚àÄ (b‚ÇÇ : Œ±), Membership.mem v b‚ÇÇ ‚Üí LT.lt b‚ÇÅ b‚ÇÇ))))","decl":"theorem order_separated [OrderTopology Œ±] {a‚ÇÅ a‚ÇÇ : Œ±} (h : a‚ÇÅ < a‚ÇÇ) :\n    ‚àÉ u v : Set Œ±, IsOpen u ‚àß IsOpen v ‚àß a‚ÇÅ ‚àà u ‚àß a‚ÇÇ ‚àà v ‚àß ‚àÄ b‚ÇÅ ‚àà u, ‚àÄ b‚ÇÇ ‚àà v, b‚ÇÅ < b‚ÇÇ :=\n  let ‚ü®x, hx, y, hy, h‚ü© := h.exists_disjoint_Iio_Ioi\n  ‚ü®Iio x, Ioi y, isOpen_gt' _, isOpen_lt' _, hx, hy, h‚ü©\n\n-- see Note [lower instance priority]\n"}
{"name":"OrderTopology.to_orderClosedTopology","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\n‚ä¢ OrderClosedTopology Œ±","decl":"instance (priority := 100) OrderTopology.to_orderClosedTopology [OrderTopology Œ±] :\n    OrderClosedTopology Œ± where\n  isClosed_le' := isOpen_compl_iff.1 <| isOpen_prod_iff.mpr fun a‚ÇÅ a‚ÇÇ (h : ¬¨a‚ÇÅ ‚â§ a‚ÇÇ) =>\n    have h : a‚ÇÇ < a‚ÇÅ := lt_of_not_ge h\n    let ‚ü®u, v, hu, hv, ha‚ÇÅ, ha‚ÇÇ, h‚ü© := order_separated h\n    ‚ü®v, u, hv, hu, ha‚ÇÇ, ha‚ÇÅ, fun ‚ü®b‚ÇÅ, b‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© => not_le_of_gt <| h b‚ÇÇ h‚ÇÇ b‚ÇÅ h‚ÇÅ‚ü©\n\n"}
{"name":"exists_Ioc_subset_of_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\ns : Set Œ±\nhs : Membership.mem (nhds a) s\nh : Exists fun l => LT.lt l a\n‚ä¢ Exists fun l => And (LT.lt l a) (HasSubset.Subset (Set.Ioc l a) s)","decl":"theorem exists_Ioc_subset_of_mem_nhds [OrderTopology Œ±] {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a)\n    (h : ‚àÉ l, l < a) : ‚àÉ l < a, Ioc l a ‚äÜ s :=\n  (nhdsLE_basis_of_exists_lt h).mem_iff.mp (nhdsWithin_le_nhds hs)\n\n"}
{"name":"exists_Ioc_subset_of_mem_nhds'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\ns : Set Œ±\nhs : Membership.mem (nhds a) s\nl : Œ±\nhl : LT.lt l a\n‚ä¢ Exists fun l' => And (Membership.mem (Set.Ico l a) l') (HasSubset.Subset (Set.Ioc l' a) s)","decl":"theorem exists_Ioc_subset_of_mem_nhds' [OrderTopology Œ±] {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) {l : Œ±}\n    (hl : l < a) : ‚àÉ l' ‚àà Ico l a, Ioc l' a ‚äÜ s :=\n  let ‚ü®l', hl'a, hl's‚ü© := exists_Ioc_subset_of_mem_nhds hs ‚ü®l, hl‚ü©\n  ‚ü®max l l', ‚ü®le_max_left _ _, max_lt hl hl'a‚ü©,\n    (Ioc_subset_Ioc_left <| le_max_right _ _).trans hl's‚ü©\n\n"}
{"name":"exists_Ico_subset_of_mem_nhds'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\ns : Set Œ±\nhs : Membership.mem (nhds a) s\nu : Œ±\nhu : LT.lt a u\n‚ä¢ Exists fun u' => And (Membership.mem (Set.Ioc a u) u') (HasSubset.Subset (Set.Ico a u') s)","decl":"theorem exists_Ico_subset_of_mem_nhds' [OrderTopology Œ±] {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) {u : Œ±}\n    (hu : a < u) : ‚àÉ u' ‚àà Ioc a u, Ico a u' ‚äÜ s := by\n  simpa only [OrderDual.exists, exists_prop, dual_Ico, dual_Ioc] using\n    exists_Ioc_subset_of_mem_nhds' (show ofDual ‚Åª¬π' s ‚àà ùìù (toDual a) from hs) hu.dual\n\n"}
{"name":"exists_Ico_subset_of_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\ns : Set Œ±\nhs : Membership.mem (nhds a) s\nh : Exists fun u => LT.lt a u\n‚ä¢ Exists fun u => And (LT.lt a u) (HasSubset.Subset (Set.Ico a u) s)","decl":"theorem exists_Ico_subset_of_mem_nhds [OrderTopology Œ±] {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a)\n    (h : ‚àÉ u, a < u) : ‚àÉ u, a < u ‚àß Ico a u ‚äÜ s :=\n  let ‚ü®_l', hl'‚ü© := h\n  let ‚ü®l, hl‚ü© := exists_Ico_subset_of_mem_nhds' hs hl'\n  ‚ü®l, hl.1.1, hl.2‚ü©\n\n"}
{"name":"exists_Icc_mem_subset_of_mem_nhdsGE","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\ns : Set Œ±\nhs : Membership.mem (nhdsWithin a (Set.Ici a)) s\n‚ä¢ Exists fun b => And (LE.le a b) (And (Membership.mem (nhdsWithin a (Set.Ici a)) (Set.Icc a b)) (HasSubset.Subset (Set.Icc a b) s))","decl":"theorem exists_Icc_mem_subset_of_mem_nhdsGE [OrderTopology Œ±] {a : Œ±} {s : Set Œ±}\n    (hs : s ‚àà ùìù[‚â•] a) : ‚àÉ b, a ‚â§ b ‚àß Icc a b ‚àà ùìù[‚â•] a ‚àß Icc a b ‚äÜ s := by\n  rcases (em (IsMax a)).imp_right not_isMax_iff.mp with (ha | ha)\n  ¬∑ use a\n    simpa [ha.Ici_eq] using hs\n  ¬∑ rcases(nhdsGE_basis_of_exists_gt ha).mem_iff.mp hs with ‚ü®b, hab, hbs‚ü©\n    rcases eq_empty_or_nonempty (Ioo a b) with (H | ‚ü®c, hac, hcb‚ü©)\n    ¬∑ have : Ico a b = Icc a a := by rw [‚Üê Icc_union_Ioo_eq_Ico le_rfl hab, H, union_empty]\n      exact ‚ü®a, le_rfl, this ‚ñ∏ ‚ü®Ico_mem_nhdsGE hab, hbs‚ü©‚ü©\n    ¬∑ refine ‚ü®c, hac.le, Icc_mem_nhdsGE hac, ?_‚ü©\n      exact (Icc_subset_Ico_right hcb).trans hbs\n\n"}
{"name":"exists_Icc_mem_subset_of_mem_nhdsWithin_Ici","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\ns : Set Œ±\nhs : Membership.mem (nhdsWithin a (Set.Ici a)) s\n‚ä¢ Exists fun b => And (LE.le a b) (And (Membership.mem (nhdsWithin a (Set.Ici a)) (Set.Icc a b)) (HasSubset.Subset (Set.Icc a b) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias exists_Icc_mem_subset_of_mem_nhdsWithin_Ici := exists_Icc_mem_subset_of_mem_nhdsGE\n\n"}
{"name":"exists_Icc_mem_subset_of_mem_nhdsLE","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\ns : Set Œ±\nhs : Membership.mem (nhdsWithin a (Set.Iic a)) s\n‚ä¢ Exists fun b => And (LE.le b a) (And (Membership.mem (nhdsWithin a (Set.Iic a)) (Set.Icc b a)) (HasSubset.Subset (Set.Icc b a) s))","decl":"theorem exists_Icc_mem_subset_of_mem_nhdsLE [OrderTopology Œ±] {a : Œ±} {s : Set Œ±}\n    (hs : s ‚àà ùìù[‚â§] a) : ‚àÉ b ‚â§ a, Icc b a ‚àà ùìù[‚â§] a ‚àß Icc b a ‚äÜ s := by\n  simpa only [dual_Icc, toDual.surjective.exists] using\n    exists_Icc_mem_subset_of_mem_nhdsGE (Œ± := Œ±·µí·µà) (a := toDual a) hs\n\n"}
{"name":"exists_Icc_mem_subset_of_mem_nhdsWithin_Iic","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\ns : Set Œ±\nhs : Membership.mem (nhdsWithin a (Set.Iic a)) s\n‚ä¢ Exists fun b => And (LE.le b a) (And (Membership.mem (nhdsWithin a (Set.Iic a)) (Set.Icc b a)) (HasSubset.Subset (Set.Icc b a) s))","decl":"@[deprecated (since := \"2024-12-22\")]\nalias exists_Icc_mem_subset_of_mem_nhdsWithin_Iic := exists_Icc_mem_subset_of_mem_nhdsLE\n\n"}
{"name":"exists_Icc_mem_subset_of_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\ns : Set Œ±\nhs : Membership.mem (nhds a) s\n‚ä¢ Exists fun b => Exists fun c => And (Membership.mem (Set.Icc b c) a) (And (Membership.mem (nhds a) (Set.Icc b c)) (HasSubset.Subset (Set.Icc b c) s))","decl":"theorem exists_Icc_mem_subset_of_mem_nhds [OrderTopology Œ±] {a : Œ±} {s : Set Œ±} (hs : s ‚àà ùìù a) :\n    ‚àÉ b c, a ‚àà Icc b c ‚àß Icc b c ‚àà ùìù a ‚àß Icc b c ‚äÜ s := by\n  rcases exists_Icc_mem_subset_of_mem_nhdsLE (nhdsWithin_le_nhds hs) with\n    ‚ü®b, hba, hb_nhds, hbs‚ü©\n  rcases exists_Icc_mem_subset_of_mem_nhdsGE (nhdsWithin_le_nhds hs) with\n    ‚ü®c, hac, hc_nhds, hcs‚ü©\n  refine ‚ü®b, c, ‚ü®hba, hac‚ü©, ?_‚ü©\n  rw [‚Üê Icc_union_Icc_eq_Icc hba hac, ‚Üê nhdsLE_sup_nhdsGE]\n  exact ‚ü®union_mem_sup hb_nhds hc_nhds, union_subset hbs hcs‚ü©\n\n"}
{"name":"IsOpen.exists_Ioo_subset","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : Nontrivial Œ±\ns : Set Œ±\nhs : IsOpen s\nh : s.Nonempty\n‚ä¢ Exists fun a => Exists fun b => And (LT.lt a b) (HasSubset.Subset (Set.Ioo a b) s)","decl":"theorem IsOpen.exists_Ioo_subset [OrderTopology Œ±] [Nontrivial Œ±] {s : Set Œ±} (hs : IsOpen s)\n    (h : s.Nonempty) : ‚àÉ a b, a < b ‚àß Ioo a b ‚äÜ s := by\n  obtain ‚ü®x, hx‚ü© : ‚àÉ x, x ‚àà s := h\n  obtain ‚ü®y, hy‚ü© : ‚àÉ y, y ‚â† x := exists_ne x\n  rcases lt_trichotomy x y with (H | rfl | H)\n  ¬∑ obtain ‚ü®u, xu, hu‚ü© : ‚àÉ u, x < u ‚àß Ico x u ‚äÜ s :=\n      exists_Ico_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©\n    exact ‚ü®x, u, xu, Ioo_subset_Ico_self.trans hu‚ü©\n  ¬∑ exact (hy rfl).elim\n  ¬∑ obtain ‚ü®l, lx, hl‚ü© : ‚àÉ l, l < x ‚àß Ioc l x ‚äÜ s :=\n      exists_Ioc_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©\n    exact ‚ü®l, x, lx, Ioo_subset_Ioc_self.trans hl‚ü©\n\n"}
{"name":"dense_of_exists_between","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : Nontrivial Œ±\ns : Set Œ±\nh : ‚àÄ ‚¶Éa b : Œ±‚¶Ñ, LT.lt a b ‚Üí Exists fun c => And (Membership.mem s c) (And (LT.lt a c) (LT.lt c b))\n‚ä¢ Dense s","decl":"theorem dense_of_exists_between [OrderTopology Œ±] [Nontrivial Œ±] {s : Set Œ±}\n    (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí ‚àÉ c ‚àà s, a < c ‚àß c < b) : Dense s := by\n  refine dense_iff_inter_open.2 fun U U_open U_nonempty => ?_\n  obtain ‚ü®a, b, hab, H‚ü© : ‚àÉ a b : Œ±, a < b ‚àß Ioo a b ‚äÜ U := U_open.exists_Ioo_subset U_nonempty\n  obtain ‚ü®x, xs, hx‚ü© : ‚àÉ x ‚àà s, a < x ‚àß x < b := h hab\n  exact ‚ü®x, ‚ü®H hx, xs‚ü©‚ü©\n\n"}
{"name":"dense_iff_exists_between","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : DenselyOrdered Œ±\ninst‚úù : Nontrivial Œ±\ns : Set Œ±\n‚ä¢ Iff (Dense s) (‚àÄ (a b : Œ±), LT.lt a b ‚Üí Exists fun c => And (Membership.mem s c) (And (LT.lt a c) (LT.lt c b)))","decl":"/-- A set in a nontrivial densely linear ordered type is dense in the sense of topology if and only\nif for any `a < b` there exists `c ‚àà s`, `a < c < b`. Each implication requires less typeclass\nassumptions. -/\ntheorem dense_iff_exists_between [OrderTopology Œ±] [DenselyOrdered Œ±] [Nontrivial Œ±] {s : Set Œ±} :\n    Dense s ‚Üî ‚àÄ a b, a < b ‚Üí ‚àÉ c ‚àà s, a < c ‚àß c < b :=\n  ‚ü®fun h _ _ hab => h.exists_between hab, dense_of_exists_between‚ü©\n\n"}
{"name":"mem_nhds_iff_exists_Ioo_subset'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\ns : Set Œ±\nhl : Exists fun l => LT.lt l a\nhu : Exists fun u => LT.lt a u\n‚ä¢ Iff (Membership.mem (nhds a) s) (Exists fun l => Exists fun u => And (Membership.mem (Set.Ioo l u) a) (HasSubset.Subset (Set.Ioo l u) s))","decl":"/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,\nprovided `a` is neither a bottom element nor a top element. -/\ntheorem mem_nhds_iff_exists_Ioo_subset' [OrderTopology Œ±] {a : Œ±} {s : Set Œ±} (hl : ‚àÉ l, l < a)\n    (hu : ‚àÉ u, a < u) : s ‚àà ùìù a ‚Üî ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s := by\n  constructor\n  ¬∑ intro h\n    rcases exists_Ico_subset_of_mem_nhds h hu with ‚ü®u, au, hu‚ü©\n    rcases exists_Ioc_subset_of_mem_nhds h hl with ‚ü®l, la, hl‚ü©\n    exact ‚ü®l, u, ‚ü®la, au‚ü©, Ioc_union_Ico_eq_Ioo la au ‚ñ∏ union_subset hl hu‚ü©\n  ¬∑ rintro ‚ü®l, u, ha, h‚ü©\n    apply mem_of_superset (Ioo_mem_nhds ha.1 ha.2) h\n\n"}
{"name":"mem_nhds_iff_exists_Ioo_subset","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMaxOrder Œ±\ninst‚úù : NoMinOrder Œ±\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhds a) s) (Exists fun l => Exists fun u => And (Membership.mem (Set.Ioo l u) a) (HasSubset.Subset (Set.Ioo l u) s))","decl":"/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.\n-/\ntheorem mem_nhds_iff_exists_Ioo_subset [OrderTopology Œ±] [NoMaxOrder Œ±] [NoMinOrder Œ±] {a : Œ±}\n    {s : Set Œ±} : s ‚àà ùìù a ‚Üî ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=\n  mem_nhds_iff_exists_Ioo_subset' (exists_lt a) (exists_gt a)\n\n"}
{"name":"nhds_basis_Ioo'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : OrderTopology Œ±\na : Œ±\nhl : Exists fun l => LT.lt l a\nhu : Exists fun u => LT.lt a u\n‚ä¢ (nhds a).HasBasis (fun b => And (LT.lt b.1 a) (LT.lt a b.2)) fun b => Set.Ioo b.1 b.2","decl":"theorem nhds_basis_Ioo' [OrderTopology Œ±] {a : Œ±} (hl : ‚àÉ l, l < a) (hu : ‚àÉ u, a < u) :\n    (ùìù a).HasBasis (fun b : Œ± √ó Œ± => b.1 < a ‚àß a < b.2) fun b => Ioo b.1 b.2 :=\n  ‚ü®fun s => (mem_nhds_iff_exists_Ioo_subset' hl hu).trans <| by simp‚ü©\n\n"}
{"name":"nhds_basis_Ioo","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMaxOrder Œ±\ninst‚úù : NoMinOrder Œ±\na : Œ±\n‚ä¢ (nhds a).HasBasis (fun b => And (LT.lt b.1 a) (LT.lt a b.2)) fun b => Set.Ioo b.1 b.2","decl":"theorem nhds_basis_Ioo [OrderTopology Œ±] [NoMaxOrder Œ±] [NoMinOrder Œ±] (a : Œ±) :\n    (ùìù a).HasBasis (fun b : Œ± √ó Œ± => b.1 < a ‚àß a < b.2) fun b => Ioo b.1 b.2 :=\n  nhds_basis_Ioo' (exists_lt a) (exists_gt a)\n\n"}
{"name":"Filter.Eventually.exists_Ioo_subset","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : NoMaxOrder Œ±\ninst‚úù : NoMinOrder Œ±\na : Œ±\np : Œ± ‚Üí Prop\nhp : Filter.Eventually (fun x => p x) (nhds a)\n‚ä¢ Exists fun l => Exists fun u => And (Membership.mem (Set.Ioo l u) a) (HasSubset.Subset (Set.Ioo l u) (setOf fun x => p x))","decl":"theorem Filter.Eventually.exists_Ioo_subset [OrderTopology Œ±] [NoMaxOrder Œ±] [NoMinOrder Œ±] {a : Œ±}\n    {p : Œ± ‚Üí Prop} (hp : ‚àÄ·∂† x in ùìù a, p x) : ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ { x | p x } :=\n  mem_nhds_iff_exists_Ioo_subset.1 hp\n\n"}
{"name":"Dense.topology_eq_generateFrom","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : DenselyOrdered Œ±\ns : Set Œ±\nhs : Dense s\n‚ä¢ Eq inst‚úù¬≥ (TopologicalSpace.generateFrom (Union.union (Set.image Set.Ioi s) (Set.image Set.Iio s)))","decl":"theorem Dense.topology_eq_generateFrom [OrderTopology Œ±] [DenselyOrdered Œ±] {s : Set Œ±}\n    (hs : Dense s) : ‚ÄπTopologicalSpace Œ±‚Ä∫ = .generateFrom (Ioi '' s ‚à™ Iio '' s) := by\n  refine (OrderTopology.topology_eq_generate_intervals (Œ± := Œ±)).trans ?_\n  refine le_antisymm (generateFrom_anti ?_) (le_generateFrom ?_)\n  ¬∑ simp only [union_subset_iff, image_subset_iff]\n    exact ‚ü®fun a _ ‚Ü¶ ‚ü®a, .inl rfl‚ü©, fun a _ ‚Ü¶ ‚ü®a, .inr rfl‚ü©‚ü©\n  ¬∑ rintro _ ‚ü®a, rfl | rfl‚ü©\n    ¬∑ rw [hs.Ioi_eq_biUnion]\n      let _ := generateFrom (Ioi '' s ‚à™ Iio '' s)\n      exact isOpen_iUnion fun x ‚Ü¶ isOpen_iUnion fun h ‚Ü¶ .basic _ <| .inl <| mem_image_of_mem _ h.1\n    ¬∑ rw [hs.Iio_eq_biUnion]\n      let _ := generateFrom (Ioi '' s ‚à™ Iio '' s)\n      exact isOpen_iUnion fun x ‚Ü¶ isOpen_iUnion fun h ‚Ü¶ .basic _ <| .inr <| mem_image_of_mem _ h.1\n\n"}
{"name":"SecondCountableTopology.of_separableSpace_orderTopology","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : DenselyOrdered Œ±\ninst‚úù : TopologicalSpace.SeparableSpace Œ±\n‚ä¢ SecondCountableTopology Œ±","decl":"/-- Let `Œ±` be a densely ordered linear order with order topology. If `Œ±` is a separable space, then\nit has second countable topology. Note that the \"densely ordered\" assumption cannot be dropped, see\n[double arrow space](https://topology.pi-base.org/spaces/S000093) for a counterexample. -/\ntheorem SecondCountableTopology.of_separableSpace_orderTopology [OrderTopology Œ±] [DenselyOrdered Œ±]\n    [SeparableSpace Œ±] : SecondCountableTopology Œ± := by\n  rcases exists_countable_dense Œ± with ‚ü®s, hc, hd‚ü©\n  refine ‚ü®‚ü®_, ?_, hd.topology_eq_generateFrom‚ü©‚ü©\n  exact (hc.image _).union (hc.image _)\n\n"}
{"name":"countable_setOf_covBy_right","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ (setOf fun x => Exists fun y => CovBy x y).Countable","decl":"/-- The set of points which are isolated on the right is countable when the space is\nsecond-countable. -/\ntheorem countable_setOf_covBy_right [OrderTopology Œ±] [SecondCountableTopology Œ±] :\n    Set.Countable { x : Œ± | ‚àÉ y, x ‚ãñ y } := by\n  nontriviality Œ±\n  let s := { x : Œ± | ‚àÉ y, x ‚ãñ y }\n  have : ‚àÄ x ‚àà s, ‚àÉ y, x ‚ãñ y := fun x => id\n  choose! y hy using this\n  have Hy : ‚àÄ x z, x ‚àà s ‚Üí z < y x ‚Üí z ‚â§ x := fun x z hx => (hy x hx).le_of_lt\n  suffices H : ‚àÄ a : Set Œ±, IsOpen a ‚Üí Set.Countable { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a } by\n    have : s ‚äÜ ‚ãÉ a ‚àà countableBasis Œ±, { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a } := fun x hx => by\n      rcases (isBasis_countableBasis Œ±).exists_mem_of_ne (hy x hx).ne with ‚ü®a, ab, xa, ya‚ü©\n      exact mem_iUnion‚ÇÇ.2 ‚ü®a, ab, hx, xa, ya‚ü©\n    refine Set.Countable.mono this ?_\n    refine Countable.biUnion (countable_countableBasis Œ±) fun a ha => H _ ?_\n    exact isOpen_of_mem_countableBasis ha\n  intro a ha\n  suffices H : Set.Countable { x | (x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a) ‚àß ¬¨IsBot x } from\n    H.of_diff (subsingleton_isBot Œ±).countable\n  simp only [and_assoc]\n  let t := { x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a ‚àß ¬¨IsBot x }\n  have : ‚àÄ x ‚àà t, ‚àÉ z < x, Ioc z x ‚äÜ a := by\n    intro x hx\n    apply exists_Ioc_subset_of_mem_nhds (ha.mem_nhds hx.2.1)\n    simpa only [IsBot, not_forall, not_le] using hx.right.right.right\n  choose! z hz h'z using this\n  have : PairwiseDisjoint t fun x => Ioc (z x) x := fun x xt x' x't hxx' => by\n    rcases hxx'.lt_or_lt with (h' | h')\n    ¬∑ refine disjoint_left.2 fun u ux ux' => xt.2.2.1 ?_\n      refine h'z x' x't ‚ü®ux'.1.trans_le (ux.2.trans (hy x xt.1).le), ?_‚ü©\n      by_contra! H\n      exact lt_irrefl _ ((Hy _ _ xt.1 H).trans_lt h')\n    ¬∑ refine disjoint_left.2 fun u ux ux' => x't.2.2.1 ?_\n      refine h'z x xt ‚ü®ux.1.trans_le (ux'.2.trans (hy x' x't.1).le), ?_‚ü©\n      by_contra! H\n      exact lt_irrefl _ ((Hy _ _ x't.1 H).trans_lt h')\n  refine this.countable_of_isOpen (fun x hx => ?_) fun x hx => ‚ü®x, hz x hx, le_rfl‚ü©\n  suffices H : Ioc (z x) x = Ioo (z x) (y x) by\n    rw [H]\n    exact isOpen_Ioo\n  exact Subset.antisymm (Ioc_subset_Ioo_right (hy x hx.1).lt) fun u hu => ‚ü®hu.1, Hy _ _ hx.1 hu.2‚ü©\n\n"}
{"name":"countable_setOf_covBy_left","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ (setOf fun x => Exists fun y => CovBy y x).Countable","decl":"/-- The set of points which are isolated on the left is countable when the space is\nsecond-countable. -/\ntheorem countable_setOf_covBy_left [OrderTopology Œ±] [SecondCountableTopology Œ±] :\n    Set.Countable { x : Œ± | ‚àÉ y, y ‚ãñ x } := by\n  convert countable_setOf_covBy_right (Œ± := Œ±·µí·µà) using 5\n  exact toDual_covBy_toDual_iff.symm\n\n"}
{"name":"countable_of_isolated_left'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ (setOf fun x => Exists fun y => And (LT.lt y x) (Eq (Set.Ioo y x) EmptyCollection.emptyCollection)).Countable","decl":"/-- The set of points which are isolated on the left is countable when the space is\nsecond-countable. -/\ntheorem countable_of_isolated_left' [OrderTopology Œ±] [SecondCountableTopology Œ±] :\n    Set.Countable { x : Œ± | ‚àÉ y, y < x ‚àß Ioo y x = ‚àÖ } := by\n  simpa only [‚Üê covBy_iff_Ioo_eq] using countable_setOf_covBy_left\n\n"}
{"name":"Set.PairwiseDisjoint.countable_of_Ioo","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : SecondCountableTopology Œ±\ny : Œ± ‚Üí Œ±\ns : Set Œ±\nh : s.PairwiseDisjoint fun x => Set.Ioo x (y x)\nh' : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí LT.lt x (y x)\n‚ä¢ s.Countable","decl":"/-- Consider a disjoint family of intervals `(x, y)` with `x < y` in a second-countable space.\nThen the family is countable.\nThis is not a straightforward consequence of second-countability as some of these intervals might be\nempty (but in fact this can happen only for countably many of them). -/\ntheorem Set.PairwiseDisjoint.countable_of_Ioo [OrderTopology Œ±] [SecondCountableTopology Œ±]\n    {y : Œ± ‚Üí Œ±} {s : Set Œ±} (h : PairwiseDisjoint s fun x => Ioo x (y x))\n    (h' : ‚àÄ x ‚àà s, x < y x) : s.Countable :=\n  have : (s \\ { x | ‚àÉ y, x ‚ãñ y }).Countable :=\n    (h.subset diff_subset).countable_of_isOpen (fun _ _ => isOpen_Ioo)\n      fun x hx => (h' _ hx.1).exists_lt_lt (mt (Exists.intro (y x)) hx.2)\n  this.of_diff countable_setOf_covBy_right\n\n"}
{"name":"countable_image_lt_image_Ioi","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : LinearOrder Œ≤\nf : Œ≤ ‚Üí Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ (setOf fun x => Exists fun z => And (LT.lt (f x) z) (‚àÄ (y : Œ≤), LT.lt x y ‚Üí LE.le z (f y))).Countable","decl":"/-- For a function taking values in a second countable space, the set of points `x` for\nwhich the image under `f` of `(x, ‚àû)` is separated above from `f x` is countable. -/\ntheorem countable_image_lt_image_Ioi [OrderTopology Œ±] [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±)\n    [SecondCountableTopology Œ±] : Set.Countable {x | ‚àÉ z, f x < z ‚àß ‚àÄ y, x < y ‚Üí z ‚â§ f y} := by\n  /- If the values of `f` are separated above on the right of `x`, there is an interval `(f x, z x)`\n    which is not reached by `f`. This gives a family of disjoint open intervals in `Œ±`. Such a\n    family can only be countable as `Œ±` is second-countable. -/\n  nontriviality Œ≤\n  have : Nonempty Œ± := Nonempty.map f (by infer_instance)\n  let s := {x | ‚àÉ z, f x < z ‚àß ‚àÄ y, x < y ‚Üí z ‚â§ f y}\n  have : ‚àÄ x, x ‚àà s ‚Üí ‚àÉ z, f x < z ‚àß ‚àÄ y, x < y ‚Üí z ‚â§ f y := fun x hx ‚Ü¶ hx\n  -- choose `z x` such that `f` does not take the values in `(f x, z x)`.\n  choose! z hz using this\n  have I : InjOn f s := by\n    apply StrictMonoOn.injOn\n    intro x hx y _ hxy\n    calc\n      f x < z x := (hz x hx).1\n      _ ‚â§ f y := (hz x hx).2 y hxy\n  -- show that `f s` is countable by arguing that a disjoint family of disjoint open intervals\n  -- (the intervals `(f x, z x)`) is at most countable.\n  have fs_count : (f '' s).Countable := by\n    have A : (f '' s).PairwiseDisjoint fun x => Ioo x (z (invFunOn f s x)) := by\n      rintro _ ‚ü®u, us, rfl‚ü© _ ‚ü®v, vs, rfl‚ü© huv\n      wlog hle : u ‚â§ v generalizing u v\n      ¬∑ exact (this v vs u us huv.symm (le_of_not_le hle)).symm\n      have hlt : u < v := hle.lt_of_ne (ne_of_apply_ne _ huv)\n      apply disjoint_iff_forall_ne.2\n      rintro a ha b hb rfl\n      simp only [I.leftInvOn_invFunOn us, I.leftInvOn_invFunOn vs] at ha hb\n      exact lt_irrefl _ ((ha.2.trans_le ((hz u us).2 v hlt)).trans hb.1)\n    apply Set.PairwiseDisjoint.countable_of_Ioo A\n    rintro _ ‚ü®y, ys, rfl‚ü©\n    simpa only [I.leftInvOn_invFunOn ys] using (hz y ys).1\n  exact MapsTo.countable_of_injOn (mapsTo_image f s) I fs_count\n\n"}
{"name":"countable_image_gt_image_Ioi","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : LinearOrder Œ≤\nf : Œ≤ ‚Üí Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ (setOf fun x => Exists fun z => And (LT.lt z (f x)) (‚àÄ (y : Œ≤), LT.lt x y ‚Üí LE.le (f y) z)).Countable","decl":"/-- For a function taking values in a second countable space, the set of points `x` for\nwhich the image under `f` of `(x, ‚àû)` is separated below from `f x` is countable. -/\ntheorem countable_image_gt_image_Ioi [OrderTopology Œ±] [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±)\n    [SecondCountableTopology Œ±] : Set.Countable {x | ‚àÉ z, z < f x ‚àß ‚àÄ y, x < y ‚Üí f y ‚â§ z} :=\n  countable_image_lt_image_Ioi (Œ± := Œ±·µí·µà) f\n\n"}
{"name":"countable_image_lt_image_Iio","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : LinearOrder Œ≤\nf : Œ≤ ‚Üí Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ (setOf fun x => Exists fun z => And (LT.lt (f x) z) (‚àÄ (y : Œ≤), LT.lt y x ‚Üí LE.le z (f y))).Countable","decl":"/-- For a function taking values in a second countable space, the set of points `x` for\nwhich the image under `f` of `(-‚àû, x)` is separated above from `f x` is countable. -/\ntheorem countable_image_lt_image_Iio [OrderTopology Œ±] [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±)\n    [SecondCountableTopology Œ±] : Set.Countable {x | ‚àÉ z, f x < z ‚àß ‚àÄ y, y < x ‚Üí z ‚â§ f y} :=\n  countable_image_lt_image_Ioi (Œ≤ := Œ≤·µí·µà) f\n\n"}
{"name":"countable_image_gt_image_Iio","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\ninst‚úù¬π : LinearOrder Œ≤\nf : Œ≤ ‚Üí Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ (setOf fun x => Exists fun z => And (LT.lt z (f x)) (‚àÄ (y : Œ≤), LT.lt y x ‚Üí LE.le (f y) z)).Countable","decl":"/-- For a function taking values in a second countable space, the set of points `x` for\nwhich the image under `f` of `(-‚àû, x)` is separated below from `f x` is countable. -/\ntheorem countable_image_gt_image_Iio [OrderTopology Œ±] [LinearOrder Œ≤] (f : Œ≤ ‚Üí Œ±)\n    [SecondCountableTopology Œ±] : Set.Countable {x | ‚àÉ z, z < f x ‚àß ‚àÄ y, y < x ‚Üí f y ‚â§ z} :=\n  countable_image_lt_image_Ioi (Œ± := Œ±·µí·µà) (Œ≤ := Œ≤·µí·µà) f\n\n"}
{"name":"instIsCountablyGenerated_atTop","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ Filter.atTop.IsCountablyGenerated","decl":"instance instIsCountablyGenerated_atTop [OrderTopology Œ±] [SecondCountableTopology Œ±] :\n    IsCountablyGenerated (atTop : Filter Œ±) := by\n  by_cases h : ‚àÉ (x : Œ±), IsTop x\n  ¬∑ rcases h with ‚ü®x, hx‚ü©\n    rw [atTop_eq_pure_of_isTop hx]\n    exact isCountablyGenerated_pure x\n  ¬∑ rcases exists_countable_basis Œ± with ‚ü®b, b_count, b_ne, hb‚ü©\n    have : Countable b := by exact Iff.mpr countable_coe_iff b_count\n    have A : ‚àÄ (s : b), ‚àÉ (x : Œ±), x ‚àà (s : Set Œ±) := by\n      intro s\n      have : (s : Set Œ±) ‚â† ‚àÖ := by\n        intro H\n        apply b_ne\n        convert s.2\n        exact H.symm\n      exact Iff.mp nmem_singleton_empty this\n    choose a ha using A\n    have : (atTop : Filter Œ±) = (generate (Ici '' (range a))) := by\n      apply atTop_eq_generate_of_not_bddAbove\n      intro ‚ü®x, hx‚ü©\n      simp only [IsTop, not_exists, not_forall, not_le] at h\n      rcases h x with ‚ü®y, hy‚ü©\n      obtain ‚ü®s, sb, -, hs‚ü© : ‚àÉ s, s ‚àà b ‚àß y ‚àà s ‚àß s ‚äÜ Ioi x :=\n        hb.exists_subset_of_mem_open hy isOpen_Ioi\n      have I : a ‚ü®s, sb‚ü© ‚â§ x := hx (mem_range_self _)\n      have J : x < a ‚ü®s, sb‚ü© := hs (ha ‚ü®s, sb‚ü©)\n      exact lt_irrefl _ (I.trans_lt J)\n    rw [this]\n    exact ‚ü®_, (countable_range _).image _, rfl‚ü©\n\n"}
{"name":"instIsCountablyGenerated_atBot","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ Filter.atBot.IsCountablyGenerated","decl":"instance instIsCountablyGenerated_atBot [OrderTopology Œ±] [SecondCountableTopology Œ±] :\n    IsCountablyGenerated (atBot : Filter Œ±) :=\n  @instIsCountablyGenerated_atTop Œ±·µí·µà _ _ _ _\n\n"}
{"name":"pi_Iic_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œπ : Type u_1\nœÄ : Œπ ‚Üí Type u_2\ninst‚úù¬≥ : Finite Œπ\ninst‚úù¬≤ : (i : Œπ) ‚Üí LinearOrder (œÄ i)\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)\ninst‚úù : ‚àÄ (i : Œπ), OrderTopology (œÄ i)\na x : (i : Œπ) ‚Üí œÄ i\nha : ‚àÄ (i : Œπ), LT.lt (x i) (a i)\n‚ä¢ Membership.mem (nhds x) (Set.Iic a)","decl":"theorem pi_Iic_mem_nhds (ha : ‚àÄ i, x i < a i) : Iic a ‚àà ùìù x :=\n  pi_univ_Iic a ‚ñ∏ set_pi_mem_nhds (Set.toFinite _) fun _ _ => Iic_mem_nhds (ha _)\n\n"}
{"name":"pi_Iic_mem_nhds'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\nŒπ : Type u_1\ninst‚úù : Finite Œπ\na' x' : Œπ ‚Üí Œ±\nha : ‚àÄ (i : Œπ), LT.lt (x' i) (a' i)\n‚ä¢ Membership.mem (nhds x') (Set.Iic a')","decl":"theorem pi_Iic_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iic a' ‚àà ùìù x' :=\n  pi_Iic_mem_nhds ha\n\n"}
{"name":"pi_Ici_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œπ : Type u_1\nœÄ : Œπ ‚Üí Type u_2\ninst‚úù¬≥ : Finite Œπ\ninst‚úù¬≤ : (i : Œπ) ‚Üí LinearOrder (œÄ i)\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)\ninst‚úù : ‚àÄ (i : Œπ), OrderTopology (œÄ i)\na x : (i : Œπ) ‚Üí œÄ i\nha : ‚àÄ (i : Œπ), LT.lt (a i) (x i)\n‚ä¢ Membership.mem (nhds x) (Set.Ici a)","decl":"theorem pi_Ici_mem_nhds (ha : ‚àÄ i, a i < x i) : Ici a ‚àà ùìù x :=\n  pi_univ_Ici a ‚ñ∏ set_pi_mem_nhds (Set.toFinite _) fun _ _ => Ici_mem_nhds (ha _)\n\n"}
{"name":"pi_Ici_mem_nhds'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\nŒπ : Type u_1\ninst‚úù : Finite Œπ\na' x' : Œπ ‚Üí Œ±\nha : ‚àÄ (i : Œπ), LT.lt (a' i) (x' i)\n‚ä¢ Membership.mem (nhds x') (Set.Ici a')","decl":"theorem pi_Ici_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ici a' ‚àà ùìù x' :=\n  pi_Ici_mem_nhds ha\n\n"}
{"name":"pi_Icc_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œπ : Type u_1\nœÄ : Œπ ‚Üí Type u_2\ninst‚úù¬≥ : Finite Œπ\ninst‚úù¬≤ : (i : Œπ) ‚Üí LinearOrder (œÄ i)\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)\ninst‚úù : ‚àÄ (i : Œπ), OrderTopology (œÄ i)\na b x : (i : Œπ) ‚Üí œÄ i\nha : ‚àÄ (i : Œπ), LT.lt (a i) (x i)\nhb : ‚àÄ (i : Œπ), LT.lt (x i) (b i)\n‚ä¢ Membership.mem (nhds x) (Set.Icc a b)","decl":"theorem pi_Icc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Icc a b ‚àà ùìù x :=\n  pi_univ_Icc a b ‚ñ∏ set_pi_mem_nhds finite_univ fun _ _ => Icc_mem_nhds (ha _) (hb _)\n\n"}
{"name":"pi_Icc_mem_nhds'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : LinearOrder Œ±\ninst‚úù¬π : OrderTopology Œ±\nŒπ : Type u_1\ninst‚úù : Finite Œπ\na' b' x' : Œπ ‚Üí Œ±\nha : ‚àÄ (i : Œπ), LT.lt (a' i) (x' i)\nhb : ‚àÄ (i : Œπ), LT.lt (x' i) (b' i)\n‚ä¢ Membership.mem (nhds x') (Set.Icc a' b')","decl":"theorem pi_Icc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Icc a' b' ‚àà ùìù x' :=\n  pi_Icc_mem_nhds ha hb\n\n"}
{"name":"pi_Iio_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œπ : Type u_1\nœÄ : Œπ ‚Üí Type u_2\ninst‚úù‚Å¥ : Finite Œπ\ninst‚úù¬≥ : (i : Œπ) ‚Üí LinearOrder (œÄ i)\ninst‚úù¬≤ : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)\ninst‚úù¬π : ‚àÄ (i : Œπ), OrderTopology (œÄ i)\na x : (i : Œπ) ‚Üí œÄ i\ninst‚úù : Nonempty Œπ\nha : ‚àÄ (i : Œπ), LT.lt (x i) (a i)\n‚ä¢ Membership.mem (nhds x) (Set.Iio a)","decl":"theorem pi_Iio_mem_nhds (ha : ‚àÄ i, x i < a i) : Iio a ‚àà ùìù x := mem_of_superset\n  (set_pi_mem_nhds finite_univ fun i _ ‚Ü¶ Iio_mem_nhds (ha i)) (pi_univ_Iio_subset a)\n\n"}
{"name":"pi_Iio_mem_nhds'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\nŒπ : Type u_1\ninst‚úù¬π : Finite Œπ\na' x' : Œπ ‚Üí Œ±\ninst‚úù : Nonempty Œπ\nha : ‚àÄ (i : Œπ), LT.lt (x' i) (a' i)\n‚ä¢ Membership.mem (nhds x') (Set.Iio a')","decl":"theorem pi_Iio_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iio a' ‚àà ùìù x' :=\n  pi_Iio_mem_nhds ha\n\n"}
{"name":"pi_Ioi_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œπ : Type u_1\nœÄ : Œπ ‚Üí Type u_2\ninst‚úù‚Å¥ : Finite Œπ\ninst‚úù¬≥ : (i : Œπ) ‚Üí LinearOrder (œÄ i)\ninst‚úù¬≤ : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)\ninst‚úù¬π : ‚àÄ (i : Œπ), OrderTopology (œÄ i)\na x : (i : Œπ) ‚Üí œÄ i\ninst‚úù : Nonempty Œπ\nha : ‚àÄ (i : Œπ), LT.lt (a i) (x i)\n‚ä¢ Membership.mem (nhds x) (Set.Ioi a)","decl":"theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=\n  pi_Iio_mem_nhds (œÄ := fun i => (œÄ i)·µí·µà) ha\n\n"}
{"name":"pi_Ioi_mem_nhds'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\nŒπ : Type u_1\ninst‚úù¬π : Finite Œπ\na' x' : Œπ ‚Üí Œ±\ninst‚úù : Nonempty Œπ\nha : ‚àÄ (i : Œπ), LT.lt (a' i) (x' i)\n‚ä¢ Membership.mem (nhds x') (Set.Ioi a')","decl":"theorem pi_Ioi_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ioi a' ‚àà ùìù x' :=\n  pi_Ioi_mem_nhds ha\n\n"}
{"name":"pi_Ioc_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œπ : Type u_1\nœÄ : Œπ ‚Üí Type u_2\ninst‚úù‚Å¥ : Finite Œπ\ninst‚úù¬≥ : (i : Œπ) ‚Üí LinearOrder (œÄ i)\ninst‚úù¬≤ : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)\ninst‚úù¬π : ‚àÄ (i : Œπ), OrderTopology (œÄ i)\na b x : (i : Œπ) ‚Üí œÄ i\ninst‚úù : Nonempty Œπ\nha : ‚àÄ (i : Œπ), LT.lt (a i) (x i)\nhb : ‚àÄ (i : Œπ), LT.lt (x i) (b i)\n‚ä¢ Membership.mem (nhds x) (Set.Ioc a b)","decl":"theorem pi_Ioc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioc a b ‚àà ùìù x := by\n  refine mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => ?_) (pi_univ_Ioc_subset a b)\n  exact Ioc_mem_nhds (ha i) (hb i)\n\n"}
{"name":"pi_Ioc_mem_nhds'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\nŒπ : Type u_1\ninst‚úù¬π : Finite Œπ\na' b' x' : Œπ ‚Üí Œ±\ninst‚úù : Nonempty Œπ\nha : ‚àÄ (i : Œπ), LT.lt (a' i) (x' i)\nhb : ‚àÄ (i : Œπ), LT.lt (x' i) (b' i)\n‚ä¢ Membership.mem (nhds x') (Set.Ioc a' b')","decl":"theorem pi_Ioc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioc a' b' ‚àà ùìù x' :=\n  pi_Ioc_mem_nhds ha hb\n\n"}
{"name":"pi_Ico_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œπ : Type u_1\nœÄ : Œπ ‚Üí Type u_2\ninst‚úù‚Å¥ : Finite Œπ\ninst‚úù¬≥ : (i : Œπ) ‚Üí LinearOrder (œÄ i)\ninst‚úù¬≤ : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)\ninst‚úù¬π : ‚àÄ (i : Œπ), OrderTopology (œÄ i)\na b x : (i : Œπ) ‚Üí œÄ i\ninst‚úù : Nonempty Œπ\nha : ‚àÄ (i : Œπ), LT.lt (a i) (x i)\nhb : ‚àÄ (i : Œπ), LT.lt (x i) (b i)\n‚ä¢ Membership.mem (nhds x) (Set.Ico a b)","decl":"theorem pi_Ico_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ico a b ‚àà ùìù x := by\n  refine mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => ?_) (pi_univ_Ico_subset a b)\n  exact Ico_mem_nhds (ha i) (hb i)\n\n"}
{"name":"pi_Ico_mem_nhds'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\nŒπ : Type u_1\ninst‚úù¬π : Finite Œπ\na' b' x' : Œπ ‚Üí Œ±\ninst‚úù : Nonempty Œπ\nha : ‚àÄ (i : Œπ), LT.lt (a' i) (x' i)\nhb : ‚àÄ (i : Œπ), LT.lt (x' i) (b' i)\n‚ä¢ Membership.mem (nhds x') (Set.Ico a' b')","decl":"theorem pi_Ico_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ico a' b' ‚àà ùìù x' :=\n  pi_Ico_mem_nhds ha hb\n\n"}
{"name":"pi_Ioo_mem_nhds","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œπ : Type u_1\nœÄ : Œπ ‚Üí Type u_2\ninst‚úù‚Å¥ : Finite Œπ\ninst‚úù¬≥ : (i : Œπ) ‚Üí LinearOrder (œÄ i)\ninst‚úù¬≤ : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)\ninst‚úù¬π : ‚àÄ (i : Œπ), OrderTopology (œÄ i)\na b x : (i : Œπ) ‚Üí œÄ i\ninst‚úù : Nonempty Œπ\nha : ‚àÄ (i : Œπ), LT.lt (a i) (x i)\nhb : ‚àÄ (i : Œπ), LT.lt (x i) (b i)\n‚ä¢ Membership.mem (nhds x) (Set.Ioo a b)","decl":"theorem pi_Ioo_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioo a b ‚àà ùìù x := by\n  refine mem_of_superset (set_pi_mem_nhds Set.finite_univ fun i _ => ?_) (pi_univ_Ioo_subset a b)\n  exact Ioo_mem_nhds (ha i) (hb i)\n\n"}
{"name":"pi_Ioo_mem_nhds'","module":"Mathlib.Topology.Order.Basic","initialProofState":"Œ± : Type u\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : OrderTopology Œ±\nŒπ : Type u_1\ninst‚úù¬π : Finite Œπ\na' b' x' : Œπ ‚Üí Œ±\ninst‚úù : Nonempty Œπ\nha : ‚àÄ (i : Œπ), LT.lt (a' i) (x' i)\nhb : ‚àÄ (i : Œπ), LT.lt (x' i) (b' i)\n‚ä¢ Membership.mem (nhds x') (Set.Ioo a' b')","decl":"theorem pi_Ioo_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioo a' b' ‚àà ùìù x' :=\n  pi_Ioo_mem_nhds ha hb\n\n"}
