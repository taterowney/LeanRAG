{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.of_le","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nP Q : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\nhQ : Q.IsInvertedBy F\nh : LE.le P Q\n⊢ P.IsInvertedBy F","decl":"lemma of_le (P Q : MorphismProperty C) (F : C ⥤ D) (hQ : Q.IsInvertedBy F) (h : P ≤ Q) :\n    P.IsInvertedBy F :=\n  fun _ _ _ hf => hQ _ (h _ hf)\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.of_comp","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} C₂\ninst✝ : CategoryTheory.Category.{u_6, u_3} C₃\nW : CategoryTheory.MorphismProperty C₁\nF : CategoryTheory.Functor C₁ C₂\nhF : W.IsInvertedBy F\nG : CategoryTheory.Functor C₂ C₃\n⊢ W.IsInvertedBy (F.comp G)","decl":"theorem of_comp {C₁ C₂ C₃ : Type*} [Category C₁] [Category C₂] [Category C₃]\n    (W : MorphismProperty C₁) (F : C₁ ⥤ C₂) (hF : W.IsInvertedBy F) (G : C₂ ⥤ C₃) :\n    W.IsInvertedBy (F ⋙ G) := fun X Y f hf => by\n  haveI := hF f hf\n  dsimp\n  infer_instance\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.op","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nW : CategoryTheory.MorphismProperty C\nL : CategoryTheory.Functor C D\nh : W.IsInvertedBy L\n⊢ W.op.IsInvertedBy L.op","decl":"theorem op {W : MorphismProperty C} {L : C ⥤ D} (h : W.IsInvertedBy L) : W.op.IsInvertedBy L.op :=\n  fun X Y f hf => by\n  haveI := h f.unop hf\n  dsimp\n  infer_instance\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.rightOp","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nW : CategoryTheory.MorphismProperty C\nL : CategoryTheory.Functor (Opposite C) D\nh : W.op.IsInvertedBy L\n⊢ W.IsInvertedBy L.rightOp","decl":"theorem rightOp {W : MorphismProperty C} {L : Cᵒᵖ ⥤ D} (h : W.op.IsInvertedBy L) :\n    W.IsInvertedBy L.rightOp := fun X Y f hf => by\n  haveI := h f.op hf\n  dsimp\n  infer_instance\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.leftOp","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nW : CategoryTheory.MorphismProperty C\nL : CategoryTheory.Functor C (Opposite D)\nh : W.IsInvertedBy L\n⊢ W.op.IsInvertedBy L.leftOp","decl":"theorem leftOp {W : MorphismProperty C} {L : C ⥤ Dᵒᵖ} (h : W.IsInvertedBy L) :\n    W.op.IsInvertedBy L.leftOp := fun X Y f hf => by\n  haveI := h f.unop hf\n  dsimp\n  infer_instance\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.unop","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nW : CategoryTheory.MorphismProperty C\nL : CategoryTheory.Functor (Opposite C) (Opposite D)\nh : W.op.IsInvertedBy L\n⊢ W.IsInvertedBy L.unop","decl":"theorem unop {W : MorphismProperty C} {L : Cᵒᵖ ⥤ Dᵒᵖ} (h : W.op.IsInvertedBy L) :\n    W.IsInvertedBy L.unop := fun X Y f hf => by\n  haveI := h f.op hf\n  dsimp\n  infer_instance\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.prod","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_6, u_2} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nE₁ : Type u_3\nE₂ : Type u_4\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} E₁\ninst✝ : CategoryTheory.Category.{u_8, u_4} E₂\nF₁ : CategoryTheory.Functor C₁ E₁\nF₂ : CategoryTheory.Functor C₂ E₂\nh₁ : W₁.IsInvertedBy F₁\nh₂ : W₂.IsInvertedBy F₂\n⊢ (W₁.prod W₂).IsInvertedBy (F₁.prod F₂)","decl":"lemma prod {C₁ C₂ : Type*} [Category C₁] [Category C₂]\n    {W₁ : MorphismProperty C₁} {W₂ : MorphismProperty C₂}\n    {E₁ E₂ : Type*} [Category E₁] [Category E₂] {F₁ : C₁ ⥤ E₁} {F₂ : C₂ ⥤ E₂}\n    (h₁ : W₁.IsInvertedBy F₁) (h₂ : W₂.IsInvertedBy F₂) :\n    (W₁.prod W₂).IsInvertedBy (F₁.prod F₂) := fun _ _ f hf => by\n  rw [isIso_prod_iff]\n  exact ⟨h₁ _ hf.1, h₂ _ hf.2⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.pi","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"J : Type w\nC : J → Type u\nD : J → Type u'\ninst✝¹ : (j : J) → CategoryTheory.Category.{v, u} (C j)\ninst✝ : (j : J) → CategoryTheory.Category.{v', u'} (D j)\nW : (j : J) → CategoryTheory.MorphismProperty (C j)\nF : (j : J) → CategoryTheory.Functor (C j) (D j)\nhF : ∀ (j : J), (W j).IsInvertedBy (F j)\n⊢ (CategoryTheory.MorphismProperty.pi W).IsInvertedBy (CategoryTheory.Functor.pi F)","decl":"lemma pi {J : Type w} {C : J → Type u} {D : J → Type u'}\n    [∀ j, Category.{v} (C j)] [∀ j, Category.{v'} (D j)]\n    (W : ∀ j, MorphismProperty (C j)) (F : ∀ j, C j ⥤ D j)\n    (hF : ∀ j, (W j).IsInvertedBy (F j)) :\n    (MorphismProperty.pi W).IsInvertedBy (Functor.pi F) := by\n  intro _ _ f hf\n  rw [isIso_pi_iff]\n  intro j\n  exact hF j _ (hf j)\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorsInverting.ext","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nW : CategoryTheory.MorphismProperty C\nF₁ F₂ : W.FunctorsInverting D\nh : Eq F₁.obj F₂.obj\n⊢ Eq F₁ F₂","decl":"@[ext]\nlemma FunctorsInverting.ext {W : MorphismProperty C} {F₁ F₂ : FunctorsInverting W D}\n    (h : F₁.obj = F₂.obj) : F₁ = F₂ := by\n  cases F₁\n  cases F₂\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorsInverting.ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nW : CategoryTheory.MorphismProperty C\nF₁ F₂ : W.FunctorsInverting D\n⊢ Iff (Eq F₁ F₂) (Eq F₁.obj F₂.obj)","decl":"@[ext]\nlemma FunctorsInverting.ext {W : MorphismProperty C} {F₁ F₂ : FunctorsInverting W D}\n    (h : F₁.obj = F₂.obj) : F₁ = F₂ := by\n  cases F₁\n  cases F₂\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorsInverting.hom_ext","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nW : CategoryTheory.MorphismProperty C\nF₁ F₂ : W.FunctorsInverting D\nα β : Quiver.Hom F₁ F₂\nh : Eq α.app β.app\n⊢ Eq α β","decl":"@[ext]\nlemma FunctorsInverting.hom_ext {W : MorphismProperty C} {F₁ F₂ : FunctorsInverting W D}\n    {α β : F₁ ⟶ F₂} (h : α.app = β.app) : α = β :=\n  NatTrans.ext h\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorsInverting.hom_ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nW : CategoryTheory.MorphismProperty C\nF₁ F₂ : W.FunctorsInverting D\nα β : Quiver.Hom F₁ F₂\n⊢ Iff (Eq α β) (Eq α.app β.app)","decl":"@[ext]\nlemma FunctorsInverting.hom_ext {W : MorphismProperty C} {F₁ F₂ : FunctorsInverting W D}\n    {α β : F₁ ⟶ F₂} (h : α.app = β.app) : α = β :=\n  NatTrans.ext h\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.iff_of_iso","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nW : CategoryTheory.MorphismProperty C\nF₁ F₂ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F₁ F₂\n⊢ Iff (W.IsInvertedBy F₁) (W.IsInvertedBy F₂)","decl":"theorem IsInvertedBy.iff_of_iso (W : MorphismProperty C) {F₁ F₂ : C ⥤ D} (e : F₁ ≅ F₂) :\n    W.IsInvertedBy F₁ ↔ W.IsInvertedBy F₂ := by\n  dsimp [IsInvertedBy]\n  simp only [NatIso.isIso_map_iff e]\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.isoClosure_iff","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nW : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\n⊢ Iff (W.isoClosure.IsInvertedBy F) (W.IsInvertedBy F)","decl":"@[simp]\nlemma IsInvertedBy.isoClosure_iff (W : MorphismProperty C) (F : C ⥤ D) :\n    W.isoClosure.IsInvertedBy F ↔ W.IsInvertedBy F := by\n  constructor\n  · intro h X Y f hf\n    exact h _ (W.le_isoClosure _ hf)\n  · intro h X Y f ⟨X', Y', f', hf', ⟨e⟩⟩\n    simp only [Arrow.iso_w' e, F.map_comp]\n    have := h _ hf'\n    infer_instance\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.iff_comp","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_5, u_2} C₂\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} C₃\nW : CategoryTheory.MorphismProperty C₁\nF : CategoryTheory.Functor C₁ C₂\nG : CategoryTheory.Functor C₂ C₃\ninst✝ : G.ReflectsIsomorphisms\n⊢ Iff (W.IsInvertedBy (F.comp G)) (W.IsInvertedBy F)","decl":"@[simp]\nlemma IsInvertedBy.iff_comp {C₁ C₂ C₃ : Type*} [Category C₁] [Category C₂] [Category C₃]\n    (W : MorphismProperty C₁) (F : C₁ ⥤ C₂) (G : C₂ ⥤ C₃) [G.ReflectsIsomorphisms] :\n    W.IsInvertedBy (F ⋙ G) ↔ W.IsInvertedBy F := by\n  constructor\n  · intro h X Y f hf\n    have : IsIso (G.map (F.map f)) := h _ hf\n    exact isIso_of_reflects_iso (F.map f) G\n  · intro hF\n    exact IsInvertedBy.of_comp W F hF G\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.iff_le_inverseImage_isomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nW : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\n⊢ Iff (W.IsInvertedBy F) (LE.le W ((CategoryTheory.MorphismProperty.isomorphisms D).inverseImage F))","decl":"lemma IsInvertedBy.iff_le_inverseImage_isomorphisms (W : MorphismProperty C) (F : C ⥤ D) :\n    W.IsInvertedBy F ↔ W ≤ (isomorphisms D).inverseImage F := Iff.rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.iff_map_le_isomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nW : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\n⊢ Iff (W.IsInvertedBy F) (LE.le (W.map F) (CategoryTheory.MorphismProperty.isomorphisms D))","decl":"lemma IsInvertedBy.iff_map_le_isomorphisms (W : MorphismProperty C) (F : C ⥤ D) :\n    W.IsInvertedBy F ↔ W.map F ≤ isomorphisms D := by\n  rw [iff_le_inverseImage_isomorphisms, map_le_iff]\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsInvertedBy.map_iff","module":"Mathlib.CategoryTheory.MorphismProperty.IsInvertedBy","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_1} C₁\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} C₂\ninst✝ : CategoryTheory.Category.{u_6, u_3} C₃\nW : CategoryTheory.MorphismProperty C₁\nF : CategoryTheory.Functor C₁ C₂\nG : CategoryTheory.Functor C₂ C₃\n⊢ Iff ((W.map F).IsInvertedBy G) (W.IsInvertedBy (F.comp G))","decl":"lemma IsInvertedBy.map_iff {C₁ C₂ C₃ : Type*} [Category C₁] [Category C₂] [Category C₃]\n    (W : MorphismProperty C₁) (F : C₁ ⥤ C₂) (G : C₂ ⥤ C₃) :\n    (W.map F).IsInvertedBy G ↔ W.IsInvertedBy (F ⋙ G) := by\n  simp only [IsInvertedBy.iff_map_le_isomorphisms, map_map]\n\n"}
