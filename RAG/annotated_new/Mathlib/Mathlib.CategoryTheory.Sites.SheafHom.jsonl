{"name":"CategoryTheory.presheafHom_obj","module":"Mathlib.CategoryTheory.Sites.SheafHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} A\nF G : CategoryTheory.Functor (Opposite C) A\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.presheafHom F G).obj X) (Quiver.Hom ((CategoryTheory.Over.forget (Opposite.unop X)).op.comp F) ((CategoryTheory.Over.forget (Opposite.unop X)).op.comp G))","decl":"/-- Given two presheaves `F` and `G` on a category `C` with values in a category `A`,\nthis `presheafHom F G` is the presheaf of types which sends an object `X : C`\nto the type of morphisms between the \"restrictions\" of `F` and `G` to the category `Over X`. -/\n@[simps! obj]\ndef presheafHom : C·µí·µñ ‚•§ Type _ where\n  obj X := (Over.forget X.unop).op ‚ãô F ‚ü∂ (Over.forget X.unop).op ‚ãô G\n  map f := whiskerLeft (Over.map f.unop).op\n  map_id := by\n    rintro ‚ü®X‚ü©\n    ext œÜ ‚ü®Y‚ü©\n    simpa [Over.mapId] using œÜ.naturality ((Over.mapId X).hom.app Y).op\n  map_comp := by\n    rintro ‚ü®X‚ü© ‚ü®Y‚ü© ‚ü®Z‚ü© ‚ü®f : Y ‚ü∂ X‚ü© ‚ü®g : Z ‚ü∂ Y‚ü©\n    ext œÜ ‚ü®W‚ü©\n    simpa [Over.mapComp] using œÜ.naturality ((Over.mapComp g f).hom.app W).op\n\n"}
{"name":"CategoryTheory.presheafHom_map_app","module":"Mathlib.CategoryTheory.Sites.SheafHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} A\nF G : CategoryTheory.Functor (Opposite C) A\nX Y Z : C\nf : Quiver.Hom Z Y\ng : Quiver.Hom Y X\nh : Quiver.Hom Z X\nw : Eq (CategoryTheory.CategoryStruct.comp f g) h\nŒ± : (CategoryTheory.presheafHom F G).obj { unop := X }\n‚ä¢ Eq (((CategoryTheory.presheafHom F G).map g.op Œ±).app { unop := CategoryTheory.Over.mk f }) (Œ±.app { unop := CategoryTheory.Over.mk h })","decl":"/-- Equational lemma for the presheaf structure on `presheafHom`.\nIt is advisable to use this lemma rather than `dsimp [presheafHom]` which may result\nin the need to prove equalities of objects in an `Over` category. -/\nlemma presheafHom_map_app {X Y Z : C} (f : Z ‚ü∂ Y) (g : Y ‚ü∂ X) (h : Z ‚ü∂ X) (w : f ‚â´ g = h)\n    (Œ± : (presheafHom F G).obj (op X)) :\n    ((presheafHom F G).map g.op Œ±).app (op (Over.mk f)) =\n      Œ±.app (op (Over.mk h)) := by\n  subst w\n  rfl\n\n"}
{"name":"CategoryTheory.presheafHom_map_app_op_mk_id","module":"Mathlib.CategoryTheory.Sites.SheafHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} A\nF G : CategoryTheory.Functor (Opposite C) A\nX Y : C\ng : Quiver.Hom Y X\nŒ± : (CategoryTheory.presheafHom F G).obj { unop := X }\n‚ä¢ Eq (((CategoryTheory.presheafHom F G).map g.op Œ±).app { unop := CategoryTheory.Over.mk (CategoryTheory.CategoryStruct.id Y) }) (Œ±.app { unop := CategoryTheory.Over.mk g })","decl":"@[simp]\nlemma presheafHom_map_app_op_mk_id {X Y : C} (g : Y ‚ü∂ X)\n    (Œ± : (presheafHom F G).obj (op X)) :\n    ((presheafHom F G).map g.op Œ±).app (op (Over.mk (ùüô Y))) =\n      Œ±.app (op (Over.mk g)) :=\n  presheafHom_map_app (ùüô Y) g g (by simp) Œ±\n\n"}
{"name":"CategoryTheory.PresheafHom.isAmalgamation_iff","module":"Mathlib.CategoryTheory.Sites.SheafHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} A\nF G : CategoryTheory.Functor (Opposite C) A\nX : C\nS : CategoryTheory.Sieve X\nx : CategoryTheory.Presieve.FamilyOfElements (CategoryTheory.presheafHom F G) S.arrows\nhx : x.Compatible\ny : (CategoryTheory.presheafHom F G).obj { unop := X }\n‚ä¢ Iff (x.IsAmalgamation y) (‚àÄ (Y : C) (g : Quiver.Hom Y X) (hg : S.arrows g), Eq (y.app { unop := CategoryTheory.Over.mk g }) ((x g hg).app { unop := CategoryTheory.Over.mk (CategoryTheory.CategoryStruct.id Y) }))","decl":"lemma PresheafHom.isAmalgamation_iff {X : C} (S : Sieve X)\n    (x : Presieve.FamilyOfElements (presheafHom F G) S.arrows)\n    (hx : x.Compatible) (y : (presheafHom F G).obj (op X)) :\n    x.IsAmalgamation y ‚Üî ‚àÄ (Y : C) (g : Y ‚ü∂ X) (hg : S g),\n      y.app (op (Over.mk g)) = (x g hg).app (op (Over.mk (ùüô Y))) := by\n  constructor\n  ¬∑ intro h Y g hg\n    rw [‚Üê h g hg, presheafHom_map_app_op_mk_id]\n  ¬∑ intro h Y g hg\n    dsimp\n    ext ‚ü®W : Over Y‚ü©\n    refine (h W.left (W.hom ‚â´ g) (S.downward_closed hg _)).trans ?_\n    have H := hx (ùüô _) W.hom (S.downward_closed hg W.hom) hg (by simp)\n    dsimp at H\n    simp only [Functor.map_id, FunctorToTypes.map_id_apply] at H\n    rw [H, presheafHom_map_app_op_mk_id]\n    rfl\n\n"}
{"name":"CategoryTheory.PresheafHom.IsSheafFor.exists_app","module":"Mathlib.CategoryTheory.Sites.SheafHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} A\nF G : CategoryTheory.Functor (Opposite C) A\nX : C\nS : CategoryTheory.Sieve X\nhG : ‚¶ÉY : C‚¶Ñ ‚Üí (f : Quiver.Hom Y X) ‚Üí CategoryTheory.Limits.IsLimit (G.mapCone (CategoryTheory.Sieve.pullback f S).arrows.cocone.op)\nx : CategoryTheory.Presieve.FamilyOfElements (CategoryTheory.presheafHom F G) S.arrows\nY : C\nhx : x.Compatible\ng : Quiver.Hom Y X\n‚ä¢ Exists fun œÜ => ‚àÄ {Z : C} (p : Quiver.Hom Z Y) (hp : S.arrows (CategoryTheory.CategoryStruct.comp p g)), Eq (CategoryTheory.CategoryStruct.comp œÜ (G.map p.op)) (CategoryTheory.CategoryStruct.comp (F.map p.op) ((x (CategoryTheory.CategoryStruct.comp p g) hp).app { unop := CategoryTheory.Over.mk (CategoryTheory.CategoryStruct.id Z) }))","decl":"include hG in\nlemma exists_app (hx : x.Compatible) (g : Y ‚ü∂ X) :\n    ‚àÉ (œÜ : F.obj (op Y) ‚ü∂ G.obj (op Y)),\n      ‚àÄ {Z : C} (p : Z ‚ü∂ Y) (hp : S (p ‚â´ g)), œÜ ‚â´ G.map p.op =\n        F.map p.op ‚â´ (x (p ‚â´ g) hp).app ‚ü®Over.mk (ùüô Z)‚ü© := by\n  let c : Cone ((Presieve.diagram (Sieve.pullback g S).arrows).op ‚ãô G) :=\n    { pt := F.obj (op Y)\n      œÄ :=\n        { app := fun ‚ü®Z, hZ‚ü© => F.map Z.hom.op ‚â´ (x _ hZ).app (op (Over.mk (ùüô _)))\n          naturality := by\n            rintro ‚ü®Z‚ÇÅ, hZ‚ÇÅ‚ü© ‚ü®Z‚ÇÇ, hZ‚ÇÇ‚ü© ‚ü®f : Z‚ÇÇ ‚ü∂ Z‚ÇÅ‚ü©\n            dsimp\n            rw [id_comp, assoc]\n            have H := hx f.left (ùüô _) hZ‚ÇÅ hZ‚ÇÇ (by simp)\n            simp only [presheafHom_obj, unop_op, Functor.id_obj, op_id,\n              FunctorToTypes.map_id_apply] at H\n            let œÜ : Over.mk f.left ‚ü∂ Over.mk (ùüô Z‚ÇÅ.left) := Over.homMk f.left\n            have H' := (x (Z‚ÇÅ.hom ‚â´ g) hZ‚ÇÅ).naturality œÜ.op\n            dsimp at H H' ‚ä¢\n            erw [‚Üê H, ‚Üê H', presheafHom_map_app_op_mk_id, ‚Üê F.map_comp_assoc,\n              ‚Üê op_comp, Over.w f] } }\n  use (hG g).lift c\n  intro Z p hp\n  exact ((hG g).fac c ‚ü®Over.mk p, hp‚ü©)\n\n"}
{"name":"CategoryTheory.PresheafHom.IsSheafFor.app_cond","module":"Mathlib.CategoryTheory.Sites.SheafHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} A\nF G : CategoryTheory.Functor (Opposite C) A\nX : C\nS : CategoryTheory.Sieve X\nhG : ‚¶ÉY : C‚¶Ñ ‚Üí (f : Quiver.Hom Y X) ‚Üí CategoryTheory.Limits.IsLimit (G.mapCone (CategoryTheory.Sieve.pullback f S).arrows.cocone.op)\nx : CategoryTheory.Presieve.FamilyOfElements (CategoryTheory.presheafHom F G) S.arrows\nY : C\nhx : x.Compatible\ng : Quiver.Hom Y X\nZ : C\np : Quiver.Hom Z Y\nhp : S.arrows (CategoryTheory.CategoryStruct.comp p g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.PresheafHom.IsSheafFor.app hG x hx g) (G.map p.op)) (CategoryTheory.CategoryStruct.comp (F.map p.op) ((x (CategoryTheory.CategoryStruct.comp p g) hp).app { unop := CategoryTheory.Over.mk (CategoryTheory.CategoryStruct.id Z) }))","decl":"lemma app_cond (hx : x.Compatible) (g : Y ‚ü∂ X) {Z : C} (p : Z ‚ü∂ Y) (hp : S (p ‚â´ g)) :\n    app hG x hx g ‚â´ G.map p.op = F.map p.op ‚â´ (x (p ‚â´ g) hp).app ‚ü®Over.mk (ùüô Z)‚ü© :=\n  (exists_app hG x hx g).choose_spec p hp\n\n"}
{"name":"CategoryTheory.presheafHom_isSheafFor","module":"Mathlib.CategoryTheory.Sites.SheafHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} A\nF G : CategoryTheory.Functor (Opposite C) A\nX : C\nS : CategoryTheory.Sieve X\nhG : ‚¶ÉY : C‚¶Ñ ‚Üí (f : Quiver.Hom Y X) ‚Üí CategoryTheory.Limits.IsLimit (G.mapCone (CategoryTheory.Sieve.pullback f S).arrows.cocone.op)\n‚ä¢ CategoryTheory.Presieve.IsSheafFor (CategoryTheory.presheafHom F G) S.arrows","decl":"include hG in\nopen PresheafHom.IsSheafFor in\nlemma presheafHom_isSheafFor  :\n    Presieve.IsSheafFor (presheafHom F G) S.arrows := by\n  intro x hx\n  apply existsUnique_of_exists_of_unique\n  ¬∑ refine ‚ü®\n      { app := fun Y => app hG x hx Y.unop.hom\n        naturality := by\n          rintro ‚ü®Y‚ÇÅ : Over X‚ü© ‚ü®Y‚ÇÇ : Over X‚ü© ‚ü®œÜ : Y‚ÇÇ ‚ü∂ Y‚ÇÅ‚ü©\n          apply (hG Y‚ÇÇ.hom).hom_ext\n          rintro ‚ü®Z : Over Y‚ÇÇ.left, hZ‚ü©\n          dsimp\n          rw [assoc, assoc, app_cond hG x hx Y‚ÇÇ.hom Z.hom hZ, ‚Üê G.map_comp, ‚Üê op_comp]\n          rw [app_cond hG x hx Y‚ÇÅ.hom (Z.hom ‚â´ œÜ.left) (by simpa using hZ),\n            ‚Üê F.map_comp_assoc, op_comp]\n          congr 3\n          simp }, ?_‚ü©\n    rw [PresheafHom.isAmalgamation_iff _ _ hx]\n    intro Y g hg\n    dsimp\n    have H := app_cond hG x hx g (ùüô _) (by simpa using hg)\n    rw [op_id, G.map_id, comp_id, F.map_id, id_comp] at H\n    exact H.trans (by congr; simp)\n  ¬∑ intro y‚ÇÅ y‚ÇÇ hy‚ÇÅ hy‚ÇÇ\n    rw [PresheafHom.isAmalgamation_iff _ _ hx] at hy‚ÇÅ hy‚ÇÇ\n    apply NatTrans.ext\n    ext ‚ü®Y : Over X‚ü©\n    apply (hG Y.hom).hom_ext\n    rintro ‚ü®Z : Over Y.left, hZ‚ü©\n    dsimp\n    let œÜ : Over.mk (Z.hom ‚â´ Y.hom) ‚ü∂ Y := Over.homMk Z.hom\n    refine (y‚ÇÅ.naturality œÜ.op).symm.trans (Eq.trans ?_ (y‚ÇÇ.naturality œÜ.op))\n    rw [(hy‚ÇÅ _ _ hZ), ‚Üê ((hy‚ÇÇ _ _ hZ))]\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.hom","module":"Mathlib.CategoryTheory.Sites.SheafHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} A\nF G : CategoryTheory.Functor (Opposite C) A\nhG : CategoryTheory.Presheaf.IsSheaf J G\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J (CategoryTheory.presheafHom F G)","decl":"lemma Presheaf.IsSheaf.hom (hG : Presheaf.IsSheaf J G) :\n    Presheaf.IsSheaf J (presheafHom F G) := by\n  rw [isSheaf_iff_isSheaf_of_type]\n  intro X S hS\n  exact presheafHom_isSheafFor F G S\n    (fun _ _ => ((Presheaf.isSheaf_iff_isLimit J G).1 hG _ (J.pullback_stable _ hS)).some)\n\n\n"}
{"name":"CategoryTheory.sheafHomSectionsEquiv_symm_apply_coe_apply","module":"Mathlib.CategoryTheory.Sites.SheafHom","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} A\nF G : CategoryTheory.Sheaf J A\nœÜ : Quiver.Hom F G\nX : Opposite C\n‚ä¢ Eq (‚Üë((CategoryTheory.sheafHomSectionsEquiv F G).symm œÜ) X) ((J.overPullback A (Opposite.unop X)).map œÜ)","decl":"@[simp]\nlemma sheafHomSectionsEquiv_symm_apply_coe_apply {F G : Sheaf J A} (œÜ : F ‚ü∂ G) (X : C·µí·µñ) :\n    ((sheafHomSectionsEquiv F G).symm œÜ).1 X = (J.overPullback A X.unop).map œÜ := rfl\n\n"}
