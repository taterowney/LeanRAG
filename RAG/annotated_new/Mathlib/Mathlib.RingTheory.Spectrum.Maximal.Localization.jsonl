{"name":"MaximalSpectrum.iInf_localization_eq_bot","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\nK : Type u_5\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Eq (iInf fun v => Localization.subalgebra.ofField K v.asIdeal.primeCompl ⋯) Bot.bot","decl":"/-- An integral domain is equal to the intersection of its localizations at all its maximal ideals\nviewed as subalgebras of its field of fractions. -/\ntheorem iInf_localization_eq_bot : (⨅ v : MaximalSpectrum R,\n    Localization.subalgebra.ofField K _ v.asIdeal.primeCompl_le_nonZeroDivisors) = ⊥ := by\n  ext x\n  rw [Algebra.mem_bot, Algebra.mem_iInf]\n  constructor\n  · contrapose\n    intro hrange hlocal\n    let denom : Ideal R := (1 : Submodule R K).comap (LinearMap.toSpanSingleton R K x)\n    have hdenom : (1 : R) ∉ denom := by simpa [denom] using hrange\n    rcases denom.exists_le_maximal (denom.ne_top_iff_one.mpr hdenom) with ⟨max, hmax, hle⟩\n    rcases hlocal ⟨max, hmax⟩ with ⟨n, d, hd, rfl⟩\n    exact hd (hle ⟨n, by simp [denom, Algebra.smul_def, mul_left_comm, mul_inv_cancel₀ <|\n      (map_ne_zero_iff _ <| IsFractionRing.injective R K).mpr fun h ↦ hd (h ▸ max.zero_mem :)]⟩)\n  · rintro ⟨y, rfl⟩ ⟨v, hv⟩\n    exact ⟨y, 1, v.ne_top_iff_one.mp hv.ne_top, by rw [map_one, inv_one, mul_one]⟩\n\n"}
{"name":"PrimeSpectrum.iInf_localization_eq_bot","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\nK : Type u_5\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Eq (iInf fun v => Localization.subalgebra.ofField K v.asIdeal.primeCompl ⋯) Bot.bot","decl":"/-- An integral domain is equal to the intersection of its localizations at all its prime ideals\nviewed as subalgebras of its field of fractions. -/\ntheorem iInf_localization_eq_bot : ⨅ v : PrimeSpectrum R,\n    Localization.subalgebra.ofField K _ (v.asIdeal.primeCompl_le_nonZeroDivisors) = ⊥ := by\n  refine bot_unique (.trans (fun _ ↦ ?_) (MaximalSpectrum.iInf_localization_eq_bot R K).le)\n  simpa only [Algebra.mem_iInf] using fun hx ⟨v, hv⟩ ↦ hx ⟨v, hv.isPrime⟩\n\n"}
{"name":"MaximalSpectrum.toPiLocalization_injective","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Function.Injective ⇑(MaximalSpectrum.toPiLocalization R)","decl":"theorem toPiLocalization_injective : Function.Injective (toPiLocalization R) := fun r r' eq ↦ by\n  rw [← one_mul r, ← one_mul r']\n  by_contra ne\n  have ⟨I, mI, hI⟩ := (Module.eqIdeal R r r').exists_le_maximal ((Ideal.ne_top_iff_one _).mpr ne)\n  have ⟨s, hs⟩ := (IsLocalization.eq_iff_exists I.primeCompl _).mp (congr_fun eq ⟨I, mI⟩)\n  exact s.2 (hI hs)\n\n"}
{"name":"MaximalSpectrum.toPiLocalization_apply_apply","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nr : R\nI : MaximalSpectrum R\n⊢ Eq ((MaximalSpectrum.toPiLocalization R) r I) ((algebraMap R (Localization.AtPrime I.asIdeal)) r)","decl":"theorem toPiLocalization_apply_apply {r I} : toPiLocalization R r I = algebraMap R _ r := rfl\n\n"}
{"name":"MaximalSpectrum.mapPiLocalization_naturality","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nhf : Function.Bijective ⇑f\n⊢ Eq ((MaximalSpectrum.mapPiLocalization f hf).comp (MaximalSpectrum.toPiLocalization R)) ((MaximalSpectrum.toPiLocalization S).comp f)","decl":"theorem mapPiLocalization_naturality :\n    (mapPiLocalization f hf).comp (toPiLocalization R) =\n      (toPiLocalization S).comp f := by\n  ext r I\n  show Localization.localRingHom _ _ _ rfl (algebraMap _ _ r) = algebraMap _ _ (f r)\n  simp_rw [← IsLocalization.mk'_one (M := (I.1.comap f).primeCompl), Localization.localRingHom_mk',\n    ← IsLocalization.mk'_one (M := I.1.primeCompl), Submonoid.coe_one, map_one f]\n  rfl\n\n"}
{"name":"MaximalSpectrum.mapPiLocalization_id","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (MaximalSpectrum.mapPiLocalization (RingHom.id R) ⋯) (RingHom.id (MaximalSpectrum.PiLocalization R))","decl":"theorem mapPiLocalization_id : mapPiLocalization (.id R) Function.bijective_id = .id _ :=\n  RingHom.ext fun _ ↦ funext fun _ ↦ congr($(Localization.localRingHom_id _) _)\n\n"}
{"name":"MaximalSpectrum.mapPiLocalization_comp","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\nS : Type u_2\nP : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : CommSemiring P\nf : RingHom R S\ng : RingHom S P\nhf : Function.Bijective ⇑f\nhg : Function.Bijective ⇑g\n⊢ Eq (MaximalSpectrum.mapPiLocalization (g.comp f) ⋯) ((MaximalSpectrum.mapPiLocalization g hg).comp (MaximalSpectrum.mapPiLocalization f hf))","decl":"theorem mapPiLocalization_comp :\n    mapPiLocalization (g.comp f) (hg.comp hf) =\n      (mapPiLocalization g hg).comp (mapPiLocalization f hf) :=\n  RingHom.ext fun _ ↦ funext fun _ ↦ congr($(Localization.localRingHom_comp _ _ _ _ rfl _ rfl) _)\n\n"}
{"name":"MaximalSpectrum.mapPiLocalization_bijective","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nhf : Function.Bijective ⇑f\n⊢ Function.Bijective ⇑(MaximalSpectrum.mapPiLocalization f hf)","decl":"theorem mapPiLocalization_bijective : Function.Bijective (mapPiLocalization f hf) := by\n  let f := RingEquiv.ofBijective f hf\n  let e := RingEquiv.ofRingHom (mapPiLocalization f hf)\n    (mapPiLocalization (f.symm : S →+* R) f.symm.bijective) ?_ ?_\n  · exact e.bijective\n  · rw [← mapPiLocalization_comp]\n    simp_rw [RingEquiv.comp_symm, mapPiLocalization_id]\n  · rw [← mapPiLocalization_comp]\n    simp_rw [RingEquiv.symm_comp, mapPiLocalization_id]\n\n"}
{"name":"MaximalSpectrum.toPiLocalization_not_surjective_of_infinite","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"ι : Type u_5\nR : ι → Type u_4\ninst✝² : (i : ι) → CommSemiring (R i)\ninst✝¹ : ∀ (i : ι), Nontrivial (R i)\ninst✝ : Infinite ι\n⊢ Not (Function.Surjective ⇑(MaximalSpectrum.toPiLocalization ((i : ι) → R i)))","decl":"theorem toPiLocalization_not_surjective_of_infinite [Infinite ι] :\n    ¬ Function.Surjective (toPiLocalization (Π i, R i)) := fun surj ↦ by\n  classical\n  have ⟨J, max, nmem⟩ := PrimeSpectrum.exists_maximal_nmem_range_sigmaToPi_of_infinite R\n  obtain ⟨r, hr⟩ := surj (Function.update 0 ⟨J, max⟩ 1)\n  have : r = 0 := funext fun i ↦ toPiLocalization_injective _ <| funext fun I ↦ by\n    replace hr := congr_fun hr ⟨_, I.2.comap_piEvalRingHom⟩\n    dsimp only [toPiLocalization_apply_apply, Subtype.coe_mk] at hr\n    simp_rw [toPiLocalization_apply_apply,\n      ← Localization.AtPrime.mapPiEvalRingHom_algebraMap_apply, hr]\n    rw [Function.update_of_ne]; · simp_rw [Pi.zero_apply, map_zero]\n    exact fun h ↦ nmem ⟨⟨i, I.1, I.2.isPrime⟩, PrimeSpectrum.ext congr($h.1)⟩\n  replace hr := congr_fun hr ⟨J, max⟩\n  rw [this, map_zero, Function.update_self] at hr\n  exact zero_ne_one hr\n\n"}
{"name":"MaximalSpectrum.finite_of_toPiLocalization_pi_surjective","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"ι : Type u_5\nR : ι → Type u_4\ninst✝¹ : (i : ι) → CommSemiring (R i)\ninst✝ : ∀ (i : ι), Nontrivial (R i)\nh : Function.Surjective ⇑(MaximalSpectrum.toPiLocalization ((i : ι) → R i))\n⊢ Finite ι","decl":"theorem finite_of_toPiLocalization_pi_surjective\n    (h : Function.Surjective (toPiLocalization (Π i, R i))) :\n    Finite ι := by\n  contrapose h; rw [not_finite_iff_infinite] at h\n  exact toPiLocalization_not_surjective_of_infinite _\n\n"}
{"name":"MaximalSpectrum.finite_of_toPiLocalization_surjective","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nsurj : Function.Surjective ⇑(MaximalSpectrum.toPiLocalization R)\n⊢ Finite (MaximalSpectrum R)","decl":"theorem finite_of_toPiLocalization_surjective\n    (surj : Function.Surjective (toPiLocalization R)) :\n    Finite (MaximalSpectrum R) := by\n  replace surj := mapPiLocalization_bijective _ ⟨toPiLocalization_injective R, surj⟩\n    |>.2.comp surj\n  rw [← RingHom.coe_comp, mapPiLocalization_naturality, RingHom.coe_comp] at surj\n  exact finite_of_toPiLocalization_pi_surjective surj.of_comp\n\n"}
{"name":"PrimeSpectrum.toPiLocalization_injective","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Function.Injective ⇑(PrimeSpectrum.toPiLocalization R)","decl":"theorem toPiLocalization_injective : Function.Injective (toPiLocalization R) :=\n  fun _ _ eq ↦ MaximalSpectrum.toPiLocalization_injective R <|\n    funext fun I ↦ congr_fun eq I.toPrimeSpectrum\n\n"}
{"name":"PrimeSpectrum.piLocalizationToMaximal_surjective","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Function.Surjective ⇑(PrimeSpectrum.piLocalizationToMaximal R)","decl":"open scoped Classical in\ntheorem piLocalizationToMaximal_surjective : Function.Surjective (piLocalizationToMaximal R) :=\n  fun r ↦ ⟨fun I ↦ if h : I.1.IsMaximal then r ⟨_, h⟩ else 0, funext fun _ ↦ dif_pos _⟩\n\n"}
{"name":"PrimeSpectrum.piLocalizationToMaximal_bijective","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nh : ∀ (I : Ideal R), I.IsPrime → I.IsMaximal\n⊢ Function.Bijective ⇑(PrimeSpectrum.piLocalizationToMaximal R)","decl":"theorem piLocalizationToMaximal_bijective (h : ∀ I : Ideal R, I.IsPrime → I.IsMaximal) :\n    Function.Bijective (piLocalizationToMaximal R) :=\n  (piLocalizationToMaximalEquiv h).bijective\n\n"}
{"name":"PrimeSpectrum.piLocalizationToMaximal_comp_toPiLocalization","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq ((PrimeSpectrum.piLocalizationToMaximal R).comp (PrimeSpectrum.toPiLocalization R)) (MaximalSpectrum.toPiLocalization R)","decl":"theorem piLocalizationToMaximal_comp_toPiLocalization :\n    (piLocalizationToMaximal R).comp (toPiLocalization R) = MaximalSpectrum.toPiLocalization R :=\n  rfl\n\n"}
{"name":"PrimeSpectrum.isMaximal_of_toPiLocalization_surjective","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nsurj : Function.Surjective ⇑(PrimeSpectrum.toPiLocalization R)\nI : PrimeSpectrum R\n⊢ I.asIdeal.IsMaximal","decl":"theorem isMaximal_of_toPiLocalization_surjective (surj : Function.Surjective (toPiLocalization R))\n    (I : PrimeSpectrum R) : I.1.IsMaximal := by\n  classical\n  have ⟨J, max, le⟩ := I.1.exists_le_maximal I.2.ne_top\n  obtain ⟨r, hr⟩ := surj (Function.update 0 ⟨J, max.isPrime⟩ 1)\n  by_contra h\n  have hJ : algebraMap _ _ r = _ := (congr_fun hr _).trans (Function.update_self ..)\n  have hI : algebraMap _ _ r = _ := congr_fun hr I\n  rw [← IsLocalization.lift_eq (M := J.primeCompl) (S := Localization J.primeCompl), hJ, map_one,\n    Function.update_of_ne] at hI\n  · exact one_ne_zero hI\n  · intro eq; have : I.1 = J := congr_arg (·.1) eq; exact h (this ▸ max)\n  · exact fun ⟨s, hs⟩ ↦ IsLocalization.map_units (M := I.1.primeCompl) _ ⟨s, fun h ↦ hs (le h)⟩\n\n"}
{"name":"PrimeSpectrum.mapPiLocalization_naturality","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\n⊢ Eq ((PrimeSpectrum.mapPiLocalization f).comp (PrimeSpectrum.toPiLocalization R)) ((PrimeSpectrum.toPiLocalization S).comp f)","decl":"theorem mapPiLocalization_naturality :\n    (mapPiLocalization f).comp (toPiLocalization R) = (toPiLocalization S).comp f := by\n  ext r I\n  show Localization.localRingHom _ _ _ rfl (algebraMap _ _ r) = algebraMap _ _ (f r)\n  simp_rw [← IsLocalization.mk'_one (M := (I.1.comap f).primeCompl), Localization.localRingHom_mk',\n    ← IsLocalization.mk'_one (M := I.1.primeCompl), Submonoid.coe_one, map_one f]\n  rfl\n\n"}
{"name":"PrimeSpectrum.mapPiLocalization_id","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (PrimeSpectrum.mapPiLocalization (RingHom.id R)) (RingHom.id (PrimeSpectrum.PiLocalization R))","decl":"theorem mapPiLocalization_id : mapPiLocalization (.id R) = .id _ := by\n  ext; exact congr($(Localization.localRingHom_id _) _)\n\n"}
{"name":"PrimeSpectrum.mapPiLocalization_comp","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\nS : Type u_2\nP : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : CommSemiring P\nf : RingHom R S\ng : RingHom S P\n⊢ Eq (PrimeSpectrum.mapPiLocalization (g.comp f)) ((PrimeSpectrum.mapPiLocalization g).comp (PrimeSpectrum.mapPiLocalization f))","decl":"theorem mapPiLocalization_comp (g : S →+* P) :\n    mapPiLocalization (g.comp f) = (mapPiLocalization g).comp (mapPiLocalization f) := by\n  ext; exact congr($(Localization.localRingHom_comp _ _ _ _ rfl _ rfl) _)\n\n"}
{"name":"PrimeSpectrum.mapPiLocalization_bijective","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nhf : Function.Bijective ⇑f\n⊢ Function.Bijective ⇑(PrimeSpectrum.mapPiLocalization f)","decl":"theorem mapPiLocalization_bijective (hf : Function.Bijective f) :\n    Function.Bijective (mapPiLocalization f) := by\n  let f := RingEquiv.ofBijective f hf\n  let e := RingEquiv.ofRingHom (mapPiLocalization (f : R →+* S)) (mapPiLocalization f.symm) ?_ ?_\n  · exact e.bijective\n  · rw [← mapPiLocalization_comp, RingEquiv.comp_symm, mapPiLocalization_id]\n  · rw [← mapPiLocalization_comp, RingEquiv.symm_comp, mapPiLocalization_id]\n\n"}
{"name":"PrimeSpectrum.toPiLocalization_not_surjective_of_infinite","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"ι : Type u_5\nR : ι → Type u_4\ninst✝² : (i : ι) → CommSemiring (R i)\ninst✝¹ : ∀ (i : ι), Nontrivial (R i)\ninst✝ : Infinite ι\n⊢ Not (Function.Surjective ⇑(PrimeSpectrum.toPiLocalization ((i : ι) → R i)))","decl":"theorem toPiLocalization_not_surjective_of_infinite [Infinite ι] :\n    ¬ Function.Surjective (toPiLocalization (Π i, R i)) :=\n  fun surj ↦ MaximalSpectrum.toPiLocalization_not_surjective_of_infinite R <| by\n    rw [← piLocalizationToMaximal_comp_toPiLocalization]\n    exact (piLocalizationToMaximal_surjective _).comp surj\n\n"}
{"name":"PrimeSpectrum.finite_of_toPiLocalization_pi_surjective","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"ι : Type u_5\nR : ι → Type u_4\ninst✝¹ : (i : ι) → CommSemiring (R i)\ninst✝ : ∀ (i : ι), Nontrivial (R i)\nh : Function.Surjective ⇑(PrimeSpectrum.toPiLocalization ((i : ι) → R i))\n⊢ Finite ι","decl":"theorem finite_of_toPiLocalization_pi_surjective\n    (h : Function.Surjective (toPiLocalization (Π i, R i))) :\n    Finite ι := by\n  contrapose h; rw [not_finite_iff_infinite] at h\n  exact toPiLocalization_not_surjective_of_infinite _\n\n"}
{"name":"PrimeSpectrum.finite_of_toPiLocalization_surjective","module":"Mathlib.RingTheory.Spectrum.Maximal.Localization","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nsurj : Function.Surjective ⇑(PrimeSpectrum.toPiLocalization R)\n⊢ Finite (PrimeSpectrum R)","decl":"theorem finite_of_toPiLocalization_surjective\n    (surj : Function.Surjective (toPiLocalization R)) :\n    Finite (PrimeSpectrum R) := by\n  replace surj := (mapPiLocalization_bijective _ ⟨toPiLocalization_injective R, surj⟩).2.comp surj\n  rw [← RingHom.coe_comp, mapPiLocalization_naturality, RingHom.coe_comp] at surj\n  exact finite_of_toPiLocalization_pi_surjective surj.of_comp\n\n"}
