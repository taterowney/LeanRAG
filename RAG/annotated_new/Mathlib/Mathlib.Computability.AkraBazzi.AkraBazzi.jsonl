{"name":"AkraBazziRecurrence.a_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\ninst‚úù : Nonempty Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\nself : AkraBazziRecurrence T g a b r\ni : Œ±\n‚ä¢ LT.lt 0 (a i)","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (‚àë i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {Œ± : Type*} [Fintype Œ±] [Nonempty Œ±]\n    (T : ‚Ñï ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) where\n  /-- Point below which the recurrence is in the base case -/\n  n‚ÇÄ : ‚Ñï\n  /-- `n‚ÇÄ` is always `> 0` -/\n  n‚ÇÄ_gt_zero : 0 < n‚ÇÄ\n  /-- The `a`'s are nonzero -/\n  a_pos : ‚àÄ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ‚àÄ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ‚àÄ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ‚Ñï) (hn‚ÇÄ : n‚ÇÄ ‚â§ n) : T n = (‚àë i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n‚ÇÄ` -/\n  T_gt_zero' (n : ‚Ñï) (hn : n < n‚ÇÄ) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ‚àÄ i n, n‚ÇÄ ‚â§ n ‚Üí r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ‚àÄ i, (fun n => (r i n : ‚Ñù) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.mk.sizeOf_spec","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Fintype Œ±\ninst‚úù¬π : Nonempty Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : SizeOf Œ±\nn‚ÇÄ : Nat\nn‚ÇÄ_gt_zero : LT.lt 0 n‚ÇÄ\na_pos : ‚àÄ (i : Œ±), LT.lt 0 (a i)\nb_pos : ‚àÄ (i : Œ±), LT.lt 0 (b i)\nb_lt_one : ‚àÄ (i : Œ±), LT.lt (b i) 1\ng_nonneg : ‚àÄ (x : Real), GE.ge x 0 ‚Üí LE.le 0 (g x)\ng_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\nh_rec : ‚àÄ (n : Nat), LE.le n‚ÇÄ n ‚Üí Eq (T n) (HAdd.hAdd (Finset.univ.sum fun i => HMul.hMul (a i) (T (r i n))) (g ‚Üën))\nT_gt_zero' : ‚àÄ (n : Nat), LT.lt n n‚ÇÄ ‚Üí LT.lt 0 (T n)\nr_lt_n : ‚àÄ (i : Œ±) (n : Nat), LE.le n‚ÇÄ n ‚Üí LT.lt (r i n) n\ndist_r_b : ‚àÄ (i : Œ±), Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (‚Üë(r i n)) (HMul.hMul (b i) ‚Üën)) fun n => HDiv.hDiv (‚Üën) (HPow.hPow (Real.log ‚Üën) 2)\n‚ä¢ Eq (SizeOf.sizeOf { n‚ÇÄ := n‚ÇÄ, n‚ÇÄ_gt_zero := n‚ÇÄ_gt_zero, a_pos := a_pos, b_pos := b_pos, b_lt_one := b_lt_one, g_nonneg := g_nonneg, g_grows_poly := g_grows_poly, h_rec := h_rec, T_gt_zero' := T_gt_zero', r_lt_n := r_lt_n, dist_r_b := dist_r_b }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf n‚ÇÄ)) (SizeOf.sizeOf n‚ÇÄ_gt_zero))","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (‚àë i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {Œ± : Type*} [Fintype Œ±] [Nonempty Œ±]\n    (T : ‚Ñï ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) where\n  /-- Point below which the recurrence is in the base case -/\n  n‚ÇÄ : ‚Ñï\n  /-- `n‚ÇÄ` is always `> 0` -/\n  n‚ÇÄ_gt_zero : 0 < n‚ÇÄ\n  /-- The `a`'s are nonzero -/\n  a_pos : ‚àÄ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ‚àÄ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ‚àÄ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ‚Ñï) (hn‚ÇÄ : n‚ÇÄ ‚â§ n) : T n = (‚àë i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n‚ÇÄ` -/\n  T_gt_zero' (n : ‚Ñï) (hn : n < n‚ÇÄ) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ‚àÄ i n, n‚ÇÄ ‚â§ n ‚Üí r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ‚àÄ i, (fun n => (r i n : ‚Ñù) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.b_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\ninst‚úù : Nonempty Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\nself : AkraBazziRecurrence T g a b r\ni : Œ±\n‚ä¢ LT.lt 0 (b i)","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (‚àë i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {Œ± : Type*} [Fintype Œ±] [Nonempty Œ±]\n    (T : ‚Ñï ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) where\n  /-- Point below which the recurrence is in the base case -/\n  n‚ÇÄ : ‚Ñï\n  /-- `n‚ÇÄ` is always `> 0` -/\n  n‚ÇÄ_gt_zero : 0 < n‚ÇÄ\n  /-- The `a`'s are nonzero -/\n  a_pos : ‚àÄ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ‚àÄ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ‚àÄ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ‚Ñï) (hn‚ÇÄ : n‚ÇÄ ‚â§ n) : T n = (‚àë i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n‚ÇÄ` -/\n  T_gt_zero' (n : ‚Ñï) (hn : n < n‚ÇÄ) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ‚àÄ i n, n‚ÇÄ ‚â§ n ‚Üí r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ‚àÄ i, (fun n => (r i n : ‚Ñù) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.h_rec","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\ninst‚úù : Nonempty Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\nself : AkraBazziRecurrence T g a b r\nn : Nat\nhn‚ÇÄ : LE.le self.n‚ÇÄ n\n‚ä¢ Eq (T n) (HAdd.hAdd (Finset.univ.sum fun i => HMul.hMul (a i) (T (r i n))) (g ‚Üën))","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (‚àë i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {Œ± : Type*} [Fintype Œ±] [Nonempty Œ±]\n    (T : ‚Ñï ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) where\n  /-- Point below which the recurrence is in the base case -/\n  n‚ÇÄ : ‚Ñï\n  /-- `n‚ÇÄ` is always `> 0` -/\n  n‚ÇÄ_gt_zero : 0 < n‚ÇÄ\n  /-- The `a`'s are nonzero -/\n  a_pos : ‚àÄ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ‚àÄ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ‚àÄ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ‚Ñï) (hn‚ÇÄ : n‚ÇÄ ‚â§ n) : T n = (‚àë i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n‚ÇÄ` -/\n  T_gt_zero' (n : ‚Ñï) (hn : n < n‚ÇÄ) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ‚àÄ i n, n‚ÇÄ ‚â§ n ‚Üí r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ‚àÄ i, (fun n => (r i n : ‚Ñù) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.r_lt_n","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\ninst‚úù : Nonempty Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\nself : AkraBazziRecurrence T g a b r\ni : Œ±\nn : Nat\na‚úù : LE.le self.n‚ÇÄ n\n‚ä¢ LT.lt (r i n) n","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (‚àë i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {Œ± : Type*} [Fintype Œ±] [Nonempty Œ±]\n    (T : ‚Ñï ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) where\n  /-- Point below which the recurrence is in the base case -/\n  n‚ÇÄ : ‚Ñï\n  /-- `n‚ÇÄ` is always `> 0` -/\n  n‚ÇÄ_gt_zero : 0 < n‚ÇÄ\n  /-- The `a`'s are nonzero -/\n  a_pos : ‚àÄ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ‚àÄ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ‚àÄ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ‚Ñï) (hn‚ÇÄ : n‚ÇÄ ‚â§ n) : T n = (‚àë i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n‚ÇÄ` -/\n  T_gt_zero' (n : ‚Ñï) (hn : n < n‚ÇÄ) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ‚àÄ i n, n‚ÇÄ ‚â§ n ‚Üí r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ‚àÄ i, (fun n => (r i n : ‚Ñù) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.b_lt_one","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\ninst‚úù : Nonempty Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\nself : AkraBazziRecurrence T g a b r\ni : Œ±\n‚ä¢ LT.lt (b i) 1","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (‚àë i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {Œ± : Type*} [Fintype Œ±] [Nonempty Œ±]\n    (T : ‚Ñï ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) where\n  /-- Point below which the recurrence is in the base case -/\n  n‚ÇÄ : ‚Ñï\n  /-- `n‚ÇÄ` is always `> 0` -/\n  n‚ÇÄ_gt_zero : 0 < n‚ÇÄ\n  /-- The `a`'s are nonzero -/\n  a_pos : ‚àÄ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ‚àÄ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ‚àÄ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ‚Ñï) (hn‚ÇÄ : n‚ÇÄ ‚â§ n) : T n = (‚àë i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n‚ÇÄ` -/\n  T_gt_zero' (n : ‚Ñï) (hn : n < n‚ÇÄ) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ‚àÄ i n, n‚ÇÄ ‚â§ n ‚Üí r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ‚àÄ i, (fun n => (r i n : ‚Ñù) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.g_nonneg","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\ninst‚úù : Nonempty Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\nself : AkraBazziRecurrence T g a b r\nx : Real\na‚úù : GE.ge x 0\n‚ä¢ LE.le 0 (g x)","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (‚àë i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {Œ± : Type*} [Fintype Œ±] [Nonempty Œ±]\n    (T : ‚Ñï ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) where\n  /-- Point below which the recurrence is in the base case -/\n  n‚ÇÄ : ‚Ñï\n  /-- `n‚ÇÄ` is always `> 0` -/\n  n‚ÇÄ_gt_zero : 0 < n‚ÇÄ\n  /-- The `a`'s are nonzero -/\n  a_pos : ‚àÄ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ‚àÄ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ‚àÄ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ‚Ñï) (hn‚ÇÄ : n‚ÇÄ ‚â§ n) : T n = (‚àë i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n‚ÇÄ` -/\n  T_gt_zero' (n : ‚Ñï) (hn : n < n‚ÇÄ) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ‚àÄ i n, n‚ÇÄ ‚â§ n ‚Üí r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ‚àÄ i, (fun n => (r i n : ‚Ñù) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.dist_r_b","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\ninst‚úù : Nonempty Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\nself : AkraBazziRecurrence T g a b r\ni : Œ±\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (‚Üë(r i n)) (HMul.hMul (b i) ‚Üën)) fun n => HDiv.hDiv (‚Üën) (HPow.hPow (Real.log ‚Üën) 2)","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (‚àë i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {Œ± : Type*} [Fintype Œ±] [Nonempty Œ±]\n    (T : ‚Ñï ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) where\n  /-- Point below which the recurrence is in the base case -/\n  n‚ÇÄ : ‚Ñï\n  /-- `n‚ÇÄ` is always `> 0` -/\n  n‚ÇÄ_gt_zero : 0 < n‚ÇÄ\n  /-- The `a`'s are nonzero -/\n  a_pos : ‚àÄ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ‚àÄ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ‚àÄ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ‚Ñï) (hn‚ÇÄ : n‚ÇÄ ‚â§ n) : T n = (‚àë i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n‚ÇÄ` -/\n  T_gt_zero' (n : ‚Ñï) (hn : n < n‚ÇÄ) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ‚àÄ i n, n‚ÇÄ ‚â§ n ‚Üí r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ‚àÄ i, (fun n => (r i n : ‚Ñù) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.mk.injEq","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\ninst‚úù : Nonempty Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\nn‚ÇÄ‚úù : Nat\nn‚ÇÄ_gt_zero‚úù : LT.lt 0 n‚ÇÄ‚úù\na_pos‚úù : ‚àÄ (i : Œ±), LT.lt 0 (a i)\nb_pos‚úù : ‚àÄ (i : Œ±), LT.lt 0 (b i)\nb_lt_one‚úù : ‚àÄ (i : Œ±), LT.lt (b i) 1\ng_nonneg‚úù : ‚àÄ (x : Real), GE.ge x 0 ‚Üí LE.le 0 (g x)\ng_grows_poly‚úù : AkraBazziRecurrence.GrowsPolynomially g\nh_rec‚úù : ‚àÄ (n : Nat), LE.le n‚ÇÄ‚úù n ‚Üí Eq (T n) (HAdd.hAdd (Finset.univ.sum fun i => HMul.hMul (a i) (T (r i n))) (g ‚Üën))\nT_gt_zero'‚úù : ‚àÄ (n : Nat), LT.lt n n‚ÇÄ‚úù ‚Üí LT.lt 0 (T n)\nr_lt_n‚úù : ‚àÄ (i : Œ±) (n : Nat), LE.le n‚ÇÄ‚úù n ‚Üí LT.lt (r i n) n\ndist_r_b‚úù : ‚àÄ (i : Œ±), Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (‚Üë(r i n)) (HMul.hMul (b i) ‚Üën)) fun n => HDiv.hDiv (‚Üën) (HPow.hPow (Real.log ‚Üën) 2)\nn‚ÇÄ : Nat\nn‚ÇÄ_gt_zero : LT.lt 0 n‚ÇÄ\na_pos : ‚àÄ (i : Œ±), LT.lt 0 (a i)\nb_pos : ‚àÄ (i : Œ±), LT.lt 0 (b i)\nb_lt_one : ‚àÄ (i : Œ±), LT.lt (b i) 1\ng_nonneg : ‚àÄ (x : Real), GE.ge x 0 ‚Üí LE.le 0 (g x)\ng_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\nh_rec : ‚àÄ (n : Nat), LE.le n‚ÇÄ n ‚Üí Eq (T n) (HAdd.hAdd (Finset.univ.sum fun i => HMul.hMul (a i) (T (r i n))) (g ‚Üën))\nT_gt_zero' : ‚àÄ (n : Nat), LT.lt n n‚ÇÄ ‚Üí LT.lt 0 (T n)\nr_lt_n : ‚àÄ (i : Œ±) (n : Nat), LE.le n‚ÇÄ n ‚Üí LT.lt (r i n) n\ndist_r_b : ‚àÄ (i : Œ±), Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (‚Üë(r i n)) (HMul.hMul (b i) ‚Üën)) fun n => HDiv.hDiv (‚Üën) (HPow.hPow (Real.log ‚Üën) 2)\n‚ä¢ Eq (Eq { n‚ÇÄ := n‚ÇÄ‚úù, n‚ÇÄ_gt_zero := n‚ÇÄ_gt_zero‚úù, a_pos := a_pos‚úù, b_pos := b_pos‚úù, b_lt_one := b_lt_one‚úù, g_nonneg := g_nonneg‚úù, g_grows_poly := g_grows_poly‚úù, h_rec := h_rec‚úù, T_gt_zero' := T_gt_zero'‚úù, r_lt_n := r_lt_n‚úù, dist_r_b := dist_r_b‚úù } { n‚ÇÄ := n‚ÇÄ, n‚ÇÄ_gt_zero := n‚ÇÄ_gt_zero, a_pos := a_pos, b_pos := b_pos, b_lt_one := b_lt_one, g_nonneg := g_nonneg, g_grows_poly := g_grows_poly, h_rec := h_rec, T_gt_zero' := T_gt_zero', r_lt_n := r_lt_n, dist_r_b := dist_r_b }) (Eq n‚ÇÄ‚úù n‚ÇÄ)","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (‚àë i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {Œ± : Type*} [Fintype Œ±] [Nonempty Œ±]\n    (T : ‚Ñï ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) where\n  /-- Point below which the recurrence is in the base case -/\n  n‚ÇÄ : ‚Ñï\n  /-- `n‚ÇÄ` is always `> 0` -/\n  n‚ÇÄ_gt_zero : 0 < n‚ÇÄ\n  /-- The `a`'s are nonzero -/\n  a_pos : ‚àÄ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ‚àÄ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ‚àÄ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ‚Ñï) (hn‚ÇÄ : n‚ÇÄ ‚â§ n) : T n = (‚àë i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n‚ÇÄ` -/\n  T_gt_zero' (n : ‚Ñï) (hn : n < n‚ÇÄ) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ‚àÄ i n, n‚ÇÄ ‚â§ n ‚Üí r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ‚àÄ i, (fun n => (r i n : ‚Ñù) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.n‚ÇÄ_gt_zero","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\ninst‚úù : Nonempty Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\nself : AkraBazziRecurrence T g a b r\n‚ä¢ LT.lt 0 self.n‚ÇÄ","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (‚àë i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {Œ± : Type*} [Fintype Œ±] [Nonempty Œ±]\n    (T : ‚Ñï ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) where\n  /-- Point below which the recurrence is in the base case -/\n  n‚ÇÄ : ‚Ñï\n  /-- `n‚ÇÄ` is always `> 0` -/\n  n‚ÇÄ_gt_zero : 0 < n‚ÇÄ\n  /-- The `a`'s are nonzero -/\n  a_pos : ‚àÄ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ‚àÄ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ‚àÄ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ‚Ñï) (hn‚ÇÄ : n‚ÇÄ ‚â§ n) : T n = (‚àë i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n‚ÇÄ` -/\n  T_gt_zero' (n : ‚Ñï) (hn : n < n‚ÇÄ) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ‚àÄ i n, n‚ÇÄ ‚â§ n ‚Üí r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ‚àÄ i, (fun n => (r i n : ‚Ñù) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.T_gt_zero'","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\ninst‚úù : Nonempty Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\nself : AkraBazziRecurrence T g a b r\nn : Nat\nhn : LT.lt n self.n‚ÇÄ\n‚ä¢ LT.lt 0 (T n)","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (‚àë i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {Œ± : Type*} [Fintype Œ±] [Nonempty Œ±]\n    (T : ‚Ñï ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) where\n  /-- Point below which the recurrence is in the base case -/\n  n‚ÇÄ : ‚Ñï\n  /-- `n‚ÇÄ` is always `> 0` -/\n  n‚ÇÄ_gt_zero : 0 < n‚ÇÄ\n  /-- The `a`'s are nonzero -/\n  a_pos : ‚àÄ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ‚àÄ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ‚àÄ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ‚Ñï) (hn‚ÇÄ : n‚ÇÄ ‚â§ n) : T n = (‚àë i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n‚ÇÄ` -/\n  T_gt_zero' (n : ‚Ñï) (hn : n < n‚ÇÄ) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ‚àÄ i n, n‚ÇÄ ‚â§ n ‚Üí r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ‚àÄ i, (fun n => (r i n : ‚Ñù) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.mk.inj","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\ninst‚úù : Nonempty Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\nn‚ÇÄ‚úù : Nat\nn‚ÇÄ_gt_zero‚úù : LT.lt 0 n‚ÇÄ‚úù\na_pos‚úù : ‚àÄ (i : Œ±), LT.lt 0 (a i)\nb_pos‚úù : ‚àÄ (i : Œ±), LT.lt 0 (b i)\nb_lt_one‚úù : ‚àÄ (i : Œ±), LT.lt (b i) 1\ng_nonneg‚úù : ‚àÄ (x : Real), GE.ge x 0 ‚Üí LE.le 0 (g x)\ng_grows_poly‚úù : AkraBazziRecurrence.GrowsPolynomially g\nh_rec‚úù : ‚àÄ (n : Nat), LE.le n‚ÇÄ‚úù n ‚Üí Eq (T n) (HAdd.hAdd (Finset.univ.sum fun i => HMul.hMul (a i) (T (r i n))) (g ‚Üën))\nT_gt_zero'‚úù : ‚àÄ (n : Nat), LT.lt n n‚ÇÄ‚úù ‚Üí LT.lt 0 (T n)\nr_lt_n‚úù : ‚àÄ (i : Œ±) (n : Nat), LE.le n‚ÇÄ‚úù n ‚Üí LT.lt (r i n) n\ndist_r_b‚úù : ‚àÄ (i : Œ±), Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (‚Üë(r i n)) (HMul.hMul (b i) ‚Üën)) fun n => HDiv.hDiv (‚Üën) (HPow.hPow (Real.log ‚Üën) 2)\nn‚ÇÄ : Nat\nn‚ÇÄ_gt_zero : LT.lt 0 n‚ÇÄ\na_pos : ‚àÄ (i : Œ±), LT.lt 0 (a i)\nb_pos : ‚àÄ (i : Œ±), LT.lt 0 (b i)\nb_lt_one : ‚àÄ (i : Œ±), LT.lt (b i) 1\ng_nonneg : ‚àÄ (x : Real), GE.ge x 0 ‚Üí LE.le 0 (g x)\ng_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\nh_rec : ‚àÄ (n : Nat), LE.le n‚ÇÄ n ‚Üí Eq (T n) (HAdd.hAdd (Finset.univ.sum fun i => HMul.hMul (a i) (T (r i n))) (g ‚Üën))\nT_gt_zero' : ‚àÄ (n : Nat), LT.lt n n‚ÇÄ ‚Üí LT.lt 0 (T n)\nr_lt_n : ‚àÄ (i : Œ±) (n : Nat), LE.le n‚ÇÄ n ‚Üí LT.lt (r i n) n\ndist_r_b : ‚àÄ (i : Œ±), Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (‚Üë(r i n)) (HMul.hMul (b i) ‚Üën)) fun n => HDiv.hDiv (‚Üën) (HPow.hPow (Real.log ‚Üën) 2)\nx‚úù : Eq { n‚ÇÄ := n‚ÇÄ‚úù, n‚ÇÄ_gt_zero := n‚ÇÄ_gt_zero‚úù, a_pos := a_pos‚úù, b_pos := b_pos‚úù, b_lt_one := b_lt_one‚úù, g_nonneg := g_nonneg‚úù, g_grows_poly := g_grows_poly‚úù, h_rec := h_rec‚úù, T_gt_zero' := T_gt_zero'‚úù, r_lt_n := r_lt_n‚úù, dist_r_b := dist_r_b‚úù } { n‚ÇÄ := n‚ÇÄ, n‚ÇÄ_gt_zero := n‚ÇÄ_gt_zero, a_pos := a_pos, b_pos := b_pos, b_lt_one := b_lt_one, g_nonneg := g_nonneg, g_grows_poly := g_grows_poly, h_rec := h_rec, T_gt_zero' := T_gt_zero', r_lt_n := r_lt_n, dist_r_b := dist_r_b }\n‚ä¢ Eq n‚ÇÄ‚úù n‚ÇÄ","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (‚àë i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {Œ± : Type*} [Fintype Œ±] [Nonempty Œ±]\n    (T : ‚Ñï ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) where\n  /-- Point below which the recurrence is in the base case -/\n  n‚ÇÄ : ‚Ñï\n  /-- `n‚ÇÄ` is always `> 0` -/\n  n‚ÇÄ_gt_zero : 0 < n‚ÇÄ\n  /-- The `a`'s are nonzero -/\n  a_pos : ‚àÄ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ‚àÄ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ‚àÄ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ‚Ñï) (hn‚ÇÄ : n‚ÇÄ ‚â§ n) : T n = (‚àë i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n‚ÇÄ` -/\n  T_gt_zero' (n : ‚Ñï) (hn : n < n‚ÇÄ) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ‚àÄ i n, n‚ÇÄ ‚â§ n ‚Üí r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ‚àÄ i, (fun n => (r i n : ‚Ñù) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.g_grows_poly","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\ninst‚úù : Nonempty Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\nself : AkraBazziRecurrence T g a b r\n‚ä¢ AkraBazziRecurrence.GrowsPolynomially g","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (‚àë i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {Œ± : Type*} [Fintype Œ±] [Nonempty Œ±]\n    (T : ‚Ñï ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù) (a : Œ± ‚Üí ‚Ñù) (b : Œ± ‚Üí ‚Ñù) (r : Œ± ‚Üí ‚Ñï ‚Üí ‚Ñï) where\n  /-- Point below which the recurrence is in the base case -/\n  n‚ÇÄ : ‚Ñï\n  /-- `n‚ÇÄ` is always `> 0` -/\n  n‚ÇÄ_gt_zero : 0 < n‚ÇÄ\n  /-- The `a`'s are nonzero -/\n  a_pos : ‚àÄ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ‚àÄ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ‚àÄ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ‚Ñï) (hn‚ÇÄ : n‚ÇÄ ‚â§ n) : T n = (‚àë i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n‚ÇÄ` -/\n  T_gt_zero' (n : ‚Ñï) (hn : n < n‚ÇÄ) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ‚àÄ i n, n‚ÇÄ ‚â§ n ‚Üí r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ‚àÄ i, (fun n => (r i n : ‚Ñù) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.min_bi_le","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Finite Œ±\ninst‚úù : Nonempty Œ±\nb : Œ± ‚Üí Real\ni : Œ±\n‚ä¢ LE.le (b (AkraBazziRecurrence.min_bi b)) (b i)","decl":"@[aesop safe apply]\nlemma min_bi_le {b : Œ± ‚Üí ‚Ñù} (i : Œ±) : b (min_bi b) ‚â§ b i :=\n  Classical.choose_spec (Finite.exists_min b) i\n\n"}
{"name":"AkraBazziRecurrence.max_bi_le","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Finite Œ±\ninst‚úù : Nonempty Œ±\nb : Œ± ‚Üí Real\ni : Œ±\n‚ä¢ LE.le (b i) (b (AkraBazziRecurrence.max_bi b))","decl":"@[aesop safe apply]\nlemma max_bi_le {b : Œ± ‚Üí ‚Ñù} (i : Œ±) : b i ‚â§ b (max_bi b) :=\n  Classical.choose_spec (Finite.exists_max b) i\n\n"}
{"name":"AkraBazziRecurrence.isLittleO_self_div_log_id","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun n => HDiv.hDiv (‚Üën) (HPow.hPow (Real.log ‚Üën) 2)) fun n => ‚Üën","decl":"lemma isLittleO_self_div_log_id :\n    (fun (n : ‚Ñï) => n / log n ^ 2) =o[atTop] (fun (n : ‚Ñï) => (n : ‚Ñù)) := by\n  calc (fun (n : ‚Ñï) => (n : ‚Ñù) / log n ^ 2) = fun (n : ‚Ñï) => (n : ‚Ñù) * ((log n) ^ 2)‚Åª¬π := by\n                  simp_rw [div_eq_mul_inv]\n         _ =o[atTop] fun (n : ‚Ñï) => (n : ‚Ñù) * 1‚Åª¬π := by\n                  refine IsBigO.mul_isLittleO (isBigO_refl _ _) ?_\n                  refine IsLittleO.inv_rev ?main ?zero\n                  case zero => simp\n                  case main => calc\n                    _ = (fun (_ : ‚Ñï) => ((1 : ‚Ñù) ^ 2))     := by simp\n                    _ =o[atTop] (fun (n : ‚Ñï) => (log n)^2) :=\n                          IsLittleO.pow (IsLittleO.natCast_atTop\n                            <| isLittleO_const_log_atTop) (by norm_num)\n         _ = (fun (n : ‚Ñï) => (n : ‚Ñù)) := by ext; simp\n\n"}
{"name":"AkraBazziRecurrence.dist_r_b'","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Eventually (fun n => ‚àÄ (i : Œ±), LE.le (Norm.norm (HSub.hSub (‚Üë(r i n)) (HMul.hMul (b i) ‚Üën))) (HDiv.hDiv (‚Üën) (HPow.hPow (Real.log ‚Üën) 2))) Filter.atTop","decl":"lemma dist_r_b' : ‚àÄ·∂† n in atTop, ‚àÄ i, ‚Äñ(r i n : ‚Ñù) - b i * n‚Äñ ‚â§ n / log n ^ 2 := by\n  rw [Filter.eventually_all]\n  intro i\n  simpa using IsLittleO.eventuallyLE (R.dist_r_b i)\n\n"}
{"name":"AkraBazziRecurrence.eventually_b_le_r","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Eventually (fun n => ‚àÄ (i : Œ±), LE.le (HSub.hSub (HMul.hMul (b i) ‚Üën) (HDiv.hDiv (‚Üën) (HPow.hPow (Real.log ‚Üën) 2))) ‚Üë(r i n)) Filter.atTop","decl":"lemma eventually_b_le_r : ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, (b i : ‚Ñù) * n - (n / log n ^ 2) ‚â§ r i n := by\n  filter_upwards [R.dist_r_b'] with n hn\n  intro i\n  have h‚ÇÅ : 0 ‚â§ b i := le_of_lt <| R.b_pos _\n  rw [sub_le_iff_le_add, add_comm, ‚Üê sub_le_iff_le_add]\n  calc (b i : ‚Ñù) * n - r i n = ‚Äñb i * n‚Äñ - ‚Äñ(r i n : ‚Ñù)‚Äñ := by\n                            simp only [norm_mul, RCLike.norm_natCast, sub_left_inj,\n                                       Nat.cast_eq_zero, Real.norm_of_nonneg h‚ÇÅ]\n                         _ ‚â§ ‚Äñ(b i * n : ‚Ñù) - r i n‚Äñ := norm_sub_norm_le _ _\n                         _ = ‚Äñ(r i n : ‚Ñù) - b i * n‚Äñ := norm_sub_rev _ _\n                         _ ‚â§ n / log n ^ 2 := hn i\n\n"}
{"name":"AkraBazziRecurrence.eventually_r_le_b","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Eventually (fun n => ‚àÄ (i : Œ±), LE.le (‚Üë(r i n)) (HAdd.hAdd (HMul.hMul (b i) ‚Üën) (HDiv.hDiv (‚Üën) (HPow.hPow (Real.log ‚Üën) 2)))) Filter.atTop","decl":"lemma eventually_r_le_b : ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, r i n ‚â§ (b i : ‚Ñù) * n + (n / log n ^ 2) := by\n  filter_upwards [R.dist_r_b'] with n hn\n  intro i\n  calc r i n = b i * n + (r i n - b i * n) := by ring\n             _ ‚â§ b i * n + ‚Äñr i n - b i * n‚Äñ := by gcongr; exact Real.le_norm_self _\n             _ ‚â§ b i * n + n / log n ^ 2 := by gcongr; exact hn i\n\n"}
{"name":"AkraBazziRecurrence.eventually_r_lt_n","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Eventually (fun n => ‚àÄ (i : Œ±), LT.lt (r i n) n) Filter.atTop","decl":"lemma eventually_r_lt_n : ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, r i n < n := by\n  filter_upwards [eventually_ge_atTop R.n‚ÇÄ] with n hn\n  exact fun i => R.r_lt_n i n hn\n\n"}
{"name":"AkraBazziRecurrence.eventually_bi_mul_le_r","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Eventually (fun n => ‚àÄ (i : Œ±), LE.le (HMul.hMul (HDiv.hDiv (b (AkraBazziRecurrence.min_bi b)) 2) ‚Üën) ‚Üë(r i n)) Filter.atTop","decl":"lemma eventually_bi_mul_le_r : ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, (b (min_bi b) / 2) * n ‚â§ r i n := by\n  have gt_zero : 0 < b (min_bi b) := R.b_pos (min_bi b)\n  have hlo := isLittleO_self_div_log_id\n  rw [Asymptotics.isLittleO_iff] at hlo\n  have hlo' := hlo (by positivity : 0 < b (min_bi b) / 2)\n  filter_upwards [hlo', R.eventually_b_le_r] with n hn hn'\n  intro i\n  simp only [Real.norm_of_nonneg (by positivity : 0 ‚â§ (n : ‚Ñù))] at hn\n  calc b (min_bi b) / 2 * n = b (min_bi b) * n - b (min_bi b) / 2 * n := by ring\n                          _ ‚â§ b (min_bi b) * n - ‚Äñn / log n ^ 2‚Äñ := by gcongr\n                          _ ‚â§ b i * n - ‚Äñn / log n ^ 2‚Äñ := by gcongr; aesop\n                          _ = b i * n - n / log n ^ 2 := by\n                                congr\n                                exact Real.norm_of_nonneg <| by positivity\n                          _ ‚â§ r i n := hn' i\n\n"}
{"name":"AkraBazziRecurrence.bi_min_div_two_lt_one","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ LT.lt (HDiv.hDiv (b (AkraBazziRecurrence.min_bi b)) 2) 1","decl":"lemma bi_min_div_two_lt_one : b (min_bi b) / 2 < 1 := by\n  have gt_zero : 0 < b (min_bi b) := R.b_pos (min_bi b)\n  calc b (min_bi b) / 2 < b (min_bi b) := by aesop (add safe apply div_two_lt_of_pos)\n                      _ < 1 := R.b_lt_one _\n\n"}
{"name":"AkraBazziRecurrence.bi_min_div_two_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ LT.lt 0 (HDiv.hDiv (b (AkraBazziRecurrence.min_bi b)) 2)","decl":"lemma bi_min_div_two_pos : 0 < b (min_bi b) / 2 := div_pos (R.b_pos _) (by norm_num)\n\n"}
{"name":"AkraBazziRecurrence.exists_eventually_const_mul_le_r","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Exists fun c => And (Membership.mem (Set.Ioo 0 1) c) (Filter.Eventually (fun n => ‚àÄ (i : Œ±), LE.le (HMul.hMul c ‚Üën) ‚Üë(r i n)) Filter.atTop)","decl":"lemma exists_eventually_const_mul_le_r :\n    ‚àÉ c ‚àà Set.Ioo (0 : ‚Ñù) 1, ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, c * n ‚â§ r i n := by\n  have gt_zero : 0 < b (min_bi b) := R.b_pos (min_bi b)\n  exact ‚ü®b (min_bi b) / 2, ‚ü®‚ü®by positivity, R.bi_min_div_two_lt_one‚ü©, R.eventually_bi_mul_le_r‚ü©‚ü©\n\n"}
{"name":"AkraBazziRecurrence.eventually_r_ge","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\nC : Real\n‚ä¢ Filter.Eventually (fun n => ‚àÄ (i : Œ±), LE.le C ‚Üë(r i n)) Filter.atTop","decl":"lemma eventually_r_ge (C : ‚Ñù) : ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, C ‚â§ r i n := by\n  obtain ‚ü®c, hc_mem, hc‚ü© := R.exists_eventually_const_mul_le_r\n  filter_upwards [eventually_ge_atTop ‚åàC / c‚åâ‚Çä, hc] with n hn‚ÇÅ hn‚ÇÇ\n  have h‚ÇÅ := hc_mem.1\n  intro i\n  calc C = c * (C / c) := by\n            rw [‚Üê mul_div_assoc]\n            exact (mul_div_cancel_left‚ÇÄ _ (by positivity)).symm\n       _ ‚â§ c * ‚åàC / c‚åâ‚Çä := by gcongr; simp [Nat.le_ceil]\n       _ ‚â§ c * n := by gcongr\n       _ ‚â§ r i n := hn‚ÇÇ i\n\n"}
{"name":"AkraBazziRecurrence.tendsto_atTop_r","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\ni : Œ±\n‚ä¢ Filter.Tendsto (r i) Filter.atTop Filter.atTop","decl":"lemma tendsto_atTop_r (i : Œ±) : Tendsto (r i) atTop atTop := by\n  rw [tendsto_atTop]\n  intro b\n  have := R.eventually_r_ge b\n  rw [Filter.eventually_all] at this\n  exact_mod_cast this i\n\n"}
{"name":"AkraBazziRecurrence.tendsto_atTop_r_real","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\ni : Œ±\n‚ä¢ Filter.Tendsto (fun n => ‚Üë(r i n)) Filter.atTop Filter.atTop","decl":"lemma tendsto_atTop_r_real (i : Œ±) : Tendsto (fun n => (r i n : ‚Ñù)) atTop atTop :=\n  Tendsto.comp tendsto_natCast_atTop_atTop (R.tendsto_atTop_r i)\n\n"}
{"name":"AkraBazziRecurrence.exists_eventually_r_le_const_mul","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Exists fun c => And (Membership.mem (Set.Ioo 0 1) c) (Filter.Eventually (fun n => ‚àÄ (i : Œ±), LE.le (‚Üë(r i n)) (HMul.hMul c ‚Üën)) Filter.atTop)","decl":"lemma exists_eventually_r_le_const_mul :\n    ‚àÉ c ‚àà Set.Ioo (0 : ‚Ñù) 1, ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, r i n ‚â§ c * n := by\n  let c := b (max_bi b) + (1 - b (max_bi b)) / 2\n  have h_max_bi_pos : 0 < b (max_bi b) := R.b_pos _\n  have h_max_bi_lt_one : 0 < 1 - b (max_bi b) := by\n    have : b (max_bi b) < 1 := R.b_lt_one _\n    linarith\n  have hc_pos : 0 < c := by positivity\n  have h‚ÇÅ : 0 < (1 - b (max_bi b)) / 2 := by positivity\n  have hc_lt_one : c < 1 :=\n    calc b (max_bi b) + (1 - b (max_bi b)) / 2 = b (max_bi b) * (1 / 2) + 1 / 2 := by ring\n                                             _ < 1 * (1 / 2) + 1 / 2 := by\n                                                  gcongr\n                                                  exact R.b_lt_one _\n                                             _ = 1 := by norm_num\n  refine ‚ü®c, ‚ü®hc_pos, hc_lt_one‚ü©, ?_‚ü©\n  have hlo := isLittleO_self_div_log_id\n  rw [Asymptotics.isLittleO_iff] at hlo\n  have hlo' := hlo h‚ÇÅ\n  filter_upwards [hlo', R.eventually_r_le_b] with n hn hn'\n  intro i\n  rw [Real.norm_of_nonneg (by positivity)] at hn\n  simp only [Real.norm_of_nonneg (by positivity : 0 ‚â§ (n : ‚Ñù))] at hn\n  calc r i n ‚â§ b i * n + n / log n ^ 2 := by exact hn' i\n             _ ‚â§ b i * n + (1 - b (max_bi b)) / 2 * n := by gcongr\n             _ = (b i + (1 - b (max_bi b)) / 2) * n := by ring\n             _ ‚â§ (b (max_bi b) + (1 - b (max_bi b)) / 2) * n := by gcongr; exact max_bi_le _\n\n"}
{"name":"AkraBazziRecurrence.eventually_r_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Eventually (fun n => ‚àÄ (i : Œ±), LT.lt 0 (r i n)) Filter.atTop","decl":"lemma eventually_r_pos : ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, 0 < r i n := by\n  rw [Filter.eventually_all]\n  exact fun i => (R.tendsto_atTop_r i).eventually_gt_atTop 0\n\n"}
{"name":"AkraBazziRecurrence.eventually_log_b_mul_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Eventually (fun n => ‚àÄ (i : Œ±), LT.lt 0 (Real.log (HMul.hMul (b i) ‚Üën))) Filter.atTop","decl":"lemma eventually_log_b_mul_pos : ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, 0 < log (b i * n) := by\n  rw [Filter.eventually_all]\n  intro i\n  have h : Tendsto (fun (n : ‚Ñï) => log (b i * n)) atTop atTop :=\n    Tendsto.comp tendsto_log_atTop\n      <| Tendsto.const_mul_atTop (b_pos R i) tendsto_natCast_atTop_atTop\n  exact h.eventually_gt_atTop 0\n\n"}
{"name":"AkraBazziRecurrence.T_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\nn : Nat\n‚ä¢ LT.lt 0 (T n)","decl":"@[aesop safe apply] lemma T_pos (n : ‚Ñï) : 0 < T n := by\n  induction n using Nat.strongRecOn with\n  | ind n h_ind =>\n    cases lt_or_le n R.n‚ÇÄ with\n    | inl hn => exact R.T_gt_zero' n hn -- n < R.n‚ÇÄ\n    | inr hn => -- R.n‚ÇÄ ‚â§ n\n      rw [R.h_rec n hn]\n      have := R.g_nonneg\n      refine add_pos_of_pos_of_nonneg (Finset.sum_pos ?sum_elems univ_nonempty) (by aesop)\n      exact fun i _ => mul_pos (R.a_pos i) <| h_ind _ (R.r_lt_n i _ hn)\n\n"}
{"name":"AkraBazziRecurrence.T_nonneg","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\nn : Nat\n‚ä¢ LE.le 0 (T n)","decl":"@[aesop safe apply]\nlemma T_nonneg (n : ‚Ñï) : 0 ‚â§ T n := le_of_lt <| R.T_pos n\n\n"}
{"name":"AkraBazziRecurrence.one_add_smoothingFn_le_two","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"x : Real\nhx : LE.le (Real.exp 1) x\n‚ä¢ LE.le (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn x)) 2","decl":"lemma one_add_smoothingFn_le_two {x : ‚Ñù} (hx : exp 1 ‚â§ x) : 1 + Œµ x ‚â§ 2 := by\n  simp only [smoothingFn, ‚Üê one_add_one_eq_two]\n  gcongr\n  have : 1 < x := by\n    calc 1 = exp 0 := by simp\n         _ < exp 1 := by simp\n         _ ‚â§ x := hx\n  rw [div_le_one (log_pos this)]\n  calc 1 = log (exp 1) := by simp\n       _ ‚â§ log x := log_le_log (exp_pos _) hx\n\n"}
{"name":"AkraBazziRecurrence.isLittleO_smoothingFn_one","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Asymptotics.IsLittleO Filter.atTop AkraBazziRecurrence.smoothingFn fun x => 1","decl":"lemma isLittleO_smoothingFn_one : Œµ =o[atTop] (fun _ => (1 : ‚Ñù)) := by\n  unfold smoothingFn\n  refine isLittleO_of_tendsto (fun _ h => False.elim <| one_ne_zero h) ?_\n  simp only [one_div, div_one]\n  exact Tendsto.inv_tendsto_atTop Real.tendsto_log_atTop\n\n"}
{"name":"AkraBazziRecurrence.isEquivalent_one_add_smoothingFn_one","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Asymptotics.IsEquivalent Filter.atTop (fun x => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn x)) fun x => 1","decl":"lemma isEquivalent_one_add_smoothingFn_one : (fun x => 1 + Œµ x) ~[atTop] (fun _ => (1 : ‚Ñù)) :=\n  IsEquivalent.add_isLittleO IsEquivalent.refl isLittleO_smoothingFn_one\n\n"}
{"name":"AkraBazziRecurrence.isEquivalent_one_sub_smoothingFn_one","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Asymptotics.IsEquivalent Filter.atTop (fun x => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x)) fun x => 1","decl":"lemma isEquivalent_one_sub_smoothingFn_one : (fun x => 1 - Œµ x) ~[atTop] (fun _ => (1 : ‚Ñù)) :=\n  IsEquivalent.sub_isLittleO IsEquivalent.refl isLittleO_smoothingFn_one\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ AkraBazziRecurrence.GrowsPolynomially fun x => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x)","decl":"lemma growsPolynomially_one_sub_smoothingFn : GrowsPolynomially fun x => 1 - Œµ x :=\n  GrowsPolynomially.of_isEquivalent_const isEquivalent_one_sub_smoothingFn_one\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ AkraBazziRecurrence.GrowsPolynomially fun x => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn x)","decl":"lemma growsPolynomially_one_add_smoothingFn : GrowsPolynomially fun x => 1 + Œµ x :=\n  GrowsPolynomially.of_isEquivalent_const isEquivalent_one_add_smoothingFn_one\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_sub_smoothingFn_gt_const_real","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"c : Real\nhc : LT.lt c 1\n‚ä¢ Filter.Eventually (fun x => LT.lt c (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x))) Filter.atTop","decl":"lemma eventually_one_sub_smoothingFn_gt_const_real (c : ‚Ñù) (hc : c < 1) :\n    ‚àÄ·∂† (x : ‚Ñù) in atTop, c < 1 - Œµ x := by\n  have h‚ÇÅ : Tendsto (fun x => 1 - Œµ x) atTop (ùìù 1) := by\n    rw [‚Üê isEquivalent_const_iff_tendsto one_ne_zero]\n    exact isEquivalent_one_sub_smoothingFn_one\n  rw [tendsto_order] at h‚ÇÅ\n  exact h‚ÇÅ.1 c hc\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_sub_smoothingFn_gt_const","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"c : Real\nhc : LT.lt c 1\n‚ä¢ Filter.Eventually (fun n => LT.lt c (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ‚Üën))) Filter.atTop","decl":"lemma eventually_one_sub_smoothingFn_gt_const (c : ‚Ñù) (hc : c < 1) :\n    ‚àÄ·∂† (n : ‚Ñï) in atTop, c < 1 - Œµ n :=\n  Eventually.natCast_atTop (p := fun n => c < 1 - Œµ n)\n    <| eventually_one_sub_smoothingFn_gt_const_real c hc\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_sub_smoothingFn_pos_real","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Filter.Eventually (fun x => LT.lt 0 (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x))) Filter.atTop","decl":"lemma eventually_one_sub_smoothingFn_pos_real : ‚àÄ·∂† (x : ‚Ñù) in atTop, 0 < 1 - Œµ x :=\n  eventually_one_sub_smoothingFn_gt_const_real 0 zero_lt_one\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_sub_smoothingFn_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Filter.Eventually (fun n => LT.lt 0 (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ‚Üën))) Filter.atTop","decl":"lemma eventually_one_sub_smoothingFn_pos : ‚àÄ·∂† (n : ‚Ñï) in atTop, 0 < 1 - Œµ n :=\n  (eventually_one_sub_smoothingFn_pos_real).natCast_atTop\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_sub_smoothingFn_nonneg","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Filter.Eventually (fun n => LE.le 0 (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ‚Üën))) Filter.atTop","decl":"lemma eventually_one_sub_smoothingFn_nonneg : ‚àÄ·∂† (n : ‚Ñï) in atTop, 0 ‚â§ 1 - Œµ n := by\n  filter_upwards [eventually_one_sub_smoothingFn_pos] with n hn; exact le_of_lt hn\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_sub_smoothingFn_r_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Eventually (fun n => ‚àÄ (i : Œ±), LT.lt 0 (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ‚Üë(r i n)))) Filter.atTop","decl":"include R in\nlemma eventually_one_sub_smoothingFn_r_pos : ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, 0 < 1 - Œµ (r i n) := by\n  rw [Filter.eventually_all]\n  exact fun i => (R.tendsto_atTop_r_real i).eventually eventually_one_sub_smoothingFn_pos_real\n\n"}
{"name":"AkraBazziRecurrence.differentiableAt_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"x : Real\nhx : LT.lt 1 x\n‚ä¢ DifferentiableAt Real AkraBazziRecurrence.smoothingFn x","decl":"@[aesop safe apply]\nlemma differentiableAt_smoothingFn {x : ‚Ñù} (hx : 1 < x) : DifferentiableAt ‚Ñù Œµ x := by\n  have : log x ‚â† 0 := Real.log_ne_zero_of_pos_of_ne_one (by positivity) (ne_of_gt hx)\n  show DifferentiableAt ‚Ñù (fun z => 1 / log z) x\n  simp_rw [one_div]\n  exact DifferentiableAt.inv (differentiableAt_log (by positivity)) this\n\n"}
{"name":"AkraBazziRecurrence.differentiableAt_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"x : Real\nhx : LT.lt 1 x\n‚ä¢ DifferentiableAt Real (fun z => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z)) x","decl":"@[aesop safe apply]\nlemma differentiableAt_one_sub_smoothingFn {x : ‚Ñù} (hx : 1 < x) :\n    DifferentiableAt ‚Ñù (fun z => 1 - Œµ z) x :=\n  DifferentiableAt.sub (differentiableAt_const _) <| differentiableAt_smoothingFn hx\n\n"}
{"name":"AkraBazziRecurrence.differentiableOn_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ DifferentiableOn Real (fun z => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z)) (Set.Ioi 1)","decl":"lemma differentiableOn_one_sub_smoothingFn : DifferentiableOn ‚Ñù (fun z => 1 - Œµ z) (Set.Ioi 1) :=\n  fun _ hx => (differentiableAt_one_sub_smoothingFn hx).differentiableWithinAt\n\n"}
{"name":"AkraBazziRecurrence.differentiableAt_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"x : Real\nhx : LT.lt 1 x\n‚ä¢ DifferentiableAt Real (fun z => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z)) x","decl":"@[aesop safe apply]\nlemma differentiableAt_one_add_smoothingFn {x : ‚Ñù} (hx : 1 < x) :\n    DifferentiableAt ‚Ñù (fun z => 1 + Œµ z) x :=\n  DifferentiableAt.add (differentiableAt_const _) <| differentiableAt_smoothingFn hx\n\n"}
{"name":"AkraBazziRecurrence.differentiableOn_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ DifferentiableOn Real (fun z => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z)) (Set.Ioi 1)","decl":"lemma differentiableOn_one_add_smoothingFn : DifferentiableOn ‚Ñù (fun z => 1 + Œµ z) (Set.Ioi 1) :=\n  fun _ hx => (differentiableAt_one_add_smoothingFn hx).differentiableWithinAt\n\n"}
{"name":"AkraBazziRecurrence.deriv_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"x : Real\nhx : LT.lt 1 x\n‚ä¢ Eq (deriv AkraBazziRecurrence.smoothingFn x) (HDiv.hDiv (Neg.neg (Inv.inv x)) (HPow.hPow (Real.log x) 2))","decl":"lemma deriv_smoothingFn {x : ‚Ñù} (hx : 1 < x) : deriv Œµ x = -x‚Åª¬π / (log x ^ 2) := by\n  have : log x ‚â† 0 := Real.log_ne_zero_of_pos_of_ne_one (by positivity) (ne_of_gt hx)\n  show deriv (fun z => 1 / log z) x = -x‚Åª¬π / (log x ^ 2)\n  rw [deriv_div] <;> aesop\n\n"}
{"name":"AkraBazziRecurrence.isLittleO_deriv_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Asymptotics.IsLittleO Filter.atTop (deriv AkraBazziRecurrence.smoothingFn) fun x => Inv.inv x","decl":"lemma isLittleO_deriv_smoothingFn : deriv Œµ =o[atTop] fun x => x‚Åª¬π := calc\n  deriv Œµ =·∂†[atTop] fun x => -x‚Åª¬π / (log x ^ 2) := by\n            filter_upwards [eventually_gt_atTop 1] with x hx\n            rw [deriv_smoothingFn hx]\n    _ = fun x => (-x * log x ^ 2)‚Åª¬π := by\n            simp_rw [neg_div, div_eq_mul_inv, ‚Üê mul_inv, neg_inv, neg_mul]\n    _ =o[atTop] fun x => (x * 1)‚Åª¬π := by\n            refine IsLittleO.inv_rev ?_ ?_\n            ¬∑ refine IsBigO.mul_isLittleO\n                (by rw [isBigO_neg_right]; aesop (add safe isBigO_refl)) ?_\n              rw [isLittleO_one_left_iff]\n              exact Tendsto.comp tendsto_norm_atTop_atTop\n                <| Tendsto.comp (tendsto_pow_atTop (by norm_num)) tendsto_log_atTop\n            ¬∑ exact Filter.Eventually.of_forall (fun x hx => by rw [mul_one] at hx; simp [hx])\n    _ = fun x => x‚Åª¬π := by simp\n\n"}
{"name":"AkraBazziRecurrence.eventually_deriv_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Filter.atTop.EventuallyEq (deriv fun x => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x)) fun x => HDiv.hDiv (Inv.inv x) (HPow.hPow (Real.log x) 2)","decl":"lemma eventually_deriv_one_sub_smoothingFn :\n    deriv (fun x => 1 - Œµ x) =·∂†[atTop] fun x => x‚Åª¬π / (log x ^ 2) := calc\n  deriv (fun x => 1 - Œµ x) =·∂†[atTop] -(deriv Œµ) := by\n        filter_upwards [eventually_gt_atTop 1] with x hx; rw [deriv_sub] <;> aesop\n    _ =·∂†[atTop] fun x => x‚Åª¬π / (log x ^ 2) := by\n        filter_upwards [eventually_gt_atTop 1] with x hx\n        simp [deriv_smoothingFn hx, neg_div]\n\n"}
{"name":"AkraBazziRecurrence.eventually_deriv_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Filter.atTop.EventuallyEq (deriv fun x => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn x)) fun x => HDiv.hDiv (Neg.neg (Inv.inv x)) (HPow.hPow (Real.log x) 2)","decl":"lemma eventually_deriv_one_add_smoothingFn :\n    deriv (fun x => 1 + Œµ x) =·∂†[atTop] fun x => -x‚Åª¬π / (log x ^ 2) := calc\n  deriv (fun x => 1 + Œµ x) =·∂†[atTop] deriv Œµ := by\n          filter_upwards [eventually_gt_atTop 1] with x hx; rw [deriv_add] <;> aesop\n    _ =·∂†[atTop] fun x => -x‚Åª¬π / (log x ^ 2) := by\n          filter_upwards [eventually_gt_atTop 1] with x hx\n          simp [deriv_smoothingFn hx]\n\n"}
{"name":"AkraBazziRecurrence.isLittleO_deriv_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Asymptotics.IsLittleO Filter.atTop (deriv fun x => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x)) fun x => Inv.inv x","decl":"lemma isLittleO_deriv_one_sub_smoothingFn :\n    deriv (fun x => 1 - Œµ x) =o[atTop] fun (x : ‚Ñù) => x‚Åª¬π := calc\n  deriv (fun x => 1 - Œµ x) =·∂†[atTop] fun z => -(deriv Œµ z) := by\n          filter_upwards [eventually_gt_atTop 1] with x hx; rw [deriv_sub] <;> aesop\n    _ =o[atTop] fun x => x‚Åª¬π := by rw [isLittleO_neg_left]; exact isLittleO_deriv_smoothingFn\n\n"}
{"name":"AkraBazziRecurrence.isLittleO_deriv_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Asymptotics.IsLittleO Filter.atTop (deriv fun x => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn x)) fun x => Inv.inv x","decl":"lemma isLittleO_deriv_one_add_smoothingFn :\n    deriv (fun x => 1 + Œµ x) =o[atTop] fun (x : ‚Ñù) => x‚Åª¬π := calc\n  deriv (fun x => 1 + Œµ x) =·∂†[atTop] fun z => deriv Œµ z := by\n          filter_upwards [eventually_gt_atTop 1] with x hx; rw [deriv_add] <;> aesop\n    _ =o[atTop] fun x => x‚Åª¬π := isLittleO_deriv_smoothingFn\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_add_smoothingFn_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Filter.Eventually (fun n => LT.lt 0 (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn ‚Üën))) Filter.atTop","decl":"lemma eventually_one_add_smoothingFn_pos : ‚àÄ·∂† (n : ‚Ñï) in atTop, 0 < 1 + Œµ n := by\n  have h‚ÇÅ := isLittleO_smoothingFn_one\n  rw [isLittleO_iff] at h‚ÇÅ\n  refine Eventually.natCast_atTop (p := fun n => 0 < 1 + Œµ n) ?_\n  filter_upwards [h‚ÇÅ (by norm_num : (0 : ‚Ñù) < 1/2), eventually_gt_atTop 1] with x _ hx'\n  have : 0 < log x := Real.log_pos hx'\n  show 0 < 1 + 1 / log x\n  positivity\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_add_smoothingFn_r_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Eventually (fun n => ‚àÄ (i : Œ±), LT.lt 0 (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn ‚Üë(r i n)))) Filter.atTop","decl":"include R in\nlemma eventually_one_add_smoothingFn_r_pos : ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, 0 < 1 + Œµ (r i n) := by\n  rw [Filter.eventually_all]\n  exact fun i => (R.tendsto_atTop_r i).eventually (f := r i) eventually_one_add_smoothingFn_pos\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_add_smoothingFn_nonneg","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ Filter.Eventually (fun n => LE.le 0 (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn ‚Üën))) Filter.atTop","decl":"lemma eventually_one_add_smoothingFn_nonneg : ‚àÄ·∂† (n : ‚Ñï) in atTop, 0 ‚â§ 1 + Œµ n := by\n  filter_upwards [eventually_one_add_smoothingFn_pos] with n hn; exact le_of_lt hn\n\n"}
{"name":"AkraBazziRecurrence.strictAntiOn_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ StrictAntiOn AkraBazziRecurrence.smoothingFn (Set.Ioi 1)","decl":"lemma strictAntiOn_smoothingFn : StrictAntiOn Œµ (Set.Ioi 1) := by\n  show StrictAntiOn (fun x => 1 / log x) (Set.Ioi 1)\n  simp_rw [one_div]\n  refine StrictAntiOn.comp_strictMonoOn inv_strictAntiOn ?log fun _ hx => log_pos hx\n  refine StrictMonoOn.mono strictMonoOn_log (fun x hx => ?_)\n  exact Set.Ioi_subset_Ioi zero_le_one hx\n\n"}
{"name":"AkraBazziRecurrence.strictMonoOn_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ StrictMonoOn (fun x => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x)) (Set.Ioi 1)","decl":"lemma strictMonoOn_one_sub_smoothingFn :\n    StrictMonoOn (fun (x : ‚Ñù) => (1 : ‚Ñù) - Œµ x) (Set.Ioi 1) := by\n  simp_rw [sub_eq_add_neg]\n  exact StrictMonoOn.const_add (StrictAntiOn.neg <| strictAntiOn_smoothingFn) 1\n\n"}
{"name":"AkraBazziRecurrence.strictAntiOn_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"‚ä¢ StrictAntiOn (fun x => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn x)) (Set.Ioi 1)","decl":"lemma strictAntiOn_one_add_smoothingFn : StrictAntiOn (fun (x : ‚Ñù) => (1 : ‚Ñù) + Œµ x) (Set.Ioi 1) :=\n  StrictAntiOn.const_add strictAntiOn_smoothingFn 1\n\n"}
{"name":"AkraBazziRecurrence.isEquivalent_smoothingFn_sub_self","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\ni : Œ±\n‚ä¢ Asymptotics.IsEquivalent Filter.atTop (fun n => HSub.hSub (AkraBazziRecurrence.smoothingFn (HMul.hMul (b i) ‚Üën)) (AkraBazziRecurrence.smoothingFn ‚Üën)) fun n => HDiv.hDiv (Neg.neg (Real.log (b i))) (HPow.hPow (Real.log ‚Üën) 2)","decl":"lemma isEquivalent_smoothingFn_sub_self (i : Œ±) :\n    (fun (n : ‚Ñï) => Œµ (b i * n) - Œµ n) ~[atTop] fun n => -log (b i) / (log n)^2 := by\n  calc (fun (n : ‚Ñï) => 1 / log (b i * n) - 1 / log n)\n        =·∂†[atTop] fun (n : ‚Ñï) => (log n - log (b i * n)) / (log (b i * n) * log n) := by\n            filter_upwards [eventually_gt_atTop 1, R.eventually_log_b_mul_pos] with n hn hn'\n            have h_log_pos : 0 < log n := Real.log_pos <| by aesop\n            simp only [one_div]\n            rw [inv_sub_inv (by have := hn' i; positivity) (by aesop)]\n      _ =·∂†[atTop] (fun (n : ‚Ñï) ‚Ü¶ (log n - log (b i) - log n) / ((log (b i) + log n) * log n)) := by\n            filter_upwards [eventually_ne_atTop 0] with n hn\n            have : 0 < b i := R.b_pos i\n            rw [log_mul (by positivity) (by aesop), sub_add_eq_sub_sub]\n      _ = (fun (n : ‚Ñï) => -log (b i) / ((log (b i) + log n) * log n)) := by ext; congr; ring\n      _ ~[atTop] (fun (n : ‚Ñï) => -log (b i) / (log n * log n)) := by\n            refine IsEquivalent.div (IsEquivalent.refl) <| IsEquivalent.mul ?_ (IsEquivalent.refl)\n            have : (fun (n : ‚Ñï) => log (b i) + log n) = fun (n : ‚Ñï) => log n + log (b i) := by\n              ext; simp [add_comm]\n            rw [this]\n            exact IsEquivalent.add_isLittleO IsEquivalent.refl\n              <| IsLittleO.natCast_atTop (f := fun (_ : ‚Ñù) => log (b i))\n                isLittleO_const_log_atTop\n      _ = (fun (n : ‚Ñï) => -log (b i) / (log n)^2) := by ext; congr 1; rw [‚Üê pow_two]\n\n"}
{"name":"AkraBazziRecurrence.isTheta_smoothingFn_sub_self","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\ni : Œ±\n‚ä¢ Asymptotics.IsTheta Filter.atTop (fun n => HSub.hSub (AkraBazziRecurrence.smoothingFn (HMul.hMul (b i) ‚Üën)) (AkraBazziRecurrence.smoothingFn ‚Üën)) fun n => HDiv.hDiv 1 (HPow.hPow (Real.log ‚Üën) 2)","decl":"lemma isTheta_smoothingFn_sub_self (i : Œ±) :\n    (fun (n : ‚Ñï) => Œµ (b i * n) - Œµ n) =Œò[atTop] fun n => 1 / (log n)^2 := by\n  calc (fun (n : ‚Ñï) => Œµ (b i * n) - Œµ n) =Œò[atTop] fun n => (-log (b i)) / (log n)^2 := by\n                  exact (R.isEquivalent_smoothingFn_sub_self i).isTheta\n    _ = fun (n : ‚Ñï) => (-log (b i)) * 1 / (log n)^2 := by simp only [mul_one]\n    _ = fun (n : ‚Ñï) => -log (b i) * (1 / (log n)^2) := by simp_rw [‚Üê mul_div_assoc]\n    _ =Œò[atTop] fun (n : ‚Ñï) => 1 / (log n)^2 := by\n                  have : -log (b i) ‚â† 0 := by\n                    rw [neg_ne_zero]\n                    exact Real.log_ne_zero_of_pos_of_ne_one\n                            (R.b_pos i) (ne_of_lt <| R.b_lt_one i)\n                  rw [‚Üê isTheta_const_mul_right this]\n\n\n"}
{"name":"AkraBazziRecurrence.continuous_sumCoeffsExp","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Continuous fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)","decl":"@[continuity]\nlemma continuous_sumCoeffsExp : Continuous (fun (p : ‚Ñù) => ‚àë i, a i * (b i) ^ p) := by\n  refine continuous_finset_sum Finset.univ fun i _ => Continuous.mul (by continuity) ?_\n  exact Continuous.rpow continuous_const continuous_id (fun x => Or.inl (ne_of_gt (R.b_pos i)))\n\n"}
{"name":"AkraBazziRecurrence.strictAnti_sumCoeffsExp","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ StrictAnti fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)","decl":"lemma strictAnti_sumCoeffsExp : StrictAnti (fun (p : ‚Ñù) => ‚àë i, a i * (b i) ^ p) := by\n  rw [‚Üê Finset.sum_fn]\n  refine Finset.sum_induction_nonempty _ _ (fun _ _ => StrictAnti.add) univ_nonempty ?terms\n  refine fun i _ => StrictAnti.const_mul ?_ (R.a_pos i)\n  exact Real.strictAnti_rpow_of_base_lt_one (R.b_pos i) (R.b_lt_one i)\n\n"}
{"name":"AkraBazziRecurrence.tendsto_zero_sumCoeffsExp","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Tendsto (fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)) Filter.atTop (nhds 0)","decl":"lemma tendsto_zero_sumCoeffsExp : Tendsto (fun (p : ‚Ñù) => ‚àë i, a i * (b i) ^ p) atTop (ùìù 0) := by\n  have h‚ÇÅ : Finset.univ.sum (fun _ : Œ± => (0 : ‚Ñù)) = 0 := by simp\n  rw [‚Üê h‚ÇÅ]\n  refine tendsto_finset_sum (univ : Finset Œ±) (fun i _ => ?_)\n  rw [‚Üê mul_zero (a i)]\n  refine Tendsto.mul (by simp) <| tendsto_rpow_atTop_of_base_lt_one _ ?_ (R.b_lt_one i)\n  have := R.b_pos i\n  linarith\n\n"}
{"name":"AkraBazziRecurrence.tendsto_atTop_sumCoeffsExp","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Tendsto (fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)) Filter.atBot Filter.atTop","decl":"lemma tendsto_atTop_sumCoeffsExp : Tendsto (fun (p : ‚Ñù) => ‚àë i, a i * (b i) ^ p) atBot atTop := by\n  have h‚ÇÅ : Tendsto (fun p : ‚Ñù => (a (max_bi b) : ‚Ñù) * b (max_bi b) ^ p) atBot atTop :=\n    Tendsto.mul_atTop (R.a_pos (max_bi b)) (by simp)\n      <| tendsto_rpow_atBot_of_base_lt_one _\n      (by have := R.b_pos (max_bi b); linarith) (R.b_lt_one _)\n  refine tendsto_atTop_mono (fun p => ?_) h‚ÇÅ\n  refine Finset.single_le_sum (f := fun i => (a i : ‚Ñù) * b i ^ p) (fun i _ => ?_) (mem_univ _)\n  have h‚ÇÅ : 0 < a i := R.a_pos i\n  have h‚ÇÇ : 0 < b i := R.b_pos i\n  positivity\n\n"}
{"name":"AkraBazziRecurrence.one_mem_range_sumCoeffsExp","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Membership.mem (Set.range fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)) 1","decl":"lemma one_mem_range_sumCoeffsExp : 1 ‚àà Set.range (fun (p : ‚Ñù) => ‚àë i, a i * (b i) ^ p) := by\n  refine mem_range_of_exists_le_of_exists_ge R.continuous_sumCoeffsExp ?le_one ?ge_one\n  case le_one =>\n    exact R.tendsto_zero_sumCoeffsExp.eventually_le_const zero_lt_one |>.exists\n  case ge_one =>\n    exact R.tendsto_atTop_sumCoeffsExp.eventually_ge_atTop _ |>.exists\n\n"}
{"name":"AkraBazziRecurrence.injective_sumCoeffsExp","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Function.Injective fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)","decl":"/-- The function x ‚Ü¶ ‚àë a_i b_i^x is injective. This implies the uniqueness of `p`. -/\nlemma injective_sumCoeffsExp : Function.Injective (fun (p : ‚Ñù) => ‚àë i, a i * (b i) ^ p) :=\n    R.strictAnti_sumCoeffsExp.injective\n\n"}
{"name":"AkraBazziRecurrence.p_def","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_2\ninst‚úù : Fintype Œ±\na b : Œ± ‚Üí Real\n‚ä¢ Eq (AkraBazziRecurrence.p a b) (Function.invFun (fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)) 1)","decl":"variable (a b) in\n/-- The exponent `p` associated with a particular Akra-Bazzi recurrence. -/\nnoncomputable irreducible_def p : ‚Ñù := Function.invFun (fun (p : ‚Ñù) => ‚àë i, a i * (b i) ^ p) 1\n\n"}
{"name":"AkraBazziRecurrence.sumCoeffsExp_p_eq_one","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Eq (Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) (AkraBazziRecurrence.p a b))) 1","decl":"include R in\n@[simp]\nlemma sumCoeffsExp_p_eq_one : ‚àë i, a i * (b i) ^ p a b = 1 := by\n  simp only [p]\n  exact Function.invFun_eq (by rw [‚Üê Set.mem_range]; exact R.one_mem_range_sumCoeffsExp)\n\n"}
{"name":"AkraBazziRecurrence.sumTransform_def","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\ng : Real ‚Üí Real\nn‚ÇÄ n : Nat\n‚ä¢ Eq (AkraBazziRecurrence.sumTransform p g n‚ÇÄ n) (HMul.hMul (HPow.hPow (‚Üën) p) ((Finset.Ico n‚ÇÄ n).sum fun u => HDiv.hDiv (g ‚Üëu) (HPow.hPow (‚Üëu) (HAdd.hAdd p 1))))","decl":"lemma sumTransform_def {p : ‚Ñù} {g : ‚Ñù ‚Üí ‚Ñù} {n‚ÇÄ n : ‚Ñï} :\n    sumTransform p g n‚ÇÄ n = n^p * ‚àë u ‚àà Finset.Ico n‚ÇÄ n, g u / u^(p + 1) := rfl\n\n\n"}
{"name":"AkraBazziRecurrence.asympBound_def","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"g : Real ‚Üí Real\nŒ± : Type u_2\ninst‚úù : Fintype Œ±\na b : Œ± ‚Üí Real\nn : Nat\n‚ä¢ Eq (AkraBazziRecurrence.asympBound g a b n) (HAdd.hAdd (HPow.hPow (‚Üën) (AkraBazziRecurrence.p a b)) (AkraBazziRecurrence.sumTransform (AkraBazziRecurrence.p a b) g 0 n))","decl":"lemma asympBound_def {Œ±} [Fintype Œ±] (a b : Œ± ‚Üí ‚Ñù) {n : ‚Ñï} :\n    asympBound g a b n = n ^ p a b + sumTransform (p a b) g 0 n := rfl\n\n"}
{"name":"AkraBazziRecurrence.asympBound_def'","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"g : Real ‚Üí Real\nŒ± : Type u_2\ninst‚úù : Fintype Œ±\na b : Œ± ‚Üí Real\nn : Nat\n‚ä¢ Eq (AkraBazziRecurrence.asympBound g a b n) (HMul.hMul (HPow.hPow (‚Üën) (AkraBazziRecurrence.p a b)) (HAdd.hAdd 1 ((Finset.range n).sum fun u => HDiv.hDiv (g ‚Üëu) (HPow.hPow (‚Üëu) (HAdd.hAdd (AkraBazziRecurrence.p a b) 1)))))","decl":"lemma asympBound_def' {Œ±} [Fintype Œ±] (a b : Œ± ‚Üí ‚Ñù) {n : ‚Ñï} :\n    asympBound g a b n = n ^ p a b * (1 + (‚àë u ‚àà range n, g u / u ^ (p a b + 1))) := by\n  simp [asympBound_def, sumTransform, mul_add, mul_one, Finset.sum_Ico_eq_sum_range]\n\n"}
{"name":"AkraBazziRecurrence.asympBound_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\nn : Nat\nhn : LT.lt 0 n\n‚ä¢ LT.lt 0 (AkraBazziRecurrence.asympBound g a b n)","decl":"lemma asympBound_pos (n : ‚Ñï) (hn : 0 < n) : 0 < asympBound g a b n := by\n  calc 0 < (n : ‚Ñù) ^ p a b * (1 + 0) := by aesop (add safe Real.rpow_pos_of_pos)\n       _ ‚â§ asympBound g a b n := by\n                    simp only [asympBound_def']\n                    gcongr n^p a b * (1 + ?_)\n                    have := R.g_nonneg\n                    aesop (add safe Real.rpow_nonneg,\n                               safe div_nonneg,\n                               safe Finset.sum_nonneg)\n\n"}
{"name":"AkraBazziRecurrence.eventually_asympBound_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Eventually (fun n => LT.lt 0 (AkraBazziRecurrence.asympBound g a b n)) Filter.atTop","decl":"lemma eventually_asympBound_pos : ‚àÄ·∂† (n : ‚Ñï) in atTop, 0 < asympBound g a b n := by\n  filter_upwards [eventually_gt_atTop 0] with n hn\n  exact R.asympBound_pos n hn\n\n"}
{"name":"AkraBazziRecurrence.eventually_asympBound_r_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Eventually (fun n => ‚àÄ (i : Œ±), LT.lt 0 (AkraBazziRecurrence.asympBound g a b (r i n))) Filter.atTop","decl":"lemma eventually_asympBound_r_pos : ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, 0 < asympBound g a b (r i n) := by\n  rw [Filter.eventually_all]\n  exact fun i => (R.tendsto_atTop_r i).eventually R.eventually_asympBound_pos\n\n"}
{"name":"AkraBazziRecurrence.eventually_atTop_sumTransform_le","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Exists fun c => And (GT.gt c 0) (Filter.Eventually (fun n => ‚àÄ (i : Œ±), LE.le (AkraBazziRecurrence.sumTransform (AkraBazziRecurrence.p a b) g (r i n) n) (HMul.hMul c (g ‚Üën))) Filter.atTop)","decl":"lemma eventually_atTop_sumTransform_le :\n    ‚àÉ c > 0, ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, sumTransform (p a b) g (r i n) n ‚â§ c * g n := by\n  obtain ‚ü®c‚ÇÅ, hc‚ÇÅ_mem, hc‚ÇÅ‚ü© := R.exists_eventually_const_mul_le_r\n  obtain ‚ü®c‚ÇÇ, hc‚ÇÇ_mem, hc‚ÇÇ‚ü© := R.g_grows_poly.eventually_atTop_le_nat hc‚ÇÅ_mem\n  have hc‚ÇÅ_pos : 0 < c‚ÇÅ := hc‚ÇÅ_mem.1\n  refine ‚ü®max c‚ÇÇ (c‚ÇÇ / c‚ÇÅ ^ (p a b + 1)), by positivity, ?_‚ü©\n  filter_upwards [hc‚ÇÅ, hc‚ÇÇ, R.eventually_r_pos, R.eventually_r_lt_n, eventually_gt_atTop 0]\n    with n hn‚ÇÅ hn‚ÇÇ hrpos hr_lt_n hn_pos\n  intro i\n  have hrpos_i := hrpos i\n  have g_nonneg : 0 ‚â§ g n := R.g_nonneg n (by positivity)\n  cases le_or_lt 0 (p a b + 1) with\n  | inl hp => -- 0 ‚â§ p a b + 1\n    calc sumTransform (p a b) g (r i n) n\n           = n ^ (p a b) * (‚àë u ‚àà Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1)) := by rfl\n         _ ‚â§ n ^ (p a b) * (‚àë u ‚àà Finset.Ico (r i n) n, c‚ÇÇ * g n / u ^ ((p a b) + 1)) := by\n                gcongr with u hu\n                rw [Finset.mem_Ico] at hu\n                have hu' : u ‚àà Set.Icc (r i n) n := ‚ü®hu.1, by omega‚ü©\n                refine hn‚ÇÇ u ?_\n                rw [Set.mem_Icc]\n                refine ‚ü®?_, by norm_cast; omega‚ü©\n                calc c‚ÇÅ * n ‚â§ r i n := by exact hn‚ÇÅ i\n                          _ ‚â§ u := by exact_mod_cast hu'.1\n         _ ‚â§ n ^ (p a b) * (‚àë _u ‚àà Finset.Ico (r i n) n, c‚ÇÇ * g n / (r i n) ^ ((p a b) + 1)) := by\n                  gcongr with u hu; rw [Finset.mem_Ico] at hu; exact hu.1\n         _ ‚â§ n ^ p a b * #(Ico (r i n) n) ‚Ä¢ (c‚ÇÇ * g n / r i n ^ (p a b + 1)) := by\n                  gcongr; exact Finset.sum_le_card_nsmul _ _ _ (fun x _ => by rfl)\n         _ = n ^ p a b * #(Ico (r i n) n) * (c‚ÇÇ * g n / r i n ^ (p a b + 1)) := by\n                  rw [nsmul_eq_mul, mul_assoc]\n         _ = n ^ (p a b) * (n - r i n) * (c‚ÇÇ * g n / (r i n) ^ ((p a b) + 1)) := by\n                  congr; rw [Nat.card_Ico, Nat.cast_sub (le_of_lt <| hr_lt_n i)]\n         _ ‚â§ n ^ (p a b) * n * (c‚ÇÇ * g n / (r i n) ^ ((p a b) + 1)) := by\n                  gcongr; simp only [tsub_le_iff_right, le_add_iff_nonneg_right, Nat.cast_nonneg]\n         _ ‚â§ n ^ (p a b) * n * (c‚ÇÇ * g n / (c‚ÇÅ * n) ^ ((p a b) + 1)) := by\n                gcongr; exact hn‚ÇÅ i\n         _ = c‚ÇÇ * g n * n ^ ((p a b) + 1) / (c‚ÇÅ * n) ^ ((p a b) + 1) := by\n                rw [‚Üê Real.rpow_add_one (by positivity) (p a b)]; ring\n         _ = c‚ÇÇ * g n * n ^ ((p a b) + 1) / (n ^ ((p a b) + 1) * c‚ÇÅ ^ ((p a b) + 1)) := by\n                rw [mul_comm c‚ÇÅ, Real.mul_rpow (by positivity) (by positivity)]\n         _ = c‚ÇÇ * g n * (n ^ ((p a b) + 1) / (n ^ ((p a b) + 1))) / c‚ÇÅ ^ ((p a b) + 1) := by ring\n         _ = c‚ÇÇ * g n / c‚ÇÅ ^ ((p a b) + 1) := by rw [div_self (by positivity), mul_one]\n         _ = (c‚ÇÇ / c‚ÇÅ ^ ((p a b) + 1)) * g n := by ring\n         _ ‚â§ max c‚ÇÇ (c‚ÇÇ / c‚ÇÅ ^ ((p a b) + 1)) * g n := by gcongr; exact le_max_right _ _\n  | inr hp => -- p a b + 1 < 0\n    calc sumTransform (p a b) g (r i n) n\n           = n ^ (p a b) * (‚àë u ‚àà Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1)) := by rfl\n         _ ‚â§ n ^ (p a b) * (‚àë u ‚àà Finset.Ico (r i n) n, c‚ÇÇ * g n / u ^ ((p a b) + 1)) := by\n                gcongr with u hu\n                rw [Finset.mem_Ico] at hu\n                have hu' : u ‚àà Set.Icc (r i n) n := ‚ü®hu.1, by omega‚ü©\n                refine hn‚ÇÇ u ?_\n                rw [Set.mem_Icc]\n                refine ‚ü®?_, by norm_cast; omega‚ü©\n                calc c‚ÇÅ * n ‚â§ r i n := by exact hn‚ÇÅ i\n                          _ ‚â§ u     := by exact_mod_cast hu'.1\n         _ ‚â§ n ^ (p a b) * (‚àë _u ‚àà Finset.Ico (r i n) n, c‚ÇÇ * g n / n ^ ((p a b) + 1)) := by\n                gcongr n ^ (p a b) * (Finset.Ico (r i n) n).sum (fun _ => c‚ÇÇ * g n / ?_) with u hu\n                rw [Finset.mem_Ico] at hu\n                have : 0 < u := calc\n                  0 < r i n := by exact hrpos_i\n                  _ ‚â§ u := by exact hu.1\n                exact rpow_le_rpow_of_exponent_nonpos (by positivity)\n                  (by exact_mod_cast (le_of_lt hu.2)) (le_of_lt hp)\n         _ ‚â§ n ^ p a b * #(Ico (r i n) n) ‚Ä¢ (c‚ÇÇ * g n / n ^ (p a b + 1)) := by\n                  gcongr; exact Finset.sum_le_card_nsmul _ _ _ (fun x _ => by rfl)\n         _ = n ^ p a b * #(Ico (r i n) n) * (c‚ÇÇ * g n / n ^ (p a b + 1)) := by\n                  rw [nsmul_eq_mul, mul_assoc]\n         _ = n ^ (p a b) * (n - r i n) * (c‚ÇÇ * g n / n ^ ((p a b) + 1)) := by\n                  congr; rw [Nat.card_Ico, Nat.cast_sub (le_of_lt <| hr_lt_n i)]\n         _ ‚â§ n ^ (p a b) * n * (c‚ÇÇ * g n / n ^ ((p a b) + 1)) := by\n                gcongr; simp only [tsub_le_iff_right, le_add_iff_nonneg_right, Nat.cast_nonneg]\n         _ = c‚ÇÇ * (n^((p a b) + 1) / n ^ ((p a b) + 1)) * g n := by\n                rw [‚Üê Real.rpow_add_one (by positivity) (p a b)]; ring\n         _ = c‚ÇÇ * g n := by rw [div_self (by positivity), mul_one]\n         _ ‚â§ max c‚ÇÇ (c‚ÇÇ / c‚ÇÅ ^ ((p a b) + 1)) * g n := by gcongr; exact le_max_left _ _\n\n"}
{"name":"AkraBazziRecurrence.eventually_atTop_sumTransform_ge","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Exists fun c => And (GT.gt c 0) (Filter.Eventually (fun n => ‚àÄ (i : Œ±), LE.le (HMul.hMul c (g ‚Üën)) (AkraBazziRecurrence.sumTransform (AkraBazziRecurrence.p a b) g (r i n) n)) Filter.atTop)","decl":"lemma eventually_atTop_sumTransform_ge :\n    ‚àÉ c > 0, ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, c * g n ‚â§ sumTransform (p a b) g (r i n) n := by\n  obtain ‚ü®c‚ÇÅ, hc‚ÇÅ_mem, hc‚ÇÅ‚ü© := R.exists_eventually_const_mul_le_r\n  obtain ‚ü®c‚ÇÇ, hc‚ÇÇ_mem, hc‚ÇÇ‚ü© := R.g_grows_poly.eventually_atTop_ge_nat hc‚ÇÅ_mem\n  obtain ‚ü®c‚ÇÉ, hc‚ÇÉ_mem, hc‚ÇÉ‚ü© := R.exists_eventually_r_le_const_mul\n  have hc‚ÇÅ_pos : 0 < c‚ÇÅ := hc‚ÇÅ_mem.1\n  have hc‚ÇÉ' : 0 < (1 - c‚ÇÉ) := by have := hc‚ÇÉ_mem.2; linarith\n  refine ‚ü®min (c‚ÇÇ * (1 - c‚ÇÉ)) ((1 - c‚ÇÉ) * c‚ÇÇ / c‚ÇÅ^((p a b) + 1)), by positivity, ?_‚ü©\n  filter_upwards [hc‚ÇÅ, hc‚ÇÇ, hc‚ÇÉ, R.eventually_r_pos, R.eventually_r_lt_n, eventually_gt_atTop 0]\n    with n hn‚ÇÅ hn‚ÇÇ hn‚ÇÉ hrpos hr_lt_n hn_pos\n  intro i\n  have hrpos_i := hrpos i\n  have g_nonneg : 0 ‚â§ g n := R.g_nonneg n (by positivity)\n  cases le_or_gt 0 (p a b + 1) with\n  | inl hp => -- 0 ‚â§ (p a b) + 1\n    calc sumTransform (p a b) g (r i n) n\n           = n ^ (p a b) * (‚àë u ‚àà Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))    := rfl\n         _ ‚â• n ^ (p a b) * (‚àë u ‚àà Finset.Ico (r i n) n, c‚ÇÇ * g n / u^((p a b) + 1)) := by\n                gcongr with u hu\n                rw [Finset.mem_Ico] at hu\n                have hu' : u ‚àà Set.Icc (r i n) n := ‚ü®hu.1, by omega‚ü©\n                refine hn‚ÇÇ u ?_\n                rw [Set.mem_Icc]\n                refine ‚ü®?_, by norm_cast; omega‚ü©\n                calc c‚ÇÅ * n ‚â§ r i n := by exact hn‚ÇÅ i\n                          _ ‚â§ u     := by exact_mod_cast hu'.1\n         _ ‚â• n ^ (p a b) * (‚àë _u ‚àà Finset.Ico (r i n) n, c‚ÇÇ * g n / n ^ ((p a b) + 1)) := by\n                gcongr with u hu\n                ¬∑ rw [Finset.mem_Ico] at hu\n                  have := calc 0 < r i n := hrpos_i\n                              _ ‚â§ u := hu.1\n                  positivity\n                ¬∑ rw [Finset.mem_Ico] at hu\n                  exact le_of_lt hu.2\n         _ ‚â• n ^ p a b * #(Ico (r i n) n) ‚Ä¢ (c‚ÇÇ * g n / n ^ (p a b + 1)) := by\n                gcongr; exact Finset.card_nsmul_le_sum _ _ _ (fun x _ => by rfl)\n         _ = n ^ p a b * #(Ico (r i n) n) * (c‚ÇÇ * g n / n ^ (p a b + 1)) := by\n                rw [nsmul_eq_mul, mul_assoc]\n         _ = n ^ (p a b) * (n - r i n) * (c‚ÇÇ * g n / n ^ ((p a b) + 1)) := by\n                congr; rw [Nat.card_Ico, Nat.cast_sub (le_of_lt <| hr_lt_n i)]\n         _ ‚â• n ^ (p a b) * (n - c‚ÇÉ * n) * (c‚ÇÇ * g n / n ^ ((p a b) + 1)) := by\n                gcongr; exact hn‚ÇÉ i\n         _ = n ^ (p a b) * n * (1 - c‚ÇÉ) * (c‚ÇÇ * g n / n ^ ((p a b) + 1)) := by ring\n         _ = c‚ÇÇ * (1 - c‚ÇÉ) * g n * (n ^ ((p a b) + 1) / n ^ ((p a b) + 1)) := by\n                rw [‚Üê Real.rpow_add_one (by positivity) (p a b)]; ring\n         _ = c‚ÇÇ * (1 - c‚ÇÉ) * g n := by rw [div_self (by positivity), mul_one]\n         _ ‚â• min (c‚ÇÇ * (1 - c‚ÇÉ)) ((1 - c‚ÇÉ) * c‚ÇÇ / c‚ÇÅ ^ ((p a b) + 1)) * g n := by\n                gcongr; exact min_le_left _ _\n  | inr hp => -- (p a b) + 1 < 0\n    calc sumTransform (p a b) g (r i n) n\n        = n ^ (p a b) * (‚àë u ‚àà Finset.Ico (r i n) n, g u / u^((p a b) + 1))        := by rfl\n      _ ‚â• n ^ (p a b) * (‚àë u ‚àà Finset.Ico (r i n) n, c‚ÇÇ * g n / u ^ ((p a b) + 1)) := by\n             gcongr with u hu\n             rw [Finset.mem_Ico] at hu\n             have hu' : u ‚àà Set.Icc (r i n) n := ‚ü®hu.1, by omega‚ü©\n             refine hn‚ÇÇ u ?_\n             rw [Set.mem_Icc]\n             refine ‚ü®?_, by norm_cast; omega‚ü©\n             calc c‚ÇÅ * n ‚â§ r i n := by exact hn‚ÇÅ i\n                       _ ‚â§ u := by exact_mod_cast hu'.1\n      _ ‚â• n ^ (p a b) * (‚àë _u ‚àà Finset.Ico (r i n) n, c‚ÇÇ * g n / (r i n) ^ ((p a b) + 1)) := by\n             gcongr n^(p a b) * (Finset.Ico (r i n) n).sum (fun _ => c‚ÇÇ * g n / ?_) with u hu\n             ¬∑ rw [Finset.mem_Ico] at hu\n               have := calc 0 < r i n := hrpos_i\n                           _ ‚â§ u := hu.1\n               positivity\n             ¬∑ rw [Finset.mem_Ico] at hu\n               exact rpow_le_rpow_of_exponent_nonpos (by positivity)\n                 (by exact_mod_cast hu.1) (le_of_lt hp)\n      _ ‚â• n ^ p a b * #(Ico (r i n) n) ‚Ä¢ (c‚ÇÇ * g n / r i n ^ (p a b + 1)) := by\n             gcongr; exact Finset.card_nsmul_le_sum _ _ _ (fun x _ => by rfl)\n      _ = n ^ p a b * #(Ico (r i n) n) * (c‚ÇÇ * g n / r i n ^ (p a b + 1)) := by\n             rw [nsmul_eq_mul, mul_assoc]\n      _ ‚â• n ^ p a b * #(Ico (r i n) n) * (c‚ÇÇ * g n / (c‚ÇÅ * n) ^ (p a b + 1)) := by\n             gcongr n ^ p a b * #(Ico (r i n) n) * (c‚ÇÇ * g n / ?_)\n             exact rpow_le_rpow_of_exponent_nonpos (by positivity) (hn‚ÇÅ i) (le_of_lt hp)\n      _ = n ^ (p a b) * (n - r i n) * (c‚ÇÇ * g n / (c‚ÇÅ * n) ^ ((p a b) + 1)) := by\n             congr; rw [Nat.card_Ico, Nat.cast_sub (le_of_lt <| hr_lt_n i)]\n      _ ‚â• n ^ (p a b) * (n - c‚ÇÉ * n) * (c‚ÇÇ * g n / (c‚ÇÅ * n) ^ ((p a b) + 1)) := by\n             gcongr; exact hn‚ÇÉ i\n      _ = n ^ (p a b) * n * (1 - c‚ÇÉ) * (c‚ÇÇ * g n / (c‚ÇÅ * n) ^ ((p a b) + 1)) := by ring\n      _ = n ^ (p a b) * n * (1 - c‚ÇÉ) * (c‚ÇÇ * g n / (c‚ÇÅ ^ ((p a b) + 1) * n ^ ((p a b) + 1))) := by\n             rw [Real.mul_rpow (by positivity) (by positivity)]\n      _ = (n ^ ((p a b) + 1) / n ^ ((p a b) + 1)) * (1 - c‚ÇÉ) * c‚ÇÇ * g n / c‚ÇÅ ^ ((p a b) + 1) := by\n             rw [‚Üê Real.rpow_add_one (by positivity) (p a b)]; ring\n      _ = (1 - c‚ÇÉ) * c‚ÇÇ / c‚ÇÅ ^ ((p a b) + 1) * g n := by\n             rw [div_self (by positivity), one_mul]; ring\n      _ ‚â• min (c‚ÇÇ * (1 - c‚ÇÉ)) ((1 - c‚ÇÉ) * c‚ÇÇ / c‚ÇÅ ^ ((p a b) + 1)) * g n := by\n             gcongr; exact min_le_right _ _\n\n"}
{"name":"AkraBazziRecurrence.eventually_deriv_rpow_p_mul_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\n‚ä¢ Filter.atTop.EventuallyEq (deriv fun z => HMul.hMul (HPow.hPow z p) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z))) fun z => HAdd.hAdd (HMul.hMul (HMul.hMul p (HPow.hPow z (HSub.hSub p 1))) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z))) (HDiv.hDiv (HPow.hPow z (HSub.hSub p 1)) (HPow.hPow (Real.log z) 2))","decl":"lemma eventually_deriv_rpow_p_mul_one_sub_smoothingFn (p : ‚Ñù) :\n    deriv (fun z => z ^ p * (1 - Œµ z))\n      =·∂†[atTop] fun z => p * z ^ (p-1) * (1 - Œµ z) + z ^ (p-1) / (log z ^ 2) := calc\n  deriv (fun x => x ^ p * (1 - Œµ x))\n    =·∂†[atTop] fun x => deriv (¬∑ ^ p) x * (1 - Œµ x) + x ^ p * deriv (1 - Œµ ¬∑) x := by\n            filter_upwards [eventually_gt_atTop 1] with x hx\n            rw [deriv_mul]\n            ¬∑ exact differentiableAt_rpow_const_of_ne _ (by positivity)\n            ¬∑ exact differentiableAt_one_sub_smoothingFn hx\n  _ =·∂†[atTop] fun x => p * x ^ (p-1) * (1 - Œµ x) + x ^ p * (x‚Åª¬π / (log x ^ 2)) := by\n            filter_upwards [eventually_gt_atTop 1, eventually_deriv_one_sub_smoothingFn]\n              with x hx hderiv\n            rw [hderiv, Real.deriv_rpow_const (Or.inl <| by positivity)]\n  _ =·∂†[atTop] fun x => p * x ^ (p-1) * (1 - Œµ x) + x ^ (p-1) / (log x ^ 2) := by\n            filter_upwards [eventually_gt_atTop 0] with x hx\n            rw [mul_div, ‚Üê Real.rpow_neg_one, ‚Üê Real.rpow_add (by positivity), sub_eq_add_neg]\n\n"}
{"name":"AkraBazziRecurrence.eventually_deriv_rpow_p_mul_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\n‚ä¢ Filter.atTop.EventuallyEq (deriv fun z => HMul.hMul (HPow.hPow z p) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z))) fun z => HSub.hSub (HMul.hMul (HMul.hMul p (HPow.hPow z (HSub.hSub p 1))) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z))) (HDiv.hDiv (HPow.hPow z (HSub.hSub p 1)) (HPow.hPow (Real.log z) 2))","decl":"lemma eventually_deriv_rpow_p_mul_one_add_smoothingFn (p : ‚Ñù) :\n    deriv (fun z => z ^ p * (1 + Œµ z))\n      =·∂†[atTop] fun z => p * z ^ (p-1) * (1 + Œµ z) - z ^ (p-1) / (log z ^ 2) := calc\n  deriv (fun x => x ^ p * (1 + Œµ x))\n    =·∂†[atTop] fun x => deriv (¬∑ ^ p) x * (1 + Œµ x) + x ^ p * deriv (1 + Œµ ¬∑) x := by\n            filter_upwards [eventually_gt_atTop 1] with x hx\n            rw [deriv_mul]\n            ¬∑ exact differentiableAt_rpow_const_of_ne _ (by positivity)\n            ¬∑ exact differentiableAt_one_add_smoothingFn hx\n  _ =·∂†[atTop] fun x => p * x ^ (p-1) * (1 + Œµ x) - x ^ p * (x‚Åª¬π / (log x ^ 2)) := by\n            filter_upwards [eventually_gt_atTop 1, eventually_deriv_one_add_smoothingFn]\n              with x hx hderiv\n            simp [hderiv, Real.deriv_rpow_const (Or.inl <| by positivity), neg_div, sub_eq_add_neg]\n  _ =·∂†[atTop] fun x => p * x ^ (p-1) * (1 + Œµ x) - x ^ (p-1) / (log x ^ 2) := by\n            filter_upwards [eventually_gt_atTop 0] with x hx\n            simp [mul_div, ‚Üê Real.rpow_neg_one, ‚Üê Real.rpow_add (by positivity), sub_eq_add_neg]\n\n"}
{"name":"AkraBazziRecurrence.isEquivalent_deriv_rpow_p_mul_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\nhp : Ne p 0\n‚ä¢ Asymptotics.IsEquivalent Filter.atTop (deriv fun z => HMul.hMul (HPow.hPow z p) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z))) fun z => HMul.hMul p (HPow.hPow z (HSub.hSub p 1))","decl":"lemma isEquivalent_deriv_rpow_p_mul_one_sub_smoothingFn {p : ‚Ñù} (hp : p ‚â† 0) :\n    deriv (fun z => z ^ p * (1 - Œµ z)) ~[atTop] fun z => p * z ^ (p-1) := calc\n  deriv (fun z => z ^ p * (1 - Œµ z))\n    =·∂†[atTop] fun z => p * z ^ (p-1) * (1 - Œµ z) + z^(p-1) / (log z ^ 2) :=\n        eventually_deriv_rpow_p_mul_one_sub_smoothingFn p\n  _ ~[atTop] fun z => p * z ^ (p-1) := by\n        refine IsEquivalent.add_isLittleO ?one ?two\n        case one => calc\n          (fun z => p * z ^ (p-1) * (1 - Œµ z)) ~[atTop] fun z => p * z ^ (p-1) * 1 :=\n                IsEquivalent.mul IsEquivalent.refl isEquivalent_one_sub_smoothingFn_one\n          _ = fun z => p * z ^ (p-1) := by ext; ring\n        case two => calc\n          (fun z => z ^ (p-1) / (log z ^ 2)) =o[atTop] fun z => z ^ (p-1) / 1 := by\n                      simp_rw [div_eq_mul_inv]\n                      refine IsBigO.mul_isLittleO (isBigO_refl _ _)\n                        (IsLittleO.inv_rev ?_ (by simp))\n                      rw [isLittleO_const_left]\n                      refine Or.inr <| Tendsto.comp tendsto_norm_atTop_atTop ?_\n                      exact Tendsto.comp (g := fun z => z ^ 2)\n                        (tendsto_pow_atTop (by norm_num)) tendsto_log_atTop\n          _ = fun z => z ^ (p-1) := by ext; simp\n          _ =Œò[atTop] fun z => p * z ^ (p-1) := by\n                      exact IsTheta.const_mul_right hp <| isTheta_refl _ _\n\n"}
{"name":"AkraBazziRecurrence.isEquivalent_deriv_rpow_p_mul_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\nhp : Ne p 0\n‚ä¢ Asymptotics.IsEquivalent Filter.atTop (deriv fun z => HMul.hMul (HPow.hPow z p) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z))) fun z => HMul.hMul p (HPow.hPow z (HSub.hSub p 1))","decl":"lemma isEquivalent_deriv_rpow_p_mul_one_add_smoothingFn {p : ‚Ñù} (hp : p ‚â† 0) :\n    deriv (fun z => z ^ p * (1 + Œµ z)) ~[atTop] fun z => p * z ^ (p-1) := calc\n  deriv (fun z => z ^ p * (1 + Œµ z))\n    =·∂†[atTop] fun z => p * z ^ (p-1) * (1 + Œµ z) - z ^ (p-1) / (log z ^ 2) :=\n        eventually_deriv_rpow_p_mul_one_add_smoothingFn p\n  _ ~[atTop] fun z => p * z ^ (p-1) := by\n        refine IsEquivalent.add_isLittleO ?one ?two\n        case one => calc\n          (fun z => p * z ^ (p-1) * (1 + Œµ z)) ~[atTop] fun z => p * z ^ (p-1) * 1 :=\n                IsEquivalent.mul IsEquivalent.refl isEquivalent_one_add_smoothingFn_one\n          _ = fun z => p * z ^ (p-1) := by ext; ring\n        case two => calc\n          (fun z => -(z ^ (p-1) / (log z ^ 2))) =o[atTop] fun z => z ^ (p-1) / 1 := by\n                      simp_rw [isLittleO_neg_left, div_eq_mul_inv]\n                      refine IsBigO.mul_isLittleO (isBigO_refl _ _)\n                        (IsLittleO.inv_rev ?_ (by simp))\n                      rw [isLittleO_const_left]\n                      refine Or.inr <| Tendsto.comp tendsto_norm_atTop_atTop ?_\n                      exact Tendsto.comp (g := fun z => z ^ 2)\n                        (tendsto_pow_atTop (by norm_num)) tendsto_log_atTop\n          _ = fun z => z ^ (p-1) := by ext; simp\n          _ =Œò[atTop] fun z => p * z ^ (p-1) := by\n                      exact IsTheta.const_mul_right hp <| isTheta_refl _ _\n\n"}
{"name":"AkraBazziRecurrence.isTheta_deriv_rpow_p_mul_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\nhp : Ne p 0\n‚ä¢ Asymptotics.IsTheta Filter.atTop (fun x => Norm.norm (deriv (fun z => HMul.hMul (HPow.hPow z p) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z))) x)) fun z => HPow.hPow z (HSub.hSub p 1)","decl":"lemma isTheta_deriv_rpow_p_mul_one_sub_smoothingFn {p : ‚Ñù} (hp : p ‚â† 0) :\n    (fun x => ‚Äñderiv (fun z => z ^ p * (1 - Œµ z)) x‚Äñ) =Œò[atTop] fun z => z ^ (p-1) := by\n  refine IsTheta.norm_left ?_\n  calc (fun x => deriv (fun z => z ^ p * (1 - Œµ z)) x) =Œò[atTop] fun z => p * z ^ (p-1) :=\n            (isEquivalent_deriv_rpow_p_mul_one_sub_smoothingFn hp).isTheta\n    _ =Œò[atTop] fun z => z ^ (p-1) :=\n            IsTheta.const_mul_left hp <| isTheta_refl _ _\n\n"}
{"name":"AkraBazziRecurrence.isTheta_deriv_rpow_p_mul_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\nhp : Ne p 0\n‚ä¢ Asymptotics.IsTheta Filter.atTop (fun x => Norm.norm (deriv (fun z => HMul.hMul (HPow.hPow z p) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z))) x)) fun z => HPow.hPow z (HSub.hSub p 1)","decl":"lemma isTheta_deriv_rpow_p_mul_one_add_smoothingFn {p : ‚Ñù} (hp : p ‚â† 0) :\n    (fun x => ‚Äñderiv (fun z => z ^ p * (1 + Œµ z)) x‚Äñ) =Œò[atTop] fun z => z ^ (p-1) := by\n  refine IsTheta.norm_left ?_\n  calc (fun x => deriv (fun z => z ^ p * (1 + Œµ z)) x) =Œò[atTop] fun z => p * z ^ (p-1) :=\n            (isEquivalent_deriv_rpow_p_mul_one_add_smoothingFn hp).isTheta\n    _ =Œò[atTop] fun z => z ^ (p-1) :=\n            IsTheta.const_mul_left hp <| isTheta_refl _ _\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_deriv_rpow_p_mul_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\n‚ä¢ AkraBazziRecurrence.GrowsPolynomially fun x => Norm.norm (deriv (fun z => HMul.hMul (HPow.hPow z p) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z))) x)","decl":"lemma growsPolynomially_deriv_rpow_p_mul_one_sub_smoothingFn (p : ‚Ñù) :\n    GrowsPolynomially fun x => ‚Äñderiv (fun z => z ^ p * (1 - Œµ z)) x‚Äñ := by\n  cases eq_or_ne p 0 with\n  | inl hp => -- p = 0\n    have h‚ÇÅ : (fun x => ‚Äñderiv (fun z => z ^ p * (1 - Œµ z)) x‚Äñ)\n        =·∂†[atTop] fun z => z‚Åª¬π / (log z ^ 2) := by\n      filter_upwards [eventually_deriv_one_sub_smoothingFn, eventually_gt_atTop 1] with x hx hx_pos\n      have : 0 ‚â§ x‚Åª¬π / (log x ^ 2) := by\n        have hlog : 0 < log x := Real.log_pos hx_pos\n        positivity\n      simp only [hp, Real.rpow_zero, one_mul, differentiableAt_const, hx, Real.norm_of_nonneg this]\n    refine GrowsPolynomially.congr_of_eventuallyEq h‚ÇÅ ?_\n    refine GrowsPolynomially.div (GrowsPolynomially.inv growsPolynomially_id)\n      (GrowsPolynomially.pow 2 growsPolynomially_log ?_)\n    filter_upwards [eventually_ge_atTop 1] with _ hx\n    exact log_nonneg hx\n  | inr hp => -- p ‚â† 0\n    refine GrowsPolynomially.of_isTheta (growsPolynomially_rpow (p-1))\n      (isTheta_deriv_rpow_p_mul_one_sub_smoothingFn hp) ?_\n    filter_upwards [eventually_gt_atTop 0] with _ _\n    positivity\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\n‚ä¢ AkraBazziRecurrence.GrowsPolynomially fun x => Norm.norm (deriv (fun z => HMul.hMul (HPow.hPow z p) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z))) x)","decl":"lemma growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p : ‚Ñù) :\n    GrowsPolynomially fun x => ‚Äñderiv (fun z => z ^ p * (1 + Œµ z)) x‚Äñ := by\n  cases eq_or_ne p 0 with\n  | inl hp => -- p = 0\n    have h‚ÇÅ : (fun x => ‚Äñderiv (fun z => z ^ p * (1 + Œµ z)) x‚Äñ)\n        =·∂†[atTop] fun z => z‚Åª¬π / (log z ^ 2) := by\n      filter_upwards [eventually_deriv_one_add_smoothingFn, eventually_gt_atTop 1] with x hx hx_pos\n      have : 0 ‚â§ x‚Åª¬π / (log x ^ 2) := by\n        have hlog : 0 < log x := Real.log_pos hx_pos\n        positivity\n      simp only [neg_div, norm_neg, hp, Real.rpow_zero,\n        one_mul, differentiableAt_const, hx, Real.norm_of_nonneg this]\n    refine GrowsPolynomially.congr_of_eventuallyEq h‚ÇÅ ?_\n    refine GrowsPolynomially.div (GrowsPolynomially.inv growsPolynomially_id)\n      (GrowsPolynomially.pow 2 growsPolynomially_log ?_)\n    filter_upwards [eventually_ge_atTop 1] with x hx\n    exact log_nonneg hx\n  | inr hp => -- p ‚â† 0\n    refine GrowsPolynomially.of_isTheta (growsPolynomially_rpow (p-1))\n      (isTheta_deriv_rpow_p_mul_one_add_smoothingFn hp) ?_\n    filter_upwards [eventually_gt_atTop 0] with _ _\n    positivity\n\n"}
{"name":"AkraBazziRecurrence.isBigO_apply_r_sub_b","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\nq : Real ‚Üí Real\nhq_diff : DifferentiableOn Real q (Set.Ioi 1)\nhq_poly : AkraBazziRecurrence.GrowsPolynomially fun x => Norm.norm (deriv q x)\ni : Œ±\n‚ä¢ Asymptotics.IsBigO Filter.atTop (fun n => HSub.hSub (q ‚Üë(r i n)) (q (HMul.hMul (b i) ‚Üën))) fun n => HMul.hMul (deriv q ‚Üën) (HSub.hSub (‚Üë(r i n)) (HMul.hMul (b i) ‚Üën))","decl":"lemma isBigO_apply_r_sub_b (q : ‚Ñù ‚Üí ‚Ñù) (hq_diff : DifferentiableOn ‚Ñù q (Set.Ioi 1))\n    (hq_poly : GrowsPolynomially fun x => ‚Äñderiv q x‚Äñ) (i : Œ±) :\n    (fun n => q (r i n) - q (b i * n)) =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by\n  let b' := b (min_bi b) / 2\n  have hb_pos : 0 < b' := by have := R.b_pos (min_bi b); positivity\n  have hb_lt_one : b' < 1 := calc\n    b (min_bi b) / 2 < b (min_bi b) := by exact div_two_lt_of_pos (R.b_pos (min_bi b))\n                   _ < 1 := R.b_lt_one (min_bi b)\n  have hb : b' ‚àà Set.Ioo 0 1 := ‚ü®hb_pos, hb_lt_one‚ü©\n  have hb' : ‚àÄ i, b' ‚â§ b i := fun i => calc\n    b (min_bi b) / 2 ‚â§ b i / 2 := by gcongr; aesop\n               _ ‚â§ b i := by exact le_of_lt <| div_two_lt_of_pos (R.b_pos i)\n  obtain ‚ü®c‚ÇÅ, _, c‚ÇÇ, _, hq_poly‚ü© := hq_poly b' hb\n  rw [isBigO_iff]\n  refine ‚ü®c‚ÇÇ, ?_‚ü©\n  have h_tendsto : Tendsto (fun x => b' * x) atTop atTop :=\n    Tendsto.const_mul_atTop hb_pos tendsto_id\n  filter_upwards [hq_poly.natCast_atTop, R.eventually_bi_mul_le_r, eventually_ge_atTop R.n‚ÇÄ,\n                  eventually_gt_atTop 0, (h_tendsto.eventually_gt_atTop 1).natCast_atTop] with\n    n hn h_bi_le_r h_ge_n‚ÇÄ h_n_pos h_bn\n  rw [norm_mul, ‚Üê mul_assoc]\n  refine Convex.norm_image_sub_le_of_norm_deriv_le\n    (s := Set.Icc (b'*n) n) (fun z hz => ?diff) (fun z hz => (hn z hz).2)\n    (convex_Icc _ _) ?mem_Icc <| ‚ü®h_bi_le_r i, by exact_mod_cast (le_of_lt (R.r_lt_n i n h_ge_n‚ÇÄ))‚ü©\n  case diff =>\n    refine hq_diff.differentiableAt (Ioi_mem_nhds ?_)\n    calc 1 < b' * n := by exact h_bn\n         _ ‚â§ z := hz.1\n  case mem_Icc =>\n    refine ‚ü®by gcongr; exact hb' i, ?_‚ü©\n    calc b i * n ‚â§ 1 * n := by gcongr; exact le_of_lt <| R.b_lt_one i\n                 _ = n := by simp\n\n"}
{"name":"AkraBazziRecurrence.rpow_p_mul_one_sub_smoothingFn_le","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Eventually (fun n => ‚àÄ (i : Œ±), LE.le (HMul.hMul (HPow.hPow (‚Üë(r i n)) (AkraBazziRecurrence.p a b)) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ‚Üë(r i n)))) (HMul.hMul (HMul.hMul (HPow.hPow (b i) (AkraBazziRecurrence.p a b)) (HPow.hPow (‚Üën) (AkraBazziRecurrence.p a b))) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ‚Üën)))) Filter.atTop","decl":"lemma rpow_p_mul_one_sub_smoothingFn_le :\n    ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, (r i n) ^ (p a b) * (1 - Œµ (r i n))\n      ‚â§ (b i) ^ (p a b) * n ^ (p a b) * (1 - Œµ n) := by\n  rw [Filter.eventually_all]\n  intro i\n  let q : ‚Ñù ‚Üí ‚Ñù := fun x => x ^ (p a b) * (1 - Œµ x)\n  have h_diff_q : DifferentiableOn ‚Ñù q (Set.Ioi 1) := by\n    refine DifferentiableOn.mul\n      (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)\n        differentiableOn_one_sub_smoothingFn\n    rw [Set.mem_compl_singleton_iff]\n    rw [Set.mem_Ioi] at hz\n    exact ne_of_gt <| zero_lt_one.trans hz\n  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc\n    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 - Œµ z) x := by rfl\n          _ =·∂†[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 - Œµ x) +\n                  x ^ (p a b) * deriv (fun z => 1 - Œµ z) x := by\n              filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'\n              rw [deriv_mul] <;> aesop\n          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by\n              refine IsBigO.add ?left ?right\n              case left => calc\n                (fun x => deriv (fun z => z ^ (p a b)) x * (1 - Œµ x))\n                    =O[atTop] fun x => x ^ ((p a b) - 1) * (1 - Œµ x) := by\n                      exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)\n                  _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 := by\n                      refine IsBigO.mul (isBigO_refl _ _)\n                        isEquivalent_one_sub_smoothingFn_one.isBigO\n                  _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]\n              case right => calc\n                (fun x => x ^ (p a b) * deriv (fun z => 1 - Œµ z) x)\n                    =O[atTop] (fun x => x ^ (p a b) * x‚Åª¬π) := by\n                      exact IsBigO.mul (isBigO_refl _ _) isLittleO_deriv_one_sub_smoothingFn.isBigO\n                  _ =·∂†[atTop] fun x => x ^ ((p a b) - 1) := by\n                      filter_upwards [eventually_gt_atTop 0] with x hx\n                      rw [‚Üê Real.rpow_neg_one, ‚Üê Real.rpow_add hx, ‚Üê sub_eq_add_neg]\n  have h_main_norm : (fun (n : ‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ)\n      ‚â§·∂†[atTop] fun (n : ‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ := by\n    refine IsLittleO.eventuallyLE ?_\n    calc\n      (fun (n : ‚Ñï) => q (r i n) - q (b i * n))\n          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by\n              exact R.isBigO_apply_r_sub_b q h_diff_q\n                (growsPolynomially_deriv_rpow_p_mul_one_sub_smoothingFn (p a b)) i\n        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by\n              exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)\n        _ =O[atTop] fun n => n^((p a b) - 1) * (n / log n ^ 2) := by\n              exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)\n        _ =·∂†[atTop] fun n => n^(p a b) / (log n) ^ 2 := by\n              filter_upwards [eventually_ne_atTop 0] with n hn\n              have hn' : (n : ‚Ñù) ‚â† 0 := by positivity\n              simp [‚Üê mul_div_assoc, ‚Üê Real.rpow_add_one hn']\n        _ = fun (n : ‚Ñï) => (n : ‚Ñù) ^ (p a b) * (1 / (log n)^2) := by\n              simp_rw [mul_div, mul_one]\n        _ =Œò[atTop] fun (n : ‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n)^2) := by\n              refine IsTheta.symm ?_\n              simp_rw [mul_assoc]\n              refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)\n              have := R.b_pos i; positivity\n        _ =Œò[atTop] fun (n : ‚Ñï) => (b i)^(p a b) * n^(p a b) * (Œµ (b i * n) - Œµ n) := by\n              exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)\n                <| R.isTheta_smoothingFn_sub_self i\n  have h_main : (fun (n : ‚Ñï) => q (r i n) - q (b i * n))\n      ‚â§·∂†[atTop] fun (n : ‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by\n    calc (fun (n : ‚Ñï) => q (r i n) - q (b i * n))\n           ‚â§·∂†[atTop] fun (n : ‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ := by\n                filter_upwards with _; exact le_norm_self _\n         _ ‚â§·∂†[atTop] fun (n : ‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ :=\n                h_main_norm\n         _ =·∂†[atTop] fun (n : ‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by\n                filter_upwards [eventually_gt_atTop ‚åà(b i)‚Åª¬π‚åâ‚Çä, eventually_gt_atTop 1] with n hn hn'\n                refine norm_of_nonneg ?_\n                have h‚ÇÅ := R.b_pos i\n                have h‚ÇÇ : 0 ‚â§ Œµ (b i * n) - Œµ n := by\n                  refine sub_nonneg_of_le <|\n                    (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le\n                  case n_gt_one =>\n                    rwa [Set.mem_Ioi, Nat.one_lt_cast]\n                  case bn_gt_one =>\n                    calc 1 = b i * (b i)‚Åª¬π := by rw [mul_inv_cancel‚ÇÄ (by positivity)]\n                        _ ‚â§ b i * ‚åà(b i)‚Åª¬π‚åâ‚Çä := by gcongr; exact Nat.le_ceil _\n                        _ < b i * n := by gcongr\n                  case le => calc b i * n ‚â§ 1 * n := by have := R.b_lt_one i; gcongr\n                                          _ = n := by rw [one_mul]\n                positivity\n  filter_upwards [h_main] with n hn\n  have h‚ÇÅ : q (b i * n) + (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)\n      = (b i) ^ (p a b) * n ^ (p a b) * (1 - Œµ n) := by\n    have := R.b_pos i\n    simp only [q, mul_rpow (by positivity : (0 : ‚Ñù) ‚â§ b i) (by positivity : (0 : ‚Ñù) ‚â§ n)]\n    ring\n  show q (r i n) ‚â§ (b i) ^ (p a b) * n ^ (p a b) * (1 - Œµ n)\n  rw [‚Üê h‚ÇÅ, ‚Üê sub_le_iff_le_add']\n  exact hn\n\n"}
{"name":"AkraBazziRecurrence.rpow_p_mul_one_add_smoothingFn_ge","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Filter.Eventually (fun n => ‚àÄ (i : Œ±), LE.le (HMul.hMul (HMul.hMul (HPow.hPow (b i) (AkraBazziRecurrence.p a b)) (HPow.hPow (‚Üën) (AkraBazziRecurrence.p a b))) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn ‚Üën))) (HMul.hMul (HPow.hPow (‚Üë(r i n)) (AkraBazziRecurrence.p a b)) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn ‚Üë(r i n))))) Filter.atTop","decl":"lemma rpow_p_mul_one_add_smoothingFn_ge :\n    ‚àÄ·∂† (n : ‚Ñï) in atTop, ‚àÄ i, (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n)\n      ‚â§ (r i n) ^ (p a b) * (1 + Œµ (r i n)) := by\n  rw [Filter.eventually_all]\n  intro i\n  let q : ‚Ñù ‚Üí ‚Ñù := fun x => x ^ (p a b) * (1 + Œµ x)\n  have h_diff_q : DifferentiableOn ‚Ñù q (Set.Ioi 1) := by\n    refine DifferentiableOn.mul\n        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)\n        differentiableOn_one_add_smoothingFn\n    rw [Set.mem_compl_singleton_iff]\n    rw [Set.mem_Ioi] at hz\n    exact ne_of_gt <| zero_lt_one.trans hz\n  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc\n    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + Œµ z) x := by rfl\n          _ =·∂†[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x)\n              + x ^ (p a b) * deriv (fun z => 1 + Œµ z) x := by\n                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'\n                rw [deriv_mul] <;> aesop\n          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by\n                refine IsBigO.add ?left ?right\n                case left => calc\n                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + Œµ x))\n                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + Œµ x) := by\n                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)\n                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=\n                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO\n                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]\n                case right => calc\n                  (fun x => x ^ (p a b) * deriv (fun z => 1 + Œµ z) x)\n                      =O[atTop] (fun x => x ^ (p a b) * x‚Åª¬π) := by\n                        exact IsBigO.mul (isBigO_refl _ _)\n                          isLittleO_deriv_one_add_smoothingFn.isBigO\n                    _ =·∂†[atTop] fun x => x ^ ((p a b) - 1) := by\n                        filter_upwards [eventually_gt_atTop 0] with x hx\n                        rw [‚Üê Real.rpow_neg_one, ‚Üê Real.rpow_add hx, ‚Üê sub_eq_add_neg]\n  have h_main_norm : (fun (n : ‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ)\n      ‚â§·∂†[atTop] fun (n : ‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ := by\n    refine IsLittleO.eventuallyLE ?_\n    calc\n      (fun (n : ‚Ñï) => q (r i n) - q (b i * n))\n          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by\n            exact R.isBigO_apply_r_sub_b q h_diff_q\n              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i\n        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by\n            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)\n        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by\n            exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)\n        _ =·∂†[atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by\n            filter_upwards [eventually_ne_atTop 0] with n hn\n            have hn' : (n : ‚Ñù) ‚â† 0 := by positivity\n            simp [‚Üê mul_div_assoc, ‚Üê Real.rpow_add_one hn']\n        _ = fun (n : ‚Ñï) => (n : ‚Ñù) ^ (p a b) * (1 / (log n) ^ 2) := by simp_rw [mul_div, mul_one]\n        _ =Œò[atTop] fun (n : ‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by\n            refine IsTheta.symm ?_\n            simp_rw [mul_assoc]\n            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)\n            have := R.b_pos i; positivity\n        _ =Œò[atTop] fun (n : ‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by\n            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)\n                  <| R.isTheta_smoothingFn_sub_self i\n  have h_main : (fun (n : ‚Ñï) => q (b i * n) - q (r i n))\n      ‚â§·∂†[atTop] fun (n : ‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by\n    calc (fun (n : ‚Ñï) => q (b i * n) - q (r i n))\n           ‚â§·∂†[atTop] fun (n : ‚Ñï) => ‚Äñq (r i n) - q (b i * n)‚Äñ := by\n              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _\n         _ ‚â§·∂†[atTop] fun (n : ‚Ñï) => ‚Äñ(b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)‚Äñ :=\n              h_main_norm\n         _ =·∂†[atTop] fun (n : ‚Ñï) => (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n) := by\n              filter_upwards [eventually_gt_atTop ‚åà(b i)‚Åª¬π‚åâ‚Çä, eventually_gt_atTop 1] with n hn hn'\n              refine norm_of_nonneg ?_\n              have h‚ÇÅ := R.b_pos i\n              have h‚ÇÇ : 0 ‚â§ Œµ (b i * n) - Œµ n := by\n                refine sub_nonneg_of_le <|\n                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le\n                case n_gt_one =>\n                  show 1 < (n : ‚Ñù)\n                  rw [Nat.one_lt_cast]\n                  exact hn'\n                case bn_gt_one =>\n                  calc 1 = b i * (b i)‚Åª¬π := by rw [mul_inv_cancel‚ÇÄ (by positivity)]\n                      _ ‚â§ b i * ‚åà(b i)‚Åª¬π‚åâ‚Çä := by gcongr; exact Nat.le_ceil _\n                      _ < b i * n := by gcongr\n                case le => calc b i * n ‚â§ 1 * n := by have := R.b_lt_one i; gcongr\n                                        _ = n := by rw [one_mul]\n              positivity\n  filter_upwards [h_main] with n hn\n  have h‚ÇÅ : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (Œµ (b i * n) - Œµ n)\n      = (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) := by\n    have := R.b_pos i\n    simp only [q, mul_rpow (by positivity : (0 : ‚Ñù) ‚â§ b i) (by positivity : (0 : ‚Ñù) ‚â§ n)]\n    ring\n  show (b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n) ‚â§ q (r i n)\n  rw [‚Üê h‚ÇÅ, sub_le_iff_le_add', ‚Üê sub_le_iff_le_add]\n  exact hn\n\n"}
{"name":"AkraBazziRecurrence.base_nonempty","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\nn : Nat\nhn : LT.lt 0 n\n‚ä¢ (Finset.Ico (Nat.floor (HMul.hMul (HDiv.hDiv (b (AkraBazziRecurrence.min_bi b)) 2) ‚Üën)) n).Nonempty","decl":"lemma base_nonempty {n : ‚Ñï} (hn : 0 < n) : (Finset.Ico (‚åäb (min_bi b) / 2 * n‚åã‚Çä) n).Nonempty := by\n  let b' := b (min_bi b)\n  have hb_pos : 0 < b' := R.b_pos _\n  simp_rw [Finset.nonempty_Ico]\n  exact_mod_cast calc ‚åäb' / 2 * n‚åã‚Çä ‚â§ b' / 2 * n := by exact Nat.floor_le (by positivity)\n                                 _ < 1 / 2 * n   := by gcongr; exact R.b_lt_one (min_bi b)\n                                 _ ‚â§ 1 * n       := by gcongr; norm_num\n                                 _ = n           := by simp\n\n"}
{"name":"AkraBazziRecurrence.T_isBigO_smoothingFn_mul_asympBound","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Asymptotics.IsBigO Filter.atTop T fun n => HMul.hMul (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ‚Üën)) (AkraBazziRecurrence.asympBound g a b n)","decl":"/-- The main proof of the upper bound part of the Akra-Bazzi theorem. The factor\n`1 - Œµ n` does not change the asymptotic order, but is needed for the induction step to go\nthrough. -/\nlemma T_isBigO_smoothingFn_mul_asympBound :\n    T =O[atTop] (fun n => (1 - Œµ n) * asympBound g a b n) := by\n  let b' := b (min_bi b) / 2\n  have hb_pos : 0 < b' := R.bi_min_div_two_pos\n  rw [isBigO_atTop_iff_eventually_exists]\n  obtain ‚ü®c‚ÇÅ, hc‚ÇÅ, h_sumTransform_aux‚ü© := R.eventually_atTop_sumTransform_ge\n  filter_upwards [eventually_ge_atTop R.n‚ÇÄ,       -- n‚ÇÄ_ge_Rn‚ÇÄ\n      eventually_forall_ge_atTop.mpr eventually_one_sub_smoothingFn_pos,    -- h_smoothing_pos\n      eventually_forall_ge_atTop.mpr\n        <| eventually_one_sub_smoothingFn_gt_const (1/2) (by norm_num),    -- h_smoothing_gt_half\n      eventually_forall_ge_atTop.mpr R.eventually_asympBound_pos,            -- h_asympBound_pos\n      eventually_forall_ge_atTop.mpr R.eventually_asympBound_r_pos,          -- h_asympBound_r_pos\n      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop\n        R.eventually_asympBound_pos,   -- h_asympBound_floor\n      eventually_gt_atTop 0,                                                -- n‚ÇÄ_pos\n      eventually_forall_ge_atTop.mpr R.eventually_one_sub_smoothingFn_r_pos,  -- h_smoothing_r_pos\n      eventually_forall_ge_atTop.mpr R.rpow_p_mul_one_sub_smoothingFn_le,    -- bound1\n      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop\n        eventually_one_sub_smoothingFn_pos,   -- h_smoothingFn_floor\n      eventually_forall_ge_atTop.mpr h_sumTransform_aux,                     -- h_sumTransform\n      eventually_forall_ge_atTop.mpr R.eventually_bi_mul_le_r]               -- h_bi_le_r\n    with n‚ÇÄ n‚ÇÄ_ge_Rn‚ÇÄ h_smoothing_pos h_smoothing_gt_half\n      h_asympBound_pos h_asympBound_r_pos h_asympBound_floor n‚ÇÄ_pos h_smoothing_r_pos\n      bound1 h_smoothingFn_floor h_sumTransform h_bi_le_r\n  -- Max of the ratio `T(n) / asympBound(n)` over the base case `n ‚àà [b * n‚ÇÄ, n‚ÇÄ)`\n  have h_base_nonempty := R.base_nonempty n‚ÇÄ_pos\n  let base_max : ‚Ñù :=\n    (Finset.Ico (‚åäb' * n‚ÇÄ‚åã‚Çä) n‚ÇÄ).sup' h_base_nonempty\n      fun n => T n / ((1 - Œµ n) * asympBound g a b n)\n  -- The big-O constant we are aiming for: max of the base case ratio and what we need to\n  -- cancel out the `g(n)` term in the calculation below\n  set C := max (2 * c‚ÇÅ‚Åª¬π) base_max with hC\n  refine ‚ü®C, fun n hn => ?_‚ü©\n  -- Base case: statement is true for `b' * n‚ÇÄ ‚â§ n < n‚ÇÄ`\n  have h_base : ‚àÄ n ‚àà Finset.Ico (‚åäb' * n‚ÇÄ‚åã‚Çä) n‚ÇÄ, T n ‚â§ C * ((1 - Œµ n) * asympBound g a b n) := by\n    intro n hn\n    rw [Finset.mem_Ico] at hn\n    have htmp1 : 0 < 1 - Œµ n := h_smoothingFn_floor n hn.1\n    have htmp2 : 0 < asympBound g a b n := h_asympBound_floor n hn.1\n    rw [‚Üê _root_.div_le_iff‚ÇÄ (by positivity)]\n    rw [‚Üê Finset.mem_Ico] at hn\n    calc T n / ((1 - Œµ ‚Üën) * asympBound g a b n)\n           ‚â§ (Finset.Ico (‚åäb' * n‚ÇÄ‚åã‚Çä) n‚ÇÄ).sup' h_base_nonempty\n                (fun z => T z / ((1 - Œµ z) * asympBound g a b z)) :=\n                  Finset.le_sup'_of_le _ (b := n) hn le_rfl\n         _ ‚â§ C := le_max_right _ _\n  have h_asympBound_pos' : 0 < asympBound g a b n := h_asympBound_pos n hn\n  have h_one_sub_smoothingFn_pos' : 0 < 1 - Œµ n := h_smoothing_pos n hn\n  rw [Real.norm_of_nonneg (R.T_nonneg n), Real.norm_of_nonneg (by positivity)]\n  -- We now prove all other cases by induction\n  induction n using Nat.strongRecOn with\n  | ind n h_ind =>\n    have b_mul_n‚ÇÄ_le_ri i : ‚åäb' * ‚Üën‚ÇÄ‚åã‚Çä ‚â§ r i n := by\n      exact_mod_cast calc ‚åäb' * (n‚ÇÄ : ‚Ñù)‚åã‚Çä ‚â§ b' * n‚ÇÄ := Nat.floor_le <| by positivity\n                                  _ ‚â§ b' * n         := by gcongr\n                                  _ ‚â§ r i n          := h_bi_le_r n hn i\n    have g_pos : 0 ‚â§ g n := R.g_nonneg n (by positivity)\n    calc\n      T n = (‚àë i, a i * T (r i n)) + g n := by exact R.h_rec n <| n‚ÇÄ_ge_Rn‚ÇÄ.trans hn\n        _ ‚â§ (‚àë i, a i * (C * ((1 - Œµ (r i n)) * asympBound g a b (r i n)))) + g n := by\n            -- Apply the induction hypothesis, or use the base case depending on how large n is\n            gcongr (‚àë i, a i * ?_) + g n with i _\n            ¬∑ exact le_of_lt <| R.a_pos _\n            ¬∑ if ri_lt_n‚ÇÄ : r i n < n‚ÇÄ then\n                exact h_base _ <| by\n                  simp_all only [gt_iff_lt, Nat.ofNat_pos, div_pos_iff_of_pos_right,\n                    eventually_atTop, sub_pos, one_div, mem_Ico, and_imp,\n                    forall_true_left, mem_univ, and_self, b', C, base_max]\n              else\n                push_neg at ri_lt_n‚ÇÄ\n                exact h_ind (r i n) (R.r_lt_n _ _ (n‚ÇÄ_ge_Rn‚ÇÄ.trans hn)) ri_lt_n‚ÇÄ\n                  (h_asympBound_r_pos _ hn _) (h_smoothing_r_pos n hn i)\n        _ = (‚àë i, a i * (C * ((1 - Œµ (r i n)) * ((r i n) ^ (p a b)\n                * (1 + (‚àë u ‚àà range (r i n), g u / u ^ ((p a b) + 1))))))) + g n := by\n            simp_rw [asympBound_def']\n        _ = (‚àë i, C * a i * ((r i n) ^ (p a b) * (1 - Œµ (r i n))\n                * ((1 + (‚àë u ‚àà range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by\n            congr; ext; ring\n        _ ‚â§ (‚àë i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Œµ n)\n                * ((1 + (‚àë u ‚àà range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by\n            gcongr (‚àë i, C * a i * (?_\n                * ((1 + (‚àë u ‚àà range (r i n), g u / u ^ ((p a b) + 1)))))) + g n with i\n            ¬∑ have := R.a_pos i\n              positivity\n            ¬∑ refine add_nonneg zero_le_one <| Finset.sum_nonneg fun j _ => ?_\n              rw [div_nonneg_iff]\n              exact Or.inl ‚ü®R.g_nonneg j (by positivity), by positivity‚ü©\n            ¬∑ exact bound1 n hn i\n        _ = (‚àë i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Œµ n)\n                * ((1 + ((‚àë u ‚àà range n, g u / u ^ ((p a b) + 1))\n                - (‚àë u ‚àà Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))) + g n := by\n            congr; ext i; congr\n            refine eq_sub_of_add_eq ?_\n            rw [add_comm]\n            exact add_eq_of_eq_sub <| Finset.sum_Ico_eq_sub _\n              <| le_of_lt <| R.r_lt_n i n <| n‚ÇÄ_ge_Rn‚ÇÄ.trans hn\n        _ = (‚àë i, C * a i * ((b i) ^ (p a b) * (1 - Œµ n) * ((n ^ (p a b)\n                * (1 + (‚àë u ‚àà range n, g u / u ^ ((p a b) + 1)))\n                - n ^ (p a b) * (‚àë u ‚àà Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))\n                + g n := by\n            congr; ext; ring\n        _ = (‚àë i, C * a i * ((b i) ^ (p a b) * (1 - Œµ n)\n                * ((asympBound g a b n - sumTransform (p a b) g (r i n) n)))) + g n := by\n            simp_rw [asympBound_def', sumTransform_def]\n        _ ‚â§ (‚àë i, C * a i * ((b i) ^ (p a b) * (1 - Œµ n)\n                * ((asympBound g a b n - c‚ÇÅ * g n)))) + g n := by\n            gcongr with i\n            ¬∑ have := R.a_pos i\n              positivity\n            ¬∑ have := R.b_pos i\n              positivity\n            ¬∑ exact h_sumTransform n hn i\n        _ = (‚àë i, C * (1 - Œµ n) * ((asympBound g a b n - c‚ÇÅ * g n))\n                * (a i * (b i) ^ (p a b))) + g n := by\n            congr; ext; ring\n        _ = C * (1 - Œµ n) * (asympBound g a b n - c‚ÇÅ * g n) + g n := by\n            rw [‚Üê Finset.mul_sum, R.sumCoeffsExp_p_eq_one, mul_one]\n        _ = C * (1 - Œµ n) * asympBound g a b n + (1 - C * c‚ÇÅ * (1 - Œµ n)) * g n := by ring\n        _ ‚â§ C * (1 - Œµ n) * asympBound g a b n + 0 := by\n            gcongr\n            refine mul_nonpos_of_nonpos_of_nonneg ?_ g_pos\n            rw [sub_nonpos]\n            calc 1 ‚â§ 2 * (c‚ÇÅ‚Åª¬π * c‚ÇÅ) * (1/2) := by\n                    rw [inv_mul_cancel‚ÇÄ (by positivity : c‚ÇÅ ‚â† 0)]; norm_num\n                 _ = (2 * c‚ÇÅ‚Åª¬π) * c‚ÇÅ * (1/2) := by ring\n                 _ ‚â§ C * c‚ÇÅ * (1 - Œµ n) := by gcongr\n                                              ¬∑ rw [hC]; exact le_max_left _ _\n                                              ¬∑ exact le_of_lt <| h_smoothing_gt_half n hn\n        _ = C * ((1 - Œµ n) * asympBound g a b n) := by ring\n\n"}
{"name":"AkraBazziRecurrence.smoothingFn_mul_asympBound_isBigO_T","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Asymptotics.IsBigO Filter.atTop (fun n => HMul.hMul (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn ‚Üën)) (AkraBazziRecurrence.asympBound g a b n)) T","decl":"/-- The main proof of the lower bound part of the Akra-Bazzi theorem. The factor\n`1 + Œµ n` does not change the asymptotic order, but is needed for the induction step to go\nthrough. -/\nlemma smoothingFn_mul_asympBound_isBigO_T :\n    (fun (n : ‚Ñï) => (1 + Œµ n) * asympBound g a b n) =O[atTop] T := by\n  let b' := b (min_bi b) / 2\n  have hb_pos : 0 < b' := R.bi_min_div_two_pos\n  rw [isBigO_atTop_iff_eventually_exists_pos]\n  obtain ‚ü®c‚ÇÅ, hc‚ÇÅ, h_sumTransform_aux‚ü© := R.eventually_atTop_sumTransform_le\n  filter_upwards [eventually_ge_atTop R.n‚ÇÄ,                                 -- n‚ÇÄ_ge_Rn‚ÇÄ\n      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_gt_atTop 0,        -- h_b_floor\n      eventually_forall_ge_atTop.mpr eventually_one_add_smoothingFn_pos,    -- h_smoothing_pos\n      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop\n        eventually_one_add_smoothingFn_pos,                                 -- h_smoothing_pos'\n      eventually_forall_ge_atTop.mpr R.eventually_asympBound_pos,            -- h_asympBound_pos\n      eventually_forall_ge_atTop.mpr R.eventually_asympBound_r_pos,          -- h_asympBound_r_pos\n      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop\n        R.eventually_asympBound_pos,                                         -- h_asympBound_floor\n      eventually_gt_atTop 0,                                                -- n‚ÇÄ_pos\n      eventually_forall_ge_atTop.mpr R.eventually_one_add_smoothingFn_r_pos,  -- h_smoothing_r_pos\n      eventually_forall_ge_atTop.mpr R.rpow_p_mul_one_add_smoothingFn_ge,   -- bound2\n      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop\n        eventually_one_add_smoothingFn_pos,                                 -- h_smoothingFn_floor\n      eventually_forall_ge_atTop.mpr h_sumTransform_aux,                    -- h_sumTransform\n      eventually_forall_ge_atTop.mpr R.eventually_bi_mul_le_r,              -- h_bi_le_r\n      eventually_forall_ge_atTop.mpr (eventually_ge_atTop ‚åàexp 1‚åâ‚Çä)]        -- h_exp\n    with n‚ÇÄ n‚ÇÄ_ge_Rn‚ÇÄ h_b_floor h_smoothing_pos h_smoothing_pos' h_asympBound_pos h_asympBound_r_pos\n      h_asympBound_floor n‚ÇÄ_pos h_smoothing_r_pos bound2 h_smoothingFn_floor h_sumTransform\n      h_bi_le_r h_exp\n  have h_base_nonempty := R.base_nonempty n‚ÇÄ_pos\n  -- Min of the ratio T(n) / asympBound(n) over the base case n ‚àà [b * n‚ÇÄ, n‚ÇÄ)\n  set base_min : ‚Ñù :=\n    (Finset.Ico (‚åäb' * n‚ÇÄ‚åã‚Çä) n‚ÇÄ).inf' h_base_nonempty\n      (fun n => T n / ((1 + Œµ n) * asympBound g a b n)) with base_min_def\n  -- The big-O constant we are aiming for: min of the base case ratio and what we need to cancel\n  -- out the g(n) term in the calculation below\n  let C := min (2 * c‚ÇÅ)‚Åª¬π base_min\n  have hC_pos : 0 < C := by\n    refine lt_min (by positivity) ?_\n    obtain ‚ü®m, hm_mem, hm‚ü© :=\n      Finset.exists_mem_eq_inf' h_base_nonempty (fun n => T n / ((1 + Œµ n) * asympBound g a b n))\n    calc 0 < T m / ((1 + Œµ m) * asympBound g a b m) := by\n              have H‚ÇÅ : 0 < T m := by exact R.T_pos _\n              have H‚ÇÇ : 0 < 1 + Œµ m := by rw [Finset.mem_Ico] at hm_mem\n                                          exact h_smoothing_pos' m hm_mem.1\n              have H‚ÇÉ : 0 < asympBound g a b m := by\n                refine R.asympBound_pos m ?_\n                calc 0 < ‚åäb' * n‚ÇÄ‚åã‚Çä := by exact h_b_floor\n                     _ ‚â§ m := by rw [Finset.mem_Ico] at hm_mem; exact hm_mem.1\n              positivity\n         _ = base_min := by rw [base_min_def, hm]\n  refine ‚ü®C, hC_pos, fun n hn => ?_‚ü©\n  -- Base case: statement is true for `b' * n‚ÇÄ ‚â§ n < n‚ÇÄ`\n  have h_base : ‚àÄ n ‚àà Finset.Ico (‚åäb' * n‚ÇÄ‚åã‚Çä) n‚ÇÄ, C * ((1 + Œµ n) * asympBound g a b n) ‚â§ T n := by\n    intro n hn\n    rw [Finset.mem_Ico] at hn\n    have htmp1 : 0 < 1 + Œµ n := h_smoothingFn_floor n hn.1\n    have htmp2 : 0 < asympBound g a b n := h_asympBound_floor n hn.1\n    rw [‚Üê _root_.le_div_iff‚ÇÄ (by positivity)]\n    rw [‚Üê Finset.mem_Ico] at hn\n    calc T n / ((1 + Œµ ‚Üën) * asympBound g a b n)\n           ‚â• (Finset.Ico (‚åäb' * n‚ÇÄ‚åã‚Çä) n‚ÇÄ).inf' h_base_nonempty\n                  fun z => T z / ((1 + Œµ z) * asympBound g a b z) :=\n                    Finset.inf'_le_of_le _ (b := n) hn <| le_refl _\n         _ ‚â• C := min_le_right _ _\n  have h_asympBound_pos' : 0 < asympBound g a b n := h_asympBound_pos n hn\n  have h_one_sub_smoothingFn_pos' : 0 < 1 + Œµ n := h_smoothing_pos n hn\n  rw [Real.norm_of_nonneg (R.T_nonneg n), Real.norm_of_nonneg (by positivity)]\n  -- We now prove all other cases by induction\n  induction n using Nat.strongRecOn with\n  | ind n h_ind =>\n    have b_mul_n‚ÇÄ_le_ri i : ‚åäb' * ‚Üën‚ÇÄ‚åã‚Çä ‚â§ r i n := by\n      exact_mod_cast calc ‚åäb' * ‚Üën‚ÇÄ‚åã‚Çä ‚â§ b' * n‚ÇÄ := Nat.floor_le <| by positivity\n                                  _ ‚â§ b' * n := by gcongr\n                                  _ ‚â§ r i n := h_bi_le_r n hn i\n    have g_pos : 0 ‚â§ g n := R.g_nonneg n (by positivity)\n    calc\n      T n = (‚àë i, a i * T (r i n)) + g n := by exact R.h_rec n <| n‚ÇÄ_ge_Rn‚ÇÄ.trans hn\n        _ ‚â• (‚àë i, a i * (C * ((1 + Œµ (r i n)) * asympBound g a b (r i n)))) + g n := by\n            -- Apply the induction hypothesis, or use the base case depending on how large `n` is\n              gcongr (‚àë i, a i * ?_) + g n with i _\n              ¬∑ exact le_of_lt <| R.a_pos _\n              ¬∑ cases lt_or_le (r i n) n‚ÇÄ with\n                | inl ri_lt_n‚ÇÄ => exact h_base _ <| Finset.mem_Ico.mpr ‚ü®b_mul_n‚ÇÄ_le_ri i, ri_lt_n‚ÇÄ‚ü©\n                | inr n‚ÇÄ_le_ri =>\n                  exact h_ind (r i n) (R.r_lt_n _ _ (n‚ÇÄ_ge_Rn‚ÇÄ.trans hn)) n‚ÇÄ_le_ri\n                    (h_asympBound_r_pos _ hn _) (h_smoothing_r_pos n hn i)\n        _ = (‚àë i, a i * (C * ((1 + Œµ (r i n)) * ((r i n) ^ (p a b)\n                  * (1 + (‚àë u ‚àà range (r i n), g u / u ^ ((p a b) + 1))))))) + g n := by\n              simp_rw [asympBound_def']\n        _ = (‚àë i, C * a i * ((r i n)^(p a b) * (1 + Œµ (r i n))\n                  * ((1 + (‚àë u ‚àà range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by\n              congr; ext; ring\n        _ ‚â• (‚àë i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n)\n                  * ((1 + (‚àë u ‚àà range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by\n              gcongr (‚àë i, C * a i * (?_ *\n                  ((1 + (‚àë u ‚àà range (r i n), g u / u ^ ((p a b) + 1)))))) + g n with i\n              ¬∑ have := R.a_pos i\n                positivity\n              ¬∑ refine add_nonneg zero_le_one <| Finset.sum_nonneg fun j _ => ?_\n                rw [div_nonneg_iff]\n                exact Or.inl ‚ü®R.g_nonneg j (by positivity), by positivity‚ü©\n              ¬∑ exact bound2 n hn i\n        _ = (‚àë i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 + Œµ n)\n                  * ((1 + ((‚àë u ‚àà range n, g u / u ^ ((p a b) + 1))\n                  - (‚àë u ‚àà Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))) + g n := by\n              congr; ext i; congr\n              refine eq_sub_of_add_eq ?_\n              rw [add_comm]\n              exact add_eq_of_eq_sub <| Finset.sum_Ico_eq_sub _\n                <| le_of_lt <| R.r_lt_n i n <| n‚ÇÄ_ge_Rn‚ÇÄ.trans hn\n        _ = (‚àë i, C * a i * ((b i) ^ (p a b) * (1 + Œµ n)\n                  * ((n ^ (p a b) * (1 + (‚àë u ‚àà range n, g u / u ^ ((p a b) + 1)))\n                  - n ^ (p a b) * (‚àë u ‚àà Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))\n                  + g n := by\n              congr; ext; ring\n        _ = (‚àë i, C * a i * ((b i) ^ (p a b) * (1 + Œµ n)\n                  * ((asympBound g a b n - sumTransform (p a b) g (r i n) n)))) + g n := by\n              simp_rw [asympBound_def', sumTransform_def]\n        _ ‚â• (‚àë i, C * a i * ((b i) ^ (p a b) * (1 + Œµ n)\n                  * ((asympBound g a b n - c‚ÇÅ * g n)))) + g n := by\n              gcongr with i\n              ¬∑ have := R.a_pos i\n                positivity\n              ¬∑ have := R.b_pos i\n                positivity\n              ¬∑ exact h_sumTransform n hn i\n        _ = (‚àë i, C * (1 + Œµ n) * ((asympBound g a b n - c‚ÇÅ * g n))\n                  * (a i * (b i) ^ (p a b))) + g n := by congr; ext; ring\n        _ = C * (1 + Œµ n) * (asympBound g a b n - c‚ÇÅ * g n) + g n := by\n              rw [‚Üê Finset.mul_sum, R.sumCoeffsExp_p_eq_one, mul_one]\n        _ = C * (1 + Œµ n) * asympBound g a b n + (1 - C * c‚ÇÅ * (1 + Œµ n)) * g n := by ring\n        _ ‚â• C * (1 + Œµ n) * asympBound g a b n + 0 := by\n              gcongr\n              refine mul_nonneg ?_ g_pos\n              rw [sub_nonneg]\n              calc C * c‚ÇÅ * (1 + Œµ n) ‚â§ C * c‚ÇÅ * 2 := by\n                        gcongr\n                        refine one_add_smoothingFn_le_two ?_\n                        calc exp 1 ‚â§ ‚åàexp 1‚åâ‚Çä := by exact Nat.le_ceil _\n                                 _ ‚â§ n := by exact_mod_cast h_exp n hn\n                    _ = C * (2 * c‚ÇÅ) := by ring\n                    _ ‚â§ (2 * c‚ÇÅ)‚Åª¬π * (2 * c‚ÇÅ) := by gcongr; exact min_le_left _ _\n                    _ = c‚ÇÅ‚Åª¬π * c‚ÇÅ := by ring\n                    _ = 1 := inv_mul_cancel‚ÇÄ (by positivity)\n        _ = C * ((1 + Œµ n) * asympBound g a b n) := by ring\n\n"}
{"name":"AkraBazziRecurrence.isBigO_asympBound","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Asymptotics.IsBigO Filter.atTop T (AkraBazziRecurrence.asympBound g a b)","decl":"/-- The **Akra-Bazzi theorem**: `T ‚àà O(n^p (1 + ‚àë_u^n g(u) / u^{p+1}))` -/\ntheorem isBigO_asympBound : T =O[atTop] asympBound g a b := by\n  calc T =O[atTop] (fun n => (1 - Œµ n) * asympBound g a b n) := by\n              exact R.T_isBigO_smoothingFn_mul_asympBound\n         _ =O[atTop] (fun n => 1 * asympBound g a b n) := by\n              refine IsBigO.mul (isBigO_const_of_tendsto (y := 1) ?_ one_ne_zero)\n                (isBigO_refl _ _)\n              rw [‚Üê Function.comp_def (fun n => 1 - Œµ n) Nat.cast]\n              exact Tendsto.comp isEquivalent_one_sub_smoothingFn_one.tendsto_const\n                tendsto_natCast_atTop_atTop\n         _ = asympBound g a b := by simp\n\n"}
{"name":"AkraBazziRecurrence.isBigO_symm_asympBound","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Asymptotics.IsBigO Filter.atTop (AkraBazziRecurrence.asympBound g a b) T","decl":"/-- The **Akra-Bazzi theorem**: `T ‚àà Œ©(n^p (1 + ‚àë_u^n g(u) / u^{p+1}))` -/\ntheorem isBigO_symm_asympBound : asympBound g a b =O[atTop] T := by\n  calc asympBound g a b = (fun n => 1 * asympBound g a b n) := by simp\n                 _ ~[atTop] (fun n => (1 + Œµ n) * asympBound g a b n) := by\n                            refine IsEquivalent.mul (IsEquivalent.symm ?_) IsEquivalent.refl\n                            rw [Function.const_def, isEquivalent_const_iff_tendsto one_ne_zero,\n                              ‚Üê Function.comp_def (fun n => 1 + Œµ n) Nat.cast]\n                            exact Tendsto.comp isEquivalent_one_add_smoothingFn_one.tendsto_const\n                              tendsto_natCast_atTop_atTop\n                 _ =O[atTop] T := R.smoothingFn_mul_asympBound_isBigO_T\n\n"}
{"name":"AkraBazziRecurrence.isTheta_asympBound","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Fintype Œ±\nT : Nat ‚Üí Real\ng : Real ‚Üí Real\na b : Œ± ‚Üí Real\nr : Œ± ‚Üí Nat ‚Üí Nat\ninst‚úù : Nonempty Œ±\nR : AkraBazziRecurrence T g a b r\n‚ä¢ Asymptotics.IsTheta Filter.atTop T (AkraBazziRecurrence.asympBound g a b)","decl":"/-- The **Akra-Bazzi theorem**: `T ‚àà Œò(n^p (1 + ‚àë_u^n g(u) / u^{p+1}))` -/\ntheorem isTheta_asympBound : T =Œò[atTop] asympBound g a b :=\n  ‚ü®R.isBigO_asympBound, R.isBigO_symm_asympBound‚ü©\n\n"}
