{"name":"AkraBazziRecurrence.a_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\nself : AkraBazziRecurrence T g a b r\ni : α\n⊢ LT.lt 0 (a i)","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (∑ i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {α : Type*} [Fintype α] [Nonempty α]\n    (T : ℕ → ℝ) (g : ℝ → ℝ) (a : α → ℝ) (b : α → ℝ) (r : α → ℕ → ℕ) where\n  /-- Point below which the recurrence is in the base case -/\n  n₀ : ℕ\n  /-- `n₀` is always `> 0` -/\n  n₀_gt_zero : 0 < n₀\n  /-- The `a`'s are nonzero -/\n  a_pos : ∀ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ∀ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ∀ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ∀ x ≥ 0, 0 ≤ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ℕ) (hn₀ : n₀ ≤ n) : T n = (∑ i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n₀` -/\n  T_gt_zero' (n : ℕ) (hn : n < n₀) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ∀ i n, n₀ ≤ n → r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ∀ i, (fun n => (r i n : ℝ) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.mk.sizeOf_spec","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ninst✝¹ : Nonempty α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : SizeOf α\nn₀ : Nat\nn₀_gt_zero : LT.lt 0 n₀\na_pos : ∀ (i : α), LT.lt 0 (a i)\nb_pos : ∀ (i : α), LT.lt 0 (b i)\nb_lt_one : ∀ (i : α), LT.lt (b i) 1\ng_nonneg : ∀ (x : Real), GE.ge x 0 → LE.le 0 (g x)\ng_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\nh_rec : ∀ (n : Nat), LE.le n₀ n → Eq (T n) (HAdd.hAdd (Finset.univ.sum fun i => HMul.hMul (a i) (T (r i n))) (g ↑n))\nT_gt_zero' : ∀ (n : Nat), LT.lt n n₀ → LT.lt 0 (T n)\nr_lt_n : ∀ (i : α) (n : Nat), LE.le n₀ n → LT.lt (r i n) n\ndist_r_b : ∀ (i : α), Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (↑(r i n)) (HMul.hMul (b i) ↑n)) fun n => HDiv.hDiv (↑n) (HPow.hPow (Real.log ↑n) 2)\n⊢ Eq (SizeOf.sizeOf { n₀ := n₀, n₀_gt_zero := n₀_gt_zero, a_pos := a_pos, b_pos := b_pos, b_lt_one := b_lt_one, g_nonneg := g_nonneg, g_grows_poly := g_grows_poly, h_rec := h_rec, T_gt_zero' := T_gt_zero', r_lt_n := r_lt_n, dist_r_b := dist_r_b }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf n₀)) (SizeOf.sizeOf n₀_gt_zero))","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (∑ i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {α : Type*} [Fintype α] [Nonempty α]\n    (T : ℕ → ℝ) (g : ℝ → ℝ) (a : α → ℝ) (b : α → ℝ) (r : α → ℕ → ℕ) where\n  /-- Point below which the recurrence is in the base case -/\n  n₀ : ℕ\n  /-- `n₀` is always `> 0` -/\n  n₀_gt_zero : 0 < n₀\n  /-- The `a`'s are nonzero -/\n  a_pos : ∀ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ∀ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ∀ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ∀ x ≥ 0, 0 ≤ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ℕ) (hn₀ : n₀ ≤ n) : T n = (∑ i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n₀` -/\n  T_gt_zero' (n : ℕ) (hn : n < n₀) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ∀ i n, n₀ ≤ n → r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ∀ i, (fun n => (r i n : ℝ) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.b_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\nself : AkraBazziRecurrence T g a b r\ni : α\n⊢ LT.lt 0 (b i)","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (∑ i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {α : Type*} [Fintype α] [Nonempty α]\n    (T : ℕ → ℝ) (g : ℝ → ℝ) (a : α → ℝ) (b : α → ℝ) (r : α → ℕ → ℕ) where\n  /-- Point below which the recurrence is in the base case -/\n  n₀ : ℕ\n  /-- `n₀` is always `> 0` -/\n  n₀_gt_zero : 0 < n₀\n  /-- The `a`'s are nonzero -/\n  a_pos : ∀ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ∀ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ∀ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ∀ x ≥ 0, 0 ≤ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ℕ) (hn₀ : n₀ ≤ n) : T n = (∑ i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n₀` -/\n  T_gt_zero' (n : ℕ) (hn : n < n₀) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ∀ i n, n₀ ≤ n → r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ∀ i, (fun n => (r i n : ℝ) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.h_rec","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\nself : AkraBazziRecurrence T g a b r\nn : Nat\nhn₀ : LE.le self.n₀ n\n⊢ Eq (T n) (HAdd.hAdd (Finset.univ.sum fun i => HMul.hMul (a i) (T (r i n))) (g ↑n))","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (∑ i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {α : Type*} [Fintype α] [Nonempty α]\n    (T : ℕ → ℝ) (g : ℝ → ℝ) (a : α → ℝ) (b : α → ℝ) (r : α → ℕ → ℕ) where\n  /-- Point below which the recurrence is in the base case -/\n  n₀ : ℕ\n  /-- `n₀` is always `> 0` -/\n  n₀_gt_zero : 0 < n₀\n  /-- The `a`'s are nonzero -/\n  a_pos : ∀ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ∀ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ∀ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ∀ x ≥ 0, 0 ≤ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ℕ) (hn₀ : n₀ ≤ n) : T n = (∑ i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n₀` -/\n  T_gt_zero' (n : ℕ) (hn : n < n₀) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ∀ i n, n₀ ≤ n → r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ∀ i, (fun n => (r i n : ℝ) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.r_lt_n","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\nself : AkraBazziRecurrence T g a b r\ni : α\nn : Nat\na✝ : LE.le self.n₀ n\n⊢ LT.lt (r i n) n","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (∑ i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {α : Type*} [Fintype α] [Nonempty α]\n    (T : ℕ → ℝ) (g : ℝ → ℝ) (a : α → ℝ) (b : α → ℝ) (r : α → ℕ → ℕ) where\n  /-- Point below which the recurrence is in the base case -/\n  n₀ : ℕ\n  /-- `n₀` is always `> 0` -/\n  n₀_gt_zero : 0 < n₀\n  /-- The `a`'s are nonzero -/\n  a_pos : ∀ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ∀ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ∀ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ∀ x ≥ 0, 0 ≤ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ℕ) (hn₀ : n₀ ≤ n) : T n = (∑ i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n₀` -/\n  T_gt_zero' (n : ℕ) (hn : n < n₀) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ∀ i n, n₀ ≤ n → r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ∀ i, (fun n => (r i n : ℝ) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.b_lt_one","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\nself : AkraBazziRecurrence T g a b r\ni : α\n⊢ LT.lt (b i) 1","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (∑ i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {α : Type*} [Fintype α] [Nonempty α]\n    (T : ℕ → ℝ) (g : ℝ → ℝ) (a : α → ℝ) (b : α → ℝ) (r : α → ℕ → ℕ) where\n  /-- Point below which the recurrence is in the base case -/\n  n₀ : ℕ\n  /-- `n₀` is always `> 0` -/\n  n₀_gt_zero : 0 < n₀\n  /-- The `a`'s are nonzero -/\n  a_pos : ∀ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ∀ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ∀ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ∀ x ≥ 0, 0 ≤ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ℕ) (hn₀ : n₀ ≤ n) : T n = (∑ i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n₀` -/\n  T_gt_zero' (n : ℕ) (hn : n < n₀) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ∀ i n, n₀ ≤ n → r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ∀ i, (fun n => (r i n : ℝ) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.g_nonneg","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\nself : AkraBazziRecurrence T g a b r\nx : Real\na✝ : GE.ge x 0\n⊢ LE.le 0 (g x)","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (∑ i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {α : Type*} [Fintype α] [Nonempty α]\n    (T : ℕ → ℝ) (g : ℝ → ℝ) (a : α → ℝ) (b : α → ℝ) (r : α → ℕ → ℕ) where\n  /-- Point below which the recurrence is in the base case -/\n  n₀ : ℕ\n  /-- `n₀` is always `> 0` -/\n  n₀_gt_zero : 0 < n₀\n  /-- The `a`'s are nonzero -/\n  a_pos : ∀ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ∀ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ∀ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ∀ x ≥ 0, 0 ≤ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ℕ) (hn₀ : n₀ ≤ n) : T n = (∑ i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n₀` -/\n  T_gt_zero' (n : ℕ) (hn : n < n₀) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ∀ i n, n₀ ≤ n → r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ∀ i, (fun n => (r i n : ℝ) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.dist_r_b","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\nself : AkraBazziRecurrence T g a b r\ni : α\n⊢ Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (↑(r i n)) (HMul.hMul (b i) ↑n)) fun n => HDiv.hDiv (↑n) (HPow.hPow (Real.log ↑n) 2)","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (∑ i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {α : Type*} [Fintype α] [Nonempty α]\n    (T : ℕ → ℝ) (g : ℝ → ℝ) (a : α → ℝ) (b : α → ℝ) (r : α → ℕ → ℕ) where\n  /-- Point below which the recurrence is in the base case -/\n  n₀ : ℕ\n  /-- `n₀` is always `> 0` -/\n  n₀_gt_zero : 0 < n₀\n  /-- The `a`'s are nonzero -/\n  a_pos : ∀ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ∀ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ∀ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ∀ x ≥ 0, 0 ≤ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ℕ) (hn₀ : n₀ ≤ n) : T n = (∑ i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n₀` -/\n  T_gt_zero' (n : ℕ) (hn : n < n₀) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ∀ i n, n₀ ≤ n → r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ∀ i, (fun n => (r i n : ℝ) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.mk.injEq","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\nn₀✝ : Nat\nn₀_gt_zero✝ : LT.lt 0 n₀✝\na_pos✝ : ∀ (i : α), LT.lt 0 (a i)\nb_pos✝ : ∀ (i : α), LT.lt 0 (b i)\nb_lt_one✝ : ∀ (i : α), LT.lt (b i) 1\ng_nonneg✝ : ∀ (x : Real), GE.ge x 0 → LE.le 0 (g x)\ng_grows_poly✝ : AkraBazziRecurrence.GrowsPolynomially g\nh_rec✝ : ∀ (n : Nat), LE.le n₀✝ n → Eq (T n) (HAdd.hAdd (Finset.univ.sum fun i => HMul.hMul (a i) (T (r i n))) (g ↑n))\nT_gt_zero'✝ : ∀ (n : Nat), LT.lt n n₀✝ → LT.lt 0 (T n)\nr_lt_n✝ : ∀ (i : α) (n : Nat), LE.le n₀✝ n → LT.lt (r i n) n\ndist_r_b✝ : ∀ (i : α), Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (↑(r i n)) (HMul.hMul (b i) ↑n)) fun n => HDiv.hDiv (↑n) (HPow.hPow (Real.log ↑n) 2)\nn₀ : Nat\nn₀_gt_zero : LT.lt 0 n₀\na_pos : ∀ (i : α), LT.lt 0 (a i)\nb_pos : ∀ (i : α), LT.lt 0 (b i)\nb_lt_one : ∀ (i : α), LT.lt (b i) 1\ng_nonneg : ∀ (x : Real), GE.ge x 0 → LE.le 0 (g x)\ng_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\nh_rec : ∀ (n : Nat), LE.le n₀ n → Eq (T n) (HAdd.hAdd (Finset.univ.sum fun i => HMul.hMul (a i) (T (r i n))) (g ↑n))\nT_gt_zero' : ∀ (n : Nat), LT.lt n n₀ → LT.lt 0 (T n)\nr_lt_n : ∀ (i : α) (n : Nat), LE.le n₀ n → LT.lt (r i n) n\ndist_r_b : ∀ (i : α), Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (↑(r i n)) (HMul.hMul (b i) ↑n)) fun n => HDiv.hDiv (↑n) (HPow.hPow (Real.log ↑n) 2)\n⊢ Eq (Eq { n₀ := n₀✝, n₀_gt_zero := n₀_gt_zero✝, a_pos := a_pos✝, b_pos := b_pos✝, b_lt_one := b_lt_one✝, g_nonneg := g_nonneg✝, g_grows_poly := g_grows_poly✝, h_rec := h_rec✝, T_gt_zero' := T_gt_zero'✝, r_lt_n := r_lt_n✝, dist_r_b := dist_r_b✝ } { n₀ := n₀, n₀_gt_zero := n₀_gt_zero, a_pos := a_pos, b_pos := b_pos, b_lt_one := b_lt_one, g_nonneg := g_nonneg, g_grows_poly := g_grows_poly, h_rec := h_rec, T_gt_zero' := T_gt_zero', r_lt_n := r_lt_n, dist_r_b := dist_r_b }) (Eq n₀✝ n₀)","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (∑ i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {α : Type*} [Fintype α] [Nonempty α]\n    (T : ℕ → ℝ) (g : ℝ → ℝ) (a : α → ℝ) (b : α → ℝ) (r : α → ℕ → ℕ) where\n  /-- Point below which the recurrence is in the base case -/\n  n₀ : ℕ\n  /-- `n₀` is always `> 0` -/\n  n₀_gt_zero : 0 < n₀\n  /-- The `a`'s are nonzero -/\n  a_pos : ∀ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ∀ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ∀ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ∀ x ≥ 0, 0 ≤ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ℕ) (hn₀ : n₀ ≤ n) : T n = (∑ i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n₀` -/\n  T_gt_zero' (n : ℕ) (hn : n < n₀) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ∀ i n, n₀ ≤ n → r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ∀ i, (fun n => (r i n : ℝ) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.n₀_gt_zero","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\nself : AkraBazziRecurrence T g a b r\n⊢ LT.lt 0 self.n₀","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (∑ i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {α : Type*} [Fintype α] [Nonempty α]\n    (T : ℕ → ℝ) (g : ℝ → ℝ) (a : α → ℝ) (b : α → ℝ) (r : α → ℕ → ℕ) where\n  /-- Point below which the recurrence is in the base case -/\n  n₀ : ℕ\n  /-- `n₀` is always `> 0` -/\n  n₀_gt_zero : 0 < n₀\n  /-- The `a`'s are nonzero -/\n  a_pos : ∀ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ∀ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ∀ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ∀ x ≥ 0, 0 ≤ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ℕ) (hn₀ : n₀ ≤ n) : T n = (∑ i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n₀` -/\n  T_gt_zero' (n : ℕ) (hn : n < n₀) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ∀ i n, n₀ ≤ n → r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ∀ i, (fun n => (r i n : ℝ) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.T_gt_zero'","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\nself : AkraBazziRecurrence T g a b r\nn : Nat\nhn : LT.lt n self.n₀\n⊢ LT.lt 0 (T n)","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (∑ i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {α : Type*} [Fintype α] [Nonempty α]\n    (T : ℕ → ℝ) (g : ℝ → ℝ) (a : α → ℝ) (b : α → ℝ) (r : α → ℕ → ℕ) where\n  /-- Point below which the recurrence is in the base case -/\n  n₀ : ℕ\n  /-- `n₀` is always `> 0` -/\n  n₀_gt_zero : 0 < n₀\n  /-- The `a`'s are nonzero -/\n  a_pos : ∀ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ∀ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ∀ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ∀ x ≥ 0, 0 ≤ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ℕ) (hn₀ : n₀ ≤ n) : T n = (∑ i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n₀` -/\n  T_gt_zero' (n : ℕ) (hn : n < n₀) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ∀ i n, n₀ ≤ n → r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ∀ i, (fun n => (r i n : ℝ) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.mk.inj","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\nn₀✝ : Nat\nn₀_gt_zero✝ : LT.lt 0 n₀✝\na_pos✝ : ∀ (i : α), LT.lt 0 (a i)\nb_pos✝ : ∀ (i : α), LT.lt 0 (b i)\nb_lt_one✝ : ∀ (i : α), LT.lt (b i) 1\ng_nonneg✝ : ∀ (x : Real), GE.ge x 0 → LE.le 0 (g x)\ng_grows_poly✝ : AkraBazziRecurrence.GrowsPolynomially g\nh_rec✝ : ∀ (n : Nat), LE.le n₀✝ n → Eq (T n) (HAdd.hAdd (Finset.univ.sum fun i => HMul.hMul (a i) (T (r i n))) (g ↑n))\nT_gt_zero'✝ : ∀ (n : Nat), LT.lt n n₀✝ → LT.lt 0 (T n)\nr_lt_n✝ : ∀ (i : α) (n : Nat), LE.le n₀✝ n → LT.lt (r i n) n\ndist_r_b✝ : ∀ (i : α), Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (↑(r i n)) (HMul.hMul (b i) ↑n)) fun n => HDiv.hDiv (↑n) (HPow.hPow (Real.log ↑n) 2)\nn₀ : Nat\nn₀_gt_zero : LT.lt 0 n₀\na_pos : ∀ (i : α), LT.lt 0 (a i)\nb_pos : ∀ (i : α), LT.lt 0 (b i)\nb_lt_one : ∀ (i : α), LT.lt (b i) 1\ng_nonneg : ∀ (x : Real), GE.ge x 0 → LE.le 0 (g x)\ng_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\nh_rec : ∀ (n : Nat), LE.le n₀ n → Eq (T n) (HAdd.hAdd (Finset.univ.sum fun i => HMul.hMul (a i) (T (r i n))) (g ↑n))\nT_gt_zero' : ∀ (n : Nat), LT.lt n n₀ → LT.lt 0 (T n)\nr_lt_n : ∀ (i : α) (n : Nat), LE.le n₀ n → LT.lt (r i n) n\ndist_r_b : ∀ (i : α), Asymptotics.IsLittleO Filter.atTop (fun n => HSub.hSub (↑(r i n)) (HMul.hMul (b i) ↑n)) fun n => HDiv.hDiv (↑n) (HPow.hPow (Real.log ↑n) 2)\nx✝ : Eq { n₀ := n₀✝, n₀_gt_zero := n₀_gt_zero✝, a_pos := a_pos✝, b_pos := b_pos✝, b_lt_one := b_lt_one✝, g_nonneg := g_nonneg✝, g_grows_poly := g_grows_poly✝, h_rec := h_rec✝, T_gt_zero' := T_gt_zero'✝, r_lt_n := r_lt_n✝, dist_r_b := dist_r_b✝ } { n₀ := n₀, n₀_gt_zero := n₀_gt_zero, a_pos := a_pos, b_pos := b_pos, b_lt_one := b_lt_one, g_nonneg := g_nonneg, g_grows_poly := g_grows_poly, h_rec := h_rec, T_gt_zero' := T_gt_zero', r_lt_n := r_lt_n, dist_r_b := dist_r_b }\n⊢ Eq n₀✝ n₀","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (∑ i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {α : Type*} [Fintype α] [Nonempty α]\n    (T : ℕ → ℝ) (g : ℝ → ℝ) (a : α → ℝ) (b : α → ℝ) (r : α → ℕ → ℕ) where\n  /-- Point below which the recurrence is in the base case -/\n  n₀ : ℕ\n  /-- `n₀` is always `> 0` -/\n  n₀_gt_zero : 0 < n₀\n  /-- The `a`'s are nonzero -/\n  a_pos : ∀ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ∀ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ∀ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ∀ x ≥ 0, 0 ≤ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ℕ) (hn₀ : n₀ ≤ n) : T n = (∑ i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n₀` -/\n  T_gt_zero' (n : ℕ) (hn : n < n₀) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ∀ i n, n₀ ≤ n → r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ∀ i, (fun n => (r i n : ℝ) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.g_grows_poly","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\nself : AkraBazziRecurrence T g a b r\n⊢ AkraBazziRecurrence.GrowsPolynomially g","decl":"/-- An Akra-Bazzi recurrence is a function that satisfies the recurrence\n`T n = (∑ i, a i * T (r i n)) + g n`. -/\nstructure AkraBazziRecurrence {α : Type*} [Fintype α] [Nonempty α]\n    (T : ℕ → ℝ) (g : ℝ → ℝ) (a : α → ℝ) (b : α → ℝ) (r : α → ℕ → ℕ) where\n  /-- Point below which the recurrence is in the base case -/\n  n₀ : ℕ\n  /-- `n₀` is always `> 0` -/\n  n₀_gt_zero : 0 < n₀\n  /-- The `a`'s are nonzero -/\n  a_pos : ∀ i, 0 < a i\n  /-- The `b`'s are nonzero -/\n  b_pos : ∀ i, 0 < b i\n  /-- The b's are less than 1 -/\n  b_lt_one : ∀ i, b i < 1\n  /-- `g` is nonnegative -/\n  g_nonneg : ∀ x ≥ 0, 0 ≤ g x\n  /-- `g` grows polynomially -/\n  g_grows_poly : AkraBazziRecurrence.GrowsPolynomially g\n  /-- The actual recurrence -/\n  h_rec (n : ℕ) (hn₀ : n₀ ≤ n) : T n = (∑ i, a i * T (r i n)) + g n\n  /-- Base case: `T(n) > 0` whenever `n < n₀` -/\n  T_gt_zero' (n : ℕ) (hn : n < n₀) : 0 < T n\n  /-- The `r`'s always reduce `n` -/\n  r_lt_n : ∀ i n, n₀ ≤ n → r i n < n\n  /-- The `r`'s approximate the `b`'s -/\n  dist_r_b : ∀ i, (fun n => (r i n : ℝ) - b i * n) =o[atTop] fun n => n / (log n) ^ 2\n\n"}
{"name":"AkraBazziRecurrence.min_bi_le","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Finite α\ninst✝ : Nonempty α\nb : α → Real\ni : α\n⊢ LE.le (b (AkraBazziRecurrence.min_bi b)) (b i)","decl":"@[aesop safe apply]\nlemma min_bi_le {b : α → ℝ} (i : α) : b (min_bi b) ≤ b i :=\n  Classical.choose_spec (Finite.exists_min b) i\n\n"}
{"name":"AkraBazziRecurrence.max_bi_le","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Finite α\ninst✝ : Nonempty α\nb : α → Real\ni : α\n⊢ LE.le (b i) (b (AkraBazziRecurrence.max_bi b))","decl":"@[aesop safe apply]\nlemma max_bi_le {b : α → ℝ} (i : α) : b i ≤ b (max_bi b) :=\n  Classical.choose_spec (Finite.exists_max b) i\n\n"}
{"name":"AkraBazziRecurrence.isLittleO_self_div_log_id","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Asymptotics.IsLittleO Filter.atTop (fun n => HDiv.hDiv (↑n) (HPow.hPow (Real.log ↑n) 2)) fun n => ↑n","decl":"lemma isLittleO_self_div_log_id :\n    (fun (n : ℕ) => n / log n ^ 2) =o[atTop] (fun (n : ℕ) => (n : ℝ)) := by\n  calc (fun (n : ℕ) => (n : ℝ) / log n ^ 2) = fun (n : ℕ) => (n : ℝ) * ((log n) ^ 2)⁻¹ := by\n                  simp_rw [div_eq_mul_inv]\n         _ =o[atTop] fun (n : ℕ) => (n : ℝ) * 1⁻¹ := by\n                  refine IsBigO.mul_isLittleO (isBigO_refl _ _) ?_\n                  refine IsLittleO.inv_rev ?main ?zero\n                  case zero => simp\n                  case main => calc\n                    _ = (fun (_ : ℕ) => ((1 : ℝ) ^ 2))     := by simp\n                    _ =o[atTop] (fun (n : ℕ) => (log n)^2) :=\n                          IsLittleO.pow (IsLittleO.natCast_atTop\n                            <| isLittleO_const_log_atTop) (by norm_num)\n         _ = (fun (n : ℕ) => (n : ℝ)) := by ext; simp\n\n"}
{"name":"AkraBazziRecurrence.dist_r_b'","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Eventually (fun n => ∀ (i : α), LE.le (Norm.norm (HSub.hSub (↑(r i n)) (HMul.hMul (b i) ↑n))) (HDiv.hDiv (↑n) (HPow.hPow (Real.log ↑n) 2))) Filter.atTop","decl":"lemma dist_r_b' : ∀ᶠ n in atTop, ∀ i, ‖(r i n : ℝ) - b i * n‖ ≤ n / log n ^ 2 := by\n  rw [Filter.eventually_all]\n  intro i\n  simpa using IsLittleO.eventuallyLE (R.dist_r_b i)\n\n"}
{"name":"AkraBazziRecurrence.eventually_b_le_r","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Eventually (fun n => ∀ (i : α), LE.le (HSub.hSub (HMul.hMul (b i) ↑n) (HDiv.hDiv (↑n) (HPow.hPow (Real.log ↑n) 2))) ↑(r i n)) Filter.atTop","decl":"lemma eventually_b_le_r : ∀ᶠ (n : ℕ) in atTop, ∀ i, (b i : ℝ) * n - (n / log n ^ 2) ≤ r i n := by\n  filter_upwards [R.dist_r_b'] with n hn\n  intro i\n  have h₁ : 0 ≤ b i := le_of_lt <| R.b_pos _\n  rw [sub_le_iff_le_add, add_comm, ← sub_le_iff_le_add]\n  calc (b i : ℝ) * n - r i n = ‖b i * n‖ - ‖(r i n : ℝ)‖ := by\n                            simp only [norm_mul, RCLike.norm_natCast, sub_left_inj,\n                                       Nat.cast_eq_zero, Real.norm_of_nonneg h₁]\n                         _ ≤ ‖(b i * n : ℝ) - r i n‖ := norm_sub_norm_le _ _\n                         _ = ‖(r i n : ℝ) - b i * n‖ := norm_sub_rev _ _\n                         _ ≤ n / log n ^ 2 := hn i\n\n"}
{"name":"AkraBazziRecurrence.eventually_r_le_b","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Eventually (fun n => ∀ (i : α), LE.le (↑(r i n)) (HAdd.hAdd (HMul.hMul (b i) ↑n) (HDiv.hDiv (↑n) (HPow.hPow (Real.log ↑n) 2)))) Filter.atTop","decl":"lemma eventually_r_le_b : ∀ᶠ (n : ℕ) in atTop, ∀ i, r i n ≤ (b i : ℝ) * n + (n / log n ^ 2) := by\n  filter_upwards [R.dist_r_b'] with n hn\n  intro i\n  calc r i n = b i * n + (r i n - b i * n) := by ring\n             _ ≤ b i * n + ‖r i n - b i * n‖ := by gcongr; exact Real.le_norm_self _\n             _ ≤ b i * n + n / log n ^ 2 := by gcongr; exact hn i\n\n"}
{"name":"AkraBazziRecurrence.eventually_r_lt_n","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Eventually (fun n => ∀ (i : α), LT.lt (r i n) n) Filter.atTop","decl":"lemma eventually_r_lt_n : ∀ᶠ (n : ℕ) in atTop, ∀ i, r i n < n := by\n  filter_upwards [eventually_ge_atTop R.n₀] with n hn\n  exact fun i => R.r_lt_n i n hn\n\n"}
{"name":"AkraBazziRecurrence.eventually_bi_mul_le_r","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Eventually (fun n => ∀ (i : α), LE.le (HMul.hMul (HDiv.hDiv (b (AkraBazziRecurrence.min_bi b)) 2) ↑n) ↑(r i n)) Filter.atTop","decl":"lemma eventually_bi_mul_le_r : ∀ᶠ (n : ℕ) in atTop, ∀ i, (b (min_bi b) / 2) * n ≤ r i n := by\n  have gt_zero : 0 < b (min_bi b) := R.b_pos (min_bi b)\n  have hlo := isLittleO_self_div_log_id\n  rw [Asymptotics.isLittleO_iff] at hlo\n  have hlo' := hlo (by positivity : 0 < b (min_bi b) / 2)\n  filter_upwards [hlo', R.eventually_b_le_r] with n hn hn'\n  intro i\n  simp only [Real.norm_of_nonneg (by positivity : 0 ≤ (n : ℝ))] at hn\n  calc b (min_bi b) / 2 * n = b (min_bi b) * n - b (min_bi b) / 2 * n := by ring\n                          _ ≤ b (min_bi b) * n - ‖n / log n ^ 2‖ := by gcongr\n                          _ ≤ b i * n - ‖n / log n ^ 2‖ := by gcongr; aesop\n                          _ = b i * n - n / log n ^ 2 := by\n                                congr\n                                exact Real.norm_of_nonneg <| by positivity\n                          _ ≤ r i n := hn' i\n\n"}
{"name":"AkraBazziRecurrence.bi_min_div_two_lt_one","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ LT.lt (HDiv.hDiv (b (AkraBazziRecurrence.min_bi b)) 2) 1","decl":"lemma bi_min_div_two_lt_one : b (min_bi b) / 2 < 1 := by\n  have gt_zero : 0 < b (min_bi b) := R.b_pos (min_bi b)\n  calc b (min_bi b) / 2 < b (min_bi b) := by aesop (add safe apply div_two_lt_of_pos)\n                      _ < 1 := R.b_lt_one _\n\n"}
{"name":"AkraBazziRecurrence.bi_min_div_two_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ LT.lt 0 (HDiv.hDiv (b (AkraBazziRecurrence.min_bi b)) 2)","decl":"lemma bi_min_div_two_pos : 0 < b (min_bi b) / 2 := div_pos (R.b_pos _) (by norm_num)\n\n"}
{"name":"AkraBazziRecurrence.exists_eventually_const_mul_le_r","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Exists fun c => And (Membership.mem (Set.Ioo 0 1) c) (Filter.Eventually (fun n => ∀ (i : α), LE.le (HMul.hMul c ↑n) ↑(r i n)) Filter.atTop)","decl":"lemma exists_eventually_const_mul_le_r :\n    ∃ c ∈ Set.Ioo (0 : ℝ) 1, ∀ᶠ (n : ℕ) in atTop, ∀ i, c * n ≤ r i n := by\n  have gt_zero : 0 < b (min_bi b) := R.b_pos (min_bi b)\n  exact ⟨b (min_bi b) / 2, ⟨⟨by positivity, R.bi_min_div_two_lt_one⟩, R.eventually_bi_mul_le_r⟩⟩\n\n"}
{"name":"AkraBazziRecurrence.eventually_r_ge","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\nC : Real\n⊢ Filter.Eventually (fun n => ∀ (i : α), LE.le C ↑(r i n)) Filter.atTop","decl":"lemma eventually_r_ge (C : ℝ) : ∀ᶠ (n : ℕ) in atTop, ∀ i, C ≤ r i n := by\n  obtain ⟨c, hc_mem, hc⟩ := R.exists_eventually_const_mul_le_r\n  filter_upwards [eventually_ge_atTop ⌈C / c⌉₊, hc] with n hn₁ hn₂\n  have h₁ := hc_mem.1\n  intro i\n  calc C = c * (C / c) := by\n            rw [← mul_div_assoc]\n            exact (mul_div_cancel_left₀ _ (by positivity)).symm\n       _ ≤ c * ⌈C / c⌉₊ := by gcongr; simp [Nat.le_ceil]\n       _ ≤ c * n := by gcongr\n       _ ≤ r i n := hn₂ i\n\n"}
{"name":"AkraBazziRecurrence.tendsto_atTop_r","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\ni : α\n⊢ Filter.Tendsto (r i) Filter.atTop Filter.atTop","decl":"lemma tendsto_atTop_r (i : α) : Tendsto (r i) atTop atTop := by\n  rw [tendsto_atTop]\n  intro b\n  have := R.eventually_r_ge b\n  rw [Filter.eventually_all] at this\n  exact_mod_cast this i\n\n"}
{"name":"AkraBazziRecurrence.tendsto_atTop_r_real","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\ni : α\n⊢ Filter.Tendsto (fun n => ↑(r i n)) Filter.atTop Filter.atTop","decl":"lemma tendsto_atTop_r_real (i : α) : Tendsto (fun n => (r i n : ℝ)) atTop atTop :=\n  Tendsto.comp tendsto_natCast_atTop_atTop (R.tendsto_atTop_r i)\n\n"}
{"name":"AkraBazziRecurrence.exists_eventually_r_le_const_mul","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Exists fun c => And (Membership.mem (Set.Ioo 0 1) c) (Filter.Eventually (fun n => ∀ (i : α), LE.le (↑(r i n)) (HMul.hMul c ↑n)) Filter.atTop)","decl":"lemma exists_eventually_r_le_const_mul :\n    ∃ c ∈ Set.Ioo (0 : ℝ) 1, ∀ᶠ (n : ℕ) in atTop, ∀ i, r i n ≤ c * n := by\n  let c := b (max_bi b) + (1 - b (max_bi b)) / 2\n  have h_max_bi_pos : 0 < b (max_bi b) := R.b_pos _\n  have h_max_bi_lt_one : 0 < 1 - b (max_bi b) := by\n    have : b (max_bi b) < 1 := R.b_lt_one _\n    linarith\n  have hc_pos : 0 < c := by positivity\n  have h₁ : 0 < (1 - b (max_bi b)) / 2 := by positivity\n  have hc_lt_one : c < 1 :=\n    calc b (max_bi b) + (1 - b (max_bi b)) / 2 = b (max_bi b) * (1 / 2) + 1 / 2 := by ring\n                                             _ < 1 * (1 / 2) + 1 / 2 := by\n                                                  gcongr\n                                                  exact R.b_lt_one _\n                                             _ = 1 := by norm_num\n  refine ⟨c, ⟨hc_pos, hc_lt_one⟩, ?_⟩\n  have hlo := isLittleO_self_div_log_id\n  rw [Asymptotics.isLittleO_iff] at hlo\n  have hlo' := hlo h₁\n  filter_upwards [hlo', R.eventually_r_le_b] with n hn hn'\n  intro i\n  rw [Real.norm_of_nonneg (by positivity)] at hn\n  simp only [Real.norm_of_nonneg (by positivity : 0 ≤ (n : ℝ))] at hn\n  calc r i n ≤ b i * n + n / log n ^ 2 := by exact hn' i\n             _ ≤ b i * n + (1 - b (max_bi b)) / 2 * n := by gcongr\n             _ = (b i + (1 - b (max_bi b)) / 2) * n := by ring\n             _ ≤ (b (max_bi b) + (1 - b (max_bi b)) / 2) * n := by gcongr; exact max_bi_le _\n\n"}
{"name":"AkraBazziRecurrence.eventually_r_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Eventually (fun n => ∀ (i : α), LT.lt 0 (r i n)) Filter.atTop","decl":"lemma eventually_r_pos : ∀ᶠ (n : ℕ) in atTop, ∀ i, 0 < r i n := by\n  rw [Filter.eventually_all]\n  exact fun i => (R.tendsto_atTop_r i).eventually_gt_atTop 0\n\n"}
{"name":"AkraBazziRecurrence.eventually_log_b_mul_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Eventually (fun n => ∀ (i : α), LT.lt 0 (Real.log (HMul.hMul (b i) ↑n))) Filter.atTop","decl":"lemma eventually_log_b_mul_pos : ∀ᶠ (n : ℕ) in atTop, ∀ i, 0 < log (b i * n) := by\n  rw [Filter.eventually_all]\n  intro i\n  have h : Tendsto (fun (n : ℕ) => log (b i * n)) atTop atTop :=\n    Tendsto.comp tendsto_log_atTop\n      <| Tendsto.const_mul_atTop (b_pos R i) tendsto_natCast_atTop_atTop\n  exact h.eventually_gt_atTop 0\n\n"}
{"name":"AkraBazziRecurrence.T_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\nn : Nat\n⊢ LT.lt 0 (T n)","decl":"@[aesop safe apply] lemma T_pos (n : ℕ) : 0 < T n := by\n  induction n using Nat.strongRecOn with\n  | ind n h_ind =>\n    cases lt_or_le n R.n₀ with\n    | inl hn => exact R.T_gt_zero' n hn -- n < R.n₀\n    | inr hn => -- R.n₀ ≤ n\n      rw [R.h_rec n hn]\n      have := R.g_nonneg\n      refine add_pos_of_pos_of_nonneg (Finset.sum_pos ?sum_elems univ_nonempty) (by aesop)\n      exact fun i _ => mul_pos (R.a_pos i) <| h_ind _ (R.r_lt_n i _ hn)\n\n"}
{"name":"AkraBazziRecurrence.T_nonneg","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\nn : Nat\n⊢ LE.le 0 (T n)","decl":"@[aesop safe apply]\nlemma T_nonneg (n : ℕ) : 0 ≤ T n := le_of_lt <| R.T_pos n\n\n"}
{"name":"AkraBazziRecurrence.one_add_smoothingFn_le_two","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"x : Real\nhx : LE.le (Real.exp 1) x\n⊢ LE.le (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn x)) 2","decl":"lemma one_add_smoothingFn_le_two {x : ℝ} (hx : exp 1 ≤ x) : 1 + ε x ≤ 2 := by\n  simp only [smoothingFn, ← one_add_one_eq_two]\n  gcongr\n  have : 1 < x := by\n    calc 1 = exp 0 := by simp\n         _ < exp 1 := by simp\n         _ ≤ x := hx\n  rw [div_le_one (log_pos this)]\n  calc 1 = log (exp 1) := by simp\n       _ ≤ log x := log_le_log (exp_pos _) hx\n\n"}
{"name":"AkraBazziRecurrence.isLittleO_smoothingFn_one","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Asymptotics.IsLittleO Filter.atTop AkraBazziRecurrence.smoothingFn fun x => 1","decl":"lemma isLittleO_smoothingFn_one : ε =o[atTop] (fun _ => (1 : ℝ)) := by\n  unfold smoothingFn\n  refine isLittleO_of_tendsto (fun _ h => False.elim <| one_ne_zero h) ?_\n  simp only [one_div, div_one]\n  exact Tendsto.inv_tendsto_atTop Real.tendsto_log_atTop\n\n"}
{"name":"AkraBazziRecurrence.isEquivalent_one_add_smoothingFn_one","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Asymptotics.IsEquivalent Filter.atTop (fun x => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn x)) fun x => 1","decl":"lemma isEquivalent_one_add_smoothingFn_one : (fun x => 1 + ε x) ~[atTop] (fun _ => (1 : ℝ)) :=\n  IsEquivalent.add_isLittleO IsEquivalent.refl isLittleO_smoothingFn_one\n\n"}
{"name":"AkraBazziRecurrence.isEquivalent_one_sub_smoothingFn_one","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Asymptotics.IsEquivalent Filter.atTop (fun x => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x)) fun x => 1","decl":"lemma isEquivalent_one_sub_smoothingFn_one : (fun x => 1 - ε x) ~[atTop] (fun _ => (1 : ℝ)) :=\n  IsEquivalent.sub_isLittleO IsEquivalent.refl isLittleO_smoothingFn_one\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ AkraBazziRecurrence.GrowsPolynomially fun x => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x)","decl":"lemma growsPolynomially_one_sub_smoothingFn : GrowsPolynomially fun x => 1 - ε x :=\n  GrowsPolynomially.of_isEquivalent_const isEquivalent_one_sub_smoothingFn_one\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ AkraBazziRecurrence.GrowsPolynomially fun x => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn x)","decl":"lemma growsPolynomially_one_add_smoothingFn : GrowsPolynomially fun x => 1 + ε x :=\n  GrowsPolynomially.of_isEquivalent_const isEquivalent_one_add_smoothingFn_one\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_sub_smoothingFn_gt_const_real","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"c : Real\nhc : LT.lt c 1\n⊢ Filter.Eventually (fun x => LT.lt c (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x))) Filter.atTop","decl":"lemma eventually_one_sub_smoothingFn_gt_const_real (c : ℝ) (hc : c < 1) :\n    ∀ᶠ (x : ℝ) in atTop, c < 1 - ε x := by\n  have h₁ : Tendsto (fun x => 1 - ε x) atTop (𝓝 1) := by\n    rw [← isEquivalent_const_iff_tendsto one_ne_zero]\n    exact isEquivalent_one_sub_smoothingFn_one\n  rw [tendsto_order] at h₁\n  exact h₁.1 c hc\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_sub_smoothingFn_gt_const","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"c : Real\nhc : LT.lt c 1\n⊢ Filter.Eventually (fun n => LT.lt c (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ↑n))) Filter.atTop","decl":"lemma eventually_one_sub_smoothingFn_gt_const (c : ℝ) (hc : c < 1) :\n    ∀ᶠ (n : ℕ) in atTop, c < 1 - ε n :=\n  Eventually.natCast_atTop (p := fun n => c < 1 - ε n)\n    <| eventually_one_sub_smoothingFn_gt_const_real c hc\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_sub_smoothingFn_pos_real","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Filter.Eventually (fun x => LT.lt 0 (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x))) Filter.atTop","decl":"lemma eventually_one_sub_smoothingFn_pos_real : ∀ᶠ (x : ℝ) in atTop, 0 < 1 - ε x :=\n  eventually_one_sub_smoothingFn_gt_const_real 0 zero_lt_one\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_sub_smoothingFn_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Filter.Eventually (fun n => LT.lt 0 (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ↑n))) Filter.atTop","decl":"lemma eventually_one_sub_smoothingFn_pos : ∀ᶠ (n : ℕ) in atTop, 0 < 1 - ε n :=\n  (eventually_one_sub_smoothingFn_pos_real).natCast_atTop\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_sub_smoothingFn_nonneg","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Filter.Eventually (fun n => LE.le 0 (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ↑n))) Filter.atTop","decl":"lemma eventually_one_sub_smoothingFn_nonneg : ∀ᶠ (n : ℕ) in atTop, 0 ≤ 1 - ε n := by\n  filter_upwards [eventually_one_sub_smoothingFn_pos] with n hn; exact le_of_lt hn\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_sub_smoothingFn_r_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Eventually (fun n => ∀ (i : α), LT.lt 0 (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ↑(r i n)))) Filter.atTop","decl":"include R in\nlemma eventually_one_sub_smoothingFn_r_pos : ∀ᶠ (n : ℕ) in atTop, ∀ i, 0 < 1 - ε (r i n) := by\n  rw [Filter.eventually_all]\n  exact fun i => (R.tendsto_atTop_r_real i).eventually eventually_one_sub_smoothingFn_pos_real\n\n"}
{"name":"AkraBazziRecurrence.differentiableAt_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"x : Real\nhx : LT.lt 1 x\n⊢ DifferentiableAt Real AkraBazziRecurrence.smoothingFn x","decl":"@[aesop safe apply]\nlemma differentiableAt_smoothingFn {x : ℝ} (hx : 1 < x) : DifferentiableAt ℝ ε x := by\n  have : log x ≠ 0 := Real.log_ne_zero_of_pos_of_ne_one (by positivity) (ne_of_gt hx)\n  show DifferentiableAt ℝ (fun z => 1 / log z) x\n  simp_rw [one_div]\n  exact DifferentiableAt.inv (differentiableAt_log (by positivity)) this\n\n"}
{"name":"AkraBazziRecurrence.differentiableAt_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"x : Real\nhx : LT.lt 1 x\n⊢ DifferentiableAt Real (fun z => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z)) x","decl":"@[aesop safe apply]\nlemma differentiableAt_one_sub_smoothingFn {x : ℝ} (hx : 1 < x) :\n    DifferentiableAt ℝ (fun z => 1 - ε z) x :=\n  DifferentiableAt.sub (differentiableAt_const _) <| differentiableAt_smoothingFn hx\n\n"}
{"name":"AkraBazziRecurrence.differentiableOn_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ DifferentiableOn Real (fun z => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z)) (Set.Ioi 1)","decl":"lemma differentiableOn_one_sub_smoothingFn : DifferentiableOn ℝ (fun z => 1 - ε z) (Set.Ioi 1) :=\n  fun _ hx => (differentiableAt_one_sub_smoothingFn hx).differentiableWithinAt\n\n"}
{"name":"AkraBazziRecurrence.differentiableAt_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"x : Real\nhx : LT.lt 1 x\n⊢ DifferentiableAt Real (fun z => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z)) x","decl":"@[aesop safe apply]\nlemma differentiableAt_one_add_smoothingFn {x : ℝ} (hx : 1 < x) :\n    DifferentiableAt ℝ (fun z => 1 + ε z) x :=\n  DifferentiableAt.add (differentiableAt_const _) <| differentiableAt_smoothingFn hx\n\n"}
{"name":"AkraBazziRecurrence.differentiableOn_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ DifferentiableOn Real (fun z => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z)) (Set.Ioi 1)","decl":"lemma differentiableOn_one_add_smoothingFn : DifferentiableOn ℝ (fun z => 1 + ε z) (Set.Ioi 1) :=\n  fun _ hx => (differentiableAt_one_add_smoothingFn hx).differentiableWithinAt\n\n"}
{"name":"AkraBazziRecurrence.deriv_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"x : Real\nhx : LT.lt 1 x\n⊢ Eq (deriv AkraBazziRecurrence.smoothingFn x) (HDiv.hDiv (Neg.neg (Inv.inv x)) (HPow.hPow (Real.log x) 2))","decl":"lemma deriv_smoothingFn {x : ℝ} (hx : 1 < x) : deriv ε x = -x⁻¹ / (log x ^ 2) := by\n  have : log x ≠ 0 := Real.log_ne_zero_of_pos_of_ne_one (by positivity) (ne_of_gt hx)\n  show deriv (fun z => 1 / log z) x = -x⁻¹ / (log x ^ 2)\n  rw [deriv_div] <;> aesop\n\n"}
{"name":"AkraBazziRecurrence.isLittleO_deriv_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Asymptotics.IsLittleO Filter.atTop (deriv AkraBazziRecurrence.smoothingFn) fun x => Inv.inv x","decl":"lemma isLittleO_deriv_smoothingFn : deriv ε =o[atTop] fun x => x⁻¹ := calc\n  deriv ε =ᶠ[atTop] fun x => -x⁻¹ / (log x ^ 2) := by\n            filter_upwards [eventually_gt_atTop 1] with x hx\n            rw [deriv_smoothingFn hx]\n    _ = fun x => (-x * log x ^ 2)⁻¹ := by\n            simp_rw [neg_div, div_eq_mul_inv, ← mul_inv, neg_inv, neg_mul]\n    _ =o[atTop] fun x => (x * 1)⁻¹ := by\n            refine IsLittleO.inv_rev ?_ ?_\n            · refine IsBigO.mul_isLittleO\n                (by rw [isBigO_neg_right]; aesop (add safe isBigO_refl)) ?_\n              rw [isLittleO_one_left_iff]\n              exact Tendsto.comp tendsto_norm_atTop_atTop\n                <| Tendsto.comp (tendsto_pow_atTop (by norm_num)) tendsto_log_atTop\n            · exact Filter.Eventually.of_forall (fun x hx => by rw [mul_one] at hx; simp [hx])\n    _ = fun x => x⁻¹ := by simp\n\n"}
{"name":"AkraBazziRecurrence.eventually_deriv_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Filter.atTop.EventuallyEq (deriv fun x => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x)) fun x => HDiv.hDiv (Inv.inv x) (HPow.hPow (Real.log x) 2)","decl":"lemma eventually_deriv_one_sub_smoothingFn :\n    deriv (fun x => 1 - ε x) =ᶠ[atTop] fun x => x⁻¹ / (log x ^ 2) := calc\n  deriv (fun x => 1 - ε x) =ᶠ[atTop] -(deriv ε) := by\n        filter_upwards [eventually_gt_atTop 1] with x hx; rw [deriv_sub] <;> aesop\n    _ =ᶠ[atTop] fun x => x⁻¹ / (log x ^ 2) := by\n        filter_upwards [eventually_gt_atTop 1] with x hx\n        simp [deriv_smoothingFn hx, neg_div]\n\n"}
{"name":"AkraBazziRecurrence.eventually_deriv_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Filter.atTop.EventuallyEq (deriv fun x => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn x)) fun x => HDiv.hDiv (Neg.neg (Inv.inv x)) (HPow.hPow (Real.log x) 2)","decl":"lemma eventually_deriv_one_add_smoothingFn :\n    deriv (fun x => 1 + ε x) =ᶠ[atTop] fun x => -x⁻¹ / (log x ^ 2) := calc\n  deriv (fun x => 1 + ε x) =ᶠ[atTop] deriv ε := by\n          filter_upwards [eventually_gt_atTop 1] with x hx; rw [deriv_add] <;> aesop\n    _ =ᶠ[atTop] fun x => -x⁻¹ / (log x ^ 2) := by\n          filter_upwards [eventually_gt_atTop 1] with x hx\n          simp [deriv_smoothingFn hx]\n\n"}
{"name":"AkraBazziRecurrence.isLittleO_deriv_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Asymptotics.IsLittleO Filter.atTop (deriv fun x => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x)) fun x => Inv.inv x","decl":"lemma isLittleO_deriv_one_sub_smoothingFn :\n    deriv (fun x => 1 - ε x) =o[atTop] fun (x : ℝ) => x⁻¹ := calc\n  deriv (fun x => 1 - ε x) =ᶠ[atTop] fun z => -(deriv ε z) := by\n          filter_upwards [eventually_gt_atTop 1] with x hx; rw [deriv_sub] <;> aesop\n    _ =o[atTop] fun x => x⁻¹ := by rw [isLittleO_neg_left]; exact isLittleO_deriv_smoothingFn\n\n"}
{"name":"AkraBazziRecurrence.isLittleO_deriv_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Asymptotics.IsLittleO Filter.atTop (deriv fun x => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn x)) fun x => Inv.inv x","decl":"lemma isLittleO_deriv_one_add_smoothingFn :\n    deriv (fun x => 1 + ε x) =o[atTop] fun (x : ℝ) => x⁻¹ := calc\n  deriv (fun x => 1 + ε x) =ᶠ[atTop] fun z => deriv ε z := by\n          filter_upwards [eventually_gt_atTop 1] with x hx; rw [deriv_add] <;> aesop\n    _ =o[atTop] fun x => x⁻¹ := isLittleO_deriv_smoothingFn\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_add_smoothingFn_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Filter.Eventually (fun n => LT.lt 0 (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn ↑n))) Filter.atTop","decl":"lemma eventually_one_add_smoothingFn_pos : ∀ᶠ (n : ℕ) in atTop, 0 < 1 + ε n := by\n  have h₁ := isLittleO_smoothingFn_one\n  rw [isLittleO_iff] at h₁\n  refine Eventually.natCast_atTop (p := fun n => 0 < 1 + ε n) ?_\n  filter_upwards [h₁ (by norm_num : (0 : ℝ) < 1/2), eventually_gt_atTop 1] with x _ hx'\n  have : 0 < log x := Real.log_pos hx'\n  show 0 < 1 + 1 / log x\n  positivity\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_add_smoothingFn_r_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Eventually (fun n => ∀ (i : α), LT.lt 0 (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn ↑(r i n)))) Filter.atTop","decl":"include R in\nlemma eventually_one_add_smoothingFn_r_pos : ∀ᶠ (n : ℕ) in atTop, ∀ i, 0 < 1 + ε (r i n) := by\n  rw [Filter.eventually_all]\n  exact fun i => (R.tendsto_atTop_r i).eventually (f := r i) eventually_one_add_smoothingFn_pos\n\n"}
{"name":"AkraBazziRecurrence.eventually_one_add_smoothingFn_nonneg","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ Filter.Eventually (fun n => LE.le 0 (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn ↑n))) Filter.atTop","decl":"lemma eventually_one_add_smoothingFn_nonneg : ∀ᶠ (n : ℕ) in atTop, 0 ≤ 1 + ε n := by\n  filter_upwards [eventually_one_add_smoothingFn_pos] with n hn; exact le_of_lt hn\n\n"}
{"name":"AkraBazziRecurrence.strictAntiOn_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ StrictAntiOn AkraBazziRecurrence.smoothingFn (Set.Ioi 1)","decl":"lemma strictAntiOn_smoothingFn : StrictAntiOn ε (Set.Ioi 1) := by\n  show StrictAntiOn (fun x => 1 / log x) (Set.Ioi 1)\n  simp_rw [one_div]\n  refine StrictAntiOn.comp_strictMonoOn inv_strictAntiOn ?log fun _ hx => log_pos hx\n  refine StrictMonoOn.mono strictMonoOn_log (fun x hx => ?_)\n  exact Set.Ioi_subset_Ioi zero_le_one hx\n\n"}
{"name":"AkraBazziRecurrence.strictMonoOn_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ StrictMonoOn (fun x => HSub.hSub 1 (AkraBazziRecurrence.smoothingFn x)) (Set.Ioi 1)","decl":"lemma strictMonoOn_one_sub_smoothingFn :\n    StrictMonoOn (fun (x : ℝ) => (1 : ℝ) - ε x) (Set.Ioi 1) := by\n  simp_rw [sub_eq_add_neg]\n  exact StrictMonoOn.const_add (StrictAntiOn.neg <| strictAntiOn_smoothingFn) 1\n\n"}
{"name":"AkraBazziRecurrence.strictAntiOn_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"⊢ StrictAntiOn (fun x => HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn x)) (Set.Ioi 1)","decl":"lemma strictAntiOn_one_add_smoothingFn : StrictAntiOn (fun (x : ℝ) => (1 : ℝ) + ε x) (Set.Ioi 1) :=\n  StrictAntiOn.const_add strictAntiOn_smoothingFn 1\n\n"}
{"name":"AkraBazziRecurrence.isEquivalent_smoothingFn_sub_self","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\ni : α\n⊢ Asymptotics.IsEquivalent Filter.atTop (fun n => HSub.hSub (AkraBazziRecurrence.smoothingFn (HMul.hMul (b i) ↑n)) (AkraBazziRecurrence.smoothingFn ↑n)) fun n => HDiv.hDiv (Neg.neg (Real.log (b i))) (HPow.hPow (Real.log ↑n) 2)","decl":"lemma isEquivalent_smoothingFn_sub_self (i : α) :\n    (fun (n : ℕ) => ε (b i * n) - ε n) ~[atTop] fun n => -log (b i) / (log n)^2 := by\n  calc (fun (n : ℕ) => 1 / log (b i * n) - 1 / log n)\n        =ᶠ[atTop] fun (n : ℕ) => (log n - log (b i * n)) / (log (b i * n) * log n) := by\n            filter_upwards [eventually_gt_atTop 1, R.eventually_log_b_mul_pos] with n hn hn'\n            have h_log_pos : 0 < log n := Real.log_pos <| by aesop\n            simp only [one_div]\n            rw [inv_sub_inv (by have := hn' i; positivity) (by aesop)]\n      _ =ᶠ[atTop] (fun (n : ℕ) ↦ (log n - log (b i) - log n) / ((log (b i) + log n) * log n)) := by\n            filter_upwards [eventually_ne_atTop 0] with n hn\n            have : 0 < b i := R.b_pos i\n            rw [log_mul (by positivity) (by aesop), sub_add_eq_sub_sub]\n      _ = (fun (n : ℕ) => -log (b i) / ((log (b i) + log n) * log n)) := by ext; congr; ring\n      _ ~[atTop] (fun (n : ℕ) => -log (b i) / (log n * log n)) := by\n            refine IsEquivalent.div (IsEquivalent.refl) <| IsEquivalent.mul ?_ (IsEquivalent.refl)\n            have : (fun (n : ℕ) => log (b i) + log n) = fun (n : ℕ) => log n + log (b i) := by\n              ext; simp [add_comm]\n            rw [this]\n            exact IsEquivalent.add_isLittleO IsEquivalent.refl\n              <| IsLittleO.natCast_atTop (f := fun (_ : ℝ) => log (b i))\n                isLittleO_const_log_atTop\n      _ = (fun (n : ℕ) => -log (b i) / (log n)^2) := by ext; congr 1; rw [← pow_two]\n\n"}
{"name":"AkraBazziRecurrence.isTheta_smoothingFn_sub_self","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\ni : α\n⊢ Asymptotics.IsTheta Filter.atTop (fun n => HSub.hSub (AkraBazziRecurrence.smoothingFn (HMul.hMul (b i) ↑n)) (AkraBazziRecurrence.smoothingFn ↑n)) fun n => HDiv.hDiv 1 (HPow.hPow (Real.log ↑n) 2)","decl":"lemma isTheta_smoothingFn_sub_self (i : α) :\n    (fun (n : ℕ) => ε (b i * n) - ε n) =Θ[atTop] fun n => 1 / (log n)^2 := by\n  calc (fun (n : ℕ) => ε (b i * n) - ε n) =Θ[atTop] fun n => (-log (b i)) / (log n)^2 := by\n                  exact (R.isEquivalent_smoothingFn_sub_self i).isTheta\n    _ = fun (n : ℕ) => (-log (b i)) * 1 / (log n)^2 := by simp only [mul_one]\n    _ = fun (n : ℕ) => -log (b i) * (1 / (log n)^2) := by simp_rw [← mul_div_assoc]\n    _ =Θ[atTop] fun (n : ℕ) => 1 / (log n)^2 := by\n                  have : -log (b i) ≠ 0 := by\n                    rw [neg_ne_zero]\n                    exact Real.log_ne_zero_of_pos_of_ne_one\n                            (R.b_pos i) (ne_of_lt <| R.b_lt_one i)\n                  rw [← isTheta_const_mul_right this]\n\n\n"}
{"name":"AkraBazziRecurrence.continuous_sumCoeffsExp","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Continuous fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)","decl":"@[continuity]\nlemma continuous_sumCoeffsExp : Continuous (fun (p : ℝ) => ∑ i, a i * (b i) ^ p) := by\n  refine continuous_finset_sum Finset.univ fun i _ => Continuous.mul (by continuity) ?_\n  exact Continuous.rpow continuous_const continuous_id (fun x => Or.inl (ne_of_gt (R.b_pos i)))\n\n"}
{"name":"AkraBazziRecurrence.strictAnti_sumCoeffsExp","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ StrictAnti fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)","decl":"lemma strictAnti_sumCoeffsExp : StrictAnti (fun (p : ℝ) => ∑ i, a i * (b i) ^ p) := by\n  rw [← Finset.sum_fn]\n  refine Finset.sum_induction_nonempty _ _ (fun _ _ => StrictAnti.add) univ_nonempty ?terms\n  refine fun i _ => StrictAnti.const_mul ?_ (R.a_pos i)\n  exact Real.strictAnti_rpow_of_base_lt_one (R.b_pos i) (R.b_lt_one i)\n\n"}
{"name":"AkraBazziRecurrence.tendsto_zero_sumCoeffsExp","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Tendsto (fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)) Filter.atTop (nhds 0)","decl":"lemma tendsto_zero_sumCoeffsExp : Tendsto (fun (p : ℝ) => ∑ i, a i * (b i) ^ p) atTop (𝓝 0) := by\n  have h₁ : Finset.univ.sum (fun _ : α => (0 : ℝ)) = 0 := by simp\n  rw [← h₁]\n  refine tendsto_finset_sum (univ : Finset α) (fun i _ => ?_)\n  rw [← mul_zero (a i)]\n  refine Tendsto.mul (by simp) <| tendsto_rpow_atTop_of_base_lt_one _ ?_ (R.b_lt_one i)\n  have := R.b_pos i\n  linarith\n\n"}
{"name":"AkraBazziRecurrence.tendsto_atTop_sumCoeffsExp","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Tendsto (fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)) Filter.atBot Filter.atTop","decl":"lemma tendsto_atTop_sumCoeffsExp : Tendsto (fun (p : ℝ) => ∑ i, a i * (b i) ^ p) atBot atTop := by\n  have h₁ : Tendsto (fun p : ℝ => (a (max_bi b) : ℝ) * b (max_bi b) ^ p) atBot atTop :=\n    Tendsto.mul_atTop (R.a_pos (max_bi b)) (by simp)\n      <| tendsto_rpow_atBot_of_base_lt_one _\n      (by have := R.b_pos (max_bi b); linarith) (R.b_lt_one _)\n  refine tendsto_atTop_mono (fun p => ?_) h₁\n  refine Finset.single_le_sum (f := fun i => (a i : ℝ) * b i ^ p) (fun i _ => ?_) (mem_univ _)\n  have h₁ : 0 < a i := R.a_pos i\n  have h₂ : 0 < b i := R.b_pos i\n  positivity\n\n"}
{"name":"AkraBazziRecurrence.one_mem_range_sumCoeffsExp","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Membership.mem (Set.range fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)) 1","decl":"lemma one_mem_range_sumCoeffsExp : 1 ∈ Set.range (fun (p : ℝ) => ∑ i, a i * (b i) ^ p) := by\n  refine mem_range_of_exists_le_of_exists_ge R.continuous_sumCoeffsExp ?le_one ?ge_one\n  case le_one =>\n    exact R.tendsto_zero_sumCoeffsExp.eventually_le_const zero_lt_one |>.exists\n  case ge_one =>\n    exact R.tendsto_atTop_sumCoeffsExp.eventually_ge_atTop _ |>.exists\n\n"}
{"name":"AkraBazziRecurrence.injective_sumCoeffsExp","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Function.Injective fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)","decl":"/-- The function x ↦ ∑ a_i b_i^x is injective. This implies the uniqueness of `p`. -/\nlemma injective_sumCoeffsExp : Function.Injective (fun (p : ℝ) => ∑ i, a i * (b i) ^ p) :=\n    R.strictAnti_sumCoeffsExp.injective\n\n"}
{"name":"AkraBazziRecurrence.p_def","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_2\ninst✝ : Fintype α\na b : α → Real\n⊢ Eq (AkraBazziRecurrence.p a b) (Function.invFun (fun p => Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) p)) 1)","decl":"variable (a b) in\n/-- The exponent `p` associated with a particular Akra-Bazzi recurrence. -/\nnoncomputable irreducible_def p : ℝ := Function.invFun (fun (p : ℝ) => ∑ i, a i * (b i) ^ p) 1\n\n"}
{"name":"AkraBazziRecurrence.sumCoeffsExp_p_eq_one","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Eq (Finset.univ.sum fun i => HMul.hMul (a i) (HPow.hPow (b i) (AkraBazziRecurrence.p a b))) 1","decl":"include R in\n@[simp]\nlemma sumCoeffsExp_p_eq_one : ∑ i, a i * (b i) ^ p a b = 1 := by\n  simp only [p]\n  exact Function.invFun_eq (by rw [← Set.mem_range]; exact R.one_mem_range_sumCoeffsExp)\n\n"}
{"name":"AkraBazziRecurrence.sumTransform_def","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\ng : Real → Real\nn₀ n : Nat\n⊢ Eq (AkraBazziRecurrence.sumTransform p g n₀ n) (HMul.hMul (HPow.hPow (↑n) p) ((Finset.Ico n₀ n).sum fun u => HDiv.hDiv (g ↑u) (HPow.hPow (↑u) (HAdd.hAdd p 1))))","decl":"lemma sumTransform_def {p : ℝ} {g : ℝ → ℝ} {n₀ n : ℕ} :\n    sumTransform p g n₀ n = n^p * ∑ u ∈ Finset.Ico n₀ n, g u / u^(p + 1) := rfl\n\n\n"}
{"name":"AkraBazziRecurrence.asympBound_def","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"g : Real → Real\nα : Type u_2\ninst✝ : Fintype α\na b : α → Real\nn : Nat\n⊢ Eq (AkraBazziRecurrence.asympBound g a b n) (HAdd.hAdd (HPow.hPow (↑n) (AkraBazziRecurrence.p a b)) (AkraBazziRecurrence.sumTransform (AkraBazziRecurrence.p a b) g 0 n))","decl":"lemma asympBound_def {α} [Fintype α] (a b : α → ℝ) {n : ℕ} :\n    asympBound g a b n = n ^ p a b + sumTransform (p a b) g 0 n := rfl\n\n"}
{"name":"AkraBazziRecurrence.asympBound_def'","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"g : Real → Real\nα : Type u_2\ninst✝ : Fintype α\na b : α → Real\nn : Nat\n⊢ Eq (AkraBazziRecurrence.asympBound g a b n) (HMul.hMul (HPow.hPow (↑n) (AkraBazziRecurrence.p a b)) (HAdd.hAdd 1 ((Finset.range n).sum fun u => HDiv.hDiv (g ↑u) (HPow.hPow (↑u) (HAdd.hAdd (AkraBazziRecurrence.p a b) 1)))))","decl":"lemma asympBound_def' {α} [Fintype α] (a b : α → ℝ) {n : ℕ} :\n    asympBound g a b n = n ^ p a b * (1 + (∑ u ∈ range n, g u / u ^ (p a b + 1))) := by\n  simp [asympBound_def, sumTransform, mul_add, mul_one, Finset.sum_Ico_eq_sum_range]\n\n"}
{"name":"AkraBazziRecurrence.asympBound_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\nn : Nat\nhn : LT.lt 0 n\n⊢ LT.lt 0 (AkraBazziRecurrence.asympBound g a b n)","decl":"lemma asympBound_pos (n : ℕ) (hn : 0 < n) : 0 < asympBound g a b n := by\n  calc 0 < (n : ℝ) ^ p a b * (1 + 0) := by aesop (add safe Real.rpow_pos_of_pos)\n       _ ≤ asympBound g a b n := by\n                    simp only [asympBound_def']\n                    gcongr n^p a b * (1 + ?_)\n                    have := R.g_nonneg\n                    aesop (add safe Real.rpow_nonneg,\n                               safe div_nonneg,\n                               safe Finset.sum_nonneg)\n\n"}
{"name":"AkraBazziRecurrence.eventually_asympBound_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Eventually (fun n => LT.lt 0 (AkraBazziRecurrence.asympBound g a b n)) Filter.atTop","decl":"lemma eventually_asympBound_pos : ∀ᶠ (n : ℕ) in atTop, 0 < asympBound g a b n := by\n  filter_upwards [eventually_gt_atTop 0] with n hn\n  exact R.asympBound_pos n hn\n\n"}
{"name":"AkraBazziRecurrence.eventually_asympBound_r_pos","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Eventually (fun n => ∀ (i : α), LT.lt 0 (AkraBazziRecurrence.asympBound g a b (r i n))) Filter.atTop","decl":"lemma eventually_asympBound_r_pos : ∀ᶠ (n : ℕ) in atTop, ∀ i, 0 < asympBound g a b (r i n) := by\n  rw [Filter.eventually_all]\n  exact fun i => (R.tendsto_atTop_r i).eventually R.eventually_asympBound_pos\n\n"}
{"name":"AkraBazziRecurrence.eventually_atTop_sumTransform_le","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Exists fun c => And (GT.gt c 0) (Filter.Eventually (fun n => ∀ (i : α), LE.le (AkraBazziRecurrence.sumTransform (AkraBazziRecurrence.p a b) g (r i n) n) (HMul.hMul c (g ↑n))) Filter.atTop)","decl":"lemma eventually_atTop_sumTransform_le :\n    ∃ c > 0, ∀ᶠ (n : ℕ) in atTop, ∀ i, sumTransform (p a b) g (r i n) n ≤ c * g n := by\n  obtain ⟨c₁, hc₁_mem, hc₁⟩ := R.exists_eventually_const_mul_le_r\n  obtain ⟨c₂, hc₂_mem, hc₂⟩ := R.g_grows_poly.eventually_atTop_le_nat hc₁_mem\n  have hc₁_pos : 0 < c₁ := hc₁_mem.1\n  refine ⟨max c₂ (c₂ / c₁ ^ (p a b + 1)), by positivity, ?_⟩\n  filter_upwards [hc₁, hc₂, R.eventually_r_pos, R.eventually_r_lt_n, eventually_gt_atTop 0]\n    with n hn₁ hn₂ hrpos hr_lt_n hn_pos\n  intro i\n  have hrpos_i := hrpos i\n  have g_nonneg : 0 ≤ g n := R.g_nonneg n (by positivity)\n  cases le_or_lt 0 (p a b + 1) with\n  | inl hp => -- 0 ≤ p a b + 1\n    calc sumTransform (p a b) g (r i n) n\n           = n ^ (p a b) * (∑ u ∈ Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1)) := by rfl\n         _ ≤ n ^ (p a b) * (∑ u ∈ Finset.Ico (r i n) n, c₂ * g n / u ^ ((p a b) + 1)) := by\n                gcongr with u hu\n                rw [Finset.mem_Ico] at hu\n                have hu' : u ∈ Set.Icc (r i n) n := ⟨hu.1, by omega⟩\n                refine hn₂ u ?_\n                rw [Set.mem_Icc]\n                refine ⟨?_, by norm_cast; omega⟩\n                calc c₁ * n ≤ r i n := by exact hn₁ i\n                          _ ≤ u := by exact_mod_cast hu'.1\n         _ ≤ n ^ (p a b) * (∑ _u ∈ Finset.Ico (r i n) n, c₂ * g n / (r i n) ^ ((p a b) + 1)) := by\n                  gcongr with u hu; rw [Finset.mem_Ico] at hu; exact hu.1\n         _ ≤ n ^ p a b * #(Ico (r i n) n) • (c₂ * g n / r i n ^ (p a b + 1)) := by\n                  gcongr; exact Finset.sum_le_card_nsmul _ _ _ (fun x _ => by rfl)\n         _ = n ^ p a b * #(Ico (r i n) n) * (c₂ * g n / r i n ^ (p a b + 1)) := by\n                  rw [nsmul_eq_mul, mul_assoc]\n         _ = n ^ (p a b) * (n - r i n) * (c₂ * g n / (r i n) ^ ((p a b) + 1)) := by\n                  congr; rw [Nat.card_Ico, Nat.cast_sub (le_of_lt <| hr_lt_n i)]\n         _ ≤ n ^ (p a b) * n * (c₂ * g n / (r i n) ^ ((p a b) + 1)) := by\n                  gcongr; simp only [tsub_le_iff_right, le_add_iff_nonneg_right, Nat.cast_nonneg]\n         _ ≤ n ^ (p a b) * n * (c₂ * g n / (c₁ * n) ^ ((p a b) + 1)) := by\n                gcongr; exact hn₁ i\n         _ = c₂ * g n * n ^ ((p a b) + 1) / (c₁ * n) ^ ((p a b) + 1) := by\n                rw [← Real.rpow_add_one (by positivity) (p a b)]; ring\n         _ = c₂ * g n * n ^ ((p a b) + 1) / (n ^ ((p a b) + 1) * c₁ ^ ((p a b) + 1)) := by\n                rw [mul_comm c₁, Real.mul_rpow (by positivity) (by positivity)]\n         _ = c₂ * g n * (n ^ ((p a b) + 1) / (n ^ ((p a b) + 1))) / c₁ ^ ((p a b) + 1) := by ring\n         _ = c₂ * g n / c₁ ^ ((p a b) + 1) := by rw [div_self (by positivity), mul_one]\n         _ = (c₂ / c₁ ^ ((p a b) + 1)) * g n := by ring\n         _ ≤ max c₂ (c₂ / c₁ ^ ((p a b) + 1)) * g n := by gcongr; exact le_max_right _ _\n  | inr hp => -- p a b + 1 < 0\n    calc sumTransform (p a b) g (r i n) n\n           = n ^ (p a b) * (∑ u ∈ Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1)) := by rfl\n         _ ≤ n ^ (p a b) * (∑ u ∈ Finset.Ico (r i n) n, c₂ * g n / u ^ ((p a b) + 1)) := by\n                gcongr with u hu\n                rw [Finset.mem_Ico] at hu\n                have hu' : u ∈ Set.Icc (r i n) n := ⟨hu.1, by omega⟩\n                refine hn₂ u ?_\n                rw [Set.mem_Icc]\n                refine ⟨?_, by norm_cast; omega⟩\n                calc c₁ * n ≤ r i n := by exact hn₁ i\n                          _ ≤ u     := by exact_mod_cast hu'.1\n         _ ≤ n ^ (p a b) * (∑ _u ∈ Finset.Ico (r i n) n, c₂ * g n / n ^ ((p a b) + 1)) := by\n                gcongr n ^ (p a b) * (Finset.Ico (r i n) n).sum (fun _ => c₂ * g n / ?_) with u hu\n                rw [Finset.mem_Ico] at hu\n                have : 0 < u := calc\n                  0 < r i n := by exact hrpos_i\n                  _ ≤ u := by exact hu.1\n                exact rpow_le_rpow_of_exponent_nonpos (by positivity)\n                  (by exact_mod_cast (le_of_lt hu.2)) (le_of_lt hp)\n         _ ≤ n ^ p a b * #(Ico (r i n) n) • (c₂ * g n / n ^ (p a b + 1)) := by\n                  gcongr; exact Finset.sum_le_card_nsmul _ _ _ (fun x _ => by rfl)\n         _ = n ^ p a b * #(Ico (r i n) n) * (c₂ * g n / n ^ (p a b + 1)) := by\n                  rw [nsmul_eq_mul, mul_assoc]\n         _ = n ^ (p a b) * (n - r i n) * (c₂ * g n / n ^ ((p a b) + 1)) := by\n                  congr; rw [Nat.card_Ico, Nat.cast_sub (le_of_lt <| hr_lt_n i)]\n         _ ≤ n ^ (p a b) * n * (c₂ * g n / n ^ ((p a b) + 1)) := by\n                gcongr; simp only [tsub_le_iff_right, le_add_iff_nonneg_right, Nat.cast_nonneg]\n         _ = c₂ * (n^((p a b) + 1) / n ^ ((p a b) + 1)) * g n := by\n                rw [← Real.rpow_add_one (by positivity) (p a b)]; ring\n         _ = c₂ * g n := by rw [div_self (by positivity), mul_one]\n         _ ≤ max c₂ (c₂ / c₁ ^ ((p a b) + 1)) * g n := by gcongr; exact le_max_left _ _\n\n"}
{"name":"AkraBazziRecurrence.eventually_atTop_sumTransform_ge","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Exists fun c => And (GT.gt c 0) (Filter.Eventually (fun n => ∀ (i : α), LE.le (HMul.hMul c (g ↑n)) (AkraBazziRecurrence.sumTransform (AkraBazziRecurrence.p a b) g (r i n) n)) Filter.atTop)","decl":"lemma eventually_atTop_sumTransform_ge :\n    ∃ c > 0, ∀ᶠ (n : ℕ) in atTop, ∀ i, c * g n ≤ sumTransform (p a b) g (r i n) n := by\n  obtain ⟨c₁, hc₁_mem, hc₁⟩ := R.exists_eventually_const_mul_le_r\n  obtain ⟨c₂, hc₂_mem, hc₂⟩ := R.g_grows_poly.eventually_atTop_ge_nat hc₁_mem\n  obtain ⟨c₃, hc₃_mem, hc₃⟩ := R.exists_eventually_r_le_const_mul\n  have hc₁_pos : 0 < c₁ := hc₁_mem.1\n  have hc₃' : 0 < (1 - c₃) := by have := hc₃_mem.2; linarith\n  refine ⟨min (c₂ * (1 - c₃)) ((1 - c₃) * c₂ / c₁^((p a b) + 1)), by positivity, ?_⟩\n  filter_upwards [hc₁, hc₂, hc₃, R.eventually_r_pos, R.eventually_r_lt_n, eventually_gt_atTop 0]\n    with n hn₁ hn₂ hn₃ hrpos hr_lt_n hn_pos\n  intro i\n  have hrpos_i := hrpos i\n  have g_nonneg : 0 ≤ g n := R.g_nonneg n (by positivity)\n  cases le_or_gt 0 (p a b + 1) with\n  | inl hp => -- 0 ≤ (p a b) + 1\n    calc sumTransform (p a b) g (r i n) n\n           = n ^ (p a b) * (∑ u ∈ Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))    := rfl\n         _ ≥ n ^ (p a b) * (∑ u ∈ Finset.Ico (r i n) n, c₂ * g n / u^((p a b) + 1)) := by\n                gcongr with u hu\n                rw [Finset.mem_Ico] at hu\n                have hu' : u ∈ Set.Icc (r i n) n := ⟨hu.1, by omega⟩\n                refine hn₂ u ?_\n                rw [Set.mem_Icc]\n                refine ⟨?_, by norm_cast; omega⟩\n                calc c₁ * n ≤ r i n := by exact hn₁ i\n                          _ ≤ u     := by exact_mod_cast hu'.1\n         _ ≥ n ^ (p a b) * (∑ _u ∈ Finset.Ico (r i n) n, c₂ * g n / n ^ ((p a b) + 1)) := by\n                gcongr with u hu\n                · rw [Finset.mem_Ico] at hu\n                  have := calc 0 < r i n := hrpos_i\n                              _ ≤ u := hu.1\n                  positivity\n                · rw [Finset.mem_Ico] at hu\n                  exact le_of_lt hu.2\n         _ ≥ n ^ p a b * #(Ico (r i n) n) • (c₂ * g n / n ^ (p a b + 1)) := by\n                gcongr; exact Finset.card_nsmul_le_sum _ _ _ (fun x _ => by rfl)\n         _ = n ^ p a b * #(Ico (r i n) n) * (c₂ * g n / n ^ (p a b + 1)) := by\n                rw [nsmul_eq_mul, mul_assoc]\n         _ = n ^ (p a b) * (n - r i n) * (c₂ * g n / n ^ ((p a b) + 1)) := by\n                congr; rw [Nat.card_Ico, Nat.cast_sub (le_of_lt <| hr_lt_n i)]\n         _ ≥ n ^ (p a b) * (n - c₃ * n) * (c₂ * g n / n ^ ((p a b) + 1)) := by\n                gcongr; exact hn₃ i\n         _ = n ^ (p a b) * n * (1 - c₃) * (c₂ * g n / n ^ ((p a b) + 1)) := by ring\n         _ = c₂ * (1 - c₃) * g n * (n ^ ((p a b) + 1) / n ^ ((p a b) + 1)) := by\n                rw [← Real.rpow_add_one (by positivity) (p a b)]; ring\n         _ = c₂ * (1 - c₃) * g n := by rw [div_self (by positivity), mul_one]\n         _ ≥ min (c₂ * (1 - c₃)) ((1 - c₃) * c₂ / c₁ ^ ((p a b) + 1)) * g n := by\n                gcongr; exact min_le_left _ _\n  | inr hp => -- (p a b) + 1 < 0\n    calc sumTransform (p a b) g (r i n) n\n        = n ^ (p a b) * (∑ u ∈ Finset.Ico (r i n) n, g u / u^((p a b) + 1))        := by rfl\n      _ ≥ n ^ (p a b) * (∑ u ∈ Finset.Ico (r i n) n, c₂ * g n / u ^ ((p a b) + 1)) := by\n             gcongr with u hu\n             rw [Finset.mem_Ico] at hu\n             have hu' : u ∈ Set.Icc (r i n) n := ⟨hu.1, by omega⟩\n             refine hn₂ u ?_\n             rw [Set.mem_Icc]\n             refine ⟨?_, by norm_cast; omega⟩\n             calc c₁ * n ≤ r i n := by exact hn₁ i\n                       _ ≤ u := by exact_mod_cast hu'.1\n      _ ≥ n ^ (p a b) * (∑ _u ∈ Finset.Ico (r i n) n, c₂ * g n / (r i n) ^ ((p a b) + 1)) := by\n             gcongr n^(p a b) * (Finset.Ico (r i n) n).sum (fun _ => c₂ * g n / ?_) with u hu\n             · rw [Finset.mem_Ico] at hu\n               have := calc 0 < r i n := hrpos_i\n                           _ ≤ u := hu.1\n               positivity\n             · rw [Finset.mem_Ico] at hu\n               exact rpow_le_rpow_of_exponent_nonpos (by positivity)\n                 (by exact_mod_cast hu.1) (le_of_lt hp)\n      _ ≥ n ^ p a b * #(Ico (r i n) n) • (c₂ * g n / r i n ^ (p a b + 1)) := by\n             gcongr; exact Finset.card_nsmul_le_sum _ _ _ (fun x _ => by rfl)\n      _ = n ^ p a b * #(Ico (r i n) n) * (c₂ * g n / r i n ^ (p a b + 1)) := by\n             rw [nsmul_eq_mul, mul_assoc]\n      _ ≥ n ^ p a b * #(Ico (r i n) n) * (c₂ * g n / (c₁ * n) ^ (p a b + 1)) := by\n             gcongr n ^ p a b * #(Ico (r i n) n) * (c₂ * g n / ?_)\n             exact rpow_le_rpow_of_exponent_nonpos (by positivity) (hn₁ i) (le_of_lt hp)\n      _ = n ^ (p a b) * (n - r i n) * (c₂ * g n / (c₁ * n) ^ ((p a b) + 1)) := by\n             congr; rw [Nat.card_Ico, Nat.cast_sub (le_of_lt <| hr_lt_n i)]\n      _ ≥ n ^ (p a b) * (n - c₃ * n) * (c₂ * g n / (c₁ * n) ^ ((p a b) + 1)) := by\n             gcongr; exact hn₃ i\n      _ = n ^ (p a b) * n * (1 - c₃) * (c₂ * g n / (c₁ * n) ^ ((p a b) + 1)) := by ring\n      _ = n ^ (p a b) * n * (1 - c₃) * (c₂ * g n / (c₁ ^ ((p a b) + 1) * n ^ ((p a b) + 1))) := by\n             rw [Real.mul_rpow (by positivity) (by positivity)]\n      _ = (n ^ ((p a b) + 1) / n ^ ((p a b) + 1)) * (1 - c₃) * c₂ * g n / c₁ ^ ((p a b) + 1) := by\n             rw [← Real.rpow_add_one (by positivity) (p a b)]; ring\n      _ = (1 - c₃) * c₂ / c₁ ^ ((p a b) + 1) * g n := by\n             rw [div_self (by positivity), one_mul]; ring\n      _ ≥ min (c₂ * (1 - c₃)) ((1 - c₃) * c₂ / c₁ ^ ((p a b) + 1)) * g n := by\n             gcongr; exact min_le_right _ _\n\n"}
{"name":"AkraBazziRecurrence.eventually_deriv_rpow_p_mul_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\n⊢ Filter.atTop.EventuallyEq (deriv fun z => HMul.hMul (HPow.hPow z p) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z))) fun z => HAdd.hAdd (HMul.hMul (HMul.hMul p (HPow.hPow z (HSub.hSub p 1))) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z))) (HDiv.hDiv (HPow.hPow z (HSub.hSub p 1)) (HPow.hPow (Real.log z) 2))","decl":"lemma eventually_deriv_rpow_p_mul_one_sub_smoothingFn (p : ℝ) :\n    deriv (fun z => z ^ p * (1 - ε z))\n      =ᶠ[atTop] fun z => p * z ^ (p-1) * (1 - ε z) + z ^ (p-1) / (log z ^ 2) := calc\n  deriv (fun x => x ^ p * (1 - ε x))\n    =ᶠ[atTop] fun x => deriv (· ^ p) x * (1 - ε x) + x ^ p * deriv (1 - ε ·) x := by\n            filter_upwards [eventually_gt_atTop 1] with x hx\n            rw [deriv_mul]\n            · exact differentiableAt_rpow_const_of_ne _ (by positivity)\n            · exact differentiableAt_one_sub_smoothingFn hx\n  _ =ᶠ[atTop] fun x => p * x ^ (p-1) * (1 - ε x) + x ^ p * (x⁻¹ / (log x ^ 2)) := by\n            filter_upwards [eventually_gt_atTop 1, eventually_deriv_one_sub_smoothingFn]\n              with x hx hderiv\n            rw [hderiv, Real.deriv_rpow_const (Or.inl <| by positivity)]\n  _ =ᶠ[atTop] fun x => p * x ^ (p-1) * (1 - ε x) + x ^ (p-1) / (log x ^ 2) := by\n            filter_upwards [eventually_gt_atTop 0] with x hx\n            rw [mul_div, ← Real.rpow_neg_one, ← Real.rpow_add (by positivity), sub_eq_add_neg]\n\n"}
{"name":"AkraBazziRecurrence.eventually_deriv_rpow_p_mul_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\n⊢ Filter.atTop.EventuallyEq (deriv fun z => HMul.hMul (HPow.hPow z p) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z))) fun z => HSub.hSub (HMul.hMul (HMul.hMul p (HPow.hPow z (HSub.hSub p 1))) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z))) (HDiv.hDiv (HPow.hPow z (HSub.hSub p 1)) (HPow.hPow (Real.log z) 2))","decl":"lemma eventually_deriv_rpow_p_mul_one_add_smoothingFn (p : ℝ) :\n    deriv (fun z => z ^ p * (1 + ε z))\n      =ᶠ[atTop] fun z => p * z ^ (p-1) * (1 + ε z) - z ^ (p-1) / (log z ^ 2) := calc\n  deriv (fun x => x ^ p * (1 + ε x))\n    =ᶠ[atTop] fun x => deriv (· ^ p) x * (1 + ε x) + x ^ p * deriv (1 + ε ·) x := by\n            filter_upwards [eventually_gt_atTop 1] with x hx\n            rw [deriv_mul]\n            · exact differentiableAt_rpow_const_of_ne _ (by positivity)\n            · exact differentiableAt_one_add_smoothingFn hx\n  _ =ᶠ[atTop] fun x => p * x ^ (p-1) * (1 + ε x) - x ^ p * (x⁻¹ / (log x ^ 2)) := by\n            filter_upwards [eventually_gt_atTop 1, eventually_deriv_one_add_smoothingFn]\n              with x hx hderiv\n            simp [hderiv, Real.deriv_rpow_const (Or.inl <| by positivity), neg_div, sub_eq_add_neg]\n  _ =ᶠ[atTop] fun x => p * x ^ (p-1) * (1 + ε x) - x ^ (p-1) / (log x ^ 2) := by\n            filter_upwards [eventually_gt_atTop 0] with x hx\n            simp [mul_div, ← Real.rpow_neg_one, ← Real.rpow_add (by positivity), sub_eq_add_neg]\n\n"}
{"name":"AkraBazziRecurrence.isEquivalent_deriv_rpow_p_mul_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\nhp : Ne p 0\n⊢ Asymptotics.IsEquivalent Filter.atTop (deriv fun z => HMul.hMul (HPow.hPow z p) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z))) fun z => HMul.hMul p (HPow.hPow z (HSub.hSub p 1))","decl":"lemma isEquivalent_deriv_rpow_p_mul_one_sub_smoothingFn {p : ℝ} (hp : p ≠ 0) :\n    deriv (fun z => z ^ p * (1 - ε z)) ~[atTop] fun z => p * z ^ (p-1) := calc\n  deriv (fun z => z ^ p * (1 - ε z))\n    =ᶠ[atTop] fun z => p * z ^ (p-1) * (1 - ε z) + z^(p-1) / (log z ^ 2) :=\n        eventually_deriv_rpow_p_mul_one_sub_smoothingFn p\n  _ ~[atTop] fun z => p * z ^ (p-1) := by\n        refine IsEquivalent.add_isLittleO ?one ?two\n        case one => calc\n          (fun z => p * z ^ (p-1) * (1 - ε z)) ~[atTop] fun z => p * z ^ (p-1) * 1 :=\n                IsEquivalent.mul IsEquivalent.refl isEquivalent_one_sub_smoothingFn_one\n          _ = fun z => p * z ^ (p-1) := by ext; ring\n        case two => calc\n          (fun z => z ^ (p-1) / (log z ^ 2)) =o[atTop] fun z => z ^ (p-1) / 1 := by\n                      simp_rw [div_eq_mul_inv]\n                      refine IsBigO.mul_isLittleO (isBigO_refl _ _)\n                        (IsLittleO.inv_rev ?_ (by simp))\n                      rw [isLittleO_const_left]\n                      refine Or.inr <| Tendsto.comp tendsto_norm_atTop_atTop ?_\n                      exact Tendsto.comp (g := fun z => z ^ 2)\n                        (tendsto_pow_atTop (by norm_num)) tendsto_log_atTop\n          _ = fun z => z ^ (p-1) := by ext; simp\n          _ =Θ[atTop] fun z => p * z ^ (p-1) := by\n                      exact IsTheta.const_mul_right hp <| isTheta_refl _ _\n\n"}
{"name":"AkraBazziRecurrence.isEquivalent_deriv_rpow_p_mul_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\nhp : Ne p 0\n⊢ Asymptotics.IsEquivalent Filter.atTop (deriv fun z => HMul.hMul (HPow.hPow z p) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z))) fun z => HMul.hMul p (HPow.hPow z (HSub.hSub p 1))","decl":"lemma isEquivalent_deriv_rpow_p_mul_one_add_smoothingFn {p : ℝ} (hp : p ≠ 0) :\n    deriv (fun z => z ^ p * (1 + ε z)) ~[atTop] fun z => p * z ^ (p-1) := calc\n  deriv (fun z => z ^ p * (1 + ε z))\n    =ᶠ[atTop] fun z => p * z ^ (p-1) * (1 + ε z) - z ^ (p-1) / (log z ^ 2) :=\n        eventually_deriv_rpow_p_mul_one_add_smoothingFn p\n  _ ~[atTop] fun z => p * z ^ (p-1) := by\n        refine IsEquivalent.add_isLittleO ?one ?two\n        case one => calc\n          (fun z => p * z ^ (p-1) * (1 + ε z)) ~[atTop] fun z => p * z ^ (p-1) * 1 :=\n                IsEquivalent.mul IsEquivalent.refl isEquivalent_one_add_smoothingFn_one\n          _ = fun z => p * z ^ (p-1) := by ext; ring\n        case two => calc\n          (fun z => -(z ^ (p-1) / (log z ^ 2))) =o[atTop] fun z => z ^ (p-1) / 1 := by\n                      simp_rw [isLittleO_neg_left, div_eq_mul_inv]\n                      refine IsBigO.mul_isLittleO (isBigO_refl _ _)\n                        (IsLittleO.inv_rev ?_ (by simp))\n                      rw [isLittleO_const_left]\n                      refine Or.inr <| Tendsto.comp tendsto_norm_atTop_atTop ?_\n                      exact Tendsto.comp (g := fun z => z ^ 2)\n                        (tendsto_pow_atTop (by norm_num)) tendsto_log_atTop\n          _ = fun z => z ^ (p-1) := by ext; simp\n          _ =Θ[atTop] fun z => p * z ^ (p-1) := by\n                      exact IsTheta.const_mul_right hp <| isTheta_refl _ _\n\n"}
{"name":"AkraBazziRecurrence.isTheta_deriv_rpow_p_mul_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\nhp : Ne p 0\n⊢ Asymptotics.IsTheta Filter.atTop (fun x => Norm.norm (deriv (fun z => HMul.hMul (HPow.hPow z p) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z))) x)) fun z => HPow.hPow z (HSub.hSub p 1)","decl":"lemma isTheta_deriv_rpow_p_mul_one_sub_smoothingFn {p : ℝ} (hp : p ≠ 0) :\n    (fun x => ‖deriv (fun z => z ^ p * (1 - ε z)) x‖) =Θ[atTop] fun z => z ^ (p-1) := by\n  refine IsTheta.norm_left ?_\n  calc (fun x => deriv (fun z => z ^ p * (1 - ε z)) x) =Θ[atTop] fun z => p * z ^ (p-1) :=\n            (isEquivalent_deriv_rpow_p_mul_one_sub_smoothingFn hp).isTheta\n    _ =Θ[atTop] fun z => z ^ (p-1) :=\n            IsTheta.const_mul_left hp <| isTheta_refl _ _\n\n"}
{"name":"AkraBazziRecurrence.isTheta_deriv_rpow_p_mul_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\nhp : Ne p 0\n⊢ Asymptotics.IsTheta Filter.atTop (fun x => Norm.norm (deriv (fun z => HMul.hMul (HPow.hPow z p) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z))) x)) fun z => HPow.hPow z (HSub.hSub p 1)","decl":"lemma isTheta_deriv_rpow_p_mul_one_add_smoothingFn {p : ℝ} (hp : p ≠ 0) :\n    (fun x => ‖deriv (fun z => z ^ p * (1 + ε z)) x‖) =Θ[atTop] fun z => z ^ (p-1) := by\n  refine IsTheta.norm_left ?_\n  calc (fun x => deriv (fun z => z ^ p * (1 + ε z)) x) =Θ[atTop] fun z => p * z ^ (p-1) :=\n            (isEquivalent_deriv_rpow_p_mul_one_add_smoothingFn hp).isTheta\n    _ =Θ[atTop] fun z => z ^ (p-1) :=\n            IsTheta.const_mul_left hp <| isTheta_refl _ _\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_deriv_rpow_p_mul_one_sub_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => Norm.norm (deriv (fun z => HMul.hMul (HPow.hPow z p) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn z))) x)","decl":"lemma growsPolynomially_deriv_rpow_p_mul_one_sub_smoothingFn (p : ℝ) :\n    GrowsPolynomially fun x => ‖deriv (fun z => z ^ p * (1 - ε z)) x‖ := by\n  cases eq_or_ne p 0 with\n  | inl hp => -- p = 0\n    have h₁ : (fun x => ‖deriv (fun z => z ^ p * (1 - ε z)) x‖)\n        =ᶠ[atTop] fun z => z⁻¹ / (log z ^ 2) := by\n      filter_upwards [eventually_deriv_one_sub_smoothingFn, eventually_gt_atTop 1] with x hx hx_pos\n      have : 0 ≤ x⁻¹ / (log x ^ 2) := by\n        have hlog : 0 < log x := Real.log_pos hx_pos\n        positivity\n      simp only [hp, Real.rpow_zero, one_mul, differentiableAt_const, hx, Real.norm_of_nonneg this]\n    refine GrowsPolynomially.congr_of_eventuallyEq h₁ ?_\n    refine GrowsPolynomially.div (GrowsPolynomially.inv growsPolynomially_id)\n      (GrowsPolynomially.pow 2 growsPolynomially_log ?_)\n    filter_upwards [eventually_ge_atTop 1] with _ hx\n    exact log_nonneg hx\n  | inr hp => -- p ≠ 0\n    refine GrowsPolynomially.of_isTheta (growsPolynomially_rpow (p-1))\n      (isTheta_deriv_rpow_p_mul_one_sub_smoothingFn hp) ?_\n    filter_upwards [eventually_gt_atTop 0] with _ _\n    positivity\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"p : Real\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => Norm.norm (deriv (fun z => HMul.hMul (HPow.hPow z p) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn z))) x)","decl":"lemma growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p : ℝ) :\n    GrowsPolynomially fun x => ‖deriv (fun z => z ^ p * (1 + ε z)) x‖ := by\n  cases eq_or_ne p 0 with\n  | inl hp => -- p = 0\n    have h₁ : (fun x => ‖deriv (fun z => z ^ p * (1 + ε z)) x‖)\n        =ᶠ[atTop] fun z => z⁻¹ / (log z ^ 2) := by\n      filter_upwards [eventually_deriv_one_add_smoothingFn, eventually_gt_atTop 1] with x hx hx_pos\n      have : 0 ≤ x⁻¹ / (log x ^ 2) := by\n        have hlog : 0 < log x := Real.log_pos hx_pos\n        positivity\n      simp only [neg_div, norm_neg, hp, Real.rpow_zero,\n        one_mul, differentiableAt_const, hx, Real.norm_of_nonneg this]\n    refine GrowsPolynomially.congr_of_eventuallyEq h₁ ?_\n    refine GrowsPolynomially.div (GrowsPolynomially.inv growsPolynomially_id)\n      (GrowsPolynomially.pow 2 growsPolynomially_log ?_)\n    filter_upwards [eventually_ge_atTop 1] with x hx\n    exact log_nonneg hx\n  | inr hp => -- p ≠ 0\n    refine GrowsPolynomially.of_isTheta (growsPolynomially_rpow (p-1))\n      (isTheta_deriv_rpow_p_mul_one_add_smoothingFn hp) ?_\n    filter_upwards [eventually_gt_atTop 0] with _ _\n    positivity\n\n"}
{"name":"AkraBazziRecurrence.isBigO_apply_r_sub_b","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\nq : Real → Real\nhq_diff : DifferentiableOn Real q (Set.Ioi 1)\nhq_poly : AkraBazziRecurrence.GrowsPolynomially fun x => Norm.norm (deriv q x)\ni : α\n⊢ Asymptotics.IsBigO Filter.atTop (fun n => HSub.hSub (q ↑(r i n)) (q (HMul.hMul (b i) ↑n))) fun n => HMul.hMul (deriv q ↑n) (HSub.hSub (↑(r i n)) (HMul.hMul (b i) ↑n))","decl":"lemma isBigO_apply_r_sub_b (q : ℝ → ℝ) (hq_diff : DifferentiableOn ℝ q (Set.Ioi 1))\n    (hq_poly : GrowsPolynomially fun x => ‖deriv q x‖) (i : α) :\n    (fun n => q (r i n) - q (b i * n)) =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by\n  let b' := b (min_bi b) / 2\n  have hb_pos : 0 < b' := by have := R.b_pos (min_bi b); positivity\n  have hb_lt_one : b' < 1 := calc\n    b (min_bi b) / 2 < b (min_bi b) := by exact div_two_lt_of_pos (R.b_pos (min_bi b))\n                   _ < 1 := R.b_lt_one (min_bi b)\n  have hb : b' ∈ Set.Ioo 0 1 := ⟨hb_pos, hb_lt_one⟩\n  have hb' : ∀ i, b' ≤ b i := fun i => calc\n    b (min_bi b) / 2 ≤ b i / 2 := by gcongr; aesop\n               _ ≤ b i := by exact le_of_lt <| div_two_lt_of_pos (R.b_pos i)\n  obtain ⟨c₁, _, c₂, _, hq_poly⟩ := hq_poly b' hb\n  rw [isBigO_iff]\n  refine ⟨c₂, ?_⟩\n  have h_tendsto : Tendsto (fun x => b' * x) atTop atTop :=\n    Tendsto.const_mul_atTop hb_pos tendsto_id\n  filter_upwards [hq_poly.natCast_atTop, R.eventually_bi_mul_le_r, eventually_ge_atTop R.n₀,\n                  eventually_gt_atTop 0, (h_tendsto.eventually_gt_atTop 1).natCast_atTop] with\n    n hn h_bi_le_r h_ge_n₀ h_n_pos h_bn\n  rw [norm_mul, ← mul_assoc]\n  refine Convex.norm_image_sub_le_of_norm_deriv_le\n    (s := Set.Icc (b'*n) n) (fun z hz => ?diff) (fun z hz => (hn z hz).2)\n    (convex_Icc _ _) ?mem_Icc <| ⟨h_bi_le_r i, by exact_mod_cast (le_of_lt (R.r_lt_n i n h_ge_n₀))⟩\n  case diff =>\n    refine hq_diff.differentiableAt (Ioi_mem_nhds ?_)\n    calc 1 < b' * n := by exact h_bn\n         _ ≤ z := hz.1\n  case mem_Icc =>\n    refine ⟨by gcongr; exact hb' i, ?_⟩\n    calc b i * n ≤ 1 * n := by gcongr; exact le_of_lt <| R.b_lt_one i\n                 _ = n := by simp\n\n"}
{"name":"AkraBazziRecurrence.rpow_p_mul_one_sub_smoothingFn_le","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Eventually (fun n => ∀ (i : α), LE.le (HMul.hMul (HPow.hPow (↑(r i n)) (AkraBazziRecurrence.p a b)) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ↑(r i n)))) (HMul.hMul (HMul.hMul (HPow.hPow (b i) (AkraBazziRecurrence.p a b)) (HPow.hPow (↑n) (AkraBazziRecurrence.p a b))) (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ↑n)))) Filter.atTop","decl":"lemma rpow_p_mul_one_sub_smoothingFn_le :\n    ∀ᶠ (n : ℕ) in atTop, ∀ i, (r i n) ^ (p a b) * (1 - ε (r i n))\n      ≤ (b i) ^ (p a b) * n ^ (p a b) * (1 - ε n) := by\n  rw [Filter.eventually_all]\n  intro i\n  let q : ℝ → ℝ := fun x => x ^ (p a b) * (1 - ε x)\n  have h_diff_q : DifferentiableOn ℝ q (Set.Ioi 1) := by\n    refine DifferentiableOn.mul\n      (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)\n        differentiableOn_one_sub_smoothingFn\n    rw [Set.mem_compl_singleton_iff]\n    rw [Set.mem_Ioi] at hz\n    exact ne_of_gt <| zero_lt_one.trans hz\n  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc\n    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 - ε z) x := by rfl\n          _ =ᶠ[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 - ε x) +\n                  x ^ (p a b) * deriv (fun z => 1 - ε z) x := by\n              filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'\n              rw [deriv_mul] <;> aesop\n          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by\n              refine IsBigO.add ?left ?right\n              case left => calc\n                (fun x => deriv (fun z => z ^ (p a b)) x * (1 - ε x))\n                    =O[atTop] fun x => x ^ ((p a b) - 1) * (1 - ε x) := by\n                      exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)\n                  _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 := by\n                      refine IsBigO.mul (isBigO_refl _ _)\n                        isEquivalent_one_sub_smoothingFn_one.isBigO\n                  _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]\n              case right => calc\n                (fun x => x ^ (p a b) * deriv (fun z => 1 - ε z) x)\n                    =O[atTop] (fun x => x ^ (p a b) * x⁻¹) := by\n                      exact IsBigO.mul (isBigO_refl _ _) isLittleO_deriv_one_sub_smoothingFn.isBigO\n                  _ =ᶠ[atTop] fun x => x ^ ((p a b) - 1) := by\n                      filter_upwards [eventually_gt_atTop 0] with x hx\n                      rw [← Real.rpow_neg_one, ← Real.rpow_add hx, ← sub_eq_add_neg]\n  have h_main_norm : (fun (n : ℕ) => ‖q (r i n) - q (b i * n)‖)\n      ≤ᶠ[atTop] fun (n : ℕ) => ‖(b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n)‖ := by\n    refine IsLittleO.eventuallyLE ?_\n    calc\n      (fun (n : ℕ) => q (r i n) - q (b i * n))\n          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by\n              exact R.isBigO_apply_r_sub_b q h_diff_q\n                (growsPolynomially_deriv_rpow_p_mul_one_sub_smoothingFn (p a b)) i\n        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by\n              exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)\n        _ =O[atTop] fun n => n^((p a b) - 1) * (n / log n ^ 2) := by\n              exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)\n        _ =ᶠ[atTop] fun n => n^(p a b) / (log n) ^ 2 := by\n              filter_upwards [eventually_ne_atTop 0] with n hn\n              have hn' : (n : ℝ) ≠ 0 := by positivity\n              simp [← mul_div_assoc, ← Real.rpow_add_one hn']\n        _ = fun (n : ℕ) => (n : ℝ) ^ (p a b) * (1 / (log n)^2) := by\n              simp_rw [mul_div, mul_one]\n        _ =Θ[atTop] fun (n : ℕ) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n)^2) := by\n              refine IsTheta.symm ?_\n              simp_rw [mul_assoc]\n              refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)\n              have := R.b_pos i; positivity\n        _ =Θ[atTop] fun (n : ℕ) => (b i)^(p a b) * n^(p a b) * (ε (b i * n) - ε n) := by\n              exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)\n                <| R.isTheta_smoothingFn_sub_self i\n  have h_main : (fun (n : ℕ) => q (r i n) - q (b i * n))\n      ≤ᶠ[atTop] fun (n : ℕ) => (b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n) := by\n    calc (fun (n : ℕ) => q (r i n) - q (b i * n))\n           ≤ᶠ[atTop] fun (n : ℕ) => ‖q (r i n) - q (b i * n)‖ := by\n                filter_upwards with _; exact le_norm_self _\n         _ ≤ᶠ[atTop] fun (n : ℕ) => ‖(b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n)‖ :=\n                h_main_norm\n         _ =ᶠ[atTop] fun (n : ℕ) => (b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n) := by\n                filter_upwards [eventually_gt_atTop ⌈(b i)⁻¹⌉₊, eventually_gt_atTop 1] with n hn hn'\n                refine norm_of_nonneg ?_\n                have h₁ := R.b_pos i\n                have h₂ : 0 ≤ ε (b i * n) - ε n := by\n                  refine sub_nonneg_of_le <|\n                    (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le\n                  case n_gt_one =>\n                    rwa [Set.mem_Ioi, Nat.one_lt_cast]\n                  case bn_gt_one =>\n                    calc 1 = b i * (b i)⁻¹ := by rw [mul_inv_cancel₀ (by positivity)]\n                        _ ≤ b i * ⌈(b i)⁻¹⌉₊ := by gcongr; exact Nat.le_ceil _\n                        _ < b i * n := by gcongr\n                  case le => calc b i * n ≤ 1 * n := by have := R.b_lt_one i; gcongr\n                                          _ = n := by rw [one_mul]\n                positivity\n  filter_upwards [h_main] with n hn\n  have h₁ : q (b i * n) + (b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n)\n      = (b i) ^ (p a b) * n ^ (p a b) * (1 - ε n) := by\n    have := R.b_pos i\n    simp only [q, mul_rpow (by positivity : (0 : ℝ) ≤ b i) (by positivity : (0 : ℝ) ≤ n)]\n    ring\n  show q (r i n) ≤ (b i) ^ (p a b) * n ^ (p a b) * (1 - ε n)\n  rw [← h₁, ← sub_le_iff_le_add']\n  exact hn\n\n"}
{"name":"AkraBazziRecurrence.rpow_p_mul_one_add_smoothingFn_ge","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Filter.Eventually (fun n => ∀ (i : α), LE.le (HMul.hMul (HMul.hMul (HPow.hPow (b i) (AkraBazziRecurrence.p a b)) (HPow.hPow (↑n) (AkraBazziRecurrence.p a b))) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn ↑n))) (HMul.hMul (HPow.hPow (↑(r i n)) (AkraBazziRecurrence.p a b)) (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn ↑(r i n))))) Filter.atTop","decl":"lemma rpow_p_mul_one_add_smoothingFn_ge :\n    ∀ᶠ (n : ℕ) in atTop, ∀ i, (b i) ^ (p a b) * n ^ (p a b) * (1 + ε n)\n      ≤ (r i n) ^ (p a b) * (1 + ε (r i n)) := by\n  rw [Filter.eventually_all]\n  intro i\n  let q : ℝ → ℝ := fun x => x ^ (p a b) * (1 + ε x)\n  have h_diff_q : DifferentiableOn ℝ q (Set.Ioi 1) := by\n    refine DifferentiableOn.mul\n        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)\n        differentiableOn_one_add_smoothingFn\n    rw [Set.mem_compl_singleton_iff]\n    rw [Set.mem_Ioi] at hz\n    exact ne_of_gt <| zero_lt_one.trans hz\n  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc\n    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + ε z) x := by rfl\n          _ =ᶠ[atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + ε x)\n              + x ^ (p a b) * deriv (fun z => 1 + ε z) x := by\n                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'\n                rw [deriv_mul] <;> aesop\n          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by\n                refine IsBigO.add ?left ?right\n                case left => calc\n                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + ε x))\n                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + ε x) := by\n                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)\n                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=\n                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO\n                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]\n                case right => calc\n                  (fun x => x ^ (p a b) * deriv (fun z => 1 + ε z) x)\n                      =O[atTop] (fun x => x ^ (p a b) * x⁻¹) := by\n                        exact IsBigO.mul (isBigO_refl _ _)\n                          isLittleO_deriv_one_add_smoothingFn.isBigO\n                    _ =ᶠ[atTop] fun x => x ^ ((p a b) - 1) := by\n                        filter_upwards [eventually_gt_atTop 0] with x hx\n                        rw [← Real.rpow_neg_one, ← Real.rpow_add hx, ← sub_eq_add_neg]\n  have h_main_norm : (fun (n : ℕ) => ‖q (r i n) - q (b i * n)‖)\n      ≤ᶠ[atTop] fun (n : ℕ) => ‖(b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n)‖ := by\n    refine IsLittleO.eventuallyLE ?_\n    calc\n      (fun (n : ℕ) => q (r i n) - q (b i * n))\n          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by\n            exact R.isBigO_apply_r_sub_b q h_diff_q\n              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i\n        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by\n            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)\n        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by\n            exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)\n        _ =ᶠ[atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by\n            filter_upwards [eventually_ne_atTop 0] with n hn\n            have hn' : (n : ℝ) ≠ 0 := by positivity\n            simp [← mul_div_assoc, ← Real.rpow_add_one hn']\n        _ = fun (n : ℕ) => (n : ℝ) ^ (p a b) * (1 / (log n) ^ 2) := by simp_rw [mul_div, mul_one]\n        _ =Θ[atTop] fun (n : ℕ) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by\n            refine IsTheta.symm ?_\n            simp_rw [mul_assoc]\n            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)\n            have := R.b_pos i; positivity\n        _ =Θ[atTop] fun (n : ℕ) => (b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n) := by\n            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)\n                  <| R.isTheta_smoothingFn_sub_self i\n  have h_main : (fun (n : ℕ) => q (b i * n) - q (r i n))\n      ≤ᶠ[atTop] fun (n : ℕ) => (b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n) := by\n    calc (fun (n : ℕ) => q (b i * n) - q (r i n))\n           ≤ᶠ[atTop] fun (n : ℕ) => ‖q (r i n) - q (b i * n)‖ := by\n              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _\n         _ ≤ᶠ[atTop] fun (n : ℕ) => ‖(b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n)‖ :=\n              h_main_norm\n         _ =ᶠ[atTop] fun (n : ℕ) => (b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n) := by\n              filter_upwards [eventually_gt_atTop ⌈(b i)⁻¹⌉₊, eventually_gt_atTop 1] with n hn hn'\n              refine norm_of_nonneg ?_\n              have h₁ := R.b_pos i\n              have h₂ : 0 ≤ ε (b i * n) - ε n := by\n                refine sub_nonneg_of_le <|\n                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le\n                case n_gt_one =>\n                  show 1 < (n : ℝ)\n                  rw [Nat.one_lt_cast]\n                  exact hn'\n                case bn_gt_one =>\n                  calc 1 = b i * (b i)⁻¹ := by rw [mul_inv_cancel₀ (by positivity)]\n                      _ ≤ b i * ⌈(b i)⁻¹⌉₊ := by gcongr; exact Nat.le_ceil _\n                      _ < b i * n := by gcongr\n                case le => calc b i * n ≤ 1 * n := by have := R.b_lt_one i; gcongr\n                                        _ = n := by rw [one_mul]\n              positivity\n  filter_upwards [h_main] with n hn\n  have h₁ : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (ε (b i * n) - ε n)\n      = (b i) ^ (p a b) * n ^ (p a b) * (1 + ε n) := by\n    have := R.b_pos i\n    simp only [q, mul_rpow (by positivity : (0 : ℝ) ≤ b i) (by positivity : (0 : ℝ) ≤ n)]\n    ring\n  show (b i) ^ (p a b) * n ^ (p a b) * (1 + ε n) ≤ q (r i n)\n  rw [← h₁, sub_le_iff_le_add', ← sub_le_iff_le_add]\n  exact hn\n\n"}
{"name":"AkraBazziRecurrence.base_nonempty","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\nn : Nat\nhn : LT.lt 0 n\n⊢ (Finset.Ico (Nat.floor (HMul.hMul (HDiv.hDiv (b (AkraBazziRecurrence.min_bi b)) 2) ↑n)) n).Nonempty","decl":"lemma base_nonempty {n : ℕ} (hn : 0 < n) : (Finset.Ico (⌊b (min_bi b) / 2 * n⌋₊) n).Nonempty := by\n  let b' := b (min_bi b)\n  have hb_pos : 0 < b' := R.b_pos _\n  simp_rw [Finset.nonempty_Ico]\n  exact_mod_cast calc ⌊b' / 2 * n⌋₊ ≤ b' / 2 * n := by exact Nat.floor_le (by positivity)\n                                 _ < 1 / 2 * n   := by gcongr; exact R.b_lt_one (min_bi b)\n                                 _ ≤ 1 * n       := by gcongr; norm_num\n                                 _ = n           := by simp\n\n"}
{"name":"AkraBazziRecurrence.T_isBigO_smoothingFn_mul_asympBound","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Asymptotics.IsBigO Filter.atTop T fun n => HMul.hMul (HSub.hSub 1 (AkraBazziRecurrence.smoothingFn ↑n)) (AkraBazziRecurrence.asympBound g a b n)","decl":"/-- The main proof of the upper bound part of the Akra-Bazzi theorem. The factor\n`1 - ε n` does not change the asymptotic order, but is needed for the induction step to go\nthrough. -/\nlemma T_isBigO_smoothingFn_mul_asympBound :\n    T =O[atTop] (fun n => (1 - ε n) * asympBound g a b n) := by\n  let b' := b (min_bi b) / 2\n  have hb_pos : 0 < b' := R.bi_min_div_two_pos\n  rw [isBigO_atTop_iff_eventually_exists]\n  obtain ⟨c₁, hc₁, h_sumTransform_aux⟩ := R.eventually_atTop_sumTransform_ge\n  filter_upwards [eventually_ge_atTop R.n₀,       -- n₀_ge_Rn₀\n      eventually_forall_ge_atTop.mpr eventually_one_sub_smoothingFn_pos,    -- h_smoothing_pos\n      eventually_forall_ge_atTop.mpr\n        <| eventually_one_sub_smoothingFn_gt_const (1/2) (by norm_num),    -- h_smoothing_gt_half\n      eventually_forall_ge_atTop.mpr R.eventually_asympBound_pos,            -- h_asympBound_pos\n      eventually_forall_ge_atTop.mpr R.eventually_asympBound_r_pos,          -- h_asympBound_r_pos\n      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop\n        R.eventually_asympBound_pos,   -- h_asympBound_floor\n      eventually_gt_atTop 0,                                                -- n₀_pos\n      eventually_forall_ge_atTop.mpr R.eventually_one_sub_smoothingFn_r_pos,  -- h_smoothing_r_pos\n      eventually_forall_ge_atTop.mpr R.rpow_p_mul_one_sub_smoothingFn_le,    -- bound1\n      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop\n        eventually_one_sub_smoothingFn_pos,   -- h_smoothingFn_floor\n      eventually_forall_ge_atTop.mpr h_sumTransform_aux,                     -- h_sumTransform\n      eventually_forall_ge_atTop.mpr R.eventually_bi_mul_le_r]               -- h_bi_le_r\n    with n₀ n₀_ge_Rn₀ h_smoothing_pos h_smoothing_gt_half\n      h_asympBound_pos h_asympBound_r_pos h_asympBound_floor n₀_pos h_smoothing_r_pos\n      bound1 h_smoothingFn_floor h_sumTransform h_bi_le_r\n  -- Max of the ratio `T(n) / asympBound(n)` over the base case `n ∈ [b * n₀, n₀)`\n  have h_base_nonempty := R.base_nonempty n₀_pos\n  let base_max : ℝ :=\n    (Finset.Ico (⌊b' * n₀⌋₊) n₀).sup' h_base_nonempty\n      fun n => T n / ((1 - ε n) * asympBound g a b n)\n  -- The big-O constant we are aiming for: max of the base case ratio and what we need to\n  -- cancel out the `g(n)` term in the calculation below\n  set C := max (2 * c₁⁻¹) base_max with hC\n  refine ⟨C, fun n hn => ?_⟩\n  -- Base case: statement is true for `b' * n₀ ≤ n < n₀`\n  have h_base : ∀ n ∈ Finset.Ico (⌊b' * n₀⌋₊) n₀, T n ≤ C * ((1 - ε n) * asympBound g a b n) := by\n    intro n hn\n    rw [Finset.mem_Ico] at hn\n    have htmp1 : 0 < 1 - ε n := h_smoothingFn_floor n hn.1\n    have htmp2 : 0 < asympBound g a b n := h_asympBound_floor n hn.1\n    rw [← _root_.div_le_iff₀ (by positivity)]\n    rw [← Finset.mem_Ico] at hn\n    calc T n / ((1 - ε ↑n) * asympBound g a b n)\n           ≤ (Finset.Ico (⌊b' * n₀⌋₊) n₀).sup' h_base_nonempty\n                (fun z => T z / ((1 - ε z) * asympBound g a b z)) :=\n                  Finset.le_sup'_of_le _ (b := n) hn le_rfl\n         _ ≤ C := le_max_right _ _\n  have h_asympBound_pos' : 0 < asympBound g a b n := h_asympBound_pos n hn\n  have h_one_sub_smoothingFn_pos' : 0 < 1 - ε n := h_smoothing_pos n hn\n  rw [Real.norm_of_nonneg (R.T_nonneg n), Real.norm_of_nonneg (by positivity)]\n  -- We now prove all other cases by induction\n  induction n using Nat.strongRecOn with\n  | ind n h_ind =>\n    have b_mul_n₀_le_ri i : ⌊b' * ↑n₀⌋₊ ≤ r i n := by\n      exact_mod_cast calc ⌊b' * (n₀ : ℝ)⌋₊ ≤ b' * n₀ := Nat.floor_le <| by positivity\n                                  _ ≤ b' * n         := by gcongr\n                                  _ ≤ r i n          := h_bi_le_r n hn i\n    have g_pos : 0 ≤ g n := R.g_nonneg n (by positivity)\n    calc\n      T n = (∑ i, a i * T (r i n)) + g n := by exact R.h_rec n <| n₀_ge_Rn₀.trans hn\n        _ ≤ (∑ i, a i * (C * ((1 - ε (r i n)) * asympBound g a b (r i n)))) + g n := by\n            -- Apply the induction hypothesis, or use the base case depending on how large n is\n            gcongr (∑ i, a i * ?_) + g n with i _\n            · exact le_of_lt <| R.a_pos _\n            · if ri_lt_n₀ : r i n < n₀ then\n                exact h_base _ <| by\n                  simp_all only [gt_iff_lt, Nat.ofNat_pos, div_pos_iff_of_pos_right,\n                    eventually_atTop, sub_pos, one_div, mem_Ico, and_imp,\n                    forall_true_left, mem_univ, and_self, b', C, base_max]\n              else\n                push_neg at ri_lt_n₀\n                exact h_ind (r i n) (R.r_lt_n _ _ (n₀_ge_Rn₀.trans hn)) ri_lt_n₀\n                  (h_asympBound_r_pos _ hn _) (h_smoothing_r_pos n hn i)\n        _ = (∑ i, a i * (C * ((1 - ε (r i n)) * ((r i n) ^ (p a b)\n                * (1 + (∑ u ∈ range (r i n), g u / u ^ ((p a b) + 1))))))) + g n := by\n            simp_rw [asympBound_def']\n        _ = (∑ i, C * a i * ((r i n) ^ (p a b) * (1 - ε (r i n))\n                * ((1 + (∑ u ∈ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by\n            congr; ext; ring\n        _ ≤ (∑ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - ε n)\n                * ((1 + (∑ u ∈ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by\n            gcongr (∑ i, C * a i * (?_\n                * ((1 + (∑ u ∈ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n with i\n            · have := R.a_pos i\n              positivity\n            · refine add_nonneg zero_le_one <| Finset.sum_nonneg fun j _ => ?_\n              rw [div_nonneg_iff]\n              exact Or.inl ⟨R.g_nonneg j (by positivity), by positivity⟩\n            · exact bound1 n hn i\n        _ = (∑ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - ε n)\n                * ((1 + ((∑ u ∈ range n, g u / u ^ ((p a b) + 1))\n                - (∑ u ∈ Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))) + g n := by\n            congr; ext i; congr\n            refine eq_sub_of_add_eq ?_\n            rw [add_comm]\n            exact add_eq_of_eq_sub <| Finset.sum_Ico_eq_sub _\n              <| le_of_lt <| R.r_lt_n i n <| n₀_ge_Rn₀.trans hn\n        _ = (∑ i, C * a i * ((b i) ^ (p a b) * (1 - ε n) * ((n ^ (p a b)\n                * (1 + (∑ u ∈ range n, g u / u ^ ((p a b) + 1)))\n                - n ^ (p a b) * (∑ u ∈ Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))\n                + g n := by\n            congr; ext; ring\n        _ = (∑ i, C * a i * ((b i) ^ (p a b) * (1 - ε n)\n                * ((asympBound g a b n - sumTransform (p a b) g (r i n) n)))) + g n := by\n            simp_rw [asympBound_def', sumTransform_def]\n        _ ≤ (∑ i, C * a i * ((b i) ^ (p a b) * (1 - ε n)\n                * ((asympBound g a b n - c₁ * g n)))) + g n := by\n            gcongr with i\n            · have := R.a_pos i\n              positivity\n            · have := R.b_pos i\n              positivity\n            · exact h_sumTransform n hn i\n        _ = (∑ i, C * (1 - ε n) * ((asympBound g a b n - c₁ * g n))\n                * (a i * (b i) ^ (p a b))) + g n := by\n            congr; ext; ring\n        _ = C * (1 - ε n) * (asympBound g a b n - c₁ * g n) + g n := by\n            rw [← Finset.mul_sum, R.sumCoeffsExp_p_eq_one, mul_one]\n        _ = C * (1 - ε n) * asympBound g a b n + (1 - C * c₁ * (1 - ε n)) * g n := by ring\n        _ ≤ C * (1 - ε n) * asympBound g a b n + 0 := by\n            gcongr\n            refine mul_nonpos_of_nonpos_of_nonneg ?_ g_pos\n            rw [sub_nonpos]\n            calc 1 ≤ 2 * (c₁⁻¹ * c₁) * (1/2) := by\n                    rw [inv_mul_cancel₀ (by positivity : c₁ ≠ 0)]; norm_num\n                 _ = (2 * c₁⁻¹) * c₁ * (1/2) := by ring\n                 _ ≤ C * c₁ * (1 - ε n) := by gcongr\n                                              · rw [hC]; exact le_max_left _ _\n                                              · exact le_of_lt <| h_smoothing_gt_half n hn\n        _ = C * ((1 - ε n) * asympBound g a b n) := by ring\n\n"}
{"name":"AkraBazziRecurrence.smoothingFn_mul_asympBound_isBigO_T","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Asymptotics.IsBigO Filter.atTop (fun n => HMul.hMul (HAdd.hAdd 1 (AkraBazziRecurrence.smoothingFn ↑n)) (AkraBazziRecurrence.asympBound g a b n)) T","decl":"/-- The main proof of the lower bound part of the Akra-Bazzi theorem. The factor\n`1 + ε n` does not change the asymptotic order, but is needed for the induction step to go\nthrough. -/\nlemma smoothingFn_mul_asympBound_isBigO_T :\n    (fun (n : ℕ) => (1 + ε n) * asympBound g a b n) =O[atTop] T := by\n  let b' := b (min_bi b) / 2\n  have hb_pos : 0 < b' := R.bi_min_div_two_pos\n  rw [isBigO_atTop_iff_eventually_exists_pos]\n  obtain ⟨c₁, hc₁, h_sumTransform_aux⟩ := R.eventually_atTop_sumTransform_le\n  filter_upwards [eventually_ge_atTop R.n₀,                                 -- n₀_ge_Rn₀\n      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_gt_atTop 0,        -- h_b_floor\n      eventually_forall_ge_atTop.mpr eventually_one_add_smoothingFn_pos,    -- h_smoothing_pos\n      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop\n        eventually_one_add_smoothingFn_pos,                                 -- h_smoothing_pos'\n      eventually_forall_ge_atTop.mpr R.eventually_asympBound_pos,            -- h_asympBound_pos\n      eventually_forall_ge_atTop.mpr R.eventually_asympBound_r_pos,          -- h_asympBound_r_pos\n      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop\n        R.eventually_asympBound_pos,                                         -- h_asympBound_floor\n      eventually_gt_atTop 0,                                                -- n₀_pos\n      eventually_forall_ge_atTop.mpr R.eventually_one_add_smoothingFn_r_pos,  -- h_smoothing_r_pos\n      eventually_forall_ge_atTop.mpr R.rpow_p_mul_one_add_smoothingFn_ge,   -- bound2\n      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop\n        eventually_one_add_smoothingFn_pos,                                 -- h_smoothingFn_floor\n      eventually_forall_ge_atTop.mpr h_sumTransform_aux,                    -- h_sumTransform\n      eventually_forall_ge_atTop.mpr R.eventually_bi_mul_le_r,              -- h_bi_le_r\n      eventually_forall_ge_atTop.mpr (eventually_ge_atTop ⌈exp 1⌉₊)]        -- h_exp\n    with n₀ n₀_ge_Rn₀ h_b_floor h_smoothing_pos h_smoothing_pos' h_asympBound_pos h_asympBound_r_pos\n      h_asympBound_floor n₀_pos h_smoothing_r_pos bound2 h_smoothingFn_floor h_sumTransform\n      h_bi_le_r h_exp\n  have h_base_nonempty := R.base_nonempty n₀_pos\n  -- Min of the ratio T(n) / asympBound(n) over the base case n ∈ [b * n₀, n₀)\n  set base_min : ℝ :=\n    (Finset.Ico (⌊b' * n₀⌋₊) n₀).inf' h_base_nonempty\n      (fun n => T n / ((1 + ε n) * asympBound g a b n)) with base_min_def\n  -- The big-O constant we are aiming for: min of the base case ratio and what we need to cancel\n  -- out the g(n) term in the calculation below\n  let C := min (2 * c₁)⁻¹ base_min\n  have hC_pos : 0 < C := by\n    refine lt_min (by positivity) ?_\n    obtain ⟨m, hm_mem, hm⟩ :=\n      Finset.exists_mem_eq_inf' h_base_nonempty (fun n => T n / ((1 + ε n) * asympBound g a b n))\n    calc 0 < T m / ((1 + ε m) * asympBound g a b m) := by\n              have H₁ : 0 < T m := by exact R.T_pos _\n              have H₂ : 0 < 1 + ε m := by rw [Finset.mem_Ico] at hm_mem\n                                          exact h_smoothing_pos' m hm_mem.1\n              have H₃ : 0 < asympBound g a b m := by\n                refine R.asympBound_pos m ?_\n                calc 0 < ⌊b' * n₀⌋₊ := by exact h_b_floor\n                     _ ≤ m := by rw [Finset.mem_Ico] at hm_mem; exact hm_mem.1\n              positivity\n         _ = base_min := by rw [base_min_def, hm]\n  refine ⟨C, hC_pos, fun n hn => ?_⟩\n  -- Base case: statement is true for `b' * n₀ ≤ n < n₀`\n  have h_base : ∀ n ∈ Finset.Ico (⌊b' * n₀⌋₊) n₀, C * ((1 + ε n) * asympBound g a b n) ≤ T n := by\n    intro n hn\n    rw [Finset.mem_Ico] at hn\n    have htmp1 : 0 < 1 + ε n := h_smoothingFn_floor n hn.1\n    have htmp2 : 0 < asympBound g a b n := h_asympBound_floor n hn.1\n    rw [← _root_.le_div_iff₀ (by positivity)]\n    rw [← Finset.mem_Ico] at hn\n    calc T n / ((1 + ε ↑n) * asympBound g a b n)\n           ≥ (Finset.Ico (⌊b' * n₀⌋₊) n₀).inf' h_base_nonempty\n                  fun z => T z / ((1 + ε z) * asympBound g a b z) :=\n                    Finset.inf'_le_of_le _ (b := n) hn <| le_refl _\n         _ ≥ C := min_le_right _ _\n  have h_asympBound_pos' : 0 < asympBound g a b n := h_asympBound_pos n hn\n  have h_one_sub_smoothingFn_pos' : 0 < 1 + ε n := h_smoothing_pos n hn\n  rw [Real.norm_of_nonneg (R.T_nonneg n), Real.norm_of_nonneg (by positivity)]\n  -- We now prove all other cases by induction\n  induction n using Nat.strongRecOn with\n  | ind n h_ind =>\n    have b_mul_n₀_le_ri i : ⌊b' * ↑n₀⌋₊ ≤ r i n := by\n      exact_mod_cast calc ⌊b' * ↑n₀⌋₊ ≤ b' * n₀ := Nat.floor_le <| by positivity\n                                  _ ≤ b' * n := by gcongr\n                                  _ ≤ r i n := h_bi_le_r n hn i\n    have g_pos : 0 ≤ g n := R.g_nonneg n (by positivity)\n    calc\n      T n = (∑ i, a i * T (r i n)) + g n := by exact R.h_rec n <| n₀_ge_Rn₀.trans hn\n        _ ≥ (∑ i, a i * (C * ((1 + ε (r i n)) * asympBound g a b (r i n)))) + g n := by\n            -- Apply the induction hypothesis, or use the base case depending on how large `n` is\n              gcongr (∑ i, a i * ?_) + g n with i _\n              · exact le_of_lt <| R.a_pos _\n              · cases lt_or_le (r i n) n₀ with\n                | inl ri_lt_n₀ => exact h_base _ <| Finset.mem_Ico.mpr ⟨b_mul_n₀_le_ri i, ri_lt_n₀⟩\n                | inr n₀_le_ri =>\n                  exact h_ind (r i n) (R.r_lt_n _ _ (n₀_ge_Rn₀.trans hn)) n₀_le_ri\n                    (h_asympBound_r_pos _ hn _) (h_smoothing_r_pos n hn i)\n        _ = (∑ i, a i * (C * ((1 + ε (r i n)) * ((r i n) ^ (p a b)\n                  * (1 + (∑ u ∈ range (r i n), g u / u ^ ((p a b) + 1))))))) + g n := by\n              simp_rw [asympBound_def']\n        _ = (∑ i, C * a i * ((r i n)^(p a b) * (1 + ε (r i n))\n                  * ((1 + (∑ u ∈ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by\n              congr; ext; ring\n        _ ≥ (∑ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 + ε n)\n                  * ((1 + (∑ u ∈ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by\n              gcongr (∑ i, C * a i * (?_ *\n                  ((1 + (∑ u ∈ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n with i\n              · have := R.a_pos i\n                positivity\n              · refine add_nonneg zero_le_one <| Finset.sum_nonneg fun j _ => ?_\n                rw [div_nonneg_iff]\n                exact Or.inl ⟨R.g_nonneg j (by positivity), by positivity⟩\n              · exact bound2 n hn i\n        _ = (∑ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 + ε n)\n                  * ((1 + ((∑ u ∈ range n, g u / u ^ ((p a b) + 1))\n                  - (∑ u ∈ Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))) + g n := by\n              congr; ext i; congr\n              refine eq_sub_of_add_eq ?_\n              rw [add_comm]\n              exact add_eq_of_eq_sub <| Finset.sum_Ico_eq_sub _\n                <| le_of_lt <| R.r_lt_n i n <| n₀_ge_Rn₀.trans hn\n        _ = (∑ i, C * a i * ((b i) ^ (p a b) * (1 + ε n)\n                  * ((n ^ (p a b) * (1 + (∑ u ∈ range n, g u / u ^ ((p a b) + 1)))\n                  - n ^ (p a b) * (∑ u ∈ Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))\n                  + g n := by\n              congr; ext; ring\n        _ = (∑ i, C * a i * ((b i) ^ (p a b) * (1 + ε n)\n                  * ((asympBound g a b n - sumTransform (p a b) g (r i n) n)))) + g n := by\n              simp_rw [asympBound_def', sumTransform_def]\n        _ ≥ (∑ i, C * a i * ((b i) ^ (p a b) * (1 + ε n)\n                  * ((asympBound g a b n - c₁ * g n)))) + g n := by\n              gcongr with i\n              · have := R.a_pos i\n                positivity\n              · have := R.b_pos i\n                positivity\n              · exact h_sumTransform n hn i\n        _ = (∑ i, C * (1 + ε n) * ((asympBound g a b n - c₁ * g n))\n                  * (a i * (b i) ^ (p a b))) + g n := by congr; ext; ring\n        _ = C * (1 + ε n) * (asympBound g a b n - c₁ * g n) + g n := by\n              rw [← Finset.mul_sum, R.sumCoeffsExp_p_eq_one, mul_one]\n        _ = C * (1 + ε n) * asympBound g a b n + (1 - C * c₁ * (1 + ε n)) * g n := by ring\n        _ ≥ C * (1 + ε n) * asympBound g a b n + 0 := by\n              gcongr\n              refine mul_nonneg ?_ g_pos\n              rw [sub_nonneg]\n              calc C * c₁ * (1 + ε n) ≤ C * c₁ * 2 := by\n                        gcongr\n                        refine one_add_smoothingFn_le_two ?_\n                        calc exp 1 ≤ ⌈exp 1⌉₊ := by exact Nat.le_ceil _\n                                 _ ≤ n := by exact_mod_cast h_exp n hn\n                    _ = C * (2 * c₁) := by ring\n                    _ ≤ (2 * c₁)⁻¹ * (2 * c₁) := by gcongr; exact min_le_left _ _\n                    _ = c₁⁻¹ * c₁ := by ring\n                    _ = 1 := inv_mul_cancel₀ (by positivity)\n        _ = C * ((1 + ε n) * asympBound g a b n) := by ring\n\n"}
{"name":"AkraBazziRecurrence.isBigO_asympBound","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Asymptotics.IsBigO Filter.atTop T (AkraBazziRecurrence.asympBound g a b)","decl":"/-- The **Akra-Bazzi theorem**: `T ∈ O(n^p (1 + ∑_u^n g(u) / u^{p+1}))` -/\ntheorem isBigO_asympBound : T =O[atTop] asympBound g a b := by\n  calc T =O[atTop] (fun n => (1 - ε n) * asympBound g a b n) := by\n              exact R.T_isBigO_smoothingFn_mul_asympBound\n         _ =O[atTop] (fun n => 1 * asympBound g a b n) := by\n              refine IsBigO.mul (isBigO_const_of_tendsto (y := 1) ?_ one_ne_zero)\n                (isBigO_refl _ _)\n              rw [← Function.comp_def (fun n => 1 - ε n) Nat.cast]\n              exact Tendsto.comp isEquivalent_one_sub_smoothingFn_one.tendsto_const\n                tendsto_natCast_atTop_atTop\n         _ = asympBound g a b := by simp\n\n"}
{"name":"AkraBazziRecurrence.isBigO_symm_asympBound","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Asymptotics.IsBigO Filter.atTop (AkraBazziRecurrence.asympBound g a b) T","decl":"/-- The **Akra-Bazzi theorem**: `T ∈ Ω(n^p (1 + ∑_u^n g(u) / u^{p+1}))` -/\ntheorem isBigO_symm_asympBound : asympBound g a b =O[atTop] T := by\n  calc asympBound g a b = (fun n => 1 * asympBound g a b n) := by simp\n                 _ ~[atTop] (fun n => (1 + ε n) * asympBound g a b n) := by\n                            refine IsEquivalent.mul (IsEquivalent.symm ?_) IsEquivalent.refl\n                            rw [Function.const_def, isEquivalent_const_iff_tendsto one_ne_zero,\n                              ← Function.comp_def (fun n => 1 + ε n) Nat.cast]\n                            exact Tendsto.comp isEquivalent_one_add_smoothingFn_one.tendsto_const\n                              tendsto_natCast_atTop_atTop\n                 _ =O[atTop] T := R.smoothingFn_mul_asympBound_isBigO_T\n\n"}
{"name":"AkraBazziRecurrence.isTheta_asympBound","module":"Mathlib.Computability.AkraBazzi.AkraBazzi","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nT : Nat → Real\ng : Real → Real\na b : α → Real\nr : α → Nat → Nat\ninst✝ : Nonempty α\nR : AkraBazziRecurrence T g a b r\n⊢ Asymptotics.IsTheta Filter.atTop T (AkraBazziRecurrence.asympBound g a b)","decl":"/-- The **Akra-Bazzi theorem**: `T ∈ Θ(n^p (1 + ∑_u^n g(u) / u^{p+1}))` -/\ntheorem isTheta_asympBound : T =Θ[atTop] asympBound g a b :=\n  ⟨R.isBigO_asympBound, R.isBigO_symm_asympBound⟩\n\n"}
