{"name":"WittVector.shift_coeff","module":"Mathlib.RingTheory.WittVector.Domain","initialProofState":"p : Nat\nR : Type u_1\nx : WittVector p R\nn k : Nat\nâŠ¢ Eq ((x.shift n).coeff k) (x.coeff (HAdd.hAdd n k))","decl":"theorem shift_coeff (x : ğ• R) (n k : â„•) : (x.shift n).coeff k = x.coeff (n + k) :=\n  rfl\n\n"}
{"name":"WittVector.verschiebung_shift","module":"Mathlib.RingTheory.WittVector.Domain","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœ : CommRing R\nx : WittVector p R\nk : Nat\nh : âˆ€ (i : Nat), LT.lt i (HAdd.hAdd k 1) â†’ Eq (x.coeff i) 0\nâŠ¢ Eq (WittVector.verschiebung (x.shift k.succ)) (x.shift k)","decl":"theorem verschiebung_shift (x : ğ• R) (k : â„•) (h : âˆ€ i < k + 1, x.coeff i = 0) :\n    verschiebung (x.shift k.succ) = x.shift k := by\n  ext âŸ¨jâŸ©\n  Â· rw [verschiebung_coeff_zero, shift_coeff, h]\n    apply Nat.lt_succ_self\n  Â· simp only [verschiebung_coeff_succ, shift]\n    congr 1\n    rw [Nat.add_succ, add_comm, Nat.add_succ, add_comm]\n\n"}
{"name":"WittVector.eq_iterate_verschiebung","module":"Mathlib.RingTheory.WittVector.Domain","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœ : CommRing R\nx : WittVector p R\nn : Nat\nh : âˆ€ (i : Nat), LT.lt i n â†’ Eq (x.coeff i) 0\nâŠ¢ Eq x (Nat.iterate (â‡‘WittVector.verschiebung) n (x.shift n))","decl":"theorem eq_iterate_verschiebung {x : ğ• R} {n : â„•} (h : âˆ€ i < n, x.coeff i = 0) :\n    x = verschiebung^[n] (x.shift n) := by\n  induction' n with k ih\n  Â· cases x; simp [shift]\n  Â· dsimp; rw [verschiebung_shift]\n    Â· exact ih fun i hi => h _ (hi.trans (Nat.lt_succ_self _))\n    Â· exact h\n\n"}
{"name":"WittVector.verschiebung_nonzero","module":"Mathlib.RingTheory.WittVector.Domain","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœ : CommRing R\nx : WittVector p R\nhx : Ne x 0\nâŠ¢ Exists fun n => Exists fun x' => And (Ne (x'.coeff 0) 0) (Eq x (Nat.iterate (â‡‘WittVector.verschiebung) n x'))","decl":"theorem verschiebung_nonzero {x : ğ• R} (hx : x â‰  0) :\n    âˆƒ n : â„•, âˆƒ x' : ğ• R, x'.coeff 0 â‰  0 âˆ§ x = verschiebung^[n] x' := by\n  classical\n  have hex : âˆƒ k : â„•, x.coeff k â‰  0 := by\n    by_contra! hall\n    apply hx\n    ext i\n    simp only [hall, zero_coeff]\n  let n := Nat.find hex\n  use n, x.shift n\n  refine âŸ¨Nat.find_spec hex, eq_iterate_verschiebung fun i hi => not_not.mp ?_âŸ©\n  exact Nat.find_min hex hi\n\n"}
{"name":"WittVector.instNoZeroDivisorsOfCharP","module":"Mathlib.RingTheory.WittVector.Domain","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CharP R p\ninstâœ : NoZeroDivisors R\nâŠ¢ NoZeroDivisors (WittVector p R)","decl":"instance [CharP R p] [NoZeroDivisors R] : NoZeroDivisors (ğ• R) :=\n  âŸ¨fun {x y} => by\n    contrapose!\n    rintro âŸ¨ha, hbâŸ©\n    rcases verschiebung_nonzero ha with âŸ¨na, wa, hwa0, rflâŸ©\n    rcases verschiebung_nonzero hb with âŸ¨nb, wb, hwb0, rflâŸ©\n    refine ne_of_apply_ne (fun x => x.coeff (na + nb)) ?_\n    dsimp only\n    rw [iterate_verschiebung_mul_coeff, zero_coeff]\n    exact mul_ne_zero (pow_ne_zero _ hwa0) (pow_ne_zero _ hwb0)âŸ©\n\n"}
{"name":"WittVector.instIsDomain","module":"Mathlib.RingTheory.WittVector.Domain","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ² : CommRing R\ninstâœÂ¹ : CharP R p\ninstâœ : IsDomain R\nâŠ¢ IsDomain (WittVector p R)","decl":"instance instIsDomain [CharP R p] [IsDomain R] : IsDomain (ğ• R) :=\n  NoZeroDivisors.to_isDomain _\n\n"}
