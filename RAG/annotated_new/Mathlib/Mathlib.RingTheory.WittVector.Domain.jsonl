{"name":"WittVector.shift_coeff","module":"Mathlib.RingTheory.WittVector.Domain","initialProofState":"p : Nat\nR : Type u_1\nx : WittVector p R\nn k : Nat\n⊢ Eq ((x.shift n).coeff k) (x.coeff (HAdd.hAdd n k))","decl":"theorem shift_coeff (x : 𝕎 R) (n k : ℕ) : (x.shift n).coeff k = x.coeff (n + k) :=\n  rfl\n\n"}
{"name":"WittVector.verschiebung_shift","module":"Mathlib.RingTheory.WittVector.Domain","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst✝ : CommRing R\nx : WittVector p R\nk : Nat\nh : ∀ (i : Nat), LT.lt i (HAdd.hAdd k 1) → Eq (x.coeff i) 0\n⊢ Eq (WittVector.verschiebung (x.shift k.succ)) (x.shift k)","decl":"theorem verschiebung_shift (x : 𝕎 R) (k : ℕ) (h : ∀ i < k + 1, x.coeff i = 0) :\n    verschiebung (x.shift k.succ) = x.shift k := by\n  ext ⟨j⟩\n  · rw [verschiebung_coeff_zero, shift_coeff, h]\n    apply Nat.lt_succ_self\n  · simp only [verschiebung_coeff_succ, shift]\n    congr 1\n    rw [Nat.add_succ, add_comm, Nat.add_succ, add_comm]\n\n"}
{"name":"WittVector.eq_iterate_verschiebung","module":"Mathlib.RingTheory.WittVector.Domain","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst✝ : CommRing R\nx : WittVector p R\nn : Nat\nh : ∀ (i : Nat), LT.lt i n → Eq (x.coeff i) 0\n⊢ Eq x (Nat.iterate (⇑WittVector.verschiebung) n (x.shift n))","decl":"theorem eq_iterate_verschiebung {x : 𝕎 R} {n : ℕ} (h : ∀ i < n, x.coeff i = 0) :\n    x = verschiebung^[n] (x.shift n) := by\n  induction' n with k ih\n  · cases x; simp [shift]\n  · dsimp; rw [verschiebung_shift]\n    · exact ih fun i hi => h _ (hi.trans (Nat.lt_succ_self _))\n    · exact h\n\n"}
{"name":"WittVector.verschiebung_nonzero","module":"Mathlib.RingTheory.WittVector.Domain","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst✝ : CommRing R\nx : WittVector p R\nhx : Ne x 0\n⊢ Exists fun n => Exists fun x' => And (Ne (x'.coeff 0) 0) (Eq x (Nat.iterate (⇑WittVector.verschiebung) n x'))","decl":"theorem verschiebung_nonzero {x : 𝕎 R} (hx : x ≠ 0) :\n    ∃ n : ℕ, ∃ x' : 𝕎 R, x'.coeff 0 ≠ 0 ∧ x = verschiebung^[n] x' := by\n  classical\n  have hex : ∃ k : ℕ, x.coeff k ≠ 0 := by\n    by_contra! hall\n    apply hx\n    ext i\n    simp only [hall, zero_coeff]\n  let n := Nat.find hex\n  use n, x.shift n\n  refine ⟨Nat.find_spec hex, eq_iterate_verschiebung fun i hi => not_not.mp ?_⟩\n  exact Nat.find_min hex hi\n\n"}
{"name":"WittVector.instNoZeroDivisorsOfCharP","module":"Mathlib.RingTheory.WittVector.Domain","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst✝² : CommRing R\ninst✝¹ : CharP R p\ninst✝ : NoZeroDivisors R\n⊢ NoZeroDivisors (WittVector p R)","decl":"instance [CharP R p] [NoZeroDivisors R] : NoZeroDivisors (𝕎 R) :=\n  ⟨fun {x y} => by\n    contrapose!\n    rintro ⟨ha, hb⟩\n    rcases verschiebung_nonzero ha with ⟨na, wa, hwa0, rfl⟩\n    rcases verschiebung_nonzero hb with ⟨nb, wb, hwb0, rfl⟩\n    refine ne_of_apply_ne (fun x => x.coeff (na + nb)) ?_\n    dsimp only\n    rw [iterate_verschiebung_mul_coeff, zero_coeff]\n    exact mul_ne_zero (pow_ne_zero _ hwa0) (pow_ne_zero _ hwb0)⟩\n\n"}
{"name":"WittVector.instIsDomain","module":"Mathlib.RingTheory.WittVector.Domain","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst✝² : CommRing R\ninst✝¹ : CharP R p\ninst✝ : IsDomain R\n⊢ IsDomain (WittVector p R)","decl":"instance instIsDomain [CharP R p] [IsDomain R] : IsDomain (𝕎 R) :=\n  NoZeroDivisors.to_isDomain _\n\n"}
