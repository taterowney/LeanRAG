{"name":"Finset.nonempty_Icc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Iff (Finset.Icc a b).Nonempty (LE.le a b)","decl":"@[simp]\ntheorem nonempty_Icc : (Icc a b).Nonempty ↔ a ≤ b := by\n  rw [← coe_nonempty, coe_Icc, Set.nonempty_Icc]\n\n"}
{"name":"Finset.Aesop.nonempty_Icc_of_le","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\na✝ : LE.le a b\n⊢ (Finset.Icc a b).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nalias ⟨_, Aesop.nonempty_Icc_of_le⟩ := nonempty_Icc\n\n"}
{"name":"Finset.nonempty_Ico","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Iff (Finset.Ico a b).Nonempty (LT.lt a b)","decl":"@[simp]\ntheorem nonempty_Ico : (Ico a b).Nonempty ↔ a < b := by\n  rw [← coe_nonempty, coe_Ico, Set.nonempty_Ico]\n\n"}
{"name":"Finset.Aesop.nonempty_Ico_of_lt","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\na✝ : LT.lt a b\n⊢ (Finset.Ico a b).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nalias ⟨_, Aesop.nonempty_Ico_of_lt⟩ := nonempty_Ico\n\n"}
{"name":"Finset.nonempty_Ioc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Iff (Finset.Ioc a b).Nonempty (LT.lt a b)","decl":"@[simp]\ntheorem nonempty_Ioc : (Ioc a b).Nonempty ↔ a < b := by\n  rw [← coe_nonempty, coe_Ioc, Set.nonempty_Ioc]\n\n"}
{"name":"Finset.Aesop.nonempty_Ioc_of_lt","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\na✝ : LT.lt a b\n⊢ (Finset.Ioc a b).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nalias ⟨_, Aesop.nonempty_Ioc_of_lt⟩ := nonempty_Ioc\n\n-- TODO: This is nonsense. A locally finite order is never densely ordered\n"}
{"name":"Finset.nonempty_Ioo","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DenselyOrdered α\n⊢ Iff (Finset.Ioo a b).Nonempty (LT.lt a b)","decl":"@[simp]\ntheorem nonempty_Ioo [DenselyOrdered α] : (Ioo a b).Nonempty ↔ a < b := by\n  rw [← coe_nonempty, coe_Ioo, Set.nonempty_Ioo]\n\n"}
{"name":"Finset.Icc_eq_empty_iff","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Iff (Eq (Finset.Icc a b) EmptyCollection.emptyCollection) (Not (LE.le a b))","decl":"@[simp]\ntheorem Icc_eq_empty_iff : Icc a b = ∅ ↔ ¬a ≤ b := by\n  rw [← coe_eq_empty, coe_Icc, Set.Icc_eq_empty_iff]\n\n"}
{"name":"Finset.Ico_eq_empty_iff","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Iff (Eq (Finset.Ico a b) EmptyCollection.emptyCollection) (Not (LT.lt a b))","decl":"@[simp]\ntheorem Ico_eq_empty_iff : Ico a b = ∅ ↔ ¬a < b := by\n  rw [← coe_eq_empty, coe_Ico, Set.Ico_eq_empty_iff]\n\n"}
{"name":"Finset.Ioc_eq_empty_iff","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Iff (Eq (Finset.Ioc a b) EmptyCollection.emptyCollection) (Not (LT.lt a b))","decl":"@[simp]\ntheorem Ioc_eq_empty_iff : Ioc a b = ∅ ↔ ¬a < b := by\n  rw [← coe_eq_empty, coe_Ioc, Set.Ioc_eq_empty_iff]\n\n-- TODO: This is nonsense. A locally finite order is never densely ordered\n"}
{"name":"Finset.Ioo_eq_empty_iff","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DenselyOrdered α\n⊢ Iff (Eq (Finset.Ioo a b) EmptyCollection.emptyCollection) (Not (LT.lt a b))","decl":"@[simp]\ntheorem Ioo_eq_empty_iff [DenselyOrdered α] : Ioo a b = ∅ ↔ ¬a < b := by\n  rw [← coe_eq_empty, coe_Ioo, Set.Ioo_eq_empty_iff]\n\n"}
{"name":"Finset.Icc_eq_empty","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\na✝ : Not (LE.le a b)\n⊢ Eq (Finset.Icc a b) EmptyCollection.emptyCollection","decl":"alias ⟨_, Icc_eq_empty⟩ := Icc_eq_empty_iff\n\n"}
{"name":"Finset.Ico_eq_empty","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\na✝ : Not (LT.lt a b)\n⊢ Eq (Finset.Ico a b) EmptyCollection.emptyCollection","decl":"alias ⟨_, Ico_eq_empty⟩ := Ico_eq_empty_iff\n\n"}
{"name":"Finset.Ioc_eq_empty","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\na✝ : Not (LT.lt a b)\n⊢ Eq (Finset.Ioc a b) EmptyCollection.emptyCollection","decl":"alias ⟨_, Ioc_eq_empty⟩ := Ioc_eq_empty_iff\n\n"}
{"name":"Finset.Ioo_eq_empty","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : Not (LT.lt a b)\n⊢ Eq (Finset.Ioo a b) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ioo_eq_empty (h : ¬a < b) : Ioo a b = ∅ :=\n  eq_empty_iff_forall_not_mem.2 fun _ hx => h ((mem_Ioo.1 hx).1.trans (mem_Ioo.1 hx).2)\n\n"}
{"name":"Finset.Icc_eq_empty_of_lt","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LT.lt b a\n⊢ Eq (Finset.Icc a b) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Icc_eq_empty_of_lt (h : b < a) : Icc a b = ∅ :=\n  Icc_eq_empty h.not_le\n\n"}
{"name":"Finset.Ico_eq_empty_of_le","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LE.le b a\n⊢ Eq (Finset.Ico a b) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ico_eq_empty_of_le (h : b ≤ a) : Ico a b = ∅ :=\n  Ico_eq_empty h.not_lt\n\n"}
{"name":"Finset.Ioc_eq_empty_of_le","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LE.le b a\n⊢ Eq (Finset.Ioc a b) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ioc_eq_empty_of_le (h : b ≤ a) : Ioc a b = ∅ :=\n  Ioc_eq_empty h.not_lt\n\n"}
{"name":"Finset.Ioo_eq_empty_of_le","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LE.le b a\n⊢ Eq (Finset.Ioo a b) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ioo_eq_empty_of_le (h : b ≤ a) : Ioo a b = ∅ :=\n  Ioo_eq_empty h.not_lt\n\n"}
{"name":"Finset.left_mem_Icc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Iff (Membership.mem (Finset.Icc a b) a) (LE.le a b)","decl":"theorem left_mem_Icc : a ∈ Icc a b ↔ a ≤ b := by simp only [mem_Icc, true_and, le_rfl]\n\n"}
{"name":"Finset.left_mem_Ico","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Iff (Membership.mem (Finset.Ico a b) a) (LT.lt a b)","decl":"theorem left_mem_Ico : a ∈ Ico a b ↔ a < b := by simp only [mem_Ico, true_and, le_refl]\n\n"}
{"name":"Finset.right_mem_Icc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Iff (Membership.mem (Finset.Icc a b) b) (LE.le a b)","decl":"theorem right_mem_Icc : b ∈ Icc a b ↔ a ≤ b := by simp only [mem_Icc, and_true, le_rfl]\n\n"}
{"name":"Finset.right_mem_Ioc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Iff (Membership.mem (Finset.Ioc a b) b) (LT.lt a b)","decl":"theorem right_mem_Ioc : b ∈ Ioc a b ↔ a < b := by simp only [mem_Ioc, and_true, le_rfl]\n\n"}
{"name":"Finset.left_not_mem_Ioc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Not (Membership.mem (Finset.Ioc a b) a)","decl":"theorem left_not_mem_Ioc : a ∉ Ioc a b := fun h => lt_irrefl _ (mem_Ioc.1 h).1\n\n"}
{"name":"Finset.left_not_mem_Ioo","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Not (Membership.mem (Finset.Ioo a b) a)","decl":"theorem left_not_mem_Ioo : a ∉ Ioo a b := fun h => lt_irrefl _ (mem_Ioo.1 h).1\n\n"}
{"name":"Finset.right_not_mem_Ico","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Not (Membership.mem (Finset.Ico a b) b)","decl":"theorem right_not_mem_Ico : b ∉ Ico a b := fun h => lt_irrefl _ (mem_Ico.1 h).2\n\n"}
{"name":"Finset.right_not_mem_Ioo","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Not (Membership.mem (Finset.Ioo a b) b)","decl":"theorem right_not_mem_Ioo : b ∉ Ioo a b := fun h => lt_irrefl _ (mem_Ioo.1 h).2\n\n"}
{"name":"Finset.Icc_subset_Icc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nha : LE.le a₂ a₁\nhb : LE.le b₁ b₂\n⊢ HasSubset.Subset (Finset.Icc a₁ b₁) (Finset.Icc a₂ b₂)","decl":"theorem Icc_subset_Icc (ha : a₂ ≤ a₁) (hb : b₁ ≤ b₂) : Icc a₁ b₁ ⊆ Icc a₂ b₂ := by\n  simpa [← coe_subset] using Set.Icc_subset_Icc ha hb\n\n"}
{"name":"Finset.Ico_subset_Ico","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nha : LE.le a₂ a₁\nhb : LE.le b₁ b₂\n⊢ HasSubset.Subset (Finset.Ico a₁ b₁) (Finset.Ico a₂ b₂)","decl":"theorem Ico_subset_Ico (ha : a₂ ≤ a₁) (hb : b₁ ≤ b₂) : Ico a₁ b₁ ⊆ Ico a₂ b₂ := by\n  simpa [← coe_subset] using Set.Ico_subset_Ico ha hb\n\n"}
{"name":"Finset.Ioc_subset_Ioc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nha : LE.le a₂ a₁\nhb : LE.le b₁ b₂\n⊢ HasSubset.Subset (Finset.Ioc a₁ b₁) (Finset.Ioc a₂ b₂)","decl":"theorem Ioc_subset_Ioc (ha : a₂ ≤ a₁) (hb : b₁ ≤ b₂) : Ioc a₁ b₁ ⊆ Ioc a₂ b₂ := by\n  simpa [← coe_subset] using Set.Ioc_subset_Ioc ha hb\n\n"}
{"name":"Finset.Ioo_subset_Ioo","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nha : LE.le a₂ a₁\nhb : LE.le b₁ b₂\n⊢ HasSubset.Subset (Finset.Ioo a₁ b₁) (Finset.Ioo a₂ b₂)","decl":"theorem Ioo_subset_Ioo (ha : a₂ ≤ a₁) (hb : b₁ ≤ b₂) : Ioo a₁ b₁ ⊆ Ioo a₂ b₂ := by\n  simpa [← coe_subset] using Set.Ioo_subset_Ioo ha hb\n\n"}
{"name":"Finset.Icc_subset_Icc_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LE.le a₁ a₂\n⊢ HasSubset.Subset (Finset.Icc a₂ b) (Finset.Icc a₁ b)","decl":"theorem Icc_subset_Icc_left (h : a₁ ≤ a₂) : Icc a₂ b ⊆ Icc a₁ b :=\n  Icc_subset_Icc h le_rfl\n\n"}
{"name":"Finset.Ico_subset_Ico_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LE.le a₁ a₂\n⊢ HasSubset.Subset (Finset.Ico a₂ b) (Finset.Ico a₁ b)","decl":"theorem Ico_subset_Ico_left (h : a₁ ≤ a₂) : Ico a₂ b ⊆ Ico a₁ b :=\n  Ico_subset_Ico h le_rfl\n\n"}
{"name":"Finset.Ioc_subset_Ioc_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LE.le a₁ a₂\n⊢ HasSubset.Subset (Finset.Ioc a₂ b) (Finset.Ioc a₁ b)","decl":"theorem Ioc_subset_Ioc_left (h : a₁ ≤ a₂) : Ioc a₂ b ⊆ Ioc a₁ b :=\n  Ioc_subset_Ioc h le_rfl\n\n"}
{"name":"Finset.Ioo_subset_Ioo_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LE.le a₁ a₂\n⊢ HasSubset.Subset (Finset.Ioo a₂ b) (Finset.Ioo a₁ b)","decl":"theorem Ioo_subset_Ioo_left (h : a₁ ≤ a₂) : Ioo a₂ b ⊆ Ioo a₁ b :=\n  Ioo_subset_Ioo h le_rfl\n\n"}
{"name":"Finset.Icc_subset_Icc_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LE.le b₁ b₂\n⊢ HasSubset.Subset (Finset.Icc a b₁) (Finset.Icc a b₂)","decl":"theorem Icc_subset_Icc_right (h : b₁ ≤ b₂) : Icc a b₁ ⊆ Icc a b₂ :=\n  Icc_subset_Icc le_rfl h\n\n"}
{"name":"Finset.Ico_subset_Ico_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LE.le b₁ b₂\n⊢ HasSubset.Subset (Finset.Ico a b₁) (Finset.Ico a b₂)","decl":"theorem Ico_subset_Ico_right (h : b₁ ≤ b₂) : Ico a b₁ ⊆ Ico a b₂ :=\n  Ico_subset_Ico le_rfl h\n\n"}
{"name":"Finset.Ioc_subset_Ioc_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LE.le b₁ b₂\n⊢ HasSubset.Subset (Finset.Ioc a b₁) (Finset.Ioc a b₂)","decl":"theorem Ioc_subset_Ioc_right (h : b₁ ≤ b₂) : Ioc a b₁ ⊆ Ioc a b₂ :=\n  Ioc_subset_Ioc le_rfl h\n\n"}
{"name":"Finset.Ioo_subset_Ioo_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LE.le b₁ b₂\n⊢ HasSubset.Subset (Finset.Ioo a b₁) (Finset.Ioo a b₂)","decl":"theorem Ioo_subset_Ioo_right (h : b₁ ≤ b₂) : Ioo a b₁ ⊆ Ioo a b₂ :=\n  Ioo_subset_Ioo le_rfl h\n\n"}
{"name":"Finset.Ico_subset_Ioo_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LT.lt a₁ a₂\n⊢ HasSubset.Subset (Finset.Ico a₂ b) (Finset.Ioo a₁ b)","decl":"theorem Ico_subset_Ioo_left (h : a₁ < a₂) : Ico a₂ b ⊆ Ioo a₁ b := by\n  rw [← coe_subset, coe_Ico, coe_Ioo]\n  exact Set.Ico_subset_Ioo_left h\n\n"}
{"name":"Finset.Ioc_subset_Ioo_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LT.lt b₁ b₂\n⊢ HasSubset.Subset (Finset.Ioc a b₁) (Finset.Ioo a b₂)","decl":"theorem Ioc_subset_Ioo_right (h : b₁ < b₂) : Ioc a b₁ ⊆ Ioo a b₂ := by\n  rw [← coe_subset, coe_Ioc, coe_Ioo]\n  exact Set.Ioc_subset_Ioo_right h\n\n"}
{"name":"Finset.Icc_subset_Ico_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh : LT.lt b₁ b₂\n⊢ HasSubset.Subset (Finset.Icc a b₁) (Finset.Ico a b₂)","decl":"theorem Icc_subset_Ico_right (h : b₁ < b₂) : Icc a b₁ ⊆ Ico a b₂ := by\n  rw [← coe_subset, coe_Icc, coe_Ico]\n  exact Set.Icc_subset_Ico_right h\n\n"}
{"name":"Finset.Ioo_subset_Ico_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ioo a b) (Finset.Ico a b)","decl":"theorem Ioo_subset_Ico_self : Ioo a b ⊆ Ico a b := by\n  rw [← coe_subset, coe_Ioo, coe_Ico]\n  exact Set.Ioo_subset_Ico_self\n\n"}
{"name":"Finset.Ioo_subset_Ioc_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ioo a b) (Finset.Ioc a b)","decl":"theorem Ioo_subset_Ioc_self : Ioo a b ⊆ Ioc a b := by\n  rw [← coe_subset, coe_Ioo, coe_Ioc]\n  exact Set.Ioo_subset_Ioc_self\n\n"}
{"name":"Finset.Ico_subset_Icc_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ico a b) (Finset.Icc a b)","decl":"theorem Ico_subset_Icc_self : Ico a b ⊆ Icc a b := by\n  rw [← coe_subset, coe_Ico, coe_Icc]\n  exact Set.Ico_subset_Icc_self\n\n"}
{"name":"Finset.Ioc_subset_Icc_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ioc a b) (Finset.Icc a b)","decl":"theorem Ioc_subset_Icc_self : Ioc a b ⊆ Icc a b := by\n  rw [← coe_subset, coe_Ioc, coe_Icc]\n  exact Set.Ioc_subset_Icc_self\n\n"}
{"name":"Finset.Ioo_subset_Icc_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ioo a b) (Finset.Icc a b)","decl":"theorem Ioo_subset_Icc_self : Ioo a b ⊆ Icc a b :=\n  Ioo_subset_Ico_self.trans Ico_subset_Icc_self\n\n"}
{"name":"Finset.Icc_subset_Icc_iff","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh₁ : LE.le a₁ b₁\n⊢ Iff (HasSubset.Subset (Finset.Icc a₁ b₁) (Finset.Icc a₂ b₂)) (And (LE.le a₂ a₁) (LE.le b₁ b₂))","decl":"theorem Icc_subset_Icc_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Icc a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ ≤ b₂ := by\n  rw [← coe_subset, coe_Icc, coe_Icc, Set.Icc_subset_Icc_iff h₁]\n\n"}
{"name":"Finset.Icc_subset_Ioo_iff","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh₁ : LE.le a₁ b₁\n⊢ Iff (HasSubset.Subset (Finset.Icc a₁ b₁) (Finset.Ioo a₂ b₂)) (And (LT.lt a₂ a₁) (LT.lt b₁ b₂))","decl":"theorem Icc_subset_Ioo_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ioo a₂ b₂ ↔ a₂ < a₁ ∧ b₁ < b₂ := by\n  rw [← coe_subset, coe_Icc, coe_Ioo, Set.Icc_subset_Ioo_iff h₁]\n\n"}
{"name":"Finset.Icc_subset_Ico_iff","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh₁ : LE.le a₁ b₁\n⊢ Iff (HasSubset.Subset (Finset.Icc a₁ b₁) (Finset.Ico a₂ b₂)) (And (LE.le a₂ a₁) (LT.lt b₁ b₂))","decl":"theorem Icc_subset_Ico_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ico a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ < b₂ := by\n  rw [← coe_subset, coe_Icc, coe_Ico, Set.Icc_subset_Ico_iff h₁]\n\n"}
{"name":"Finset.Icc_subset_Ioc_iff","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nh₁ : LE.le a₁ b₁\n⊢ Iff (HasSubset.Subset (Finset.Icc a₁ b₁) (Finset.Ioc a₂ b₂)) (And (LT.lt a₂ a₁) (LE.le b₁ b₂))","decl":"theorem Icc_subset_Ioc_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ioc a₂ b₂ ↔ a₂ < a₁ ∧ b₁ ≤ b₂ :=\n  (Icc_subset_Ico_iff h₁.dual).trans and_comm\n\n--TODO: `Ico_subset_Ioo_iff`, `Ioc_subset_Ioo_iff`\n"}
{"name":"Finset.Icc_ssubset_Icc_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nhI : LE.le a₂ b₂\nha : LT.lt a₂ a₁\nhb : LE.le b₁ b₂\n⊢ HasSSubset.SSubset (Finset.Icc a₁ b₁) (Finset.Icc a₂ b₂)","decl":"theorem Icc_ssubset_Icc_left (hI : a₂ ≤ b₂) (ha : a₂ < a₁) (hb : b₁ ≤ b₂) :\n    Icc a₁ b₁ ⊂ Icc a₂ b₂ := by\n  rw [← coe_ssubset, coe_Icc, coe_Icc]\n  exact Set.Icc_ssubset_Icc_left hI ha hb\n\n"}
{"name":"Finset.Icc_ssubset_Icc_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na₁ a₂ b₁ b₂ : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nhI : LE.le a₂ b₂\nha : LE.le a₂ a₁\nhb : LT.lt b₁ b₂\n⊢ HasSSubset.SSubset (Finset.Icc a₁ b₁) (Finset.Icc a₂ b₂)","decl":"theorem Icc_ssubset_Icc_right (hI : a₂ ≤ b₂) (ha : a₂ ≤ a₁) (hb : b₁ < b₂) :\n    Icc a₁ b₁ ⊂ Icc a₂ b₂ := by\n  rw [← coe_ssubset, coe_Icc, coe_Icc]\n  exact Set.Icc_ssubset_Icc_right hI ha hb\n\n"}
{"name":"Finset.Ico_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Eq (Finset.Ico a a) EmptyCollection.emptyCollection","decl":"theorem Ico_self : Ico a a = ∅ :=\n  Ico_eq_empty <| lt_irrefl _\n\n"}
{"name":"Finset.Ioc_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Eq (Finset.Ioc a a) EmptyCollection.emptyCollection","decl":"theorem Ioc_self : Ioc a a = ∅ :=\n  Ioc_eq_empty <| lt_irrefl _\n\n"}
{"name":"Finset.Ioo_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\n⊢ Eq (Finset.Ioo a a) EmptyCollection.emptyCollection","decl":"theorem Ioo_self : Ioo a a = ∅ :=\n  Ioo_eq_empty <| lt_irrefl _\n\n"}
{"name":"Finset.Ico_filter_lt_of_le_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b c : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidablePred fun x => LT.lt x c\nhca : LE.le c a\n⊢ Eq (Finset.filter (fun x => LT.lt x c) (Finset.Ico a b)) EmptyCollection.emptyCollection","decl":"theorem Ico_filter_lt_of_le_left [DecidablePred (· < c)] (hca : c ≤ a) :\n    {x ∈ Ico a b | x < c} = ∅ :=\n  filter_false_of_mem fun _ hx => (hca.trans (mem_Ico.1 hx).1).not_lt\n\n"}
{"name":"Finset.Ico_filter_lt_of_right_le","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b c : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidablePred fun x => LT.lt x c\nhbc : LE.le b c\n⊢ Eq (Finset.filter (fun x => LT.lt x c) (Finset.Ico a b)) (Finset.Ico a b)","decl":"theorem Ico_filter_lt_of_right_le [DecidablePred (· < c)] (hbc : b ≤ c) :\n    {x ∈ Ico a b | x < c} = Ico a b :=\n  filter_true_of_mem fun _ hx => (mem_Ico.1 hx).2.trans_le hbc\n\n"}
{"name":"Finset.Ico_filter_lt_of_le_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b c : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidablePred fun x => LT.lt x c\nhcb : LE.le c b\n⊢ Eq (Finset.filter (fun x => LT.lt x c) (Finset.Ico a b)) (Finset.Ico a c)","decl":"theorem Ico_filter_lt_of_le_right [DecidablePred (· < c)] (hcb : c ≤ b) :\n    {x ∈ Ico a b | x < c} = Ico a c := by\n  ext x\n  rw [mem_filter, mem_Ico, mem_Ico, and_right_comm]\n  exact and_iff_left_of_imp fun h => h.2.trans_le hcb\n\n"}
{"name":"Finset.Ico_filter_le_of_le_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\na b c : α\ninst✝ : DecidablePred fun x => LE.le c x\nhca : LE.le c a\n⊢ Eq (Finset.filter (fun x => LE.le c x) (Finset.Ico a b)) (Finset.Ico a b)","decl":"theorem Ico_filter_le_of_le_left {a b c : α} [DecidablePred (c ≤ ·)] (hca : c ≤ a) :\n    {x ∈ Ico a b | c ≤ x} = Ico a b :=\n  filter_true_of_mem fun _ hx => hca.trans (mem_Ico.1 hx).1\n\n"}
{"name":"Finset.Ico_filter_le_of_right_le","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\na b : α\ninst✝ : DecidablePred fun x => LE.le b x\n⊢ Eq (Finset.filter (fun x => LE.le b x) (Finset.Ico a b)) EmptyCollection.emptyCollection","decl":"theorem Ico_filter_le_of_right_le {a b : α} [DecidablePred (b ≤ ·)] :\n    {x ∈ Ico a b | b ≤ x} = ∅ :=\n  filter_false_of_mem fun _ hx => (mem_Ico.1 hx).2.not_le\n\n"}
{"name":"Finset.Ico_filter_le_of_left_le","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\na b c : α\ninst✝ : DecidablePred fun x => LE.le c x\nhac : LE.le a c\n⊢ Eq (Finset.filter (fun x => LE.le c x) (Finset.Ico a b)) (Finset.Ico c b)","decl":"theorem Ico_filter_le_of_left_le {a b c : α} [DecidablePred (c ≤ ·)] (hac : a ≤ c) :\n    {x ∈ Ico a b | c ≤ x} = Ico c b := by\n  ext x\n  rw [mem_filter, mem_Ico, mem_Ico, and_comm, and_left_comm]\n  exact and_iff_right_of_imp fun h => hac.trans h.1\n\n"}
{"name":"Finset.Icc_filter_lt_of_lt_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\na b c : α\ninst✝ : DecidablePred fun x => LT.lt x c\nh : LT.lt b c\n⊢ Eq (Finset.filter (fun x => LT.lt x c) (Finset.Icc a b)) (Finset.Icc a b)","decl":"theorem Icc_filter_lt_of_lt_right {a b c : α} [DecidablePred (· < c)] (h : b < c) :\n    {x ∈ Icc a b | x < c} = Icc a b :=\n  filter_true_of_mem fun _ hx => lt_of_le_of_lt (mem_Icc.1 hx).2 h\n\n"}
{"name":"Finset.Ioc_filter_lt_of_lt_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\na b c : α\ninst✝ : DecidablePred fun x => LT.lt x c\nh : LT.lt b c\n⊢ Eq (Finset.filter (fun x => LT.lt x c) (Finset.Ioc a b)) (Finset.Ioc a b)","decl":"theorem Ioc_filter_lt_of_lt_right {a b c : α} [DecidablePred (· < c)] (h : b < c) :\n    {x ∈ Ioc a b | x < c} = Ioc a b :=\n  filter_true_of_mem fun _ hx => lt_of_le_of_lt (mem_Ioc.1 hx).2 h\n\n"}
{"name":"Finset.Iic_filter_lt_of_lt_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_3\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderBot α\na c : α\ninst✝ : DecidablePred fun x => LT.lt x c\nh : LT.lt a c\n⊢ Eq (Finset.filter (fun x => LT.lt x c) (Finset.Iic a)) (Finset.Iic a)","decl":"theorem Iic_filter_lt_of_lt_right {α} [Preorder α] [LocallyFiniteOrderBot α] {a c : α}\n    [DecidablePred (· < c)] (h : a < c) : {x ∈ Iic a | x < c} = Iic a :=\n  filter_true_of_mem fun _ hx => lt_of_le_of_lt (mem_Iic.1 hx) h\n\n"}
{"name":"Finset.filter_lt_lt_eq_Ioo","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝³ : Preorder α\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : Fintype α\ninst✝ : DecidablePred fun j => And (LT.lt a j) (LT.lt j b)\n⊢ Eq (Finset.filter (fun j => And (LT.lt a j) (LT.lt j b)) Finset.univ) (Finset.Ioo a b)","decl":"theorem filter_lt_lt_eq_Ioo [DecidablePred fun j => a < j ∧ j < b] :\n    ({j | a < j ∧ j < b} : Finset _) = Ioo a b := by ext; simp\n\n"}
{"name":"Finset.filter_lt_le_eq_Ioc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝³ : Preorder α\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : Fintype α\ninst✝ : DecidablePred fun j => And (LT.lt a j) (LE.le j b)\n⊢ Eq (Finset.filter (fun j => And (LT.lt a j) (LE.le j b)) Finset.univ) (Finset.Ioc a b)","decl":"theorem filter_lt_le_eq_Ioc [DecidablePred fun j => a < j ∧ j ≤ b] :\n    ({j | a < j ∧ j ≤ b} : Finset _) = Ioc a b := by ext; simp\n\n"}
{"name":"Finset.filter_le_lt_eq_Ico","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝³ : Preorder α\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : Fintype α\ninst✝ : DecidablePred fun j => And (LE.le a j) (LT.lt j b)\n⊢ Eq (Finset.filter (fun j => And (LE.le a j) (LT.lt j b)) Finset.univ) (Finset.Ico a b)","decl":"theorem filter_le_lt_eq_Ico [DecidablePred fun j => a ≤ j ∧ j < b] :\n    ({j | a ≤ j ∧ j < b} : Finset _) = Ico a b := by ext; simp\n\n"}
{"name":"Finset.filter_le_le_eq_Icc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝³ : Preorder α\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : Fintype α\ninst✝ : DecidablePred fun j => And (LE.le a j) (LE.le j b)\n⊢ Eq (Finset.filter (fun j => And (LE.le a j) (LE.le j b)) Finset.univ) (Finset.Icc a b)","decl":"theorem filter_le_le_eq_Icc [DecidablePred fun j => a ≤ j ∧ j ≤ b] :\n    ({j | a ≤ j ∧ j ≤ b} : Finset _) = Icc a b := by ext; simp\n\n"}
{"name":"Finset.Ioi_eq_empty","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderTop α\n⊢ Iff (Eq (Finset.Ioi a) EmptyCollection.emptyCollection) (IsMax a)","decl":"@[simp]\ntheorem Ioi_eq_empty : Ioi a = ∅ ↔ IsMax a := by\n  rw [← coe_eq_empty, coe_Ioi, Set.Ioi_eq_empty_iff]\n\n"}
{"name":"Finset.Ioi_top","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderTop α\ninst✝ : OrderTop α\n⊢ Eq (Finset.Ioi Top.top) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ioi_top [OrderTop α] : Ioi (⊤ : α) = ∅ := Ioi_eq_empty.mpr isMax_top\n\n"}
{"name":"Finset.Ici_bot","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : LocallyFiniteOrderTop α\ninst✝¹ : OrderBot α\ninst✝ : Fintype α\n⊢ Eq (Finset.Ici Bot.bot) Finset.univ","decl":"@[simp]\ntheorem Ici_bot [OrderBot α] [Fintype α] : Ici (⊥ : α) = univ := by\n  ext a; simp only [mem_Ici, bot_le, mem_univ]\n\n"}
{"name":"Finset.nonempty_Ici","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderTop α\n⊢ (Finset.Ici a).Nonempty","decl":"@[simp, aesop safe apply (rule_sets := [finsetNonempty])]\nlemma nonempty_Ici : (Ici a).Nonempty := ⟨a, mem_Ici.2 le_rfl⟩\n"}
{"name":"Finset.nonempty_Ioi","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderTop α\n⊢ Iff (Finset.Ioi a).Nonempty (Not (IsMax a))","decl":"@[simp]\nlemma nonempty_Ioi : (Ioi a).Nonempty ↔ ¬ IsMax a := by simp [Finset.Nonempty]\n\n"}
{"name":"Finset.Aesop.nonempty_Ioi_of_not_isMax","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderTop α\na✝ : Not (IsMax a)\n⊢ (Finset.Ioi a).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nalias ⟨_, Aesop.nonempty_Ioi_of_not_isMax⟩ := nonempty_Ioi\n\n"}
{"name":"Finset.Ici_subset_Ici","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderTop α\n⊢ Iff (HasSubset.Subset (Finset.Ici a) (Finset.Ici b)) (LE.le b a)","decl":"theorem Ici_subset_Ici : Ici a ⊆ Ici b ↔ b ≤ a := by\n  simpa [← coe_subset] using Set.Ici_subset_Ici\n\n"}
{"name":"Finset.Ioi_subset_Ioi","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderTop α\nh : LE.le a b\n⊢ HasSubset.Subset (Finset.Ioi b) (Finset.Ioi a)","decl":"theorem Ioi_subset_Ioi (h : a ≤ b) : Ioi b ⊆ Ioi a := by\n  simpa [← coe_subset] using Set.Ioi_subset_Ioi h\n\n"}
{"name":"Finset.Icc_subset_Ici_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderTop α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Icc a b) (Finset.Ici a)","decl":"theorem Icc_subset_Ici_self : Icc a b ⊆ Ici a := by\n  simpa [← coe_subset] using Set.Icc_subset_Ici_self\n\n"}
{"name":"Finset.Ico_subset_Ici_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderTop α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ico a b) (Finset.Ici a)","decl":"theorem Ico_subset_Ici_self : Ico a b ⊆ Ici a := by\n  simpa [← coe_subset] using Set.Ico_subset_Ici_self\n\n"}
{"name":"Finset.Ioc_subset_Ioi_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderTop α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ioc a b) (Finset.Ioi a)","decl":"theorem Ioc_subset_Ioi_self : Ioc a b ⊆ Ioi a := by\n  simpa [← coe_subset] using Set.Ioc_subset_Ioi_self\n\n"}
{"name":"Finset.Ioo_subset_Ioi_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderTop α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ioo a b) (Finset.Ioi a)","decl":"theorem Ioo_subset_Ioi_self : Ioo a b ⊆ Ioi a := by\n  simpa [← coe_subset] using Set.Ioo_subset_Ioi_self\n\n"}
{"name":"Finset.Ioc_subset_Ici_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderTop α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ioc a b) (Finset.Ici a)","decl":"theorem Ioc_subset_Ici_self : Ioc a b ⊆ Ici a :=\n  Ioc_subset_Icc_self.trans Icc_subset_Ici_self\n\n"}
{"name":"Finset.Ioo_subset_Ici_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderTop α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ioo a b) (Finset.Ici a)","decl":"theorem Ioo_subset_Ici_self : Ioo a b ⊆ Ici a :=\n  Ioo_subset_Ico_self.trans Ico_subset_Ici_self\n\n"}
{"name":"Finset.Iio_eq_empty","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderBot α\n⊢ Iff (Eq (Finset.Iio a) EmptyCollection.emptyCollection) (IsMin a)","decl":"@[simp]\ntheorem Iio_eq_empty : Iio a = ∅ ↔ IsMin a := Ioi_eq_empty (α := αᵒᵈ)\n\n"}
{"name":"Finset.Iio_bot","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderBot α\ninst✝ : OrderBot α\n⊢ Eq (Finset.Iio Bot.bot) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Iio_bot [OrderBot α] : Iio (⊥ : α) = ∅ := Iio_eq_empty.mpr isMin_bot\n\n"}
{"name":"Finset.Iic_top","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : LocallyFiniteOrderBot α\ninst✝¹ : OrderTop α\ninst✝ : Fintype α\n⊢ Eq (Finset.Iic Top.top) Finset.univ","decl":"@[simp]\ntheorem Iic_top [OrderTop α] [Fintype α] : Iic (⊤ : α) = univ := by\n  ext a; simp only [mem_Iic, le_top, mem_univ]\n\n"}
{"name":"Finset.nonempty_Iic","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderBot α\n⊢ (Finset.Iic a).Nonempty","decl":"@[simp, aesop safe apply (rule_sets := [finsetNonempty])]\nlemma nonempty_Iic : (Iic a).Nonempty := ⟨a, mem_Iic.2 le_rfl⟩\n"}
{"name":"Finset.nonempty_Iio","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderBot α\n⊢ Iff (Finset.Iio a).Nonempty (Not (IsMin a))","decl":"@[simp]\nlemma nonempty_Iio : (Iio a).Nonempty ↔ ¬ IsMin a := by simp [Finset.Nonempty]\n\n"}
{"name":"Finset.Aesop.nonempty_Iio_of_not_isMin","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderBot α\na✝ : Not (IsMin a)\n⊢ (Finset.Iio a).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nalias ⟨_, Aesop.nonempty_Iio_of_not_isMin⟩ := nonempty_Iio\n\n"}
{"name":"Finset.Iic_subset_Iic","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderBot α\n⊢ Iff (HasSubset.Subset (Finset.Iic a) (Finset.Iic b)) (LE.le a b)","decl":"theorem Iic_subset_Iic : Iic a ⊆ Iic b ↔ a ≤ b := by\n  simpa [← coe_subset] using Set.Iic_subset_Iic\n\n"}
{"name":"Finset.Iio_subset_Iio","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderBot α\nh : LE.le a b\n⊢ HasSubset.Subset (Finset.Iio a) (Finset.Iio b)","decl":"theorem Iio_subset_Iio (h : a ≤ b) : Iio a ⊆ Iio b := by\n  simpa [← coe_subset] using Set.Iio_subset_Iio h\n\n"}
{"name":"Finset.Icc_subset_Iic_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderBot α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Icc a b) (Finset.Iic b)","decl":"theorem Icc_subset_Iic_self : Icc a b ⊆ Iic b := by\n  simpa [← coe_subset] using Set.Icc_subset_Iic_self\n\n"}
{"name":"Finset.Ioc_subset_Iic_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderBot α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ioc a b) (Finset.Iic b)","decl":"theorem Ioc_subset_Iic_self : Ioc a b ⊆ Iic b := by\n  simpa [← coe_subset] using Set.Ioc_subset_Iic_self\n\n"}
{"name":"Finset.Ico_subset_Iio_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderBot α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ico a b) (Finset.Iio b)","decl":"theorem Ico_subset_Iio_self : Ico a b ⊆ Iio b := by\n  simpa [← coe_subset] using Set.Ico_subset_Iio_self\n\n"}
{"name":"Finset.Ioo_subset_Iio_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderBot α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ioo a b) (Finset.Iio b)","decl":"theorem Ioo_subset_Iio_self : Ioo a b ⊆ Iio b := by\n  simpa [← coe_subset] using Set.Ioo_subset_Iio_self\n\n"}
{"name":"Finset.Ico_subset_Iic_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderBot α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ico a b) (Finset.Iic b)","decl":"theorem Ico_subset_Iic_self : Ico a b ⊆ Iic b :=\n  Ico_subset_Icc_self.trans Icc_subset_Iic_self\n\n"}
{"name":"Finset.Ioo_subset_Iic_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderBot α\ninst✝ : LocallyFiniteOrder α\n⊢ HasSubset.Subset (Finset.Ioo a b) (Finset.Iic b)","decl":"theorem Ioo_subset_Iic_self : Ioo a b ⊆ Iic b :=\n  Ioo_subset_Ioc_self.trans Ioc_subset_Iic_self\n\n"}
{"name":"Finset.Ioi_subset_Ici_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderTop α\na : α\n⊢ HasSubset.Subset (Finset.Ioi a) (Finset.Ici a)","decl":"theorem Ioi_subset_Ici_self : Ioi a ⊆ Ici a := by\n  simpa [← coe_subset] using Set.Ioi_subset_Ici_self\n\n"}
{"name":"BddBelow.finite","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderTop α\ns : Set α\nhs : BddBelow s\n⊢ s.Finite","decl":"theorem _root_.BddBelow.finite {s : Set α} (hs : BddBelow s) : s.Finite :=\n  let ⟨a, ha⟩ := hs\n  (Ici a).finite_toSet.subset fun _ hx => mem_Ici.2 <| ha hx\n\n"}
{"name":"Set.Infinite.not_bddBelow","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderTop α\ns : Set α\na✝ : s.Infinite\n⊢ Not (BddBelow s)","decl":"theorem _root_.Set.Infinite.not_bddBelow {s : Set α} : s.Infinite → ¬BddBelow s :=\n  mt BddBelow.finite\n\n"}
{"name":"Finset.filter_lt_eq_Ioi","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : LocallyFiniteOrderTop α\na : α\ninst✝¹ : Fintype α\ninst✝ : DecidablePred fun x => LT.lt a x\n⊢ Eq (Finset.filter (fun x => LT.lt a x) Finset.univ) (Finset.Ioi a)","decl":"theorem filter_lt_eq_Ioi [DecidablePred (a < ·)] : ({x | a < x} : Finset _) = Ioi a := by ext; simp\n"}
{"name":"Finset.filter_le_eq_Ici","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : LocallyFiniteOrderTop α\na : α\ninst✝¹ : Fintype α\ninst✝ : DecidablePred fun x => LE.le a x\n⊢ Eq (Finset.filter (fun x => LE.le a x) Finset.univ) (Finset.Ici a)","decl":"theorem filter_le_eq_Ici [DecidablePred (a ≤ ·)] : ({x | a ≤ x} : Finset _) = Ici a := by ext; simp\n\n"}
{"name":"Finset.Iio_subset_Iic_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderBot α\na : α\n⊢ HasSubset.Subset (Finset.Iio a) (Finset.Iic a)","decl":"theorem Iio_subset_Iic_self : Iio a ⊆ Iic a := by\n  simpa [← coe_subset] using Set.Iio_subset_Iic_self\n\n"}
{"name":"BddAbove.finite","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderBot α\ns : Set α\nhs : BddAbove s\n⊢ s.Finite","decl":"theorem _root_.BddAbove.finite {s : Set α} (hs : BddAbove s) : s.Finite :=\n  hs.dual.finite\n\n"}
{"name":"Set.Infinite.not_bddAbove","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrderBot α\ns : Set α\na✝ : s.Infinite\n⊢ Not (BddAbove s)","decl":"theorem _root_.Set.Infinite.not_bddAbove {s : Set α} : s.Infinite → ¬BddAbove s :=\n  mt BddAbove.finite\n\n"}
{"name":"Finset.filter_gt_eq_Iio","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : LocallyFiniteOrderBot α\na : α\ninst✝¹ : Fintype α\ninst✝ : DecidablePred fun x => LT.lt x a\n⊢ Eq (Finset.filter (fun x => LT.lt x a) Finset.univ) (Finset.Iio a)","decl":"theorem filter_gt_eq_Iio [DecidablePred (· < a)] : ({x | x < a} : Finset _) = Iio a := by ext; simp\n"}
{"name":"Finset.filter_ge_eq_Iic","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : LocallyFiniteOrderBot α\na : α\ninst✝¹ : Fintype α\ninst✝ : DecidablePred fun x => LE.le x a\n⊢ Eq (Finset.filter (fun x => LE.le x a) Finset.univ) (Finset.Iic a)","decl":"theorem filter_ge_eq_Iic [DecidablePred (· ≤ a)] : ({x | x ≤ a} : Finset _) = Iic a := by ext; simp\n\n"}
{"name":"Finset.Icc_bot","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : OrderBot α\n⊢ Eq (Finset.Icc Bot.bot a) (Finset.Iic a)","decl":"@[simp]\ntheorem Icc_bot [OrderBot α] : Icc (⊥ : α) a = Iic a := rfl\n\n"}
{"name":"Finset.Icc_top","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : OrderTop α\n⊢ Eq (Finset.Icc a Top.top) (Finset.Ici a)","decl":"@[simp]\ntheorem Icc_top [OrderTop α] : Icc a (⊤ : α) = Ici a := rfl\n\n"}
{"name":"Finset.Ico_bot","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : OrderBot α\n⊢ Eq (Finset.Ico Bot.bot a) (Finset.Iio a)","decl":"@[simp]\ntheorem Ico_bot [OrderBot α] : Ico (⊥ : α) a = Iio a := rfl\n\n"}
{"name":"Finset.Ioc_top","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\na : α\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : OrderTop α\n⊢ Eq (Finset.Ioc a Top.top) (Finset.Ioi a)","decl":"@[simp]\ntheorem Ioc_top [OrderTop α] : Ioc a (⊤ : α) = Ioi a := rfl\n\n"}
{"name":"Finset.Icc_bot_top","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : BoundedOrder α\ninst✝ : Fintype α\n⊢ Eq (Finset.Icc Bot.bot Top.top) Finset.univ","decl":"theorem Icc_bot_top [BoundedOrder α] [Fintype α] : Icc (⊥ : α) (⊤ : α) = univ := by\n  rw [Icc_bot, Iic_top]\n\n"}
{"name":"Finset.disjoint_Ioi_Iio","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrderTop α\ninst✝ : LocallyFiniteOrderBot α\na : α\n⊢ Disjoint (Finset.Ioi a) (Finset.Iio a)","decl":"theorem disjoint_Ioi_Iio (a : α) : Disjoint (Ioi a) (Iio a) :=\n  disjoint_left.2 fun _ hab hba => (mem_Ioi.1 hab).not_lt <| mem_Iio.1 hba\n\n"}
{"name":"Finset.Icc_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\na : α\n⊢ Eq (Finset.Icc a a) (Singleton.singleton a)","decl":"@[simp]\ntheorem Icc_self (a : α) : Icc a a = {a} := by rw [← coe_eq_singleton, coe_Icc, Set.Icc_self]\n\n"}
{"name":"Finset.Icc_eq_singleton_iff","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\n⊢ Iff (Eq (Finset.Icc a b) (Singleton.singleton c)) (And (Eq a c) (Eq b c))","decl":"@[simp]\ntheorem Icc_eq_singleton_iff : Icc a b = {c} ↔ a = c ∧ b = c := by\n  rw [← coe_eq_singleton, coe_Icc, Set.Icc_eq_singleton_iff]\n\n"}
{"name":"Finset.Ico_disjoint_Ico_consecutive","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\n⊢ Disjoint (Finset.Ico a b) (Finset.Ico b c)","decl":"theorem Ico_disjoint_Ico_consecutive (a b c : α) : Disjoint (Ico a b) (Ico b c) :=\n  disjoint_left.2 fun _ hab hbc => (mem_Ico.mp hab).2.not_le (mem_Ico.mp hbc).1\n\n"}
{"name":"Finset.Ici_top","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : OrderTop α\n⊢ Eq (Finset.Ici Top.top) (Singleton.singleton Top.top)","decl":"@[simp]\ntheorem Ici_top [OrderTop α] : Ici (⊤ : α) = {⊤} := Icc_eq_singleton_iff.2 ⟨rfl, rfl⟩\n\n"}
{"name":"Finset.Iic_bot","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : OrderBot α\n⊢ Eq (Finset.Iic Bot.bot) (Singleton.singleton Bot.bot)","decl":"@[simp]\ntheorem Iic_bot [OrderBot α] : Iic (⊥ : α) = {⊥} := Icc_eq_singleton_iff.2 ⟨rfl, rfl⟩\n\n"}
{"name":"Finset.Icc_erase_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na b : α\n⊢ Eq ((Finset.Icc a b).erase a) (Finset.Ioc a b)","decl":"@[simp]\ntheorem Icc_erase_left (a b : α) : (Icc a b).erase a = Ioc a b := by simp [← coe_inj]\n\n"}
{"name":"Finset.Icc_erase_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na b : α\n⊢ Eq ((Finset.Icc a b).erase b) (Finset.Ico a b)","decl":"@[simp]\ntheorem Icc_erase_right (a b : α) : (Icc a b).erase b = Ico a b := by simp [← coe_inj]\n\n"}
{"name":"Finset.Ico_erase_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na b : α\n⊢ Eq ((Finset.Ico a b).erase a) (Finset.Ioo a b)","decl":"@[simp]\ntheorem Ico_erase_left (a b : α) : (Ico a b).erase a = Ioo a b := by simp [← coe_inj]\n\n"}
{"name":"Finset.Ioc_erase_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na b : α\n⊢ Eq ((Finset.Ioc a b).erase b) (Finset.Ioo a b)","decl":"@[simp]\ntheorem Ioc_erase_right (a b : α) : (Ioc a b).erase b = Ioo a b := by simp [← coe_inj]\n\n"}
{"name":"Finset.Icc_diff_both","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na b : α\n⊢ Eq (SDiff.sdiff (Finset.Icc a b) (Insert.insert a (Singleton.singleton b))) (Finset.Ioo a b)","decl":"@[simp]\ntheorem Icc_diff_both (a b : α) : Icc a b \\ {a, b} = Ioo a b := by simp [← coe_inj]\n\n"}
{"name":"Finset.Ico_insert_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\na b : α\ninst✝ : DecidableEq α\nh : LE.le a b\n⊢ Eq (Insert.insert b (Finset.Ico a b)) (Finset.Icc a b)","decl":"@[simp]\ntheorem Ico_insert_right (h : a ≤ b) : insert b (Ico a b) = Icc a b := by\n  rw [← coe_inj, coe_insert, coe_Icc, coe_Ico, Set.insert_eq, Set.union_comm, Set.Ico_union_right h]\n\n"}
{"name":"Finset.Ioc_insert_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\na b : α\ninst✝ : DecidableEq α\nh : LE.le a b\n⊢ Eq (Insert.insert a (Finset.Ioc a b)) (Finset.Icc a b)","decl":"@[simp]\ntheorem Ioc_insert_left (h : a ≤ b) : insert a (Ioc a b) = Icc a b := by\n  rw [← coe_inj, coe_insert, coe_Ioc, coe_Icc, Set.insert_eq, Set.union_comm, Set.Ioc_union_left h]\n\n"}
{"name":"Finset.Ioo_insert_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\na b : α\ninst✝ : DecidableEq α\nh : LT.lt a b\n⊢ Eq (Insert.insert a (Finset.Ioo a b)) (Finset.Ico a b)","decl":"@[simp]\ntheorem Ioo_insert_left (h : a < b) : insert a (Ioo a b) = Ico a b := by\n  rw [← coe_inj, coe_insert, coe_Ioo, coe_Ico, Set.insert_eq, Set.union_comm, Set.Ioo_union_left h]\n\n"}
{"name":"Finset.Ioo_insert_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\na b : α\ninst✝ : DecidableEq α\nh : LT.lt a b\n⊢ Eq (Insert.insert b (Finset.Ioo a b)) (Finset.Ioc a b)","decl":"@[simp]\ntheorem Ioo_insert_right (h : a < b) : insert b (Ioo a b) = Ioc a b := by\n  rw [← coe_inj, coe_insert, coe_Ioo, coe_Ioc, Set.insert_eq, Set.union_comm, Set.Ioo_union_right h]\n\n"}
{"name":"Finset.Icc_diff_Ico_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\na b : α\ninst✝ : DecidableEq α\nh : LE.le a b\n⊢ Eq (SDiff.sdiff (Finset.Icc a b) (Finset.Ico a b)) (Singleton.singleton b)","decl":"@[simp]\ntheorem Icc_diff_Ico_self (h : a ≤ b) : Icc a b \\ Ico a b = {b} := by simp [← coe_inj, h]\n\n"}
{"name":"Finset.Icc_diff_Ioc_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\na b : α\ninst✝ : DecidableEq α\nh : LE.le a b\n⊢ Eq (SDiff.sdiff (Finset.Icc a b) (Finset.Ioc a b)) (Singleton.singleton a)","decl":"@[simp]\ntheorem Icc_diff_Ioc_self (h : a ≤ b) : Icc a b \\ Ioc a b = {a} := by simp [← coe_inj, h]\n\n"}
{"name":"Finset.Icc_diff_Ioo_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\na b : α\ninst✝ : DecidableEq α\nh : LE.le a b\n⊢ Eq (SDiff.sdiff (Finset.Icc a b) (Finset.Ioo a b)) (Insert.insert a (Singleton.singleton b))","decl":"@[simp]\ntheorem Icc_diff_Ioo_self (h : a ≤ b) : Icc a b \\ Ioo a b = {a, b} := by simp [← coe_inj, h]\n\n"}
{"name":"Finset.Ico_diff_Ioo_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\na b : α\ninst✝ : DecidableEq α\nh : LT.lt a b\n⊢ Eq (SDiff.sdiff (Finset.Ico a b) (Finset.Ioo a b)) (Singleton.singleton a)","decl":"@[simp]\ntheorem Ico_diff_Ioo_self (h : a < b) : Ico a b \\ Ioo a b = {a} := by simp [← coe_inj, h]\n\n"}
{"name":"Finset.Ioc_diff_Ioo_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\na b : α\ninst✝ : DecidableEq α\nh : LT.lt a b\n⊢ Eq (SDiff.sdiff (Finset.Ioc a b) (Finset.Ioo a b)) (Singleton.singleton b)","decl":"@[simp]\ntheorem Ioc_diff_Ioo_self (h : a < b) : Ioc a b \\ Ioo a b = {b} := by simp [← coe_inj, h]\n\n"}
{"name":"Finset.Ico_inter_Ico_consecutive","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : DecidableEq α\na b c : α\n⊢ Eq (Inter.inter (Finset.Ico a b) (Finset.Ico b c)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ico_inter_Ico_consecutive (a b c : α) : Ico a b ∩ Ico b c = ∅ :=\n  (Ico_disjoint_Ico_consecutive a b c).eq_bot\n\n"}
{"name":"Finset.Icc_eq_cons_Ico","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Finset.Icc a b) (Finset.cons b (Finset.Ico a b) ⋯)","decl":"/-- `Finset.cons` version of `Finset.Ico_insert_right`. -/\ntheorem Icc_eq_cons_Ico (h : a ≤ b) : Icc a b = (Ico a b).cons b right_not_mem_Ico := by\n  classical rw [cons_eq_insert, Ico_insert_right h]\n\n"}
{"name":"Finset.Icc_eq_cons_Ioc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Finset.Icc a b) (Finset.cons a (Finset.Ioc a b) ⋯)","decl":"/-- `Finset.cons` version of `Finset.Ioc_insert_left`. -/\ntheorem Icc_eq_cons_Ioc (h : a ≤ b) : Icc a b = (Ioc a b).cons a left_not_mem_Ioc := by\n  classical rw [cons_eq_insert, Ioc_insert_left h]\n\n"}
{"name":"Finset.Ioc_eq_cons_Ioo","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (Finset.Ioc a b) (Finset.cons b (Finset.Ioo a b) ⋯)","decl":"/-- `Finset.cons` version of `Finset.Ioo_insert_right`. -/\ntheorem Ioc_eq_cons_Ioo (h : a < b) : Ioc a b = (Ioo a b).cons b right_not_mem_Ioo := by\n  classical rw [cons_eq_insert, Ioo_insert_right h]\n\n"}
{"name":"Finset.Ico_eq_cons_Ioo","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (Finset.Ico a b) (Finset.cons a (Finset.Ioo a b) ⋯)","decl":"/-- `Finset.cons` version of `Finset.Ioo_insert_left`. -/\ntheorem Ico_eq_cons_Ioo (h : a < b) : Ico a b = (Ioo a b).cons a left_not_mem_Ioo := by\n  classical rw [cons_eq_insert, Ioo_insert_left h]\n\n"}
{"name":"Finset.Ico_filter_le_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\na b : α\ninst✝ : DecidablePred fun x => LE.le x a\nhab : LT.lt a b\n⊢ Eq (Finset.filter (fun x => LE.le x a) (Finset.Ico a b)) (Singleton.singleton a)","decl":"theorem Ico_filter_le_left {a b : α} [DecidablePred (· ≤ a)] (hab : a < b) :\n    {x ∈ Ico a b | x ≤ a} = {a} := by\n  ext x\n  rw [mem_filter, mem_Ico, mem_singleton, and_right_comm, ← le_antisymm_iff, eq_comm]\n  exact and_iff_left_of_imp fun h => h.le.trans_lt hab\n\n"}
{"name":"Finset.card_Ico_eq_card_Icc_sub_one","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ Eq (Finset.Ico a b).card (HSub.hSub (Finset.Icc a b).card 1)","decl":"theorem card_Ico_eq_card_Icc_sub_one (a b : α) : #(Ico a b) = #(Icc a b) - 1 := by\n  classical\n    by_cases h : a ≤ b\n    · rw [Icc_eq_cons_Ico h, card_cons]\n      exact (Nat.add_sub_cancel _ _).symm\n    · rw [Ico_eq_empty fun h' => h h'.le, Icc_eq_empty h, card_empty, Nat.zero_sub]\n\n"}
{"name":"Finset.card_Ioc_eq_card_Icc_sub_one","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ Eq (Finset.Ioc a b).card (HSub.hSub (Finset.Icc a b).card 1)","decl":"theorem card_Ioc_eq_card_Icc_sub_one (a b : α) : #(Ioc a b) = #(Icc a b) - 1 :=\n  @card_Ico_eq_card_Icc_sub_one αᵒᵈ _ _ _ _\n\n"}
{"name":"Finset.card_Ioo_eq_card_Ico_sub_one","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ Eq (Finset.Ioo a b).card (HSub.hSub (Finset.Ico a b).card 1)","decl":"theorem card_Ioo_eq_card_Ico_sub_one (a b : α) : #(Ioo a b) = #(Ico a b) - 1 := by\n  classical\n    by_cases h : a < b\n    · rw [Ico_eq_cons_Ioo h, card_cons]\n      exact (Nat.add_sub_cancel _ _).symm\n    · rw [Ioo_eq_empty h, Ico_eq_empty h, card_empty, Nat.zero_sub]\n\n"}
{"name":"Finset.card_Ioo_eq_card_Ioc_sub_one","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ Eq (Finset.Ioo a b).card (HSub.hSub (Finset.Ioc a b).card 1)","decl":"theorem card_Ioo_eq_card_Ioc_sub_one (a b : α) : #(Ioo a b) = #(Ioc a b) - 1 :=\n  @card_Ioo_eq_card_Ico_sub_one αᵒᵈ _ _ _ _\n\n"}
{"name":"Finset.card_Ioo_eq_card_Icc_sub_two","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ Eq (Finset.Ioo a b).card (HSub.hSub (Finset.Icc a b).card 2)","decl":"theorem card_Ioo_eq_card_Icc_sub_two (a b : α) : #(Ioo a b) = #(Icc a b) - 2 := by\n  rw [card_Ioo_eq_card_Ico_sub_one, card_Ico_eq_card_Icc_sub_one]\n  rfl\n\n"}
{"name":"Finset.uIcc_map_sectL","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : Lattice α\ninst✝³ : Lattice β\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : LocallyFiniteOrder β\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : α\nc : β\n⊢ Eq (Finset.map (Function.Embedding.sectL α c) (Finset.uIcc a b)) (Finset.uIcc { fst := a, snd := c } { fst := b, snd := c })","decl":"lemma uIcc_map_sectL [Lattice α] [Lattice β] [LocallyFiniteOrder α] [LocallyFiniteOrder β]\n    [DecidableRel (α := α × β) (· ≤ ·)] (a b : α) (c : β) :\n    (uIcc a b).map (.sectL _ c) = uIcc (a, c) (b, c) := by\n  aesop (add safe forward [le_antisymm])\n\n"}
{"name":"Finset.Icc_map_sectL","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : Preorder α\ninst✝³ : PartialOrder β\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : LocallyFiniteOrder β\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : α\nc : β\n⊢ Eq (Finset.map (Function.Embedding.sectL α c) (Finset.Icc a b)) (Finset.Icc { fst := a, snd := c } { fst := b, snd := c })","decl":"lemma Icc_map_sectL : (Icc a b).map (.sectL _ c) = Icc (a, c) (b, c) := by\n  aesop (add safe forward [le_antisymm])\n\n"}
{"name":"Finset.Ioc_map_sectL","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : Preorder α\ninst✝³ : PartialOrder β\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : LocallyFiniteOrder β\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : α\nc : β\n⊢ Eq (Finset.map (Function.Embedding.sectL α c) (Finset.Ioc a b)) (Finset.Ioc { fst := a, snd := c } { fst := b, snd := c })","decl":"lemma Ioc_map_sectL : (Ioc a b).map (.sectL _ c) = Ioc (a, c) (b, c) := by\n  aesop (add safe forward [le_antisymm, le_of_lt])\n\n"}
{"name":"Finset.Ico_map_sectL","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : Preorder α\ninst✝³ : PartialOrder β\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : LocallyFiniteOrder β\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : α\nc : β\n⊢ Eq (Finset.map (Function.Embedding.sectL α c) (Finset.Ico a b)) (Finset.Ico { fst := a, snd := c } { fst := b, snd := c })","decl":"lemma Ico_map_sectL : (Ico a b).map (.sectL _ c) = Ico (a, c) (b, c) := by\n  aesop (add safe forward [le_antisymm, le_of_lt])\n\n"}
{"name":"Finset.Ioo_map_sectL","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : Preorder α\ninst✝³ : PartialOrder β\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : LocallyFiniteOrder β\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\na b : α\nc : β\n⊢ Eq (Finset.map (Function.Embedding.sectL α c) (Finset.Ioo a b)) (Finset.Ioo { fst := a, snd := c } { fst := b, snd := c })","decl":"lemma Ioo_map_sectL : (Ioo a b).map (.sectL _ c) = Ioo (a, c) (b, c) := by\n  aesop (add safe forward [le_antisymm, le_of_lt])\n\n"}
{"name":"Finset.uIcc_map_sectR","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : Lattice α\ninst✝³ : Lattice β\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : LocallyFiniteOrder β\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nc : α\na b : β\n⊢ Eq (Finset.map (Function.Embedding.sectR c β) (Finset.uIcc a b)) (Finset.uIcc { fst := c, snd := a } { fst := c, snd := b })","decl":"lemma uIcc_map_sectR [Lattice α] [Lattice β] [LocallyFiniteOrder α] [LocallyFiniteOrder β]\n    [DecidableRel (α := α × β) (· ≤ ·)] (c : α) (a b : β) :\n    (uIcc a b).map (.sectR c _) = uIcc (c, a) (c, b) := by\n  aesop (add safe forward [le_antisymm])\n\n"}
{"name":"Finset.Icc_map_sectR","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : PartialOrder α\ninst✝³ : Preorder β\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : LocallyFiniteOrder β\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nc : α\na b : β\n⊢ Eq (Finset.map (Function.Embedding.sectR c β) (Finset.Icc a b)) (Finset.Icc { fst := c, snd := a } { fst := c, snd := b })","decl":"lemma Icc_map_sectR : (Icc a b).map (.sectR c _) = Icc (c, a) (c, b) := by\n  aesop (add safe forward [le_antisymm])\n\n"}
{"name":"Finset.Ioc_map_sectR","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : PartialOrder α\ninst✝³ : Preorder β\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : LocallyFiniteOrder β\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nc : α\na b : β\n⊢ Eq (Finset.map (Function.Embedding.sectR c β) (Finset.Ioc a b)) (Finset.Ioc { fst := c, snd := a } { fst := c, snd := b })","decl":"lemma Ioc_map_sectR : (Ioc a b).map (.sectR c _) = Ioc (c, a) (c, b) := by\n  aesop (add safe forward [le_antisymm, le_of_lt])\n\n"}
{"name":"Finset.Ico_map_sectR","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : PartialOrder α\ninst✝³ : Preorder β\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : LocallyFiniteOrder β\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nc : α\na b : β\n⊢ Eq (Finset.map (Function.Embedding.sectR c β) (Finset.Ico a b)) (Finset.Ico { fst := c, snd := a } { fst := c, snd := b })","decl":"lemma Ico_map_sectR : (Ico a b).map (.sectR c _) = Ico (c, a) (c, b) := by\n  aesop (add safe forward [le_antisymm, le_of_lt])\n\n"}
{"name":"Finset.Ioo_map_sectR","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : PartialOrder α\ninst✝³ : Preorder β\ninst✝² : LocallyFiniteOrder α\ninst✝¹ : LocallyFiniteOrder β\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nc : α\na b : β\n⊢ Eq (Finset.map (Function.Embedding.sectR c β) (Finset.Ioo a b)) (Finset.Ioo { fst := c, snd := a } { fst := c, snd := b })","decl":"lemma Ioo_map_sectR : (Ioo a b).map (.sectR c _) = Ioo (c, a) (c, b) := by\n  aesop (add safe forward [le_antisymm, le_of_lt])\n\n"}
{"name":"Finset.Ici_erase","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrderTop α\ninst✝ : DecidableEq α\na : α\n⊢ Eq ((Finset.Ici a).erase a) (Finset.Ioi a)","decl":"@[simp]\ntheorem Ici_erase [DecidableEq α] (a : α) : (Ici a).erase a = Ioi a := by\n  ext\n  simp_rw [Finset.mem_erase, mem_Ici, mem_Ioi, lt_iff_le_and_ne, and_comm, ne_comm]\n\n"}
{"name":"Finset.Ioi_insert","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrderTop α\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Insert.insert a (Finset.Ioi a)) (Finset.Ici a)","decl":"@[simp]\ntheorem Ioi_insert [DecidableEq α] (a : α) : insert a (Ioi a) = Ici a := by\n  ext\n  simp_rw [Finset.mem_insert, mem_Ici, mem_Ioi, le_iff_lt_or_eq, or_comm, eq_comm]\n\n"}
{"name":"Finset.not_mem_Ioi_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrderTop α\nb : α\n⊢ Not (Membership.mem (Finset.Ioi b) b)","decl":"theorem not_mem_Ioi_self {b : α} : b ∉ Ioi b := fun h => lt_irrefl _ (mem_Ioi.1 h)\n\n-- Purposefully written the other way around\n"}
{"name":"Finset.Ici_eq_cons_Ioi","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrderTop α\na : α\n⊢ Eq (Finset.Ici a) (Finset.cons a (Finset.Ioi a) ⋯)","decl":"/-- `Finset.cons` version of `Finset.Ioi_insert`. -/\ntheorem Ici_eq_cons_Ioi (a : α) : Ici a = (Ioi a).cons a not_mem_Ioi_self := by\n  classical rw [cons_eq_insert, Ioi_insert]\n\n"}
{"name":"Finset.card_Ioi_eq_card_Ici_sub_one","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrderTop α\na : α\n⊢ Eq (Finset.Ioi a).card (HSub.hSub (Finset.Ici a).card 1)","decl":"theorem card_Ioi_eq_card_Ici_sub_one (a : α) : #(Ioi a) = #(Ici a) - 1 := by\n  rw [Ici_eq_cons_Ioi, card_cons, Nat.add_sub_cancel_right]\n\n"}
{"name":"Finset.Iic_erase","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrderBot α\ninst✝ : DecidableEq α\nb : α\n⊢ Eq ((Finset.Iic b).erase b) (Finset.Iio b)","decl":"@[simp]\ntheorem Iic_erase [DecidableEq α] (b : α) : (Iic b).erase b = Iio b := by\n  ext\n  simp_rw [Finset.mem_erase, mem_Iic, mem_Iio, lt_iff_le_and_ne, and_comm]\n\n"}
{"name":"Finset.Iio_insert","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrderBot α\ninst✝ : DecidableEq α\nb : α\n⊢ Eq (Insert.insert b (Finset.Iio b)) (Finset.Iic b)","decl":"@[simp]\ntheorem Iio_insert [DecidableEq α] (b : α) : insert b (Iio b) = Iic b := by\n  ext\n  simp_rw [Finset.mem_insert, mem_Iic, mem_Iio, le_iff_lt_or_eq, or_comm]\n\n"}
{"name":"Finset.not_mem_Iio_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrderBot α\nb : α\n⊢ Not (Membership.mem (Finset.Iio b) b)","decl":"theorem not_mem_Iio_self {b : α} : b ∉ Iio b := fun h => lt_irrefl _ (mem_Iio.1 h)\n\n-- Purposefully written the other way around\n"}
{"name":"Finset.Iic_eq_cons_Iio","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrderBot α\nb : α\n⊢ Eq (Finset.Iic b) (Finset.cons b (Finset.Iio b) ⋯)","decl":"/-- `Finset.cons` version of `Finset.Iio_insert`. -/\ntheorem Iic_eq_cons_Iio (b : α) : Iic b = (Iio b).cons b not_mem_Iio_self := by\n  classical rw [cons_eq_insert, Iio_insert]\n\n"}
{"name":"Finset.card_Iio_eq_card_Iic_sub_one","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrderBot α\na : α\n⊢ Eq (Finset.Iio a).card (HSub.hSub (Finset.Iic a).card 1)","decl":"theorem card_Iio_eq_card_Iic_sub_one (a : α) : #(Iio a) = #(Iic a) - 1 := by\n  rw [Iic_eq_cons_Iio, card_cons, Nat.add_sub_cancel_right]\n\n"}
{"name":"Finset.sup'_Iic","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : SemilatticeSup α\ninst✝ : LocallyFiniteOrderBot α\na : α\n⊢ Eq ((Finset.Iic a).sup' ⋯ id) a","decl":"lemma sup'_Iic (a : α) : (Iic a).sup' nonempty_Iic id = a :=\n  le_antisymm (sup'_le _ _ fun _ ↦ mem_Iic.1) <| le_sup' (f := id) <| mem_Iic.2 <| le_refl a\n\n"}
{"name":"Finset.sup_Iic","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : LocallyFiniteOrderBot α\ninst✝ : OrderBot α\na : α\n⊢ Eq ((Finset.Iic a).sup id) a","decl":"@[simp] lemma sup_Iic [OrderBot α] (a : α) : (Iic a).sup id = a :=\n  le_antisymm (Finset.sup_le fun _ ↦ mem_Iic.1) <| le_sup (f := id) <| mem_Iic.2 <| le_refl a\n\n"}
{"name":"Finset.inf'_Ici","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : SemilatticeInf α\ninst✝ : LocallyFiniteOrderTop α\na : α\n⊢ Eq ((Finset.Ici a).inf' ⋯ id) a","decl":"lemma inf'_Ici (a : α) : (Ici a).inf' nonempty_Ici id = a :=\n  ge_antisymm (le_inf' _ _ fun _ ↦ mem_Ici.1) <| inf'_le (f := id) <| mem_Ici.2 <| le_refl a\n\n"}
{"name":"Finset.inf_Ici","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : SemilatticeInf α\ninst✝¹ : LocallyFiniteOrderTop α\ninst✝ : OrderTop α\na : α\n⊢ Eq ((Finset.Ici a).inf id) a","decl":"@[simp] lemma inf_Ici [OrderTop α] (a : α) : (Ici a).inf id = a :=\n  le_antisymm (inf_le (f := id) <| mem_Ici.2 <| le_refl a) <| Finset.le_inf fun _ ↦ mem_Ici.1\n\n"}
{"name":"Finset.Ico_subset_Ico_iff","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na₁ b₁ a₂ b₂ : α\nh : LT.lt a₁ b₁\n⊢ Iff (HasSubset.Subset (Finset.Ico a₁ b₁) (Finset.Ico a₂ b₂)) (And (LE.le a₂ a₁) (LE.le b₁ b₂))","decl":"theorem Ico_subset_Ico_iff {a₁ b₁ a₂ b₂ : α} (h : a₁ < b₁) :\n    Ico a₁ b₁ ⊆ Ico a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ ≤ b₂ := by\n  rw [← coe_subset, coe_Ico, coe_Ico, Set.Ico_subset_Ico_iff h]\n\n"}
{"name":"Finset.Ico_union_Ico_eq_Ico","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\nhab : LE.le a b\nhbc : LE.le b c\n⊢ Eq (Union.union (Finset.Ico a b) (Finset.Ico b c)) (Finset.Ico a c)","decl":"theorem Ico_union_Ico_eq_Ico {a b c : α} (hab : a ≤ b) (hbc : b ≤ c) :\n    Ico a b ∪ Ico b c = Ico a c := by\n  rw [← coe_inj, coe_union, coe_Ico, coe_Ico, coe_Ico, Set.Ico_union_Ico_eq_Ico hab hbc]\n\n"}
{"name":"Finset.Ioc_union_Ioc_eq_Ioc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\nh₁ : LE.le a b\nh₂ : LE.le b c\n⊢ Eq (Union.union (Finset.Ioc a b) (Finset.Ioc b c)) (Finset.Ioc a c)","decl":"@[simp]\ntheorem Ioc_union_Ioc_eq_Ioc {a b c : α} (h₁ : a ≤ b) (h₂ : b ≤ c) :\n    Ioc a b ∪ Ioc b c = Ioc a c := by\n  rw [← coe_inj, coe_union, coe_Ioc, coe_Ioc, coe_Ioc, Set.Ioc_union_Ioc_eq_Ioc h₁ h₂]\n\n"}
{"name":"Finset.Ico_subset_Ico_union_Ico","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\n⊢ HasSubset.Subset (Finset.Ico a c) (Union.union (Finset.Ico a b) (Finset.Ico b c))","decl":"theorem Ico_subset_Ico_union_Ico {a b c : α} : Ico a c ⊆ Ico a b ∪ Ico b c := by\n  rw [← coe_subset, coe_union, coe_Ico, coe_Ico, coe_Ico]\n  exact Set.Ico_subset_Ico_union_Ico\n\n"}
{"name":"Finset.Ico_union_Ico'","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c d : α\nhcb : LE.le c b\nhad : LE.le a d\n⊢ Eq (Union.union (Finset.Ico a b) (Finset.Ico c d)) (Finset.Ico (Min.min a c) (Max.max b d))","decl":"theorem Ico_union_Ico' {a b c d : α} (hcb : c ≤ b) (had : a ≤ d) :\n    Ico a b ∪ Ico c d = Ico (min a c) (max b d) := by\n  rw [← coe_inj, coe_union, coe_Ico, coe_Ico, coe_Ico, Set.Ico_union_Ico' hcb had]\n\n"}
{"name":"Finset.Ico_union_Ico","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c d : α\nh₁ : LE.le (Min.min a b) (Max.max c d)\nh₂ : LE.le (Min.min c d) (Max.max a b)\n⊢ Eq (Union.union (Finset.Ico a b) (Finset.Ico c d)) (Finset.Ico (Min.min a c) (Max.max b d))","decl":"theorem Ico_union_Ico {a b c d : α} (h₁ : min a b ≤ max c d) (h₂ : min c d ≤ max a b) :\n    Ico a b ∪ Ico c d = Ico (min a c) (max b d) := by\n  rw [← coe_inj, coe_union, coe_Ico, coe_Ico, coe_Ico, Set.Ico_union_Ico h₁ h₂]\n\n"}
{"name":"Finset.Ico_inter_Ico","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c d : α\n⊢ Eq (Inter.inter (Finset.Ico a b) (Finset.Ico c d)) (Finset.Ico (Max.max a c) (Min.min b d))","decl":"theorem Ico_inter_Ico {a b c d : α} : Ico a b ∩ Ico c d = Ico (max a c) (min b d) := by\n  rw [← coe_inj, coe_inter, coe_Ico, coe_Ico, coe_Ico, Set.Ico_inter_Ico]\n\n"}
{"name":"Finset.Ico_filter_lt","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\n⊢ Eq (Finset.filter (fun x => LT.lt x c) (Finset.Ico a b)) (Finset.Ico a (Min.min b c))","decl":"@[simp]\ntheorem Ico_filter_lt (a b c : α) : {x ∈ Ico a b | x < c} = Ico a (min b c) := by\n  cases le_total b c with\n  | inl h => rw [Ico_filter_lt_of_right_le h, min_eq_left h]\n  | inr h => rw [Ico_filter_lt_of_le_right h, min_eq_right h]\n\n"}
{"name":"Finset.Ico_filter_le","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\n⊢ Eq (Finset.filter (fun x => LE.le c x) (Finset.Ico a b)) (Finset.Ico (Max.max a c) b)","decl":"@[simp]\ntheorem Ico_filter_le (a b c : α) : {x ∈ Ico a b | c ≤ x} = Ico (max a c) b := by\n  cases le_total a c with\n  | inl h => rw [Ico_filter_le_of_left_le h, max_eq_right h]\n  | inr h => rw [Ico_filter_le_of_le_left h, max_eq_left h]\n\n"}
{"name":"Finset.Ioo_filter_lt","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\n⊢ Eq (Finset.filter (fun x => LT.lt x c) (Finset.Ioo a b)) (Finset.Ioo a (Min.min b c))","decl":"@[simp]\ntheorem Ioo_filter_lt (a b c : α) : {x ∈ Ioo a b | x < c} = Ioo a (min b c) := by\n  ext\n  simp [and_assoc]\n\n"}
{"name":"Finset.Iio_filter_lt","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrderBot α\na b : α\n⊢ Eq (Finset.filter (fun x => LT.lt x b) (Finset.Iio a)) (Finset.Iio (Min.min a b))","decl":"@[simp]\ntheorem Iio_filter_lt {α} [LinearOrder α] [LocallyFiniteOrderBot α] (a b : α) :\n    {x ∈ Iio a | x < b} = Iio (min a b) := by\n  ext\n  simp [and_assoc]\n\n"}
{"name":"Finset.Ico_diff_Ico_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\n⊢ Eq (SDiff.sdiff (Finset.Ico a b) (Finset.Ico a c)) (Finset.Ico (Max.max a c) b)","decl":"@[simp]\ntheorem Ico_diff_Ico_left (a b c : α) : Ico a b \\ Ico a c = Ico (max a c) b := by\n  cases le_total a c with\n  | inl h =>\n    ext x\n    rw [mem_sdiff, mem_Ico, mem_Ico, mem_Ico, max_eq_right h, and_right_comm, not_and, not_lt]\n    exact and_congr_left' ⟨fun hx => hx.2 hx.1, fun hx => ⟨h.trans hx, fun _ => hx⟩⟩\n  | inr h => rw [Ico_eq_empty_of_le h, sdiff_empty, max_eq_left h]\n\n"}
{"name":"Finset.Ico_diff_Ico_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\n⊢ Eq (SDiff.sdiff (Finset.Ico a b) (Finset.Ico c b)) (Finset.Ico a (Min.min b c))","decl":"@[simp]\ntheorem Ico_diff_Ico_right (a b c : α) : Ico a b \\ Ico c b = Ico a (min b c) := by\n  cases le_total b c with\n  | inl h => rw [Ico_eq_empty_of_le h, sdiff_empty, min_eq_left h]\n  | inr h =>\n    ext x\n    rw [mem_sdiff, mem_Ico, mem_Ico, mem_Ico, min_eq_right h, and_assoc, not_and', not_le]\n    exact and_congr_right' ⟨fun hx => hx.2 hx.1, fun hx => ⟨hx.trans_le h, fun _ => hx⟩⟩\n\n"}
{"name":"Set.Infinite.exists_gt","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrderBot α\ns : Set α\nhs : s.Infinite\na : α\n⊢ Exists fun b => And (Membership.mem s b) (LT.lt a b)","decl":"theorem _root_.Set.Infinite.exists_gt (hs : s.Infinite) : ∀ a, ∃ b ∈ s, a < b :=\n  not_bddAbove_iff.1 hs.not_bddAbove\n\n"}
{"name":"Set.infinite_iff_exists_gt","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : LocallyFiniteOrderBot α\ns : Set α\ninst✝ : Nonempty α\n⊢ Iff s.Infinite (∀ (a : α), Exists fun b => And (Membership.mem s b) (LT.lt a b))","decl":"theorem _root_.Set.infinite_iff_exists_gt [Nonempty α] : s.Infinite ↔ ∀ a, ∃ b ∈ s, a < b :=\n  ⟨Set.Infinite.exists_gt, Set.infinite_of_forall_exists_gt⟩\n\n"}
{"name":"Set.Infinite.exists_lt","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrderTop α\ns : Set α\nhs : s.Infinite\na : α\n⊢ Exists fun b => And (Membership.mem s b) (LT.lt b a)","decl":"theorem _root_.Set.Infinite.exists_lt (hs : s.Infinite) : ∀ a, ∃ b ∈ s, b < a :=\n  not_bddBelow_iff.1 hs.not_bddBelow\n\n"}
{"name":"Set.infinite_iff_exists_lt","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : LocallyFiniteOrderTop α\ns : Set α\ninst✝ : Nonempty α\n⊢ Iff s.Infinite (∀ (a : α), Exists fun b => And (Membership.mem s b) (LT.lt b a))","decl":"theorem _root_.Set.infinite_iff_exists_lt [Nonempty α] : s.Infinite ↔ ∀ a, ∃ b ∈ s, b < a :=\n  ⟨Set.Infinite.exists_lt, Set.infinite_of_forall_exists_lt⟩\n\n"}
{"name":"Finset.Ioi_disjUnion_Iio","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝³ : LinearOrder α\ninst✝² : Fintype α\ninst✝¹ : LocallyFiniteOrderTop α\ninst✝ : LocallyFiniteOrderBot α\na : α\n⊢ Eq ((Finset.Ioi a).disjUnion (Finset.Iio a) ⋯) (HasCompl.compl (Singleton.singleton a))","decl":"theorem Ioi_disjUnion_Iio (a : α) :\n    (Ioi a).disjUnion (Iio a) (disjoint_Ioi_Iio a) = ({a} : Finset α)ᶜ := by\n  ext\n  simp [eq_comm]\n\n"}
{"name":"Finset.uIcc_toDual","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ Eq (Finset.uIcc (OrderDual.toDual a) (OrderDual.toDual b)) (Finset.map OrderDual.toDual.toEmbedding (Finset.uIcc a b))","decl":"theorem uIcc_toDual (a b : α) : [[toDual a, toDual b]] = [[a, b]].map toDual.toEmbedding :=\n  Icc_toDual (a ⊔ b) (a ⊓ b)\n\n"}
{"name":"Finset.uIcc_of_le","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Finset.uIcc a b) (Finset.Icc a b)","decl":"@[simp]\ntheorem uIcc_of_le (h : a ≤ b) : [[a, b]] = Icc a b := by\n  rw [uIcc, inf_eq_left.2 h, sup_eq_right.2 h]\n\n"}
{"name":"Finset.uIcc_of_ge","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na b : α\nh : LE.le b a\n⊢ Eq (Finset.uIcc a b) (Finset.Icc b a)","decl":"@[simp]\ntheorem uIcc_of_ge (h : b ≤ a) : [[a, b]] = Icc b a := by\n  rw [uIcc, inf_eq_right.2 h, sup_eq_left.2 h]\n\n"}
{"name":"Finset.uIcc_comm","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ Eq (Finset.uIcc a b) (Finset.uIcc b a)","decl":"theorem uIcc_comm (a b : α) : [[a, b]] = [[b, a]] := by\n  rw [uIcc, uIcc, inf_comm, sup_comm]\n\n"}
{"name":"Finset.uIcc_self","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na : α\n⊢ Eq (Finset.uIcc a a) (Singleton.singleton a)","decl":"theorem uIcc_self : [[a, a]] = {a} := by simp [uIcc]\n\n"}
{"name":"Finset.nonempty_uIcc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ (Finset.uIcc a b).Nonempty","decl":"@[simp]\ntheorem nonempty_uIcc : Finset.Nonempty [[a, b]] :=\n  nonempty_Icc.2 inf_le_sup\n\n"}
{"name":"Finset.Icc_subset_uIcc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ HasSubset.Subset (Finset.Icc a b) (Finset.uIcc a b)","decl":"theorem Icc_subset_uIcc : Icc a b ⊆ [[a, b]] :=\n  Icc_subset_Icc inf_le_left le_sup_right\n\n"}
{"name":"Finset.Icc_subset_uIcc'","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ HasSubset.Subset (Finset.Icc b a) (Finset.uIcc a b)","decl":"theorem Icc_subset_uIcc' : Icc b a ⊆ [[a, b]] :=\n  Icc_subset_Icc inf_le_right le_sup_left\n\n"}
{"name":"Finset.left_mem_uIcc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ Membership.mem (Finset.uIcc a b) a","decl":"theorem left_mem_uIcc : a ∈ [[a, b]] :=\n  mem_Icc.2 ⟨inf_le_left, le_sup_left⟩\n\n"}
{"name":"Finset.right_mem_uIcc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ Membership.mem (Finset.uIcc a b) b","decl":"theorem right_mem_uIcc : b ∈ [[a, b]] :=\n  mem_Icc.2 ⟨inf_le_right, le_sup_right⟩\n\n"}
{"name":"Finset.mem_uIcc_of_le","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na b x : α\nha : LE.le a x\nhb : LE.le x b\n⊢ Membership.mem (Finset.uIcc a b) x","decl":"theorem mem_uIcc_of_le (ha : a ≤ x) (hb : x ≤ b) : x ∈ [[a, b]] :=\n  Icc_subset_uIcc <| mem_Icc.2 ⟨ha, hb⟩\n\n"}
{"name":"Finset.mem_uIcc_of_ge","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na b x : α\nhb : LE.le b x\nha : LE.le x a\n⊢ Membership.mem (Finset.uIcc a b) x","decl":"theorem mem_uIcc_of_ge (hb : b ≤ x) (ha : x ≤ a) : x ∈ [[a, b]] :=\n  Icc_subset_uIcc' <| mem_Icc.2 ⟨hb, ha⟩\n\n"}
{"name":"Finset.uIcc_subset_uIcc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na₁ a₂ b₁ b₂ : α\nh₁ : Membership.mem (Finset.uIcc a₂ b₂) a₁\nh₂ : Membership.mem (Finset.uIcc a₂ b₂) b₁\n⊢ HasSubset.Subset (Finset.uIcc a₁ b₁) (Finset.uIcc a₂ b₂)","decl":"theorem uIcc_subset_uIcc (h₁ : a₁ ∈ [[a₂, b₂]]) (h₂ : b₁ ∈ [[a₂, b₂]]) :\n    [[a₁, b₁]] ⊆ [[a₂, b₂]] := by\n  rw [mem_uIcc] at h₁ h₂\n  exact Icc_subset_Icc (_root_.le_inf h₁.1 h₂.1) (_root_.sup_le h₁.2 h₂.2)\n\n"}
{"name":"Finset.uIcc_subset_Icc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na₁ a₂ b₁ b₂ : α\nha : Membership.mem (Finset.Icc a₂ b₂) a₁\nhb : Membership.mem (Finset.Icc a₂ b₂) b₁\n⊢ HasSubset.Subset (Finset.uIcc a₁ b₁) (Finset.Icc a₂ b₂)","decl":"theorem uIcc_subset_Icc (ha : a₁ ∈ Icc a₂ b₂) (hb : b₁ ∈ Icc a₂ b₂) : [[a₁, b₁]] ⊆ Icc a₂ b₂ := by\n  rw [mem_Icc] at ha hb\n  exact Icc_subset_Icc (_root_.le_inf ha.1 hb.1) (_root_.sup_le ha.2 hb.2)\n\n"}
{"name":"Finset.uIcc_subset_uIcc_iff_mem","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na₁ a₂ b₁ b₂ : α\n⊢ Iff (HasSubset.Subset (Finset.uIcc a₁ b₁) (Finset.uIcc a₂ b₂)) (And (Membership.mem (Finset.uIcc a₂ b₂) a₁) (Membership.mem (Finset.uIcc a₂ b₂) b₁))","decl":"theorem uIcc_subset_uIcc_iff_mem : [[a₁, b₁]] ⊆ [[a₂, b₂]] ↔ a₁ ∈ [[a₂, b₂]] ∧ b₁ ∈ [[a₂, b₂]] :=\n  ⟨fun h => ⟨h left_mem_uIcc, h right_mem_uIcc⟩, fun h => uIcc_subset_uIcc h.1 h.2⟩\n\n"}
{"name":"Finset.uIcc_subset_uIcc_iff_le'","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na₁ a₂ b₁ b₂ : α\n⊢ Iff (HasSubset.Subset (Finset.uIcc a₁ b₁) (Finset.uIcc a₂ b₂)) (And (LE.le (Min.min a₂ b₂) (Min.min a₁ b₁)) (LE.le (Max.max a₁ b₁) (Max.max a₂ b₂)))","decl":"theorem uIcc_subset_uIcc_iff_le' :\n    [[a₁, b₁]] ⊆ [[a₂, b₂]] ↔ a₂ ⊓ b₂ ≤ a₁ ⊓ b₁ ∧ a₁ ⊔ b₁ ≤ a₂ ⊔ b₂ :=\n  Icc_subset_Icc_iff inf_le_sup\n\n"}
{"name":"Finset.uIcc_subset_uIcc_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na b x : α\nh : Membership.mem (Finset.uIcc a b) x\n⊢ HasSubset.Subset (Finset.uIcc x b) (Finset.uIcc a b)","decl":"theorem uIcc_subset_uIcc_right (h : x ∈ [[a, b]]) : [[x, b]] ⊆ [[a, b]] :=\n  uIcc_subset_uIcc h right_mem_uIcc\n\n"}
{"name":"Finset.uIcc_subset_uIcc_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Lattice α\ninst✝ : LocallyFiniteOrder α\na b x : α\nh : Membership.mem (Finset.uIcc a b) x\n⊢ HasSubset.Subset (Finset.uIcc a x) (Finset.uIcc a b)","decl":"theorem uIcc_subset_uIcc_left (h : x ∈ [[a, b]]) : [[a, x]] ⊆ [[a, b]] :=\n  uIcc_subset_uIcc left_mem_uIcc h\n\n"}
{"name":"Finset.eq_of_mem_uIcc_of_mem_uIcc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DistribLattice α\ninst✝ : LocallyFiniteOrder α\na b c : α\na✝¹ : Membership.mem (Finset.uIcc b c) a\na✝ : Membership.mem (Finset.uIcc a c) b\n⊢ Eq a b","decl":"theorem eq_of_mem_uIcc_of_mem_uIcc : a ∈ [[b, c]] → b ∈ [[a, c]] → a = b := by\n  simp_rw [mem_uIcc]\n  exact Set.eq_of_mem_uIcc_of_mem_uIcc\n\n"}
{"name":"Finset.eq_of_mem_uIcc_of_mem_uIcc'","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DistribLattice α\ninst✝ : LocallyFiniteOrder α\na b c : α\na✝¹ : Membership.mem (Finset.uIcc a c) b\na✝ : Membership.mem (Finset.uIcc a b) c\n⊢ Eq b c","decl":"theorem eq_of_mem_uIcc_of_mem_uIcc' : b ∈ [[a, c]] → c ∈ [[a, b]] → b = c := by\n  simp_rw [mem_uIcc]\n  exact Set.eq_of_mem_uIcc_of_mem_uIcc'\n\n"}
{"name":"Finset.uIcc_injective_right","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DistribLattice α\ninst✝ : LocallyFiniteOrder α\na : α\n⊢ Function.Injective fun b => Finset.uIcc b a","decl":"theorem uIcc_injective_right (a : α) : Injective fun b => [[b, a]] := fun b c h => by\n  rw [Finset.ext_iff] at h\n  exact eq_of_mem_uIcc_of_mem_uIcc ((h _).1 left_mem_uIcc) ((h _).2 left_mem_uIcc)\n\n"}
{"name":"Finset.uIcc_injective_left","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : DistribLattice α\ninst✝ : LocallyFiniteOrder α\na : α\n⊢ Function.Injective (Finset.uIcc a)","decl":"theorem uIcc_injective_left (a : α) : Injective (uIcc a) := by\n  simpa only [uIcc_comm] using uIcc_injective_right a\n\n"}
{"name":"Finset.Icc_min_max","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ Eq (Finset.Icc (Min.min a b) (Max.max a b)) (Finset.uIcc a b)","decl":"theorem Icc_min_max : Icc (min a b) (max a b) = [[a, b]] :=\n  rfl\n\n"}
{"name":"Finset.uIcc_of_not_le","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b : α\nh : Not (LE.le a b)\n⊢ Eq (Finset.uIcc a b) (Finset.Icc b a)","decl":"theorem uIcc_of_not_le (h : ¬a ≤ b) : [[a, b]] = Icc b a :=\n  uIcc_of_ge <| le_of_not_ge h\n\n"}
{"name":"Finset.uIcc_of_not_ge","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b : α\nh : Not (LE.le b a)\n⊢ Eq (Finset.uIcc a b) (Finset.Icc a b)","decl":"theorem uIcc_of_not_ge (h : ¬b ≤ a) : [[a, b]] = Icc a b :=\n  uIcc_of_le <| le_of_not_ge h\n\n"}
{"name":"Finset.uIcc_eq_union","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b : α\n⊢ Eq (Finset.uIcc a b) (Union.union (Finset.Icc a b) (Finset.Icc b a))","decl":"theorem uIcc_eq_union : [[a, b]] = Icc a b ∪ Icc b a :=\n  coe_injective <| by\n    push_cast\n    exact Set.uIcc_eq_union\n\n"}
{"name":"Finset.mem_uIcc'","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\n⊢ Iff (Membership.mem (Finset.uIcc b c) a) (Or (And (LE.le b a) (LE.le a c)) (And (LE.le c a) (LE.le a b)))","decl":"theorem mem_uIcc' : a ∈ [[b, c]] ↔ b ≤ a ∧ a ≤ c ∨ c ≤ a ∧ a ≤ b := by simp [uIcc_eq_union]\n\n"}
{"name":"Finset.not_mem_uIcc_of_lt","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\na✝¹ : LT.lt c a\na✝ : LT.lt c b\n⊢ Not (Membership.mem (Finset.uIcc a b) c)","decl":"theorem not_mem_uIcc_of_lt : c < a → c < b → c ∉ [[a, b]] := by\n  rw [mem_uIcc]\n  exact Set.not_mem_uIcc_of_lt\n\n"}
{"name":"Finset.not_mem_uIcc_of_gt","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\na✝¹ : LT.lt a c\na✝ : LT.lt b c\n⊢ Not (Membership.mem (Finset.uIcc a b) c)","decl":"theorem not_mem_uIcc_of_gt : a < c → b < c → c ∉ [[a, b]] := by\n  rw [mem_uIcc]\n  exact Set.not_mem_uIcc_of_gt\n\n"}
{"name":"Finset.uIcc_subset_uIcc_iff_le","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na₁ a₂ b₁ b₂ : α\n⊢ Iff (HasSubset.Subset (Finset.uIcc a₁ b₁) (Finset.uIcc a₂ b₂)) (And (LE.le (Min.min a₂ b₂) (Min.min a₁ b₁)) (LE.le (Max.max a₁ b₁) (Max.max a₂ b₂)))","decl":"theorem uIcc_subset_uIcc_iff_le :\n    [[a₁, b₁]] ⊆ [[a₂, b₂]] ↔ min a₂ b₂ ≤ min a₁ b₁ ∧ max a₁ b₁ ≤ max a₂ b₂ :=\n  uIcc_subset_uIcc_iff_le'\n\n"}
{"name":"Finset.uIcc_subset_uIcc_union_uIcc","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : LocallyFiniteOrder α\na b c : α\n⊢ HasSubset.Subset (Finset.uIcc a c) (Union.union (Finset.uIcc a b) (Finset.uIcc b c))","decl":"/-- A sort of triangle inequality. -/\ntheorem uIcc_subset_uIcc_union_uIcc : [[a, c]] ⊆ [[a, b]] ∪ [[b, c]] :=\n  coe_subset.1 <| by\n    push_cast\n    exact Set.uIcc_subset_uIcc_union_uIcc\n\n"}
{"name":"transGen_wcovBy_of_le","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nx y : α\nhxy : LE.le x y\n⊢ Relation.TransGen (fun x1 x2 => WCovBy x1 x2) x y","decl":"set_option linter.unusedVariables false in -- `have` for wf induction triggers linter\nlemma transGen_wcovBy_of_le [Preorder α] [LocallyFiniteOrder α] {x y : α} (hxy : x ≤ y) :\n    TransGen (· ⩿ ·) x y := by\n  -- We proceed by well-founded induction on the cardinality of `Icc x y`.\n  -- It's impossible for the cardinality to be zero since `x ≤ y`\n  have : #(Ico x y) < #(Icc x y) := card_lt_card <|\n    ⟨Ico_subset_Icc_self, not_subset.mpr ⟨y, ⟨right_mem_Icc.mpr hxy, right_not_mem_Ico⟩⟩⟩\n  by_cases hxy' : y ≤ x\n  -- If `y ≤ x`, then `x ⩿ y`\n  · exact .single <| wcovBy_of_le_of_le hxy hxy'\n  /- and if `¬ y ≤ x`, then `x < y`, not because it is a linear order, but because `x ≤ y`\n  already. In that case, since `z` is maximal in `Ico x y`, then `z ⩿ y` and we can use the\n  induction hypothesis to show that `Relation.TransGen (· ⩿ ·) x z`. -/\n  · have h_non : (Ico x y).Nonempty := ⟨x, mem_Ico.mpr ⟨le_rfl, lt_of_le_not_le hxy hxy'⟩⟩\n    obtain ⟨z, z_mem, hz⟩ := (Ico x y).exists_maximal h_non\n    have z_card := calc\n      #(Icc x z) ≤ #(Ico x y) := card_le_card <| Icc_subset_Ico_right (mem_Ico.mp z_mem).2\n      _          < #(Icc x y) := this\n    have h₁ := transGen_wcovBy_of_le (mem_Ico.mp z_mem).1\n    have h₂ : z ⩿ y := by\n      refine ⟨(mem_Ico.mp z_mem).2.le, fun c hzc hcy ↦ hz c ?_ hzc⟩\n      exact mem_Ico.mpr <| ⟨(mem_Ico.mp z_mem).1.trans hzc.le, hcy⟩\n    exact .tail h₁ h₂\ntermination_by #(Icc x y)\n\n"}
{"name":"le_iff_transGen_wcovBy","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nx y : α\n⊢ Iff (LE.le x y) (Relation.TransGen (fun x1 x2 => WCovBy x1 x2) x y)","decl":"/-- In a locally finite preorder, `≤` is the transitive closure of `⩿`. -/\nlemma le_iff_transGen_wcovBy [Preorder α] [LocallyFiniteOrder α] {x y : α} :\n    x ≤ y ↔ TransGen (· ⩿ ·) x y := by\n  refine ⟨transGen_wcovBy_of_le, fun h ↦ ?_⟩\n  induction h with\n  | single h => exact h.le\n  | tail _ h₁ h₂ => exact h₂.trans h₁.le\n\n"}
{"name":"le_iff_reflTransGen_covBy","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : LocallyFiniteOrder α\nx y : α\n⊢ Iff (LE.le x y) (Relation.ReflTransGen (fun x1 x2 => CovBy x1 x2) x y)","decl":"/-- In a locally finite partial order, `≤` is the reflexive transitive closure of `⋖`. -/\nlemma le_iff_reflTransGen_covBy [PartialOrder α] [LocallyFiniteOrder α] {x y : α} :\n    x ≤ y ↔ ReflTransGen (· ⋖ ·) x y := by\n  rw [le_iff_transGen_wcovBy, wcovBy_eq_reflGen_covBy, transGen_reflGen]\n\n"}
{"name":"transGen_covBy_of_lt","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nx y : α\nhxy : LT.lt x y\n⊢ Relation.TransGen (fun x1 x2 => CovBy x1 x2) x y","decl":"set_option linter.unusedVariables false in -- `have` for wf induction triggers linter\nlemma transGen_covBy_of_lt [Preorder α] [LocallyFiniteOrder α] {x y : α} (hxy : x < y) :\n    TransGen (· ⋖ ·) x y := by\n  -- We proceed by well-founded induction on the cardinality of `Ico x y`.\n  -- It's impossible for the cardinality to be zero since `x < y`\n  have h_non : (Ico x y).Nonempty := ⟨x, mem_Ico.mpr ⟨le_rfl, hxy⟩⟩\n  -- `Ico x y` is a nonempty finset and so contains a maximal element `z` and\n  -- `Ico x z` has cardinality strictly less than the cardinality of `Ico x y`\n  obtain ⟨z, z_mem, hz⟩ := (Ico x y).exists_maximal h_non\n  have z_card : #(Ico x z) < #(Ico x y) := card_lt_card <| ssubset_iff_of_subset\n    (Ico_subset_Ico le_rfl (mem_Ico.mp z_mem).2.le) |>.mpr ⟨z, z_mem, right_not_mem_Ico⟩\n  /- Since `z` is maximal in `Ico x y`, `z ⋖ y`. -/\n  have hzy : z ⋖ y := by\n    refine ⟨(mem_Ico.mp z_mem).2, fun c hc hcy ↦ ?_⟩\n    exact hz _ (mem_Ico.mpr ⟨((mem_Ico.mp z_mem).1.trans_lt hc).le, hcy⟩) hc\n  by_cases hxz : x < z\n  /- when `x < z`, then we may use the induction hypothesis to get a chain\n  `Relation.TransGen (· ⋖ ·) x z`, which we can extend with `Relation.TransGen.tail`. -/\n  · exact .tail (transGen_covBy_of_lt hxz) hzy\n  /- when `¬ x < z`, then actually `z ≤ x` (not because it's a linear order, but because\n  `x ≤ z`), and since `z ⋖ y` we conclude that `x ⋖ y` , then `Relation.TransGen.single`. -/\n  · simp only [lt_iff_le_not_le, not_and, not_not] at hxz\n    exact .single (hzy.of_le_of_lt (hxz (mem_Ico.mp z_mem).1) hxy)\ntermination_by #(Ico x y)\n\n"}
{"name":"lt_iff_transGen_covBy","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\nx y : α\n⊢ Iff (LT.lt x y) (Relation.TransGen (fun x1 x2 => CovBy x1 x2) x y)","decl":"/-- In a locally finite preorder, `<` is the transitive closure of `⋖`. -/\nlemma lt_iff_transGen_covBy [Preorder α] [LocallyFiniteOrder α] {x y : α} :\n    x < y ↔ TransGen (· ⋖ ·) x y := by\n  refine ⟨transGen_covBy_of_lt, fun h ↦ ?_⟩\n  induction h with\n  | single hx => exact hx.1\n  | tail _ hb ih => exact ih.trans hb.1\n\n"}
{"name":"monotone_iff_forall_wcovBy","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Monotone f) (∀ (a b : α), WCovBy a b → LE.le (f a) (f b))","decl":"/-- A function from a locally finite preorder is monotone if and only if it is monotone when\nrestricted to pairs satisfying `a ⩿ b`. -/\nlemma monotone_iff_forall_wcovBy [Preorder α] [LocallyFiniteOrder α] [Preorder β]\n    (f : α → β) : Monotone f ↔ ∀ a b : α, a ⩿ b → f a ≤ f b := by\n  refine ⟨fun hf _ _ h ↦ hf h.le, fun h a b hab ↦ ?_⟩\n  simpa [transGen_eq_self (r := ((· : β) ≤ ·)) transitive_le]\n    using TransGen.lift f h <| le_iff_transGen_wcovBy.mp hab\n\n"}
{"name":"monotone_iff_forall_covBy","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Monotone f) (∀ (a b : α), CovBy a b → LE.le (f a) (f b))","decl":"/-- A function from a locally finite partial order is monotone if and only if it is monotone when\nrestricted to pairs satisfying `a ⋖ b`. -/\nlemma monotone_iff_forall_covBy [PartialOrder α] [LocallyFiniteOrder α] [Preorder β]\n    (f : α → β) : Monotone f ↔ ∀ a b : α, a ⋖ b → f a ≤ f b := by\n  refine ⟨fun hf _ _ h ↦ hf h.le, fun h a b hab ↦ ?_⟩\n  simpa [reflTransGen_eq_self (r := ((· : β) ≤ ·)) IsRefl.reflexive transitive_le]\n    using ReflTransGen.lift f h <| le_iff_reflTransGen_covBy.mp hab\n\n"}
{"name":"strictMono_iff_forall_covBy","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictMono f) (∀ (a b : α), CovBy a b → LT.lt (f a) (f b))","decl":"/-- A function from a locally finite preorder is strictly monotone if and only if it is strictly\nmonotone when restricted to pairs satisfying `a ⋖ b`. -/\nlemma strictMono_iff_forall_covBy [Preorder α] [LocallyFiniteOrder α] [Preorder β]\n    (f : α → β) : StrictMono f ↔ ∀ a b : α, a ⋖ b → f a < f b := by\n  refine ⟨fun hf _ _ h ↦ hf h.lt, fun h a b hab ↦ ?_⟩\n  have := Relation.TransGen.lift f h (a := a) (b := b)\n  rw [← lt_iff_transGen_covBy, transGen_eq_self (@lt_trans β _)] at this\n  exact this hab\n\n"}
{"name":"antitone_iff_forall_wcovBy","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Antitone f) (∀ (a b : α), WCovBy a b → LE.le (f b) (f a))","decl":"/-- A function from a locally finite preorder is antitone if and only if it is antitone when\nrestricted to pairs satisfying `a ⩿ b`. -/\nlemma antitone_iff_forall_wcovBy [Preorder α] [LocallyFiniteOrder α] [Preorder β]\n    (f : α → β) : Antitone f ↔ ∀ a b : α, a ⩿ b → f b ≤ f a :=\n  monotone_iff_forall_wcovBy (β := βᵒᵈ) f\n\n"}
{"name":"antitone_iff_forall_covBy","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : PartialOrder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (Antitone f) (∀ (a b : α), CovBy a b → LE.le (f b) (f a))","decl":"/-- A function from a locally finite partial order is antitone if and only if it is antitone when\nrestricted to pairs satisfying `a ⋖ b`. -/\nlemma antitone_iff_forall_covBy [PartialOrder α] [LocallyFiniteOrder α] [Preorder β]\n    (f : α → β) : Antitone f ↔ ∀ a b : α, a ⋖ b → f b ≤ f a :=\n  monotone_iff_forall_covBy (β := βᵒᵈ) f\n\n"}
{"name":"strictAnti_iff_forall_covBy","module":"Mathlib.Order.Interval.Finset.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Preorder α\ninst✝¹ : LocallyFiniteOrder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (StrictAnti f) (∀ (a b : α), CovBy a b → LT.lt (f b) (f a))","decl":"/-- A function from a locally finite preorder is strictly antitone if and only if it is strictly\nantitone when restricted to pairs satisfying `a ⋖ b`. -/\nlemma strictAnti_iff_forall_covBy [Preorder α] [LocallyFiniteOrder α] [Preorder β]\n    (f : α → β) : StrictAnti f ↔ ∀ a b : α, a ⋖ b → f b < f a :=\n  strictMono_iff_forall_covBy (β := βᵒᵈ) f\n\n"}
