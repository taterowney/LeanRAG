{"name":"Polynomial.coe_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\n⊢ Eq (⇑(Polynomial.expand R p)) (Polynomial.eval₂ Polynomial.C (HPow.hPow Polynomial.X p))","decl":"theorem coe_expand : (expand R p : R[X] → R[X]) = eval₂ C (X ^ p) :=\n  rfl\n\n"}
{"name":"Polynomial.expand_eq_comp_X_pow","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nf : Polynomial R\n⊢ Eq ((Polynomial.expand R p) f) (f.comp (HPow.hPow Polynomial.X p))","decl":"theorem expand_eq_comp_X_pow {f : R[X]} : expand R p f = f.comp (X ^ p) := rfl\n\n"}
{"name":"Polynomial.expand_eq_sum","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nf : Polynomial R\n⊢ Eq ((Polynomial.expand R p) f) (f.sum fun e a => HMul.hMul (Polynomial.C a) (HPow.hPow (HPow.hPow Polynomial.X p) e))","decl":"theorem expand_eq_sum {f : R[X]} : expand R p f = f.sum fun e a => C a * (X ^ p) ^ e := by\n  simp [expand, eval₂]\n\n"}
{"name":"Polynomial.expand_C","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nr : R\n⊢ Eq ((Polynomial.expand R p) (Polynomial.C r)) (Polynomial.C r)","decl":"@[simp]\ntheorem expand_C (r : R) : expand R p (C r) = C r :=\n  eval₂_C _ _\n\n"}
{"name":"Polynomial.expand_X","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\n⊢ Eq ((Polynomial.expand R p) Polynomial.X) (HPow.hPow Polynomial.X p)","decl":"@[simp]\ntheorem expand_X : expand R p X = X ^ p :=\n  eval₂_X _ _\n\n"}
{"name":"Polynomial.expand_monomial","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Nat\nr : R\n⊢ Eq ((Polynomial.expand R p) ((Polynomial.monomial q) r)) ((Polynomial.monomial (HMul.hMul q p)) r)","decl":"@[simp]\ntheorem expand_monomial (r : R) : expand R p (monomial q r) = monomial (q * p) r := by\n  simp_rw [← smul_X_eq_monomial, map_smul, map_pow, expand_X, mul_comm, pow_mul]\n\n"}
{"name":"Polynomial.expand_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Nat\nf : Polynomial R\n⊢ Eq ((Polynomial.expand R p) ((Polynomial.expand R q) f)) ((Polynomial.expand R (HMul.hMul p q)) f)","decl":"theorem expand_expand (f : R[X]) : expand R p (expand R q f) = expand R (p * q) f :=\n  Polynomial.induction_on f (fun r => by simp_rw [expand_C])\n    (fun f g ihf ihg => by simp_rw [map_add, ihf, ihg]) fun n r _ => by\n    simp_rw [map_mul, expand_C, map_pow, expand_X, map_pow, expand_X, pow_mul]\n\n"}
{"name":"Polynomial.expand_mul","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Nat\nf : Polynomial R\n⊢ Eq ((Polynomial.expand R (HMul.hMul p q)) f) ((Polynomial.expand R p) ((Polynomial.expand R q) f))","decl":"theorem expand_mul (f : R[X]) : expand R (p * q) f = expand R p (expand R q f) :=\n  (expand_expand p q f).symm\n\n"}
{"name":"Polynomial.expand_zero","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\n⊢ Eq ((Polynomial.expand R 0) f) (Polynomial.C (Polynomial.eval 1 f))","decl":"@[simp]\ntheorem expand_zero (f : R[X]) : expand R 0 f = C (eval 1 f) := by simp [expand]\n\n"}
{"name":"Polynomial.expand_one","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\n⊢ Eq ((Polynomial.expand R 1) f) f","decl":"@[simp]\ntheorem expand_one (f : R[X]) : expand R 1 f = f :=\n  Polynomial.induction_on f (fun r => by rw [expand_C])\n    (fun f g ihf ihg => by rw [map_add, ihf, ihg]) fun n r _ => by\n    rw [map_mul, expand_C, map_pow, expand_X, pow_one]\n\n"}
{"name":"Polynomial.expand_pow","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Nat\nf : Polynomial R\n⊢ Eq ((Polynomial.expand R (HPow.hPow p q)) f) (Nat.iterate (⇑(Polynomial.expand R p)) q f)","decl":"theorem expand_pow (f : R[X]) : expand R (p ^ q) f = (expand R p)^[q] f :=\n  Nat.recOn q (by rw [pow_zero, expand_one, Function.iterate_zero, id]) fun n ih => by\n    rw [Function.iterate_succ_apply', pow_succ', expand_mul, ih]\n\n"}
{"name":"Polynomial.derivative_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nf : Polynomial R\n⊢ Eq (Polynomial.derivative ((Polynomial.expand R p) f)) (HMul.hMul ((Polynomial.expand R p) (Polynomial.derivative f)) (HMul.hMul (↑p) (HPow.hPow Polynomial.X (HSub.hSub p 1))))","decl":"theorem derivative_expand (f : R[X]) : Polynomial.derivative (expand R p f) =\n    expand R p (Polynomial.derivative f) * (p * (X ^ (p - 1) : R[X])) := by\n  rw [coe_expand, derivative_eval₂_C, derivative_pow, C_eq_natCast, derivative_X, mul_one]\n\n"}
{"name":"Polynomial.coeff_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nhp : LT.lt 0 p\nf : Polynomial R\nn : Nat\n⊢ Eq (((Polynomial.expand R p) f).coeff n) (ite (Dvd.dvd p n) (f.coeff (HDiv.hDiv n p)) 0)","decl":"theorem coeff_expand {p : ℕ} (hp : 0 < p) (f : R[X]) (n : ℕ) :\n    (expand R p f).coeff n = if p ∣ n then f.coeff (n / p) else 0 := by\n  simp only [expand_eq_sum]\n  simp_rw [coeff_sum, ← pow_mul, C_mul_X_pow_eq_monomial, coeff_monomial, sum]\n  split_ifs with h\n  · rw [Finset.sum_eq_single (n / p), Nat.mul_div_cancel' h, if_pos rfl]\n    · intro b _ hb2\n      rw [if_neg]\n      intro hb3\n      apply hb2\n      rw [← hb3, Nat.mul_div_cancel_left b hp]\n    · intro hn\n      rw [not_mem_support_iff.1 hn]\n      split_ifs <;> rfl\n  · rw [Finset.sum_eq_zero]\n    intro k _\n    rw [if_neg]\n    exact fun hkn => h ⟨k, hkn.symm⟩\n\n"}
{"name":"Polynomial.coeff_expand_mul","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nhp : LT.lt 0 p\nf : Polynomial R\nn : Nat\n⊢ Eq (((Polynomial.expand R p) f).coeff (HMul.hMul n p)) (f.coeff n)","decl":"@[simp]\ntheorem coeff_expand_mul {p : ℕ} (hp : 0 < p) (f : R[X]) (n : ℕ) :\n    (expand R p f).coeff (n * p) = f.coeff n := by\n  rw [coeff_expand hp, if_pos (dvd_mul_left _ _), Nat.mul_div_cancel _ hp]\n\n"}
{"name":"Polynomial.coeff_expand_mul'","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nhp : LT.lt 0 p\nf : Polynomial R\nn : Nat\n⊢ Eq (((Polynomial.expand R p) f).coeff (HMul.hMul p n)) (f.coeff n)","decl":"@[simp]\ntheorem coeff_expand_mul' {p : ℕ} (hp : 0 < p) (f : R[X]) (n : ℕ) :\n    (expand R p f).coeff (p * n) = f.coeff n := by rw [mul_comm, coeff_expand_mul hp]\n\n"}
{"name":"Polynomial.expand_injective","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nn : Nat\nhn : LT.lt 0 n\n⊢ Function.Injective ⇑(Polynomial.expand R n)","decl":"/-- Expansion is injective. -/\ntheorem expand_injective {n : ℕ} (hn : 0 < n) : Function.Injective (expand R n) := fun g g' H =>\n  ext fun k => by rw [← coeff_expand_mul hn, H, coeff_expand_mul hn]\n\n"}
{"name":"Polynomial.expand_inj","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nhp : LT.lt 0 p\nf g : Polynomial R\n⊢ Iff (Eq ((Polynomial.expand R p) f) ((Polynomial.expand R p) g)) (Eq f g)","decl":"theorem expand_inj {p : ℕ} (hp : 0 < p) {f g : R[X]} : expand R p f = expand R p g ↔ f = g :=\n  (expand_injective hp).eq_iff\n\n"}
{"name":"Polynomial.expand_eq_zero","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nhp : LT.lt 0 p\nf : Polynomial R\n⊢ Iff (Eq ((Polynomial.expand R p) f) 0) (Eq f 0)","decl":"theorem expand_eq_zero {p : ℕ} (hp : 0 < p) {f : R[X]} : expand R p f = 0 ↔ f = 0 :=\n  (expand_injective hp).eq_iff' (map_zero _)\n\n"}
{"name":"Polynomial.expand_ne_zero","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nhp : LT.lt 0 p\nf : Polynomial R\n⊢ Iff (Ne ((Polynomial.expand R p) f) 0) (Ne f 0)","decl":"theorem expand_ne_zero {p : ℕ} (hp : 0 < p) {f : R[X]} : expand R p f ≠ 0 ↔ f ≠ 0 :=\n  (expand_eq_zero hp).not\n\n"}
{"name":"Polynomial.expand_eq_C","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nhp : LT.lt 0 p\nf : Polynomial R\nr : R\n⊢ Iff (Eq ((Polynomial.expand R p) f) (Polynomial.C r)) (Eq f (Polynomial.C r))","decl":"theorem expand_eq_C {p : ℕ} (hp : 0 < p) {f : R[X]} {r : R} : expand R p f = C r ↔ f = C r := by\n  rw [← expand_C, expand_inj hp, expand_C]\n\n"}
{"name":"Polynomial.natDegree_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nf : Polynomial R\n⊢ Eq ((Polynomial.expand R p) f).natDegree (HMul.hMul f.natDegree p)","decl":"theorem natDegree_expand (p : ℕ) (f : R[X]) : (expand R p f).natDegree = f.natDegree * p := by\n  rcases p.eq_zero_or_pos with hp | hp\n  · rw [hp, coe_expand, pow_zero, mul_zero, ← C_1, eval₂_hom, natDegree_C]\n  by_cases hf : f = 0\n  · rw [hf, map_zero, natDegree_zero, zero_mul]\n  have hf1 : expand R p f ≠ 0 := mt (expand_eq_zero hp).1 hf\n  rw [← WithBot.coe_eq_coe]\n  convert (degree_eq_natDegree hf1).symm -- Porting note: was `rw [degree_eq_natDegree hf1]`\n  symm\n  refine le_antisymm ((degree_le_iff_coeff_zero _ _).2 fun n hn => ?_) ?_\n  · rw [coeff_expand hp]\n    split_ifs with hpn\n    · rw [coeff_eq_zero_of_natDegree_lt]\n      contrapose! hn\n      erw [WithBot.coe_le_coe, ← Nat.div_mul_cancel hpn]\n      exact Nat.mul_le_mul_right p hn\n    · rfl\n  · refine le_degree_of_ne_zero ?_\n    erw [coeff_expand_mul hp, ← leadingCoeff]\n    exact mt leadingCoeff_eq_zero.1 hf\n\n"}
{"name":"Polynomial.leadingCoeff_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nf : Polynomial R\nhp : LT.lt 0 p\n⊢ Eq ((Polynomial.expand R p) f).leadingCoeff f.leadingCoeff","decl":"theorem leadingCoeff_expand {p : ℕ} {f : R[X]} (hp : 0 < p) :\n    (expand R p f).leadingCoeff = f.leadingCoeff := by\n  simp_rw [leadingCoeff, natDegree_expand, coeff_expand_mul hp]\n\n"}
{"name":"Polynomial.monic_expand_iff","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nf : Polynomial R\nhp : LT.lt 0 p\n⊢ Iff ((Polynomial.expand R p) f).Monic f.Monic","decl":"theorem monic_expand_iff {p : ℕ} {f : R[X]} (hp : 0 < p) : (expand R p f).Monic ↔ f.Monic := by\n  simp only [Monic, leadingCoeff_expand hp]\n\n"}
{"name":"Polynomial.Monic.expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nf : Polynomial R\nhp : LT.lt 0 p\na✝ : f.Monic\n⊢ ((Polynomial.expand R p) f).Monic","decl":"alias ⟨_, Monic.expand⟩ := monic_expand_iff\n\n"}
{"name":"Polynomial.map_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\nS : Type v\ninst✝ : CommSemiring S\np : Nat\nf : RingHom R S\nq : Polynomial R\n⊢ Eq (Polynomial.map f ((Polynomial.expand R p) q)) ((Polynomial.expand S p) (Polynomial.map f q))","decl":"theorem map_expand {p : ℕ} {f : R →+* S} {q : R[X]} :\n    map f (expand R p q) = expand S p (map f q) := by\n  by_cases hp : p = 0\n  · simp [hp]\n  ext\n  rw [coeff_map, coeff_expand (Nat.pos_of_ne_zero hp), coeff_expand (Nat.pos_of_ne_zero hp)]\n  split_ifs <;> simp_all\n\n"}
{"name":"Polynomial.expand_eval","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nP : Polynomial R\nr : R\n⊢ Eq (Polynomial.eval r ((Polynomial.expand R p) P)) (Polynomial.eval (HPow.hPow r p) P)","decl":"@[simp]\ntheorem expand_eval (p : ℕ) (P : R[X]) (r : R) : eval r (expand R p P) = eval (r ^ p) P := by\n  refine Polynomial.induction_on P (fun a => by simp) (fun f g hf hg => ?_) fun n a _ => by simp\n  rw [map_add, eval_add, eval_add, hf, hg]\n\n"}
{"name":"Polynomial.expand_aeval","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type u_1\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\np : Nat\nP : Polynomial R\nr : A\n⊢ Eq ((Polynomial.aeval r) ((Polynomial.expand R p) P)) ((Polynomial.aeval (HPow.hPow r p)) P)","decl":"@[simp]\ntheorem expand_aeval {A : Type*} [Semiring A] [Algebra R A] (p : ℕ) (P : R[X]) (r : A) :\n    aeval r (expand R p P) = aeval (r ^ p) P := by\n  refine Polynomial.induction_on P (fun a => by simp) (fun f g hf hg => ?_) fun n a _ => by simp\n  rw [map_add, aeval_add, aeval_add, hf, hg]\n\n"}
{"name":"Polynomial.coeff_contract","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nhp : Ne p 0\nf : Polynomial R\nn : Nat\n⊢ Eq ((Polynomial.contract p f).coeff n) (f.coeff (HMul.hMul n p))","decl":"theorem coeff_contract {p : ℕ} (hp : p ≠ 0) (f : R[X]) (n : ℕ) :\n    (contract p f).coeff n = f.coeff (n * p) := by\n  simp only [contract, coeff_monomial, sum_ite_eq', finset_sum_coeff, mem_range, not_lt,\n    ite_eq_left_iff]\n  intro hn\n  apply (coeff_eq_zero_of_natDegree_lt _).symm\n  calc\n    f.natDegree < f.natDegree + 1 := Nat.lt_succ_self _\n    _ ≤ n * 1 := by simpa only [mul_one] using hn\n    _ ≤ n * p := mul_le_mul_of_nonneg_left (show 1 ≤ p from hp.bot_lt) (zero_le n)\n\n"}
{"name":"Polynomial.map_contract","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\nS : Type v\ninst✝ : CommSemiring S\np : Nat\nhp : Ne p 0\nf : RingHom R S\nq : Polynomial R\n⊢ Eq (Polynomial.map f (Polynomial.contract p q)) (Polynomial.contract p (Polynomial.map f q))","decl":"theorem map_contract {p : ℕ} (hp : p ≠ 0) {f : R →+* S} {q : R[X]} :\n    (q.contract p).map f = (q.map f).contract p := ext fun n ↦ by\n  simp only [coeff_map, coeff_contract hp]\n\n"}
{"name":"Polynomial.contract_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nf : Polynomial R\nhp : Ne p 0\n⊢ Eq (Polynomial.contract p ((Polynomial.expand R p) f)) f","decl":"theorem contract_expand {f : R[X]} (hp : p ≠ 0) : contract p (expand R p f) = f := by\n  ext\n  simp [coeff_contract hp, coeff_expand hp.bot_lt, Nat.mul_div_cancel _ hp.bot_lt]\n\n"}
{"name":"Polynomial.contract_one","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\n⊢ Eq (Polynomial.contract 1 f) f","decl":"theorem contract_one {f : R[X]} : contract 1 f = f :=\n  ext fun n ↦ by rw [coeff_contract one_ne_zero, mul_one]\n\n"}
{"name":"Polynomial.contract_C","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nr : R\n⊢ Eq (Polynomial.contract p (Polynomial.C r)) (Polynomial.C r)","decl":"@[simp] theorem contract_C (r : R) : contract p (C r) = C r := by simp [contract]\n\n"}
{"name":"Polynomial.contract_add","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nhp : Ne p 0\nf g : Polynomial R\n⊢ Eq (Polynomial.contract p (HAdd.hAdd f g)) (HAdd.hAdd (Polynomial.contract p f) (Polynomial.contract p g))","decl":"theorem contract_add {p : ℕ} (hp : p ≠ 0) (f g : R[X]) :\n    contract p (f + g) = contract p f + contract p g := by\n  ext; simp_rw [coeff_add, coeff_contract hp, coeff_add]\n\n"}
{"name":"Polynomial.contract_mul_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np : Nat\nhp : Ne p 0\nf g : Polynomial R\n⊢ Eq (Polynomial.contract p (HMul.hMul f ((Polynomial.expand R p) g))) (HMul.hMul (Polynomial.contract p f) g)","decl":"theorem contract_mul_expand {p : ℕ} (hp : p ≠ 0) (f g : R[X]) :\n    contract p (f * expand R p g) = contract p f * g := by\n  ext n\n  rw [coeff_contract hp, coeff_mul, coeff_mul, ← sum_subset\n    (s₁ := (antidiagonal n).image fun x ↦ (x.1 * p, x.2 * p)), sum_image]\n  · simp_rw [coeff_expand_mul hp.bot_lt, coeff_contract hp]\n  · intro x hx y hy eq; simpa only [Prod.ext_iff, Nat.mul_right_cancel_iff hp.bot_lt] using eq\n  · simp_rw [subset_iff, mem_image, mem_antidiagonal]; rintro _ ⟨x, rfl, rfl⟩; simp_rw [add_mul]\n  simp_rw [mem_image, mem_antidiagonal]\n  intro ⟨x, y⟩ eq nex\n  by_cases h : p ∣ y\n  · obtain ⟨x, rfl⟩ : p ∣ x := (Nat.dvd_add_iff_left h).mpr (eq ▸ dvd_mul_left p n)\n    obtain ⟨y, rfl⟩ := h\n    refine (nex ⟨⟨x, y⟩, (Nat.mul_right_cancel_iff hp.bot_lt).mp ?_, by simp_rw [mul_comm]⟩).elim\n    rw [← eq, mul_comm, mul_add]\n  · rw [coeff_expand hp.bot_lt, if_neg h, mul_zero]\n\n"}
{"name":"Polynomial.isCoprime_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf g : Polynomial R\np : Nat\nhp : Ne p 0\n⊢ Iff (IsCoprime ((Polynomial.expand R p) f) ((Polynomial.expand R p) g)) (IsCoprime f g)","decl":"@[simp] theorem isCoprime_expand {f g : R[X]} {p : ℕ} (hp : p ≠ 0) :\n    IsCoprime (expand R p f) (expand R p g) ↔ IsCoprime f g :=\n  ⟨fun ⟨a, b, eq⟩ ↦ ⟨contract p a, contract p b, by\n    simp_rw [← contract_mul_expand hp, ← contract_add hp, eq, ← C_1, contract_C]⟩, (·.map _)⟩\n\n"}
{"name":"Polynomial.expand_contract","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝² : CommSemiring R\np : Nat\ninst✝¹ : CharP R p\ninst✝ : NoZeroDivisors R\nf : Polynomial R\nhf : Eq (Polynomial.derivative f) 0\nhp : Ne p 0\n⊢ Eq ((Polynomial.expand R p) (Polynomial.contract p f)) f","decl":"theorem expand_contract [CharP R p] [NoZeroDivisors R] {f : R[X]} (hf : Polynomial.derivative f = 0)\n    (hp : p ≠ 0) : expand R p (contract p f) = f := by\n  ext n\n  rw [coeff_expand hp.bot_lt, coeff_contract hp]\n  split_ifs with h\n  · rw [Nat.div_mul_cancel h]\n  · cases' n with n\n    · exact absurd (dvd_zero p) h\n    have := coeff_derivative f n\n    rw [hf, coeff_zero, zero_eq_mul] at this\n    cases' this with h'\n    · rw [h']\n    rename_i _ _ _ h'\n    rw [← Nat.cast_succ, CharP.cast_eq_zero_iff R p] at h'\n    exact absurd h' h\n\n"}
{"name":"Polynomial.expand_contract'","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝² : CommSemiring R\np : Nat\ninst✝¹ : ExpChar R p\ninst✝ : NoZeroDivisors R\nf : Polynomial R\nhf : Eq (Polynomial.derivative f) 0\n⊢ Eq ((Polynomial.expand R p) (Polynomial.contract p f)) f","decl":"theorem expand_contract' [NoZeroDivisors R] {f : R[X]} (hf : Polynomial.derivative f = 0) :\n    expand R p (contract p f) = f := by\n  obtain _ | @⟨_, hprime, hchar⟩ := ‹ExpChar R p›\n  · rw [expand_one, contract_one]\n  · haveI := Fact.mk hchar; exact expand_contract p hf hprime.ne_zero\n\n"}
{"name":"Polynomial.expand_char","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\nf : Polynomial R\n⊢ Eq (Polynomial.map (frobenius R p) ((Polynomial.expand R p) f)) (HPow.hPow f p)","decl":"theorem expand_char (f : R[X]) : map (frobenius R p) (expand R p f) = f ^ p := by\n  refine f.induction_on' (fun a b ha hb => ?_) fun n a => ?_\n  · rw [map_add, Polynomial.map_add, ha, hb, add_pow_expChar]\n  · rw [expand_monomial, map_monomial, ← C_mul_X_pow_eq_monomial, ← C_mul_X_pow_eq_monomial,\n      mul_pow, ← C.map_pow, frobenius_def]\n    ring\n\n"}
{"name":"Polynomial.map_expand_pow_char","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\np : Nat\ninst✝ : ExpChar R p\nf : Polynomial R\nn : Nat\n⊢ Eq (Polynomial.map (HPow.hPow (frobenius R p) n) ((Polynomial.expand R (HPow.hPow p n)) f)) (HPow.hPow f (HPow.hPow p n))","decl":"theorem map_expand_pow_char (f : R[X]) (n : ℕ) :\n    map (frobenius R p ^ n) (expand R (p ^ n) f) = f ^ p ^ n := by\n  induction n with\n  | zero => simp [RingHom.one_def]\n  | succ _ n_ih =>\n    symm\n    rw [pow_succ, pow_mul, ← n_ih, ← expand_char, pow_succ', RingHom.mul_def, ← map_map, mul_comm,\n      expand_mul, ← map_expand]\n\n"}
{"name":"Polynomial.rootMultiplicity_expand_pow","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝¹ : CommRing R\np n : Nat\ninst✝ : ExpChar R p\nf : Polynomial R\nr : R\n⊢ Eq (Polynomial.rootMultiplicity r ((Polynomial.expand R (HPow.hPow p n)) f)) (HMul.hMul (HPow.hPow p n) (Polynomial.rootMultiplicity (HPow.hPow r (HPow.hPow p n)) f))","decl":"theorem rootMultiplicity_expand_pow :\n    (expand R (p ^ n) f).rootMultiplicity r = p ^ n * f.rootMultiplicity (r ^ p ^ n) := by\n  obtain rfl | h0 := eq_or_ne f 0; · simp\n  obtain ⟨g, hg, ndvd⟩ := f.exists_eq_pow_rootMultiplicity_mul_and_not_dvd h0 (r ^ p ^ n)\n  rw [dvd_iff_isRoot, ← eval_X (x := r), ← eval_pow, ← isRoot_comp, ← expand_eq_comp_X_pow] at ndvd\n  conv_lhs => rw [hg, map_mul, map_pow, map_sub, expand_X, expand_C, map_pow, ← sub_pow_expChar_pow,\n    ← pow_mul, mul_comm, rootMultiplicity_mul_X_sub_C_pow (expand_ne_zero (expChar_pow_pos R p n)\n      |>.mpr <| right_ne_zero_of_mul <| hg ▸ h0), rootMultiplicity_eq_zero ndvd, zero_add]\n\n"}
{"name":"Polynomial.rootMultiplicity_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝¹ : CommRing R\np : Nat\ninst✝ : ExpChar R p\nf : Polynomial R\nr : R\n⊢ Eq (Polynomial.rootMultiplicity r ((Polynomial.expand R p) f)) (HMul.hMul p (Polynomial.rootMultiplicity (HPow.hPow r p) f))","decl":"theorem rootMultiplicity_expand :\n    (expand R p f).rootMultiplicity r = p * f.rootMultiplicity (r ^ p) := by\n  rw [← pow_one p, rootMultiplicity_expand_pow]\n\n"}
{"name":"Polynomial.isLocalHom_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Nat\nhp : LT.lt 0 p\n⊢ IsLocalHom (Polynomial.expand R p)","decl":"theorem isLocalHom_expand {p : ℕ} (hp : 0 < p) : IsLocalHom (expand R p) := by\n  refine ⟨fun f hf1 => ?_⟩\n  have hf2 := eq_C_of_degree_eq_zero (degree_eq_zero_of_isUnit hf1)\n  rw [coeff_expand hp, if_pos (dvd_zero _), p.zero_div] at hf2\n  rw [hf2, isUnit_C] at hf1; rw [expand_eq_C hp] at hf2; rwa [hf2, isUnit_C]\n\n"}
{"name":"Polynomial.isLocalRingHom_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Nat\nhp : LT.lt 0 p\n⊢ IsLocalHom (Polynomial.expand R p)","decl":"@[deprecated (since := \"2024-10-10\")]\nalias isLocalRingHom_expand := isLocalHom_expand\n\n"}
{"name":"Polynomial.of_irreducible_expand","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Nat\nhp : Ne p 0\nf : Polynomial R\nhf : Irreducible ((Polynomial.expand R p) f)\n⊢ Irreducible f","decl":"theorem of_irreducible_expand {p : ℕ} (hp : p ≠ 0) {f : R[X]} (hf : Irreducible (expand R p f)) :\n    Irreducible f :=\n  let _ := isLocalHom_expand R hp.bot_lt\n  hf.of_map\n\n"}
{"name":"Polynomial.of_irreducible_expand_pow","module":"Mathlib.Algebra.Polynomial.Expand","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Nat\nhp : Ne p 0\nf : Polynomial R\nn : Nat\na✝ : Irreducible ((Polynomial.expand R (HPow.hPow p n)) f)\n⊢ Irreducible f","decl":"theorem of_irreducible_expand_pow {p : ℕ} (hp : p ≠ 0) {f : R[X]} {n : ℕ} :\n    Irreducible (expand R (p ^ n) f) → Irreducible f :=\n  Nat.recOn n (fun hf => by rwa [pow_zero, expand_one] at hf) fun n ih hf =>\n    ih <| of_irreducible_expand hp <| by\n      rw [pow_succ'] at hf\n      rwa [expand_expand]\n\n"}
