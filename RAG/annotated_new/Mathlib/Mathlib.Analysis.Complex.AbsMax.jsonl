{"name":"Complex.norm_max_aux‚ÇÅ","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"F : Type v\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Complex F\ninst‚úù : CompleteSpace F\nf : Complex ‚Üí F\nz w : Complex\nhd : DiffContOnCl Complex f (Metric.ball z (Dist.dist w z))\nhz : IsMaxOn (Function.comp Norm.norm f) (Metric.closedBall z (Dist.dist w z)) z\n‚ä¢ Eq (Norm.norm (f w)) (Norm.norm (f z))","decl":"theorem norm_max_aux‚ÇÅ [CompleteSpace F] {f : ‚ÑÇ ‚Üí F} {z w : ‚ÑÇ}\n    (hd : DiffContOnCl ‚ÑÇ f (ball z (dist w z)))\n    (hz : IsMaxOn (norm ‚àò f) (closedBall z (dist w z)) z) : ‚Äñf w‚Äñ = ‚Äñf z‚Äñ := by\n  -- Consider a circle of radius `r = dist w z`.\n  set r : ‚Ñù := dist w z\n  have hw : w ‚àà closedBall z r := mem_closedBall.2 le_rfl\n  -- Assume the converse. Since `‚Äñf w‚Äñ ‚â§ ‚Äñf z‚Äñ`, we have `‚Äñf w‚Äñ < ‚Äñf z‚Äñ`.\n  refine (isMaxOn_iff.1 hz _ hw).antisymm (not_lt.1 ?_)\n  rintro hw_lt : ‚Äñf w‚Äñ < ‚Äñf z‚Äñ\n  have hr : 0 < r := dist_pos.2 (ne_of_apply_ne (norm ‚àò f) hw_lt.ne)\n  -- Due to Cauchy integral formula, it suffices to prove the following inequality.\n  suffices ‚Äñ‚àÆ Œ∂ in C(z, r), (Œ∂ - z)‚Åª¬π ‚Ä¢ f Œ∂‚Äñ < 2 * œÄ * ‚Äñf z‚Äñ by\n    refine this.ne ?_\n    have A : (‚àÆ Œ∂ in C(z, r), (Œ∂ - z)‚Åª¬π ‚Ä¢ f Œ∂) = (2 * œÄ * I : ‚ÑÇ) ‚Ä¢ f z :=\n      hd.circleIntegral_sub_inv_smul (mem_ball_self hr)\n    simp [A, norm_smul, Real.pi_pos.le]\n  suffices ‚Äñ‚àÆ Œ∂ in C(z, r), (Œ∂ - z)‚Åª¬π ‚Ä¢ f Œ∂‚Äñ < 2 * œÄ * r * (‚Äñf z‚Äñ / r) by\n    rwa [mul_assoc, mul_div_cancel‚ÇÄ _ hr.ne'] at this\n  /- This inequality is true because `‚Äñ(Œ∂ - z)‚Åª¬π ‚Ä¢ f Œ∂‚Äñ ‚â§ ‚Äñf z‚Äñ / r` for all `Œ∂` on the circle and\n    this inequality is strict at `Œ∂ = w`. -/\n  have hsub : sphere z r ‚äÜ closedBall z r := sphere_subset_closedBall\n  refine circleIntegral.norm_integral_lt_of_norm_le_const_of_lt hr ?_ ?_ ‚ü®w, rfl, ?_‚ü©\n  ¬∑ show ContinuousOn (fun Œ∂ : ‚ÑÇ => (Œ∂ - z)‚Åª¬π ‚Ä¢ f Œ∂) (sphere z r)\n    refine ((continuousOn_id.sub continuousOn_const).inv‚ÇÄ ?_).smul (hd.continuousOn_ball.mono hsub)\n    exact fun Œ∂ hŒ∂ => sub_ne_zero.2 (ne_of_mem_sphere hŒ∂ hr.ne')\n  ¬∑ show ‚àÄ Œ∂ ‚àà sphere z r, ‚Äñ(Œ∂ - z)‚Åª¬π ‚Ä¢ f Œ∂‚Äñ ‚â§ ‚Äñf z‚Äñ / r\n    rintro Œ∂ (hŒ∂ : abs (Œ∂ - z) = r)\n    rw [le_div_iff‚ÇÄ hr, norm_smul, norm_inv, norm_eq_abs, hŒ∂, mul_comm, mul_inv_cancel_left‚ÇÄ hr.ne']\n    exact hz (hsub hŒ∂)\n  show ‚Äñ(w - z)‚Åª¬π ‚Ä¢ f w‚Äñ < ‚Äñf z‚Äñ / r\n  rw [norm_smul, norm_inv, norm_eq_abs, ‚Üê div_eq_inv_mul]\n  exact (div_lt_div_iff_of_pos_right hr).2 hw_lt\n\n"}
{"name":"Complex.norm_max_aux‚ÇÇ","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"F : Type v\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Complex F\nf : Complex ‚Üí F\nz w : Complex\nhd : DiffContOnCl Complex f (Metric.ball z (Dist.dist w z))\nhz : IsMaxOn (Function.comp Norm.norm f) (Metric.closedBall z (Dist.dist w z)) z\n‚ä¢ Eq (Norm.norm (f w)) (Norm.norm (f z))","decl":"theorem norm_max_aux‚ÇÇ {f : ‚ÑÇ ‚Üí F} {z w : ‚ÑÇ} (hd : DiffContOnCl ‚ÑÇ f (ball z (dist w z)))\n    (hz : IsMaxOn (norm ‚àò f) (closedBall z (dist w z)) z) : ‚Äñf w‚Äñ = ‚Äñf z‚Äñ := by\n  set e : F ‚ÜíL[‚ÑÇ] FÃÇ := UniformSpace.Completion.toComplL\n  have he : ‚àÄ x, ‚Äñe x‚Äñ = ‚Äñx‚Äñ := UniformSpace.Completion.norm_coe\n  replace hz : IsMaxOn (norm ‚àò e ‚àò f) (closedBall z (dist w z)) z := by\n    simpa only [IsMaxOn, Function.comp_def, he] using hz\n  simpa only [he, Function.comp_def]\n    using norm_max_aux‚ÇÅ (e.differentiable.comp_diffContOnCl hd) hz\n\n"}
{"name":"Complex.norm_max_aux‚ÇÉ","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"F : Type v\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Complex F\nf : Complex ‚Üí F\nz w : Complex\nr : Real\nhr : Eq (Dist.dist w z) r\nhd : DiffContOnCl Complex f (Metric.ball z r)\nhz : IsMaxOn (Function.comp Norm.norm f) (Metric.ball z r) z\n‚ä¢ Eq (Norm.norm (f w)) (Norm.norm (f z))","decl":"theorem norm_max_aux‚ÇÉ {f : ‚ÑÇ ‚Üí F} {z w : ‚ÑÇ} {r : ‚Ñù} (hr : dist w z = r)\n    (hd : DiffContOnCl ‚ÑÇ f (ball z r)) (hz : IsMaxOn (norm ‚àò f) (ball z r) z) : ‚Äñf w‚Äñ = ‚Äñf z‚Äñ := by\n  subst r\n  rcases eq_or_ne w z with (rfl | hne); ¬∑ rfl\n  rw [‚Üê dist_ne_zero] at hne\n  exact norm_max_aux‚ÇÇ hd (closure_ball z hne ‚ñ∏ hz.closure hd.continuousOn.norm)\n\n"}
{"name":"Complex.norm_eqOn_closedBall_of_isMaxOn","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Complex E\nF : Type v\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Complex F\nf : E ‚Üí F\nz : E\nr : Real\nhd : DiffContOnCl Complex f (Metric.ball z r)\nhz : IsMaxOn (Function.comp Norm.norm f) (Metric.ball z r) z\n‚ä¢ Set.EqOn (Function.comp Norm.norm f) (Function.const E (Norm.norm (f z))) (Metric.closedBall z r)","decl":"/-- **Maximum modulus principle** on a closed ball: if `f : E ‚Üí F` is continuous on a closed ball,\nis complex differentiable on the corresponding open ball, and the norm `‚Äñf w‚Äñ` takes its maximum\nvalue on the open ball at its center, then the norm `‚Äñf w‚Äñ` is constant on the closed ball. -/\ntheorem norm_eqOn_closedBall_of_isMaxOn {f : E ‚Üí F} {z : E} {r : ‚Ñù}\n    (hd : DiffContOnCl ‚ÑÇ f (ball z r)) (hz : IsMaxOn (norm ‚àò f) (ball z r) z) :\n    EqOn (norm ‚àò f) (const E ‚Äñf z‚Äñ) (closedBall z r) := by\n  intro w hw\n  rw [mem_closedBall, dist_comm] at hw\n  rcases eq_or_ne z w with (rfl | hne); ¬∑ rfl\n  set e := (lineMap z w : ‚ÑÇ ‚Üí E)\n  have hde : Differentiable ‚ÑÇ e := (differentiable_id.smul_const (w - z)).add_const z\n  suffices ‚Äñ(f ‚àò e) (1 : ‚ÑÇ)‚Äñ = ‚Äñ(f ‚àò e) (0 : ‚ÑÇ)‚Äñ by simpa [e]\n  have hr : dist (1 : ‚ÑÇ) 0 = 1 := by simp\n  have hball : MapsTo e (ball 0 1) (ball z r) := by\n    refine ((lipschitzWith_lineMap z w).mapsTo_ball (mt nndist_eq_zero.1 hne) 0 1).mono\n      Subset.rfl ?_\n    simpa only [lineMap_apply_zero, mul_one, coe_nndist] using ball_subset_ball hw\n  exact norm_max_aux‚ÇÉ hr (hd.comp hde.diffContOnCl hball)\n      (hz.comp_mapsTo hball (lineMap_apply_zero z w))\n\n"}
{"name":"Complex.norm_eq_norm_of_isMaxOn_of_ball_subset","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Complex E\nF : Type v\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Complex F\nf : E ‚Üí F\ns : Set E\nz w : E\nhd : DiffContOnCl Complex f s\nhz : IsMaxOn (Function.comp Norm.norm f) s z\nhsub : HasSubset.Subset (Metric.ball z (Dist.dist w z)) s\n‚ä¢ Eq (Norm.norm (f w)) (Norm.norm (f z))","decl":"/-- **Maximum modulus principle**: if `f : E ‚Üí F` is complex differentiable on a set `s`, the norm\nof `f` takes it maximum on `s` at `z`, and `w` is a point such that the closed ball with center `z`\nand radius `dist w z` is included in `s`, then `‚Äñf w‚Äñ = ‚Äñf z‚Äñ`. -/\ntheorem norm_eq_norm_of_isMaxOn_of_ball_subset {f : E ‚Üí F} {s : Set E} {z w : E}\n    (hd : DiffContOnCl ‚ÑÇ f s) (hz : IsMaxOn (norm ‚àò f) s z) (hsub : ball z (dist w z) ‚äÜ s) :\n    ‚Äñf w‚Äñ = ‚Äñf z‚Äñ :=\n  norm_eqOn_closedBall_of_isMaxOn (hd.mono hsub) (hz.on_subset hsub) (mem_closedBall.2 le_rfl)\n\n"}
{"name":"Complex.norm_eventually_eq_of_isLocalMax","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Complex E\nF : Type v\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Complex F\nf : E ‚Üí F\nc : E\nhd : Filter.Eventually (fun z => DifferentiableAt Complex f z) (nhds c)\nhc : IsLocalMax (Function.comp Norm.norm f) c\n‚ä¢ Filter.Eventually (fun y => Eq (Norm.norm (f y)) (Norm.norm (f c))) (nhds c)","decl":"/-- **Maximum modulus principle**: if `f : E ‚Üí F` is complex differentiable in a neighborhood of `c`\nand the norm `‚Äñf z‚Äñ` has a local maximum at `c`, then `‚Äñf z‚Äñ` is locally constant in a neighborhood\nof `c`. -/\ntheorem norm_eventually_eq_of_isLocalMax {f : E ‚Üí F} {c : E}\n    (hd : ‚àÄ·∂† z in ùìù c, DifferentiableAt ‚ÑÇ f z) (hc : IsLocalMax (norm ‚àò f) c) :\n    ‚àÄ·∂† y in ùìù c, ‚Äñf y‚Äñ = ‚Äñf c‚Äñ := by\n  rcases nhds_basis_closedBall.eventually_iff.1 (hd.and hc) with ‚ü®r, hr‚ÇÄ, hr‚ü©\n  exact nhds_basis_closedBall.eventually_iff.2\n    ‚ü®r, hr‚ÇÄ, norm_eqOn_closedBall_of_isMaxOn (DifferentiableOn.diffContOnCl fun x hx =>\n        (hr <| closure_ball_subset_closedBall hx).1.differentiableWithinAt) fun x hx =>\n      (hr <| ball_subset_closedBall hx).2‚ü©\n\n"}
{"name":"Complex.isOpen_setOf_mem_nhds_and_isMaxOn_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Complex E\nF : Type v\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Complex F\nf : E ‚Üí F\ns : Set E\nhd : DifferentiableOn Complex f s\n‚ä¢ IsOpen (setOf fun z => And (Membership.mem (nhds z) s) (IsMaxOn (Function.comp Norm.norm f) s z))","decl":"theorem isOpen_setOf_mem_nhds_and_isMaxOn_norm {f : E ‚Üí F} {s : Set E}\n    (hd : DifferentiableOn ‚ÑÇ f s) : IsOpen {z | s ‚àà ùìù z ‚àß IsMaxOn (norm ‚àò f) s z} := by\n  refine isOpen_iff_mem_nhds.2 fun z hz => (eventually_eventually_nhds.2 hz.1).and ?_\n  replace hd : ‚àÄ·∂† w in ùìù z, DifferentiableAt ‚ÑÇ f w := hd.eventually_differentiableAt hz.1\n  exact (norm_eventually_eq_of_isLocalMax hd <| hz.2.isLocalMax hz.1).mono fun x hx y hy =>\n    le_trans (hz.2 hy).out hx.ge\n\n"}
{"name":"Complex.norm_eqOn_of_isPreconnected_of_isMaxOn","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Complex E\nF : Type v\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Complex F\nf : E ‚Üí F\nU : Set E\nc : E\nhc : IsPreconnected U\nho : IsOpen U\nhd : DifferentiableOn Complex f U\nhcU : Membership.mem U c\nhm : IsMaxOn (Function.comp Norm.norm f) U c\n‚ä¢ Set.EqOn (Function.comp Norm.norm f) (Function.const E (Norm.norm (f c))) U","decl":"/-- **Maximum modulus principle** on a connected set. Let `U` be a (pre)connected open set in a\ncomplex normed space. Let `f : E ‚Üí F` be a function that is complex differentiable on `U`. Suppose\nthat `‚Äñf x‚Äñ` takes its maximum value on `U` at `c ‚àà U`. Then `‚Äñf x‚Äñ = ‚Äñf c‚Äñ` for all `x ‚àà U`. -/\ntheorem norm_eqOn_of_isPreconnected_of_isMaxOn {f : E ‚Üí F} {U : Set E} {c : E}\n    (hc : IsPreconnected U) (ho : IsOpen U) (hd : DifferentiableOn ‚ÑÇ f U) (hcU : c ‚àà U)\n    (hm : IsMaxOn (norm ‚àò f) U c) : EqOn (norm ‚àò f) (const E ‚Äñf c‚Äñ) U := by\n  set V := U ‚à© {z | IsMaxOn (norm ‚àò f) U z}\n  have hV : ‚àÄ x ‚àà V, ‚Äñf x‚Äñ = ‚Äñf c‚Äñ := fun x hx => le_antisymm (hm hx.1) (hx.2 hcU)\n  suffices U ‚äÜ V from fun x hx => hV x (this hx)\n  have hVo : IsOpen V := by\n    simpa only [ho.mem_nhds_iff, setOf_and, setOf_mem_eq]\n      using isOpen_setOf_mem_nhds_and_isMaxOn_norm hd\n  have hVne : (U ‚à© V).Nonempty := ‚ü®c, hcU, hcU, hm‚ü©\n  set W := U ‚à© {z | ‚Äñf z‚Äñ ‚â† ‚Äñf c‚Äñ}\n  have hWo : IsOpen W := hd.continuousOn.norm.isOpen_inter_preimage ho isOpen_ne\n  have hdVW : Disjoint V W := disjoint_left.mpr fun x hxV hxW => hxW.2 (hV x hxV)\n  have hUVW : U ‚äÜ V ‚à™ W := fun x hx =>\n    (eq_or_ne ‚Äñf x‚Äñ ‚Äñf c‚Äñ).imp (fun h => ‚ü®hx, fun y hy => (hm hy).out.trans_eq h.symm‚ü©)\n      (And.intro hx)\n  exact hc.subset_left_of_subset_union hVo hWo hdVW hUVW hVne\n\n"}
{"name":"Complex.norm_eqOn_closure_of_isPreconnected_of_isMaxOn","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Complex E\nF : Type v\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Complex F\nf : E ‚Üí F\nU : Set E\nc : E\nhc : IsPreconnected U\nho : IsOpen U\nhd : DiffContOnCl Complex f U\nhcU : Membership.mem U c\nhm : IsMaxOn (Function.comp Norm.norm f) U c\n‚ä¢ Set.EqOn (Function.comp Norm.norm f) (Function.const E (Norm.norm (f c))) (closure U)","decl":"/-- **Maximum modulus principle** on a connected set. Let `U` be a (pre)connected open set in a\ncomplex normed space.  Let `f : E ‚Üí F` be a function that is complex differentiable on `U` and is\ncontinuous on its closure. Suppose that `‚Äñf x‚Äñ` takes its maximum value on `U` at `c ‚àà U`. Then\n`‚Äñf x‚Äñ = ‚Äñf c‚Äñ` for all `x ‚àà closure U`. -/\ntheorem norm_eqOn_closure_of_isPreconnected_of_isMaxOn {f : E ‚Üí F} {U : Set E} {c : E}\n    (hc : IsPreconnected U) (ho : IsOpen U) (hd : DiffContOnCl ‚ÑÇ f U) (hcU : c ‚àà U)\n    (hm : IsMaxOn (norm ‚àò f) U c) : EqOn (norm ‚àò f) (const E ‚Äñf c‚Äñ) (closure U) :=\n  (norm_eqOn_of_isPreconnected_of_isMaxOn hc ho hd.differentiableOn hcU hm).of_subset_closure\n    hd.continuousOn.norm continuousOn_const subset_closure Subset.rfl\n\n"}
{"name":"Complex.eqOn_of_isPreconnected_of_isMaxOn_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Complex E\nF : Type v\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Complex F\ninst‚úù : StrictConvexSpace Real F\nf : E ‚Üí F\nU : Set E\nc : E\nhc : IsPreconnected U\nho : IsOpen U\nhd : DifferentiableOn Complex f U\nhcU : Membership.mem U c\nhm : IsMaxOn (Function.comp Norm.norm f) U c\n‚ä¢ Set.EqOn f (Function.const E (f c)) U","decl":"/-- **Maximum modulus principle** on a connected set. Let `U` be a (pre)connected open set in a\ncomplex normed space.  Let `f : E ‚Üí F` be a function that is complex differentiable on `U`. Suppose\nthat `‚Äñf x‚Äñ` takes its maximum value on `U` at `c ‚àà U`. Then `f x = f c` for all `x ‚àà U`.\n\nTODO: change assumption from `IsMaxOn` to `IsLocalMax`. -/\ntheorem eqOn_of_isPreconnected_of_isMaxOn_norm {f : E ‚Üí F} {U : Set E} {c : E}\n    (hc : IsPreconnected U) (ho : IsOpen U) (hd : DifferentiableOn ‚ÑÇ f U) (hcU : c ‚àà U)\n    (hm : IsMaxOn (norm ‚àò f) U c) : EqOn f (const E (f c)) U := fun x hx =>\n  have H‚ÇÅ : ‚Äñf x‚Äñ = ‚Äñf c‚Äñ := norm_eqOn_of_isPreconnected_of_isMaxOn hc ho hd hcU hm hx\n  have H‚ÇÇ : ‚Äñf x + f c‚Äñ = ‚Äñf c + f c‚Äñ :=\n    norm_eqOn_of_isPreconnected_of_isMaxOn hc ho (hd.add_const _) hcU hm.norm_add_self hx\n  eq_of_norm_eq_of_norm_add_eq H‚ÇÅ <| by simp only [H‚ÇÇ, SameRay.rfl.norm_add, H‚ÇÅ, Function.const]\n\n"}
{"name":"Complex.eqOn_closure_of_isPreconnected_of_isMaxOn_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Complex E\nF : Type v\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Complex F\ninst‚úù : StrictConvexSpace Real F\nf : E ‚Üí F\nU : Set E\nc : E\nhc : IsPreconnected U\nho : IsOpen U\nhd : DiffContOnCl Complex f U\nhcU : Membership.mem U c\nhm : IsMaxOn (Function.comp Norm.norm f) U c\n‚ä¢ Set.EqOn f (Function.const E (f c)) (closure U)","decl":"/-- **Maximum modulus principle** on a connected set. Let `U` be a (pre)connected open set in a\ncomplex normed space.  Let `f : E ‚Üí F` be a function that is complex differentiable on `U` and is\ncontinuous on its closure. Suppose that `‚Äñf x‚Äñ` takes its maximum value on `U` at `c ‚àà U`. Then\n`f x = f c` for all `x ‚àà closure U`. -/\ntheorem eqOn_closure_of_isPreconnected_of_isMaxOn_norm {f : E ‚Üí F} {U : Set E} {c : E}\n    (hc : IsPreconnected U) (ho : IsOpen U) (hd : DiffContOnCl ‚ÑÇ f U) (hcU : c ‚àà U)\n    (hm : IsMaxOn (norm ‚àò f) U c) : EqOn f (const E (f c)) (closure U) :=\n  (eqOn_of_isPreconnected_of_isMaxOn_norm hc ho hd.differentiableOn hcU hm).of_subset_closure\n    hd.continuousOn continuousOn_const subset_closure Subset.rfl\n\n"}
{"name":"Complex.eq_of_isMaxOn_of_ball_subset","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Complex E\nF : Type v\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Complex F\ninst‚úù : StrictConvexSpace Real F\nf : E ‚Üí F\ns : Set E\nz w : E\nhd : DiffContOnCl Complex f s\nhz : IsMaxOn (Function.comp Norm.norm f) s z\nhsub : HasSubset.Subset (Metric.ball z (Dist.dist w z)) s\n‚ä¢ Eq (f w) (f z)","decl":"/-- **Maximum modulus principle**. Let `f : E ‚Üí F` be a function between complex normed spaces.\nSuppose that the codomain `F` is a strictly convex space, `f` is complex differentiable on a set\n`s`, `f` is continuous on the closure of `s`, the norm of `f` takes it maximum on `s` at `z`, and\n`w` is a point such that the closed ball with center `z` and radius `dist w z` is included in `s`,\nthen `f w = f z`. -/\ntheorem eq_of_isMaxOn_of_ball_subset {f : E ‚Üí F} {s : Set E} {z w : E} (hd : DiffContOnCl ‚ÑÇ f s)\n    (hz : IsMaxOn (norm ‚àò f) s z) (hsub : ball z (dist w z) ‚äÜ s) : f w = f z :=\n  have H‚ÇÅ : ‚Äñf w‚Äñ = ‚Äñf z‚Äñ := norm_eq_norm_of_isMaxOn_of_ball_subset hd hz hsub\n  have H‚ÇÇ : ‚Äñf w + f z‚Äñ = ‚Äñf z + f z‚Äñ :=\n    norm_eq_norm_of_isMaxOn_of_ball_subset (hd.add_const _) hz.norm_add_self hsub\n  eq_of_norm_eq_of_norm_add_eq H‚ÇÅ <| by simp only [H‚ÇÇ, SameRay.rfl.norm_add, H‚ÇÅ]\n\n"}
{"name":"Complex.eqOn_closedBall_of_isMaxOn_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Complex E\nF : Type v\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Complex F\ninst‚úù : StrictConvexSpace Real F\nf : E ‚Üí F\nz : E\nr : Real\nhd : DiffContOnCl Complex f (Metric.ball z r)\nhz : IsMaxOn (Function.comp Norm.norm f) (Metric.ball z r) z\n‚ä¢ Set.EqOn f (Function.const E (f z)) (Metric.closedBall z r)","decl":"/-- **Maximum modulus principle** on a closed ball. Suppose that a function `f : E ‚Üí F` from a\nnormed complex space to a strictly convex normed complex space has the following properties:\n\n- it is continuous on a closed ball `Metric.closedBall z r`,\n- it is complex differentiable on the corresponding open ball;\n- the norm `‚Äñf w‚Äñ` takes its maximum value on the open ball at its center.\n\nThen `f` is a constant on the closed ball. -/\ntheorem eqOn_closedBall_of_isMaxOn_norm {f : E ‚Üí F} {z : E} {r : ‚Ñù}\n    (hd : DiffContOnCl ‚ÑÇ f (ball z r)) (hz : IsMaxOn (norm ‚àò f) (ball z r) z) :\n    EqOn f (const E (f z)) (closedBall z r) := fun _x hx =>\n  eq_of_isMaxOn_of_ball_subset hd hz <| ball_subset_ball hx\n\n"}
{"name":"Complex.eq_const_of_exists_max","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Complex E\nF : Type v\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Complex F\ninst‚úù : StrictConvexSpace Real F\nf : E ‚Üí F\nb : Real\nh_an : DifferentiableOn Complex f (Metric.ball 0 b)\nv : E\nhv : Membership.mem (Metric.ball 0 b) v\nhv_max : IsMaxOn (Function.comp Norm.norm f) (Metric.ball 0 b) v\n‚ä¢ Set.EqOn f (Function.const E (f v)) (Metric.ball 0 b)","decl":"/-- If `f` is differentiable on the open unit ball `{z : ‚ÑÇ | ‚Äñz‚Äñ < 1}`, and `‚Äñf‚Äñ` attains a maximum\nin this open ball, then `f` is constant.-/\nlemma eq_const_of_exists_max {f : E ‚Üí F} {b : ‚Ñù} (h_an : DifferentiableOn ‚ÑÇ f (ball 0 b))\n    {v : E} (hv : v ‚àà ball 0 b) (hv_max : IsMaxOn (norm ‚àò f) (ball 0 b) v) :\n    Set.EqOn f (Function.const E (f v)) (ball 0 b) :=\n  Complex.eqOn_of_isPreconnected_of_isMaxOn_norm (convex_ball 0 b).isPreconnected\n    isOpen_ball h_an hv hv_max\n\n"}
{"name":"Complex.eq_const_of_exists_le","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Complex E\nF : Type v\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Complex F\ninst‚úù¬π : StrictConvexSpace Real F\ninst‚úù : ProperSpace E\nf : E ‚Üí F\nr b : Real\nh_an : DifferentiableOn Complex f (Metric.ball 0 b)\nhr_nn : LE.le 0 r\nhr_lt : LT.lt r b\nhr : ‚àÄ (z : E), Membership.mem (Metric.ball 0 b) z ‚Üí Exists fun w => And (Membership.mem (Metric.closedBall 0 r) w) (LE.le (Norm.norm (f z)) (Norm.norm (f w)))\n‚ä¢ Set.EqOn f (Function.const E (f 0)) (Metric.ball 0 b)","decl":"/-- If `f` is a function differentiable on the open unit ball, and there exists an `r < 1` such that\nany value of `‚Äñf‚Äñ` on the open ball is bounded above by some value on the closed ball of radius `r`,\nthen `f` is constant. -/\nlemma eq_const_of_exists_le [ProperSpace E] {f : E ‚Üí F} {r b : ‚Ñù}\n    (h_an : DifferentiableOn ‚ÑÇ f (ball 0 b)) (hr_nn : 0 ‚â§ r) (hr_lt : r < b)\n    (hr : ‚àÄ z, z ‚àà (ball 0 b) ‚Üí ‚àÉ w, w ‚àà closedBall 0 r ‚àß ‚Äñf z‚Äñ ‚â§ ‚Äñf w‚Äñ) :\n    Set.EqOn f (Function.const E (f 0)) (ball 0 b) := by\n  obtain ‚ü®x, hx_mem, hx_max‚ü© := isCompact_closedBall (0 : E) r |>.exists_isMaxOn\n    (nonempty_closedBall.mpr hr_nn)\n    (h_an.continuousOn.mono <| closedBall_subset_ball hr_lt).norm\n  suffices Set.EqOn f (Function.const E (f x)) (ball 0 b) by\n    rwa [this (mem_ball_self (hr_nn.trans_lt hr_lt))]\n  apply eq_const_of_exists_max h_an (closedBall_subset_ball hr_lt hx_mem) (fun z hz ‚Ü¶ ?_)\n  obtain ‚ü®w, hw, hw'‚ü© := hr z hz\n  exact hw'.trans (hx_max hw)\n\n"}
{"name":"Complex.eventually_eq_of_isLocalMax_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Complex E\nF : Type v\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Complex F\ninst‚úù : StrictConvexSpace Real F\nf : E ‚Üí F\nc : E\nhd : Filter.Eventually (fun z => DifferentiableAt Complex f z) (nhds c)\nhc : IsLocalMax (Function.comp Norm.norm f) c\n‚ä¢ Filter.Eventually (fun y => Eq (f y) (f c)) (nhds c)","decl":"/-- **Maximum modulus principle**: if `f : E ‚Üí F` is complex differentiable in a neighborhood of `c`\nand the norm `‚Äñf z‚Äñ` has a local maximum at `c`, then `f` is locally constant in a neighborhood\nof `c`. -/\ntheorem eventually_eq_of_isLocalMax_norm {f : E ‚Üí F} {c : E}\n    (hd : ‚àÄ·∂† z in ùìù c, DifferentiableAt ‚ÑÇ f z) (hc : IsLocalMax (norm ‚àò f) c) :\n    ‚àÄ·∂† y in ùìù c, f y = f c := by\n  rcases nhds_basis_closedBall.eventually_iff.1 (hd.and hc) with ‚ü®r, hr‚ÇÄ, hr‚ü©\n  exact nhds_basis_closedBall.eventually_iff.2\n    ‚ü®r, hr‚ÇÄ, eqOn_closedBall_of_isMaxOn_norm (DifferentiableOn.diffContOnCl fun x hx =>\n        (hr <| closure_ball_subset_closedBall hx).1.differentiableWithinAt) fun x hx =>\n      (hr <| ball_subset_closedBall hx).2‚ü©\n\n"}
{"name":"Complex.eventually_eq_or_eq_zero_of_isLocalMin_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : E ‚Üí Complex\nc : E\nhf : Filter.Eventually (fun z => DifferentiableAt Complex f z) (nhds c)\nhc : IsLocalMin (Function.comp Norm.norm f) c\n‚ä¢ Or (Filter.Eventually (fun z => Eq (f z) (f c)) (nhds c)) (Eq (f c) 0)","decl":"theorem eventually_eq_or_eq_zero_of_isLocalMin_norm {f : E ‚Üí ‚ÑÇ} {c : E}\n    (hf : ‚àÄ·∂† z in ùìù c, DifferentiableAt ‚ÑÇ f z) (hc : IsLocalMin (norm ‚àò f) c) :\n    (‚àÄ·∂† z in ùìù c, f z = f c) ‚à® f c = 0 := by\n  refine or_iff_not_imp_right.mpr fun h => ?_\n  have h1 : ‚àÄ·∂† z in ùìù c, f z ‚â† 0 := hf.self_of_nhds.continuousAt.eventually_ne h\n  have h2 : IsLocalMax (norm ‚àò f)‚Åª¬π c := hc.inv (h1.mono fun z => norm_pos_iff.mpr)\n  have h3 : IsLocalMax (norm ‚àò f‚Åª¬π) c := by refine h2.congr (Eventually.of_forall ?_); simp\n  have h4 : ‚àÄ·∂† z in ùìù c, DifferentiableAt ‚ÑÇ f‚Åª¬π z := by filter_upwards [hf, h1] with z h using h.inv\n  filter_upwards [eventually_eq_of_isLocalMax_norm h4 h3] with z using inv_inj.mp\n\n"}
{"name":"Complex.exists_mem_frontier_isMaxOn_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace Complex E\nF : Type v\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace Complex F\ninst‚úù¬π : Nontrivial E\ninst‚úù : FiniteDimensional Complex E\nf : E ‚Üí F\nU : Set E\nhb : Bornology.IsBounded U\nhne : U.Nonempty\nhd : DiffContOnCl Complex f U\n‚ä¢ Exists fun z => And (Membership.mem (frontier U) z) (IsMaxOn (Function.comp Norm.norm f) (closure U) z)","decl":"/-- **Maximum modulus principle**: if `f : E ‚Üí F` is complex differentiable on a nonempty bounded\nset `U` and is continuous on its closure, then there exists a point `z ‚àà frontier U` such that\n`(‚Äñf ¬∑‚Äñ)` takes it maximum value on `closure U` at `z`. -/\ntheorem exists_mem_frontier_isMaxOn_norm [FiniteDimensional ‚ÑÇ E] {f : E ‚Üí F} {U : Set E}\n    (hb : IsBounded U) (hne : U.Nonempty) (hd : DiffContOnCl ‚ÑÇ f U) :\n    ‚àÉ z ‚àà frontier U, IsMaxOn (norm ‚àò f) (closure U) z := by\n  have hc : IsCompact (closure U) := hb.isCompact_closure\n  obtain ‚ü®w, hwU, hle‚ü© : ‚àÉ w ‚àà closure U, IsMaxOn (norm ‚àò f) (closure U) w :=\n    hc.exists_isMaxOn hne.closure hd.continuousOn.norm\n  rw [closure_eq_interior_union_frontier, mem_union] at hwU\n  cases' hwU with hwU hwU; rotate_left; ¬∑ exact ‚ü®w, hwU, hle‚ü©\n  have : interior U ‚â† univ := ne_top_of_le_ne_top hc.ne_univ interior_subset_closure\n  rcases exists_mem_frontier_infDist_compl_eq_dist hwU this with ‚ü®z, hzU, hzw‚ü©\n  refine ‚ü®z, frontier_interior_subset hzU, fun x hx => (hle hx).out.trans_eq ?_‚ü©\n  refine (norm_eq_norm_of_isMaxOn_of_ball_subset hd (hle.on_subset subset_closure) ?_).symm\n  rw [dist_comm, ‚Üê hzw]\n  exact ball_infDist_compl_subset.trans interior_subset\n\n"}
{"name":"Complex.norm_le_of_forall_mem_frontier_norm_le","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Complex E\nF : Type v\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Complex F\ninst‚úù : Nontrivial E\nf : E ‚Üí F\nU : Set E\nhU : Bornology.IsBounded U\nhd : DiffContOnCl Complex f U\nC : Real\nhC : ‚àÄ (z : E), Membership.mem (frontier U) z ‚Üí LE.le (Norm.norm (f z)) C\nz : E\nhz : Membership.mem (closure U) z\n‚ä¢ LE.le (Norm.norm (f z)) C","decl":"/-- **Maximum modulus principle**: if `f : E ‚Üí F` is complex differentiable on a bounded set `U` and\n`‚Äñf z‚Äñ ‚â§ C` for any `z ‚àà frontier U`, then the same is true for any `z ‚àà closure U`. -/\ntheorem norm_le_of_forall_mem_frontier_norm_le {f : E ‚Üí F} {U : Set E} (hU : IsBounded U)\n    (hd : DiffContOnCl ‚ÑÇ f U) {C : ‚Ñù} (hC : ‚àÄ z ‚àà frontier U, ‚Äñf z‚Äñ ‚â§ C) {z : E}\n    (hz : z ‚àà closure U) : ‚Äñf z‚Äñ ‚â§ C := by\n  rw [closure_eq_self_union_frontier, union_comm, mem_union] at hz\n  cases' hz with hz hz; ¬∑ exact hC z hz\n  /- In case of a finite dimensional domain, one can just apply\n    `Complex.exists_mem_frontier_isMaxOn_norm`. To make it work in any Banach space, we restrict\n    the function to a line first. -/\n  rcases exists_ne z with ‚ü®w, hne‚ü©\n  set e := (lineMap z w : ‚ÑÇ ‚Üí E)\n  have hde : Differentiable ‚ÑÇ e := (differentiable_id.smul_const (w - z)).add_const z\n  have hL : AntilipschitzWith (nndist z w)‚Åª¬π e := antilipschitzWith_lineMap hne.symm\n  replace hd : DiffContOnCl ‚ÑÇ (f ‚àò e) (e ‚Åª¬π' U) :=\n    hd.comp hde.diffContOnCl (mapsTo_preimage _ _)\n  have h‚ÇÄ : (0 : ‚ÑÇ) ‚àà e ‚Åª¬π' U := by simpa only [e, mem_preimage, lineMap_apply_zero]\n  rcases exists_mem_frontier_isMaxOn_norm (hL.isBounded_preimage hU) ‚ü®0, h‚ÇÄ‚ü© hd with ‚ü®Œ∂, hŒ∂U, hŒ∂‚ü©\n  calc\n    ‚Äñf z‚Äñ = ‚Äñf (e 0)‚Äñ := by simp only [e, lineMap_apply_zero]\n    _ ‚â§ ‚Äñf (e Œ∂)‚Äñ := hŒ∂ (subset_closure h‚ÇÄ)\n    _ ‚â§ C := hC _ (hde.continuous.frontier_preimage_subset _ hŒ∂U)\n\n"}
{"name":"Complex.eqOn_closure_of_eqOn_frontier","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Complex E\nF : Type v\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Complex F\ninst‚úù : Nontrivial E\nf g : E ‚Üí F\nU : Set E\nhU : Bornology.IsBounded U\nhf : DiffContOnCl Complex f U\nhg : DiffContOnCl Complex g U\nhfg : Set.EqOn f g (frontier U)\n‚ä¢ Set.EqOn f g (closure U)","decl":"/-- If two complex differentiable functions `f g : E ‚Üí F` are equal on the boundary of a bounded set\n`U`, then they are equal on `closure U`. -/\ntheorem eqOn_closure_of_eqOn_frontier {f g : E ‚Üí F} {U : Set E} (hU : IsBounded U)\n    (hf : DiffContOnCl ‚ÑÇ f U) (hg : DiffContOnCl ‚ÑÇ g U) (hfg : EqOn f g (frontier U)) :\n    EqOn f g (closure U) := by\n  suffices H : ‚àÄ z ‚àà closure U, ‚Äñ(f - g) z‚Äñ ‚â§ 0 by simpa [sub_eq_zero] using H\n  refine fun z hz => norm_le_of_forall_mem_frontier_norm_le hU (hf.sub hg) (fun w hw => ?_) hz\n  simp [hfg hw]\n\n"}
{"name":"Complex.eqOn_of_eqOn_frontier","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Complex E\nF : Type v\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Complex F\ninst‚úù : Nontrivial E\nf g : E ‚Üí F\nU : Set E\nhU : Bornology.IsBounded U\nhf : DiffContOnCl Complex f U\nhg : DiffContOnCl Complex g U\nhfg : Set.EqOn f g (frontier U)\n‚ä¢ Set.EqOn f g U","decl":"/-- If two complex differentiable functions `f g : E ‚Üí F` are equal on the boundary of a bounded set\n`U`, then they are equal on `U`. -/\ntheorem eqOn_of_eqOn_frontier {f g : E ‚Üí F} {U : Set E} (hU : IsBounded U) (hf : DiffContOnCl ‚ÑÇ f U)\n    (hg : DiffContOnCl ‚ÑÇ g U) (hfg : EqOn f g (frontier U)) : EqOn f g U :=\n  (eqOn_closure_of_eqOn_frontier hU hf hg hfg).mono subset_closure\n\n"}
