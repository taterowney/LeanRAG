{"name":"Complex.norm_max_aux₁","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"F : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Complex F\ninst✝ : CompleteSpace F\nf : Complex → F\nz w : Complex\nhd : DiffContOnCl Complex f (Metric.ball z (Dist.dist w z))\nhz : IsMaxOn (Function.comp Norm.norm f) (Metric.closedBall z (Dist.dist w z)) z\n⊢ Eq (Norm.norm (f w)) (Norm.norm (f z))","decl":"theorem norm_max_aux₁ [CompleteSpace F] {f : ℂ → F} {z w : ℂ}\n    (hd : DiffContOnCl ℂ f (ball z (dist w z)))\n    (hz : IsMaxOn (norm ∘ f) (closedBall z (dist w z)) z) : ‖f w‖ = ‖f z‖ := by\n  -- Consider a circle of radius `r = dist w z`.\n  set r : ℝ := dist w z\n  have hw : w ∈ closedBall z r := mem_closedBall.2 le_rfl\n  -- Assume the converse. Since `‖f w‖ ≤ ‖f z‖`, we have `‖f w‖ < ‖f z‖`.\n  refine (isMaxOn_iff.1 hz _ hw).antisymm (not_lt.1 ?_)\n  rintro hw_lt : ‖f w‖ < ‖f z‖\n  have hr : 0 < r := dist_pos.2 (ne_of_apply_ne (norm ∘ f) hw_lt.ne)\n  -- Due to Cauchy integral formula, it suffices to prove the following inequality.\n  suffices ‖∮ ζ in C(z, r), (ζ - z)⁻¹ • f ζ‖ < 2 * π * ‖f z‖ by\n    refine this.ne ?_\n    have A : (∮ ζ in C(z, r), (ζ - z)⁻¹ • f ζ) = (2 * π * I : ℂ) • f z :=\n      hd.circleIntegral_sub_inv_smul (mem_ball_self hr)\n    simp [A, norm_smul, Real.pi_pos.le]\n  suffices ‖∮ ζ in C(z, r), (ζ - z)⁻¹ • f ζ‖ < 2 * π * r * (‖f z‖ / r) by\n    rwa [mul_assoc, mul_div_cancel₀ _ hr.ne'] at this\n  /- This inequality is true because `‖(ζ - z)⁻¹ • f ζ‖ ≤ ‖f z‖ / r` for all `ζ` on the circle and\n    this inequality is strict at `ζ = w`. -/\n  have hsub : sphere z r ⊆ closedBall z r := sphere_subset_closedBall\n  refine circleIntegral.norm_integral_lt_of_norm_le_const_of_lt hr ?_ ?_ ⟨w, rfl, ?_⟩\n  · show ContinuousOn (fun ζ : ℂ => (ζ - z)⁻¹ • f ζ) (sphere z r)\n    refine ((continuousOn_id.sub continuousOn_const).inv₀ ?_).smul (hd.continuousOn_ball.mono hsub)\n    exact fun ζ hζ => sub_ne_zero.2 (ne_of_mem_sphere hζ hr.ne')\n  · show ∀ ζ ∈ sphere z r, ‖(ζ - z)⁻¹ • f ζ‖ ≤ ‖f z‖ / r\n    rintro ζ (hζ : abs (ζ - z) = r)\n    rw [le_div_iff₀ hr, norm_smul, norm_inv, norm_eq_abs, hζ, mul_comm, mul_inv_cancel_left₀ hr.ne']\n    exact hz (hsub hζ)\n  show ‖(w - z)⁻¹ • f w‖ < ‖f z‖ / r\n  rw [norm_smul, norm_inv, norm_eq_abs, ← div_eq_inv_mul]\n  exact (div_lt_div_iff_of_pos_right hr).2 hw_lt\n\n"}
{"name":"Complex.norm_max_aux₂","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"F : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Complex F\nf : Complex → F\nz w : Complex\nhd : DiffContOnCl Complex f (Metric.ball z (Dist.dist w z))\nhz : IsMaxOn (Function.comp Norm.norm f) (Metric.closedBall z (Dist.dist w z)) z\n⊢ Eq (Norm.norm (f w)) (Norm.norm (f z))","decl":"theorem norm_max_aux₂ {f : ℂ → F} {z w : ℂ} (hd : DiffContOnCl ℂ f (ball z (dist w z)))\n    (hz : IsMaxOn (norm ∘ f) (closedBall z (dist w z)) z) : ‖f w‖ = ‖f z‖ := by\n  set e : F →L[ℂ] F̂ := UniformSpace.Completion.toComplL\n  have he : ∀ x, ‖e x‖ = ‖x‖ := UniformSpace.Completion.norm_coe\n  replace hz : IsMaxOn (norm ∘ e ∘ f) (closedBall z (dist w z)) z := by\n    simpa only [IsMaxOn, Function.comp_def, he] using hz\n  simpa only [he, Function.comp_def]\n    using norm_max_aux₁ (e.differentiable.comp_diffContOnCl hd) hz\n\n"}
{"name":"Complex.norm_max_aux₃","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"F : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Complex F\nf : Complex → F\nz w : Complex\nr : Real\nhr : Eq (Dist.dist w z) r\nhd : DiffContOnCl Complex f (Metric.ball z r)\nhz : IsMaxOn (Function.comp Norm.norm f) (Metric.ball z r) z\n⊢ Eq (Norm.norm (f w)) (Norm.norm (f z))","decl":"theorem norm_max_aux₃ {f : ℂ → F} {z w : ℂ} {r : ℝ} (hr : dist w z = r)\n    (hd : DiffContOnCl ℂ f (ball z r)) (hz : IsMaxOn (norm ∘ f) (ball z r) z) : ‖f w‖ = ‖f z‖ := by\n  subst r\n  rcases eq_or_ne w z with (rfl | hne); · rfl\n  rw [← dist_ne_zero] at hne\n  exact norm_max_aux₂ hd (closure_ball z hne ▸ hz.closure hd.continuousOn.norm)\n\n"}
{"name":"Complex.norm_eqOn_closedBall_of_isMaxOn","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Complex E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Complex F\nf : E → F\nz : E\nr : Real\nhd : DiffContOnCl Complex f (Metric.ball z r)\nhz : IsMaxOn (Function.comp Norm.norm f) (Metric.ball z r) z\n⊢ Set.EqOn (Function.comp Norm.norm f) (Function.const E (Norm.norm (f z))) (Metric.closedBall z r)","decl":"/-- **Maximum modulus principle** on a closed ball: if `f : E → F` is continuous on a closed ball,\nis complex differentiable on the corresponding open ball, and the norm `‖f w‖` takes its maximum\nvalue on the open ball at its center, then the norm `‖f w‖` is constant on the closed ball. -/\ntheorem norm_eqOn_closedBall_of_isMaxOn {f : E → F} {z : E} {r : ℝ}\n    (hd : DiffContOnCl ℂ f (ball z r)) (hz : IsMaxOn (norm ∘ f) (ball z r) z) :\n    EqOn (norm ∘ f) (const E ‖f z‖) (closedBall z r) := by\n  intro w hw\n  rw [mem_closedBall, dist_comm] at hw\n  rcases eq_or_ne z w with (rfl | hne); · rfl\n  set e := (lineMap z w : ℂ → E)\n  have hde : Differentiable ℂ e := (differentiable_id.smul_const (w - z)).add_const z\n  suffices ‖(f ∘ e) (1 : ℂ)‖ = ‖(f ∘ e) (0 : ℂ)‖ by simpa [e]\n  have hr : dist (1 : ℂ) 0 = 1 := by simp\n  have hball : MapsTo e (ball 0 1) (ball z r) := by\n    refine ((lipschitzWith_lineMap z w).mapsTo_ball (mt nndist_eq_zero.1 hne) 0 1).mono\n      Subset.rfl ?_\n    simpa only [lineMap_apply_zero, mul_one, coe_nndist] using ball_subset_ball hw\n  exact norm_max_aux₃ hr (hd.comp hde.diffContOnCl hball)\n      (hz.comp_mapsTo hball (lineMap_apply_zero z w))\n\n"}
{"name":"Complex.norm_eq_norm_of_isMaxOn_of_ball_subset","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Complex E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Complex F\nf : E → F\ns : Set E\nz w : E\nhd : DiffContOnCl Complex f s\nhz : IsMaxOn (Function.comp Norm.norm f) s z\nhsub : HasSubset.Subset (Metric.ball z (Dist.dist w z)) s\n⊢ Eq (Norm.norm (f w)) (Norm.norm (f z))","decl":"/-- **Maximum modulus principle**: if `f : E → F` is complex differentiable on a set `s`, the norm\nof `f` takes it maximum on `s` at `z`, and `w` is a point such that the closed ball with center `z`\nand radius `dist w z` is included in `s`, then `‖f w‖ = ‖f z‖`. -/\ntheorem norm_eq_norm_of_isMaxOn_of_ball_subset {f : E → F} {s : Set E} {z w : E}\n    (hd : DiffContOnCl ℂ f s) (hz : IsMaxOn (norm ∘ f) s z) (hsub : ball z (dist w z) ⊆ s) :\n    ‖f w‖ = ‖f z‖ :=\n  norm_eqOn_closedBall_of_isMaxOn (hd.mono hsub) (hz.on_subset hsub) (mem_closedBall.2 le_rfl)\n\n"}
{"name":"Complex.norm_eventually_eq_of_isLocalMax","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Complex E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Complex F\nf : E → F\nc : E\nhd : Filter.Eventually (fun z => DifferentiableAt Complex f z) (nhds c)\nhc : IsLocalMax (Function.comp Norm.norm f) c\n⊢ Filter.Eventually (fun y => Eq (Norm.norm (f y)) (Norm.norm (f c))) (nhds c)","decl":"/-- **Maximum modulus principle**: if `f : E → F` is complex differentiable in a neighborhood of `c`\nand the norm `‖f z‖` has a local maximum at `c`, then `‖f z‖` is locally constant in a neighborhood\nof `c`. -/\ntheorem norm_eventually_eq_of_isLocalMax {f : E → F} {c : E}\n    (hd : ∀ᶠ z in 𝓝 c, DifferentiableAt ℂ f z) (hc : IsLocalMax (norm ∘ f) c) :\n    ∀ᶠ y in 𝓝 c, ‖f y‖ = ‖f c‖ := by\n  rcases nhds_basis_closedBall.eventually_iff.1 (hd.and hc) with ⟨r, hr₀, hr⟩\n  exact nhds_basis_closedBall.eventually_iff.2\n    ⟨r, hr₀, norm_eqOn_closedBall_of_isMaxOn (DifferentiableOn.diffContOnCl fun x hx =>\n        (hr <| closure_ball_subset_closedBall hx).1.differentiableWithinAt) fun x hx =>\n      (hr <| ball_subset_closedBall hx).2⟩\n\n"}
{"name":"Complex.isOpen_setOf_mem_nhds_and_isMaxOn_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Complex E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Complex F\nf : E → F\ns : Set E\nhd : DifferentiableOn Complex f s\n⊢ IsOpen (setOf fun z => And (Membership.mem (nhds z) s) (IsMaxOn (Function.comp Norm.norm f) s z))","decl":"theorem isOpen_setOf_mem_nhds_and_isMaxOn_norm {f : E → F} {s : Set E}\n    (hd : DifferentiableOn ℂ f s) : IsOpen {z | s ∈ 𝓝 z ∧ IsMaxOn (norm ∘ f) s z} := by\n  refine isOpen_iff_mem_nhds.2 fun z hz => (eventually_eventually_nhds.2 hz.1).and ?_\n  replace hd : ∀ᶠ w in 𝓝 z, DifferentiableAt ℂ f w := hd.eventually_differentiableAt hz.1\n  exact (norm_eventually_eq_of_isLocalMax hd <| hz.2.isLocalMax hz.1).mono fun x hx y hy =>\n    le_trans (hz.2 hy).out hx.ge\n\n"}
{"name":"Complex.norm_eqOn_of_isPreconnected_of_isMaxOn","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Complex E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Complex F\nf : E → F\nU : Set E\nc : E\nhc : IsPreconnected U\nho : IsOpen U\nhd : DifferentiableOn Complex f U\nhcU : Membership.mem U c\nhm : IsMaxOn (Function.comp Norm.norm f) U c\n⊢ Set.EqOn (Function.comp Norm.norm f) (Function.const E (Norm.norm (f c))) U","decl":"/-- **Maximum modulus principle** on a connected set. Let `U` be a (pre)connected open set in a\ncomplex normed space. Let `f : E → F` be a function that is complex differentiable on `U`. Suppose\nthat `‖f x‖` takes its maximum value on `U` at `c ∈ U`. Then `‖f x‖ = ‖f c‖` for all `x ∈ U`. -/\ntheorem norm_eqOn_of_isPreconnected_of_isMaxOn {f : E → F} {U : Set E} {c : E}\n    (hc : IsPreconnected U) (ho : IsOpen U) (hd : DifferentiableOn ℂ f U) (hcU : c ∈ U)\n    (hm : IsMaxOn (norm ∘ f) U c) : EqOn (norm ∘ f) (const E ‖f c‖) U := by\n  set V := U ∩ {z | IsMaxOn (norm ∘ f) U z}\n  have hV : ∀ x ∈ V, ‖f x‖ = ‖f c‖ := fun x hx => le_antisymm (hm hx.1) (hx.2 hcU)\n  suffices U ⊆ V from fun x hx => hV x (this hx)\n  have hVo : IsOpen V := by\n    simpa only [ho.mem_nhds_iff, setOf_and, setOf_mem_eq]\n      using isOpen_setOf_mem_nhds_and_isMaxOn_norm hd\n  have hVne : (U ∩ V).Nonempty := ⟨c, hcU, hcU, hm⟩\n  set W := U ∩ {z | ‖f z‖ ≠ ‖f c‖}\n  have hWo : IsOpen W := hd.continuousOn.norm.isOpen_inter_preimage ho isOpen_ne\n  have hdVW : Disjoint V W := disjoint_left.mpr fun x hxV hxW => hxW.2 (hV x hxV)\n  have hUVW : U ⊆ V ∪ W := fun x hx =>\n    (eq_or_ne ‖f x‖ ‖f c‖).imp (fun h => ⟨hx, fun y hy => (hm hy).out.trans_eq h.symm⟩)\n      (And.intro hx)\n  exact hc.subset_left_of_subset_union hVo hWo hdVW hUVW hVne\n\n"}
{"name":"Complex.norm_eqOn_closure_of_isPreconnected_of_isMaxOn","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Complex E\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Complex F\nf : E → F\nU : Set E\nc : E\nhc : IsPreconnected U\nho : IsOpen U\nhd : DiffContOnCl Complex f U\nhcU : Membership.mem U c\nhm : IsMaxOn (Function.comp Norm.norm f) U c\n⊢ Set.EqOn (Function.comp Norm.norm f) (Function.const E (Norm.norm (f c))) (closure U)","decl":"/-- **Maximum modulus principle** on a connected set. Let `U` be a (pre)connected open set in a\ncomplex normed space.  Let `f : E → F` be a function that is complex differentiable on `U` and is\ncontinuous on its closure. Suppose that `‖f x‖` takes its maximum value on `U` at `c ∈ U`. Then\n`‖f x‖ = ‖f c‖` for all `x ∈ closure U`. -/\ntheorem norm_eqOn_closure_of_isPreconnected_of_isMaxOn {f : E → F} {U : Set E} {c : E}\n    (hc : IsPreconnected U) (ho : IsOpen U) (hd : DiffContOnCl ℂ f U) (hcU : c ∈ U)\n    (hm : IsMaxOn (norm ∘ f) U c) : EqOn (norm ∘ f) (const E ‖f c‖) (closure U) :=\n  (norm_eqOn_of_isPreconnected_of_isMaxOn hc ho hd.differentiableOn hcU hm).of_subset_closure\n    hd.continuousOn.norm continuousOn_const subset_closure Subset.rfl\n\n"}
{"name":"Complex.eqOn_of_isPreconnected_of_isMaxOn_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Complex E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Complex F\ninst✝ : StrictConvexSpace Real F\nf : E → F\nU : Set E\nc : E\nhc : IsPreconnected U\nho : IsOpen U\nhd : DifferentiableOn Complex f U\nhcU : Membership.mem U c\nhm : IsMaxOn (Function.comp Norm.norm f) U c\n⊢ Set.EqOn f (Function.const E (f c)) U","decl":"/-- **Maximum modulus principle** on a connected set. Let `U` be a (pre)connected open set in a\ncomplex normed space.  Let `f : E → F` be a function that is complex differentiable on `U`. Suppose\nthat `‖f x‖` takes its maximum value on `U` at `c ∈ U`. Then `f x = f c` for all `x ∈ U`.\n\nTODO: change assumption from `IsMaxOn` to `IsLocalMax`. -/\ntheorem eqOn_of_isPreconnected_of_isMaxOn_norm {f : E → F} {U : Set E} {c : E}\n    (hc : IsPreconnected U) (ho : IsOpen U) (hd : DifferentiableOn ℂ f U) (hcU : c ∈ U)\n    (hm : IsMaxOn (norm ∘ f) U c) : EqOn f (const E (f c)) U := fun x hx =>\n  have H₁ : ‖f x‖ = ‖f c‖ := norm_eqOn_of_isPreconnected_of_isMaxOn hc ho hd hcU hm hx\n  have H₂ : ‖f x + f c‖ = ‖f c + f c‖ :=\n    norm_eqOn_of_isPreconnected_of_isMaxOn hc ho (hd.add_const _) hcU hm.norm_add_self hx\n  eq_of_norm_eq_of_norm_add_eq H₁ <| by simp only [H₂, SameRay.rfl.norm_add, H₁, Function.const]\n\n"}
{"name":"Complex.eqOn_closure_of_isPreconnected_of_isMaxOn_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Complex E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Complex F\ninst✝ : StrictConvexSpace Real F\nf : E → F\nU : Set E\nc : E\nhc : IsPreconnected U\nho : IsOpen U\nhd : DiffContOnCl Complex f U\nhcU : Membership.mem U c\nhm : IsMaxOn (Function.comp Norm.norm f) U c\n⊢ Set.EqOn f (Function.const E (f c)) (closure U)","decl":"/-- **Maximum modulus principle** on a connected set. Let `U` be a (pre)connected open set in a\ncomplex normed space.  Let `f : E → F` be a function that is complex differentiable on `U` and is\ncontinuous on its closure. Suppose that `‖f x‖` takes its maximum value on `U` at `c ∈ U`. Then\n`f x = f c` for all `x ∈ closure U`. -/\ntheorem eqOn_closure_of_isPreconnected_of_isMaxOn_norm {f : E → F} {U : Set E} {c : E}\n    (hc : IsPreconnected U) (ho : IsOpen U) (hd : DiffContOnCl ℂ f U) (hcU : c ∈ U)\n    (hm : IsMaxOn (norm ∘ f) U c) : EqOn f (const E (f c)) (closure U) :=\n  (eqOn_of_isPreconnected_of_isMaxOn_norm hc ho hd.differentiableOn hcU hm).of_subset_closure\n    hd.continuousOn continuousOn_const subset_closure Subset.rfl\n\n"}
{"name":"Complex.eq_of_isMaxOn_of_ball_subset","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Complex E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Complex F\ninst✝ : StrictConvexSpace Real F\nf : E → F\ns : Set E\nz w : E\nhd : DiffContOnCl Complex f s\nhz : IsMaxOn (Function.comp Norm.norm f) s z\nhsub : HasSubset.Subset (Metric.ball z (Dist.dist w z)) s\n⊢ Eq (f w) (f z)","decl":"/-- **Maximum modulus principle**. Let `f : E → F` be a function between complex normed spaces.\nSuppose that the codomain `F` is a strictly convex space, `f` is complex differentiable on a set\n`s`, `f` is continuous on the closure of `s`, the norm of `f` takes it maximum on `s` at `z`, and\n`w` is a point such that the closed ball with center `z` and radius `dist w z` is included in `s`,\nthen `f w = f z`. -/\ntheorem eq_of_isMaxOn_of_ball_subset {f : E → F} {s : Set E} {z w : E} (hd : DiffContOnCl ℂ f s)\n    (hz : IsMaxOn (norm ∘ f) s z) (hsub : ball z (dist w z) ⊆ s) : f w = f z :=\n  have H₁ : ‖f w‖ = ‖f z‖ := norm_eq_norm_of_isMaxOn_of_ball_subset hd hz hsub\n  have H₂ : ‖f w + f z‖ = ‖f z + f z‖ :=\n    norm_eq_norm_of_isMaxOn_of_ball_subset (hd.add_const _) hz.norm_add_self hsub\n  eq_of_norm_eq_of_norm_add_eq H₁ <| by simp only [H₂, SameRay.rfl.norm_add, H₁]\n\n"}
{"name":"Complex.eqOn_closedBall_of_isMaxOn_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Complex E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Complex F\ninst✝ : StrictConvexSpace Real F\nf : E → F\nz : E\nr : Real\nhd : DiffContOnCl Complex f (Metric.ball z r)\nhz : IsMaxOn (Function.comp Norm.norm f) (Metric.ball z r) z\n⊢ Set.EqOn f (Function.const E (f z)) (Metric.closedBall z r)","decl":"/-- **Maximum modulus principle** on a closed ball. Suppose that a function `f : E → F` from a\nnormed complex space to a strictly convex normed complex space has the following properties:\n\n- it is continuous on a closed ball `Metric.closedBall z r`,\n- it is complex differentiable on the corresponding open ball;\n- the norm `‖f w‖` takes its maximum value on the open ball at its center.\n\nThen `f` is a constant on the closed ball. -/\ntheorem eqOn_closedBall_of_isMaxOn_norm {f : E → F} {z : E} {r : ℝ}\n    (hd : DiffContOnCl ℂ f (ball z r)) (hz : IsMaxOn (norm ∘ f) (ball z r) z) :\n    EqOn f (const E (f z)) (closedBall z r) := fun _x hx =>\n  eq_of_isMaxOn_of_ball_subset hd hz <| ball_subset_ball hx\n\n"}
{"name":"Complex.eq_const_of_exists_max","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Complex E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Complex F\ninst✝ : StrictConvexSpace Real F\nf : E → F\nb : Real\nh_an : DifferentiableOn Complex f (Metric.ball 0 b)\nv : E\nhv : Membership.mem (Metric.ball 0 b) v\nhv_max : IsMaxOn (Function.comp Norm.norm f) (Metric.ball 0 b) v\n⊢ Set.EqOn f (Function.const E (f v)) (Metric.ball 0 b)","decl":"/-- If `f` is differentiable on the open unit ball `{z : ℂ | ‖z‖ < 1}`, and `‖f‖` attains a maximum\nin this open ball, then `f` is constant.-/\nlemma eq_const_of_exists_max {f : E → F} {b : ℝ} (h_an : DifferentiableOn ℂ f (ball 0 b))\n    {v : E} (hv : v ∈ ball 0 b) (hv_max : IsMaxOn (norm ∘ f) (ball 0 b) v) :\n    Set.EqOn f (Function.const E (f v)) (ball 0 b) :=\n  Complex.eqOn_of_isPreconnected_of_isMaxOn_norm (convex_ball 0 b).isPreconnected\n    isOpen_ball h_an hv hv_max\n\n"}
{"name":"Complex.eq_const_of_exists_le","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Complex E\nF : Type v\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Complex F\ninst✝¹ : StrictConvexSpace Real F\ninst✝ : ProperSpace E\nf : E → F\nr b : Real\nh_an : DifferentiableOn Complex f (Metric.ball 0 b)\nhr_nn : LE.le 0 r\nhr_lt : LT.lt r b\nhr : ∀ (z : E), Membership.mem (Metric.ball 0 b) z → Exists fun w => And (Membership.mem (Metric.closedBall 0 r) w) (LE.le (Norm.norm (f z)) (Norm.norm (f w)))\n⊢ Set.EqOn f (Function.const E (f 0)) (Metric.ball 0 b)","decl":"/-- If `f` is a function differentiable on the open unit ball, and there exists an `r < 1` such that\nany value of `‖f‖` on the open ball is bounded above by some value on the closed ball of radius `r`,\nthen `f` is constant. -/\nlemma eq_const_of_exists_le [ProperSpace E] {f : E → F} {r b : ℝ}\n    (h_an : DifferentiableOn ℂ f (ball 0 b)) (hr_nn : 0 ≤ r) (hr_lt : r < b)\n    (hr : ∀ z, z ∈ (ball 0 b) → ∃ w, w ∈ closedBall 0 r ∧ ‖f z‖ ≤ ‖f w‖) :\n    Set.EqOn f (Function.const E (f 0)) (ball 0 b) := by\n  obtain ⟨x, hx_mem, hx_max⟩ := isCompact_closedBall (0 : E) r |>.exists_isMaxOn\n    (nonempty_closedBall.mpr hr_nn)\n    (h_an.continuousOn.mono <| closedBall_subset_ball hr_lt).norm\n  suffices Set.EqOn f (Function.const E (f x)) (ball 0 b) by\n    rwa [this (mem_ball_self (hr_nn.trans_lt hr_lt))]\n  apply eq_const_of_exists_max h_an (closedBall_subset_ball hr_lt hx_mem) (fun z hz ↦ ?_)\n  obtain ⟨w, hw, hw'⟩ := hr z hz\n  exact hw'.trans (hx_max hw)\n\n"}
{"name":"Complex.eventually_eq_of_isLocalMax_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Complex E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Complex F\ninst✝ : StrictConvexSpace Real F\nf : E → F\nc : E\nhd : Filter.Eventually (fun z => DifferentiableAt Complex f z) (nhds c)\nhc : IsLocalMax (Function.comp Norm.norm f) c\n⊢ Filter.Eventually (fun y => Eq (f y) (f c)) (nhds c)","decl":"/-- **Maximum modulus principle**: if `f : E → F` is complex differentiable in a neighborhood of `c`\nand the norm `‖f z‖` has a local maximum at `c`, then `f` is locally constant in a neighborhood\nof `c`. -/\ntheorem eventually_eq_of_isLocalMax_norm {f : E → F} {c : E}\n    (hd : ∀ᶠ z in 𝓝 c, DifferentiableAt ℂ f z) (hc : IsLocalMax (norm ∘ f) c) :\n    ∀ᶠ y in 𝓝 c, f y = f c := by\n  rcases nhds_basis_closedBall.eventually_iff.1 (hd.and hc) with ⟨r, hr₀, hr⟩\n  exact nhds_basis_closedBall.eventually_iff.2\n    ⟨r, hr₀, eqOn_closedBall_of_isMaxOn_norm (DifferentiableOn.diffContOnCl fun x hx =>\n        (hr <| closure_ball_subset_closedBall hx).1.differentiableWithinAt) fun x hx =>\n      (hr <| ball_subset_closedBall hx).2⟩\n\n"}
{"name":"Complex.eventually_eq_or_eq_zero_of_isLocalMin_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Complex E\nf : E → Complex\nc : E\nhf : Filter.Eventually (fun z => DifferentiableAt Complex f z) (nhds c)\nhc : IsLocalMin (Function.comp Norm.norm f) c\n⊢ Or (Filter.Eventually (fun z => Eq (f z) (f c)) (nhds c)) (Eq (f c) 0)","decl":"theorem eventually_eq_or_eq_zero_of_isLocalMin_norm {f : E → ℂ} {c : E}\n    (hf : ∀ᶠ z in 𝓝 c, DifferentiableAt ℂ f z) (hc : IsLocalMin (norm ∘ f) c) :\n    (∀ᶠ z in 𝓝 c, f z = f c) ∨ f c = 0 := by\n  refine or_iff_not_imp_right.mpr fun h => ?_\n  have h1 : ∀ᶠ z in 𝓝 c, f z ≠ 0 := hf.self_of_nhds.continuousAt.eventually_ne h\n  have h2 : IsLocalMax (norm ∘ f)⁻¹ c := hc.inv (h1.mono fun z => norm_pos_iff.mpr)\n  have h3 : IsLocalMax (norm ∘ f⁻¹) c := by refine h2.congr (Eventually.of_forall ?_); simp\n  have h4 : ∀ᶠ z in 𝓝 c, DifferentiableAt ℂ f⁻¹ z := by filter_upwards [hf, h1] with z h using h.inv\n  filter_upwards [eventually_eq_of_isLocalMax_norm h4 h3] with z using inv_inj.mp\n\n"}
{"name":"Complex.exists_mem_frontier_isMaxOn_norm","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Complex E\nF : Type v\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Complex F\ninst✝¹ : Nontrivial E\ninst✝ : FiniteDimensional Complex E\nf : E → F\nU : Set E\nhb : Bornology.IsBounded U\nhne : U.Nonempty\nhd : DiffContOnCl Complex f U\n⊢ Exists fun z => And (Membership.mem (frontier U) z) (IsMaxOn (Function.comp Norm.norm f) (closure U) z)","decl":"/-- **Maximum modulus principle**: if `f : E → F` is complex differentiable on a nonempty bounded\nset `U` and is continuous on its closure, then there exists a point `z ∈ frontier U` such that\n`(‖f ·‖)` takes it maximum value on `closure U` at `z`. -/\ntheorem exists_mem_frontier_isMaxOn_norm [FiniteDimensional ℂ E] {f : E → F} {U : Set E}\n    (hb : IsBounded U) (hne : U.Nonempty) (hd : DiffContOnCl ℂ f U) :\n    ∃ z ∈ frontier U, IsMaxOn (norm ∘ f) (closure U) z := by\n  have hc : IsCompact (closure U) := hb.isCompact_closure\n  obtain ⟨w, hwU, hle⟩ : ∃ w ∈ closure U, IsMaxOn (norm ∘ f) (closure U) w :=\n    hc.exists_isMaxOn hne.closure hd.continuousOn.norm\n  rw [closure_eq_interior_union_frontier, mem_union] at hwU\n  cases' hwU with hwU hwU; rotate_left; · exact ⟨w, hwU, hle⟩\n  have : interior U ≠ univ := ne_top_of_le_ne_top hc.ne_univ interior_subset_closure\n  rcases exists_mem_frontier_infDist_compl_eq_dist hwU this with ⟨z, hzU, hzw⟩\n  refine ⟨z, frontier_interior_subset hzU, fun x hx => (hle hx).out.trans_eq ?_⟩\n  refine (norm_eq_norm_of_isMaxOn_of_ball_subset hd (hle.on_subset subset_closure) ?_).symm\n  rw [dist_comm, ← hzw]\n  exact ball_infDist_compl_subset.trans interior_subset\n\n"}
{"name":"Complex.norm_le_of_forall_mem_frontier_norm_le","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Complex E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Complex F\ninst✝ : Nontrivial E\nf : E → F\nU : Set E\nhU : Bornology.IsBounded U\nhd : DiffContOnCl Complex f U\nC : Real\nhC : ∀ (z : E), Membership.mem (frontier U) z → LE.le (Norm.norm (f z)) C\nz : E\nhz : Membership.mem (closure U) z\n⊢ LE.le (Norm.norm (f z)) C","decl":"/-- **Maximum modulus principle**: if `f : E → F` is complex differentiable on a bounded set `U` and\n`‖f z‖ ≤ C` for any `z ∈ frontier U`, then the same is true for any `z ∈ closure U`. -/\ntheorem norm_le_of_forall_mem_frontier_norm_le {f : E → F} {U : Set E} (hU : IsBounded U)\n    (hd : DiffContOnCl ℂ f U) {C : ℝ} (hC : ∀ z ∈ frontier U, ‖f z‖ ≤ C) {z : E}\n    (hz : z ∈ closure U) : ‖f z‖ ≤ C := by\n  rw [closure_eq_self_union_frontier, union_comm, mem_union] at hz\n  cases' hz with hz hz; · exact hC z hz\n  /- In case of a finite dimensional domain, one can just apply\n    `Complex.exists_mem_frontier_isMaxOn_norm`. To make it work in any Banach space, we restrict\n    the function to a line first. -/\n  rcases exists_ne z with ⟨w, hne⟩\n  set e := (lineMap z w : ℂ → E)\n  have hde : Differentiable ℂ e := (differentiable_id.smul_const (w - z)).add_const z\n  have hL : AntilipschitzWith (nndist z w)⁻¹ e := antilipschitzWith_lineMap hne.symm\n  replace hd : DiffContOnCl ℂ (f ∘ e) (e ⁻¹' U) :=\n    hd.comp hde.diffContOnCl (mapsTo_preimage _ _)\n  have h₀ : (0 : ℂ) ∈ e ⁻¹' U := by simpa only [e, mem_preimage, lineMap_apply_zero]\n  rcases exists_mem_frontier_isMaxOn_norm (hL.isBounded_preimage hU) ⟨0, h₀⟩ hd with ⟨ζ, hζU, hζ⟩\n  calc\n    ‖f z‖ = ‖f (e 0)‖ := by simp only [e, lineMap_apply_zero]\n    _ ≤ ‖f (e ζ)‖ := hζ (subset_closure h₀)\n    _ ≤ C := hC _ (hde.continuous.frontier_preimage_subset _ hζU)\n\n"}
{"name":"Complex.eqOn_closure_of_eqOn_frontier","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Complex E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Complex F\ninst✝ : Nontrivial E\nf g : E → F\nU : Set E\nhU : Bornology.IsBounded U\nhf : DiffContOnCl Complex f U\nhg : DiffContOnCl Complex g U\nhfg : Set.EqOn f g (frontier U)\n⊢ Set.EqOn f g (closure U)","decl":"/-- If two complex differentiable functions `f g : E → F` are equal on the boundary of a bounded set\n`U`, then they are equal on `closure U`. -/\ntheorem eqOn_closure_of_eqOn_frontier {f g : E → F} {U : Set E} (hU : IsBounded U)\n    (hf : DiffContOnCl ℂ f U) (hg : DiffContOnCl ℂ g U) (hfg : EqOn f g (frontier U)) :\n    EqOn f g (closure U) := by\n  suffices H : ∀ z ∈ closure U, ‖(f - g) z‖ ≤ 0 by simpa [sub_eq_zero] using H\n  refine fun z hz => norm_le_of_forall_mem_frontier_norm_le hU (hf.sub hg) (fun w hw => ?_) hz\n  simp [hfg hw]\n\n"}
{"name":"Complex.eqOn_of_eqOn_frontier","module":"Mathlib.Analysis.Complex.AbsMax","initialProofState":"E : Type u\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Complex E\nF : Type v\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Complex F\ninst✝ : Nontrivial E\nf g : E → F\nU : Set E\nhU : Bornology.IsBounded U\nhf : DiffContOnCl Complex f U\nhg : DiffContOnCl Complex g U\nhfg : Set.EqOn f g (frontier U)\n⊢ Set.EqOn f g U","decl":"/-- If two complex differentiable functions `f g : E → F` are equal on the boundary of a bounded set\n`U`, then they are equal on `U`. -/\ntheorem eqOn_of_eqOn_frontier {f g : E → F} {U : Set E} (hU : IsBounded U) (hf : DiffContOnCl ℂ f U)\n    (hg : DiffContOnCl ℂ g U) (hfg : EqOn f g (frontier U)) : EqOn f g U :=\n  (eqOn_closure_of_eqOn_frontier hU hf hg hfg).mono subset_closure\n\n"}
