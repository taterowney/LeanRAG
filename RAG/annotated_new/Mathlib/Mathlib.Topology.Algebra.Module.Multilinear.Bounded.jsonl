{"name":"Bornology.IsVonNBounded.image_multilinear'","module":"Mathlib.Topology.Algebra.Module.Multilinear.Bounded","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\nF : Type u_3\nE : ι → Type u_4\ninst✝⁷ : NormedField 𝕜\ninst✝⁶ : (i : ι) → AddCommGroup (E i)\ninst✝⁵ : (i : ι) → Module 𝕜 (E i)\ninst✝⁴ : (i : ι) → TopologicalSpace (E i)\ninst✝³ : AddCommGroup F\ninst✝² : Module 𝕜 F\ninst✝¹ : TopologicalSpace F\ninst✝ : Nonempty ι\ns : Set ((i : ι) → E i)\nhs : Bornology.IsVonNBounded 𝕜 s\nf : ContinuousMultilinearMap 𝕜 E F\n⊢ Bornology.IsVonNBounded 𝕜 (Set.image (⇑f) s)","decl":"/-- The image of a von Neumann bounded set under a continuous multilinear map\nis von Neumann bounded.\n\nThis version does not assume that the topologies on the domain and on the codomain\nagree with the vector space structure in any way\nbut it assumes that `ι` is nonempty.\n-/\ntheorem image_multilinear' [Nonempty ι] {s : Set (∀ i, E i)} (hs : IsVonNBounded 𝕜 s)\n    (f : ContinuousMultilinearMap 𝕜 E F) : IsVonNBounded 𝕜 (f '' s) := fun V hV ↦ by\n  classical\n  if h₁ : ∀ c : 𝕜, ‖c‖ ≤ 1 then\n    exact absorbs_iff_norm.2 ⟨2, fun c hc ↦ by linarith [h₁ c]⟩\n  else\n    let _ : NontriviallyNormedField 𝕜 := ⟨by simpa using h₁⟩\n    obtain ⟨I, t, ht₀, hft⟩ :\n        ∃ (I : Finset ι) (t : ∀ i, Set (E i)), (∀ i, t i ∈ 𝓝 0) ∧ Set.pi I t ⊆ f ⁻¹' V := by\n      have hfV : f ⁻¹' V ∈ 𝓝 0 := (map_continuous f).tendsto' _ _ f.map_zero hV\n      rwa [nhds_pi, Filter.mem_pi, exists_finite_iff_finset] at hfV\n    have : ∀ i, ∃ c : 𝕜, c ≠ 0 ∧ ∀ c' : 𝕜, ‖c'‖ ≤ ‖c‖ → ∀ x ∈ s, c' • x i ∈ t i := fun i ↦ by\n      rw [isVonNBounded_pi_iff] at hs\n      have := (hs i).tendsto_smallSets_nhds.eventually (mem_lift' (ht₀ i))\n      rcases NormedAddCommGroup.nhds_zero_basis_norm_lt.eventually_iff.1 this with ⟨r, hr₀, hr⟩\n      rcases NormedField.exists_norm_lt 𝕜 hr₀ with ⟨c, hc₀, hc⟩\n      refine ⟨c, norm_pos_iff.1 hc₀, fun c' hle x hx ↦ ?_⟩\n      exact hr (hle.trans_lt hc) ⟨_, ⟨x, hx, rfl⟩, rfl⟩\n    choose c hc₀ hc using this\n    rw [absorbs_iff_eventually_nhds_zero (mem_of_mem_nhds hV),\n      NormedAddCommGroup.nhds_zero_basis_norm_lt.eventually_iff]\n    have hc₀' : ∏ i ∈ I, c i ≠ 0 := Finset.prod_ne_zero_iff.2 fun i _ ↦ hc₀ i\n    refine ⟨‖∏ i ∈ I, c i‖, norm_pos_iff.2 hc₀', fun a ha ↦ mapsTo_image_iff.2 fun x hx ↦ ?_⟩\n    let ⟨i₀⟩ := ‹Nonempty ι›\n    set y := I.piecewise (fun i ↦ c i • x i) x\n    calc\n      f (update y i₀ ((a / ∏ i ∈ I, c i) • y i₀)) ∈ V := hft fun i hi => by\n        rcases eq_or_ne i i₀ with rfl | hne\n        · simp_rw [update_self, y, I.piecewise_eq_of_mem _ _ hi, smul_smul]\n          refine hc _ _ ?_ _ hx\n          calc\n            ‖(a / ∏ i ∈ I, c i) * c i‖ ≤ (‖∏ i ∈ I, c i‖ / ‖∏ i ∈ I, c i‖) * ‖c i‖ := by\n              rw [norm_mul, norm_div]; gcongr; exact ha.out.le\n            _ ≤ 1 * ‖c i‖ := by gcongr; apply div_self_le_one\n            _ = ‖c i‖ := one_mul _\n        · simp_rw [update_of_ne hne, y, I.piecewise_eq_of_mem _ _ hi]\n          exact hc _ _ le_rfl _ hx\n      _ = a • f x := by\n        rw [f.map_update_smul, update_eq_self, f.map_piecewise_smul, div_eq_mul_inv, mul_smul,\n          inv_smul_smul₀ hc₀']\n\n"}
{"name":"Bornology.IsVonNBounded.image_multilinear","module":"Mathlib.Topology.Algebra.Module.Multilinear.Bounded","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\nF : Type u_3\nE : ι → Type u_4\ninst✝⁷ : NormedField 𝕜\ninst✝⁶ : (i : ι) → AddCommGroup (E i)\ninst✝⁵ : (i : ι) → Module 𝕜 (E i)\ninst✝⁴ : (i : ι) → TopologicalSpace (E i)\ninst✝³ : AddCommGroup F\ninst✝² : Module 𝕜 F\ninst✝¹ : TopologicalSpace F\ninst✝ : ContinuousSMul 𝕜 F\ns : Set ((i : ι) → E i)\nhs : Bornology.IsVonNBounded 𝕜 s\nf : ContinuousMultilinearMap 𝕜 E F\n⊢ Bornology.IsVonNBounded 𝕜 (Set.image (⇑f) s)","decl":"/-- The image of a von Neumann bounded set under a continuous multilinear map\nis von Neumann bounded.\n\nThis version assumes that the codomain is a topological vector space.\n-/\ntheorem image_multilinear [ContinuousSMul 𝕜 F] {s : Set (∀ i, E i)} (hs : IsVonNBounded 𝕜 s)\n    (f : ContinuousMultilinearMap 𝕜 E F) : IsVonNBounded 𝕜 (f '' s) := by\n  cases isEmpty_or_nonempty ι with\n  | inl h =>\n    exact (isBounded_iff_isVonNBounded _).1 <|\n      @Set.Finite.isBounded _ (vonNBornology 𝕜 F) _ (s.toFinite.image _)\n  | inr h => exact hs.image_multilinear' f\n\n"}
