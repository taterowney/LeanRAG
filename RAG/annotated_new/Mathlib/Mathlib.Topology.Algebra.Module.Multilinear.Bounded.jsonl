{"name":"Bornology.IsVonNBounded.image_multilinear'","module":"Mathlib.Topology.Algebra.Module.Multilinear.Bounded","initialProofState":"Î¹ : Type u_1\nð•œ : Type u_2\nF : Type u_3\nE : Î¹ â†’ Type u_4\ninstâœâ· : NormedField ð•œ\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ Module ð•œ (E i)\ninstâœâ´ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ð•œ F\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : Nonempty Î¹\ns : Set ((i : Î¹) â†’ E i)\nhs : Bornology.IsVonNBounded ð•œ s\nf : ContinuousMultilinearMap ð•œ E F\nâŠ¢ Bornology.IsVonNBounded ð•œ (Set.image (â‡‘f) s)","decl":"/-- The image of a von Neumann bounded set under a continuous multilinear map\nis von Neumann bounded.\n\nThis version does not assume that the topologies on the domain and on the codomain\nagree with the vector space structure in any way\nbut it assumes that `Î¹` is nonempty.\n-/\ntheorem image_multilinear' [Nonempty Î¹] {s : Set (âˆ€ i, E i)} (hs : IsVonNBounded ð•œ s)\n    (f : ContinuousMultilinearMap ð•œ E F) : IsVonNBounded ð•œ (f '' s) := fun V hV â†¦ by\n  classical\n  if hâ‚ : âˆ€ c : ð•œ, â€–câ€– â‰¤ 1 then\n    exact absorbs_iff_norm.2 âŸ¨2, fun c hc â†¦ by linarith [hâ‚ c]âŸ©\n  else\n    let _ : NontriviallyNormedField ð•œ := âŸ¨by simpa using hâ‚âŸ©\n    obtain âŸ¨I, t, htâ‚€, hftâŸ© :\n        âˆƒ (I : Finset Î¹) (t : âˆ€ i, Set (E i)), (âˆ€ i, t i âˆˆ ð“ 0) âˆ§ Set.pi I t âŠ† f â»Â¹' V := by\n      have hfV : f â»Â¹' V âˆˆ ð“ 0 := (map_continuous f).tendsto' _ _ f.map_zero hV\n      rwa [nhds_pi, Filter.mem_pi, exists_finite_iff_finset] at hfV\n    have : âˆ€ i, âˆƒ c : ð•œ, c â‰  0 âˆ§ âˆ€ c' : ð•œ, â€–c'â€– â‰¤ â€–câ€– â†’ âˆ€ x âˆˆ s, c' â€¢ x i âˆˆ t i := fun i â†¦ by\n      rw [isVonNBounded_pi_iff] at hs\n      have := (hs i).tendsto_smallSets_nhds.eventually (mem_lift' (htâ‚€ i))\n      rcases NormedAddCommGroup.nhds_zero_basis_norm_lt.eventually_iff.1 this with âŸ¨r, hrâ‚€, hrâŸ©\n      rcases NormedField.exists_norm_lt ð•œ hrâ‚€ with âŸ¨c, hcâ‚€, hcâŸ©\n      refine âŸ¨c, norm_pos_iff.1 hcâ‚€, fun c' hle x hx â†¦ ?_âŸ©\n      exact hr (hle.trans_lt hc) âŸ¨_, âŸ¨x, hx, rflâŸ©, rflâŸ©\n    choose c hcâ‚€ hc using this\n    rw [absorbs_iff_eventually_nhds_zero (mem_of_mem_nhds hV),\n      NormedAddCommGroup.nhds_zero_basis_norm_lt.eventually_iff]\n    have hcâ‚€' : âˆ i âˆˆ I, c i â‰  0 := Finset.prod_ne_zero_iff.2 fun i _ â†¦ hcâ‚€ i\n    refine âŸ¨â€–âˆ i âˆˆ I, c iâ€–, norm_pos_iff.2 hcâ‚€', fun a ha â†¦ mapsTo_image_iff.2 fun x hx â†¦ ?_âŸ©\n    let âŸ¨iâ‚€âŸ© := â€¹Nonempty Î¹â€º\n    set y := I.piecewise (fun i â†¦ c i â€¢ x i) x\n    calc\n      f (update y iâ‚€ ((a / âˆ i âˆˆ I, c i) â€¢ y iâ‚€)) âˆˆ V := hft fun i hi => by\n        rcases eq_or_ne i iâ‚€ with rfl | hne\n        Â· simp_rw [update_self, y, I.piecewise_eq_of_mem _ _ hi, smul_smul]\n          refine hc _ _ ?_ _ hx\n          calc\n            â€–(a / âˆ i âˆˆ I, c i) * c iâ€– â‰¤ (â€–âˆ i âˆˆ I, c iâ€– / â€–âˆ i âˆˆ I, c iâ€–) * â€–c iâ€– := by\n              rw [norm_mul, norm_div]; gcongr; exact ha.out.le\n            _ â‰¤ 1 * â€–c iâ€– := by gcongr; apply div_self_le_one\n            _ = â€–c iâ€– := one_mul _\n        Â· simp_rw [update_of_ne hne, y, I.piecewise_eq_of_mem _ _ hi]\n          exact hc _ _ le_rfl _ hx\n      _ = a â€¢ f x := by\n        rw [f.map_update_smul, update_eq_self, f.map_piecewise_smul, div_eq_mul_inv, mul_smul,\n          inv_smul_smulâ‚€ hcâ‚€']\n\n"}
{"name":"Bornology.IsVonNBounded.image_multilinear","module":"Mathlib.Topology.Algebra.Module.Multilinear.Bounded","initialProofState":"Î¹ : Type u_1\nð•œ : Type u_2\nF : Type u_3\nE : Î¹ â†’ Type u_4\ninstâœâ· : NormedField ð•œ\ninstâœâ¶ : (i : Î¹) â†’ AddCommGroup (E i)\ninstâœâµ : (i : Î¹) â†’ Module ð•œ (E i)\ninstâœâ´ : (i : Î¹) â†’ TopologicalSpace (E i)\ninstâœÂ³ : AddCommGroup F\ninstâœÂ² : Module ð•œ F\ninstâœÂ¹ : TopologicalSpace F\ninstâœ : ContinuousSMul ð•œ F\ns : Set ((i : Î¹) â†’ E i)\nhs : Bornology.IsVonNBounded ð•œ s\nf : ContinuousMultilinearMap ð•œ E F\nâŠ¢ Bornology.IsVonNBounded ð•œ (Set.image (â‡‘f) s)","decl":"/-- The image of a von Neumann bounded set under a continuous multilinear map\nis von Neumann bounded.\n\nThis version assumes that the codomain is a topological vector space.\n-/\ntheorem image_multilinear [ContinuousSMul ð•œ F] {s : Set (âˆ€ i, E i)} (hs : IsVonNBounded ð•œ s)\n    (f : ContinuousMultilinearMap ð•œ E F) : IsVonNBounded ð•œ (f '' s) := by\n  cases isEmpty_or_nonempty Î¹ with\n  | inl h =>\n    exact (isBounded_iff_isVonNBounded _).1 <|\n      @Set.Finite.isBounded _ (vonNBornology ð•œ F) _ (s.toFinite.image _)\n  | inr h => exact hs.image_multilinear' f\n\n"}
