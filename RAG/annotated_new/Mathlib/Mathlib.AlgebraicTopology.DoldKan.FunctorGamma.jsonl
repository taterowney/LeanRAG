{"name":"AlgebraicTopology.DoldKan.IsÎ´â‚€.iff","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"j : Nat\ni : Fin (HAdd.hAdd j 2)\nâŠ¢ Iff (AlgebraicTopology.DoldKan.IsÎ´â‚€ (SimplexCategory.Î´ i)) (Eq i 0)","decl":"theorem iff {j : â„•} {i : Fin (j + 2)} : IsÎ´â‚€ (SimplexCategory.Î´ i) â†” i = 0 := by\n  constructor\n  Â· rintro âŸ¨_, hâ‚‚âŸ©\n    by_contra h\n    exact hâ‚‚ (Fin.succAbove_ne_zero_zero h)\n  Â· rintro rfl\n    exact âŸ¨rfl, by dsimp; exact Fin.succ_ne_zero (0 : Fin (j + 1))âŸ©\n\n"}
{"name":"AlgebraicTopology.DoldKan.IsÎ´â‚€.eq_Î´â‚€","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"n : Nat\ni : Quiver.Hom (SimplexCategory.mk n) (SimplexCategory.mk (HAdd.hAdd n 1))\ninstâœ : CategoryTheory.Mono i\nhi : AlgebraicTopology.DoldKan.IsÎ´â‚€ i\nâŠ¢ Eq i (SimplexCategory.Î´ 0)","decl":"theorem eq_Î´â‚€ {n : â„•} {i : ([n] : SimplexCategory) âŸ¶ [n + 1]} [Mono i] (hi : IsÎ´â‚€ i) :\n    i = SimplexCategory.Î´ 0 := by\n  obtain âŸ¨j, rflâŸ© := SimplexCategory.eq_Î´_of_mono i\n  rw [iff] at hi\n  rw [hi]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_id","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\nÎ” : SimplexCategory\nâŠ¢ Eq (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K (CategoryTheory.CategoryStruct.id Î”)) (CategoryTheory.CategoryStruct.id (K.X Î”.len))","decl":"theorem mapMono_id : mapMono K (ğŸ™ Î”) = ğŸ™ _ := by\n  unfold mapMono\n  simp only [eq_self_iff_true, eqToHom_refl, dite_eq_ite, if_true]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_Î´â‚€'","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\nÎ” Î”' : SimplexCategory\ni : Quiver.Hom Î”' Î”\ninstâœ : CategoryTheory.Mono i\nhi : AlgebraicTopology.DoldKan.IsÎ´â‚€ i\nâŠ¢ Eq (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i) (K.d Î”.len Î”'.len)","decl":"theorem mapMono_Î´â‚€' (i : Î”' âŸ¶ Î”) [Mono i] (hi : IsÎ´â‚€ i) : mapMono K i = K.d Î”.len Î”'.len := by\n  unfold mapMono\n  suffices Î” â‰  Î”' by\n    simp only [dif_neg this, dif_pos hi]\n  rintro rfl\n  simpa only [self_eq_add_right, Nat.one_ne_zero] using hi.1\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_Î´â‚€","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\nn : Nat\nâŠ¢ Eq (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K (SimplexCategory.Î´ 0)) (K.d (HAdd.hAdd n 1) n)","decl":"@[simp]\ntheorem mapMono_Î´â‚€ {n : â„•} : mapMono K (Î´ (0 : Fin (n + 2))) = K.d (n + 1) n :=\n  mapMono_Î´â‚€' K _ (by rw [IsÎ´â‚€.iff])\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\nÎ” Î”' : SimplexCategory\ni : Quiver.Hom Î”' Î”\ninstâœ : CategoryTheory.Mono i\nhâ‚ : Ne Î” Î”'\nhâ‚‚ : Not (AlgebraicTopology.DoldKan.IsÎ´â‚€ i)\nâŠ¢ Eq (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i) 0","decl":"theorem mapMono_eq_zero (i : Î”' âŸ¶ Î”) [Mono i] (hâ‚ : Î” â‰  Î”') (hâ‚‚ : Â¬IsÎ´â‚€ i) : mapMono K i = 0 := by\n  unfold mapMono\n  rw [Ne] at hâ‚\n  split_ifs\n  rfl\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_naturality_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nK K' : ChainComplex C Nat\nf : Quiver.Hom K K'\nÎ” Î”' : SimplexCategory\ni : Quiver.Hom Î” Î”'\ninstâœ : CategoryTheory.Mono i\nZ : C\nh : Quiver.Hom (K'.X Î”.len) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i) (CategoryTheory.CategoryStruct.comp (f.f Î”.len) h)) (CategoryTheory.CategoryStruct.comp (f.f Î”'.len) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K' i) h))","decl":"@[reassoc (attr := simp)]\ntheorem mapMono_naturality (i : Î” âŸ¶ Î”') [Mono i] :\n    mapMono K i â‰« f.f Î”.len = f.f Î”'.len â‰« mapMono K' i := by\n  unfold mapMono\n  split_ifs with h\n  Â· subst h\n    simp only [id_comp, eqToHom_refl, comp_id]\n  Â· rw [HomologicalComplex.Hom.comm]\n  Â· rw [zero_comp, comp_zero]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_naturality","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nK K' : ChainComplex C Nat\nf : Quiver.Hom K K'\nÎ” Î”' : SimplexCategory\ni : Quiver.Hom Î” Î”'\ninstâœ : CategoryTheory.Mono i\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i) (f.f Î”.len)) (CategoryTheory.CategoryStruct.comp (f.f Î”'.len) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K' i))","decl":"@[reassoc (attr := simp)]\ntheorem mapMono_naturality (i : Î” âŸ¶ Î”') [Mono i] :\n    mapMono K i â‰« f.f Î”.len = f.f Î”'.len â‰« mapMono K' i := by\n  unfold mapMono\n  split_ifs with h\n  Â· subst h\n    simp only [id_comp, eqToHom_refl, comp_id]\n  Â· rw [HomologicalComplex.Hom.comm]\n  Â· rw [zero_comp, comp_zero]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_comp_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\nÎ” Î”' Î”'' : SimplexCategory\ni' : Quiver.Hom Î”'' Î”'\ni : Quiver.Hom Î”' Î”\ninstâœÂ¹ : CategoryTheory.Mono i'\ninstâœ : CategoryTheory.Mono i\nZ : C\nh : Quiver.Hom (K.X Î”''.len) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i') h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K (CategoryTheory.CategoryStruct.comp i' i)) h)","decl":"@[reassoc (attr := simp)]\ntheorem mapMono_comp (i' : Î”'' âŸ¶ Î”') (i : Î”' âŸ¶ Î”) [Mono i'] [Mono i] :\n    mapMono K i â‰« mapMono K i' = mapMono K (i' â‰« i) := by\n  -- case where i : Î”' âŸ¶ Î” is the identity\n  by_cases hâ‚ : Î” = Î”'\n  Â· subst hâ‚\n    simp only [SimplexCategory.eq_id_of_mono i, comp_id, id_comp, mapMono_id K, eqToHom_refl]\n  -- case where i' : Î”'' âŸ¶ Î”' is the identity\n  by_cases hâ‚‚ : Î”' = Î”''\n  Â· subst hâ‚‚\n    simp only [SimplexCategory.eq_id_of_mono i', comp_id, id_comp, mapMono_id K, eqToHom_refl]\n  -- then the RHS is always zero\n  obtain âŸ¨k, hkâŸ© := Nat.exists_eq_add_of_lt (len_lt_of_mono i hâ‚)\n  obtain âŸ¨k', hk'âŸ© := Nat.exists_eq_add_of_lt (len_lt_of_mono i' hâ‚‚)\n  have eq : Î”.len = Î”''.len + (k + k' + 2) := by omega\n  rw [mapMono_eq_zero K (i' â‰« i) _ _]; rotate_left\n  Â· by_contra h\n    simp only [self_eq_add_right, h, add_eq_zero, and_false, reduceCtorEq] at eq\n  Â· by_contra h\n    simp only [h.1, add_right_inj] at eq\n    omega\n  -- in all cases, the LHS is also zero, either by definition, or because d â‰« d = 0\n  by_cases hâ‚ƒ : IsÎ´â‚€ i\n  Â· by_cases hâ‚„ : IsÎ´â‚€ i'\n    Â· rw [mapMono_Î´â‚€' K i hâ‚ƒ, mapMono_Î´â‚€' K i' hâ‚„, HomologicalComplex.d_comp_d]\n    Â· simp only [mapMono_eq_zero K i' hâ‚‚ hâ‚„, comp_zero]\n  Â· simp only [mapMono_eq_zero K i hâ‚ hâ‚ƒ, zero_comp]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono_comp","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\nÎ” Î”' Î”'' : SimplexCategory\ni' : Quiver.Hom Î”'' Î”'\ni : Quiver.Hom Î”' Î”\ninstâœÂ¹ : CategoryTheory.Mono i'\ninstâœ : CategoryTheory.Mono i\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i')) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K (CategoryTheory.CategoryStruct.comp i' i))","decl":"@[reassoc (attr := simp)]\ntheorem mapMono_comp (i' : Î”'' âŸ¶ Î”') (i : Î”' âŸ¶ Î”) [Mono i'] [Mono i] :\n    mapMono K i â‰« mapMono K i' = mapMono K (i' â‰« i) := by\n  -- case where i : Î”' âŸ¶ Î” is the identity\n  by_cases hâ‚ : Î” = Î”'\n  Â· subst hâ‚\n    simp only [SimplexCategory.eq_id_of_mono i, comp_id, id_comp, mapMono_id K, eqToHom_refl]\n  -- case where i' : Î”'' âŸ¶ Î”' is the identity\n  by_cases hâ‚‚ : Î”' = Î”''\n  Â· subst hâ‚‚\n    simp only [SimplexCategory.eq_id_of_mono i', comp_id, id_comp, mapMono_id K, eqToHom_refl]\n  -- then the RHS is always zero\n  obtain âŸ¨k, hkâŸ© := Nat.exists_eq_add_of_lt (len_lt_of_mono i hâ‚)\n  obtain âŸ¨k', hk'âŸ© := Nat.exists_eq_add_of_lt (len_lt_of_mono i' hâ‚‚)\n  have eq : Î”.len = Î”''.len + (k + k' + 2) := by omega\n  rw [mapMono_eq_zero K (i' â‰« i) _ _]; rotate_left\n  Â· by_contra h\n    simp only [self_eq_add_right, h, add_eq_zero, and_false, reduceCtorEq] at eq\n  Â· by_contra h\n    simp only [h.1, add_right_inj] at eq\n    omega\n  -- in all cases, the LHS is also zero, either by definition, or because d â‰« d = 0\n  by_cases hâ‚ƒ : IsÎ´â‚€ i\n  Â· by_cases hâ‚„ : IsÎ´â‚€ i'\n    Â· rw [mapMono_Î´â‚€' K i hâ‚ƒ, mapMono_Î´â‚€' K i' hâ‚„, HomologicalComplex.d_comp_d]\n    Â· simp only [mapMono_eq_zero K i' hâ‚‚ hâ‚„, comp_zero]\n  Â· simp only [mapMono_eq_zero K i hâ‚ hâ‚ƒ, zero_comp]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summandâ‚€","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninstâœÂ² : CategoryTheory.Limits.HasFiniteCoproducts C\nÎ” Î”' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Î”\nÎ¸ : Quiver.Hom Î” Î”'\nÎ”'' : SimplexCategory\ne : Quiver.Hom (Opposite.unop Î”') Î”''\ni : Quiver.Hom Î”'' (Opposite.unop A.fst)\ninstâœÂ¹ : CategoryTheory.Epi e\ninstâœ : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) (CategoryTheory.CategoryStruct.comp Î¸.unop A.e)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand K Î”) A) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.map K Î¸)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i) (CategoryTheory.Limits.Sigma.Î¹ (AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand K Î”') (SimplicialObject.Splitting.IndexSet.mk e)))","decl":"@[reassoc]\ntheorem map_on_summandâ‚€ {Î” Î”' : SimplexCategoryáµ’áµ–} (A : Splitting.IndexSet Î”) {Î¸ : Î” âŸ¶ Î”'}\n    {Î”'' : SimplexCategory} {e : Î”'.unop âŸ¶ Î”''} {i : Î”'' âŸ¶ A.1.unop} [Epi e] [Mono i]\n    (fac : e â‰« i = Î¸.unop â‰« A.e) :\n    Sigma.Î¹ (summand K Î”) A â‰« map K Î¸ =\n      Termwise.mapMono K i â‰« Sigma.Î¹ (summand K Î”') (Splitting.IndexSet.mk e) := by\n  simp only [map, colimit.Î¹_desc, Cofan.mk_Î¹_app]\n  have h := SimplexCategory.image_eq fac\n  subst h\n  congr\n  Â· exact SimplexCategory.image_Î¹_eq fac\n  Â· dsimp only [SimplicialObject.Splitting.IndexSet.pull]\n    congr\n    exact SimplexCategory.factorThruImage_eq fac\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summandâ‚€_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninstâœÂ² : CategoryTheory.Limits.HasFiniteCoproducts C\nÎ” Î”' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Î”\nÎ¸ : Quiver.Hom Î” Î”'\nÎ”'' : SimplexCategory\ne : Quiver.Hom (Opposite.unop Î”') Î”''\ni : Quiver.Hom Î”'' (Opposite.unop A.fst)\ninstâœÂ¹ : CategoryTheory.Epi e\ninstâœ : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) (CategoryTheory.CategoryStruct.comp Î¸.unop A.e)\nZ : C\nh : Quiver.Hom (AlgebraicTopology.DoldKan.Î“â‚€.Obj.objâ‚‚ K Î”') Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand K Î”) A) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.map K Î¸) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand K Î”') (SimplicialObject.Splitting.IndexSet.mk e)) h))","decl":"@[reassoc]\ntheorem map_on_summandâ‚€ {Î” Î”' : SimplexCategoryáµ’áµ–} (A : Splitting.IndexSet Î”) {Î¸ : Î” âŸ¶ Î”'}\n    {Î”'' : SimplexCategory} {e : Î”'.unop âŸ¶ Î”''} {i : Î”'' âŸ¶ A.1.unop} [Epi e] [Mono i]\n    (fac : e â‰« i = Î¸.unop â‰« A.e) :\n    Sigma.Î¹ (summand K Î”) A â‰« map K Î¸ =\n      Termwise.mapMono K i â‰« Sigma.Î¹ (summand K Î”') (Splitting.IndexSet.mk e) := by\n  simp only [map, colimit.Î¹_desc, Cofan.mk_Î¹_app]\n  have h := SimplexCategory.image_eq fac\n  subst h\n  congr\n  Â· exact SimplexCategory.image_Î¹_eq fac\n  Â· dsimp only [SimplicialObject.Splitting.IndexSet.pull]\n    congr\n    exact SimplexCategory.factorThruImage_eq fac\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summandâ‚€'_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nÎ” Î”' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Î”\nÎ¸ : Quiver.Hom Î” Î”'\nZ : C\nh : Quiver.Hom (AlgebraicTopology.DoldKan.Î“â‚€.Obj.objâ‚‚ K Î”') Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand K Î”) A) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.map K Î¸) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K (CategoryTheory.Limits.image.Î¹ (CategoryTheory.CategoryStruct.comp Î¸.unop A.e))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand K Î”') (A.pull Î¸)) h))","decl":"@[reassoc]\ntheorem map_on_summandâ‚€' {Î” Î”' : SimplexCategoryáµ’áµ–} (A : Splitting.IndexSet Î”) (Î¸ : Î” âŸ¶ Î”') :\n    Sigma.Î¹ (summand K Î”) A â‰« map K Î¸ =\n      Termwise.mapMono K (image.Î¹ (Î¸.unop â‰« A.e)) â‰« Sigma.Î¹ (summand K _) (A.pull Î¸) :=\n  map_on_summandâ‚€ K A (A.fac_pull Î¸)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summandâ‚€'","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nÎ” Î”' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Î”\nÎ¸ : Quiver.Hom Î” Î”'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand K Î”) A) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.map K Î¸)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K (CategoryTheory.Limits.image.Î¹ (CategoryTheory.CategoryStruct.comp Î¸.unop A.e))) (CategoryTheory.Limits.Sigma.Î¹ (AlgebraicTopology.DoldKan.Î“â‚€.Obj.summand K Î”') (A.pull Î¸)))","decl":"@[reassoc]\ntheorem map_on_summandâ‚€' {Î” Î”' : SimplexCategoryáµ’áµ–} (A : Splitting.IndexSet Î”) (Î¸ : Î” âŸ¶ Î”') :\n    Sigma.Î¹ (summand K Î”) A â‰« map K Î¸ =\n      Termwise.mapMono K (image.Î¹ (Î¸.unop â‰« A.e)) â‰« Sigma.Î¹ (summand K _) (A.pull Î¸) :=\n  map_on_summandâ‚€ K A (A.fac_pull Î¸)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.obj_obj","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nK : ChainComplex C Nat\nÎ” : Opposite SimplexCategory\nâŠ¢ Eq ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).obj Î”) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.objâ‚‚ K Î”)","decl":"/-- The functor `Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C`, on objects. -/\n@[simps]\ndef obj (K : ChainComplex C â„•) : SimplicialObject C where\n  obj Î” := Obj.objâ‚‚ K Î”\n  map Î¸ := Obj.map K Î¸\n  map_id Î” := colimit.hom_ext (fun âŸ¨AâŸ© => by\n    dsimp\n    have fac : A.e â‰« ğŸ™ A.1.unop = (ğŸ™ Î”).unop â‰« A.e := by rw [unop_id, comp_id, id_comp]\n    erw [Obj.map_on_summandâ‚€ K A fac, Obj.Termwise.mapMono_id, id_comp, comp_id]\n    rfl)\n  map_comp {Î”'' Î”' Î”} Î¸' Î¸ := colimit.hom_ext (fun âŸ¨AâŸ© => by\n    have fac : Î¸.unop â‰« Î¸'.unop â‰« A.e = (Î¸' â‰« Î¸).unop â‰« A.e := by rw [unop_comp, assoc]\n    rw [â† image.fac (Î¸'.unop â‰« A.e), â† assoc, â†\n      image.fac (Î¸.unop â‰« factorThruImage (Î¸'.unop â‰« A.e)), assoc] at fac\n    simp only [Obj.map_on_summandâ‚€'_assoc K A Î¸', Obj.map_on_summandâ‚€' K _ Î¸,\n      Obj.Termwise.mapMono_comp_assoc, Obj.map_on_summandâ‚€ K A fac]\n    rfl)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.obj_map","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nK : ChainComplex C Nat\nXâœ Yâœ : Opposite SimplexCategory\nÎ¸ : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).map Î¸) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.map K Î¸)","decl":"/-- The functor `Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C`, on objects. -/\n@[simps]\ndef obj (K : ChainComplex C â„•) : SimplicialObject C where\n  obj Î” := Obj.objâ‚‚ K Î”\n  map Î¸ := Obj.map K Î¸\n  map_id Î” := colimit.hom_ext (fun âŸ¨AâŸ© => by\n    dsimp\n    have fac : A.e â‰« ğŸ™ A.1.unop = (ğŸ™ Î”).unop â‰« A.e := by rw [unop_id, comp_id, id_comp]\n    erw [Obj.map_on_summandâ‚€ K A fac, Obj.Termwise.mapMono_id, id_comp, comp_id]\n    rfl)\n  map_comp {Î”'' Î”' Î”} Î¸' Î¸ := colimit.hom_ext (fun âŸ¨AâŸ© => by\n    have fac : Î¸.unop â‰« Î¸'.unop â‰« A.e = (Î¸' â‰« Î¸).unop â‰« A.e := by rw [unop_comp, assoc]\n    rw [â† image.fac (Î¸'.unop â‰« A.e), â† assoc, â†\n      image.fac (Î¸.unop â‰« factorThruImage (Î¸'.unop â‰« A.e)), assoc] at fac\n    simp only [Obj.map_on_summandâ‚€'_assoc K A Î¸', Obj.map_on_summandâ‚€' K _ Î¸,\n      Obj.Termwise.mapMono_comp_assoc, Obj.map_on_summandâ‚€ K A fac]\n    rfl)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summand","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninstâœÂ² : CategoryTheory.Limits.HasFiniteCoproducts C\nÎ” Î”' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Î”\nÎ¸ : Quiver.Hom Î” Î”'\nÎ”'' : SimplexCategory\ne : Quiver.Hom (Opposite.unop Î”') Î”''\ni : Quiver.Hom Î”'' (Opposite.unop A.fst)\ninstâœÂ¹ : CategoryTheory.Epi e\ninstâœ : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) (CategoryTheory.CategoryStruct.comp Î¸.unop A.e)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan Î”).inj A) ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).map Î¸)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i) (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan Î”').inj (SimplicialObject.Splitting.IndexSet.mk e)))","decl":"@[reassoc]\ntheorem Obj.map_on_summand {Î” Î”' : SimplexCategoryáµ’áµ–} (A : Splitting.IndexSet Î”) (Î¸ : Î” âŸ¶ Î”')\n    {Î”'' : SimplexCategory} {e : Î”'.unop âŸ¶ Î”''} {i : Î”'' âŸ¶ A.1.unop} [Epi e] [Mono i]\n    (fac : e â‰« i = Î¸.unop â‰« A.e) :\n    ((Î“â‚€.splitting K).cofan Î”).inj A â‰« (Î“â‚€.obj K).map Î¸ =\n      Î“â‚€.Obj.Termwise.mapMono K i â‰« ((Î“â‚€.splitting K).cofan Î”').inj (Splitting.IndexSet.mk e) := by\n  dsimp [Splitting.cofan]\n  change (_ â‰« (Î“â‚€.obj K).map A.e.op) â‰« (Î“â‚€.obj K).map Î¸ = _\n  rw [assoc, â† Functor.map_comp]\n  dsimp [splitting]\n  erw [Î“â‚€.Obj.map_on_summandâ‚€ K (Splitting.IndexSet.id A.1)\n    (show e â‰« i = ((Splitting.IndexSet.e A).op â‰« Î¸).unop â‰« ğŸ™ _ by rw [comp_id, fac]; rfl),\n    Î“â‚€.Obj.map_on_summandâ‚€ K (Splitting.IndexSet.id (op Î”''))\n      (show e â‰« ğŸ™ Î”'' = e.op.unop â‰« ğŸ™ _ by simp), Termwise.mapMono_id, id_comp]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summand_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninstâœÂ² : CategoryTheory.Limits.HasFiniteCoproducts C\nÎ” Î”' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Î”\nÎ¸ : Quiver.Hom Î” Î”'\nÎ”'' : SimplexCategory\ne : Quiver.Hom (Opposite.unop Î”') Î”''\ni : Quiver.Hom Î”'' (Opposite.unop A.fst)\ninstâœÂ¹ : CategoryTheory.Epi e\ninstâœ : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) (CategoryTheory.CategoryStruct.comp Î¸.unop A.e)\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).obj Î”') Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan Î”).inj A) (CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).map Î¸) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i) (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan Î”').inj (SimplicialObject.Splitting.IndexSet.mk e)) h))","decl":"@[reassoc]\ntheorem Obj.map_on_summand {Î” Î”' : SimplexCategoryáµ’áµ–} (A : Splitting.IndexSet Î”) (Î¸ : Î” âŸ¶ Î”')\n    {Î”'' : SimplexCategory} {e : Î”'.unop âŸ¶ Î”''} {i : Î”'' âŸ¶ A.1.unop} [Epi e] [Mono i]\n    (fac : e â‰« i = Î¸.unop â‰« A.e) :\n    ((Î“â‚€.splitting K).cofan Î”).inj A â‰« (Î“â‚€.obj K).map Î¸ =\n      Î“â‚€.Obj.Termwise.mapMono K i â‰« ((Î“â‚€.splitting K).cofan Î”').inj (Splitting.IndexSet.mk e) := by\n  dsimp [Splitting.cofan]\n  change (_ â‰« (Î“â‚€.obj K).map A.e.op) â‰« (Î“â‚€.obj K).map Î¸ = _\n  rw [assoc, â† Functor.map_comp]\n  dsimp [splitting]\n  erw [Î“â‚€.Obj.map_on_summandâ‚€ K (Splitting.IndexSet.id A.1)\n    (show e â‰« i = ((Splitting.IndexSet.e A).op â‰« Î¸).unop â‰« ğŸ™ _ by rw [comp_id, fac]; rfl),\n    Î“â‚€.Obj.map_on_summandâ‚€ K (Splitting.IndexSet.id (op Î”''))\n      (show e â‰« ğŸ™ Î”'' = e.op.unop â‰« ğŸ™ _ by simp), Termwise.mapMono_id, id_comp]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summand'_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nÎ” Î”' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Î”\nÎ¸ : Quiver.Hom Î” Î”'\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).obj Î”') Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan Î”).inj A) (CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).map Î¸) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K (CategoryTheory.Limits.image.Î¹ (CategoryTheory.CategoryStruct.comp Î¸.unop A.e))) (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan Î”').inj (A.pull Î¸)) h))","decl":"@[reassoc]\ntheorem Obj.map_on_summand' {Î” Î”' : SimplexCategoryáµ’áµ–} (A : Splitting.IndexSet Î”) (Î¸ : Î” âŸ¶ Î”') :\n    ((splitting K).cofan Î”).inj A â‰« (obj K).map Î¸ =\n      Obj.Termwise.mapMono K (image.Î¹ (Î¸.unop â‰« A.e)) â‰«\n        ((splitting K).cofan Î”').inj (A.pull Î¸) := by\n  apply Obj.map_on_summand\n  apply image.fac\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_on_summand'","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nÎ” Î”' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Î”\nÎ¸ : Quiver.Hom Î” Î”'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan Î”).inj A) ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).map Î¸)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K (CategoryTheory.Limits.image.Î¹ (CategoryTheory.CategoryStruct.comp Î¸.unop A.e))) (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan Î”').inj (A.pull Î¸)))","decl":"@[reassoc]\ntheorem Obj.map_on_summand' {Î” Î”' : SimplexCategoryáµ’áµ–} (A : Splitting.IndexSet Î”) (Î¸ : Î” âŸ¶ Î”') :\n    ((splitting K).cofan Î”).inj A â‰« (obj K).map Î¸ =\n      Obj.Termwise.mapMono K (image.Î¹ (Î¸.unop â‰« A.e)) â‰«\n        ((splitting K).cofan Î”').inj (A.pull Î¸) := by\n  apply Obj.map_on_summand\n  apply image.fac\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.mapMono_on_summand_id_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteCoproducts C\nÎ” Î”' : SimplexCategory\ni : Quiver.Hom Î”' Î”\ninstâœ : CategoryTheory.Mono i\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).obj { unop := Î”' }) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan { unop := Î” }).inj (SimplicialObject.Splitting.IndexSet.id { unop := Î” })) (CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).map i.op) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i) (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan { unop := Î”' }).inj (SimplicialObject.Splitting.IndexSet.id { unop := Î”' })) h))","decl":"@[reassoc]\ntheorem Obj.mapMono_on_summand_id {Î” Î”' : SimplexCategory} (i : Î”' âŸ¶ Î”) [Mono i] :\n    ((splitting K).cofan _).inj (Splitting.IndexSet.id (op Î”)) â‰« (obj K).map i.op =\n      Obj.Termwise.mapMono K i â‰« ((splitting K).cofan _).inj (Splitting.IndexSet.id (op Î”')) :=\n  Obj.map_on_summand K (Splitting.IndexSet.id (op Î”)) i.op (rfl : ğŸ™ _ â‰« i = i â‰« ğŸ™ _)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.mapMono_on_summand_id","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteCoproducts C\nÎ” Î”' : SimplexCategory\ni : Quiver.Hom Î”' Î”\ninstâœ : CategoryTheory.Mono i\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan { unop := Î” }).inj (SimplicialObject.Splitting.IndexSet.id { unop := Î” })) ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).map i.op)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Î“â‚€.Obj.Termwise.mapMono K i) (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan { unop := Î”' }).inj (SimplicialObject.Splitting.IndexSet.id { unop := Î”' })))","decl":"@[reassoc]\ntheorem Obj.mapMono_on_summand_id {Î” Î”' : SimplexCategory} (i : Î”' âŸ¶ Î”) [Mono i] :\n    ((splitting K).cofan _).inj (Splitting.IndexSet.id (op Î”)) â‰« (obj K).map i.op =\n      Obj.Termwise.mapMono K i â‰« ((splitting K).cofan _).inj (Splitting.IndexSet.id (op Î”')) :=\n  Obj.map_on_summand K (Splitting.IndexSet.id (op Î”)) i.op (rfl : ğŸ™ _ â‰« i = i â‰« ğŸ™ _)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_epi_on_summand_id_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteCoproducts C\nÎ” Î”' : SimplexCategory\ne : Quiver.Hom Î”' Î”\ninstâœ : CategoryTheory.Epi e\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).obj { unop := Î”' }) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan { unop := Î” }).inj (SimplicialObject.Splitting.IndexSet.id { unop := Î” })) (CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).map e.op) h)) (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan { unop := Î”' }).inj (SimplicialObject.Splitting.IndexSet.mk e)) h)","decl":"@[reassoc]\ntheorem Obj.map_epi_on_summand_id {Î” Î”' : SimplexCategory} (e : Î”' âŸ¶ Î”) [Epi e] :\n    ((Î“â‚€.splitting K).cofan _).inj (Splitting.IndexSet.id (op Î”)) â‰« (Î“â‚€.obj K).map e.op =\n      ((Î“â‚€.splitting K).cofan _).inj (Splitting.IndexSet.mk e) := by\n  simpa only [Î“â‚€.Obj.map_on_summand K (Splitting.IndexSet.id (op Î”)) e.op\n      (rfl : e â‰« ğŸ™ Î” = e â‰« ğŸ™ Î”),\n    Î“â‚€.Obj.Termwise.mapMono_id] using id_comp _\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.Obj.map_epi_on_summand_id","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteCoproducts C\nÎ” Î”' : SimplexCategory\ne : Quiver.Hom Î”' Î”\ninstâœ : CategoryTheory.Epi e\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan { unop := Î” }).inj (SimplicialObject.Splitting.IndexSet.id { unop := Î” })) ((AlgebraicTopology.DoldKan.Î“â‚€.obj K).map e.op)) (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan { unop := Î”' }).inj (SimplicialObject.Splitting.IndexSet.mk e))","decl":"@[reassoc]\ntheorem Obj.map_epi_on_summand_id {Î” Î”' : SimplexCategory} (e : Î”' âŸ¶ Î”) [Epi e] :\n    ((Î“â‚€.splitting K).cofan _).inj (Splitting.IndexSet.id (op Î”)) â‰« (Î“â‚€.obj K).map e.op =\n      ((Î“â‚€.splitting K).cofan _).inj (Splitting.IndexSet.mk e) := by\n  simpa only [Î“â‚€.Obj.map_on_summand K (Splitting.IndexSet.id (op Î”)) e.op\n      (rfl : e â‰« ğŸ™ Î” = e â‰« ğŸ™ Î”),\n    Î“â‚€.Obj.Termwise.mapMono_id] using id_comp _\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€.map_app","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nK K' : ChainComplex C Nat\nf : Quiver.Hom K K'\nÎ” : Opposite SimplexCategory\nâŠ¢ Eq ((AlgebraicTopology.DoldKan.Î“â‚€.map f).app Î”) ((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).desc Î” fun A => CategoryTheory.CategoryStruct.comp (f.f (Opposite.unop A.fst).len) (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K').cofan Î”).inj A))","decl":"/-- The functor `Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C`, on morphisms. -/\n@[simps]\ndef map {K K' : ChainComplex C â„•} (f : K âŸ¶ K') : obj K âŸ¶ obj K' where\n  app Î” := (Î“â‚€.splitting K).desc Î” fun A => f.f A.1.unop.len â‰«\n    ((Î“â‚€.splitting K').cofan _).inj A\n  naturality {Î”' Î”} Î¸ := by\n    apply (Î“â‚€.splitting K).hom_ext'\n    intro A\n    simp only [(splitting K).Î¹_desc_assoc, Obj.map_on_summand'_assoc K _ Î¸, (splitting K).Î¹_desc,\n      assoc, Obj.map_on_summand' K' _ Î¸]\n    apply Obj.Termwise.mapMono_naturality_assoc\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€'_obj","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nK : ChainComplex C Nat\nâŠ¢ Eq (AlgebraicTopology.DoldKan.Î“â‚€'.obj K) (SimplicialObject.Split.mk' (AlgebraicTopology.DoldKan.Î“â‚€.splitting K))","decl":"/-- The functor `Î“â‚€' : ChainComplex C â„• â¥¤ SimplicialObject.Split C`\nthat induces `Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C`, which\nshall be the inverse functor of the Dold-Kan equivalence for\nabelian or pseudo-abelian categories. -/\n@[simps]\ndef Î“â‚€' : ChainComplex C â„• â¥¤ SimplicialObject.Split C where\n  obj K := SimplicialObject.Split.mk' (Î“â‚€.splitting K)\n  map {K K'} f :=\n    { F := Î“â‚€.map f\n      f := f.f\n      comm := fun n => by\n        dsimp\n        simp only [â† Splitting.cofan_inj_id, (Î“â‚€.splitting K).Î¹_desc]\n        rfl }\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€'_map_F","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nK K' : ChainComplex C Nat\nf : Quiver.Hom K K'\nâŠ¢ Eq (AlgebraicTopology.DoldKan.Î“â‚€'.map f).F (AlgebraicTopology.DoldKan.Î“â‚€.map f)","decl":"/-- The functor `Î“â‚€' : ChainComplex C â„• â¥¤ SimplicialObject.Split C`\nthat induces `Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C`, which\nshall be the inverse functor of the Dold-Kan equivalence for\nabelian or pseudo-abelian categories. -/\n@[simps]\ndef Î“â‚€' : ChainComplex C â„• â¥¤ SimplicialObject.Split C where\n  obj K := SimplicialObject.Split.mk' (Î“â‚€.splitting K)\n  map {K K'} f :=\n    { F := Î“â‚€.map f\n      f := f.f\n      comm := fun n => by\n        dsimp\n        simp only [â† Splitting.cofan_inj_id, (Î“â‚€.splitting K).Î¹_desc]\n        rfl }\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€'_map_f","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nK K' : ChainComplex C Nat\nf : Quiver.Hom K K'\ni : Nat\nâŠ¢ Eq ((AlgebraicTopology.DoldKan.Î“â‚€'.map f).f i) (f.f i)","decl":"/-- The functor `Î“â‚€' : ChainComplex C â„• â¥¤ SimplicialObject.Split C`\nthat induces `Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C`, which\nshall be the inverse functor of the Dold-Kan equivalence for\nabelian or pseudo-abelian categories. -/\n@[simps]\ndef Î“â‚€' : ChainComplex C â„• â¥¤ SimplicialObject.Split C where\n  obj K := SimplicialObject.Split.mk' (Î“â‚€.splitting K)\n  map {K K'} f :=\n    { F := Î“â‚€.map f\n      f := f.f\n      comm := fun n => by\n        dsimp\n        simp only [â† Splitting.cofan_inj_id, (Î“â‚€.splitting K).Î¹_desc]\n        rfl }\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€_obj_obj","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nX : ChainComplex C Nat\nÎ” : Opposite SimplexCategory\nâŠ¢ Eq ((AlgebraicTopology.DoldKan.Î“â‚€.obj X).obj Î”) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.objâ‚‚ X Î”)","decl":"/-- The functor `Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C`, which is\nthe inverse functor of the Dold-Kan equivalence when `C` is an abelian\ncategory, or more generally a pseudoabelian category. -/\n@[simps!]\ndef Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C :=\n  Î“â‚€' â‹™ Split.forget _\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€_obj_map","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nX : ChainComplex C Nat\nXâœ Yâœ : Opposite SimplexCategory\nÎ¸ : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((AlgebraicTopology.DoldKan.Î“â‚€.obj X).map Î¸) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.map X Î¸)","decl":"/-- The functor `Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C`, which is\nthe inverse functor of the Dold-Kan equivalence when `C` is an abelian\ncategory, or more generally a pseudoabelian category. -/\n@[simps!]\ndef Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C :=\n  Î“â‚€' â‹™ Split.forget _\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚€_map_app","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nXâœ Yâœ : ChainComplex C Nat\nf : Quiver.Hom Xâœ Yâœ\nÎ” : Opposite SimplexCategory\nâŠ¢ Eq ((AlgebraicTopology.DoldKan.Î“â‚€.map f).app Î”) ((AlgebraicTopology.DoldKan.Î“â‚€.splitting Xâœ).desc Î” fun A => CategoryTheory.CategoryStruct.comp (f.f (Opposite.unop A.fst).len) (((AlgebraicTopology.DoldKan.Î“â‚€.splitting Yâœ).cofan Î”).inj A))","decl":"/-- The functor `Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C`, which is\nthe inverse functor of the Dold-Kan equivalence when `C` is an abelian\ncategory, or more generally a pseudoabelian category. -/\n@[simps!]\ndef Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C :=\n  Î“â‚€' â‹™ Split.forget _\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚‚_obj_X_obj","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nP : CategoryTheory.Idempotents.Karoubi (ChainComplex C Nat)\nÎ” : Opposite SimplexCategory\nâŠ¢ Eq ((AlgebraicTopology.DoldKan.Î“â‚‚.obj P).X.obj Î”) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.objâ‚‚ P.X Î”)","decl":"/-- The extension of `Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C`\non the idempotent completions. It shall be an equivalence of categories\nfor any additive category `C`. -/\n@[simps!]\ndef Î“â‚‚ : Karoubi (ChainComplex C â„•) â¥¤ Karoubi (SimplicialObject C) :=\n  (CategoryTheory.Idempotents.functorExtensionâ‚‚ _ _).obj Î“â‚€\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚‚_map_f_app","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nXâœ Yâœ : CategoryTheory.Idempotents.Karoubi (ChainComplex C Nat)\nf : Quiver.Hom Xâœ Yâœ\nÎ” : Opposite SimplexCategory\nâŠ¢ Eq ((AlgebraicTopology.DoldKan.Î“â‚‚.map f).f.app Î”) ((AlgebraicTopology.DoldKan.Î“â‚€.splitting Xâœ.X).desc Î” fun A => CategoryTheory.CategoryStruct.comp (f.f.f (Opposite.unop A.fst).len) (((AlgebraicTopology.DoldKan.Î“â‚€.splitting Yâœ.X).cofan Î”).inj A))","decl":"/-- The extension of `Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C`\non the idempotent completions. It shall be an equivalence of categories\nfor any additive category `C`. -/\n@[simps!]\ndef Î“â‚‚ : Karoubi (ChainComplex C â„•) â¥¤ Karoubi (SimplicialObject C) :=\n  (CategoryTheory.Idempotents.functorExtensionâ‚‚ _ _).obj Î“â‚€\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚‚_obj_p_app","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nP : CategoryTheory.Idempotents.Karoubi (ChainComplex C Nat)\nÎ” : Opposite SimplexCategory\nâŠ¢ Eq ((AlgebraicTopology.DoldKan.Î“â‚‚.obj P).p.app Î”) ((AlgebraicTopology.DoldKan.Î“â‚€.splitting P.X).desc Î” fun A => CategoryTheory.CategoryStruct.comp (P.p.f (Opposite.unop A.fst).len) (((AlgebraicTopology.DoldKan.Î“â‚€.splitting P.X).cofan Î”).inj A))","decl":"/-- The extension of `Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C`\non the idempotent completions. It shall be an equivalence of categories\nfor any additive category `C`. -/\n@[simps!]\ndef Î“â‚‚ : Karoubi (ChainComplex C â„•) â¥¤ Karoubi (SimplicialObject C) :=\n  (CategoryTheory.Idempotents.functorExtensionâ‚‚ _ _).obj Î“â‚€\n\n"}
{"name":"AlgebraicTopology.DoldKan.Î“â‚‚_obj_X_map","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nP : CategoryTheory.Idempotents.Karoubi (ChainComplex C Nat)\nXâœ Yâœ : Opposite SimplexCategory\nÎ¸ : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((AlgebraicTopology.DoldKan.Î“â‚‚.obj P).X.map Î¸) (AlgebraicTopology.DoldKan.Î“â‚€.Obj.map P.X Î¸)","decl":"/-- The extension of `Î“â‚€ : ChainComplex C â„• â¥¤ SimplicialObject C`\non the idempotent completions. It shall be an equivalence of categories\nfor any additive category `C`. -/\n@[simps!]\ndef Î“â‚‚ : Karoubi (ChainComplex C â„•) â¥¤ Karoubi (SimplicialObject C) :=\n  (CategoryTheory.Idempotents.functorExtensionâ‚‚ _ _).obj Î“â‚€\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.on_Î“â‚€_summand_id","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nK : ChainComplex C Nat\nn : Nat\nâŠ¢ AlgebraicTopology.DoldKan.HigherFacesVanish (HAdd.hAdd n 1) (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan { unop := SimplexCategory.mk (HAdd.hAdd n 1) }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk (HAdd.hAdd n 1) }))","decl":"theorem HigherFacesVanish.on_Î“â‚€_summand_id (K : ChainComplex C â„•) (n : â„•) :\n    @HigherFacesVanish C _ _ (Î“â‚€.obj K) _ n (n + 1)\n      (((Î“â‚€.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n + 1]))) := by\n  intro j _\n  have eq := Î“â‚€.Obj.mapMono_on_summand_id K (SimplexCategory.Î´ j.succ)\n  rw [Î“â‚€.Obj.Termwise.mapMono_eq_zero K, zero_comp] at eq; rotate_left\n  Â· intro h\n    exact (Nat.succ_ne_self n) (congr_arg SimplexCategory.len h)\n  Â· exact fun h => Fin.succ_ne_zero j (by simpa only [IsÎ´â‚€.iff] using h)\n  exact eq\n\n"}
{"name":"AlgebraicTopology.DoldKan.PInfty_on_Î“â‚€_splitting_summand_eq_self_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nK : ChainComplex C Nat\nn : Nat\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.AlternatingFaceMapComplex.obj (AlgebraicTopology.DoldKan.Î“â‚€.obj K)).X n) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f n) h)) (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) h)","decl":"@[reassoc (attr := simp)]\ntheorem PInfty_on_Î“â‚€_splitting_summand_eq_self (K : ChainComplex C â„•) {n : â„•} :\n    ((Î“â‚€.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n])) â‰«\n      (PInfty : K[Î“â‚€.obj K] âŸ¶ _).f n =\n      ((Î“â‚€.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n])) := by\n  rw [PInfty_f]\n  rcases n with _|n\n  Â· simpa only [P_f_0_eq] using comp_id _\n  Â· exact (HigherFacesVanish.on_Î“â‚€_summand_id K n).comp_P_eq_self\n\n"}
{"name":"AlgebraicTopology.DoldKan.PInfty_on_Î“â‚€_splitting_summand_eq_self","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.Limits.HasFiniteCoproducts C\nK : ChainComplex C Nat\nn : Nat\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) (AlgebraicTopology.DoldKan.PInfty.f n)) (((AlgebraicTopology.DoldKan.Î“â‚€.splitting K).cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n }))","decl":"@[reassoc (attr := simp)]\ntheorem PInfty_on_Î“â‚€_splitting_summand_eq_self (K : ChainComplex C â„•) {n : â„•} :\n    ((Î“â‚€.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n])) â‰«\n      (PInfty : K[Î“â‚€.obj K] âŸ¶ _).f n =\n      ((Î“â‚€.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n])) := by\n  rw [PInfty_f]\n  rcases n with _|n\n  Â· simpa only [P_f_0_eq] using comp_id _\n  Â· exact (HigherFacesVanish.on_Î“â‚€_summand_id K n).comp_P_eq_self\n\n"}
