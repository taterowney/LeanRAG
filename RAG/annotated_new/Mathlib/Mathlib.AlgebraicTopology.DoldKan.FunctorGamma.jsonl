{"name":"AlgebraicTopology.DoldKan.Isδ₀.iff","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"j : Nat\ni : Fin (HAdd.hAdd j 2)\n⊢ Iff (AlgebraicTopology.DoldKan.Isδ₀ (SimplexCategory.δ i)) (Eq i 0)","decl":"theorem iff {j : ℕ} {i : Fin (j + 2)} : Isδ₀ (SimplexCategory.δ i) ↔ i = 0 := by\n  constructor\n  · rintro ⟨_, h₂⟩\n    by_contra h\n    exact h₂ (Fin.succAbove_ne_zero_zero h)\n  · rintro rfl\n    exact ⟨rfl, by dsimp; exact Fin.succ_ne_zero (0 : Fin (j + 1))⟩\n\n"}
{"name":"AlgebraicTopology.DoldKan.Isδ₀.eq_δ₀","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"n : Nat\ni : Quiver.Hom (SimplexCategory.mk n) (SimplexCategory.mk (HAdd.hAdd n 1))\ninst✝ : CategoryTheory.Mono i\nhi : AlgebraicTopology.DoldKan.Isδ₀ i\n⊢ Eq i (SimplexCategory.δ 0)","decl":"theorem eq_δ₀ {n : ℕ} {i : ([n] : SimplexCategory) ⟶ [n + 1]} [Mono i] (hi : Isδ₀ i) :\n    i = SimplexCategory.δ 0 := by\n  obtain ⟨j, rfl⟩ := SimplexCategory.eq_δ_of_mono i\n  rw [iff] at hi\n  rw [hi]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono_id","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\nΔ : SimplexCategory\n⊢ Eq (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K (CategoryTheory.CategoryStruct.id Δ)) (CategoryTheory.CategoryStruct.id (K.X Δ.len))","decl":"theorem mapMono_id : mapMono K (𝟙 Δ) = 𝟙 _ := by\n  unfold mapMono\n  simp only [eq_self_iff_true, eqToHom_refl, dite_eq_ite, if_true]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono_δ₀'","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\nΔ Δ' : SimplexCategory\ni : Quiver.Hom Δ' Δ\ninst✝ : CategoryTheory.Mono i\nhi : AlgebraicTopology.DoldKan.Isδ₀ i\n⊢ Eq (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i) (K.d Δ.len Δ'.len)","decl":"theorem mapMono_δ₀' (i : Δ' ⟶ Δ) [Mono i] (hi : Isδ₀ i) : mapMono K i = K.d Δ.len Δ'.len := by\n  unfold mapMono\n  suffices Δ ≠ Δ' by\n    simp only [dif_neg this, dif_pos hi]\n  rintro rfl\n  simpa only [self_eq_add_right, Nat.one_ne_zero] using hi.1\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono_δ₀","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\nn : Nat\n⊢ Eq (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K (SimplexCategory.δ 0)) (K.d (HAdd.hAdd n 1) n)","decl":"@[simp]\ntheorem mapMono_δ₀ {n : ℕ} : mapMono K (δ (0 : Fin (n + 2))) = K.d (n + 1) n :=\n  mapMono_δ₀' K _ (by rw [Isδ₀.iff])\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\nΔ Δ' : SimplexCategory\ni : Quiver.Hom Δ' Δ\ninst✝ : CategoryTheory.Mono i\nh₁ : Ne Δ Δ'\nh₂ : Not (AlgebraicTopology.DoldKan.Isδ₀ i)\n⊢ Eq (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i) 0","decl":"theorem mapMono_eq_zero (i : Δ' ⟶ Δ) [Mono i] (h₁ : Δ ≠ Δ') (h₂ : ¬Isδ₀ i) : mapMono K i = 0 := by\n  unfold mapMono\n  rw [Ne] at h₁\n  split_ifs\n  rfl\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono_naturality_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK K' : ChainComplex C Nat\nf : Quiver.Hom K K'\nΔ Δ' : SimplexCategory\ni : Quiver.Hom Δ Δ'\ninst✝ : CategoryTheory.Mono i\nZ : C\nh : Quiver.Hom (K'.X Δ.len) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i) (CategoryTheory.CategoryStruct.comp (f.f Δ.len) h)) (CategoryTheory.CategoryStruct.comp (f.f Δ'.len) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K' i) h))","decl":"@[reassoc (attr := simp)]\ntheorem mapMono_naturality (i : Δ ⟶ Δ') [Mono i] :\n    mapMono K i ≫ f.f Δ.len = f.f Δ'.len ≫ mapMono K' i := by\n  unfold mapMono\n  split_ifs with h\n  · subst h\n    simp only [id_comp, eqToHom_refl, comp_id]\n  · rw [HomologicalComplex.Hom.comm]\n  · rw [zero_comp, comp_zero]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono_naturality","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK K' : ChainComplex C Nat\nf : Quiver.Hom K K'\nΔ Δ' : SimplexCategory\ni : Quiver.Hom Δ Δ'\ninst✝ : CategoryTheory.Mono i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i) (f.f Δ.len)) (CategoryTheory.CategoryStruct.comp (f.f Δ'.len) (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K' i))","decl":"@[reassoc (attr := simp)]\ntheorem mapMono_naturality (i : Δ ⟶ Δ') [Mono i] :\n    mapMono K i ≫ f.f Δ.len = f.f Δ'.len ≫ mapMono K' i := by\n  unfold mapMono\n  split_ifs with h\n  · subst h\n    simp only [id_comp, eqToHom_refl, comp_id]\n  · rw [HomologicalComplex.Hom.comm]\n  · rw [zero_comp, comp_zero]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono_comp_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\nΔ Δ' Δ'' : SimplexCategory\ni' : Quiver.Hom Δ'' Δ'\ni : Quiver.Hom Δ' Δ\ninst✝¹ : CategoryTheory.Mono i'\ninst✝ : CategoryTheory.Mono i\nZ : C\nh : Quiver.Hom (K.X Δ''.len) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i') h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K (CategoryTheory.CategoryStruct.comp i' i)) h)","decl":"@[reassoc (attr := simp)]\ntheorem mapMono_comp (i' : Δ'' ⟶ Δ') (i : Δ' ⟶ Δ) [Mono i'] [Mono i] :\n    mapMono K i ≫ mapMono K i' = mapMono K (i' ≫ i) := by\n  -- case where i : Δ' ⟶ Δ is the identity\n  by_cases h₁ : Δ = Δ'\n  · subst h₁\n    simp only [SimplexCategory.eq_id_of_mono i, comp_id, id_comp, mapMono_id K, eqToHom_refl]\n  -- case where i' : Δ'' ⟶ Δ' is the identity\n  by_cases h₂ : Δ' = Δ''\n  · subst h₂\n    simp only [SimplexCategory.eq_id_of_mono i', comp_id, id_comp, mapMono_id K, eqToHom_refl]\n  -- then the RHS is always zero\n  obtain ⟨k, hk⟩ := Nat.exists_eq_add_of_lt (len_lt_of_mono i h₁)\n  obtain ⟨k', hk'⟩ := Nat.exists_eq_add_of_lt (len_lt_of_mono i' h₂)\n  have eq : Δ.len = Δ''.len + (k + k' + 2) := by omega\n  rw [mapMono_eq_zero K (i' ≫ i) _ _]; rotate_left\n  · by_contra h\n    simp only [self_eq_add_right, h, add_eq_zero, and_false, reduceCtorEq] at eq\n  · by_contra h\n    simp only [h.1, add_right_inj] at eq\n    omega\n  -- in all cases, the LHS is also zero, either by definition, or because d ≫ d = 0\n  by_cases h₃ : Isδ₀ i\n  · by_cases h₄ : Isδ₀ i'\n    · rw [mapMono_δ₀' K i h₃, mapMono_δ₀' K i' h₄, HomologicalComplex.d_comp_d]\n    · simp only [mapMono_eq_zero K i' h₂ h₄, comp_zero]\n  · simp only [mapMono_eq_zero K i h₁ h₃, zero_comp]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono_comp","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\nΔ Δ' Δ'' : SimplexCategory\ni' : Quiver.Hom Δ'' Δ'\ni : Quiver.Hom Δ' Δ\ninst✝¹ : CategoryTheory.Mono i'\ninst✝ : CategoryTheory.Mono i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i) (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i')) (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K (CategoryTheory.CategoryStruct.comp i' i))","decl":"@[reassoc (attr := simp)]\ntheorem mapMono_comp (i' : Δ'' ⟶ Δ') (i : Δ' ⟶ Δ) [Mono i'] [Mono i] :\n    mapMono K i ≫ mapMono K i' = mapMono K (i' ≫ i) := by\n  -- case where i : Δ' ⟶ Δ is the identity\n  by_cases h₁ : Δ = Δ'\n  · subst h₁\n    simp only [SimplexCategory.eq_id_of_mono i, comp_id, id_comp, mapMono_id K, eqToHom_refl]\n  -- case where i' : Δ'' ⟶ Δ' is the identity\n  by_cases h₂ : Δ' = Δ''\n  · subst h₂\n    simp only [SimplexCategory.eq_id_of_mono i', comp_id, id_comp, mapMono_id K, eqToHom_refl]\n  -- then the RHS is always zero\n  obtain ⟨k, hk⟩ := Nat.exists_eq_add_of_lt (len_lt_of_mono i h₁)\n  obtain ⟨k', hk'⟩ := Nat.exists_eq_add_of_lt (len_lt_of_mono i' h₂)\n  have eq : Δ.len = Δ''.len + (k + k' + 2) := by omega\n  rw [mapMono_eq_zero K (i' ≫ i) _ _]; rotate_left\n  · by_contra h\n    simp only [self_eq_add_right, h, add_eq_zero, and_false, reduceCtorEq] at eq\n  · by_contra h\n    simp only [h.1, add_right_inj] at eq\n    omega\n  -- in all cases, the LHS is also zero, either by definition, or because d ≫ d = 0\n  by_cases h₃ : Isδ₀ i\n  · by_cases h₄ : Isδ₀ i'\n    · rw [mapMono_δ₀' K i h₃, mapMono_δ₀' K i' h₄, HomologicalComplex.d_comp_d]\n    · simp only [mapMono_eq_zero K i' h₂ h₄, comp_zero]\n  · simp only [mapMono_eq_zero K i h₁ h₃, zero_comp]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.map_on_summand₀","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninst✝² : CategoryTheory.Limits.HasFiniteCoproducts C\nΔ Δ' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nθ : Quiver.Hom Δ Δ'\nΔ'' : SimplexCategory\ne : Quiver.Hom (Opposite.unop Δ') Δ''\ni : Quiver.Hom Δ'' (Opposite.unop A.fst)\ninst✝¹ : CategoryTheory.Epi e\ninst✝ : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) (CategoryTheory.CategoryStruct.comp θ.unop A.e)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (AlgebraicTopology.DoldKan.Γ₀.Obj.summand K Δ) A) (AlgebraicTopology.DoldKan.Γ₀.Obj.map K θ)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i) (CategoryTheory.Limits.Sigma.ι (AlgebraicTopology.DoldKan.Γ₀.Obj.summand K Δ') (SimplicialObject.Splitting.IndexSet.mk e)))","decl":"@[reassoc]\ntheorem map_on_summand₀ {Δ Δ' : SimplexCategoryᵒᵖ} (A : Splitting.IndexSet Δ) {θ : Δ ⟶ Δ'}\n    {Δ'' : SimplexCategory} {e : Δ'.unop ⟶ Δ''} {i : Δ'' ⟶ A.1.unop} [Epi e] [Mono i]\n    (fac : e ≫ i = θ.unop ≫ A.e) :\n    Sigma.ι (summand K Δ) A ≫ map K θ =\n      Termwise.mapMono K i ≫ Sigma.ι (summand K Δ') (Splitting.IndexSet.mk e) := by\n  simp only [map, colimit.ι_desc, Cofan.mk_ι_app]\n  have h := SimplexCategory.image_eq fac\n  subst h\n  congr\n  · exact SimplexCategory.image_ι_eq fac\n  · dsimp only [SimplicialObject.Splitting.IndexSet.pull]\n    congr\n    exact SimplexCategory.factorThruImage_eq fac\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.map_on_summand₀_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninst✝² : CategoryTheory.Limits.HasFiniteCoproducts C\nΔ Δ' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nθ : Quiver.Hom Δ Δ'\nΔ'' : SimplexCategory\ne : Quiver.Hom (Opposite.unop Δ') Δ''\ni : Quiver.Hom Δ'' (Opposite.unop A.fst)\ninst✝¹ : CategoryTheory.Epi e\ninst✝ : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) (CategoryTheory.CategoryStruct.comp θ.unop A.e)\nZ : C\nh : Quiver.Hom (AlgebraicTopology.DoldKan.Γ₀.Obj.obj₂ K Δ') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (AlgebraicTopology.DoldKan.Γ₀.Obj.summand K Δ) A) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.map K θ) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (AlgebraicTopology.DoldKan.Γ₀.Obj.summand K Δ') (SimplicialObject.Splitting.IndexSet.mk e)) h))","decl":"@[reassoc]\ntheorem map_on_summand₀ {Δ Δ' : SimplexCategoryᵒᵖ} (A : Splitting.IndexSet Δ) {θ : Δ ⟶ Δ'}\n    {Δ'' : SimplexCategory} {e : Δ'.unop ⟶ Δ''} {i : Δ'' ⟶ A.1.unop} [Epi e] [Mono i]\n    (fac : e ≫ i = θ.unop ≫ A.e) :\n    Sigma.ι (summand K Δ) A ≫ map K θ =\n      Termwise.mapMono K i ≫ Sigma.ι (summand K Δ') (Splitting.IndexSet.mk e) := by\n  simp only [map, colimit.ι_desc, Cofan.mk_ι_app]\n  have h := SimplexCategory.image_eq fac\n  subst h\n  congr\n  · exact SimplexCategory.image_ι_eq fac\n  · dsimp only [SimplicialObject.Splitting.IndexSet.pull]\n    congr\n    exact SimplexCategory.factorThruImage_eq fac\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.map_on_summand₀'_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nΔ Δ' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nθ : Quiver.Hom Δ Δ'\nZ : C\nh : Quiver.Hom (AlgebraicTopology.DoldKan.Γ₀.Obj.obj₂ K Δ') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (AlgebraicTopology.DoldKan.Γ₀.Obj.summand K Δ) A) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.map K θ) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K (CategoryTheory.Limits.image.ι (CategoryTheory.CategoryStruct.comp θ.unop A.e))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (AlgebraicTopology.DoldKan.Γ₀.Obj.summand K Δ') (A.pull θ)) h))","decl":"@[reassoc]\ntheorem map_on_summand₀' {Δ Δ' : SimplexCategoryᵒᵖ} (A : Splitting.IndexSet Δ) (θ : Δ ⟶ Δ') :\n    Sigma.ι (summand K Δ) A ≫ map K θ =\n      Termwise.mapMono K (image.ι (θ.unop ≫ A.e)) ≫ Sigma.ι (summand K _) (A.pull θ) :=\n  map_on_summand₀ K A (A.fac_pull θ)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.map_on_summand₀'","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nΔ Δ' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nθ : Quiver.Hom Δ Δ'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (AlgebraicTopology.DoldKan.Γ₀.Obj.summand K Δ) A) (AlgebraicTopology.DoldKan.Γ₀.Obj.map K θ)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K (CategoryTheory.Limits.image.ι (CategoryTheory.CategoryStruct.comp θ.unop A.e))) (CategoryTheory.Limits.Sigma.ι (AlgebraicTopology.DoldKan.Γ₀.Obj.summand K Δ') (A.pull θ)))","decl":"@[reassoc]\ntheorem map_on_summand₀' {Δ Δ' : SimplexCategoryᵒᵖ} (A : Splitting.IndexSet Δ) (θ : Δ ⟶ Δ') :\n    Sigma.ι (summand K Δ) A ≫ map K θ =\n      Termwise.mapMono K (image.ι (θ.unop ≫ A.e)) ≫ Sigma.ι (summand K _) (A.pull θ) :=\n  map_on_summand₀ K A (A.fac_pull θ)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.obj_obj","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nK : ChainComplex C Nat\nΔ : Opposite SimplexCategory\n⊢ Eq ((AlgebraicTopology.DoldKan.Γ₀.obj K).obj Δ) (AlgebraicTopology.DoldKan.Γ₀.Obj.obj₂ K Δ)","decl":"/-- The functor `Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C`, on objects. -/\n@[simps]\ndef obj (K : ChainComplex C ℕ) : SimplicialObject C where\n  obj Δ := Obj.obj₂ K Δ\n  map θ := Obj.map K θ\n  map_id Δ := colimit.hom_ext (fun ⟨A⟩ => by\n    dsimp\n    have fac : A.e ≫ 𝟙 A.1.unop = (𝟙 Δ).unop ≫ A.e := by rw [unop_id, comp_id, id_comp]\n    erw [Obj.map_on_summand₀ K A fac, Obj.Termwise.mapMono_id, id_comp, comp_id]\n    rfl)\n  map_comp {Δ'' Δ' Δ} θ' θ := colimit.hom_ext (fun ⟨A⟩ => by\n    have fac : θ.unop ≫ θ'.unop ≫ A.e = (θ' ≫ θ).unop ≫ A.e := by rw [unop_comp, assoc]\n    rw [← image.fac (θ'.unop ≫ A.e), ← assoc, ←\n      image.fac (θ.unop ≫ factorThruImage (θ'.unop ≫ A.e)), assoc] at fac\n    simp only [Obj.map_on_summand₀'_assoc K A θ', Obj.map_on_summand₀' K _ θ,\n      Obj.Termwise.mapMono_comp_assoc, Obj.map_on_summand₀ K A fac]\n    rfl)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.obj_map","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nK : ChainComplex C Nat\nX✝ Y✝ : Opposite SimplexCategory\nθ : Quiver.Hom X✝ Y✝\n⊢ Eq ((AlgebraicTopology.DoldKan.Γ₀.obj K).map θ) (AlgebraicTopology.DoldKan.Γ₀.Obj.map K θ)","decl":"/-- The functor `Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C`, on objects. -/\n@[simps]\ndef obj (K : ChainComplex C ℕ) : SimplicialObject C where\n  obj Δ := Obj.obj₂ K Δ\n  map θ := Obj.map K θ\n  map_id Δ := colimit.hom_ext (fun ⟨A⟩ => by\n    dsimp\n    have fac : A.e ≫ 𝟙 A.1.unop = (𝟙 Δ).unop ≫ A.e := by rw [unop_id, comp_id, id_comp]\n    erw [Obj.map_on_summand₀ K A fac, Obj.Termwise.mapMono_id, id_comp, comp_id]\n    rfl)\n  map_comp {Δ'' Δ' Δ} θ' θ := colimit.hom_ext (fun ⟨A⟩ => by\n    have fac : θ.unop ≫ θ'.unop ≫ A.e = (θ' ≫ θ).unop ≫ A.e := by rw [unop_comp, assoc]\n    rw [← image.fac (θ'.unop ≫ A.e), ← assoc, ←\n      image.fac (θ.unop ≫ factorThruImage (θ'.unop ≫ A.e)), assoc] at fac\n    simp only [Obj.map_on_summand₀'_assoc K A θ', Obj.map_on_summand₀' K _ θ,\n      Obj.Termwise.mapMono_comp_assoc, Obj.map_on_summand₀ K A fac]\n    rfl)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.map_on_summand","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninst✝² : CategoryTheory.Limits.HasFiniteCoproducts C\nΔ Δ' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nθ : Quiver.Hom Δ Δ'\nΔ'' : SimplexCategory\ne : Quiver.Hom (Opposite.unop Δ') Δ''\ni : Quiver.Hom Δ'' (Opposite.unop A.fst)\ninst✝¹ : CategoryTheory.Epi e\ninst✝ : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) (CategoryTheory.CategoryStruct.comp θ.unop A.e)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan Δ).inj A) ((AlgebraicTopology.DoldKan.Γ₀.obj K).map θ)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i) (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan Δ').inj (SimplicialObject.Splitting.IndexSet.mk e)))","decl":"@[reassoc]\ntheorem Obj.map_on_summand {Δ Δ' : SimplexCategoryᵒᵖ} (A : Splitting.IndexSet Δ) (θ : Δ ⟶ Δ')\n    {Δ'' : SimplexCategory} {e : Δ'.unop ⟶ Δ''} {i : Δ'' ⟶ A.1.unop} [Epi e] [Mono i]\n    (fac : e ≫ i = θ.unop ≫ A.e) :\n    ((Γ₀.splitting K).cofan Δ).inj A ≫ (Γ₀.obj K).map θ =\n      Γ₀.Obj.Termwise.mapMono K i ≫ ((Γ₀.splitting K).cofan Δ').inj (Splitting.IndexSet.mk e) := by\n  dsimp [Splitting.cofan]\n  change (_ ≫ (Γ₀.obj K).map A.e.op) ≫ (Γ₀.obj K).map θ = _\n  rw [assoc, ← Functor.map_comp]\n  dsimp [splitting]\n  erw [Γ₀.Obj.map_on_summand₀ K (Splitting.IndexSet.id A.1)\n    (show e ≫ i = ((Splitting.IndexSet.e A).op ≫ θ).unop ≫ 𝟙 _ by rw [comp_id, fac]; rfl),\n    Γ₀.Obj.map_on_summand₀ K (Splitting.IndexSet.id (op Δ''))\n      (show e ≫ 𝟙 Δ'' = e.op.unop ≫ 𝟙 _ by simp), Termwise.mapMono_id, id_comp]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.map_on_summand_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninst✝² : CategoryTheory.Limits.HasFiniteCoproducts C\nΔ Δ' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nθ : Quiver.Hom Δ Δ'\nΔ'' : SimplexCategory\ne : Quiver.Hom (Opposite.unop Δ') Δ''\ni : Quiver.Hom Δ'' (Opposite.unop A.fst)\ninst✝¹ : CategoryTheory.Epi e\ninst✝ : CategoryTheory.Mono i\nfac : Eq (CategoryTheory.CategoryStruct.comp e i) (CategoryTheory.CategoryStruct.comp θ.unop A.e)\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.DoldKan.Γ₀.obj K).obj Δ') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan Δ).inj A) (CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.DoldKan.Γ₀.obj K).map θ) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i) (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan Δ').inj (SimplicialObject.Splitting.IndexSet.mk e)) h))","decl":"@[reassoc]\ntheorem Obj.map_on_summand {Δ Δ' : SimplexCategoryᵒᵖ} (A : Splitting.IndexSet Δ) (θ : Δ ⟶ Δ')\n    {Δ'' : SimplexCategory} {e : Δ'.unop ⟶ Δ''} {i : Δ'' ⟶ A.1.unop} [Epi e] [Mono i]\n    (fac : e ≫ i = θ.unop ≫ A.e) :\n    ((Γ₀.splitting K).cofan Δ).inj A ≫ (Γ₀.obj K).map θ =\n      Γ₀.Obj.Termwise.mapMono K i ≫ ((Γ₀.splitting K).cofan Δ').inj (Splitting.IndexSet.mk e) := by\n  dsimp [Splitting.cofan]\n  change (_ ≫ (Γ₀.obj K).map A.e.op) ≫ (Γ₀.obj K).map θ = _\n  rw [assoc, ← Functor.map_comp]\n  dsimp [splitting]\n  erw [Γ₀.Obj.map_on_summand₀ K (Splitting.IndexSet.id A.1)\n    (show e ≫ i = ((Splitting.IndexSet.e A).op ≫ θ).unop ≫ 𝟙 _ by rw [comp_id, fac]; rfl),\n    Γ₀.Obj.map_on_summand₀ K (Splitting.IndexSet.id (op Δ''))\n      (show e ≫ 𝟙 Δ'' = e.op.unop ≫ 𝟙 _ by simp), Termwise.mapMono_id, id_comp]\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.map_on_summand'_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nΔ Δ' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nθ : Quiver.Hom Δ Δ'\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.DoldKan.Γ₀.obj K).obj Δ') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan Δ).inj A) (CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.DoldKan.Γ₀.obj K).map θ) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K (CategoryTheory.Limits.image.ι (CategoryTheory.CategoryStruct.comp θ.unop A.e))) (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan Δ').inj (A.pull θ)) h))","decl":"@[reassoc]\ntheorem Obj.map_on_summand' {Δ Δ' : SimplexCategoryᵒᵖ} (A : Splitting.IndexSet Δ) (θ : Δ ⟶ Δ') :\n    ((splitting K).cofan Δ).inj A ≫ (obj K).map θ =\n      Obj.Termwise.mapMono K (image.ι (θ.unop ≫ A.e)) ≫\n        ((splitting K).cofan Δ').inj (A.pull θ) := by\n  apply Obj.map_on_summand\n  apply image.fac\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.map_on_summand'","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nΔ Δ' : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Δ\nθ : Quiver.Hom Δ Δ'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan Δ).inj A) ((AlgebraicTopology.DoldKan.Γ₀.obj K).map θ)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K (CategoryTheory.Limits.image.ι (CategoryTheory.CategoryStruct.comp θ.unop A.e))) (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan Δ').inj (A.pull θ)))","decl":"@[reassoc]\ntheorem Obj.map_on_summand' {Δ Δ' : SimplexCategoryᵒᵖ} (A : Splitting.IndexSet Δ) (θ : Δ ⟶ Δ') :\n    ((splitting K).cofan Δ).inj A ≫ (obj K).map θ =\n      Obj.Termwise.mapMono K (image.ι (θ.unop ≫ A.e)) ≫\n        ((splitting K).cofan Δ').inj (A.pull θ) := by\n  apply Obj.map_on_summand\n  apply image.fac\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.mapMono_on_summand_id_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninst✝¹ : CategoryTheory.Limits.HasFiniteCoproducts C\nΔ Δ' : SimplexCategory\ni : Quiver.Hom Δ' Δ\ninst✝ : CategoryTheory.Mono i\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.DoldKan.Γ₀.obj K).obj { unop := Δ' }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan { unop := Δ }).inj (SimplicialObject.Splitting.IndexSet.id { unop := Δ })) (CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.DoldKan.Γ₀.obj K).map i.op) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i) (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan { unop := Δ' }).inj (SimplicialObject.Splitting.IndexSet.id { unop := Δ' })) h))","decl":"@[reassoc]\ntheorem Obj.mapMono_on_summand_id {Δ Δ' : SimplexCategory} (i : Δ' ⟶ Δ) [Mono i] :\n    ((splitting K).cofan _).inj (Splitting.IndexSet.id (op Δ)) ≫ (obj K).map i.op =\n      Obj.Termwise.mapMono K i ≫ ((splitting K).cofan _).inj (Splitting.IndexSet.id (op Δ')) :=\n  Obj.map_on_summand K (Splitting.IndexSet.id (op Δ)) i.op (rfl : 𝟙 _ ≫ i = i ≫ 𝟙 _)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.mapMono_on_summand_id","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninst✝¹ : CategoryTheory.Limits.HasFiniteCoproducts C\nΔ Δ' : SimplexCategory\ni : Quiver.Hom Δ' Δ\ninst✝ : CategoryTheory.Mono i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan { unop := Δ }).inj (SimplicialObject.Splitting.IndexSet.id { unop := Δ })) ((AlgebraicTopology.DoldKan.Γ₀.obj K).map i.op)) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i) (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan { unop := Δ' }).inj (SimplicialObject.Splitting.IndexSet.id { unop := Δ' })))","decl":"@[reassoc]\ntheorem Obj.mapMono_on_summand_id {Δ Δ' : SimplexCategory} (i : Δ' ⟶ Δ) [Mono i] :\n    ((splitting K).cofan _).inj (Splitting.IndexSet.id (op Δ)) ≫ (obj K).map i.op =\n      Obj.Termwise.mapMono K i ≫ ((splitting K).cofan _).inj (Splitting.IndexSet.id (op Δ')) :=\n  Obj.map_on_summand K (Splitting.IndexSet.id (op Δ)) i.op (rfl : 𝟙 _ ≫ i = i ≫ 𝟙 _)\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.map_epi_on_summand_id_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninst✝¹ : CategoryTheory.Limits.HasFiniteCoproducts C\nΔ Δ' : SimplexCategory\ne : Quiver.Hom Δ' Δ\ninst✝ : CategoryTheory.Epi e\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.DoldKan.Γ₀.obj K).obj { unop := Δ' }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan { unop := Δ }).inj (SimplicialObject.Splitting.IndexSet.id { unop := Δ })) (CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.DoldKan.Γ₀.obj K).map e.op) h)) (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan { unop := Δ' }).inj (SimplicialObject.Splitting.IndexSet.mk e)) h)","decl":"@[reassoc]\ntheorem Obj.map_epi_on_summand_id {Δ Δ' : SimplexCategory} (e : Δ' ⟶ Δ) [Epi e] :\n    ((Γ₀.splitting K).cofan _).inj (Splitting.IndexSet.id (op Δ)) ≫ (Γ₀.obj K).map e.op =\n      ((Γ₀.splitting K).cofan _).inj (Splitting.IndexSet.mk e) := by\n  simpa only [Γ₀.Obj.map_on_summand K (Splitting.IndexSet.id (op Δ)) e.op\n      (rfl : e ≫ 𝟙 Δ = e ≫ 𝟙 Δ),\n    Γ₀.Obj.Termwise.mapMono_id] using id_comp _\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.Obj.map_epi_on_summand_id","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nK : ChainComplex C Nat\ninst✝¹ : CategoryTheory.Limits.HasFiniteCoproducts C\nΔ Δ' : SimplexCategory\ne : Quiver.Hom Δ' Δ\ninst✝ : CategoryTheory.Epi e\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan { unop := Δ }).inj (SimplicialObject.Splitting.IndexSet.id { unop := Δ })) ((AlgebraicTopology.DoldKan.Γ₀.obj K).map e.op)) (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan { unop := Δ' }).inj (SimplicialObject.Splitting.IndexSet.mk e))","decl":"@[reassoc]\ntheorem Obj.map_epi_on_summand_id {Δ Δ' : SimplexCategory} (e : Δ' ⟶ Δ) [Epi e] :\n    ((Γ₀.splitting K).cofan _).inj (Splitting.IndexSet.id (op Δ)) ≫ (Γ₀.obj K).map e.op =\n      ((Γ₀.splitting K).cofan _).inj (Splitting.IndexSet.mk e) := by\n  simpa only [Γ₀.Obj.map_on_summand K (Splitting.IndexSet.id (op Δ)) e.op\n      (rfl : e ≫ 𝟙 Δ = e ≫ 𝟙 Δ),\n    Γ₀.Obj.Termwise.mapMono_id] using id_comp _\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀.map_app","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nK K' : ChainComplex C Nat\nf : Quiver.Hom K K'\nΔ : Opposite SimplexCategory\n⊢ Eq ((AlgebraicTopology.DoldKan.Γ₀.map f).app Δ) ((AlgebraicTopology.DoldKan.Γ₀.splitting K).desc Δ fun A => CategoryTheory.CategoryStruct.comp (f.f (Opposite.unop A.fst).len) (((AlgebraicTopology.DoldKan.Γ₀.splitting K').cofan Δ).inj A))","decl":"/-- The functor `Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C`, on morphisms. -/\n@[simps]\ndef map {K K' : ChainComplex C ℕ} (f : K ⟶ K') : obj K ⟶ obj K' where\n  app Δ := (Γ₀.splitting K).desc Δ fun A => f.f A.1.unop.len ≫\n    ((Γ₀.splitting K').cofan _).inj A\n  naturality {Δ' Δ} θ := by\n    apply (Γ₀.splitting K).hom_ext'\n    intro A\n    simp only [(splitting K).ι_desc_assoc, Obj.map_on_summand'_assoc K _ θ, (splitting K).ι_desc,\n      assoc, Obj.map_on_summand' K' _ θ]\n    apply Obj.Termwise.mapMono_naturality_assoc\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀'_obj","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nK : ChainComplex C Nat\n⊢ Eq (AlgebraicTopology.DoldKan.Γ₀'.obj K) (SimplicialObject.Split.mk' (AlgebraicTopology.DoldKan.Γ₀.splitting K))","decl":"/-- The functor `Γ₀' : ChainComplex C ℕ ⥤ SimplicialObject.Split C`\nthat induces `Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C`, which\nshall be the inverse functor of the Dold-Kan equivalence for\nabelian or pseudo-abelian categories. -/\n@[simps]\ndef Γ₀' : ChainComplex C ℕ ⥤ SimplicialObject.Split C where\n  obj K := SimplicialObject.Split.mk' (Γ₀.splitting K)\n  map {K K'} f :=\n    { F := Γ₀.map f\n      f := f.f\n      comm := fun n => by\n        dsimp\n        simp only [← Splitting.cofan_inj_id, (Γ₀.splitting K).ι_desc]\n        rfl }\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀'_map_F","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nK K' : ChainComplex C Nat\nf : Quiver.Hom K K'\n⊢ Eq (AlgebraicTopology.DoldKan.Γ₀'.map f).F (AlgebraicTopology.DoldKan.Γ₀.map f)","decl":"/-- The functor `Γ₀' : ChainComplex C ℕ ⥤ SimplicialObject.Split C`\nthat induces `Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C`, which\nshall be the inverse functor of the Dold-Kan equivalence for\nabelian or pseudo-abelian categories. -/\n@[simps]\ndef Γ₀' : ChainComplex C ℕ ⥤ SimplicialObject.Split C where\n  obj K := SimplicialObject.Split.mk' (Γ₀.splitting K)\n  map {K K'} f :=\n    { F := Γ₀.map f\n      f := f.f\n      comm := fun n => by\n        dsimp\n        simp only [← Splitting.cofan_inj_id, (Γ₀.splitting K).ι_desc]\n        rfl }\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀'_map_f","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nK K' : ChainComplex C Nat\nf : Quiver.Hom K K'\ni : Nat\n⊢ Eq ((AlgebraicTopology.DoldKan.Γ₀'.map f).f i) (f.f i)","decl":"/-- The functor `Γ₀' : ChainComplex C ℕ ⥤ SimplicialObject.Split C`\nthat induces `Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C`, which\nshall be the inverse functor of the Dold-Kan equivalence for\nabelian or pseudo-abelian categories. -/\n@[simps]\ndef Γ₀' : ChainComplex C ℕ ⥤ SimplicialObject.Split C where\n  obj K := SimplicialObject.Split.mk' (Γ₀.splitting K)\n  map {K K'} f :=\n    { F := Γ₀.map f\n      f := f.f\n      comm := fun n => by\n        dsimp\n        simp only [← Splitting.cofan_inj_id, (Γ₀.splitting K).ι_desc]\n        rfl }\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀_obj_obj","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nX : ChainComplex C Nat\nΔ : Opposite SimplexCategory\n⊢ Eq ((AlgebraicTopology.DoldKan.Γ₀.obj X).obj Δ) (AlgebraicTopology.DoldKan.Γ₀.Obj.obj₂ X Δ)","decl":"/-- The functor `Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C`, which is\nthe inverse functor of the Dold-Kan equivalence when `C` is an abelian\ncategory, or more generally a pseudoabelian category. -/\n@[simps!]\ndef Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C :=\n  Γ₀' ⋙ Split.forget _\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀_obj_map","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nX : ChainComplex C Nat\nX✝ Y✝ : Opposite SimplexCategory\nθ : Quiver.Hom X✝ Y✝\n⊢ Eq ((AlgebraicTopology.DoldKan.Γ₀.obj X).map θ) (AlgebraicTopology.DoldKan.Γ₀.Obj.map X θ)","decl":"/-- The functor `Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C`, which is\nthe inverse functor of the Dold-Kan equivalence when `C` is an abelian\ncategory, or more generally a pseudoabelian category. -/\n@[simps!]\ndef Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C :=\n  Γ₀' ⋙ Split.forget _\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₀_map_app","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nX✝ Y✝ : ChainComplex C Nat\nf : Quiver.Hom X✝ Y✝\nΔ : Opposite SimplexCategory\n⊢ Eq ((AlgebraicTopology.DoldKan.Γ₀.map f).app Δ) ((AlgebraicTopology.DoldKan.Γ₀.splitting X✝).desc Δ fun A => CategoryTheory.CategoryStruct.comp (f.f (Opposite.unop A.fst).len) (((AlgebraicTopology.DoldKan.Γ₀.splitting Y✝).cofan Δ).inj A))","decl":"/-- The functor `Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C`, which is\nthe inverse functor of the Dold-Kan equivalence when `C` is an abelian\ncategory, or more generally a pseudoabelian category. -/\n@[simps!]\ndef Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C :=\n  Γ₀' ⋙ Split.forget _\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₂_obj_X_obj","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nP : CategoryTheory.Idempotents.Karoubi (ChainComplex C Nat)\nΔ : Opposite SimplexCategory\n⊢ Eq ((AlgebraicTopology.DoldKan.Γ₂.obj P).X.obj Δ) (AlgebraicTopology.DoldKan.Γ₀.Obj.obj₂ P.X Δ)","decl":"/-- The extension of `Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C`\non the idempotent completions. It shall be an equivalence of categories\nfor any additive category `C`. -/\n@[simps!]\ndef Γ₂ : Karoubi (ChainComplex C ℕ) ⥤ Karoubi (SimplicialObject C) :=\n  (CategoryTheory.Idempotents.functorExtension₂ _ _).obj Γ₀\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₂_map_f_app","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nX✝ Y✝ : CategoryTheory.Idempotents.Karoubi (ChainComplex C Nat)\nf : Quiver.Hom X✝ Y✝\nΔ : Opposite SimplexCategory\n⊢ Eq ((AlgebraicTopology.DoldKan.Γ₂.map f).f.app Δ) ((AlgebraicTopology.DoldKan.Γ₀.splitting X✝.X).desc Δ fun A => CategoryTheory.CategoryStruct.comp (f.f.f (Opposite.unop A.fst).len) (((AlgebraicTopology.DoldKan.Γ₀.splitting Y✝.X).cofan Δ).inj A))","decl":"/-- The extension of `Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C`\non the idempotent completions. It shall be an equivalence of categories\nfor any additive category `C`. -/\n@[simps!]\ndef Γ₂ : Karoubi (ChainComplex C ℕ) ⥤ Karoubi (SimplicialObject C) :=\n  (CategoryTheory.Idempotents.functorExtension₂ _ _).obj Γ₀\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₂_obj_p_app","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nP : CategoryTheory.Idempotents.Karoubi (ChainComplex C Nat)\nΔ : Opposite SimplexCategory\n⊢ Eq ((AlgebraicTopology.DoldKan.Γ₂.obj P).p.app Δ) ((AlgebraicTopology.DoldKan.Γ₀.splitting P.X).desc Δ fun A => CategoryTheory.CategoryStruct.comp (P.p.f (Opposite.unop A.fst).len) (((AlgebraicTopology.DoldKan.Γ₀.splitting P.X).cofan Δ).inj A))","decl":"/-- The extension of `Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C`\non the idempotent completions. It shall be an equivalence of categories\nfor any additive category `C`. -/\n@[simps!]\ndef Γ₂ : Karoubi (ChainComplex C ℕ) ⥤ Karoubi (SimplicialObject C) :=\n  (CategoryTheory.Idempotents.functorExtension₂ _ _).obj Γ₀\n\n"}
{"name":"AlgebraicTopology.DoldKan.Γ₂_obj_X_map","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nP : CategoryTheory.Idempotents.Karoubi (ChainComplex C Nat)\nX✝ Y✝ : Opposite SimplexCategory\nθ : Quiver.Hom X✝ Y✝\n⊢ Eq ((AlgebraicTopology.DoldKan.Γ₂.obj P).X.map θ) (AlgebraicTopology.DoldKan.Γ₀.Obj.map P.X θ)","decl":"/-- The extension of `Γ₀ : ChainComplex C ℕ ⥤ SimplicialObject C`\non the idempotent completions. It shall be an equivalence of categories\nfor any additive category `C`. -/\n@[simps!]\ndef Γ₂ : Karoubi (ChainComplex C ℕ) ⥤ Karoubi (SimplicialObject C) :=\n  (CategoryTheory.Idempotents.functorExtension₂ _ _).obj Γ₀\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.on_Γ₀_summand_id","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nK : ChainComplex C Nat\nn : Nat\n⊢ AlgebraicTopology.DoldKan.HigherFacesVanish (HAdd.hAdd n 1) (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan { unop := SimplexCategory.mk (HAdd.hAdd n 1) }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk (HAdd.hAdd n 1) }))","decl":"theorem HigherFacesVanish.on_Γ₀_summand_id (K : ChainComplex C ℕ) (n : ℕ) :\n    @HigherFacesVanish C _ _ (Γ₀.obj K) _ n (n + 1)\n      (((Γ₀.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n + 1]))) := by\n  intro j _\n  have eq := Γ₀.Obj.mapMono_on_summand_id K (SimplexCategory.δ j.succ)\n  rw [Γ₀.Obj.Termwise.mapMono_eq_zero K, zero_comp] at eq; rotate_left\n  · intro h\n    exact (Nat.succ_ne_self n) (congr_arg SimplexCategory.len h)\n  · exact fun h => Fin.succ_ne_zero j (by simpa only [Isδ₀.iff] using h)\n  exact eq\n\n"}
{"name":"AlgebraicTopology.DoldKan.PInfty_on_Γ₀_splitting_summand_eq_self_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nK : ChainComplex C Nat\nn : Nat\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.AlternatingFaceMapComplex.obj (AlgebraicTopology.DoldKan.Γ₀.obj K)).X n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f n) h)) (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) h)","decl":"@[reassoc (attr := simp)]\ntheorem PInfty_on_Γ₀_splitting_summand_eq_self (K : ChainComplex C ℕ) {n : ℕ} :\n    ((Γ₀.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n])) ≫\n      (PInfty : K[Γ₀.obj K] ⟶ _).f n =\n      ((Γ₀.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n])) := by\n  rw [PInfty_f]\n  rcases n with _|n\n  · simpa only [P_f_0_eq] using comp_id _\n  · exact (HigherFacesVanish.on_Γ₀_summand_id K n).comp_P_eq_self\n\n"}
{"name":"AlgebraicTopology.DoldKan.PInfty_on_Γ₀_splitting_summand_eq_self","module":"Mathlib.AlgebraicTopology.DoldKan.FunctorGamma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nK : ChainComplex C Nat\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) (AlgebraicTopology.DoldKan.PInfty.f n)) (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n }))","decl":"@[reassoc (attr := simp)]\ntheorem PInfty_on_Γ₀_splitting_summand_eq_self (K : ChainComplex C ℕ) {n : ℕ} :\n    ((Γ₀.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n])) ≫\n      (PInfty : K[Γ₀.obj K] ⟶ _).f n =\n      ((Γ₀.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n])) := by\n  rw [PInfty_f]\n  rcases n with _|n\n  · simpa only [P_f_0_eq] using comp_id _\n  · exact (HigherFacesVanish.on_Γ₀_summand_id K n).comp_P_eq_self\n\n"}
