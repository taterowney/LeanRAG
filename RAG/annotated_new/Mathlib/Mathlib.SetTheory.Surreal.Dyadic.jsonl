{"name":"SetTheory.PGame.powHalf_zero","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"⊢ Eq (SetTheory.PGame.powHalf 0) 1","decl":"@[simp]\ntheorem powHalf_zero : powHalf 0 = 1 :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.powHalf_leftMoves","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\n⊢ Eq (SetTheory.PGame.powHalf n).LeftMoves PUnit.{u_1 + 1}","decl":"theorem powHalf_leftMoves (n) : (powHalf n).LeftMoves = PUnit := by cases n <;> rfl\n\n"}
{"name":"SetTheory.PGame.powHalf_zero_rightMoves","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"⊢ Eq (SetTheory.PGame.powHalf 0).RightMoves PEmpty.{u_1 + 1}","decl":"theorem powHalf_zero_rightMoves : (powHalf 0).RightMoves = PEmpty :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.powHalf_succ_rightMoves","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\n⊢ Eq (SetTheory.PGame.powHalf (HAdd.hAdd n 1)).RightMoves PUnit.{u_1 + 1}","decl":"theorem powHalf_succ_rightMoves (n) : (powHalf (n + 1)).RightMoves = PUnit :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.powHalf_moveLeft","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\ni : (SetTheory.PGame.powHalf n).LeftMoves\n⊢ Eq ((SetTheory.PGame.powHalf n).moveLeft i) 0","decl":"@[simp]\ntheorem powHalf_moveLeft (n i) : (powHalf n).moveLeft i = 0 := by cases n <;> cases i <;> rfl\n\n"}
{"name":"SetTheory.PGame.powHalf_succ_moveRight","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\ni : (SetTheory.PGame.powHalf (HAdd.hAdd n 1)).RightMoves\n⊢ Eq ((SetTheory.PGame.powHalf (HAdd.hAdd n 1)).moveRight i) (SetTheory.PGame.powHalf n)","decl":"@[simp]\ntheorem powHalf_succ_moveRight (n i) : (powHalf (n + 1)).moveRight i = powHalf n :=\n  rfl\n\n"}
{"name":"SetTheory.PGame.isEmpty_powHalf_zero_rightMoves","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"⊢ IsEmpty (SetTheory.PGame.powHalf 0).RightMoves","decl":"instance isEmpty_powHalf_zero_rightMoves : IsEmpty (powHalf 0).RightMoves :=\n  inferInstanceAs (IsEmpty PEmpty)\n\n"}
{"name":"SetTheory.PGame.birthday_half","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"⊢ Eq (SetTheory.PGame.powHalf 1).birthday 2","decl":"@[simp]\ntheorem birthday_half : birthday (powHalf 1) = 2 := by\n  rw [birthday_def]; simp\n\n"}
{"name":"SetTheory.PGame.numeric_powHalf","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\n⊢ (SetTheory.PGame.powHalf n).Numeric","decl":"/-- For all natural numbers `n`, the pre-games `powHalf n` are numeric. -/\ntheorem numeric_powHalf (n) : (powHalf n).Numeric := by\n  induction n with\n  | zero => exact numeric_one\n  | succ n hn =>\n    constructor\n    · simpa using hn.moveLeft_lt default\n    · exact ⟨fun _ => numeric_zero, fun _ => hn⟩\n\n"}
{"name":"SetTheory.PGame.powHalf_succ_lt_powHalf","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\n⊢ LT.lt (SetTheory.PGame.powHalf (HAdd.hAdd n 1)) (SetTheory.PGame.powHalf n)","decl":"theorem powHalf_succ_lt_powHalf (n : ℕ) : powHalf (n + 1) < powHalf n :=\n  (numeric_powHalf (n + 1)).lt_moveRight default\n\n"}
{"name":"SetTheory.PGame.powHalf_succ_le_powHalf","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\n⊢ LE.le (SetTheory.PGame.powHalf (HAdd.hAdd n 1)) (SetTheory.PGame.powHalf n)","decl":"theorem powHalf_succ_le_powHalf (n : ℕ) : powHalf (n + 1) ≤ powHalf n :=\n  (powHalf_succ_lt_powHalf n).le\n\n"}
{"name":"SetTheory.PGame.powHalf_le_one","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\n⊢ LE.le (SetTheory.PGame.powHalf n) 1","decl":"theorem powHalf_le_one (n : ℕ) : powHalf n ≤ 1 := by\n  induction n with\n  | zero => exact le_rfl\n  | succ n hn => exact (powHalf_succ_le_powHalf n).trans hn\n\n"}
{"name":"SetTheory.PGame.powHalf_succ_lt_one","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\n⊢ LT.lt (SetTheory.PGame.powHalf (HAdd.hAdd n 1)) 1","decl":"theorem powHalf_succ_lt_one (n : ℕ) : powHalf (n + 1) < 1 :=\n  (powHalf_succ_lt_powHalf n).trans_le <| powHalf_le_one n\n\n"}
{"name":"SetTheory.PGame.powHalf_pos","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\n⊢ LT.lt 0 (SetTheory.PGame.powHalf n)","decl":"theorem powHalf_pos (n : ℕ) : 0 < powHalf n := by\n  rw [← lf_iff_lt numeric_zero (numeric_powHalf n), zero_lf_le]; simp\n\n"}
{"name":"SetTheory.PGame.zero_le_powHalf","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\n⊢ LE.le 0 (SetTheory.PGame.powHalf n)","decl":"theorem zero_le_powHalf (n : ℕ) : 0 ≤ powHalf n :=\n  (powHalf_pos n).le\n\n"}
{"name":"SetTheory.PGame.add_powHalf_succ_self_eq_powHalf","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\n⊢ HasEquiv.Equiv (HAdd.hAdd (SetTheory.PGame.powHalf (HAdd.hAdd n 1)) (SetTheory.PGame.powHalf (HAdd.hAdd n 1))) (SetTheory.PGame.powHalf n)","decl":"theorem add_powHalf_succ_self_eq_powHalf (n) : powHalf (n + 1) + powHalf (n + 1) ≈ powHalf n := by\n  induction' n using Nat.strong_induction_on with n hn\n  constructor <;> rw [le_iff_forall_lf] <;> constructor\n  · rintro (⟨⟨⟩⟩ | ⟨⟨⟩⟩) <;> apply lf_of_lt\n    · calc\n        0 + powHalf n.succ ≈ powHalf n.succ := zero_add_equiv _\n        _ < powHalf n := powHalf_succ_lt_powHalf n\n    · calc\n        powHalf n.succ + 0 ≈ powHalf n.succ := add_zero_equiv _\n        _ < powHalf n := powHalf_succ_lt_powHalf n\n  · cases' n with n\n    · rintro ⟨⟩\n    rintro ⟨⟩\n    apply lf_of_moveRight_le\n    swap\n    · exact Sum.inl default\n    calc\n      powHalf n.succ + powHalf (n.succ + 1) ≤ powHalf n.succ + powHalf n.succ :=\n        add_le_add_left (powHalf_succ_le_powHalf _) _\n      _ ≈ powHalf n := hn _ (Nat.lt_succ_self n)\n  · simp only [powHalf_moveLeft, forall_const]\n    apply lf_of_lt\n    calc\n      0 ≈ 0 + 0 := Equiv.symm (add_zero_equiv 0)\n      _ ≤ powHalf n.succ + 0 := add_le_add_right (zero_le_powHalf _) _\n      _ < powHalf n.succ + powHalf n.succ := add_lt_add_left (powHalf_pos _) _\n  · rintro (⟨⟨⟩⟩ | ⟨⟨⟩⟩) <;> apply lf_of_lt\n    · calc\n        powHalf n ≈ powHalf n + 0 := Equiv.symm (add_zero_equiv _)\n        _ < powHalf n + powHalf n.succ := add_lt_add_left (powHalf_pos _) _\n    · calc\n        powHalf n ≈ 0 + powHalf n := Equiv.symm (zero_add_equiv _)\n        _ < powHalf n.succ + powHalf n := add_lt_add_right (powHalf_pos _) _\n\n"}
{"name":"SetTheory.PGame.half_add_half_equiv_one","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"⊢ HasEquiv.Equiv (HAdd.hAdd (SetTheory.PGame.powHalf 1) (SetTheory.PGame.powHalf 1)) 1","decl":"theorem half_add_half_equiv_one : powHalf 1 + powHalf 1 ≈ 1 :=\n  add_powHalf_succ_self_eq_powHalf 0\n\n"}
{"name":"Surreal.powHalf_zero","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"⊢ Eq (Surreal.powHalf 0) 1","decl":"@[simp]\ntheorem powHalf_zero : powHalf 0 = 1 :=\n  rfl\n\n"}
{"name":"Surreal.double_powHalf_succ_eq_powHalf","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\n⊢ Eq (HMul.hMul 2 (Surreal.powHalf (HAdd.hAdd n 1))) (Surreal.powHalf n)","decl":"@[simp]\ntheorem double_powHalf_succ_eq_powHalf (n : ℕ) : 2 * powHalf (n + 1) = powHalf n := by\n  rw [two_mul]; exact Quotient.sound (PGame.add_powHalf_succ_self_eq_powHalf n)\n\n"}
{"name":"Surreal.nsmul_pow_two_powHalf","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n : Nat\n⊢ Eq (HMul.hMul (HPow.hPow 2 n) (Surreal.powHalf n)) 1","decl":"@[simp]\ntheorem nsmul_pow_two_powHalf (n : ℕ) : 2 ^ n * powHalf n = 1 := by\n  induction' n with n hn\n  · simp only [pow_zero, powHalf_zero, mul_one]\n  · rw [← hn, ← double_powHalf_succ_eq_powHalf n, ← mul_assoc (2 ^ n) 2 (powHalf (n + 1)),\n      pow_succ', mul_comm 2 (2 ^ n)]\n\n"}
{"name":"Surreal.nsmul_pow_two_powHalf'","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"n k : Nat\n⊢ Eq (HMul.hMul (HPow.hPow 2 n) (Surreal.powHalf (HAdd.hAdd n k))) (Surreal.powHalf k)","decl":"@[simp]\ntheorem nsmul_pow_two_powHalf' (n k : ℕ) : 2 ^ n * powHalf (n + k) = powHalf k := by\n  induction' k with k hk\n  · simp only [add_zero, Surreal.nsmul_pow_two_powHalf, eq_self_iff_true,\n      Surreal.powHalf_zero]\n  · rw [← double_powHalf_succ_eq_powHalf (n + k), ← double_powHalf_succ_eq_powHalf k,\n      ← mul_assoc, mul_comm (2 ^ n) 2, mul_assoc] at hk\n    rw [← zsmul_eq_zsmul_iff' two_ne_zero]\n    simpa only [zsmul_eq_mul, Int.cast_ofNat]\n\n"}
{"name":"Surreal.zsmul_pow_two_powHalf","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"m : Int\nn k : Nat\n⊢ Eq (HMul.hMul (HMul.hMul (↑m) (HPow.hPow 2 n)) (Surreal.powHalf (HAdd.hAdd n k))) (HMul.hMul (↑m) (Surreal.powHalf k))","decl":"theorem zsmul_pow_two_powHalf (m : ℤ) (n k : ℕ) :\n    (m * 2 ^ n) * powHalf (n + k) = m * powHalf k := by\n  rw [mul_assoc]\n  congr\n  exact nsmul_pow_two_powHalf' n k\n\n"}
{"name":"Surreal.dyadic_aux","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"m₁ m₂ : Int\ny₁ y₂ : Nat\nh₂ : Eq (HMul.hMul m₁ (HPow.hPow 2 y₁)) (HMul.hMul m₂ (HPow.hPow 2 y₂))\n⊢ Eq (HMul.hMul (↑m₁) (Surreal.powHalf y₂)) (HMul.hMul (↑m₂) (Surreal.powHalf y₁))","decl":"theorem dyadic_aux {m₁ m₂ : ℤ} {y₁ y₂ : ℕ} (h₂ : m₁ * 2 ^ y₁ = m₂ * 2 ^ y₂) :\n    m₁ * powHalf y₂ = m₂ * powHalf y₁ := by\n  revert m₁ m₂\n  wlog h : y₁ ≤ y₂\n  · intro m₁ m₂ aux; exact (this (le_of_not_le h) aux.symm).symm\n  intro m₁ m₂ h₂\n  obtain ⟨c, rfl⟩ := le_iff_exists_add.mp h\n  rw [add_comm, pow_add, ← mul_assoc, mul_eq_mul_right_iff] at h₂\n  cases' h₂ with h₂ h₂\n  · rw [h₂, add_comm]\n    simp_rw [Int.cast_mul, Int.cast_pow, Int.cast_ofNat, zsmul_pow_two_powHalf m₂ c y₁]\n  · have := Nat.one_le_pow y₁ 2 Nat.succ_pos'\n    norm_cast at h₂; omega\n\n"}
{"name":"Surreal.dyadicMap_apply","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"m : Int\np : Subtype fun x => Membership.mem (Submonoid.powers 2) x\n⊢ Eq (Surreal.dyadicMap (IsLocalization.mk' (Localization (Submonoid.powers 2)) m p)) (HMul.hMul (↑m) (Surreal.powHalf (Submonoid.log p)))","decl":"@[simp]\ntheorem dyadicMap_apply (m : ℤ) (p : Submonoid.powers (2 : ℤ)) :\n    dyadicMap (IsLocalization.mk' (Localization (Submonoid.powers 2)) m p) =\n      m * powHalf (Submonoid.log p) := by\n  rw [← Localization.mk_eq_mk']; rfl\n\n"}
{"name":"Surreal.dyadicMap_apply_pow","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"m : Int\nn : Nat\n⊢ Eq (Surreal.dyadicMap (IsLocalization.mk' (Localization (Submonoid.powers 2)) m (Submonoid.pow 2 n))) (HSMul.hSMul m (Surreal.powHalf n))","decl":"theorem dyadicMap_apply_pow (m : ℤ) (n : ℕ) :\n    dyadicMap (IsLocalization.mk' (Localization (Submonoid.powers 2)) m (Submonoid.pow 2 n)) =\n      m • powHalf n := by\n  rw [dyadicMap_apply, @Submonoid.log_pow_int_eq_self 2 one_lt_two]\n  simp only [zsmul_eq_mul]\n\n"}
{"name":"Surreal.dyadicMap_apply_pow'","module":"Mathlib.SetTheory.Surreal.Dyadic","initialProofState":"m : Int\nn : Nat\n⊢ Eq (HMul.hMul (↑m) (Surreal.powHalf (Submonoid.log (Submonoid.pow 2 n)))) (HMul.hMul (↑m) (Surreal.powHalf n))","decl":"@[simp]\ntheorem dyadicMap_apply_pow' (m : ℤ) (n : ℕ) :\n    m * Surreal.powHalf (Submonoid.log (Submonoid.pow (2 : ℤ) n)) = m * powHalf n := by\n  rw [@Submonoid.log_pow_int_eq_self 2 one_lt_two]\n\n"}
