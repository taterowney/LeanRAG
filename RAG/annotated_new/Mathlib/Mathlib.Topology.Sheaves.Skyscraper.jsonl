{"name":"skyscraperPresheaf_map","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝² : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nA : C\nU V : Opposite (TopologicalSpace.Opens ↑X)\ni : Quiver.Hom U V\n⊢ Eq ((skyscraperPresheaf p₀ A).map i) (dite (Membership.mem (Opposite.unop V) p₀) (fun h => CategoryTheory.eqToHom ⋯) fun h => (Eq.ndrec CategoryTheory.Limits.terminalIsTerminal ⋯).from ((fun U => ite (Membership.mem (Opposite.unop U) p₀) A (CategoryTheory.Limits.terminal C)) U))","decl":"/-- A skyscraper presheaf is a presheaf supported at a single point: if `p₀ ∈ X` is a specified\npoint, then the skyscraper presheaf `𝓕` with value `A` is defined by `U ↦ A` if `p₀ ∈ U` and\n`U ↦ *` if `p₀ ∉ A` where `*` is some terminal object.\n-/\n@[simps]\ndef skyscraperPresheaf : Presheaf C X where\n  obj U := if p₀ ∈ unop U then A else terminal C\n  map {U V} i :=\n    if h : p₀ ∈ unop V then eqToHom <| by dsimp; rw [if_pos h, if_pos (by simpa using i.unop.le h)]\n    else ((if_neg h).symm.ndrec terminalIsTerminal).from _\n  map_id U :=\n    (em (p₀ ∈ U.unop)).elim (fun h => dif_pos h) fun h =>\n      ((if_neg h).symm.ndrec terminalIsTerminal).hom_ext _ _\n  map_comp {U V W} iVU iWV := by\n    by_cases hW : p₀ ∈ unop W\n    · have hV : p₀ ∈ unop V := leOfHom iWV.unop hW\n      simp only [dif_pos hW, dif_pos hV, eqToHom_trans]\n    · dsimp; rw [dif_neg hW]; apply ((if_neg hW).symm.ndrec terminalIsTerminal).hom_ext\n\n"}
{"name":"skyscraperPresheaf_obj","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝² : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nA : C\nU : Opposite (TopologicalSpace.Opens ↑X)\n⊢ Eq ((skyscraperPresheaf p₀ A).obj U) (ite (Membership.mem (Opposite.unop U) p₀) A (CategoryTheory.Limits.terminal C))","decl":"/-- A skyscraper presheaf is a presheaf supported at a single point: if `p₀ ∈ X` is a specified\npoint, then the skyscraper presheaf `𝓕` with value `A` is defined by `U ↦ A` if `p₀ ∈ U` and\n`U ↦ *` if `p₀ ∉ A` where `*` is some terminal object.\n-/\n@[simps]\ndef skyscraperPresheaf : Presheaf C X where\n  obj U := if p₀ ∈ unop U then A else terminal C\n  map {U V} i :=\n    if h : p₀ ∈ unop V then eqToHom <| by dsimp; rw [if_pos h, if_pos (by simpa using i.unop.le h)]\n    else ((if_neg h).symm.ndrec terminalIsTerminal).from _\n  map_id U :=\n    (em (p₀ ∈ U.unop)).elim (fun h => dif_pos h) fun h =>\n      ((if_neg h).symm.ndrec terminalIsTerminal).hom_ext _ _\n  map_comp {U V W} iVU iWV := by\n    by_cases hW : p₀ ∈ unop W\n    · have hV : p₀ ∈ unop V := leOfHom iWV.unop hW\n      simp only [dif_pos hW, dif_pos hV, eqToHom_trans]\n    · dsimp; rw [dif_neg hW]; apply ((if_neg hW).symm.ndrec terminalIsTerminal).hom_ext\n\n"}
{"name":"skyscraperPresheaf_eq_pushforward","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝² : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nA : C\nhd : (U : TopologicalSpace.Opens ↑(TopCat.of PUnit.{u + 1})) → Decidable (Membership.mem U PUnit.unit)\n⊢ Eq (skyscraperPresheaf p₀ A) ((TopCat.Presheaf.pushforward C (ContinuousMap.const (↑(TopCat.of PUnit.{u + 1})) p₀)).obj (skyscraperPresheaf PUnit.unit A))","decl":"theorem skyscraperPresheaf_eq_pushforward\n    [hd : ∀ U : Opens (TopCat.of PUnit.{u + 1}), Decidable (PUnit.unit ∈ U)] :\n    skyscraperPresheaf p₀ A =\n      ContinuousMap.const (TopCat.of PUnit) p₀ _*\n        skyscraperPresheaf (X := TopCat.of PUnit) PUnit.unit A := by\n  convert_to @skyscraperPresheaf X p₀ (fun U => hd <| (Opens.map <| ContinuousMap.const _ p₀).obj U)\n    C _ _ A = _ <;> congr\n\n"}
{"name":"SkyscraperPresheafFunctor.map'_app","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝² : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\na b : C\nf : Quiver.Hom a b\nU : Opposite (TopologicalSpace.Opens ↑X)\n⊢ Eq ((SkyscraperPresheafFunctor.map' p₀ f).app U) (dite (Membership.mem (Opposite.unop U) p₀) (fun h => CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom ⋯))) fun h => (Eq.ndrec CategoryTheory.Limits.terminalIsTerminal ⋯).from ((skyscraperPresheaf p₀ a).obj U))","decl":"/-- Taking skyscraper presheaf at a point is functorial: `c ↦ skyscraper p₀ c` defines a functor by\nsending every `f : a ⟶ b` to the natural transformation `α` defined as: `α(U) = f : a ⟶ b` if\n`p₀ ∈ U` and the unique morphism to a terminal object in `C` if `p₀ ∉ U`.\n-/\n@[simps]\ndef SkyscraperPresheafFunctor.map' {a b : C} (f : a ⟶ b) :\n    skyscraperPresheaf p₀ a ⟶ skyscraperPresheaf p₀ b where\n  app U :=\n    if h : p₀ ∈ U.unop then eqToHom (if_pos h) ≫ f ≫ eqToHom (if_pos h).symm\n    else ((if_neg h).symm.ndrec terminalIsTerminal).from _\n  naturality U V i := by\n    simp only [skyscraperPresheaf_map]\n    by_cases hV : p₀ ∈ V.unop\n    · have hU : p₀ ∈ U.unop := leOfHom i.unop hV\n      simp only [skyscraperPresheaf_obj, hU, hV, ↓reduceDIte, eqToHom_trans_assoc, Category.assoc,\n        eqToHom_trans]\n    · apply ((if_neg hV).symm.ndrec terminalIsTerminal).hom_ext\n\n"}
{"name":"SkyscraperPresheafFunctor.map'_id","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝² : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\na : C\n⊢ Eq (SkyscraperPresheafFunctor.map' p₀ (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (skyscraperPresheaf p₀ a))","decl":"theorem SkyscraperPresheafFunctor.map'_id {a : C} :\n    SkyscraperPresheafFunctor.map' p₀ (𝟙 a) = 𝟙 _ := by\n  ext U\n  simp only [SkyscraperPresheafFunctor.map'_app, NatTrans.id_app]; split_ifs <;> aesop_cat\n\n"}
{"name":"SkyscraperPresheafFunctor.map'_comp","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝² : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\na b c : C\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n⊢ Eq (SkyscraperPresheafFunctor.map' p₀ (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (SkyscraperPresheafFunctor.map' p₀ f) (SkyscraperPresheafFunctor.map' p₀ g))","decl":"theorem SkyscraperPresheafFunctor.map'_comp {a b c : C} (f : a ⟶ b) (g : b ⟶ c) :\n    SkyscraperPresheafFunctor.map' p₀ (f ≫ g) =\n      SkyscraperPresheafFunctor.map' p₀ f ≫ SkyscraperPresheafFunctor.map' p₀ g := by\n  ext U\n  simp only [SkyscraperPresheafFunctor.map'_app, NatTrans.comp_app]\n  split_ifs with h <;> aesop_cat\n\n"}
{"name":"skyscraperPresheafFunctor_obj","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝² : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nA : C\n⊢ Eq ((skyscraperPresheafFunctor p₀).obj A) (skyscraperPresheaf p₀ A)","decl":"/-- Taking skyscraper presheaf at a point is functorial: `c ↦ skyscraper p₀ c` defines a functor by\nsending every `f : a ⟶ b` to the natural transformation `α` defined as: `α(U) = f : a ⟶ b` if\n`p₀ ∈ U` and the unique morphism to a terminal object in `C` if `p₀ ∉ U`.\n-/\n@[simps]\ndef skyscraperPresheafFunctor : C ⥤ Presheaf C X where\n  obj := skyscraperPresheaf p₀\n  map := SkyscraperPresheafFunctor.map' p₀\n  map_id _ := SkyscraperPresheafFunctor.map'_id p₀\n  map_comp := SkyscraperPresheafFunctor.map'_comp p₀\n\n"}
{"name":"skyscraperPresheafFunctor_map","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝² : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((skyscraperPresheafFunctor p₀).map f) (SkyscraperPresheafFunctor.map' p₀ f)","decl":"/-- Taking skyscraper presheaf at a point is functorial: `c ↦ skyscraper p₀ c` defines a functor by\nsending every `f : a ⟶ b` to the natural transformation `α` defined as: `α(U) = f : a ⟶ b` if\n`p₀ ∈ U` and the unique morphism to a terminal object in `C` if `p₀ ∉ U`.\n-/\n@[simps]\ndef skyscraperPresheafFunctor : C ⥤ Presheaf C X where\n  obj := skyscraperPresheaf p₀\n  map := SkyscraperPresheafFunctor.map' p₀\n  map_id _ := SkyscraperPresheafFunctor.map'_id p₀\n  map_comp := SkyscraperPresheafFunctor.map'_comp p₀\n\n"}
{"name":"skyscraperPresheafCoconeOfSpecializes_ι_app","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝² : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝¹ : CategoryTheory.Category.{u, v} C\nA : C\ninst✝ : CategoryTheory.Limits.HasTerminal C\ny : ↑X\nh : Specializes p₀ y\nU : Opposite (TopologicalSpace.OpenNhds y)\n⊢ Eq ((skyscraperPresheafCoconeOfSpecializes p₀ A h).ι.app U) (CategoryTheory.eqToHom ⋯)","decl":"/-- The cocone at `A` for the stalk functor of `skyscraperPresheaf p₀ A` when `y ∈ closure {p₀}`\n-/\n@[simps]\ndef skyscraperPresheafCoconeOfSpecializes {y : X} (h : p₀ ⤳ y) :\n    Cocone ((OpenNhds.inclusion y).op ⋙ skyscraperPresheaf p₀ A) where\n  pt := A\n  ι :=\n    { app := fun U => eqToHom <| if_pos <| h.mem_open U.unop.1.2 U.unop.2\n      naturality := fun U V inc => by\n        change dite _ _ _ ≫ _ = _; rw [dif_pos]\n        swap -- Porting note: swap goal to prevent proving same thing twice\n        · exact h.mem_open V.unop.1.2 V.unop.2\n        · simp only [Functor.comp_obj, Functor.op_obj, skyscraperPresheaf_obj, unop_op,\n            Functor.const_obj_obj, eqToHom_trans, Functor.const_obj_map, Category.comp_id] }\n\n"}
{"name":"skyscraperPresheafCoconeOfSpecializes_pt","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝² : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝¹ : CategoryTheory.Category.{u, v} C\nA : C\ninst✝ : CategoryTheory.Limits.HasTerminal C\ny : ↑X\nh : Specializes p₀ y\n⊢ Eq (skyscraperPresheafCoconeOfSpecializes p₀ A h).pt A","decl":"/-- The cocone at `A` for the stalk functor of `skyscraperPresheaf p₀ A` when `y ∈ closure {p₀}`\n-/\n@[simps]\ndef skyscraperPresheafCoconeOfSpecializes {y : X} (h : p₀ ⤳ y) :\n    Cocone ((OpenNhds.inclusion y).op ⋙ skyscraperPresheaf p₀ A) where\n  pt := A\n  ι :=\n    { app := fun U => eqToHom <| if_pos <| h.mem_open U.unop.1.2 U.unop.2\n      naturality := fun U V inc => by\n        change dite _ _ _ ≫ _ = _; rw [dif_pos]\n        swap -- Porting note: swap goal to prevent proving same thing twice\n        · exact h.mem_open V.unop.1.2 V.unop.2\n        · simp only [Functor.comp_obj, Functor.op_obj, skyscraperPresheaf_obj, unop_op,\n            Functor.const_obj_obj, eqToHom_trans, Functor.const_obj_map, Category.comp_id] }\n\n"}
{"name":"germ_skyscraperPresheafStalkOfSpecializes_hom","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝³ : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝² : CategoryTheory.Category.{u, v} C\nA : C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasColimits C\ny : ↑X\nh : Specializes p₀ y\nU : TopologicalSpace.Opens ↑X\nhU : Membership.mem U y\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((skyscraperPresheaf p₀ A).germ U y hU) (skyscraperPresheafStalkOfSpecializes p₀ A h).hom) (CategoryTheory.eqToHom ⋯)","decl":"@[reassoc (attr := simp)]\nlemma germ_skyscraperPresheafStalkOfSpecializes_hom [HasColimits C] {y : X} (h : p₀ ⤳ y) (U hU) :\n    (skyscraperPresheaf p₀ A).germ U y hU ≫\n      (skyscraperPresheafStalkOfSpecializes p₀ A h).hom = eqToHom (if_pos (h.mem_open U.2 hU)) :=\n  colimit.isoColimitCocone_ι_hom _ _\n\n"}
{"name":"germ_skyscraperPresheafStalkOfSpecializes_hom_assoc","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝³ : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝² : CategoryTheory.Category.{u, v} C\nA : C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasColimits C\ny : ↑X\nh✝ : Specializes p₀ y\nU : TopologicalSpace.Opens ↑X\nhU : Membership.mem U y\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((skyscraperPresheaf p₀ A).germ U y hU) (CategoryTheory.CategoryStruct.comp (skyscraperPresheafStalkOfSpecializes p₀ A h✝).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) h)","decl":"@[reassoc (attr := simp)]\nlemma germ_skyscraperPresheafStalkOfSpecializes_hom [HasColimits C] {y : X} (h : p₀ ⤳ y) (U hU) :\n    (skyscraperPresheaf p₀ A).germ U y hU ≫\n      (skyscraperPresheafStalkOfSpecializes p₀ A h).hom = eqToHom (if_pos (h.mem_open U.2 hU)) :=\n  colimit.isoColimitCocone_ι_hom _ _\n\n"}
{"name":"skyscraperPresheafCocone_ι_app","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝² : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝¹ : CategoryTheory.Category.{u, v} C\nA : C\ninst✝ : CategoryTheory.Limits.HasTerminal C\ny : ↑X\nx✝ : Opposite (TopologicalSpace.OpenNhds y)\n⊢ Eq ((skyscraperPresheafCocone p₀ A y).ι.app x✝) (CategoryTheory.Limits.terminal.from (((TopologicalSpace.OpenNhds.inclusion y).op.comp (skyscraperPresheaf p₀ A)).obj x✝))","decl":"/-- The cocone at `*` for the stalk functor of `skyscraperPresheaf p₀ A` when `y ∉ closure {p₀}`\n-/\n@[simps]\ndef skyscraperPresheafCocone (y : X) :\n    Cocone ((OpenNhds.inclusion y).op ⋙ skyscraperPresheaf p₀ A) where\n  pt := terminal C\n  ι :=\n    { app := fun _ => terminal.from _\n      naturality := fun _ _ _ => terminalIsTerminal.hom_ext _ _ }\n\n"}
{"name":"skyscraperPresheafCocone_pt","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝² : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝¹ : CategoryTheory.Category.{u, v} C\nA : C\ninst✝ : CategoryTheory.Limits.HasTerminal C\ny : ↑X\n⊢ Eq (skyscraperPresheafCocone p₀ A y).pt (CategoryTheory.Limits.terminal C)","decl":"/-- The cocone at `*` for the stalk functor of `skyscraperPresheaf p₀ A` when `y ∉ closure {p₀}`\n-/\n@[simps]\ndef skyscraperPresheafCocone (y : X) :\n    Cocone ((OpenNhds.inclusion y).op ⋙ skyscraperPresheaf p₀ A) where\n  pt := terminal C\n  ι :=\n    { app := fun _ => terminal.from _\n      naturality := fun _ _ _ => terminalIsTerminal.hom_ext _ _ }\n\n"}
{"name":"skyscraperPresheaf_isSheaf","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝² : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝¹ : CategoryTheory.Category.{u, v} C\nA : C\ninst✝ : CategoryTheory.Limits.HasTerminal C\n⊢ (skyscraperPresheaf p₀ A).IsSheaf","decl":"theorem skyscraperPresheaf_isSheaf : (skyscraperPresheaf p₀ A).IsSheaf := by\n  classical exact\n    (Presheaf.isSheaf_iso_iff (eqToIso <| skyscraperPresheaf_eq_pushforward p₀ A)).mpr <|\n      (Sheaf.pushforward_sheaf_of_sheaf _\n        (Presheaf.isSheaf_on_punit_of_isTerminal _ (by\n          dsimp [skyscraperPresheaf]\n          rw [if_neg]\n          · exact terminalIsTerminal\n          · #adaptation_note /-- 2024-03-24\n            Previously the universe annotation was not needed here. -/\n            exact Set.not_mem_empty PUnit.unit.{u+1})))\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.toSkyscraperPresheaf_app","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝³ : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝² : CategoryTheory.Category.{u, v} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasColimits C\n𝓕 : TopCat.Presheaf C X\nc : C\nf : Quiver.Hom (𝓕.stalk p₀) c\nU : Opposite (TopologicalSpace.Opens ↑X)\n⊢ Eq ((StalkSkyscraperPresheafAdjunctionAuxs.toSkyscraperPresheaf p₀ f).app U) (dite (Membership.mem (Opposite.unop U) p₀) (fun h => CategoryTheory.CategoryStruct.comp (𝓕.germ (Opposite.unop U) p₀ h) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom ⋯))) fun h => (Eq.ndrec CategoryTheory.Limits.terminalIsTerminal ⋯).from (𝓕.obj U))","decl":"/-- If `f : 𝓕.stalk p₀ ⟶ c`, then a natural transformation `𝓕 ⟶ skyscraperPresheaf p₀ c` can be\ndefined by: `𝓕.germ p₀ ≫ f : 𝓕(U) ⟶ c` if `p₀ ∈ U` and the unique morphism to a terminal object\nif `p₀ ∉ U`.\n-/\n@[simps]\ndef toSkyscraperPresheaf {𝓕 : Presheaf C X} {c : C} (f : 𝓕.stalk p₀ ⟶ c) :\n    𝓕 ⟶ skyscraperPresheaf p₀ c where\n  app U :=\n    if h : p₀ ∈ U.unop then 𝓕.germ _ p₀ h ≫ f ≫ eqToHom (if_pos h).symm\n    else ((if_neg h).symm.ndrec terminalIsTerminal).from _\n  naturality U V inc := by\n    -- Porting note: don't know why original proof fell short of working, add `aesop_cat` finished\n    -- the proofs anyway\n    dsimp\n    by_cases hV : p₀ ∈ V.unop\n    · have hU : p₀ ∈ U.unop := leOfHom inc.unop hV\n      split_ifs\n      rw [← Category.assoc, 𝓕.germ_res' inc, Category.assoc, Category.assoc, eqToHom_trans]\n    · split_ifs\n      exact ((if_neg hV).symm.ndrec terminalIsTerminal).hom_ext ..\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.germ_fromStalk","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝³ : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝² : CategoryTheory.Category.{u, v} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasColimits C\n𝓕 : TopCat.Presheaf C X\nc : C\nf : Quiver.Hom 𝓕 (skyscraperPresheaf p₀ c)\nU : TopologicalSpace.Opens ↑X\nhU : Membership.mem U p₀\n⊢ Eq (CategoryTheory.CategoryStruct.comp (𝓕.germ U p₀ hU) (StalkSkyscraperPresheafAdjunctionAuxs.fromStalk p₀ f)) (CategoryTheory.CategoryStruct.comp (f.app { unop := U }) (CategoryTheory.eqToHom ⋯))","decl":"@[reassoc (attr := simp)]\nlemma germ_fromStalk {𝓕 : Presheaf C X} {c : C} (f : 𝓕 ⟶ skyscraperPresheaf p₀ c) (U) (hU) :\n    𝓕.germ U p₀ hU ≫ fromStalk p₀ f = f.app (op U) ≫ eqToHom (if_pos hU) :=\n  colimit.ι_desc _ _\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.germ_fromStalk_assoc","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝³ : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝² : CategoryTheory.Category.{u, v} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasColimits C\n𝓕 : TopCat.Presheaf C X\nc : C\nf : Quiver.Hom 𝓕 (skyscraperPresheaf p₀ c)\nU : TopologicalSpace.Opens ↑X\nhU : Membership.mem U p₀\nZ : C\nh : Quiver.Hom c Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (𝓕.germ U p₀ hU) (CategoryTheory.CategoryStruct.comp (StalkSkyscraperPresheafAdjunctionAuxs.fromStalk p₀ f) h)) (CategoryTheory.CategoryStruct.comp (f.app { unop := U }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) h))","decl":"@[reassoc (attr := simp)]\nlemma germ_fromStalk {𝓕 : Presheaf C X} {c : C} (f : 𝓕 ⟶ skyscraperPresheaf p₀ c) (U) (hU) :\n    𝓕.germ U p₀ hU ≫ fromStalk p₀ f = f.app (op U) ≫ eqToHom (if_pos hU) :=\n  colimit.ι_desc _ _\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.to_skyscraper_fromStalk","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝³ : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝² : CategoryTheory.Category.{u, v} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasColimits C\n𝓕 : TopCat.Presheaf C X\nc : C\nf : Quiver.Hom 𝓕 (skyscraperPresheaf p₀ c)\n⊢ Eq (StalkSkyscraperPresheafAdjunctionAuxs.toSkyscraperPresheaf p₀ (StalkSkyscraperPresheafAdjunctionAuxs.fromStalk p₀ f)) f","decl":"theorem to_skyscraper_fromStalk {𝓕 : Presheaf C X} {c : C} (f : 𝓕 ⟶ skyscraperPresheaf p₀ c) :\n    toSkyscraperPresheaf p₀ (fromStalk _ f) = f := by\n  apply NatTrans.ext\n  ext U\n  dsimp\n  split_ifs with h\n  · rw [← Category.assoc, germ_fromStalk, Category.assoc, eqToHom_trans, eqToHom_refl,\n      Category.comp_id]\n  · exact ((if_neg h).symm.ndrec terminalIsTerminal).hom_ext ..\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.fromStalk_to_skyscraper","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝³ : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝² : CategoryTheory.Category.{u, v} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasColimits C\n𝓕 : TopCat.Presheaf C X\nc : C\nf : Quiver.Hom (𝓕.stalk p₀) c\n⊢ Eq (StalkSkyscraperPresheafAdjunctionAuxs.fromStalk p₀ (StalkSkyscraperPresheafAdjunctionAuxs.toSkyscraperPresheaf p₀ f)) f","decl":"theorem fromStalk_to_skyscraper {𝓕 : Presheaf C X} {c : C} (f : 𝓕.stalk p₀ ⟶ c) :\n    fromStalk p₀ (toSkyscraperPresheaf _ f) = f := by\n  refine 𝓕.stalk_hom_ext fun U hxU ↦ ?_\n  rw [germ_fromStalk, toSkyscraperPresheaf_app, dif_pos hxU, Category.assoc, Category.assoc,\n    eqToHom_trans, eqToHom_refl, Category.comp_id, Presheaf.germ]\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.unit_app","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝³ : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝² : CategoryTheory.Category.{u, v} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasColimits C\nx✝ : TopCat.Presheaf C X\n⊢ Eq ((StalkSkyscraperPresheafAdjunctionAuxs.unit p₀).app x✝) (StalkSkyscraperPresheafAdjunctionAuxs.toSkyscraperPresheaf p₀ (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.id (TopCat.Presheaf C X)).obj x✝).stalk p₀)))","decl":"/-- The unit in `Presheaf.stalkFunctor ⊣ skyscraperPresheafFunctor`\n-/\n@[simps]\nprotected def unit :\n    𝟭 (Presheaf C X) ⟶ Presheaf.stalkFunctor C p₀ ⋙ skyscraperPresheafFunctor p₀ where\n  app _ := toSkyscraperPresheaf _ <| 𝟙 _\n  naturality 𝓕 𝓖 f := by\n    ext U; dsimp\n    split_ifs with h\n    · simp only [Category.id_comp, Category.assoc, eqToHom_trans_assoc, eqToHom_refl,\n        Presheaf.stalkFunctor_map_germ_assoc, Presheaf.stalkFunctor_obj]\n    · apply ((if_neg h).symm.ndrec terminalIsTerminal).hom_ext\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.counit_app","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝³ : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝² : CategoryTheory.Category.{u, v} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasColimits C\nc : C\n⊢ Eq ((StalkSkyscraperPresheafAdjunctionAuxs.counit p₀).app c) (skyscraperPresheafStalkOfSpecializes p₀ c ⋯).hom","decl":"/-- The counit in `Presheaf.stalkFunctor ⊣ skyscraperPresheafFunctor`\n-/\n@[simps]\nprotected def counit :\n    skyscraperPresheafFunctor p₀ ⋙ (Presheaf.stalkFunctor C p₀ : Presheaf C X ⥤ C) ⟶ 𝟭 C where\n  app c := (skyscraperPresheafStalkOfSpecializes p₀ c specializes_rfl).hom\n  naturality x y f := TopCat.Presheaf.stalk_hom_ext _ fun U hxU ↦ by simp [hxU]\n\n"}
{"name":"instIsRightAdjointPresheafSkyscraperPresheafFunctorOfHasColimits","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝³ : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝² : CategoryTheory.Category.{u, v} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasColimits C\n⊢ (skyscraperPresheafFunctor p₀).IsRightAdjoint","decl":"instance [HasColimits C] : (skyscraperPresheafFunctor p₀ : C ⥤ Presheaf C X).IsRightAdjoint  :=\n  (skyscraperPresheafStalkAdjunction _).isRightAdjoint\n\n"}
{"name":"instIsLeftAdjointPresheafStalkFunctor","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\nC : Type v\ninst✝² : CategoryTheory.Category.{u, v} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasColimits C\n⊢ (TopCat.Presheaf.stalkFunctor C p₀).IsLeftAdjoint","decl":"instance [HasColimits C] : (Presheaf.stalkFunctor C p₀).IsLeftAdjoint  :=\n  -- Use a classical instance instead of the one from `variable`s\n  have : ∀ U : Opens X, Decidable (p₀ ∈ U) := fun _ ↦ Classical.dec _\n  (skyscraperPresheafStalkAdjunction _).isLeftAdjoint\n\n"}
{"name":"instIsRightAdjointSheafSkyscraperSheafFunctorOfHasColimits","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\np₀ : ↑X\ninst✝³ : (U : TopologicalSpace.Opens ↑X) → Decidable (Membership.mem U p₀)\nC : Type v\ninst✝² : CategoryTheory.Category.{u, v} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasColimits C\n⊢ (skyscraperSheafFunctor p₀).IsRightAdjoint","decl":"instance [HasColimits C] : (skyscraperSheafFunctor p₀ : C ⥤ Sheaf C X).IsRightAdjoint  :=\n  (stalkSkyscraperSheafAdjunction _).isRightAdjoint\n\n"}
