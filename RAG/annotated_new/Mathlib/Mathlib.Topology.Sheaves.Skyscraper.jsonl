{"name":"skyscraperPresheaf_map","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ² : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ¹ : CategoryTheory.Category.{w, v} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nA : C\nU V : Opposite (TopologicalSpace.Opens â†‘X)\ni : Quiver.Hom U V\nâŠ¢ Eq ((skyscraperPresheaf pâ‚€ A).map i) (dite (Membership.mem (Opposite.unop V) pâ‚€) (fun h => CategoryTheory.eqToHom â‹¯) fun h => (Eq.ndrec CategoryTheory.Limits.terminalIsTerminal â‹¯).from ((fun U => ite (Membership.mem (Opposite.unop U) pâ‚€) A (CategoryTheory.Limits.terminal C)) U))","decl":"/-- A skyscraper presheaf is a presheaf supported at a single point: if `pâ‚€ âˆˆ X` is a specified\npoint, then the skyscraper presheaf `ğ“•` with value `A` is defined by `U â†¦ A` if `pâ‚€ âˆˆ U` and\n`U â†¦ *` if `pâ‚€ âˆ‰ A` where `*` is some terminal object.\n-/\n@[simps]\ndef skyscraperPresheaf : Presheaf C X where\n  obj U := if pâ‚€ âˆˆ unop U then A else terminal C\n  map {U V} i :=\n    if h : pâ‚€ âˆˆ unop V then eqToHom <| by dsimp; rw [if_pos h, if_pos (by simpa using i.unop.le h)]\n    else ((if_neg h).symm.ndrec terminalIsTerminal).from _\n  map_id U :=\n    (em (pâ‚€ âˆˆ U.unop)).elim (fun h => dif_pos h) fun h =>\n      ((if_neg h).symm.ndrec terminalIsTerminal).hom_ext _ _\n  map_comp {U V W} iVU iWV := by\n    by_cases hW : pâ‚€ âˆˆ unop W\n    Â· have hV : pâ‚€ âˆˆ unop V := leOfHom iWV.unop hW\n      simp only [dif_pos hW, dif_pos hV, eqToHom_trans]\n    Â· dsimp; rw [dif_neg hW]; apply ((if_neg hW).symm.ndrec terminalIsTerminal).hom_ext\n\n"}
{"name":"skyscraperPresheaf_obj","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ² : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ¹ : CategoryTheory.Category.{w, v} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nA : C\nU : Opposite (TopologicalSpace.Opens â†‘X)\nâŠ¢ Eq ((skyscraperPresheaf pâ‚€ A).obj U) (ite (Membership.mem (Opposite.unop U) pâ‚€) A (CategoryTheory.Limits.terminal C))","decl":"/-- A skyscraper presheaf is a presheaf supported at a single point: if `pâ‚€ âˆˆ X` is a specified\npoint, then the skyscraper presheaf `ğ“•` with value `A` is defined by `U â†¦ A` if `pâ‚€ âˆˆ U` and\n`U â†¦ *` if `pâ‚€ âˆ‰ A` where `*` is some terminal object.\n-/\n@[simps]\ndef skyscraperPresheaf : Presheaf C X where\n  obj U := if pâ‚€ âˆˆ unop U then A else terminal C\n  map {U V} i :=\n    if h : pâ‚€ âˆˆ unop V then eqToHom <| by dsimp; rw [if_pos h, if_pos (by simpa using i.unop.le h)]\n    else ((if_neg h).symm.ndrec terminalIsTerminal).from _\n  map_id U :=\n    (em (pâ‚€ âˆˆ U.unop)).elim (fun h => dif_pos h) fun h =>\n      ((if_neg h).symm.ndrec terminalIsTerminal).hom_ext _ _\n  map_comp {U V W} iVU iWV := by\n    by_cases hW : pâ‚€ âˆˆ unop W\n    Â· have hV : pâ‚€ âˆˆ unop V := leOfHom iWV.unop hW\n      simp only [dif_pos hW, dif_pos hV, eqToHom_trans]\n    Â· dsimp; rw [dif_neg hW]; apply ((if_neg hW).symm.ndrec terminalIsTerminal).hom_ext\n\n"}
{"name":"skyscraperPresheaf_eq_pushforward","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ² : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ¹ : CategoryTheory.Category.{w, v} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nA : C\nhd : (U : TopologicalSpace.Opens â†‘(TopCat.of PUnit.{u + 1})) â†’ Decidable (Membership.mem U PUnit.unit)\nâŠ¢ Eq (skyscraperPresheaf pâ‚€ A) ((TopCat.Presheaf.pushforward C (ContinuousMap.const (â†‘(TopCat.of PUnit.{u + 1})) pâ‚€)).obj (skyscraperPresheaf PUnit.unit A))","decl":"theorem skyscraperPresheaf_eq_pushforward\n    [hd : âˆ€ U : Opens (TopCat.of PUnit.{u + 1}), Decidable (PUnit.unit âˆˆ U)] :\n    skyscraperPresheaf pâ‚€ A =\n      ContinuousMap.const (TopCat.of PUnit) pâ‚€ _*\n        skyscraperPresheaf (X := TopCat.of PUnit) PUnit.unit A := by\n  convert_to @skyscraperPresheaf X pâ‚€ (fun U => hd <| (Opens.map <| ContinuousMap.const _ pâ‚€).obj U)\n    C _ _ A = _ <;> congr\n\n"}
{"name":"SkyscraperPresheafFunctor.map'_app","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ² : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ¹ : CategoryTheory.Category.{w, v} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\na b : C\nf : Quiver.Hom a b\nU : Opposite (TopologicalSpace.Opens â†‘X)\nâŠ¢ Eq ((SkyscraperPresheafFunctor.map' pâ‚€ f).app U) (dite (Membership.mem (Opposite.unop U) pâ‚€) (fun h => CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom â‹¯))) fun h => (Eq.ndrec CategoryTheory.Limits.terminalIsTerminal â‹¯).from ((skyscraperPresheaf pâ‚€ a).obj U))","decl":"/-- Taking skyscraper presheaf at a point is functorial: `c â†¦ skyscraper pâ‚€ c` defines a functor by\nsending every `f : a âŸ¶ b` to the natural transformation `Î±` defined as: `Î±(U) = f : a âŸ¶ b` if\n`pâ‚€ âˆˆ U` and the unique morphism to a terminal object in `C` if `pâ‚€ âˆ‰ U`.\n-/\n@[simps]\ndef SkyscraperPresheafFunctor.map' {a b : C} (f : a âŸ¶ b) :\n    skyscraperPresheaf pâ‚€ a âŸ¶ skyscraperPresheaf pâ‚€ b where\n  app U :=\n    if h : pâ‚€ âˆˆ U.unop then eqToHom (if_pos h) â‰« f â‰« eqToHom (if_pos h).symm\n    else ((if_neg h).symm.ndrec terminalIsTerminal).from _\n  naturality U V i := by\n    simp only [skyscraperPresheaf_map]\n    by_cases hV : pâ‚€ âˆˆ V.unop\n    Â· have hU : pâ‚€ âˆˆ U.unop := leOfHom i.unop hV\n      simp only [skyscraperPresheaf_obj, hU, hV, â†“reduceDIte, eqToHom_trans_assoc, Category.assoc,\n        eqToHom_trans]\n    Â· apply ((if_neg hV).symm.ndrec terminalIsTerminal).hom_ext\n\n"}
{"name":"SkyscraperPresheafFunctor.map'_id","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ² : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ¹ : CategoryTheory.Category.{w, v} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\na : C\nâŠ¢ Eq (SkyscraperPresheafFunctor.map' pâ‚€ (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (skyscraperPresheaf pâ‚€ a))","decl":"theorem SkyscraperPresheafFunctor.map'_id {a : C} :\n    SkyscraperPresheafFunctor.map' pâ‚€ (ğŸ™ a) = ğŸ™ _ := by\n  ext U\n  simp only [SkyscraperPresheafFunctor.map'_app, NatTrans.id_app]; split_ifs <;> aesop_cat\n\n"}
{"name":"SkyscraperPresheafFunctor.map'_comp","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ² : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ¹ : CategoryTheory.Category.{w, v} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\na b c : C\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nâŠ¢ Eq (SkyscraperPresheafFunctor.map' pâ‚€ (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (SkyscraperPresheafFunctor.map' pâ‚€ f) (SkyscraperPresheafFunctor.map' pâ‚€ g))","decl":"theorem SkyscraperPresheafFunctor.map'_comp {a b c : C} (f : a âŸ¶ b) (g : b âŸ¶ c) :\n    SkyscraperPresheafFunctor.map' pâ‚€ (f â‰« g) =\n      SkyscraperPresheafFunctor.map' pâ‚€ f â‰« SkyscraperPresheafFunctor.map' pâ‚€ g := by\n  ext U\n  simp only [SkyscraperPresheafFunctor.map'_app, NatTrans.comp_app]\n  split_ifs with h <;> aesop_cat\n\n"}
{"name":"skyscraperPresheafFunctor_obj","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ² : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ¹ : CategoryTheory.Category.{w, v} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nA : C\nâŠ¢ Eq ((skyscraperPresheafFunctor pâ‚€).obj A) (skyscraperPresheaf pâ‚€ A)","decl":"/-- Taking skyscraper presheaf at a point is functorial: `c â†¦ skyscraper pâ‚€ c` defines a functor by\nsending every `f : a âŸ¶ b` to the natural transformation `Î±` defined as: `Î±(U) = f : a âŸ¶ b` if\n`pâ‚€ âˆˆ U` and the unique morphism to a terminal object in `C` if `pâ‚€ âˆ‰ U`.\n-/\n@[simps]\ndef skyscraperPresheafFunctor : C â¥¤ Presheaf C X where\n  obj := skyscraperPresheaf pâ‚€\n  map := SkyscraperPresheafFunctor.map' pâ‚€\n  map_id _ := SkyscraperPresheafFunctor.map'_id pâ‚€\n  map_comp := SkyscraperPresheafFunctor.map'_comp pâ‚€\n\n"}
{"name":"skyscraperPresheafFunctor_map","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ² : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ¹ : CategoryTheory.Category.{w, v} C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nXâœ Yâœ : C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((skyscraperPresheafFunctor pâ‚€).map f) (SkyscraperPresheafFunctor.map' pâ‚€ f)","decl":"/-- Taking skyscraper presheaf at a point is functorial: `c â†¦ skyscraper pâ‚€ c` defines a functor by\nsending every `f : a âŸ¶ b` to the natural transformation `Î±` defined as: `Î±(U) = f : a âŸ¶ b` if\n`pâ‚€ âˆˆ U` and the unique morphism to a terminal object in `C` if `pâ‚€ âˆ‰ U`.\n-/\n@[simps]\ndef skyscraperPresheafFunctor : C â¥¤ Presheaf C X where\n  obj := skyscraperPresheaf pâ‚€\n  map := SkyscraperPresheafFunctor.map' pâ‚€\n  map_id _ := SkyscraperPresheafFunctor.map'_id pâ‚€\n  map_comp := SkyscraperPresheafFunctor.map'_comp pâ‚€\n\n"}
{"name":"skyscraperPresheafCoconeOfSpecializes_Î¹_app","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ² : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ¹ : CategoryTheory.Category.{u, v} C\nA : C\ninstâœ : CategoryTheory.Limits.HasTerminal C\ny : â†‘X\nh : Specializes pâ‚€ y\nU : Opposite (TopologicalSpace.OpenNhds y)\nâŠ¢ Eq ((skyscraperPresheafCoconeOfSpecializes pâ‚€ A h).Î¹.app U) (CategoryTheory.eqToHom â‹¯)","decl":"/-- The cocone at `A` for the stalk functor of `skyscraperPresheaf pâ‚€ A` when `y âˆˆ closure {pâ‚€}`\n-/\n@[simps]\ndef skyscraperPresheafCoconeOfSpecializes {y : X} (h : pâ‚€ â¤³ y) :\n    Cocone ((OpenNhds.inclusion y).op â‹™ skyscraperPresheaf pâ‚€ A) where\n  pt := A\n  Î¹ :=\n    { app := fun U => eqToHom <| if_pos <| h.mem_open U.unop.1.2 U.unop.2\n      naturality := fun U V inc => by\n        change dite _ _ _ â‰« _ = _; rw [dif_pos]\n        swap -- Porting note: swap goal to prevent proving same thing twice\n        Â· exact h.mem_open V.unop.1.2 V.unop.2\n        Â· simp only [Functor.comp_obj, Functor.op_obj, skyscraperPresheaf_obj, unop_op,\n            Functor.const_obj_obj, eqToHom_trans, Functor.const_obj_map, Category.comp_id] }\n\n"}
{"name":"skyscraperPresheafCoconeOfSpecializes_pt","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ² : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ¹ : CategoryTheory.Category.{u, v} C\nA : C\ninstâœ : CategoryTheory.Limits.HasTerminal C\ny : â†‘X\nh : Specializes pâ‚€ y\nâŠ¢ Eq (skyscraperPresheafCoconeOfSpecializes pâ‚€ A h).pt A","decl":"/-- The cocone at `A` for the stalk functor of `skyscraperPresheaf pâ‚€ A` when `y âˆˆ closure {pâ‚€}`\n-/\n@[simps]\ndef skyscraperPresheafCoconeOfSpecializes {y : X} (h : pâ‚€ â¤³ y) :\n    Cocone ((OpenNhds.inclusion y).op â‹™ skyscraperPresheaf pâ‚€ A) where\n  pt := A\n  Î¹ :=\n    { app := fun U => eqToHom <| if_pos <| h.mem_open U.unop.1.2 U.unop.2\n      naturality := fun U V inc => by\n        change dite _ _ _ â‰« _ = _; rw [dif_pos]\n        swap -- Porting note: swap goal to prevent proving same thing twice\n        Â· exact h.mem_open V.unop.1.2 V.unop.2\n        Â· simp only [Functor.comp_obj, Functor.op_obj, skyscraperPresheaf_obj, unop_op,\n            Functor.const_obj_obj, eqToHom_trans, Functor.const_obj_map, Category.comp_id] }\n\n"}
{"name":"germ_skyscraperPresheafStalkOfSpecializes_hom","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ³ : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ² : CategoryTheory.Category.{u, v} C\nA : C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasColimits C\ny : â†‘X\nh : Specializes pâ‚€ y\nU : TopologicalSpace.Opens â†‘X\nhU : Membership.mem U y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((skyscraperPresheaf pâ‚€ A).germ U y hU) (skyscraperPresheafStalkOfSpecializes pâ‚€ A h).hom) (CategoryTheory.eqToHom â‹¯)","decl":"@[reassoc (attr := simp)]\nlemma germ_skyscraperPresheafStalkOfSpecializes_hom [HasColimits C] {y : X} (h : pâ‚€ â¤³ y) (U hU) :\n    (skyscraperPresheaf pâ‚€ A).germ U y hU â‰«\n      (skyscraperPresheafStalkOfSpecializes pâ‚€ A h).hom = eqToHom (if_pos (h.mem_open U.2 hU)) :=\n  colimit.isoColimitCocone_Î¹_hom _ _\n\n"}
{"name":"germ_skyscraperPresheafStalkOfSpecializes_hom_assoc","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ³ : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ² : CategoryTheory.Category.{u, v} C\nA : C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasColimits C\ny : â†‘X\nhâœ : Specializes pâ‚€ y\nU : TopologicalSpace.Opens â†‘X\nhU : Membership.mem U y\nZ : C\nh : Quiver.Hom A Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((skyscraperPresheaf pâ‚€ A).germ U y hU) (CategoryTheory.CategoryStruct.comp (skyscraperPresheafStalkOfSpecializes pâ‚€ A hâœ).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) h)","decl":"@[reassoc (attr := simp)]\nlemma germ_skyscraperPresheafStalkOfSpecializes_hom [HasColimits C] {y : X} (h : pâ‚€ â¤³ y) (U hU) :\n    (skyscraperPresheaf pâ‚€ A).germ U y hU â‰«\n      (skyscraperPresheafStalkOfSpecializes pâ‚€ A h).hom = eqToHom (if_pos (h.mem_open U.2 hU)) :=\n  colimit.isoColimitCocone_Î¹_hom _ _\n\n"}
{"name":"skyscraperPresheafCocone_Î¹_app","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ² : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ¹ : CategoryTheory.Category.{u, v} C\nA : C\ninstâœ : CategoryTheory.Limits.HasTerminal C\ny : â†‘X\nxâœ : Opposite (TopologicalSpace.OpenNhds y)\nâŠ¢ Eq ((skyscraperPresheafCocone pâ‚€ A y).Î¹.app xâœ) (CategoryTheory.Limits.terminal.from (((TopologicalSpace.OpenNhds.inclusion y).op.comp (skyscraperPresheaf pâ‚€ A)).obj xâœ))","decl":"/-- The cocone at `*` for the stalk functor of `skyscraperPresheaf pâ‚€ A` when `y âˆ‰ closure {pâ‚€}`\n-/\n@[simps]\ndef skyscraperPresheafCocone (y : X) :\n    Cocone ((OpenNhds.inclusion y).op â‹™ skyscraperPresheaf pâ‚€ A) where\n  pt := terminal C\n  Î¹ :=\n    { app := fun _ => terminal.from _\n      naturality := fun _ _ _ => terminalIsTerminal.hom_ext _ _ }\n\n"}
{"name":"skyscraperPresheafCocone_pt","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ² : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ¹ : CategoryTheory.Category.{u, v} C\nA : C\ninstâœ : CategoryTheory.Limits.HasTerminal C\ny : â†‘X\nâŠ¢ Eq (skyscraperPresheafCocone pâ‚€ A y).pt (CategoryTheory.Limits.terminal C)","decl":"/-- The cocone at `*` for the stalk functor of `skyscraperPresheaf pâ‚€ A` when `y âˆ‰ closure {pâ‚€}`\n-/\n@[simps]\ndef skyscraperPresheafCocone (y : X) :\n    Cocone ((OpenNhds.inclusion y).op â‹™ skyscraperPresheaf pâ‚€ A) where\n  pt := terminal C\n  Î¹ :=\n    { app := fun _ => terminal.from _\n      naturality := fun _ _ _ => terminalIsTerminal.hom_ext _ _ }\n\n"}
{"name":"skyscraperPresheaf_isSheaf","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ² : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ¹ : CategoryTheory.Category.{u, v} C\nA : C\ninstâœ : CategoryTheory.Limits.HasTerminal C\nâŠ¢ (skyscraperPresheaf pâ‚€ A).IsSheaf","decl":"theorem skyscraperPresheaf_isSheaf : (skyscraperPresheaf pâ‚€ A).IsSheaf := by\n  classical exact\n    (Presheaf.isSheaf_iso_iff (eqToIso <| skyscraperPresheaf_eq_pushforward pâ‚€ A)).mpr <|\n      (Sheaf.pushforward_sheaf_of_sheaf _\n        (Presheaf.isSheaf_on_punit_of_isTerminal _ (by\n          dsimp [skyscraperPresheaf]\n          rw [if_neg]\n          Â· exact terminalIsTerminal\n          Â· #adaptation_note /-- 2024-03-24\n            Previously the universe annotation was not needed here. -/\n            exact Set.not_mem_empty PUnit.unit.{u+1})))\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.toSkyscraperPresheaf_app","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ³ : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ² : CategoryTheory.Category.{u, v} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasColimits C\nğ“• : TopCat.Presheaf C X\nc : C\nf : Quiver.Hom (ğ“•.stalk pâ‚€) c\nU : Opposite (TopologicalSpace.Opens â†‘X)\nâŠ¢ Eq ((StalkSkyscraperPresheafAdjunctionAuxs.toSkyscraperPresheaf pâ‚€ f).app U) (dite (Membership.mem (Opposite.unop U) pâ‚€) (fun h => CategoryTheory.CategoryStruct.comp (ğ“•.germ (Opposite.unop U) pâ‚€ h) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom â‹¯))) fun h => (Eq.ndrec CategoryTheory.Limits.terminalIsTerminal â‹¯).from (ğ“•.obj U))","decl":"/-- If `f : ğ“•.stalk pâ‚€ âŸ¶ c`, then a natural transformation `ğ“• âŸ¶ skyscraperPresheaf pâ‚€ c` can be\ndefined by: `ğ“•.germ pâ‚€ â‰« f : ğ“•(U) âŸ¶ c` if `pâ‚€ âˆˆ U` and the unique morphism to a terminal object\nif `pâ‚€ âˆ‰ U`.\n-/\n@[simps]\ndef toSkyscraperPresheaf {ğ“• : Presheaf C X} {c : C} (f : ğ“•.stalk pâ‚€ âŸ¶ c) :\n    ğ“• âŸ¶ skyscraperPresheaf pâ‚€ c where\n  app U :=\n    if h : pâ‚€ âˆˆ U.unop then ğ“•.germ _ pâ‚€ h â‰« f â‰« eqToHom (if_pos h).symm\n    else ((if_neg h).symm.ndrec terminalIsTerminal).from _\n  naturality U V inc := by\n    -- Porting note: don't know why original proof fell short of working, add `aesop_cat` finished\n    -- the proofs anyway\n    dsimp\n    by_cases hV : pâ‚€ âˆˆ V.unop\n    Â· have hU : pâ‚€ âˆˆ U.unop := leOfHom inc.unop hV\n      split_ifs\n      rw [â† Category.assoc, ğ“•.germ_res' inc, Category.assoc, Category.assoc, eqToHom_trans]\n    Â· split_ifs\n      exact ((if_neg hV).symm.ndrec terminalIsTerminal).hom_ext ..\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.germ_fromStalk","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ³ : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ² : CategoryTheory.Category.{u, v} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasColimits C\nğ“• : TopCat.Presheaf C X\nc : C\nf : Quiver.Hom ğ“• (skyscraperPresheaf pâ‚€ c)\nU : TopologicalSpace.Opens â†‘X\nhU : Membership.mem U pâ‚€\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (ğ“•.germ U pâ‚€ hU) (StalkSkyscraperPresheafAdjunctionAuxs.fromStalk pâ‚€ f)) (CategoryTheory.CategoryStruct.comp (f.app { unop := U }) (CategoryTheory.eqToHom â‹¯))","decl":"@[reassoc (attr := simp)]\nlemma germ_fromStalk {ğ“• : Presheaf C X} {c : C} (f : ğ“• âŸ¶ skyscraperPresheaf pâ‚€ c) (U) (hU) :\n    ğ“•.germ U pâ‚€ hU â‰« fromStalk pâ‚€ f = f.app (op U) â‰« eqToHom (if_pos hU) :=\n  colimit.Î¹_desc _ _\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.germ_fromStalk_assoc","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ³ : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ² : CategoryTheory.Category.{u, v} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasColimits C\nğ“• : TopCat.Presheaf C X\nc : C\nf : Quiver.Hom ğ“• (skyscraperPresheaf pâ‚€ c)\nU : TopologicalSpace.Opens â†‘X\nhU : Membership.mem U pâ‚€\nZ : C\nh : Quiver.Hom c Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (ğ“•.germ U pâ‚€ hU) (CategoryTheory.CategoryStruct.comp (StalkSkyscraperPresheafAdjunctionAuxs.fromStalk pâ‚€ f) h)) (CategoryTheory.CategoryStruct.comp (f.app { unop := U }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom â‹¯) h))","decl":"@[reassoc (attr := simp)]\nlemma germ_fromStalk {ğ“• : Presheaf C X} {c : C} (f : ğ“• âŸ¶ skyscraperPresheaf pâ‚€ c) (U) (hU) :\n    ğ“•.germ U pâ‚€ hU â‰« fromStalk pâ‚€ f = f.app (op U) â‰« eqToHom (if_pos hU) :=\n  colimit.Î¹_desc _ _\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.to_skyscraper_fromStalk","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ³ : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ² : CategoryTheory.Category.{u, v} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasColimits C\nğ“• : TopCat.Presheaf C X\nc : C\nf : Quiver.Hom ğ“• (skyscraperPresheaf pâ‚€ c)\nâŠ¢ Eq (StalkSkyscraperPresheafAdjunctionAuxs.toSkyscraperPresheaf pâ‚€ (StalkSkyscraperPresheafAdjunctionAuxs.fromStalk pâ‚€ f)) f","decl":"theorem to_skyscraper_fromStalk {ğ“• : Presheaf C X} {c : C} (f : ğ“• âŸ¶ skyscraperPresheaf pâ‚€ c) :\n    toSkyscraperPresheaf pâ‚€ (fromStalk _ f) = f := by\n  apply NatTrans.ext\n  ext U\n  dsimp\n  split_ifs with h\n  Â· rw [â† Category.assoc, germ_fromStalk, Category.assoc, eqToHom_trans, eqToHom_refl,\n      Category.comp_id]\n  Â· exact ((if_neg h).symm.ndrec terminalIsTerminal).hom_ext ..\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.fromStalk_to_skyscraper","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ³ : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ² : CategoryTheory.Category.{u, v} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasColimits C\nğ“• : TopCat.Presheaf C X\nc : C\nf : Quiver.Hom (ğ“•.stalk pâ‚€) c\nâŠ¢ Eq (StalkSkyscraperPresheafAdjunctionAuxs.fromStalk pâ‚€ (StalkSkyscraperPresheafAdjunctionAuxs.toSkyscraperPresheaf pâ‚€ f)) f","decl":"theorem fromStalk_to_skyscraper {ğ“• : Presheaf C X} {c : C} (f : ğ“•.stalk pâ‚€ âŸ¶ c) :\n    fromStalk pâ‚€ (toSkyscraperPresheaf _ f) = f := by\n  refine ğ“•.stalk_hom_ext fun U hxU â†¦ ?_\n  rw [germ_fromStalk, toSkyscraperPresheaf_app, dif_pos hxU, Category.assoc, Category.assoc,\n    eqToHom_trans, eqToHom_refl, Category.comp_id, Presheaf.germ]\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.unit_app","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ³ : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ² : CategoryTheory.Category.{u, v} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasColimits C\nxâœ : TopCat.Presheaf C X\nâŠ¢ Eq ((StalkSkyscraperPresheafAdjunctionAuxs.unit pâ‚€).app xâœ) (StalkSkyscraperPresheafAdjunctionAuxs.toSkyscraperPresheaf pâ‚€ (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.id (TopCat.Presheaf C X)).obj xâœ).stalk pâ‚€)))","decl":"/-- The unit in `Presheaf.stalkFunctor âŠ£ skyscraperPresheafFunctor`\n-/\n@[simps]\nprotected def unit :\n    ğŸ­ (Presheaf C X) âŸ¶ Presheaf.stalkFunctor C pâ‚€ â‹™ skyscraperPresheafFunctor pâ‚€ where\n  app _ := toSkyscraperPresheaf _ <| ğŸ™ _\n  naturality ğ“• ğ“– f := by\n    ext U; dsimp\n    split_ifs with h\n    Â· simp only [Category.id_comp, Category.assoc, eqToHom_trans_assoc, eqToHom_refl,\n        Presheaf.stalkFunctor_map_germ_assoc, Presheaf.stalkFunctor_obj]\n    Â· apply ((if_neg h).symm.ndrec terminalIsTerminal).hom_ext\n\n"}
{"name":"StalkSkyscraperPresheafAdjunctionAuxs.counit_app","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ³ : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ² : CategoryTheory.Category.{u, v} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasColimits C\nc : C\nâŠ¢ Eq ((StalkSkyscraperPresheafAdjunctionAuxs.counit pâ‚€).app c) (skyscraperPresheafStalkOfSpecializes pâ‚€ c â‹¯).hom","decl":"/-- The counit in `Presheaf.stalkFunctor âŠ£ skyscraperPresheafFunctor`\n-/\n@[simps]\nprotected def counit :\n    skyscraperPresheafFunctor pâ‚€ â‹™ (Presheaf.stalkFunctor C pâ‚€ : Presheaf C X â¥¤ C) âŸ¶ ğŸ­ C where\n  app c := (skyscraperPresheafStalkOfSpecializes pâ‚€ c specializes_rfl).hom\n  naturality x y f := TopCat.Presheaf.stalk_hom_ext _ fun U hxU â†¦ by simp [hxU]\n\n"}
{"name":"instIsRightAdjointPresheafSkyscraperPresheafFunctorOfHasColimits","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ³ : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ² : CategoryTheory.Category.{u, v} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasColimits C\nâŠ¢ (skyscraperPresheafFunctor pâ‚€).IsRightAdjoint","decl":"instance [HasColimits C] : (skyscraperPresheafFunctor pâ‚€ : C â¥¤ Presheaf C X).IsRightAdjoint  :=\n  (skyscraperPresheafStalkAdjunction _).isRightAdjoint\n\n"}
{"name":"instIsLeftAdjointPresheafStalkFunctor","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\nC : Type v\ninstâœÂ² : CategoryTheory.Category.{u, v} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasColimits C\nâŠ¢ (TopCat.Presheaf.stalkFunctor C pâ‚€).IsLeftAdjoint","decl":"instance [HasColimits C] : (Presheaf.stalkFunctor C pâ‚€).IsLeftAdjoint  :=\n  -- Use a classical instance instead of the one from `variable`s\n  have : âˆ€ U : Opens X, Decidable (pâ‚€ âˆˆ U) := fun _ â†¦ Classical.dec _\n  (skyscraperPresheafStalkAdjunction _).isLeftAdjoint\n\n"}
{"name":"instIsRightAdjointSheafSkyscraperSheafFunctorOfHasColimits","module":"Mathlib.Topology.Sheaves.Skyscraper","initialProofState":"X : TopCat\npâ‚€ : â†‘X\ninstâœÂ³ : (U : TopologicalSpace.Opens â†‘X) â†’ Decidable (Membership.mem U pâ‚€)\nC : Type v\ninstâœÂ² : CategoryTheory.Category.{u, v} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasColimits C\nâŠ¢ (skyscraperSheafFunctor pâ‚€).IsRightAdjoint","decl":"instance [HasColimits C] : (skyscraperSheafFunctor pâ‚€ : C â¥¤ Sheaf C X).IsRightAdjoint  :=\n  (stalkSkyscraperSheafAdjunction _).isRightAdjoint\n\n"}
