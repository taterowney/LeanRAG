{"name":"CircularPreorder.sbtw_trans_left","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\nself : CircularPreorder α\na b c d : α\na✝¹ : SBtw.sbtw a b c\na✝ : SBtw.sbtw b d c\n⊢ SBtw.sbtw a d c","decl":"/-- A circular preorder is the analogue of a preorder where you can loop around. `≤` and `<` are\nreplaced by ternary relations `btw` and `sbtw`. `btw` is reflexive and cyclic. `sbtw` is transitive.\n-/\nclass CircularPreorder (α : Type*) extends Btw α, SBtw α where\n  /-- `a` is between `a` and `a`. -/\n  btw_refl (a : α) : btw a a a\n  /-- If `b` is between `a` and `c`, then `c` is between `b` and `a`.\n  This is motivated by imagining three points on a circle. -/\n  btw_cyclic_left {a b c : α} : btw a b c → btw b c a\n  sbtw := fun a b c => btw a b c ∧ ¬btw c b a\n  /-- Strict betweenness is given by betweenness in one direction and non-betweenness in the other.\n\n  I.e., if `b` is between `a` and `c` but not between `c` and `a`, then we say `b` is strictly\n  between `a` and `c`. -/\n  sbtw_iff_btw_not_btw {a b c : α} : sbtw a b c ↔ btw a b c ∧ ¬btw c b a := by intros; rfl\n  /-- For any fixed `c`, `fun a b ↦ sbtw a b c` is a transitive relation.\n\n  I.e., given `a` `b` `d` `c` in that \"order\", if we have `b` strictly between `a` and `c`, and `d`\n  strictly between `b` and `c`, then `d` is strictly between `a` and `c`. -/\n  sbtw_trans_left {a b c d : α} : sbtw a b c → sbtw b d c → sbtw a d c\n\n"}
{"name":"CircularPreorder.sbtw_iff_btw_not_btw","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\nself : CircularPreorder α\na b c : α\n⊢ Iff (SBtw.sbtw a b c) (And (Btw.btw a b c) (Not (Btw.btw c b a)))","decl":"/-- A circular preorder is the analogue of a preorder where you can loop around. `≤` and `<` are\nreplaced by ternary relations `btw` and `sbtw`. `btw` is reflexive and cyclic. `sbtw` is transitive.\n-/\nclass CircularPreorder (α : Type*) extends Btw α, SBtw α where\n  /-- `a` is between `a` and `a`. -/\n  btw_refl (a : α) : btw a a a\n  /-- If `b` is between `a` and `c`, then `c` is between `b` and `a`.\n  This is motivated by imagining three points on a circle. -/\n  btw_cyclic_left {a b c : α} : btw a b c → btw b c a\n  sbtw := fun a b c => btw a b c ∧ ¬btw c b a\n  /-- Strict betweenness is given by betweenness in one direction and non-betweenness in the other.\n\n  I.e., if `b` is between `a` and `c` but not between `c` and `a`, then we say `b` is strictly\n  between `a` and `c`. -/\n  sbtw_iff_btw_not_btw {a b c : α} : sbtw a b c ↔ btw a b c ∧ ¬btw c b a := by intros; rfl\n  /-- For any fixed `c`, `fun a b ↦ sbtw a b c` is a transitive relation.\n\n  I.e., given `a` `b` `d` `c` in that \"order\", if we have `b` strictly between `a` and `c`, and `d`\n  strictly between `b` and `c`, then `d` is strictly between `a` and `c`. -/\n  sbtw_trans_left {a b c d : α} : sbtw a b c → sbtw b d c → sbtw a d c\n\n"}
{"name":"CircularPreorder.btw_refl","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\nself : CircularPreorder α\na : α\n⊢ Btw.btw a a a","decl":"/-- A circular preorder is the analogue of a preorder where you can loop around. `≤` and `<` are\nreplaced by ternary relations `btw` and `sbtw`. `btw` is reflexive and cyclic. `sbtw` is transitive.\n-/\nclass CircularPreorder (α : Type*) extends Btw α, SBtw α where\n  /-- `a` is between `a` and `a`. -/\n  btw_refl (a : α) : btw a a a\n  /-- If `b` is between `a` and `c`, then `c` is between `b` and `a`.\n  This is motivated by imagining three points on a circle. -/\n  btw_cyclic_left {a b c : α} : btw a b c → btw b c a\n  sbtw := fun a b c => btw a b c ∧ ¬btw c b a\n  /-- Strict betweenness is given by betweenness in one direction and non-betweenness in the other.\n\n  I.e., if `b` is between `a` and `c` but not between `c` and `a`, then we say `b` is strictly\n  between `a` and `c`. -/\n  sbtw_iff_btw_not_btw {a b c : α} : sbtw a b c ↔ btw a b c ∧ ¬btw c b a := by intros; rfl\n  /-- For any fixed `c`, `fun a b ↦ sbtw a b c` is a transitive relation.\n\n  I.e., given `a` `b` `d` `c` in that \"order\", if we have `b` strictly between `a` and `c`, and `d`\n  strictly between `b` and `c`, then `d` is strictly between `a` and `c`. -/\n  sbtw_trans_left {a b c d : α} : sbtw a b c → sbtw b d c → sbtw a d c\n\n"}
{"name":"CircularPreorder.btw_cyclic_left","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\nself : CircularPreorder α\na b c : α\na✝ : Btw.btw a b c\n⊢ Btw.btw b c a","decl":"/-- A circular preorder is the analogue of a preorder where you can loop around. `≤` and `<` are\nreplaced by ternary relations `btw` and `sbtw`. `btw` is reflexive and cyclic. `sbtw` is transitive.\n-/\nclass CircularPreorder (α : Type*) extends Btw α, SBtw α where\n  /-- `a` is between `a` and `a`. -/\n  btw_refl (a : α) : btw a a a\n  /-- If `b` is between `a` and `c`, then `c` is between `b` and `a`.\n  This is motivated by imagining three points on a circle. -/\n  btw_cyclic_left {a b c : α} : btw a b c → btw b c a\n  sbtw := fun a b c => btw a b c ∧ ¬btw c b a\n  /-- Strict betweenness is given by betweenness in one direction and non-betweenness in the other.\n\n  I.e., if `b` is between `a` and `c` but not between `c` and `a`, then we say `b` is strictly\n  between `a` and `c`. -/\n  sbtw_iff_btw_not_btw {a b c : α} : sbtw a b c ↔ btw a b c ∧ ¬btw c b a := by intros; rfl\n  /-- For any fixed `c`, `fun a b ↦ sbtw a b c` is a transitive relation.\n\n  I.e., given `a` `b` `d` `c` in that \"order\", if we have `b` strictly between `a` and `c`, and `d`\n  strictly between `b` and `c`, then `d` is strictly between `a` and `c`. -/\n  sbtw_trans_left {a b c d : α} : sbtw a b c → sbtw b d c → sbtw a d c\n\n"}
{"name":"CircularPartialOrder.btw_antisymm","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\nself : CircularPartialOrder α\na b c : α\na✝¹ : Btw.btw a b c\na✝ : Btw.btw c b a\n⊢ Or (Eq a b) (Or (Eq b c) (Eq c a))","decl":"/-- A circular partial order is the analogue of a partial order where you can loop around. `≤` and\n`<` are replaced by ternary relations `btw` and `sbtw`. `btw` is reflexive, cyclic and\nantisymmetric. `sbtw` is transitive. -/\nclass CircularPartialOrder (α : Type*) extends CircularPreorder α where\n  /-- If `b` is between `a` and `c` and also between `c` and `a`, then at least one pair of points\n  among `a`, `b`, `c` are identical. -/\n  btw_antisymm {a b c : α} : btw a b c → btw c b a → a = b ∨ b = c ∨ c = a\n\n"}
{"name":"CircularOrder.btw_total","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\nself : CircularOrder α\na b c : α\n⊢ Or (Btw.btw a b c) (Btw.btw c b a)","decl":"/-- A circular order is the analogue of a linear order where you can loop around. `≤` and `<` are\nreplaced by ternary relations `btw` and `sbtw`. `btw` is reflexive, cyclic, antisymmetric and total.\n`sbtw` is transitive. -/\nclass CircularOrder (α : Type*) extends CircularPartialOrder α where\n  /-- For any triple of points, the second is between the other two one way or another. -/\n  btw_total : ∀ a b c : α, btw a b c ∨ btw c b a\n\n"}
{"name":"btw_rfl","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na : α\n⊢ Btw.btw a a a","decl":"theorem btw_rfl {a : α} : btw a a a :=\n  btw_refl _\n\n-- TODO: `alias` creates a def instead of a lemma (because `btw_cyclic_left` is a def).\n-- alias btw_cyclic_left        ← Btw.btw.cyclic_left\n"}
{"name":"Btw.btw.cyclic_left","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : Btw.btw a b c\n⊢ Btw.btw b c a","decl":"theorem Btw.btw.cyclic_left {a b c : α} (h : btw a b c) : btw b c a :=\n  btw_cyclic_left h\n\n"}
{"name":"btw_cyclic_right","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : Btw.btw a b c\n⊢ Btw.btw c a b","decl":"theorem btw_cyclic_right {a b c : α} (h : btw a b c) : btw c a b :=\n  h.cyclic_left.cyclic_left\n\n"}
{"name":"Btw.btw.cyclic_right","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : Btw.btw a b c\n⊢ Btw.btw c a b","decl":"alias Btw.btw.cyclic_right := btw_cyclic_right\n\n"}
{"name":"btw_cyclic","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\n⊢ Iff (Btw.btw a b c) (Btw.btw c a b)","decl":"/-- The order of the `↔` has been chosen so that `rw [btw_cyclic]` cycles to the right while\n`rw [← btw_cyclic]` cycles to the left (thus following the prepended arrow). -/\ntheorem btw_cyclic {a b c : α} : btw a b c ↔ btw c a b :=\n  ⟨btw_cyclic_right, btw_cyclic_left⟩\n\n"}
{"name":"sbtw_iff_btw_not_btw","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\n⊢ Iff (SBtw.sbtw a b c) (And (Btw.btw a b c) (Not (Btw.btw c b a)))","decl":"theorem sbtw_iff_btw_not_btw {a b c : α} : sbtw a b c ↔ btw a b c ∧ ¬btw c b a :=\n  CircularPreorder.sbtw_iff_btw_not_btw\n\n"}
{"name":"btw_of_sbtw","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : SBtw.sbtw a b c\n⊢ Btw.btw a b c","decl":"theorem btw_of_sbtw {a b c : α} (h : sbtw a b c) : btw a b c :=\n  (sbtw_iff_btw_not_btw.1 h).1\n\n"}
{"name":"SBtw.sbtw.btw","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : SBtw.sbtw a b c\n⊢ Btw.btw a b c","decl":"alias SBtw.sbtw.btw := btw_of_sbtw\n\n"}
{"name":"not_btw_of_sbtw","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : SBtw.sbtw a b c\n⊢ Not (Btw.btw c b a)","decl":"theorem not_btw_of_sbtw {a b c : α} (h : sbtw a b c) : ¬btw c b a :=\n  (sbtw_iff_btw_not_btw.1 h).2\n\n"}
{"name":"SBtw.sbtw.not_btw","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : SBtw.sbtw a b c\n⊢ Not (Btw.btw c b a)","decl":"alias SBtw.sbtw.not_btw := not_btw_of_sbtw\n\n"}
{"name":"not_sbtw_of_btw","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : Btw.btw a b c\n⊢ Not (SBtw.sbtw c b a)","decl":"theorem not_sbtw_of_btw {a b c : α} (h : btw a b c) : ¬sbtw c b a := fun h' => h'.not_btw h\n\n"}
{"name":"Btw.btw.not_sbtw","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : Btw.btw a b c\n⊢ Not (SBtw.sbtw c b a)","decl":"alias Btw.btw.not_sbtw := not_sbtw_of_btw\n\n"}
{"name":"sbtw_of_btw_not_btw","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nhabc : Btw.btw a b c\nhcba : Not (Btw.btw c b a)\n⊢ SBtw.sbtw a b c","decl":"theorem sbtw_of_btw_not_btw {a b c : α} (habc : btw a b c) (hcba : ¬btw c b a) : sbtw a b c :=\n  sbtw_iff_btw_not_btw.2 ⟨habc, hcba⟩\n\n"}
{"name":"Btw.btw.sbtw_of_not_btw","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nhabc : Btw.btw a b c\nhcba : Not (Btw.btw c b a)\n⊢ SBtw.sbtw a b c","decl":"alias Btw.btw.sbtw_of_not_btw := sbtw_of_btw_not_btw\n\n"}
{"name":"sbtw_cyclic_left","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : SBtw.sbtw a b c\n⊢ SBtw.sbtw b c a","decl":"theorem sbtw_cyclic_left {a b c : α} (h : sbtw a b c) : sbtw b c a :=\n  h.btw.cyclic_left.sbtw_of_not_btw fun h' => h.not_btw h'.cyclic_left\n\n"}
{"name":"SBtw.sbtw.cyclic_left","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : SBtw.sbtw a b c\n⊢ SBtw.sbtw b c a","decl":"alias SBtw.sbtw.cyclic_left := sbtw_cyclic_left\n\n"}
{"name":"sbtw_cyclic_right","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : SBtw.sbtw a b c\n⊢ SBtw.sbtw c a b","decl":"theorem sbtw_cyclic_right {a b c : α} (h : sbtw a b c) : sbtw c a b :=\n  h.cyclic_left.cyclic_left\n\n"}
{"name":"SBtw.sbtw.cyclic_right","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : SBtw.sbtw a b c\n⊢ SBtw.sbtw c a b","decl":"alias SBtw.sbtw.cyclic_right := sbtw_cyclic_right\n\n"}
{"name":"sbtw_cyclic","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\n⊢ Iff (SBtw.sbtw a b c) (SBtw.sbtw c a b)","decl":"/-- The order of the `↔` has been chosen so that `rw [sbtw_cyclic]` cycles to the right while\n`rw [← sbtw_cyclic]` cycles to the left (thus following the prepended arrow). -/\ntheorem sbtw_cyclic {a b c : α} : sbtw a b c ↔ sbtw c a b :=\n  ⟨sbtw_cyclic_right, sbtw_cyclic_left⟩\n\n-- TODO: `alias` creates a def instead of a lemma (because `sbtw_trans_left` is a def).\n-- alias btw_trans_left        ← SBtw.sbtw.trans_left\n"}
{"name":"SBtw.sbtw.trans_left","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c d : α\nh : SBtw.sbtw a b c\na✝ : SBtw.sbtw b d c\n⊢ SBtw.sbtw a d c","decl":"theorem SBtw.sbtw.trans_left {a b c d : α} (h : sbtw a b c) : sbtw b d c → sbtw a d c :=\n  sbtw_trans_left h\n\n"}
{"name":"sbtw_trans_right","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c d : α\nhbc : SBtw.sbtw a b c\nhcd : SBtw.sbtw a c d\n⊢ SBtw.sbtw a b d","decl":"theorem sbtw_trans_right {a b c d : α} (hbc : sbtw a b c) (hcd : sbtw a c d) : sbtw a b d :=\n  (hbc.cyclic_left.trans_left hcd.cyclic_left).cyclic_right\n\n"}
{"name":"SBtw.sbtw.trans_right","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c d : α\nhbc : SBtw.sbtw a b c\nhcd : SBtw.sbtw a c d\n⊢ SBtw.sbtw a b d","decl":"alias SBtw.sbtw.trans_right := sbtw_trans_right\n\n"}
{"name":"sbtw_asymm","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : SBtw.sbtw a b c\n⊢ Not (SBtw.sbtw c b a)","decl":"theorem sbtw_asymm {a b c : α} (h : sbtw a b c) : ¬sbtw c b a :=\n  h.btw.not_sbtw\n\n"}
{"name":"SBtw.sbtw.not_sbtw","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b c : α\nh : SBtw.sbtw a b c\n⊢ Not (SBtw.sbtw c b a)","decl":"alias SBtw.sbtw.not_sbtw := sbtw_asymm\n\n"}
{"name":"sbtw_irrefl_left_right","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b : α\n⊢ Not (SBtw.sbtw a b a)","decl":"theorem sbtw_irrefl_left_right {a b : α} : ¬sbtw a b a := fun h => h.not_btw h.btw\n\n"}
{"name":"sbtw_irrefl_left","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b : α\n⊢ Not (SBtw.sbtw a a b)","decl":"theorem sbtw_irrefl_left {a b : α} : ¬sbtw a a b := fun h => sbtw_irrefl_left_right h.cyclic_left\n\n"}
{"name":"sbtw_irrefl_right","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b : α\n⊢ Not (SBtw.sbtw a b b)","decl":"theorem sbtw_irrefl_right {a b : α} : ¬sbtw a b b := fun h => sbtw_irrefl_left_right h.cyclic_right\n\n"}
{"name":"sbtw_irrefl","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na : α\n⊢ Not (SBtw.sbtw a a a)","decl":"theorem sbtw_irrefl (a : α) : ¬sbtw a a a :=\n  sbtw_irrefl_left_right\n\n"}
{"name":"Btw.btw.antisymm","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPartialOrder α\na b c : α\nh : Btw.btw a b c\na✝ : Btw.btw c b a\n⊢ Or (Eq a b) (Or (Eq b c) (Eq c a))","decl":"theorem Btw.btw.antisymm {a b c : α} (h : btw a b c) : btw c b a → a = b ∨ b = c ∨ c = a :=\n  btw_antisymm h\n\n"}
{"name":"btw_refl_left_right","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularOrder α\na b : α\n⊢ Btw.btw a b a","decl":"theorem btw_refl_left_right (a b : α) : btw a b a :=\n  or_self_iff.1 (btw_total a b a)\n\n"}
{"name":"btw_rfl_left_right","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularOrder α\na b : α\n⊢ Btw.btw a b a","decl":"theorem btw_rfl_left_right {a b : α} : btw a b a :=\n  btw_refl_left_right _ _\n\n"}
{"name":"btw_refl_left","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularOrder α\na b : α\n⊢ Btw.btw a a b","decl":"theorem btw_refl_left (a b : α) : btw a a b :=\n  btw_rfl_left_right.cyclic_right\n\n"}
{"name":"btw_rfl_left","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularOrder α\na b : α\n⊢ Btw.btw a a b","decl":"theorem btw_rfl_left {a b : α} : btw a a b :=\n  btw_refl_left _ _\n\n"}
{"name":"btw_refl_right","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularOrder α\na b : α\n⊢ Btw.btw a b b","decl":"theorem btw_refl_right (a b : α) : btw a b b :=\n  btw_rfl_left_right.cyclic_left\n\n"}
{"name":"btw_rfl_right","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularOrder α\na b : α\n⊢ Btw.btw a b b","decl":"theorem btw_rfl_right {a b : α} : btw a b b :=\n  btw_refl_right _ _\n\n"}
{"name":"sbtw_iff_not_btw","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularOrder α\na b c : α\n⊢ Iff (SBtw.sbtw a b c) (Not (Btw.btw c b a))","decl":"theorem sbtw_iff_not_btw {a b c : α} : sbtw a b c ↔ ¬btw c b a := by\n  rw [sbtw_iff_btw_not_btw]\n  exact and_iff_right_of_imp (btw_total _ _ _).resolve_left\n\n"}
{"name":"btw_iff_not_sbtw","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularOrder α\na b c : α\n⊢ Iff (Btw.btw a b c) (Not (SBtw.sbtw c b a))","decl":"theorem btw_iff_not_sbtw {a b c : α} : btw a b c ↔ ¬sbtw c b a :=\n  iff_not_comm.1 sbtw_iff_not_btw\n\n"}
{"name":"Set.mem_cIcc","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b x : α\n⊢ Iff (Membership.mem (Set.cIcc a b) x) (Btw.btw a x b)","decl":"@[simp]\ntheorem mem_cIcc {a b x : α} : x ∈ cIcc a b ↔ btw a x b :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_cIoo","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularPreorder α\na b x : α\n⊢ Iff (Membership.mem (Set.cIoo a b) x) (SBtw.sbtw a x b)","decl":"@[simp]\ntheorem mem_cIoo {a b x : α} : x ∈ cIoo a b ↔ sbtw a x b :=\n  Iff.rfl\n\n"}
{"name":"Set.left_mem_cIcc","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularOrder α\na b : α\n⊢ Membership.mem (Set.cIcc a b) a","decl":"theorem left_mem_cIcc (a b : α) : a ∈ cIcc a b :=\n  btw_rfl_left\n\n"}
{"name":"Set.right_mem_cIcc","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularOrder α\na b : α\n⊢ Membership.mem (Set.cIcc a b) b","decl":"theorem right_mem_cIcc (a b : α) : b ∈ cIcc a b :=\n  btw_rfl_right\n\n"}
{"name":"Set.compl_cIcc","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularOrder α\na b : α\n⊢ Eq (HasCompl.compl (Set.cIcc a b)) (Set.cIoo b a)","decl":"theorem compl_cIcc {a b : α} : (cIcc a b)ᶜ = cIoo b a := by\n  ext\n  rw [Set.mem_cIoo, sbtw_iff_not_btw, cIcc, mem_compl_iff, mem_setOf]\n\n"}
{"name":"Set.compl_cIoo","module":"Mathlib.Order.Circular","initialProofState":"α : Type u_1\ninst✝ : CircularOrder α\na b : α\n⊢ Eq (HasCompl.compl (Set.cIoo a b)) (Set.cIcc b a)","decl":"theorem compl_cIoo {a b : α} : (cIoo a b)ᶜ = cIcc b a := by\n  ext\n  rw [Set.mem_cIcc, btw_iff_not_sbtw, cIoo, mem_compl_iff, mem_setOf]\n\n"}
