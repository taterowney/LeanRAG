{"name":"Pi.lex_eq_finsupp_lex","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝ : Zero N\nr : α → α → Prop\ns : N → N → Prop\na b : Finsupp α N\n⊢ Eq (Pi.Lex r (fun {i} => s) ⇑a ⇑b) (Finsupp.Lex r s a b)","decl":"theorem _root_.Pi.lex_eq_finsupp_lex {r : α → α → Prop} {s : N → N → Prop} (a b : α →₀ N) :\n    Pi.Lex r s a b = Finsupp.Lex r s a b :=\n  rfl\n\n"}
{"name":"Finsupp.lex_def","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝ : Zero N\nr : α → α → Prop\ns : N → N → Prop\na b : Finsupp α N\n⊢ Iff (Finsupp.Lex r s a b) (Exists fun j => And (∀ (d : α), r d j → Eq (a d) (b d)) (s (a j) (b j)))","decl":"theorem lex_def {r : α → α → Prop} {s : N → N → Prop} {a b : α →₀ N} :\n    Finsupp.Lex r s a b ↔ ∃ j, (∀ d, r d j → a d = b d) ∧ s (a j) (b j) :=\n  Iff.rfl\n\n"}
{"name":"Finsupp.lex_eq_invImage_dfinsupp_lex","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝ : Zero N\nr : α → α → Prop\ns : N → N → Prop\n⊢ Eq (Finsupp.Lex r s) (InvImage (DFinsupp.Lex r fun x => s) Finsupp.toDFinsupp)","decl":"theorem lex_eq_invImage_dfinsupp_lex (r : α → α → Prop) (s : N → N → Prop) :\n    Finsupp.Lex r s = InvImage (DFinsupp.Lex r fun _ ↦ s) toDFinsupp :=\n  rfl\n\n"}
{"name":"Finsupp.lex_lt_iff","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝² : Zero N\ninst✝¹ : LT α\ninst✝ : LT N\na b : Lex (Finsupp α N)\n⊢ Iff (LT.lt a b) (Exists fun i => And (∀ (j : α), LT.lt j i → Eq ((ofLex a) j) ((ofLex b) j)) (LT.lt ((ofLex a) i) ((ofLex b) i)))","decl":"theorem lex_lt_iff [LT α] [LT N] {a b : Lex (α →₀ N)} :\n    a < b ↔ ∃ i, (∀ j, j < i → ofLex a j = ofLex b j) ∧ ofLex a i < ofLex b i :=\n  Finsupp.lex_def\n\n"}
{"name":"Finsupp.lex_lt_iff_of_unique","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝³ : Zero N\ninst✝² : Preorder α\ninst✝¹ : LT N\ninst✝ : Unique α\na b : Lex (Finsupp α N)\n⊢ Iff (LT.lt a b) (LT.lt ((ofLex a) Inhabited.default) ((ofLex b) Inhabited.default))","decl":"theorem lex_lt_iff_of_unique [Preorder α] [LT N] [Unique α] {a b : Lex (α →₀ N)} :\n    a < b ↔ ofLex a default < ofLex b default := by\n  simp only [lex_lt_iff, Unique.exists_iff, and_iff_right_iff_imp]\n  refine fun _ j hj ↦ False.elim (lt_irrefl j ?_)\n  simpa only [Unique.uniq] using hj\n\n"}
{"name":"Finsupp.lex_lt_of_lt_of_preorder","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝² : Zero N\ninst✝¹ : Preorder N\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\nx y : Finsupp α N\nhlt : LT.lt x y\n⊢ Exists fun i => And (∀ (j : α), r j i → And (LE.le (x j) (y j)) (LE.le (y j) (x j))) (LT.lt (x i) (y i))","decl":"theorem lex_lt_of_lt_of_preorder [Preorder N] (r) [IsStrictOrder α r] {x y : α →₀ N} (hlt : x < y) :\n    ∃ i, (∀ j, r j i → x j ≤ y j ∧ y j ≤ x j) ∧ x i < y i :=\n  DFinsupp.lex_lt_of_lt_of_preorder r (id hlt : x.toDFinsupp < y.toDFinsupp)\n\n"}
{"name":"Finsupp.lex_lt_of_lt","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝² : Zero N\ninst✝¹ : PartialOrder N\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\nx y : Finsupp α N\nhlt : LT.lt x y\n⊢ Pi.Lex r (fun {i} x1 x2 => LT.lt x1 x2) ⇑x ⇑y","decl":"theorem lex_lt_of_lt [PartialOrder N] (r) [IsStrictOrder α r] {x y : α →₀ N} (hlt : x < y) :\n    Pi.Lex r (· < ·) x y :=\n  DFinsupp.lex_lt_of_lt r (id hlt : x.toDFinsupp < y.toDFinsupp)\n\n"}
{"name":"Finsupp.Lex.isStrictOrder","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝² : Zero N\ninst✝¹ : LinearOrder α\ninst✝ : PartialOrder N\n⊢ IsStrictOrder (Lex (Finsupp α N)) fun x1 x2 => LT.lt x1 x2","decl":"instance Lex.isStrictOrder [LinearOrder α] [PartialOrder N] :\n    IsStrictOrder (Lex (α →₀ N)) (· < ·) where\n  irrefl _ := lt_irrefl (α := Lex (α → N)) _\n  trans _ _ _ := lt_trans (α := Lex (α → N))\n\n"}
{"name":"Finsupp.Lex.single_strictAnti","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ StrictAnti fun a => toLex (Finsupp.single a 1)","decl":"theorem Lex.single_strictAnti : StrictAnti (fun (a : α) ↦ toLex (single a 1)) := by\n  intro a b h\n  simp only [LT.lt, Finsupp.lex_def]\n  simp only [ofLex_toLex, Nat.lt_eq]\n  use a\n  constructor\n  · intro d hd\n    simp only [Finsupp.single_eq_of_ne (ne_of_lt hd).symm,\n      Finsupp.single_eq_of_ne (ne_of_gt (lt_trans hd h))]\n  · simp only [single_eq_same, single_eq_of_ne (ne_of_lt h).symm, zero_lt_one]\n\n"}
{"name":"Finsupp.Lex.single_lt_iff","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (LT.lt (toLex (Finsupp.single b 1)) (toLex (Finsupp.single a 1))) (LT.lt a b)","decl":"theorem Lex.single_lt_iff {a b : α} : toLex (single b 1) < toLex (single a 1) ↔ a < b :=\n  Lex.single_strictAnti.lt_iff_lt\n\n"}
{"name":"Finsupp.Lex.single_le_iff","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (LE.le (toLex (Finsupp.single b 1)) (toLex (Finsupp.single a 1))) (LE.le a b)","decl":"theorem Lex.single_le_iff {a b : α} : toLex (single b 1) ≤ toLex (single a 1) ↔ a ≤ b :=\n  Lex.single_strictAnti.le_iff_le\n\n"}
{"name":"Finsupp.Lex.single_antitone","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ Antitone fun a => toLex (Finsupp.single a 1)","decl":"theorem Lex.single_antitone : Antitone (fun (a : α) ↦ toLex (single a 1)) :=\n  Lex.single_strictAnti.antitone\n\n"}
{"name":"Finsupp.toLex_monotone","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝² : Zero N\ninst✝¹ : LinearOrder α\ninst✝ : PartialOrder N\n⊢ Monotone ⇑toLex","decl":"theorem toLex_monotone : Monotone (@toLex (α →₀ N)) :=\n  fun a b h ↦ DFinsupp.toLex_monotone (id h : ∀ i, ofLex (toDFinsupp a) i ≤ ofLex (toDFinsupp b) i)\n\n"}
{"name":"Finsupp.lt_of_forall_lt_of_lt","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝² : Zero N\ninst✝¹ : LinearOrder α\ninst✝ : PartialOrder N\na b : Lex (Finsupp α N)\ni : α\na✝¹ : ∀ (j : α), LT.lt j i → Eq ((ofLex a) j) ((ofLex b) j)\na✝ : LT.lt ((ofLex a) i) ((ofLex b) i)\n⊢ LT.lt a b","decl":"theorem lt_of_forall_lt_of_lt (a b : Lex (α →₀ N)) (i : α) :\n    (∀ j < i, ofLex a j = ofLex b j) → ofLex a i < ofLex b i → a < b :=\n  fun h1 h2 ↦ ⟨i, h1, h2⟩\n\n"}
{"name":"Finsupp.lex_le_iff_of_unique","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝³ : Zero N\ninst✝² : LinearOrder α\ninst✝¹ : PartialOrder N\ninst✝ : Unique α\na b : Lex (Finsupp α N)\n⊢ Iff (LE.le a b) (LE.le ((ofLex a) Inhabited.default) ((ofLex b) Inhabited.default))","decl":"theorem lex_le_iff_of_unique [Unique α] {a b : Lex (α →₀ N)} :\n    a ≤ b ↔ ofLex a default ≤ ofLex b default := by\n  simp only [le_iff_eq_or_lt, EmbeddingLike.apply_eq_iff_eq]\n  apply or_congr _ lex_lt_iff_of_unique\n  conv_lhs => rw [← toLex_ofLex a, ← toLex_ofLex b, toLex_inj]\n  simp only [Finsupp.ext_iff, Unique.forall_iff]\n\n"}
{"name":"Finsupp.Lex.addLeftStrictMono","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝³ : LinearOrder α\ninst✝² : AddMonoid N\ninst✝¹ : LinearOrder N\ninst✝ : AddLeftStrictMono N\n⊢ AddLeftStrictMono (Lex (Finsupp α N))","decl":"instance Lex.addLeftStrictMono : AddLeftStrictMono (Lex (α →₀ N)) :=\n  ⟨fun _ _ _ ⟨a, lta, ha⟩ ↦ ⟨a, fun j ja ↦ congr_arg _ (lta j ja), add_lt_add_left ha _⟩⟩\n\n"}
{"name":"Finsupp.Lex.addLeftMono","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝³ : LinearOrder α\ninst✝² : AddMonoid N\ninst✝¹ : LinearOrder N\ninst✝ : AddLeftStrictMono N\n⊢ AddLeftMono (Lex (Finsupp α N))","decl":"instance Lex.addLeftMono : AddLeftMono (Lex (α →₀ N)) :=\n  addLeftMono_of_addLeftStrictMono _\n\n"}
{"name":"Finsupp.Lex.addRightStrictMono","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝³ : LinearOrder α\ninst✝² : AddMonoid N\ninst✝¹ : LinearOrder N\ninst✝ : AddRightStrictMono N\n⊢ AddRightStrictMono (Lex (Finsupp α N))","decl":"instance Lex.addRightStrictMono : AddRightStrictMono (Lex (α →₀ N)) :=\n  ⟨fun f _ _ ⟨a, lta, ha⟩ ↦\n    ⟨a, fun j ja ↦ congr_arg (· + ofLex f j) (lta j ja), add_lt_add_right ha _⟩⟩\n\n"}
{"name":"Finsupp.Lex.addRightMono","module":"Mathlib.Data.Finsupp.Lex","initialProofState":"α : Type u_1\nN : Type u_2\ninst✝³ : LinearOrder α\ninst✝² : AddMonoid N\ninst✝¹ : LinearOrder N\ninst✝ : AddRightStrictMono N\n⊢ AddRightMono (Lex (Finsupp α N))","decl":"instance Lex.addRightMono : AddRightMono (Lex (α →₀ N)) :=\n  addRightMono_of_addRightStrictMono _\n\n"}
