{"name":"rexp_neg_quadratic_isLittleO_rpow_atTop","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.PoissonSummation","initialProofState":"a : Real\nha : LT.lt a 0\nb s : Real\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => Real.exp (HAdd.hAdd (HMul.hMul a (HPow.hPow x 2)) (HMul.hMul b x))) fun x => HPow.hPow x s","decl":"lemma rexp_neg_quadratic_isLittleO_rpow_atTop {a : ‚Ñù} (ha : a < 0) (b s : ‚Ñù) :\n    (fun x ‚Ü¶ rexp (a * x ^ 2 + b * x)) =o[atTop] (¬∑ ^ s) := by\n  suffices (fun x ‚Ü¶ rexp (a * x ^ 2 + b * x)) =o[atTop] (fun x ‚Ü¶ rexp (-x)) by\n    refine this.trans ?_\n    simpa only [neg_one_mul] using isLittleO_exp_neg_mul_rpow_atTop zero_lt_one s\n  rw [isLittleO_exp_comp_exp_comp]\n  have : (fun x ‚Ü¶ -x - (a * x ^ 2 + b * x)) = fun x ‚Ü¶ x * (-a * x - (b + 1)) := by\n    ext1 x; ring_nf\n  rw [this]\n  exact tendsto_id.atTop_mul_atTop <|\n    Filter.tendsto_atTop_add_const_right _ _ <| tendsto_id.const_mul_atTop (neg_pos.mpr ha)\n\n"}
{"name":"cexp_neg_quadratic_isLittleO_rpow_atTop","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.PoissonSummation","initialProofState":"a : Complex\nha : LT.lt a.re 0\nb : Complex\ns : Real\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => Complex.exp (HAdd.hAdd (HMul.hMul a (HPow.hPow (‚Üëx) 2)) (HMul.hMul b ‚Üëx))) fun x => HPow.hPow x s","decl":"lemma cexp_neg_quadratic_isLittleO_rpow_atTop {a : ‚ÑÇ} (ha : a.re < 0) (b : ‚ÑÇ) (s : ‚Ñù) :\n    (fun x : ‚Ñù ‚Ü¶ cexp (a * x ^ 2 + b * x)) =o[atTop] (¬∑ ^ s) := by\n  apply Asymptotics.IsLittleO.of_norm_left\n  convert rexp_neg_quadratic_isLittleO_rpow_atTop ha b.re s with x\n  simp_rw [Complex.norm_eq_abs, Complex.abs_exp, add_re, ‚Üê ofReal_pow, mul_comm (_ : ‚ÑÇ) ‚Üë(_ : ‚Ñù),\n      re_ofReal_mul, mul_comm _ (re _)]\n\n"}
{"name":"cexp_neg_quadratic_isLittleO_abs_rpow_cocompact","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.PoissonSummation","initialProofState":"a : Complex\nha : LT.lt a.re 0\nb : Complex\ns : Real\n‚ä¢ Asymptotics.IsLittleO (Filter.cocompact Real) (fun x => Complex.exp (HAdd.hAdd (HMul.hMul a (HPow.hPow (‚Üëx) 2)) (HMul.hMul b ‚Üëx))) fun x => HPow.hPow (abs x) s","decl":"lemma cexp_neg_quadratic_isLittleO_abs_rpow_cocompact {a : ‚ÑÇ} (ha : a.re < 0) (b : ‚ÑÇ) (s : ‚Ñù) :\n    (fun x : ‚Ñù ‚Ü¶ cexp (a * x ^ 2 + b * x)) =o[cocompact ‚Ñù] (|¬∑| ^ s) := by\n  rw [cocompact_eq_atBot_atTop, isLittleO_sup]\n  constructor\n  ¬∑ refine ((cexp_neg_quadratic_isLittleO_rpow_atTop ha (-b) s).comp_tendsto\n      Filter.tendsto_neg_atBot_atTop).congr' (Eventually.of_forall fun x ‚Ü¶ ?_) ?_\n    ¬∑ simp only [neg_mul, Function.comp_apply, ofReal_neg, neg_sq, mul_neg, neg_neg]\n    ¬∑ refine (eventually_lt_atBot 0).mp (Eventually.of_forall fun x hx ‚Ü¶ ?_)\n      simp only [Function.comp_apply, abs_of_neg hx]\n  ¬∑ refine (cexp_neg_quadratic_isLittleO_rpow_atTop ha b s).congr' EventuallyEq.rfl ?_\n    refine (eventually_gt_atTop 0).mp (Eventually.of_forall fun x hx ‚Ü¶ ?_)\n    simp_rw [abs_of_pos hx]\n\n"}
{"name":"tendsto_rpow_abs_mul_exp_neg_mul_sq_cocompact","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.PoissonSummation","initialProofState":"a : Real\nha : LT.lt 0 a\ns : Real\n‚ä¢ Filter.Tendsto (fun x => HMul.hMul (HPow.hPow (abs x) s) (Real.exp (HMul.hMul (Neg.neg a) (HPow.hPow x 2)))) (Filter.cocompact Real) (nhds 0)","decl":"theorem tendsto_rpow_abs_mul_exp_neg_mul_sq_cocompact {a : ‚Ñù} (ha : 0 < a) (s : ‚Ñù) :\n    Tendsto (fun x : ‚Ñù => |x| ^ s * rexp (-a * x ^ 2)) (cocompact ‚Ñù) (ùìù 0) := by\n  conv in rexp _ => rw [‚Üê sq_abs]\n  erw [cocompact_eq_atBot_atTop, ‚Üê comap_abs_atTop,\n    @tendsto_comap'_iff _ _ _ (fun y => y ^ s * rexp (-a * y ^ 2)) _ _ _\n      (mem_atTop_sets.mpr ‚ü®0, fun b hb => ‚ü®b, abs_of_nonneg hb‚ü©‚ü©)]\n  exact\n    (rpow_mul_exp_neg_mul_sq_isLittleO_exp_neg ha s).tendsto_zero_of_tendsto\n      (tendsto_exp_atBot.comp <| tendsto_id.const_mul_atTop_of_neg (neg_lt_zero.mpr one_half_pos))\n\n"}
{"name":"isLittleO_exp_neg_mul_sq_cocompact","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.PoissonSummation","initialProofState":"a : Complex\nha : LT.lt 0 a.re\ns : Real\n‚ä¢ Asymptotics.IsLittleO (Filter.cocompact Real) (fun x => Complex.exp (HMul.hMul (Neg.neg a) (HPow.hPow (‚Üëx) 2))) fun x => HPow.hPow (abs x) s","decl":"theorem isLittleO_exp_neg_mul_sq_cocompact {a : ‚ÑÇ} (ha : 0 < a.re) (s : ‚Ñù) :\n    (fun x : ‚Ñù => Complex.exp (-a * x ^ 2)) =o[cocompact ‚Ñù] fun x : ‚Ñù => |x| ^ s := by\n  convert cexp_neg_quadratic_isLittleO_abs_rpow_cocompact (?_ : (-a).re < 0) 0 s using 1\n  ¬∑ simp_rw [zero_mul, add_zero]\n  ¬∑ rwa [neg_re, neg_lt_zero]\n\n"}
{"name":"Complex.tsum_exp_neg_quadratic","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.PoissonSummation","initialProofState":"a : Complex\nha : LT.lt 0 a.re\nb : Complex\n‚ä¢ Eq (tsum fun n => Complex.exp (HAdd.hAdd (HMul.hMul (HMul.hMul (Neg.neg ‚ÜëReal.pi) a) (HPow.hPow (‚Üën) 2)) (HMul.hMul (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) b) ‚Üën))) (HMul.hMul (HDiv.hDiv 1 (HPow.hPow a (1 / 2))) (tsum fun n => Complex.exp (HMul.hMul (HDiv.hDiv (Neg.neg ‚ÜëReal.pi) a) (HPow.hPow (HAdd.hAdd (‚Üën) (HMul.hMul Complex.I b)) 2))))","decl":"/-- Jacobi's theta-function transformation formula for the sum of `exp -Q(x)`, where `Q` is a\nnegative definite quadratic form. -/\ntheorem Complex.tsum_exp_neg_quadratic {a : ‚ÑÇ} (ha : 0 < a.re) (b : ‚ÑÇ) :\n    (‚àë' n : ‚Ñ§, cexp (-œÄ * a * n ^ 2 + 2 * œÄ * b * n)) =\n      1 / a ^ (1 / 2 : ‚ÑÇ) * ‚àë' n : ‚Ñ§, cexp (-œÄ / a * (n + I * b) ^ 2) := by\n  let f : ‚Ñù ‚Üí ‚ÑÇ := fun x ‚Ü¶ cexp (-œÄ * a * x ^ 2 + 2 * œÄ * b * x)\n  have hCf : Continuous f := by\n    refine Complex.continuous_exp.comp (Continuous.add ?_ ?_)\n    ¬∑ exact continuous_const.mul (Complex.continuous_ofReal.pow 2)\n    ¬∑ exact continuous_const.mul Complex.continuous_ofReal\n  have hFf : ùìï f = fun x : ‚Ñù ‚Ü¶ 1 / a ^ (1 / 2 : ‚ÑÇ) * cexp (-œÄ / a * (x + I * b) ^ 2) :=\n    fourierIntegral_gaussian_pi' ha b\n  have h1 : 0 < (‚ÜëœÄ * a).re := by\n    rw [re_ofReal_mul]\n    exact mul_pos pi_pos ha\n  have h2 : 0 < (‚ÜëœÄ / a).re := by\n    rw [div_eq_mul_inv, re_ofReal_mul, inv_re]\n    refine mul_pos pi_pos (div_pos ha <| normSq_pos.mpr ?_)\n    contrapose! ha\n    rw [ha, zero_re]\n  have f_bd : f =O[cocompact ‚Ñù] (fun x => |x| ^ (-2 : ‚Ñù)) := by\n    convert (cexp_neg_quadratic_isLittleO_abs_rpow_cocompact ?_ _ (-2)).isBigO\n    rwa [neg_mul, neg_re, neg_lt_zero]\n  have Ff_bd : (ùìï f) =O[cocompact ‚Ñù] (fun x => |x| ^ (-2 : ‚Ñù)) := by\n    rw [hFf]\n    have : ‚àÄ (x : ‚Ñù), -‚ÜëœÄ / a * (‚Üëx + I * b) ^ 2 =\n        -‚ÜëœÄ / a * x ^ 2 + (-2 * œÄ * I * b) / a * x + œÄ * b ^ 2 / a := by\n      intro x; ring_nf; rw [I_sq]; ring\n    simp_rw [this]\n    conv => enter [2, x]; rw [Complex.exp_add, ‚Üê mul_assoc _ _ (Complex.exp _), mul_comm]\n    refine ((cexp_neg_quadratic_isLittleO_abs_rpow_cocompact\n      (?_) (-2 * ‚ÜëœÄ * I * b / a) (-2)).isBigO.const_mul_left _).const_mul_left _\n    rwa [neg_div, neg_re, neg_lt_zero]\n  convert Real.tsum_eq_tsum_fourierIntegral_of_rpow_decay hCf one_lt_two f_bd Ff_bd 0 using 1\n  ¬∑ simp only [f, zero_add, ofReal_intCast]\n  ¬∑ rw [‚Üê tsum_mul_left]\n    simp only [QuotientAddGroup.mk_zero, fourier_eval_zero, mul_one, hFf, ofReal_intCast]\n\n"}
{"name":"Complex.tsum_exp_neg_mul_int_sq","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.PoissonSummation","initialProofState":"a : Complex\nha : LT.lt 0 a.re\n‚ä¢ Eq (tsum fun n => Complex.exp (HMul.hMul (HMul.hMul (Neg.neg ‚ÜëReal.pi) a) (HPow.hPow (‚Üën) 2))) (HMul.hMul (HDiv.hDiv 1 (HPow.hPow a (1 / 2))) (tsum fun n => Complex.exp (HMul.hMul (HDiv.hDiv (Neg.neg ‚ÜëReal.pi) a) (HPow.hPow (‚Üën) 2))))","decl":"theorem Complex.tsum_exp_neg_mul_int_sq {a : ‚ÑÇ} (ha : 0 < a.re) :\n    (‚àë' n : ‚Ñ§, cexp (-œÄ * a * (n : ‚ÑÇ) ^ 2)) =\n      1 / a ^ (1 / 2 : ‚ÑÇ) * ‚àë' n : ‚Ñ§, cexp (-œÄ / a * (n : ‚ÑÇ) ^ 2) := by\n  simpa only [mul_zero, zero_mul, add_zero] using Complex.tsum_exp_neg_quadratic ha 0\n\n"}
{"name":"Real.tsum_exp_neg_mul_int_sq","module":"Mathlib.Analysis.SpecialFunctions.Gaussian.PoissonSummation","initialProofState":"a : Real\nha : LT.lt 0 a\n‚ä¢ Eq (tsum fun n => Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) a) (HPow.hPow (‚Üën) 2))) (HMul.hMul (HDiv.hDiv 1 (HPow.hPow a (1 / 2))) (tsum fun n => Real.exp (HMul.hMul (HDiv.hDiv (Neg.neg Real.pi) a) (HPow.hPow (‚Üën) 2))))","decl":"theorem Real.tsum_exp_neg_mul_int_sq {a : ‚Ñù} (ha : 0 < a) :\n    (‚àë' n : ‚Ñ§, exp (-œÄ * a * (n : ‚Ñù) ^ 2)) =\n      (1 : ‚Ñù) / a ^ (1 / 2 : ‚Ñù) * (‚àë' n : ‚Ñ§, exp (-œÄ / a * (n : ‚Ñù) ^ 2)) := by\n  simpa only [‚Üê ofReal_inj, ofReal_tsum, ofReal_exp, ofReal_mul, ofReal_neg, ofReal_pow,\n    ofReal_intCast, ofReal_div, ofReal_one, ofReal_cpow ha.le, ofReal_ofNat, mul_zero, zero_mul,\n    add_zero] using Complex.tsum_exp_neg_quadratic (by rwa [ofReal_re] : 0 < (a : ‚ÑÇ).re) 0\n\n"}
