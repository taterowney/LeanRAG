{"name":"Polynomial.trinomial_def","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk m n : Nat\nu v w : R\n⊢ Eq (Polynomial.trinomial k m n u v w) (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Polynomial.C u) (HPow.hPow Polynomial.X k)) (HMul.hMul (Polynomial.C v) (HPow.hPow Polynomial.X m))) (HMul.hMul (Polynomial.C w) (HPow.hPow Polynomial.X n)))","decl":"theorem trinomial_def : trinomial k m n u v w = C u * X ^ k + C v * X ^ m + C w * X ^ n :=\n  rfl\n\n"}
{"name":"Polynomial.trinomial_leading_coeff'","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk m n : Nat\nu v w : R\nhkm : LT.lt k m\nhmn : LT.lt m n\n⊢ Eq ((Polynomial.trinomial k m n u v w).coeff n) w","decl":"theorem trinomial_leading_coeff' (hkm : k < m) (hmn : m < n) :\n    (trinomial k m n u v w).coeff n = w := by\n  rw [trinomial_def, coeff_add, coeff_add, coeff_C_mul_X_pow, coeff_C_mul_X_pow, coeff_C_mul_X_pow,\n    if_neg (hkm.trans hmn).ne', if_neg hmn.ne', if_pos rfl, zero_add, zero_add]\n\n"}
{"name":"Polynomial.trinomial_middle_coeff","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk m n : Nat\nu v w : R\nhkm : LT.lt k m\nhmn : LT.lt m n\n⊢ Eq ((Polynomial.trinomial k m n u v w).coeff m) v","decl":"theorem trinomial_middle_coeff (hkm : k < m) (hmn : m < n) :\n    (trinomial k m n u v w).coeff m = v := by\n  rw [trinomial_def, coeff_add, coeff_add, coeff_C_mul_X_pow, coeff_C_mul_X_pow, coeff_C_mul_X_pow,\n    if_neg hkm.ne', if_pos rfl, if_neg hmn.ne, zero_add, add_zero]\n\n"}
{"name":"Polynomial.trinomial_trailing_coeff'","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk m n : Nat\nu v w : R\nhkm : LT.lt k m\nhmn : LT.lt m n\n⊢ Eq ((Polynomial.trinomial k m n u v w).coeff k) u","decl":"theorem trinomial_trailing_coeff' (hkm : k < m) (hmn : m < n) :\n    (trinomial k m n u v w).coeff k = u := by\n  rw [trinomial_def, coeff_add, coeff_add, coeff_C_mul_X_pow, coeff_C_mul_X_pow, coeff_C_mul_X_pow,\n    if_pos rfl, if_neg hkm.ne, if_neg (hkm.trans hmn).ne, add_zero, add_zero]\n\n"}
{"name":"Polynomial.trinomial_natDegree","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk m n : Nat\nu v w : R\nhkm : LT.lt k m\nhmn : LT.lt m n\nhw : Ne w 0\n⊢ Eq (Polynomial.trinomial k m n u v w).natDegree n","decl":"theorem trinomial_natDegree (hkm : k < m) (hmn : m < n) (hw : w ≠ 0) :\n    (trinomial k m n u v w).natDegree = n := by\n  refine\n    natDegree_eq_of_degree_eq_some\n      ((Finset.sup_le fun i h => ?_).antisymm <|\n        le_degree_of_ne_zero <| by rwa [trinomial_leading_coeff' hkm hmn])\n  replace h := support_trinomial' k m n u v w h\n  rw [mem_insert, mem_insert, mem_singleton] at h\n  rcases h with (rfl | rfl | rfl)\n  · exact WithBot.coe_le_coe.mpr (hkm.trans hmn).le\n  · exact WithBot.coe_le_coe.mpr hmn.le\n  · exact le_rfl\n\n"}
{"name":"Polynomial.trinomial_natTrailingDegree","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk m n : Nat\nu v w : R\nhkm : LT.lt k m\nhmn : LT.lt m n\nhu : Ne u 0\n⊢ Eq (Polynomial.trinomial k m n u v w).natTrailingDegree k","decl":"theorem trinomial_natTrailingDegree (hkm : k < m) (hmn : m < n) (hu : u ≠ 0) :\n    (trinomial k m n u v w).natTrailingDegree = k := by\n  refine\n    natTrailingDegree_eq_of_trailingDegree_eq_some\n      ((Finset.le_inf fun i h => ?_).antisymm <|\n          trailingDegree_le_of_ne_zero <| by rwa [trinomial_trailing_coeff' hkm hmn]).symm\n  replace h := support_trinomial' k m n u v w h\n  rw [mem_insert, mem_insert, mem_singleton] at h\n  rcases h with (rfl | rfl | rfl)\n  · exact le_rfl\n  · exact WithTop.coe_le_coe.mpr hkm.le\n  · exact WithTop.coe_le_coe.mpr (hkm.trans hmn).le\n\n"}
{"name":"Polynomial.trinomial_leadingCoeff","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk m n : Nat\nu v w : R\nhkm : LT.lt k m\nhmn : LT.lt m n\nhw : Ne w 0\n⊢ Eq (Polynomial.trinomial k m n u v w).leadingCoeff w","decl":"theorem trinomial_leadingCoeff (hkm : k < m) (hmn : m < n) (hw : w ≠ 0) :\n    (trinomial k m n u v w).leadingCoeff = w := by\n  rw [leadingCoeff, trinomial_natDegree hkm hmn hw, trinomial_leading_coeff' hkm hmn]\n\n"}
{"name":"Polynomial.trinomial_trailingCoeff","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk m n : Nat\nu v w : R\nhkm : LT.lt k m\nhmn : LT.lt m n\nhu : Ne u 0\n⊢ Eq (Polynomial.trinomial k m n u v w).trailingCoeff u","decl":"theorem trinomial_trailingCoeff (hkm : k < m) (hmn : m < n) (hu : u ≠ 0) :\n    (trinomial k m n u v w).trailingCoeff = u := by\n  rw [trailingCoeff, trinomial_natTrailingDegree hkm hmn hu, trinomial_trailing_coeff' hkm hmn]\n\n"}
{"name":"Polynomial.trinomial_monic","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk m n : Nat\nu v : R\nhkm : LT.lt k m\nhmn : LT.lt m n\n⊢ (Polynomial.trinomial k m n u v 1).Monic","decl":"theorem trinomial_monic (hkm : k < m) (hmn : m < n) : (trinomial k m n u v 1).Monic := by\n  nontriviality R\n  exact trinomial_leadingCoeff hkm hmn one_ne_zero\n\n"}
{"name":"Polynomial.trinomial_mirror","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk m n : Nat\nu v w : R\nhkm : LT.lt k m\nhmn : LT.lt m n\nhu : Ne u 0\nhw : Ne w 0\n⊢ Eq (Polynomial.trinomial k m n u v w).mirror (Polynomial.trinomial k (HAdd.hAdd (HSub.hSub n m) k) n w v u)","decl":"theorem trinomial_mirror (hkm : k < m) (hmn : m < n) (hu : u ≠ 0) (hw : w ≠ 0) :\n    (trinomial k m n u v w).mirror = trinomial k (n - m + k) n w v u := by\n  rw [mirror, trinomial_natTrailingDegree hkm hmn hu, reverse, trinomial_natDegree hkm hmn hw,\n    trinomial_def, reflect_add, reflect_add, reflect_C_mul_X_pow, reflect_C_mul_X_pow,\n    reflect_C_mul_X_pow, revAt_le (hkm.trans hmn).le, revAt_le hmn.le, revAt_le le_rfl, add_mul,\n    add_mul, mul_assoc, mul_assoc, mul_assoc, ← pow_add, ← pow_add, ← pow_add,\n    Nat.sub_add_cancel (hkm.trans hmn).le, Nat.sub_self, zero_add, add_comm, add_comm (C u * X ^ n),\n    ← add_assoc, ← trinomial_def]\n\n"}
{"name":"Polynomial.trinomial_support","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nk m n : Nat\nu v w : R\nhkm : LT.lt k m\nhmn : LT.lt m n\nhu : Ne u 0\nhv : Ne v 0\nhw : Ne w 0\n⊢ Eq (Polynomial.trinomial k m n u v w).support (Insert.insert k (Insert.insert m (Singleton.singleton n)))","decl":"theorem trinomial_support (hkm : k < m) (hmn : m < n) (hu : u ≠ 0) (hv : v ≠ 0) (hw : w ≠ 0) :\n    (trinomial k m n u v w).support = {k, m, n} :=\n  support_trinomial hkm hmn hu hv hw\n\n"}
{"name":"Polynomial.IsUnitTrinomial.not_isUnit","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p : Polynomial Int\nhp : p.IsUnitTrinomial\n⊢ Not (IsUnit p)","decl":"theorem not_isUnit (hp : p.IsUnitTrinomial) : ¬IsUnit p := by\n  obtain ⟨k, m, n, hkm, hmn, u, v, w, rfl⟩ := hp\n  exact fun h =>\n    ne_zero_of_lt hmn\n      ((trinomial_natDegree hkm hmn w.ne_zero).symm.trans\n        (natDegree_eq_of_degree_eq_some (degree_eq_zero_of_isUnit h)))\n\n"}
{"name":"Polynomial.IsUnitTrinomial.card_support_eq_three","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p : Polynomial Int\nhp : p.IsUnitTrinomial\n⊢ Eq p.support.card 3","decl":"theorem card_support_eq_three (hp : p.IsUnitTrinomial) : #p.support = 3 := by\n  obtain ⟨k, m, n, hkm, hmn, u, v, w, rfl⟩ := hp\n  exact card_support_trinomial hkm hmn u.ne_zero v.ne_zero w.ne_zero\n\n"}
{"name":"Polynomial.IsUnitTrinomial.ne_zero","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p : Polynomial Int\nhp : p.IsUnitTrinomial\n⊢ Ne p 0","decl":"theorem ne_zero (hp : p.IsUnitTrinomial) : p ≠ 0 := by\n  rintro rfl\n  simpa using hp.card_support_eq_three\n\n"}
{"name":"Polynomial.IsUnitTrinomial.coeff_isUnit","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p : Polynomial Int\nhp : p.IsUnitTrinomial\nk : Nat\nhk : Membership.mem p.support k\n⊢ IsUnit (p.coeff k)","decl":"theorem coeff_isUnit (hp : p.IsUnitTrinomial) {k : ℕ} (hk : k ∈ p.support) :\n    IsUnit (p.coeff k) := by\n  obtain ⟨k, m, n, hkm, hmn, u, v, w, rfl⟩ := hp\n  have := support_trinomial' k m n (u : ℤ) v w hk\n  rw [mem_insert, mem_insert, mem_singleton] at this\n  rcases this with (rfl | rfl | rfl)\n  · refine ⟨u, by rw [trinomial_trailing_coeff' hkm hmn]⟩\n  · refine ⟨v, by rw [trinomial_middle_coeff hkm hmn]⟩\n  · refine ⟨w, by rw [trinomial_leading_coeff' hkm hmn]⟩\n\n"}
{"name":"Polynomial.IsUnitTrinomial.leadingCoeff_isUnit","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p : Polynomial Int\nhp : p.IsUnitTrinomial\n⊢ IsUnit p.leadingCoeff","decl":"theorem leadingCoeff_isUnit (hp : p.IsUnitTrinomial) : IsUnit p.leadingCoeff :=\n  hp.coeff_isUnit (natDegree_mem_support_of_nonzero hp.ne_zero)\n\n"}
{"name":"Polynomial.IsUnitTrinomial.trailingCoeff_isUnit","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p : Polynomial Int\nhp : p.IsUnitTrinomial\n⊢ IsUnit p.trailingCoeff","decl":"theorem trailingCoeff_isUnit (hp : p.IsUnitTrinomial) : IsUnit p.trailingCoeff :=\n  hp.coeff_isUnit (natTrailingDegree_mem_support_of_nonzero hp.ne_zero)\n\n"}
{"name":"Polynomial.isUnitTrinomial_iff","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p : Polynomial Int\n⊢ Iff p.IsUnitTrinomial (And (Eq p.support.card 3) (∀ (k : Nat), Membership.mem p.support k → IsUnit (p.coeff k)))","decl":"theorem isUnitTrinomial_iff :\n    p.IsUnitTrinomial ↔ #p.support = 3 ∧ ∀ k ∈ p.support, IsUnit (p.coeff k) := by\n  refine ⟨fun hp => ⟨hp.card_support_eq_three, fun k => hp.coeff_isUnit⟩, fun hp => ?_⟩\n  obtain ⟨k, m, n, hkm, hmn, x, y, z, hx, hy, hz, rfl⟩ := card_support_eq_three.mp hp.1\n  rw [support_trinomial hkm hmn hx hy hz] at hp\n  replace hx := hp.2 k (mem_insert_self k {m, n})\n  replace hy := hp.2 m (mem_insert_of_mem (mem_insert_self m {n}))\n  replace hz := hp.2 n (mem_insert_of_mem (mem_insert_of_mem (mem_singleton_self n)))\n  simp_rw [coeff_add, coeff_C_mul, coeff_X_pow_self, mul_one, coeff_X_pow] at hx hy hz\n  rw [if_neg hkm.ne, if_neg (hkm.trans hmn).ne] at hx\n  rw [if_neg hkm.ne', if_neg hmn.ne] at hy\n  rw [if_neg (hkm.trans hmn).ne', if_neg hmn.ne'] at hz\n  simp_rw [mul_zero, zero_add, add_zero] at hx hy hz\n  exact ⟨k, m, n, hkm, hmn, hx.unit, hy.unit, hz.unit, rfl⟩\n\n"}
{"name":"Polynomial.isUnitTrinomial_iff'","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p : Polynomial Int\n⊢ Iff p.IsUnitTrinomial (Eq ((HMul.hMul p p.mirror).coeff (HDiv.hDiv (HAdd.hAdd (HMul.hMul p p.mirror).natDegree (HMul.hMul p p.mirror).natTrailingDegree) 2)) 3)","decl":"theorem isUnitTrinomial_iff' :\n    p.IsUnitTrinomial ↔\n      (p * p.mirror).coeff (((p * p.mirror).natDegree + (p * p.mirror).natTrailingDegree) / 2) =\n        3 := by\n  rw [natDegree_mul_mirror, natTrailingDegree_mul_mirror, ← mul_add,\n    Nat.mul_div_right _ zero_lt_two, coeff_mul_mirror]\n  refine ⟨?_, fun hp => ?_⟩\n  · rintro ⟨k, m, n, hkm, hmn, u, v, w, rfl⟩\n    rw [sum_def, trinomial_support hkm hmn u.ne_zero v.ne_zero w.ne_zero,\n      sum_insert (mt mem_insert.mp (not_or_intro hkm.ne (mt mem_singleton.mp (hkm.trans hmn).ne))),\n      sum_insert (mt mem_singleton.mp hmn.ne), sum_singleton, trinomial_leading_coeff' hkm hmn,\n      trinomial_middle_coeff hkm hmn, trinomial_trailing_coeff' hkm hmn]\n    simp_rw [← Units.val_pow_eq_pow_val, Int.units_sq, Units.val_one]\n    decide\n  · have key : ∀ k ∈ p.support, p.coeff k ^ 2 = 1 := fun k hk =>\n      Int.sq_eq_one_of_sq_le_three\n        ((single_le_sum (fun k _ => sq_nonneg (p.coeff k)) hk).trans hp.le) (mem_support_iff.mp hk)\n    refine isUnitTrinomial_iff.mpr ⟨?_, fun k hk => isUnit_ofPowEqOne (key k hk) two_ne_zero⟩\n    rw [sum_def, sum_congr rfl key, sum_const, Nat.smul_one_eq_cast] at hp\n    exact Nat.cast_injective hp\n\n"}
{"name":"Polynomial.isUnitTrinomial_iff''","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p q : Polynomial Int\nh : Eq (HMul.hMul p p.mirror) (HMul.hMul q q.mirror)\n⊢ Iff p.IsUnitTrinomial q.IsUnitTrinomial","decl":"theorem isUnitTrinomial_iff'' (h : p * p.mirror = q * q.mirror) :\n    p.IsUnitTrinomial ↔ q.IsUnitTrinomial := by\n  rw [isUnitTrinomial_iff', isUnitTrinomial_iff', h]\n\n"}
{"name":"Polynomial.IsUnitTrinomial.irreducible_aux1","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p : Polynomial Int\nk m n : Nat\nhkm : LT.lt k m\nhmn : LT.lt m n\nu v w : Units Int\nhp : Eq p (Polynomial.trinomial k m n ↑u ↑v ↑w)\n⊢ Eq (HMul.hMul (Polynomial.C ↑v) (HAdd.hAdd (HMul.hMul (Polynomial.C ↑u) (HPow.hPow Polynomial.X (HAdd.hAdd m n))) (HMul.hMul (Polynomial.C ↑w) (HPow.hPow Polynomial.X (HAdd.hAdd (HAdd.hAdd (HSub.hSub n m) k) n))))) { toFinsupp := Finsupp.filter (fun x => Membership.mem (Set.Ioo (HAdd.hAdd k n) (HAdd.hAdd n n)) x) (HMul.hMul p p.mirror).toFinsupp }","decl":"theorem irreducible_aux1 {k m n : ℕ} (hkm : k < m) (hmn : m < n) (u v w : Units ℤ)\n    (hp : p = trinomial k m n (u : ℤ) v w) :\n    C (v : ℤ) * (C (u : ℤ) * X ^ (m + n) + C (w : ℤ) * X ^ (n - m + k + n)) =\n      ⟨Finsupp.filter (· ∈ Set.Ioo (k + n) (n + n)) (p * p.mirror).toFinsupp⟩ := by\n  have key : n - m + k < n := by rwa [← lt_tsub_iff_right, tsub_lt_tsub_iff_left_of_le hmn.le]\n  rw [hp, trinomial_mirror hkm hmn u.ne_zero w.ne_zero]\n  simp_rw [trinomial_def, C_mul_X_pow_eq_monomial, add_mul, mul_add, monomial_mul_monomial,\n    toFinsupp_add, toFinsupp_monomial]\n  -- Porting note: added next line (less powerful `simp`).\n  rw [Finsupp.filter_add, Finsupp.filter_add, Finsupp.filter_add, Finsupp.filter_add,\n    Finsupp.filter_add, Finsupp.filter_add, Finsupp.filter_add, Finsupp.filter_add]\n  rw [Finsupp.filter_single_of_neg, Finsupp.filter_single_of_neg, Finsupp.filter_single_of_neg,\n    Finsupp.filter_single_of_neg, Finsupp.filter_single_of_neg, Finsupp.filter_single_of_pos,\n    Finsupp.filter_single_of_neg, Finsupp.filter_single_of_pos, Finsupp.filter_single_of_neg]\n  · simp only [add_zero, zero_add, ofFinsupp_add, ofFinsupp_single]\n    -- Porting note: added next two lines (less powerful `simp`).\n    rw [ofFinsupp_add]\n    simp only [ofFinsupp_single]\n    rw [C_mul_monomial, C_mul_monomial, mul_comm (v : ℤ) w, add_comm (n - m + k) n]\n  · exact fun h => h.2.ne rfl\n  · refine ⟨?_, add_lt_add_left key n⟩\n    rwa [add_comm, add_lt_add_iff_left, lt_add_iff_pos_left, tsub_pos_iff_lt]\n  · exact fun h => h.1.ne (add_comm k n)\n  · exact ⟨add_lt_add_right hkm n, add_lt_add_right hmn n⟩\n  · rw [← add_assoc, add_tsub_cancel_of_le hmn.le, add_comm]\n    exact fun h => h.1.ne rfl\n  · intro h\n    have := h.1\n    rw [add_comm, add_lt_add_iff_right] at this\n    exact asymm this hmn\n  · exact fun h => h.1.ne rfl\n  · exact fun h => asymm ((add_lt_add_iff_left k).mp h.1) key\n  · exact fun h => asymm ((add_lt_add_iff_left k).mp h.1) (hkm.trans hmn)\n\n"}
{"name":"Polynomial.IsUnitTrinomial.irreducible_aux2","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p q : Polynomial Int\nk m m' n : Nat\nhkm : LT.lt k m\nhmn : LT.lt m n\nhkm' : LT.lt k m'\nhmn' : LT.lt m' n\nu v w : Units Int\nhp : Eq p (Polynomial.trinomial k m n ↑u ↑v ↑w)\nhq : Eq q (Polynomial.trinomial k m' n ↑u ↑v ↑w)\nh : Eq (HMul.hMul p p.mirror) (HMul.hMul q q.mirror)\n⊢ Or (Eq q p) (Eq q p.mirror)","decl":"theorem irreducible_aux2 {k m m' n : ℕ} (hkm : k < m) (hmn : m < n) (hkm' : k < m') (hmn' : m' < n)\n    (u v w : Units ℤ) (hp : p = trinomial k m n (u : ℤ) v w) (hq : q = trinomial k m' n (u : ℤ) v w)\n    (h : p * p.mirror = q * q.mirror) : q = p ∨ q = p.mirror := by\n  let f : ℤ[X] → ℤ[X] := fun p => ⟨Finsupp.filter (· ∈ Set.Ioo (k + n) (n + n)) p.toFinsupp⟩\n  replace h := congr_arg f h\n  replace h := (irreducible_aux1 hkm hmn u v w hp).trans h\n  replace h := h.trans (irreducible_aux1 hkm' hmn' u v w hq).symm\n  rw [(isUnit_C.mpr v.isUnit).mul_right_inj] at h\n  rw [binomial_eq_binomial u.ne_zero w.ne_zero] at h\n  simp only [add_left_inj, Units.eq_iff] at h\n  rcases h with (⟨rfl, -⟩ | ⟨rfl, rfl, h⟩ | ⟨-, hm, hm'⟩)\n  · exact Or.inl (hq.trans hp.symm)\n  · refine Or.inr ?_\n    rw [← trinomial_mirror hkm' hmn' u.ne_zero u.ne_zero, eq_comm, mirror_eq_iff] at hp\n    exact hq.trans hp\n  · obtain rfl : m = m' := by omega\n    exact Or.inl (hq.trans hp.symm)\n\n"}
{"name":"Polynomial.IsUnitTrinomial.irreducible_aux3","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p q : Polynomial Int\nk m m' n : Nat\nhkm : LT.lt k m\nhmn : LT.lt m n\nhkm' : LT.lt k m'\nhmn' : LT.lt m' n\nu v w x z : Units Int\nhp : Eq p (Polynomial.trinomial k m n ↑u ↑v ↑w)\nhq : Eq q (Polynomial.trinomial k m' n ↑x ↑v ↑z)\nh : Eq (HMul.hMul p p.mirror) (HMul.hMul q q.mirror)\n⊢ Or (Eq q p) (Eq q p.mirror)","decl":"theorem irreducible_aux3 {k m m' n : ℕ} (hkm : k < m) (hmn : m < n) (hkm' : k < m') (hmn' : m' < n)\n    (u v w x z : Units ℤ) (hp : p = trinomial k m n (u : ℤ) v w)\n    (hq : q = trinomial k m' n (x : ℤ) v z) (h : p * p.mirror = q * q.mirror) :\n    q = p ∨ q = p.mirror := by\n  have hmul := congr_arg leadingCoeff h\n  rw [leadingCoeff_mul, leadingCoeff_mul, mirror_leadingCoeff, mirror_leadingCoeff, hp, hq,\n    trinomial_leadingCoeff hkm hmn w.ne_zero, trinomial_leadingCoeff hkm' hmn' z.ne_zero,\n    trinomial_trailingCoeff hkm hmn u.ne_zero, trinomial_trailingCoeff hkm' hmn' x.ne_zero]\n    at hmul\n  have hadd := congr_arg (eval 1) h\n  rw [eval_mul, eval_mul, mirror_eval_one, mirror_eval_one, ← sq, ← sq, hp, hq] at hadd\n  simp only [eval_add, eval_C_mul, eval_pow, eval_X, one_pow, mul_one, trinomial_def] at hadd\n  rw [add_assoc, add_assoc, add_comm (u : ℤ), add_comm (x : ℤ), add_assoc, add_assoc] at hadd\n  simp only [add_sq', add_assoc, add_right_inj, ← Units.val_pow_eq_pow_val, Int.units_sq] at hadd\n  rw [mul_assoc, hmul, ← mul_assoc, add_right_inj,\n    mul_right_inj' (show 2 * (v : ℤ) ≠ 0 from mul_ne_zero two_ne_zero v.ne_zero)] at hadd\n  replace hadd :=\n    (Int.isUnit_add_isUnit_eq_isUnit_add_isUnit w.isUnit u.isUnit z.isUnit x.isUnit).mp hadd\n  simp only [Units.eq_iff] at hadd\n  rcases hadd with (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩)\n  · exact irreducible_aux2 hkm hmn hkm' hmn' u v w hp hq h\n  · rw [← mirror_inj, trinomial_mirror hkm' hmn' w.ne_zero u.ne_zero] at hq\n    rw [mul_comm q, ← q.mirror_mirror, q.mirror.mirror_mirror] at h\n    rw [← mirror_inj, or_comm, ← mirror_eq_iff]\n    exact\n      irreducible_aux2 hkm hmn (lt_add_of_pos_left k (tsub_pos_of_lt hmn'))\n        (lt_tsub_iff_right.mp ((tsub_lt_tsub_iff_left_of_le hmn'.le).mpr hkm')) u v w hp hq h\n\n"}
{"name":"Polynomial.IsUnitTrinomial.irreducible_of_coprime","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p : Polynomial Int\nhp : p.IsUnitTrinomial\nh : IsRelPrime p p.mirror\n⊢ Irreducible p","decl":"theorem irreducible_of_coprime (hp : p.IsUnitTrinomial)\n    (h : IsRelPrime p p.mirror) : Irreducible p := by\n  refine irreducible_of_mirror hp.not_isUnit (fun q hpq => ?_) h\n  have hq : IsUnitTrinomial q := (isUnitTrinomial_iff'' hpq).mp hp\n  obtain ⟨k, m, n, hkm, hmn, u, v, w, hp⟩ := hp\n  obtain ⟨k', m', n', hkm', hmn', x, y, z, hq⟩ := hq\n  have hk : k = k' := by\n    rw [← mul_right_inj' (show 2 ≠ 0 from two_ne_zero), ←\n      trinomial_natTrailingDegree hkm hmn u.ne_zero, ← hp, ← natTrailingDegree_mul_mirror, hpq,\n      natTrailingDegree_mul_mirror, hq, trinomial_natTrailingDegree hkm' hmn' x.ne_zero]\n  have hn : n = n' := by\n    rw [← mul_right_inj' (show 2 ≠ 0 from two_ne_zero), ← trinomial_natDegree hkm hmn w.ne_zero, ←\n      hp, ← natDegree_mul_mirror, hpq, natDegree_mul_mirror, hq,\n      trinomial_natDegree hkm' hmn' z.ne_zero]\n  subst hk\n  subst hn\n  rcases eq_or_eq_neg_of_sq_eq_sq (y : ℤ) (v : ℤ)\n      ((Int.isUnit_sq y.isUnit).trans (Int.isUnit_sq v.isUnit).symm) with\n    (h1 | h1)\n  · -- Porting note: `rw [h1] at *` rewrites at `h1`\n    rw [h1] at hq\n    rcases irreducible_aux3 hkm hmn hkm' hmn' u v w x z hp hq hpq with (h2 | h2)\n    · exact Or.inl h2\n    · exact Or.inr (Or.inr (Or.inl h2))\n  · -- Porting note: `rw [h1] at *` rewrites at `h1`\n    rw [h1] at hq\n    rw [trinomial_def] at hp\n    rw [← neg_inj, neg_add, neg_add, ← neg_mul, ← neg_mul, ← neg_mul, ← C_neg, ← C_neg, ← C_neg]\n      at hp\n    rw [← neg_mul_neg, ← mirror_neg] at hpq\n    rcases irreducible_aux3 hkm hmn hkm' hmn' (-u) (-v) (-w) x z hp hq hpq with (rfl | rfl)\n    · exact Or.inr (Or.inl rfl)\n    · exact Or.inr (Or.inr (Or.inr p.mirror_neg))\n\n"}
{"name":"Polynomial.IsUnitTrinomial.irreducible_of_isCoprime","module":"Mathlib.Algebra.Polynomial.UnitTrinomial","initialProofState":"p : Polynomial Int\nhp : p.IsUnitTrinomial\nh : IsCoprime p p.mirror\n⊢ Irreducible p","decl":"/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem irreducible_of_isCoprime (hp : p.IsUnitTrinomial) (h : IsCoprime p p.mirror) :\n    Irreducible p :=\n  irreducible_of_coprime hp fun _ => h.isUnit_of_dvd'\n\n"}
