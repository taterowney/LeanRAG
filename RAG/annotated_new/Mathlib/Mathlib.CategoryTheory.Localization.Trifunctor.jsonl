{"name":"CategoryTheory.Localization.lift₃NatTrans_app_app_app","module":"Mathlib.CategoryTheory.Localization.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_6\nD₂ : Type u_7\nD₃ : Type u_8\nE : Type u_13\ninst✝¹⁴ : CategoryTheory.Category.{u_18, u_1} C₁\ninst✝¹³ : CategoryTheory.Category.{u_19, u_2} C₂\ninst✝¹² : CategoryTheory.Category.{u_20, u_3} C₃\ninst✝¹¹ : CategoryTheory.Category.{u_17, u_6} D₁\ninst✝¹⁰ : CategoryTheory.Category.{u_16, u_7} D₂\ninst✝⁹ : CategoryTheory.Category.{u_15, u_8} D₃\ninst✝⁸ : CategoryTheory.Category.{u_14, u_13} E\nL₁ : CategoryTheory.Functor C₁ D₁\nL₂ : CategoryTheory.Functor C₂ D₂\nL₃ : CategoryTheory.Functor C₃ D₃\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nW₃ : CategoryTheory.MorphismProperty C₃\ninst✝⁷ : L₁.IsLocalization W₁\ninst✝⁶ : L₂.IsLocalization W₂\ninst✝⁵ : L₃.IsLocalization W₃\ninst✝⁴ : W₁.ContainsIdentities\ninst✝³ : W₂.ContainsIdentities\ninst✝² : W₃.ContainsIdentities\nF₁ F₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ E))\nF₁' F₂' : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\ninst✝¹ : CategoryTheory.Localization.Lifting₃ L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₁'\ninst✝ : CategoryTheory.Localization.Lifting₃ L₁ L₂ L₃ W₁ W₂ W₃ F₂ F₂'\nτ : Quiver.Hom F₁ F₂\nX₁ : C₁\nX₂ : C₂\nX₃ : C₃\n⊢ Eq ((((CategoryTheory.Localization.lift₃NatTrans L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₂ F₁' F₂' τ).app (L₁.obj X₁)).app (L₂.obj X₂)).app (L₃.obj X₃)) (CategoryTheory.CategoryStruct.comp ((((CategoryTheory.Localization.Lifting₃.iso L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₁').hom.app X₁).app X₂).app X₃) (CategoryTheory.CategoryStruct.comp (((τ.app X₁).app X₂).app X₃) ((((CategoryTheory.Localization.Lifting₃.iso L₁ L₂ L₃ W₁ W₂ W₃ F₂ F₂').inv.app X₁).app X₂).app X₃)))","decl":"@[simp]\ntheorem lift₃NatTrans_app_app_app (X₁ : C₁) (X₂ : C₂) (X₃ : C₃) :\n    (((lift₃NatTrans L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₂ F₁' F₂' τ).app\n        (L₁.obj X₁)).app (L₂.obj X₂)).app (L₃.obj X₃) =\n      (((Lifting₃.iso L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₁').hom.app X₁).app X₂).app X₃ ≫\n        ((τ.app X₁).app X₂).app X₃ ≫\n        (((Lifting₃.iso L₁ L₂ L₃ W₁ W₂ W₃ F₂ F₂').inv.app X₁).app X₂).app X₃ := by\n  dsimp [lift₃NatTrans, fullyFaithfulUncurry₃, Equivalence.fullyFaithfulFunctor]\n  simp only [currying₃_unitIso_hom_app_app_app_app, Functor.id_obj,\n    currying₃_unitIso_inv_app_app_app_app, Functor.comp_obj,\n    Category.comp_id, Category.id_comp]\n  exact liftNatTrans_app _ _ _ _ (uncurry₃.obj F₁') (uncurry₃.obj F₂') (uncurry₃.map τ) ⟨X₁, X₂, X₃⟩\n\n"}
{"name":"CategoryTheory.Localization.natTrans₃_ext","module":"Mathlib.CategoryTheory.Localization.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_6\nD₂ : Type u_7\nD₃ : Type u_8\nE : Type u_13\ninst✝¹² : CategoryTheory.Category.{u_18, u_1} C₁\ninst✝¹¹ : CategoryTheory.Category.{u_19, u_2} C₂\ninst✝¹⁰ : CategoryTheory.Category.{u_20, u_3} C₃\ninst✝⁹ : CategoryTheory.Category.{u_15, u_6} D₁\ninst✝⁸ : CategoryTheory.Category.{u_16, u_7} D₂\ninst✝⁷ : CategoryTheory.Category.{u_17, u_8} D₃\ninst✝⁶ : CategoryTheory.Category.{u_14, u_13} E\nL₁ : CategoryTheory.Functor C₁ D₁\nL₂ : CategoryTheory.Functor C₂ D₂\nL₃ : CategoryTheory.Functor C₃ D₃\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nW₃ : CategoryTheory.MorphismProperty C₃\ninst✝⁵ : L₁.IsLocalization W₁\ninst✝⁴ : L₂.IsLocalization W₂\ninst✝³ : L₃.IsLocalization W₃\ninst✝² : W₁.ContainsIdentities\ninst✝¹ : W₂.ContainsIdentities\ninst✝ : W₃.ContainsIdentities\nF₁' F₂' : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nτ τ' : Quiver.Hom F₁' F₂'\nh : ∀ (X₁ : C₁) (X₂ : C₂) (X₃ : C₃), Eq (((τ.app (L₁.obj X₁)).app (L₂.obj X₂)).app (L₃.obj X₃)) (((τ'.app (L₁.obj X₁)).app (L₂.obj X₂)).app (L₃.obj X₃))\n⊢ Eq τ τ'","decl":"variable {F₁' F₂'} in\ninclude W₁ W₂ W₃ in\ntheorem natTrans₃_ext {τ τ' : F₁' ⟶ F₂'}\n    (h : ∀ (X₁ : C₁) (X₂ : C₂) (X₃ : C₃), ((τ.app (L₁.obj X₁)).app (L₂.obj X₂)).app (L₃.obj X₃) =\n      ((τ'.app (L₁.obj X₁)).app (L₂.obj X₂)).app (L₃.obj X₃)) : τ = τ' :=\n  uncurry₃.map_injective (natTrans_ext (L₁.prod (L₂.prod L₃)) (W₁.prod (W₂.prod W₃))\n    (fun _ ↦ h _ _ _))\n\n"}
{"name":"CategoryTheory.Localization.lift₃NatIso_hom","module":"Mathlib.CategoryTheory.Localization.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_6\nD₂ : Type u_7\nD₃ : Type u_8\nE : Type u_13\ninst✝¹⁴ : CategoryTheory.Category.{u_14, u_1} C₁\ninst✝¹³ : CategoryTheory.Category.{u_15, u_2} C₂\ninst✝¹² : CategoryTheory.Category.{u_16, u_3} C₃\ninst✝¹¹ : CategoryTheory.Category.{u_17, u_6} D₁\ninst✝¹⁰ : CategoryTheory.Category.{u_18, u_7} D₂\ninst✝⁹ : CategoryTheory.Category.{u_19, u_8} D₃\ninst✝⁸ : CategoryTheory.Category.{u_20, u_13} E\nL₁ : CategoryTheory.Functor C₁ D₁\nL₂ : CategoryTheory.Functor C₂ D₂\nL₃ : CategoryTheory.Functor C₃ D₃\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nW₃ : CategoryTheory.MorphismProperty C₃\ninst✝⁷ : L₁.IsLocalization W₁\ninst✝⁶ : L₂.IsLocalization W₂\ninst✝⁵ : L₃.IsLocalization W₃\ninst✝⁴ : W₁.ContainsIdentities\ninst✝³ : W₂.ContainsIdentities\ninst✝² : W₃.ContainsIdentities\nF₁ F₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ E))\nF₁' F₂' : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\ninst✝¹ : CategoryTheory.Localization.Lifting₃ L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₁'\ninst✝ : CategoryTheory.Localization.Lifting₃ L₁ L₂ L₃ W₁ W₂ W₃ F₂ F₂'\ne : CategoryTheory.Iso F₁ F₂\n⊢ Eq (CategoryTheory.Localization.lift₃NatIso L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₂ F₁' F₂' e).hom (CategoryTheory.Localization.lift₃NatTrans L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₂ F₁' F₂' e.hom)","decl":"/-- The natural isomorphism `F₁' ≅ F₂'` of trifunctors induced by a\nnatural isomorphism `e : F₁ ≅ F₂` when `Lifting₃ L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₁'`\nand `Lifting₃ L₁ L₂ L₃ W₁ W₂ W₃ F₂ F₂'` hold. -/\n@[simps]\nnoncomputable def lift₃NatIso : F₁' ≅ F₂' where\n  hom := lift₃NatTrans L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₂ F₁' F₂' e.hom\n  inv := lift₃NatTrans L₁ L₂ L₃ W₁ W₂ W₃ F₂ F₁ F₂' F₁' e.inv\n  hom_inv_id := natTrans₃_ext L₁ L₂ L₃ W₁ W₂ W₃ (by aesop_cat)\n  inv_hom_id := natTrans₃_ext L₁ L₂ L₃ W₁ W₂ W₃ (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Localization.lift₃NatIso_inv","module":"Mathlib.CategoryTheory.Localization.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_6\nD₂ : Type u_7\nD₃ : Type u_8\nE : Type u_13\ninst✝¹⁴ : CategoryTheory.Category.{u_14, u_1} C₁\ninst✝¹³ : CategoryTheory.Category.{u_15, u_2} C₂\ninst✝¹² : CategoryTheory.Category.{u_16, u_3} C₃\ninst✝¹¹ : CategoryTheory.Category.{u_17, u_6} D₁\ninst✝¹⁰ : CategoryTheory.Category.{u_18, u_7} D₂\ninst✝⁹ : CategoryTheory.Category.{u_19, u_8} D₃\ninst✝⁸ : CategoryTheory.Category.{u_20, u_13} E\nL₁ : CategoryTheory.Functor C₁ D₁\nL₂ : CategoryTheory.Functor C₂ D₂\nL₃ : CategoryTheory.Functor C₃ D₃\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nW₃ : CategoryTheory.MorphismProperty C₃\ninst✝⁷ : L₁.IsLocalization W₁\ninst✝⁶ : L₂.IsLocalization W₂\ninst✝⁵ : L₃.IsLocalization W₃\ninst✝⁴ : W₁.ContainsIdentities\ninst✝³ : W₂.ContainsIdentities\ninst✝² : W₃.ContainsIdentities\nF₁ F₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ E))\nF₁' F₂' : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\ninst✝¹ : CategoryTheory.Localization.Lifting₃ L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₁'\ninst✝ : CategoryTheory.Localization.Lifting₃ L₁ L₂ L₃ W₁ W₂ W₃ F₂ F₂'\ne : CategoryTheory.Iso F₁ F₂\n⊢ Eq (CategoryTheory.Localization.lift₃NatIso L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₂ F₁' F₂' e).inv (CategoryTheory.Localization.lift₃NatTrans L₁ L₂ L₃ W₁ W₂ W₃ F₂ F₁ F₂' F₁' e.inv)","decl":"/-- The natural isomorphism `F₁' ≅ F₂'` of trifunctors induced by a\nnatural isomorphism `e : F₁ ≅ F₂` when `Lifting₃ L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₁'`\nand `Lifting₃ L₁ L₂ L₃ W₁ W₂ W₃ F₂ F₂'` hold. -/\n@[simps]\nnoncomputable def lift₃NatIso : F₁' ≅ F₂' where\n  hom := lift₃NatTrans L₁ L₂ L₃ W₁ W₂ W₃ F₁ F₂ F₁' F₂' e.hom\n  inv := lift₃NatTrans L₁ L₂ L₃ W₁ W₂ W₃ F₂ F₁ F₂' F₁' e.inv\n  hom_inv_id := natTrans₃_ext L₁ L₂ L₃ W₁ W₂ W₃ (by aesop_cat)\n  inv_hom_id := natTrans₃_ext L₁ L₂ L₃ W₁ W₂ W₃ (by aesop_cat)\n\n"}
{"name":"CategoryTheory.Localization.associator_hom_app_app_app","module":"Mathlib.CategoryTheory.Localization.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₁₂ : Type u_4\nC₂₃ : Type u_5\nD₁ : Type u_6\nD₂ : Type u_7\nD₃ : Type u_8\nD₁₂ : Type u_9\nD₂₃ : Type u_10\nC : Type u_11\nD : Type u_12\ninst✝²¹ : CategoryTheory.Category.{u_19, u_1} C₁\ninst✝²⁰ : CategoryTheory.Category.{u_20, u_2} C₂\ninst✝¹⁹ : CategoryTheory.Category.{u_21, u_3} C₃\ninst✝¹⁸ : CategoryTheory.Category.{u_17, u_6} D₁\ninst✝¹⁷ : CategoryTheory.Category.{u_16, u_7} D₂\ninst✝¹⁶ : CategoryTheory.Category.{u_15, u_8} D₃\ninst✝¹⁵ : CategoryTheory.Category.{u_23, u_4} C₁₂\ninst✝¹⁴ : CategoryTheory.Category.{u_24, u_5} C₂₃\ninst✝¹³ : CategoryTheory.Category.{u_18, u_9} D₁₂\ninst✝¹² : CategoryTheory.Category.{u_22, u_10} D₂₃\ninst✝¹¹ : CategoryTheory.Category.{u_25, u_11} C\ninst✝¹⁰ : CategoryTheory.Category.{u_14, u_12} D\nL₁ : CategoryTheory.Functor C₁ D₁\nL₂ : CategoryTheory.Functor C₂ D₂\nL₃ : CategoryTheory.Functor C₃ D₃\nL₁₂ : CategoryTheory.Functor C₁₂ D₁₂\nL₂₃ : CategoryTheory.Functor C₂₃ D₂₃\nL : CategoryTheory.Functor C D\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nW₃ : CategoryTheory.MorphismProperty C₃\nW₁₂ : CategoryTheory.MorphismProperty C₁₂\nW₂₃ : CategoryTheory.MorphismProperty C₂₃\ninst✝⁹ : W₁.ContainsIdentities\ninst✝⁸ : W₂.ContainsIdentities\ninst✝⁷ : W₃.ContainsIdentities\ninst✝⁶ : L₁.IsLocalization W₁\ninst✝⁵ : L₂.IsLocalization W₂\ninst✝⁴ : L₃.IsLocalization W₃\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C)\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\niso : CategoryTheory.Iso (CategoryTheory.bifunctorComp₁₂ F₁₂ G) (CategoryTheory.bifunctorComp₂₃ F G₂₃)\nF₁₂' : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ D₁₂)\nG' : CategoryTheory.Functor D₁₂ (CategoryTheory.Functor D₃ D)\nF' : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂₃ D)\nG₂₃' : CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ D₂₃)\ninst✝³ : CategoryTheory.Localization.Lifting₂ L₁ L₂ W₁ W₂ (F₁₂.comp ((CategoryTheory.whiskeringRight C₂ C₁₂ D₁₂).obj L₁₂)) F₁₂'\ninst✝² : CategoryTheory.Localization.Lifting₂ L₁₂ L₃ W₁₂ W₃ (G.comp ((CategoryTheory.whiskeringRight C₃ C D).obj L)) G'\ninst✝¹ : CategoryTheory.Localization.Lifting₂ L₁ L₂₃ W₁ W₂₃ (F.comp ((CategoryTheory.whiskeringRight C₂₃ C D).obj L)) F'\ninst✝ : CategoryTheory.Localization.Lifting₂ L₂ L₃ W₂ W₃ (G₂₃.comp ((CategoryTheory.whiskeringRight C₃ C₂₃ D₂₃).obj L₂₃)) G₂₃'\nX₁ : C₁\nX₂ : C₂\nX₃ : C₃\n⊢ Eq ((((CategoryTheory.Localization.associator L₁ L₂ L₃ L₁₂ L₂₃ L W₁ W₂ W₃ W₁₂ W₂₃ iso F₁₂' G' F' G₂₃').hom.app (L₁.obj X₁)).app (L₂.obj X₂)).app (L₃.obj X₃)) (CategoryTheory.CategoryStruct.comp ((G'.map (((CategoryTheory.Localization.Lifting₂.iso L₁ L₂ W₁ W₂ (F₁₂.comp ((CategoryTheory.whiskeringRight C₂ C₁₂ D₁₂).obj L₁₂)) F₁₂').hom.app X₁).app X₂)).app (L₃.obj X₃)) (CategoryTheory.CategoryStruct.comp (((CategoryTheory.Localization.Lifting₂.iso L₁₂ L₃ W₁₂ W₃ (G.comp ((CategoryTheory.whiskeringRight C₃ C D).obj L)) G').hom.app ((F₁₂.obj X₁).obj X₂)).app X₃) (CategoryTheory.CategoryStruct.comp (L.map (((iso.hom.app X₁).app X₂).app X₃)) (CategoryTheory.CategoryStruct.comp (((CategoryTheory.Localization.Lifting₂.iso L₁ L₂₃ W₁ W₂₃ (F.comp ((CategoryTheory.whiskeringRight C₂₃ C D).obj L)) F').inv.app X₁).app ((G₂₃.obj X₂).obj X₃)) ((F'.obj (L₁.obj X₁)).map (((CategoryTheory.Localization.Lifting₂.iso L₂ L₃ W₂ W₃ (G₂₃.comp ((CategoryTheory.whiskeringRight C₃ C₂₃ D₂₃).obj L₂₃)) G₂₃').inv.app X₂).app X₃))))))","decl":"lemma associator_hom_app_app_app (X₁ : C₁) (X₂ : C₂) (X₃ : C₃) :\n    (((associator L₁ L₂ L₃ L₁₂ L₂₃ L W₁ W₂ W₃ W₁₂ W₂₃ iso F₁₂' G' F' G₂₃').hom.app (L₁.obj X₁)).app\n      (L₂.obj X₂)).app (L₃.obj X₃) =\n        (G'.map (((Lifting₂.iso L₁ L₂ W₁ W₂\n          (F₁₂ ⋙ (whiskeringRight C₂ C₁₂ D₁₂).obj L₁₂) F₁₂').hom.app X₁).app X₂)).app (L₃.obj X₃) ≫\n          ((Lifting₂.iso L₁₂ L₃ W₁₂ W₃ (G ⋙ (whiskeringRight C₃ C D).obj L) G').hom.app\n              ((F₁₂.obj X₁).obj X₂)).app X₃ ≫\n            L.map (((iso.hom.app X₁).app X₂).app X₃) ≫\n          ((Lifting₂.iso L₁ L₂₃ W₁ W₂₃\n            (F ⋙ (whiskeringRight _ _ _).obj L) F').inv.app X₁).app ((G₂₃.obj X₂).obj X₃) ≫\n        (F'.obj (L₁.obj X₁)).map\n          (((Lifting₂.iso L₂ L₃ W₂ W₃\n            (G₂₃ ⋙ (whiskeringRight _ _ _).obj L₂₃) G₂₃').inv.app X₂).app X₃) := by\n  dsimp [associator]\n  rw [lift₃NatTrans_app_app_app]\n  dsimp [Lifting₃.iso, Lifting₃.bifunctorComp₁₂, Lifting₃.bifunctorComp₂₃]\n  simp only [Category.assoc]\n\n"}
