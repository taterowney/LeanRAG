{"name":"IsPrimitiveRoot.discr_zeta_eq_discr_zeta_sub_one","module":"Mathlib.NumberTheory.Cyclotomic.Discriminant","initialProofState":"n : PNat\nK : Type u\ninst✝¹ : Field K\ninst✝ : CharZero K\nζ : K\nce : IsCyclotomicExtension (Singleton.singleton n) Rat K\nhζ : IsPrimitiveRoot ζ ↑n\n⊢ Eq (Algebra.discr Rat ⇑(IsPrimitiveRoot.powerBasis Rat hζ).basis) (Algebra.discr Rat ⇑(IsPrimitiveRoot.subOnePowerBasis Rat hζ).basis)","decl":"/-- The discriminant of the power basis given by a primitive root of unity `ζ` is the same as the\ndiscriminant of the power basis given by `ζ - 1`. -/\ntheorem discr_zeta_eq_discr_zeta_sub_one (hζ : IsPrimitiveRoot ζ n) :\n    discr ℚ (hζ.powerBasis ℚ).basis = discr ℚ (hζ.subOnePowerBasis ℚ).basis := by\n  haveI : NumberField K := @NumberField.mk _ _ _ (IsCyclotomicExtension.finiteDimensional {n} ℚ K)\n  have H₁ : (aeval (hζ.powerBasis ℚ).gen) (X - 1 : ℤ[X]) = (hζ.subOnePowerBasis ℚ).gen := by simp\n  have H₂ : (aeval (hζ.subOnePowerBasis ℚ).gen) (X + 1 : ℤ[X]) = (hζ.powerBasis ℚ).gen := by simp\n  refine discr_eq_discr_of_toMatrix_coeff_isIntegral _ (fun i j => toMatrix_isIntegral H₁ ?_ ?_ _ _)\n    fun i j => toMatrix_isIntegral H₂ ?_ ?_ _ _\n  · exact hζ.isIntegral n.pos\n  · refine minpoly.isIntegrallyClosed_eq_field_fractions' (K := ℚ) (hζ.isIntegral n.pos)\n  · exact (hζ.isIntegral n.pos).sub isIntegral_one\n  · refine minpoly.isIntegrallyClosed_eq_field_fractions' (K := ℚ) ?_\n    exact (hζ.isIntegral n.pos).sub isIntegral_one\n\n"}
{"name":"IsCyclotomicExtension.discr_prime_pow_ne_two","module":"Mathlib.NumberTheory.Cyclotomic.Discriminant","initialProofState":"p : PNat\nk : Nat\nK : Type u\nL : Type v\nζ : L\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) K L\nhp : Fact (Nat.Prime ↑p)\nhζ : IsPrimitiveRoot ζ ↑(HPow.hPow p (HAdd.hAdd k 1))\nhirr : Irreducible (Polynomial.cyclotomic (↑(HPow.hPow p (HAdd.hAdd k 1))) K)\nhk : Ne (HPow.hPow p (HAdd.hAdd k 1)) 2\n⊢ Eq (Algebra.discr K ⇑(IsPrimitiveRoot.powerBasis K hζ).basis) (HMul.hMul (HPow.hPow (-1) (HDiv.hDiv (HPow.hPow (↑p) (HAdd.hAdd k 1)).totient 2)) (HPow.hPow (↑↑p) (HMul.hMul (HPow.hPow (↑p) k) (HSub.hSub (HMul.hMul (HSub.hSub (↑p) 1) (HAdd.hAdd k 1)) 1))))","decl":"/-- If `p` is a prime and `IsCyclotomicExtension {p ^ (k + 1)} K L`, then the discriminant of\n`hζ.powerBasis K` is `(-1) ^ ((p ^ (k + 1).totient) / 2) * p ^ (p ^ k * ((p - 1) * (k + 1) - 1))`\nif `Irreducible (cyclotomic (p ^ (k + 1)) K))`, and `p ^ (k + 1) ≠ 2`. -/\ntheorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ℕ).Prime]\n    (hζ : IsPrimitiveRoot ζ ↑(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (↑(p ^ (k + 1)) : ℕ) K))\n    (hk : p ^ (k + 1) ≠ 2) : discr K (hζ.powerBasis K).basis =\n      (-1) ^ ((p ^ (k + 1) : ℕ).totient / 2) * p ^ ((p : ℕ) ^ k * ((p - 1) * (k + 1) - 1)) := by\n  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L\n  -- Porting note: these two instances are not automatically synthesised and must be constructed\n  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L\n  haveI se : Algebra.IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable\n  rw [discr_powerBasis_eq_norm, finrank L hirr, hζ.powerBasis_gen _, ←\n    hζ.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,\n    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]\n  have coe_two : ((2 : ℕ+) : ℕ) = 2 := rfl\n  have hp2 : p = 2 → k ≠ 0 := by\n    rintro rfl rfl\n    exact absurd rfl hk\n  congr 1\n  · rcases eq_or_ne p 2 with (rfl | hp2)\n    · rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with ⟨k, rfl⟩\n      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']\n      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]\n      cases k\n      · simp\n      · simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,\n          ((even_two.mul_right _).mul_right _).neg_one_pow]\n    · replace hp2 : (p : ℕ) ≠ 2 := by rwa [Ne, ← coe_two, PNat.coe_inj]\n      have hpo : Odd (p : ℕ) := hp.out.odd_of_ne_two hp2\n      obtain ⟨a, ha⟩ := (hp.out.even_sub_one hp2).two_dvd\n      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,\n        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,\n        pow_mul, hpo.pow.neg_one_pow]\n      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one\n      rw [mul_left_comm, ← ha]\n      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)\n  · have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)\n    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,\n      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, ← PNat.pow_coe,\n      hζ.minpoly_eq_cyclotomic_of_irreducible hirr] at H\n    replace H := congr_arg (fun P => aeval ζ P) H\n    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,\n      _root_.map_sub, aeval_one, aeval_X_pow] at H\n    replace H := congr_arg (Algebra.norm K) H\n    have hnorm : (norm K) (ζ ^ (p : ℕ) ^ k - 1) = (p : K) ^ (p : ℕ) ^ k := by\n      by_cases hp : p = 2\n      · exact mod_cast hζ.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)\n      · exact mod_cast hζ.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp\n    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, ← map_natCast (algebraMap K L),\n      Algebra.norm_algebraMap, finrank L hirr] at H\n    conv_rhs at H => -- Porting note: need to drill down to successfully rewrite the totient\n      enter [1, 2]\n      rw [PNat.pow_coe, ← succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,\n        Nat.pred_succ]\n    rw [← hζ.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hζ.norm_eq_one hk hirr, one_pow,\n      mul_one, PNat.pow_coe, cast_pow, ← pow_mul, ← mul_assoc, mul_comm (k + 1), mul_assoc] at H\n    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)\n    rw [← succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : ℕ) ^ k)] at H\n    replace H := (mul_left_inj' fun h => ?_).1 H\n    · simp only [H, mul_comm _ (k + 1)]; norm_cast\n    · -- Porting note: was `replace h := pow_eq_zero h; rw [coe_coe] at h; simpa using hne.1`\n      have := hne.1\n      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this\n      exact absurd (pow_eq_zero h) this\n\n"}
{"name":"IsCyclotomicExtension.discr_prime_pow_ne_two'","module":"Mathlib.NumberTheory.Cyclotomic.Discriminant","initialProofState":"p : PNat\nk : Nat\nK : Type u\nL : Type v\nζ : L\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p (HAdd.hAdd k 1))) K L\nhp : Fact (Nat.Prime ↑p)\nhζ : IsPrimitiveRoot ζ ↑(HPow.hPow p (HAdd.hAdd k 1))\nhirr : Irreducible (Polynomial.cyclotomic (↑(HPow.hPow p (HAdd.hAdd k 1))) K)\nhk : Ne (HPow.hPow p (HAdd.hAdd k 1)) 2\n⊢ Eq (Algebra.discr K ⇑(IsPrimitiveRoot.powerBasis K hζ).basis) (HMul.hMul (HPow.hPow (-1) (HDiv.hDiv (HMul.hMul (HPow.hPow (↑p) k) (HSub.hSub (↑p) 1)) 2)) (HPow.hPow (↑↑p) (HMul.hMul (HPow.hPow (↑p) k) (HSub.hSub (HMul.hMul (HSub.hSub (↑p) 1) (HAdd.hAdd k 1)) 1))))","decl":"/-- If `p` is a prime and `IsCyclotomicExtension {p ^ (k + 1)} K L`, then the discriminant of\n`hζ.powerBasis K` is `(-1) ^ (p ^ k * (p - 1) / 2) * p ^ (p ^ k * ((p - 1) * (k + 1) - 1))`\nif `Irreducible (cyclotomic (p ^ (k + 1)) K))`, and `p ^ (k + 1) ≠ 2`. -/\ntheorem discr_prime_pow_ne_two' [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : ℕ).Prime]\n    (hζ : IsPrimitiveRoot ζ ↑(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (↑(p ^ (k + 1)) : ℕ) K))\n    (hk : p ^ (k + 1) ≠ 2) : discr K (hζ.powerBasis K).basis =\n      (-1) ^ ((p : ℕ) ^ k * (p - 1) / 2) * p ^ ((p : ℕ) ^ k * ((p - 1) * (k + 1) - 1)) := by\n  simpa [totient_prime_pow hp.out (succ_pos k)] using discr_prime_pow_ne_two hζ hirr hk\n\n"}
{"name":"IsCyclotomicExtension.discr_prime_pow","module":"Mathlib.NumberTheory.Cyclotomic.Discriminant","initialProofState":"p : PNat\nk : Nat\nK : Type u\nL : Type v\nζ : L\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nhcycl : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p k)) K L\nhp : Fact (Nat.Prime ↑p)\nhζ : IsPrimitiveRoot ζ ↑(HPow.hPow p k)\nhirr : Irreducible (Polynomial.cyclotomic (↑(HPow.hPow p k)) K)\n⊢ Eq (Algebra.discr K ⇑(IsPrimitiveRoot.powerBasis K hζ).basis) (HMul.hMul (HPow.hPow (-1) (HDiv.hDiv (HPow.hPow (↑p) k).totient 2)) (HPow.hPow (↑↑p) (HMul.hMul (HPow.hPow (↑p) (HSub.hSub k 1)) (HSub.hSub (HMul.hMul (HSub.hSub (↑p) 1) k) 1))))","decl":"/-- If `p` is a prime and `IsCyclotomicExtension {p ^ k} K L`, then the discriminant of\n`hζ.powerBasis K` is `(-1) ^ ((p ^ k).totient / 2) * p ^ (p ^ (k - 1) * ((p - 1) * k - 1))`\nif `Irreducible (cyclotomic (p ^ k) K))`. Beware that in the cases `p ^ k = 1` and `p ^ k = 2`\nthe formula uses `1 / 2 = 0` and `0 - 1 = 0`. It is useful only to have a uniform result.\nSee also `IsCyclotomicExtension.discr_prime_pow_eq_unit_mul_pow`. -/\ntheorem discr_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} K L] [hp : Fact (p : ℕ).Prime]\n    (hζ : IsPrimitiveRoot ζ ↑(p ^ k)) (hirr : Irreducible (cyclotomic (↑(p ^ k) : ℕ) K)) :\n    discr K (hζ.powerBasis K).basis =\n      (-1) ^ ((p ^ k : ℕ).totient / 2) * p ^ ((p : ℕ) ^ (k - 1) * ((p - 1) * k - 1)) := by\n  cases' k with k k\n  · simp only [coe_basis, _root_.pow_zero, powerBasis_gen _ hζ, totient_one, mul_zero, mul_one,\n      show 1 / 2 = 0 by rfl, discr, traceMatrix]\n    have hζone : ζ = 1 := by simpa using hζ\n    rw [hζ.powerBasis_dim _, hζone, ← (algebraMap K L).map_one,\n      minpoly.eq_X_sub_C_of_algebraMap_inj _ (algebraMap K L).injective, natDegree_X_sub_C]\n    simp only [traceMatrix, map_one, one_pow, Matrix.det_unique, traceForm_apply, mul_one]\n    rw [← (algebraMap K L).map_one, trace_algebraMap, finrank _ hirr]\n    norm_num\n  · by_cases hk : p ^ (k + 1) = 2\n    · have coe_two : 2 = ((2 : ℕ+) : ℕ) := rfl\n      have hp : p = 2 := by\n        rw [← PNat.coe_inj, PNat.pow_coe, ← pow_one 2] at hk\n        replace hk :=\n          eq_of_prime_pow_eq (prime_iff.1 hp.out) (prime_iff.1 Nat.prime_two) (succ_pos _) hk\n        rwa [coe_two, PNat.coe_inj] at hk\n      subst hp\n      rw [← PNat.coe_inj, PNat.pow_coe] at hk\n      nth_rw 2 [← pow_one 2] at hk\n      replace hk := Nat.pow_right_injective rfl.le hk\n      rw [add_left_eq_self] at hk\n      subst hk\n      rw [pow_one] at hζ hcycl\n      have : natDegree (minpoly K ζ) = 1 := by\n        rw [hζ.eq_neg_one_of_two_right, show (-1 : L) = algebraMap K L (-1) by simp,\n          minpoly.eq_X_sub_C_of_algebraMap_inj _ (NoZeroSMulDivisors.algebraMap_injective K L)]\n        exact natDegree_X_sub_C (-1)\n      rcases Fin.equiv_iff_eq.2 this with ⟨e⟩\n      rw [← Algebra.discr_reindex K (hζ.powerBasis K).basis e, coe_basis, powerBasis_gen]; norm_num\n      simp_rw [hζ.eq_neg_one_of_two_right, show (-1 : L) = algebraMap K L (-1) by simp]\n      convert_to (discr K fun i : Fin 1 ↦ (algebraMap K L) (-1) ^ ↑i) = _\n      · congr\n        ext i\n        simp only [map_neg, map_one, Function.comp_apply, Fin.val_eq_zero, _root_.pow_zero]\n        suffices (e.symm i : ℕ) = 0 by simp [this]\n        rw [← Nat.lt_one_iff]\n        convert (e.symm i).2\n        rw [this]\n      · simp only [discr, traceMatrix_apply, Matrix.det_unique, Fin.default_eq_zero, Fin.val_zero,\n          _root_.pow_zero, traceForm_apply, mul_one]\n        rw [← (algebraMap K L).map_one, trace_algebraMap, finrank _ hirr]; norm_num\n    · exact discr_prime_pow_ne_two hζ hirr hk\n\n"}
{"name":"IsCyclotomicExtension.discr_prime_pow_eq_unit_mul_pow","module":"Mathlib.NumberTheory.Cyclotomic.Discriminant","initialProofState":"p : PNat\nk : Nat\nK : Type u\nL : Type v\nζ : L\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : IsCyclotomicExtension (Singleton.singleton (HPow.hPow p k)) K L\nhp : Fact (Nat.Prime ↑p)\nhζ : IsPrimitiveRoot ζ ↑(HPow.hPow p k)\nhirr : Irreducible (Polynomial.cyclotomic (↑(HPow.hPow p k)) K)\n⊢ Exists fun u => Exists fun n => Eq (Algebra.discr K ⇑(IsPrimitiveRoot.powerBasis K hζ).basis) (HMul.hMul (↑↑u) (HPow.hPow (↑↑p) n))","decl":"/-- If `p` is a prime and `IsCyclotomicExtension {p ^ k} K L`, then there are `u : ℤˣ` and\n`n : ℕ` such that the discriminant of `hζ.powerBasis K` is `u * p ^ n`. Often this is enough and\nless cumbersome to use than `IsCyclotomicExtension.discr_prime_pow`. -/\ntheorem discr_prime_pow_eq_unit_mul_pow [IsCyclotomicExtension {p ^ k} K L]\n    [hp : Fact (p : ℕ).Prime] (hζ : IsPrimitiveRoot ζ ↑(p ^ k))\n    (hirr : Irreducible (cyclotomic (↑(p ^ k) : ℕ) K)) :\n    ∃ (u : ℤˣ) (n : ℕ), discr K (hζ.powerBasis K).basis = u * p ^ n := by\n  rw [discr_prime_pow hζ hirr]\n  by_cases heven : Even ((p ^ k : ℕ).totient / 2)\n  · exact ⟨1, (p : ℕ) ^ (k - 1) * ((p - 1) * k - 1), by rw [heven.neg_one_pow]; norm_num⟩\n  · exact ⟨-1, (p : ℕ) ^ (k - 1) * ((p - 1) * k - 1), by\n      rw [(not_even_iff_odd.1 heven).neg_one_pow]; norm_num⟩\n\n"}
{"name":"IsCyclotomicExtension.discr_odd_prime","module":"Mathlib.NumberTheory.Cyclotomic.Discriminant","initialProofState":"p : PNat\nK : Type u\nL : Type v\nζ : L\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : IsCyclotomicExtension (Singleton.singleton p) K L\nhp : Fact (Nat.Prime ↑p)\nhζ : IsPrimitiveRoot ζ ↑p\nhirr : Irreducible (Polynomial.cyclotomic (↑p) K)\nhodd : Ne p 2\n⊢ Eq (Algebra.discr K ⇑(IsPrimitiveRoot.powerBasis K hζ).basis) (HMul.hMul (HPow.hPow (-1) (HDiv.hDiv (HSub.hSub (↑p) 1) 2)) (HPow.hPow (↑↑p) (HSub.hSub (↑p) 2)))","decl":"/-- If `p` is an odd prime and `IsCyclotomicExtension {p} K L`, then\n`discr K (hζ.powerBasis K).basis = (-1) ^ ((p - 1) / 2) * p ^ (p - 2)` if\n`Irreducible (cyclotomic p K)`. -/\ntheorem discr_odd_prime [IsCyclotomicExtension {p} K L] [hp : Fact (p : ℕ).Prime]\n    (hζ : IsPrimitiveRoot ζ p) (hirr : Irreducible (cyclotomic p K)) (hodd : p ≠ 2) :\n    discr K (hζ.powerBasis K).basis = (-1) ^ (((p : ℕ) - 1) / 2) * p ^ ((p : ℕ) - 2) := by\n  have : IsCyclotomicExtension {p ^ (0 + 1)} K L := by\n    rw [zero_add, pow_one]\n    infer_instance\n  have hζ' : IsPrimitiveRoot ζ (p ^ (0 + 1):) := by simpa using hζ\n  convert discr_prime_pow_ne_two hζ' (by simpa [hirr]) (by simp [hodd]) using 2\n  · rw [zero_add, pow_one, totient_prime hp.out]\n  · rw [_root_.pow_zero, one_mul, zero_add, mul_one, Nat.sub_sub]\n\n"}
