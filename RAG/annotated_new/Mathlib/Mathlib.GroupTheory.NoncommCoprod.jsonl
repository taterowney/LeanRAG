{"name":"AddHom.noncommCoprod_apply","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : AddSemigroup P\nf : AddHom M P\ng : AddHom N P\ncomm : ∀ (m : M) (n : N), AddCommute (f m) (g n)\nmn : Prod M N\n⊢ Eq ((f.noncommCoprod g comm) mn) (HAdd.hAdd (f mn.1) (g mn.2))","decl":"/-- Coproduct of two `MulHom`s with the same codomain with `Commute` assumption:\n  `f.noncommCoprod g _ (p : M × N) = f p.1 * g p.2`.\n  (For the commutative case, use `MulHom.coprod`) -/\n@[to_additive (attr := simps)\n    \"Coproduct of two `AddHom`s with the same codomain with `AddCommute` assumption:\n    `f.noncommCoprod g _ (p : M × N) = f p.1 + g p.2`.\n    (For the commutative case, use `AddHom.coprod`)\"]\ndef noncommCoprod (comm : ∀ m n, Commute (f m) (g n)) : M × N →ₙ* P where\n  toFun mn := f mn.fst * g mn.snd\n  map_mul' mn mn' := by simpa using (comm _ _).mul_mul_mul_comm _ _\n\n"}
{"name":"MulHom.noncommCoprod_apply","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Semigroup P\nf : MulHom M P\ng : MulHom N P\ncomm : ∀ (m : M) (n : N), Commute (f m) (g n)\nmn : Prod M N\n⊢ Eq ((f.noncommCoprod g comm) mn) (HMul.hMul (f mn.1) (g mn.2))","decl":"/-- Coproduct of two `MulHom`s with the same codomain with `Commute` assumption:\n  `f.noncommCoprod g _ (p : M × N) = f p.1 * g p.2`.\n  (For the commutative case, use `MulHom.coprod`) -/\n@[to_additive (attr := simps)\n    \"Coproduct of two `AddHom`s with the same codomain with `AddCommute` assumption:\n    `f.noncommCoprod g _ (p : M × N) = f p.1 + g p.2`.\n    (For the commutative case, use `AddHom.coprod`)\"]\ndef noncommCoprod (comm : ∀ m n, Commute (f m) (g n)) : M × N →ₙ* P where\n  toFun mn := f mn.fst * g mn.snd\n  map_mul' mn mn' := by simpa using (comm _ _).mul_mul_mul_comm _ _\n\n"}
{"name":"MulHom.noncommCoprod_apply'","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : Semigroup P\nf : MulHom M P\ng : MulHom N P\ncomm : ∀ (m : M) (n : N), Commute (f m) (g n)\nmn : Prod M N\n⊢ Eq ((f.noncommCoprod g comm) mn) (HMul.hMul (g mn.2) (f mn.1))","decl":"/-- Variant of `MulHom.noncommCoprod_apply` with the product written in the other direction` -/\n@[to_additive\n  \"Variant of `AddHom.noncommCoprod_apply`, with the sum written in the other direction\"]\ntheorem noncommCoprod_apply' (comm) (mn : M × N) :\n    (f.noncommCoprod g comm) mn = g mn.2 * f mn.1 := by\n  rw [← comm, noncommCoprod_apply]\n\n"}
{"name":"AddHom.noncommCoprod_apply'","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : AddSemigroup P\nf : AddHom M P\ng : AddHom N P\ncomm : ∀ (m : M) (n : N), AddCommute (f m) (g n)\nmn : Prod M N\n⊢ Eq ((f.noncommCoprod g comm) mn) (HAdd.hAdd (g mn.2) (f mn.1))","decl":"/-- Variant of `MulHom.noncommCoprod_apply` with the product written in the other direction` -/\n@[to_additive\n  \"Variant of `AddHom.noncommCoprod_apply`, with the sum written in the other direction\"]\ntheorem noncommCoprod_apply' (comm) (mn : M × N) :\n    (f.noncommCoprod g comm) mn = g mn.2 * f mn.1 := by\n  rw [← comm, noncommCoprod_apply]\n\n"}
{"name":"MulHom.comp_noncommCoprod","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝³ : Mul M\ninst✝² : Mul N\ninst✝¹ : Semigroup P\nf : MulHom M P\ng : MulHom N P\nQ : Type u_4\ninst✝ : Semigroup Q\nh : MulHom P Q\ncomm : ∀ (m : M) (n : N), Commute (f m) (g n)\n⊢ Eq (h.comp (f.noncommCoprod g comm)) ((h.comp f).noncommCoprod (h.comp g) ⋯)","decl":"@[to_additive]\ntheorem comp_noncommCoprod {Q : Type*} [Semigroup Q] (h : P →ₙ* Q)\n    (comm : ∀ m n, Commute (f m) (g n)) :\n    h.comp (f.noncommCoprod g comm) =\n      (h.comp f).noncommCoprod (h.comp g) (fun m n ↦ (comm m n).map h) :=\n  ext fun _ => map_mul h _ _\n\n"}
{"name":"AddHom.comp_noncommCoprod","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝³ : Add M\ninst✝² : Add N\ninst✝¹ : AddSemigroup P\nf : AddHom M P\ng : AddHom N P\nQ : Type u_4\ninst✝ : AddSemigroup Q\nh : AddHom P Q\ncomm : ∀ (m : M) (n : N), AddCommute (f m) (g n)\n⊢ Eq (h.comp (f.noncommCoprod g comm)) ((h.comp f).noncommCoprod (h.comp g) ⋯)","decl":"@[to_additive]\ntheorem comp_noncommCoprod {Q : Type*} [Semigroup Q] (h : P →ₙ* Q)\n    (comm : ∀ m n, Commute (f m) (g n)) :\n    h.comp (f.noncommCoprod g comm) =\n      (h.comp f).noncommCoprod (h.comp g) (fun m n ↦ (comm m n).map h) :=\n  ext fun _ => map_mul h _ _\n\n"}
{"name":"MonoidHom.noncommCoprod_apply","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\ncomm : ∀ (m : M) (n : N), Commute (f m) (g n)\nmn : Prod M N\n⊢ Eq ((f.noncommCoprod g comm) mn) (HMul.hMul (f mn.1) (g mn.2))","decl":"/-- Coproduct of two `MonoidHom`s with the same codomain,\n  with a commutation assumption:\n  `f.noncommCoprod g _ (p : M × N) = f p.1 * g p.2`.\n  (Noncommutative case; in the commutative case, use `MonoidHom.coprod`.)-/\n@[to_additive (attr := simps)\n    \"Coproduct of two `AddMonoidHom`s with the same codomain,\n    with a commutation assumption:\n    `f.noncommCoprod g (p : M × N) = f p.1 + g p.2`.\n    (Noncommutative case; in the commutative case, use `AddHom.coprod`.)\"]\ndef noncommCoprod : M × N →* P where\n  toFun := fun mn ↦ (f mn.fst) * (g mn.snd)\n  map_one' := by simp only [Prod.fst_one, Prod.snd_one, map_one, mul_one]\n  __ := f.toMulHom.noncommCoprod g.toMulHom comm\n\n"}
{"name":"AddMonoidHom.noncommCoprod_apply","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\ncomm : ∀ (m : M) (n : N), AddCommute (f m) (g n)\nmn : Prod M N\n⊢ Eq ((f.noncommCoprod g comm) mn) (HAdd.hAdd (f mn.1) (g mn.2))","decl":"/-- Coproduct of two `MonoidHom`s with the same codomain,\n  with a commutation assumption:\n  `f.noncommCoprod g _ (p : M × N) = f p.1 * g p.2`.\n  (Noncommutative case; in the commutative case, use `MonoidHom.coprod`.)-/\n@[to_additive (attr := simps)\n    \"Coproduct of two `AddMonoidHom`s with the same codomain,\n    with a commutation assumption:\n    `f.noncommCoprod g (p : M × N) = f p.1 + g p.2`.\n    (Noncommutative case; in the commutative case, use `AddHom.coprod`.)\"]\ndef noncommCoprod : M × N →* P where\n  toFun := fun mn ↦ (f mn.fst) * (g mn.snd)\n  map_one' := by simp only [Prod.fst_one, Prod.snd_one, map_one, mul_one]\n  __ := f.toMulHom.noncommCoprod g.toMulHom comm\n\n"}
{"name":"AddMonoidHom.noncommCoprod_apply'","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\ncomm : ∀ (m : M) (n : N), AddCommute (f m) (g n)\nmn : Prod M N\n⊢ Eq ((f.noncommCoprod g comm) mn) (HAdd.hAdd (g mn.2) (f mn.1))","decl":"/-- Variant of `MonoidHom.noncomCoprod_apply` with the product written in the other direction` -/\n@[to_additive\n  \"Variant of `AddMonoidHom.noncomCoprod_apply` with the sum written in the other direction\"]\ntheorem noncommCoprod_apply' (comm) (mn : M × N) :\n    (f.noncommCoprod g comm) mn = g mn.2 * f mn.1 := by\n  rw [← comm, MonoidHom.noncommCoprod_apply]\n\n"}
{"name":"MonoidHom.noncommCoprod_apply'","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\ncomm : ∀ (m : M) (n : N), Commute (f m) (g n)\nmn : Prod M N\n⊢ Eq ((f.noncommCoprod g comm) mn) (HMul.hMul (g mn.2) (f mn.1))","decl":"/-- Variant of `MonoidHom.noncomCoprod_apply` with the product written in the other direction` -/\n@[to_additive\n  \"Variant of `AddMonoidHom.noncomCoprod_apply` with the sum written in the other direction\"]\ntheorem noncommCoprod_apply' (comm) (mn : M × N) :\n    (f.noncommCoprod g comm) mn = g mn.2 * f mn.1 := by\n  rw [← comm, MonoidHom.noncommCoprod_apply]\n\n"}
{"name":"AddMonoidHom.noncommCoprod_comp_inl","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\ncomm : ∀ (m : M) (n : N), AddCommute (f m) (g n)\n⊢ Eq ((f.noncommCoprod g comm).comp (AddMonoidHom.inl M N)) f","decl":"@[to_additive (attr := simp)]\ntheorem noncommCoprod_comp_inl : (f.noncommCoprod g comm).comp (inl M N) = f :=\n  ext fun x => by simp\n\n"}
{"name":"MonoidHom.noncommCoprod_comp_inl","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\ncomm : ∀ (m : M) (n : N), Commute (f m) (g n)\n⊢ Eq ((f.noncommCoprod g comm).comp (MonoidHom.inl M N)) f","decl":"@[to_additive (attr := simp)]\ntheorem noncommCoprod_comp_inl : (f.noncommCoprod g comm).comp (inl M N) = f :=\n  ext fun x => by simp\n\n"}
{"name":"AddMonoidHom.noncommCoprod_comp_inr","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\ncomm : ∀ (m : M) (n : N), AddCommute (f m) (g n)\n⊢ Eq ((f.noncommCoprod g comm).comp (AddMonoidHom.inr M N)) g","decl":"@[to_additive (attr := simp)]\ntheorem noncommCoprod_comp_inr : (f.noncommCoprod g comm).comp (inr M N) = g :=\n  ext fun x => by simp\n\n"}
{"name":"MonoidHom.noncommCoprod_comp_inr","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\ncomm : ∀ (m : M) (n : N), Commute (f m) (g n)\n⊢ Eq ((f.noncommCoprod g comm).comp (MonoidHom.inr M N)) g","decl":"@[to_additive (attr := simp)]\ntheorem noncommCoprod_comp_inr : (f.noncommCoprod g comm).comp (inr M N) = g :=\n  ext fun x => by simp\n\n"}
{"name":"AddMonoidHom.noncommCoprod_unique","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom (Prod M N) P\n⊢ Eq ((f.comp (AddMonoidHom.inl M N)).noncommCoprod (f.comp (AddMonoidHom.inr M N)) ⋯) f","decl":"@[to_additive (attr := simp)]\ntheorem noncommCoprod_unique (f : M × N →* P) :\n    (f.comp (inl M N)).noncommCoprod (f.comp (inr M N)) (fun _ _ => (commute_inl_inr _ _).map f)\n      = f :=\n  ext fun x => by simp [coprod_apply, inl_apply, inr_apply, ← map_mul]\n\n"}
{"name":"MonoidHom.noncommCoprod_unique","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom (Prod M N) P\n⊢ Eq ((f.comp (MonoidHom.inl M N)).noncommCoprod (f.comp (MonoidHom.inr M N)) ⋯) f","decl":"@[to_additive (attr := simp)]\ntheorem noncommCoprod_unique (f : M × N →* P) :\n    (f.comp (inl M N)).noncommCoprod (f.comp (inr M N)) (fun _ _ => (commute_inl_inr _ _).map f)\n      = f :=\n  ext fun x => by simp [coprod_apply, inl_apply, inr_apply, ← map_mul]\n\n"}
{"name":"MonoidHom.noncommCoprod_inl_inr","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq ((MonoidHom.inl M N).noncommCoprod (MonoidHom.inr M N) ⋯) (MonoidHom.id (Prod M N))","decl":"@[to_additive (attr := simp)]\ntheorem noncommCoprod_inl_inr {M N : Type*} [Monoid M] [Monoid N] :\n    (inl M N).noncommCoprod (inr M N) commute_inl_inr = id (M × N) :=\n  noncommCoprod_unique <| .id (M × N)\n\n"}
{"name":"AddMonoidHom.noncommCoprod_inl_inr","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq ((AddMonoidHom.inl M N).noncommCoprod (AddMonoidHom.inr M N) ⋯) (AddMonoidHom.id (Prod M N))","decl":"@[to_additive (attr := simp)]\ntheorem noncommCoprod_inl_inr {M N : Type*} [Monoid M] [Monoid N] :\n    (inl M N).noncommCoprod (inr M N) commute_inl_inr = id (M × N) :=\n  noncommCoprod_unique <| .id (M × N)\n\n"}
{"name":"MonoidHom.comp_noncommCoprod","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\ncomm : ∀ (m : M) (n : N), Commute (f m) (g n)\nQ : Type u_4\ninst✝ : Monoid Q\nh : MonoidHom P Q\n⊢ Eq (h.comp (f.noncommCoprod g comm)) ((h.comp f).noncommCoprod (h.comp g) ⋯)","decl":"@[to_additive]\ntheorem comp_noncommCoprod {Q : Type*} [Monoid Q] (h : P →* Q) :\n    h.comp (f.noncommCoprod g comm) =\n      (h.comp f).noncommCoprod (h.comp g) (fun m n ↦ (comm m n).map h) :=\n  ext fun x => by simp\n\n"}
{"name":"AddMonoidHom.comp_noncommCoprod","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\ncomm : ∀ (m : M) (n : N), AddCommute (f m) (g n)\nQ : Type u_4\ninst✝ : AddMonoid Q\nh : AddMonoidHom P Q\n⊢ Eq (h.comp (f.noncommCoprod g comm)) ((h.comp f).noncommCoprod (h.comp g) ⋯)","decl":"@[to_additive]\ntheorem comp_noncommCoprod {Q : Type*} [Monoid Q] (h : P →* Q) :\n    h.comp (f.noncommCoprod g comm) =\n      (h.comp f).noncommCoprod (h.comp g) (fun m n ↦ (comm m n).map h) :=\n  ext fun x => by simp\n\n"}
{"name":"MonoidHom.noncommCoprod_injective","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Group M\ninst✝¹ : Group N\ninst✝ : Group P\nf : MonoidHom M P\ng : MonoidHom N P\ncomm : ∀ (m : M) (n : N), Commute (f m) (g n)\n⊢ Iff (Function.Injective ⇑(f.noncommCoprod g comm)) (And (Function.Injective ⇑f) (And (Function.Injective ⇑g) (Disjoint f.range g.range)))","decl":"lemma noncommCoprod_injective {M N P : Type*} [Group M] [Group N] [Group P]\n    (f : M →* P) (g : N →* P) (comm : ∀ (m : M) (n : N), Commute (f m) (g n)) :\n    Function.Injective (noncommCoprod f g comm) ↔\n      (Function.Injective f ∧ Function.Injective g ∧ _root_.Disjoint f.range g.range) := by\n  simp only [injective_iff_map_eq_one, disjoint_iff_inf_le,\n    noncommCoprod_apply, Prod.forall, Prod.mk_eq_one]\n  refine ⟨fun h ↦ ⟨fun x ↦ ?_, fun x ↦ ?_, ?_⟩, ?_⟩\n  · simpa using h x 1\n  · simpa using h 1 x\n  · intro x ⟨⟨y, hy⟩, z, hz⟩\n    rwa [(h y z⁻¹ (by rw [map_inv, hy, hz, mul_inv_cancel])).1, map_one, eq_comm] at hy\n  · intro ⟨hf, hg, hp⟩ a b h\n    have key := hp ⟨⟨a⁻¹, by rwa [map_inv, inv_eq_iff_mul_eq_one]⟩, b, rfl⟩\n    exact ⟨hf a (by rwa [key, mul_one] at h), hg b key⟩\n\n"}
{"name":"MonoidHom.noncommCoprod_range","module":"Mathlib.GroupTheory.NoncommCoprod","initialProofState":"M : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝² : Group M\ninst✝¹ : Group N\ninst✝ : Group P\nf : MonoidHom M P\ng : MonoidHom N P\ncomm : ∀ (m : M) (n : N), Commute (f m) (g n)\n⊢ Eq (f.noncommCoprod g comm).range (Max.max f.range g.range)","decl":"lemma noncommCoprod_range {M N P : Type*} [Group M] [Group N] [Group P]\n    (f : M →* P) (g : N →* P) (comm : ∀ (m : M) (n : N), Commute (f m) (g n)) :\n    (noncommCoprod f g comm).range = f.range ⊔ g.range := by\n  apply le_antisymm\n  · rintro - ⟨a, rfl⟩\n    exact mul_mem (mem_sup_left ⟨a.1, rfl⟩) (mem_sup_right ⟨a.2, rfl⟩)\n  · rw [sup_le_iff]\n    constructor\n    · rintro - ⟨a, rfl⟩\n      exact ⟨(a, 1), by rw [noncommCoprod_apply, map_one, mul_one]⟩\n    · rintro - ⟨a, rfl⟩\n      exact ⟨(1, a), by rw [noncommCoprod_apply, map_one, one_mul]⟩\n\n"}
