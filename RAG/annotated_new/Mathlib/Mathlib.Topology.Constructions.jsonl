{"name":"instDiscreteTopologyAdditive","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : DiscreteTopology X\nâŠ¢ DiscreteTopology (Additive X)","decl":"instance [DiscreteTopology X] : DiscreteTopology (Additive X) := â€¹DiscreteTopology Xâ€º\n"}
{"name":"instDiscreteTopologyMultiplicative","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : DiscreteTopology X\nâŠ¢ DiscreteTopology (Multiplicative X)","decl":"instance [DiscreteTopology X] : DiscreteTopology (Multiplicative X) := â€¹DiscreteTopology Xâ€º\n\n"}
{"name":"continuous_ofMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Continuous â‡‘Additive.ofMul","decl":"theorem continuous_ofMul : Continuous (ofMul : X â†’ Additive X) := continuous_id\n\n"}
{"name":"continuous_toMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Continuous â‡‘Additive.toMul","decl":"theorem continuous_toMul : Continuous (toMul : Additive X â†’ X) := continuous_id\n\n"}
{"name":"continuous_ofAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Continuous â‡‘Multiplicative.ofAdd","decl":"theorem continuous_ofAdd : Continuous (ofAdd : X â†’ Multiplicative X) := continuous_id\n\n"}
{"name":"continuous_toAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Continuous â‡‘Multiplicative.toAdd","decl":"theorem continuous_toAdd : Continuous (toAdd : Multiplicative X â†’ X) := continuous_id\n\n"}
{"name":"isOpenMap_ofMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsOpenMap â‡‘Additive.ofMul","decl":"theorem isOpenMap_ofMul : IsOpenMap (ofMul : X â†’ Additive X) := IsOpenMap.id\n\n"}
{"name":"isOpenMap_toMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsOpenMap â‡‘Additive.toMul","decl":"theorem isOpenMap_toMul : IsOpenMap (toMul : Additive X â†’ X) := IsOpenMap.id\n\n"}
{"name":"isOpenMap_ofAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsOpenMap â‡‘Multiplicative.ofAdd","decl":"theorem isOpenMap_ofAdd : IsOpenMap (ofAdd : X â†’ Multiplicative X) := IsOpenMap.id\n\n"}
{"name":"isOpenMap_toAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsOpenMap â‡‘Multiplicative.toAdd","decl":"theorem isOpenMap_toAdd : IsOpenMap (toAdd : Multiplicative X â†’ X) := IsOpenMap.id\n\n"}
{"name":"isClosedMap_ofMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsClosedMap â‡‘Additive.ofMul","decl":"theorem isClosedMap_ofMul : IsClosedMap (ofMul : X â†’ Additive X) := IsClosedMap.id\n\n"}
{"name":"isClosedMap_toMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsClosedMap â‡‘Additive.toMul","decl":"theorem isClosedMap_toMul : IsClosedMap (toMul : Additive X â†’ X) := IsClosedMap.id\n\n"}
{"name":"isClosedMap_ofAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsClosedMap â‡‘Multiplicative.ofAdd","decl":"theorem isClosedMap_ofAdd : IsClosedMap (ofAdd : X â†’ Multiplicative X) := IsClosedMap.id\n\n"}
{"name":"isClosedMap_toAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsClosedMap â‡‘Multiplicative.toAdd","decl":"theorem isClosedMap_toAdd : IsClosedMap (toAdd : Multiplicative X â†’ X) := IsClosedMap.id\n\n"}
{"name":"nhds_ofMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nx : X\nâŠ¢ Eq (nhds (Additive.ofMul x)) (Filter.map (â‡‘Additive.ofMul) (nhds x))","decl":"theorem nhds_ofMul (x : X) : ğ“ (ofMul x) = map ofMul (ğ“ x) := rfl\n\n"}
{"name":"nhds_ofAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nx : X\nâŠ¢ Eq (nhds (Multiplicative.ofAdd x)) (Filter.map (â‡‘Multiplicative.ofAdd) (nhds x))","decl":"theorem nhds_ofAdd (x : X) : ğ“ (ofAdd x) = map ofAdd (ğ“ x) := rfl\n\n"}
{"name":"nhds_toMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nx : Additive X\nâŠ¢ Eq (nhds (Additive.toMul x)) (Filter.map (â‡‘Additive.toMul) (nhds x))","decl":"theorem nhds_toMul (x : Additive X) : ğ“ x.toMul = map toMul (ğ“ x) := rfl\n\n"}
{"name":"nhds_toAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nx : Multiplicative X\nâŠ¢ Eq (nhds (Multiplicative.toAdd x)) (Filter.map (â‡‘Multiplicative.toAdd) (nhds x))","decl":"theorem nhds_toAdd (x : Multiplicative X) : ğ“ x.toAdd = map toAdd (ğ“ x) := rfl\n\n"}
{"name":"OrderDual.instDiscreteTopology","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : DiscreteTopology X\nâŠ¢ DiscreteTopology (OrderDual X)","decl":"instance OrderDual.instDiscreteTopology [DiscreteTopology X] : DiscreteTopology Xáµ’áµˆ := â€¹_â€º\n\n"}
{"name":"continuous_toDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Continuous â‡‘OrderDual.toDual","decl":"theorem continuous_toDual : Continuous (toDual : X â†’ Xáµ’áµˆ) := continuous_id\n\n"}
{"name":"continuous_ofDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Continuous â‡‘OrderDual.ofDual","decl":"theorem continuous_ofDual : Continuous (ofDual : Xáµ’áµˆ â†’ X) := continuous_id\n\n"}
{"name":"isOpenMap_toDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsOpenMap â‡‘OrderDual.toDual","decl":"theorem isOpenMap_toDual : IsOpenMap (toDual : X â†’ Xáµ’áµˆ) := IsOpenMap.id\n\n"}
{"name":"isOpenMap_ofDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsOpenMap â‡‘OrderDual.ofDual","decl":"theorem isOpenMap_ofDual : IsOpenMap (ofDual : Xáµ’áµˆ â†’ X) := IsOpenMap.id\n\n"}
{"name":"isClosedMap_toDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsClosedMap â‡‘OrderDual.toDual","decl":"theorem isClosedMap_toDual : IsClosedMap (toDual : X â†’ Xáµ’áµˆ) := IsClosedMap.id\n\n"}
{"name":"isClosedMap_ofDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsClosedMap â‡‘OrderDual.ofDual","decl":"theorem isClosedMap_ofDual : IsClosedMap (ofDual : Xáµ’áµˆ â†’ X) := IsClosedMap.id\n\n"}
{"name":"nhds_toDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nx : X\nâŠ¢ Eq (nhds (OrderDual.toDual x)) (Filter.map (â‡‘OrderDual.toDual) (nhds x))","decl":"theorem nhds_toDual (x : X) : ğ“ (toDual x) = map toDual (ğ“ x) := rfl\n\n"}
{"name":"nhds_ofDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nx : X\nâŠ¢ Eq (nhds (OrderDual.ofDual x)) (Filter.map (â‡‘OrderDual.ofDual) (nhds x))","decl":"theorem nhds_ofDual (x : X) : ğ“ (ofDual x) = map ofDual (ğ“ x) := rfl\n\n"}
{"name":"OrderDual.instNeBotNhdsWithinIoi","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : Preorder X\nx : X\ninstâœ : (nhdsWithin x (Set.Iio x)).NeBot\nâŠ¢ (nhdsWithin (OrderDual.toDual x) (Set.Ioi (OrderDual.toDual x))).NeBot","decl":"instance OrderDual.instNeBotNhdsWithinIoi [(ğ“[<] x).NeBot] : (ğ“[>] toDual x).NeBot := â€¹_â€º\n"}
{"name":"OrderDual.instNeBotNhdsWithinIio","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : Preorder X\nx : X\ninstâœ : (nhdsWithin x (Set.Ioi x)).NeBot\nâŠ¢ (nhdsWithin (OrderDual.toDual x) (Set.Iio (OrderDual.toDual x))).NeBot","decl":"instance OrderDual.instNeBotNhdsWithinIio [(ğ“[>] x).NeBot] : (ğ“[<] toDual x).NeBot := â€¹_â€º\n\n"}
{"name":"Quotient.preimage_mem_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Setoid X\nV : Set (Quotient s)\nx : X\nhs : Membership.mem (nhds (Quotient.mk' x)) V\nâŠ¢ Membership.mem (nhds x) (Set.preimage Quotient.mk' V)","decl":"theorem Quotient.preimage_mem_nhds [TopologicalSpace X] [s : Setoid X] {V : Set <| Quotient s}\n    {x : X} (hs : V âˆˆ ğ“ (Quotient.mk' x)) : Quotient.mk' â»Â¹' V âˆˆ ğ“ x :=\n  preimage_nhds_coinduced hs\n\n"}
{"name":"Dense.quotient","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ¹ : Setoid X\ninstâœ : TopologicalSpace X\ns : Set X\nH : Dense s\nâŠ¢ Dense (Set.image Quotient.mk' s)","decl":"/-- The image of a dense set under `Quotient.mk'` is a dense set. -/\ntheorem Dense.quotient [Setoid X] [TopologicalSpace X] {s : Set X} (H : Dense s) :\n    Dense (Quotient.mk' '' s) :=\n  Quotient.mk''_surjective.denseRange.dense_image continuous_coinduced_rng H\n\n"}
{"name":"DenseRange.quotient","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : Setoid X\ninstâœ : TopologicalSpace X\nf : Y â†’ X\nhf : DenseRange f\nâŠ¢ DenseRange (Function.comp Quotient.mk' f)","decl":"/-- The composition of `Quotient.mk'` and a function with dense range has dense range. -/\ntheorem DenseRange.quotient [Setoid X] [TopologicalSpace X] {f : Y â†’ X} (hf : DenseRange f) :\n    DenseRange (Quotient.mk' âˆ˜ f) :=\n  Quotient.mk''_surjective.denseRange.comp hf continuous_coinduced_rng\n\n"}
{"name":"continuous_map_of_le","module":"Mathlib.Topology.Constructions","initialProofState":"Î± : Type u_5\ninstâœ : TopologicalSpace Î±\ns t : Setoid Î±\nh : LE.le s t\nâŠ¢ Continuous (Setoid.map_of_le h)","decl":"theorem continuous_map_of_le {Î± : Type*} [TopologicalSpace Î±]\n    {s t : Setoid Î±} (h : s â‰¤ t) : Continuous (Setoid.map_of_le h) :=\n  continuous_coinduced_rng\n\n"}
{"name":"continuous_map_sInf","module":"Mathlib.Topology.Constructions","initialProofState":"Î± : Type u_5\ninstâœ : TopologicalSpace Î±\nS : Set (Setoid Î±)\ns : Setoid Î±\nh : Membership.mem S s\nâŠ¢ Continuous (Setoid.map_sInf h)","decl":"theorem continuous_map_sInf {Î± : Type*} [TopologicalSpace Î±]\n    {S : Set (Setoid Î±)} {s : Setoid Î±} (h : s âˆˆ S) : Continuous (Setoid.map_sInf h) :=\n  continuous_coinduced_rng\n\n"}
{"name":"instDiscreteTopologySubtype","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\np : X â†’ Prop\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : DiscreteTopology X\nâŠ¢ DiscreteTopology (Subtype p)","decl":"instance {p : X â†’ Prop} [TopologicalSpace X] [DiscreteTopology X] : DiscreteTopology (Subtype p) :=\n  âŸ¨bot_unique fun s _ => âŸ¨(â†‘) '' s, isOpen_discrete _, preimage_image_eq _ Subtype.val_injectiveâŸ©âŸ©\n\n"}
{"name":"Sum.discreteTopology","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nh : DiscreteTopology X\nhY : DiscreteTopology Y\nâŠ¢ DiscreteTopology (Sum X Y)","decl":"instance Sum.discreteTopology [TopologicalSpace X] [TopologicalSpace Y] [h : DiscreteTopology X]\n    [hY : DiscreteTopology Y] : DiscreteTopology (X âŠ• Y) :=\n  âŸ¨sup_eq_bot_iff.2 <| by simp [h.eq_bot, hY.eq_bot]âŸ©\n\n"}
{"name":"Sigma.discreteTopology","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nY : Î¹ â†’ Type v\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Y i)\nh : âˆ€ (i : Î¹), DiscreteTopology (Y i)\nâŠ¢ DiscreteTopology (Sigma Y)","decl":"instance Sigma.discreteTopology {Î¹ : Type*} {Y : Î¹ â†’ Type v} [âˆ€ i, TopologicalSpace (Y i)]\n    [h : âˆ€ i, DiscreteTopology (Y i)] : DiscreteTopology (Sigma Y) :=\n  âŸ¨iSup_eq_bot.2 fun _ => by simp only [(h _).eq_bot, coinduced_bot]âŸ©\n\n"}
{"name":"comap_nhdsWithin_range","module":"Mathlib.Topology.Constructions","initialProofState":"Î± : Type u_5\nÎ² : Type u_6\ninstâœ : TopologicalSpace Î²\nf : Î± â†’ Î²\ny : Î²\nâŠ¢ Eq (Filter.comap f (nhdsWithin y (Set.range f))) (Filter.comap f (nhds y))","decl":"@[simp] lemma comap_nhdsWithin_range {Î± Î²} [TopologicalSpace Î²] (f : Î± â†’ Î²) (y : Î²) :\n    comap f (ğ“[range f] y) = comap f (ğ“ y) := comap_inf_principal_range\n\n"}
{"name":"mem_nhds_subtype","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nx : Subtype fun x => Membership.mem s x\nt : Set (Subtype fun x => Membership.mem s x)\nâŠ¢ Iff (Membership.mem (nhds x) t) (Exists fun u => And (Membership.mem (nhds â†‘x) u) (HasSubset.Subset (Set.preimage Subtype.val u) t))","decl":"theorem mem_nhds_subtype (s : Set X) (x : { x // x âˆˆ s }) (t : Set { x // x âˆˆ s }) :\n    t âˆˆ ğ“ x â†” âˆƒ u âˆˆ ğ“ (x : X), Subtype.val â»Â¹' u âŠ† t :=\n  mem_nhds_induced _ x t\n\n"}
{"name":"nhds_subtype","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nx : Subtype fun x => Membership.mem s x\nâŠ¢ Eq (nhds x) (Filter.comap Subtype.val (nhds â†‘x))","decl":"theorem nhds_subtype (s : Set X) (x : { x // x âˆˆ s }) : ğ“ x = comap (â†‘) (ğ“ (x : X)) :=\n  nhds_induced _ x\n\n"}
{"name":"nhds_subtype_eq_comap_nhdsWithin","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nx : Subtype fun x => Membership.mem s x\nâŠ¢ Eq (nhds x) (Filter.comap Subtype.val (nhdsWithin (â†‘x) s))","decl":"lemma nhds_subtype_eq_comap_nhdsWithin (s : Set X) (x : { x // x âˆˆ s }) :\n    ğ“ x = comap (â†‘) (ğ“[s] (x : X)) := by\n  rw [nhds_subtype, â† comap_nhdsWithin_range, Subtype.range_val]\n\n"}
{"name":"nhdsWithin_subtype_eq_bot_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nx : â†‘s\nâŠ¢ Iff (Eq (nhdsWithin x (Set.preimage Subtype.val t)) Bot.bot) (Eq (Min.min (nhdsWithin (â†‘x) t) (Filter.principal s)) Bot.bot)","decl":"theorem nhdsWithin_subtype_eq_bot_iff {s t : Set X} {x : s} :\n    ğ“[((â†‘) : s â†’ X) â»Â¹' t] x = âŠ¥ â†” ğ“[t] (x : X) âŠ“ ğ“Ÿ s = âŠ¥ := by\n  rw [inf_principal_eq_bot_iff_comap, nhdsWithin, nhdsWithin, comap_inf, comap_principal,\n    nhds_induced]\n\n"}
{"name":"nhds_ne_subtype_eq_bot_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nS : Set X\nx : â†‘S\nâŠ¢ Iff (Eq (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) Bot.bot) (Eq (Min.min (nhdsWithin (â†‘x) (HasCompl.compl (Singleton.singleton â†‘x))) (Filter.principal S)) Bot.bot)","decl":"theorem nhds_ne_subtype_eq_bot_iff {S : Set X} {x : S} :\n    ğ“[â‰ ] x = âŠ¥ â†” ğ“[â‰ ] (x : X) âŠ“ ğ“Ÿ S = âŠ¥ := by\n  rw [â† nhdsWithin_subtype_eq_bot_iff, preimage_compl, â† image_singleton,\n    Subtype.coe_injective.preimage_image]\n\n"}
{"name":"nhds_ne_subtype_neBot_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nS : Set X\nx : â†‘S\nâŠ¢ Iff (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot (Min.min (nhdsWithin (â†‘x) (HasCompl.compl (Singleton.singleton â†‘x))) (Filter.principal S)).NeBot","decl":"theorem nhds_ne_subtype_neBot_iff {S : Set X} {x : S} :\n    (ğ“[â‰ ] x).NeBot â†” (ğ“[â‰ ] (x : X) âŠ“ ğ“Ÿ S).NeBot := by\n  rw [neBot_iff, neBot_iff, not_iff_not, nhds_ne_subtype_eq_bot_iff]\n\n"}
{"name":"discreteTopology_subtype_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nS : Set X\nâŠ¢ Iff (DiscreteTopology â†‘S) (âˆ€ (x : X), Membership.mem S x â†’ Eq (Min.min (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) (Filter.principal S)) Bot.bot)","decl":"theorem discreteTopology_subtype_iff {S : Set X} :\n    DiscreteTopology S â†” âˆ€ x âˆˆ S, ğ“[â‰ ] x âŠ“ ğ“Ÿ S = âŠ¥ := by\n  simp_rw [discreteTopology_iff_nhds_ne, SetCoe.forall', nhds_ne_subtype_eq_bot_iff]\n\n"}
{"name":"CofiniteTopology.isOpen_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ns : Set (CofiniteTopology X)\nâŠ¢ Iff (IsOpen s) (s.Nonempty â†’ (HasCompl.compl s).Finite)","decl":"theorem isOpen_iff {s : Set (CofiniteTopology X)} : IsOpen s â†” s.Nonempty â†’ sá¶œ.Finite :=\n  Iff.rfl\n\n"}
{"name":"CofiniteTopology.isOpen_iff'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ns : Set (CofiniteTopology X)\nâŠ¢ Iff (IsOpen s) (Or (Eq s EmptyCollection.emptyCollection) (HasCompl.compl s).Finite)","decl":"theorem isOpen_iff' {s : Set (CofiniteTopology X)} : IsOpen s â†” s = âˆ… âˆ¨ sá¶œ.Finite := by\n  simp only [isOpen_iff, nonempty_iff_ne_empty, or_iff_not_imp_left]\n\n"}
{"name":"CofiniteTopology.isClosed_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ns : Set (CofiniteTopology X)\nâŠ¢ Iff (IsClosed s) (Or (Eq s Set.univ) s.Finite)","decl":"theorem isClosed_iff {s : Set (CofiniteTopology X)} : IsClosed s â†” s = univ âˆ¨ s.Finite := by\n  simp only [â† isOpen_compl_iff, isOpen_iff', compl_compl, compl_empty_iff]\n\n"}
{"name":"CofiniteTopology.nhds_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nx : CofiniteTopology X\nâŠ¢ Eq (nhds x) (Max.max (Pure.pure x) Filter.cofinite)","decl":"theorem nhds_eq (x : CofiniteTopology X) : ğ“ x = pure x âŠ” cofinite := by\n  ext U\n  rw [mem_nhds_iff]\n  constructor\n  Â· rintro âŸ¨V, hVU, V_op, haVâŸ©\n    exact mem_sup.mpr âŸ¨hVU haV, mem_of_superset (V_op âŸ¨_, haVâŸ©) hVUâŸ©\n  Â· rintro âŸ¨hU : x âˆˆ U, hU' : Uá¶œ.FiniteâŸ©\n    exact âŸ¨U, Subset.rfl, fun _ => hU', hUâŸ©\n\n"}
{"name":"CofiniteTopology.mem_nhds_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nx : CofiniteTopology X\ns : Set (CofiniteTopology X)\nâŠ¢ Iff (Membership.mem (nhds x) s) (And (Membership.mem s x) (HasCompl.compl s).Finite)","decl":"theorem mem_nhds_iff {x : CofiniteTopology X} {s : Set (CofiniteTopology X)} :\n    s âˆˆ ğ“ x â†” x âˆˆ s âˆ§ sá¶œ.Finite := by simp [nhds_eq]\n\n"}
{"name":"continuous_prod_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Y\ng : X â†’ Z\nâŠ¢ Iff (Continuous fun x => { fst := f x, snd := g x }) (And (Continuous f) (Continuous g))","decl":"@[simp] theorem continuous_prod_mk {f : X â†’ Y} {g : X â†’ Z} :\n    (Continuous fun x => (f x, g x)) â†” Continuous f âˆ§ Continuous g :=\n  (@continuous_inf_rng X (Y Ã— Z) _ _ (TopologicalSpace.induced Prod.fst _)\n    (TopologicalSpace.induced Prod.snd _)).trans <|\n    continuous_induced_rng.and continuous_induced_rng\n\n"}
{"name":"continuous_fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Continuous Prod.fst","decl":"@[continuity]\ntheorem continuous_fst : Continuous (@Prod.fst X Y) :=\n  (continuous_prod_mk.1 continuous_id).1\n\n"}
{"name":"Continuous.fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Prod Y Z\nhf : Continuous f\nâŠ¢ Continuous fun x => (f x).1","decl":"/-- Postcomposing `f` with `Prod.fst` is continuous -/\n@[fun_prop]\ntheorem Continuous.fst {f : X â†’ Y Ã— Z} (hf : Continuous f) : Continuous fun x : X => (f x).1 :=\n  continuous_fst.comp hf\n\n"}
{"name":"Continuous.fst'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Z\nhf : Continuous f\nâŠ¢ Continuous fun x => f x.1","decl":"/-- Precomposing `f` with `Prod.fst` is continuous -/\ntheorem Continuous.fst' {f : X â†’ Z} (hf : Continuous f) : Continuous fun x : X Ã— Y => f x.fst :=\n  hf.comp continuous_fst\n\n"}
{"name":"continuousAt_fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\np : Prod X Y\nâŠ¢ ContinuousAt Prod.fst p","decl":"theorem continuousAt_fst {p : X Ã— Y} : ContinuousAt Prod.fst p :=\n  continuous_fst.continuousAt\n\n"}
{"name":"ContinuousAt.fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Prod Y Z\nx : X\nhf : ContinuousAt f x\nâŠ¢ ContinuousAt (fun x => (f x).1) x","decl":"/-- Postcomposing `f` with `Prod.fst` is continuous at `x` -/\n@[fun_prop]\ntheorem ContinuousAt.fst {f : X â†’ Y Ã— Z} {x : X} (hf : ContinuousAt f x) :\n    ContinuousAt (fun x : X => (f x).1) x :=\n  continuousAt_fst.comp hf\n\n"}
{"name":"ContinuousAt.fst'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Z\nx : X\ny : Y\nhf : ContinuousAt f x\nâŠ¢ ContinuousAt (fun x => f x.1) { fst := x, snd := y }","decl":"/-- Precomposing `f` with `Prod.fst` is continuous at `(x, y)` -/\ntheorem ContinuousAt.fst' {f : X â†’ Z} {x : X} {y : Y} (hf : ContinuousAt f x) :\n    ContinuousAt (fun x : X Ã— Y => f x.fst) (x, y) :=\n  ContinuousAt.comp hf continuousAt_fst\n\n"}
{"name":"ContinuousAt.fst''","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Z\nx : Prod X Y\nhf : ContinuousAt f x.1\nâŠ¢ ContinuousAt (fun x => f x.1) x","decl":"/-- Precomposing `f` with `Prod.fst` is continuous at `x : X Ã— Y` -/\ntheorem ContinuousAt.fst'' {f : X â†’ Z} {x : X Ã— Y} (hf : ContinuousAt f x.fst) :\n    ContinuousAt (fun x : X Ã— Y => f x.fst) x :=\n  hf.comp continuousAt_fst\n\n"}
{"name":"Filter.Tendsto.fst_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nZ : Type u_1\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nX : Type u_5\nl : Filter X\nf : X â†’ Prod Y Z\np : Prod Y Z\nh : Filter.Tendsto f l (nhds p)\nâŠ¢ Filter.Tendsto (fun a => (f a).1) l (nhds p.1)","decl":"theorem Filter.Tendsto.fst_nhds {X} {l : Filter X} {f : X â†’ Y Ã— Z} {p : Y Ã— Z}\n    (h : Tendsto f l (ğ“ p)) : Tendsto (fun a â†¦ (f a).1) l (ğ“ <| p.1) :=\n  continuousAt_fst.tendsto.comp h\n\n"}
{"name":"continuous_snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Continuous Prod.snd","decl":"@[continuity]\ntheorem continuous_snd : Continuous (@Prod.snd X Y) :=\n  (continuous_prod_mk.1 continuous_id).2\n\n"}
{"name":"Continuous.snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Prod Y Z\nhf : Continuous f\nâŠ¢ Continuous fun x => (f x).2","decl":"/-- Postcomposing `f` with `Prod.snd` is continuous -/\n@[fun_prop]\ntheorem Continuous.snd {f : X â†’ Y Ã— Z} (hf : Continuous f) : Continuous fun x : X => (f x).2 :=\n  continuous_snd.comp hf\n\n"}
{"name":"Continuous.snd'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : Y â†’ Z\nhf : Continuous f\nâŠ¢ Continuous fun x => f x.2","decl":"/-- Precomposing `f` with `Prod.snd` is continuous -/\ntheorem Continuous.snd' {f : Y â†’ Z} (hf : Continuous f) : Continuous fun x : X Ã— Y => f x.snd :=\n  hf.comp continuous_snd\n\n"}
{"name":"continuousAt_snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\np : Prod X Y\nâŠ¢ ContinuousAt Prod.snd p","decl":"theorem continuousAt_snd {p : X Ã— Y} : ContinuousAt Prod.snd p :=\n  continuous_snd.continuousAt\n\n"}
{"name":"ContinuousAt.snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Prod Y Z\nx : X\nhf : ContinuousAt f x\nâŠ¢ ContinuousAt (fun x => (f x).2) x","decl":"/-- Postcomposing `f` with `Prod.snd` is continuous at `x` -/\n@[fun_prop]\ntheorem ContinuousAt.snd {f : X â†’ Y Ã— Z} {x : X} (hf : ContinuousAt f x) :\n    ContinuousAt (fun x : X => (f x).2) x :=\n  continuousAt_snd.comp hf\n\n"}
{"name":"ContinuousAt.snd'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : Y â†’ Z\nx : X\ny : Y\nhf : ContinuousAt f y\nâŠ¢ ContinuousAt (fun x => f x.2) { fst := x, snd := y }","decl":"/-- Precomposing `f` with `Prod.snd` is continuous at `(x, y)` -/\ntheorem ContinuousAt.snd' {f : Y â†’ Z} {x : X} {y : Y} (hf : ContinuousAt f y) :\n    ContinuousAt (fun x : X Ã— Y => f x.snd) (x, y) :=\n  ContinuousAt.comp hf continuousAt_snd\n\n"}
{"name":"ContinuousAt.snd''","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : Y â†’ Z\nx : Prod X Y\nhf : ContinuousAt f x.2\nâŠ¢ ContinuousAt (fun x => f x.2) x","decl":"/-- Precomposing `f` with `Prod.snd` is continuous at `x : X Ã— Y` -/\ntheorem ContinuousAt.snd'' {f : Y â†’ Z} {x : X Ã— Y} (hf : ContinuousAt f x.snd) :\n    ContinuousAt (fun x : X Ã— Y => f x.snd) x :=\n  hf.comp continuousAt_snd\n\n"}
{"name":"Filter.Tendsto.snd_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nZ : Type u_1\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nX : Type u_5\nl : Filter X\nf : X â†’ Prod Y Z\np : Prod Y Z\nh : Filter.Tendsto f l (nhds p)\nâŠ¢ Filter.Tendsto (fun a => (f a).2) l (nhds p.2)","decl":"theorem Filter.Tendsto.snd_nhds {X} {l : Filter X} {f : X â†’ Y Ã— Z} {p : Y Ã— Z}\n    (h : Tendsto f l (ğ“ p)) : Tendsto (fun a â†¦ (f a).2) l (ğ“ <| p.2) :=\n  continuousAt_snd.tendsto.comp h\n\n"}
{"name":"Continuous.prod_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : Z â†’ X\ng : Z â†’ Y\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun x => { fst := f x, snd := g x }","decl":"@[continuity, fun_prop]\ntheorem Continuous.prod_mk {f : Z â†’ X} {g : Z â†’ Y} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x => (f x, g x) :=\n  continuous_prod_mk.2 âŸ¨hf, hgâŸ©\n\n"}
{"name":"Continuous.Prod.mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : X\nâŠ¢ Continuous fun y => { fst := x, snd := y }","decl":"@[continuity]\ntheorem Continuous.Prod.mk (x : X) : Continuous fun y : Y => (x, y) :=\n  continuous_const.prod_mk continuous_id\n\n"}
{"name":"Continuous.Prod.mk_left","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ny : Y\nâŠ¢ Continuous fun x => { fst := x, snd := y }","decl":"@[continuity]\ntheorem Continuous.Prod.mk_left (y : Y) : Continuous fun x : X => (x, y) :=\n  continuous_id.prod_mk continuous_const\n\n"}
{"name":"IsClosed.setOf_mapsTo","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Z\nÎ± : Type u_5\nf : X â†’ Î± â†’ Z\ns : Set Î±\nt : Set Z\nht : IsClosed t\nhf : âˆ€ (a : Î±), Membership.mem s a â†’ Continuous fun x => f x a\nâŠ¢ IsClosed (setOf fun x => Set.MapsTo (f x) s t)","decl":"/-- If `f x y` is continuous in `x` for all `y âˆˆ s`,\nthen the set of `x` such that `f x` maps `s` to `t` is closed. -/\nlemma IsClosed.setOf_mapsTo {Î± : Type*} {f : X â†’ Î± â†’ Z} {s : Set Î±} {t : Set Z} (ht : IsClosed t)\n    (hf : âˆ€ a âˆˆ s, Continuous (f Â· a)) : IsClosed {x | MapsTo (f x) s t} := by\n  simpa only [MapsTo, setOf_forall] using isClosed_biInter fun y hy â†¦ ht.preimage (hf y hy)\n\n"}
{"name":"Continuous.compâ‚‚","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\ng : Prod X Y â†’ Z\nhg : Continuous g\ne : W â†’ X\nhe : Continuous e\nf : W â†’ Y\nhf : Continuous f\nâŠ¢ Continuous fun w => g { fst := e w, snd := f w }","decl":"theorem Continuous.compâ‚‚ {g : X Ã— Y â†’ Z} (hg : Continuous g) {e : W â†’ X} (he : Continuous e)\n    {f : W â†’ Y} (hf : Continuous f) : Continuous fun w => g (e w, f w) :=\n  hg.comp <| he.prod_mk hf\n\n"}
{"name":"Continuous.compâ‚ƒ","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\nÎµ : Type u_3\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : TopologicalSpace Y\ninstâœÂ² : TopologicalSpace Z\ninstâœÂ¹ : TopologicalSpace W\ninstâœ : TopologicalSpace Îµ\ng : Prod X (Prod Y Z) â†’ Îµ\nhg : Continuous g\ne : W â†’ X\nhe : Continuous e\nf : W â†’ Y\nhf : Continuous f\nk : W â†’ Z\nhk : Continuous k\nâŠ¢ Continuous fun w => g { fst := e w, snd := { fst := f w, snd := k w } }","decl":"theorem Continuous.compâ‚ƒ {g : X Ã— Y Ã— Z â†’ Îµ} (hg : Continuous g) {e : W â†’ X} (he : Continuous e)\n    {f : W â†’ Y} (hf : Continuous f) {k : W â†’ Z} (hk : Continuous k) :\n    Continuous fun w => g (e w, f w, k w) :=\n  hg.compâ‚‚ he <| hf.prod_mk hk\n\n"}
{"name":"Continuous.compâ‚„","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\nÎµ : Type u_3\nÎ¶ : Type u_4\ninstâœâµ : TopologicalSpace X\ninstâœâ´ : TopologicalSpace Y\ninstâœÂ³ : TopologicalSpace Z\ninstâœÂ² : TopologicalSpace W\ninstâœÂ¹ : TopologicalSpace Îµ\ninstâœ : TopologicalSpace Î¶\ng : Prod X (Prod Y (Prod Z Î¶)) â†’ Îµ\nhg : Continuous g\ne : W â†’ X\nhe : Continuous e\nf : W â†’ Y\nhf : Continuous f\nk : W â†’ Z\nhk : Continuous k\nl : W â†’ Î¶\nhl : Continuous l\nâŠ¢ Continuous fun w => g { fst := e w, snd := { fst := f w, snd := { fst := k w, snd := l w } } }","decl":"theorem Continuous.compâ‚„ {g : X Ã— Y Ã— Z Ã— Î¶ â†’ Îµ} (hg : Continuous g) {e : W â†’ X} (he : Continuous e)\n    {f : W â†’ Y} (hf : Continuous f) {k : W â†’ Z} (hk : Continuous k) {l : W â†’ Î¶}\n    (hl : Continuous l) : Continuous fun w => g (e w, f w, k w, l w) :=\n  hg.compâ‚ƒ he hf <| hk.prod_mk hl\n\n"}
{"name":"Continuous.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : Z â†’ X\ng : W â†’ Y\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous (Prod.map f g)","decl":"@[continuity]\ntheorem Continuous.prodMap {f : Z â†’ X} {g : W â†’ Y} (hf : Continuous f) (hg : Continuous g) :\n    Continuous (Prod.map f g) :=\n  hf.fst'.prod_mk hg.snd'\n\n"}
{"name":"Continuous.prod_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : Z â†’ X\ng : W â†’ Y\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-05\")] alias Continuous.prod_map := Continuous.prodMap\n\n"}
{"name":"continuous_inf_dom_leftâ‚‚","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X â†’ Y â†’ Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nâŠ¢ Continuous fun p => f p.1 p.2","decl":"/-- A version of `continuous_inf_dom_left` for binary functions -/\ntheorem continuous_inf_dom_leftâ‚‚ {X Y Z} {f : X â†’ Y â†’ Z} {ta1 ta2 : TopologicalSpace X}\n    {tb1 tb2 : TopologicalSpace Y} {tc1 : TopologicalSpace Z}\n    (h : by haveI := ta1; haveI := tb1; exact Continuous fun p : X Ã— Y => f p.1 p.2) : by\n    haveI := ta1 âŠ“ ta2; haveI := tb1 âŠ“ tb2; exact Continuous fun p : X Ã— Y => f p.1 p.2 := by\n  have ha := @continuous_inf_dom_left _ _ id ta1 ta2 ta1 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_left _ _ id tb1 tb2 tb1 (@continuous_id _ (id _))\n  have h_continuous_id := @Continuous.prodMap _ _ _ _ ta1 tb1 (ta1 âŠ“ ta2) (tb1 âŠ“ tb2) _ _ ha hb\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n\n"}
{"name":"continuous_inf_dom_rightâ‚‚","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X â†’ Y â†’ Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nâŠ¢ Continuous fun p => f p.1 p.2","decl":"/-- A version of `continuous_inf_dom_right` for binary functions -/\ntheorem continuous_inf_dom_rightâ‚‚ {X Y Z} {f : X â†’ Y â†’ Z} {ta1 ta2 : TopologicalSpace X}\n    {tb1 tb2 : TopologicalSpace Y} {tc1 : TopologicalSpace Z}\n    (h : by haveI := ta2; haveI := tb2; exact Continuous fun p : X Ã— Y => f p.1 p.2) : by\n    haveI := ta1 âŠ“ ta2; haveI := tb1 âŠ“ tb2; exact Continuous fun p : X Ã— Y => f p.1 p.2 := by\n  have ha := @continuous_inf_dom_right _ _ id ta1 ta2 ta2 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_right _ _ id tb1 tb2 tb2 (@continuous_id _ (id _))\n  have h_continuous_id := @Continuous.prodMap _ _ _ _ ta2 tb2 (ta1 âŠ“ ta2) (tb1 âŠ“ tb2) _ _ ha hb\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n\n"}
{"name":"continuous_sInf_domâ‚‚","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X â†’ Y â†’ Z\ntas : Set (TopologicalSpace X)\ntbs : Set (TopologicalSpace Y)\ntX : TopologicalSpace X\ntY : TopologicalSpace Y\ntc : TopologicalSpace Z\nhX : Membership.mem tas tX\nhY : Membership.mem tbs tY\nhf : Continuous fun p => f p.1 p.2\nâŠ¢ Continuous fun p => f p.1 p.2","decl":"/-- A version of `continuous_sInf_dom` for binary functions -/\ntheorem continuous_sInf_domâ‚‚ {X Y Z} {f : X â†’ Y â†’ Z} {tas : Set (TopologicalSpace X)}\n    {tbs : Set (TopologicalSpace Y)} {tX : TopologicalSpace X} {tY : TopologicalSpace Y}\n    {tc : TopologicalSpace Z} (hX : tX âˆˆ tas) (hY : tY âˆˆ tbs)\n    (hf : Continuous fun p : X Ã— Y => f p.1 p.2) : by\n    haveI := sInf tas; haveI := sInf tbs\n    exact @Continuous _ _ _ tc fun p : X Ã— Y => f p.1 p.2 := by\n  have hX := continuous_sInf_dom hX continuous_id\n  have hY := continuous_sInf_dom hY continuous_id\n  have h_continuous_id := @Continuous.prodMap _ _ _ _ tX tY (sInf tas) (sInf tbs) _ _ hX hY\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ hf h_continuous_id\n\n"}
{"name":"Filter.Eventually.prod_inl_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\np : X â†’ Prop\nx : X\nh : Filter.Eventually (fun x => p x) (nhds x)\ny : Y\nâŠ¢ Filter.Eventually (fun x => p x.1) (nhds { fst := x, snd := y })","decl":"theorem Filter.Eventually.prod_inl_nhds {p : X â†’ Prop} {x : X} (h : âˆ€á¶  x in ğ“ x, p x) (y : Y) :\n    âˆ€á¶  x in ğ“ (x, y), p (x : X Ã— Y).1 :=\n  continuousAt_fst h\n\n"}
{"name":"Filter.Eventually.prod_inr_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\np : Y â†’ Prop\ny : Y\nh : Filter.Eventually (fun x => p x) (nhds y)\nx : X\nâŠ¢ Filter.Eventually (fun x => p x.2) (nhds { fst := x, snd := y })","decl":"theorem Filter.Eventually.prod_inr_nhds {p : Y â†’ Prop} {y : Y} (h : âˆ€á¶  x in ğ“ y, p x) (x : X) :\n    âˆ€á¶  x in ğ“ (x, y), p (x : X Ã— Y).2 :=\n  continuousAt_snd h\n\n"}
{"name":"Filter.Eventually.prod_mk_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\npx : X â†’ Prop\nx : X\nhx : Filter.Eventually (fun x => px x) (nhds x)\npy : Y â†’ Prop\ny : Y\nhy : Filter.Eventually (fun y => py y) (nhds y)\nâŠ¢ Filter.Eventually (fun p => And (px p.1) (py p.2)) (nhds { fst := x, snd := y })","decl":"theorem Filter.Eventually.prod_mk_nhds {px : X â†’ Prop} {x} (hx : âˆ€á¶  x in ğ“ x, px x) {py : Y â†’ Prop}\n    {y} (hy : âˆ€á¶  y in ğ“ y, py y) : âˆ€á¶  p in ğ“ (x, y), px (p : X Ã— Y).1 âˆ§ py p.2 :=\n  (hx.prod_inl_nhds y).and (hy.prod_inr_nhds x)\n\n"}
{"name":"continuous_swap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Continuous Prod.swap","decl":"theorem continuous_swap : Continuous (Prod.swap : X Ã— Y â†’ Y Ã— X) :=\n  continuous_snd.prod_mk continuous_fst\n\n"}
{"name":"isClosedMap_swap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ IsClosedMap Prod.swap","decl":"lemma isClosedMap_swap : IsClosedMap (Prod.swap : X Ã— Y â†’ Y Ã— X) := fun s hs â†¦ by\n  rw [image_swap_eq_preimage_swap]\n  exact hs.preimage continuous_swap\n\n"}
{"name":"Continuous.uncurry_left","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Y â†’ Z\nx : X\nh : Continuous (Function.uncurry f)\nâŠ¢ Continuous (f x)","decl":"theorem Continuous.uncurry_left {f : X â†’ Y â†’ Z} (x : X) (h : Continuous (uncurry f)) :\n    Continuous (f x) :=\n  h.comp (Continuous.Prod.mk _)\n\n"}
{"name":"Continuous.uncurry_right","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Y â†’ Z\ny : Y\nh : Continuous (Function.uncurry f)\nâŠ¢ Continuous fun a => f a y","decl":"theorem Continuous.uncurry_right {f : X â†’ Y â†’ Z} (y : Y) (h : Continuous (uncurry f)) :\n    Continuous fun a => f a y :=\n  h.comp (Continuous.Prod.mk_left _)\n\n\n"}
{"name":"continuous_curry","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\ng : Prod X Y â†’ Z\nx : X\nh : Continuous g\nâŠ¢ Continuous (Function.curry g x)","decl":"theorem continuous_curry {g : X Ã— Y â†’ Z} (x : X) (h : Continuous g) : Continuous (curry g x) :=\n  Continuous.uncurry_left x h\n\n"}
{"name":"IsOpen.prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nt : Set Y\nhs : IsOpen s\nht : IsOpen t\nâŠ¢ IsOpen (SProd.sprod s t)","decl":"theorem IsOpen.prod {s : Set X} {t : Set Y} (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s Ã—Ë¢ t) :=\n  (hs.preimage continuous_fst).inter (ht.preimage continuous_snd)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: Lean fails to find `tâ‚` and `tâ‚‚` by unification\n"}
{"name":"nhds_prod_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : X\ny : Y\nâŠ¢ Eq (nhds { fst := x, snd := y }) (SProd.sprod (nhds x) (nhds y))","decl":"theorem nhds_prod_eq {x : X} {y : Y} : ğ“ (x, y) = ğ“ x Ã—Ë¢ ğ“ y := by\n  rw [prod_eq_inf, instTopologicalSpaceProd, nhds_inf (tâ‚ := TopologicalSpace.induced Prod.fst _)\n    (tâ‚‚ := TopologicalSpace.induced Prod.snd _), nhds_induced, nhds_induced]\n\n"}
{"name":"nhdsWithin_prod_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : X\ny : Y\ns : Set X\nt : Set Y\nâŠ¢ Eq (nhdsWithin { fst := x, snd := y } (SProd.sprod s t)) (SProd.sprod (nhdsWithin x s) (nhdsWithin y t))","decl":"theorem nhdsWithin_prod_eq (x : X) (y : Y) (s : Set X) (t : Set Y) :\n    ğ“[s Ã—Ë¢ t] (x, y) = ğ“[s] x Ã—Ë¢ ğ“[t] y := by\n  simp only [nhdsWithin, nhds_prod_eq, â† prod_inf_prod, prod_principal_principal]\n\n"}
{"name":"Prod.instNeBotNhdsWithinIio","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : Preorder X\ninstâœ : Preorder Y\nx : Prod X Y\nhxâ‚ : (nhdsWithin x.1 (Set.Iio x.1)).NeBot\nhxâ‚‚ : (nhdsWithin x.2 (Set.Iio x.2)).NeBot\nâŠ¢ (nhdsWithin x (Set.Iio x)).NeBot","decl":"instance Prod.instNeBotNhdsWithinIio [Preorder X] [Preorder Y] {x : X Ã— Y}\n    [hxâ‚ : (ğ“[<] x.1).NeBot] [hxâ‚‚ : (ğ“[<] x.2).NeBot] : (ğ“[<] x).NeBot := by\n  refine (hxâ‚.prod hxâ‚‚).mono ?_\n  rw [â† nhdsWithin_prod_eq]\n  exact nhdsWithin_mono _ fun _ âŸ¨hâ‚, hâ‚‚âŸ© â†¦ Prod.lt_iff.2 <| .inl âŸ¨hâ‚, hâ‚‚.leâŸ©\n\n"}
{"name":"Prod.instNeBotNhdsWithinIoi","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœâµ : TopologicalSpace X\ninstâœâ´ : TopologicalSpace Y\ninstâœÂ³ : Preorder X\ninstâœÂ² : Preorder Y\nx : Prod X Y\ninstâœÂ¹ : (nhdsWithin x.1 (Set.Ioi x.1)).NeBot\ninstâœ : (nhdsWithin x.2 (Set.Ioi x.2)).NeBot\nâŠ¢ (nhdsWithin x (Set.Ioi x)).NeBot","decl":"instance Prod.instNeBotNhdsWithinIoi [Preorder X] [Preorder Y] {x : X Ã— Y}\n    [(ğ“[>] x.1).NeBot] [(ğ“[>] x.2).NeBot] : (ğ“[>] x).NeBot :=\n  Prod.instNeBotNhdsWithinIio (X := Xáµ’áµˆ) (Y := Yáµ’áµˆ)\n    (x := (OrderDual.toDual x.1, OrderDual.toDual x.2))\n\n"}
{"name":"mem_nhds_prod_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : X\ny : Y\ns : Set (Prod X Y)\nâŠ¢ Iff (Membership.mem (nhds { fst := x, snd := y }) s) (Exists fun u => And (Membership.mem (nhds x) u) (Exists fun v => And (Membership.mem (nhds y) v) (HasSubset.Subset (SProd.sprod u v) s)))","decl":"theorem mem_nhds_prod_iff {x : X} {y : Y} {s : Set (X Ã— Y)} :\n    s âˆˆ ğ“ (x, y) â†” âˆƒ u âˆˆ ğ“ x, âˆƒ v âˆˆ ğ“ y, u Ã—Ë¢ v âŠ† s := by rw [nhds_prod_eq, mem_prod_iff]\n\n"}
{"name":"mem_nhdsWithin_prod_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : X\ny : Y\ns : Set (Prod X Y)\ntx : Set X\nty : Set Y\nâŠ¢ Iff (Membership.mem (nhdsWithin { fst := x, snd := y } (SProd.sprod tx ty)) s) (Exists fun u => And (Membership.mem (nhdsWithin x tx) u) (Exists fun v => And (Membership.mem (nhdsWithin y ty) v) (HasSubset.Subset (SProd.sprod u v) s)))","decl":"theorem mem_nhdsWithin_prod_iff {x : X} {y : Y} {s : Set (X Ã— Y)} {tx : Set X} {ty : Set Y} :\n    s âˆˆ ğ“[tx Ã—Ë¢ ty] (x, y) â†” âˆƒ u âˆˆ ğ“[tx] x, âˆƒ v âˆˆ ğ“[ty] y, u Ã—Ë¢ v âŠ† s := by\n  rw [nhdsWithin_prod_eq, mem_prod_iff]\n\n"}
{"name":"Filter.HasBasis.prod_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nÎ¹X : Type u_5\nÎ¹Y : Type u_6\npx : Î¹X â†’ Prop\npy : Î¹Y â†’ Prop\nsx : Î¹X â†’ Set X\nsy : Î¹Y â†’ Set Y\nx : X\ny : Y\nhx : (nhds x).HasBasis px sx\nhy : (nhds y).HasBasis py sy\nâŠ¢ (nhds { fst := x, snd := y }).HasBasis (fun i => And (px i.1) (py i.2)) fun i => SProd.sprod (sx i.1) (sy i.2)","decl":"theorem Filter.HasBasis.prod_nhds {Î¹X Î¹Y : Type*} {px : Î¹X â†’ Prop} {py : Î¹Y â†’ Prop}\n    {sx : Î¹X â†’ Set X} {sy : Î¹Y â†’ Set Y} {x : X} {y : Y} (hx : (ğ“ x).HasBasis px sx)\n    (hy : (ğ“ y).HasBasis py sy) :\n    (ğ“ (x, y)).HasBasis (fun i : Î¹X Ã— Î¹Y => px i.1 âˆ§ py i.2) fun i => sx i.1 Ã—Ë¢ sy i.2 := by\n  rw [nhds_prod_eq]\n  exact hx.prod hy\n\n"}
{"name":"Filter.HasBasis.prod_nhds'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nÎ¹X : Type u_5\nÎ¹Y : Type u_6\npX : Î¹X â†’ Prop\npY : Î¹Y â†’ Prop\nsx : Î¹X â†’ Set X\nsy : Î¹Y â†’ Set Y\np : Prod X Y\nhx : (nhds p.1).HasBasis pX sx\nhy : (nhds p.2).HasBasis pY sy\nâŠ¢ (nhds p).HasBasis (fun i => And (pX i.1) (pY i.2)) fun i => SProd.sprod (sx i.1) (sy i.2)","decl":"theorem Filter.HasBasis.prod_nhds' {Î¹X Î¹Y : Type*} {pX : Î¹X â†’ Prop} {pY : Î¹Y â†’ Prop}\n    {sx : Î¹X â†’ Set X} {sy : Î¹Y â†’ Set Y} {p : X Ã— Y} (hx : (ğ“ p.1).HasBasis pX sx)\n    (hy : (ğ“ p.2).HasBasis pY sy) :\n    (ğ“ p).HasBasis (fun i : Î¹X Ã— Î¹Y => pX i.1 âˆ§ pY i.2) fun i => sx i.1 Ã—Ë¢ sy i.2 :=\n  hx.prod_nhds hy\n\n"}
{"name":"MapClusterPt.curry_prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nÎ± : Type u_5\nÎ² : Type u_6\nf : Î± â†’ X\ng : Î² â†’ Y\nla : Filter Î±\nlb : Filter Î²\nx : X\ny : Y\nhf : MapClusterPt x la f\nhg : MapClusterPt y lb g\nâŠ¢ MapClusterPt { fst := x, snd := y } (la.curry lb) (Prod.map f g)","decl":"theorem MapClusterPt.curry_prodMap {Î± Î² : Type*}\n    {f : Î± â†’ X} {g : Î² â†’ Y} {la : Filter Î±} {lb : Filter Î²} {x : X} {y : Y}\n    (hf : MapClusterPt x la f) (hg : MapClusterPt y lb g) :\n    MapClusterPt (x, y) (la.curry lb) (.map f g) := by\n  rw [mapClusterPt_iff] at hf hg\n  rw [((ğ“ x).basis_sets.prod_nhds (ğ“ y).basis_sets).mapClusterPt_iff_frequently]\n  rintro âŸ¨s, tâŸ© âŸ¨hs, htâŸ©\n  rw [frequently_curry_iff]\n  exact (hf s hs).mono fun x hx â†¦ (hg t ht).mono fun y hy â†¦ âŸ¨hx, hyâŸ©\n\n"}
{"name":"MapClusterPt.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nÎ± : Type u_5\nÎ² : Type u_6\nf : Î± â†’ X\ng : Î² â†’ Y\nla : Filter Î±\nlb : Filter Î²\nx : X\ny : Y\nhf : MapClusterPt x la f\nhg : MapClusterPt y lb g\nâŠ¢ MapClusterPt { fst := x, snd := y } (SProd.sprod la lb) (Prod.map f g)","decl":"theorem MapClusterPt.prodMap {Î± Î² : Type*}\n    {f : Î± â†’ X} {g : Î² â†’ Y} {la : Filter Î±} {lb : Filter Î²} {x : X} {y : Y}\n    (hf : MapClusterPt x la f) (hg : MapClusterPt y lb g) :\n    MapClusterPt (x, y) (la Ã—Ë¢ lb) (.map f g) :=\n  (hf.curry_prodMap hg).mono <| map_mono curry_le_prod\n\n"}
{"name":"mem_nhds_prod_iff'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : X\ny : Y\ns : Set (Prod X Y)\nâŠ¢ Iff (Membership.mem (nhds { fst := x, snd := y }) s) (Exists fun u => Exists fun v => And (IsOpen u) (And (Membership.mem u x) (And (IsOpen v) (And (Membership.mem v y) (HasSubset.Subset (SProd.sprod u v) s)))))","decl":"theorem mem_nhds_prod_iff' {x : X} {y : Y} {s : Set (X Ã— Y)} :\n    s âˆˆ ğ“ (x, y) â†” âˆƒ u v, IsOpen u âˆ§ x âˆˆ u âˆ§ IsOpen v âˆ§ y âˆˆ v âˆ§ u Ã—Ë¢ v âŠ† s :=\n  ((nhds_basis_opens x).prod_nhds (nhds_basis_opens y)).mem_iff.trans <| by\n    simp only [Prod.exists, and_comm, and_assoc, and_left_comm]\n\n"}
{"name":"Prod.tendsto_iff","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nZ : Type u_1\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nX : Type u_5\nseq : X â†’ Prod Y Z\nf : Filter X\np : Prod Y Z\nâŠ¢ Iff (Filter.Tendsto seq f (nhds p)) (And (Filter.Tendsto (fun n => (seq n).1) f (nhds p.1)) (Filter.Tendsto (fun n => (seq n).2) f (nhds p.2)))","decl":"theorem Prod.tendsto_iff {X} (seq : X â†’ Y Ã— Z) {f : Filter X} (p : Y Ã— Z) :\n    Tendsto seq f (ğ“ p) â†”\n      Tendsto (fun n => (seq n).fst) f (ğ“ p.fst) âˆ§ Tendsto (fun n => (seq n).snd) f (ğ“ p.snd) := by\n  rw [nhds_prod_eq, Filter.tendsto_prod_iff']\n\n"}
{"name":"instDiscreteTopologyProd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : DiscreteTopology X\ninstâœ : DiscreteTopology Y\nâŠ¢ DiscreteTopology (Prod X Y)","decl":"instance [DiscreteTopology X] [DiscreteTopology Y] : DiscreteTopology (X Ã— Y) :=\n  discreteTopology_iff_nhds.2 fun (a, b) => by\n    rw [nhds_prod_eq, nhds_discrete X, nhds_discrete Y, prod_pure_pure]\n\n"}
{"name":"prod_mem_nhds_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nt : Set Y\nx : X\ny : Y\nâŠ¢ Iff (Membership.mem (nhds { fst := x, snd := y }) (SProd.sprod s t)) (And (Membership.mem (nhds x) s) (Membership.mem (nhds y) t))","decl":"theorem prod_mem_nhds_iff {s : Set X} {t : Set Y} {x : X} {y : Y} :\n    s Ã—Ë¢ t âˆˆ ğ“ (x, y) â†” s âˆˆ ğ“ x âˆ§ t âˆˆ ğ“ y := by rw [nhds_prod_eq, prod_mem_prod_iff]\n\n"}
{"name":"prod_mem_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nt : Set Y\nx : X\ny : Y\nhx : Membership.mem (nhds x) s\nhy : Membership.mem (nhds y) t\nâŠ¢ Membership.mem (nhds { fst := x, snd := y }) (SProd.sprod s t)","decl":"theorem prod_mem_nhds {s : Set X} {t : Set Y} {x : X} {y : Y} (hx : s âˆˆ ğ“ x) (hy : t âˆˆ ğ“ y) :\n    s Ã—Ë¢ t âˆˆ ğ“ (x, y) :=\n  prod_mem_nhds_iff.2 âŸ¨hx, hyâŸ©\n\n"}
{"name":"isOpen_setOf_disjoint_nhds_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ IsOpen (setOf fun p => Disjoint (nhds p.1) (nhds p.2))","decl":"theorem isOpen_setOf_disjoint_nhds_nhds : IsOpen { p : X Ã— X | Disjoint (ğ“ p.1) (ğ“ p.2) } := by\n  simp only [isOpen_iff_mem_nhds, Prod.forall, mem_setOf_eq]\n  intro x y h\n  obtain âŸ¨U, hU, V, hV, hdâŸ© := ((nhds_basis_opens x).disjoint_iff (nhds_basis_opens y)).mp h\n  exact mem_nhds_prod_iff'.mpr âŸ¨U, V, hU.2, hU.1, hV.2, hV.1, fun âŸ¨x', y'âŸ© âŸ¨hx', hy'âŸ© =>\n    disjoint_of_disjoint_of_mem hd (hU.2.mem_nhds hx') (hV.2.mem_nhds hy')âŸ©\n\n"}
{"name":"Filter.Eventually.prod_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\np : X â†’ Prop\nq : Y â†’ Prop\nx : X\ny : Y\nhx : Filter.Eventually (fun x => p x) (nhds x)\nhy : Filter.Eventually (fun y => q y) (nhds y)\nâŠ¢ Filter.Eventually (fun z => And (p z.1) (q z.2)) (nhds { fst := x, snd := y })","decl":"theorem Filter.Eventually.prod_nhds {p : X â†’ Prop} {q : Y â†’ Prop} {x : X} {y : Y}\n    (hx : âˆ€á¶  x in ğ“ x, p x) (hy : âˆ€á¶  y in ğ“ y, q y) : âˆ€á¶  z : X Ã— Y in ğ“ (x, y), p z.1 âˆ§ q z.2 :=\n  prod_mem_nhds hx hy\n\n"}
{"name":"nhds_swap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : X\ny : Y\nâŠ¢ Eq (nhds { fst := x, snd := y }) (Filter.map Prod.swap (nhds { fst := y, snd := x }))","decl":"theorem nhds_swap (x : X) (y : Y) : ğ“ (x, y) = (ğ“ (y, x)).map Prod.swap := by\n  rw [nhds_prod_eq, Filter.prod_comm, nhds_prod_eq]; rfl\n\n"}
{"name":"Filter.Tendsto.prod_mk_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nÎ³ : Type u_5\nx : X\ny : Y\nf : Filter Î³\nmx : Î³ â†’ X\nmy : Î³ â†’ Y\nhx : Filter.Tendsto mx f (nhds x)\nhy : Filter.Tendsto my f (nhds y)\nâŠ¢ Filter.Tendsto (fun c => { fst := mx c, snd := my c }) f (nhds { fst := x, snd := y })","decl":"theorem Filter.Tendsto.prod_mk_nhds {Î³} {x : X} {y : Y} {f : Filter Î³} {mx : Î³ â†’ X} {my : Î³ â†’ Y}\n    (hx : Tendsto mx f (ğ“ x)) (hy : Tendsto my f (ğ“ y)) :\n    Tendsto (fun c => (mx c, my c)) f (ğ“ (x, y)) := by\n  rw [nhds_prod_eq]; exact Filter.Tendsto.prod_mk hx hy\n\n"}
{"name":"Filter.Eventually.curry_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\np : Prod X Y â†’ Prop\nx : X\ny : Y\nh : Filter.Eventually (fun x => p x) (nhds { fst := x, snd := y })\nâŠ¢ Filter.Eventually (fun x' => Filter.Eventually (fun y' => p { fst := x', snd := y' }) (nhds y)) (nhds x)","decl":"theorem Filter.Eventually.curry_nhds {p : X Ã— Y â†’ Prop} {x : X} {y : Y}\n    (h : âˆ€á¶  x in ğ“ (x, y), p x) : âˆ€á¶  x' in ğ“ x, âˆ€á¶  y' in ğ“ y, p (x', y') := by\n  rw [nhds_prod_eq] at h\n  exact h.curry\n\n"}
{"name":"ContinuousAt.prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Y\ng : X â†’ Z\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nâŠ¢ ContinuousAt (fun x => { fst := f x, snd := g x }) x","decl":"@[fun_prop]\ntheorem ContinuousAt.prod {f : X â†’ Y} {g : X â†’ Z} {x : X} (hf : ContinuousAt f x)\n    (hg : ContinuousAt g x) : ContinuousAt (fun x => (f x, g x)) x :=\n  hf.prod_mk_nhds hg\n\n"}
{"name":"ContinuousAt.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Z\ng : Y â†’ W\np : Prod X Y\nhf : ContinuousAt f p.1\nhg : ContinuousAt g p.2\nâŠ¢ ContinuousAt (Prod.map f g) p","decl":"theorem ContinuousAt.prodMap {f : X â†’ Z} {g : Y â†’ W} {p : X Ã— Y} (hf : ContinuousAt f p.fst)\n    (hg : ContinuousAt g p.snd) : ContinuousAt (Prod.map f g) p :=\n  hf.fst''.prod hg.snd''\n\n"}
{"name":"ContinuousAt.prod_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Z\ng : Y â†’ W\np : Prod X Y\nhf : ContinuousAt f p.1\nhg : ContinuousAt g p.2\nâŠ¢ ContinuousAt (Prod.map f g) p","decl":"@[deprecated (since := \"2024-10-05\")] alias ContinuousAt.prod_map := ContinuousAt.prodMap\n\n"}
{"name":"ContinuousAt.prodMap'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Z\ng : Y â†’ W\nx : X\ny : Y\nhf : ContinuousAt f x\nhg : ContinuousAt g y\nâŠ¢ ContinuousAt (Prod.map f g) { fst := x, snd := y }","decl":"/-- A version of `ContinuousAt.prodMap` that avoids `Prod.fst`/`Prod.snd`\nby assuming that the point is `(x, y)`. -/\ntheorem ContinuousAt.prodMap' {f : X â†’ Z} {g : Y â†’ W} {x : X} {y : Y} (hf : ContinuousAt f x)\n    (hg : ContinuousAt g y) : ContinuousAt (Prod.map f g) (x, y) :=\n  hf.prodMap hg\n\n"}
{"name":"ContinuousAt.prod_map'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Z\ng : Y â†’ W\nx : X\ny : Y\nhf : ContinuousAt f x\nhg : ContinuousAt g y\nâŠ¢ ContinuousAt (Prod.map f g) { fst := x, snd := y }","decl":"@[deprecated (since := \"2024-10-05\")] alias ContinuousAt.prod_map' := ContinuousAt.prodMap'\n\n"}
{"name":"ContinuousAt.compâ‚‚","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : Prod Y Z â†’ W\ng : X â†’ Y\nh : X â†’ Z\nx : X\nhf : ContinuousAt f { fst := g x, snd := h x }\nhg : ContinuousAt g x\nhh : ContinuousAt h x\nâŠ¢ ContinuousAt (fun x => f { fst := g x, snd := h x }) x","decl":"theorem ContinuousAt.compâ‚‚ {f : Y Ã— Z â†’ W} {g : X â†’ Y} {h : X â†’ Z} {x : X}\n    (hf : ContinuousAt f (g x, h x)) (hg : ContinuousAt g x) (hh : ContinuousAt h x) :\n    ContinuousAt (fun x â†¦ f (g x, h x)) x :=\n  ContinuousAt.comp hf (hg.prod hh)\n\n"}
{"name":"ContinuousAt.compâ‚‚_of_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : Prod Y Z â†’ W\ng : X â†’ Y\nh : X â†’ Z\nx : X\ny : Prod Y Z\nhf : ContinuousAt f y\nhg : ContinuousAt g x\nhh : ContinuousAt h x\ne : Eq { fst := g x, snd := h x } y\nâŠ¢ ContinuousAt (fun x => f { fst := g x, snd := h x }) x","decl":"theorem ContinuousAt.compâ‚‚_of_eq {f : Y Ã— Z â†’ W} {g : X â†’ Y} {h : X â†’ Z} {x : X} {y : Y Ã— Z}\n    (hf : ContinuousAt f y) (hg : ContinuousAt g x) (hh : ContinuousAt h x) (e : (g x, h x) = y) :\n    ContinuousAt (fun x â†¦ f (g x, h x)) x := by\n  rw [â† e] at hf\n  exact hf.compâ‚‚ hg hh\n\n"}
{"name":"Continuous.curry_left","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : Prod X Y â†’ Z\nhf : Continuous f\ny : Y\nâŠ¢ Continuous fun x => f { fst := x, snd := y }","decl":"/-- Continuous functions on products are continuous in their first argument -/\ntheorem Continuous.curry_left {f : X Ã— Y â†’ Z} (hf : Continuous f) {y : Y} :\n    Continuous fun x â†¦ f (x, y) :=\n  hf.comp (continuous_id.prod_mk continuous_const)\n"}
{"name":"Continuous.along_fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : Prod X Y â†’ Z\nhf : Continuous f\ny : Y\nâŠ¢ Continuous fun x => f { fst := x, snd := y }","decl":"alias Continuous.along_fst := Continuous.curry_left\n\n"}
{"name":"Continuous.curry_right","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : Prod X Y â†’ Z\nhf : Continuous f\nx : X\nâŠ¢ Continuous fun y => f { fst := x, snd := y }","decl":"/-- Continuous functions on products are continuous in their second argument -/\ntheorem Continuous.curry_right {f : X Ã— Y â†’ Z} (hf : Continuous f) {x : X} :\n    Continuous fun y â†¦ f (x, y) :=\n  hf.comp (continuous_const.prod_mk continuous_id)\n"}
{"name":"Continuous.along_snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : Prod X Y â†’ Z\nhf : Continuous f\nx : X\nâŠ¢ Continuous fun y => f { fst := x, snd := y }","decl":"alias Continuous.along_snd := Continuous.curry_right\n\n-- todo: prove a version of `generateFrom_union` with `image2 (âˆ©) s t` in the LHS and use it here\n"}
{"name":"prod_generateFrom_generateFrom_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u_5\nY : Type u_6\ns : Set (Set X)\nt : Set (Set Y)\nhs : Eq s.sUnion Set.univ\nht : Eq t.sUnion Set.univ\nâŠ¢ Eq instTopologicalSpaceProd (TopologicalSpace.generateFrom (Set.image2 (fun x1 x2 => SProd.sprod x1 x2) s t))","decl":"theorem prod_generateFrom_generateFrom_eq {X Y : Type*} {s : Set (Set X)} {t : Set (Set Y)}\n    (hs : â‹ƒâ‚€ s = univ) (ht : â‹ƒâ‚€ t = univ) :\n    @instTopologicalSpaceProd X Y (generateFrom s) (generateFrom t) =\n      generateFrom (image2 (Â·  Ã—Ë¢ Â·) s t) :=\n  let G := generateFrom (image2  (Â·  Ã—Ë¢ Â·) s t)\n  le_antisymm\n    (le_generateFrom fun _ âŸ¨_, hu, _, hv, g_eqâŸ© =>\n      g_eq.symm â–¸\n        @IsOpen.prod _ _ (generateFrom s) (generateFrom t) _ _ (GenerateOpen.basic _ hu)\n          (GenerateOpen.basic _ hv))\n    (le_inf\n      (coinduced_le_iff_le_induced.mp <|\n        le_generateFrom fun u hu =>\n          have : â‹ƒ v âˆˆ t, u Ã—Ë¢ v = Prod.fst â»Â¹' u := by\n            simp_rw [â† prod_iUnion, â† sUnion_eq_biUnion, ht, prod_univ]\n          show G.IsOpen (Prod.fst â»Â¹' u) by\n            rw [â† this]\n            exact\n              isOpen_iUnion fun v =>\n                isOpen_iUnion fun hv => GenerateOpen.basic _ âŸ¨_, hu, _, hv, rflâŸ©)\n      (coinduced_le_iff_le_induced.mp <|\n        le_generateFrom fun v hv =>\n          have : â‹ƒ u âˆˆ s, u Ã—Ë¢ v = Prod.snd â»Â¹' v := by\n            simp_rw [â† iUnion_prod_const, â† sUnion_eq_biUnion, hs, univ_prod]\n          show G.IsOpen (Prod.snd â»Â¹' v) by\n            rw [â† this]\n            exact\n              isOpen_iUnion fun u =>\n                isOpen_iUnion fun hu => GenerateOpen.basic _ âŸ¨_, hu, _, hv, rflâŸ©))\n\n-- todo: use the previous lemma?\n"}
{"name":"prod_eq_generateFrom","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Eq instTopologicalSpaceProd (TopologicalSpace.generateFrom (setOf fun g => Exists fun s => Exists fun t => And (IsOpen s) (And (IsOpen t) (Eq g (SProd.sprod s t)))))","decl":"theorem prod_eq_generateFrom :\n    instTopologicalSpaceProd =\n      generateFrom { g | âˆƒ (s : Set X) (t : Set Y), IsOpen s âˆ§ IsOpen t âˆ§ g = s Ã—Ë¢ t } :=\n  le_antisymm (le_generateFrom fun _ âŸ¨_, _, hs, ht, g_eqâŸ© => g_eq.symm â–¸ hs.prod ht)\n    (le_inf\n      (forall_mem_image.2 fun t ht =>\n        GenerateOpen.basic _ âŸ¨t, univ, by simpa [Set.prod_eq] using htâŸ©)\n      (forall_mem_image.2 fun t ht =>\n        GenerateOpen.basic _ âŸ¨univ, t, by simpa [Set.prod_eq] using htâŸ©))\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: align with `mem_nhds_prod_iff'`\n"}
{"name":"isOpen_prod_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set (Prod X Y)\nâŠ¢ Iff (IsOpen s) (âˆ€ (a : X) (b : Y), Membership.mem s { fst := a, snd := b } â†’ Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u a) (And (Membership.mem v b) (HasSubset.Subset (SProd.sprod u v) s)))))","decl":"theorem isOpen_prod_iff {s : Set (X Ã— Y)} :\n    IsOpen s â†” âˆ€ a b, (a, b) âˆˆ s â†’\n      âˆƒ u v, IsOpen u âˆ§ IsOpen v âˆ§ a âˆˆ u âˆ§ b âˆˆ v âˆ§ u Ã—Ë¢ v âŠ† s :=\n  isOpen_iff_mem_nhds.trans <| by simp_rw [Prod.forall, mem_nhds_prod_iff', and_left_comm]\n\n"}
{"name":"prod_induced_induced","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nW : Type u_2\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace W\nX : Type u_5\nZ : Type u_6\nf : X â†’ Y\ng : Z â†’ W\nâŠ¢ Eq instTopologicalSpaceProd (TopologicalSpace.induced (fun p => { fst := f p.1, snd := g p.2 }) instTopologicalSpaceProd)","decl":"/-- A product of induced topologies is induced by the product map -/\ntheorem prod_induced_induced {X Z} (f : X â†’ Y) (g : Z â†’ W) :\n    @instTopologicalSpaceProd X Z (induced f â€¹_â€º) (induced g â€¹_â€º) =\n      induced (fun p => (f p.1, g p.2)) instTopologicalSpaceProd := by\n  delta instTopologicalSpaceProd\n  simp_rw [induced_inf, induced_compose]\n  rfl\n\n"}
{"name":"exists_nhds_square","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set (Prod X X)\nx : X\nhx : Membership.mem (nhds { fst := x, snd := x }) s\nâŠ¢ Exists fun U => And (IsOpen U) (And (Membership.mem U x) (HasSubset.Subset (SProd.sprod U U) s))","decl":"/-- Given a neighborhood `s` of `(x, x)`, then `(x, x)` has a square open neighborhood\n  that is a subset of `s`. -/\ntheorem exists_nhds_square {s : Set (X Ã— X)} {x : X} (hx : s âˆˆ ğ“ (x, x)) :\n    âˆƒ U : Set X, IsOpen U âˆ§ x âˆˆ U âˆ§ U Ã—Ë¢ U âŠ† s := by\n  simpa [nhds_prod_eq, (nhds_basis_opens x).prod_self.mem_iff, and_assoc, and_left_comm] using hx\n\n"}
{"name":"map_fst_nhdsWithin","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : Prod X Y\nâŠ¢ Eq (Filter.map Prod.fst (nhdsWithin x (Set.preimage Prod.snd (Singleton.singleton x.2)))) (nhds x.1)","decl":"/-- `Prod.fst` maps neighborhood of `x : X Ã— Y` within the section `Prod.snd â»Â¹' {x.2}`\nto `ğ“ x.1`. -/\ntheorem map_fst_nhdsWithin (x : X Ã— Y) : map Prod.fst (ğ“[Prod.snd â»Â¹' {x.2}] x) = ğ“ x.1 := by\n  refine le_antisymm (continuousAt_fst.mono_left inf_le_left) fun s hs => ?_\n  rcases x with âŸ¨x, yâŸ©\n  rw [mem_map, nhdsWithin, mem_inf_principal, mem_nhds_prod_iff] at hs\n  rcases hs with âŸ¨u, hu, v, hv, HâŸ©\n  simp only [prod_subset_iff, mem_singleton_iff, mem_setOf_eq, mem_preimage] at H\n  exact mem_of_superset hu fun z hz => H _ hz _ (mem_of_mem_nhds hv) rfl\n\n"}
{"name":"map_fst_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : Prod X Y\nâŠ¢ Eq (Filter.map Prod.fst (nhds x)) (nhds x.1)","decl":"@[simp]\ntheorem map_fst_nhds (x : X Ã— Y) : map Prod.fst (ğ“ x) = ğ“ x.1 :=\n  le_antisymm continuousAt_fst <| (map_fst_nhdsWithin x).symm.trans_le (map_mono inf_le_left)\n\n"}
{"name":"isOpenMap_fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ IsOpenMap Prod.fst","decl":"/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem isOpenMap_fst : IsOpenMap (@Prod.fst X Y) :=\n  isOpenMap_iff_nhds_le.2 fun x => (map_fst_nhds x).ge\n\n"}
{"name":"map_snd_nhdsWithin","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : Prod X Y\nâŠ¢ Eq (Filter.map Prod.snd (nhdsWithin x (Set.preimage Prod.fst (Singleton.singleton x.1)))) (nhds x.2)","decl":"/-- `Prod.snd` maps neighborhood of `x : X Ã— Y` within the section `Prod.fst â»Â¹' {x.1}`\nto `ğ“ x.2`. -/\ntheorem map_snd_nhdsWithin (x : X Ã— Y) : map Prod.snd (ğ“[Prod.fst â»Â¹' {x.1}] x) = ğ“ x.2 := by\n  refine le_antisymm (continuousAt_snd.mono_left inf_le_left) fun s hs => ?_\n  rcases x with âŸ¨x, yâŸ©\n  rw [mem_map, nhdsWithin, mem_inf_principal, mem_nhds_prod_iff] at hs\n  rcases hs with âŸ¨u, hu, v, hv, HâŸ©\n  simp only [prod_subset_iff, mem_singleton_iff, mem_setOf_eq, mem_preimage] at H\n  exact mem_of_superset hv fun z hz => H _ (mem_of_mem_nhds hu) _ hz rfl\n\n"}
{"name":"map_snd_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : Prod X Y\nâŠ¢ Eq (Filter.map Prod.snd (nhds x)) (nhds x.2)","decl":"@[simp]\ntheorem map_snd_nhds (x : X Ã— Y) : map Prod.snd (ğ“ x) = ğ“ x.2 :=\n  le_antisymm continuousAt_snd <| (map_snd_nhdsWithin x).symm.trans_le (map_mono inf_le_left)\n\n"}
{"name":"isOpenMap_snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ IsOpenMap Prod.snd","decl":"/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem isOpenMap_snd : IsOpenMap (@Prod.snd X Y) :=\n  isOpenMap_iff_nhds_le.2 fun x => (map_snd_nhds x).ge\n\n"}
{"name":"isOpen_prod_iff'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nt : Set Y\nâŠ¢ Iff (IsOpen (SProd.sprod s t)) (Or (And (IsOpen s) (IsOpen t)) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection)))","decl":"/-- A product set is open in a product space if and only if each factor is open, or one of them is\nempty -/\ntheorem isOpen_prod_iff' {s : Set X} {t : Set Y} :\n    IsOpen (s Ã—Ë¢ t) â†” IsOpen s âˆ§ IsOpen t âˆ¨ s = âˆ… âˆ¨ t = âˆ… := by\n  rcases (s Ã—Ë¢ t).eq_empty_or_nonempty with h | h\n  Â· simp [h, prod_eq_empty_iff.1 h]\n  Â· have st : s.Nonempty âˆ§ t.Nonempty := prod_nonempty_iff.1 h\n    constructor\n    Â· intro (H : IsOpen (s Ã—Ë¢ t))\n      refine Or.inl âŸ¨?_, ?_âŸ©\n      Â· simpa only [fst_image_prod _ st.2] using isOpenMap_fst _ H\n      Â· simpa only [snd_image_prod st.1 t] using isOpenMap_snd _ H\n    Â· intro H\n      simp only [st.1.ne_empty, st.2.ne_empty, not_false_iff, or_false] at H\n      exact H.1.prod H.2\n\n"}
{"name":"isQuotientMap_fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : Nonempty Y\nâŠ¢ Topology.IsQuotientMap Prod.fst","decl":"theorem isQuotientMap_fst [Nonempty Y] : IsQuotientMap (Prod.fst : X Ã— Y â†’ X) :=\n  isOpenMap_fst.isQuotientMap continuous_fst Prod.fst_surjective\n\n"}
{"name":"quotientMap_fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : Nonempty Y\nâŠ¢ Topology.IsQuotientMap Prod.fst","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_fst := isQuotientMap_fst\n\n"}
{"name":"isQuotientMap_snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : Nonempty X\nâŠ¢ Topology.IsQuotientMap Prod.snd","decl":"theorem isQuotientMap_snd [Nonempty X] : IsQuotientMap (Prod.snd : X Ã— Y â†’ Y) :=\n  isOpenMap_snd.isQuotientMap continuous_snd Prod.snd_surjective\n\n"}
{"name":"quotientMap_snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : Nonempty X\nâŠ¢ Topology.IsQuotientMap Prod.snd","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_snd := isQuotientMap_snd\n\n"}
{"name":"closure_prod_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nt : Set Y\nâŠ¢ Eq (closure (SProd.sprod s t)) (SProd.sprod (closure s) (closure t))","decl":"theorem closure_prod_eq {s : Set X} {t : Set Y} : closure (s Ã—Ë¢ t) = closure s Ã—Ë¢ closure t :=\n  ext fun âŸ¨a, bâŸ© => by\n    simp_rw [mem_prod, mem_closure_iff_nhdsWithin_neBot, nhdsWithin_prod_eq, prod_neBot]\n\n"}
{"name":"interior_prod_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nt : Set Y\nâŠ¢ Eq (interior (SProd.sprod s t)) (SProd.sprod (interior s) (interior t))","decl":"theorem interior_prod_eq (s : Set X) (t : Set Y) : interior (s Ã—Ë¢ t) = interior s Ã—Ë¢ interior t :=\n  ext fun âŸ¨a, bâŸ© => by simp only [mem_interior_iff_mem_nhds, mem_prod, prod_mem_nhds_iff]\n\n"}
{"name":"frontier_prod_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nt : Set Y\nâŠ¢ Eq (frontier (SProd.sprod s t)) (Union.union (SProd.sprod (closure s) (frontier t)) (SProd.sprod (frontier s) (closure t)))","decl":"theorem frontier_prod_eq (s : Set X) (t : Set Y) :\n    frontier (s Ã—Ë¢ t) = closure s Ã—Ë¢ frontier t âˆª frontier s Ã—Ë¢ closure t := by\n  simp only [frontier, closure_prod_eq, interior_prod_eq, prod_diff_prod]\n\n"}
{"name":"frontier_prod_univ_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nâŠ¢ Eq (frontier (SProd.sprod s Set.univ)) (SProd.sprod (frontier s) Set.univ)","decl":"@[simp]\ntheorem frontier_prod_univ_eq (s : Set X) :\n    frontier (s Ã—Ë¢ (univ : Set Y)) = frontier s Ã—Ë¢ univ := by\n  simp [frontier_prod_eq]\n\n"}
{"name":"frontier_univ_prod_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set Y\nâŠ¢ Eq (frontier (SProd.sprod Set.univ s)) (SProd.sprod Set.univ (frontier s))","decl":"@[simp]\ntheorem frontier_univ_prod_eq (s : Set Y) :\n    frontier ((univ : Set X) Ã—Ë¢ s) = univ Ã—Ë¢ frontier s := by\n  simp [frontier_prod_eq]\n\n"}
{"name":"map_mem_closureâ‚‚","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Y â†’ Z\nx : X\ny : Y\ns : Set X\nt : Set Y\nu : Set Z\nhf : Continuous (Function.uncurry f)\nhx : Membership.mem (closure s) x\nhy : Membership.mem (closure t) y\nh : âˆ€ (a : X), Membership.mem s a â†’ âˆ€ (b : Y), Membership.mem t b â†’ Membership.mem u (f a b)\nâŠ¢ Membership.mem (closure u) (f x y)","decl":"theorem map_mem_closureâ‚‚ {f : X â†’ Y â†’ Z} {x : X} {y : Y} {s : Set X} {t : Set Y} {u : Set Z}\n    (hf : Continuous (uncurry f)) (hx : x âˆˆ closure s) (hy : y âˆˆ closure t)\n    (h : âˆ€ a âˆˆ s, âˆ€ b âˆˆ t, f a b âˆˆ u) : f x y âˆˆ closure u :=\n  have Hâ‚ : (x, y) âˆˆ closure (s Ã—Ë¢ t) := by simpa only [closure_prod_eq] using mk_mem_prod hx hy\n  have Hâ‚‚ : MapsTo (uncurry f) (s Ã—Ë¢ t) u := forall_prod_set.2 h\n  Hâ‚‚.closure hf Hâ‚\n\n"}
{"name":"IsClosed.prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nsâ‚ : Set X\nsâ‚‚ : Set Y\nhâ‚ : IsClosed sâ‚\nhâ‚‚ : IsClosed sâ‚‚\nâŠ¢ IsClosed (SProd.sprod sâ‚ sâ‚‚)","decl":"theorem IsClosed.prod {sâ‚ : Set X} {sâ‚‚ : Set Y} (hâ‚ : IsClosed sâ‚) (hâ‚‚ : IsClosed sâ‚‚) :\n    IsClosed (sâ‚ Ã—Ë¢ sâ‚‚) :=\n  closure_eq_iff_isClosed.mp <| by simp only [hâ‚.closure_eq, hâ‚‚.closure_eq, closure_prod_eq]\n\n"}
{"name":"Dense.prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nt : Set Y\nhs : Dense s\nht : Dense t\nâŠ¢ Dense (SProd.sprod s t)","decl":"/-- The product of two dense sets is a dense set. -/\ntheorem Dense.prod {s : Set X} {t : Set Y} (hs : Dense s) (ht : Dense t) : Dense (s Ã—Ë¢ t) :=\n  fun x => by\n  rw [closure_prod_eq]\n  exact âŸ¨hs x.1, ht x.2âŸ©\n\n"}
{"name":"DenseRange.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nZ : Type u_1\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nÎ¹ : Type u_5\nÎº : Type u_6\nf : Î¹ â†’ Y\ng : Îº â†’ Z\nhf : DenseRange f\nhg : DenseRange g\nâŠ¢ DenseRange (Prod.map f g)","decl":"/-- If `f` and `g` are maps with dense range, then `Prod.map f g` has dense range. -/\ntheorem DenseRange.prodMap {Î¹ : Type*} {Îº : Type*} {f : Î¹ â†’ Y} {g : Îº â†’ Z} (hf : DenseRange f)\n    (hg : DenseRange g) : DenseRange (Prod.map f g) := by\n  simpa only [DenseRange, prod_range_range_eq] using hf.prod hg\n\n"}
{"name":"DenseRange.prod_map","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nZ : Type u_1\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nÎ¹ : Type u_5\nÎº : Type u_6\nf : Î¹ â†’ Y\ng : Îº â†’ Z\nhf : DenseRange f\nhg : DenseRange g\nâŠ¢ DenseRange (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-05\")] alias DenseRange.prod_map := DenseRange.prodMap\n\n"}
{"name":"Topology.IsInducing.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : Topology.IsInducing f\nhg : Topology.IsInducing g\nâŠ¢ Topology.IsInducing (Prod.map f g)","decl":"lemma Topology.IsInducing.prodMap {f : X â†’ Y} {g : Z â†’ W} (hf : IsInducing f) (hg : IsInducing g) :\n    IsInducing (Prod.map f g) :=\n  isInducing_iff_nhds.2 fun (x, z) => by simp_rw [Prod.map_def, nhds_prod_eq, hf.nhds_eq_comap,\n    hg.nhds_eq_comap, prod_comap_comap_eq]\n\n"}
{"name":"Inducing.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : Topology.IsInducing f\nhg : Topology.IsInducing g\nâŠ¢ Topology.IsInducing (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.prodMap := IsInducing.prodMap\n\n"}
{"name":"Inducing.prod_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : Topology.IsInducing f\nhg : Topology.IsInducing g\nâŠ¢ Topology.IsInducing (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-05\")] alias Inducing.prod_map := IsInducing.prodMap\n\n"}
{"name":"Topology.isInducing_const_prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nx : X\nf : Y â†’ Z\nâŠ¢ Iff (Topology.IsInducing fun x' => { fst := x, snd := f x' }) (Topology.IsInducing f)","decl":"@[simp]\nlemma Topology.isInducing_const_prod {x : X} {f : Y â†’ Z} :\n    IsInducing (fun x' => (x, f x')) â†” IsInducing f := by\n  simp_rw [isInducing_iff, instTopologicalSpaceProd, induced_inf, induced_compose,\n    Function.comp_def, induced_const, top_inf_eq]\n\n"}
{"name":"inducing_const_prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nx : X\nf : Y â†’ Z\nâŠ¢ Iff (Topology.IsInducing fun x' => { fst := x, snd := f x' }) (Topology.IsInducing f)","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_const_prod := isInducing_const_prod\n\n"}
{"name":"Topology.isInducing_prod_const","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\ny : Y\nf : X â†’ Z\nâŠ¢ Iff (Topology.IsInducing fun x => { fst := f x, snd := y }) (Topology.IsInducing f)","decl":"@[simp]\nlemma Topology.isInducing_prod_const {y : Y} {f : X â†’ Z} :\n    IsInducing (fun x => (f x, y)) â†” IsInducing f := by\n  simp_rw [isInducing_iff, instTopologicalSpaceProd, induced_inf, induced_compose,\n    Function.comp_def, induced_const, inf_top_eq]\n\n"}
{"name":"inducing_prod_const","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\ny : Y\nf : X â†’ Z\nâŠ¢ Iff (Topology.IsInducing fun x => { fst := f x, snd := y }) (Topology.IsInducing f)","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_prod_const := isInducing_prod_const\n\n"}
{"name":"Topology.IsEmbedding.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : Topology.IsEmbedding f\nhg : Topology.IsEmbedding g\nâŠ¢ Topology.IsEmbedding (Prod.map f g)","decl":"lemma Topology.IsEmbedding.prodMap {f : X â†’ Y} {g : Z â†’ W} (hf : IsEmbedding f)\n    (hg : IsEmbedding g) : IsEmbedding (Prod.map f g) where\n  toIsInducing := hf.isInducing.prodMap hg.isInducing\n  injective := hf.injective.prodMap hg.injective\n\n"}
{"name":"Embedding.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : Topology.IsEmbedding f\nhg : Topology.IsEmbedding g\nâŠ¢ Topology.IsEmbedding (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-08\")] alias Embedding.prodMap := Topology.IsEmbedding.prodMap\n"}
{"name":"Embedding.prod_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : Topology.IsEmbedding f\nhg : Topology.IsEmbedding g\nâŠ¢ Topology.IsEmbedding (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-05\")] alias Embedding.prod_map := Topology.IsEmbedding.prodMap\n\n"}
{"name":"IsOpenMap.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : IsOpenMap f\nhg : IsOpenMap g\nâŠ¢ IsOpenMap (Prod.map f g)","decl":"protected theorem IsOpenMap.prodMap {f : X â†’ Y} {g : Z â†’ W} (hf : IsOpenMap f) (hg : IsOpenMap g) :\n    IsOpenMap (Prod.map f g) := by\n  rw [isOpenMap_iff_nhds_le]\n  rintro âŸ¨a, bâŸ©\n  rw [nhds_prod_eq, nhds_prod_eq, â† Filter.prod_map_map_eq']\n  exact Filter.prod_mono (hf.nhds_le a) (hg.nhds_le b)\n\n"}
{"name":"IsOpenMap.prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : IsOpenMap f\nhg : IsOpenMap g\nâŠ¢ IsOpenMap (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-05\")] alias IsOpenMap.prod := IsOpenMap.prodMap\n\n"}
{"name":"Topology.IsOpenEmbedding.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : Topology.IsOpenEmbedding f\nhg : Topology.IsOpenEmbedding g\nâŠ¢ Topology.IsOpenEmbedding (Prod.map f g)","decl":"protected lemma Topology.IsOpenEmbedding.prodMap {f : X â†’ Y} {g : Z â†’ W} (hf : IsOpenEmbedding f)\n    (hg : IsOpenEmbedding g) : IsOpenEmbedding (Prod.map f g) :=\n  .of_isEmbedding_isOpenMap (hf.1.prodMap hg.1) (hf.isOpenMap.prodMap hg.isOpenMap)\n\n"}
{"name":"OpenEmbedding.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : Topology.IsOpenEmbedding f\nhg : Topology.IsOpenEmbedding g\nâŠ¢ Topology.IsOpenEmbedding (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.prodMap := IsOpenEmbedding.prodMap\n\n"}
{"name":"IsOpenEmbedding.prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : Topology.IsOpenEmbedding f\nhg : Topology.IsOpenEmbedding g\nâŠ¢ Topology.IsOpenEmbedding (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-05\")] alias IsOpenEmbedding.prod := IsOpenEmbedding.prodMap\n\n"}
{"name":"isEmbedding_graph","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : Continuous f\nâŠ¢ Topology.IsEmbedding fun x => { fst := x, snd := f x }","decl":"lemma isEmbedding_graph {f : X â†’ Y} (hf : Continuous f) : IsEmbedding fun x => (x, f x) :=\n  .of_comp (continuous_id.prod_mk hf) continuous_fst .id\n\n"}
{"name":"embedding_graph","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : Continuous f\nâŠ¢ Topology.IsEmbedding fun x => { fst := x, snd := f x }","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_graph := isEmbedding_graph\n\n"}
{"name":"isEmbedding_prodMk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : X\nâŠ¢ Topology.IsEmbedding (Prod.mk x)","decl":"lemma isEmbedding_prodMk (x : X) : IsEmbedding (Prod.mk x : Y â†’ X Ã— Y) :=\n  .of_comp (Continuous.Prod.mk x) continuous_snd .id\n\n"}
{"name":"embedding_prod_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : X\nâŠ¢ Topology.IsEmbedding (Prod.mk x)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_prod_mk := isEmbedding_prodMk\n\n"}
{"name":"IsOpenQuotientMap.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : IsOpenQuotientMap f\nhg : IsOpenQuotientMap g\nâŠ¢ IsOpenQuotientMap (Prod.map f g)","decl":"theorem IsOpenQuotientMap.prodMap {f : X â†’ Y} {g : Z â†’ W} (hf : IsOpenQuotientMap f)\n    (hg : IsOpenQuotientMap g) : IsOpenQuotientMap (Prod.map f g) :=\n  âŸ¨.prodMap hf.1 hg.1, .prodMap hf.2 hg.2, .prodMap hf.3 hg.3âŸ©\n\n"}
{"name":"continuous_bool_rng","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nf : X â†’ Bool\nb : Bool\nâŠ¢ Iff (Continuous f) (IsClopen (Set.preimage f (Singleton.singleton b)))","decl":"lemma continuous_bool_rng [TopologicalSpace X] {f : X â†’ Bool} (b : Bool) :\n    Continuous f â†” IsClopen (f â»Â¹' {b}) := by\n  rw [continuous_discrete_rng, Bool.forall_bool' b, IsClopen, â† isOpen_compl_iff, â† preimage_compl,\n    Bool.compl_singleton, and_comm]\n\n"}
{"name":"continuous_sum_dom","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : Sum X Y â†’ Z\nâŠ¢ Iff (Continuous f) (And (Continuous (Function.comp f Sum.inl)) (Continuous (Function.comp f Sum.inr)))","decl":"theorem continuous_sum_dom {f : X âŠ• Y â†’ Z} :\n    Continuous f â†” Continuous (f âˆ˜ Sum.inl) âˆ§ Continuous (f âˆ˜ Sum.inr) :=\n  (continuous_sup_dom (tâ‚ := TopologicalSpace.coinduced Sum.inl _)\n    (tâ‚‚ := TopologicalSpace.coinduced Sum.inr _)).trans <|\n    continuous_coinduced_dom.and continuous_coinduced_dom\n\n"}
{"name":"continuous_sum_elim","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Z\ng : Y â†’ Z\nâŠ¢ Iff (Continuous (Sum.elim f g)) (And (Continuous f) (Continuous g))","decl":"theorem continuous_sum_elim {f : X â†’ Z} {g : Y â†’ Z} :\n    Continuous (Sum.elim f g) â†” Continuous f âˆ§ Continuous g :=\n  continuous_sum_dom\n\n"}
{"name":"Continuous.sum_elim","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Z\ng : Y â†’ Z\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous (Sum.elim f g)","decl":"@[continuity, fun_prop]\ntheorem Continuous.sum_elim {f : X â†’ Z} {g : Y â†’ Z} (hf : Continuous f) (hg : Continuous g) :\n    Continuous (Sum.elim f g) :=\n  continuous_sum_elim.2 âŸ¨hf, hgâŸ©\n\n"}
{"name":"continuous_isLeft","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Continuous Sum.isLeft","decl":"@[continuity, fun_prop]\ntheorem continuous_isLeft : Continuous (isLeft : X âŠ• Y â†’ Bool) :=\n  continuous_sum_dom.2 âŸ¨continuous_const, continuous_constâŸ©\n\n"}
{"name":"continuous_isRight","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Continuous Sum.isRight","decl":"@[continuity, fun_prop]\ntheorem continuous_isRight : Continuous (isRight : X âŠ• Y â†’ Bool) :=\n  continuous_sum_dom.2 âŸ¨continuous_const, continuous_constâŸ©\n\n"}
{"name":"continuous_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Continuous Sum.inl","decl":"@[continuity, fun_prop]\ntheorem continuous_inl : Continuous (@inl X Y) := âŸ¨fun _ => And.leftâŸ©\n\n"}
{"name":"continuous_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Continuous Sum.inr","decl":"@[continuity, fun_prop]\ntheorem continuous_inr : Continuous (@inr X Y) := âŸ¨fun _ => And.rightâŸ©\n\n"}
{"name":"continuous_sum_swap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Continuous Sum.swap","decl":"@[fun_prop, continuity]\nlemma continuous_sum_swap : Continuous (@Sum.swap X Y) :=\n  Continuous.sum_elim continuous_inr continuous_inl\n\n"}
{"name":"isOpen_sum_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set (Sum X Y)\nâŠ¢ Iff (IsOpen s) (And (IsOpen (Set.preimage Sum.inl s)) (IsOpen (Set.preimage Sum.inr s)))","decl":"theorem isOpen_sum_iff {s : Set (X âŠ• Y)} : IsOpen s â†” IsOpen (inl â»Â¹' s) âˆ§ IsOpen (inr â»Â¹' s) :=\n  Iff.rfl\n\n"}
{"name":"isClosed_sum_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set (Sum X Y)\nâŠ¢ Iff (IsClosed s) (And (IsClosed (Set.preimage Sum.inl s)) (IsClosed (Set.preimage Sum.inr s)))","decl":"theorem isClosed_sum_iff {s : Set (X âŠ• Y)} :\n    IsClosed s â†” IsClosed (inl â»Â¹' s) âˆ§ IsClosed (inr â»Â¹' s) := by\n  simp only [â† isOpen_compl_iff, isOpen_sum_iff, preimage_compl]\n\n"}
{"name":"isOpenMap_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ IsOpenMap Sum.inl","decl":"theorem isOpenMap_inl : IsOpenMap (@inl X Y) := fun u hu => by\n  simpa [isOpen_sum_iff, preimage_image_eq u Sum.inl_injective]\n\n"}
{"name":"isOpenMap_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ IsOpenMap Sum.inr","decl":"theorem isOpenMap_inr : IsOpenMap (@inr X Y) := fun u hu => by\n  simpa [isOpen_sum_iff, preimage_image_eq u Sum.inr_injective]\n\n"}
{"name":"Topology.IsOpenEmbedding.inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsOpenEmbedding Sum.inl","decl":"protected lemma Topology.IsOpenEmbedding.inl : IsOpenEmbedding (@inl X Y) :=\n  .of_continuous_injective_isOpenMap continuous_inl inl_injective isOpenMap_inl\n\n"}
{"name":"isOpenEmbedding_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsOpenEmbedding Sum.inl","decl":"@[deprecated (since := \"2024-10-30\")] alias isOpenEmbedding_inl := IsOpenEmbedding.inl\n\n"}
{"name":"openEmbedding_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsOpenEmbedding Sum.inl","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_inl := IsOpenEmbedding.inl\n\n"}
{"name":"Topology.IsOpenEmbedding.inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsOpenEmbedding Sum.inr","decl":"protected lemma Topology.IsOpenEmbedding.inr : IsOpenEmbedding (@inr X Y) :=\n  .of_continuous_injective_isOpenMap continuous_inr inr_injective isOpenMap_inr\n\n"}
{"name":"isOpenEmbedding_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsOpenEmbedding Sum.inr","decl":"@[deprecated (since := \"2024-10-30\")] alias isOpenEmbedding_inr := IsOpenEmbedding.inr\n\n"}
{"name":"openEmbedding_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsOpenEmbedding Sum.inr","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_inr := IsOpenEmbedding.inr\n\n"}
{"name":"Topology.IsEmbedding.inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsEmbedding Sum.inl","decl":"protected lemma Topology.IsEmbedding.inl : IsEmbedding (@inl X Y) := IsOpenEmbedding.inl.1\n"}
{"name":"Topology.IsEmbedding.inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsEmbedding Sum.inr","decl":"protected lemma Topology.IsEmbedding.inr : IsEmbedding (@inr X Y) := IsOpenEmbedding.inr.1\n\n"}
{"name":"embedding_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsEmbedding Sum.inr","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_inr := IsEmbedding.inr\n\n"}
{"name":"isOpen_range_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ IsOpen (Set.range Sum.inl)","decl":"lemma isOpen_range_inl : IsOpen (range (inl : X â†’ X âŠ• Y)) := IsOpenEmbedding.inl.2\n"}
{"name":"isOpen_range_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ IsOpen (Set.range Sum.inr)","decl":"lemma isOpen_range_inr : IsOpen (range (inr : Y â†’ X âŠ• Y)) := IsOpenEmbedding.inr.2\n\n"}
{"name":"isClosed_range_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ IsClosed (Set.range Sum.inl)","decl":"theorem isClosed_range_inl : IsClosed (range (inl : X â†’ X âŠ• Y)) := by\n  rw [â† isOpen_compl_iff, compl_range_inl]\n  exact isOpen_range_inr\n\n"}
{"name":"isClosed_range_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ IsClosed (Set.range Sum.inr)","decl":"theorem isClosed_range_inr : IsClosed (range (inr : Y â†’ X âŠ• Y)) := by\n  rw [â† isOpen_compl_iff, compl_range_inr]\n  exact isOpen_range_inl\n\n"}
{"name":"Topology.IsClosedEmbedding.inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsClosedEmbedding Sum.inl","decl":"theorem Topology.IsClosedEmbedding.inl : IsClosedEmbedding (inl : X â†’ X âŠ• Y) :=\n  âŸ¨.inl, isClosed_range_inlâŸ©\n\n"}
{"name":"isClosedEmbedding_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsClosedEmbedding Sum.inl","decl":"@[deprecated (since := \"2024-10-30\")] alias isClosedEmbedding_inl := IsClosedEmbedding.inl\n\n"}
{"name":"closedEmbedding_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsClosedEmbedding Sum.inl","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_inl := IsClosedEmbedding.inl\n\n"}
{"name":"Topology.IsClosedEmbedding.inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsClosedEmbedding Sum.inr","decl":"theorem Topology.IsClosedEmbedding.inr : IsClosedEmbedding (inr : Y â†’ X âŠ• Y) :=\n  âŸ¨.inr, isClosed_range_inrâŸ©\n\n"}
{"name":"isClosedEmbedding_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsClosedEmbedding Sum.inr","decl":"@[deprecated (since := \"2024-10-30\")] alias isClosedEmbedding_inr := IsClosedEmbedding.inr\n\n"}
{"name":"closedEmbedding_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nâŠ¢ Topology.IsClosedEmbedding Sum.inr","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_inr := IsClosedEmbedding.inr\n\n"}
{"name":"nhds_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nx : X\nâŠ¢ Eq (nhds (Sum.inl x)) (Filter.map Sum.inl (nhds x))","decl":"theorem nhds_inl (x : X) : ğ“ (inl x : X âŠ• Y) = map inl (ğ“ x) :=\n  (IsOpenEmbedding.inl.map_nhds_eq _).symm\n\n"}
{"name":"nhds_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ny : Y\nâŠ¢ Eq (nhds (Sum.inr y)) (Filter.map Sum.inr (nhds y))","decl":"theorem nhds_inr (y : Y) : ğ“ (inr y : X âŠ• Y) = map inr (ğ“ y) :=\n  (IsOpenEmbedding.inr.map_nhds_eq _).symm\n\n"}
{"name":"continuous_sum_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nâŠ¢ Iff (Continuous (Sum.map f g)) (And (Continuous f) (Continuous g))","decl":"@[simp]\ntheorem continuous_sum_map {f : X â†’ Y} {g : Z â†’ W} :\n    Continuous (Sum.map f g) â†” Continuous f âˆ§ Continuous g :=\n  continuous_sum_elim.trans <|\n    IsEmbedding.inl.continuous_iff.symm.and IsEmbedding.inr.continuous_iff.symm\n\n"}
{"name":"Continuous.sum_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous (Sum.map f g)","decl":"@[continuity, fun_prop]\ntheorem Continuous.sum_map {f : X â†’ Y} {g : Z â†’ W} (hf : Continuous f) (hg : Continuous g) :\n    Continuous (Sum.map f g) :=\n  continuous_sum_map.2 âŸ¨hf, hgâŸ©\n\n"}
{"name":"isOpenMap_sum","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : Sum X Y â†’ Z\nâŠ¢ Iff (IsOpenMap f) (And (IsOpenMap fun a => f (Sum.inl a)) (IsOpenMap fun b => f (Sum.inr b)))","decl":"theorem isOpenMap_sum {f : X âŠ• Y â†’ Z} :\n    IsOpenMap f â†” (IsOpenMap fun a => f (inl a)) âˆ§ IsOpenMap fun b => f (inr b) := by\n  simp only [isOpenMap_iff_nhds_le, Sum.forall, nhds_inl, nhds_inr, Filter.map_map, comp_def]\n\n"}
{"name":"IsOpenMap.sumMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : IsOpenMap f\nhg : IsOpenMap g\nâŠ¢ IsOpenMap (Sum.map f g)","decl":"theorem IsOpenMap.sumMap {f : X â†’ Y} {g : Z â†’ W} (hf : IsOpenMap f) (hg : IsOpenMap g) :\n    IsOpenMap (Sum.map f g) := by\n  exact isOpenMap_sum.2 âŸ¨isOpenMap_inl.comp hf,isOpenMap_inr.comp hgâŸ©\n\n"}
{"name":"isOpenMap_sum_elim","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Z\ng : Y â†’ Z\nâŠ¢ Iff (IsOpenMap (Sum.elim f g)) (And (IsOpenMap f) (IsOpenMap g))","decl":"@[simp]\ntheorem isOpenMap_sum_elim {f : X â†’ Z} {g : Y â†’ Z} :\n    IsOpenMap (Sum.elim f g) â†” IsOpenMap f âˆ§ IsOpenMap g := by\n  simp only [isOpenMap_sum, elim_inl, elim_inr]\n\n"}
{"name":"IsOpenMap.sum_elim","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Z\ng : Y â†’ Z\nhf : IsOpenMap f\nhg : IsOpenMap g\nâŠ¢ IsOpenMap (Sum.elim f g)","decl":"theorem IsOpenMap.sum_elim {f : X â†’ Z} {g : Y â†’ Z} (hf : IsOpenMap f) (hg : IsOpenMap g) :\n    IsOpenMap (Sum.elim f g) :=\n  isOpenMap_sum_elim.2 âŸ¨hf, hgâŸ©\n\n"}
{"name":"isClosedMap_sum","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : Sum X Y â†’ Z\nâŠ¢ Iff (IsClosedMap f) (And (IsClosedMap fun a => f (Sum.inl a)) (IsClosedMap fun b => f (Sum.inr b)))","decl":"theorem isClosedMap_sum {f : X âŠ• Y â†’ Z} :\n    IsClosedMap f â†” (IsClosedMap fun a => f (.inl a)) âˆ§ IsClosedMap fun b => f (.inr b) := by\n  constructor\n  Â· intro h\n    exact âŸ¨h.comp IsClosedEmbedding.inl.isClosedMap, h.comp IsClosedEmbedding.inr.isClosedMapâŸ©\n  Â· rintro h Z hZ\n    rw [isClosed_sum_iff] at hZ\n    convert (h.1 _ hZ.1).union (h.2 _ hZ.2)\n    ext\n    simp only [mem_image, Sum.exists, mem_union, mem_preimage]\n\n"}
{"name":"Topology.IsInducing.subtypeVal","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\ninstâœ : TopologicalSpace Y\nt : Set Y\nâŠ¢ Topology.IsInducing Subtype.val","decl":"lemma Topology.IsInducing.subtypeVal {t : Set Y} : IsInducing ((â†‘) : t â†’ Y) := âŸ¨rflâŸ©\n\n"}
{"name":"inducing_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\ninstâœ : TopologicalSpace Y\nt : Set Y\nâŠ¢ Topology.IsInducing Subtype.val","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_subtype_val := IsInducing.subtypeVal\n\n"}
{"name":"Topology.IsInducing.of_codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nt : Set Y\nht : âˆ€ (x : X), Membership.mem t (f x)\nh : Topology.IsInducing (Set.codRestrict f t ht)\nâŠ¢ Topology.IsInducing f","decl":"lemma Topology.IsInducing.of_codRestrict {f : X â†’ Y} {t : Set Y} (ht : âˆ€ x, f x âˆˆ t)\n    (h : IsInducing (t.codRestrict f ht)) : IsInducing f := subtypeVal.comp h\n\n"}
{"name":"Inducing.of_codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nt : Set Y\nht : âˆ€ (x : X), Membership.mem t (f x)\nh : Topology.IsInducing (Set.codRestrict f t ht)\nâŠ¢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.of_codRestrict := IsInducing.of_codRestrict\n\n"}
{"name":"Topology.IsEmbedding.subtypeVal","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\np : X â†’ Prop\nâŠ¢ Topology.IsEmbedding Subtype.val","decl":"lemma Topology.IsEmbedding.subtypeVal : IsEmbedding ((â†‘) : Subtype p â†’ X) :=\n  âŸ¨.subtypeVal, Subtype.coe_injectiveâŸ©\n\n"}
{"name":"embedding_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\np : X â†’ Prop\nâŠ¢ Topology.IsEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_subtype_val := IsEmbedding.subtypeVal\n\n"}
{"name":"Topology.IsClosedEmbedding.subtypeVal","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\np : X â†’ Prop\nh : IsClosed (setOf fun a => p a)\nâŠ¢ Topology.IsClosedEmbedding Subtype.val","decl":"theorem Topology.IsClosedEmbedding.subtypeVal (h : IsClosed {a | p a}) :\n    IsClosedEmbedding ((â†‘) : Subtype p â†’ X) :=\n  âŸ¨.subtypeVal, by rwa [Subtype.range_coe_subtype]âŸ©\n\n"}
{"name":"closedEmbedding_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\np : X â†’ Prop\nh : IsClosed (setOf fun a => p a)\nâŠ¢ Topology.IsClosedEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_subtype_val := IsClosedEmbedding.subtypeVal\n\n"}
{"name":"continuous_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\np : X â†’ Prop\nâŠ¢ Continuous Subtype.val","decl":"@[continuity, fun_prop]\ntheorem continuous_subtype_val : Continuous (@Subtype.val X p) :=\n  continuous_induced_dom\n\n"}
{"name":"Continuous.subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\np : X â†’ Prop\nf : Y â†’ Subtype p\nhf : Continuous f\nâŠ¢ Continuous fun x => â†‘(f x)","decl":"theorem Continuous.subtype_val {f : Y â†’ Subtype p} (hf : Continuous f) :\n    Continuous fun x => (f x : X) :=\n  continuous_subtype_val.comp hf\n\n"}
{"name":"IsOpen.isOpenEmbedding_subtypeVal","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsOpen s\nâŠ¢ Topology.IsOpenEmbedding Subtype.val","decl":"theorem IsOpen.isOpenEmbedding_subtypeVal {s : Set X} (hs : IsOpen s) :\n    IsOpenEmbedding ((â†‘) : s â†’ X) :=\n  âŸ¨.subtypeVal, (@Subtype.range_coe _ s).symm â–¸ hsâŸ©\n\n"}
{"name":"IsOpen.openEmbedding_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsOpen s\nâŠ¢ Topology.IsOpenEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-18\")]\nalias IsOpen.openEmbedding_subtype_val := IsOpen.isOpenEmbedding_subtypeVal\n\n"}
{"name":"IsOpen.isOpenMap_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsOpen s\nâŠ¢ IsOpenMap Subtype.val","decl":"theorem IsOpen.isOpenMap_subtype_val {s : Set X} (hs : IsOpen s) : IsOpenMap ((â†‘) : s â†’ X) :=\n  hs.isOpenEmbedding_subtypeVal.isOpenMap\n\n"}
{"name":"IsOpenMap.restrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : IsOpenMap f\ns : Set X\nhs : IsOpen s\nâŠ¢ IsOpenMap (s.restrict f)","decl":"theorem IsOpenMap.restrict {f : X â†’ Y} (hf : IsOpenMap f) {s : Set X} (hs : IsOpen s) :\n    IsOpenMap (s.restrict f) :=\n  hf.comp hs.isOpenMap_subtype_val\n\n"}
{"name":"IsClosed.isClosedEmbedding_subtypeVal","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsClosed s\nâŠ¢ Topology.IsClosedEmbedding Subtype.val","decl":"lemma IsClosed.isClosedEmbedding_subtypeVal {s : Set X} (hs : IsClosed s) :\n    IsClosedEmbedding ((â†‘) : s â†’ X) := .subtypeVal hs\n\n"}
{"name":"IsClosed.closedEmbedding_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsClosed s\nâŠ¢ Topology.IsClosedEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-20\")]\nalias IsClosed.closedEmbedding_subtype_val := IsClosed.isClosedEmbedding_subtypeVal\n\n"}
{"name":"IsClosed.isClosedMap_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsClosed s\nâŠ¢ IsClosedMap Subtype.val","decl":"theorem IsClosed.isClosedMap_subtype_val {s : Set X} (hs : IsClosed s) :\n    IsClosedMap ((â†‘) : s â†’ X) :=\n  hs.isClosedEmbedding_subtypeVal.isClosedMap\n\n"}
{"name":"Continuous.subtype_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\np : X â†’ Prop\nf : Y â†’ X\nh : Continuous f\nhp : âˆ€ (x : Y), p (f x)\nâŠ¢ Continuous fun x => âŸ¨f x, â‹¯âŸ©","decl":"@[continuity, fun_prop]\ntheorem Continuous.subtype_mk {f : Y â†’ X} (h : Continuous f) (hp : âˆ€ x, p (f x)) :\n    Continuous fun x => (âŸ¨f x, hp xâŸ© : Subtype p) :=\n  continuous_induced_rng.2 h\n\n"}
{"name":"Continuous.subtype_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\np : X â†’ Prop\nf : X â†’ Y\nh : Continuous f\nq : Y â†’ Prop\nhpq : âˆ€ (x : X), p x â†’ q (f x)\nâŠ¢ Continuous (Subtype.map f hpq)","decl":"theorem Continuous.subtype_map {f : X â†’ Y} (h : Continuous f) {q : Y â†’ Prop}\n    (hpq : âˆ€ x, p x â†’ q (f x)) : Continuous (Subtype.map f hpq) :=\n  (h.comp continuous_subtype_val).subtype_mk _\n\n"}
{"name":"continuous_inclusion","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nh : HasSubset.Subset s t\nâŠ¢ Continuous (Set.inclusion h)","decl":"theorem continuous_inclusion {s t : Set X} (h : s âŠ† t) : Continuous (inclusion h) :=\n  continuous_id.subtype_map h\n\n"}
{"name":"continuousAt_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\np : X â†’ Prop\nx : Subtype p\nâŠ¢ ContinuousAt Subtype.val x","decl":"theorem continuousAt_subtype_val {p : X â†’ Prop} {x : Subtype p} :\n    ContinuousAt ((â†‘) : Subtype p â†’ X) x :=\n  continuous_subtype_val.continuousAt\n\n"}
{"name":"Subtype.dense_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nt : Set â†‘s\nâŠ¢ Iff (Dense t) (HasSubset.Subset s (closure â†‘t))","decl":"theorem Subtype.dense_iff {s : Set X} {t : Set s} : Dense t â†” s âŠ† closure ((â†‘) '' t) := by\n  rw [IsInducing.subtypeVal.dense_iff, SetCoe.forall]\n  rfl\n\n"}
{"name":"map_nhds_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nx : â†‘s\nâŠ¢ Eq (Filter.map Subtype.val (nhds x)) (nhdsWithin (â†‘x) s)","decl":"theorem map_nhds_subtype_val {s : Set X} (x : s) : map ((â†‘) : s â†’ X) (ğ“ x) = ğ“[s] â†‘x := by\n  rw [IsInducing.subtypeVal.map_nhds_eq, Subtype.range_val]\n\n"}
{"name":"map_nhds_subtype_coe_eq_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\np : X â†’ Prop\nx : X\nhx : p x\nh : Filter.Eventually (fun x => p x) (nhds x)\nâŠ¢ Eq (Filter.map Subtype.val (nhds âŸ¨x, hxâŸ©)) (nhds x)","decl":"theorem map_nhds_subtype_coe_eq_nhds {x : X} (hx : p x) (h : âˆ€á¶  x in ğ“ x, p x) :\n    map ((â†‘) : Subtype p â†’ X) (ğ“ âŸ¨x, hxâŸ©) = ğ“ x :=\n  map_nhds_induced_of_mem <| by rw [Subtype.range_val]; exact h\n\n"}
{"name":"nhds_subtype_eq_comap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\np : X â†’ Prop\nx : X\nh : p x\nâŠ¢ Eq (nhds âŸ¨x, hâŸ©) (Filter.comap Subtype.val (nhds x))","decl":"theorem nhds_subtype_eq_comap {x : X} {h : p x} : ğ“ (âŸ¨x, hâŸ© : Subtype p) = comap (â†‘) (ğ“ x) :=\n  nhds_induced _ _\n\n"}
{"name":"tendsto_subtype_rng","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nY : Type u_5\np : X â†’ Prop\nl : Filter Y\nf : Y â†’ Subtype p\nx : Subtype p\nâŠ¢ Iff (Filter.Tendsto f l (nhds x)) (Filter.Tendsto (fun x => â†‘(f x)) l (nhds â†‘x))","decl":"theorem tendsto_subtype_rng {Y : Type*} {p : X â†’ Prop} {l : Filter Y} {f : Y â†’ Subtype p} :\n    âˆ€ {x : Subtype p}, Tendsto f l (ğ“ x) â†” Tendsto (fun x => (f x : X)) l (ğ“ (x : X))\n  | âŸ¨a, haâŸ© => by rw [nhds_subtype_eq_comap, tendsto_comap_iff]; rfl\n\n"}
{"name":"closure_subtype","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\np : X â†’ Prop\nx : Subtype fun a => p a\ns : Set (Subtype fun a => p a)\nâŠ¢ Iff (Membership.mem (closure s) x) (Membership.mem (closure (Set.image Subtype.val s)) â†‘x)","decl":"theorem closure_subtype {x : { a // p a }} {s : Set { a // p a }} :\n    x âˆˆ closure s â†” (x : X) âˆˆ closure (((â†‘) : _ â†’ X) '' s) :=\n  closure_induced\n\n"}
{"name":"continuousAt_codRestrict_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nt : Set Y\nh1 : âˆ€ (x : X), Membership.mem t (f x)\nx : X\nâŠ¢ Iff (ContinuousAt (Set.codRestrict f t h1) x) (ContinuousAt f x)","decl":"@[simp]\ntheorem continuousAt_codRestrict_iff {f : X â†’ Y} {t : Set Y} (h1 : âˆ€ x, f x âˆˆ t) {x : X} :\n    ContinuousAt (codRestrict f t h1) x â†” ContinuousAt f x :=\n  IsInducing.subtypeVal.continuousAt_iff\n\n"}
{"name":"ContinuousAt.codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nt : Set Y\nh1 : âˆ€ (x : X), Membership.mem t (f x)\nx : X\naâœ : ContinuousAt f x\nâŠ¢ ContinuousAt (Set.codRestrict f t h1) x","decl":"alias âŸ¨_, ContinuousAt.codRestrictâŸ© := continuousAt_codRestrict_iff\n\n"}
{"name":"ContinuousAt.restrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\ns : Set X\nt : Set Y\nh1 : Set.MapsTo f s t\nx : â†‘s\nh2 : ContinuousAt f â†‘x\nâŠ¢ ContinuousAt (Set.MapsTo.restrict f s t h1) x","decl":"theorem ContinuousAt.restrict {f : X â†’ Y} {s : Set X} {t : Set Y} (h1 : MapsTo f s t) {x : s}\n    (h2 : ContinuousAt f x) : ContinuousAt (h1.restrict f s t) x :=\n  (h2.comp continuousAt_subtype_val).codRestrict _\n\n"}
{"name":"ContinuousAt.restrictPreimage","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\ns : Set Y\nx : â†‘(Set.preimage f s)\nh : ContinuousAt f â†‘x\nâŠ¢ ContinuousAt (s.restrictPreimage f) x","decl":"theorem ContinuousAt.restrictPreimage {f : X â†’ Y} {s : Set Y} {x : f â»Â¹' s} (h : ContinuousAt f x) :\n    ContinuousAt (s.restrictPreimage f) x :=\n  h.restrict _\n\n"}
{"name":"Continuous.codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\ns : Set Y\nhf : Continuous f\nhs : âˆ€ (a : X), Membership.mem s (f a)\nâŠ¢ Continuous (Set.codRestrict f s hs)","decl":"@[continuity, fun_prop]\ntheorem Continuous.codRestrict {f : X â†’ Y} {s : Set Y} (hf : Continuous f) (hs : âˆ€ a, f a âˆˆ s) :\n    Continuous (s.codRestrict f hs) :=\n  hf.subtype_mk hs\n\n"}
{"name":"Continuous.restrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\ns : Set X\nt : Set Y\nh1 : Set.MapsTo f s t\nh2 : Continuous f\nâŠ¢ Continuous (Set.MapsTo.restrict f s t h1)","decl":"@[continuity, fun_prop]\ntheorem Continuous.restrict {f : X â†’ Y} {s : Set X} {t : Set Y} (h1 : MapsTo f s t)\n    (h2 : Continuous f) : Continuous (h1.restrict f s t) :=\n  (h2.comp continuous_subtype_val).codRestrict _\n\n"}
{"name":"Continuous.restrictPreimage","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\ns : Set Y\nh : Continuous f\nâŠ¢ Continuous (s.restrictPreimage f)","decl":"@[continuity, fun_prop]\ntheorem Continuous.restrictPreimage {f : X â†’ Y} {s : Set Y} (h : Continuous f) :\n    Continuous (s.restrictPreimage f) :=\n  h.restrict _\n\n"}
{"name":"Topology.IsInducing.codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ne : X â†’ Y\nhe : Topology.IsInducing e\ns : Set Y\nhs : âˆ€ (x : X), Membership.mem s (e x)\nâŠ¢ Topology.IsInducing (Set.codRestrict e s hs)","decl":"theorem Topology.IsInducing.codRestrict {e : X â†’ Y} (he : IsInducing e) {s : Set Y}\n    (hs : âˆ€ x, e x âˆˆ s) : IsInducing (codRestrict e s hs) :=\n  he.of_comp (he.continuous.codRestrict hs) continuous_subtype_val\n\n"}
{"name":"Inducing.codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ne : X â†’ Y\nhe : Topology.IsInducing e\ns : Set Y\nhs : âˆ€ (x : X), Membership.mem s (e x)\nâŠ¢ Topology.IsInducing (Set.codRestrict e s hs)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.codRestrict := IsInducing.codRestrict\n\n"}
{"name":"Topology.IsEmbedding.codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ne : X â†’ Y\nhe : Topology.IsEmbedding e\ns : Set Y\nhs : âˆ€ (x : X), Membership.mem s (e x)\nâŠ¢ Topology.IsEmbedding (Set.codRestrict e s hs)","decl":"protected lemma Topology.IsEmbedding.codRestrict {e : X â†’ Y} (he : IsEmbedding e) (s : Set Y)\n    (hs : âˆ€ x, e x âˆˆ s) : IsEmbedding (codRestrict e s hs) :=\n  he.of_comp (he.continuous.codRestrict hs) continuous_subtype_val\n\n"}
{"name":"Embedding.codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ne : X â†’ Y\nhe : Topology.IsEmbedding e\ns : Set Y\nhs : âˆ€ (x : X), Membership.mem s (e x)\nâŠ¢ Topology.IsEmbedding (Set.codRestrict e s hs)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.codRestrict := IsEmbedding.codRestrict\n\n"}
{"name":"Topology.IsEmbedding.inclusion","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nh : HasSubset.Subset s t\nâŠ¢ Topology.IsEmbedding (Set.inclusion h)","decl":"protected lemma Topology.IsEmbedding.inclusion (h : s âŠ† t) :\n    IsEmbedding (inclusion h) := IsEmbedding.subtypeVal.codRestrict _ _\n\n"}
{"name":"Topology.IsOpenEmbedding.inclusion","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nhst : HasSubset.Subset s t\nhs : IsOpen (Set.preimage Subtype.val s)\nâŠ¢ Topology.IsOpenEmbedding (Set.inclusion hst)","decl":"protected lemma Topology.IsOpenEmbedding.inclusion (hst : s âŠ† t) (hs : IsOpen (t â†“âˆ© s)) :\n    IsOpenEmbedding (inclusion hst) where\n  toIsEmbedding := .inclusion _\n  isOpen_range := by rwa [range_inclusion]\n\n"}
{"name":"Topology.IsClosedEmbedding.inclusion","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nhst : HasSubset.Subset s t\nhs : IsClosed (Set.preimage Subtype.val s)\nâŠ¢ Topology.IsClosedEmbedding (Set.inclusion hst)","decl":"protected lemma Topology.IsClosedEmbedding.inclusion (hst : s âŠ† t) (hs : IsClosed (t â†“âˆ© s)) :\n    IsClosedEmbedding (inclusion hst) where\n  toIsEmbedding := .inclusion _\n  isClosed_range := by rwa [range_inclusion]\n\n"}
{"name":"embedding_inclusion","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nh : HasSubset.Subset s t\nâŠ¢ Topology.IsEmbedding (Set.inclusion h)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_inclusion := IsEmbedding.inclusion\n\n"}
{"name":"DiscreteTopology.of_subset","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u_5\ninstâœ : TopologicalSpace X\ns t : Set X\nxâœ : DiscreteTopology â†‘s\nts : HasSubset.Subset t s\nâŠ¢ DiscreteTopology â†‘t","decl":"/-- Let `s, t âŠ† X` be two subsets of a topological space `X`.  If `t âŠ† s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem DiscreteTopology.of_subset {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (_ : DiscreteTopology s) (ts : t âŠ† s) : DiscreteTopology t :=\n  (IsEmbedding.inclusion ts).discreteTopology\n\n"}
{"name":"DiscreteTopology.preimage_of_continuous_injective","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u_5\nY : Type u_6\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ns : Set Y\ninstâœ : DiscreteTopology â†‘s\nf : X â†’ Y\nhc : Continuous f\nhinj : Function.Injective f\nâŠ¢ DiscreteTopology â†‘(Set.preimage f s)","decl":"/-- Let `s` be a discrete subset of a topological space. Then the preimage of `s` by\na continuous injective map is also discrete. -/\ntheorem DiscreteTopology.preimage_of_continuous_injective {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] (s : Set Y) [DiscreteTopology s] {f : X â†’ Y} (hc : Continuous f)\n    (hinj : Function.Injective f) : DiscreteTopology (f â»Â¹' s) :=\n  DiscreteTopology.of_continuous_injective (Î² := s) (Continuous.restrict\n    (by exact fun _ x â†¦ x) hc) ((MapsTo.restrict_inj _).mpr hinj.injOn)\n\n"}
{"name":"Topology.IsQuotientMap.restrictPreimage_isOpen","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : Topology.IsQuotientMap f\ns : Set Y\nhs : IsOpen s\nâŠ¢ Topology.IsQuotientMap (s.restrictPreimage f)","decl":"/-- If `f : X â†’ Y` is a quotient map,\nthen its restriction to the preimage of an open set is a quotient map too. -/\ntheorem Topology.IsQuotientMap.restrictPreimage_isOpen {f : X â†’ Y} (hf : IsQuotientMap f)\n    {s : Set Y} (hs : IsOpen s) : IsQuotientMap (s.restrictPreimage f) := by\n  refine isQuotientMap_iff.2 âŸ¨hf.surjective.restrictPreimage _, fun U â†¦ ?_âŸ©\n  rw [hs.isOpenEmbedding_subtypeVal.isOpen_iff_image_isOpen, â† hf.isOpen_preimage,\n    (hs.preimage hf.continuous).isOpenEmbedding_subtypeVal.isOpen_iff_image_isOpen,\n    image_val_preimage_restrictPreimage]\n\n"}
{"name":"QuotientMap.restrictPreimage_isOpen","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : Topology.IsQuotientMap f\ns : Set Y\nhs : IsOpen s\nâŠ¢ Topology.IsQuotientMap (s.restrictPreimage f)","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.restrictPreimage_isOpen := IsQuotientMap.restrictPreimage_isOpen\n\n"}
{"name":"isClosed_preimage_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nâŠ¢ Iff (IsClosed (Set.preimage Subtype.val t)) (HasSubset.Subset (Inter.inter s (closure (Inter.inter s t))) t)","decl":"open scoped Set.Notation in\nlemma isClosed_preimage_val {s t : Set X} : IsClosed (s â†“âˆ© t) â†” s âˆ© closure (s âˆ© t) âŠ† t := by\n  rw [â† closure_eq_iff_isClosed, IsEmbedding.subtypeVal.closure_eq_preimage_closure_image,\n    â† Subtype.val_injective.image_injective.eq_iff, Subtype.image_preimage_coe,\n    Subtype.image_preimage_coe, subset_antisymm_iff, and_iff_left, Set.subset_inter_iff,\n    and_iff_right]\n  exacts [Set.inter_subset_left, Set.subset_inter Set.inter_subset_left subset_closure]\n\n"}
{"name":"frontier_inter_open_inter","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns t : Set X\nht : IsOpen t\nâŠ¢ Eq (Inter.inter (frontier (Inter.inter s t)) t) (Inter.inter (frontier s) t)","decl":"theorem frontier_inter_open_inter {s t : Set X} (ht : IsOpen t) :\n    frontier (s âˆ© t) âˆ© t = frontier s âˆ© t := by\n  simp only [Set.inter_comm _ t, â† Subtype.preimage_coe_eq_preimage_coe_iff,\n    ht.isOpenMap_subtype_val.preimage_frontier_eq_frontier_preimage continuous_subtype_val,\n    Subtype.preimage_coe_self_inter]\n\n"}
{"name":"isQuotientMap_quot_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nr : X â†’ X â†’ Prop\nâŠ¢ Topology.IsQuotientMap (Quot.mk r)","decl":"theorem isQuotientMap_quot_mk : IsQuotientMap (@Quot.mk X r) :=\n  âŸ¨Quot.exists_rep, rflâŸ©\n\n"}
{"name":"quotientMap_quot_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nr : X â†’ X â†’ Prop\nâŠ¢ Topology.IsQuotientMap (Quot.mk r)","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_quot_mk := isQuotientMap_quot_mk\n\n"}
{"name":"continuous_quot_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nr : X â†’ X â†’ Prop\nâŠ¢ Continuous (Quot.mk r)","decl":"@[continuity, fun_prop]\ntheorem continuous_quot_mk : Continuous (@Quot.mk X r) :=\n  continuous_coinduced_rng\n\n"}
{"name":"continuous_quot_lift","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nr : X â†’ X â†’ Prop\nf : X â†’ Y\nhr : âˆ€ (a b : X), r a b â†’ Eq (f a) (f b)\nh : Continuous f\nâŠ¢ Continuous (Quot.lift f hr)","decl":"@[continuity, fun_prop]\ntheorem continuous_quot_lift {f : X â†’ Y} (hr : âˆ€ a b, r a b â†’ f a = f b) (h : Continuous f) :\n    Continuous (Quot.lift f hr : Quot r â†’ Y) :=\n  continuous_coinduced_dom.2 h\n\n"}
{"name":"isQuotientMap_quotient_mk'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Setoid X\nâŠ¢ Topology.IsQuotientMap Quotient.mk'","decl":"theorem isQuotientMap_quotient_mk' : IsQuotientMap (@Quotient.mk' X s) :=\n  isQuotientMap_quot_mk\n\n"}
{"name":"quotientMap_quotient_mk'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Setoid X\nâŠ¢ Topology.IsQuotientMap Quotient.mk'","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_quotient_mk' := isQuotientMap_quotient_mk'\n\n"}
{"name":"continuous_quotient_mk'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Setoid X\nâŠ¢ Continuous Quotient.mk'","decl":"theorem continuous_quotient_mk' : Continuous (@Quotient.mk' X s) :=\n  continuous_coinduced_rng\n\n"}
{"name":"Continuous.quotient_lift","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Setoid X\nf : X â†’ Y\nh : Continuous f\nhs : âˆ€ (a b : X), HasEquiv.Equiv a b â†’ Eq (f a) (f b)\nâŠ¢ Continuous (Quotient.lift f hs)","decl":"theorem Continuous.quotient_lift {f : X â†’ Y} (h : Continuous f) (hs : âˆ€ a b, a â‰ˆ b â†’ f a = f b) :\n    Continuous (Quotient.lift f hs : Quotient s â†’ Y) :=\n  continuous_coinduced_dom.2 h\n\n"}
{"name":"Continuous.quotient_liftOn'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Setoid X\nf : X â†’ Y\nh : Continuous f\nhs : âˆ€ (a b : X), s a b â†’ Eq (f a) (f b)\nâŠ¢ Continuous fun x => x.liftOn' f hs","decl":"theorem Continuous.quotient_liftOn' {f : X â†’ Y} (h : Continuous f)\n    (hs : âˆ€ a b, s a b â†’ f a = f b) :\n    Continuous (fun x => Quotient.liftOn' x f hs : Quotient s â†’ Y) :=\n  h.quotient_lift hs\n\n"}
{"name":"Continuous.quotient_map'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Setoid X\nt : Setoid Y\nf : X â†’ Y\nhf : Continuous f\nH : Relator.LiftFun (â‡‘s) (â‡‘t) f f\nâŠ¢ Continuous (Quotient.map' f H)","decl":"@[continuity, fun_prop]\ntheorem Continuous.quotient_map' {t : Setoid Y} {f : X â†’ Y} (hf : Continuous f)\n    (H : (s.r â‡’ t.r) f f) : Continuous (Quotient.map' f H) :=\n  (continuous_quotient_mk'.comp hf).quotient_lift _\n\n"}
{"name":"continuous_pi_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\ninstâœ : TopologicalSpace X\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nf : X â†’ (i : Î¹) â†’ Ï€ i\nâŠ¢ Iff (Continuous f) (âˆ€ (i : Î¹), Continuous fun a => f a i)","decl":"theorem continuous_pi_iff : Continuous f â†” âˆ€ i, Continuous fun a => f a i := by\n  simp only [continuous_iInf_rng, continuous_induced_rng, comp_def]\n\n"}
{"name":"continuous_pi","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\ninstâœ : TopologicalSpace X\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nf : X â†’ (i : Î¹) â†’ Ï€ i\nh : âˆ€ (i : Î¹), Continuous fun a => f a i\nâŠ¢ Continuous f","decl":"@[continuity, fun_prop]\ntheorem continuous_pi (h : âˆ€ i, Continuous fun a => f a i) : Continuous f :=\n  continuous_pi_iff.2 h\n\n"}
{"name":"continuous_apply","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ni : Î¹\nâŠ¢ Continuous fun p => p i","decl":"@[continuity, fun_prop]\ntheorem continuous_apply (i : Î¹) : Continuous fun p : âˆ€ i, Ï€ i => p i :=\n  continuous_iInf_dom continuous_induced_dom\n\n"}
{"name":"continuous_apply_apply","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÎº : Type u_7\nÏ : Îº â†’ Î¹ â†’ Type u_8\ninstâœ : (j : Îº) â†’ (i : Î¹) â†’ TopologicalSpace (Ï j i)\nj : Îº\ni : Î¹\nâŠ¢ Continuous fun p => p j i","decl":"@[continuity]\ntheorem continuous_apply_apply {Ï : Îº â†’ Î¹ â†’ Type*} [âˆ€ j i, TopologicalSpace (Ï j i)] (j : Îº)\n    (i : Î¹) : Continuous fun p : âˆ€ j, âˆ€ i, Ï j i => p j i :=\n  (continuous_apply i).comp (continuous_apply j)\n\n"}
{"name":"continuousAt_apply","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ni : Î¹\nx : (i : Î¹) â†’ Ï€ i\nâŠ¢ ContinuousAt (fun p => p i) x","decl":"theorem continuousAt_apply (i : Î¹) (x : âˆ€ i, Ï€ i) : ContinuousAt (fun p : âˆ€ i, Ï€ i => p i) x :=\n  (continuous_apply i).continuousAt\n\n"}
{"name":"Filter.Tendsto.apply_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nl : Filter Y\nf : Y â†’ (i : Î¹) â†’ Ï€ i\nx : (i : Î¹) â†’ Ï€ i\nh : Filter.Tendsto f l (nhds x)\ni : Î¹\nâŠ¢ Filter.Tendsto (fun a => f a i) l (nhds (x i))","decl":"theorem Filter.Tendsto.apply_nhds {l : Filter Y} {f : Y â†’ âˆ€ i, Ï€ i} {x : âˆ€ i, Ï€ i}\n    (h : Tendsto f l (ğ“ x)) (i : Î¹) : Tendsto (fun a => f a i) l (ğ“ <| x i) :=\n  (continuousAt_apply i _).tendsto.comp h\n\n"}
{"name":"Continuous.piMap","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nY : Î¹ â†’ Type u_8\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Y i)\nf : (i : Î¹) â†’ Ï€ i â†’ Y i\nhf : âˆ€ (i : Î¹), Continuous (f i)\nâŠ¢ Continuous (Pi.map f)","decl":"@[fun_prop]\nprotected theorem Continuous.piMap {Y : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (Y i)]\n    {f : âˆ€ i, Ï€ i â†’ Y i} (hf : âˆ€ i, Continuous (f i)) : Continuous (Pi.map f) :=\n  continuous_pi fun i â†¦ (hf i).comp (continuous_apply i)\n\n"}
{"name":"nhds_pi","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\na : (i : Î¹) â†’ Ï€ i\nâŠ¢ Eq (nhds a) (Filter.pi fun i => nhds (a i))","decl":"theorem nhds_pi {a : âˆ€ i, Ï€ i} : ğ“ a = pi fun i => ğ“ (a i) := by\n  simp only [nhds_iInf, nhds_induced, Filter.pi]\n\n"}
{"name":"IsOpenMap.piMap","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nY : Î¹ â†’ Type u_8\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Y i)\nf : (i : Î¹) â†’ Ï€ i â†’ Y i\nhfo : âˆ€ (i : Î¹), IsOpenMap (f i)\nhsurj : Filter.Eventually (fun i => Function.Surjective (f i)) Filter.cofinite\nâŠ¢ IsOpenMap (Pi.map f)","decl":"protected theorem IsOpenMap.piMap {Y : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (Y i)] {f : âˆ€ i, Ï€ i â†’ Y i}\n    (hfo : âˆ€ i, IsOpenMap (f i)) (hsurj : âˆ€á¶  i in cofinite, Surjective (f i)) :\n    IsOpenMap (Pi.map f) := by\n  refine IsOpenMap.of_nhds_le fun x â†¦ ?_\n  rw [nhds_pi, nhds_pi, map_piMap_pi hsurj]\n  exact Filter.pi_mono fun i â†¦ (hfo i).nhds_le _\n\n"}
{"name":"IsOpenQuotientMap.piMap","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nY : Î¹ â†’ Type u_8\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Y i)\nf : (i : Î¹) â†’ Ï€ i â†’ Y i\nhf : âˆ€ (i : Î¹), IsOpenQuotientMap (f i)\nâŠ¢ IsOpenQuotientMap (Pi.map f)","decl":"protected theorem IsOpenQuotientMap.piMap {Y : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (Y i)]\n    {f : âˆ€ i, Ï€ i â†’ Y i} (hf : âˆ€ i, IsOpenQuotientMap (f i)) : IsOpenQuotientMap (Pi.map f) :=\n  âŸ¨.piMap fun i â†¦ (hf i).1, .piMap fun i â†¦ (hf i).2, .piMap (fun i â†¦ (hf i).3) <|\n    .of_forall fun i â†¦ (hf i).1âŸ©\n\n"}
{"name":"tendsto_pi_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nf : Y â†’ (i : Î¹) â†’ Ï€ i\ng : (i : Î¹) â†’ Ï€ i\nu : Filter Y\nâŠ¢ Iff (Filter.Tendsto f u (nhds g)) (âˆ€ (x : Î¹), Filter.Tendsto (fun i => f i x) u (nhds (g x)))","decl":"theorem tendsto_pi_nhds {f : Y â†’ âˆ€ i, Ï€ i} {g : âˆ€ i, Ï€ i} {u : Filter Y} :\n    Tendsto f u (ğ“ g) â†” âˆ€ x, Tendsto (fun i => f i x) u (ğ“ (g x)) := by\n  rw [nhds_pi, Filter.tendsto_pi]\n\n"}
{"name":"continuousAt_pi","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\ninstâœ : TopologicalSpace X\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nf : X â†’ (i : Î¹) â†’ Ï€ i\nx : X\nâŠ¢ Iff (ContinuousAt f x) (âˆ€ (i : Î¹), ContinuousAt (fun y => f y i) x)","decl":"theorem continuousAt_pi {f : X â†’ âˆ€ i, Ï€ i} {x : X} :\n    ContinuousAt f x â†” âˆ€ i, ContinuousAt (fun y => f y i) x :=\n  tendsto_pi_nhds\n\n"}
{"name":"continuousAt_pi'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\ninstâœ : TopologicalSpace X\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nf : X â†’ (i : Î¹) â†’ Ï€ i\nx : X\nhf : âˆ€ (i : Î¹), ContinuousAt (fun y => f y i) x\nâŠ¢ ContinuousAt f x","decl":"@[fun_prop]\ntheorem continuousAt_pi' {f : X â†’ âˆ€ i, Ï€ i} {x : X} (hf : âˆ€ i, ContinuousAt (fun y => f y i) x) :\n    ContinuousAt f x :=\n  continuousAt_pi.2 hf\n\n"}
{"name":"ContinuousAt.piMap","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nY : Î¹ â†’ Type u_8\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Y i)\nf : (i : Î¹) â†’ Ï€ i â†’ Y i\nx : (i : Î¹) â†’ Ï€ i\nhf : âˆ€ (i : Î¹), ContinuousAt (f i) (x i)\nâŠ¢ ContinuousAt (Pi.map f) x","decl":"@[fun_prop]\nprotected theorem ContinuousAt.piMap {Y : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (Y i)]\n    {f : âˆ€ i, Ï€ i â†’ Y i} {x : âˆ€ i, Ï€ i} (hf : âˆ€ i, ContinuousAt (f i) (x i)) :\n    ContinuousAt (Pi.map f) x :=\n  continuousAt_pi.2 fun i â†¦ (hf i).comp (continuousAt_apply i x)\n\n"}
{"name":"Pi.continuous_precomp'","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nÎ¹' : Type u_8\nÏ† : Î¹' â†’ Î¹\nâŠ¢ Continuous fun f j => f (Ï† j)","decl":"theorem Pi.continuous_precomp' {Î¹' : Type*} (Ï† : Î¹' â†’ Î¹) :\n    Continuous (fun (f : (âˆ€ i, Ï€ i)) (j : Î¹') â†¦ f (Ï† j)) :=\n  continuous_pi fun j â†¦ continuous_apply (Ï† j)\n\n"}
{"name":"Pi.continuous_precomp","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nÎ¹ : Type u_5\ninstâœ : TopologicalSpace X\nÎ¹' : Type u_8\nÏ† : Î¹' â†’ Î¹\nâŠ¢ Continuous fun x => Function.comp x Ï†","decl":"theorem Pi.continuous_precomp {Î¹' : Type*} (Ï† : Î¹' â†’ Î¹) :\n    Continuous (Â· âˆ˜ Ï† : (Î¹ â†’ X) â†’ (Î¹' â†’ X)) :=\n  Pi.continuous_precomp' Ï†\n\n"}
{"name":"Pi.continuous_postcomp'","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nX : Î¹ â†’ Type u_8\ninstâœ : (i : Î¹) â†’ TopologicalSpace (X i)\ng : (i : Î¹) â†’ Ï€ i â†’ X i\nhg : âˆ€ (i : Î¹), Continuous (g i)\nâŠ¢ Continuous fun f i => g i (f i)","decl":"theorem Pi.continuous_postcomp' {X : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (X i)]\n    {g : âˆ€ i, Ï€ i â†’ X i} (hg : âˆ€ i, Continuous (g i)) :\n    Continuous (fun (f : (âˆ€ i, Ï€ i)) (i : Î¹) â†¦ g i (f i)) :=\n  continuous_pi fun i â†¦ (hg i).comp <| continuous_apply i\n\n"}
{"name":"Pi.continuous_postcomp","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nÎ¹ : Type u_5\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ng : X â†’ Y\nhg : Continuous g\nâŠ¢ Continuous fun x => Function.comp g x","decl":"theorem Pi.continuous_postcomp [TopologicalSpace Y] {g : X â†’ Y} (hg : Continuous g) :\n    Continuous (g âˆ˜ Â· : (Î¹ â†’ X) â†’ (Î¹ â†’ Y)) :=\n  Pi.continuous_postcomp' fun _ â†¦ hg\n\n"}
{"name":"Pi.induced_precomp'","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nÎ¹' : Type u_8\nÏ† : Î¹' â†’ Î¹\nâŠ¢ Eq (TopologicalSpace.induced (fun f j => f (Ï† j)) Pi.topologicalSpace) (iInf fun i' => TopologicalSpace.induced (Function.eval (Ï† i')) (T (Ï† i')))","decl":"lemma Pi.induced_precomp' {Î¹' : Type*} (Ï† : Î¹' â†’ Î¹) :\n    induced (fun (f : (âˆ€ i, Ï€ i)) (j : Î¹') â†¦ f (Ï† j)) Pi.topologicalSpace =\n    â¨… i', induced (eval (Ï† i')) (T (Ï† i')) := by\n  simp [Pi.topologicalSpace, induced_iInf, induced_compose, comp_def]\n\n"}
{"name":"Pi.induced_precomp","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nÎ¹ : Type u_5\ninstâœ : TopologicalSpace Y\nÎ¹' : Type u_8\nÏ† : Î¹' â†’ Î¹\nâŠ¢ Eq (TopologicalSpace.induced (fun x => Function.comp x Ï†) Pi.topologicalSpace) (iInf fun i' => TopologicalSpace.induced (Function.eval (Ï† i')) instâœ)","decl":"lemma Pi.induced_precomp [TopologicalSpace Y] {Î¹' : Type*} (Ï† : Î¹' â†’ Î¹) :\n    induced (Â· âˆ˜ Ï†) Pi.topologicalSpace =\n    â¨… i', induced (eval (Ï† i')) â€¹TopologicalSpace Yâ€º :=\n  induced_precomp' Ï†\n\n"}
{"name":"Pi.continuous_restrict","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nS : Set Î¹\nâŠ¢ Continuous S.restrict","decl":"@[continuity, fun_prop]\nlemma Pi.continuous_restrict (S : Set Î¹) :\n    Continuous (S.restrict : (âˆ€ i : Î¹, Ï€ i) â†’ (âˆ€ i : S, Ï€ i)) :=\n  Pi.continuous_precomp' ((â†‘) : S â†’ Î¹)\n\n"}
{"name":"Pi.continuous_restrictâ‚‚","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ns t : Set Î¹\nhst : HasSubset.Subset s t\nâŠ¢ Continuous (Set.restrictâ‚‚ hst)","decl":"@[continuity, fun_prop]\nlemma Pi.continuous_restrictâ‚‚ {s t : Set Î¹} (hst : s âŠ† t) : Continuous (restrictâ‚‚ (Ï€ := Ï€) hst) :=\n  continuous_pi fun _ â†¦ continuous_apply _\n\n"}
{"name":"Finset.continuous_restrict","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ns : Finset Î¹\nâŠ¢ Continuous s.restrict","decl":"@[continuity, fun_prop]\ntheorem Finset.continuous_restrict (s : Finset Î¹) : Continuous (s.restrict (Ï€ := Ï€)) :=\n  continuous_pi fun _ â†¦ continuous_apply _\n\n"}
{"name":"Finset.continuous_restrictâ‚‚","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ns t : Finset Î¹\nhst : HasSubset.Subset s t\nâŠ¢ Continuous (Finset.restrictâ‚‚ hst)","decl":"@[continuity, fun_prop]\ntheorem Finset.continuous_restrictâ‚‚ {s t : Finset Î¹} (hst : s âŠ† t) :\n    Continuous (Finset.restrictâ‚‚ (Ï€ := Ï€) hst) :=\n  continuous_pi fun _ â†¦ continuous_apply _\n\n"}
{"name":"Pi.continuous_restrict_apply","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Z\ns : Set X\nf : X â†’ Z\nhf : Continuous f\nâŠ¢ Continuous (s.restrict f)","decl":"@[continuity, fun_prop]\ntheorem Pi.continuous_restrict_apply (s : Set X) {f : X â†’ Z} (hf : Continuous f) :\n    Continuous (s.restrict f) := hf.comp continuous_subtype_val\n\n"}
{"name":"Pi.continuous_restrictâ‚‚_apply","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Z\ns t : Set X\nhst : HasSubset.Subset s t\nf : â†‘t â†’ Z\nhf : Continuous f\nâŠ¢ Continuous (Set.restrictâ‚‚ hst f)","decl":"@[continuity, fun_prop]\ntheorem Pi.continuous_restrictâ‚‚_apply {s t : Set X} (hst : s âŠ† t)\n    {f : t â†’ Z} (hf : Continuous f) :\n    Continuous (restrictâ‚‚ (Ï€ := fun _ â†¦ Z) hst f) := hf.comp (continuous_inclusion hst)\n\n"}
{"name":"Finset.continuous_restrict_apply","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Z\ns : Finset X\nf : X â†’ Z\nhf : Continuous f\nâŠ¢ Continuous (s.restrict f)","decl":"@[continuity, fun_prop]\ntheorem Finset.continuous_restrict_apply (s : Finset X) {f : X â†’ Z} (hf : Continuous f) :\n    Continuous (s.restrict f) := hf.comp continuous_subtype_val\n\n"}
{"name":"Finset.continuous_restrictâ‚‚_apply","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Z\ns t : Finset X\nhst : HasSubset.Subset s t\nf : (Subtype fun x => Membership.mem t x) â†’ Z\nhf : Continuous f\nâŠ¢ Continuous (Finset.restrictâ‚‚ hst f)","decl":"@[continuity, fun_prop]\ntheorem Finset.continuous_restrictâ‚‚_apply {s t : Finset X} (hst : s âŠ† t)\n    {f : t â†’ Z} (hf : Continuous f) :\n    Continuous (restrictâ‚‚ (Ï€ := fun _ â†¦ Z) hst f) := hf.comp (continuous_inclusion hst)\n\n"}
{"name":"Pi.induced_restrict","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nS : Set Î¹\nâŠ¢ Eq (TopologicalSpace.induced S.restrict Pi.topologicalSpace) (iInf fun i => iInf fun h => TopologicalSpace.induced (Function.eval i) (T i))","decl":"lemma Pi.induced_restrict (S : Set Î¹) :\n    induced (S.restrict) Pi.topologicalSpace =\n    â¨… i âˆˆ S, induced (eval i) (T i) := by\n  simp (config := { unfoldPartialApp := true }) [â† iInf_subtype'', â† induced_precomp' ((â†‘) : S â†’ Î¹),\n    restrict]\n\n"}
{"name":"Pi.induced_restrict_sUnion","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nğ”– : Set (Set Î¹)\nâŠ¢ Eq (TopologicalSpace.induced ğ”–.sUnion.restrict Pi.topologicalSpace) (iInf fun S => iInf fun h => TopologicalSpace.induced S.restrict Pi.topologicalSpace)","decl":"lemma Pi.induced_restrict_sUnion (ğ”– : Set (Set Î¹)) :\n    induced (â‹ƒâ‚€ ğ”–).restrict (Pi.topologicalSpace (Y := fun i : (â‹ƒâ‚€ ğ”–) â†¦ Ï€ i)) =\n    â¨… S âˆˆ ğ”–, induced S.restrict Pi.topologicalSpace := by\n  simp_rw [Pi.induced_restrict, iInf_sUnion]\n\n"}
{"name":"Filter.Tendsto.update","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ninstâœ : DecidableEq Î¹\nl : Filter Y\nf : Y â†’ (i : Î¹) â†’ Ï€ i\nx : (i : Î¹) â†’ Ï€ i\nhf : Filter.Tendsto f l (nhds x)\ni : Î¹\ng : Y â†’ Ï€ i\nxi : Ï€ i\nhg : Filter.Tendsto g l (nhds xi)\nâŠ¢ Filter.Tendsto (fun a => Function.update (f a) i (g a)) l (nhds (Function.update x i xi))","decl":"theorem Filter.Tendsto.update [DecidableEq Î¹] {l : Filter Y} {f : Y â†’ âˆ€ i, Ï€ i} {x : âˆ€ i, Ï€ i}\n    (hf : Tendsto f l (ğ“ x)) (i : Î¹) {g : Y â†’ Ï€ i} {xi : Ï€ i} (hg : Tendsto g l (ğ“ xi)) :\n    Tendsto (fun a => update (f a) i (g a)) l (ğ“ <| update x i xi) :=\n  tendsto_pi_nhds.2 fun j => by rcases eq_or_ne j i with (rfl | hj) <;> simp [*, hf.apply_nhds]\n\n"}
{"name":"ContinuousAt.update","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\ninstâœÂ¹ : TopologicalSpace X\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nf : X â†’ (i : Î¹) â†’ Ï€ i\ninstâœ : DecidableEq Î¹\nx : X\nhf : ContinuousAt f x\ni : Î¹\ng : X â†’ Ï€ i\nhg : ContinuousAt g x\nâŠ¢ ContinuousAt (fun a => Function.update (f a) i (g a)) x","decl":"theorem ContinuousAt.update [DecidableEq Î¹] {x : X} (hf : ContinuousAt f x) (i : Î¹) {g : X â†’ Ï€ i}\n    (hg : ContinuousAt g x) : ContinuousAt (fun a => update (f a) i (g a)) x :=\n  hf.tendsto.update i hg\n\n"}
{"name":"Continuous.update","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nÎ¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\ninstâœÂ¹ : TopologicalSpace X\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nf : X â†’ (i : Î¹) â†’ Ï€ i\ninstâœ : DecidableEq Î¹\nhf : Continuous f\ni : Î¹\ng : X â†’ Ï€ i\nhg : Continuous g\nâŠ¢ Continuous fun a => Function.update (f a) i (g a)","decl":"theorem Continuous.update [DecidableEq Î¹] (hf : Continuous f) (i : Î¹) {g : X â†’ Ï€ i}\n    (hg : Continuous g) : Continuous fun a => update (f a) i (g a) :=\n  continuous_iff_continuousAt.2 fun _ => hf.continuousAt.update i hg.continuousAt\n\n"}
{"name":"continuous_update","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ninstâœ : DecidableEq Î¹\ni : Î¹\nâŠ¢ Continuous fun f => Function.update f.1 i f.2","decl":"/-- `Function.update f i x` is continuous in `(f, x)`. -/\n@[continuity, fun_prop]\ntheorem continuous_update [DecidableEq Î¹] (i : Î¹) :\n    Continuous fun f : (âˆ€ j, Ï€ j) Ã— Ï€ i => update f.1 i f.2 :=\n  continuous_fst.update i continuous_snd\n\n"}
{"name":"continuous_single","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ninstâœÂ¹ : (i : Î¹) â†’ Zero (Ï€ i)\ninstâœ : DecidableEq Î¹\ni : Î¹\nâŠ¢ Continuous fun x => Pi.single i x","decl":"/-- `Pi.mulSingle i x` is continuous in `x`. -/\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: restore @[continuity]\n@[to_additive \"`Pi.single i x` is continuous in `x`.\"]\ntheorem continuous_mulSingle [âˆ€ i, One (Ï€ i)] [DecidableEq Î¹] (i : Î¹) :\n    Continuous fun x => (Pi.mulSingle i x : âˆ€ i, Ï€ i) :=\n  continuous_const.update _ continuous_id\n\n"}
{"name":"continuous_mulSingle","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ninstâœÂ¹ : (i : Î¹) â†’ One (Ï€ i)\ninstâœ : DecidableEq Î¹\ni : Î¹\nâŠ¢ Continuous fun x => Pi.mulSingle i x","decl":"/-- `Pi.mulSingle i x` is continuous in `x`. -/\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: restore @[continuity]\n@[to_additive \"`Pi.single i x` is continuous in `x`.\"]\ntheorem continuous_mulSingle [âˆ€ i, One (Ï€ i)] [DecidableEq Î¹] (i : Î¹) :\n    Continuous fun x => (Pi.mulSingle i x : âˆ€ i, Ï€ i) :=\n  continuous_const.update _ continuous_id\n\n"}
{"name":"Filter.Tendsto.finCons","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nn : Nat\nÏ€ : Fin (HAdd.hAdd n 1) â†’ Type u_8\ninstâœ : (i : Fin (HAdd.hAdd n 1)) â†’ TopologicalSpace (Ï€ i)\nf : Y â†’ Ï€ 0\ng : Y â†’ (j : Fin n) â†’ Ï€ j.succ\nl : Filter Y\nx : Ï€ 0\ny : (j : Fin n) â†’ Ï€ j.succ\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\nâŠ¢ Filter.Tendsto (fun a => Fin.cons (f a) (g a)) l (nhds (Fin.cons x y))","decl":"theorem Filter.Tendsto.finCons\n    {f : Y â†’ Ï€ 0} {g : Y â†’ âˆ€ j : Fin n, Ï€ j.succ} {l : Filter Y} {x : Ï€ 0} {y : âˆ€ j, Ï€ (Fin.succ j)}\n    (hf : Tendsto f l (ğ“ x)) (hg : Tendsto g l (ğ“ y)) :\n    Tendsto (fun a => Fin.cons (f a) (g a)) l (ğ“ <| Fin.cons x y) :=\n  tendsto_pi_nhds.2 fun j => Fin.cases (by simpa) (by simpa using tendsto_pi_nhds.1 hg) j\n\n"}
{"name":"ContinuousAt.finCons","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\nn : Nat\nÏ€ : Fin (HAdd.hAdd n 1) â†’ Type u_8\ninstâœ : (i : Fin (HAdd.hAdd n 1)) â†’ TopologicalSpace (Ï€ i)\nf : X â†’ Ï€ 0\ng : X â†’ (j : Fin n) â†’ Ï€ j.succ\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nâŠ¢ ContinuousAt (fun a => Fin.cons (f a) (g a)) x","decl":"theorem ContinuousAt.finCons {f : X â†’ Ï€ 0} {g : X â†’ âˆ€ j : Fin n, Ï€ (Fin.succ j)} {x : X}\n    (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun a => Fin.cons (f a) (g a)) x :=\n  hf.tendsto.finCons hg\n\n"}
{"name":"Continuous.finCons","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\nn : Nat\nÏ€ : Fin (HAdd.hAdd n 1) â†’ Type u_8\ninstâœ : (i : Fin (HAdd.hAdd n 1)) â†’ TopologicalSpace (Ï€ i)\nf : X â†’ Ï€ 0\ng : X â†’ (j : Fin n) â†’ Ï€ j.succ\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun a => Fin.cons (f a) (g a)","decl":"theorem Continuous.finCons {f : X â†’ Ï€ 0} {g : X â†’ âˆ€ j : Fin n, Ï€ (Fin.succ j)}\n    (hf : Continuous f) (hg : Continuous g) : Continuous fun a => Fin.cons (f a) (g a) :=\n  continuous_iff_continuousAt.2 fun _ => hf.continuousAt.finCons hg.continuousAt\n\n"}
{"name":"Filter.Tendsto.matrixVecCons","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nZ : Type u_1\ninstâœ : TopologicalSpace Z\nn : Nat\nf : Y â†’ Z\ng : Y â†’ Fin n â†’ Z\nl : Filter Y\nx : Z\ny : Fin n â†’ Z\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\nâŠ¢ Filter.Tendsto (fun a => Matrix.vecCons (f a) (g a)) l (nhds (Matrix.vecCons x y))","decl":"theorem Filter.Tendsto.matrixVecCons\n    {f : Y â†’ Z} {g : Y â†’ Fin n â†’ Z} {l : Filter Y} {x : Z} {y : Fin n â†’ Z}\n    (hf : Tendsto f l (ğ“ x)) (hg : Tendsto g l (ğ“ y)) :\n    Tendsto (fun a => Matrix.vecCons (f a) (g a)) l (ğ“ <| Matrix.vecCons x y) :=\n  hf.finCons hg\n\n"}
{"name":"ContinuousAt.matrixVecCons","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Z\nn : Nat\nf : X â†’ Z\ng : X â†’ Fin n â†’ Z\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nâŠ¢ ContinuousAt (fun a => Matrix.vecCons (f a) (g a)) x","decl":"theorem ContinuousAt.matrixVecCons\n    {f : X â†’ Z} {g : X â†’ Fin n â†’ Z} {x : X} (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun a => Matrix.vecCons (f a) (g a)) x :=\n  hf.finCons hg\n\n"}
{"name":"Continuous.matrixVecCons","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Z\nn : Nat\nf : X â†’ Z\ng : X â†’ Fin n â†’ Z\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun a => Matrix.vecCons (f a) (g a)","decl":"theorem Continuous.matrixVecCons\n    {f : X â†’ Z} {g : X â†’ Fin n â†’ Z} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun a => Matrix.vecCons (f a) (g a) :=\n  hf.finCons hg\n\n"}
{"name":"Filter.Tendsto.finSnoc","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nn : Nat\nÏ€ : Fin (HAdd.hAdd n 1) â†’ Type u_8\ninstâœ : (i : Fin (HAdd.hAdd n 1)) â†’ TopologicalSpace (Ï€ i)\nf : Y â†’ (j : Fin n) â†’ Ï€ j.castSucc\ng : Y â†’ Ï€ (Fin.last n)\nl : Filter Y\nx : (j : Fin n) â†’ Ï€ j.castSucc\ny : Ï€ (Fin.last n)\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\nâŠ¢ Filter.Tendsto (fun a => Fin.snoc (f a) (g a)) l (nhds (Fin.snoc x y))","decl":"theorem Filter.Tendsto.finSnoc\n    {f : Y â†’ âˆ€ j : Fin n, Ï€ j.castSucc} {g : Y â†’ Ï€ (Fin.last _)}\n    {l : Filter Y} {x : âˆ€ j, Ï€ (Fin.castSucc j)} {y : Ï€ (Fin.last _)}\n    (hf : Tendsto f l (ğ“ x)) (hg : Tendsto g l (ğ“ y)) :\n    Tendsto (fun a => Fin.snoc (f a) (g a)) l (ğ“ <| Fin.snoc x y) :=\n  tendsto_pi_nhds.2 fun j => Fin.lastCases (by simpa) (by simpa using tendsto_pi_nhds.1 hf) j\n\n"}
{"name":"ContinuousAt.finSnoc","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\nn : Nat\nÏ€ : Fin (HAdd.hAdd n 1) â†’ Type u_8\ninstâœ : (i : Fin (HAdd.hAdd n 1)) â†’ TopologicalSpace (Ï€ i)\nf : X â†’ (j : Fin n) â†’ Ï€ j.castSucc\ng : X â†’ Ï€ (Fin.last n)\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nâŠ¢ ContinuousAt (fun a => Fin.snoc (f a) (g a)) x","decl":"theorem ContinuousAt.finSnoc {f : X â†’ âˆ€ j : Fin n, Ï€ j.castSucc} {g : X â†’ Ï€ (Fin.last _)} {x : X}\n    (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun a => Fin.snoc (f a) (g a)) x :=\n  hf.tendsto.finSnoc hg\n\n"}
{"name":"Continuous.finSnoc","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\nn : Nat\nÏ€ : Fin (HAdd.hAdd n 1) â†’ Type u_8\ninstâœ : (i : Fin (HAdd.hAdd n 1)) â†’ TopologicalSpace (Ï€ i)\nf : X â†’ (j : Fin n) â†’ Ï€ j.castSucc\ng : X â†’ Ï€ (Fin.last n)\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun a => Fin.snoc (f a) (g a)","decl":"theorem Continuous.finSnoc {f : X â†’ âˆ€ j : Fin n, Ï€ j.castSucc} {g : X â†’ Ï€ (Fin.last _)}\n    (hf : Continuous f) (hg : Continuous g) : Continuous fun a => Fin.snoc (f a) (g a) :=\n  continuous_iff_continuousAt.2 fun _ => hf.continuousAt.finSnoc hg.continuousAt\n\n"}
{"name":"Filter.Tendsto.finInsertNth","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nn : Nat\nÏ€ : Fin (HAdd.hAdd n 1) â†’ Type u_8\ninstâœ : (i : Fin (HAdd.hAdd n 1)) â†’ TopologicalSpace (Ï€ i)\ni : Fin (HAdd.hAdd n 1)\nf : Y â†’ Ï€ i\ng : Y â†’ (j : Fin n) â†’ Ï€ (i.succAbove j)\nl : Filter Y\nx : Ï€ i\ny : (j : Fin n) â†’ Ï€ (i.succAbove j)\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\nâŠ¢ Filter.Tendsto (fun a => i.insertNth (f a) (g a)) l (nhds (i.insertNth x y))","decl":"theorem Filter.Tendsto.finInsertNth\n    (i : Fin (n + 1)) {f : Y â†’ Ï€ i} {g : Y â†’ âˆ€ j : Fin n, Ï€ (i.succAbove j)} {l : Filter Y}\n    {x : Ï€ i} {y : âˆ€ j, Ï€ (i.succAbove j)} (hf : Tendsto f l (ğ“ x)) (hg : Tendsto g l (ğ“ y)) :\n    Tendsto (fun a => i.insertNth (f a) (g a)) l (ğ“ <| i.insertNth x y) :=\n  tendsto_pi_nhds.2 fun j => Fin.succAboveCases i (by simpa) (by simpa using tendsto_pi_nhds.1 hg) j\n\n"}
{"name":"Filter.Tendsto.fin_insertNth","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nn : Nat\nÏ€ : Fin (HAdd.hAdd n 1) â†’ Type u_8\ninstâœ : (i : Fin (HAdd.hAdd n 1)) â†’ TopologicalSpace (Ï€ i)\ni : Fin (HAdd.hAdd n 1)\nf : Y â†’ Ï€ i\ng : Y â†’ (j : Fin n) â†’ Ï€ (i.succAbove j)\nl : Filter Y\nx : Ï€ i\ny : (j : Fin n) â†’ Ï€ (i.succAbove j)\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\nâŠ¢ Filter.Tendsto (fun a => i.insertNth (f a) (g a)) l (nhds (i.insertNth x y))","decl":"@[deprecated (since := \"2025-01-02\")]\nalias Filter.Tendsto.fin_insertNth := Filter.Tendsto.finInsertNth\n\n"}
{"name":"ContinuousAt.finInsertNth","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\nn : Nat\nÏ€ : Fin (HAdd.hAdd n 1) â†’ Type u_8\ninstâœ : (i : Fin (HAdd.hAdd n 1)) â†’ TopologicalSpace (Ï€ i)\ni : Fin (HAdd.hAdd n 1)\nf : X â†’ Ï€ i\ng : X â†’ (j : Fin n) â†’ Ï€ (i.succAbove j)\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nâŠ¢ ContinuousAt (fun a => i.insertNth (f a) (g a)) x","decl":"theorem ContinuousAt.finInsertNth\n    (i : Fin (n + 1)) {f : X â†’ Ï€ i} {g : X â†’ âˆ€ j : Fin n, Ï€ (i.succAbove j)} {x : X}\n    (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun a => i.insertNth (f a) (g a)) x :=\n  hf.tendsto.finInsertNth i hg\n\n"}
{"name":"ContinuousAt.fin_insertNth","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\nn : Nat\nÏ€ : Fin (HAdd.hAdd n 1) â†’ Type u_8\ninstâœ : (i : Fin (HAdd.hAdd n 1)) â†’ TopologicalSpace (Ï€ i)\ni : Fin (HAdd.hAdd n 1)\nf : X â†’ Ï€ i\ng : X â†’ (j : Fin n) â†’ Ï€ (i.succAbove j)\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nâŠ¢ ContinuousAt (fun a => i.insertNth (f a) (g a)) x","decl":"@[deprecated (since := \"2025-01-02\")]\nalias ContinuousAt.fin_insertNth := ContinuousAt.finInsertNth\n\n"}
{"name":"Continuous.finInsertNth","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\nn : Nat\nÏ€ : Fin (HAdd.hAdd n 1) â†’ Type u_8\ninstâœ : (i : Fin (HAdd.hAdd n 1)) â†’ TopologicalSpace (Ï€ i)\ni : Fin (HAdd.hAdd n 1)\nf : X â†’ Ï€ i\ng : X â†’ (j : Fin n) â†’ Ï€ (i.succAbove j)\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun a => i.insertNth (f a) (g a)","decl":"theorem Continuous.finInsertNth\n    (i : Fin (n + 1)) {f : X â†’ Ï€ i} {g : X â†’ âˆ€ j : Fin n, Ï€ (i.succAbove j)}\n    (hf : Continuous f) (hg : Continuous g) : Continuous fun a => i.insertNth (f a) (g a) :=\n  continuous_iff_continuousAt.2 fun _ => hf.continuousAt.finInsertNth i hg.continuousAt\n\n"}
{"name":"Continuous.fin_insertNth","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\nn : Nat\nÏ€ : Fin (HAdd.hAdd n 1) â†’ Type u_8\ninstâœ : (i : Fin (HAdd.hAdd n 1)) â†’ TopologicalSpace (Ï€ i)\ni : Fin (HAdd.hAdd n 1)\nf : X â†’ Ï€ i\ng : X â†’ (j : Fin n) â†’ Ï€ (i.succAbove j)\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous fun a => i.insertNth (f a) (g a)","decl":"@[deprecated (since := \"2025-01-02\")]\nalias Continuous.fin_insertNth := Continuous.finInsertNth\n\n"}
{"name":"isOpen_set_pi","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ni : Set Î¹\ns : (a : Î¹) â†’ Set (Ï€ a)\nhi : i.Finite\nhs : âˆ€ (a : Î¹), Membership.mem i a â†’ IsOpen (s a)\nâŠ¢ IsOpen (i.pi s)","decl":"theorem isOpen_set_pi {i : Set Î¹} {s : âˆ€ a, Set (Ï€ a)} (hi : i.Finite)\n    (hs : âˆ€ a âˆˆ i, IsOpen (s a)) : IsOpen (pi i s) := by\n  rw [pi_def]; exact hi.isOpen_biInter fun a ha => (hs _ ha).preimage (continuous_apply _)\n\n"}
{"name":"isOpen_pi_iff","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ns : Set ((a : Î¹) â†’ Ï€ a)\nâŠ¢ Iff (IsOpen s) (âˆ€ (f : (a : Î¹) â†’ Ï€ a), Membership.mem s f â†’ Exists fun I => Exists fun u => And (âˆ€ (a : Î¹), Membership.mem I a â†’ And (IsOpen (u a)) (Membership.mem (u a) (f a))) (HasSubset.Subset ((â†‘I).pi u) s))","decl":"theorem isOpen_pi_iff {s : Set (âˆ€ a, Ï€ a)} :\n    IsOpen s â†”\n      âˆ€ f, f âˆˆ s â†’ âˆƒ (I : Finset Î¹) (u : âˆ€ a, Set (Ï€ a)),\n        (âˆ€ a, a âˆˆ I â†’ IsOpen (u a) âˆ§ f a âˆˆ u a) âˆ§ (I : Set Î¹).pi u âŠ† s := by\n  rw [isOpen_iff_nhds]\n  simp_rw [le_principal_iff, nhds_pi, Filter.mem_pi', mem_nhds_iff]\n  refine forallâ‚‚_congr fun a _ => âŸ¨?_, ?_âŸ©\n  Â· rintro âŸ¨I, t, âŸ¨h1, h2âŸ©âŸ©\n    refine âŸ¨I, fun a => eval a '' (I : Set Î¹).pi fun a => (h1 a).choose, fun i hi => ?_, ?_âŸ©\n    Â· simp_rw [eval_image_pi (Finset.mem_coe.mpr hi)\n          (pi_nonempty_iff.mpr fun i => âŸ¨_, fun _ => (h1 i).choose_spec.2.2âŸ©)]\n      exact (h1 i).choose_spec.2\n    Â· exact Subset.trans\n        (pi_mono fun i hi => (eval_image_pi_subset hi).trans (h1 i).choose_spec.1) h2\n  Â· rintro âŸ¨I, t, âŸ¨h1, h2âŸ©âŸ©\n    classical\n    refine âŸ¨I, fun a => ite (a âˆˆ I) (t a) univ, fun i => ?_, ?_âŸ©\n    Â· by_cases hi : i âˆˆ I\n      Â· use t i\n        simp_rw [if_pos hi]\n        exact âŸ¨Subset.rfl, (h1 i) hiâŸ©\n      Â· use univ\n        simp_rw [if_neg hi]\n        exact âŸ¨Subset.rfl, isOpen_univ, mem_univ _âŸ©\n    Â· rw [â† univ_pi_ite]\n      simp only [â† ite_and, â† Finset.mem_coe, and_self_iff, univ_pi_ite, h2]\n\n"}
{"name":"isOpen_pi_iff'","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ninstâœ : Finite Î¹\ns : Set ((a : Î¹) â†’ Ï€ a)\nâŠ¢ Iff (IsOpen s) (âˆ€ (f : (a : Î¹) â†’ Ï€ a), Membership.mem s f â†’ Exists fun u => And (âˆ€ (a : Î¹), And (IsOpen (u a)) (Membership.mem (u a) (f a))) (HasSubset.Subset (Set.univ.pi u) s))","decl":"theorem isOpen_pi_iff' [Finite Î¹] {s : Set (âˆ€ a, Ï€ a)} :\n    IsOpen s â†”\n      âˆ€ f, f âˆˆ s â†’ âˆƒ u : âˆ€ a, Set (Ï€ a), (âˆ€ a, IsOpen (u a) âˆ§ f a âˆˆ u a) âˆ§ univ.pi u âŠ† s := by\n  cases nonempty_fintype Î¹\n  rw [isOpen_iff_nhds]\n  simp_rw [le_principal_iff, nhds_pi, Filter.mem_pi', mem_nhds_iff]\n  refine forallâ‚‚_congr fun a _ => âŸ¨?_, ?_âŸ©\n  Â· rintro âŸ¨I, t, âŸ¨h1, h2âŸ©âŸ©\n    refine\n      âŸ¨fun i => (h1 i).choose,\n        âŸ¨fun i => (h1 i).choose_spec.2,\n          (pi_mono fun i _ => (h1 i).choose_spec.1).trans (Subset.trans ?_ h2)âŸ©âŸ©\n    rw [â† pi_inter_compl (I : Set Î¹)]\n    exact inter_subset_left\n  Â· exact fun âŸ¨u, âŸ¨h1, _âŸ©âŸ© =>\n      âŸ¨Finset.univ, u, âŸ¨fun i => âŸ¨u i, âŸ¨rfl.subset, h1 iâŸ©âŸ©, by rwa [Finset.coe_univ]âŸ©âŸ©\n\n"}
{"name":"isClosed_set_pi","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ni : Set Î¹\ns : (a : Î¹) â†’ Set (Ï€ a)\nhs : âˆ€ (a : Î¹), Membership.mem i a â†’ IsClosed (s a)\nâŠ¢ IsClosed (i.pi s)","decl":"theorem isClosed_set_pi {i : Set Î¹} {s : âˆ€ a, Set (Ï€ a)} (hs : âˆ€ a âˆˆ i, IsClosed (s a)) :\n    IsClosed (pi i s) := by\n  rw [pi_def]; exact isClosed_biInter fun a ha => (hs _ ha).preimage (continuous_apply _)\n\n"}
{"name":"mem_nhds_of_pi_mem_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nI : Set Î¹\ns : (i : Î¹) â†’ Set (Ï€ i)\na : (i : Î¹) â†’ Ï€ i\nhs : Membership.mem (nhds a) (I.pi s)\ni : Î¹\nhi : Membership.mem I i\nâŠ¢ Membership.mem (nhds (a i)) (s i)","decl":"theorem mem_nhds_of_pi_mem_nhds {I : Set Î¹} {s : âˆ€ i, Set (Ï€ i)} (a : âˆ€ i, Ï€ i) (hs : I.pi s âˆˆ ğ“ a)\n    {i : Î¹} (hi : i âˆˆ I) : s i âˆˆ ğ“ (a i) := by\n  rw [nhds_pi] at hs; exact mem_of_pi_mem_pi hs hi\n\n"}
{"name":"set_pi_mem_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ni : Set Î¹\ns : (a : Î¹) â†’ Set (Ï€ a)\nx : (a : Î¹) â†’ Ï€ a\nhi : i.Finite\nhs : âˆ€ (a : Î¹), Membership.mem i a â†’ Membership.mem (nhds (x a)) (s a)\nâŠ¢ Membership.mem (nhds x) (i.pi s)","decl":"theorem set_pi_mem_nhds {i : Set Î¹} {s : âˆ€ a, Set (Ï€ a)} {x : âˆ€ a, Ï€ a} (hi : i.Finite)\n    (hs : âˆ€ a âˆˆ i, s a âˆˆ ğ“ (x a)) : pi i s âˆˆ ğ“ x := by\n  rw [pi_def, biInter_mem hi]\n  exact fun a ha => (continuous_apply a).continuousAt (hs a ha)\n\n"}
{"name":"set_pi_mem_nhds_iff","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nI : Set Î¹\nhI : I.Finite\ns : (i : Î¹) â†’ Set (Ï€ i)\na : (i : Î¹) â†’ Ï€ i\nâŠ¢ Iff (Membership.mem (nhds a) (I.pi s)) (âˆ€ (i : Î¹), Membership.mem I i â†’ Membership.mem (nhds (a i)) (s i))","decl":"theorem set_pi_mem_nhds_iff {I : Set Î¹} (hI : I.Finite) {s : âˆ€ i, Set (Ï€ i)} (a : âˆ€ i, Ï€ i) :\n    I.pi s âˆˆ ğ“ a â†” âˆ€ i : Î¹, i âˆˆ I â†’ s i âˆˆ ğ“ (a i) := by\n  rw [nhds_pi, pi_mem_pi_iff hI]\n\n"}
{"name":"interior_pi_set","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nI : Set Î¹\nhI : I.Finite\ns : (i : Î¹) â†’ Set (Ï€ i)\nâŠ¢ Eq (interior (I.pi s)) (I.pi fun i => interior (s i))","decl":"theorem interior_pi_set {I : Set Î¹} (hI : I.Finite) {s : âˆ€ i, Set (Ï€ i)} :\n    interior (pi I s) = I.pi fun i => interior (s i) := by\n  ext a\n  simp only [Set.mem_pi, mem_interior_iff_mem_nhds, set_pi_mem_nhds_iff hI]\n\n"}
{"name":"exists_finset_piecewise_mem_of_mem_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ninstâœ : DecidableEq Î¹\ns : Set ((a : Î¹) â†’ Ï€ a)\nx : (a : Î¹) â†’ Ï€ a\nhs : Membership.mem (nhds x) s\ny : (a : Î¹) â†’ Ï€ a\nâŠ¢ Exists fun I => Membership.mem s (I.piecewise x y)","decl":"theorem exists_finset_piecewise_mem_of_mem_nhds [DecidableEq Î¹] {s : Set (âˆ€ a, Ï€ a)} {x : âˆ€ a, Ï€ a}\n    (hs : s âˆˆ ğ“ x) (y : âˆ€ a, Ï€ a) : âˆƒ I : Finset Î¹, I.piecewise x y âˆˆ s := by\n  simp only [nhds_pi, Filter.mem_pi'] at hs\n  rcases hs with âŸ¨I, t, htx, htsâŸ©\n  refine âŸ¨I, hts fun i hi => ?_âŸ©\n  simpa [Finset.mem_coe.1 hi] using mem_of_mem_nhds (htx i)\n\n"}
{"name":"pi_generateFrom_eq","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_8\ng : (a : Î¹) â†’ Set (Set (Ï€ a))\nâŠ¢ Eq Pi.topologicalSpace (TopologicalSpace.generateFrom (setOf fun t => Exists fun s => Exists fun i => And (âˆ€ (a : Î¹), Membership.mem i a â†’ Membership.mem (g a) (s a)) (Eq t ((â†‘i).pi s))))","decl":"theorem pi_generateFrom_eq {Ï€ : Î¹ â†’ Type*} {g : âˆ€ a, Set (Set (Ï€ a))} :\n    (@Pi.topologicalSpace Î¹ Ï€ fun a => generateFrom (g a)) =\n      generateFrom\n        { t | âˆƒ (s : âˆ€ a, Set (Ï€ a)) (i : Finset Î¹), (âˆ€ a âˆˆ i, s a âˆˆ g a) âˆ§ t = pi (â†‘i) s } := by\n  refine le_antisymm ?_ ?_\n  Â· apply le_generateFrom\n    rintro _ âŸ¨s, i, hi, rflâŸ©\n    letI := fun a => generateFrom (g a)\n    exact isOpen_set_pi i.finite_toSet (fun a ha => GenerateOpen.basic _ (hi a ha))\n  Â· classical\n    refine le_iInf fun i => coinduced_le_iff_le_induced.1 <| le_generateFrom fun s hs => ?_\n    refine GenerateOpen.basic _ âŸ¨update (fun i => univ) i s, {i}, ?_âŸ©\n    simp [hs]\n\n"}
{"name":"pi_eq_generateFrom","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nâŠ¢ Eq Pi.topologicalSpace (TopologicalSpace.generateFrom (setOf fun g => Exists fun s => Exists fun i => And (âˆ€ (a : Î¹), Membership.mem i a â†’ IsOpen (s a)) (Eq g ((â†‘i).pi s))))","decl":"theorem pi_eq_generateFrom :\n    Pi.topologicalSpace =\n      generateFrom\n        { g | âˆƒ (s : âˆ€ a, Set (Ï€ a)) (i : Finset Î¹), (âˆ€ a âˆˆ i, IsOpen (s a)) âˆ§ g = pi (â†‘i) s } :=\n  calc Pi.topologicalSpace\n  _ = @Pi.topologicalSpace Î¹ Ï€ fun _ => generateFrom { s | IsOpen s } := by\n    simp only [generateFrom_setOf_isOpen]\n  _ = _ := pi_generateFrom_eq\n\n"}
{"name":"pi_generateFrom_eq_finite","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_8\ng : (a : Î¹) â†’ Set (Set (Ï€ a))\ninstâœ : Finite Î¹\nhg : âˆ€ (a : Î¹), Eq (g a).sUnion Set.univ\nâŠ¢ Eq Pi.topologicalSpace (TopologicalSpace.generateFrom (setOf fun t => Exists fun s => And (âˆ€ (a : Î¹), Membership.mem (g a) (s a)) (Eq t (Set.univ.pi s))))","decl":"theorem pi_generateFrom_eq_finite {Ï€ : Î¹ â†’ Type*} {g : âˆ€ a, Set (Set (Ï€ a))} [Finite Î¹]\n    (hg : âˆ€ a, â‹ƒâ‚€ g a = univ) :\n    (@Pi.topologicalSpace Î¹ Ï€ fun a => generateFrom (g a)) =\n      generateFrom { t | âˆƒ s : âˆ€ a, Set (Ï€ a), (âˆ€ a, s a âˆˆ g a) âˆ§ t = pi univ s } := by\n  cases nonempty_fintype Î¹\n  rw [pi_generateFrom_eq]\n  refine le_antisymm (generateFrom_anti ?_) (le_generateFrom ?_)\n  Â· exact fun s âŸ¨t, ht, EqâŸ© => âŸ¨t, Finset.univ, by simp [ht, Eq]âŸ©\n  Â· rintro s âŸ¨t, i, ht, rflâŸ©\n    letI := generateFrom { t | âˆƒ s : âˆ€ a, Set (Ï€ a), (âˆ€ a, s a âˆˆ g a) âˆ§ t = pi univ s }\n    refine isOpen_iff_forall_mem_open.2 fun f hf => ?_\n    choose c hcg hfc using fun a => sUnion_eq_univ_iff.1 (hg a) (f a)\n    refine âŸ¨pi i t âˆ© pi ((â†‘i)á¶œ : Set Î¹) c, inter_subset_left, ?_, âŸ¨hf, fun a _ => hfc aâŸ©âŸ©\n    classical\n    rw [â† univ_pi_piecewise]\n    refine GenerateOpen.basic _ âŸ¨_, fun a => ?_, rflâŸ©\n    by_cases a âˆˆ i <;> simp [*]\n\n"}
{"name":"induced_to_pi","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nX : Type u_8\nf : X â†’ (i : Î¹) â†’ Ï€ i\nâŠ¢ Eq (TopologicalSpace.induced f Pi.topologicalSpace) (iInf fun i => TopologicalSpace.induced (fun x => f x i) inferInstance)","decl":"theorem induced_to_pi {X : Type*} (f : X â†’ âˆ€ i, Ï€ i) :\n    induced f Pi.topologicalSpace = â¨… i, induced (f Â· i) inferInstance := by\n  simp_rw [Pi.topologicalSpace, induced_iInf, induced_compose, Function.comp_def]\n\n"}
{"name":"inducing_iInf_to_pi","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nX : Type u_8\nf : (i : Î¹) â†’ X â†’ Ï€ i\nâŠ¢ Topology.IsInducing fun x i => f i x","decl":"/-- Suppose `Ï€ i` is a family of topological spaces indexed by `i : Î¹`, and `X` is a type\nendowed with a family of maps `f i : X â†’ Ï€ i` for every `i : Î¹`, hence inducing a\nmap `g : X â†’ Î  i, Ï€ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Î¹` varies is simply the topology on `X` induced by `g : X â†’ Î  i, Ï€ i`\nwhere `Î  i, Ï€ i` is endowed with the usual product topology. -/\ntheorem inducing_iInf_to_pi {X : Type*} (f : âˆ€ i, X â†’ Ï€ i) :\n    @IsInducing X (âˆ€ i, Ï€ i) (â¨… i, induced (f i) inferInstance) _ fun x i => f i x :=\n  letI := â¨… i, induced (f i) inferInstance; âŸ¨(induced_to_pi _).symmâŸ©\n\n"}
{"name":"Pi.discreteTopology","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\nT : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\nâŠ¢ DiscreteTopology ((i : Î¹) â†’ Ï€ i)","decl":"/-- A finite product of discrete spaces is discrete. -/\ninstance Pi.discreteTopology : DiscreteTopology (âˆ€ i, Ï€ i) :=\n  singletons_open_iff_discrete.mp fun x => by\n    rw [â† univ_pi_singleton]\n    exact isOpen_set_pi finite_univ fun i _ => (isOpen_discrete {x i})\n\n"}
{"name":"continuous_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nâŠ¢ Continuous (Sigma.mk i)","decl":"@[continuity, fun_prop]\ntheorem continuous_sigmaMk {i : Î¹} : Continuous (@Sigma.mk Î¹ Ïƒ i) :=\n  continuous_iSup_rng continuous_coinduced_rng\n\n"}
{"name":"isOpen_sigma_iff","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ns : Set (Sigma Ïƒ)\nâŠ¢ Iff (IsOpen s) (âˆ€ (i : Î¹), IsOpen (Set.preimage (Sigma.mk i) s))","decl":"theorem isOpen_sigma_iff {s : Set (Sigma Ïƒ)} : IsOpen s â†” âˆ€ i, IsOpen (Sigma.mk i â»Â¹' s) := by\n  rw [isOpen_iSup_iff]\n  rfl\n\n"}
{"name":"isClosed_sigma_iff","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ns : Set (Sigma Ïƒ)\nâŠ¢ Iff (IsClosed s) (âˆ€ (i : Î¹), IsClosed (Set.preimage (Sigma.mk i) s))","decl":"theorem isClosed_sigma_iff {s : Set (Sigma Ïƒ)} : IsClosed s â†” âˆ€ i, IsClosed (Sigma.mk i â»Â¹' s) := by\n  simp only [â† isOpen_compl_iff, isOpen_sigma_iff, preimage_compl]\n\n"}
{"name":"isOpenMap_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nâŠ¢ IsOpenMap (Sigma.mk i)","decl":"theorem isOpenMap_sigmaMk {i : Î¹} : IsOpenMap (@Sigma.mk Î¹ Ïƒ i) := by\n  intro s hs\n  rw [isOpen_sigma_iff]\n  intro j\n  rcases eq_or_ne j i with (rfl | hne)\n  Â· rwa [preimage_image_eq _ sigma_mk_injective]\n  Â· rw [preimage_image_sigmaMk_of_ne hne]\n    exact isOpen_empty\n\n"}
{"name":"isOpen_range_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nâŠ¢ IsOpen (Set.range (Sigma.mk i))","decl":"theorem isOpen_range_sigmaMk {i : Î¹} : IsOpen (range (@Sigma.mk Î¹ Ïƒ i)) :=\n  isOpenMap_sigmaMk.isOpen_range\n\n"}
{"name":"isClosedMap_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nâŠ¢ IsClosedMap (Sigma.mk i)","decl":"theorem isClosedMap_sigmaMk {i : Î¹} : IsClosedMap (@Sigma.mk Î¹ Ïƒ i) := by\n  intro s hs\n  rw [isClosed_sigma_iff]\n  intro j\n  rcases eq_or_ne j i with (rfl | hne)\n  Â· rwa [preimage_image_eq _ sigma_mk_injective]\n  Â· rw [preimage_image_sigmaMk_of_ne hne]\n    exact isClosed_empty\n\n"}
{"name":"isClosed_range_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nâŠ¢ IsClosed (Set.range (Sigma.mk i))","decl":"theorem isClosed_range_sigmaMk {i : Î¹} : IsClosed (range (@Sigma.mk Î¹ Ïƒ i)) :=\n  isClosedMap_sigmaMk.isClosed_range\n\n"}
{"name":"Topology.IsOpenEmbedding.sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nâŠ¢ Topology.IsOpenEmbedding (Sigma.mk i)","decl":"lemma Topology.IsOpenEmbedding.sigmaMk {i : Î¹} : IsOpenEmbedding (@Sigma.mk Î¹ Ïƒ i) :=\n  .of_continuous_injective_isOpenMap continuous_sigmaMk sigma_mk_injective isOpenMap_sigmaMk\n\n"}
{"name":"isOpenEmbedding_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nâŠ¢ Topology.IsOpenEmbedding (Sigma.mk i)","decl":"@[deprecated (since := \"2024-10-30\")] alias isOpenEmbedding_sigmaMk := IsOpenEmbedding.sigmaMk\n\n"}
{"name":"openEmbedding_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nâŠ¢ Topology.IsOpenEmbedding (Sigma.mk i)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_sigmaMk := IsOpenEmbedding.sigmaMk\n\n"}
{"name":"Topology.IsClosedEmbedding.sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nâŠ¢ Topology.IsClosedEmbedding (Sigma.mk i)","decl":"lemma Topology.IsClosedEmbedding.sigmaMk {i : Î¹} : IsClosedEmbedding (@Sigma.mk Î¹ Ïƒ i) :=\n  .of_continuous_injective_isClosedMap continuous_sigmaMk sigma_mk_injective isClosedMap_sigmaMk\n\n"}
{"name":"isClosedEmbedding_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nâŠ¢ Topology.IsClosedEmbedding (Sigma.mk i)","decl":"@[deprecated (since := \"2024-10-30\")] alias isClosedEmbedding_sigmaMk := IsClosedEmbedding.sigmaMk\n\n"}
{"name":"closedEmbedding_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nâŠ¢ Topology.IsClosedEmbedding (Sigma.mk i)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_sigmaMk := IsClosedEmbedding.sigmaMk\n\n"}
{"name":"Topology.IsEmbedding.sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nâŠ¢ Topology.IsEmbedding (Sigma.mk i)","decl":"lemma Topology.IsEmbedding.sigmaMk {i : Î¹} : IsEmbedding (@Sigma.mk Î¹ Ïƒ i) :=\n  IsClosedEmbedding.sigmaMk.1\n\n"}
{"name":"embedding_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nâŠ¢ Topology.IsEmbedding (Sigma.mk i)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_sigmaMk := IsEmbedding.sigmaMk\n\n"}
{"name":"Sigma.nhds_mk","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nx : Ïƒ i\nâŠ¢ Eq (nhds âŸ¨i, xâŸ©) (Filter.map (Sigma.mk i) (nhds x))","decl":"theorem Sigma.nhds_mk (i : Î¹) (x : Ïƒ i) : ğ“ (âŸ¨i, xâŸ© : Sigma Ïƒ) = Filter.map (Sigma.mk i) (ğ“ x) :=\n  (IsOpenEmbedding.sigmaMk.map_nhds_eq x).symm\n\n"}
{"name":"Sigma.nhds_eq","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\nx : Sigma Ïƒ\nâŠ¢ Eq (nhds x) (Filter.map (Sigma.mk x.fst) (nhds x.snd))","decl":"theorem Sigma.nhds_eq (x : Sigma Ïƒ) : ğ“ x = Filter.map (Sigma.mk x.1) (ğ“ x.2) := by\n  cases x\n  apply Sigma.nhds_mk\n\n"}
{"name":"comap_sigmaMk_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ni : Î¹\nx : Ïƒ i\nâŠ¢ Eq (Filter.comap (Sigma.mk i) (nhds âŸ¨i, xâŸ©)) (nhds x)","decl":"theorem comap_sigmaMk_nhds (i : Î¹) (x : Ïƒ i) : comap (Sigma.mk i) (ğ“ âŸ¨i, xâŸ©) = ğ“ x :=\n  (IsEmbedding.sigmaMk.nhds_eq_comap _).symm\n\n"}
{"name":"isOpen_sigma_fst_preimage","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ns : Set Î¹\nâŠ¢ IsOpen (Set.preimage Sigma.fst s)","decl":"theorem isOpen_sigma_fst_preimage (s : Set Î¹) : IsOpen (Sigma.fst â»Â¹' s : Set (Î£ a, Ïƒ a)) := by\n  rw [â† biUnion_of_singleton s, preimage_iUnionâ‚‚]\n  simp only [â† range_sigmaMk]\n  exact isOpen_biUnion fun _ _ => isOpen_range_sigmaMk\n\n"}
{"name":"continuous_sigma_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nÎ¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : TopologicalSpace X\nf : Sigma Ïƒ â†’ X\nâŠ¢ Iff (Continuous f) (âˆ€ (i : Î¹), Continuous fun a => f âŸ¨i, aâŸ©)","decl":"/-- A map out of a sum type is continuous iff its restriction to each summand is. -/\n@[simp]\ntheorem continuous_sigma_iff {f : Sigma Ïƒ â†’ X} :\n    Continuous f â†” âˆ€ i, Continuous fun a => f âŸ¨i, aâŸ© := by\n  delta instTopologicalSpaceSigma\n  rw [continuous_iSup_dom]\n  exact forall_congr' fun _ => continuous_coinduced_dom\n\n"}
{"name":"continuous_sigma","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nÎ¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : TopologicalSpace X\nf : Sigma Ïƒ â†’ X\nhf : âˆ€ (i : Î¹), Continuous fun a => f âŸ¨i, aâŸ©\nâŠ¢ Continuous f","decl":"/-- A map out of a sum type is continuous if its restriction to each summand is. -/\n@[continuity, fun_prop]\ntheorem continuous_sigma {f : Sigma Ïƒ â†’ X} (hf : âˆ€ i, Continuous fun a => f âŸ¨i, aâŸ©) :\n    Continuous f :=\n  continuous_sigma_iff.2 hf\n\n"}
{"name":"inducing_sigma","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nÎ¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : TopologicalSpace X\nf : Sigma Ïƒ â†’ X\nâŠ¢ Iff (Topology.IsInducing f) (And (âˆ€ (i : Î¹), Topology.IsInducing (Function.comp f (Sigma.mk i))) (âˆ€ (i : Î¹), Exists fun U => And (IsOpen U) (âˆ€ (x : Sigma Ïƒ), Iff (Membership.mem U (f x)) (Eq x.fst i))))","decl":"/-- A map defined on a sigma type (a.k.a. the disjoint union of an indexed family of topological\nspaces) is inducing iff its restriction to each component is inducing and each the image of each\ncomponent under `f` can be separated from the images of all other components by an open set. -/\ntheorem inducing_sigma {f : Sigma Ïƒ â†’ X} :\n    IsInducing f â†” (âˆ€ i, IsInducing (f âˆ˜ Sigma.mk i)) âˆ§\n      (âˆ€ i, âˆƒ U, IsOpen U âˆ§ âˆ€ x, f x âˆˆ U â†” x.1 = i) := by\n  refine âŸ¨fun h â†¦ âŸ¨fun i â†¦ h.comp IsEmbedding.sigmaMk.1, fun i â†¦ ?_âŸ©, ?_âŸ©\n  Â· rcases h.isOpen_iff.1 (isOpen_range_sigmaMk (i := i)) with âŸ¨U, hUo, hUâŸ©\n    refine âŸ¨U, hUo, ?_âŸ©\n    simpa [Set.ext_iff] using hU\n  Â· refine fun âŸ¨hâ‚, hâ‚‚âŸ© â†¦ isInducing_iff_nhds.2 fun âŸ¨i, xâŸ© â†¦ ?_\n    rw [Sigma.nhds_mk, (hâ‚ i).nhds_eq_comap, comp_apply, â† comap_comap, map_comap_of_mem]\n    rcases hâ‚‚ i with âŸ¨U, hUo, hUâŸ©\n    filter_upwards [preimage_mem_comap <| hUo.mem_nhds <| (hU _).2 rfl] with y hy\n    simpa [hU] using hy\n\n"}
{"name":"continuous_sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÎº : Type u_6\nÏƒ : Î¹ â†’ Type u_7\nÏ„ : Îº â†’ Type u_8\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : (k : Îº) â†’ TopologicalSpace (Ï„ k)\nfâ‚ : Î¹ â†’ Îº\nfâ‚‚ : (i : Î¹) â†’ Ïƒ i â†’ Ï„ (fâ‚ i)\nâŠ¢ Iff (Continuous (Sigma.map fâ‚ fâ‚‚)) (âˆ€ (i : Î¹), Continuous (fâ‚‚ i))","decl":"@[simp 1100]\ntheorem continuous_sigma_map {fâ‚ : Î¹ â†’ Îº} {fâ‚‚ : âˆ€ i, Ïƒ i â†’ Ï„ (fâ‚ i)} :\n    Continuous (Sigma.map fâ‚ fâ‚‚) â†” âˆ€ i, Continuous (fâ‚‚ i) :=\n  continuous_sigma_iff.trans <| by\n    simp only [Sigma.map, IsEmbedding.sigmaMk.continuous_iff, comp_def]\n\n"}
{"name":"Continuous.sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÎº : Type u_6\nÏƒ : Î¹ â†’ Type u_7\nÏ„ : Îº â†’ Type u_8\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : (k : Îº) â†’ TopologicalSpace (Ï„ k)\nfâ‚ : Î¹ â†’ Îº\nfâ‚‚ : (i : Î¹) â†’ Ïƒ i â†’ Ï„ (fâ‚ i)\nhf : âˆ€ (i : Î¹), Continuous (fâ‚‚ i)\nâŠ¢ Continuous (Sigma.map fâ‚ fâ‚‚)","decl":"@[continuity, fun_prop]\ntheorem Continuous.sigma_map {fâ‚ : Î¹ â†’ Îº} {fâ‚‚ : âˆ€ i, Ïƒ i â†’ Ï„ (fâ‚ i)} (hf : âˆ€ i, Continuous (fâ‚‚ i)) :\n    Continuous (Sigma.map fâ‚ fâ‚‚) :=\n  continuous_sigma_map.2 hf\n\n"}
{"name":"isOpenMap_sigma","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nÎ¹ : Type u_5\nÏƒ : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : TopologicalSpace X\nf : Sigma Ïƒ â†’ X\nâŠ¢ Iff (IsOpenMap f) (âˆ€ (i : Î¹), IsOpenMap fun a => f âŸ¨i, aâŸ©)","decl":"theorem isOpenMap_sigma {f : Sigma Ïƒ â†’ X} : IsOpenMap f â†” âˆ€ i, IsOpenMap fun a => f âŸ¨i, aâŸ© := by\n  simp only [isOpenMap_iff_nhds_le, Sigma.forall, Sigma.nhds_eq, map_map, comp_def]\n\n"}
{"name":"isOpenMap_sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÎº : Type u_6\nÏƒ : Î¹ â†’ Type u_7\nÏ„ : Îº â†’ Type u_8\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : (k : Îº) â†’ TopologicalSpace (Ï„ k)\nfâ‚ : Î¹ â†’ Îº\nfâ‚‚ : (i : Î¹) â†’ Ïƒ i â†’ Ï„ (fâ‚ i)\nâŠ¢ Iff (IsOpenMap (Sigma.map fâ‚ fâ‚‚)) (âˆ€ (i : Î¹), IsOpenMap (fâ‚‚ i))","decl":"theorem isOpenMap_sigma_map {fâ‚ : Î¹ â†’ Îº} {fâ‚‚ : âˆ€ i, Ïƒ i â†’ Ï„ (fâ‚ i)} :\n    IsOpenMap (Sigma.map fâ‚ fâ‚‚) â†” âˆ€ i, IsOpenMap (fâ‚‚ i) :=\n  isOpenMap_sigma.trans <|\n    forall_congr' fun i => (@IsOpenEmbedding.sigmaMk _ _ _ (fâ‚ i)).isOpenMap_iff.symm\n\n"}
{"name":"Topology.isInducing_sigmaMap","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÎº : Type u_6\nÏƒ : Î¹ â†’ Type u_7\nÏ„ : Îº â†’ Type u_8\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : (k : Îº) â†’ TopologicalSpace (Ï„ k)\nfâ‚ : Î¹ â†’ Îº\nfâ‚‚ : (i : Î¹) â†’ Ïƒ i â†’ Ï„ (fâ‚ i)\nhâ‚ : Function.Injective fâ‚\nâŠ¢ Iff (Topology.IsInducing (Sigma.map fâ‚ fâ‚‚)) (âˆ€ (i : Î¹), Topology.IsInducing (fâ‚‚ i))","decl":"lemma Topology.isInducing_sigmaMap {fâ‚ : Î¹ â†’ Îº} {fâ‚‚ : âˆ€ i, Ïƒ i â†’ Ï„ (fâ‚ i)}\n    (hâ‚ : Injective fâ‚) : IsInducing (Sigma.map fâ‚ fâ‚‚) â†” âˆ€ i, IsInducing (fâ‚‚ i) := by\n  simp only [isInducing_iff_nhds, Sigma.forall, Sigma.nhds_mk, Sigma.map_mk,\n    â† map_sigma_mk_comap hâ‚, map_inj sigma_mk_injective]\n\n"}
{"name":"inducing_sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÎº : Type u_6\nÏƒ : Î¹ â†’ Type u_7\nÏ„ : Îº â†’ Type u_8\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : (k : Îº) â†’ TopologicalSpace (Ï„ k)\nfâ‚ : Î¹ â†’ Îº\nfâ‚‚ : (i : Î¹) â†’ Ïƒ i â†’ Ï„ (fâ‚ i)\nhâ‚ : Function.Injective fâ‚\nâŠ¢ Iff (Topology.IsInducing (Sigma.map fâ‚ fâ‚‚)) (âˆ€ (i : Î¹), Topology.IsInducing (fâ‚‚ i))","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_sigma_map := isInducing_sigmaMap\n\n"}
{"name":"Topology.isEmbedding_sigmaMap","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÎº : Type u_6\nÏƒ : Î¹ â†’ Type u_7\nÏ„ : Îº â†’ Type u_8\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : (k : Îº) â†’ TopologicalSpace (Ï„ k)\nfâ‚ : Î¹ â†’ Îº\nfâ‚‚ : (i : Î¹) â†’ Ïƒ i â†’ Ï„ (fâ‚ i)\nh : Function.Injective fâ‚\nâŠ¢ Iff (Topology.IsEmbedding (Sigma.map fâ‚ fâ‚‚)) (âˆ€ (i : Î¹), Topology.IsEmbedding (fâ‚‚ i))","decl":"lemma Topology.isEmbedding_sigmaMap {fâ‚ : Î¹ â†’ Îº} {fâ‚‚ : âˆ€ i, Ïƒ i â†’ Ï„ (fâ‚ i)}\n    (h : Injective fâ‚) : IsEmbedding (Sigma.map fâ‚ fâ‚‚) â†” âˆ€ i, IsEmbedding (fâ‚‚ i) := by\n  simp only [isEmbedding_iff, Injective.sigma_map, isInducing_sigmaMap h, forall_and,\n    h.sigma_map_iff]\n\n"}
{"name":"embedding_sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÎº : Type u_6\nÏƒ : Î¹ â†’ Type u_7\nÏ„ : Îº â†’ Type u_8\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : (k : Îº) â†’ TopologicalSpace (Ï„ k)\nfâ‚ : Î¹ â†’ Îº\nfâ‚‚ : (i : Î¹) â†’ Ïƒ i â†’ Ï„ (fâ‚ i)\nh : Function.Injective fâ‚\nâŠ¢ Iff (Topology.IsEmbedding (Sigma.map fâ‚ fâ‚‚)) (âˆ€ (i : Î¹), Topology.IsEmbedding (fâ‚‚ i))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_sigma_map := isEmbedding_sigmaMap\n\n"}
{"name":"Topology.isOpenEmbedding_sigmaMap","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÎº : Type u_6\nÏƒ : Î¹ â†’ Type u_7\nÏ„ : Îº â†’ Type u_8\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : (k : Îº) â†’ TopologicalSpace (Ï„ k)\nfâ‚ : Î¹ â†’ Îº\nfâ‚‚ : (i : Î¹) â†’ Ïƒ i â†’ Ï„ (fâ‚ i)\nh : Function.Injective fâ‚\nâŠ¢ Iff (Topology.IsOpenEmbedding (Sigma.map fâ‚ fâ‚‚)) (âˆ€ (i : Î¹), Topology.IsOpenEmbedding (fâ‚‚ i))","decl":"lemma Topology.isOpenEmbedding_sigmaMap {fâ‚ : Î¹ â†’ Îº} {fâ‚‚ : âˆ€ i, Ïƒ i â†’ Ï„ (fâ‚ i)} (h : Injective fâ‚) :\n    IsOpenEmbedding (Sigma.map fâ‚ fâ‚‚) â†” âˆ€ i, IsOpenEmbedding (fâ‚‚ i) := by\n  simp only [isOpenEmbedding_iff_isEmbedding_isOpenMap, isOpenMap_sigma_map, isEmbedding_sigmaMap h,\n    forall_and]\n\n"}
{"name":"isOpenEmbedding_sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÎº : Type u_6\nÏƒ : Î¹ â†’ Type u_7\nÏ„ : Îº â†’ Type u_8\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : (k : Îº) â†’ TopologicalSpace (Ï„ k)\nfâ‚ : Î¹ â†’ Îº\nfâ‚‚ : (i : Î¹) â†’ Ïƒ i â†’ Ï„ (fâ‚ i)\nh : Function.Injective fâ‚\nâŠ¢ Iff (Topology.IsOpenEmbedding (Sigma.map fâ‚ fâ‚‚)) (âˆ€ (i : Î¹), Topology.IsOpenEmbedding (fâ‚‚ i))","decl":"@[deprecated (since := \"2024-10-30\")] alias isOpenEmbedding_sigma_map := isOpenEmbedding_sigmaMap\n\n"}
{"name":"openEmbedding_sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"Î¹ : Type u_5\nÎº : Type u_6\nÏƒ : Î¹ â†’ Type u_7\nÏ„ : Îº â†’ Type u_8\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ïƒ i)\ninstâœ : (k : Îº) â†’ TopologicalSpace (Ï„ k)\nfâ‚ : Î¹ â†’ Îº\nfâ‚‚ : (i : Î¹) â†’ Ïƒ i â†’ Ï„ (fâ‚ i)\nh : Function.Injective fâ‚\nâŠ¢ Iff (Topology.IsOpenEmbedding (Sigma.map fâ‚ fâ‚‚)) (âˆ€ (i : Î¹), Topology.IsOpenEmbedding (fâ‚‚ i))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_sigma_map := isOpenEmbedding_sigmaMap\n\n"}
{"name":"ULift.isOpen_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set (ULift.{v, u} X)\nâŠ¢ Iff (IsOpen s) (IsOpen (Set.preimage ULift.up s))","decl":"theorem ULift.isOpen_iff [TopologicalSpace X] {s : Set (ULift.{v} X)} :\n    IsOpen s â†” IsOpen (ULift.up â»Â¹' s) := by\n  rw [ULift.topologicalSpace, â† Equiv.ulift_apply, â† Equiv.ulift.coinduced_symm, â† isOpen_coinduced]\n\n"}
{"name":"ULift.isClosed_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set (ULift.{v, u} X)\nâŠ¢ Iff (IsClosed s) (IsClosed (Set.preimage ULift.up s))","decl":"theorem ULift.isClosed_iff [TopologicalSpace X] {s : Set (ULift.{v} X)} :\n    IsClosed s â†” IsClosed (ULift.up â»Â¹' s) := by\n  rw [â† isOpen_compl_iff, â† isOpen_compl_iff, isOpen_iff, preimage_compl]\n\n"}
{"name":"continuous_uLift_down","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Continuous ULift.down","decl":"@[continuity]\ntheorem continuous_uLift_down [TopologicalSpace X] : Continuous (ULift.down : ULift.{v, u} X â†’ X) :=\n  continuous_induced_dom\n\n"}
{"name":"continuous_uLift_up","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Continuous ULift.up","decl":"@[continuity]\ntheorem continuous_uLift_up [TopologicalSpace X] : Continuous (ULift.up : X â†’ ULift.{v, u} X) :=\n  continuous_induced_rng.2 continuous_id\n\n"}
{"name":"Topology.IsEmbedding.uliftDown","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Topology.IsEmbedding ULift.down","decl":"lemma Topology.IsEmbedding.uliftDown [TopologicalSpace X] :\n    IsEmbedding (ULift.down : ULift.{v, u} X â†’ X) := âŸ¨âŸ¨rflâŸ©, ULift.down_injectiveâŸ©\n\n"}
{"name":"embedding_uLift_down","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Topology.IsEmbedding ULift.down","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_uLift_down := IsEmbedding.uliftDown\n\n"}
{"name":"Topology.IsClosedEmbedding.uliftDown","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Topology.IsClosedEmbedding ULift.down","decl":"lemma Topology.IsClosedEmbedding.uliftDown [TopologicalSpace X] :\n    IsClosedEmbedding (ULift.down : ULift.{v, u} X â†’ X) :=\n  âŸ¨.uliftDown, by simp only [ULift.down_surjective.range_eq, isClosed_univ]âŸ©\n\n"}
{"name":"ULift.isClosedEmbedding_down","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Topology.IsClosedEmbedding ULift.down","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ULift.isClosedEmbedding_down := IsClosedEmbedding.uliftDown\n\n"}
{"name":"ULift.closedEmbedding_down","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\nâŠ¢ Topology.IsClosedEmbedding ULift.down","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ULift.closedEmbedding_down := IsClosedEmbedding.uliftDown\n\n"}
{"name":"instDiscreteTopologyULift","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : DiscreteTopology X\nâŠ¢ DiscreteTopology (ULift.{u_5, u} X)","decl":"instance [TopologicalSpace X] [DiscreteTopology X] : DiscreteTopology (ULift X) :=\n  IsEmbedding.uliftDown.discreteTopology\n\n"}
{"name":"IsOpen.trans","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nt : Set â†‘s\nht : IsOpen t\nhs : IsOpen s\nâŠ¢ IsOpen (Set.image Subtype.val t)","decl":"theorem IsOpen.trans (ht : IsOpen t) (hs : IsOpen s) : IsOpen (t : Set X) := by\n  rcases isOpen_induced_iff.mp ht with âŸ¨s', hs', rflâŸ©\n  rw [Subtype.image_preimage_coe]\n  exact hs.inter hs'\n\n"}
{"name":"IsClosed.trans","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninstâœ : TopologicalSpace X\ns : Set X\nt : Set â†‘s\nht : IsClosed t\nhs : IsClosed s\nâŠ¢ IsClosed (Set.image Subtype.val t)","decl":"theorem IsClosed.trans (ht : IsClosed t) (hs : IsClosed s) : IsClosed (t : Set X) := by\n  rcases isClosed_induced_iff.mp ht with âŸ¨s', hs', rflâŸ©\n  rw [Subtype.image_preimage_coe]\n  exact hs.inter hs'\n\n"}
{"name":"nhdsSet_prod_le","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nt : Set Y\nâŠ¢ LE.le (nhdsSet (SProd.sprod s t)) (SProd.sprod (nhdsSet s) (nhdsSet t))","decl":"/-- The product of a neighborhood of `s` and a neighborhood of `t` is a neighborhood of `s Ã—Ë¢ t`,\nformulated in terms of a filter inequality. -/\ntheorem nhdsSet_prod_le (s : Set X) (t : Set Y) : ğ“Ë¢ (s Ã—Ë¢ t) â‰¤ ğ“Ë¢ s Ã—Ë¢ ğ“Ë¢ t :=\n  ((hasBasis_nhdsSet _).prod (hasBasis_nhdsSet _)).ge_iff.2 fun (_u, _v) âŸ¨âŸ¨huo, hsuâŸ©, hvo, htvâŸ© â†¦\n    (huo.prod hvo).mem_nhdsSet.2 <| prod_mono hsu htv\n\n"}
{"name":"Filter.eventually_nhdsSet_prod_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nt : Set Y\np : Prod X Y â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun q => p q) (nhdsSet (SProd.sprod s t))) (âˆ€ (x : X), Membership.mem s x â†’ âˆ€ (y : Y), Membership.mem t y â†’ Exists fun px => And (Filter.Eventually (fun x' => px x') (nhds x)) (Exists fun py => And (Filter.Eventually (fun y' => py y') (nhds y)) (âˆ€ {x : X}, px x â†’ âˆ€ {y : Y}, py y â†’ p { fst := x, snd := y })))","decl":"theorem Filter.eventually_nhdsSet_prod_iff {p : X Ã— Y â†’ Prop} :\n    (âˆ€á¶  q in ğ“Ë¢ (s Ã—Ë¢ t), p q) â†”\n      âˆ€ x âˆˆ s, âˆ€ y âˆˆ t,\n          âˆƒ px : X â†’ Prop, (âˆ€á¶  x' in ğ“ x, px x') âˆ§ âˆƒ py : Y â†’ Prop, (âˆ€á¶  y' in ğ“ y, py y') âˆ§\n            âˆ€ {x : X}, px x â†’ âˆ€ {y : Y}, py y â†’ p (x, y) := by\n  simp_rw [eventually_nhdsSet_iff_forall, forall_prod_set, nhds_prod_eq, eventually_prod_iff]\n\n"}
{"name":"Filter.Eventually.prod_nhdsSet","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ns : Set X\nt : Set Y\np : Prod X Y â†’ Prop\npx : X â†’ Prop\npy : Y â†’ Prop\nhp : âˆ€ {x : X}, px x â†’ âˆ€ {y : Y}, py y â†’ p { fst := x, snd := y }\nhs : Filter.Eventually (fun x => px x) (nhdsSet s)\nht : Filter.Eventually (fun y => py y) (nhdsSet t)\nâŠ¢ Filter.Eventually (fun q => p q) (nhdsSet (SProd.sprod s t))","decl":"theorem Filter.Eventually.prod_nhdsSet {p : X Ã— Y â†’ Prop} {px : X â†’ Prop} {py : Y â†’ Prop}\n    (hp : âˆ€ {x : X}, px x â†’ âˆ€ {y : Y}, py y â†’ p (x, y)) (hs : âˆ€á¶  x in ğ“Ë¢ s, px x)\n    (ht : âˆ€á¶  y in ğ“Ë¢ t, py y) : âˆ€á¶  q in ğ“Ë¢ (s Ã—Ë¢ t), p q :=\n  nhdsSet_prod_le _ _ (mem_of_superset (prod_mem_prod hs ht) fun _ âŸ¨hx, hyâŸ© â†¦ hp hx hy)\n\n"}
