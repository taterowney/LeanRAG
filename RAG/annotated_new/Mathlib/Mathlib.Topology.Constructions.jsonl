{"name":"instDiscreteTopologyAdditive","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\n⊢ DiscreteTopology (Additive X)","decl":"instance [DiscreteTopology X] : DiscreteTopology (Additive X) := ‹DiscreteTopology X›\n"}
{"name":"instDiscreteTopologyMultiplicative","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\n⊢ DiscreteTopology (Multiplicative X)","decl":"instance [DiscreteTopology X] : DiscreteTopology (Multiplicative X) := ‹DiscreteTopology X›\n\n"}
{"name":"continuous_ofMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Continuous ⇑Additive.ofMul","decl":"theorem continuous_ofMul : Continuous (ofMul : X → Additive X) := continuous_id\n\n"}
{"name":"continuous_toMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Continuous ⇑Additive.toMul","decl":"theorem continuous_toMul : Continuous (toMul : Additive X → X) := continuous_id\n\n"}
{"name":"continuous_ofAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Continuous ⇑Multiplicative.ofAdd","decl":"theorem continuous_ofAdd : Continuous (ofAdd : X → Multiplicative X) := continuous_id\n\n"}
{"name":"continuous_toAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Continuous ⇑Multiplicative.toAdd","decl":"theorem continuous_toAdd : Continuous (toAdd : Multiplicative X → X) := continuous_id\n\n"}
{"name":"isOpenMap_ofMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsOpenMap ⇑Additive.ofMul","decl":"theorem isOpenMap_ofMul : IsOpenMap (ofMul : X → Additive X) := IsOpenMap.id\n\n"}
{"name":"isOpenMap_toMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsOpenMap ⇑Additive.toMul","decl":"theorem isOpenMap_toMul : IsOpenMap (toMul : Additive X → X) := IsOpenMap.id\n\n"}
{"name":"isOpenMap_ofAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsOpenMap ⇑Multiplicative.ofAdd","decl":"theorem isOpenMap_ofAdd : IsOpenMap (ofAdd : X → Multiplicative X) := IsOpenMap.id\n\n"}
{"name":"isOpenMap_toAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsOpenMap ⇑Multiplicative.toAdd","decl":"theorem isOpenMap_toAdd : IsOpenMap (toAdd : Multiplicative X → X) := IsOpenMap.id\n\n"}
{"name":"isClosedMap_ofMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsClosedMap ⇑Additive.ofMul","decl":"theorem isClosedMap_ofMul : IsClosedMap (ofMul : X → Additive X) := IsClosedMap.id\n\n"}
{"name":"isClosedMap_toMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsClosedMap ⇑Additive.toMul","decl":"theorem isClosedMap_toMul : IsClosedMap (toMul : Additive X → X) := IsClosedMap.id\n\n"}
{"name":"isClosedMap_ofAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsClosedMap ⇑Multiplicative.ofAdd","decl":"theorem isClosedMap_ofAdd : IsClosedMap (ofAdd : X → Multiplicative X) := IsClosedMap.id\n\n"}
{"name":"isClosedMap_toAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsClosedMap ⇑Multiplicative.toAdd","decl":"theorem isClosedMap_toAdd : IsClosedMap (toAdd : Multiplicative X → X) := IsClosedMap.id\n\n"}
{"name":"nhds_ofMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (nhds (Additive.ofMul x)) (Filter.map (⇑Additive.ofMul) (nhds x))","decl":"theorem nhds_ofMul (x : X) : 𝓝 (ofMul x) = map ofMul (𝓝 x) := rfl\n\n"}
{"name":"nhds_ofAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (nhds (Multiplicative.ofAdd x)) (Filter.map (⇑Multiplicative.ofAdd) (nhds x))","decl":"theorem nhds_ofAdd (x : X) : 𝓝 (ofAdd x) = map ofAdd (𝓝 x) := rfl\n\n"}
{"name":"nhds_toMul","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : Additive X\n⊢ Eq (nhds (Additive.toMul x)) (Filter.map (⇑Additive.toMul) (nhds x))","decl":"theorem nhds_toMul (x : Additive X) : 𝓝 x.toMul = map toMul (𝓝 x) := rfl\n\n"}
{"name":"nhds_toAdd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : Multiplicative X\n⊢ Eq (nhds (Multiplicative.toAdd x)) (Filter.map (⇑Multiplicative.toAdd) (nhds x))","decl":"theorem nhds_toAdd (x : Multiplicative X) : 𝓝 x.toAdd = map toAdd (𝓝 x) := rfl\n\n"}
{"name":"OrderDual.instDiscreteTopology","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\n⊢ DiscreteTopology (OrderDual X)","decl":"instance OrderDual.instDiscreteTopology [DiscreteTopology X] : DiscreteTopology Xᵒᵈ := ‹_›\n\n"}
{"name":"continuous_toDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Continuous ⇑OrderDual.toDual","decl":"theorem continuous_toDual : Continuous (toDual : X → Xᵒᵈ) := continuous_id\n\n"}
{"name":"continuous_ofDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Continuous ⇑OrderDual.ofDual","decl":"theorem continuous_ofDual : Continuous (ofDual : Xᵒᵈ → X) := continuous_id\n\n"}
{"name":"isOpenMap_toDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsOpenMap ⇑OrderDual.toDual","decl":"theorem isOpenMap_toDual : IsOpenMap (toDual : X → Xᵒᵈ) := IsOpenMap.id\n\n"}
{"name":"isOpenMap_ofDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsOpenMap ⇑OrderDual.ofDual","decl":"theorem isOpenMap_ofDual : IsOpenMap (ofDual : Xᵒᵈ → X) := IsOpenMap.id\n\n"}
{"name":"isClosedMap_toDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsClosedMap ⇑OrderDual.toDual","decl":"theorem isClosedMap_toDual : IsClosedMap (toDual : X → Xᵒᵈ) := IsClosedMap.id\n\n"}
{"name":"isClosedMap_ofDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsClosedMap ⇑OrderDual.ofDual","decl":"theorem isClosedMap_ofDual : IsClosedMap (ofDual : Xᵒᵈ → X) := IsClosedMap.id\n\n"}
{"name":"nhds_toDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (nhds (OrderDual.toDual x)) (Filter.map (⇑OrderDual.toDual) (nhds x))","decl":"theorem nhds_toDual (x : X) : 𝓝 (toDual x) = map toDual (𝓝 x) := rfl\n\n"}
{"name":"nhds_ofDual","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx : X\n⊢ Eq (nhds (OrderDual.ofDual x)) (Filter.map (⇑OrderDual.ofDual) (nhds x))","decl":"theorem nhds_ofDual (x : X) : 𝓝 (ofDual x) = map ofDual (𝓝 x) := rfl\n\n"}
{"name":"OrderDual.instNeBotNhdsWithinIoi","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝² : TopologicalSpace X\ninst✝¹ : Preorder X\nx : X\ninst✝ : (nhdsWithin x (Set.Iio x)).NeBot\n⊢ (nhdsWithin (OrderDual.toDual x) (Set.Ioi (OrderDual.toDual x))).NeBot","decl":"instance OrderDual.instNeBotNhdsWithinIoi [(𝓝[<] x).NeBot] : (𝓝[>] toDual x).NeBot := ‹_›\n"}
{"name":"OrderDual.instNeBotNhdsWithinIio","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝² : TopologicalSpace X\ninst✝¹ : Preorder X\nx : X\ninst✝ : (nhdsWithin x (Set.Ioi x)).NeBot\n⊢ (nhdsWithin (OrderDual.toDual x) (Set.Iio (OrderDual.toDual x))).NeBot","decl":"instance OrderDual.instNeBotNhdsWithinIio [(𝓝[>] x).NeBot] : (𝓝[<] toDual x).NeBot := ‹_›\n\n"}
{"name":"Quotient.preimage_mem_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Setoid X\nV : Set (Quotient s)\nx : X\nhs : Membership.mem (nhds (Quotient.mk' x)) V\n⊢ Membership.mem (nhds x) (Set.preimage Quotient.mk' V)","decl":"theorem Quotient.preimage_mem_nhds [TopologicalSpace X] [s : Setoid X] {V : Set <| Quotient s}\n    {x : X} (hs : V ∈ 𝓝 (Quotient.mk' x)) : Quotient.mk' ⁻¹' V ∈ 𝓝 x :=\n  preimage_nhds_coinduced hs\n\n"}
{"name":"Dense.quotient","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝¹ : Setoid X\ninst✝ : TopologicalSpace X\ns : Set X\nH : Dense s\n⊢ Dense (Set.image Quotient.mk' s)","decl":"/-- The image of a dense set under `Quotient.mk'` is a dense set. -/\ntheorem Dense.quotient [Setoid X] [TopologicalSpace X] {s : Set X} (H : Dense s) :\n    Dense (Quotient.mk' '' s) :=\n  Quotient.mk''_surjective.denseRange.dense_image continuous_coinduced_rng H\n\n"}
{"name":"DenseRange.quotient","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : Setoid X\ninst✝ : TopologicalSpace X\nf : Y → X\nhf : DenseRange f\n⊢ DenseRange (Function.comp Quotient.mk' f)","decl":"/-- The composition of `Quotient.mk'` and a function with dense range has dense range. -/\ntheorem DenseRange.quotient [Setoid X] [TopologicalSpace X] {f : Y → X} (hf : DenseRange f) :\n    DenseRange (Quotient.mk' ∘ f) :=\n  Quotient.mk''_surjective.denseRange.comp hf continuous_coinduced_rng\n\n"}
{"name":"continuous_map_of_le","module":"Mathlib.Topology.Constructions","initialProofState":"α : Type u_5\ninst✝ : TopologicalSpace α\ns t : Setoid α\nh : LE.le s t\n⊢ Continuous (Setoid.map_of_le h)","decl":"theorem continuous_map_of_le {α : Type*} [TopologicalSpace α]\n    {s t : Setoid α} (h : s ≤ t) : Continuous (Setoid.map_of_le h) :=\n  continuous_coinduced_rng\n\n"}
{"name":"continuous_map_sInf","module":"Mathlib.Topology.Constructions","initialProofState":"α : Type u_5\ninst✝ : TopologicalSpace α\nS : Set (Setoid α)\ns : Setoid α\nh : Membership.mem S s\n⊢ Continuous (Setoid.map_sInf h)","decl":"theorem continuous_map_sInf {α : Type*} [TopologicalSpace α]\n    {S : Set (Setoid α)} {s : Setoid α} (h : s ∈ S) : Continuous (Setoid.map_sInf h) :=\n  continuous_coinduced_rng\n\n"}
{"name":"instDiscreteTopologySubtype","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\np : X → Prop\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\n⊢ DiscreteTopology (Subtype p)","decl":"instance {p : X → Prop} [TopologicalSpace X] [DiscreteTopology X] : DiscreteTopology (Subtype p) :=\n  ⟨bot_unique fun s _ => ⟨(↑) '' s, isOpen_discrete _, preimage_image_eq _ Subtype.val_injective⟩⟩\n\n"}
{"name":"Sum.discreteTopology","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nh : DiscreteTopology X\nhY : DiscreteTopology Y\n⊢ DiscreteTopology (Sum X Y)","decl":"instance Sum.discreteTopology [TopologicalSpace X] [TopologicalSpace Y] [h : DiscreteTopology X]\n    [hY : DiscreteTopology Y] : DiscreteTopology (X ⊕ Y) :=\n  ⟨sup_eq_bot_iff.2 <| by simp [h.eq_bot, hY.eq_bot]⟩\n\n"}
{"name":"Sigma.discreteTopology","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nY : ι → Type v\ninst✝ : (i : ι) → TopologicalSpace (Y i)\nh : ∀ (i : ι), DiscreteTopology (Y i)\n⊢ DiscreteTopology (Sigma Y)","decl":"instance Sigma.discreteTopology {ι : Type*} {Y : ι → Type v} [∀ i, TopologicalSpace (Y i)]\n    [h : ∀ i, DiscreteTopology (Y i)] : DiscreteTopology (Sigma Y) :=\n  ⟨iSup_eq_bot.2 fun _ => by simp only [(h _).eq_bot, coinduced_bot]⟩\n\n"}
{"name":"comap_nhdsWithin_range","module":"Mathlib.Topology.Constructions","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝ : TopologicalSpace β\nf : α → β\ny : β\n⊢ Eq (Filter.comap f (nhdsWithin y (Set.range f))) (Filter.comap f (nhds y))","decl":"@[simp] lemma comap_nhdsWithin_range {α β} [TopologicalSpace β] (f : α → β) (y : β) :\n    comap f (𝓝[range f] y) = comap f (𝓝 y) := comap_inf_principal_range\n\n"}
{"name":"mem_nhds_subtype","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nx : Subtype fun x => Membership.mem s x\nt : Set (Subtype fun x => Membership.mem s x)\n⊢ Iff (Membership.mem (nhds x) t) (Exists fun u => And (Membership.mem (nhds ↑x) u) (HasSubset.Subset (Set.preimage Subtype.val u) t))","decl":"theorem mem_nhds_subtype (s : Set X) (x : { x // x ∈ s }) (t : Set { x // x ∈ s }) :\n    t ∈ 𝓝 x ↔ ∃ u ∈ 𝓝 (x : X), Subtype.val ⁻¹' u ⊆ t :=\n  mem_nhds_induced _ x t\n\n"}
{"name":"nhds_subtype","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (nhds x) (Filter.comap Subtype.val (nhds ↑x))","decl":"theorem nhds_subtype (s : Set X) (x : { x // x ∈ s }) : 𝓝 x = comap (↑) (𝓝 (x : X)) :=\n  nhds_induced _ x\n\n"}
{"name":"nhds_subtype_eq_comap_nhdsWithin","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (nhds x) (Filter.comap Subtype.val (nhdsWithin (↑x) s))","decl":"lemma nhds_subtype_eq_comap_nhdsWithin (s : Set X) (x : { x // x ∈ s }) :\n    𝓝 x = comap (↑) (𝓝[s] (x : X)) := by\n  rw [nhds_subtype, ← comap_nhdsWithin_range, Subtype.range_val]\n\n"}
{"name":"nhdsWithin_subtype_eq_bot_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nx : ↑s\n⊢ Iff (Eq (nhdsWithin x (Set.preimage Subtype.val t)) Bot.bot) (Eq (Min.min (nhdsWithin (↑x) t) (Filter.principal s)) Bot.bot)","decl":"theorem nhdsWithin_subtype_eq_bot_iff {s t : Set X} {x : s} :\n    𝓝[((↑) : s → X) ⁻¹' t] x = ⊥ ↔ 𝓝[t] (x : X) ⊓ 𝓟 s = ⊥ := by\n  rw [inf_principal_eq_bot_iff_comap, nhdsWithin, nhdsWithin, comap_inf, comap_principal,\n    nhds_induced]\n\n"}
{"name":"nhds_ne_subtype_eq_bot_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nS : Set X\nx : ↑S\n⊢ Iff (Eq (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) Bot.bot) (Eq (Min.min (nhdsWithin (↑x) (HasCompl.compl (Singleton.singleton ↑x))) (Filter.principal S)) Bot.bot)","decl":"theorem nhds_ne_subtype_eq_bot_iff {S : Set X} {x : S} :\n    𝓝[≠] x = ⊥ ↔ 𝓝[≠] (x : X) ⊓ 𝓟 S = ⊥ := by\n  rw [← nhdsWithin_subtype_eq_bot_iff, preimage_compl, ← image_singleton,\n    Subtype.coe_injective.preimage_image]\n\n"}
{"name":"nhds_ne_subtype_neBot_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nS : Set X\nx : ↑S\n⊢ Iff (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot (Min.min (nhdsWithin (↑x) (HasCompl.compl (Singleton.singleton ↑x))) (Filter.principal S)).NeBot","decl":"theorem nhds_ne_subtype_neBot_iff {S : Set X} {x : S} :\n    (𝓝[≠] x).NeBot ↔ (𝓝[≠] (x : X) ⊓ 𝓟 S).NeBot := by\n  rw [neBot_iff, neBot_iff, not_iff_not, nhds_ne_subtype_eq_bot_iff]\n\n"}
{"name":"discreteTopology_subtype_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nS : Set X\n⊢ Iff (DiscreteTopology ↑S) (∀ (x : X), Membership.mem S x → Eq (Min.min (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) (Filter.principal S)) Bot.bot)","decl":"theorem discreteTopology_subtype_iff {S : Set X} :\n    DiscreteTopology S ↔ ∀ x ∈ S, 𝓝[≠] x ⊓ 𝓟 S = ⊥ := by\n  simp_rw [discreteTopology_iff_nhds_ne, SetCoe.forall', nhds_ne_subtype_eq_bot_iff]\n\n"}
{"name":"CofiniteTopology.isOpen_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ns : Set (CofiniteTopology X)\n⊢ Iff (IsOpen s) (s.Nonempty → (HasCompl.compl s).Finite)","decl":"theorem isOpen_iff {s : Set (CofiniteTopology X)} : IsOpen s ↔ s.Nonempty → sᶜ.Finite :=\n  Iff.rfl\n\n"}
{"name":"CofiniteTopology.isOpen_iff'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ns : Set (CofiniteTopology X)\n⊢ Iff (IsOpen s) (Or (Eq s EmptyCollection.emptyCollection) (HasCompl.compl s).Finite)","decl":"theorem isOpen_iff' {s : Set (CofiniteTopology X)} : IsOpen s ↔ s = ∅ ∨ sᶜ.Finite := by\n  simp only [isOpen_iff, nonempty_iff_ne_empty, or_iff_not_imp_left]\n\n"}
{"name":"CofiniteTopology.isClosed_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ns : Set (CofiniteTopology X)\n⊢ Iff (IsClosed s) (Or (Eq s Set.univ) s.Finite)","decl":"theorem isClosed_iff {s : Set (CofiniteTopology X)} : IsClosed s ↔ s = univ ∨ s.Finite := by\n  simp only [← isOpen_compl_iff, isOpen_iff', compl_compl, compl_empty_iff]\n\n"}
{"name":"CofiniteTopology.nhds_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nx : CofiniteTopology X\n⊢ Eq (nhds x) (Max.max (Pure.pure x) Filter.cofinite)","decl":"theorem nhds_eq (x : CofiniteTopology X) : 𝓝 x = pure x ⊔ cofinite := by\n  ext U\n  rw [mem_nhds_iff]\n  constructor\n  · rintro ⟨V, hVU, V_op, haV⟩\n    exact mem_sup.mpr ⟨hVU haV, mem_of_superset (V_op ⟨_, haV⟩) hVU⟩\n  · rintro ⟨hU : x ∈ U, hU' : Uᶜ.Finite⟩\n    exact ⟨U, Subset.rfl, fun _ => hU', hU⟩\n\n"}
{"name":"CofiniteTopology.mem_nhds_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nx : CofiniteTopology X\ns : Set (CofiniteTopology X)\n⊢ Iff (Membership.mem (nhds x) s) (And (Membership.mem s x) (HasCompl.compl s).Finite)","decl":"theorem mem_nhds_iff {x : CofiniteTopology X} {s : Set (CofiniteTopology X)} :\n    s ∈ 𝓝 x ↔ x ∈ s ∧ sᶜ.Finite := by simp [nhds_eq]\n\n"}
{"name":"continuous_prod_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y\ng : X → Z\n⊢ Iff (Continuous fun x => { fst := f x, snd := g x }) (And (Continuous f) (Continuous g))","decl":"@[simp] theorem continuous_prod_mk {f : X → Y} {g : X → Z} :\n    (Continuous fun x => (f x, g x)) ↔ Continuous f ∧ Continuous g :=\n  (@continuous_inf_rng X (Y × Z) _ _ (TopologicalSpace.induced Prod.fst _)\n    (TopologicalSpace.induced Prod.snd _)).trans <|\n    continuous_induced_rng.and continuous_induced_rng\n\n"}
{"name":"continuous_fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Continuous Prod.fst","decl":"@[continuity]\ntheorem continuous_fst : Continuous (@Prod.fst X Y) :=\n  (continuous_prod_mk.1 continuous_id).1\n\n"}
{"name":"Continuous.fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Prod Y Z\nhf : Continuous f\n⊢ Continuous fun x => (f x).1","decl":"/-- Postcomposing `f` with `Prod.fst` is continuous -/\n@[fun_prop]\ntheorem Continuous.fst {f : X → Y × Z} (hf : Continuous f) : Continuous fun x : X => (f x).1 :=\n  continuous_fst.comp hf\n\n"}
{"name":"Continuous.fst'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Z\nhf : Continuous f\n⊢ Continuous fun x => f x.1","decl":"/-- Precomposing `f` with `Prod.fst` is continuous -/\ntheorem Continuous.fst' {f : X → Z} (hf : Continuous f) : Continuous fun x : X × Y => f x.fst :=\n  hf.comp continuous_fst\n\n"}
{"name":"continuousAt_fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\np : Prod X Y\n⊢ ContinuousAt Prod.fst p","decl":"theorem continuousAt_fst {p : X × Y} : ContinuousAt Prod.fst p :=\n  continuous_fst.continuousAt\n\n"}
{"name":"ContinuousAt.fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Prod Y Z\nx : X\nhf : ContinuousAt f x\n⊢ ContinuousAt (fun x => (f x).1) x","decl":"/-- Postcomposing `f` with `Prod.fst` is continuous at `x` -/\n@[fun_prop]\ntheorem ContinuousAt.fst {f : X → Y × Z} {x : X} (hf : ContinuousAt f x) :\n    ContinuousAt (fun x : X => (f x).1) x :=\n  continuousAt_fst.comp hf\n\n"}
{"name":"ContinuousAt.fst'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Z\nx : X\ny : Y\nhf : ContinuousAt f x\n⊢ ContinuousAt (fun x => f x.1) { fst := x, snd := y }","decl":"/-- Precomposing `f` with `Prod.fst` is continuous at `(x, y)` -/\ntheorem ContinuousAt.fst' {f : X → Z} {x : X} {y : Y} (hf : ContinuousAt f x) :\n    ContinuousAt (fun x : X × Y => f x.fst) (x, y) :=\n  ContinuousAt.comp hf continuousAt_fst\n\n"}
{"name":"ContinuousAt.fst''","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Z\nx : Prod X Y\nhf : ContinuousAt f x.1\n⊢ ContinuousAt (fun x => f x.1) x","decl":"/-- Precomposing `f` with `Prod.fst` is continuous at `x : X × Y` -/\ntheorem ContinuousAt.fst'' {f : X → Z} {x : X × Y} (hf : ContinuousAt f x.fst) :\n    ContinuousAt (fun x : X × Y => f x.fst) x :=\n  hf.comp continuousAt_fst\n\n"}
{"name":"Filter.Tendsto.fst_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nZ : Type u_1\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nX : Type u_5\nl : Filter X\nf : X → Prod Y Z\np : Prod Y Z\nh : Filter.Tendsto f l (nhds p)\n⊢ Filter.Tendsto (fun a => (f a).1) l (nhds p.1)","decl":"theorem Filter.Tendsto.fst_nhds {X} {l : Filter X} {f : X → Y × Z} {p : Y × Z}\n    (h : Tendsto f l (𝓝 p)) : Tendsto (fun a ↦ (f a).1) l (𝓝 <| p.1) :=\n  continuousAt_fst.tendsto.comp h\n\n"}
{"name":"continuous_snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Continuous Prod.snd","decl":"@[continuity]\ntheorem continuous_snd : Continuous (@Prod.snd X Y) :=\n  (continuous_prod_mk.1 continuous_id).2\n\n"}
{"name":"Continuous.snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Prod Y Z\nhf : Continuous f\n⊢ Continuous fun x => (f x).2","decl":"/-- Postcomposing `f` with `Prod.snd` is continuous -/\n@[fun_prop]\ntheorem Continuous.snd {f : X → Y × Z} (hf : Continuous f) : Continuous fun x : X => (f x).2 :=\n  continuous_snd.comp hf\n\n"}
{"name":"Continuous.snd'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : Y → Z\nhf : Continuous f\n⊢ Continuous fun x => f x.2","decl":"/-- Precomposing `f` with `Prod.snd` is continuous -/\ntheorem Continuous.snd' {f : Y → Z} (hf : Continuous f) : Continuous fun x : X × Y => f x.snd :=\n  hf.comp continuous_snd\n\n"}
{"name":"continuousAt_snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\np : Prod X Y\n⊢ ContinuousAt Prod.snd p","decl":"theorem continuousAt_snd {p : X × Y} : ContinuousAt Prod.snd p :=\n  continuous_snd.continuousAt\n\n"}
{"name":"ContinuousAt.snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Prod Y Z\nx : X\nhf : ContinuousAt f x\n⊢ ContinuousAt (fun x => (f x).2) x","decl":"/-- Postcomposing `f` with `Prod.snd` is continuous at `x` -/\n@[fun_prop]\ntheorem ContinuousAt.snd {f : X → Y × Z} {x : X} (hf : ContinuousAt f x) :\n    ContinuousAt (fun x : X => (f x).2) x :=\n  continuousAt_snd.comp hf\n\n"}
{"name":"ContinuousAt.snd'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : Y → Z\nx : X\ny : Y\nhf : ContinuousAt f y\n⊢ ContinuousAt (fun x => f x.2) { fst := x, snd := y }","decl":"/-- Precomposing `f` with `Prod.snd` is continuous at `(x, y)` -/\ntheorem ContinuousAt.snd' {f : Y → Z} {x : X} {y : Y} (hf : ContinuousAt f y) :\n    ContinuousAt (fun x : X × Y => f x.snd) (x, y) :=\n  ContinuousAt.comp hf continuousAt_snd\n\n"}
{"name":"ContinuousAt.snd''","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : Y → Z\nx : Prod X Y\nhf : ContinuousAt f x.2\n⊢ ContinuousAt (fun x => f x.2) x","decl":"/-- Precomposing `f` with `Prod.snd` is continuous at `x : X × Y` -/\ntheorem ContinuousAt.snd'' {f : Y → Z} {x : X × Y} (hf : ContinuousAt f x.snd) :\n    ContinuousAt (fun x : X × Y => f x.snd) x :=\n  hf.comp continuousAt_snd\n\n"}
{"name":"Filter.Tendsto.snd_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nZ : Type u_1\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nX : Type u_5\nl : Filter X\nf : X → Prod Y Z\np : Prod Y Z\nh : Filter.Tendsto f l (nhds p)\n⊢ Filter.Tendsto (fun a => (f a).2) l (nhds p.2)","decl":"theorem Filter.Tendsto.snd_nhds {X} {l : Filter X} {f : X → Y × Z} {p : Y × Z}\n    (h : Tendsto f l (𝓝 p)) : Tendsto (fun a ↦ (f a).2) l (𝓝 <| p.2) :=\n  continuousAt_snd.tendsto.comp h\n\n"}
{"name":"Continuous.prod_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : Z → X\ng : Z → Y\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun x => { fst := f x, snd := g x }","decl":"@[continuity, fun_prop]\ntheorem Continuous.prod_mk {f : Z → X} {g : Z → Y} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x => (f x, g x) :=\n  continuous_prod_mk.2 ⟨hf, hg⟩\n\n"}
{"name":"Continuous.Prod.mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\n⊢ Continuous fun y => { fst := x, snd := y }","decl":"@[continuity]\ntheorem Continuous.Prod.mk (x : X) : Continuous fun y : Y => (x, y) :=\n  continuous_const.prod_mk continuous_id\n\n"}
{"name":"Continuous.Prod.mk_left","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ny : Y\n⊢ Continuous fun x => { fst := x, snd := y }","decl":"@[continuity]\ntheorem Continuous.Prod.mk_left (y : Y) : Continuous fun x : X => (x, y) :=\n  continuous_id.prod_mk continuous_const\n\n"}
{"name":"IsClosed.setOf_mapsTo","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Z\nα : Type u_5\nf : X → α → Z\ns : Set α\nt : Set Z\nht : IsClosed t\nhf : ∀ (a : α), Membership.mem s a → Continuous fun x => f x a\n⊢ IsClosed (setOf fun x => Set.MapsTo (f x) s t)","decl":"/-- If `f x y` is continuous in `x` for all `y ∈ s`,\nthen the set of `x` such that `f x` maps `s` to `t` is closed. -/\nlemma IsClosed.setOf_mapsTo {α : Type*} {f : X → α → Z} {s : Set α} {t : Set Z} (ht : IsClosed t)\n    (hf : ∀ a ∈ s, Continuous (f · a)) : IsClosed {x | MapsTo (f x) s t} := by\n  simpa only [MapsTo, setOf_forall] using isClosed_biInter fun y hy ↦ ht.preimage (hf y hy)\n\n"}
{"name":"Continuous.comp₂","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\ng : Prod X Y → Z\nhg : Continuous g\ne : W → X\nhe : Continuous e\nf : W → Y\nhf : Continuous f\n⊢ Continuous fun w => g { fst := e w, snd := f w }","decl":"theorem Continuous.comp₂ {g : X × Y → Z} (hg : Continuous g) {e : W → X} (he : Continuous e)\n    {f : W → Y} (hf : Continuous f) : Continuous fun w => g (e w, f w) :=\n  hg.comp <| he.prod_mk hf\n\n"}
{"name":"Continuous.comp₃","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\nε : Type u_3\ninst✝⁴ : TopologicalSpace X\ninst✝³ : TopologicalSpace Y\ninst✝² : TopologicalSpace Z\ninst✝¹ : TopologicalSpace W\ninst✝ : TopologicalSpace ε\ng : Prod X (Prod Y Z) → ε\nhg : Continuous g\ne : W → X\nhe : Continuous e\nf : W → Y\nhf : Continuous f\nk : W → Z\nhk : Continuous k\n⊢ Continuous fun w => g { fst := e w, snd := { fst := f w, snd := k w } }","decl":"theorem Continuous.comp₃ {g : X × Y × Z → ε} (hg : Continuous g) {e : W → X} (he : Continuous e)\n    {f : W → Y} (hf : Continuous f) {k : W → Z} (hk : Continuous k) :\n    Continuous fun w => g (e w, f w, k w) :=\n  hg.comp₂ he <| hf.prod_mk hk\n\n"}
{"name":"Continuous.comp₄","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\nε : Type u_3\nζ : Type u_4\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace Y\ninst✝³ : TopologicalSpace Z\ninst✝² : TopologicalSpace W\ninst✝¹ : TopologicalSpace ε\ninst✝ : TopologicalSpace ζ\ng : Prod X (Prod Y (Prod Z ζ)) → ε\nhg : Continuous g\ne : W → X\nhe : Continuous e\nf : W → Y\nhf : Continuous f\nk : W → Z\nhk : Continuous k\nl : W → ζ\nhl : Continuous l\n⊢ Continuous fun w => g { fst := e w, snd := { fst := f w, snd := { fst := k w, snd := l w } } }","decl":"theorem Continuous.comp₄ {g : X × Y × Z × ζ → ε} (hg : Continuous g) {e : W → X} (he : Continuous e)\n    {f : W → Y} (hf : Continuous f) {k : W → Z} (hk : Continuous k) {l : W → ζ}\n    (hl : Continuous l) : Continuous fun w => g (e w, f w, k w, l w) :=\n  hg.comp₃ he hf <| hk.prod_mk hl\n\n"}
{"name":"Continuous.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : Z → X\ng : W → Y\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous (Prod.map f g)","decl":"@[continuity]\ntheorem Continuous.prodMap {f : Z → X} {g : W → Y} (hf : Continuous f) (hg : Continuous g) :\n    Continuous (Prod.map f g) :=\n  hf.fst'.prod_mk hg.snd'\n\n"}
{"name":"Continuous.prod_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : Z → X\ng : W → Y\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-05\")] alias Continuous.prod_map := Continuous.prodMap\n\n"}
{"name":"continuous_inf_dom_left₂","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X → Y → Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\n⊢ Continuous fun p => f p.1 p.2","decl":"/-- A version of `continuous_inf_dom_left` for binary functions -/\ntheorem continuous_inf_dom_left₂ {X Y Z} {f : X → Y → Z} {ta1 ta2 : TopologicalSpace X}\n    {tb1 tb2 : TopologicalSpace Y} {tc1 : TopologicalSpace Z}\n    (h : by haveI := ta1; haveI := tb1; exact Continuous fun p : X × Y => f p.1 p.2) : by\n    haveI := ta1 ⊓ ta2; haveI := tb1 ⊓ tb2; exact Continuous fun p : X × Y => f p.1 p.2 := by\n  have ha := @continuous_inf_dom_left _ _ id ta1 ta2 ta1 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_left _ _ id tb1 tb2 tb1 (@continuous_id _ (id _))\n  have h_continuous_id := @Continuous.prodMap _ _ _ _ ta1 tb1 (ta1 ⊓ ta2) (tb1 ⊓ tb2) _ _ ha hb\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n\n"}
{"name":"continuous_inf_dom_right₂","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X → Y → Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\n⊢ Continuous fun p => f p.1 p.2","decl":"/-- A version of `continuous_inf_dom_right` for binary functions -/\ntheorem continuous_inf_dom_right₂ {X Y Z} {f : X → Y → Z} {ta1 ta2 : TopologicalSpace X}\n    {tb1 tb2 : TopologicalSpace Y} {tc1 : TopologicalSpace Z}\n    (h : by haveI := ta2; haveI := tb2; exact Continuous fun p : X × Y => f p.1 p.2) : by\n    haveI := ta1 ⊓ ta2; haveI := tb1 ⊓ tb2; exact Continuous fun p : X × Y => f p.1 p.2 := by\n  have ha := @continuous_inf_dom_right _ _ id ta1 ta2 ta2 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_right _ _ id tb1 tb2 tb2 (@continuous_id _ (id _))\n  have h_continuous_id := @Continuous.prodMap _ _ _ _ ta2 tb2 (ta1 ⊓ ta2) (tb1 ⊓ tb2) _ _ ha hb\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n\n"}
{"name":"continuous_sInf_dom₂","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X → Y → Z\ntas : Set (TopologicalSpace X)\ntbs : Set (TopologicalSpace Y)\ntX : TopologicalSpace X\ntY : TopologicalSpace Y\ntc : TopologicalSpace Z\nhX : Membership.mem tas tX\nhY : Membership.mem tbs tY\nhf : Continuous fun p => f p.1 p.2\n⊢ Continuous fun p => f p.1 p.2","decl":"/-- A version of `continuous_sInf_dom` for binary functions -/\ntheorem continuous_sInf_dom₂ {X Y Z} {f : X → Y → Z} {tas : Set (TopologicalSpace X)}\n    {tbs : Set (TopologicalSpace Y)} {tX : TopologicalSpace X} {tY : TopologicalSpace Y}\n    {tc : TopologicalSpace Z} (hX : tX ∈ tas) (hY : tY ∈ tbs)\n    (hf : Continuous fun p : X × Y => f p.1 p.2) : by\n    haveI := sInf tas; haveI := sInf tbs\n    exact @Continuous _ _ _ tc fun p : X × Y => f p.1 p.2 := by\n  have hX := continuous_sInf_dom hX continuous_id\n  have hY := continuous_sInf_dom hY continuous_id\n  have h_continuous_id := @Continuous.prodMap _ _ _ _ tX tY (sInf tas) (sInf tbs) _ _ hX hY\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ hf h_continuous_id\n\n"}
{"name":"Filter.Eventually.prod_inl_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\np : X → Prop\nx : X\nh : Filter.Eventually (fun x => p x) (nhds x)\ny : Y\n⊢ Filter.Eventually (fun x => p x.1) (nhds { fst := x, snd := y })","decl":"theorem Filter.Eventually.prod_inl_nhds {p : X → Prop} {x : X} (h : ∀ᶠ x in 𝓝 x, p x) (y : Y) :\n    ∀ᶠ x in 𝓝 (x, y), p (x : X × Y).1 :=\n  continuousAt_fst h\n\n"}
{"name":"Filter.Eventually.prod_inr_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\np : Y → Prop\ny : Y\nh : Filter.Eventually (fun x => p x) (nhds y)\nx : X\n⊢ Filter.Eventually (fun x => p x.2) (nhds { fst := x, snd := y })","decl":"theorem Filter.Eventually.prod_inr_nhds {p : Y → Prop} {y : Y} (h : ∀ᶠ x in 𝓝 y, p x) (x : X) :\n    ∀ᶠ x in 𝓝 (x, y), p (x : X × Y).2 :=\n  continuousAt_snd h\n\n"}
{"name":"Filter.Eventually.prod_mk_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\npx : X → Prop\nx : X\nhx : Filter.Eventually (fun x => px x) (nhds x)\npy : Y → Prop\ny : Y\nhy : Filter.Eventually (fun y => py y) (nhds y)\n⊢ Filter.Eventually (fun p => And (px p.1) (py p.2)) (nhds { fst := x, snd := y })","decl":"theorem Filter.Eventually.prod_mk_nhds {px : X → Prop} {x} (hx : ∀ᶠ x in 𝓝 x, px x) {py : Y → Prop}\n    {y} (hy : ∀ᶠ y in 𝓝 y, py y) : ∀ᶠ p in 𝓝 (x, y), px (p : X × Y).1 ∧ py p.2 :=\n  (hx.prod_inl_nhds y).and (hy.prod_inr_nhds x)\n\n"}
{"name":"continuous_swap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Continuous Prod.swap","decl":"theorem continuous_swap : Continuous (Prod.swap : X × Y → Y × X) :=\n  continuous_snd.prod_mk continuous_fst\n\n"}
{"name":"isClosedMap_swap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ IsClosedMap Prod.swap","decl":"lemma isClosedMap_swap : IsClosedMap (Prod.swap : X × Y → Y × X) := fun s hs ↦ by\n  rw [image_swap_eq_preimage_swap]\n  exact hs.preimage continuous_swap\n\n"}
{"name":"Continuous.uncurry_left","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y → Z\nx : X\nh : Continuous (Function.uncurry f)\n⊢ Continuous (f x)","decl":"theorem Continuous.uncurry_left {f : X → Y → Z} (x : X) (h : Continuous (uncurry f)) :\n    Continuous (f x) :=\n  h.comp (Continuous.Prod.mk _)\n\n"}
{"name":"Continuous.uncurry_right","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y → Z\ny : Y\nh : Continuous (Function.uncurry f)\n⊢ Continuous fun a => f a y","decl":"theorem Continuous.uncurry_right {f : X → Y → Z} (y : Y) (h : Continuous (uncurry f)) :\n    Continuous fun a => f a y :=\n  h.comp (Continuous.Prod.mk_left _)\n\n\n"}
{"name":"continuous_curry","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\ng : Prod X Y → Z\nx : X\nh : Continuous g\n⊢ Continuous (Function.curry g x)","decl":"theorem continuous_curry {g : X × Y → Z} (x : X) (h : Continuous g) : Continuous (curry g x) :=\n  Continuous.uncurry_left x h\n\n"}
{"name":"IsOpen.prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\nhs : IsOpen s\nht : IsOpen t\n⊢ IsOpen (SProd.sprod s t)","decl":"theorem IsOpen.prod {s : Set X} {t : Set Y} (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s ×ˢ t) :=\n  (hs.preimage continuous_fst).inter (ht.preimage continuous_snd)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: Lean fails to find `t₁` and `t₂` by unification\n"}
{"name":"nhds_prod_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\ny : Y\n⊢ Eq (nhds { fst := x, snd := y }) (SProd.sprod (nhds x) (nhds y))","decl":"theorem nhds_prod_eq {x : X} {y : Y} : 𝓝 (x, y) = 𝓝 x ×ˢ 𝓝 y := by\n  rw [prod_eq_inf, instTopologicalSpaceProd, nhds_inf (t₁ := TopologicalSpace.induced Prod.fst _)\n    (t₂ := TopologicalSpace.induced Prod.snd _), nhds_induced, nhds_induced]\n\n"}
{"name":"nhdsWithin_prod_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\ny : Y\ns : Set X\nt : Set Y\n⊢ Eq (nhdsWithin { fst := x, snd := y } (SProd.sprod s t)) (SProd.sprod (nhdsWithin x s) (nhdsWithin y t))","decl":"theorem nhdsWithin_prod_eq (x : X) (y : Y) (s : Set X) (t : Set Y) :\n    𝓝[s ×ˢ t] (x, y) = 𝓝[s] x ×ˢ 𝓝[t] y := by\n  simp only [nhdsWithin, nhds_prod_eq, ← prod_inf_prod, prod_principal_principal]\n\n"}
{"name":"Prod.instNeBotNhdsWithinIio","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : Preorder X\ninst✝ : Preorder Y\nx : Prod X Y\nhx₁ : (nhdsWithin x.1 (Set.Iio x.1)).NeBot\nhx₂ : (nhdsWithin x.2 (Set.Iio x.2)).NeBot\n⊢ (nhdsWithin x (Set.Iio x)).NeBot","decl":"instance Prod.instNeBotNhdsWithinIio [Preorder X] [Preorder Y] {x : X × Y}\n    [hx₁ : (𝓝[<] x.1).NeBot] [hx₂ : (𝓝[<] x.2).NeBot] : (𝓝[<] x).NeBot := by\n  refine (hx₁.prod hx₂).mono ?_\n  rw [← nhdsWithin_prod_eq]\n  exact nhdsWithin_mono _ fun _ ⟨h₁, h₂⟩ ↦ Prod.lt_iff.2 <| .inl ⟨h₁, h₂.le⟩\n\n"}
{"name":"Prod.instNeBotNhdsWithinIoi","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace Y\ninst✝³ : Preorder X\ninst✝² : Preorder Y\nx : Prod X Y\ninst✝¹ : (nhdsWithin x.1 (Set.Ioi x.1)).NeBot\ninst✝ : (nhdsWithin x.2 (Set.Ioi x.2)).NeBot\n⊢ (nhdsWithin x (Set.Ioi x)).NeBot","decl":"instance Prod.instNeBotNhdsWithinIoi [Preorder X] [Preorder Y] {x : X × Y}\n    [(𝓝[>] x.1).NeBot] [(𝓝[>] x.2).NeBot] : (𝓝[>] x).NeBot :=\n  Prod.instNeBotNhdsWithinIio (X := Xᵒᵈ) (Y := Yᵒᵈ)\n    (x := (OrderDual.toDual x.1, OrderDual.toDual x.2))\n\n"}
{"name":"mem_nhds_prod_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\ny : Y\ns : Set (Prod X Y)\n⊢ Iff (Membership.mem (nhds { fst := x, snd := y }) s) (Exists fun u => And (Membership.mem (nhds x) u) (Exists fun v => And (Membership.mem (nhds y) v) (HasSubset.Subset (SProd.sprod u v) s)))","decl":"theorem mem_nhds_prod_iff {x : X} {y : Y} {s : Set (X × Y)} :\n    s ∈ 𝓝 (x, y) ↔ ∃ u ∈ 𝓝 x, ∃ v ∈ 𝓝 y, u ×ˢ v ⊆ s := by rw [nhds_prod_eq, mem_prod_iff]\n\n"}
{"name":"mem_nhdsWithin_prod_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\ny : Y\ns : Set (Prod X Y)\ntx : Set X\nty : Set Y\n⊢ Iff (Membership.mem (nhdsWithin { fst := x, snd := y } (SProd.sprod tx ty)) s) (Exists fun u => And (Membership.mem (nhdsWithin x tx) u) (Exists fun v => And (Membership.mem (nhdsWithin y ty) v) (HasSubset.Subset (SProd.sprod u v) s)))","decl":"theorem mem_nhdsWithin_prod_iff {x : X} {y : Y} {s : Set (X × Y)} {tx : Set X} {ty : Set Y} :\n    s ∈ 𝓝[tx ×ˢ ty] (x, y) ↔ ∃ u ∈ 𝓝[tx] x, ∃ v ∈ 𝓝[ty] y, u ×ˢ v ⊆ s := by\n  rw [nhdsWithin_prod_eq, mem_prod_iff]\n\n"}
{"name":"Filter.HasBasis.prod_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nιX : Type u_5\nιY : Type u_6\npx : ιX → Prop\npy : ιY → Prop\nsx : ιX → Set X\nsy : ιY → Set Y\nx : X\ny : Y\nhx : (nhds x).HasBasis px sx\nhy : (nhds y).HasBasis py sy\n⊢ (nhds { fst := x, snd := y }).HasBasis (fun i => And (px i.1) (py i.2)) fun i => SProd.sprod (sx i.1) (sy i.2)","decl":"theorem Filter.HasBasis.prod_nhds {ιX ιY : Type*} {px : ιX → Prop} {py : ιY → Prop}\n    {sx : ιX → Set X} {sy : ιY → Set Y} {x : X} {y : Y} (hx : (𝓝 x).HasBasis px sx)\n    (hy : (𝓝 y).HasBasis py sy) :\n    (𝓝 (x, y)).HasBasis (fun i : ιX × ιY => px i.1 ∧ py i.2) fun i => sx i.1 ×ˢ sy i.2 := by\n  rw [nhds_prod_eq]\n  exact hx.prod hy\n\n"}
{"name":"Filter.HasBasis.prod_nhds'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nιX : Type u_5\nιY : Type u_6\npX : ιX → Prop\npY : ιY → Prop\nsx : ιX → Set X\nsy : ιY → Set Y\np : Prod X Y\nhx : (nhds p.1).HasBasis pX sx\nhy : (nhds p.2).HasBasis pY sy\n⊢ (nhds p).HasBasis (fun i => And (pX i.1) (pY i.2)) fun i => SProd.sprod (sx i.1) (sy i.2)","decl":"theorem Filter.HasBasis.prod_nhds' {ιX ιY : Type*} {pX : ιX → Prop} {pY : ιY → Prop}\n    {sx : ιX → Set X} {sy : ιY → Set Y} {p : X × Y} (hx : (𝓝 p.1).HasBasis pX sx)\n    (hy : (𝓝 p.2).HasBasis pY sy) :\n    (𝓝 p).HasBasis (fun i : ιX × ιY => pX i.1 ∧ pY i.2) fun i => sx i.1 ×ˢ sy i.2 :=\n  hx.prod_nhds hy\n\n"}
{"name":"MapClusterPt.curry_prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nα : Type u_5\nβ : Type u_6\nf : α → X\ng : β → Y\nla : Filter α\nlb : Filter β\nx : X\ny : Y\nhf : MapClusterPt x la f\nhg : MapClusterPt y lb g\n⊢ MapClusterPt { fst := x, snd := y } (la.curry lb) (Prod.map f g)","decl":"theorem MapClusterPt.curry_prodMap {α β : Type*}\n    {f : α → X} {g : β → Y} {la : Filter α} {lb : Filter β} {x : X} {y : Y}\n    (hf : MapClusterPt x la f) (hg : MapClusterPt y lb g) :\n    MapClusterPt (x, y) (la.curry lb) (.map f g) := by\n  rw [mapClusterPt_iff] at hf hg\n  rw [((𝓝 x).basis_sets.prod_nhds (𝓝 y).basis_sets).mapClusterPt_iff_frequently]\n  rintro ⟨s, t⟩ ⟨hs, ht⟩\n  rw [frequently_curry_iff]\n  exact (hf s hs).mono fun x hx ↦ (hg t ht).mono fun y hy ↦ ⟨hx, hy⟩\n\n"}
{"name":"MapClusterPt.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nα : Type u_5\nβ : Type u_6\nf : α → X\ng : β → Y\nla : Filter α\nlb : Filter β\nx : X\ny : Y\nhf : MapClusterPt x la f\nhg : MapClusterPt y lb g\n⊢ MapClusterPt { fst := x, snd := y } (SProd.sprod la lb) (Prod.map f g)","decl":"theorem MapClusterPt.prodMap {α β : Type*}\n    {f : α → X} {g : β → Y} {la : Filter α} {lb : Filter β} {x : X} {y : Y}\n    (hf : MapClusterPt x la f) (hg : MapClusterPt y lb g) :\n    MapClusterPt (x, y) (la ×ˢ lb) (.map f g) :=\n  (hf.curry_prodMap hg).mono <| map_mono curry_le_prod\n\n"}
{"name":"mem_nhds_prod_iff'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\ny : Y\ns : Set (Prod X Y)\n⊢ Iff (Membership.mem (nhds { fst := x, snd := y }) s) (Exists fun u => Exists fun v => And (IsOpen u) (And (Membership.mem u x) (And (IsOpen v) (And (Membership.mem v y) (HasSubset.Subset (SProd.sprod u v) s)))))","decl":"theorem mem_nhds_prod_iff' {x : X} {y : Y} {s : Set (X × Y)} :\n    s ∈ 𝓝 (x, y) ↔ ∃ u v, IsOpen u ∧ x ∈ u ∧ IsOpen v ∧ y ∈ v ∧ u ×ˢ v ⊆ s :=\n  ((nhds_basis_opens x).prod_nhds (nhds_basis_opens y)).mem_iff.trans <| by\n    simp only [Prod.exists, and_comm, and_assoc, and_left_comm]\n\n"}
{"name":"Prod.tendsto_iff","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nZ : Type u_1\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nX : Type u_5\nseq : X → Prod Y Z\nf : Filter X\np : Prod Y Z\n⊢ Iff (Filter.Tendsto seq f (nhds p)) (And (Filter.Tendsto (fun n => (seq n).1) f (nhds p.1)) (Filter.Tendsto (fun n => (seq n).2) f (nhds p.2)))","decl":"theorem Prod.tendsto_iff {X} (seq : X → Y × Z) {f : Filter X} (p : Y × Z) :\n    Tendsto seq f (𝓝 p) ↔\n      Tendsto (fun n => (seq n).fst) f (𝓝 p.fst) ∧ Tendsto (fun n => (seq n).snd) f (𝓝 p.snd) := by\n  rw [nhds_prod_eq, Filter.tendsto_prod_iff']\n\n"}
{"name":"instDiscreteTopologyProd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : DiscreteTopology X\ninst✝ : DiscreteTopology Y\n⊢ DiscreteTopology (Prod X Y)","decl":"instance [DiscreteTopology X] [DiscreteTopology Y] : DiscreteTopology (X × Y) :=\n  discreteTopology_iff_nhds.2 fun (a, b) => by\n    rw [nhds_prod_eq, nhds_discrete X, nhds_discrete Y, prod_pure_pure]\n\n"}
{"name":"prod_mem_nhds_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\nx : X\ny : Y\n⊢ Iff (Membership.mem (nhds { fst := x, snd := y }) (SProd.sprod s t)) (And (Membership.mem (nhds x) s) (Membership.mem (nhds y) t))","decl":"theorem prod_mem_nhds_iff {s : Set X} {t : Set Y} {x : X} {y : Y} :\n    s ×ˢ t ∈ 𝓝 (x, y) ↔ s ∈ 𝓝 x ∧ t ∈ 𝓝 y := by rw [nhds_prod_eq, prod_mem_prod_iff]\n\n"}
{"name":"prod_mem_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\nx : X\ny : Y\nhx : Membership.mem (nhds x) s\nhy : Membership.mem (nhds y) t\n⊢ Membership.mem (nhds { fst := x, snd := y }) (SProd.sprod s t)","decl":"theorem prod_mem_nhds {s : Set X} {t : Set Y} {x : X} {y : Y} (hx : s ∈ 𝓝 x) (hy : t ∈ 𝓝 y) :\n    s ×ˢ t ∈ 𝓝 (x, y) :=\n  prod_mem_nhds_iff.2 ⟨hx, hy⟩\n\n"}
{"name":"isOpen_setOf_disjoint_nhds_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ IsOpen (setOf fun p => Disjoint (nhds p.1) (nhds p.2))","decl":"theorem isOpen_setOf_disjoint_nhds_nhds : IsOpen { p : X × X | Disjoint (𝓝 p.1) (𝓝 p.2) } := by\n  simp only [isOpen_iff_mem_nhds, Prod.forall, mem_setOf_eq]\n  intro x y h\n  obtain ⟨U, hU, V, hV, hd⟩ := ((nhds_basis_opens x).disjoint_iff (nhds_basis_opens y)).mp h\n  exact mem_nhds_prod_iff'.mpr ⟨U, V, hU.2, hU.1, hV.2, hV.1, fun ⟨x', y'⟩ ⟨hx', hy'⟩ =>\n    disjoint_of_disjoint_of_mem hd (hU.2.mem_nhds hx') (hV.2.mem_nhds hy')⟩\n\n"}
{"name":"Filter.Eventually.prod_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\np : X → Prop\nq : Y → Prop\nx : X\ny : Y\nhx : Filter.Eventually (fun x => p x) (nhds x)\nhy : Filter.Eventually (fun y => q y) (nhds y)\n⊢ Filter.Eventually (fun z => And (p z.1) (q z.2)) (nhds { fst := x, snd := y })","decl":"theorem Filter.Eventually.prod_nhds {p : X → Prop} {q : Y → Prop} {x : X} {y : Y}\n    (hx : ∀ᶠ x in 𝓝 x, p x) (hy : ∀ᶠ y in 𝓝 y, q y) : ∀ᶠ z : X × Y in 𝓝 (x, y), p z.1 ∧ q z.2 :=\n  prod_mem_nhds hx hy\n\n"}
{"name":"nhds_swap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\ny : Y\n⊢ Eq (nhds { fst := x, snd := y }) (Filter.map Prod.swap (nhds { fst := y, snd := x }))","decl":"theorem nhds_swap (x : X) (y : Y) : 𝓝 (x, y) = (𝓝 (y, x)).map Prod.swap := by\n  rw [nhds_prod_eq, Filter.prod_comm, nhds_prod_eq]; rfl\n\n"}
{"name":"Filter.Tendsto.prod_mk_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nγ : Type u_5\nx : X\ny : Y\nf : Filter γ\nmx : γ → X\nmy : γ → Y\nhx : Filter.Tendsto mx f (nhds x)\nhy : Filter.Tendsto my f (nhds y)\n⊢ Filter.Tendsto (fun c => { fst := mx c, snd := my c }) f (nhds { fst := x, snd := y })","decl":"theorem Filter.Tendsto.prod_mk_nhds {γ} {x : X} {y : Y} {f : Filter γ} {mx : γ → X} {my : γ → Y}\n    (hx : Tendsto mx f (𝓝 x)) (hy : Tendsto my f (𝓝 y)) :\n    Tendsto (fun c => (mx c, my c)) f (𝓝 (x, y)) := by\n  rw [nhds_prod_eq]; exact Filter.Tendsto.prod_mk hx hy\n\n"}
{"name":"Filter.Eventually.curry_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\np : Prod X Y → Prop\nx : X\ny : Y\nh : Filter.Eventually (fun x => p x) (nhds { fst := x, snd := y })\n⊢ Filter.Eventually (fun x' => Filter.Eventually (fun y' => p { fst := x', snd := y' }) (nhds y)) (nhds x)","decl":"theorem Filter.Eventually.curry_nhds {p : X × Y → Prop} {x : X} {y : Y}\n    (h : ∀ᶠ x in 𝓝 (x, y), p x) : ∀ᶠ x' in 𝓝 x, ∀ᶠ y' in 𝓝 y, p (x', y') := by\n  rw [nhds_prod_eq] at h\n  exact h.curry\n\n"}
{"name":"ContinuousAt.prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y\ng : X → Z\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\n⊢ ContinuousAt (fun x => { fst := f x, snd := g x }) x","decl":"@[fun_prop]\ntheorem ContinuousAt.prod {f : X → Y} {g : X → Z} {x : X} (hf : ContinuousAt f x)\n    (hg : ContinuousAt g x) : ContinuousAt (fun x => (f x, g x)) x :=\n  hf.prod_mk_nhds hg\n\n"}
{"name":"ContinuousAt.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Z\ng : Y → W\np : Prod X Y\nhf : ContinuousAt f p.1\nhg : ContinuousAt g p.2\n⊢ ContinuousAt (Prod.map f g) p","decl":"theorem ContinuousAt.prodMap {f : X → Z} {g : Y → W} {p : X × Y} (hf : ContinuousAt f p.fst)\n    (hg : ContinuousAt g p.snd) : ContinuousAt (Prod.map f g) p :=\n  hf.fst''.prod hg.snd''\n\n"}
{"name":"ContinuousAt.prod_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Z\ng : Y → W\np : Prod X Y\nhf : ContinuousAt f p.1\nhg : ContinuousAt g p.2\n⊢ ContinuousAt (Prod.map f g) p","decl":"@[deprecated (since := \"2024-10-05\")] alias ContinuousAt.prod_map := ContinuousAt.prodMap\n\n"}
{"name":"ContinuousAt.prodMap'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Z\ng : Y → W\nx : X\ny : Y\nhf : ContinuousAt f x\nhg : ContinuousAt g y\n⊢ ContinuousAt (Prod.map f g) { fst := x, snd := y }","decl":"/-- A version of `ContinuousAt.prodMap` that avoids `Prod.fst`/`Prod.snd`\nby assuming that the point is `(x, y)`. -/\ntheorem ContinuousAt.prodMap' {f : X → Z} {g : Y → W} {x : X} {y : Y} (hf : ContinuousAt f x)\n    (hg : ContinuousAt g y) : ContinuousAt (Prod.map f g) (x, y) :=\n  hf.prodMap hg\n\n"}
{"name":"ContinuousAt.prod_map'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Z\ng : Y → W\nx : X\ny : Y\nhf : ContinuousAt f x\nhg : ContinuousAt g y\n⊢ ContinuousAt (Prod.map f g) { fst := x, snd := y }","decl":"@[deprecated (since := \"2024-10-05\")] alias ContinuousAt.prod_map' := ContinuousAt.prodMap'\n\n"}
{"name":"ContinuousAt.comp₂","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : Prod Y Z → W\ng : X → Y\nh : X → Z\nx : X\nhf : ContinuousAt f { fst := g x, snd := h x }\nhg : ContinuousAt g x\nhh : ContinuousAt h x\n⊢ ContinuousAt (fun x => f { fst := g x, snd := h x }) x","decl":"theorem ContinuousAt.comp₂ {f : Y × Z → W} {g : X → Y} {h : X → Z} {x : X}\n    (hf : ContinuousAt f (g x, h x)) (hg : ContinuousAt g x) (hh : ContinuousAt h x) :\n    ContinuousAt (fun x ↦ f (g x, h x)) x :=\n  ContinuousAt.comp hf (hg.prod hh)\n\n"}
{"name":"ContinuousAt.comp₂_of_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : Prod Y Z → W\ng : X → Y\nh : X → Z\nx : X\ny : Prod Y Z\nhf : ContinuousAt f y\nhg : ContinuousAt g x\nhh : ContinuousAt h x\ne : Eq { fst := g x, snd := h x } y\n⊢ ContinuousAt (fun x => f { fst := g x, snd := h x }) x","decl":"theorem ContinuousAt.comp₂_of_eq {f : Y × Z → W} {g : X → Y} {h : X → Z} {x : X} {y : Y × Z}\n    (hf : ContinuousAt f y) (hg : ContinuousAt g x) (hh : ContinuousAt h x) (e : (g x, h x) = y) :\n    ContinuousAt (fun x ↦ f (g x, h x)) x := by\n  rw [← e] at hf\n  exact hf.comp₂ hg hh\n\n"}
{"name":"Continuous.curry_left","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : Prod X Y → Z\nhf : Continuous f\ny : Y\n⊢ Continuous fun x => f { fst := x, snd := y }","decl":"/-- Continuous functions on products are continuous in their first argument -/\ntheorem Continuous.curry_left {f : X × Y → Z} (hf : Continuous f) {y : Y} :\n    Continuous fun x ↦ f (x, y) :=\n  hf.comp (continuous_id.prod_mk continuous_const)\n"}
{"name":"Continuous.along_fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : Prod X Y → Z\nhf : Continuous f\ny : Y\n⊢ Continuous fun x => f { fst := x, snd := y }","decl":"alias Continuous.along_fst := Continuous.curry_left\n\n"}
{"name":"Continuous.curry_right","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : Prod X Y → Z\nhf : Continuous f\nx : X\n⊢ Continuous fun y => f { fst := x, snd := y }","decl":"/-- Continuous functions on products are continuous in their second argument -/\ntheorem Continuous.curry_right {f : X × Y → Z} (hf : Continuous f) {x : X} :\n    Continuous fun y ↦ f (x, y) :=\n  hf.comp (continuous_const.prod_mk continuous_id)\n"}
{"name":"Continuous.along_snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : Prod X Y → Z\nhf : Continuous f\nx : X\n⊢ Continuous fun y => f { fst := x, snd := y }","decl":"alias Continuous.along_snd := Continuous.curry_right\n\n-- todo: prove a version of `generateFrom_union` with `image2 (∩) s t` in the LHS and use it here\n"}
{"name":"prod_generateFrom_generateFrom_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u_5\nY : Type u_6\ns : Set (Set X)\nt : Set (Set Y)\nhs : Eq s.sUnion Set.univ\nht : Eq t.sUnion Set.univ\n⊢ Eq instTopologicalSpaceProd (TopologicalSpace.generateFrom (Set.image2 (fun x1 x2 => SProd.sprod x1 x2) s t))","decl":"theorem prod_generateFrom_generateFrom_eq {X Y : Type*} {s : Set (Set X)} {t : Set (Set Y)}\n    (hs : ⋃₀ s = univ) (ht : ⋃₀ t = univ) :\n    @instTopologicalSpaceProd X Y (generateFrom s) (generateFrom t) =\n      generateFrom (image2 (·  ×ˢ ·) s t) :=\n  let G := generateFrom (image2  (·  ×ˢ ·) s t)\n  le_antisymm\n    (le_generateFrom fun _ ⟨_, hu, _, hv, g_eq⟩ =>\n      g_eq.symm ▸\n        @IsOpen.prod _ _ (generateFrom s) (generateFrom t) _ _ (GenerateOpen.basic _ hu)\n          (GenerateOpen.basic _ hv))\n    (le_inf\n      (coinduced_le_iff_le_induced.mp <|\n        le_generateFrom fun u hu =>\n          have : ⋃ v ∈ t, u ×ˢ v = Prod.fst ⁻¹' u := by\n            simp_rw [← prod_iUnion, ← sUnion_eq_biUnion, ht, prod_univ]\n          show G.IsOpen (Prod.fst ⁻¹' u) by\n            rw [← this]\n            exact\n              isOpen_iUnion fun v =>\n                isOpen_iUnion fun hv => GenerateOpen.basic _ ⟨_, hu, _, hv, rfl⟩)\n      (coinduced_le_iff_le_induced.mp <|\n        le_generateFrom fun v hv =>\n          have : ⋃ u ∈ s, u ×ˢ v = Prod.snd ⁻¹' v := by\n            simp_rw [← iUnion_prod_const, ← sUnion_eq_biUnion, hs, univ_prod]\n          show G.IsOpen (Prod.snd ⁻¹' v) by\n            rw [← this]\n            exact\n              isOpen_iUnion fun u =>\n                isOpen_iUnion fun hu => GenerateOpen.basic _ ⟨_, hu, _, hv, rfl⟩))\n\n-- todo: use the previous lemma?\n"}
{"name":"prod_eq_generateFrom","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Eq instTopologicalSpaceProd (TopologicalSpace.generateFrom (setOf fun g => Exists fun s => Exists fun t => And (IsOpen s) (And (IsOpen t) (Eq g (SProd.sprod s t)))))","decl":"theorem prod_eq_generateFrom :\n    instTopologicalSpaceProd =\n      generateFrom { g | ∃ (s : Set X) (t : Set Y), IsOpen s ∧ IsOpen t ∧ g = s ×ˢ t } :=\n  le_antisymm (le_generateFrom fun _ ⟨_, _, hs, ht, g_eq⟩ => g_eq.symm ▸ hs.prod ht)\n    (le_inf\n      (forall_mem_image.2 fun t ht =>\n        GenerateOpen.basic _ ⟨t, univ, by simpa [Set.prod_eq] using ht⟩)\n      (forall_mem_image.2 fun t ht =>\n        GenerateOpen.basic _ ⟨univ, t, by simpa [Set.prod_eq] using ht⟩))\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: align with `mem_nhds_prod_iff'`\n"}
{"name":"isOpen_prod_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set (Prod X Y)\n⊢ Iff (IsOpen s) (∀ (a : X) (b : Y), Membership.mem s { fst := a, snd := b } → Exists fun u => Exists fun v => And (IsOpen u) (And (IsOpen v) (And (Membership.mem u a) (And (Membership.mem v b) (HasSubset.Subset (SProd.sprod u v) s)))))","decl":"theorem isOpen_prod_iff {s : Set (X × Y)} :\n    IsOpen s ↔ ∀ a b, (a, b) ∈ s →\n      ∃ u v, IsOpen u ∧ IsOpen v ∧ a ∈ u ∧ b ∈ v ∧ u ×ˢ v ⊆ s :=\n  isOpen_iff_mem_nhds.trans <| by simp_rw [Prod.forall, mem_nhds_prod_iff', and_left_comm]\n\n"}
{"name":"prod_induced_induced","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nW : Type u_2\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace W\nX : Type u_5\nZ : Type u_6\nf : X → Y\ng : Z → W\n⊢ Eq instTopologicalSpaceProd (TopologicalSpace.induced (fun p => { fst := f p.1, snd := g p.2 }) instTopologicalSpaceProd)","decl":"/-- A product of induced topologies is induced by the product map -/\ntheorem prod_induced_induced {X Z} (f : X → Y) (g : Z → W) :\n    @instTopologicalSpaceProd X Z (induced f ‹_›) (induced g ‹_›) =\n      induced (fun p => (f p.1, g p.2)) instTopologicalSpaceProd := by\n  delta instTopologicalSpaceProd\n  simp_rw [induced_inf, induced_compose]\n  rfl\n\n"}
{"name":"exists_nhds_square","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set (Prod X X)\nx : X\nhx : Membership.mem (nhds { fst := x, snd := x }) s\n⊢ Exists fun U => And (IsOpen U) (And (Membership.mem U x) (HasSubset.Subset (SProd.sprod U U) s))","decl":"/-- Given a neighborhood `s` of `(x, x)`, then `(x, x)` has a square open neighborhood\n  that is a subset of `s`. -/\ntheorem exists_nhds_square {s : Set (X × X)} {x : X} (hx : s ∈ 𝓝 (x, x)) :\n    ∃ U : Set X, IsOpen U ∧ x ∈ U ∧ U ×ˢ U ⊆ s := by\n  simpa [nhds_prod_eq, (nhds_basis_opens x).prod_self.mem_iff, and_assoc, and_left_comm] using hx\n\n"}
{"name":"map_fst_nhdsWithin","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : Prod X Y\n⊢ Eq (Filter.map Prod.fst (nhdsWithin x (Set.preimage Prod.snd (Singleton.singleton x.2)))) (nhds x.1)","decl":"/-- `Prod.fst` maps neighborhood of `x : X × Y` within the section `Prod.snd ⁻¹' {x.2}`\nto `𝓝 x.1`. -/\ntheorem map_fst_nhdsWithin (x : X × Y) : map Prod.fst (𝓝[Prod.snd ⁻¹' {x.2}] x) = 𝓝 x.1 := by\n  refine le_antisymm (continuousAt_fst.mono_left inf_le_left) fun s hs => ?_\n  rcases x with ⟨x, y⟩\n  rw [mem_map, nhdsWithin, mem_inf_principal, mem_nhds_prod_iff] at hs\n  rcases hs with ⟨u, hu, v, hv, H⟩\n  simp only [prod_subset_iff, mem_singleton_iff, mem_setOf_eq, mem_preimage] at H\n  exact mem_of_superset hu fun z hz => H _ hz _ (mem_of_mem_nhds hv) rfl\n\n"}
{"name":"map_fst_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : Prod X Y\n⊢ Eq (Filter.map Prod.fst (nhds x)) (nhds x.1)","decl":"@[simp]\ntheorem map_fst_nhds (x : X × Y) : map Prod.fst (𝓝 x) = 𝓝 x.1 :=\n  le_antisymm continuousAt_fst <| (map_fst_nhdsWithin x).symm.trans_le (map_mono inf_le_left)\n\n"}
{"name":"isOpenMap_fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ IsOpenMap Prod.fst","decl":"/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem isOpenMap_fst : IsOpenMap (@Prod.fst X Y) :=\n  isOpenMap_iff_nhds_le.2 fun x => (map_fst_nhds x).ge\n\n"}
{"name":"map_snd_nhdsWithin","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : Prod X Y\n⊢ Eq (Filter.map Prod.snd (nhdsWithin x (Set.preimage Prod.fst (Singleton.singleton x.1)))) (nhds x.2)","decl":"/-- `Prod.snd` maps neighborhood of `x : X × Y` within the section `Prod.fst ⁻¹' {x.1}`\nto `𝓝 x.2`. -/\ntheorem map_snd_nhdsWithin (x : X × Y) : map Prod.snd (𝓝[Prod.fst ⁻¹' {x.1}] x) = 𝓝 x.2 := by\n  refine le_antisymm (continuousAt_snd.mono_left inf_le_left) fun s hs => ?_\n  rcases x with ⟨x, y⟩\n  rw [mem_map, nhdsWithin, mem_inf_principal, mem_nhds_prod_iff] at hs\n  rcases hs with ⟨u, hu, v, hv, H⟩\n  simp only [prod_subset_iff, mem_singleton_iff, mem_setOf_eq, mem_preimage] at H\n  exact mem_of_superset hv fun z hz => H _ (mem_of_mem_nhds hu) _ hz rfl\n\n"}
{"name":"map_snd_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : Prod X Y\n⊢ Eq (Filter.map Prod.snd (nhds x)) (nhds x.2)","decl":"@[simp]\ntheorem map_snd_nhds (x : X × Y) : map Prod.snd (𝓝 x) = 𝓝 x.2 :=\n  le_antisymm continuousAt_snd <| (map_snd_nhdsWithin x).symm.trans_le (map_mono inf_le_left)\n\n"}
{"name":"isOpenMap_snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ IsOpenMap Prod.snd","decl":"/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem isOpenMap_snd : IsOpenMap (@Prod.snd X Y) :=\n  isOpenMap_iff_nhds_le.2 fun x => (map_snd_nhds x).ge\n\n"}
{"name":"isOpen_prod_iff'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\n⊢ Iff (IsOpen (SProd.sprod s t)) (Or (And (IsOpen s) (IsOpen t)) (Or (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection)))","decl":"/-- A product set is open in a product space if and only if each factor is open, or one of them is\nempty -/\ntheorem isOpen_prod_iff' {s : Set X} {t : Set Y} :\n    IsOpen (s ×ˢ t) ↔ IsOpen s ∧ IsOpen t ∨ s = ∅ ∨ t = ∅ := by\n  rcases (s ×ˢ t).eq_empty_or_nonempty with h | h\n  · simp [h, prod_eq_empty_iff.1 h]\n  · have st : s.Nonempty ∧ t.Nonempty := prod_nonempty_iff.1 h\n    constructor\n    · intro (H : IsOpen (s ×ˢ t))\n      refine Or.inl ⟨?_, ?_⟩\n      · simpa only [fst_image_prod _ st.2] using isOpenMap_fst _ H\n      · simpa only [snd_image_prod st.1 t] using isOpenMap_snd _ H\n    · intro H\n      simp only [st.1.ne_empty, st.2.ne_empty, not_false_iff, or_false] at H\n      exact H.1.prod H.2\n\n"}
{"name":"isQuotientMap_fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : Nonempty Y\n⊢ Topology.IsQuotientMap Prod.fst","decl":"theorem isQuotientMap_fst [Nonempty Y] : IsQuotientMap (Prod.fst : X × Y → X) :=\n  isOpenMap_fst.isQuotientMap continuous_fst Prod.fst_surjective\n\n"}
{"name":"quotientMap_fst","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : Nonempty Y\n⊢ Topology.IsQuotientMap Prod.fst","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_fst := isQuotientMap_fst\n\n"}
{"name":"isQuotientMap_snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : Nonempty X\n⊢ Topology.IsQuotientMap Prod.snd","decl":"theorem isQuotientMap_snd [Nonempty X] : IsQuotientMap (Prod.snd : X × Y → Y) :=\n  isOpenMap_snd.isQuotientMap continuous_snd Prod.snd_surjective\n\n"}
{"name":"quotientMap_snd","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : Nonempty X\n⊢ Topology.IsQuotientMap Prod.snd","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_snd := isQuotientMap_snd\n\n"}
{"name":"closure_prod_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\n⊢ Eq (closure (SProd.sprod s t)) (SProd.sprod (closure s) (closure t))","decl":"theorem closure_prod_eq {s : Set X} {t : Set Y} : closure (s ×ˢ t) = closure s ×ˢ closure t :=\n  ext fun ⟨a, b⟩ => by\n    simp_rw [mem_prod, mem_closure_iff_nhdsWithin_neBot, nhdsWithin_prod_eq, prod_neBot]\n\n"}
{"name":"interior_prod_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\n⊢ Eq (interior (SProd.sprod s t)) (SProd.sprod (interior s) (interior t))","decl":"theorem interior_prod_eq (s : Set X) (t : Set Y) : interior (s ×ˢ t) = interior s ×ˢ interior t :=\n  ext fun ⟨a, b⟩ => by simp only [mem_interior_iff_mem_nhds, mem_prod, prod_mem_nhds_iff]\n\n"}
{"name":"frontier_prod_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\n⊢ Eq (frontier (SProd.sprod s t)) (Union.union (SProd.sprod (closure s) (frontier t)) (SProd.sprod (frontier s) (closure t)))","decl":"theorem frontier_prod_eq (s : Set X) (t : Set Y) :\n    frontier (s ×ˢ t) = closure s ×ˢ frontier t ∪ frontier s ×ˢ closure t := by\n  simp only [frontier, closure_prod_eq, interior_prod_eq, prod_diff_prod]\n\n"}
{"name":"frontier_prod_univ_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\n⊢ Eq (frontier (SProd.sprod s Set.univ)) (SProd.sprod (frontier s) Set.univ)","decl":"@[simp]\ntheorem frontier_prod_univ_eq (s : Set X) :\n    frontier (s ×ˢ (univ : Set Y)) = frontier s ×ˢ univ := by\n  simp [frontier_prod_eq]\n\n"}
{"name":"frontier_univ_prod_eq","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set Y\n⊢ Eq (frontier (SProd.sprod Set.univ s)) (SProd.sprod Set.univ (frontier s))","decl":"@[simp]\ntheorem frontier_univ_prod_eq (s : Set Y) :\n    frontier ((univ : Set X) ×ˢ s) = univ ×ˢ frontier s := by\n  simp [frontier_prod_eq]\n\n"}
{"name":"map_mem_closure₂","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Y → Z\nx : X\ny : Y\ns : Set X\nt : Set Y\nu : Set Z\nhf : Continuous (Function.uncurry f)\nhx : Membership.mem (closure s) x\nhy : Membership.mem (closure t) y\nh : ∀ (a : X), Membership.mem s a → ∀ (b : Y), Membership.mem t b → Membership.mem u (f a b)\n⊢ Membership.mem (closure u) (f x y)","decl":"theorem map_mem_closure₂ {f : X → Y → Z} {x : X} {y : Y} {s : Set X} {t : Set Y} {u : Set Z}\n    (hf : Continuous (uncurry f)) (hx : x ∈ closure s) (hy : y ∈ closure t)\n    (h : ∀ a ∈ s, ∀ b ∈ t, f a b ∈ u) : f x y ∈ closure u :=\n  have H₁ : (x, y) ∈ closure (s ×ˢ t) := by simpa only [closure_prod_eq] using mk_mem_prod hx hy\n  have H₂ : MapsTo (uncurry f) (s ×ˢ t) u := forall_prod_set.2 h\n  H₂.closure hf H₁\n\n"}
{"name":"IsClosed.prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns₁ : Set X\ns₂ : Set Y\nh₁ : IsClosed s₁\nh₂ : IsClosed s₂\n⊢ IsClosed (SProd.sprod s₁ s₂)","decl":"theorem IsClosed.prod {s₁ : Set X} {s₂ : Set Y} (h₁ : IsClosed s₁) (h₂ : IsClosed s₂) :\n    IsClosed (s₁ ×ˢ s₂) :=\n  closure_eq_iff_isClosed.mp <| by simp only [h₁.closure_eq, h₂.closure_eq, closure_prod_eq]\n\n"}
{"name":"Dense.prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\nhs : Dense s\nht : Dense t\n⊢ Dense (SProd.sprod s t)","decl":"/-- The product of two dense sets is a dense set. -/\ntheorem Dense.prod {s : Set X} {t : Set Y} (hs : Dense s) (ht : Dense t) : Dense (s ×ˢ t) :=\n  fun x => by\n  rw [closure_prod_eq]\n  exact ⟨hs x.1, ht x.2⟩\n\n"}
{"name":"DenseRange.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nZ : Type u_1\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nι : Type u_5\nκ : Type u_6\nf : ι → Y\ng : κ → Z\nhf : DenseRange f\nhg : DenseRange g\n⊢ DenseRange (Prod.map f g)","decl":"/-- If `f` and `g` are maps with dense range, then `Prod.map f g` has dense range. -/\ntheorem DenseRange.prodMap {ι : Type*} {κ : Type*} {f : ι → Y} {g : κ → Z} (hf : DenseRange f)\n    (hg : DenseRange g) : DenseRange (Prod.map f g) := by\n  simpa only [DenseRange, prod_range_range_eq] using hf.prod hg\n\n"}
{"name":"DenseRange.prod_map","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nZ : Type u_1\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nι : Type u_5\nκ : Type u_6\nf : ι → Y\ng : κ → Z\nhf : DenseRange f\nhg : DenseRange g\n⊢ DenseRange (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-05\")] alias DenseRange.prod_map := DenseRange.prodMap\n\n"}
{"name":"Topology.IsInducing.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : Topology.IsInducing f\nhg : Topology.IsInducing g\n⊢ Topology.IsInducing (Prod.map f g)","decl":"lemma Topology.IsInducing.prodMap {f : X → Y} {g : Z → W} (hf : IsInducing f) (hg : IsInducing g) :\n    IsInducing (Prod.map f g) :=\n  isInducing_iff_nhds.2 fun (x, z) => by simp_rw [Prod.map_def, nhds_prod_eq, hf.nhds_eq_comap,\n    hg.nhds_eq_comap, prod_comap_comap_eq]\n\n"}
{"name":"Inducing.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : Topology.IsInducing f\nhg : Topology.IsInducing g\n⊢ Topology.IsInducing (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.prodMap := IsInducing.prodMap\n\n"}
{"name":"Inducing.prod_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : Topology.IsInducing f\nhg : Topology.IsInducing g\n⊢ Topology.IsInducing (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-05\")] alias Inducing.prod_map := IsInducing.prodMap\n\n"}
{"name":"Topology.isInducing_const_prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nx : X\nf : Y → Z\n⊢ Iff (Topology.IsInducing fun x' => { fst := x, snd := f x' }) (Topology.IsInducing f)","decl":"@[simp]\nlemma Topology.isInducing_const_prod {x : X} {f : Y → Z} :\n    IsInducing (fun x' => (x, f x')) ↔ IsInducing f := by\n  simp_rw [isInducing_iff, instTopologicalSpaceProd, induced_inf, induced_compose,\n    Function.comp_def, induced_const, top_inf_eq]\n\n"}
{"name":"inducing_const_prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nx : X\nf : Y → Z\n⊢ Iff (Topology.IsInducing fun x' => { fst := x, snd := f x' }) (Topology.IsInducing f)","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_const_prod := isInducing_const_prod\n\n"}
{"name":"Topology.isInducing_prod_const","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\ny : Y\nf : X → Z\n⊢ Iff (Topology.IsInducing fun x => { fst := f x, snd := y }) (Topology.IsInducing f)","decl":"@[simp]\nlemma Topology.isInducing_prod_const {y : Y} {f : X → Z} :\n    IsInducing (fun x => (f x, y)) ↔ IsInducing f := by\n  simp_rw [isInducing_iff, instTopologicalSpaceProd, induced_inf, induced_compose,\n    Function.comp_def, induced_const, inf_top_eq]\n\n"}
{"name":"inducing_prod_const","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\ny : Y\nf : X → Z\n⊢ Iff (Topology.IsInducing fun x => { fst := f x, snd := y }) (Topology.IsInducing f)","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_prod_const := isInducing_prod_const\n\n"}
{"name":"Topology.IsEmbedding.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : Topology.IsEmbedding f\nhg : Topology.IsEmbedding g\n⊢ Topology.IsEmbedding (Prod.map f g)","decl":"lemma Topology.IsEmbedding.prodMap {f : X → Y} {g : Z → W} (hf : IsEmbedding f)\n    (hg : IsEmbedding g) : IsEmbedding (Prod.map f g) where\n  toIsInducing := hf.isInducing.prodMap hg.isInducing\n  injective := hf.injective.prodMap hg.injective\n\n"}
{"name":"Embedding.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : Topology.IsEmbedding f\nhg : Topology.IsEmbedding g\n⊢ Topology.IsEmbedding (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-08\")] alias Embedding.prodMap := Topology.IsEmbedding.prodMap\n"}
{"name":"Embedding.prod_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : Topology.IsEmbedding f\nhg : Topology.IsEmbedding g\n⊢ Topology.IsEmbedding (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-05\")] alias Embedding.prod_map := Topology.IsEmbedding.prodMap\n\n"}
{"name":"IsOpenMap.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : IsOpenMap f\nhg : IsOpenMap g\n⊢ IsOpenMap (Prod.map f g)","decl":"protected theorem IsOpenMap.prodMap {f : X → Y} {g : Z → W} (hf : IsOpenMap f) (hg : IsOpenMap g) :\n    IsOpenMap (Prod.map f g) := by\n  rw [isOpenMap_iff_nhds_le]\n  rintro ⟨a, b⟩\n  rw [nhds_prod_eq, nhds_prod_eq, ← Filter.prod_map_map_eq']\n  exact Filter.prod_mono (hf.nhds_le a) (hg.nhds_le b)\n\n"}
{"name":"IsOpenMap.prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : IsOpenMap f\nhg : IsOpenMap g\n⊢ IsOpenMap (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-05\")] alias IsOpenMap.prod := IsOpenMap.prodMap\n\n"}
{"name":"Topology.IsOpenEmbedding.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : Topology.IsOpenEmbedding f\nhg : Topology.IsOpenEmbedding g\n⊢ Topology.IsOpenEmbedding (Prod.map f g)","decl":"protected lemma Topology.IsOpenEmbedding.prodMap {f : X → Y} {g : Z → W} (hf : IsOpenEmbedding f)\n    (hg : IsOpenEmbedding g) : IsOpenEmbedding (Prod.map f g) :=\n  .of_isEmbedding_isOpenMap (hf.1.prodMap hg.1) (hf.isOpenMap.prodMap hg.isOpenMap)\n\n"}
{"name":"OpenEmbedding.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : Topology.IsOpenEmbedding f\nhg : Topology.IsOpenEmbedding g\n⊢ Topology.IsOpenEmbedding (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.prodMap := IsOpenEmbedding.prodMap\n\n"}
{"name":"IsOpenEmbedding.prod","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : Topology.IsOpenEmbedding f\nhg : Topology.IsOpenEmbedding g\n⊢ Topology.IsOpenEmbedding (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-05\")] alias IsOpenEmbedding.prod := IsOpenEmbedding.prodMap\n\n"}
{"name":"isEmbedding_graph","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\n⊢ Topology.IsEmbedding fun x => { fst := x, snd := f x }","decl":"lemma isEmbedding_graph {f : X → Y} (hf : Continuous f) : IsEmbedding fun x => (x, f x) :=\n  .of_comp (continuous_id.prod_mk hf) continuous_fst .id\n\n"}
{"name":"embedding_graph","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Continuous f\n⊢ Topology.IsEmbedding fun x => { fst := x, snd := f x }","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_graph := isEmbedding_graph\n\n"}
{"name":"isEmbedding_prodMk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\n⊢ Topology.IsEmbedding (Prod.mk x)","decl":"lemma isEmbedding_prodMk (x : X) : IsEmbedding (Prod.mk x : Y → X × Y) :=\n  .of_comp (Continuous.Prod.mk x) continuous_snd .id\n\n"}
{"name":"embedding_prod_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\n⊢ Topology.IsEmbedding (Prod.mk x)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_prod_mk := isEmbedding_prodMk\n\n"}
{"name":"IsOpenQuotientMap.prodMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : IsOpenQuotientMap f\nhg : IsOpenQuotientMap g\n⊢ IsOpenQuotientMap (Prod.map f g)","decl":"theorem IsOpenQuotientMap.prodMap {f : X → Y} {g : Z → W} (hf : IsOpenQuotientMap f)\n    (hg : IsOpenQuotientMap g) : IsOpenQuotientMap (Prod.map f g) :=\n  ⟨.prodMap hf.1 hg.1, .prodMap hf.2 hg.2, .prodMap hf.3 hg.3⟩\n\n"}
{"name":"continuous_bool_rng","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nf : X → Bool\nb : Bool\n⊢ Iff (Continuous f) (IsClopen (Set.preimage f (Singleton.singleton b)))","decl":"lemma continuous_bool_rng [TopologicalSpace X] {f : X → Bool} (b : Bool) :\n    Continuous f ↔ IsClopen (f ⁻¹' {b}) := by\n  rw [continuous_discrete_rng, Bool.forall_bool' b, IsClopen, ← isOpen_compl_iff, ← preimage_compl,\n    Bool.compl_singleton, and_comm]\n\n"}
{"name":"continuous_sum_dom","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : Sum X Y → Z\n⊢ Iff (Continuous f) (And (Continuous (Function.comp f Sum.inl)) (Continuous (Function.comp f Sum.inr)))","decl":"theorem continuous_sum_dom {f : X ⊕ Y → Z} :\n    Continuous f ↔ Continuous (f ∘ Sum.inl) ∧ Continuous (f ∘ Sum.inr) :=\n  (continuous_sup_dom (t₁ := TopologicalSpace.coinduced Sum.inl _)\n    (t₂ := TopologicalSpace.coinduced Sum.inr _)).trans <|\n    continuous_coinduced_dom.and continuous_coinduced_dom\n\n"}
{"name":"continuous_sum_elim","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Z\ng : Y → Z\n⊢ Iff (Continuous (Sum.elim f g)) (And (Continuous f) (Continuous g))","decl":"theorem continuous_sum_elim {f : X → Z} {g : Y → Z} :\n    Continuous (Sum.elim f g) ↔ Continuous f ∧ Continuous g :=\n  continuous_sum_dom\n\n"}
{"name":"Continuous.sum_elim","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Z\ng : Y → Z\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous (Sum.elim f g)","decl":"@[continuity, fun_prop]\ntheorem Continuous.sum_elim {f : X → Z} {g : Y → Z} (hf : Continuous f) (hg : Continuous g) :\n    Continuous (Sum.elim f g) :=\n  continuous_sum_elim.2 ⟨hf, hg⟩\n\n"}
{"name":"continuous_isLeft","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Continuous Sum.isLeft","decl":"@[continuity, fun_prop]\ntheorem continuous_isLeft : Continuous (isLeft : X ⊕ Y → Bool) :=\n  continuous_sum_dom.2 ⟨continuous_const, continuous_const⟩\n\n"}
{"name":"continuous_isRight","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Continuous Sum.isRight","decl":"@[continuity, fun_prop]\ntheorem continuous_isRight : Continuous (isRight : X ⊕ Y → Bool) :=\n  continuous_sum_dom.2 ⟨continuous_const, continuous_const⟩\n\n"}
{"name":"continuous_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Continuous Sum.inl","decl":"@[continuity, fun_prop]\ntheorem continuous_inl : Continuous (@inl X Y) := ⟨fun _ => And.left⟩\n\n"}
{"name":"continuous_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Continuous Sum.inr","decl":"@[continuity, fun_prop]\ntheorem continuous_inr : Continuous (@inr X Y) := ⟨fun _ => And.right⟩\n\n"}
{"name":"continuous_sum_swap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Continuous Sum.swap","decl":"@[fun_prop, continuity]\nlemma continuous_sum_swap : Continuous (@Sum.swap X Y) :=\n  Continuous.sum_elim continuous_inr continuous_inl\n\n"}
{"name":"isOpen_sum_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set (Sum X Y)\n⊢ Iff (IsOpen s) (And (IsOpen (Set.preimage Sum.inl s)) (IsOpen (Set.preimage Sum.inr s)))","decl":"theorem isOpen_sum_iff {s : Set (X ⊕ Y)} : IsOpen s ↔ IsOpen (inl ⁻¹' s) ∧ IsOpen (inr ⁻¹' s) :=\n  Iff.rfl\n\n"}
{"name":"isClosed_sum_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set (Sum X Y)\n⊢ Iff (IsClosed s) (And (IsClosed (Set.preimage Sum.inl s)) (IsClosed (Set.preimage Sum.inr s)))","decl":"theorem isClosed_sum_iff {s : Set (X ⊕ Y)} :\n    IsClosed s ↔ IsClosed (inl ⁻¹' s) ∧ IsClosed (inr ⁻¹' s) := by\n  simp only [← isOpen_compl_iff, isOpen_sum_iff, preimage_compl]\n\n"}
{"name":"isOpenMap_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ IsOpenMap Sum.inl","decl":"theorem isOpenMap_inl : IsOpenMap (@inl X Y) := fun u hu => by\n  simpa [isOpen_sum_iff, preimage_image_eq u Sum.inl_injective]\n\n"}
{"name":"isOpenMap_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ IsOpenMap Sum.inr","decl":"theorem isOpenMap_inr : IsOpenMap (@inr X Y) := fun u hu => by\n  simpa [isOpen_sum_iff, preimage_image_eq u Sum.inr_injective]\n\n"}
{"name":"Topology.IsOpenEmbedding.inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsOpenEmbedding Sum.inl","decl":"protected lemma Topology.IsOpenEmbedding.inl : IsOpenEmbedding (@inl X Y) :=\n  .of_continuous_injective_isOpenMap continuous_inl inl_injective isOpenMap_inl\n\n"}
{"name":"isOpenEmbedding_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsOpenEmbedding Sum.inl","decl":"@[deprecated (since := \"2024-10-30\")] alias isOpenEmbedding_inl := IsOpenEmbedding.inl\n\n"}
{"name":"openEmbedding_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsOpenEmbedding Sum.inl","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_inl := IsOpenEmbedding.inl\n\n"}
{"name":"Topology.IsOpenEmbedding.inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsOpenEmbedding Sum.inr","decl":"protected lemma Topology.IsOpenEmbedding.inr : IsOpenEmbedding (@inr X Y) :=\n  .of_continuous_injective_isOpenMap continuous_inr inr_injective isOpenMap_inr\n\n"}
{"name":"isOpenEmbedding_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsOpenEmbedding Sum.inr","decl":"@[deprecated (since := \"2024-10-30\")] alias isOpenEmbedding_inr := IsOpenEmbedding.inr\n\n"}
{"name":"openEmbedding_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsOpenEmbedding Sum.inr","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_inr := IsOpenEmbedding.inr\n\n"}
{"name":"Topology.IsEmbedding.inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsEmbedding Sum.inl","decl":"protected lemma Topology.IsEmbedding.inl : IsEmbedding (@inl X Y) := IsOpenEmbedding.inl.1\n"}
{"name":"Topology.IsEmbedding.inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsEmbedding Sum.inr","decl":"protected lemma Topology.IsEmbedding.inr : IsEmbedding (@inr X Y) := IsOpenEmbedding.inr.1\n\n"}
{"name":"embedding_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsEmbedding Sum.inr","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_inr := IsEmbedding.inr\n\n"}
{"name":"isOpen_range_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ IsOpen (Set.range Sum.inl)","decl":"lemma isOpen_range_inl : IsOpen (range (inl : X → X ⊕ Y)) := IsOpenEmbedding.inl.2\n"}
{"name":"isOpen_range_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ IsOpen (Set.range Sum.inr)","decl":"lemma isOpen_range_inr : IsOpen (range (inr : Y → X ⊕ Y)) := IsOpenEmbedding.inr.2\n\n"}
{"name":"isClosed_range_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ IsClosed (Set.range Sum.inl)","decl":"theorem isClosed_range_inl : IsClosed (range (inl : X → X ⊕ Y)) := by\n  rw [← isOpen_compl_iff, compl_range_inl]\n  exact isOpen_range_inr\n\n"}
{"name":"isClosed_range_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ IsClosed (Set.range Sum.inr)","decl":"theorem isClosed_range_inr : IsClosed (range (inr : Y → X ⊕ Y)) := by\n  rw [← isOpen_compl_iff, compl_range_inr]\n  exact isOpen_range_inl\n\n"}
{"name":"Topology.IsClosedEmbedding.inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsClosedEmbedding Sum.inl","decl":"theorem Topology.IsClosedEmbedding.inl : IsClosedEmbedding (inl : X → X ⊕ Y) :=\n  ⟨.inl, isClosed_range_inl⟩\n\n"}
{"name":"isClosedEmbedding_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsClosedEmbedding Sum.inl","decl":"@[deprecated (since := \"2024-10-30\")] alias isClosedEmbedding_inl := IsClosedEmbedding.inl\n\n"}
{"name":"closedEmbedding_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsClosedEmbedding Sum.inl","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_inl := IsClosedEmbedding.inl\n\n"}
{"name":"Topology.IsClosedEmbedding.inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsClosedEmbedding Sum.inr","decl":"theorem Topology.IsClosedEmbedding.inr : IsClosedEmbedding (inr : Y → X ⊕ Y) :=\n  ⟨.inr, isClosed_range_inr⟩\n\n"}
{"name":"isClosedEmbedding_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsClosedEmbedding Sum.inr","decl":"@[deprecated (since := \"2024-10-30\")] alias isClosedEmbedding_inr := IsClosedEmbedding.inr\n\n"}
{"name":"closedEmbedding_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\n⊢ Topology.IsClosedEmbedding Sum.inr","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_inr := IsClosedEmbedding.inr\n\n"}
{"name":"nhds_inl","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nx : X\n⊢ Eq (nhds (Sum.inl x)) (Filter.map Sum.inl (nhds x))","decl":"theorem nhds_inl (x : X) : 𝓝 (inl x : X ⊕ Y) = map inl (𝓝 x) :=\n  (IsOpenEmbedding.inl.map_nhds_eq _).symm\n\n"}
{"name":"nhds_inr","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ny : Y\n⊢ Eq (nhds (Sum.inr y)) (Filter.map Sum.inr (nhds y))","decl":"theorem nhds_inr (y : Y) : 𝓝 (inr y : X ⊕ Y) = map inr (𝓝 y) :=\n  (IsOpenEmbedding.inr.map_nhds_eq _).symm\n\n"}
{"name":"continuous_sum_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\n⊢ Iff (Continuous (Sum.map f g)) (And (Continuous f) (Continuous g))","decl":"@[simp]\ntheorem continuous_sum_map {f : X → Y} {g : Z → W} :\n    Continuous (Sum.map f g) ↔ Continuous f ∧ Continuous g :=\n  continuous_sum_elim.trans <|\n    IsEmbedding.inl.continuous_iff.symm.and IsEmbedding.inr.continuous_iff.symm\n\n"}
{"name":"Continuous.sum_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous (Sum.map f g)","decl":"@[continuity, fun_prop]\ntheorem Continuous.sum_map {f : X → Y} {g : Z → W} (hf : Continuous f) (hg : Continuous g) :\n    Continuous (Sum.map f g) :=\n  continuous_sum_map.2 ⟨hf, hg⟩\n\n"}
{"name":"isOpenMap_sum","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : Sum X Y → Z\n⊢ Iff (IsOpenMap f) (And (IsOpenMap fun a => f (Sum.inl a)) (IsOpenMap fun b => f (Sum.inr b)))","decl":"theorem isOpenMap_sum {f : X ⊕ Y → Z} :\n    IsOpenMap f ↔ (IsOpenMap fun a => f (inl a)) ∧ IsOpenMap fun b => f (inr b) := by\n  simp only [isOpenMap_iff_nhds_le, Sum.forall, nhds_inl, nhds_inr, Filter.map_map, comp_def]\n\n"}
{"name":"IsOpenMap.sumMap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : TopologicalSpace Z\ninst✝ : TopologicalSpace W\nf : X → Y\ng : Z → W\nhf : IsOpenMap f\nhg : IsOpenMap g\n⊢ IsOpenMap (Sum.map f g)","decl":"theorem IsOpenMap.sumMap {f : X → Y} {g : Z → W} (hf : IsOpenMap f) (hg : IsOpenMap g) :\n    IsOpenMap (Sum.map f g) := by\n  exact isOpenMap_sum.2 ⟨isOpenMap_inl.comp hf,isOpenMap_inr.comp hg⟩\n\n"}
{"name":"isOpenMap_sum_elim","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Z\ng : Y → Z\n⊢ Iff (IsOpenMap (Sum.elim f g)) (And (IsOpenMap f) (IsOpenMap g))","decl":"@[simp]\ntheorem isOpenMap_sum_elim {f : X → Z} {g : Y → Z} :\n    IsOpenMap (Sum.elim f g) ↔ IsOpenMap f ∧ IsOpenMap g := by\n  simp only [isOpenMap_sum, elim_inl, elim_inr]\n\n"}
{"name":"IsOpenMap.sum_elim","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : X → Z\ng : Y → Z\nhf : IsOpenMap f\nhg : IsOpenMap g\n⊢ IsOpenMap (Sum.elim f g)","decl":"theorem IsOpenMap.sum_elim {f : X → Z} {g : Y → Z} (hf : IsOpenMap f) (hg : IsOpenMap g) :\n    IsOpenMap (Sum.elim f g) :=\n  isOpenMap_sum_elim.2 ⟨hf, hg⟩\n\n"}
{"name":"isClosedMap_sum","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nZ : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ninst✝ : TopologicalSpace Z\nf : Sum X Y → Z\n⊢ Iff (IsClosedMap f) (And (IsClosedMap fun a => f (Sum.inl a)) (IsClosedMap fun b => f (Sum.inr b)))","decl":"theorem isClosedMap_sum {f : X ⊕ Y → Z} :\n    IsClosedMap f ↔ (IsClosedMap fun a => f (.inl a)) ∧ IsClosedMap fun b => f (.inr b) := by\n  constructor\n  · intro h\n    exact ⟨h.comp IsClosedEmbedding.inl.isClosedMap, h.comp IsClosedEmbedding.inr.isClosedMap⟩\n  · rintro h Z hZ\n    rw [isClosed_sum_iff] at hZ\n    convert (h.1 _ hZ.1).union (h.2 _ hZ.2)\n    ext\n    simp only [mem_image, Sum.exists, mem_union, mem_preimage]\n\n"}
{"name":"Topology.IsInducing.subtypeVal","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\ninst✝ : TopologicalSpace Y\nt : Set Y\n⊢ Topology.IsInducing Subtype.val","decl":"lemma Topology.IsInducing.subtypeVal {t : Set Y} : IsInducing ((↑) : t → Y) := ⟨rfl⟩\n\n"}
{"name":"inducing_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\ninst✝ : TopologicalSpace Y\nt : Set Y\n⊢ Topology.IsInducing Subtype.val","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_subtype_val := IsInducing.subtypeVal\n\n"}
{"name":"Topology.IsInducing.of_codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nt : Set Y\nht : ∀ (x : X), Membership.mem t (f x)\nh : Topology.IsInducing (Set.codRestrict f t ht)\n⊢ Topology.IsInducing f","decl":"lemma Topology.IsInducing.of_codRestrict {f : X → Y} {t : Set Y} (ht : ∀ x, f x ∈ t)\n    (h : IsInducing (t.codRestrict f ht)) : IsInducing f := subtypeVal.comp h\n\n"}
{"name":"Inducing.of_codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nt : Set Y\nht : ∀ (x : X), Membership.mem t (f x)\nh : Topology.IsInducing (Set.codRestrict f t ht)\n⊢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.of_codRestrict := IsInducing.of_codRestrict\n\n"}
{"name":"Topology.IsEmbedding.subtypeVal","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : X → Prop\n⊢ Topology.IsEmbedding Subtype.val","decl":"lemma Topology.IsEmbedding.subtypeVal : IsEmbedding ((↑) : Subtype p → X) :=\n  ⟨.subtypeVal, Subtype.coe_injective⟩\n\n"}
{"name":"embedding_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : X → Prop\n⊢ Topology.IsEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_subtype_val := IsEmbedding.subtypeVal\n\n"}
{"name":"Topology.IsClosedEmbedding.subtypeVal","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : X → Prop\nh : IsClosed (setOf fun a => p a)\n⊢ Topology.IsClosedEmbedding Subtype.val","decl":"theorem Topology.IsClosedEmbedding.subtypeVal (h : IsClosed {a | p a}) :\n    IsClosedEmbedding ((↑) : Subtype p → X) :=\n  ⟨.subtypeVal, by rwa [Subtype.range_coe_subtype]⟩\n\n"}
{"name":"closedEmbedding_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : X → Prop\nh : IsClosed (setOf fun a => p a)\n⊢ Topology.IsClosedEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_subtype_val := IsClosedEmbedding.subtypeVal\n\n"}
{"name":"continuous_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : X → Prop\n⊢ Continuous Subtype.val","decl":"@[continuity, fun_prop]\ntheorem continuous_subtype_val : Continuous (@Subtype.val X p) :=\n  continuous_induced_dom\n\n"}
{"name":"Continuous.subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\np : X → Prop\nf : Y → Subtype p\nhf : Continuous f\n⊢ Continuous fun x => ↑(f x)","decl":"theorem Continuous.subtype_val {f : Y → Subtype p} (hf : Continuous f) :\n    Continuous fun x => (f x : X) :=\n  continuous_subtype_val.comp hf\n\n"}
{"name":"IsOpen.isOpenEmbedding_subtypeVal","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsOpen s\n⊢ Topology.IsOpenEmbedding Subtype.val","decl":"theorem IsOpen.isOpenEmbedding_subtypeVal {s : Set X} (hs : IsOpen s) :\n    IsOpenEmbedding ((↑) : s → X) :=\n  ⟨.subtypeVal, (@Subtype.range_coe _ s).symm ▸ hs⟩\n\n"}
{"name":"IsOpen.openEmbedding_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsOpen s\n⊢ Topology.IsOpenEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-18\")]\nalias IsOpen.openEmbedding_subtype_val := IsOpen.isOpenEmbedding_subtypeVal\n\n"}
{"name":"IsOpen.isOpenMap_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsOpen s\n⊢ IsOpenMap Subtype.val","decl":"theorem IsOpen.isOpenMap_subtype_val {s : Set X} (hs : IsOpen s) : IsOpenMap ((↑) : s → X) :=\n  hs.isOpenEmbedding_subtypeVal.isOpenMap\n\n"}
{"name":"IsOpenMap.restrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : IsOpenMap f\ns : Set X\nhs : IsOpen s\n⊢ IsOpenMap (s.restrict f)","decl":"theorem IsOpenMap.restrict {f : X → Y} (hf : IsOpenMap f) {s : Set X} (hs : IsOpen s) :\n    IsOpenMap (s.restrict f) :=\n  hf.comp hs.isOpenMap_subtype_val\n\n"}
{"name":"IsClosed.isClosedEmbedding_subtypeVal","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsClosed s\n⊢ Topology.IsClosedEmbedding Subtype.val","decl":"lemma IsClosed.isClosedEmbedding_subtypeVal {s : Set X} (hs : IsClosed s) :\n    IsClosedEmbedding ((↑) : s → X) := .subtypeVal hs\n\n"}
{"name":"IsClosed.closedEmbedding_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsClosed s\n⊢ Topology.IsClosedEmbedding Subtype.val","decl":"@[deprecated (since := \"2024-10-20\")]\nalias IsClosed.closedEmbedding_subtype_val := IsClosed.isClosedEmbedding_subtypeVal\n\n"}
{"name":"IsClosed.isClosedMap_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsClosed s\n⊢ IsClosedMap Subtype.val","decl":"theorem IsClosed.isClosedMap_subtype_val {s : Set X} (hs : IsClosed s) :\n    IsClosedMap ((↑) : s → X) :=\n  hs.isClosedEmbedding_subtypeVal.isClosedMap\n\n"}
{"name":"Continuous.subtype_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\np : X → Prop\nf : Y → X\nh : Continuous f\nhp : ∀ (x : Y), p (f x)\n⊢ Continuous fun x => ⟨f x, ⋯⟩","decl":"@[continuity, fun_prop]\ntheorem Continuous.subtype_mk {f : Y → X} (h : Continuous f) (hp : ∀ x, p (f x)) :\n    Continuous fun x => (⟨f x, hp x⟩ : Subtype p) :=\n  continuous_induced_rng.2 h\n\n"}
{"name":"Continuous.subtype_map","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\np : X → Prop\nf : X → Y\nh : Continuous f\nq : Y → Prop\nhpq : ∀ (x : X), p x → q (f x)\n⊢ Continuous (Subtype.map f hpq)","decl":"theorem Continuous.subtype_map {f : X → Y} (h : Continuous f) {q : Y → Prop}\n    (hpq : ∀ x, p x → q (f x)) : Continuous (Subtype.map f hpq) :=\n  (h.comp continuous_subtype_val).subtype_mk _\n\n"}
{"name":"continuous_inclusion","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nh : HasSubset.Subset s t\n⊢ Continuous (Set.inclusion h)","decl":"theorem continuous_inclusion {s t : Set X} (h : s ⊆ t) : Continuous (inclusion h) :=\n  continuous_id.subtype_map h\n\n"}
{"name":"continuousAt_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : X → Prop\nx : Subtype p\n⊢ ContinuousAt Subtype.val x","decl":"theorem continuousAt_subtype_val {p : X → Prop} {x : Subtype p} :\n    ContinuousAt ((↑) : Subtype p → X) x :=\n  continuous_subtype_val.continuousAt\n\n"}
{"name":"Subtype.dense_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nt : Set ↑s\n⊢ Iff (Dense t) (HasSubset.Subset s (closure ↑t))","decl":"theorem Subtype.dense_iff {s : Set X} {t : Set s} : Dense t ↔ s ⊆ closure ((↑) '' t) := by\n  rw [IsInducing.subtypeVal.dense_iff, SetCoe.forall]\n  rfl\n\n"}
{"name":"map_nhds_subtype_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nx : ↑s\n⊢ Eq (Filter.map Subtype.val (nhds x)) (nhdsWithin (↑x) s)","decl":"theorem map_nhds_subtype_val {s : Set X} (x : s) : map ((↑) : s → X) (𝓝 x) = 𝓝[s] ↑x := by\n  rw [IsInducing.subtypeVal.map_nhds_eq, Subtype.range_val]\n\n"}
{"name":"map_nhds_subtype_coe_eq_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : X → Prop\nx : X\nhx : p x\nh : Filter.Eventually (fun x => p x) (nhds x)\n⊢ Eq (Filter.map Subtype.val (nhds ⟨x, hx⟩)) (nhds x)","decl":"theorem map_nhds_subtype_coe_eq_nhds {x : X} (hx : p x) (h : ∀ᶠ x in 𝓝 x, p x) :\n    map ((↑) : Subtype p → X) (𝓝 ⟨x, hx⟩) = 𝓝 x :=\n  map_nhds_induced_of_mem <| by rw [Subtype.range_val]; exact h\n\n"}
{"name":"nhds_subtype_eq_comap","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : X → Prop\nx : X\nh : p x\n⊢ Eq (nhds ⟨x, h⟩) (Filter.comap Subtype.val (nhds x))","decl":"theorem nhds_subtype_eq_comap {x : X} {h : p x} : 𝓝 (⟨x, h⟩ : Subtype p) = comap (↑) (𝓝 x) :=\n  nhds_induced _ _\n\n"}
{"name":"tendsto_subtype_rng","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nY : Type u_5\np : X → Prop\nl : Filter Y\nf : Y → Subtype p\nx : Subtype p\n⊢ Iff (Filter.Tendsto f l (nhds x)) (Filter.Tendsto (fun x => ↑(f x)) l (nhds ↑x))","decl":"theorem tendsto_subtype_rng {Y : Type*} {p : X → Prop} {l : Filter Y} {f : Y → Subtype p} :\n    ∀ {x : Subtype p}, Tendsto f l (𝓝 x) ↔ Tendsto (fun x => (f x : X)) l (𝓝 (x : X))\n  | ⟨a, ha⟩ => by rw [nhds_subtype_eq_comap, tendsto_comap_iff]; rfl\n\n"}
{"name":"closure_subtype","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\np : X → Prop\nx : Subtype fun a => p a\ns : Set (Subtype fun a => p a)\n⊢ Iff (Membership.mem (closure s) x) (Membership.mem (closure (Set.image Subtype.val s)) ↑x)","decl":"theorem closure_subtype {x : { a // p a }} {s : Set { a // p a }} :\n    x ∈ closure s ↔ (x : X) ∈ closure (((↑) : _ → X) '' s) :=\n  closure_induced\n\n"}
{"name":"continuousAt_codRestrict_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nt : Set Y\nh1 : ∀ (x : X), Membership.mem t (f x)\nx : X\n⊢ Iff (ContinuousAt (Set.codRestrict f t h1) x) (ContinuousAt f x)","decl":"@[simp]\ntheorem continuousAt_codRestrict_iff {f : X → Y} {t : Set Y} (h1 : ∀ x, f x ∈ t) {x : X} :\n    ContinuousAt (codRestrict f t h1) x ↔ ContinuousAt f x :=\n  IsInducing.subtypeVal.continuousAt_iff\n\n"}
{"name":"ContinuousAt.codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nt : Set Y\nh1 : ∀ (x : X), Membership.mem t (f x)\nx : X\na✝ : ContinuousAt f x\n⊢ ContinuousAt (Set.codRestrict f t h1) x","decl":"alias ⟨_, ContinuousAt.codRestrict⟩ := continuousAt_codRestrict_iff\n\n"}
{"name":"ContinuousAt.restrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nt : Set Y\nh1 : Set.MapsTo f s t\nx : ↑s\nh2 : ContinuousAt f ↑x\n⊢ ContinuousAt (Set.MapsTo.restrict f s t h1) x","decl":"theorem ContinuousAt.restrict {f : X → Y} {s : Set X} {t : Set Y} (h1 : MapsTo f s t) {x : s}\n    (h2 : ContinuousAt f x) : ContinuousAt (h1.restrict f s t) x :=\n  (h2.comp continuousAt_subtype_val).codRestrict _\n\n"}
{"name":"ContinuousAt.restrictPreimage","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set Y\nx : ↑(Set.preimage f s)\nh : ContinuousAt f ↑x\n⊢ ContinuousAt (s.restrictPreimage f) x","decl":"theorem ContinuousAt.restrictPreimage {f : X → Y} {s : Set Y} {x : f ⁻¹' s} (h : ContinuousAt f x) :\n    ContinuousAt (s.restrictPreimage f) x :=\n  h.restrict _\n\n"}
{"name":"Continuous.codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set Y\nhf : Continuous f\nhs : ∀ (a : X), Membership.mem s (f a)\n⊢ Continuous (Set.codRestrict f s hs)","decl":"@[continuity, fun_prop]\ntheorem Continuous.codRestrict {f : X → Y} {s : Set Y} (hf : Continuous f) (hs : ∀ a, f a ∈ s) :\n    Continuous (s.codRestrict f hs) :=\n  hf.subtype_mk hs\n\n"}
{"name":"Continuous.restrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set X\nt : Set Y\nh1 : Set.MapsTo f s t\nh2 : Continuous f\n⊢ Continuous (Set.MapsTo.restrict f s t h1)","decl":"@[continuity, fun_prop]\ntheorem Continuous.restrict {f : X → Y} {s : Set X} {t : Set Y} (h1 : MapsTo f s t)\n    (h2 : Continuous f) : Continuous (h1.restrict f s t) :=\n  (h2.comp continuous_subtype_val).codRestrict _\n\n"}
{"name":"Continuous.restrictPreimage","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\ns : Set Y\nh : Continuous f\n⊢ Continuous (s.restrictPreimage f)","decl":"@[continuity, fun_prop]\ntheorem Continuous.restrictPreimage {f : X → Y} {s : Set Y} (h : Continuous f) :\n    Continuous (s.restrictPreimage f) :=\n  h.restrict _\n\n"}
{"name":"Topology.IsInducing.codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ne : X → Y\nhe : Topology.IsInducing e\ns : Set Y\nhs : ∀ (x : X), Membership.mem s (e x)\n⊢ Topology.IsInducing (Set.codRestrict e s hs)","decl":"theorem Topology.IsInducing.codRestrict {e : X → Y} (he : IsInducing e) {s : Set Y}\n    (hs : ∀ x, e x ∈ s) : IsInducing (codRestrict e s hs) :=\n  he.of_comp (he.continuous.codRestrict hs) continuous_subtype_val\n\n"}
{"name":"Inducing.codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ne : X → Y\nhe : Topology.IsInducing e\ns : Set Y\nhs : ∀ (x : X), Membership.mem s (e x)\n⊢ Topology.IsInducing (Set.codRestrict e s hs)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.codRestrict := IsInducing.codRestrict\n\n"}
{"name":"Topology.IsEmbedding.codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ne : X → Y\nhe : Topology.IsEmbedding e\ns : Set Y\nhs : ∀ (x : X), Membership.mem s (e x)\n⊢ Topology.IsEmbedding (Set.codRestrict e s hs)","decl":"protected lemma Topology.IsEmbedding.codRestrict {e : X → Y} (he : IsEmbedding e) (s : Set Y)\n    (hs : ∀ x, e x ∈ s) : IsEmbedding (codRestrict e s hs) :=\n  he.of_comp (he.continuous.codRestrict hs) continuous_subtype_val\n\n"}
{"name":"Embedding.codRestrict","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ne : X → Y\nhe : Topology.IsEmbedding e\ns : Set Y\nhs : ∀ (x : X), Membership.mem s (e x)\n⊢ Topology.IsEmbedding (Set.codRestrict e s hs)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.codRestrict := IsEmbedding.codRestrict\n\n"}
{"name":"Topology.IsEmbedding.inclusion","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nh : HasSubset.Subset s t\n⊢ Topology.IsEmbedding (Set.inclusion h)","decl":"protected lemma Topology.IsEmbedding.inclusion (h : s ⊆ t) :\n    IsEmbedding (inclusion h) := IsEmbedding.subtypeVal.codRestrict _ _\n\n"}
{"name":"Topology.IsOpenEmbedding.inclusion","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhst : HasSubset.Subset s t\nhs : IsOpen (Set.preimage Subtype.val s)\n⊢ Topology.IsOpenEmbedding (Set.inclusion hst)","decl":"protected lemma Topology.IsOpenEmbedding.inclusion (hst : s ⊆ t) (hs : IsOpen (t ↓∩ s)) :\n    IsOpenEmbedding (inclusion hst) where\n  toIsEmbedding := .inclusion _\n  isOpen_range := by rwa [range_inclusion]\n\n"}
{"name":"Topology.IsClosedEmbedding.inclusion","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nhst : HasSubset.Subset s t\nhs : IsClosed (Set.preimage Subtype.val s)\n⊢ Topology.IsClosedEmbedding (Set.inclusion hst)","decl":"protected lemma Topology.IsClosedEmbedding.inclusion (hst : s ⊆ t) (hs : IsClosed (t ↓∩ s)) :\n    IsClosedEmbedding (inclusion hst) where\n  toIsEmbedding := .inclusion _\n  isClosed_range := by rwa [range_inclusion]\n\n"}
{"name":"embedding_inclusion","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nh : HasSubset.Subset s t\n⊢ Topology.IsEmbedding (Set.inclusion h)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_inclusion := IsEmbedding.inclusion\n\n"}
{"name":"DiscreteTopology.of_subset","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u_5\ninst✝ : TopologicalSpace X\ns t : Set X\nx✝ : DiscreteTopology ↑s\nts : HasSubset.Subset t s\n⊢ DiscreteTopology ↑t","decl":"/-- Let `s, t ⊆ X` be two subsets of a topological space `X`.  If `t ⊆ s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem DiscreteTopology.of_subset {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (_ : DiscreteTopology s) (ts : t ⊆ s) : DiscreteTopology t :=\n  (IsEmbedding.inclusion ts).discreteTopology\n\n"}
{"name":"DiscreteTopology.preimage_of_continuous_injective","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u_5\nY : Type u_6\ninst✝² : TopologicalSpace X\ninst✝¹ : TopologicalSpace Y\ns : Set Y\ninst✝ : DiscreteTopology ↑s\nf : X → Y\nhc : Continuous f\nhinj : Function.Injective f\n⊢ DiscreteTopology ↑(Set.preimage f s)","decl":"/-- Let `s` be a discrete subset of a topological space. Then the preimage of `s` by\na continuous injective map is also discrete. -/\ntheorem DiscreteTopology.preimage_of_continuous_injective {X Y : Type*} [TopologicalSpace X]\n    [TopologicalSpace Y] (s : Set Y) [DiscreteTopology s] {f : X → Y} (hc : Continuous f)\n    (hinj : Function.Injective f) : DiscreteTopology (f ⁻¹' s) :=\n  DiscreteTopology.of_continuous_injective (β := s) (Continuous.restrict\n    (by exact fun _ x ↦ x) hc) ((MapsTo.restrict_inj _).mpr hinj.injOn)\n\n"}
{"name":"Topology.IsQuotientMap.restrictPreimage_isOpen","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsQuotientMap f\ns : Set Y\nhs : IsOpen s\n⊢ Topology.IsQuotientMap (s.restrictPreimage f)","decl":"/-- If `f : X → Y` is a quotient map,\nthen its restriction to the preimage of an open set is a quotient map too. -/\ntheorem Topology.IsQuotientMap.restrictPreimage_isOpen {f : X → Y} (hf : IsQuotientMap f)\n    {s : Set Y} (hs : IsOpen s) : IsQuotientMap (s.restrictPreimage f) := by\n  refine isQuotientMap_iff.2 ⟨hf.surjective.restrictPreimage _, fun U ↦ ?_⟩\n  rw [hs.isOpenEmbedding_subtypeVal.isOpen_iff_image_isOpen, ← hf.isOpen_preimage,\n    (hs.preimage hf.continuous).isOpenEmbedding_subtypeVal.isOpen_iff_image_isOpen,\n    image_val_preimage_restrictPreimage]\n\n"}
{"name":"QuotientMap.restrictPreimage_isOpen","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nf : X → Y\nhf : Topology.IsQuotientMap f\ns : Set Y\nhs : IsOpen s\n⊢ Topology.IsQuotientMap (s.restrictPreimage f)","decl":"@[deprecated (since := \"2024-10-22\")]\nalias QuotientMap.restrictPreimage_isOpen := IsQuotientMap.restrictPreimage_isOpen\n\n"}
{"name":"isClosed_preimage_val","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\n⊢ Iff (IsClosed (Set.preimage Subtype.val t)) (HasSubset.Subset (Inter.inter s (closure (Inter.inter s t))) t)","decl":"open scoped Set.Notation in\nlemma isClosed_preimage_val {s t : Set X} : IsClosed (s ↓∩ t) ↔ s ∩ closure (s ∩ t) ⊆ t := by\n  rw [← closure_eq_iff_isClosed, IsEmbedding.subtypeVal.closure_eq_preimage_closure_image,\n    ← Subtype.val_injective.image_injective.eq_iff, Subtype.image_preimage_coe,\n    Subtype.image_preimage_coe, subset_antisymm_iff, and_iff_left, Set.subset_inter_iff,\n    and_iff_right]\n  exacts [Set.inter_subset_left, Set.subset_inter Set.inter_subset_left subset_closure]\n\n"}
{"name":"frontier_inter_open_inter","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns t : Set X\nht : IsOpen t\n⊢ Eq (Inter.inter (frontier (Inter.inter s t)) t) (Inter.inter (frontier s) t)","decl":"theorem frontier_inter_open_inter {s t : Set X} (ht : IsOpen t) :\n    frontier (s ∩ t) ∩ t = frontier s ∩ t := by\n  simp only [Set.inter_comm _ t, ← Subtype.preimage_coe_eq_preimage_coe_iff,\n    ht.isOpenMap_subtype_val.preimage_frontier_eq_frontier_preimage continuous_subtype_val,\n    Subtype.preimage_coe_self_inter]\n\n"}
{"name":"isQuotientMap_quot_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nr : X → X → Prop\n⊢ Topology.IsQuotientMap (Quot.mk r)","decl":"theorem isQuotientMap_quot_mk : IsQuotientMap (@Quot.mk X r) :=\n  ⟨Quot.exists_rep, rfl⟩\n\n"}
{"name":"quotientMap_quot_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nr : X → X → Prop\n⊢ Topology.IsQuotientMap (Quot.mk r)","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_quot_mk := isQuotientMap_quot_mk\n\n"}
{"name":"continuous_quot_mk","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nr : X → X → Prop\n⊢ Continuous (Quot.mk r)","decl":"@[continuity, fun_prop]\ntheorem continuous_quot_mk : Continuous (@Quot.mk X r) :=\n  continuous_coinduced_rng\n\n"}
{"name":"continuous_quot_lift","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\nr : X → X → Prop\nf : X → Y\nhr : ∀ (a b : X), r a b → Eq (f a) (f b)\nh : Continuous f\n⊢ Continuous (Quot.lift f hr)","decl":"@[continuity, fun_prop]\ntheorem continuous_quot_lift {f : X → Y} (hr : ∀ a b, r a b → f a = f b) (h : Continuous f) :\n    Continuous (Quot.lift f hr : Quot r → Y) :=\n  continuous_coinduced_dom.2 h\n\n"}
{"name":"isQuotientMap_quotient_mk'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Setoid X\n⊢ Topology.IsQuotientMap Quotient.mk'","decl":"theorem isQuotientMap_quotient_mk' : IsQuotientMap (@Quotient.mk' X s) :=\n  isQuotientMap_quot_mk\n\n"}
{"name":"quotientMap_quotient_mk'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Setoid X\n⊢ Topology.IsQuotientMap Quotient.mk'","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap_quotient_mk' := isQuotientMap_quotient_mk'\n\n"}
{"name":"continuous_quotient_mk'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Setoid X\n⊢ Continuous Quotient.mk'","decl":"theorem continuous_quotient_mk' : Continuous (@Quotient.mk' X s) :=\n  continuous_coinduced_rng\n\n"}
{"name":"Continuous.quotient_lift","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Setoid X\nf : X → Y\nh : Continuous f\nhs : ∀ (a b : X), HasEquiv.Equiv a b → Eq (f a) (f b)\n⊢ Continuous (Quotient.lift f hs)","decl":"theorem Continuous.quotient_lift {f : X → Y} (h : Continuous f) (hs : ∀ a b, a ≈ b → f a = f b) :\n    Continuous (Quotient.lift f hs : Quotient s → Y) :=\n  continuous_coinduced_dom.2 h\n\n"}
{"name":"Continuous.quotient_liftOn'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Setoid X\nf : X → Y\nh : Continuous f\nhs : ∀ (a b : X), s a b → Eq (f a) (f b)\n⊢ Continuous fun x => x.liftOn' f hs","decl":"theorem Continuous.quotient_liftOn' {f : X → Y} (h : Continuous f)\n    (hs : ∀ a b, s a b → f a = f b) :\n    Continuous (fun x => Quotient.liftOn' x f hs : Quotient s → Y) :=\n  h.quotient_lift hs\n\n"}
{"name":"Continuous.quotient_map'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Setoid X\nt : Setoid Y\nf : X → Y\nhf : Continuous f\nH : Relator.LiftFun (⇑s) (⇑t) f f\n⊢ Continuous (Quotient.map' f H)","decl":"@[continuity, fun_prop]\ntheorem Continuous.quotient_map' {t : Setoid Y} {f : X → Y} (hf : Continuous f)\n    (H : (s.r ⇒ t.r) f f) : Continuous (Quotient.map' f H) :=\n  (continuous_quotient_mk'.comp hf).quotient_lift _\n\n"}
{"name":"continuous_pi_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nι : Type u_5\nπ : ι → Type u_6\ninst✝ : TopologicalSpace X\nT : (i : ι) → TopologicalSpace (π i)\nf : X → (i : ι) → π i\n⊢ Iff (Continuous f) (∀ (i : ι), Continuous fun a => f a i)","decl":"theorem continuous_pi_iff : Continuous f ↔ ∀ i, Continuous fun a => f a i := by\n  simp only [continuous_iInf_rng, continuous_induced_rng, comp_def]\n\n"}
{"name":"continuous_pi","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nι : Type u_5\nπ : ι → Type u_6\ninst✝ : TopologicalSpace X\nT : (i : ι) → TopologicalSpace (π i)\nf : X → (i : ι) → π i\nh : ∀ (i : ι), Continuous fun a => f a i\n⊢ Continuous f","decl":"@[continuity, fun_prop]\ntheorem continuous_pi (h : ∀ i, Continuous fun a => f a i) : Continuous f :=\n  continuous_pi_iff.2 h\n\n"}
{"name":"continuous_apply","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ni : ι\n⊢ Continuous fun p => p i","decl":"@[continuity, fun_prop]\ntheorem continuous_apply (i : ι) : Continuous fun p : ∀ i, π i => p i :=\n  continuous_iInf_dom continuous_induced_dom\n\n"}
{"name":"continuous_apply_apply","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nκ : Type u_7\nρ : κ → ι → Type u_8\ninst✝ : (j : κ) → (i : ι) → TopologicalSpace (ρ j i)\nj : κ\ni : ι\n⊢ Continuous fun p => p j i","decl":"@[continuity]\ntheorem continuous_apply_apply {ρ : κ → ι → Type*} [∀ j i, TopologicalSpace (ρ j i)] (j : κ)\n    (i : ι) : Continuous fun p : ∀ j, ∀ i, ρ j i => p j i :=\n  (continuous_apply i).comp (continuous_apply j)\n\n"}
{"name":"continuousAt_apply","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ni : ι\nx : (i : ι) → π i\n⊢ ContinuousAt (fun p => p i) x","decl":"theorem continuousAt_apply (i : ι) (x : ∀ i, π i) : ContinuousAt (fun p : ∀ i, π i => p i) x :=\n  (continuous_apply i).continuousAt\n\n"}
{"name":"Filter.Tendsto.apply_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nl : Filter Y\nf : Y → (i : ι) → π i\nx : (i : ι) → π i\nh : Filter.Tendsto f l (nhds x)\ni : ι\n⊢ Filter.Tendsto (fun a => f a i) l (nhds (x i))","decl":"theorem Filter.Tendsto.apply_nhds {l : Filter Y} {f : Y → ∀ i, π i} {x : ∀ i, π i}\n    (h : Tendsto f l (𝓝 x)) (i : ι) : Tendsto (fun a => f a i) l (𝓝 <| x i) :=\n  (continuousAt_apply i _).tendsto.comp h\n\n"}
{"name":"Continuous.piMap","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nY : ι → Type u_8\ninst✝ : (i : ι) → TopologicalSpace (Y i)\nf : (i : ι) → π i → Y i\nhf : ∀ (i : ι), Continuous (f i)\n⊢ Continuous (Pi.map f)","decl":"@[fun_prop]\nprotected theorem Continuous.piMap {Y : ι → Type*} [∀ i, TopologicalSpace (Y i)]\n    {f : ∀ i, π i → Y i} (hf : ∀ i, Continuous (f i)) : Continuous (Pi.map f) :=\n  continuous_pi fun i ↦ (hf i).comp (continuous_apply i)\n\n"}
{"name":"nhds_pi","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\na : (i : ι) → π i\n⊢ Eq (nhds a) (Filter.pi fun i => nhds (a i))","decl":"theorem nhds_pi {a : ∀ i, π i} : 𝓝 a = pi fun i => 𝓝 (a i) := by\n  simp only [nhds_iInf, nhds_induced, Filter.pi]\n\n"}
{"name":"IsOpenMap.piMap","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nY : ι → Type u_8\ninst✝ : (i : ι) → TopologicalSpace (Y i)\nf : (i : ι) → π i → Y i\nhfo : ∀ (i : ι), IsOpenMap (f i)\nhsurj : Filter.Eventually (fun i => Function.Surjective (f i)) Filter.cofinite\n⊢ IsOpenMap (Pi.map f)","decl":"protected theorem IsOpenMap.piMap {Y : ι → Type*} [∀ i, TopologicalSpace (Y i)] {f : ∀ i, π i → Y i}\n    (hfo : ∀ i, IsOpenMap (f i)) (hsurj : ∀ᶠ i in cofinite, Surjective (f i)) :\n    IsOpenMap (Pi.map f) := by\n  refine IsOpenMap.of_nhds_le fun x ↦ ?_\n  rw [nhds_pi, nhds_pi, map_piMap_pi hsurj]\n  exact Filter.pi_mono fun i ↦ (hfo i).nhds_le _\n\n"}
{"name":"IsOpenQuotientMap.piMap","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nY : ι → Type u_8\ninst✝ : (i : ι) → TopologicalSpace (Y i)\nf : (i : ι) → π i → Y i\nhf : ∀ (i : ι), IsOpenQuotientMap (f i)\n⊢ IsOpenQuotientMap (Pi.map f)","decl":"protected theorem IsOpenQuotientMap.piMap {Y : ι → Type*} [∀ i, TopologicalSpace (Y i)]\n    {f : ∀ i, π i → Y i} (hf : ∀ i, IsOpenQuotientMap (f i)) : IsOpenQuotientMap (Pi.map f) :=\n  ⟨.piMap fun i ↦ (hf i).1, .piMap fun i ↦ (hf i).2, .piMap (fun i ↦ (hf i).3) <|\n    .of_forall fun i ↦ (hf i).1⟩\n\n"}
{"name":"tendsto_pi_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nf : Y → (i : ι) → π i\ng : (i : ι) → π i\nu : Filter Y\n⊢ Iff (Filter.Tendsto f u (nhds g)) (∀ (x : ι), Filter.Tendsto (fun i => f i x) u (nhds (g x)))","decl":"theorem tendsto_pi_nhds {f : Y → ∀ i, π i} {g : ∀ i, π i} {u : Filter Y} :\n    Tendsto f u (𝓝 g) ↔ ∀ x, Tendsto (fun i => f i x) u (𝓝 (g x)) := by\n  rw [nhds_pi, Filter.tendsto_pi]\n\n"}
{"name":"continuousAt_pi","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nι : Type u_5\nπ : ι → Type u_6\ninst✝ : TopologicalSpace X\nT : (i : ι) → TopologicalSpace (π i)\nf : X → (i : ι) → π i\nx : X\n⊢ Iff (ContinuousAt f x) (∀ (i : ι), ContinuousAt (fun y => f y i) x)","decl":"theorem continuousAt_pi {f : X → ∀ i, π i} {x : X} :\n    ContinuousAt f x ↔ ∀ i, ContinuousAt (fun y => f y i) x :=\n  tendsto_pi_nhds\n\n"}
{"name":"continuousAt_pi'","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nι : Type u_5\nπ : ι → Type u_6\ninst✝ : TopologicalSpace X\nT : (i : ι) → TopologicalSpace (π i)\nf : X → (i : ι) → π i\nx : X\nhf : ∀ (i : ι), ContinuousAt (fun y => f y i) x\n⊢ ContinuousAt f x","decl":"@[fun_prop]\ntheorem continuousAt_pi' {f : X → ∀ i, π i} {x : X} (hf : ∀ i, ContinuousAt (fun y => f y i) x) :\n    ContinuousAt f x :=\n  continuousAt_pi.2 hf\n\n"}
{"name":"ContinuousAt.piMap","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nY : ι → Type u_8\ninst✝ : (i : ι) → TopologicalSpace (Y i)\nf : (i : ι) → π i → Y i\nx : (i : ι) → π i\nhf : ∀ (i : ι), ContinuousAt (f i) (x i)\n⊢ ContinuousAt (Pi.map f) x","decl":"@[fun_prop]\nprotected theorem ContinuousAt.piMap {Y : ι → Type*} [∀ i, TopologicalSpace (Y i)]\n    {f : ∀ i, π i → Y i} {x : ∀ i, π i} (hf : ∀ i, ContinuousAt (f i) (x i)) :\n    ContinuousAt (Pi.map f) x :=\n  continuousAt_pi.2 fun i ↦ (hf i).comp (continuousAt_apply i x)\n\n"}
{"name":"Pi.continuous_precomp'","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nι' : Type u_8\nφ : ι' → ι\n⊢ Continuous fun f j => f (φ j)","decl":"theorem Pi.continuous_precomp' {ι' : Type*} (φ : ι' → ι) :\n    Continuous (fun (f : (∀ i, π i)) (j : ι') ↦ f (φ j)) :=\n  continuous_pi fun j ↦ continuous_apply (φ j)\n\n"}
{"name":"Pi.continuous_precomp","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nι : Type u_5\ninst✝ : TopologicalSpace X\nι' : Type u_8\nφ : ι' → ι\n⊢ Continuous fun x => Function.comp x φ","decl":"theorem Pi.continuous_precomp {ι' : Type*} (φ : ι' → ι) :\n    Continuous (· ∘ φ : (ι → X) → (ι' → X)) :=\n  Pi.continuous_precomp' φ\n\n"}
{"name":"Pi.continuous_postcomp'","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nX : ι → Type u_8\ninst✝ : (i : ι) → TopologicalSpace (X i)\ng : (i : ι) → π i → X i\nhg : ∀ (i : ι), Continuous (g i)\n⊢ Continuous fun f i => g i (f i)","decl":"theorem Pi.continuous_postcomp' {X : ι → Type*} [∀ i, TopologicalSpace (X i)]\n    {g : ∀ i, π i → X i} (hg : ∀ i, Continuous (g i)) :\n    Continuous (fun (f : (∀ i, π i)) (i : ι) ↦ g i (f i)) :=\n  continuous_pi fun i ↦ (hg i).comp <| continuous_apply i\n\n"}
{"name":"Pi.continuous_postcomp","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\nι : Type u_5\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ng : X → Y\nhg : Continuous g\n⊢ Continuous fun x => Function.comp g x","decl":"theorem Pi.continuous_postcomp [TopologicalSpace Y] {g : X → Y} (hg : Continuous g) :\n    Continuous (g ∘ · : (ι → X) → (ι → Y)) :=\n  Pi.continuous_postcomp' fun _ ↦ hg\n\n"}
{"name":"Pi.induced_precomp'","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nι' : Type u_8\nφ : ι' → ι\n⊢ Eq (TopologicalSpace.induced (fun f j => f (φ j)) Pi.topologicalSpace) (iInf fun i' => TopologicalSpace.induced (Function.eval (φ i')) (T (φ i')))","decl":"lemma Pi.induced_precomp' {ι' : Type*} (φ : ι' → ι) :\n    induced (fun (f : (∀ i, π i)) (j : ι') ↦ f (φ j)) Pi.topologicalSpace =\n    ⨅ i', induced (eval (φ i')) (T (φ i')) := by\n  simp [Pi.topologicalSpace, induced_iInf, induced_compose, comp_def]\n\n"}
{"name":"Pi.induced_precomp","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nι : Type u_5\ninst✝ : TopologicalSpace Y\nι' : Type u_8\nφ : ι' → ι\n⊢ Eq (TopologicalSpace.induced (fun x => Function.comp x φ) Pi.topologicalSpace) (iInf fun i' => TopologicalSpace.induced (Function.eval (φ i')) inst✝)","decl":"lemma Pi.induced_precomp [TopologicalSpace Y] {ι' : Type*} (φ : ι' → ι) :\n    induced (· ∘ φ) Pi.topologicalSpace =\n    ⨅ i', induced (eval (φ i')) ‹TopologicalSpace Y› :=\n  induced_precomp' φ\n\n"}
{"name":"Pi.continuous_restrict","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nS : Set ι\n⊢ Continuous S.restrict","decl":"@[continuity, fun_prop]\nlemma Pi.continuous_restrict (S : Set ι) :\n    Continuous (S.restrict : (∀ i : ι, π i) → (∀ i : S, π i)) :=\n  Pi.continuous_precomp' ((↑) : S → ι)\n\n"}
{"name":"Pi.continuous_restrict₂","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ns t : Set ι\nhst : HasSubset.Subset s t\n⊢ Continuous (Set.restrict₂ hst)","decl":"@[continuity, fun_prop]\nlemma Pi.continuous_restrict₂ {s t : Set ι} (hst : s ⊆ t) : Continuous (restrict₂ (π := π) hst) :=\n  continuous_pi fun _ ↦ continuous_apply _\n\n"}
{"name":"Finset.continuous_restrict","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ns : Finset ι\n⊢ Continuous s.restrict","decl":"@[continuity, fun_prop]\ntheorem Finset.continuous_restrict (s : Finset ι) : Continuous (s.restrict (π := π)) :=\n  continuous_pi fun _ ↦ continuous_apply _\n\n"}
{"name":"Finset.continuous_restrict₂","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ns t : Finset ι\nhst : HasSubset.Subset s t\n⊢ Continuous (Finset.restrict₂ hst)","decl":"@[continuity, fun_prop]\ntheorem Finset.continuous_restrict₂ {s t : Finset ι} (hst : s ⊆ t) :\n    Continuous (Finset.restrict₂ (π := π) hst) :=\n  continuous_pi fun _ ↦ continuous_apply _\n\n"}
{"name":"Pi.continuous_restrict_apply","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Z\ns : Set X\nf : X → Z\nhf : Continuous f\n⊢ Continuous (s.restrict f)","decl":"@[continuity, fun_prop]\ntheorem Pi.continuous_restrict_apply (s : Set X) {f : X → Z} (hf : Continuous f) :\n    Continuous (s.restrict f) := hf.comp continuous_subtype_val\n\n"}
{"name":"Pi.continuous_restrict₂_apply","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Z\ns t : Set X\nhst : HasSubset.Subset s t\nf : ↑t → Z\nhf : Continuous f\n⊢ Continuous (Set.restrict₂ hst f)","decl":"@[continuity, fun_prop]\ntheorem Pi.continuous_restrict₂_apply {s t : Set X} (hst : s ⊆ t)\n    {f : t → Z} (hf : Continuous f) :\n    Continuous (restrict₂ (π := fun _ ↦ Z) hst f) := hf.comp (continuous_inclusion hst)\n\n"}
{"name":"Finset.continuous_restrict_apply","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Z\ns : Finset X\nf : X → Z\nhf : Continuous f\n⊢ Continuous (s.restrict f)","decl":"@[continuity, fun_prop]\ntheorem Finset.continuous_restrict_apply (s : Finset X) {f : X → Z} (hf : Continuous f) :\n    Continuous (s.restrict f) := hf.comp continuous_subtype_val\n\n"}
{"name":"Finset.continuous_restrict₂_apply","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Z\ns t : Finset X\nhst : HasSubset.Subset s t\nf : (Subtype fun x => Membership.mem t x) → Z\nhf : Continuous f\n⊢ Continuous (Finset.restrict₂ hst f)","decl":"@[continuity, fun_prop]\ntheorem Finset.continuous_restrict₂_apply {s t : Finset X} (hst : s ⊆ t)\n    {f : t → Z} (hf : Continuous f) :\n    Continuous (restrict₂ (π := fun _ ↦ Z) hst f) := hf.comp (continuous_inclusion hst)\n\n"}
{"name":"Pi.induced_restrict","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nS : Set ι\n⊢ Eq (TopologicalSpace.induced S.restrict Pi.topologicalSpace) (iInf fun i => iInf fun h => TopologicalSpace.induced (Function.eval i) (T i))","decl":"lemma Pi.induced_restrict (S : Set ι) :\n    induced (S.restrict) Pi.topologicalSpace =\n    ⨅ i ∈ S, induced (eval i) (T i) := by\n  simp (config := { unfoldPartialApp := true }) [← iInf_subtype'', ← induced_precomp' ((↑) : S → ι),\n    restrict]\n\n"}
{"name":"Pi.induced_restrict_sUnion","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\n𝔖 : Set (Set ι)\n⊢ Eq (TopologicalSpace.induced 𝔖.sUnion.restrict Pi.topologicalSpace) (iInf fun S => iInf fun h => TopologicalSpace.induced S.restrict Pi.topologicalSpace)","decl":"lemma Pi.induced_restrict_sUnion (𝔖 : Set (Set ι)) :\n    induced (⋃₀ 𝔖).restrict (Pi.topologicalSpace (Y := fun i : (⋃₀ 𝔖) ↦ π i)) =\n    ⨅ S ∈ 𝔖, induced S.restrict Pi.topologicalSpace := by\n  simp_rw [Pi.induced_restrict, iInf_sUnion]\n\n"}
{"name":"Filter.Tendsto.update","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ninst✝ : DecidableEq ι\nl : Filter Y\nf : Y → (i : ι) → π i\nx : (i : ι) → π i\nhf : Filter.Tendsto f l (nhds x)\ni : ι\ng : Y → π i\nxi : π i\nhg : Filter.Tendsto g l (nhds xi)\n⊢ Filter.Tendsto (fun a => Function.update (f a) i (g a)) l (nhds (Function.update x i xi))","decl":"theorem Filter.Tendsto.update [DecidableEq ι] {l : Filter Y} {f : Y → ∀ i, π i} {x : ∀ i, π i}\n    (hf : Tendsto f l (𝓝 x)) (i : ι) {g : Y → π i} {xi : π i} (hg : Tendsto g l (𝓝 xi)) :\n    Tendsto (fun a => update (f a) i (g a)) l (𝓝 <| update x i xi) :=\n  tendsto_pi_nhds.2 fun j => by rcases eq_or_ne j i with (rfl | hj) <;> simp [*, hf.apply_nhds]\n\n"}
{"name":"ContinuousAt.update","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nι : Type u_5\nπ : ι → Type u_6\ninst✝¹ : TopologicalSpace X\nT : (i : ι) → TopologicalSpace (π i)\nf : X → (i : ι) → π i\ninst✝ : DecidableEq ι\nx : X\nhf : ContinuousAt f x\ni : ι\ng : X → π i\nhg : ContinuousAt g x\n⊢ ContinuousAt (fun a => Function.update (f a) i (g a)) x","decl":"theorem ContinuousAt.update [DecidableEq ι] {x : X} (hf : ContinuousAt f x) (i : ι) {g : X → π i}\n    (hg : ContinuousAt g x) : ContinuousAt (fun a => update (f a) i (g a)) x :=\n  hf.tendsto.update i hg\n\n"}
{"name":"Continuous.update","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nι : Type u_5\nπ : ι → Type u_6\ninst✝¹ : TopologicalSpace X\nT : (i : ι) → TopologicalSpace (π i)\nf : X → (i : ι) → π i\ninst✝ : DecidableEq ι\nhf : Continuous f\ni : ι\ng : X → π i\nhg : Continuous g\n⊢ Continuous fun a => Function.update (f a) i (g a)","decl":"theorem Continuous.update [DecidableEq ι] (hf : Continuous f) (i : ι) {g : X → π i}\n    (hg : Continuous g) : Continuous fun a => update (f a) i (g a) :=\n  continuous_iff_continuousAt.2 fun _ => hf.continuousAt.update i hg.continuousAt\n\n"}
{"name":"continuous_update","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Continuous fun f => Function.update f.1 i f.2","decl":"/-- `Function.update f i x` is continuous in `(f, x)`. -/\n@[continuity, fun_prop]\ntheorem continuous_update [DecidableEq ι] (i : ι) :\n    Continuous fun f : (∀ j, π j) × π i => update f.1 i f.2 :=\n  continuous_fst.update i continuous_snd\n\n"}
{"name":"continuous_single","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ninst✝¹ : (i : ι) → Zero (π i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Continuous fun x => Pi.single i x","decl":"/-- `Pi.mulSingle i x` is continuous in `x`. -/\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: restore @[continuity]\n@[to_additive \"`Pi.single i x` is continuous in `x`.\"]\ntheorem continuous_mulSingle [∀ i, One (π i)] [DecidableEq ι] (i : ι) :\n    Continuous fun x => (Pi.mulSingle i x : ∀ i, π i) :=\n  continuous_const.update _ continuous_id\n\n"}
{"name":"continuous_mulSingle","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ninst✝¹ : (i : ι) → One (π i)\ninst✝ : DecidableEq ι\ni : ι\n⊢ Continuous fun x => Pi.mulSingle i x","decl":"/-- `Pi.mulSingle i x` is continuous in `x`. -/\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: restore @[continuity]\n@[to_additive \"`Pi.single i x` is continuous in `x`.\"]\ntheorem continuous_mulSingle [∀ i, One (π i)] [DecidableEq ι] (i : ι) :\n    Continuous fun x => (Pi.mulSingle i x : ∀ i, π i) :=\n  continuous_const.update _ continuous_id\n\n"}
{"name":"Filter.Tendsto.finCons","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nn : Nat\nπ : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → TopologicalSpace (π i)\nf : Y → π 0\ng : Y → (j : Fin n) → π j.succ\nl : Filter Y\nx : π 0\ny : (j : Fin n) → π j.succ\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\n⊢ Filter.Tendsto (fun a => Fin.cons (f a) (g a)) l (nhds (Fin.cons x y))","decl":"theorem Filter.Tendsto.finCons\n    {f : Y → π 0} {g : Y → ∀ j : Fin n, π j.succ} {l : Filter Y} {x : π 0} {y : ∀ j, π (Fin.succ j)}\n    (hf : Tendsto f l (𝓝 x)) (hg : Tendsto g l (𝓝 y)) :\n    Tendsto (fun a => Fin.cons (f a) (g a)) l (𝓝 <| Fin.cons x y) :=\n  tendsto_pi_nhds.2 fun j => Fin.cases (by simpa) (by simpa using tendsto_pi_nhds.1 hg) j\n\n"}
{"name":"ContinuousAt.finCons","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nn : Nat\nπ : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → TopologicalSpace (π i)\nf : X → π 0\ng : X → (j : Fin n) → π j.succ\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\n⊢ ContinuousAt (fun a => Fin.cons (f a) (g a)) x","decl":"theorem ContinuousAt.finCons {f : X → π 0} {g : X → ∀ j : Fin n, π (Fin.succ j)} {x : X}\n    (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun a => Fin.cons (f a) (g a)) x :=\n  hf.tendsto.finCons hg\n\n"}
{"name":"Continuous.finCons","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nn : Nat\nπ : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → TopologicalSpace (π i)\nf : X → π 0\ng : X → (j : Fin n) → π j.succ\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun a => Fin.cons (f a) (g a)","decl":"theorem Continuous.finCons {f : X → π 0} {g : X → ∀ j : Fin n, π (Fin.succ j)}\n    (hf : Continuous f) (hg : Continuous g) : Continuous fun a => Fin.cons (f a) (g a) :=\n  continuous_iff_continuousAt.2 fun _ => hf.continuousAt.finCons hg.continuousAt\n\n"}
{"name":"Filter.Tendsto.matrixVecCons","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nZ : Type u_1\ninst✝ : TopologicalSpace Z\nn : Nat\nf : Y → Z\ng : Y → Fin n → Z\nl : Filter Y\nx : Z\ny : Fin n → Z\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\n⊢ Filter.Tendsto (fun a => Matrix.vecCons (f a) (g a)) l (nhds (Matrix.vecCons x y))","decl":"theorem Filter.Tendsto.matrixVecCons\n    {f : Y → Z} {g : Y → Fin n → Z} {l : Filter Y} {x : Z} {y : Fin n → Z}\n    (hf : Tendsto f l (𝓝 x)) (hg : Tendsto g l (𝓝 y)) :\n    Tendsto (fun a => Matrix.vecCons (f a) (g a)) l (𝓝 <| Matrix.vecCons x y) :=\n  hf.finCons hg\n\n"}
{"name":"ContinuousAt.matrixVecCons","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Z\nn : Nat\nf : X → Z\ng : X → Fin n → Z\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\n⊢ ContinuousAt (fun a => Matrix.vecCons (f a) (g a)) x","decl":"theorem ContinuousAt.matrixVecCons\n    {f : X → Z} {g : X → Fin n → Z} {x : X} (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun a => Matrix.vecCons (f a) (g a)) x :=\n  hf.finCons hg\n\n"}
{"name":"Continuous.matrixVecCons","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nZ : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Z\nn : Nat\nf : X → Z\ng : X → Fin n → Z\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun a => Matrix.vecCons (f a) (g a)","decl":"theorem Continuous.matrixVecCons\n    {f : X → Z} {g : X → Fin n → Z} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun a => Matrix.vecCons (f a) (g a) :=\n  hf.finCons hg\n\n"}
{"name":"Filter.Tendsto.finSnoc","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nn : Nat\nπ : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → TopologicalSpace (π i)\nf : Y → (j : Fin n) → π j.castSucc\ng : Y → π (Fin.last n)\nl : Filter Y\nx : (j : Fin n) → π j.castSucc\ny : π (Fin.last n)\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\n⊢ Filter.Tendsto (fun a => Fin.snoc (f a) (g a)) l (nhds (Fin.snoc x y))","decl":"theorem Filter.Tendsto.finSnoc\n    {f : Y → ∀ j : Fin n, π j.castSucc} {g : Y → π (Fin.last _)}\n    {l : Filter Y} {x : ∀ j, π (Fin.castSucc j)} {y : π (Fin.last _)}\n    (hf : Tendsto f l (𝓝 x)) (hg : Tendsto g l (𝓝 y)) :\n    Tendsto (fun a => Fin.snoc (f a) (g a)) l (𝓝 <| Fin.snoc x y) :=\n  tendsto_pi_nhds.2 fun j => Fin.lastCases (by simpa) (by simpa using tendsto_pi_nhds.1 hf) j\n\n"}
{"name":"ContinuousAt.finSnoc","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nn : Nat\nπ : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → TopologicalSpace (π i)\nf : X → (j : Fin n) → π j.castSucc\ng : X → π (Fin.last n)\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\n⊢ ContinuousAt (fun a => Fin.snoc (f a) (g a)) x","decl":"theorem ContinuousAt.finSnoc {f : X → ∀ j : Fin n, π j.castSucc} {g : X → π (Fin.last _)} {x : X}\n    (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun a => Fin.snoc (f a) (g a)) x :=\n  hf.tendsto.finSnoc hg\n\n"}
{"name":"Continuous.finSnoc","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nn : Nat\nπ : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → TopologicalSpace (π i)\nf : X → (j : Fin n) → π j.castSucc\ng : X → π (Fin.last n)\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun a => Fin.snoc (f a) (g a)","decl":"theorem Continuous.finSnoc {f : X → ∀ j : Fin n, π j.castSucc} {g : X → π (Fin.last _)}\n    (hf : Continuous f) (hg : Continuous g) : Continuous fun a => Fin.snoc (f a) (g a) :=\n  continuous_iff_continuousAt.2 fun _ => hf.continuousAt.finSnoc hg.continuousAt\n\n"}
{"name":"Filter.Tendsto.finInsertNth","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nn : Nat\nπ : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → TopologicalSpace (π i)\ni : Fin (HAdd.hAdd n 1)\nf : Y → π i\ng : Y → (j : Fin n) → π (i.succAbove j)\nl : Filter Y\nx : π i\ny : (j : Fin n) → π (i.succAbove j)\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\n⊢ Filter.Tendsto (fun a => i.insertNth (f a) (g a)) l (nhds (i.insertNth x y))","decl":"theorem Filter.Tendsto.finInsertNth\n    (i : Fin (n + 1)) {f : Y → π i} {g : Y → ∀ j : Fin n, π (i.succAbove j)} {l : Filter Y}\n    {x : π i} {y : ∀ j, π (i.succAbove j)} (hf : Tendsto f l (𝓝 x)) (hg : Tendsto g l (𝓝 y)) :\n    Tendsto (fun a => i.insertNth (f a) (g a)) l (𝓝 <| i.insertNth x y) :=\n  tendsto_pi_nhds.2 fun j => Fin.succAboveCases i (by simpa) (by simpa using tendsto_pi_nhds.1 hg) j\n\n"}
{"name":"Filter.Tendsto.fin_insertNth","module":"Mathlib.Topology.Constructions","initialProofState":"Y : Type v\nn : Nat\nπ : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → TopologicalSpace (π i)\ni : Fin (HAdd.hAdd n 1)\nf : Y → π i\ng : Y → (j : Fin n) → π (i.succAbove j)\nl : Filter Y\nx : π i\ny : (j : Fin n) → π (i.succAbove j)\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\n⊢ Filter.Tendsto (fun a => i.insertNth (f a) (g a)) l (nhds (i.insertNth x y))","decl":"@[deprecated (since := \"2025-01-02\")]\nalias Filter.Tendsto.fin_insertNth := Filter.Tendsto.finInsertNth\n\n"}
{"name":"ContinuousAt.finInsertNth","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nn : Nat\nπ : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → TopologicalSpace (π i)\ni : Fin (HAdd.hAdd n 1)\nf : X → π i\ng : X → (j : Fin n) → π (i.succAbove j)\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\n⊢ ContinuousAt (fun a => i.insertNth (f a) (g a)) x","decl":"theorem ContinuousAt.finInsertNth\n    (i : Fin (n + 1)) {f : X → π i} {g : X → ∀ j : Fin n, π (i.succAbove j)} {x : X}\n    (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun a => i.insertNth (f a) (g a)) x :=\n  hf.tendsto.finInsertNth i hg\n\n"}
{"name":"ContinuousAt.fin_insertNth","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nn : Nat\nπ : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → TopologicalSpace (π i)\ni : Fin (HAdd.hAdd n 1)\nf : X → π i\ng : X → (j : Fin n) → π (i.succAbove j)\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\n⊢ ContinuousAt (fun a => i.insertNth (f a) (g a)) x","decl":"@[deprecated (since := \"2025-01-02\")]\nalias ContinuousAt.fin_insertNth := ContinuousAt.finInsertNth\n\n"}
{"name":"Continuous.finInsertNth","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nn : Nat\nπ : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → TopologicalSpace (π i)\ni : Fin (HAdd.hAdd n 1)\nf : X → π i\ng : X → (j : Fin n) → π (i.succAbove j)\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun a => i.insertNth (f a) (g a)","decl":"theorem Continuous.finInsertNth\n    (i : Fin (n + 1)) {f : X → π i} {g : X → ∀ j : Fin n, π (i.succAbove j)}\n    (hf : Continuous f) (hg : Continuous g) : Continuous fun a => i.insertNth (f a) (g a) :=\n  continuous_iff_continuousAt.2 fun _ => hf.continuousAt.finInsertNth i hg.continuousAt\n\n"}
{"name":"Continuous.fin_insertNth","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\nn : Nat\nπ : Fin (HAdd.hAdd n 1) → Type u_8\ninst✝ : (i : Fin (HAdd.hAdd n 1)) → TopologicalSpace (π i)\ni : Fin (HAdd.hAdd n 1)\nf : X → π i\ng : X → (j : Fin n) → π (i.succAbove j)\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun a => i.insertNth (f a) (g a)","decl":"@[deprecated (since := \"2025-01-02\")]\nalias Continuous.fin_insertNth := Continuous.finInsertNth\n\n"}
{"name":"isOpen_set_pi","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ni : Set ι\ns : (a : ι) → Set (π a)\nhi : i.Finite\nhs : ∀ (a : ι), Membership.mem i a → IsOpen (s a)\n⊢ IsOpen (i.pi s)","decl":"theorem isOpen_set_pi {i : Set ι} {s : ∀ a, Set (π a)} (hi : i.Finite)\n    (hs : ∀ a ∈ i, IsOpen (s a)) : IsOpen (pi i s) := by\n  rw [pi_def]; exact hi.isOpen_biInter fun a ha => (hs _ ha).preimage (continuous_apply _)\n\n"}
{"name":"isOpen_pi_iff","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ns : Set ((a : ι) → π a)\n⊢ Iff (IsOpen s) (∀ (f : (a : ι) → π a), Membership.mem s f → Exists fun I => Exists fun u => And (∀ (a : ι), Membership.mem I a → And (IsOpen (u a)) (Membership.mem (u a) (f a))) (HasSubset.Subset ((↑I).pi u) s))","decl":"theorem isOpen_pi_iff {s : Set (∀ a, π a)} :\n    IsOpen s ↔\n      ∀ f, f ∈ s → ∃ (I : Finset ι) (u : ∀ a, Set (π a)),\n        (∀ a, a ∈ I → IsOpen (u a) ∧ f a ∈ u a) ∧ (I : Set ι).pi u ⊆ s := by\n  rw [isOpen_iff_nhds]\n  simp_rw [le_principal_iff, nhds_pi, Filter.mem_pi', mem_nhds_iff]\n  refine forall₂_congr fun a _ => ⟨?_, ?_⟩\n  · rintro ⟨I, t, ⟨h1, h2⟩⟩\n    refine ⟨I, fun a => eval a '' (I : Set ι).pi fun a => (h1 a).choose, fun i hi => ?_, ?_⟩\n    · simp_rw [eval_image_pi (Finset.mem_coe.mpr hi)\n          (pi_nonempty_iff.mpr fun i => ⟨_, fun _ => (h1 i).choose_spec.2.2⟩)]\n      exact (h1 i).choose_spec.2\n    · exact Subset.trans\n        (pi_mono fun i hi => (eval_image_pi_subset hi).trans (h1 i).choose_spec.1) h2\n  · rintro ⟨I, t, ⟨h1, h2⟩⟩\n    classical\n    refine ⟨I, fun a => ite (a ∈ I) (t a) univ, fun i => ?_, ?_⟩\n    · by_cases hi : i ∈ I\n      · use t i\n        simp_rw [if_pos hi]\n        exact ⟨Subset.rfl, (h1 i) hi⟩\n      · use univ\n        simp_rw [if_neg hi]\n        exact ⟨Subset.rfl, isOpen_univ, mem_univ _⟩\n    · rw [← univ_pi_ite]\n      simp only [← ite_and, ← Finset.mem_coe, and_self_iff, univ_pi_ite, h2]\n\n"}
{"name":"isOpen_pi_iff'","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ninst✝ : Finite ι\ns : Set ((a : ι) → π a)\n⊢ Iff (IsOpen s) (∀ (f : (a : ι) → π a), Membership.mem s f → Exists fun u => And (∀ (a : ι), And (IsOpen (u a)) (Membership.mem (u a) (f a))) (HasSubset.Subset (Set.univ.pi u) s))","decl":"theorem isOpen_pi_iff' [Finite ι] {s : Set (∀ a, π a)} :\n    IsOpen s ↔\n      ∀ f, f ∈ s → ∃ u : ∀ a, Set (π a), (∀ a, IsOpen (u a) ∧ f a ∈ u a) ∧ univ.pi u ⊆ s := by\n  cases nonempty_fintype ι\n  rw [isOpen_iff_nhds]\n  simp_rw [le_principal_iff, nhds_pi, Filter.mem_pi', mem_nhds_iff]\n  refine forall₂_congr fun a _ => ⟨?_, ?_⟩\n  · rintro ⟨I, t, ⟨h1, h2⟩⟩\n    refine\n      ⟨fun i => (h1 i).choose,\n        ⟨fun i => (h1 i).choose_spec.2,\n          (pi_mono fun i _ => (h1 i).choose_spec.1).trans (Subset.trans ?_ h2)⟩⟩\n    rw [← pi_inter_compl (I : Set ι)]\n    exact inter_subset_left\n  · exact fun ⟨u, ⟨h1, _⟩⟩ =>\n      ⟨Finset.univ, u, ⟨fun i => ⟨u i, ⟨rfl.subset, h1 i⟩⟩, by rwa [Finset.coe_univ]⟩⟩\n\n"}
{"name":"isClosed_set_pi","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ni : Set ι\ns : (a : ι) → Set (π a)\nhs : ∀ (a : ι), Membership.mem i a → IsClosed (s a)\n⊢ IsClosed (i.pi s)","decl":"theorem isClosed_set_pi {i : Set ι} {s : ∀ a, Set (π a)} (hs : ∀ a ∈ i, IsClosed (s a)) :\n    IsClosed (pi i s) := by\n  rw [pi_def]; exact isClosed_biInter fun a ha => (hs _ ha).preimage (continuous_apply _)\n\n"}
{"name":"mem_nhds_of_pi_mem_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nI : Set ι\ns : (i : ι) → Set (π i)\na : (i : ι) → π i\nhs : Membership.mem (nhds a) (I.pi s)\ni : ι\nhi : Membership.mem I i\n⊢ Membership.mem (nhds (a i)) (s i)","decl":"theorem mem_nhds_of_pi_mem_nhds {I : Set ι} {s : ∀ i, Set (π i)} (a : ∀ i, π i) (hs : I.pi s ∈ 𝓝 a)\n    {i : ι} (hi : i ∈ I) : s i ∈ 𝓝 (a i) := by\n  rw [nhds_pi] at hs; exact mem_of_pi_mem_pi hs hi\n\n"}
{"name":"set_pi_mem_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ni : Set ι\ns : (a : ι) → Set (π a)\nx : (a : ι) → π a\nhi : i.Finite\nhs : ∀ (a : ι), Membership.mem i a → Membership.mem (nhds (x a)) (s a)\n⊢ Membership.mem (nhds x) (i.pi s)","decl":"theorem set_pi_mem_nhds {i : Set ι} {s : ∀ a, Set (π a)} {x : ∀ a, π a} (hi : i.Finite)\n    (hs : ∀ a ∈ i, s a ∈ 𝓝 (x a)) : pi i s ∈ 𝓝 x := by\n  rw [pi_def, biInter_mem hi]\n  exact fun a ha => (continuous_apply a).continuousAt (hs a ha)\n\n"}
{"name":"set_pi_mem_nhds_iff","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nI : Set ι\nhI : I.Finite\ns : (i : ι) → Set (π i)\na : (i : ι) → π i\n⊢ Iff (Membership.mem (nhds a) (I.pi s)) (∀ (i : ι), Membership.mem I i → Membership.mem (nhds (a i)) (s i))","decl":"theorem set_pi_mem_nhds_iff {I : Set ι} (hI : I.Finite) {s : ∀ i, Set (π i)} (a : ∀ i, π i) :\n    I.pi s ∈ 𝓝 a ↔ ∀ i : ι, i ∈ I → s i ∈ 𝓝 (a i) := by\n  rw [nhds_pi, pi_mem_pi_iff hI]\n\n"}
{"name":"interior_pi_set","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nI : Set ι\nhI : I.Finite\ns : (i : ι) → Set (π i)\n⊢ Eq (interior (I.pi s)) (I.pi fun i => interior (s i))","decl":"theorem interior_pi_set {I : Set ι} (hI : I.Finite) {s : ∀ i, Set (π i)} :\n    interior (pi I s) = I.pi fun i => interior (s i) := by\n  ext a\n  simp only [Set.mem_pi, mem_interior_iff_mem_nhds, set_pi_mem_nhds_iff hI]\n\n"}
{"name":"exists_finset_piecewise_mem_of_mem_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\ninst✝ : DecidableEq ι\ns : Set ((a : ι) → π a)\nx : (a : ι) → π a\nhs : Membership.mem (nhds x) s\ny : (a : ι) → π a\n⊢ Exists fun I => Membership.mem s (I.piecewise x y)","decl":"theorem exists_finset_piecewise_mem_of_mem_nhds [DecidableEq ι] {s : Set (∀ a, π a)} {x : ∀ a, π a}\n    (hs : s ∈ 𝓝 x) (y : ∀ a, π a) : ∃ I : Finset ι, I.piecewise x y ∈ s := by\n  simp only [nhds_pi, Filter.mem_pi'] at hs\n  rcases hs with ⟨I, t, htx, hts⟩\n  refine ⟨I, hts fun i hi => ?_⟩\n  simpa [Finset.mem_coe.1 hi] using mem_of_mem_nhds (htx i)\n\n"}
{"name":"pi_generateFrom_eq","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_8\ng : (a : ι) → Set (Set (π a))\n⊢ Eq Pi.topologicalSpace (TopologicalSpace.generateFrom (setOf fun t => Exists fun s => Exists fun i => And (∀ (a : ι), Membership.mem i a → Membership.mem (g a) (s a)) (Eq t ((↑i).pi s))))","decl":"theorem pi_generateFrom_eq {π : ι → Type*} {g : ∀ a, Set (Set (π a))} :\n    (@Pi.topologicalSpace ι π fun a => generateFrom (g a)) =\n      generateFrom\n        { t | ∃ (s : ∀ a, Set (π a)) (i : Finset ι), (∀ a ∈ i, s a ∈ g a) ∧ t = pi (↑i) s } := by\n  refine le_antisymm ?_ ?_\n  · apply le_generateFrom\n    rintro _ ⟨s, i, hi, rfl⟩\n    letI := fun a => generateFrom (g a)\n    exact isOpen_set_pi i.finite_toSet (fun a ha => GenerateOpen.basic _ (hi a ha))\n  · classical\n    refine le_iInf fun i => coinduced_le_iff_le_induced.1 <| le_generateFrom fun s hs => ?_\n    refine GenerateOpen.basic _ ⟨update (fun i => univ) i s, {i}, ?_⟩\n    simp [hs]\n\n"}
{"name":"pi_eq_generateFrom","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\n⊢ Eq Pi.topologicalSpace (TopologicalSpace.generateFrom (setOf fun g => Exists fun s => Exists fun i => And (∀ (a : ι), Membership.mem i a → IsOpen (s a)) (Eq g ((↑i).pi s))))","decl":"theorem pi_eq_generateFrom :\n    Pi.topologicalSpace =\n      generateFrom\n        { g | ∃ (s : ∀ a, Set (π a)) (i : Finset ι), (∀ a ∈ i, IsOpen (s a)) ∧ g = pi (↑i) s } :=\n  calc Pi.topologicalSpace\n  _ = @Pi.topologicalSpace ι π fun _ => generateFrom { s | IsOpen s } := by\n    simp only [generateFrom_setOf_isOpen]\n  _ = _ := pi_generateFrom_eq\n\n"}
{"name":"pi_generateFrom_eq_finite","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_8\ng : (a : ι) → Set (Set (π a))\ninst✝ : Finite ι\nhg : ∀ (a : ι), Eq (g a).sUnion Set.univ\n⊢ Eq Pi.topologicalSpace (TopologicalSpace.generateFrom (setOf fun t => Exists fun s => And (∀ (a : ι), Membership.mem (g a) (s a)) (Eq t (Set.univ.pi s))))","decl":"theorem pi_generateFrom_eq_finite {π : ι → Type*} {g : ∀ a, Set (Set (π a))} [Finite ι]\n    (hg : ∀ a, ⋃₀ g a = univ) :\n    (@Pi.topologicalSpace ι π fun a => generateFrom (g a)) =\n      generateFrom { t | ∃ s : ∀ a, Set (π a), (∀ a, s a ∈ g a) ∧ t = pi univ s } := by\n  cases nonempty_fintype ι\n  rw [pi_generateFrom_eq]\n  refine le_antisymm (generateFrom_anti ?_) (le_generateFrom ?_)\n  · exact fun s ⟨t, ht, Eq⟩ => ⟨t, Finset.univ, by simp [ht, Eq]⟩\n  · rintro s ⟨t, i, ht, rfl⟩\n    letI := generateFrom { t | ∃ s : ∀ a, Set (π a), (∀ a, s a ∈ g a) ∧ t = pi univ s }\n    refine isOpen_iff_forall_mem_open.2 fun f hf => ?_\n    choose c hcg hfc using fun a => sUnion_eq_univ_iff.1 (hg a) (f a)\n    refine ⟨pi i t ∩ pi ((↑i)ᶜ : Set ι) c, inter_subset_left, ?_, ⟨hf, fun a _ => hfc a⟩⟩\n    classical\n    rw [← univ_pi_piecewise]\n    refine GenerateOpen.basic _ ⟨_, fun a => ?_, rfl⟩\n    by_cases a ∈ i <;> simp [*]\n\n"}
{"name":"induced_to_pi","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nX : Type u_8\nf : X → (i : ι) → π i\n⊢ Eq (TopologicalSpace.induced f Pi.topologicalSpace) (iInf fun i => TopologicalSpace.induced (fun x => f x i) inferInstance)","decl":"theorem induced_to_pi {X : Type*} (f : X → ∀ i, π i) :\n    induced f Pi.topologicalSpace = ⨅ i, induced (f · i) inferInstance := by\n  simp_rw [Pi.topologicalSpace, induced_iInf, induced_compose, Function.comp_def]\n\n"}
{"name":"inducing_iInf_to_pi","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\nX : Type u_8\nf : (i : ι) → X → π i\n⊢ Topology.IsInducing fun x i => f i x","decl":"/-- Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\nwhere `Π i, π i` is endowed with the usual product topology. -/\ntheorem inducing_iInf_to_pi {X : Type*} (f : ∀ i, X → π i) :\n    @IsInducing X (∀ i, π i) (⨅ i, induced (f i) inferInstance) _ fun x i => f i x :=\n  letI := ⨅ i, induced (f i) inferInstance; ⟨(induced_to_pi _).symm⟩\n\n"}
{"name":"Pi.discreteTopology","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\nT : (i : ι) → TopologicalSpace (π i)\n⊢ DiscreteTopology ((i : ι) → π i)","decl":"/-- A finite product of discrete spaces is discrete. -/\ninstance Pi.discreteTopology : DiscreteTopology (∀ i, π i) :=\n  singletons_open_iff_discrete.mp fun x => by\n    rw [← univ_pi_singleton]\n    exact isOpen_set_pi finite_univ fun i _ => (isOpen_discrete {x i})\n\n"}
{"name":"continuous_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\n⊢ Continuous (Sigma.mk i)","decl":"@[continuity, fun_prop]\ntheorem continuous_sigmaMk {i : ι} : Continuous (@Sigma.mk ι σ i) :=\n  continuous_iSup_rng continuous_coinduced_rng\n\n"}
{"name":"isOpen_sigma_iff","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ns : Set (Sigma σ)\n⊢ Iff (IsOpen s) (∀ (i : ι), IsOpen (Set.preimage (Sigma.mk i) s))","decl":"theorem isOpen_sigma_iff {s : Set (Sigma σ)} : IsOpen s ↔ ∀ i, IsOpen (Sigma.mk i ⁻¹' s) := by\n  rw [isOpen_iSup_iff]\n  rfl\n\n"}
{"name":"isClosed_sigma_iff","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ns : Set (Sigma σ)\n⊢ Iff (IsClosed s) (∀ (i : ι), IsClosed (Set.preimage (Sigma.mk i) s))","decl":"theorem isClosed_sigma_iff {s : Set (Sigma σ)} : IsClosed s ↔ ∀ i, IsClosed (Sigma.mk i ⁻¹' s) := by\n  simp only [← isOpen_compl_iff, isOpen_sigma_iff, preimage_compl]\n\n"}
{"name":"isOpenMap_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\n⊢ IsOpenMap (Sigma.mk i)","decl":"theorem isOpenMap_sigmaMk {i : ι} : IsOpenMap (@Sigma.mk ι σ i) := by\n  intro s hs\n  rw [isOpen_sigma_iff]\n  intro j\n  rcases eq_or_ne j i with (rfl | hne)\n  · rwa [preimage_image_eq _ sigma_mk_injective]\n  · rw [preimage_image_sigmaMk_of_ne hne]\n    exact isOpen_empty\n\n"}
{"name":"isOpen_range_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\n⊢ IsOpen (Set.range (Sigma.mk i))","decl":"theorem isOpen_range_sigmaMk {i : ι} : IsOpen (range (@Sigma.mk ι σ i)) :=\n  isOpenMap_sigmaMk.isOpen_range\n\n"}
{"name":"isClosedMap_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\n⊢ IsClosedMap (Sigma.mk i)","decl":"theorem isClosedMap_sigmaMk {i : ι} : IsClosedMap (@Sigma.mk ι σ i) := by\n  intro s hs\n  rw [isClosed_sigma_iff]\n  intro j\n  rcases eq_or_ne j i with (rfl | hne)\n  · rwa [preimage_image_eq _ sigma_mk_injective]\n  · rw [preimage_image_sigmaMk_of_ne hne]\n    exact isClosed_empty\n\n"}
{"name":"isClosed_range_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\n⊢ IsClosed (Set.range (Sigma.mk i))","decl":"theorem isClosed_range_sigmaMk {i : ι} : IsClosed (range (@Sigma.mk ι σ i)) :=\n  isClosedMap_sigmaMk.isClosed_range\n\n"}
{"name":"Topology.IsOpenEmbedding.sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\n⊢ Topology.IsOpenEmbedding (Sigma.mk i)","decl":"lemma Topology.IsOpenEmbedding.sigmaMk {i : ι} : IsOpenEmbedding (@Sigma.mk ι σ i) :=\n  .of_continuous_injective_isOpenMap continuous_sigmaMk sigma_mk_injective isOpenMap_sigmaMk\n\n"}
{"name":"isOpenEmbedding_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\n⊢ Topology.IsOpenEmbedding (Sigma.mk i)","decl":"@[deprecated (since := \"2024-10-30\")] alias isOpenEmbedding_sigmaMk := IsOpenEmbedding.sigmaMk\n\n"}
{"name":"openEmbedding_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\n⊢ Topology.IsOpenEmbedding (Sigma.mk i)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_sigmaMk := IsOpenEmbedding.sigmaMk\n\n"}
{"name":"Topology.IsClosedEmbedding.sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\n⊢ Topology.IsClosedEmbedding (Sigma.mk i)","decl":"lemma Topology.IsClosedEmbedding.sigmaMk {i : ι} : IsClosedEmbedding (@Sigma.mk ι σ i) :=\n  .of_continuous_injective_isClosedMap continuous_sigmaMk sigma_mk_injective isClosedMap_sigmaMk\n\n"}
{"name":"isClosedEmbedding_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\n⊢ Topology.IsClosedEmbedding (Sigma.mk i)","decl":"@[deprecated (since := \"2024-10-30\")] alias isClosedEmbedding_sigmaMk := IsClosedEmbedding.sigmaMk\n\n"}
{"name":"closedEmbedding_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\n⊢ Topology.IsClosedEmbedding (Sigma.mk i)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_sigmaMk := IsClosedEmbedding.sigmaMk\n\n"}
{"name":"Topology.IsEmbedding.sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\n⊢ Topology.IsEmbedding (Sigma.mk i)","decl":"lemma Topology.IsEmbedding.sigmaMk {i : ι} : IsEmbedding (@Sigma.mk ι σ i) :=\n  IsClosedEmbedding.sigmaMk.1\n\n"}
{"name":"embedding_sigmaMk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\n⊢ Topology.IsEmbedding (Sigma.mk i)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_sigmaMk := IsEmbedding.sigmaMk\n\n"}
{"name":"Sigma.nhds_mk","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\nx : σ i\n⊢ Eq (nhds ⟨i, x⟩) (Filter.map (Sigma.mk i) (nhds x))","decl":"theorem Sigma.nhds_mk (i : ι) (x : σ i) : 𝓝 (⟨i, x⟩ : Sigma σ) = Filter.map (Sigma.mk i) (𝓝 x) :=\n  (IsOpenEmbedding.sigmaMk.map_nhds_eq x).symm\n\n"}
{"name":"Sigma.nhds_eq","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\nx : Sigma σ\n⊢ Eq (nhds x) (Filter.map (Sigma.mk x.fst) (nhds x.snd))","decl":"theorem Sigma.nhds_eq (x : Sigma σ) : 𝓝 x = Filter.map (Sigma.mk x.1) (𝓝 x.2) := by\n  cases x\n  apply Sigma.nhds_mk\n\n"}
{"name":"comap_sigmaMk_nhds","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ni : ι\nx : σ i\n⊢ Eq (Filter.comap (Sigma.mk i) (nhds ⟨i, x⟩)) (nhds x)","decl":"theorem comap_sigmaMk_nhds (i : ι) (x : σ i) : comap (Sigma.mk i) (𝓝 ⟨i, x⟩) = 𝓝 x :=\n  (IsEmbedding.sigmaMk.nhds_eq_comap _).symm\n\n"}
{"name":"isOpen_sigma_fst_preimage","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nσ : ι → Type u_7\ninst✝ : (i : ι) → TopologicalSpace (σ i)\ns : Set ι\n⊢ IsOpen (Set.preimage Sigma.fst s)","decl":"theorem isOpen_sigma_fst_preimage (s : Set ι) : IsOpen (Sigma.fst ⁻¹' s : Set (Σ a, σ a)) := by\n  rw [← biUnion_of_singleton s, preimage_iUnion₂]\n  simp only [← range_sigmaMk]\n  exact isOpen_biUnion fun _ _ => isOpen_range_sigmaMk\n\n"}
{"name":"continuous_sigma_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nι : Type u_5\nσ : ι → Type u_7\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : TopologicalSpace X\nf : Sigma σ → X\n⊢ Iff (Continuous f) (∀ (i : ι), Continuous fun a => f ⟨i, a⟩)","decl":"/-- A map out of a sum type is continuous iff its restriction to each summand is. -/\n@[simp]\ntheorem continuous_sigma_iff {f : Sigma σ → X} :\n    Continuous f ↔ ∀ i, Continuous fun a => f ⟨i, a⟩ := by\n  delta instTopologicalSpaceSigma\n  rw [continuous_iSup_dom]\n  exact forall_congr' fun _ => continuous_coinduced_dom\n\n"}
{"name":"continuous_sigma","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nι : Type u_5\nσ : ι → Type u_7\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : TopologicalSpace X\nf : Sigma σ → X\nhf : ∀ (i : ι), Continuous fun a => f ⟨i, a⟩\n⊢ Continuous f","decl":"/-- A map out of a sum type is continuous if its restriction to each summand is. -/\n@[continuity, fun_prop]\ntheorem continuous_sigma {f : Sigma σ → X} (hf : ∀ i, Continuous fun a => f ⟨i, a⟩) :\n    Continuous f :=\n  continuous_sigma_iff.2 hf\n\n"}
{"name":"inducing_sigma","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nι : Type u_5\nσ : ι → Type u_7\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : TopologicalSpace X\nf : Sigma σ → X\n⊢ Iff (Topology.IsInducing f) (And (∀ (i : ι), Topology.IsInducing (Function.comp f (Sigma.mk i))) (∀ (i : ι), Exists fun U => And (IsOpen U) (∀ (x : Sigma σ), Iff (Membership.mem U (f x)) (Eq x.fst i))))","decl":"/-- A map defined on a sigma type (a.k.a. the disjoint union of an indexed family of topological\nspaces) is inducing iff its restriction to each component is inducing and each the image of each\ncomponent under `f` can be separated from the images of all other components by an open set. -/\ntheorem inducing_sigma {f : Sigma σ → X} :\n    IsInducing f ↔ (∀ i, IsInducing (f ∘ Sigma.mk i)) ∧\n      (∀ i, ∃ U, IsOpen U ∧ ∀ x, f x ∈ U ↔ x.1 = i) := by\n  refine ⟨fun h ↦ ⟨fun i ↦ h.comp IsEmbedding.sigmaMk.1, fun i ↦ ?_⟩, ?_⟩\n  · rcases h.isOpen_iff.1 (isOpen_range_sigmaMk (i := i)) with ⟨U, hUo, hU⟩\n    refine ⟨U, hUo, ?_⟩\n    simpa [Set.ext_iff] using hU\n  · refine fun ⟨h₁, h₂⟩ ↦ isInducing_iff_nhds.2 fun ⟨i, x⟩ ↦ ?_\n    rw [Sigma.nhds_mk, (h₁ i).nhds_eq_comap, comp_apply, ← comap_comap, map_comap_of_mem]\n    rcases h₂ i with ⟨U, hUo, hU⟩\n    filter_upwards [preimage_mem_comap <| hUo.mem_nhds <| (hU _).2 rfl] with y hy\n    simpa [hU] using hy\n\n"}
{"name":"continuous_sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nκ : Type u_6\nσ : ι → Type u_7\nτ : κ → Type u_8\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : (k : κ) → TopologicalSpace (τ k)\nf₁ : ι → κ\nf₂ : (i : ι) → σ i → τ (f₁ i)\n⊢ Iff (Continuous (Sigma.map f₁ f₂)) (∀ (i : ι), Continuous (f₂ i))","decl":"@[simp 1100]\ntheorem continuous_sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} :\n    Continuous (Sigma.map f₁ f₂) ↔ ∀ i, Continuous (f₂ i) :=\n  continuous_sigma_iff.trans <| by\n    simp only [Sigma.map, IsEmbedding.sigmaMk.continuous_iff, comp_def]\n\n"}
{"name":"Continuous.sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nκ : Type u_6\nσ : ι → Type u_7\nτ : κ → Type u_8\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : (k : κ) → TopologicalSpace (τ k)\nf₁ : ι → κ\nf₂ : (i : ι) → σ i → τ (f₁ i)\nhf : ∀ (i : ι), Continuous (f₂ i)\n⊢ Continuous (Sigma.map f₁ f₂)","decl":"@[continuity, fun_prop]\ntheorem Continuous.sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} (hf : ∀ i, Continuous (f₂ i)) :\n    Continuous (Sigma.map f₁ f₂) :=\n  continuous_sigma_map.2 hf\n\n"}
{"name":"isOpenMap_sigma","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nι : Type u_5\nσ : ι → Type u_7\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : TopologicalSpace X\nf : Sigma σ → X\n⊢ Iff (IsOpenMap f) (∀ (i : ι), IsOpenMap fun a => f ⟨i, a⟩)","decl":"theorem isOpenMap_sigma {f : Sigma σ → X} : IsOpenMap f ↔ ∀ i, IsOpenMap fun a => f ⟨i, a⟩ := by\n  simp only [isOpenMap_iff_nhds_le, Sigma.forall, Sigma.nhds_eq, map_map, comp_def]\n\n"}
{"name":"isOpenMap_sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nκ : Type u_6\nσ : ι → Type u_7\nτ : κ → Type u_8\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : (k : κ) → TopologicalSpace (τ k)\nf₁ : ι → κ\nf₂ : (i : ι) → σ i → τ (f₁ i)\n⊢ Iff (IsOpenMap (Sigma.map f₁ f₂)) (∀ (i : ι), IsOpenMap (f₂ i))","decl":"theorem isOpenMap_sigma_map {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} :\n    IsOpenMap (Sigma.map f₁ f₂) ↔ ∀ i, IsOpenMap (f₂ i) :=\n  isOpenMap_sigma.trans <|\n    forall_congr' fun i => (@IsOpenEmbedding.sigmaMk _ _ _ (f₁ i)).isOpenMap_iff.symm\n\n"}
{"name":"Topology.isInducing_sigmaMap","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nκ : Type u_6\nσ : ι → Type u_7\nτ : κ → Type u_8\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : (k : κ) → TopologicalSpace (τ k)\nf₁ : ι → κ\nf₂ : (i : ι) → σ i → τ (f₁ i)\nh₁ : Function.Injective f₁\n⊢ Iff (Topology.IsInducing (Sigma.map f₁ f₂)) (∀ (i : ι), Topology.IsInducing (f₂ i))","decl":"lemma Topology.isInducing_sigmaMap {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)}\n    (h₁ : Injective f₁) : IsInducing (Sigma.map f₁ f₂) ↔ ∀ i, IsInducing (f₂ i) := by\n  simp only [isInducing_iff_nhds, Sigma.forall, Sigma.nhds_mk, Sigma.map_mk,\n    ← map_sigma_mk_comap h₁, map_inj sigma_mk_injective]\n\n"}
{"name":"inducing_sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nκ : Type u_6\nσ : ι → Type u_7\nτ : κ → Type u_8\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : (k : κ) → TopologicalSpace (τ k)\nf₁ : ι → κ\nf₂ : (i : ι) → σ i → τ (f₁ i)\nh₁ : Function.Injective f₁\n⊢ Iff (Topology.IsInducing (Sigma.map f₁ f₂)) (∀ (i : ι), Topology.IsInducing (f₂ i))","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_sigma_map := isInducing_sigmaMap\n\n"}
{"name":"Topology.isEmbedding_sigmaMap","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nκ : Type u_6\nσ : ι → Type u_7\nτ : κ → Type u_8\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : (k : κ) → TopologicalSpace (τ k)\nf₁ : ι → κ\nf₂ : (i : ι) → σ i → τ (f₁ i)\nh : Function.Injective f₁\n⊢ Iff (Topology.IsEmbedding (Sigma.map f₁ f₂)) (∀ (i : ι), Topology.IsEmbedding (f₂ i))","decl":"lemma Topology.isEmbedding_sigmaMap {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)}\n    (h : Injective f₁) : IsEmbedding (Sigma.map f₁ f₂) ↔ ∀ i, IsEmbedding (f₂ i) := by\n  simp only [isEmbedding_iff, Injective.sigma_map, isInducing_sigmaMap h, forall_and,\n    h.sigma_map_iff]\n\n"}
{"name":"embedding_sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nκ : Type u_6\nσ : ι → Type u_7\nτ : κ → Type u_8\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : (k : κ) → TopologicalSpace (τ k)\nf₁ : ι → κ\nf₂ : (i : ι) → σ i → τ (f₁ i)\nh : Function.Injective f₁\n⊢ Iff (Topology.IsEmbedding (Sigma.map f₁ f₂)) (∀ (i : ι), Topology.IsEmbedding (f₂ i))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_sigma_map := isEmbedding_sigmaMap\n\n"}
{"name":"Topology.isOpenEmbedding_sigmaMap","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nκ : Type u_6\nσ : ι → Type u_7\nτ : κ → Type u_8\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : (k : κ) → TopologicalSpace (τ k)\nf₁ : ι → κ\nf₂ : (i : ι) → σ i → τ (f₁ i)\nh : Function.Injective f₁\n⊢ Iff (Topology.IsOpenEmbedding (Sigma.map f₁ f₂)) (∀ (i : ι), Topology.IsOpenEmbedding (f₂ i))","decl":"lemma Topology.isOpenEmbedding_sigmaMap {f₁ : ι → κ} {f₂ : ∀ i, σ i → τ (f₁ i)} (h : Injective f₁) :\n    IsOpenEmbedding (Sigma.map f₁ f₂) ↔ ∀ i, IsOpenEmbedding (f₂ i) := by\n  simp only [isOpenEmbedding_iff_isEmbedding_isOpenMap, isOpenMap_sigma_map, isEmbedding_sigmaMap h,\n    forall_and]\n\n"}
{"name":"isOpenEmbedding_sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nκ : Type u_6\nσ : ι → Type u_7\nτ : κ → Type u_8\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : (k : κ) → TopologicalSpace (τ k)\nf₁ : ι → κ\nf₂ : (i : ι) → σ i → τ (f₁ i)\nh : Function.Injective f₁\n⊢ Iff (Topology.IsOpenEmbedding (Sigma.map f₁ f₂)) (∀ (i : ι), Topology.IsOpenEmbedding (f₂ i))","decl":"@[deprecated (since := \"2024-10-30\")] alias isOpenEmbedding_sigma_map := isOpenEmbedding_sigmaMap\n\n"}
{"name":"openEmbedding_sigma_map","module":"Mathlib.Topology.Constructions","initialProofState":"ι : Type u_5\nκ : Type u_6\nσ : ι → Type u_7\nτ : κ → Type u_8\ninst✝¹ : (i : ι) → TopologicalSpace (σ i)\ninst✝ : (k : κ) → TopologicalSpace (τ k)\nf₁ : ι → κ\nf₂ : (i : ι) → σ i → τ (f₁ i)\nh : Function.Injective f₁\n⊢ Iff (Topology.IsOpenEmbedding (Sigma.map f₁ f₂)) (∀ (i : ι), Topology.IsOpenEmbedding (f₂ i))","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_sigma_map := isOpenEmbedding_sigmaMap\n\n"}
{"name":"ULift.isOpen_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set (ULift.{v, u} X)\n⊢ Iff (IsOpen s) (IsOpen (Set.preimage ULift.up s))","decl":"theorem ULift.isOpen_iff [TopologicalSpace X] {s : Set (ULift.{v} X)} :\n    IsOpen s ↔ IsOpen (ULift.up ⁻¹' s) := by\n  rw [ULift.topologicalSpace, ← Equiv.ulift_apply, ← Equiv.ulift.coinduced_symm, ← isOpen_coinduced]\n\n"}
{"name":"ULift.isClosed_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set (ULift.{v, u} X)\n⊢ Iff (IsClosed s) (IsClosed (Set.preimage ULift.up s))","decl":"theorem ULift.isClosed_iff [TopologicalSpace X] {s : Set (ULift.{v} X)} :\n    IsClosed s ↔ IsClosed (ULift.up ⁻¹' s) := by\n  rw [← isOpen_compl_iff, ← isOpen_compl_iff, isOpen_iff, preimage_compl]\n\n"}
{"name":"continuous_uLift_down","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Continuous ULift.down","decl":"@[continuity]\ntheorem continuous_uLift_down [TopologicalSpace X] : Continuous (ULift.down : ULift.{v, u} X → X) :=\n  continuous_induced_dom\n\n"}
{"name":"continuous_uLift_up","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Continuous ULift.up","decl":"@[continuity]\ntheorem continuous_uLift_up [TopologicalSpace X] : Continuous (ULift.up : X → ULift.{v, u} X) :=\n  continuous_induced_rng.2 continuous_id\n\n"}
{"name":"Topology.IsEmbedding.uliftDown","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Topology.IsEmbedding ULift.down","decl":"lemma Topology.IsEmbedding.uliftDown [TopologicalSpace X] :\n    IsEmbedding (ULift.down : ULift.{v, u} X → X) := ⟨⟨rfl⟩, ULift.down_injective⟩\n\n"}
{"name":"embedding_uLift_down","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Topology.IsEmbedding ULift.down","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_uLift_down := IsEmbedding.uliftDown\n\n"}
{"name":"Topology.IsClosedEmbedding.uliftDown","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Topology.IsClosedEmbedding ULift.down","decl":"lemma Topology.IsClosedEmbedding.uliftDown [TopologicalSpace X] :\n    IsClosedEmbedding (ULift.down : ULift.{v, u} X → X) :=\n  ⟨.uliftDown, by simp only [ULift.down_surjective.range_eq, isClosed_univ]⟩\n\n"}
{"name":"ULift.isClosedEmbedding_down","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Topology.IsClosedEmbedding ULift.down","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ULift.isClosedEmbedding_down := IsClosedEmbedding.uliftDown\n\n"}
{"name":"ULift.closedEmbedding_down","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\n⊢ Topology.IsClosedEmbedding ULift.down","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ULift.closedEmbedding_down := IsClosedEmbedding.uliftDown\n\n"}
{"name":"instDiscreteTopologyULift","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\n⊢ DiscreteTopology (ULift.{u_5, u} X)","decl":"instance [TopologicalSpace X] [DiscreteTopology X] : DiscreteTopology (ULift X) :=\n  IsEmbedding.uliftDown.discreteTopology\n\n"}
{"name":"IsOpen.trans","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nt : Set ↑s\nht : IsOpen t\nhs : IsOpen s\n⊢ IsOpen (Set.image Subtype.val t)","decl":"theorem IsOpen.trans (ht : IsOpen t) (hs : IsOpen s) : IsOpen (t : Set X) := by\n  rcases isOpen_induced_iff.mp ht with ⟨s', hs', rfl⟩\n  rw [Subtype.image_preimage_coe]\n  exact hs.inter hs'\n\n"}
{"name":"IsClosed.trans","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\ns : Set X\nt : Set ↑s\nht : IsClosed t\nhs : IsClosed s\n⊢ IsClosed (Set.image Subtype.val t)","decl":"theorem IsClosed.trans (ht : IsClosed t) (hs : IsClosed s) : IsClosed (t : Set X) := by\n  rcases isClosed_induced_iff.mp ht with ⟨s', hs', rfl⟩\n  rw [Subtype.image_preimage_coe]\n  exact hs.inter hs'\n\n"}
{"name":"nhdsSet_prod_le","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\n⊢ LE.le (nhdsSet (SProd.sprod s t)) (SProd.sprod (nhdsSet s) (nhdsSet t))","decl":"/-- The product of a neighborhood of `s` and a neighborhood of `t` is a neighborhood of `s ×ˢ t`,\nformulated in terms of a filter inequality. -/\ntheorem nhdsSet_prod_le (s : Set X) (t : Set Y) : 𝓝ˢ (s ×ˢ t) ≤ 𝓝ˢ s ×ˢ 𝓝ˢ t :=\n  ((hasBasis_nhdsSet _).prod (hasBasis_nhdsSet _)).ge_iff.2 fun (_u, _v) ⟨⟨huo, hsu⟩, hvo, htv⟩ ↦\n    (huo.prod hvo).mem_nhdsSet.2 <| prod_mono hsu htv\n\n"}
{"name":"Filter.eventually_nhdsSet_prod_iff","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\np : Prod X Y → Prop\n⊢ Iff (Filter.Eventually (fun q => p q) (nhdsSet (SProd.sprod s t))) (∀ (x : X), Membership.mem s x → ∀ (y : Y), Membership.mem t y → Exists fun px => And (Filter.Eventually (fun x' => px x') (nhds x)) (Exists fun py => And (Filter.Eventually (fun y' => py y') (nhds y)) (∀ {x : X}, px x → ∀ {y : Y}, py y → p { fst := x, snd := y })))","decl":"theorem Filter.eventually_nhdsSet_prod_iff {p : X × Y → Prop} :\n    (∀ᶠ q in 𝓝ˢ (s ×ˢ t), p q) ↔\n      ∀ x ∈ s, ∀ y ∈ t,\n          ∃ px : X → Prop, (∀ᶠ x' in 𝓝 x, px x') ∧ ∃ py : Y → Prop, (∀ᶠ y' in 𝓝 y, py y') ∧\n            ∀ {x : X}, px x → ∀ {y : Y}, py y → p (x, y) := by\n  simp_rw [eventually_nhdsSet_iff_forall, forall_prod_set, nhds_prod_eq, eventually_prod_iff]\n\n"}
{"name":"Filter.Eventually.prod_nhdsSet","module":"Mathlib.Topology.Constructions","initialProofState":"X : Type u\nY : Type v\ninst✝¹ : TopologicalSpace X\ninst✝ : TopologicalSpace Y\ns : Set X\nt : Set Y\np : Prod X Y → Prop\npx : X → Prop\npy : Y → Prop\nhp : ∀ {x : X}, px x → ∀ {y : Y}, py y → p { fst := x, snd := y }\nhs : Filter.Eventually (fun x => px x) (nhdsSet s)\nht : Filter.Eventually (fun y => py y) (nhdsSet t)\n⊢ Filter.Eventually (fun q => p q) (nhdsSet (SProd.sprod s t))","decl":"theorem Filter.Eventually.prod_nhdsSet {p : X × Y → Prop} {px : X → Prop} {py : Y → Prop}\n    (hp : ∀ {x : X}, px x → ∀ {y : Y}, py y → p (x, y)) (hs : ∀ᶠ x in 𝓝ˢ s, px x)\n    (ht : ∀ᶠ y in 𝓝ˢ t, py y) : ∀ᶠ q in 𝓝ˢ (s ×ˢ t), p q :=\n  nhdsSet_prod_le _ _ (mem_of_superset (prod_mem_prod hs ht) fun _ ⟨hx, hy⟩ ↦ hp hx hy)\n\n"}
