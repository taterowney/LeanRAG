{"name":"Order.cof_le","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\nr : α → α → Prop\nS : Set α\nh : ∀ (a : α), Exists fun b => And (Membership.mem S b) (r a b)\n⊢ LE.le (Order.cof r) (Cardinal.mk ↑S)","decl":"theorem cof_le (r : α → α → Prop) {S : Set α} (h : ∀ a, ∃ b ∈ S, r a b) : cof r ≤ #S :=\n  csInf_le' ⟨S, h, rfl⟩\n\n"}
{"name":"Order.le_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsRefl α r\nc : Cardinal.{u}\n⊢ Iff (LE.le c (Order.cof r)) (∀ {S : Set α}, (∀ (a : α), Exists fun b => And (Membership.mem S b) (r a b)) → LE.le c (Cardinal.mk ↑S))","decl":"theorem le_cof [IsRefl α r] (c : Cardinal) :\n    c ≤ cof r ↔ ∀ {S : Set α}, (∀ a, ∃ b ∈ S, r a b) → c ≤ #S := by\n  rw [cof, le_csInf_iff'' (cof_nonempty r)]\n  use fun H S h => H _ ⟨S, h, rfl⟩\n  rintro H d ⟨S, h, rfl⟩\n  exact H h\n\n"}
{"name":"RelIso.cof_eq_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsRefl β s\nf : RelIso r s\n⊢ Eq (Cardinal.lift.{v, u} (Order.cof r)) (Cardinal.lift.{u, v} (Order.cof s))","decl":"theorem cof_eq_lift [IsRefl β s] (f : r ≃r s) :\n    Cardinal.lift.{v} (Order.cof r) = Cardinal.lift.{u} (Order.cof s) :=\n  have := f.toRelEmbedding.isRefl\n  (f.cof_le_lift).antisymm (f.symm.cof_le_lift)\n\n"}
{"name":"RelIso.cof_eq","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α β : Type u\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsRefl β s\nf : RelIso r s\n⊢ Eq (Order.cof r) (Order.cof s)","decl":"theorem cof_eq {α β : Type u} {r : α → α → Prop} {s} [IsRefl β s] (f : r ≃r s) :\n    Order.cof r = Order.cof s :=\n  lift_inj.1 (f.cof_eq_lift)\n\n"}
{"name":"RelIso.cof_le","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α β : Type u\nr : α → α → Prop\ns : β → β → Prop\ninst✝ : IsRefl β s\nf : RelIso r s\n⊢ LE.le (Order.cof r) (Order.cof s)","decl":"@[deprecated cof_eq (since := \"2024-10-22\")]\ntheorem cof_le {α β : Type u} {r : α → α → Prop} {s} [IsRefl β s] (f : r ≃r s) :\n    Order.cof r ≤ Order.cof s :=\n  f.cof_eq.le\n\n"}
{"name":"StrictOrder.cof_nonempty","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsIrrefl α r\n⊢ (setOf fun c => Exists fun S => And (Set.Unbounded r S) (Eq (Cardinal.mk ↑S) c)).Nonempty","decl":"/-- The set in the definition of `Order.StrictOrder.cof` is nonempty. -/\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-10-22\")]\ntheorem StrictOrder.cof_nonempty (r : α → α → Prop) [IsIrrefl α r] :\n    { c | ∃ S : Set α, Unbounded r S ∧ #S = c }.Nonempty :=\n  @Order.cof_nonempty α _ (IsRefl.swap rᶜ)\n\n"}
{"name":"Ordinal.cof_type","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ Eq (Ordinal.type r).cof (Order.cof (Function.swap (HasCompl.compl r)))","decl":"theorem cof_type (r : α → α → Prop) [IsWellOrder α r] : (type r).cof = Order.cof (swap rᶜ) :=\n  rfl\n\n"}
{"name":"Ordinal.cof_type_lt","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\ninst✝¹ : LinearOrder α\ninst✝ : IsWellOrder α fun x1 x2 => LT.lt x1 x2\n⊢ Eq (Ordinal.type fun x1 x2 => LT.lt x1 x2).cof (Order.cof fun x1 x2 => LE.le x1 x2)","decl":"theorem cof_type_lt [LinearOrder α] [IsWellOrder α (· < ·)] :\n    (@type α (· < ·) _).cof = @Order.cof α (· ≤ ·) := by\n  rw [cof_type, compl_lt, swap_ge]\n\n"}
{"name":"Ordinal.cof_eq_cof_toType","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq o.cof (Order.cof fun x1 x2 => LE.le x1 x2)","decl":"theorem cof_eq_cof_toType (o : Ordinal) : o.cof = @Order.cof o.toType (· ≤ ·) := by\n  conv_lhs => rw [← type_toType o, cof_type_lt]\n\n"}
{"name":"Ordinal.le_cof_type","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nc : Cardinal.{u}\n⊢ Iff (LE.le c (Ordinal.type r).cof) (∀ (S : Set α), Set.Unbounded r S → LE.le c (Cardinal.mk ↑S))","decl":"theorem le_cof_type [IsWellOrder α r] {c} : c ≤ cof (type r) ↔ ∀ S, Unbounded r S → c ≤ #S :=\n  (le_csInf_iff'' (Order.cof_nonempty _)).trans\n    ⟨fun H S h => H _ ⟨S, h, rfl⟩, by\n      rintro H d ⟨S, h, rfl⟩\n      exact H _ h⟩\n\n"}
{"name":"Ordinal.cof_type_le","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nS : Set α\nh : Set.Unbounded r S\n⊢ LE.le (Ordinal.type r).cof (Cardinal.mk ↑S)","decl":"theorem cof_type_le [IsWellOrder α r] {S : Set α} (h : Unbounded r S) : cof (type r) ≤ #S :=\n  le_cof_type.1 le_rfl S h\n\n"}
{"name":"Ordinal.lt_cof_type","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nS : Set α\na✝ : LT.lt (Cardinal.mk ↑S) (Ordinal.type r).cof\n⊢ Set.Bounded r S","decl":"theorem lt_cof_type [IsWellOrder α r] {S : Set α} : #S < cof (type r) → Bounded r S := by\n  simpa using not_imp_not.2 cof_type_le\n\n"}
{"name":"Ordinal.cof_eq","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ Exists fun S => And (Set.Unbounded r S) (Eq (Cardinal.mk ↑S) (Ordinal.type r).cof)","decl":"theorem cof_eq (r : α → α → Prop) [IsWellOrder α r] : ∃ S, Unbounded r S ∧ #S = cof (type r) :=\n  csInf_mem (Order.cof_nonempty (swap rᶜ))\n\n"}
{"name":"Ordinal.ord_cof_eq","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ Exists fun S => And (Set.Unbounded r S) (Eq (Ordinal.type (Subrel r fun x => Membership.mem S x)) (Ordinal.type r).cof.ord)","decl":"theorem ord_cof_eq (r : α → α → Prop) [IsWellOrder α r] :\n    ∃ S, Unbounded r S ∧ type (Subrel r (· ∈ S)) = (cof (type r)).ord := by\n  let ⟨S, hS, e⟩ := cof_eq r\n  let ⟨s, _, e'⟩ := Cardinal.ord_eq S\n  let T : Set α := { a | ∃ aS : a ∈ S, ∀ b : S, s b ⟨_, aS⟩ → r b a }\n  suffices Unbounded r T by\n    refine ⟨T, this, le_antisymm ?_ (Cardinal.ord_le.2 <| cof_type_le this)⟩\n    rw [← e, e']\n    refine\n      (RelEmbedding.ofMonotone\n          (fun a : T =>\n            (⟨a,\n                let ⟨aS, _⟩ := a.2\n                aS⟩ :\n              S))\n          fun a b h => ?_).ordinal_type_le\n    rcases a with ⟨a, aS, ha⟩\n    rcases b with ⟨b, bS, hb⟩\n    change s ⟨a, _⟩ ⟨b, _⟩\n    refine ((trichotomous_of s _ _).resolve_left fun hn => ?_).resolve_left ?_\n    · exact asymm h (ha _ hn)\n    · intro e\n      injection e with e\n      subst b\n      exact irrefl _ h\n  intro a\n  have : { b : S | ¬r b a }.Nonempty :=\n    let ⟨b, bS, ba⟩ := hS a\n    ⟨⟨b, bS⟩, ba⟩\n  let b := (IsWellFounded.wf : WellFounded s).min _ this\n  have ba : ¬r b a := IsWellFounded.wf.min_mem _ this\n  refine ⟨b, ⟨b.2, fun c => not_imp_not.1 fun h => ?_⟩, ba⟩\n  rw [show ∀ b : S, (⟨b, b.2⟩ : S) = b by intro b; cases b; rfl]\n  exact IsWellFounded.wf.not_lt_min _ this (IsOrderConnected.neg_trans h ba)\n\n"}
{"name":"Ordinal.cof_lsub_def_nonempty","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\n⊢ (setOf fun a => Exists fun ι => Exists fun f => And (Eq (Ordinal.lsub f) o) (Eq (Cardinal.mk ι) a)).Nonempty","decl":"/-- The set in the `lsub` characterization of `cof` is nonempty. -/\ntheorem cof_lsub_def_nonempty (o) :\n    { a : Cardinal | ∃ (ι : _) (f : ι → Ordinal), lsub.{u, u} f = o ∧ #ι = a }.Nonempty :=\n  ⟨_, card_mem_cof⟩\n\n"}
{"name":"Ordinal.cof_eq_sInf_lsub","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\n⊢ Eq o.cof (InfSet.sInf (setOf fun a => Exists fun ι => Exists fun f => And (Eq (Ordinal.lsub f) o) (Eq (Cardinal.mk ι) a)))","decl":"theorem cof_eq_sInf_lsub (o : Ordinal.{u}) : cof o =\n    sInf { a : Cardinal | ∃ (ι : Type u) (f : ι → Ordinal), lsub.{u, u} f = o ∧ #ι = a } := by\n  refine le_antisymm (le_csInf (cof_lsub_def_nonempty o) ?_) (csInf_le' ?_)\n  · rintro a ⟨ι, f, hf, rfl⟩\n    rw [← type_toType o]\n    refine\n      (cof_type_le fun a => ?_).trans\n        (@mk_le_of_injective _ _\n          (fun s : typein ((· < ·) : o.toType → o.toType → Prop) ⁻¹' Set.range f =>\n            Classical.choose s.prop)\n          fun s t hst => by\n          let H := congr_arg f hst\n          rwa [Classical.choose_spec s.prop, Classical.choose_spec t.prop, typein_inj,\n            Subtype.coe_inj] at H)\n    have := typein_lt_self a\n    simp_rw [← hf, lt_lsub_iff] at this\n    cases' this with i hi\n    refine ⟨enum (α := o.toType) (· < ·) ⟨f i, ?_⟩, ?_, ?_⟩\n    · rw [type_toType, ← hf]\n      apply lt_lsub\n    · rw [mem_preimage, typein_enum]\n      exact mem_range_self i\n    · rwa [← typein_le_typein, typein_enum]\n  · rcases cof_eq (α := o.toType) (· < ·) with ⟨S, hS, hS'⟩\n    let f : S → Ordinal := fun s => typein LT.lt s.val\n    refine ⟨S, f, le_antisymm (lsub_le fun i => typein_lt_self (o := o) i)\n      (le_of_forall_lt fun a ha => ?_), by rwa [type_toType o] at hS'⟩\n    rw [← type_toType o] at ha\n    rcases hS (enum (· < ·) ⟨a, ha⟩) with ⟨b, hb, hb'⟩\n    rw [← typein_le_typein, typein_enum] at hb'\n    exact hb'.trans_lt (lt_lsub.{u, u} f ⟨b, hb⟩)\n\n"}
{"name":"Ordinal.lift_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{v}\n⊢ Eq (Cardinal.lift.{u, v} o.cof) (Ordinal.lift.{u, v} o).cof","decl":"@[simp]\ntheorem lift_cof (o) : Cardinal.lift.{u, v} (cof o) = cof (Ordinal.lift.{u, v} o) := by\n  refine inductionOn o fun α r _ ↦ ?_\n  rw [← type_uLift, cof_type, cof_type, ← Cardinal.lift_id'.{v, u} (Order.cof _),\n    ← Cardinal.lift_umax]\n  apply RelIso.cof_eq_lift ⟨Equiv.ulift.symm, _⟩\n  simp [swap]\n\n"}
{"name":"Ordinal.cof_le_card","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\n⊢ LE.le o.cof o.card","decl":"theorem cof_le_card (o) : cof o ≤ card o := by\n  rw [cof_eq_sInf_lsub]\n  exact csInf_le' card_mem_cof\n\n"}
{"name":"Ordinal.cof_ord_le","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u_1}\n⊢ LE.le c.ord.cof c","decl":"theorem cof_ord_le (c : Cardinal) : c.ord.cof ≤ c := by simpa using cof_le_card c.ord\n\n"}
{"name":"Ordinal.ord_cof_le","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\n⊢ LE.le o.cof.ord o","decl":"theorem ord_cof_le (o : Ordinal.{u}) : o.cof.ord ≤ o :=\n  (ord_le_ord.2 (cof_le_card o)).trans (ord_card_le o)\n\n"}
{"name":"Ordinal.exists_lsub_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\n⊢ Exists fun ι => Exists fun f => And (Eq (Ordinal.lsub f) o) (Eq (Cardinal.mk ι) o.cof)","decl":"theorem exists_lsub_cof (o : Ordinal) :\n    ∃ (ι : _) (f : ι → Ordinal), lsub.{u, u} f = o ∧ #ι = cof o := by\n  rw [cof_eq_sInf_lsub]\n  exact csInf_mem (cof_lsub_def_nonempty o)\n\n"}
{"name":"Ordinal.cof_lsub_le","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{u}\n⊢ LE.le (Ordinal.lsub f).cof (Cardinal.mk ι)","decl":"theorem cof_lsub_le {ι} (f : ι → Ordinal) : cof (lsub.{u, u} f) ≤ #ι := by\n  rw [cof_eq_sInf_lsub]\n  exact csInf_le' ⟨ι, f, rfl, rfl⟩\n\n"}
{"name":"Ordinal.cof_lsub_le_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ LE.le (Ordinal.lsub f).cof (Cardinal.lift.{v, u} (Cardinal.mk ι))","decl":"theorem cof_lsub_le_lift {ι} (f : ι → Ordinal) :\n    cof (lsub.{u, v} f) ≤ Cardinal.lift.{v, u} #ι := by\n  rw [← mk_uLift.{u, v}]\n  convert cof_lsub_le.{max u v} fun i : ULift.{v, u} ι => f i.down\n  exact\n    lsub_eq_of_range_eq.{u, max u v, max u v}\n      (Set.ext fun x => ⟨fun ⟨i, hi⟩ => ⟨ULift.up.{v, u} i, hi⟩, fun ⟨i, hi⟩ => ⟨_, hi⟩⟩)\n\n"}
{"name":"Ordinal.le_cof_iff_lsub","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\na : Cardinal.{u}\n⊢ Iff (LE.le a o.cof) (∀ {ι : Type u} (f : ι → Ordinal.{u}), Eq (Ordinal.lsub f) o → LE.le a (Cardinal.mk ι))","decl":"theorem le_cof_iff_lsub {o : Ordinal} {a : Cardinal} :\n    a ≤ cof o ↔ ∀ {ι} (f : ι → Ordinal), lsub.{u, u} f = o → a ≤ #ι := by\n  rw [cof_eq_sInf_lsub]\n  exact\n    (le_csInf_iff'' (cof_lsub_def_nonempty o)).trans\n      ⟨fun H ι f hf => H _ ⟨ι, f, hf, rfl⟩, fun H b ⟨ι, f, hf, hb⟩ => by\n        rw [← hb]\n        exact H _ hf⟩\n\n"}
{"name":"Ordinal.lsub_lt_ord_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\nc : Ordinal.{max u v}\nhι : LT.lt (Cardinal.lift.{v, u} (Cardinal.mk ι)) c.cof\nhf : ∀ (i : ι), LT.lt (f i) c\n⊢ LT.lt (Ordinal.lsub f) c","decl":"theorem lsub_lt_ord_lift {ι} {f : ι → Ordinal} {c : Ordinal}\n    (hι : Cardinal.lift.{v, u} #ι < c.cof)\n    (hf : ∀ i, f i < c) : lsub.{u, v} f < c :=\n  lt_of_le_of_ne (lsub_le hf) fun h => by\n    subst h\n    exact (cof_lsub_le_lift.{u, v} f).not_lt hι\n\n"}
{"name":"Ordinal.lsub_lt_ord","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{u}\nc : Ordinal.{u}\nhι : LT.lt (Cardinal.mk ι) c.cof\na✝ : ∀ (i : ι), LT.lt (f i) c\n⊢ LT.lt (Ordinal.lsub f) c","decl":"theorem lsub_lt_ord {ι} {f : ι → Ordinal} {c : Ordinal} (hι : #ι < c.cof) :\n    (∀ i, f i < c) → lsub.{u, u} f < c :=\n  lsub_lt_ord_lift (by rwa [(#ι).lift_id])\n\n"}
{"name":"Ordinal.cof_iSup_le_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\nH : ∀ (i : ι), LT.lt (f i) (iSup f)\n⊢ LE.le (iSup f).cof (Cardinal.lift.{v, u} (Cardinal.mk ι))","decl":"theorem cof_iSup_le_lift {ι} {f : ι → Ordinal} (H : ∀ i, f i < iSup f) :\n    cof (iSup f) ≤ Cardinal.lift.{v, u} #ι := by\n  rw [← Ordinal.sup] at *\n  rw [← sup_eq_lsub_iff_lt_sup.{u, v}] at H\n  rw [H]\n  exact cof_lsub_le_lift f\n\n"}
{"name":"Ordinal.cof_sup_le_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\nH : ∀ (i : ι), LT.lt (f i) (Ordinal.sup f)\n⊢ LE.le (Ordinal.sup f).cof (Cardinal.lift.{v, u} (Cardinal.mk ι))","decl":"set_option linter.deprecated false in\n@[deprecated cof_iSup_le_lift (since := \"2024-08-27\")]\ntheorem cof_sup_le_lift {ι} {f : ι → Ordinal} (H : ∀ i, f i < sup.{u, v} f) :\n    cof (sup.{u, v} f) ≤ Cardinal.lift.{v, u} #ι := by\n  rw [← sup_eq_lsub_iff_lt_sup.{u, v}] at H\n  rw [H]\n  exact cof_lsub_le_lift f\n\n"}
{"name":"Ordinal.cof_iSup_le","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u_1}\nH : ∀ (i : ι), LT.lt (f i) (iSup f)\n⊢ LE.le (iSup f).cof (Cardinal.mk ι)","decl":"theorem cof_iSup_le {ι} {f : ι → Ordinal} (H : ∀ i, f i < iSup f) :\n    cof (iSup f) ≤ #ι := by\n  rw [← (#ι).lift_id]\n  exact cof_iSup_le_lift H\n\n"}
{"name":"Ordinal.cof_sup_le","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{u}\nH : ∀ (i : ι), LT.lt (f i) (Ordinal.sup f)\n⊢ LE.le (Ordinal.sup f).cof (Cardinal.mk ι)","decl":"set_option linter.deprecated false in\n@[deprecated cof_iSup_le (since := \"2024-08-27\")]\ntheorem cof_sup_le {ι} {f : ι → Ordinal} (H : ∀ i, f i < sup.{u, u} f) :\n    cof (sup.{u, u} f) ≤ #ι := by\n  rw [← (#ι).lift_id]\n  exact cof_sup_le_lift H\n\n"}
{"name":"Ordinal.iSup_lt_ord_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\nc : Ordinal.{max u v}\nhι : LT.lt (Cardinal.lift.{v, u} (Cardinal.mk ι)) c.cof\nhf : ∀ (i : ι), LT.lt (f i) c\n⊢ LT.lt (iSup f) c","decl":"theorem iSup_lt_ord_lift {ι} {f : ι → Ordinal} {c : Ordinal} (hι : Cardinal.lift.{v, u} #ι < c.cof)\n    (hf : ∀ i, f i < c) : iSup f < c :=\n  (sup_le_lsub.{u, v} f).trans_lt (lsub_lt_ord_lift hι hf)\n\n"}
{"name":"Ordinal.sup_lt_ord_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\nc : Ordinal.{max u v}\nhι : LT.lt (Cardinal.lift.{v, u} (Cardinal.mk ι)) c.cof\nhf : ∀ (i : ι), LT.lt (f i) c\n⊢ LT.lt (Ordinal.sup f) c","decl":"set_option linter.deprecated false in\n@[deprecated iSup_lt_ord_lift (since := \"2024-08-27\")]\ntheorem sup_lt_ord_lift {ι} {f : ι → Ordinal} {c : Ordinal} (hι : Cardinal.lift.{v, u} #ι < c.cof)\n    (hf : ∀ i, f i < c) : sup.{u, v} f < c :=\n  iSup_lt_ord_lift hι hf\n\n"}
{"name":"Ordinal.iSup_lt_ord","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u_1}\nc : Ordinal.{u_1}\nhι : LT.lt (Cardinal.mk ι) c.cof\na✝ : ∀ (i : ι), LT.lt (f i) c\n⊢ LT.lt (iSup f) c","decl":"theorem iSup_lt_ord {ι} {f : ι → Ordinal} {c : Ordinal} (hι : #ι < c.cof) :\n    (∀ i, f i < c) → iSup f < c :=\n  iSup_lt_ord_lift (by rwa [(#ι).lift_id])\n\n"}
{"name":"Ordinal.sup_lt_ord","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{u}\nc : Ordinal.{u}\nhι : LT.lt (Cardinal.mk ι) c.cof\na✝ : ∀ (i : ι), LT.lt (f i) c\n⊢ LT.lt (Ordinal.sup f) c","decl":"set_option linter.deprecated false in\n@[deprecated iSup_lt_ord (since := \"2024-08-27\")]\ntheorem sup_lt_ord {ι} {f : ι → Ordinal} {c : Ordinal} (hι : #ι < c.cof) :\n    (∀ i, f i < c) → sup.{u, u} f < c :=\n  sup_lt_ord_lift (by rwa [(#ι).lift_id])\n\n"}
{"name":"Ordinal.iSup_lt_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Cardinal.{max u v}\nc : Cardinal.{max u v}\nhι : LT.lt (Cardinal.lift.{v, u} (Cardinal.mk ι)) c.ord.cof\nhf : ∀ (i : ι), LT.lt (f i) c\n⊢ LT.lt (iSup f) c","decl":"theorem iSup_lt_lift {ι} {f : ι → Cardinal} {c : Cardinal}\n    (hι : Cardinal.lift.{v, u} #ι < c.ord.cof)\n    (hf : ∀ i, f i < c) : iSup f < c := by\n  rw [← ord_lt_ord, iSup_ord (Cardinal.bddAbove_range _)]\n  refine iSup_lt_ord_lift hι fun i => ?_\n  rw [ord_lt_ord]\n  apply hf\n\n"}
{"name":"Ordinal.iSup_lt","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u_1\nf : ι → Cardinal.{u_1}\nc : Cardinal.{u_1}\nhι : LT.lt (Cardinal.mk ι) c.ord.cof\na✝ : ∀ (i : ι), LT.lt (f i) c\n⊢ LT.lt (iSup f) c","decl":"theorem iSup_lt {ι} {f : ι → Cardinal} {c : Cardinal} (hι : #ι < c.ord.cof) :\n    (∀ i, f i < c) → iSup f < c :=\n  iSup_lt_lift (by rwa [(#ι).lift_id])\n\n"}
{"name":"Ordinal.nfpFamily_lt_ord_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v} → Ordinal.{max u v}\nc : Ordinal.{max u v}\nhc : LT.lt Cardinal.aleph0 c.cof\nhc' : LT.lt (Cardinal.lift.{v, u} (Cardinal.mk ι)) c.cof\nhf : ∀ (i : ι) (b : Ordinal.{max u v}), LT.lt b c → LT.lt (f i b) c\na : Ordinal.{max u v}\nha : LT.lt a c\n⊢ LT.lt (Ordinal.nfpFamily f a) c","decl":"theorem nfpFamily_lt_ord_lift {ι} {f : ι → Ordinal → Ordinal} {c} (hc : ℵ₀ < cof c)\n    (hc' : Cardinal.lift.{v, u} #ι < cof c) (hf : ∀ (i), ∀ b < c, f i b < c) {a} (ha : a < c) :\n    nfpFamily f a < c := by\n  refine iSup_lt_ord_lift ((Cardinal.lift_le.2 (mk_list_le_max ι)).trans_lt ?_) fun l => ?_\n  · rw [lift_max]\n    apply max_lt _ hc'\n    rwa [Cardinal.lift_aleph0]\n  · induction' l with i l H\n    · exact ha\n    · exact hf _ _ H\n\n"}
{"name":"Ordinal.nfpFamily_lt_ord","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{u} → Ordinal.{u}\nc : Ordinal.{u}\nhc : LT.lt Cardinal.aleph0 c.cof\nhc' : LT.lt (Cardinal.mk ι) c.cof\nhf : ∀ (i : ι) (b : Ordinal.{u}), LT.lt b c → LT.lt (f i b) c\na : Ordinal.{u}\na✝ : LT.lt a c\n⊢ LT.lt (Ordinal.nfpFamily f a) c","decl":"theorem nfpFamily_lt_ord {ι} {f : ι → Ordinal → Ordinal} {c} (hc : ℵ₀ < cof c) (hc' : #ι < cof c)\n    (hf : ∀ (i), ∀ b < c, f i b < c) {a} : a < c → nfpFamily.{u, u} f a < c :=\n  nfpFamily_lt_ord_lift hc (by rwa [(#ι).lift_id]) hf\n\n"}
{"name":"Ordinal.nfpBFamily_lt_ord_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v} → Ordinal.{max u v}\nc : Ordinal.{max u v}\nhc : LT.lt Cardinal.aleph0 c.cof\nhc' : LT.lt (Cardinal.lift.{v, u} o.card) c.cof\nhf : ∀ (i : Ordinal.{u}) (hi : LT.lt i o) (b : Ordinal.{max u v}), LT.lt b c → LT.lt (f i hi b) c\na : Ordinal.{max u v}\na✝ : LT.lt a c\n⊢ LT.lt (o.nfpBFamily f a) c","decl":"set_option linter.deprecated false in\n@[deprecated nfpFamily_lt_ord_lift (since := \"2024-10-14\")]\ntheorem nfpBFamily_lt_ord_lift {o : Ordinal} {f : ∀ a < o, Ordinal → Ordinal} {c} (hc : ℵ₀ < cof c)\n    (hc' : Cardinal.lift.{v, u} o.card < cof c) (hf : ∀ (i hi), ∀ b < c, f i hi b < c) {a} :\n    a < c → nfpBFamily.{u, v} o f a < c :=\n  nfpFamily_lt_ord_lift hc (by rwa [mk_toType]) fun _ => hf _ _\n\n"}
{"name":"Ordinal.nfpBFamily_lt_ord","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{u} → Ordinal.{u}\nc : Ordinal.{u}\nhc : LT.lt Cardinal.aleph0 c.cof\nhc' : LT.lt o.card c.cof\nhf : ∀ (i : Ordinal.{u}) (hi : LT.lt i o) (b : Ordinal.{u}), LT.lt b c → LT.lt (f i hi b) c\na : Ordinal.{u}\na✝ : LT.lt a c\n⊢ LT.lt (o.nfpBFamily f a) c","decl":"set_option linter.deprecated false in\n@[deprecated nfpFamily_lt_ord (since := \"2024-10-14\")]\ntheorem nfpBFamily_lt_ord {o : Ordinal} {f : ∀ a < o, Ordinal → Ordinal} {c} (hc : ℵ₀ < cof c)\n    (hc' : o.card < cof c) (hf : ∀ (i hi), ∀ b < c, f i hi b < c) {a} :\n    a < c → nfpBFamily.{u, u} o f a < c :=\n  nfpBFamily_lt_ord_lift hc (by rwa [o.card.lift_id]) hf\n\n"}
{"name":"Ordinal.nfp_lt_ord","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nc : Ordinal.{u_1}\nhc : LT.lt Cardinal.aleph0 c.cof\nhf : ∀ (i : Ordinal.{u_1}), LT.lt i c → LT.lt (f i) c\na : Ordinal.{u_1}\na✝ : LT.lt a c\n⊢ LT.lt (Ordinal.nfp f a) c","decl":"theorem nfp_lt_ord {f : Ordinal → Ordinal} {c} (hc : ℵ₀ < cof c) (hf : ∀ i < c, f i < c) {a} :\n    a < c → nfp f a < c :=\n  nfpFamily_lt_ord_lift hc (by simpa using Cardinal.one_lt_aleph0.trans hc) fun _ => hf\n\n"}
{"name":"Ordinal.exists_blsub_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\n⊢ Exists fun f => Eq (o.cof.ord.blsub f) o","decl":"theorem exists_blsub_cof (o : Ordinal) :\n    ∃ f : ∀ a < (cof o).ord, Ordinal, blsub.{u, u} _ f = o := by\n  rcases exists_lsub_cof o with ⟨ι, f, hf, hι⟩\n  rcases Cardinal.ord_eq ι with ⟨r, hr, hι'⟩\n  rw [← @blsub_eq_lsub' ι r hr] at hf\n  rw [← hι, hι']\n  exact ⟨_, hf⟩\n\n"}
{"name":"Ordinal.le_cof_iff_blsub","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"b : Ordinal.{u}\na : Cardinal.{u}\n⊢ Iff (LE.le a b.cof) (∀ {o : Ordinal.{u}} (f : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{u}), Eq (o.blsub f) b → LE.le a o.card)","decl":"theorem le_cof_iff_blsub {b : Ordinal} {a : Cardinal} :\n    a ≤ cof b ↔ ∀ {o} (f : ∀ a < o, Ordinal), blsub.{u, u} o f = b → a ≤ o.card :=\n  le_cof_iff_lsub.trans\n    ⟨fun H o f hf => by simpa using H _ hf, fun H ι f hf => by\n      rcases Cardinal.ord_eq ι with ⟨r, hr, hι'⟩\n      rw [← @blsub_eq_lsub' ι r hr] at hf\n      simpa using H _ hf⟩\n\n"}
{"name":"Ordinal.cof_blsub_le_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ LE.le (o.blsub f).cof (Cardinal.lift.{v, u} o.card)","decl":"theorem cof_blsub_le_lift {o} (f : ∀ a < o, Ordinal) :\n    cof (blsub.{u, v} o f) ≤ Cardinal.lift.{v, u} o.card := by\n  rw [← mk_toType o]\n  exact cof_lsub_le_lift _\n\n"}
{"name":"Ordinal.cof_blsub_le","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{u}\n⊢ LE.le (o.blsub f).cof o.card","decl":"theorem cof_blsub_le {o} (f : ∀ a < o, Ordinal) : cof (blsub.{u, u} o f) ≤ o.card := by\n  rw [← o.card.lift_id]\n  exact cof_blsub_le_lift f\n\n"}
{"name":"Ordinal.blsub_lt_ord_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\nc : Ordinal.{max u v}\nho : LT.lt (Cardinal.lift.{v, u} o.card) c.cof\nhf : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), LT.lt (f i hi) c\n⊢ LT.lt (o.blsub f) c","decl":"theorem blsub_lt_ord_lift {o : Ordinal.{u}} {f : ∀ a < o, Ordinal} {c : Ordinal}\n    (ho : Cardinal.lift.{v, u} o.card < c.cof) (hf : ∀ i hi, f i hi < c) : blsub.{u, v} o f < c :=\n  lt_of_le_of_ne (blsub_le hf) fun h =>\n    ho.not_le (by simpa [← iSup_ord, hf, h] using cof_blsub_le_lift.{u, v} f)\n\n"}
{"name":"Ordinal.blsub_lt_ord","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{u}\nc : Ordinal.{u}\nho : LT.lt o.card c.cof\nhf : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), LT.lt (f i hi) c\n⊢ LT.lt (o.blsub f) c","decl":"theorem blsub_lt_ord {o : Ordinal} {f : ∀ a < o, Ordinal} {c : Ordinal} (ho : o.card < c.cof)\n    (hf : ∀ i hi, f i hi < c) : blsub.{u, u} o f < c :=\n  blsub_lt_ord_lift (by rwa [o.card.lift_id]) hf\n\n"}
{"name":"Ordinal.cof_bsup_le_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\nH : ∀ (i : Ordinal.{u}) (h : LT.lt i o), LT.lt (f i h) (o.bsup f)\n⊢ LE.le (o.bsup f).cof (Cardinal.lift.{v, u} o.card)","decl":"theorem cof_bsup_le_lift {o : Ordinal} {f : ∀ a < o, Ordinal} (H : ∀ i h, f i h < bsup.{u, v} o f) :\n    cof (bsup.{u, v} o f) ≤ Cardinal.lift.{v, u} o.card := by\n  rw [← bsup_eq_blsub_iff_lt_bsup.{u, v}] at H\n  rw [H]\n  exact cof_blsub_le_lift.{u, v} f\n\n"}
{"name":"Ordinal.cof_bsup_le","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{u}\na✝ : ∀ (i : Ordinal.{u}) (h : LT.lt i o), LT.lt (f i h) (o.bsup f)\n⊢ LE.le (o.bsup f).cof o.card","decl":"theorem cof_bsup_le {o : Ordinal} {f : ∀ a < o, Ordinal} :\n    (∀ i h, f i h < bsup.{u, u} o f) → cof (bsup.{u, u} o f) ≤ o.card := by\n  rw [← o.card.lift_id]\n  exact cof_bsup_le_lift\n\n"}
{"name":"Ordinal.bsup_lt_ord_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\nc : Ordinal.{max u v}\nho : LT.lt (Cardinal.lift.{v, u} o.card) c.cof\nhf : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), LT.lt (f i hi) c\n⊢ LT.lt (o.bsup f) c","decl":"theorem bsup_lt_ord_lift {o : Ordinal} {f : ∀ a < o, Ordinal} {c : Ordinal}\n    (ho : Cardinal.lift.{v, u} o.card < c.cof) (hf : ∀ i hi, f i hi < c) : bsup.{u, v} o f < c :=\n  (bsup_le_blsub f).trans_lt (blsub_lt_ord_lift ho hf)\n\n"}
{"name":"Ordinal.bsup_lt_ord","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{u}\nc : Ordinal.{u}\nho : LT.lt o.card c.cof\na✝ : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), LT.lt (f i hi) c\n⊢ LT.lt (o.bsup f) c","decl":"theorem bsup_lt_ord {o : Ordinal} {f : ∀ a < o, Ordinal} {c : Ordinal} (ho : o.card < c.cof) :\n    (∀ i hi, f i hi < c) → bsup.{u, u} o f < c :=\n  bsup_lt_ord_lift (by rwa [o.card.lift_id])\n\n"}
{"name":"Ordinal.cof_zero","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"⊢ Eq (Ordinal.cof 0) 0","decl":"@[simp]\ntheorem cof_zero : cof 0 = 0 := by\n  refine LE.le.antisymm  ?_ (Cardinal.zero_le _)\n  rw [← card_zero]\n  exact cof_le_card 0\n\n"}
{"name":"Ordinal.cof_eq_zero","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (Eq o.cof 0) (Eq o 0)","decl":"@[simp]\ntheorem cof_eq_zero {o} : cof o = 0 ↔ o = 0 :=\n  ⟨inductionOn o fun _ r _ z =>\n      let ⟨_, hl, e⟩ := cof_eq r\n      type_eq_zero_iff_isEmpty.2 <|\n        ⟨fun a =>\n          let ⟨_, h, _⟩ := hl a\n          (mk_eq_zero_iff.1 (e.trans z)).elim' ⟨_, h⟩⟩,\n    fun e => by simp [e]⟩\n\n"}
{"name":"Ordinal.cof_ne_zero","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (Ne o.cof 0) (Ne o 0)","decl":"theorem cof_ne_zero {o} : cof o ≠ 0 ↔ o ≠ 0 :=\n  cof_eq_zero.not\n\n"}
{"name":"Ordinal.cof_succ","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Order.succ o).cof 1","decl":"@[simp]\ntheorem cof_succ (o) : cof (succ o) = 1 := by\n  apply le_antisymm\n  · refine inductionOn o fun α r _ => ?_\n    change cof (type _) ≤ _\n    rw [← (_ : #_ = 1)]\n    · apply cof_type_le\n      refine fun a => ⟨Sum.inr PUnit.unit, Set.mem_singleton _, ?_⟩\n      rcases a with (a | ⟨⟨⟨⟩⟩⟩) <;> simp [EmptyRelation]\n    · rw [Cardinal.mk_fintype, Set.card_singleton]\n      simp\n  · rw [← Cardinal.succ_zero, succ_le_iff]\n    simpa [lt_iff_le_and_ne, Cardinal.zero_le] using fun h =>\n      succ_ne_zero o (cof_eq_zero.1 (Eq.symm h))\n\n"}
{"name":"Ordinal.cof_eq_one_iff_is_succ","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\n⊢ Iff (Eq o.cof 1) (Exists fun a => Eq o (Order.succ a))","decl":"@[simp]\ntheorem cof_eq_one_iff_is_succ {o} : cof.{u} o = 1 ↔ ∃ a, o = succ a :=\n  ⟨inductionOn o fun α r _ z => by\n      rcases cof_eq r with ⟨S, hl, e⟩; rw [z] at e\n      cases' mk_ne_zero_iff.1 (by rw [e]; exact one_ne_zero) with a\n      refine\n        ⟨typein r a,\n          Eq.symm <|\n            Quotient.sound\n              ⟨RelIso.ofSurjective (RelEmbedding.ofMonotone ?_ fun x y => ?_) fun x => ?_⟩⟩\n      · apply Sum.rec <;> [exact Subtype.val; exact fun _ => a]\n      · rcases x with (x | ⟨⟨⟨⟩⟩⟩) <;> rcases y with (y | ⟨⟨⟨⟩⟩⟩) <;>\n          simp [Subrel, Order.Preimage, EmptyRelation]\n        exact x.2\n      · suffices r x a ∨ ∃ _ : PUnit.{u}, ↑a = x by\n          convert this\n          dsimp [RelEmbedding.ofMonotone]; simp\n        rcases trichotomous_of r x a with (h | h | h)\n        · exact Or.inl h\n        · exact Or.inr ⟨PUnit.unit, h.symm⟩\n        · rcases hl x with ⟨a', aS, hn⟩\n          refine absurd h ?_\n          convert hn\n          change (a : α) = ↑(⟨a', aS⟩ : S)\n          have := le_one_iff_subsingleton.1 (le_of_eq e)\n          congr!,\n    fun ⟨a, e⟩ => by simp [e]⟩\n\n"}
{"name":"Ordinal.IsFundamentalSequence.cof_eq","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"a o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{u}\nhf : a.IsFundamentalSequence o f\n⊢ Eq a.cof.ord o","decl":"protected theorem cof_eq (hf : IsFundamentalSequence a o f) : a.cof.ord = o :=\n  hf.1.antisymm' <| by\n    rw [← hf.2.2]\n    exact (ord_le_ord.2 (cof_blsub_le f)).trans (ord_card_le o)\n\n"}
{"name":"Ordinal.IsFundamentalSequence.strict_mono","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"a o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{u}\nhf : a.IsFundamentalSequence o f\ni j : Ordinal.{u}\nhi : LT.lt i o\nhj : LT.lt j o\na✝ : LT.lt i j\n⊢ LT.lt (f i hi) (f j hj)","decl":"protected theorem strict_mono (hf : IsFundamentalSequence a o f) {i j} :\n    ∀ hi hj, i < j → f i hi < f j hj :=\n  hf.2.1\n\n"}
{"name":"Ordinal.IsFundamentalSequence.blsub_eq","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"a o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{u}\nhf : a.IsFundamentalSequence o f\n⊢ Eq (o.blsub f) a","decl":"theorem blsub_eq (hf : IsFundamentalSequence a o f) : blsub.{u, u} o f = a :=\n  hf.2.2\n\n"}
{"name":"Ordinal.IsFundamentalSequence.ord_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"a o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{u}\nhf : a.IsFundamentalSequence o f\n⊢ a.IsFundamentalSequence a.cof.ord fun i hi => f i ⋯","decl":"theorem ord_cof (hf : IsFundamentalSequence a o f) :\n    IsFundamentalSequence a a.cof.ord fun i hi => f i (hi.trans_le (by rw [hf.cof_eq])) := by\n  have H := hf.cof_eq\n  subst H\n  exact hf\n\n"}
{"name":"Ordinal.IsFundamentalSequence.id_of_le_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nh : LE.le o o.cof.ord\n⊢ o.IsFundamentalSequence o fun a x => a","decl":"theorem id_of_le_cof (h : o ≤ o.cof.ord) : IsFundamentalSequence o o fun a _ => a :=\n  ⟨h, @fun _ _ _ _ => id, blsub_id o⟩\n\n"}
{"name":"Ordinal.IsFundamentalSequence.zero","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"f : (b : Ordinal.{u_1}) → LT.lt b 0 → Ordinal.{u_1}\n⊢ Ordinal.IsFundamentalSequence 0 0 f","decl":"protected theorem zero {f : ∀ b < (0 : Ordinal), Ordinal} : IsFundamentalSequence 0 0 f :=\n  ⟨by rw [cof_zero, ord_zero], @fun i _ hi => (Ordinal.not_lt_zero i hi).elim, blsub_zero f⟩\n\n"}
{"name":"Ordinal.IsFundamentalSequence.succ","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\n⊢ (Order.succ o).IsFundamentalSequence 1 fun x x => o","decl":"protected theorem succ : IsFundamentalSequence (succ o) 1 fun _ _ => o := by\n  refine ⟨?_, @fun i j hi hj h => ?_, blsub_const Ordinal.one_ne_zero o⟩\n  · rw [cof_succ, ord_one]\n  · rw [lt_one_iff_zero] at hi hj\n    rw [hi, hj] at h\n    exact h.false.elim\n\n"}
{"name":"Ordinal.IsFundamentalSequence.monotone","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"a o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{u}\nhf : a.IsFundamentalSequence o f\ni j : Ordinal.{u}\nhi : LT.lt i o\nhj : LT.lt j o\nhij : LE.le i j\n⊢ LE.le (f i hi) (f j hj)","decl":"protected theorem monotone (hf : IsFundamentalSequence a o f) {i j : Ordinal} (hi : i < o)\n    (hj : j < o) (hij : i ≤ j) : f i hi ≤ f j hj := by\n  rcases lt_or_eq_of_le hij with (hij | rfl)\n  · exact (hf.2.1 hi hj hij).le\n  · rfl\n\n"}
{"name":"Ordinal.IsFundamentalSequence.trans","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"a o o' : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{u}\nhf : a.IsFundamentalSequence o f\ng : (b : Ordinal.{u}) → LT.lt b o' → Ordinal.{u}\nhg : o.IsFundamentalSequence o' g\n⊢ a.IsFundamentalSequence o' fun i hi => f (g i hi) ⋯","decl":"theorem trans {a o o' : Ordinal.{u}} {f : ∀ b < o, Ordinal.{u}} (hf : IsFundamentalSequence a o f)\n    {g : ∀ b < o', Ordinal.{u}} (hg : IsFundamentalSequence o o' g) :\n    IsFundamentalSequence a o' fun i hi =>\n      f (g i hi) (by rw [← hg.2.2]; apply lt_blsub) := by\n  refine ⟨?_, @fun i j _ _ h => hf.2.1 _ _ (hg.2.1 _ _ h), ?_⟩\n  · rw [hf.cof_eq]\n    exact hg.1.trans (ord_cof_le o)\n  · rw [@blsub_comp.{u, u, u} o _ f (@IsFundamentalSequence.monotone _ _ f hf)]\n    · exact hf.2.2\n    · exact hg.2.2\n\n"}
{"name":"Ordinal.IsFundamentalSequence.lt","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"a o : Ordinal.{u_1}\ns : (p : Ordinal.{u_1}) → LT.lt p o → Ordinal.{u_1}\nh : a.IsFundamentalSequence o s\np : Ordinal.{u_1}\nhp : LT.lt p o\n⊢ LT.lt (s p hp) a","decl":"protected theorem lt {a o : Ordinal} {s : Π p < o, Ordinal}\n    (h : IsFundamentalSequence a o s) {p : Ordinal} (hp : p < o) : s p hp < a :=\n  h.blsub_eq ▸ lt_blsub s p hp\n\n"}
{"name":"Ordinal.exists_fundamental_sequence","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"a : Ordinal.{u}\n⊢ Exists fun f => a.IsFundamentalSequence a.cof.ord f","decl":"/-- Every ordinal has a fundamental sequence. -/\ntheorem exists_fundamental_sequence (a : Ordinal.{u}) :\n    ∃ f, IsFundamentalSequence a a.cof.ord f := by\n  suffices h : ∃ o f, IsFundamentalSequence a o f by\n    rcases h with ⟨o, f, hf⟩\n    exact ⟨_, hf.ord_cof⟩\n  rcases exists_lsub_cof a with ⟨ι, f, hf, hι⟩\n  rcases ord_eq ι with ⟨r, wo, hr⟩\n  haveI := wo\n  let r' := Subrel r fun i ↦ ∀ j, r j i → f j < f i\n  let hrr' : r' ↪r r := Subrel.relEmbedding _ _\n  haveI := hrr'.isWellOrder\n  refine\n    ⟨_, _, hrr'.ordinal_type_le.trans ?_, @fun i j _ h _ => (enum r' ⟨j, h⟩).prop _ ?_,\n      le_antisymm (blsub_le fun i hi => lsub_le_iff.1 hf.le _) ?_⟩\n  · rw [← hι, hr]\n  · change r (hrr'.1 _) (hrr'.1 _)\n    rwa [hrr'.2, @enum_lt_enum _ r']\n  · rw [← hf, lsub_le_iff]\n    intro i\n    suffices h : ∃ i' hi', f i ≤ bfamilyOfFamily' r' (fun i => f i) i' hi' by\n      rcases h with ⟨i', hi', hfg⟩\n      exact hfg.trans_lt (lt_blsub _ _ _)\n    by_cases h : ∀ j, r j i → f j < f i\n    · refine ⟨typein r' ⟨i, h⟩, typein_lt_type _ _, ?_⟩\n      rw [bfamilyOfFamily'_typein]\n    · push_neg at h\n      cases' wo.wf.min_mem _ h with hji hij\n      refine ⟨typein r' ⟨_, fun k hkj => lt_of_lt_of_le ?_ hij⟩, typein_lt_type _ _, ?_⟩\n      · by_contra! H\n        exact (wo.wf.not_lt_min _ h ⟨IsTrans.trans _ _ _ hkj hji, H⟩) hkj\n      · rwa [bfamilyOfFamily'_typein]\n\n"}
{"name":"Ordinal.cof_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"a : Ordinal.{u}\n⊢ Eq a.cof.ord.cof a.cof","decl":"@[simp]\ntheorem cof_cof (a : Ordinal.{u}) : cof (cof a).ord = cof a := by\n  cases' exists_fundamental_sequence a with f hf\n  cases' exists_fundamental_sequence a.cof.ord with g hg\n  exact ord_injective (hf.trans hg).cof_eq.symm\n\n"}
{"name":"Ordinal.IsNormal.isFundamentalSequence","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"f : Ordinal.{u} → Ordinal.{u}\nhf : Ordinal.IsNormal f\na o : Ordinal.{u}\nha : a.IsLimit\ng : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{u}\nhg : a.IsFundamentalSequence o g\n⊢ (f a).IsFundamentalSequence o fun b hb => f (g b hb)","decl":"protected theorem IsNormal.isFundamentalSequence {f : Ordinal.{u} → Ordinal.{u}} (hf : IsNormal f)\n    {a o} (ha : IsLimit a) {g} (hg : IsFundamentalSequence a o g) :\n    IsFundamentalSequence (f a) o fun b hb => f (g b hb) := by\n  refine ⟨?_, @fun i j _ _ h => hf.strictMono (hg.2.1 _ _ h), ?_⟩\n  · rcases exists_lsub_cof (f a) with ⟨ι, f', hf', hι⟩\n    rw [← hg.cof_eq, ord_le_ord, ← hι]\n    suffices (lsub.{u, u} fun i => sInf { b : Ordinal | f' i ≤ f b }) = a by\n      rw [← this]\n      apply cof_lsub_le\n    have H : ∀ i, ∃ b < a, f' i ≤ f b := fun i => by\n      have := lt_lsub.{u, u} f' i\n      rw [hf', ← IsNormal.blsub_eq.{u, u} hf ha, lt_blsub_iff] at this\n      simpa using this\n    refine (lsub_le fun i => ?_).antisymm (le_of_forall_lt fun b hb => ?_)\n    · rcases H i with ⟨b, hb, hb'⟩\n      exact lt_of_le_of_lt (csInf_le' hb') hb\n    · have := hf.strictMono hb\n      rw [← hf', lt_lsub_iff] at this\n      cases' this with i hi\n      rcases H i with ⟨b, _, hb⟩\n      exact\n        ((le_csInf_iff'' ⟨b, by exact hb⟩).2 fun c hc =>\n          hf.strictMono.le_iff_le.1 (hi.trans hc)).trans_lt (lt_lsub _ i)\n  · rw [@blsub_comp.{u, u, u} a _ (fun b _ => f b) (@fun i j _ _ h => hf.strictMono.monotone h) g\n        hg.2.2]\n    exact IsNormal.blsub_eq.{u, u} hf ha\n\n"}
{"name":"Ordinal.IsNormal.cof_eq","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nhf : Ordinal.IsNormal f\na : Ordinal.{u_1}\nha : a.IsLimit\n⊢ Eq (f a).cof a.cof","decl":"theorem IsNormal.cof_eq {f} (hf : IsNormal f) {a} (ha : IsLimit a) : cof (f a) = cof a :=\n  let ⟨_, hg⟩ := exists_fundamental_sequence a\n  ord_injective (hf.isFundamentalSequence ha hg).cof_eq\n\n"}
{"name":"Ordinal.IsNormal.cof_le","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nhf : Ordinal.IsNormal f\na : Ordinal.{u_1}\n⊢ LE.le a.cof (f a).cof","decl":"theorem IsNormal.cof_le {f} (hf : IsNormal f) (a) : cof a ≤ cof (f a) := by\n  rcases zero_or_succ_or_limit a with (rfl | ⟨b, rfl⟩ | ha)\n  · rw [cof_zero]\n    exact zero_le _\n  · rw [cof_succ, Cardinal.one_le_iff_ne_zero, cof_ne_zero, ← Ordinal.pos_iff_ne_zero]\n    exact (Ordinal.zero_le (f b)).trans_lt (hf.1 b)\n  · rw [hf.cof_eq ha]\n\n"}
{"name":"Ordinal.cof_add","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"a b : Ordinal.{u_1}\na✝ : Ne b 0\n⊢ Eq (HAdd.hAdd a b).cof b.cof","decl":"@[simp]\ntheorem cof_add (a b : Ordinal) : b ≠ 0 → cof (a + b) = cof b := fun h => by\n  rcases zero_or_succ_or_limit b with (rfl | ⟨c, rfl⟩ | hb)\n  · contradiction\n  · rw [add_succ, cof_succ, cof_succ]\n  · exact (isNormal_add_right a).cof_eq hb\n\n"}
{"name":"Ordinal.aleph0_le_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LE.le Cardinal.aleph0 o.cof) o.IsLimit","decl":"theorem aleph0_le_cof {o} : ℵ₀ ≤ cof o ↔ IsLimit o := by\n  rcases zero_or_succ_or_limit o with (rfl | ⟨o, rfl⟩ | l)\n  · simp [not_zero_isLimit, Cardinal.aleph0_ne_zero]\n  · simp [not_succ_isLimit, Cardinal.one_lt_aleph0]\n  · simp only [l, iff_true]\n    refine le_of_not_lt fun h => ?_\n    cases' Cardinal.lt_aleph0.1 h with n e\n    have := cof_cof o\n    rw [e, ord_nat] at this\n    cases n\n    · simp at e\n      simp [e, not_zero_isLimit] at l\n    · rw [natCast_succ, cof_succ] at this\n      rw [← this, cof_eq_one_iff_is_succ] at e\n      rcases e with ⟨a, rfl⟩\n      exact not_succ_isLimit _ l\n\n"}
{"name":"Ordinal.cof_preOmega","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\nho : Order.IsSuccPrelimit o\n⊢ Eq (Ordinal.preOmega o).cof o.cof","decl":"@[simp]\ntheorem cof_preOmega {o : Ordinal} (ho : IsSuccPrelimit o) : (preOmega o).cof = o.cof := by\n  by_cases h : IsMin o\n  · simp [h.eq_bot]\n  · exact isNormal_preOmega.cof_eq ⟨h, ho⟩\n\n"}
{"name":"Ordinal.cof_omega","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\nho : o.IsLimit\n⊢ Eq (Ordinal.omega o).cof o.cof","decl":"@[simp]\ntheorem cof_omega {o : Ordinal} (ho : o.IsLimit) : (ω_ o).cof = o.cof :=\n  isNormal_omega.cof_eq ho\n\n"}
{"name":"Ordinal.preAleph_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\nho : o.IsLimit\n⊢ Eq (Cardinal.preAleph o).ord.cof o.cof","decl":"set_option linter.deprecated false in\n@[deprecated cof_preOmega (since := \"2024-10-22\")]\ntheorem preAleph_cof {o : Ordinal} (ho : o.IsLimit) : (preAleph o).ord.cof = o.cof :=\n  aleph'_isNormal.cof_eq ho\n\n"}
{"name":"Ordinal.aleph'_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\nho : o.IsLimit\n⊢ Eq (Cardinal.aleph' o).ord.cof o.cof","decl":"set_option linter.deprecated false in\n@[deprecated cof_preOmega (since := \"2024-10-22\")]\ntheorem aleph'_cof {o : Ordinal} (ho : o.IsLimit) : (aleph' o).ord.cof = o.cof :=\n  aleph'_isNormal.cof_eq ho\n\n"}
{"name":"Ordinal.aleph_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\nho : o.IsLimit\n⊢ Eq (Cardinal.aleph o).ord.cof o.cof","decl":"set_option linter.deprecated false in\n@[deprecated cof_omega (since := \"2024-10-22\")]\ntheorem aleph_cof {o : Ordinal} (ho : o.IsLimit) : (ℵ_  o).ord.cof = o.cof :=\n  aleph_isNormal.cof_eq ho\n\n"}
{"name":"Ordinal.cof_omega0","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"⊢ Eq Ordinal.omega0.cof Cardinal.aleph0","decl":"@[simp]\ntheorem cof_omega0 : cof ω = ℵ₀ :=\n  (aleph0_le_cof.2 isLimit_omega0).antisymm' <| by\n    rw [← card_omega0]\n    apply cof_le_card\n\n"}
{"name":"Ordinal.cof_eq'","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nh : (Ordinal.type r).IsLimit\n⊢ Exists fun S => And (∀ (a : α), Exists fun b => And (Membership.mem S b) (r a b)) (Eq (Cardinal.mk ↑S) (Ordinal.type r).cof)","decl":"theorem cof_eq' (r : α → α → Prop) [IsWellOrder α r] (h : IsLimit (type r)) :\n    ∃ S : Set α, (∀ a, ∃ b ∈ S, r a b) ∧ #S = cof (type r) :=\n  let ⟨S, H, e⟩ := cof_eq r\n  ⟨S, fun a =>\n    let a' := enum r ⟨_, h.succ_lt (typein_lt_type r a)⟩\n    let ⟨b, h, ab⟩ := H a'\n    ⟨b, h,\n      (IsOrderConnected.conn a b a' <|\n            (typein_lt_typein r).1\n              (by\n                rw [typein_enum]\n                exact lt_succ (typein _ _))).resolve_right\n        ab⟩,\n    e⟩\n\n"}
{"name":"Ordinal.cof_univ","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"⊢ Eq Ordinal.univ.{u, v}.cof Cardinal.univ.{u, v}","decl":"@[simp]\ntheorem cof_univ : cof univ.{u, v} = Cardinal.univ.{u, v} :=\n  le_antisymm (cof_le_card _)\n    (by\n      refine le_of_forall_lt fun c h => ?_\n      rcases lt_univ'.1 h with ⟨c, rfl⟩\n      rcases @cof_eq Ordinal.{u} (· < ·) _ with ⟨S, H, Se⟩\n      rw [univ, ← lift_cof, ← Cardinal.lift_lift.{u+1, v, u}, Cardinal.lift_lt, ← Se]\n      refine lt_of_not_ge fun h => ?_\n      cases' Cardinal.mem_range_lift_of_le h with a e\n      refine Quotient.inductionOn a (fun α e => ?_) e\n      cases' Quotient.exact e with f\n      have f := Equiv.ulift.symm.trans f\n      let g a := (f a).1\n      let o := succ (iSup g)\n      rcases H o with ⟨b, h, l⟩\n      refine l (lt_succ_iff.2 ?_)\n      rw [← show g (f.symm ⟨b, h⟩) = b by simp [g]]\n      apply Ordinal.le_iSup)\n\n"}
{"name":"Ordinal.unbounded_of_unbounded_sUnion","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\nr : α → α → Prop\nwo : IsWellOrder α r\ns : Set (Set α)\nh₁ : Set.Unbounded r s.sUnion\nh₂ : LT.lt (Cardinal.mk ↑s) (Order.cof (Function.swap (HasCompl.compl r)))\n⊢ Exists fun x => And (Membership.mem s x) (Set.Unbounded r x)","decl":"/-- If the union of s is unbounded and s is smaller than the cofinality,\n  then s has an unbounded member -/\ntheorem unbounded_of_unbounded_sUnion (r : α → α → Prop) [wo : IsWellOrder α r] {s : Set (Set α)}\n    (h₁ : Unbounded r <| ⋃₀ s) (h₂ : #s < Order.cof (swap rᶜ)) : ∃ x ∈ s, Unbounded r x := by\n  by_contra! h\n  simp_rw [not_unbounded_iff] at h\n  let f : s → α := fun x : s => wo.wf.sup x (h x.1 x.2)\n  refine h₂.not_le (le_trans (csInf_le' ⟨range f, fun x => ?_, rfl⟩) mk_range_le)\n  rcases h₁ x with ⟨y, ⟨c, hc, hy⟩, hxy⟩\n  exact ⟨f ⟨c, hc⟩, mem_range_self _, fun hxz => hxy (Trans.trans (wo.wf.lt_sup _ hy) hxz)⟩\n\n"}
{"name":"Ordinal.unbounded_of_unbounded_iUnion","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α β : Type u\nr : α → α → Prop\nwo : IsWellOrder α r\ns : β → Set α\nh₁ : Set.Unbounded r (Set.iUnion fun x => s x)\nh₂ : LT.lt (Cardinal.mk β) (Order.cof (Function.swap (HasCompl.compl r)))\n⊢ Exists fun x => Set.Unbounded r (s x)","decl":"/-- If the union of s is unbounded and s is smaller than the cofinality,\n  then s has an unbounded member -/\ntheorem unbounded_of_unbounded_iUnion {α β : Type u} (r : α → α → Prop) [wo : IsWellOrder α r]\n    (s : β → Set α) (h₁ : Unbounded r <| ⋃ x, s x) (h₂ : #β < Order.cof (swap rᶜ)) :\n    ∃ x : β, Unbounded r (s x) := by\n  rw [← sUnion_range] at h₁\n  rcases unbounded_of_unbounded_sUnion r h₁ (mk_range_le.trans_lt h₂) with ⟨_, ⟨x, rfl⟩, u⟩\n  exact ⟨x, u⟩\n\n"}
{"name":"Ordinal.infinite_pigeonhole","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"β α : Type u\nf : β → α\nh₁ : LE.le Cardinal.aleph0 (Cardinal.mk β)\nh₂ : LT.lt (Cardinal.mk α) (Cardinal.mk β).ord.cof\n⊢ Exists fun a => Eq (Cardinal.mk ↑(Set.preimage f (Singleton.singleton a))) (Cardinal.mk β)","decl":"/-- The infinite pigeonhole principle -/\ntheorem infinite_pigeonhole {β α : Type u} (f : β → α) (h₁ : ℵ₀ ≤ #β) (h₂ : #α < (#β).ord.cof) :\n    ∃ a : α, #(f ⁻¹' {a}) = #β := by\n  have : ∃ a, #β ≤ #(f ⁻¹' {a}) := by\n    by_contra! h\n    apply mk_univ.not_lt\n    rw [← preimage_univ, ← iUnion_of_singleton, preimage_iUnion]\n    exact\n      mk_iUnion_le_sum_mk.trans_lt\n        ((sum_le_iSup _).trans_lt <| mul_lt_of_lt h₁ (h₂.trans_le <| cof_ord_le _) (iSup_lt h₂ h))\n  cases' this with x h\n  refine ⟨x, h.antisymm' ?_⟩\n  rw [le_mk_iff_exists_set]\n  exact ⟨_, rfl⟩\n\n"}
{"name":"Ordinal.infinite_pigeonhole_card","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"β α : Type u\nf : β → α\nθ : Cardinal.{u}\nhθ : LE.le θ (Cardinal.mk β)\nh₁ : LE.le Cardinal.aleph0 θ\nh₂ : LT.lt (Cardinal.mk α) θ.ord.cof\n⊢ Exists fun a => LE.le θ (Cardinal.mk ↑(Set.preimage f (Singleton.singleton a)))","decl":"/-- Pigeonhole principle for a cardinality below the cardinality of the domain -/\ntheorem infinite_pigeonhole_card {β α : Type u} (f : β → α) (θ : Cardinal) (hθ : θ ≤ #β)\n    (h₁ : ℵ₀ ≤ θ) (h₂ : #α < θ.ord.cof) : ∃ a : α, θ ≤ #(f ⁻¹' {a}) := by\n  rcases le_mk_iff_exists_set.1 hθ with ⟨s, rfl⟩\n  cases' infinite_pigeonhole (f ∘ Subtype.val : s → α) h₁ h₂ with a ha\n  use a; rw [← ha, @preimage_comp _ _ _ Subtype.val f]\n  exact mk_preimage_of_injective _ _ Subtype.val_injective\n\n"}
{"name":"Ordinal.infinite_pigeonhole_set","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"β α : Type u\ns : Set β\nf : ↑s → α\nθ : Cardinal.{u}\nhθ : LE.le θ (Cardinal.mk ↑s)\nh₁ : LE.le Cardinal.aleph0 θ\nh₂ : LT.lt (Cardinal.mk α) θ.ord.cof\n⊢ Exists fun a => Exists fun t => Exists fun h => And (LE.le θ (Cardinal.mk ↑t)) (∀ ⦃x : β⦄ (hx : Membership.mem t x), Eq (f ⟨x, ⋯⟩) a)","decl":"theorem infinite_pigeonhole_set {β α : Type u} {s : Set β} (f : s → α) (θ : Cardinal)\n    (hθ : θ ≤ #s) (h₁ : ℵ₀ ≤ θ) (h₂ : #α < θ.ord.cof) :\n    ∃ (a : α) (t : Set β) (h : t ⊆ s), θ ≤ #t ∧ ∀ ⦃x⦄ (hx : x ∈ t), f ⟨x, h hx⟩ = a := by\n  cases' infinite_pigeonhole_card f θ hθ h₁ h₂ with a ha\n  refine ⟨a, { x | ∃ h, f ⟨x, h⟩ = a }, ?_, ?_, ?_⟩\n  · rintro x ⟨hx, _⟩\n    exact hx\n  · refine\n      ha.trans\n        (ge_of_eq <|\n          Quotient.sound ⟨Equiv.trans ?_ (Equiv.subtypeSubtypeEquivSubtypeExists _ _).symm⟩)\n    simp only [coe_eq_subtype, mem_singleton_iff, mem_preimage, mem_setOf_eq]\n    rfl\n  rintro x ⟨_, hx'⟩; exact hx'\n\n"}
{"name":"Cardinal.IsStrongLimit.ne_zero","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u_1}\nh : c.IsStrongLimit\n⊢ Ne c 0","decl":"theorem IsStrongLimit.ne_zero {c} (h : IsStrongLimit c) : c ≠ 0 :=\n  h.1\n\n"}
{"name":"Cardinal.IsStrongLimit.two_power_lt","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"x c : Cardinal.{u_1}\nh : c.IsStrongLimit\na✝ : LT.lt x c\n⊢ LT.lt (HPow.hPow 2 x) c","decl":"theorem IsStrongLimit.two_power_lt {x c} (h : IsStrongLimit c) : x < c → (2^x) < c :=\n  h.2 x\n\n"}
{"name":"Cardinal.isStrongLimit_aleph0","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"⊢ Cardinal.aleph0.IsStrongLimit","decl":"theorem isStrongLimit_aleph0 : IsStrongLimit ℵ₀ :=\n  ⟨aleph0_ne_zero, fun x hx => by\n    rcases lt_aleph0.1 hx with ⟨n, rfl⟩\n    exact mod_cast nat_lt_aleph0 (2 ^ n)⟩\n\n"}
{"name":"Cardinal.IsStrongLimit.isSuccLimit","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u_1}\nH : c.IsStrongLimit\n⊢ Order.IsSuccLimit c","decl":"protected theorem IsStrongLimit.isSuccLimit {c} (H : IsStrongLimit c) : IsSuccLimit c := by\n  rw [Cardinal.isSuccLimit_iff]\n  exact ⟨H.ne_zero, isSuccPrelimit_of_succ_lt fun x h =>\n    (succ_le_of_lt <| cantor x).trans_lt (H.two_power_lt h)⟩\n\n"}
{"name":"Cardinal.IsStrongLimit.isSuccPrelimit","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u_1}\nH : c.IsStrongLimit\n⊢ Order.IsSuccPrelimit c","decl":"protected theorem IsStrongLimit.isSuccPrelimit {c} (H : IsStrongLimit c) : IsSuccPrelimit c :=\n  H.isSuccLimit.isSuccPrelimit\n\n"}
{"name":"Cardinal.IsStrongLimit.aleph0_le","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u_1}\nH : c.IsStrongLimit\n⊢ LE.le Cardinal.aleph0 c","decl":"theorem IsStrongLimit.aleph0_le {c} (H : IsStrongLimit c) : ℵ₀ ≤ c :=\n  aleph0_le_of_isSuccLimit H.isSuccLimit\n\n"}
{"name":"Cardinal.IsStrongLimit.isLimit","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u_1}\nH : c.IsStrongLimit\n⊢ c.IsLimit","decl":"set_option linter.deprecated false in\n@[deprecated IsStrongLimit.isSuccLimit (since := \"2024-09-17\")]\ntheorem IsStrongLimit.isLimit {c} (H : IsStrongLimit c) : IsLimit c :=\n  ⟨H.ne_zero, H.isSuccPrelimit⟩\n\n"}
{"name":"Cardinal.isStrongLimit_beth","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\nH : Order.IsSuccPrelimit o\n⊢ (Cardinal.beth o).IsStrongLimit","decl":"theorem isStrongLimit_beth {o : Ordinal} (H : IsSuccPrelimit o) : IsStrongLimit (ℶ_ o) := by\n  rcases eq_or_ne o 0 with (rfl | h)\n  · rw [beth_zero]\n    exact isStrongLimit_aleph0\n  · refine ⟨beth_ne_zero o, fun a ha => ?_⟩\n    rw [beth_limit] at ha\n    · rcases exists_lt_of_lt_ciSup' ha with ⟨⟨i, hi⟩, ha⟩\n      have := power_le_power_left two_ne_zero ha.le\n      rw [← beth_succ] at this\n      exact this.trans_lt (beth_lt.2 (H.succ_lt hi))\n    · rw [isLimit_iff]\n      exact ⟨h, H⟩\n\n"}
{"name":"Cardinal.mk_bounded_subset","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u_1\nh : ∀ (x : Cardinal.{u_1}), LT.lt x (Cardinal.mk α) → LT.lt (HPow.hPow 2 x) (Cardinal.mk α)\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nhr : Eq (Cardinal.mk α).ord (Ordinal.type r)\n⊢ Eq (Cardinal.mk (Subtype fun s => Set.Bounded r s)) (Cardinal.mk α)","decl":"theorem mk_bounded_subset {α : Type*} (h : ∀ x < #α, (2^x) < #α) {r : α → α → Prop}\n    [IsWellOrder α r] (hr : (#α).ord = type r) : #{ s : Set α // Bounded r s } = #α := by\n  rcases eq_or_ne #α 0 with (ha | ha)\n  · rw [ha]\n    haveI := mk_eq_zero_iff.1 ha\n    rw [mk_eq_zero_iff]\n    constructor\n    rintro ⟨s, hs⟩\n    exact (not_unbounded_iff s).2 hs (unbounded_of_isEmpty s)\n  have h' : IsStrongLimit #α := ⟨ha, h⟩\n  have ha := h'.aleph0_le\n  apply le_antisymm\n  · have : { s : Set α | Bounded r s } = ⋃ i, 𝒫{ j | r j i } := setOf_exists _\n    rw [← coe_setOf, this]\n    refine mk_iUnion_le_sum_mk.trans ((sum_le_iSup (fun i => #(𝒫{ j | r j i }))).trans\n      ((mul_le_max_of_aleph0_le_left ha).trans ?_))\n    rw [max_eq_left]\n    apply ciSup_le' _\n    intro i\n    rw [mk_powerset]\n    apply (h'.two_power_lt _).le\n    rw [coe_setOf, card_typein, ← lt_ord, hr]\n    apply typein_lt_type\n  · refine @mk_le_of_injective α _ (fun x => Subtype.mk {x} ?_) ?_\n    · apply bounded_singleton\n      rw [← hr]\n      apply isLimit_ord ha\n    · intro a b hab\n      simpa [singleton_eq_singleton_iff] using hab\n\n"}
{"name":"Cardinal.mk_subset_mk_lt_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u_1\nh : ∀ (x : Cardinal.{u_1}), LT.lt x (Cardinal.mk α) → LT.lt (HPow.hPow 2 x) (Cardinal.mk α)\n⊢ Eq (Cardinal.mk (Subtype fun s => LT.lt (Cardinal.mk ↑s) (Cardinal.mk α).ord.cof)) (Cardinal.mk α)","decl":"theorem mk_subset_mk_lt_cof {α : Type*} (h : ∀ x < #α, (2^x) < #α) :\n    #{ s : Set α // #s < cof (#α).ord } = #α := by\n  rcases eq_or_ne #α 0 with (ha | ha)\n  · simp [ha]\n  have h' : IsStrongLimit #α := ⟨ha, h⟩\n  rcases ord_eq α with ⟨r, wo, hr⟩\n  haveI := wo\n  apply le_antisymm\n  · conv_rhs => rw [← mk_bounded_subset h hr]\n    apply mk_le_mk_of_subset\n    intro s hs\n    rw [hr] at hs\n    exact lt_cof_type hs\n  · refine @mk_le_of_injective α _ (fun x => Subtype.mk {x} ?_) ?_\n    · rw [mk_singleton]\n      exact one_lt_aleph0.trans_le (aleph0_le_cof.2 (isLimit_ord h'.aleph0_le))\n    · intro a b hab\n      simpa [singleton_eq_singleton_iff] using hab\n\n"}
{"name":"Cardinal.IsRegular.aleph0_le","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u_1}\nH : c.IsRegular\n⊢ LE.le Cardinal.aleph0 c","decl":"theorem IsRegular.aleph0_le {c : Cardinal} (H : c.IsRegular) : ℵ₀ ≤ c :=\n  H.1\n\n"}
{"name":"Cardinal.IsRegular.cof_eq","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u_1}\nH : c.IsRegular\n⊢ Eq c.ord.cof c","decl":"theorem IsRegular.cof_eq {c : Cardinal} (H : c.IsRegular) : c.ord.cof = c :=\n  (cof_ord_le c).antisymm H.2\n\n"}
{"name":"Cardinal.IsRegular.cof_omega_eq","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\nH : (Cardinal.aleph o).IsRegular\n⊢ Eq (Ordinal.omega o).cof (Cardinal.aleph o)","decl":"theorem IsRegular.cof_omega_eq {o : Ordinal} (H : (ℵ_ o).IsRegular) : (ω_ o).cof = ℵ_ o := by\n  rw [← ord_aleph, H.cof_eq]\n\n"}
{"name":"Cardinal.IsRegular.pos","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u_1}\nH : c.IsRegular\n⊢ LT.lt 0 c","decl":"theorem IsRegular.pos {c : Cardinal} (H : c.IsRegular) : 0 < c :=\n  aleph0_pos.trans_le H.1\n\n"}
{"name":"Cardinal.IsRegular.nat_lt","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u_1}\nH : c.IsRegular\nn : Nat\n⊢ LT.lt (↑n) c","decl":"theorem IsRegular.nat_lt {c : Cardinal} (H : c.IsRegular) (n : ℕ) : n < c :=\n  lt_of_lt_of_le (nat_lt_aleph0 n) H.aleph0_le\n\n"}
{"name":"Cardinal.IsRegular.ord_pos","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u_1}\nH : c.IsRegular\n⊢ LT.lt 0 c.ord","decl":"theorem IsRegular.ord_pos {c : Cardinal} (H : c.IsRegular) : 0 < c.ord := by\n  rw [Cardinal.lt_ord, card_zero]\n  exact H.pos\n\n"}
{"name":"Cardinal.isRegular_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\nh : o.IsLimit\n⊢ o.cof.IsRegular","decl":"theorem isRegular_cof {o : Ordinal} (h : o.IsLimit) : IsRegular o.cof :=\n  ⟨aleph0_le_cof.2 h, (cof_cof o).ge⟩\n\n"}
{"name":"Cardinal.isRegular_aleph0","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"⊢ Cardinal.aleph0.IsRegular","decl":"theorem isRegular_aleph0 : IsRegular ℵ₀ :=\n  ⟨le_rfl, by simp⟩\n\n"}
{"name":"Cardinal.fact_isRegular_aleph0","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"⊢ Fact Cardinal.aleph0.IsRegular","decl":"lemma fact_isRegular_aleph0 : Fact Cardinal.aleph0.IsRegular where\n  out := Cardinal.isRegular_aleph0\n\n"}
{"name":"Cardinal.isRegular_succ","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u}\nh : LE.le Cardinal.aleph0 c\n⊢ (Order.succ c).IsRegular","decl":"theorem isRegular_succ {c : Cardinal.{u}} (h : ℵ₀ ≤ c) : IsRegular (succ c) :=\n  ⟨h.trans (le_succ c),\n    succ_le_of_lt\n      (by\n        have αe := Cardinal.mk_out (succ c)\n        set α := (succ c).out\n        rcases ord_eq α with ⟨r, wo, re⟩\n        have := isLimit_ord (h.trans (le_succ _))\n        rw [← αe, re] at this ⊢\n        rcases cof_eq' r this with ⟨S, H, Se⟩\n        rw [← Se]\n        apply lt_imp_lt_of_le_imp_le fun h => mul_le_mul_right' h c\n        rw [mul_eq_self h, ← succ_le_iff, ← αe, ← sum_const']\n        refine le_trans ?_ (sum_le_sum (fun (x : S) => card (typein r (x : α))) _ fun i => ?_)\n        · simp only [← card_typein, ← mk_sigma]\n          exact\n            ⟨Embedding.ofSurjective (fun x => x.2.1) fun a =>\n                let ⟨b, h, ab⟩ := H a\n                ⟨⟨⟨_, h⟩, _, ab⟩, rfl⟩⟩\n        · rw [← lt_succ_iff, ← lt_ord, ← αe, re]\n          apply typein_lt_type)⟩\n\n"}
{"name":"Cardinal.isRegular_aleph_one","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"⊢ (Cardinal.aleph 1).IsRegular","decl":"theorem isRegular_aleph_one : IsRegular ℵ₁ := by\n  rw [← succ_aleph0]\n  exact isRegular_succ le_rfl\n\n"}
{"name":"Cardinal.isRegular_preAleph_succ","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\nh : LE.le Ordinal.omega0 o\n⊢ (Cardinal.preAleph (Order.succ o)).IsRegular","decl":"theorem isRegular_preAleph_succ {o : Ordinal} (h : ω ≤ o) : IsRegular (preAleph (succ o)) := by\n  rw [preAleph_succ]\n  exact isRegular_succ (aleph0_le_preAleph.2 h)\n\n"}
{"name":"Cardinal.isRegular_aleph'_succ","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\nh : LE.le Ordinal.omega0 o\n⊢ (Cardinal.aleph' (Order.succ o)).IsRegular","decl":"set_option linter.deprecated false in\n@[deprecated isRegular_preAleph_succ (since := \"2024-10-22\")]\ntheorem isRegular_aleph'_succ {o : Ordinal} (h : ω ≤ o) : IsRegular (aleph' (succ o)) := by\n  rw [aleph'_succ]\n  exact isRegular_succ (aleph0_le_aleph'.2 h)\n\n"}
{"name":"Cardinal.isRegular_aleph_succ","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u_1}\n⊢ (Cardinal.aleph (Order.succ o)).IsRegular","decl":"theorem isRegular_aleph_succ (o : Ordinal) : IsRegular (ℵ_ (succ o)) := by\n  rw [aleph_succ]\n  exact isRegular_succ (aleph0_le_aleph o)\n\n"}
{"name":"Cardinal.infinite_pigeonhole_card_lt","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"β α : Type u\nf : β → α\nw : LT.lt (Cardinal.mk α) (Cardinal.mk β)\nw' : LE.le Cardinal.aleph0 (Cardinal.mk α)\n⊢ Exists fun a => LT.lt (Cardinal.mk α) (Cardinal.mk ↑(Set.preimage f (Singleton.singleton a)))","decl":"/-- A function whose codomain's cardinality is infinite but strictly smaller than its domain's\nhas a fiber with cardinality strictly great than the codomain.\n-/\ntheorem infinite_pigeonhole_card_lt {β α : Type u} (f : β → α) (w : #α < #β) (w' : ℵ₀ ≤ #α) :\n    ∃ a : α, #α < #(f ⁻¹' {a}) := by\n  simp_rw [← succ_le_iff]\n  exact\n    Ordinal.infinite_pigeonhole_card f (succ #α) (succ_le_of_lt w) (w'.trans (lt_succ _).le)\n      ((lt_succ _).trans_le (isRegular_succ w').2.ge)\n\n"}
{"name":"Cardinal.exists_infinite_fiber","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"β α : Type u\nf : β → α\nw : LT.lt (Cardinal.mk α) (Cardinal.mk β)\nw' : Infinite α\n⊢ Exists fun a => Infinite ↑(Set.preimage f (Singleton.singleton a))","decl":"/-- A function whose codomain's cardinality is infinite but strictly smaller than its domain's\nhas an infinite fiber.\n-/\ntheorem exists_infinite_fiber {β α : Type u} (f : β → α) (w : #α < #β) (w' : Infinite α) :\n    ∃ a : α, Infinite (f ⁻¹' {a}) := by\n  simp_rw [Cardinal.infinite_iff] at w' ⊢\n  cases' infinite_pigeonhole_card_lt f w w' with a ha\n  exact ⟨a, w'.trans ha.le⟩\n\n"}
{"name":"Cardinal.le_range_of_union_finset_eq_top","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Infinite β\nf : α → Finset β\nw : Eq (Set.iUnion fun a => ↑(f a)) Top.top\n⊢ LE.le (Cardinal.mk β) (Cardinal.mk ↑(Set.range f))","decl":"/-- If an infinite type `β` can be expressed as a union of finite sets,\nthen the cardinality of the collection of those finite sets\nmust be at least the cardinality of `β`.\n-/\ntheorem le_range_of_union_finset_eq_top {α β : Type*} [Infinite β] (f : α → Finset β)\n    (w : ⋃ a, (f a : Set β) = ⊤) : #β ≤ #(range f) := by\n  have k : _root_.Infinite (range f) := by\n    rw [infinite_coe_iff]\n    apply mt (union_finset_finite_of_range_finite f)\n    rw [w]\n    exact infinite_univ\n  by_contra h\n  simp only [not_le] at h\n  let u : ∀ b, ∃ a, b ∈ f a := fun b => by simpa using (w.ge :) (Set.mem_univ b)\n  let u' : β → range f := fun b => ⟨f (u b).choose, by simp⟩\n  have v' : ∀ a, u' ⁻¹' {⟨f a, by simp⟩} ≤ f a := by\n    rintro a p m\n    simp? [u']  at m says simp only [mem_preimage, mem_singleton_iff, Subtype.mk.injEq, u'] at m\n    rw [← m]\n    apply fun b => (u b).choose_spec\n  obtain ⟨⟨-, ⟨a, rfl⟩⟩, p⟩ := exists_infinite_fiber u' h k\n  exact (@Infinite.of_injective _ _ p (inclusion (v' a)) (inclusion_injective _)).false\n\n"}
{"name":"Cardinal.lsub_lt_ord_lift_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.lift.{v, u} (Cardinal.mk ι)) c\na✝ : ∀ (i : ι), LT.lt (f i) c.ord\n⊢ LT.lt (Ordinal.lsub f) c.ord","decl":"theorem lsub_lt_ord_lift_of_isRegular {ι} {f : ι → Ordinal} {c} (hc : IsRegular c)\n    (hι : Cardinal.lift.{v, u} #ι < c) : (∀ i, f i < c.ord) → Ordinal.lsub.{u, v} f < c.ord :=\n  lsub_lt_ord_lift (by rwa [hc.cof_eq])\n\n"}
{"name":"Cardinal.lsub_lt_ord_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type (max u_1 u_2)\nf : ι → Ordinal.{max u_1 u_2}\nc : Cardinal.{max u_1 u_2}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.mk ι) c\na✝ : ∀ (i : ι), LT.lt (f i) c.ord\n⊢ LT.lt (Ordinal.lsub f) c.ord","decl":"theorem lsub_lt_ord_of_isRegular {ι} {f : ι → Ordinal} {c} (hc : IsRegular c) (hι : #ι < c) :\n    (∀ i, f i < c.ord) → Ordinal.lsub f < c.ord :=\n  lsub_lt_ord (by rwa [hc.cof_eq])\n\n"}
{"name":"Cardinal.iSup_lt_ord_lift_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.lift.{v, u} (Cardinal.mk ι)) c\na✝ : ∀ (i : ι), LT.lt (f i) c.ord\n⊢ LT.lt (iSup f) c.ord","decl":"theorem iSup_lt_ord_lift_of_isRegular {ι} {f : ι → Ordinal} {c} (hc : IsRegular c)\n    (hι : Cardinal.lift.{v, u} #ι < c) : (∀ i, f i < c.ord) → iSup f < c.ord :=\n  iSup_lt_ord_lift (by rwa [hc.cof_eq])\n\n"}
{"name":"Cardinal.sup_lt_ord_lift_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.lift.{v, u} (Cardinal.mk ι)) c\na✝ : ∀ (i : ι), LT.lt (f i) c.ord\n⊢ LT.lt (Ordinal.sup f) c.ord","decl":"set_option linter.deprecated false in\n@[deprecated iSup_lt_ord_lift_of_isRegular (since := \"2024-08-27\")]\ntheorem sup_lt_ord_lift_of_isRegular {ι} {f : ι → Ordinal} {c} (hc : IsRegular c)\n    (hι : Cardinal.lift.{v, u} #ι < c) : (∀ i, f i < c.ord) → Ordinal.sup.{u, v} f < c.ord :=\n  iSup_lt_ord_lift_of_isRegular hc hι\n\n"}
{"name":"Cardinal.iSup_lt_ord_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u_1\nf : ι → Ordinal.{u_1}\nc : Cardinal.{u_1}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.mk ι) c\na✝ : ∀ (i : ι), LT.lt (f i) c.ord\n⊢ LT.lt (iSup f) c.ord","decl":"theorem iSup_lt_ord_of_isRegular {ι} {f : ι → Ordinal} {c} (hc : IsRegular c) (hι : #ι < c) :\n    (∀ i, f i < c.ord) → iSup f < c.ord :=\n  iSup_lt_ord (by rwa [hc.cof_eq])\n\n"}
{"name":"Cardinal.sup_lt_ord_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type (max u_1 u_2)\nf : ι → Ordinal.{max u_1 u_2}\nc : Cardinal.{max u_1 u_2}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.mk ι) c\na✝ : ∀ (i : ι), LT.lt (f i) c.ord\n⊢ LT.lt (Ordinal.sup f) c.ord","decl":"set_option linter.deprecated false in\n@[deprecated iSup_lt_ord_of_isRegular (since := \"2024-08-27\")]\ntheorem sup_lt_ord_of_isRegular {ι} {f : ι → Ordinal} {c} (hc : IsRegular c) (hι : #ι < c) :\n    (∀ i, f i < c.ord) → Ordinal.sup f < c.ord :=\n  iSup_lt_ord_of_isRegular hc hι\n\n"}
{"name":"Cardinal.blsub_lt_ord_lift_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nho : LT.lt (Cardinal.lift.{v, u} o.card) c\na✝ : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), LT.lt (f i hi) c.ord\n⊢ LT.lt (o.blsub f) c.ord","decl":"theorem blsub_lt_ord_lift_of_isRegular {o : Ordinal} {f : ∀ a < o, Ordinal} {c} (hc : IsRegular c)\n    (ho : Cardinal.lift.{v, u} o.card < c) :\n    (∀ i hi, f i hi < c.ord) → Ordinal.blsub.{u, v} o f < c.ord :=\n  blsub_lt_ord_lift (by rwa [hc.cof_eq])\n\n"}
{"name":"Cardinal.blsub_lt_ord_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{max u_1 u_2}\nf : (a : Ordinal.{max u_1 u_2}) → LT.lt a o → Ordinal.{max u_1 u_2}\nc : Cardinal.{max u_1 u_2}\nhc : c.IsRegular\nho : LT.lt o.card c\na✝ : ∀ (i : Ordinal.{max u_1 u_2}) (hi : LT.lt i o), LT.lt (f i hi) c.ord\n⊢ LT.lt (o.blsub f) c.ord","decl":"theorem blsub_lt_ord_of_isRegular {o : Ordinal} {f : ∀ a < o, Ordinal} {c} (hc : IsRegular c)\n    (ho : o.card < c) : (∀ i hi, f i hi < c.ord) → Ordinal.blsub o f < c.ord :=\n  blsub_lt_ord (by rwa [hc.cof_eq])\n\n"}
{"name":"Cardinal.bsup_lt_ord_lift_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.lift.{v, u} o.card) c\na✝ : ∀ (i : Ordinal.{u}) (hi : LT.lt i o), LT.lt (f i hi) c.ord\n⊢ LT.lt (o.bsup f) c.ord","decl":"theorem bsup_lt_ord_lift_of_isRegular {o : Ordinal} {f : ∀ a < o, Ordinal} {c} (hc : IsRegular c)\n    (hι : Cardinal.lift.{v, u} o.card < c) :\n    (∀ i hi, f i hi < c.ord) → Ordinal.bsup.{u, v} o f < c.ord :=\n  bsup_lt_ord_lift (by rwa [hc.cof_eq])\n\n"}
{"name":"Cardinal.bsup_lt_ord_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{max u_1 u_2}\nf : (a : Ordinal.{max u_1 u_2}) → LT.lt a o → Ordinal.{max u_1 u_2}\nc : Cardinal.{max u_1 u_2}\nhc : c.IsRegular\nhι : LT.lt o.card c\na✝ : ∀ (i : Ordinal.{max u_1 u_2}) (hi : LT.lt i o), LT.lt (f i hi) c.ord\n⊢ LT.lt (o.bsup f) c.ord","decl":"theorem bsup_lt_ord_of_isRegular {o : Ordinal} {f : ∀ a < o, Ordinal} {c} (hc : IsRegular c)\n    (hι : o.card < c) : (∀ i hi, f i hi < c.ord) → Ordinal.bsup o f < c.ord :=\n  bsup_lt_ord (by rwa [hc.cof_eq])\n\n"}
{"name":"Cardinal.iSup_lt_lift_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Cardinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.lift.{v, u} (Cardinal.mk ι)) c\na✝ : ∀ (i : ι), LT.lt (f i) c\n⊢ LT.lt (iSup f) c","decl":"theorem iSup_lt_lift_of_isRegular {ι} {f : ι → Cardinal} {c} (hc : IsRegular c)\n    (hι : Cardinal.lift.{v, u} #ι < c) : (∀ i, f i < c) → iSup.{max u v + 1, u + 1} f < c :=\n  iSup_lt_lift.{u, v} (by rwa [hc.cof_eq])\n\n"}
{"name":"Cardinal.iSup_lt_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u_1\nf : ι → Cardinal.{u_1}\nc : Cardinal.{u_1}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.mk ι) c\na✝ : ∀ (i : ι), LT.lt (f i) c\n⊢ LT.lt (iSup f) c","decl":"theorem iSup_lt_of_isRegular {ι} {f : ι → Cardinal} {c} (hc : IsRegular c) (hι : #ι < c) :\n    (∀ i, f i < c) → iSup f < c :=\n  iSup_lt (by rwa [hc.cof_eq])\n\n"}
{"name":"Cardinal.sum_lt_lift_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Cardinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.lift.{v, u} (Cardinal.mk ι)) c\nhf : ∀ (i : ι), LT.lt (f i) c\n⊢ LT.lt (Cardinal.sum f) c","decl":"theorem sum_lt_lift_of_isRegular {ι : Type u} {f : ι → Cardinal} {c : Cardinal} (hc : IsRegular c)\n    (hι : Cardinal.lift.{v, u} #ι < c) (hf : ∀ i, f i < c) : sum f < c :=\n  (sum_le_iSup_lift _).trans_lt <| mul_lt_of_lt hc.1 hι (iSup_lt_lift_of_isRegular hc hι hf)\n\n"}
{"name":"Cardinal.sum_lt_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Cardinal.{u}\nc : Cardinal.{u}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.mk ι) c\na✝ : ∀ (i : ι), LT.lt (f i) c\n⊢ LT.lt (Cardinal.sum f) c","decl":"theorem sum_lt_of_isRegular {ι : Type u} {f : ι → Cardinal} {c : Cardinal} (hc : IsRegular c)\n    (hι : #ι < c) : (∀ i, f i < c) → sum f < c :=\n  sum_lt_lift_of_isRegular.{u, u} hc (by rwa [lift_id])\n\n"}
{"name":"Cardinal.card_lt_of_card_iUnion_lt","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι α : Type u\nt : ι → Set α\nc : Cardinal.{u}\nh : LT.lt (Cardinal.mk ↑(Set.iUnion fun i => t i)) c\ni : ι\n⊢ LT.lt (Cardinal.mk ↑(t i)) c","decl":"@[simp]\ntheorem card_lt_of_card_iUnion_lt {ι : Type u} {α : Type u} {t : ι → Set α} {c : Cardinal}\n    (h : #(⋃ i, t i) < c) (i : ι) : #(t i) < c :=\n  lt_of_le_of_lt (Cardinal.mk_le_mk_of_subset <| subset_iUnion _ _) h\n\n"}
{"name":"Cardinal.card_iUnion_lt_iff_forall_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι α : Type u\nt : ι → Set α\nc : Cardinal.{u}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.mk ι) c\n⊢ Iff (LT.lt (Cardinal.mk ↑(Set.iUnion fun i => t i)) c) (∀ (i : ι), LT.lt (Cardinal.mk ↑(t i)) c)","decl":"@[simp]\ntheorem card_iUnion_lt_iff_forall_of_isRegular {ι : Type u} {α : Type u} {t : ι → Set α}\n    {c : Cardinal} (hc : c.IsRegular) (hι : #ι < c) : #(⋃ i, t i) < c ↔ ∀ i, #(t i) < c := by\n  refine ⟨card_lt_of_card_iUnion_lt, fun h ↦ ?_⟩\n  apply lt_of_le_of_lt (Cardinal.mk_sUnion_le _)\n  apply Cardinal.mul_lt_of_lt hc.aleph0_le\n    (lt_of_le_of_lt Cardinal.mk_range_le hι)\n  apply Cardinal.iSup_lt_of_isRegular hc (lt_of_le_of_lt Cardinal.mk_range_le hι)\n  simpa\n\n"}
{"name":"Cardinal.card_lt_of_card_biUnion_lt","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α β : Type u\ns : Set α\nt : (a : α) → Membership.mem s a → Set β\nc : Cardinal.{u}\nh : LT.lt (Cardinal.mk ↑(Set.iUnion fun a => Set.iUnion fun h => t a h)) c\na : α\nha : Membership.mem s a\n⊢ LT.lt (Cardinal.mk ↑(t a ha)) c","decl":"theorem card_lt_of_card_biUnion_lt {α β : Type u} {s : Set α} {t : ∀ a ∈ s, Set β} {c : Cardinal}\n    (h : #(⋃ a ∈ s, t a ‹_›) < c) (a : α) (ha : a ∈ s) : # (t a ha) < c := by\n  rw [biUnion_eq_iUnion] at h\n  have := card_lt_of_card_iUnion_lt h\n  simp_all only [iUnion_coe_set,\n    Subtype.forall]\n\n"}
{"name":"Cardinal.card_biUnion_lt_iff_forall_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α β : Type u\ns : Set α\nt : (a : α) → Membership.mem s a → Set β\nc : Cardinal.{u}\nhc : c.IsRegular\nhs : LT.lt (Cardinal.mk ↑s) c\n⊢ Iff (LT.lt (Cardinal.mk ↑(Set.iUnion fun a => Set.iUnion fun h => t a h)) c) (∀ (a : α) (ha : Membership.mem s a), LT.lt (Cardinal.mk ↑(t a ha)) c)","decl":"theorem card_biUnion_lt_iff_forall_of_isRegular {α β : Type u} {s : Set α} {t : ∀ a ∈ s, Set β}\n    {c : Cardinal} (hc : c.IsRegular) (hs : #s < c) :\n    #(⋃ a ∈ s, t a ‹_›) < c ↔ ∀ a (ha : a ∈ s), # (t a ha) < c := by\n  rw [biUnion_eq_iUnion, card_iUnion_lt_iff_forall_of_isRegular hc hs, SetCoe.forall']\n\n"}
{"name":"Cardinal.nfpFamily_lt_ord_lift_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v} → Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.lift.{v, u} (Cardinal.mk ι)) c\nhc' : Ne c Cardinal.aleph0\nhf : ∀ (i : ι) (b : Ordinal.{max u v}), LT.lt b c.ord → LT.lt (f i b) c.ord\na : Ordinal.{max u v}\nha : LT.lt a c.ord\n⊢ LT.lt (Ordinal.nfpFamily f a) c.ord","decl":"theorem nfpFamily_lt_ord_lift_of_isRegular {ι} {f : ι → Ordinal → Ordinal} {c} (hc : IsRegular c)\n    (hι : Cardinal.lift.{v, u} #ι < c) (hc' : c ≠ ℵ₀) (hf : ∀ (i), ∀ b < c.ord, f i b < c.ord) {a}\n    (ha : a < c.ord) : nfpFamily f a < c.ord := by\n  apply nfpFamily_lt_ord_lift _ _ hf ha <;> rw [hc.cof_eq]\n  · exact lt_of_le_of_ne hc.1 hc'.symm\n  · exact hι\n\n"}
{"name":"Cardinal.nfpFamily_lt_ord_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{u} → Ordinal.{u}\nc : Cardinal.{u}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.mk ι) c\nhc' : Ne c Cardinal.aleph0\na : Ordinal.{u}\nhf : ∀ (i : ι) (b : Ordinal.{u}), LT.lt b c.ord → LT.lt (f i b) c.ord\na✝ : LT.lt a c.ord\n⊢ LT.lt (Ordinal.nfpFamily f a) c.ord","decl":"theorem nfpFamily_lt_ord_of_isRegular {ι} {f : ι → Ordinal → Ordinal} {c} (hc : IsRegular c)\n    (hι : #ι < c) (hc' : c ≠ ℵ₀) {a} (hf : ∀ (i), ∀ b < c.ord, f i b < c.ord) :\n    a < c.ord → nfpFamily.{u, u} f a < c.ord :=\n  nfpFamily_lt_ord_lift_of_isRegular hc (by rwa [lift_id]) hc' hf\n\n"}
{"name":"Cardinal.nfpBFamily_lt_ord_lift_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v} → Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nho : LT.lt (Cardinal.lift.{v, u} o.card) c\nhc' : Ne c Cardinal.aleph0\nhf : ∀ (i : Ordinal.{u}) (hi : LT.lt i o) (b : Ordinal.{max u v}), LT.lt b c.ord → LT.lt (f i hi b) c.ord\na : Ordinal.{max u v}\na✝ : LT.lt a c.ord\n⊢ LT.lt (o.nfpBFamily f a) c.ord","decl":"set_option linter.deprecated false in\n@[deprecated nfpFamily_lt_ord_lift_of_isRegular (since := \"2024-10-14\")]\ntheorem nfpBFamily_lt_ord_lift_of_isRegular {o : Ordinal} {f : ∀ a < o, Ordinal → Ordinal} {c}\n    (hc : IsRegular c) (ho : Cardinal.lift.{v, u} o.card < c) (hc' : c ≠ ℵ₀)\n    (hf : ∀ (i hi), ∀ b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord → nfpBFamily.{u, v} o f a < c.ord :=\n  nfpFamily_lt_ord_lift_of_isRegular hc (by rwa [mk_toType]) hc' fun _ => hf _ _\n\n"}
{"name":"Cardinal.nfpBFamily_lt_ord_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{u} → Ordinal.{u}\nc : Cardinal.{u}\nhc : c.IsRegular\nho : LT.lt o.card c\nhc' : Ne c Cardinal.aleph0\nhf : ∀ (i : Ordinal.{u}) (hi : LT.lt i o) (b : Ordinal.{u}), LT.lt b c.ord → LT.lt (f i hi b) c.ord\na : Ordinal.{u}\na✝ : LT.lt a c.ord\n⊢ LT.lt (o.nfpBFamily f a) c.ord","decl":"set_option linter.deprecated false in\n@[deprecated nfpFamily_lt_ord_of_isRegular (since := \"2024-10-14\")]\ntheorem nfpBFamily_lt_ord_of_isRegular {o : Ordinal} {f : ∀ a < o, Ordinal → Ordinal} {c}\n    (hc : IsRegular c) (ho : o.card < c) (hc' : c ≠ ℵ₀)\n    (hf : ∀ (i hi), ∀ b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord → nfpBFamily.{u, u} o f a < c.ord :=\n  nfpBFamily_lt_ord_lift_of_isRegular hc (by rwa [lift_id]) hc' hf\n\n"}
{"name":"Cardinal.nfp_lt_ord_of_isRegular","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"f : Ordinal.{u_1} → Ordinal.{u_1}\nc : Cardinal.{u_1}\nhc : c.IsRegular\nhc' : Ne c Cardinal.aleph0\nhf : ∀ (i : Ordinal.{u_1}), LT.lt i c.ord → LT.lt (f i) c.ord\na : Ordinal.{u_1}\na✝ : LT.lt a c.ord\n⊢ LT.lt (Ordinal.nfp f a) c.ord","decl":"theorem nfp_lt_ord_of_isRegular {f : Ordinal → Ordinal} {c} (hc : IsRegular c) (hc' : c ≠ ℵ₀)\n    (hf : ∀ i < c.ord, f i < c.ord) {a} : a < c.ord → nfp f a < c.ord :=\n  nfp_lt_ord\n    (by\n      rw [hc.cof_eq]\n      exact lt_of_le_of_ne hc.1 hc'.symm)\n    hf\n\n"}
{"name":"Cardinal.derivFamily_lt_ord_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v} → Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.lift.{v, u} (Cardinal.mk ι)) c\nhc' : Ne c Cardinal.aleph0\nhf : ∀ (i : ι) (b : Ordinal.{max u v}), LT.lt b c.ord → LT.lt (f i b) c.ord\na : Ordinal.{max u v}\na✝ : LT.lt a c.ord\n⊢ LT.lt (Ordinal.derivFamily f a) c.ord","decl":"theorem derivFamily_lt_ord_lift {ι : Type u} {f : ι → Ordinal → Ordinal} {c} (hc : IsRegular c)\n    (hι : lift.{v} #ι < c) (hc' : c ≠ ℵ₀) (hf : ∀ i, ∀ b < c.ord, f i b < c.ord) {a} :\n    a < c.ord → derivFamily f a < c.ord := by\n  have hω : ℵ₀ < c.ord.cof := by\n    rw [hc.cof_eq]\n    exact lt_of_le_of_ne hc.1 hc'.symm\n  induction a using limitRecOn with\n  | H₁ =>\n    rw [derivFamily_zero]\n    exact nfpFamily_lt_ord_lift hω (by rwa [hc.cof_eq]) hf\n  | H₂ b hb =>\n    intro hb'\n    rw [derivFamily_succ]\n    exact\n      nfpFamily_lt_ord_lift hω (by rwa [hc.cof_eq]) hf\n        ((isLimit_ord hc.1).succ_lt (hb ((lt_succ b).trans hb')))\n  | H₃ b hb H =>\n    intro hb'\n    -- TODO: generalize the universes of the lemmas in this file so we don't have to rely on bsup\n    have : ⨆ a : Iio b, _ = _ :=\n      iSup_eq_bsup.{max u v, max u v} (f := fun x (_ : x < b) ↦ derivFamily f x)\n    rw [derivFamily_limit f hb, this]\n    exact\n      bsup_lt_ord_of_isRegular.{u, v} hc (ord_lt_ord.1 ((ord_card_le b).trans_lt hb')) fun o' ho' =>\n        H o' ho' (ho'.trans hb')\n\n"}
{"name":"Cardinal.derivFamily_lt_ord","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"ι : Type u\nf : ι → Ordinal.{u} → Ordinal.{u}\nc : Cardinal.{u}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.mk ι) c\nhc' : Ne c Cardinal.aleph0\nhf : ∀ (i : ι) (b : Ordinal.{u}), LT.lt b c.ord → LT.lt (f i b) c.ord\na : Ordinal.{u}\na✝ : LT.lt a c.ord\n⊢ LT.lt (Ordinal.derivFamily f a) c.ord","decl":"theorem derivFamily_lt_ord {ι} {f : ι → Ordinal → Ordinal} {c} (hc : IsRegular c) (hι : #ι < c)\n    (hc' : c ≠ ℵ₀) (hf : ∀ (i), ∀ b < c.ord, f i b < c.ord) {a} :\n    a < c.ord → derivFamily.{u, u} f a < c.ord :=\n  derivFamily_lt_ord_lift hc (by rwa [lift_id]) hc' hf\n\n"}
{"name":"Cardinal.derivBFamily_lt_ord_lift","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v} → Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : c.IsRegular\nhι : LT.lt (Cardinal.lift.{v, u} o.card) c\nhc' : Ne c Cardinal.aleph0\nhf : ∀ (i : Ordinal.{u}) (hi : LT.lt i o) (b : Ordinal.{max u v}), LT.lt b c.ord → LT.lt (f i hi b) c.ord\na : Ordinal.{max u v}\na✝ : LT.lt a c.ord\n⊢ LT.lt (o.derivBFamily f a) c.ord","decl":"set_option linter.deprecated false in\n@[deprecated derivFamily_lt_ord_lift (since := \"2024-10-14\")]\ntheorem derivBFamily_lt_ord_lift {o : Ordinal} {f : ∀ a < o, Ordinal → Ordinal} {c}\n    (hc : IsRegular c) (hι : Cardinal.lift.{v, u} o.card < c) (hc' : c ≠ ℵ₀)\n    (hf : ∀ (i hi), ∀ b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord → derivBFamily.{u, v} o f a < c.ord :=\n  derivFamily_lt_ord_lift hc (by rwa [mk_toType]) hc' fun _ => hf _ _\n\n"}
{"name":"Cardinal.derivBFamily_lt_ord","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{u} → Ordinal.{u}\nc : Cardinal.{u}\nhc : c.IsRegular\nhι : LT.lt o.card c\nhc' : Ne c Cardinal.aleph0\nhf : ∀ (i : Ordinal.{u}) (hi : LT.lt i o) (b : Ordinal.{u}), LT.lt b c.ord → LT.lt (f i hi b) c.ord\na : Ordinal.{u}\na✝ : LT.lt a c.ord\n⊢ LT.lt (o.derivBFamily f a) c.ord","decl":"set_option linter.deprecated false in\n@[deprecated derivFamily_lt_ord (since := \"2024-10-14\")]\ntheorem derivBFamily_lt_ord {o : Ordinal} {f : ∀ a < o, Ordinal → Ordinal} {c} (hc : IsRegular c)\n    (hι : o.card < c) (hc' : c ≠ ℵ₀) (hf : ∀ (i hi), ∀ b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord → derivBFamily.{u, u} o f a < c.ord :=\n  derivBFamily_lt_ord_lift hc (by rwa [lift_id]) hc' hf\n\n"}
{"name":"Cardinal.deriv_lt_ord","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"f : Ordinal.{u} → Ordinal.{u}\nc : Cardinal.{u}\nhc : c.IsRegular\nhc' : Ne c Cardinal.aleph0\nhf : ∀ (i : Ordinal.{u}), LT.lt i c.ord → LT.lt (f i) c.ord\na : Ordinal.{u}\na✝ : LT.lt a c.ord\n⊢ LT.lt (Ordinal.deriv f a) c.ord","decl":"theorem deriv_lt_ord {f : Ordinal.{u} → Ordinal} {c} (hc : IsRegular c) (hc' : c ≠ ℵ₀)\n    (hf : ∀ i < c.ord, f i < c.ord) {a} : a < c.ord → deriv f a < c.ord :=\n  derivFamily_lt_ord_lift hc\n    (by simpa using Cardinal.one_lt_aleph0.trans (lt_of_le_of_ne hc.1 hc'.symm)) hc' fun _ => hf\n\n"}
{"name":"Cardinal.IsInaccessible.mk","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u_1}\nh₁ : LT.lt Cardinal.aleph0 c\nh₂ : LE.le c c.ord.cof\nh₃ : ∀ (x : Cardinal.{u_1}), LT.lt x c → LT.lt (HPow.hPow 2 x) c\n⊢ c.IsInaccessible","decl":"theorem IsInaccessible.mk {c} (h₁ : ℵ₀ < c) (h₂ : c ≤ c.ord.cof) (h₃ : ∀ x < c, (2^x) < c) :\n    IsInaccessible c :=\n  ⟨h₁, ⟨h₁.le, h₂⟩, (aleph0_pos.trans h₁).ne', h₃⟩\n\n-- Lean's foundations prove the existence of ℵ₀ many inaccessible cardinals\n"}
{"name":"Cardinal.univ_inaccessible","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"⊢ Cardinal.univ.{u, v}.IsInaccessible","decl":"theorem univ_inaccessible : IsInaccessible univ.{u, v} :=\n  IsInaccessible.mk (by simpa using lift_lt_univ' ℵ₀) (by simp) fun c h => by\n    rcases lt_univ'.1 h with ⟨c, rfl⟩\n    rw [← lift_two_power]\n    apply lift_lt_univ'\n\n"}
{"name":"Cardinal.lt_power_cof","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"c : Cardinal.{u}\na✝ : LE.le Cardinal.aleph0 c\n⊢ LT.lt c (HPow.hPow c c.ord.cof)","decl":"theorem lt_power_cof {c : Cardinal.{u}} : ℵ₀ ≤ c → c < (c^cof c.ord) :=\n  Cardinal.inductionOn c fun α h => by\n    rcases ord_eq α with ⟨r, wo, re⟩\n    have := isLimit_ord h\n    rw [re] at this ⊢\n    rcases cof_eq' r this with ⟨S, H, Se⟩\n    have := sum_lt_prod (fun a : S => #{ x // r x a }) (fun _ => #α) fun i => ?_\n    · simp only [Cardinal.prod_const, Cardinal.lift_id, ← Se, ← mk_sigma, power_def] at this ⊢\n      refine lt_of_le_of_lt ?_ this\n      refine ⟨Embedding.ofSurjective ?_ ?_⟩\n      · exact fun x => x.2.1\n      · exact fun a =>\n          let ⟨b, h, ab⟩ := H a\n          ⟨⟨⟨_, h⟩, _, ab⟩, rfl⟩\n    · have := typein_lt_type r i\n      rwa [← re, lt_ord] at this\n\n"}
{"name":"Cardinal.lt_cof_power","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"a b : Cardinal.{u_1}\nha : LE.le Cardinal.aleph0 a\nb1 : LT.lt 1 b\n⊢ LT.lt a (HPow.hPow b a).ord.cof","decl":"theorem lt_cof_power {a b : Cardinal} (ha : ℵ₀ ≤ a) (b1 : 1 < b) : a < cof (b^a).ord := by\n  have b0 : b ≠ 0 := (zero_lt_one.trans b1).ne'\n  apply lt_imp_lt_of_le_imp_le (power_le_power_left <| power_ne_zero a b0)\n  rw [← power_mul, mul_eq_self ha]\n  exact lt_power_cof (ha.trans <| (cantor' _ b1).le)\n\n"}
{"name":"Ordinal.iSup_sequence_lt_omega1","module":"Mathlib.SetTheory.Cardinal.Cofinality","initialProofState":"α : Type u\ninst✝ : Countable α\no : α → Ordinal.{max u v}\nho : ∀ (n : α), LT.lt (o n) (Cardinal.aleph 1).ord\n⊢ LT.lt (iSup o) (Cardinal.aleph 1).ord","decl":"lemma iSup_sequence_lt_omega1 {α : Type u} [Countable α]\n    (o : α → Ordinal.{max u v}) (ho : ∀ n, o n < (aleph 1).ord) :\n    iSup o < (aleph 1).ord := by\n  apply iSup_lt_ord_lift _ ho\n  rw [Cardinal.isRegular_aleph_one.cof_eq]\n  exact lt_of_le_of_lt mk_le_aleph0 aleph0_lt_aleph_one\n\n"}
