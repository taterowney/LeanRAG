{"name":"MonoidAlgebra.instIsCancelAdd","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : IsCancelAdd k\n⊢ IsCancelAdd (MonoidAlgebra k G)","decl":"instance MonoidAlgebra.instIsCancelAdd [IsCancelAdd k] : IsCancelAdd (MonoidAlgebra k G) :=\n  inferInstanceAs (IsCancelAdd (G →₀ k))\n\n"}
{"name":"MonoidAlgebra.single_zero","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\na : G\n⊢ Eq (MonoidAlgebra.single a 0) 0","decl":"theorem single_zero (a : G) : (single a 0 : MonoidAlgebra k G) = 0 := Finsupp.single_zero a\n\n"}
{"name":"MonoidAlgebra.single_add","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\na : G\nb₁ b₂ : k\n⊢ Eq (MonoidAlgebra.single a (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (MonoidAlgebra.single a b₁) (MonoidAlgebra.single a b₂))","decl":"theorem single_add (a : G) (b₁ b₂ : k) : single a (b₁ + b₂) = single a b₁ + single a b₂ :=\n  Finsupp.single_add a b₁ b₂\n\n"}
{"name":"MonoidAlgebra.sum_single_index","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\nN : Type u_3\ninst✝ : AddCommMonoid N\na : G\nb : k\nh : G → k → N\nh_zero : Eq (h a 0) 0\n⊢ Eq (Finsupp.sum (MonoidAlgebra.single a b) h) (h a b)","decl":"@[simp]\ntheorem sum_single_index {N} [AddCommMonoid N] {a : G} {b : k} {h : G → k → N}\n    (h_zero : h a 0 = 0) :\n    (single a b).sum h = h a b := Finsupp.sum_single_index h_zero\n\n"}
{"name":"MonoidAlgebra.sum_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\nf : MonoidAlgebra k G\n⊢ Eq (Finsupp.sum f MonoidAlgebra.single) f","decl":"@[simp]\ntheorem sum_single (f : MonoidAlgebra k G) : f.sum single = f :=\n  Finsupp.sum_single f\n\n"}
{"name":"MonoidAlgebra.single_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\na a' : G\nb : k\ninst✝ : Decidable (Eq a a')\n⊢ Eq ((MonoidAlgebra.single a b) a') (ite (Eq a a') b 0)","decl":"theorem single_apply {a a' : G} {b : k} [Decidable (a = a')] :\n    single a b a' = if a = a' then b else 0 :=\n  Finsupp.single_apply\n\n"}
{"name":"MonoidAlgebra.single_eq_zero","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\na : G\nb : k\n⊢ Iff (Eq (MonoidAlgebra.single a b) 0) (Eq b 0)","decl":"@[simp]\ntheorem single_eq_zero {a : G} {b : k} : single a b = 0 ↔ b = 0 := Finsupp.single_eq_zero\n\n"}
{"name":"MonoidAlgebra.mapDomain_sum","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\nk' : Type u_3\nG' : Type u_4\ninst✝ : Semiring k'\nf : G → G'\ns : MonoidAlgebra k' G\nv : G → k' → MonoidAlgebra k G\n⊢ Eq (MonoidAlgebra.mapDomain f (Finsupp.sum s v)) (Finsupp.sum s fun a b => MonoidAlgebra.mapDomain f (v a b))","decl":"theorem mapDomain_sum {k' G' : Type*} [Semiring k'] {f : G → G'} {s : MonoidAlgebra k' G}\n    {v : G → k' → MonoidAlgebra k G} :\n    mapDomain f (s.sum v) = s.sum fun a b => mapDomain f (v a b) :=\n  Finsupp.mapDomain_sum\n\n"}
{"name":"MonoidAlgebra.liftNC_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝¹ : Semiring k\ninst✝ : NonUnitalNonAssocSemiring R\nf : AddMonoidHom k R\ng : G → R\na : G\nb : k\n⊢ Eq ((MonoidAlgebra.liftNC f g) (MonoidAlgebra.single a b)) (HMul.hMul (f b) (g a))","decl":"@[simp]\ntheorem liftNC_single (f : k →+ R) (g : G → R) (a : G) (b : k) :\n    liftNC f g (single a b) = f b * g a :=\n  liftAddHom_apply_single _ _ _\n\n"}
{"name":"MonoidAlgebra.mul_def","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Mul G\nf g : MonoidAlgebra k G\n⊢ Eq (HMul.hMul f g) (Finsupp.sum f fun a₁ b₁ => Finsupp.sum g fun a₂ b₂ => MonoidAlgebra.single (HMul.hMul a₁ a₂) (HMul.hMul b₁ b₂))","decl":"theorem mul_def {f g : MonoidAlgebra k G} :\n    f * g = f.sum fun a₁ b₁ => g.sum fun a₂ b₂ => single (a₁ * a₂) (b₁ * b₂) := by\n  with_unfolding_all rfl\n\n"}
{"name":"MonoidAlgebra.liftNC_mul","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝⁴ : Semiring k\ninst✝³ : Mul G\ninst✝² : Semiring R\ng_hom : Type u_3\ninst✝¹ : FunLike g_hom G R\ninst✝ : MulHomClass g_hom G R\nf : RingHom k R\ng : g_hom\na b : MonoidAlgebra k G\nh_comm : ∀ {x y : G}, Membership.mem a.support y → Commute (f (b x)) (g y)\n⊢ Eq ((MonoidAlgebra.liftNC ↑f ⇑g) (HMul.hMul a b)) (HMul.hMul ((MonoidAlgebra.liftNC ↑f ⇑g) a) ((MonoidAlgebra.liftNC ↑f ⇑g) b))","decl":"theorem liftNC_mul {g_hom : Type*} [FunLike g_hom G R] [MulHomClass g_hom G R]\n    (f : k →+* R) (g : g_hom) (a b : MonoidAlgebra k G)\n    (h_comm : ∀ {x y}, y ∈ a.support → Commute (f (b x)) (g y)) :\n    liftNC (f : k →+ R) g (a * b) = liftNC (f : k →+ R) g a * liftNC (f : k →+ R) g b := by\n  conv_rhs => rw [← sum_single a, ← sum_single b]\n  -- Porting note: `(liftNC _ g).map_finsupp_sum` → `map_finsupp_sum`\n  simp_rw [mul_def, map_finsupp_sum, liftNC_single, Finsupp.sum_mul, Finsupp.mul_sum]\n  refine Finset.sum_congr rfl fun y hy => Finset.sum_congr rfl fun x _hx => ?_\n  simp [mul_assoc, (h_comm hy).left_comm]\n\n"}
{"name":"MonoidAlgebra.one_def","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : One G\n⊢ Eq 1 (MonoidAlgebra.single 1 1)","decl":"theorem one_def : (1 : MonoidAlgebra k G) = single 1 1 :=\n  rfl\n\n"}
{"name":"MonoidAlgebra.liftNC_one","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝⁴ : NonAssocSemiring R\ninst✝³ : Semiring k\ninst✝² : One G\ng_hom : Type u_3\ninst✝¹ : FunLike g_hom G R\ninst✝ : OneHomClass g_hom G R\nf : RingHom k R\ng : g_hom\n⊢ Eq ((MonoidAlgebra.liftNC ↑f ⇑g) 1) 1","decl":"@[simp]\ntheorem liftNC_one {g_hom : Type*} [FunLike g_hom G R] [OneHomClass g_hom G R]\n    (f : k →+* R) (g : g_hom) :\n    liftNC (f : k →+ R) g 1 = 1 := by simp [one_def]\n\n"}
{"name":"MonoidAlgebra.natCast_def","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : MulOneClass G\nn : Nat\n⊢ Eq (↑n) (MonoidAlgebra.single 1 ↑n)","decl":"theorem natCast_def (n : ℕ) : (n : MonoidAlgebra k G) = single (1 : G) (n : k) :=\n  rfl\n\n"}
{"name":"MonoidAlgebra.nontrivial","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝² : Semiring k\ninst✝¹ : Nontrivial k\ninst✝ : Nonempty G\n⊢ Nontrivial (MonoidAlgebra k G)","decl":"instance nontrivial [Semiring k] [Nontrivial k] [Nonempty G] : Nontrivial (MonoidAlgebra k G) :=\n  Finsupp.instNontrivial\n\n"}
{"name":"MonoidAlgebra.intCast_def","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Ring k\ninst✝ : MulOneClass G\nz : Int\n⊢ Eq (↑z) (MonoidAlgebra.single 1 ↑z)","decl":"theorem intCast_def [Ring k] [MulOneClass G] (z : ℤ) :\n    (z : MonoidAlgebra k G) = single (1 : G) (z : k) :=\n  rfl\n\n"}
{"name":"MonoidAlgebra.noZeroSMulDivisors","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : Zero R\ninst✝² : Semiring k\ninst✝¹ : SMulZeroClass R k\ninst✝ : NoZeroSMulDivisors R k\n⊢ NoZeroSMulDivisors R (MonoidAlgebra k G)","decl":"instance noZeroSMulDivisors [Zero R] [Semiring k] [SMulZeroClass R k] [NoZeroSMulDivisors R k] :\n    NoZeroSMulDivisors R (MonoidAlgebra k G) :=\n  Finsupp.noZeroSMulDivisors\n\n"}
{"name":"MonoidAlgebra.faithfulSMul","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : Semiring k\ninst✝² : SMulZeroClass R k\ninst✝¹ : FaithfulSMul R k\ninst✝ : Nonempty G\n⊢ FaithfulSMul R (MonoidAlgebra k G)","decl":"instance faithfulSMul [Semiring k] [SMulZeroClass R k] [FaithfulSMul R k] [Nonempty G] :\n    FaithfulSMul R (MonoidAlgebra k G) :=\n  Finsupp.faithfulSMul\n\n"}
{"name":"MonoidAlgebra.isScalarTower","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\nS : Type u_3\ninst✝⁴ : Semiring k\ninst✝³ : SMulZeroClass R k\ninst✝² : SMulZeroClass S k\ninst✝¹ : SMul R S\ninst✝ : IsScalarTower R S k\n⊢ IsScalarTower R S (MonoidAlgebra k G)","decl":"instance isScalarTower [Semiring k] [SMulZeroClass R k] [SMulZeroClass S k] [SMul R S]\n    [IsScalarTower R S k] : IsScalarTower R S (MonoidAlgebra k G) :=\n  Finsupp.isScalarTower G k\n\n"}
{"name":"MonoidAlgebra.smulCommClass","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\nS : Type u_3\ninst✝³ : Semiring k\ninst✝² : SMulZeroClass R k\ninst✝¹ : SMulZeroClass S k\ninst✝ : SMulCommClass R S k\n⊢ SMulCommClass R S (MonoidAlgebra k G)","decl":"instance smulCommClass [Semiring k] [SMulZeroClass R k] [SMulZeroClass S k] [SMulCommClass R S k] :\n    SMulCommClass R S (MonoidAlgebra k G) :=\n  Finsupp.smulCommClass G k\n\n"}
{"name":"MonoidAlgebra.isCentralScalar","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : Semiring k\ninst✝² : SMulZeroClass R k\ninst✝¹ : SMulZeroClass (MulOpposite R) k\ninst✝ : IsCentralScalar R k\n⊢ IsCentralScalar R (MonoidAlgebra k G)","decl":"instance isCentralScalar [Semiring k] [SMulZeroClass R k] [SMulZeroClass Rᵐᵒᵖ k]\n    [IsCentralScalar R k] : IsCentralScalar R (MonoidAlgebra k G) :=\n  Finsupp.isCentralScalar G k\n\n"}
{"name":"MonoidAlgebra.smul_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝¹ : Semiring k\ninst✝ : SMulZeroClass R k\na : G\nc : R\nb : k\n⊢ Eq (HSMul.hSMul c (MonoidAlgebra.single a b)) (MonoidAlgebra.single a (HSMul.hSMul c b))","decl":"@[simp]\ntheorem smul_single [Semiring k] [SMulZeroClass R k] (a : G) (c : R) (b : k) :\n    c • single a b = single a (c • b) :=\n  Finsupp.smul_single _ _ _\n\n"}
{"name":"MonoidAlgebra.ext","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\nf g : MonoidAlgebra k G\nH : ∀ (x : G), Eq (f x) (g x)\n⊢ Eq f g","decl":"/-- A copy of `Finsupp.ext` for `MonoidAlgebra`. -/\n@[ext]\ntheorem ext [Semiring k] ⦃f g : MonoidAlgebra k G⦄ (H : ∀ (x : G), f x = g x) :\n    f = g :=\n  Finsupp.ext H\n\n"}
{"name":"MonoidAlgebra.ext_iff","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\nf g : MonoidAlgebra k G\n⊢ Iff (Eq f g) (∀ (x : G), Eq (f x) (g x))","decl":"/-- A copy of `Finsupp.ext` for `MonoidAlgebra`. -/\n@[ext]\ntheorem ext [Semiring k] ⦃f g : MonoidAlgebra k G⦄ (H : ∀ (x : G), f x = g x) :\n    f = g :=\n  Finsupp.ext H\n\n"}
{"name":"MonoidAlgebra.singleAddHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\na : G\nb : k\n⊢ Eq ((MonoidAlgebra.singleAddHom a) b) (MonoidAlgebra.single a b)","decl":"@[simp] lemma singleAddHom_apply [Semiring k] (a : G) (b : k) :\n  singleAddHom a b = single a b := rfl\n\n"}
{"name":"MonoidAlgebra.addHom_ext'_iff","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nN : Type u_3\ninst✝¹ : Semiring k\ninst✝ : AddZeroClass N\nf g : AddMonoidHom (MonoidAlgebra k G) N\n⊢ Iff (Eq f g) (∀ (x : G), Eq (f.comp (MonoidAlgebra.singleAddHom x)) (g.comp (MonoidAlgebra.singleAddHom x)))","decl":"/-- A copy of `Finsupp.addHom_ext'` for `MonoidAlgebra`. -/\n@[ext high]\ntheorem addHom_ext' {N : Type*} [Semiring k] [AddZeroClass N]\n    ⦃f g : MonoidAlgebra k G →+ N⦄\n    (H : ∀ (x : G), AddMonoidHom.comp f (singleAddHom x) = AddMonoidHom.comp g (singleAddHom x)) :\n    f = g :=\n  Finsupp.addHom_ext' H\n\n"}
{"name":"MonoidAlgebra.addHom_ext'","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nN : Type u_3\ninst✝¹ : Semiring k\ninst✝ : AddZeroClass N\nf g : AddMonoidHom (MonoidAlgebra k G) N\nH : ∀ (x : G), Eq (f.comp (MonoidAlgebra.singleAddHom x)) (g.comp (MonoidAlgebra.singleAddHom x))\n⊢ Eq f g","decl":"/-- A copy of `Finsupp.addHom_ext'` for `MonoidAlgebra`. -/\n@[ext high]\ntheorem addHom_ext' {N : Type*} [Semiring k] [AddZeroClass N]\n    ⦃f g : MonoidAlgebra k G →+ N⦄\n    (H : ∀ (x : G), AddMonoidHom.comp f (singleAddHom x) = AddMonoidHom.comp g (singleAddHom x)) :\n    f = g :=\n  Finsupp.addHom_ext' H\n\n"}
{"name":"MonoidAlgebra.distribMulActionHom_ext'_iff","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\nN : Type u_3\ninst✝⁴ : Monoid R\ninst✝³ : Semiring k\ninst✝² : AddMonoid N\ninst✝¹ : DistribMulAction R N\ninst✝ : DistribMulAction R k\nf g : DistribMulActionHom (MonoidHom.id R) (MonoidAlgebra k G) N\n⊢ Iff (Eq f g) (∀ (a : G), Eq (f.comp (Finsupp.DistribMulActionHom.single a)) (g.comp (Finsupp.DistribMulActionHom.single a)))","decl":"/-- A copy of `Finsupp.distribMulActionHom_ext'` for `MonoidAlgebra`. -/\n@[ext]\ntheorem distribMulActionHom_ext' {N : Type*} [Monoid R] [Semiring k] [AddMonoid N]\n    [DistribMulAction R N] [DistribMulAction R k]\n    {f g : MonoidAlgebra k G →+[R] N}\n    (h : ∀ a : G,\n      f.comp (DistribMulActionHom.single (M := k) a) = g.comp (DistribMulActionHom.single a)) :\n    f = g :=\n  Finsupp.distribMulActionHom_ext' h\n\n"}
{"name":"MonoidAlgebra.distribMulActionHom_ext'","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\nN : Type u_3\ninst✝⁴ : Monoid R\ninst✝³ : Semiring k\ninst✝² : AddMonoid N\ninst✝¹ : DistribMulAction R N\ninst✝ : DistribMulAction R k\nf g : DistribMulActionHom (MonoidHom.id R) (MonoidAlgebra k G) N\nh : ∀ (a : G), Eq (f.comp (Finsupp.DistribMulActionHom.single a)) (g.comp (Finsupp.DistribMulActionHom.single a))\n⊢ Eq f g","decl":"/-- A copy of `Finsupp.distribMulActionHom_ext'` for `MonoidAlgebra`. -/\n@[ext]\ntheorem distribMulActionHom_ext' {N : Type*} [Monoid R] [Semiring k] [AddMonoid N]\n    [DistribMulAction R N] [DistribMulAction R k]\n    {f g : MonoidAlgebra k G →+[R] N}\n    (h : ∀ a : G,\n      f.comp (DistribMulActionHom.single (M := k) a) = g.comp (DistribMulActionHom.single a)) :\n    f = g :=\n  Finsupp.distribMulActionHom_ext' h\n\n"}
{"name":"MonoidAlgebra.lsingle_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : Semiring k\ninst✝ : Module R k\na : G\nb : k\n⊢ Eq ((MonoidAlgebra.lsingle a) b) (MonoidAlgebra.single a b)","decl":"@[simp] lemma lsingle_apply [Semiring R] [Semiring k] [Module R k] (a : G) (b : k) :\n  lsingle (R := R) a b = single a b := rfl\n\n"}
{"name":"MonoidAlgebra.lhom_ext'","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\nN : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : Semiring k\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : Module R k\nf g : LinearMap (RingHom.id R) (MonoidAlgebra k G) N\nH : ∀ (x : G), Eq (f.comp (MonoidAlgebra.lsingle x)) (g.comp (MonoidAlgebra.lsingle x))\n⊢ Eq f g","decl":"/-- A copy of `Finsupp.lhom_ext'` for `MonoidAlgebra`. -/\n@[ext high]\nlemma lhom_ext' {N : Type*} [Semiring R] [Semiring k] [AddCommMonoid N] [Module R N] [Module R k]\n    ⦃f g : MonoidAlgebra k G →ₗ[R] N⦄\n    (H : ∀ (x : G), LinearMap.comp f (lsingle x) = LinearMap.comp g (lsingle x)) :\n    f = g :=\n  Finsupp.lhom_ext' H\n\n"}
{"name":"MonoidAlgebra.lhom_ext'_iff","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\nN : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : Semiring k\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : Module R k\nf g : LinearMap (RingHom.id R) (MonoidAlgebra k G) N\n⊢ Iff (Eq f g) (∀ (x : G), Eq (f.comp (MonoidAlgebra.lsingle x)) (g.comp (MonoidAlgebra.lsingle x)))","decl":"/-- A copy of `Finsupp.lhom_ext'` for `MonoidAlgebra`. -/\n@[ext high]\nlemma lhom_ext' {N : Type*} [Semiring R] [Semiring k] [AddCommMonoid N] [Module R N] [Module R k]\n    ⦃f g : MonoidAlgebra k G →ₗ[R] N⦄\n    (H : ∀ (x : G), LinearMap.comp f (lsingle x) = LinearMap.comp g (lsingle x)) :\n    f = g :=\n  Finsupp.lhom_ext' H\n\n"}
{"name":"MonoidAlgebra.mul_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝² : Semiring k\ninst✝¹ : DecidableEq G\ninst✝ : Mul G\nf g : MonoidAlgebra k G\nx : G\n⊢ Eq ((HMul.hMul f g) x) (Finsupp.sum f fun a₁ b₁ => Finsupp.sum g fun a₂ b₂ => ite (Eq (HMul.hMul a₁ a₂) x) (HMul.hMul b₁ b₂) 0)","decl":"theorem mul_apply [DecidableEq G] [Mul G] (f g : MonoidAlgebra k G) (x : G) :\n    (f * g) x = f.sum fun a₁ b₁ => g.sum fun a₂ b₂ => if a₁ * a₂ = x then b₁ * b₂ else 0 := by\n  -- Porting note: `reducible` cannot be `local` so proof gets long.\n  rw [mul_def, Finsupp.sum_apply]; congr; ext\n  rw [Finsupp.sum_apply]; congr; ext\n  apply single_apply\n\n"}
{"name":"MonoidAlgebra.mul_apply_antidiagonal","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Mul G\nf g : MonoidAlgebra k G\nx : G\ns : Finset (Prod G G)\nhs : ∀ {p : Prod G G}, Iff (Membership.mem s p) (Eq (HMul.hMul p.1 p.2) x)\n⊢ Eq ((HMul.hMul f g) x) (s.sum fun p => HMul.hMul (f p.1) (g p.2))","decl":"theorem mul_apply_antidiagonal [Mul G] (f g : MonoidAlgebra k G) (x : G) (s : Finset (G × G))\n    (hs : ∀ {p : G × G}, p ∈ s ↔ p.1 * p.2 = x) : (f * g) x = ∑ p ∈ s, f p.1 * g p.2 := by\n  classical exact\n      let F : G × G → k := fun p => if p.1 * p.2 = x then f p.1 * g p.2 else 0\n      calc\n        (f * g) x = ∑ a₁ ∈ f.support, ∑ a₂ ∈ g.support, F (a₁, a₂) := mul_apply f g x\n        _ = ∑ p ∈ f.support ×ˢ g.support, F p := by rw [Finset.sum_product]\n        _ = ∑ p ∈ f.support ×ˢ g.support with p.1 * p.2 = x, f p.1 * g p.2 :=\n          (Finset.sum_filter _ _).symm\n        _ = ∑ p ∈ s with p.1 ∈ f.support ∧ p.2 ∈ g.support, f p.1 * g p.2 := by\n          congr! 1; ext; simp only [mem_filter, mem_product, hs, and_comm]\n        _ = ∑ p ∈ s, f p.1 * g p.2 :=\n          sum_subset (filter_subset _ _) fun p hps hp => by\n            simp only [mem_filter, mem_support_iff, not_and, Classical.not_not] at hp ⊢\n            by_cases h1 : f p.1 = 0\n            · rw [h1, zero_mul]\n            · rw [hp hps h1, mul_zero]\n\n"}
{"name":"MonoidAlgebra.single_mul_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Mul G\na₁ a₂ : G\nb₁ b₂ : k\n⊢ Eq (HMul.hMul (MonoidAlgebra.single a₁ b₁) (MonoidAlgebra.single a₂ b₂)) (MonoidAlgebra.single (HMul.hMul a₁ a₂) (HMul.hMul b₁ b₂))","decl":"@[simp]\ntheorem single_mul_single [Mul G] {a₁ a₂ : G} {b₁ b₂ : k} :\n    single a₁ b₁ * single a₂ b₂ = single (a₁ * a₂) (b₁ * b₂) := by\n  rw [mul_def]\n  exact (sum_single_index (by simp only [zero_mul, single_zero, sum_zero])).trans\n    (sum_single_index (by rw [mul_zero, single_zero]))\n\n"}
{"name":"MonoidAlgebra.single_commute_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Mul G\na₁ a₂ : G\nb₁ b₂ : k\nha : Commute a₁ a₂\nhb : Commute b₁ b₂\n⊢ Commute (MonoidAlgebra.single a₁ b₁) (MonoidAlgebra.single a₂ b₂)","decl":"theorem single_commute_single [Mul G] {a₁ a₂ : G} {b₁ b₂ : k}\n    (ha : Commute a₁ a₂) (hb : Commute b₁ b₂) :\n    Commute (single a₁ b₁) (single a₂ b₂) :=\n  single_mul_single.trans <| congr_arg₂ single ha hb |>.trans single_mul_single.symm\n\n"}
{"name":"MonoidAlgebra.single_commute","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Mul G\na : G\nb : k\nha : ∀ (a' : G), Commute a a'\nhb : ∀ (b' : k), Commute b b'\nf : MonoidAlgebra k G\n⊢ Commute (MonoidAlgebra.single a b) f","decl":"theorem single_commute [Mul G] {a : G} {b : k} (ha : ∀ a', Commute a a') (hb : ∀ b', Commute b b') :\n    ∀ f : MonoidAlgebra k G, Commute (single a b) f :=\n  suffices AddMonoidHom.mulLeft (single a b) = AddMonoidHom.mulRight (single a b) from\n    DFunLike.congr_fun this\n  addHom_ext' fun a' => AddMonoidHom.ext fun b' => single_commute_single (ha a') (hb b')\n\n"}
{"name":"MonoidAlgebra.single_pow","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Monoid G\na : G\nb : k\nn : Nat\n⊢ Eq (HPow.hPow (MonoidAlgebra.single a b) n) (MonoidAlgebra.single (HPow.hPow a n) (HPow.hPow b n))","decl":"@[simp]\ntheorem single_pow [Monoid G] {a : G} {b : k} : ∀ n : ℕ, single a b ^ n = single (a ^ n) (b ^ n)\n  | 0 => by\n    simp only [pow_zero]\n    rfl\n  | n + 1 => by simp only [pow_succ, single_pow n, single_mul_single]\n\n"}
{"name":"MonoidAlgebra.mapDomain_one","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nα₂ : Type u_5\ninst✝⁴ : Semiring β\ninst✝³ : One α\ninst✝² : One α₂\nF : Type u_6\ninst✝¹ : FunLike F α α₂\ninst✝ : OneHomClass F α α₂\nf : F\n⊢ Eq (MonoidAlgebra.mapDomain (⇑f) 1) 1","decl":"/-- Like `Finsupp.mapDomain_zero`, but for the `1` we define in this file -/\n@[simp]\ntheorem mapDomain_one {α : Type*} {β : Type*} {α₂ : Type*} [Semiring β] [One α] [One α₂]\n    {F : Type*} [FunLike F α α₂] [OneHomClass F α α₂] (f : F) :\n    (mapDomain f (1 : MonoidAlgebra β α) : MonoidAlgebra β α₂) = (1 : MonoidAlgebra β α₂) := by\n  simp_rw [one_def, mapDomain_single, map_one]\n\n"}
{"name":"MonoidAlgebra.mapDomain_mul","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nα₂ : Type u_5\ninst✝⁴ : Semiring β\ninst✝³ : Mul α\ninst✝² : Mul α₂\nF : Type u_6\ninst✝¹ : FunLike F α α₂\ninst✝ : MulHomClass F α α₂\nf : F\nx y : MonoidAlgebra β α\n⊢ Eq (MonoidAlgebra.mapDomain (⇑f) (HMul.hMul x y)) (HMul.hMul (MonoidAlgebra.mapDomain (⇑f) x) (MonoidAlgebra.mapDomain (⇑f) y))","decl":"/-- Like `Finsupp.mapDomain_add`, but for the convolutive multiplication we define in this file -/\ntheorem mapDomain_mul {α : Type*} {β : Type*} {α₂ : Type*} [Semiring β] [Mul α] [Mul α₂]\n    {F : Type*} [FunLike F α α₂] [MulHomClass F α α₂] (f : F) (x y : MonoidAlgebra β α) :\n    mapDomain f (x * y) = mapDomain f x * mapDomain f y := by\n  simp_rw [mul_def, mapDomain_sum, mapDomain_single, map_mul]\n  rw [Finsupp.sum_mapDomain_index]\n  · congr\n    ext a b\n    rw [Finsupp.sum_mapDomain_index]\n    · simp\n    · simp [mul_add]\n  · simp\n  · simp [add_mul]\n\n"}
{"name":"MonoidAlgebra.ofMagma_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Mul G\na : G\n⊢ Eq ((MonoidAlgebra.ofMagma k G) a) (MonoidAlgebra.single a 1)","decl":"/-- The embedding of a magma into its magma algebra. -/\n@[simps]\ndef ofMagma [Mul G] : G →ₙ* MonoidAlgebra k G where\n  toFun a := single a 1\n  map_mul' a b := by simp only [mul_def, mul_one, sum_single_index, single_eq_zero, mul_zero]\n\n"}
{"name":"MonoidAlgebra.of_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : MulOneClass G\na : G\n⊢ Eq ((MonoidAlgebra.of k G) a) (MonoidAlgebra.single a 1)","decl":"/-- The embedding of a unital magma into its magma algebra. -/\n@[simps]\ndef of [MulOneClass G] : G →* MonoidAlgebra k G :=\n  { ofMagma k G with\n    toFun := fun a => single a 1\n    map_one' := rfl }\n\n"}
{"name":"MonoidAlgebra.smul_single'","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\nc : k\na : G\nb : k\n⊢ Eq (HSMul.hSMul c (MonoidAlgebra.single a b)) (MonoidAlgebra.single a (HMul.hMul c b))","decl":"/-- Copy of `Finsupp.smul_single'` that avoids the `MonoidAlgebra = Finsupp` defeq abuse. -/\ntheorem smul_single' (c : k) (a : G) (b : k) : c • single a b = single a (c * b) :=\n  Finsupp.smul_single' c a b\n\n"}
{"name":"MonoidAlgebra.smul_of","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : MulOneClass G\ng : G\nr : k\n⊢ Eq (HSMul.hSMul r ((MonoidAlgebra.of k G) g)) (MonoidAlgebra.single g r)","decl":"theorem smul_of [MulOneClass G] (g : G) (r : k) : r • of k G g = single g r := by\n  simp\n\n"}
{"name":"MonoidAlgebra.of_injective","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝² : Semiring k\ninst✝¹ : MulOneClass G\ninst✝ : Nontrivial k\n⊢ Function.Injective ⇑(MonoidAlgebra.of k G)","decl":"theorem of_injective [MulOneClass G] [Nontrivial k] :\n    Function.Injective (of k G) := fun a b h => by\n  simpa using (single_eq_single_iff _ _ _ _).mp h\n\n"}
{"name":"MonoidAlgebra.of_commute","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : MulOneClass G\na : G\nh : ∀ (a' : G), Commute a a'\nf : MonoidAlgebra k G\n⊢ Commute ((MonoidAlgebra.of k G) a) f","decl":"theorem of_commute [MulOneClass G] {a : G} (h : ∀ a', Commute a a') (f : MonoidAlgebra k G) :\n    Commute (of k G a) f :=\n  single_commute h Commute.one_left f\n\n"}
{"name":"MonoidAlgebra.singleHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : MulOneClass G\na : Prod k G\n⊢ Eq (MonoidAlgebra.singleHom a) (MonoidAlgebra.single a.2 a.1)","decl":"/-- `Finsupp.single` as a `MonoidHom` from the product type into the monoid algebra.\n\nNote the order of the elements of the product are reversed compared to the arguments of\n`Finsupp.single`.\n-/\n@[simps]\ndef singleHom [MulOneClass G] : k × G →* MonoidAlgebra k G where\n  toFun a := single a.2 a.1\n  map_one' := rfl\n  map_mul' _a _b := single_mul_single.symm\n\n"}
{"name":"MonoidAlgebra.mul_single_apply_aux","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Mul G\nf : MonoidAlgebra k G\nr : k\nx y z : G\nH : ∀ (a : G), Membership.mem f.support a → Iff (Eq (HMul.hMul a x) z) (Eq a y)\n⊢ Eq ((HMul.hMul f (MonoidAlgebra.single x r)) z) (HMul.hMul (f y) r)","decl":"theorem mul_single_apply_aux [Mul G] (f : MonoidAlgebra k G) {r : k} {x y z : G}\n    (H : ∀ a ∈ f.support, a * x = z ↔ a = y) : (f * single x r) z = f y * r := by\n  classical exact\n    calc\n      (f * single x r) z\n      _ = sum f fun a b => ite (a * x = z) (b * r) 0 :=\n        (mul_apply _ _ _).trans <| Finsupp.sum_congr fun _ _ => sum_single_index (by simp)\n\n      _ = f.sum fun a b => ite (a = y) (b * r) 0 := Finsupp.sum_congr fun x hx => by\n        simp only [H _ hx]\n      _ = if y ∈ f.support then f y * r else 0 := f.support.sum_ite_eq' _ _\n      _ = _ := by split_ifs with h <;> simp at h <;> simp [h]\n\n\n"}
{"name":"MonoidAlgebra.mul_single_one_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : MulOneClass G\nf : MonoidAlgebra k G\nr : k\nx : G\n⊢ Eq ((HMul.hMul f (MonoidAlgebra.single 1 r)) x) (HMul.hMul (f x) r)","decl":"theorem mul_single_one_apply [MulOneClass G] (f : MonoidAlgebra k G) (r : k) (x : G) :\n    (HMul.hMul (β := MonoidAlgebra k G) f (single 1 r)) x = f x * r :=\n  f.mul_single_apply_aux fun a ha => by rw [mul_one]\n\n"}
{"name":"MonoidAlgebra.mul_single_apply_of_not_exists_mul","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Mul G\nr : k\ng g' : G\nx : MonoidAlgebra k G\nh : Not (Exists fun d => Eq g' (HMul.hMul d g))\n⊢ Eq ((HMul.hMul x (MonoidAlgebra.single g r)) g') 0","decl":"theorem mul_single_apply_of_not_exists_mul [Mul G] (r : k) {g g' : G} (x : MonoidAlgebra k G)\n    (h : ¬∃ d, g' = d * g) : (x * single g r) g' = 0 := by\n  classical\n    rw [mul_apply, Finsupp.sum_comm, Finsupp.sum_single_index]\n    swap\n    · simp_rw [Finsupp.sum, mul_zero, ite_self, Finset.sum_const_zero]\n    · apply Finset.sum_eq_zero\n      simp_rw [ite_eq_right_iff]\n      rintro g'' _hg'' rfl\n      exfalso\n      exact h ⟨_, rfl⟩\n\n"}
{"name":"MonoidAlgebra.single_mul_apply_aux","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Mul G\nf : MonoidAlgebra k G\nr : k\nx y z : G\nH : ∀ (a : G), Membership.mem f.support a → Iff (Eq (HMul.hMul x a) y) (Eq a z)\n⊢ Eq ((HMul.hMul (MonoidAlgebra.single x r) f) y) (HMul.hMul r (f z))","decl":"theorem single_mul_apply_aux [Mul G] (f : MonoidAlgebra k G) {r : k} {x y z : G}\n    (H : ∀ a ∈ f.support, x * a = y ↔ a = z) : (single x r * f) y = r * f z := by\n  classical exact\n      have : (f.sum fun a b => ite (x * a = y) (0 * b) 0) = 0 := by simp\n      calc\n        (single x r * f) y\n        _ = sum f fun a b => ite (x * a = y) (r * b) 0 :=\n          (mul_apply _ _ _).trans <| sum_single_index this\n        _ = f.sum fun a b => ite (a = z) (r * b) 0 := Finsupp.sum_congr fun x hx => by\n          simp only [H _ hx]\n        _ = if z ∈ f.support then r * f z else 0 := f.support.sum_ite_eq' _ _\n        _ = _ := by split_ifs with h <;> simp at h <;> simp [h]\n\n"}
{"name":"MonoidAlgebra.single_one_mul_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : MulOneClass G\nf : MonoidAlgebra k G\nr : k\nx : G\n⊢ Eq ((HMul.hMul (MonoidAlgebra.single 1 r) f) x) (HMul.hMul r (f x))","decl":"theorem single_one_mul_apply [MulOneClass G] (f : MonoidAlgebra k G) (r : k) (x : G) :\n    (single (1 : G) r * f) x = r * f x :=\n  f.single_mul_apply_aux fun a ha => by rw [one_mul]\n\n"}
{"name":"MonoidAlgebra.single_mul_apply_of_not_exists_mul","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Mul G\nr : k\ng g' : G\nx : MonoidAlgebra k G\nh : Not (Exists fun d => Eq g' (HMul.hMul g d))\n⊢ Eq ((HMul.hMul (MonoidAlgebra.single g r) x) g') 0","decl":"theorem single_mul_apply_of_not_exists_mul [Mul G] (r : k) {g g' : G} (x : MonoidAlgebra k G)\n    (h : ¬∃ d, g' = g * d) : (single g r * x) g' = 0 := by\n  classical\n    rw [mul_apply, Finsupp.sum_single_index]\n    swap\n    · simp_rw [Finsupp.sum, zero_mul, ite_self, Finset.sum_const_zero]\n    · apply Finset.sum_eq_zero\n      simp_rw [ite_eq_right_iff]\n      rintro g'' _hg'' rfl\n      exfalso\n      exact h ⟨_, rfl⟩\n\n"}
{"name":"MonoidAlgebra.liftNC_smul","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝² : Semiring k\ninst✝¹ : MulOneClass G\nR : Type u_3\ninst✝ : Semiring R\nf : RingHom k R\ng : MonoidHom G R\nc : k\nφ : MonoidAlgebra k G\n⊢ Eq ((MonoidAlgebra.liftNC ↑f ⇑g) (HSMul.hSMul c φ)) (HMul.hMul (f c) ((MonoidAlgebra.liftNC ↑f ⇑g) φ))","decl":"theorem liftNC_smul [MulOneClass G] {R : Type*} [Semiring R] (f : k →+* R) (g : G →* R) (c : k)\n    (φ : MonoidAlgebra k G) : liftNC (f : k →+ R) g (c • φ) = f c * liftNC (f : k →+ R) g φ := by\n  suffices (liftNC (↑f) g).comp (smulAddHom k (MonoidAlgebra k G) c) =\n      (AddMonoidHom.mulLeft (f c)).comp (liftNC (↑f) g) from\n    DFunLike.congr_fun this φ\n  ext\n  simp_rw [AddMonoidHom.comp_apply, singleAddHom_apply, smulAddHom_apply,\n    AddMonoidHom.coe_mulLeft, smul_single', liftNC_single, AddMonoidHom.coe_coe, map_mul, mul_assoc]\n\n"}
{"name":"MonoidAlgebra.isScalarTower_self","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : Semiring k\ninst✝² : DistribSMul R k\ninst✝¹ : Mul G\ninst✝ : IsScalarTower R k k\n⊢ IsScalarTower R (MonoidAlgebra k G) (MonoidAlgebra k G)","decl":"instance isScalarTower_self [IsScalarTower R k k] :\n    IsScalarTower R (MonoidAlgebra k G) (MonoidAlgebra k G) where\n  smul_assoc t a b := by\n    ext\n    -- Porting note: `refine` & `rw` are required because `simp` behaves differently.\n    classical\n    simp only [smul_eq_mul, mul_apply]\n    rw [coe_smul]\n    refine Eq.trans (sum_smul_index' (g := a) (b := t) ?_) ?_ <;>\n      simp only [mul_apply, Finsupp.smul_sum, smul_ite, smul_mul_assoc,\n        zero_mul, ite_self, imp_true_iff, sum_zero, Pi.smul_apply, smul_zero]\n\n"}
{"name":"MonoidAlgebra.smulCommClass_self","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : Semiring k\ninst✝² : DistribSMul R k\ninst✝¹ : Mul G\ninst✝ : SMulCommClass R k k\n⊢ SMulCommClass R (MonoidAlgebra k G) (MonoidAlgebra k G)","decl":"/-- Note that if `k` is a `CommSemiring` then we have `SMulCommClass k k k` and so we can take\n`R = k` in the below. In other words, if the coefficients are commutative amongst themselves, they\nalso commute with the algebra multiplication. -/\ninstance smulCommClass_self [SMulCommClass R k k] :\n    SMulCommClass R (MonoidAlgebra k G) (MonoidAlgebra k G) where\n  smul_comm t a b := by\n    ext\n    -- Porting note: `refine` & `rw` are required because `simp` behaves differently.\n    classical\n    simp only [smul_eq_mul, mul_apply]\n    rw [coe_smul]\n    refine Eq.symm (Eq.trans (congr_arg (sum a)\n      (funext₂ fun a₁ b₁ => sum_smul_index' (g := b) (b := t) ?_)) ?_) <;>\n    simp only [mul_apply, Finsupp.sum, Finset.smul_sum, smul_ite, mul_smul_comm,\n      imp_true_iff, ite_eq_right_iff, Pi.smul_apply, mul_zero, smul_zero]\n\n"}
{"name":"MonoidAlgebra.smulCommClass_symm_self","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : Semiring k\ninst✝² : DistribSMul R k\ninst✝¹ : Mul G\ninst✝ : SMulCommClass k R k\n⊢ SMulCommClass (MonoidAlgebra k G) R (MonoidAlgebra k G)","decl":"instance smulCommClass_symm_self [SMulCommClass k R k] :\n    SMulCommClass (MonoidAlgebra k G) R (MonoidAlgebra k G) :=\n  ⟨fun t a b => by\n    haveI := SMulCommClass.symm k R k\n    rw [← smul_comm]⟩\n\n"}
{"name":"MonoidAlgebra.single_one_comm","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : CommSemiring k\ninst✝ : MulOneClass G\nr : k\nf : MonoidAlgebra k G\n⊢ Eq (HMul.hMul (MonoidAlgebra.single 1 r) f) (HMul.hMul f (MonoidAlgebra.single 1 r))","decl":"theorem single_one_comm [CommSemiring k] [MulOneClass G] (r : k) (f : MonoidAlgebra k G) :\n    single (1 : G) r * f = f * single (1 : G) r :=\n  single_commute Commute.one_left (Commute.all _) f\n\n"}
{"name":"MonoidAlgebra.singleOneRingHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : MulOneClass G\nb : k\n⊢ Eq (MonoidAlgebra.singleOneRingHom b) (MonoidAlgebra.single 1 b)","decl":"/-- `Finsupp.single 1` as a `RingHom` -/\n@[simps]\ndef singleOneRingHom [Semiring k] [MulOneClass G] : k →+* MonoidAlgebra k G :=\n  { singleAddHom 1 with\n    toFun := single 1\n    map_one' := rfl\n    map_mul' := fun x y => by simp }\n\n"}
{"name":"MonoidAlgebra.mapDomainRingHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"G : Type u₂\nk : Type u_3\nH : Type u_4\nF : Type u_5\ninst✝⁴ : Semiring k\ninst✝³ : Monoid G\ninst✝² : Monoid H\ninst✝¹ : FunLike F G H\ninst✝ : MonoidHomClass F G H\nf : F\na✝ : Finsupp G k\n⊢ Eq ((MonoidAlgebra.mapDomainRingHom k f) a✝) ((↑(Finsupp.mapDomain.addMonoidHom ⇑f)).toFun a✝)","decl":"/-- If `f : G → H` is a multiplicative homomorphism between two monoids, then\n`Finsupp.mapDomain f` is a ring homomorphism between their monoid algebras. -/\n@[simps]\ndef mapDomainRingHom (k : Type*) {H F : Type*} [Semiring k] [Monoid G] [Monoid H]\n    [FunLike F G H] [MonoidHomClass F G H] (f : F) : MonoidAlgebra k G →+* MonoidAlgebra k H :=\n  { (Finsupp.mapDomain.addMonoidHom f : MonoidAlgebra k G →+ MonoidAlgebra k H) with\n    map_one' := mapDomain_one f\n    map_mul' := fun x y => mapDomain_mul f x y }\n\n"}
{"name":"MonoidAlgebra.ringHom_ext","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_3\ninst✝² : Semiring k\ninst✝¹ : MulOneClass G\ninst✝ : Semiring R\nf g : RingHom (MonoidAlgebra k G) R\nh₁ : ∀ (b : k), Eq (f (MonoidAlgebra.single 1 b)) (g (MonoidAlgebra.single 1 b))\nh_of : ∀ (a : G), Eq (f (MonoidAlgebra.single a 1)) (g (MonoidAlgebra.single a 1))\n⊢ Eq f g","decl":"/-- If two ring homomorphisms from `MonoidAlgebra k G` are equal on all `single a 1`\nand `single 1 b`, then they are equal. -/\ntheorem ringHom_ext {R} [Semiring k] [MulOneClass G] [Semiring R] {f g : MonoidAlgebra k G →+* R}\n    (h₁ : ∀ b, f (single 1 b) = g (single 1 b)) (h_of : ∀ a, f (single a 1) = g (single a 1)) :\n    f = g :=\n  RingHom.coe_addMonoidHom_injective <|\n    addHom_ext fun a b => by\n      rw [← single, ← one_mul a, ← mul_one b, ← single_mul_single]\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      erw [AddMonoidHom.coe_coe f, AddMonoidHom.coe_coe g]; rw [f.map_mul, g.map_mul, h₁, h_of]\n\n"}
{"name":"MonoidAlgebra.ringHom_ext'","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_3\ninst✝² : Semiring k\ninst✝¹ : MulOneClass G\ninst✝ : Semiring R\nf g : RingHom (MonoidAlgebra k G) R\nh₁ : Eq (f.comp MonoidAlgebra.singleOneRingHom) (g.comp MonoidAlgebra.singleOneRingHom)\nh_of : Eq ((↑f).comp (MonoidAlgebra.of k G)) ((↑g).comp (MonoidAlgebra.of k G))\n⊢ Eq f g","decl":"/-- If two ring homomorphisms from `MonoidAlgebra k G` are equal on all `single a 1`\nand `single 1 b`, then they are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem ringHom_ext' {R} [Semiring k] [MulOneClass G] [Semiring R] {f g : MonoidAlgebra k G →+* R}\n    (h₁ : f.comp singleOneRingHom = g.comp singleOneRingHom)\n    (h_of :\n      (f : MonoidAlgebra k G →* R).comp (of k G) = (g : MonoidAlgebra k G →* R).comp (of k G)) :\n    f = g :=\n  ringHom_ext (RingHom.congr_fun h₁) (DFunLike.congr_fun h_of)\n\n"}
{"name":"MonoidAlgebra.ringHom_ext'_iff","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_3\ninst✝² : Semiring k\ninst✝¹ : MulOneClass G\ninst✝ : Semiring R\nf g : RingHom (MonoidAlgebra k G) R\n⊢ Iff (Eq f g) (And (Eq (f.comp MonoidAlgebra.singleOneRingHom) (g.comp MonoidAlgebra.singleOneRingHom)) (Eq ((↑f).comp (MonoidAlgebra.of k G)) ((↑g).comp (MonoidAlgebra.of k G))))","decl":"/-- If two ring homomorphisms from `MonoidAlgebra k G` are equal on all `single a 1`\nand `single 1 b`, then they are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem ringHom_ext' {R} [Semiring k] [MulOneClass G] [Semiring R] {f g : MonoidAlgebra k G →+* R}\n    (h₁ : f.comp singleOneRingHom = g.comp singleOneRingHom)\n    (h_of :\n      (f : MonoidAlgebra k G →* R).comp (of k G) = (g : MonoidAlgebra k G →* R).comp (of k G)) :\n    f = g :=\n  ringHom_ext (RingHom.congr_fun h₁) (DFunLike.congr_fun h_of)\n\n"}
{"name":"MonoidAlgebra.induction_on","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Monoid G\np : MonoidAlgebra k G → Prop\nf : MonoidAlgebra k G\nhM : ∀ (g : G), p ((MonoidAlgebra.of k G) g)\nhadd : ∀ (f g : MonoidAlgebra k G), p f → p g → p (HAdd.hAdd f g)\nhsmul : ∀ (r : k) (f : MonoidAlgebra k G), p f → p (HSMul.hSMul r f)\n⊢ p f","decl":"theorem induction_on [Semiring k] [Monoid G] {p : MonoidAlgebra k G → Prop} (f : MonoidAlgebra k G)\n    (hM : ∀ g, p (of k G g)) (hadd : ∀ f g : MonoidAlgebra k G, p f → p g → p (f + g))\n    (hsmul : ∀ (r : k) (f), p f → p (r • f)) : p f := by\n  refine Finsupp.induction_linear f ?_ (fun f g hf hg => hadd f g hf hg) fun g r => ?_\n  · simpa using hsmul 0 (of k G 1) (hM 1)\n  · convert hsmul r (of k G g) (hM g)\n    simp\n\n"}
{"name":"MonoidAlgebra.prod_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nι : Type ui\ninst✝¹ : CommSemiring k\ninst✝ : CommMonoid G\ns : Finset ι\na : ι → G\nb : ι → k\n⊢ Eq (s.prod fun i => MonoidAlgebra.single (a i) (b i)) (MonoidAlgebra.single (s.prod fun i => a i) (s.prod fun i => b i))","decl":"theorem prod_single [CommSemiring k] [CommMonoid G] {s : Finset ι} {a : ι → G} {b : ι → k} :\n    (∏ i ∈ s, single (a i) (b i)) = single (∏ i ∈ s, a i) (∏ i ∈ s, b i) :=\n  Finset.cons_induction_on s rfl fun a s has ih => by\n    rw [prod_cons has, ih, single_mul_single, prod_cons has, prod_cons has]\n\n"}
{"name":"MonoidAlgebra.mul_single_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Group G\nf : MonoidAlgebra k G\nr : k\nx y : G\n⊢ Eq ((HMul.hMul f (MonoidAlgebra.single x r)) y) (HMul.hMul (f (HMul.hMul y (Inv.inv x))) r)","decl":"@[simp]\ntheorem mul_single_apply (f : MonoidAlgebra k G) (r : k) (x y : G) :\n    (f * single x r) y = f (y * x⁻¹) * r :=\n  f.mul_single_apply_aux fun _a _ => eq_mul_inv_iff_mul_eq.symm\n\n"}
{"name":"MonoidAlgebra.single_mul_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Group G\nr : k\nx : G\nf : MonoidAlgebra k G\ny : G\n⊢ Eq ((HMul.hMul (MonoidAlgebra.single x r) f) y) (HMul.hMul r (f (HMul.hMul (Inv.inv x) y)))","decl":"@[simp]\ntheorem single_mul_apply (r : k) (x : G) (f : MonoidAlgebra k G) (y : G) :\n    (single x r * f) y = r * f (x⁻¹ * y) :=\n  f.single_mul_apply_aux fun _z _ => eq_inv_mul_iff_mul_eq.symm\n\n"}
{"name":"MonoidAlgebra.mul_apply_left","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Group G\nf g : MonoidAlgebra k G\nx : G\n⊢ Eq ((HMul.hMul f g) x) (Finsupp.sum f fun a b => HMul.hMul b (g (HMul.hMul (Inv.inv a) x)))","decl":"theorem mul_apply_left (f g : MonoidAlgebra k G) (x : G) :\n    (f * g) x = f.sum fun a b => b * g (a⁻¹ * x) :=\n  calc\n    (f * g) x = sum f fun a b => (single a b * g) x := by\n      rw [← Finsupp.sum_apply, ← Finsupp.sum_mul g f, f.sum_single]\n    _ = _ := by simp only [single_mul_apply, Finsupp.sum]\n\n-- If we'd assumed `CommSemiring`, we could deduce this from `mul_apply_left`.\n"}
{"name":"MonoidAlgebra.mul_apply_right","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Group G\nf g : MonoidAlgebra k G\nx : G\n⊢ Eq ((HMul.hMul f g) x) (Finsupp.sum g fun a b => HMul.hMul (f (HMul.hMul x (Inv.inv a))) b)","decl":"theorem mul_apply_right (f g : MonoidAlgebra k G) (x : G) :\n    (f * g) x = g.sum fun a b => f (x * a⁻¹) * b :=\n  calc\n    (f * g) x = sum g fun a b => (f * single a b) x := by\n      rw [← Finsupp.sum_apply, ← Finsupp.mul_sum f g, g.sum_single]\n    _ = _ := by simp only [mul_single_apply, Finsupp.sum]\n\n"}
{"name":"MonoidAlgebra.opRingEquiv_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Monoid G\na✝ : MulOpposite (Finsupp G k)\n⊢ Eq (MonoidAlgebra.opRingEquiv a✝) (Finsupp.equivMapDomain MulOpposite.opEquiv (Finsupp.mapRange MulOpposite.op ⋯ (MulOpposite.unop a✝)))","decl":"/-- The opposite of a `MonoidAlgebra R I` equivalent as a ring to\nthe `MonoidAlgebra Rᵐᵒᵖ Iᵐᵒᵖ` over the opposite ring, taking elements to their opposite. -/\n@[simps! (config := { simpRhs := true }) apply symm_apply]\nprotected noncomputable def opRingEquiv [Monoid G] :\n    (MonoidAlgebra k G)ᵐᵒᵖ ≃+* MonoidAlgebra kᵐᵒᵖ Gᵐᵒᵖ :=\n  { opAddEquiv.symm.trans <|\n      (Finsupp.mapRange.addEquiv (opAddEquiv : k ≃+ kᵐᵒᵖ)).trans <| Finsupp.domCongr opEquiv with\n    map_mul' := by\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      rw [Equiv.toFun_as_coe, AddEquiv.toEquiv_eq_coe]; erw [AddEquiv.coe_toEquiv]\n      rw [← AddEquiv.coe_toAddMonoidHom]\n      refine Iff.mpr (AddMonoidHom.map_mul_iff (R := (MonoidAlgebra k G)ᵐᵒᵖ)\n        (S := MonoidAlgebra kᵐᵒᵖ Gᵐᵒᵖ) _) ?_\n      ext\n      -- Porting note: `reducible` cannot be `local` so proof gets long.\n      simp only [AddMonoidHom.coe_comp, AddEquiv.coe_toAddMonoidHom, opAddEquiv_apply,\n        Function.comp_apply, singleAddHom_apply, AddMonoidHom.compr₂_apply, AddMonoidHom.coe_mul,\n        AddMonoidHom.coe_mulLeft, AddMonoidHom.compl₂_apply]\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      erw [AddEquiv.trans_apply, AddEquiv.trans_apply, AddEquiv.trans_apply, AddEquiv.trans_apply,\n        AddEquiv.trans_apply, AddEquiv.trans_apply, MulOpposite.opAddEquiv_symm_apply]\n      rw [MulOpposite.unop_mul (α := MonoidAlgebra k G), unop_op, unop_op, single_mul_single]\n      simp }\n\n"}
{"name":"MonoidAlgebra.opRingEquiv_symm_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Monoid G\na✝ : Finsupp (MulOpposite G) (MulOpposite k)\n⊢ Eq (MonoidAlgebra.opRingEquiv.symm a✝) (MulOpposite.op (Finsupp.mapRange MulOpposite.unop ⋯ (Finsupp.equivMapDomain MulOpposite.opEquiv.symm a✝)))","decl":"/-- The opposite of a `MonoidAlgebra R I` equivalent as a ring to\nthe `MonoidAlgebra Rᵐᵒᵖ Iᵐᵒᵖ` over the opposite ring, taking elements to their opposite. -/\n@[simps! (config := { simpRhs := true }) apply symm_apply]\nprotected noncomputable def opRingEquiv [Monoid G] :\n    (MonoidAlgebra k G)ᵐᵒᵖ ≃+* MonoidAlgebra kᵐᵒᵖ Gᵐᵒᵖ :=\n  { opAddEquiv.symm.trans <|\n      (Finsupp.mapRange.addEquiv (opAddEquiv : k ≃+ kᵐᵒᵖ)).trans <| Finsupp.domCongr opEquiv with\n    map_mul' := by\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      rw [Equiv.toFun_as_coe, AddEquiv.toEquiv_eq_coe]; erw [AddEquiv.coe_toEquiv]\n      rw [← AddEquiv.coe_toAddMonoidHom]\n      refine Iff.mpr (AddMonoidHom.map_mul_iff (R := (MonoidAlgebra k G)ᵐᵒᵖ)\n        (S := MonoidAlgebra kᵐᵒᵖ Gᵐᵒᵖ) _) ?_\n      ext\n      -- Porting note: `reducible` cannot be `local` so proof gets long.\n      simp only [AddMonoidHom.coe_comp, AddEquiv.coe_toAddMonoidHom, opAddEquiv_apply,\n        Function.comp_apply, singleAddHom_apply, AddMonoidHom.compr₂_apply, AddMonoidHom.coe_mul,\n        AddMonoidHom.coe_mulLeft, AddMonoidHom.compl₂_apply]\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      erw [AddEquiv.trans_apply, AddEquiv.trans_apply, AddEquiv.trans_apply, AddEquiv.trans_apply,\n        AddEquiv.trans_apply, AddEquiv.trans_apply, MulOpposite.opAddEquiv_symm_apply]\n      rw [MulOpposite.unop_mul (α := MonoidAlgebra k G), unop_op, unop_op, single_mul_single]\n      simp }\n\n"}
{"name":"MonoidAlgebra.opRingEquiv_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Monoid G\nr : k\nx : G\n⊢ Eq (MonoidAlgebra.opRingEquiv (MulOpposite.op (MonoidAlgebra.single x r))) (MonoidAlgebra.single (MulOpposite.op x) (MulOpposite.op r))","decl":"theorem opRingEquiv_single [Monoid G] (r : k) (x : G) :\n    MonoidAlgebra.opRingEquiv (op (single x r)) = single (op x) (op r) := by simp\n\n"}
{"name":"MonoidAlgebra.opRingEquiv_symm_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Monoid G\nr : MulOpposite k\nx : MulOpposite G\n⊢ Eq (MonoidAlgebra.opRingEquiv.symm (MonoidAlgebra.single x r)) (MulOpposite.op (MonoidAlgebra.single (MulOpposite.unop x) (MulOpposite.unop r)))","decl":"theorem opRingEquiv_symm_single [Monoid G] (r : kᵐᵒᵖ) (x : Gᵐᵒᵖ) :\n    MonoidAlgebra.opRingEquiv.symm (single x r) = op (single x.unop r.unop) := by simp\n\n"}
{"name":"MonoidAlgebra.isLocalHom_singleOneRingHom","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Monoid G\n⊢ IsLocalHom MonoidAlgebra.singleOneRingHom","decl":"instance isLocalHom_singleOneRingHom [Semiring k] [Monoid G] :\n    IsLocalHom (singleOneRingHom (k := k) (G := G)) where\n  map_nonunit x hx := by\n    obtain ⟨⟨x, xi, hx, hxi⟩, rfl⟩ := hx\n    simp_rw [MonoidAlgebra.ext_iff, singleOneRingHom_apply] at hx hxi ⊢\n    specialize hx 1\n    specialize hxi 1\n    classical\n    simp_rw [single_one_mul_apply, one_def, single_apply, if_pos] at hx\n    simp_rw [mul_single_one_apply, one_def, single_apply, if_pos] at hxi\n    exact ⟨⟨x, xi 1, hx, hxi⟩, rfl⟩\n\n"}
{"name":"AddMonoidAlgebra.instIsCancelAdd","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : IsCancelAdd k\n⊢ IsCancelAdd (AddMonoidAlgebra k G)","decl":"instance instIsCancelAdd [IsCancelAdd k] : IsCancelAdd (AddMonoidAlgebra k G) :=\n  inferInstanceAs (IsCancelAdd (G →₀ k))\n\n"}
{"name":"AddMonoidAlgebra.single_zero","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\na : G\n⊢ Eq (AddMonoidAlgebra.single a 0) 0","decl":"theorem single_zero (a : G) : (single a 0 : k[G]) = 0 := Finsupp.single_zero a\n\n"}
{"name":"AddMonoidAlgebra.single_add","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\na : G\nb₁ b₂ : k\n⊢ Eq (AddMonoidAlgebra.single a (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (AddMonoidAlgebra.single a b₁) (AddMonoidAlgebra.single a b₂))","decl":"theorem single_add (a : G) (b₁ b₂ : k) : single a (b₁ + b₂) = single a b₁ + single a b₂ :=\n  Finsupp.single_add a b₁ b₂\n\n"}
{"name":"AddMonoidAlgebra.sum_single_index","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\nN : Type u_3\ninst✝ : AddCommMonoid N\na : G\nb : k\nh : G → k → N\nh_zero : Eq (h a 0) 0\n⊢ Eq (Finsupp.sum (AddMonoidAlgebra.single a b) h) (h a b)","decl":"@[simp]\ntheorem sum_single_index {N} [AddCommMonoid N] {a : G} {b : k} {h : G → k → N}\n    (h_zero : h a 0 = 0) :\n    (single a b).sum h = h a b := Finsupp.sum_single_index h_zero\n\n"}
{"name":"AddMonoidAlgebra.sum_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\nf : AddMonoidAlgebra k G\n⊢ Eq (Finsupp.sum f AddMonoidAlgebra.single) f","decl":"@[simp]\ntheorem sum_single (f : k[G]) : f.sum single = f :=\n  Finsupp.sum_single f\n\n"}
{"name":"AddMonoidAlgebra.single_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\na a' : G\nb : k\ninst✝ : Decidable (Eq a a')\n⊢ Eq ((AddMonoidAlgebra.single a b) a') (ite (Eq a a') b 0)","decl":"theorem single_apply {a a' : G} {b : k} [Decidable (a = a')] :\n    single a b a' = if a = a' then b else 0 :=\n  Finsupp.single_apply\n\n"}
{"name":"AddMonoidAlgebra.single_eq_zero","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\na : G\nb : k\n⊢ Iff (Eq (AddMonoidAlgebra.single a b) 0) (Eq b 0)","decl":"@[simp]\ntheorem single_eq_zero {a : G} {b : k} : single a b = 0 ↔ b = 0 := Finsupp.single_eq_zero\n\n"}
{"name":"AddMonoidAlgebra.mapDomain_sum","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\nk' : Type u_3\nG' : Type u_4\ninst✝ : Semiring k'\nf : G → G'\ns : AddMonoidAlgebra k' G\nv : G → k' → AddMonoidAlgebra k G\n⊢ Eq (AddMonoidAlgebra.mapDomain f (Finsupp.sum s v)) (Finsupp.sum s fun a b => AddMonoidAlgebra.mapDomain f (v a b))","decl":"theorem mapDomain_sum {k' G' : Type*} [Semiring k'] {f : G → G'} {s : AddMonoidAlgebra k' G}\n    {v : G → k' → k[G]} :\n    mapDomain f (s.sum v) = s.sum fun a b => mapDomain f (v a b) :=\n  Finsupp.mapDomain_sum\n\n"}
{"name":"AddMonoidAlgebra.mapDomain_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\nG' : Type u_3\nf : G → G'\na : G\nb : k\n⊢ Eq (AddMonoidAlgebra.mapDomain f (AddMonoidAlgebra.single a b)) (AddMonoidAlgebra.single (f a) b)","decl":"theorem mapDomain_single {G' : Type*} {f : G → G'} {a : G} {b : k} :\n    mapDomain f (single a b) = single (f a) b :=\n  Finsupp.mapDomain_single\n\n"}
{"name":"AddMonoidAlgebra.liftNC_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝¹ : Semiring k\ninst✝ : NonUnitalNonAssocSemiring R\nf : AddMonoidHom k R\ng : Multiplicative G → R\na : G\nb : k\n⊢ Eq ((AddMonoidAlgebra.liftNC f g) (AddMonoidAlgebra.single a b)) (HMul.hMul (f b) (g (Multiplicative.ofAdd a)))","decl":"@[simp]\ntheorem liftNC_single (f : k →+ R) (g : Multiplicative G → R) (a : G) (b : k) :\n    liftNC f g (single a b) = f b * g (Multiplicative.ofAdd a) :=\n  liftAddHom_apply_single _ _ _\n\n"}
{"name":"AddMonoidAlgebra.mul_def","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Add G\nf g : AddMonoidAlgebra k G\n⊢ Eq (HMul.hMul f g) (Finsupp.sum f fun a₁ b₁ => Finsupp.sum g fun a₂ b₂ => AddMonoidAlgebra.single (HAdd.hAdd a₁ a₂) (HMul.hMul b₁ b₂))","decl":"theorem mul_def {f g : k[G]} :\n    f * g = f.sum fun a₁ b₁ => g.sum fun a₂ b₂ => single (a₁ + a₂) (b₁ * b₂) :=\n  MonoidAlgebra.mul_def (G := Multiplicative G)\n\n"}
{"name":"AddMonoidAlgebra.liftNC_mul","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝⁴ : Semiring k\ninst✝³ : Add G\ninst✝² : Semiring R\ng_hom : Type u_3\ninst✝¹ : FunLike g_hom (Multiplicative G) R\ninst✝ : MulHomClass g_hom (Multiplicative G) R\nf : RingHom k R\ng : g_hom\na b : AddMonoidAlgebra k G\nh_comm : ∀ {x y : G}, Membership.mem a.support y → Commute (f (b x)) (g (Multiplicative.ofAdd y))\n⊢ Eq ((AddMonoidAlgebra.liftNC ↑f ⇑g) (HMul.hMul a b)) (HMul.hMul ((AddMonoidAlgebra.liftNC ↑f ⇑g) a) ((AddMonoidAlgebra.liftNC ↑f ⇑g) b))","decl":"theorem liftNC_mul {g_hom : Type*}\n    [FunLike g_hom (Multiplicative G) R] [MulHomClass g_hom (Multiplicative G) R]\n    (f : k →+* R) (g : g_hom) (a b : k[G])\n    (h_comm : ∀ {x y}, y ∈ a.support → Commute (f (b x)) (g <| Multiplicative.ofAdd y)) :\n    liftNC (f : k →+ R) g (a * b) = liftNC (f : k →+ R) g a * liftNC (f : k →+ R) g b :=\n  MonoidAlgebra.liftNC_mul f g _ _ @h_comm\n\n"}
{"name":"AddMonoidAlgebra.one_def","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Zero G\n⊢ Eq 1 (AddMonoidAlgebra.single 0 1)","decl":"theorem one_def : (1 : k[G]) = single 0 1 :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.liftNC_one","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝⁴ : Semiring k\ninst✝³ : Zero G\ninst✝² : NonAssocSemiring R\ng_hom : Type u_3\ninst✝¹ : FunLike g_hom (Multiplicative G) R\ninst✝ : OneHomClass g_hom (Multiplicative G) R\nf : RingHom k R\ng : g_hom\n⊢ Eq ((AddMonoidAlgebra.liftNC ↑f ⇑g) 1) 1","decl":"@[simp]\ntheorem liftNC_one {g_hom : Type*}\n    [FunLike g_hom (Multiplicative G) R] [OneHomClass g_hom (Multiplicative G) R]\n    (f : k →+* R) (g : g_hom) : liftNC (f : k →+ R) g 1 = 1 :=\n  MonoidAlgebra.liftNC_one f g\n\n"}
{"name":"AddMonoidAlgebra.natCast_def","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddZeroClass G\nn : Nat\n⊢ Eq (↑n) (AddMonoidAlgebra.single 0 ↑n)","decl":"theorem natCast_def (n : ℕ) : (n : k[G]) = single (0 : G) (n : k) :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.noZeroSMulDivisors","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : Zero R\ninst✝² : Semiring k\ninst✝¹ : SMulZeroClass R k\ninst✝ : NoZeroSMulDivisors R k\n⊢ NoZeroSMulDivisors R (AddMonoidAlgebra k G)","decl":"instance noZeroSMulDivisors [Zero R] [Semiring k] [SMulZeroClass R k] [NoZeroSMulDivisors R k] :\n    NoZeroSMulDivisors R k[G] :=\n  Finsupp.noZeroSMulDivisors\n\n"}
{"name":"AddMonoidAlgebra.nontrivial","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝² : Semiring k\ninst✝¹ : Nontrivial k\ninst✝ : Nonempty G\n⊢ Nontrivial (AddMonoidAlgebra k G)","decl":"instance nontrivial [Semiring k] [Nontrivial k] [Nonempty G] : Nontrivial k[G] :=\n  Finsupp.instNontrivial\n\n"}
{"name":"AddMonoidAlgebra.intCast_def","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Ring k\ninst✝ : AddZeroClass G\nz : Int\n⊢ Eq (↑z) (AddMonoidAlgebra.single 0 ↑z)","decl":"theorem intCast_def [Ring k] [AddZeroClass G] (z : ℤ) :\n    (z : k[G]) = single (0 : G) (z : k) :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.faithfulSMul","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : Semiring k\ninst✝² : SMulZeroClass R k\ninst✝¹ : FaithfulSMul R k\ninst✝ : Nonempty G\n⊢ FaithfulSMul R (AddMonoidAlgebra k G)","decl":"instance faithfulSMul [Semiring k] [SMulZeroClass R k] [FaithfulSMul R k] [Nonempty G] :\n    FaithfulSMul R k[G] :=\n  Finsupp.faithfulSMul\n\n"}
{"name":"AddMonoidAlgebra.isScalarTower","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\nS : Type u_3\ninst✝⁴ : Semiring k\ninst✝³ : SMulZeroClass R k\ninst✝² : SMulZeroClass S k\ninst✝¹ : SMul R S\ninst✝ : IsScalarTower R S k\n⊢ IsScalarTower R S (AddMonoidAlgebra k G)","decl":"instance isScalarTower [Semiring k] [SMulZeroClass R k] [SMulZeroClass S k] [SMul R S]\n    [IsScalarTower R S k] : IsScalarTower R S k[G] :=\n  Finsupp.isScalarTower G k\n\n"}
{"name":"AddMonoidAlgebra.smulCommClass","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\nS : Type u_3\ninst✝³ : Semiring k\ninst✝² : SMulZeroClass R k\ninst✝¹ : SMulZeroClass S k\ninst✝ : SMulCommClass R S k\n⊢ SMulCommClass R S (AddMonoidAlgebra k G)","decl":"instance smulCommClass [Semiring k] [SMulZeroClass R k] [SMulZeroClass S k] [SMulCommClass R S k] :\n    SMulCommClass R S k[G] :=\n  Finsupp.smulCommClass G k\n\n"}
{"name":"AddMonoidAlgebra.isCentralScalar","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : Semiring k\ninst✝² : SMulZeroClass R k\ninst✝¹ : SMulZeroClass (MulOpposite R) k\ninst✝ : IsCentralScalar R k\n⊢ IsCentralScalar R (AddMonoidAlgebra k G)","decl":"instance isCentralScalar [Semiring k] [SMulZeroClass R k] [SMulZeroClass Rᵐᵒᵖ k]\n    [IsCentralScalar R k] : IsCentralScalar R k[G] :=\n  Finsupp.isCentralScalar G k\n\n"}
{"name":"AddMonoidAlgebra.smul_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝¹ : Semiring k\ninst✝ : SMulZeroClass R k\na : G\nc : R\nb : k\n⊢ Eq (HSMul.hSMul c (AddMonoidAlgebra.single a b)) (AddMonoidAlgebra.single a (HSMul.hSMul c b))","decl":"@[simp]\ntheorem smul_single [Semiring k] [SMulZeroClass R k] (a : G) (c : R) (b : k) :\n    c • single a b = single a (c • b) :=\n  Finsupp.smul_single _ _ _\n\n"}
{"name":"AddMonoidAlgebra.ext","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\nf g : AddMonoidAlgebra k G\nH : ∀ (x : G), Eq (f x) (g x)\n⊢ Eq f g","decl":"/-- A copy of `Finsupp.ext` for `AddMonoidAlgebra`. -/\n@[ext]\ntheorem ext [Semiring k] ⦃f g : AddMonoidAlgebra k G⦄ (H : ∀ (x : G), f x = g x) :\n    f = g :=\n  Finsupp.ext H\n\n"}
{"name":"AddMonoidAlgebra.ext_iff","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\nf g : AddMonoidAlgebra k G\n⊢ Iff (Eq f g) (∀ (x : G), Eq (f x) (g x))","decl":"/-- A copy of `Finsupp.ext` for `AddMonoidAlgebra`. -/\n@[ext]\ntheorem ext [Semiring k] ⦃f g : AddMonoidAlgebra k G⦄ (H : ∀ (x : G), f x = g x) :\n    f = g :=\n  Finsupp.ext H\n\n"}
{"name":"AddMonoidAlgebra.singleAddHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\na : G\nb : k\n⊢ Eq ((AddMonoidAlgebra.singleAddHom a) b) (AddMonoidAlgebra.single a b)","decl":"@[simp] lemma singleAddHom_apply [Semiring k] (a : G) (b : k) :\n  singleAddHom a b = single a b := rfl\n\n"}
{"name":"AddMonoidAlgebra.addHom_ext'_iff","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nN : Type u_3\ninst✝¹ : Semiring k\ninst✝ : AddZeroClass N\nf g : AddMonoidHom (AddMonoidAlgebra k G) N\n⊢ Iff (Eq f g) (∀ (x : G), Eq (f.comp (AddMonoidAlgebra.singleAddHom x)) (g.comp (AddMonoidAlgebra.singleAddHom x)))","decl":"/-- A copy of `Finsupp.addHom_ext'` for `AddMonoidAlgebra`. -/\n@[ext high]\ntheorem addHom_ext' {N : Type*} [Semiring k] [AddZeroClass N]\n    ⦃f g : AddMonoidAlgebra k G →+ N⦄\n    (H : ∀ (x : G), AddMonoidHom.comp f (singleAddHom x) = AddMonoidHom.comp g (singleAddHom x)) :\n    f = g :=\n  Finsupp.addHom_ext' H\n\n"}
{"name":"AddMonoidAlgebra.addHom_ext'","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nN : Type u_3\ninst✝¹ : Semiring k\ninst✝ : AddZeroClass N\nf g : AddMonoidHom (AddMonoidAlgebra k G) N\nH : ∀ (x : G), Eq (f.comp (AddMonoidAlgebra.singleAddHom x)) (g.comp (AddMonoidAlgebra.singleAddHom x))\n⊢ Eq f g","decl":"/-- A copy of `Finsupp.addHom_ext'` for `AddMonoidAlgebra`. -/\n@[ext high]\ntheorem addHom_ext' {N : Type*} [Semiring k] [AddZeroClass N]\n    ⦃f g : AddMonoidAlgebra k G →+ N⦄\n    (H : ∀ (x : G), AddMonoidHom.comp f (singleAddHom x) = AddMonoidHom.comp g (singleAddHom x)) :\n    f = g :=\n  Finsupp.addHom_ext' H\n\n"}
{"name":"AddMonoidAlgebra.distribMulActionHom_ext'_iff","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\nN : Type u_3\ninst✝⁴ : Monoid R\ninst✝³ : Semiring k\ninst✝² : AddMonoid N\ninst✝¹ : DistribMulAction R N\ninst✝ : DistribMulAction R k\nf g : DistribMulActionHom (MonoidHom.id R) (AddMonoidAlgebra k G) N\n⊢ Iff (Eq f g) (∀ (a : G), Eq (f.comp (Finsupp.DistribMulActionHom.single a)) (g.comp (Finsupp.DistribMulActionHom.single a)))","decl":"/-- A copy of `Finsupp.distribMulActionHom_ext'` for `AddMonoidAlgebra`. -/\n@[ext]\ntheorem distribMulActionHom_ext' {N : Type*} [Monoid R] [Semiring k] [AddMonoid N]\n    [DistribMulAction R N] [DistribMulAction R k]\n    {f g : AddMonoidAlgebra k G →+[R] N}\n    (h : ∀ a : G,\n      f.comp (DistribMulActionHom.single (M := k) a) = g.comp (DistribMulActionHom.single a)) :\n    f = g :=\n  Finsupp.distribMulActionHom_ext' h\n\n"}
{"name":"AddMonoidAlgebra.distribMulActionHom_ext'","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\nN : Type u_3\ninst✝⁴ : Monoid R\ninst✝³ : Semiring k\ninst✝² : AddMonoid N\ninst✝¹ : DistribMulAction R N\ninst✝ : DistribMulAction R k\nf g : DistribMulActionHom (MonoidHom.id R) (AddMonoidAlgebra k G) N\nh : ∀ (a : G), Eq (f.comp (Finsupp.DistribMulActionHom.single a)) (g.comp (Finsupp.DistribMulActionHom.single a))\n⊢ Eq f g","decl":"/-- A copy of `Finsupp.distribMulActionHom_ext'` for `AddMonoidAlgebra`. -/\n@[ext]\ntheorem distribMulActionHom_ext' {N : Type*} [Monoid R] [Semiring k] [AddMonoid N]\n    [DistribMulAction R N] [DistribMulAction R k]\n    {f g : AddMonoidAlgebra k G →+[R] N}\n    (h : ∀ a : G,\n      f.comp (DistribMulActionHom.single (M := k) a) = g.comp (DistribMulActionHom.single a)) :\n    f = g :=\n  Finsupp.distribMulActionHom_ext' h\n\n"}
{"name":"AddMonoidAlgebra.lsingle_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : Semiring k\ninst✝ : Module R k\na : G\nb : k\n⊢ Eq ((AddMonoidAlgebra.lsingle a) b) (AddMonoidAlgebra.single a b)","decl":"@[simp] lemma lsingle_apply [Semiring R] [Semiring k] [Module R k] (a : G) (b : k) :\n  lsingle (R := R) a b = single a b := rfl\n\n"}
{"name":"AddMonoidAlgebra.lhom_ext'_iff","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\nN : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : Semiring k\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : Module R k\nf g : LinearMap (RingHom.id R) (AddMonoidAlgebra k G) N\n⊢ Iff (Eq f g) (∀ (x : G), Eq (f.comp (AddMonoidAlgebra.lsingle x)) (g.comp (AddMonoidAlgebra.lsingle x)))","decl":"/-- A copy of `Finsupp.lhom_ext'` for `AddMonoidAlgebra`. -/\n@[ext high]\nlemma lhom_ext' {N : Type*} [Semiring R] [Semiring k] [AddCommMonoid N] [Module R N] [Module R k]\n    ⦃f g : AddMonoidAlgebra k G →ₗ[R] N⦄\n    (H : ∀ (x : G), LinearMap.comp f (lsingle x) = LinearMap.comp g (lsingle x)) :\n    f = g :=\n  Finsupp.lhom_ext' H\n\n"}
{"name":"AddMonoidAlgebra.lhom_ext'","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\nN : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : Semiring k\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : Module R k\nf g : LinearMap (RingHom.id R) (AddMonoidAlgebra k G) N\nH : ∀ (x : G), Eq (f.comp (AddMonoidAlgebra.lsingle x)) (g.comp (AddMonoidAlgebra.lsingle x))\n⊢ Eq f g","decl":"/-- A copy of `Finsupp.lhom_ext'` for `AddMonoidAlgebra`. -/\n@[ext high]\nlemma lhom_ext' {N : Type*} [Semiring R] [Semiring k] [AddCommMonoid N] [Module R N] [Module R k]\n    ⦃f g : AddMonoidAlgebra k G →ₗ[R] N⦄\n    (H : ∀ (x : G), LinearMap.comp f (lsingle x) = LinearMap.comp g (lsingle x)) :\n    f = g :=\n  Finsupp.lhom_ext' H\n\n"}
{"name":"AddMonoidAlgebra.mul_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝² : Semiring k\ninst✝¹ : DecidableEq G\ninst✝ : Add G\nf g : AddMonoidAlgebra k G\nx : G\n⊢ Eq ((HMul.hMul f g) x) (Finsupp.sum f fun a₁ b₁ => Finsupp.sum g fun a₂ b₂ => ite (Eq (HAdd.hAdd a₁ a₂) x) (HMul.hMul b₁ b₂) 0)","decl":"theorem mul_apply [DecidableEq G] [Add G] (f g : k[G]) (x : G) :\n    (f * g) x = f.sum fun a₁ b₁ => g.sum fun a₂ b₂ => if a₁ + a₂ = x then b₁ * b₂ else 0 :=\n  @MonoidAlgebra.mul_apply k (Multiplicative G) _ _ _ _ _ _\n\n"}
{"name":"AddMonoidAlgebra.mul_apply_antidiagonal","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Add G\nf g : AddMonoidAlgebra k G\nx : G\ns : Finset (Prod G G)\nhs : ∀ {p : Prod G G}, Iff (Membership.mem s p) (Eq (HAdd.hAdd p.1 p.2) x)\n⊢ Eq ((HMul.hMul f g) x) (s.sum fun p => HMul.hMul (f p.1) (g p.2))","decl":"theorem mul_apply_antidiagonal [Add G] (f g : k[G]) (x : G) (s : Finset (G × G))\n    (hs : ∀ {p : G × G}, p ∈ s ↔ p.1 + p.2 = x) : (f * g) x = ∑ p ∈ s, f p.1 * g p.2 :=\n  @MonoidAlgebra.mul_apply_antidiagonal k (Multiplicative G) _ _ _ _ _ s @hs\n\n"}
{"name":"AddMonoidAlgebra.single_mul_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Add G\na₁ a₂ : G\nb₁ b₂ : k\n⊢ Eq (HMul.hMul (AddMonoidAlgebra.single a₁ b₁) (AddMonoidAlgebra.single a₂ b₂)) (AddMonoidAlgebra.single (HAdd.hAdd a₁ a₂) (HMul.hMul b₁ b₂))","decl":"theorem single_mul_single [Add G] {a₁ a₂ : G} {b₁ b₂ : k} :\n    single a₁ b₁ * single a₂ b₂ = single (a₁ + a₂) (b₁ * b₂) :=\n  @MonoidAlgebra.single_mul_single k (Multiplicative G) _ _ _ _ _ _\n\n"}
{"name":"AddMonoidAlgebra.single_commute_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Add G\na₁ a₂ : G\nb₁ b₂ : k\nha : AddCommute a₁ a₂\nhb : Commute b₁ b₂\n⊢ Commute (AddMonoidAlgebra.single a₁ b₁) (AddMonoidAlgebra.single a₂ b₂)","decl":"theorem single_commute_single [Add G] {a₁ a₂ : G} {b₁ b₂ : k}\n    (ha : AddCommute a₁ a₂) (hb : Commute b₁ b₂) :\n    Commute (single a₁ b₁) (single a₂ b₂) :=\n  @MonoidAlgebra.single_commute_single k (Multiplicative G) _ _ _ _ _ _ ha hb\n\n-- This should be a `@[simp]` lemma, but the simp_nf linter times out if we add this.\n-- Probably the correct fix is to make a `[Add]MonoidAlgebra.single` with the correct type,\n-- instead of relying on `Finsupp.single`.\n"}
{"name":"AddMonoidAlgebra.single_pow","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddMonoid G\na : G\nb : k\nn : Nat\n⊢ Eq (HPow.hPow (AddMonoidAlgebra.single a b) n) (AddMonoidAlgebra.single (HSMul.hSMul n a) (HPow.hPow b n))","decl":"theorem single_pow [AddMonoid G] {a : G} {b : k} : ∀ n : ℕ, single a b ^ n = single (n • a) (b ^ n)\n  | 0 => by\n    simp only [pow_zero, zero_nsmul]\n    rfl\n  | n + 1 => by\n    rw [pow_succ, pow_succ, single_pow n, single_mul_single, add_nsmul, one_nsmul]\n\n"}
{"name":"AddMonoidAlgebra.mapDomain_one","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nα₂ : Type u_5\ninst✝⁴ : Semiring β\ninst✝³ : Zero α\ninst✝² : Zero α₂\nF : Type u_6\ninst✝¹ : FunLike F α α₂\ninst✝ : ZeroHomClass F α α₂\nf : F\n⊢ Eq (AddMonoidAlgebra.mapDomain (⇑f) 1) 1","decl":"/-- Like `Finsupp.mapDomain_zero`, but for the `1` we define in this file -/\n@[simp]\ntheorem mapDomain_one {α : Type*} {β : Type*} {α₂ : Type*} [Semiring β] [Zero α] [Zero α₂]\n    {F : Type*} [FunLike F α α₂] [ZeroHomClass F α α₂] (f : F) :\n    (mapDomain f (1 : AddMonoidAlgebra β α) : AddMonoidAlgebra β α₂) =\n      (1 : AddMonoidAlgebra β α₂) := by\n  simp_rw [one_def, mapDomain_single, map_zero]\n\n"}
{"name":"AddMonoidAlgebra.mapDomain_mul","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"α : Type u_3\nβ : Type u_4\nα₂ : Type u_5\ninst✝⁴ : Semiring β\ninst✝³ : Add α\ninst✝² : Add α₂\nF : Type u_6\ninst✝¹ : FunLike F α α₂\ninst✝ : AddHomClass F α α₂\nf : F\nx y : AddMonoidAlgebra β α\n⊢ Eq (AddMonoidAlgebra.mapDomain (⇑f) (HMul.hMul x y)) (HMul.hMul (AddMonoidAlgebra.mapDomain (⇑f) x) (AddMonoidAlgebra.mapDomain (⇑f) y))","decl":"/-- Like `Finsupp.mapDomain_add`, but for the convolutive multiplication we define in this file -/\ntheorem mapDomain_mul {α : Type*} {β : Type*} {α₂ : Type*} [Semiring β] [Add α] [Add α₂]\n    {F : Type*} [FunLike F α α₂] [AddHomClass F α α₂] (f : F) (x y : AddMonoidAlgebra β α) :\n    mapDomain f (x * y) = mapDomain f x * mapDomain f y := by\n  simp_rw [mul_def, mapDomain_sum, mapDomain_single, map_add]\n  rw [Finsupp.sum_mapDomain_index]\n  · congr\n    ext a b\n    rw [Finsupp.sum_mapDomain_index]\n    · simp\n    · simp [mul_add]\n  · simp\n  · simp [add_mul]\n\n"}
{"name":"AddMonoidAlgebra.ofMagma_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Add G\na : Multiplicative G\n⊢ Eq ((AddMonoidAlgebra.ofMagma k G) a) (AddMonoidAlgebra.single a 1)","decl":"/-- The embedding of an additive magma into its additive magma algebra. -/\n@[simps]\ndef ofMagma [Add G] : Multiplicative G →ₙ* k[G] where\n  toFun a := single a 1\n  map_mul' a b := by simp only [mul_def, mul_one, sum_single_index, single_eq_zero, mul_zero]; rfl\n\n"}
{"name":"AddMonoidAlgebra.of_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddZeroClass G\na : Multiplicative G\n⊢ Eq ((AddMonoidAlgebra.of k G) a) (AddMonoidAlgebra.single (Multiplicative.toAdd a) 1)","decl":"@[simp]\ntheorem of_apply [AddZeroClass G] (a : Multiplicative G) :\n    of k G a = single a.toAdd 1 :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.of'_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\na : G\n⊢ Eq (AddMonoidAlgebra.of' k G a) (AddMonoidAlgebra.single a 1)","decl":"@[simp]\ntheorem of'_apply (a : G) : of' k G a = single a 1 :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.of'_eq_of","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddZeroClass G\na : G\n⊢ Eq (AddMonoidAlgebra.of' k G a) ((AddMonoidAlgebra.of k G) (Multiplicative.ofAdd a))","decl":"theorem of'_eq_of [AddZeroClass G] (a : G) : of' k G a = of k G (.ofAdd a) := rfl\n\n"}
{"name":"AddMonoidAlgebra.of_injective","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝² : Semiring k\ninst✝¹ : Nontrivial k\ninst✝ : AddZeroClass G\n⊢ Function.Injective ⇑(AddMonoidAlgebra.of k G)","decl":"theorem of_injective [Nontrivial k] [AddZeroClass G] : Function.Injective (of k G) :=\n  MonoidAlgebra.of_injective\n\n"}
{"name":"AddMonoidAlgebra.of'_commute","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddZeroClass G\na : G\nh : ∀ (a' : G), AddCommute a a'\nf : AddMonoidAlgebra k G\n⊢ Commute (AddMonoidAlgebra.of' k G a) f","decl":"theorem of'_commute [AddZeroClass G] {a : G} (h : ∀ a', AddCommute a a')\n    (f : AddMonoidAlgebra k G) :\n    Commute (of' k G a) f :=\n  MonoidAlgebra.of_commute (G := Multiplicative G) h f\n\n"}
{"name":"AddMonoidAlgebra.singleHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddZeroClass G\na : Prod k (Multiplicative G)\n⊢ Eq (AddMonoidAlgebra.singleHom a) (AddMonoidAlgebra.single (Multiplicative.toAdd a.2) a.1)","decl":"/-- `Finsupp.single` as a `MonoidHom` from the product type into the additive monoid algebra.\n\nNote the order of the elements of the product are reversed compared to the arguments of\n`Finsupp.single`.\n-/\n@[simps]\ndef singleHom [AddZeroClass G] : k × Multiplicative G →* k[G] where\n  toFun a := single a.2.toAdd a.1\n  map_one' := rfl\n  map_mul' _a _b := single_mul_single.symm\n\n"}
{"name":"AddMonoidAlgebra.smul_single'","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝ : Semiring k\nc : k\na : G\nb : k\n⊢ Eq (HSMul.hSMul c (AddMonoidAlgebra.single a b)) (AddMonoidAlgebra.single a (HMul.hMul c b))","decl":"/-- Copy of `Finsupp.smul_single'` that avoids the `AddMonoidAlgebra = Finsupp` defeq abuse. -/\ntheorem smul_single' (c : k) (a : G) (b : k) : c • single a b = single a (c * b) :=\n  Finsupp.smul_single' c a b\n\n"}
{"name":"AddMonoidAlgebra.mul_single_apply_aux","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Add G\nf : AddMonoidAlgebra k G\nr : k\nx y z : G\nH : ∀ (a : G), Membership.mem f.support a → Iff (Eq (HAdd.hAdd a x) z) (Eq a y)\n⊢ Eq ((HMul.hMul f (AddMonoidAlgebra.single x r)) z) (HMul.hMul (f y) r)","decl":"theorem mul_single_apply_aux [Add G] (f : k[G]) (r : k) (x y z : G)\n    (H : ∀ a ∈ f.support, a + x = z ↔ a = y) : (f * single x r) z = f y * r :=\n  @MonoidAlgebra.mul_single_apply_aux k (Multiplicative G) _ _ _ _ _ _ _ H\n\n"}
{"name":"AddMonoidAlgebra.mul_single_zero_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddZeroClass G\nf : AddMonoidAlgebra k G\nr : k\nx : G\n⊢ Eq ((HMul.hMul f (AddMonoidAlgebra.single 0 r)) x) (HMul.hMul (f x) r)","decl":"theorem mul_single_zero_apply [AddZeroClass G] (f : k[G]) (r : k) (x : G) :\n    (f * single (0 : G) r) x = f x * r :=\n  f.mul_single_apply_aux r _ _ _ fun a _ => by rw [add_zero]\n\n"}
{"name":"AddMonoidAlgebra.mul_single_apply_of_not_exists_add","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Add G\nr : k\ng g' : G\nx : AddMonoidAlgebra k G\nh : Not (Exists fun d => Eq g' (HAdd.hAdd d g))\n⊢ Eq ((HMul.hMul x (AddMonoidAlgebra.single g r)) g') 0","decl":"theorem mul_single_apply_of_not_exists_add [Add G] (r : k) {g g' : G} (x : k[G])\n    (h : ¬∃ d, g' = d + g) : (x * single g r) g' = 0 :=\n  @MonoidAlgebra.mul_single_apply_of_not_exists_mul k (Multiplicative G) _ _ _ _ _ _ h\n\n"}
{"name":"AddMonoidAlgebra.single_mul_apply_aux","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Add G\nf : AddMonoidAlgebra k G\nr : k\nx y z : G\nH : ∀ (a : G), Membership.mem f.support a → Iff (Eq (HAdd.hAdd x a) y) (Eq a z)\n⊢ Eq ((HMul.hMul (AddMonoidAlgebra.single x r) f) y) (HMul.hMul r (f z))","decl":"theorem single_mul_apply_aux [Add G] (f : k[G]) (r : k) (x y z : G)\n    (H : ∀ a ∈ f.support, x + a = y ↔ a = z) : (single x r * f) y = r * f z :=\n  @MonoidAlgebra.single_mul_apply_aux k (Multiplicative G) _ _ _ _ _ _ _ H\n\n"}
{"name":"AddMonoidAlgebra.single_zero_mul_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddZeroClass G\nf : AddMonoidAlgebra k G\nr : k\nx : G\n⊢ Eq ((HMul.hMul (AddMonoidAlgebra.single 0 r) f) x) (HMul.hMul r (f x))","decl":"theorem single_zero_mul_apply [AddZeroClass G] (f : k[G]) (r : k) (x : G) :\n    (single (0 : G) r * f) x = r * f x :=\n  f.single_mul_apply_aux r _ _ _ fun a _ => by rw [zero_add]\n\n"}
{"name":"AddMonoidAlgebra.single_mul_apply_of_not_exists_add","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : Add G\nr : k\ng g' : G\nx : AddMonoidAlgebra k G\nh : Not (Exists fun d => Eq g' (HAdd.hAdd g d))\n⊢ Eq ((HMul.hMul (AddMonoidAlgebra.single g r) x) g') 0","decl":"theorem single_mul_apply_of_not_exists_add [Add G] (r : k) {g g' : G} (x : k[G])\n    (h : ¬∃ d, g' = g + d) : (single g r * x) g' = 0 :=\n  @MonoidAlgebra.single_mul_apply_of_not_exists_mul k (Multiplicative G) _ _ _ _ _ _ h\n\n"}
{"name":"AddMonoidAlgebra.mul_single_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddGroup G\nf : AddMonoidAlgebra k G\nr : k\nx y : G\n⊢ Eq ((HMul.hMul f (AddMonoidAlgebra.single x r)) y) (HMul.hMul (f (HSub.hSub y x)) r)","decl":"theorem mul_single_apply [AddGroup G] (f : k[G]) (r : k) (x y : G) :\n    (f * single x r) y = f (y - x) * r :=\n  (sub_eq_add_neg y x).symm ▸ @MonoidAlgebra.mul_single_apply k (Multiplicative G) _ _ _ _ _ _\n\n"}
{"name":"AddMonoidAlgebra.single_mul_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddGroup G\nr : k\nx : G\nf : AddMonoidAlgebra k G\ny : G\n⊢ Eq ((HMul.hMul (AddMonoidAlgebra.single x r) f) y) (HMul.hMul r (f (HAdd.hAdd (Neg.neg x) y)))","decl":"theorem single_mul_apply [AddGroup G] (r : k) (x : G) (f : k[G]) (y : G) :\n    (single x r * f) y = r * f (-x + y) :=\n  @MonoidAlgebra.single_mul_apply k (Multiplicative G) _ _ _ _ _ _\n\n"}
{"name":"AddMonoidAlgebra.liftNC_smul","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝² : Semiring k\nR : Type u_3\ninst✝¹ : AddZeroClass G\ninst✝ : Semiring R\nf : RingHom k R\ng : MonoidHom (Multiplicative G) R\nc : k\nφ : MonoidAlgebra k G\n⊢ Eq ((AddMonoidAlgebra.liftNC ↑f ⇑g) (HSMul.hSMul c φ)) (HMul.hMul (f c) ((AddMonoidAlgebra.liftNC ↑f ⇑g) φ))","decl":"theorem liftNC_smul {R : Type*} [AddZeroClass G] [Semiring R] (f : k →+* R)\n    (g : Multiplicative G →* R) (c : k) (φ : MonoidAlgebra k G) :\n    liftNC (f : k →+ R) g (c • φ) = f c * liftNC (f : k →+ R) g φ :=\n  @MonoidAlgebra.liftNC_smul k (Multiplicative G) _ _ _ _ f g c φ\n\n"}
{"name":"AddMonoidAlgebra.induction_on","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddMonoid G\np : AddMonoidAlgebra k G → Prop\nf : AddMonoidAlgebra k G\nhM : ∀ (g : G), p ((AddMonoidAlgebra.of k G) (Multiplicative.ofAdd g))\nhadd : ∀ (f g : AddMonoidAlgebra k G), p f → p g → p (HAdd.hAdd f g)\nhsmul : ∀ (r : k) (f : AddMonoidAlgebra k G), p f → p (HSMul.hSMul r f)\n⊢ p f","decl":"theorem induction_on [AddMonoid G] {p : k[G] → Prop} (f : k[G])\n    (hM : ∀ g, p (of k G (Multiplicative.ofAdd g)))\n    (hadd : ∀ f g : k[G], p f → p g → p (f + g))\n    (hsmul : ∀ (r : k) (f), p f → p (r • f)) : p f := by\n  refine Finsupp.induction_linear f ?_ (fun f g hf hg => hadd f g hf hg) fun g r => ?_\n  · simpa using hsmul 0 (of k G (Multiplicative.ofAdd 0)) (hM 0)\n  · convert hsmul r (of k G (Multiplicative.ofAdd g)) (hM g)\n    simp\n\n"}
{"name":"AddMonoidAlgebra.mapDomainRingHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"G : Type u₂\nk : Type u_3\ninst✝⁴ : Semiring k\nH : Type u_4\nF : Type u_5\ninst✝³ : AddMonoid G\ninst✝² : AddMonoid H\ninst✝¹ : FunLike F G H\ninst✝ : AddMonoidHomClass F G H\nf : F\na✝ : Finsupp G k\n⊢ Eq ((AddMonoidAlgebra.mapDomainRingHom k f) a✝) ((↑(Finsupp.mapDomain.addMonoidHom ⇑f)).toFun a✝)","decl":"/-- If `f : G → H` is an additive homomorphism between two additive monoids, then\n`Finsupp.mapDomain f` is a ring homomorphism between their add monoid algebras. -/\n@[simps]\ndef mapDomainRingHom (k : Type*) [Semiring k] {H F : Type*} [AddMonoid G] [AddMonoid H]\n    [FunLike F G H] [AddMonoidHomClass F G H] (f : F) : k[G] →+* k[H] :=\n  { (Finsupp.mapDomain.addMonoidHom f : MonoidAlgebra k G →+ MonoidAlgebra k H) with\n    map_one' := mapDomain_one f\n    map_mul' := fun x y => mapDomain_mul f x y }\n\n"}
{"name":"AddMonoidAlgebra.isScalarTower_self","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : Semiring k\ninst✝² : DistribSMul R k\ninst✝¹ : Add G\ninst✝ : IsScalarTower R k k\n⊢ IsScalarTower R (AddMonoidAlgebra k G) (AddMonoidAlgebra k G)","decl":"instance isScalarTower_self [IsScalarTower R k k] :\n    IsScalarTower R k[G] k[G] :=\n  @MonoidAlgebra.isScalarTower_self k (Multiplicative G) R _ _ _ _\n\n"}
{"name":"AddMonoidAlgebra.smulCommClass_self","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : Semiring k\ninst✝² : DistribSMul R k\ninst✝¹ : Add G\ninst✝ : SMulCommClass R k k\n⊢ SMulCommClass R (AddMonoidAlgebra k G) (AddMonoidAlgebra k G)","decl":"/-- Note that if `k` is a `CommSemiring` then we have `SMulCommClass k k k` and so we can take\n`R = k` in the below. In other words, if the coefficients are commutative amongst themselves, they\nalso commute with the algebra multiplication. -/\ninstance smulCommClass_self [SMulCommClass R k k] :\n    SMulCommClass R k[G] k[G] :=\n  @MonoidAlgebra.smulCommClass_self k (Multiplicative G) R _ _ _ _\n\n"}
{"name":"AddMonoidAlgebra.smulCommClass_symm_self","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : Semiring k\ninst✝² : DistribSMul R k\ninst✝¹ : Add G\ninst✝ : SMulCommClass k R k\n⊢ SMulCommClass (AddMonoidAlgebra k G) R (AddMonoidAlgebra k G)","decl":"instance smulCommClass_symm_self [SMulCommClass k R k] :\n    SMulCommClass k[G] R k[G] :=\n  @MonoidAlgebra.smulCommClass_symm_self k (Multiplicative G) R _ _ _ _\n\n"}
{"name":"AddMonoidAlgebra.singleZeroRingHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddMonoid G\nb : k\n⊢ Eq (AddMonoidAlgebra.singleZeroRingHom b) (AddMonoidAlgebra.single 0 b)","decl":"/-- `Finsupp.single 0` as a `RingHom` -/\n@[simps]\ndef singleZeroRingHom [Semiring k] [AddMonoid G] : k →+* k[G] :=\n  { singleAddHom 0 with\n    toFun := single 0\n    map_one' := rfl\n    map_mul' := fun x y => by simp only [Finsupp.singleAddHom, single_mul_single, zero_add] }\n\n"}
{"name":"AddMonoidAlgebra.ringHom_ext","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_3\ninst✝² : Semiring k\ninst✝¹ : AddMonoid G\ninst✝ : Semiring R\nf g : RingHom (AddMonoidAlgebra k G) R\nh₀ : ∀ (b : k), Eq (f (AddMonoidAlgebra.single 0 b)) (g (AddMonoidAlgebra.single 0 b))\nh_of : ∀ (a : G), Eq (f (AddMonoidAlgebra.single a 1)) (g (AddMonoidAlgebra.single a 1))\n⊢ Eq f g","decl":"/-- If two ring homomorphisms from `k[G]` are equal on all `single a 1`\nand `single 0 b`, then they are equal. -/\ntheorem ringHom_ext {R} [Semiring k] [AddMonoid G] [Semiring R] {f g : k[G] →+* R}\n    (h₀ : ∀ b, f (single 0 b) = g (single 0 b)) (h_of : ∀ a, f (single a 1) = g (single a 1)) :\n    f = g :=\n  @MonoidAlgebra.ringHom_ext k (Multiplicative G) R _ _ _ _ _ h₀ h_of\n\n"}
{"name":"AddMonoidAlgebra.ringHom_ext'","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_3\ninst✝² : Semiring k\ninst✝¹ : AddMonoid G\ninst✝ : Semiring R\nf g : RingHom (AddMonoidAlgebra k G) R\nh₁ : Eq (f.comp AddMonoidAlgebra.singleZeroRingHom) (g.comp AddMonoidAlgebra.singleZeroRingHom)\nh_of : Eq ((↑f).comp (AddMonoidAlgebra.of k G)) ((↑g).comp (AddMonoidAlgebra.of k G))\n⊢ Eq f g","decl":"/-- If two ring homomorphisms from `k[G]` are equal on all `single a 1`\nand `single 0 b`, then they are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem ringHom_ext' {R} [Semiring k] [AddMonoid G] [Semiring R] {f g : k[G] →+* R}\n    (h₁ : f.comp singleZeroRingHom = g.comp singleZeroRingHom)\n    (h_of : (f : k[G] →* R).comp (of k G) = (g : k[G] →* R).comp (of k G)) :\n    f = g :=\n  ringHom_ext (RingHom.congr_fun h₁) (DFunLike.congr_fun h_of)\n\n"}
{"name":"AddMonoidAlgebra.ringHom_ext'_iff","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_3\ninst✝² : Semiring k\ninst✝¹ : AddMonoid G\ninst✝ : Semiring R\nf g : RingHom (AddMonoidAlgebra k G) R\n⊢ Iff (Eq f g) (And (Eq (f.comp AddMonoidAlgebra.singleZeroRingHom) (g.comp AddMonoidAlgebra.singleZeroRingHom)) (Eq ((↑f).comp (AddMonoidAlgebra.of k G)) ((↑g).comp (AddMonoidAlgebra.of k G))))","decl":"/-- If two ring homomorphisms from `k[G]` are equal on all `single a 1`\nand `single 0 b`, then they are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem ringHom_ext' {R} [Semiring k] [AddMonoid G] [Semiring R] {f g : k[G] →+* R}\n    (h₁ : f.comp singleZeroRingHom = g.comp singleZeroRingHom)\n    (h_of : (f : k[G] →* R).comp (of k G) = (g : k[G] →* R).comp (of k G)) :\n    f = g :=\n  ringHom_ext (RingHom.congr_fun h₁) (DFunLike.congr_fun h_of)\n\n"}
{"name":"AddMonoidAlgebra.opRingEquiv_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddCommMonoid G\na✝ : MulOpposite (Finsupp G k)\n⊢ Eq (AddMonoidAlgebra.opRingEquiv a✝) (Finsupp.mapRange MulOpposite.op ⋯ (MulOpposite.unop a✝))","decl":"/-- The opposite of an `R[I]` is ring equivalent to\nthe `AddMonoidAlgebra Rᵐᵒᵖ I` over the opposite ring, taking elements to their opposite. -/\n@[simps! (config := { simpRhs := true }) apply symm_apply]\nprotected noncomputable def opRingEquiv [AddCommMonoid G] :\n    k[G]ᵐᵒᵖ ≃+* kᵐᵒᵖ[G] :=\n  { MulOpposite.opAddEquiv.symm.trans\n      (Finsupp.mapRange.addEquiv (MulOpposite.opAddEquiv : k ≃+ kᵐᵒᵖ)) with\n    map_mul' := by\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      rw [Equiv.toFun_as_coe, AddEquiv.toEquiv_eq_coe]; erw [AddEquiv.coe_toEquiv]\n      rw [← AddEquiv.coe_toAddMonoidHom]\n      refine Iff.mpr (AddMonoidHom.map_mul_iff (R := k[G]ᵐᵒᵖ) (S := kᵐᵒᵖ[G]) _) ?_\n      -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): Was `ext`.\n      refine AddMonoidHom.mul_op_ext _ _ <| addHom_ext' fun i₁ => AddMonoidHom.ext fun r₁ =>\n        AddMonoidHom.mul_op_ext _ _ <| addHom_ext' fun i₂ => AddMonoidHom.ext fun r₂ => ?_\n      -- Porting note: `reducible` cannot be `local` so proof gets long.\n      dsimp\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      erw [AddEquiv.trans_apply, AddEquiv.trans_apply, AddEquiv.trans_apply,\n        MulOpposite.opAddEquiv_symm_apply]; rw [MulOpposite.unop_mul (α := k[G])]\n      dsimp\n      rw [mapRange_single, single_mul_single, mapRange_single, mapRange_single]\n      simp only [mapRange_single, single_mul_single, ← op_mul, add_comm] }\n\n-- @[simp] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10618): simp can prove this.\n-- More specifically, the LHS simplifies to `Finsupp.single`, which implies there's some\n-- defeq abuse going on.\n"}
{"name":"AddMonoidAlgebra.opRingEquiv_symm_apply","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddCommMonoid G\na✝ : Finsupp G (MulOpposite k)\n⊢ Eq (AddMonoidAlgebra.opRingEquiv.symm a✝) (MulOpposite.op (Finsupp.mapRange MulOpposite.unop ⋯ a✝))","decl":"/-- The opposite of an `R[I]` is ring equivalent to\nthe `AddMonoidAlgebra Rᵐᵒᵖ I` over the opposite ring, taking elements to their opposite. -/\n@[simps! (config := { simpRhs := true }) apply symm_apply]\nprotected noncomputable def opRingEquiv [AddCommMonoid G] :\n    k[G]ᵐᵒᵖ ≃+* kᵐᵒᵖ[G] :=\n  { MulOpposite.opAddEquiv.symm.trans\n      (Finsupp.mapRange.addEquiv (MulOpposite.opAddEquiv : k ≃+ kᵐᵒᵖ)) with\n    map_mul' := by\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      rw [Equiv.toFun_as_coe, AddEquiv.toEquiv_eq_coe]; erw [AddEquiv.coe_toEquiv]\n      rw [← AddEquiv.coe_toAddMonoidHom]\n      refine Iff.mpr (AddMonoidHom.map_mul_iff (R := k[G]ᵐᵒᵖ) (S := kᵐᵒᵖ[G]) _) ?_\n      -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): Was `ext`.\n      refine AddMonoidHom.mul_op_ext _ _ <| addHom_ext' fun i₁ => AddMonoidHom.ext fun r₁ =>\n        AddMonoidHom.mul_op_ext _ _ <| addHom_ext' fun i₂ => AddMonoidHom.ext fun r₂ => ?_\n      -- Porting note: `reducible` cannot be `local` so proof gets long.\n      dsimp\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      erw [AddEquiv.trans_apply, AddEquiv.trans_apply, AddEquiv.trans_apply,\n        MulOpposite.opAddEquiv_symm_apply]; rw [MulOpposite.unop_mul (α := k[G])]\n      dsimp\n      rw [mapRange_single, single_mul_single, mapRange_single, mapRange_single]\n      simp only [mapRange_single, single_mul_single, ← op_mul, add_comm] }\n\n-- @[simp] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10618): simp can prove this.\n-- More specifically, the LHS simplifies to `Finsupp.single`, which implies there's some\n-- defeq abuse going on.\n"}
{"name":"AddMonoidAlgebra.opRingEquiv_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddCommMonoid G\nr : k\nx : G\n⊢ Eq (AddMonoidAlgebra.opRingEquiv (MulOpposite.op (AddMonoidAlgebra.single x r))) (AddMonoidAlgebra.single x (MulOpposite.op r))","decl":"theorem opRingEquiv_single [AddCommMonoid G] (r : k) (x : G) :\n    AddMonoidAlgebra.opRingEquiv (op (single x r)) = single x (op r) := by simp\n\n"}
{"name":"AddMonoidAlgebra.opRingEquiv_symm_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddCommMonoid G\nr : MulOpposite k\nx : MulOpposite G\n⊢ Eq (AddMonoidAlgebra.opRingEquiv.symm (AddMonoidAlgebra.single x r)) (MulOpposite.op (AddMonoidAlgebra.single x (MulOpposite.unop r)))","decl":"theorem opRingEquiv_symm_single [AddCommMonoid G] (r : kᵐᵒᵖ) (x : Gᵐᵒᵖ) :\n    AddMonoidAlgebra.opRingEquiv.symm (single x r) = op (single x r.unop) := by simp\n\n"}
{"name":"AddMonoidAlgebra.prod_single","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\nι : Type ui\ninst✝¹ : CommSemiring k\ninst✝ : AddCommMonoid G\ns : Finset ι\na : ι → G\nb : ι → k\n⊢ Eq (s.prod fun i => AddMonoidAlgebra.single (a i) (b i)) (AddMonoidAlgebra.single (s.sum fun i => a i) (s.prod fun i => b i))","decl":"theorem prod_single [CommSemiring k] [AddCommMonoid G] {s : Finset ι} {a : ι → G} {b : ι → k} :\n    (∏ i ∈ s, single (a i) (b i)) = single (∑ i ∈ s, a i) (∏ i ∈ s, b i) :=\n  Finset.cons_induction_on s rfl fun a s has ih => by\n    rw [prod_cons has, ih, single_mul_single, sum_cons has, prod_cons has]\n\n"}
{"name":"AddMonoidAlgebra.isLocalHom_singleZeroRingHom","module":"Mathlib.Algebra.MonoidAlgebra.Defs","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : Semiring k\ninst✝ : AddMonoid G\n⊢ IsLocalHom AddMonoidAlgebra.singleZeroRingHom","decl":"instance isLocalHom_singleZeroRingHom [Semiring k] [AddMonoid G] :\n    IsLocalHom (singleZeroRingHom (k := k) (G := G)) :=\n  MonoidAlgebra.isLocalHom_singleOneRingHom (G := Multiplicative G)\n\n"}
