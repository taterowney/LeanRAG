{"name":"Submodule.IsPrimary.ne_top","module":"Mathlib.RingTheory.IsPrimary","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Submodule R M\nh : S.IsPrimary\n⊢ Ne S Top.top","decl":"lemma IsPrimary.ne_top (h : S.IsPrimary) : S ≠ ⊤ := h.left\n\n"}
{"name":"Submodule.isPrimary_iff_zero_divisor_quotient_imp_nilpotent_smul","module":"Mathlib.RingTheory.IsPrimary","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS : Submodule R M\n⊢ Iff S.IsPrimary (And (Ne S Top.top) (∀ (r : R) (x : HasQuotient.Quotient M S), Ne x 0 → Eq (HSMul.hSMul r x) 0 → Exists fun n => Eq (HSMul.hSMul (HPow.hPow r n) Top.top) Bot.bot))","decl":"lemma isPrimary_iff_zero_divisor_quotient_imp_nilpotent_smul :\n    S.IsPrimary ↔ S ≠ ⊤ ∧ ∀ (r : R) (x : M ⧸ S), x ≠ 0 → r • x = 0 →\n      ∃ n : ℕ, r ^ n • (⊤ : Submodule R (M ⧸ S)) = ⊥ := by\n  refine (and_congr_right fun _ ↦ ?_)\n  simp_rw [S.mkQ_surjective.forall, ← map_smul, ne_eq, ← LinearMap.mem_ker, ker_mkQ]\n  congr! 2\n  rw [forall_comm, ← or_iff_not_imp_left,\n    ← LinearMap.range_eq_top.mpr S.mkQ_surjective, ← map_top]\n  simp_rw [eq_bot_iff, ← map_pointwise_smul, map_le_iff_le_comap, comap_bot, ker_mkQ]\n\n"}
