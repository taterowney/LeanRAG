{"name":"Prime.exists_mem_multiset_dvd","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\ninst✝ : CommMonoidWithZero α\np : α\nhp : Prime p\ns : Multiset α\na✝ : Dvd.dvd p s.prod\n⊢ Exists fun a => And (Membership.mem s a) (Dvd.dvd p a)","decl":"theorem exists_mem_multiset_dvd (hp : Prime p) {s : Multiset α} : p ∣ s.prod → ∃ a ∈ s, p ∣ a :=\n  Multiset.induction_on s (fun h => (hp.not_dvd_one h).elim) fun a s ih h =>\n    have : p ∣ a * s.prod := by simpa using h\n    match hp.dvd_or_dvd this with\n    | Or.inl h => ⟨a, Multiset.mem_cons_self a s, h⟩\n    | Or.inr h =>\n      let ⟨a, has, h⟩ := ih h\n      ⟨a, Multiset.mem_cons_of_mem has, h⟩\n\n"}
{"name":"Prime.exists_mem_multiset_map_dvd","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CommMonoidWithZero α\np : α\nhp : Prime p\ns : Multiset β\nf : β → α\na✝ : Dvd.dvd p (Multiset.map f s).prod\n⊢ Exists fun a => And (Membership.mem s a) (Dvd.dvd p (f a))","decl":"theorem exists_mem_multiset_map_dvd (hp : Prime p) {s : Multiset β} {f : β → α} :\n    p ∣ (s.map f).prod → ∃ a ∈ s, p ∣ f a := fun h => by\n  simpa only [exists_prop, Multiset.mem_map, exists_exists_and_eq_and] using\n    hp.exists_mem_multiset_dvd h\n\n"}
{"name":"Prime.exists_mem_finset_dvd","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CommMonoidWithZero α\np : α\nhp : Prime p\ns : Finset β\nf : β → α\na✝ : Dvd.dvd p (s.prod f)\n⊢ Exists fun i => And (Membership.mem s i) (Dvd.dvd p (f i))","decl":"theorem exists_mem_finset_dvd (hp : Prime p) {s : Finset β} {f : β → α} :\n    p ∣ s.prod f → ∃ i ∈ s, p ∣ f i :=\n  hp.exists_mem_multiset_map_dvd\n\n"}
{"name":"Prod.associated_iff","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"M : Type u_5\nN : Type u_6\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nx z : Prod M N\n⊢ Iff (Associated x z) (And (Associated x.1 z.1) (Associated x.2 z.2))","decl":"theorem Prod.associated_iff {M N : Type*} [Monoid M] [Monoid N] {x z : M × N} :\n    x ~ᵤ z ↔ x.1 ~ᵤ z.1 ∧ x.2 ~ᵤ z.2 :=\n  ⟨fun ⟨u, hu⟩ => ⟨⟨(MulEquiv.prodUnits.toFun u).1, (Prod.eq_iff_fst_eq_snd_eq.1 hu).1⟩,\n    ⟨(MulEquiv.prodUnits.toFun u).2, (Prod.eq_iff_fst_eq_snd_eq.1 hu).2⟩⟩,\n  fun ⟨⟨u₁, h₁⟩, ⟨u₂, h₂⟩⟩ =>\n    ⟨MulEquiv.prodUnits.invFun (u₁, u₂), Prod.eq_iff_fst_eq_snd_eq.2 ⟨h₁, h₂⟩⟩⟩\n\n"}
{"name":"Associated.prod","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"M : Type u_5\ninst✝ : CommMonoid M\nι : Type u_6\ns : Finset ι\nf g : ι → M\nh : ∀ (i : ι), Membership.mem s i → Associated (f i) (g i)\n⊢ Associated (s.prod fun i => f i) (s.prod fun i => g i)","decl":"theorem Associated.prod {M : Type*} [CommMonoid M] {ι : Type*} (s : Finset ι) (f : ι → M)\n    (g : ι → M) (h : ∀ i, i ∈ s → (f i) ~ᵤ (g i)) : (∏ i ∈ s, f i) ~ᵤ (∏ i ∈ s, g i) := by\n  induction s using Finset.induction with\n  | empty =>\n    simp only [Finset.prod_empty]\n    rfl\n  | @insert j s hjs IH =>\n    classical\n    convert_to (∏ i ∈ insert j s, f i) ~ᵤ (∏ i ∈ insert j s, g i)\n    rw [Finset.prod_insert hjs, Finset.prod_insert hjs]\n    exact Associated.mul_mul (h j (Finset.mem_insert_self j s))\n      (IH (fun i hi ↦ h i (Finset.mem_insert_of_mem hi)))\n\n"}
{"name":"exists_associated_mem_of_dvd_prod","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\np : α\nhp : Prime p\ns : Multiset α\na✝¹ : ∀ (r : α), Membership.mem s r → Prime r\na✝ : Dvd.dvd p s.prod\n⊢ Exists fun q => And (Membership.mem s q) (Associated p q)","decl":"theorem exists_associated_mem_of_dvd_prod [CancelCommMonoidWithZero α] {p : α} (hp : Prime p)\n    {s : Multiset α} : (∀ r ∈ s, Prime r) → p ∣ s.prod → ∃ q ∈ s, p ~ᵤ q :=\n  Multiset.induction_on s (by simp [mt isUnit_iff_dvd_one.2 hp.not_unit]) fun a s ih hs hps => by\n    rw [Multiset.prod_cons] at hps\n    rcases hp.dvd_or_dvd hps with h | h\n    · have hap := hs a (Multiset.mem_cons.2 (Or.inl rfl))\n      exact ⟨a, Multiset.mem_cons_self a _, hp.associated_of_dvd hap h⟩\n    · rcases ih (fun r hr => hs _ (Multiset.mem_cons.2 (Or.inr hr))) h with ⟨q, hq₁, hq₂⟩\n      exact ⟨q, Multiset.mem_cons.2 (Or.inr hq₁), hq₂⟩\n\n"}
{"name":"divisor_closure_eq_closure","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\nx y : α\nhxy : Membership.mem (Submonoid.closure (setOf fun r => Or (IsUnit r) (Prime r))) (HMul.hMul x y)\n⊢ Membership.mem (Submonoid.closure (setOf fun r => Or (IsUnit r) (Prime r))) x","decl":"open Submonoid in\n/-- Let x, y ∈ α. If x * y can be written as a product of units and prime elements, then x can be\nwritten as a product of units and prime elements. -/\ntheorem divisor_closure_eq_closure [CancelCommMonoidWithZero α]\n    (x y : α) (hxy : x * y ∈ closure { r : α | IsUnit r ∨ Prime r}) :\n    x ∈ closure { r : α | IsUnit r ∨ Prime r} := by\n  obtain ⟨m, hm, hprod⟩ := exists_multiset_of_mem_closure hxy\n  induction m using Multiset.induction generalizing x y with\n  | empty =>\n    apply subset_closure\n    simp only [Set.mem_setOf]\n    simp only [Multiset.prod_zero] at hprod\n    left; exact isUnit_of_mul_eq_one _ _ hprod.symm\n  | @cons c s hind =>\n    simp only [Multiset.mem_cons, forall_eq_or_imp, Set.mem_setOf] at hm\n    simp only [Multiset.prod_cons] at hprod\n    simp only [Set.mem_setOf_eq] at hind\n    obtain ⟨ha₁ | ha₂, hs⟩ := hm\n    · rcases ha₁.exists_right_inv with ⟨k, hk⟩\n      refine hind x (y*k) ?_ hs ?_\n      · simp only [← mul_assoc, ← hprod, ← Multiset.prod_cons, mul_comm]\n        refine multiset_prod_mem _ _ (Multiset.forall_mem_cons.2 ⟨subset_closure (Set.mem_def.2 ?_),\n          Multiset.forall_mem_cons.2 ⟨subset_closure (Set.mem_def.2 ?_), (fun t ht =>\n          subset_closure (hs t ht))⟩⟩)\n        · left; exact isUnit_of_mul_eq_one_right _ _ hk\n        · left; exact ha₁\n      · rw [← mul_one s.prod, ← hk, ← mul_assoc, ← mul_assoc, mul_eq_mul_right_iff, mul_comm]\n        left; exact hprod\n    · rcases ha₂.dvd_mul.1 (Dvd.intro _ hprod) with ⟨c, hc⟩ | ⟨c, hc⟩\n      · rw [hc]; rw [hc, mul_assoc] at hprod\n        refine Submonoid.mul_mem _ (subset_closure (Set.mem_def.2 ?_))\n          (hind _ _ ?_ hs (mul_left_cancel₀ ha₂.ne_zero hprod))\n        · right; exact ha₂\n        rw [← mul_left_cancel₀ ha₂.ne_zero hprod]\n        exact multiset_prod_mem _ _ (fun t ht => subset_closure (hs t ht))\n      rw [hc, mul_comm x _, mul_assoc, mul_comm c _] at hprod\n      refine hind x c ?_ hs (mul_left_cancel₀ ha₂.ne_zero hprod)\n      rw [← mul_left_cancel₀ ha₂.ne_zero hprod]\n      exact multiset_prod_mem _ _ (fun t ht => subset_closure (hs t ht))\n\n"}
{"name":"Multiset.prod_primes_dvd","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : (a : α) → DecidablePred (Associated a)\ns : Multiset α\nn : α\nh : ∀ (a : α), Membership.mem s a → Prime a\ndiv : ∀ (a : α), Membership.mem s a → Dvd.dvd a n\nuniq : ∀ (a : α), LE.le (Multiset.countP (Associated a) s) 1\n⊢ Dvd.dvd s.prod n","decl":"theorem Multiset.prod_primes_dvd [CancelCommMonoidWithZero α]\n    [∀ a : α, DecidablePred (Associated a)] {s : Multiset α} (n : α) (h : ∀ a ∈ s, Prime a)\n    (div : ∀ a ∈ s, a ∣ n) (uniq : ∀ a, s.countP (Associated a) ≤ 1) : s.prod ∣ n := by\n  induction s using Multiset.induction_on generalizing n with\n  | empty => simp only [Multiset.prod_zero, one_dvd]\n  | cons a s induct =>\n    rw [Multiset.prod_cons]\n    obtain ⟨k, rfl⟩ : a ∣ n := div a (Multiset.mem_cons_self a s)\n    apply mul_dvd_mul_left a\n    refine induct _ (fun a ha => h a (Multiset.mem_cons_of_mem ha)) (fun b b_in_s => ?_)\n      fun a => (Multiset.countP_le_of_le _ (Multiset.le_cons_self _ _)).trans (uniq a)\n    have b_div_n := div b (Multiset.mem_cons_of_mem b_in_s)\n    have a_prime := h a (Multiset.mem_cons_self a s)\n    have b_prime := h b (Multiset.mem_cons_of_mem b_in_s)\n    refine (b_prime.dvd_or_dvd b_div_n).resolve_left fun b_div_a => ?_\n    have assoc := b_prime.associated_of_dvd a_prime b_div_a\n    have := uniq a\n    rw [Multiset.countP_cons_of_pos _ (Associated.refl _), Nat.succ_le_succ_iff, ← not_lt,\n      Multiset.countP_pos] at this\n    exact this ⟨b, b_in_s, assoc.symm⟩\n\n"}
{"name":"Finset.prod_primes_dvd","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : Subsingleton (Units α)\ns : Finset α\nn : α\nh : ∀ (a : α), Membership.mem s a → Prime a\ndiv : ∀ (a : α), Membership.mem s a → Dvd.dvd a n\n⊢ Dvd.dvd (s.prod fun p => p) n","decl":"theorem Finset.prod_primes_dvd [CancelCommMonoidWithZero α] [Subsingleton αˣ] {s : Finset α} (n : α)\n    (h : ∀ a ∈ s, Prime a) (div : ∀ a ∈ s, a ∣ n) : (∏ p ∈ s, p) ∣ n := by\n  classical\n    exact\n      Multiset.prod_primes_dvd n (by simpa only [Multiset.map_id', Finset.mem_def] using h)\n        (by simpa only [Multiset.map_id', Finset.mem_def] using div)\n        (by\n          simp only [Multiset.map_id', associated_eq_eq, Multiset.countP_eq_card_filter,\n            ← s.val.count_eq_card_filter_eq, ← Multiset.nodup_iff_count_le_one, s.nodup])\n\n"}
{"name":"Associates.prod_mk","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\np : Multiset α\n⊢ Eq (Multiset.map Associates.mk p).prod (Associates.mk p.prod)","decl":"theorem prod_mk {p : Multiset α} : (p.map Associates.mk).prod = Associates.mk p.prod :=\n  Multiset.induction_on p (by simp) fun a s ih => by simp [ih, Associates.mk_mul_mk]\n\n"}
{"name":"Associates.finset_prod_mk","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CommMonoid α\np : Finset β\nf : β → α\n⊢ Eq (p.prod fun i => Associates.mk (f i)) (Associates.mk (p.prod fun i => f i))","decl":"theorem finset_prod_mk {p : Finset β} {f : β → α} :\n    (∏ i ∈ p, Associates.mk (f i)) = Associates.mk (∏ i ∈ p, f i) := by\n  -- Porting note: added\n  have : (fun i => Associates.mk (f i)) = Associates.mk ∘ f :=\n    funext fun x => Function.comp_apply\n  rw [Finset.prod_eq_multiset_prod, this, ← Multiset.map_map, prod_mk,\n    ← Finset.prod_eq_multiset_prod]\n\n"}
{"name":"Associates.rel_associated_iff_map_eq_map","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\np q : Multiset α\n⊢ Iff (Multiset.Rel Associated p q) (Eq (Multiset.map Associates.mk p) (Multiset.map Associates.mk q))","decl":"theorem rel_associated_iff_map_eq_map {p q : Multiset α} :\n    Multiset.Rel Associated p q ↔ p.map Associates.mk = q.map Associates.mk := by\n  rw [← Multiset.rel_eq, Multiset.rel_map]\n  simp only [mk_eq_mk_iff_associated]\n\n"}
{"name":"Associates.prod_eq_one_iff","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\np : Multiset (Associates α)\n⊢ Iff (Eq p.prod 1) (∀ (a : Associates α), Membership.mem p a → Eq a 1)","decl":"theorem prod_eq_one_iff {p : Multiset (Associates α)} :\n    p.prod = 1 ↔ ∀ a ∈ p, (a : Associates α) = 1 :=\n  Multiset.induction_on p (by simp)\n    (by simp +contextual [mul_eq_one, or_imp, forall_and])\n\n"}
{"name":"Associates.prod_le_prod","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\np q : Multiset (Associates α)\nh : LE.le p q\n⊢ LE.le p.prod q.prod","decl":"theorem prod_le_prod {p q : Multiset (Associates α)} (h : p ≤ q) : p.prod ≤ q.prod := by\n  haveI := Classical.decEq (Associates α)\n  haveI := Classical.decEq α\n  suffices p.prod ≤ (p + (q - p)).prod by rwa [add_tsub_cancel_of_le h] at this\n  suffices p.prod * 1 ≤ p.prod * (q - p).prod by simpa\n  exact mul_mono (le_refl p.prod) one_le\n\n"}
{"name":"Associates.exists_mem_multiset_le_of_prime","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\ns : Multiset (Associates α)\np : Associates α\nhp : Prime p\na✝ : LE.le p s.prod\n⊢ Exists fun a => And (Membership.mem s a) (LE.le p a)","decl":"theorem exists_mem_multiset_le_of_prime {s : Multiset (Associates α)} {p : Associates α}\n    (hp : Prime p) : p ≤ s.prod → ∃ a ∈ s, p ≤ a :=\n  Multiset.induction_on s (fun ⟨_, eq⟩ => (hp.ne_one (mul_eq_one.1 eq.symm).1).elim)\n    fun a s ih h =>\n    have : p ≤ a * s.prod := by simpa using h\n    match Prime.le_or_le hp this with\n    | Or.inl h => ⟨a, Multiset.mem_cons_self a s, h⟩\n    | Or.inr h =>\n      let ⟨a, has, h⟩ := ih h\n      ⟨a, Multiset.mem_cons_of_mem has, h⟩\n\n"}
{"name":"Multiset.prod_ne_zero_of_prime","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : Nontrivial α\ns : Multiset α\nh : ∀ (x : α), Membership.mem s x → Prime x\n⊢ Ne s.prod 0","decl":"theorem prod_ne_zero_of_prime [CancelCommMonoidWithZero α] [Nontrivial α] (s : Multiset α)\n    (h : ∀ x ∈ s, Prime x) : s.prod ≠ 0 :=\n  Multiset.prod_ne_zero fun h0 => Prime.ne_zero (h 0 h0) rfl\n\n"}
{"name":"Prime.dvd_finset_prod_iff","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoidWithZero M\nS : Finset α\np : M\npp : Prime p\ng : α → M\n⊢ Iff (Dvd.dvd p (S.prod g)) (Exists fun a => And (Membership.mem S a) (Dvd.dvd p (g a)))","decl":"theorem Prime.dvd_finset_prod_iff {S : Finset α} {p : M} (pp : Prime p) (g : α → M) :\n    p ∣ S.prod g ↔ ∃ a ∈ S, p ∣ g a :=\n  ⟨pp.exists_mem_finset_dvd, fun ⟨_, ha1, ha2⟩ => dvd_trans ha2 (dvd_prod_of_mem g ha1)⟩\n\n"}
{"name":"Prime.not_dvd_finset_prod","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoidWithZero M\nS : Finset α\np : M\npp : Prime p\ng : α → M\nhS : ∀ (a : α), Membership.mem S a → Not (Dvd.dvd p (g a))\n⊢ Not (Dvd.dvd p (S.prod g))","decl":"theorem Prime.not_dvd_finset_prod {S : Finset α} {p : M} (pp : Prime p) {g : α → M}\n    (hS : ∀ a ∈ S, ¬p ∣ g a) : ¬p ∣ S.prod g := by\n  exact mt (Prime.dvd_finset_prod_iff pp _).1 <| not_exists.2 fun a => not_and.2 (hS a)\n\n"}
{"name":"Prime.dvd_finsupp_prod_iff","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoidWithZero M\nf : Finsupp α M\ng : α → M → Nat\np : Nat\npp : Prime p\n⊢ Iff (Dvd.dvd p (f.prod g)) (Exists fun a => And (Membership.mem f.support a) (Dvd.dvd p (g a (f a))))","decl":"theorem Prime.dvd_finsupp_prod_iff {f : α →₀ M} {g : α → M → ℕ} {p : ℕ} (pp : Prime p) :\n    p ∣ f.prod g ↔ ∃ a ∈ f.support, p ∣ g a (f a) :=\n  Prime.dvd_finset_prod_iff pp _\n\n"}
{"name":"Prime.not_dvd_finsupp_prod","module":"Mathlib.Algebra.BigOperators.Associated","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : CommMonoidWithZero M\nf : Finsupp α M\ng : α → M → Nat\np : Nat\npp : Prime p\nhS : ∀ (a : α), Membership.mem f.support a → Not (Dvd.dvd p (g a (f a)))\n⊢ Not (Dvd.dvd p (f.prod g))","decl":"theorem Prime.not_dvd_finsupp_prod {f : α →₀ M} {g : α → M → ℕ} {p : ℕ} (pp : Prime p)\n    (hS : ∀ a ∈ f.support, ¬p ∣ g a (f a)) : ¬p ∣ f.prod g :=\n  Prime.not_dvd_finset_prod pp hS\n\n"}
