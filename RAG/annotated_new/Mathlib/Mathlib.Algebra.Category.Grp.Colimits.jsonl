{"name":"AddCommGrp.Colimits.Quot.addMonoidHom_ext","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝¹ : DecidableEq J\nα : Type u_1\ninst✝ : AddMonoid α\nf g : AddMonoidHom (AddCommGrp.Colimits.Quot F) α\nh : ∀ (j : J) (x : ↑(F.obj j)), Eq (f ((AddCommGrp.Colimits.Quot.ι F j) x)) (g ((AddCommGrp.Colimits.Quot.ι F j) x))\n⊢ Eq f g","decl":"lemma Quot.addMonoidHom_ext [DecidableEq J] {α : Type*} [AddMonoid α] {f g : Quot F →+ α}\n    (h : ∀ (j : J) (x : F.obj j), f (Quot.ι F j x) = g (Quot.ι F j x)) : f = g :=\n  QuotientAddGroup.addMonoidHom_ext _ (DFinsupp.addHom_ext h)\n\n"}
{"name":"AddCommGrp.Colimits.Quot.ι_desc","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\nc : CategoryTheory.Limits.Cocone F\ninst✝ : DecidableEq J\nj : J\nx : ↑(F.obj j)\n⊢ Eq ((AddCommGrp.Colimits.Quot.desc F c) ((AddCommGrp.Colimits.Quot.ι F j) x)) ((CategoryTheory.ConcreteCategory.hom (c.ι.app j)) x)","decl":"@[simp]\nlemma Quot.ι_desc [DecidableEq J] (j : J) (x : F.obj j) :\n    Quot.desc F c (Quot.ι F j x) = c.ι.app j x := by\n  dsimp [desc, ι]\n  erw [QuotientAddGroup.lift_mk']\n  simp\n\n"}
{"name":"AddCommGrp.Colimits.Quot.map_ι","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝ : DecidableEq J\nj j' : J\nf : Quiver.Hom j j'\nx : ↑(F.obj j)\n⊢ Eq ((AddCommGrp.Colimits.Quot.ι F j') ((CategoryTheory.ConcreteCategory.hom (F.map f)) x)) ((AddCommGrp.Colimits.Quot.ι F j) x)","decl":"@[simp]\nlemma Quot.map_ι [DecidableEq J] {j j' : J} {f : j ⟶ j'} (x : F.obj j) :\n    Quot.ι F j' (F.map f x) = Quot.ι F j x := by\n  dsimp [ι]\n  refine eq_of_sub_eq_zero ?_\n  erw [← (QuotientAddGroup.mk' (Relations F)).map_sub, ← AddMonoidHom.mem_ker]\n  rw [QuotientAddGroup.ker_mk']\n  simp only [DFinsupp.singleAddHom_apply]\n  exact AddSubgroup.subset_closure ⟨j, j', f, x, rfl⟩\n\n"}
{"name":"AddCommGrp.Colimits.quotToQuotUlift_ι","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝ : DecidableEq J\nj : J\nx : ↑(F.obj j)\n⊢ Eq ((AddCommGrp.Colimits.quotToQuotUlift F) ((AddCommGrp.Colimits.Quot.ι F j) x)) ((AddCommGrp.Colimits.Quot.ι (F.comp AddCommGrp.uliftFunctor) j) { down := x })","decl":"lemma quotToQuotUlift_ι [DecidableEq J] (j : J) (x : F.obj j) :\n    quotToQuotUlift F (Quot.ι F j x) = Quot.ι _ j (ULift.up x) := by\n  dsimp [quotToQuotUlift, Quot.ι]\n  conv_lhs => erw [AddMonoidHom.comp_apply (QuotientAddGroup.mk' (Relations F))\n    (DFinsupp.singleAddHom _ j), QuotientAddGroup.lift_mk']\n  simp only [DFinsupp.singleAddHom_apply, DFinsupp.sumAddHom_single, AddMonoidHom.coe_comp,\n    AddMonoidHom.coe_coe, Function.comp_apply]\n  rfl\n\n"}
{"name":"AddCommGrp.Colimits.quotUliftToQuot_ι","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝ : DecidableEq J\nj : J\nx : ↑((F.comp AddCommGrp.uliftFunctor).obj j)\n⊢ Eq ((AddCommGrp.Colimits.quotUliftToQuot F) ((AddCommGrp.Colimits.Quot.ι (F.comp AddCommGrp.uliftFunctor) j) x)) ((AddCommGrp.Colimits.Quot.ι F j) x.down)","decl":"lemma quotUliftToQuot_ι [DecidableEq J] (j : J) (x : (F ⋙ uliftFunctor.{u'}).obj j) :\n    quotUliftToQuot F (Quot.ι _ j x) = Quot.ι F j x.down := by\n  dsimp [quotUliftToQuot, Quot.ι]\n  conv_lhs => erw [AddMonoidHom.comp_apply (QuotientAddGroup.mk' (Relations (F ⋙ uliftFunctor)))\n    (DFinsupp.singleAddHom _ j), QuotientAddGroup.lift_mk']\n  simp only [Functor.comp_obj, uliftFunctor_obj, DFinsupp.singleAddHom_apply,\n    DFinsupp.sumAddHom_single, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply]\n  rfl\n\n"}
{"name":"AddCommGrp.Colimits.Quot.desc_quotQuotUliftAddEquiv","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝ : DecidableEq J\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq ((AddCommGrp.Colimits.Quot.desc (F.comp AddCommGrp.uliftFunctor) (AddCommGrp.uliftFunctor.mapCocone c)).comp (AddCommGrp.Colimits.quotQuotUliftAddEquiv F).toAddMonoidHom) (AddEquiv.ulift.symm.toAddMonoidHom.comp (AddCommGrp.Colimits.Quot.desc F c))","decl":"lemma Quot.desc_quotQuotUliftAddEquiv [DecidableEq J] (c : Cocone F) :\n    (Quot.desc (F ⋙ uliftFunctor.{u'}) (uliftFunctor.{u'}.mapCocone c)).comp\n    (quotQuotUliftAddEquiv F).toAddMonoidHom =\n    AddEquiv.ulift.symm.toAddMonoidHom.comp (Quot.desc F c) := by\n  refine Quot.addMonoidHom_ext _ (fun j a ↦ ?_)\n  dsimp\n  simp only [quotToQuotUlift_ι, Functor.comp_obj, uliftFunctor_obj, ι_desc,\n    Functor.const_obj_obj, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, ι_desc]\n  erw [Quot.ι_desc]\n  rfl\n\n"}
{"name":"AddCommGrp.Colimits.toCocone_pt_coe","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝¹ : DecidableEq J\nA : Type w\ninst✝ : AddCommGroup A\nf : AddMonoidHom (AddCommGrp.Colimits.Quot F) A\n⊢ Eq (↑(AddCommGrp.Colimits.toCocone F f).pt) A","decl":"/-- (implementation detail) A morphism of commutative additive groups `Quot F →+ A`\ninduces a cocone on `F` as long as the universes work out.\n-/\n@[simps]\ndef toCocone [DecidableEq J] {A : Type w} [AddCommGroup A] (f : Quot F →+ A) : Cocone F where\n  pt := AddCommGrp.of A\n  ι.app j := ofHom <| f.comp (Quot.ι F j)\n\n"}
{"name":"AddCommGrp.Colimits.toCocone_ι_app","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝¹ : DecidableEq J\nA : Type w\ninst✝ : AddCommGroup A\nf : AddMonoidHom (AddCommGrp.Colimits.Quot F) A\nj : J\n⊢ Eq ((AddCommGrp.Colimits.toCocone F f).ι.app j) (AddCommGrp.ofHom (f.comp (AddCommGrp.Colimits.Quot.ι F j)))","decl":"/-- (implementation detail) A morphism of commutative additive groups `Quot F →+ A`\ninduces a cocone on `F` as long as the universes work out.\n-/\n@[simps]\ndef toCocone [DecidableEq J] {A : Type w} [AddCommGroup A] (f : Quot F →+ A) : Cocone F where\n  pt := AddCommGrp.of A\n  ι.app j := ofHom <| f.comp (Quot.ι F j)\n\n"}
{"name":"AddCommGrp.Colimits.Quot.desc_toCocone_desc","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\nc : CategoryTheory.Limits.Cocone F\ninst✝¹ : DecidableEq J\nA : Type w\ninst✝ : AddCommGroup A\nf : AddMonoidHom (AddCommGrp.Colimits.Quot F) A\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq ((AddCommGrp.Hom.hom (hc.desc (AddCommGrp.Colimits.toCocone F f))).comp (AddCommGrp.Colimits.Quot.desc F c)) f","decl":"lemma Quot.desc_toCocone_desc [DecidableEq J] {A : Type w} [AddCommGroup A] (f : Quot F →+ A)\n    (hc : IsColimit c) : (hc.desc (toCocone F f)).hom.comp (Quot.desc F c) = f := by\n  refine Quot.addMonoidHom_ext F (fun j x ↦ ?_)\n  rw [AddMonoidHom.comp_apply, ι_desc]\n  change (c.ι.app j ≫ hc.desc (toCocone F f)) _ = _\n  rw [hc.fac]\n  simp\n\n"}
{"name":"AddCommGrp.Colimits.Quot.desc_toCocone_desc_app","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\nc : CategoryTheory.Limits.Cocone F\ninst✝¹ : DecidableEq J\nA : Type w\ninst✝ : AddCommGroup A\nf : AddMonoidHom (AddCommGrp.Colimits.Quot F) A\nhc : CategoryTheory.Limits.IsColimit c\nx : AddCommGrp.Colimits.Quot F\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (hc.desc (AddCommGrp.Colimits.toCocone F f))) ((AddCommGrp.Colimits.Quot.desc F c) x)) (f x)","decl":"lemma Quot.desc_toCocone_desc_app [DecidableEq J] {A : Type w} [AddCommGroup A] (f : Quot F →+ A)\n    (hc : IsColimit c) (x : Quot F) : hc.desc (toCocone F f) (Quot.desc F c x) = f x := by\n  conv_rhs => rw [← Quot.desc_toCocone_desc F c f hc]\n  dsimp\n\n"}
{"name":"AddCommGrp.Colimits.colimitCocone_pt","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝¹ : DecidableEq J\ninst✝ : Small.{w, max w u} (AddCommGrp.Colimits.Quot F)\n⊢ Eq (AddCommGrp.Colimits.colimitCocone F).pt (AddCommGrp.of (Shrink.{w, max u w} (AddCommGrp.Colimits.Quot F)))","decl":"/-- (internal implementation) The colimit cocone of a functor `F`, implemented as a quotient of\n`DFinsupp (fun j ↦ F.obj j)`, under the assumption that said quotient is small.\n-/\n@[simps pt ι_app]\nnoncomputable def colimitCocone [DecidableEq J] [Small.{w} (Quot.{w} F)] : Cocone F where\n  pt := AddCommGrp.of (Shrink (Quot F))\n  ι :=\n    { app j :=\n        AddCommGrp.ofHom (Shrink.addEquiv.symm.toAddMonoidHom.comp (Quot.ι F j))\n      naturality _ _ _ := by\n        ext\n        dsimp\n        change Shrink.addEquiv.symm _ = _\n        rw [Quot.map_ι] }\n\n"}
{"name":"AddCommGrp.Colimits.colimitCocone_ι_app","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝¹ : DecidableEq J\ninst✝ : Small.{w, max w u} (AddCommGrp.Colimits.Quot F)\nj : J\n⊢ Eq ((AddCommGrp.Colimits.colimitCocone F).ι.app j) (AddCommGrp.ofHom (Shrink.addEquiv.symm.toAddMonoidHom.comp (AddCommGrp.Colimits.Quot.ι F j)))","decl":"/-- (internal implementation) The colimit cocone of a functor `F`, implemented as a quotient of\n`DFinsupp (fun j ↦ F.obj j)`, under the assumption that said quotient is small.\n-/\n@[simps pt ι_app]\nnoncomputable def colimitCocone [DecidableEq J] [Small.{w} (Quot.{w} F)] : Cocone F where\n  pt := AddCommGrp.of (Shrink (Quot F))\n  ι :=\n    { app j :=\n        AddCommGrp.ofHom (Shrink.addEquiv.symm.toAddMonoidHom.comp (Quot.ι F j))\n      naturality _ _ _ := by\n        ext\n        dsimp\n        change Shrink.addEquiv.symm _ = _\n        rw [Quot.map_ι] }\n\n"}
{"name":"AddCommGrp.Colimits.Quot.desc_colimitCocone","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\ninst✝¹ : DecidableEq J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝ : Small.{w, max u w} (AddCommGrp.Colimits.Quot F)\n⊢ Eq (AddCommGrp.Colimits.Quot.desc F (AddCommGrp.Colimits.colimitCocone F)) Shrink.addEquiv.symm.toAddMonoidHom","decl":"@[simp]\ntheorem Quot.desc_colimitCocone [DecidableEq J] (F : J ⥤ AddCommGrp.{w}) [Small.{w} (Quot F)] :\n    Quot.desc F (colimitCocone F) = (Shrink.addEquiv (α := Quot F)).symm.toAddMonoidHom := by\n  refine Quot.addMonoidHom_ext F (fun j x ↦ ?_)\n  simp only [colimitCocone_pt, AddEquiv.toAddMonoidHom_eq_coe, AddMonoidHom.coe_coe]\n  erw [Quot.ι_desc]\n  simp\n\n"}
{"name":"AddCommGrp.hasColimit_of_small_quot","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝ : DecidableEq J\nh : Small.{w, max u w} (AddCommGrp.Colimits.Quot F)\n⊢ CategoryTheory.Limits.HasColimit F","decl":"lemma hasColimit_of_small_quot [DecidableEq J] (h : Small.{w} (Quot F)) : HasColimit F :=\n  ⟨_, colimitCoconeIsColimit F⟩\n\n"}
{"name":"AddCommGrp.instSmallQuot","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝¹ : DecidableEq J\ninst✝ : Small.{w, u} J\n⊢ Small.{w, max u w} (AddCommGrp.Colimits.Quot F)","decl":"instance [DecidableEq J] [Small.{w} J] : Small.{w} (Quot F) :=\n  small_of_surjective (QuotientAddGroup.mk'_surjective _)\n\n"}
{"name":"AddCommGrp.hasColimit","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : Small.{w, u} J\nF : CategoryTheory.Functor J AddCommGrp\n⊢ CategoryTheory.Limits.HasColimit F","decl":"instance hasColimit [Small.{w} J] (F : J ⥤ AddCommGrp.{w}) : HasColimit F := by\n  classical\n  exact hasColimit_of_small_quot F inferInstance\n\n\n"}
{"name":"AddCommGrp.hasColimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : Small.{w, u} J\n⊢ CategoryTheory.Limits.HasColimitsOfShape J AddCommGrp","decl":"/--\nIf `J` is `w`-small, then any functor `J ⥤ AddCommGrp.{w}` has a colimit.\n-/\ninstance hasColimitsOfShape [Small.{w} J] : HasColimitsOfShape J (AddCommGrp.{w}) where\n\n"}
{"name":"AddCommGrp.hasColimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Colimits","initialProofState":"inst✝ : UnivLE.{u, w}\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{v, u, w, w + 1} AddCommGrp","decl":"/-- The category of additive commutative groups has all small colimits.\n-/\ninstance (priority := 1300) hasColimitsOfSize [UnivLE.{u, w}] :\n    HasColimitsOfSize.{v, u} (AddCommGrp.{w}) where\n\n"}
