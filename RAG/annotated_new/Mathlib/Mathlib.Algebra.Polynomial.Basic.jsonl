{"name":"Polynomial.ofFinsupp.injEq","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ntoFinsupp✝ toFinsupp : AddMonoidAlgebra R Nat\n⊢ Eq (Eq { toFinsupp := toFinsupp✝ } { toFinsupp := toFinsupp }) (Eq toFinsupp✝ toFinsupp)","decl":"/-- `Polynomial R` is the type of univariate polynomials over `R`,\ndenoted as `R[X]` within the `Polynomial` namespace.\n\nPolynomials should be seen as (semi-)rings with the additional constructor `X`.\nThe embedding from `R` is called `C`. -/\nstructure Polynomial (R : Type*) [Semiring R] where ofFinsupp ::\n  toFinsupp : AddMonoidAlgebra R ℕ\n\n"}
{"name":"Polynomial.ofFinsupp.sizeOf_spec","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : SizeOf R\ntoFinsupp : AddMonoidAlgebra R Nat\n⊢ Eq (SizeOf.sizeOf { toFinsupp := toFinsupp }) (HAdd.hAdd 1 (SizeOf.sizeOf toFinsupp))","decl":"/-- `Polynomial R` is the type of univariate polynomials over `R`,\ndenoted as `R[X]` within the `Polynomial` namespace.\n\nPolynomials should be seen as (semi-)rings with the additional constructor `X`.\nThe embedding from `R` is called `C`. -/\nstructure Polynomial (R : Type*) [Semiring R] where ofFinsupp ::\n  toFinsupp : AddMonoidAlgebra R ℕ\n\n"}
{"name":"Polynomial.ofFinsupp.inj","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ntoFinsupp✝ toFinsupp : AddMonoidAlgebra R Nat\nx✝ : Eq { toFinsupp := toFinsupp✝ } { toFinsupp := toFinsupp }\n⊢ Eq toFinsupp✝ toFinsupp","decl":"/-- `Polynomial R` is the type of univariate polynomials over `R`,\ndenoted as `R[X]` within the `Polynomial` namespace.\n\nPolynomials should be seen as (semi-)rings with the additional constructor `X`.\nThe embedding from `R` is called `C`. -/\nstructure Polynomial (R : Type*) [Semiring R] where ofFinsupp ::\n  toFinsupp : AddMonoidAlgebra R ℕ\n\n"}
{"name":"Polynomial.forall_iff_forall_finsupp","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nP : Polynomial R → Prop\n⊢ Iff (∀ (p : Polynomial R), P p) (∀ (q : AddMonoidAlgebra R Nat), P { toFinsupp := q })","decl":"theorem forall_iff_forall_finsupp (P : R[X] → Prop) :\n    (∀ p, P p) ↔ ∀ q : R[ℕ], P ⟨q⟩ :=\n  ⟨fun h q => h ⟨q⟩, fun h ⟨p⟩ => h p⟩\n\n"}
{"name":"Polynomial.exists_iff_exists_finsupp","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nP : Polynomial R → Prop\n⊢ Iff (Exists fun p => P p) (Exists fun q => P { toFinsupp := q })","decl":"theorem exists_iff_exists_finsupp (P : R[X] → Prop) :\n    (∃ p, P p) ↔ ∃ q : R[ℕ], P ⟨q⟩ :=\n  ⟨fun ⟨⟨p⟩, hp⟩ => ⟨p, hp⟩, fun ⟨q, hq⟩ => ⟨⟨q⟩, hq⟩⟩\n\n"}
{"name":"Polynomial.eta","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nf : Polynomial R\n⊢ Eq { toFinsupp := f.toFinsupp } f","decl":"@[simp]\ntheorem eta (f : R[X]) : Polynomial.ofFinsupp f.toFinsupp = f := by cases f; rfl\n\n"}
{"name":"Polynomial.add_eq_add","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\n⊢ Eq (Polynomial.add p q) (HAdd.hAdd p q)","decl":"@[simp] theorem add_eq_add : add p q = p + q := rfl\n"}
{"name":"Polynomial.mul_eq_mul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\n⊢ Eq (Polynomial.mul p q) (HMul.hMul p q)","decl":"@[simp] theorem mul_eq_mul : mul p q = p * q := rfl\n\n"}
{"name":"Polynomial.instNoZeroSMulDivisors","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝³ : Semiring R\nS : Type u_1\ninst✝² : Zero S\ninst✝¹ : SMulZeroClass S R\ninst✝ : NoZeroSMulDivisors S R\n⊢ NoZeroSMulDivisors S (Polynomial R)","decl":"instance {S : Type*} [Zero S] [SMulZeroClass S R] [NoZeroSMulDivisors S R] :\n    NoZeroSMulDivisors S R[X] where\n  eq_zero_or_eq_zero_of_smul_eq_zero eq :=\n    (eq_zero_or_eq_zero_of_smul_eq_zero <| congr_arg toFinsupp eq).imp id (congr_arg ofFinsupp)\n\n-- to avoid a bug in the `ring` tactic\n"}
{"name":"Polynomial.ofFinsupp_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq { toFinsupp := 0 } 0","decl":"@[simp]\ntheorem ofFinsupp_zero : (⟨0⟩ : R[X]) = 0 :=\n  rfl\n\n"}
{"name":"Polynomial.ofFinsupp_one","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq { toFinsupp := 1 } 1","decl":"@[simp]\ntheorem ofFinsupp_one : (⟨1⟩ : R[X]) = 1 :=\n  rfl\n\n"}
{"name":"Polynomial.ofFinsupp_add","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na b : AddMonoidAlgebra R Nat\n⊢ Eq { toFinsupp := HAdd.hAdd a b } (HAdd.hAdd { toFinsupp := a } { toFinsupp := b })","decl":"@[simp]\ntheorem ofFinsupp_add {a b} : (⟨a + b⟩ : R[X]) = ⟨a⟩ + ⟨b⟩ :=\n  show _ = add _ _ by rw [add_def]\n\n"}
{"name":"Polynomial.ofFinsupp_neg","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\na : AddMonoidAlgebra R Nat\n⊢ Eq { toFinsupp := Neg.neg a } (Neg.neg { toFinsupp := a })","decl":"@[simp]\ntheorem ofFinsupp_neg {R : Type u} [Ring R] {a} : (⟨-a⟩ : R[X]) = -⟨a⟩ :=\n  show _ = neg _ by rw [neg_def]\n\n"}
{"name":"Polynomial.ofFinsupp_sub","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\na b : AddMonoidAlgebra R Nat\n⊢ Eq { toFinsupp := HSub.hSub a b } (HSub.hSub { toFinsupp := a } { toFinsupp := b })","decl":"@[simp]\ntheorem ofFinsupp_sub {R : Type u} [Ring R] {a b} : (⟨a - b⟩ : R[X]) = ⟨a⟩ - ⟨b⟩ := by\n  rw [sub_eq_add_neg, ofFinsupp_add, ofFinsupp_neg]\n  rfl\n\n"}
{"name":"Polynomial.ofFinsupp_mul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na b : AddMonoidAlgebra R Nat\n⊢ Eq { toFinsupp := HMul.hMul a b } (HMul.hMul { toFinsupp := a } { toFinsupp := b })","decl":"@[simp]\ntheorem ofFinsupp_mul (a b) : (⟨a * b⟩ : R[X]) = ⟨a⟩ * ⟨b⟩ :=\n  show _ = mul _ _ by rw [mul_def]\n\n"}
{"name":"Polynomial.ofFinsupp_nsmul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : Nat\nb : AddMonoidAlgebra R Nat\n⊢ Eq { toFinsupp := HSMul.hSMul a b } (HSMul.hSMul a { toFinsupp := b })","decl":"@[simp]\ntheorem ofFinsupp_nsmul (a : ℕ) (b) :\n    (⟨a • b⟩ : R[X]) = (a • ⟨b⟩ : R[X]) :=\n  rfl\n\n"}
{"name":"Polynomial.ofFinsupp_smul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type u_1\ninst✝ : SMulZeroClass S R\na : S\nb : AddMonoidAlgebra R Nat\n⊢ Eq { toFinsupp := HSMul.hSMul a b } (HSMul.hSMul a { toFinsupp := b })","decl":"@[simp]\ntheorem ofFinsupp_smul {S : Type*} [SMulZeroClass S R] (a : S) (b) :\n    (⟨a • b⟩ : R[X]) = (a • ⟨b⟩ : R[X]) :=\n  rfl\n\n"}
{"name":"Polynomial.ofFinsupp_pow","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : AddMonoidAlgebra R Nat\nn : Nat\n⊢ Eq { toFinsupp := HPow.hPow a n } (HPow.hPow { toFinsupp := a } n)","decl":"@[simp]\ntheorem ofFinsupp_pow (a) (n : ℕ) : (⟨a ^ n⟩ : R[X]) = ⟨a⟩ ^ n := by\n  change _ = npowRec n _\n  induction n with\n  | zero        => simp [npowRec]\n  | succ n n_ih => simp [npowRec, n_ih, pow_succ]\n\n"}
{"name":"Polynomial.toFinsupp_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.toFinsupp 0) 0","decl":"@[simp]\ntheorem toFinsupp_zero : (0 : R[X]).toFinsupp = 0 :=\n  rfl\n\n"}
{"name":"Polynomial.toFinsupp_one","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.toFinsupp 1) 1","decl":"@[simp]\ntheorem toFinsupp_one : (1 : R[X]).toFinsupp = 1 :=\n  rfl\n\n"}
{"name":"Polynomial.toFinsupp_add","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na b : Polynomial R\n⊢ Eq (HAdd.hAdd a b).toFinsupp (HAdd.hAdd a.toFinsupp b.toFinsupp)","decl":"@[simp]\ntheorem toFinsupp_add (a b : R[X]) : (a + b).toFinsupp = a.toFinsupp + b.toFinsupp := by\n  cases a\n  cases b\n  rw [← ofFinsupp_add]\n\n"}
{"name":"Polynomial.toFinsupp_neg","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\na : Polynomial R\n⊢ Eq (Neg.neg a).toFinsupp (Neg.neg a.toFinsupp)","decl":"@[simp]\ntheorem toFinsupp_neg {R : Type u} [Ring R] (a : R[X]) : (-a).toFinsupp = -a.toFinsupp := by\n  cases a\n  rw [← ofFinsupp_neg]\n\n"}
{"name":"Polynomial.toFinsupp_sub","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\na b : Polynomial R\n⊢ Eq (HSub.hSub a b).toFinsupp (HSub.hSub a.toFinsupp b.toFinsupp)","decl":"@[simp]\ntheorem toFinsupp_sub {R : Type u} [Ring R] (a b : R[X]) :\n    (a - b).toFinsupp = a.toFinsupp - b.toFinsupp := by\n  rw [sub_eq_add_neg, ← toFinsupp_neg, ← toFinsupp_add]\n  rfl\n\n"}
{"name":"Polynomial.toFinsupp_mul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na b : Polynomial R\n⊢ Eq (HMul.hMul a b).toFinsupp (HMul.hMul a.toFinsupp b.toFinsupp)","decl":"@[simp]\ntheorem toFinsupp_mul (a b : R[X]) : (a * b).toFinsupp = a.toFinsupp * b.toFinsupp := by\n  cases a\n  cases b\n  rw [← ofFinsupp_mul]\n\n"}
{"name":"Polynomial.toFinsupp_nsmul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : Nat\nb : Polynomial R\n⊢ Eq (HSMul.hSMul a b).toFinsupp (HSMul.hSMul a b.toFinsupp)","decl":"@[simp]\ntheorem toFinsupp_nsmul (a : ℕ) (b : R[X]) :\n    (a • b).toFinsupp = a • b.toFinsupp :=\n  rfl\n\n"}
{"name":"Polynomial.toFinsupp_smul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type u_1\ninst✝ : SMulZeroClass S R\na : S\nb : Polynomial R\n⊢ Eq (HSMul.hSMul a b).toFinsupp (HSMul.hSMul a b.toFinsupp)","decl":"@[simp]\ntheorem toFinsupp_smul {S : Type*} [SMulZeroClass S R] (a : S) (b : R[X]) :\n    (a • b).toFinsupp = a • b.toFinsupp :=\n  rfl\n\n"}
{"name":"Polynomial.toFinsupp_pow","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : Polynomial R\nn : Nat\n⊢ Eq (HPow.hPow a n).toFinsupp (HPow.hPow a.toFinsupp n)","decl":"@[simp]\ntheorem toFinsupp_pow (a : R[X]) (n : ℕ) : (a ^ n).toFinsupp = a.toFinsupp ^ n := by\n  cases a\n  rw [← ofFinsupp_pow]\n\n"}
{"name":"IsSMulRegular.polynomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝² : Semiring R\nS : Type u_1\ninst✝¹ : Monoid S\ninst✝ : DistribMulAction S R\na : S\nha : IsSMulRegular R a\n⊢ IsSMulRegular (Polynomial R) a","decl":"theorem _root_.IsSMulRegular.polynomial {S : Type*} [Monoid S] [DistribMulAction S R] {a : S}\n    (ha : IsSMulRegular R a) : IsSMulRegular R[X] a\n  | ⟨_x⟩, ⟨_y⟩, h => congr_arg _ <| ha.finsupp (Polynomial.ofFinsupp.inj h)\n\n"}
{"name":"Polynomial.toFinsupp_injective","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Function.Injective Polynomial.toFinsupp","decl":"theorem toFinsupp_injective : Function.Injective (toFinsupp : R[X] → AddMonoidAlgebra _ _) :=\n  fun ⟨_x⟩ ⟨_y⟩ => congr_arg _\n\n"}
{"name":"Polynomial.toFinsupp_inj","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na b : Polynomial R\n⊢ Iff (Eq a.toFinsupp b.toFinsupp) (Eq a b)","decl":"@[simp]\ntheorem toFinsupp_inj {a b : R[X]} : a.toFinsupp = b.toFinsupp ↔ a = b :=\n  toFinsupp_injective.eq_iff\n\n"}
{"name":"Polynomial.toFinsupp_eq_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : Polynomial R\n⊢ Iff (Eq a.toFinsupp 0) (Eq a 0)","decl":"@[simp]\ntheorem toFinsupp_eq_zero {a : R[X]} : a.toFinsupp = 0 ↔ a = 0 := by\n  rw [← toFinsupp_zero, toFinsupp_inj]\n\n"}
{"name":"Polynomial.toFinsupp_eq_one","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : Polynomial R\n⊢ Iff (Eq a.toFinsupp 1) (Eq a 1)","decl":"@[simp]\ntheorem toFinsupp_eq_one {a : R[X]} : a.toFinsupp = 1 ↔ a = 1 := by\n  rw [← toFinsupp_one, toFinsupp_inj]\n\n"}
{"name":"Polynomial.ofFinsupp_inj","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na b : AddMonoidAlgebra R Nat\n⊢ Iff (Eq { toFinsupp := a } { toFinsupp := b }) (Eq a b)","decl":"/-- A more convenient spelling of `Polynomial.ofFinsupp.injEq` in terms of `Iff`. -/\ntheorem ofFinsupp_inj {a b} : (⟨a⟩ : R[X]) = ⟨b⟩ ↔ a = b :=\n  iff_of_eq (ofFinsupp.injEq _ _)\n\n"}
{"name":"Polynomial.ofFinsupp_eq_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : AddMonoidAlgebra R Nat\n⊢ Iff (Eq { toFinsupp := a } 0) (Eq a 0)","decl":"@[simp]\ntheorem ofFinsupp_eq_zero {a} : (⟨a⟩ : R[X]) = 0 ↔ a = 0 := by\n  rw [← ofFinsupp_zero, ofFinsupp_inj]\n\n"}
{"name":"Polynomial.ofFinsupp_eq_one","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : AddMonoidAlgebra R Nat\n⊢ Iff (Eq { toFinsupp := a } 1) (Eq a 1)","decl":"@[simp]\ntheorem ofFinsupp_eq_one {a} : (⟨a⟩ : R[X]) = 1 ↔ a = 1 := by rw [← ofFinsupp_one, ofFinsupp_inj]\n\n"}
{"name":"Polynomial.faithfulSMul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝² : Semiring R\nS : Type u_1\ninst✝¹ : SMulZeroClass S R\ninst✝ : FaithfulSMul S R\n⊢ FaithfulSMul S (Polynomial R)","decl":"instance faithfulSMul {S} [SMulZeroClass S R] [FaithfulSMul S R] : FaithfulSMul S R[X] where\n  eq_of_smul_eq_smul {_s₁ _s₂} h :=\n    eq_of_smul_eq_smul fun a : ℕ →₀ R => congr_arg toFinsupp (h ⟨a⟩)\n\n"}
{"name":"Polynomial.smulCommClass","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝³ : Semiring R\nS₁ : Type u_1\nS₂ : Type u_2\ninst✝² : SMulZeroClass S₁ R\ninst✝¹ : SMulZeroClass S₂ R\ninst✝ : SMulCommClass S₁ S₂ R\n⊢ SMulCommClass S₁ S₂ (Polynomial R)","decl":"instance smulCommClass {S₁ S₂} [SMulZeroClass S₁ R] [SMulZeroClass S₂ R] [SMulCommClass S₁ S₂ R] :\n  SMulCommClass S₁ S₂ R[X] :=\n  ⟨by\n    rintro m n ⟨f⟩\n    simp_rw [← ofFinsupp_smul, smul_comm m n f]⟩\n\n"}
{"name":"Polynomial.isScalarTower","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝⁴ : Semiring R\nS₁ : Type u_1\nS₂ : Type u_2\ninst✝³ : SMul S₁ S₂\ninst✝² : SMulZeroClass S₁ R\ninst✝¹ : SMulZeroClass S₂ R\ninst✝ : IsScalarTower S₁ S₂ R\n⊢ IsScalarTower S₁ S₂ (Polynomial R)","decl":"instance isScalarTower {S₁ S₂} [SMul S₁ S₂] [SMulZeroClass S₁ R] [SMulZeroClass S₂ R]\n  [IsScalarTower S₁ S₂ R] : IsScalarTower S₁ S₂ R[X] :=\n  ⟨by\n    rintro _ _ ⟨⟩\n    simp_rw [← ofFinsupp_smul, smul_assoc]⟩\n\n"}
{"name":"Polynomial.isScalarTower_right","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"α : Type u_1\nK : Type u_2\ninst✝² : Semiring K\ninst✝¹ : DistribSMul α K\ninst✝ : IsScalarTower α K K\n⊢ IsScalarTower α (Polynomial K) (Polynomial K)","decl":"instance isScalarTower_right {α K : Type*} [Semiring K] [DistribSMul α K] [IsScalarTower α K K] :\n    IsScalarTower α K[X] K[X] :=\n  ⟨by\n    rintro _ ⟨⟩ ⟨⟩\n    simp_rw [smul_eq_mul, ← ofFinsupp_smul, ← ofFinsupp_mul, ← ofFinsupp_smul, smul_mul_assoc]⟩\n\n"}
{"name":"Polynomial.isCentralScalar","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝³ : Semiring R\nS : Type u_1\ninst✝² : SMulZeroClass S R\ninst✝¹ : SMulZeroClass (MulOpposite S) R\ninst✝ : IsCentralScalar S R\n⊢ IsCentralScalar S (Polynomial R)","decl":"instance isCentralScalar {S} [SMulZeroClass S R] [SMulZeroClass Sᵐᵒᵖ R] [IsCentralScalar S R] :\n  IsCentralScalar S R[X] :=\n  ⟨by\n    rintro _ ⟨⟩\n    simp_rw [← ofFinsupp_smul, op_smul_eq_smul]⟩\n\n"}
{"name":"Polynomial.toFinsuppIso_symm_apply","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\ntoFinsupp : AddMonoidAlgebra R Nat\n⊢ Eq ((Polynomial.toFinsuppIso R).symm toFinsupp) { toFinsupp := toFinsupp }","decl":"/-- Ring isomorphism between `R[X]` and `R[ℕ]`. This is just an\nimplementation detail, but it can be useful to transfer results from `Finsupp` to polynomials. -/\n@[simps apply symm_apply]\ndef toFinsuppIso : R[X] ≃+* R[ℕ] where\n  toFun := toFinsupp\n  invFun := ofFinsupp\n  left_inv := fun ⟨_p⟩ => rfl\n  right_inv _p := rfl\n  map_mul' := toFinsupp_mul\n  map_add' := toFinsupp_add\n\n"}
{"name":"Polynomial.toFinsuppIso_apply","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nself : Polynomial R\n⊢ Eq ((Polynomial.toFinsuppIso R) self) self.toFinsupp","decl":"/-- Ring isomorphism between `R[X]` and `R[ℕ]`. This is just an\nimplementation detail, but it can be useful to transfer results from `Finsupp` to polynomials. -/\n@[simps apply symm_apply]\ndef toFinsuppIso : R[X] ≃+* R[ℕ] where\n  toFun := toFinsupp\n  invFun := ofFinsupp\n  left_inv := fun ⟨_p⟩ => rfl\n  right_inv _p := rfl\n  map_mul' := toFinsupp_mul\n  map_add' := toFinsupp_add\n\n"}
{"name":"Polynomial.toFinsuppIsoLinear_apply","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na✝ : Polynomial R\n⊢ Eq ((Polynomial.toFinsuppIsoLinear R) a✝) a✝.toFinsupp","decl":"/-- Linear isomorphism between `R[X]` and `R[ℕ]`. This is just an\nimplementation detail, but it can be useful to transfer results from `Finsupp` to polynomials. -/\n@[simps!]\ndef toFinsuppIsoLinear : R[X] ≃ₗ[R] R[ℕ] where\n  __ := toFinsuppIso R\n  map_smul' _ _ := rfl\n\n"}
{"name":"Polynomial.toFinsuppIsoLinear_symm_apply_toFinsupp","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na✝ : AddMonoidAlgebra R Nat\n⊢ Eq ((Polynomial.toFinsuppIsoLinear R).symm a✝).toFinsupp a✝","decl":"/-- Linear isomorphism between `R[X]` and `R[ℕ]`. This is just an\nimplementation detail, but it can be useful to transfer results from `Finsupp` to polynomials. -/\n@[simps!]\ndef toFinsuppIsoLinear : R[X] ≃ₗ[R] R[ℕ] where\n  __ := toFinsuppIso R\n  map_smul' _ _ := rfl\n\n"}
{"name":"Polynomial.ofFinsupp_sum","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nι : Type u_1\ns : Finset ι\nf : ι → AddMonoidAlgebra R Nat\n⊢ Eq { toFinsupp := s.sum fun i => f i } (s.sum fun i => { toFinsupp := f i })","decl":"theorem ofFinsupp_sum {ι : Type*} (s : Finset ι) (f : ι → R[ℕ]) :\n    (⟨∑ i ∈ s, f i⟩ : R[X]) = ∑ i ∈ s, ⟨f i⟩ :=\n  map_sum (toFinsuppIso R).symm f s\n\n"}
{"name":"Polynomial.toFinsupp_sum","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nι : Type u_1\ns : Finset ι\nf : ι → Polynomial R\n⊢ Eq (s.sum fun i => f i).toFinsupp (s.sum fun i => (f i).toFinsupp)","decl":"theorem toFinsupp_sum {ι : Type*} (s : Finset ι) (f : ι → R[X]) :\n    (∑ i ∈ s, f i : R[X]).toFinsupp = ∑ i ∈ s, (f i).toFinsupp :=\n  map_sum (toFinsuppIso R) f s\n\n"}
{"name":"Polynomial.support_ofFinsupp","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : AddMonoidAlgebra R Nat\n⊢ Eq { toFinsupp := p }.support p.support","decl":"@[simp]\ntheorem support_ofFinsupp (p) : support (⟨p⟩ : R[X]) = p.support := by rw [support]\n\n"}
{"name":"Polynomial.support_toFinsupp","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq p.toFinsupp.support p.support","decl":"theorem support_toFinsupp (p : R[X]) : p.toFinsupp.support = p.support := by rw [support]\n\n"}
{"name":"Polynomial.support_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.support 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem support_zero : (0 : R[X]).support = ∅ :=\n  rfl\n\n"}
{"name":"Polynomial.support_eq_empty","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Iff (Eq p.support EmptyCollection.emptyCollection) (Eq p 0)","decl":"@[simp]\ntheorem support_eq_empty : p.support = ∅ ↔ p = 0 := by\n  rcases p with ⟨⟩\n  simp [support]\n\n"}
{"name":"Polynomial.support_nonempty","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Iff p.support.Nonempty (Ne p 0)","decl":"@[simp] lemma support_nonempty : p.support.Nonempty ↔ p ≠ 0 :=\n  Finset.nonempty_iff_ne_empty.trans support_eq_empty.not\n\n"}
{"name":"Polynomial.card_support_eq_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Iff (Eq p.support.card 0) (Eq p 0)","decl":"theorem card_support_eq_zero : #p.support = 0 ↔ p = 0 := by simp\n\n"}
{"name":"Polynomial.toFinsupp_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nr : R\n⊢ Eq ((Polynomial.monomial n) r).toFinsupp (Finsupp.single n r)","decl":"@[simp]\ntheorem toFinsupp_monomial (n : ℕ) (r : R) : (monomial n r).toFinsupp = Finsupp.single n r := by\n  simp [monomial]\n\n"}
{"name":"Polynomial.ofFinsupp_single","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nr : R\n⊢ Eq { toFinsupp := Finsupp.single n r } ((Polynomial.monomial n) r)","decl":"@[simp]\ntheorem ofFinsupp_single (n : ℕ) (r : R) : (⟨Finsupp.single n r⟩ : R[X]) = monomial n r := by\n  simp [monomial]\n\n"}
{"name":"Polynomial.monomial_zero_right","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\n⊢ Eq ((Polynomial.monomial n) 0) 0","decl":"@[simp]\ntheorem monomial_zero_right (n : ℕ) : monomial n (0 : R) = 0 :=\n  (monomial n).map_zero\n\n-- This is not a `simp` lemma as `monomial_zero_left` is more general.\n"}
{"name":"Polynomial.monomial_zero_one","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq ((Polynomial.monomial 0) 1) 1","decl":"theorem monomial_zero_one : monomial 0 (1 : R) = 1 :=\n  rfl\n\n-- TODO: can't we just delete this one?\n"}
{"name":"Polynomial.monomial_add","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nr s : R\n⊢ Eq ((Polynomial.monomial n) (HAdd.hAdd r s)) (HAdd.hAdd ((Polynomial.monomial n) r) ((Polynomial.monomial n) s))","decl":"theorem monomial_add (n : ℕ) (r s : R) : monomial n (r + s) = monomial n r + monomial n s :=\n  (monomial n).map_add _ _\n\n"}
{"name":"Polynomial.monomial_mul_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn m : Nat\nr s : R\n⊢ Eq (HMul.hMul ((Polynomial.monomial n) r) ((Polynomial.monomial m) s)) ((Polynomial.monomial (HAdd.hAdd n m)) (HMul.hMul r s))","decl":"theorem monomial_mul_monomial (n m : ℕ) (r s : R) :\n    monomial n r * monomial m s = monomial (n + m) (r * s) :=\n  toFinsupp_injective <| by\n    simp only [toFinsupp_monomial, toFinsupp_mul, AddMonoidAlgebra.single_mul_single]\n\n"}
{"name":"Polynomial.monomial_pow","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nr : R\nk : Nat\n⊢ Eq (HPow.hPow ((Polynomial.monomial n) r) k) ((Polynomial.monomial (HMul.hMul n k)) (HPow.hPow r k))","decl":"@[simp]\ntheorem monomial_pow (n : ℕ) (r : R) (k : ℕ) : monomial n r ^ k = monomial (n * k) (r ^ k) := by\n  induction k with\n  | zero => simp [pow_zero, monomial_zero_one]\n  | succ k ih => simp [pow_succ, ih, monomial_mul_monomial, mul_add, add_comm]\n\n"}
{"name":"Polynomial.smul_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type u_1\ninst✝ : SMulZeroClass S R\na : S\nn : Nat\nb : R\n⊢ Eq (HSMul.hSMul a ((Polynomial.monomial n) b)) ((Polynomial.monomial n) (HSMul.hSMul a b))","decl":"theorem smul_monomial {S} [SMulZeroClass S R] (a : S) (n : ℕ) (b : R) :\n    a • monomial n b = monomial n (a • b) :=\n  toFinsupp_injective <| AddMonoidAlgebra.smul_single _ _ _\n\n"}
{"name":"Polynomial.monomial_injective","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\n⊢ Function.Injective ⇑(Polynomial.monomial n)","decl":"theorem monomial_injective (n : ℕ) : Function.Injective (monomial n : R → R[X]) :=\n  (toFinsuppIso R).symm.injective.comp (single_injective n)\n\n"}
{"name":"Polynomial.monomial_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nt : R\nn : Nat\n⊢ Iff (Eq ((Polynomial.monomial n) t) 0) (Eq t 0)","decl":"@[simp]\ntheorem monomial_eq_zero_iff (t : R) (n : ℕ) : monomial n t = 0 ↔ t = 0 :=\n  LinearMap.map_eq_zero_iff _ (Polynomial.monomial_injective n)\n\n"}
{"name":"Polynomial.monomial_eq_monomial_iff","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nm n : Nat\na b : R\n⊢ Iff (Eq ((Polynomial.monomial m) a) ((Polynomial.monomial n) b)) (Or (And (Eq m n) (Eq a b)) (And (Eq a 0) (Eq b 0)))","decl":"theorem monomial_eq_monomial_iff {m n : ℕ} {a b : R} :\n    monomial m a = monomial n b ↔ m = n ∧ a = b ∨ a = 0 ∧ b = 0 := by\n  rw [← toFinsupp_inj, toFinsupp_monomial, toFinsupp_monomial, Finsupp.single_eq_single_iff]\n\n"}
{"name":"Polynomial.support_add","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\n⊢ HasSubset.Subset (HAdd.hAdd p q).support (Union.union p.support q.support)","decl":"theorem support_add : (p + q).support ⊆ p.support ∪ q.support := by\n  simpa [support] using Finsupp.support_add\n\n"}
{"name":"Polynomial.monomial_zero_left","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\n⊢ Eq ((Polynomial.monomial 0) a) (Polynomial.C a)","decl":"@[simp]\ntheorem monomial_zero_left (a : R) : monomial 0 a = C a :=\n  rfl\n\n"}
{"name":"Polynomial.toFinsupp_C","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\n⊢ Eq (Polynomial.C a).toFinsupp (AddMonoidAlgebra.single 0 a)","decl":"@[simp]\ntheorem toFinsupp_C (a : R) : (C a).toFinsupp = single 0 a :=\n  rfl\n\n"}
{"name":"Polynomial.C_0","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.C 0) 0","decl":"theorem C_0 : C (0 : R) = 0 := by simp\n\n"}
{"name":"Polynomial.C_1","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.C 1) 1","decl":"theorem C_1 : C (1 : R) = 1 :=\n  rfl\n\n"}
{"name":"Polynomial.C_mul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na b : R\ninst✝ : Semiring R\n⊢ Eq (Polynomial.C (HMul.hMul a b)) (HMul.hMul (Polynomial.C a) (Polynomial.C b))","decl":"theorem C_mul : C (a * b) = C a * C b :=\n  C.map_mul a b\n\n"}
{"name":"Polynomial.C_add","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na b : R\ninst✝ : Semiring R\n⊢ Eq (Polynomial.C (HAdd.hAdd a b)) (HAdd.hAdd (Polynomial.C a) (Polynomial.C b))","decl":"theorem C_add : C (a + b) = C a + C b :=\n  C.map_add a b\n\n"}
{"name":"Polynomial.smul_C","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type u_1\ninst✝ : SMulZeroClass S R\ns : S\nr : R\n⊢ Eq (HSMul.hSMul s (Polynomial.C r)) (Polynomial.C (HSMul.hSMul s r))","decl":"@[simp]\ntheorem smul_C {S} [SMulZeroClass S R] (s : S) (r : R) : s • C r = C (s • r) :=\n  smul_monomial _ _ r\n\n"}
{"name":"Polynomial.C_pow","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na : R\nn : Nat\ninst✝ : Semiring R\n⊢ Eq (Polynomial.C (HPow.hPow a n)) (HPow.hPow (Polynomial.C a) n)","decl":"theorem C_pow : C (a ^ n) = C a ^ n :=\n  C.map_pow a n\n\n"}
{"name":"Polynomial.C_eq_natCast","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (Polynomial.C ↑n) ↑n","decl":"theorem C_eq_natCast (n : ℕ) : C (n : R) = (n : R[X]) :=\n  map_natCast C n\n\n"}
{"name":"Polynomial.C_mul_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na b : R\nn : Nat\ninst✝ : Semiring R\n⊢ Eq (HMul.hMul (Polynomial.C a) ((Polynomial.monomial n) b)) ((Polynomial.monomial n) (HMul.hMul a b))","decl":"@[simp]\ntheorem C_mul_monomial : C a * monomial n b = monomial n (a * b) := by\n  simp only [← monomial_zero_left, monomial_mul_monomial, zero_add]\n\n"}
{"name":"Polynomial.monomial_mul_C","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na b : R\nn : Nat\ninst✝ : Semiring R\n⊢ Eq (HMul.hMul ((Polynomial.monomial n) a) (Polynomial.C b)) ((Polynomial.monomial n) (HMul.hMul a b))","decl":"@[simp]\ntheorem monomial_mul_C : monomial n a * C b = monomial n (a * b) := by\n  simp only [← monomial_zero_left, monomial_mul_monomial, add_zero]\n\n"}
{"name":"Polynomial.monomial_one_one_eq_X","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq ((Polynomial.monomial 1) 1) Polynomial.X","decl":"theorem monomial_one_one_eq_X : monomial 1 (1 : R) = X :=\n  rfl\n\n"}
{"name":"Polynomial.monomial_one_right_eq_X_pow","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\n⊢ Eq ((Polynomial.monomial n) 1) (HPow.hPow Polynomial.X n)","decl":"theorem monomial_one_right_eq_X_pow (n : ℕ) : monomial n (1 : R) = X ^ n := by\n  induction n with\n  | zero => simp [monomial_zero_one]\n  | succ n ih => rw [pow_succ, ← ih, ← monomial_one_one_eq_X, monomial_mul_monomial, mul_one]\n\n"}
{"name":"Polynomial.toFinsupp_X","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq Polynomial.X.toFinsupp (Finsupp.single 1 1)","decl":"@[simp]\ntheorem toFinsupp_X : X.toFinsupp = Finsupp.single 1 (1 : R) :=\n  rfl\n\n"}
{"name":"Polynomial.X_ne_C","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\na : R\n⊢ Ne Polynomial.X (Polynomial.C a)","decl":"theorem X_ne_C [Nontrivial R] (a : R) : X ≠ C a := by\n  intro he\n  simpa using monomial_eq_monomial_iff.1 he\n\n"}
{"name":"Polynomial.X_mul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (HMul.hMul Polynomial.X p) (HMul.hMul p Polynomial.X)","decl":"/-- `X` commutes with everything, even when the coefficients are noncommutative. -/\ntheorem X_mul : X * p = p * X := by\n  rcases p with ⟨⟩\n  -- Porting note: `ofFinsupp.injEq` is required.\n  simp only [X, ← ofFinsupp_single, ← ofFinsupp_mul, LinearMap.coe_mk, ofFinsupp.injEq]\n  -- Porting note: Was `ext`.\n  refine Finsupp.ext fun _ => ?_\n  simp [AddMonoidAlgebra.mul_apply, AddMonoidAlgebra.sum_single_index, add_comm]\n\n"}
{"name":"Polynomial.X_pow_mul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Eq (HMul.hMul (HPow.hPow Polynomial.X n) p) (HMul.hMul p (HPow.hPow Polynomial.X n))","decl":"theorem X_pow_mul {n : ℕ} : X ^ n * p = p * X ^ n := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    conv_lhs => rw [pow_succ]\n    rw [mul_assoc, X_mul, ← mul_assoc, ih, mul_assoc, ← pow_succ]\n\n"}
{"name":"Polynomial.X_mul_C","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nr : R\n⊢ Eq (HMul.hMul Polynomial.X (Polynomial.C r)) (HMul.hMul (Polynomial.C r) Polynomial.X)","decl":"/-- Prefer putting constants to the left of `X`.\n\nThis lemma is the loop-avoiding `simp` version of `Polynomial.X_mul`. -/\n@[simp]\ntheorem X_mul_C (r : R) : X * C r = C r * X :=\n  X_mul\n\n"}
{"name":"Polynomial.X_pow_mul_C","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nr : R\nn : Nat\n⊢ Eq (HMul.hMul (HPow.hPow Polynomial.X n) (Polynomial.C r)) (HMul.hMul (Polynomial.C r) (HPow.hPow Polynomial.X n))","decl":"/-- Prefer putting constants to the left of `X ^ n`.\n\nThis lemma is the loop-avoiding `simp` version of `X_pow_mul`. -/\n@[simp]\ntheorem X_pow_mul_C (r : R) (n : ℕ) : X ^ n * C r = C r * X ^ n :=\n  X_pow_mul\n\n"}
{"name":"Polynomial.X_pow_mul_assoc","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nn : Nat\n⊢ Eq (HMul.hMul (HMul.hMul p (HPow.hPow Polynomial.X n)) q) (HMul.hMul (HMul.hMul p q) (HPow.hPow Polynomial.X n))","decl":"theorem X_pow_mul_assoc {n : ℕ} : p * X ^ n * q = p * q * X ^ n := by\n  rw [mul_assoc, X_pow_mul, ← mul_assoc]\n\n"}
{"name":"Polynomial.X_pow_mul_assoc_C","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\nr : R\n⊢ Eq (HMul.hMul (HMul.hMul p (HPow.hPow Polynomial.X n)) (Polynomial.C r)) (HMul.hMul (HMul.hMul p (Polynomial.C r)) (HPow.hPow Polynomial.X n))","decl":"/-- Prefer putting constants to the left of `X ^ n`.\n\nThis lemma is the loop-avoiding `simp` version of `X_pow_mul_assoc`. -/\n@[simp]\ntheorem X_pow_mul_assoc_C {n : ℕ} (r : R) : p * X ^ n * C r = p * C r * X ^ n :=\n  X_pow_mul_assoc\n\n"}
{"name":"Polynomial.commute_X","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Commute Polynomial.X p","decl":"theorem commute_X (p : R[X]) : Commute X p :=\n  X_mul\n\n"}
{"name":"Polynomial.commute_X_pow","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Commute (HPow.hPow Polynomial.X n) p","decl":"theorem commute_X_pow (p : R[X]) (n : ℕ) : Commute (X ^ n) p :=\n  X_pow_mul\n\n"}
{"name":"Polynomial.monomial_mul_X","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nr : R\n⊢ Eq (HMul.hMul ((Polynomial.monomial n) r) Polynomial.X) ((Polynomial.monomial (HAdd.hAdd n 1)) r)","decl":"@[simp]\ntheorem monomial_mul_X (n : ℕ) (r : R) : monomial n r * X = monomial (n + 1) r := by\n  erw [monomial_mul_monomial, mul_one]\n\n"}
{"name":"Polynomial.monomial_mul_X_pow","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nr : R\nk : Nat\n⊢ Eq (HMul.hMul ((Polynomial.monomial n) r) (HPow.hPow Polynomial.X k)) ((Polynomial.monomial (HAdd.hAdd n k)) r)","decl":"@[simp]\ntheorem monomial_mul_X_pow (n : ℕ) (r : R) (k : ℕ) :\n    monomial n r * X ^ k = monomial (n + k) r := by\n  induction k with\n  | zero => simp\n  | succ k ih => simp [ih, pow_succ, ← mul_assoc, add_assoc]\n\n"}
{"name":"Polynomial.X_mul_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nr : R\n⊢ Eq (HMul.hMul Polynomial.X ((Polynomial.monomial n) r)) ((Polynomial.monomial (HAdd.hAdd n 1)) r)","decl":"@[simp]\ntheorem X_mul_monomial (n : ℕ) (r : R) : X * monomial n r = monomial (n + 1) r := by\n  rw [X_mul, monomial_mul_X]\n\n"}
{"name":"Polynomial.X_pow_mul_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nk n : Nat\nr : R\n⊢ Eq (HMul.hMul (HPow.hPow Polynomial.X k) ((Polynomial.monomial n) r)) ((Polynomial.monomial (HAdd.hAdd n k)) r)","decl":"@[simp]\ntheorem X_pow_mul_monomial (k n : ℕ) (r : R) : X ^ k * monomial n r = monomial (n + k) r := by\n  rw [X_pow_mul, monomial_mul_X_pow]\n\n"}
{"name":"Polynomial.coeff_ofFinsupp","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : AddMonoidAlgebra R Nat\n⊢ Eq { toFinsupp := p }.coeff ⇑p","decl":"@[simp]\ntheorem coeff_ofFinsupp (p) : coeff (⟨p⟩ : R[X]) = p := by rw [coeff]\n\n"}
{"name":"Polynomial.coeff_injective","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Function.Injective Polynomial.coeff","decl":"theorem coeff_injective : Injective (coeff : R[X] → ℕ → R) := by\n  rintro ⟨p⟩ ⟨q⟩\n  -- Porting note: `ofFinsupp.injEq` is required.\n  simp only [coeff, DFunLike.coe_fn_eq, imp_self, ofFinsupp.injEq]\n\n"}
{"name":"Polynomial.coeff_inj","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\n⊢ Iff (Eq p.coeff q.coeff) (Eq p q)","decl":"@[simp]\ntheorem coeff_inj : p.coeff = q.coeff ↔ p = q :=\n  coeff_injective.eq_iff\n\n"}
{"name":"Polynomial.toFinsupp_apply","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nf : Polynomial R\ni : Nat\n⊢ Eq (f.toFinsupp i) (f.coeff i)","decl":"theorem toFinsupp_apply (f : R[X]) (i) : f.toFinsupp i = f.coeff i := by cases f; rfl\n\n"}
{"name":"Polynomial.coeff_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na : R\nm n : Nat\ninst✝ : Semiring R\n⊢ Eq (((Polynomial.monomial n) a).coeff m) (ite (Eq n m) a 0)","decl":"theorem coeff_monomial : coeff (monomial n a) m = if n = m then a else 0 := by\n  simp [coeff, Finsupp.single_apply]\n\n"}
{"name":"Polynomial.coeff_monomial_same","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nc : R\n⊢ Eq (((Polynomial.monomial n) c).coeff n) c","decl":"@[simp]\ntheorem coeff_monomial_same (n : ℕ) (c : R) : (monomial n c).coeff n = c :=\n  Finsupp.single_eq_same\n\n"}
{"name":"Polynomial.coeff_monomial_of_ne","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nm n : Nat\nc : R\nh : Ne n m\n⊢ Eq (((Polynomial.monomial n) c).coeff m) 0","decl":"theorem coeff_monomial_of_ne {m n : ℕ} (c : R) (h : n ≠ m) : (monomial n c).coeff m = 0 :=\n  Finsupp.single_eq_of_ne h\n\n"}
{"name":"Polynomial.coeff_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (Polynomial.coeff 0 n) 0","decl":"@[simp]\ntheorem coeff_zero (n : ℕ) : coeff (0 : R[X]) n = 0 :=\n  rfl\n\n"}
{"name":"Polynomial.coeff_one","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (Polynomial.coeff 1 n) (ite (Eq n 0) 1 0)","decl":"theorem coeff_one {n : ℕ} : coeff (1 : R[X]) n = if n = 0 then 1 else 0 := by\n  simp_rw [eq_comm (a := n) (b := 0)]\n  exact coeff_monomial\n\n"}
{"name":"Polynomial.coeff_one_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.coeff 1 0) 1","decl":"@[simp]\ntheorem coeff_one_zero : coeff (1 : R[X]) 0 = 1 := by\n  simp [coeff_one]\n\n"}
{"name":"Polynomial.coeff_X_one","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.X.coeff 1) 1","decl":"@[simp]\ntheorem coeff_X_one : coeff (X : R[X]) 1 = 1 :=\n  coeff_monomial\n\n"}
{"name":"Polynomial.coeff_X_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.X.coeff 0) 0","decl":"@[simp]\ntheorem coeff_X_zero : coeff (X : R[X]) 0 = 0 :=\n  coeff_monomial\n\n"}
{"name":"Polynomial.coeff_monomial_succ","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na : R\nn : Nat\ninst✝ : Semiring R\n⊢ Eq (((Polynomial.monomial (HAdd.hAdd n 1)) a).coeff 0) 0","decl":"@[simp]\ntheorem coeff_monomial_succ : coeff (monomial (n + 1) a) 0 = 0 := by simp [coeff_monomial]\n\n"}
{"name":"Polynomial.coeff_X","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\nn : Nat\ninst✝ : Semiring R\n⊢ Eq (Polynomial.X.coeff n) (ite (Eq 1 n) 1 0)","decl":"theorem coeff_X : coeff (X : R[X]) n = if 1 = n then 1 else 0 :=\n  coeff_monomial\n\n"}
{"name":"Polynomial.coeff_X_of_ne_one","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nhn : Ne n 1\n⊢ Eq (Polynomial.X.coeff n) 0","decl":"theorem coeff_X_of_ne_one {n : ℕ} (hn : n ≠ 1) : coeff (X : R[X]) n = 0 := by\n  rw [coeff_X, if_neg hn.symm]\n\n"}
{"name":"Polynomial.mem_support_iff","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\nn : Nat\ninst✝ : Semiring R\np : Polynomial R\n⊢ Iff (Membership.mem p.support n) (Ne (p.coeff n) 0)","decl":"@[simp]\ntheorem mem_support_iff : n ∈ p.support ↔ p.coeff n ≠ 0 := by\n  rcases p with ⟨⟩\n  simp\n\n"}
{"name":"Polynomial.not_mem_support_iff","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\nn : Nat\ninst✝ : Semiring R\np : Polynomial R\n⊢ Iff (Not (Membership.mem p.support n)) (Eq (p.coeff n) 0)","decl":"theorem not_mem_support_iff : n ∉ p.support ↔ p.coeff n = 0 := by simp\n\n"}
{"name":"Polynomial.coeff_C","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na : R\nn : Nat\ninst✝ : Semiring R\n⊢ Eq ((Polynomial.C a).coeff n) (ite (Eq n 0) a 0)","decl":"theorem coeff_C : coeff (C a) n = ite (n = 0) a 0 := by\n  convert coeff_monomial (a := a) (m := n) (n := 0) using 2\n  simp [eq_comm]\n\n"}
{"name":"Polynomial.coeff_C_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\n⊢ Eq ((Polynomial.C a).coeff 0) a","decl":"@[simp]\ntheorem coeff_C_zero : coeff (C a) 0 = a :=\n  coeff_monomial\n\n"}
{"name":"Polynomial.coeff_C_ne_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na : R\nn : Nat\ninst✝ : Semiring R\nh : Ne n 0\n⊢ Eq ((Polynomial.C a).coeff n) 0","decl":"theorem coeff_C_ne_zero (h : n ≠ 0) : (C a).coeff n = 0 := by rw [coeff_C, if_neg h]\n\n"}
{"name":"Polynomial.coeff_C_succ","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nr : R\nn : Nat\n⊢ Eq ((Polynomial.C r).coeff (HAdd.hAdd n 1)) 0","decl":"@[simp]\nlemma coeff_C_succ {r : R} {n : ℕ} : coeff (C r) (n + 1) = 0 := by simp [coeff_C]\n\n"}
{"name":"Polynomial.coeff_natCast_ite","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\nm n : Nat\ninst✝ : Semiring R\n⊢ Eq ((↑m).coeff n) ↑(ite (Eq n 0) m 0)","decl":"@[simp]\ntheorem coeff_natCast_ite : (Nat.cast m : R[X]).coeff n = ite (n = 0) m 0 := by\n  simp only [← C_eq_natCast, coeff_C, Nat.cast_ite, Nat.cast_zero]\n\n"}
{"name":"Polynomial.coeff_ofNat_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\na : Nat\ninst✝ : a.AtLeastTwo\n⊢ Eq ((OfNat.ofNat a).coeff 0) (OfNat.ofNat a)","decl":"@[simp]\ntheorem coeff_ofNat_zero (a : ℕ) [a.AtLeastTwo] :\n    coeff (ofNat(a) : R[X]) 0 = ofNat(a) :=\n  coeff_monomial\n\n"}
{"name":"Polynomial.coeff_ofNat_succ","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na n : Nat\nh : a.AtLeastTwo\n⊢ Eq ((OfNat.ofNat a).coeff (HAdd.hAdd n 1)) 0","decl":"@[simp]\ntheorem coeff_ofNat_succ (a n : ℕ) [h : a.AtLeastTwo] :\n    coeff (ofNat(a) : R[X]) (n + 1) = 0 := by\n  rw [← Nat.cast_ofNat]\n  simp [-Nat.cast_ofNat]\n\n"}
{"name":"Polynomial.C_mul_X_pow_eq_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X n)) ((Polynomial.monomial n) a)","decl":"theorem C_mul_X_pow_eq_monomial : ∀ {n : ℕ}, C a * X ^ n = monomial n a\n  | 0 => mul_one _\n  | n + 1 => by\n    rw [pow_succ, ← mul_assoc, C_mul_X_pow_eq_monomial, X, monomial_mul_monomial, mul_one]\n\n"}
{"name":"Polynomial.toFinsupp_C_mul_X_pow","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\nn : Nat\n⊢ Eq (HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X n)).toFinsupp (Finsupp.single n a)","decl":"@[simp high]\ntheorem toFinsupp_C_mul_X_pow (a : R) (n : ℕ) :\n    Polynomial.toFinsupp (C a * X ^ n) = Finsupp.single n a := by\n  rw [C_mul_X_pow_eq_monomial, toFinsupp_monomial]\n\n"}
{"name":"Polynomial.C_mul_X_eq_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\n⊢ Eq (HMul.hMul (Polynomial.C a) Polynomial.X) ((Polynomial.monomial 1) a)","decl":"theorem C_mul_X_eq_monomial : C a * X = monomial 1 a := by rw [← C_mul_X_pow_eq_monomial, pow_one]\n\n"}
{"name":"Polynomial.toFinsupp_C_mul_X","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\n⊢ Eq (HMul.hMul (Polynomial.C a) Polynomial.X).toFinsupp (Finsupp.single 1 a)","decl":"@[simp high]\ntheorem toFinsupp_C_mul_X (a : R) : Polynomial.toFinsupp (C a * X) = Finsupp.single 1 a := by\n  rw [C_mul_X_eq_monomial, toFinsupp_monomial]\n\n"}
{"name":"Polynomial.C_injective","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Function.Injective ⇑Polynomial.C","decl":"theorem C_injective : Injective (C : R → R[X]) :=\n  monomial_injective 0\n\n"}
{"name":"Polynomial.C_inj","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na b : R\ninst✝ : Semiring R\n⊢ Iff (Eq (Polynomial.C a) (Polynomial.C b)) (Eq a b)","decl":"@[simp]\ntheorem C_inj : C a = C b ↔ a = b :=\n  C_injective.eq_iff\n\n"}
{"name":"Polynomial.C_eq_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\n⊢ Iff (Eq (Polynomial.C a) 0) (Eq a 0)","decl":"@[simp]\ntheorem C_eq_zero : C a = 0 ↔ a = 0 :=\n  C_injective.eq_iff' (map_zero C)\n\n"}
{"name":"Polynomial.C_ne_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\n⊢ Iff (Ne (Polynomial.C a) 0) (Ne a 0)","decl":"theorem C_ne_zero : C a ≠ 0 ↔ a ≠ 0 :=\n  C_eq_zero.not\n\n"}
{"name":"Polynomial.subsingleton_iff_subsingleton","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Iff (Subsingleton (Polynomial R)) (Subsingleton R)","decl":"theorem subsingleton_iff_subsingleton : Subsingleton R[X] ↔ Subsingleton R :=\n  ⟨@Injective.subsingleton _ _ _ C_injective, by\n    intro\n    infer_instance⟩\n\n"}
{"name":"Polynomial.Nontrivial.of_polynomial_ne","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nh : Ne p q\n⊢ Nontrivial R","decl":"theorem Nontrivial.of_polynomial_ne (h : p ≠ q) : Nontrivial R :=\n  (subsingleton_or_nontrivial R).resolve_left fun _hI => h <| Subsingleton.elim _ _\n\n"}
{"name":"Polynomial.forall_eq_iff_forall_eq","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Iff (∀ (f g : Polynomial R), Eq f g) (∀ (a b : R), Eq a b)","decl":"theorem forall_eq_iff_forall_eq : (∀ f g : R[X], f = g) ↔ ∀ a b : R, a = b := by\n  simpa only [← subsingleton_iff] using subsingleton_iff_subsingleton\n\n"}
{"name":"Polynomial.ext_iff","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\n⊢ Iff (Eq p q) (∀ (n : Nat), Eq (p.coeff n) (q.coeff n))","decl":"theorem ext_iff {p q : R[X]} : p = q ↔ ∀ n, coeff p n = coeff q n := by\n  rcases p with ⟨f : ℕ →₀ R⟩\n  rcases q with ⟨g : ℕ →₀ R⟩\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): was `simp [coeff, DFunLike.ext_iff]`\n  simpa [coeff] using DFunLike.ext_iff (f := f) (g := g)\n\n"}
{"name":"Polynomial.ext","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\na✝ : ∀ (n : Nat), Eq (p.coeff n) (q.coeff n)\n⊢ Eq p q","decl":"@[ext]\ntheorem ext {p q : R[X]} : (∀ n, coeff p n = coeff q n) → p = q :=\n  ext_iff.2\n\n"}
{"name":"Polynomial.addSubmonoid_closure_setOf_eq_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (AddSubmonoid.closure (setOf fun p => Exists fun n => Exists fun a => Eq p ((Polynomial.monomial n) a))) Top.top","decl":"/-- Monomials generate the additive monoid of polynomials. -/\ntheorem addSubmonoid_closure_setOf_eq_monomial :\n    AddSubmonoid.closure { p : R[X] | ∃ n a, p = monomial n a } = ⊤ := by\n  apply top_unique\n  rw [← AddSubmonoid.map_equiv_top (toFinsuppIso R).symm.toAddEquiv, ←\n    Finsupp.add_closure_setOf_eq_single, AddMonoidHom.map_mclosure]\n  refine AddSubmonoid.closure_mono (Set.image_subset_iff.2 ?_)\n  rintro _ ⟨n, a, rfl⟩\n  exact ⟨n, a, Polynomial.ofFinsupp_single _ _⟩\n\n"}
{"name":"Polynomial.addHom_ext","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nM : Type u_1\ninst✝ : AddMonoid M\nf g : AddMonoidHom (Polynomial R) M\nh : ∀ (n : Nat) (a : R), Eq (f ((Polynomial.monomial n) a)) (g ((Polynomial.monomial n) a))\n⊢ Eq f g","decl":"theorem addHom_ext {M : Type*} [AddMonoid M] {f g : R[X] →+ M}\n    (h : ∀ n a, f (monomial n a) = g (monomial n a)) : f = g :=\n  AddMonoidHom.eq_of_eqOn_denseM addSubmonoid_closure_setOf_eq_monomial <| by\n    rintro p ⟨n, a, rfl⟩\n    exact h n a\n\n"}
{"name":"Polynomial.addHom_ext'_iff","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nM : Type u_1\ninst✝ : AddMonoid M\nf g : AddMonoidHom (Polynomial R) M\n⊢ Iff (Eq f g) (∀ (n : Nat), Eq (f.comp (Polynomial.monomial n).toAddMonoidHom) (g.comp (Polynomial.monomial n).toAddMonoidHom))","decl":"@[ext high]\ntheorem addHom_ext' {M : Type*} [AddMonoid M] {f g : R[X] →+ M}\n    (h : ∀ n, f.comp (monomial n).toAddMonoidHom = g.comp (monomial n).toAddMonoidHom) : f = g :=\n  addHom_ext fun n => DFunLike.congr_fun (h n)\n\n"}
{"name":"Polynomial.addHom_ext'","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nM : Type u_1\ninst✝ : AddMonoid M\nf g : AddMonoidHom (Polynomial R) M\nh : ∀ (n : Nat), Eq (f.comp (Polynomial.monomial n).toAddMonoidHom) (g.comp (Polynomial.monomial n).toAddMonoidHom)\n⊢ Eq f g","decl":"@[ext high]\ntheorem addHom_ext' {M : Type*} [AddMonoid M] {f g : R[X] →+ M}\n    (h : ∀ n, f.comp (monomial n).toAddMonoidHom = g.comp (monomial n).toAddMonoidHom) : f = g :=\n  addHom_ext fun n => DFunLike.congr_fun (h n)\n\n"}
{"name":"Polynomial.lhom_ext'_iff","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝² : Semiring R\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearMap (RingHom.id R) (Polynomial R) M\n⊢ Iff (Eq f g) (∀ (n : Nat), Eq (f.comp (Polynomial.monomial n)) (g.comp (Polynomial.monomial n)))","decl":"@[ext high]\ntheorem lhom_ext' {M : Type*} [AddCommMonoid M] [Module R M] {f g : R[X] →ₗ[R] M}\n    (h : ∀ n, f.comp (monomial n) = g.comp (monomial n)) : f = g :=\n  LinearMap.toAddMonoidHom_injective <| addHom_ext fun n => LinearMap.congr_fun (h n)\n\n-- this has the same content as the subsingleton\n"}
{"name":"Polynomial.lhom_ext'","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝² : Semiring R\nM : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearMap (RingHom.id R) (Polynomial R) M\nh : ∀ (n : Nat), Eq (f.comp (Polynomial.monomial n)) (g.comp (Polynomial.monomial n))\n⊢ Eq f g","decl":"@[ext high]\ntheorem lhom_ext' {M : Type*} [AddCommMonoid M] [Module R M] {f g : R[X] →ₗ[R] M}\n    (h : ∀ n, f.comp (monomial n) = g.comp (monomial n)) : f = g :=\n  LinearMap.toAddMonoidHom_injective <| addHom_ext fun n => LinearMap.congr_fun (h n)\n\n-- this has the same content as the subsingleton\n"}
{"name":"Polynomial.eq_zero_of_eq_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nh : Eq 0 1\np : Polynomial R\n⊢ Eq p 0","decl":"theorem eq_zero_of_eq_zero (h : (0 : R) = (1 : R)) (p : R[X]) : p = 0 := by\n  rw [← one_smul R p, ← h, zero_smul]\n\n"}
{"name":"Polynomial.support_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\na : R\nH : Ne a 0\n⊢ Eq ((Polynomial.monomial n) a).support (Singleton.singleton n)","decl":"theorem support_monomial (n) {a : R} (H : a ≠ 0) : (monomial n a).support = singleton n := by\n  rw [← ofFinsupp_single, support]; exact Finsupp.support_single_ne_zero _ H\n\n"}
{"name":"Polynomial.support_monomial'","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\na : R\n⊢ HasSubset.Subset ((Polynomial.monomial n) a).support (Singleton.singleton n)","decl":"theorem support_monomial' (n) (a : R) : (monomial n a).support ⊆ singleton n := by\n  rw [← ofFinsupp_single, support]\n  exact Finsupp.support_single_subset\n\n"}
{"name":"Polynomial.support_C","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\nh : Ne a 0\n⊢ Eq (Polynomial.C a).support (Singleton.singleton 0)","decl":"theorem support_C {a : R} (h : a ≠ 0) : (C a).support = singleton 0 :=\n  support_monomial 0 h\n\n"}
{"name":"Polynomial.support_C_subset","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\n⊢ HasSubset.Subset (Polynomial.C a).support (Singleton.singleton 0)","decl":"theorem support_C_subset (a : R) : (C a).support ⊆ singleton 0 :=\n  support_monomial' 0 a\n\n"}
{"name":"Polynomial.support_C_mul_X","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nc : R\nh : Ne c 0\n⊢ Eq (HMul.hMul (Polynomial.C c) Polynomial.X).support (Singleton.singleton 1)","decl":"theorem support_C_mul_X {c : R} (h : c ≠ 0) : Polynomial.support (C c * X) = singleton 1 := by\n  rw [C_mul_X_eq_monomial, support_monomial 1 h]\n\n"}
{"name":"Polynomial.support_C_mul_X'","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nc : R\n⊢ HasSubset.Subset (HMul.hMul (Polynomial.C c) Polynomial.X).support (Singleton.singleton 1)","decl":"theorem support_C_mul_X' (c : R) : Polynomial.support (C c * X) ⊆ singleton 1 := by\n  simpa only [C_mul_X_eq_monomial] using support_monomial' 1 c\n\n"}
{"name":"Polynomial.support_C_mul_X_pow","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nc : R\nh : Ne c 0\n⊢ Eq (HMul.hMul (Polynomial.C c) (HPow.hPow Polynomial.X n)).support (Singleton.singleton n)","decl":"theorem support_C_mul_X_pow (n : ℕ) {c : R} (h : c ≠ 0) :\n    Polynomial.support (C c * X ^ n) = singleton n := by\n  rw [C_mul_X_pow_eq_monomial, support_monomial n h]\n\n"}
{"name":"Polynomial.support_C_mul_X_pow'","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\nc : R\n⊢ HasSubset.Subset (HMul.hMul (Polynomial.C c) (HPow.hPow Polynomial.X n)).support (Singleton.singleton n)","decl":"theorem support_C_mul_X_pow' (n : ℕ) (c : R) : Polynomial.support (C c * X ^ n) ⊆ singleton n := by\n  simpa only [C_mul_X_pow_eq_monomial] using support_monomial' n c\n\n"}
{"name":"Polynomial.support_binomial'","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nk m : Nat\nx y : R\n⊢ HasSubset.Subset (HAdd.hAdd (HMul.hMul (Polynomial.C x) (HPow.hPow Polynomial.X k)) (HMul.hMul (Polynomial.C y) (HPow.hPow Polynomial.X m))).support (Insert.insert k (Singleton.singleton m))","decl":"theorem support_binomial' (k m : ℕ) (x y : R) :\n    Polynomial.support (C x * X ^ k + C y * X ^ m) ⊆ {k, m} :=\n  support_add.trans\n    (union_subset\n      ((support_C_mul_X_pow' k x).trans (singleton_subset_iff.mpr (mem_insert_self k {m})))\n      ((support_C_mul_X_pow' m y).trans\n        (singleton_subset_iff.mpr (mem_insert_of_mem (mem_singleton_self m)))))\n\n"}
{"name":"Polynomial.support_trinomial'","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nk m n : Nat\nx y z : R\n⊢ HasSubset.Subset (HAdd.hAdd (HAdd.hAdd (HMul.hMul (Polynomial.C x) (HPow.hPow Polynomial.X k)) (HMul.hMul (Polynomial.C y) (HPow.hPow Polynomial.X m))) (HMul.hMul (Polynomial.C z) (HPow.hPow Polynomial.X n))).support (Insert.insert k (Insert.insert m (Singleton.singleton n)))","decl":"theorem support_trinomial' (k m n : ℕ) (x y z : R) :\n    Polynomial.support (C x * X ^ k + C y * X ^ m + C z * X ^ n) ⊆ {k, m, n} :=\n  support_add.trans\n    (union_subset\n      (support_add.trans\n        (union_subset\n          ((support_C_mul_X_pow' k x).trans (singleton_subset_iff.mpr (mem_insert_self k {m, n})))\n          ((support_C_mul_X_pow' m y).trans\n            (singleton_subset_iff.mpr (mem_insert_of_mem (mem_insert_self m {n}))))))\n      ((support_C_mul_X_pow' n z).trans\n        (singleton_subset_iff.mpr (mem_insert_of_mem (mem_insert_of_mem (mem_singleton_self n))))))\n\n"}
{"name":"Polynomial.X_pow_eq_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (HPow.hPow Polynomial.X n) ((Polynomial.monomial n) 1)","decl":"theorem X_pow_eq_monomial (n) : X ^ n = monomial n (1 : R) := by\n  induction n with\n  | zero => rw [pow_zero, monomial_zero_one]\n  | succ n hn => rw [pow_succ, hn, X, monomial_mul_monomial, one_mul]\n\n"}
{"name":"Polynomial.toFinsupp_X_pow","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (HPow.hPow Polynomial.X n).toFinsupp (Finsupp.single n 1)","decl":"@[simp high]\ntheorem toFinsupp_X_pow (n : ℕ) : (X ^ n).toFinsupp = Finsupp.single n (1 : R) := by\n  rw [X_pow_eq_monomial, toFinsupp_monomial]\n\n"}
{"name":"Polynomial.smul_X_eq_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (HSMul.hSMul a (HPow.hPow Polynomial.X n)) ((Polynomial.monomial n) a)","decl":"theorem smul_X_eq_monomial {n} : a • X ^ n = monomial n (a : R) := by\n  rw [X_pow_eq_monomial, smul_monomial, smul_eq_mul, mul_one]\n\n"}
{"name":"Polynomial.support_X_pow","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nH : Not (Eq 1 0)\nn : Nat\n⊢ Eq (HPow.hPow Polynomial.X n).support (Singleton.singleton n)","decl":"theorem support_X_pow (H : ¬(1 : R) = 0) (n : ℕ) : (X ^ n : R[X]).support = singleton n := by\n  convert support_monomial n H\n  exact X_pow_eq_monomial n\n\n"}
{"name":"Polynomial.support_X_empty","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nH : Eq 1 0\n⊢ Eq Polynomial.X.support EmptyCollection.emptyCollection","decl":"theorem support_X_empty (H : (1 : R) = 0) : (X : R[X]).support = ∅ := by\n  rw [X, H, monomial_zero_right, support_zero]\n\n"}
{"name":"Polynomial.support_X","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nH : Not (Eq 1 0)\n⊢ Eq Polynomial.X.support (Singleton.singleton 1)","decl":"theorem support_X (H : ¬(1 : R) = 0) : (X : R[X]).support = singleton 1 := by\n  rw [← pow_one X, support_X_pow H 1]\n\n"}
{"name":"Polynomial.monomial_left_inj","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\nha : Ne a 0\ni j : Nat\n⊢ Iff (Eq ((Polynomial.monomial i) a) ((Polynomial.monomial j) a)) (Eq i j)","decl":"theorem monomial_left_inj {a : R} (ha : a ≠ 0) {i j : ℕ} :\n    monomial i a = monomial j a ↔ i = j := by\n  simp only [← ofFinsupp_single, ofFinsupp.injEq, Finsupp.single_left_inj ha]\n\n"}
{"name":"Polynomial.binomial_eq_binomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nk l m n : Nat\nu v : R\nhu : Ne u 0\nhv : Ne v 0\n⊢ Iff (Eq (HAdd.hAdd (HMul.hMul (Polynomial.C u) (HPow.hPow Polynomial.X k)) (HMul.hMul (Polynomial.C v) (HPow.hPow Polynomial.X l))) (HAdd.hAdd (HMul.hMul (Polynomial.C u) (HPow.hPow Polynomial.X m)) (HMul.hMul (Polynomial.C v) (HPow.hPow Polynomial.X n)))) (Or (And (Eq k m) (Eq l n)) (Or (And (Eq u v) (And (Eq k n) (Eq l m))) (And (Eq (HAdd.hAdd u v) 0) (And (Eq k l) (Eq m n)))))","decl":"theorem binomial_eq_binomial {k l m n : ℕ} {u v : R} (hu : u ≠ 0) (hv : v ≠ 0) :\n    C u * X ^ k + C v * X ^ l = C u * X ^ m + C v * X ^ n ↔\n      k = m ∧ l = n ∨ u = v ∧ k = n ∧ l = m ∨ u + v = 0 ∧ k = l ∧ m = n := by\n  simp_rw [C_mul_X_pow_eq_monomial, ← toFinsupp_inj, toFinsupp_add, toFinsupp_monomial]\n  exact Finsupp.single_add_single_eq_single_add_single hu hv\n\n"}
{"name":"Polynomial.natCast_mul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\np : Polynomial R\n⊢ Eq (HMul.hMul (↑n) p) (HSMul.hSMul n p)","decl":"theorem natCast_mul (n : ℕ) (p : R[X]) : (n : R[X]) * p = n • p :=\n  (nsmul_eq_mul _ _).symm\n\n"}
{"name":"Polynomial.sum_def","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type u_1\ninst✝ : AddCommMonoid S\np : Polynomial R\nf : Nat → R → S\n⊢ Eq (p.sum f) (p.support.sum fun n => f n (p.coeff n))","decl":"theorem sum_def {S : Type*} [AddCommMonoid S] (p : R[X]) (f : ℕ → R → S) :\n    p.sum f = ∑ n ∈ p.support, f n (p.coeff n) :=\n  rfl\n\n"}
{"name":"Polynomial.sum_eq_of_subset","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type u_1\ninst✝ : AddCommMonoid S\np : Polynomial R\nf : Nat → R → S\nhf : ∀ (i : Nat), Eq (f i 0) 0\ns : Finset Nat\nhs : HasSubset.Subset p.support s\n⊢ Eq (p.sum f) (s.sum fun n => f n (p.coeff n))","decl":"theorem sum_eq_of_subset {S : Type*} [AddCommMonoid S] {p : R[X]} (f : ℕ → R → S)\n    (hf : ∀ i, f i 0 = 0) {s : Finset ℕ} (hs : p.support ⊆ s) :\n    p.sum f = ∑ n ∈ s, f n (p.coeff n) :=\n  Finsupp.sum_of_support_subset _ hs f (fun i _ ↦ hf i)\n\n"}
{"name":"Polynomial.mul_eq_sum_sum","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\n⊢ Eq (HMul.hMul p q) (p.support.sum fun i => q.sum fun j a => (Polynomial.monomial (HAdd.hAdd i j)) (HMul.hMul (p.coeff i) a))","decl":"/-- Expressing the product of two polynomials as a double sum. -/\ntheorem mul_eq_sum_sum :\n    p * q = ∑ i ∈ p.support, q.sum fun j a => (monomial (i + j)) (p.coeff i * a) := by\n  apply toFinsupp_injective\n  rcases p with ⟨⟩; rcases q with ⟨⟩\n  simp_rw [sum, coeff, toFinsupp_sum, support, toFinsupp_mul, toFinsupp_monomial,\n    AddMonoidAlgebra.mul_def, Finsupp.sum]\n\n"}
{"name":"Polynomial.sum_zero_index","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type u_1\ninst✝ : AddCommMonoid S\nf : Nat → R → S\n⊢ Eq (Polynomial.sum 0 f) 0","decl":"@[simp]\ntheorem sum_zero_index {S : Type*} [AddCommMonoid S] (f : ℕ → R → S) : (0 : R[X]).sum f = 0 := by\n  simp [sum]\n\n"}
{"name":"Polynomial.sum_monomial_index","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type u_1\ninst✝ : AddCommMonoid S\nn : Nat\na : R\nf : Nat → R → S\nhf : Eq (f n 0) 0\n⊢ Eq (((Polynomial.monomial n) a).sum f) (f n a)","decl":"@[simp]\ntheorem sum_monomial_index {S : Type*} [AddCommMonoid S] {n : ℕ} (a : R) (f : ℕ → R → S)\n    (hf : f n 0 = 0) : (monomial n a : R[X]).sum f = f n a :=\n  Finsupp.sum_single_index hf\n\n"}
{"name":"Polynomial.sum_C_index","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\na : R\nβ : Type u_1\ninst✝ : AddCommMonoid β\nf : Nat → R → β\nh : Eq (f 0 0) 0\n⊢ Eq ((Polynomial.C a).sum f) (f 0 a)","decl":"@[simp]\ntheorem sum_C_index {a} {β} [AddCommMonoid β] {f : ℕ → R → β} (h : f 0 0 = 0) :\n    (C a).sum f = f 0 a :=\n  sum_monomial_index a f h\n\n-- the assumption `hf` is only necessary when the ring is trivial\n"}
{"name":"Polynomial.sum_X_index","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type u_1\ninst✝ : AddCommMonoid S\nf : Nat → R → S\nhf : Eq (f 1 0) 0\n⊢ Eq (Polynomial.X.sum f) (f 1 1)","decl":"@[simp]\ntheorem sum_X_index {S : Type*} [AddCommMonoid S] {f : ℕ → R → S} (hf : f 1 0 = 0) :\n    (X : R[X]).sum f = f 1 1 :=\n  sum_monomial_index 1 f hf\n\n"}
{"name":"Polynomial.sum_add_index","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type u_1\ninst✝ : AddCommMonoid S\np q : Polynomial R\nf : Nat → R → S\nhf : ∀ (i : Nat), Eq (f i 0) 0\nh_add : ∀ (a : Nat) (b₁ b₂ : R), Eq (f a (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (f a b₁) (f a b₂))\n⊢ Eq ((HAdd.hAdd p q).sum f) (HAdd.hAdd (p.sum f) (q.sum f))","decl":"theorem sum_add_index {S : Type*} [AddCommMonoid S] (p q : R[X]) (f : ℕ → R → S)\n    (hf : ∀ i, f i 0 = 0) (h_add : ∀ a b₁ b₂, f a (b₁ + b₂) = f a b₁ + f a b₂) :\n    (p + q).sum f = p.sum f + q.sum f := by\n  rw [show p + q = ⟨p.toFinsupp + q.toFinsupp⟩ from add_def p q]\n  exact Finsupp.sum_add_index (fun i _ ↦ hf i) (fun a _ b₁ b₂ ↦ h_add a b₁ b₂)\n\n"}
{"name":"Polynomial.sum_add'","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type u_1\ninst✝ : AddCommMonoid S\np : Polynomial R\nf g : Nat → R → S\n⊢ Eq (p.sum (HAdd.hAdd f g)) (HAdd.hAdd (p.sum f) (p.sum g))","decl":"theorem sum_add' {S : Type*} [AddCommMonoid S] (p : R[X]) (f g : ℕ → R → S) :\n    p.sum (f + g) = p.sum f + p.sum g := by simp [sum_def, Finset.sum_add_distrib]\n\n"}
{"name":"Polynomial.sum_add","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type u_1\ninst✝ : AddCommMonoid S\np : Polynomial R\nf g : Nat → R → S\n⊢ Eq (p.sum fun n x => HAdd.hAdd (f n x) (g n x)) (HAdd.hAdd (p.sum f) (p.sum g))","decl":"theorem sum_add {S : Type*} [AddCommMonoid S] (p : R[X]) (f g : ℕ → R → S) :\n    (p.sum fun n x => f n x + g n x) = p.sum f + p.sum g :=\n  sum_add' _ _ _\n\n"}
{"name":"Polynomial.sum_smul_index","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type u_1\ninst✝ : AddCommMonoid S\np : Polynomial R\nb : R\nf : Nat → R → S\nhf : ∀ (i : Nat), Eq (f i 0) 0\n⊢ Eq ((HSMul.hSMul b p).sum f) (p.sum fun n a => f n (HMul.hMul b a))","decl":"theorem sum_smul_index {S : Type*} [AddCommMonoid S] (p : R[X]) (b : R) (f : ℕ → R → S)\n    (hf : ∀ i, f i 0 = 0) : (b • p).sum f = p.sum fun n a => f n (b * a) :=\n  Finsupp.sum_smul_index hf\n\n"}
{"name":"Polynomial.sum_smul_index'","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝² : Semiring R\nS : Type u_1\nT : Type u_2\ninst✝¹ : DistribSMul T R\ninst✝ : AddCommMonoid S\np : Polynomial R\nb : T\nf : Nat → R → S\nhf : ∀ (i : Nat), Eq (f i 0) 0\n⊢ Eq ((HSMul.hSMul b p).sum f) (p.sum fun n a => f n (HSMul.hSMul b a))","decl":"theorem sum_smul_index' {S T : Type*} [DistribSMul T R] [AddCommMonoid S] (p : R[X]) (b : T)\n    (f : ℕ → R → S) (hf : ∀ i, f i 0 = 0) : (b • p).sum f = p.sum fun n a => f n (b • a) :=\n  Finsupp.sum_smul_index' hf\n\n"}
{"name":"Polynomial.smul_sum","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝² : Semiring R\nS : Type u_1\nT : Type u_2\ninst✝¹ : AddCommMonoid S\ninst✝ : DistribSMul T S\np : Polynomial R\nb : T\nf : Nat → R → S\n⊢ Eq (HSMul.hSMul b (p.sum f)) (p.sum fun n a => HSMul.hSMul b (f n a))","decl":"protected theorem smul_sum {S T : Type*} [AddCommMonoid S] [DistribSMul T S] (p : R[X]) (b : T)\n    (f : ℕ → R → S) : b • p.sum f = p.sum fun n a => b • f n a :=\n  Finsupp.smul_sum\n\n"}
{"name":"Polynomial.sum_monomial_eq","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (p.sum fun n a => (Polynomial.monomial n) a) p","decl":"@[simp]\ntheorem sum_monomial_eq : ∀ p : R[X], (p.sum fun n a => monomial n a) = p\n  | ⟨_p⟩ => (ofFinsupp_sum _ _).symm.trans (congr_arg _ <| Finsupp.sum_single _)\n\n"}
{"name":"Polynomial.sum_C_mul_X_pow_eq","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (p.sum fun n a => HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X n)) p","decl":"theorem sum_C_mul_X_pow_eq (p : R[X]) : (p.sum fun n a => C a * X ^ n) = p := by\n  simp_rw [C_mul_X_pow_eq_monomial, sum_monomial_eq]\n\n"}
{"name":"Polynomial.induction_on","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nM : Polynomial R → Prop\np : Polynomial R\nh_C : ∀ (a : R), M (Polynomial.C a)\nh_add : ∀ (p q : Polynomial R), M p → M q → M (HAdd.hAdd p q)\nh_monomial : ∀ (n : Nat) (a : R), M (HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X n)) → M (HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X (HAdd.hAdd n 1)))\n⊢ M p","decl":"@[elab_as_elim]\nprotected theorem induction_on {M : R[X] → Prop} (p : R[X]) (h_C : ∀ a, M (C a))\n    (h_add : ∀ p q, M p → M q → M (p + q))\n    (h_monomial : ∀ (n : ℕ) (a : R), M (C a * X ^ n) → M (C a * X ^ (n + 1))) : M p := by\n  have A : ∀ {n : ℕ} {a}, M (C a * X ^ n) := by\n    intro n a\n    induction n with\n    | zero => rw [pow_zero, mul_one]; exact h_C a\n    | succ n ih => exact h_monomial _ _ ih\n  have B : ∀ s : Finset ℕ, M (s.sum fun n : ℕ => C (p.coeff n) * X ^ n) := by\n    apply Finset.induction\n    · convert h_C 0\n      exact C_0.symm\n    · intro n s ns ih\n      rw [sum_insert ns]\n      exact h_add _ _ A ih\n  rw [← sum_C_mul_X_pow_eq p, Polynomial.sum]\n  exact B (support p)\n\n"}
{"name":"Polynomial.induction_on'","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nM : Polynomial R → Prop\np : Polynomial R\nh_add : ∀ (p q : Polynomial R), M p → M q → M (HAdd.hAdd p q)\nh_monomial : ∀ (n : Nat) (a : R), M ((Polynomial.monomial n) a)\n⊢ M p","decl":"/-- To prove something about polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials.\n-/\n@[elab_as_elim]\nprotected theorem induction_on' {M : R[X] → Prop} (p : R[X]) (h_add : ∀ p q, M p → M q → M (p + q))\n    (h_monomial : ∀ (n : ℕ) (a : R), M (monomial n a)) : M p :=\n  Polynomial.induction_on p (h_monomial 0) h_add fun n a _h =>\n    by rw [C_mul_X_pow_eq_monomial]; exact h_monomial _ _\n\n"}
{"name":"Polynomial.erase_def","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\nx✝ : Polynomial R\n⊢ Eq (Polynomial.erase n x✝) (Polynomial.support.match_1 (fun x => Polynomial R) x✝ fun p => { toFinsupp := Finsupp.erase n p })","decl":"/-- `erase p n` is the polynomial `p` in which the `X^n` term has been erased. -/\nirreducible_def erase (n : ℕ) : R[X] → R[X]\n  | ⟨p⟩ => ⟨p.erase n⟩\n\n"}
{"name":"Polynomial.toFinsupp_erase","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Eq (Polynomial.erase n p).toFinsupp (Finsupp.erase n p.toFinsupp)","decl":"@[simp]\ntheorem toFinsupp_erase (p : R[X]) (n : ℕ) : toFinsupp (p.erase n) = p.toFinsupp.erase n := by\n  rcases p with ⟨⟩\n  simp only [erase_def]\n\n"}
{"name":"Polynomial.ofFinsupp_erase","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : AddMonoidAlgebra R Nat\nn : Nat\n⊢ Eq { toFinsupp := Finsupp.erase n p } (Polynomial.erase n { toFinsupp := p })","decl":"@[simp]\ntheorem ofFinsupp_erase (p : R[ℕ]) (n : ℕ) :\n    (⟨p.erase n⟩ : R[X]) = (⟨p⟩ : R[X]).erase n := by\n  rcases p with ⟨⟩\n  simp only [erase_def]\n\n"}
{"name":"Polynomial.support_erase","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Eq (Polynomial.erase n p).support (p.support.erase n)","decl":"@[simp]\ntheorem support_erase (p : R[X]) (n : ℕ) : support (p.erase n) = (support p).erase n := by\n  rcases p with ⟨⟩\n  simp only [support, erase_def, Finsupp.support_erase]\n\n"}
{"name":"Polynomial.monomial_add_erase","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Eq (HAdd.hAdd ((Polynomial.monomial n) (p.coeff n)) (Polynomial.erase n p)) p","decl":"theorem monomial_add_erase (p : R[X]) (n : ℕ) : monomial n (coeff p n) + p.erase n = p :=\n  toFinsupp_injective <| by\n    rcases p with ⟨⟩\n    rw [toFinsupp_add, toFinsupp_monomial, toFinsupp_erase, coeff]\n    exact Finsupp.single_add_erase _ _\n\n"}
{"name":"Polynomial.coeff_erase","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn i : Nat\n⊢ Eq ((Polynomial.erase n p).coeff i) (ite (Eq i n) 0 (p.coeff i))","decl":"theorem coeff_erase (p : R[X]) (n i : ℕ) :\n    (p.erase n).coeff i = if i = n then 0 else p.coeff i := by\n  rcases p with ⟨⟩\n  simp only [erase_def, coeff]\n  -- Porting note: Was `convert rfl`.\n  exact ite_congr rfl (fun _ => rfl) (fun _ => rfl)\n\n"}
{"name":"Polynomial.erase_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\n⊢ Eq (Polynomial.erase n 0) 0","decl":"@[simp]\ntheorem erase_zero (n : ℕ) : (0 : R[X]).erase n = 0 :=\n  toFinsupp_injective <| by simp\n\n"}
{"name":"Polynomial.erase_monomial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\nn : Nat\na : R\n⊢ Eq (Polynomial.erase n ((Polynomial.monomial n) a)) 0","decl":"@[simp]\ntheorem erase_monomial {n : ℕ} {a : R} : erase n (monomial n a) = 0 :=\n  toFinsupp_injective <| by simp\n\n"}
{"name":"Polynomial.erase_same","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Eq ((Polynomial.erase n p).coeff n) 0","decl":"@[simp]\ntheorem erase_same (p : R[X]) (n : ℕ) : coeff (p.erase n) n = 0 := by simp [coeff_erase]\n\n"}
{"name":"Polynomial.erase_ne","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn i : Nat\nh : Ne i n\n⊢ Eq ((Polynomial.erase n p).coeff i) (p.coeff i)","decl":"@[simp]\ntheorem erase_ne (p : R[X]) (n i : ℕ) (h : i ≠ n) : coeff (p.erase n) i = coeff p i := by\n  simp [coeff_erase, h]\n\n"}
{"name":"Polynomial.coeff_update","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\na : R\n⊢ Eq (p.update n a).coeff (Function.update p.coeff n a)","decl":"theorem coeff_update (p : R[X]) (n : ℕ) (a : R) :\n    (p.update n a).coeff = Function.update p.coeff n a := by\n  ext\n  cases p\n  simp only [coeff, update, Function.update_apply, coe_update]\n\n"}
{"name":"Polynomial.coeff_update_apply","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\na : R\ni : Nat\n⊢ Eq ((p.update n a).coeff i) (ite (Eq i n) a (p.coeff i))","decl":"theorem coeff_update_apply (p : R[X]) (n : ℕ) (a : R) (i : ℕ) :\n    (p.update n a).coeff i = if i = n then a else p.coeff i := by\n  rw [coeff_update, Function.update_apply]\n\n"}
{"name":"Polynomial.coeff_update_same","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\na : R\n⊢ Eq ((p.update n a).coeff n) a","decl":"@[simp]\ntheorem coeff_update_same (p : R[X]) (n : ℕ) (a : R) : (p.update n a).coeff n = a := by\n  rw [p.coeff_update_apply, if_pos rfl]\n\n"}
{"name":"Polynomial.coeff_update_ne","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\na : R\ni : Nat\nh : Ne i n\n⊢ Eq ((p.update n a).coeff i) (p.coeff i)","decl":"theorem coeff_update_ne (p : R[X]) {n : ℕ} (a : R) {i : ℕ} (h : i ≠ n) :\n    (p.update n a).coeff i = p.coeff i := by rw [p.coeff_update_apply, if_neg h]\n\n"}
{"name":"Polynomial.update_zero_eq_erase","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Eq (p.update n 0) (Polynomial.erase n p)","decl":"@[simp]\ntheorem update_zero_eq_erase (p : R[X]) (n : ℕ) : p.update n 0 = p.erase n := by\n  ext\n  rw [coeff_update_apply, coeff_erase]\n\n"}
{"name":"Polynomial.support_update","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\np : Polynomial R\nn : Nat\na : R\ninst✝ : Decidable (Eq a 0)\n⊢ Eq (p.update n a).support (ite (Eq a 0) (p.support.erase n) (Insert.insert n p.support))","decl":"theorem support_update (p : R[X]) (n : ℕ) (a : R) [Decidable (a = 0)] :\n    support (p.update n a) = if a = 0 then p.support.erase n else insert n p.support := by\n  classical\n    cases p\n    simp only [support, update, Finsupp.support_update]\n    congr\n\n"}
{"name":"Polynomial.support_update_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\n⊢ Eq (p.update n 0).support (p.support.erase n)","decl":"theorem support_update_zero (p : R[X]) (n : ℕ) : support (p.update n 0) = p.support.erase n := by\n  rw [update_zero_eq_erase, support_erase]\n\n"}
{"name":"Polynomial.support_update_ne_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\na : R\nha : Ne a 0\n⊢ Eq (p.update n a).support (Insert.insert n p.support)","decl":"theorem support_update_ne_zero (p : R[X]) (n : ℕ) {a : R} (ha : a ≠ 0) :\n    support (p.update n a) = insert n p.support := by classical rw [support_update, if_neg ha]\n\n"}
{"name":"Polynomial.ofFinsupp_zsmul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\na : Int\nb : AddMonoidAlgebra R Nat\n⊢ Eq { toFinsupp := HSMul.hSMul a b } (HSMul.hSMul a { toFinsupp := b })","decl":"@[simp]\ntheorem ofFinsupp_zsmul (a : ℤ) (b) :\n    (⟨a • b⟩ : R[X]) = (a • ⟨b⟩ : R[X]) :=\n  rfl\n\n"}
{"name":"Polynomial.toFinsupp_zsmul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\na : Int\nb : Polynomial R\n⊢ Eq (HSMul.hSMul a b).toFinsupp (HSMul.hSMul a b.toFinsupp)","decl":"@[simp]\ntheorem toFinsupp_zsmul (a : ℤ) (b : R[X]) :\n    (a • b).toFinsupp = a • b.toFinsupp :=\n  rfl\n\n"}
{"name":"Polynomial.coeff_neg","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\nn : Nat\n⊢ Eq ((Neg.neg p).coeff n) (Neg.neg (p.coeff n))","decl":"@[simp]\ntheorem coeff_neg (p : R[X]) (n : ℕ) : coeff (-p) n = -coeff p n := by\n  rcases p with ⟨⟩\n  rw [← ofFinsupp_neg, coeff, coeff, Finsupp.neg_apply]\n\n"}
{"name":"Polynomial.coeff_sub","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np q : Polynomial R\nn : Nat\n⊢ Eq ((HSub.hSub p q).coeff n) (HSub.hSub (p.coeff n) (q.coeff n))","decl":"@[simp]\ntheorem coeff_sub (p q : R[X]) (n : ℕ) : coeff (p - q) n = coeff p n - coeff q n := by\n  rcases p with ⟨⟩\n  rcases q with ⟨⟩\n  rw [← ofFinsupp_sub, coeff, coeff, coeff, Finsupp.sub_apply]\n\n"}
{"name":"Polynomial.monomial_neg","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nn : Nat\na : R\n⊢ Eq ((Polynomial.monomial n) (Neg.neg a)) (Neg.neg ((Polynomial.monomial n) a))","decl":"@[simp]\ntheorem monomial_neg (n : ℕ) (a : R) : monomial n (-a) = -monomial n a := by\n  rw [eq_neg_iff_add_eq_zero, ← monomial_add, neg_add_cancel, monomial_zero_right]\n\n"}
{"name":"Polynomial.monomial_sub","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na b : R\ninst✝ : Ring R\nn : Nat\n⊢ Eq ((Polynomial.monomial n) (HSub.hSub a b)) (HSub.hSub ((Polynomial.monomial n) a) ((Polynomial.monomial n) b))","decl":"theorem monomial_sub (n : ℕ) : monomial n (a - b) = monomial n a - monomial n b := by\n  rw [sub_eq_add_neg, monomial_add, monomial_neg, sub_eq_add_neg]\n\n"}
{"name":"Polynomial.support_neg","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\np : Polynomial R\n⊢ Eq (Neg.neg p).support p.support","decl":"@[simp]\ntheorem support_neg {p : R[X]} : (-p).support = p.support := by\n  rcases p with ⟨⟩\n  rw [← ofFinsupp_neg, support, support, Finsupp.support_neg]\n\n"}
{"name":"Polynomial.C_eq_intCast","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Ring R\nn : Int\n⊢ Eq (Polynomial.C ↑n) ↑n","decl":"theorem C_eq_intCast (n : ℤ) : C (n : R) = n := by simp\n\n"}
{"name":"Polynomial.C_neg","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na : R\ninst✝ : Ring R\n⊢ Eq (Polynomial.C (Neg.neg a)) (Neg.neg (Polynomial.C a))","decl":"theorem C_neg : C (-a) = -C a :=\n  RingHom.map_neg C a\n\n"}
{"name":"Polynomial.C_sub","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\na b : R\ninst✝ : Ring R\n⊢ Eq (Polynomial.C (HSub.hSub a b)) (HSub.hSub (Polynomial.C a) (Polynomial.C b))","decl":"theorem C_sub : C (a - b) = C a - C b :=\n  RingHom.map_sub C a b\n\n"}
{"name":"Polynomial.nontrivial","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\n⊢ Nontrivial (Polynomial R)","decl":"instance nontrivial [Nontrivial R] : Nontrivial R[X] := by\n  have h : Nontrivial R[ℕ] := by infer_instance\n  rcases h.exists_pair_ne with ⟨x, y, hxy⟩\n  refine ⟨⟨⟨x⟩, ⟨y⟩, ?_⟩⟩\n  simp [hxy]\n\n"}
{"name":"Polynomial.X_ne_zero","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\n⊢ Ne Polynomial.X 0","decl":"@[simp]\ntheorem X_ne_zero [Nontrivial R] : (X : R[X]) ≠ 0 :=\n  mt (congr_arg fun p => coeff p 1) (by simp)\n\n"}
{"name":"Polynomial.nnqsmul_eq_C_mul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : DivisionSemiring R\nq : NNRat\nf : Polynomial R\n⊢ Eq (HSMul.hSMul q f) (HMul.hMul (Polynomial.C ↑q) f)","decl":"lemma nnqsmul_eq_C_mul (q : ℚ≥0) (f : R[X]) : q • f = Polynomial.C (q : R) * f := by\n  rw [← NNRat.smul_one_eq_cast, ← Polynomial.smul_C, C_1, smul_one_mul]\n\n"}
{"name":"Polynomial.qsmul_eq_C_mul","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : DivisionRing R\na : Rat\nf : Polynomial R\n⊢ Eq (HSMul.hSMul a f) (HMul.hMul (Polynomial.C ↑a) f)","decl":"theorem qsmul_eq_C_mul (a : ℚ) (f : R[X]) : a • f = Polynomial.C (a : R) * f := by\n  rw [← Rat.smul_one_eq_cast, ← Polynomial.smul_C, C_1, smul_one_mul]\n\n"}
{"name":"Polynomial.nontrivial_iff","module":"Mathlib.Algebra.Polynomial.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Iff (Nontrivial (Polynomial R)) (Nontrivial R)","decl":"@[simp]\ntheorem nontrivial_iff [Semiring R] : Nontrivial R[X] ↔ Nontrivial R :=\n  ⟨fun h =>\n    let ⟨_r, _s, hrs⟩ := @exists_pair_ne _ h\n    Nontrivial.of_polynomial_ne hrs,\n    fun h => @Polynomial.nontrivial _ _ h⟩\n\n"}
