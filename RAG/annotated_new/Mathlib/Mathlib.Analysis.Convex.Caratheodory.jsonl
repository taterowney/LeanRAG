{"name":"Caratheodory.mem_convexHull_erase","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"𝕜 : Type u_1\nE : Type u\ninst✝³ : LinearOrderedField 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : DecidableEq E\nt : Finset E\nh : Not (AffineIndependent 𝕜 Subtype.val)\nx : E\nm : Membership.mem ((convexHull 𝕜) ↑t) x\n⊢ Exists fun y => Membership.mem ((convexHull 𝕜) ↑(t.erase ↑y)) x","decl":"/-- If `x` is in the convex hull of some finset `t` whose elements are not affine-independent,\nthen it is in the convex hull of a strict subset of `t`. -/\ntheorem mem_convexHull_erase [DecidableEq E] {t : Finset E} (h : ¬AffineIndependent 𝕜 ((↑) : t → E))\n    {x : E} (m : x ∈ convexHull 𝕜 (↑t : Set E)) :\n    ∃ y : (↑t : Set E), x ∈ convexHull 𝕜 (↑(t.erase y) : Set E) := by\n  simp only [Finset.convexHull_eq, mem_setOf_eq] at m ⊢\n  obtain ⟨f, fpos, fsum, rfl⟩ := m\n  obtain ⟨g, gcombo, gsum, gpos⟩ := exists_nontrivial_relation_sum_zero_of_not_affine_ind h\n  replace gpos := exists_pos_of_sum_zero_of_exists_nonzero g gsum gpos\n  clear h\n  let s := {z ∈ t | 0 < g z}\n  obtain ⟨i₀, mem, w⟩ : ∃ i₀ ∈ s, ∀ i ∈ s, f i₀ / g i₀ ≤ f i / g i := by\n    apply s.exists_min_image fun z => f z / g z\n    obtain ⟨x, hx, hgx⟩ : ∃ x ∈ t, 0 < g x := gpos\n    exact ⟨x, mem_filter.mpr ⟨hx, hgx⟩⟩\n  have hg : 0 < g i₀ := by\n    rw [mem_filter] at mem\n    exact mem.2\n  have hi₀ : i₀ ∈ t := filter_subset _ _ mem\n  let k : E → 𝕜 := fun z => f z - f i₀ / g i₀ * g z\n  have hk : k i₀ = 0 := by field_simp [k, ne_of_gt hg]\n  have ksum : ∑ e ∈ t.erase i₀, k e = 1 := by\n    calc\n      ∑ e ∈ t.erase i₀, k e = ∑ e ∈ t, k e := by\n        conv_rhs => rw [← insert_erase hi₀, sum_insert (not_mem_erase i₀ t), hk, zero_add]\n      _ = ∑ e ∈ t, (f e - f i₀ / g i₀ * g e) := rfl\n      _ = 1 := by rw [sum_sub_distrib, fsum, ← mul_sum, gsum, mul_zero, sub_zero]\n  refine ⟨⟨i₀, hi₀⟩, k, ?_, by convert ksum, ?_⟩\n  · simp only [k, and_imp, sub_nonneg, mem_erase, Ne, Subtype.coe_mk]\n    intro e _ het\n    by_cases hes : e ∈ s\n    · have hge : 0 < g e := by\n        rw [mem_filter] at hes\n        exact hes.2\n      rw [← le_div_iff₀ hge]\n      exact w _ hes\n    · calc\n        _ ≤ 0 := by\n          apply mul_nonpos_of_nonneg_of_nonpos\n          · apply div_nonneg (fpos i₀ (mem_of_subset (filter_subset _ t) mem)) (le_of_lt hg)\n          · simpa only [s, mem_filter, het, true_and, not_lt] using hes\n        _ ≤ f e := fpos e het\n  · rw [Subtype.coe_mk, centerMass_eq_of_sum_1 _ id ksum]\n    calc\n      ∑ e ∈ t.erase i₀, k e • e = ∑ e ∈ t, k e • e := sum_erase _ (by rw [hk, zero_smul])\n      _ = ∑ e ∈ t, (f e - f i₀ / g i₀ * g e) • e := rfl\n      _ = t.centerMass f id := by\n        simp only [sub_smul, mul_smul, sum_sub_distrib, ← smul_sum, gcombo, smul_zero, sub_zero,\n          centerMass, fsum, inv_one, one_smul, id]\n\n"}
{"name":"Caratheodory.minCardFinsetOfMemConvexHull_subseteq","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"𝕜 : Type u_1\nE : Type u\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nx : E\nhx : Membership.mem ((convexHull 𝕜) s) x\n⊢ HasSubset.Subset (↑(Caratheodory.minCardFinsetOfMemConvexHull hx)) s","decl":"theorem minCardFinsetOfMemConvexHull_subseteq : ↑(minCardFinsetOfMemConvexHull hx) ⊆ s :=\n  (Function.argminOn_mem _ { t : Finset E | ↑t ⊆ s ∧ x ∈ convexHull 𝕜 (t : Set E) } _).1\n\n"}
{"name":"Caratheodory.mem_minCardFinsetOfMemConvexHull","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"𝕜 : Type u_1\nE : Type u\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nx : E\nhx : Membership.mem ((convexHull 𝕜) s) x\n⊢ Membership.mem ((convexHull 𝕜) ↑(Caratheodory.minCardFinsetOfMemConvexHull hx)) x","decl":"theorem mem_minCardFinsetOfMemConvexHull :\n    x ∈ convexHull 𝕜 (minCardFinsetOfMemConvexHull hx : Set E) :=\n  (Function.argminOn_mem _ { t : Finset E | ↑t ⊆ s ∧ x ∈ convexHull 𝕜 (t : Set E) } _).2\n\n"}
{"name":"Caratheodory.minCardFinsetOfMemConvexHull_nonempty","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"𝕜 : Type u_1\nE : Type u\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nx : E\nhx : Membership.mem ((convexHull 𝕜) s) x\n⊢ (Caratheodory.minCardFinsetOfMemConvexHull hx).Nonempty","decl":"theorem minCardFinsetOfMemConvexHull_nonempty : (minCardFinsetOfMemConvexHull hx).Nonempty := by\n  rw [← Finset.coe_nonempty, ← @convexHull_nonempty_iff 𝕜]\n  exact ⟨x, mem_minCardFinsetOfMemConvexHull hx⟩\n\n"}
{"name":"Caratheodory.minCardFinsetOfMemConvexHull_card_le_card","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"𝕜 : Type u_1\nE : Type u\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nx : E\nhx : Membership.mem ((convexHull 𝕜) s) x\nt : Finset E\nht₁ : HasSubset.Subset (↑t) s\nht₂ : Membership.mem ((convexHull 𝕜) ↑t) x\n⊢ LE.le (Caratheodory.minCardFinsetOfMemConvexHull hx).card t.card","decl":"theorem minCardFinsetOfMemConvexHull_card_le_card {t : Finset E} (ht₁ : ↑t ⊆ s)\n    (ht₂ : x ∈ convexHull 𝕜 (t : Set E)) : #(minCardFinsetOfMemConvexHull hx) ≤ #t :=\n  Function.argminOn_le _ _ (by exact ⟨ht₁, ht₂⟩)\n\n"}
{"name":"Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"𝕜 : Type u_1\nE : Type u\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nx : E\nhx : Membership.mem ((convexHull 𝕜) s) x\n⊢ AffineIndependent 𝕜 Subtype.val","decl":"theorem affineIndependent_minCardFinsetOfMemConvexHull :\n    AffineIndependent 𝕜 ((↑) : minCardFinsetOfMemConvexHull hx → E) := by\n  let k := #(minCardFinsetOfMemConvexHull hx) - 1\n  have hk : #(minCardFinsetOfMemConvexHull hx) = k + 1 :=\n    (Nat.succ_pred_eq_of_pos (Finset.card_pos.mpr (minCardFinsetOfMemConvexHull_nonempty hx))).symm\n  classical\n  by_contra h\n  obtain ⟨p, hp⟩ := mem_convexHull_erase h (mem_minCardFinsetOfMemConvexHull hx)\n  have contra := minCardFinsetOfMemConvexHull_card_le_card hx (Set.Subset.trans\n    (Finset.erase_subset (p : E) (minCardFinsetOfMemConvexHull hx))\n    (minCardFinsetOfMemConvexHull_subseteq hx)) hp\n  rw [← not_lt] at contra\n  apply contra\n  rw [card_erase_of_mem p.2, hk]\n  exact lt_add_one _\n\n"}
{"name":"convexHull_eq_union","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"𝕜 : Type u_1\nE : Type u\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\n⊢ Eq ((convexHull 𝕜) s) (Set.iUnion fun t => Set.iUnion fun x => Set.iUnion fun x => (convexHull 𝕜) ↑t)","decl":"/-- **Carathéodory's convexity theorem** -/\ntheorem convexHull_eq_union : convexHull 𝕜 s =\n    ⋃ (t : Finset E) (_ : ↑t ⊆ s) (_ : AffineIndependent 𝕜 ((↑) : t → E)), convexHull 𝕜 ↑t := by\n  apply Set.Subset.antisymm\n  · intro x hx\n    simp only [exists_prop, Set.mem_iUnion]\n    exact ⟨Caratheodory.minCardFinsetOfMemConvexHull hx,\n      Caratheodory.minCardFinsetOfMemConvexHull_subseteq hx,\n      Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull hx,\n      Caratheodory.mem_minCardFinsetOfMemConvexHull hx⟩\n  · iterate 3 convert Set.iUnion_subset _; intro\n    exact convexHull_mono ‹_›\n\n"}
{"name":"eq_pos_convex_span_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"𝕜 : Type u_1\nE : Type u\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nx : E\nhx : Membership.mem ((convexHull 𝕜) s) x\n⊢ Exists fun ι => Exists fun x_1 => Exists fun z => Exists fun w => And (HasSubset.Subset (Set.range z) s) (And (AffineIndependent 𝕜 z) (And (∀ (i : ι), LT.lt 0 (w i)) (And (Eq (Finset.univ.sum fun i => w i) 1) (Eq (Finset.univ.sum fun i => HSMul.hSMul (w i) (z i)) x))))","decl":"/-- A more explicit version of `convexHull_eq_union`. -/\ntheorem eq_pos_convex_span_of_mem_convexHull {x : E} (hx : x ∈ convexHull 𝕜 s) :\n    ∃ (ι : Sort (u + 1)) (_ : Fintype ι),\n      ∃ (z : ι → E) (w : ι → 𝕜), Set.range z ⊆ s ∧ AffineIndependent 𝕜 z ∧ (∀ i, 0 < w i) ∧\n        ∑ i, w i = 1 ∧ ∑ i, w i • z i = x := by\n  rw [convexHull_eq_union] at hx\n  simp only [exists_prop, Set.mem_iUnion] at hx\n  obtain ⟨t, ht₁, ht₂, ht₃⟩ := hx\n  simp only [t.convexHull_eq, exists_prop, Set.mem_setOf_eq] at ht₃\n  obtain ⟨w, hw₁, hw₂, hw₃⟩ := ht₃\n  let t' := {i ∈ t | w i ≠ 0}\n  refine ⟨t', t'.fintypeCoeSort, ((↑) : t' → E), w ∘ ((↑) : t' → E), ?_, ?_, ?_, ?_, ?_⟩\n  · rw [Subtype.range_coe_subtype]\n    exact Subset.trans (Finset.filter_subset _ t) ht₁\n  · exact ht₂.comp_embedding ⟨_, inclusion_injective (Finset.filter_subset (fun i => w i ≠ 0) t)⟩\n  · exact fun i =>\n      (hw₁ _ (Finset.mem_filter.mp i.2).1).lt_of_ne (Finset.mem_filter.mp i.property).2.symm\n  · erw [Finset.sum_attach, Finset.sum_filter_ne_zero, hw₂]\n  · change (∑ i ∈ t'.attach, (fun e => w e • e) ↑i) = x\n    rw [Finset.sum_attach (f := fun e => w e • e), Finset.sum_filter_of_ne]\n    · rw [t.centerMass_eq_of_sum_1 id hw₂] at hw₃\n      exact hw₃\n    · intro e _ hwe contra\n      apply hwe\n      rw [contra, zero_smul]\n"}
