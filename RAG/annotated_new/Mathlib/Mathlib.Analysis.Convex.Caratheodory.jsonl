{"name":"Caratheodory.mem_convexHull_erase","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"ğ•œ : Type u_1\nE : Type u\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : DecidableEq E\nt : Finset E\nh : Not (AffineIndependent ğ•œ Subtype.val)\nx : E\nm : Membership.mem ((convexHull ğ•œ) â†‘t) x\nâŠ¢ Exists fun y => Membership.mem ((convexHull ğ•œ) â†‘(t.erase â†‘y)) x","decl":"/-- If `x` is in the convex hull of some finset `t` whose elements are not affine-independent,\nthen it is in the convex hull of a strict subset of `t`. -/\ntheorem mem_convexHull_erase [DecidableEq E] {t : Finset E} (h : Â¬AffineIndependent ğ•œ ((â†‘) : t â†’ E))\n    {x : E} (m : x âˆˆ convexHull ğ•œ (â†‘t : Set E)) :\n    âˆƒ y : (â†‘t : Set E), x âˆˆ convexHull ğ•œ (â†‘(t.erase y) : Set E) := by\n  simp only [Finset.convexHull_eq, mem_setOf_eq] at m âŠ¢\n  obtain âŸ¨f, fpos, fsum, rflâŸ© := m\n  obtain âŸ¨g, gcombo, gsum, gposâŸ© := exists_nontrivial_relation_sum_zero_of_not_affine_ind h\n  replace gpos := exists_pos_of_sum_zero_of_exists_nonzero g gsum gpos\n  clear h\n  let s := {z âˆˆ t | 0 < g z}\n  obtain âŸ¨iâ‚€, mem, wâŸ© : âˆƒ iâ‚€ âˆˆ s, âˆ€ i âˆˆ s, f iâ‚€ / g iâ‚€ â‰¤ f i / g i := by\n    apply s.exists_min_image fun z => f z / g z\n    obtain âŸ¨x, hx, hgxâŸ© : âˆƒ x âˆˆ t, 0 < g x := gpos\n    exact âŸ¨x, mem_filter.mpr âŸ¨hx, hgxâŸ©âŸ©\n  have hg : 0 < g iâ‚€ := by\n    rw [mem_filter] at mem\n    exact mem.2\n  have hiâ‚€ : iâ‚€ âˆˆ t := filter_subset _ _ mem\n  let k : E â†’ ğ•œ := fun z => f z - f iâ‚€ / g iâ‚€ * g z\n  have hk : k iâ‚€ = 0 := by field_simp [k, ne_of_gt hg]\n  have ksum : âˆ‘ e âˆˆ t.erase iâ‚€, k e = 1 := by\n    calc\n      âˆ‘ e âˆˆ t.erase iâ‚€, k e = âˆ‘ e âˆˆ t, k e := by\n        conv_rhs => rw [â† insert_erase hiâ‚€, sum_insert (not_mem_erase iâ‚€ t), hk, zero_add]\n      _ = âˆ‘ e âˆˆ t, (f e - f iâ‚€ / g iâ‚€ * g e) := rfl\n      _ = 1 := by rw [sum_sub_distrib, fsum, â† mul_sum, gsum, mul_zero, sub_zero]\n  refine âŸ¨âŸ¨iâ‚€, hiâ‚€âŸ©, k, ?_, by convert ksum, ?_âŸ©\n  Â· simp only [k, and_imp, sub_nonneg, mem_erase, Ne, Subtype.coe_mk]\n    intro e _ het\n    by_cases hes : e âˆˆ s\n    Â· have hge : 0 < g e := by\n        rw [mem_filter] at hes\n        exact hes.2\n      rw [â† le_div_iffâ‚€ hge]\n      exact w _ hes\n    Â· calc\n        _ â‰¤ 0 := by\n          apply mul_nonpos_of_nonneg_of_nonpos\n          Â· apply div_nonneg (fpos iâ‚€ (mem_of_subset (filter_subset _ t) mem)) (le_of_lt hg)\n          Â· simpa only [s, mem_filter, het, true_and, not_lt] using hes\n        _ â‰¤ f e := fpos e het\n  Â· rw [Subtype.coe_mk, centerMass_eq_of_sum_1 _ id ksum]\n    calc\n      âˆ‘ e âˆˆ t.erase iâ‚€, k e â€¢ e = âˆ‘ e âˆˆ t, k e â€¢ e := sum_erase _ (by rw [hk, zero_smul])\n      _ = âˆ‘ e âˆˆ t, (f e - f iâ‚€ / g iâ‚€ * g e) â€¢ e := rfl\n      _ = t.centerMass f id := by\n        simp only [sub_smul, mul_smul, sum_sub_distrib, â† smul_sum, gcombo, smul_zero, sub_zero,\n          centerMass, fsum, inv_one, one_smul, id]\n\n"}
{"name":"Caratheodory.minCardFinsetOfMemConvexHull_subseteq","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"ğ•œ : Type u_1\nE : Type u\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nx : E\nhx : Membership.mem ((convexHull ğ•œ) s) x\nâŠ¢ HasSubset.Subset (â†‘(Caratheodory.minCardFinsetOfMemConvexHull hx)) s","decl":"theorem minCardFinsetOfMemConvexHull_subseteq : â†‘(minCardFinsetOfMemConvexHull hx) âŠ† s :=\n  (Function.argminOn_mem _ { t : Finset E | â†‘t âŠ† s âˆ§ x âˆˆ convexHull ğ•œ (t : Set E) } _).1\n\n"}
{"name":"Caratheodory.mem_minCardFinsetOfMemConvexHull","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"ğ•œ : Type u_1\nE : Type u\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nx : E\nhx : Membership.mem ((convexHull ğ•œ) s) x\nâŠ¢ Membership.mem ((convexHull ğ•œ) â†‘(Caratheodory.minCardFinsetOfMemConvexHull hx)) x","decl":"theorem mem_minCardFinsetOfMemConvexHull :\n    x âˆˆ convexHull ğ•œ (minCardFinsetOfMemConvexHull hx : Set E) :=\n  (Function.argminOn_mem _ { t : Finset E | â†‘t âŠ† s âˆ§ x âˆˆ convexHull ğ•œ (t : Set E) } _).2\n\n"}
{"name":"Caratheodory.minCardFinsetOfMemConvexHull_nonempty","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"ğ•œ : Type u_1\nE : Type u\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nx : E\nhx : Membership.mem ((convexHull ğ•œ) s) x\nâŠ¢ (Caratheodory.minCardFinsetOfMemConvexHull hx).Nonempty","decl":"theorem minCardFinsetOfMemConvexHull_nonempty : (minCardFinsetOfMemConvexHull hx).Nonempty := by\n  rw [â† Finset.coe_nonempty, â† @convexHull_nonempty_iff ğ•œ]\n  exact âŸ¨x, mem_minCardFinsetOfMemConvexHull hxâŸ©\n\n"}
{"name":"Caratheodory.minCardFinsetOfMemConvexHull_card_le_card","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"ğ•œ : Type u_1\nE : Type u\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nx : E\nhx : Membership.mem ((convexHull ğ•œ) s) x\nt : Finset E\nhtâ‚ : HasSubset.Subset (â†‘t) s\nhtâ‚‚ : Membership.mem ((convexHull ğ•œ) â†‘t) x\nâŠ¢ LE.le (Caratheodory.minCardFinsetOfMemConvexHull hx).card t.card","decl":"theorem minCardFinsetOfMemConvexHull_card_le_card {t : Finset E} (htâ‚ : â†‘t âŠ† s)\n    (htâ‚‚ : x âˆˆ convexHull ğ•œ (t : Set E)) : #(minCardFinsetOfMemConvexHull hx) â‰¤ #t :=\n  Function.argminOn_le _ _ (by exact âŸ¨htâ‚, htâ‚‚âŸ©)\n\n"}
{"name":"Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"ğ•œ : Type u_1\nE : Type u\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nx : E\nhx : Membership.mem ((convexHull ğ•œ) s) x\nâŠ¢ AffineIndependent ğ•œ Subtype.val","decl":"theorem affineIndependent_minCardFinsetOfMemConvexHull :\n    AffineIndependent ğ•œ ((â†‘) : minCardFinsetOfMemConvexHull hx â†’ E) := by\n  let k := #(minCardFinsetOfMemConvexHull hx) - 1\n  have hk : #(minCardFinsetOfMemConvexHull hx) = k + 1 :=\n    (Nat.succ_pred_eq_of_pos (Finset.card_pos.mpr (minCardFinsetOfMemConvexHull_nonempty hx))).symm\n  classical\n  by_contra h\n  obtain âŸ¨p, hpâŸ© := mem_convexHull_erase h (mem_minCardFinsetOfMemConvexHull hx)\n  have contra := minCardFinsetOfMemConvexHull_card_le_card hx (Set.Subset.trans\n    (Finset.erase_subset (p : E) (minCardFinsetOfMemConvexHull hx))\n    (minCardFinsetOfMemConvexHull_subseteq hx)) hp\n  rw [â† not_lt] at contra\n  apply contra\n  rw [card_erase_of_mem p.2, hk]\n  exact lt_add_one _\n\n"}
{"name":"convexHull_eq_union","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"ğ•œ : Type u_1\nE : Type u\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nâŠ¢ Eq ((convexHull ğ•œ) s) (Set.iUnion fun t => Set.iUnion fun x => Set.iUnion fun x => (convexHull ğ•œ) â†‘t)","decl":"/-- **CarathÃ©odory's convexity theorem** -/\ntheorem convexHull_eq_union : convexHull ğ•œ s =\n    â‹ƒ (t : Finset E) (_ : â†‘t âŠ† s) (_ : AffineIndependent ğ•œ ((â†‘) : t â†’ E)), convexHull ğ•œ â†‘t := by\n  apply Set.Subset.antisymm\n  Â· intro x hx\n    simp only [exists_prop, Set.mem_iUnion]\n    exact âŸ¨Caratheodory.minCardFinsetOfMemConvexHull hx,\n      Caratheodory.minCardFinsetOfMemConvexHull_subseteq hx,\n      Caratheodory.affineIndependent_minCardFinsetOfMemConvexHull hx,\n      Caratheodory.mem_minCardFinsetOfMemConvexHull hxâŸ©\n  Â· iterate 3 convert Set.iUnion_subset _; intro\n    exact convexHull_mono â€¹_â€º\n\n"}
{"name":"eq_pos_convex_span_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Caratheodory","initialProofState":"ğ•œ : Type u_1\nE : Type u\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nx : E\nhx : Membership.mem ((convexHull ğ•œ) s) x\nâŠ¢ Exists fun Î¹ => Exists fun x_1 => Exists fun z => Exists fun w => And (HasSubset.Subset (Set.range z) s) (And (AffineIndependent ğ•œ z) (And (âˆ€ (i : Î¹), LT.lt 0 (w i)) (And (Eq (Finset.univ.sum fun i => w i) 1) (Eq (Finset.univ.sum fun i => HSMul.hSMul (w i) (z i)) x))))","decl":"/-- A more explicit version of `convexHull_eq_union`. -/\ntheorem eq_pos_convex_span_of_mem_convexHull {x : E} (hx : x âˆˆ convexHull ğ•œ s) :\n    âˆƒ (Î¹ : Sort (u + 1)) (_ : Fintype Î¹),\n      âˆƒ (z : Î¹ â†’ E) (w : Î¹ â†’ ğ•œ), Set.range z âŠ† s âˆ§ AffineIndependent ğ•œ z âˆ§ (âˆ€ i, 0 < w i) âˆ§\n        âˆ‘ i, w i = 1 âˆ§ âˆ‘ i, w i â€¢ z i = x := by\n  rw [convexHull_eq_union] at hx\n  simp only [exists_prop, Set.mem_iUnion] at hx\n  obtain âŸ¨t, htâ‚, htâ‚‚, htâ‚ƒâŸ© := hx\n  simp only [t.convexHull_eq, exists_prop, Set.mem_setOf_eq] at htâ‚ƒ\n  obtain âŸ¨w, hwâ‚, hwâ‚‚, hwâ‚ƒâŸ© := htâ‚ƒ\n  let t' := {i âˆˆ t | w i â‰  0}\n  refine âŸ¨t', t'.fintypeCoeSort, ((â†‘) : t' â†’ E), w âˆ˜ ((â†‘) : t' â†’ E), ?_, ?_, ?_, ?_, ?_âŸ©\n  Â· rw [Subtype.range_coe_subtype]\n    exact Subset.trans (Finset.filter_subset _ t) htâ‚\n  Â· exact htâ‚‚.comp_embedding âŸ¨_, inclusion_injective (Finset.filter_subset (fun i => w i â‰  0) t)âŸ©\n  Â· exact fun i =>\n      (hwâ‚ _ (Finset.mem_filter.mp i.2).1).lt_of_ne (Finset.mem_filter.mp i.property).2.symm\n  Â· erw [Finset.sum_attach, Finset.sum_filter_ne_zero, hwâ‚‚]\n  Â· change (âˆ‘ i âˆˆ t'.attach, (fun e => w e â€¢ e) â†‘i) = x\n    rw [Finset.sum_attach (f := fun e => w e â€¢ e), Finset.sum_filter_of_ne]\n    Â· rw [t.centerMass_eq_of_sum_1 id hwâ‚‚] at hwâ‚ƒ\n      exact hwâ‚ƒ\n    Â· intro e _ hwe contra\n      apply hwe\n      rw [contra, zero_smul]\n"}
