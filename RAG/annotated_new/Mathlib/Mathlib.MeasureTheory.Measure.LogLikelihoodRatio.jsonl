{"name":"MeasureTheory.llr_def","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.llr μ ν) fun x => Real.log (μ.rnDeriv ν x).toReal","decl":"lemma llr_def (μ ν : Measure α) : llr μ ν = fun x ↦ log (μ.rnDeriv ν x).toReal := rfl\n\n"}
{"name":"MeasureTheory.exp_llr","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ (MeasureTheory.ae ν).EventuallyEq (fun x => Real.exp (MeasureTheory.llr μ ν x)) fun x => ite (Eq (μ.rnDeriv ν x) 0) 1 (μ.rnDeriv ν x).toReal","decl":"lemma exp_llr (μ ν : Measure α) [SigmaFinite μ] :\n    (fun x ↦ exp (llr μ ν x))\n      =ᵐ[ν] fun x ↦ if μ.rnDeriv ν x = 0 then 1 else (μ.rnDeriv ν x).toReal := by\n  filter_upwards [Measure.rnDeriv_lt_top μ ν] with x hx\n  by_cases h_zero : μ.rnDeriv ν x = 0\n  · simp only [llr, h_zero, ENNReal.zero_toReal, log_zero, exp_zero, ite_true]\n  · rw [llr, exp_log, if_neg h_zero]\n    exact ENNReal.toReal_pos h_zero hx.ne\n\n"}
{"name":"MeasureTheory.exp_llr_of_ac","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : μ.HaveLebesgueDecomposition ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun x => Real.exp (MeasureTheory.llr μ ν x)) fun x => (μ.rnDeriv ν x).toReal","decl":"lemma exp_llr_of_ac (μ ν : Measure α) [SigmaFinite μ] [Measure.HaveLebesgueDecomposition μ ν]\n    (hμν : μ ≪ ν) :\n    (fun x ↦ exp (llr μ ν x)) =ᵐ[μ] fun x ↦ (μ.rnDeriv ν x).toReal := by\n  filter_upwards [hμν.ae_le (exp_llr μ ν), Measure.rnDeriv_pos hμν] with x hx_eq hx_pos\n  rw [hx_eq, if_neg hx_pos.ne']\n\n"}
{"name":"MeasureTheory.exp_llr_of_ac'","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : ν.AbsolutelyContinuous μ\n⊢ (MeasureTheory.ae ν).EventuallyEq (fun x => Real.exp (MeasureTheory.llr μ ν x)) fun x => (μ.rnDeriv ν x).toReal","decl":"lemma exp_llr_of_ac' (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν] (hμν : ν ≪ μ) :\n    (fun x ↦ exp (llr μ ν x)) =ᵐ[ν] fun x ↦ (μ.rnDeriv ν x).toReal := by\n  filter_upwards [exp_llr μ ν, Measure.rnDeriv_pos' hμν] with x hx hx_pos\n  rwa [if_neg hx_pos.ne'] at hx\n\n"}
{"name":"MeasureTheory.neg_llr","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ (MeasureTheory.ae μ).EventuallyEq (Neg.neg (MeasureTheory.llr μ ν)) (MeasureTheory.llr ν μ)","decl":"lemma neg_llr [SigmaFinite μ] [SigmaFinite ν] (hμν : μ ≪ ν) :\n    - llr μ ν =ᵐ[μ] llr ν μ := by\n  filter_upwards [Measure.inv_rnDeriv hμν] with x hx\n  rw [Pi.neg_apply, llr, llr, ← log_inv, ← ENNReal.toReal_inv]\n  congr\n\n"}
{"name":"MeasureTheory.exp_neg_llr","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun x => Real.exp (Neg.neg (MeasureTheory.llr μ ν x))) fun x => (ν.rnDeriv μ x).toReal","decl":"lemma exp_neg_llr [SigmaFinite μ] [SigmaFinite ν] (hμν : μ ≪ ν) :\n    (fun x ↦ exp (- llr μ ν x)) =ᵐ[μ] fun x ↦ (ν.rnDeriv μ x).toReal := by\n  filter_upwards [neg_llr hμν, exp_llr_of_ac' ν μ hμν] with x hx hx_exp_log\n  rw [Pi.neg_apply] at hx\n  rw [hx, hx_exp_log]\n\n"}
{"name":"MeasureTheory.exp_neg_llr'","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : ν.AbsolutelyContinuous μ\n⊢ (MeasureTheory.ae ν).EventuallyEq (fun x => Real.exp (Neg.neg (MeasureTheory.llr μ ν x))) fun x => (ν.rnDeriv μ x).toReal","decl":"lemma exp_neg_llr' [SigmaFinite μ] [SigmaFinite ν] (hμν : ν ≪ μ) :\n    (fun x ↦ exp (- llr μ ν x)) =ᵐ[ν] fun x ↦ (ν.rnDeriv μ x).toReal := by\n  filter_upwards [neg_llr hμν, exp_llr_of_ac ν μ hμν] with x hx hx_exp_log\n  rw [Pi.neg_apply, neg_eq_iff_eq_neg] at hx\n  rw [← hx, hx_exp_log]\n\n"}
{"name":"MeasureTheory.measurable_llr","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Measurable (MeasureTheory.llr μ ν)","decl":"@[measurability]\nlemma measurable_llr (μ ν : Measure α) : Measurable (llr μ ν) :=\n  (Measure.measurable_rnDeriv μ ν).ennreal_toReal.log\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_llr","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ MeasureTheory.StronglyMeasurable (MeasureTheory.llr μ ν)","decl":"@[measurability]\nlemma stronglyMeasurable_llr (μ ν : Measure α) : StronglyMeasurable (llr μ ν) :=\n  (measurable_llr μ ν).stronglyMeasurable\n\n"}
{"name":"MeasureTheory.llr_smul_left","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : μ.HaveLebesgueDecomposition ν\nhμν : μ.AbsolutelyContinuous ν\nc : ENNReal\nhc : Ne c 0\nhc_ne_top : Ne c Top.top\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.llr (HSMul.hSMul c μ) ν) fun x => HAdd.hAdd (MeasureTheory.llr μ ν x) (Real.log c.toReal)","decl":"lemma llr_smul_left [IsFiniteMeasure μ] [Measure.HaveLebesgueDecomposition μ ν]\n    (hμν : μ ≪ ν) (c : ℝ≥0∞) (hc : c ≠ 0) (hc_ne_top : c ≠ ∞) :\n    llr (c • μ) ν =ᵐ[μ] fun x ↦ llr μ ν x + log c.toReal := by\n  simp only [llr, llr_def]\n  have h := Measure.rnDeriv_smul_left_of_ne_top μ ν hc_ne_top\n  filter_upwards [hμν.ae_le h, Measure.rnDeriv_pos hμν, hμν.ae_le (Measure.rnDeriv_lt_top μ ν)]\n    with x hx_eq hx_pos hx_ne_top\n  rw [hx_eq]\n  simp only [Pi.smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rw [log_mul]\n  rotate_left\n  · rw [ENNReal.toReal_ne_zero]\n    simp [hc, hc_ne_top]\n  · rw [ENNReal.toReal_ne_zero]\n    simp [hx_pos.ne', hx_ne_top.ne]\n  ring\n\n"}
{"name":"MeasureTheory.llr_smul_right","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : μ.HaveLebesgueDecomposition ν\nhμν : μ.AbsolutelyContinuous ν\nc : ENNReal\nhc : Ne c 0\nhc_ne_top : Ne c Top.top\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.llr μ (HSMul.hSMul c ν)) fun x => HSub.hSub (MeasureTheory.llr μ ν x) (Real.log c.toReal)","decl":"lemma llr_smul_right [IsFiniteMeasure μ] [Measure.HaveLebesgueDecomposition μ ν]\n    (hμν : μ ≪ ν) (c : ℝ≥0∞) (hc : c ≠ 0) (hc_ne_top : c ≠ ∞) :\n    llr μ (c • ν) =ᵐ[μ] fun x ↦ llr μ ν x - log c.toReal := by\n  simp only [llr, llr_def]\n  have h := Measure.rnDeriv_smul_right_of_ne_top μ ν hc hc_ne_top\n  filter_upwards [hμν.ae_le h, Measure.rnDeriv_pos hμν, hμν.ae_le (Measure.rnDeriv_lt_top μ ν)]\n    with x hx_eq hx_pos hx_ne_top\n  rw [hx_eq]\n  simp only [Pi.smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rw [log_mul]\n  rotate_left\n  · rw [ENNReal.toReal_ne_zero]\n    simp [hc, hc_ne_top]\n  · rw [ENNReal.toReal_ne_zero]\n    simp [hx_pos.ne', hx_ne_top.ne]\n  rw [ENNReal.toReal_inv, log_inv]\n  ring\n\n"}
{"name":"MeasureTheory.llr_tilted_left","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : α → Real\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\nhf : MeasureTheory.Integrable (fun x => Real.exp (f x)) μ\nhfν : AEMeasurable f ν\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.llr (μ.tilted f) ν) fun x => HAdd.hAdd (HSub.hSub (f x) (Real.log (MeasureTheory.integral μ fun z => Real.exp (f z)))) (MeasureTheory.llr μ ν x)","decl":"lemma llr_tilted_left [SigmaFinite μ] [SigmaFinite ν] (hμν : μ ≪ ν)\n    (hf : Integrable (fun x ↦ exp (f x)) μ) (hfν : AEMeasurable f ν) :\n    (llr (μ.tilted f) ν) =ᵐ[μ] fun x ↦ f x - log (∫ z, exp (f z) ∂μ) + llr μ ν x := by\n  cases eq_zero_or_neZero μ with\n  | inl hμ =>\n    simp only [hμ, ae_zero, Filter.EventuallyEq]; exact Filter.eventually_bot\n  | inr h0 =>\n    filter_upwards [hμν.ae_le (toReal_rnDeriv_tilted_left μ hfν), Measure.rnDeriv_pos hμν,\n      hμν.ae_le (Measure.rnDeriv_lt_top μ ν)] with x hx hx_pos hx_lt_top\n    rw [llr, hx, log_mul, div_eq_mul_inv, log_mul (exp_pos _).ne', log_exp, log_inv, llr,\n      ← sub_eq_add_neg]\n    · simp only [ne_eq, inv_eq_zero]\n      exact (integral_exp_pos hf).ne'\n    · simp only [ne_eq, div_eq_zero_iff]\n      push_neg\n      exact ⟨(exp_pos _).ne', (integral_exp_pos hf).ne'⟩\n    · simp [ENNReal.toReal_eq_zero_iff, hx_lt_top.ne, hx_pos.ne']\n\n"}
{"name":"MeasureTheory.integrable_llr_tilted_left","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : α → Real\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\nhf : MeasureTheory.Integrable f μ\nh_int : MeasureTheory.Integrable (MeasureTheory.llr μ ν) μ\nhfμ : MeasureTheory.Integrable (fun x => Real.exp (f x)) μ\nhfν : AEMeasurable f ν\n⊢ MeasureTheory.Integrable (MeasureTheory.llr (μ.tilted f) ν) μ","decl":"lemma integrable_llr_tilted_left [IsFiniteMeasure μ] [SigmaFinite ν]\n    (hμν : μ ≪ ν) (hf : Integrable f μ) (h_int : Integrable (llr μ ν) μ)\n    (hfμ : Integrable (fun x ↦ exp (f x)) μ) (hfν : AEMeasurable f ν) :\n    Integrable (llr (μ.tilted f) ν) μ := by\n  rw [integrable_congr (llr_tilted_left hμν hfμ hfν)]\n  exact Integrable.add (hf.sub (integrable_const _)) h_int\n\n"}
{"name":"MeasureTheory.integral_llr_tilted_left","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : α → Real\ninst✝¹ : MeasureTheory.IsProbabilityMeasure μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\nhf : MeasureTheory.Integrable f μ\nh_int : MeasureTheory.Integrable (MeasureTheory.llr μ ν) μ\nhfμ : MeasureTheory.Integrable (fun x => Real.exp (f x)) μ\nhfν : AEMeasurable f ν\n⊢ Eq (MeasureTheory.integral μ fun x => MeasureTheory.llr (μ.tilted f) ν x) (HSub.hSub (HAdd.hAdd (MeasureTheory.integral μ fun x => MeasureTheory.llr μ ν x) (MeasureTheory.integral μ fun x => f x)) (Real.log (MeasureTheory.integral μ fun x => Real.exp (f x))))","decl":"lemma integral_llr_tilted_left [IsProbabilityMeasure μ] [SigmaFinite ν]\n    (hμν : μ ≪ ν) (hf : Integrable f μ) (h_int : Integrable (llr μ ν) μ)\n    (hfμ : Integrable (fun x ↦ exp (f x)) μ) (hfν : AEMeasurable f ν) :\n    ∫ x, llr (μ.tilted f) ν x ∂μ = ∫ x, llr μ ν x ∂μ + ∫ x, f x ∂μ - log (∫ x, exp (f x) ∂μ) := by\n  calc ∫ x, llr (μ.tilted f) ν x ∂μ\n    = ∫ x, f x - log (∫ x, exp (f x) ∂μ) + llr μ ν x ∂μ :=\n        integral_congr_ae (llr_tilted_left hμν hfμ hfν)\n  _ = ∫ x, f x ∂μ - log (∫ x, exp (f x) ∂μ) + ∫ x, llr μ ν x ∂μ := by\n        rw [integral_add ?_ h_int]\n        swap; · exact hf.sub (integrable_const _)\n        rw [integral_sub hf (integrable_const _)]\n        simp only [integral_const, measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n  _ = ∫ x, llr μ ν x ∂μ + ∫ x, f x ∂μ - log (∫ x, exp (f x) ∂μ) := by abel\n\n"}
{"name":"MeasureTheory.llr_tilted_right","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : α → Real\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\nhf : MeasureTheory.Integrable (fun x => Real.exp (f x)) ν\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.llr μ (ν.tilted f)) fun x => HAdd.hAdd (HAdd.hAdd (Neg.neg (f x)) (Real.log (MeasureTheory.integral ν fun z => Real.exp (f z)))) (MeasureTheory.llr μ ν x)","decl":"lemma llr_tilted_right [SigmaFinite μ] [SigmaFinite ν]\n    (hμν : μ ≪ ν) (hf : Integrable (fun x ↦ exp (f x)) ν) :\n    (llr μ (ν.tilted f)) =ᵐ[μ] fun x ↦ - f x + log (∫ z, exp (f z) ∂ν) + llr μ ν x := by\n  cases eq_zero_or_neZero ν with\n  | inl h =>\n    have hμ : μ = 0 := by ext s _; exact hμν (by simp [h])\n    simp only [hμ, ae_zero, Filter.EventuallyEq]; exact Filter.eventually_bot\n  | inr h0 =>\n    filter_upwards [hμν.ae_le (toReal_rnDeriv_tilted_right μ ν hf), Measure.rnDeriv_pos hμν,\n      hμν.ae_le (Measure.rnDeriv_lt_top μ ν)] with x hx hx_pos hx_lt_top\n    rw [llr, hx, log_mul, log_mul (exp_pos _).ne', log_exp, llr]\n    · exact (integral_exp_pos hf).ne'\n    · refine (mul_pos (exp_pos _) (integral_exp_pos hf)).ne'\n    · simp [ENNReal.toReal_eq_zero_iff, hx_lt_top.ne, hx_pos.ne']\n\n"}
{"name":"MeasureTheory.integrable_llr_tilted_right","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : α → Real\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\nhfμ : MeasureTheory.Integrable f μ\nh_int : MeasureTheory.Integrable (MeasureTheory.llr μ ν) μ\nhfν : MeasureTheory.Integrable (fun x => Real.exp (f x)) ν\n⊢ MeasureTheory.Integrable (MeasureTheory.llr μ (ν.tilted f)) μ","decl":"lemma integrable_llr_tilted_right [IsFiniteMeasure μ] [SigmaFinite ν]\n    (hμν : μ ≪ ν) (hfμ : Integrable f μ)\n    (h_int : Integrable (llr μ ν) μ) (hfν : Integrable (fun x ↦ exp (f x)) ν) :\n    Integrable (llr μ (ν.tilted f)) μ := by\n  rw [integrable_congr (llr_tilted_right hμν hfν)]\n  exact Integrable.add (hfμ.neg.add (integrable_const _)) h_int\n\n"}
{"name":"MeasureTheory.integral_llr_tilted_right","module":"Mathlib.MeasureTheory.Measure.LogLikelihoodRatio","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : α → Real\ninst✝¹ : MeasureTheory.IsProbabilityMeasure μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhμν : μ.AbsolutelyContinuous ν\nhfμ : MeasureTheory.Integrable f μ\nhfν : MeasureTheory.Integrable (fun x => Real.exp (f x)) ν\nh_int : MeasureTheory.Integrable (MeasureTheory.llr μ ν) μ\n⊢ Eq (MeasureTheory.integral μ fun x => MeasureTheory.llr μ (ν.tilted f) x) (HAdd.hAdd (HSub.hSub (MeasureTheory.integral μ fun x => MeasureTheory.llr μ ν x) (MeasureTheory.integral μ fun x => f x)) (Real.log (MeasureTheory.integral ν fun x => Real.exp (f x))))","decl":"lemma integral_llr_tilted_right [IsProbabilityMeasure μ] [SigmaFinite ν]\n    (hμν : μ ≪ ν) (hfμ : Integrable f μ) (hfν : Integrable (fun x ↦ exp (f x)) ν)\n    (h_int : Integrable (llr μ ν) μ) :\n    ∫ x, llr μ (ν.tilted f) x ∂μ = ∫ x, llr μ ν x ∂μ - ∫ x, f x ∂μ + log (∫ x, exp (f x) ∂ν) := by\n  calc ∫ x, llr μ (ν.tilted f) x ∂μ\n    = ∫ x, - f x + log (∫ x, exp (f x) ∂ν) + llr μ ν x ∂μ :=\n        integral_congr_ae (llr_tilted_right hμν hfν)\n  _ = - ∫ x, f x ∂μ + log (∫ x, exp (f x) ∂ν) + ∫ x, llr μ ν x ∂μ := by\n        rw [← integral_neg, integral_add ?_ h_int]\n        swap; · exact hfμ.neg.add (integrable_const _)\n        rw [integral_add ?_ (integrable_const _)]\n        swap; · exact hfμ.neg\n        simp only [integral_const, measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n  _ = ∫ x, llr μ ν x ∂μ - ∫ x, f x ∂μ + log (∫ x, exp (f x) ∂ν) := by abel\n\n"}
