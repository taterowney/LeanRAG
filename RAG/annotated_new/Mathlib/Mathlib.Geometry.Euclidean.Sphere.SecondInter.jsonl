{"name":"EuclideanGeometry.Sphere.secondInter_dist","module":"Mathlib.Geometry.Euclidean.Sphere.SecondInter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np : P\nv : V\n⊢ Eq (Dist.dist (s.secondInter p v) s.center) (Dist.dist p s.center)","decl":"/-- The distance between `secondInter` and the center equals the distance between the original\npoint and the center. -/\n@[simp]\ntheorem Sphere.secondInter_dist (s : Sphere P) (p : P) (v : V) :\n    dist (s.secondInter p v) s.center = dist p s.center := by\n  rw [Sphere.secondInter]\n  by_cases hv : v = 0; · simp [hv]\n  rw [dist_smul_vadd_eq_dist _ _ hv]\n  exact Or.inr rfl\n\n"}
{"name":"EuclideanGeometry.Sphere.secondInter_mem","module":"Mathlib.Geometry.Euclidean.Sphere.SecondInter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np : P\nv : V\n⊢ Iff (Membership.mem s (s.secondInter p v)) (Membership.mem s p)","decl":"/-- The point given by `secondInter` lies on the sphere. -/\n@[simp]\ntheorem Sphere.secondInter_mem {s : Sphere P} {p : P} (v : V) : s.secondInter p v ∈ s ↔ p ∈ s := by\n  simp_rw [mem_sphere, Sphere.secondInter_dist]\n\n"}
{"name":"EuclideanGeometry.Sphere.secondInter_zero","module":"Mathlib.Geometry.Euclidean.Sphere.SecondInter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np : P\n⊢ Eq (s.secondInter p 0) p","decl":"/-- If the vector is zero, `secondInter` gives the original point. -/\n@[simp]\ntheorem Sphere.secondInter_zero (s : Sphere P) (p : P) : s.secondInter p (0 : V) = p := by\n  simp [Sphere.secondInter]\n\n"}
{"name":"EuclideanGeometry.Sphere.secondInter_eq_self_iff","module":"Mathlib.Geometry.Euclidean.Sphere.SecondInter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np : P\nv : V\n⊢ Iff (Eq (s.secondInter p v) p) (Eq (Inner.inner v (VSub.vsub p s.center)) 0)","decl":"/-- The point given by `secondInter` equals the original point if and only if the line is\northogonal to the radius vector. -/\ntheorem Sphere.secondInter_eq_self_iff {s : Sphere P} {p : P} {v : V} :\n    s.secondInter p v = p ↔ ⟪v, p -ᵥ s.center⟫ = 0 := by\n  refine ⟨fun hp => ?_, fun hp => ?_⟩\n  · by_cases hv : v = 0\n    · simp [hv]\n    rwa [Sphere.secondInter, eq_comm, eq_vadd_iff_vsub_eq, vsub_self, eq_comm, smul_eq_zero,\n      or_iff_left hv, div_eq_zero_iff, inner_self_eq_zero, or_iff_left hv, mul_eq_zero,\n      or_iff_right (by norm_num : (-2 : ℝ) ≠ 0)] at hp\n  · rw [Sphere.secondInter, hp, mul_zero, zero_div, zero_smul, zero_vadd]\n\n"}
{"name":"EuclideanGeometry.Sphere.eq_or_eq_secondInter_of_mem_mk'_span_singleton_iff_mem","module":"Mathlib.Geometry.Euclidean.Sphere.SecondInter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np : P\nhp : Membership.mem s p\nv : V\np' : P\nhp' : Membership.mem (AffineSubspace.mk' p (Submodule.span Real (Singleton.singleton v))) p'\n⊢ Iff (Or (Eq p' p) (Eq p' (s.secondInter p v))) (Membership.mem s p')","decl":"/-- A point on a line through a point on a sphere equals that point or `secondInter`. -/\ntheorem Sphere.eq_or_eq_secondInter_of_mem_mk'_span_singleton_iff_mem {s : Sphere P} {p : P}\n    (hp : p ∈ s) {v : V} {p' : P} (hp' : p' ∈ AffineSubspace.mk' p (ℝ ∙ v)) :\n    p' = p ∨ p' = s.secondInter p v ↔ p' ∈ s := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rcases h with (h | h)\n    · rwa [h]\n    · rwa [h, Sphere.secondInter_mem]\n  · rw [AffineSubspace.mem_mk'_iff_vsub_mem, Submodule.mem_span_singleton] at hp'\n    rcases hp' with ⟨r, hr⟩\n    rw [eq_comm, ← eq_vadd_iff_vsub_eq] at hr\n    subst hr\n    by_cases hv : v = 0\n    · simp [hv]\n    rw [Sphere.secondInter]\n    rw [mem_sphere] at h hp\n    rw [← hp, dist_smul_vadd_eq_dist _ _ hv] at h\n    rcases h with (h | h) <;> simp [h]\n\n"}
{"name":"EuclideanGeometry.Sphere.secondInter_smul","module":"Mathlib.Geometry.Euclidean.Sphere.SecondInter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np : P\nv : V\nr : Real\nhr : Ne r 0\n⊢ Eq (s.secondInter p (HSMul.hSMul r v)) (s.secondInter p v)","decl":"/-- `secondInter` is unchanged by multiplying the vector by a nonzero real. -/\n@[simp]\ntheorem Sphere.secondInter_smul (s : Sphere P) (p : P) (v : V) {r : ℝ} (hr : r ≠ 0) :\n    s.secondInter p (r • v) = s.secondInter p v := by\n  simp_rw [Sphere.secondInter, real_inner_smul_left, inner_smul_right, smul_smul,\n    div_mul_eq_div_div]\n  rw [mul_comm, ← mul_div_assoc, ← mul_div_assoc, mul_div_cancel_left₀ _ hr, mul_comm, mul_assoc,\n    mul_div_cancel_left₀ _ hr, mul_comm]\n\n"}
{"name":"EuclideanGeometry.Sphere.secondInter_neg","module":"Mathlib.Geometry.Euclidean.Sphere.SecondInter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np : P\nv : V\n⊢ Eq (s.secondInter p (Neg.neg v)) (s.secondInter p v)","decl":"/-- `secondInter` is unchanged by negating the vector. -/\n@[simp]\ntheorem Sphere.secondInter_neg (s : Sphere P) (p : P) (v : V) :\n    s.secondInter p (-v) = s.secondInter p v := by\n  rw [← neg_one_smul ℝ v, s.secondInter_smul p v (by norm_num : (-1 : ℝ) ≠ 0)]\n\n"}
{"name":"EuclideanGeometry.Sphere.secondInter_secondInter","module":"Mathlib.Geometry.Euclidean.Sphere.SecondInter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np : P\nv : V\n⊢ Eq (s.secondInter (s.secondInter p v) v) p","decl":"/-- Applying `secondInter` twice returns the original point. -/\n@[simp]\ntheorem Sphere.secondInter_secondInter (s : Sphere P) (p : P) (v : V) :\n    s.secondInter (s.secondInter p v) v = p := by\n  by_cases hv : v = 0; · simp [hv]\n  have hv' : ⟪v, v⟫ ≠ 0 := inner_self_ne_zero.2 hv\n  simp only [Sphere.secondInter, vadd_vsub_assoc, vadd_vadd, inner_add_right, inner_smul_right,\n    div_mul_cancel₀ _ hv']\n  rw [← @vsub_eq_zero_iff_eq V, vadd_vsub, ← add_smul, ← add_div]\n  convert zero_smul ℝ (M := V) _\n  convert zero_div (G₀ := ℝ) _\n  ring\n\n"}
{"name":"EuclideanGeometry.Sphere.secondInter_eq_lineMap","module":"Mathlib.Geometry.Euclidean.Sphere.SecondInter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np p' : P\n⊢ Eq (s.secondInter p (VSub.vsub p' p)) ((AffineMap.lineMap p p') (HDiv.hDiv (HMul.hMul (-2) (Inner.inner (VSub.vsub p' p) (VSub.vsub p s.center))) (Inner.inner (VSub.vsub p' p) (VSub.vsub p' p))))","decl":"/-- If the vector passed to `secondInter` is given by a subtraction involving the point in\n`secondInter`, the result of `secondInter` may be expressed using `lineMap`. -/\ntheorem Sphere.secondInter_eq_lineMap (s : Sphere P) (p p' : P) :\n    s.secondInter p (p' -ᵥ p) =\n      AffineMap.lineMap p p' (-2 * ⟪p' -ᵥ p, p -ᵥ s.center⟫ / ⟪p' -ᵥ p, p' -ᵥ p⟫) :=\n  rfl\n\n"}
{"name":"EuclideanGeometry.Sphere.secondInter_vsub_mem_affineSpan","module":"Mathlib.Geometry.Euclidean.Sphere.SecondInter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np₁ p₂ : P\n⊢ Membership.mem (affineSpan Real (Insert.insert p₁ (Singleton.singleton p₂))) (s.secondInter p₁ (VSub.vsub p₂ p₁))","decl":"/-- If the vector passed to `secondInter` is given by a subtraction involving the point in\n`secondInter`, the result lies in the span of the two points. -/\ntheorem Sphere.secondInter_vsub_mem_affineSpan (s : Sphere P) (p₁ p₂ : P) :\n    s.secondInter p₁ (p₂ -ᵥ p₁) ∈ line[ℝ, p₁, p₂] :=\n  smul_vsub_vadd_mem_affineSpan_pair _ _ _\n\n"}
{"name":"EuclideanGeometry.Sphere.secondInter_collinear","module":"Mathlib.Geometry.Euclidean.Sphere.SecondInter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np p' : P\n⊢ Collinear Real (Insert.insert p (Insert.insert p' (Singleton.singleton (s.secondInter p (VSub.vsub p' p)))))","decl":"/-- If the vector passed to `secondInter` is given by a subtraction involving the point in\n`secondInter`, the three points are collinear. -/\ntheorem Sphere.secondInter_collinear (s : Sphere P) (p p' : P) :\n    Collinear ℝ ({p, p', s.secondInter p (p' -ᵥ p)} : Set P) := by\n  rw [Set.pair_comm, Set.insert_comm]\n  exact\n    (collinear_insert_iff_of_mem_affineSpan (s.secondInter_vsub_mem_affineSpan _ _)).2\n      (collinear_pair ℝ _ _)\n\n"}
{"name":"EuclideanGeometry.Sphere.wbtw_secondInter","module":"Mathlib.Geometry.Euclidean.Sphere.SecondInter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np p' : P\nhp : Membership.mem s p\nhp' : LE.le (Dist.dist p' s.center) s.radius\n⊢ Wbtw Real p p' (s.secondInter p (VSub.vsub p' p))","decl":"/-- If the vector passed to `secondInter` is given by a subtraction involving the point in\n`secondInter`, and the second point is not outside the sphere, the second point is weakly\nbetween the first point and the result of `secondInter`. -/\ntheorem Sphere.wbtw_secondInter {s : Sphere P} {p p' : P} (hp : p ∈ s)\n    (hp' : dist p' s.center ≤ s.radius) : Wbtw ℝ p p' (s.secondInter p (p' -ᵥ p)) := by\n  by_cases h : p' = p; · simp [h]\n  refine\n    wbtw_of_collinear_of_dist_center_le_radius (s.secondInter_collinear p p') hp hp'\n      ((Sphere.secondInter_mem _).2 hp) ?_\n  intro he\n  rw [eq_comm, Sphere.secondInter_eq_self_iff, ← neg_neg (p' -ᵥ p), inner_neg_left,\n    neg_vsub_eq_vsub_rev, neg_eq_zero, eq_comm] at he\n  exact ((inner_pos_or_eq_of_dist_le_radius hp hp').resolve_right (Ne.symm h)).ne he\n\n"}
{"name":"EuclideanGeometry.Sphere.sbtw_secondInter","module":"Mathlib.Geometry.Euclidean.Sphere.SecondInter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np p' : P\nhp : Membership.mem s p\nhp' : LT.lt (Dist.dist p' s.center) s.radius\n⊢ Sbtw Real p p' (s.secondInter p (VSub.vsub p' p))","decl":"/-- If the vector passed to `secondInter` is given by a subtraction involving the point in\n`secondInter`, and the second point is inside the sphere, the second point is strictly between\nthe first point and the result of `secondInter`. -/\ntheorem Sphere.sbtw_secondInter {s : Sphere P} {p p' : P} (hp : p ∈ s)\n    (hp' : dist p' s.center < s.radius) : Sbtw ℝ p p' (s.secondInter p (p' -ᵥ p)) := by\n  refine ⟨Sphere.wbtw_secondInter hp hp'.le, ?_, ?_⟩\n  · rintro rfl\n    rw [mem_sphere] at hp\n    simp [hp] at hp'\n  · rintro h\n    rw [h, mem_sphere.1 ((Sphere.secondInter_mem _).2 hp)] at hp'\n    exact lt_irrefl _ hp'\n\n"}
