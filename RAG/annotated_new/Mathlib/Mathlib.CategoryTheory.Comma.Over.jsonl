{"name":"CategoryTheory.Over.OverMorphism.ext_iff","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU V : CategoryTheory.Over X\nf g : Quiver.Hom U V\n‚ä¢ Iff (Eq f g) (Eq f.left g.left)","decl":"@[ext]\ntheorem OverMorphism.ext {X : T} {U V : Over X} {f g : U ‚ü∂ V} (h : f.left = g.left) : f = g := by\n  let ‚ü®_,b,_‚ü© := f\n  let ‚ü®_,e,_‚ü© := g\n  congr\n  simp only [eq_iff_true_of_subsingleton]\n\n"}
{"name":"CategoryTheory.Over.OverMorphism.ext","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU V : CategoryTheory.Over X\nf g : Quiver.Hom U V\nh : Eq f.left g.left\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem OverMorphism.ext {X : T} {U V : Over X} {f g : U ‚ü∂ V} (h : f.left = g.left) : f = g := by\n  let ‚ü®_,b,_‚ü© := f\n  let ‚ü®_,e,_‚ü© := g\n  congr\n  simp only [eq_iff_true_of_subsingleton]\n\n"}
{"name":"CategoryTheory.Over.over_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU : CategoryTheory.Over X\n‚ä¢ Eq U.right { as := PUnit.unit }","decl":"@[simp]\ntheorem over_right (U : Over X) : U.right = ‚ü®‚ü®‚ü©‚ü© := by simp only\n\n"}
{"name":"CategoryTheory.Over.id_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU : CategoryTheory.Over X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id U).left (CategoryTheory.CategoryStruct.id U.left)","decl":"@[simp]\ntheorem id_left (U : Over X) : CommaMorphism.left (ùüô U) = ùüô U.left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Over.comp_left_assoc","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\na b c : CategoryTheory.Over X\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nZ : T\nh : Quiver.Hom c.left Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).left h) (CategoryTheory.CategoryStruct.comp f.left (CategoryTheory.CategoryStruct.comp g.left h))","decl":"@[simp, reassoc]\ntheorem comp_left (a b c : Over X) (f : a ‚ü∂ b) (g : b ‚ü∂ c) : (f ‚â´ g).left = f.left ‚â´ g.left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Over.comp_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\na b c : CategoryTheory.Over X\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).left (CategoryTheory.CategoryStruct.comp f.left g.left)","decl":"@[simp, reassoc]\ntheorem comp_left (a b c : Over X) (f : a ‚ü∂ b) (g : b ‚ü∂ c) : (f ‚â´ g).left = f.left ‚â´ g.left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Over.w","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nA B : CategoryTheory.Over X\nf : Quiver.Hom A B\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.left B.hom) A.hom","decl":"@[reassoc (attr := simp)]\ntheorem w {A B : Over X} (f : A ‚ü∂ B) : f.left ‚â´ B.hom = A.hom := by have := f.w; aesop_cat\n\n"}
{"name":"CategoryTheory.Over.w_assoc","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nA B : CategoryTheory.Over X\nf : Quiver.Hom A B\nZ : T\nh : Quiver.Hom ((CategoryTheory.Functor.fromPUnit X).obj B.right) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.left (CategoryTheory.CategoryStruct.comp B.hom h)) (CategoryTheory.CategoryStruct.comp A.hom h)","decl":"@[reassoc (attr := simp)]\ntheorem w {A B : Over X} (f : A ‚ü∂ B) : f.left ‚â´ B.hom = A.hom := by have := f.w; aesop_cat\n\n"}
{"name":"CategoryTheory.Over.mk_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : Quiver.Hom Y X\n‚ä¢ Eq (CategoryTheory.Over.mk f).hom f","decl":"/-- To give an object in the over category, it suffices to give a morphism with codomain `X`. -/\n@[simps! left hom]\ndef mk {X Y : T} (f : Y ‚ü∂ X) : Over X :=\n  CostructuredArrow.mk f\n\n"}
{"name":"CategoryTheory.Over.mk_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : Quiver.Hom Y X\n‚ä¢ Eq (CategoryTheory.Over.mk f).left Y","decl":"/-- To give an object in the over category, it suffices to give a morphism with codomain `X`. -/\n@[simps! left hom]\ndef mk {X Y : T} (f : Y ‚ü∂ X) : Over X :=\n  CostructuredArrow.mk f\n\n"}
{"name":"CategoryTheory.Over.coe_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : Quiver.Hom Y X\n‚ä¢ Eq (CategoryTheory.Over.mk f).hom f","decl":"@[simp]\ntheorem coe_hom {X Y : T} (f : Y ‚ü∂ X) : (f : Over X).hom = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Over.homMk_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU V : CategoryTheory.Over X\nf : Quiver.Hom U.left V.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp f V.hom) U.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Over.homMk f w).left f","decl":"/-- To give a morphism in the over category, it suffices to give an arrow fitting in a commutative\n    triangle. -/\n@[simps! left]\ndef homMk {U V : Over X} (f : U.left ‚ü∂ V.left) (w : f ‚â´ V.hom = U.hom := by aesop_cat) : U ‚ü∂ V :=\n  CostructuredArrow.homMk f w\n\n"}
{"name":"CategoryTheory.Over.isoMk_hom_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Over X\nhl : CategoryTheory.Iso f.left g.left\nhw : autoParam (Eq (CategoryTheory.CategoryStruct.comp hl.hom g.hom) f.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Over.isoMk hl hw).hom.left hl.hom","decl":"/-- Construct an isomorphism in the over category given isomorphisms of the objects whose forward\ndirection gives a commutative triangle.\n-/\n@[simps! hom_left inv_left]\ndef isoMk {f g : Over X} (hl : f.left ‚âÖ g.left) (hw : hl.hom ‚â´ g.hom = f.hom := by aesop_cat) :\n    f ‚âÖ g :=\n  CostructuredArrow.isoMk hl hw\n\n"}
{"name":"CategoryTheory.Over.isoMk_inv_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Over X\nhl : CategoryTheory.Iso f.left g.left\nhw : autoParam (Eq (CategoryTheory.CategoryStruct.comp hl.hom g.hom) f.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Over.isoMk hl hw).inv.left hl.inv","decl":"/-- Construct an isomorphism in the over category given isomorphisms of the objects whose forward\ndirection gives a commutative triangle.\n-/\n@[simps! hom_left inv_left]\ndef isoMk {f g : Over X} (hl : f.left ‚âÖ g.left) (hw : hl.hom ‚â´ g.hom = f.hom := by aesop_cat) :\n    f ‚âÖ g :=\n  CostructuredArrow.isoMk hl hw\n\n"}
{"name":"CategoryTheory.Over.hom_left_inv_left_assoc","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Over X\ne : CategoryTheory.Iso f g\nZ : T\nh : Quiver.Hom f.left Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.hom.left (CategoryTheory.CategoryStruct.comp e.inv.left h)) h","decl":"@[reassoc (attr := simp)]\nlemma hom_left_inv_left {f g : Over X} (e : f ‚âÖ g) :\n    e.hom.left ‚â´ e.inv.left = ùüô f.left := by\n  simp [‚Üê Over.comp_left]\n\n"}
{"name":"CategoryTheory.Over.hom_left_inv_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Over X\ne : CategoryTheory.Iso f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.hom.left e.inv.left) (CategoryTheory.CategoryStruct.id f.left)","decl":"@[reassoc (attr := simp)]\nlemma hom_left_inv_left {f g : Over X} (e : f ‚âÖ g) :\n    e.hom.left ‚â´ e.inv.left = ùüô f.left := by\n  simp [‚Üê Over.comp_left]\n\n"}
{"name":"CategoryTheory.Over.inv_left_hom_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Over X\ne : CategoryTheory.Iso f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.inv.left e.hom.left) (CategoryTheory.CategoryStruct.id g.left)","decl":"@[reassoc (attr := simp)]\nlemma inv_left_hom_left {f g : Over X} (e : f ‚âÖ g) :\n    e.inv.left ‚â´ e.hom.left = ùüô g.left := by\n  simp [‚Üê Over.comp_left]\n\n"}
{"name":"CategoryTheory.Over.inv_left_hom_left_assoc","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Over X\ne : CategoryTheory.Iso f g\nZ : T\nh : Quiver.Hom g.left Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.inv.left (CategoryTheory.CategoryStruct.comp e.hom.left h)) h","decl":"@[reassoc (attr := simp)]\nlemma inv_left_hom_left {f g : Over X} (e : f ‚âÖ g) :\n    e.inv.left ‚â´ e.hom.left = ùüô g.left := by\n  simp [‚Üê Over.comp_left]\n\n"}
{"name":"CategoryTheory.Over.forget_obj","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU : CategoryTheory.Over X\n‚ä¢ Eq ((CategoryTheory.Over.forget X).obj U) U.left","decl":"@[simp]\ntheorem forget_obj {U : Over X} : (forget X).obj U = U.left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Over.forget_map","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU V : CategoryTheory.Over X\nf : Quiver.Hom U V\n‚ä¢ Eq ((CategoryTheory.Over.forget X).map f) f.left","decl":"@[simp]\ntheorem forget_map {U V : Over X} {f : U ‚ü∂ V} : (forget X).map f = f.left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Over.forgetCocone_Œπ_app","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nself : CategoryTheory.Comma (CategoryTheory.Functor.id T) (CategoryTheory.Functor.fromPUnit X)\n‚ä¢ Eq ((CategoryTheory.Over.forgetCocone X).Œπ.app self) self.hom","decl":"/-- The natural cocone over the forgetful functor `Over X ‚•§ T` with cocone point `X`. -/\n@[simps]\ndef forgetCocone (X : T) : Limits.Cocone (forget X) :=\n  { pt := X\n    Œπ := { app := Comma.hom } }\n\n"}
{"name":"CategoryTheory.Over.forgetCocone_pt","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ Eq (CategoryTheory.Over.forgetCocone X).pt X","decl":"/-- The natural cocone over the forgetful functor `Over X ‚•§ T` with cocone point `X`. -/\n@[simps]\ndef forgetCocone (X : T) : Limits.Cocone (forget X) :=\n  { pt := X\n    Œπ := { app := Comma.hom } }\n\n"}
{"name":"CategoryTheory.Over.map_obj_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : Quiver.Hom X Y\nU : CategoryTheory.Over X\n‚ä¢ Eq ((CategoryTheory.Over.map f).obj U).left U.left","decl":"@[simp]\ntheorem map_obj_left : ((map f).obj U).left = U.left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Over.map_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : Quiver.Hom X Y\nU : CategoryTheory.Over X\n‚ä¢ Eq ((CategoryTheory.Over.map f).obj U).hom (CategoryTheory.CategoryStruct.comp U.hom f)","decl":"@[simp]\ntheorem map_obj_hom : ((map f).obj U).hom = U.hom ‚â´ f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Over.map_map_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : Quiver.Hom X Y\nU V : CategoryTheory.Over X\ng : Quiver.Hom U V\n‚ä¢ Eq ((CategoryTheory.Over.map f).map g).left g.left","decl":"@[simp]\ntheorem map_map_left : ((map f).map g).left = g.left :=\n  rfl\n"}
{"name":"CategoryTheory.Over.mapIso_functor","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : CategoryTheory.Iso X Y\n‚ä¢ Eq (CategoryTheory.Over.mapIso f).functor (CategoryTheory.Over.map f.hom)","decl":"@[simp] lemma mapIso_functor {Y : T} (f : X ‚âÖ Y) : (mapIso f).functor = map f.hom := rfl\n"}
{"name":"CategoryTheory.Over.mapIso_inverse","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : CategoryTheory.Iso X Y\n‚ä¢ Eq (CategoryTheory.Over.mapIso f).inverse (CategoryTheory.Over.map f.inv)","decl":"@[simp] lemma mapIso_inverse {Y : T} (f : X ‚âÖ Y) : (mapIso f).inverse = map f.inv := rfl\n\n"}
{"name":"CategoryTheory.Over.mapId_eq","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nY : T\n‚ä¢ Eq (CategoryTheory.Over.map (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.Functor.id (CategoryTheory.Over Y))","decl":"/-- Mapping by the identity morphism is just the identity functor. -/\ntheorem mapId_eq (Y : T) : map (ùüô Y) = ùü≠ _ := by\n  fapply Functor.ext\n  ¬∑ intro x\n    dsimp [Over, Over.map, Comma.mapRight]\n    simp only [Category.comp_id]\n    exact rfl\n  ¬∑ intros x y u\n    dsimp [Over, Over.map, Comma.mapRight]\n    simp\n\n"}
{"name":"CategoryTheory.Over.mapId_inv","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nY : T\n‚ä¢ Eq (CategoryTheory.Over.mapId Y).inv (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The natural isomorphism arising from `mapForget_eq`. -/\n@[simps!]\ndef mapId (Y : T) : map (ùüô Y) ‚âÖ ùü≠ _ := eqToIso (mapId_eq Y)\n--  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Over.mapId_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nY : T\n‚ä¢ Eq (CategoryTheory.Over.mapId Y).hom (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The natural isomorphism arising from `mapForget_eq`. -/\n@[simps!]\ndef mapId (Y : T) : map (ùüô Y) ‚âÖ ùü≠ _ := eqToIso (mapId_eq Y)\n--  NatIso.ofComponents fun X => isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Over.mapForget_eq","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Over.map f).comp (CategoryTheory.Over.forget Y)) (CategoryTheory.Over.forget X)","decl":"/-- Mapping by `f` and then forgetting is the same as forgetting. -/\ntheorem mapForget_eq {X Y : T} (f : X ‚ü∂ Y) :\n    (map f) ‚ãô (forget Y) = (forget X) := by\n  fapply Functor.ext\n  ¬∑ dsimp [Over, Over.map]; intro x; exact rfl\n  ¬∑ intros x y u; simp\n\n"}
{"name":"CategoryTheory.Over.eqToHom_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU V : CategoryTheory.Over X\ne : Eq U V\n‚ä¢ Eq (CategoryTheory.eqToHom e).left (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem eqToHom_left {X : T} {U V : Over X} (e : U = V) :\n    (eqToHom e).left = eqToHom (e ‚ñ∏ rfl : U.left = V.left) := by\n  subst e; rfl\n\n"}
{"name":"CategoryTheory.Over.mapComp_eq","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y Z : T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.Over.map (CategoryTheory.CategoryStruct.comp f g)) ((CategoryTheory.Over.map f).comp (CategoryTheory.Over.map g))","decl":"/-- Mapping by the composite morphism `f ‚â´ g` is the same as mapping by `f` then by `g`. -/\ntheorem mapComp_eq {X Y Z : T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    map (f ‚â´ g) = (map f) ‚ãô (map g) := by\n  fapply Functor.ext\n  ¬∑ simp [Over.map, Comma.mapRight]\n  ¬∑ intro U V k\n    ext\n    simp\n\n"}
{"name":"CategoryTheory.Over.mapComp_inv","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y Z : T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.Over.mapComp f g).inv (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The natural isomorphism arising from `mapComp_eq`. -/\n@[simps!]\ndef mapComp {X Y Z : T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    map (f ‚â´ g) ‚âÖ (map f) ‚ãô (map g) := eqToIso (mapComp_eq f g)\n\n"}
{"name":"CategoryTheory.Over.mapComp_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y Z : T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.Over.mapComp f g).hom (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The natural isomorphism arising from `mapComp_eq`. -/\n@[simps!]\ndef mapComp {X Y Z : T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    map (f ‚â´ g) ‚âÖ (map f) ‚ãô (map g) := eqToIso (mapComp_eq f g)\n\n"}
{"name":"CategoryTheory.Over.mapCongr_hom_app","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX‚úù Y : T\nf g : Quiver.Hom X‚úù Y\nh : Eq f g\nX : CategoryTheory.Over X‚úù\n‚ä¢ Eq ((CategoryTheory.Over.mapCongr f g h).hom.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- If `f = g`, then `map f` is naturally isomorphic to `map g`. -/\n@[simps!]\ndef mapCongr {X Y : T} (f g : X ‚ü∂ Y) (h : f = g) :\n    map f ‚âÖ map g :=\n  NatIso.ofComponents (fun A ‚Ü¶ eqToIso (by rw [h]))\n\n"}
{"name":"CategoryTheory.Over.mapCongr_inv_app","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX‚úù Y : T\nf g : Quiver.Hom X‚úù Y\nh : Eq f g\nX : CategoryTheory.Over X‚úù\n‚ä¢ Eq ((CategoryTheory.Over.mapCongr f g h).inv.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- If `f = g`, then `map f` is naturally isomorphic to `map g`. -/\n@[simps!]\ndef mapCongr {X Y : T} (f g : X ‚ü∂ Y) (h : f = g) :\n    map f ‚âÖ map g :=\n  NatIso.ofComponents (fun A ‚Ü¶ eqToIso (by rw [h]))\n\n"}
{"name":"CategoryTheory.Over.mapFunctor_obj","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ Eq ((CategoryTheory.Over.mapFunctor T).obj X) (CategoryTheory.Cat.of (CategoryTheory.Over X))","decl":"variable (T) in\n/-- The functor defined by the over categories.-/\n@[simps] def mapFunctor : T ‚•§ Cat where\n  obj X := Cat.of (Over X)\n  map := map\n  map_id := mapId_eq\n  map_comp := mapComp_eq\n\n"}
{"name":"CategoryTheory.Over.mapFunctor_map","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX‚úù Y‚úù : T\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Over.mapFunctor T).map f) (CategoryTheory.Over.map f)","decl":"variable (T) in\n/-- The functor defined by the over categories.-/\n@[simps] def mapFunctor : T ‚•§ Cat where\n  obj X := Cat.of (Over X)\n  map := map\n  map_id := mapId_eq\n  map_comp := mapComp_eq\n\n"}
{"name":"CategoryTheory.Over.forget_reflects_iso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ (CategoryTheory.Over.forget X).ReflectsIsomorphisms","decl":"instance forget_reflects_iso : (forget X).ReflectsIsomorphisms where\n  reflects {Y Z} f t := by\n    let g : Z ‚ü∂ Y := Over.homMk (inv ((forget X).map f))\n      ((asIso ((forget X).map f)).inv_comp_eq.2 (Over.w f).symm)\n    dsimp [forget] at t\n    refine ‚ü®‚ü®g, ‚ü®?_,?_‚ü©‚ü©‚ü©\n    repeat (ext; simp [g])\n\n"}
{"name":"CategoryTheory.Over.forget_faithful","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ (CategoryTheory.Over.forget X).Faithful","decl":"instance forget_faithful : (forget X).Faithful where\n\n-- TODO: Show the converse holds if `T` has binary products.\n"}
{"name":"CategoryTheory.Over.epi_of_epi_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Over X\nk : Quiver.Hom f g\nhk : CategoryTheory.Epi k.left\n‚ä¢ CategoryTheory.Epi k","decl":"/--\nIf `k.left` is an epimorphism, then `k` is an epimorphism. In other words, `Over.forget X` reflects\nepimorphisms.\nThe converse does not hold without additional assumptions on the underlying category, see\n`CategoryTheory.Over.epi_left_of_epi`.\n-/\ntheorem epi_of_epi_left {f g : Over X} (k : f ‚ü∂ g) [hk : Epi k.left] : Epi k :=\n  (forget X).epi_of_epi_map hk\n\n"}
{"name":"CategoryTheory.Over.mono_of_mono_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Over X\nk : Quiver.Hom f g\nhk : CategoryTheory.Mono k.left\n‚ä¢ CategoryTheory.Mono k","decl":"/--\nIf `k.left` is a monomorphism, then `k` is a monomorphism. In other words, `Over.forget X` reflects\nmonomorphisms.\nThe converse of `CategoryTheory.Over.mono_left_of_mono`.\n\nThis lemma is not an instance, to avoid loops in type class inference.\n-/\ntheorem mono_of_mono_left {f g : Over X} (k : f ‚ü∂ g) [hk : Mono k.left] : Mono k :=\n  (forget X).mono_of_mono_map hk\n\n"}
{"name":"CategoryTheory.Over.mono_left_of_mono","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Over X\nk : Quiver.Hom f g\ninst‚úù : CategoryTheory.Mono k\n‚ä¢ CategoryTheory.Mono k.left","decl":"/--\nIf `k` is a monomorphism, then `k.left` is a monomorphism. In other words, `Over.forget X` preserves\nmonomorphisms.\nThe converse of `CategoryTheory.Over.mono_of_mono_left`.\n-/\ninstance mono_left_of_mono {f g : Over X} (k : f ‚ü∂ g) [Mono k] : Mono k.left := by\n  refine ‚ü®fun {Y : T} l m a => ?_‚ü©\n  let l' : mk (m ‚â´ f.hom) ‚ü∂ f := homMk l (by\n        dsimp; rw [‚Üê Over.w k, ‚Üê Category.assoc, congrArg (¬∑ ‚â´ g.hom) a, Category.assoc])\n  suffices l' = (homMk m : mk (m ‚â´ f.hom) ‚ü∂ f) by apply congrArg CommaMorphism.left this\n  rw [‚Üê cancel_mono k]\n  ext\n  apply a\n\n"}
{"name":"CategoryTheory.Over.iteratedSliceForward_map","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf : CategoryTheory.Over X\nX‚úù Y‚úù : CategoryTheory.Over f\nŒ∫ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (f.iteratedSliceForward.map Œ∫) (CategoryTheory.Over.homMk Œ∫.left.left ‚ãØ)","decl":"/-- Given f : Y ‚ü∂ X, this is the obvious functor from (T/X)/f to T/Y -/\n@[simps]\ndef iteratedSliceForward : Over f ‚•§ Over f.left where\n  obj Œ± := Over.mk Œ±.hom.left\n  map Œ∫ := Over.homMk Œ∫.left.left (by dsimp; rw [‚Üê Over.w Œ∫]; rfl)\n\n"}
{"name":"CategoryTheory.Over.iteratedSliceForward_obj","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf : CategoryTheory.Over X\nŒ± : CategoryTheory.Over f\n‚ä¢ Eq (f.iteratedSliceForward.obj Œ±) (CategoryTheory.Over.mk Œ±.hom.left)","decl":"/-- Given f : Y ‚ü∂ X, this is the obvious functor from (T/X)/f to T/Y -/\n@[simps]\ndef iteratedSliceForward : Over f ‚•§ Over f.left where\n  obj Œ± := Over.mk Œ±.hom.left\n  map Œ∫ := Over.homMk Œ∫.left.left (by dsimp; rw [‚Üê Over.w Œ∫]; rfl)\n\n"}
{"name":"CategoryTheory.Over.iteratedSliceBackward_map","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf : CategoryTheory.Over X\nX‚úù Y‚úù : CategoryTheory.Over f.left\nŒ± : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (f.iteratedSliceBackward.map Œ±) (CategoryTheory.Over.homMk (CategoryTheory.Over.homMk Œ±.left ‚ãØ) ‚ãØ)","decl":"/-- Given f : Y ‚ü∂ X, this is the obvious functor from T/Y to (T/X)/f -/\n@[simps]\ndef iteratedSliceBackward : Over f.left ‚•§ Over f where\n  obj g := mk (homMk g.hom : mk (g.hom ‚â´ f.hom) ‚ü∂ f)\n  map Œ± := homMk (homMk Œ±.left (w_assoc Œ± f.hom)) (OverMorphism.ext (w Œ±))\n\n"}
{"name":"CategoryTheory.Over.iteratedSliceBackward_obj","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf : CategoryTheory.Over X\ng : CategoryTheory.Over f.left\n‚ä¢ Eq (f.iteratedSliceBackward.obj g) (CategoryTheory.Over.mk (CategoryTheory.Over.homMk g.hom ‚ãØ))","decl":"/-- Given f : Y ‚ü∂ X, this is the obvious functor from T/Y to (T/X)/f -/\n@[simps]\ndef iteratedSliceBackward : Over f.left ‚•§ Over f where\n  obj g := mk (homMk g.hom : mk (g.hom ‚â´ f.hom) ‚ü∂ f)\n  map Œ± := homMk (homMk Œ±.left (w_assoc Œ± f.hom)) (OverMorphism.ext (w Œ±))\n\n"}
{"name":"CategoryTheory.Over.iteratedSliceEquiv_unitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf : CategoryTheory.Over X\n‚ä¢ Eq f.iteratedSliceEquiv.unitIso (CategoryTheory.NatIso.ofComponents (fun g => CategoryTheory.Over.isoMk (CategoryTheory.Over.isoMk (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Over f)).obj g).left.left) ‚ãØ) ‚ãØ) ‚ãØ)","decl":"/-- Given f : Y ‚ü∂ X, we have an equivalence between (T/X)/f and T/Y -/\n@[simps]\ndef iteratedSliceEquiv : Over f ‚âå Over f.left where\n  functor := iteratedSliceForward f\n  inverse := iteratedSliceBackward f\n  unitIso := NatIso.ofComponents (fun g => Over.isoMk (Over.isoMk (Iso.refl _)))\n  counitIso := NatIso.ofComponents (fun g => Over.isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Over.iteratedSliceEquiv_inverse","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf : CategoryTheory.Over X\n‚ä¢ Eq f.iteratedSliceEquiv.inverse f.iteratedSliceBackward","decl":"/-- Given f : Y ‚ü∂ X, we have an equivalence between (T/X)/f and T/Y -/\n@[simps]\ndef iteratedSliceEquiv : Over f ‚âå Over f.left where\n  functor := iteratedSliceForward f\n  inverse := iteratedSliceBackward f\n  unitIso := NatIso.ofComponents (fun g => Over.isoMk (Over.isoMk (Iso.refl _)))\n  counitIso := NatIso.ofComponents (fun g => Over.isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Over.iteratedSliceEquiv_counitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf : CategoryTheory.Over X\n‚ä¢ Eq f.iteratedSliceEquiv.counitIso (CategoryTheory.NatIso.ofComponents (fun g => CategoryTheory.Over.isoMk (CategoryTheory.Iso.refl ((f.iteratedSliceBackward.comp f.iteratedSliceForward).obj g).left) ‚ãØ) ‚ãØ)","decl":"/-- Given f : Y ‚ü∂ X, we have an equivalence between (T/X)/f and T/Y -/\n@[simps]\ndef iteratedSliceEquiv : Over f ‚âå Over f.left where\n  functor := iteratedSliceForward f\n  inverse := iteratedSliceBackward f\n  unitIso := NatIso.ofComponents (fun g => Over.isoMk (Over.isoMk (Iso.refl _)))\n  counitIso := NatIso.ofComponents (fun g => Over.isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Over.iteratedSliceEquiv_functor","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf : CategoryTheory.Over X\n‚ä¢ Eq f.iteratedSliceEquiv.functor f.iteratedSliceForward","decl":"/-- Given f : Y ‚ü∂ X, we have an equivalence between (T/X)/f and T/Y -/\n@[simps]\ndef iteratedSliceEquiv : Over f ‚âå Over f.left where\n  functor := iteratedSliceForward f\n  inverse := iteratedSliceBackward f\n  unitIso := NatIso.ofComponents (fun g => Over.isoMk (Over.isoMk (Iso.refl _)))\n  counitIso := NatIso.ofComponents (fun g => Over.isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.Over.iteratedSliceForward_forget","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf : CategoryTheory.Over X\n‚ä¢ Eq (f.iteratedSliceForward.comp (CategoryTheory.Over.forget f.left)) ((CategoryTheory.Over.forget f).comp (CategoryTheory.Over.forget X))","decl":"theorem iteratedSliceForward_forget :\n    iteratedSliceForward f ‚ãô forget f.left = forget f ‚ãô forget X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Over.iteratedSliceBackward_forget_forget","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf : CategoryTheory.Over X\n‚ä¢ Eq (f.iteratedSliceBackward.comp ((CategoryTheory.Over.forget f).comp (CategoryTheory.Over.forget X))) (CategoryTheory.Over.forget f.left)","decl":"theorem iteratedSliceBackward_forget_forget :\n    iteratedSliceBackward f ‚ãô forget f ‚ãô forget X = forget f.left :=\n  rfl\n\n"}
{"name":"CategoryTheory.Over.post_obj","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor T D\nY : CategoryTheory.Over X\n‚ä¢ Eq ((CategoryTheory.Over.post F).obj Y) (CategoryTheory.Over.mk (F.map Y.hom))","decl":"/-- A functor `F : T ‚•§ D` induces a functor `Over X ‚•§ Over (F.obj X)` in the obvious way. -/\n@[simps]\ndef post (F : T ‚•§ D) : Over X ‚•§ Over (F.obj X) where\n  obj Y := mk <| F.map Y.hom\n  map f := Over.homMk (F.map f.left)\n    (by simp only [Functor.id_obj, mk_left, Functor.const_obj_obj, mk_hom, ‚Üê F.map_comp, w])\n\n"}
{"name":"CategoryTheory.Over.post_map","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor T D\nX‚úù Y‚úù : CategoryTheory.Over X\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Over.post F).map f) (CategoryTheory.Over.homMk (F.map f.left) ‚ãØ)","decl":"/-- A functor `F : T ‚•§ D` induces a functor `Over X ‚•§ Over (F.obj X)` in the obvious way. -/\n@[simps]\ndef post (F : T ‚•§ D) : Over X ‚•§ Over (F.obj X) where\n  obj Y := mk <| F.map Y.hom\n  map f := Over.homMk (F.map f.left)\n    (by simp only [Functor.id_obj, mk_left, Functor.const_obj_obj, mk_hom, ‚Üê F.map_comp, w])\n\n"}
{"name":"CategoryTheory.Over.post_comp","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor T D\nG : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.Over.post (F.comp G)) ((CategoryTheory.Over.post F).comp (CategoryTheory.Over.post G))","decl":"lemma post_comp {E : Type*} [Category E] (F : T ‚•§ D) (G : D ‚•§ E) :\n    post (X := X) (F ‚ãô G) = post (X := X) F ‚ãô post G :=\n  rfl\n\n"}
{"name":"CategoryTheory.Over.postComp_inv_app_right_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor T D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.Over X‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- `post (F ‚ãô G)` is isomorphic (actually equal) to `post F ‚ãô post G`. -/\n@[simps!]\ndef postComp {E : Type*} [Category E] (F : T ‚•§ D) (G : D ‚•§ E) :\n    post (X := X) (F ‚ãô G) ‚âÖ post F ‚ãô post G :=\n  NatIso.ofComponents (fun X ‚Ü¶ Iso.refl _)\n\n"}
{"name":"CategoryTheory.Over.postComp_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor T D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.Over X‚úù\n‚ä¢ Eq ((CategoryTheory.Over.postComp F G).inv.app X).left (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.left)))","decl":"/-- `post (F ‚ãô G)` is isomorphic (actually equal) to `post F ‚ãô post G`. -/\n@[simps!]\ndef postComp {E : Type*} [Category E] (F : T ‚•§ D) (G : D ‚•§ E) :\n    post (X := X) (F ‚ãô G) ‚âÖ post F ‚ãô post G :=\n  NatIso.ofComponents (fun X ‚Ü¶ Iso.refl _)\n\n"}
{"name":"CategoryTheory.Over.postComp_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor T D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.Over X‚úù\n‚ä¢ Eq ((CategoryTheory.Over.postComp F G).hom.app X).left (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.left)))","decl":"/-- `post (F ‚ãô G)` is isomorphic (actually equal) to `post F ‚ãô post G`. -/\n@[simps!]\ndef postComp {E : Type*} [Category E] (F : T ‚•§ D) (G : D ‚•§ E) :\n    post (X := X) (F ‚ãô G) ‚âÖ post F ‚ãô post G :=\n  NatIso.ofComponents (fun X ‚Ü¶ Iso.refl _)\n\n"}
{"name":"CategoryTheory.Over.postComp_hom_app_right_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor T D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.Over X‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- `post (F ‚ãô G)` is isomorphic (actually equal) to `post F ‚ãô post G`. -/\n@[simps!]\ndef postComp {E : Type*} [Category E] (F : T ‚•§ D) (G : D ‚•§ E) :\n    post (X := X) (F ‚ãô G) ‚âÖ post F ‚ãô post G :=\n  NatIso.ofComponents (fun X ‚Ü¶ Iso.refl _)\n\n"}
{"name":"CategoryTheory.Over.postMap_app","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF G : CategoryTheory.Functor T D\ne : Quiver.Hom F G\nY : CategoryTheory.Over X\n‚ä¢ Eq ((CategoryTheory.Over.postMap e).app Y) (CategoryTheory.Over.homMk (e.app Y.left) ‚ãØ)","decl":"/-- A natural transformation `F ‚ü∂ G` induces a natural transformation on\n`Over X` up to `Under.map`. -/\n@[simps]\ndef postMap {F G : T ‚•§ D} (e : F ‚ü∂ G) : post F ‚ãô map (e.app X) ‚ü∂ post G where\n  app Y := Over.homMk (e.app Y.left)\n\n"}
{"name":"CategoryTheory.Over.postCongr_inv_app_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nF G : CategoryTheory.Functor T D\ne : CategoryTheory.Iso F G\nX : CategoryTheory.Over X‚úù\n‚ä¢ Eq ((CategoryTheory.Over.postCongr e).inv.app X).left (e.inv.app X.left)","decl":"/-- If `F` and `G` are naturally isomorphic, then `Over.post F` and `Over.post G` are also naturally\nisomorphic up to `Over.map` -/\n@[simps!]\ndef postCongr {F G : T ‚•§ D} (e : F ‚âÖ G) : post F ‚ãô map (e.hom.app X) ‚âÖ post G :=\n  NatIso.ofComponents (fun A ‚Ü¶ Over.isoMk (e.app A.left))\n\n"}
{"name":"CategoryTheory.Over.postCongr_inv_app_right_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nF G : CategoryTheory.Functor T D\ne : CategoryTheory.Iso F G\nX : CategoryTheory.Over X‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- If `F` and `G` are naturally isomorphic, then `Over.post F` and `Over.post G` are also naturally\nisomorphic up to `Over.map` -/\n@[simps!]\ndef postCongr {F G : T ‚•§ D} (e : F ‚âÖ G) : post F ‚ãô map (e.hom.app X) ‚âÖ post G :=\n  NatIso.ofComponents (fun A ‚Ü¶ Over.isoMk (e.app A.left))\n\n"}
{"name":"CategoryTheory.Over.postCongr_hom_app_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nF G : CategoryTheory.Functor T D\ne : CategoryTheory.Iso F G\nX : CategoryTheory.Over X‚úù\n‚ä¢ Eq ((CategoryTheory.Over.postCongr e).hom.app X).left (e.hom.app X.left)","decl":"/-- If `F` and `G` are naturally isomorphic, then `Over.post F` and `Over.post G` are also naturally\nisomorphic up to `Over.map` -/\n@[simps!]\ndef postCongr {F G : T ‚•§ D} (e : F ‚âÖ G) : post F ‚ãô map (e.hom.app X) ‚âÖ post G :=\n  NatIso.ofComponents (fun A ‚Ü¶ Over.isoMk (e.app A.left))\n\n"}
{"name":"CategoryTheory.Over.postCongr_hom_app_right_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nF G : CategoryTheory.Functor T D\ne : CategoryTheory.Iso F G\nX : CategoryTheory.Over X‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- If `F` and `G` are naturally isomorphic, then `Over.post F` and `Over.post G` are also naturally\nisomorphic up to `Over.map` -/\n@[simps!]\ndef postCongr {F G : T ‚•§ D} (e : F ‚âÖ G) : post F ‚ãô map (e.hom.app X) ‚âÖ post G :=\n  NatIso.ofComponents (fun A ‚Ü¶ Over.isoMk (e.app A.left))\n\n"}
{"name":"CategoryTheory.Over.instFaithfulObjPost","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor T D\ninst‚úù : F.Faithful\n‚ä¢ (CategoryTheory.Over.post F).Faithful","decl":"instance [F.Faithful] : (Over.post (X := X) F).Faithful where\n  map_injective {A B} f g h := by\n    ext\n    exact F.map_injective (congrArg CommaMorphism.left h)\n\n"}
{"name":"CategoryTheory.Over.instFullObjPostOfFaithful","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor T D\ninst‚úù¬π : F.Faithful\ninst‚úù : F.Full\n‚ä¢ (CategoryTheory.Over.post F).Full","decl":"instance [F.Faithful] [F.Full] : (Over.post (X := X) F).Full where\n  map_surjective {A B} f := by\n    obtain ‚ü®a, ha‚ü© := F.map_surjective f.left\n    have w : a ‚â´ B.hom = A.hom := F.map_injective <| by simpa [ha] using Over.w _\n    exact ‚ü®Over.homMk a, by ext; simpa‚ü©\n\n"}
{"name":"CategoryTheory.Over.instEssSurjObjPostOfFull","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor T D\ninst‚úù¬π : F.Full\ninst‚úù : F.EssSurj\n‚ä¢ (CategoryTheory.Over.post F).EssSurj","decl":"instance [F.Full] [F.EssSurj] : (Over.post (X := X) F).EssSurj where\n  mem_essImage B := by\n    obtain ‚ü®A', ‚ü®e‚ü©‚ü© := Functor.EssSurj.mem_essImage (F := F) B.left\n    obtain ‚ü®f, hf‚ü© := F.map_surjective (e.hom ‚â´ B.hom)\n    exact ‚ü®Over.mk f, ‚ü®Over.isoMk e‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Over.instIsEquivalenceObjPost","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor T D\ninst‚úù : F.IsEquivalence\n‚ä¢ (CategoryTheory.Over.post F).IsEquivalence","decl":"instance [F.IsEquivalence] : (Over.post (X := X) F).IsEquivalence where\n\n"}
{"name":"CategoryTheory.Over.postEquiv_counitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Equivalence T D\n‚ä¢ Eq (CategoryTheory.Over.postEquiv X F).counitIso (CategoryTheory.NatIso.ofComponents (fun A => CategoryTheory.Over.isoMk (F.counitIso.app A.left) ‚ãØ) ‚ãØ)","decl":"/-- An equivalence of categories induces an equivalence on over categories. -/\n@[simps]\ndef postEquiv (F : T ‚âå D) : Over X ‚âå Over (F.functor.obj X) where\n  functor := Over.post F.functor\n  inverse := Over.post (X := F.functor.obj X) F.inverse ‚ãô Over.map (F.unitIso.inv.app X)\n  unitIso := NatIso.ofComponents (fun A ‚Ü¶ Over.isoMk (F.unitIso.app A.left))\n  counitIso := NatIso.ofComponents (fun A ‚Ü¶ Over.isoMk (F.counitIso.app A.left))\n\n"}
{"name":"CategoryTheory.Over.postEquiv_functor","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Equivalence T D\n‚ä¢ Eq (CategoryTheory.Over.postEquiv X F).functor (CategoryTheory.Over.post F.functor)","decl":"/-- An equivalence of categories induces an equivalence on over categories. -/\n@[simps]\ndef postEquiv (F : T ‚âå D) : Over X ‚âå Over (F.functor.obj X) where\n  functor := Over.post F.functor\n  inverse := Over.post (X := F.functor.obj X) F.inverse ‚ãô Over.map (F.unitIso.inv.app X)\n  unitIso := NatIso.ofComponents (fun A ‚Ü¶ Over.isoMk (F.unitIso.app A.left))\n  counitIso := NatIso.ofComponents (fun A ‚Ü¶ Over.isoMk (F.counitIso.app A.left))\n\n"}
{"name":"CategoryTheory.Over.postEquiv_unitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Equivalence T D\n‚ä¢ Eq (CategoryTheory.Over.postEquiv X F).unitIso (CategoryTheory.NatIso.ofComponents (fun A => CategoryTheory.Over.isoMk (F.unitIso.app A.left) ‚ãØ) ‚ãØ)","decl":"/-- An equivalence of categories induces an equivalence on over categories. -/\n@[simps]\ndef postEquiv (F : T ‚âå D) : Over X ‚âå Over (F.functor.obj X) where\n  functor := Over.post F.functor\n  inverse := Over.post (X := F.functor.obj X) F.inverse ‚ãô Over.map (F.unitIso.inv.app X)\n  unitIso := NatIso.ofComponents (fun A ‚Ü¶ Over.isoMk (F.unitIso.app A.left))\n  counitIso := NatIso.ofComponents (fun A ‚Ü¶ Over.isoMk (F.counitIso.app A.left))\n\n"}
{"name":"CategoryTheory.Over.postEquiv_inverse","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Equivalence T D\n‚ä¢ Eq (CategoryTheory.Over.postEquiv X F).inverse ((CategoryTheory.Over.post F.inverse).comp (CategoryTheory.Over.map (F.unitIso.inv.app X)))","decl":"/-- An equivalence of categories induces an equivalence on over categories. -/\n@[simps]\ndef postEquiv (F : T ‚âå D) : Over X ‚âå Over (F.functor.obj X) where\n  functor := Over.post F.functor\n  inverse := Over.post (X := F.functor.obj X) F.inverse ‚ãô Over.map (F.unitIso.inv.app X)\n  unitIso := NatIso.ofComponents (fun A ‚Ü¶ Over.isoMk (F.unitIso.app A.left))\n  counitIso := NatIso.ofComponents (fun A ‚Ü¶ Over.isoMk (F.counitIso.app A.left))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.toOver_obj_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nX‚úù : T\nX : CategoryTheory.Comma (F.comp (CategoryTheory.Functor.id T)) (CategoryTheory.Functor.fromPUnit X‚úù)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.toOver F X‚úù).obj X).left (F.obj X.left)","decl":"/-- Reinterpreting an `F`-costructured arrow `F.obj d ‚ü∂ X` as an arrow over `X` induces a functor\n    `CostructuredArrow F X ‚•§ Over X`. -/\n@[simps!]\ndef toOver (F : D ‚•§ T) (X : T) : CostructuredArrow F X ‚•§ Over X :=\n  CostructuredArrow.pre F (ùü≠ T) X\n\n"}
{"name":"CategoryTheory.CostructuredArrow.toOver_map_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nX : T\nX‚úù Y‚úù : CategoryTheory.Comma (F.comp (CategoryTheory.Functor.id T)) (CategoryTheory.Functor.fromPUnit X)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.toOver F X).map f).right (CategoryTheory.CategoryStruct.id X‚úù.right)","decl":"/-- Reinterpreting an `F`-costructured arrow `F.obj d ‚ü∂ X` as an arrow over `X` induces a functor\n    `CostructuredArrow F X ‚•§ Over X`. -/\n@[simps!]\ndef toOver (F : D ‚•§ T) (X : T) : CostructuredArrow F X ‚•§ Over X :=\n  CostructuredArrow.pre F (ùü≠ T) X\n\n"}
{"name":"CategoryTheory.CostructuredArrow.toOver_obj_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nX‚úù : T\nX : CategoryTheory.Comma (F.comp (CategoryTheory.Functor.id T)) (CategoryTheory.Functor.fromPUnit X‚úù)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.toOver F X‚úù).obj X).right X.right","decl":"/-- Reinterpreting an `F`-costructured arrow `F.obj d ‚ü∂ X` as an arrow over `X` induces a functor\n    `CostructuredArrow F X ‚•§ Over X`. -/\n@[simps!]\ndef toOver (F : D ‚•§ T) (X : T) : CostructuredArrow F X ‚•§ Over X :=\n  CostructuredArrow.pre F (ùü≠ T) X\n\n"}
{"name":"CategoryTheory.CostructuredArrow.toOver_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nX‚úù : T\nX : CategoryTheory.Comma (F.comp (CategoryTheory.Functor.id T)) (CategoryTheory.Functor.fromPUnit X‚úù)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.toOver F X‚úù).obj X).hom X.hom","decl":"/-- Reinterpreting an `F`-costructured arrow `F.obj d ‚ü∂ X` as an arrow over `X` induces a functor\n    `CostructuredArrow F X ‚•§ Over X`. -/\n@[simps!]\ndef toOver (F : D ‚•§ T) (X : T) : CostructuredArrow F X ‚•§ Over X :=\n  CostructuredArrow.pre F (ùü≠ T) X\n\n"}
{"name":"CategoryTheory.CostructuredArrow.toOver_map_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nX : T\nX‚úù Y‚úù : CategoryTheory.Comma (F.comp (CategoryTheory.Functor.id T)) (CategoryTheory.Functor.fromPUnit X)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.toOver F X).map f).left (F.map f.left)","decl":"/-- Reinterpreting an `F`-costructured arrow `F.obj d ‚ü∂ X` as an arrow over `X` induces a functor\n    `CostructuredArrow F X ‚•§ Over X`. -/\n@[simps!]\ndef toOver (F : D ‚•§ T) (X : T) : CostructuredArrow F X ‚•§ Over X :=\n  CostructuredArrow.pre F (ùü≠ T) X\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instFaithfulOverToOver","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nX : T\ninst‚úù : F.Faithful\n‚ä¢ (CategoryTheory.CostructuredArrow.toOver F X).Faithful","decl":"instance (F : D ‚•§ T) (X : T) [F.Faithful] : (toOver F X).Faithful :=\n  show (CostructuredArrow.pre _ _ _).Faithful from inferInstance\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instFullOverToOver","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nX : T\ninst‚úù : F.Full\n‚ä¢ (CategoryTheory.CostructuredArrow.toOver F X).Full","decl":"instance (F : D ‚•§ T) (X : T) [F.Full] : (toOver F X).Full :=\n  show (CostructuredArrow.pre _ _ _).Full from inferInstance\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instEssSurjOverToOver","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nX : T\ninst‚úù : F.EssSurj\n‚ä¢ (CategoryTheory.CostructuredArrow.toOver F X).EssSurj","decl":"instance (F : D ‚•§ T) (X : T) [F.EssSurj] : (toOver F X).EssSurj :=\n  show (CostructuredArrow.pre _ _ _).EssSurj from inferInstance\n\n"}
{"name":"CategoryTheory.CostructuredArrow.isEquivalence_toOver","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nX : T\ninst‚úù : F.IsEquivalence\n‚ä¢ (CategoryTheory.CostructuredArrow.toOver F X).IsEquivalence","decl":"/-- An equivalence `F` induces an equivalence `CostructuredArrow F X ‚âå Over X`. -/\ninstance isEquivalence_toOver (F : D ‚•§ T) (X : T) [F.IsEquivalence] :\n    (toOver F X).IsEquivalence :=\n  CostructuredArrow.isEquivalence_pre _ _ _\n\n"}
{"name":"CategoryTheory.Under.UnderMorphism.ext","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU V : CategoryTheory.Under X\nf g : Quiver.Hom U V\nh : Eq f.right g.right\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem UnderMorphism.ext {X : T} {U V : Under X} {f g : U ‚ü∂ V} (h : f.right = g.right) :\n    f = g := by\n  let ‚ü®_,b,_‚ü© := f; let ‚ü®_,e,_‚ü© := g\n  congr; simp only [eq_iff_true_of_subsingleton]\n\n"}
{"name":"CategoryTheory.Under.UnderMorphism.ext_iff","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU V : CategoryTheory.Under X\nf g : Quiver.Hom U V\n‚ä¢ Iff (Eq f g) (Eq f.right g.right)","decl":"@[ext]\ntheorem UnderMorphism.ext {X : T} {U V : Under X} {f g : U ‚ü∂ V} (h : f.right = g.right) :\n    f = g := by\n  let ‚ü®_,b,_‚ü© := f; let ‚ü®_,e,_‚ü© := g\n  congr; simp only [eq_iff_true_of_subsingleton]\n\n"}
{"name":"CategoryTheory.Under.under_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU : CategoryTheory.Under X\n‚ä¢ Eq U.left { as := PUnit.unit }","decl":"@[simp]\ntheorem under_left (U : Under X) : U.left = ‚ü®‚ü®‚ü©‚ü© := by simp only\n\n"}
{"name":"CategoryTheory.Under.id_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU : CategoryTheory.Under X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id U).right (CategoryTheory.CategoryStruct.id U.right)","decl":"@[simp]\ntheorem id_right (U : Under X) : CommaMorphism.right (ùüô U) = ùüô U.right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Under.comp_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\na b c : CategoryTheory.Under X\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).right (CategoryTheory.CategoryStruct.comp f.right g.right)","decl":"@[simp]\ntheorem comp_right (a b c : Under X) (f : a ‚ü∂ b) (g : b ‚ü∂ c) : (f ‚â´ g).right = f.right ‚â´ g.right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Under.w_assoc","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nA B : CategoryTheory.Under X\nf : Quiver.Hom A B\nZ : T\nh : Quiver.Hom B.right Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.hom (CategoryTheory.CategoryStruct.comp f.right h)) (CategoryTheory.CategoryStruct.comp B.hom h)","decl":"@[reassoc (attr := simp)]\ntheorem w {A B : Under X} (f : A ‚ü∂ B) : A.hom ‚â´ f.right = B.hom := by have := f.w; aesop_cat\n\n"}
{"name":"CategoryTheory.Under.w","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nA B : CategoryTheory.Under X\nf : Quiver.Hom A B\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.hom f.right) B.hom","decl":"@[reassoc (attr := simp)]\ntheorem w {A B : Under X} (f : A ‚ü∂ B) : A.hom ‚â´ f.right = B.hom := by have := f.w; aesop_cat\n\n"}
{"name":"CategoryTheory.Under.mk_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Under.mk f).hom f","decl":"/-- To give an object in the under category, it suffices to give an arrow with domain `X`. -/\n@[simps! right hom]\ndef mk {X Y : T} (f : X ‚ü∂ Y) : Under X :=\n  StructuredArrow.mk f\n\n"}
{"name":"CategoryTheory.Under.mk_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Under.mk f).right Y","decl":"/-- To give an object in the under category, it suffices to give an arrow with domain `X`. -/\n@[simps! right hom]\ndef mk {X Y : T} (f : X ‚ü∂ Y) : Under X :=\n  StructuredArrow.mk f\n\n"}
{"name":"CategoryTheory.Under.homMk_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU V : CategoryTheory.Under X\nf : Quiver.Hom U.right V.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp U.hom f) V.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Under.homMk f w).right f","decl":"/-- To give a morphism in the under category, it suffices to give a morphism fitting in a\n    commutative triangle. -/\n@[simps! right]\ndef homMk {U V : Under X} (f : U.right ‚ü∂ V.right) (w : U.hom ‚â´ f = V.hom := by aesop_cat) : U ‚ü∂ V :=\n  StructuredArrow.homMk f w\n\n"}
{"name":"CategoryTheory.Under.isoMk_hom_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Under X\nhr : CategoryTheory.Iso f.right g.right\nhw : Eq (CategoryTheory.CategoryStruct.comp f.hom hr.hom) g.hom\n‚ä¢ Eq (CategoryTheory.Under.isoMk hr hw).hom.right hr.hom","decl":"@[simp]\ntheorem isoMk_hom_right {f g : Under X} (hr : f.right ‚âÖ g.right) (hw : f.hom ‚â´ hr.hom = g.hom) :\n    (isoMk hr hw).hom.right = hr.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Under.isoMk_inv_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Under X\nhr : CategoryTheory.Iso f.right g.right\nhw : Eq (CategoryTheory.CategoryStruct.comp f.hom hr.hom) g.hom\n‚ä¢ Eq (CategoryTheory.Under.isoMk hr hw).inv.right hr.inv","decl":"@[simp]\ntheorem isoMk_inv_right {f g : Under X} (hr : f.right ‚âÖ g.right) (hw : f.hom ‚â´ hr.hom = g.hom) :\n    (isoMk hr hw).inv.right = hr.inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.Under.hom_right_inv_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Under X\ne : CategoryTheory.Iso f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.hom.right e.inv.right) (CategoryTheory.CategoryStruct.id f.right)","decl":"@[reassoc (attr := simp)]\nlemma hom_right_inv_right {f g : Under X} (e : f ‚âÖ g) :\n    e.hom.right ‚â´ e.inv.right = ùüô f.right := by\n  simp [‚Üê Under.comp_right]\n\n"}
{"name":"CategoryTheory.Under.hom_right_inv_right_assoc","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Under X\ne : CategoryTheory.Iso f g\nZ : T\nh : Quiver.Hom f.right Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.hom.right (CategoryTheory.CategoryStruct.comp e.inv.right h)) h","decl":"@[reassoc (attr := simp)]\nlemma hom_right_inv_right {f g : Under X} (e : f ‚âÖ g) :\n    e.hom.right ‚â´ e.inv.right = ùüô f.right := by\n  simp [‚Üê Under.comp_right]\n\n"}
{"name":"CategoryTheory.Under.inv_right_hom_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Under X\ne : CategoryTheory.Iso f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.inv.right e.hom.right) (CategoryTheory.CategoryStruct.id g.right)","decl":"@[reassoc (attr := simp)]\nlemma inv_right_hom_right {f g : Under X} (e : f ‚âÖ g) :\n    e.inv.right ‚â´ e.hom.right = ùüô g.right := by\n  simp [‚Üê Under.comp_right]\n\n"}
{"name":"CategoryTheory.Under.inv_right_hom_right_assoc","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Under X\ne : CategoryTheory.Iso f g\nZ : T\nh : Quiver.Hom g.right Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp e.inv.right (CategoryTheory.CategoryStruct.comp e.hom.right h)) h","decl":"@[reassoc (attr := simp)]\nlemma inv_right_hom_right {f g : Under X} (e : f ‚âÖ g) :\n    e.inv.right ‚â´ e.hom.right = ùüô g.right := by\n  simp [‚Üê Under.comp_right]\n\n"}
{"name":"CategoryTheory.Under.forget_obj","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU : CategoryTheory.Under X\n‚ä¢ Eq ((CategoryTheory.Under.forget X).obj U) U.right","decl":"@[simp]\ntheorem forget_obj {U : Under X} : (forget X).obj U = U.right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Under.forget_map","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU V : CategoryTheory.Under X\nf : Quiver.Hom U V\n‚ä¢ Eq ((CategoryTheory.Under.forget X).map f) f.right","decl":"@[simp]\ntheorem forget_map {U V : Under X} {f : U ‚ü∂ V} : (forget X).map f = f.right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Under.forgetCone_œÄ_app","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nself : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit X) (CategoryTheory.Functor.id T)\n‚ä¢ Eq ((CategoryTheory.Under.forgetCone X).œÄ.app self) self.hom","decl":"/-- The natural cone over the forgetful functor `Under X ‚•§ T` with cone point `X`. -/\n@[simps]\ndef forgetCone (X : T) : Limits.Cone (forget X) :=\n  { pt := X\n    œÄ := { app := Comma.hom } }\n\n"}
{"name":"CategoryTheory.Under.forgetCone_pt","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ Eq (CategoryTheory.Under.forgetCone X).pt X","decl":"/-- The natural cone over the forgetful functor `Under X ‚•§ T` with cone point `X`. -/\n@[simps]\ndef forgetCone (X : T) : Limits.Cone (forget X) :=\n  { pt := X\n    œÄ := { app := Comma.hom } }\n\n"}
{"name":"CategoryTheory.Under.map_obj_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : Quiver.Hom X Y\nU : CategoryTheory.Under Y\n‚ä¢ Eq ((CategoryTheory.Under.map f).obj U).right U.right","decl":"@[simp]\ntheorem map_obj_right : ((map f).obj U).right = U.right :=\n  rfl\n\n"}
{"name":"CategoryTheory.Under.map_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : Quiver.Hom X Y\nU : CategoryTheory.Under Y\n‚ä¢ Eq ((CategoryTheory.Under.map f).obj U).hom (CategoryTheory.CategoryStruct.comp f U.hom)","decl":"@[simp]\ntheorem map_obj_hom : ((map f).obj U).hom = f ‚â´ U.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Under.map_map_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : Quiver.Hom X Y\nU V : CategoryTheory.Under Y\ng : Quiver.Hom U V\n‚ä¢ Eq ((CategoryTheory.Under.map f).map g).right g.right","decl":"@[simp]\ntheorem map_map_right : ((map f).map g).right = g.right :=\n  rfl\n"}
{"name":"CategoryTheory.Under.mapIso_functor","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : CategoryTheory.Iso X Y\n‚ä¢ Eq (CategoryTheory.Under.mapIso f).functor (CategoryTheory.Under.map f.hom)","decl":"@[simp] lemma mapIso_functor {Y : T} (f : X ‚âÖ Y) : (mapIso f).functor = map f.hom := rfl\n"}
{"name":"CategoryTheory.Under.mapIso_inverse","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : CategoryTheory.Iso X Y\n‚ä¢ Eq (CategoryTheory.Under.mapIso f).inverse (CategoryTheory.Under.map f.inv)","decl":"@[simp] lemma mapIso_inverse {Y : T} (f : X ‚âÖ Y) : (mapIso f).inverse = map f.inv := rfl\n\n"}
{"name":"CategoryTheory.Under.mapId_eq","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nY : T\n‚ä¢ Eq (CategoryTheory.Under.map (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.Functor.id (CategoryTheory.Under Y))","decl":"/-- Mapping by the identity morphism is just the identity functor. -/\ntheorem mapId_eq (Y : T) : map (ùüô Y) = ùü≠ _ := by\n  fapply Functor.ext\n  ¬∑ intro x\n    dsimp [Under, Under.map, Comma.mapLeft]\n    simp only [Category.id_comp]\n    exact rfl\n  ¬∑ intros x y u\n    dsimp [Under, Under.map, Comma.mapLeft]\n    simp\n\n"}
{"name":"CategoryTheory.Under.mapId_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nY : T\n‚ä¢ Eq (CategoryTheory.Under.mapId Y).hom (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- Mapping by the identity morphism is just the identity functor. -/\n@[simps!]\ndef mapId (Y : T) : map (ùüô Y) ‚âÖ ùü≠ _ := eqToIso (mapId_eq Y)\n\n"}
{"name":"CategoryTheory.Under.mapId_inv","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nY : T\n‚ä¢ Eq (CategoryTheory.Under.mapId Y).inv (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- Mapping by the identity morphism is just the identity functor. -/\n@[simps!]\ndef mapId (Y : T) : map (ùüô Y) ‚âÖ ùü≠ _ := eqToIso (mapId_eq Y)\n\n"}
{"name":"CategoryTheory.Under.mapForget_eq","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y : T\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Under.map f).comp (CategoryTheory.Under.forget X)) (CategoryTheory.Under.forget Y)","decl":"/-- Mapping by `f` and then forgetting is the same as forgetting. -/\ntheorem mapForget_eq {X Y : T} (f : X ‚ü∂ Y) :\n    (map f) ‚ãô (forget X) = (forget Y) := by\n  fapply Functor.ext\n  ¬∑ dsimp [Under, Under.map]; intro x; exact rfl\n  ¬∑ intros x y u; simp\n\n"}
{"name":"CategoryTheory.Under.eqToHom_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nU V : CategoryTheory.Under X\ne : Eq U V\n‚ä¢ Eq (CategoryTheory.eqToHom e).right (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem eqToHom_right {X : T} {U V : Under X} (e : U = V) :\n    (eqToHom e).right = eqToHom (e ‚ñ∏ rfl : U.right = V.right) := by\n  subst e; rfl\n\n"}
{"name":"CategoryTheory.Under.mapComp_eq","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y Z : T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.Under.map (CategoryTheory.CategoryStruct.comp f g)) ((CategoryTheory.Under.map g).comp (CategoryTheory.Under.map f))","decl":"/-- Mapping by the composite morphism `f ‚â´ g` is the same as mapping by `f` then by `g`. -/\ntheorem mapComp_eq {X Y Z : T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    map (f ‚â´ g) = (map g) ‚ãô (map f) := by\n  fapply Functor.ext\n  ¬∑ simp [Under.map, Comma.mapLeft]\n  ¬∑ intro U V k\n    ext\n    simp\n\n"}
{"name":"CategoryTheory.Under.mapComp_inv","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y Z : T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.Under.mapComp f g).inv (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The natural isomorphism arising from `mapComp_eq`. -/\n@[simps!]\ndef mapComp {Y Z : T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : map (f ‚â´ g) ‚âÖ map g ‚ãô map f :=\n  eqToIso (mapComp_eq f g)\n\n"}
{"name":"CategoryTheory.Under.mapComp_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX Y Z : T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.Under.mapComp f g).hom (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The natural isomorphism arising from `mapComp_eq`. -/\n@[simps!]\ndef mapComp {Y Z : T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : map (f ‚â´ g) ‚âÖ map g ‚ãô map f :=\n  eqToIso (mapComp_eq f g)\n\n"}
{"name":"CategoryTheory.Under.mapCongr_inv_app","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX‚úù Y : T\nf g : Quiver.Hom X‚úù Y\nh : Eq f g\nX : CategoryTheory.Under Y\n‚ä¢ Eq ((CategoryTheory.Under.mapCongr f g h).inv.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- If `f = g`, then `map f` is naturally isomorphic to `map g`. -/\n@[simps!]\ndef mapCongr {X Y : T} (f g : X ‚ü∂ Y) (h : f = g) :\n    map f ‚âÖ map g :=\n  NatIso.ofComponents (fun A ‚Ü¶ eqToIso (by rw [h]))\n\n"}
{"name":"CategoryTheory.Under.mapCongr_hom_app","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX‚úù Y : T\nf g : Quiver.Hom X‚úù Y\nh : Eq f g\nX : CategoryTheory.Under Y\n‚ä¢ Eq ((CategoryTheory.Under.mapCongr f g h).hom.app X) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- If `f = g`, then `map f` is naturally isomorphic to `map g`. -/\n@[simps!]\ndef mapCongr {X Y : T} (f g : X ‚ü∂ Y) (h : f = g) :\n    map f ‚âÖ map g :=\n  NatIso.ofComponents (fun A ‚Ü¶ eqToIso (by rw [h]))\n\n"}
{"name":"CategoryTheory.Under.mapFunctor_map","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX‚úù Y‚úù : Opposite T\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Under.mapFunctor T).map f) (CategoryTheory.Under.map f.unop)","decl":"variable (T) in\n/-- The functor defined by the under categories.-/\n@[simps] def mapFunctor : T·µí·µñ  ‚•§ Cat where\n  obj X := Cat.of (Under X.unop)\n  map f := map f.unop\n  map_id X := mapId_eq X.unop\n  map_comp f g := mapComp_eq (g.unop) (f.unop)\n\n"}
{"name":"CategoryTheory.Under.mapFunctor_obj","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Opposite T\n‚ä¢ Eq ((CategoryTheory.Under.mapFunctor T).obj X) (CategoryTheory.Cat.of (CategoryTheory.Under (Opposite.unop X)))","decl":"variable (T) in\n/-- The functor defined by the under categories.-/\n@[simps] def mapFunctor : T·µí·µñ  ‚•§ Cat where\n  obj X := Cat.of (Under X.unop)\n  map f := map f.unop\n  map_id X := mapId_eq X.unop\n  map_comp f g := mapComp_eq (g.unop) (f.unop)\n\n"}
{"name":"CategoryTheory.Under.forget_reflects_iso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ (CategoryTheory.Under.forget X).ReflectsIsomorphisms","decl":"instance forget_reflects_iso : (forget X).ReflectsIsomorphisms where\n  reflects {Y Z} f t := by\n    let g : Z ‚ü∂ Y := Under.homMk (inv ((Under.forget X).map f))\n      ((IsIso.comp_inv_eq _).2 (Under.w f).symm)\n    dsimp [forget] at t\n    refine ‚ü®‚ü®g, ‚ü®?_,?_‚ü©‚ü©‚ü©\n    repeat (ext; simp [g])\n\n"}
{"name":"CategoryTheory.Under.forget_faithful","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ (CategoryTheory.Under.forget X).Faithful","decl":"instance forget_faithful : (forget X).Faithful where\n\n-- TODO: Show the converse holds if `T` has binary coproducts.\n"}
{"name":"CategoryTheory.Under.mono_of_mono_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Under X\nk : Quiver.Hom f g\nhk : CategoryTheory.Mono k.right\n‚ä¢ CategoryTheory.Mono k","decl":"/-- If `k.right` is a monomorphism, then `k` is a monomorphism. In other words, `Under.forget X`\nreflects epimorphisms.\nThe converse does not hold without additional assumptions on the underlying category, see\n`CategoryTheory.Under.mono_right_of_mono`.\n-/\ntheorem mono_of_mono_right {f g : Under X} (k : f ‚ü∂ g) [hk : Mono k.right] : Mono k :=\n  (forget X).mono_of_mono_map hk\n\n"}
{"name":"CategoryTheory.Under.epi_of_epi_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Under X\nk : Quiver.Hom f g\nhk : CategoryTheory.Epi k.right\n‚ä¢ CategoryTheory.Epi k","decl":"/--\nIf `k.right` is an epimorphism, then `k` is an epimorphism. In other words, `Under.forget X`\nreflects epimorphisms.\nThe converse of `CategoryTheory.Under.epi_right_of_epi`.\n\nThis lemma is not an instance, to avoid loops in type class inference.\n-/\ntheorem epi_of_epi_right {f g : Under X} (k : f ‚ü∂ g) [hk : Epi k.right] : Epi k :=\n  (forget X).epi_of_epi_map hk\n\n"}
{"name":"CategoryTheory.Under.epi_right_of_epi","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nf g : CategoryTheory.Under X\nk : Quiver.Hom f g\ninst‚úù : CategoryTheory.Epi k\n‚ä¢ CategoryTheory.Epi k.right","decl":"/--\nIf `k` is an epimorphism, then `k.right` is an epimorphism. In other words, `Under.forget X`\npreserves epimorphisms.\nThe converse of `CategoryTheory.under.epi_of_epi_right`.\n-/\ninstance epi_right_of_epi {f g : Under X} (k : f ‚ü∂ g) [Epi k] : Epi k.right := by\n  refine ‚ü®fun {Y : T} l m a => ?_‚ü©\n  let l' : g ‚ü∂ mk (g.hom ‚â´ m) := homMk l (by\n    dsimp; rw [‚Üê Under.w k, Category.assoc, a, Category.assoc])\n  -- Porting note: add type ascription here to `homMk m`\n  suffices l' = (homMk m : g ‚ü∂ mk (g.hom ‚â´ m)) by apply congrArg CommaMorphism.right this\n  rw [‚Üê cancel_epi k]; ext; apply a\n\n"}
{"name":"CategoryTheory.Under.post_obj","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor T D\nY : CategoryTheory.Under X\n‚ä¢ Eq ((CategoryTheory.Under.post F).obj Y) (CategoryTheory.Under.mk (F.map Y.hom))","decl":"/-- A functor `F : T ‚•§ D` induces a functor `Under X ‚•§ Under (F.obj X)` in the obvious way. -/\n@[simps]\ndef post {X : T} (F : T ‚•§ D) : Under X ‚•§ Under (F.obj X) where\n  obj Y := mk <| F.map Y.hom\n  map f := Under.homMk (F.map f.right)\n    (by simp only [Functor.id_obj, Functor.const_obj_obj, mk_right, mk_hom, ‚Üê F.map_comp, w])\n\n"}
{"name":"CategoryTheory.Under.post_map","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor T D\nX‚úù Y‚úù : CategoryTheory.Under X\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Under.post F).map f) (CategoryTheory.Under.homMk (F.map f.right) ‚ãØ)","decl":"/-- A functor `F : T ‚•§ D` induces a functor `Under X ‚•§ Under (F.obj X)` in the obvious way. -/\n@[simps]\ndef post {X : T} (F : T ‚•§ D) : Under X ‚•§ Under (F.obj X) where\n  obj Y := mk <| F.map Y.hom\n  map f := Under.homMk (F.map f.right)\n    (by simp only [Functor.id_obj, Functor.const_obj_obj, mk_right, mk_hom, ‚Üê F.map_comp, w])\n\n"}
{"name":"CategoryTheory.Under.post_comp","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor T D\nG : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.Under.post (F.comp G)) ((CategoryTheory.Under.post F).comp (CategoryTheory.Under.post G))","decl":"lemma post_comp {E : Type*} [Category E] (F : T ‚•§ D) (G : D ‚•§ E) :\n    post (X := X) (F ‚ãô G) = post (X := X) F ‚ãô post G :=\n  rfl\n\n"}
{"name":"CategoryTheory.Under.postComp_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor T D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.Under X‚úù\n‚ä¢ Eq ((CategoryTheory.Under.postComp F G).inv.app X).right (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.right)))","decl":"/-- `post (F ‚ãô G)` is isomorphic (actually equal) to `post F ‚ãô post G`. -/\n@[simps!]\ndef postComp {E : Type*} [Category E] (F : T ‚•§ D) (G : D ‚•§ E) :\n    post (X := X) (F ‚ãô G) ‚âÖ post F ‚ãô post G :=\n  NatIso.ofComponents (fun X ‚Ü¶ Iso.refl _)\n\n"}
{"name":"CategoryTheory.Under.postComp_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor T D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.Under X‚úù\n‚ä¢ Eq ((CategoryTheory.Under.postComp F G).hom.app X).right (CategoryTheory.CategoryStruct.id (G.obj (F.obj X.right)))","decl":"/-- `post (F ‚ãô G)` is isomorphic (actually equal) to `post F ‚ãô post G`. -/\n@[simps!]\ndef postComp {E : Type*} [Category E] (F : T ‚•§ D) (G : D ‚•§ E) :\n    post (X := X) (F ‚ãô G) ‚âÖ post F ‚ãô post G :=\n  NatIso.ofComponents (fun X ‚Ü¶ Iso.refl _)\n\n"}
{"name":"CategoryTheory.Under.postComp_hom_app_left_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor T D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.Under X‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- `post (F ‚ãô G)` is isomorphic (actually equal) to `post F ‚ãô post G`. -/\n@[simps!]\ndef postComp {E : Type*} [Category E] (F : T ‚•§ D) (G : D ‚•§ E) :\n    post (X := X) (F ‚ãô G) ‚âÖ post F ‚ãô post G :=\n  NatIso.ofComponents (fun X ‚Ü¶ Iso.refl _)\n\n"}
{"name":"CategoryTheory.Under.postComp_inv_app_left_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor T D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.Under X‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- `post (F ‚ãô G)` is isomorphic (actually equal) to `post F ‚ãô post G`. -/\n@[simps!]\ndef postComp {E : Type*} [Category E] (F : T ‚•§ D) (G : D ‚•§ E) :\n    post (X := X) (F ‚ãô G) ‚âÖ post F ‚ãô post G :=\n  NatIso.ofComponents (fun X ‚Ü¶ Iso.refl _)\n\n"}
{"name":"CategoryTheory.Under.postMap_app","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF G : CategoryTheory.Functor T D\ne : Quiver.Hom F G\nY : CategoryTheory.Under X\n‚ä¢ Eq ((CategoryTheory.Under.postMap e).app Y) (CategoryTheory.Under.homMk (e.app Y.right) ‚ãØ)","decl":"/-- A natural transformation `F ‚ü∂ G` induces a natural transformation on\n`Under X` up to `Under.map`. -/\n@[simps]\ndef postMap {F G : T ‚•§ D} (e : F ‚ü∂ G) : post (X := X) F ‚ü∂ post G ‚ãô map (e.app X) where\n  app Y := Under.homMk (e.app Y.right)\n\n"}
{"name":"CategoryTheory.Under.postCongr_inv_app_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nF G : CategoryTheory.Functor T D\ne : CategoryTheory.Iso F G\nX : CategoryTheory.Under X‚úù\n‚ä¢ Eq ((CategoryTheory.Under.postCongr e).inv.app X).right (e.inv.app X.right)","decl":"/-- If `F` and `G` are naturally isomorphic, then `Under.post F` and `Under.post G` are also\nnaturally isomorphic up to `Under.map` -/\n@[simps!]\ndef postCongr {F G : T ‚•§ D} (e : F ‚âÖ G) : post F ‚âÖ post G ‚ãô map (e.hom.app X) :=\n  NatIso.ofComponents (fun A ‚Ü¶ Under.isoMk (e.app A.right))\n\n"}
{"name":"CategoryTheory.Under.postCongr_hom_app_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nF G : CategoryTheory.Functor T D\ne : CategoryTheory.Iso F G\nX : CategoryTheory.Under X‚úù\n‚ä¢ Eq ((CategoryTheory.Under.postCongr e).hom.app X).right (e.hom.app X.right)","decl":"/-- If `F` and `G` are naturally isomorphic, then `Under.post F` and `Under.post G` are also\nnaturally isomorphic up to `Under.map` -/\n@[simps!]\ndef postCongr {F G : T ‚•§ D} (e : F ‚âÖ G) : post F ‚âÖ post G ‚ãô map (e.hom.app X) :=\n  NatIso.ofComponents (fun A ‚Ü¶ Under.isoMk (e.app A.right))\n\n"}
{"name":"CategoryTheory.Under.postCongr_hom_app_left_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nF G : CategoryTheory.Functor T D\ne : CategoryTheory.Iso F G\nX : CategoryTheory.Under X‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- If `F` and `G` are naturally isomorphic, then `Under.post F` and `Under.post G` are also\nnaturally isomorphic up to `Under.map` -/\n@[simps!]\ndef postCongr {F G : T ‚•§ D} (e : F ‚âÖ G) : post F ‚âÖ post G ‚ãô map (e.hom.app X) :=\n  NatIso.ofComponents (fun A ‚Ü¶ Under.isoMk (e.app A.right))\n\n"}
{"name":"CategoryTheory.Under.postCongr_inv_app_left_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nF G : CategoryTheory.Functor T D\ne : CategoryTheory.Iso F G\nX : CategoryTheory.Under X‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- If `F` and `G` are naturally isomorphic, then `Under.post F` and `Under.post G` are also\nnaturally isomorphic up to `Under.map` -/\n@[simps!]\ndef postCongr {F G : T ‚•§ D} (e : F ‚âÖ G) : post F ‚âÖ post G ‚ãô map (e.hom.app X) :=\n  NatIso.ofComponents (fun A ‚Ü¶ Under.isoMk (e.app A.right))\n\n"}
{"name":"CategoryTheory.Under.instFaithfulObjPost","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor T D\ninst‚úù : F.Faithful\n‚ä¢ (CategoryTheory.Under.post F).Faithful","decl":"instance [F.Faithful] : (Under.post (X := X) F).Faithful where\n  map_injective {A B} f g h := by\n    ext\n    exact F.map_injective (congrArg CommaMorphism.right h)\n\n"}
{"name":"CategoryTheory.Under.instFullObjPostOfFaithful","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor T D\ninst‚úù¬π : F.Faithful\ninst‚úù : F.Full\n‚ä¢ (CategoryTheory.Under.post F).Full","decl":"instance [F.Faithful] [F.Full] : (Under.post (X := X) F).Full where\n  map_surjective {A B} f := by\n    obtain ‚ü®a, ha‚ü© := F.map_surjective f.right\n    dsimp at a\n    have w : A.hom ‚â´ a = B.hom := F.map_injective <| by simpa [ha] using Under.w f\n    exact ‚ü®Under.homMk a, by ext; simpa‚ü©\n\n"}
{"name":"CategoryTheory.Under.instEssSurjObjPostOfFull","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor T D\ninst‚úù¬π : F.Full\ninst‚úù : F.EssSurj\n‚ä¢ (CategoryTheory.Under.post F).EssSurj","decl":"instance [F.Full] [F.EssSurj] : (Under.post (X := X) F).EssSurj where\n  mem_essImage B := by\n    obtain ‚ü®B', ‚ü®e‚ü©‚ü© := Functor.EssSurj.mem_essImage (F := F) B.right\n    obtain ‚ü®f, hf‚ü© := F.map_surjective (B.hom ‚â´ e.inv)\n    exact ‚ü®Under.mk f, ‚ü®Under.isoMk e‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Under.instIsEquivalenceObjPost","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor T D\ninst‚úù : F.IsEquivalence\n‚ä¢ (CategoryTheory.Under.post F).IsEquivalence","decl":"instance [F.IsEquivalence] : (Under.post (X := X) F).IsEquivalence where\n\n"}
{"name":"CategoryTheory.Under.postEquiv_counitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Equivalence T D\n‚ä¢ Eq (CategoryTheory.Under.postEquiv X F).counitIso (CategoryTheory.NatIso.ofComponents (fun A => CategoryTheory.Under.isoMk (F.counitIso.app A.right) ‚ãØ) ‚ãØ)","decl":"/-- An equivalence of categories induces an equivalence on under categories. -/\n@[simps]\ndef postEquiv (F : T ‚âå D) : Under X ‚âå Under (F.functor.obj X) where\n  functor := post F.functor\n  inverse := post (X := F.functor.obj X) F.inverse ‚ãô Under.map (F.unitIso.hom.app X)\n  unitIso := NatIso.ofComponents (fun A ‚Ü¶ Under.isoMk (F.unitIso.app A.right))\n  counitIso := NatIso.ofComponents (fun A ‚Ü¶ Under.isoMk (F.counitIso.app A.right))\n\n"}
{"name":"CategoryTheory.Under.postEquiv_functor","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Equivalence T D\n‚ä¢ Eq (CategoryTheory.Under.postEquiv X F).functor (CategoryTheory.Under.post F.functor)","decl":"/-- An equivalence of categories induces an equivalence on under categories. -/\n@[simps]\ndef postEquiv (F : T ‚âå D) : Under X ‚âå Under (F.functor.obj X) where\n  functor := post F.functor\n  inverse := post (X := F.functor.obj X) F.inverse ‚ãô Under.map (F.unitIso.hom.app X)\n  unitIso := NatIso.ofComponents (fun A ‚Ü¶ Under.isoMk (F.unitIso.app A.right))\n  counitIso := NatIso.ofComponents (fun A ‚Ü¶ Under.isoMk (F.counitIso.app A.right))\n\n"}
{"name":"CategoryTheory.Under.postEquiv_inverse","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Equivalence T D\n‚ä¢ Eq (CategoryTheory.Under.postEquiv X F).inverse ((CategoryTheory.Under.post F.inverse).comp (CategoryTheory.Under.map (F.unitIso.hom.app X)))","decl":"/-- An equivalence of categories induces an equivalence on under categories. -/\n@[simps]\ndef postEquiv (F : T ‚âå D) : Under X ‚âå Under (F.functor.obj X) where\n  functor := post F.functor\n  inverse := post (X := F.functor.obj X) F.inverse ‚ãô Under.map (F.unitIso.hom.app X)\n  unitIso := NatIso.ofComponents (fun A ‚Ü¶ Under.isoMk (F.unitIso.app A.right))\n  counitIso := NatIso.ofComponents (fun A ‚Ü¶ Under.isoMk (F.counitIso.app A.right))\n\n"}
{"name":"CategoryTheory.Under.postEquiv_unitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Equivalence T D\n‚ä¢ Eq (CategoryTheory.Under.postEquiv X F).unitIso (CategoryTheory.NatIso.ofComponents (fun A => CategoryTheory.Under.isoMk (F.unitIso.app A.right) ‚ãØ) ‚ãØ)","decl":"/-- An equivalence of categories induces an equivalence on under categories. -/\n@[simps]\ndef postEquiv (F : T ‚âå D) : Under X ‚âå Under (F.functor.obj X) where\n  functor := post F.functor\n  inverse := post (X := F.functor.obj X) F.inverse ‚ãô Under.map (F.unitIso.hom.app X)\n  unitIso := NatIso.ofComponents (fun A ‚Ü¶ Under.isoMk (F.unitIso.app A.right))\n  counitIso := NatIso.ofComponents (fun A ‚Ü¶ Under.isoMk (F.counitIso.app A.right))\n\n"}
{"name":"CategoryTheory.StructuredArrow.toUnder_map_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor D T\nX‚úù Y‚úù : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit X) (F.comp (CategoryTheory.Functor.id T))\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.toUnder X F).map f).right (F.map f.right)","decl":"/-- Reinterpreting an `F`-structured arrow `X ‚ü∂ F.obj d` as an arrow under `X` induces a functor\n    `StructuredArrow X F ‚•§ Under X`. -/\n@[simps!]\ndef toUnder (X : T) (F : D ‚•§ T) : StructuredArrow X F ‚•§ Under X :=\n  StructuredArrow.pre X F (ùü≠ T)\n\n"}
{"name":"CategoryTheory.StructuredArrow.toUnder_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nF : CategoryTheory.Functor D T\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit X‚úù) (F.comp (CategoryTheory.Functor.id T))\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.toUnder X‚úù F).obj X).hom X.hom","decl":"/-- Reinterpreting an `F`-structured arrow `X ‚ü∂ F.obj d` as an arrow under `X` induces a functor\n    `StructuredArrow X F ‚•§ Under X`. -/\n@[simps!]\ndef toUnder (X : T) (F : D ‚•§ T) : StructuredArrow X F ‚•§ Under X :=\n  StructuredArrow.pre X F (ùü≠ T)\n\n"}
{"name":"CategoryTheory.StructuredArrow.toUnder_map_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor D T\nX‚úù Y‚úù : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit X) (F.comp (CategoryTheory.Functor.id T))\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.toUnder X F).map f).left (CategoryTheory.CategoryStruct.id X‚úù.left)","decl":"/-- Reinterpreting an `F`-structured arrow `X ‚ü∂ F.obj d` as an arrow under `X` induces a functor\n    `StructuredArrow X F ‚•§ Under X`. -/\n@[simps!]\ndef toUnder (X : T) (F : D ‚•§ T) : StructuredArrow X F ‚•§ Under X :=\n  StructuredArrow.pre X F (ùü≠ T)\n\n"}
{"name":"CategoryTheory.StructuredArrow.toUnder_obj_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nF : CategoryTheory.Functor D T\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit X‚úù) (F.comp (CategoryTheory.Functor.id T))\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.toUnder X‚úù F).obj X).right (F.obj X.right)","decl":"/-- Reinterpreting an `F`-structured arrow `X ‚ü∂ F.obj d` as an arrow under `X` induces a functor\n    `StructuredArrow X F ‚•§ Under X`. -/\n@[simps!]\ndef toUnder (X : T) (F : D ‚•§ T) : StructuredArrow X F ‚•§ Under X :=\n  StructuredArrow.pre X F (ùü≠ T)\n\n"}
{"name":"CategoryTheory.StructuredArrow.toUnder_obj_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : T\nF : CategoryTheory.Functor D T\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit X‚úù) (F.comp (CategoryTheory.Functor.id T))\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.toUnder X‚úù F).obj X).left X.left","decl":"/-- Reinterpreting an `F`-structured arrow `X ‚ü∂ F.obj d` as an arrow under `X` induces a functor\n    `StructuredArrow X F ‚•§ Under X`. -/\n@[simps!]\ndef toUnder (X : T) (F : D ‚•§ T) : StructuredArrow X F ‚•§ Under X :=\n  StructuredArrow.pre X F (ùü≠ T)\n\n"}
{"name":"CategoryTheory.StructuredArrow.instFaithfulUnderToUnder","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor D T\ninst‚úù : F.Faithful\n‚ä¢ (CategoryTheory.StructuredArrow.toUnder X F).Faithful","decl":"instance (X : T) (F : D ‚•§ T) [F.Faithful] : (toUnder X F).Faithful :=\n  show (StructuredArrow.pre _ _ _).Faithful from inferInstance\n\n"}
{"name":"CategoryTheory.StructuredArrow.instFullUnderToUnder","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor D T\ninst‚úù : F.Full\n‚ä¢ (CategoryTheory.StructuredArrow.toUnder X F).Full","decl":"instance (X : T) (F : D ‚•§ T) [F.Full] : (toUnder X F).Full :=\n  show (StructuredArrow.pre _ _ _).Full from inferInstance\n\n"}
{"name":"CategoryTheory.StructuredArrow.instEssSurjUnderToUnder","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor D T\ninst‚úù : F.EssSurj\n‚ä¢ (CategoryTheory.StructuredArrow.toUnder X F).EssSurj","decl":"instance (X : T) (F : D ‚•§ T) [F.EssSurj] : (toUnder X F).EssSurj :=\n  show (StructuredArrow.pre _ _ _).EssSurj from inferInstance\n\n"}
{"name":"CategoryTheory.StructuredArrow.isEquivalence_toUnder","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : T\nF : CategoryTheory.Functor D T\ninst‚úù : F.IsEquivalence\n‚ä¢ (CategoryTheory.StructuredArrow.toUnder X F).IsEquivalence","decl":"/-- An equivalence `F` induces an equivalence `StructuredArrow X F ‚âå Under X`. -/\ninstance isEquivalence_toUnder (X : T) (F : D ‚•§ T) [F.IsEquivalence] :\n    (toUnder X F).IsEquivalence :=\n  StructuredArrow.isEquivalence_pre _ _ _\n\n"}
{"name":"CategoryTheory.Functor.toOver_obj_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nS : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} S\nF : CategoryTheory.Functor S T\nX : T\nf : (Y : S) ‚Üí Quiver.Hom (F.obj Y) X\nh : ‚àÄ {Y Z : S} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (F.map g) (f Z)) (f Y)\nY : S\n‚ä¢ Eq ((F.toOver X f h).obj Y).left (F.obj Y)","decl":"/-- Given `X : T`, to upgrade a functor `F : S ‚•§ T` to a functor `S ‚•§ Over X`, it suffices to\n    provide maps `F.obj Y ‚ü∂ X` for all `Y` making the obvious triangles involving all `F.map g`\n    commute. -/\n@[simps! obj_left map_left]\ndef toOver (F : S ‚•§ T) (X : T) (f : (Y : S) ‚Üí F.obj Y ‚ü∂ X)\n    (h : ‚àÄ {Y Z : S} (g : Y ‚ü∂ Z), F.map g ‚â´ f Z = f Y) : S ‚•§ Over X :=\n  F.toCostructuredArrow (ùü≠ _) X f h\n\n"}
{"name":"CategoryTheory.Functor.toOver_map_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nS : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} S\nF : CategoryTheory.Functor S T\nX : T\nf : (Y : S) ‚Üí Quiver.Hom (F.obj Y) X\nh : ‚àÄ {Y Z : S} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (F.map g) (f Z)) (f Y)\nX‚úù Y‚úù : S\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((F.toOver X f h).map g).left (F.map g)","decl":"/-- Given `X : T`, to upgrade a functor `F : S ‚•§ T` to a functor `S ‚•§ Over X`, it suffices to\n    provide maps `F.obj Y ‚ü∂ X` for all `Y` making the obvious triangles involving all `F.map g`\n    commute. -/\n@[simps! obj_left map_left]\ndef toOver (F : S ‚•§ T) (X : T) (f : (Y : S) ‚Üí F.obj Y ‚ü∂ X)\n    (h : ‚àÄ {Y Z : S} (g : Y ‚ü∂ Z), F.map g ‚â´ f Z = f Y) : S ‚•§ Over X :=\n  F.toCostructuredArrow (ùü≠ _) X f h\n\n"}
{"name":"CategoryTheory.Functor.toOver_comp_forget","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nS : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} S\nF : CategoryTheory.Functor S T\nX : T\nf : (Y : S) ‚Üí Quiver.Hom (F.obj Y) X\nh : ‚àÄ {Y Z : S} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (F.map g) (f Z)) (f Y)\n‚ä¢ Eq ((F.toOver X f ‚ãØ).comp (CategoryTheory.Over.forget X)) F","decl":"@[simp]\nlemma toOver_comp_forget (F : S ‚•§ T) (X : T) (f : (Y : S) ‚Üí F.obj Y ‚ü∂ X)\n    (h : ‚àÄ {Y Z : S} (g : Y ‚ü∂ Z), F.map g ‚â´ f Z = f Y) : F.toOver X f h ‚ãô Over.forget _ = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.toUnder_obj_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nS : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} S\nF : CategoryTheory.Functor S T\nX : T\nf : (Y : S) ‚Üí Quiver.Hom X (F.obj Y)\nh : ‚àÄ {Y Z : S} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (f Y) (F.map g)) (f Z)\nY : S\n‚ä¢ Eq ((F.toUnder X f h).obj Y).right (F.obj Y)","decl":"/-- Given `X : T`, to upgrade a functor `F : S ‚•§ T` to a functor `S ‚•§ Under X`, it suffices to\n    provide maps `X ‚ü∂ F.obj Y` for all `Y` making the obvious triangles involving all `F.map g`\n    commute. -/\n@[simps! obj_right map_right]\ndef toUnder (F : S ‚•§ T) (X : T) (f : (Y : S) ‚Üí X ‚ü∂ F.obj Y)\n    (h : ‚àÄ {Y Z : S} (g : Y ‚ü∂ Z), f Y ‚â´ F.map g = f Z) : S ‚•§ Under X :=\n  F.toStructuredArrow X (ùü≠ _) f h\n\n"}
{"name":"CategoryTheory.Functor.toUnder_map_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nS : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} S\nF : CategoryTheory.Functor S T\nX : T\nf : (Y : S) ‚Üí Quiver.Hom X (F.obj Y)\nh : ‚àÄ {Y Z : S} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (f Y) (F.map g)) (f Z)\nX‚úù Y‚úù : S\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((F.toUnder X f h).map g).right (F.map g)","decl":"/-- Given `X : T`, to upgrade a functor `F : S ‚•§ T` to a functor `S ‚•§ Under X`, it suffices to\n    provide maps `X ‚ü∂ F.obj Y` for all `Y` making the obvious triangles involving all `F.map g`\n    commute. -/\n@[simps! obj_right map_right]\ndef toUnder (F : S ‚•§ T) (X : T) (f : (Y : S) ‚Üí X ‚ü∂ F.obj Y)\n    (h : ‚àÄ {Y Z : S} (g : Y ‚ü∂ Z), f Y ‚â´ F.map g = f Z) : S ‚•§ Under X :=\n  F.toStructuredArrow X (ùü≠ _) f h\n\n"}
{"name":"CategoryTheory.Functor.toUnder_comp_forget","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nS : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} S\nF : CategoryTheory.Functor S T\nX : T\nf : (Y : S) ‚Üí Quiver.Hom X (F.obj Y)\nh : ‚àÄ {Y Z : S} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (f Y) (F.map g)) (f Z)\n‚ä¢ Eq ((F.toUnder X f ‚ãØ).comp (CategoryTheory.Under.forget X)) F","decl":"@[simp]\nlemma toUnder_comp_forget (F : S ‚•§ T) (X : T) (f : (Y : S) ‚Üí X ‚ü∂ F.obj Y)\n    (h : ‚àÄ {Y Z : S} (g : Y ‚ü∂ Z), f Y ‚â´ F.map g = f Z) : F.toUnder X f h ‚ãô Under.forget _ = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY‚úù : T\nX : D\nY : CategoryTheory.StructuredArrow X (CategoryTheory.StructuredArrow.proj Y‚úù F)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor F Y‚úù X).obj Y).hom Y.right.hom","decl":"/-- A functor from the structured arrow category on the projection functor for any structured\narrow category. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.functor (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow X (StructuredArrow.proj Y F) ‚•§ StructuredArrow Y (Under.forget X ‚ãô F) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _ ‚ãô StructuredArrow.proj Y _) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_left_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY : T\nX : D\nX‚úù Y‚úù : CategoryTheory.StructuredArrow X (CategoryTheory.StructuredArrow.proj Y F)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- A functor from the structured arrow category on the projection functor for any structured\narrow category. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.functor (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow X (StructuredArrow.proj Y F) ‚•§ StructuredArrow Y (Under.forget X ‚ãô F) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _ ‚ãô StructuredArrow.proj Y _) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_left_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY‚úù : T\nX : D\nY : CategoryTheory.StructuredArrow X (CategoryTheory.StructuredArrow.proj Y‚úù F)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor F Y‚úù X).obj Y).right.left.as PUnit.unit","decl":"/-- A functor from the structured arrow category on the projection functor for any structured\narrow category. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.functor (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow X (StructuredArrow.proj Y F) ‚•§ StructuredArrow Y (Under.forget X ‚ãô F) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _ ‚ãô StructuredArrow.proj Y _) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY : T\nX : D\nX‚úù Y‚úù : CategoryTheory.StructuredArrow X (CategoryTheory.StructuredArrow.proj Y F)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor F Y X).map g).right.right g.right.right","decl":"/-- A functor from the structured arrow category on the projection functor for any structured\narrow category. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.functor (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow X (StructuredArrow.proj Y F) ‚•§ StructuredArrow Y (Under.forget X ‚ãô F) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _ ‚ãô StructuredArrow.proj Y _) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_left_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY‚úù : T\nX : D\nY : CategoryTheory.StructuredArrow X (CategoryTheory.StructuredArrow.proj Y‚úù F)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor F Y‚úù X).obj Y).left.as PUnit.unit","decl":"/-- A functor from the structured arrow category on the projection functor for any structured\narrow category. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.functor (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow X (StructuredArrow.proj Y F) ‚•§ StructuredArrow Y (Under.forget X ‚ãô F) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _ ‚ãô StructuredArrow.proj Y _) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_map_right_left_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY : T\nX : D\nX‚úù Y‚úù : CategoryTheory.StructuredArrow X (CategoryTheory.StructuredArrow.proj Y F)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- A functor from the structured arrow category on the projection functor for any structured\narrow category. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.functor (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow X (StructuredArrow.proj Y F) ‚•§ StructuredArrow Y (Under.forget X ‚ãô F) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _ ‚ãô StructuredArrow.proj Y _) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY‚úù : T\nX : D\nY : CategoryTheory.StructuredArrow X (CategoryTheory.StructuredArrow.proj Y‚úù F)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor F Y‚úù X).obj Y).right.hom Y.hom","decl":"/-- A functor from the structured arrow category on the projection functor for any structured\narrow category. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.functor (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow X (StructuredArrow.proj Y F) ‚•§ StructuredArrow Y (Under.forget X ‚ãô F) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _ ‚ãô StructuredArrow.proj Y _) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor_obj_right_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY‚úù : T\nX : D\nY : CategoryTheory.StructuredArrow X (CategoryTheory.StructuredArrow.proj Y‚úù F)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.functor F Y‚úù X).obj Y).right.right Y.right.right","decl":"/-- A functor from the structured arrow category on the projection functor for any structured\narrow category. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.functor (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow X (StructuredArrow.proj Y F) ‚•§ StructuredArrow Y (Under.forget X ‚ãô F) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _ ‚ãô StructuredArrow.proj Y _) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY : T\nX : D\nX‚úù Y‚úù : CategoryTheory.StructuredArrow Y ((CategoryTheory.Under.forget X).comp F)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse F Y X).map g).right.right g.right.right","decl":"/-- The inverse functor of `ofStructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.inverse (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow Y (Under.forget X ‚ãô F) ‚•§ StructuredArrow X (StructuredArrow.proj Y F) :=\n  Functor.toStructuredArrow\n    (Functor.toStructuredArrow (StructuredArrow.proj Y _ ‚ãô Under.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY‚úù : T\nX : D\nY : CategoryTheory.StructuredArrow Y‚úù ((CategoryTheory.Under.forget X).comp F)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse F Y‚úù X).obj Y).hom Y.right.hom","decl":"/-- The inverse functor of `ofStructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.inverse (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow Y (Under.forget X ‚ãô F) ‚•§ StructuredArrow X (StructuredArrow.proj Y F) :=\n  Functor.toStructuredArrow\n    (Functor.toStructuredArrow (StructuredArrow.proj Y _ ‚ãô Under.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_left_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY : T\nX : D\nX‚úù Y‚úù : CategoryTheory.StructuredArrow Y ((CategoryTheory.Under.forget X).comp F)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor of `ofStructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.inverse (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow Y (Under.forget X ‚ãô F) ‚•§ StructuredArrow X (StructuredArrow.proj Y F) :=\n  Functor.toStructuredArrow\n    (Functor.toStructuredArrow (StructuredArrow.proj Y _ ‚ãô Under.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY‚úù : T\nX : D\nY : CategoryTheory.StructuredArrow Y‚úù ((CategoryTheory.Under.forget X).comp F)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse F Y‚úù X).obj Y).right.hom Y.hom","decl":"/-- The inverse functor of `ofStructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.inverse (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow Y (Under.forget X ‚ãô F) ‚•§ StructuredArrow X (StructuredArrow.proj Y F) :=\n  Functor.toStructuredArrow\n    (Functor.toStructuredArrow (StructuredArrow.proj Y _ ‚ãô Under.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY‚úù : T\nX : D\nY : CategoryTheory.StructuredArrow Y‚úù ((CategoryTheory.Under.forget X).comp F)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse F Y‚úù X).obj Y).right.right Y.right.right","decl":"/-- The inverse functor of `ofStructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.inverse (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow Y (Under.forget X ‚ãô F) ‚•§ StructuredArrow X (StructuredArrow.proj Y F) :=\n  Functor.toStructuredArrow\n    (Functor.toStructuredArrow (StructuredArrow.proj Y _ ‚ãô Under.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_left_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY‚úù : T\nX : D\nY : CategoryTheory.StructuredArrow Y‚úù ((CategoryTheory.Under.forget X).comp F)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse F Y‚úù X).obj Y).left.as PUnit.unit","decl":"/-- The inverse functor of `ofStructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.inverse (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow Y (Under.forget X ‚ãô F) ‚•§ StructuredArrow X (StructuredArrow.proj Y F) :=\n  Functor.toStructuredArrow\n    (Functor.toStructuredArrow (StructuredArrow.proj Y _ ‚ãô Under.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_map_right_left_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY : T\nX : D\nX‚úù Y‚úù : CategoryTheory.StructuredArrow Y ((CategoryTheory.Under.forget X).comp F)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor of `ofStructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.inverse (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow Y (Under.forget X ‚ãô F) ‚•§ StructuredArrow X (StructuredArrow.proj Y F) :=\n  Functor.toStructuredArrow\n    (Functor.toStructuredArrow (StructuredArrow.proj Y _ ‚ãô Under.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse_obj_right_left_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D T\nY‚úù : T\nX : D\nY : CategoryTheory.StructuredArrow Y‚úù ((CategoryTheory.Under.forget X).comp F)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofStructuredArrowProjEquivalence.inverse F Y‚úù X).obj Y).right.left.as PUnit.unit","decl":"/-- The inverse functor of `ofStructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofStructuredArrowProjEquivalence.inverse (F : D ‚•§ T) (Y : T) (X : D) :\n    StructuredArrow Y (Under.forget X ‚ãô F) ‚•§ StructuredArrow X (StructuredArrow.proj Y F) :=\n  Functor.toStructuredArrow\n    (Functor.toStructuredArrow (StructuredArrow.proj Y _ ‚ãô Under.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.right.hom) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.StructuredArrow X (CategoryTheory.Functor.diag T)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofDiagEquivalence.functor X).obj Y).right.right Y.right","decl":"/-- The canonical functor from the structured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the structured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    StructuredArrow X (Functor.diag _) ‚•§ StructuredArrow X.2 (Under.forget X.1) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _) _\n      (fun f => by exact f.hom.1) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.hom.2) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.StructuredArrow X (CategoryTheory.Functor.diag T)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofDiagEquivalence.functor X).obj Y).right.hom Y.hom.1","decl":"/-- The canonical functor from the structured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the structured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    StructuredArrow X (Functor.diag _) ‚•§ StructuredArrow X.2 (Under.forget X.1) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _) _\n      (fun f => by exact f.hom.1) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.hom.2) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_right_left_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nX‚úù Y‚úù : CategoryTheory.StructuredArrow X (CategoryTheory.Functor.diag T)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The canonical functor from the structured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the structured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    StructuredArrow X (Functor.diag _) ‚•§ StructuredArrow X.2 (Under.forget X.1) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _) _\n      (fun f => by exact f.hom.1) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.hom.2) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.StructuredArrow X (CategoryTheory.Functor.diag T)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofDiagEquivalence.functor X).obj Y).hom Y.hom.2","decl":"/-- The canonical functor from the structured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the structured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    StructuredArrow X (Functor.diag _) ‚•§ StructuredArrow X.2 (Under.forget X.1) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _) _\n      (fun f => by exact f.hom.1) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.hom.2) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_left_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nX‚úù Y‚úù : CategoryTheory.StructuredArrow X (CategoryTheory.Functor.diag T)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The canonical functor from the structured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the structured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    StructuredArrow X (Functor.diag _) ‚•§ StructuredArrow X.2 (Under.forget X.1) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _) _\n      (fun f => by exact f.hom.1) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.hom.2) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_map_right_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nX‚úù Y‚úù : CategoryTheory.StructuredArrow X (CategoryTheory.Functor.diag T)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofDiagEquivalence.functor X).map g).right.right g.right","decl":"/-- The canonical functor from the structured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the structured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    StructuredArrow X (Functor.diag _) ‚•§ StructuredArrow X.2 (Under.forget X.1) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _) _\n      (fun f => by exact f.hom.1) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.hom.2) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_right_left_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.StructuredArrow X (CategoryTheory.Functor.diag T)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofDiagEquivalence.functor X).obj Y).right.left.as PUnit.unit","decl":"/-- The canonical functor from the structured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the structured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    StructuredArrow X (Functor.diag _) ‚•§ StructuredArrow X.2 (Under.forget X.1) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _) _\n      (fun f => by exact f.hom.1) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.hom.2) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofDiagEquivalence.functor_obj_left_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.StructuredArrow X (CategoryTheory.Functor.diag T)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofDiagEquivalence.functor X).obj Y).left.as PUnit.unit","decl":"/-- The canonical functor from the structured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the structured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    StructuredArrow X (Functor.diag _) ‚•§ StructuredArrow X.2 (Under.forget X.1) :=\n  Functor.toStructuredArrow\n    (Functor.toUnder (StructuredArrow.proj X _) _\n      (fun f => by exact f.hom.1) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.hom.2) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.StructuredArrow X.2 (CategoryTheory.Under.forget X.1)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse X).obj Y).hom { fst := Y.right.hom, snd := Y.hom }","decl":"/-- The inverse functor of `ofDiagEquivalence.functor`. -/\n@[simps!]\ndef ofDiagEquivalence.inverse (X : T √ó T) :\n    StructuredArrow X.2 (Under.forget X.1) ‚•§ StructuredArrow X (Functor.diag _) :=\n  Functor.toStructuredArrow (StructuredArrow.proj _ _ ‚ãô Under.forget _) _ _\n    (fun f => (f.right.hom, f.hom)) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_map_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nX‚úù Y‚úù : CategoryTheory.StructuredArrow X.2 (CategoryTheory.Under.forget X.1)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse X).map g).right g.right.right","decl":"/-- The inverse functor of `ofDiagEquivalence.functor`. -/\n@[simps!]\ndef ofDiagEquivalence.inverse (X : T √ó T) :\n    StructuredArrow X.2 (Under.forget X.1) ‚•§ StructuredArrow X (Functor.diag _) :=\n  Functor.toStructuredArrow (StructuredArrow.proj _ _ ‚ãô Under.forget _) _ _\n    (fun f => (f.right.hom, f.hom)) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.StructuredArrow X.2 (CategoryTheory.Under.forget X.1)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse X).obj Y).right Y.right.right","decl":"/-- The inverse functor of `ofDiagEquivalence.functor`. -/\n@[simps!]\ndef ofDiagEquivalence.inverse (X : T √ó T) :\n    StructuredArrow X.2 (Under.forget X.1) ‚•§ StructuredArrow X (Functor.diag _) :=\n  Functor.toStructuredArrow (StructuredArrow.proj _ _ ‚ãô Under.forget _) _ _\n    (fun f => (f.right.hom, f.hom)) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_obj_left_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.StructuredArrow X.2 (CategoryTheory.Under.forget X.1)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse X).obj Y).left.as PUnit.unit","decl":"/-- The inverse functor of `ofDiagEquivalence.functor`. -/\n@[simps!]\ndef ofDiagEquivalence.inverse (X : T √ó T) :\n    StructuredArrow X.2 (Under.forget X.1) ‚•§ StructuredArrow X (Functor.diag _) :=\n  Functor.toStructuredArrow (StructuredArrow.proj _ _ ‚ãô Under.forget _) _ _\n    (fun f => (f.right.hom, f.hom)) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofDiagEquivalence.inverse_map_left_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nX‚úù Y‚úù : CategoryTheory.StructuredArrow X.2 (CategoryTheory.Under.forget X.1)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor of `ofDiagEquivalence.functor`. -/\n@[simps!]\ndef ofDiagEquivalence.inverse (X : T √ó T) :\n    StructuredArrow X.2 (Under.forget X.1) ‚•§ StructuredArrow X (Functor.diag _) :=\n  Functor.toStructuredArrow (StructuredArrow.proj _ _ ‚ãô Under.forget _) _ _\n    (fun f => (f.right.hom, f.hom)) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_map_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX‚úù Y‚úù : CategoryTheory.StructuredArrow c (CategoryTheory.Comma.fst F G)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor F G c).map f).left (CategoryTheory.Under.homMk f.right.left ‚ãØ)","decl":"/-- The functor used to define the equivalence `ofCommaSndEquivalence`. -/\n@[simps]\ndef ofCommaSndEquivalenceFunctor (c : C) :\n    StructuredArrow c (Comma.fst F G) ‚•§ Comma (Under.forget c ‚ãô F) G where\n  obj X := ‚ü®Under.mk X.hom, X.right.right, X.right.hom‚ü©\n  map f := ‚ü®Under.homMk f.right.left (by simpa using f.w.symm), f.right.right, by simp‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_map_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX‚úù Y‚úù : CategoryTheory.StructuredArrow c (CategoryTheory.Comma.fst F G)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor F G c).map f).right f.right.right","decl":"/-- The functor used to define the equivalence `ofCommaSndEquivalence`. -/\n@[simps]\ndef ofCommaSndEquivalenceFunctor (c : C) :\n    StructuredArrow c (Comma.fst F G) ‚•§ Comma (Under.forget c ‚ãô F) G where\n  obj X := ‚ü®Under.mk X.hom, X.right.right, X.right.hom‚ü©\n  map f := ‚ü®Under.homMk f.right.left (by simpa using f.w.symm), f.right.right, by simp‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_obj_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX : CategoryTheory.StructuredArrow c (CategoryTheory.Comma.fst F G)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor F G c).obj X).left (CategoryTheory.Under.mk X.hom)","decl":"/-- The functor used to define the equivalence `ofCommaSndEquivalence`. -/\n@[simps]\ndef ofCommaSndEquivalenceFunctor (c : C) :\n    StructuredArrow c (Comma.fst F G) ‚•§ Comma (Under.forget c ‚ãô F) G where\n  obj X := ‚ü®Under.mk X.hom, X.right.right, X.right.hom‚ü©\n  map f := ‚ü®Under.homMk f.right.left (by simpa using f.w.symm), f.right.right, by simp‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_obj_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX : CategoryTheory.StructuredArrow c (CategoryTheory.Comma.fst F G)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor F G c).obj X).right X.right.right","decl":"/-- The functor used to define the equivalence `ofCommaSndEquivalence`. -/\n@[simps]\ndef ofCommaSndEquivalenceFunctor (c : C) :\n    StructuredArrow c (Comma.fst F G) ‚•§ Comma (Under.forget c ‚ãô F) G where\n  obj X := ‚ü®Under.mk X.hom, X.right.right, X.right.hom‚ü©\n  map f := ‚ü®Under.homMk f.right.left (by simpa using f.w.symm), f.right.right, by simp‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX : CategoryTheory.StructuredArrow c (CategoryTheory.Comma.fst F G)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor F G c).obj X).hom X.right.hom","decl":"/-- The functor used to define the equivalence `ofCommaSndEquivalence`. -/\n@[simps]\ndef ofCommaSndEquivalenceFunctor (c : C) :\n    StructuredArrow c (Comma.fst F G) ‚•§ Comma (Under.forget c ‚ãô F) G where\n  obj X := ‚ü®Under.mk X.hom, X.right.right, X.right.hom‚ü©\n  map f := ‚ü®Under.homMk f.right.left (by simpa using f.w.symm), f.right.right, by simp‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_map_right_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX‚úù Y‚úù : CategoryTheory.Comma ((CategoryTheory.Under.forget c).comp F) G\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse F G c).map g).right.right g.right","decl":"/-- The inverse functor used to define the equivalence `ofCommaSndEquivalence`. -/\n@[simps!]\ndef ofCommaSndEquivalenceInverse (c : C) :\n    Comma (Under.forget c ‚ãô F) G ‚•§ StructuredArrow c (Comma.fst F G) :=\n  Functor.toStructuredArrow (Comma.preLeft (Under.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nY : CategoryTheory.Comma ((CategoryTheory.Under.forget c).comp F) G\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse F G c).obj Y).right.hom Y.hom","decl":"/-- The inverse functor used to define the equivalence `ofCommaSndEquivalence`. -/\n@[simps!]\ndef ofCommaSndEquivalenceInverse (c : C) :\n    Comma (Under.forget c ‚ãô F) G ‚•§ StructuredArrow c (Comma.fst F G) :=\n  Functor.toStructuredArrow (Comma.preLeft (Under.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nY : CategoryTheory.Comma ((CategoryTheory.Under.forget c).comp F) G\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse F G c).obj Y).hom Y.left.hom","decl":"/-- The inverse functor used to define the equivalence `ofCommaSndEquivalence`. -/\n@[simps!]\ndef ofCommaSndEquivalenceInverse (c : C) :\n    Comma (Under.forget c ‚ãô F) G ‚•§ StructuredArrow c (Comma.fst F G) :=\n  Functor.toStructuredArrow (Comma.preLeft (Under.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nY : CategoryTheory.Comma ((CategoryTheory.Under.forget c).comp F) G\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse F G c).obj Y).right.left Y.left.right","decl":"/-- The inverse functor used to define the equivalence `ofCommaSndEquivalence`. -/\n@[simps!]\ndef ofCommaSndEquivalenceInverse (c : C) :\n    Comma (Under.forget c ‚ãô F) G ‚•§ StructuredArrow c (Comma.fst F G) :=\n  Functor.toStructuredArrow (Comma.preLeft (Under.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_left_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nY : CategoryTheory.Comma ((CategoryTheory.Under.forget c).comp F) G\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse F G c).obj Y).left.as PUnit.unit","decl":"/-- The inverse functor used to define the equivalence `ofCommaSndEquivalence`. -/\n@[simps!]\ndef ofCommaSndEquivalenceInverse (c : C) :\n    Comma (Under.forget c ‚ãô F) G ‚•§ StructuredArrow c (Comma.fst F G) :=\n  Functor.toStructuredArrow (Comma.preLeft (Under.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_map_left_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX‚úù Y‚úù : CategoryTheory.Comma ((CategoryTheory.Under.forget c).comp F) G\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor used to define the equivalence `ofCommaSndEquivalence`. -/\n@[simps!]\ndef ofCommaSndEquivalenceInverse (c : C) :\n    Comma (Under.forget c ‚ãô F) G ‚•§ StructuredArrow c (Comma.fst F G) :=\n  Functor.toStructuredArrow (Comma.preLeft (Under.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_obj_right_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nY : CategoryTheory.Comma ((CategoryTheory.Under.forget c).comp F) G\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse F G c).obj Y).right.right Y.right","decl":"/-- The inverse functor used to define the equivalence `ofCommaSndEquivalence`. -/\n@[simps!]\ndef ofCommaSndEquivalenceInverse (c : C) :\n    Comma (Under.forget c ‚ãô F) G ‚•§ StructuredArrow c (Comma.fst F G) :=\n  Functor.toStructuredArrow (Comma.preLeft (Under.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse_map_right_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX‚úù Y‚úù : CategoryTheory.Comma ((CategoryTheory.Under.forget c).comp F) G\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse F G c).map g).right.left g.left.right","decl":"/-- The inverse functor used to define the equivalence `ofCommaSndEquivalence`. -/\n@[simps!]\ndef ofCommaSndEquivalenceInverse (c : C) :\n    Comma (Under.forget c ‚ãô F) G ‚•§ StructuredArrow c (Comma.fst F G) :=\n  Functor.toStructuredArrow (Comma.preLeft (Under.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalence_counitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\n‚ä¢ Eq (CategoryTheory.StructuredArrow.ofCommaSndEquivalence F G c).counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl (((CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse F G c).comp (CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor F G c)).obj x)) ‚ãØ)","decl":"/-- There is a canonical equivalence between the structured arrow category with domain `c` on\nthe functor `Comma.fst F G : Comma F G ‚•§ F` and the comma category over\n`Under.forget c ‚ãô F : Under c ‚•§ T` and `G`. -/\n@[simps]\ndef ofCommaSndEquivalence (c : C) :\n    StructuredArrow c (Comma.fst F G) ‚âå Comma (Under.forget c ‚ãô F) G where\n  functor := ofCommaSndEquivalenceFunctor F G c\n  inverse := ofCommaSndEquivalenceInverse F G c\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalence_unitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\n‚ä¢ Eq (CategoryTheory.StructuredArrow.ofCommaSndEquivalence F G c).unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.StructuredArrow c (CategoryTheory.Comma.fst F G))).obj x)) ‚ãØ)","decl":"/-- There is a canonical equivalence between the structured arrow category with domain `c` on\nthe functor `Comma.fst F G : Comma F G ‚•§ F` and the comma category over\n`Under.forget c ‚ãô F : Under c ‚•§ T` and `G`. -/\n@[simps]\ndef ofCommaSndEquivalence (c : C) :\n    StructuredArrow c (Comma.fst F G) ‚âå Comma (Under.forget c ‚ãô F) G where\n  functor := ofCommaSndEquivalenceFunctor F G c\n  inverse := ofCommaSndEquivalenceInverse F G c\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalence_inverse","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\n‚ä¢ Eq (CategoryTheory.StructuredArrow.ofCommaSndEquivalence F G c).inverse (CategoryTheory.StructuredArrow.ofCommaSndEquivalenceInverse F G c)","decl":"/-- There is a canonical equivalence between the structured arrow category with domain `c` on\nthe functor `Comma.fst F G : Comma F G ‚•§ F` and the comma category over\n`Under.forget c ‚ãô F : Under c ‚•§ T` and `G`. -/\n@[simps]\ndef ofCommaSndEquivalence (c : C) :\n    StructuredArrow c (Comma.fst F G) ‚âå Comma (Under.forget c ‚ãô F) G where\n  functor := ofCommaSndEquivalenceFunctor F G c\n  inverse := ofCommaSndEquivalenceInverse F G c\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ofCommaSndEquivalence_functor","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\n‚ä¢ Eq (CategoryTheory.StructuredArrow.ofCommaSndEquivalence F G c).functor (CategoryTheory.StructuredArrow.ofCommaSndEquivalenceFunctor F G c)","decl":"/-- There is a canonical equivalence between the structured arrow category with domain `c` on\nthe functor `Comma.fst F G : Comma F G ‚•§ F` and the comma category over\n`Under.forget c ‚ãô F : Under c ‚•§ T` and `G`. -/\n@[simps]\ndef ofCommaSndEquivalence (c : C) :\n    StructuredArrow c (Comma.fst F G) ‚âå Comma (Under.forget c ‚ãô F) G where\n  functor := ofCommaSndEquivalenceFunctor F G c\n  inverse := ofCommaSndEquivalenceInverse F G c\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_right_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY‚úù : D\nX : T\nY : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.proj F Y‚úù) X\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor F Y‚úù X).obj Y).left.right.as PUnit.unit","decl":"/-- A functor from the costructured arrow category on the projection functor for any costructured\narrow category. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.functor (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (CostructuredArrow.proj F Y) X ‚•§ CostructuredArrow (Over.forget X ‚ãô F) Y :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X ‚ãô CostructuredArrow.proj F Y) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_right_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY : D\nX : T\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.proj F Y) X\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- A functor from the costructured arrow category on the projection functor for any costructured\narrow category. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.functor (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (CostructuredArrow.proj F Y) X ‚•§ CostructuredArrow (Over.forget X ‚ãô F) Y :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X ‚ãô CostructuredArrow.proj F Y) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_left_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY : D\nX : T\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.proj F Y) X\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor F Y X).map g).left.left g.left.left","decl":"/-- A functor from the costructured arrow category on the projection functor for any costructured\narrow category. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.functor (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (CostructuredArrow.proj F Y) X ‚•§ CostructuredArrow (Over.forget X ‚ãô F) Y :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X ‚ãô CostructuredArrow.proj F Y) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_right_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY‚úù : D\nX : T\nY : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.proj F Y‚úù) X\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor F Y‚úù X).obj Y).right.as PUnit.unit","decl":"/-- A functor from the costructured arrow category on the projection functor for any costructured\narrow category. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.functor (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (CostructuredArrow.proj F Y) X ‚•§ CostructuredArrow (Over.forget X ‚ãô F) Y :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X ‚ãô CostructuredArrow.proj F Y) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY‚úù : D\nX : T\nY : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.proj F Y‚úù) X\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor F Y‚úù X).obj Y).left.hom Y.hom","decl":"/-- A functor from the costructured arrow category on the projection functor for any costructured\narrow category. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.functor (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (CostructuredArrow.proj F Y) X ‚•§ CostructuredArrow (Over.forget X ‚ãô F) Y :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X ‚ãô CostructuredArrow.proj F Y) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_map_left_right_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY : D\nX : T\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.proj F Y) X\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- A functor from the costructured arrow category on the projection functor for any costructured\narrow category. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.functor (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (CostructuredArrow.proj F Y) X ‚•§ CostructuredArrow (Over.forget X ‚ãô F) Y :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X ‚ãô CostructuredArrow.proj F Y) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_left_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY‚úù : D\nX : T\nY : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.proj F Y‚úù) X\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor F Y‚úù X).obj Y).left.left Y.left.left","decl":"/-- A functor from the costructured arrow category on the projection functor for any costructured\narrow category. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.functor (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (CostructuredArrow.proj F Y) X ‚•§ CostructuredArrow (Over.forget X ‚ãô F) Y :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X ‚ãô CostructuredArrow.proj F Y) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY‚úù : D\nX : T\nY : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.proj F Y‚úù) X\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.functor F Y‚úù X).obj Y).hom Y.left.hom","decl":"/-- A functor from the costructured arrow category on the projection functor for any costructured\narrow category. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.functor (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (CostructuredArrow.proj F Y) X ‚•§ CostructuredArrow (Over.forget X ‚ãô F) Y :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X ‚ãô CostructuredArrow.proj F Y) _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY‚úù : D\nX : T\nY : CategoryTheory.CostructuredArrow ((CategoryTheory.Over.forget X).comp F) Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse F Y‚úù X).obj Y).hom Y.left.hom","decl":"/-- The inverse functor of `ofCostructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.inverse (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (Over.forget X ‚ãô F) Y ‚•§ CostructuredArrow (CostructuredArrow.proj F Y) X :=\n  Functor.toCostructuredArrow\n    (Functor.toCostructuredArrow (CostructuredArrow.proj _ Y ‚ãô Over.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_right_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY : D\nX : T\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow ((CategoryTheory.Over.forget X).comp F) Y\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor of `ofCostructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.inverse (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (Over.forget X ‚ãô F) Y ‚•§ CostructuredArrow (CostructuredArrow.proj F Y) X :=\n  Functor.toCostructuredArrow\n    (Functor.toCostructuredArrow (CostructuredArrow.proj _ Y ‚ãô Over.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY‚úù : D\nX : T\nY : CategoryTheory.CostructuredArrow ((CategoryTheory.Over.forget X).comp F) Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse F Y‚úù X).obj Y).left.hom Y.hom","decl":"/-- The inverse functor of `ofCostructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.inverse (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (Over.forget X ‚ãô F) Y ‚•§ CostructuredArrow (CostructuredArrow.proj F Y) X :=\n  Functor.toCostructuredArrow\n    (Functor.toCostructuredArrow (CostructuredArrow.proj _ Y ‚ãô Over.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_right_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY‚úù : D\nX : T\nY : CategoryTheory.CostructuredArrow ((CategoryTheory.Over.forget X).comp F) Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse F Y‚úù X).obj Y).right.as PUnit.unit","decl":"/-- The inverse functor of `ofCostructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.inverse (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (Over.forget X ‚ãô F) Y ‚•§ CostructuredArrow (CostructuredArrow.proj F Y) X :=\n  Functor.toCostructuredArrow\n    (Functor.toCostructuredArrow (CostructuredArrow.proj _ Y ‚ãô Over.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_left_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY : D\nX : T\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow ((CategoryTheory.Over.forget X).comp F) Y\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse F Y X).map g).left.left g.left.left","decl":"/-- The inverse functor of `ofCostructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.inverse (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (Over.forget X ‚ãô F) Y ‚•§ CostructuredArrow (CostructuredArrow.proj F Y) X :=\n  Functor.toCostructuredArrow\n    (Functor.toCostructuredArrow (CostructuredArrow.proj _ Y ‚ãô Over.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_map_left_right_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY : D\nX : T\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow ((CategoryTheory.Over.forget X).comp F) Y\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor of `ofCostructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.inverse (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (Over.forget X ‚ãô F) Y ‚•§ CostructuredArrow (CostructuredArrow.proj F Y) X :=\n  Functor.toCostructuredArrow\n    (Functor.toCostructuredArrow (CostructuredArrow.proj _ Y ‚ãô Over.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_right_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY‚úù : D\nX : T\nY : CategoryTheory.CostructuredArrow ((CategoryTheory.Over.forget X).comp F) Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse F Y‚úù X).obj Y).left.right.as PUnit.unit","decl":"/-- The inverse functor of `ofCostructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.inverse (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (Over.forget X ‚ãô F) Y ‚•§ CostructuredArrow (CostructuredArrow.proj F Y) X :=\n  Functor.toCostructuredArrow\n    (Functor.toCostructuredArrow (CostructuredArrow.proj _ Y ‚ãô Over.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse_obj_left_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor T D\nY‚úù : D\nX : T\nY : CategoryTheory.CostructuredArrow ((CategoryTheory.Over.forget X).comp F) Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCostructuredArrowProjEquivalence.inverse F Y‚úù X).obj Y).left.left Y.left.left","decl":"/-- The inverse functor of `ofCostructuredArrowProjEquivalence.functor`. -/\n@[simps!]\ndef ofCostructuredArrowProjEquivalence.inverse (F : T ‚•§ D) (Y : D) (X : T) :\n    CostructuredArrow (Over.forget X ‚ãô F) Y ‚•§ CostructuredArrow (CostructuredArrow.proj F Y) X :=\n  Functor.toCostructuredArrow\n    (Functor.toCostructuredArrow (CostructuredArrow.proj _ Y ‚ãô Over.forget X) _ _\n      (fun g => by exact g.hom) (fun m => by have := m.w; aesop_cat)) _ _\n    (fun f => f.left.hom) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.CostructuredArrow (CategoryTheory.Functor.diag T) X\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor X).obj Y).hom Y.hom.2","decl":"/-- The canonical functor from the costructured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the costructured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    CostructuredArrow (Functor.diag _) X ‚•§ CostructuredArrow (Over.forget X.1) X.2 :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X) _\n      (fun g => by exact g.hom.1) (fun m => by have := congrArg (¬∑.1) m.w; aesop_cat))\n    _ _\n    (fun f => f.hom.2) (fun m => by have := congrArg (¬∑.2) m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_left_right_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (CategoryTheory.Functor.diag T) X\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The canonical functor from the costructured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the costructured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    CostructuredArrow (Functor.diag _) X ‚•§ CostructuredArrow (Over.forget X.1) X.2 :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X) _\n      (fun g => by exact g.hom.1) (fun m => by have := congrArg (¬∑.1) m.w; aesop_cat))\n    _ _\n    (fun f => f.hom.2) (fun m => by have := congrArg (¬∑.2) m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.CostructuredArrow (CategoryTheory.Functor.diag T) X\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor X).obj Y).left.hom Y.hom.1","decl":"/-- The canonical functor from the costructured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the costructured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    CostructuredArrow (Functor.diag _) X ‚•§ CostructuredArrow (Over.forget X.1) X.2 :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X) _\n      (fun g => by exact g.hom.1) (fun m => by have := congrArg (¬∑.1) m.w; aesop_cat))\n    _ _\n    (fun f => f.hom.2) (fun m => by have := congrArg (¬∑.2) m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.CostructuredArrow (CategoryTheory.Functor.diag T) X\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor X).obj Y).left.left Y.left","decl":"/-- The canonical functor from the costructured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the costructured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    CostructuredArrow (Functor.diag _) X ‚•§ CostructuredArrow (Over.forget X.1) X.2 :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X) _\n      (fun g => by exact g.hom.1) (fun m => by have := congrArg (¬∑.1) m.w; aesop_cat))\n    _ _\n    (fun f => f.hom.2) (fun m => by have := congrArg (¬∑.2) m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_right_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.CostructuredArrow (CategoryTheory.Functor.diag T) X\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor X).obj Y).right.as PUnit.unit","decl":"/-- The canonical functor from the costructured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the costructured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    CostructuredArrow (Functor.diag _) X ‚•§ CostructuredArrow (Over.forget X.1) X.2 :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X) _\n      (fun g => by exact g.hom.1) (fun m => by have := congrArg (¬∑.1) m.w; aesop_cat))\n    _ _\n    (fun f => f.hom.2) (fun m => by have := congrArg (¬∑.2) m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_left_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (CategoryTheory.Functor.diag T) X\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor X).map g).left.left g.left","decl":"/-- The canonical functor from the costructured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the costructured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    CostructuredArrow (Functor.diag _) X ‚•§ CostructuredArrow (Over.forget X.1) X.2 :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X) _\n      (fun g => by exact g.hom.1) (fun m => by have := congrArg (¬∑.1) m.w; aesop_cat))\n    _ _\n    (fun f => f.hom.2) (fun m => by have := congrArg (¬∑.2) m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_map_right_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (CategoryTheory.Functor.diag T) X\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The canonical functor from the costructured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the costructured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    CostructuredArrow (Functor.diag _) X ‚•§ CostructuredArrow (Over.forget X.1) X.2 :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X) _\n      (fun g => by exact g.hom.1) (fun m => by have := congrArg (¬∑.1) m.w; aesop_cat))\n    _ _\n    (fun f => f.hom.2) (fun m => by have := congrArg (¬∑.2) m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor_obj_left_right_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.CostructuredArrow (CategoryTheory.Functor.diag T) X\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofDiagEquivalence.functor X).obj Y).left.right.as PUnit.unit","decl":"/-- The canonical functor from the costructured arrow category on the diagonal functor\n`T ‚•§ T √ó T` to the costructured arrow category on `Under.forget`. -/\n@[simps!]\ndef ofDiagEquivalence.functor (X : T √ó T) :\n    CostructuredArrow (Functor.diag _) X ‚•§ CostructuredArrow (Over.forget X.1) X.2 :=\n  Functor.toCostructuredArrow\n    (Functor.toOver (CostructuredArrow.proj _ X) _\n      (fun g => by exact g.hom.1) (fun m => by have := congrArg (¬∑.1) m.w; aesop_cat))\n    _ _\n    (fun f => f.hom.2) (fun m => by have := congrArg (¬∑.2) m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.CostructuredArrow (CategoryTheory.Over.forget X.1) X.2\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse X).obj Y).left Y.left.left","decl":"/-- The inverse functor of `ofDiagEquivalence.functor`. -/\n@[simps!]\ndef ofDiagEquivalence.inverse (X : T √ó T) :\n    CostructuredArrow (Over.forget X.1) X.2 ‚•§ CostructuredArrow (Functor.diag _) X :=\n  Functor.toCostructuredArrow (CostructuredArrow.proj _ _ ‚ãô Over.forget _) _ X\n    (fun f => (f.left.hom, f.hom)) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.CostructuredArrow (CategoryTheory.Over.forget X.1) X.2\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse X).obj Y).hom { fst := Y.left.hom, snd := Y.hom }","decl":"/-- The inverse functor of `ofDiagEquivalence.functor`. -/\n@[simps!]\ndef ofDiagEquivalence.inverse (X : T √ó T) :\n    CostructuredArrow (Over.forget X.1) X.2 ‚•§ CostructuredArrow (Functor.diag _) X :=\n  Functor.toCostructuredArrow (CostructuredArrow.proj _ _ ‚ãô Over.forget _) _ X\n    (fun f => (f.left.hom, f.hom)) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_obj_right_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nY : CategoryTheory.CostructuredArrow (CategoryTheory.Over.forget X.1) X.2\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse X).obj Y).right.as PUnit.unit","decl":"/-- The inverse functor of `ofDiagEquivalence.functor`. -/\n@[simps!]\ndef ofDiagEquivalence.inverse (X : T √ó T) :\n    CostructuredArrow (Over.forget X.1) X.2 ‚•§ CostructuredArrow (Functor.diag _) X :=\n  Functor.toCostructuredArrow (CostructuredArrow.proj _ _ ‚ãô Over.forget _) _ X\n    (fun f => (f.left.hom, f.hom)) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_map_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (CategoryTheory.Over.forget X.1) X.2\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse X).map g).left g.left.left","decl":"/-- The inverse functor of `ofDiagEquivalence.functor`. -/\n@[simps!]\ndef ofDiagEquivalence.inverse (X : T √ó T) :\n    CostructuredArrow (Over.forget X.1) X.2 ‚•§ CostructuredArrow (Functor.diag _) X :=\n  Functor.toCostructuredArrow (CostructuredArrow.proj _ _ ‚ãô Over.forget _) _ X\n    (fun f => (f.left.hom, f.hom)) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofDiagEquivalence.inverse_map_right_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : Prod T T\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (CategoryTheory.Over.forget X.1) X.2\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor of `ofDiagEquivalence.functor`. -/\n@[simps!]\ndef ofDiagEquivalence.inverse (X : T √ó T) :\n    CostructuredArrow (Over.forget X.1) X.2 ‚•§ CostructuredArrow (Functor.diag _) X :=\n  Functor.toCostructuredArrow (CostructuredArrow.proj _ _ ‚ãô Over.forget _) _ X\n    (fun f => (f.left.hom, f.hom)) (fun m => by have := m.w; aesop_cat)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX : CategoryTheory.CostructuredArrow (CategoryTheory.Comma.fst F G) c\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor F G c).obj X).right X.left.right","decl":"/-- The functor used to define the equivalence `ofCommaFstEquivalence`. -/\n@[simps]\ndef ofCommaFstEquivalenceFunctor (c : C) :\n    CostructuredArrow (Comma.fst F G) c ‚•§ Comma (Over.forget c ‚ãô F) G where\n  obj X := ‚ü®Over.mk X.hom, X.left.right, X.left.hom‚ü©\n  map f := ‚ü®Over.homMk f.left.left (by simpa using f.w), f.left.right, by simp‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_map_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (CategoryTheory.Comma.fst F G) c\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor F G c).map f).left (CategoryTheory.Over.homMk f.left.left ‚ãØ)","decl":"/-- The functor used to define the equivalence `ofCommaFstEquivalence`. -/\n@[simps]\ndef ofCommaFstEquivalenceFunctor (c : C) :\n    CostructuredArrow (Comma.fst F G) c ‚•§ Comma (Over.forget c ‚ãô F) G where\n  obj X := ‚ü®Over.mk X.hom, X.left.right, X.left.hom‚ü©\n  map f := ‚ü®Over.homMk f.left.left (by simpa using f.w), f.left.right, by simp‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX : CategoryTheory.CostructuredArrow (CategoryTheory.Comma.fst F G) c\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor F G c).obj X).hom X.left.hom","decl":"/-- The functor used to define the equivalence `ofCommaFstEquivalence`. -/\n@[simps]\ndef ofCommaFstEquivalenceFunctor (c : C) :\n    CostructuredArrow (Comma.fst F G) c ‚•§ Comma (Over.forget c ‚ãô F) G where\n  obj X := ‚ü®Over.mk X.hom, X.left.right, X.left.hom‚ü©\n  map f := ‚ü®Over.homMk f.left.left (by simpa using f.w), f.left.right, by simp‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_obj_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX : CategoryTheory.CostructuredArrow (CategoryTheory.Comma.fst F G) c\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor F G c).obj X).left (CategoryTheory.Over.mk X.hom)","decl":"/-- The functor used to define the equivalence `ofCommaFstEquivalence`. -/\n@[simps]\ndef ofCommaFstEquivalenceFunctor (c : C) :\n    CostructuredArrow (Comma.fst F G) c ‚•§ Comma (Over.forget c ‚ãô F) G where\n  obj X := ‚ü®Over.mk X.hom, X.left.right, X.left.hom‚ü©\n  map f := ‚ü®Over.homMk f.left.left (by simpa using f.w), f.left.right, by simp‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor_map_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (CategoryTheory.Comma.fst F G) c\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor F G c).map f).right f.left.right","decl":"/-- The functor used to define the equivalence `ofCommaFstEquivalence`. -/\n@[simps]\ndef ofCommaFstEquivalenceFunctor (c : C) :\n    CostructuredArrow (Comma.fst F G) c ‚•§ Comma (Over.forget c ‚ãô F) G where\n  obj X := ‚ü®Over.mk X.hom, X.left.right, X.left.hom‚ü©\n  map f := ‚ü®Over.homMk f.left.left (by simpa using f.w), f.left.right, by simp‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_right_as","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nY : CategoryTheory.Comma ((CategoryTheory.Over.forget c).comp F) G\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse F G c).obj Y).right.as PUnit.unit","decl":"/-- The inverse functor used to define the equivalence `ofCommaFstEquivalence`. -/\n@[simps!]\ndef ofCommaFstEquivalenceInverse (c : C) :\n    Comma (Over.forget c ‚ãô F) G ‚•§ CostructuredArrow (Comma.fst F G) c :=\n  Functor.toCostructuredArrow (Comma.preLeft (Over.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_map_left_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX‚úù Y‚úù : CategoryTheory.Comma ((CategoryTheory.Over.forget c).comp F) G\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse F G c).map g).left.left g.left.left","decl":"/-- The inverse functor used to define the equivalence `ofCommaFstEquivalence`. -/\n@[simps!]\ndef ofCommaFstEquivalenceInverse (c : C) :\n    Comma (Over.forget c ‚ãô F) G ‚•§ CostructuredArrow (Comma.fst F G) c :=\n  Functor.toCostructuredArrow (Comma.preLeft (Over.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nY : CategoryTheory.Comma ((CategoryTheory.Over.forget c).comp F) G\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse F G c).obj Y).left.right Y.right","decl":"/-- The inverse functor used to define the equivalence `ofCommaFstEquivalence`. -/\n@[simps!]\ndef ofCommaFstEquivalenceInverse (c : C) :\n    Comma (Over.forget c ‚ãô F) G ‚•§ CostructuredArrow (Comma.fst F G) c :=\n  Functor.toCostructuredArrow (Comma.preLeft (Over.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nY : CategoryTheory.Comma ((CategoryTheory.Over.forget c).comp F) G\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse F G c).obj Y).left.hom Y.hom","decl":"/-- The inverse functor used to define the equivalence `ofCommaFstEquivalence`. -/\n@[simps!]\ndef ofCommaFstEquivalenceInverse (c : C) :\n    Comma (Over.forget c ‚ãô F) G ‚•§ CostructuredArrow (Comma.fst F G) c :=\n  Functor.toCostructuredArrow (Comma.preLeft (Over.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_map_right_down_down","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX‚úù Y‚úù : CategoryTheory.Comma ((CategoryTheory.Over.forget c).comp F) G\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor used to define the equivalence `ofCommaFstEquivalence`. -/\n@[simps!]\ndef ofCommaFstEquivalenceInverse (c : C) :\n    Comma (Over.forget c ‚ãô F) G ‚•§ CostructuredArrow (Comma.fst F G) c :=\n  Functor.toCostructuredArrow (Comma.preLeft (Over.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_hom","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nY : CategoryTheory.Comma ((CategoryTheory.Over.forget c).comp F) G\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse F G c).obj Y).hom Y.left.hom","decl":"/-- The inverse functor used to define the equivalence `ofCommaFstEquivalence`. -/\n@[simps!]\ndef ofCommaFstEquivalenceInverse (c : C) :\n    Comma (Over.forget c ‚ãô F) G ‚•§ CostructuredArrow (Comma.fst F G) c :=\n  Functor.toCostructuredArrow (Comma.preLeft (Over.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_map_left_right","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nX‚úù Y‚úù : CategoryTheory.Comma ((CategoryTheory.Over.forget c).comp F) G\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse F G c).map g).left.right g.right","decl":"/-- The inverse functor used to define the equivalence `ofCommaFstEquivalence`. -/\n@[simps!]\ndef ofCommaFstEquivalenceInverse (c : C) :\n    Comma (Over.forget c ‚ãô F) G ‚•§ CostructuredArrow (Comma.fst F G) c :=\n  Functor.toCostructuredArrow (Comma.preLeft (Over.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse_obj_left_left","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\nY : CategoryTheory.Comma ((CategoryTheory.Over.forget c).comp F) G\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse F G c).obj Y).left.left Y.left.left","decl":"/-- The inverse functor used to define the equivalence `ofCommaFstEquivalence`. -/\n@[simps!]\ndef ofCommaFstEquivalenceInverse (c : C) :\n    Comma (Over.forget c ‚ãô F) G ‚•§ CostructuredArrow (Comma.fst F G) c :=\n  Functor.toCostructuredArrow (Comma.preLeft (Over.forget c) F G) _ _\n    (fun Y => Y.left.hom) (fun _ => by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalence_unitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.ofCommaFstEquivalence F G c).unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.CostructuredArrow (CategoryTheory.Comma.fst F G) c)).obj x)) ‚ãØ)","decl":"/-- There is a canonical equivalence between the costructured arrow category with codomain `c` on\nthe functor `Comma.fst F G : Comma F G ‚•§ F` and the comma category over\n`Over.forget c ‚ãô F : Over c ‚•§ T` and `G`. -/\n@[simps]\ndef ofCommaFstEquivalence (c : C) :\n    CostructuredArrow (Comma.fst F G) c ‚âå Comma (Over.forget c ‚ãô F) G where\n  functor := ofCommaFstEquivalenceFunctor F G c\n  inverse := ofCommaFstEquivalenceInverse F G c\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalence_inverse","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.ofCommaFstEquivalence F G c).inverse (CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse F G c)","decl":"/-- There is a canonical equivalence between the costructured arrow category with codomain `c` on\nthe functor `Comma.fst F G : Comma F G ‚•§ F` and the comma category over\n`Over.forget c ‚ãô F : Over c ‚•§ T` and `G`. -/\n@[simps]\ndef ofCommaFstEquivalence (c : C) :\n    CostructuredArrow (Comma.fst F G) c ‚âå Comma (Over.forget c ‚ãô F) G where\n  functor := ofCommaFstEquivalenceFunctor F G c\n  inverse := ofCommaFstEquivalenceInverse F G c\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalence_functor","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.ofCommaFstEquivalence F G c).functor (CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor F G c)","decl":"/-- There is a canonical equivalence between the costructured arrow category with codomain `c` on\nthe functor `Comma.fst F G : Comma F G ‚•§ F` and the comma category over\n`Over.forget c ‚ãô F : Over c ‚•§ T` and `G`. -/\n@[simps]\ndef ofCommaFstEquivalence (c : C) :\n    CostructuredArrow (Comma.fst F G) c ‚âå Comma (Over.forget c ‚ãô F) G where\n  functor := ofCommaFstEquivalenceFunctor F G c\n  inverse := ofCommaFstEquivalenceInverse F G c\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ofCommaFstEquivalence_counitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor C T\nG : CategoryTheory.Functor D T\nc : C\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.ofCommaFstEquivalence F G c).counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl (((CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceInverse F G c).comp (CategoryTheory.CostructuredArrow.ofCommaFstEquivalenceFunctor F G c)).obj x)) ‚ãØ)","decl":"/-- There is a canonical equivalence between the costructured arrow category with codomain `c` on\nthe functor `Comma.fst F G : Comma F G ‚•§ F` and the comma category over\n`Over.forget c ‚ãô F : Over c ‚•§ T` and `G`. -/\n@[simps]\ndef ofCommaFstEquivalence (c : C) :\n    CostructuredArrow (Comma.fst F G) c ‚âå Comma (Over.forget c ‚ãô F) G where\n  functor := ofCommaFstEquivalenceFunctor F G c\n  inverse := ofCommaFstEquivalenceInverse F G c\n  unitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n\n"}
{"name":"CategoryTheory.Over.opToOpUnder_obj","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nY : CategoryTheory.Over { unop := X }\n‚ä¢ Eq ((CategoryTheory.Over.opToOpUnder X).obj Y) { unop := CategoryTheory.Under.mk Y.hom.unop }","decl":"/-- The canonical functor by reversing structure arrows. -/\n@[simps]\ndef Over.opToOpUnder : Over (op X) ‚•§ (Under X)·µí·µñ where\n  obj Y := ‚ü®Under.mk Y.hom.unop‚ü©\n  map {Z Y} f := ‚ü®Under.homMk (f.left.unop) (by dsimp; rw [‚Üê unop_comp, Over.w])‚ü©\n\n"}
{"name":"CategoryTheory.Over.opToOpUnder_map","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nZ Y : CategoryTheory.Over { unop := X }\nf : Quiver.Hom Z Y\n‚ä¢ Eq ((CategoryTheory.Over.opToOpUnder X).map f) { unop := CategoryTheory.Under.homMk f.left.unop ‚ãØ }","decl":"/-- The canonical functor by reversing structure arrows. -/\n@[simps]\ndef Over.opToOpUnder : Over (op X) ‚•§ (Under X)·µí·µñ where\n  obj Y := ‚ü®Under.mk Y.hom.unop‚ü©\n  map {Z Y} f := ‚ü®Under.homMk (f.left.unop) (by dsimp; rw [‚Üê unop_comp, Over.w])‚ü©\n\n"}
{"name":"CategoryTheory.Under.opToOverOp_map","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nZ Y : Opposite (CategoryTheory.Under X)\nf : Quiver.Hom Z Y\n‚ä¢ Eq ((CategoryTheory.Under.opToOverOp X).map f) (CategoryTheory.Over.homMk f.unop.right.op ‚ãØ)","decl":"/-- The canonical functor by reversing structure arrows. -/\n@[simps]\ndef Under.opToOverOp : (Under X)·µí·µñ ‚•§ Over (op X) where\n  obj Y := Over.mk (Y.unop.hom.op)\n  map {Z Y} f := Over.homMk f.unop.right.op <| by dsimp; rw [‚Üê Under.w f.unop, op_comp]\n\n"}
{"name":"CategoryTheory.Under.opToOverOp_obj","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nY : Opposite (CategoryTheory.Under X)\n‚ä¢ Eq ((CategoryTheory.Under.opToOverOp X).obj Y) (CategoryTheory.Over.mk (Opposite.unop Y).hom.op)","decl":"/-- The canonical functor by reversing structure arrows. -/\n@[simps]\ndef Under.opToOverOp : (Under X)·µí·µñ ‚•§ Over (op X) where\n  obj Y := Over.mk (Y.unop.hom.op)\n  map {Z Y} f := Over.homMk f.unop.right.op <| by dsimp; rw [‚Üê Under.w f.unop, op_comp]\n\n"}
{"name":"CategoryTheory.Over.opEquivOpUnder_inverse","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ Eq (CategoryTheory.Over.opEquivOpUnder X).inverse (CategoryTheory.Under.opToOverOp X)","decl":"/-- `Over.opToOpUnder` is an equivalence of categories. -/\n@[simps]\ndef Over.opEquivOpUnder : Over (op X) ‚âå (Under X)·µí·µñ where\n  functor := Over.opToOpUnder X\n  inverse := Under.opToOverOp X\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Over.opEquivOpUnder_unitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ Eq (CategoryTheory.Over.opEquivOpUnder X).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (CategoryTheory.Over { unop := X })))","decl":"/-- `Over.opToOpUnder` is an equivalence of categories. -/\n@[simps]\ndef Over.opEquivOpUnder : Over (op X) ‚âå (Under X)·µí·µñ where\n  functor := Over.opToOpUnder X\n  inverse := Under.opToOverOp X\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Over.opEquivOpUnder_counitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ Eq (CategoryTheory.Over.opEquivOpUnder X).counitIso (CategoryTheory.Iso.refl ((CategoryTheory.Under.opToOverOp X).comp (CategoryTheory.Over.opToOpUnder X)))","decl":"/-- `Over.opToOpUnder` is an equivalence of categories. -/\n@[simps]\ndef Over.opEquivOpUnder : Over (op X) ‚âå (Under X)·µí·µñ where\n  functor := Over.opToOpUnder X\n  inverse := Under.opToOverOp X\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Over.opEquivOpUnder_functor","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ Eq (CategoryTheory.Over.opEquivOpUnder X).functor (CategoryTheory.Over.opToOpUnder X)","decl":"/-- `Over.opToOpUnder` is an equivalence of categories. -/\n@[simps]\ndef Over.opEquivOpUnder : Over (op X) ‚âå (Under X)·µí·µñ where\n  functor := Over.opToOpUnder X\n  inverse := Under.opToOverOp X\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Under.opToOpOver_obj","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nY : CategoryTheory.Under { unop := X }\n‚ä¢ Eq ((CategoryTheory.Under.opToOpOver X).obj Y) { unop := CategoryTheory.Over.mk Y.hom.unop }","decl":"/-- The canonical functor by reversing structure arrows. -/\n@[simps]\ndef Under.opToOpOver : Under (op X) ‚•§ (Over X)·µí·µñ where\n  obj Y := ‚ü®Over.mk Y.hom.unop‚ü©\n  map {Z Y} f := ‚ü®Over.homMk (f.right.unop) (by dsimp; rw [‚Üê unop_comp, Under.w])‚ü©\n\n"}
{"name":"CategoryTheory.Under.opToOpOver_map","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nZ Y : CategoryTheory.Under { unop := X }\nf : Quiver.Hom Z Y\n‚ä¢ Eq ((CategoryTheory.Under.opToOpOver X).map f) { unop := CategoryTheory.Over.homMk f.right.unop ‚ãØ }","decl":"/-- The canonical functor by reversing structure arrows. -/\n@[simps]\ndef Under.opToOpOver : Under (op X) ‚•§ (Over X)·µí·µñ where\n  obj Y := ‚ü®Over.mk Y.hom.unop‚ü©\n  map {Z Y} f := ‚ü®Over.homMk (f.right.unop) (by dsimp; rw [‚Üê unop_comp, Under.w])‚ü©\n\n"}
{"name":"CategoryTheory.Over.opToUnderOp_obj","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nY : Opposite (CategoryTheory.Over X)\n‚ä¢ Eq ((CategoryTheory.Over.opToUnderOp X).obj Y) (CategoryTheory.Under.mk (Opposite.unop Y).hom.op)","decl":"/-- The canonical functor by reversing structure arrows. -/\n@[simps]\ndef Over.opToUnderOp : (Over X)·µí·µñ ‚•§ Under (op X) where\n  obj Y := Under.mk (Y.unop.hom.op)\n  map {Z Y} f := Under.homMk f.unop.left.op <| by dsimp; rw [‚Üê Over.w f.unop, op_comp]\n\n"}
{"name":"CategoryTheory.Over.opToUnderOp_map","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\nZ Y : Opposite (CategoryTheory.Over X)\nf : Quiver.Hom Z Y\n‚ä¢ Eq ((CategoryTheory.Over.opToUnderOp X).map f) (CategoryTheory.Under.homMk f.unop.left.op ‚ãØ)","decl":"/-- The canonical functor by reversing structure arrows. -/\n@[simps]\ndef Over.opToUnderOp : (Over X)·µí·µñ ‚•§ Under (op X) where\n  obj Y := Under.mk (Y.unop.hom.op)\n  map {Z Y} f := Under.homMk f.unop.left.op <| by dsimp; rw [‚Üê Over.w f.unop, op_comp]\n\n"}
{"name":"CategoryTheory.Under.opEquivOpOver_functor","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ Eq (CategoryTheory.Under.opEquivOpOver X).functor (CategoryTheory.Under.opToOpOver X)","decl":"/-- `Under.opToOpOver` is an equivalence of categories. -/\n@[simps]\ndef Under.opEquivOpOver : Under (op X) ‚âå (Over X)·µí·µñ where\n  functor := Under.opToOpOver X\n  inverse := Over.opToUnderOp X\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Under.opEquivOpOver_inverse","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ Eq (CategoryTheory.Under.opEquivOpOver X).inverse (CategoryTheory.Over.opToUnderOp X)","decl":"/-- `Under.opToOpOver` is an equivalence of categories. -/\n@[simps]\ndef Under.opEquivOpOver : Under (op X) ‚âå (Over X)·µí·µñ where\n  functor := Under.opToOpOver X\n  inverse := Over.opToUnderOp X\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Under.opEquivOpOver_counitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ Eq (CategoryTheory.Under.opEquivOpOver X).counitIso (CategoryTheory.Iso.refl ((CategoryTheory.Over.opToUnderOp X).comp (CategoryTheory.Under.opToOpOver X)))","decl":"/-- `Under.opToOpOver` is an equivalence of categories. -/\n@[simps]\ndef Under.opEquivOpOver : Under (op X) ‚âå (Over X)·µí·µñ where\n  functor := Under.opToOpOver X\n  inverse := Over.opToUnderOp X\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Under.opEquivOpOver_unitIso","module":"Mathlib.CategoryTheory.Comma.Over","initialProofState":"T : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T\nX : T\n‚ä¢ Eq (CategoryTheory.Under.opEquivOpOver X).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (CategoryTheory.Under { unop := X })))","decl":"/-- `Under.opToOpOver` is an equivalence of categories. -/\n@[simps]\ndef Under.opEquivOpOver : Under (op X) ‚âå (Over X)·µí·µñ where\n  functor := Under.opToOpOver X\n  inverse := Over.opToUnderOp X\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
