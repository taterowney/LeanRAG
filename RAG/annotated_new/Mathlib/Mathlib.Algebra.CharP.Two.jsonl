{"name":"CharTwo.two_eq_zero","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoidWithOne R\ninst✝ : CharP R 2\n⊢ Eq 2 0","decl":"theorem two_eq_zero [CharP R 2] : (2 : R) = 0 := by\n  rw [← Nat.cast_two, CharP.cast_eq_zero]\n\n"}
{"name":"CharTwo.of_one_ne_zero_of_two_eq_zero","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝ : AddMonoidWithOne R\nh₁ : Ne 1 0\nh₂ : Eq 2 0\n⊢ CharP R 2","decl":"/-- The only hypotheses required to build a `CharP R 2` instance are `1 ≠ 0` and `2 = 0`. -/\ntheorem of_one_ne_zero_of_two_eq_zero (h₁ : (1 : R) ≠ 0) (h₂ : (2 : R) = 0) : CharP R 2 where\n  cast_eq_zero_iff' n := by\n    obtain hn | hn := Nat.even_or_odd n\n    · simp_rw [hn.two_dvd, iff_true]\n      exact natCast_eq_zero_of_even_of_two_eq_zero hn h₂\n    · simp_rw [hn.not_two_dvd_nat, iff_false]\n      rwa [natCast_eq_one_of_odd_of_two_eq_zero hn h₂]\n\n"}
{"name":"CharTwo.add_self_eq_zero","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : CharP R 2\nx : R\n⊢ Eq (HAdd.hAdd x x) 0","decl":"@[scoped simp]\ntheorem add_self_eq_zero (x : R) : x + x = 0 := by rw [← two_smul R x, two_eq_zero, zero_smul]\n\n"}
{"name":"CharTwo.two_nsmul","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : CharP R 2\nx : R\n⊢ Eq (HSMul.hSMul 2 x) 0","decl":"@[scoped simp]\nprotected theorem two_nsmul (x : R) : 2 • x = 0 := by rw [two_smul, add_self_eq_zero]\n\n"}
{"name":"CharTwo.neg_eq","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R 2\nx : R\n⊢ Eq (Neg.neg x) x","decl":"@[scoped simp]\ntheorem neg_eq (x : R) : -x = x := by\n  rw [neg_eq_iff_add_eq_zero, add_self_eq_zero]\n\n"}
{"name":"CharTwo.neg_eq'","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R 2\n⊢ Eq Neg.neg id","decl":"theorem neg_eq' : Neg.neg = (id : R → R) :=\n  funext neg_eq\n\n"}
{"name":"CharTwo.sub_eq_add","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R 2\nx y : R\n⊢ Eq (HSub.hSub x y) (HAdd.hAdd x y)","decl":"@[scoped simp]\ntheorem sub_eq_add (x y : R) : x - y = x + y := by rw [sub_eq_add_neg, neg_eq]\n\n"}
{"name":"CharTwo.sub_eq_add'","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R 2\n⊢ Eq HSub.hSub fun x1 x2 => HAdd.hAdd x1 x2","decl":"@[deprecated sub_eq_add (since := \"2024-10-24\")]\ntheorem sub_eq_add' : HSub.hSub = (· + · : R → R → R) :=\n  funext₂ sub_eq_add\n\n"}
{"name":"CharTwo.add_eq_iff_eq_add","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R 2\na b c : R\n⊢ Iff (Eq (HAdd.hAdd a b) c) (Eq a (HAdd.hAdd c b))","decl":"theorem add_eq_iff_eq_add {a b c : R} : a + b = c ↔ a = c + b := by\n  rw [← sub_eq_iff_eq_add, sub_eq_add]\n\n"}
{"name":"CharTwo.eq_add_iff_add_eq","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R 2\na b c : R\n⊢ Iff (Eq a (HAdd.hAdd b c)) (Eq (HAdd.hAdd a c) b)","decl":"theorem eq_add_iff_add_eq {a b c : R} : a = b + c ↔ a + c = b := by\n  rw [← eq_sub_iff_add_eq, sub_eq_add]\n\n"}
{"name":"CharTwo.two_zsmul","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : CharP R 2\nx : R\n⊢ Eq (HSMul.hSMul 2 x) 0","decl":"@[scoped simp]\nprotected theorem two_zsmul (x : R) : (2 : ℤ) • x = 0 := by\n  rw [two_zsmul, add_self_eq_zero]\n\n"}
{"name":"CharTwo.add_sq","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CharP R 2\nx y : R\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) 2) (HAdd.hAdd (HPow.hPow x 2) (HPow.hPow y 2))","decl":"theorem add_sq (x y : R) : (x + y) ^ 2 = x ^ 2 + y ^ 2 :=\n  add_pow_char _ _ _\n\n"}
{"name":"CharTwo.add_mul_self","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CharP R 2\nx y : R\n⊢ Eq (HMul.hMul (HAdd.hAdd x y) (HAdd.hAdd x y)) (HAdd.hAdd (HMul.hMul x x) (HMul.hMul y y))","decl":"theorem add_mul_self (x y : R) : (x + y) * (x + y) = x * x + y * y := by\n  rw [← pow_two, ← pow_two, ← pow_two, add_sq]\n\n"}
{"name":"CharTwo.list_sum_sq","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CharP R 2\nl : List R\n⊢ Eq (HPow.hPow l.sum 2) (List.map (fun x => HPow.hPow x 2) l).sum","decl":"theorem list_sum_sq (l : List R) : l.sum ^ 2 = (l.map (· ^ 2)).sum :=\n  list_sum_pow_char _ _\n\n"}
{"name":"CharTwo.list_sum_mul_self","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CharP R 2\nl : List R\n⊢ Eq (HMul.hMul l.sum l.sum) (List.map (fun x => HMul.hMul x x) l).sum","decl":"theorem list_sum_mul_self (l : List R) : l.sum * l.sum = (List.map (fun x => x * x) l).sum := by\n  simp_rw [← pow_two, list_sum_sq]\n\n"}
{"name":"CharTwo.multiset_sum_sq","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CharP R 2\nl : Multiset R\n⊢ Eq (HPow.hPow l.sum 2) (Multiset.map (fun x => HPow.hPow x 2) l).sum","decl":"theorem multiset_sum_sq (l : Multiset R) : l.sum ^ 2 = (l.map (· ^ 2)).sum :=\n  multiset_sum_pow_char _ _\n\n"}
{"name":"CharTwo.multiset_sum_mul_self","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : CharP R 2\nl : Multiset R\n⊢ Eq (HMul.hMul l.sum l.sum) (Multiset.map (fun x => HMul.hMul x x) l).sum","decl":"theorem multiset_sum_mul_self (l : Multiset R) :\n    l.sum * l.sum = (Multiset.map (fun x => x * x) l).sum := by simp_rw [← pow_two, multiset_sum_sq]\n\n"}
{"name":"CharTwo.sum_sq","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : CharP R 2\ns : Finset ι\nf : ι → R\n⊢ Eq (HPow.hPow (s.sum fun i => f i) 2) (s.sum fun i => HPow.hPow (f i) 2)","decl":"theorem sum_sq (s : Finset ι) (f : ι → R) : (∑ i ∈ s, f i) ^ 2 = ∑ i ∈ s, f i ^ 2 :=\n  sum_pow_char _ _ _\n\n"}
{"name":"CharTwo.sum_mul_self","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : CharP R 2\ns : Finset ι\nf : ι → R\n⊢ Eq (HMul.hMul (s.sum fun i => f i) (s.sum fun i => f i)) (s.sum fun i => HMul.hMul (f i) (f i))","decl":"theorem sum_mul_self (s : Finset ι) (f : ι → R) :\n    ((∑ i ∈ s, f i) * ∑ i ∈ s, f i) = ∑ i ∈ s, f i * f i := by simp_rw [← pow_two, sum_sq]\n\n"}
{"name":"neg_one_eq_one_iff","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\n⊢ Iff (Eq (-1) 1) (Eq (ringChar R) 2)","decl":"theorem neg_one_eq_one_iff [Nontrivial R] : (-1 : R) = 1 ↔ ringChar R = 2 := by\n  refine ⟨fun h => ?_, fun h => @CharTwo.neg_eq _ _ (ringChar.of_eq h) 1⟩\n  rw [eq_comm, ← sub_eq_zero, sub_neg_eq_add, ← Nat.cast_one, ← Nat.cast_add] at h\n  exact ((Nat.dvd_prime Nat.prime_two).mp (ringChar.dvd h)).resolve_left CharP.ringChar_ne_one\n\n"}
{"name":"orderOf_neg_one","module":"Mathlib.Algebra.CharP.Two","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\n⊢ Eq (orderOf (-1)) (ite (Eq (ringChar R) 2) 1 2)","decl":"@[simp]\ntheorem orderOf_neg_one [Nontrivial R] : orderOf (-1 : R) = if ringChar R = 2 then 1 else 2 := by\n  split_ifs with h\n  · rw [neg_one_eq_one_iff.2 h, orderOf_one]\n  apply orderOf_eq_prime\n  · simp\n  simpa [neg_one_eq_one_iff] using h\n\n"}
