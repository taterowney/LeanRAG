{"name":"Filter.tendsto_cocompact_mul_leftâ‚€","module":"Mathlib.Topology.Algebra.Field","initialProofState":"K : Type u_1\ninstâœÂ² : DivisionRing K\ninstâœÂ¹ : TopologicalSpace K\ninstâœ : ContinuousMul K\na : K\nha : Ne a 0\nâŠ¢ Filter.Tendsto (fun x => HMul.hMul a x) (Filter.cocompact K) (Filter.cocompact K)","decl":"/-- Left-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_leftâ‚€ [ContinuousMul K] {a : K} (ha : a â‰  0) :\n    Filter.Tendsto (fun x : K => a * x) (Filter.cocompact K) (Filter.cocompact K) :=\n  Filter.tendsto_cocompact_mul_left (inv_mul_cancelâ‚€ ha)\n\n"}
{"name":"Filter.tendsto_cocompact_mul_rightâ‚€","module":"Mathlib.Topology.Algebra.Field","initialProofState":"K : Type u_1\ninstâœÂ² : DivisionRing K\ninstâœÂ¹ : TopologicalSpace K\ninstâœ : ContinuousMul K\na : K\nha : Ne a 0\nâŠ¢ Filter.Tendsto (fun x => HMul.hMul x a) (Filter.cocompact K) (Filter.cocompact K)","decl":"/-- Right-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_rightâ‚€ [ContinuousMul K] {a : K} (ha : a â‰  0) :\n    Filter.Tendsto (fun x : K => x * a) (Filter.cocompact K) (Filter.cocompact K) :=\n  Filter.tendsto_cocompact_mul_right (mul_inv_cancelâ‚€ ha)\n\n"}
{"name":"instFiniteOfTopologicalRingOfCompactSpaceOfT2Space","module":"Mathlib.Topology.Algebra.Field","initialProofState":"K : Type u_2\ninstâœâ´ : DivisionRing K\ninstâœÂ³ : TopologicalSpace K\ninstâœÂ² : TopologicalRing K\ninstâœÂ¹ : CompactSpace K\ninstâœ : T2Space K\nâŠ¢ Finite K","decl":"/-- Compact hausdorff topological fields are finite. -/\ninstance (priority := 100) {K} [DivisionRing K] [TopologicalSpace K]\n    [TopologicalRing K] [CompactSpace K] [T2Space K] : Finite K := by\n  suffices DiscreteTopology K by\n    exact finite_of_compact_of_discrete\n  rw [discreteTopology_iff_isOpen_singleton_zero]\n  exact GroupWithZero.isOpen_singleton_zero\n\n"}
{"name":"TopologicalDivisionRing.toTopologicalRing","module":"Mathlib.Topology.Algebra.Field","initialProofState":"K : Type u_1\ninstâœÂ¹ : DivisionRing K\ninstâœ : TopologicalSpace K\nself : TopologicalDivisionRing K\nâŠ¢ TopologicalRing K","decl":"/-- A topological division ring is a division ring with a topology where all operations are\n    continuous, including inversion. -/\nclass TopologicalDivisionRing extends TopologicalRing K, HasContinuousInvâ‚€ K : Prop\n\n"}
{"name":"TopologicalDivisionRing.toHasContinuousInvâ‚€","module":"Mathlib.Topology.Algebra.Field","initialProofState":"K : Type u_1\ninstâœÂ¹ : DivisionRing K\ninstâœ : TopologicalSpace K\nself : TopologicalDivisionRing K\nâŠ¢ HasContinuousInvâ‚€ K","decl":"/-- A topological division ring is a division ring with a topology where all operations are\n    continuous, including inversion. -/\nclass TopologicalDivisionRing extends TopologicalRing K, HasContinuousInvâ‚€ K : Prop\n\n"}
{"name":"Subfield.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Field","initialProofState":"Î± : Type u_2\ninstâœÂ² : Field Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalDivisionRing Î±\ns : Subfield Î±\nâŠ¢ LE.le s s.topologicalClosure","decl":"theorem Subfield.le_topologicalClosure (s : Subfield Î±) : s â‰¤ s.topologicalClosure :=\n  _root_.subset_closure\n\n"}
{"name":"Subfield.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Field","initialProofState":"Î± : Type u_2\ninstâœÂ² : Field Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalDivisionRing Î±\ns : Subfield Î±\nâŠ¢ IsClosed â†‘s.topologicalClosure","decl":"theorem Subfield.isClosed_topologicalClosure (s : Subfield Î±) :\n    IsClosed (s.topologicalClosure : Set Î±) :=\n  isClosed_closure\n\n"}
{"name":"Subfield.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Field","initialProofState":"Î± : Type u_2\ninstâœÂ² : Field Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalDivisionRing Î±\ns t : Subfield Î±\nh : LE.le s t\nht : IsClosed â†‘t\nâŠ¢ LE.le s.topologicalClosure t","decl":"theorem Subfield.topologicalClosure_minimal (s : Subfield Î±) {t : Subfield Î±} (h : s â‰¤ t)\n    (ht : IsClosed (t : Set Î±)) : s.topologicalClosure â‰¤ t :=\n  closure_minimal h ht\n\n"}
{"name":"affineHomeomorph_symm_apply","module":"Mathlib.Topology.Algebra.Field","initialProofState":"ğ•œ : Type u_2\ninstâœÂ¹ : Field ğ•œ\ninstâœ : TopologicalSpace ğ•œ\na b : ğ•œ\nh : Ne a 0\ny : ğ•œ\nâŠ¢ Eq ((affineHomeomorph a b h).symm y) (HDiv.hDiv (HSub.hSub y b) a)","decl":"/--\nThe map `fun x => a * x + b`, as a homeomorphism from `ğ•œ` (a topological field) to itself,\nwhen `a â‰  0`.\n-/\n@[simps]\ndef affineHomeomorph (a b : ğ•œ) (h : a â‰  0) : ğ•œ â‰ƒâ‚œ ğ•œ where\n  toFun x := a * x + b\n  invFun y := (y - b) / a\n  left_inv x := by\n    simp only [add_sub_cancel_right]\n    exact mul_div_cancel_leftâ‚€ x h\n  right_inv y := by simp [mul_div_cancelâ‚€ _ h]\n\n"}
{"name":"affineHomeomorph_apply","module":"Mathlib.Topology.Algebra.Field","initialProofState":"ğ•œ : Type u_2\ninstâœÂ¹ : Field ğ•œ\ninstâœ : TopologicalSpace ğ•œ\na b : ğ•œ\nh : Ne a 0\nx : ğ•œ\nâŠ¢ Eq ((affineHomeomorph a b h) x) (HAdd.hAdd (HMul.hMul a x) b)","decl":"/--\nThe map `fun x => a * x + b`, as a homeomorphism from `ğ•œ` (a topological field) to itself,\nwhen `a â‰  0`.\n-/\n@[simps]\ndef affineHomeomorph (a b : ğ•œ) (h : a â‰  0) : ğ•œ â‰ƒâ‚œ ğ•œ where\n  toFun x := a * x + b\n  invFun y := (y - b) / a\n  left_inv x := by\n    simp only [add_sub_cancel_right]\n    exact mul_div_cancel_leftâ‚€ x h\n  right_inv y := by simp [mul_div_cancelâ‚€ _ h]\n\n"}
{"name":"affineHomeomorph_image_Icc","module":"Mathlib.Topology.Algebra.Field","initialProofState":"ğ•œ : Type u_3\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : TopologicalRing ğ•œ\na b c d : ğ•œ\nh : LT.lt 0 a\nâŠ¢ Eq (Set.image (â‡‘(affineHomeomorph a b â‹¯)) (Set.Icc c d)) (Set.Icc (HAdd.hAdd (HMul.hMul a c) b) (HAdd.hAdd (HMul.hMul a d) b))","decl":"theorem affineHomeomorph_image_Icc {ğ•œ : Type*} [LinearOrderedField ğ•œ] [TopologicalSpace ğ•œ]\n    [TopologicalRing ğ•œ] (a b c d : ğ•œ) (h : 0 < a) :\n    affineHomeomorph a b h.ne' '' Set.Icc c d = Set.Icc (a * c + b) (a * d + b) := by\n  simp [h]\n\n"}
{"name":"affineHomeomorph_image_Ico","module":"Mathlib.Topology.Algebra.Field","initialProofState":"ğ•œ : Type u_3\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : TopologicalRing ğ•œ\na b c d : ğ•œ\nh : LT.lt 0 a\nâŠ¢ Eq (Set.image (â‡‘(affineHomeomorph a b â‹¯)) (Set.Ico c d)) (Set.Ico (HAdd.hAdd (HMul.hMul a c) b) (HAdd.hAdd (HMul.hMul a d) b))","decl":"theorem affineHomeomorph_image_Ico {ğ•œ : Type*} [LinearOrderedField ğ•œ] [TopologicalSpace ğ•œ]\n    [TopologicalRing ğ•œ] (a b c d : ğ•œ) (h : 0 < a) :\n    affineHomeomorph a b h.ne' '' Set.Ico c d = Set.Ico (a * c + b) (a * d + b) := by\n  simp [h]\n\n"}
{"name":"affineHomeomorph_image_Ioc","module":"Mathlib.Topology.Algebra.Field","initialProofState":"ğ•œ : Type u_3\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : TopologicalRing ğ•œ\na b c d : ğ•œ\nh : LT.lt 0 a\nâŠ¢ Eq (Set.image (â‡‘(affineHomeomorph a b â‹¯)) (Set.Ioc c d)) (Set.Ioc (HAdd.hAdd (HMul.hMul a c) b) (HAdd.hAdd (HMul.hMul a d) b))","decl":"theorem affineHomeomorph_image_Ioc {ğ•œ : Type*} [LinearOrderedField ğ•œ] [TopologicalSpace ğ•œ]\n    [TopologicalRing ğ•œ] (a b c d : ğ•œ) (h : 0 < a) :\n    affineHomeomorph a b h.ne' '' Set.Ioc c d = Set.Ioc (a * c + b) (a * d + b) := by\n  simp [h]\n\n"}
{"name":"affineHomeomorph_image_Ioo","module":"Mathlib.Topology.Algebra.Field","initialProofState":"ğ•œ : Type u_3\ninstâœÂ² : LinearOrderedField ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : TopologicalRing ğ•œ\na b c d : ğ•œ\nh : LT.lt 0 a\nâŠ¢ Eq (Set.image (â‡‘(affineHomeomorph a b â‹¯)) (Set.Ioo c d)) (Set.Ioo (HAdd.hAdd (HMul.hMul a c) b) (HAdd.hAdd (HMul.hMul a d) b))","decl":"theorem affineHomeomorph_image_Ioo {ğ•œ : Type*} [LinearOrderedField ğ•œ] [TopologicalSpace ğ•œ]\n    [TopologicalRing ğ•œ] (a b c d : ğ•œ) (h : 0 < a) :\n    affineHomeomorph a b h.ne' '' Set.Ioo c d = Set.Ioo (a * c + b) (a * d + b) := by\n  simp [h]\n\n"}
{"name":"IsLocalMin.inv","module":"Mathlib.Topology.Algebra.Field","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : LinearOrderedSemifield Î²\nf : Î± â†’ Î²\na : Î±\nh1 : IsLocalMin f a\nh2 : Filter.Eventually (fun z => LT.lt 0 (f z)) (nhds a)\nâŠ¢ IsLocalMax (Inv.inv f) a","decl":"theorem IsLocalMin.inv {f : Î± â†’ Î²} {a : Î±} (h1 : IsLocalMin f a) (h2 : âˆ€á¶  z in ğ“ a, 0 < f z) :\n    IsLocalMax fâ»Â¹ a := by\n  filter_upwards [h1, h2] with z h3 h4 using(inv_le_invâ‚€ h4 h2.self_of_nhds).mpr h3\n\n"}
{"name":"IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq","module":"Mathlib.Topology.Algebra.Field","initialProofState":"Î± : Type u_2\nğ•œ : Type u_3\nf : Î± â†’ ğ•œ\nS : Set Î±\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : TopologicalSpace ğ•œ\ninstâœÂ² : T1Space ğ•œ\ninstâœÂ¹ : Ring ğ•œ\ninstâœ : NoZeroDivisors ğ•œ\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : Set.EqOn (HPow.hPow f 2) 1 S\nâŠ¢ Or (Set.EqOn f 1 S) (Set.EqOn f (-1) S)","decl":"/-- If `f` is a function `Î± â†’ ğ•œ` which is continuous on a preconnected set `S`, and\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. -/\ntheorem IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq [Ring ğ•œ] [NoZeroDivisors ğ•œ]\n    (hS : IsPreconnected S) (hf : ContinuousOn f S) (hsq : EqOn (f ^ 2) 1 S) :\n    EqOn f 1 S âˆ¨ EqOn f (-1) S := by\n  have : DiscreteTopology ({1, -1} : Set ğ•œ) := Finite.instDiscreteTopology\n  have hmaps : MapsTo f S {1, -1} := by\n    simpa only [EqOn, Pi.one_apply, Pi.pow_apply, sq_eq_one_iff] using hsq\n  simpa using hS.eqOn_const_of_mapsTo hf hmaps\n\n"}
{"name":"IsPreconnected.eq_or_eq_neg_of_sq_eq","module":"Mathlib.Topology.Algebra.Field","initialProofState":"Î± : Type u_2\nğ•œ : Type u_3\nf g : Î± â†’ ğ•œ\nS : Set Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : TopologicalSpace ğ•œ\ninstâœÂ³ : T1Space ğ•œ\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : HasContinuousInvâ‚€ ğ•œ\ninstâœ : ContinuousMul ğ•œ\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhg : ContinuousOn g S\nhsq : Set.EqOn (HPow.hPow f 2) (HPow.hPow g 2) S\nhg_ne : âˆ€ {x : Î±}, Membership.mem S x â†’ Ne (g x) 0\nâŠ¢ Or (Set.EqOn f g S) (Set.EqOn f (Neg.neg g) S)","decl":"/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then either `f = g` or `f = -g` on\n`S`. -/\ntheorem IsPreconnected.eq_or_eq_neg_of_sq_eq [Field ğ•œ] [HasContinuousInvâ‚€ ğ•œ] [ContinuousMul ğ•œ]\n    (hS : IsPreconnected S) (hf : ContinuousOn f S) (hg : ContinuousOn g S)\n    (hsq : EqOn (f ^ 2) (g ^ 2) S) (hg_ne : âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) :\n    EqOn f g S âˆ¨ EqOn f (-g) S := by\n  have hsq : EqOn ((f / g) ^ 2) 1 S := fun x hx => by\n    simpa [div_eq_one_iff_eq (pow_ne_zero _ (hg_ne hx)), div_pow] using hsq hx\n  simpa (config := { contextual := true }) [EqOn, div_eq_iff (hg_ne _)]\n    using hS.eq_one_or_eq_neg_one_of_sq_eq (hf.div hg fun z => hg_ne) hsq\n\n"}
{"name":"IsPreconnected.eq_of_sq_eq","module":"Mathlib.Topology.Algebra.Field","initialProofState":"Î± : Type u_2\nğ•œ : Type u_3\nf g : Î± â†’ ğ•œ\nS : Set Î±\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : TopologicalSpace ğ•œ\ninstâœÂ³ : T1Space ğ•œ\ninstâœÂ² : Field ğ•œ\ninstâœÂ¹ : HasContinuousInvâ‚€ ğ•œ\ninstâœ : ContinuousMul ğ•œ\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhg : ContinuousOn g S\nhsq : Set.EqOn (HPow.hPow f 2) (HPow.hPow g 2) S\nhg_ne : âˆ€ {x : Î±}, Membership.mem S x â†’ Ne (g x) 0\ny : Î±\nhy : Membership.mem S y\nhy' : Eq (f y) (g y)\nâŠ¢ Set.EqOn f g S","decl":"/-- If `f, g` are functions `Î± â†’ ğ•œ`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z â‰  0` all `z âˆˆ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem IsPreconnected.eq_of_sq_eq [Field ğ•œ] [HasContinuousInvâ‚€ ğ•œ] [ContinuousMul ğ•œ]\n    (hS : IsPreconnected S) (hf : ContinuousOn f S) (hg : ContinuousOn g S)\n    (hsq : EqOn (f ^ 2) (g ^ 2) S) (hg_ne : âˆ€ {x : Î±}, x âˆˆ S â†’ g x â‰  0) {y : Î±} (hy : y âˆˆ S)\n    (hy' : f y = g y) : EqOn f g S := fun x hx => by\n  rcases hS.eq_or_eq_neg_of_sq_eq hf hg @hsq @hg_ne with (h | h)\n  Â· exact h hx\n  Â· rw [h _, Pi.neg_apply, neg_eq_iff_add_eq_zero, â† two_mul, mul_eq_zero,\n      (iff_of_eq (iff_false _)).2 (hg_ne _)] at hy' âŠ¢ <;> assumption\n\n"}
{"name":"Subfield.continuousSMul","module":"Mathlib.Topology.Algebra.Field","initialProofState":"F : Type u_2\ninstâœâ´ : DivisionRing F\ninstâœÂ³ : TopologicalSpace F\nX : Type u_3\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : MulAction F X\ninstâœ : ContinuousSMul F X\nM : Subfield F\nâŠ¢ ContinuousSMul (Subtype fun x => Membership.mem M x) X","decl":"instance Subfield.continuousSMul (M : Subfield F) : ContinuousSMul M X :=\n  Subring.continuousSMul M.toSubring X\n\n"}
