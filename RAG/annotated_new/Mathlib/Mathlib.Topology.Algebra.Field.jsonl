{"name":"Filter.tendsto_cocompact_mul_left₀","module":"Mathlib.Topology.Algebra.Field","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\ninst✝¹ : TopologicalSpace K\ninst✝ : ContinuousMul K\na : K\nha : Ne a 0\n⊢ Filter.Tendsto (fun x => HMul.hMul a x) (Filter.cocompact K) (Filter.cocompact K)","decl":"/-- Left-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_left₀ [ContinuousMul K] {a : K} (ha : a ≠ 0) :\n    Filter.Tendsto (fun x : K => a * x) (Filter.cocompact K) (Filter.cocompact K) :=\n  Filter.tendsto_cocompact_mul_left (inv_mul_cancel₀ ha)\n\n"}
{"name":"Filter.tendsto_cocompact_mul_right₀","module":"Mathlib.Topology.Algebra.Field","initialProofState":"K : Type u_1\ninst✝² : DivisionRing K\ninst✝¹ : TopologicalSpace K\ninst✝ : ContinuousMul K\na : K\nha : Ne a 0\n⊢ Filter.Tendsto (fun x => HMul.hMul x a) (Filter.cocompact K) (Filter.cocompact K)","decl":"/-- Right-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. -/\ntheorem Filter.tendsto_cocompact_mul_right₀ [ContinuousMul K] {a : K} (ha : a ≠ 0) :\n    Filter.Tendsto (fun x : K => x * a) (Filter.cocompact K) (Filter.cocompact K) :=\n  Filter.tendsto_cocompact_mul_right (mul_inv_cancel₀ ha)\n\n"}
{"name":"instFiniteOfTopologicalRingOfCompactSpaceOfT2Space","module":"Mathlib.Topology.Algebra.Field","initialProofState":"K : Type u_2\ninst✝⁴ : DivisionRing K\ninst✝³ : TopologicalSpace K\ninst✝² : TopologicalRing K\ninst✝¹ : CompactSpace K\ninst✝ : T2Space K\n⊢ Finite K","decl":"/-- Compact hausdorff topological fields are finite. -/\ninstance (priority := 100) {K} [DivisionRing K] [TopologicalSpace K]\n    [TopologicalRing K] [CompactSpace K] [T2Space K] : Finite K := by\n  suffices DiscreteTopology K by\n    exact finite_of_compact_of_discrete\n  rw [discreteTopology_iff_isOpen_singleton_zero]\n  exact GroupWithZero.isOpen_singleton_zero\n\n"}
{"name":"TopologicalDivisionRing.toTopologicalRing","module":"Mathlib.Topology.Algebra.Field","initialProofState":"K : Type u_1\ninst✝¹ : DivisionRing K\ninst✝ : TopologicalSpace K\nself : TopologicalDivisionRing K\n⊢ TopologicalRing K","decl":"/-- A topological division ring is a division ring with a topology where all operations are\n    continuous, including inversion. -/\nclass TopologicalDivisionRing extends TopologicalRing K, HasContinuousInv₀ K : Prop\n\n"}
{"name":"TopologicalDivisionRing.toHasContinuousInv₀","module":"Mathlib.Topology.Algebra.Field","initialProofState":"K : Type u_1\ninst✝¹ : DivisionRing K\ninst✝ : TopologicalSpace K\nself : TopologicalDivisionRing K\n⊢ HasContinuousInv₀ K","decl":"/-- A topological division ring is a division ring with a topology where all operations are\n    continuous, including inversion. -/\nclass TopologicalDivisionRing extends TopologicalRing K, HasContinuousInv₀ K : Prop\n\n"}
{"name":"Subfield.le_topologicalClosure","module":"Mathlib.Topology.Algebra.Field","initialProofState":"α : Type u_2\ninst✝² : Field α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalDivisionRing α\ns : Subfield α\n⊢ LE.le s s.topologicalClosure","decl":"theorem Subfield.le_topologicalClosure (s : Subfield α) : s ≤ s.topologicalClosure :=\n  _root_.subset_closure\n\n"}
{"name":"Subfield.isClosed_topologicalClosure","module":"Mathlib.Topology.Algebra.Field","initialProofState":"α : Type u_2\ninst✝² : Field α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalDivisionRing α\ns : Subfield α\n⊢ IsClosed ↑s.topologicalClosure","decl":"theorem Subfield.isClosed_topologicalClosure (s : Subfield α) :\n    IsClosed (s.topologicalClosure : Set α) :=\n  isClosed_closure\n\n"}
{"name":"Subfield.topologicalClosure_minimal","module":"Mathlib.Topology.Algebra.Field","initialProofState":"α : Type u_2\ninst✝² : Field α\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalDivisionRing α\ns t : Subfield α\nh : LE.le s t\nht : IsClosed ↑t\n⊢ LE.le s.topologicalClosure t","decl":"theorem Subfield.topologicalClosure_minimal (s : Subfield α) {t : Subfield α} (h : s ≤ t)\n    (ht : IsClosed (t : Set α)) : s.topologicalClosure ≤ t :=\n  closure_minimal h ht\n\n"}
{"name":"affineHomeomorph_symm_apply","module":"Mathlib.Topology.Algebra.Field","initialProofState":"𝕜 : Type u_2\ninst✝¹ : Field 𝕜\ninst✝ : TopologicalSpace 𝕜\na b : 𝕜\nh : Ne a 0\ny : 𝕜\n⊢ Eq ((affineHomeomorph a b h).symm y) (HDiv.hDiv (HSub.hSub y b) a)","decl":"/--\nThe map `fun x => a * x + b`, as a homeomorphism from `𝕜` (a topological field) to itself,\nwhen `a ≠ 0`.\n-/\n@[simps]\ndef affineHomeomorph (a b : 𝕜) (h : a ≠ 0) : 𝕜 ≃ₜ 𝕜 where\n  toFun x := a * x + b\n  invFun y := (y - b) / a\n  left_inv x := by\n    simp only [add_sub_cancel_right]\n    exact mul_div_cancel_left₀ x h\n  right_inv y := by simp [mul_div_cancel₀ _ h]\n\n"}
{"name":"affineHomeomorph_apply","module":"Mathlib.Topology.Algebra.Field","initialProofState":"𝕜 : Type u_2\ninst✝¹ : Field 𝕜\ninst✝ : TopologicalSpace 𝕜\na b : 𝕜\nh : Ne a 0\nx : 𝕜\n⊢ Eq ((affineHomeomorph a b h) x) (HAdd.hAdd (HMul.hMul a x) b)","decl":"/--\nThe map `fun x => a * x + b`, as a homeomorphism from `𝕜` (a topological field) to itself,\nwhen `a ≠ 0`.\n-/\n@[simps]\ndef affineHomeomorph (a b : 𝕜) (h : a ≠ 0) : 𝕜 ≃ₜ 𝕜 where\n  toFun x := a * x + b\n  invFun y := (y - b) / a\n  left_inv x := by\n    simp only [add_sub_cancel_right]\n    exact mul_div_cancel_left₀ x h\n  right_inv y := by simp [mul_div_cancel₀ _ h]\n\n"}
{"name":"affineHomeomorph_image_Icc","module":"Mathlib.Topology.Algebra.Field","initialProofState":"𝕜 : Type u_3\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : TopologicalRing 𝕜\na b c d : 𝕜\nh : LT.lt 0 a\n⊢ Eq (Set.image (⇑(affineHomeomorph a b ⋯)) (Set.Icc c d)) (Set.Icc (HAdd.hAdd (HMul.hMul a c) b) (HAdd.hAdd (HMul.hMul a d) b))","decl":"theorem affineHomeomorph_image_Icc {𝕜 : Type*} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜]\n    [TopologicalRing 𝕜] (a b c d : 𝕜) (h : 0 < a) :\n    affineHomeomorph a b h.ne' '' Set.Icc c d = Set.Icc (a * c + b) (a * d + b) := by\n  simp [h]\n\n"}
{"name":"affineHomeomorph_image_Ico","module":"Mathlib.Topology.Algebra.Field","initialProofState":"𝕜 : Type u_3\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : TopologicalRing 𝕜\na b c d : 𝕜\nh : LT.lt 0 a\n⊢ Eq (Set.image (⇑(affineHomeomorph a b ⋯)) (Set.Ico c d)) (Set.Ico (HAdd.hAdd (HMul.hMul a c) b) (HAdd.hAdd (HMul.hMul a d) b))","decl":"theorem affineHomeomorph_image_Ico {𝕜 : Type*} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜]\n    [TopologicalRing 𝕜] (a b c d : 𝕜) (h : 0 < a) :\n    affineHomeomorph a b h.ne' '' Set.Ico c d = Set.Ico (a * c + b) (a * d + b) := by\n  simp [h]\n\n"}
{"name":"affineHomeomorph_image_Ioc","module":"Mathlib.Topology.Algebra.Field","initialProofState":"𝕜 : Type u_3\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : TopologicalRing 𝕜\na b c d : 𝕜\nh : LT.lt 0 a\n⊢ Eq (Set.image (⇑(affineHomeomorph a b ⋯)) (Set.Ioc c d)) (Set.Ioc (HAdd.hAdd (HMul.hMul a c) b) (HAdd.hAdd (HMul.hMul a d) b))","decl":"theorem affineHomeomorph_image_Ioc {𝕜 : Type*} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜]\n    [TopologicalRing 𝕜] (a b c d : 𝕜) (h : 0 < a) :\n    affineHomeomorph a b h.ne' '' Set.Ioc c d = Set.Ioc (a * c + b) (a * d + b) := by\n  simp [h]\n\n"}
{"name":"affineHomeomorph_image_Ioo","module":"Mathlib.Topology.Algebra.Field","initialProofState":"𝕜 : Type u_3\ninst✝² : LinearOrderedField 𝕜\ninst✝¹ : TopologicalSpace 𝕜\ninst✝ : TopologicalRing 𝕜\na b c d : 𝕜\nh : LT.lt 0 a\n⊢ Eq (Set.image (⇑(affineHomeomorph a b ⋯)) (Set.Ioo c d)) (Set.Ioo (HAdd.hAdd (HMul.hMul a c) b) (HAdd.hAdd (HMul.hMul a d) b))","decl":"theorem affineHomeomorph_image_Ioo {𝕜 : Type*} [LinearOrderedField 𝕜] [TopologicalSpace 𝕜]\n    [TopologicalRing 𝕜] (a b c d : 𝕜) (h : 0 < a) :\n    affineHomeomorph a b h.ne' '' Set.Ioo c d = Set.Ioo (a * c + b) (a * d + b) := by\n  simp [h]\n\n"}
{"name":"IsLocalMin.inv","module":"Mathlib.Topology.Algebra.Field","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : LinearOrderedSemifield β\nf : α → β\na : α\nh1 : IsLocalMin f a\nh2 : Filter.Eventually (fun z => LT.lt 0 (f z)) (nhds a)\n⊢ IsLocalMax (Inv.inv f) a","decl":"theorem IsLocalMin.inv {f : α → β} {a : α} (h1 : IsLocalMin f a) (h2 : ∀ᶠ z in 𝓝 a, 0 < f z) :\n    IsLocalMax f⁻¹ a := by\n  filter_upwards [h1, h2] with z h3 h4 using(inv_le_inv₀ h4 h2.self_of_nhds).mpr h3\n\n"}
{"name":"IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq","module":"Mathlib.Topology.Algebra.Field","initialProofState":"α : Type u_2\n𝕜 : Type u_3\nf : α → 𝕜\nS : Set α\ninst✝⁴ : TopologicalSpace α\ninst✝³ : TopologicalSpace 𝕜\ninst✝² : T1Space 𝕜\ninst✝¹ : Ring 𝕜\ninst✝ : NoZeroDivisors 𝕜\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : Set.EqOn (HPow.hPow f 2) 1 S\n⊢ Or (Set.EqOn f 1 S) (Set.EqOn f (-1) S)","decl":"/-- If `f` is a function `α → 𝕜` which is continuous on a preconnected set `S`, and\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. -/\ntheorem IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq [Ring 𝕜] [NoZeroDivisors 𝕜]\n    (hS : IsPreconnected S) (hf : ContinuousOn f S) (hsq : EqOn (f ^ 2) 1 S) :\n    EqOn f 1 S ∨ EqOn f (-1) S := by\n  have : DiscreteTopology ({1, -1} : Set 𝕜) := Finite.instDiscreteTopology\n  have hmaps : MapsTo f S {1, -1} := by\n    simpa only [EqOn, Pi.one_apply, Pi.pow_apply, sq_eq_one_iff] using hsq\n  simpa using hS.eqOn_const_of_mapsTo hf hmaps\n\n"}
{"name":"IsPreconnected.eq_or_eq_neg_of_sq_eq","module":"Mathlib.Topology.Algebra.Field","initialProofState":"α : Type u_2\n𝕜 : Type u_3\nf g : α → 𝕜\nS : Set α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : T1Space 𝕜\ninst✝² : Field 𝕜\ninst✝¹ : HasContinuousInv₀ 𝕜\ninst✝ : ContinuousMul 𝕜\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhg : ContinuousOn g S\nhsq : Set.EqOn (HPow.hPow f 2) (HPow.hPow g 2) S\nhg_ne : ∀ {x : α}, Membership.mem S x → Ne (g x) 0\n⊢ Or (Set.EqOn f g S) (Set.EqOn f (Neg.neg g) S)","decl":"/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then either `f = g` or `f = -g` on\n`S`. -/\ntheorem IsPreconnected.eq_or_eq_neg_of_sq_eq [Field 𝕜] [HasContinuousInv₀ 𝕜] [ContinuousMul 𝕜]\n    (hS : IsPreconnected S) (hf : ContinuousOn f S) (hg : ContinuousOn g S)\n    (hsq : EqOn (f ^ 2) (g ^ 2) S) (hg_ne : ∀ {x : α}, x ∈ S → g x ≠ 0) :\n    EqOn f g S ∨ EqOn f (-g) S := by\n  have hsq : EqOn ((f / g) ^ 2) 1 S := fun x hx => by\n    simpa [div_eq_one_iff_eq (pow_ne_zero _ (hg_ne hx)), div_pow] using hsq hx\n  simpa (config := { contextual := true }) [EqOn, div_eq_iff (hg_ne _)]\n    using hS.eq_one_or_eq_neg_one_of_sq_eq (hf.div hg fun z => hg_ne) hsq\n\n"}
{"name":"IsPreconnected.eq_of_sq_eq","module":"Mathlib.Topology.Algebra.Field","initialProofState":"α : Type u_2\n𝕜 : Type u_3\nf g : α → 𝕜\nS : Set α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : TopologicalSpace 𝕜\ninst✝³ : T1Space 𝕜\ninst✝² : Field 𝕜\ninst✝¹ : HasContinuousInv₀ 𝕜\ninst✝ : ContinuousMul 𝕜\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhg : ContinuousOn g S\nhsq : Set.EqOn (HPow.hPow f 2) (HPow.hPow g 2) S\nhg_ne : ∀ {x : α}, Membership.mem S x → Ne (g x) 0\ny : α\nhy : Membership.mem S y\nhy' : Eq (f y) (g y)\n⊢ Set.EqOn f g S","decl":"/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem IsPreconnected.eq_of_sq_eq [Field 𝕜] [HasContinuousInv₀ 𝕜] [ContinuousMul 𝕜]\n    (hS : IsPreconnected S) (hf : ContinuousOn f S) (hg : ContinuousOn g S)\n    (hsq : EqOn (f ^ 2) (g ^ 2) S) (hg_ne : ∀ {x : α}, x ∈ S → g x ≠ 0) {y : α} (hy : y ∈ S)\n    (hy' : f y = g y) : EqOn f g S := fun x hx => by\n  rcases hS.eq_or_eq_neg_of_sq_eq hf hg @hsq @hg_ne with (h | h)\n  · exact h hx\n  · rw [h _, Pi.neg_apply, neg_eq_iff_add_eq_zero, ← two_mul, mul_eq_zero,\n      (iff_of_eq (iff_false _)).2 (hg_ne _)] at hy' ⊢ <;> assumption\n\n"}
{"name":"Subfield.continuousSMul","module":"Mathlib.Topology.Algebra.Field","initialProofState":"F : Type u_2\ninst✝⁴ : DivisionRing F\ninst✝³ : TopologicalSpace F\nX : Type u_3\ninst✝² : TopologicalSpace X\ninst✝¹ : MulAction F X\ninst✝ : ContinuousSMul F X\nM : Subfield F\n⊢ ContinuousSMul (Subtype fun x => Membership.mem M x) X","decl":"instance Subfield.continuousSMul (M : Subfield F) : ContinuousSMul M X :=\n  Subring.continuousSMul M.toSubring X\n\n"}
