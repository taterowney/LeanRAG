{"name":"AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\n⊢ Eq (Nat.card α) (HMul.hMul (Nat.card (HasQuotient.Quotient α s)) (Nat.card (Subtype fun x => Membership.mem s x)))","decl":"@[to_additive AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup]\ntheorem card_eq_card_quotient_mul_card_subgroup (s : Subgroup α) :\n    Nat.card α = Nat.card (α ⧸ s) * Nat.card s := by\n  rw [← Nat.card_prod]; exact Nat.card_congr Subgroup.groupEquivQuotientProdSubgroup\n\n"}
{"name":"Subgroup.card_eq_card_quotient_mul_card_subgroup","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\n⊢ Eq (Nat.card α) (HMul.hMul (Nat.card (HasQuotient.Quotient α s)) (Nat.card (Subtype fun x => Membership.mem s x)))","decl":"@[to_additive AddSubgroup.card_eq_card_quotient_mul_card_addSubgroup]\ntheorem card_eq_card_quotient_mul_card_subgroup (s : Subgroup α) :\n    Nat.card α = Nat.card (α ⧸ s) * Nat.card s := by\n  rw [← Nat.card_prod]; exact Nat.card_congr Subgroup.groupEquivQuotientProdSubgroup\n\n"}
{"name":"Subgroup.card_mul_eq_card_subgroup_mul_card_quotient","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nt : Set α\n⊢ Eq (Nat.card ↑(HMul.hMul t ↑s)) (HMul.hMul (Nat.card (Subtype fun x => Membership.mem s x)) (Nat.card ↑(Set.image QuotientGroup.mk t)))","decl":"@[to_additive]\nlemma card_mul_eq_card_subgroup_mul_card_quotient (s : Subgroup α) (t : Set α) :\n    Nat.card (t * s : Set α) = Nat.card s * Nat.card (t.image (↑) : Set (α ⧸ s)) := by\n  rw [← Nat.card_prod, Nat.card_congr]\n  apply Equiv.trans _ (QuotientGroup.preimageMkEquivSubgroupProdSet _ _)\n  rw [QuotientGroup.preimage_image_mk]\n  convert Equiv.refl ↑(t * s)\n  aesop (add simp [Set.mem_mul])\n\n"}
{"name":"AddSubgroup.card_add_eq_card_addSubgroup_add_card_quotient","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nt : Set α\n⊢ Eq (Nat.card ↑(HAdd.hAdd t ↑s)) (HMul.hMul (Nat.card (Subtype fun x => Membership.mem s x)) (Nat.card ↑(Set.image QuotientAddGroup.mk t)))","decl":"@[to_additive]\nlemma card_mul_eq_card_subgroup_mul_card_quotient (s : Subgroup α) (t : Set α) :\n    Nat.card (t * s : Set α) = Nat.card s * Nat.card (t.image (↑) : Set (α ⧸ s)) := by\n  rw [← Nat.card_prod, Nat.card_congr]\n  apply Equiv.trans _ (QuotientGroup.preimageMkEquivSubgroupProdSet _ _)\n  rw [QuotientGroup.preimage_image_mk]\n  convert Equiv.refl ↑(t * s)\n  aesop (add simp [Set.mem_mul])\n\n"}
{"name":"AddSubgroup.card_addSubgroup_dvd_card","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\n⊢ Dvd.dvd (Nat.card (Subtype fun x => Membership.mem s x)) (Nat.card α)","decl":"/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\n@[to_additive \"**Lagrange's Theorem**: The order of an additive subgroup divides the order of its\n ambient additive group.\"]\ntheorem card_subgroup_dvd_card (s : Subgroup α) : Nat.card s ∣ Nat.card α := by\n  classical simp [card_eq_card_quotient_mul_card_subgroup s, @dvd_mul_left ℕ]\n\n"}
{"name":"Subgroup.card_subgroup_dvd_card","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\n⊢ Dvd.dvd (Nat.card (Subtype fun x => Membership.mem s x)) (Nat.card α)","decl":"/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\n@[to_additive \"**Lagrange's Theorem**: The order of an additive subgroup divides the order of its\n ambient additive group.\"]\ntheorem card_subgroup_dvd_card (s : Subgroup α) : Nat.card s ∣ Nat.card α := by\n  classical simp [card_eq_card_quotient_mul_card_subgroup s, @dvd_mul_left ℕ]\n\n"}
{"name":"AddSubgroup.card_quotient_dvd_card","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\n⊢ Dvd.dvd (Nat.card (HasQuotient.Quotient α s)) (Nat.card α)","decl":"@[to_additive]\ntheorem card_quotient_dvd_card (s : Subgroup α) : Nat.card (α ⧸ s) ∣ Nat.card α := by\n  simp [card_eq_card_quotient_mul_card_subgroup s, @dvd_mul_right ℕ]\n\n"}
{"name":"Subgroup.card_quotient_dvd_card","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\n⊢ Dvd.dvd (Nat.card (HasQuotient.Quotient α s)) (Nat.card α)","decl":"@[to_additive]\ntheorem card_quotient_dvd_card (s : Subgroup α) : Nat.card (α ⧸ s) ∣ Nat.card α := by\n  simp [card_eq_card_quotient_mul_card_subgroup s, @dvd_mul_right ℕ]\n\n"}
{"name":"Subgroup.card_dvd_of_injective","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝¹ : Group α\nH : Type u_2\ninst✝ : Group H\nf : MonoidHom α H\nhf : Function.Injective ⇑f\n⊢ Dvd.dvd (Nat.card α) (Nat.card H)","decl":"@[to_additive]\ntheorem card_dvd_of_injective (f : α →* H) (hf : Function.Injective f) :\n    Nat.card α ∣ Nat.card H := by\n  classical calc\n      Nat.card α = Nat.card (f.range : Subgroup H) := Nat.card_congr (Equiv.ofInjective f hf)\n      _ ∣ Nat.card H := card_subgroup_dvd_card _\n\n"}
{"name":"AddSubgroup.card_dvd_of_injective","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\nH : Type u_2\ninst✝ : AddGroup H\nf : AddMonoidHom α H\nhf : Function.Injective ⇑f\n⊢ Dvd.dvd (Nat.card α) (Nat.card H)","decl":"@[to_additive]\ntheorem card_dvd_of_injective (f : α →* H) (hf : Function.Injective f) :\n    Nat.card α ∣ Nat.card H := by\n  classical calc\n      Nat.card α = Nat.card (f.range : Subgroup H) := Nat.card_congr (Equiv.ofInjective f hf)\n      _ ∣ Nat.card H := card_subgroup_dvd_card _\n\n"}
{"name":"Subgroup.card_dvd_of_le","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝ : Group α\nH K : Subgroup α\nhHK : LE.le H K\n⊢ Dvd.dvd (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card (Subtype fun x => Membership.mem K x))","decl":"@[to_additive]\ntheorem card_dvd_of_le {H K : Subgroup α} (hHK : H ≤ K) : Nat.card H ∣ Nat.card K :=\n  card_dvd_of_injective (inclusion hHK) (inclusion_injective hHK)\n\n"}
{"name":"AddSubgroup.card_dvd_of_le","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nH K : AddSubgroup α\nhHK : LE.le H K\n⊢ Dvd.dvd (Nat.card (Subtype fun x => Membership.mem H x)) (Nat.card (Subtype fun x => Membership.mem K x))","decl":"@[to_additive]\ntheorem card_dvd_of_le {H K : Subgroup α} (hHK : H ≤ K) : Nat.card H ∣ Nat.card K :=\n  card_dvd_of_injective (inclusion hHK) (inclusion_injective hHK)\n\n"}
{"name":"AddSubgroup.card_comap_dvd_of_injective","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\nH : Type u_2\ninst✝ : AddGroup H\nK : AddSubgroup H\nf : AddMonoidHom α H\nhf : Function.Injective ⇑f\n⊢ Dvd.dvd (Nat.card (Subtype fun x => Membership.mem (AddSubgroup.comap f K) x)) (Nat.card (Subtype fun x => Membership.mem K x))","decl":"@[to_additive]\ntheorem card_comap_dvd_of_injective (K : Subgroup H) (f : α →* H)\n    (hf : Function.Injective f) : Nat.card (K.comap f) ∣ Nat.card K :=\n  calc Nat.card (K.comap f) = Nat.card ((K.comap f).map f) :=\n      Nat.card_congr (equivMapOfInjective _ _ hf).toEquiv\n    _ ∣ Nat.card K := card_dvd_of_le (map_comap_le _ _)\n\n"}
{"name":"Subgroup.card_comap_dvd_of_injective","module":"Mathlib.GroupTheory.Coset.Card","initialProofState":"α : Type u_1\ninst✝¹ : Group α\nH : Type u_2\ninst✝ : Group H\nK : Subgroup H\nf : MonoidHom α H\nhf : Function.Injective ⇑f\n⊢ Dvd.dvd (Nat.card (Subtype fun x => Membership.mem (Subgroup.comap f K) x)) (Nat.card (Subtype fun x => Membership.mem K x))","decl":"@[to_additive]\ntheorem card_comap_dvd_of_injective (K : Subgroup H) (f : α →* H)\n    (hf : Function.Injective f) : Nat.card (K.comap f) ∣ Nat.card K :=\n  calc Nat.card (K.comap f) = Nat.card ((K.comap f).map f) :=\n      Nat.card_congr (equivMapOfInjective _ _ hf).toEquiv\n    _ ∣ Nat.card K := card_dvd_of_le (map_comap_le _ _)\n\n"}
