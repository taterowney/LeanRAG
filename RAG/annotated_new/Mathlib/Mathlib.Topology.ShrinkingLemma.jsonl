{"name":"ShrinkingLemma.PartialRefinement.closure_subset","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\nself : ShrinkingLemma.PartialRefinement u s p\ni : ι\na✝ : Membership.mem self.carrier i\n⊢ HasSubset.Subset (closure (self.toFun i)) (u i)","decl":"/-- Auxiliary definition for the proof of the shrinking lemma. A partial refinement of a covering\n`⋃ i, u i` of a set `s` is a map `v : ι → Set X` and a set `carrier : Set ι` such that\n\n* `s ⊆ ⋃ i, v i`;\n* all `v i` are open;\n* if `i ∈ carrier v`, then `closure (v i) ⊆ u i`;\n* if `i ∉ carrier`, then `v i = u i`.\n\nThis type is equipped with the following partial order: `v ≤ v'` if `v.carrier ⊆ v'.carrier`\nand `v i = v' i` for `i ∈ v.carrier`. We will use Zorn's lemma to prove that this type has\na maximal element, then show that the maximal element must have `carrier = univ`. -/\n@[ext] structure PartialRefinement (u : ι → Set X) (s : Set X) (p : Set X → Prop) where\n  /-- A family of sets that form a partial refinement of `u`. -/\n  toFun : ι → Set X\n  /-- The set of indexes `i` such that `i`-th set is already shrunk. -/\n  carrier : Set ι\n  /-- Each set from the partially refined family is open. -/\n  protected isOpen : ∀ i, IsOpen (toFun i)\n  /-- The partially refined family still covers the set. -/\n  subset_iUnion : s ⊆ ⋃ i, toFun i\n  /-- For each `i ∈ carrier`, the original set includes the closure of the refined set. -/\n  closure_subset : ∀ {i}, i ∈ carrier → closure (toFun i) ⊆ u i\n  /-- For each `i ∈ carrier`, the refined set satisfies `p`. -/\n  pred_of_mem {i} (hi : i ∈ carrier) : p (toFun i)\n  /-- Sets that correspond to `i ∉ carrier` are not modified. -/\n  apply_eq : ∀ {i}, i ∉ carrier → toFun i = u i\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.isOpen","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\nself : ShrinkingLemma.PartialRefinement u s p\ni : ι\n⊢ IsOpen (self.toFun i)","decl":"/-- Auxiliary definition for the proof of the shrinking lemma. A partial refinement of a covering\n`⋃ i, u i` of a set `s` is a map `v : ι → Set X` and a set `carrier : Set ι` such that\n\n* `s ⊆ ⋃ i, v i`;\n* all `v i` are open;\n* if `i ∈ carrier v`, then `closure (v i) ⊆ u i`;\n* if `i ∉ carrier`, then `v i = u i`.\n\nThis type is equipped with the following partial order: `v ≤ v'` if `v.carrier ⊆ v'.carrier`\nand `v i = v' i` for `i ∈ v.carrier`. We will use Zorn's lemma to prove that this type has\na maximal element, then show that the maximal element must have `carrier = univ`. -/\n@[ext] structure PartialRefinement (u : ι → Set X) (s : Set X) (p : Set X → Prop) where\n  /-- A family of sets that form a partial refinement of `u`. -/\n  toFun : ι → Set X\n  /-- The set of indexes `i` such that `i`-th set is already shrunk. -/\n  carrier : Set ι\n  /-- Each set from the partially refined family is open. -/\n  protected isOpen : ∀ i, IsOpen (toFun i)\n  /-- The partially refined family still covers the set. -/\n  subset_iUnion : s ⊆ ⋃ i, toFun i\n  /-- For each `i ∈ carrier`, the original set includes the closure of the refined set. -/\n  closure_subset : ∀ {i}, i ∈ carrier → closure (toFun i) ⊆ u i\n  /-- For each `i ∈ carrier`, the refined set satisfies `p`. -/\n  pred_of_mem {i} (hi : i ∈ carrier) : p (toFun i)\n  /-- Sets that correspond to `i ∉ carrier` are not modified. -/\n  apply_eq : ∀ {i}, i ∉ carrier → toFun i = u i\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.mk.injEq","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\ntoFun✝ : ι → Set X\ncarrier✝ : Set ι\nisOpen✝ : ∀ (i : ι), IsOpen (toFun✝ i)\nsubset_iUnion✝ : HasSubset.Subset s (Set.iUnion fun i => toFun✝ i)\nclosure_subset✝ : ∀ {i : ι}, Membership.mem carrier✝ i → HasSubset.Subset (closure (toFun✝ i)) (u i)\npred_of_mem✝ : ∀ {i : ι}, Membership.mem carrier✝ i → p (toFun✝ i)\napply_eq✝ : ∀ {i : ι}, Not (Membership.mem carrier✝ i) → Eq (toFun✝ i) (u i)\ntoFun : ι → Set X\ncarrier : Set ι\nisOpen : ∀ (i : ι), IsOpen (toFun i)\nsubset_iUnion : HasSubset.Subset s (Set.iUnion fun i => toFun i)\nclosure_subset : ∀ {i : ι}, Membership.mem carrier i → HasSubset.Subset (closure (toFun i)) (u i)\npred_of_mem : ∀ {i : ι}, Membership.mem carrier i → p (toFun i)\napply_eq : ∀ {i : ι}, Not (Membership.mem carrier i) → Eq (toFun i) (u i)\n⊢ Eq (Eq { toFun := toFun✝, carrier := carrier✝, isOpen := isOpen✝, subset_iUnion := subset_iUnion✝, closure_subset := closure_subset✝, pred_of_mem := pred_of_mem✝, apply_eq := apply_eq✝ } { toFun := toFun, carrier := carrier, isOpen := isOpen, subset_iUnion := subset_iUnion, closure_subset := closure_subset, pred_of_mem := pred_of_mem, apply_eq := apply_eq }) (And (Eq toFun✝ toFun) (Eq carrier✝ carrier))","decl":"/-- Auxiliary definition for the proof of the shrinking lemma. A partial refinement of a covering\n`⋃ i, u i` of a set `s` is a map `v : ι → Set X` and a set `carrier : Set ι` such that\n\n* `s ⊆ ⋃ i, v i`;\n* all `v i` are open;\n* if `i ∈ carrier v`, then `closure (v i) ⊆ u i`;\n* if `i ∉ carrier`, then `v i = u i`.\n\nThis type is equipped with the following partial order: `v ≤ v'` if `v.carrier ⊆ v'.carrier`\nand `v i = v' i` for `i ∈ v.carrier`. We will use Zorn's lemma to prove that this type has\na maximal element, then show that the maximal element must have `carrier = univ`. -/\n@[ext] structure PartialRefinement (u : ι → Set X) (s : Set X) (p : Set X → Prop) where\n  /-- A family of sets that form a partial refinement of `u`. -/\n  toFun : ι → Set X\n  /-- The set of indexes `i` such that `i`-th set is already shrunk. -/\n  carrier : Set ι\n  /-- Each set from the partially refined family is open. -/\n  protected isOpen : ∀ i, IsOpen (toFun i)\n  /-- The partially refined family still covers the set. -/\n  subset_iUnion : s ⊆ ⋃ i, toFun i\n  /-- For each `i ∈ carrier`, the original set includes the closure of the refined set. -/\n  closure_subset : ∀ {i}, i ∈ carrier → closure (toFun i) ⊆ u i\n  /-- For each `i ∈ carrier`, the refined set satisfies `p`. -/\n  pred_of_mem {i} (hi : i ∈ carrier) : p (toFun i)\n  /-- Sets that correspond to `i ∉ carrier` are not modified. -/\n  apply_eq : ∀ {i}, i ∉ carrier → toFun i = u i\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.mk.inj","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\ntoFun✝ : ι → Set X\ncarrier✝ : Set ι\nisOpen✝ : ∀ (i : ι), IsOpen (toFun✝ i)\nsubset_iUnion✝ : HasSubset.Subset s (Set.iUnion fun i => toFun✝ i)\nclosure_subset✝ : ∀ {i : ι}, Membership.mem carrier✝ i → HasSubset.Subset (closure (toFun✝ i)) (u i)\npred_of_mem✝ : ∀ {i : ι}, Membership.mem carrier✝ i → p (toFun✝ i)\napply_eq✝ : ∀ {i : ι}, Not (Membership.mem carrier✝ i) → Eq (toFun✝ i) (u i)\ntoFun : ι → Set X\ncarrier : Set ι\nisOpen : ∀ (i : ι), IsOpen (toFun i)\nsubset_iUnion : HasSubset.Subset s (Set.iUnion fun i => toFun i)\nclosure_subset : ∀ {i : ι}, Membership.mem carrier i → HasSubset.Subset (closure (toFun i)) (u i)\npred_of_mem : ∀ {i : ι}, Membership.mem carrier i → p (toFun i)\napply_eq : ∀ {i : ι}, Not (Membership.mem carrier i) → Eq (toFun i) (u i)\nx✝ : Eq { toFun := toFun✝, carrier := carrier✝, isOpen := isOpen✝, subset_iUnion := subset_iUnion✝, closure_subset := closure_subset✝, pred_of_mem := pred_of_mem✝, apply_eq := apply_eq✝ } { toFun := toFun, carrier := carrier, isOpen := isOpen, subset_iUnion := subset_iUnion, closure_subset := closure_subset, pred_of_mem := pred_of_mem, apply_eq := apply_eq }\n⊢ And (Eq toFun✝ toFun) (Eq carrier✝ carrier)","decl":"/-- Auxiliary definition for the proof of the shrinking lemma. A partial refinement of a covering\n`⋃ i, u i` of a set `s` is a map `v : ι → Set X` and a set `carrier : Set ι` such that\n\n* `s ⊆ ⋃ i, v i`;\n* all `v i` are open;\n* if `i ∈ carrier v`, then `closure (v i) ⊆ u i`;\n* if `i ∉ carrier`, then `v i = u i`.\n\nThis type is equipped with the following partial order: `v ≤ v'` if `v.carrier ⊆ v'.carrier`\nand `v i = v' i` for `i ∈ v.carrier`. We will use Zorn's lemma to prove that this type has\na maximal element, then show that the maximal element must have `carrier = univ`. -/\n@[ext] structure PartialRefinement (u : ι → Set X) (s : Set X) (p : Set X → Prop) where\n  /-- A family of sets that form a partial refinement of `u`. -/\n  toFun : ι → Set X\n  /-- The set of indexes `i` such that `i`-th set is already shrunk. -/\n  carrier : Set ι\n  /-- Each set from the partially refined family is open. -/\n  protected isOpen : ∀ i, IsOpen (toFun i)\n  /-- The partially refined family still covers the set. -/\n  subset_iUnion : s ⊆ ⋃ i, toFun i\n  /-- For each `i ∈ carrier`, the original set includes the closure of the refined set. -/\n  closure_subset : ∀ {i}, i ∈ carrier → closure (toFun i) ⊆ u i\n  /-- For each `i ∈ carrier`, the refined set satisfies `p`. -/\n  pred_of_mem {i} (hi : i ∈ carrier) : p (toFun i)\n  /-- Sets that correspond to `i ∉ carrier` are not modified. -/\n  apply_eq : ∀ {i}, i ∉ carrier → toFun i = u i\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.ext","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\nx y : ShrinkingLemma.PartialRefinement u s p\ntoFun : Eq x.toFun y.toFun\ncarrier : Eq x.carrier y.carrier\n⊢ Eq x y","decl":"/-- Auxiliary definition for the proof of the shrinking lemma. A partial refinement of a covering\n`⋃ i, u i` of a set `s` is a map `v : ι → Set X` and a set `carrier : Set ι` such that\n\n* `s ⊆ ⋃ i, v i`;\n* all `v i` are open;\n* if `i ∈ carrier v`, then `closure (v i) ⊆ u i`;\n* if `i ∉ carrier`, then `v i = u i`.\n\nThis type is equipped with the following partial order: `v ≤ v'` if `v.carrier ⊆ v'.carrier`\nand `v i = v' i` for `i ∈ v.carrier`. We will use Zorn's lemma to prove that this type has\na maximal element, then show that the maximal element must have `carrier = univ`. -/\n@[ext] structure PartialRefinement (u : ι → Set X) (s : Set X) (p : Set X → Prop) where\n  /-- A family of sets that form a partial refinement of `u`. -/\n  toFun : ι → Set X\n  /-- The set of indexes `i` such that `i`-th set is already shrunk. -/\n  carrier : Set ι\n  /-- Each set from the partially refined family is open. -/\n  protected isOpen : ∀ i, IsOpen (toFun i)\n  /-- The partially refined family still covers the set. -/\n  subset_iUnion : s ⊆ ⋃ i, toFun i\n  /-- For each `i ∈ carrier`, the original set includes the closure of the refined set. -/\n  closure_subset : ∀ {i}, i ∈ carrier → closure (toFun i) ⊆ u i\n  /-- For each `i ∈ carrier`, the refined set satisfies `p`. -/\n  pred_of_mem {i} (hi : i ∈ carrier) : p (toFun i)\n  /-- Sets that correspond to `i ∉ carrier` are not modified. -/\n  apply_eq : ∀ {i}, i ∉ carrier → toFun i = u i\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.mk.sizeOf_spec","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝⁵ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\ninst✝⁴ : SizeOf ι\ninst✝³ : SizeOf X\ninst✝² : (a : ι) → (a_1 : X) → SizeOf (u a a_1)\ninst✝¹ : (a : X) → SizeOf (s a)\ninst✝ : (a : Set X) → SizeOf (p a)\ntoFun : ι → Set X\ncarrier : Set ι\nisOpen : ∀ (i : ι), IsOpen (toFun i)\nsubset_iUnion : HasSubset.Subset s (Set.iUnion fun i => toFun i)\nclosure_subset : ∀ {i : ι}, Membership.mem carrier i → HasSubset.Subset (closure (toFun i)) (u i)\npred_of_mem : ∀ {i : ι}, Membership.mem carrier i → p (toFun i)\napply_eq : ∀ {i : ι}, Not (Membership.mem carrier i) → Eq (toFun i) (u i)\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, carrier := carrier, isOpen := isOpen, subset_iUnion := subset_iUnion, closure_subset := closure_subset, pred_of_mem := pred_of_mem, apply_eq := apply_eq }) 1","decl":"/-- Auxiliary definition for the proof of the shrinking lemma. A partial refinement of a covering\n`⋃ i, u i` of a set `s` is a map `v : ι → Set X` and a set `carrier : Set ι` such that\n\n* `s ⊆ ⋃ i, v i`;\n* all `v i` are open;\n* if `i ∈ carrier v`, then `closure (v i) ⊆ u i`;\n* if `i ∉ carrier`, then `v i = u i`.\n\nThis type is equipped with the following partial order: `v ≤ v'` if `v.carrier ⊆ v'.carrier`\nand `v i = v' i` for `i ∈ v.carrier`. We will use Zorn's lemma to prove that this type has\na maximal element, then show that the maximal element must have `carrier = univ`. -/\n@[ext] structure PartialRefinement (u : ι → Set X) (s : Set X) (p : Set X → Prop) where\n  /-- A family of sets that form a partial refinement of `u`. -/\n  toFun : ι → Set X\n  /-- The set of indexes `i` such that `i`-th set is already shrunk. -/\n  carrier : Set ι\n  /-- Each set from the partially refined family is open. -/\n  protected isOpen : ∀ i, IsOpen (toFun i)\n  /-- The partially refined family still covers the set. -/\n  subset_iUnion : s ⊆ ⋃ i, toFun i\n  /-- For each `i ∈ carrier`, the original set includes the closure of the refined set. -/\n  closure_subset : ∀ {i}, i ∈ carrier → closure (toFun i) ⊆ u i\n  /-- For each `i ∈ carrier`, the refined set satisfies `p`. -/\n  pred_of_mem {i} (hi : i ∈ carrier) : p (toFun i)\n  /-- Sets that correspond to `i ∉ carrier` are not modified. -/\n  apply_eq : ∀ {i}, i ∉ carrier → toFun i = u i\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.subset_iUnion","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\nself : ShrinkingLemma.PartialRefinement u s p\n⊢ HasSubset.Subset s (Set.iUnion fun i => self.toFun i)","decl":"/-- Auxiliary definition for the proof of the shrinking lemma. A partial refinement of a covering\n`⋃ i, u i` of a set `s` is a map `v : ι → Set X` and a set `carrier : Set ι` such that\n\n* `s ⊆ ⋃ i, v i`;\n* all `v i` are open;\n* if `i ∈ carrier v`, then `closure (v i) ⊆ u i`;\n* if `i ∉ carrier`, then `v i = u i`.\n\nThis type is equipped with the following partial order: `v ≤ v'` if `v.carrier ⊆ v'.carrier`\nand `v i = v' i` for `i ∈ v.carrier`. We will use Zorn's lemma to prove that this type has\na maximal element, then show that the maximal element must have `carrier = univ`. -/\n@[ext] structure PartialRefinement (u : ι → Set X) (s : Set X) (p : Set X → Prop) where\n  /-- A family of sets that form a partial refinement of `u`. -/\n  toFun : ι → Set X\n  /-- The set of indexes `i` such that `i`-th set is already shrunk. -/\n  carrier : Set ι\n  /-- Each set from the partially refined family is open. -/\n  protected isOpen : ∀ i, IsOpen (toFun i)\n  /-- The partially refined family still covers the set. -/\n  subset_iUnion : s ⊆ ⋃ i, toFun i\n  /-- For each `i ∈ carrier`, the original set includes the closure of the refined set. -/\n  closure_subset : ∀ {i}, i ∈ carrier → closure (toFun i) ⊆ u i\n  /-- For each `i ∈ carrier`, the refined set satisfies `p`. -/\n  pred_of_mem {i} (hi : i ∈ carrier) : p (toFun i)\n  /-- Sets that correspond to `i ∉ carrier` are not modified. -/\n  apply_eq : ∀ {i}, i ∉ carrier → toFun i = u i\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.apply_eq","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\nself : ShrinkingLemma.PartialRefinement u s p\ni : ι\na✝ : Not (Membership.mem self.carrier i)\n⊢ Eq (self.toFun i) (u i)","decl":"/-- Auxiliary definition for the proof of the shrinking lemma. A partial refinement of a covering\n`⋃ i, u i` of a set `s` is a map `v : ι → Set X` and a set `carrier : Set ι` such that\n\n* `s ⊆ ⋃ i, v i`;\n* all `v i` are open;\n* if `i ∈ carrier v`, then `closure (v i) ⊆ u i`;\n* if `i ∉ carrier`, then `v i = u i`.\n\nThis type is equipped with the following partial order: `v ≤ v'` if `v.carrier ⊆ v'.carrier`\nand `v i = v' i` for `i ∈ v.carrier`. We will use Zorn's lemma to prove that this type has\na maximal element, then show that the maximal element must have `carrier = univ`. -/\n@[ext] structure PartialRefinement (u : ι → Set X) (s : Set X) (p : Set X → Prop) where\n  /-- A family of sets that form a partial refinement of `u`. -/\n  toFun : ι → Set X\n  /-- The set of indexes `i` such that `i`-th set is already shrunk. -/\n  carrier : Set ι\n  /-- Each set from the partially refined family is open. -/\n  protected isOpen : ∀ i, IsOpen (toFun i)\n  /-- The partially refined family still covers the set. -/\n  subset_iUnion : s ⊆ ⋃ i, toFun i\n  /-- For each `i ∈ carrier`, the original set includes the closure of the refined set. -/\n  closure_subset : ∀ {i}, i ∈ carrier → closure (toFun i) ⊆ u i\n  /-- For each `i ∈ carrier`, the refined set satisfies `p`. -/\n  pred_of_mem {i} (hi : i ∈ carrier) : p (toFun i)\n  /-- Sets that correspond to `i ∉ carrier` are not modified. -/\n  apply_eq : ∀ {i}, i ∉ carrier → toFun i = u i\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.pred_of_mem","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\nself : ShrinkingLemma.PartialRefinement u s p\ni : ι\nhi : Membership.mem self.carrier i\n⊢ p (self.toFun i)","decl":"/-- Auxiliary definition for the proof of the shrinking lemma. A partial refinement of a covering\n`⋃ i, u i` of a set `s` is a map `v : ι → Set X` and a set `carrier : Set ι` such that\n\n* `s ⊆ ⋃ i, v i`;\n* all `v i` are open;\n* if `i ∈ carrier v`, then `closure (v i) ⊆ u i`;\n* if `i ∉ carrier`, then `v i = u i`.\n\nThis type is equipped with the following partial order: `v ≤ v'` if `v.carrier ⊆ v'.carrier`\nand `v i = v' i` for `i ∈ v.carrier`. We will use Zorn's lemma to prove that this type has\na maximal element, then show that the maximal element must have `carrier = univ`. -/\n@[ext] structure PartialRefinement (u : ι → Set X) (s : Set X) (p : Set X → Prop) where\n  /-- A family of sets that form a partial refinement of `u`. -/\n  toFun : ι → Set X\n  /-- The set of indexes `i` such that `i`-th set is already shrunk. -/\n  carrier : Set ι\n  /-- Each set from the partially refined family is open. -/\n  protected isOpen : ∀ i, IsOpen (toFun i)\n  /-- The partially refined family still covers the set. -/\n  subset_iUnion : s ⊆ ⋃ i, toFun i\n  /-- For each `i ∈ carrier`, the original set includes the closure of the refined set. -/\n  closure_subset : ∀ {i}, i ∈ carrier → closure (toFun i) ⊆ u i\n  /-- For each `i ∈ carrier`, the refined set satisfies `p`. -/\n  pred_of_mem {i} (hi : i ∈ carrier) : p (toFun i)\n  /-- Sets that correspond to `i ∉ carrier` are not modified. -/\n  apply_eq : ∀ {i}, i ∉ carrier → toFun i = u i\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.ext_iff","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\nx y : ShrinkingLemma.PartialRefinement u s p\n⊢ Iff (Eq x y) (And (Eq x.toFun y.toFun) (Eq x.carrier y.carrier))","decl":"/-- Auxiliary definition for the proof of the shrinking lemma. A partial refinement of a covering\n`⋃ i, u i` of a set `s` is a map `v : ι → Set X` and a set `carrier : Set ι` such that\n\n* `s ⊆ ⋃ i, v i`;\n* all `v i` are open;\n* if `i ∈ carrier v`, then `closure (v i) ⊆ u i`;\n* if `i ∉ carrier`, then `v i = u i`.\n\nThis type is equipped with the following partial order: `v ≤ v'` if `v.carrier ⊆ v'.carrier`\nand `v i = v' i` for `i ∈ v.carrier`. We will use Zorn's lemma to prove that this type has\na maximal element, then show that the maximal element must have `carrier = univ`. -/\n@[ext] structure PartialRefinement (u : ι → Set X) (s : Set X) (p : Set X → Prop) where\n  /-- A family of sets that form a partial refinement of `u`. -/\n  toFun : ι → Set X\n  /-- The set of indexes `i` such that `i`-th set is already shrunk. -/\n  carrier : Set ι\n  /-- Each set from the partially refined family is open. -/\n  protected isOpen : ∀ i, IsOpen (toFun i)\n  /-- The partially refined family still covers the set. -/\n  subset_iUnion : s ⊆ ⋃ i, toFun i\n  /-- For each `i ∈ carrier`, the original set includes the closure of the refined set. -/\n  closure_subset : ∀ {i}, i ∈ carrier → closure (toFun i) ⊆ u i\n  /-- For each `i ∈ carrier`, the refined set satisfies `p`. -/\n  pred_of_mem {i} (hi : i ∈ carrier) : p (toFun i)\n  /-- Sets that correspond to `i ∉ carrier` are not modified. -/\n  apply_eq : ∀ {i}, i ∉ carrier → toFun i = u i\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.subset","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\nv : ShrinkingLemma.PartialRefinement u s p\ni : ι\n⊢ HasSubset.Subset (v.toFun i) (u i)","decl":"protected theorem subset (v : PartialRefinement u s p) (i : ι) : v i ⊆ u i := by\n  classical\n  exact if h : i ∈ v.carrier then subset_closure.trans (v.closure_subset h) else (v.apply_eq h).le\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.apply_eq_of_chain","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\nc : Set (ShrinkingLemma.PartialRefinement u s p)\nhc : IsChain (fun x1 x2 => LE.le x1 x2) c\nv₁ v₂ : ShrinkingLemma.PartialRefinement u s p\nh₁ : Membership.mem c v₁\nh₂ : Membership.mem c v₂\ni : ι\nhi₁ : Membership.mem v₁.carrier i\nhi₂ : Membership.mem v₂.carrier i\n⊢ Eq (v₁.toFun i) (v₂.toFun i)","decl":"/-- If two partial refinements `v₁`, `v₂` belong to a chain (hence, they are comparable)\nand `i` belongs to the carriers of both partial refinements, then `v₁ i = v₂ i`. -/\ntheorem apply_eq_of_chain {c : Set (PartialRefinement u s p)} (hc : IsChain (· ≤ ·) c) {v₁ v₂}\n    (h₁ : v₁ ∈ c) (h₂ : v₂ ∈ c) {i} (hi₁ : i ∈ v₁.carrier) (hi₂ : i ∈ v₂.carrier) :\n    v₁ i = v₂ i :=\n  (hc.total h₁ h₂).elim (fun hle => hle.2 _ hi₁) (fun hle => (hle.2 _ hi₂).symm)\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.find_mem","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\nc : Set (ShrinkingLemma.PartialRefinement u s p)\ni : ι\nne : c.Nonempty\n⊢ Membership.mem c (ShrinkingLemma.PartialRefinement.find c ne i)","decl":"theorem find_mem {c : Set (PartialRefinement u s p)} (i : ι) (ne : c.Nonempty) :\n    find c ne i ∈ c := by\n  rw [find]\n  split_ifs with h\n  exacts [h.choose_spec.1, ne.some_mem]\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.mem_find_carrier_iff","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\nc : Set (ShrinkingLemma.PartialRefinement u s p)\ni : ι\nne : c.Nonempty\n⊢ Iff (Membership.mem (ShrinkingLemma.PartialRefinement.find c ne i).carrier i) (Membership.mem (ShrinkingLemma.PartialRefinement.chainSupCarrier c) i)","decl":"theorem mem_find_carrier_iff {c : Set (PartialRefinement u s p)} {i : ι} (ne : c.Nonempty) :\n    i ∈ (find c ne i).carrier ↔ i ∈ chainSupCarrier c := by\n  rw [find]\n  split_ifs with h\n  · have := h.choose_spec\n    exact iff_of_true this.2 (mem_iUnion₂.2 ⟨_, this.1, this.2⟩)\n  · push_neg at h\n    refine iff_of_false (h _ ne.some_mem) ?_\n    simpa only [chainSupCarrier, mem_iUnion₂, not_exists]\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.find_apply_of_mem","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\nc : Set (ShrinkingLemma.PartialRefinement u s p)\nhc : IsChain (fun x1 x2 => LE.le x1 x2) c\nne : c.Nonempty\ni : ι\nv : ShrinkingLemma.PartialRefinement u s p\nhv : Membership.mem c v\nhi : Membership.mem v.carrier i\n⊢ Eq ((ShrinkingLemma.PartialRefinement.find c ne i).toFun i) (v.toFun i)","decl":"theorem find_apply_of_mem {c : Set (PartialRefinement u s p)} (hc : IsChain (· ≤ ·) c)\n    (ne : c.Nonempty) {i v} (hv : v ∈ c) (hi : i ∈ carrier v) : find c ne i i = v i :=\n  apply_eq_of_chain hc (find_mem _ _) hv ((mem_find_carrier_iff _).2 <| mem_iUnion₂.2 ⟨v, hv, hi⟩)\n    hi\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.le_chainSup","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝ : TopologicalSpace X\nu : ι → Set X\ns : Set X\np : Set X → Prop\nc : Set (ShrinkingLemma.PartialRefinement u s p)\nhc : IsChain (fun x1 x2 => LE.le x1 x2) c\nne : c.Nonempty\nhfin : ∀ (x : X), Membership.mem s x → (setOf fun i => Membership.mem (u i) x).Finite\nhU : HasSubset.Subset s (Set.iUnion fun i => u i)\nv : ShrinkingLemma.PartialRefinement u s p\nhv : Membership.mem c v\n⊢ LE.le v (ShrinkingLemma.PartialRefinement.chainSup c hc ne hfin hU)","decl":"/-- `chainSup hu c hc ne hfin hU` is an upper bound of the chain `c`. -/\ntheorem le_chainSup {c : Set (PartialRefinement u s p)} (hc : IsChain (· ≤ ·) c) (ne : c.Nonempty)\n    (hfin : ∀ x ∈ s, { i | x ∈ u i }.Finite) (hU : s ⊆ ⋃ i, u i) {v} (hv : v ∈ c) :\n    v ≤ chainSup c hc ne hfin hU :=\n  ⟨fun _ hi => mem_biUnion hv hi, fun _ hi => (find_apply_of_mem hc _ hv hi).symm⟩\n\n"}
{"name":"ShrinkingLemma.PartialRefinement.exists_gt","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nu : ι → Set X\ns : Set X\ninst✝ : NormalSpace X\nv : ShrinkingLemma.PartialRefinement u s Top.top\nhs : IsClosed s\ni : ι\nhi : Not (Membership.mem v.carrier i)\n⊢ Exists fun v' => LT.lt v v'","decl":"/-- If `s` is a closed set, `v` is a partial refinement, and `i` is an index such that\n`i ∉ v.carrier`, then there exists a partial refinement that is strictly greater than `v`. -/\ntheorem exists_gt [NormalSpace X] (v : PartialRefinement u s ⊤) (hs : IsClosed s)\n    (i : ι) (hi : i ∉ v.carrier) :\n    ∃ v' : PartialRefinement u s ⊤, v < v' := by\n  have I : (s ∩ ⋂ (j) (_ : j ≠ i), (v j)ᶜ) ⊆ v i := by\n    simp only [subset_def, mem_inter_iff, mem_iInter, and_imp]\n    intro x hxs H\n    rcases mem_iUnion.1 (v.subset_iUnion hxs) with ⟨j, hj⟩\n    exact (em (j = i)).elim (fun h => h ▸ hj) fun h => (H j h hj).elim\n  have C : IsClosed (s ∩ ⋂ (j) (_ : j ≠ i), (v j)ᶜ) :=\n    IsClosed.inter hs (isClosed_biInter fun _ _ => isClosed_compl_iff.2 <| v.isOpen _)\n  rcases normal_exists_closure_subset C (v.isOpen i) I with ⟨vi, ovi, hvi, cvi⟩\n  classical\n  refine ⟨⟨update v i vi, insert i v.carrier, ?_, ?_, ?_, ?_, ?_⟩, ?_, ?_⟩\n  · intro j\n    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]\n  · refine fun x hx => mem_iUnion.2 ?_\n    rcases em (∃ j ≠ i, x ∈ v j) with (⟨j, hji, hj⟩ | h)\n    · use j\n      rwa [update_of_ne hji]\n    · push_neg at h\n      use i\n      rw [update_self]\n      exact hvi ⟨hx, mem_biInter h⟩\n  · rintro j (rfl | hj)\n    · rwa [update_self, ← v.apply_eq hi]\n    · rw [update_of_ne (ne_of_mem_of_not_mem hj hi)]\n      exact v.closure_subset hj\n  · exact fun _ => trivial\n  · intro j hj\n    rw [mem_insert_iff, not_or] at hj\n    rw [update_of_ne hj.1, v.apply_eq hj.2]\n  · refine ⟨subset_insert _ _, fun j hj => ?_⟩\n    exact (update_of_ne (ne_of_mem_of_not_mem hj hi) _ _).symm\n  · exact fun hle => hi (hle.1 <| mem_insert _ _)\n\n"}
{"name":"exists_subset_iUnion_closure_subset","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nu : ι → Set X\ns : Set X\ninst✝ : NormalSpace X\nhs : IsClosed s\nuo : ∀ (i : ι), IsOpen (u i)\nuf : ∀ (x : X), Membership.mem s x → (setOf fun i => Membership.mem (u i) x).Finite\nus : HasSubset.Subset s (Set.iUnion fun i => u i)\n⊢ Exists fun v => And (HasSubset.Subset s (Set.iUnion v)) (And (∀ (i : ι), IsOpen (v i)) (∀ (i : ι), HasSubset.Subset (closure (v i)) (u i)))","decl":"/-- **Shrinking lemma**. A point-finite open cover of a closed subset of a normal space can be\n\"shrunk\" to a new open cover so that the closure of each new open set is contained in the\ncorresponding original open set. -/\ntheorem exists_subset_iUnion_closure_subset (hs : IsClosed s) (uo : ∀ i, IsOpen (u i))\n    (uf : ∀ x ∈ s, { i | x ∈ u i }.Finite) (us : s ⊆ ⋃ i, u i) :\n    ∃ v : ι → Set X, s ⊆ iUnion v ∧ (∀ i, IsOpen (v i)) ∧ ∀ i, closure (v i) ⊆ u i := by\n  haveI : Nonempty (PartialRefinement u s ⊤) :=\n    ⟨⟨u, ∅, uo, us, False.elim, False.elim, fun _ => rfl⟩⟩\n  have : ∀ c : Set (PartialRefinement u s ⊤),\n      IsChain (· ≤ ·) c → c.Nonempty → ∃ ub, ∀ v ∈ c, v ≤ ub :=\n    fun c hc ne => ⟨.chainSup c hc ne uf us, fun v hv => PartialRefinement.le_chainSup _ _ _ _ hv⟩\n  rcases zorn_le_nonempty this with ⟨v, hv⟩\n  suffices ∀ i, i ∈ v.carrier from\n    ⟨v, v.subset_iUnion, fun i => v.isOpen _, fun i => v.closure_subset (this i)⟩\n  refine fun i ↦ by_contra fun hi ↦ ?_\n  rcases v.exists_gt hs i hi with ⟨v', hlt⟩\n  exact hv.not_lt hlt\n\n"}
{"name":"exists_subset_iUnion_closed_subset","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nu : ι → Set X\ns : Set X\ninst✝ : NormalSpace X\nhs : IsClosed s\nuo : ∀ (i : ι), IsOpen (u i)\nuf : ∀ (x : X), Membership.mem s x → (setOf fun i => Membership.mem (u i) x).Finite\nus : HasSubset.Subset s (Set.iUnion fun i => u i)\n⊢ Exists fun v => And (HasSubset.Subset s (Set.iUnion v)) (And (∀ (i : ι), IsClosed (v i)) (∀ (i : ι), HasSubset.Subset (v i) (u i)))","decl":"/-- **Shrinking lemma**. A point-finite open cover of a closed subset of a normal space can be\n\"shrunk\" to a new closed cover so that each new closed set is contained in the corresponding\noriginal open set. See also `exists_subset_iUnion_closure_subset` for a stronger statement. -/\ntheorem exists_subset_iUnion_closed_subset (hs : IsClosed s) (uo : ∀ i, IsOpen (u i))\n    (uf : ∀ x ∈ s, { i | x ∈ u i }.Finite) (us : s ⊆ ⋃ i, u i) :\n    ∃ v : ι → Set X, s ⊆ iUnion v ∧ (∀ i, IsClosed (v i)) ∧ ∀ i, v i ⊆ u i :=\n  let ⟨v, hsv, _, hv⟩ := exists_subset_iUnion_closure_subset hs uo uf us\n  ⟨fun i => closure (v i), Subset.trans hsv (iUnion_mono fun _ => subset_closure),\n    fun _ => isClosed_closure, hv⟩\n\n"}
{"name":"exists_iUnion_eq_closure_subset","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nu : ι → Set X\ninst✝ : NormalSpace X\nuo : ∀ (i : ι), IsOpen (u i)\nuf : ∀ (x : X), (setOf fun i => Membership.mem (u i) x).Finite\nuU : Eq (Set.iUnion fun i => u i) Set.univ\n⊢ Exists fun v => And (Eq (Set.iUnion v) Set.univ) (And (∀ (i : ι), IsOpen (v i)) (∀ (i : ι), HasSubset.Subset (closure (v i)) (u i)))","decl":"/-- Shrinking lemma. A point-finite open cover of a closed subset of a normal space can be \"shrunk\"\nto a new open cover so that the closure of each new open set is contained in the corresponding\noriginal open set. -/\ntheorem exists_iUnion_eq_closure_subset (uo : ∀ i, IsOpen (u i)) (uf : ∀ x, { i | x ∈ u i }.Finite)\n    (uU : ⋃ i, u i = univ) :\n    ∃ v : ι → Set X, iUnion v = univ ∧ (∀ i, IsOpen (v i)) ∧ ∀ i, closure (v i) ⊆ u i :=\n  let ⟨v, vU, hv⟩ := exists_subset_iUnion_closure_subset isClosed_univ uo (fun x _ => uf x) uU.ge\n  ⟨v, univ_subset_iff.1 vU, hv⟩\n\n"}
{"name":"exists_iUnion_eq_closed_subset","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝¹ : TopologicalSpace X\nu : ι → Set X\ninst✝ : NormalSpace X\nuo : ∀ (i : ι), IsOpen (u i)\nuf : ∀ (x : X), (setOf fun i => Membership.mem (u i) x).Finite\nuU : Eq (Set.iUnion fun i => u i) Set.univ\n⊢ Exists fun v => And (Eq (Set.iUnion v) Set.univ) (And (∀ (i : ι), IsClosed (v i)) (∀ (i : ι), HasSubset.Subset (v i) (u i)))","decl":"/-- Shrinking lemma. A point-finite open cover of a closed subset of a normal space can be \"shrunk\"\nto a new closed cover so that each of the new closed sets is contained in the corresponding\noriginal open set. See also `exists_iUnion_eq_closure_subset` for a stronger statement. -/\ntheorem exists_iUnion_eq_closed_subset (uo : ∀ i, IsOpen (u i)) (uf : ∀ x, { i | x ∈ u i }.Finite)\n    (uU : ⋃ i, u i = univ) :\n    ∃ v : ι → Set X, iUnion v = univ ∧ (∀ i, IsClosed (v i)) ∧ ∀ i, v i ⊆ u i :=\n  let ⟨v, vU, hv⟩ := exists_subset_iUnion_closed_subset isClosed_univ uo (fun x _ => uf x) uU.ge\n  ⟨v, univ_subset_iff.1 vU, hv⟩\n\n"}
{"name":"exists_gt_t2space","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\nu : ι → Set X\ns : Set X\ninst✝¹ : T2Space X\ninst✝ : LocallyCompactSpace X\nv : ShrinkingLemma.PartialRefinement u s fun w => IsCompact (closure w)\nhs : IsCompact s\ni : ι\nhi : Not (Membership.mem v.carrier i)\n⊢ Exists fun v' => And (LT.lt v v') (IsCompact (closure (v'.toFun i)))","decl":"/-- In a locally compact Hausdorff space `X`, if `s` is a compact set, `v` is a partial refinement,\nand `i` is an index such that `i ∉ v.carrier`, then there exists a partial refinement that is\nstrictly greater than `v`. -/\ntheorem exists_gt_t2space (v : PartialRefinement u s (fun w => IsCompact (closure w)))\n    (hs : IsCompact s) (i : ι) (hi : i ∉ v.carrier) :\n    ∃ v' : PartialRefinement u s (fun w => IsCompact (closure w)),\n      v < v' ∧ IsCompact (closure (v' i)) := by\n  -- take `v i` such that `closure (v i)` is compact\n  set si := s ∩ (⋃ j ≠ i, v j)ᶜ with hsi\n  simp only [ne_eq, compl_iUnion] at hsi\n  have hsic : IsCompact si := by\n    apply IsCompact.of_isClosed_subset hs _ Set.inter_subset_left\n    · have : IsOpen (⋃ j ≠ i, v j) := by\n        apply isOpen_biUnion\n        intro j _\n        exact v.isOpen j\n      exact IsClosed.inter (IsCompact.isClosed hs) (IsOpen.isClosed_compl this)\n  have : si ⊆ v i := by\n    intro x hx\n    have (j) (hj : j ≠ i) : x ∉ v j := by\n      rw [hsi] at hx\n      apply Set.not_mem_of_mem_compl\n      have hsi' : x ∈ (⋂ i_1, ⋂ (_ : ¬i_1 = i), (v.toFun i_1)ᶜ) := Set.mem_of_mem_inter_right hx\n      rw [ne_eq] at hj\n      rw [Set.mem_iInter₂] at hsi'\n      exact hsi' j hj\n    obtain ⟨j, hj⟩ := Set.mem_iUnion.mp\n      (v.subset_iUnion (Set.mem_of_mem_inter_left hx))\n    obtain rfl : j = i := by\n      by_contra! h\n      exact this j h hj\n    exact hj\n  obtain ⟨vi, hvi⟩ := exists_open_between_and_isCompact_closure hsic (v.isOpen i) this\n  classical\n  refine ⟨⟨update v i vi, insert i v.carrier, ?_, ?_, ?_, ?_, ?_⟩, ⟨?_, ?_⟩, ?_⟩\n  · intro j\n    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]\n  · refine fun x hx => mem_iUnion.2 ?_\n    rcases em (∃ j ≠ i, x ∈ v j) with (⟨j, hji, hj⟩ | h)\n    · use j\n      rwa [update_of_ne hji]\n    · push_neg at h\n      use i\n      rw [update_self]\n      apply hvi.2.1\n      rw [hsi]\n      exact ⟨hx, mem_iInter₂_of_mem h⟩\n  · rintro j (rfl | hj)\n    · rw [update_self]\n      exact subset_trans hvi.2.2.1 <| PartialRefinement.subset v j\n    · rw [update_of_ne (ne_of_mem_of_not_mem hj hi)]\n      exact v.closure_subset hj\n  · intro j hj\n    rw [mem_insert_iff] at hj\n    by_cases h : j = i\n    · rw [← h]\n      simp only [update_self]\n      exact hvi.2.2.2\n    · apply hj.elim\n      · intro hji\n        exact False.elim (h hji)\n      · intro hjmemv\n        rw [update_of_ne h]\n        exact v.pred_of_mem hjmemv\n  · intro j hj\n    rw [mem_insert_iff, not_or] at hj\n    rw [update_of_ne hj.1, v.apply_eq hj.2]\n  · refine ⟨subset_insert _ _, fun j hj => ?_⟩\n    exact (update_of_ne (ne_of_mem_of_not_mem hj hi) _ _).symm\n  · exact fun hle => hi (hle.1 <| mem_insert _ _)\n  · simp only [update_self]\n    exact hvi.2.2.2\n\n"}
{"name":"exists_subset_iUnion_closure_subset_t2space","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\nu : ι → Set X\ns : Set X\ninst✝¹ : T2Space X\ninst✝ : LocallyCompactSpace X\nhs : IsCompact s\nuo : ∀ (i : ι), IsOpen (u i)\nuf : ∀ (x : X), Membership.mem s x → (setOf fun i => Membership.mem (u i) x).Finite\nus : HasSubset.Subset s (Set.iUnion fun i => u i)\n⊢ Exists fun v => And (HasSubset.Subset s (Set.iUnion v)) (And (∀ (i : ι), IsOpen (v i)) (And (∀ (i : ι), HasSubset.Subset (closure (v i)) (u i)) (∀ (i : ι), IsCompact (closure (v i)))))","decl":"/-- **Shrinking lemma** . A point-finite open cover of a compact subset of a `T2Space`\n`LocallyCompactSpace` can be \"shrunk\" to a new open cover so that the closure of each new open set\nis contained in the corresponding original open set. -/\ntheorem exists_subset_iUnion_closure_subset_t2space (hs : IsCompact s) (uo : ∀ i, IsOpen (u i))\n    (uf : ∀ x ∈ s, { i | x ∈ u i }.Finite) (us : s ⊆ ⋃ i, u i) :\n    ∃ v : ι → Set X, s ⊆ iUnion v ∧ (∀ i, IsOpen (v i)) ∧ (∀ i, closure (v i) ⊆ u i)\n      ∧ (∀ i, IsCompact (closure (v i))) := by\n  haveI : Nonempty (PartialRefinement u s (fun w => IsCompact (closure w))) :=\n    ⟨⟨u, ∅, uo, us, False.elim, False.elim, fun _ => rfl⟩⟩\n  have : ∀ c : Set (PartialRefinement u s (fun w => IsCompact (closure w))),\n      IsChain (· ≤ ·) c → c.Nonempty → ∃ ub, ∀ v ∈ c, v ≤ ub :=\n    fun c hc ne => ⟨.chainSup c hc ne uf us, fun v hv => PartialRefinement.le_chainSup _ _ _ _ hv⟩\n  rcases zorn_le_nonempty this with ⟨v, hv⟩\n  suffices ∀ i, i ∈ v.carrier from\n    ⟨v, v.subset_iUnion, fun i => v.isOpen _, fun i => v.closure_subset (this i), ?_⟩\n  · intro i\n    exact v.pred_of_mem (this i)\n  · intro i\n    by_contra! hi\n    rcases exists_gt_t2space v hs i hi with ⟨v', hlt, _⟩\n    exact hv.not_lt hlt\n\n"}
{"name":"exists_subset_iUnion_compact_subset_t2space","module":"Mathlib.Topology.ShrinkingLemma","initialProofState":"ι : Type u_1\nX : Type u_2\ninst✝² : TopologicalSpace X\nu : ι → Set X\ns : Set X\ninst✝¹ : T2Space X\ninst✝ : LocallyCompactSpace X\nhs : IsCompact s\nuo : ∀ (i : ι), IsOpen (u i)\nuf : ∀ (x : X), Membership.mem s x → (setOf fun i => Membership.mem (u i) x).Finite\nus : HasSubset.Subset s (Set.iUnion fun i => u i)\n⊢ Exists fun v => And (HasSubset.Subset s (Set.iUnion v)) (And (∀ (i : ι), IsClosed (v i)) (And (∀ (i : ι), HasSubset.Subset (v i) (u i)) (∀ (i : ι), IsCompact (v i))))","decl":"/-- **Shrinking lemma**. A point-finite open cover of a compact subset of a locally compact T2 space\ncan be \"shrunk\" to a new closed cover so that each new closed set is contained in the corresponding\noriginal open set. See also `exists_subset_iUnion_closure_subset_t2space` for a stronger statement.\n-/\ntheorem exists_subset_iUnion_compact_subset_t2space (hs : IsCompact s) (uo : ∀ i, IsOpen (u i))\n    (uf : ∀ x ∈ s, { i | x ∈ u i }.Finite) (us : s ⊆ ⋃ i, u i) :\n    ∃ v : ι → Set X, s ⊆ iUnion v ∧ (∀ i, IsClosed (v i)) ∧ (∀ i, v i ⊆ u i)\n      ∧ ∀ i, IsCompact (v i) := by\n  let ⟨v, hsv, _, hv⟩ := exists_subset_iUnion_closure_subset_t2space hs uo uf us\n  use fun i => closure (v i)\n  refine ⟨?_, ?_, ?_⟩\n  · exact Subset.trans hsv (iUnion_mono fun _ => subset_closure)\n  · simp only [isClosed_closure, implies_true]\n  · simp only\n    exact And.intro (fun i => hv.1 i) (fun i => hv.2 i)\n\n"}
