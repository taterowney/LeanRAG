{"name":"Algebra.FinitePresentation.out","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\nA : Type w₂\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nself : Algebra.FinitePresentation R A\n⊢ Exists fun n => Exists fun f => And (Function.Surjective ⇑f) (RingHom.ker f.toRingHom).FG","decl":"/-- An algebra over a commutative semiring is `Algebra.FinitePresentation` if it is the quotient of\na polynomial ring in `n` variables by a finitely generated ideal. -/\nclass Algebra.FinitePresentation [CommSemiring R] [Semiring A] [Algebra R A] : Prop where\n  out : ∃ (n : ℕ) (f : MvPolynomial (Fin n) R →ₐ[R] A), Surjective f ∧ f.toRingHom.ker.FG\n\n"}
{"name":"Algebra.FiniteType.of_finitePresentation","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\nA : Type w₂\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Algebra.FinitePresentation R A\n⊢ Algebra.FiniteType R A","decl":"/-- A finitely presented algebra is of finite type. -/\ninstance of_finitePresentation [FinitePresentation R A] : FiniteType R A := by\n  obtain ⟨n, f, hf⟩ := FinitePresentation.out (R := R) (A := A)\n  apply FiniteType.iff_quotient_mvPolynomial''.2\n  exact ⟨n, f, hf.1⟩\n\n"}
{"name":"Algebra.FinitePresentation.of_finiteType","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\nA : Type w₂\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : IsNoetherianRing R\n⊢ Iff (Algebra.FiniteType R A) (Algebra.FinitePresentation R A)","decl":"/-- An algebra over a Noetherian ring is finitely generated if and only if it is finitely\npresented. -/\ntheorem of_finiteType [IsNoetherianRing R] : FiniteType R A ↔ FinitePresentation R A := by\n  refine ⟨fun h => ?_, fun hfp => Algebra.FiniteType.of_finitePresentation⟩\n  obtain ⟨n, f, hf⟩ := Algebra.FiniteType.iff_quotient_mvPolynomial''.1 h\n  refine ⟨n, f, hf, ?_⟩\n  have hnoet : IsNoetherianRing (MvPolynomial (Fin n) R) := by infer_instance\n  -- Porting note: rewrote code to help typeclass inference\n  rw [isNoetherianRing_iff] at hnoet\n  letI : Module (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R) := Semiring.toModule\n  convert hnoet.noetherian (RingHom.ker f.toRingHom)\n\n"}
{"name":"Algebra.FinitePresentation.equiv","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\nA : Type w₂\nB : Type w₃\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\ninst✝ : Algebra.FinitePresentation R A\ne : AlgEquiv R A B\n⊢ Algebra.FinitePresentation R B","decl":"/-- If `e : A ≃ₐ[R] B` and `A` is finitely presented, then so is `B`. -/\ntheorem equiv [FinitePresentation R A] (e : A ≃ₐ[R] B) : FinitePresentation R B := by\n  obtain ⟨n, f, hf⟩ := FinitePresentation.out (R := R) (A := A)\n  use n, AlgHom.comp (↑e) f\n  constructor\n  · rw [AlgHom.coe_comp]\n    exact Function.Surjective.comp e.surjective hf.1\n  suffices (RingHom.ker (AlgHom.comp (e : A →ₐ[R] B) f).toRingHom) = RingHom.ker f.toRingHom by\n    rw [this]\n    exact hf.2\n  have hco : (AlgHom.comp (e : A →ₐ[R] B) f).toRingHom = RingHom.comp (e.toRingEquiv : A ≃+* B)\n    f.toRingHom := by\n    have h : (AlgHom.comp (e : A →ₐ[R] B) f).toRingHom =\n      e.toAlgHom.toRingHom.comp f.toRingHom := rfl\n    have h1 : ↑e.toRingEquiv = e.toAlgHom.toRingHom := rfl\n    rw [h, h1]\n  rw [RingHom.ker_eq_comap_bot, hco, ← Ideal.comap_comap, ← RingHom.ker_eq_comap_bot,\n    RingHom.ker_coe_equiv (AlgEquiv.toRingEquiv e), RingHom.ker_eq_comap_bot]\n\n"}
{"name":"Algebra.FinitePresentation.mvPolynomial","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\ninst✝¹ : CommRing R\nι : Type u_1\ninst✝ : Finite ι\n⊢ Algebra.FinitePresentation R (MvPolynomial ι R)","decl":"/-- The ring of polynomials in finitely many variables is finitely presented. -/\nprotected instance mvPolynomial (ι : Type*) [Finite ι] :\n    FinitePresentation R (MvPolynomial ι R) where\n  out := by\n    cases nonempty_fintype ι\n    let eqv := (MvPolynomial.renameEquiv R <| Fintype.equivFin ι).symm\n    exact\n      ⟨Fintype.card ι, eqv, eqv.surjective,\n        ((RingHom.injective_iff_ker_eq_bot _).1 eqv.injective).symm ▸ Submodule.fg_bot⟩\n\n"}
{"name":"Algebra.FinitePresentation.self","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\ninst✝ : CommRing R\n⊢ Algebra.FinitePresentation R R","decl":"/-- `R` is finitely presented as `R`-algebra. -/\ninstance self : FinitePresentation R R :=\n  -- Porting note: replaced `PEmpty` with `Empty`\n  equiv (MvPolynomial.isEmptyAlgEquiv R Empty)\n\n"}
{"name":"Algebra.FinitePresentation.polynomial","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\ninst✝ : CommRing R\n⊢ Algebra.FinitePresentation R (Polynomial R)","decl":"/-- `R[X]` is finitely presented as `R`-algebra. -/\ninstance polynomial : FinitePresentation R R[X] :=\n  -- Porting note: replaced `PUnit` with `Unit`\n  letI := FinitePresentation.mvPolynomial R Unit\n  equiv (MvPolynomial.pUnitAlgEquiv R)\n\n"}
{"name":"Algebra.FinitePresentation.quotient","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\nA : Type w₂\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nI : Ideal A\nh : I.FG\ninst✝ : Algebra.FinitePresentation R A\n⊢ Algebra.FinitePresentation R (HasQuotient.Quotient A I)","decl":"/-- The quotient of a finitely presented algebra by a finitely generated ideal is finitely\npresented. -/\nprotected theorem quotient {I : Ideal A} (h : I.FG) [FinitePresentation R A] :\n    FinitePresentation R (A ⧸ I) where\n  out := by\n    obtain ⟨n, f, hf⟩ := FinitePresentation.out (R := R) (A := A)\n    refine ⟨n, (Ideal.Quotient.mkₐ R I).comp f, ?_, ?_⟩\n    · exact (Ideal.Quotient.mkₐ_surjective R I).comp hf.1\n    · refine Ideal.fg_ker_comp _ _ hf.2 ?_ hf.1\n      simp [h]\n\n"}
{"name":"Algebra.FinitePresentation.of_surjective","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\nA : Type w₂\nB : Type w₃\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\nf : AlgHom R A B\nhf : Function.Surjective ⇑f\nhker : (RingHom.ker f.toRingHom).FG\ninst✝ : Algebra.FinitePresentation R A\n⊢ Algebra.FinitePresentation R B","decl":"/-- If `f : A →ₐ[R] B` is surjective with finitely generated kernel and `A` is finitely presented,\nthen so is `B`. -/\ntheorem of_surjective {f : A →ₐ[R] B} (hf : Function.Surjective f) (hker : f.toRingHom.ker.FG)\n    [FinitePresentation R A] : FinitePresentation R B :=\n  letI : FinitePresentation R (A ⧸ RingHom.ker f) := FinitePresentation.quotient hker\n  equiv (Ideal.quotientKerAlgEquivOfSurjective hf)\n\n"}
{"name":"Algebra.FinitePresentation.iff","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\nA : Type w₂\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Iff (Algebra.FinitePresentation R A) (Exists fun n => Exists fun I => Exists fun x => I.FG)","decl":"theorem iff :\n    FinitePresentation R A ↔\n      ∃ (n : _) (I : Ideal (MvPolynomial (Fin n) R)) (_ : (_ ⧸ I) ≃ₐ[R] A), I.FG := by\n  constructor\n  · rintro ⟨n, f, hf⟩\n    exact ⟨n, RingHom.ker f.toRingHom, Ideal.quotientKerAlgEquivOfSurjective hf.1, hf.2⟩\n  · rintro ⟨n, I, e, hfg⟩\n    letI := (FinitePresentation.mvPolynomial R _).quotient hfg\n    exact equiv e\n\n"}
{"name":"Algebra.FinitePresentation.iff_quotient_mvPolynomial'","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\nA : Type w₂\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Iff (Algebra.FinitePresentation R A) (Exists fun ι => Exists fun x => Exists fun f => And (Function.Surjective ⇑f) (RingHom.ker f.toRingHom).FG)","decl":"/-- An algebra is finitely presented if and only if it is a quotient of a polynomial ring whose\nvariables are indexed by a fintype by a finitely generated ideal. -/\ntheorem iff_quotient_mvPolynomial' :\n    FinitePresentation R A ↔\n      ∃ (ι : Type*) (_ : Fintype ι) (f : MvPolynomial ι R →ₐ[R] A),\n        Surjective f ∧ f.toRingHom.ker.FG := by\n  constructor\n  · rintro ⟨n, f, hfs, hfk⟩\n    set ulift_var := MvPolynomial.renameEquiv R Equiv.ulift\n    refine\n      ⟨ULift (Fin n), inferInstance, f.comp ulift_var.toAlgHom, hfs.comp ulift_var.surjective,\n        Ideal.fg_ker_comp _ _ ?_ hfk ulift_var.surjective⟩\n    erw [RingHom.ker_coe_equiv ulift_var.toRingEquiv]\n    exact Submodule.fg_bot\n    -- Porting note: was\n    -- convert Submodule.fg_bot\n    -- exact RingHom.ker_coe_equiv ulift_var.toRingEquiv\n  · rintro ⟨ι, hfintype, f, hf⟩\n    have equiv := MvPolynomial.renameEquiv R (Fintype.equivFin ι)\n    use Fintype.card ι, f.comp equiv.symm, hf.1.comp (AlgEquiv.symm equiv).surjective\n    refine Ideal.fg_ker_comp (S := MvPolynomial ι R) (A := A) _ f ?_ hf.2 equiv.symm.surjective\n    erw [RingHom.ker_coe_equiv equiv.symm.toRingEquiv]\n    exact Submodule.fg_bot\n    -- Porting note: was\n    -- convert Submodule.fg_bot\n    -- exact RingHom.ker_coe_equiv equiv.symm.toRingEquiv\n\n"}
{"name":"Algebra.FinitePresentation.mvPolynomial_of_finitePresentation","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\nA : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : Algebra R A\ninst✝¹ : Algebra.FinitePresentation R A\nι : Type v\ninst✝ : Finite ι\n⊢ Algebra.FinitePresentation R (MvPolynomial ι A)","decl":"universe v in\n-- Porting note: make universe level explicit to ensure `ι, ι'` has the same universe level\n/-- If `A` is a finitely presented `R`-algebra, then `MvPolynomial (Fin n) A` is finitely presented\nas `R`-algebra. -/\ntheorem mvPolynomial_of_finitePresentation [FinitePresentation.{w₁, w₂} R A]\n    (ι : Type v) [Finite ι] :\n    FinitePresentation.{w₁, max v w₂} R (MvPolynomial ι A) := by\n  have hfp : FinitePresentation.{w₁, w₂} R A := inferInstance\n  rw [iff_quotient_mvPolynomial'] at hfp ⊢\n  classical\n  -- Porting note: use the same universe level\n  obtain ⟨(ι' : Type v), _, f, hf_surj, hf_ker⟩ := hfp\n  let g := (MvPolynomial.mapAlgHom f).comp (MvPolynomial.sumAlgEquiv R ι ι').toAlgHom\n  cases nonempty_fintype (ι ⊕ ι')\n  refine\n    ⟨ι ⊕ ι', by infer_instance, g,\n      (MvPolynomial.map_surjective f.toRingHom hf_surj).comp (AlgEquiv.surjective _),\n      Ideal.fg_ker_comp _ _ ?_ ?_ (AlgEquiv.surjective _)⟩\n  · erw [RingHom.ker_coe_equiv (MvPolynomial.sumAlgEquiv R ι ι').toRingEquiv]\n    exact Submodule.fg_bot\n    -- Porting note: was\n    -- convert Submodule.fg_bot\n    -- exact RingHom.ker_coe_equiv (MvPolynomial.sumAlgEquiv R ι ι').toRingEquiv\n  · rw [AlgHom.toRingHom_eq_coe, MvPolynomial.mapAlgHom_coe_ringHom, MvPolynomial.ker_map]\n    exact hf_ker.map MvPolynomial.C\n\n"}
{"name":"Algebra.FinitePresentation.trans","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\nA : Type w₂\nB : Type w₃\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : IsScalarTower R A B\ninst✝¹ : Algebra.FinitePresentation R A\ninst✝ : Algebra.FinitePresentation A B\n⊢ Algebra.FinitePresentation R B","decl":"/-- If `A` is an `R`-algebra and `S` is an `A`-algebra, both finitely presented, then `S` is\n  finitely presented as `R`-algebra. -/\ntheorem trans [Algebra A B] [IsScalarTower R A B] [FinitePresentation R A]\n    [FinitePresentation A B] : FinitePresentation R B := by\n  have hfpB : FinitePresentation A B := inferInstance\n  obtain ⟨n, I, e, hfg⟩ := iff.1 hfpB\n  letI : FinitePresentation R (MvPolynomial (Fin n) A ⧸ I) :=\n    (mvPolynomial_of_finitePresentation _).quotient hfg\n  exact equiv (e.restrictScalars R)\n\n"}
{"name":"Algebra.FinitePresentation.of_restrict_scalars_finitePresentation","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\nA : Type w₂\nB : Type w₃\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : IsScalarTower R A B\ninst✝¹ : Algebra.FinitePresentation R B\ninst✝ : Algebra.FiniteType R A\n⊢ Algebra.FinitePresentation A B","decl":"@[stacks 0561]\ntheorem of_restrict_scalars_finitePresentation [Algebra A B] [IsScalarTower R A B]\n    [FinitePresentation.{w₁, w₃} R B] [FiniteType R A] :\n    FinitePresentation.{w₂, w₃} A B := by\n  classical\n  obtain ⟨n, f, hf, s, hs⟩ := FinitePresentation.out (R := R) (A := B)\n  letI RX := MvPolynomial (Fin n) R\n  letI AX := MvPolynomial (Fin n) A\n  refine ⟨n, MvPolynomial.aeval (f ∘ X), ?_, ?_⟩\n  · rw [← AlgHom.range_eq_top, ← Algebra.adjoin_range_eq_range_aeval,\n      Set.range_comp f MvPolynomial.X, eq_top_iff, ← @adjoin_adjoin_of_tower R A B,\n      adjoin_image, adjoin_range_X, Algebra.map_top, (AlgHom.range_eq_top _).mpr hf]\n    exact fun {x} => subset_adjoin ⟨⟩\n  · obtain ⟨t, ht⟩ := FiniteType.out (R := R) (A := A)\n    have := fun i : t => hf (algebraMap A B i)\n    choose t' ht' using this\n    have ht'' : Algebra.adjoin R (algebraMap A AX '' t ∪ Set.range (X : _ → AX)) = ⊤ := by\n      rw [adjoin_union_eq_adjoin_adjoin, ← Subalgebra.restrictScalars_top R (A := AX)\n        (S := { x // x ∈ adjoin R ((algebraMap A AX) '' t) })]\n      refine congrArg (Subalgebra.restrictScalars R) ?_\n      rw [adjoin_algebraMap, ht]\n      apply Subalgebra.restrictScalars_injective R\n      rw [← adjoin_restrictScalars, adjoin_range_X, Subalgebra.restrictScalars_top,\n        Subalgebra.restrictScalars_top]\n    letI g : t → AX := fun x => MvPolynomial.C (x : A) - map (algebraMap R A) (t' x)\n    refine ⟨s.image (map (algebraMap R A)) ∪ t.attach.image g, ?_⟩\n    rw [Finset.coe_union, Finset.coe_image, Finset.coe_image, Finset.attach_eq_univ,\n      Finset.coe_univ, Set.image_univ]\n    let s₀ := (MvPolynomial.map (algebraMap R A)) '' s ∪ Set.range g\n    let I := RingHom.ker (MvPolynomial.aeval (R := A) (f ∘ MvPolynomial.X))\n    change Ideal.span s₀ = I\n    have leI : Ideal.span ((MvPolynomial.map (algebraMap R A)) '' s ∪ Set.range g) ≤\n      RingHom.ker (MvPolynomial.aeval (R := A) (f ∘ MvPolynomial.X)) := by\n      rw [Ideal.span_le]\n      rintro _ (⟨x, hx, rfl⟩ | ⟨⟨x, hx⟩, rfl⟩) <;>\n      erw [RingHom.mem_ker]\n      · rw [MvPolynomial.aeval_map_algebraMap (R := R) (A := A), ← aeval_unique]\n        have := Ideal.subset_span hx\n        rwa [hs] at this\n      · rw [map_sub, MvPolynomial.aeval_map_algebraMap, ← aeval_unique,\n          MvPolynomial.aeval_C, ht', Subtype.coe_mk, sub_self]\n    apply leI.antisymm\n    intro x hx\n    rw [RingHom.mem_ker] at hx\n    let s₀ := (MvPolynomial.map (algebraMap R A)) '' ↑s ∪ Set.range g\n    change x ∈ Ideal.span s₀\n    have : x ∈ (MvPolynomial.map (algebraMap R A) : _ →+* AX).range.toAddSubmonoid ⊔\n      (Ideal.span s₀).toAddSubmonoid := by\n      have : x ∈ (⊤ : Subalgebra R AX) := trivial\n      rw [← ht''] at this\n      refine adjoin_induction ?_ ?_ ?_ ?_ this\n      · rintro _ (⟨x, hx, rfl⟩ | ⟨i, rfl⟩)\n        · rw [MvPolynomial.algebraMap_eq, ← sub_add_cancel (MvPolynomial.C x)\n            (map (algebraMap R A) (t' ⟨x, hx⟩)), add_comm]\n          apply AddSubmonoid.add_mem_sup\n          · exact Set.mem_range_self _\n          · apply Ideal.subset_span\n            apply Set.mem_union_right\n            exact Set.mem_range_self _\n        · apply AddSubmonoid.mem_sup_left\n          exact ⟨X i, map_X _ _⟩\n      · intro r\n        apply AddSubmonoid.mem_sup_left\n        exact ⟨C r, map_C _ _⟩\n      · intro _ _ _ _ h₁ h₂\n        exact add_mem h₁ h₂\n      · intro x₁ x₂ _ _ h₁ h₂\n        obtain ⟨_, ⟨p₁, rfl⟩, q₁, hq₁, rfl⟩ := AddSubmonoid.mem_sup.mp h₁\n        obtain ⟨_, ⟨p₂, rfl⟩, q₂, hq₂, rfl⟩ := AddSubmonoid.mem_sup.mp h₂\n        rw [add_mul, mul_add, add_assoc, ← map_mul]\n        apply AddSubmonoid.add_mem_sup\n        · exact Set.mem_range_self _\n        · refine add_mem (Ideal.mul_mem_left _ _ hq₂) (Ideal.mul_mem_right _ _ hq₁)\n    obtain ⟨_, ⟨p, rfl⟩, q, hq, rfl⟩ := AddSubmonoid.mem_sup.mp this\n    rw [map_add, aeval_map_algebraMap, ← aeval_unique, show MvPolynomial.aeval (f ∘ X) q = 0\n      from leI hq, add_zero] at hx\n    suffices Ideal.span (s : Set RX) ≤ (Ideal.span s₀).comap (MvPolynomial.map <| algebraMap R A) by\n      refine add_mem ?_ hq\n      rw [hs] at this\n      exact this hx\n    rw [Ideal.span_le]\n    intro x hx\n    apply Ideal.subset_span\n    apply Set.mem_union_left\n    exact Set.mem_image_of_mem _ hx\n\n"}
{"name":"Algebra.FinitePresentation.ker_fg_of_mvPolynomial","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\nA : Type w₂\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nn : Nat\nf : AlgHom R (MvPolynomial (Fin n) R) A\nhf : Function.Surjective ⇑f\ninst✝ : Algebra.FinitePresentation R A\n⊢ (RingHom.ker f.toRingHom).FG","decl":"/-- This is used to prove the strictly stronger `ker_fg_of_surjective`. Use it instead. -/\ntheorem ker_fg_of_mvPolynomial {n : ℕ} (f : MvPolynomial (Fin n) R →ₐ[R] A)\n    (hf : Function.Surjective f) [FinitePresentation R A] : f.toRingHom.ker.FG := by\n  classical\n    obtain ⟨m, f', hf', s, hs⟩ := FinitePresentation.out (R := R) (A := A)\n    let RXn := MvPolynomial (Fin n) R\n    let RXm := MvPolynomial (Fin m) R\n    have := fun i : Fin n => hf' (f <| X i)\n    choose g hg using this\n    have := fun i : Fin m => hf (f' <| X i)\n    choose h hh using this\n    let aeval_h : RXm →ₐ[R] RXn := aeval h\n    let g' : Fin n → RXn := fun i => X i - aeval_h (g i)\n    refine ⟨Finset.univ.image g' ∪ s.image aeval_h, ?_⟩\n    simp only [Finset.coe_image, Finset.coe_union, Finset.coe_univ, Set.image_univ]\n    have hh' : ∀ x, f (aeval_h x) = f' x := by\n      intro x\n      rw [← f.coe_toRingHom, map_aeval]\n      simp_rw [AlgHom.coe_toRingHom, hh]\n      rw [AlgHom.comp_algebraMap, ← aeval_eq_eval₂Hom,\n        -- Porting note: added line below\n        ← funext fun i => Function.comp_apply (f := ↑f') (g := MvPolynomial.X),\n        ← aeval_unique]\n    let s' := Set.range g' ∪ aeval_h '' s\n    have leI : Ideal.span s' ≤ RingHom.ker f.toRingHom := by\n      rw [Ideal.span_le]\n      rintro _ (⟨i, rfl⟩ | ⟨x, hx, rfl⟩)\n      · change f (g' i) = 0\n        rw [map_sub, ← hg, hh', sub_self]\n      · change f (aeval_h x) = 0\n        rw [hh']\n        change x ∈ RingHom.ker f'.toRingHom\n        rw [← hs]\n        exact Ideal.subset_span hx\n    apply leI.antisymm\n    intro x hx\n    have : x ∈ aeval_h.range.toAddSubmonoid ⊔ (Ideal.span s').toAddSubmonoid := by\n      have : x ∈ adjoin R (Set.range X : Set RXn) := by\n        rw [adjoin_range_X]\n        trivial\n      refine adjoin_induction ?_ ?_ ?_ ?_ this\n      · rintro _ ⟨i, rfl⟩\n        rw [← sub_add_cancel (X i) (aeval h (g i)), add_comm]\n        apply AddSubmonoid.add_mem_sup\n        · exact Set.mem_range_self _\n        · apply Submodule.subset_span\n          apply Set.mem_union_left\n          exact Set.mem_range_self _\n      · intro r\n        apply AddSubmonoid.mem_sup_left\n        exact ⟨C r, aeval_C _ _⟩\n      · intro _ _ _ _ h₁ h₂\n        exact add_mem h₁ h₂\n      · intro p₁ p₂ _ _ h₁ h₂\n        obtain ⟨_, ⟨x₁, rfl⟩, y₁, hy₁, rfl⟩ := AddSubmonoid.mem_sup.mp h₁\n        obtain ⟨_, ⟨x₂, rfl⟩, y₂, hy₂, rfl⟩ := AddSubmonoid.mem_sup.mp h₂\n        rw [mul_add, add_mul, add_assoc, ← map_mul]\n        apply AddSubmonoid.add_mem_sup\n        · exact Set.mem_range_self _\n        · exact add_mem (Ideal.mul_mem_right _ _ hy₁) (Ideal.mul_mem_left _ _ hy₂)\n    obtain ⟨_, ⟨x, rfl⟩, y, hy, rfl⟩ := AddSubmonoid.mem_sup.mp this\n    refine add_mem ?_ hy\n    simp only [RXn, RingHom.mem_ker, AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom, map_add,\n      show f y = 0 from leI hy, add_zero, hh'] at hx\n    suffices Ideal.span (s : Set RXm) ≤ (Ideal.span s').comap aeval_h by\n      apply this\n      rwa [hs]\n    rw [Ideal.span_le]\n    intro x hx\n    apply Submodule.subset_span\n    apply Set.mem_union_right\n    exact Set.mem_image_of_mem _ hx\n\n"}
{"name":"Algebra.FinitePresentation.ker_fG_of_surjective","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type w₁\nA : Type w₂\nB : Type w₃\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : Algebra R A\ninst✝³ : CommRing B\ninst✝² : Algebra R B\nf : AlgHom R A B\nhf : Function.Surjective ⇑f\ninst✝¹ : Algebra.FinitePresentation R A\ninst✝ : Algebra.FinitePresentation R B\n⊢ (RingHom.ker f.toRingHom).FG","decl":"/-- If `f : A →ₐ[R] B` is a surjection between finitely-presented `R`-algebras, then the kernel of\n`f` is finitely generated. -/\ntheorem ker_fG_of_surjective (f : A →ₐ[R] B) (hf : Function.Surjective f)\n    [FinitePresentation R A] [FinitePresentation R B] : f.toRingHom.ker.FG := by\n  obtain ⟨n, g, hg, _⟩ := FinitePresentation.out (R := R) (A := A)\n  convert (ker_fg_of_mvPolynomial (f.comp g) (hf.comp hg)).map g.toRingHom\n  simp_rw [RingHom.ker_eq_comap_bot, AlgHom.toRingHom_eq_coe, AlgHom.comp_toRingHom]\n  rw [← Ideal.comap_comap, Ideal.map_comap_of_surjective (g : MvPolynomial (Fin n) R →+* A) hg]\n\n"}
{"name":"RingHom.FiniteType.of_finitePresentation","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommRing A\ninst✝ : CommRing B\nf : RingHom A B\nhf : f.FinitePresentation\n⊢ f.FiniteType","decl":"theorem of_finitePresentation {f : A →+* B} (hf : f.FinitePresentation) : f.FiniteType :=\n  @Algebra.FiniteType.of_finitePresentation A B _ _ f.toAlgebra hf\n\n"}
{"name":"RingHom.FinitePresentation.id","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"A : Type u_1\ninst✝ : CommRing A\n⊢ (RingHom.id A).FinitePresentation","decl":"theorem id : FinitePresentation (RingHom.id A) :=\n  Algebra.FinitePresentation.self A\n\n"}
{"name":"RingHom.FinitePresentation.comp_surjective","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : CommRing C\nf : RingHom A B\ng : RingHom B C\nhf : f.FinitePresentation\nhg : Function.Surjective ⇑g\nhker : (RingHom.ker g).FG\n⊢ (g.comp f).FinitePresentation","decl":"theorem comp_surjective {f : A →+* B} {g : B →+* C} (hf : f.FinitePresentation) (hg : Surjective g)\n    (hker : g.ker.FG) : (g.comp f).FinitePresentation := by\n  algebraize [f, g.comp f]\n  exact Algebra.FinitePresentation.of_surjective\n    (f :=\n      { g with\n        toFun := g\n        commutes' := fun _ => rfl })\n    hg hker\n\n"}
{"name":"RingHom.FinitePresentation.of_surjective","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommRing A\ninst✝ : CommRing B\nf : RingHom A B\nhf : Function.Surjective ⇑f\nhker : (RingHom.ker f).FG\n⊢ f.FinitePresentation","decl":"theorem of_surjective (f : A →+* B) (hf : Surjective f) (hker : f.ker.FG) :\n    f.FinitePresentation := by\n  rw [← f.comp_id]\n  exact (id A).comp_surjective hf hker\n\n"}
{"name":"RingHom.FinitePresentation.of_finiteType","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : IsNoetherianRing A\nf : RingHom A B\n⊢ Iff f.FiniteType f.FinitePresentation","decl":"theorem of_finiteType [IsNoetherianRing A] {f : A →+* B} : f.FiniteType ↔ f.FinitePresentation :=\n  @Algebra.FinitePresentation.of_finiteType A B _ _ f.toAlgebra _\n\n"}
{"name":"RingHom.FinitePresentation.comp","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : CommRing C\ng : RingHom B C\nf : RingHom A B\nhg : g.FinitePresentation\nhf : f.FinitePresentation\n⊢ (g.comp f).FinitePresentation","decl":"theorem comp {g : B →+* C} {f : A →+* B} (hg : g.FinitePresentation) (hf : f.FinitePresentation) :\n    (g.comp f).FinitePresentation := by\n  -- Porting note: specify `Algebra` instances to get `SMul`\n  algebraize [f, g, g.comp f]\n  exact Algebra.FinitePresentation.trans A B C\n\n"}
{"name":"RingHom.FinitePresentation.of_comp_finiteType","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : CommRing C\nf : RingHom A B\ng : RingHom B C\nhg : (g.comp f).FinitePresentation\nhf : f.FiniteType\n⊢ g.FinitePresentation","decl":"theorem of_comp_finiteType (f : A →+* B) {g : B →+* C} (hg : (g.comp f).FinitePresentation)\n    (hf : f.FiniteType) : g.FinitePresentation := by\n  -- Porting note: need to specify some instances\n  algebraize [f, g, g.comp f]\n  exact Algebra.FinitePresentation.of_restrict_scalars_finitePresentation A B C\n\n"}
{"name":"RingHom.FinitePresentation.polynomial_induction","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"P : (R : Type u) → [inst : CommRing R] → (S : Type u) → [inst_1 : CommRing S] → RingHom R S → Prop\nQ : (R : Type u) → [inst : CommRing R] → (S : Type v) → [inst_1 : CommRing S] → RingHom R S → Prop\npolynomial : ∀ (R : Type u) [inst : CommRing R], P R (Polynomial R) Polynomial.C\nfg_ker : ∀ (R : Type u) [inst : CommRing R] (S : Type v) [inst_1 : CommRing S] (f : RingHom R S), Function.Surjective ⇑f → (RingHom.ker f).FG → Q R S f\ncomp : ∀ (R : Type u) [inst : CommRing R] (S : Type u) [inst_1 : CommRing S] (T : Type v) [inst_2 : CommRing T] (f : RingHom R S) (g : RingHom S T), P R S f → Q S T g → Q R T (g.comp f)\nR : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : f.FinitePresentation\n⊢ Q R S f","decl":"/-- Induction principle for finitely presented ring homomorphisms.\n\nFor a property to hold for all finitely presented ring homs, it suffices for it to hold for\n`Polynomial.C : R → R[X]`, surjective ring homs with finitely generated kernels, and to be closed\nunder composition.\n\nNote that to state this conveniently for ring homs between rings of different universes, we carry\naround two predicates `P` and `Q`, which should be \"the same\" apart from universes:\n* `P`, for ring homs `(R : Type u) → (S : Type u)`.\n* `Q`, for ring homs `(R : Type u) → (S : Type v)`.\n-/\nlemma polynomial_induction\n    (P : ∀ (R : Type u) [CommRing R] (S : Type u) [CommRing S], (R →+* S) → Prop)\n    (Q : ∀ (R : Type u) [CommRing R] (S : Type v) [CommRing S], (R →+* S) → Prop)\n    (polynomial : ∀ (R) [CommRing R], P R R[X] C)\n    (fg_ker : ∀ (R : Type u) [CommRing R] (S : Type v) [CommRing S] (f : R →+* S),\n      Surjective f → (ker f).FG → Q R S f)\n    (comp : ∀ (R) [CommRing R] (S) [CommRing S] (T) [CommRing T] (f : R →+* S) (g : S →+* T),\n      P R S f → Q S T g → Q R T (g.comp f))\n    {R : Type u} {S : Type v} [CommRing R] [CommRing S] (f : R →+* S) (hf : f.FinitePresentation) :\n    Q R S f := by\n  letI := f.toAlgebra\n  obtain ⟨n, g, hg, hg'⟩ := hf\n  let g' := g.toRingHom\n  change Surjective g' at hg\n  change (ker g').FG at hg'\n  have : g'.comp MvPolynomial.C = f := g.comp_algebraMap\n  clear_value g'\n  subst this\n  clear g\n  induction n generalizing R S with\n  | zero =>\n    refine fg_ker _ _ _ (hg.comp (MvPolynomial.C_surjective (Fin 0))) ?_\n    rw [← comap_ker]\n    convert hg'.map (MvPolynomial.isEmptyRingEquiv R (Fin 0)).toRingHom using 1\n    simp only [RingEquiv.toRingHom_eq_coe]\n    exact Ideal.comap_symm (MvPolynomial.isEmptyRingEquiv R (Fin 0))\n  | succ n IH =>\n    let e : MvPolynomial (Fin (n + 1)) R ≃ₐ[R] MvPolynomial (Fin n) R[X] :=\n      (MvPolynomial.renameEquiv R (finSuccEquiv n)).trans (MvPolynomial.optionEquivRight R (Fin n))\n    have he : (ker (g'.comp <| RingHomClass.toRingHom e.symm)).FG := by\n      rw [← RingHom.comap_ker]\n      convert hg'.map e.toAlgHom.toRingHom using 1\n      exact Ideal.comap_symm e.toRingEquiv\n    have := IH (R := R[X]) (S := S) (g'.comp e.symm) (hg.comp e.symm.surjective) he\n    convert comp _ _ _ _ _ (polynomial _) this using 1\n    rw [comp_assoc, comp_assoc]\n    congr 1 with r\n    simp [e]\n\n"}
{"name":"AlgHom.FiniteType.of_finitePresentation","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\nhf : f.FinitePresentation\n⊢ f.FiniteType","decl":"theorem of_finitePresentation {f : A →ₐ[R] B} (hf : f.FinitePresentation) : f.FiniteType :=\n  RingHom.FiniteType.of_finitePresentation hf\n\n"}
{"name":"AlgHom.FinitePresentation.id","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ (AlgHom.id R A).FinitePresentation","decl":"theorem id : FinitePresentation (AlgHom.id R A) :=\n  RingHom.FinitePresentation.id A\n\n"}
{"name":"AlgHom.FinitePresentation.comp","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : CommRing C\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R C\ng : AlgHom R B C\nf : AlgHom R A B\nhg : g.FinitePresentation\nhf : f.FinitePresentation\n⊢ (g.comp f).FinitePresentation","decl":"theorem comp {g : B →ₐ[R] C} {f : A →ₐ[R] B} (hg : g.FinitePresentation)\n    (hf : f.FinitePresentation) : (g.comp f).FinitePresentation :=\n  RingHom.FinitePresentation.comp hg hf\n\n"}
{"name":"AlgHom.FinitePresentation.comp_surjective","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : CommRing C\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R C\nf : AlgHom R A B\ng : AlgHom R B C\nhf : f.FinitePresentation\nhg : Function.Surjective ⇑g\nhker : (RingHom.ker g.toRingHom).FG\n⊢ (g.comp f).FinitePresentation","decl":"theorem comp_surjective {f : A →ₐ[R] B} {g : B →ₐ[R] C} (hf : f.FinitePresentation)\n    (hg : Surjective g) (hker : g.toRingHom.ker.FG) : (g.comp f).FinitePresentation :=\n  RingHom.FinitePresentation.comp_surjective hf hg hker\n\n"}
{"name":"AlgHom.FinitePresentation.of_surjective","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\nhf : Function.Surjective ⇑f\nhker : (RingHom.ker f.toRingHom).FG\n⊢ f.FinitePresentation","decl":"theorem of_surjective (f : A →ₐ[R] B) (hf : Surjective f) (hker : f.toRingHom.ker.FG) :\n    f.FinitePresentation := by\n  -- Porting note: added `convert`\n  convert RingHom.FinitePresentation.of_surjective f hf hker\n\n"}
{"name":"AlgHom.FinitePresentation.of_finiteType","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : IsNoetherianRing A\nf : AlgHom R A B\n⊢ Iff f.FiniteType f.FinitePresentation","decl":"theorem of_finiteType [IsNoetherianRing A] {f : A →ₐ[R] B} : f.FiniteType ↔ f.FinitePresentation :=\n  RingHom.FinitePresentation.of_finiteType\n\n"}
{"name":"AlgHom.FinitePresentation.of_comp_finiteType","module":"Mathlib.RingTheory.FinitePresentation","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : CommRing C\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R C\nf : AlgHom R A B\ng : AlgHom R B C\nh : (g.comp f).FinitePresentation\nh' : f.FiniteType\n⊢ g.FinitePresentation","decl":"nonrec theorem of_comp_finiteType (f : A →ₐ[R] B) {g : B →ₐ[R] C}\n    (h : (g.comp f).FinitePresentation) (h' : f.FiniteType) : g.FinitePresentation :=\n  h.of_comp_finiteType _ h'\n\n"}
