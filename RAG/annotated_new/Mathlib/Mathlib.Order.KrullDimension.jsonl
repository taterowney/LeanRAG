{"name":"Order.height_toDual","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ Eq (Order.height (OrderDual.toDual x)) (Order.coheight x)","decl":"@[simp] lemma height_toDual (x : α) : height (OrderDual.toDual x) = coheight x := rfl\n"}
{"name":"Order.height_ofDual","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : OrderDual α\n⊢ Eq (Order.height (OrderDual.ofDual x)) (Order.coheight x)","decl":"@[simp] lemma height_ofDual (x : αᵒᵈ) : height (OrderDual.ofDual x) = coheight x := rfl\n"}
{"name":"Order.coheight_toDual","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ Eq (Order.coheight (OrderDual.toDual x)) (Order.height x)","decl":"@[simp] lemma coheight_toDual (x : α) : coheight (OrderDual.toDual x) = height x := rfl\n"}
{"name":"Order.coheight_ofDual","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : OrderDual α\n⊢ Eq (Order.coheight (OrderDual.ofDual x)) (Order.height x)","decl":"@[simp] lemma coheight_ofDual (x : αᵒᵈ) : coheight (OrderDual.ofDual x) = height x := rfl\n\n"}
{"name":"Order.coheight_eq","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (Order.coheight a) (iSup fun p => iSup fun x => ↑p.length)","decl":"/--\nThe **coheight** of an element `a` in a preorder `α` is the supremum of the rightmost index of all\nrelation series of `α` ordered by `<` and beginning with `a`.\n\nThis is not the definition of `coheight`. The definition of `coheight` is via the `height` in the\ndual order, in order to easily transfer theorems between `height` and `coheight`.\n-/\nlemma coheight_eq (a : α) :\n    coheight a = ⨆ (p : LTSeries α) (_ : a ≤ p.head), (p.length : ℕ∞) := by\n  apply Equiv.iSup_congr ⟨RelSeries.reverse, RelSeries.reverse, RelSeries.reverse_reverse,\n    RelSeries.reverse_reverse⟩\n  congr! 1\n\n"}
{"name":"Order.height_le_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nn : ENat\n⊢ Iff (LE.le (Order.height a) n) (∀ ⦃p : LTSeries α⦄, LE.le (RelSeries.last p) a → LE.le (↑p.length) n)","decl":"lemma height_le_iff {a : α} {n : ℕ∞} :\n    height a ≤ n ↔ ∀ ⦃p : LTSeries α⦄, p.last ≤ a → p.length ≤ n := by\n rw [height, iSup₂_le_iff]\n\n"}
{"name":"Order.coheight_le_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nn : ENat\n⊢ Iff (LE.le (Order.coheight a) n) (∀ ⦃p : LTSeries α⦄, LE.le a (RelSeries.head p) → LE.le (↑p.length) n)","decl":"lemma coheight_le_iff {a : α} {n : ℕ∞} :\n    coheight a ≤ n ↔ ∀ ⦃p : LTSeries α⦄, a ≤ p.head → p.length ≤ n := by\n rw [coheight_eq, iSup₂_le_iff]\n\n"}
{"name":"Order.height_le","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nn : ENat\nh : ∀ (p : LTSeries α), Eq (RelSeries.last p) a → LE.le (↑p.length) n\n⊢ LE.le (Order.height a) n","decl":"lemma height_le {a : α} {n : ℕ∞} (h : ∀ (p : LTSeries α), p.last = a → p.length ≤ n) :\n    height a ≤ n := by\n  apply height_le_iff.mpr\n  intro p hlast\n  wlog hlenpos : p.length ≠ 0\n  · simp_all\n  -- We replace the last element in the series with `a`\n  let p' := p.eraseLast.snoc a (lt_of_lt_of_le (p.eraseLast_last_rel_last (by simp_all)) hlast)\n  rw [show p.length = p'.length by simp [p']; omega]\n  apply h\n  simp [p']\n\n"}
{"name":"Order.height_le_iff'","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nn : ENat\n⊢ Iff (LE.le (Order.height a) n) (∀ ⦃p : LTSeries α⦄, Eq (RelSeries.last p) a → LE.le (↑p.length) n)","decl":"/--\nVariant of `height_le_iff` ranging only over those series that end exactly on `a`.\n-/\nlemma height_le_iff' {a : α} {n : ℕ∞} :\n    height a ≤ n ↔ ∀ ⦃p : LTSeries α⦄, p.last = a → p.length ≤ n := by\n constructor\n · rw [height_le_iff]\n   exact fun h p hlast => h (le_of_eq hlast)\n · exact height_le\n\n"}
{"name":"Order.height_eq_iSup_last_eq","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (Order.height a) (iSup fun p => iSup fun x => ↑p.length)","decl":"/--\nAlternative definition of height, with the supremum ranging only over those series that end at `a`.\n-/\nlemma height_eq_iSup_last_eq (a : α) :\n    height a = ⨆ (p : LTSeries α) (_ : p.last = a), ↑(p.length) := by\n  apply eq_of_forall_ge_iff\n  intro n\n  rw [height_le_iff', iSup₂_le_iff]\n\n"}
{"name":"Order.coheight_eq_iSup_head_eq","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (Order.coheight a) (iSup fun p => iSup fun x => ↑p.length)","decl":"/--\nAlternative definition of coheight, with the supremum only ranging over those series\nthat begin at `a`.\n-/\nlemma coheight_eq_iSup_head_eq (a : α) :\n    coheight a = ⨆ (p : LTSeries α) (_ : p.head = a), ↑(p.length) := by\n  show height (α := αᵒᵈ) a = ⨆ (p : LTSeries α) (_ : p.head = a), ↑(p.length)\n  rw [height_eq_iSup_last_eq]\n  apply Equiv.iSup_congr ⟨RelSeries.reverse, RelSeries.reverse, RelSeries.reverse_reverse,\n    RelSeries.reverse_reverse⟩\n  simp\n\n"}
{"name":"Order.coheight_le_iff'","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nn : ENat\n⊢ Iff (LE.le (Order.coheight a) n) (∀ ⦃p : LTSeries α⦄, Eq (RelSeries.head p) a → LE.le (↑p.length) n)","decl":"/--\nVariant of `coheight_le_iff` ranging only over those series that begin exactly on `a`.\n-/\nlemma coheight_le_iff' {a : α} {n : ℕ∞} :\n    coheight a ≤ n ↔ ∀ ⦃p : LTSeries α⦄, p.head = a → p.length ≤ n := by\n  rw [coheight_eq_iSup_head_eq, iSup₂_le_iff]\n\n"}
{"name":"Order.coheight_le","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nn : ENat\nh : ∀ (p : LTSeries α), Eq (RelSeries.head p) a → LE.le (↑p.length) n\n⊢ LE.le (Order.coheight a) n","decl":"lemma coheight_le {a : α} {n : ℕ∞} (h : ∀ (p : LTSeries α), p.head = a → p.length ≤ n) :\n    coheight a ≤ n :=\n  coheight_le_iff'.mpr h\n\n"}
{"name":"Order.length_le_height","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\np : LTSeries α\nx : α\nhlast : LE.le (RelSeries.last p) x\n⊢ LE.le (↑p.length) (Order.height x)","decl":"lemma length_le_height {p : LTSeries α} {x : α} (hlast : p.last ≤ x) :\n    p.length ≤ height x := by\n  by_cases hlen0 : p.length ≠ 0\n  · let p' := p.eraseLast.snoc x (by\n      apply lt_of_lt_of_le\n      · apply p.step ⟨p.length - 1, by omega⟩\n      · convert hlast\n        simp only [Fin.succ_mk, Nat.succ_eq_add_one, RelSeries.last, Fin.last]\n        congr; omega)\n    suffices p'.length ≤ height x by\n      simp [p'] at this\n      convert this\n      norm_cast\n      omega\n    refine le_iSup₂_of_le p' ?_ le_rfl\n    simp [p']\n  · simp_all\n\n"}
{"name":"Order.length_le_coheight","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\np : LTSeries α\nhhead : LE.le x (RelSeries.head p)\n⊢ LE.le (↑p.length) (Order.coheight x)","decl":"lemma length_le_coheight {x : α} {p : LTSeries α} (hhead : x ≤ p.head) :\n    p.length ≤ coheight x :=\n  length_le_height (α := αᵒᵈ) (p := p.reverse) (by simpa)\n\n"}
{"name":"Order.length_le_height_last","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\np : LTSeries α\n⊢ LE.le (↑p.length) (Order.height (RelSeries.last p))","decl":"/--\nThe height of the last element in a series is larger or equal to the length of the series.\n-/\nlemma length_le_height_last {p : LTSeries α} : p.length ≤ height p.last :=\n  length_le_height le_rfl\n\n"}
{"name":"Order.length_le_coheight_head","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\np : LTSeries α\n⊢ LE.le (↑p.length) (Order.coheight (RelSeries.head p))","decl":"/--\nThe coheight of the first element in a series is larger or equal to the length of the series.\n-/\nlemma length_le_coheight_head {p : LTSeries α} : p.length ≤ coheight p.head :=\n  length_le_coheight le_rfl\n\n"}
{"name":"Order.index_le_height","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\np : LTSeries α\ni : Fin (HAdd.hAdd p.length 1)\n⊢ LE.le (↑↑i) (Order.height (p.toFun i))","decl":"/--\nThe height of an element in a series is larger or equal to its index in the series.\n-/\nlemma index_le_height (p : LTSeries α) (i : Fin (p.length + 1)) : i ≤ height (p i) :=\n  length_le_height_last (p := p.take i)\n\n"}
{"name":"Order.rev_index_le_coheight","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\np : LTSeries α\ni : Fin (HAdd.hAdd p.length 1)\n⊢ LE.le (↑↑i.rev) (Order.coheight (p.toFun i))","decl":"/--\nThe coheight of an element in a series is larger or equal to its reverse index in the series.\n-/\nlemma rev_index_le_coheight (p : LTSeries α) (i : Fin (p.length + 1)) : i.rev ≤ coheight (p i) := by\n  simpa using index_le_height (α := αᵒᵈ) p.reverse i.rev\n\n"}
{"name":"Order.height_eq_index_of_length_eq_height_last","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\np : LTSeries α\nh : Eq (↑p.length) (Order.height (RelSeries.last p))\ni : Fin (HAdd.hAdd p.length 1)\n⊢ Eq (Order.height (p.toFun i)) ↑↑i","decl":"/--\nIn a maximally long series, i.e one as long as the height of the last element, the height of each\nelement is its index in the series.\n-/\nlemma height_eq_index_of_length_eq_height_last {p : LTSeries α} (h : p.length = height p.last)\n    (i : Fin (p.length + 1)) : height (p i) = i := by\n  refine le_antisymm (height_le ?_) (index_le_height p i)\n  intro p' hp'\n  have hp'' := length_le_height_last (p := p'.smash (p.drop i) (by simpa))\n  simp [← h] at hp''; clear h\n  norm_cast at *\n  omega\n\n"}
{"name":"Order.coheight_eq_index_of_length_eq_head_coheight","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\np : LTSeries α\nh : Eq (↑p.length) (Order.coheight (RelSeries.head p))\ni : Fin (HAdd.hAdd p.length 1)\n⊢ Eq (Order.coheight (p.toFun i)) ↑↑i.rev","decl":"/--\nIn a maximally long series, i.e one as long as the coheight of the first element, the coheight of\neach element is its reverse index in the series.\n-/\nlemma coheight_eq_index_of_length_eq_head_coheight {p : LTSeries α} (h : p.length = coheight p.head)\n    (i : Fin (p.length + 1)) : coheight (p i) = i.rev := by\n  simpa using height_eq_index_of_length_eq_height_last (α := αᵒᵈ) (p := p.reverse) (by simpa) i.rev\n\n"}
{"name":"Order.height_mono","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Monotone Order.height","decl":"lemma height_mono : Monotone (α := α) height :=\n  fun _ _ hab ↦ biSup_mono (fun _ hla => hla.trans hab)\n\n"}
{"name":"GCongr.height_le_height","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LE.le a b\n⊢ LE.le (Order.height a) (Order.height b)","decl":"@[gcongr] protected lemma _root_.GCongr.height_le_height (a b : α) (hab : a ≤ b) :\n    height a ≤ height b := height_mono hab\n\n"}
{"name":"Order.coheight_anti","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Antitone Order.coheight","decl":"lemma coheight_anti : Antitone (α := α) coheight :=\n  (height_mono (α := αᵒᵈ)).dual_left\n\n"}
{"name":"GCongr.coheight_le_coheight","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhba : LE.le b a\n⊢ LE.le (Order.coheight a) (Order.coheight b)","decl":"@[gcongr] protected lemma _root_.GCongr.coheight_le_coheight (a b : α) (hba : b ≤ a) :\n    coheight a ≤ coheight b := coheight_anti hba\n\n"}
{"name":"Order.height_strictMono","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\nhxy : LT.lt x y\nhfin : LT.lt (Order.height x) Top.top\n⊢ LT.lt (Order.height x) (Order.height y)","decl":"@[gcongr] lemma height_strictMono {x y : α} (hxy : x < y) (hfin : height x < ⊤) :\n    height x < height y := by\n  rw [← ENat.add_one_le_iff hfin.ne, height_add_const, iSup₂_le_iff]\n  intro p hlast\n  have := length_le_height_last (p := p.snoc y (by simp [*]))\n  simpa using this\n\n"}
{"name":"Order.height_add_one_le","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LT.lt a b\n⊢ LE.le (HAdd.hAdd (Order.height a) 1) (Order.height b)","decl":"lemma height_add_one_le {a b : α} (hab : a < b) : height a + 1 ≤ height b := by\n  cases hfin : height a with\n  | top =>\n    have : ⊤ ≤ height b := by\n      rw [← hfin]\n      gcongr\n    simp [this]\n  | coe n =>\n    apply Order.add_one_le_of_lt\n    rw [← hfin]\n    gcongr\n    simp [hfin]\n\n/- For elements of finite height, `coheight` is strictly antitone. -/\n"}
{"name":"Order.coheight_strictAnti","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\nhyx : LT.lt y x\nhfin : LT.lt (Order.coheight x) Top.top\n⊢ LT.lt (Order.coheight x) (Order.coheight y)","decl":"@[gcongr] lemma coheight_strictAnti {x y : α} (hyx : y < x) (hfin : coheight x < ⊤) :\n    coheight x < coheight y :=\n  height_strictMono (α := αᵒᵈ) hyx hfin\n\n"}
{"name":"Order.coheight_add_one_le","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nhab : LT.lt b a\n⊢ LE.le (HAdd.hAdd (Order.coheight a) 1) (Order.coheight b)","decl":"lemma coheight_add_one_le {a b : α} (hab : b < a) : coheight a + 1 ≤ coheight b := by\n  cases hfin : coheight a with\n  | top =>\n    have : ⊤ ≤ coheight b := by\n      rw [← hfin]\n      gcongr\n    simp [this]\n  | coe n =>\n    apply Order.add_one_le_of_lt\n    rw [← hfin]\n    gcongr\n    simp [hfin]\n\n"}
{"name":"Order.height_le_height_apply_of_strictMono","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictMono f\nx : α\n⊢ LE.le (Order.height x) (Order.height (f x))","decl":"lemma height_le_height_apply_of_strictMono (f : α → β) (hf : StrictMono f) (x : α) :\n    height x ≤ height (f x) := by\n  simp only [height_eq_iSup_last_eq]\n  apply iSup₂_le\n  intro p hlast\n  apply le_iSup₂_of_le (p.map f hf) (by simp [hlast]) (by simp)\n\n"}
{"name":"Order.coheight_le_coheight_apply_of_strictMono","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictMono f\nx : α\n⊢ LE.le (Order.coheight x) (Order.coheight (f x))","decl":"lemma coheight_le_coheight_apply_of_strictMono (f : α → β) (hf : StrictMono f) (x : α) :\n    coheight x ≤ coheight (f x) := by\n  apply height_le_height_apply_of_strictMono (α := αᵒᵈ)\n  exact fun _ _ h ↦ hf h\n\n"}
{"name":"Order.height_orderIso","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\nx : α\n⊢ Eq (Order.height (f x)) (Order.height x)","decl":"@[simp]\nlemma height_orderIso (f : α ≃o β) (x : α) : height (f x) = height x := by\n  apply le_antisymm\n  · simpa using height_le_height_apply_of_strictMono _ f.symm.strictMono (f x)\n  · exact height_le_height_apply_of_strictMono _ f.strictMono x\n\n"}
{"name":"Order.coheight_orderIso","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\nx : α\n⊢ Eq (Order.coheight (f x)) (Order.coheight x)","decl":"lemma coheight_orderIso (f : α ≃o β) (x : α) : coheight (f x) = coheight x :=\n  height_orderIso (α := αᵒᵈ) f.dual x\n\n"}
{"name":"Order.exists_series_of_le_height","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nn : Nat\nh : LE.le (↑n) (Order.height a)\n⊢ Exists fun p => And (Eq (RelSeries.last p) a) (Eq p.length n)","decl":"/-- There exist a series ending in a element for any length up to the element’s height.  -/\nlemma exists_series_of_le_height (a : α) {n : ℕ} (h : n ≤ height a) :\n    ∃ p : LTSeries α, p.last = a ∧ p.length = n := by\n  have hne : Nonempty { p : LTSeries α // p.last = a } := ⟨RelSeries.singleton _ a, rfl⟩\n  cases ha : height a with\n  | top =>\n    clear h\n    rw [height_eq_iSup_last_eq, iSup_subtype', ENat.iSup_coe_eq_top, bddAbove_def] at ha\n    contrapose! ha\n    use n\n    rintro m ⟨⟨p, rfl⟩, hp⟩\n    simp only at hp\n    by_contra! hnm\n    apply ha (p.drop ⟨m-n, by omega⟩) (by simp) (by simp; omega)\n  | coe m =>\n    rw [ha, Nat.cast_le] at h\n    rw [height_eq_iSup_last_eq, iSup_subtype'] at ha\n    obtain ⟨⟨p, hlast⟩, hlen⟩ := exists_eq_iSup_of_iSup_eq_coe ha\n    simp only [Nat.cast_inj] at hlen\n    use p.drop ⟨m-n, by omega⟩\n    constructor\n    · simp [hlast]\n    · simp [hlen]; omega\n\n"}
{"name":"Order.exists_series_of_le_coheight","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nn : Nat\nh : LE.le (↑n) (Order.coheight a)\n⊢ Exists fun p => And (Eq (RelSeries.head p) a) (Eq p.length n)","decl":"lemma exists_series_of_le_coheight (a : α) {n : ℕ} (h : n ≤ coheight a) :\n    ∃ p : LTSeries α, p.head = a ∧ p.length = n := by\n  obtain ⟨p, hp, hl⟩ := exists_series_of_le_height (α := αᵒᵈ) a h\n  exact ⟨p.reverse, by simpa, by simpa⟩\n\n"}
{"name":"Order.exists_series_of_height_eq_coe","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nn : Nat\nh : Eq (Order.height a) ↑n\n⊢ Exists fun p => And (Eq (RelSeries.last p) a) (Eq p.length n)","decl":"/-- For an element of finite height there exists a series ending in that element of that height. -/\nlemma exists_series_of_height_eq_coe (a : α) {n : ℕ} (h : height a = n) :\n    ∃ p : LTSeries α, p.last = a ∧ p.length = n :=\n  exists_series_of_le_height a (le_of_eq h.symm)\n\n"}
{"name":"Order.exists_series_of_coheight_eq_coe","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nn : Nat\nh : Eq (Order.coheight a) ↑n\n⊢ Exists fun p => And (Eq (RelSeries.head p) a) (Eq p.length n)","decl":"lemma exists_series_of_coheight_eq_coe (a : α) {n : ℕ} (h : coheight a = n) :\n    ∃ p : LTSeries α, p.head = a ∧ p.length = n :=\n  exists_series_of_le_coheight a (le_of_eq h.symm)\n\n"}
{"name":"Order.height_eq_iSup_lt_height","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ Eq (Order.height x) (iSup fun y => iSup fun h => HAdd.hAdd (Order.height y) 1)","decl":"/-- Another characterization of height, based on the supremum of the heights of elements below. -/\nlemma height_eq_iSup_lt_height (x : α) : height x = ⨆ y < x, height y + 1 := by\n  apply le_antisymm\n  · apply height_le\n    intro p hp\n    cases hlen : p.length with\n    | zero => simp\n    | succ n =>\n      apply le_iSup_of_le p.eraseLast.last\n      apply le_iSup_of_le (by rw [← hp]; apply RelSeries.eraseLast_last_rel_last _ (by omega))\n      rw [height_add_const]\n      apply le_iSup₂_of_le p.eraseLast (by rfl) (by simp [hlen])\n  · apply iSup₂_le; intro y hyx\n    rw [height_add_const]\n    apply iSup₂_le; intro p hp\n    apply le_iSup₂_of_le (p.snoc x (hp ▸ hyx)) (by simp) (by simp)\n\n"}
{"name":"Order.coheight_eq_iSup_gt_coheight","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ Eq (Order.coheight x) (iSup fun y => iSup fun h => HAdd.hAdd (Order.coheight y) 1)","decl":"/--\nAnother characterization of coheight, based on the supremum of the coheights of elements above.\n-/\nlemma coheight_eq_iSup_gt_coheight (x : α) : coheight x = ⨆ y > x, coheight y + 1 :=\n  height_eq_iSup_lt_height (α := αᵒᵈ) x\n\n"}
{"name":"Order.height_le_coe_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\nn : Nat\n⊢ Iff (LE.le (Order.height x) ↑n) (∀ (y : α), LT.lt y x → LT.lt (Order.height y) ↑n)","decl":"lemma height_le_coe_iff {x : α} {n : ℕ} : height x ≤ n ↔ ∀ y < x, height y < n := by\n  conv_lhs => rw [height_eq_iSup_lt_height, iSup₂_le_iff]\n  congr! 2 with y _\n  cases height y\n  · simp\n  · norm_cast\n\n"}
{"name":"Order.coheight_le_coe_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\nn : Nat\n⊢ Iff (LE.le (Order.coheight x) ↑n) (∀ (y : α), GT.gt y x → LT.lt (Order.coheight y) ↑n)","decl":"lemma coheight_le_coe_iff {x : α} {n : ℕ} : coheight x ≤ n ↔ ∀ y > x, coheight y < n :=\n  height_le_coe_iff (α := αᵒᵈ)\n\n"}
{"name":"Order.height_eq_top_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ Iff (Eq (Order.height x) Top.top) (∀ (n : Nat), Exists fun p => And (Eq (RelSeries.last p) x) (Eq p.length n))","decl":"/--\nThe height of an element is infinite iff there exist series of arbitrary length ending in that\nelement.\n-/\nlemma height_eq_top_iff {x : α} :\n    height x = ⊤ ↔ ∀ n, ∃ p : LTSeries α, p.last = x ∧ p.length = n where\n  mp h n := by\n    apply exists_series_of_le_height x (n := n)\n    simp [h]\n  mpr h := by\n    rw [height_eq_iSup_last_eq, iSup_subtype', ENat.iSup_coe_eq_top, bddAbove_def]\n    push_neg\n    intro n\n    obtain ⟨p, hlast, hp⟩ := h (n+1)\n    exact ⟨p.length, ⟨⟨⟨p, hlast⟩, by simp [hp]⟩, by simp [hp]⟩⟩\n\n"}
{"name":"Order.coheight_eq_top_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ Iff (Eq (Order.coheight x) Top.top) (∀ (n : Nat), Exists fun p => And (Eq (RelSeries.head p) x) (Eq p.length n))","decl":"/--\nThe coheight of an element is infinite iff there exist series of arbitrary length ending in that\nelement.\n-/\nlemma coheight_eq_top_iff {x : α} :\n    coheight x = ⊤ ↔ ∀ n, ∃ p : LTSeries α, p.head = x ∧ p.length = n := by\n  convert height_eq_top_iff (α := αᵒᵈ) (x := x) using 2 with n\n  constructor <;> (intro ⟨p, hp, hl⟩; use p.reverse; constructor <;> simpa)\n\n"}
{"name":"Order.height_eq_zero","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ Iff (Eq (Order.height x) 0) (IsMin x)","decl":"/-- The elements of height zero are the minimal elements. -/\n@[simp] lemma height_eq_zero {x : α} : height x = 0 ↔ IsMin x := by\n  simpa [isMin_iff_forall_not_lt] using height_le_coe_iff (x := x) (n := 0)\n\n"}
{"name":"Order.IsMin.height_eq_zero","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\na✝ : IsMin x\n⊢ Eq (Order.height x) 0","decl":"protected alias ⟨_, IsMin.height_eq_zero⟩ := height_eq_zero\n\n"}
{"name":"Order.coheight_eq_zero","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ Iff (Eq (Order.coheight x) 0) (IsMax x)","decl":"/-- The elements of coheight zero are the maximal elements. -/\n@[simp] lemma coheight_eq_zero {x : α} : coheight x = 0 ↔ IsMax x :=\n  height_eq_zero (α := αᵒᵈ)\n\n"}
{"name":"Order.IsMax.coheight_eq_zero","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\na✝ : IsMax x\n⊢ Eq (Order.coheight x) 0","decl":"protected alias ⟨_, IsMax.coheight_eq_zero⟩ := coheight_eq_zero\n\n"}
{"name":"Order.height_bot","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_3\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\n⊢ Eq (Order.height Bot.bot) 0","decl":"@[simp] lemma height_bot (α : Type*) [Preorder α] [OrderBot α] : height (⊥ : α) = 0 := by simp\n\n"}
{"name":"Order.coheight_top","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_3\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\n⊢ Eq (Order.coheight Top.top) 0","decl":"@[simp] lemma coheight_top (α : Type*) [Preorder α] [OrderTop α] : coheight (⊤ : α) = 0 := by simp\n\n"}
{"name":"Order.coe_lt_height_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\nn : Nat\nhfin : LT.lt (Order.height x) Top.top\n⊢ Iff (LT.lt (↑n) (Order.height x)) (Exists fun y => And (LT.lt y x) (Eq (Order.height y) ↑n))","decl":"lemma coe_lt_height_iff {x : α} {n : ℕ} (hfin : height x < ⊤) :\n    n < height x ↔ ∃ y < x, height y = n where\n  mp h := by\n    obtain ⟨m, hx : height x = m⟩ := Option.ne_none_iff_exists'.mp hfin.ne_top\n    rw [hx] at h; norm_cast at h\n    obtain ⟨p, hp, hlen⟩ := exists_series_of_height_eq_coe x hx\n    use p ⟨n, by omega⟩\n    constructor\n    · rw [← hp]\n      apply LTSeries.strictMono\n      simp [Fin.last]; omega\n    · exact height_eq_index_of_length_eq_height_last (by simp [hlen, hp, hx]) ⟨n, by omega⟩\n  mpr := fun ⟨y, hyx, hy⟩ =>\n    hy ▸ height_strictMono hyx (lt_of_le_of_lt (height_mono hyx.le) hfin)\n\n"}
{"name":"Order.coe_lt_coheight_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\nn : Nat\nhfin : LT.lt (Order.coheight x) Top.top\n⊢ Iff (LT.lt (↑n) (Order.coheight x)) (Exists fun y => And (GT.gt y x) (Eq (Order.coheight y) ↑n))","decl":"lemma coe_lt_coheight_iff {x : α} {n : ℕ} (hfin : coheight x < ⊤):\n    n < coheight x ↔ ∃ y > x, coheight y = n :=\n  coe_lt_height_iff (α := αᵒᵈ) hfin\n\n"}
{"name":"Order.height_eq_coe_add_one_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\nn : Nat\n⊢ Iff (Eq (Order.height x) (HAdd.hAdd (↑n) 1)) (And (LT.lt (Order.height x) Top.top) (And (Exists fun y => And (LT.lt y x) (Eq (Order.height y) ↑n)) (∀ (y : α), LT.lt y x → LE.le (Order.height y) ↑n)))","decl":"lemma height_eq_coe_add_one_iff {x : α} {n : ℕ} :\n    height x = n + 1 ↔ height x < ⊤ ∧ (∃ y < x, height y = n) ∧ (∀ y < x, height y ≤ n) := by\n  wlog hfin : height x < ⊤\n  · simp_all\n    exact ne_of_beq_false rfl\n  simp only [hfin, true_and]\n  trans n < height x ∧ height x ≤ n + 1\n  · rw [le_antisymm_iff, and_comm]\n    simp [hfin, ENat.lt_add_one_iff, ENat.add_one_le_iff]\n  · congr! 1\n    · exact coe_lt_height_iff hfin\n    · simpa [hfin, ENat.lt_add_one_iff] using height_le_coe_iff (x := x) (n := n+1)\n\n"}
{"name":"Order.coheight_eq_coe_add_one_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\nn : Nat\n⊢ Iff (Eq (Order.coheight x) (HAdd.hAdd (↑n) 1)) (And (LT.lt (Order.coheight x) Top.top) (And (Exists fun y => And (GT.gt y x) (Eq (Order.coheight y) ↑n)) (∀ (y : α), GT.gt y x → LE.le (Order.coheight y) ↑n)))","decl":"lemma coheight_eq_coe_add_one_iff {x : α} {n : ℕ} :\n    coheight x = n + 1 ↔\n      coheight x < ⊤ ∧ (∃ y > x, coheight y = n) ∧ (∀ y > x, coheight y ≤ n) :=\n  height_eq_coe_add_one_iff (α := αᵒᵈ)\n\n"}
{"name":"Order.height_eq_coe_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\nn : Nat\n⊢ Iff (Eq (Order.height x) ↑n) (And (LT.lt (Order.height x) Top.top) (And (Or (Eq n 0) (Exists fun y => And (LT.lt y x) (Eq (Order.height y) (HSub.hSub (↑n) 1)))) (∀ (y : α), LT.lt y x → LT.lt (Order.height y) ↑n)))","decl":"lemma height_eq_coe_iff {x : α} {n : ℕ} :\n    height x = n ↔\n      height x < ⊤ ∧ (n = 0 ∨ ∃ y < x, height y = n - 1) ∧ (∀ y < x, height y < n) := by\n  wlog hfin : height x < ⊤\n  · simp_all\n  simp only [hfin, true_and]\n  cases n\n  case zero => simp [isMin_iff_forall_not_lt]\n  case succ n =>\n    simp only [Nat.cast_add, Nat.cast_one, add_eq_zero, one_ne_zero, and_false, false_or]\n    rw [height_eq_coe_add_one_iff]\n    simp only [hfin, true_and]\n    congr! 3\n    rename_i y _\n    cases height y <;> simp; norm_cast; omega\n\n"}
{"name":"Order.coheight_eq_coe_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\nn : Nat\n⊢ Iff (Eq (Order.coheight x) ↑n) (And (LT.lt (Order.coheight x) Top.top) (And (Or (Eq n 0) (Exists fun y => And (GT.gt y x) (Eq (Order.coheight y) (HSub.hSub (↑n) 1)))) (∀ (y : α), GT.gt y x → LT.lt (Order.coheight y) ↑n)))","decl":"lemma coheight_eq_coe_iff {x : α} {n : ℕ} :\n    coheight x = n ↔\n      coheight x < ⊤ ∧ (n = 0 ∨ ∃ y > x, coheight y = n - 1) ∧ (∀ y > x, coheight y < n) :=\n  height_eq_coe_iff (α := αᵒᵈ)\n\n"}
{"name":"Order.height_eq_coe_iff_minimal_le_height","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nn : Nat\n⊢ Iff (Eq (Order.height a) ↑n) (Minimal (fun y => LE.le (↑n) (Order.height y)) a)","decl":"/-- The elements of finite height `n` are the minimal elements among those of height `≥ n`. -/\nlemma height_eq_coe_iff_minimal_le_height {a : α} {n : ℕ} :\n    height a = n ↔ Minimal (fun y => n ≤ height y) a := by\n  by_cases hfin : height a < ⊤\n  · cases hn : n with\n    | zero => simp\n    | succ => simp [minimal_iff_forall_lt, height_eq_coe_add_one_iff, ENat.add_one_le_iff,\n        coe_lt_height_iff, *]\n  · suffices ∃ x < a, ↑n ≤ height x by\n      simp_all [minimal_iff_forall_lt]\n    simp only [not_lt, top_le_iff, height_eq_top_iff] at hfin\n    obtain ⟨p, rfl, hp⟩ := hfin (n+1)\n    use p.eraseLast.last, RelSeries.eraseLast_last_rel_last _ (by omega)\n    simpa [hp] using length_le_height_last (p := p.eraseLast)\n\n"}
{"name":"Order.coheight_eq_coe_iff_maximal_le_coheight","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nn : Nat\n⊢ Iff (Eq (Order.coheight a) ↑n) (Maximal (fun y => LE.le (↑n) (Order.coheight y)) a)","decl":"/-- The elements of finite coheight `n` are the maximal elements among those of coheight `≥ n`. -/\nlemma coheight_eq_coe_iff_maximal_le_coheight {a : α} {n : ℕ} :\n    coheight a = n ↔ Maximal (fun y => n ≤ coheight y) a :=\n  height_eq_coe_iff_minimal_le_height (α := αᵒᵈ)\n\n"}
{"name":"Order.LTSeries.length_le_krullDim","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\np : LTSeries α\n⊢ LE.le (↑p.length) (Order.krullDim α)","decl":"lemma LTSeries.length_le_krullDim (p : LTSeries α) : p.length ≤ krullDim α := le_sSup ⟨_, rfl⟩\n\n"}
{"name":"Order.krullDim_eq_bot_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Iff (Eq (Order.krullDim α) Bot.bot) (IsEmpty α)","decl":"lemma krullDim_eq_bot_iff : krullDim α = ⊥ ↔ IsEmpty α := by\n  rw [eq_bot_iff, krullDim, iSup_le_iff]\n  simp only [le_bot_iff, WithBot.natCast_ne_bot, isEmpty_iff]\n  exact ⟨fun H x ↦ H ⟨0, fun _ ↦ x, by simp⟩, (· <| · 1)⟩\n\n"}
{"name":"Order.krullDim_nonneg_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Iff (LE.le 0 (Order.krullDim α)) (Nonempty α)","decl":"lemma krullDim_nonneg_iff : 0 ≤ krullDim α ↔ Nonempty α := by\n  rw [← not_iff_not, not_le, not_nonempty_iff, ← krullDim_eq_bot_iff, ← WithBot.lt_coe_bot,\n    bot_eq_zero, WithBot.coe_zero]\n\n"}
{"name":"Order.krullDim_eq_bot","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : IsEmpty α\n⊢ Eq (Order.krullDim α) Bot.bot","decl":"lemma krullDim_eq_bot [IsEmpty α] : krullDim α = ⊥ := krullDim_eq_bot_iff.mpr ‹_›\n\n"}
{"name":"Order.krullDim_eq_bot_of_isEmpty","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : IsEmpty α\n⊢ Eq (Order.krullDim α) Bot.bot","decl":"@[deprecated (since := \"2024-12-22\")] alias krullDim_eq_bot_of_isEmpty := krullDim_eq_bot\n\n"}
{"name":"Order.krullDim_nonneg","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ LE.le 0 (Order.krullDim α)","decl":"lemma krullDim_nonneg [Nonempty α] : 0 ≤ krullDim α := krullDim_nonneg_iff.mpr ‹_›\n\n"}
{"name":"Order.krullDim_nonneg_of_nonempty","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ LE.le 0 (Order.krullDim α)","decl":"@[deprecated (since := \"2024-12-22\")] alias krullDim_nonneg_of_nonempty := krullDim_nonneg\n\n"}
{"name":"Order.krullDim_nonpos_iff_forall_isMax","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Iff (LE.le (Order.krullDim α) 0) (∀ (x : α), IsMax x)","decl":"lemma krullDim_nonpos_iff_forall_isMax : krullDim α ≤ 0 ↔ ∀ x : α, IsMax x := by\n  simp only [krullDim, iSup_le_iff, isMax_iff_forall_not_lt]\n  refine ⟨fun H x y h ↦ (H ⟨1, ![x, y],\n    fun i ↦ by obtain rfl := Subsingleton.elim i 0; simpa⟩).not_lt (by simp), ?_⟩\n  · rintro H ⟨_ | n, l, h⟩\n    · simp\n    · cases H (l 0) (l 1) (h 0)\n\n"}
{"name":"Order.krullDim_nonpos_iff_forall_isMin","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Iff (LE.le (Order.krullDim α) 0) (∀ (x : α), IsMin x)","decl":"lemma krullDim_nonpos_iff_forall_isMin : krullDim α ≤ 0 ↔ ∀ x : α, IsMin x := by\n  simp only [krullDim_nonpos_iff_forall_isMax, IsMax, IsMin]\n  exact forall_swap\n\n"}
{"name":"Order.krullDim_le_one_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Iff (LE.le (Order.krullDim α) 1) (∀ (x : α), Or (IsMin x) (IsMax x))","decl":"lemma krullDim_le_one_iff : krullDim α ≤ 1 ↔ ∀ x : α, IsMin x ∨ IsMax x := by\n  rw [← not_iff_not]\n  simp_rw [isMax_iff_forall_not_lt, isMin_iff_forall_not_lt, krullDim, iSup_le_iff]\n  push_neg\n  constructor\n  · rintro ⟨⟨_ | _ | n, l, hl⟩, hl'⟩\n    iterate 2 · cases hl'.not_le (by simp)\n    exact ⟨l 1, ⟨l 0, hl 0⟩, l 2, hl 1⟩\n  · rintro ⟨x, ⟨y, hxy⟩, z, hzx⟩\n    exact ⟨⟨2, ![y, x, z], fun i ↦ by fin_cases i <;> simpa⟩, by simp⟩\n\n"}
{"name":"Order.krullDim_le_one_iff_forall_isMax","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\n⊢ Iff (LE.le (Order.krullDim α) 1) (∀ (x : α), Ne x Bot.bot → IsMax x)","decl":"lemma krullDim_le_one_iff_forall_isMax {α : Type*} [PartialOrder α] [OrderBot α] :\n    krullDim α ≤ 1 ↔ ∀ x : α, x ≠ ⊥ → IsMax x := by\n  simp [krullDim_le_one_iff, ← or_iff_not_imp_left]\n\n"}
{"name":"Order.krullDim_le_one_iff_forall_isMin","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\n⊢ Iff (LE.le (Order.krullDim α) 1) (∀ (x : α), Ne x Top.top → IsMin x)","decl":"lemma krullDim_le_one_iff_forall_isMin {α : Type*} [PartialOrder α] [OrderTop α] :\n    krullDim α ≤ 1 ↔ ∀ x : α, x ≠ ⊤ → IsMin x := by\n  simp [krullDim_le_one_iff, ← or_iff_not_imp_right]\n\n"}
{"name":"Order.krullDim_pos_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Iff (LT.lt 0 (Order.krullDim α)) (Exists fun x => Exists fun y => LT.lt x y)","decl":"lemma krullDim_pos_iff : 0 < krullDim α ↔ ∃ x y : α, x < y := by\n  rw [← not_iff_not]\n  push_neg\n  simp_rw [← isMax_iff_forall_not_lt, ← krullDim_nonpos_iff_forall_isMax]\n\n"}
{"name":"Order.one_le_krullDim_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Iff (LE.le 1 (Order.krullDim α)) (Exists fun x => Exists fun y => LT.lt x y)","decl":"lemma one_le_krullDim_iff : 1 ≤ krullDim α ↔ ∃ x y : α, x < y := by\n  rw [← krullDim_pos_iff, ← Nat.cast_zero, ← WithBot.add_one_le_iff, Nat.cast_zero, zero_add]\n\n"}
{"name":"Order.krullDim_nonpos_of_subsingleton","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Subsingleton α\n⊢ LE.le (Order.krullDim α) 0","decl":"lemma krullDim_nonpos_of_subsingleton [Subsingleton α] : krullDim α ≤ 0 := by\n  rw [krullDim_nonpos_iff_forall_isMax]\n  exact fun x y h ↦ (Subsingleton.elim x y).ge\n\n"}
{"name":"Order.krullDim_eq_zero_of_unique","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Unique α\n⊢ Eq (Order.krullDim α) 0","decl":"lemma krullDim_eq_zero_of_unique [Unique α] : krullDim α = 0 :=\n  le_antisymm krullDim_nonpos_of_subsingleton krullDim_nonneg\n\n"}
{"name":"Order.krullDim_eq_length_of_finiteDimensionalOrder","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : FiniteDimensionalOrder α\n⊢ Eq (Order.krullDim α) ↑(LTSeries.longestOf α).length","decl":"lemma krullDim_eq_length_of_finiteDimensionalOrder [FiniteDimensionalOrder α] :\n    krullDim α = (LTSeries.longestOf α).length :=\n  le_antisymm\n    (iSup_le <| fun _ ↦ WithBot.coe_le_coe.mpr <| WithTop.coe_le_coe.mpr <|\n      RelSeries.length_le_length_longestOf _ _) <|\n    le_iSup (fun (i : LTSeries _) ↦ (i.length : WithBot (WithTop ℕ))) <| LTSeries.longestOf _\n\n"}
{"name":"Order.krullDim_eq_top","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : InfiniteDimensionalOrder α\n⊢ Eq (Order.krullDim α) Top.top","decl":"lemma krullDim_eq_top [InfiniteDimensionalOrder α] :\n    krullDim α = ⊤ :=\n  le_antisymm le_top <| le_iSup_iff.mpr <| fun m hm ↦ match m, hm with\n  | ⊥, hm => False.elim <| by\n    haveI : Inhabited α := ⟨LTSeries.withLength _ 0 0⟩\n    exact not_le_of_lt (WithBot.bot_lt_coe _ : ⊥ < (0 : WithBot (WithTop ℕ))) <| hm default\n  | some ⊤, _ => le_refl _\n  | some (some m), hm => by\n    refine (not_lt_of_le (hm (LTSeries.withLength _ (m + 1))) ?_).elim\n    rw [WithBot.some_eq_coe, ← WithBot.coe_natCast, WithBot.coe_lt_coe,\n      WithTop.some_eq_coe, ← WithTop.coe_natCast, WithTop.coe_lt_coe]\n    simp\n\n"}
{"name":"Order.krullDim_eq_top_of_infiniteDimensionalOrder","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : InfiniteDimensionalOrder α\n⊢ Eq (Order.krullDim α) Top.top","decl":"@[deprecated (since := \"2024-12-22\")]\nalias krullDim_eq_top_of_infiniteDimensionalOrder := krullDim_eq_top\n\n"}
{"name":"Order.krullDim_eq_top_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Iff (Eq (Order.krullDim α) Top.top) (InfiniteDimensionalOrder α)","decl":"lemma krullDim_eq_top_iff : krullDim α = ⊤ ↔ InfiniteDimensionalOrder α := by\n  refine ⟨fun h ↦ ?_, fun _ ↦ krullDim_eq_top⟩\n  cases isEmpty_or_nonempty α\n  · simp [krullDim_eq_bot] at h\n  cases finiteDimensionalOrder_or_infiniteDimensionalOrder α\n  · rw [krullDim_eq_length_of_finiteDimensionalOrder] at h\n    cases h\n  · infer_instance\n\n"}
{"name":"Order.le_krullDim_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nn : Nat\n⊢ Iff (LE.le (↑n) (Order.krullDim α)) (Exists fun l => Eq l.length n)","decl":"lemma le_krullDim_iff {n : ℕ} : n ≤ krullDim α ↔ ∃ l : LTSeries α, l.length = n := by\n  cases isEmpty_or_nonempty α\n  · simp [krullDim_eq_bot]\n  cases finiteDimensionalOrder_or_infiniteDimensionalOrder α\n  · rw [krullDim_eq_length_of_finiteDimensionalOrder, Nat.cast_le]\n    constructor\n    · exact fun H ↦ ⟨(LTSeries.longestOf α).take ⟨_, Nat.lt_succ.mpr H⟩, rfl⟩\n    · exact fun ⟨l, hl⟩ ↦ hl ▸ l.longestOf_is_longest\n  · simpa [krullDim_eq_top] using Rel.InfiniteDimensional.exists_relSeries_with_length n\n\n"}
{"name":"Order.krullDim_eq_iSup_length","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ Eq (Order.krullDim α) ↑(iSup fun p => ↑p.length)","decl":"/-- A definition of krullDim for nonempty `α` that avoids `WithBot` -/\nlemma krullDim_eq_iSup_length [Nonempty α] :\n    krullDim α = ⨆ (p : LTSeries α), (p.length : ℕ∞) := by\n  unfold krullDim\n  rw [WithBot.coe_iSup (OrderTop.bddAbove _)]\n  rfl\n\n"}
{"name":"Order.krullDim_lt_coe_iff","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nn : Nat\n⊢ Iff (LT.lt (Order.krullDim α) ↑n) (∀ (l : LTSeries α), LT.lt l.length n)","decl":"lemma krullDim_lt_coe_iff {n : ℕ} : krullDim α < n ↔ ∀ l : LTSeries α, l.length < n := by\n  rw [krullDim, ← WithBot.coe_natCast]\n  cases' n with n\n  · rw [ENat.coe_zero, ← bot_eq_zero, WithBot.lt_coe_bot]\n    simp\n  · simp [WithBot.lt_add_one_iff, WithBot.coe_natCast, Nat.lt_succ]\n\n"}
{"name":"Order.krullDim_le_of_strictMono","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : StrictMono f\n⊢ LE.le (Order.krullDim α) (Order.krullDim β)","decl":"lemma krullDim_le_of_strictMono (f : α → β) (hf : StrictMono f) : krullDim α ≤ krullDim β :=\n  iSup_le fun p ↦ le_sSup ⟨p.map f hf, rfl⟩\n\n"}
{"name":"Order.krullDim_le_of_strictComono_and_surj","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : ∀ ⦃a b : α⦄, LT.lt (f a) (f b) → LT.lt a b\nhf' : Function.Surjective f\n⊢ LE.le (Order.krullDim β) (Order.krullDim α)","decl":"lemma krullDim_le_of_strictComono_and_surj\n    (f : α → β) (hf : ∀ ⦃a b⦄, f a < f b → a < b) (hf' : Function.Surjective f) :\n    krullDim β ≤ krullDim α :=\n  iSup_le fun p ↦ le_sSup ⟨p.comap _ hf hf', rfl⟩\n\n"}
{"name":"Order.krullDim_eq_of_orderIso","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : OrderIso α β\n⊢ Eq (Order.krullDim α) (Order.krullDim β)","decl":"lemma krullDim_eq_of_orderIso (f : α ≃o β) : krullDim α = krullDim β :=\n  le_antisymm (krullDim_le_of_strictMono _ f.strictMono) <|\n    krullDim_le_of_strictMono _ f.symm.strictMono\n\n"}
{"name":"Order.krullDim_orderDual","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Eq (Order.krullDim (OrderDual α)) (Order.krullDim α)","decl":"@[simp] lemma krullDim_orderDual : krullDim αᵒᵈ = krullDim α :=\n  le_antisymm (iSup_le fun i ↦ le_sSup ⟨i.reverse, rfl⟩) <|\n    iSup_le fun i ↦ le_sSup ⟨i.reverse, rfl⟩\n\n"}
{"name":"Order.height_le_krullDim","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ LE.le (↑(Order.height a)) (Order.krullDim α)","decl":"lemma height_le_krullDim (a : α) : height a ≤ krullDim α := by\n  have : Nonempty α := ⟨a⟩\n  rw [krullDim_eq_iSup_length]\n  simp only [WithBot.coe_le_coe, iSup_le_iff]\n  exact height_le fun p _ ↦ le_iSup_of_le p le_rfl\n\n"}
{"name":"Order.coheight_le_krullDim","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ LE.le (↑(Order.coheight a)) (Order.krullDim α)","decl":"lemma coheight_le_krullDim (a : α) : coheight a ≤ krullDim α := by\n  simpa using height_le_krullDim (α := αᵒᵈ) a\n\n"}
{"name":"Order.krullDim_eq_iSup_height_of_nonempty","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ Eq (Order.krullDim α) ↑(iSup fun a => Order.height a)","decl":"/--\nThe Krull dimension is the supremum of the elements' heights.\n\nThis version of the lemma assumes that `α` is nonempty. In this case, the coercion from `ℕ∞` to\n`WithBot ℕ∞` is on the outside fo the right-hand side, which is usually more convenient.\n\nIf `α` were empty, then `krullDim α = ⊥`. See `krullDim_eq_iSup_height` for the more general\nversion, with the coercion under the supremum.\n-/\nlemma krullDim_eq_iSup_height_of_nonempty [Nonempty α] : krullDim α = ↑(⨆ (a : α), height a) := by\n  apply le_antisymm\n  · apply iSup_le\n    intro p\n    suffices p.length ≤ ⨆ (a : α), height a by\n      exact (WithBot.unbot'_le_iff fun _ => this).mp this\n    apply le_iSup_of_le p.last (length_le_height_last (p := p))\n  · rw [WithBot.coe_iSup (by bddDefault)]\n    apply iSup_le\n    apply height_le_krullDim\n\n"}
{"name":"Order.krullDim_eq_iSup_coheight_of_nonempty","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ Eq (Order.krullDim α) ↑(iSup fun a => Order.coheight a)","decl":"/--\nThe Krull dimension is the supremum of the elements' coheights.\n\nThis version of the lemma assumes that `α` is nonempty. In this case, the coercion from `ℕ∞` to\n`WithBot ℕ∞` is on the outside of the right-hand side, which is usually more convenient.\n\nIf `α` were empty, then `krullDim α = ⊥`. See `krullDim_eq_iSup_coheight` for the more general\nversion, with the coercion under the supremum.\n-/\nlemma krullDim_eq_iSup_coheight_of_nonempty [Nonempty α] :\n    krullDim α = ↑(⨆ (a : α), coheight a) := by\n  simpa using krullDim_eq_iSup_height_of_nonempty (α := αᵒᵈ)\n\n"}
{"name":"Order.krullDim_eq_iSup_height_add_coheight_of_nonempty","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ Eq (Order.krullDim α) ↑(iSup fun a => HAdd.hAdd (Order.height a) (Order.coheight a))","decl":"/--\nThe Krull dimension is the supremum of the elements' height plus coheight.\n-/\nlemma krullDim_eq_iSup_height_add_coheight_of_nonempty [Nonempty α] :\n    krullDim α = ↑(⨆ (a : α), height a + coheight a) := by\n  apply le_antisymm\n  · rw [krullDim_eq_iSup_height_of_nonempty, WithBot.coe_le_coe]\n    apply ciSup_mono (by bddDefault) (by simp)\n  · wlog hnottop : krullDim α < ⊤\n    · simp_all\n    rw [krullDim_eq_iSup_length, WithBot.coe_le_coe]\n    apply iSup_le\n    intro a\n    have : height a < ⊤ := WithBot.coe_lt_coe.mp (lt_of_le_of_lt (height_le_krullDim a) hnottop)\n    have : coheight a < ⊤ := WithBot.coe_lt_coe.mp (lt_of_le_of_lt (coheight_le_krullDim a) hnottop)\n    cases hh : height a with\n    | top => simp_all\n    | coe n =>\n      cases hch : coheight a with\n      | top => simp_all\n      | coe m =>\n        obtain ⟨p₁, hlast, hlen₁⟩ := exists_series_of_height_eq_coe a hh\n        obtain ⟨p₂, hhead, hlen₂⟩ := exists_series_of_coheight_eq_coe a hch\n        apply le_iSup_of_le ((p₁.smash p₂) (by simp [*])) (by simp [*])\n\n"}
{"name":"Order.krullDim_eq_iSup_height","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Eq (Order.krullDim α) (iSup fun a => ↑(Order.height a))","decl":"/--\nThe Krull dimension is the supremum of the elements' heights.\n\nIf `α` is `Nonempty`, then `krullDim_eq_iSup_height_of_nonempty`, with the coercion from\n`ℕ∞` to `WithBot ℕ∞` outside the supremum, can be more convenient.\n-/\nlemma krullDim_eq_iSup_height : krullDim α = ⨆ (a : α), ↑(height a) := by\n  cases isEmpty_or_nonempty α with\n  | inl h => rw [krullDim_eq_bot, ciSup_of_empty]\n  | inr h => rw [krullDim_eq_iSup_height_of_nonempty, WithBot.coe_iSup (OrderTop.bddAbove _)]\n\n"}
{"name":"Order.krullDim_eq_iSup_coheight","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Eq (Order.krullDim α) (iSup fun a => ↑(Order.coheight a))","decl":"/--\nThe Krull dimension is the supremum of the elements' coheights.\n\nIf `α` is `Nonempty`, then `krullDim_eq_iSup_coheight_of_nonempty`, with the coercion from\n`ℕ∞` to `WithBot ℕ∞` outside the supremum, can be more convenient.\n-/\nlemma krullDim_eq_iSup_coheight : krullDim α = ⨆ (a : α), ↑(coheight a) := by\n  cases isEmpty_or_nonempty α with\n  | inl h => rw [krullDim_eq_bot, ciSup_of_empty]\n  | inr h => rw [krullDim_eq_iSup_coheight_of_nonempty, WithBot.coe_iSup (OrderTop.bddAbove _)]\n\n"}
{"name":"Order.height_top_eq_krullDim","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\n⊢ Eq (↑(Order.height Top.top)) (Order.krullDim α)","decl":"@[simp] -- not as useful as a simp lemma as it looks, due to the coe on the left\nlemma height_top_eq_krullDim [OrderTop α] : height (⊤ : α) = krullDim α := by\n  rw [krullDim_eq_iSup_length]\n  simp only [WithBot.coe_inj]\n  apply le_antisymm\n  · exact height_le fun p _ ↦ le_iSup_of_le p le_rfl\n  · exact iSup_le fun _ => length_le_height le_top\n\n"}
{"name":"Order.coheight_bot_eq_krullDim","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\n⊢ Eq (↑(Order.coheight Bot.bot)) (Order.krullDim α)","decl":"@[simp] -- not as useful as a simp lemma as it looks, due to the coe on the left\nlemma coheight_bot_eq_krullDim [OrderBot α] : coheight (⊥ : α) = krullDim α := by\n  rw [← krullDim_orderDual]\n  exact height_top_eq_krullDim (α := αᵒᵈ)\n\n"}
{"name":"Order.height_nat","module":"Mathlib.Order.KrullDimension","initialProofState":"n : Nat\n⊢ Eq (Order.height n) ↑n","decl":"@[simp] lemma height_nat (n : ℕ) : height n = n := by\n  induction n using Nat.strongRecOn with | ind n ih =>\n  apply le_antisymm\n  · apply height_le_coe_iff.mpr\n    simp +contextual only [ih, Nat.cast_lt, implies_true]\n  · exact length_le_height_last (p := LTSeries.range n)\n\n"}
{"name":"Order.coheight_of_noMaxOrder","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Eq (Order.coheight a) Top.top","decl":"@[simp] lemma coheight_of_noMaxOrder [NoMaxOrder α] (a : α) : coheight a = ⊤ := by\n  obtain ⟨f, hstrictmono⟩ := Nat.exists_strictMono ↑(Set.Ioi a)\n  apply coheight_eq_top_iff.mpr\n  intro m\n  use {length := m, toFun := fun i => if i = 0 then a else f i, step := ?step }\n  case h => simp [RelSeries.head]\n  case step =>\n    intro ⟨i, hi⟩\n    by_cases hzero : i = 0\n    · subst i\n      exact (f 1).prop\n    · suffices f i < f (i + 1) by simp [Fin.ext_iff, hzero, this]\n      apply hstrictmono\n      omega\n\n"}
{"name":"Order.height_of_noMinOrder","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\na : α\n⊢ Eq (Order.height a) Top.top","decl":"@[simp] lemma height_of_noMinOrder [NoMinOrder α] (a : α) : height a = ⊤ :=\n  -- Implementation note: Here it's a bit easier to define the coheight variant first\n  coheight_of_noMaxOrder (α := αᵒᵈ) a\n\n"}
{"name":"Order.krullDim_of_noMaxOrder","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : Nonempty α\ninst✝ : NoMaxOrder α\n⊢ Eq (Order.krullDim α) Top.top","decl":"@[simp] lemma krullDim_of_noMaxOrder [Nonempty α] [NoMaxOrder α] : krullDim α = ⊤ := by\n  simp [krullDim_eq_iSup_coheight, coheight_of_noMaxOrder]\n\n"}
{"name":"Order.krullDim_of_noMinOrder","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : Nonempty α\ninst✝ : NoMinOrder α\n⊢ Eq (Order.krullDim α) Top.top","decl":"@[simp] lemma krullDim_of_noMinOrder [Nonempty α] [NoMinOrder α] : krullDim α = ⊤ := by\n  simp [krullDim_eq_iSup_height, height_of_noMinOrder]\n\n"}
{"name":"Order.coheight_nat","module":"Mathlib.Order.KrullDimension","initialProofState":"n : Nat\n⊢ Eq (Order.coheight n) Top.top","decl":"lemma coheight_nat (n : ℕ) : coheight n = ⊤ := coheight_of_noMaxOrder ..\n\n"}
{"name":"Order.krullDim_nat","module":"Mathlib.Order.KrullDimension","initialProofState":"⊢ Eq (Order.krullDim Nat) Top.top","decl":"lemma krullDim_nat : krullDim ℕ = ⊤ := krullDim_of_noMaxOrder ..\n\n"}
{"name":"Order.height_int","module":"Mathlib.Order.KrullDimension","initialProofState":"n : Int\n⊢ Eq (Order.height n) Top.top","decl":"lemma height_int (n : ℤ) : height n = ⊤ := height_of_noMinOrder ..\n\n"}
{"name":"Order.coheight_int","module":"Mathlib.Order.KrullDimension","initialProofState":"n : Int\n⊢ Eq (Order.coheight n) Top.top","decl":"lemma coheight_int (n : ℤ) : coheight n = ⊤ := coheight_of_noMaxOrder ..\n\n"}
{"name":"Order.krullDim_int","module":"Mathlib.Order.KrullDimension","initialProofState":"⊢ Eq (Order.krullDim Int) Top.top","decl":"lemma krullDim_int : krullDim ℤ = ⊤ := krullDim_of_noMaxOrder ..\n\n"}
{"name":"Order.height_coe_withBot","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ Eq (Order.height ↑x) (HAdd.hAdd (Order.height x) 1)","decl":"@[simp] lemma height_coe_withBot (x : α) : height (x : WithBot α) = height x + 1 := by\n  apply le_antisymm\n  · apply height_le\n    intro p hlast\n    wlog hlenpos : p.length ≠ 0\n    · simp_all\n    -- essentially p' := (p.drop 1).map unbot\n    let p' : LTSeries α := {\n      length := p.length - 1\n      toFun := fun ⟨i, hi⟩ => (p ⟨i+1, by omega⟩).unbot (by\n        apply LT.lt.ne_bot (a := p.head)\n        apply p.strictMono\n        exact compare_gt_iff_gt.mp rfl)\n      step := fun i => by simpa [WithBot.unbot_lt_iff] using p.step ⟨i + 1, by omega⟩ }\n    have hlast' : p'.last = x := by\n      simp only [p', RelSeries.last, Fin.val_last, WithBot.unbot_eq_iff, ← hlast, Fin.last]\n      congr\n      omega\n    suffices p'.length ≤ height p'.last by\n      simpa [p', hlast'] using this\n    apply length_le_height_last\n  · rw [height_add_const]\n    apply iSup₂_le\n    intro p hlast\n    let p' := (p.map _ WithBot.coe_strictMono).cons ⊥ (by simp)\n    apply le_iSup₂_of_le p' (by simp [p', hlast]) (by simp [p'])\n\n"}
{"name":"Order.coheight_coe_withTop","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ Eq (Order.coheight ↑x) (HAdd.hAdd (Order.coheight x) 1)","decl":"@[simp] lemma coheight_coe_withTop (x : α) : coheight (x : WithTop α) = coheight x + 1 :=\n  height_coe_withBot (α := αᵒᵈ) x\n\n"}
{"name":"Order.height_coe_withTop","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ Eq (Order.height ↑x) (Order.height x)","decl":"@[simp] lemma height_coe_withTop (x : α) : height (x : WithTop α) = height x := by\n  apply le_antisymm\n  · apply height_le\n    intro p hlast\n    -- essentially p' := p.map untop\n    let p' : LTSeries α := {\n      length := p.length\n      toFun := fun i => (p i).untop (by\n        apply WithTop.lt_top_iff_ne_top.mp\n        apply lt_of_le_of_lt\n        · exact p.monotone (Fin.le_last _)\n        · rw [RelSeries.last] at hlast\n          simp [hlast])\n      step := fun i => by simpa only [WithTop.untop_lt_iff, WithTop.coe_untop] using p.step i }\n    have hlast' : p'.last = x := by\n      simp only [p', RelSeries.last, Fin.val_last, WithTop.untop_eq_iff, ← hlast]\n    suffices p'.length ≤ height p'.last by\n      rw [hlast'] at this\n      simpa [p'] using this\n    apply length_le_height_last\n  · apply height_le\n    intro p hlast\n    let p' := p.map _ WithTop.coe_strictMono\n    apply le_iSup₂_of_le p' (by simp [p', hlast]) (by simp [p'])\n\n"}
{"name":"Order.coheight_coe_withBot","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ Eq (Order.coheight ↑x) (Order.coheight x)","decl":"@[simp] lemma coheight_coe_withBot (x : α) : coheight (x : WithBot α) = coheight x :=\n  height_coe_withTop (α := αᵒᵈ) x\n\n"}
{"name":"Order.krullDim_WithTop","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ Eq (Order.krullDim (WithTop α)) (HAdd.hAdd (Order.krullDim α) 1)","decl":"@[simp] lemma krullDim_WithTop [Nonempty α] : krullDim (WithTop α) = krullDim α + 1 := by\n  rw [← height_top_eq_krullDim, krullDim_eq_iSup_height_of_nonempty, height_eq_iSup_lt_height]\n  norm_cast\n  simp_rw [WithTop.lt_top_iff_ne_top]\n  rw [ENat.iSup_add, iSup_subtype']\n  symm\n  apply Equiv.withTopSubtypeNe.symm.iSup_congr\n  simp\n\n"}
{"name":"Order.krullDim_withBot","module":"Mathlib.Order.KrullDimension","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ Eq (Order.krullDim (WithBot α)) (HAdd.hAdd (Order.krullDim α) 1)","decl":"@[simp] lemma krullDim_withBot [Nonempty α] : krullDim (WithBot α) = krullDim α + 1 := by\n  conv_lhs => rw [← krullDim_orderDual]\n  conv_rhs => rw [← krullDim_orderDual]\n  exact krullDim_WithTop (α := αᵒᵈ)\n\n"}
{"name":"Order.krullDim_enat","module":"Mathlib.Order.KrullDimension","initialProofState":"⊢ Eq (Order.krullDim ENat) Top.top","decl":"@[simp]\nlemma krullDim_enat : krullDim ℕ∞ = ⊤ := by\n  show (krullDim (WithTop ℕ) = ⊤)\n  simp only [krullDim_WithTop, krullDim_nat]\n  rfl\n\n"}
{"name":"Order.height_enat","module":"Mathlib.Order.KrullDimension","initialProofState":"n : ENat\n⊢ Eq (Order.height n) n","decl":"@[simp]\nlemma height_enat (n : ℕ∞) : height n = n := by\n  cases n with\n  | top => simp only [← WithBot.coe_eq_coe, height_top_eq_krullDim, krullDim_enat, WithBot.coe_top]\n  | coe n => exact (height_coe_withTop _).trans (height_nat _)\n\n"}
{"name":"Order.coheight_coe_enat","module":"Mathlib.Order.KrullDimension","initialProofState":"n : Nat\n⊢ Eq (Order.coheight ↑n) Top.top","decl":"@[simp]\nlemma coheight_coe_enat (n : ℕ) : coheight (n : ℕ∞) = ⊤ := by\n  apply (coheight_coe_withTop _).trans\n  simp only [Nat.cast_id, coheight_nat, top_add]\n\n"}
