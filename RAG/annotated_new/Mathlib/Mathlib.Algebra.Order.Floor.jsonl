{"name":"FloorSemiring.gc_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_4\ninst✝ : OrderedSemiring α\nself : FloorSemiring α\na : α\nn : Nat\nha : LE.le 0 a\n⊢ Iff (LE.le n (FloorSemiring.floor a)) (LE.le (↑n) a)","decl":"/-- A `FloorSemiring` is an ordered semiring over `α` with a function\n`floor : α → ℕ` satisfying `∀ (n : ℕ) (x : α), n ≤ ⌊x⌋ ↔ (n : α) ≤ x)`.\nNote that many lemmas require a `LinearOrder`. Please see the above `TODO`. -/\nclass FloorSemiring (α) [OrderedSemiring α] where\n  /-- `FloorSemiring.floor a` computes the greatest natural `n` such that `(n : α) ≤ a`. -/\n  floor : α → ℕ\n  /-- `FloorSemiring.ceil a` computes the least natural `n` such that `a ≤ (n : α)`. -/\n  ceil : α → ℕ\n  /-- `FloorSemiring.floor` of a negative element is zero. -/\n  floor_of_neg {a : α} (ha : a < 0) : floor a = 0\n  /-- A natural number `n` is smaller than `FloorSemiring.floor a` iff its coercion to `α` is\n  smaller than `a`. -/\n  gc_floor {a : α} {n : ℕ} (ha : 0 ≤ a) : n ≤ floor a ↔ (n : α) ≤ a\n  /-- `FloorSemiring.ceil` is the lower adjoint of the coercion `↑ : ℕ → α`. -/\n  gc_ceil : GaloisConnection ceil (↑)\n\n"}
{"name":"FloorSemiring.gc_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_4\ninst✝ : OrderedSemiring α\nself : FloorSemiring α\n⊢ GaloisConnection FloorSemiring.ceil Nat.cast","decl":"/-- A `FloorSemiring` is an ordered semiring over `α` with a function\n`floor : α → ℕ` satisfying `∀ (n : ℕ) (x : α), n ≤ ⌊x⌋ ↔ (n : α) ≤ x)`.\nNote that many lemmas require a `LinearOrder`. Please see the above `TODO`. -/\nclass FloorSemiring (α) [OrderedSemiring α] where\n  /-- `FloorSemiring.floor a` computes the greatest natural `n` such that `(n : α) ≤ a`. -/\n  floor : α → ℕ\n  /-- `FloorSemiring.ceil a` computes the least natural `n` such that `a ≤ (n : α)`. -/\n  ceil : α → ℕ\n  /-- `FloorSemiring.floor` of a negative element is zero. -/\n  floor_of_neg {a : α} (ha : a < 0) : floor a = 0\n  /-- A natural number `n` is smaller than `FloorSemiring.floor a` iff its coercion to `α` is\n  smaller than `a`. -/\n  gc_floor {a : α} {n : ℕ} (ha : 0 ≤ a) : n ≤ floor a ↔ (n : α) ≤ a\n  /-- `FloorSemiring.ceil` is the lower adjoint of the coercion `↑ : ℕ → α`. -/\n  gc_ceil : GaloisConnection ceil (↑)\n\n"}
{"name":"FloorSemiring.floor_of_neg","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_4\ninst✝ : OrderedSemiring α\nself : FloorSemiring α\na : α\nha : LT.lt a 0\n⊢ Eq (FloorSemiring.floor a) 0","decl":"/-- A `FloorSemiring` is an ordered semiring over `α` with a function\n`floor : α → ℕ` satisfying `∀ (n : ℕ) (x : α), n ≤ ⌊x⌋ ↔ (n : α) ≤ x)`.\nNote that many lemmas require a `LinearOrder`. Please see the above `TODO`. -/\nclass FloorSemiring (α) [OrderedSemiring α] where\n  /-- `FloorSemiring.floor a` computes the greatest natural `n` such that `(n : α) ≤ a`. -/\n  floor : α → ℕ\n  /-- `FloorSemiring.ceil a` computes the least natural `n` such that `a ≤ (n : α)`. -/\n  ceil : α → ℕ\n  /-- `FloorSemiring.floor` of a negative element is zero. -/\n  floor_of_neg {a : α} (ha : a < 0) : floor a = 0\n  /-- A natural number `n` is smaller than `FloorSemiring.floor a` iff its coercion to `α` is\n  smaller than `a`. -/\n  gc_floor {a : α} {n : ℕ} (ha : 0 ≤ a) : n ≤ floor a ↔ (n : α) ≤ a\n  /-- `FloorSemiring.ceil` is the lower adjoint of the coercion `↑ : ℕ → α`. -/\n  gc_ceil : GaloisConnection ceil (↑)\n\n"}
{"name":"Nat.floor_nat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"⊢ Eq Nat.floor id","decl":"@[simp]\ntheorem floor_nat : (Nat.floor : ℕ → ℕ) = id :=\n  rfl\n\n"}
{"name":"Nat.ceil_nat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"⊢ Eq Nat.ceil id","decl":"@[simp]\ntheorem ceil_nat : (Nat.ceil : ℕ → ℕ) = id :=\n  rfl\n\n"}
{"name":"Nat.le_floor_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : OrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\nha : LE.le 0 a\n⊢ Iff (LE.le n (Nat.floor a)) (LE.le (↑n) a)","decl":"theorem le_floor_iff (ha : 0 ≤ a) : n ≤ ⌊a⌋₊ ↔ (n : α) ≤ a :=\n  FloorSemiring.gc_floor ha\n\n"}
{"name":"Nat.le_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : OrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\nh : LE.le (↑n) a\n⊢ LE.le n (Nat.floor a)","decl":"theorem le_floor (h : (n : α) ≤ a) : n ≤ ⌊a⌋₊ :=\n  (le_floor_iff <| n.cast_nonneg.trans h).2 h\n\n"}
{"name":"Nat.gc_ceil_coe","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : OrderedSemiring α\ninst✝ : FloorSemiring α\n⊢ GaloisConnection Nat.ceil Nat.cast","decl":"theorem gc_ceil_coe : GaloisConnection (ceil : α → ℕ) (↑) :=\n  FloorSemiring.gc_ceil\n\n"}
{"name":"Nat.ceil_le","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : OrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\n⊢ Iff (LE.le (Nat.ceil a) n) (LE.le a ↑n)","decl":"@[simp]\ntheorem ceil_le : ⌈a⌉₊ ≤ n ↔ a ≤ n :=\n  gc_ceil_coe _ _\n\n"}
{"name":"Nat.floor_lt","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\nha : LE.le 0 a\n⊢ Iff (LT.lt (Nat.floor a) n) (LT.lt a ↑n)","decl":"theorem floor_lt (ha : 0 ≤ a) : ⌊a⌋₊ < n ↔ a < n :=\n  lt_iff_lt_of_le_iff_le <| le_floor_iff ha\n\n"}
{"name":"Nat.floor_lt_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nha : LE.le 0 a\n⊢ Iff (LT.lt (Nat.floor a) 1) (LT.lt a 1)","decl":"theorem floor_lt_one (ha : 0 ≤ a) : ⌊a⌋₊ < 1 ↔ a < 1 :=\n  (floor_lt ha).trans <| by rw [Nat.cast_one]\n\n"}
{"name":"Nat.lt_of_floor_lt","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\nh : LT.lt (Nat.floor a) n\n⊢ LT.lt a ↑n","decl":"theorem lt_of_floor_lt (h : ⌊a⌋₊ < n) : a < n :=\n  lt_of_not_le fun h' => (le_floor h').not_lt h\n\n"}
{"name":"Nat.lt_one_of_floor_lt_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nh : LT.lt (Nat.floor a) 1\n⊢ LT.lt a 1","decl":"theorem lt_one_of_floor_lt_one (h : ⌊a⌋₊ < 1) : a < 1 := mod_cast lt_of_floor_lt h\n\n"}
{"name":"Nat.floor_le","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nha : LE.le 0 a\n⊢ LE.le (↑(Nat.floor a)) a","decl":"theorem floor_le (ha : 0 ≤ a) : (⌊a⌋₊ : α) ≤ a :=\n  (le_floor_iff ha).1 le_rfl\n\n"}
{"name":"Nat.lt_succ_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\n⊢ LT.lt a ↑(Nat.floor a).succ","decl":"theorem lt_succ_floor (a : α) : a < ⌊a⌋₊.succ :=\n  lt_of_floor_lt <| Nat.lt_succ_self _\n\n"}
{"name":"Nat.lt_floor_add_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\n⊢ LT.lt a (HAdd.hAdd (↑(Nat.floor a)) 1)","decl":"@[bound]\ntheorem lt_floor_add_one (a : α) : a < ⌊a⌋₊ + 1 := by simpa using lt_succ_floor a\n\n"}
{"name":"Nat.floor_natCast","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\nn : Nat\n⊢ Eq (Nat.floor ↑n) n","decl":"@[simp]\ntheorem floor_natCast (n : ℕ) : ⌊(n : α)⌋₊ = n :=\n  eq_of_forall_le_iff fun a => by\n    rw [le_floor_iff, Nat.cast_le]\n    exact n.cast_nonneg\n\n"}
{"name":"Nat.floor_zero","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\n⊢ Eq (Nat.floor 0) 0","decl":"@[simp]\ntheorem floor_zero : ⌊(0 : α)⌋₊ = 0 := by rw [← Nat.cast_zero, floor_natCast]\n\n"}
{"name":"Nat.floor_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\n⊢ Eq (Nat.floor 1) 1","decl":"@[simp]\ntheorem floor_one : ⌊(1 : α)⌋₊ = 1 := by rw [← Nat.cast_one, floor_natCast]\n\n"}
{"name":"Nat.floor_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : FloorSemiring α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Nat.floor (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem floor_ofNat (n : ℕ) [n.AtLeastTwo] : ⌊(ofNat(n) : α)⌋₊ = ofNat(n) :=\n  Nat.floor_natCast _\n\n"}
{"name":"Nat.floor_of_nonpos","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nha : LE.le a 0\n⊢ Eq (Nat.floor a) 0","decl":"theorem floor_of_nonpos (ha : a ≤ 0) : ⌊a⌋₊ = 0 :=\n  ha.lt_or_eq.elim FloorSemiring.floor_of_neg <| by\n    rintro rfl\n    exact floor_zero\n\n"}
{"name":"Nat.floor_mono","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\n⊢ Monotone Nat.floor","decl":"theorem floor_mono : Monotone (floor : α → ℕ) := fun a b h => by\n  obtain ha | ha := le_total a 0\n  · rw [floor_of_nonpos ha]\n    exact Nat.zero_le _\n  · exact le_floor ((floor_le ha).trans h)\n\n"}
{"name":"Nat.floor_le_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na b : α\nhab : LE.le a b\n⊢ LE.le (Nat.floor a) (Nat.floor b)","decl":"@[gcongr, bound] lemma floor_le_floor (hab : a ≤ b) : ⌊a⌋₊ ≤ ⌊b⌋₊ := floor_mono hab\n\n"}
{"name":"Nat.le_floor_iff'","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\nhn : Ne n 0\n⊢ Iff (LE.le n (Nat.floor a)) (LE.le (↑n) a)","decl":"theorem le_floor_iff' (hn : n ≠ 0) : n ≤ ⌊a⌋₊ ↔ (n : α) ≤ a := by\n  obtain ha | ha := le_total a 0\n  · rw [floor_of_nonpos ha]\n    exact\n      iff_of_false (Nat.pos_of_ne_zero hn).not_le\n        (not_le_of_lt <| ha.trans_lt <| cast_pos.2 <| Nat.pos_of_ne_zero hn)\n  · exact le_floor_iff ha\n\n"}
{"name":"Nat.one_le_floor_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\nx : α\n⊢ Iff (LE.le 1 (Nat.floor x)) (LE.le 1 x)","decl":"@[simp]\ntheorem one_le_floor_iff (x : α) : 1 ≤ ⌊x⌋₊ ↔ 1 ≤ x :=\n  mod_cast @le_floor_iff' α _ _ x 1 one_ne_zero\n\n"}
{"name":"Nat.floor_lt'","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\nhn : Ne n 0\n⊢ Iff (LT.lt (Nat.floor a) n) (LT.lt a ↑n)","decl":"theorem floor_lt' (hn : n ≠ 0) : ⌊a⌋₊ < n ↔ a < n :=\n  lt_iff_lt_of_le_iff_le <| le_floor_iff' hn\n\n"}
{"name":"Nat.floor_pos","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\n⊢ Iff (LT.lt 0 (Nat.floor a)) (LE.le 1 a)","decl":"theorem floor_pos : 0 < ⌊a⌋₊ ↔ 1 ≤ a := by\n  -- Porting note: broken `convert le_floor_iff' Nat.one_ne_zero`\n  rw [Nat.lt_iff_add_one_le, zero_add, le_floor_iff' Nat.one_ne_zero, cast_one]\n\n"}
{"name":"Nat.pos_of_floor_pos","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nh : LT.lt 0 (Nat.floor a)\n⊢ LT.lt 0 a","decl":"theorem pos_of_floor_pos (h : 0 < ⌊a⌋₊) : 0 < a :=\n  (le_or_lt a 0).resolve_left fun ha => lt_irrefl 0 <| by rwa [floor_of_nonpos ha] at h\n\n"}
{"name":"Nat.lt_of_lt_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\nh : LT.lt n (Nat.floor a)\n⊢ LT.lt (↑n) a","decl":"theorem lt_of_lt_floor (h : n < ⌊a⌋₊) : ↑n < a :=\n  (Nat.cast_lt.2 h).trans_le <| floor_le (pos_of_floor_pos <| (Nat.zero_le n).trans_lt h).le\n\n"}
{"name":"Nat.floor_le_of_le","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\nh : LE.le a ↑n\n⊢ LE.le (Nat.floor a) n","decl":"theorem floor_le_of_le (h : a ≤ n) : ⌊a⌋₊ ≤ n :=\n  le_imp_le_iff_lt_imp_lt.2 lt_of_lt_floor h\n\n"}
{"name":"Nat.floor_le_one_of_le_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nh : LE.le a 1\n⊢ LE.le (Nat.floor a) 1","decl":"theorem floor_le_one_of_le_one (h : a ≤ 1) : ⌊a⌋₊ ≤ 1 :=\n  floor_le_of_le <| h.trans_eq <| Nat.cast_one.symm\n\n"}
{"name":"Nat.floor_eq_zero","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\n⊢ Iff (Eq (Nat.floor a) 0) (LT.lt a 1)","decl":"@[simp]\ntheorem floor_eq_zero : ⌊a⌋₊ = 0 ↔ a < 1 := by\n  rw [← lt_one_iff, ← @cast_one α]\n  exact floor_lt' Nat.one_ne_zero\n\n"}
{"name":"Nat.floor_eq_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\nha : LE.le 0 a\n⊢ Iff (Eq (Nat.floor a) n) (And (LE.le (↑n) a) (LT.lt a (HAdd.hAdd (↑n) 1)))","decl":"theorem floor_eq_iff (ha : 0 ≤ a) : ⌊a⌋₊ = n ↔ ↑n ≤ a ∧ a < ↑n + 1 := by\n  rw [← le_floor_iff ha, ← Nat.cast_one, ← Nat.cast_add, ← floor_lt ha, Nat.lt_add_one_iff,\n    le_antisymm_iff, and_comm]\n\n"}
{"name":"Nat.floor_eq_iff'","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\nhn : Ne n 0\n⊢ Iff (Eq (Nat.floor a) n) (And (LE.le (↑n) a) (LT.lt a (HAdd.hAdd (↑n) 1)))","decl":"theorem floor_eq_iff' (hn : n ≠ 0) : ⌊a⌋₊ = n ↔ ↑n ≤ a ∧ a < ↑n + 1 := by\n  rw [← le_floor_iff' hn, ← Nat.cast_one, ← Nat.cast_add, ← floor_lt' (Nat.add_one_ne_zero n),\n    Nat.lt_add_one_iff, le_antisymm_iff, and_comm]\n\n"}
{"name":"Nat.floor_eq_on_Ico","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\nn : Nat\na : α\na✝ : Membership.mem (Set.Ico (↑n) (HAdd.hAdd (↑n) 1)) a\n⊢ Eq (Nat.floor a) n","decl":"theorem floor_eq_on_Ico (n : ℕ) : ∀ a ∈ (Set.Ico n (n + 1) : Set α), ⌊a⌋₊ = n := fun _ ⟨h₀, h₁⟩ =>\n  (floor_eq_iff <| n.cast_nonneg.trans h₀).mpr ⟨h₀, h₁⟩\n\n"}
{"name":"Nat.floor_eq_on_Ico'","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\nn : Nat\na : α\na✝ : Membership.mem (Set.Ico (↑n) (HAdd.hAdd (↑n) 1)) a\n⊢ Eq ↑(Nat.floor a) ↑n","decl":"theorem floor_eq_on_Ico' (n : ℕ) :\n    ∀ a ∈ (Set.Ico n (n + 1) : Set α), (⌊a⌋₊ : α) = n :=\n  fun x hx => mod_cast floor_eq_on_Ico n x hx\n\n"}
{"name":"Nat.preimage_floor_zero","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\n⊢ Eq (Set.preimage Nat.floor (Singleton.singleton 0)) (Set.Iio 1)","decl":"@[simp]\ntheorem preimage_floor_zero : (floor : α → ℕ) ⁻¹' {0} = Iio 1 :=\n  ext fun _ => floor_eq_zero\n\n-- Porting note: in mathlib3 there was no need for the type annotation in `(n:α)`\n"}
{"name":"Nat.preimage_floor_of_ne_zero","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\nn : Nat\nhn : Ne n 0\n⊢ Eq (Set.preimage Nat.floor (Singleton.singleton n)) (Set.Ico (↑n) (HAdd.hAdd (↑n) 1))","decl":"theorem preimage_floor_of_ne_zero {n : ℕ} (hn : n ≠ 0) :\n    (floor : α → ℕ) ⁻¹' {n} = Ico (n : α) (n + 1) :=\n  ext fun _ => floor_eq_iff' hn\n\n"}
{"name":"Nat.lt_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\n⊢ Iff (LT.lt n (Nat.ceil a)) (LT.lt (↑n) a)","decl":"theorem lt_ceil : n < ⌈a⌉₊ ↔ (n : α) < a :=\n  lt_iff_lt_of_le_iff_le ceil_le\n\n"}
{"name":"Nat.add_one_le_ceil_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\n⊢ Iff (LE.le (HAdd.hAdd n 1) (Nat.ceil a)) (LT.lt (↑n) a)","decl":"theorem add_one_le_ceil_iff : n + 1 ≤ ⌈a⌉₊ ↔ (n : α) < a := by\n  rw [← Nat.lt_ceil, Nat.add_one_le_iff]\n\n"}
{"name":"Nat.one_le_ceil_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\n⊢ Iff (LE.le 1 (Nat.ceil a)) (LT.lt 0 a)","decl":"@[simp]\ntheorem one_le_ceil_iff : 1 ≤ ⌈a⌉₊ ↔ 0 < a := by\n  rw [← zero_add 1, Nat.add_one_le_ceil_iff, Nat.cast_zero]\n\n"}
{"name":"Nat.ceil_le_floor_add_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\n⊢ LE.le (Nat.ceil a) (HAdd.hAdd (Nat.floor a) 1)","decl":"@[bound]\ntheorem ceil_le_floor_add_one (a : α) : ⌈a⌉₊ ≤ ⌊a⌋₊ + 1 := by\n  rw [ceil_le, Nat.cast_add, Nat.cast_one]\n  exact (lt_floor_add_one a).le\n\n"}
{"name":"Nat.le_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\n⊢ LE.le a ↑(Nat.ceil a)","decl":"@[bound]\ntheorem le_ceil (a : α) : a ≤ ⌈a⌉₊ :=\n  ceil_le.1 le_rfl\n\n"}
{"name":"Nat.ceil_intCast","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_4\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorSemiring α\nz : Int\n⊢ Eq (Nat.ceil ↑z) z.toNat","decl":"@[simp]\ntheorem ceil_intCast {α : Type*} [LinearOrderedRing α] [FloorSemiring α] (z : ℤ) :\n    ⌈(z : α)⌉₊ = z.toNat :=\n  eq_of_forall_ge_iff fun a => by\n    simp only [ceil_le, Int.toNat_le]\n    norm_cast\n\n"}
{"name":"Nat.ceil_natCast","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\nn : Nat\n⊢ Eq (Nat.ceil ↑n) n","decl":"@[simp]\ntheorem ceil_natCast (n : ℕ) : ⌈(n : α)⌉₊ = n :=\n  eq_of_forall_ge_iff fun a => by rw [ceil_le, cast_le]\n\n"}
{"name":"Nat.ceil_mono","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\n⊢ Monotone Nat.ceil","decl":"theorem ceil_mono : Monotone (ceil : α → ℕ) :=\n  gc_ceil_coe.monotone_l\n\n"}
{"name":"Nat.ceil_le_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na b : α\nhab : LE.le a b\n⊢ LE.le (Nat.ceil a) (Nat.ceil b)","decl":"@[gcongr, bound] lemma ceil_le_ceil (hab : a ≤ b) : ⌈a⌉₊ ≤ ⌈b⌉₊ := ceil_mono hab\n\n"}
{"name":"Nat.ceil_zero","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\n⊢ Eq (Nat.ceil 0) 0","decl":"@[simp]\ntheorem ceil_zero : ⌈(0 : α)⌉₊ = 0 := by rw [← Nat.cast_zero, ceil_natCast]\n\n"}
{"name":"Nat.ceil_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\n⊢ Eq (Nat.ceil 1) 1","decl":"@[simp]\ntheorem ceil_one : ⌈(1 : α)⌉₊ = 1 := by rw [← Nat.cast_one, ceil_natCast]\n\n"}
{"name":"Nat.ceil_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : FloorSemiring α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Nat.ceil (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem ceil_ofNat (n : ℕ) [n.AtLeastTwo] : ⌈(ofNat(n) : α)⌉₊ = ofNat(n) := ceil_natCast n\n\n"}
{"name":"Nat.ceil_eq_zero","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\n⊢ Iff (Eq (Nat.ceil a) 0) (LE.le a 0)","decl":"@[simp]\ntheorem ceil_eq_zero : ⌈a⌉₊ = 0 ↔ a ≤ 0 := by rw [← Nat.le_zero, ceil_le, Nat.cast_zero]\n\n"}
{"name":"Nat.ceil_pos","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\n⊢ Iff (LT.lt 0 (Nat.ceil a)) (LT.lt 0 a)","decl":"@[simp]\ntheorem ceil_pos : 0 < ⌈a⌉₊ ↔ 0 < a := by rw [lt_ceil, cast_zero]\n\n"}
{"name":"Nat.lt_of_ceil_lt","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\nh : LT.lt (Nat.ceil a) n\n⊢ LT.lt a ↑n","decl":"theorem lt_of_ceil_lt (h : ⌈a⌉₊ < n) : a < n :=\n  (le_ceil a).trans_lt (Nat.cast_lt.2 h)\n\n"}
{"name":"Nat.le_of_ceil_le","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\nh : LE.le (Nat.ceil a) n\n⊢ LE.le a ↑n","decl":"theorem le_of_ceil_le (h : ⌈a⌉₊ ≤ n) : a ≤ n :=\n  (le_ceil a).trans (Nat.cast_le.2 h)\n\n"}
{"name":"Nat.floor_le_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\n⊢ LE.le (Nat.floor a) (Nat.ceil a)","decl":"@[bound]\ntheorem floor_le_ceil (a : α) : ⌊a⌋₊ ≤ ⌈a⌉₊ := by\n  obtain ha | ha := le_total a 0\n  · rw [floor_of_nonpos ha]\n    exact Nat.zero_le _\n  · exact cast_le.1 ((floor_le ha).trans <| le_ceil _)\n\n"}
{"name":"Nat.floor_lt_ceil_of_lt_of_pos","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na b : α\nh : LT.lt a b\nh' : LT.lt 0 b\n⊢ LT.lt (Nat.floor a) (Nat.ceil b)","decl":"theorem floor_lt_ceil_of_lt_of_pos {a b : α} (h : a < b) (h' : 0 < b) : ⌊a⌋₊ < ⌈b⌉₊ := by\n  rcases le_or_lt 0 a with (ha | ha)\n  · rw [floor_lt ha]\n    exact h.trans_le (le_ceil _)\n  · rwa [floor_of_nonpos ha.le, lt_ceil, Nat.cast_zero]\n\n"}
{"name":"Nat.ceil_eq_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nn : Nat\nhn : Ne n 0\n⊢ Iff (Eq (Nat.ceil a) n) (And (LT.lt (↑(HSub.hSub n 1)) a) (LE.le a ↑n))","decl":"theorem ceil_eq_iff (hn : n ≠ 0) : ⌈a⌉₊ = n ↔ ↑(n - 1) < a ∧ a ≤ n := by\n  rw [← ceil_le, ← not_le, ← ceil_le, not_le,\n    tsub_lt_iff_right (Nat.add_one_le_iff.2 (pos_iff_ne_zero.2 hn)), Nat.lt_add_one_iff,\n    le_antisymm_iff, and_comm]\n\n"}
{"name":"Nat.preimage_ceil_zero","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\n⊢ Eq (Set.preimage Nat.ceil (Singleton.singleton 0)) (Set.Iic 0)","decl":"@[simp]\ntheorem preimage_ceil_zero : (Nat.ceil : α → ℕ) ⁻¹' {0} = Iic 0 :=\n  ext fun _ => ceil_eq_zero\n\n-- Porting note: in mathlib3 there was no need for the type annotation in `(↑(n - 1))`\n"}
{"name":"Nat.preimage_ceil_of_ne_zero","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\nn : Nat\nhn : Ne n 0\n⊢ Eq (Set.preimage Nat.ceil (Singleton.singleton n)) (Set.Ioc ↑(HSub.hSub n 1) ↑n)","decl":"theorem preimage_ceil_of_ne_zero (hn : n ≠ 0) : (Nat.ceil : α → ℕ) ⁻¹' {n} = Ioc (↑(n - 1) : α) n :=\n  ext fun _ => ceil_eq_iff hn\n\n"}
{"name":"Nat.preimage_Ioo","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na b : α\nha : LE.le 0 a\n⊢ Eq (Set.preimage Nat.cast (Set.Ioo a b)) (Set.Ioo (Nat.floor a) (Nat.ceil b))","decl":"@[simp]\ntheorem preimage_Ioo {a b : α} (ha : 0 ≤ a) :\n    (Nat.cast : ℕ → α) ⁻¹' Set.Ioo a b = Set.Ioo ⌊a⌋₊ ⌈b⌉₊ := by\n  ext\n  simp [floor_lt, lt_ceil, ha]\n\n-- Porting note: changed `(coe : ℕ → α)` to `(Nat.cast : ℕ → α)`\n"}
{"name":"Nat.preimage_Ico","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na b : α\n⊢ Eq (Set.preimage Nat.cast (Set.Ico a b)) (Set.Ico (Nat.ceil a) (Nat.ceil b))","decl":"@[simp]\ntheorem preimage_Ico {a b : α} : (Nat.cast : ℕ → α) ⁻¹' Set.Ico a b = Set.Ico ⌈a⌉₊ ⌈b⌉₊ := by\n  ext\n  simp [ceil_le, lt_ceil]\n\n-- Porting note: changed `(coe : ℕ → α)` to `(Nat.cast : ℕ → α)`\n"}
{"name":"Nat.preimage_Ioc","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na b : α\nha : LE.le 0 a\nhb : LE.le 0 b\n⊢ Eq (Set.preimage Nat.cast (Set.Ioc a b)) (Set.Ioc (Nat.floor a) (Nat.floor b))","decl":"@[simp]\ntheorem preimage_Ioc {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) :\n    (Nat.cast : ℕ → α) ⁻¹' Set.Ioc a b = Set.Ioc ⌊a⌋₊ ⌊b⌋₊ := by\n  ext\n  simp [floor_lt, le_floor_iff, hb, ha]\n\n-- Porting note: changed `(coe : ℕ → α)` to `(Nat.cast : ℕ → α)`\n"}
{"name":"Nat.preimage_Icc","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na b : α\nhb : LE.le 0 b\n⊢ Eq (Set.preimage Nat.cast (Set.Icc a b)) (Set.Icc (Nat.ceil a) (Nat.floor b))","decl":"@[simp]\ntheorem preimage_Icc {a b : α} (hb : 0 ≤ b) :\n    (Nat.cast : ℕ → α) ⁻¹' Set.Icc a b = Set.Icc ⌈a⌉₊ ⌊b⌋₊ := by\n  ext\n  simp [ceil_le, hb, le_floor_iff]\n\n-- Porting note: changed `(coe : ℕ → α)` to `(Nat.cast : ℕ → α)`\n"}
{"name":"Nat.preimage_Ioi","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nha : LE.le 0 a\n⊢ Eq (Set.preimage Nat.cast (Set.Ioi a)) (Set.Ioi (Nat.floor a))","decl":"@[simp]\ntheorem preimage_Ioi {a : α} (ha : 0 ≤ a) : (Nat.cast : ℕ → α) ⁻¹' Set.Ioi a = Set.Ioi ⌊a⌋₊ := by\n  ext\n  simp [floor_lt, ha]\n\n-- Porting note: changed `(coe : ℕ → α)` to `(Nat.cast : ℕ → α)`\n"}
{"name":"Nat.preimage_Ici","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\n⊢ Eq (Set.preimage Nat.cast (Set.Ici a)) (Set.Ici (Nat.ceil a))","decl":"@[simp]\ntheorem preimage_Ici {a : α} : (Nat.cast : ℕ → α) ⁻¹' Set.Ici a = Set.Ici ⌈a⌉₊ := by\n  ext\n  simp [ceil_le]\n\n-- Porting note: changed `(coe : ℕ → α)` to `(Nat.cast : ℕ → α)`\n"}
{"name":"Nat.preimage_Iio","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\n⊢ Eq (Set.preimage Nat.cast (Set.Iio a)) (Set.Iio (Nat.ceil a))","decl":"@[simp]\ntheorem preimage_Iio {a : α} : (Nat.cast : ℕ → α) ⁻¹' Set.Iio a = Set.Iio ⌈a⌉₊ := by\n  ext\n  simp [lt_ceil]\n\n-- Porting note: changed `(coe : ℕ → α)` to `(Nat.cast : ℕ → α)`\n"}
{"name":"Nat.preimage_Iic","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nha : LE.le 0 a\n⊢ Eq (Set.preimage Nat.cast (Set.Iic a)) (Set.Iic (Nat.floor a))","decl":"@[simp]\ntheorem preimage_Iic {a : α} (ha : 0 ≤ a) : (Nat.cast : ℕ → α) ⁻¹' Set.Iic a = Set.Iic ⌊a⌋₊ := by\n  ext\n  simp [le_floor_iff, ha]\n\n"}
{"name":"Nat.floor_add_nat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nha : LE.le 0 a\nn : Nat\n⊢ Eq (Nat.floor (HAdd.hAdd a ↑n)) (HAdd.hAdd (Nat.floor a) n)","decl":"theorem floor_add_nat (ha : 0 ≤ a) (n : ℕ) : ⌊a + n⌋₊ = ⌊a⌋₊ + n :=\n  eq_of_forall_le_iff fun b => by\n    rw [le_floor_iff (add_nonneg ha n.cast_nonneg)]\n    obtain hb | hb := le_total n b\n    · obtain ⟨d, rfl⟩ := exists_add_of_le hb\n      rw [Nat.cast_add, add_comm n, add_comm (n : α), add_le_add_iff_right, add_le_add_iff_right,\n        le_floor_iff ha]\n    · obtain ⟨d, rfl⟩ := exists_add_of_le hb\n      rw [Nat.cast_add, add_left_comm _ b, add_left_comm _ (b : α)]\n      refine iff_of_true ?_ le_self_add\n      exact le_add_of_nonneg_right <| ha.trans <| le_add_of_nonneg_right d.cast_nonneg\n\n"}
{"name":"Nat.floor_add_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nha : LE.le 0 a\n⊢ Eq (Nat.floor (HAdd.hAdd a 1)) (HAdd.hAdd (Nat.floor a) 1)","decl":"theorem floor_add_one (ha : 0 ≤ a) : ⌊a + 1⌋₊ = ⌊a⌋₊ + 1 := by\n  -- Porting note: broken `convert floor_add_nat ha 1`\n  rw [← cast_one, floor_add_nat ha 1]\n\n"}
{"name":"Nat.floor_add_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : FloorSemiring α\na : α\nha : LE.le 0 a\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Nat.floor (HAdd.hAdd a (OfNat.ofNat n))) (HAdd.hAdd (Nat.floor a) (OfNat.ofNat n))","decl":"theorem floor_add_ofNat (ha : 0 ≤ a) (n : ℕ) [n.AtLeastTwo] :\n    ⌊a + ofNat(n)⌋₊ = ⌊a⌋₊ + ofNat(n) :=\n  floor_add_nat ha n\n\n"}
{"name":"Nat.floor_sub_nat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : FloorSemiring α\ninst✝² : Sub α\ninst✝¹ : OrderedSub α\ninst✝ : ExistsAddOfLE α\na : α\nn : Nat\n⊢ Eq (Nat.floor (HSub.hSub a ↑n)) (HSub.hSub (Nat.floor a) n)","decl":"@[simp]\ntheorem floor_sub_nat [Sub α] [OrderedSub α] [ExistsAddOfLE α] (a : α) (n : ℕ) :\n    ⌊a - n⌋₊ = ⌊a⌋₊ - n := by\n  obtain ha | ha := le_total a 0\n  · rw [floor_of_nonpos ha, floor_of_nonpos (tsub_nonpos_of_le (ha.trans n.cast_nonneg)), zero_tsub]\n  rcases le_total a n with h | h\n  · rw [floor_of_nonpos (tsub_nonpos_of_le h), eq_comm, tsub_eq_zero_iff_le]\n    exact Nat.cast_le.1 ((Nat.floor_le ha).trans h)\n  · rw [eq_tsub_iff_add_eq_of_le (le_floor h), ← floor_add_nat _, tsub_add_cancel_of_le h]\n    exact le_tsub_of_add_le_left ((add_zero _).trans_le h)\n\n"}
{"name":"Nat.floor_sub_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝⁴ : LinearOrderedSemiring α\ninst✝³ : FloorSemiring α\ninst✝² : Sub α\ninst✝¹ : OrderedSub α\ninst✝ : ExistsAddOfLE α\na : α\n⊢ Eq (Nat.floor (HSub.hSub a 1)) (HSub.hSub (Nat.floor a) 1)","decl":"@[simp]\ntheorem floor_sub_one [Sub α] [OrderedSub α] [ExistsAddOfLE α] (a : α) : ⌊a - 1⌋₊ = ⌊a⌋₊ - 1 :=\n  mod_cast floor_sub_nat a 1\n\n"}
{"name":"Nat.floor_sub_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : FloorSemiring α\ninst✝³ : Sub α\ninst✝² : OrderedSub α\ninst✝¹ : ExistsAddOfLE α\na : α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Nat.floor (HSub.hSub a (OfNat.ofNat n))) (HSub.hSub (Nat.floor a) (OfNat.ofNat n))","decl":"@[simp]\ntheorem floor_sub_ofNat [Sub α] [OrderedSub α] [ExistsAddOfLE α] (a : α) (n : ℕ) [n.AtLeastTwo] :\n    ⌊a - ofNat(n)⌋₊ = ⌊a⌋₊ - ofNat(n) :=\n  floor_sub_nat a n\n\n"}
{"name":"Nat.ceil_add_nat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nha : LE.le 0 a\nn : Nat\n⊢ Eq (Nat.ceil (HAdd.hAdd a ↑n)) (HAdd.hAdd (Nat.ceil a) n)","decl":"theorem ceil_add_nat (ha : 0 ≤ a) (n : ℕ) : ⌈a + n⌉₊ = ⌈a⌉₊ + n :=\n  eq_of_forall_ge_iff fun b => by\n    rw [← not_lt, ← not_lt, not_iff_not, lt_ceil]\n    obtain hb | hb := le_or_lt n b\n    · obtain ⟨d, rfl⟩ := exists_add_of_le hb\n      rw [Nat.cast_add, add_comm n, add_comm (n : α), add_lt_add_iff_right, add_lt_add_iff_right,\n        lt_ceil]\n    · exact iff_of_true (lt_add_of_nonneg_of_lt ha <| cast_lt.2 hb) (Nat.lt_add_left _ hb)\n\n"}
{"name":"Nat.ceil_add_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nha : LE.le 0 a\n⊢ Eq (Nat.ceil (HAdd.hAdd a 1)) (HAdd.hAdd (Nat.ceil a) 1)","decl":"theorem ceil_add_one (ha : 0 ≤ a) : ⌈a + 1⌉₊ = ⌈a⌉₊ + 1 := by\n  -- Porting note: broken `convert ceil_add_nat ha 1`\n  rw [cast_one.symm, ceil_add_nat ha 1]\n\n"}
{"name":"Nat.ceil_add_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedSemiring α\ninst✝¹ : FloorSemiring α\na : α\nha : LE.le 0 a\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Nat.ceil (HAdd.hAdd a (OfNat.ofNat n))) (HAdd.hAdd (Nat.ceil a) (OfNat.ofNat n))","decl":"theorem ceil_add_ofNat (ha : 0 ≤ a) (n : ℕ) [n.AtLeastTwo] :\n    ⌈a + ofNat(n)⌉₊ = ⌈a⌉₊ + ofNat(n) :=\n  ceil_add_nat ha n\n\n"}
{"name":"Nat.ceil_lt_add_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na : α\nha : LE.le 0 a\n⊢ LT.lt (↑(Nat.ceil a)) (HAdd.hAdd a 1)","decl":"@[bound]\ntheorem ceil_lt_add_one (ha : 0 ≤ a) : (⌈a⌉₊ : α) < a + 1 :=\n  lt_ceil.1 <| (Nat.lt_succ_self _).trans_le (ceil_add_one ha).ge\n\n"}
{"name":"Nat.ceil_add_le","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemiring α\ninst✝ : FloorSemiring α\na b : α\n⊢ LE.le (Nat.ceil (HAdd.hAdd a b)) (HAdd.hAdd (Nat.ceil a) (Nat.ceil b))","decl":"@[bound]\ntheorem ceil_add_le (a b : α) : ⌈a + b⌉₊ ≤ ⌈a⌉₊ + ⌈b⌉₊ := by\n  rw [ceil_le, Nat.cast_add]\n  gcongr <;> apply le_ceil\n\n"}
{"name":"Nat.sub_one_lt_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorSemiring α\na : α\n⊢ LT.lt (HSub.hSub a 1) ↑(Nat.floor a)","decl":"@[bound]\ntheorem sub_one_lt_floor (a : α) : a - 1 < ⌊a⌋₊ :=\n  sub_lt_iff_lt_add.2 <| lt_floor_add_one a\n\n"}
{"name":"Nat.floor_div_nat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemifield α\ninst✝ : FloorSemiring α\na : α\nn : Nat\n⊢ Eq (Nat.floor (HDiv.hDiv a ↑n)) (HDiv.hDiv (Nat.floor a) n)","decl":"theorem floor_div_nat (a : α) (n : ℕ) : ⌊a / n⌋₊ = ⌊a⌋₊ / n := by\n  rcases le_total a 0 with ha | ha\n  · rw [floor_of_nonpos, floor_of_nonpos ha]\n    · simp\n    apply div_nonpos_of_nonpos_of_nonneg ha n.cast_nonneg\n  obtain rfl | hn := n.eq_zero_or_pos\n  · rw [cast_zero, div_zero, Nat.div_zero, floor_zero]\n  refine (floor_eq_iff ?_).2 ?_\n  · exact div_nonneg ha n.cast_nonneg\n  constructor\n  · exact cast_div_le.trans (div_le_div_of_nonneg_right (floor_le ha) n.cast_nonneg)\n  rw [div_lt_iff₀, add_mul, one_mul, ← cast_mul, ← cast_add, ← floor_lt ha]\n  · exact lt_div_mul_add hn\n  · exact cast_pos.2 hn\n\n"}
{"name":"Nat.floor_div_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedSemifield α\ninst✝¹ : FloorSemiring α\na : α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Nat.floor (HDiv.hDiv a (OfNat.ofNat n))) (HDiv.hDiv (Nat.floor a) (OfNat.ofNat n))","decl":"theorem floor_div_ofNat (a : α) (n : ℕ) [n.AtLeastTwo] :\n    ⌊a / ofNat(n)⌋₊ = ⌊a⌋₊ / ofNat(n) :=\n  floor_div_nat a n\n\n"}
{"name":"Nat.floor_div_eq_div","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedSemifield α\ninst✝ : FloorSemiring α\nm n : Nat\n⊢ Eq (Nat.floor (HDiv.hDiv ↑m ↑n)) (HDiv.hDiv m n)","decl":"/-- Natural division is the floor of field division. -/\ntheorem floor_div_eq_div (m n : ℕ) : ⌊(m : α) / n⌋₊ = m / n := by\n  convert floor_div_nat (m : α) n\n  rw [m.floor_natCast]\n\n"}
{"name":"Nat.mul_lt_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorSemiring α\na b : α\nhb₀ : LT.lt 0 b\nhb : LT.lt b 1\nhba : LE.le (↑(Nat.ceil (HDiv.hDiv b (HSub.hSub 1 b)))) a\n⊢ LT.lt (HMul.hMul b a) ↑(Nat.floor a)","decl":"lemma mul_lt_floor (hb₀ : 0 < b) (hb : b < 1) (hba : ⌈b / (1 - b)⌉₊ ≤ a) : b * a < ⌊a⌋₊ := by\n  calc\n    b * a < b * (⌊a⌋₊ + 1) := by gcongr; exacts [hb₀, lt_floor_add_one _]\n    _ ≤ ⌊a⌋₊ := by\n      rw [_root_.mul_add_one, ← le_sub_iff_add_le', ← one_sub_mul, ← div_le_iff₀' (by linarith),\n        ← ceil_le]\n      exact le_floor hba\n\n"}
{"name":"Nat.ceil_lt_mul","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorSemiring α\na b : α\nhb : LT.lt 1 b\nhba : LT.lt (HDiv.hDiv (↑(Nat.ceil (Inv.inv (HSub.hSub b 1)))) b) a\n⊢ LT.lt (↑(Nat.ceil a)) (HMul.hMul b a)","decl":"lemma ceil_lt_mul (hb : 1 < b) (hba : ⌈(b - 1)⁻¹⌉₊ / b < a) : ⌈a⌉₊ < b * a := by\n  obtain hab | hba := le_total a (b - 1)⁻¹\n  · calc\n      ⌈a⌉₊ ≤ (⌈(b - 1)⁻¹⌉₊ : α) := by gcongr\n      _ < b * a := by rwa [← div_lt_iff₀']; positivity\n  · rw [← sub_pos] at hb\n    calc\n      ⌈a⌉₊ < a + 1 := ceil_lt_add_one <| hba.trans' <| by positivity\n      _ = a + (b - 1) * (b - 1)⁻¹ := by rw [mul_inv_cancel₀]; positivity\n      _ ≤ a + (b - 1) * a := by gcongr; positivity\n      _ = b * a := by rw [sub_one_mul, add_sub_cancel]\n\n"}
{"name":"Nat.ceil_le_mul","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorSemiring α\na b : α\nhb : LT.lt 1 b\nhba : LE.le (HDiv.hDiv (↑(Nat.ceil (Inv.inv (HSub.hSub b 1)))) b) a\n⊢ LE.le (↑(Nat.ceil a)) (HMul.hMul b a)","decl":"lemma ceil_le_mul (hb : 1 < b) (hba : ⌈(b - 1)⁻¹⌉₊ / b ≤ a) : ⌈a⌉₊ ≤ b * a := by\n  obtain rfl | hba := hba.eq_or_lt\n  · rw [mul_div_cancel₀, cast_le, ceil_le]\n    · exact _root_.div_le_self (by positivity) hb.le\n    · positivity\n  · exact (ceil_lt_mul hb hba).le\n\n"}
{"name":"Nat.div_two_lt_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorSemiring α\na : α\nha : LE.le 1 a\n⊢ LT.lt (HDiv.hDiv a 2) ↑(Nat.floor a)","decl":"lemma div_two_lt_floor (ha : 1 ≤ a) : a / 2 < ⌊a⌋₊ := by\n  rw [div_eq_inv_mul]; refine mul_lt_floor ?_ ?_ ?_ <;> norm_num; assumption\n\n"}
{"name":"Nat.ceil_lt_two_mul","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorSemiring α\na : α\nha : LT.lt (Inv.inv 2) a\n⊢ LT.lt (↑(Nat.ceil a)) (HMul.hMul 2 a)","decl":"lemma ceil_lt_two_mul (ha : 2⁻¹ < a) : ⌈a⌉₊ < 2 * a :=\n  ceil_lt_mul one_lt_two (by norm_num at ha ⊢; exact ha)\n\n"}
{"name":"Nat.ceil_le_two_mul","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorSemiring α\na : α\nha : LE.le (Inv.inv 2) a\n⊢ LE.le (↑(Nat.ceil a)) (HMul.hMul 2 a)","decl":"lemma ceil_le_two_mul (ha : 2⁻¹ ≤ a) : ⌈a⌉₊ ≤ 2 * a :=\n  ceil_le_mul one_lt_two (by norm_num at ha ⊢; exact ha)\n\n"}
{"name":"subsingleton_floorSemiring","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_4\ninst✝ : LinearOrderedSemiring α\n⊢ Subsingleton (FloorSemiring α)","decl":"/-- There exists at most one `FloorSemiring` structure on a linear ordered semiring. -/\ntheorem subsingleton_floorSemiring {α} [LinearOrderedSemiring α] :\n    Subsingleton (FloorSemiring α) := by\n  refine ⟨fun H₁ H₂ => ?_⟩\n  have : H₁.ceil = H₂.ceil := funext fun a => (H₁.gc_ceil.l_unique H₂.gc_ceil) fun n => rfl\n  have : H₁.floor = H₂.floor := by\n    ext a\n    cases' lt_or_le a 0 with h h\n    · rw [H₁.floor_of_neg, H₂.floor_of_neg] <;> exact h\n    · refine eq_of_forall_le_iff fun n => ?_\n      rw [H₁.gc_floor, H₂.gc_floor] <;> exact h\n  cases H₁\n  cases H₂\n  congr\n\n"}
{"name":"FloorRing.gc_ceil_coe","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_4\ninst✝ : LinearOrderedRing α\nself : FloorRing α\n⊢ GaloisConnection FloorRing.ceil Int.cast","decl":"/-- A `FloorRing` is a linear ordered ring over `α` with a function\n`floor : α → ℤ` satisfying `∀ (z : ℤ) (a : α), z ≤ floor a ↔ (z : α) ≤ a)`.\n-/\nclass FloorRing (α) [LinearOrderedRing α] where\n  /-- `FloorRing.floor a` computes the greatest integer `z` such that `(z : α) ≤ a`. -/\n  floor : α → ℤ\n  /-- `FloorRing.ceil a` computes the least integer `z` such that `a ≤ (z : α)`. -/\n  ceil : α → ℤ\n  /-- `FloorRing.ceil` is the upper adjoint of the coercion `↑ : ℤ → α`. -/\n  gc_coe_floor : GaloisConnection (↑) floor\n  /-- `FloorRing.ceil` is the lower adjoint of the coercion `↑ : ℤ → α`. -/\n  gc_ceil_coe : GaloisConnection ceil (↑)\n\n"}
{"name":"FloorRing.gc_coe_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_4\ninst✝ : LinearOrderedRing α\nself : FloorRing α\n⊢ GaloisConnection Int.cast FloorRing.floor","decl":"/-- A `FloorRing` is a linear ordered ring over `α` with a function\n`floor : α → ℤ` satisfying `∀ (z : ℤ) (a : α), z ≤ floor a ↔ (z : α) ≤ a)`.\n-/\nclass FloorRing (α) [LinearOrderedRing α] where\n  /-- `FloorRing.floor a` computes the greatest integer `z` such that `(z : α) ≤ a`. -/\n  floor : α → ℤ\n  /-- `FloorRing.ceil a` computes the least integer `z` such that `a ≤ (z : α)`. -/\n  ceil : α → ℤ\n  /-- `FloorRing.ceil` is the upper adjoint of the coercion `↑ : ℤ → α`. -/\n  gc_coe_floor : GaloisConnection (↑) floor\n  /-- `FloorRing.ceil` is the lower adjoint of the coercion `↑ : ℤ → α`. -/\n  gc_ceil_coe : GaloisConnection ceil (↑)\n\n"}
{"name":"Int.floor_int","module":"Mathlib.Algebra.Order.Floor","initialProofState":"⊢ Eq Int.floor id","decl":"@[simp]\ntheorem floor_int : (Int.floor : ℤ → ℤ) = id :=\n  rfl\n\n"}
{"name":"Int.ceil_int","module":"Mathlib.Algebra.Order.Floor","initialProofState":"⊢ Eq Int.ceil id","decl":"@[simp]\ntheorem ceil_int : (Int.ceil : ℤ → ℤ) = id :=\n  rfl\n\n"}
{"name":"Int.fract_int","module":"Mathlib.Algebra.Order.Floor","initialProofState":"⊢ Eq Int.fract 0","decl":"@[simp]\ntheorem fract_int : (Int.fract : ℤ → ℤ) = 0 :=\n  funext fun x => by simp [fract]\n\n"}
{"name":"Int.floorRing_floor_eq","module":"Mathlib.Algebra.Order.Floor","initialProofState":"⊢ Eq @FloorRing.floor @Int.floor","decl":"@[simp]\ntheorem floorRing_floor_eq : @FloorRing.floor = @Int.floor :=\n  rfl\n\n"}
{"name":"Int.floorRing_ceil_eq","module":"Mathlib.Algebra.Order.Floor","initialProofState":"⊢ Eq @FloorRing.ceil @Int.ceil","decl":"@[simp]\ntheorem floorRing_ceil_eq : @FloorRing.ceil = @Int.ceil :=\n  rfl\n\n"}
{"name":"Int.gc_coe_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\n⊢ GaloisConnection Int.cast Int.floor","decl":"theorem gc_coe_floor : GaloisConnection ((↑) : ℤ → α) floor :=\n  FloorRing.gc_coe_floor\n\n"}
{"name":"Int.le_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\n⊢ Iff (LE.le z (Int.floor a)) (LE.le (↑z) a)","decl":"theorem le_floor : z ≤ ⌊a⌋ ↔ (z : α) ≤ a :=\n  (gc_coe_floor z a).symm\n\n"}
{"name":"Int.floor_lt","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\n⊢ Iff (LT.lt (Int.floor a) z) (LT.lt a ↑z)","decl":"theorem floor_lt : ⌊a⌋ < z ↔ a < z :=\n  lt_iff_lt_of_le_iff_le le_floor\n\n"}
{"name":"Int.floor_le","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ LE.le (↑(Int.floor a)) a","decl":"@[bound]\ntheorem floor_le (a : α) : (⌊a⌋ : α) ≤ a :=\n  gc_coe_floor.l_u_le a\n\n"}
{"name":"Int.floor_le_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\n⊢ Iff (LE.le (Int.floor a) z) (LT.lt a (HAdd.hAdd (↑z) 1))","decl":"theorem floor_le_iff : ⌊a⌋ ≤ z ↔ a < z + 1 := by rw [← lt_add_one_iff, floor_lt]; norm_cast\n"}
{"name":"Int.lt_floor_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\n⊢ Iff (LT.lt z (Int.floor a)) (LE.le (HAdd.hAdd (↑z) 1) a)","decl":"theorem lt_floor_iff : z < ⌊a⌋ ↔ z + 1 ≤ a := by rw [← add_one_le_iff, le_floor]; norm_cast\n\n"}
{"name":"Int.floor_nonneg","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Iff (LE.le 0 (Int.floor a)) (LE.le 0 a)","decl":"theorem floor_nonneg : 0 ≤ ⌊a⌋ ↔ 0 ≤ a := by rw [le_floor, Int.cast_zero]\n\n"}
{"name":"Int.floor_le_sub_one_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\n⊢ Iff (LE.le (Int.floor a) (HSub.hSub z 1)) (LT.lt a ↑z)","decl":"@[simp]\ntheorem floor_le_sub_one_iff : ⌊a⌋ ≤ z - 1 ↔ a < z := by rw [← floor_lt, le_sub_one_iff]\n\n"}
{"name":"Int.floor_le_neg_one_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Iff (LE.le (Int.floor a) (-1)) (LT.lt a 0)","decl":"@[simp]\ntheorem floor_le_neg_one_iff : ⌊a⌋ ≤ -1 ↔ a < 0 := by\n  rw [← zero_sub (1 : ℤ), floor_le_sub_one_iff, cast_zero]\n\n"}
{"name":"Int.floor_nonpos","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nha : LE.le a 0\n⊢ LE.le (Int.floor a) 0","decl":"@[bound]\ntheorem floor_nonpos (ha : a ≤ 0) : ⌊a⌋ ≤ 0 := by\n  rw [← @cast_le α, Int.cast_zero]\n  exact (floor_le a).trans ha\n\n"}
{"name":"Int.lt_succ_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ LT.lt a ↑(Int.floor a).succ","decl":"theorem lt_succ_floor (a : α) : a < ⌊a⌋.succ :=\n  floor_lt.1 <| Int.lt_succ_self _\n\n"}
{"name":"Int.lt_floor_add_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ LT.lt a (HAdd.hAdd (↑(Int.floor a)) 1)","decl":"@[simp, bound]\ntheorem lt_floor_add_one (a : α) : a < ⌊a⌋ + 1 := by\n  simpa only [Int.succ, Int.cast_add, Int.cast_one] using lt_succ_floor a\n\n"}
{"name":"Int.sub_one_lt_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ LT.lt (HSub.hSub a 1) ↑(Int.floor a)","decl":"@[simp, bound]\ntheorem sub_one_lt_floor (a : α) : a - 1 < ⌊a⌋ :=\n  sub_lt_iff_lt_add.2 (lt_floor_add_one a)\n\n"}
{"name":"Int.floor_intCast","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\n⊢ Eq (Int.floor ↑z) z","decl":"@[simp]\ntheorem floor_intCast (z : ℤ) : ⌊(z : α)⌋ = z :=\n  eq_of_forall_le_iff fun a => by rw [le_floor, Int.cast_le]\n\n"}
{"name":"Int.floor_natCast","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nn : Nat\n⊢ Eq (Int.floor ↑n) ↑n","decl":"@[simp]\ntheorem floor_natCast (n : ℕ) : ⌊(n : α)⌋ = n :=\n  eq_of_forall_le_iff fun a => by rw [le_floor, ← cast_natCast, cast_le]\n\n"}
{"name":"Int.floor_zero","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\n⊢ Eq (Int.floor 0) 0","decl":"@[simp]\ntheorem floor_zero : ⌊(0 : α)⌋ = 0 := by rw [← cast_zero, floor_intCast]\n\n"}
{"name":"Int.floor_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\n⊢ Eq (Int.floor 1) 1","decl":"@[simp]\ntheorem floor_one : ⌊(1 : α)⌋ = 1 := by rw [← cast_one, floor_intCast]\n\n"}
{"name":"Int.floor_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Int.floor (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp] theorem floor_ofNat (n : ℕ) [n.AtLeastTwo] : ⌊(ofNat(n) : α)⌋ = ofNat(n) :=\n  floor_natCast n\n\n"}
{"name":"Int.floor_mono","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\n⊢ Monotone Int.floor","decl":"@[mono]\ntheorem floor_mono : Monotone (floor : α → ℤ) :=\n  gc_coe_floor.monotone_u\n\n"}
{"name":"Int.floor_le_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\nhab : LE.le a b\n⊢ LE.le (Int.floor a) (Int.floor b)","decl":"@[gcongr, bound] lemma floor_le_floor (hab : a ≤ b) : ⌊a⌋ ≤ ⌊b⌋ := floor_mono hab\n\n"}
{"name":"Int.floor_pos","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Iff (LT.lt 0 (Int.floor a)) (LE.le 1 a)","decl":"theorem floor_pos : 0 < ⌊a⌋ ↔ 1 ≤ a := by\n  -- Porting note: broken `convert le_floor`\n  rw [Int.lt_iff_add_one_le, zero_add, le_floor, cast_one]\n\n"}
{"name":"Int.floor_add_int","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nz : Int\n⊢ Eq (Int.floor (HAdd.hAdd a ↑z)) (HAdd.hAdd (Int.floor a) z)","decl":"@[simp]\ntheorem floor_add_int (a : α) (z : ℤ) : ⌊a + z⌋ = ⌊a⌋ + z :=\n  eq_of_forall_le_iff fun a => by\n    rw [le_floor, ← sub_le_iff_le_add, ← sub_le_iff_le_add, le_floor, Int.cast_sub]\n\n"}
{"name":"Int.floor_add_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.floor (HAdd.hAdd a 1)) (HAdd.hAdd (Int.floor a) 1)","decl":"@[simp]\ntheorem floor_add_one (a : α) : ⌊a + 1⌋ = ⌊a⌋ + 1 := by\n  -- Porting note: broken `convert floor_add_int a 1`\n  rw [← cast_one, floor_add_int]\n\n"}
{"name":"Int.le_floor_add","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\n⊢ LE.le (HAdd.hAdd (Int.floor a) (Int.floor b)) (Int.floor (HAdd.hAdd a b))","decl":"@[bound]\ntheorem le_floor_add (a b : α) : ⌊a⌋ + ⌊b⌋ ≤ ⌊a + b⌋ := by\n  rw [le_floor, Int.cast_add]\n  gcongr <;> apply floor_le\n\n"}
{"name":"Int.le_floor_add_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\n⊢ LE.le (HSub.hSub (Int.floor (HAdd.hAdd a b)) 1) (HAdd.hAdd (Int.floor a) (Int.floor b))","decl":"@[bound]\ntheorem le_floor_add_floor (a b : α) : ⌊a + b⌋ - 1 ≤ ⌊a⌋ + ⌊b⌋ := by\n  rw [← sub_le_iff_le_add, le_floor, Int.cast_sub, sub_le_comm, Int.cast_sub, Int.cast_one]\n  refine le_trans ?_ (sub_one_lt_floor _).le\n  rw [sub_le_iff_le_add', ← add_sub_assoc, sub_le_sub_iff_right]\n  exact floor_le _\n\n"}
{"name":"Int.floor_int_add","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\n⊢ Eq (Int.floor (HAdd.hAdd (↑z) a)) (HAdd.hAdd z (Int.floor a))","decl":"@[simp]\ntheorem floor_int_add (z : ℤ) (a : α) : ⌊↑z + a⌋ = z + ⌊a⌋ := by\n  simpa only [add_comm] using floor_add_int a z\n\n"}
{"name":"Int.floor_add_nat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nn : Nat\n⊢ Eq (Int.floor (HAdd.hAdd a ↑n)) (HAdd.hAdd (Int.floor a) ↑n)","decl":"@[simp]\ntheorem floor_add_nat (a : α) (n : ℕ) : ⌊a + n⌋ = ⌊a⌋ + n := by\n  rw [← Int.cast_natCast, floor_add_int]\n\n"}
{"name":"Int.floor_add_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\na : α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Int.floor (HAdd.hAdd a (OfNat.ofNat n))) (HAdd.hAdd (Int.floor a) (OfNat.ofNat n))","decl":"@[simp]\ntheorem floor_add_ofNat (a : α) (n : ℕ) [n.AtLeastTwo] :\n    ⌊a + ofNat(n)⌋ = ⌊a⌋ + ofNat(n) :=\n  floor_add_nat a n\n\n"}
{"name":"Int.floor_nat_add","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nn : Nat\na : α\n⊢ Eq (Int.floor (HAdd.hAdd (↑n) a)) (HAdd.hAdd (↑n) (Int.floor a))","decl":"@[simp]\ntheorem floor_nat_add (n : ℕ) (a : α) : ⌊↑n + a⌋ = n + ⌊a⌋ := by\n  rw [← Int.cast_natCast, floor_int_add]\n\n"}
{"name":"Int.floor_ofNat_add","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\nn : Nat\ninst✝ : n.AtLeastTwo\na : α\n⊢ Eq (Int.floor (HAdd.hAdd (OfNat.ofNat n) a)) (HAdd.hAdd (OfNat.ofNat n) (Int.floor a))","decl":"@[simp]\ntheorem floor_ofNat_add (n : ℕ) [n.AtLeastTwo] (a : α) :\n    ⌊ofNat(n) + a⌋ = ofNat(n) + ⌊a⌋ :=\n  floor_nat_add n a\n\n"}
{"name":"Int.floor_sub_int","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nz : Int\n⊢ Eq (Int.floor (HSub.hSub a ↑z)) (HSub.hSub (Int.floor a) z)","decl":"@[simp]\ntheorem floor_sub_int (a : α) (z : ℤ) : ⌊a - z⌋ = ⌊a⌋ - z :=\n  Eq.trans (by rw [Int.cast_neg, sub_eq_add_neg]) (floor_add_int _ _)\n\n"}
{"name":"Int.floor_sub_nat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nn : Nat\n⊢ Eq (Int.floor (HSub.hSub a ↑n)) (HSub.hSub (Int.floor a) ↑n)","decl":"@[simp]\ntheorem floor_sub_nat (a : α) (n : ℕ) : ⌊a - n⌋ = ⌊a⌋ - n := by\n  rw [← Int.cast_natCast, floor_sub_int]\n\n"}
{"name":"Int.floor_sub_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.floor (HSub.hSub a 1)) (HSub.hSub (Int.floor a) 1)","decl":"@[simp] theorem floor_sub_one (a : α) : ⌊a - 1⌋ = ⌊a⌋ - 1 := mod_cast floor_sub_nat a 1\n\n"}
{"name":"Int.floor_sub_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\na : α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Int.floor (HSub.hSub a (OfNat.ofNat n))) (HSub.hSub (Int.floor a) (OfNat.ofNat n))","decl":"@[simp]\ntheorem floor_sub_ofNat (a : α) (n : ℕ) [n.AtLeastTwo] :\n    ⌊a - ofNat(n)⌋ = ⌊a⌋ - ofNat(n) :=\n  floor_sub_nat a n\n\n"}
{"name":"Int.abs_sub_lt_one_of_floor_eq_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_4\ninst✝¹ : LinearOrderedCommRing α\ninst✝ : FloorRing α\na b : α\nh : Eq (Int.floor a) (Int.floor b)\n⊢ LT.lt (abs (HSub.hSub a b)) 1","decl":"theorem abs_sub_lt_one_of_floor_eq_floor {α : Type*} [LinearOrderedCommRing α] [FloorRing α]\n    {a b : α} (h : ⌊a⌋ = ⌊b⌋) : |a - b| < 1 := by\n  have : a < ⌊a⌋ + 1 := lt_floor_add_one a\n  have : b < ⌊b⌋ + 1 := lt_floor_add_one b\n  have : (⌊a⌋ : α) = ⌊b⌋ := Int.cast_inj.2 h\n  have : (⌊a⌋ : α) ≤ a := floor_le a\n  have : (⌊b⌋ : α) ≤ b := floor_le b\n  exact abs_sub_lt_iff.2 ⟨by linarith, by linarith⟩\n\n"}
{"name":"Int.floor_eq_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\n⊢ Iff (Eq (Int.floor a) z) (And (LE.le (↑z) a) (LT.lt a (HAdd.hAdd (↑z) 1)))","decl":"theorem floor_eq_iff : ⌊a⌋ = z ↔ ↑z ≤ a ∧ a < z + 1 := by\n  rw [le_antisymm_iff, le_floor, ← Int.lt_add_one_iff, floor_lt, Int.cast_add, Int.cast_one,\n    and_comm]\n\n"}
{"name":"Int.floor_eq_zero_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Iff (Eq (Int.floor a) 0) (Membership.mem (Set.Ico 0 1) a)","decl":"@[simp]\ntheorem floor_eq_zero_iff : ⌊a⌋ = 0 ↔ a ∈ Ico (0 : α) 1 := by simp [floor_eq_iff]\n\n"}
{"name":"Int.floor_eq_on_Ico","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nn : Int\na : α\na✝ : Membership.mem (Set.Ico (↑n) (HAdd.hAdd (↑n) 1)) a\n⊢ Eq (Int.floor a) n","decl":"theorem floor_eq_on_Ico (n : ℤ) : ∀ a ∈ Set.Ico (n : α) (n + 1), ⌊a⌋ = n := fun _ ⟨h₀, h₁⟩ =>\n  floor_eq_iff.mpr ⟨h₀, h₁⟩\n\n"}
{"name":"Int.floor_eq_on_Ico'","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nn : Int\na : α\na✝ : Membership.mem (Set.Ico (↑n) (HAdd.hAdd (↑n) 1)) a\n⊢ Eq ↑(Int.floor a) ↑n","decl":"theorem floor_eq_on_Ico' (n : ℤ) : ∀ a ∈ Set.Ico (n : α) (n + 1), (⌊a⌋ : α) = n := fun a ha =>\n  congr_arg _ <| floor_eq_on_Ico n a ha\n\n-- Porting note: in mathlib3 there was no need for the type annotation in `(m:α)`\n"}
{"name":"Int.preimage_floor_singleton","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nm : Int\n⊢ Eq (Set.preimage Int.floor (Singleton.singleton m)) (Set.Ico (↑m) (HAdd.hAdd (↑m) 1))","decl":"@[simp]\ntheorem preimage_floor_singleton (m : ℤ) : (floor : α → ℤ) ⁻¹' {m} = Ico (m : α) (m + 1) :=\n  ext fun _ => floor_eq_iff\n\n"}
{"name":"Int.self_sub_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (HSub.hSub a ↑(Int.floor a)) (Int.fract a)","decl":"@[simp]\ntheorem self_sub_floor (a : α) : a - ⌊a⌋ = fract a :=\n  rfl\n\n"}
{"name":"Int.floor_add_fract","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (HAdd.hAdd (↑(Int.floor a)) (Int.fract a)) a","decl":"@[simp]\ntheorem floor_add_fract (a : α) : (⌊a⌋ : α) + fract a = a :=\n  add_sub_cancel _ _\n\n"}
{"name":"Int.fract_add_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (HAdd.hAdd (Int.fract a) ↑(Int.floor a)) a","decl":"@[simp]\ntheorem fract_add_floor (a : α) : fract a + ⌊a⌋ = a :=\n  sub_add_cancel _ _\n\n"}
{"name":"Int.fract_add_int","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nm : Int\n⊢ Eq (Int.fract (HAdd.hAdd a ↑m)) (Int.fract a)","decl":"@[simp]\ntheorem fract_add_int (a : α) (m : ℤ) : fract (a + m) = fract a := by\n  rw [fract]\n  simp\n\n"}
{"name":"Int.fract_add_nat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nm : Nat\n⊢ Eq (Int.fract (HAdd.hAdd a ↑m)) (Int.fract a)","decl":"@[simp]\ntheorem fract_add_nat (a : α) (m : ℕ) : fract (a + m) = fract a := by\n  rw [fract]\n  simp\n\n"}
{"name":"Int.fract_add_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.fract (HAdd.hAdd a 1)) (Int.fract a)","decl":"@[simp]\ntheorem fract_add_one (a : α) : fract (a + 1) = fract a := mod_cast fract_add_nat a 1\n\n"}
{"name":"Int.fract_add_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\na : α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Int.fract (HAdd.hAdd a (OfNat.ofNat n))) (Int.fract a)","decl":"@[simp]\ntheorem fract_add_ofNat (a : α) (n : ℕ) [n.AtLeastTwo] :\n    fract (a + ofNat(n)) = fract a :=\n  fract_add_nat a n\n\n"}
{"name":"Int.fract_int_add","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nm : Int\na : α\n⊢ Eq (Int.fract (HAdd.hAdd (↑m) a)) (Int.fract a)","decl":"@[simp]\ntheorem fract_int_add (m : ℤ) (a : α) : fract (↑m + a) = fract a := by rw [add_comm, fract_add_int]\n\n"}
{"name":"Int.fract_nat_add","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nn : Nat\na : α\n⊢ Eq (Int.fract (HAdd.hAdd (↑n) a)) (Int.fract a)","decl":"@[simp]\ntheorem fract_nat_add (n : ℕ) (a : α) : fract (↑n + a) = fract a := by rw [add_comm, fract_add_nat]\n\n"}
{"name":"Int.fract_one_add","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.fract (HAdd.hAdd 1 a)) (Int.fract a)","decl":"@[simp]\ntheorem fract_one_add (a : α) : fract (1 + a) = fract a := mod_cast fract_nat_add 1 a\n\n"}
{"name":"Int.fract_ofNat_add","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\nn : Nat\ninst✝ : n.AtLeastTwo\na : α\n⊢ Eq (Int.fract (HAdd.hAdd (OfNat.ofNat n) a)) (Int.fract a)","decl":"@[simp]\ntheorem fract_ofNat_add (n : ℕ) [n.AtLeastTwo] (a : α) :\n    fract (ofNat(n) + a) = fract a :=\n  fract_nat_add n a\n\n"}
{"name":"Int.fract_sub_int","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nm : Int\n⊢ Eq (Int.fract (HSub.hSub a ↑m)) (Int.fract a)","decl":"@[simp]\ntheorem fract_sub_int (a : α) (m : ℤ) : fract (a - m) = fract a := by\n  rw [fract]\n  simp\n\n"}
{"name":"Int.fract_sub_nat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nn : Nat\n⊢ Eq (Int.fract (HSub.hSub a ↑n)) (Int.fract a)","decl":"@[simp]\ntheorem fract_sub_nat (a : α) (n : ℕ) : fract (a - n) = fract a := by\n  rw [fract]\n  simp\n\n"}
{"name":"Int.fract_sub_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.fract (HSub.hSub a 1)) (Int.fract a)","decl":"@[simp]\ntheorem fract_sub_one (a : α) : fract (a - 1) = fract a := mod_cast fract_sub_nat a 1\n\n"}
{"name":"Int.fract_sub_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\na : α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Int.fract (HSub.hSub a (OfNat.ofNat n))) (Int.fract a)","decl":"@[simp]\ntheorem fract_sub_ofNat (a : α) (n : ℕ) [n.AtLeastTwo] :\n    fract (a - ofNat(n)) = fract a :=\n  fract_sub_nat a n\n\n-- Was a duplicate lemma under a bad name\n\n"}
{"name":"Int.fract_add_le","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\n⊢ LE.le (Int.fract (HAdd.hAdd a b)) (HAdd.hAdd (Int.fract a) (Int.fract b))","decl":"theorem fract_add_le (a b : α) : fract (a + b) ≤ fract a + fract b := by\n  rw [fract, fract, fract, sub_add_sub_comm, sub_le_sub_iff_left, ← Int.cast_add, Int.cast_le]\n  exact le_floor_add _ _\n\n"}
{"name":"Int.fract_add_fract_le","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\n⊢ LE.le (HAdd.hAdd (Int.fract a) (Int.fract b)) (HAdd.hAdd (Int.fract (HAdd.hAdd a b)) 1)","decl":"theorem fract_add_fract_le (a b : α) : fract a + fract b ≤ fract (a + b) + 1 := by\n  rw [fract, fract, fract, sub_add_sub_comm, sub_add, sub_le_sub_iff_left]\n  exact mod_cast le_floor_add_floor a b\n\n"}
{"name":"Int.self_sub_fract","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (HSub.hSub a (Int.fract a)) ↑(Int.floor a)","decl":"@[simp]\ntheorem self_sub_fract (a : α) : a - fract a = ⌊a⌋ :=\n  sub_sub_cancel _ _\n\n"}
{"name":"Int.fract_sub_self","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (HSub.hSub (Int.fract a) a) (Neg.neg ↑(Int.floor a))","decl":"@[simp]\ntheorem fract_sub_self (a : α) : fract a - a = -⌊a⌋ :=\n  sub_sub_cancel_left _ _\n\n"}
{"name":"Int.fract_nonneg","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ LE.le 0 (Int.fract a)","decl":"@[simp]\ntheorem fract_nonneg (a : α) : 0 ≤ fract a :=\n  sub_nonneg.2 <| floor_le _\n\n"}
{"name":"Int.fract_pos","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Iff (LT.lt 0 (Int.fract a)) (Ne a ↑(Int.floor a))","decl":"/-- The fractional part of `a` is positive if and only if `a ≠ ⌊a⌋`. -/\nlemma fract_pos : 0 < fract a ↔ a ≠ ⌊a⌋ :=\n  (fract_nonneg a).lt_iff_ne.trans <| ne_comm.trans sub_ne_zero\n\n"}
{"name":"Int.fract_lt_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ LT.lt (Int.fract a) 1","decl":"theorem fract_lt_one (a : α) : fract a < 1 :=\n  sub_lt_comm.1 <| sub_one_lt_floor _\n\n"}
{"name":"Int.fract_zero","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\n⊢ Eq (Int.fract 0) 0","decl":"@[simp]\ntheorem fract_zero : fract (0 : α) = 0 := by rw [fract, floor_zero, cast_zero, sub_self]\n\n"}
{"name":"Int.fract_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\n⊢ Eq (Int.fract 1) 0","decl":"@[simp]\ntheorem fract_one : fract (1 : α) = 0 := by simp [fract]\n\n"}
{"name":"Int.abs_fract","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (abs (Int.fract a)) (Int.fract a)","decl":"theorem abs_fract : |fract a| = fract a :=\n  abs_eq_self.mpr <| fract_nonneg a\n\n"}
{"name":"Int.abs_one_sub_fract","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (abs (HSub.hSub 1 (Int.fract a))) (HSub.hSub 1 (Int.fract a))","decl":"@[simp]\ntheorem abs_one_sub_fract : |1 - fract a| = 1 - fract a :=\n  abs_eq_self.mpr <| sub_nonneg.mpr (fract_lt_one a).le\n\n"}
{"name":"Int.fract_intCast","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\n⊢ Eq (Int.fract ↑z) 0","decl":"@[simp]\ntheorem fract_intCast (z : ℤ) : fract (z : α) = 0 := by\n  unfold fract\n  rw [floor_intCast]\n  exact sub_self _\n\n"}
{"name":"Int.fract_natCast","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nn : Nat\n⊢ Eq (Int.fract ↑n) 0","decl":"@[simp]\ntheorem fract_natCast (n : ℕ) : fract (n : α) = 0 := by simp [fract]\n\n"}
{"name":"Int.fract_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Int.fract (OfNat.ofNat n)) 0","decl":"@[simp]\ntheorem fract_ofNat (n : ℕ) [n.AtLeastTwo] :\n    fract (ofNat(n) : α) = 0 :=\n  fract_natCast n\n\n"}
{"name":"Int.fract_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.fract ↑(Int.floor a)) 0","decl":"theorem fract_floor (a : α) : fract (⌊a⌋ : α) = 0 :=\n  fract_intCast _\n\n"}
{"name":"Int.floor_fract","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.floor (Int.fract a)) 0","decl":"@[simp]\ntheorem floor_fract (a : α) : ⌊fract a⌋ = 0 := by\n  rw [floor_eq_iff, Int.cast_zero, zero_add]; exact ⟨fract_nonneg _, fract_lt_one _⟩\n\n"}
{"name":"Int.fract_eq_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\n⊢ Iff (Eq (Int.fract a) b) (And (LE.le 0 b) (And (LT.lt b 1) (Exists fun z => Eq (HSub.hSub a b) ↑z)))","decl":"theorem fract_eq_iff {a b : α} : fract a = b ↔ 0 ≤ b ∧ b < 1 ∧ ∃ z : ℤ, a - b = z :=\n  ⟨fun h => by\n    rw [← h]\n    exact ⟨fract_nonneg _, fract_lt_one _, ⟨⌊a⌋, sub_sub_cancel _ _⟩⟩,\n   by\n    rintro ⟨h₀, h₁, z, hz⟩\n    rw [← self_sub_floor, eq_comm, eq_sub_iff_add_eq, add_comm, ← eq_sub_iff_add_eq, hz,\n      Int.cast_inj, floor_eq_iff, ← hz]\n    constructor <;> simpa [sub_eq_add_neg, add_assoc] ⟩\n\n"}
{"name":"Int.fract_eq_fract","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\n⊢ Iff (Eq (Int.fract a) (Int.fract b)) (Exists fun z => Eq (HSub.hSub a b) ↑z)","decl":"theorem fract_eq_fract {a b : α} : fract a = fract b ↔ ∃ z : ℤ, a - b = z :=\n  ⟨fun h => ⟨⌊a⌋ - ⌊b⌋, by unfold fract at h; rw [Int.cast_sub, sub_eq_sub_iff_sub_eq_sub.1 h]⟩,\n   by\n    rintro ⟨z, hz⟩\n    refine fract_eq_iff.2 ⟨fract_nonneg _, fract_lt_one _, z + ⌊b⌋, ?_⟩\n    rw [eq_add_of_sub_eq hz, add_comm, Int.cast_add]\n    exact add_sub_sub_cancel _ _ _⟩\n\n"}
{"name":"Int.fract_eq_self","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Iff (Eq (Int.fract a) a) (And (LE.le 0 a) (LT.lt a 1))","decl":"@[simp]\ntheorem fract_eq_self {a : α} : fract a = a ↔ 0 ≤ a ∧ a < 1 :=\n  fract_eq_iff.trans <| and_assoc.symm.trans <| and_iff_left ⟨0, by simp⟩\n\n"}
{"name":"Int.fract_fract","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.fract (Int.fract a)) (Int.fract a)","decl":"@[simp]\ntheorem fract_fract (a : α) : fract (fract a) = fract a :=\n  fract_eq_self.2 ⟨fract_nonneg _, fract_lt_one _⟩\n\n"}
{"name":"Int.fract_add","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\n⊢ Exists fun z => Eq (HSub.hSub (HSub.hSub (Int.fract (HAdd.hAdd a b)) (Int.fract a)) (Int.fract b)) ↑z","decl":"theorem fract_add (a b : α) : ∃ z : ℤ, fract (a + b) - fract a - fract b = z :=\n  ⟨⌊a⌋ + ⌊b⌋ - ⌊a + b⌋, by\n    unfold fract\n    simp only [sub_eq_add_neg, neg_add_rev, neg_neg, cast_add, cast_neg]\n    abel⟩\n\n"}
{"name":"Int.fract_neg","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nx : α\nhx : Ne (Int.fract x) 0\n⊢ Eq (Int.fract (Neg.neg x)) (HSub.hSub 1 (Int.fract x))","decl":"theorem fract_neg {x : α} (hx : fract x ≠ 0) : fract (-x) = 1 - fract x := by\n  rw [fract_eq_iff]\n  constructor\n  · rw [le_sub_iff_add_le, zero_add]\n    exact (fract_lt_one x).le\n  refine ⟨sub_lt_self _ (lt_of_le_of_ne' (fract_nonneg x) hx), -⌊x⌋ - 1, ?_⟩\n  simp only [sub_sub_eq_add_sub, cast_sub, cast_neg, cast_one, sub_left_inj]\n  conv in -x => rw [← floor_add_fract x]\n  simp [-floor_add_fract]\n\n"}
{"name":"Int.fract_neg_eq_zero","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nx : α\n⊢ Iff (Eq (Int.fract (Neg.neg x)) 0) (Eq (Int.fract x) 0)","decl":"@[simp]\ntheorem fract_neg_eq_zero {x : α} : fract (-x) = 0 ↔ fract x = 0 := by\n  simp only [fract_eq_iff, le_refl, zero_lt_one, tsub_zero, true_and]\n  constructor <;> rintro ⟨z, hz⟩ <;> use -z <;> simp [← hz]\n\n"}
{"name":"Int.fract_mul_nat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nb : Nat\n⊢ Exists fun z => Eq (HSub.hSub (HMul.hMul (Int.fract a) ↑b) (Int.fract (HMul.hMul a ↑b))) ↑z","decl":"theorem fract_mul_nat (a : α) (b : ℕ) : ∃ z : ℤ, fract a * b - fract (a * b) = z := by\n  induction' b with c hc\n  · use 0; simp\n  · rcases hc with ⟨z, hz⟩\n    rw [Nat.cast_add, mul_add, mul_add, Nat.cast_one, mul_one, mul_one]\n    rcases fract_add (a * c) a with ⟨y, hy⟩\n    use z - y\n    rw [Int.cast_sub, ← hz, ← hy]\n    abel\n\n-- Porting note: in mathlib3 there was no need for the type annotation in `(m:α)`\n"}
{"name":"Int.preimage_fract","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\ns : Set α\n⊢ Eq (Set.preimage Int.fract s) (Set.iUnion fun m => Set.preimage (fun x => HSub.hSub x ↑m) (Inter.inter s (Set.Ico 0 1)))","decl":"theorem preimage_fract (s : Set α) :\n    fract ⁻¹' s = ⋃ m : ℤ, (fun x => x - (m : α)) ⁻¹' (s ∩ Ico (0 : α) 1) := by\n  ext x\n  simp only [mem_preimage, mem_iUnion, mem_inter_iff]\n  refine ⟨fun h => ⟨⌊x⌋, h, fract_nonneg x, fract_lt_one x⟩, ?_⟩\n  rintro ⟨m, hms, hm0, hm1⟩\n  obtain rfl : ⌊x⌋ = m := floor_eq_iff.2 ⟨sub_nonneg.1 hm0, sub_lt_iff_lt_add'.1 hm1⟩\n  exact hms\n\n"}
{"name":"Int.image_fract","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\ns : Set α\n⊢ Eq (Set.image Int.fract s) (Set.iUnion fun m => Inter.inter (Set.image (fun x => HSub.hSub x ↑m) s) (Set.Ico 0 1))","decl":"theorem image_fract (s : Set α) : fract '' s = ⋃ m : ℤ, (fun x : α => x - m) '' s ∩ Ico 0 1 := by\n  ext x\n  simp only [mem_image, mem_inter_iff, mem_iUnion]; constructor\n  · rintro ⟨y, hy, rfl⟩\n    exact ⟨⌊y⌋, ⟨y, hy, rfl⟩, fract_nonneg y, fract_lt_one y⟩\n  · rintro ⟨m, ⟨y, hys, rfl⟩, h0, h1⟩\n    obtain rfl : ⌊y⌋ = m := floor_eq_iff.2 ⟨sub_nonneg.1 h0, sub_lt_iff_lt_add'.1 h1⟩\n    exact ⟨y, hys, rfl⟩\n\n"}
{"name":"Int.fract_div_mul_self_mem_Ico","module":"Mathlib.Algebra.Order.Floor","initialProofState":"k : Type u_4\ninst✝¹ : LinearOrderedField k\ninst✝ : FloorRing k\na b : k\nha : LT.lt 0 a\n⊢ Membership.mem (Set.Ico 0 a) (HMul.hMul (Int.fract (HDiv.hDiv b a)) a)","decl":"theorem fract_div_mul_self_mem_Ico (a b : k) (ha : 0 < a) : fract (b / a) * a ∈ Ico 0 a :=\n  ⟨(mul_nonneg_iff_of_pos_right ha).2 (fract_nonneg (b / a)),\n    (mul_lt_iff_lt_one_left ha).2 (fract_lt_one (b / a))⟩\n\n"}
{"name":"Int.fract_div_mul_self_add_zsmul_eq","module":"Mathlib.Algebra.Order.Floor","initialProofState":"k : Type u_4\ninst✝¹ : LinearOrderedField k\ninst✝ : FloorRing k\na b : k\nha : Ne a 0\n⊢ Eq (HAdd.hAdd (HMul.hMul (Int.fract (HDiv.hDiv b a)) a) (HSMul.hSMul (Int.floor (HDiv.hDiv b a)) a)) b","decl":"theorem fract_div_mul_self_add_zsmul_eq (a b : k) (ha : a ≠ 0) :\n    fract (b / a) * a + ⌊b / a⌋ • a = b := by\n  rw [zsmul_eq_mul, ← add_mul, fract_add_floor, div_mul_cancel₀ b ha]\n\n"}
{"name":"Int.sub_floor_div_mul_nonneg","module":"Mathlib.Algebra.Order.Floor","initialProofState":"k : Type u_4\ninst✝¹ : LinearOrderedField k\ninst✝ : FloorRing k\nb a : k\nhb : LT.lt 0 b\n⊢ LE.le 0 (HSub.hSub a (HMul.hMul (↑(Int.floor (HDiv.hDiv a b))) b))","decl":"theorem sub_floor_div_mul_nonneg (a : k) (hb : 0 < b) : 0 ≤ a - ⌊a / b⌋ * b :=\n  sub_nonneg_of_le <| (le_div_iff₀ hb).1 <| floor_le _\n\n"}
{"name":"Int.sub_floor_div_mul_lt","module":"Mathlib.Algebra.Order.Floor","initialProofState":"k : Type u_4\ninst✝¹ : LinearOrderedField k\ninst✝ : FloorRing k\nb a : k\nhb : LT.lt 0 b\n⊢ LT.lt (HSub.hSub a (HMul.hMul (↑(Int.floor (HDiv.hDiv a b))) b)) b","decl":"theorem sub_floor_div_mul_lt (a : k) (hb : 0 < b) : a - ⌊a / b⌋ * b < b :=\n  sub_lt_iff_lt_add.2 <| by\n    -- Porting note: `← one_add_mul` worked in mathlib3 without the argument\n    rw [← one_add_mul _ b, ← div_lt_iff₀ hb, add_comm]\n    exact lt_floor_add_one _\n\n"}
{"name":"Int.fract_div_natCast_eq_div_natCast_mod","module":"Mathlib.Algebra.Order.Floor","initialProofState":"k : Type u_4\ninst✝¹ : LinearOrderedField k\ninst✝ : FloorRing k\nm n : Nat\n⊢ Eq (Int.fract (HDiv.hDiv ↑m ↑n)) (HDiv.hDiv ↑(HMod.hMod m n) ↑n)","decl":"theorem fract_div_natCast_eq_div_natCast_mod {m n : ℕ} : fract ((m : k) / n) = ↑(m % n) / n := by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · simp\n  have hn' : 0 < (n : k) := by\n    norm_cast\n  refine fract_eq_iff.mpr ⟨?_, ?_, m / n, ?_⟩\n  · positivity\n  · simpa only [div_lt_one hn', Nat.cast_lt] using m.mod_lt hn\n  · rw [sub_eq_iff_eq_add', ← mul_right_inj' hn'.ne', mul_div_cancel₀ _ hn'.ne', mul_add,\n      mul_div_cancel₀ _ hn'.ne']\n    norm_cast\n    rw [← Nat.cast_add, Nat.mod_add_div m n]\n\n"}
{"name":"Int.fract_div_intCast_eq_div_intCast_mod","module":"Mathlib.Algebra.Order.Floor","initialProofState":"k : Type u_4\ninst✝¹ : LinearOrderedField k\ninst✝ : FloorRing k\nm : Int\nn : Nat\n⊢ Eq (Int.fract (HDiv.hDiv ↑m ↑n)) (HDiv.hDiv ↑(HMod.hMod m ↑n) ↑n)","decl":"theorem fract_div_intCast_eq_div_intCast_mod {m : ℤ} {n : ℕ} :\n    fract ((m : k) / n) = ↑(m % n) / n := by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · simp\n  replace hn : 0 < (n : k) := by norm_cast\n  have : ∀ {l : ℤ}, 0 ≤ l → fract ((l : k) / n) = ↑(l % n) / n := by\n    intros l hl\n    obtain ⟨l₀, rfl | rfl⟩ := l.eq_nat_or_neg\n    · rw [cast_natCast, ← natCast_mod, cast_natCast, fract_div_natCast_eq_div_natCast_mod]\n    · rw [Right.nonneg_neg_iff, natCast_nonpos_iff] at hl\n      simp [hl]\n  obtain ⟨m₀, rfl | rfl⟩ := m.eq_nat_or_neg\n  · exact this (ofNat_nonneg m₀)\n  let q := ⌈↑m₀ / (n : k)⌉\n  let m₁ := q * ↑n - (↑m₀ : ℤ)\n  have hm₁ : 0 ≤ m₁ := by\n    simpa [m₁, ← @cast_le k, ← div_le_iff₀ hn] using FloorRing.gc_ceil_coe.le_u_l _\n  calc\n    fract ((Int.cast (-(m₀ : ℤ)) : k) / (n : k))\n      -- Porting note: the `rw [cast_neg, cast_natCast]` was `push_cast`\n      = fract (-(m₀ : k) / n) := by rw [cast_neg, cast_natCast]\n    _ = fract ((m₁ : k) / n) := ?_\n    _ = Int.cast (m₁ % (n : ℤ)) / Nat.cast n := this hm₁\n    _ = Int.cast (-(↑m₀ : ℤ) % ↑n) / Nat.cast n := ?_\n\n  · rw [← fract_int_add q, ← mul_div_cancel_right₀ (q : k) hn.ne', ← add_div, ← sub_eq_add_neg]\n    -- Porting note: the `simp` was `push_cast`\n    simp [m₁]\n  · congr 2\n    change (q * ↑n - (↑m₀ : ℤ)) % ↑n = _\n    rw [sub_eq_add_neg, add_comm (q * ↑n), add_mul_emod_self]\n\n"}
{"name":"Int.gc_ceil_coe","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\n⊢ GaloisConnection Int.ceil Int.cast","decl":"theorem gc_ceil_coe : GaloisConnection ceil ((↑) : ℤ → α) :=\n  FloorRing.gc_ceil_coe\n\n"}
{"name":"Int.ceil_le","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\n⊢ Iff (LE.le (Int.ceil a) z) (LE.le a ↑z)","decl":"theorem ceil_le : ⌈a⌉ ≤ z ↔ a ≤ z :=\n  gc_ceil_coe a z\n\n"}
{"name":"Int.floor_neg","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.floor (Neg.neg a)) (Neg.neg (Int.ceil a))","decl":"theorem floor_neg : ⌊-a⌋ = -⌈a⌉ :=\n  eq_of_forall_le_iff fun z => by rw [le_neg, ceil_le, le_floor, Int.cast_neg, le_neg]\n\n"}
{"name":"Int.ceil_neg","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.ceil (Neg.neg a)) (Neg.neg (Int.floor a))","decl":"theorem ceil_neg : ⌈-a⌉ = -⌊a⌋ :=\n  eq_of_forall_ge_iff fun z => by rw [neg_le, ceil_le, le_floor, Int.cast_neg, neg_le]\n\n"}
{"name":"Int.lt_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\n⊢ Iff (LT.lt z (Int.ceil a)) (LT.lt (↑z) a)","decl":"theorem lt_ceil : z < ⌈a⌉ ↔ (z : α) < a :=\n  lt_iff_lt_of_le_iff_le ceil_le\n\n"}
{"name":"Int.add_one_le_ceil_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\n⊢ Iff (LE.le (HAdd.hAdd z 1) (Int.ceil a)) (LT.lt (↑z) a)","decl":"@[simp]\ntheorem add_one_le_ceil_iff : z + 1 ≤ ⌈a⌉ ↔ (z : α) < a := by rw [← lt_ceil, add_one_le_iff]\n\n"}
{"name":"Int.one_le_ceil_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Iff (LE.le 1 (Int.ceil a)) (LT.lt 0 a)","decl":"@[simp]\ntheorem one_le_ceil_iff : 1 ≤ ⌈a⌉ ↔ 0 < a := by\n  rw [← zero_add (1 : ℤ), add_one_le_ceil_iff, cast_zero]\n\n"}
{"name":"Int.ceil_le_floor_add_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ LE.le (Int.ceil a) (HAdd.hAdd (Int.floor a) 1)","decl":"@[bound]\ntheorem ceil_le_floor_add_one (a : α) : ⌈a⌉ ≤ ⌊a⌋ + 1 := by\n  rw [ceil_le, Int.cast_add, Int.cast_one]\n  exact (lt_floor_add_one a).le\n\n"}
{"name":"Int.le_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ LE.le a ↑(Int.ceil a)","decl":"@[bound]\ntheorem le_ceil (a : α) : a ≤ ⌈a⌉ :=\n  gc_ceil_coe.le_u_l a\n\n"}
{"name":"Int.le_ceil_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\n⊢ Iff (LE.le z (Int.ceil a)) (LT.lt (HSub.hSub (↑z) 1) a)","decl":"lemma le_ceil_iff : z ≤ ⌈a⌉ ↔ z - 1 < a := by rw [← sub_one_lt_iff, lt_ceil]; norm_cast\n"}
{"name":"Int.ceil_lt_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\n⊢ Iff (LT.lt (Int.ceil a) z) (LE.le a (HSub.hSub (↑z) 1))","decl":"lemma ceil_lt_iff : ⌈a⌉ < z ↔ a ≤ z - 1 := by rw [← le_sub_one_iff, ceil_le]; norm_cast\n\n"}
{"name":"Int.ceil_intCast","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\n⊢ Eq (Int.ceil ↑z) z","decl":"@[simp]\ntheorem ceil_intCast (z : ℤ) : ⌈(z : α)⌉ = z :=\n  eq_of_forall_ge_iff fun a => by rw [ceil_le, Int.cast_le]\n\n"}
{"name":"Int.ceil_natCast","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nn : Nat\n⊢ Eq (Int.ceil ↑n) ↑n","decl":"@[simp]\ntheorem ceil_natCast (n : ℕ) : ⌈(n : α)⌉ = n :=\n  eq_of_forall_ge_iff fun a => by rw [ceil_le, ← cast_natCast, cast_le]\n\n"}
{"name":"Int.ceil_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Int.ceil (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem ceil_ofNat (n : ℕ) [n.AtLeastTwo] : ⌈(ofNat(n) : α)⌉ = ofNat(n) := ceil_natCast n\n\n"}
{"name":"Int.ceil_mono","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\n⊢ Monotone Int.ceil","decl":"theorem ceil_mono : Monotone (ceil : α → ℤ) :=\n  gc_ceil_coe.monotone_l\n\n"}
{"name":"Int.ceil_le_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\nhab : LE.le a b\n⊢ LE.le (Int.ceil a) (Int.ceil b)","decl":"@[gcongr, bound] lemma ceil_le_ceil (hab : a ≤ b) : ⌈a⌉ ≤ ⌈b⌉ := ceil_mono hab\n\n"}
{"name":"Int.ceil_add_int","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nz : Int\n⊢ Eq (Int.ceil (HAdd.hAdd a ↑z)) (HAdd.hAdd (Int.ceil a) z)","decl":"@[simp]\ntheorem ceil_add_int (a : α) (z : ℤ) : ⌈a + z⌉ = ⌈a⌉ + z := by\n  rw [← neg_inj, neg_add', ← floor_neg, ← floor_neg, neg_add', floor_sub_int]\n\n"}
{"name":"Int.ceil_add_nat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nn : Nat\n⊢ Eq (Int.ceil (HAdd.hAdd a ↑n)) (HAdd.hAdd (Int.ceil a) ↑n)","decl":"@[simp]\ntheorem ceil_add_nat (a : α) (n : ℕ) : ⌈a + n⌉ = ⌈a⌉ + n := by rw [← Int.cast_natCast, ceil_add_int]\n\n"}
{"name":"Int.ceil_add_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.ceil (HAdd.hAdd a 1)) (HAdd.hAdd (Int.ceil a) 1)","decl":"@[simp]\ntheorem ceil_add_one (a : α) : ⌈a + 1⌉ = ⌈a⌉ + 1 := by\n  -- Porting note: broken `convert ceil_add_int a (1 : ℤ)`\n  rw [← ceil_add_int a (1 : ℤ), cast_one]\n\n"}
{"name":"Int.ceil_add_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\na : α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Int.ceil (HAdd.hAdd a (OfNat.ofNat n))) (HAdd.hAdd (Int.ceil a) (OfNat.ofNat n))","decl":"@[simp]\ntheorem ceil_add_ofNat (a : α) (n : ℕ) [n.AtLeastTwo] :\n    ⌈a + ofNat(n)⌉ = ⌈a⌉ + ofNat(n) :=\n  ceil_add_nat a n\n\n"}
{"name":"Int.ceil_sub_int","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nz : Int\n⊢ Eq (Int.ceil (HSub.hSub a ↑z)) (HSub.hSub (Int.ceil a) z)","decl":"@[simp]\ntheorem ceil_sub_int (a : α) (z : ℤ) : ⌈a - z⌉ = ⌈a⌉ - z :=\n  Eq.trans (by rw [Int.cast_neg, sub_eq_add_neg]) (ceil_add_int _ _)\n\n"}
{"name":"Int.ceil_sub_nat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nn : Nat\n⊢ Eq (Int.ceil (HSub.hSub a ↑n)) (HSub.hSub (Int.ceil a) ↑n)","decl":"@[simp]\ntheorem ceil_sub_nat (a : α) (n : ℕ) : ⌈a - n⌉ = ⌈a⌉ - n := by\n  convert ceil_sub_int a n using 1\n  simp\n\n"}
{"name":"Int.ceil_sub_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.ceil (HSub.hSub a 1)) (HSub.hSub (Int.ceil a) 1)","decl":"@[simp]\ntheorem ceil_sub_one (a : α) : ⌈a - 1⌉ = ⌈a⌉ - 1 := by\n  rw [eq_sub_iff_add_eq, ← ceil_add_one, sub_add_cancel]\n\n"}
{"name":"Int.ceil_sub_ofNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\na : α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Int.ceil (HSub.hSub a (OfNat.ofNat n))) (HSub.hSub (Int.ceil a) (OfNat.ofNat n))","decl":"@[simp]\ntheorem ceil_sub_ofNat (a : α) (n : ℕ) [n.AtLeastTwo] :\n    ⌈a - ofNat(n)⌉ = ⌈a⌉ - ofNat(n) :=\n  ceil_sub_nat a n\n\n"}
{"name":"Int.ceil_lt_add_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ LT.lt (↑(Int.ceil a)) (HAdd.hAdd a 1)","decl":"@[bound]\ntheorem ceil_lt_add_one (a : α) : (⌈a⌉ : α) < a + 1 := by\n  rw [← lt_ceil, ← Int.cast_one, ceil_add_int]\n  apply lt_add_one\n\n"}
{"name":"Int.ceil_add_le","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\n⊢ LE.le (Int.ceil (HAdd.hAdd a b)) (HAdd.hAdd (Int.ceil a) (Int.ceil b))","decl":"@[bound]\ntheorem ceil_add_le (a b : α) : ⌈a + b⌉ ≤ ⌈a⌉ + ⌈b⌉ := by\n  rw [ceil_le, Int.cast_add]\n  gcongr <;> apply le_ceil\n\n"}
{"name":"Int.ceil_add_ceil_le","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\n⊢ LE.le (HAdd.hAdd (Int.ceil a) (Int.ceil b)) (HAdd.hAdd (Int.ceil (HAdd.hAdd a b)) 1)","decl":"@[bound]\ntheorem ceil_add_ceil_le (a b : α) : ⌈a⌉ + ⌈b⌉ ≤ ⌈a + b⌉ + 1 := by\n  rw [← le_sub_iff_add_le, ceil_le, Int.cast_sub, Int.cast_add, Int.cast_one, le_sub_comm]\n  refine (ceil_lt_add_one _).le.trans ?_\n  rw [le_sub_iff_add_le', ← add_assoc, add_le_add_iff_right]\n  exact le_ceil _\n\n"}
{"name":"Int.ceil_pos","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Iff (LT.lt 0 (Int.ceil a)) (LT.lt 0 a)","decl":"@[simp]\ntheorem ceil_pos : 0 < ⌈a⌉ ↔ 0 < a := by rw [lt_ceil, cast_zero]\n\n"}
{"name":"Int.ceil_zero","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\n⊢ Eq (Int.ceil 0) 0","decl":"@[simp]\ntheorem ceil_zero : ⌈(0 : α)⌉ = 0 := by rw [← cast_zero, ceil_intCast]\n\n"}
{"name":"Int.ceil_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\n⊢ Eq (Int.ceil 1) 1","decl":"@[simp]\ntheorem ceil_one : ⌈(1 : α)⌉ = 1 := by rw [← cast_one, ceil_intCast]\n\n"}
{"name":"Int.ceil_nonneg","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nha : LE.le 0 a\n⊢ LE.le 0 (Int.ceil a)","decl":"@[bound]\ntheorem ceil_nonneg (ha : 0 ≤ a) : 0 ≤ ⌈a⌉ := mod_cast ha.trans (le_ceil a)\n\n"}
{"name":"Int.ceil_eq_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\n⊢ Iff (Eq (Int.ceil a) z) (And (LT.lt (HSub.hSub (↑z) 1) a) (LE.le a ↑z))","decl":"theorem ceil_eq_iff : ⌈a⌉ = z ↔ ↑z - 1 < a ∧ a ≤ z := by\n  rw [← ceil_le, ← Int.cast_one, ← Int.cast_sub, ← lt_ceil, Int.sub_one_lt_iff, le_antisymm_iff,\n    and_comm]\n\n"}
{"name":"Int.ceil_eq_zero_iff","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Iff (Eq (Int.ceil a) 0) (Membership.mem (Set.Ioc (-1) 0) a)","decl":"@[simp]\ntheorem ceil_eq_zero_iff : ⌈a⌉ = 0 ↔ a ∈ Ioc (-1 : α) 0 := by simp [ceil_eq_iff]\n\n"}
{"name":"Int.ceil_eq_on_Ioc","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\na✝ : Membership.mem (Set.Ioc (HSub.hSub (↑z) 1) ↑z) a\n⊢ Eq (Int.ceil a) z","decl":"theorem ceil_eq_on_Ioc (z : ℤ) : ∀ a ∈ Set.Ioc (z - 1 : α) z, ⌈a⌉ = z := fun _ ⟨h₀, h₁⟩ =>\n  ceil_eq_iff.mpr ⟨h₀, h₁⟩\n\n"}
{"name":"Int.ceil_eq_on_Ioc'","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nz : Int\na : α\na✝ : Membership.mem (Set.Ioc (HSub.hSub (↑z) 1) ↑z) a\n⊢ Eq ↑(Int.ceil a) ↑z","decl":"theorem ceil_eq_on_Ioc' (z : ℤ) : ∀ a ∈ Set.Ioc (z - 1 : α) z, (⌈a⌉ : α) = z := fun a ha =>\n  mod_cast ceil_eq_on_Ioc z a ha\n\n"}
{"name":"Int.floor_le_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ LE.le (Int.floor a) (Int.ceil a)","decl":"@[bound]\ntheorem floor_le_ceil (a : α) : ⌊a⌋ ≤ ⌈a⌉ :=\n  cast_le.1 <| (floor_le _).trans <| le_ceil _\n\n"}
{"name":"Int.floor_lt_ceil_of_lt","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\nh : LT.lt a b\n⊢ LT.lt (Int.floor a) (Int.ceil b)","decl":"@[bound]\ntheorem floor_lt_ceil_of_lt {a b : α} (h : a < b) : ⌊a⌋ < ⌈b⌉ :=\n  cast_lt.1 <| (floor_le a).trans_lt <| h.trans_le <| le_ceil b\n\n-- Porting note: in mathlib3 there was no need for the type annotation in `(m : α)`\n"}
{"name":"Int.preimage_ceil_singleton","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nm : Int\n⊢ Eq (Set.preimage Int.ceil (Singleton.singleton m)) (Set.Ioc (HSub.hSub (↑m) 1) ↑m)","decl":"@[simp]\ntheorem preimage_ceil_singleton (m : ℤ) : (ceil : α → ℤ) ⁻¹' {m} = Ioc ((m : α) - 1) m :=\n  ext fun _ => ceil_eq_iff\n\n"}
{"name":"Int.fract_eq_zero_or_add_one_sub_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Or (Eq (Int.fract a) 0) (Eq (Int.fract a) (HSub.hSub (HAdd.hAdd a 1) ↑(Int.ceil a)))","decl":"theorem fract_eq_zero_or_add_one_sub_ceil (a : α) : fract a = 0 ∨ fract a = a + 1 - (⌈a⌉ : α) := by\n  rcases eq_or_ne (fract a) 0 with ha | ha\n  · exact Or.inl ha\n  right\n  suffices (⌈a⌉ : α) = ⌊a⌋ + 1 by\n    rw [this, ← self_sub_fract]\n    abel\n  norm_cast\n  rw [ceil_eq_iff]\n  refine ⟨?_, _root_.le_of_lt <| by simp⟩\n  rw [cast_add, cast_one, add_tsub_cancel_right, ← self_sub_fract a, sub_lt_self_iff]\n  exact ha.symm.lt_of_le (fract_nonneg a)\n\n"}
{"name":"Int.ceil_eq_add_one_sub_fract","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nha : Ne (Int.fract a) 0\n⊢ Eq (↑(Int.ceil a)) (HSub.hSub (HAdd.hAdd a 1) (Int.fract a))","decl":"theorem ceil_eq_add_one_sub_fract (ha : fract a ≠ 0) : (⌈a⌉ : α) = a + 1 - fract a := by\n  rw [(or_iff_right ha).mp (fract_eq_zero_or_add_one_sub_ceil a)]\n  abel\n\n"}
{"name":"Int.ceil_sub_self_eq","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nha : Ne (Int.fract a) 0\n⊢ Eq (HSub.hSub (↑(Int.ceil a)) a) (HSub.hSub 1 (Int.fract a))","decl":"theorem ceil_sub_self_eq (ha : fract a ≠ 0) : (⌈a⌉ : α) - a = 1 - fract a := by\n  rw [(or_iff_right ha).mp (fract_eq_zero_or_add_one_sub_ceil a)]\n  abel\n\n"}
{"name":"Int.mul_lt_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"k : Type u_4\ninst✝¹ : LinearOrderedField k\ninst✝ : FloorRing k\na b : k\nhb₀ : LT.lt 0 b\nhb : LT.lt b 1\nhba : LE.le (↑(Int.ceil (HDiv.hDiv b (HSub.hSub 1 b)))) a\n⊢ LT.lt (HMul.hMul b a) ↑(Int.floor a)","decl":"lemma mul_lt_floor (hb₀ : 0 < b) (hb : b < 1) (hba : ⌈b / (1 - b)⌉ ≤ a) : b * a < ⌊a⌋ := by\n  calc\n    b * a < b * (⌊a⌋ + 1) := by gcongr; exacts [hb₀, lt_floor_add_one _]\n    _ ≤ ⌊a⌋ := by\n      rwa [_root_.mul_add_one, ← le_sub_iff_add_le', ← one_sub_mul, ← div_le_iff₀' (by linarith),\n        ← ceil_le, le_floor]\n\n"}
{"name":"Int.ceil_div_ceil_inv_sub_one","module":"Mathlib.Algebra.Order.Floor","initialProofState":"k : Type u_4\ninst✝¹ : LinearOrderedField k\ninst✝ : FloorRing k\na : k\nha : LE.le 1 a\n⊢ Eq (Int.ceil (HDiv.hDiv (↑(Int.ceil (Inv.inv (HSub.hSub a 1)))) a)) (Int.ceil (Inv.inv (HSub.hSub a 1)))","decl":"lemma ceil_div_ceil_inv_sub_one (ha : 1 ≤ a) : ⌈⌈(a - 1)⁻¹⌉ / a⌉ = ⌈(a - 1)⁻¹⌉ := by\n  obtain rfl | ha := ha.eq_or_lt\n  · simp\n  have : 0 < a - 1 := by linarith\n  have : 0 < ⌈(a - 1)⁻¹⌉ := ceil_pos.2 <| by positivity\n  refine le_antisymm (ceil_le.2 <| div_le_self (by positivity) ha.le) <| ?_\n  rw [le_ceil_iff, sub_lt_comm, div_eq_mul_inv, ← mul_one_sub,\n    ← lt_div_iff₀ (sub_pos.2 <| inv_lt_one_of_one_lt₀ ha)]\n  convert ceil_lt_add_one _ using 1\n  field_simp\n\n"}
{"name":"Int.ceil_lt_mul","module":"Mathlib.Algebra.Order.Floor","initialProofState":"k : Type u_4\ninst✝¹ : LinearOrderedField k\ninst✝ : FloorRing k\na b : k\nhb : LT.lt 1 b\nhba : LT.lt (HDiv.hDiv (↑(Int.ceil (Inv.inv (HSub.hSub b 1)))) b) a\n⊢ LT.lt (↑(Int.ceil a)) (HMul.hMul b a)","decl":"lemma ceil_lt_mul (hb : 1 < b) (hba : ⌈(b - 1)⁻¹⌉ / b < a) : ⌈a⌉ < b * a := by\n  obtain hab | hba := le_total a (b - 1)⁻¹\n  · calc\n      ⌈a⌉ ≤ (⌈(b - 1)⁻¹⌉ : k) := by gcongr\n      _ < b * a := by rwa [← div_lt_iff₀']; positivity\n  · rw [← sub_pos] at hb\n    calc\n      ⌈a⌉ < a + 1 := ceil_lt_add_one _\n      _ = a + (b - 1) * (b - 1)⁻¹ := by rw [mul_inv_cancel₀]; positivity\n      _ ≤ a + (b - 1) * a := by gcongr; positivity\n      _ = b * a := by rw [sub_one_mul, add_sub_cancel]\n\n"}
{"name":"Int.ceil_le_mul","module":"Mathlib.Algebra.Order.Floor","initialProofState":"k : Type u_4\ninst✝¹ : LinearOrderedField k\ninst✝ : FloorRing k\na b : k\nhb : LT.lt 1 b\nhba : LE.le (HDiv.hDiv (↑(Int.ceil (Inv.inv (HSub.hSub b 1)))) b) a\n⊢ LE.le (↑(Int.ceil a)) (HMul.hMul b a)","decl":"lemma ceil_le_mul (hb : 1 < b) (hba : ⌈(b - 1)⁻¹⌉ / b ≤ a) : ⌈a⌉ ≤ b * a := by\n  obtain rfl | hba := hba.eq_or_lt\n  · rw [ceil_div_ceil_inv_sub_one hb.le, mul_div_cancel₀]\n    positivity\n  · exact (ceil_lt_mul hb hba).le\n\n"}
{"name":"Int.div_two_lt_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"k : Type u_4\ninst✝¹ : LinearOrderedField k\ninst✝ : FloorRing k\na : k\nha : LE.le 1 a\n⊢ LT.lt (HDiv.hDiv a 2) ↑(Int.floor a)","decl":"lemma div_two_lt_floor (ha : 1 ≤ a) : a / 2 < ⌊a⌋ := by\n  rw [div_eq_inv_mul]; refine mul_lt_floor ?_ ?_ ?_ <;> norm_num; assumption\n\n"}
{"name":"Int.ceil_lt_two_mul","module":"Mathlib.Algebra.Order.Floor","initialProofState":"k : Type u_4\ninst✝¹ : LinearOrderedField k\ninst✝ : FloorRing k\na : k\nha : LT.lt (Inv.inv 2) a\n⊢ LT.lt (↑(Int.ceil a)) (HMul.hMul 2 a)","decl":"lemma ceil_lt_two_mul (ha : 2⁻¹ < a) : ⌈a⌉ < 2 * a :=\n  ceil_lt_mul one_lt_two (by norm_num at ha ⊢; exact ha)\n\n"}
{"name":"Int.ceil_le_two_mul","module":"Mathlib.Algebra.Order.Floor","initialProofState":"k : Type u_4\ninst✝¹ : LinearOrderedField k\ninst✝ : FloorRing k\na : k\nha : LE.le (Inv.inv 2) a\n⊢ LE.le (↑(Int.ceil a)) (HMul.hMul 2 a)","decl":"lemma ceil_le_two_mul (ha : 2⁻¹ ≤ a) : ⌈a⌉ ≤ 2 * a :=\n  ceil_le_mul one_lt_two (by norm_num at ha ⊢; exact ha)\n\n"}
{"name":"Int.preimage_Ioo","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\n⊢ Eq (Set.preimage Int.cast (Set.Ioo a b)) (Set.Ioo (Int.floor a) (Int.ceil b))","decl":"@[simp]\ntheorem preimage_Ioo {a b : α} : ((↑) : ℤ → α) ⁻¹' Set.Ioo a b = Set.Ioo ⌊a⌋ ⌈b⌉ := by\n  ext\n  simp [floor_lt, lt_ceil]\n\n"}
{"name":"Int.preimage_Ico","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\n⊢ Eq (Set.preimage Int.cast (Set.Ico a b)) (Set.Ico (Int.ceil a) (Int.ceil b))","decl":"@[simp]\ntheorem preimage_Ico {a b : α} : ((↑) : ℤ → α) ⁻¹' Set.Ico a b = Set.Ico ⌈a⌉ ⌈b⌉ := by\n  ext\n  simp [ceil_le, lt_ceil]\n\n"}
{"name":"Int.preimage_Ioc","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\n⊢ Eq (Set.preimage Int.cast (Set.Ioc a b)) (Set.Ioc (Int.floor a) (Int.floor b))","decl":"@[simp]\ntheorem preimage_Ioc {a b : α} : ((↑) : ℤ → α) ⁻¹' Set.Ioc a b = Set.Ioc ⌊a⌋ ⌊b⌋ := by\n  ext\n  simp [floor_lt, le_floor]\n\n"}
{"name":"Int.preimage_Icc","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na b : α\n⊢ Eq (Set.preimage Int.cast (Set.Icc a b)) (Set.Icc (Int.ceil a) (Int.floor b))","decl":"@[simp]\ntheorem preimage_Icc {a b : α} : ((↑) : ℤ → α) ⁻¹' Set.Icc a b = Set.Icc ⌈a⌉ ⌊b⌋ := by\n  ext\n  simp [ceil_le, le_floor]\n\n"}
{"name":"Int.preimage_Ioi","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Set.preimage Int.cast (Set.Ioi a)) (Set.Ioi (Int.floor a))","decl":"@[simp]\ntheorem preimage_Ioi : ((↑) : ℤ → α) ⁻¹' Set.Ioi a = Set.Ioi ⌊a⌋ := by\n  ext\n  simp [floor_lt]\n\n"}
{"name":"Int.preimage_Ici","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Set.preimage Int.cast (Set.Ici a)) (Set.Ici (Int.ceil a))","decl":"@[simp]\ntheorem preimage_Ici : ((↑) : ℤ → α) ⁻¹' Set.Ici a = Set.Ici ⌈a⌉ := by\n  ext\n  simp [ceil_le]\n\n"}
{"name":"Int.preimage_Iio","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Set.preimage Int.cast (Set.Iio a)) (Set.Iio (Int.ceil a))","decl":"@[simp]\ntheorem preimage_Iio : ((↑) : ℤ → α) ⁻¹' Set.Iio a = Set.Iio ⌈a⌉ := by\n  ext\n  simp [lt_ceil]\n\n"}
{"name":"Int.preimage_Iic","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Set.preimage Int.cast (Set.Iic a)) (Set.Iic (Int.floor a))","decl":"@[simp]\ntheorem preimage_Iic : ((↑) : ℤ → α) ⁻¹' Set.Iic a = Set.Iic ⌊a⌋ := by\n  ext\n  simp [le_floor]\n\n"}
{"name":"Nat.floor_congr","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : LinearOrderedSemiring α\ninst✝² : LinearOrderedSemiring β\ninst✝¹ : FloorSemiring α\ninst✝ : FloorSemiring β\na : α\nb : β\nh : ∀ (n : Nat), Iff (LE.le (↑n) a) (LE.le (↑n) b)\n⊢ Eq (Nat.floor a) (Nat.floor b)","decl":"theorem floor_congr (h : ∀ n : ℕ, (n : α) ≤ a ↔ (n : β) ≤ b) : ⌊a⌋₊ = ⌊b⌋₊ := by\n  have h₀ : 0 ≤ a ↔ 0 ≤ b := by simpa only [cast_zero] using h 0\n  obtain ha | ha := lt_or_le a 0\n  · rw [floor_of_nonpos ha.le, floor_of_nonpos (le_of_not_le <| h₀.not.mp ha.not_le)]\n  exact (le_floor <| (h _).1 <| floor_le ha).antisymm (le_floor <| (h _).2 <| floor_le <| h₀.1 ha)\n\n"}
{"name":"Nat.ceil_congr","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : LinearOrderedSemiring α\ninst✝² : LinearOrderedSemiring β\ninst✝¹ : FloorSemiring α\ninst✝ : FloorSemiring β\na : α\nb : β\nh : ∀ (n : Nat), Iff (LE.le a ↑n) (LE.le b ↑n)\n⊢ Eq (Nat.ceil a) (Nat.ceil b)","decl":"theorem ceil_congr (h : ∀ n : ℕ, a ≤ n ↔ b ≤ n) : ⌈a⌉₊ = ⌈b⌉₊ :=\n  (ceil_le.2 <| (h _).2 <| le_ceil _).antisymm <| ceil_le.2 <| (h _).1 <| le_ceil _\n\n"}
{"name":"Nat.map_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : LinearOrderedSemiring β\ninst✝³ : FloorSemiring α\ninst✝² : FloorSemiring β\ninst✝¹ : FunLike F α β\ninst✝ : RingHomClass F α β\nf : F\nhf : StrictMono ⇑f\na : α\n⊢ Eq (Nat.floor (f a)) (Nat.floor a)","decl":"theorem map_floor (f : F) (hf : StrictMono f) (a : α) : ⌊f a⌋₊ = ⌊a⌋₊ :=\n  floor_congr fun n => by rw [← map_natCast f, hf.le_iff_le]\n\n"}
{"name":"Nat.map_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedSemiring α\ninst✝⁴ : LinearOrderedSemiring β\ninst✝³ : FloorSemiring α\ninst✝² : FloorSemiring β\ninst✝¹ : FunLike F α β\ninst✝ : RingHomClass F α β\nf : F\nhf : StrictMono ⇑f\na : α\n⊢ Eq (Nat.ceil (f a)) (Nat.ceil a)","decl":"theorem map_ceil (f : F) (hf : StrictMono f) (a : α) : ⌈f a⌉₊ = ⌈a⌉₊ :=\n  ceil_congr fun n => by rw [← map_natCast f, hf.le_iff_le]\n\n"}
{"name":"Int.floor_congr","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : LinearOrderedRing α\ninst✝² : LinearOrderedRing β\ninst✝¹ : FloorRing α\ninst✝ : FloorRing β\na : α\nb : β\nh : ∀ (n : Int), Iff (LE.le (↑n) a) (LE.le (↑n) b)\n⊢ Eq (Int.floor a) (Int.floor b)","decl":"theorem floor_congr (h : ∀ n : ℤ, (n : α) ≤ a ↔ (n : β) ≤ b) : ⌊a⌋ = ⌊b⌋ :=\n  (le_floor.2 <| (h _).1 <| floor_le _).antisymm <| le_floor.2 <| (h _).2 <| floor_le _\n\n"}
{"name":"Int.ceil_congr","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : LinearOrderedRing α\ninst✝² : LinearOrderedRing β\ninst✝¹ : FloorRing α\ninst✝ : FloorRing β\na : α\nb : β\nh : ∀ (n : Int), Iff (LE.le a ↑n) (LE.le b ↑n)\n⊢ Eq (Int.ceil a) (Int.ceil b)","decl":"theorem ceil_congr (h : ∀ n : ℤ, a ≤ n ↔ b ≤ n) : ⌈a⌉ = ⌈b⌉ :=\n  (ceil_le.2 <| (h _).2 <| le_ceil _).antisymm <| ceil_le.2 <| (h _).1 <| le_ceil _\n\n"}
{"name":"Int.map_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedRing α\ninst✝⁴ : LinearOrderedRing β\ninst✝³ : FloorRing α\ninst✝² : FloorRing β\ninst✝¹ : FunLike F α β\ninst✝ : RingHomClass F α β\nf : F\nhf : StrictMono ⇑f\na : α\n⊢ Eq (Int.floor (f a)) (Int.floor a)","decl":"theorem map_floor (f : F) (hf : StrictMono f) (a : α) : ⌊f a⌋ = ⌊a⌋ :=\n  floor_congr fun n => by rw [← map_intCast f, hf.le_iff_le]\n\n"}
{"name":"Int.map_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedRing α\ninst✝⁴ : LinearOrderedRing β\ninst✝³ : FloorRing α\ninst✝² : FloorRing β\ninst✝¹ : FunLike F α β\ninst✝ : RingHomClass F α β\nf : F\nhf : StrictMono ⇑f\na : α\n⊢ Eq (Int.ceil (f a)) (Int.ceil a)","decl":"theorem map_ceil (f : F) (hf : StrictMono f) (a : α) : ⌈f a⌉ = ⌈a⌉ :=\n  ceil_congr fun n => by rw [← map_intCast f, hf.le_iff_le]\n\n"}
{"name":"Int.map_fract","module":"Mathlib.Algebra.Order.Floor","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedRing α\ninst✝⁴ : LinearOrderedRing β\ninst✝³ : FloorRing α\ninst✝² : FloorRing β\ninst✝¹ : FunLike F α β\ninst✝ : RingHomClass F α β\nf : F\nhf : StrictMono ⇑f\na : α\n⊢ Eq (Int.fract (f a)) (f (Int.fract a))","decl":"theorem map_fract (f : F) (hf : StrictMono f) (a : α) : fract (f a) = f (fract a) := by\n  simp_rw [fract, map_sub, map_intCast, map_floor _ hf]\n\n"}
{"name":"Int.floor_toNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.floor a).toNat (Nat.floor a)","decl":"theorem Int.floor_toNat (a : α) : ⌊a⌋.toNat = ⌊a⌋₊ :=\n  rfl\n\n"}
{"name":"Int.ceil_toNat","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (Int.ceil a).toNat (Nat.ceil a)","decl":"theorem Int.ceil_toNat (a : α) : ⌈a⌉.toNat = ⌈a⌉₊ :=\n  rfl\n\n"}
{"name":"Nat.floor_int","module":"Mathlib.Algebra.Order.Floor","initialProofState":"⊢ Eq Nat.floor Int.toNat","decl":"@[simp]\ntheorem Nat.floor_int : (Nat.floor : ℤ → ℕ) = Int.toNat :=\n  rfl\n\n"}
{"name":"Nat.ceil_int","module":"Mathlib.Algebra.Order.Floor","initialProofState":"⊢ Eq Nat.ceil Int.toNat","decl":"@[simp]\ntheorem Nat.ceil_int : (Nat.ceil : ℤ → ℕ) = Int.toNat :=\n  rfl\n\n"}
{"name":"Int.natCast_floor_eq_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nha : LE.le 0 a\n⊢ Eq (↑(Nat.floor a)) (Int.floor a)","decl":"theorem Int.natCast_floor_eq_floor (ha : 0 ≤ a) : (⌊a⌋₊ : ℤ) = ⌊a⌋ := by\n  rw [← Int.floor_toNat, Int.toNat_of_nonneg (Int.floor_nonneg.2 ha)]\n\n"}
{"name":"Int.natCast_ceil_eq_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nha : LE.le 0 a\n⊢ Eq (↑(Nat.ceil a)) (Int.ceil a)","decl":"theorem Int.natCast_ceil_eq_ceil (ha : 0 ≤ a) : (⌈a⌉₊ : ℤ) = ⌈a⌉ := by\n  rw [← Int.ceil_toNat, Int.toNat_of_nonneg (Int.ceil_nonneg ha)]\n\n"}
{"name":"natCast_floor_eq_intCast_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nha : LE.le 0 a\n⊢ Eq ↑(Nat.floor a) ↑(Int.floor a)","decl":"theorem natCast_floor_eq_intCast_floor (ha : 0 ≤ a) : (⌊a⌋₊ : α) = ⌊a⌋ := by\n  rw [← Int.natCast_floor_eq_floor ha, Int.cast_natCast]\n\n"}
{"name":"natCast_ceil_eq_intCast_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nha : LE.le 0 a\n⊢ Eq ↑(Nat.ceil a) ↑(Int.ceil a)","decl":"theorem natCast_ceil_eq_intCast_ceil (ha : 0 ≤ a) : (⌈a⌉₊ : α) = ⌈a⌉ := by\n  rw [← Int.natCast_ceil_eq_ceil ha, Int.cast_natCast]\n\n"}
{"name":"Int.ofNat_floor_eq_floor","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nha : LE.le 0 a\n⊢ Eq (↑(Nat.floor a)) (Int.floor a)","decl":"@[deprecated (since := \"2024-08-20\")] alias Int.ofNat_floor_eq_floor := natCast_floor_eq_floor\n"}
{"name":"Int.ofNat_ceil_eq_ceil","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\nha : LE.le 0 a\n⊢ Eq (↑(Nat.ceil a)) (Int.ceil a)","decl":"@[deprecated (since := \"2024-08-20\")] alias Int.ofNat_ceil_eq_ceil := natCast_ceil_eq_ceil\n\n"}
{"name":"subsingleton_floorRing","module":"Mathlib.Algebra.Order.Floor","initialProofState":"α : Type u_4\ninst✝ : LinearOrderedRing α\n⊢ Subsingleton (FloorRing α)","decl":"/-- There exists at most one `FloorRing` structure on a given linear ordered ring. -/\ntheorem subsingleton_floorRing {α} [LinearOrderedRing α] : Subsingleton (FloorRing α) := by\n  refine ⟨fun H₁ H₂ => ?_⟩\n  have : H₁.floor = H₂.floor :=\n    funext fun a => (H₁.gc_coe_floor.u_unique H₂.gc_coe_floor) fun _ => rfl\n  have : H₁.ceil = H₂.ceil := funext fun a => (H₁.gc_ceil_coe.l_unique H₂.gc_ceil_coe) fun _ => rfl\n  cases H₁; cases H₂; congr\n\n"}
