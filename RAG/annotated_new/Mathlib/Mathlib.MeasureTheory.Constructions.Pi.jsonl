{"name":"MeasureTheory.piPremeasure_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝ : Fintype ι\nm : (i : ι) → MeasureTheory.OuterMeasure (α i)\ns : (i : ι) → Set (α i)\nhs : (Set.univ.pi s).Nonempty\n⊢ Eq (MeasureTheory.piPremeasure m (Set.univ.pi s)) (Finset.univ.prod fun i => (m i) (s i))","decl":"theorem piPremeasure_pi {s : ∀ i, Set (α i)} (hs : (pi univ s).Nonempty) :\n    piPremeasure m (pi univ s) = ∏ i, m i (s i) := by simp [hs, piPremeasure]\n\n"}
{"name":"MeasureTheory.piPremeasure_pi'","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝ : Fintype ι\nm : (i : ι) → MeasureTheory.OuterMeasure (α i)\ns : (i : ι) → Set (α i)\n⊢ Eq (MeasureTheory.piPremeasure m (Set.univ.pi s)) (Finset.univ.prod fun i => (m i) (s i))","decl":"theorem piPremeasure_pi' {s : ∀ i, Set (α i)} : piPremeasure m (pi univ s) = ∏ i, m i (s i) := by\n  cases isEmpty_or_nonempty ι\n  · simp [piPremeasure]\n  rcases (pi univ s).eq_empty_or_nonempty with h | h\n  · rcases univ_pi_eq_empty_iff.mp h with ⟨i, hi⟩\n    have : ∃ i, m i (s i) = 0 := ⟨i, by simp [hi]⟩\n    simpa [h, Finset.card_univ, zero_pow Fintype.card_ne_zero, @eq_comm _ (0 : ℝ≥0∞),\n      Finset.prod_eq_zero_iff, piPremeasure]\n  · simp [h, piPremeasure]\n\n"}
{"name":"MeasureTheory.piPremeasure_pi_mono","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝ : Fintype ι\nm : (i : ι) → MeasureTheory.OuterMeasure (α i)\ns t : Set ((i : ι) → α i)\nh : HasSubset.Subset s t\n⊢ LE.le (MeasureTheory.piPremeasure m s) (MeasureTheory.piPremeasure m t)","decl":"theorem piPremeasure_pi_mono {s t : Set (∀ i, α i)} (h : s ⊆ t) :\n    piPremeasure m s ≤ piPremeasure m t :=\n  Finset.prod_le_prod' fun _ _ => measure_mono (image_subset _ h)\n\n"}
{"name":"MeasureTheory.piPremeasure_pi_eval","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝ : Fintype ι\nm : (i : ι) → MeasureTheory.OuterMeasure (α i)\ns : Set ((i : ι) → α i)\n⊢ Eq (MeasureTheory.piPremeasure m (Set.univ.pi fun i => Set.image (Function.eval i) s)) (MeasureTheory.piPremeasure m s)","decl":"theorem piPremeasure_pi_eval {s : Set (∀ i, α i)} :\n    piPremeasure m (pi univ fun i => eval i '' s) = piPremeasure m s := by\n  simp only [eval, piPremeasure_pi']; rfl\n\n"}
{"name":"MeasureTheory.OuterMeasure.pi_pi_le","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝ : Fintype ι\nm : (i : ι) → MeasureTheory.OuterMeasure (α i)\ns : (i : ι) → Set (α i)\n⊢ LE.le ((MeasureTheory.OuterMeasure.pi m) (Set.univ.pi s)) (Finset.univ.prod fun i => (m i) (s i))","decl":"theorem pi_pi_le (m : ∀ i, OuterMeasure (α i)) (s : ∀ i, Set (α i)) :\n    OuterMeasure.pi m (pi univ s) ≤ ∏ i, m i (s i) := by\n  rcases (pi univ s).eq_empty_or_nonempty with h | h\n  · simp [h]\n  exact (boundedBy_le _).trans_eq (piPremeasure_pi h)\n\n"}
{"name":"MeasureTheory.OuterMeasure.le_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝ : Fintype ι\nm : (i : ι) → MeasureTheory.OuterMeasure (α i)\nn : MeasureTheory.OuterMeasure ((i : ι) → α i)\n⊢ Iff (LE.le n (MeasureTheory.OuterMeasure.pi m)) (∀ (s : (i : ι) → Set (α i)), (Set.univ.pi s).Nonempty → LE.le (n (Set.univ.pi s)) (Finset.univ.prod fun i => (m i) (s i)))","decl":"theorem le_pi {m : ∀ i, OuterMeasure (α i)} {n : OuterMeasure (∀ i, α i)} :\n    n ≤ OuterMeasure.pi m ↔\n      ∀ s : ∀ i, Set (α i), (pi univ s).Nonempty → n (pi univ s) ≤ ∏ i, m i (s i) := by\n  rw [OuterMeasure.pi, le_boundedBy']; constructor\n  · intro h s hs; refine (h _ hs).trans_eq (piPremeasure_pi hs)\n  · intro h s hs; refine le_trans (n.mono <| subset_pi_eval_image univ s) (h _ ?_)\n    simp [univ_pi_nonempty_iff, hs]\n\n"}
{"name":"MeasureTheory.Measure.tprod_nil","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"δ : Type u_4\nπ : δ → Type u_5\ninst✝ : (x : δ) → MeasurableSpace (π x)\nμ : (i : δ) → MeasureTheory.Measure (π i)\n⊢ Eq (MeasureTheory.Measure.tprod List.nil μ) (MeasureTheory.Measure.dirac PUnit.unit)","decl":"@[simp]\ntheorem tprod_nil (μ : ∀ i, Measure (π i)) : Measure.tprod [] μ = dirac PUnit.unit :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.tprod_cons","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"δ : Type u_4\nπ : δ → Type u_5\ninst✝ : (x : δ) → MeasurableSpace (π x)\ni : δ\nl : List δ\nμ : (i : δ) → MeasureTheory.Measure (π i)\n⊢ Eq (MeasureTheory.Measure.tprod (List.cons i l) μ) ((μ i).prod (MeasureTheory.Measure.tprod l μ))","decl":"@[simp]\ntheorem tprod_cons (i : δ) (l : List δ) (μ : ∀ i, Measure (π i)) :\n    Measure.tprod (i :: l) μ = (μ i).prod (Measure.tprod l μ) :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.sigmaFinite_tprod","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"δ : Type u_4\nπ : δ → Type u_5\ninst✝¹ : (x : δ) → MeasurableSpace (π x)\nl : List δ\nμ : (i : δ) → MeasureTheory.Measure (π i)\ninst✝ : ∀ (i : δ), MeasureTheory.SigmaFinite (μ i)\n⊢ MeasureTheory.SigmaFinite (MeasureTheory.Measure.tprod l μ)","decl":"instance sigmaFinite_tprod (l : List δ) (μ : ∀ i, Measure (π i)) [∀ i, SigmaFinite (μ i)] :\n    SigmaFinite (Measure.tprod l μ) := by\n  induction l with\n  | nil => rw [tprod_nil]; infer_instance\n  | cons i l ih => rw [tprod_cons]; exact @prod.instSigmaFinite _ _ _ _ _ _ _ ih\n\n"}
{"name":"MeasureTheory.Measure.tprod_tprod","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"δ : Type u_4\nπ : δ → Type u_5\ninst✝¹ : (x : δ) → MeasurableSpace (π x)\nl : List δ\nμ : (i : δ) → MeasureTheory.Measure (π i)\ninst✝ : ∀ (i : δ), MeasureTheory.SigmaFinite (μ i)\ns : (i : δ) → Set (π i)\n⊢ Eq ((MeasureTheory.Measure.tprod l μ) (Set.tprod l s)) (List.map (fun i => (μ i) (s i)) l).prod","decl":"theorem tprod_tprod (l : List δ) (μ : ∀ i, Measure (π i)) [∀ i, SigmaFinite (μ i)]\n    (s : ∀ i, Set (π i)) :\n    Measure.tprod l μ (Set.tprod l s) = (l.map fun i => (μ i) (s i)).prod := by\n  induction l with\n  | nil => simp\n  | cons a l ih =>\n    rw [tprod_cons, Set.tprod]\n    erw [prod_prod] -- TODO: why `rw` fails?\n    rw [map_cons, prod_cons, ih]\n\n"}
{"name":"MeasureTheory.Measure.pi'_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : Encodable ι\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ns : (i : ι) → Set (α i)\n⊢ Eq ((MeasureTheory.Measure.pi' μ) (Set.univ.pi s)) (Finset.univ.prod fun i => (μ i) (s i))","decl":"theorem pi'_pi [∀ i, SigmaFinite (μ i)] (s : ∀ i, Set (α i)) :\n    pi' μ (pi univ s) = ∏ i, μ i (s i) := by\n  classical\n  rw [pi']\n  rw [← MeasurableEquiv.piMeasurableEquivTProd_symm_apply, MeasurableEquiv.map_apply,\n    MeasurableEquiv.piMeasurableEquivTProd_symm_apply, elim_preimage_pi, tprod_tprod _ μ, ←\n    List.prod_toFinset, sortedUniv_toFinset] <;>\n  exact sortedUniv_nodup ι\n\n"}
{"name":"MeasureTheory.Measure.pi_caratheodory","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\n⊢ LE.le MeasurableSpace.pi (MeasureTheory.OuterMeasure.pi fun i => (μ i).toOuterMeasure).caratheodory","decl":"theorem pi_caratheodory :\n    MeasurableSpace.pi ≤ (OuterMeasure.pi fun i => (μ i).toOuterMeasure).caratheodory := by\n  refine iSup_le ?_\n  intro i s hs\n  rw [MeasurableSpace.comap] at hs\n  rcases hs with ⟨s, hs, rfl⟩\n  apply boundedBy_caratheodory\n  intro t\n  simp_rw [piPremeasure]\n  refine Finset.prod_add_prod_le' (Finset.mem_univ i) ?_ ?_ ?_\n  · simp [image_inter_preimage, image_diff_preimage, measure_inter_add_diff _ hs, le_refl]\n  · rintro j - _; gcongr; apply inter_subset_left\n  · rintro j - _; gcongr; apply diff_subset\n\n"}
{"name":"MeasureTheory.Measure.pi_def","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_4\nα : ι → Type u_5\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\n⊢ Eq (MeasureTheory.Measure.pi μ) ((MeasureTheory.OuterMeasure.pi fun i => (μ i).toOuterMeasure).toMeasure ⋯)","decl":"/-- `Measure.pi μ` is the finite product of the measures `{μ i | i : ι}`.\n  It is defined to be measure corresponding to `MeasureTheory.OuterMeasure.pi`. -/\nprotected irreducible_def pi : Measure (∀ i, α i) :=\n  toMeasure (OuterMeasure.pi fun i => (μ i).toOuterMeasure) (pi_caratheodory μ)\n\n-- Porting note: moved from below so that instances about `Measure.pi` and `MeasureSpace.pi`\n-- go together\n"}
{"name":"MeasureTheory.Measure.pi_pi_aux","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ns : (i : ι) → Set (α i)\nhs : ∀ (i : ι), MeasurableSet (s i)\n⊢ Eq ((MeasureTheory.Measure.pi μ) (Set.univ.pi s)) (Finset.univ.prod fun i => (μ i) (s i))","decl":"theorem pi_pi_aux [∀ i, SigmaFinite (μ i)] (s : ∀ i, Set (α i)) (hs : ∀ i, MeasurableSet (s i)) :\n    Measure.pi μ (pi univ s) = ∏ i, μ i (s i) := by\n  refine le_antisymm ?_ ?_\n  · rw [Measure.pi, toMeasure_apply _ _ (MeasurableSet.pi countable_univ fun i _ => hs i)]\n    apply OuterMeasure.pi_pi_le\n  · haveI : Encodable ι := Fintype.toEncodable ι\n    simp_rw [← pi'_pi μ s, Measure.pi,\n      toMeasure_apply _ _ (MeasurableSet.pi countable_univ fun i _ => hs i)]\n    suffices (pi' μ).toOuterMeasure ≤ OuterMeasure.pi fun i => (μ i).toOuterMeasure by exact this _\n    clear hs s\n    rw [OuterMeasure.le_pi]\n    intro s _\n    exact (pi'_pi μ s).le\n\n"}
{"name":"MeasureTheory.Measure.pi_eq_generateFrom","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\nC : (i : ι) → Set (Set (α i))\nhC : ∀ (i : ι), Eq (MeasurableSpace.generateFrom (C i)) (inst✝ i)\nh2C : ∀ (i : ι), IsPiSystem (C i)\nh3C : (i : ι) → (μ i).FiniteSpanningSetsIn (C i)\nμν : MeasureTheory.Measure ((i : ι) → α i)\nh₁ : ∀ (s : (i : ι) → Set (α i)), (∀ (i : ι), Membership.mem (C i) (s i)) → Eq (μν (Set.univ.pi s)) (Finset.univ.prod fun i => (μ i) (s i))\n⊢ Eq (MeasureTheory.Measure.pi μ) μν","decl":"/-- A measure on a finite product space equals the product measure if they are equal on rectangles\n  with as sides sets that generate the corresponding σ-algebras. -/\ntheorem pi_eq_generateFrom {C : ∀ i, Set (Set (α i))}\n    (hC : ∀ i, generateFrom (C i) = by apply_assumption) (h2C : ∀ i, IsPiSystem (C i))\n    (h3C : ∀ i, (μ i).FiniteSpanningSetsIn (C i)) {μν : Measure (∀ i, α i)}\n    (h₁ : ∀ s : ∀ i, Set (α i), (∀ i, s i ∈ C i) → μν (pi univ s) = ∏ i, μ i (s i)) :\n    Measure.pi μ = μν := by\n  have h4C : ∀ (i) (s : Set (α i)), s ∈ C i → MeasurableSet s := by\n    intro i s hs; rw [← hC]; exact measurableSet_generateFrom hs\n  refine\n    (FiniteSpanningSetsIn.pi h3C).ext\n      (generateFrom_eq_pi hC fun i => (h3C i).isCountablySpanning).symm (IsPiSystem.pi h2C) ?_\n  rintro _ ⟨s, hs, rfl⟩\n  rw [mem_univ_pi] at hs\n  haveI := fun i => (h3C i).sigmaFinite\n  simp_rw [h₁ s hs, pi_pi_aux μ s fun i => h4C i _ (hs i)]\n\n"}
{"name":"MeasureTheory.Measure.pi_eq","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\nμ' : MeasureTheory.Measure ((i : ι) → α i)\nh : ∀ (s : (i : ι) → Set (α i)), (∀ (i : ι), MeasurableSet (s i)) → Eq (μ' (Set.univ.pi s)) (Finset.univ.prod fun i => (μ i) (s i))\n⊢ Eq (MeasureTheory.Measure.pi μ) μ'","decl":"/-- A measure on a finite product space equals the product measure if they are equal on\n  rectangles. -/\ntheorem pi_eq {μ' : Measure (∀ i, α i)}\n    (h : ∀ s : ∀ i, Set (α i), (∀ i, MeasurableSet (s i)) → μ' (pi univ s) = ∏ i, μ i (s i)) :\n    Measure.pi μ = μ' :=\n  pi_eq_generateFrom (fun _ => generateFrom_measurableSet) (fun _ => isPiSystem_measurableSet)\n    (fun i => (μ i).toFiniteSpanningSetsIn) h\n\n"}
{"name":"MeasureTheory.Measure.pi'_eq_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝ : Encodable ι\n⊢ Eq (MeasureTheory.Measure.pi' μ) (MeasureTheory.Measure.pi μ)","decl":"theorem pi'_eq_pi [Encodable ι] : pi' μ = Measure.pi μ :=\n  Eq.symm <| pi_eq fun s _ => pi'_pi μ s\n\n"}
{"name":"MeasureTheory.Measure.pi_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ns : (i : ι) → Set (α i)\n⊢ Eq ((MeasureTheory.Measure.pi μ) (Set.univ.pi s)) (Finset.univ.prod fun i => (μ i) (s i))","decl":"@[simp]\ntheorem pi_pi (s : ∀ i, Set (α i)) : Measure.pi μ (pi univ s) = ∏ i, μ i (s i) := by\n  haveI : Encodable ι := Fintype.toEncodable ι\n  rw [← pi'_eq_pi, pi'_pi]\n\n"}
{"name":"MeasureTheory.Measure.pi_univ","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\n⊢ Eq ((MeasureTheory.Measure.pi μ) Set.univ) (Finset.univ.prod fun i => (μ i) Set.univ)","decl":"nonrec theorem pi_univ : Measure.pi μ univ = ∏ i, μ i univ := by rw [← pi_univ, pi_pi μ]\n\n"}
{"name":"MeasureTheory.Measure.pi_ball","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝ : (i : ι) → MetricSpace (α i)\nx : (i : ι) → α i\nr : Real\nhr : LT.lt 0 r\n⊢ Eq ((MeasureTheory.Measure.pi μ) (Metric.ball x r)) (Finset.univ.prod fun i => (μ i) (Metric.ball (x i) r))","decl":"theorem pi_ball [∀ i, MetricSpace (α i)] (x : ∀ i, α i) {r : ℝ} (hr : 0 < r) :\n    Measure.pi μ (Metric.ball x r) = ∏ i, μ i (Metric.ball (x i) r) := by rw [ball_pi _ hr, pi_pi]\n\n"}
{"name":"MeasureTheory.Measure.pi_closedBall","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝ : (i : ι) → MetricSpace (α i)\nx : (i : ι) → α i\nr : Real\nhr : LE.le 0 r\n⊢ Eq ((MeasureTheory.Measure.pi μ) (Metric.closedBall x r)) (Finset.univ.prod fun i => (μ i) (Metric.closedBall (x i) r))","decl":"theorem pi_closedBall [∀ i, MetricSpace (α i)] (x : ∀ i, α i) {r : ℝ} (hr : 0 ≤ r) :\n    Measure.pi μ (Metric.closedBall x r) = ∏ i, μ i (Metric.closedBall (x i) r) := by\n  rw [closedBall_pi _ hr, pi_pi]\n\n"}
{"name":"MeasureTheory.Measure.pi.sigmaFinite","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\n⊢ MeasureTheory.SigmaFinite (MeasureTheory.Measure.pi μ)","decl":"instance pi.sigmaFinite : SigmaFinite (Measure.pi μ) :=\n  (FiniteSpanningSetsIn.pi fun i => (μ i).toFiniteSpanningSetsIn).sigmaFinite\n\n"}
{"name":"MeasureTheory.Measure.instSigmaFiniteForallVolume","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝² : Fintype ι\nα : ι → Type u_4\ninst✝¹ : (i : ι) → MeasureTheory.MeasureSpace (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume","decl":"instance {α : ι → Type*} [∀ i, MeasureSpace (α i)] [∀ i, SigmaFinite (volume : Measure (α i))] :\n    SigmaFinite (volume : Measure (∀ i, α i)) :=\n  pi.sigmaFinite _\n\n"}
{"name":"MeasureTheory.Measure.pi.instIsFiniteMeasure","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝ : ∀ (i : ι), MeasureTheory.IsFiniteMeasure (μ i)\n⊢ MeasureTheory.IsFiniteMeasure (MeasureTheory.Measure.pi μ)","decl":"instance pi.instIsFiniteMeasure [∀ i, IsFiniteMeasure (μ i)] :\n    IsFiniteMeasure (Measure.pi μ) :=\n  ⟨Measure.pi_univ μ ▸ ENNReal.prod_lt_top (fun i _ ↦ measure_lt_top (μ i) _)⟩\n\n"}
{"name":"MeasureTheory.Measure.instIsFiniteMeasureForallVolume","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝² : Fintype ι\nα : ι → Type u_4\ninst✝¹ : (i : ι) → MeasureTheory.MeasureSpace (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.IsFiniteMeasure MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.IsFiniteMeasure MeasureTheory.MeasureSpace.volume","decl":"instance {α : ι → Type*} [∀ i, MeasureSpace (α i)] [∀ i, IsFiniteMeasure (volume : Measure (α i))] :\n    IsFiniteMeasure (volume : Measure (∀ i, α i)) :=\n  pi.instIsFiniteMeasure _\n\n"}
{"name":"MeasureTheory.Measure.pi.instIsProbabilityMeasure","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.IsProbabilityMeasure (μ i)\n⊢ MeasureTheory.IsProbabilityMeasure (MeasureTheory.Measure.pi μ)","decl":"instance pi.instIsProbabilityMeasure [∀ i, IsProbabilityMeasure (μ i)] :\n    IsProbabilityMeasure (Measure.pi μ) :=\n  ⟨by simp only [Measure.pi_univ, measure_univ, Finset.prod_const_one]⟩\n\n"}
{"name":"MeasureTheory.Measure.instIsProbabilityMeasureForallVolume","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝² : Fintype ι\nα : ι → Type u_4\ninst✝¹ : (i : ι) → MeasureTheory.MeasureSpace (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume","decl":"instance {α : ι → Type*} [∀ i, MeasureSpace (α i)]\n    [∀ i, IsProbabilityMeasure (volume : Measure (α i))] :\n    IsProbabilityMeasure (volume : Measure (∀ i, α i)) :=\n  pi.instIsProbabilityMeasure _\n\n"}
{"name":"MeasureTheory.Measure.pi_of_empty","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"α : Type u_4\ninst✝¹ : Fintype α\ninst✝ : IsEmpty α\nβ : α → Type u_5\nm : (a : α) → MeasurableSpace (β a)\nμ : (a : α) → MeasureTheory.Measure (β a)\nx : optParam ((a : α) → β a) fun a => isEmptyElim a\n⊢ Eq (MeasureTheory.Measure.pi μ) (MeasureTheory.Measure.dirac x)","decl":"theorem pi_of_empty {α : Type*} [Fintype α] [IsEmpty α] {β : α → Type*}\n    {m : ∀ a, MeasurableSpace (β a)} (μ : ∀ a : α, Measure (β a)) (x : ∀ a, β a := isEmptyElim) :\n    Measure.pi μ = dirac x := by\n  haveI : ∀ a, SigmaFinite (μ a) := isEmptyElim\n  refine pi_eq fun s _ => ?_\n  rw [Fintype.prod_empty, dirac_apply_of_mem]\n  exact isEmptyElim (α := α)\n\n"}
{"name":"MeasureTheory.Measure.volume_pi_eq_dirac","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : IsEmpty ι\nα : ι → Type u_5\ninst✝ : (i : ι) → MeasureTheory.MeasureSpace (α i)\nx : optParam ((a : ι) → α a) fun a => isEmptyElim a\n⊢ Eq MeasureTheory.MeasureSpace.volume (MeasureTheory.Measure.dirac x)","decl":"lemma volume_pi_eq_dirac {ι : Type*} [Fintype ι] [IsEmpty ι]\n    {α : ι → Type*} [∀ i, MeasureSpace (α i)] (x : ∀ a, α a := isEmptyElim) :\n    (volume : Measure (∀ i, α i)) = Measure.dirac x :=\n  Measure.pi_of_empty _ _\n\n"}
{"name":"MeasureTheory.Measure.pi_empty_univ","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"α : Type u_4\ninst✝¹ : Fintype α\ninst✝ : IsEmpty α\nβ : α → Type u_5\nm : (α : α) → MeasurableSpace (β α)\nμ : (a : α) → MeasureTheory.Measure (β a)\n⊢ Eq ((MeasureTheory.Measure.pi μ) Set.univ) 1","decl":"@[simp]\ntheorem pi_empty_univ {α : Type*} [Fintype α] [IsEmpty α] {β : α → Type*}\n    {m : ∀ α, MeasurableSpace (β α)} (μ : ∀ a : α, Measure (β a)) :\n    Measure.pi μ (Set.univ) = 1 := by\n  rw [pi_of_empty, measure_univ]\n\n"}
{"name":"MeasureTheory.Measure.pi_eval_preimage_null","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ni : ι\ns : Set (α i)\nhs : Eq ((μ i) s) 0\n⊢ Eq ((MeasureTheory.Measure.pi μ) (Set.preimage (Function.eval i) s)) 0","decl":"theorem pi_eval_preimage_null {i : ι} {s : Set (α i)} (hs : μ i s = 0) :\n    Measure.pi μ (eval i ⁻¹' s) = 0 := by\n  classical\n  -- WLOG, `s` is measurable\n  rcases exists_measurable_superset_of_null hs with ⟨t, hst, _, hμt⟩\n  suffices Measure.pi μ (eval i ⁻¹' t) = 0 from measure_mono_null (preimage_mono hst) this\n  -- Now rewrite it as `Set.pi`, and apply `pi_pi`\n  rw [← univ_pi_update_univ, pi_pi]\n  apply Finset.prod_eq_zero (Finset.mem_univ i)\n  simp [hμt]\n\n"}
{"name":"MeasureTheory.Measure.pi_hyperplane","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ni : ι\ninst✝ : MeasureTheory.NoAtoms (μ i)\nx : α i\n⊢ Eq ((MeasureTheory.Measure.pi μ) (setOf fun f => Eq (f i) x)) 0","decl":"theorem pi_hyperplane (i : ι) [NoAtoms (μ i)] (x : α i) :\n    Measure.pi μ { f : ∀ i, α i | f i = x } = 0 :=\n  show Measure.pi μ (eval i ⁻¹' {x}) = 0 from pi_eval_preimage_null _ (measure_singleton x)\n\n"}
{"name":"MeasureTheory.Measure.ae_eval_ne","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ni : ι\ninst✝ : MeasureTheory.NoAtoms (μ i)\nx : α i\n⊢ Filter.Eventually (fun y => Ne (y i) x) (MeasureTheory.ae (MeasureTheory.Measure.pi μ))","decl":"theorem ae_eval_ne (i : ι) [NoAtoms (μ i)] (x : α i) : ∀ᵐ y : ∀ i, α i ∂Measure.pi μ, y i ≠ x :=\n  compl_mem_ae_iff.2 (pi_hyperplane μ i x)\n\n"}
{"name":"MeasureTheory.Measure.tendsto_eval_ae_ae","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ni : ι\n⊢ Filter.Tendsto (Function.eval i) (MeasureTheory.ae (MeasureTheory.Measure.pi μ)) (MeasureTheory.ae (μ i))","decl":"theorem tendsto_eval_ae_ae {i : ι} : Tendsto (eval i) (ae (Measure.pi μ)) (ae (μ i)) := fun _ hs =>\n  pi_eval_preimage_null μ hs\n\n"}
{"name":"MeasureTheory.Measure.ae_pi_le_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\n⊢ LE.le (MeasureTheory.ae (MeasureTheory.Measure.pi μ)) (Filter.pi fun i => MeasureTheory.ae (μ i))","decl":"theorem ae_pi_le_pi : ae (Measure.pi μ) ≤ Filter.pi fun i => ae (μ i) :=\n  le_iInf fun _ => tendsto_eval_ae_ae.le_comap\n\n"}
{"name":"MeasureTheory.Measure.ae_eq_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\nβ : ι → Type u_4\nf f' : (i : ι) → α i → β i\nh : ∀ (i : ι), (MeasureTheory.ae (μ i)).EventuallyEq (f i) (f' i)\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyEq (fun x i => f i (x i)) fun x i => f' i (x i)","decl":"theorem ae_eq_pi {β : ι → Type*} {f f' : ∀ i, α i → β i} (h : ∀ i, f i =ᵐ[μ i] f' i) :\n    (fun (x : ∀ i, α i) i => f i (x i)) =ᵐ[Measure.pi μ] fun x i => f' i (x i) :=\n  (eventually_all.2 fun i => tendsto_eval_ae_ae.eventually (h i)).mono fun _ hx => funext hx\n\n"}
{"name":"MeasureTheory.Measure.ae_le_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\nβ : ι → Type u_4\ninst✝ : (i : ι) → Preorder (β i)\nf f' : (i : ι) → α i → β i\nh : ∀ (i : ι), (MeasureTheory.ae (μ i)).EventuallyLE (f i) (f' i)\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyLE (fun x i => f i (x i)) fun x i => f' i (x i)","decl":"theorem ae_le_pi {β : ι → Type*} [∀ i, Preorder (β i)] {f f' : ∀ i, α i → β i}\n    (h : ∀ i, f i ≤ᵐ[μ i] f' i) :\n    (fun (x : ∀ i, α i) i => f i (x i)) ≤ᵐ[Measure.pi μ] fun x i => f' i (x i) :=\n  (eventually_all.2 fun i => tendsto_eval_ae_ae.eventually (h i)).mono fun _ hx => hx\n\n"}
{"name":"MeasureTheory.Measure.ae_le_set_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\nI : Set ι\ns t : (i : ι) → Set (α i)\nh : ∀ (i : ι), Membership.mem I i → (MeasureTheory.ae (μ i)).EventuallyLE (s i) (t i)\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyLE (I.pi s) (I.pi t)","decl":"theorem ae_le_set_pi {I : Set ι} {s t : ∀ i, Set (α i)} (h : ∀ i ∈ I, s i ≤ᵐ[μ i] t i) :\n    Set.pi I s ≤ᵐ[Measure.pi μ] Set.pi I t :=\n  ((eventually_all_finite I.toFinite).2 fun i hi => tendsto_eval_ae_ae.eventually (h i hi)).mono\n    fun _ hst hx i hi => hst i hi <| hx i hi\n\n"}
{"name":"MeasureTheory.Measure.ae_eq_set_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\nI : Set ι\ns t : (i : ι) → Set (α i)\nh : ∀ (i : ι), Membership.mem I i → (MeasureTheory.ae (μ i)).EventuallyEq (s i) (t i)\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyEq (I.pi s) (I.pi t)","decl":"theorem ae_eq_set_pi {I : Set ι} {s t : ∀ i, Set (α i)} (h : ∀ i ∈ I, s i =ᵐ[μ i] t i) :\n    Set.pi I s =ᵐ[Measure.pi μ] Set.pi I t :=\n  (ae_le_set_pi fun i hi => (h i hi).le).antisymm (ae_le_set_pi fun i hi => (h i hi).symm.le)\n\n"}
{"name":"MeasureTheory.Measure.pi_map_piCongrLeft","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nι' : Type u_2\ninst✝² : Fintype ι\nhι' : Fintype ι'\ne : Equiv ι ι'\nβ : ι' → Type u_4\ninst✝¹ : (i : ι') → MeasurableSpace (β i)\nμ : (i : ι') → MeasureTheory.Measure (β i)\ninst✝ : ∀ (i : ι'), MeasureTheory.SigmaFinite (μ i)\n⊢ Eq (MeasureTheory.Measure.map (⇑(MeasurableEquiv.piCongrLeft (fun i => β i) e)) (MeasureTheory.Measure.pi fun i => μ (e i))) (MeasureTheory.Measure.pi μ)","decl":"lemma pi_map_piCongrLeft [hι' : Fintype ι'] (e : ι ≃ ι') {β : ι' → Type*}\n    [∀ i, MeasurableSpace (β i)] (μ : (i : ι') → Measure (β i)) [∀ i, SigmaFinite (μ i)] :\n    (Measure.pi fun i ↦ μ (e i)).map (MeasurableEquiv.piCongrLeft (fun i ↦ β i) e)\n      = Measure.pi μ := by\n  let e_meas : ((b : ι) → β (e b)) ≃ᵐ ((a : ι') → β a) :=\n    MeasurableEquiv.piCongrLeft (fun i ↦ β i) e\n  refine Measure.pi_eq (fun s _ ↦ ?_) |>.symm\n  rw [e_meas.measurableEmbedding.map_apply]\n  let s' : (i : ι) → Set (β (e i)) := fun i ↦ s (e i)\n  have : e_meas ⁻¹' pi univ s = pi univ s' := by\n    ext x\n    simp only [mem_preimage, Set.mem_pi, mem_univ, forall_true_left, s']\n    refine (e.forall_congr ?_).symm\n    intro i\n    rw [MeasurableEquiv.piCongrLeft_apply_apply e x i]\n  rw [this, pi_pi, Finset.prod_equiv e.symm]\n  · simp only [Finset.mem_univ, implies_true]\n  intro i _\n  simp only [s']\n  congr\n  all_goals rw [e.apply_symm_apply]\n\n"}
{"name":"MeasureTheory.Measure.pi_map_piOptionEquivProd","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝² : Fintype ι\nβ : Option ι → Type u_4\ninst✝¹ : (i : Option ι) → MeasurableSpace (β i)\nμ : (i : Option ι) → MeasureTheory.Measure (β i)\ninst✝ : ∀ (i : Option ι), MeasureTheory.SigmaFinite (μ i)\n⊢ Eq (MeasureTheory.Measure.map (⇑(MeasurableEquiv.piOptionEquivProd β).symm) ((MeasureTheory.Measure.pi fun i => μ (Option.some i)).prod (μ Option.none))) (MeasureTheory.Measure.pi μ)","decl":"lemma pi_map_piOptionEquivProd {β : Option ι → Type*} [∀ i, MeasurableSpace (β i)]\n    (μ : (i : Option ι) → Measure (β i)) [∀ (i : Option ι), SigmaFinite (μ i)] :\n    ((Measure.pi fun i ↦ μ (some i)).prod (μ none)).map\n      (MeasurableEquiv.piOptionEquivProd β).symm = Measure.pi μ := by\n  refine pi_eq (fun s _ ↦ ?_) |>.symm\n  let e_meas : ((i : ι) → β (some i)) × β none ≃ᵐ ((i : Option ι) → β i) :=\n    MeasurableEquiv.piOptionEquivProd β |>.symm\n  have me := MeasurableEquiv.measurableEmbedding e_meas\n  have : e_meas ⁻¹' pi univ s = (pi univ (fun i ↦ s (some i))) ×ˢ (s none) := by\n    ext x\n    simp only [mem_preimage, Set.mem_pi, mem_univ, forall_true_left, mem_prod]\n    refine ⟨by tauto, fun _ i ↦ ?_⟩\n    rcases i <;> tauto\n  simp only [e_meas, me.map_apply, univ_option, le_eq_subset, Finset.prod_insertNone, this,\n    prod_prod, pi_pi, mul_comm]\n\n"}
{"name":"MeasureTheory.Measure.pi_Iio_ae_eq_pi_Iic","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.NoAtoms (μ i)\ns : Set ι\nf : (i : ι) → α i\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyEq (s.pi fun i => Set.Iio (f i)) (s.pi fun i => Set.Iic (f i))","decl":"theorem pi_Iio_ae_eq_pi_Iic {s : Set ι} {f : ∀ i, α i} :\n    (pi s fun i => Iio (f i)) =ᵐ[Measure.pi μ] pi s fun i => Iic (f i) :=\n  ae_eq_set_pi fun _ _ => Iio_ae_eq_Iic\n\n"}
{"name":"MeasureTheory.Measure.pi_Ioi_ae_eq_pi_Ici","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.NoAtoms (μ i)\ns : Set ι\nf : (i : ι) → α i\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyEq (s.pi fun i => Set.Ioi (f i)) (s.pi fun i => Set.Ici (f i))","decl":"theorem pi_Ioi_ae_eq_pi_Ici {s : Set ι} {f : ∀ i, α i} :\n    (pi s fun i => Ioi (f i)) =ᵐ[Measure.pi μ] pi s fun i => Ici (f i) :=\n  ae_eq_set_pi fun _ _ => Ioi_ae_eq_Ici\n\n"}
{"name":"MeasureTheory.Measure.univ_pi_Iio_ae_eq_Iic","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.NoAtoms (μ i)\nf : (i : ι) → α i\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyEq (Set.univ.pi fun i => Set.Iio (f i)) (Set.Iic f)","decl":"theorem univ_pi_Iio_ae_eq_Iic {f : ∀ i, α i} :\n    (pi univ fun i => Iio (f i)) =ᵐ[Measure.pi μ] Iic f := by\n  rw [← pi_univ_Iic]; exact pi_Iio_ae_eq_pi_Iic\n\n"}
{"name":"MeasureTheory.Measure.univ_pi_Ioi_ae_eq_Ici","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.NoAtoms (μ i)\nf : (i : ι) → α i\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyEq (Set.univ.pi fun i => Set.Ioi (f i)) (Set.Ici f)","decl":"theorem univ_pi_Ioi_ae_eq_Ici {f : ∀ i, α i} :\n    (pi univ fun i => Ioi (f i)) =ᵐ[Measure.pi μ] Ici f := by\n  rw [← pi_univ_Ici]; exact pi_Ioi_ae_eq_pi_Ici\n\n"}
{"name":"MeasureTheory.Measure.pi_Ioo_ae_eq_pi_Icc","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.NoAtoms (μ i)\ns : Set ι\nf g : (i : ι) → α i\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyEq (s.pi fun i => Set.Ioo (f i) (g i)) (s.pi fun i => Set.Icc (f i) (g i))","decl":"theorem pi_Ioo_ae_eq_pi_Icc {s : Set ι} {f g : ∀ i, α i} :\n    (pi s fun i => Ioo (f i) (g i)) =ᵐ[Measure.pi μ] pi s fun i => Icc (f i) (g i) :=\n  ae_eq_set_pi fun _ _ => Ioo_ae_eq_Icc\n\n"}
{"name":"MeasureTheory.Measure.pi_Ioo_ae_eq_pi_Ioc","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.NoAtoms (μ i)\ns : Set ι\nf g : (i : ι) → α i\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyEq (s.pi fun i => Set.Ioo (f i) (g i)) (s.pi fun i => Set.Ioc (f i) (g i))","decl":"theorem pi_Ioo_ae_eq_pi_Ioc {s : Set ι} {f g : ∀ i, α i} :\n    (pi s fun i => Ioo (f i) (g i)) =ᵐ[Measure.pi μ] pi s fun i => Ioc (f i) (g i) :=\n  ae_eq_set_pi fun _ _ => Ioo_ae_eq_Ioc\n\n"}
{"name":"MeasureTheory.Measure.univ_pi_Ioo_ae_eq_Icc","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.NoAtoms (μ i)\nf g : (i : ι) → α i\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyEq (Set.univ.pi fun i => Set.Ioo (f i) (g i)) (Set.Icc f g)","decl":"theorem univ_pi_Ioo_ae_eq_Icc {f g : ∀ i, α i} :\n    (pi univ fun i => Ioo (f i) (g i)) =ᵐ[Measure.pi μ] Icc f g := by\n  rw [← pi_univ_Icc]; exact pi_Ioo_ae_eq_pi_Icc\n\n"}
{"name":"MeasureTheory.Measure.pi_Ioc_ae_eq_pi_Icc","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.NoAtoms (μ i)\ns : Set ι\nf g : (i : ι) → α i\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyEq (s.pi fun i => Set.Ioc (f i) (g i)) (s.pi fun i => Set.Icc (f i) (g i))","decl":"theorem pi_Ioc_ae_eq_pi_Icc {s : Set ι} {f g : ∀ i, α i} :\n    (pi s fun i => Ioc (f i) (g i)) =ᵐ[Measure.pi μ] pi s fun i => Icc (f i) (g i) :=\n  ae_eq_set_pi fun _ _ => Ioc_ae_eq_Icc\n\n"}
{"name":"MeasureTheory.Measure.univ_pi_Ioc_ae_eq_Icc","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.NoAtoms (μ i)\nf g : (i : ι) → α i\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyEq (Set.univ.pi fun i => Set.Ioc (f i) (g i)) (Set.Icc f g)","decl":"theorem univ_pi_Ioc_ae_eq_Icc {f g : ∀ i, α i} :\n    (pi univ fun i => Ioc (f i) (g i)) =ᵐ[Measure.pi μ] Icc f g := by\n  rw [← pi_univ_Icc]; exact pi_Ioc_ae_eq_pi_Icc\n\n"}
{"name":"MeasureTheory.Measure.pi_Ico_ae_eq_pi_Icc","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.NoAtoms (μ i)\ns : Set ι\nf g : (i : ι) → α i\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyEq (s.pi fun i => Set.Ico (f i) (g i)) (s.pi fun i => Set.Icc (f i) (g i))","decl":"theorem pi_Ico_ae_eq_pi_Icc {s : Set ι} {f g : ∀ i, α i} :\n    (pi s fun i => Ico (f i) (g i)) =ᵐ[Measure.pi μ] pi s fun i => Icc (f i) (g i) :=\n  ae_eq_set_pi fun _ _ => Ico_ae_eq_Icc\n\n"}
{"name":"MeasureTheory.Measure.univ_pi_Ico_ae_eq_Icc","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.NoAtoms (μ i)\nf g : (i : ι) → α i\n⊢ (MeasureTheory.ae (MeasureTheory.Measure.pi μ)).EventuallyEq (Set.univ.pi fun i => Set.Ico (f i) (g i)) (Set.Icc f g)","decl":"theorem univ_pi_Ico_ae_eq_Icc {f g : ∀ i, α i} :\n    (pi univ fun i => Ico (f i) (g i)) =ᵐ[Measure.pi μ] Icc f g := by\n  rw [← pi_univ_Icc]; exact pi_Ico_ae_eq_pi_Icc\n\n"}
{"name":"MeasureTheory.Measure.pi_noAtoms","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ni : ι\ninst✝ : MeasureTheory.NoAtoms (μ i)\n⊢ MeasureTheory.NoAtoms (MeasureTheory.Measure.pi μ)","decl":"/-- If one of the measures `μ i` has no atoms, them `Measure.pi µ`\nhas no atoms. The instance below assumes that all `μ i` have no atoms. -/\ntheorem pi_noAtoms (i : ι) [NoAtoms (μ i)] : NoAtoms (Measure.pi μ) :=\n  ⟨fun x => flip measure_mono_null (pi_hyperplane μ i (x i)) (singleton_subset_iff.2 rfl)⟩\n\n"}
{"name":"MeasureTheory.Measure.pi_noAtoms'","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\nh : Nonempty ι\ninst✝ : ∀ (i : ι), MeasureTheory.NoAtoms (μ i)\n⊢ MeasureTheory.NoAtoms (MeasureTheory.Measure.pi μ)","decl":"instance pi_noAtoms' [h : Nonempty ι] [∀ i, NoAtoms (μ i)] : NoAtoms (Measure.pi μ) :=\n  h.elim fun i => pi_noAtoms i\n\n"}
{"name":"MeasureTheory.Measure.instNoAtomsForallVolumeOfNonemptyOfSigmaFinite","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nα : ι → Type u_4\ninst✝³ : Nonempty ι\ninst✝² : (i : ι) → MeasureTheory.MeasureSpace (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : ∀ (i : ι), MeasureTheory.NoAtoms MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.NoAtoms MeasureTheory.MeasureSpace.volume","decl":"instance {α : ι → Type*} [Nonempty ι] [∀ i, MeasureSpace (α i)]\n    [∀ i, SigmaFinite (volume : Measure (α i))] [∀ i, NoAtoms (volume : Measure (α i))] :\n    NoAtoms (volume : Measure (∀ i, α i)) :=\n  pi_noAtoms'\n\n"}
{"name":"MeasureTheory.Measure.pi.isLocallyFiniteMeasure","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : (i : ι) → TopologicalSpace (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.IsLocallyFiniteMeasure (μ i)\n⊢ MeasureTheory.IsLocallyFiniteMeasure (MeasureTheory.Measure.pi μ)","decl":"instance pi.isLocallyFiniteMeasure\n    [∀ i, TopologicalSpace (α i)] [∀ i, IsLocallyFiniteMeasure (μ i)] :\n    IsLocallyFiniteMeasure (Measure.pi μ) := by\n  refine ⟨fun x => ?_⟩\n  choose s hxs ho hμ using fun i => (μ i).exists_isOpen_measure_lt_top (x i)\n  refine ⟨pi univ s, set_pi_mem_nhds finite_univ fun i _ => IsOpen.mem_nhds (ho i) (hxs i), ?_⟩\n  rw [pi_pi]\n  exact ENNReal.prod_lt_top fun i _ => hμ i\n\n"}
{"name":"MeasureTheory.Measure.instIsLocallyFiniteMeasureForallVolumeOfSigmaFinite","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nX : ι → Type u_4\ninst✝³ : (i : ι) → TopologicalSpace (X i)\ninst✝² : (i : ι) → MeasureTheory.MeasureSpace (X i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : ∀ (i : ι), MeasureTheory.IsLocallyFiniteMeasure MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.IsLocallyFiniteMeasure MeasureTheory.MeasureSpace.volume","decl":"instance {X : ι → Type*} [∀ i, TopologicalSpace (X i)] [∀ i, MeasureSpace (X i)]\n    [∀ i, SigmaFinite (volume : Measure (X i))]\n    [∀ i, IsLocallyFiniteMeasure (volume : Measure (X i))] :\n    IsLocallyFiniteMeasure (volume : Measure (∀ i, X i)) :=\n  pi.isLocallyFiniteMeasure\n\n"}
{"name":"MeasureTheory.Measure.pi.isMulLeftInvariant","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : (i : ι) → Group (α i)\ninst✝¹ : ∀ (i : ι), MeasurableMul (α i)\ninst✝ : ∀ (i : ι), (μ i).IsMulLeftInvariant\n⊢ (MeasureTheory.Measure.pi μ).IsMulLeftInvariant","decl":"@[to_additive]\ninstance pi.isMulLeftInvariant [∀ i, Group (α i)] [∀ i, MeasurableMul (α i)]\n    [∀ i, IsMulLeftInvariant (μ i)] : IsMulLeftInvariant (Measure.pi μ) := by\n  refine ⟨fun v => (pi_eq fun s hs => ?_).symm⟩\n  rw [map_apply (measurable_const_mul _) (MeasurableSet.univ_pi hs),\n    show (v * ·) ⁻¹' univ.pi s = univ.pi fun i => (v i * ·) ⁻¹' s i by rfl, pi_pi]\n  simp_rw [measure_preimage_mul]\n\n"}
{"name":"MeasureTheory.Measure.pi.isAddLeftInvariant","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : (i : ι) → AddGroup (α i)\ninst✝¹ : ∀ (i : ι), MeasurableAdd (α i)\ninst✝ : ∀ (i : ι), (μ i).IsAddLeftInvariant\n⊢ (MeasureTheory.Measure.pi μ).IsAddLeftInvariant","decl":"@[to_additive]\ninstance pi.isMulLeftInvariant [∀ i, Group (α i)] [∀ i, MeasurableMul (α i)]\n    [∀ i, IsMulLeftInvariant (μ i)] : IsMulLeftInvariant (Measure.pi μ) := by\n  refine ⟨fun v => (pi_eq fun s hs => ?_).symm⟩\n  rw [map_apply (measurable_const_mul _) (MeasurableSet.univ_pi hs),\n    show (v * ·) ⁻¹' univ.pi s = univ.pi fun i => (v i * ·) ⁻¹' s i by rfl, pi_pi]\n  simp_rw [measure_preimage_mul]\n\n"}
{"name":"MeasureTheory.Measure.instIsMulLeftInvariantForallVolumeOfMeasurableMulOfSigmaFinite","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁵ : Fintype ι\nG : ι → Type u_4\ninst✝⁴ : (i : ι) → Group (G i)\ninst✝³ : (i : ι) → MeasureTheory.MeasureSpace (G i)\ninst✝² : ∀ (i : ι), MeasurableMul (G i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : ∀ (i : ι), MeasureTheory.MeasureSpace.volume.IsMulLeftInvariant\n⊢ MeasureTheory.MeasureSpace.volume.IsMulLeftInvariant","decl":"@[to_additive]\ninstance {G : ι → Type*} [∀ i, Group (G i)] [∀ i, MeasureSpace (G i)] [∀ i, MeasurableMul (G i)]\n    [∀ i, SigmaFinite (volume : Measure (G i))] [∀ i, IsMulLeftInvariant (volume : Measure (G i))] :\n    IsMulLeftInvariant (volume : Measure (∀ i, G i)) :=\n  pi.isMulLeftInvariant _\n\n"}
{"name":"MeasureTheory.Measure.instIsAddLeftInvariantForallVolumeOfMeasurableAddOfSigmaFinite","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁵ : Fintype ι\nG : ι → Type u_4\ninst✝⁴ : (i : ι) → AddGroup (G i)\ninst✝³ : (i : ι) → MeasureTheory.MeasureSpace (G i)\ninst✝² : ∀ (i : ι), MeasurableAdd (G i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : ∀ (i : ι), MeasureTheory.MeasureSpace.volume.IsAddLeftInvariant\n⊢ MeasureTheory.MeasureSpace.volume.IsAddLeftInvariant","decl":"@[to_additive]\ninstance {G : ι → Type*} [∀ i, Group (G i)] [∀ i, MeasureSpace (G i)] [∀ i, MeasurableMul (G i)]\n    [∀ i, SigmaFinite (volume : Measure (G i))] [∀ i, IsMulLeftInvariant (volume : Measure (G i))] :\n    IsMulLeftInvariant (volume : Measure (∀ i, G i)) :=\n  pi.isMulLeftInvariant _\n\n"}
{"name":"MeasureTheory.Measure.pi.isMulRightInvariant","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : (i : ι) → Group (α i)\ninst✝¹ : ∀ (i : ι), MeasurableMul (α i)\ninst✝ : ∀ (i : ι), (μ i).IsMulRightInvariant\n⊢ (MeasureTheory.Measure.pi μ).IsMulRightInvariant","decl":"@[to_additive]\ninstance pi.isMulRightInvariant [∀ i, Group (α i)] [∀ i, MeasurableMul (α i)]\n    [∀ i, IsMulRightInvariant (μ i)] : IsMulRightInvariant (Measure.pi μ) := by\n  refine ⟨fun v => (pi_eq fun s hs => ?_).symm⟩\n  rw [map_apply (measurable_mul_const _) (MeasurableSet.univ_pi hs),\n    show (· * v) ⁻¹' univ.pi s = univ.pi fun i => (· * v i) ⁻¹' s i by rfl, pi_pi]\n  simp_rw [measure_preimage_mul_right]\n\n"}
{"name":"MeasureTheory.Measure.pi.isAddRightInvariant","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : (i : ι) → AddGroup (α i)\ninst✝¹ : ∀ (i : ι), MeasurableAdd (α i)\ninst✝ : ∀ (i : ι), (μ i).IsAddRightInvariant\n⊢ (MeasureTheory.Measure.pi μ).IsAddRightInvariant","decl":"@[to_additive]\ninstance pi.isMulRightInvariant [∀ i, Group (α i)] [∀ i, MeasurableMul (α i)]\n    [∀ i, IsMulRightInvariant (μ i)] : IsMulRightInvariant (Measure.pi μ) := by\n  refine ⟨fun v => (pi_eq fun s hs => ?_).symm⟩\n  rw [map_apply (measurable_mul_const _) (MeasurableSet.univ_pi hs),\n    show (· * v) ⁻¹' univ.pi s = univ.pi fun i => (· * v i) ⁻¹' s i by rfl, pi_pi]\n  simp_rw [measure_preimage_mul_right]\n\n"}
{"name":"MeasureTheory.Measure.instIsMulRightInvariantForallVolumeOfMeasurableMulOfSigmaFinite","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁵ : Fintype ι\nG : ι → Type u_4\ninst✝⁴ : (i : ι) → Group (G i)\ninst✝³ : (i : ι) → MeasureTheory.MeasureSpace (G i)\ninst✝² : ∀ (i : ι), MeasurableMul (G i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : ∀ (i : ι), MeasureTheory.MeasureSpace.volume.IsMulRightInvariant\n⊢ MeasureTheory.MeasureSpace.volume.IsMulRightInvariant","decl":"@[to_additive]\ninstance {G : ι → Type*} [∀ i, Group (G i)] [∀ i, MeasureSpace (G i)] [∀ i, MeasurableMul (G i)]\n    [∀ i, SigmaFinite (volume : Measure (G i))]\n    [∀ i, IsMulRightInvariant (volume : Measure (G i))] :\n    IsMulRightInvariant (volume : Measure (∀ i, G i)) :=\n  pi.isMulRightInvariant _\n\n"}
{"name":"MeasureTheory.Measure.instIsAddRightInvariantForallVolumeOfMeasurableAddOfSigmaFinite","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁵ : Fintype ι\nG : ι → Type u_4\ninst✝⁴ : (i : ι) → AddGroup (G i)\ninst✝³ : (i : ι) → MeasureTheory.MeasureSpace (G i)\ninst✝² : ∀ (i : ι), MeasurableAdd (G i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : ∀ (i : ι), MeasureTheory.MeasureSpace.volume.IsAddRightInvariant\n⊢ MeasureTheory.MeasureSpace.volume.IsAddRightInvariant","decl":"@[to_additive]\ninstance {G : ι → Type*} [∀ i, Group (G i)] [∀ i, MeasureSpace (G i)] [∀ i, MeasurableMul (G i)]\n    [∀ i, SigmaFinite (volume : Measure (G i))]\n    [∀ i, IsMulRightInvariant (volume : Measure (G i))] :\n    IsMulRightInvariant (volume : Measure (∀ i, G i)) :=\n  pi.isMulRightInvariant _\n\n"}
{"name":"MeasureTheory.Measure.pi.isNegInvariant","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : (i : ι) → AddGroup (α i)\ninst✝¹ : ∀ (i : ι), MeasurableNeg (α i)\ninst✝ : ∀ (i : ι), (μ i).IsNegInvariant\n⊢ (MeasureTheory.Measure.pi μ).IsNegInvariant","decl":"@[to_additive]\ninstance pi.isInvInvariant [∀ i, Group (α i)] [∀ i, MeasurableInv (α i)]\n    [∀ i, IsInvInvariant (μ i)] : IsInvInvariant (Measure.pi μ) := by\n  refine ⟨(Measure.pi_eq fun s hs => ?_).symm⟩\n  have A : Inv.inv ⁻¹' pi univ s = Set.pi univ fun i => Inv.inv ⁻¹' s i := by ext; simp\n  simp_rw [Measure.inv, Measure.map_apply measurable_inv (MeasurableSet.univ_pi hs), A, pi_pi,\n    measure_preimage_inv]\n\n"}
{"name":"MeasureTheory.Measure.pi.isInvInvariant","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁴ : Fintype ι\ninst✝³ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝² : (i : ι) → Group (α i)\ninst✝¹ : ∀ (i : ι), MeasurableInv (α i)\ninst✝ : ∀ (i : ι), (μ i).IsInvInvariant\n⊢ (MeasureTheory.Measure.pi μ).IsInvInvariant","decl":"@[to_additive]\ninstance pi.isInvInvariant [∀ i, Group (α i)] [∀ i, MeasurableInv (α i)]\n    [∀ i, IsInvInvariant (μ i)] : IsInvInvariant (Measure.pi μ) := by\n  refine ⟨(Measure.pi_eq fun s hs => ?_).symm⟩\n  have A : Inv.inv ⁻¹' pi univ s = Set.pi univ fun i => Inv.inv ⁻¹' s i := by ext; simp\n  simp_rw [Measure.inv, Measure.map_apply measurable_inv (MeasurableSet.univ_pi hs), A, pi_pi,\n    measure_preimage_inv]\n\n"}
{"name":"MeasureTheory.Measure.instIsNegInvariantForallVolumeOfMeasurableNegOfSigmaFinite","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁵ : Fintype ι\nG : ι → Type u_4\ninst✝⁴ : (i : ι) → AddGroup (G i)\ninst✝³ : (i : ι) → MeasureTheory.MeasureSpace (G i)\ninst✝² : ∀ (i : ι), MeasurableNeg (G i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : ∀ (i : ι), MeasureTheory.MeasureSpace.volume.IsNegInvariant\n⊢ MeasureTheory.MeasureSpace.volume.IsNegInvariant","decl":"@[to_additive]\ninstance {G : ι → Type*} [∀ i, Group (G i)] [∀ i, MeasureSpace (G i)] [∀ i, MeasurableInv (G i)]\n    [∀ i, SigmaFinite (volume : Measure (G i))] [∀ i, IsInvInvariant (volume : Measure (G i))] :\n    IsInvInvariant (volume : Measure (∀ i, G i)) :=\n  pi.isInvInvariant _\n\n"}
{"name":"MeasureTheory.Measure.instIsInvInvariantForallVolumeOfMeasurableInvOfSigmaFinite","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁵ : Fintype ι\nG : ι → Type u_4\ninst✝⁴ : (i : ι) → Group (G i)\ninst✝³ : (i : ι) → MeasureTheory.MeasureSpace (G i)\ninst✝² : ∀ (i : ι), MeasurableInv (G i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : ∀ (i : ι), MeasureTheory.MeasureSpace.volume.IsInvInvariant\n⊢ MeasureTheory.MeasureSpace.volume.IsInvInvariant","decl":"@[to_additive]\ninstance {G : ι → Type*} [∀ i, Group (G i)] [∀ i, MeasureSpace (G i)] [∀ i, MeasurableInv (G i)]\n    [∀ i, SigmaFinite (volume : Measure (G i))] [∀ i, IsInvInvariant (volume : Measure (G i))] :\n    IsInvInvariant (volume : Measure (∀ i, G i)) :=\n  pi.isInvInvariant _\n\n"}
{"name":"MeasureTheory.Measure.pi.isOpenPosMeasure","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : (i : ι) → TopologicalSpace (α i)\ninst✝ : ∀ (i : ι), (μ i).IsOpenPosMeasure\n⊢ (MeasureTheory.Measure.pi μ).IsOpenPosMeasure","decl":"instance pi.isOpenPosMeasure [∀ i, TopologicalSpace (α i)] [∀ i, IsOpenPosMeasure (μ i)] :\n    IsOpenPosMeasure (MeasureTheory.Measure.pi μ) := by\n  constructor\n  rintro U U_open ⟨a, ha⟩\n  obtain ⟨s, ⟨hs, hsU⟩⟩ := isOpen_pi_iff'.1 U_open a ha\n  refine ne_of_gt (lt_of_lt_of_le ?_ (measure_mono hsU))\n  simp only [pi_pi]\n  rw [CanonicallyOrderedAdd.prod_pos]\n  intro i _\n  apply (hs i).1.measure_pos (μ i) ⟨a i, (hs i).2⟩\n\n"}
{"name":"MeasureTheory.Measure.instIsOpenPosMeasureForallVolumeOfSigmaFinite","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nX : ι → Type u_4\ninst✝³ : (i : ι) → TopologicalSpace (X i)\ninst✝² : (i : ι) → MeasureTheory.MeasureSpace (X i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.MeasureSpace.volume.IsOpenPosMeasure\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.MeasureSpace.volume.IsOpenPosMeasure","decl":"instance {X : ι → Type*} [∀ i, TopologicalSpace (X i)] [∀ i, MeasureSpace (X i)]\n    [∀ i, IsOpenPosMeasure (volume : Measure (X i))] [∀ i, SigmaFinite (volume : Measure (X i))] :\n    IsOpenPosMeasure (volume : Measure (∀ i, X i)) :=\n  pi.isOpenPosMeasure _\n\n"}
{"name":"MeasureTheory.Measure.pi.isFiniteMeasureOnCompacts","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : (i : ι) → TopologicalSpace (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.IsFiniteMeasureOnCompacts (μ i)\n⊢ MeasureTheory.IsFiniteMeasureOnCompacts (MeasureTheory.Measure.pi μ)","decl":"instance pi.isFiniteMeasureOnCompacts [∀ i, TopologicalSpace (α i)]\n    [∀ i, IsFiniteMeasureOnCompacts (μ i)] :\n    IsFiniteMeasureOnCompacts (MeasureTheory.Measure.pi μ) := by\n  constructor\n  intro K hK\n  suffices Measure.pi μ (Set.univ.pi fun j => Function.eval j '' K) < ⊤ by\n    exact lt_of_le_of_lt (measure_mono (univ.subset_pi_eval_image K)) this\n  rw [Measure.pi_pi]\n  refine WithTop.prod_lt_top ?_\n  exact fun i _ => IsCompact.measure_lt_top (IsCompact.image hK (continuous_apply i))\n\n"}
{"name":"MeasureTheory.Measure.instIsFiniteMeasureOnCompactsForallVolumeOfSigmaFinite","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁴ : Fintype ι\nX : ι → Type u_4\ninst✝³ : (i : ι) → MeasureTheory.MeasureSpace (X i)\ninst✝² : (i : ι) → TopologicalSpace (X i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : ∀ (i : ι), MeasureTheory.IsFiniteMeasureOnCompacts MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.IsFiniteMeasureOnCompacts MeasureTheory.MeasureSpace.volume","decl":"instance {X : ι → Type*} [∀ i, MeasureSpace (X i)] [∀ i, TopologicalSpace (X i)]\n    [∀ i, SigmaFinite (volume : Measure (X i))]\n    [∀ i, IsFiniteMeasureOnCompacts (volume : Measure (X i))] :\n    IsFiniteMeasureOnCompacts (volume : Measure (∀ i, X i)) :=\n  pi.isFiniteMeasureOnCompacts _\n\n"}
{"name":"MeasureTheory.Measure.pi.isAddHaarMeasure","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁵ : Fintype ι\ninst✝⁴ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝³ : (i : ι) → AddGroup (α i)\ninst✝² : (i : ι) → TopologicalSpace (α i)\ninst✝¹ : ∀ (i : ι), (μ i).IsAddHaarMeasure\ninst✝ : ∀ (i : ι), MeasurableAdd (α i)\n⊢ (MeasureTheory.Measure.pi μ).IsAddHaarMeasure","decl":"@[to_additive]\ninstance pi.isHaarMeasure [∀ i, Group (α i)] [∀ i, TopologicalSpace (α i)]\n    [∀ i, IsHaarMeasure (μ i)] [∀ i, MeasurableMul (α i)] : IsHaarMeasure (Measure.pi μ) where\n\n"}
{"name":"MeasureTheory.Measure.pi.isHaarMeasure","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝⁵ : Fintype ι\ninst✝⁴ : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝³ : (i : ι) → Group (α i)\ninst✝² : (i : ι) → TopologicalSpace (α i)\ninst✝¹ : ∀ (i : ι), (μ i).IsHaarMeasure\ninst✝ : ∀ (i : ι), MeasurableMul (α i)\n⊢ (MeasureTheory.Measure.pi μ).IsHaarMeasure","decl":"@[to_additive]\ninstance pi.isHaarMeasure [∀ i, Group (α i)] [∀ i, TopologicalSpace (α i)]\n    [∀ i, IsHaarMeasure (μ i)] [∀ i, MeasurableMul (α i)] : IsHaarMeasure (Measure.pi μ) where\n\n"}
{"name":"MeasureTheory.Measure.instIsHaarMeasureForallVolumeOfMeasurableMulOfSigmaFinite","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁶ : Fintype ι\nG : ι → Type u_4\ninst✝⁵ : (i : ι) → Group (G i)\ninst✝⁴ : (i : ι) → MeasureTheory.MeasureSpace (G i)\ninst✝³ : ∀ (i : ι), MeasurableMul (G i)\ninst✝² : (i : ι) → TopologicalSpace (G i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : ∀ (i : ι), MeasureTheory.MeasureSpace.volume.IsHaarMeasure\n⊢ MeasureTheory.MeasureSpace.volume.IsHaarMeasure","decl":"@[to_additive]\ninstance {G : ι → Type*} [∀ i, Group (G i)] [∀ i, MeasureSpace (G i)] [∀ i, MeasurableMul (G i)]\n    [∀ i, TopologicalSpace (G i)] [∀ i, SigmaFinite (volume : Measure (G i))]\n    [∀ i, IsHaarMeasure (volume : Measure (G i))] : IsHaarMeasure (volume : Measure (∀ i, G i)) :=\n  pi.isHaarMeasure _\n\n"}
{"name":"MeasureTheory.Measure.instIsAddHaarMeasureForallVolumeOfMeasurableAddOfSigmaFinite","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁶ : Fintype ι\nG : ι → Type u_4\ninst✝⁵ : (i : ι) → AddGroup (G i)\ninst✝⁴ : (i : ι) → MeasureTheory.MeasureSpace (G i)\ninst✝³ : ∀ (i : ι), MeasurableAdd (G i)\ninst✝² : (i : ι) → TopologicalSpace (G i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : ∀ (i : ι), MeasureTheory.MeasureSpace.volume.IsAddHaarMeasure\n⊢ MeasureTheory.MeasureSpace.volume.IsAddHaarMeasure","decl":"@[to_additive]\ninstance {G : ι → Type*} [∀ i, Group (G i)] [∀ i, MeasureSpace (G i)] [∀ i, MeasurableMul (G i)]\n    [∀ i, TopologicalSpace (G i)] [∀ i, SigmaFinite (volume : Measure (G i))]\n    [∀ i, IsHaarMeasure (volume : Measure (G i))] : IsHaarMeasure (volume : Measure (∀ i, G i)) :=\n  pi.isHaarMeasure _\n\n"}
{"name":"MeasureTheory.volume_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → MeasureTheory.MeasureSpace (α i)\n⊢ Eq MeasureTheory.MeasureSpace.volume (MeasureTheory.Measure.pi fun x => MeasureTheory.MeasureSpace.volume)","decl":"theorem volume_pi [∀ i, MeasureSpace (α i)] :\n    (volume : Measure (∀ i, α i)) = Measure.pi fun _ => volume :=\n  rfl\n\n"}
{"name":"MeasureTheory.volume_pi_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\ninst✝¹ : (i : ι) → MeasureTheory.MeasureSpace (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ns : (i : ι) → Set (α i)\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.univ.pi s)) (Finset.univ.prod fun i => MeasureTheory.MeasureSpace.volume (s i))","decl":"theorem volume_pi_pi [∀ i, MeasureSpace (α i)] [∀ i, SigmaFinite (volume : Measure (α i))]\n    (s : ∀ i, Set (α i)) : volume (pi univ s) = ∏ i, volume (s i) :=\n  Measure.pi_pi (fun _ => volume) s\n\n"}
{"name":"MeasureTheory.volume_pi_ball","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasureTheory.MeasureSpace (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : (i : ι) → MetricSpace (α i)\nx : (i : ι) → α i\nr : Real\nhr : LT.lt 0 r\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.ball x r)) (Finset.univ.prod fun i => MeasureTheory.MeasureSpace.volume (Metric.ball (x i) r))","decl":"theorem volume_pi_ball [∀ i, MeasureSpace (α i)] [∀ i, SigmaFinite (volume : Measure (α i))]\n    [∀ i, MetricSpace (α i)] (x : ∀ i, α i) {r : ℝ} (hr : 0 < r) :\n    volume (Metric.ball x r) = ∏ i, volume (Metric.ball (x i) r) :=\n  Measure.pi_ball _ _ hr\n\n"}
{"name":"MeasureTheory.volume_pi_closedBall","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → MeasureTheory.MeasureSpace (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : (i : ι) → MetricSpace (α i)\nx : (i : ι) → α i\nr : Real\nhr : LE.le 0 r\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall x r)) (Finset.univ.prod fun i => MeasureTheory.MeasureSpace.volume (Metric.closedBall (x i) r))","decl":"theorem volume_pi_closedBall [∀ i, MeasureSpace (α i)] [∀ i, SigmaFinite (volume : Measure (α i))]\n    [∀ i, MetricSpace (α i)] (x : ∀ i, α i) {r : ℝ} (hr : 0 ≤ r) :\n    volume (Metric.closedBall x r) = ∏ i, volume (Metric.closedBall (x i) r) :=\n  Measure.pi_closedBall _ _ hr\n\n"}
{"name":"MeasureTheory.Pi.isAddLeftInvariant_volume","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁵ : Fintype ι\nα : Type u_4\ninst✝⁴ : AddGroup α\ninst✝³ : MeasureTheory.MeasureSpace α\ninst✝² : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝¹ : MeasurableAdd α\ninst✝ : MeasureTheory.MeasureSpace.volume.IsAddLeftInvariant\n⊢ MeasureTheory.MeasureSpace.volume.IsAddLeftInvariant","decl":"/-- We intentionally restrict this only to the nondependent function space, since type-class\ninference cannot find an instance for `ι → ℝ` when this is stated for dependent function spaces. -/\n@[to_additive \"We intentionally restrict this only to the nondependent function space, since\ntype-class inference cannot find an instance for `ι → ℝ` when this is stated for dependent function\nspaces.\"]\ninstance Pi.isMulLeftInvariant_volume {α} [Group α] [MeasureSpace α]\n    [SigmaFinite (volume : Measure α)] [MeasurableMul α] [IsMulLeftInvariant (volume : Measure α)] :\n    IsMulLeftInvariant (volume : Measure (ι → α)) :=\n  pi.isMulLeftInvariant _\n\n"}
{"name":"MeasureTheory.Pi.isMulLeftInvariant_volume","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁵ : Fintype ι\nα : Type u_4\ninst✝⁴ : Group α\ninst✝³ : MeasureTheory.MeasureSpace α\ninst✝² : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝¹ : MeasurableMul α\ninst✝ : MeasureTheory.MeasureSpace.volume.IsMulLeftInvariant\n⊢ MeasureTheory.MeasureSpace.volume.IsMulLeftInvariant","decl":"/-- We intentionally restrict this only to the nondependent function space, since type-class\ninference cannot find an instance for `ι → ℝ` when this is stated for dependent function spaces. -/\n@[to_additive \"We intentionally restrict this only to the nondependent function space, since\ntype-class inference cannot find an instance for `ι → ℝ` when this is stated for dependent function\nspaces.\"]\ninstance Pi.isMulLeftInvariant_volume {α} [Group α] [MeasureSpace α]\n    [SigmaFinite (volume : Measure α)] [MeasurableMul α] [IsMulLeftInvariant (volume : Measure α)] :\n    IsMulLeftInvariant (volume : Measure (ι → α)) :=\n  pi.isMulLeftInvariant _\n\n"}
{"name":"MeasureTheory.Pi.isNegInvariant_volume","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁵ : Fintype ι\nα : Type u_4\ninst✝⁴ : AddGroup α\ninst✝³ : MeasureTheory.MeasureSpace α\ninst✝² : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝¹ : MeasurableNeg α\ninst✝ : MeasureTheory.MeasureSpace.volume.IsNegInvariant\n⊢ MeasureTheory.MeasureSpace.volume.IsNegInvariant","decl":"/-- We intentionally restrict this only to the nondependent function space, since type-class\ninference cannot find an instance for `ι → ℝ` when this is stated for dependent function spaces. -/\n@[to_additive \"We intentionally restrict this only to the nondependent function space, since\ntype-class inference cannot find an instance for `ι → ℝ` when this is stated for dependent function\nspaces.\"]\ninstance Pi.isInvInvariant_volume {α} [Group α] [MeasureSpace α] [SigmaFinite (volume : Measure α)]\n    [MeasurableInv α] [IsInvInvariant (volume : Measure α)] :\n    IsInvInvariant (volume : Measure (ι → α)) :=\n  pi.isInvInvariant _\n\n"}
{"name":"MeasureTheory.Pi.isInvInvariant_volume","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝⁵ : Fintype ι\nα : Type u_4\ninst✝⁴ : Group α\ninst✝³ : MeasureTheory.MeasureSpace α\ninst✝² : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝¹ : MeasurableInv α\ninst✝ : MeasureTheory.MeasureSpace.volume.IsInvInvariant\n⊢ MeasureTheory.MeasureSpace.volume.IsInvInvariant","decl":"/-- We intentionally restrict this only to the nondependent function space, since type-class\ninference cannot find an instance for `ι → ℝ` when this is stated for dependent function spaces. -/\n@[to_additive \"We intentionally restrict this only to the nondependent function space, since\ntype-class inference cannot find an instance for `ι → ℝ` when this is stated for dependent function\nspaces.\"]\ninstance Pi.isInvInvariant_volume {α} [Group α] [MeasureSpace α] [SigmaFinite (volume : Measure α)]\n    [MeasurableInv α] [IsInvInvariant (volume : Measure α)] :\n    IsInvInvariant (volume : Measure (ι → α)) :=\n  pi.isInvInvariant _\n\n"}
{"name":"MeasureTheory.measurePreserving_piEquivPiSubtypeProd","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_3\ninst✝² : Fintype ι\nm : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\np : ι → Prop\ninst✝ : DecidablePred p\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.piEquivPiSubtypeProd α p)) (MeasureTheory.Measure.pi μ) ((MeasureTheory.Measure.pi fun i => μ ↑i).prod (MeasureTheory.Measure.pi fun i => μ ↑i))","decl":"theorem measurePreserving_piEquivPiSubtypeProd (p : ι → Prop) [DecidablePred p] :\n    MeasurePreserving (MeasurableEquiv.piEquivPiSubtypeProd α p) (Measure.pi μ)\n      ((Measure.pi fun i : Subtype p => μ i).prod (Measure.pi fun i => μ i)) := by\n  set e := (MeasurableEquiv.piEquivPiSubtypeProd α p).symm\n  refine MeasurePreserving.symm e ?_\n  refine ⟨e.measurable, (pi_eq fun s _ => ?_).symm⟩\n  have : e ⁻¹' pi univ s =\n      (pi univ fun i : { i // p i } => s i) ×ˢ pi univ fun i : { i // ¬p i } => s i :=\n    Equiv.preimage_piEquivPiSubtypeProd_symm_pi p s\n  rw [e.map_apply, this, prod_prod, pi_pi, pi_pi]\n  exact Fintype.prod_subtype_mul_prod_subtype p fun i => μ i (s i)\n\n"}
{"name":"MeasureTheory.volume_preserving_piEquivPiSubtypeProd","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝³ : Fintype ι\nα : ι → Type u_4\ninst✝² : (i : ι) → MeasureTheory.MeasureSpace (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\np : ι → Prop\ninst✝ : DecidablePred p\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.piEquivPiSubtypeProd α p)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem volume_preserving_piEquivPiSubtypeProd (α : ι → Type*)\n    [∀ i, MeasureSpace (α i)] [∀ i, SigmaFinite (volume : Measure (α i))] (p : ι → Prop)\n    [DecidablePred p] : MeasurePreserving (MeasurableEquiv.piEquivPiSubtypeProd α p) :=\n  measurePreserving_piEquivPiSubtypeProd (fun _ => volume) p\n\n"}
{"name":"MeasureTheory.measurePreserving_piCongrLeft","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nι' : Type u_2\nα : ι → Type u_3\ninst✝² : Fintype ι\nm : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝¹ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\ninst✝ : Fintype ι'\nf : Equiv ι' ι\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.piCongrLeft α f)) (MeasureTheory.Measure.pi fun i' => μ (f i')) (MeasureTheory.Measure.pi μ)","decl":"theorem measurePreserving_piCongrLeft (f : ι' ≃ ι) :\n    MeasurePreserving (MeasurableEquiv.piCongrLeft α f)\n      (Measure.pi fun i' => μ (f i')) (Measure.pi μ) where\n  measurable := (MeasurableEquiv.piCongrLeft α f).measurable\n  map_eq := by\n    refine (pi_eq fun s _ => ?_).symm\n    rw [MeasurableEquiv.map_apply, MeasurableEquiv.coe_piCongrLeft f,\n      Equiv.piCongrLeft_preimage_univ_pi, pi_pi _ _, f.prod_comp (fun i => μ i (s i))]\n\n"}
{"name":"MeasureTheory.volume_measurePreserving_piCongrLeft","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nι' : Type u_2\ninst✝³ : Fintype ι\ninst✝² : Fintype ι'\nα : ι → Type u_4\nf : Equiv ι' ι\ninst✝¹ : (i : ι) → MeasureTheory.MeasureSpace (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.piCongrLeft α f)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem volume_measurePreserving_piCongrLeft (α : ι → Type*) (f : ι' ≃ ι)\n    [∀ i, MeasureSpace (α i)] [∀ i, SigmaFinite (volume : Measure (α i))] :\n    MeasurePreserving (MeasurableEquiv.piCongrLeft α f) volume volume :=\n  measurePreserving_piCongrLeft (fun _ ↦ volume) f\n\n"}
{"name":"MeasureTheory.measurePreserving_arrowProdEquivProdArrow","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"α : Type u_4\nβ : Type u_5\nγ : Type u_6\ninst✝⁴ : MeasurableSpace α\ninst✝³ : MeasurableSpace β\ninst✝² : Fintype γ\nμ : γ → MeasureTheory.Measure α\nν : γ → MeasureTheory.Measure β\ninst✝¹ : ∀ (i : γ), MeasureTheory.SigmaFinite (μ i)\ninst✝ : ∀ (i : γ), MeasureTheory.SigmaFinite (ν i)\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.arrowProdEquivProdArrow α β γ)) (MeasureTheory.Measure.pi fun i => (μ i).prod (ν i)) ((MeasureTheory.Measure.pi fun i => μ i).prod (MeasureTheory.Measure.pi fun i => ν i))","decl":"theorem measurePreserving_arrowProdEquivProdArrow (α β γ : Type*) [MeasurableSpace α]\n    [MeasurableSpace β] [Fintype γ] (μ : γ → Measure α) (ν : γ → Measure β) [∀ i, SigmaFinite (μ i)]\n    [∀ i, SigmaFinite (ν i)] :\n    MeasurePreserving (MeasurableEquiv.arrowProdEquivProdArrow α β γ)\n      (.pi fun i ↦ (μ i).prod (ν i))\n        ((Measure.pi fun i ↦ μ i).prod (Measure.pi fun i ↦ ν i)) where\n  measurable := (MeasurableEquiv.arrowProdEquivProdArrow α β γ).measurable\n  map_eq := by\n    refine (FiniteSpanningSetsIn.ext ?_ (isPiSystem_pi.prod isPiSystem_pi)\n      ((FiniteSpanningSetsIn.pi fun i ↦ (μ i).toFiniteSpanningSetsIn).prod\n      (FiniteSpanningSetsIn.pi (fun i ↦ (ν i).toFiniteSpanningSetsIn))) ?_).symm\n    · refine (generateFrom_eq_prod generateFrom_pi generateFrom_pi ?_ ?_).symm\n      · exact (FiniteSpanningSetsIn.pi (fun i ↦ (μ i).toFiniteSpanningSetsIn)).isCountablySpanning\n      · exact (FiniteSpanningSetsIn.pi (fun i ↦ (ν i).toFiniteSpanningSetsIn)).isCountablySpanning\n    · rintro _ ⟨s, ⟨s, _, rfl⟩, ⟨_, ⟨t, _, rfl⟩, rfl⟩⟩\n      rw [MeasurableEquiv.map_apply, MeasurableEquiv.arrowProdEquivProdArrow,\n        MeasurableEquiv.coe_mk]\n      rw [show Equiv.arrowProdEquivProdArrow α β γ ⁻¹' (univ.pi s ×ˢ univ.pi t) =\n          (univ.pi fun i ↦ s i ×ˢ t i) by\n          ext; simp [Equiv.arrowProdEquivProdArrow, Equiv.coe_fn_mk, Set.mem_pi, forall_and]]\n      simp_rw [pi_pi, prod_prod, pi_pi, Finset.prod_mul_distrib]\n\n"}
{"name":"MeasureTheory.volume_measurePreserving_arrowProdEquivProdArrow","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"α : Type u_4\nβ : Type u_5\nγ : Type u_6\ninst✝⁴ : MeasureTheory.MeasureSpace α\ninst✝³ : MeasureTheory.MeasureSpace β\ninst✝² : Fintype γ\ninst✝¹ : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ninst✝ : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.arrowProdEquivProdArrow α β γ)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem volume_measurePreserving_arrowProdEquivProdArrow (α β γ : Type*) [MeasureSpace α]\n    [MeasureSpace β] [Fintype γ] [SigmaFinite (volume : Measure α)]\n    [SigmaFinite (volume : Measure β)] :\n    MeasurePreserving (MeasurableEquiv.arrowProdEquivProdArrow α β γ) :=\n  measurePreserving_arrowProdEquivProdArrow α β γ (fun _ ↦ volume) (fun _ ↦ volume)\n\n"}
{"name":"MeasureTheory.measurePreserving_sumPiEquivProdPi_symm","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nι' : Type u_2\ninst✝² : Fintype ι\ninst✝¹ : Fintype ι'\nπ : Sum ι ι' → Type u_4\nm : (i : Sum ι ι') → MeasurableSpace (π i)\nμ : (i : Sum ι ι') → MeasureTheory.Measure (π i)\ninst✝ : ∀ (i : Sum ι ι'), MeasureTheory.SigmaFinite (μ i)\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.sumPiEquivProdPi π).symm) ((MeasureTheory.Measure.pi fun i => μ (Sum.inl i)).prod (MeasureTheory.Measure.pi fun i => μ (Sum.inr i))) (MeasureTheory.Measure.pi μ)","decl":"theorem measurePreserving_sumPiEquivProdPi_symm {π : ι ⊕ ι' → Type*}\n    {m : ∀ i, MeasurableSpace (π i)} (μ : ∀ i, Measure (π i)) [∀ i, SigmaFinite (μ i)] :\n    MeasurePreserving (MeasurableEquiv.sumPiEquivProdPi π).symm\n      ((Measure.pi fun i => μ (.inl i)).prod (Measure.pi fun i => μ (.inr i))) (Measure.pi μ) where\n  measurable := (MeasurableEquiv.sumPiEquivProdPi π).symm.measurable\n  map_eq := by\n    refine (pi_eq fun s _ => ?_).symm\n    simp_rw [MeasurableEquiv.map_apply, MeasurableEquiv.coe_sumPiEquivProdPi_symm,\n      Equiv.sumPiEquivProdPi_symm_preimage_univ_pi, Measure.prod_prod, Measure.pi_pi,\n      Fintype.prod_sum_type]\n\n"}
{"name":"MeasureTheory.volume_measurePreserving_sumPiEquivProdPi_symm","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nι' : Type u_2\ninst✝³ : Fintype ι\ninst✝² : Fintype ι'\nπ : Sum ι ι' → Type u_4\ninst✝¹ : (i : Sum ι ι') → MeasureTheory.MeasureSpace (π i)\ninst✝ : ∀ (i : Sum ι ι'), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.sumPiEquivProdPi π).symm) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem volume_measurePreserving_sumPiEquivProdPi_symm (π : ι ⊕ ι' → Type*)\n    [∀ i, MeasureSpace (π i)] [∀ i, SigmaFinite (volume : Measure (π i))] :\n    MeasurePreserving (MeasurableEquiv.sumPiEquivProdPi π).symm volume volume :=\n  measurePreserving_sumPiEquivProdPi_symm (fun _ ↦ volume)\n\n"}
{"name":"MeasureTheory.measurePreserving_sumPiEquivProdPi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nι' : Type u_2\ninst✝² : Fintype ι\ninst✝¹ : Fintype ι'\nπ : Sum ι ι' → Type u_4\n_m : (i : Sum ι ι') → MeasurableSpace (π i)\nμ : (i : Sum ι ι') → MeasureTheory.Measure (π i)\ninst✝ : ∀ (i : Sum ι ι'), MeasureTheory.SigmaFinite (μ i)\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.sumPiEquivProdPi π)) (MeasureTheory.Measure.pi μ) ((MeasureTheory.Measure.pi fun i => μ (Sum.inl i)).prod (MeasureTheory.Measure.pi fun i => μ (Sum.inr i)))","decl":"theorem measurePreserving_sumPiEquivProdPi {π : ι ⊕ ι' → Type*} {_m : ∀ i, MeasurableSpace (π i)}\n    (μ : ∀ i, Measure (π i)) [∀ i, SigmaFinite (μ i)] :\n    MeasurePreserving (MeasurableEquiv.sumPiEquivProdPi π)\n      (Measure.pi μ) ((Measure.pi fun i => μ (.inl i)).prod (Measure.pi fun i => μ (.inr i))) :=\n  measurePreserving_sumPiEquivProdPi_symm μ |>.symm\n\n"}
{"name":"MeasureTheory.volume_measurePreserving_sumPiEquivProdPi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\nι' : Type u_2\ninst✝³ : Fintype ι\ninst✝² : Fintype ι'\nπ : Sum ι ι' → Type u_4\ninst✝¹ : (i : Sum ι ι') → MeasureTheory.MeasureSpace (π i)\ninst✝ : ∀ (i : Sum ι ι'), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.sumPiEquivProdPi π)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem volume_measurePreserving_sumPiEquivProdPi (π : ι ⊕ ι' → Type*)\n    [∀ i, MeasureSpace (π i)] [∀ i, SigmaFinite (volume : Measure (π i))] :\n    MeasurePreserving (MeasurableEquiv.sumPiEquivProdPi π) volume volume :=\n  measurePreserving_sumPiEquivProdPi (fun _ ↦ volume)\n\n"}
{"name":"MeasureTheory.measurePreserving_piFinSuccAbove","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u\nm : (i : Fin (HAdd.hAdd n 1)) → MeasurableSpace (α i)\nμ : (i : Fin (HAdd.hAdd n 1)) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : Fin (HAdd.hAdd n 1)), MeasureTheory.SigmaFinite (μ i)\ni : Fin (HAdd.hAdd n 1)\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.piFinSuccAbove α i)) (MeasureTheory.Measure.pi μ) ((μ i).prod (MeasureTheory.Measure.pi fun j => μ (i.succAbove j)))","decl":"theorem measurePreserving_piFinSuccAbove {n : ℕ} {α : Fin (n + 1) → Type u}\n    {m : ∀ i, MeasurableSpace (α i)} (μ : ∀ i, Measure (α i)) [∀ i, SigmaFinite (μ i)]\n    (i : Fin (n + 1)) :\n    MeasurePreserving (MeasurableEquiv.piFinSuccAbove α i) (Measure.pi μ)\n      ((μ i).prod <| Measure.pi fun j => μ (i.succAbove j)) := by\n  set e := (MeasurableEquiv.piFinSuccAbove α i).symm\n  refine MeasurePreserving.symm e ?_\n  refine ⟨e.measurable, (pi_eq fun s _ => ?_).symm⟩\n  rw [e.map_apply, i.prod_univ_succAbove _, ← pi_pi, ← prod_prod]\n  congr 1 with ⟨x, f⟩\n  simp [e, i.forall_iff_succAbove]\n\n"}
{"name":"MeasureTheory.volume_preserving_piFinSuccAbove","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u\ninst✝¹ : (i : Fin (HAdd.hAdd n 1)) → MeasureTheory.MeasureSpace (α i)\ninst✝ : ∀ (i : Fin (HAdd.hAdd n 1)), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\ni : Fin (HAdd.hAdd n 1)\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.piFinSuccAbove α i)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem volume_preserving_piFinSuccAbove {n : ℕ} (α : Fin (n + 1) → Type u)\n    [∀ i, MeasureSpace (α i)] [∀ i, SigmaFinite (volume : Measure (α i))] (i : Fin (n + 1)) :\n    MeasurePreserving (MeasurableEquiv.piFinSuccAbove α i) :=\n  measurePreserving_piFinSuccAbove (fun _ => volume) i\n\n"}
{"name":"MeasureTheory.measurePreserving_piUnique","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\nπ : ι → Type u_4\ninst✝ : Unique ι\nm : (i : ι) → MeasurableSpace (π i)\nμ : (i : ι) → MeasureTheory.Measure (π i)\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.piUnique π)) (MeasureTheory.Measure.pi μ) (μ Inhabited.default)","decl":"theorem measurePreserving_piUnique {π : ι → Type*} [Unique ι] {m : ∀ i, MeasurableSpace (π i)}\n    (μ : ∀ i, Measure (π i)) :\n    MeasurePreserving (MeasurableEquiv.piUnique π) (Measure.pi μ) (μ default) where\n  measurable := (MeasurableEquiv.piUnique π).measurable\n  map_eq := by\n    set e := MeasurableEquiv.piUnique π\n    have : (piPremeasure fun i => (μ i).toOuterMeasure) = Measure.map e.symm (μ default) := by\n      ext1 s\n      rw [piPremeasure, Fintype.prod_unique, e.symm.map_apply, coe_toOuterMeasure]\n      congr 1; exact e.toEquiv.image_eq_preimage s\n    simp_rw [Measure.pi, OuterMeasure.pi, this, ← coe_toOuterMeasure, boundedBy_eq_self,\n      toOuterMeasure_toMeasure, MeasurableEquiv.map_map_symm]\n\n"}
{"name":"MeasureTheory.volume_preserving_piUnique","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝² : Fintype ι\nπ : ι → Type u_4\ninst✝¹ : Unique ι\ninst✝ : (i : ι) → MeasureTheory.MeasureSpace (π i)\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.piUnique π)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem volume_preserving_piUnique (π : ι → Type*) [Unique ι] [∀ i, MeasureSpace (π i)] :\n    MeasurePreserving (MeasurableEquiv.piUnique π) volume volume :=\n  measurePreserving_piUnique _\n\n"}
{"name":"MeasureTheory.measurePreserving_funUnique","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"β : Type u\n_m : MeasurableSpace β\nμ : MeasureTheory.Measure β\nα : Type v\ninst✝ : Unique α\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.funUnique α β)) (MeasureTheory.Measure.pi fun x => μ) μ","decl":"theorem measurePreserving_funUnique {β : Type u} {_m : MeasurableSpace β} (μ : Measure β)\n    (α : Type v) [Unique α] :\n    MeasurePreserving (MeasurableEquiv.funUnique α β) (Measure.pi fun _ : α => μ) μ :=\n  measurePreserving_piUnique _\n\n"}
{"name":"MeasureTheory.volume_preserving_funUnique","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Unique α\ninst✝ : MeasureTheory.MeasureSpace β\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.funUnique α β)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem volume_preserving_funUnique (α : Type u) (β : Type v) [Unique α] [MeasureSpace β] :\n    MeasurePreserving (MeasurableEquiv.funUnique α β) volume volume :=\n  measurePreserving_funUnique volume α\n\n"}
{"name":"MeasureTheory.measurePreserving_piFinTwo","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"α : Fin 2 → Type u\nm : (i : Fin 2) → MeasurableSpace (α i)\nμ : (i : Fin 2) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : Fin 2), MeasureTheory.SigmaFinite (μ i)\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.piFinTwo α)) (MeasureTheory.Measure.pi μ) ((μ 0).prod (μ 1))","decl":"theorem measurePreserving_piFinTwo {α : Fin 2 → Type u} {m : ∀ i, MeasurableSpace (α i)}\n    (μ : ∀ i, Measure (α i)) [∀ i, SigmaFinite (μ i)] :\n    MeasurePreserving (MeasurableEquiv.piFinTwo α) (Measure.pi μ) ((μ 0).prod (μ 1)) := by\n  refine ⟨MeasurableEquiv.measurable _, (Measure.prod_eq fun s t _ _ => ?_).symm⟩\n  rw [MeasurableEquiv.map_apply, MeasurableEquiv.piFinTwo_apply, Fin.preimage_apply_01_prod,\n    Measure.pi_pi, Fin.prod_univ_two]\n  rfl\n\n"}
{"name":"MeasureTheory.volume_preserving_piFinTwo","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"α : Fin 2 → Type u\ninst✝¹ : (i : Fin 2) → MeasureTheory.MeasureSpace (α i)\ninst✝ : ∀ (i : Fin 2), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.piFinTwo α)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem volume_preserving_piFinTwo (α : Fin 2 → Type u) [∀ i, MeasureSpace (α i)]\n    [∀ i, SigmaFinite (volume : Measure (α i))] :\n    MeasurePreserving (MeasurableEquiv.piFinTwo α) volume volume :=\n  measurePreserving_piFinTwo _\n\n"}
{"name":"MeasureTheory.measurePreserving_finTwoArrow_vec","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"α : Type u\nx✝ : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\n⊢ MeasureTheory.MeasurePreserving (⇑MeasurableEquiv.finTwoArrow) (MeasureTheory.Measure.pi (Matrix.vecCons μ (Matrix.vecCons ν Matrix.vecEmpty))) (μ.prod ν)","decl":"theorem measurePreserving_finTwoArrow_vec {α : Type u} {_ : MeasurableSpace α} (μ ν : Measure α)\n    [SigmaFinite μ] [SigmaFinite ν] :\n    MeasurePreserving MeasurableEquiv.finTwoArrow (Measure.pi ![μ, ν]) (μ.prod ν) :=\n  haveI : ∀ i, SigmaFinite (![μ, ν] i) := Fin.forall_fin_two.2 ⟨‹_›, ‹_›⟩\n  measurePreserving_piFinTwo _\n\n"}
{"name":"MeasureTheory.measurePreserving_finTwoArrow","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"α : Type u\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\n⊢ MeasureTheory.MeasurePreserving (⇑MeasurableEquiv.finTwoArrow) (MeasureTheory.Measure.pi fun x => μ) (μ.prod μ)","decl":"theorem measurePreserving_finTwoArrow {α : Type u} {m : MeasurableSpace α} (μ : Measure α)\n    [SigmaFinite μ] :\n    MeasurePreserving MeasurableEquiv.finTwoArrow (Measure.pi fun _ => μ) (μ.prod μ) := by\n  simpa only [Matrix.vec_single_eq_const, Matrix.vecCons_const] using\n    measurePreserving_finTwoArrow_vec μ μ\n\n"}
{"name":"MeasureTheory.volume_preserving_finTwoArrow","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"α : Type u\ninst✝¹ : MeasureTheory.MeasureSpace α\ninst✝ : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.MeasurePreserving (⇑MeasurableEquiv.finTwoArrow) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem volume_preserving_finTwoArrow (α : Type u) [MeasureSpace α]\n    [SigmaFinite (volume : Measure α)] :\n    MeasurePreserving (@MeasurableEquiv.finTwoArrow α _) volume volume :=\n  measurePreserving_finTwoArrow volume\n\n"}
{"name":"MeasureTheory.measurePreserving_pi_empty","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u\nα : ι → Type v\ninst✝¹ : Fintype ι\ninst✝ : IsEmpty ι\nm : (i : ι) → MeasurableSpace (α i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.ofUniqueOfUnique ((i : ι) → α i) Unit)) (MeasureTheory.Measure.pi μ) (MeasureTheory.Measure.dirac Unit.unit)","decl":"theorem measurePreserving_pi_empty {ι : Type u} {α : ι → Type v} [Fintype ι] [IsEmpty ι]\n    {m : ∀ i, MeasurableSpace (α i)} (μ : ∀ i, Measure (α i)) :\n    MeasurePreserving (MeasurableEquiv.ofUniqueOfUnique (∀ i, α i) Unit) (Measure.pi μ)\n      (Measure.dirac ()) := by\n  set e := MeasurableEquiv.ofUniqueOfUnique (∀ i, α i) Unit\n  refine ⟨e.measurable, ?_⟩\n  rw [Measure.pi_of_empty, Measure.map_dirac e.measurable]\n\n"}
{"name":"MeasureTheory.volume_preserving_pi_empty","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u\nα : ι → Type v\ninst✝² : Fintype ι\ninst✝¹ : IsEmpty ι\ninst✝ : (i : ι) → MeasureTheory.MeasureSpace (α i)\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.ofUniqueOfUnique ((i : ι) → α i) Unit)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem volume_preserving_pi_empty {ι : Type u} (α : ι → Type v) [Fintype ι] [IsEmpty ι]\n    [∀ i, MeasureSpace (α i)] :\n    MeasurePreserving (MeasurableEquiv.ofUniqueOfUnique (∀ i, α i) Unit) volume volume :=\n  measurePreserving_pi_empty fun _ => volume\n\n"}
{"name":"MeasureTheory.measurePreserving_piFinsetUnion","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_4\nα : ι → Type u_5\nx✝ : (i : ι) → MeasurableSpace (α i)\ninst✝¹ : DecidableEq ι\ns t : Finset ι\nh : Disjoint s t\nμ : (i : ι) → MeasureTheory.Measure (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (μ i)\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.piFinsetUnion α h)) ((MeasureTheory.Measure.pi fun i => μ ↑i).prod (MeasureTheory.Measure.pi fun i => μ ↑i)) (MeasureTheory.Measure.pi fun i => μ ↑i)","decl":"theorem measurePreserving_piFinsetUnion {ι : Type*} {α : ι → Type*}\n    {_ : ∀ i, MeasurableSpace (α i)} [DecidableEq ι] {s t : Finset ι} (h : Disjoint s t)\n    (μ : ∀ i, Measure (α i)) [∀ i, SigmaFinite (μ i)] :\n    MeasurePreserving (MeasurableEquiv.piFinsetUnion α h)\n      ((Measure.pi fun i : s ↦ μ i).prod (Measure.pi fun i : t ↦ μ i))\n      (Measure.pi fun i : ↥(s ∪ t) ↦ μ i) :=\n  let e := Equiv.Finset.union s t h\n  measurePreserving_piCongrLeft (fun i : ↥(s ∪ t) ↦ μ i) e |>.comp <|\n    measurePreserving_sumPiEquivProdPi_symm fun b ↦ μ (e b)\n\n"}
{"name":"MeasureTheory.volume_preserving_piFinsetUnion","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_4\ninst✝² : DecidableEq ι\nα : ι → Type u_5\ns t : Finset ι\nh : Disjoint s t\ninst✝¹ : (i : ι) → MeasureTheory.MeasureSpace (α i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.piFinsetUnion α h)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem volume_preserving_piFinsetUnion {ι : Type*} [DecidableEq ι] (α : ι → Type*) {s t : Finset ι}\n    (h : Disjoint s t) [∀ i, MeasureSpace (α i)] [∀ i, SigmaFinite (volume : Measure (α i))] :\n    MeasurePreserving (MeasurableEquiv.piFinsetUnion α h) volume volume :=\n  measurePreserving_piFinsetUnion h (fun _ ↦ volume)\n\n"}
{"name":"MeasureTheory.measurePreserving_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_4\ninst✝³ : Fintype ι\nα : ι → Type v\nβ : ι → Type u_5\ninst✝² : (i : ι) → MeasurableSpace (α i)\ninst✝¹ : (i : ι) → MeasurableSpace (β i)\nμ : (i : ι) → MeasureTheory.Measure (α i)\nν : (i : ι) → MeasureTheory.Measure (β i)\nf : (i : ι) → α i → β i\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite (ν i)\nhf : ∀ (i : ι), MeasureTheory.MeasurePreserving (f i) (μ i) (ν i)\n⊢ MeasureTheory.MeasurePreserving (fun a i => f i (a i)) (MeasureTheory.Measure.pi μ) (MeasureTheory.Measure.pi ν)","decl":"theorem measurePreserving_pi {ι : Type*} [Fintype ι] {α : ι → Type v} {β : ι → Type*}\n    [∀ i, MeasurableSpace (α i)] [∀ i, MeasurableSpace (β i)]\n    (μ : (i : ι) → Measure (α i)) (ν : (i : ι) → Measure (β i))\n    {f : (i : ι) → (α i) → (β i)} [∀ i, SigmaFinite (ν i)]\n    (hf : ∀ i, MeasurePreserving (f i) (μ i) (ν i)) :\n    MeasurePreserving (fun a i ↦ f i (a i)) (Measure.pi μ) (Measure.pi ν) where\n  measurable :=\n    measurable_pi_iff.mpr <| fun i ↦ (hf i).measurable.comp (measurable_pi_apply i)\n  map_eq := by\n    haveI : ∀ i, SigmaFinite (μ i) := fun i ↦ (hf i).sigmaFinite\n    refine (Measure.pi_eq fun s hs ↦ ?_).symm\n    rw [Measure.map_apply, Set.preimage_pi, Measure.pi_pi]\n    · simp_rw [← MeasurePreserving.measure_preimage (hf _) (hs _).nullMeasurableSet]\n    · exact measurable_pi_iff.mpr <| fun i ↦ (hf i).measurable.comp (measurable_pi_apply i)\n    · exact MeasurableSet.univ_pi hs\n\n"}
{"name":"MeasureTheory.volume_preserving_pi","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"ι : Type u_1\ninst✝³ : Fintype ι\nα' : ι → Type u_4\nβ' : ι → Type u_5\ninst✝² : (i : ι) → MeasureTheory.MeasureSpace (α' i)\ninst✝¹ : (i : ι) → MeasureTheory.MeasureSpace (β' i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\nf : (i : ι) → α' i → β' i\nhf : ∀ (i : ι), MeasureTheory.MeasurePreserving (f i) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.MeasurePreserving (fun a i => f i (a i)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"theorem volume_preserving_pi {α' β' : ι → Type*} [∀ i, MeasureSpace (α' i)]\n    [∀ i, MeasureSpace (β' i)] [∀ i, SigmaFinite (volume : Measure (β' i))]\n    {f : (i : ι) → (α' i) → (β' i)} (hf : ∀ i, MeasurePreserving (f i)) :\n    MeasurePreserving (fun (a : (i : ι) → α' i) (i : ι) ↦ (f i) (a i)) :=\n  measurePreserving_pi _ _ hf\n\n"}
{"name":"MeasureTheory.measurePreserving_arrowCongr'","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"α₁ : Type u_4\nβ₁ : Type u_5\nα₂ : Type u_6\nβ₂ : Type u_7\ninst✝⁴ : Fintype α₁\ninst✝³ : Fintype α₂\ninst✝² : MeasurableSpace β₁\ninst✝¹ : MeasurableSpace β₂\nμ : α₁ → MeasureTheory.Measure β₁\nν : α₂ → MeasureTheory.Measure β₂\ninst✝ : ∀ (i : α₂), MeasureTheory.SigmaFinite (ν i)\neα : Equiv α₁ α₂\neβ : MeasurableEquiv β₁ β₂\nhm : ∀ (i : α₁), MeasureTheory.MeasurePreserving (⇑eβ) (μ i) (ν (eα i))\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.arrowCongr' eα eβ)) (MeasureTheory.Measure.pi fun i => μ i) (MeasureTheory.Measure.pi fun i => ν i)","decl":"/-- The measurable equiv `(α₁ → β₁) ≃ᵐ (α₂ → β₂)` induced by `α₁ ≃ α₂` and `β₁ ≃ᵐ β₂` is\nmeasure preserving. -/\ntheorem measurePreserving_arrowCongr' {α₁ β₁ α₂ β₂ : Type*} [Fintype α₁] [Fintype α₂]\n    [MeasurableSpace β₁] [MeasurableSpace β₂] (μ : α₁ → Measure β₁) (ν : α₂ → Measure β₂)\n    [∀ i, SigmaFinite (ν i)] (eα : α₁ ≃ α₂) (eβ : β₁ ≃ᵐ β₂)\n    (hm : ∀ i, MeasurePreserving eβ (μ i) (ν (eα i))) :\n    MeasurePreserving (MeasurableEquiv.arrowCongr' eα eβ) (Measure.pi fun i ↦ μ i)\n      (Measure.pi fun i ↦ ν i) := by\n  classical\n  convert (measurePreserving_piCongrLeft (fun i : α₂ ↦ ν i) eα).comp\n    (measurePreserving_pi μ (fun i : α₁ ↦ ν (eα i)) hm)\n  simp only [MeasurableEquiv.arrowCongr', Equiv.arrowCongr', Equiv.arrowCongr, EquivLike.coe_coe,\n    comp_def, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, MeasurableEquiv.piCongrLeft,\n    Equiv.piCongrLeft, Equiv.symm_symm, Equiv.piCongrLeft', eq_rec_constant, Equiv.coe_fn_symm_mk]\n\n"}
{"name":"MeasureTheory.volume_preserving_arrowCongr'","module":"Mathlib.MeasureTheory.Constructions.Pi","initialProofState":"α₁ : Type u_4\nβ₁ : Type u_5\nα₂ : Type u_6\nβ₂ : Type u_7\ninst✝⁴ : Fintype α₁\ninst✝³ : Fintype α₂\ninst✝² : MeasureTheory.MeasureSpace β₁\ninst✝¹ : MeasureTheory.MeasureSpace β₂\ninst✝ : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\nhα : Equiv α₁ α₂\nhβ : MeasurableEquiv β₁ β₂\nhm : MeasureTheory.MeasurePreserving (⇑hβ) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.MeasurePreserving (⇑(MeasurableEquiv.arrowCongr' hα hβ)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"/-- The measurable equiv `(α₁ → β₁) ≃ᵐ (α₂ → β₂)` induced by `α₁ ≃ α₂` and `β₁ ≃ᵐ β₂` is\nvolume preserving. -/\n theorem volume_preserving_arrowCongr' {α₁ β₁ α₂ β₂ : Type*} [Fintype α₁] [Fintype α₂]\n    [MeasureSpace β₁] [MeasureSpace β₂] [SigmaFinite (volume : Measure β₂)]\n    (hα : α₁ ≃ α₂) (hβ : β₁ ≃ᵐ β₂) (hm : MeasurePreserving hβ) :\n    MeasurePreserving (MeasurableEquiv.arrowCongr' hα hβ) :=\n  measurePreserving_arrowCongr' (fun _ ↦ volume) (fun _ ↦ volume) hα hβ (fun _ ↦ hm)\n\n"}
