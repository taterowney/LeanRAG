{"name":"RingHom.surjective_localRingHom_iff","module":"Mathlib.RingTheory.SurjectiveOnStalks","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Type u_2\ninst✝¹ : CommRing S\nf : RingHom R S\nP : Ideal S\ninst✝ : P.IsPrime\n⊢ Iff (Function.Surjective ⇑(Localization.localRingHom (Ideal.comap f P) P f ⋯)) (∀ (s : S), Exists fun x => Exists fun r => Exists fun c => And (Not (Membership.mem P c)) (And (Not (Membership.mem P (f r))) (Eq (HMul.hMul (HMul.hMul c (f r)) s) (HMul.hMul c (f x)))))","decl":"/--\n`R_p →+* S_q` is surjective if and only if\nevery `x : S` is of the form `f x / f r` for some `f r ∉ q`.\nThis is useful when proving `SurjectiveOnStalks`.\n-/\nlemma surjective_localRingHom_iff (P : Ideal S) [P.IsPrime] :\n    Function.Surjective (Localization.localRingHom _ P f rfl) ↔\n      ∀ s : S, ∃ x r : R, ∃ c ∉ P, f r ∉ P ∧ c * f r * s = c * f x := by\n  constructor\n  · intro H y\n    obtain ⟨a, ha⟩ := H (IsLocalization.mk' _ y (1 : P.primeCompl))\n    obtain ⟨a, t, rfl⟩ := IsLocalization.mk'_surjective (P.comap f).primeCompl a\n    rw [Localization.localRingHom_mk', IsLocalization.mk'_eq_iff_eq,\n      Submonoid.coe_one, one_mul, IsLocalization.eq_iff_exists P.primeCompl] at ha\n    obtain ⟨c, hc⟩ := ha\n    simp only [← mul_assoc] at hc\n    exact ⟨_, _, _, c.2, t.2, hc.symm⟩\n  · refine fun H y ↦ Localization.ind (fun ⟨y, t, h⟩ ↦ ?_) y\n    simp only\n    obtain ⟨yx, ys, yc, hyc, hy, ey⟩ := H y\n    obtain ⟨tx, ts, yt, hyt, ht, et⟩ := H t\n    refine ⟨Localization.mk (yx * ts) ⟨ys * tx, Submonoid.mul_mem _ hy ?_⟩, ?_⟩\n    · exact fun H ↦ mul_mem (P.primeCompl.mul_mem hyt ht) h (et ▸ Ideal.mul_mem_left _ yt H)\n    · simp only [Localization.mk_eq_mk', Localization.localRingHom_mk', map_mul f,\n        IsLocalization.mk'_eq_iff_eq, IsLocalization.eq_iff_exists P.primeCompl]\n      refine ⟨⟨yc, hyc⟩ * ⟨yt, hyt⟩, ?_⟩\n      simp only [Submonoid.coe_mul]\n      convert congr($(ey.symm) * $(et)) using 1 <;> ring\n\n"}
{"name":"RingHom.surjectiveOnStalks_iff_forall_ideal","module":"Mathlib.RingTheory.SurjectiveOnStalks","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nS : Type u_2\ninst✝ : CommRing S\nf : RingHom R S\n⊢ Iff f.SurjectiveOnStalks (∀ (I : Ideal S), Ne I Top.top → ∀ (s : S), Exists fun x => Exists fun r => Exists fun c => And (Not (Membership.mem I c)) (And (Not (Membership.mem I (f r))) (Eq (HMul.hMul (HMul.hMul c (f r)) s) (HMul.hMul c (f x)))))","decl":"lemma surjectiveOnStalks_iff_forall_ideal :\n    f.SurjectiveOnStalks ↔\n      ∀ I : Ideal S, I ≠ ⊤ → ∀ s : S, ∃ x r : R, ∃ c ∉ I, f r ∉ I ∧ c * f r * s = c * f x := by\n  simp_rw [SurjectiveOnStalks, surjective_localRingHom_iff]\n  refine ⟨fun H I hI s ↦ ?_, fun H I hI ↦ H I hI.ne_top⟩\n  obtain ⟨M, hM, hIM⟩ := I.exists_le_maximal hI\n  obtain ⟨x, r, c, hc, hr, e⟩ := H M hM.isPrime s\n  exact ⟨x, r, c, fun h ↦ hc (hIM h), fun h ↦ hr (hIM h), e⟩\n\n"}
{"name":"RingHom.surjectiveOnStalks_iff_forall_maximal","module":"Mathlib.RingTheory.SurjectiveOnStalks","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nS : Type u_2\ninst✝ : CommRing S\nf : RingHom R S\n⊢ Iff f.SurjectiveOnStalks (∀ (I : Ideal S) (x : I.IsMaximal), Function.Surjective ⇑(Localization.localRingHom (Ideal.comap f I) I f ⋯))","decl":"lemma surjectiveOnStalks_iff_forall_maximal :\n    f.SurjectiveOnStalks ↔ ∀ (I : Ideal S) (_ : I.IsMaximal),\n      Function.Surjective (Localization.localRingHom _ I f rfl) := by\n  refine ⟨fun H I hI ↦ H I hI.isPrime, fun H I hI ↦ ?_⟩\n  simp_rw [surjective_localRingHom_iff] at H ⊢\n  intro s\n  obtain ⟨M, hM, hIM⟩ := I.exists_le_maximal hI.ne_top\n  obtain ⟨x, r, c, hc, hr, e⟩ := H M hM s\n  exact ⟨x, r, c, fun h ↦ hc (hIM h), fun h ↦ hr (hIM h), e⟩\n\n"}
{"name":"RingHom.surjectiveOnStalks_iff_forall_maximal'","module":"Mathlib.RingTheory.SurjectiveOnStalks","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nS : Type u_2\ninst✝ : CommRing S\nf : RingHom R S\n⊢ Iff f.SurjectiveOnStalks (∀ (I : Ideal S), I.IsMaximal → ∀ (s : S), Exists fun x => Exists fun r => Exists fun c => And (Not (Membership.mem I c)) (And (Not (Membership.mem I (f r))) (Eq (HMul.hMul (HMul.hMul c (f r)) s) (HMul.hMul c (f x)))))","decl":"lemma surjectiveOnStalks_iff_forall_maximal' :\n    f.SurjectiveOnStalks ↔ ∀ I : Ideal S, I.IsMaximal →\n      ∀ s : S, ∃ x r : R, ∃ c ∉ I, f r ∉ I ∧ c * f r * s = c * f x := by\n  simp only [surjectiveOnStalks_iff_forall_maximal, surjective_localRingHom_iff]\n\n"}
{"name":"RingHom.surjectiveOnStalks_of_exists_div","module":"Mathlib.RingTheory.SurjectiveOnStalks","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nS : Type u_2\ninst✝ : CommRing S\nf : RingHom R S\nh : ∀ (x : S), Exists fun r => Exists fun s => And (IsUnit (f s)) (Eq (HMul.hMul (f s) x) (f r))\n⊢ f.SurjectiveOnStalks","decl":"lemma surjectiveOnStalks_of_exists_div (h : ∀ x : S, ∃ r s : R, IsUnit (f s) ∧ f s * x = f r) :\n    SurjectiveOnStalks f :=\n  surjectiveOnStalks_iff_forall_ideal.mpr fun I hI x ↦\n    let ⟨r, s, hr, hr'⟩ := h x\n    ⟨r, s, 1, by simpa [← Ideal.eq_top_iff_one], fun h ↦ hI (I.eq_top_of_isUnit_mem h hr), by simpa⟩\n\n"}
{"name":"RingHom.surjectiveOnStalks_of_surjective","module":"Mathlib.RingTheory.SurjectiveOnStalks","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nS : Type u_2\ninst✝ : CommRing S\nf : RingHom R S\nh : Function.Surjective ⇑f\n⊢ f.SurjectiveOnStalks","decl":"lemma surjectiveOnStalks_of_surjective (h : Function.Surjective f) :\n    SurjectiveOnStalks f :=\n  surjectiveOnStalks_iff_forall_ideal.mpr fun _ _ s ↦\n    let ⟨r, hr⟩ := h s\n    ⟨r, 1, 1, by simpa [← Ideal.eq_top_iff_one], by simpa [← Ideal.eq_top_iff_one], by simp [hr]⟩\n\n"}
{"name":"RingHom.SurjectiveOnStalks.comp","module":"Mathlib.RingTheory.SurjectiveOnStalks","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Type u_2\ninst✝¹ : CommRing S\nT : Type u_3\ninst✝ : CommRing T\ng : RingHom S T\nf : RingHom R S\nhg : g.SurjectiveOnStalks\nhf : f.SurjectiveOnStalks\n⊢ (g.comp f).SurjectiveOnStalks","decl":"lemma SurjectiveOnStalks.comp (hg : SurjectiveOnStalks g) (hf : SurjectiveOnStalks f) :\n    SurjectiveOnStalks (g.comp f) := by\n  intros I hI\n  have := (hg I hI).comp (hf _ (hI.comap g))\n  rwa [← RingHom.coe_comp, ← Localization.localRingHom_comp] at this\n\n"}
{"name":"RingHom.SurjectiveOnStalks.of_comp","module":"Mathlib.RingTheory.SurjectiveOnStalks","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Type u_2\ninst✝¹ : CommRing S\nT : Type u_3\ninst✝ : CommRing T\ng : RingHom S T\nf : RingHom R S\nhg : (g.comp f).SurjectiveOnStalks\n⊢ g.SurjectiveOnStalks","decl":"lemma SurjectiveOnStalks.of_comp (hg : SurjectiveOnStalks (g.comp f)) :\n    SurjectiveOnStalks g := by\n  intros I hI\n  have := hg I hI\n  rw [Localization.localRingHom_comp (I.comap (g.comp f)) (I.comap g) _ _ rfl _ rfl,\n    RingHom.coe_comp] at this\n  exact this.of_comp\n\n\n"}
{"name":"RingHom.SurjectiveOnStalks.exists_mul_eq_tmul","module":"Mathlib.RingTheory.SurjectiveOnStalks","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Type u_2\ninst✝³ : CommRing S\nT : Type u_3\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\ninst✝ : Algebra R S\nhf₂ : (algebraMap R T).SurjectiveOnStalks\nx : TensorProduct R S T\nJ : Ideal T\nhJ : J.IsPrime\n⊢ Exists fun t => Exists fun r => Exists fun a => And (Not (Membership.mem J (HSMul.hSMul r t))) (Eq (HMul.hMul (TensorProduct.tmul R 1 (HSMul.hSMul r t)) x) (TensorProduct.tmul R a t))","decl":"variable [Algebra R T] [Algebra R S] in\n/--\nIf `R → T` is surjective on stalks, and `J` is some prime of `T`,\nthen every element `x` in `S ⊗[R] T` satisfies `(1 ⊗ r • t) * x = a ⊗ t` for some\n`r : R`, `a : S`, and `t : T` such that `r • t ∉ J`.\n-/\nlemma SurjectiveOnStalks.exists_mul_eq_tmul\n    (hf₂ : (algebraMap R T).SurjectiveOnStalks)\n    (x : S ⊗[R] T) (J : Ideal T) (hJ : J.IsPrime) :\n    ∃ (t : T) (r : R) (a : S), (r • t ∉ J) ∧\n      (1 : S) ⊗ₜ[R] (r • t) * x = a ⊗ₜ[R] t := by\n  induction x with\n  | zero =>\n    exact ⟨1, 1, 0, by rw [one_smul]; exact J.primeCompl.one_mem,\n      by rw [mul_zero, TensorProduct.zero_tmul]⟩\n  | tmul x₁ x₂ =>\n    obtain ⟨y, s, c, hs, hc, e⟩ := (surjective_localRingHom_iff _).mp (hf₂ J hJ) x₂\n    simp_rw [Algebra.smul_def]\n    refine ⟨c, s, y • x₁, J.primeCompl.mul_mem hc hs, ?_⟩\n    rw [Algebra.TensorProduct.tmul_mul_tmul, one_mul, mul_comm _ c, e,\n      TensorProduct.smul_tmul, Algebra.smul_def, mul_comm]\n  | add x₁ x₂ hx₁ hx₂ =>\n    obtain ⟨t₁, r₁, a₁, hr₁, e₁⟩ := hx₁\n    obtain ⟨t₂, r₂, a₂, hr₂, e₂⟩ := hx₂\n    have : (r₁ * r₂) • (t₁ * t₂) = (r₁ • t₁) * (r₂ • t₂) := by\n      simp_rw [← smul_eq_mul]; rw [smul_smul_smul_comm]\n    refine ⟨t₁ * t₂, r₁ * r₂, r₂ • a₁ + r₁ • a₂, this.symm ▸ J.primeCompl.mul_mem hr₁ hr₂, ?_⟩\n    rw [this, ← one_mul (1 : S), ← Algebra.TensorProduct.tmul_mul_tmul, mul_add, mul_comm (_ ⊗ₜ _),\n      mul_assoc, e₁, Algebra.TensorProduct.tmul_mul_tmul, one_mul, smul_mul_assoc,\n      ← TensorProduct.smul_tmul, mul_comm (_ ⊗ₜ _), mul_assoc, e₂,\n      Algebra.TensorProduct.tmul_mul_tmul, one_mul, smul_mul_assoc, ← TensorProduct.smul_tmul,\n      TensorProduct.add_tmul, mul_comm t₁ t₂]\n\n"}
{"name":"RingHom.surjectiveOnStalks_of_isLocalization","module":"Mathlib.RingTheory.SurjectiveOnStalks","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\n⊢ (algebraMap R S).SurjectiveOnStalks","decl":"variable (S) in\nlemma surjectiveOnStalks_of_isLocalization\n    [Algebra R S] [IsLocalization M S] :\n    SurjectiveOnStalks (algebraMap R S) := by\n  refine surjectiveOnStalks_of_exists_div fun s ↦ ?_\n  obtain ⟨x, s, rfl⟩ := IsLocalization.mk'_surjective M s\n  exact ⟨x, s, IsLocalization.map_units S s, IsLocalization.mk'_spec' S x s⟩\n\n"}
{"name":"RingHom.SurjectiveOnStalks.baseChange","module":"Mathlib.RingTheory.SurjectiveOnStalks","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Type u_2\ninst✝³ : CommRing S\nT : Type u_3\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\ninst✝ : Algebra R S\nhf : (algebraMap R T).SurjectiveOnStalks\n⊢ (algebraMap S (TensorProduct R S T)).SurjectiveOnStalks","decl":"lemma SurjectiveOnStalks.baseChange\n    [Algebra R T] [Algebra R S]\n    (hf : (algebraMap R T).SurjectiveOnStalks) :\n    (algebraMap S (S ⊗[R] T)).SurjectiveOnStalks := by\n  let g : T →+* S ⊗[R] T := Algebra.TensorProduct.includeRight.toRingHom\n  intros J hJ\n  rw [surjective_localRingHom_iff]\n  intro x\n  obtain ⟨t, r, a, ht, e⟩ := hf.exists_mul_eq_tmul x (J.comap g) inferInstance\n  refine ⟨a, algebraMap _ _ r, 1 ⊗ₜ (r • t), ht, ?_, ?_⟩\n  · intro H\n    simp only [Algebra.algebraMap_eq_smul_one (A := S), Algebra.TensorProduct.algebraMap_apply,\n      Algebra.id.map_eq_id, id_apply, smul_tmul, ← Algebra.algebraMap_eq_smul_one (A := T)] at H\n    rw [Ideal.mem_comap, Algebra.smul_def, g.map_mul] at ht\n    exact ht (J.mul_mem_right _ H)\n  · simp only [tmul_smul, Algebra.TensorProduct.algebraMap_apply, Algebra.id.map_eq_id,\n      RingHomCompTriple.comp_apply, Algebra.smul_mul_assoc, Algebra.TensorProduct.tmul_mul_tmul,\n      one_mul, mul_one, id_apply, ← e]\n    rw [Algebra.algebraMap_eq_smul_one, ← smul_tmul', smul_mul_assoc]\n\n"}
{"name":"RingHom.surjectiveOnStalks_iff_of_isLocalHom","module":"Mathlib.RingTheory.SurjectiveOnStalks","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Type u_2\ninst✝² : CommRing S\nf : RingHom R S\ninst✝¹ : IsLocalRing S\ninst✝ : IsLocalHom f\n⊢ Iff f.SurjectiveOnStalks (Function.Surjective ⇑f)","decl":"lemma surjectiveOnStalks_iff_of_isLocalHom [IsLocalRing S] [IsLocalHom f] :\n    f.SurjectiveOnStalks ↔ Function.Surjective f := by\n  refine ⟨fun H x ↦ ?_, fun h ↦ surjectiveOnStalks_of_surjective h⟩\n  obtain ⟨y, r, c, hc, hr, e⟩ :=\n    (surjective_localRingHom_iff _).mp (H (IsLocalRing.maximalIdeal _) inferInstance) x\n  simp only [IsLocalRing.mem_maximalIdeal, mem_nonunits_iff, not_not] at hc hr\n  refine ⟨(isUnit_of_map_unit f r hr).unit⁻¹ * y, ?_⟩\n  apply hr.mul_right_injective\n  apply hc.mul_right_injective\n  simp only [← _root_.map_mul, ← mul_assoc, IsUnit.mul_val_inv, one_mul, e]\n\n"}
{"name":"RingHom.surjectiveOnStalks_iff_of_isLocalRingHom","module":"Mathlib.RingTheory.SurjectiveOnStalks","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nS : Type u_2\ninst✝² : CommRing S\nf : RingHom R S\ninst✝¹ : IsLocalRing S\ninst✝ : IsLocalHom f\n⊢ Iff f.SurjectiveOnStalks (Function.Surjective ⇑f)","decl":"@[deprecated (since := \"2024-10-10\")]\nalias surjectiveOnStalks_iff_of_isLocalRingHom := surjectiveOnStalks_iff_of_isLocalHom\n\n"}
