{"name":"ChainComplex.linearYonedaObj_d","module":"Mathlib.CategoryTheory.Abelian.Ext","initialProofState":"C : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} C\ninst✝⁴ : CategoryTheory.Abelian C\nα : Type u_3\ninst✝³ : AddRightCancelSemigroup α\ninst✝² : One α\nX : ChainComplex C α\nA : Type u_4\ninst✝¹ : Ring A\ninst✝ : CategoryTheory.Linear A C\nY : C\ni j : α\n⊢ Eq ((X.linearYonedaObj A Y).d i j) (ModuleCat.ofHom (CategoryTheory.Linear.leftComp A Y (X.d j i)))","decl":"/-- Given a chain complex `X` and an object `Y`, this is the cochain complex\nwhich in degree `i` consists of the module of morphisms `X.X i ⟶ Y`. -/\n@[simps! X d]\ndef ChainComplex.linearYonedaObj {α : Type*} [AddRightCancelSemigroup α] [One α]\n    (X : ChainComplex C α) (A : Type*) [Ring A] [Linear A C] (Y : C) :\n    CochainComplex (ModuleCat A) α :=\n  ((((linearYoneda A C).obj Y).rightOp.mapHomologicalComplex _).obj X).unop\n\n"}
{"name":"ChainComplex.linearYonedaObj_X","module":"Mathlib.CategoryTheory.Abelian.Ext","initialProofState":"C : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} C\ninst✝⁴ : CategoryTheory.Abelian C\nα : Type u_3\ninst✝³ : AddRightCancelSemigroup α\ninst✝² : One α\nX : ChainComplex C α\nA : Type u_4\ninst✝¹ : Ring A\ninst✝ : CategoryTheory.Linear A C\nY : C\ni : α\n⊢ Eq ((X.linearYonedaObj A Y).X i) (((CategoryTheory.linearYoneda A C).obj Y).obj { unop := X.X i })","decl":"/-- Given a chain complex `X` and an object `Y`, this is the cochain complex\nwhich in degree `i` consists of the module of morphisms `X.X i ⟶ Y`. -/\n@[simps! X d]\ndef ChainComplex.linearYonedaObj {α : Type*} [AddRightCancelSemigroup α] [One α]\n    (X : ChainComplex C α) (A : Type*) [Ring A] [Linear A C] (Y : C) :\n    CochainComplex (ModuleCat A) α :=\n  ((((linearYoneda A C).obj Y).rightOp.mapHomologicalComplex _).obj X).unop\n\n"}
{"name":"isZero_Ext_succ_of_projective","module":"Mathlib.CategoryTheory.Abelian.Ext","initialProofState":"R : Type u_1\ninst✝⁵ : Ring R\nC : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} C\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.Linear R C\ninst✝¹ : CategoryTheory.EnoughProjectives C\nX Y : C\ninst✝ : CategoryTheory.Projective X\nn : Nat\n⊢ CategoryTheory.Limits.IsZero (((Ext R C (HAdd.hAdd n 1)).obj { unop := X }).obj Y)","decl":"/-- If `X : C` is projective and `n : ℕ`, then `Ext^(n + 1) X Y ≅ 0` for any `Y`. -/\nlemma isZero_Ext_succ_of_projective (X Y : C) [Projective X] (n : ℕ) :\n    IsZero (((Ext R C (n + 1)).obj (Opposite.op X)).obj Y) := by\n  refine IsZero.of_iso ?_ ((ProjectiveResolution.self X).isoExt (n + 1) Y)\n  rw [← HomologicalComplex.exactAt_iff_isZero_homology, HomologicalComplex.exactAt_iff]\n  refine ShortComplex.exact_of_isZero_X₂ _ ?_\n  dsimp\n  rw [IsZero.iff_id_eq_zero]\n  ext (x : _ ⟶ _)\n  obtain rfl : x = 0 := (HomologicalComplex.isZero_single_obj_X\n    (ComplexShape.down ℕ) 0 X (n + 1) (by simp)).eq_of_src _ _\n  rfl\n"}
