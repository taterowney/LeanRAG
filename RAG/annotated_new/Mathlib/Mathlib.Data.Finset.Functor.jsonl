{"name":"Finset.lawfulFunctor","module":"Mathlib.Data.Finset.Functor","initialProofState":"inst✝ : (P : Prop) → Decidable P\n⊢ LawfulFunctor Finset","decl":"instance lawfulFunctor : LawfulFunctor Finset where\n  id_map _ := image_id\n  comp_map _ _ _ := image_image.symm\n  map_const {α} {β} := by simp only [Functor.mapConst, Functor.map]\n\n"}
{"name":"Finset.fmap_def","module":"Mathlib.Data.Finset.Functor","initialProofState":"α β : Type u\ninst✝ : (P : Prop) → Decidable P\ns : Finset α\nf : α → β\n⊢ Eq (Functor.map f s) (Finset.image f s)","decl":"@[simp]\ntheorem fmap_def {s : Finset α} (f : α → β) : f <$> s = s.image f := rfl\n\n"}
{"name":"Finset.pure_def","module":"Mathlib.Data.Finset.Functor","initialProofState":"α : Type u_1\n⊢ Eq Pure.pure Singleton.singleton","decl":"@[simp]\ntheorem pure_def {α} : (pure : α → Finset α) = singleton := rfl\n\n"}
{"name":"Finset.seq_def","module":"Mathlib.Data.Finset.Functor","initialProofState":"α β : Type u\ninst✝ : (P : Prop) → Decidable P\ns : Finset α\nt : Finset (α → β)\n⊢ Eq (Seq.seq t fun x => s) (t.sup fun f => Finset.image f s)","decl":"@[simp]\ntheorem seq_def (s : Finset α) (t : Finset (α → β)) : t <*> s = t.sup fun f => s.image f :=\n  rfl\n\n"}
{"name":"Finset.seqLeft_def","module":"Mathlib.Data.Finset.Functor","initialProofState":"α β : Type u\ninst✝ : (P : Prop) → Decidable P\ns : Finset α\nt : Finset β\n⊢ Eq (SeqLeft.seqLeft s fun x => t) (ite (Eq t EmptyCollection.emptyCollection) EmptyCollection.emptyCollection s)","decl":"@[simp]\ntheorem seqLeft_def (s : Finset α) (t : Finset β) : s <* t = if t = ∅ then ∅ else s :=\n  rfl\n\n"}
{"name":"Finset.seqRight_def","module":"Mathlib.Data.Finset.Functor","initialProofState":"α β : Type u\ninst✝ : (P : Prop) → Decidable P\ns : Finset α\nt : Finset β\n⊢ Eq (SeqRight.seqRight s fun x => t) (ite (Eq s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection t)","decl":"@[simp]\ntheorem seqRight_def (s : Finset α) (t : Finset β) : s *> t = if s = ∅ then ∅ else t :=\n  rfl\n\n"}
{"name":"Finset.image₂_def","module":"Mathlib.Data.Finset.Functor","initialProofState":"inst✝ : (P : Prop) → Decidable P\nα β γ : Type u\nf : α → β → γ\ns : Finset α\nt : Finset β\n⊢ Eq (Finset.image₂ f s t) (Seq.seq (Functor.map f s) fun x => t)","decl":"/-- `Finset.image₂` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. -/\ntheorem image₂_def {α β γ : Type u} (f : α → β → γ) (s : Finset α) (t : Finset β) :\n    image₂ f s t = f <$> s <*> t := by\n  ext\n  simp [mem_sup]\n\n"}
{"name":"Finset.lawfulApplicative","module":"Mathlib.Data.Finset.Functor","initialProofState":"inst✝ : (P : Prop) → Decidable P\n⊢ LawfulApplicative Finset","decl":"instance lawfulApplicative : LawfulApplicative Finset :=\n  { Finset.lawfulFunctor with\n    seqLeft_eq := fun s t => by\n      rw [seq_def, fmap_def, seqLeft_def]\n      obtain rfl | ht := t.eq_empty_or_nonempty\n      · simp_rw [image_empty, if_true]\n        exact (sup_bot _).symm\n      · ext a\n        rw [if_neg ht.ne_empty, mem_sup]\n        refine ⟨fun ha => ⟨const _ a, mem_image_of_mem _ ha, mem_image_const_self.2 ht⟩, ?_⟩\n        rintro ⟨f, hf, ha⟩\n        rw [mem_image] at hf ha\n        obtain ⟨b, hb, rfl⟩ := hf\n        obtain ⟨_, _, rfl⟩ := ha\n        exact hb\n    seqRight_eq := fun s t => by\n      rw [seq_def, fmap_def, seqRight_def]\n      obtain rfl | hs := s.eq_empty_or_nonempty\n      · rw [if_pos rfl, image_empty, sup_empty, bot_eq_empty]\n      · ext a\n        rw [if_neg hs.ne_empty, mem_sup]\n        refine ⟨fun ha => ⟨id, mem_image_const_self.2 hs, by rwa [image_id]⟩, ?_⟩\n        rintro ⟨f, hf, ha⟩\n        rw [mem_image] at hf ha\n        obtain ⟨b, hb, rfl⟩ := ha\n        obtain ⟨_, _, rfl⟩ := hf\n        exact hb\n    pure_seq := fun f s => by simp only [pure_def, seq_def, sup_singleton, fmap_def]\n    map_pure := fun _ _ => image_singleton _ _\n    seq_pure := fun _ _ => sup_singleton'' _ _\n    seq_assoc := fun s t u => by\n      ext a\n      simp_rw [seq_def, fmap_def]\n      simp only [exists_prop, mem_sup, mem_image]\n      constructor\n      · rintro ⟨g, hg, b, ⟨f, hf, a, ha, rfl⟩, rfl⟩\n        exact ⟨g ∘ f, ⟨comp g, ⟨g, hg, rfl⟩, f, hf, rfl⟩, a, ha, rfl⟩\n      · rintro ⟨c, ⟨_, ⟨g, hg, rfl⟩, f, hf, rfl⟩, a, ha, rfl⟩\n        exact ⟨g, hg, f a, ⟨f, hf, a, ha, rfl⟩, rfl⟩ }\n\n"}
{"name":"Finset.commApplicative","module":"Mathlib.Data.Finset.Functor","initialProofState":"inst✝ : (P : Prop) → Decidable P\n⊢ CommApplicative Finset","decl":"instance commApplicative : CommApplicative Finset :=\n  { Finset.lawfulApplicative with\n    commutative_prod := fun s t => by\n      simp_rw [seq_def, fmap_def, sup_image, sup_eq_biUnion]\n      change (s.biUnion fun a => t.image fun b => (a, b))\n        = t.biUnion fun b => s.image fun a => (a, b)\n      trans s ×ˢ t <;> [rw [product_eq_biUnion]; rw [product_eq_biUnion_right]] }\n\n"}
{"name":"Finset.bind_def","module":"Mathlib.Data.Finset.Functor","initialProofState":"inst✝ : (P : Prop) → Decidable P\nα β : Type u_1\n⊢ Eq (fun x1 x2 => Bind.bind x1 x2) Finset.sup","decl":"@[simp]\ntheorem bind_def {α β} : (· >>= ·) = sup (α := Finset α) (β := β) :=\n  rfl\n\n"}
{"name":"Finset.instLawfulMonad","module":"Mathlib.Data.Finset.Functor","initialProofState":"inst✝ : (P : Prop) → Decidable P\n⊢ LawfulMonad Finset","decl":"instance : LawfulMonad Finset :=\n  { Finset.lawfulApplicative with\n    bind_pure_comp := fun _ _ => sup_singleton'' _ _\n    bind_map := fun _ _ => rfl\n    pure_bind := fun _ _ => sup_singleton\n    bind_assoc := fun s f g => by simp only [bind, ← sup_biUnion, sup_eq_biUnion, biUnion_biUnion] }\n\n"}
{"name":"Finset.id_traverse","module":"Mathlib.Data.Finset.Functor","initialProofState":"α : Type u\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.traverse Pure.pure s) s","decl":"@[simp]\ntheorem id_traverse [DecidableEq α] (s : Finset α) : traverse (pure : α → Id α) s = s := by\n  rw [traverse, Multiset.id_traverse]\n  exact s.val_toFinset\n\n"}
{"name":"Finset.map_comp_coe","module":"Mathlib.Data.Finset.Functor","initialProofState":"α β : Type u\nh : α → β\n⊢ Eq (Function.comp (Functor.map h) Multiset.toFinset) (Function.comp Multiset.toFinset (Functor.map h))","decl":"open scoped Classical in\n@[simp]\ntheorem map_comp_coe (h : α → β) :\n    Functor.map h ∘ Multiset.toFinset = Multiset.toFinset ∘ Functor.map h :=\n  funext fun _ => image_toFinset\n\n"}
{"name":"Finset.map_comp_coe_apply","module":"Mathlib.Data.Finset.Functor","initialProofState":"α β : Type u\nh : α → β\ns : Multiset α\n⊢ Eq (Finset.image h s.toFinset) (Functor.map h s).toFinset","decl":"open scoped Classical in\n@[simp]\ntheorem map_comp_coe_apply (h : α → β) (s : Multiset α) :\n    s.toFinset.image h = (h <$> s).toFinset :=\n  congrFun (map_comp_coe h) s\n\n"}
{"name":"Finset.map_traverse","module":"Mathlib.Data.Finset.Functor","initialProofState":"α β γ : Type u\nG : Type u → Type u\ninst✝¹ : Applicative G\ninst✝ : CommApplicative G\ng : α → G β\nh : β → γ\ns : Finset α\n⊢ Eq (Functor.map (Functor.map h) (Finset.traverse g s)) (Finset.traverse (Function.comp (Functor.map h) g) s)","decl":"open scoped Classical in\ntheorem map_traverse (g : α → G β) (h : β → γ) (s : Finset α) :\n    Functor.map h <$> traverse g s = traverse (Functor.map h ∘ g) s := by\n  unfold traverse\n  simp only [Functor.map_map, fmap_def, map_comp_coe_apply, Multiset.fmap_def, ←\n    Multiset.map_traverse]\n\n"}
