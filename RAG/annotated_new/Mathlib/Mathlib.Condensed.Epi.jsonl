{"name":"Condensed.epi_iff_locallySurjective_on_compHaus","module":"Mathlib.Condensed.Epi","initialProofState":"A : Type u'\ninst✝⁷ : CategoryTheory.Category.{v', u'} A\ninst✝⁶ : CategoryTheory.HasForget A\ninst✝⁵ : CategoryTheory.ConcreteCategory.HasFunctorialSurjectiveInjectiveFactorization A\nX Y : Condensed A\nf : Quiver.Hom X Y\ninst✝⁴ : (CategoryTheory.coherentTopology CompHaus).WEqualsLocallyBijective A\ninst✝³ : CategoryTheory.HasSheafify (CategoryTheory.coherentTopology CompHaus) A\ninst✝² : (CategoryTheory.coherentTopology CompHaus).HasSheafCompose (CategoryTheory.forget A)\ninst✝¹ : CategoryTheory.Balanced (CategoryTheory.Sheaf (CategoryTheory.coherentTopology CompHaus) A)\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts (CategoryTheory.forget A)\n⊢ Iff (CategoryTheory.Epi f) (∀ (S : CompHaus) (y : (CategoryTheory.forget A).obj (Y.val.obj { unop := S })), Exists fun S' => Exists fun φ => Exists fun x => Exists fun x => Eq ((f.val.app { unop := S' }) x) ((Y.val.map { unop := φ }) y))","decl":"variable\n  [(coherentTopology CompHaus).WEqualsLocallyBijective A]\n  [HasSheafify (coherentTopology CompHaus) A]\n  [(coherentTopology CompHaus.{u}).HasSheafCompose (CategoryTheory.forget A)]\n  [Balanced (Sheaf (coherentTopology CompHaus) A)]\n  [PreservesFiniteProducts (CategoryTheory.forget A)] in\nlemma epi_iff_locallySurjective_on_compHaus : Epi f ↔\n    ∀ (S : CompHaus) (y : Y.val.obj ⟨S⟩),\n      (∃ (S' : CompHaus) (φ : S' ⟶ S) (_ : Function.Surjective φ) (x : X.val.obj ⟨S'⟩),\n        f.val.app ⟨S'⟩ x = Y.val.map ⟨φ⟩ y) := by\n  rw [← isLocallySurjective_iff_epi', coherentTopology.isLocallySurjective_iff,\n    regularTopology.isLocallySurjective_iff]\n  simp_rw [((CompHaus.effectiveEpi_tfae _).out 0 2 :)]\n\n"}
{"name":"Condensed.epi_iff_surjective_on_stonean","module":"Mathlib.Condensed.Epi","initialProofState":"A : Type u'\ninst✝⁸ : CategoryTheory.Category.{v', u'} A\ninst✝⁷ : CategoryTheory.HasForget A\ninst✝⁶ : CategoryTheory.ConcreteCategory.HasFunctorialSurjectiveInjectiveFactorization A\nX Y : Condensed A\nf : Quiver.Hom X Y\ninst✝⁵ : CategoryTheory.Limits.PreservesFiniteProducts (CategoryTheory.forget A)\ninst✝⁴ : ∀ (X : Opposite CompHaus), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.StructuredArrow X Stonean.toCompHaus.op) A\ninst✝³ : (CategoryTheory.extensiveTopology Stonean).WEqualsLocallyBijective A\ninst✝² : CategoryTheory.HasSheafify (CategoryTheory.extensiveTopology Stonean) A\ninst✝¹ : (CategoryTheory.extensiveTopology Stonean).HasSheafCompose (CategoryTheory.forget A)\ninst✝ : CategoryTheory.Balanced (CategoryTheory.Sheaf (CategoryTheory.extensiveTopology Stonean) A)\n⊢ Iff (CategoryTheory.Epi f) (∀ (S : Stonean), Function.Surjective ⇑(f.val.app { unop := S.compHaus }))","decl":"variable\n  [PreservesFiniteProducts (CategoryTheory.forget A)]\n  [∀ (X : CompHausᵒᵖ), HasLimitsOfShape (StructuredArrow X Stonean.toCompHaus.op) A]\n  [(extensiveTopology Stonean).WEqualsLocallyBijective A]\n  [HasSheafify (extensiveTopology Stonean) A]\n  [(extensiveTopology Stonean.{u}).HasSheafCompose (CategoryTheory.forget A)]\n  [Balanced (Sheaf (extensiveTopology Stonean) A)] in\nlemma epi_iff_surjective_on_stonean : Epi f ↔\n    ∀ (S : Stonean), Function.Surjective (f.val.app (op S.compHaus)) := by\n  rw [← (StoneanCompHaus.equivalence A).inverse.epi_map_iff_epi,\n    ← Presheaf.coherentExtensiveEquivalence.functor.epi_map_iff_epi,\n    ← isLocallySurjective_iff_epi']\n  exact extensiveTopology.isLocallySurjective_iff (D := A) _\n\n"}
{"name":"CondensedSet.epi_iff_locallySurjective_on_compHaus","module":"Mathlib.Condensed.Epi","initialProofState":"X Y : CondensedSet\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Epi f) (∀ (S : CompHaus) (y : Y.val.obj { unop := S }), Exists fun S' => Exists fun φ => Exists fun x => Exists fun x => Eq (f.val.app { unop := S' } x) (Y.val.map { unop := φ } y))","decl":"lemma epi_iff_locallySurjective_on_compHaus : Epi f ↔\n    ∀ (S : CompHaus) (y : Y.val.obj ⟨S⟩),\n      (∃ (S' : CompHaus) (φ : S' ⟶ S) (_ : Function.Surjective φ) (x : X.val.obj ⟨S'⟩),\n        f.val.app ⟨S'⟩ x = Y.val.map ⟨φ⟩ y) :=\n  Condensed.epi_iff_locallySurjective_on_compHaus _ f\n\n"}
{"name":"CondensedSet.epi_iff_surjective_on_stonean","module":"Mathlib.Condensed.Epi","initialProofState":"X Y : CondensedSet\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Epi f) (∀ (S : Stonean), Function.Surjective (f.val.app { unop := S.compHaus }))","decl":"lemma epi_iff_surjective_on_stonean : Epi f ↔\n    ∀ (S : Stonean), Function.Surjective (f.val.app (op S.compHaus)) :=\n  Condensed.epi_iff_surjective_on_stonean _ f\n\n"}
{"name":"CondensedMod.epi_iff_locallySurjective_on_compHaus","module":"Mathlib.Condensed.Epi","initialProofState":"R : Type (u + 1)\ninst✝ : Ring R\nX Y : CondensedMod R\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Epi f) (∀ (S : CompHaus) (y : ↑(Y.val.obj { unop := S })), Exists fun S' => Exists fun φ => Exists fun x => Exists fun x => Eq ((CategoryTheory.ConcreteCategory.hom (f.val.app { unop := S' })) x) ((CategoryTheory.ConcreteCategory.hom (Y.val.map { unop := φ })) y))","decl":"lemma epi_iff_locallySurjective_on_compHaus : Epi f ↔\n    ∀ (S : CompHaus) (y : Y.val.obj ⟨S⟩),\n      (∃ (S' : CompHaus) (φ : S' ⟶ S) (_ : Function.Surjective φ) (x : X.val.obj ⟨S'⟩),\n        f.val.app ⟨S'⟩ x = Y.val.map ⟨φ⟩ y) :=\n  Condensed.epi_iff_locallySurjective_on_compHaus _ f\n\n"}
{"name":"CondensedMod.epi_iff_surjective_on_stonean","module":"Mathlib.Condensed.Epi","initialProofState":"R : Type (u + 1)\ninst✝ : Ring R\nX Y : CondensedMod R\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Epi f) (∀ (S : Stonean), Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom (f.val.app { unop := S.compHaus })))","decl":"lemma epi_iff_surjective_on_stonean : Epi f ↔\n    ∀ (S : Stonean), Function.Surjective (f.val.app (op S.compHaus)) :=\n  have : HasLimitsOfSize.{u, u+1} (ModuleCat R) := hasLimitsOfSizeShrink.{u, u+1, u+1, u+1} _\n  Condensed.epi_iff_surjective_on_stonean _ f\n\n"}
