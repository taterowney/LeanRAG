{"name":"Multiset.zero_disjSum","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Multiset β\n⊢ Eq (Multiset.disjSum 0 t) (Multiset.map Sum.inr t)","decl":"@[simp]\ntheorem zero_disjSum : (0 : Multiset α).disjSum t = t.map inr :=\n  Multiset.zero_add _\n\n"}
{"name":"Multiset.disjSum_zero","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Multiset α\n⊢ Eq (s.disjSum 0) (Multiset.map Sum.inl s)","decl":"@[simp]\ntheorem disjSum_zero : s.disjSum (0 : Multiset β) = s.map inl :=\n  Multiset.add_zero _\n\n"}
{"name":"Multiset.card_disjSum","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Multiset α\nt : Multiset β\n⊢ Eq (s.disjSum t).card (HAdd.hAdd s.card t.card)","decl":"@[simp]\ntheorem card_disjSum : Multiset.card (s.disjSum t) = Multiset.card s + Multiset.card t := by\n  rw [disjSum, card_add, card_map, card_map]\n\n"}
{"name":"Multiset.mem_disjSum","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Multiset α\nt : Multiset β\nx : Sum α β\n⊢ Iff (Membership.mem (s.disjSum t) x) (Or (Exists fun a => And (Membership.mem s a) (Eq (Sum.inl a) x)) (Exists fun b => And (Membership.mem t b) (Eq (Sum.inr b) x)))","decl":"theorem mem_disjSum : x ∈ s.disjSum t ↔ (∃ a, a ∈ s ∧ inl a = x) ∨ ∃ b, b ∈ t ∧ inr b = x := by\n  simp_rw [disjSum, mem_add, mem_map]\n\n"}
{"name":"Multiset.inl_mem_disjSum","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Multiset α\nt : Multiset β\na : α\n⊢ Iff (Membership.mem (s.disjSum t) (Sum.inl a)) (Membership.mem s a)","decl":"@[simp]\ntheorem inl_mem_disjSum : inl a ∈ s.disjSum t ↔ a ∈ s := by\n  rw [mem_disjSum, or_iff_left]\n  -- Porting note: Previous code for L62 was: simp only [exists_eq_right]\n  · simp only [inl.injEq, exists_eq_right]\n  rintro ⟨b, _, hb⟩\n  exact inr_ne_inl hb\n\n"}
{"name":"Multiset.inr_mem_disjSum","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Multiset α\nt : Multiset β\nb : β\n⊢ Iff (Membership.mem (s.disjSum t) (Sum.inr b)) (Membership.mem t b)","decl":"@[simp]\ntheorem inr_mem_disjSum : inr b ∈ s.disjSum t ↔ b ∈ t := by\n  rw [mem_disjSum, or_iff_right]\n  -- Porting note: Previous code for L72 was: simp only [exists_eq_right]\n  · simp only [inr.injEq, exists_eq_right]\n  rintro ⟨a, _, ha⟩\n  exact inl_ne_inr ha\n\n"}
{"name":"Multiset.disjSum_mono","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Multiset α\nt₁ t₂ : Multiset β\nhs : LE.le s₁ s₂\nht : LE.le t₁ t₂\n⊢ LE.le (s₁.disjSum t₁) (s₂.disjSum t₂)","decl":"theorem disjSum_mono (hs : s₁ ≤ s₂) (ht : t₁ ≤ t₂) : s₁.disjSum t₁ ≤ s₂.disjSum t₂ :=\n  add_le_add (map_le_map hs) (map_le_map ht)\n\n"}
{"name":"Multiset.disjSum_mono_left","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Multiset β\n⊢ Monotone fun s => s.disjSum t","decl":"theorem disjSum_mono_left (t : Multiset β) : Monotone fun s : Multiset α => s.disjSum t :=\n  fun _ _ hs => Multiset.add_le_add_right (map_le_map hs)\n\n"}
{"name":"Multiset.disjSum_mono_right","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Multiset α\n⊢ Monotone s.disjSum","decl":"theorem disjSum_mono_right (s : Multiset α) :\n    Monotone (s.disjSum : Multiset β → Multiset (α ⊕ β)) := fun _ _ ht =>\n  Multiset.add_le_add_left (map_le_map ht)\n\n"}
{"name":"Multiset.disjSum_lt_disjSum_of_lt_of_le","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Multiset α\nt₁ t₂ : Multiset β\nhs : LT.lt s₁ s₂\nht : LE.le t₁ t₂\n⊢ LT.lt (s₁.disjSum t₁) (s₂.disjSum t₂)","decl":"theorem disjSum_lt_disjSum_of_lt_of_le (hs : s₁ < s₂) (ht : t₁ ≤ t₂) :\n    s₁.disjSum t₁ < s₂.disjSum t₂ :=\n  add_lt_add_of_lt_of_le (map_lt_map hs) (map_le_map ht)\n\n"}
{"name":"Multiset.disjSum_lt_disjSum_of_le_of_lt","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Multiset α\nt₁ t₂ : Multiset β\nhs : LE.le s₁ s₂\nht : LT.lt t₁ t₂\n⊢ LT.lt (s₁.disjSum t₁) (s₂.disjSum t₂)","decl":"theorem disjSum_lt_disjSum_of_le_of_lt (hs : s₁ ≤ s₂) (ht : t₁ < t₂) :\n    s₁.disjSum t₁ < s₂.disjSum t₂ :=\n  add_lt_add_of_le_of_lt (map_le_map hs) (map_lt_map ht)\n\n"}
{"name":"Multiset.disjSum_strictMono_left","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Multiset β\n⊢ StrictMono fun s => s.disjSum t","decl":"theorem disjSum_strictMono_left (t : Multiset β) : StrictMono fun s : Multiset α => s.disjSum t :=\n  fun _ _ hs => disjSum_lt_disjSum_of_lt_of_le hs le_rfl\n\n"}
{"name":"Multiset.disjSum_strictMono_right","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Multiset α\n⊢ StrictMono s.disjSum","decl":"theorem disjSum_strictMono_right (s : Multiset α) :\n    StrictMono (s.disjSum : Multiset β → Multiset (α ⊕ β)) := fun _ _ =>\n  disjSum_lt_disjSum_of_le_of_lt le_rfl\n\n"}
{"name":"Multiset.Nodup.disjSum","module":"Mathlib.Data.Multiset.Sum","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Multiset α\nt : Multiset β\nhs : s.Nodup\nht : t.Nodup\n⊢ (s.disjSum t).Nodup","decl":"protected theorem Nodup.disjSum (hs : s.Nodup) (ht : t.Nodup) : (s.disjSum t).Nodup := by\n  refine ((hs.map inl_injective).add_iff <| ht.map inr_injective).2 ?_\n  rw [disjoint_map_map]\n  exact fun _ _ _ _ ↦ inr_ne_inl.symm\n\n"}
