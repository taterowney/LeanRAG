{"name":"PresheafOfModules.Derivation.ext","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nx y : M.Derivation œÜ\nd : Eq (@PresheafOfModules.Derivation.d C inst‚úù¬π D inst‚úù S F R M œÜ x) (@PresheafOfModules.Derivation.d C inst‚úù¬π D inst‚úù S F R M œÜ y)\n‚ä¢ Eq x y","decl":"/-- Given a morphism of presheaves of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`,\nthis is the type of relative `œÜ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X ‚Üí+ M.obj X` of a derivation -/\n  d {X : D·µí·µñ} : R.obj X ‚Üí+ M.obj X\n  d_mul {X : D·µí·µñ} (a b : R.obj X) : d (a * b) = a ‚Ä¢ d b + b ‚Ä¢ d a := by aesop_cat\n  d_map {X Y : D·µí·µñ} (f : X ‚ü∂ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : C·µí·µñ} (a : S.obj X) : d (œÜ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.d_mul","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nself : M.Derivation œÜ\nX : Opposite D\na b : ‚Üë(R.obj X)\n‚ä¢ Eq (self.d (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (self.d b)) (HSMul.hSMul b (self.d a)))","decl":"/-- Given a morphism of presheaves of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`,\nthis is the type of relative `œÜ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X ‚Üí+ M.obj X` of a derivation -/\n  d {X : D·µí·µñ} : R.obj X ‚Üí+ M.obj X\n  d_mul {X : D·µí·µñ} (a b : R.obj X) : d (a * b) = a ‚Ä¢ d b + b ‚Ä¢ d a := by aesop_cat\n  d_map {X Y : D·µí·µñ} (f : X ‚ü∂ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : C·µí·µñ} (a : S.obj X) : d (œÜ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nd‚úù : {X : Opposite D} ‚Üí AddMonoidHom ‚Üë(R.obj X) ‚Üë(M.obj X)\nd_mul‚úù : autoParam (‚àÄ {X : Opposite D} (a b : ‚Üë(R.obj X)), Eq (d‚úù (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (d‚úù b)) (HSMul.hSMul b (d‚úù a)))) _auto‚úù\nd_map‚úù : autoParam (‚àÄ {X Y : Opposite D} (f : Quiver.Hom X Y) (x : ‚Üë(R.obj X)), Eq (d‚úù ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) (d‚úù x))) _auto‚úù\nd_app‚úù : autoParam (‚àÄ {X : Opposite C} (a : ‚Üë(S.obj X)), Eq (d‚úù ((CategoryTheory.ConcreteCategory.hom (œÜ.app X)) a)) 0) _auto‚úù\nd : {X : Opposite D} ‚Üí AddMonoidHom ‚Üë(R.obj X) ‚Üë(M.obj X)\nd_mul : autoParam (‚àÄ {X : Opposite D} (a b : ‚Üë(R.obj X)), Eq (d (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (d b)) (HSMul.hSMul b (d a)))) _auto‚úù\nd_map : autoParam (‚àÄ {X Y : Opposite D} (f : Quiver.Hom X Y) (x : ‚Üë(R.obj X)), Eq (d ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) (d x))) _auto‚úù\nd_app : autoParam (‚àÄ {X : Opposite C} (a : ‚Üë(S.obj X)), Eq (d ((CategoryTheory.ConcreteCategory.hom (œÜ.app X)) a)) 0) _auto‚úù\n‚ä¢ Eq (Eq { d := d‚úù, d_mul := d_mul‚úù, d_map := d_map‚úù, d_app := d_app‚úù } { d := d, d_mul := d_mul, d_map := d_map, d_app := d_app }) (Eq d‚úù d)","decl":"/-- Given a morphism of presheaves of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`,\nthis is the type of relative `œÜ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X ‚Üí+ M.obj X` of a derivation -/\n  d {X : D·µí·µñ} : R.obj X ‚Üí+ M.obj X\n  d_mul {X : D·µí·µñ} (a b : R.obj X) : d (a * b) = a ‚Ä¢ d b + b ‚Ä¢ d a := by aesop_cat\n  d_map {X Y : D·µí·µñ} (f : X ‚ü∂ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : C·µí·µñ} (a : S.obj X) : d (œÜ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf D\nd : {X : Opposite D} ‚Üí AddMonoidHom ‚Üë(R.obj X) ‚Üë(M.obj X)\nd_mul : autoParam (‚àÄ {X : Opposite D} (a b : ‚Üë(R.obj X)), Eq (d (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (d b)) (HSMul.hSMul b (d a)))) _auto‚úù\nd_map : autoParam (‚àÄ {X Y : Opposite D} (f : Quiver.Hom X Y) (x : ‚Üë(R.obj X)), Eq (d ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) (d x))) _auto‚úù\nd_app : autoParam (‚àÄ {X : Opposite C} (a : ‚Üë(S.obj X)), Eq (d ((CategoryTheory.ConcreteCategory.hom (œÜ.app X)) a)) 0) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { d := d, d_mul := d_mul, d_map := d_map, d_app := d_app }) 1","decl":"/-- Given a morphism of presheaves of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`,\nthis is the type of relative `œÜ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X ‚Üí+ M.obj X` of a derivation -/\n  d {X : D·µí·µñ} : R.obj X ‚Üí+ M.obj X\n  d_mul {X : D·µí·µñ} (a b : R.obj X) : d (a * b) = a ‚Ä¢ d b + b ‚Ä¢ d a := by aesop_cat\n  d_map {X Y : D·µí·µñ} (f : X ‚ü∂ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : C·µí·µñ} (a : S.obj X) : d (œÜ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nd‚úù : {X : Opposite D} ‚Üí AddMonoidHom ‚Üë(R.obj X) ‚Üë(M.obj X)\nd_mul‚úù : autoParam (‚àÄ {X : Opposite D} (a b : ‚Üë(R.obj X)), Eq (d‚úù (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (d‚úù b)) (HSMul.hSMul b (d‚úù a)))) _auto‚úù\nd_map‚úù : autoParam (‚àÄ {X Y : Opposite D} (f : Quiver.Hom X Y) (x : ‚Üë(R.obj X)), Eq (d‚úù ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) (d‚úù x))) _auto‚úù\nd_app‚úù : autoParam (‚àÄ {X : Opposite C} (a : ‚Üë(S.obj X)), Eq (d‚úù ((CategoryTheory.ConcreteCategory.hom (œÜ.app X)) a)) 0) _auto‚úù\nd : {X : Opposite D} ‚Üí AddMonoidHom ‚Üë(R.obj X) ‚Üë(M.obj X)\nd_mul : autoParam (‚àÄ {X : Opposite D} (a b : ‚Üë(R.obj X)), Eq (d (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (d b)) (HSMul.hSMul b (d a)))) _auto‚úù\nd_map : autoParam (‚àÄ {X Y : Opposite D} (f : Quiver.Hom X Y) (x : ‚Üë(R.obj X)), Eq (d ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) (d x))) _auto‚úù\nd_app : autoParam (‚àÄ {X : Opposite C} (a : ‚Üë(S.obj X)), Eq (d ((CategoryTheory.ConcreteCategory.hom (œÜ.app X)) a)) 0) _auto‚úù\nx‚úù : Eq { d := d‚úù, d_mul := d_mul‚úù, d_map := d_map‚úù, d_app := d_app‚úù } { d := d, d_mul := d_mul, d_map := d_map, d_app := d_app }\n‚ä¢ Eq d‚úù d","decl":"/-- Given a morphism of presheaves of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`,\nthis is the type of relative `œÜ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X ‚Üí+ M.obj X` of a derivation -/\n  d {X : D·µí·µñ} : R.obj X ‚Üí+ M.obj X\n  d_mul {X : D·µí·µñ} (a b : R.obj X) : d (a * b) = a ‚Ä¢ d b + b ‚Ä¢ d a := by aesop_cat\n  d_map {X Y : D·µí·µñ} (f : X ‚ü∂ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : C·µí·µñ} (a : S.obj X) : d (œÜ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.d_app","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nself : M.Derivation œÜ\nX : Opposite C\na : ‚Üë(S.obj X)\n‚ä¢ Eq (self.d ((CategoryTheory.ConcreteCategory.hom (œÜ.app X)) a)) 0","decl":"/-- Given a morphism of presheaves of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`,\nthis is the type of relative `œÜ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X ‚Üí+ M.obj X` of a derivation -/\n  d {X : D·µí·µñ} : R.obj X ‚Üí+ M.obj X\n  d_mul {X : D·µí·µñ} (a b : R.obj X) : d (a * b) = a ‚Ä¢ d b + b ‚Ä¢ d a := by aesop_cat\n  d_map {X Y : D·µí·µñ} (f : X ‚ü∂ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : C·µí·µñ} (a : S.obj X) : d (œÜ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.ext_iff","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nx y : M.Derivation œÜ\n‚ä¢ Iff (Eq x y) (Eq (@PresheafOfModules.Derivation.d C inst‚úù¬π D inst‚úù S F R M œÜ x) (@PresheafOfModules.Derivation.d C inst‚úù¬π D inst‚úù S F R M œÜ y))","decl":"/-- Given a morphism of presheaves of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`,\nthis is the type of relative `œÜ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X ‚Üí+ M.obj X` of a derivation -/\n  d {X : D·µí·µñ} : R.obj X ‚Üí+ M.obj X\n  d_mul {X : D·µí·µñ} (a b : R.obj X) : d (a * b) = a ‚Ä¢ d b + b ‚Ä¢ d a := by aesop_cat\n  d_map {X Y : D·µí·µñ} (f : X ‚ü∂ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : C·µí·µñ} (a : S.obj X) : d (œÜ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.d_map","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nself : M.Derivation œÜ\nX Y : Opposite D\nf : Quiver.Hom X Y\nx : ‚Üë(R.obj X)\n‚ä¢ Eq (self.d ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) (self.d x))","decl":"/-- Given a morphism of presheaves of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`,\nthis is the type of relative `œÜ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X ‚Üí+ M.obj X` of a derivation -/\n  d {X : D·µí·µñ} : R.obj X ‚Üí+ M.obj X\n  d_mul {X : D·µí·µñ} (a b : R.obj X) : d (a * b) = a ‚Ä¢ d b + b ‚Ä¢ d a := by aesop_cat\n  d_map {X Y : D·µí·µñ} (f : X ‚ü∂ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : C·µí·µñ} (a : S.obj X) : d (œÜ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.congr_d","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nd d' : M.Derivation œÜ\nh : Eq d d'\nX : Opposite D\nb : ‚Üë(R.obj X)\n‚ä¢ Eq (d.d b) (d'.d b)","decl":"lemma congr_d {d d' : M.Derivation œÜ} (h : d = d') {X : D·µí·µñ} (b : R.obj X) :\n    d.d b = d'.d b := by rw [h]\n\n"}
{"name":"PresheafOfModules.Derivation.d_one","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation œÜ\nX : Opposite D\n‚ä¢ Eq (d.d 1) 0","decl":"@[simp] lemma d_one (X : D·µí·µñ) : d.d (X := X) 1 = 0 := by\n  simpa using d.d_mul (X := X) 1 1\n\n"}
{"name":"PresheafOfModules.Derivation.postcomp_d_apply","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM N : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation œÜ\nf : Quiver.Hom M N\nX‚úù : Opposite D\na‚úù : ‚Üë(R.obj X‚úù)\n‚ä¢ Eq ((d.postcomp f).d a‚úù) ((ModuleCat.Hom.hom (f.app X‚úù)) (d.d a‚úù))","decl":"/-- The postcomposition of a derivation by a morphism of presheaves of modules. -/\n@[simps! d_apply]\ndef postcomp (f : M ‚ü∂ N) : N.Derivation œÜ where\n  d := (f.app _).hom.toAddMonoidHom.comp d.d\n  d_map {X Y} g x := by simpa using naturality_apply f g (d.d x)\n  d_app {X} a := by\n    dsimp\n    erw [d_app, map_zero]\n\n"}
{"name":"PresheafOfModules.Derivation.Universal.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation œÜ\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf D\ndesc : {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} ‚Üí M'.Derivation œÜ ‚Üí Quiver.Hom M M'\nfac : autoParam (‚àÄ {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} (d' : M'.Derivation œÜ), Eq (d.postcomp (desc d')) d') _auto‚úù\npostcomp_injective : autoParam (‚àÄ {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} (œÜ_1 œÜ' : Quiver.Hom M M'), Eq (d.postcomp œÜ_1) (d.postcomp œÜ') ‚Üí Eq œÜ_1 œÜ') _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { desc := desc, fac := fac, postcomp_injective := postcomp_injective }) 1","decl":"/-- The universal property that a derivation `d : M.Derivation œÜ` must\nsatisfy so that the presheaf of modules `M` can be considered as the presheaf of\n(relative) differentials of a presheaf of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`. -/\nstructure Universal where\n  /-- An absolyte derivation of `M'` descends as a morphism `M ‚ü∂ M'`. -/\n  desc {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (d' : M'.Derivation œÜ) : M ‚ü∂ M'\n  fac {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (d' : M'.Derivation œÜ) : d.postcomp (desc d') = d' := by aesop_cat\n  postcomp_injective {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (œÜ œÜ' : M ‚ü∂ M') (h : d.postcomp œÜ = d.postcomp œÜ') : œÜ = œÜ' := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.Universal.postcomp_injective","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ‚úù : Quiver.Hom S (F.op.comp R)\nd : M.Derivation œÜ‚úù\nself : d.Universal\nM' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ œÜ' : Quiver.Hom M M'\nh : Eq (d.postcomp œÜ) (d.postcomp œÜ')\n‚ä¢ Eq œÜ œÜ'","decl":"/-- The universal property that a derivation `d : M.Derivation œÜ` must\nsatisfy so that the presheaf of modules `M` can be considered as the presheaf of\n(relative) differentials of a presheaf of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`. -/\nstructure Universal where\n  /-- An absolyte derivation of `M'` descends as a morphism `M ‚ü∂ M'`. -/\n  desc {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (d' : M'.Derivation œÜ) : M ‚ü∂ M'\n  fac {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (d' : M'.Derivation œÜ) : d.postcomp (desc d') = d' := by aesop_cat\n  postcomp_injective {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (œÜ œÜ' : M ‚ü∂ M') (h : d.postcomp œÜ = d.postcomp œÜ') : œÜ = œÜ' := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.Universal.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation œÜ\ndesc‚úù : {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} ‚Üí M'.Derivation œÜ ‚Üí Quiver.Hom M M'\nfac‚úù : autoParam (‚àÄ {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} (d' : M'.Derivation œÜ), Eq (d.postcomp (desc‚úù d')) d') _auto‚úù\npostcomp_injective‚úù : autoParam (‚àÄ {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} (œÜ_1 œÜ' : Quiver.Hom M M'), Eq (d.postcomp œÜ_1) (d.postcomp œÜ') ‚Üí Eq œÜ_1 œÜ') _auto‚úù\ndesc : {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} ‚Üí M'.Derivation œÜ ‚Üí Quiver.Hom M M'\nfac : autoParam (‚àÄ {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} (d' : M'.Derivation œÜ), Eq (d.postcomp (desc d')) d') _auto‚úù\npostcomp_injective : autoParam (‚àÄ {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} (œÜ_1 œÜ' : Quiver.Hom M M'), Eq (d.postcomp œÜ_1) (d.postcomp œÜ') ‚Üí Eq œÜ_1 œÜ') _auto‚úù\nx‚úù : Eq { desc := desc‚úù, fac := fac‚úù, postcomp_injective := postcomp_injective‚úù } { desc := desc, fac := fac, postcomp_injective := postcomp_injective }\n‚ä¢ Eq desc‚úù desc","decl":"/-- The universal property that a derivation `d : M.Derivation œÜ` must\nsatisfy so that the presheaf of modules `M` can be considered as the presheaf of\n(relative) differentials of a presheaf of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`. -/\nstructure Universal where\n  /-- An absolyte derivation of `M'` descends as a morphism `M ‚ü∂ M'`. -/\n  desc {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (d' : M'.Derivation œÜ) : M ‚ü∂ M'\n  fac {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (d' : M'.Derivation œÜ) : d.postcomp (desc d') = d' := by aesop_cat\n  postcomp_injective {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (œÜ œÜ' : M ‚ü∂ M') (h : d.postcomp œÜ = d.postcomp œÜ') : œÜ = œÜ' := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.Universal.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation œÜ\ndesc‚úù : {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} ‚Üí M'.Derivation œÜ ‚Üí Quiver.Hom M M'\nfac‚úù : autoParam (‚àÄ {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} (d' : M'.Derivation œÜ), Eq (d.postcomp (desc‚úù d')) d') _auto‚úù\npostcomp_injective‚úù : autoParam (‚àÄ {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} (œÜ_1 œÜ' : Quiver.Hom M M'), Eq (d.postcomp œÜ_1) (d.postcomp œÜ') ‚Üí Eq œÜ_1 œÜ') _auto‚úù\ndesc : {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} ‚Üí M'.Derivation œÜ ‚Üí Quiver.Hom M M'\nfac : autoParam (‚àÄ {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} (d' : M'.Derivation œÜ), Eq (d.postcomp (desc d')) d') _auto‚úù\npostcomp_injective : autoParam (‚àÄ {M' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))} (œÜ_1 œÜ' : Quiver.Hom M M'), Eq (d.postcomp œÜ_1) (d.postcomp œÜ') ‚Üí Eq œÜ_1 œÜ') _auto‚úù\n‚ä¢ Eq (Eq { desc := desc‚úù, fac := fac‚úù, postcomp_injective := postcomp_injective‚úù } { desc := desc, fac := fac, postcomp_injective := postcomp_injective }) (Eq desc‚úù desc)","decl":"/-- The universal property that a derivation `d : M.Derivation œÜ` must\nsatisfy so that the presheaf of modules `M` can be considered as the presheaf of\n(relative) differentials of a presheaf of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`. -/\nstructure Universal where\n  /-- An absolyte derivation of `M'` descends as a morphism `M ‚ü∂ M'`. -/\n  desc {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (d' : M'.Derivation œÜ) : M ‚ü∂ M'\n  fac {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (d' : M'.Derivation œÜ) : d.postcomp (desc d') = d' := by aesop_cat\n  postcomp_injective {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (œÜ œÜ' : M ‚ü∂ M') (h : d.postcomp œÜ = d.postcomp œÜ') : œÜ = œÜ' := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.Universal.fac","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation œÜ\nself : d.Universal\nM' : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nd' : M'.Derivation œÜ\n‚ä¢ Eq (d.postcomp (self.desc d')) d'","decl":"/-- The universal property that a derivation `d : M.Derivation œÜ` must\nsatisfy so that the presheaf of modules `M` can be considered as the presheaf of\n(relative) differentials of a presheaf of commutative rings `œÜ : S ‚ü∂ F.op ‚ãô R`. -/\nstructure Universal where\n  /-- An absolyte derivation of `M'` descends as a morphism `M ‚ü∂ M'`. -/\n  desc {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (d' : M'.Derivation œÜ) : M ‚ü∂ M'\n  fac {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (d' : M'.Derivation œÜ) : d.postcomp (desc d') = d' := by aesop_cat\n  postcomp_injective {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n    (œÜ œÜ' : M ‚ü∂ M') (h : d.postcomp œÜ = d.postcomp œÜ') : œÜ = œÜ' := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.instSubsingletonUniversal","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation œÜ\n‚ä¢ Subsingleton d.Universal","decl":"instance : Subsingleton d.Universal where\n  allEq h‚ÇÅ h‚ÇÇ := by\n    suffices ‚àÄ {M' : PresheafOfModules (R ‚ãô forget‚ÇÇ CommRingCat RingCat)}\n      (d' : M'.Derivation œÜ), h‚ÇÅ.desc d' = h‚ÇÇ.desc d' by\n        cases h‚ÇÅ\n        cases h‚ÇÇ\n        simp only [Universal.mk.injEq]\n        ext : 2\n        apply this\n    intro M' d'\n    apply h‚ÇÅ.postcomp_injective\n    simp\n\n"}
{"name":"PresheafOfModules.HasDifferentials.exists_universal_derivation","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nœÜ : Quiver.Hom S (F.op.comp R)\nself : PresheafOfModules.HasDifferentials œÜ\n‚ä¢ Exists fun M => Exists fun d => Nonempty d.Universal","decl":"/-- The property that there exists a universal derivation for\na morphism of presheaves of commutative rings `S ‚ü∂ F.op ‚ãô R`. -/\nclass HasDifferentials : Prop where\n  exists_universal_derivation : ‚àÉ (M : PresheafOfModules.{u} (R ‚ãô forget‚ÇÇ _ _))\n      (d : M.Derivation œÜ), Nonempty d.Universal\n\n"}
{"name":"PresheafOfModules.Derivation'.d_app","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ' : Quiver.Hom S' R\nd : M.Derivation' œÜ'\nX : Opposite D\na : ‚Üë(S'.obj X)\n‚ä¢ Eq (d.d ((CategoryTheory.ConcreteCategory.hom (œÜ'.app X)) a)) 0","decl":"@[simp]\nnonrec lemma d_app (d : M.Derivation' œÜ') {X : D·µí·µñ} (a : S'.obj X) :\n    d.d (œÜ'.app X a) = 0 :=\n  d.d_app _\n\n"}
{"name":"PresheafOfModules.Derivation'.app_apply","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ' : Quiver.Hom S' R\nd : M.Derivation' œÜ'\nX : Opposite D\nb : ‚Üë(R.obj X)\n‚ä¢ Eq ((d.app X).d b) (d.d b)","decl":"@[simp]\nlemma app_apply (d : M.Derivation' œÜ') {X : D·µí·µñ} (b : R.obj X) :\n    (d.app X).d b = d.d b := rfl\n\n"}
{"name":"PresheafOfModules.Derivation'.mk_app","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget‚ÇÇ CommRingCat RingCat))\nœÜ' : Quiver.Hom S' R\nd : (X : Opposite D) ‚Üí (M.obj X).Derivation (œÜ'.app X)\nd_map : ‚àÄ ‚¶ÉX Y : Opposite D‚¶Ñ (f : Quiver.Hom X Y) (x : ‚Üë(R.obj X)), Eq ((d Y).d ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) ((d X).d x))\nX : Opposite D\n‚ä¢ Eq ((PresheafOfModules.Derivation'.mk d d_map).app X) (d X)","decl":"@[simp]\nlemma mk_app (X : D·µí·µñ) : (mk d d_map).app X = d X := rfl\n\n"}
{"name":"PresheafOfModules.DifferentialsConstruction.relativeDifferentials'_obj","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nœÜ' : Quiver.Hom S' R\nX : Opposite D\n‚ä¢ Eq ((PresheafOfModules.DifferentialsConstruction.relativeDifferentials' œÜ').obj X) (CommRingCat.KaehlerDifferential (œÜ'.app X))","decl":"/-- The presheaf of relative differentials of a morphism of presheaves of\ncommutative rings. -/\n@[simps (config := .lemmasOnly)]\nnoncomputable def relativeDifferentials' :\n    PresheafOfModules.{u} (R ‚ãô forget‚ÇÇ _ _) where\n  obj X := CommRingCat.KaehlerDifferential (œÜ'.app X)\n  -- Have to hint `g' := R.map f` below, or it gets unfolded weirdly.\n  map f := CommRingCat.KaehlerDifferential.map (g' := R.map f) (œÜ'.naturality f)\n  -- Without `dsimp`, `ext` doesn't pick up the right lemmas.\n  map_id _ := by dsimp; ext; simp\n  map_comp _ _ := by dsimp; ext; simp\n\n"}
{"name":"PresheafOfModules.DifferentialsConstruction.relativeDifferentials'_map","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nœÜ' : Quiver.Hom S' R\nX‚úù Y‚úù : Opposite D\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((PresheafOfModules.DifferentialsConstruction.relativeDifferentials' œÜ').map f) (CommRingCat.KaehlerDifferential.map ‚ãØ)","decl":"/-- The presheaf of relative differentials of a morphism of presheaves of\ncommutative rings. -/\n@[simps (config := .lemmasOnly)]\nnoncomputable def relativeDifferentials' :\n    PresheafOfModules.{u} (R ‚ãô forget‚ÇÇ _ _) where\n  obj X := CommRingCat.KaehlerDifferential (œÜ'.app X)\n  -- Have to hint `g' := R.map f` below, or it gets unfolded weirdly.\n  map f := CommRingCat.KaehlerDifferential.map (g' := R.map f) (œÜ'.naturality f)\n  -- Without `dsimp`, `ext` doesn't pick up the right lemmas.\n  map_id _ := by dsimp; ext; simp\n  map_comp _ _ := by dsimp; ext; simp\n\n"}
{"name":"PresheafOfModules.DifferentialsConstruction.relativeDifferentials'_map_d","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nœÜ' : Quiver.Hom S' R\nX Y : Opposite D\nf : Quiver.Hom X Y\nx : ‚Üë(R.obj X)\n‚ä¢ Eq ((ModuleCat.Hom.hom ((PresheafOfModules.DifferentialsConstruction.relativeDifferentials' œÜ').map f)) (CommRingCat.KaehlerDifferential.d x)) (CommRingCat.KaehlerDifferential.d ((CategoryTheory.ConcreteCategory.hom (R.map f)) x))","decl":"@[simp]\nlemma relativeDifferentials'_map_d {X Y : D·µí·µñ} (f : X ‚ü∂ Y) (x : R.obj X) :\n    DFunLike.coe (Œ± := CommRingCat.KaehlerDifferential (œÜ'.app X))\n      (Œ≤ := fun _ ‚Ü¶ CommRingCat.KaehlerDifferential (œÜ'.app Y))\n      (ModuleCat.Hom.hom (R := ‚Üë(R.obj X)) ((relativeDifferentials' œÜ').map f))\n        (CommRingCat.KaehlerDifferential.d x) =\n        CommRingCat.KaehlerDifferential.d (R.map f x) :=\n  CommRingCat.KaehlerDifferential.map_d (œÜ'.naturality f) _\n\n"}
{"name":"PresheafOfModules.DifferentialsConstruction.instHasDifferentials","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nœÜ' : Quiver.Hom S' R\n‚ä¢ PresheafOfModules.HasDifferentials œÜ'","decl":"instance : HasDifferentials (F := ùü≠ D) œÜ' := ‚ü®_, _,  ‚ü®isUniversal' œÜ'‚ü©‚ü©\n\n"}
