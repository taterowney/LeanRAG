{"name":"PresheafOfModules.Derivation.ext","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nx y : M.Derivation φ\nd : Eq (@PresheafOfModules.Derivation.d C inst✝¹ D inst✝ S F R M φ x) (@PresheafOfModules.Derivation.d C inst✝¹ D inst✝ S F R M φ y)\n⊢ Eq x y","decl":"/-- Given a morphism of presheaves of commutative rings `φ : S ⟶ F.op ⋙ R`,\nthis is the type of relative `φ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X →+ M.obj X` of a derivation -/\n  d {X : Dᵒᵖ} : R.obj X →+ M.obj X\n  d_mul {X : Dᵒᵖ} (a b : R.obj X) : d (a * b) = a • d b + b • d a := by aesop_cat\n  d_map {X Y : Dᵒᵖ} (f : X ⟶ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : Cᵒᵖ} (a : S.obj X) : d (φ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.d_mul","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nself : M.Derivation φ\nX : Opposite D\na b : ↑(R.obj X)\n⊢ Eq (self.d (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (self.d b)) (HSMul.hSMul b (self.d a)))","decl":"/-- Given a morphism of presheaves of commutative rings `φ : S ⟶ F.op ⋙ R`,\nthis is the type of relative `φ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X →+ M.obj X` of a derivation -/\n  d {X : Dᵒᵖ} : R.obj X →+ M.obj X\n  d_mul {X : Dᵒᵖ} (a b : R.obj X) : d (a * b) = a • d b + b • d a := by aesop_cat\n  d_map {X Y : Dᵒᵖ} (f : X ⟶ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : Cᵒᵖ} (a : S.obj X) : d (φ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nd✝ : {X : Opposite D} → AddMonoidHom ↑(R.obj X) ↑(M.obj X)\nd_mul✝ : autoParam (∀ {X : Opposite D} (a b : ↑(R.obj X)), Eq (d✝ (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (d✝ b)) (HSMul.hSMul b (d✝ a)))) _auto✝\nd_map✝ : autoParam (∀ {X Y : Opposite D} (f : Quiver.Hom X Y) (x : ↑(R.obj X)), Eq (d✝ ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) (d✝ x))) _auto✝\nd_app✝ : autoParam (∀ {X : Opposite C} (a : ↑(S.obj X)), Eq (d✝ ((CategoryTheory.ConcreteCategory.hom (φ.app X)) a)) 0) _auto✝\nd : {X : Opposite D} → AddMonoidHom ↑(R.obj X) ↑(M.obj X)\nd_mul : autoParam (∀ {X : Opposite D} (a b : ↑(R.obj X)), Eq (d (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (d b)) (HSMul.hSMul b (d a)))) _auto✝\nd_map : autoParam (∀ {X Y : Opposite D} (f : Quiver.Hom X Y) (x : ↑(R.obj X)), Eq (d ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) (d x))) _auto✝\nd_app : autoParam (∀ {X : Opposite C} (a : ↑(S.obj X)), Eq (d ((CategoryTheory.ConcreteCategory.hom (φ.app X)) a)) 0) _auto✝\n⊢ Eq (Eq { d := d✝, d_mul := d_mul✝, d_map := d_map✝, d_app := d_app✝ } { d := d, d_mul := d_mul, d_map := d_map, d_app := d_app }) (Eq d✝ d)","decl":"/-- Given a morphism of presheaves of commutative rings `φ : S ⟶ F.op ⋙ R`,\nthis is the type of relative `φ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X →+ M.obj X` of a derivation -/\n  d {X : Dᵒᵖ} : R.obj X →+ M.obj X\n  d_mul {X : Dᵒᵖ} (a b : R.obj X) : d (a * b) = a • d b + b • d a := by aesop_cat\n  d_map {X Y : Dᵒᵖ} (f : X ⟶ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : Cᵒᵖ} (a : S.obj X) : d (φ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\ninst✝¹ : SizeOf C\ninst✝ : SizeOf D\nd : {X : Opposite D} → AddMonoidHom ↑(R.obj X) ↑(M.obj X)\nd_mul : autoParam (∀ {X : Opposite D} (a b : ↑(R.obj X)), Eq (d (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (d b)) (HSMul.hSMul b (d a)))) _auto✝\nd_map : autoParam (∀ {X Y : Opposite D} (f : Quiver.Hom X Y) (x : ↑(R.obj X)), Eq (d ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) (d x))) _auto✝\nd_app : autoParam (∀ {X : Opposite C} (a : ↑(S.obj X)), Eq (d ((CategoryTheory.ConcreteCategory.hom (φ.app X)) a)) 0) _auto✝\n⊢ Eq (SizeOf.sizeOf { d := d, d_mul := d_mul, d_map := d_map, d_app := d_app }) 1","decl":"/-- Given a morphism of presheaves of commutative rings `φ : S ⟶ F.op ⋙ R`,\nthis is the type of relative `φ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X →+ M.obj X` of a derivation -/\n  d {X : Dᵒᵖ} : R.obj X →+ M.obj X\n  d_mul {X : Dᵒᵖ} (a b : R.obj X) : d (a * b) = a • d b + b • d a := by aesop_cat\n  d_map {X Y : Dᵒᵖ} (f : X ⟶ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : Cᵒᵖ} (a : S.obj X) : d (φ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nd✝ : {X : Opposite D} → AddMonoidHom ↑(R.obj X) ↑(M.obj X)\nd_mul✝ : autoParam (∀ {X : Opposite D} (a b : ↑(R.obj X)), Eq (d✝ (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (d✝ b)) (HSMul.hSMul b (d✝ a)))) _auto✝\nd_map✝ : autoParam (∀ {X Y : Opposite D} (f : Quiver.Hom X Y) (x : ↑(R.obj X)), Eq (d✝ ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) (d✝ x))) _auto✝\nd_app✝ : autoParam (∀ {X : Opposite C} (a : ↑(S.obj X)), Eq (d✝ ((CategoryTheory.ConcreteCategory.hom (φ.app X)) a)) 0) _auto✝\nd : {X : Opposite D} → AddMonoidHom ↑(R.obj X) ↑(M.obj X)\nd_mul : autoParam (∀ {X : Opposite D} (a b : ↑(R.obj X)), Eq (d (HMul.hMul a b)) (HAdd.hAdd (HSMul.hSMul a (d b)) (HSMul.hSMul b (d a)))) _auto✝\nd_map : autoParam (∀ {X Y : Opposite D} (f : Quiver.Hom X Y) (x : ↑(R.obj X)), Eq (d ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) (d x))) _auto✝\nd_app : autoParam (∀ {X : Opposite C} (a : ↑(S.obj X)), Eq (d ((CategoryTheory.ConcreteCategory.hom (φ.app X)) a)) 0) _auto✝\nx✝ : Eq { d := d✝, d_mul := d_mul✝, d_map := d_map✝, d_app := d_app✝ } { d := d, d_mul := d_mul, d_map := d_map, d_app := d_app }\n⊢ Eq d✝ d","decl":"/-- Given a morphism of presheaves of commutative rings `φ : S ⟶ F.op ⋙ R`,\nthis is the type of relative `φ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X →+ M.obj X` of a derivation -/\n  d {X : Dᵒᵖ} : R.obj X →+ M.obj X\n  d_mul {X : Dᵒᵖ} (a b : R.obj X) : d (a * b) = a • d b + b • d a := by aesop_cat\n  d_map {X Y : Dᵒᵖ} (f : X ⟶ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : Cᵒᵖ} (a : S.obj X) : d (φ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.d_app","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nself : M.Derivation φ\nX : Opposite C\na : ↑(S.obj X)\n⊢ Eq (self.d ((CategoryTheory.ConcreteCategory.hom (φ.app X)) a)) 0","decl":"/-- Given a morphism of presheaves of commutative rings `φ : S ⟶ F.op ⋙ R`,\nthis is the type of relative `φ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X →+ M.obj X` of a derivation -/\n  d {X : Dᵒᵖ} : R.obj X →+ M.obj X\n  d_mul {X : Dᵒᵖ} (a b : R.obj X) : d (a * b) = a • d b + b • d a := by aesop_cat\n  d_map {X Y : Dᵒᵖ} (f : X ⟶ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : Cᵒᵖ} (a : S.obj X) : d (φ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.ext_iff","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nx y : M.Derivation φ\n⊢ Iff (Eq x y) (Eq (@PresheafOfModules.Derivation.d C inst✝¹ D inst✝ S F R M φ x) (@PresheafOfModules.Derivation.d C inst✝¹ D inst✝ S F R M φ y))","decl":"/-- Given a morphism of presheaves of commutative rings `φ : S ⟶ F.op ⋙ R`,\nthis is the type of relative `φ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X →+ M.obj X` of a derivation -/\n  d {X : Dᵒᵖ} : R.obj X →+ M.obj X\n  d_mul {X : Dᵒᵖ} (a b : R.obj X) : d (a * b) = a • d b + b • d a := by aesop_cat\n  d_map {X Y : Dᵒᵖ} (f : X ⟶ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : Cᵒᵖ} (a : S.obj X) : d (φ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.d_map","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nself : M.Derivation φ\nX Y : Opposite D\nf : Quiver.Hom X Y\nx : ↑(R.obj X)\n⊢ Eq (self.d ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) (self.d x))","decl":"/-- Given a morphism of presheaves of commutative rings `φ : S ⟶ F.op ⋙ R`,\nthis is the type of relative `φ`-derivation of a presheaf of `R`-modules `M`. -/\n@[ext]\nstructure Derivation where\n  /-- the underlying additive map `R.obj X →+ M.obj X` of a derivation -/\n  d {X : Dᵒᵖ} : R.obj X →+ M.obj X\n  d_mul {X : Dᵒᵖ} (a b : R.obj X) : d (a * b) = a • d b + b • d a := by aesop_cat\n  d_map {X Y : Dᵒᵖ} (f : X ⟶ Y) (x : R.obj X) :\n    d (R.map f x) = M.map f (d x) := by aesop_cat\n  d_app {X : Cᵒᵖ} (a : S.obj X) : d (φ.app X a) = 0 := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.congr_d","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nd d' : M.Derivation φ\nh : Eq d d'\nX : Opposite D\nb : ↑(R.obj X)\n⊢ Eq (d.d b) (d'.d b)","decl":"lemma congr_d {d d' : M.Derivation φ} (h : d = d') {X : Dᵒᵖ} (b : R.obj X) :\n    d.d b = d'.d b := by rw [h]\n\n"}
{"name":"PresheafOfModules.Derivation.d_one","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation φ\nX : Opposite D\n⊢ Eq (d.d 1) 0","decl":"@[simp] lemma d_one (X : Dᵒᵖ) : d.d (X := X) 1 = 0 := by\n  simpa using d.d_mul (X := X) 1 1\n\n"}
{"name":"PresheafOfModules.Derivation.postcomp_d_apply","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM N : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation φ\nf : Quiver.Hom M N\nX✝ : Opposite D\na✝ : ↑(R.obj X✝)\n⊢ Eq ((d.postcomp f).d a✝) ((ModuleCat.Hom.hom (f.app X✝)) (d.d a✝))","decl":"/-- The postcomposition of a derivation by a morphism of presheaves of modules. -/\n@[simps! d_apply]\ndef postcomp (f : M ⟶ N) : N.Derivation φ where\n  d := (f.app _).hom.toAddMonoidHom.comp d.d\n  d_map {X Y} g x := by simpa using naturality_apply f g (d.d x)\n  d_app {X} a := by\n    dsimp\n    erw [d_app, map_zero]\n\n"}
{"name":"PresheafOfModules.Derivation.Universal.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation φ\ninst✝¹ : SizeOf C\ninst✝ : SizeOf D\ndesc : {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} → M'.Derivation φ → Quiver.Hom M M'\nfac : autoParam (∀ {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} (d' : M'.Derivation φ), Eq (d.postcomp (desc d')) d') _auto✝\npostcomp_injective : autoParam (∀ {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} (φ_1 φ' : Quiver.Hom M M'), Eq (d.postcomp φ_1) (d.postcomp φ') → Eq φ_1 φ') _auto✝\n⊢ Eq (SizeOf.sizeOf { desc := desc, fac := fac, postcomp_injective := postcomp_injective }) 1","decl":"/-- The universal property that a derivation `d : M.Derivation φ` must\nsatisfy so that the presheaf of modules `M` can be considered as the presheaf of\n(relative) differentials of a presheaf of commutative rings `φ : S ⟶ F.op ⋙ R`. -/\nstructure Universal where\n  /-- An absolyte derivation of `M'` descends as a morphism `M ⟶ M'`. -/\n  desc {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (d' : M'.Derivation φ) : M ⟶ M'\n  fac {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (d' : M'.Derivation φ) : d.postcomp (desc d') = d' := by aesop_cat\n  postcomp_injective {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (φ φ' : M ⟶ M') (h : d.postcomp φ = d.postcomp φ') : φ = φ' := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.Universal.postcomp_injective","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ✝ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation φ✝\nself : d.Universal\nM' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ φ' : Quiver.Hom M M'\nh : Eq (d.postcomp φ) (d.postcomp φ')\n⊢ Eq φ φ'","decl":"/-- The universal property that a derivation `d : M.Derivation φ` must\nsatisfy so that the presheaf of modules `M` can be considered as the presheaf of\n(relative) differentials of a presheaf of commutative rings `φ : S ⟶ F.op ⋙ R`. -/\nstructure Universal where\n  /-- An absolyte derivation of `M'` descends as a morphism `M ⟶ M'`. -/\n  desc {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (d' : M'.Derivation φ) : M ⟶ M'\n  fac {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (d' : M'.Derivation φ) : d.postcomp (desc d') = d' := by aesop_cat\n  postcomp_injective {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (φ φ' : M ⟶ M') (h : d.postcomp φ = d.postcomp φ') : φ = φ' := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.Universal.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation φ\ndesc✝ : {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} → M'.Derivation φ → Quiver.Hom M M'\nfac✝ : autoParam (∀ {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} (d' : M'.Derivation φ), Eq (d.postcomp (desc✝ d')) d') _auto✝\npostcomp_injective✝ : autoParam (∀ {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} (φ_1 φ' : Quiver.Hom M M'), Eq (d.postcomp φ_1) (d.postcomp φ') → Eq φ_1 φ') _auto✝\ndesc : {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} → M'.Derivation φ → Quiver.Hom M M'\nfac : autoParam (∀ {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} (d' : M'.Derivation φ), Eq (d.postcomp (desc d')) d') _auto✝\npostcomp_injective : autoParam (∀ {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} (φ_1 φ' : Quiver.Hom M M'), Eq (d.postcomp φ_1) (d.postcomp φ') → Eq φ_1 φ') _auto✝\nx✝ : Eq { desc := desc✝, fac := fac✝, postcomp_injective := postcomp_injective✝ } { desc := desc, fac := fac, postcomp_injective := postcomp_injective }\n⊢ Eq desc✝ desc","decl":"/-- The universal property that a derivation `d : M.Derivation φ` must\nsatisfy so that the presheaf of modules `M` can be considered as the presheaf of\n(relative) differentials of a presheaf of commutative rings `φ : S ⟶ F.op ⋙ R`. -/\nstructure Universal where\n  /-- An absolyte derivation of `M'` descends as a morphism `M ⟶ M'`. -/\n  desc {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (d' : M'.Derivation φ) : M ⟶ M'\n  fac {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (d' : M'.Derivation φ) : d.postcomp (desc d') = d' := by aesop_cat\n  postcomp_injective {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (φ φ' : M ⟶ M') (h : d.postcomp φ = d.postcomp φ') : φ = φ' := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.Universal.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation φ\ndesc✝ : {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} → M'.Derivation φ → Quiver.Hom M M'\nfac✝ : autoParam (∀ {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} (d' : M'.Derivation φ), Eq (d.postcomp (desc✝ d')) d') _auto✝\npostcomp_injective✝ : autoParam (∀ {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} (φ_1 φ' : Quiver.Hom M M'), Eq (d.postcomp φ_1) (d.postcomp φ') → Eq φ_1 φ') _auto✝\ndesc : {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} → M'.Derivation φ → Quiver.Hom M M'\nfac : autoParam (∀ {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} (d' : M'.Derivation φ), Eq (d.postcomp (desc d')) d') _auto✝\npostcomp_injective : autoParam (∀ {M' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))} (φ_1 φ' : Quiver.Hom M M'), Eq (d.postcomp φ_1) (d.postcomp φ') → Eq φ_1 φ') _auto✝\n⊢ Eq (Eq { desc := desc✝, fac := fac✝, postcomp_injective := postcomp_injective✝ } { desc := desc, fac := fac, postcomp_injective := postcomp_injective }) (Eq desc✝ desc)","decl":"/-- The universal property that a derivation `d : M.Derivation φ` must\nsatisfy so that the presheaf of modules `M` can be considered as the presheaf of\n(relative) differentials of a presheaf of commutative rings `φ : S ⟶ F.op ⋙ R`. -/\nstructure Universal where\n  /-- An absolyte derivation of `M'` descends as a morphism `M ⟶ M'`. -/\n  desc {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (d' : M'.Derivation φ) : M ⟶ M'\n  fac {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (d' : M'.Derivation φ) : d.postcomp (desc d') = d' := by aesop_cat\n  postcomp_injective {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (φ φ' : M ⟶ M') (h : d.postcomp φ = d.postcomp φ') : φ = φ' := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.Universal.fac","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation φ\nself : d.Universal\nM' : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nd' : M'.Derivation φ\n⊢ Eq (d.postcomp (self.desc d')) d'","decl":"/-- The universal property that a derivation `d : M.Derivation φ` must\nsatisfy so that the presheaf of modules `M` can be considered as the presheaf of\n(relative) differentials of a presheaf of commutative rings `φ : S ⟶ F.op ⋙ R`. -/\nstructure Universal where\n  /-- An absolyte derivation of `M'` descends as a morphism `M ⟶ M'`. -/\n  desc {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (d' : M'.Derivation φ) : M ⟶ M'\n  fac {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (d' : M'.Derivation φ) : d.postcomp (desc d') = d' := by aesop_cat\n  postcomp_injective {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n    (φ φ' : M ⟶ M') (h : d.postcomp φ = d.postcomp φ') : φ = φ' := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Derivation.instSubsingletonUniversal","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ : Quiver.Hom S (F.op.comp R)\nd : M.Derivation φ\n⊢ Subsingleton d.Universal","decl":"instance : Subsingleton d.Universal where\n  allEq h₁ h₂ := by\n    suffices ∀ {M' : PresheafOfModules (R ⋙ forget₂ CommRingCat RingCat)}\n      (d' : M'.Derivation φ), h₁.desc d' = h₂.desc d' by\n        cases h₁\n        cases h₂\n        simp only [Universal.mk.injEq]\n        ext : 2\n        apply this\n    intro M' d'\n    apply h₁.postcomp_injective\n    simp\n\n"}
{"name":"PresheafOfModules.HasDifferentials.exists_universal_derivation","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor (Opposite C) CommRingCat\nF : CategoryTheory.Functor C D\nR : CategoryTheory.Functor (Opposite D) CommRingCat\nφ : Quiver.Hom S (F.op.comp R)\nself : PresheafOfModules.HasDifferentials φ\n⊢ Exists fun M => Exists fun d => Nonempty d.Universal","decl":"/-- The property that there exists a universal derivation for\na morphism of presheaves of commutative rings `S ⟶ F.op ⋙ R`. -/\nclass HasDifferentials : Prop where\n  exists_universal_derivation : ∃ (M : PresheafOfModules.{u} (R ⋙ forget₂ _ _))\n      (d : M.Derivation φ), Nonempty d.Universal\n\n"}
{"name":"PresheafOfModules.Derivation'.d_app","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ' : Quiver.Hom S' R\nd : M.Derivation' φ'\nX : Opposite D\na : ↑(S'.obj X)\n⊢ Eq (d.d ((CategoryTheory.ConcreteCategory.hom (φ'.app X)) a)) 0","decl":"@[simp]\nnonrec lemma d_app (d : M.Derivation' φ') {X : Dᵒᵖ} (a : S'.obj X) :\n    d.d (φ'.app X a) = 0 :=\n  d.d_app _\n\n"}
{"name":"PresheafOfModules.Derivation'.app_apply","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ' : Quiver.Hom S' R\nd : M.Derivation' φ'\nX : Opposite D\nb : ↑(R.obj X)\n⊢ Eq ((d.app X).d b) (d.d b)","decl":"@[simp]\nlemma app_apply (d : M.Derivation' φ') {X : Dᵒᵖ} (b : R.obj X) :\n    (d.app X).d b = d.d b := rfl\n\n"}
{"name":"PresheafOfModules.Derivation'.mk_app","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nM : PresheafOfModules (R.comp (CategoryTheory.forget₂ CommRingCat RingCat))\nφ' : Quiver.Hom S' R\nd : (X : Opposite D) → (M.obj X).Derivation (φ'.app X)\nd_map : ∀ ⦃X Y : Opposite D⦄ (f : Quiver.Hom X Y) (x : ↑(R.obj X)), Eq ((d Y).d ((CategoryTheory.ConcreteCategory.hom (R.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (M.map f)) ((d X).d x))\nX : Opposite D\n⊢ Eq ((PresheafOfModules.Derivation'.mk d d_map).app X) (d X)","decl":"@[simp]\nlemma mk_app (X : Dᵒᵖ) : (mk d d_map).app X = d X := rfl\n\n"}
{"name":"PresheafOfModules.DifferentialsConstruction.relativeDifferentials'_obj","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nφ' : Quiver.Hom S' R\nX : Opposite D\n⊢ Eq ((PresheafOfModules.DifferentialsConstruction.relativeDifferentials' φ').obj X) (CommRingCat.KaehlerDifferential (φ'.app X))","decl":"/-- The presheaf of relative differentials of a morphism of presheaves of\ncommutative rings. -/\n@[simps (config := .lemmasOnly)]\nnoncomputable def relativeDifferentials' :\n    PresheafOfModules.{u} (R ⋙ forget₂ _ _) where\n  obj X := CommRingCat.KaehlerDifferential (φ'.app X)\n  -- Have to hint `g' := R.map f` below, or it gets unfolded weirdly.\n  map f := CommRingCat.KaehlerDifferential.map (g' := R.map f) (φ'.naturality f)\n  -- Without `dsimp`, `ext` doesn't pick up the right lemmas.\n  map_id _ := by dsimp; ext; simp\n  map_comp _ _ := by dsimp; ext; simp\n\n"}
{"name":"PresheafOfModules.DifferentialsConstruction.relativeDifferentials'_map","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nφ' : Quiver.Hom S' R\nX✝ Y✝ : Opposite D\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((PresheafOfModules.DifferentialsConstruction.relativeDifferentials' φ').map f) (CommRingCat.KaehlerDifferential.map ⋯)","decl":"/-- The presheaf of relative differentials of a morphism of presheaves of\ncommutative rings. -/\n@[simps (config := .lemmasOnly)]\nnoncomputable def relativeDifferentials' :\n    PresheafOfModules.{u} (R ⋙ forget₂ _ _) where\n  obj X := CommRingCat.KaehlerDifferential (φ'.app X)\n  -- Have to hint `g' := R.map f` below, or it gets unfolded weirdly.\n  map f := CommRingCat.KaehlerDifferential.map (g' := R.map f) (φ'.naturality f)\n  -- Without `dsimp`, `ext` doesn't pick up the right lemmas.\n  map_id _ := by dsimp; ext; simp\n  map_comp _ _ := by dsimp; ext; simp\n\n"}
{"name":"PresheafOfModules.DifferentialsConstruction.relativeDifferentials'_map_d","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nφ' : Quiver.Hom S' R\nX Y : Opposite D\nf : Quiver.Hom X Y\nx : ↑(R.obj X)\n⊢ Eq ((ModuleCat.Hom.hom ((PresheafOfModules.DifferentialsConstruction.relativeDifferentials' φ').map f)) (CommRingCat.KaehlerDifferential.d x)) (CommRingCat.KaehlerDifferential.d ((CategoryTheory.ConcreteCategory.hom (R.map f)) x))","decl":"@[simp]\nlemma relativeDifferentials'_map_d {X Y : Dᵒᵖ} (f : X ⟶ Y) (x : R.obj X) :\n    DFunLike.coe (α := CommRingCat.KaehlerDifferential (φ'.app X))\n      (β := fun _ ↦ CommRingCat.KaehlerDifferential (φ'.app Y))\n      (ModuleCat.Hom.hom (R := ↑(R.obj X)) ((relativeDifferentials' φ').map f))\n        (CommRingCat.KaehlerDifferential.d x) =\n        CommRingCat.KaehlerDifferential.d (R.map f x) :=\n  CommRingCat.KaehlerDifferential.map_d (φ'.naturality f) _\n\n"}
{"name":"PresheafOfModules.DifferentialsConstruction.instHasDifferentials","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Presheaf","initialProofState":"D : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS' R : CategoryTheory.Functor (Opposite D) CommRingCat\nφ' : Quiver.Hom S' R\n⊢ PresheafOfModules.HasDifferentials φ'","decl":"instance : HasDifferentials (F := 𝟭 D) φ' := ⟨_, _,  ⟨isUniversal' φ'⟩⟩\n\n"}
