{"name":"ProbabilityTheory.lintegral_condKernel_mem","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\na : α\ns : Set (Prod β Ω)\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.lintegral (κ.fst a) fun x => (κ.condKernel { fst := a, snd := x }) (setOf fun y => Membership.mem s { fst := x, snd := y })) ((κ a) s)","decl":"lemma lintegral_condKernel_mem (a : α) {s : Set (β × Ω)} (hs : MeasurableSet s) :\n    ∫⁻ x, Kernel.condKernel κ (a, x) {y | (x, y) ∈ s} ∂(Kernel.fst κ a) = κ a s := by\n  conv_rhs => rw [← κ.disintegrate κ.condKernel]\n  simp_rw [Kernel.compProd_apply hs]\n\n"}
{"name":"ProbabilityTheory.setLIntegral_condKernel_eq_measure_prod","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\na : α\ns : Set β\nhs : MeasurableSet s\nt : Set Ω\nht : MeasurableSet t\n⊢ Eq (MeasureTheory.lintegral ((κ.fst a).restrict s) fun b => (κ.condKernel { fst := a, snd := b }) t) ((κ a) (SProd.sprod s t))","decl":"lemma setLIntegral_condKernel_eq_measure_prod (a : α) {s : Set β} (hs : MeasurableSet s)\n    {t : Set Ω} (ht : MeasurableSet t) :\n    ∫⁻ b in s, Kernel.condKernel κ (a, b) t ∂(Kernel.fst κ a) = κ a (s ×ˢ t) := by\n  have : κ a (s ×ˢ t) = (Kernel.fst κ ⊗ₖ Kernel.condKernel κ) a (s ×ˢ t) := by\n    congr; exact (κ.disintegrate _).symm\n  rw [this, Kernel.compProd_apply (hs.prod ht)]\n  classical\n  have : ∀ b, Kernel.condKernel κ (a, b) {c | (b, c) ∈ s ×ˢ t}\n      = s.indicator (fun b ↦ Kernel.condKernel κ (a, b) t) b := by\n    intro b\n    by_cases hb : b ∈ s <;> simp [hb]\n  simp_rw [this]\n  rw [lintegral_indicator hs]\n\n"}
{"name":"ProbabilityTheory.lintegral_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nf : Prod β Ω → ENNReal\nhf : Measurable f\na : α\n⊢ Eq (MeasureTheory.lintegral (κ.fst a) fun b => MeasureTheory.lintegral (κ.condKernel { fst := a, snd := b }) fun ω => f { fst := b, snd := ω }) (MeasureTheory.lintegral (κ a) fun x => f x)","decl":"lemma lintegral_condKernel (hf : Measurable f) (a : α) :\n    ∫⁻ b, ∫⁻ ω, f (b, ω) ∂(Kernel.condKernel κ (a, b)) ∂(Kernel.fst κ a) = ∫⁻ x, f x ∂(κ a) := by\n  conv_rhs => rw [← κ.disintegrate κ.condKernel]\n  rw [Kernel.lintegral_compProd _ _ _ hf]\n\n"}
{"name":"ProbabilityTheory.setLIntegral_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nf : Prod β Ω → ENNReal\nhf : Measurable f\na : α\ns : Set β\nhs : MeasurableSet s\nt : Set Ω\nht : MeasurableSet t\n⊢ Eq (MeasureTheory.lintegral ((κ.fst a).restrict s) fun b => MeasureTheory.lintegral ((κ.condKernel { fst := a, snd := b }).restrict t) fun ω => f { fst := b, snd := ω }) (MeasureTheory.lintegral ((κ a).restrict (SProd.sprod s t)) fun x => f x)","decl":"lemma setLIntegral_condKernel (hf : Measurable f) (a : α) {s : Set β}\n    (hs : MeasurableSet s) {t : Set Ω} (ht : MeasurableSet t) :\n    ∫⁻ b in s, ∫⁻ ω in t, f (b, ω) ∂(Kernel.condKernel κ (a, b)) ∂(Kernel.fst κ a)\n      = ∫⁻ x in s ×ˢ t, f x ∂(κ a) := by\n  conv_rhs => rw [← κ.disintegrate κ.condKernel]\n  rw [Kernel.setLIntegral_compProd _ _ _ hf hs ht]\n\n"}
{"name":"ProbabilityTheory.setLIntegral_condKernel_univ_right","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nf : Prod β Ω → ENNReal\nhf : Measurable f\na : α\ns : Set β\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.lintegral ((κ.fst a).restrict s) fun b => MeasureTheory.lintegral (κ.condKernel { fst := a, snd := b }) fun ω => f { fst := b, snd := ω }) (MeasureTheory.lintegral ((κ a).restrict (SProd.sprod s Set.univ)) fun x => f x)","decl":"lemma setLIntegral_condKernel_univ_right (hf : Measurable f) (a : α) {s : Set β}\n    (hs : MeasurableSet s) :\n    ∫⁻ b in s, ∫⁻ ω, f (b, ω) ∂(Kernel.condKernel κ (a, b)) ∂(Kernel.fst κ a)\n      = ∫⁻ x in s ×ˢ Set.univ, f x ∂(κ a) := by\n  rw [← setLIntegral_condKernel hf a hs MeasurableSet.univ]; simp_rw [Measure.restrict_univ]\n\n"}
{"name":"ProbabilityTheory.setLIntegral_condKernel_univ_left","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nf : Prod β Ω → ENNReal\nhf : Measurable f\na : α\nt : Set Ω\nht : MeasurableSet t\n⊢ Eq (MeasureTheory.lintegral (κ.fst a) fun b => MeasureTheory.lintegral ((κ.condKernel { fst := a, snd := b }).restrict t) fun ω => f { fst := b, snd := ω }) (MeasureTheory.lintegral ((κ a).restrict (SProd.sprod Set.univ t)) fun x => f x)","decl":"lemma setLIntegral_condKernel_univ_left (hf : Measurable f) (a : α) {t : Set Ω}\n    (ht : MeasurableSet t) :\n    ∫⁻ b, ∫⁻ ω in t, f (b, ω) ∂(Kernel.condKernel κ (a, b)) ∂(Kernel.fst κ a)\n      = ∫⁻ x in Set.univ ×ˢ t, f x ∂(κ a) := by\n  rw [← setLIntegral_condKernel hf a MeasurableSet.univ ht]; simp_rw [Measure.restrict_univ]\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.integral_kernel_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝² : ProbabilityTheory.IsFiniteKernel κ\nE : Type u_4\nf : Prod β Ω → E\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na : α\nhf : MeasureTheory.AEStronglyMeasurable f (κ a)\n⊢ MeasureTheory.AEStronglyMeasurable (fun x => MeasureTheory.integral (κ.condKernel { fst := a, snd := x }) fun y => f { fst := x, snd := y }) (κ.fst a)","decl":"lemma _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_condKernel (a : α)\n    (hf : AEStronglyMeasurable f (κ a)) :\n    AEStronglyMeasurable (fun x ↦ ∫ y, f (x, y) ∂(Kernel.condKernel κ (a, x)))\n      (Kernel.fst κ a) := by\n  rw [← κ.disintegrate κ.condKernel] at hf\n  exact AEStronglyMeasurable.integral_kernel_compProd hf\n\n"}
{"name":"ProbabilityTheory.integral_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝² : ProbabilityTheory.IsFiniteKernel κ\nE : Type u_4\nf : Prod β Ω → E\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na : α\nhf : MeasureTheory.Integrable f (κ a)\n⊢ Eq (MeasureTheory.integral (κ.fst a) fun b => MeasureTheory.integral (κ.condKernel { fst := a, snd := b }) fun ω => f { fst := b, snd := ω }) (MeasureTheory.integral (κ a) fun x => f x)","decl":"lemma integral_condKernel (a : α) (hf : Integrable f (κ a)) :\n    ∫ b, ∫ ω, f (b, ω) ∂(Kernel.condKernel κ (a, b)) ∂(Kernel.fst κ a) = ∫ x, f x ∂(κ a) := by\n  conv_rhs => rw [← κ.disintegrate κ.condKernel]\n  rw [← κ.disintegrate κ.condKernel] at hf\n  rw [integral_compProd hf]\n\n"}
{"name":"ProbabilityTheory.setIntegral_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝² : ProbabilityTheory.IsFiniteKernel κ\nE : Type u_4\nf : Prod β Ω → E\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na : α\ns : Set β\nhs : MeasurableSet s\nt : Set Ω\nht : MeasurableSet t\nhf : MeasureTheory.IntegrableOn f (SProd.sprod s t) (κ a)\n⊢ Eq (MeasureTheory.integral ((κ.fst a).restrict s) fun b => MeasureTheory.integral ((κ.condKernel { fst := a, snd := b }).restrict t) fun ω => f { fst := b, snd := ω }) (MeasureTheory.integral ((κ a).restrict (SProd.sprod s t)) fun x => f x)","decl":"lemma setIntegral_condKernel (a : α) {s : Set β} (hs : MeasurableSet s)\n    {t : Set Ω} (ht : MeasurableSet t) (hf : IntegrableOn f (s ×ˢ t) (κ a)) :\n    ∫ b in s, ∫ ω in t, f (b, ω) ∂(Kernel.condKernel κ (a, b)) ∂(Kernel.fst κ a)\n      = ∫ x in s ×ˢ t, f x ∂(κ a) := by\n  conv_rhs => rw [← κ.disintegrate κ.condKernel]\n  rw [← κ.disintegrate κ.condKernel] at hf\n  rw [setIntegral_compProd hs ht hf]\n\n"}
{"name":"ProbabilityTheory.setIntegral_condKernel_univ_right","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝² : ProbabilityTheory.IsFiniteKernel κ\nE : Type u_4\nf : Prod β Ω → E\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na : α\ns : Set β\nhs : MeasurableSet s\nhf : MeasureTheory.IntegrableOn f (SProd.sprod s Set.univ) (κ a)\n⊢ Eq (MeasureTheory.integral ((κ.fst a).restrict s) fun b => MeasureTheory.integral (κ.condKernel { fst := a, snd := b }) fun ω => f { fst := b, snd := ω }) (MeasureTheory.integral ((κ a).restrict (SProd.sprod s Set.univ)) fun x => f x)","decl":"lemma setIntegral_condKernel_univ_right (a : α) {s : Set β} (hs : MeasurableSet s)\n    (hf : IntegrableOn f (s ×ˢ Set.univ) (κ a)) :\n    ∫ b in s, ∫ ω, f (b, ω) ∂(Kernel.condKernel κ (a, b)) ∂(Kernel.fst κ a)\n      = ∫ x in s ×ˢ Set.univ, f x ∂(κ a) := by\n  rw [← setIntegral_condKernel a hs MeasurableSet.univ hf]; simp_rw [Measure.restrict_univ]\n\n"}
{"name":"ProbabilityTheory.setIntegral_condKernel_univ_left","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : MeasurableSpace.CountableOrCountablyGenerated α β\nκ : ProbabilityTheory.Kernel α (Prod β Ω)\ninst✝² : ProbabilityTheory.IsFiniteKernel κ\nE : Type u_4\nf : Prod β Ω → E\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\na : α\nt : Set Ω\nht : MeasurableSet t\nhf : MeasureTheory.IntegrableOn f (SProd.sprod Set.univ t) (κ a)\n⊢ Eq (MeasureTheory.integral (κ.fst a) fun b => MeasureTheory.integral ((κ.condKernel { fst := a, snd := b }).restrict t) fun ω => f { fst := b, snd := ω }) (MeasureTheory.integral ((κ a).restrict (SProd.sprod Set.univ t)) fun x => f x)","decl":"lemma setIntegral_condKernel_univ_left (a : α) {t : Set Ω} (ht : MeasurableSet t)\n    (hf : IntegrableOn f (Set.univ ×ˢ t) (κ a)) :\n    ∫ b, ∫ ω in t, f (b, ω) ∂(Kernel.condKernel κ (a, b)) ∂(Kernel.fst κ a)\n      = ∫ x in Set.univ ×ˢ t, f x ∂(κ a) := by\n  rw [← setIntegral_condKernel a MeasurableSet.univ ht hf]; simp_rw [Measure.restrict_univ]\n\n"}
{"name":"MeasureTheory.Measure.lintegral_condKernel_mem","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"β : Type u_1\nΩ : Type u_2\nmβ : MeasurableSpace β\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod β Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\ns : Set (Prod β Ω)\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.lintegral ρ.fst fun x => (ρ.condKernel x) (setOf fun y => Membership.mem s { fst := x, snd := y })) (ρ s)","decl":"lemma lintegral_condKernel_mem {s : Set (β × Ω)} (hs : MeasurableSet s) :\n    ∫⁻ x, ρ.condKernel x {y | (x, y) ∈ s} ∂ρ.fst = ρ s := by\n  conv_rhs => rw [← ρ.disintegrate ρ.condKernel]\n  simp_rw [compProd_apply hs]\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.setLIntegral_condKernel_eq_measure_prod","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"β : Type u_1\nΩ : Type u_2\nmβ : MeasurableSpace β\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod β Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\ns : Set β\nhs : MeasurableSet s\nt : Set Ω\nht : MeasurableSet t\n⊢ Eq (MeasureTheory.lintegral (ρ.fst.restrict s) fun b => (ρ.condKernel b) t) (ρ (SProd.sprod s t))","decl":"lemma setLIntegral_condKernel_eq_measure_prod {s : Set β} (hs : MeasurableSet s) {t : Set Ω}\n    (ht : MeasurableSet t) :\n    ∫⁻ b in s, ρ.condKernel b t ∂ρ.fst = ρ (s ×ˢ t) := by\n  have : ρ (s ×ˢ t) = (ρ.fst ⊗ₘ ρ.condKernel) (s ×ˢ t) := by\n    congr; exact (ρ.disintegrate _).symm\n  rw [this, compProd_apply (hs.prod ht)]\n  classical\n  have : ∀ b, ρ.condKernel b (Prod.mk b ⁻¹' s ×ˢ t)\n      = s.indicator (fun b ↦ ρ.condKernel b t) b := by\n    intro b\n    by_cases hb : b ∈ s <;> simp [hb]\n  simp_rw [this]\n  rw [lintegral_indicator hs]\n\n"}
{"name":"MeasureTheory.Measure.lintegral_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"β : Type u_1\nΩ : Type u_2\nmβ : MeasurableSpace β\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod β Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\nf : Prod β Ω → ENNReal\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral ρ.fst fun b => MeasureTheory.lintegral (ρ.condKernel b) fun ω => f { fst := b, snd := ω }) (MeasureTheory.lintegral ρ fun x => f x)","decl":"lemma lintegral_condKernel (hf : Measurable f) :\n    ∫⁻ b, ∫⁻ ω, f (b, ω) ∂(ρ.condKernel b) ∂ρ.fst = ∫⁻ x, f x ∂ρ := by\n  conv_rhs => rw [← ρ.disintegrate ρ.condKernel]\n  rw [lintegral_compProd hf]\n\n"}
{"name":"MeasureTheory.Measure.setLIntegral_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"β : Type u_1\nΩ : Type u_2\nmβ : MeasurableSpace β\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod β Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\nf : Prod β Ω → ENNReal\nhf : Measurable f\ns : Set β\nhs : MeasurableSet s\nt : Set Ω\nht : MeasurableSet t\n⊢ Eq (MeasureTheory.lintegral (ρ.fst.restrict s) fun b => MeasureTheory.lintegral ((ρ.condKernel b).restrict t) fun ω => f { fst := b, snd := ω }) (MeasureTheory.lintegral (ρ.restrict (SProd.sprod s t)) fun x => f x)","decl":"lemma setLIntegral_condKernel (hf : Measurable f) {s : Set β}\n    (hs : MeasurableSet s) {t : Set Ω} (ht : MeasurableSet t) :\n    ∫⁻ b in s, ∫⁻ ω in t, f (b, ω) ∂(ρ.condKernel b) ∂ρ.fst\n      = ∫⁻ x in s ×ˢ t, f x ∂ρ := by\n  conv_rhs => rw [← ρ.disintegrate ρ.condKernel]\n  rw [setLIntegral_compProd hf hs ht]\n\n"}
{"name":"MeasureTheory.Measure.setLIntegral_condKernel_univ_right","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"β : Type u_1\nΩ : Type u_2\nmβ : MeasurableSpace β\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod β Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\nf : Prod β Ω → ENNReal\nhf : Measurable f\ns : Set β\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.lintegral (ρ.fst.restrict s) fun b => MeasureTheory.lintegral (ρ.condKernel b) fun ω => f { fst := b, snd := ω }) (MeasureTheory.lintegral (ρ.restrict (SProd.sprod s Set.univ)) fun x => f x)","decl":"lemma setLIntegral_condKernel_univ_right (hf : Measurable f) {s : Set β}\n    (hs : MeasurableSet s) :\n    ∫⁻ b in s, ∫⁻ ω, f (b, ω) ∂(ρ.condKernel b) ∂ρ.fst\n      = ∫⁻ x in s ×ˢ Set.univ, f x ∂ρ := by\n  rw [← setLIntegral_condKernel hf hs MeasurableSet.univ]; simp_rw [Measure.restrict_univ]\n\n"}
{"name":"MeasureTheory.Measure.setLIntegral_condKernel_univ_left","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"β : Type u_1\nΩ : Type u_2\nmβ : MeasurableSpace β\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod β Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\nf : Prod β Ω → ENNReal\nhf : Measurable f\nt : Set Ω\nht : MeasurableSet t\n⊢ Eq (MeasureTheory.lintegral ρ.fst fun b => MeasureTheory.lintegral ((ρ.condKernel b).restrict t) fun ω => f { fst := b, snd := ω }) (MeasureTheory.lintegral (ρ.restrict (SProd.sprod Set.univ t)) fun x => f x)","decl":"lemma setLIntegral_condKernel_univ_left (hf : Measurable f) {t : Set Ω}\n    (ht : MeasurableSet t) :\n    ∫⁻ b, ∫⁻ ω in t, f (b, ω) ∂(ρ.condKernel b) ∂ρ.fst\n      = ∫⁻ x in Set.univ ×ˢ t, f x ∂ρ := by\n  rw [← setLIntegral_condKernel hf MeasurableSet.univ ht]; simp_rw [Measure.restrict_univ]\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.integral_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"β : Type u_1\nΩ : Type u_2\nmβ : MeasurableSpace β\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod β Ω)\ninst✝² : MeasureTheory.IsFiniteMeasure ρ\nE : Type u_3\nf : Prod β Ω → E\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nhf : MeasureTheory.AEStronglyMeasurable f ρ\n⊢ MeasureTheory.AEStronglyMeasurable (fun x => MeasureTheory.integral (ρ.condKernel x) fun y => f { fst := x, snd := y }) ρ.fst","decl":"lemma _root_.MeasureTheory.AEStronglyMeasurable.integral_condKernel\n    (hf : AEStronglyMeasurable f ρ) :\n    AEStronglyMeasurable (fun x ↦ ∫ y, f (x, y) ∂ρ.condKernel x) ρ.fst := by\n  rw [← ρ.disintegrate ρ.condKernel] at hf\n  exact AEStronglyMeasurable.integral_kernel_compProd hf\n\n"}
{"name":"MeasureTheory.Measure.integral_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"β : Type u_1\nΩ : Type u_2\nmβ : MeasurableSpace β\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod β Ω)\ninst✝² : MeasureTheory.IsFiniteMeasure ρ\nE : Type u_3\nf : Prod β Ω → E\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nhf : MeasureTheory.Integrable f ρ\n⊢ Eq (MeasureTheory.integral ρ.fst fun b => MeasureTheory.integral (ρ.condKernel b) fun ω => f { fst := b, snd := ω }) (MeasureTheory.integral ρ fun x => f x)","decl":"lemma integral_condKernel (hf : Integrable f ρ) :\n    ∫ b, ∫ ω, f (b, ω) ∂(ρ.condKernel b) ∂ρ.fst = ∫ x, f x ∂ρ := by\n  conv_rhs => rw [← ρ.disintegrate ρ.condKernel]\n  rw [← ρ.disintegrate ρ.condKernel] at hf\n  rw [integral_compProd hf]\n\n"}
{"name":"MeasureTheory.Measure.setIntegral_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"β : Type u_1\nΩ : Type u_2\nmβ : MeasurableSpace β\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod β Ω)\ninst✝² : MeasureTheory.IsFiniteMeasure ρ\nE : Type u_3\nf : Prod β Ω → E\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ns : Set β\nhs : MeasurableSet s\nt : Set Ω\nht : MeasurableSet t\nhf : MeasureTheory.IntegrableOn f (SProd.sprod s t) ρ\n⊢ Eq (MeasureTheory.integral (ρ.fst.restrict s) fun b => MeasureTheory.integral ((ρ.condKernel b).restrict t) fun ω => f { fst := b, snd := ω }) (MeasureTheory.integral (ρ.restrict (SProd.sprod s t)) fun x => f x)","decl":"lemma setIntegral_condKernel {s : Set β} (hs : MeasurableSet s)\n    {t : Set Ω} (ht : MeasurableSet t) (hf : IntegrableOn f (s ×ˢ t) ρ) :\n    ∫ b in s, ∫ ω in t, f (b, ω) ∂(ρ.condKernel b) ∂ρ.fst = ∫ x in s ×ˢ t, f x ∂ρ := by\n  conv_rhs => rw [← ρ.disintegrate ρ.condKernel]\n  rw [← ρ.disintegrate ρ.condKernel] at hf\n  rw [setIntegral_compProd hs ht hf]\n\n"}
{"name":"MeasureTheory.Measure.setIntegral_condKernel_univ_right","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"β : Type u_1\nΩ : Type u_2\nmβ : MeasurableSpace β\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod β Ω)\ninst✝² : MeasureTheory.IsFiniteMeasure ρ\nE : Type u_3\nf : Prod β Ω → E\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ns : Set β\nhs : MeasurableSet s\nhf : MeasureTheory.IntegrableOn f (SProd.sprod s Set.univ) ρ\n⊢ Eq (MeasureTheory.integral (ρ.fst.restrict s) fun b => MeasureTheory.integral (ρ.condKernel b) fun ω => f { fst := b, snd := ω }) (MeasureTheory.integral (ρ.restrict (SProd.sprod s Set.univ)) fun x => f x)","decl":"lemma setIntegral_condKernel_univ_right {s : Set β} (hs : MeasurableSet s)\n    (hf : IntegrableOn f (s ×ˢ Set.univ) ρ) :\n    ∫ b in s, ∫ ω, f (b, ω) ∂(ρ.condKernel b) ∂ρ.fst = ∫ x in s ×ˢ Set.univ, f x ∂ρ := by\n  rw [← setIntegral_condKernel hs MeasurableSet.univ hf]; simp_rw [Measure.restrict_univ]\n\n"}
{"name":"MeasureTheory.Measure.setIntegral_condKernel_univ_left","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"β : Type u_1\nΩ : Type u_2\nmβ : MeasurableSpace β\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\nρ : MeasureTheory.Measure (Prod β Ω)\ninst✝² : MeasureTheory.IsFiniteMeasure ρ\nE : Type u_3\nf : Prod β Ω → E\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nt : Set Ω\nht : MeasurableSet t\nhf : MeasureTheory.IntegrableOn f (SProd.sprod Set.univ t) ρ\n⊢ Eq (MeasureTheory.integral ρ.fst fun b => MeasureTheory.integral ((ρ.condKernel b).restrict t) fun ω => f { fst := b, snd := ω }) (MeasureTheory.integral (ρ.restrict (SProd.sprod Set.univ t)) fun x => f x)","decl":"lemma setIntegral_condKernel_univ_left {t : Set Ω} (ht : MeasurableSet t)\n    (hf : IntegrableOn f (Set.univ ×ˢ t) ρ) :\n    ∫ b, ∫ ω in t, f (b, ω) ∂(ρ.condKernel b) ∂ρ.fst = ∫ x in Set.univ ×ˢ t, f x ∂ρ := by\n  rw [← setIntegral_condKernel MeasurableSet.univ ht hf]; simp_rw [Measure.restrict_univ]\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.ae_integrable_condKernel_iff","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nΩ : Type u_2\nF : Type u_4\nmα : MeasurableSpace α\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : NormedAddCommGroup F\nρ : MeasureTheory.Measure (Prod α Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\nf : Prod α Ω → F\nhf : MeasureTheory.AEStronglyMeasurable f ρ\n⊢ Iff (And (Filter.Eventually (fun a => MeasureTheory.Integrable (fun ω => f { fst := a, snd := ω }) (ρ.condKernel a)) (MeasureTheory.ae ρ.fst)) (MeasureTheory.Integrable (fun a => MeasureTheory.integral (ρ.condKernel a) fun ω => Norm.norm (f { fst := a, snd := ω })) ρ.fst)) (MeasureTheory.Integrable f ρ)","decl":"theorem AEStronglyMeasurable.ae_integrable_condKernel_iff {f : α × Ω → F}\n    (hf : AEStronglyMeasurable f ρ) :\n    (∀ᵐ a ∂ρ.fst, Integrable (fun ω ↦ f (a, ω)) (ρ.condKernel a)) ∧\n      Integrable (fun a ↦ ∫ ω, ‖f (a, ω)‖ ∂ρ.condKernel a) ρ.fst ↔ Integrable f ρ := by\n  rw [← ρ.disintegrate ρ.condKernel] at hf\n  conv_rhs => rw [← ρ.disintegrate ρ.condKernel]\n  rw [Measure.integrable_compProd_iff hf]\n\n"}
{"name":"MeasureTheory.Integrable.condKernel_ae","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nΩ : Type u_2\nF : Type u_4\nmα : MeasurableSpace α\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : NormedAddCommGroup F\nρ : MeasureTheory.Measure (Prod α Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\nf : Prod α Ω → F\nhf_int : MeasureTheory.Integrable f ρ\n⊢ Filter.Eventually (fun a => MeasureTheory.Integrable (fun ω => f { fst := a, snd := ω }) (ρ.condKernel a)) (MeasureTheory.ae ρ.fst)","decl":"theorem Integrable.condKernel_ae {f : α × Ω → F} (hf_int : Integrable f ρ) :\n    ∀ᵐ a ∂ρ.fst, Integrable (fun ω ↦ f (a, ω)) (ρ.condKernel a) := by\n  have hf_ae : AEStronglyMeasurable f ρ := hf_int.1\n  rw [← hf_ae.ae_integrable_condKernel_iff] at hf_int\n  exact hf_int.1\n\n"}
{"name":"MeasureTheory.Integrable.integral_norm_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nΩ : Type u_2\nF : Type u_4\nmα : MeasurableSpace α\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : NormedAddCommGroup F\nρ : MeasureTheory.Measure (Prod α Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\nf : Prod α Ω → F\nhf_int : MeasureTheory.Integrable f ρ\n⊢ MeasureTheory.Integrable (fun x => MeasureTheory.integral (ρ.condKernel x) fun y => Norm.norm (f { fst := x, snd := y })) ρ.fst","decl":"theorem Integrable.integral_norm_condKernel {f : α × Ω → F} (hf_int : Integrable f ρ) :\n    Integrable (fun x ↦ ∫ y, ‖f (x, y)‖ ∂ρ.condKernel x) ρ.fst := by\n  have hf_ae : AEStronglyMeasurable f ρ := hf_int.1\n  rw [← hf_ae.ae_integrable_condKernel_iff] at hf_int\n  exact hf_int.2\n\n"}
{"name":"MeasureTheory.Integrable.norm_integral_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nΩ : Type u_2\nE : Type u_3\nmα : MeasurableSpace α\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nρ : MeasureTheory.Measure (Prod α Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\nf : Prod α Ω → E\nhf_int : MeasureTheory.Integrable f ρ\n⊢ MeasureTheory.Integrable (fun x => Norm.norm (MeasureTheory.integral (ρ.condKernel x) fun y => f { fst := x, snd := y })) ρ.fst","decl":"theorem Integrable.norm_integral_condKernel {f : α × Ω → E} (hf_int : Integrable f ρ) :\n    Integrable (fun x ↦ ‖∫ y, f (x, y) ∂ρ.condKernel x‖) ρ.fst := by\n  refine hf_int.integral_norm_condKernel.mono hf_int.1.integral_condKernel.norm ?_\n  refine Filter.Eventually.of_forall fun x ↦ ?_\n  rw [norm_norm]\n  refine (norm_integral_le_integral_norm _).trans_eq (Real.norm_of_nonneg ?_).symm\n  exact integral_nonneg_of_ae (Filter.Eventually.of_forall fun y ↦ norm_nonneg _)\n\n"}
{"name":"MeasureTheory.Integrable.integral_condKernel","module":"Mathlib.Probability.Kernel.Disintegration.Integral","initialProofState":"α : Type u_1\nΩ : Type u_2\nE : Type u_3\nmα : MeasurableSpace α\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nρ : MeasureTheory.Measure (Prod α Ω)\ninst✝ : MeasureTheory.IsFiniteMeasure ρ\nf : Prod α Ω → E\nhf_int : MeasureTheory.Integrable f ρ\n⊢ MeasureTheory.Integrable (fun x => MeasureTheory.integral (ρ.condKernel x) fun y => f { fst := x, snd := y }) ρ.fst","decl":"theorem Integrable.integral_condKernel {f : α × Ω → E} (hf_int : Integrable f ρ) :\n    Integrable (fun x ↦ ∫ y, f (x, y) ∂ρ.condKernel x) ρ.fst :=\n  (integrable_norm_iff hf_int.1.integral_condKernel).mp hf_int.norm_integral_condKernel\n\n"}
