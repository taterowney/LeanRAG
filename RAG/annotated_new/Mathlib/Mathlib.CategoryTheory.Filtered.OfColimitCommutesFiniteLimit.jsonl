{"name":"CategoryTheory.isFiltered_of_nonempty_limit_colimit_to_colimit_limit","module":"Mathlib.CategoryTheory.Filtered.OfColimitCommutesFiniteLimit","initialProofState":"K : Type v\ninst✝ : CategoryTheory.SmallCategory K\nh : ∀ {J : Type v} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] (F : CategoryTheory.Functor J (CategoryTheory.Functor K (Type v))), Nonempty (Quiver.Hom (CategoryTheory.Limits.limit (CategoryTheory.Limits.colimit F.flip)) (CategoryTheory.Limits.colimit (CategoryTheory.Limits.limit F)))\n⊢ CategoryTheory.IsFiltered K","decl":"/-- A converse to `colimitLimitIso`: if colimits of shape `K` commute with finite\nlimits, then `K` is filtered. -/\ntheorem isFiltered_of_nonempty_limit_colimit_to_colimit_limit\n    (h : ∀ {J : Type v} [SmallCategory J] [FinCategory J] (F : J ⥤ K ⥤ Type v),\n      Nonempty (limit (colimit F.flip) ⟶ colimit (limit F))) : IsFiltered K := by\n  refine IsFiltered.iff_nonempty_limit.2 (fun {J} _ _ F => ?_)\n  suffices Nonempty (limit (colimit (F.op ⋙ coyoneda).flip)) by\n    obtain ⟨X, y, -⟩ := Types.jointly_surjective' (this.map (h (F.op ⋙ coyoneda)).some).some\n    exact ⟨X, ⟨(limitObjIsoLimitCompEvaluation (F.op ⋙ coyoneda) _).hom y⟩⟩\n  let _ (j : Jᵒᵖ) : Unique ((colimit (F.op ⋙ coyoneda).flip).obj j) :=\n    ((colimitObjIsoColimitCompEvaluation (F.op ⋙ coyoneda).flip _ ≪≫\n      Coyoneda.colimitCoyonedaIso _)).toEquiv.unique\n  exact ⟨Types.Limit.mk (colimit (F.op ⋙ coyoneda).flip) (fun j => default) (by subsingleton)⟩\n\n"}
