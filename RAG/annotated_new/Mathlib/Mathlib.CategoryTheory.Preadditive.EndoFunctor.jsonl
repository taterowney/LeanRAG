{"name":"CategoryTheory.Endofunctor.algebraPreadditive_homGroup_neg_f","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\nA₁ A₂ : CategoryTheory.Endofunctor.Algebra F\nα : Quiver.Hom A₁ A₂\n⊢ Eq (Neg.neg α).f (Neg.neg α.f)","decl":"/-- The category of algebras over an additive endofunctor on a preadditive category is preadditive.\n-/\n@[simps]\ninstance Endofunctor.algebraPreadditive : Preadditive (Endofunctor.Algebra F) where\n  homGroup A₁ A₂ :=\n    { add := fun α β =>\n        { f := α.f + β.f\n          h := by simp only [Functor.map_add, add_comp, Endofunctor.Algebra.Hom.h, comp_add] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n α =>\n        { f := n • α.f\n          h := by rw [comp_nsmul, Functor.map_nsmul, nsmul_comp, Endofunctor.Algebra.Hom.h] }\n      neg := fun α =>\n        { f := -α.f\n          h := by simp only [Functor.map_neg, neg_comp, Endofunctor.Algebra.Hom.h, comp_neg] }\n      sub := fun α β =>\n        { f := α.f - β.f\n          h := by simp only [Functor.map_sub, sub_comp, Endofunctor.Algebra.Hom.h, comp_sub] }\n      zsmul := fun r α =>\n        { f := r • α.f\n          h := by rw [comp_zsmul, Functor.map_zsmul, zsmul_comp, Endofunctor.Algebra.Hom.h] }\n      add_assoc := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Algebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Algebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Algebra.Hom.ext\n        simp only [natCast_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Algebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, ← Nat.cast_smul_eq_nsmul ℤ]\n      neg_add_cancel := by\n        intros\n        apply Algebra.Hom.ext\n        apply neg_add_cancel\n      add_comm := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Algebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Algebra.Hom.ext\n    apply comp_add\n\n"}
{"name":"CategoryTheory.Endofunctor.algebraPreadditive_homGroup_zsmul_f","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\nA₁ A₂ : CategoryTheory.Endofunctor.Algebra F\nr : Int\nα : Quiver.Hom A₁ A₂\n⊢ Eq (HSMul.hSMul r α).f (HSMul.hSMul r α.f)","decl":"/-- The category of algebras over an additive endofunctor on a preadditive category is preadditive.\n-/\n@[simps]\ninstance Endofunctor.algebraPreadditive : Preadditive (Endofunctor.Algebra F) where\n  homGroup A₁ A₂ :=\n    { add := fun α β =>\n        { f := α.f + β.f\n          h := by simp only [Functor.map_add, add_comp, Endofunctor.Algebra.Hom.h, comp_add] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n α =>\n        { f := n • α.f\n          h := by rw [comp_nsmul, Functor.map_nsmul, nsmul_comp, Endofunctor.Algebra.Hom.h] }\n      neg := fun α =>\n        { f := -α.f\n          h := by simp only [Functor.map_neg, neg_comp, Endofunctor.Algebra.Hom.h, comp_neg] }\n      sub := fun α β =>\n        { f := α.f - β.f\n          h := by simp only [Functor.map_sub, sub_comp, Endofunctor.Algebra.Hom.h, comp_sub] }\n      zsmul := fun r α =>\n        { f := r • α.f\n          h := by rw [comp_zsmul, Functor.map_zsmul, zsmul_comp, Endofunctor.Algebra.Hom.h] }\n      add_assoc := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Algebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Algebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Algebra.Hom.ext\n        simp only [natCast_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Algebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, ← Nat.cast_smul_eq_nsmul ℤ]\n      neg_add_cancel := by\n        intros\n        apply Algebra.Hom.ext\n        apply neg_add_cancel\n      add_comm := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Algebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Algebra.Hom.ext\n    apply comp_add\n\n"}
{"name":"CategoryTheory.Endofunctor.algebraPreadditive_homGroup_zero_f","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\nA₁ A₂ : CategoryTheory.Endofunctor.Algebra F\n⊢ Eq (CategoryTheory.Endofunctor.Algebra.Hom.f 0) 0","decl":"/-- The category of algebras over an additive endofunctor on a preadditive category is preadditive.\n-/\n@[simps]\ninstance Endofunctor.algebraPreadditive : Preadditive (Endofunctor.Algebra F) where\n  homGroup A₁ A₂ :=\n    { add := fun α β =>\n        { f := α.f + β.f\n          h := by simp only [Functor.map_add, add_comp, Endofunctor.Algebra.Hom.h, comp_add] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n α =>\n        { f := n • α.f\n          h := by rw [comp_nsmul, Functor.map_nsmul, nsmul_comp, Endofunctor.Algebra.Hom.h] }\n      neg := fun α =>\n        { f := -α.f\n          h := by simp only [Functor.map_neg, neg_comp, Endofunctor.Algebra.Hom.h, comp_neg] }\n      sub := fun α β =>\n        { f := α.f - β.f\n          h := by simp only [Functor.map_sub, sub_comp, Endofunctor.Algebra.Hom.h, comp_sub] }\n      zsmul := fun r α =>\n        { f := r • α.f\n          h := by rw [comp_zsmul, Functor.map_zsmul, zsmul_comp, Endofunctor.Algebra.Hom.h] }\n      add_assoc := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Algebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Algebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Algebra.Hom.ext\n        simp only [natCast_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Algebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, ← Nat.cast_smul_eq_nsmul ℤ]\n      neg_add_cancel := by\n        intros\n        apply Algebra.Hom.ext\n        apply neg_add_cancel\n      add_comm := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Algebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Algebra.Hom.ext\n    apply comp_add\n\n"}
{"name":"CategoryTheory.Endofunctor.algebraPreadditive_homGroup_add_f","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\nA₁ A₂ : CategoryTheory.Endofunctor.Algebra F\nα β : Quiver.Hom A₁ A₂\n⊢ Eq (HAdd.hAdd α β).f (HAdd.hAdd α.f β.f)","decl":"/-- The category of algebras over an additive endofunctor on a preadditive category is preadditive.\n-/\n@[simps]\ninstance Endofunctor.algebraPreadditive : Preadditive (Endofunctor.Algebra F) where\n  homGroup A₁ A₂ :=\n    { add := fun α β =>\n        { f := α.f + β.f\n          h := by simp only [Functor.map_add, add_comp, Endofunctor.Algebra.Hom.h, comp_add] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n α =>\n        { f := n • α.f\n          h := by rw [comp_nsmul, Functor.map_nsmul, nsmul_comp, Endofunctor.Algebra.Hom.h] }\n      neg := fun α =>\n        { f := -α.f\n          h := by simp only [Functor.map_neg, neg_comp, Endofunctor.Algebra.Hom.h, comp_neg] }\n      sub := fun α β =>\n        { f := α.f - β.f\n          h := by simp only [Functor.map_sub, sub_comp, Endofunctor.Algebra.Hom.h, comp_sub] }\n      zsmul := fun r α =>\n        { f := r • α.f\n          h := by rw [comp_zsmul, Functor.map_zsmul, zsmul_comp, Endofunctor.Algebra.Hom.h] }\n      add_assoc := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Algebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Algebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Algebra.Hom.ext\n        simp only [natCast_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Algebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, ← Nat.cast_smul_eq_nsmul ℤ]\n      neg_add_cancel := by\n        intros\n        apply Algebra.Hom.ext\n        apply neg_add_cancel\n      add_comm := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Algebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Algebra.Hom.ext\n    apply comp_add\n\n"}
{"name":"CategoryTheory.Endofunctor.algebraPreadditive_homGroup_sub_f","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\nA₁ A₂ : CategoryTheory.Endofunctor.Algebra F\nα β : Quiver.Hom A₁ A₂\n⊢ Eq (HSub.hSub α β).f (HSub.hSub α.f β.f)","decl":"/-- The category of algebras over an additive endofunctor on a preadditive category is preadditive.\n-/\n@[simps]\ninstance Endofunctor.algebraPreadditive : Preadditive (Endofunctor.Algebra F) where\n  homGroup A₁ A₂ :=\n    { add := fun α β =>\n        { f := α.f + β.f\n          h := by simp only [Functor.map_add, add_comp, Endofunctor.Algebra.Hom.h, comp_add] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n α =>\n        { f := n • α.f\n          h := by rw [comp_nsmul, Functor.map_nsmul, nsmul_comp, Endofunctor.Algebra.Hom.h] }\n      neg := fun α =>\n        { f := -α.f\n          h := by simp only [Functor.map_neg, neg_comp, Endofunctor.Algebra.Hom.h, comp_neg] }\n      sub := fun α β =>\n        { f := α.f - β.f\n          h := by simp only [Functor.map_sub, sub_comp, Endofunctor.Algebra.Hom.h, comp_sub] }\n      zsmul := fun r α =>\n        { f := r • α.f\n          h := by rw [comp_zsmul, Functor.map_zsmul, zsmul_comp, Endofunctor.Algebra.Hom.h] }\n      add_assoc := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Algebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Algebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Algebra.Hom.ext\n        simp only [natCast_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Algebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, ← Nat.cast_smul_eq_nsmul ℤ]\n      neg_add_cancel := by\n        intros\n        apply Algebra.Hom.ext\n        apply neg_add_cancel\n      add_comm := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Algebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Algebra.Hom.ext\n    apply comp_add\n\n"}
{"name":"CategoryTheory.Endofunctor.algebraPreadditive_homGroup_nsmul_f","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\nA₁ A₂ : CategoryTheory.Endofunctor.Algebra F\nn : Nat\nα : Quiver.Hom A₁ A₂\n⊢ Eq (HSMul.hSMul n α).f (HSMul.hSMul n α.f)","decl":"/-- The category of algebras over an additive endofunctor on a preadditive category is preadditive.\n-/\n@[simps]\ninstance Endofunctor.algebraPreadditive : Preadditive (Endofunctor.Algebra F) where\n  homGroup A₁ A₂ :=\n    { add := fun α β =>\n        { f := α.f + β.f\n          h := by simp only [Functor.map_add, add_comp, Endofunctor.Algebra.Hom.h, comp_add] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n α =>\n        { f := n • α.f\n          h := by rw [comp_nsmul, Functor.map_nsmul, nsmul_comp, Endofunctor.Algebra.Hom.h] }\n      neg := fun α =>\n        { f := -α.f\n          h := by simp only [Functor.map_neg, neg_comp, Endofunctor.Algebra.Hom.h, comp_neg] }\n      sub := fun α β =>\n        { f := α.f - β.f\n          h := by simp only [Functor.map_sub, sub_comp, Endofunctor.Algebra.Hom.h, comp_sub] }\n      zsmul := fun r α =>\n        { f := r • α.f\n          h := by rw [comp_zsmul, Functor.map_zsmul, zsmul_comp, Endofunctor.Algebra.Hom.h] }\n      add_assoc := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Algebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Algebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Algebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Algebra.Hom.ext\n        simp only [natCast_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Algebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, ← Nat.cast_smul_eq_nsmul ℤ]\n      neg_add_cancel := by\n        intros\n        apply Algebra.Hom.ext\n        apply neg_add_cancel\n      add_comm := by\n        intros\n        apply Algebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Algebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Algebra.Hom.ext\n    apply comp_add\n\n"}
{"name":"CategoryTheory.Algebra.forget_additive","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\n⊢ (CategoryTheory.Endofunctor.Algebra.forget F).Additive","decl":"instance Algebra.forget_additive : (Endofunctor.Algebra.forget F).Additive where\n\n"}
{"name":"CategoryTheory.Endofunctor.coalgebraPreadditive_homGroup_add_f","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\nA₁ A₂ : CategoryTheory.Endofunctor.Coalgebra F\nα β : Quiver.Hom A₁ A₂\n⊢ Eq (HAdd.hAdd α β).f (HAdd.hAdd α.f β.f)","decl":"@[simps]\ninstance Endofunctor.coalgebraPreadditive : Preadditive (Endofunctor.Coalgebra F) where\n  homGroup A₁ A₂ :=\n    { add := fun α β =>\n        { f := α.f + β.f\n          h := by simp only [Functor.map_add, comp_add, Endofunctor.Coalgebra.Hom.h, add_comp] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n α =>\n        { f := n • α.f\n          h := by rw [Functor.map_nsmul, comp_nsmul, Endofunctor.Coalgebra.Hom.h, nsmul_comp] }\n      neg := fun α =>\n        { f := -α.f\n          h := by simp only [Functor.map_neg, comp_neg, Endofunctor.Coalgebra.Hom.h, neg_comp] }\n      sub := fun α β =>\n        { f := α.f - β.f\n          h := by simp only [Functor.map_sub, comp_sub, Endofunctor.Coalgebra.Hom.h, sub_comp] }\n      zsmul := fun r α =>\n        { f := r • α.f\n          h := by rw [Functor.map_zsmul, comp_zsmul, Endofunctor.Coalgebra.Hom.h, zsmul_comp] }\n      add_assoc := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Coalgebra.Hom.ext\n        simp only [natCast_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Coalgebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, ← Nat.cast_smul_eq_nsmul ℤ]\n      neg_add_cancel := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply neg_add_cancel\n      add_comm := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply comp_add\n\n"}
{"name":"CategoryTheory.Endofunctor.coalgebraPreadditive_homGroup_zero_f","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\nA₁ A₂ : CategoryTheory.Endofunctor.Coalgebra F\n⊢ Eq (CategoryTheory.Endofunctor.Coalgebra.Hom.f 0) 0","decl":"@[simps]\ninstance Endofunctor.coalgebraPreadditive : Preadditive (Endofunctor.Coalgebra F) where\n  homGroup A₁ A₂ :=\n    { add := fun α β =>\n        { f := α.f + β.f\n          h := by simp only [Functor.map_add, comp_add, Endofunctor.Coalgebra.Hom.h, add_comp] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n α =>\n        { f := n • α.f\n          h := by rw [Functor.map_nsmul, comp_nsmul, Endofunctor.Coalgebra.Hom.h, nsmul_comp] }\n      neg := fun α =>\n        { f := -α.f\n          h := by simp only [Functor.map_neg, comp_neg, Endofunctor.Coalgebra.Hom.h, neg_comp] }\n      sub := fun α β =>\n        { f := α.f - β.f\n          h := by simp only [Functor.map_sub, comp_sub, Endofunctor.Coalgebra.Hom.h, sub_comp] }\n      zsmul := fun r α =>\n        { f := r • α.f\n          h := by rw [Functor.map_zsmul, comp_zsmul, Endofunctor.Coalgebra.Hom.h, zsmul_comp] }\n      add_assoc := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Coalgebra.Hom.ext\n        simp only [natCast_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Coalgebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, ← Nat.cast_smul_eq_nsmul ℤ]\n      neg_add_cancel := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply neg_add_cancel\n      add_comm := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply comp_add\n\n"}
{"name":"CategoryTheory.Endofunctor.coalgebraPreadditive_homGroup_nsmul_f","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\nA₁ A₂ : CategoryTheory.Endofunctor.Coalgebra F\nn : Nat\nα : Quiver.Hom A₁ A₂\n⊢ Eq (HSMul.hSMul n α).f (HSMul.hSMul n α.f)","decl":"@[simps]\ninstance Endofunctor.coalgebraPreadditive : Preadditive (Endofunctor.Coalgebra F) where\n  homGroup A₁ A₂ :=\n    { add := fun α β =>\n        { f := α.f + β.f\n          h := by simp only [Functor.map_add, comp_add, Endofunctor.Coalgebra.Hom.h, add_comp] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n α =>\n        { f := n • α.f\n          h := by rw [Functor.map_nsmul, comp_nsmul, Endofunctor.Coalgebra.Hom.h, nsmul_comp] }\n      neg := fun α =>\n        { f := -α.f\n          h := by simp only [Functor.map_neg, comp_neg, Endofunctor.Coalgebra.Hom.h, neg_comp] }\n      sub := fun α β =>\n        { f := α.f - β.f\n          h := by simp only [Functor.map_sub, comp_sub, Endofunctor.Coalgebra.Hom.h, sub_comp] }\n      zsmul := fun r α =>\n        { f := r • α.f\n          h := by rw [Functor.map_zsmul, comp_zsmul, Endofunctor.Coalgebra.Hom.h, zsmul_comp] }\n      add_assoc := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Coalgebra.Hom.ext\n        simp only [natCast_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Coalgebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, ← Nat.cast_smul_eq_nsmul ℤ]\n      neg_add_cancel := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply neg_add_cancel\n      add_comm := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply comp_add\n\n"}
{"name":"CategoryTheory.Endofunctor.coalgebraPreadditive_homGroup_neg_f","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\nA₁ A₂ : CategoryTheory.Endofunctor.Coalgebra F\nα : Quiver.Hom A₁ A₂\n⊢ Eq (Neg.neg α).f (Neg.neg α.f)","decl":"@[simps]\ninstance Endofunctor.coalgebraPreadditive : Preadditive (Endofunctor.Coalgebra F) where\n  homGroup A₁ A₂ :=\n    { add := fun α β =>\n        { f := α.f + β.f\n          h := by simp only [Functor.map_add, comp_add, Endofunctor.Coalgebra.Hom.h, add_comp] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n α =>\n        { f := n • α.f\n          h := by rw [Functor.map_nsmul, comp_nsmul, Endofunctor.Coalgebra.Hom.h, nsmul_comp] }\n      neg := fun α =>\n        { f := -α.f\n          h := by simp only [Functor.map_neg, comp_neg, Endofunctor.Coalgebra.Hom.h, neg_comp] }\n      sub := fun α β =>\n        { f := α.f - β.f\n          h := by simp only [Functor.map_sub, comp_sub, Endofunctor.Coalgebra.Hom.h, sub_comp] }\n      zsmul := fun r α =>\n        { f := r • α.f\n          h := by rw [Functor.map_zsmul, comp_zsmul, Endofunctor.Coalgebra.Hom.h, zsmul_comp] }\n      add_assoc := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Coalgebra.Hom.ext\n        simp only [natCast_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Coalgebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, ← Nat.cast_smul_eq_nsmul ℤ]\n      neg_add_cancel := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply neg_add_cancel\n      add_comm := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply comp_add\n\n"}
{"name":"CategoryTheory.Endofunctor.coalgebraPreadditive_homGroup_sub_f","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\nA₁ A₂ : CategoryTheory.Endofunctor.Coalgebra F\nα β : Quiver.Hom A₁ A₂\n⊢ Eq (HSub.hSub α β).f (HSub.hSub α.f β.f)","decl":"@[simps]\ninstance Endofunctor.coalgebraPreadditive : Preadditive (Endofunctor.Coalgebra F) where\n  homGroup A₁ A₂ :=\n    { add := fun α β =>\n        { f := α.f + β.f\n          h := by simp only [Functor.map_add, comp_add, Endofunctor.Coalgebra.Hom.h, add_comp] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n α =>\n        { f := n • α.f\n          h := by rw [Functor.map_nsmul, comp_nsmul, Endofunctor.Coalgebra.Hom.h, nsmul_comp] }\n      neg := fun α =>\n        { f := -α.f\n          h := by simp only [Functor.map_neg, comp_neg, Endofunctor.Coalgebra.Hom.h, neg_comp] }\n      sub := fun α β =>\n        { f := α.f - β.f\n          h := by simp only [Functor.map_sub, comp_sub, Endofunctor.Coalgebra.Hom.h, sub_comp] }\n      zsmul := fun r α =>\n        { f := r • α.f\n          h := by rw [Functor.map_zsmul, comp_zsmul, Endofunctor.Coalgebra.Hom.h, zsmul_comp] }\n      add_assoc := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Coalgebra.Hom.ext\n        simp only [natCast_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Coalgebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, ← Nat.cast_smul_eq_nsmul ℤ]\n      neg_add_cancel := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply neg_add_cancel\n      add_comm := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply comp_add\n\n"}
{"name":"CategoryTheory.Endofunctor.coalgebraPreadditive_homGroup_zsmul_f","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\nA₁ A₂ : CategoryTheory.Endofunctor.Coalgebra F\nr : Int\nα : Quiver.Hom A₁ A₂\n⊢ Eq (HSMul.hSMul r α).f (HSMul.hSMul r α.f)","decl":"@[simps]\ninstance Endofunctor.coalgebraPreadditive : Preadditive (Endofunctor.Coalgebra F) where\n  homGroup A₁ A₂ :=\n    { add := fun α β =>\n        { f := α.f + β.f\n          h := by simp only [Functor.map_add, comp_add, Endofunctor.Coalgebra.Hom.h, add_comp] }\n      zero :=\n        { f := 0\n          h := by simp only [Functor.map_zero, zero_comp, comp_zero] }\n      nsmul := fun n α =>\n        { f := n • α.f\n          h := by rw [Functor.map_nsmul, comp_nsmul, Endofunctor.Coalgebra.Hom.h, nsmul_comp] }\n      neg := fun α =>\n        { f := -α.f\n          h := by simp only [Functor.map_neg, comp_neg, Endofunctor.Coalgebra.Hom.h, neg_comp] }\n      sub := fun α β =>\n        { f := α.f - β.f\n          h := by simp only [Functor.map_sub, comp_sub, Endofunctor.Coalgebra.Hom.h, sub_comp] }\n      zsmul := fun r α =>\n        { f := r • α.f\n          h := by rw [Functor.map_zsmul, comp_zsmul, Endofunctor.Coalgebra.Hom.h, zsmul_comp] }\n      add_assoc := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_assoc\n      zero_add := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_add\n      add_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_zero\n      nsmul_zero := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      nsmul_succ := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply succ_nsmul\n      sub_eq_add_neg := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply sub_eq_add_neg\n      zsmul_zero' := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply zero_smul\n      zsmul_succ' := by\n        intros\n        apply Coalgebra.Hom.ext\n        simp only [natCast_zsmul, succ_nsmul]\n        rfl\n      zsmul_neg' := by\n        intros\n        apply Coalgebra.Hom.ext\n        simp only [negSucc_zsmul, neg_inj, ← Nat.cast_smul_eq_nsmul ℤ]\n      neg_add_cancel := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply neg_add_cancel\n      add_comm := by\n        intros\n        apply Coalgebra.Hom.ext\n        apply add_comm }\n  add_comp := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply add_comp\n  comp_add := by\n    intros\n    apply Coalgebra.Hom.ext\n    apply comp_add\n\n"}
{"name":"CategoryTheory.Coalgebra.forget_additive","module":"Mathlib.CategoryTheory.Preadditive.EndoFunctor","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Preadditive C\nF : CategoryTheory.Functor C C\n⊢ (CategoryTheory.Endofunctor.Coalgebra.forget F).Additive","decl":"instance Coalgebra.forget_additive : (Endofunctor.Coalgebra.forget F).Additive where\n\n"}
