{"name":"PowerSeries.exists_coeff_ne_zero_iff_ne_zero","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\n⊢ Iff (Exists fun n => Ne ((PowerSeries.coeff R n) φ) 0) (Ne φ 0)","decl":"theorem exists_coeff_ne_zero_iff_ne_zero : (∃ n : ℕ, coeff R n φ ≠ 0) ↔ φ ≠ 0 := by\n  refine not_iff_not.mp ?_\n  push_neg\n  simp [(coeff R _).map_zero]\n\n"}
{"name":"PowerSeries.order_zero","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (PowerSeries.order 0) Top.top","decl":"/-- The order of the `0` power series is infinite. -/\n@[simp]\ntheorem order_zero : order (0 : R⟦X⟧) = ⊤ :=\n  dif_pos rfl\n\n"}
{"name":"PowerSeries.order_finite_iff_ne_zero","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\n⊢ Iff (LT.lt φ.order Top.top) (Ne φ 0)","decl":"theorem order_finite_iff_ne_zero : (order φ < ⊤) ↔ φ ≠ 0 := by\n  simp only [order]\n  constructor\n  · split_ifs with h <;> intro H\n    · simp at H\n    · exact h\n  · intro h\n    simp [h]\n\n"}
{"name":"PowerSeries.coeff_order","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\nh : LT.lt φ.order Top.top\n⊢ Ne ((PowerSeries.coeff R (φ.order.lift h)) φ) 0","decl":"/-- If the order of a formal power series is finite,\nthen the coefficient indexed by the order is nonzero. -/\ntheorem coeff_order (h : order φ < ⊤) : coeff R (φ.order.lift h) φ ≠ 0 := by\n  classical\n  simp only [order, order_finite_iff_ne_zero.mp h, not_false_iff, dif_neg]\n  generalize_proofs h\n  exact Nat.find_spec h\n\n"}
{"name":"PowerSeries.order_le","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\nn : Nat\nh : Ne ((PowerSeries.coeff R n) φ) 0\n⊢ LE.le φ.order ↑n","decl":"/-- If the `n`th coefficient of a formal power series is nonzero,\nthen the order of the power series is less than or equal to `n`. -/\ntheorem order_le (n : ℕ) (h : coeff R n φ ≠ 0) : order φ ≤ n := by\n  classical\n  rw [order, dif_neg]\n  · simpa using ⟨n, le_rfl, h⟩\n  · exact exists_coeff_ne_zero_iff_ne_zero.mp ⟨n, h⟩\n\n"}
{"name":"PowerSeries.coeff_of_lt_order","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\nn : Nat\nh : LT.lt (↑n) φ.order\n⊢ Eq ((PowerSeries.coeff R n) φ) 0","decl":"/-- The `n`th coefficient of a formal power series is `0` if `n` is strictly\nsmaller than the order of the power series. -/\ntheorem coeff_of_lt_order (n : ℕ) (h : ↑n < order φ) : coeff R n φ = 0 := by\n  contrapose! h\n  exact order_le _ h\n\n"}
{"name":"PowerSeries.order_eq_top","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\n⊢ Iff (Eq φ.order Top.top) (Eq φ 0)","decl":"/-- The `0` power series is the unique power series with infinite order. -/\n@[simp]\ntheorem order_eq_top {φ : R⟦X⟧} : φ.order = ⊤ ↔ φ = 0 := by\n  simpa using order_finite_iff_ne_zero.not_left\n\n"}
{"name":"PowerSeries.nat_le_order","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\nn : Nat\nh : ∀ (i : Nat), LT.lt i n → Eq ((PowerSeries.coeff R i) φ) 0\n⊢ LE.le (↑n) φ.order","decl":"/-- The order of a formal power series is at least `n` if\nthe `i`th coefficient is `0` for all `i < n`. -/\ntheorem nat_le_order (φ : R⟦X⟧) (n : ℕ) (h : ∀ i < n, coeff R i φ = 0) : ↑n ≤ order φ := by\n  by_contra H; rw [not_le] at H\n  have lt_top : order φ < ⊤ := lt_top_of_lt H\n  replace H : (order φ).lift lt_top < n := by simpa\n  exact coeff_order lt_top (h _ H)\n\n"}
{"name":"PowerSeries.le_order","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\nn : ENat\nh : ∀ (i : Nat), LT.lt (↑i) n → Eq ((PowerSeries.coeff R i) φ) 0\n⊢ LE.le n φ.order","decl":"/-- The order of a formal power series is at least `n` if\nthe `i`th coefficient is `0` for all `i < n`. -/\ntheorem le_order (φ : R⟦X⟧) (n : ℕ∞) (h : ∀ i : ℕ, ↑i < n → coeff R i φ = 0) :\n    n ≤ order φ := by\n  cases n with\n  | top => simpa using ext (by simpa using h)\n  | coe n =>\n    convert nat_le_order φ n _\n    simpa using h\n\n"}
{"name":"PowerSeries.order_eq_nat","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\nn : Nat\n⊢ Iff (Eq φ.order ↑n) (And (Ne ((PowerSeries.coeff R n) φ) 0) (∀ (i : Nat), LT.lt i n → Eq ((PowerSeries.coeff R i) φ) 0))","decl":"/-- The order of a formal power series is exactly `n` if the `n`th coefficient is nonzero,\nand the `i`th coefficient is `0` for all `i < n`. -/\ntheorem order_eq_nat {φ : R⟦X⟧} {n : ℕ} :\n    order φ = n ↔ coeff R n φ ≠ 0 ∧ ∀ i, i < n → coeff R i φ = 0 := by\n  classical\n  rcases eq_or_ne φ 0 with (rfl | hφ)\n  · simp\n  simp [order, dif_neg hφ, Nat.find_eq_iff]\n\n"}
{"name":"PowerSeries.order_eq","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\nn : ENat\n⊢ Iff (Eq φ.order n) (And (∀ (i : Nat), Eq (↑i) n → Ne ((PowerSeries.coeff R i) φ) 0) (∀ (i : Nat), LT.lt (↑i) n → Eq ((PowerSeries.coeff R i) φ) 0))","decl":"/-- The order of a formal power series is exactly `n` if the `n`th coefficient is nonzero,\nand the `i`th coefficient is `0` for all `i < n`. -/\ntheorem order_eq {φ : R⟦X⟧} {n : ℕ∞} :\n    order φ = n ↔ (∀ i : ℕ, ↑i = n → coeff R i φ ≠ 0) ∧ ∀ i : ℕ, ↑i < n → coeff R i φ = 0 := by\n  cases n with\n  | top => simp [ext_iff]\n  | coe n => simp [order_eq_nat]\n\n\n"}
{"name":"PowerSeries.min_order_le_order_add","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ ψ : PowerSeries R\n⊢ LE.le (Min.min φ.order ψ.order) (HAdd.hAdd φ ψ).order","decl":"/-- The order of the sum of two formal power series\n is at least the minimum of their orders. -/\ntheorem min_order_le_order_add (φ ψ : R⟦X⟧) : min (order φ) (order ψ) ≤ order (φ + ψ) := by\n  refine le_order _ _ ?_\n  simp +contextual [coeff_of_lt_order]\n\n"}
{"name":"PowerSeries.le_order_add","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ ψ : PowerSeries R\n⊢ LE.le (Min.min φ.order ψ.order) (HAdd.hAdd φ ψ).order","decl":"@[deprecated (since := \"2024-11-12\")] alias le_order_add := min_order_le_order_add\n\n"}
{"name":"PowerSeries.order_add_of_order_eq","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ ψ : PowerSeries R\nh : Ne φ.order ψ.order\n⊢ Eq (HAdd.hAdd φ ψ).order (Min.min φ.order ψ.order)","decl":"/-- The order of the sum of two formal power series\n is the minimum of their orders if their orders differ. -/\ntheorem order_add_of_order_eq (φ ψ : R⟦X⟧) (h : order φ ≠ order ψ) :\n    order (φ + ψ) = order φ ⊓ order ψ := by\n  refine le_antisymm ?_ (min_order_le_order_add _ _)\n  by_cases H₁ : order φ < order ψ\n  · apply order_add_of_order_eq.aux _ _ h H₁\n  by_cases H₂ : order ψ < order φ\n  · simpa only [add_comm, inf_comm] using order_add_of_order_eq.aux _ _ h.symm H₂\n  exfalso; exact h (le_antisymm (not_lt.1 H₂) (not_lt.1 H₁))\n\n"}
{"name":"PowerSeries.le_order_mul","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ ψ : PowerSeries R\n⊢ LE.le (HAdd.hAdd φ.order ψ.order) (HMul.hMul φ ψ).order","decl":"/-- The order of the product of two formal power series\n is at least the sum of their orders. -/\ntheorem le_order_mul (φ ψ : R⟦X⟧) : order φ + order ψ ≤ order (φ * ψ) := by\n  apply le_order\n  intro n hn; rw [coeff_mul, Finset.sum_eq_zero]\n  rintro ⟨i, j⟩ hij\n  by_cases hi : ↑i < order φ\n  · rw [coeff_of_lt_order i hi, zero_mul]\n  by_cases hj : ↑j < order ψ\n  · rw [coeff_of_lt_order j hj, mul_zero]\n  rw [not_lt] at hi hj; rw [mem_antidiagonal] at hij\n  exfalso\n  apply ne_of_lt (lt_of_lt_of_le hn <| add_le_add hi hj)\n  rw [← Nat.cast_add, hij]\n\n"}
{"name":"PowerSeries.order_mul_ge","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ ψ : PowerSeries R\n⊢ LE.le (HAdd.hAdd φ.order ψ.order) (HMul.hMul φ ψ).order","decl":"alias order_mul_ge := le_order_mul\n\n"}
{"name":"PowerSeries.order_monomial","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nn : Nat\na : R\ninst✝ : Decidable (Eq a 0)\n⊢ Eq ((PowerSeries.monomial R n) a).order (ite (Eq a 0) Top.top ↑n)","decl":"/-- The order of the monomial `a*X^n` is infinite if `a = 0` and `n` otherwise. -/\ntheorem order_monomial (n : ℕ) (a : R) [Decidable (a = 0)] :\n    order (monomial R n a) = if a = 0 then (⊤ : ℕ∞) else n := by\n  split_ifs with h\n  · rw [h, order_eq_top, LinearMap.map_zero]\n  · rw [order_eq]\n    constructor <;> intro i hi\n    · simp only [Nat.cast_inj] at hi\n      rwa [hi, coeff_monomial_same]\n    · simp only [Nat.cast_lt] at hi\n      rw [coeff_monomial, if_neg]\n      exact ne_of_lt hi\n\n"}
{"name":"PowerSeries.order_monomial_of_ne_zero","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\na : R\nh : Ne a 0\n⊢ Eq ((PowerSeries.monomial R n) a).order ↑n","decl":"/-- The order of the monomial `a*X^n` is `n` if `a ≠ 0`. -/\ntheorem order_monomial_of_ne_zero (n : ℕ) (a : R) (h : a ≠ 0) : order (monomial R n a) = n := by\n  classical\n  rw [order_monomial, if_neg h]\n\n"}
{"name":"PowerSeries.coeff_mul_of_lt_order","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ ψ : PowerSeries R\nn : Nat\nh : LT.lt (↑n) ψ.order\n⊢ Eq ((PowerSeries.coeff R n) (HMul.hMul φ ψ)) 0","decl":"/-- If `n` is strictly smaller than the order of `ψ`, then the `n`th coefficient of its product\nwith any other power series is `0`. -/\ntheorem coeff_mul_of_lt_order {φ ψ : R⟦X⟧} {n : ℕ} (h : ↑n < ψ.order) :\n    coeff R n (φ * ψ) = 0 := by\n  suffices coeff R n (φ * ψ) = ∑ p ∈ antidiagonal n, 0 by rw [this, Finset.sum_const_zero]\n  rw [coeff_mul]\n  apply Finset.sum_congr rfl\n  intro x hx\n  refine mul_eq_zero_of_right (coeff R x.fst φ) (coeff_of_lt_order x.snd (lt_of_le_of_lt ?_ h))\n  rw [mem_antidiagonal] at hx\n  norm_cast\n  omega\n\n"}
{"name":"PowerSeries.coeff_mul_one_sub_of_lt_order","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_2\ninst✝ : CommRing R\nφ ψ : PowerSeries R\nn : Nat\nh : LT.lt (↑n) ψ.order\n⊢ Eq ((PowerSeries.coeff R n) (HMul.hMul φ (HSub.hSub 1 ψ))) ((PowerSeries.coeff R n) φ)","decl":"theorem coeff_mul_one_sub_of_lt_order {R : Type*} [CommRing R] {φ ψ : R⟦X⟧} (n : ℕ)\n    (h : ↑n < ψ.order) : coeff R n (φ * (1 - ψ)) = coeff R n φ := by\n  simp [coeff_mul_of_lt_order h, mul_sub]\n\n"}
{"name":"PowerSeries.coeff_mul_prod_one_sub_of_lt_order","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_2\nι : Type u_3\ninst✝ : CommRing R\nk : Nat\ns : Finset ι\nφ : PowerSeries R\nf : ι → PowerSeries R\na✝ : ∀ (i : ι), Membership.mem s i → LT.lt (↑k) (f i).order\n⊢ Eq ((PowerSeries.coeff R k) (HMul.hMul φ (s.prod fun i => HSub.hSub 1 (f i)))) ((PowerSeries.coeff R k) φ)","decl":"theorem coeff_mul_prod_one_sub_of_lt_order {R ι : Type*} [CommRing R] (k : ℕ) (s : Finset ι)\n    (φ : R⟦X⟧) (f : ι → R⟦X⟧) :\n    (∀ i ∈ s, ↑k < (f i).order) → coeff R k (φ * ∏ i ∈ s, (1 - f i)) = coeff R k φ := by\n  classical\n  induction' s using Finset.induction_on with a s ha ih t\n  · simp\n  · intro t\n    simp only [Finset.mem_insert, forall_eq_or_imp] at t\n    rw [Finset.prod_insert ha, ← mul_assoc, mul_right_comm, coeff_mul_one_sub_of_lt_order _ t.1]\n    exact ih t.2\n\n-- TODO: link with `X_pow_dvd_iff`\n"}
{"name":"PowerSeries.X_pow_order_dvd","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nφ : PowerSeries R\nh : LT.lt φ.order Top.top\n⊢ Dvd.dvd (HPow.hPow PowerSeries.X (φ.order.lift h)) φ","decl":"theorem X_pow_order_dvd (h : order φ < ⊤) : X ^ (order φ).lift h ∣ φ := by\n  refine ⟨PowerSeries.mk fun n => coeff R (n + (order φ).lift h) φ, ?_⟩\n  ext n\n  simp only [coeff_mul, coeff_X_pow, coeff_mk, boole_mul, Finset.sum_ite,\n    Finset.sum_const_zero, add_zero]\n  rw [Finset.filter_fst_eq_antidiagonal n ((order φ).lift h)]\n  split_ifs with hn\n  · simp [tsub_add_cancel_of_le hn]\n  · simp only [Finset.sum_empty]\n    refine coeff_of_lt_order _ ?_\n    simpa using hn\n\n"}
{"name":"PowerSeries.order_eq_emultiplicity_X","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_2\ninst✝ : Semiring R\nφ : PowerSeries R\n⊢ Eq φ.order (emultiplicity PowerSeries.X φ)","decl":"theorem order_eq_emultiplicity_X {R : Type*} [Semiring R] (φ : R⟦X⟧) :\n    order φ = emultiplicity X φ := by\n  classical\n  rcases eq_or_ne φ 0 with (rfl | hφ)\n  · simp\n  cases ho : order φ with\n  | top => simp [hφ] at ho\n  | coe n =>\n    have hn : φ.order.lift (order_finite_iff_ne_zero.mpr hφ) = n := by simp [ho]\n    rw [← hn, eq_comm]\n    apply le_antisymm _\n    · apply le_emultiplicity_of_pow_dvd\n      apply X_pow_order_dvd\n    · apply Order.le_of_lt_add_one\n      rw [← not_le, ← Nat.cast_one, ← Nat.cast_add, ← pow_dvd_iff_le_emultiplicity]\n      rintro ⟨ψ, H⟩\n      have := congr_arg (coeff R n) H\n      rw [← (ψ.commute_X.pow_right _).eq, coeff_mul_of_lt_order, ← hn] at this\n      · exact coeff_order _ this\n      · rw [X_pow_eq, order_monomial]\n        split_ifs\n        · simp\n        · rw [← hn, ENat.coe_lt_coe]\n          simp\n\n"}
{"name":"PowerSeries.self_eq_X_pow_order_mul_divided_by_X_pow_order","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : PowerSeries R\nhf : Ne f 0\n⊢ Eq (HMul.hMul (HPow.hPow PowerSeries.X (f.order.lift ⋯)) (PowerSeries.divided_by_X_pow_order hf)) f","decl":"theorem self_eq_X_pow_order_mul_divided_by_X_pow_order {f : R⟦X⟧} (hf : f ≠ 0) :\n    X ^ f.order.lift (order_finite_iff_ne_zero.mpr hf) * divided_by_X_pow_order hf = f :=\n  haveI dvd := X_pow_order_dvd (order_finite_iff_ne_zero.mpr hf)\n  (exists_eq_mul_right_of_dvd dvd).choose_spec.symm\n\n"}
{"name":"PowerSeries.order_one","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\n⊢ Eq (PowerSeries.order 1) 0","decl":"/-- The order of the formal power series `1` is `0`. -/\n@[simp]\ntheorem order_one : order (1 : R⟦X⟧) = 0 := by\n  simpa using order_monomial_of_ne_zero 0 (1 : R) one_ne_zero\n\n"}
{"name":"PowerSeries.order_zero_of_unit","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\nf : PowerSeries R\na✝ : IsUnit f\n⊢ Eq f.order 0","decl":"/-- The order of an invertible power series is `0`. -/\ntheorem order_zero_of_unit {f : PowerSeries R} : IsUnit f → f.order = 0 := by\n  rintro ⟨⟨u, v, hu, hv⟩, hf⟩\n  apply And.left\n  rw [← add_eq_zero, ← hf, ← nonpos_iff_eq_zero, ← @order_one R _ _, ← hu]\n  exact order_mul_ge _ _\n\n"}
{"name":"PowerSeries.order_X","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\n⊢ Eq PowerSeries.X.order 1","decl":"/-- The order of the formal power series `X` is `1`. -/\n@[simp]\ntheorem order_X : order (X : R⟦X⟧) = 1 := by\n  simpa only [Nat.cast_one] using order_monomial_of_ne_zero 1 (1 : R) one_ne_zero\n\n"}
{"name":"PowerSeries.order_X_pow","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\nn : Nat\n⊢ Eq (HPow.hPow PowerSeries.X n).order ↑n","decl":"/-- The order of the formal power series `X^n` is `n`. -/\n@[simp]\ntheorem order_X_pow (n : ℕ) : order ((X : R⟦X⟧) ^ n) = n := by\n  rw [X_pow_eq, order_monomial_of_ne_zero]\n  exact one_ne_zero\n\n"}
{"name":"PowerSeries.order_mul","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nφ ψ : PowerSeries R\n⊢ Eq (HMul.hMul φ ψ).order (HAdd.hAdd φ.order ψ.order)","decl":"/-- The order of the product of two formal power series over an integral domain\n is the sum of their orders. -/\ntheorem order_mul (φ ψ : R⟦X⟧) : order (φ * ψ) = order φ + order ψ := by\n  classical\n  simp only [order_eq_emultiplicity_X]\n  exact emultiplicity_mul X_prime\n\n-- Dividing `X` by the maximal power of `X` dividing it leaves `1`.\n"}
{"name":"PowerSeries.divided_by_X_pow_order_of_X_eq_one","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Eq (PowerSeries.divided_by_X_pow_order ⋯) 1","decl":"@[simp]\ntheorem divided_by_X_pow_order_of_X_eq_one : divided_by_X_pow_order X_ne_zero = (1 : R⟦X⟧) := by\n  rw [← mul_eq_left₀ X_ne_zero]\n  simpa using self_eq_X_pow_order_mul_divided_by_X_pow_order (@X_ne_zero R _ _)\n\n-- Dividing a power series by the maximal power of `X` dividing it, respects multiplication.\n"}
{"name":"PowerSeries.divided_by_X_pow_orderMul","module":"Mathlib.RingTheory.PowerSeries.Order","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nf g : PowerSeries R\nhf : Ne f 0\nhg : Ne g 0\n⊢ Eq (HMul.hMul (PowerSeries.divided_by_X_pow_order hf) (PowerSeries.divided_by_X_pow_order hg)) (PowerSeries.divided_by_X_pow_order ⋯)","decl":"theorem divided_by_X_pow_orderMul {f g : R⟦X⟧} (hf : f ≠ 0) (hg : g ≠ 0) :\n    divided_by_X_pow_order hf * divided_by_X_pow_order hg =\n      divided_by_X_pow_order (mul_ne_zero hf hg) := by\n  set df := f.order.lift (order_finite_iff_ne_zero.mpr hf)\n  set dg := g.order.lift (order_finite_iff_ne_zero.mpr hg)\n  set dfg := (f * g).order.lift (order_finite_iff_ne_zero.mpr (mul_ne_zero hf hg))\n  have H_add_d : df + dg = dfg := by\n    simp_all [df, dg, dfg, order_mul f g]\n  have H := self_eq_X_pow_order_mul_divided_by_X_pow_order (mul_ne_zero hf hg)\n  have : f * g = X ^ dfg * (divided_by_X_pow_order hf * divided_by_X_pow_order hg) := by\n    calc\n      f * g = X ^ df * divided_by_X_pow_order hf * (X ^ dg * divided_by_X_pow_order hg) := by\n        rw [self_eq_X_pow_order_mul_divided_by_X_pow_order,\n          self_eq_X_pow_order_mul_divided_by_X_pow_order]\n      _ = X ^ df * X ^ dg * divided_by_X_pow_order hf * divided_by_X_pow_order hg := by ring\n      _ = X ^ (df + dg) * divided_by_X_pow_order hf * divided_by_X_pow_order hg := by rw [pow_add]\n      _ = X ^ dfg * divided_by_X_pow_order hf * divided_by_X_pow_order hg := by rw [H_add_d]\n      _ = X ^ dfg * (divided_by_X_pow_order hf * divided_by_X_pow_order hg) := by rw [mul_assoc]\n  refine (IsLeftCancelMulZero.mul_left_cancel_of_ne_zero (pow_ne_zero dfg X_ne_zero) ?_).symm\n  simp only [this] at H\n  convert H\n\n"}
