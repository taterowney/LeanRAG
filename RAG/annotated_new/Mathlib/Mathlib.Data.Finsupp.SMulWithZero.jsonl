{"name":"Finsupp.coe_smul","module":"Mathlib.Data.Finsupp.SMulWithZero","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\ninst✝¹ : Zero M\ninst✝ : SMulZeroClass R M\nb : R\nv : Finsupp α M\n⊢ Eq (⇑(HSMul.hSMul b v)) (HSMul.hSMul b ⇑v)","decl":"@[simp, norm_cast]\ntheorem coe_smul [Zero M] [SMulZeroClass R M] (b : R) (v : α →₀ M) : ⇑(b • v) = b • ⇑v :=\n  rfl\n\n"}
{"name":"Finsupp.smul_apply","module":"Mathlib.Data.Finsupp.SMulWithZero","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\ninst✝¹ : Zero M\ninst✝ : SMulZeroClass R M\nb : R\nv : Finsupp α M\na : α\n⊢ Eq ((HSMul.hSMul b v) a) (HSMul.hSMul b (v a))","decl":"theorem smul_apply [Zero M] [SMulZeroClass R M] (b : R) (v : α →₀ M) (a : α) :\n    (b • v) a = b • v a :=\n  rfl\n\n"}
{"name":"Finsupp.isScalarTower","module":"Mathlib.Data.Finsupp.SMulWithZero","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\nS : Type u_12\ninst✝⁴ : Zero M\ninst✝³ : SMulZeroClass R M\ninst✝² : SMulZeroClass S M\ninst✝¹ : SMul R S\ninst✝ : IsScalarTower R S M\n⊢ IsScalarTower R S (Finsupp α M)","decl":"instance isScalarTower [Zero M] [SMulZeroClass R M] [SMulZeroClass S M] [SMul R S]\n  [IsScalarTower R S M] : IsScalarTower R S (α →₀ M) where\n  smul_assoc _ _ _ := ext fun _ => smul_assoc _ _ _\n\n"}
{"name":"Finsupp.smulCommClass","module":"Mathlib.Data.Finsupp.SMulWithZero","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\nS : Type u_12\ninst✝³ : Zero M\ninst✝² : SMulZeroClass R M\ninst✝¹ : SMulZeroClass S M\ninst✝ : SMulCommClass R S M\n⊢ SMulCommClass R S (Finsupp α M)","decl":"instance smulCommClass [Zero M] [SMulZeroClass R M] [SMulZeroClass S M] [SMulCommClass R S M] :\n  SMulCommClass R S (α →₀ M) where\n  smul_comm _ _ _ := ext fun _ => smul_comm _ _ _\n\n"}
{"name":"Finsupp.isCentralScalar","module":"Mathlib.Data.Finsupp.SMulWithZero","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\ninst✝³ : Zero M\ninst✝² : SMulZeroClass R M\ninst✝¹ : SMulZeroClass (MulOpposite R) M\ninst✝ : IsCentralScalar R M\n⊢ IsCentralScalar R (Finsupp α M)","decl":"instance isCentralScalar [Zero M] [SMulZeroClass R M] [SMulZeroClass Rᵐᵒᵖ M] [IsCentralScalar R M] :\n  IsCentralScalar R (α →₀ M) where\n  op_smul_eq_smul _ _ := ext fun _ => op_smul_eq_smul _ _\n\n"}
{"name":"Finsupp.support_smul","module":"Mathlib.Data.Finsupp.SMulWithZero","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\ninst✝¹ : AddMonoid M\ninst✝ : SMulZeroClass R M\nb : R\ng : Finsupp α M\n⊢ HasSubset.Subset (HSMul.hSMul b g).support g.support","decl":"theorem support_smul [AddMonoid M] [SMulZeroClass R M] {b : R} {g : α →₀ M} :\n    (b • g).support ⊆ g.support := fun a => by\n  simp only [smul_apply, mem_support_iff, Ne]\n  exact mt fun h => h.symm ▸ smul_zero _\n\n"}
{"name":"Finsupp.smul_single","module":"Mathlib.Data.Finsupp.SMulWithZero","initialProofState":"α : Type u_1\nM : Type u_5\nR : Type u_11\ninst✝¹ : Zero M\ninst✝ : SMulZeroClass R M\nc : R\na : α\nb : M\n⊢ Eq (HSMul.hSMul c (Finsupp.single a b)) (Finsupp.single a (HSMul.hSMul c b))","decl":"@[simp]\ntheorem smul_single [Zero M] [SMulZeroClass R M] (c : R) (a : α) (b : M) :\n    c • Finsupp.single a b = Finsupp.single a (c • b) :=\n  mapRange_single\n\n"}
{"name":"Finsupp.mapRange_smul","module":"Mathlib.Data.Finsupp.SMulWithZero","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\nR : Type u_11\nx✝ : Monoid R\ninst✝³ : AddMonoid M\ninst✝² : DistribMulAction R M\ninst✝¹ : AddMonoid N\ninst✝ : DistribMulAction R N\nf : M → N\nhf : Eq (f 0) 0\nc : R\nv : Finsupp α M\nhsmul : ∀ (x : M), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))\n⊢ Eq (Finsupp.mapRange f hf (HSMul.hSMul c v)) (HSMul.hSMul c (Finsupp.mapRange f hf v))","decl":"theorem mapRange_smul {_ : Monoid R} [AddMonoid M] [DistribMulAction R M] [AddMonoid N]\n    [DistribMulAction R N] {f : M → N} {hf : f 0 = 0} (c : R) (v : α →₀ M)\n    (hsmul : ∀ x, f (c • x) = c • f x) : mapRange f hf (c • v) = c • mapRange f hf v := by\n  erw [← mapRange_comp]\n  · have : f ∘ (c • ·) = (c • ·) ∘ f := funext hsmul\n    simp_rw [this]\n    apply mapRange_comp\n  simp only [Function.comp_apply, smul_zero, hf]\n\n"}
