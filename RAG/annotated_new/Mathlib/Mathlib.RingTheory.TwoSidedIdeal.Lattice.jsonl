{"name":"TwoSidedIdeal.sup_ringCon","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI J : TwoSidedIdeal R\n⊢ Eq (Max.max I J).ringCon (Max.max I.ringCon J.ringCon)","decl":"lemma sup_ringCon (I J : TwoSidedIdeal R) : (I ⊔ J).ringCon = I.ringCon ⊔ J.ringCon := rfl\n\n"}
{"name":"TwoSidedIdeal.mem_sup_left","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI J : TwoSidedIdeal R\nx : R\nh : Membership.mem I x\n⊢ Membership.mem (Max.max I J) x","decl":"lemma mem_sup_left {I J : TwoSidedIdeal R} {x : R} (h : x ∈ I) :\n    x ∈ I ⊔ J :=\n  (show I ≤ I ⊔ J from le_sup_left) h\n\n"}
{"name":"TwoSidedIdeal.mem_sup_right","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI J : TwoSidedIdeal R\nx : R\nh : Membership.mem J x\n⊢ Membership.mem (Max.max I J) x","decl":"lemma mem_sup_right {I J : TwoSidedIdeal R} {x : R} (h : x ∈ J) :\n    x ∈ I ⊔ J :=\n  (show J ≤ I ⊔ J from le_sup_right) h\n\n"}
{"name":"TwoSidedIdeal.mem_sup","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI J : TwoSidedIdeal R\nx : R\n⊢ Iff (Membership.mem (Max.max I J) x) (Exists fun y => And (Membership.mem I y) (Exists fun z => And (Membership.mem J z) (Eq (HAdd.hAdd y z) x)))","decl":"lemma mem_sup {I J : TwoSidedIdeal R} {x : R} :\n    x ∈ I ⊔ J ↔ ∃ y ∈ I, ∃ z ∈ J, y + z = x := by\n  constructor\n  · let s : TwoSidedIdeal R := .mk'\n      {x | ∃ y ∈ I, ∃ z ∈ J, y + z = x}\n      ⟨0, ⟨zero_mem _, ⟨0, ⟨zero_mem _, zero_add _⟩⟩⟩⟩\n      (by rintro _ _ ⟨x, ⟨hx, ⟨y, ⟨hy, rfl⟩⟩⟩⟩ ⟨a, ⟨ha, ⟨b, ⟨hb, rfl⟩⟩⟩⟩;\n          exact ⟨x + a, ⟨add_mem _ hx ha, ⟨y + b, ⟨add_mem _ hy hb, by abel⟩⟩⟩⟩)\n      (by rintro _ ⟨x, ⟨hx, ⟨y, ⟨hy, rfl⟩⟩⟩⟩\n          exact ⟨-x, ⟨neg_mem _ hx, ⟨-y, ⟨neg_mem _ hy, by abel⟩⟩⟩⟩)\n      (by rintro r _ ⟨x, ⟨hx, ⟨y, ⟨hy, rfl⟩⟩⟩⟩\n          exact ⟨_, ⟨mul_mem_left _ _ _ hx, ⟨_, ⟨mul_mem_left _ _ _ hy, mul_add _ _ _ |>.symm⟩⟩⟩⟩)\n      (by rintro r _ ⟨x, ⟨hx, ⟨y, ⟨hy, rfl⟩⟩⟩⟩\n          exact ⟨_, ⟨mul_mem_right _ _ _ hx, ⟨_, ⟨mul_mem_right _ _ _ hy, add_mul _ _ _ |>.symm⟩⟩⟩⟩)\n    suffices (I.ringCon ⊔ J.ringCon) ≤ s.ringCon by\n      intro h; convert this h; rw [rel_iff, sub_zero, mem_mk']; rfl\n    refine sup_le (fun x y h => ?_) (fun x y h => ?_) <;> rw [rel_iff] at h ⊢ <;> rw [mem_mk']\n    exacts [⟨_, ⟨h, ⟨0, ⟨zero_mem _, add_zero _⟩⟩⟩⟩, ⟨0, ⟨zero_mem _, ⟨_, ⟨h, zero_add _⟩⟩⟩⟩]\n  · rintro ⟨y, ⟨hy, ⟨z, ⟨hz, rfl⟩⟩⟩⟩; exact add_mem _ (mem_sup_left hy) (mem_sup_right hz)\n\n"}
{"name":"TwoSidedIdeal.inf_ringCon","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI J : TwoSidedIdeal R\n⊢ Eq (Min.min I J).ringCon (Min.min I.ringCon J.ringCon)","decl":"lemma inf_ringCon (I J : TwoSidedIdeal R) : (I ⊓ J).ringCon = I.ringCon ⊓ J.ringCon := rfl\n\n"}
{"name":"TwoSidedIdeal.mem_inf","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI J : TwoSidedIdeal R\nx : R\n⊢ Iff (Membership.mem (Min.min I J) x) (And (Membership.mem I x) (Membership.mem J x))","decl":"lemma mem_inf {I J : TwoSidedIdeal R} {x : R} :\n    x ∈ I ⊓ J ↔ x ∈ I ∧ x ∈ J :=\n  Iff.rfl\n\n"}
{"name":"TwoSidedIdeal.sSup_ringCon","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nS : Set (TwoSidedIdeal R)\n⊢ Eq (SupSet.sSup S).ringCon (SupSet.sSup (Set.image TwoSidedIdeal.ringCon S))","decl":"lemma sSup_ringCon (S : Set (TwoSidedIdeal R)) :\n    (sSup S).ringCon = sSup (TwoSidedIdeal.ringCon '' S) := rfl\n\n"}
{"name":"TwoSidedIdeal.iSup_ringCon","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nι : Type u_2\nI : ι → TwoSidedIdeal R\n⊢ Eq (iSup fun i => I i).ringCon (iSup fun i => (I i).ringCon)","decl":"lemma iSup_ringCon {ι : Type*} (I : ι → TwoSidedIdeal R) :\n    (⨆ i, I i).ringCon = ⨆ i, (I i).ringCon := by\n  simp only [iSup, sSup_ringCon]; congr; ext; simp\n\n"}
{"name":"TwoSidedIdeal.sInf_ringCon","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nS : Set (TwoSidedIdeal R)\n⊢ Eq (InfSet.sInf S).ringCon (InfSet.sInf (Set.image TwoSidedIdeal.ringCon S))","decl":"lemma sInf_ringCon (S : Set (TwoSidedIdeal R)) :\n    (sInf S).ringCon = sInf (TwoSidedIdeal.ringCon '' S) := rfl\n\n"}
{"name":"TwoSidedIdeal.iInf_ringCon","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nι : Type u_2\nI : ι → TwoSidedIdeal R\n⊢ Eq (iInf fun i => I i).ringCon (iInf fun i => (I i).ringCon)","decl":"lemma iInf_ringCon {ι : Type*} (I : ι → TwoSidedIdeal R) :\n    (⨅ i, I i).ringCon = ⨅ i, (I i).ringCon := by\n  simp only [iInf, sInf_ringCon]; congr!; ext; simp\n\n"}
{"name":"TwoSidedIdeal.mem_iInf","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nι : Type u_2\nI : ι → TwoSidedIdeal R\nx : R\n⊢ Iff (Membership.mem (iInf I) x) (∀ (i : ι), Membership.mem (I i) x)","decl":"lemma mem_iInf {ι : Type*} {I : ι → TwoSidedIdeal R} {x : R} :\n    x ∈ iInf I ↔ ∀ i, x ∈ I i :=\n  show (∀ _, _) ↔ _ by simp [mem_iff]\n\n"}
{"name":"TwoSidedIdeal.mem_sInf","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nS : Set (TwoSidedIdeal R)\nx : R\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (I : TwoSidedIdeal R), Membership.mem S I → Membership.mem I x)","decl":"lemma mem_sInf {S : Set (TwoSidedIdeal R)} {x : R} :\n    x ∈ sInf S ↔ ∀ I ∈ S, x ∈ I :=\n  show (∀ _, _) ↔ _ by simp [mem_iff]\n\n"}
{"name":"TwoSidedIdeal.top_ringCon","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\n⊢ Eq Top.top.ringCon Top.top","decl":"lemma top_ringCon : (⊤ : TwoSidedIdeal R).ringCon = ⊤ := rfl\n\n"}
{"name":"TwoSidedIdeal.mem_top","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nx : R\n⊢ Membership.mem Top.top x","decl":"@[simp]\nlemma mem_top {x : R} : x ∈ (⊤: TwoSidedIdeal R) := trivial\n\n"}
{"name":"TwoSidedIdeal.bot_ringCon","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\n⊢ Eq Bot.bot.ringCon Bot.bot","decl":"lemma bot_ringCon : (⊥ : TwoSidedIdeal R).ringCon = ⊥ := rfl\n\n"}
{"name":"TwoSidedIdeal.mem_bot","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nx : R\n⊢ Iff (Membership.mem Bot.bot x) (Eq x 0)","decl":"@[simp]\nlemma mem_bot {x : R} : x ∈ (⊥ : TwoSidedIdeal R) ↔ x = 0 :=\n  Iff.rfl\n\n"}
{"name":"TwoSidedIdeal.one_mem_iff","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_2\ninst✝ : NonAssocRing R\nI : TwoSidedIdeal R\n⊢ Iff (Membership.mem I 1) (Eq I Top.top)","decl":"lemma one_mem_iff {R : Type*} [NonAssocRing R] (I : TwoSidedIdeal R) :\n    (1 : R) ∈ I ↔ I = ⊤ :=\n  ⟨fun h => eq_top_iff.2 fun x _ => by simpa using I.mul_mem_left x _ h, fun h ↦ h.symm ▸ trivial⟩\n\n"}
{"name":"TwoSidedIdeal.one_mem","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_2\ninst✝ : NonAssocRing R\nI : TwoSidedIdeal R\na✝ : Eq I Top.top\n⊢ Membership.mem I 1","decl":"alias ⟨eq_top, one_mem⟩ := one_mem_iff\n\n"}
{"name":"TwoSidedIdeal.eq_top","module":"Mathlib.RingTheory.TwoSidedIdeal.Lattice","initialProofState":"R : Type u_2\ninst✝ : NonAssocRing R\nI : TwoSidedIdeal R\na✝ : Membership.mem I 1\n⊢ Eq I Top.top","decl":"alias ⟨eq_top, one_mem⟩ := one_mem_iff\n\n"}
