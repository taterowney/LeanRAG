{"name":"Algebra.FiniteType.out","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nself : Algebra.FiniteType R A\n⊢ Top.top.FG","decl":"/-- An algebra over a commutative semiring is of `FiniteType` if it is finitely generated\nover the base ring as algebra. -/\nclass Algebra.FiniteType [CommSemiring R] [Semiring A] [Algebra R A] : Prop where\n  out : (⊤ : Subalgebra R A).FG\n\n"}
{"name":"Module.Finite.finiteType","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nhRA : Module.Finite R A\n⊢ Algebra.FiniteType R A","decl":"instance (priority := 100) finiteType {R : Type*} (A : Type*) [CommSemiring R] [Semiring A]\n    [Algebra R A] [hRA : Module.Finite R A] : Algebra.FiniteType R A :=\n  ⟨Subalgebra.fg_of_submodule_fg hRA.1⟩\n\n"}
{"name":"Algebra.FiniteType.self","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\ninst✝ : CommSemiring R\n⊢ Algebra.FiniteType R R","decl":"theorem self : FiniteType R R :=\n  ⟨⟨{1}, Subsingleton.elim _ _⟩⟩\n\n"}
{"name":"Algebra.FiniteType.polynomial","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\ninst✝ : CommSemiring R\n⊢ Algebra.FiniteType R (Polynomial R)","decl":"protected theorem polynomial : FiniteType R R[X] :=\n  ⟨⟨{Polynomial.X}, by\n      rw [Finset.coe_singleton]\n      exact Polynomial.adjoin_X⟩⟩\n\n\n"}
{"name":"Algebra.FiniteType.freeAlgebra","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\ninst✝¹ : CommSemiring R\nι : Type u_1\ninst✝ : Finite ι\n⊢ Algebra.FiniteType R (FreeAlgebra R ι)","decl":"protected theorem freeAlgebra (ι : Type*) [Finite ι] : FiniteType R (FreeAlgebra R ι) := by\n  cases nonempty_fintype ι\n  classical\n  exact\n    ⟨⟨Finset.univ.image (FreeAlgebra.ι R), by\n        rw [Finset.coe_image, Finset.coe_univ, Set.image_univ]\n        exact FreeAlgebra.adjoin_range_ι R ι⟩⟩\n\n"}
{"name":"Algebra.FiniteType.mvPolynomial","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\ninst✝¹ : CommSemiring R\nι : Type u_1\ninst✝ : Finite ι\n⊢ Algebra.FiniteType R (MvPolynomial ι R)","decl":"protected theorem mvPolynomial (ι : Type*) [Finite ι] : FiniteType R (MvPolynomial ι R) := by\n  cases nonempty_fintype ι\n  classical\n  exact\n    ⟨⟨Finset.univ.image MvPolynomial.X, by\n        rw [Finset.coe_image, Finset.coe_univ, Set.image_univ]\n        exact MvPolynomial.adjoin_range_X⟩⟩\n\n"}
{"name":"Algebra.FiniteType.of_restrictScalars_finiteType","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\nhA : Algebra.FiniteType R A\n⊢ Algebra.FiniteType S A","decl":"theorem of_restrictScalars_finiteType [Algebra S A] [IsScalarTower R S A] [hA : FiniteType R A] :\n    FiniteType S A := by\n  obtain ⟨s, hS⟩ := hA.out\n  refine ⟨⟨s, eq_top_iff.2 fun b => ?_⟩⟩\n  have le : adjoin R (s : Set A) ≤ Subalgebra.restrictScalars R (adjoin S s) := by\n    apply (Algebra.adjoin_le _ : adjoin R (s : Set A) ≤ Subalgebra.restrictScalars R (adjoin S ↑s))\n    simp only [Subalgebra.coe_restrictScalars]\n    exact Algebra.subset_adjoin\n  exact le (eq_top_iff.1 hS b)\n\n"}
{"name":"Algebra.FiniteType.of_surjective","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nhRA : Algebra.FiniteType R A\nf : AlgHom R A B\nhf : Function.Surjective ⇑f\n⊢ Algebra.FiniteType R B","decl":"theorem of_surjective (hRA : FiniteType R A) (f : A →ₐ[R] B) (hf : Surjective f) : FiniteType R B :=\n  ⟨by\n    convert hRA.1.map f\n    simpa only [map_top f, @eq_comm _ ⊤, eq_top_iff, AlgHom.mem_range] using hf⟩\n\n"}
{"name":"Algebra.FiniteType.equiv","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nhRA : Algebra.FiniteType R A\ne : AlgEquiv R A B\n⊢ Algebra.FiniteType R B","decl":"theorem equiv (hRA : FiniteType R A) (e : A ≃ₐ[R] B) : FiniteType R B :=\n  hRA.of_surjective e e.surjective\n\n"}
{"name":"Algebra.FiniteType.trans","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R S\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\nhRS : Algebra.FiniteType R S\nhSA : Algebra.FiniteType S A\n⊢ Algebra.FiniteType R A","decl":"theorem trans [Algebra S A] [IsScalarTower R S A] (hRS : FiniteType R S) (hSA : FiniteType S A) :\n    FiniteType R A :=\n  ⟨fg_trans' hRS.1 hSA.1⟩\n\n"}
{"name":"Algebra.FiniteType.quotient","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nI : Ideal S\nh : Algebra.FiniteType R S\n⊢ Algebra.FiniteType R (HasQuotient.Quotient S I)","decl":"instance quotient (R : Type*) {S : Type*} [CommSemiring R] [CommRing S] [Algebra R S] (I : Ideal S)\n    [h : Algebra.FiniteType R S] : Algebra.FiniteType R (S ⧸ I) :=\n  Algebra.FiniteType.trans h inferInstance\n\n"}
{"name":"Algebra.FiniteType.iff_quotient_freeAlgebra","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Iff (Algebra.FiniteType R A) (Exists fun s => Exists fun f => Function.Surjective ⇑f)","decl":"/-- An algebra is finitely generated if and only if it is a quotient\nof a free algebra whose variables are indexed by a finset. -/\ntheorem iff_quotient_freeAlgebra :\n    FiniteType R A ↔\n      ∃ (s : Finset A) (f : FreeAlgebra R s →ₐ[R] A), Surjective f := by\n  constructor\n  · rintro ⟨s, hs⟩\n    refine ⟨s, FreeAlgebra.lift _ (↑), ?_⟩\n    intro x\n    have hrw : (↑s : Set A) = fun x : A => x ∈ s.val := rfl\n    rw [← Set.mem_range, ← AlgHom.coe_range]\n    erw [← adjoin_eq_range_freeAlgebra_lift]\n    simp_rw [← hrw, hs]\n    exact Set.mem_univ x\n  · rintro ⟨s, ⟨f, hsur⟩⟩\n    exact FiniteType.of_surjective (FiniteType.freeAlgebra R s) f hsur\n\n"}
{"name":"Algebra.FiniteType.iff_quotient_mvPolynomial","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\nS : Type uS\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ Iff (Algebra.FiniteType R S) (Exists fun s => Exists fun f => Function.Surjective ⇑f)","decl":"/-- A commutative algebra is finitely generated if and only if it is a quotient\nof a polynomial ring whose variables are indexed by a finset. -/\ntheorem iff_quotient_mvPolynomial :\n    FiniteType R S ↔\n      ∃ (s : Finset S) (f : MvPolynomial { x // x ∈ s } R →ₐ[R] S), Surjective f := by\n  constructor\n  · rintro ⟨s, hs⟩\n    use s, MvPolynomial.aeval (↑)\n    intro x\n    have hrw : (↑s : Set S) = fun x : S => x ∈ s.val := rfl\n    rw [← Set.mem_range, ← AlgHom.coe_range, ← adjoin_eq_range]\n    simp_rw [← hrw, hs]\n    exact Set.mem_univ x\n  · rintro ⟨s, ⟨f, hsur⟩⟩\n    exact FiniteType.of_surjective (FiniteType.mvPolynomial R { x // x ∈ s }) f hsur\n\n"}
{"name":"Algebra.FiniteType.iff_quotient_freeAlgebra'","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Iff (Algebra.FiniteType R A) (Exists fun ι => Exists fun x => Exists fun f => Function.Surjective ⇑f)","decl":"/-- An algebra is finitely generated if and only if it is a quotient\nof a polynomial ring whose variables are indexed by a fintype. -/\ntheorem iff_quotient_freeAlgebra' : FiniteType R A ↔\n    ∃ (ι : Type uA) (_ : Fintype ι) (f : FreeAlgebra R ι →ₐ[R] A), Surjective f := by\n  constructor\n  · rw [iff_quotient_freeAlgebra]\n    rintro ⟨s, ⟨f, hsur⟩⟩\n    use { x : A // x ∈ s }, inferInstance, f\n  · rintro ⟨ι, ⟨hfintype, ⟨f, hsur⟩⟩⟩\n    letI : Fintype ι := hfintype\n    exact FiniteType.of_surjective (FiniteType.freeAlgebra R ι) f hsur\n\n"}
{"name":"Algebra.FiniteType.iff_quotient_mvPolynomial'","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\nS : Type uS\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ Iff (Algebra.FiniteType R S) (Exists fun ι => Exists fun x => Exists fun f => Function.Surjective ⇑f)","decl":"/-- A commutative algebra is finitely generated if and only if it is a quotient\nof a polynomial ring whose variables are indexed by a fintype. -/\ntheorem iff_quotient_mvPolynomial' : FiniteType R S ↔\n    ∃ (ι : Type uS) (_ : Fintype ι) (f : MvPolynomial ι R →ₐ[R] S), Surjective f := by\n  constructor\n  · rw [iff_quotient_mvPolynomial]\n    rintro ⟨s, ⟨f, hsur⟩⟩\n    use { x : S // x ∈ s }, inferInstance, f\n  · rintro ⟨ι, ⟨hfintype, ⟨f, hsur⟩⟩⟩\n    letI : Fintype ι := hfintype\n    exact FiniteType.of_surjective (FiniteType.mvPolynomial R ι) f hsur\n\n"}
{"name":"Algebra.FiniteType.iff_quotient_mvPolynomial''","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\nS : Type uS\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ Iff (Algebra.FiniteType R S) (Exists fun n => Exists fun f => Function.Surjective ⇑f)","decl":"/-- A commutative algebra is finitely generated if and only if it is a quotient of a polynomial ring\nin `n` variables. -/\ntheorem iff_quotient_mvPolynomial'' :\n    FiniteType R S ↔ ∃ (n : ℕ) (f : MvPolynomial (Fin n) R →ₐ[R] S), Surjective f := by\n  constructor\n  · rw [iff_quotient_mvPolynomial']\n    rintro ⟨ι, hfintype, ⟨f, hsur⟩⟩\n    have equiv := MvPolynomial.renameEquiv R (Fintype.equivFin ι)\n    exact ⟨Fintype.card ι, AlgHom.comp f equiv.symm.toAlgHom, by simpa using hsur⟩\n  · rintro ⟨n, ⟨f, hsur⟩⟩\n    exact FiniteType.of_surjective (FiniteType.mvPolynomial R (Fin n)) f hsur\n\n"}
{"name":"Algebra.FiniteType.prod","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nhA : Algebra.FiniteType R A\nhB : Algebra.FiniteType R B\n⊢ Algebra.FiniteType R (Prod A B)","decl":"instance prod [hA : FiniteType R A] [hB : FiniteType R B] : FiniteType R (A × B) :=\n  ⟨by rw [← Subalgebra.prod_top]; exact hA.1.prod hB.1⟩\n\n"}
{"name":"Algebra.FiniteType.isNoetherianRing","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nh : Algebra.FiniteType R S\ninst✝ : IsNoetherianRing R\n⊢ IsNoetherianRing S","decl":"theorem isNoetherianRing (R S : Type*) [CommRing R] [CommRing S] [Algebra R S]\n    [h : Algebra.FiniteType R S] [IsNoetherianRing R] : IsNoetherianRing S := by\n  obtain ⟨s, hs⟩ := h.1\n  apply\n    isNoetherianRing_of_surjective (MvPolynomial s R) S\n      (MvPolynomial.aeval (↑) : MvPolynomial s R →ₐ[R] S).toRingHom\n  erw [← Set.range_eq_univ, ← AlgHom.coe_range, ←\n    Algebra.adjoin_range_eq_range_aeval, Subtype.range_coe_subtype, Finset.setOf_mem, hs]\n  rfl\n\n"}
{"name":"Subalgebra.fg_iff_finiteType","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nS : Subalgebra R A\n⊢ Iff S.FG (Algebra.FiniteType R (Subtype fun x => Membership.mem S x))","decl":"theorem _root_.Subalgebra.fg_iff_finiteType (S : Subalgebra R A) : S.FG ↔ Algebra.FiniteType R S :=\n  S.fg_top.symm.trans ⟨fun h => ⟨h⟩, fun h => h.out⟩\n\n"}
{"name":"RingHom.Finite.finiteType","module":"Mathlib.RingTheory.FiniteType","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommRing A\ninst✝ : CommRing B\nf : RingHom A B\nhf : f.Finite\n⊢ f.FiniteType","decl":"theorem finiteType {f : A →+* B} (hf : f.Finite) : FiniteType f :=\n  @Module.Finite.finiteType _ _ _ _ f.toAlgebra hf\n\n"}
{"name":"RingHom.FiniteType.id","module":"Mathlib.RingTheory.FiniteType","initialProofState":"A : Type u_1\ninst✝ : CommRing A\n⊢ (RingHom.id A).FiniteType","decl":"theorem id : FiniteType (RingHom.id A) :=\n  Algebra.FiniteType.self A\n\n"}
{"name":"RingHom.FiniteType.comp_surjective","module":"Mathlib.RingTheory.FiniteType","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : CommRing C\nf : RingHom A B\ng : RingHom B C\nhf : f.FiniteType\nhg : Function.Surjective ⇑g\n⊢ (g.comp f).FiniteType","decl":"theorem comp_surjective {f : A →+* B} {g : B →+* C} (hf : f.FiniteType) (hg : Surjective g) :\n    (g.comp f).FiniteType := by\n  algebraize_only [f, g.comp f]\n  exact Algebra.FiniteType.of_surjective hf\n    { g with\n      toFun := g\n      commutes' := fun a => rfl }\n    hg\n\n"}
{"name":"RingHom.FiniteType.of_surjective","module":"Mathlib.RingTheory.FiniteType","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommRing A\ninst✝ : CommRing B\nf : RingHom A B\nhf : Function.Surjective ⇑f\n⊢ f.FiniteType","decl":"theorem of_surjective (f : A →+* B) (hf : Surjective f) : f.FiniteType := by\n  rw [← f.comp_id]\n  exact (id A).comp_surjective hf\n\n"}
{"name":"RingHom.FiniteType.comp","module":"Mathlib.RingTheory.FiniteType","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : CommRing C\ng : RingHom B C\nf : RingHom A B\nhg : g.FiniteType\nhf : f.FiniteType\n⊢ (g.comp f).FiniteType","decl":"theorem comp {g : B →+* C} {f : A →+* B} (hg : g.FiniteType) (hf : f.FiniteType) :\n    (g.comp f).FiniteType := by\n  algebraize_only [f, g, g.comp f]\n  exact Algebra.FiniteType.trans hf hg\n\n"}
{"name":"RingHom.FiniteType.of_finite","module":"Mathlib.RingTheory.FiniteType","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommRing A\ninst✝ : CommRing B\nf : RingHom A B\nhf : f.Finite\n⊢ f.FiniteType","decl":"theorem of_finite {f : A →+* B} (hf : f.Finite) : f.FiniteType :=\n  @Module.Finite.finiteType _ _ _ _ f.toAlgebra hf\n\n"}
{"name":"RingHom.Finite.to_finiteType","module":"Mathlib.RingTheory.FiniteType","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommRing A\ninst✝ : CommRing B\nf : RingHom A B\nhf : f.Finite\n⊢ f.FiniteType","decl":"alias _root_.RingHom.Finite.to_finiteType := of_finite\n\n"}
{"name":"RingHom.FiniteType.of_comp_finiteType","module":"Mathlib.RingTheory.FiniteType","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : CommRing C\nf : RingHom A B\ng : RingHom B C\nh : (g.comp f).FiniteType\n⊢ g.FiniteType","decl":"theorem of_comp_finiteType {f : A →+* B} {g : B →+* C} (h : (g.comp f).FiniteType) :\n    g.FiniteType := by\n  algebraize [f, g, g.comp f]\n  exact Algebra.FiniteType.of_restrictScalars_finiteType A B C\n\n"}
{"name":"AlgHom.Finite.finiteType","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\nhf : f.Finite\n⊢ f.FiniteType","decl":"theorem finiteType {f : A →ₐ[R] B} (hf : f.Finite) : FiniteType f :=\n  RingHom.Finite.finiteType hf\n\n"}
{"name":"AlgHom.FiniteType.id","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ (AlgHom.id R A).FiniteType","decl":"theorem id : FiniteType (AlgHom.id R A) :=\n  RingHom.FiniteType.id A\n\n"}
{"name":"AlgHom.FiniteType.comp","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : CommRing C\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R C\ng : AlgHom R B C\nf : AlgHom R A B\nhg : g.FiniteType\nhf : f.FiniteType\n⊢ (g.comp f).FiniteType","decl":"theorem comp {g : B →ₐ[R] C} {f : A →ₐ[R] B} (hg : g.FiniteType) (hf : f.FiniteType) :\n    (g.comp f).FiniteType :=\n  RingHom.FiniteType.comp hg hf\n\n"}
{"name":"AlgHom.FiniteType.comp_surjective","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : CommRing C\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R C\nf : AlgHom R A B\ng : AlgHom R B C\nhf : f.FiniteType\nhg : Function.Surjective ⇑g\n⊢ (g.comp f).FiniteType","decl":"theorem comp_surjective {f : A →ₐ[R] B} {g : B →ₐ[R] C} (hf : f.FiniteType) (hg : Surjective g) :\n    (g.comp f).FiniteType :=\n  RingHom.FiniteType.comp_surjective hf hg\n\n"}
{"name":"AlgHom.FiniteType.of_surjective","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\nhf : Function.Surjective ⇑f\n⊢ f.FiniteType","decl":"theorem of_surjective (f : A →ₐ[R] B) (hf : Surjective f) : f.FiniteType :=\n  RingHom.FiniteType.of_surjective f.toRingHom hf\n\n"}
{"name":"AlgHom.FiniteType.of_comp_finiteType","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : CommRing C\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R C\nf : AlgHom R A B\ng : AlgHom R B C\nh : (g.comp f).FiniteType\n⊢ g.FiniteType","decl":"theorem of_comp_finiteType {f : A →ₐ[R] B} {g : B →ₐ[R] C} (h : (g.comp f).FiniteType) :\n    g.FiniteType :=\n  RingHom.FiniteType.of_comp_finiteType h\n\n"}
{"name":"AddMonoidAlgebra.mem_adjoin_support","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : AddMonoid M\nf : AddMonoidAlgebra R M\n⊢ Membership.mem (Algebra.adjoin R (Set.image (AddMonoidAlgebra.of' R M) ↑f.support)) f","decl":"/-- An element of `R[M]` is in the subalgebra generated by its support. -/\ntheorem mem_adjoin_support (f : R[M]) : f ∈ adjoin R (of' R M '' f.support) := by\n  suffices span R (of' R M '' f.support) ≤\n      Subalgebra.toSubmodule (adjoin R (of' R M '' f.support)) by\n    exact this (mem_span_support f)\n  rw [Submodule.span_le]\n  exact subset_adjoin\n\n"}
{"name":"AddMonoidAlgebra.support_gen_of_gen","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : AddMonoid M\nS : Set (AddMonoidAlgebra R M)\nhS : Eq (Algebra.adjoin R S) Top.top\n⊢ Eq (Algebra.adjoin R (Set.iUnion fun f => Set.iUnion fun h => Set.image (AddMonoidAlgebra.of' R M) ↑f.support)) Top.top","decl":"/-- If a set `S` generates, as algebra, `R[M]`, then the set of supports of\nelements of `S` generates `R[M]`. -/\ntheorem support_gen_of_gen {S : Set R[M]} (hS : Algebra.adjoin R S = ⊤) :\n    Algebra.adjoin R (⋃ f ∈ S, of' R M '' (f.support : Set M)) = ⊤ := by\n  refine le_antisymm le_top ?_\n  rw [← hS, adjoin_le_iff]\n  intro f hf\n  have hincl :\n    of' R M '' f.support ⊆ ⋃ (g : R[M]) (_ : g ∈ S), of' R M '' g.support := by\n    intro s hs\n    exact Set.mem_iUnion₂.2 ⟨f, ⟨hf, hs⟩⟩\n  exact adjoin_mono hincl (mem_adjoin_support f)\n\n"}
{"name":"AddMonoidAlgebra.support_gen_of_gen'","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : AddMonoid M\nS : Set (AddMonoidAlgebra R M)\nhS : Eq (Algebra.adjoin R S) Top.top\n⊢ Eq (Algebra.adjoin R (Set.image (AddMonoidAlgebra.of' R M) (Set.iUnion fun f => Set.iUnion fun h => ↑f.support))) Top.top","decl":"/-- If a set `S` generates, as algebra, `R[M]`, then the image of the union of\nthe supports of elements of `S` generates `R[M]`. -/\ntheorem support_gen_of_gen' {S : Set R[M]} (hS : Algebra.adjoin R S = ⊤) :\n    Algebra.adjoin R (of' R M '' ⋃ f ∈ S, (f.support : Set M)) = ⊤ := by\n  suffices (of' R M '' ⋃ f ∈ S, (f.support : Set M)) = ⋃ f ∈ S, of' R M '' (f.support : Set M) by\n    rw [this]\n    exact support_gen_of_gen hS\n  simp only [Set.image_iUnion]\n\n"}
{"name":"AddMonoidAlgebra.exists_finset_adjoin_eq_top","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : CommRing R\ninst✝ : AddMonoid M\nh : Algebra.FiniteType R (AddMonoidAlgebra R M)\n⊢ Exists fun G => Eq (Algebra.adjoin R (Set.image (AddMonoidAlgebra.of' R M) ↑G)) Top.top","decl":"/-- If `R[M]` is of finite type, then there is a `G : Finset M` such that its\nimage generates, as algebra, `R[M]`. -/\ntheorem exists_finset_adjoin_eq_top [h : FiniteType R R[M]] :\n    ∃ G : Finset M, Algebra.adjoin R (of' R M '' G) = ⊤ := by\n  obtain ⟨S, hS⟩ := h\n  letI : DecidableEq M := Classical.decEq M\n  use Finset.biUnion S fun f => f.support\n  have : (Finset.biUnion S fun f => f.support : Set M) = ⋃ f ∈ S, (f.support : Set M) := by\n    simp only [Finset.set_biUnion_coe, Finset.coe_biUnion]\n  rw [this]\n  exact support_gen_of_gen' hS\n\n"}
{"name":"AddMonoidAlgebra.of'_mem_span","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddMonoid M\ninst✝ : Nontrivial R\nm : M\nS : Set M\n⊢ Iff (Membership.mem (Submodule.span R (Set.image (AddMonoidAlgebra.of' R M) S)) (AddMonoidAlgebra.of' R M m)) (Membership.mem S m)","decl":"/-- The image of an element `m : M` in `R[M]` belongs the submodule generated by\n`S : Set M` if and only if `m ∈ S`. -/\ntheorem of'_mem_span [Nontrivial R] {m : M} {S : Set M} :\n    of' R M m ∈ span R (of' R M '' S) ↔ m ∈ S := by\n  refine ⟨fun h => ?_, fun h => Submodule.subset_span <| Set.mem_image_of_mem (of R M) h⟩\n  erw [of', ← Finsupp.supported_eq_span_single, Finsupp.mem_supported,\n    Finsupp.support_single_ne_zero _ (one_ne_zero' R)] at h\n  simpa using h\n\n"}
{"name":"AddMonoidAlgebra.mem_closure_of_mem_span_closure","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddMonoid M\ninst✝ : Nontrivial R\nm : M\nS : Set M\nh : Membership.mem (Submodule.span R ↑(Submonoid.closure (Set.image (AddMonoidAlgebra.of' R M) S))) (AddMonoidAlgebra.of' R M m)\n⊢ Membership.mem (AddSubmonoid.closure S) m","decl":"/--\nIf the image of an element `m : M` in `R[M]` belongs the submodule generated by\nthe closure of some `S : Set M` then `m ∈ closure S`. -/\ntheorem mem_closure_of_mem_span_closure [Nontrivial R] {m : M} {S : Set M}\n    (h : of' R M m ∈ span R (Submonoid.closure (of' R M '' S) : Set R[M])) :\n    m ∈ closure S := by\n  suffices Multiplicative.ofAdd m ∈ Submonoid.closure (Multiplicative.toAdd ⁻¹' S) by\n    simpa [← toSubmonoid_closure]\n  let S' := @Submonoid.closure (Multiplicative M) Multiplicative.mulOneClass S\n  have h' : Submonoid.map (of R M) S' = Submonoid.closure ((fun x : M => (of R M) x) '' S) :=\n    MonoidHom.map_mclosure _ _\n  rw [Set.image_congr' (show ∀ x, of' R M x = of R M x from fun x => of'_eq_of x), ← h'] at h\n  simpa using of'_mem_span.1 h\n\n"}
{"name":"AddMonoidAlgebra.mvPolynomial_aeval_of_surjective_of_closure","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : CommSemiring R\nS : Set M\nhS : Eq (AddSubmonoid.closure S) Top.top\n⊢ Function.Surjective ⇑(MvPolynomial.aeval fun s => AddMonoidAlgebra.of' R M ↑s)","decl":"/-- If a set `S` generates an additive monoid `M`, then the image of `M` generates, as algebra,\n`R[M]`. -/\ntheorem mvPolynomial_aeval_of_surjective_of_closure [AddCommMonoid M] [CommSemiring R] {S : Set M}\n    (hS : closure S = ⊤) :\n    Function.Surjective\n      (MvPolynomial.aeval fun s : S => of' R M ↑s : MvPolynomial S R → R[M]) := by\n  intro f\n  induction' f using induction_on with m f g ihf ihg r f ih\n  · have : m ∈ closure S := hS.symm ▸ mem_top _\n    refine AddSubmonoid.closure_induction (fun m hm => ?_) ?_ ?_ this\n    · exact ⟨MvPolynomial.X ⟨m, hm⟩, MvPolynomial.aeval_X _ _⟩\n    · exact ⟨1, map_one _⟩\n    · rintro m₁ m₂ _ _ ⟨P₁, hP₁⟩ ⟨P₂, hP₂⟩\n      exact\n        ⟨P₁ * P₂, by\n          rw [map_mul, hP₁, hP₂, of_apply, of_apply, of_apply, single_mul_single,\n            one_mul]; rfl⟩\n  · rcases ihf with ⟨P, rfl⟩\n    rcases ihg with ⟨Q, rfl⟩\n    exact ⟨P + Q, map_add _ _ _⟩\n  · rcases ih with ⟨P, rfl⟩\n    exact ⟨r • P, map_smul _ _ _⟩\n\n"}
{"name":"AddMonoidAlgebra.freeAlgebra_lift_of_surjective_of_closure","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : CommSemiring R\nS : Set M\nhS : Eq (AddSubmonoid.closure S) Top.top\n⊢ Function.Surjective ⇑((FreeAlgebra.lift R) fun s => AddMonoidAlgebra.of' R M ↑s)","decl":"/-- If a set `S` generates an additive monoid `M`, then the image of `M` generates, as algebra,\n`R[M]`. -/\ntheorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}\n    (hS : closure S = ⊤) :\n    Function.Surjective\n      (FreeAlgebra.lift R fun s : S => of' R M ↑s : FreeAlgebra R S → R[M]) := by\n  intro f\n  induction' f using induction_on with m f g ihf ihg r f ih\n  · have : m ∈ closure S := hS.symm ▸ mem_top _\n    refine AddSubmonoid.closure_induction (fun m hm => ?_) ?_ ?_ this\n    · exact ⟨FreeAlgebra.ι R ⟨m, hm⟩, FreeAlgebra.lift_ι_apply _ _⟩\n    · exact ⟨1, map_one _⟩\n    · rintro m₁ m₂ _ _ ⟨P₁, hP₁⟩ ⟨P₂, hP₂⟩\n      exact\n        ⟨P₁ * P₂, by\n          rw [map_mul, hP₁, hP₂, of_apply, of_apply, of_apply, single_mul_single,\n            one_mul]; rfl⟩\n  · rcases ihf with ⟨P, rfl⟩\n    rcases ihg with ⟨Q, rfl⟩\n    exact ⟨P + Q, map_add _ _ _⟩\n  · rcases ih with ⟨P, rfl⟩\n    exact ⟨r • P, map_smul _ _ _⟩\n\n"}
{"name":"AddMonoidAlgebra.finiteType_of_fg","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : CommRing R\nh : AddMonoid.FG M\n⊢ Algebra.FiniteType R (AddMonoidAlgebra R M)","decl":"/-- If an additive monoid `M` is finitely generated then `R[M]` is of finite\ntype. -/\ninstance finiteType_of_fg [CommRing R] [h : AddMonoid.FG M] :\n    FiniteType R R[M] := by\n  obtain ⟨S, hS⟩ := h.out\n  exact (FiniteType.freeAlgebra R (S : Set M)).of_surjective\n      (FreeAlgebra.lift R fun s : (S : Set M) => of' R M ↑s)\n      (freeAlgebra_lift_of_surjective_of_closure hS)\n\n"}
{"name":"AddMonoidAlgebra.finiteType_iff_fg","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : AddMonoid M\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\n⊢ Iff (Algebra.FiniteType R (AddMonoidAlgebra R M)) (AddMonoid.FG M)","decl":"/-- An additive monoid `M` is finitely generated if and only if `R[M]` is of\nfinite type. -/\ntheorem finiteType_iff_fg [CommRing R] [Nontrivial R] :\n    FiniteType R R[M] ↔ AddMonoid.FG M := by\n  refine ⟨fun h => ?_, fun h => @AddMonoidAlgebra.finiteType_of_fg _ _ _ _ h⟩\n  obtain ⟨S, hS⟩ := @exists_finset_adjoin_eq_top R M _ _ h\n  refine AddMonoid.fg_def.2 ⟨S, (eq_top_iff' _).2 fun m => ?_⟩\n  have hm : of' R M m ∈ Subalgebra.toSubmodule (adjoin R (of' R M '' ↑S)) := by\n    simp only [hS, top_toSubmodule, Submodule.mem_top]\n  rw [adjoin_eq_span] at hm\n  exact mem_closure_of_mem_span_closure hm\n\n"}
{"name":"AddMonoidAlgebra.fg_of_finiteType","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : AddMonoid M\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\nh : Algebra.FiniteType R (AddMonoidAlgebra R M)\n⊢ AddMonoid.FG M","decl":"/-- If `R[M]` is of finite type then `M` is finitely generated. -/\ntheorem fg_of_finiteType [CommRing R] [Nontrivial R] [h : FiniteType R R[M]] :\n    AddMonoid.FG M :=\n  finiteType_iff_fg.1 h\n\n"}
{"name":"AddMonoidAlgebra.finiteType_iff_group_fg","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nG : Type u_3\ninst✝² : AddCommGroup G\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\n⊢ Iff (Algebra.FiniteType R (AddMonoidAlgebra R G)) (AddGroup.FG G)","decl":"/-- An additive group `G` is finitely generated if and only if `R[G]` is of\nfinite type. -/\ntheorem finiteType_iff_group_fg {G : Type*} [AddCommGroup G] [CommRing R] [Nontrivial R] :\n    FiniteType R R[G] ↔ AddGroup.FG G := by\n  simpa [AddGroup.fg_iff_addMonoid_fg] using finiteType_iff_fg\n\n"}
{"name":"MonoidAlgebra.mem_adjoin_support","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : Monoid M\nf : MonoidAlgebra R M\n⊢ Membership.mem (Algebra.adjoin R (Set.image ⇑(MonoidAlgebra.of R M) ↑f.support)) f","decl":"/-- An element of `MonoidAlgebra R M` is in the subalgebra generated by its support. -/\ntheorem mem_adjoin_support (f : MonoidAlgebra R M) : f ∈ adjoin R (of R M '' f.support) := by\n  suffices span R (of R M '' f.support) ≤ Subalgebra.toSubmodule (adjoin R (of R M '' f.support)) by\n    exact this (mem_span_support f)\n  rw [Submodule.span_le]\n  exact subset_adjoin\n\n"}
{"name":"MonoidAlgebra.support_gen_of_gen","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : Monoid M\nS : Set (MonoidAlgebra R M)\nhS : Eq (Algebra.adjoin R S) Top.top\n⊢ Eq (Algebra.adjoin R (Set.iUnion fun f => Set.iUnion fun h => Set.image ⇑(MonoidAlgebra.of R M) ↑f.support)) Top.top","decl":"/-- If a set `S` generates, as algebra, `MonoidAlgebra R M`, then the set of supports of elements\nof `S` generates `MonoidAlgebra R M`. -/\ntheorem support_gen_of_gen {S : Set (MonoidAlgebra R M)} (hS : Algebra.adjoin R S = ⊤) :\n    Algebra.adjoin R (⋃ f ∈ S, of R M '' (f.support : Set M)) = ⊤ := by\n  refine le_antisymm le_top ?_\n  rw [← hS, adjoin_le_iff]\n  intro f hf\n  -- Porting note: ⋃ notation did not work here. Was\n  -- ⋃ (g : MonoidAlgebra R M) (H : g ∈ S), (of R M '' g.support)\n  have hincl : (of R M '' f.support) ⊆\n      Set.iUnion fun (g : MonoidAlgebra R M)\n        => Set.iUnion fun (_ : g ∈ S) => (of R M '' g.support) := by\n    intro s hs\n    exact Set.mem_iUnion₂.2 ⟨f, ⟨hf, hs⟩⟩\n  exact adjoin_mono hincl (mem_adjoin_support f)\n\n"}
{"name":"MonoidAlgebra.support_gen_of_gen'","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : Monoid M\nS : Set (MonoidAlgebra R M)\nhS : Eq (Algebra.adjoin R S) Top.top\n⊢ Eq (Algebra.adjoin R (Set.image (⇑(MonoidAlgebra.of R M)) (Set.iUnion fun f => Set.iUnion fun h => ↑f.support))) Top.top","decl":"/-- If a set `S` generates, as algebra, `MonoidAlgebra R M`, then the image of the union of the\nsupports of elements of `S` generates `MonoidAlgebra R M`. -/\ntheorem support_gen_of_gen' {S : Set (MonoidAlgebra R M)} (hS : Algebra.adjoin R S = ⊤) :\n    Algebra.adjoin R (of R M '' ⋃ f ∈ S, (f.support : Set M)) = ⊤ := by\n  suffices (of R M '' ⋃ f ∈ S, (f.support : Set M)) = ⋃ f ∈ S, of R M '' (f.support : Set M) by\n    rw [this]\n    exact support_gen_of_gen hS\n  simp only [Set.image_iUnion]\n\n"}
{"name":"MonoidAlgebra.exists_finset_adjoin_eq_top","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : CommRing R\ninst✝ : Monoid M\nh : Algebra.FiniteType R (MonoidAlgebra R M)\n⊢ Exists fun G => Eq (Algebra.adjoin R (Set.image ⇑(MonoidAlgebra.of R M) ↑G)) Top.top","decl":"/-- If `MonoidAlgebra R M` is of finite type, then there is a `G : Finset M` such that its image\ngenerates, as algebra, `MonoidAlgebra R M`. -/\ntheorem exists_finset_adjoin_eq_top [h : FiniteType R (MonoidAlgebra R M)] :\n    ∃ G : Finset M, Algebra.adjoin R (of R M '' G) = ⊤ := by\n  obtain ⟨S, hS⟩ := h\n  letI : DecidableEq M := Classical.decEq M\n  use Finset.biUnion S fun f => f.support\n  have : (Finset.biUnion S fun f => f.support : Set M) = ⋃ f ∈ S, (f.support : Set M) := by\n    simp only [Finset.set_biUnion_coe, Finset.coe_biUnion]\n  rw [this]\n  exact support_gen_of_gen' hS\n\n"}
{"name":"MonoidAlgebra.of_mem_span_of_iff","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Monoid M\ninst✝ : Nontrivial R\nm : M\nS : Set M\n⊢ Iff (Membership.mem (Submodule.span R (Set.image (⇑(MonoidAlgebra.of R M)) S)) ((MonoidAlgebra.of R M) m)) (Membership.mem S m)","decl":"/-- The image of an element `m : M` in `MonoidAlgebra R M` belongs the submodule generated by\n`S : Set M` if and only if `m ∈ S`. -/\ntheorem of_mem_span_of_iff [Nontrivial R] {m : M} {S : Set M} :\n    of R M m ∈ span R (of R M '' S) ↔ m ∈ S := by\n  refine ⟨fun h => ?_, fun h => Submodule.subset_span <| Set.mem_image_of_mem (of R M) h⟩\n  erw [of, MonoidHom.coe_mk, ← Finsupp.supported_eq_span_single, Finsupp.mem_supported,\n    Finsupp.support_single_ne_zero _ (one_ne_zero' R)] at h\n  simpa using h\n\n"}
{"name":"MonoidAlgebra.mem_closure_of_mem_span_closure","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Monoid M\ninst✝ : Nontrivial R\nm : M\nS : Set M\nh : Membership.mem (Submodule.span R ↑(Submonoid.closure (Set.image (⇑(MonoidAlgebra.of R M)) S))) ((MonoidAlgebra.of R M) m)\n⊢ Membership.mem (Submonoid.closure S) m","decl":"/--\nIf the image of an element `m : M` in `MonoidAlgebra R M` belongs the submodule generated by the\nclosure of some `S : Set M` then `m ∈ closure S`. -/\ntheorem mem_closure_of_mem_span_closure [Nontrivial R] {m : M} {S : Set M}\n    (h : of R M m ∈ span R (Submonoid.closure (of R M '' S) : Set (MonoidAlgebra R M))) :\n    m ∈ closure S := by\n  rw [← MonoidHom.map_mclosure] at h\n  simpa using of_mem_span_of_iff.1 h\n\n"}
{"name":"MonoidAlgebra.mvPolynomial_aeval_of_surjective_of_closure","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : CommMonoid M\ninst✝ : CommSemiring R\nS : Set M\nhS : Eq (Submonoid.closure S) Top.top\n⊢ Function.Surjective ⇑(MvPolynomial.aeval fun s => (MonoidAlgebra.of R M) ↑s)","decl":"/-- If a set `S` generates a monoid `M`, then the image of `M` generates, as algebra,\n`MonoidAlgebra R M`. -/\ntheorem mvPolynomial_aeval_of_surjective_of_closure [CommMonoid M] [CommSemiring R] {S : Set M}\n    (hS : closure S = ⊤) :\n    Function.Surjective\n      (MvPolynomial.aeval fun s : S => of R M ↑s : MvPolynomial S R → MonoidAlgebra R M) := by\n  intro f\n  induction' f using induction_on with m f g ihf ihg r f ih\n  · have : m ∈ closure S := hS.symm ▸ mem_top _\n    refine Submonoid.closure_induction (fun m hm => ?_) ?_ ?_ this\n    · exact ⟨MvPolynomial.X ⟨m, hm⟩, MvPolynomial.aeval_X _ _⟩\n    · exact ⟨1, map_one _⟩\n    · rintro m₁ m₂ _ _ ⟨P₁, hP₁⟩ ⟨P₂, hP₂⟩\n      exact\n        ⟨P₁ * P₂, by\n          rw [map_mul, hP₁, hP₂, of_apply, of_apply, of_apply, single_mul_single, one_mul]⟩\n  · rcases ihf with ⟨P, rfl⟩; rcases ihg with ⟨Q, rfl⟩\n    exact ⟨P + Q, map_add _ _ _⟩\n  · rcases ih with ⟨P, rfl⟩\n    exact ⟨r • P, map_smul _ _ _⟩\n\n\n"}
{"name":"MonoidAlgebra.freeAlgebra_lift_of_surjective_of_closure","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : Monoid M\ninst✝ : CommSemiring R\nS : Set M\nhS : Eq (Submonoid.closure S) Top.top\n⊢ Function.Surjective ⇑((FreeAlgebra.lift R) fun s => (MonoidAlgebra.of R M) ↑s)","decl":"/-- If a set `S` generates an additive monoid `M`, then the image of `M` generates, as algebra,\n`R[M]`. -/\ntheorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}\n    (hS : closure S = ⊤) :\n    Function.Surjective\n      (FreeAlgebra.lift R fun s : S => of R M ↑s : FreeAlgebra R S → MonoidAlgebra R M) := by\n  intro f\n  induction' f using induction_on with m f g ihf ihg r f ih\n  · have : m ∈ closure S := hS.symm ▸ mem_top _\n    refine Submonoid.closure_induction (fun m hm => ?_) ?_ ?_ this\n    · exact ⟨FreeAlgebra.ι R ⟨m, hm⟩, FreeAlgebra.lift_ι_apply _ _⟩\n    · exact ⟨1, map_one _⟩\n    · rintro m₁ m₂ _ _ ⟨P₁, hP₁⟩ ⟨P₂, hP₂⟩\n      exact\n        ⟨P₁ * P₂, by\n          rw [map_mul, hP₁, hP₂, of_apply, of_apply, of_apply, single_mul_single, one_mul]⟩\n  · rcases ihf with ⟨P, rfl⟩\n    rcases ihg with ⟨Q, rfl⟩\n    exact ⟨P + Q, map_add _ _ _⟩\n  · rcases ih with ⟨P, rfl⟩\n    exact ⟨r • P, map_smul _ _ _⟩\n\n"}
{"name":"MonoidAlgebra.finiteType_of_fg","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Monoid M\ninst✝¹ : CommRing R\ninst✝ : Monoid.FG M\n⊢ Algebra.FiniteType R (MonoidAlgebra R M)","decl":"/-- If a monoid `M` is finitely generated then `MonoidAlgebra R M` is of finite type. -/\ninstance finiteType_of_fg [CommRing R] [Monoid.FG M] : FiniteType R (MonoidAlgebra R M) :=\n  (AddMonoidAlgebra.finiteType_of_fg R (Additive M)).equiv (toAdditiveAlgEquiv R M).symm\n\n"}
{"name":"MonoidAlgebra.finiteType_iff_fg","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Monoid M\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\n⊢ Iff (Algebra.FiniteType R (MonoidAlgebra R M)) (Monoid.FG M)","decl":"/-- A monoid `M` is finitely generated if and only if `MonoidAlgebra R M` is of finite type. -/\ntheorem finiteType_iff_fg [CommRing R] [Nontrivial R] :\n    FiniteType R (MonoidAlgebra R M) ↔ Monoid.FG M :=\n  ⟨fun h =>\n    Monoid.fg_iff_add_fg.2 <|\n      AddMonoidAlgebra.finiteType_iff_fg.1 <| h.equiv <| toAdditiveAlgEquiv R M,\n    fun h => @MonoidAlgebra.finiteType_of_fg _ _ _ _ h⟩\n\n"}
{"name":"MonoidAlgebra.fg_of_finiteType","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Monoid M\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\nh : Algebra.FiniteType R (MonoidAlgebra R M)\n⊢ Monoid.FG M","decl":"/-- If `MonoidAlgebra R M` is of finite type then `M` is finitely generated. -/\ntheorem fg_of_finiteType [CommRing R] [Nontrivial R] [h : FiniteType R (MonoidAlgebra R M)] :\n    Monoid.FG M :=\n  finiteType_iff_fg.1 h\n\n"}
{"name":"MonoidAlgebra.finiteType_iff_group_fg","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\nG : Type u_3\ninst✝² : Group G\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\n⊢ Iff (Algebra.FiniteType R (MonoidAlgebra R G)) (Group.FG G)","decl":"/-- A group `G` is finitely generated if and only if `R[G]` is of finite type. -/\ntheorem finiteType_iff_group_fg {G : Type*} [Group G] [CommRing R] [Nontrivial R] :\n    FiniteType R (MonoidAlgebra R G) ↔ Group.FG G := by\n  simpa [Group.fg_iff_monoid_fg] using finiteType_iff_fg\n\n"}
{"name":"CommRing.orzechProperty","module":"Mathlib.RingTheory.FiniteType","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ OrzechProperty R","decl":"open Submodule Module Module.Finite in\n/-- Any commutative ring `R` satisfies the `OrzechProperty`, that is, for any finitely generated\n`R`-module `M`, any surjective homomorphism `f : N →ₗ[R] M` from a submodule `N` of `M` to `M`\nis injective.\n\nThis is a consequence of Noetherian case\n(`IsNoetherian.injective_of_surjective_of_injective`), which requires that `M` is a\nNoetherian module, but allows `R` to be non-commutative. The reduction of this result to\nNoetherian case is adapted from <https://math.stackexchange.com/a/1066110>:\nsuppose `{ m_j }` is a finite set of generator of `M`, for any `n : N` one can write\n`i n = ∑ j, b_j * m_j` for `{ b_j }` in `R`, here `i : N →ₗ[R] M` is the standard inclusion.\nWe can choose `{ n_j }` which are preimages of `{ m_j }` under `f`, and can choose\n`{ c_jl }` in `R` such that `i n_j = ∑ l, c_jl * m_l` for each `j`.\nNow let `A` be the subring of `R` generated by `{ b_j }` and `{ c_jl }`, then it is\nNoetherian. Let `N'` be the `A`-submodule of `N` generated by `n` and `{ n_j }`,\n`M'` be the `A`-submodule of `M` generated by `{ m_j }`,\nthen it's easy to see that `i` and `f` restrict to `N' →ₗ[A] M'`,\nand the restricted version of `f` is surjective, hence by Noetherian case,\nit is also injective, in particular, if `f n = 0`, then `n = 0`.\n\nSee also Orzech's original paper: *Onto endomorphisms are isomorphisms* [orzech1971]. -/\ninstance (priority := 100) CommRing.orzechProperty\n    (R : Type*) [CommRing R] : OrzechProperty R := by\n  refine ⟨fun {M} _ _ _ {N} f hf ↦ ?_⟩\n  letI := addCommMonoidToAddCommGroup R (M := M)\n  letI := addCommMonoidToAddCommGroup R (M := N)\n  let i := N.subtype\n  let hi : Function.Injective i := N.injective_subtype\n  refine LinearMap.ker_eq_bot.1 <| LinearMap.ker_eq_bot'.2 fun n hn ↦ ?_\n  obtain ⟨k, mj, hmj⟩ := exists_fin (R := R) (M := M)\n  rw [← surjective_piEquiv_apply_iff] at hmj\n  obtain ⟨b, hb⟩ := hmj (i n)\n  choose nj hnj using fun j ↦ hf (mj j)\n  choose c hc using fun j ↦ hmj (i (nj j))\n  let A := Subring.closure (Set.range b ∪ Set.range c.uncurry)\n  let N' := span A ({n} ∪ Set.range nj)\n  let M' := span A (Set.range mj)\n  haveI : IsNoetherianRing A := is_noetherian_subring_closure _\n    (.union (Set.finite_range _) (Set.finite_range _))\n  haveI : Module.Finite A M' := span_of_finite A (Set.finite_range _)\n  refine congr($((LinearMap.ker_eq_bot'.1 <| LinearMap.ker_eq_bot.2 <|\n    IsNoetherian.injective_of_surjective_of_injective\n      ((i.restrictScalars A).restrict fun x hx ↦ ?_ : N' →ₗ[A] M')\n      ((f.restrictScalars A).restrict fun x hx ↦ ?_ : N' →ₗ[A] M')\n      (fun _ _ h ↦ injective_subtype _ (hi congr(($h).1)))\n      fun ⟨x, hx⟩ ↦ ?_) ⟨n, (subset_span (by simp))⟩ (Subtype.val_injective hn)).1)\n  · induction hx using span_induction with\n    | mem x hx =>\n      change i x ∈ M'\n      simp only [Set.singleton_union, Set.mem_insert_iff, Set.mem_range] at hx\n      rcases hx with hx | ⟨j, rfl⟩\n      · rw [hx, ← hb, piEquiv_apply_apply]\n        refine Submodule.sum_mem _ fun j _ ↦ ?_\n        let b' : A := ⟨b j, Subring.subset_closure (by simp)⟩\n        rw [show b j • mj j = b' • mj j from rfl]\n        exact smul_mem _ _ (subset_span (by simp))\n      · rw [← hc, piEquiv_apply_apply]\n        refine Submodule.sum_mem _ fun j' _ ↦ ?_\n        let c' : A := ⟨c j j', Subring.subset_closure\n          (by simp [show ∃ a b, c a b = c j j' from ⟨j, j', rfl⟩])⟩\n        rw [show c j j' • mj j' = c' • mj j' from rfl]\n        exact smul_mem _ _ (subset_span (by simp))\n    | zero => simp\n    | add x _ y _ hx hy => rw [map_add]; exact add_mem hx hy\n    | smul a x _ hx => rw [map_smul]; exact smul_mem _ _ hx\n  · induction hx using span_induction with\n    | mem x hx =>\n      change f x ∈ M'\n      simp only [Set.singleton_union, Set.mem_insert_iff, Set.mem_range] at hx\n      rcases hx with hx | ⟨j, rfl⟩\n      · rw [hx, hn]; exact zero_mem _\n      · exact subset_span (by simp [hnj])\n    | zero => simp\n    | add x _ y _ hx hy => rw [map_add]; exact add_mem hx hy\n    | smul a x _ hx => rw [map_smul]; exact smul_mem _ _ hx\n  suffices x ∈ LinearMap.range ((f.restrictScalars A).domRestrict N') by\n    obtain ⟨a, ha⟩ := this\n    exact ⟨a, Subtype.val_injective ha⟩\n  induction hx using span_induction with\n  | mem x hx =>\n    obtain ⟨j, rfl⟩ := hx\n    exact ⟨⟨nj j, subset_span (by simp)⟩, hnj j⟩\n  | zero => exact zero_mem _\n  | add x y _ _ hx hy => exact add_mem hx hy\n  | smul a x _ hx => exact smul_mem _ a hx\n\n"}
