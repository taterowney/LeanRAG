{"name":"FiniteDimensional.of_injective","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : DivisionRing K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\nV₂ : Type v'\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\nf : LinearMap (RingHom.id K) V V₂\nw : Function.Injective ⇑f\ninst✝ : FiniteDimensional K V₂\n⊢ FiniteDimensional K V","decl":"/-- If the codomain of an injective linear map is finite dimensional, the domain must be as well. -/\ntheorem of_injective (f : V →ₗ[K] V₂) (w : Function.Injective f) [FiniteDimensional K V₂] :\n    FiniteDimensional K V :=\n  have : IsNoetherian K V₂ := IsNoetherian.iff_fg.mpr ‹_›\n  Module.Finite.of_injective f w\n\n"}
{"name":"FiniteDimensional.of_surjective","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : DivisionRing K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\nV₂ : Type v'\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\nf : LinearMap (RingHom.id K) V V₂\nw : Function.Surjective ⇑f\ninst✝ : FiniteDimensional K V\n⊢ FiniteDimensional K V₂","decl":"/-- If the domain of a surjective linear map is finite dimensional, the codomain must be as well. -/\ntheorem of_surjective (f : V →ₗ[K] V₂) (w : Function.Surjective f) [FiniteDimensional K V] :\n    FiniteDimensional K V₂ :=\n  Module.Finite.of_surjective f w\n\n"}
{"name":"FiniteDimensional.finiteDimensional_pi","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\ninst✝¹ : DivisionRing K\nι : Type u_1\ninst✝ : Finite ι\n⊢ FiniteDimensional K (ι → K)","decl":"instance finiteDimensional_pi {ι : Type*} [Finite ι] : FiniteDimensional K (ι → K) :=\n  Finite.pi\n\n"}
{"name":"FiniteDimensional.finiteDimensional_pi'","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\ninst✝⁴ : DivisionRing K\nι : Type u_1\ninst✝³ : Finite ι\nM : ι → Type u_2\ninst✝² : (i : ι) → AddCommGroup (M i)\ninst✝¹ : (i : ι) → Module K (M i)\ninst✝ : ∀ (i : ι), FiniteDimensional K (M i)\n⊢ FiniteDimensional K ((i : ι) → M i)","decl":"instance finiteDimensional_pi' {ι : Type*} [Finite ι] (M : ι → Type*) [∀ i, AddCommGroup (M i)]\n    [∀ i, Module K (M i)] [∀ i, FiniteDimensional K (M i)] : FiniteDimensional K (∀ i, M i) :=\n  Finite.pi\n\n"}
{"name":"FiniteDimensional.of_fintype_basis","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nι : Type w\ninst✝ : Finite ι\nh : Basis ι K V\n⊢ FiniteDimensional K V","decl":"/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem of_fintype_basis {ι : Type w} [Finite ι] (h : Basis ι K V) : FiniteDimensional K V :=\n  Module.Finite.of_basis h\n\n"}
{"name":"FiniteDimensional.of_finite_basis","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nι : Type w\ns : Set ι\nh : Basis (↑s) K V\nhs : s.Finite\n⊢ FiniteDimensional K V","decl":"/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem of_finite_basis {ι : Type w} {s : Set ι} (h : Basis s K V) (hs : Set.Finite s) :\n    FiniteDimensional K V :=\n  haveI := hs.fintype\n  of_fintype_basis h\n\n"}
{"name":"FiniteDimensional.finiteDimensional_submodule","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nS : Submodule K V\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem S x)","decl":"/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ninstance finiteDimensional_submodule [FiniteDimensional K V] (S : Submodule K V) :\n    FiniteDimensional K S := by\n  letI : IsNoetherian K V := iff_fg.2 ?_\n  · exact iff_fg.1 <| IsNoetherian.iff_rank_lt_aleph0.2 <|\n      (Submodule.rank_le _).trans_lt (rank_lt_aleph0 K V)\n  · infer_instance\n\n"}
{"name":"FiniteDimensional.finiteDimensional_quotient","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nS : Submodule K V\n⊢ FiniteDimensional K (HasQuotient.Quotient V S)","decl":"/-- A quotient of a finite-dimensional space is also finite-dimensional. -/\ninstance finiteDimensional_quotient [FiniteDimensional K V] (S : Submodule K V) :\n    FiniteDimensional K (V ⧸ S) :=\n  Module.Finite.quotient K S\n\n"}
{"name":"FiniteDimensional.of_finrank_pos","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nh : LT.lt 0 (Module.finrank K V)\n⊢ FiniteDimensional K V","decl":"theorem of_finrank_pos (h : 0 < finrank K V) : FiniteDimensional K V :=\n  Module.finite_of_finrank_pos h\n\n"}
{"name":"FiniteDimensional.of_finrank_eq_succ","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nn : Nat\nhn : Eq (Module.finrank K V) n.succ\n⊢ FiniteDimensional K V","decl":"theorem of_finrank_eq_succ {n : ℕ} (hn : finrank K V = n.succ) :\n    FiniteDimensional K V :=\n  Module.finite_of_finrank_eq_succ hn\n\n"}
{"name":"FiniteDimensional.of_fact_finrank_eq_succ","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nn : Nat\nhn : Fact (Eq (Module.finrank K V) (HAdd.hAdd n 1))\n⊢ FiniteDimensional K V","decl":"/-- We can infer `FiniteDimensional K V` in the presence of `[Fact (finrank K V = n + 1)]`. Declare\nthis as a local instance where needed. -/\ntheorem of_fact_finrank_eq_succ (n : ℕ) [hn : Fact (finrank K V = n + 1)] :\n    FiniteDimensional K V :=\n  of_finrank_eq_succ hn.out\n\n"}
{"name":"Module.finrank_eq_rank'","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\n⊢ Eq (↑(Module.finrank K V)) (Module.rank K V)","decl":"/-- In a finite-dimensional space, its dimension (seen as a cardinal) coincides with its\n`finrank`. This is a copy of `finrank_eq_rank _ _` which creates easier typeclass searches. -/\ntheorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=\n  finrank_eq_rank _ _\n\n"}
{"name":"Module.finrank_of_infinite_dimensional","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nh : Not (FiniteDimensional K V)\n⊢ Eq (Module.finrank K V) 0","decl":"theorem finrank_of_infinite_dimensional (h : ¬FiniteDimensional K V) : finrank K V = 0 :=\n  Module.finrank_of_not_finite h\n\n"}
{"name":"Module.finiteDimensional_iff_of_rank_eq_nsmul","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\nW : Type v\ninst✝¹ : AddCommGroup W\ninst✝ : Module K W\nn : Nat\nhn : Ne n 0\nhVW : Eq (Module.rank K V) (HSMul.hSMul n (Module.rank K W))\n⊢ Iff (FiniteDimensional K V) (FiniteDimensional K W)","decl":"theorem finiteDimensional_iff_of_rank_eq_nsmul {W} [AddCommGroup W] [Module K W] {n : ℕ}\n    (hn : n ≠ 0) (hVW : Module.rank K V = n • Module.rank K W) :\n    FiniteDimensional K V ↔ FiniteDimensional K W :=\n  Module.finite_iff_of_rank_eq_nsmul hn hVW\n\n"}
{"name":"Module.finrank_eq_card_basis'","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nι : Type w\nh : Basis ι K V\n⊢ Eq (↑(Module.finrank K V)) (Cardinal.mk ι)","decl":"/-- If a vector space is finite-dimensional, then the cardinality of any basis is equal to its\n`finrank`. -/\ntheorem finrank_eq_card_basis' [FiniteDimensional K V] {ι : Type w} (h : Basis ι K V) :\n    (finrank K V : Cardinal.{w}) = #ι :=\n  Module.mk_finrank_eq_card_basis h\n\n"}
{"name":"LinearIndependent.lt_aleph0_of_finiteDimensional","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nι : Type w\ninst✝ : FiniteDimensional K V\nv : ι → V\nh : LinearIndependent K v\n⊢ LT.lt (Cardinal.mk ι) Cardinal.aleph0","decl":"theorem _root_.LinearIndependent.lt_aleph0_of_finiteDimensional {ι : Type w} [FiniteDimensional K V]\n    {v : ι → V} (h : LinearIndependent K v) : #ι < ℵ₀ :=\n  h.lt_aleph0_of_finite\n\n"}
{"name":"Submodule.eq_top_of_finrank_eq","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nS : Submodule K V\nh : Eq (Module.finrank K (Subtype fun x => Membership.mem S x)) (Module.finrank K V)\n⊢ Eq S Top.top","decl":"/-- If a submodule has maximal dimension in a finite dimensional space, then it is equal to the\nwhole space. -/\ntheorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}\n    (h : finrank K S = finrank K V) : S = ⊤ := by\n  haveI : IsNoetherian K V := iff_fg.2 inferInstance\n  set bS := Basis.ofVectorSpace K S with bS_eq\n  have : LinearIndependent K ((↑) : ((↑) '' Basis.ofVectorSpaceIndex K S : Set V) → V) :=\n    LinearIndependent.image_subtype (f := Submodule.subtype S)\n      (by simpa [bS] using bS.linearIndependent) (by simp)\n  set b := Basis.extend this with b_eq\n  -- Porting note: `letI` now uses `this` so we need to give different names\n  letI i1 : Fintype (this.extend _) :=\n    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype\n  letI i2 : Fintype (((↑) : S → V) '' Basis.ofVectorSpaceIndex K S) :=\n    (LinearIndependent.set_finite_of_isNoetherian this).fintype\n  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=\n    (LinearIndependent.set_finite_of_isNoetherian\n      (by simpa [bS] using bS.linearIndependent)).fintype\n  have : (↑) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=\n    Set.eq_of_subset_of_card_le (this.subset_extend _)\n      (by\n        rw [Set.card_image_of_injective _ Subtype.coe_injective, ← finrank_eq_card_basis bS, ←\n            finrank_eq_card_basis b, h])\n  rw [← b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, ← this, ← Submodule.coe_subtype,\n    span_image]\n  have := bS.span_eq\n  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this\n  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]\n\n"}
{"name":"FiniteDimensional.finiteDimensional_self","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\ninst✝ : DivisionRing K\n⊢ FiniteDimensional K K","decl":"instance finiteDimensional_self : FiniteDimensional K K := inferInstance\n\n"}
{"name":"FiniteDimensional.span_of_finite","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nA : Set V\nhA : A.Finite\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (Submodule.span K A) x)","decl":"/-- The submodule generated by a finite set is finite-dimensional. -/\ntheorem span_of_finite {A : Set V} (hA : Set.Finite A) : FiniteDimensional K (Submodule.span K A) :=\n  Module.Finite.span_of_finite K hA\n\n"}
{"name":"FiniteDimensional.span_singleton","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nx : V\n⊢ FiniteDimensional K (Subtype fun x_1 => Membership.mem (Submodule.span K (Singleton.singleton x)) x_1)","decl":"/-- The submodule generated by a single element is finite-dimensional. -/\ninstance span_singleton (x : V) : FiniteDimensional K (K ∙ x) :=\n  Module.Finite.span_singleton K x\n\n"}
{"name":"FiniteDimensional.span_finset","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns : Finset V\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (Submodule.span K ↑s) x)","decl":"/-- The submodule generated by a finset is finite-dimensional. -/\ninstance span_finset (s : Finset V) : FiniteDimensional K (span K (s : Set V)) :=\n  Module.Finite.span_finset K s\n\n"}
{"name":"FiniteDimensional.instSubtypeMemSubmoduleMapLinearMapId","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : DivisionRing K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\nV₂ : Type v'\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\nf : LinearMap (RingHom.id K) V V₂\np : Submodule K V\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem p x)\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (Submodule.map f p) x)","decl":"/-- Pushforwards of finite-dimensional submodules are finite-dimensional. -/\ninstance (f : V →ₗ[K] V₂) (p : Submodule K V) [FiniteDimensional K p] :\n    FiniteDimensional K (p.map f) :=\n  Module.Finite.map _ _\n\n"}
{"name":"FiniteDimensional.exists_relation_sum_zero_pos_coefficient_of_finrank_succ_lt_card","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"L : Type u_1\ninst✝³ : LinearOrderedField L\nW : Type v\ninst✝² : AddCommGroup W\ninst✝¹ : Module L W\ninst✝ : FiniteDimensional L W\nt : Finset W\nh : LT.lt (HAdd.hAdd (Module.finrank L W) 1) t.card\n⊢ Exists fun f => And (Eq (t.sum fun e => HSMul.hSMul (f e) e) 0) (And (Eq (t.sum fun e => f e) 0) (Exists fun x => And (Membership.mem t x) (LT.lt 0 (f x))))","decl":"/-- A slight strengthening of `exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card`\navailable when working over an ordered field:\nwe can ensure a positive coefficient, not just a nonzero coefficient.\n-/\ntheorem exists_relation_sum_zero_pos_coefficient_of_finrank_succ_lt_card [FiniteDimensional L W]\n    {t : Finset W} (h : finrank L W + 1 < t.card) :\n    ∃ f : W → L, ∑ e ∈ t, f e • e = 0 ∧ ∑ e ∈ t, f e = 0 ∧ ∃ x ∈ t, 0 < f x := by\n  obtain ⟨f, sum, total, nonzero⟩ :=\n    Module.exists_nontrivial_relation_sum_zero_of_finrank_succ_lt_card h\n  exact ⟨f, sum, total, exists_pos_of_sum_zero_of_exists_nonzero f total nonzero⟩\n\n\n"}
{"name":"FiniteDimensional.basisSingleton_repr_apply","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nι : Type u_1\ninst✝ : Unique ι\nh : Eq (Module.finrank K V) 1\nv : V\nhv : Ne v 0\nw : V\n⊢ Eq ((FiniteDimensional.basisSingleton ι h v hv).repr w) (Finsupp.single Inhabited.default (HDiv.hDiv (((Module.basisUnique ι h).repr w) Inhabited.default) (((Module.basisUnique ι h).repr v) Inhabited.default)))","decl":"/-- In a vector space with dimension 1, each set {v} is a basis for `v ≠ 0`. -/\n@[simps repr_apply]\nnoncomputable def basisSingleton (ι : Type*) [Unique ι] (h : finrank K V = 1) (v : V)\n    (hv : v ≠ 0) : Basis ι K V :=\n  let b := Module.basisUnique ι h\n  let h : b.repr v default ≠ 0 := mt Module.basisUnique_repr_eq_zero_iff.mp hv\n  Basis.ofRepr\n    { toFun := fun w => Finsupp.single default (b.repr w default / b.repr v default)\n      invFun := fun f => f default • v\n      map_add' := by simp [add_div]\n      map_smul' := by simp [mul_div]\n      left_inv := fun w => by\n        apply_fun b.repr using b.repr.toEquiv.injective\n        apply_fun Equiv.finsuppUnique\n        simp only [LinearEquiv.map_smulₛₗ, Finsupp.coe_smul, Finsupp.single_eq_same,\n          smul_eq_mul, Pi.smul_apply, Equiv.finsuppUnique_apply]\n        exact div_mul_cancel₀ _ h\n      right_inv := fun f => by\n        ext\n        simp only [LinearEquiv.map_smulₛₗ, Finsupp.coe_smul, Finsupp.single_eq_same,\n          RingHom.id_apply, smul_eq_mul, Pi.smul_apply]\n        exact mul_div_cancel_right₀ _ h }\n\n"}
{"name":"FiniteDimensional.basisSingleton_apply","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nι : Type u_1\ninst✝ : Unique ι\nh : Eq (Module.finrank K V) 1\nv : V\nhv : Ne v 0\ni : ι\n⊢ Eq ((FiniteDimensional.basisSingleton ι h v hv) i) v","decl":"@[simp]\ntheorem basisSingleton_apply (ι : Type*) [Unique ι] (h : finrank K V = 1) (v : V) (hv : v ≠ 0)\n    (i : ι) : basisSingleton ι h v hv i = v := by\n  cases Unique.uniq ‹Unique ι› i\n  simp [basisSingleton]\n\n"}
{"name":"FiniteDimensional.range_basisSingleton","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nι : Type u_1\ninst✝ : Unique ι\nh : Eq (Module.finrank K V) 1\nv : V\nhv : Ne v 0\n⊢ Eq (Set.range ⇑(FiniteDimensional.basisSingleton ι h v hv)) (Singleton.singleton v)","decl":"@[simp]\ntheorem range_basisSingleton (ι : Type*) [Unique ι] (h : finrank K V = 1) (v : V) (hv : v ≠ 0) :\n    Set.range (basisSingleton ι h v hv) = {v} := by rw [Set.range_unique, basisSingleton_apply]\n\n"}
{"name":"FiniteDimensional.trans","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"F : Type u_1\nK : Type u_2\nA : Type u_3\ninst✝⁸ : DivisionRing F\ninst✝⁷ : DivisionRing K\ninst✝⁶ : AddCommGroup A\ninst✝⁵ : Module F K\ninst✝⁴ : Module K A\ninst✝³ : Module F A\ninst✝² : IsScalarTower F K A\ninst✝¹ : FiniteDimensional F K\ninst✝ : FiniteDimensional K A\n⊢ FiniteDimensional F A","decl":"theorem trans [FiniteDimensional F K] [FiniteDimensional K A] : FiniteDimensional F A :=\n  Module.Finite.trans K A\n\n"}
{"name":"FiniteDimensional.of_rank_eq_nat","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nn : Nat\nh : Eq (Module.rank K V) ↑n\n⊢ FiniteDimensional K V","decl":"theorem FiniteDimensional.of_rank_eq_nat {n : ℕ} (h : Module.rank K V = n) :\n    FiniteDimensional K V :=\n  Module.finite_of_rank_eq_nat h\n\n"}
{"name":"FiniteDimensional.of_rank_eq_zero","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nh : Eq (Module.rank K V) 0\n⊢ FiniteDimensional K V","decl":"theorem FiniteDimensional.of_rank_eq_zero (h : Module.rank K V = 0) : FiniteDimensional K V :=\n  Module.finite_of_rank_eq_zero h\n\n"}
{"name":"FiniteDimensional.of_rank_eq_one","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nh : Eq (Module.rank K V) 1\n⊢ FiniteDimensional K V","decl":"theorem FiniteDimensional.of_rank_eq_one (h : Module.rank K V = 1) : FiniteDimensional K V :=\n  Module.finite_of_rank_eq_one h\n\n"}
{"name":"finiteDimensional_bot","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem Bot.bot x)","decl":"instance finiteDimensional_bot : FiniteDimensional K (⊥ : Submodule K V) :=\n  .of_rank_eq_zero <| by simp\n\n"}
{"name":"Submodule.fg_iff_finiteDimensional","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\ns : Submodule K V\n⊢ Iff s.FG (FiniteDimensional K (Subtype fun x => Membership.mem s x))","decl":"/-- A submodule is finitely generated if and only if it is finite-dimensional -/\ntheorem fg_iff_finiteDimensional (s : Submodule K V) : s.FG ↔ FiniteDimensional K s :=\n  ⟨fun h => Module.finite_def.2 <| (fg_top s).2 h, fun h => (fg_top s).1 <| Module.finite_def.1 h⟩\n\n"}
{"name":"Submodule.finiteDimensional_of_le","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nS₁ S₂ : Submodule K V\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem S₂ x)\nh : LE.le S₁ S₂\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem S₁ x)","decl":"/-- A submodule contained in a finite-dimensional submodule is\nfinite-dimensional. -/\ntheorem finiteDimensional_of_le {S₁ S₂ : Submodule K V} [FiniteDimensional K S₂] (h : S₁ ≤ S₂) :\n    FiniteDimensional K S₁ :=\n  haveI : IsNoetherian K S₂ := iff_fg.2 inferInstance\n  iff_fg.1\n    (IsNoetherian.iff_rank_lt_aleph0.2 ((Submodule.rank_mono h).trans_lt (rank_lt_aleph0 K S₂)))\n\n"}
{"name":"Submodule.finiteDimensional_inf_left","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nS₁ S₂ : Submodule K V\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem S₁ x)\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (Min.min S₁ S₂) x)","decl":"/-- The inf of two submodules, the first finite-dimensional, is\nfinite-dimensional. -/\ninstance finiteDimensional_inf_left (S₁ S₂ : Submodule K V) [FiniteDimensional K S₁] :\n    FiniteDimensional K (S₁ ⊓ S₂ : Submodule K V) :=\n  finiteDimensional_of_le inf_le_left\n\n"}
{"name":"Submodule.finiteDimensional_inf_right","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nS₁ S₂ : Submodule K V\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem S₂ x)\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (Min.min S₁ S₂) x)","decl":"/-- The inf of two submodules, the second finite-dimensional, is\nfinite-dimensional. -/\ninstance finiteDimensional_inf_right (S₁ S₂ : Submodule K V) [FiniteDimensional K S₂] :\n    FiniteDimensional K (S₁ ⊓ S₂ : Submodule K V) :=\n  finiteDimensional_of_le inf_le_right\n\n"}
{"name":"Submodule.finiteDimensional_sup","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nS₁ S₂ : Submodule K V\nh₁ : FiniteDimensional K (Subtype fun x => Membership.mem S₁ x)\nh₂ : FiniteDimensional K (Subtype fun x => Membership.mem S₂ x)\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (Max.max S₁ S₂) x)","decl":"/-- The sup of two finite-dimensional submodules is\nfinite-dimensional. -/\ninstance finiteDimensional_sup (S₁ S₂ : Submodule K V) [h₁ : FiniteDimensional K S₁]\n    [h₂ : FiniteDimensional K S₂] : FiniteDimensional K (S₁ ⊔ S₂ : Submodule K V) := by\n  unfold FiniteDimensional at *\n  rw [finite_def] at *\n  exact (fg_top _).2 (((fg_top S₁).1 h₁).sup ((fg_top S₂).1 h₂))\n\n"}
{"name":"Submodule.finiteDimensional_finset_sup","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nι : Type u_1\ns : Finset ι\nS : ι → Submodule K V\ninst✝ : ∀ (i : ι), FiniteDimensional K (Subtype fun x => Membership.mem (S i) x)\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (s.sup S) x)","decl":"/-- The submodule generated by a finite supremum of finite dimensional submodules is\nfinite-dimensional.\n\nNote that strictly this only needs `∀ i ∈ s, FiniteDimensional K (S i)`, but that doesn't\nwork well with typeclass search. -/\ninstance finiteDimensional_finset_sup {ι : Type*} (s : Finset ι) (S : ι → Submodule K V)\n    [∀ i, FiniteDimensional K (S i)] : FiniteDimensional K (s.sup S : Submodule K V) := by\n  refine\n    @Finset.sup_induction _ _ _ _ s S (fun i => FiniteDimensional K ↑i) (finiteDimensional_bot K V)\n      ?_ fun i _ => by infer_instance\n  intro S₁ hS₁ S₂ hS₂\n  exact Submodule.finiteDimensional_sup S₁ S₂\n\n"}
{"name":"Submodule.finiteDimensional_iSup","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\nι : Sort u_1\ninst✝¹ : Finite ι\nS : ι → Submodule K V\ninst✝ : ∀ (i : ι), FiniteDimensional K (Subtype fun x => Membership.mem (S i) x)\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (iSup fun i => S i) x)","decl":"/-- The submodule generated by a supremum of finite dimensional submodules, indexed by a finite\nsort is finite-dimensional. -/\ninstance finiteDimensional_iSup {ι : Sort*} [Finite ι] (S : ι → Submodule K V)\n    [∀ i, FiniteDimensional K (S i)] : FiniteDimensional K ↑(⨆ i, S i) := by\n  cases nonempty_fintype (PLift ι)\n  rw [← iSup_plift_down, ← Finset.sup_univ_eq_iSup]\n  exact Submodule.finiteDimensional_finset_sup _ _\n\n"}
{"name":"LinearEquiv.finiteDimensional","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : DivisionRing K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\nV₂ : Type v'\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\nf : LinearEquiv (RingHom.id K) V V₂\ninst✝ : FiniteDimensional K V\n⊢ FiniteDimensional K V₂","decl":"/-- Finite dimensionality is preserved under linear equivalence. -/\nprotected theorem finiteDimensional (f : V ≃ₗ[K] V₂) [FiniteDimensional K V] :\n    FiniteDimensional K V₂ :=\n  Module.Finite.equiv f\n\n"}
{"name":"finiteDimensional_finsupp","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝⁴ : DivisionRing K\ninst✝³ : AddCommGroup V\ninst✝² : Module K V\nι : Type u_1\ninst✝¹ : Finite ι\ninst✝ : FiniteDimensional K V\n⊢ FiniteDimensional K (Finsupp ι V)","decl":"instance finiteDimensional_finsupp {ι : Type*} [Finite ι] [FiniteDimensional K V] :\n    FiniteDimensional K (ι →₀ V) :=\n  Module.Finite.finsupp\n\n"}
{"name":"Submodule.eq_of_le_of_finrank_le","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nS₁ S₂ : Submodule K V\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem S₂ x)\nhle : LE.le S₁ S₂\nhd : LE.le (Module.finrank K (Subtype fun x => Membership.mem S₂ x)) (Module.finrank K (Subtype fun x => Membership.mem S₁ x))\n⊢ Eq S₁ S₂","decl":"/-- If a submodule is contained in a finite-dimensional\nsubmodule with the same or smaller dimension, they are equal. -/\ntheorem eq_of_le_of_finrank_le {S₁ S₂ : Submodule K V} [FiniteDimensional K S₂] (hle : S₁ ≤ S₂)\n    (hd : finrank K S₂ ≤ finrank K S₁) : S₁ = S₂ := by\n  rw [← LinearEquiv.finrank_eq (Submodule.comapSubtypeEquivOfLe hle)] at hd\n  exact le_antisymm hle (Submodule.comap_subtype_eq_top.1\n    (eq_top_of_finrank_eq (le_antisymm (comap (Submodule.subtype S₂) S₁).finrank_le hd)))\n\n"}
{"name":"Submodule.eq_of_le_of_finrank_eq","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\nS₁ S₂ : Submodule K V\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem S₂ x)\nhle : LE.le S₁ S₂\nhd : Eq (Module.finrank K (Subtype fun x => Membership.mem S₁ x)) (Module.finrank K (Subtype fun x => Membership.mem S₂ x))\n⊢ Eq S₁ S₂","decl":"/-- If a submodule is contained in a finite-dimensional\nsubmodule with the same dimension, they are equal. -/\ntheorem eq_of_le_of_finrank_eq {S₁ S₂ : Submodule K V} [FiniteDimensional K S₂] (hle : S₁ ≤ S₂)\n    (hd : finrank K S₁ = finrank K S₂) : S₁ = S₂ :=\n  eq_of_le_of_finrank_le hle hd.ge\n\n"}
{"name":"Subalgebra.eq_of_le_of_finrank_le","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Ring L\ninst✝ : Algebra K L\nF E : Subalgebra K L\nhfin : FiniteDimensional K (Subtype fun x => Membership.mem E x)\nh_le : LE.le F E\nh_finrank : LE.le (Module.finrank K (Subtype fun x => Membership.mem E x)) (Module.finrank K (Subtype fun x => Membership.mem F x))\n⊢ Eq F E","decl":"/-- If a subalgebra is contained in a finite-dimensional\nsubalgebra with the same or smaller dimension, they are equal. -/\ntheorem eq_of_le_of_finrank_le (h_le : F ≤ E) (h_finrank : finrank K E ≤ finrank K F) : F = E :=\n  haveI : Module.Finite K (Subalgebra.toSubmodule E) := hfin\n  toSubmodule_injective <| Submodule.eq_of_le_of_finrank_le h_le h_finrank\n\n"}
{"name":"Subalgebra.eq_of_le_of_finrank_eq","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Ring L\ninst✝ : Algebra K L\nF E : Subalgebra K L\nhfin : FiniteDimensional K (Subtype fun x => Membership.mem E x)\nh_le : LE.le F E\nh_finrank : Eq (Module.finrank K (Subtype fun x => Membership.mem F x)) (Module.finrank K (Subtype fun x => Membership.mem E x))\n⊢ Eq F E","decl":"/-- If a subalgebra is contained in a finite-dimensional\nsubalgebra with the same dimension, they are equal. -/\ntheorem eq_of_le_of_finrank_eq (h_le : F ≤ E) (h_finrank : finrank K F = finrank K E) : F = E :=\n  eq_of_le_of_finrank_le h_le h_finrank.ge\n\n"}
{"name":"LinearMap.surjective_of_injective","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : LinearMap (RingHom.id K) V V\nhinj : Function.Injective ⇑f\n⊢ Function.Surjective ⇑f","decl":"/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem surjective_of_injective [FiniteDimensional K V] {f : V →ₗ[K] V} (hinj : Injective f) :\n    Surjective f := by\n  have h := rank_range_of_injective _ hinj\n  rw [← finrank_eq_rank, ← finrank_eq_rank, Nat.cast_inj] at h\n  exact range_eq_top.1 (eq_top_of_finrank_eq h)\n\n"}
{"name":"LinearMap.finiteDimensional_of_surjective","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : DivisionRing K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\nV₂ : Type v'\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\ninst✝ : FiniteDimensional K V\nf : LinearMap (RingHom.id K) V V₂\nhf : Eq (LinearMap.range f) Top.top\n⊢ FiniteDimensional K V₂","decl":"/-- The image under an onto linear map of a finite-dimensional space is also finite-dimensional. -/\ntheorem finiteDimensional_of_surjective [FiniteDimensional K V] (f : V →ₗ[K] V₂)\n    (hf : LinearMap.range f = ⊤) : FiniteDimensional K V₂ :=\n  Module.Finite.of_surjective f <| range_eq_top.1 hf\n\n"}
{"name":"LinearMap.finiteDimensional_range","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝⁵ : DivisionRing K\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module K V\nV₂ : Type v'\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module K V₂\ninst✝ : FiniteDimensional K V\nf : LinearMap (RingHom.id K) V V₂\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (LinearMap.range f) x)","decl":"/-- The range of a linear map defined on a finite-dimensional space is also finite-dimensional. -/\ninstance finiteDimensional_range [FiniteDimensional K V] (f : V →ₗ[K] V₂) :\n    FiniteDimensional K (LinearMap.range f) :=\n  Module.Finite.range f\n\n"}
{"name":"LinearMap.injective_iff_surjective","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : LinearMap (RingHom.id K) V V\n⊢ Iff (Function.Injective ⇑f) (Function.Surjective ⇑f)","decl":"/-- On a finite-dimensional space, a linear map is injective if and only if it is surjective. -/\ntheorem injective_iff_surjective [FiniteDimensional K V] {f : V →ₗ[K] V} :\n    Injective f ↔ Surjective f :=\n  ⟨surjective_of_injective, fun hsurj =>\n    let ⟨g, hg⟩ := f.exists_rightInverse_of_surjective (range_eq_top.2 hsurj)\n    have : Function.RightInverse g f := LinearMap.ext_iff.1 hg\n    (leftInverse_of_surjective_of_rightInverse (surjective_of_injective this.injective)\n        this).injective⟩\n\n"}
{"name":"LinearMap.injOn_iff_surjOn","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\np : Submodule K V\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem p x)\nf : LinearMap (RingHom.id K) V V\nh : ∀ (x : V), Membership.mem p x → Membership.mem p (f x)\n⊢ Iff (Set.InjOn ⇑f ↑p) (Set.SurjOn ⇑f ↑p ↑p)","decl":"lemma injOn_iff_surjOn {p : Submodule K V} [FiniteDimensional K p]\n    {f : V →ₗ[K] V} (h : ∀ x ∈ p, f x ∈ p) :\n    Set.InjOn f p ↔ Set.SurjOn f p p := by\n  rw [Set.injOn_iff_injective, ← Set.MapsTo.restrict_surjective_iff h]\n  change Injective (f.domRestrict p) ↔ Surjective (f.restrict h)\n  simp [disjoint_iff, ← injective_iff_surjective]\n\n"}
{"name":"LinearMap.ker_eq_bot_iff_range_eq_top","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : LinearMap (RingHom.id K) V V\n⊢ Iff (Eq (LinearMap.ker f) Bot.bot) (Eq (LinearMap.range f) Top.top)","decl":"theorem ker_eq_bot_iff_range_eq_top [FiniteDimensional K V] {f : V →ₗ[K] V} :\n    LinearMap.ker f = ⊥ ↔ LinearMap.range f = ⊤ := by\n  rw [range_eq_top, ker_eq_bot, injective_iff_surjective]\n\n"}
{"name":"LinearMap.mul_eq_one_of_mul_eq_one","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf g : LinearMap (RingHom.id K) V V\nhfg : Eq (HMul.hMul f g) 1\n⊢ Eq (HMul.hMul g f) 1","decl":"/-- In a finite-dimensional space, if linear maps are inverse to each other on one side then they\nare also inverse to each other on the other side. -/\ntheorem mul_eq_one_of_mul_eq_one [FiniteDimensional K V] {f g : V →ₗ[K] V} (hfg : f * g = 1) :\n    g * f = 1 := by\n  have ginj : Injective g :=\n    HasLeftInverse.injective ⟨f, fun x => show (f * g) x = (1 : V →ₗ[K] V) x by rw [hfg]⟩\n  let ⟨i, hi⟩ := g.exists_rightInverse_of_surjective\n    (range_eq_top.2 (injective_iff_surjective.1 ginj))\n  have : f * (g * i) = f * 1 := congr_arg _ hi\n  rw [← mul_assoc, hfg, one_mul, mul_one] at this; rwa [← this]\n\n"}
{"name":"LinearMap.mul_eq_one_comm","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf g : LinearMap (RingHom.id K) V V\n⊢ Iff (Eq (HMul.hMul f g) 1) (Eq (HMul.hMul g f) 1)","decl":"/-- In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\nthey are inverse to each other on the other side. -/\ntheorem mul_eq_one_comm [FiniteDimensional K V] {f g : V →ₗ[K] V} : f * g = 1 ↔ g * f = 1 :=\n  ⟨mul_eq_one_of_mul_eq_one, mul_eq_one_of_mul_eq_one⟩\n\n"}
{"name":"LinearMap.comp_eq_id_comm","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf g : LinearMap (RingHom.id K) V V\n⊢ Iff (Eq (f.comp g) LinearMap.id) (Eq (g.comp f) LinearMap.id)","decl":"/-- In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\nthey are inverse to each other on the other side. -/\ntheorem comp_eq_id_comm [FiniteDimensional K V] {f g : V →ₗ[K] V} : f.comp g = id ↔ g.comp f = id :=\n  mul_eq_one_comm\n\n"}
{"name":"LinearMap.comap_eq_sup_ker_of_disjoint","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\np : Submodule K V\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem p x)\nf : LinearMap (RingHom.id K) V V\nh : ∀ (x : V), Membership.mem p x → Membership.mem p (f x)\nh' : Disjoint p (LinearMap.ker f)\n⊢ Eq (Submodule.comap f p) (Max.max p (LinearMap.ker f))","decl":"theorem comap_eq_sup_ker_of_disjoint {p : Submodule K V} [FiniteDimensional K p] {f : V →ₗ[K] V}\n    (h : ∀ x ∈ p, f x ∈ p) (h' : Disjoint p (ker f)) :\n    p.comap f = p ⊔ ker f := by\n  refine le_antisymm (fun x hx ↦ ?_) (sup_le_iff.mpr ⟨h, ker_le_comap _⟩)\n  obtain ⟨⟨y, hy⟩, hxy⟩ :=\n    surjective_of_injective ((injective_restrict_iff_disjoint h).mpr h') ⟨f x, hx⟩\n  replace hxy : f y = f x := by simpa [Subtype.ext_iff] using hxy\n  exact Submodule.mem_sup.mpr ⟨y, hy, x - y, by simp [hxy], add_sub_cancel y x⟩\n\n"}
{"name":"LinearMap.ker_comp_eq_of_commute_of_disjoint_ker","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf g : LinearMap (RingHom.id K) V V\nh : Commute f g\nh' : Disjoint (LinearMap.ker f) (LinearMap.ker g)\n⊢ Eq (LinearMap.ker (f.comp g)) (Max.max (LinearMap.ker f) (LinearMap.ker g))","decl":"theorem ker_comp_eq_of_commute_of_disjoint_ker [FiniteDimensional K V] {f g : V →ₗ[K] V}\n    (h : Commute f g) (h' : Disjoint (ker f) (ker g)) :\n    ker (f ∘ₗ g) = ker f ⊔ ker g := by\n  suffices ∀ x, f x = 0 → f (g x) = 0 by rw [ker_comp, comap_eq_sup_ker_of_disjoint _ h']; simpa\n  intro x hx\n  rw [← comp_apply, ← mul_eq_comp, h.eq, mul_apply, hx, _root_.map_zero]\n\n"}
{"name":"LinearMap.ker_noncommProd_eq_of_supIndep_ker","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nι : Type u_1\nf : ι → LinearMap (RingHom.id K) V V\ns : Finset ι\ncomm : (↑s).Pairwise (Function.onFun Commute f)\nh : s.SupIndep fun i => LinearMap.ker (f i)\n⊢ Eq (LinearMap.ker (s.noncommProd f comm)) (iSup fun i => iSup fun h => LinearMap.ker (f i))","decl":"theorem ker_noncommProd_eq_of_supIndep_ker [FiniteDimensional K V] {ι : Type*} {f : ι → V →ₗ[K] V}\n    (s : Finset ι) (comm) (h : s.SupIndep fun i ↦ ker (f i)) :\n    ker (s.noncommProd f comm) = ⨆ i ∈ s, ker (f i) := by\n  classical\n  induction' s using Finset.induction_on with i s hi ih\n  · simp [one_eq_id]\n  replace ih : ker (Finset.noncommProd s f <| Set.Pairwise.mono (s.subset_insert i) comm) =\n      ⨆ x ∈ s, ker (f x) := ih _ (h.subset (s.subset_insert i))\n  rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hi, mul_eq_comp,\n    ker_comp_eq_of_commute_of_disjoint_ker]\n  · simp_rw [Finset.mem_insert_coe, iSup_insert, Finset.mem_coe, ih]\n  · exact s.noncommProd_commute _ _ _ fun j hj ↦\n      comm (s.mem_insert_self i) (Finset.mem_insert_of_mem hj) (by aesop)\n  · replace h := Finset.supIndep_iff_disjoint_erase.mp h i (s.mem_insert_self i)\n    simpa [ih, hi, Finset.sup_eq_iSup] using h\n\n"}
{"name":"LinearEquiv.coe_ofInjectiveEndo","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : LinearMap (RingHom.id K) V V\nh_inj : Function.Injective ⇑f\n⊢ Eq ⇑(LinearEquiv.ofInjectiveEndo f h_inj) ⇑f","decl":"@[simp]\ntheorem coe_ofInjectiveEndo (f : V →ₗ[K] V) (h_inj : Injective f) :\n    ⇑(ofInjectiveEndo f h_inj) = f :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofInjectiveEndo_right_inv","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : LinearMap (RingHom.id K) V V\nh_inj : Function.Injective ⇑f\n⊢ Eq (HMul.hMul f ↑(LinearEquiv.ofInjectiveEndo f h_inj).symm) 1","decl":"@[simp]\ntheorem ofInjectiveEndo_right_inv (f : V →ₗ[K] V) (h_inj : Injective f) :\n    f * (ofInjectiveEndo f h_inj).symm = 1 :=\n  LinearMap.ext <| (ofInjectiveEndo f h_inj).apply_symm_apply\n\n"}
{"name":"LinearEquiv.ofInjectiveEndo_left_inv","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : LinearMap (RingHom.id K) V V\nh_inj : Function.Injective ⇑f\n⊢ Eq (HMul.hMul (↑(LinearEquiv.ofInjectiveEndo f h_inj).symm) f) 1","decl":"@[simp]\ntheorem ofInjectiveEndo_left_inv (f : V →ₗ[K] V) (h_inj : Injective f) :\n    ((ofInjectiveEndo f h_inj).symm : V →ₗ[K] V) * f = 1 :=\n  LinearMap.ext <| (ofInjectiveEndo f h_inj).symm_apply_apply\n\n"}
{"name":"LinearMap.isUnit_iff_ker_eq_bot","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : LinearMap (RingHom.id K) V V\n⊢ Iff (IsUnit f) (Eq (LinearMap.ker f) Bot.bot)","decl":"theorem isUnit_iff_ker_eq_bot [FiniteDimensional K V] (f : V →ₗ[K] V) :\n    IsUnit f ↔ (LinearMap.ker f) = ⊥ := by\n  constructor\n  · rintro ⟨u, rfl⟩\n    exact LinearMap.ker_eq_bot_of_inverse u.inv_mul\n  · intro h_inj\n    rw [ker_eq_bot] at h_inj\n    exact ⟨⟨f, (LinearEquiv.ofInjectiveEndo f h_inj).symm.toLinearMap,\n      LinearEquiv.ofInjectiveEndo_right_inv f h_inj, LinearEquiv.ofInjectiveEndo_left_inv f h_inj⟩,\n      rfl⟩\n\n"}
{"name":"LinearMap.isUnit_iff_range_eq_top","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nf : LinearMap (RingHom.id K) V V\n⊢ Iff (IsUnit f) (Eq (LinearMap.range f) Top.top)","decl":"theorem isUnit_iff_range_eq_top [FiniteDimensional K V] (f : V →ₗ[K] V) :\n    IsUnit f ↔ (LinearMap.range f) = ⊤ := by\n  rw [isUnit_iff_ker_eq_bot, ker_eq_bot_iff_range_eq_top]\n\n"}
{"name":"finrank_zero_iff_forall_zero","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\n⊢ Iff (Eq (Module.finrank K V) 0) (∀ (x : V), Eq x 0)","decl":"theorem finrank_zero_iff_forall_zero [FiniteDimensional K V] : finrank K V = 0 ↔ ∀ x : V, x = 0 :=\n  Module.finrank_zero_iff.trans (subsingleton_iff_forall_eq 0)\n\n"}
{"name":"FiniteDimensional.exists_mul_eq_one","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝⁴ : Field F\ninst✝³ : Ring K\ninst✝² : IsDomain K\ninst✝¹ : Algebra F K\ninst✝ : FiniteDimensional F K\nx : K\nH : Ne x 0\n⊢ Exists fun y => Eq (HMul.hMul x y) 1","decl":"lemma FiniteDimensional.exists_mul_eq_one (F : Type*) {K : Type*} [Field F] [Ring K] [IsDomain K]\n    [Algebra F K] [FiniteDimensional F K] {x : K} (H : x ≠ 0) : ∃ y, x * y = 1 := by\n  have : Function.Surjective (LinearMap.mulLeft F x) :=\n    LinearMap.injective_iff_surjective.1 fun y z => ((mul_right_inj' H).1 : x * y = x * z → y = z)\n  exact this 1\n\n"}
{"name":"FiniteDimensional.isUnit","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝⁴ : Field F\ninst✝³ : Ring K\ninst✝² : IsDomain K\ninst✝¹ : Algebra F K\ninst✝ : FiniteDimensional F K\nx : K\nH : Ne x 0\n⊢ IsUnit x","decl":"lemma FiniteDimensional.isUnit (F : Type*) {K : Type*} [Field F] [Ring K] [IsDomain K]\n    [Algebra F K] [FiniteDimensional F K] {x : K} (H : x ≠ 0) : IsUnit x :=\n  let _ := divisionRingOfFiniteDimensional F K; H.isUnit\n\n"}
{"name":"finrank_span_singleton","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : V\nhv : Ne v 0\n⊢ Eq (Module.finrank K (Subtype fun x => Membership.mem (Submodule.span K (Singleton.singleton v)) x)) 1","decl":"theorem finrank_span_singleton {v : V} (hv : v ≠ 0) : finrank K (K ∙ v) = 1 := by\n  apply le_antisymm\n  · exact finrank_span_le_card ({v} : Set V)\n  · rw [Nat.succ_le_iff, finrank_pos_iff]\n    use ⟨v, mem_span_singleton_self v⟩, 0\n    apply Subtype.coe_ne_coe.mp\n    simp [hv]\n\n"}
{"name":"exists_smul_eq_of_finrank_eq_one","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nh : Eq (Module.finrank K V) 1\nx : V\nhx : Ne x 0\ny : V\n⊢ Exists fun c => Eq (HSMul.hSMul c x) y","decl":"/-- In a one-dimensional space, any vector is a multiple of any nonzero vector -/\nlemma exists_smul_eq_of_finrank_eq_one\n    (h : finrank K V = 1) {x : V} (hx : x ≠ 0) (y : V) :\n    ∃ (c : K), c • x = y := by\n  have : Submodule.span K {x} = ⊤ := by\n    have : FiniteDimensional K V := .of_finrank_eq_succ h\n    apply eq_top_of_finrank_eq\n    rw [h]\n    exact finrank_span_singleton hx\n  have : y ∈ Submodule.span K {x} := by rw [this]; exact mem_top\n  exact mem_span_singleton.1 this\n\n"}
{"name":"Set.finrank_mono","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\ns t : Set V\nh : HasSubset.Subset s t\n⊢ LE.le (Set.finrank K s) (Set.finrank K t)","decl":"theorem Set.finrank_mono [FiniteDimensional K V] {s t : Set V} (h : s ⊆ t) :\n    s.finrank K ≤ t.finrank K :=\n  Submodule.finrank_mono (span_mono h)\n\n"}
{"name":"finrank_eq_one_iff_of_nonzero","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : V\nnz : Ne v 0\n⊢ Iff (Eq (Module.finrank K V) 1) (Eq (Submodule.span K (Singleton.singleton v)) Top.top)","decl":"/-- A vector space with a nonzero vector `v` has dimension 1 iff `v` spans.\n-/\ntheorem finrank_eq_one_iff_of_nonzero (v : V) (nz : v ≠ 0) :\n    finrank K V = 1 ↔ span K ({v} : Set V) = ⊤ :=\n  ⟨fun h => by simpa using (basisSingleton Unit h v nz).span_eq, fun s =>\n    finrank_eq_card_basis\n      (Basis.mk (linearIndependent_singleton nz)\n        (by\n          convert s.ge  -- Porting note: added `.ge` to make things easier for `convert`\n          simp))⟩\n\n"}
{"name":"finrank_eq_one_iff_of_nonzero'","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nv : V\nnz : Ne v 0\n⊢ Iff (Eq (Module.finrank K V) 1) (∀ (w : V), Exists fun c => Eq (HSMul.hSMul c v) w)","decl":"/-- A module with a nonzero vector `v` has dimension 1 iff every vector is a multiple of `v`.\n-/\ntheorem finrank_eq_one_iff_of_nonzero' (v : V) (nz : v ≠ 0) :\n    finrank K V = 1 ↔ ∀ w : V, ∃ c : K, c • v = w := by\n  rw [finrank_eq_one_iff_of_nonzero v nz]\n  apply span_singleton_eq_top_iff\n\n-- We use the `LinearMap.CompatibleSMul` typeclass here, to encompass two situations:\n-- * `A = K`\n-- * `[Field K] [Algebra K A] [IsScalarTower K A V] [IsScalarTower K A W]`\n"}
{"name":"surjective_of_nonzero_of_finrank_eq_one","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝⁸ : DivisionRing K\ninst✝⁷ : AddCommGroup V\ninst✝⁶ : Module K V\nW : Type u_1\nA : Type u_2\ninst✝⁵ : Semiring A\ninst✝⁴ : Module A V\ninst✝³ : AddCommGroup W\ninst✝² : Module K W\ninst✝¹ : Module A W\ninst✝ : LinearMap.CompatibleSMul V W K A\nh : Eq (Module.finrank K W) 1\nf : LinearMap (RingHom.id A) V W\nw : Ne f 0\n⊢ Function.Surjective ⇑f","decl":"theorem surjective_of_nonzero_of_finrank_eq_one {W A : Type*} [Semiring A] [Module A V]\n    [AddCommGroup W] [Module K W] [Module A W] [LinearMap.CompatibleSMul V W K A]\n    (h : finrank K W = 1) {f : V →ₗ[A] W} (w : f ≠ 0) : Surjective f := by\n  change Surjective (f.restrictScalars K)\n  obtain ⟨v, n⟩ := DFunLike.ne_iff.mp w\n  intro z\n  obtain ⟨c, rfl⟩ := (finrank_eq_one_iff_of_nonzero' (f v) n).mp h z\n  exact ⟨c • v, by simp⟩\n\n"}
{"name":"Subalgebra.finiteDimensional_toSubmodule","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Ring E\ninst✝ : Algebra F E\nS : Subalgebra F E\n⊢ Iff (FiniteDimensional F (Subtype fun x => Membership.mem (Subalgebra.toSubmodule S) x)) (FiniteDimensional F (Subtype fun x => Membership.mem S x))","decl":"/-- A `Subalgebra` is `FiniteDimensional` iff it is `FiniteDimensional` as a submodule. -/\ntheorem Subalgebra.finiteDimensional_toSubmodule {S : Subalgebra F E} :\n    FiniteDimensional F (Subalgebra.toSubmodule S) ↔ FiniteDimensional F S :=\n  Iff.rfl\n\n"}
{"name":"FiniteDimensional.subalgebra_toSubmodule","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Ring E\ninst✝ : Algebra F E\nS : Subalgebra F E\na✝ : FiniteDimensional F (Subtype fun x => Membership.mem S x)\n⊢ FiniteDimensional F (Subtype fun x => Membership.mem (Subalgebra.toSubmodule S) x)","decl":"alias ⟨FiniteDimensional.of_subalgebra_toSubmodule, FiniteDimensional.subalgebra_toSubmodule⟩ :=\n  Subalgebra.finiteDimensional_toSubmodule\n\n"}
{"name":"FiniteDimensional.of_subalgebra_toSubmodule","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Ring E\ninst✝ : Algebra F E\nS : Subalgebra F E\na✝ : FiniteDimensional F (Subtype fun x => Membership.mem (Subalgebra.toSubmodule S) x)\n⊢ FiniteDimensional F (Subtype fun x => Membership.mem S x)","decl":"alias ⟨FiniteDimensional.of_subalgebra_toSubmodule, FiniteDimensional.subalgebra_toSubmodule⟩ :=\n  Subalgebra.finiteDimensional_toSubmodule\n\n"}
{"name":"FiniteDimensional.finiteDimensional_subalgebra","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝³ : Field F\ninst✝² : Ring E\ninst✝¹ : Algebra F E\ninst✝ : FiniteDimensional F E\nS : Subalgebra F E\n⊢ FiniteDimensional F (Subtype fun x => Membership.mem S x)","decl":"instance FiniteDimensional.finiteDimensional_subalgebra [FiniteDimensional F E]\n    (S : Subalgebra F E) : FiniteDimensional F S :=\n  FiniteDimensional.of_subalgebra_toSubmodule inferInstance\n\n"}
{"name":"Module.End.ker_pow_constant","module":"Mathlib.LinearAlgebra.FiniteDimensional.Defs","initialProofState":"K : Type u\nV : Type v\ninst✝² : DivisionRing K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nf : Module.End K V\nk : Nat\nh : Eq (LinearMap.ker (HPow.hPow f k)) (LinearMap.ker (HPow.hPow f k.succ))\nm : Nat\n⊢ Eq (LinearMap.ker (HPow.hPow f k)) (LinearMap.ker (HPow.hPow f (HAdd.hAdd k m)))","decl":"theorem ker_pow_constant {f : End K V} {k : ℕ}\n    (h : LinearMap.ker (f ^ k) = LinearMap.ker (f ^ k.succ)) :\n    ∀ m, LinearMap.ker (f ^ k) = LinearMap.ker (f ^ (k + m))\n  | 0 => by simp\n  | m + 1 => by\n    apply le_antisymm\n    · rw [add_comm, pow_add]\n      apply LinearMap.ker_le_ker_comp\n    · rw [ker_pow_constant h m, add_comm m 1, ← add_assoc, pow_add, pow_add f k m,\n        LinearMap.mul_eq_comp, LinearMap.mul_eq_comp, LinearMap.ker_comp, LinearMap.ker_comp, h,\n        Nat.add_one]\n\n"}
