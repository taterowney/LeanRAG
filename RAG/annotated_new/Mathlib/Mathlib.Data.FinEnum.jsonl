{"name":"FinEnum.mem_toList","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ninst✝ : FinEnum α\nx : α\n⊢ Membership.mem (FinEnum.toList α) x","decl":"@[simp]\ntheorem mem_toList [FinEnum α] (x : α) : x ∈ toList α := by\n  simp [toList]; exists equiv x; simp\n\n"}
{"name":"FinEnum.nodup_toList","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ninst✝ : FinEnum α\n⊢ (FinEnum.toList α).Nodup","decl":"@[simp]\ntheorem nodup_toList [FinEnum α] : List.Nodup (toList α) := by\n  simp [toList]; apply List.Nodup.map <;> [apply Equiv.injective; apply List.nodup_finRange]\n\n"}
{"name":"FinEnum.card_ulift","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ninst✝¹ : FinEnum (ULift.{u_1, u} α)\ninst✝ : FinEnum α\n⊢ Eq (FinEnum.card (ULift.{u_1, u} α)) (FinEnum.card α)","decl":"@[simp]\ntheorem card_ulift [FinEnum (ULift α)] [FinEnum α] : card (ULift α) = card α :=\n  Fin.equiv_iff_eq.mp ⟨equiv.symm.trans Equiv.ulift |>.trans equiv⟩\n\n"}
{"name":"FinEnum.equiv_up","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ninst✝ : FinEnum α\na : α\n⊢ Eq (FinEnum.equiv { down := a }) (FinEnum.equiv a)","decl":"@[simp] lemma equiv_up : equiv (ULift.up a) = equiv a := rfl\n"}
{"name":"FinEnum.equiv_down","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ninst✝ : FinEnum α\na' : ULift.{u_1, u} α\n⊢ Eq (FinEnum.equiv a'.down) (FinEnum.equiv a')","decl":"@[simp] lemma equiv_down : equiv a'.down = equiv a' := rfl\n"}
{"name":"FinEnum.up_equiv_symm","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ninst✝ : FinEnum α\ni : Fin (FinEnum.card α)\n⊢ Eq { down := FinEnum.equiv.symm i } (FinEnum.equiv.symm i)","decl":"@[simp] lemma up_equiv_symm : ULift.up (equiv.symm i) = (equiv (α := ULift α)).symm i := rfl\n"}
{"name":"FinEnum.down_equiv_symm","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ninst✝ : FinEnum α\ni : Fin (FinEnum.card α)\n⊢ Eq (FinEnum.equiv.symm i).down (FinEnum.equiv.symm i)","decl":"@[simp] lemma down_equiv_symm : ((equiv (α := ULift α)).symm i).down = equiv.symm i := rfl\n\n"}
{"name":"FinEnum.card_fin","module":"Mathlib.Data.FinEnum","initialProofState":"n : Nat\ninst✝ : FinEnum (Fin n)\n⊢ Eq (FinEnum.card (Fin n)) n","decl":"@[simp]\ntheorem card_fin {n} [FinEnum (Fin n)] : card (Fin n) = n := Fin.equiv_iff_eq.mp ⟨equiv.symm⟩\n\n"}
{"name":"FinEnum.Finset.mem_enum","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ninst✝ : DecidableEq α\ns : Finset α\nxs : List α\n⊢ Iff (Membership.mem (FinEnum.Finset.enum xs) s) (∀ (x : α), Membership.mem s x → Membership.mem xs x)","decl":"@[simp]\ntheorem Finset.mem_enum [DecidableEq α] (s : Finset α) (xs : List α) :\n    s ∈ Finset.enum xs ↔ ∀ x ∈ s, x ∈ xs := by\n  induction xs generalizing s with\n  | nil => simp [enum, eq_empty_iff_forall_not_mem]\n  | cons x xs ih =>\n      simp only [enum, List.bind_eq_flatMap, List.mem_flatMap, List.mem_cons, List.mem_singleton,\n        List.not_mem_nil, or_false, ih]\n      refine ⟨by aesop, fun hs => ⟨s.erase x, ?_⟩⟩\n      simp only [or_iff_not_imp_left] at hs\n      simp +contextual [eq_comm (a := s), or_iff_not_imp_left, hs]\n\n"}
{"name":"FinEnum.card_eq_fintypeCard","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ninst✝¹ : FinEnum α\ninst✝ : Fintype α\n⊢ Eq (FinEnum.card α) (Fintype.card α)","decl":"/-- The enumeration merely adds an ordering, leaving the cardinality as is. -/\ntheorem card_eq_fintypeCard {α : Type u} [FinEnum α] [Fintype α] : card α = Fintype.card α :=\n  Fintype.truncEquivFin α |>.inductionOn (fun h ↦ Fin.equiv_iff_eq.mp ⟨equiv.symm.trans h⟩)\n\n"}
{"name":"FinEnum.card_unique","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ne₁ e₂ : FinEnum α\n⊢ Eq (FinEnum.card α) (FinEnum.card α)","decl":"/-- Any two enumerations of the same type have the same length. -/\ntheorem card_unique {α : Type u} (e₁ e₂ : FinEnum α) : e₁.card = e₂.card :=\n  calc _\n  _ = _ := @card_eq_fintypeCard _ e₁ inferInstance\n  _ = _ := Fintype.card_congr' rfl\n  _ = _ := @card_eq_fintypeCard _ e₂ inferInstance |>.symm\n\n"}
{"name":"FinEnum.card_eq_zero_iff","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ninst✝ : FinEnum α\n⊢ Iff (Eq (FinEnum.card α) 0) (IsEmpty α)","decl":"/-- A type indexable by `Fin 0` is empty and vice versa. -/\ntheorem card_eq_zero_iff {α : Type u} [FinEnum α] : card α = 0 ↔ IsEmpty α :=\n  Eq.congr_left card_eq_fintypeCard |>.trans Fintype.card_eq_zero_iff\n\n"}
{"name":"FinEnum.card_eq_zero","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ninst✝¹ : FinEnum α\ninst✝ : IsEmpty α\n⊢ Eq (FinEnum.card α) 0","decl":"/-- Any enumeration of an empty type has length 0. -/\ntheorem card_eq_zero {α : Type u} [FinEnum α] [IsEmpty α] : card α = 0 :=\n  card_eq_zero_iff.mpr ‹_›\n\n"}
{"name":"FinEnum.card_pos_iff","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ninst✝ : FinEnum α\n⊢ Iff (LT.lt 0 (FinEnum.card α)) (Nonempty α)","decl":"/-- A type indexable by `Fin n` with positive `n` is inhabited and vice versa. -/\ntheorem card_pos_iff {α : Type u} [FinEnum α] : 0 < card α ↔ Nonempty α :=\n  card_eq_fintypeCard (α := α) ▸ Fintype.card_pos_iff\n\n"}
{"name":"FinEnum.card_pos","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u_1\ninst✝¹ : FinEnum α\ninst✝ : Nonempty α\n⊢ LT.lt 0 (FinEnum.card α)","decl":"/-- Any non-empty enumeration has more than one element. -/\nlemma card_pos {α : Type*} [FinEnum α] [Nonempty α] : 0 < card α :=\n  card_pos_iff.mpr ‹_›\n\n"}
{"name":"FinEnum.card_ne_zero","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u_1\ninst✝¹ : FinEnum α\ninst✝ : Nonempty α\n⊢ Ne (FinEnum.card α) 0","decl":"/-- No non-empty enumeration has 0 elements. -/\nlemma card_ne_zero {α : Type*} [FinEnum α] [Nonempty α] : card α ≠ 0 := card_pos.ne'\n\n"}
{"name":"FinEnum.card_eq_one","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u\ninst✝¹ : FinEnum α\ninst✝ : Unique α\n⊢ Eq (FinEnum.card α) 1","decl":"/-- Any enumeration of a type with unique inhabitant has length 1. -/\ntheorem card_eq_one (α : Type u) [FinEnum α] [Unique α] : card α = 1 :=\n  card_eq_fintypeCard.trans <| Fintype.card_eq_one_iff_nonempty_unique.mpr ⟨‹_›⟩\n\n"}
{"name":"List.mem_pi_toList","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u_1\ninst✝¹ : FinEnum α\nβ : α → Type u_2\ninst✝ : (a : α) → FinEnum (β a)\nxs : List α\nf : (a : α) → Membership.mem xs a → β a\n⊢ Membership.mem (xs.pi fun x => FinEnum.toList (β x)) f","decl":"theorem mem_pi_toList (xs : List α)\n    (f : ∀ a, a ∈ xs → β a) : f ∈ pi xs fun x => toList (β x) :=\n  (mem_pi _ _).mpr fun _ _ ↦ mem_toList _\n\n"}
{"name":"List.Pi.mem_enum","module":"Mathlib.Data.FinEnum","initialProofState":"α : Type u_1\ninst✝¹ : FinEnum α\nβ : α → Type u_2\ninst✝ : (a : α) → FinEnum (β a)\nf : (a : α) → β a\n⊢ Membership.mem (List.Pi.enum β) f","decl":"theorem Pi.mem_enum (f : ∀ a, β a) :\n    f ∈ Pi.enum β := by simpa [Pi.enum] using ⟨fun a _ => f a, mem_pi_toList _ _, rfl⟩\n\n"}
