{"name":"MeasureTheory.convolution_integrand_bound_right_of_le_of_subset","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedAddCommGroup E'\ninstâœâ¶ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œ E'\ninstâœÂ² : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalSpace G\nC : Real\nhC : âˆ€ (i : G), LE.le (Norm.norm (g i)) C\nx t : G\ns u : Set G\nhx : Membership.mem s x\nhu : HasSubset.Subset (HAdd.hAdd (Neg.neg (tsupport g)) s) u\nâŠ¢ LE.le (Norm.norm ((L (f t)) (g (HSub.hSub x t)))) (u.indicator (fun t => HMul.hMul (HMul.hMul (Norm.norm L) (Norm.norm (f t))) C) t)","decl":"theorem convolution_integrand_bound_right_of_le_of_subset {C : â„} (hC : âˆ€ i, â€–g iâ€– â‰¤ C) {x t : G}\n    {s u : Set G} (hx : x âˆˆ s) (hu : -tsupport g + s âŠ† u) :\n    â€–L (f t) (g (x - t))â€– â‰¤ u.indicator (fun t => â€–Lâ€– * â€–f tâ€– * C) t := by\n  -- Porting note: had to add `f := _`\n  refine le_indicator (f := fun t â†¦ â€–L (f t) (g (x - t))â€–) (fun t _ => ?_) (fun t ht => ?_) t\n  Â· apply_rules [L.le_of_opNormâ‚‚_le_of_le, le_rfl]\n  Â· have : x - t âˆ‰ support g := by\n      refine mt (fun hxt => hu ?_) ht\n      refine âŸ¨_, Set.neg_mem_neg.mpr (subset_closure hxt), _, hx, ?_âŸ©\n      simp only [neg_sub, sub_add_cancel]\n    simp only [nmem_support.mp this, (L _).map_zero, norm_zero, le_rfl]\n\n"}
{"name":"HasCompactSupport.convolution_integrand_bound_right_of_subset","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedAddCommGroup E'\ninstâœâ¶ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œ E'\ninstâœÂ² : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalSpace G\nhcg : HasCompactSupport g\nhg : Continuous g\nx t : G\ns u : Set G\nhx : Membership.mem s x\nhu : HasSubset.Subset (HAdd.hAdd (Neg.neg (tsupport g)) s) u\nâŠ¢ LE.le (Norm.norm ((L (f t)) (g (HSub.hSub x t)))) (u.indicator (fun t => HMul.hMul (HMul.hMul (Norm.norm L) (Norm.norm (f t))) (iSup fun i => Norm.norm (g i))) t)","decl":"theorem _root_.HasCompactSupport.convolution_integrand_bound_right_of_subset\n    (hcg : HasCompactSupport g) (hg : Continuous g)\n    {x t : G} {s u : Set G} (hx : x âˆˆ s) (hu : -tsupport g + s âŠ† u) :\n    â€–L (f t) (g (x - t))â€– â‰¤ u.indicator (fun t => â€–Lâ€– * â€–f tâ€– * â¨† i, â€–g iâ€–) t := by\n  refine convolution_integrand_bound_right_of_le_of_subset _ (fun i => ?_) hx hu\n  exact le_ciSup (hg.norm.bddAbove_range_of_hasCompactSupport hcg.norm) _\n\n"}
{"name":"HasCompactSupport.convolution_integrand_bound_right","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedAddCommGroup E'\ninstâœâ¶ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œ E'\ninstâœÂ² : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalSpace G\nhcg : HasCompactSupport g\nhg : Continuous g\nx t : G\ns : Set G\nhx : Membership.mem s x\nâŠ¢ LE.le (Norm.norm ((L (f t)) (g (HSub.hSub x t)))) ((HAdd.hAdd (Neg.neg (tsupport g)) s).indicator (fun t => HMul.hMul (HMul.hMul (Norm.norm L) (Norm.norm (f t))) (iSup fun i => Norm.norm (g i))) t)","decl":"theorem _root_.HasCompactSupport.convolution_integrand_bound_right (hcg : HasCompactSupport g)\n    (hg : Continuous g) {x t : G} {s : Set G} (hx : x âˆˆ s) :\n    â€–L (f t) (g (x - t))â€– â‰¤ (-tsupport g + s).indicator (fun t => â€–Lâ€– * â€–f tâ€– * â¨† i, â€–g iâ€–) t :=\n  hcg.convolution_integrand_bound_right_of_subset L hg hx Subset.rfl\n\n"}
{"name":"Continuous.convolution_integrand_fst","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œ E'\ninstâœÂ³ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : ContinuousSub G\nhg : Continuous g\nt : G\nâŠ¢ Continuous fun x => (L (f t)) (g (HSub.hSub x t))","decl":"theorem _root_.Continuous.convolution_integrand_fst [ContinuousSub G] (hg : Continuous g) (t : G) :\n    Continuous fun x => L (f t) (g (x - t)) :=\n  L.continuousâ‚‚.compâ‚‚ continuous_const <| hg.comp <| continuous_id.sub continuous_const\n\n"}
{"name":"HasCompactSupport.convolution_integrand_bound_left","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedAddCommGroup E'\ninstâœâ¶ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œ E'\ninstâœÂ² : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ¹ : AddGroup G\ninstâœ : TopologicalSpace G\nhcf : HasCompactSupport f\nhf : Continuous f\nx t : G\ns : Set G\nhx : Membership.mem s x\nâŠ¢ LE.le (Norm.norm ((L (f (HSub.hSub x t))) (g t))) ((HAdd.hAdd (Neg.neg (tsupport f)) s).indicator (fun t => HMul.hMul (HMul.hMul (Norm.norm L) (iSup fun i => Norm.norm (f i))) (Norm.norm (g t))) t)","decl":"theorem _root_.HasCompactSupport.convolution_integrand_bound_left (hcf : HasCompactSupport f)\n    (hf : Continuous f) {x t : G} {s : Set G} (hx : x âˆˆ s) :\n    â€–L (f (x - t)) (g t)â€– â‰¤\n      (-tsupport f + s).indicator (fun t => (â€–Lâ€– * â¨† i, â€–f iâ€–) * â€–g tâ€–) t := by\n  convert hcf.convolution_integrand_bound_right L.flip hf hx using 1\n  simp_rw [L.opNorm_flip, mul_right_comm]\n\n"}
{"name":"MeasureTheory.ConvolutionExistsAt.integrable","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedAddCommGroup E'\ninstâœâ¶ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œ E'\ninstâœÂ² : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ¹ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœ : Sub G\nx : G\nh : MeasureTheory.ConvolutionExistsAt f g x L Î¼\nâŠ¢ MeasureTheory.Integrable (fun t => (L (f t)) (g (HSub.hSub x t))) Î¼","decl":"variable {L} in\ntheorem ConvolutionExistsAt.integrable [Sub G] {x : G} (h : ConvolutionExistsAt f g x L Î¼) :\n    Integrable (fun t => L (f t) (g (x - t))) Î¼ :=\n  h\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.convolution_integrand'","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedAddCommGroup E'\ninstâœâ¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedSpace ğ•œ E'\ninstâœâµ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ´ : MeasurableSpace G\nÎ¼ Î½ : MeasureTheory.Measure G\ninstâœÂ³ : AddGroup G\ninstâœÂ² : MeasurableAddâ‚‚ G\ninstâœÂ¹ : MeasurableNeg G\ninstâœ : MeasureTheory.SFinite Î½\nhf : MeasureTheory.AEStronglyMeasurable f Î½\nhg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map (fun p => HSub.hSub p.1 p.2) (Î¼.prod Î½))\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun p => (L (f p.2)) (g (HSub.hSub p.1 p.2))) (Î¼.prod Î½)","decl":"theorem AEStronglyMeasurable.convolution_integrand' [MeasurableAddâ‚‚ G]\n    [MeasurableNeg G] [SFinite Î½] (hf : AEStronglyMeasurable f Î½)\n    (hg : AEStronglyMeasurable g <| map (fun p : G Ã— G => p.1 - p.2) (Î¼.prod Î½)) :\n    AEStronglyMeasurable (fun p : G Ã— G => L (f p.2) (g (p.1 - p.2))) (Î¼.prod Î½) :=\n  L.aestronglyMeasurable_compâ‚‚ hf.snd <| hg.comp_measurable measurable_sub\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.convolution_integrand_snd'","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedAddCommGroup E'\ninstâœâ¸ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œ E'\ninstâœâ´ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ³ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : MeasurableAdd G\ninstâœ : MeasurableNeg G\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nx : G\nhg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map (fun t => HSub.hSub x t) Î¼)\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun t => (L (f t)) (g (HSub.hSub x t))) Î¼","decl":"theorem AEStronglyMeasurable.convolution_integrand_snd'\n    (hf : AEStronglyMeasurable f Î¼) {x : G}\n    (hg : AEStronglyMeasurable g <| map (fun t => x - t) Î¼) :\n    AEStronglyMeasurable (fun t => L (f t) (g (x - t))) Î¼ :=\n  L.aestronglyMeasurable_compâ‚‚ hf <| hg.comp_measurable <| measurable_id.const_sub x\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.convolution_integrand_swap_snd'","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedAddCommGroup E'\ninstâœâ¸ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œ E'\ninstâœâ´ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ³ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : MeasurableAdd G\ninstâœ : MeasurableNeg G\nx : G\nhf : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map (fun t => HSub.hSub x t) Î¼)\nhg : MeasureTheory.AEStronglyMeasurable g Î¼\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun t => (L (f (HSub.hSub x t))) (g t)) Î¼","decl":"theorem AEStronglyMeasurable.convolution_integrand_swap_snd' {x : G}\n    (hf : AEStronglyMeasurable f <| map (fun t => x - t) Î¼) (hg : AEStronglyMeasurable g Î¼) :\n    AEStronglyMeasurable (fun t => L (f (x - t)) (g t)) Î¼ :=\n  L.aestronglyMeasurable_compâ‚‚ (hf.comp_measurable <| measurable_id.const_sub x) hg\n\n"}
{"name":"BddAbove.convolutionExistsAt'","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedAddCommGroup E'\ninstâœâ¸ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œ E'\ninstâœâ´ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ³ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : MeasurableAdd G\ninstâœ : MeasurableNeg G\nxâ‚€ : G\ns : Set G\nhbg : BddAbove (Set.image (fun i => Norm.norm (g i)) (Set.preimage (fun t => HAdd.hAdd (Neg.neg t) xâ‚€) s))\nhs : MeasurableSet s\nh2s : HasSubset.Subset (Function.support fun t => (L (f t)) (g (HSub.hSub xâ‚€ t))) s\nhf : MeasureTheory.IntegrableOn f s Î¼\nhmg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map (fun t => HSub.hSub xâ‚€ t) (Î¼.restrict s))\nâŠ¢ MeasureTheory.ConvolutionExistsAt f g xâ‚€ L Î¼","decl":"/-- A sufficient condition to prove that `f â‹†[L, Î¼] g` exists.\nWe assume that `f` is integrable on a set `s` and `g` is bounded and ae strongly measurable\non `xâ‚€ - s` (note that both properties hold if `g` is continuous with compact support). -/\ntheorem _root_.BddAbove.convolutionExistsAt' {xâ‚€ : G} {s : Set G}\n    (hbg : BddAbove ((fun i => â€–g iâ€–) '' ((fun t => -t + xâ‚€) â»Â¹' s))) (hs : MeasurableSet s)\n    (h2s : (support fun t => L (f t) (g (xâ‚€ - t))) âŠ† s) (hf : IntegrableOn f s Î¼)\n    (hmg : AEStronglyMeasurable g <| map (fun t => xâ‚€ - t) (Î¼.restrict s)) :\n    ConvolutionExistsAt f g xâ‚€ L Î¼ := by\n  rw [ConvolutionExistsAt]\n  rw [â† integrableOn_iff_integrable_of_support_subset h2s]\n  set s' := (fun t => -t + xâ‚€) â»Â¹' s\n  have : âˆ€áµ t : G âˆ‚Î¼.restrict s,\n      â€–L (f t) (g (xâ‚€ - t))â€– â‰¤ s.indicator (fun t => â€–Lâ€– * â€–f tâ€– * â¨† i : s', â€–g iâ€–) t := by\n    filter_upwards\n    refine le_indicator (fun t ht => ?_) fun t ht => ?_\n    Â· apply_rules [L.le_of_opNormâ‚‚_le_of_le, le_rfl]\n      refine (le_ciSup_set hbg <| mem_preimage.mpr ?_)\n      rwa [neg_sub, sub_add_cancel]\n    Â· have : t âˆ‰ support fun t => L (f t) (g (xâ‚€ - t)) := mt (fun h => h2s h) ht\n      rw [nmem_support.mp this, norm_zero]\n  refine Integrable.mono' ?_ ?_ this\n  Â· rw [integrable_indicator_iff hs]; exact ((hf.norm.const_mul _).mul_const _).integrableOn\n  Â· exact hf.aestronglyMeasurable.convolution_integrand_snd' L hmg\n\n"}
{"name":"MeasureTheory.ConvolutionExistsAt.ofNorm'","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedAddCommGroup E'\ninstâœâ¸ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œ E'\ninstâœâ´ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ³ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ² : AddGroup G\ninstâœÂ¹ : MeasurableAdd G\ninstâœ : MeasurableNeg G\nxâ‚€ : G\nh : MeasureTheory.ConvolutionExistsAt (fun x => Norm.norm (f x)) (fun x => Norm.norm (g x)) xâ‚€ (ContinuousLinearMap.mul Real Real) Î¼\nhmf : MeasureTheory.AEStronglyMeasurable f Î¼\nhmg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map (fun t => HSub.hSub xâ‚€ t) Î¼)\nâŠ¢ MeasureTheory.ConvolutionExistsAt f g xâ‚€ L Î¼","decl":"/-- If `â€–fâ€– *[Î¼] â€–gâ€–` exists, then `f *[L, Î¼] g` exists. -/\ntheorem ConvolutionExistsAt.ofNorm' {xâ‚€ : G}\n    (h : ConvolutionExistsAt (fun x => â€–f xâ€–) (fun x => â€–g xâ€–) xâ‚€ (mul â„ â„) Î¼)\n    (hmf : AEStronglyMeasurable f Î¼) (hmg : AEStronglyMeasurable g <| map (fun t => xâ‚€ - t) Î¼) :\n    ConvolutionExistsAt f g xâ‚€ L Î¼ := by\n  refine (h.const_mul â€–Lâ€–).mono'\n    (hmf.convolution_integrand_snd' L hmg) (Eventually.of_forall fun x => ?_)\n  rw [mul_apply', â† mul_assoc]\n  apply L.le_opNormâ‚‚\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.convolution_integrand_snd","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ninstâœÂ¹â° : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedSpace ğ•œ E'\ninstâœâ¶ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâµ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ´ : AddGroup G\ninstâœÂ³ : MeasurableAddâ‚‚ G\ninstâœÂ² : MeasurableNeg G\ninstâœÂ¹ : MeasureTheory.SFinite Î¼\ninstâœ : Î¼.IsAddRightInvariant\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nhg : MeasureTheory.AEStronglyMeasurable g Î¼\nx : G\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun t => (L (f t)) (g (HSub.hSub x t))) Î¼","decl":"theorem AEStronglyMeasurable.convolution_integrand_snd (hf : AEStronglyMeasurable f Î¼)\n    (hg : AEStronglyMeasurable g Î¼) (x : G) :\n    AEStronglyMeasurable (fun t => L (f t) (g (x - t))) Î¼ :=\n  hf.convolution_integrand_snd' L <|\n    hg.mono_ac <| (quasiMeasurePreserving_sub_left_of_right_invariant Î¼ x).absolutelyContinuous\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.convolution_integrand_swap_snd","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ninstâœÂ¹â° : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedSpace ğ•œ E'\ninstâœâ¶ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâµ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ´ : AddGroup G\ninstâœÂ³ : MeasurableAddâ‚‚ G\ninstâœÂ² : MeasurableNeg G\ninstâœÂ¹ : MeasureTheory.SFinite Î¼\ninstâœ : Î¼.IsAddRightInvariant\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nhg : MeasureTheory.AEStronglyMeasurable g Î¼\nx : G\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun t => (L (f (HSub.hSub x t))) (g t)) Î¼","decl":"theorem AEStronglyMeasurable.convolution_integrand_swap_snd\n    (hf : AEStronglyMeasurable f Î¼) (hg : AEStronglyMeasurable g Î¼) (x : G) :\n    AEStronglyMeasurable (fun t => L (f (x - t)) (g t)) Î¼ :=\n  (hf.mono_ac\n        (quasiMeasurePreserving_sub_left_of_right_invariant Î¼\n            x).absolutelyContinuous).convolution_integrand_swap_snd'\n    L hg\n\n"}
{"name":"MeasureTheory.ConvolutionExistsAt.ofNorm","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ninstâœÂ¹â° : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedSpace ğ•œ E'\ninstâœâ¶ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâµ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ´ : AddGroup G\ninstâœÂ³ : MeasurableAddâ‚‚ G\ninstâœÂ² : MeasurableNeg G\ninstâœÂ¹ : MeasureTheory.SFinite Î¼\ninstâœ : Î¼.IsAddRightInvariant\nxâ‚€ : G\nh : MeasureTheory.ConvolutionExistsAt (fun x => Norm.norm (f x)) (fun x => Norm.norm (g x)) xâ‚€ (ContinuousLinearMap.mul Real Real) Î¼\nhmf : MeasureTheory.AEStronglyMeasurable f Î¼\nhmg : MeasureTheory.AEStronglyMeasurable g Î¼\nâŠ¢ MeasureTheory.ConvolutionExistsAt f g xâ‚€ L Î¼","decl":"/-- If `â€–fâ€– *[Î¼] â€–gâ€–` exists, then `f *[L, Î¼] g` exists. -/\ntheorem ConvolutionExistsAt.ofNorm {xâ‚€ : G}\n    (h : ConvolutionExistsAt (fun x => â€–f xâ€–) (fun x => â€–g xâ€–) xâ‚€ (mul â„ â„) Î¼)\n    (hmf : AEStronglyMeasurable f Î¼) (hmg : AEStronglyMeasurable g Î¼) :\n    ConvolutionExistsAt f g xâ‚€ L Î¼ :=\n  h.ofNorm' L hmf <|\n    hmg.mono_ac (quasiMeasurePreserving_sub_left_of_right_invariant Î¼ xâ‚€).absolutelyContinuous\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.convolution_integrand","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¶ : MeasurableSpace G\nÎ¼ Î½ : MeasureTheory.Measure G\ninstâœâµ : AddGroup G\ninstâœâ´ : MeasurableAddâ‚‚ G\ninstâœÂ³ : MeasurableNeg G\ninstâœÂ² : MeasureTheory.SFinite Î¼\ninstâœÂ¹ : Î¼.IsAddRightInvariant\ninstâœ : MeasureTheory.SFinite Î½\nhf : MeasureTheory.AEStronglyMeasurable f Î½\nhg : MeasureTheory.AEStronglyMeasurable g Î¼\nâŠ¢ MeasureTheory.AEStronglyMeasurable (fun p => (L (f p.2)) (g (HSub.hSub p.1 p.2))) (Î¼.prod Î½)","decl":"theorem AEStronglyMeasurable.convolution_integrand (hf : AEStronglyMeasurable f Î½)\n    (hg : AEStronglyMeasurable g Î¼) :\n    AEStronglyMeasurable (fun p : G Ã— G => L (f p.2) (g (p.1 - p.2))) (Î¼.prod Î½) :=\n  hf.convolution_integrand' L <|\n    hg.mono_ac (quasiMeasurePreserving_sub_of_right_invariant Î¼ Î½).absolutelyContinuous\n\n"}
{"name":"MeasureTheory.Integrable.convolution_integrand","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¶ : MeasurableSpace G\nÎ¼ Î½ : MeasureTheory.Measure G\ninstâœâµ : AddGroup G\ninstâœâ´ : MeasurableAddâ‚‚ G\ninstâœÂ³ : MeasurableNeg G\ninstâœÂ² : MeasureTheory.SFinite Î¼\ninstâœÂ¹ : Î¼.IsAddRightInvariant\ninstâœ : MeasureTheory.SFinite Î½\nhf : MeasureTheory.Integrable f Î½\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ MeasureTheory.Integrable (fun p => (L (f p.2)) (g (HSub.hSub p.1 p.2))) (Î¼.prod Î½)","decl":"theorem Integrable.convolution_integrand (hf : Integrable f Î½) (hg : Integrable g Î¼) :\n    Integrable (fun p : G Ã— G => L (f p.2) (g (p.1 - p.2))) (Î¼.prod Î½) := by\n  have h_meas : AEStronglyMeasurable (fun p : G Ã— G => L (f p.2) (g (p.1 - p.2))) (Î¼.prod Î½) :=\n    hf.aestronglyMeasurable.convolution_integrand L hg.aestronglyMeasurable\n  have h2_meas : AEStronglyMeasurable (fun y : G => âˆ« x : G, â€–L (f y) (g (x - y))â€– âˆ‚Î¼) Î½ :=\n    h_meas.prod_swap.norm.integral_prod_right'\n  simp_rw [integrable_prod_iff' h_meas]\n  refine âŸ¨Eventually.of_forall fun t => (L (f t)).integrable_comp (hg.comp_sub_right t), ?_âŸ©\n  refine Integrable.mono' ?_ h2_meas\n      (Eventually.of_forall fun t => (?_ : _ â‰¤ â€–Lâ€– * â€–f tâ€– * âˆ« x, â€–g (x - t)â€– âˆ‚Î¼))\n  Â· simp only [integral_sub_right_eq_self (â€–g Â·â€–)]\n    exact (hf.norm.const_mul _).mul_const _\n  Â· simp_rw [â† integral_mul_left]\n    rw [Real.norm_of_nonneg (by positivity)]\n    exact integral_mono_of_nonneg (Eventually.of_forall fun t => norm_nonneg _)\n      ((hg.comp_sub_right t).norm.const_mul _) (Eventually.of_forall fun t => L.le_opNormâ‚‚ _ _)\n\n"}
{"name":"MeasureTheory.Integrable.ae_convolution_exists","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¶ : MeasurableSpace G\nÎ¼ Î½ : MeasureTheory.Measure G\ninstâœâµ : AddGroup G\ninstâœâ´ : MeasurableAddâ‚‚ G\ninstâœÂ³ : MeasurableNeg G\ninstâœÂ² : MeasureTheory.SFinite Î¼\ninstâœÂ¹ : Î¼.IsAddRightInvariant\ninstâœ : MeasureTheory.SFinite Î½\nhf : MeasureTheory.Integrable f Î½\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ Filter.Eventually (fun x => MeasureTheory.ConvolutionExistsAt f g x L Î½) (MeasureTheory.ae Î¼)","decl":"theorem Integrable.ae_convolution_exists (hf : Integrable f Î½) (hg : Integrable g Î¼) :\n    âˆ€áµ x âˆ‚Î¼, ConvolutionExistsAt f g x L Î½ :=\n  ((integrable_prod_iff <|\n          hf.aestronglyMeasurable.convolution_integrand L hg.aestronglyMeasurable).mp <|\n      hf.convolution_integrand L hg).1\n\n"}
{"name":"HasCompactSupport.convolutionExistsAt","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedAddCommGroup E'\ninstâœâ¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedSpace ğ•œ E'\ninstâœâµ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ´ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ³ : AddGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : BorelSpace G\nxâ‚€ : G\nh : HasCompactSupport fun t => (L (f t)) (g (HSub.hSub xâ‚€ t))\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : Continuous g\nâŠ¢ MeasureTheory.ConvolutionExistsAt f g xâ‚€ L Î¼","decl":"theorem _root_.HasCompactSupport.convolutionExistsAt {xâ‚€ : G}\n    (h : HasCompactSupport fun t => L (f t) (g (xâ‚€ - t))) (hf : LocallyIntegrable f Î¼)\n    (hg : Continuous g) : ConvolutionExistsAt f g xâ‚€ L Î¼ := by\n  let u := (Homeomorph.neg G).trans (Homeomorph.addRight xâ‚€)\n  let v := (Homeomorph.neg G).trans (Homeomorph.addLeft xâ‚€)\n  apply ((u.isCompact_preimage.mpr h).bddAbove_image hg.norm.continuousOn).convolutionExistsAt' L\n    isClosed_closure.measurableSet subset_closure (hf.integrableOn_isCompact h)\n  have A : AEStronglyMeasurable (g âˆ˜ v)\n      (Î¼.restrict (tsupport fun t : G => L (f t) (g (xâ‚€ - t)))) := by\n    apply (hg.comp v.continuous).continuousOn.aestronglyMeasurable_of_isCompact h\n    exact (isClosed_tsupport _).measurableSet\n  convert ((v.continuous.measurable.measurePreserving\n      (Î¼.restrict (tsupport fun t => L (f t) (g (xâ‚€ - t))))).aestronglyMeasurable_comp_iff\n    v.measurableEmbedding).1 A\n  ext x\n  simp only [v, Homeomorph.neg, sub_eq_add_neg, val_toAddUnits_apply, Homeomorph.trans_apply,\n    Equiv.neg_apply, Equiv.toFun_as_coe, Homeomorph.homeomorph_mk_coe, Equiv.coe_fn_mk,\n    Homeomorph.coe_addLeft]\n\n"}
{"name":"HasCompactSupport.convolutionExists_right","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedAddCommGroup E'\ninstâœâ¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedSpace ğ•œ E'\ninstâœâµ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ´ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ³ : AddGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : BorelSpace G\nhcg : HasCompactSupport g\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : Continuous g\nâŠ¢ MeasureTheory.ConvolutionExists f g L Î¼","decl":"theorem _root_.HasCompactSupport.convolutionExists_right (hcg : HasCompactSupport g)\n    (hf : LocallyIntegrable f Î¼) (hg : Continuous g) : ConvolutionExists f g L Î¼ := by\n  intro xâ‚€\n  refine HasCompactSupport.convolutionExistsAt L ?_ hf hg\n  refine (hcg.comp_homeomorph (Homeomorph.subLeft xâ‚€)).mono ?_\n  refine fun t => mt fun ht : g (xâ‚€ - t) = 0 => ?_\n  simp_rw [ht, (L _).map_zero]\n\n"}
{"name":"HasCompactSupport.convolutionExists_left_of_continuous_right","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedAddCommGroup E'\ninstâœâ¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedSpace ğ•œ E'\ninstâœâµ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ´ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ³ : AddGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : BorelSpace G\nhcf : HasCompactSupport f\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : Continuous g\nâŠ¢ MeasureTheory.ConvolutionExists f g L Î¼","decl":"theorem _root_.HasCompactSupport.convolutionExists_left_of_continuous_right\n    (hcf : HasCompactSupport f) (hf : LocallyIntegrable f Î¼) (hg : Continuous g) :\n    ConvolutionExists f g L Î¼ := by\n  intro xâ‚€\n  refine HasCompactSupport.convolutionExistsAt L ?_ hf hg\n  refine hcf.mono ?_\n  refine fun t => mt fun ht : f t = 0 => ?_\n  simp_rw [ht, L.map_zeroâ‚‚]\n\n"}
{"name":"BddAbove.convolutionExistsAt","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ninstâœÂ¹â° : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedSpace ğ•œ E'\ninstâœâ¶ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâµ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : MeasurableNeg G\ninstâœÂ² : Î¼.IsAddLeftInvariant\ninstâœÂ¹ : MeasurableAddâ‚‚ G\ninstâœ : MeasureTheory.SFinite Î¼\nxâ‚€ : G\ns : Set G\nhbg : BddAbove (Set.image (fun i => Norm.norm (g i)) (Set.preimage (fun t => HSub.hSub xâ‚€ t) s))\nhs : MeasurableSet s\nh2s : HasSubset.Subset (Function.support fun t => (L (f t)) (g (HSub.hSub xâ‚€ t))) s\nhf : MeasureTheory.IntegrableOn f s Î¼\nhmg : MeasureTheory.AEStronglyMeasurable g Î¼\nâŠ¢ MeasureTheory.ConvolutionExistsAt f g xâ‚€ L Î¼","decl":"/-- A sufficient condition to prove that `f â‹†[L, Î¼] g` exists.\nWe assume that the integrand has compact support and `g` is bounded on this support (note that\nboth properties hold if `g` is continuous with compact support). We also require that `f` is\nintegrable on the support of the integrand, and that both functions are strongly measurable.\n\nThis is a variant of `BddAbove.convolutionExistsAt'` in an abelian group with a left-invariant\nmeasure. This allows us to state the boundedness and measurability of `g` in a more natural way. -/\ntheorem _root_.BddAbove.convolutionExistsAt [MeasurableAddâ‚‚ G] [SFinite Î¼] {xâ‚€ : G} {s : Set G}\n    (hbg : BddAbove ((fun i => â€–g iâ€–) '' ((fun t => xâ‚€ - t) â»Â¹' s))) (hs : MeasurableSet s)\n    (h2s : (support fun t => L (f t) (g (xâ‚€ - t))) âŠ† s) (hf : IntegrableOn f s Î¼)\n    (hmg : AEStronglyMeasurable g Î¼) : ConvolutionExistsAt f g xâ‚€ L Î¼ := by\n  refine BddAbove.convolutionExistsAt' L ?_ hs h2s hf ?_\n  Â· simp_rw [â† sub_eq_neg_add, hbg]\n  Â· have : AEStronglyMeasurable g (map (fun t : G => xâ‚€ - t) Î¼) :=\n      hmg.mono_ac (quasiMeasurePreserving_sub_left_of_right_invariant Î¼ xâ‚€).absolutelyContinuous\n    apply this.mono_measure\n    exact map_mono restrict_le_self (measurable_const.sub measurable_id')\n\n"}
{"name":"MeasureTheory.convolutionExistsAt_flip","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ninstâœÂ¹â° : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\nx : G\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedSpace ğ•œ E'\ninstâœâ¶ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâµ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : MeasurableNeg G\ninstâœÂ² : Î¼.IsAddLeftInvariant\ninstâœÂ¹ : MeasurableAdd G\ninstâœ : Î¼.IsNegInvariant\nâŠ¢ Iff (MeasureTheory.ConvolutionExistsAt g f x L.flip Î¼) (MeasureTheory.ConvolutionExistsAt f g x L Î¼)","decl":"theorem convolutionExistsAt_flip :\n    ConvolutionExistsAt g f x L.flip Î¼ â†” ConvolutionExistsAt f g x L Î¼ := by\n  simp_rw [ConvolutionExistsAt, â† integrable_comp_sub_left (fun t => L (f t) (g (x - t))) x,\n    sub_sub_cancel, flip_apply]\n\n"}
{"name":"MeasureTheory.ConvolutionExistsAt.integrable_swap","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ninstâœÂ¹â° : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\nx : G\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedSpace ğ•œ E'\ninstâœâ¶ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâµ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : MeasurableNeg G\ninstâœÂ² : Î¼.IsAddLeftInvariant\ninstâœÂ¹ : MeasurableAdd G\ninstâœ : Î¼.IsNegInvariant\nh : MeasureTheory.ConvolutionExistsAt f g x L Î¼\nâŠ¢ MeasureTheory.Integrable (fun t => (L (f (HSub.hSub x t))) (g t)) Î¼","decl":"theorem ConvolutionExistsAt.integrable_swap (h : ConvolutionExistsAt f g x L Î¼) :\n    Integrable (fun t => L (f (x - t)) (g t)) Î¼ := by\n  convert h.comp_sub_left x\n  simp_rw [sub_sub_self]\n\n"}
{"name":"MeasureTheory.convolutionExistsAt_iff_integrable_swap","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ninstâœÂ¹â° : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\nx : G\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedSpace ğ•œ E'\ninstâœâ¶ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâµ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : MeasurableNeg G\ninstâœÂ² : Î¼.IsAddLeftInvariant\ninstâœÂ¹ : MeasurableAdd G\ninstâœ : Î¼.IsNegInvariant\nâŠ¢ Iff (MeasureTheory.ConvolutionExistsAt f g x L Î¼) (MeasureTheory.Integrable (fun t => (L (f (HSub.hSub x t))) (g t)) Î¼)","decl":"theorem convolutionExistsAt_iff_integrable_swap :\n    ConvolutionExistsAt f g x L Î¼ â†” Integrable (fun t => L (f (x - t)) (g t)) Î¼ :=\n  convolutionExistsAt_flip.symm\n\n"}
{"name":"HasCompactSupport.convolutionExistsLeft","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¶ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâµ : AddCommGroup G\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : TopologicalAddGroup G\ninstâœÂ² : BorelSpace G\ninstâœÂ¹ : Î¼.IsAddLeftInvariant\ninstâœ : Î¼.IsNegInvariant\nhcf : HasCompactSupport f\nhf : Continuous f\nhg : MeasureTheory.LocallyIntegrable g Î¼\nâŠ¢ MeasureTheory.ConvolutionExists f g L Î¼","decl":"theorem _root_.HasCompactSupport.convolutionExistsLeft\n    (hcf : HasCompactSupport f) (hf : Continuous f)\n    (hg : LocallyIntegrable g Î¼) : ConvolutionExists f g L Î¼ := fun xâ‚€ =>\n  convolutionExistsAt_flip.mp <| hcf.convolutionExists_right L.flip hg hf xâ‚€\n\n"}
{"name":"HasCompactSupport.convolutionExistsRightOfContinuousLeft","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¶ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâµ : AddCommGroup G\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : TopologicalAddGroup G\ninstâœÂ² : BorelSpace G\ninstâœÂ¹ : Î¼.IsAddLeftInvariant\ninstâœ : Î¼.IsNegInvariant\nhcg : HasCompactSupport g\nhf : Continuous f\nhg : MeasureTheory.LocallyIntegrable g Î¼\nâŠ¢ MeasureTheory.ConvolutionExists f g L Î¼","decl":"theorem _root_.HasCompactSupport.convolutionExistsRightOfContinuousLeft (hcg : HasCompactSupport g)\n    (hf : Continuous f) (hg : LocallyIntegrable g Î¼) : ConvolutionExists f g L Î¼ := fun xâ‚€ =>\n  convolutionExistsAt_flip.mp <| hcg.convolutionExists_left_of_continuous_right L.flip hg hf xâ‚€\n\n"}
{"name":"MeasureTheory.convolution_def","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\nx : G\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œ E'\ninstâœÂ³ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : Sub G\nâŠ¢ Eq (MeasureTheory.convolution f g L Î¼ x) (MeasureTheory.integral Î¼ fun t => (L (f t)) (g (HSub.hSub x t)))","decl":"theorem convolution_def [Sub G] : (f â‹†[L, Î¼] g) x = âˆ« t, L (f t) (g (x - t)) âˆ‚Î¼ :=\n  rfl\n\n"}
{"name":"MeasureTheory.convolution_lsmul","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\nx : G\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedSpace ğ•œ F\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : Sub G\nf : G â†’ ğ•œ\ng : G â†’ F\nâŠ¢ Eq (MeasureTheory.convolution f g (ContinuousLinearMap.lsmul ğ•œ ğ•œ) Î¼ x) (MeasureTheory.integral Î¼ fun t => HSMul.hSMul (f t) (g (HSub.hSub x t)))","decl":"/-- The definition of convolution where the bilinear operator is scalar multiplication.\nNote: it often helps the elaborator to give the type of the convolution explicitly. -/\ntheorem convolution_lsmul [Sub G] {f : G â†’ ğ•œ} {g : G â†’ F} :\n    (f â‹†[lsmul ğ•œ ğ•œ, Î¼] g : G â†’ F) x = âˆ« t, f t â€¢ g (x - t) âˆ‚Î¼ :=\n  rfl\n\n"}
{"name":"MeasureTheory.convolution_mul","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nx : G\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Sub G\ninstâœ : NormedSpace Real ğ•œ\nf g : G â†’ ğ•œ\nâŠ¢ Eq (MeasureTheory.convolution f g (ContinuousLinearMap.mul ğ•œ ğ•œ) Î¼ x) (MeasureTheory.integral Î¼ fun t => HMul.hMul (f t) (g (HSub.hSub x t)))","decl":"/-- The definition of convolution where the bilinear operator is multiplication. -/\ntheorem convolution_mul [Sub G] [NormedSpace â„ ğ•œ] {f : G â†’ ğ•œ} {g : G â†’ ğ•œ} :\n    (f â‹†[mul ğ•œ ğ•œ, Î¼] g) x = âˆ« t, f t * g (x - t) âˆ‚Î¼ :=\n  rfl\n\n"}
{"name":"MeasureTheory.smul_convolution","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedAddCommGroup E'\ninstâœâ¸ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œ E'\ninstâœâ´ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ³ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : AddGroup G\ninstâœ : SMulCommClass Real ğ•œ F\ny : ğ•œ\nâŠ¢ Eq (MeasureTheory.convolution (HSMul.hSMul y f) g L Î¼) (HSMul.hSMul y (MeasureTheory.convolution f g L Î¼))","decl":"theorem smul_convolution [SMulCommClass â„ ğ•œ F] {y : ğ•œ} : y â€¢ f â‹†[L, Î¼] g = y â€¢ (f â‹†[L, Î¼] g) := by\n  ext; simp only [Pi.smul_apply, convolution_def, â† integral_smul, L.map_smulâ‚‚]\n\n"}
{"name":"MeasureTheory.convolution_smul","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedAddCommGroup E'\ninstâœâ¸ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œ E'\ninstâœâ´ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ³ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : AddGroup G\ninstâœ : SMulCommClass Real ğ•œ F\ny : ğ•œ\nâŠ¢ Eq (MeasureTheory.convolution f (HSMul.hSMul y g) L Î¼) (HSMul.hSMul y (MeasureTheory.convolution f g L Î¼))","decl":"theorem convolution_smul [SMulCommClass â„ ğ•œ F] {y : ğ•œ} : f â‹†[L, Î¼] y â€¢ g = y â€¢ (f â‹†[L, Î¼] g) := by\n  ext; simp only [Pi.smul_apply, convolution_def, â† integral_smul, (L _).map_smul]\n\n"}
{"name":"MeasureTheory.zero_convolution","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : NormedAddCommGroup F\ng : G â†’ E'\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œ E'\ninstâœÂ³ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : AddGroup G\nâŠ¢ Eq (MeasureTheory.convolution 0 g L Î¼) 0","decl":"@[simp]\ntheorem zero_convolution : 0 â‹†[L, Î¼] g = 0 := by\n  ext\n  simp_rw [convolution_def, Pi.zero_apply, L.map_zeroâ‚‚, integral_zero]\n\n"}
{"name":"MeasureTheory.convolution_zero","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : NormedAddCommGroup F\nf : G â†’ E\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œ E'\ninstâœÂ³ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : AddGroup G\nâŠ¢ Eq (MeasureTheory.convolution f 0 L Î¼) 0","decl":"@[simp]\ntheorem convolution_zero : f â‹†[L, Î¼] 0 = 0 := by\n  ext\n  simp_rw [convolution_def, Pi.zero_apply, (L _).map_zero, integral_zero]\n\n"}
{"name":"MeasureTheory.ConvolutionExistsAt.distrib_add","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : NormedAddCommGroup F\nf : G â†’ E\ng g' : G â†’ E'\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œ E'\ninstâœÂ³ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : AddGroup G\nx : G\nhfg : MeasureTheory.ConvolutionExistsAt f g x L Î¼\nhfg' : MeasureTheory.ConvolutionExistsAt f g' x L Î¼\nâŠ¢ Eq (MeasureTheory.convolution f (HAdd.hAdd g g') L Î¼ x) (HAdd.hAdd (MeasureTheory.convolution f g L Î¼ x) (MeasureTheory.convolution f g' L Î¼ x))","decl":"theorem ConvolutionExistsAt.distrib_add {x : G} (hfg : ConvolutionExistsAt f g x L Î¼)\n    (hfg' : ConvolutionExistsAt f g' x L Î¼) :\n    (f â‹†[L, Î¼] (g + g')) x = (f â‹†[L, Î¼] g) x + (f â‹†[L, Î¼] g') x := by\n  simp only [convolution_def, (L _).map_add, Pi.add_apply, integral_add hfg hfg']\n\n"}
{"name":"MeasureTheory.ConvolutionExists.distrib_add","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : NormedAddCommGroup F\nf : G â†’ E\ng g' : G â†’ E'\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œ E'\ninstâœÂ³ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : AddGroup G\nhfg : MeasureTheory.ConvolutionExists f g L Î¼\nhfg' : MeasureTheory.ConvolutionExists f g' L Î¼\nâŠ¢ Eq (MeasureTheory.convolution f (HAdd.hAdd g g') L Î¼) (HAdd.hAdd (MeasureTheory.convolution f g L Î¼) (MeasureTheory.convolution f g' L Î¼))","decl":"theorem ConvolutionExists.distrib_add (hfg : ConvolutionExists f g L Î¼)\n    (hfg' : ConvolutionExists f g' L Î¼) : f â‹†[L, Î¼] (g + g') = f â‹†[L, Î¼] g + f â‹†[L, Î¼] g' := by\n  ext x\n  exact (hfg x).distrib_add (hfg' x)\n\n"}
{"name":"MeasureTheory.ConvolutionExistsAt.add_distrib","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : NormedAddCommGroup F\nf f' : G â†’ E\ng : G â†’ E'\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œ E'\ninstâœÂ³ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : AddGroup G\nx : G\nhfg : MeasureTheory.ConvolutionExistsAt f g x L Î¼\nhfg' : MeasureTheory.ConvolutionExistsAt f' g x L Î¼\nâŠ¢ Eq (MeasureTheory.convolution (HAdd.hAdd f f') g L Î¼ x) (HAdd.hAdd (MeasureTheory.convolution f g L Î¼ x) (MeasureTheory.convolution f' g L Î¼ x))","decl":"theorem ConvolutionExistsAt.add_distrib {x : G} (hfg : ConvolutionExistsAt f g x L Î¼)\n    (hfg' : ConvolutionExistsAt f' g x L Î¼) :\n    ((f + f') â‹†[L, Î¼] g) x = (f â‹†[L, Î¼] g) x + (f' â‹†[L, Î¼] g) x := by\n  simp only [convolution_def, L.map_addâ‚‚, Pi.add_apply, integral_add hfg hfg']\n\n"}
{"name":"MeasureTheory.ConvolutionExists.add_distrib","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : NormedAddCommGroup F\nf f' : G â†’ E\ng : G â†’ E'\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œ E'\ninstâœÂ³ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : AddGroup G\nhfg : MeasureTheory.ConvolutionExists f g L Î¼\nhfg' : MeasureTheory.ConvolutionExists f' g L Î¼\nâŠ¢ Eq (MeasureTheory.convolution (HAdd.hAdd f f') g L Î¼) (HAdd.hAdd (MeasureTheory.convolution f g L Î¼) (MeasureTheory.convolution f' g L Î¼))","decl":"theorem ConvolutionExists.add_distrib (hfg : ConvolutionExists f g L Î¼)\n    (hfg' : ConvolutionExists f' g L Î¼) : (f + f') â‹†[L, Î¼] g = f â‹†[L, Î¼] g + f' â‹†[L, Î¼] g := by\n  ext x\n  exact (hfg x).add_distrib (hfg' x)\n\n"}
{"name":"MeasureTheory.convolution_mono_right","module":"Mathlib.Analysis.Convolution","initialProofState":"G : Type uG\nx : G\ninstâœÂ¹ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœ : AddGroup G\nf g g' : G â†’ Real\nhfg : MeasureTheory.ConvolutionExistsAt f g x (ContinuousLinearMap.lsmul Real Real) Î¼\nhfg' : MeasureTheory.ConvolutionExistsAt f g' x (ContinuousLinearMap.lsmul Real Real) Î¼\nhf : âˆ€ (x : G), LE.le 0 (f x)\nhg : âˆ€ (x : G), LE.le (g x) (g' x)\nâŠ¢ LE.le (MeasureTheory.convolution f g (ContinuousLinearMap.lsmul Real Real) Î¼ x) (MeasureTheory.convolution f g' (ContinuousLinearMap.lsmul Real Real) Î¼ x)","decl":"theorem convolution_mono_right {f g g' : G â†’ â„} (hfg : ConvolutionExistsAt f g x (lsmul â„ â„) Î¼)\n    (hfg' : ConvolutionExistsAt f g' x (lsmul â„ â„) Î¼) (hf : âˆ€ x, 0 â‰¤ f x) (hg : âˆ€ x, g x â‰¤ g' x) :\n    (f â‹†[lsmul â„ â„, Î¼] g) x â‰¤ (f â‹†[lsmul â„ â„, Î¼] g') x := by\n  apply integral_mono hfg hfg'\n  simp only [lsmul_apply, Algebra.id.smul_eq_mul]\n  intro t\n  apply mul_le_mul_of_nonneg_left (hg _) (hf _)\n\n"}
{"name":"MeasureTheory.convolution_mono_right_of_nonneg","module":"Mathlib.Analysis.Convolution","initialProofState":"G : Type uG\nx : G\ninstâœÂ¹ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœ : AddGroup G\nf g g' : G â†’ Real\nhfg' : MeasureTheory.ConvolutionExistsAt f g' x (ContinuousLinearMap.lsmul Real Real) Î¼\nhf : âˆ€ (x : G), LE.le 0 (f x)\nhg : âˆ€ (x : G), LE.le (g x) (g' x)\nhg' : âˆ€ (x : G), LE.le 0 (g' x)\nâŠ¢ LE.le (MeasureTheory.convolution f g (ContinuousLinearMap.lsmul Real Real) Î¼ x) (MeasureTheory.convolution f g' (ContinuousLinearMap.lsmul Real Real) Î¼ x)","decl":"theorem convolution_mono_right_of_nonneg {f g g' : G â†’ â„}\n    (hfg' : ConvolutionExistsAt f g' x (lsmul â„ â„) Î¼) (hf : âˆ€ x, 0 â‰¤ f x) (hg : âˆ€ x, g x â‰¤ g' x)\n    (hg' : âˆ€ x, 0 â‰¤ g' x) : (f â‹†[lsmul â„ â„, Î¼] g) x â‰¤ (f â‹†[lsmul â„ â„, Î¼] g') x := by\n  by_cases H : ConvolutionExistsAt f g x (lsmul â„ â„) Î¼\n  Â· exact convolution_mono_right H hfg' hf hg\n  have : (f â‹†[lsmul â„ â„, Î¼] g) x = 0 := integral_undef H\n  rw [this]\n  exact integral_nonneg fun y => mul_nonneg (hf y) (hg' (x - y))\n\n"}
{"name":"MeasureTheory.convolution_congr","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf f' : G â†’ E\ng g' : G â†’ E'\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¶ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâµ : NormedSpace Real F\ninstâœâ´ : AddGroup G\ninstâœÂ³ : MeasurableAddâ‚‚ G\ninstâœÂ² : MeasurableNeg G\ninstâœÂ¹ : MeasureTheory.SFinite Î¼\ninstâœ : Î¼.IsAddRightInvariant\nh1 : (MeasureTheory.ae Î¼).EventuallyEq f f'\nh2 : (MeasureTheory.ae Î¼).EventuallyEq g g'\nâŠ¢ Eq (MeasureTheory.convolution f g L Î¼) (MeasureTheory.convolution f' g' L Î¼)","decl":"theorem convolution_congr [MeasurableAddâ‚‚ G] [MeasurableNeg G] [SFinite Î¼]\n    [IsAddRightInvariant Î¼] (h1 : f =áµ[Î¼] f') (h2 : g =áµ[Î¼] g') : f â‹†[L, Î¼] g = f' â‹†[L, Î¼] g' := by\n  ext x\n  apply integral_congr_ae\n  exact (h1.prod_mk <| h2.comp_tendsto\n    (quasiMeasurePreserving_sub_left_of_right_invariant Î¼ x).tendsto_ae).fun_comp â†¿fun x y â†¦ L x y\n\n"}
{"name":"MeasureTheory.support_convolution_subset_swap","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œ E'\ninstâœÂ³ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : AddGroup G\nâŠ¢ HasSubset.Subset (Function.support (MeasureTheory.convolution f g L Î¼)) (HAdd.hAdd (Function.support g) (Function.support f))","decl":"theorem support_convolution_subset_swap : support (f â‹†[L, Î¼] g) âŠ† support g + support f := by\n  intro x h2x\n  by_contra hx\n  apply h2x\n  simp_rw [Set.mem_add, â† exists_and_left, not_exists, not_and_or, nmem_support] at hx\n  rw [convolution_def]\n  convert integral_zero G F using 2\n  ext t\n  rcases hx (x - t) t with (h | h | h)\n  Â· rw [h, (L _).map_zero]\n  Â· rw [h, L.map_zeroâ‚‚]\n  Â· exact (h <| sub_add_cancel x t).elim\n\n"}
{"name":"MeasureTheory.Integrable.integrable_convolution","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¶ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâµ : NormedSpace Real F\ninstâœâ´ : AddGroup G\ninstâœÂ³ : MeasurableAddâ‚‚ G\ninstâœÂ² : MeasurableNeg G\ninstâœÂ¹ : MeasureTheory.SFinite Î¼\ninstâœ : Î¼.IsAddRightInvariant\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ MeasureTheory.Integrable (MeasureTheory.convolution f g L Î¼) Î¼","decl":"theorem Integrable.integrable_convolution (hf : Integrable f Î¼)\n    (hg : Integrable g Î¼) : Integrable (f â‹†[L, Î¼] g) Î¼ :=\n  (hf.convolution_integrand L hg).integral_prod_left\n\n"}
{"name":"HasCompactSupport.convolution","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ninstâœÂ¹â° : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedSpace ğ•œ E'\ninstâœâ¶ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâµ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ´ : NormedSpace Real F\ninstâœÂ³ : AddGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : T2Space G\nhcf : HasCompactSupport f\nhcg : HasCompactSupport g\nâŠ¢ HasCompactSupport (MeasureTheory.convolution f g L Î¼)","decl":"protected theorem _root_.HasCompactSupport.convolution [T2Space G] (hcf : HasCompactSupport f)\n    (hcg : HasCompactSupport g) : HasCompactSupport (f â‹†[L, Î¼] g) :=\n  (hcg.isCompact.add hcf).of_isClosed_subset isClosed_closure <|\n    closure_minimal\n      ((support_convolution_subset_swap L).trans <| add_subset_add subset_closure subset_closure)\n      (hcg.isCompact.add hcf).isClosed\n\n"}
{"name":"MeasureTheory.continuousOn_convolution_right_with_param","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¶ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâµ : NormedSpace Real F\ninstâœâ´ : AddGroup G\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : TopologicalAddGroup G\ninstâœÂ¹ : BorelSpace G\ninstâœ : TopologicalSpace P\ng : P â†’ G â†’ E'\ns : Set P\nk : Set G\nhk : IsCompact k\nhgs : âˆ€ (p : P) (x : G), Membership.mem s p â†’ Not (Membership.mem k x) â†’ Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : ContinuousOn (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\nâŠ¢ ContinuousOn (fun q => MeasureTheory.convolution f (g q.1) L Î¼ q.2) (SProd.sprod s Set.univ)","decl":"/-- The convolution `f * g` is continuous if `f` is locally integrable and `g` is continuous and\ncompactly supported. Version where `g` depends on an additional parameter in a subset `s` of\na parameter space `P` (and the compact support `k` is independent of the parameter in `s`). -/\ntheorem continuousOn_convolution_right_with_param {g : P â†’ G â†’ E'} {s : Set P} {k : Set G}\n    (hk : IsCompact k) (hgs : âˆ€ p, âˆ€ x, p âˆˆ s â†’ x âˆ‰ k â†’ g p x = 0)\n    (hf : LocallyIntegrable f Î¼) (hg : ContinuousOn (â†¿g) (s Ã—Ë¢ univ)) :\n    ContinuousOn (fun q : P Ã— G => (f â‹†[L, Î¼] g q.1) q.2) (s Ã—Ë¢ univ) := by\n  /- First get rid of the case where the space is not locally compact. Then `g` vanishes everywhere\n  and the conclusion is trivial. -/\n  by_cases H : âˆ€ p âˆˆ s, âˆ€ x, g p x = 0\n  Â· apply (continuousOn_const (c := 0)).congr\n    rintro âŸ¨p, xâŸ© âŸ¨hp, -âŸ©\n    apply integral_eq_zero_of_ae (Eventually.of_forall (fun y â†¦ ?_))\n    simp [H p hp _]\n  have : LocallyCompactSpace G := by\n    push_neg at H\n    rcases H with âŸ¨p, hp, x, hxâŸ©\n    have A : support (g p) âŠ† k := support_subset_iff'.2 (fun y hy â†¦ hgs p y hp hy)\n    have B : Continuous (g p) := by\n      refine hg.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_\n      simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hp\n    rcases eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_addGroup hk A B with H|H\n    Â· simp [H] at hx\n    Â· exact H\n  /- Since `G` is locally compact, one may thicken `k` a little bit into a larger compact set\n  `(-k) + t`, outside of which all functions that appear in the convolution vanish. Then we can\n  apply a continuity statement for integrals depending on a parameter, with respect to\n  locally integrable functions and compactly supported continuous functions. -/\n  rintro âŸ¨qâ‚€, xâ‚€âŸ© âŸ¨hqâ‚€, -âŸ©\n  obtain âŸ¨t, t_comp, htâŸ© : âˆƒ t, IsCompact t âˆ§ t âˆˆ ğ“ xâ‚€ := exists_compact_mem_nhds xâ‚€\n  let k' : Set G := (-k) +áµ¥ t\n  have k'_comp : IsCompact k' := IsCompact.vadd_set hk.neg t_comp\n  let g' : (P Ã— G) â†’ G â†’ E' := fun p x â†¦ g p.1 (p.2 - x)\n  let s' : Set (P Ã— G) := s Ã—Ë¢ t\n  have A : ContinuousOn g'.uncurry (s' Ã—Ë¢ univ) := by\n    have : g'.uncurry = g.uncurry âˆ˜ (fun w â†¦ (w.1.1, w.1.2 - w.2)) := by ext y; rfl\n    rw [this]\n    refine hg.comp (continuous_fst.fst.prod_mk (continuous_fst.snd.sub\n      continuous_snd)).continuousOn ?_\n    simp +contextual [s', MapsTo]\n  have B : ContinuousOn (fun a â†¦ âˆ« x, L (f x) (g' a x) âˆ‚Î¼) s' := by\n    apply continuousOn_integral_bilinear_of_locally_integrable_of_compact_support L k'_comp A _\n      (hf.integrableOn_isCompact k'_comp)\n    rintro âŸ¨p, xâŸ© y âŸ¨hp, hxâŸ© hy\n    apply hgs p _ hp\n    contrapose! hy\n    exact âŸ¨y - x, by simpa using hy, x, hx, by simpâŸ©\n  apply ContinuousWithinAt.mono_of_mem_nhdsWithin (B (qâ‚€, xâ‚€) âŸ¨hqâ‚€, mem_of_mem_nhds htâŸ©)\n  exact mem_nhdsWithin_prod_iff.2 âŸ¨s, self_mem_nhdsWithin, t, nhdsWithin_le_nhds ht, Subset.rflâŸ©\n\n"}
{"name":"MeasureTheory.continuousOn_convolution_right_with_param_comp","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¶ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâµ : NormedSpace Real F\ninstâœâ´ : AddGroup G\ninstâœÂ³ : TopologicalSpace G\ninstâœÂ² : TopologicalAddGroup G\ninstâœÂ¹ : BorelSpace G\ninstâœ : TopologicalSpace P\ns : Set P\nv : P â†’ G\nhv : ContinuousOn v s\ng : P â†’ G â†’ E'\nk : Set G\nhk : IsCompact k\nhgs : âˆ€ (p : P) (x : G), Membership.mem s p â†’ Not (Membership.mem k x) â†’ Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : ContinuousOn (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\nâŠ¢ ContinuousOn (fun x => MeasureTheory.convolution f (g x) L Î¼ (v x)) s","decl":"/-- The convolution `f * g` is continuous if `f` is locally integrable and `g` is continuous and\ncompactly supported. Version where `g` depends on an additional parameter in an open subset `s` of\na parameter space `P` (and the compact support `k` is independent of the parameter in `s`),\ngiven in terms of compositions with an additional continuous map. -/\ntheorem continuousOn_convolution_right_with_param_comp {s : Set P} {v : P â†’ G}\n    (hv : ContinuousOn v s) {g : P â†’ G â†’ E'} {k : Set G} (hk : IsCompact k)\n    (hgs : âˆ€ p, âˆ€ x, p âˆˆ s â†’ x âˆ‰ k â†’ g p x = 0) (hf : LocallyIntegrable f Î¼)\n    (hg : ContinuousOn (â†¿g) (s Ã—Ë¢ univ)) : ContinuousOn (fun x => (f â‹†[L, Î¼] g x) (v x)) s := by\n  apply\n    (continuousOn_convolution_right_with_param L hk hgs hf hg).comp (continuousOn_id.prod hv)\n  intro x hx\n  simp only [hx, prod_mk_mem_set_prod_eq, mem_univ, and_self_iff, _root_.id]\n\n"}
{"name":"HasCompactSupport.continuous_convolution_right","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ninstâœÂ¹â° : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : NormedSpace ğ•œ E'\ninstâœâ¶ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâµ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ´ : NormedSpace Real F\ninstâœÂ³ : AddGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : BorelSpace G\nhcg : HasCompactSupport g\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : Continuous g\nâŠ¢ Continuous (MeasureTheory.convolution f g L Î¼)","decl":"/-- The convolution is continuous if one function is locally integrable and the other has compact\nsupport and is continuous. -/\ntheorem _root_.HasCompactSupport.continuous_convolution_right (hcg : HasCompactSupport g)\n    (hf : LocallyIntegrable f Î¼) (hg : Continuous g) : Continuous (f â‹†[L, Î¼] g) := by\n  rw [continuous_iff_continuousOn_univ]\n  let g' : G â†’ G â†’ E' := fun _ q => g q\n  have : ContinuousOn (â†¿g') (univ Ã—Ë¢ univ) := (hg.comp continuous_snd).continuousOn\n  exact continuousOn_convolution_right_with_param_comp L\n    (continuous_iff_continuousOn_univ.1 continuous_id) hcg\n    (fun p x _ hx => image_eq_zero_of_nmem_tsupport hx) hf this\n\n"}
{"name":"BddAbove.continuous_convolution_right_of_integrable","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹â´ : NormedAddCommGroup E\ninstâœÂ¹Â³ : NormedAddCommGroup E'\ninstâœÂ¹Â² : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : NormedSpace ğ•œ E\ninstâœâ¹ : NormedSpace ğ•œ E'\ninstâœâ¸ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ· : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ¶ : NormedSpace Real F\ninstâœâµ : AddGroup G\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : TopologicalAddGroup G\ninstâœÂ² : BorelSpace G\ninstâœÂ¹ : FirstCountableTopology G\ninstâœ : SecondCountableTopologyEither G E'\nhbg : BddAbove (Set.range fun x => Norm.norm (g x))\nhf : MeasureTheory.Integrable f Î¼\nhg : Continuous g\nâŠ¢ Continuous (MeasureTheory.convolution f g L Î¼)","decl":"/-- The convolution is continuous if one function is integrable and the other is bounded and\ncontinuous. -/\ntheorem _root_.BddAbove.continuous_convolution_right_of_integrable\n    [FirstCountableTopology G] [SecondCountableTopologyEither G E']\n    (hbg : BddAbove (range fun x => â€–g xâ€–)) (hf : Integrable f Î¼) (hg : Continuous g) :\n    Continuous (f â‹†[L, Î¼] g) := by\n  refine continuous_iff_continuousAt.mpr fun xâ‚€ => ?_\n  have : âˆ€á¶  x in ğ“ xâ‚€, âˆ€áµ t : G âˆ‚Î¼, â€–L (f t) (g (x - t))â€– â‰¤ â€–Lâ€– * â€–f tâ€– * â¨† i, â€–g iâ€– := by\n    filter_upwards with x; filter_upwards with t\n    apply_rules [L.le_of_opNormâ‚‚_le_of_le, le_rfl, le_ciSup hbg (x - t)]\n  refine continuousAt_of_dominated ?_ this ?_ ?_\n  Â· exact Eventually.of_forall fun x =>\n      hf.aestronglyMeasurable.convolution_integrand_snd' L hg.aestronglyMeasurable\n  Â· exact (hf.norm.const_mul _).mul_const _\n  Â· exact Eventually.of_forall fun t => (L.continuousâ‚‚.compâ‚‚ continuous_const <|\n      hg.comp <| continuous_id.sub continuous_const).continuousAt\n\n"}
{"name":"MeasureTheory.support_convolution_subset","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œ E'\ninstâœÂ³ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : AddCommGroup G\nâŠ¢ HasSubset.Subset (Function.support (MeasureTheory.convolution f g L Î¼)) (HAdd.hAdd (Function.support f) (Function.support g))","decl":"theorem support_convolution_subset : support (f â‹†[L, Î¼] g) âŠ† support f + support g :=\n  (support_convolution_subset_swap L).trans (add_comm _ _).subset\n\n"}
{"name":"MeasureTheory.convolution_flip","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¶ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâµ : NormedSpace Real F\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : Î¼.IsAddLeftInvariant\ninstâœÂ² : Î¼.IsNegInvariant\ninstâœÂ¹ : MeasurableNeg G\ninstâœ : MeasurableAdd G\nâŠ¢ Eq (MeasureTheory.convolution g f L.flip Î¼) (MeasureTheory.convolution f g L Î¼)","decl":"/-- Commutativity of convolution -/\ntheorem convolution_flip : g â‹†[L.flip, Î¼] f = f â‹†[L, Î¼] g := by\n  ext1 x\n  simp_rw [convolution_def]\n  rw [â† integral_sub_left_eq_self _ Î¼ x]\n  simp_rw [sub_sub_self, flip_apply]\n\n"}
{"name":"MeasureTheory.convolution_eq_swap","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\nx : G\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¶ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâµ : NormedSpace Real F\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : Î¼.IsAddLeftInvariant\ninstâœÂ² : Î¼.IsNegInvariant\ninstâœÂ¹ : MeasurableNeg G\ninstâœ : MeasurableAdd G\nâŠ¢ Eq (MeasureTheory.convolution f g L Î¼ x) (MeasureTheory.integral Î¼ fun t => (L (f (HSub.hSub x t))) (g t))","decl":"/-- The symmetric definition of convolution. -/\ntheorem convolution_eq_swap : (f â‹†[L, Î¼] g) x = âˆ« t, L (f (x - t)) (g t) âˆ‚Î¼ := by\n  rw [â† convolution_flip]; rfl\n\n"}
{"name":"MeasureTheory.convolution_lsmul_swap","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup F\nx : G\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedSpace ğ•œ F\ninstâœâ¶ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâµ : NormedSpace Real F\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : Î¼.IsAddLeftInvariant\ninstâœÂ² : Î¼.IsNegInvariant\ninstâœÂ¹ : MeasurableNeg G\ninstâœ : MeasurableAdd G\nf : G â†’ ğ•œ\ng : G â†’ F\nâŠ¢ Eq (MeasureTheory.convolution f g (ContinuousLinearMap.lsmul ğ•œ ğ•œ) Î¼ x) (MeasureTheory.integral Î¼ fun t => HSMul.hSMul (f (HSub.hSub x t)) (g t))","decl":"/-- The symmetric definition of convolution where the bilinear operator is scalar multiplication. -/\ntheorem convolution_lsmul_swap {f : G â†’ ğ•œ} {g : G â†’ F} :\n    (f â‹†[lsmul ğ•œ ğ•œ, Î¼] g : G â†’ F) x = âˆ« t, f (x - t) â€¢ g t âˆ‚Î¼ :=\n  convolution_eq_swap _\n\n"}
{"name":"MeasureTheory.convolution_mul_swap","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nx : G\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâµ : AddCommGroup G\ninstâœâ´ : Î¼.IsAddLeftInvariant\ninstâœÂ³ : Î¼.IsNegInvariant\ninstâœÂ² : MeasurableNeg G\ninstâœÂ¹ : MeasurableAdd G\ninstâœ : NormedSpace Real ğ•œ\nf g : G â†’ ğ•œ\nâŠ¢ Eq (MeasureTheory.convolution f g (ContinuousLinearMap.mul ğ•œ ğ•œ) Î¼ x) (MeasureTheory.integral Î¼ fun t => HMul.hMul (f (HSub.hSub x t)) (g t))","decl":"/-- The symmetric definition of convolution where the bilinear operator is multiplication. -/\ntheorem convolution_mul_swap [NormedSpace â„ ğ•œ] {f : G â†’ ğ•œ} {g : G â†’ ğ•œ} :\n    (f â‹†[mul ğ•œ ğ•œ, Î¼] g) x = âˆ« t, f (x - t) * g t âˆ‚Î¼ :=\n  convolution_eq_swap _\n\n"}
{"name":"MeasureTheory.convolution_neg_of_neg_eq","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\nx : G\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¶ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâµ : NormedSpace Real F\ninstâœâ´ : AddCommGroup G\ninstâœÂ³ : Î¼.IsAddLeftInvariant\ninstâœÂ² : Î¼.IsNegInvariant\ninstâœÂ¹ : MeasurableNeg G\ninstâœ : MeasurableAdd G\nh1 : Filter.Eventually (fun x => Eq (f (Neg.neg x)) (f x)) (MeasureTheory.ae Î¼)\nh2 : Filter.Eventually (fun x => Eq (g (Neg.neg x)) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (MeasureTheory.convolution f g L Î¼ (Neg.neg x)) (MeasureTheory.convolution f g L Î¼ x)","decl":"/-- The convolution of two even functions is also even. -/\ntheorem convolution_neg_of_neg_eq (h1 : âˆ€áµ x âˆ‚Î¼, f (-x) = f x) (h2 : âˆ€áµ x âˆ‚Î¼, g (-x) = g x) :\n    (f â‹†[L, Î¼] g) (-x) = (f â‹†[L, Î¼] g) x :=\n  calc\n    âˆ« t : G, (L (f t)) (g (-x - t)) âˆ‚Î¼ = âˆ« t : G, (L (f (-t))) (g (x + t)) âˆ‚Î¼ := by\n      apply integral_congr_ae\n      filter_upwards [h1, (eventually_add_left_iff Î¼ x).2 h2] with t ht h't\n      simp_rw [ht, â† h't, neg_add']\n    _ = âˆ« t : G, (L (f t)) (g (x - t)) âˆ‚Î¼ := by\n      rw [â† integral_neg_eq_self]\n      simp only [neg_neg, â† sub_eq_add_neg]\n\n"}
{"name":"HasCompactSupport.continuous_convolution_left","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹â´ : NormedAddCommGroup E\ninstâœÂ¹Â³ : NormedAddCommGroup E'\ninstâœÂ¹Â² : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : NormedSpace ğ•œ E\ninstâœâ¹ : NormedSpace ğ•œ E'\ninstâœâ¸ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ· : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ¶ : NormedSpace Real F\ninstâœâµ : AddCommGroup G\ninstâœâ´ : Î¼.IsAddLeftInvariant\ninstâœÂ³ : Î¼.IsNegInvariant\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : BorelSpace G\nhcf : HasCompactSupport f\nhf : Continuous f\nhg : MeasureTheory.LocallyIntegrable g Î¼\nâŠ¢ Continuous (MeasureTheory.convolution f g L Î¼)","decl":"theorem _root_.HasCompactSupport.continuous_convolution_left\n    (hcf : HasCompactSupport f) (hf : Continuous f) (hg : LocallyIntegrable g Î¼) :\n    Continuous (f â‹†[L, Î¼] g) := by\n  rw [â† convolution_flip]\n  exact hcf.continuous_convolution_right L.flip hg hf\n\n"}
{"name":"BddAbove.continuous_convolution_left_of_integrable","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹â¶ : NormedAddCommGroup E\ninstâœÂ¹âµ : NormedAddCommGroup E'\ninstâœÂ¹â´ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â² : NormedSpace ğ•œ E\ninstâœÂ¹Â¹ : NormedSpace ğ•œ E'\ninstâœÂ¹â° : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¹ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ¸ : NormedSpace Real F\ninstâœâ· : AddCommGroup G\ninstâœâ¶ : Î¼.IsAddLeftInvariant\ninstâœâµ : Î¼.IsNegInvariant\ninstâœâ´ : TopologicalSpace G\ninstâœÂ³ : TopologicalAddGroup G\ninstâœÂ² : BorelSpace G\ninstâœÂ¹ : FirstCountableTopology G\ninstâœ : SecondCountableTopologyEither G E\nhbf : BddAbove (Set.range fun x => Norm.norm (f x))\nhf : Continuous f\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ Continuous (MeasureTheory.convolution f g L Î¼)","decl":"theorem _root_.BddAbove.continuous_convolution_left_of_integrable\n    [FirstCountableTopology G] [SecondCountableTopologyEither G E]\n    (hbf : BddAbove (range fun x => â€–f xâ€–)) (hf : Continuous f) (hg : Integrable g Î¼) :\n    Continuous (f â‹†[L, Î¼] g) := by\n  rw [â† convolution_flip]\n  exact hbf.continuous_convolution_right_of_integrable L.flip hg hf\n\n"}
{"name":"MeasureTheory.convolution_eq_right'","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œ E'\ninstâœÂ³ : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : SeminormedAddCommGroup G\nxâ‚€ : G\nR : Real\nhf : HasSubset.Subset (Function.support f) (Metric.ball 0 R)\nhg : âˆ€ (x : G), Membership.mem (Metric.ball xâ‚€ R) x â†’ Eq (g x) (g xâ‚€)\nâŠ¢ Eq (MeasureTheory.convolution f g L Î¼ xâ‚€) (MeasureTheory.integral Î¼ fun t => (L (f t)) (g xâ‚€))","decl":"/-- Compute `(f â‹† g) xâ‚€` if the support of the `f` is within `Metric.ball 0 R`, and `g` is constant\non `Metric.ball xâ‚€ R`.\n\nWe can simplify the RHS further if we assume `f` is integrable, but also if `L = (â€¢)` or more\ngenerally if `L` has an `AntilipschitzWith`-condition. -/\ntheorem convolution_eq_right' {xâ‚€ : G} {R : â„} (hf : support f âŠ† ball (0 : G) R)\n    (hg : âˆ€ x âˆˆ ball xâ‚€ R, g x = g xâ‚€) : (f â‹†[L, Î¼] g) xâ‚€ = âˆ« t, L (f t) (g xâ‚€) âˆ‚Î¼ := by\n  have h2 : âˆ€ t, L (f t) (g (xâ‚€ - t)) = L (f t) (g xâ‚€) := fun t â†¦ by\n    by_cases ht : t âˆˆ support f\n    Â· have h2t := hf ht\n      rw [mem_ball_zero_iff] at h2t\n      specialize hg (xâ‚€ - t)\n      rw [sub_eq_add_neg, add_mem_ball_iff_norm, norm_neg, â† sub_eq_add_neg] at hg\n      rw [hg h2t]\n    Â· rw [nmem_support] at ht\n      simp_rw [ht, L.map_zeroâ‚‚]\n  simp_rw [convolution_def, h2]\n\n"}
{"name":"MeasureTheory.dist_convolution_le'","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace ğ•œ F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ¶ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâµ : NormedSpace Real F\ninstâœâ´ : SeminormedAddCommGroup G\ninstâœÂ³ : BorelSpace G\ninstâœÂ² : SecondCountableTopology G\ninstâœÂ¹ : Î¼.IsAddLeftInvariant\ninstâœ : MeasureTheory.SFinite Î¼\nxâ‚€ : G\nR Îµ : Real\nzâ‚€ : E'\nhÎµ : LE.le 0 Îµ\nhif : MeasureTheory.Integrable f Î¼\nhf : HasSubset.Subset (Function.support f) (Metric.ball 0 R)\nhmg : MeasureTheory.AEStronglyMeasurable g Î¼\nhg : âˆ€ (x : G), Membership.mem (Metric.ball xâ‚€ R) x â†’ LE.le (Dist.dist (g x) zâ‚€) Îµ\nâŠ¢ LE.le (Dist.dist (MeasureTheory.convolution f g L Î¼ xâ‚€) (MeasureTheory.integral Î¼ fun t => (L (f t)) zâ‚€)) (HMul.hMul (HMul.hMul (Norm.norm L) (MeasureTheory.integral Î¼ fun x => Norm.norm (f x))) Îµ)","decl":"/-- Approximate `(f â‹† g) xâ‚€` if the support of the `f` is bounded within a ball, and `g` is near\n`g xâ‚€` on a ball with the same radius around `xâ‚€`. See `dist_convolution_le` for a special case.\n\nWe can simplify the second argument of `dist` further if we add some extra type-classes on `E`\nand `ğ•œ` or if `L` is scalar multiplication. -/\ntheorem dist_convolution_le' {xâ‚€ : G} {R Îµ : â„} {zâ‚€ : E'} (hÎµ : 0 â‰¤ Îµ) (hif : Integrable f Î¼)\n    (hf : support f âŠ† ball (0 : G) R) (hmg : AEStronglyMeasurable g Î¼)\n    (hg : âˆ€ x âˆˆ ball xâ‚€ R, dist (g x) zâ‚€ â‰¤ Îµ) :\n    dist ((f â‹†[L, Î¼] g : G â†’ F) xâ‚€) (âˆ« t, L (f t) zâ‚€ âˆ‚Î¼) â‰¤ (â€–Lâ€– * âˆ« x, â€–f xâ€– âˆ‚Î¼) * Îµ := by\n  have hfg : ConvolutionExistsAt f g xâ‚€ L Î¼ := by\n    refine BddAbove.convolutionExistsAt L ?_ Metric.isOpen_ball.measurableSet (Subset.trans ?_ hf)\n      hif.integrableOn hmg\n    swap; Â· refine fun t => mt fun ht : f t = 0 => ?_; simp_rw [ht, L.map_zeroâ‚‚]\n    rw [bddAbove_def]\n    refine âŸ¨â€–zâ‚€â€– + Îµ, ?_âŸ©\n    rintro _ âŸ¨x, hx, rflâŸ©\n    refine norm_le_norm_add_const_of_dist_le (hg x ?_)\n    rwa [mem_ball_iff_norm, norm_sub_rev, â† mem_ball_zero_iff]\n  have h2 : âˆ€ t, dist (L (f t) (g (xâ‚€ - t))) (L (f t) zâ‚€) â‰¤ â€–L (f t)â€– * Îµ := by\n    intro t; by_cases ht : t âˆˆ support f\n    Â· have h2t := hf ht\n      rw [mem_ball_zero_iff] at h2t\n      specialize hg (xâ‚€ - t)\n      rw [sub_eq_add_neg, add_mem_ball_iff_norm, norm_neg, â† sub_eq_add_neg] at hg\n      refine ((L (f t)).dist_le_opNorm _ _).trans ?_\n      exact mul_le_mul_of_nonneg_left (hg h2t) (norm_nonneg _)\n    Â· rw [nmem_support] at ht\n      simp_rw [ht, L.map_zeroâ‚‚, L.map_zero, norm_zero, zero_mul, dist_self]\n      rfl\n  simp_rw [convolution_def]\n  simp_rw [dist_eq_norm] at h2 âŠ¢\n  rw [â† integral_sub hfg.integrable]; swap; Â· exact (L.flip zâ‚€).integrable_comp hif\n  refine (norm_integral_le_of_norm_le ((L.integrable_comp hif).norm.mul_const Îµ)\n    (Eventually.of_forall h2)).trans ?_\n  rw [integral_mul_right]\n  refine mul_le_mul_of_nonneg_right ?_ hÎµ\n  have h3 : âˆ€ t, â€–L (f t)â€– â‰¤ â€–Lâ€– * â€–f tâ€– := by\n    intro t\n    exact L.le_opNorm (f t)\n  refine (integral_mono (L.integrable_comp hif).norm (hif.norm.const_mul _) h3).trans_eq ?_\n  rw [integral_mul_left]\n\n"}
{"name":"MeasureTheory.dist_convolution_le","module":"Mathlib.Analysis.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninstâœâ¸ : NormedAddCommGroup E'\ng : G â†’ E'\ninstâœâ· : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ¶ : SeminormedAddCommGroup G\ninstâœâµ : BorelSpace G\ninstâœâ´ : SecondCountableTopology G\ninstâœÂ³ : Î¼.IsAddLeftInvariant\ninstâœÂ² : MeasureTheory.SFinite Î¼\ninstâœÂ¹ : NormedSpace Real E'\ninstâœ : CompleteSpace E'\nf : G â†’ Real\nxâ‚€ : G\nR Îµ : Real\nzâ‚€ : E'\nhÎµ : LE.le 0 Îµ\nhf : HasSubset.Subset (Function.support f) (Metric.ball 0 R)\nhnf : âˆ€ (x : G), LE.le 0 (f x)\nhintf : Eq (MeasureTheory.integral Î¼ fun x => f x) 1\nhmg : MeasureTheory.AEStronglyMeasurable g Î¼\nhg : âˆ€ (x : G), Membership.mem (Metric.ball xâ‚€ R) x â†’ LE.le (Dist.dist (g x) zâ‚€) Îµ\nâŠ¢ LE.le (Dist.dist (MeasureTheory.convolution f g (ContinuousLinearMap.lsmul Real Real) Î¼ xâ‚€) zâ‚€) Îµ","decl":"/-- Approximate `f â‹† g` if the support of the `f` is bounded within a ball, and `g` is near `g xâ‚€`\non a ball with the same radius around `xâ‚€`.\n\nThis is a special case of `dist_convolution_le'` where `L` is `(â€¢)`, `f` has integral 1 and `f` is\nnonnegative. -/\ntheorem dist_convolution_le {f : G â†’ â„} {xâ‚€ : G} {R Îµ : â„} {zâ‚€ : E'} (hÎµ : 0 â‰¤ Îµ)\n    (hf : support f âŠ† ball (0 : G) R) (hnf : âˆ€ x, 0 â‰¤ f x) (hintf : âˆ« x, f x âˆ‚Î¼ = 1)\n    (hmg : AEStronglyMeasurable g Î¼) (hg : âˆ€ x âˆˆ ball xâ‚€ R, dist (g x) zâ‚€ â‰¤ Îµ) :\n    dist ((f â‹†[lsmul â„ â„, Î¼] g : G â†’ E') xâ‚€) zâ‚€ â‰¤ Îµ := by\n  have hif : Integrable f Î¼ := integrable_of_integral_eq_one hintf\n  convert (dist_convolution_le' (lsmul â„ â„) hÎµ hif hf hmg hg).trans _\n  Â· simp_rw [lsmul_apply, integral_smul_const, hintf, one_smul]\n  Â· simp_rw [Real.norm_of_nonneg (hnf _), hintf, mul_one]\n    exact (mul_le_mul_of_nonneg_right opNorm_lsmul_le hÎµ).trans_eq (one_mul Îµ)\n\n"}
{"name":"MeasureTheory.convolution_tendsto_right","module":"Mathlib.Analysis.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ¶ : SeminormedAddCommGroup G\ninstâœâµ : BorelSpace G\ninstâœâ´ : SecondCountableTopology G\ninstâœÂ³ : Î¼.IsAddLeftInvariant\ninstâœÂ² : MeasureTheory.SFinite Î¼\ninstâœÂ¹ : NormedSpace Real E'\ninstâœ : CompleteSpace E'\nÎ¹ : Type u_1\ng : Î¹ â†’ G â†’ E'\nl : Filter Î¹\nxâ‚€ : G\nzâ‚€ : E'\nÏ† : Î¹ â†’ G â†’ Real\nk : Î¹ â†’ G\nhnÏ† : Filter.Eventually (fun i => âˆ€ (x : G), LE.le 0 (Ï† i x)) l\nhiÏ† : Filter.Eventually (fun i => Eq (MeasureTheory.integral Î¼ fun x => Ï† i x) 1) l\nhÏ† : Filter.Tendsto (fun n => Function.support (Ï† n)) l (nhds 0).smallSets\nhmg : Filter.Eventually (fun i => MeasureTheory.AEStronglyMeasurable (g i) Î¼) l\nhcg : Filter.Tendsto (Function.uncurry g) (SProd.sprod l (nhds xâ‚€)) (nhds zâ‚€)\nhk : Filter.Tendsto k l (nhds xâ‚€)\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.convolution (Ï† i) (g i) (ContinuousLinearMap.lsmul Real Real) Î¼ (k i)) l (nhds zâ‚€)","decl":"/-- `(Ï† i â‹† g i) (k i)` tends to `zâ‚€` as `i` tends to some filter `l` if\n* `Ï†` is a sequence of nonnegative functions with integral `1` as `i` tends to `l`;\n* The support of `Ï†` tends to small neighborhoods around `(0 : G)` as `i` tends to `l`;\n* `g i` is `mu`-a.e. strongly measurable as `i` tends to `l`;\n* `g i x` tends to `zâ‚€` as `(i, x)` tends to `l Ã—Ë¢ ğ“ xâ‚€`;\n* `k i` tends to `xâ‚€`.\n\nSee also `ContDiffBump.convolution_tendsto_right`.\n-/\ntheorem convolution_tendsto_right {Î¹} {g : Î¹ â†’ G â†’ E'} {l : Filter Î¹} {xâ‚€ : G} {zâ‚€ : E'}\n    {Ï† : Î¹ â†’ G â†’ â„} {k : Î¹ â†’ G} (hnÏ† : âˆ€á¶  i in l, âˆ€ x, 0 â‰¤ Ï† i x)\n    (hiÏ† : âˆ€á¶  i in l, âˆ« x, Ï† i x âˆ‚Î¼ = 1)\n    -- todo: we could weaken this to \"the integral tends to 1\"\n    (hÏ† : Tendsto (fun n => support (Ï† n)) l (ğ“ 0).smallSets)\n    (hmg : âˆ€á¶  i in l, AEStronglyMeasurable (g i) Î¼) (hcg : Tendsto (uncurry g) (l Ã—Ë¢ ğ“ xâ‚€) (ğ“ zâ‚€))\n    (hk : Tendsto k l (ğ“ xâ‚€)) :\n    Tendsto (fun i : Î¹ => (Ï† i â‹†[lsmul â„ â„, Î¼] g i : G â†’ E') (k i)) l (ğ“ zâ‚€) := by\n  simp_rw [tendsto_smallSets_iff] at hÏ†\n  rw [Metric.tendsto_nhds] at hcg âŠ¢\n  simp_rw [Metric.eventually_prod_nhds_iff] at hcg\n  intro Îµ hÎµ\n  have h2Îµ : 0 < Îµ / 3 := div_pos hÎµ (by norm_num)\n  obtain âŸ¨p, hp, Î´, hÎ´, hgÎ´âŸ© := hcg _ h2Îµ\n  dsimp only [uncurry] at hgÎ´\n  have h2k := hk.eventually (ball_mem_nhds xâ‚€ <| half_pos hÎ´)\n  have h2Ï† := hÏ† (ball (0 : G) _) <| ball_mem_nhds _ (half_pos hÎ´)\n  filter_upwards [hp, h2k, h2Ï†, hnÏ†, hiÏ†, hmg] with i hpi hki hÏ†i hnÏ†i hiÏ†i hmgi\n  have hgi : dist (g i (k i)) zâ‚€ < Îµ / 3 := hgÎ´ hpi (hki.trans <| half_lt_self hÎ´)\n  have h1 : âˆ€ x' âˆˆ ball (k i) (Î´ / 2), dist (g i x') (g i (k i)) â‰¤ Îµ / 3 + Îµ / 3 := by\n    intro x' hx'\n    refine (dist_triangle_right _ _ _).trans (add_le_add (hgÎ´ hpi ?_).le hgi.le)\n    exact ((dist_triangle _ _ _).trans_lt (add_lt_add hx'.out hki)).trans_eq (add_halves Î´)\n  have := dist_convolution_le (add_pos h2Îµ h2Îµ).le hÏ†i hnÏ†i hiÏ†i hmgi h1\n  refine ((dist_triangle _ _ _).trans_lt (add_lt_add_of_le_of_lt this hgi)).trans_eq ?_\n  field_simp; ring_nf\n\n"}
{"name":"MeasureTheory.integral_convolution","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹â¹ : NormedAddCommGroup E\ninstâœÂ¹â¸ : NormedAddCommGroup E'\ninstâœÂ¹â· : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹â¶ : RCLike ğ•œ\ninstâœÂ¹âµ : NormedSpace ğ•œ E\ninstâœÂ¹â´ : NormedSpace ğ•œ E'\ninstâœÂ¹Â³ : NormedSpace Real F\ninstâœÂ¹Â² : NormedSpace ğ•œ F\ninstâœÂ¹Â¹ : MeasurableSpace G\nÎ¼ Î½ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ¹â° : CompleteSpace F\ninstâœâ¹ : AddGroup G\ninstâœâ¸ : MeasureTheory.SFinite Î¼\ninstâœâ· : MeasureTheory.SFinite Î½\ninstâœâ¶ : Î¼.IsAddRightInvariant\ninstâœâµ : MeasurableAddâ‚‚ G\ninstâœâ´ : MeasurableNeg G\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedSpace Real E'\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace E'\nhf : MeasureTheory.Integrable f Î½\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => MeasureTheory.convolution f g L Î½ x) ((L (MeasureTheory.integral Î½ fun x => f x)) (MeasureTheory.integral Î¼ fun x => g x))","decl":"theorem integral_convolution [MeasurableAddâ‚‚ G] [MeasurableNeg G] [NormedSpace â„ E]\n    [NormedSpace â„ E'] [CompleteSpace E] [CompleteSpace E'] (hf : Integrable f Î½)\n    (hg : Integrable g Î¼) : âˆ« x, (f â‹†[L, Î½] g) x âˆ‚Î¼ = L (âˆ« x, f x âˆ‚Î½) (âˆ« x, g x âˆ‚Î¼) := by\n  refine (integral_integral_swap (by apply hf.convolution_integrand L hg)).trans ?_\n  simp_rw [integral_comp_comm _ (hg.comp_sub_right _), integral_sub_right_eq_self]\n  exact (L.flip (âˆ« x, g x âˆ‚Î¼)).integral_comp_comm hf\n\n"}
{"name":"MeasureTheory.convolution_assoc'","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nE'' : Type uE''\nF : Type uF\nF' : Type uF'\nF'' : Type uF''\ninstâœÂ²â¶ : NormedAddCommGroup E\ninstâœÂ²âµ : NormedAddCommGroup E'\ninstâœÂ²â´ : NormedAddCommGroup E''\ninstâœÂ²Â³ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ²Â² : RCLike ğ•œ\ninstâœÂ²Â¹ : NormedSpace ğ•œ E\ninstâœÂ²â° : NormedSpace ğ•œ E'\ninstâœÂ¹â¹ : NormedSpace ğ•œ E''\ninstâœÂ¹â¸ : NormedSpace Real F\ninstâœÂ¹â· : NormedSpace ğ•œ F\ninstâœÂ¹â¶ : MeasurableSpace G\nÎ¼ Î½ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ¹âµ : CompleteSpace F\ninstâœÂ¹â´ : NormedAddCommGroup F'\ninstâœÂ¹Â³ : NormedSpace Real F'\ninstâœÂ¹Â² : NormedSpace ğ•œ F'\ninstâœÂ¹Â¹ : CompleteSpace F'\ninstâœÂ¹â° : NormedAddCommGroup F''\ninstâœâ¹ : NormedSpace Real F''\ninstâœâ¸ : NormedSpace ğ•œ F''\ninstâœâ· : CompleteSpace F''\nk : G â†’ E''\nLâ‚‚ : ContinuousLinearMap (RingHom.id ğ•œ) F (ContinuousLinearMap (RingHom.id ğ•œ) E'' F')\nLâ‚ƒ : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F'' F')\nLâ‚„ : ContinuousLinearMap (RingHom.id ğ•œ) E' (ContinuousLinearMap (RingHom.id ğ•œ) E'' F'')\ninstâœâ¶ : AddGroup G\ninstâœâµ : MeasureTheory.SFinite Î¼\ninstâœâ´ : MeasureTheory.SFinite Î½\ninstâœÂ³ : Î¼.IsAddRightInvariant\ninstâœÂ² : MeasurableAddâ‚‚ G\ninstâœÂ¹ : Î½.IsAddRightInvariant\ninstâœ : MeasurableNeg G\nhL : âˆ€ (x : E) (y : E') (z : E''), Eq ((Lâ‚‚ ((L x) y)) z) ((Lâ‚ƒ x) ((Lâ‚„ y) z))\nxâ‚€ : G\nhfg : Filter.Eventually (fun y => MeasureTheory.ConvolutionExistsAt f g y L Î½) (MeasureTheory.ae Î¼)\nhgk : Filter.Eventually (fun x => MeasureTheory.ConvolutionExistsAt g k x Lâ‚„ Î¼) (MeasureTheory.ae Î½)\nhi : MeasureTheory.Integrable (Function.uncurry fun x y => (Lâ‚ƒ (f y)) ((Lâ‚„ (g (HSub.hSub x y))) (k (HSub.hSub xâ‚€ x)))) (Î¼.prod Î½)\nâŠ¢ Eq (MeasureTheory.convolution (MeasureTheory.convolution f g L Î½) k Lâ‚‚ Î¼ xâ‚€) (MeasureTheory.convolution f (MeasureTheory.convolution g k Lâ‚„ Î¼) Lâ‚ƒ Î½ xâ‚€)","decl":"/-- Convolution is associative. This has a weak but inconvenient integrability condition.\nSee also `MeasureTheory.convolution_assoc`. -/\ntheorem convolution_assoc' (hL : âˆ€ (x : E) (y : E') (z : E''), Lâ‚‚ (L x y) z = Lâ‚ƒ x (Lâ‚„ y z))\n    {xâ‚€ : G} (hfg : âˆ€áµ y âˆ‚Î¼, ConvolutionExistsAt f g y L Î½)\n    (hgk : âˆ€áµ x âˆ‚Î½, ConvolutionExistsAt g k x Lâ‚„ Î¼)\n    (hi : Integrable (uncurry fun x y => (Lâ‚ƒ (f y)) ((Lâ‚„ (g (x - y))) (k (xâ‚€ - x)))) (Î¼.prod Î½)) :\n    ((f â‹†[L, Î½] g) â‹†[Lâ‚‚, Î¼] k) xâ‚€ = (f â‹†[Lâ‚ƒ, Î½] g â‹†[Lâ‚„, Î¼] k) xâ‚€ :=\n  calc\n    ((f â‹†[L, Î½] g) â‹†[Lâ‚‚, Î¼] k) xâ‚€ = âˆ« t, Lâ‚‚ (âˆ« s, L (f s) (g (t - s)) âˆ‚Î½) (k (xâ‚€ - t)) âˆ‚Î¼ := rfl\n    _ = âˆ« t, âˆ« s, Lâ‚‚ (L (f s) (g (t - s))) (k (xâ‚€ - t)) âˆ‚Î½ âˆ‚Î¼ :=\n      (integral_congr_ae (hfg.mono fun t ht => ((Lâ‚‚.flip (k (xâ‚€ - t))).integral_comp_comm ht).symm))\n    _ = âˆ« t, âˆ« s, Lâ‚ƒ (f s) (Lâ‚„ (g (t - s)) (k (xâ‚€ - t))) âˆ‚Î½ âˆ‚Î¼ := by simp_rw [hL]\n    _ = âˆ« s, âˆ« t, Lâ‚ƒ (f s) (Lâ‚„ (g (t - s)) (k (xâ‚€ - t))) âˆ‚Î¼ âˆ‚Î½ := by rw [integral_integral_swap hi]\n    _ = âˆ« s, âˆ« u, Lâ‚ƒ (f s) (Lâ‚„ (g u) (k (xâ‚€ - s - u))) âˆ‚Î¼ âˆ‚Î½ := by\n      congr; ext t\n      rw [eq_comm, â† integral_sub_right_eq_self _ t]\n      simp_rw [sub_sub_sub_cancel_right]\n    _ = âˆ« s, Lâ‚ƒ (f s) (âˆ« u, Lâ‚„ (g u) (k (xâ‚€ - s - u)) âˆ‚Î¼) âˆ‚Î½ := by\n      refine integral_congr_ae ?_\n      refine ((quasiMeasurePreserving_sub_left_of_right_invariant Î½ xâ‚€).ae hgk).mono fun t ht => ?_\n      exact (Lâ‚ƒ (f t)).integral_comp_comm ht\n    _ = (f â‹†[Lâ‚ƒ, Î½] g â‹†[Lâ‚„, Î¼] k) xâ‚€ := rfl\n\n"}
{"name":"MeasureTheory.convolution_assoc","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nE'' : Type uE''\nF : Type uF\nF' : Type uF'\nF'' : Type uF''\ninstâœÂ²â¶ : NormedAddCommGroup E\ninstâœÂ²âµ : NormedAddCommGroup E'\ninstâœÂ²â´ : NormedAddCommGroup E''\ninstâœÂ²Â³ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ²Â² : RCLike ğ•œ\ninstâœÂ²Â¹ : NormedSpace ğ•œ E\ninstâœÂ²â° : NormedSpace ğ•œ E'\ninstâœÂ¹â¹ : NormedSpace ğ•œ E''\ninstâœÂ¹â¸ : NormedSpace Real F\ninstâœÂ¹â· : NormedSpace ğ•œ F\ninstâœÂ¹â¶ : MeasurableSpace G\nÎ¼ Î½ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ¹âµ : CompleteSpace F\ninstâœÂ¹â´ : NormedAddCommGroup F'\ninstâœÂ¹Â³ : NormedSpace Real F'\ninstâœÂ¹Â² : NormedSpace ğ•œ F'\ninstâœÂ¹Â¹ : CompleteSpace F'\ninstâœÂ¹â° : NormedAddCommGroup F''\ninstâœâ¹ : NormedSpace Real F''\ninstâœâ¸ : NormedSpace ğ•œ F''\ninstâœâ· : CompleteSpace F''\nk : G â†’ E''\nLâ‚‚ : ContinuousLinearMap (RingHom.id ğ•œ) F (ContinuousLinearMap (RingHom.id ğ•œ) E'' F')\nLâ‚ƒ : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) F'' F')\nLâ‚„ : ContinuousLinearMap (RingHom.id ğ•œ) E' (ContinuousLinearMap (RingHom.id ğ•œ) E'' F'')\ninstâœâ¶ : AddGroup G\ninstâœâµ : MeasureTheory.SFinite Î¼\ninstâœâ´ : MeasureTheory.SFinite Î½\ninstâœÂ³ : Î¼.IsAddRightInvariant\ninstâœÂ² : MeasurableAddâ‚‚ G\ninstâœÂ¹ : Î½.IsAddRightInvariant\ninstâœ : MeasurableNeg G\nhL : âˆ€ (x : E) (y : E') (z : E''), Eq ((Lâ‚‚ ((L x) y)) z) ((Lâ‚ƒ x) ((Lâ‚„ y) z))\nxâ‚€ : G\nhf : MeasureTheory.AEStronglyMeasurable f Î½\nhg : MeasureTheory.AEStronglyMeasurable g Î¼\nhk : MeasureTheory.AEStronglyMeasurable k Î¼\nhfg : Filter.Eventually (fun y => MeasureTheory.ConvolutionExistsAt f g y L Î½) (MeasureTheory.ae Î¼)\nhgk : Filter.Eventually (fun x => MeasureTheory.ConvolutionExistsAt (fun x => Norm.norm (g x)) (fun x => Norm.norm (k x)) x (ContinuousLinearMap.mul Real Real) Î¼) (MeasureTheory.ae Î½)\nhfgk : MeasureTheory.ConvolutionExistsAt (fun x => Norm.norm (f x)) (MeasureTheory.convolution (fun x => Norm.norm (g x)) (fun x => Norm.norm (k x)) (ContinuousLinearMap.mul Real Real) Î¼) xâ‚€ (ContinuousLinearMap.mul Real Real) Î½\nâŠ¢ Eq (MeasureTheory.convolution (MeasureTheory.convolution f g L Î½) k Lâ‚‚ Î¼ xâ‚€) (MeasureTheory.convolution f (MeasureTheory.convolution g k Lâ‚„ Î¼) Lâ‚ƒ Î½ xâ‚€)","decl":"/-- Convolution is associative. This requires that\n* all maps are a.e. strongly measurable w.r.t one of the measures\n* `f â‹†[L, Î½] g` exists almost everywhere\n* `â€–gâ€– â‹†[Î¼] â€–kâ€–` exists almost everywhere\n* `â€–fâ€– â‹†[Î½] (â€–gâ€– â‹†[Î¼] â€–kâ€–)` exists at `xâ‚€` -/\ntheorem convolution_assoc (hL : âˆ€ (x : E) (y : E') (z : E''), Lâ‚‚ (L x y) z = Lâ‚ƒ x (Lâ‚„ y z)) {xâ‚€ : G}\n    (hf : AEStronglyMeasurable f Î½) (hg : AEStronglyMeasurable g Î¼) (hk : AEStronglyMeasurable k Î¼)\n    (hfg : âˆ€áµ y âˆ‚Î¼, ConvolutionExistsAt f g y L Î½)\n    (hgk : âˆ€áµ x âˆ‚Î½, ConvolutionExistsAt (fun x => â€–g xâ€–) (fun x => â€–k xâ€–) x (mul â„ â„) Î¼)\n    (hfgk :\n      ConvolutionExistsAt (fun x => â€–f xâ€–) ((fun x => â€–g xâ€–) â‹†[mul â„ â„, Î¼] fun x => â€–k xâ€–) xâ‚€\n        (mul â„ â„) Î½) :\n    ((f â‹†[L, Î½] g) â‹†[Lâ‚‚, Î¼] k) xâ‚€ = (f â‹†[Lâ‚ƒ, Î½] g â‹†[Lâ‚„, Î¼] k) xâ‚€ := by\n  refine convolution_assoc' L Lâ‚‚ Lâ‚ƒ Lâ‚„ hL hfg (hgk.mono fun x hx => hx.ofNorm Lâ‚„ hg hk) ?_\n  -- the following is similar to `Integrable.convolution_integrand`\n  have h_meas :\n    AEStronglyMeasurable (uncurry fun x y => Lâ‚ƒ (f y) (Lâ‚„ (g x) (k (xâ‚€ - y - x))))\n      (Î¼.prod Î½) := by\n    refine Lâ‚ƒ.aestronglyMeasurable_compâ‚‚ hf.snd ?_\n    refine Lâ‚„.aestronglyMeasurable_compâ‚‚ hg.fst ?_\n    refine (hk.mono_ac ?_).comp_measurable\n      ((measurable_const.sub measurable_snd).sub measurable_fst)\n    refine QuasiMeasurePreserving.absolutelyContinuous ?_\n    refine QuasiMeasurePreserving.prod_of_left\n      ((measurable_const.sub measurable_snd).sub measurable_fst) (Eventually.of_forall fun y => ?_)\n    dsimp only\n    exact quasiMeasurePreserving_sub_left_of_right_invariant Î¼ _\n  have h2_meas :\n    AEStronglyMeasurable (fun y => âˆ« x, â€–Lâ‚ƒ (f y) (Lâ‚„ (g x) (k (xâ‚€ - y - x)))â€– âˆ‚Î¼) Î½ :=\n    h_meas.prod_swap.norm.integral_prod_right'\n  have h3 : map (fun z : G Ã— G => (z.1 - z.2, z.2)) (Î¼.prod Î½) = Î¼.prod Î½ :=\n    (measurePreserving_sub_prod Î¼ Î½).map_eq\n  suffices Integrable (uncurry fun x y => Lâ‚ƒ (f y) (Lâ‚„ (g x) (k (xâ‚€ - y - x)))) (Î¼.prod Î½) by\n    rw [â† h3] at this\n    convert this.comp_measurable (measurable_sub.prod_mk measurable_snd)\n    ext âŸ¨x, yâŸ©\n    simp (config := { unfoldPartialApp := true }) only [uncurry, Function.comp_apply,\n      sub_sub_sub_cancel_right]\n  simp_rw [integrable_prod_iff' h_meas]\n  refine âŸ¨((quasiMeasurePreserving_sub_left_of_right_invariant Î½ xâ‚€).ae hgk).mono fun t ht =>\n    (Lâ‚ƒ (f t)).integrable_comp <| ht.ofNorm Lâ‚„ hg hk, ?_âŸ©\n  refine (hfgk.const_mul (â€–Lâ‚ƒâ€– * â€–Lâ‚„â€–)).mono' h2_meas\n    (((quasiMeasurePreserving_sub_left_of_right_invariant Î½ xâ‚€).ae hgk).mono fun t ht => ?_)\n  simp_rw [convolution_def, mul_apply', mul_mul_mul_comm â€–Lâ‚ƒâ€– â€–Lâ‚„â€–, â† integral_mul_left]\n  rw [Real.norm_of_nonneg (by positivity)]\n  refine integral_mono_of_nonneg (Eventually.of_forall fun t => norm_nonneg _)\n    ((ht.const_mul _).const_mul _) (Eventually.of_forall fun s => ?_)\n  simp only [â† mul_assoc â€–Lâ‚„â€–]\n  apply_rules [ContinuousLinearMap.le_of_opNormâ‚‚_le_of_le, le_rfl]\n\n"}
{"name":"MeasureTheory.convolution_precompR_apply","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nE'' : Type uE''\nF : Type uF\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ninstâœÂ¹â° : NormedAddCommGroup E''\ninstâœâ¹ : NormedAddCommGroup F\nf : G â†’ E\ninstâœâ¸ : RCLike ğ•œ\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedSpace ğ•œ E'\ninstâœâµ : NormedSpace ğ•œ E''\ninstâœâ´ : NormedSpace Real F\ninstâœÂ³ : NormedSpace ğ•œ F\ninstâœÂ² : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : BorelSpace G\ng : G â†’ ContinuousLinearMap (RingHom.id ğ•œ) E'' E'\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhcg : HasCompactSupport g\nhg : Continuous g\nxâ‚€ : G\nx : E''\nâŠ¢ Eq ((MeasureTheory.convolution f g (ContinuousLinearMap.precompR E'' L) Î¼ xâ‚€) x) (MeasureTheory.convolution f (fun a => (g a) x) L Î¼ xâ‚€)","decl":"theorem convolution_precompR_apply {g : G â†’ E'' â†’L[ğ•œ] E'} (hf : LocallyIntegrable f Î¼)\n    (hcg : HasCompactSupport g) (hg : Continuous g) (xâ‚€ : G) (x : E'') :\n    (f â‹†[L.precompR E'', Î¼] g) xâ‚€ x = (f â‹†[L, Î¼] fun a => g a x) xâ‚€ := by\n  have := hcg.convolutionExists_right (L.precompR E'' :) hf hg xâ‚€\n  simp_rw [convolution_def, ContinuousLinearMap.integral_apply this]\n  rfl\n\n"}
{"name":"HasCompactSupport.hasFDerivAt_convolution_right","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹â° : RCLike ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace Real F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : BorelSpace G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : MeasureTheory.SFinite Î¼\ninstâœ : Î¼.IsAddLeftInvariant\nhcg : HasCompactSupport g\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : ContDiff ğ•œ 1 g\nxâ‚€ : G\nâŠ¢ HasFDerivAt (MeasureTheory.convolution f g L Î¼) (MeasureTheory.convolution f (fderiv ğ•œ g) (ContinuousLinearMap.precompR G L) Î¼ xâ‚€) xâ‚€","decl":"/-- Compute the total derivative of `f â‹† g` if `g` is `C^1` with compact support and `f` is locally\nintegrable. To write down the total derivative as a convolution, we use\n`ContinuousLinearMap.precompR`. -/\ntheorem _root_.HasCompactSupport.hasFDerivAt_convolution_right (hcg : HasCompactSupport g)\n    (hf : LocallyIntegrable f Î¼) (hg : ContDiff ğ•œ 1 g) (xâ‚€ : G) :\n    HasFDerivAt (f â‹†[L, Î¼] g) ((f â‹†[L.precompR G, Î¼] fderiv ğ•œ g) xâ‚€) xâ‚€ := by\n  rcases hcg.eq_zero_or_finiteDimensional ğ•œ hg.continuous with (rfl | fin_dim)\n  Â· have : fderiv ğ•œ (0 : G â†’ E') = 0 := fderiv_const (0 : E')\n    simp only [this, convolution_zero, Pi.zero_apply]\n    exact hasFDerivAt_const (0 : F) xâ‚€\n  have : ProperSpace G := FiniteDimensional.proper_rclike ğ•œ G\n  set L' := L.precompR G\n  have h1 : âˆ€á¶  x in ğ“ xâ‚€, AEStronglyMeasurable (fun t => L (f t) (g (x - t))) Î¼ :=\n    Eventually.of_forall\n      (hf.aestronglyMeasurable.convolution_integrand_snd L hg.continuous.aestronglyMeasurable)\n  have h2 : âˆ€ x, AEStronglyMeasurable (fun t => L' (f t) (fderiv ğ•œ g (x - t))) Î¼ :=\n    hf.aestronglyMeasurable.convolution_integrand_snd L'\n      (hg.continuous_fderiv le_rfl).aestronglyMeasurable\n  have h3 : âˆ€ x t, HasFDerivAt (fun x => g (x - t)) (fderiv ğ•œ g (x - t)) x := fun x t â†¦ by\n    simpa using\n      (hg.differentiable le_rfl).differentiableAt.hasFDerivAt.comp x\n        ((hasFDerivAt_id x).sub (hasFDerivAt_const t x))\n  let K' := -tsupport (fderiv ğ•œ g) + closedBall xâ‚€ 1\n  have hK' : IsCompact K' := (hcg.fderiv ğ•œ).neg.add (isCompact_closedBall xâ‚€ 1)\n  -- Porting note: was\n  -- `refine' hasFDerivAt_integral_of_dominated_of_fderiv_le zero_lt_one h1 _ (h2 xâ‚€) _ _ _`\n  -- but it failed; surprisingly, `apply` works\n  apply hasFDerivAt_integral_of_dominated_of_fderiv_le zero_lt_one h1 _ (h2 xâ‚€)\n  Â· filter_upwards with t x hx using\n      (hcg.fderiv ğ•œ).convolution_integrand_bound_right L' (hg.continuous_fderiv le_rfl)\n        (ball_subset_closedBall hx)\n  Â· rw [integrable_indicator_iff hK'.measurableSet]\n    exact ((hf.integrableOn_isCompact hK').norm.const_mul _).mul_const _\n  Â· exact Eventually.of_forall fun t x _ => (L _).hasFDerivAt.comp x (h3 x t)\n  Â· exact hcg.convolutionExists_right L hf hg.continuous xâ‚€\n\n"}
{"name":"HasCompactSupport.hasFDerivAt_convolution_left","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹â´ : NormedAddCommGroup E\ninstâœÂ¹Â³ : NormedAddCommGroup E'\ninstâœÂ¹Â² : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹Â¹ : RCLike ğ•œ\ninstâœÂ¹â° : NormedSpace ğ•œ E\ninstâœâ¹ : NormedSpace ğ•œ E'\ninstâœâ¸ : NormedSpace Real F\ninstâœâ· : NormedSpace ğ•œ F\ninstâœâ¶ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœâµ : NormedAddCommGroup G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : NormedSpace ğ•œ G\ninstâœÂ² : MeasureTheory.SFinite Î¼\ninstâœÂ¹ : Î¼.IsAddLeftInvariant\ninstâœ : Î¼.IsNegInvariant\nhcf : HasCompactSupport f\nhf : ContDiff ğ•œ 1 f\nhg : MeasureTheory.LocallyIntegrable g Î¼\nxâ‚€ : G\nâŠ¢ HasFDerivAt (MeasureTheory.convolution f g L Î¼) (MeasureTheory.convolution (fderiv ğ•œ f) g (ContinuousLinearMap.precompL G L) Î¼ xâ‚€) xâ‚€","decl":"theorem _root_.HasCompactSupport.hasFDerivAt_convolution_left [IsNegInvariant Î¼]\n    (hcf : HasCompactSupport f) (hf : ContDiff ğ•œ 1 f) (hg : LocallyIntegrable g Î¼) (xâ‚€ : G) :\n    HasFDerivAt (f â‹†[L, Î¼] g) ((fderiv ğ•œ f â‹†[L.precompL G, Î¼] g) xâ‚€) xâ‚€ := by\n  simp (config := { singlePass := true }) only [â† convolution_flip]\n  exact hcf.hasFDerivAt_convolution_right L.flip hg hf xâ‚€\n\n"}
{"name":"HasCompactSupport.hasDerivAt_convolution_right","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œ E'\ninstâœÂ³ : NormedSpace Real F\ninstâœÂ² : NormedSpace ğ•œ F\nfâ‚€ : ğ•œ â†’ E\ngâ‚€ : ğ•œ â†’ E'\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\nÎ¼ : MeasureTheory.Measure ğ•œ\ninstâœÂ¹ : Î¼.IsAddLeftInvariant\ninstâœ : MeasureTheory.SFinite Î¼\nhf : MeasureTheory.LocallyIntegrable fâ‚€ Î¼\nhcg : HasCompactSupport gâ‚€\nhg : ContDiff ğ•œ 1 gâ‚€\nxâ‚€ : ğ•œ\nâŠ¢ HasDerivAt (MeasureTheory.convolution fâ‚€ gâ‚€ L Î¼) (MeasureTheory.convolution fâ‚€ (deriv gâ‚€) L Î¼ xâ‚€) xâ‚€","decl":"theorem _root_.HasCompactSupport.hasDerivAt_convolution_right (hf : LocallyIntegrable fâ‚€ Î¼)\n    (hcg : HasCompactSupport gâ‚€) (hg : ContDiff ğ•œ 1 gâ‚€) (xâ‚€ : ğ•œ) :\n    HasDerivAt (fâ‚€ â‹†[L, Î¼] gâ‚€) ((fâ‚€ â‹†[L, Î¼] deriv gâ‚€) xâ‚€) xâ‚€ := by\n  convert (hcg.hasFDerivAt_convolution_right L hf hg xâ‚€).hasDerivAt using 1\n  rw [convolution_precompR_apply L hf (hcg.fderiv ğ•œ) (hg.continuous_fderiv le_rfl)]\n  rfl\n\n"}
{"name":"HasCompactSupport.hasDerivAt_convolution_left","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹â° : NormedAddCommGroup E\ninstâœâ¹ : NormedAddCommGroup E'\ninstâœâ¸ : NormedAddCommGroup F\ninstâœâ· : RCLike ğ•œ\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œ E'\ninstâœâ´ : NormedSpace Real F\ninstâœÂ³ : NormedSpace ğ•œ F\nfâ‚€ : ğ•œ â†’ E\ngâ‚€ : ğ•œ â†’ E'\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\nÎ¼ : MeasureTheory.Measure ğ•œ\ninstâœÂ² : Î¼.IsAddLeftInvariant\ninstâœÂ¹ : MeasureTheory.SFinite Î¼\ninstâœ : Î¼.IsNegInvariant\nhcf : HasCompactSupport fâ‚€\nhf : ContDiff ğ•œ 1 fâ‚€\nhg : MeasureTheory.LocallyIntegrable gâ‚€ Î¼\nxâ‚€ : ğ•œ\nâŠ¢ HasDerivAt (MeasureTheory.convolution fâ‚€ gâ‚€ L Î¼) (MeasureTheory.convolution (deriv fâ‚€) gâ‚€ L Î¼ xâ‚€) xâ‚€","decl":"theorem _root_.HasCompactSupport.hasDerivAt_convolution_left [IsNegInvariant Î¼]\n    (hcf : HasCompactSupport fâ‚€) (hf : ContDiff ğ•œ 1 fâ‚€) (hg : LocallyIntegrable gâ‚€ Î¼) (xâ‚€ : ğ•œ) :\n    HasDerivAt (fâ‚€ â‹†[L, Î¼] gâ‚€) ((deriv fâ‚€ â‹†[L, Î¼] gâ‚€) xâ‚€) xâ‚€ := by\n  simp (config := { singlePass := true }) only [â† convolution_flip]\n  exact hcf.hasDerivAt_convolution_right L.flip hg hf xâ‚€\n\n"}
{"name":"MeasureTheory.hasFDerivAt_convolution_right_with_param","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ninstâœÂ¹â° : RCLike ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace Real F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : BorelSpace G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup P\ninstâœ : NormedSpace ğ•œ P\nÎ¼ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ng : P â†’ G â†’ E'\ns : Set P\nk : Set G\nhs : IsOpen s\nhk : IsCompact k\nhgs : âˆ€ (p : P) (x : G), Membership.mem s p â†’ Not (Membership.mem k x) â†’ Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : ContDiffOn ğ•œ 1 (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\nqâ‚€ : Prod P G\nhqâ‚€ : Membership.mem s qâ‚€.1\nâŠ¢ HasFDerivAt (fun q => MeasureTheory.convolution f (g q.1) L Î¼ q.2) (MeasureTheory.convolution f (fun x => fderiv ğ•œ (Function.HasUncurry.uncurry g) { fst := qâ‚€.1, snd := x }) (ContinuousLinearMap.precompR (Prod P G) L) Î¼ qâ‚€.2) qâ‚€","decl":"/-- The derivative of the convolution `f * g` is given by `f * Dg`, when `f` is locally integrable\nand `g` is `C^1` and compactly supported. Version where `g` depends on an additional parameter in an\nopen subset `s` of a parameter space `P` (and the compact support `k` is independent of the\nparameter in `s`). -/\ntheorem hasFDerivAt_convolution_right_with_param {g : P â†’ G â†’ E'} {s : Set P} {k : Set G}\n    (hs : IsOpen s) (hk : IsCompact k) (hgs : âˆ€ p, âˆ€ x, p âˆˆ s â†’ x âˆ‰ k â†’ g p x = 0)\n    (hf : LocallyIntegrable f Î¼) (hg : ContDiffOn ğ•œ 1 (â†¿g) (s Ã—Ë¢ univ)) (qâ‚€ : P Ã— G)\n    (hqâ‚€ : qâ‚€.1 âˆˆ s) :\n    HasFDerivAt (fun q : P Ã— G => (f â‹†[L, Î¼] g q.1) q.2)\n      ((f â‹†[L.precompR (P Ã— G), Î¼] fun x : G => fderiv ğ•œ (â†¿g) (qâ‚€.1, x)) qâ‚€.2) qâ‚€ := by\n  let g' := fderiv ğ•œ â†¿g\n  have A : âˆ€ p âˆˆ s, Continuous (g p) := fun p hp â†¦ by\n    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_\n    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hp\n  have A' : âˆ€ q : P Ã— G, q.1 âˆˆ s â†’ s Ã—Ë¢ univ âˆˆ ğ“ q := fun q hq â†¦ by\n    apply (hs.prod isOpen_univ).mem_nhds\n    simpa only [mem_prod, mem_univ, and_true] using hq\n  -- The derivative of `g` vanishes away from `k`.\n  have g'_zero : âˆ€ p x, p âˆˆ s â†’ x âˆ‰ k â†’ g' (p, x) = 0 := by\n    intro p x hp hx\n    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv\n    have M2 : ká¶œ âˆˆ ğ“ x := hk.isClosed.isOpen_compl.mem_nhds hx\n    have M1 : s âˆˆ ğ“ p := hs.mem_nhds hp\n    rw [nhds_prod_eq]\n    filter_upwards [prod_mem_prod M1 M2]\n    rintro âŸ¨p, yâŸ© âŸ¨hp, hyâŸ©\n    exact hgs p y hp hy\n  /- We find a small neighborhood of `{qâ‚€.1} Ã— k` on which the derivative is uniformly bounded. This\n    follows from the continuity at all points of the compact set `k`. -/\n  obtain âŸ¨Îµ, C, Îµpos, hâ‚€Îµ, hÎµâŸ© :\n      âˆƒ Îµ C, 0 < Îµ âˆ§ ball qâ‚€.1 Îµ âŠ† s âˆ§ âˆ€ p x, â€–p - qâ‚€.1â€– < Îµ â†’ â€–g' (p, x)â€– â‰¤ C := by\n    have A : IsCompact ({qâ‚€.1} Ã—Ë¢ k) := isCompact_singleton.prod hk\n    obtain âŸ¨t, kt, t_open, htâŸ© : âˆƒ t, {qâ‚€.1} Ã—Ë¢ k âŠ† t âˆ§ IsOpen t âˆ§ IsBounded (g' '' t) := by\n      have B : ContinuousOn g' (s Ã—Ë¢ univ) :=\n        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl\n      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B\n      simp only [prod_subset_prod_iff, hqâ‚€, singleton_subset_iff, subset_univ, and_self_iff,\n        true_or]\n    obtain âŸ¨Îµ, Îµpos, hÎµ, h'ÎµâŸ© :\n      âˆƒ Îµ : â„, 0 < Îµ âˆ§ thickening Îµ ({qâ‚€.fst} Ã—Ë¢ k) âŠ† t âˆ§ ball qâ‚€.1 Îµ âŠ† s := by\n      obtain âŸ¨Îµ, Îµpos, hÎµâŸ© : âˆƒ Îµ : â„, 0 < Îµ âˆ§ thickening Îµ (({qâ‚€.fst} : Set P) Ã—Ë¢ k) âŠ† t :=\n        A.exists_thickening_subset_open t_open kt\n      obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´ : â„, 0 < Î´ âˆ§ ball qâ‚€.1 Î´ âŠ† s := Metric.isOpen_iff.1 hs _ hqâ‚€\n      refine âŸ¨min Îµ Î´, lt_min Îµpos Î´pos, ?_, ?_âŸ©\n      Â· exact Subset.trans (thickening_mono (min_le_left _ _) _) hÎµ\n      Â· exact Subset.trans (ball_subset_ball (min_le_right _ _)) hÎ´\n    obtain âŸ¨C, Cpos, hCâŸ© : âˆƒ C, 0 < C âˆ§ g' '' t âŠ† closedBall 0 C := ht.subset_closedBall_lt 0 0\n    refine âŸ¨Îµ, C, Îµpos, h'Îµ, fun p x hp => ?_âŸ©\n    have hps : p âˆˆ s := h'Îµ (mem_ball_iff_norm.2 hp)\n    by_cases hx : x âˆˆ k\n    Â· have H : (p, x) âˆˆ t := by\n        apply hÎµ\n        refine mem_thickening_iff.2 âŸ¨(qâ‚€.1, x), ?_, ?_âŸ©\n        Â· simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and,\n            exists_eq_right]\n        Â· rw [â† dist_eq_norm] at hp\n          simpa only [Prod.dist_eq, Îµpos, dist_self, max_lt_iff, and_true] using hp\n      have : g' (p, x) âˆˆ closedBall (0 : P Ã— G â†’L[ğ•œ] E') C := hC (mem_image_of_mem _ H)\n      rwa [mem_closedBall_zero_iff] at this\n    Â· have : g' (p, x) = 0 := g'_zero _ _ hps hx\n      rw [this]\n      simpa only [norm_zero] using Cpos.le\n  /- Now, we wish to apply a theorem on differentiation of integrals. For this, we need to check\n    trivial measurability or integrability assumptions (in `I1`, `I2`, `I3`), as well as a uniform\n    integrability assumption over the derivative (in `I4` and `I5`) and pointwise differentiability\n    in `I6`. -/\n  have I1 :\n    âˆ€á¶  x : P Ã— G in ğ“ qâ‚€, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) Î¼ := by\n    filter_upwards [A' qâ‚€ hqâ‚€]\n    rintro âŸ¨p, xâŸ© âŸ¨hp, -âŸ©\n    refine (HasCompactSupport.convolutionExists_right L ?_ hf (A _ hp) _).1\n    apply hk.of_isClosed_subset (isClosed_tsupport _)\n    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed\n  have I2 : Integrable (fun a : G => L (f a) (g qâ‚€.1 (qâ‚€.2 - a))) Î¼ := by\n    have M : HasCompactSupport (g qâ‚€.1) := HasCompactSupport.intro hk fun x hx => hgs qâ‚€.1 x hqâ‚€ hx\n    apply M.convolutionExists_right L hf (A qâ‚€.1 hqâ‚€) qâ‚€.2\n  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (qâ‚€.fst, qâ‚€.snd - a))) Î¼ := by\n    have T : HasCompactSupport fun y => g' (qâ‚€.1, y) :=\n      HasCompactSupport.intro hk fun x hx => g'_zero qâ‚€.1 x hqâ‚€ hx\n    apply (HasCompactSupport.convolutionExists_right (L.precompR (P Ã— G) :) T hf _ qâ‚€.2).1\n    have : ContinuousOn g' (s Ã—Ë¢ univ) :=\n      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl\n    apply this.comp_continuous (continuous_const.prod_mk continuous_id')\n    intro x\n    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hqâ‚€\n  set K' := (-k + {qâ‚€.2} : Set G) with K'_def\n  have hK' : IsCompact K' := hk.neg.add isCompact_singleton\n  obtain âŸ¨U, U_open, K'U, hUâŸ© : âˆƒ U, IsOpen U âˆ§ K' âŠ† U âˆ§ IntegrableOn f U Î¼ :=\n    hf.integrableOn_nhds_isCompact hK'\n  obtain âŸ¨Î´, Î´pos, Î´Îµ, hÎ´âŸ© : âˆƒ Î´, (0 : â„) < Î´ âˆ§ Î´ â‰¤ Îµ âˆ§ K' + ball 0 Î´ âŠ† U := by\n    obtain âŸ¨V, V_mem, hVâŸ© : âˆƒ V âˆˆ ğ“ (0 : G), K' + V âŠ† U :=\n      compact_open_separated_add_right hK' U_open K'U\n    rcases Metric.mem_nhds_iff.1 V_mem with âŸ¨Î´, Î´pos, hÎ´âŸ©\n    refine âŸ¨min Î´ Îµ, lt_min Î´pos Îµpos, min_le_right Î´ Îµ, ?_âŸ©\n    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hÎ´)).trans hV\n  -- Porting note: added to speed up the line below.\n  letI := ContinuousLinearMap.hasOpNorm (ğ•œ := ğ•œ) (ğ•œâ‚‚ := ğ•œ) (E := E)\n    (F := (P Ã— G â†’L[ğ•œ] E') â†’L[ğ•œ] P Ã— G â†’L[ğ•œ] F) (Ïƒâ‚â‚‚ := RingHom.id ğ•œ)\n  let bound : G â†’ â„ := indicator U fun t => â€–(L.precompR (P Ã— G))â€– * â€–f tâ€– * C\n  have I4 : âˆ€áµ a : G âˆ‚Î¼, âˆ€ x : P Ã— G, dist x qâ‚€ < Î´ â†’\n      â€–L.precompR (P Ã— G) (f a) (g' (x.fst, x.snd - a))â€– â‰¤ bound a := by\n    filter_upwards with a x hx\n    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx\n    have : (-tsupport fun a => g' (x.1, a)) + ball qâ‚€.2 Î´ âŠ† U := by\n      apply Subset.trans _ hÎ´\n      rw [K'_def, add_assoc]\n      apply add_subset_add\n      Â· rw [neg_subset_neg]\n        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed\n        apply g'_zero x.1 z (hâ‚€Îµ _) hz\n        rw [mem_ball_iff_norm]\n        exact ((le_max_left _ _).trans_lt hx).trans_le Î´Îµ\n      Â· simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]\n    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this\n    Â· intro y\n      exact hÎµ _ _ (((le_max_left _ _).trans_lt hx).trans_le Î´Îµ)\n    Â· rw [mem_ball_iff_norm]\n      exact (le_max_right _ _).trans_lt hx\n  have I5 : Integrable bound Î¼ := by\n    rw [integrable_indicator_iff U_open.measurableSet]\n    exact (hU.norm.const_mul _).mul_const _\n  have I6 : âˆ€áµ a : G âˆ‚Î¼, âˆ€ x : P Ã— G, dist x qâ‚€ < Î´ â†’\n      HasFDerivAt (fun x : P Ã— G => L (f a) (g x.1 (x.2 - a)))\n        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by\n    filter_upwards with a x hx\n    apply (L _).hasFDerivAt.comp x\n    have N : s Ã—Ë¢ univ âˆˆ ğ“ (x.1, x.2 - a) := by\n      apply A'\n      apply hâ‚€Îµ\n      rw [Prod.dist_eq] at hx\n      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) Î´Îµ\n    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt\n    have Z' :\n        HasFDerivAt (fun x : P Ã— G => (x.1, x.2 - a)) (ContinuousLinearMap.id ğ•œ (P Ã— G)) x := by\n      have : (fun x : P Ã— G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by\n        ext x <;> simp only [Pi.sub_apply, _root_.id, Prod.fst_sub, sub_zero, Prod.snd_sub]\n      rw [this]\n      exact (hasFDerivAt_id x).sub_const (0, a)\n    exact Z.comp x Z'\n  exact hasFDerivAt_integral_of_dominated_of_fderiv_le Î´pos I1 I2 I3 I4 I5 I6\n\n"}
{"name":"MeasureTheory.contDiffOn_convolution_right_with_param_aux","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nE : Type uE\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : RCLike ğ•œ\ninstâœÂ¹Â¹ : NormedSpace ğ•œ E\nG E' F P : Type uP\ninstâœÂ¹â° : NormedAddCommGroup E'\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace Real F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : MeasurableSpace G\nÎ¼ : MeasureTheory.Measure G\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : BorelSpace G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup P\ninstâœ : NormedSpace ğ•œ P\nf : G â†’ E\nn : ENat\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ng : P â†’ G â†’ E'\ns : Set P\nk : Set G\nhs : IsOpen s\nhk : IsCompact k\nhgs : âˆ€ (p : P) (x : G), Membership.mem s p â†’ Not (Membership.mem k x) â†’ Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : ContDiffOn ğ•œ (â†‘n) (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\nâŠ¢ ContDiffOn ğ•œ (â†‘n) (fun q => MeasureTheory.convolution f (g q.1) L Î¼ q.2) (SProd.sprod s Set.univ)","decl":"/-- The convolution `f * g` is `C^n` when `f` is locally integrable and `g` is `C^n` and compactly\nsupported. Version where `g` depends on an additional parameter in an open subset `s` of a\nparameter space `P` (and the compact support `k` is independent of the parameter in `s`).\nIn this version, all the types belong to the same universe (to get an induction working in the\nproof). Use instead `contDiffOn_convolution_right_with_param`, which removes this restriction. -/\ntheorem contDiffOn_convolution_right_with_param_aux {G : Type uP} {E' : Type uP} {F : Type uP}\n    {P : Type uP} [NormedAddCommGroup E'] [NormedAddCommGroup F] [NormedSpace ğ•œ E']\n    [NormedSpace â„ F] [NormedSpace ğ•œ F] [MeasurableSpace G]\n    {Î¼ : Measure G}\n    [NormedAddCommGroup G] [BorelSpace G] [NormedSpace ğ•œ G] [NormedAddCommGroup P] [NormedSpace ğ•œ P]\n    {f : G â†’ E} {n : â„•âˆ} (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) {g : P â†’ G â†’ E'} {s : Set P} {k : Set G}\n    (hs : IsOpen s) (hk : IsCompact k) (hgs : âˆ€ p, âˆ€ x, p âˆˆ s â†’ x âˆ‰ k â†’ g p x = 0)\n    (hf : LocallyIntegrable f Î¼) (hg : ContDiffOn ğ•œ n (â†¿g) (s Ã—Ë¢ univ)) :\n    ContDiffOn ğ•œ n (fun q : P Ã— G => (f â‹†[L, Î¼] g q.1) q.2) (s Ã—Ë¢ univ) := by\n  /- We have a formula for the derivation of `f * g`, which is of the same form, thanks to\n    `hasFDerivAt_convolution_right_with_param`. Therefore, we can prove the result by induction on\n    `n` (but for this we need the spaces at the different steps of the induction to live in the same\n    universe, which is why we make the assumption in the lemma that all the relevant spaces\n    come from the same universe). -/\n  induction n using ENat.nat_induction generalizing g E' F with\n  | h0 =>\n    rw [WithTop.coe_zero, contDiffOn_zero] at hg âŠ¢\n    exact continuousOn_convolution_right_with_param L hk hgs hf hg\n  | hsuc n ih =>\n    simp only [Nat.succ_eq_add_one, Nat.cast_add, Nat.cast_one, WithTop.coe_add,\n      WithTop.coe_natCast, WithTop.coe_one] at hg âŠ¢\n    let f' : P â†’ G â†’ P Ã— G â†’L[ğ•œ] F := fun p a =>\n      (f â‹†[L.precompR (P Ã— G), Î¼] fun x : G => fderiv ğ•œ (uncurry g) (p, x)) a\n    have A : âˆ€ qâ‚€ : P Ã— G, qâ‚€.1 âˆˆ s â†’\n        HasFDerivAt (fun q : P Ã— G => (f â‹†[L, Î¼] g q.1) q.2) (f' qâ‚€.1 qâ‚€.2) qâ‚€ :=\n      hasFDerivAt_convolution_right_with_param L hs hk hgs hf hg.one_of_succ\n    rw [contDiffOn_succ_iff_fderiv_of_isOpen (hs.prod (@isOpen_univ G _))] at hg âŠ¢\n    refine âŸ¨?_, by simp, ?_âŸ©\n    Â· rintro âŸ¨p, xâŸ© âŸ¨hp, -âŸ©\n      exact (A (p, x) hp).differentiableAt.differentiableWithinAt\n    Â· suffices H : ContDiffOn ğ•œ n (â†¿f') (s Ã—Ë¢ univ) by\n        apply H.congr\n        rintro âŸ¨p, xâŸ© âŸ¨hp, -âŸ©\n        exact (A (p, x) hp).fderiv\n      have B : âˆ€ (p : P) (x : G), p âˆˆ s â†’ x âˆ‰ k â†’ fderiv ğ•œ (uncurry g) (p, x) = 0 := by\n        intro p x hp hx\n        apply (hasFDerivAt_zero_of_eventually_const (0 : E') _).fderiv\n        have M2 : ká¶œ âˆˆ ğ“ x := IsOpen.mem_nhds hk.isClosed.isOpen_compl hx\n        have M1 : s âˆˆ ğ“ p := hs.mem_nhds hp\n        rw [nhds_prod_eq]\n        filter_upwards [prod_mem_prod M1 M2]\n        rintro âŸ¨p, yâŸ© âŸ¨hp, hyâŸ©\n        exact hgs p y hp hy\n      apply ih (L.precompR (P Ã— G) :) B\n      convert hg.2.2\n  | htop ih =>\n    rw [contDiffOn_infty] at hg âŠ¢\n    exact fun n â†¦ ih n L hgs (hg n)\n\n"}
{"name":"MeasureTheory.contDiffOn_convolution_right_with_param","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\ninstâœÂ¹â° : RCLike ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace Real F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : BorelSpace G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup P\ninstâœ : NormedSpace ğ•œ P\nÎ¼ : MeasureTheory.Measure G\nf : G â†’ E\nn : ENat\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ng : P â†’ G â†’ E'\ns : Set P\nk : Set G\nhs : IsOpen s\nhk : IsCompact k\nhgs : âˆ€ (p : P) (x : G), Membership.mem s p â†’ Not (Membership.mem k x) â†’ Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : ContDiffOn ğ•œ (â†‘n) (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\nâŠ¢ ContDiffOn ğ•œ (â†‘n) (fun q => MeasureTheory.convolution f (g q.1) L Î¼ q.2) (SProd.sprod s Set.univ)","decl":"/-- The convolution `f * g` is `C^n` when `f` is locally integrable and `g` is `C^n` and compactly\nsupported. Version where `g` depends on an additional parameter in an open subset `s` of a\nparameter space `P` (and the compact support `k` is independent of the parameter in `s`). -/\ntheorem contDiffOn_convolution_right_with_param {f : G â†’ E} {n : â„•âˆ} (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F)\n    {g : P â†’ G â†’ E'} {s : Set P} {k : Set G} (hs : IsOpen s) (hk : IsCompact k)\n    (hgs : âˆ€ p, âˆ€ x, p âˆˆ s â†’ x âˆ‰ k â†’ g p x = 0) (hf : LocallyIntegrable f Î¼)\n    (hg : ContDiffOn ğ•œ n (â†¿g) (s Ã—Ë¢ univ)) :\n    ContDiffOn ğ•œ n (fun q : P Ã— G => (f â‹†[L, Î¼] g q.1) q.2) (s Ã—Ë¢ univ) := by\n  /- The result is known when all the universes are the same, from\n    `contDiffOn_convolution_right_with_param_aux`. We reduce to this situation by pushing\n    everything through `ULift` continuous linear equivalences. -/\n  let eG : Type max uG uE' uF uP := ULift.{max uE' uF uP} G\n  borelize eG\n  let eE' : Type max uE' uG uF uP := ULift.{max uG uF uP} E'\n  let eF : Type max uF uG uE' uP := ULift.{max uG uE' uP} F\n  let eP : Type max uP uG uE' uF := ULift.{max uG uE' uF} P\n  let isoG : eG â‰ƒL[ğ•œ] G := ContinuousLinearEquiv.ulift\n  let isoE' : eE' â‰ƒL[ğ•œ] E' := ContinuousLinearEquiv.ulift\n  let isoF : eF â‰ƒL[ğ•œ] F := ContinuousLinearEquiv.ulift\n  let isoP : eP â‰ƒL[ğ•œ] P := ContinuousLinearEquiv.ulift\n  let ef := f âˆ˜ isoG\n  let eÎ¼ : Measure eG := Measure.map isoG.symm Î¼\n  let eg : eP â†’ eG â†’ eE' := fun ep ex => isoE'.symm (g (isoP ep) (isoG ex))\n  let eL :=\n    ContinuousLinearMap.comp\n      ((ContinuousLinearEquiv.arrowCongr isoE' isoF).symm : (E' â†’L[ğ•œ] F) â†’L[ğ•œ] eE' â†’L[ğ•œ] eF) L\n  let R := fun q : eP Ã— eG => (ef â‹†[eL, eÎ¼] eg q.1) q.2\n  have R_contdiff : ContDiffOn ğ•œ n R ((isoP â»Â¹' s) Ã—Ë¢ univ) := by\n    have hek : IsCompact (isoG â»Â¹' k) := isoG.toHomeomorph.isClosedEmbedding.isCompact_preimage hk\n    have hes : IsOpen (isoP â»Â¹' s) := isoP.continuous.isOpen_preimage _ hs\n    refine contDiffOn_convolution_right_with_param_aux eL hes hek ?_ ?_ ?_\n    Â· intro p x hp hx\n      simp only [eg, (Â· âˆ˜ Â·), ContinuousLinearEquiv.prod_apply, LinearIsometryEquiv.coe_coe,\n        ContinuousLinearEquiv.map_eq_zero_iff]\n      exact hgs _ _ hp hx\n    Â· exact (locallyIntegrable_map_homeomorph isoG.symm.toHomeomorph).2 hf\n    Â· apply isoE'.symm.contDiff.comp_contDiffOn\n      apply hg.comp (isoP.prod isoG).contDiff.contDiffOn\n      rintro âŸ¨p, xâŸ© âŸ¨hp, -âŸ©\n      simpa only [mem_preimage, ContinuousLinearEquiv.prod_apply, prod_mk_mem_set_prod_eq, mem_univ,\n        and_true] using hp\n  have A : ContDiffOn ğ•œ n (isoF âˆ˜ R âˆ˜ (isoP.prod isoG).symm) (s Ã—Ë¢ univ) := by\n    apply isoF.contDiff.comp_contDiffOn\n    apply R_contdiff.comp (ContinuousLinearEquiv.contDiff _).contDiffOn\n    rintro âŸ¨p, xâŸ© âŸ¨hp, -âŸ©\n    simpa only [mem_preimage, mem_prod, mem_univ, and_true, ContinuousLinearEquiv.prod_symm,\n      ContinuousLinearEquiv.prod_apply, ContinuousLinearEquiv.apply_symm_apply] using hp\n  have : isoF âˆ˜ R âˆ˜ (isoP.prod isoG).symm = fun q : P Ã— G => (f â‹†[L, Î¼] g q.1) q.2 := by\n    apply funext\n    rintro âŸ¨p, xâŸ©\n    simp only [LinearIsometryEquiv.coe_coe, (Â· âˆ˜ Â·), ContinuousLinearEquiv.prod_symm,\n      ContinuousLinearEquiv.prod_apply]\n    simp only [R, convolution, coe_comp', ContinuousLinearEquiv.coe_coe, (Â· âˆ˜ Â·)]\n    rw [IsClosedEmbedding.integral_map, â† isoF.integral_comp_comm]\n    Â· rfl\n    Â· exact isoG.symm.toHomeomorph.isClosedEmbedding\n  simp_rw [this] at A\n  exact A\n\n"}
{"name":"MeasureTheory.contDiffOn_convolution_right_with_param_comp","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\ninstâœÂ¹â° : RCLike ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace Real F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : BorelSpace G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup P\ninstâœ : NormedSpace ğ•œ P\nÎ¼ : MeasureTheory.Measure G\nn : ENat\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ns : Set P\nv : P â†’ G\nhv : ContDiffOn ğ•œ (â†‘n) v s\nf : G â†’ E\ng : P â†’ G â†’ E'\nk : Set G\nhs : IsOpen s\nhk : IsCompact k\nhgs : âˆ€ (p : P) (x : G), Membership.mem s p â†’ Not (Membership.mem k x) â†’ Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : ContDiffOn ğ•œ (â†‘n) (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\nâŠ¢ ContDiffOn ğ•œ (â†‘n) (fun x => MeasureTheory.convolution f (g x) L Î¼ (v x)) s","decl":"/-- The convolution `f * g` is `C^n` when `f` is locally integrable and `g` is `C^n` and compactly\nsupported. Version where `g` depends on an additional parameter in an open subset `s` of a\nparameter space `P` (and the compact support `k` is independent of the parameter in `s`),\ngiven in terms of composition with an additional `C^n` function. -/\ntheorem contDiffOn_convolution_right_with_param_comp {n : â„•âˆ} (L : E â†’L[ğ•œ] E' â†’L[ğ•œ] F) {s : Set P}\n    {v : P â†’ G} (hv : ContDiffOn ğ•œ n v s) {f : G â†’ E} {g : P â†’ G â†’ E'} {k : Set G} (hs : IsOpen s)\n    (hk : IsCompact k) (hgs : âˆ€ p, âˆ€ x, p âˆˆ s â†’ x âˆ‰ k â†’ g p x = 0) (hf : LocallyIntegrable f Î¼)\n    (hg : ContDiffOn ğ•œ n (â†¿g) (s Ã—Ë¢ univ)) : ContDiffOn ğ•œ n (fun x => (f â‹†[L, Î¼] g x) (v x)) s := by\n  apply (contDiffOn_convolution_right_with_param L hs hk hgs hf hg).comp (contDiffOn_id.prod hv)\n  intro x hx\n  simp only [hx, mem_preimage, prod_mk_mem_set_prod_eq, mem_univ, and_self_iff, _root_.id]\n\n"}
{"name":"MeasureTheory.contDiffOn_convolution_left_with_param","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninstâœÂ¹âµ : NormedAddCommGroup E\ninstâœÂ¹â´ : NormedAddCommGroup E'\ninstâœÂ¹Â³ : NormedAddCommGroup F\ninstâœÂ¹Â² : RCLike ğ•œ\ninstâœÂ¹Â¹ : NormedSpace ğ•œ E\ninstâœÂ¹â° : NormedSpace ğ•œ E'\ninstâœâ¹ : NormedSpace Real F\ninstâœâ¸ : NormedSpace ğ•œ F\ninstâœâ· : MeasurableSpace G\ninstâœâ¶ : NormedAddCommGroup G\ninstâœâµ : BorelSpace G\ninstâœâ´ : NormedSpace ğ•œ G\ninstâœÂ³ : NormedAddCommGroup P\ninstâœÂ² : NormedSpace ğ•œ P\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsAddLeftInvariant\ninstâœ : Î¼.IsNegInvariant\nL : ContinuousLinearMap (RingHom.id ğ•œ) E' (ContinuousLinearMap (RingHom.id ğ•œ) E F)\nf : G â†’ E\nn : ENat\ng : P â†’ G â†’ E'\ns : Set P\nk : Set G\nhs : IsOpen s\nhk : IsCompact k\nhgs : âˆ€ (p : P) (x : G), Membership.mem s p â†’ Not (Membership.mem k x) â†’ Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : ContDiffOn ğ•œ (â†‘n) (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\nâŠ¢ ContDiffOn ğ•œ (â†‘n) (fun q => MeasureTheory.convolution (g q.1) f L Î¼ q.2) (SProd.sprod s Set.univ)","decl":"/-- The convolution `g * f` is `C^n` when `f` is locally integrable and `g` is `C^n` and compactly\nsupported. Version where `g` depends on an additional parameter in an open subset `s` of a\nparameter space `P` (and the compact support `k` is independent of the parameter in `s`). -/\ntheorem contDiffOn_convolution_left_with_param [Î¼.IsAddLeftInvariant] [Î¼.IsNegInvariant]\n    (L : E' â†’L[ğ•œ] E â†’L[ğ•œ] F) {f : G â†’ E} {n : â„•âˆ} {g : P â†’ G â†’ E'} {s : Set P} {k : Set G}\n    (hs : IsOpen s) (hk : IsCompact k) (hgs : âˆ€ p, âˆ€ x, p âˆˆ s â†’ x âˆ‰ k â†’ g p x = 0)\n    (hf : LocallyIntegrable f Î¼) (hg : ContDiffOn ğ•œ n (â†¿g) (s Ã—Ë¢ univ)) :\n    ContDiffOn ğ•œ n (fun q : P Ã— G => (g q.1 â‹†[L, Î¼] f) q.2) (s Ã—Ë¢ univ) := by\n  simpa only [convolution_flip] using contDiffOn_convolution_right_with_param L.flip hs hk hgs hf hg\n\n"}
{"name":"MeasureTheory.contDiffOn_convolution_left_with_param_comp","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninstâœÂ¹âµ : NormedAddCommGroup E\ninstâœÂ¹â´ : NormedAddCommGroup E'\ninstâœÂ¹Â³ : NormedAddCommGroup F\ninstâœÂ¹Â² : RCLike ğ•œ\ninstâœÂ¹Â¹ : NormedSpace ğ•œ E\ninstâœÂ¹â° : NormedSpace ğ•œ E'\ninstâœâ¹ : NormedSpace Real F\ninstâœâ¸ : NormedSpace ğ•œ F\ninstâœâ· : MeasurableSpace G\ninstâœâ¶ : NormedAddCommGroup G\ninstâœâµ : BorelSpace G\ninstâœâ´ : NormedSpace ğ•œ G\ninstâœÂ³ : NormedAddCommGroup P\ninstâœÂ² : NormedSpace ğ•œ P\nÎ¼ : MeasureTheory.Measure G\ninstâœÂ¹ : Î¼.IsAddLeftInvariant\ninstâœ : Î¼.IsNegInvariant\nL : ContinuousLinearMap (RingHom.id ğ•œ) E' (ContinuousLinearMap (RingHom.id ğ•œ) E F)\ns : Set P\nn : ENat\nv : P â†’ G\nhv : ContDiffOn ğ•œ (â†‘n) v s\nf : G â†’ E\ng : P â†’ G â†’ E'\nk : Set G\nhs : IsOpen s\nhk : IsCompact k\nhgs : âˆ€ (p : P) (x : G), Membership.mem s p â†’ Not (Membership.mem k x) â†’ Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : ContDiffOn ğ•œ (â†‘n) (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\nâŠ¢ ContDiffOn ğ•œ (â†‘n) (fun x => MeasureTheory.convolution (g x) f L Î¼ (v x)) s","decl":"/-- The convolution `g * f` is `C^n` when `f` is locally integrable and `g` is `C^n` and compactly\nsupported. Version where `g` depends on an additional parameter in an open subset `s` of a\nparameter space `P` (and the compact support `k` is independent of the parameter in `s`),\ngiven in terms of composition with additional `C^n` functions. -/\ntheorem contDiffOn_convolution_left_with_param_comp [Î¼.IsAddLeftInvariant] [Î¼.IsNegInvariant]\n    (L : E' â†’L[ğ•œ] E â†’L[ğ•œ] F) {s : Set P} {n : â„•âˆ} {v : P â†’ G} (hv : ContDiffOn ğ•œ n v s) {f : G â†’ E}\n    {g : P â†’ G â†’ E'} {k : Set G} (hs : IsOpen s) (hk : IsCompact k)\n    (hgs : âˆ€ p, âˆ€ x, p âˆˆ s â†’ x âˆ‰ k â†’ g p x = 0) (hf : LocallyIntegrable f Î¼)\n    (hg : ContDiffOn ğ•œ n (â†¿g) (s Ã—Ë¢ univ)) : ContDiffOn ğ•œ n (fun x => (g x â‹†[L, Î¼] f) (v x)) s := by\n  apply (contDiffOn_convolution_left_with_param L hs hk hgs hf hg).comp (contDiffOn_id.prod hv)\n  intro x hx\n  simp only [hx, mem_preimage, prod_mk_mem_set_prod_eq, mem_univ, and_self_iff, _root_.id]\n\n"}
{"name":"HasCompactSupport.contDiff_convolution_right","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedAddCommGroup E'\ninstâœâ¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœâ¸ : RCLike ğ•œ\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedSpace ğ•œ E'\ninstâœâµ : NormedSpace Real F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : MeasurableSpace G\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : BorelSpace G\ninstâœ : NormedSpace ğ•œ G\nÎ¼ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\nn : ENat\nhcg : HasCompactSupport g\nhf : MeasureTheory.LocallyIntegrable f Î¼\nhg : ContDiff ğ•œ (â†‘n) g\nâŠ¢ ContDiff ğ•œ (â†‘n) (MeasureTheory.convolution f g L Î¼)","decl":"theorem _root_.HasCompactSupport.contDiff_convolution_right {n : â„•âˆ} (hcg : HasCompactSupport g)\n    (hf : LocallyIntegrable f Î¼) (hg : ContDiff ğ•œ n g) : ContDiff ğ•œ n (f â‹†[L, Î¼] g) := by\n  rcases exists_compact_iff_hasCompactSupport.2 hcg with âŸ¨k, hk, h'kâŸ©\n  rw [â† contDiffOn_univ]\n  exact contDiffOn_convolution_right_with_param_comp L contDiffOn_id isOpen_univ hk\n    (fun p x _ hx => h'k x hx) hf (hg.comp contDiff_snd).contDiffOn\n\n"}
{"name":"HasCompactSupport.contDiff_convolution_left","module":"Mathlib.Analysis.Convolution","initialProofState":"ğ•œ : Type uğ•œ\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â³ : NormedAddCommGroup E\ninstâœÂ¹Â² : NormedAddCommGroup E'\ninstâœÂ¹Â¹ : NormedAddCommGroup F\nf : G â†’ E\ng : G â†’ E'\ninstâœÂ¹â° : RCLike ğ•œ\ninstâœâ¹ : NormedSpace ğ•œ E\ninstâœâ¸ : NormedSpace ğ•œ E'\ninstâœâ· : NormedSpace Real F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : MeasurableSpace G\ninstâœâ´ : NormedAddCommGroup G\ninstâœÂ³ : BorelSpace G\ninstâœÂ² : NormedSpace ğ•œ G\nÎ¼ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) E' F)\ninstâœÂ¹ : Î¼.IsAddLeftInvariant\ninstâœ : Î¼.IsNegInvariant\nn : ENat\nhcf : HasCompactSupport f\nhf : ContDiff ğ•œ (â†‘n) f\nhg : MeasureTheory.LocallyIntegrable g Î¼\nâŠ¢ ContDiff ğ•œ (â†‘n) (MeasureTheory.convolution f g L Î¼)","decl":"theorem _root_.HasCompactSupport.contDiff_convolution_left [Î¼.IsAddLeftInvariant] [Î¼.IsNegInvariant]\n    {n : â„•âˆ} (hcf : HasCompactSupport f) (hf : ContDiff ğ•œ n f) (hg : LocallyIntegrable g Î¼) :\n    ContDiff ğ•œ n (f â‹†[L, Î¼] g) := by\n  rw [â† convolution_flip]\n  exact hcf.contDiff_convolution_right L.flip hg hf\n\n"}
{"name":"MeasureTheory.posConvolution_eq_convolution_indicator","module":"Mathlib.Analysis.Convolution","initialProofState":"E : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedAddCommGroup E'\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedSpace Real E'\ninstâœÂ¹ : NormedSpace Real F\nf : Real â†’ E\ng : Real â†’ E'\nL : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E' F)\nÎ½ : autoParam (MeasureTheory.Measure Real) _autoâœ\ninstâœ : MeasureTheory.NoAtoms Î½\nâŠ¢ Eq (MeasureTheory.posConvolution f g L Î½) (MeasureTheory.convolution ((Set.Ioi 0).indicator f) ((Set.Ioi 0).indicator g) L Î½)","decl":"theorem posConvolution_eq_convolution_indicator (f : â„ â†’ E) (g : â„ â†’ E') (L : E â†’L[â„] E' â†’L[â„] F)\n    (Î½ : Measure â„ := by volume_tac) [NoAtoms Î½] :\n    posConvolution f g L Î½ = convolution (indicator (Ioi 0) f) (indicator (Ioi 0) g) L Î½ := by\n  ext1 x\n  -- Porting note: was `rw [convolution, posConvolution, indicator]`, now `rw` can't do it\n  -- the `rw` unfolded only one `indicator`; now we unfold it everywhere, so we need to adjust\n  -- `rw`s below\n  unfold convolution posConvolution indicator; simp only\n  split_ifs with h\n  Â· rw [intervalIntegral.integral_of_le (le_of_lt h), integral_Ioc_eq_integral_Ioo, â†\n      integral_indicator (measurableSet_Ioo : MeasurableSet (Ioo 0 x))]\n    congr 1 with t : 1\n    have : t â‰¤ 0 âˆ¨ t âˆˆ Ioo 0 x âˆ¨ x â‰¤ t := by\n      rcases le_or_lt t 0 with (h | h)\n      Â· exact Or.inl h\n      Â· rcases lt_or_le t x with (h' | h')\n        exacts [Or.inr (Or.inl âŸ¨h, h'âŸ©), Or.inr (Or.inr h')]\n    rcases this with (ht | ht | ht)\n    Â· -- Porting note: was\n      -- rw [indicator_of_not_mem (not_mem_Ioo_of_le ht), indicator_of_not_mem (not_mem_Ioi.mpr ht),\n      --   ContinuousLinearMap.map_zero, ContinuousLinearMap.zero_apply]\n      rw [indicator_of_not_mem (not_mem_Ioo_of_le ht), if_neg (not_mem_Ioi.mpr ht),\n        ContinuousLinearMap.map_zero, ContinuousLinearMap.zero_apply]\n    Â· -- Porting note: was\n      -- rw [indicator_of_mem ht, indicator_of_mem (mem_Ioi.mpr ht.1),\n      --     indicator_of_mem (mem_Ioi.mpr <| sub_pos.mpr ht.2)]\n      rw [indicator_of_mem ht, if_pos (mem_Ioi.mpr ht.1),\n        if_pos (mem_Ioi.mpr <| sub_pos.mpr ht.2)]\n    Â· -- Porting note: was\n      -- rw [indicator_of_not_mem (not_mem_Ioo_of_ge ht),\n      --     indicator_of_not_mem (not_mem_Ioi.mpr (sub_nonpos_of_le ht)),\n      --     ContinuousLinearMap.map_zero]\n      rw [indicator_of_not_mem (not_mem_Ioo_of_ge ht),\n        if_neg (not_mem_Ioi.mpr (sub_nonpos_of_le ht)), ContinuousLinearMap.map_zero]\n  Â· convert (integral_zero â„ F).symm with t\n    by_cases ht : 0 < t\n    Â· -- Porting note: was\n      -- rw [indicator_of_not_mem (_ : x - t âˆ‰ Ioi 0), ContinuousLinearMap.map_zero]\n      rw [if_neg (_ : x - t âˆ‰ Ioi 0), ContinuousLinearMap.map_zero]\n      rw [not_mem_Ioi] at h âŠ¢\n      exact sub_nonpos.mpr (h.trans ht.le)\n    Â· -- Porting note: was\n      -- rw [indicator_of_not_mem (mem_Ioi.not.mpr ht), ContinuousLinearMap.map_zero,\n      --  ContinuousLinearMap.zero_apply]\n      rw [if_neg (mem_Ioi.not.mpr ht), ContinuousLinearMap.map_zero,\n        ContinuousLinearMap.zero_apply]\n\n"}
{"name":"MeasureTheory.integrable_posConvolution","module":"Mathlib.Analysis.Convolution","initialProofState":"E : Type uE\nE' : Type uE'\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedAddCommGroup E'\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : NormedSpace Real E'\ninstâœâ´ : NormedSpace Real F\nf : Real â†’ E\ng : Real â†’ E'\nÎ¼ Î½ : MeasureTheory.Measure Real\ninstâœÂ³ : MeasureTheory.SFinite Î¼\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : Î¼.IsAddRightInvariant\ninstâœ : MeasureTheory.NoAtoms Î½\nhf : MeasureTheory.IntegrableOn f (Set.Ioi 0) Î½\nhg : MeasureTheory.IntegrableOn g (Set.Ioi 0) Î¼\nL : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E' F)\nâŠ¢ MeasureTheory.Integrable (MeasureTheory.posConvolution f g L Î½) Î¼","decl":"theorem integrable_posConvolution {f : â„ â†’ E} {g : â„ â†’ E'} {Î¼ Î½ : Measure â„} [SFinite Î¼]\n    [SFinite Î½] [IsAddRightInvariant Î¼] [NoAtoms Î½] (hf : IntegrableOn f (Ioi 0) Î½)\n    (hg : IntegrableOn g (Ioi 0) Î¼) (L : E â†’L[â„] E' â†’L[â„] F) :\n    Integrable (posConvolution f g L Î½) Î¼ := by\n  rw [â† integrable_indicator_iff (measurableSet_Ioi : MeasurableSet (Ioi (0 : â„)))] at hf hg\n  rw [posConvolution_eq_convolution_indicator f g L Î½]\n  exact (hf.convolution_integrand L hg).integral_prod_left\n\n"}
{"name":"MeasureTheory.integral_posConvolution","module":"Mathlib.Analysis.Convolution","initialProofState":"E : Type uE\nE' : Type uE'\nF : Type uF\ninstâœÂ¹Â² : NormedAddCommGroup E\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ninstâœÂ¹â° : NormedAddCommGroup F\ninstâœâ¹ : NormedSpace Real E\ninstâœâ¸ : NormedSpace Real E'\ninstâœâ· : NormedSpace Real F\ninstâœâ¶ : CompleteSpace E\ninstâœâµ : CompleteSpace E'\ninstâœâ´ : CompleteSpace F\nÎ¼ Î½ : MeasureTheory.Measure Real\ninstâœÂ³ : MeasureTheory.SFinite Î¼\ninstâœÂ² : MeasureTheory.SFinite Î½\ninstâœÂ¹ : Î¼.IsAddRightInvariant\ninstâœ : MeasureTheory.NoAtoms Î½\nf : Real â†’ E\ng : Real â†’ E'\nhf : MeasureTheory.IntegrableOn f (Set.Ioi 0) Î½\nhg : MeasureTheory.IntegrableOn g (Set.Ioi 0) Î¼\nL : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E' F)\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Ioi 0)) fun x => intervalIntegral (fun t => (L (f t)) (g (HSub.hSub x t))) 0 x Î½) ((L (MeasureTheory.integral (Î½.restrict (Set.Ioi 0)) fun x => f x)) (MeasureTheory.integral (Î¼.restrict (Set.Ioi 0)) fun x => g x))","decl":"/-- The integral over `Ioi 0` of a forward convolution of two functions is equal to the product\nof their integrals over this set. (Compare `integral_convolution` for the two-sided convolution.) -/\ntheorem integral_posConvolution [CompleteSpace E] [CompleteSpace E'] [CompleteSpace F]\n    {Î¼ Î½ : Measure â„}\n    [SFinite Î¼] [SFinite Î½] [IsAddRightInvariant Î¼] [NoAtoms Î½] {f : â„ â†’ E} {g : â„ â†’ E'}\n    (hf : IntegrableOn f (Ioi 0) Î½) (hg : IntegrableOn g (Ioi 0) Î¼) (L : E â†’L[â„] E' â†’L[â„] F) :\n    âˆ« x : â„ in Ioi 0, âˆ« t : â„ in (0)..x, L (f t) (g (x - t)) âˆ‚Î½ âˆ‚Î¼ =\n      L (âˆ« x : â„ in Ioi 0, f x âˆ‚Î½) (âˆ« x : â„ in Ioi 0, g x âˆ‚Î¼) := by\n  rw [â† integrable_indicator_iff measurableSet_Ioi] at hf hg\n  simp_rw [â† integral_indicator measurableSet_Ioi]\n  convert integral_convolution L hf hg using 4 with x\n  apply posConvolution_eq_convolution_indicator\n\n"}
