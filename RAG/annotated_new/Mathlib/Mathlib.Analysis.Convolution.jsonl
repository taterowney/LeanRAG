{"name":"MeasureTheory.convolution_integrand_bound_right_of_le_of_subset","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedAddCommGroup E'\ninst✝⁶ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜 E'\ninst✝² : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝¹ : AddGroup G\ninst✝ : TopologicalSpace G\nC : Real\nhC : ∀ (i : G), LE.le (Norm.norm (g i)) C\nx t : G\ns u : Set G\nhx : Membership.mem s x\nhu : HasSubset.Subset (HAdd.hAdd (Neg.neg (tsupport g)) s) u\n⊢ LE.le (Norm.norm ((L (f t)) (g (HSub.hSub x t)))) (u.indicator (fun t => HMul.hMul (HMul.hMul (Norm.norm L) (Norm.norm (f t))) C) t)","decl":"theorem convolution_integrand_bound_right_of_le_of_subset {C : ℝ} (hC : ∀ i, ‖g i‖ ≤ C) {x t : G}\n    {s u : Set G} (hx : x ∈ s) (hu : -tsupport g + s ⊆ u) :\n    ‖L (f t) (g (x - t))‖ ≤ u.indicator (fun t => ‖L‖ * ‖f t‖ * C) t := by\n  -- Porting note: had to add `f := _`\n  refine le_indicator (f := fun t ↦ ‖L (f t) (g (x - t))‖) (fun t _ => ?_) (fun t ht => ?_) t\n  · apply_rules [L.le_of_opNorm₂_le_of_le, le_rfl]\n  · have : x - t ∉ support g := by\n      refine mt (fun hxt => hu ?_) ht\n      refine ⟨_, Set.neg_mem_neg.mpr (subset_closure hxt), _, hx, ?_⟩\n      simp only [neg_sub, sub_add_cancel]\n    simp only [nmem_support.mp this, (L _).map_zero, norm_zero, le_rfl]\n\n"}
{"name":"HasCompactSupport.convolution_integrand_bound_right_of_subset","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedAddCommGroup E'\ninst✝⁶ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜 E'\ninst✝² : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝¹ : AddGroup G\ninst✝ : TopologicalSpace G\nhcg : HasCompactSupport g\nhg : Continuous g\nx t : G\ns u : Set G\nhx : Membership.mem s x\nhu : HasSubset.Subset (HAdd.hAdd (Neg.neg (tsupport g)) s) u\n⊢ LE.le (Norm.norm ((L (f t)) (g (HSub.hSub x t)))) (u.indicator (fun t => HMul.hMul (HMul.hMul (Norm.norm L) (Norm.norm (f t))) (iSup fun i => Norm.norm (g i))) t)","decl":"theorem _root_.HasCompactSupport.convolution_integrand_bound_right_of_subset\n    (hcg : HasCompactSupport g) (hg : Continuous g)\n    {x t : G} {s u : Set G} (hx : x ∈ s) (hu : -tsupport g + s ⊆ u) :\n    ‖L (f t) (g (x - t))‖ ≤ u.indicator (fun t => ‖L‖ * ‖f t‖ * ⨆ i, ‖g i‖) t := by\n  refine convolution_integrand_bound_right_of_le_of_subset _ (fun i => ?_) hx hu\n  exact le_ciSup (hg.norm.bddAbove_range_of_hasCompactSupport hcg.norm) _\n\n"}
{"name":"HasCompactSupport.convolution_integrand_bound_right","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedAddCommGroup E'\ninst✝⁶ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜 E'\ninst✝² : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝¹ : AddGroup G\ninst✝ : TopologicalSpace G\nhcg : HasCompactSupport g\nhg : Continuous g\nx t : G\ns : Set G\nhx : Membership.mem s x\n⊢ LE.le (Norm.norm ((L (f t)) (g (HSub.hSub x t)))) ((HAdd.hAdd (Neg.neg (tsupport g)) s).indicator (fun t => HMul.hMul (HMul.hMul (Norm.norm L) (Norm.norm (f t))) (iSup fun i => Norm.norm (g i))) t)","decl":"theorem _root_.HasCompactSupport.convolution_integrand_bound_right (hcg : HasCompactSupport g)\n    (hg : Continuous g) {x t : G} {s : Set G} (hx : x ∈ s) :\n    ‖L (f t) (g (x - t))‖ ≤ (-tsupport g + s).indicator (fun t => ‖L‖ * ‖f t‖ * ⨆ i, ‖g i‖) t :=\n  hcg.convolution_integrand_bound_right_of_subset L hg hx Subset.rfl\n\n"}
{"name":"Continuous.convolution_integrand_fst","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝² : AddGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : ContinuousSub G\nhg : Continuous g\nt : G\n⊢ Continuous fun x => (L (f t)) (g (HSub.hSub x t))","decl":"theorem _root_.Continuous.convolution_integrand_fst [ContinuousSub G] (hg : Continuous g) (t : G) :\n    Continuous fun x => L (f t) (g (x - t)) :=\n  L.continuous₂.comp₂ continuous_const <| hg.comp <| continuous_id.sub continuous_const\n\n"}
{"name":"HasCompactSupport.convolution_integrand_bound_left","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedAddCommGroup E'\ninst✝⁶ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜 E'\ninst✝² : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝¹ : AddGroup G\ninst✝ : TopologicalSpace G\nhcf : HasCompactSupport f\nhf : Continuous f\nx t : G\ns : Set G\nhx : Membership.mem s x\n⊢ LE.le (Norm.norm ((L (f (HSub.hSub x t))) (g t))) ((HAdd.hAdd (Neg.neg (tsupport f)) s).indicator (fun t => HMul.hMul (HMul.hMul (Norm.norm L) (iSup fun i => Norm.norm (f i))) (Norm.norm (g t))) t)","decl":"theorem _root_.HasCompactSupport.convolution_integrand_bound_left (hcf : HasCompactSupport f)\n    (hf : Continuous f) {x t : G} {s : Set G} (hx : x ∈ s) :\n    ‖L (f (x - t)) (g t)‖ ≤\n      (-tsupport f + s).indicator (fun t => (‖L‖ * ⨆ i, ‖f i‖) * ‖g t‖) t := by\n  convert hcf.convolution_integrand_bound_right L.flip hf hx using 1\n  simp_rw [L.opNorm_flip, mul_right_comm]\n\n"}
{"name":"MeasureTheory.ConvolutionExistsAt.integrable","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedAddCommGroup E'\ninst✝⁶ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜 E'\ninst✝² : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝¹ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝ : Sub G\nx : G\nh : MeasureTheory.ConvolutionExistsAt f g x L μ\n⊢ MeasureTheory.Integrable (fun t => (L (f t)) (g (HSub.hSub x t))) μ","decl":"variable {L} in\ntheorem ConvolutionExistsAt.integrable [Sub G] {x : G} (h : ConvolutionExistsAt f g x L μ) :\n    Integrable (fun t => L (f t) (g (x - t))) μ :=\n  h\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.convolution_integrand'","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedAddCommGroup E'\ninst✝⁹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedSpace 𝕜 E'\ninst✝⁵ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁴ : MeasurableSpace G\nμ ν : MeasureTheory.Measure G\ninst✝³ : AddGroup G\ninst✝² : MeasurableAdd₂ G\ninst✝¹ : MeasurableNeg G\ninst✝ : MeasureTheory.SFinite ν\nhf : MeasureTheory.AEStronglyMeasurable f ν\nhg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map (fun p => HSub.hSub p.1 p.2) (μ.prod ν))\n⊢ MeasureTheory.AEStronglyMeasurable (fun p => (L (f p.2)) (g (HSub.hSub p.1 p.2))) (μ.prod ν)","decl":"theorem AEStronglyMeasurable.convolution_integrand' [MeasurableAdd₂ G]\n    [MeasurableNeg G] [SFinite ν] (hf : AEStronglyMeasurable f ν)\n    (hg : AEStronglyMeasurable g <| map (fun p : G × G => p.1 - p.2) (μ.prod ν)) :\n    AEStronglyMeasurable (fun p : G × G => L (f p.2) (g (p.1 - p.2))) (μ.prod ν) :=\n  L.aestronglyMeasurable_comp₂ hf.snd <| hg.comp_measurable measurable_sub\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.convolution_integrand_snd'","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedAddCommGroup E'\ninst✝⁸ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜 E'\ninst✝⁴ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝³ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\ninst✝ : MeasurableNeg G\nhf : MeasureTheory.AEStronglyMeasurable f μ\nx : G\nhg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map (fun t => HSub.hSub x t) μ)\n⊢ MeasureTheory.AEStronglyMeasurable (fun t => (L (f t)) (g (HSub.hSub x t))) μ","decl":"theorem AEStronglyMeasurable.convolution_integrand_snd'\n    (hf : AEStronglyMeasurable f μ) {x : G}\n    (hg : AEStronglyMeasurable g <| map (fun t => x - t) μ) :\n    AEStronglyMeasurable (fun t => L (f t) (g (x - t))) μ :=\n  L.aestronglyMeasurable_comp₂ hf <| hg.comp_measurable <| measurable_id.const_sub x\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.convolution_integrand_swap_snd'","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedAddCommGroup E'\ninst✝⁸ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜 E'\ninst✝⁴ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝³ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\ninst✝ : MeasurableNeg G\nx : G\nhf : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map (fun t => HSub.hSub x t) μ)\nhg : MeasureTheory.AEStronglyMeasurable g μ\n⊢ MeasureTheory.AEStronglyMeasurable (fun t => (L (f (HSub.hSub x t))) (g t)) μ","decl":"theorem AEStronglyMeasurable.convolution_integrand_swap_snd' {x : G}\n    (hf : AEStronglyMeasurable f <| map (fun t => x - t) μ) (hg : AEStronglyMeasurable g μ) :\n    AEStronglyMeasurable (fun t => L (f (x - t)) (g t)) μ :=\n  L.aestronglyMeasurable_comp₂ (hf.comp_measurable <| measurable_id.const_sub x) hg\n\n"}
{"name":"BddAbove.convolutionExistsAt'","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedAddCommGroup E'\ninst✝⁸ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜 E'\ninst✝⁴ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝³ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\ninst✝ : MeasurableNeg G\nx₀ : G\ns : Set G\nhbg : BddAbove (Set.image (fun i => Norm.norm (g i)) (Set.preimage (fun t => HAdd.hAdd (Neg.neg t) x₀) s))\nhs : MeasurableSet s\nh2s : HasSubset.Subset (Function.support fun t => (L (f t)) (g (HSub.hSub x₀ t))) s\nhf : MeasureTheory.IntegrableOn f s μ\nhmg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map (fun t => HSub.hSub x₀ t) (μ.restrict s))\n⊢ MeasureTheory.ConvolutionExistsAt f g x₀ L μ","decl":"/-- A sufficient condition to prove that `f ⋆[L, μ] g` exists.\nWe assume that `f` is integrable on a set `s` and `g` is bounded and ae strongly measurable\non `x₀ - s` (note that both properties hold if `g` is continuous with compact support). -/\ntheorem _root_.BddAbove.convolutionExistsAt' {x₀ : G} {s : Set G}\n    (hbg : BddAbove ((fun i => ‖g i‖) '' ((fun t => -t + x₀) ⁻¹' s))) (hs : MeasurableSet s)\n    (h2s : (support fun t => L (f t) (g (x₀ - t))) ⊆ s) (hf : IntegrableOn f s μ)\n    (hmg : AEStronglyMeasurable g <| map (fun t => x₀ - t) (μ.restrict s)) :\n    ConvolutionExistsAt f g x₀ L μ := by\n  rw [ConvolutionExistsAt]\n  rw [← integrableOn_iff_integrable_of_support_subset h2s]\n  set s' := (fun t => -t + x₀) ⁻¹' s\n  have : ∀ᵐ t : G ∂μ.restrict s,\n      ‖L (f t) (g (x₀ - t))‖ ≤ s.indicator (fun t => ‖L‖ * ‖f t‖ * ⨆ i : s', ‖g i‖) t := by\n    filter_upwards\n    refine le_indicator (fun t ht => ?_) fun t ht => ?_\n    · apply_rules [L.le_of_opNorm₂_le_of_le, le_rfl]\n      refine (le_ciSup_set hbg <| mem_preimage.mpr ?_)\n      rwa [neg_sub, sub_add_cancel]\n    · have : t ∉ support fun t => L (f t) (g (x₀ - t)) := mt (fun h => h2s h) ht\n      rw [nmem_support.mp this, norm_zero]\n  refine Integrable.mono' ?_ ?_ this\n  · rw [integrable_indicator_iff hs]; exact ((hf.norm.const_mul _).mul_const _).integrableOn\n  · exact hf.aestronglyMeasurable.convolution_integrand_snd' L hmg\n\n"}
{"name":"MeasureTheory.ConvolutionExistsAt.ofNorm'","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedAddCommGroup E'\ninst✝⁸ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜 E'\ninst✝⁴ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝³ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝² : AddGroup G\ninst✝¹ : MeasurableAdd G\ninst✝ : MeasurableNeg G\nx₀ : G\nh : MeasureTheory.ConvolutionExistsAt (fun x => Norm.norm (f x)) (fun x => Norm.norm (g x)) x₀ (ContinuousLinearMap.mul Real Real) μ\nhmf : MeasureTheory.AEStronglyMeasurable f μ\nhmg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map (fun t => HSub.hSub x₀ t) μ)\n⊢ MeasureTheory.ConvolutionExistsAt f g x₀ L μ","decl":"/-- If `‖f‖ *[μ] ‖g‖` exists, then `f *[L, μ] g` exists. -/\ntheorem ConvolutionExistsAt.ofNorm' {x₀ : G}\n    (h : ConvolutionExistsAt (fun x => ‖f x‖) (fun x => ‖g x‖) x₀ (mul ℝ ℝ) μ)\n    (hmf : AEStronglyMeasurable f μ) (hmg : AEStronglyMeasurable g <| map (fun t => x₀ - t) μ) :\n    ConvolutionExistsAt f g x₀ L μ := by\n  refine (h.const_mul ‖L‖).mono'\n    (hmf.convolution_integrand_snd' L hmg) (Eventually.of_forall fun x => ?_)\n  rw [mul_apply', ← mul_assoc]\n  apply L.le_opNorm₂\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.convolution_integrand_snd","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹² : NormedAddCommGroup E\ninst✝¹¹ : NormedAddCommGroup E'\ninst✝¹⁰ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedSpace 𝕜 E'\ninst✝⁶ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁵ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\ninst✝² : MeasurableNeg G\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.IsAddRightInvariant\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhg : MeasureTheory.AEStronglyMeasurable g μ\nx : G\n⊢ MeasureTheory.AEStronglyMeasurable (fun t => (L (f t)) (g (HSub.hSub x t))) μ","decl":"theorem AEStronglyMeasurable.convolution_integrand_snd (hf : AEStronglyMeasurable f μ)\n    (hg : AEStronglyMeasurable g μ) (x : G) :\n    AEStronglyMeasurable (fun t => L (f t) (g (x - t))) μ :=\n  hf.convolution_integrand_snd' L <|\n    hg.mono_ac <| (quasiMeasurePreserving_sub_left_of_right_invariant μ x).absolutelyContinuous\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.convolution_integrand_swap_snd","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹² : NormedAddCommGroup E\ninst✝¹¹ : NormedAddCommGroup E'\ninst✝¹⁰ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedSpace 𝕜 E'\ninst✝⁶ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁵ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\ninst✝² : MeasurableNeg G\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.IsAddRightInvariant\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhg : MeasureTheory.AEStronglyMeasurable g μ\nx : G\n⊢ MeasureTheory.AEStronglyMeasurable (fun t => (L (f (HSub.hSub x t))) (g t)) μ","decl":"theorem AEStronglyMeasurable.convolution_integrand_swap_snd\n    (hf : AEStronglyMeasurable f μ) (hg : AEStronglyMeasurable g μ) (x : G) :\n    AEStronglyMeasurable (fun t => L (f (x - t)) (g t)) μ :=\n  (hf.mono_ac\n        (quasiMeasurePreserving_sub_left_of_right_invariant μ\n            x).absolutelyContinuous).convolution_integrand_swap_snd'\n    L hg\n\n"}
{"name":"MeasureTheory.ConvolutionExistsAt.ofNorm","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹² : NormedAddCommGroup E\ninst✝¹¹ : NormedAddCommGroup E'\ninst✝¹⁰ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedSpace 𝕜 E'\ninst✝⁶ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁵ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\ninst✝² : MeasurableNeg G\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.IsAddRightInvariant\nx₀ : G\nh : MeasureTheory.ConvolutionExistsAt (fun x => Norm.norm (f x)) (fun x => Norm.norm (g x)) x₀ (ContinuousLinearMap.mul Real Real) μ\nhmf : MeasureTheory.AEStronglyMeasurable f μ\nhmg : MeasureTheory.AEStronglyMeasurable g μ\n⊢ MeasureTheory.ConvolutionExistsAt f g x₀ L μ","decl":"/-- If `‖f‖ *[μ] ‖g‖` exists, then `f *[L, μ] g` exists. -/\ntheorem ConvolutionExistsAt.ofNorm {x₀ : G}\n    (h : ConvolutionExistsAt (fun x => ‖f x‖) (fun x => ‖g x‖) x₀ (mul ℝ ℝ) μ)\n    (hmf : AEStronglyMeasurable f μ) (hmg : AEStronglyMeasurable g μ) :\n    ConvolutionExistsAt f g x₀ L μ :=\n  h.ofNorm' L hmf <|\n    hmg.mono_ac (quasiMeasurePreserving_sub_left_of_right_invariant μ x₀).absolutelyContinuous\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.convolution_integrand","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁶ : MeasurableSpace G\nμ ν : MeasureTheory.Measure G\ninst✝⁵ : AddGroup G\ninst✝⁴ : MeasurableAdd₂ G\ninst✝³ : MeasurableNeg G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : μ.IsAddRightInvariant\ninst✝ : MeasureTheory.SFinite ν\nhf : MeasureTheory.AEStronglyMeasurable f ν\nhg : MeasureTheory.AEStronglyMeasurable g μ\n⊢ MeasureTheory.AEStronglyMeasurable (fun p => (L (f p.2)) (g (HSub.hSub p.1 p.2))) (μ.prod ν)","decl":"theorem AEStronglyMeasurable.convolution_integrand (hf : AEStronglyMeasurable f ν)\n    (hg : AEStronglyMeasurable g μ) :\n    AEStronglyMeasurable (fun p : G × G => L (f p.2) (g (p.1 - p.2))) (μ.prod ν) :=\n  hf.convolution_integrand' L <|\n    hg.mono_ac (quasiMeasurePreserving_sub_of_right_invariant μ ν).absolutelyContinuous\n\n"}
{"name":"MeasureTheory.Integrable.convolution_integrand","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁶ : MeasurableSpace G\nμ ν : MeasureTheory.Measure G\ninst✝⁵ : AddGroup G\ninst✝⁴ : MeasurableAdd₂ G\ninst✝³ : MeasurableNeg G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : μ.IsAddRightInvariant\ninst✝ : MeasureTheory.SFinite ν\nhf : MeasureTheory.Integrable f ν\nhg : MeasureTheory.Integrable g μ\n⊢ MeasureTheory.Integrable (fun p => (L (f p.2)) (g (HSub.hSub p.1 p.2))) (μ.prod ν)","decl":"theorem Integrable.convolution_integrand (hf : Integrable f ν) (hg : Integrable g μ) :\n    Integrable (fun p : G × G => L (f p.2) (g (p.1 - p.2))) (μ.prod ν) := by\n  have h_meas : AEStronglyMeasurable (fun p : G × G => L (f p.2) (g (p.1 - p.2))) (μ.prod ν) :=\n    hf.aestronglyMeasurable.convolution_integrand L hg.aestronglyMeasurable\n  have h2_meas : AEStronglyMeasurable (fun y : G => ∫ x : G, ‖L (f y) (g (x - y))‖ ∂μ) ν :=\n    h_meas.prod_swap.norm.integral_prod_right'\n  simp_rw [integrable_prod_iff' h_meas]\n  refine ⟨Eventually.of_forall fun t => (L (f t)).integrable_comp (hg.comp_sub_right t), ?_⟩\n  refine Integrable.mono' ?_ h2_meas\n      (Eventually.of_forall fun t => (?_ : _ ≤ ‖L‖ * ‖f t‖ * ∫ x, ‖g (x - t)‖ ∂μ))\n  · simp only [integral_sub_right_eq_self (‖g ·‖)]\n    exact (hf.norm.const_mul _).mul_const _\n  · simp_rw [← integral_mul_left]\n    rw [Real.norm_of_nonneg (by positivity)]\n    exact integral_mono_of_nonneg (Eventually.of_forall fun t => norm_nonneg _)\n      ((hg.comp_sub_right t).norm.const_mul _) (Eventually.of_forall fun t => L.le_opNorm₂ _ _)\n\n"}
{"name":"MeasureTheory.Integrable.ae_convolution_exists","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁶ : MeasurableSpace G\nμ ν : MeasureTheory.Measure G\ninst✝⁵ : AddGroup G\ninst✝⁴ : MeasurableAdd₂ G\ninst✝³ : MeasurableNeg G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : μ.IsAddRightInvariant\ninst✝ : MeasureTheory.SFinite ν\nhf : MeasureTheory.Integrable f ν\nhg : MeasureTheory.Integrable g μ\n⊢ Filter.Eventually (fun x => MeasureTheory.ConvolutionExistsAt f g x L ν) (MeasureTheory.ae μ)","decl":"theorem Integrable.ae_convolution_exists (hf : Integrable f ν) (hg : Integrable g μ) :\n    ∀ᵐ x ∂μ, ConvolutionExistsAt f g x L ν :=\n  ((integrable_prod_iff <|\n          hf.aestronglyMeasurable.convolution_integrand L hg.aestronglyMeasurable).mp <|\n      hf.convolution_integrand L hg).1\n\n"}
{"name":"HasCompactSupport.convolutionExistsAt","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedAddCommGroup E'\ninst✝⁹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedSpace 𝕜 E'\ninst✝⁵ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁴ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : BorelSpace G\nx₀ : G\nh : HasCompactSupport fun t => (L (f t)) (g (HSub.hSub x₀ t))\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : Continuous g\n⊢ MeasureTheory.ConvolutionExistsAt f g x₀ L μ","decl":"theorem _root_.HasCompactSupport.convolutionExistsAt {x₀ : G}\n    (h : HasCompactSupport fun t => L (f t) (g (x₀ - t))) (hf : LocallyIntegrable f μ)\n    (hg : Continuous g) : ConvolutionExistsAt f g x₀ L μ := by\n  let u := (Homeomorph.neg G).trans (Homeomorph.addRight x₀)\n  let v := (Homeomorph.neg G).trans (Homeomorph.addLeft x₀)\n  apply ((u.isCompact_preimage.mpr h).bddAbove_image hg.norm.continuousOn).convolutionExistsAt' L\n    isClosed_closure.measurableSet subset_closure (hf.integrableOn_isCompact h)\n  have A : AEStronglyMeasurable (g ∘ v)\n      (μ.restrict (tsupport fun t : G => L (f t) (g (x₀ - t)))) := by\n    apply (hg.comp v.continuous).continuousOn.aestronglyMeasurable_of_isCompact h\n    exact (isClosed_tsupport _).measurableSet\n  convert ((v.continuous.measurable.measurePreserving\n      (μ.restrict (tsupport fun t => L (f t) (g (x₀ - t))))).aestronglyMeasurable_comp_iff\n    v.measurableEmbedding).1 A\n  ext x\n  simp only [v, Homeomorph.neg, sub_eq_add_neg, val_toAddUnits_apply, Homeomorph.trans_apply,\n    Equiv.neg_apply, Equiv.toFun_as_coe, Homeomorph.homeomorph_mk_coe, Equiv.coe_fn_mk,\n    Homeomorph.coe_addLeft]\n\n"}
{"name":"HasCompactSupport.convolutionExists_right","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedAddCommGroup E'\ninst✝⁹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedSpace 𝕜 E'\ninst✝⁵ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁴ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : BorelSpace G\nhcg : HasCompactSupport g\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : Continuous g\n⊢ MeasureTheory.ConvolutionExists f g L μ","decl":"theorem _root_.HasCompactSupport.convolutionExists_right (hcg : HasCompactSupport g)\n    (hf : LocallyIntegrable f μ) (hg : Continuous g) : ConvolutionExists f g L μ := by\n  intro x₀\n  refine HasCompactSupport.convolutionExistsAt L ?_ hf hg\n  refine (hcg.comp_homeomorph (Homeomorph.subLeft x₀)).mono ?_\n  refine fun t => mt fun ht : g (x₀ - t) = 0 => ?_\n  simp_rw [ht, (L _).map_zero]\n\n"}
{"name":"HasCompactSupport.convolutionExists_left_of_continuous_right","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedAddCommGroup E'\ninst✝⁹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedSpace 𝕜 E'\ninst✝⁵ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁴ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : BorelSpace G\nhcf : HasCompactSupport f\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : Continuous g\n⊢ MeasureTheory.ConvolutionExists f g L μ","decl":"theorem _root_.HasCompactSupport.convolutionExists_left_of_continuous_right\n    (hcf : HasCompactSupport f) (hf : LocallyIntegrable f μ) (hg : Continuous g) :\n    ConvolutionExists f g L μ := by\n  intro x₀\n  refine HasCompactSupport.convolutionExistsAt L ?_ hf hg\n  refine hcf.mono ?_\n  refine fun t => mt fun ht : f t = 0 => ?_\n  simp_rw [ht, L.map_zero₂]\n\n"}
{"name":"BddAbove.convolutionExistsAt","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹² : NormedAddCommGroup E\ninst✝¹¹ : NormedAddCommGroup E'\ninst✝¹⁰ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedSpace 𝕜 E'\ninst✝⁶ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁵ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : AddCommGroup G\ninst✝³ : MeasurableNeg G\ninst✝² : μ.IsAddLeftInvariant\ninst✝¹ : MeasurableAdd₂ G\ninst✝ : MeasureTheory.SFinite μ\nx₀ : G\ns : Set G\nhbg : BddAbove (Set.image (fun i => Norm.norm (g i)) (Set.preimage (fun t => HSub.hSub x₀ t) s))\nhs : MeasurableSet s\nh2s : HasSubset.Subset (Function.support fun t => (L (f t)) (g (HSub.hSub x₀ t))) s\nhf : MeasureTheory.IntegrableOn f s μ\nhmg : MeasureTheory.AEStronglyMeasurable g μ\n⊢ MeasureTheory.ConvolutionExistsAt f g x₀ L μ","decl":"/-- A sufficient condition to prove that `f ⋆[L, μ] g` exists.\nWe assume that the integrand has compact support and `g` is bounded on this support (note that\nboth properties hold if `g` is continuous with compact support). We also require that `f` is\nintegrable on the support of the integrand, and that both functions are strongly measurable.\n\nThis is a variant of `BddAbove.convolutionExistsAt'` in an abelian group with a left-invariant\nmeasure. This allows us to state the boundedness and measurability of `g` in a more natural way. -/\ntheorem _root_.BddAbove.convolutionExistsAt [MeasurableAdd₂ G] [SFinite μ] {x₀ : G} {s : Set G}\n    (hbg : BddAbove ((fun i => ‖g i‖) '' ((fun t => x₀ - t) ⁻¹' s))) (hs : MeasurableSet s)\n    (h2s : (support fun t => L (f t) (g (x₀ - t))) ⊆ s) (hf : IntegrableOn f s μ)\n    (hmg : AEStronglyMeasurable g μ) : ConvolutionExistsAt f g x₀ L μ := by\n  refine BddAbove.convolutionExistsAt' L ?_ hs h2s hf ?_\n  · simp_rw [← sub_eq_neg_add, hbg]\n  · have : AEStronglyMeasurable g (map (fun t : G => x₀ - t) μ) :=\n      hmg.mono_ac (quasiMeasurePreserving_sub_left_of_right_invariant μ x₀).absolutelyContinuous\n    apply this.mono_measure\n    exact map_mono restrict_le_self (measurable_const.sub measurable_id')\n\n"}
{"name":"MeasureTheory.convolutionExistsAt_flip","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹² : NormedAddCommGroup E\ninst✝¹¹ : NormedAddCommGroup E'\ninst✝¹⁰ : NormedAddCommGroup F\nf : G → E\ng : G → E'\nx : G\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedSpace 𝕜 E'\ninst✝⁶ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁵ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : AddCommGroup G\ninst✝³ : MeasurableNeg G\ninst✝² : μ.IsAddLeftInvariant\ninst✝¹ : MeasurableAdd G\ninst✝ : μ.IsNegInvariant\n⊢ Iff (MeasureTheory.ConvolutionExistsAt g f x L.flip μ) (MeasureTheory.ConvolutionExistsAt f g x L μ)","decl":"theorem convolutionExistsAt_flip :\n    ConvolutionExistsAt g f x L.flip μ ↔ ConvolutionExistsAt f g x L μ := by\n  simp_rw [ConvolutionExistsAt, ← integrable_comp_sub_left (fun t => L (f t) (g (x - t))) x,\n    sub_sub_cancel, flip_apply]\n\n"}
{"name":"MeasureTheory.ConvolutionExistsAt.integrable_swap","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹² : NormedAddCommGroup E\ninst✝¹¹ : NormedAddCommGroup E'\ninst✝¹⁰ : NormedAddCommGroup F\nf : G → E\ng : G → E'\nx : G\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedSpace 𝕜 E'\ninst✝⁶ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁵ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : AddCommGroup G\ninst✝³ : MeasurableNeg G\ninst✝² : μ.IsAddLeftInvariant\ninst✝¹ : MeasurableAdd G\ninst✝ : μ.IsNegInvariant\nh : MeasureTheory.ConvolutionExistsAt f g x L μ\n⊢ MeasureTheory.Integrable (fun t => (L (f (HSub.hSub x t))) (g t)) μ","decl":"theorem ConvolutionExistsAt.integrable_swap (h : ConvolutionExistsAt f g x L μ) :\n    Integrable (fun t => L (f (x - t)) (g t)) μ := by\n  convert h.comp_sub_left x\n  simp_rw [sub_sub_self]\n\n"}
{"name":"MeasureTheory.convolutionExistsAt_iff_integrable_swap","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹² : NormedAddCommGroup E\ninst✝¹¹ : NormedAddCommGroup E'\ninst✝¹⁰ : NormedAddCommGroup F\nf : G → E\ng : G → E'\nx : G\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedSpace 𝕜 E'\ninst✝⁶ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁵ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : AddCommGroup G\ninst✝³ : MeasurableNeg G\ninst✝² : μ.IsAddLeftInvariant\ninst✝¹ : MeasurableAdd G\ninst✝ : μ.IsNegInvariant\n⊢ Iff (MeasureTheory.ConvolutionExistsAt f g x L μ) (MeasureTheory.Integrable (fun t => (L (f (HSub.hSub x t))) (g t)) μ)","decl":"theorem convolutionExistsAt_iff_integrable_swap :\n    ConvolutionExistsAt f g x L μ ↔ Integrable (fun t => L (f (x - t)) (g t)) μ :=\n  convolutionExistsAt_flip.symm\n\n"}
{"name":"HasCompactSupport.convolutionExistsLeft","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁶ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁵ : AddCommGroup G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : TopologicalAddGroup G\ninst✝² : BorelSpace G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : μ.IsNegInvariant\nhcf : HasCompactSupport f\nhf : Continuous f\nhg : MeasureTheory.LocallyIntegrable g μ\n⊢ MeasureTheory.ConvolutionExists f g L μ","decl":"theorem _root_.HasCompactSupport.convolutionExistsLeft\n    (hcf : HasCompactSupport f) (hf : Continuous f)\n    (hg : LocallyIntegrable g μ) : ConvolutionExists f g L μ := fun x₀ =>\n  convolutionExistsAt_flip.mp <| hcf.convolutionExists_right L.flip hg hf x₀\n\n"}
{"name":"HasCompactSupport.convolutionExistsRightOfContinuousLeft","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁶ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁵ : AddCommGroup G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : TopologicalAddGroup G\ninst✝² : BorelSpace G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : μ.IsNegInvariant\nhcg : HasCompactSupport g\nhf : Continuous f\nhg : MeasureTheory.LocallyIntegrable g μ\n⊢ MeasureTheory.ConvolutionExists f g L μ","decl":"theorem _root_.HasCompactSupport.convolutionExistsRightOfContinuousLeft (hcg : HasCompactSupport g)\n    (hf : Continuous f) (hg : LocallyIntegrable g μ) : ConvolutionExists f g L μ := fun x₀ =>\n  convolutionExistsAt_flip.mp <| hcg.convolutionExists_left_of_continuous_right L.flip hg hf x₀\n\n"}
{"name":"MeasureTheory.convolution_def","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : NormedAddCommGroup F\nf : G → E\ng : G → E'\nx : G\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : NormedSpace Real F\ninst✝ : Sub G\n⊢ Eq (MeasureTheory.convolution f g L μ x) (MeasureTheory.integral μ fun t => (L (f t)) (g (HSub.hSub x t)))","decl":"theorem convolution_def [Sub G] : (f ⋆[L, μ] g) x = ∫ t, L (f t) (g (x - t)) ∂μ :=\n  rfl\n\n"}
{"name":"MeasureTheory.convolution_lsmul","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\nx : G\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedSpace 𝕜 F\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : NormedSpace Real F\ninst✝ : Sub G\nf : G → 𝕜\ng : G → F\n⊢ Eq (MeasureTheory.convolution f g (ContinuousLinearMap.lsmul 𝕜 𝕜) μ x) (MeasureTheory.integral μ fun t => HSMul.hSMul (f t) (g (HSub.hSub x t)))","decl":"/-- The definition of convolution where the bilinear operator is scalar multiplication.\nNote: it often helps the elaborator to give the type of the convolution explicitly. -/\ntheorem convolution_lsmul [Sub G] {f : G → 𝕜} {g : G → F} :\n    (f ⋆[lsmul 𝕜 𝕜, μ] g : G → F) x = ∫ t, f t • g (x - t) ∂μ :=\n  rfl\n\n"}
{"name":"MeasureTheory.convolution_mul","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nx : G\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : Sub G\ninst✝ : NormedSpace Real 𝕜\nf g : G → 𝕜\n⊢ Eq (MeasureTheory.convolution f g (ContinuousLinearMap.mul 𝕜 𝕜) μ x) (MeasureTheory.integral μ fun t => HMul.hMul (f t) (g (HSub.hSub x t)))","decl":"/-- The definition of convolution where the bilinear operator is multiplication. -/\ntheorem convolution_mul [Sub G] [NormedSpace ℝ 𝕜] {f : G → 𝕜} {g : G → 𝕜} :\n    (f ⋆[mul 𝕜 𝕜, μ] g) x = ∫ t, f t * g (x - t) ∂μ :=\n  rfl\n\n"}
{"name":"MeasureTheory.smul_convolution","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedAddCommGroup E'\ninst✝⁸ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜 E'\ninst✝⁴ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝³ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝² : NormedSpace Real F\ninst✝¹ : AddGroup G\ninst✝ : SMulCommClass Real 𝕜 F\ny : 𝕜\n⊢ Eq (MeasureTheory.convolution (HSMul.hSMul y f) g L μ) (HSMul.hSMul y (MeasureTheory.convolution f g L μ))","decl":"theorem smul_convolution [SMulCommClass ℝ 𝕜 F] {y : 𝕜} : y • f ⋆[L, μ] g = y • (f ⋆[L, μ] g) := by\n  ext; simp only [Pi.smul_apply, convolution_def, ← integral_smul, L.map_smul₂]\n\n"}
{"name":"MeasureTheory.convolution_smul","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedAddCommGroup E'\ninst✝⁸ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜 E'\ninst✝⁴ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝³ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝² : NormedSpace Real F\ninst✝¹ : AddGroup G\ninst✝ : SMulCommClass Real 𝕜 F\ny : 𝕜\n⊢ Eq (MeasureTheory.convolution f (HSMul.hSMul y g) L μ) (HSMul.hSMul y (MeasureTheory.convolution f g L μ))","decl":"theorem convolution_smul [SMulCommClass ℝ 𝕜 F] {y : 𝕜} : f ⋆[L, μ] y • g = y • (f ⋆[L, μ] g) := by\n  ext; simp only [Pi.smul_apply, convolution_def, ← integral_smul, (L _).map_smul]\n\n"}
{"name":"MeasureTheory.zero_convolution","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : NormedAddCommGroup F\ng : G → E'\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : NormedSpace Real F\ninst✝ : AddGroup G\n⊢ Eq (MeasureTheory.convolution 0 g L μ) 0","decl":"@[simp]\ntheorem zero_convolution : 0 ⋆[L, μ] g = 0 := by\n  ext\n  simp_rw [convolution_def, Pi.zero_apply, L.map_zero₂, integral_zero]\n\n"}
{"name":"MeasureTheory.convolution_zero","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : NormedAddCommGroup F\nf : G → E\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : NormedSpace Real F\ninst✝ : AddGroup G\n⊢ Eq (MeasureTheory.convolution f 0 L μ) 0","decl":"@[simp]\ntheorem convolution_zero : f ⋆[L, μ] 0 = 0 := by\n  ext\n  simp_rw [convolution_def, Pi.zero_apply, (L _).map_zero, integral_zero]\n\n"}
{"name":"MeasureTheory.ConvolutionExistsAt.distrib_add","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : NormedAddCommGroup F\nf : G → E\ng g' : G → E'\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : NormedSpace Real F\ninst✝ : AddGroup G\nx : G\nhfg : MeasureTheory.ConvolutionExistsAt f g x L μ\nhfg' : MeasureTheory.ConvolutionExistsAt f g' x L μ\n⊢ Eq (MeasureTheory.convolution f (HAdd.hAdd g g') L μ x) (HAdd.hAdd (MeasureTheory.convolution f g L μ x) (MeasureTheory.convolution f g' L μ x))","decl":"theorem ConvolutionExistsAt.distrib_add {x : G} (hfg : ConvolutionExistsAt f g x L μ)\n    (hfg' : ConvolutionExistsAt f g' x L μ) :\n    (f ⋆[L, μ] (g + g')) x = (f ⋆[L, μ] g) x + (f ⋆[L, μ] g') x := by\n  simp only [convolution_def, (L _).map_add, Pi.add_apply, integral_add hfg hfg']\n\n"}
{"name":"MeasureTheory.ConvolutionExists.distrib_add","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : NormedAddCommGroup F\nf : G → E\ng g' : G → E'\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : NormedSpace Real F\ninst✝ : AddGroup G\nhfg : MeasureTheory.ConvolutionExists f g L μ\nhfg' : MeasureTheory.ConvolutionExists f g' L μ\n⊢ Eq (MeasureTheory.convolution f (HAdd.hAdd g g') L μ) (HAdd.hAdd (MeasureTheory.convolution f g L μ) (MeasureTheory.convolution f g' L μ))","decl":"theorem ConvolutionExists.distrib_add (hfg : ConvolutionExists f g L μ)\n    (hfg' : ConvolutionExists f g' L μ) : f ⋆[L, μ] (g + g') = f ⋆[L, μ] g + f ⋆[L, μ] g' := by\n  ext x\n  exact (hfg x).distrib_add (hfg' x)\n\n"}
{"name":"MeasureTheory.ConvolutionExistsAt.add_distrib","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : NormedAddCommGroup F\nf f' : G → E\ng : G → E'\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : NormedSpace Real F\ninst✝ : AddGroup G\nx : G\nhfg : MeasureTheory.ConvolutionExistsAt f g x L μ\nhfg' : MeasureTheory.ConvolutionExistsAt f' g x L μ\n⊢ Eq (MeasureTheory.convolution (HAdd.hAdd f f') g L μ x) (HAdd.hAdd (MeasureTheory.convolution f g L μ x) (MeasureTheory.convolution f' g L μ x))","decl":"theorem ConvolutionExistsAt.add_distrib {x : G} (hfg : ConvolutionExistsAt f g x L μ)\n    (hfg' : ConvolutionExistsAt f' g x L μ) :\n    ((f + f') ⋆[L, μ] g) x = (f ⋆[L, μ] g) x + (f' ⋆[L, μ] g) x := by\n  simp only [convolution_def, L.map_add₂, Pi.add_apply, integral_add hfg hfg']\n\n"}
{"name":"MeasureTheory.ConvolutionExists.add_distrib","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : NormedAddCommGroup F\nf f' : G → E\ng : G → E'\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : NormedSpace Real F\ninst✝ : AddGroup G\nhfg : MeasureTheory.ConvolutionExists f g L μ\nhfg' : MeasureTheory.ConvolutionExists f' g L μ\n⊢ Eq (MeasureTheory.convolution (HAdd.hAdd f f') g L μ) (HAdd.hAdd (MeasureTheory.convolution f g L μ) (MeasureTheory.convolution f' g L μ))","decl":"theorem ConvolutionExists.add_distrib (hfg : ConvolutionExists f g L μ)\n    (hfg' : ConvolutionExists f' g L μ) : (f + f') ⋆[L, μ] g = f ⋆[L, μ] g + f' ⋆[L, μ] g := by\n  ext x\n  exact (hfg x).add_distrib (hfg' x)\n\n"}
{"name":"MeasureTheory.convolution_mono_right","module":"Mathlib.Analysis.Convolution","initialProofState":"G : Type uG\nx : G\ninst✝¹ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝ : AddGroup G\nf g g' : G → Real\nhfg : MeasureTheory.ConvolutionExistsAt f g x (ContinuousLinearMap.lsmul Real Real) μ\nhfg' : MeasureTheory.ConvolutionExistsAt f g' x (ContinuousLinearMap.lsmul Real Real) μ\nhf : ∀ (x : G), LE.le 0 (f x)\nhg : ∀ (x : G), LE.le (g x) (g' x)\n⊢ LE.le (MeasureTheory.convolution f g (ContinuousLinearMap.lsmul Real Real) μ x) (MeasureTheory.convolution f g' (ContinuousLinearMap.lsmul Real Real) μ x)","decl":"theorem convolution_mono_right {f g g' : G → ℝ} (hfg : ConvolutionExistsAt f g x (lsmul ℝ ℝ) μ)\n    (hfg' : ConvolutionExistsAt f g' x (lsmul ℝ ℝ) μ) (hf : ∀ x, 0 ≤ f x) (hg : ∀ x, g x ≤ g' x) :\n    (f ⋆[lsmul ℝ ℝ, μ] g) x ≤ (f ⋆[lsmul ℝ ℝ, μ] g') x := by\n  apply integral_mono hfg hfg'\n  simp only [lsmul_apply, Algebra.id.smul_eq_mul]\n  intro t\n  apply mul_le_mul_of_nonneg_left (hg _) (hf _)\n\n"}
{"name":"MeasureTheory.convolution_mono_right_of_nonneg","module":"Mathlib.Analysis.Convolution","initialProofState":"G : Type uG\nx : G\ninst✝¹ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝ : AddGroup G\nf g g' : G → Real\nhfg' : MeasureTheory.ConvolutionExistsAt f g' x (ContinuousLinearMap.lsmul Real Real) μ\nhf : ∀ (x : G), LE.le 0 (f x)\nhg : ∀ (x : G), LE.le (g x) (g' x)\nhg' : ∀ (x : G), LE.le 0 (g' x)\n⊢ LE.le (MeasureTheory.convolution f g (ContinuousLinearMap.lsmul Real Real) μ x) (MeasureTheory.convolution f g' (ContinuousLinearMap.lsmul Real Real) μ x)","decl":"theorem convolution_mono_right_of_nonneg {f g g' : G → ℝ}\n    (hfg' : ConvolutionExistsAt f g' x (lsmul ℝ ℝ) μ) (hf : ∀ x, 0 ≤ f x) (hg : ∀ x, g x ≤ g' x)\n    (hg' : ∀ x, 0 ≤ g' x) : (f ⋆[lsmul ℝ ℝ, μ] g) x ≤ (f ⋆[lsmul ℝ ℝ, μ] g') x := by\n  by_cases H : ConvolutionExistsAt f g x (lsmul ℝ ℝ) μ\n  · exact convolution_mono_right H hfg' hf hg\n  have : (f ⋆[lsmul ℝ ℝ, μ] g) x = 0 := integral_undef H\n  rw [this]\n  exact integral_nonneg fun y => mul_nonneg (hf y) (hg' (x - y))\n\n"}
{"name":"MeasureTheory.convolution_congr","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf f' : G → E\ng g' : G → E'\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁶ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁵ : NormedSpace Real F\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\ninst✝² : MeasurableNeg G\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.IsAddRightInvariant\nh1 : (MeasureTheory.ae μ).EventuallyEq f f'\nh2 : (MeasureTheory.ae μ).EventuallyEq g g'\n⊢ Eq (MeasureTheory.convolution f g L μ) (MeasureTheory.convolution f' g' L μ)","decl":"theorem convolution_congr [MeasurableAdd₂ G] [MeasurableNeg G] [SFinite μ]\n    [IsAddRightInvariant μ] (h1 : f =ᵐ[μ] f') (h2 : g =ᵐ[μ] g') : f ⋆[L, μ] g = f' ⋆[L, μ] g' := by\n  ext x\n  apply integral_congr_ae\n  exact (h1.prod_mk <| h2.comp_tendsto\n    (quasiMeasurePreserving_sub_left_of_right_invariant μ x).tendsto_ae).fun_comp ↿fun x y ↦ L x y\n\n"}
{"name":"MeasureTheory.support_convolution_subset_swap","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : NormedSpace Real F\ninst✝ : AddGroup G\n⊢ HasSubset.Subset (Function.support (MeasureTheory.convolution f g L μ)) (HAdd.hAdd (Function.support g) (Function.support f))","decl":"theorem support_convolution_subset_swap : support (f ⋆[L, μ] g) ⊆ support g + support f := by\n  intro x h2x\n  by_contra hx\n  apply h2x\n  simp_rw [Set.mem_add, ← exists_and_left, not_exists, not_and_or, nmem_support] at hx\n  rw [convolution_def]\n  convert integral_zero G F using 2\n  ext t\n  rcases hx (x - t) t with (h | h | h)\n  · rw [h, (L _).map_zero]\n  · rw [h, L.map_zero₂]\n  · exact (h <| sub_add_cancel x t).elim\n\n"}
{"name":"MeasureTheory.Integrable.integrable_convolution","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁶ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁵ : NormedSpace Real F\ninst✝⁴ : AddGroup G\ninst✝³ : MeasurableAdd₂ G\ninst✝² : MeasurableNeg G\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.IsAddRightInvariant\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g μ\n⊢ MeasureTheory.Integrable (MeasureTheory.convolution f g L μ) μ","decl":"theorem Integrable.integrable_convolution (hf : Integrable f μ)\n    (hg : Integrable g μ) : Integrable (f ⋆[L, μ] g) μ :=\n  (hf.convolution_integrand L hg).integral_prod_left\n\n"}
{"name":"HasCompactSupport.convolution","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹² : NormedAddCommGroup E\ninst✝¹¹ : NormedAddCommGroup E'\ninst✝¹⁰ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedSpace 𝕜 E'\ninst✝⁶ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁵ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : NormedSpace Real F\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : T2Space G\nhcf : HasCompactSupport f\nhcg : HasCompactSupport g\n⊢ HasCompactSupport (MeasureTheory.convolution f g L μ)","decl":"protected theorem _root_.HasCompactSupport.convolution [T2Space G] (hcf : HasCompactSupport f)\n    (hcg : HasCompactSupport g) : HasCompactSupport (f ⋆[L, μ] g) :=\n  (hcg.isCompact.add hcf).of_isClosed_subset isClosed_closure <|\n    closure_minimal\n      ((support_convolution_subset_swap L).trans <| add_subset_add subset_closure subset_closure)\n      (hcg.isCompact.add hcf).isClosed\n\n"}
{"name":"MeasureTheory.continuousOn_convolution_right_with_param","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁶ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁵ : NormedSpace Real F\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : BorelSpace G\ninst✝ : TopologicalSpace P\ng : P → G → E'\ns : Set P\nk : Set G\nhk : IsCompact k\nhgs : ∀ (p : P) (x : G), Membership.mem s p → Not (Membership.mem k x) → Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : ContinuousOn (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\n⊢ ContinuousOn (fun q => MeasureTheory.convolution f (g q.1) L μ q.2) (SProd.sprod s Set.univ)","decl":"/-- The convolution `f * g` is continuous if `f` is locally integrable and `g` is continuous and\ncompactly supported. Version where `g` depends on an additional parameter in a subset `s` of\na parameter space `P` (and the compact support `k` is independent of the parameter in `s`). -/\ntheorem continuousOn_convolution_right_with_param {g : P → G → E'} {s : Set P} {k : Set G}\n    (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)\n    (hf : LocallyIntegrable f μ) (hg : ContinuousOn (↿g) (s ×ˢ univ)) :\n    ContinuousOn (fun q : P × G => (f ⋆[L, μ] g q.1) q.2) (s ×ˢ univ) := by\n  /- First get rid of the case where the space is not locally compact. Then `g` vanishes everywhere\n  and the conclusion is trivial. -/\n  by_cases H : ∀ p ∈ s, ∀ x, g p x = 0\n  · apply (continuousOn_const (c := 0)).congr\n    rintro ⟨p, x⟩ ⟨hp, -⟩\n    apply integral_eq_zero_of_ae (Eventually.of_forall (fun y ↦ ?_))\n    simp [H p hp _]\n  have : LocallyCompactSpace G := by\n    push_neg at H\n    rcases H with ⟨p, hp, x, hx⟩\n    have A : support (g p) ⊆ k := support_subset_iff'.2 (fun y hy ↦ hgs p y hp hy)\n    have B : Continuous (g p) := by\n      refine hg.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_\n      simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hp\n    rcases eq_zero_or_locallyCompactSpace_of_support_subset_isCompact_of_addGroup hk A B with H|H\n    · simp [H] at hx\n    · exact H\n  /- Since `G` is locally compact, one may thicken `k` a little bit into a larger compact set\n  `(-k) + t`, outside of which all functions that appear in the convolution vanish. Then we can\n  apply a continuity statement for integrals depending on a parameter, with respect to\n  locally integrable functions and compactly supported continuous functions. -/\n  rintro ⟨q₀, x₀⟩ ⟨hq₀, -⟩\n  obtain ⟨t, t_comp, ht⟩ : ∃ t, IsCompact t ∧ t ∈ 𝓝 x₀ := exists_compact_mem_nhds x₀\n  let k' : Set G := (-k) +ᵥ t\n  have k'_comp : IsCompact k' := IsCompact.vadd_set hk.neg t_comp\n  let g' : (P × G) → G → E' := fun p x ↦ g p.1 (p.2 - x)\n  let s' : Set (P × G) := s ×ˢ t\n  have A : ContinuousOn g'.uncurry (s' ×ˢ univ) := by\n    have : g'.uncurry = g.uncurry ∘ (fun w ↦ (w.1.1, w.1.2 - w.2)) := by ext y; rfl\n    rw [this]\n    refine hg.comp (continuous_fst.fst.prod_mk (continuous_fst.snd.sub\n      continuous_snd)).continuousOn ?_\n    simp +contextual [s', MapsTo]\n  have B : ContinuousOn (fun a ↦ ∫ x, L (f x) (g' a x) ∂μ) s' := by\n    apply continuousOn_integral_bilinear_of_locally_integrable_of_compact_support L k'_comp A _\n      (hf.integrableOn_isCompact k'_comp)\n    rintro ⟨p, x⟩ y ⟨hp, hx⟩ hy\n    apply hgs p _ hp\n    contrapose! hy\n    exact ⟨y - x, by simpa using hy, x, hx, by simp⟩\n  apply ContinuousWithinAt.mono_of_mem_nhdsWithin (B (q₀, x₀) ⟨hq₀, mem_of_mem_nhds ht⟩)\n  exact mem_nhdsWithin_prod_iff.2 ⟨s, self_mem_nhdsWithin, t, nhdsWithin_le_nhds ht, Subset.rfl⟩\n\n"}
{"name":"MeasureTheory.continuousOn_convolution_right_with_param_comp","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁶ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁵ : NormedSpace Real F\ninst✝⁴ : AddGroup G\ninst✝³ : TopologicalSpace G\ninst✝² : TopologicalAddGroup G\ninst✝¹ : BorelSpace G\ninst✝ : TopologicalSpace P\ns : Set P\nv : P → G\nhv : ContinuousOn v s\ng : P → G → E'\nk : Set G\nhk : IsCompact k\nhgs : ∀ (p : P) (x : G), Membership.mem s p → Not (Membership.mem k x) → Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : ContinuousOn (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\n⊢ ContinuousOn (fun x => MeasureTheory.convolution f (g x) L μ (v x)) s","decl":"/-- The convolution `f * g` is continuous if `f` is locally integrable and `g` is continuous and\ncompactly supported. Version where `g` depends on an additional parameter in an open subset `s` of\na parameter space `P` (and the compact support `k` is independent of the parameter in `s`),\ngiven in terms of compositions with an additional continuous map. -/\ntheorem continuousOn_convolution_right_with_param_comp {s : Set P} {v : P → G}\n    (hv : ContinuousOn v s) {g : P → G → E'} {k : Set G} (hk : IsCompact k)\n    (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0) (hf : LocallyIntegrable f μ)\n    (hg : ContinuousOn (↿g) (s ×ˢ univ)) : ContinuousOn (fun x => (f ⋆[L, μ] g x) (v x)) s := by\n  apply\n    (continuousOn_convolution_right_with_param L hk hgs hf hg).comp (continuousOn_id.prod hv)\n  intro x hx\n  simp only [hx, prod_mk_mem_set_prod_eq, mem_univ, and_self_iff, _root_.id]\n\n"}
{"name":"HasCompactSupport.continuous_convolution_right","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹² : NormedAddCommGroup E\ninst✝¹¹ : NormedAddCommGroup E'\ninst✝¹⁰ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : NormedSpace 𝕜 E'\ninst✝⁶ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁵ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : NormedSpace Real F\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : BorelSpace G\nhcg : HasCompactSupport g\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : Continuous g\n⊢ Continuous (MeasureTheory.convolution f g L μ)","decl":"/-- The convolution is continuous if one function is locally integrable and the other has compact\nsupport and is continuous. -/\ntheorem _root_.HasCompactSupport.continuous_convolution_right (hcg : HasCompactSupport g)\n    (hf : LocallyIntegrable f μ) (hg : Continuous g) : Continuous (f ⋆[L, μ] g) := by\n  rw [continuous_iff_continuousOn_univ]\n  let g' : G → G → E' := fun _ q => g q\n  have : ContinuousOn (↿g') (univ ×ˢ univ) := (hg.comp continuous_snd).continuousOn\n  exact continuousOn_convolution_right_with_param_comp L\n    (continuous_iff_continuousOn_univ.1 continuous_id) hcg\n    (fun p x _ hx => image_eq_zero_of_nmem_tsupport hx) hf this\n\n"}
{"name":"BddAbove.continuous_convolution_right_of_integrable","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹⁴ : NormedAddCommGroup E\ninst✝¹³ : NormedAddCommGroup E'\ninst✝¹² : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹¹ : NontriviallyNormedField 𝕜\ninst✝¹⁰ : NormedSpace 𝕜 E\ninst✝⁹ : NormedSpace 𝕜 E'\ninst✝⁸ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁷ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁶ : NormedSpace Real F\ninst✝⁵ : AddGroup G\ninst✝⁴ : TopologicalSpace G\ninst✝³ : TopologicalAddGroup G\ninst✝² : BorelSpace G\ninst✝¹ : FirstCountableTopology G\ninst✝ : SecondCountableTopologyEither G E'\nhbg : BddAbove (Set.range fun x => Norm.norm (g x))\nhf : MeasureTheory.Integrable f μ\nhg : Continuous g\n⊢ Continuous (MeasureTheory.convolution f g L μ)","decl":"/-- The convolution is continuous if one function is integrable and the other is bounded and\ncontinuous. -/\ntheorem _root_.BddAbove.continuous_convolution_right_of_integrable\n    [FirstCountableTopology G] [SecondCountableTopologyEither G E']\n    (hbg : BddAbove (range fun x => ‖g x‖)) (hf : Integrable f μ) (hg : Continuous g) :\n    Continuous (f ⋆[L, μ] g) := by\n  refine continuous_iff_continuousAt.mpr fun x₀ => ?_\n  have : ∀ᶠ x in 𝓝 x₀, ∀ᵐ t : G ∂μ, ‖L (f t) (g (x - t))‖ ≤ ‖L‖ * ‖f t‖ * ⨆ i, ‖g i‖ := by\n    filter_upwards with x; filter_upwards with t\n    apply_rules [L.le_of_opNorm₂_le_of_le, le_rfl, le_ciSup hbg (x - t)]\n  refine continuousAt_of_dominated ?_ this ?_ ?_\n  · exact Eventually.of_forall fun x =>\n      hf.aestronglyMeasurable.convolution_integrand_snd' L hg.aestronglyMeasurable\n  · exact (hf.norm.const_mul _).mul_const _\n  · exact Eventually.of_forall fun t => (L.continuous₂.comp₂ continuous_const <|\n      hg.comp <| continuous_id.sub continuous_const).continuousAt\n\n"}
{"name":"MeasureTheory.support_convolution_subset","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : NormedSpace Real F\ninst✝ : AddCommGroup G\n⊢ HasSubset.Subset (Function.support (MeasureTheory.convolution f g L μ)) (HAdd.hAdd (Function.support f) (Function.support g))","decl":"theorem support_convolution_subset : support (f ⋆[L, μ] g) ⊆ support f + support g :=\n  (support_convolution_subset_swap L).trans (add_comm _ _).subset\n\n"}
{"name":"MeasureTheory.convolution_flip","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁶ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁵ : NormedSpace Real F\ninst✝⁴ : AddCommGroup G\ninst✝³ : μ.IsAddLeftInvariant\ninst✝² : μ.IsNegInvariant\ninst✝¹ : MeasurableNeg G\ninst✝ : MeasurableAdd G\n⊢ Eq (MeasureTheory.convolution g f L.flip μ) (MeasureTheory.convolution f g L μ)","decl":"/-- Commutativity of convolution -/\ntheorem convolution_flip : g ⋆[L.flip, μ] f = f ⋆[L, μ] g := by\n  ext1 x\n  simp_rw [convolution_def]\n  rw [← integral_sub_left_eq_self _ μ x]\n  simp_rw [sub_sub_self, flip_apply]\n\n"}
{"name":"MeasureTheory.convolution_eq_swap","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\nx : G\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁶ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁵ : NormedSpace Real F\ninst✝⁴ : AddCommGroup G\ninst✝³ : μ.IsAddLeftInvariant\ninst✝² : μ.IsNegInvariant\ninst✝¹ : MeasurableNeg G\ninst✝ : MeasurableAdd G\n⊢ Eq (MeasureTheory.convolution f g L μ x) (MeasureTheory.integral μ fun t => (L (f (HSub.hSub x t))) (g t))","decl":"/-- The symmetric definition of convolution. -/\ntheorem convolution_eq_swap : (f ⋆[L, μ] g) x = ∫ t, L (f (x - t)) (g t) ∂μ := by\n  rw [← convolution_flip]; rfl\n\n"}
{"name":"MeasureTheory.convolution_lsmul_swap","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nF : Type uF\ninst✝⁹ : NormedAddCommGroup F\nx : G\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedSpace 𝕜 F\ninst✝⁶ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁵ : NormedSpace Real F\ninst✝⁴ : AddCommGroup G\ninst✝³ : μ.IsAddLeftInvariant\ninst✝² : μ.IsNegInvariant\ninst✝¹ : MeasurableNeg G\ninst✝ : MeasurableAdd G\nf : G → 𝕜\ng : G → F\n⊢ Eq (MeasureTheory.convolution f g (ContinuousLinearMap.lsmul 𝕜 𝕜) μ x) (MeasureTheory.integral μ fun t => HSMul.hSMul (f (HSub.hSub x t)) (g t))","decl":"/-- The symmetric definition of convolution where the bilinear operator is scalar multiplication. -/\ntheorem convolution_lsmul_swap {f : G → 𝕜} {g : G → F} :\n    (f ⋆[lsmul 𝕜 𝕜, μ] g : G → F) x = ∫ t, f (x - t) • g t ∂μ :=\n  convolution_eq_swap _\n\n"}
{"name":"MeasureTheory.convolution_mul_swap","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nx : G\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁵ : AddCommGroup G\ninst✝⁴ : μ.IsAddLeftInvariant\ninst✝³ : μ.IsNegInvariant\ninst✝² : MeasurableNeg G\ninst✝¹ : MeasurableAdd G\ninst✝ : NormedSpace Real 𝕜\nf g : G → 𝕜\n⊢ Eq (MeasureTheory.convolution f g (ContinuousLinearMap.mul 𝕜 𝕜) μ x) (MeasureTheory.integral μ fun t => HMul.hMul (f (HSub.hSub x t)) (g t))","decl":"/-- The symmetric definition of convolution where the bilinear operator is multiplication. -/\ntheorem convolution_mul_swap [NormedSpace ℝ 𝕜] {f : G → 𝕜} {g : G → 𝕜} :\n    (f ⋆[mul 𝕜 𝕜, μ] g) x = ∫ t, f (x - t) * g t ∂μ :=\n  convolution_eq_swap _\n\n"}
{"name":"MeasureTheory.convolution_neg_of_neg_eq","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\nx : G\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁶ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁵ : NormedSpace Real F\ninst✝⁴ : AddCommGroup G\ninst✝³ : μ.IsAddLeftInvariant\ninst✝² : μ.IsNegInvariant\ninst✝¹ : MeasurableNeg G\ninst✝ : MeasurableAdd G\nh1 : Filter.Eventually (fun x => Eq (f (Neg.neg x)) (f x)) (MeasureTheory.ae μ)\nh2 : Filter.Eventually (fun x => Eq (g (Neg.neg x)) (g x)) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.convolution f g L μ (Neg.neg x)) (MeasureTheory.convolution f g L μ x)","decl":"/-- The convolution of two even functions is also even. -/\ntheorem convolution_neg_of_neg_eq (h1 : ∀ᵐ x ∂μ, f (-x) = f x) (h2 : ∀ᵐ x ∂μ, g (-x) = g x) :\n    (f ⋆[L, μ] g) (-x) = (f ⋆[L, μ] g) x :=\n  calc\n    ∫ t : G, (L (f t)) (g (-x - t)) ∂μ = ∫ t : G, (L (f (-t))) (g (x + t)) ∂μ := by\n      apply integral_congr_ae\n      filter_upwards [h1, (eventually_add_left_iff μ x).2 h2] with t ht h't\n      simp_rw [ht, ← h't, neg_add']\n    _ = ∫ t : G, (L (f t)) (g (x - t)) ∂μ := by\n      rw [← integral_neg_eq_self]\n      simp only [neg_neg, ← sub_eq_add_neg]\n\n"}
{"name":"HasCompactSupport.continuous_convolution_left","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹⁴ : NormedAddCommGroup E\ninst✝¹³ : NormedAddCommGroup E'\ninst✝¹² : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹¹ : NontriviallyNormedField 𝕜\ninst✝¹⁰ : NormedSpace 𝕜 E\ninst✝⁹ : NormedSpace 𝕜 E'\ninst✝⁸ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁷ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁶ : NormedSpace Real F\ninst✝⁵ : AddCommGroup G\ninst✝⁴ : μ.IsAddLeftInvariant\ninst✝³ : μ.IsNegInvariant\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : BorelSpace G\nhcf : HasCompactSupport f\nhf : Continuous f\nhg : MeasureTheory.LocallyIntegrable g μ\n⊢ Continuous (MeasureTheory.convolution f g L μ)","decl":"theorem _root_.HasCompactSupport.continuous_convolution_left\n    (hcf : HasCompactSupport f) (hf : Continuous f) (hg : LocallyIntegrable g μ) :\n    Continuous (f ⋆[L, μ] g) := by\n  rw [← convolution_flip]\n  exact hcf.continuous_convolution_right L.flip hg hf\n\n"}
{"name":"BddAbove.continuous_convolution_left_of_integrable","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹⁶ : NormedAddCommGroup E\ninst✝¹⁵ : NormedAddCommGroup E'\ninst✝¹⁴ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹³ : NontriviallyNormedField 𝕜\ninst✝¹² : NormedSpace 𝕜 E\ninst✝¹¹ : NormedSpace 𝕜 E'\ninst✝¹⁰ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁹ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁸ : NormedSpace Real F\ninst✝⁷ : AddCommGroup G\ninst✝⁶ : μ.IsAddLeftInvariant\ninst✝⁵ : μ.IsNegInvariant\ninst✝⁴ : TopologicalSpace G\ninst✝³ : TopologicalAddGroup G\ninst✝² : BorelSpace G\ninst✝¹ : FirstCountableTopology G\ninst✝ : SecondCountableTopologyEither G E\nhbf : BddAbove (Set.range fun x => Norm.norm (f x))\nhf : Continuous f\nhg : MeasureTheory.Integrable g μ\n⊢ Continuous (MeasureTheory.convolution f g L μ)","decl":"theorem _root_.BddAbove.continuous_convolution_left_of_integrable\n    [FirstCountableTopology G] [SecondCountableTopologyEither G E]\n    (hbf : BddAbove (range fun x => ‖f x‖)) (hf : Continuous f) (hg : Integrable g μ) :\n    Continuous (f ⋆[L, μ] g) := by\n  rw [← convolution_flip]\n  exact hbf.continuous_convolution_right_of_integrable L.flip hg hf\n\n"}
{"name":"MeasureTheory.convolution_eq_right'","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝¹ : NormedSpace Real F\ninst✝ : SeminormedAddCommGroup G\nx₀ : G\nR : Real\nhf : HasSubset.Subset (Function.support f) (Metric.ball 0 R)\nhg : ∀ (x : G), Membership.mem (Metric.ball x₀ R) x → Eq (g x) (g x₀)\n⊢ Eq (MeasureTheory.convolution f g L μ x₀) (MeasureTheory.integral μ fun t => (L (f t)) (g x₀))","decl":"/-- Compute `(f ⋆ g) x₀` if the support of the `f` is within `Metric.ball 0 R`, and `g` is constant\non `Metric.ball x₀ R`.\n\nWe can simplify the RHS further if we assume `f` is integrable, but also if `L = (•)` or more\ngenerally if `L` has an `AntilipschitzWith`-condition. -/\ntheorem convolution_eq_right' {x₀ : G} {R : ℝ} (hf : support f ⊆ ball (0 : G) R)\n    (hg : ∀ x ∈ ball x₀ R, g x = g x₀) : (f ⋆[L, μ] g) x₀ = ∫ t, L (f t) (g x₀) ∂μ := by\n  have h2 : ∀ t, L (f t) (g (x₀ - t)) = L (f t) (g x₀) := fun t ↦ by\n    by_cases ht : t ∈ support f\n    · have h2t := hf ht\n      rw [mem_ball_zero_iff] at h2t\n      specialize hg (x₀ - t)\n      rw [sub_eq_add_neg, add_mem_ball_iff_norm, norm_neg, ← sub_eq_add_neg] at hg\n      rw [hg h2t]\n    · rw [nmem_support] at ht\n      simp_rw [ht, L.map_zero₂]\n  simp_rw [convolution_def, h2]\n\n"}
{"name":"MeasureTheory.dist_convolution_le'","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace 𝕜 F\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁶ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁵ : NormedSpace Real F\ninst✝⁴ : SeminormedAddCommGroup G\ninst✝³ : BorelSpace G\ninst✝² : SecondCountableTopology G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : MeasureTheory.SFinite μ\nx₀ : G\nR ε : Real\nz₀ : E'\nhε : LE.le 0 ε\nhif : MeasureTheory.Integrable f μ\nhf : HasSubset.Subset (Function.support f) (Metric.ball 0 R)\nhmg : MeasureTheory.AEStronglyMeasurable g μ\nhg : ∀ (x : G), Membership.mem (Metric.ball x₀ R) x → LE.le (Dist.dist (g x) z₀) ε\n⊢ LE.le (Dist.dist (MeasureTheory.convolution f g L μ x₀) (MeasureTheory.integral μ fun t => (L (f t)) z₀)) (HMul.hMul (HMul.hMul (Norm.norm L) (MeasureTheory.integral μ fun x => Norm.norm (f x))) ε)","decl":"/-- Approximate `(f ⋆ g) x₀` if the support of the `f` is bounded within a ball, and `g` is near\n`g x₀` on a ball with the same radius around `x₀`. See `dist_convolution_le` for a special case.\n\nWe can simplify the second argument of `dist` further if we add some extra type-classes on `E`\nand `𝕜` or if `L` is scalar multiplication. -/\ntheorem dist_convolution_le' {x₀ : G} {R ε : ℝ} {z₀ : E'} (hε : 0 ≤ ε) (hif : Integrable f μ)\n    (hf : support f ⊆ ball (0 : G) R) (hmg : AEStronglyMeasurable g μ)\n    (hg : ∀ x ∈ ball x₀ R, dist (g x) z₀ ≤ ε) :\n    dist ((f ⋆[L, μ] g : G → F) x₀) (∫ t, L (f t) z₀ ∂μ) ≤ (‖L‖ * ∫ x, ‖f x‖ ∂μ) * ε := by\n  have hfg : ConvolutionExistsAt f g x₀ L μ := by\n    refine BddAbove.convolutionExistsAt L ?_ Metric.isOpen_ball.measurableSet (Subset.trans ?_ hf)\n      hif.integrableOn hmg\n    swap; · refine fun t => mt fun ht : f t = 0 => ?_; simp_rw [ht, L.map_zero₂]\n    rw [bddAbove_def]\n    refine ⟨‖z₀‖ + ε, ?_⟩\n    rintro _ ⟨x, hx, rfl⟩\n    refine norm_le_norm_add_const_of_dist_le (hg x ?_)\n    rwa [mem_ball_iff_norm, norm_sub_rev, ← mem_ball_zero_iff]\n  have h2 : ∀ t, dist (L (f t) (g (x₀ - t))) (L (f t) z₀) ≤ ‖L (f t)‖ * ε := by\n    intro t; by_cases ht : t ∈ support f\n    · have h2t := hf ht\n      rw [mem_ball_zero_iff] at h2t\n      specialize hg (x₀ - t)\n      rw [sub_eq_add_neg, add_mem_ball_iff_norm, norm_neg, ← sub_eq_add_neg] at hg\n      refine ((L (f t)).dist_le_opNorm _ _).trans ?_\n      exact mul_le_mul_of_nonneg_left (hg h2t) (norm_nonneg _)\n    · rw [nmem_support] at ht\n      simp_rw [ht, L.map_zero₂, L.map_zero, norm_zero, zero_mul, dist_self]\n      rfl\n  simp_rw [convolution_def]\n  simp_rw [dist_eq_norm] at h2 ⊢\n  rw [← integral_sub hfg.integrable]; swap; · exact (L.flip z₀).integrable_comp hif\n  refine (norm_integral_le_of_norm_le ((L.integrable_comp hif).norm.mul_const ε)\n    (Eventually.of_forall h2)).trans ?_\n  rw [integral_mul_right]\n  refine mul_le_mul_of_nonneg_right ?_ hε\n  have h3 : ∀ t, ‖L (f t)‖ ≤ ‖L‖ * ‖f t‖ := by\n    intro t\n    exact L.le_opNorm (f t)\n  refine (integral_mono (L.integrable_comp hif).norm (hif.norm.const_mul _) h3).trans_eq ?_\n  rw [integral_mul_left]\n\n"}
{"name":"MeasureTheory.dist_convolution_le","module":"Mathlib.Analysis.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninst✝⁸ : NormedAddCommGroup E'\ng : G → E'\ninst✝⁷ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁶ : SeminormedAddCommGroup G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : SecondCountableTopology G\ninst✝³ : μ.IsAddLeftInvariant\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : NormedSpace Real E'\ninst✝ : CompleteSpace E'\nf : G → Real\nx₀ : G\nR ε : Real\nz₀ : E'\nhε : LE.le 0 ε\nhf : HasSubset.Subset (Function.support f) (Metric.ball 0 R)\nhnf : ∀ (x : G), LE.le 0 (f x)\nhintf : Eq (MeasureTheory.integral μ fun x => f x) 1\nhmg : MeasureTheory.AEStronglyMeasurable g μ\nhg : ∀ (x : G), Membership.mem (Metric.ball x₀ R) x → LE.le (Dist.dist (g x) z₀) ε\n⊢ LE.le (Dist.dist (MeasureTheory.convolution f g (ContinuousLinearMap.lsmul Real Real) μ x₀) z₀) ε","decl":"/-- Approximate `f ⋆ g` if the support of the `f` is bounded within a ball, and `g` is near `g x₀`\non a ball with the same radius around `x₀`.\n\nThis is a special case of `dist_convolution_le'` where `L` is `(•)`, `f` has integral 1 and `f` is\nnonnegative. -/\ntheorem dist_convolution_le {f : G → ℝ} {x₀ : G} {R ε : ℝ} {z₀ : E'} (hε : 0 ≤ ε)\n    (hf : support f ⊆ ball (0 : G) R) (hnf : ∀ x, 0 ≤ f x) (hintf : ∫ x, f x ∂μ = 1)\n    (hmg : AEStronglyMeasurable g μ) (hg : ∀ x ∈ ball x₀ R, dist (g x) z₀ ≤ ε) :\n    dist ((f ⋆[lsmul ℝ ℝ, μ] g : G → E') x₀) z₀ ≤ ε := by\n  have hif : Integrable f μ := integrable_of_integral_eq_one hintf\n  convert (dist_convolution_le' (lsmul ℝ ℝ) hε hif hf hmg hg).trans _\n  · simp_rw [lsmul_apply, integral_smul_const, hintf, one_smul]\n  · simp_rw [Real.norm_of_nonneg (hnf _), hintf, mul_one]\n    exact (mul_le_mul_of_nonneg_right opNorm_lsmul_le hε).trans_eq (one_mul ε)\n\n"}
{"name":"MeasureTheory.convolution_tendsto_right","module":"Mathlib.Analysis.Convolution","initialProofState":"G : Type uG\nE' : Type uE'\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁶ : SeminormedAddCommGroup G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : SecondCountableTopology G\ninst✝³ : μ.IsAddLeftInvariant\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : NormedSpace Real E'\ninst✝ : CompleteSpace E'\nι : Type u_1\ng : ι → G → E'\nl : Filter ι\nx₀ : G\nz₀ : E'\nφ : ι → G → Real\nk : ι → G\nhnφ : Filter.Eventually (fun i => ∀ (x : G), LE.le 0 (φ i x)) l\nhiφ : Filter.Eventually (fun i => Eq (MeasureTheory.integral μ fun x => φ i x) 1) l\nhφ : Filter.Tendsto (fun n => Function.support (φ n)) l (nhds 0).smallSets\nhmg : Filter.Eventually (fun i => MeasureTheory.AEStronglyMeasurable (g i) μ) l\nhcg : Filter.Tendsto (Function.uncurry g) (SProd.sprod l (nhds x₀)) (nhds z₀)\nhk : Filter.Tendsto k l (nhds x₀)\n⊢ Filter.Tendsto (fun i => MeasureTheory.convolution (φ i) (g i) (ContinuousLinearMap.lsmul Real Real) μ (k i)) l (nhds z₀)","decl":"/-- `(φ i ⋆ g i) (k i)` tends to `z₀` as `i` tends to some filter `l` if\n* `φ` is a sequence of nonnegative functions with integral `1` as `i` tends to `l`;\n* The support of `φ` tends to small neighborhoods around `(0 : G)` as `i` tends to `l`;\n* `g i` is `mu`-a.e. strongly measurable as `i` tends to `l`;\n* `g i x` tends to `z₀` as `(i, x)` tends to `l ×ˢ 𝓝 x₀`;\n* `k i` tends to `x₀`.\n\nSee also `ContDiffBump.convolution_tendsto_right`.\n-/\ntheorem convolution_tendsto_right {ι} {g : ι → G → E'} {l : Filter ι} {x₀ : G} {z₀ : E'}\n    {φ : ι → G → ℝ} {k : ι → G} (hnφ : ∀ᶠ i in l, ∀ x, 0 ≤ φ i x)\n    (hiφ : ∀ᶠ i in l, ∫ x, φ i x ∂μ = 1)\n    -- todo: we could weaken this to \"the integral tends to 1\"\n    (hφ : Tendsto (fun n => support (φ n)) l (𝓝 0).smallSets)\n    (hmg : ∀ᶠ i in l, AEStronglyMeasurable (g i) μ) (hcg : Tendsto (uncurry g) (l ×ˢ 𝓝 x₀) (𝓝 z₀))\n    (hk : Tendsto k l (𝓝 x₀)) :\n    Tendsto (fun i : ι => (φ i ⋆[lsmul ℝ ℝ, μ] g i : G → E') (k i)) l (𝓝 z₀) := by\n  simp_rw [tendsto_smallSets_iff] at hφ\n  rw [Metric.tendsto_nhds] at hcg ⊢\n  simp_rw [Metric.eventually_prod_nhds_iff] at hcg\n  intro ε hε\n  have h2ε : 0 < ε / 3 := div_pos hε (by norm_num)\n  obtain ⟨p, hp, δ, hδ, hgδ⟩ := hcg _ h2ε\n  dsimp only [uncurry] at hgδ\n  have h2k := hk.eventually (ball_mem_nhds x₀ <| half_pos hδ)\n  have h2φ := hφ (ball (0 : G) _) <| ball_mem_nhds _ (half_pos hδ)\n  filter_upwards [hp, h2k, h2φ, hnφ, hiφ, hmg] with i hpi hki hφi hnφi hiφi hmgi\n  have hgi : dist (g i (k i)) z₀ < ε / 3 := hgδ hpi (hki.trans <| half_lt_self hδ)\n  have h1 : ∀ x' ∈ ball (k i) (δ / 2), dist (g i x') (g i (k i)) ≤ ε / 3 + ε / 3 := by\n    intro x' hx'\n    refine (dist_triangle_right _ _ _).trans (add_le_add (hgδ hpi ?_).le hgi.le)\n    exact ((dist_triangle _ _ _).trans_lt (add_lt_add hx'.out hki)).trans_eq (add_halves δ)\n  have := dist_convolution_le (add_pos h2ε h2ε).le hφi hnφi hiφi hmgi h1\n  refine ((dist_triangle _ _ _).trans_lt (add_lt_add_of_le_of_lt this hgi)).trans_eq ?_\n  field_simp; ring_nf\n\n"}
{"name":"MeasureTheory.integral_convolution","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹⁹ : NormedAddCommGroup E\ninst✝¹⁸ : NormedAddCommGroup E'\ninst✝¹⁷ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹⁶ : RCLike 𝕜\ninst✝¹⁵ : NormedSpace 𝕜 E\ninst✝¹⁴ : NormedSpace 𝕜 E'\ninst✝¹³ : NormedSpace Real F\ninst✝¹² : NormedSpace 𝕜 F\ninst✝¹¹ : MeasurableSpace G\nμ ν : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝¹⁰ : CompleteSpace F\ninst✝⁹ : AddGroup G\ninst✝⁸ : MeasureTheory.SFinite μ\ninst✝⁷ : MeasureTheory.SFinite ν\ninst✝⁶ : μ.IsAddRightInvariant\ninst✝⁵ : MeasurableAdd₂ G\ninst✝⁴ : MeasurableNeg G\ninst✝³ : NormedSpace Real E\ninst✝² : NormedSpace Real E'\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace E'\nhf : MeasureTheory.Integrable f ν\nhg : MeasureTheory.Integrable g μ\n⊢ Eq (MeasureTheory.integral μ fun x => MeasureTheory.convolution f g L ν x) ((L (MeasureTheory.integral ν fun x => f x)) (MeasureTheory.integral μ fun x => g x))","decl":"theorem integral_convolution [MeasurableAdd₂ G] [MeasurableNeg G] [NormedSpace ℝ E]\n    [NormedSpace ℝ E'] [CompleteSpace E] [CompleteSpace E'] (hf : Integrable f ν)\n    (hg : Integrable g μ) : ∫ x, (f ⋆[L, ν] g) x ∂μ = L (∫ x, f x ∂ν) (∫ x, g x ∂μ) := by\n  refine (integral_integral_swap (by apply hf.convolution_integrand L hg)).trans ?_\n  simp_rw [integral_comp_comm _ (hg.comp_sub_right _), integral_sub_right_eq_self]\n  exact (L.flip (∫ x, g x ∂μ)).integral_comp_comm hf\n\n"}
{"name":"MeasureTheory.convolution_assoc'","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nE'' : Type uE''\nF : Type uF\nF' : Type uF'\nF'' : Type uF''\ninst✝²⁶ : NormedAddCommGroup E\ninst✝²⁵ : NormedAddCommGroup E'\ninst✝²⁴ : NormedAddCommGroup E''\ninst✝²³ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝²² : RCLike 𝕜\ninst✝²¹ : NormedSpace 𝕜 E\ninst✝²⁰ : NormedSpace 𝕜 E'\ninst✝¹⁹ : NormedSpace 𝕜 E''\ninst✝¹⁸ : NormedSpace Real F\ninst✝¹⁷ : NormedSpace 𝕜 F\ninst✝¹⁶ : MeasurableSpace G\nμ ν : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝¹⁵ : CompleteSpace F\ninst✝¹⁴ : NormedAddCommGroup F'\ninst✝¹³ : NormedSpace Real F'\ninst✝¹² : NormedSpace 𝕜 F'\ninst✝¹¹ : CompleteSpace F'\ninst✝¹⁰ : NormedAddCommGroup F''\ninst✝⁹ : NormedSpace Real F''\ninst✝⁸ : NormedSpace 𝕜 F''\ninst✝⁷ : CompleteSpace F''\nk : G → E''\nL₂ : ContinuousLinearMap (RingHom.id 𝕜) F (ContinuousLinearMap (RingHom.id 𝕜) E'' F')\nL₃ : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F'' F')\nL₄ : ContinuousLinearMap (RingHom.id 𝕜) E' (ContinuousLinearMap (RingHom.id 𝕜) E'' F'')\ninst✝⁶ : AddGroup G\ninst✝⁵ : MeasureTheory.SFinite μ\ninst✝⁴ : MeasureTheory.SFinite ν\ninst✝³ : μ.IsAddRightInvariant\ninst✝² : MeasurableAdd₂ G\ninst✝¹ : ν.IsAddRightInvariant\ninst✝ : MeasurableNeg G\nhL : ∀ (x : E) (y : E') (z : E''), Eq ((L₂ ((L x) y)) z) ((L₃ x) ((L₄ y) z))\nx₀ : G\nhfg : Filter.Eventually (fun y => MeasureTheory.ConvolutionExistsAt f g y L ν) (MeasureTheory.ae μ)\nhgk : Filter.Eventually (fun x => MeasureTheory.ConvolutionExistsAt g k x L₄ μ) (MeasureTheory.ae ν)\nhi : MeasureTheory.Integrable (Function.uncurry fun x y => (L₃ (f y)) ((L₄ (g (HSub.hSub x y))) (k (HSub.hSub x₀ x)))) (μ.prod ν)\n⊢ Eq (MeasureTheory.convolution (MeasureTheory.convolution f g L ν) k L₂ μ x₀) (MeasureTheory.convolution f (MeasureTheory.convolution g k L₄ μ) L₃ ν x₀)","decl":"/-- Convolution is associative. This has a weak but inconvenient integrability condition.\nSee also `MeasureTheory.convolution_assoc`. -/\ntheorem convolution_assoc' (hL : ∀ (x : E) (y : E') (z : E''), L₂ (L x y) z = L₃ x (L₄ y z))\n    {x₀ : G} (hfg : ∀ᵐ y ∂μ, ConvolutionExistsAt f g y L ν)\n    (hgk : ∀ᵐ x ∂ν, ConvolutionExistsAt g k x L₄ μ)\n    (hi : Integrable (uncurry fun x y => (L₃ (f y)) ((L₄ (g (x - y))) (k (x₀ - x)))) (μ.prod ν)) :\n    ((f ⋆[L, ν] g) ⋆[L₂, μ] k) x₀ = (f ⋆[L₃, ν] g ⋆[L₄, μ] k) x₀ :=\n  calc\n    ((f ⋆[L, ν] g) ⋆[L₂, μ] k) x₀ = ∫ t, L₂ (∫ s, L (f s) (g (t - s)) ∂ν) (k (x₀ - t)) ∂μ := rfl\n    _ = ∫ t, ∫ s, L₂ (L (f s) (g (t - s))) (k (x₀ - t)) ∂ν ∂μ :=\n      (integral_congr_ae (hfg.mono fun t ht => ((L₂.flip (k (x₀ - t))).integral_comp_comm ht).symm))\n    _ = ∫ t, ∫ s, L₃ (f s) (L₄ (g (t - s)) (k (x₀ - t))) ∂ν ∂μ := by simp_rw [hL]\n    _ = ∫ s, ∫ t, L₃ (f s) (L₄ (g (t - s)) (k (x₀ - t))) ∂μ ∂ν := by rw [integral_integral_swap hi]\n    _ = ∫ s, ∫ u, L₃ (f s) (L₄ (g u) (k (x₀ - s - u))) ∂μ ∂ν := by\n      congr; ext t\n      rw [eq_comm, ← integral_sub_right_eq_self _ t]\n      simp_rw [sub_sub_sub_cancel_right]\n    _ = ∫ s, L₃ (f s) (∫ u, L₄ (g u) (k (x₀ - s - u)) ∂μ) ∂ν := by\n      refine integral_congr_ae ?_\n      refine ((quasiMeasurePreserving_sub_left_of_right_invariant ν x₀).ae hgk).mono fun t ht => ?_\n      exact (L₃ (f t)).integral_comp_comm ht\n    _ = (f ⋆[L₃, ν] g ⋆[L₄, μ] k) x₀ := rfl\n\n"}
{"name":"MeasureTheory.convolution_assoc","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nE'' : Type uE''\nF : Type uF\nF' : Type uF'\nF'' : Type uF''\ninst✝²⁶ : NormedAddCommGroup E\ninst✝²⁵ : NormedAddCommGroup E'\ninst✝²⁴ : NormedAddCommGroup E''\ninst✝²³ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝²² : RCLike 𝕜\ninst✝²¹ : NormedSpace 𝕜 E\ninst✝²⁰ : NormedSpace 𝕜 E'\ninst✝¹⁹ : NormedSpace 𝕜 E''\ninst✝¹⁸ : NormedSpace Real F\ninst✝¹⁷ : NormedSpace 𝕜 F\ninst✝¹⁶ : MeasurableSpace G\nμ ν : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝¹⁵ : CompleteSpace F\ninst✝¹⁴ : NormedAddCommGroup F'\ninst✝¹³ : NormedSpace Real F'\ninst✝¹² : NormedSpace 𝕜 F'\ninst✝¹¹ : CompleteSpace F'\ninst✝¹⁰ : NormedAddCommGroup F''\ninst✝⁹ : NormedSpace Real F''\ninst✝⁸ : NormedSpace 𝕜 F''\ninst✝⁷ : CompleteSpace F''\nk : G → E''\nL₂ : ContinuousLinearMap (RingHom.id 𝕜) F (ContinuousLinearMap (RingHom.id 𝕜) E'' F')\nL₃ : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F'' F')\nL₄ : ContinuousLinearMap (RingHom.id 𝕜) E' (ContinuousLinearMap (RingHom.id 𝕜) E'' F'')\ninst✝⁶ : AddGroup G\ninst✝⁵ : MeasureTheory.SFinite μ\ninst✝⁴ : MeasureTheory.SFinite ν\ninst✝³ : μ.IsAddRightInvariant\ninst✝² : MeasurableAdd₂ G\ninst✝¹ : ν.IsAddRightInvariant\ninst✝ : MeasurableNeg G\nhL : ∀ (x : E) (y : E') (z : E''), Eq ((L₂ ((L x) y)) z) ((L₃ x) ((L₄ y) z))\nx₀ : G\nhf : MeasureTheory.AEStronglyMeasurable f ν\nhg : MeasureTheory.AEStronglyMeasurable g μ\nhk : MeasureTheory.AEStronglyMeasurable k μ\nhfg : Filter.Eventually (fun y => MeasureTheory.ConvolutionExistsAt f g y L ν) (MeasureTheory.ae μ)\nhgk : Filter.Eventually (fun x => MeasureTheory.ConvolutionExistsAt (fun x => Norm.norm (g x)) (fun x => Norm.norm (k x)) x (ContinuousLinearMap.mul Real Real) μ) (MeasureTheory.ae ν)\nhfgk : MeasureTheory.ConvolutionExistsAt (fun x => Norm.norm (f x)) (MeasureTheory.convolution (fun x => Norm.norm (g x)) (fun x => Norm.norm (k x)) (ContinuousLinearMap.mul Real Real) μ) x₀ (ContinuousLinearMap.mul Real Real) ν\n⊢ Eq (MeasureTheory.convolution (MeasureTheory.convolution f g L ν) k L₂ μ x₀) (MeasureTheory.convolution f (MeasureTheory.convolution g k L₄ μ) L₃ ν x₀)","decl":"/-- Convolution is associative. This requires that\n* all maps are a.e. strongly measurable w.r.t one of the measures\n* `f ⋆[L, ν] g` exists almost everywhere\n* `‖g‖ ⋆[μ] ‖k‖` exists almost everywhere\n* `‖f‖ ⋆[ν] (‖g‖ ⋆[μ] ‖k‖)` exists at `x₀` -/\ntheorem convolution_assoc (hL : ∀ (x : E) (y : E') (z : E''), L₂ (L x y) z = L₃ x (L₄ y z)) {x₀ : G}\n    (hf : AEStronglyMeasurable f ν) (hg : AEStronglyMeasurable g μ) (hk : AEStronglyMeasurable k μ)\n    (hfg : ∀ᵐ y ∂μ, ConvolutionExistsAt f g y L ν)\n    (hgk : ∀ᵐ x ∂ν, ConvolutionExistsAt (fun x => ‖g x‖) (fun x => ‖k x‖) x (mul ℝ ℝ) μ)\n    (hfgk :\n      ConvolutionExistsAt (fun x => ‖f x‖) ((fun x => ‖g x‖) ⋆[mul ℝ ℝ, μ] fun x => ‖k x‖) x₀\n        (mul ℝ ℝ) ν) :\n    ((f ⋆[L, ν] g) ⋆[L₂, μ] k) x₀ = (f ⋆[L₃, ν] g ⋆[L₄, μ] k) x₀ := by\n  refine convolution_assoc' L L₂ L₃ L₄ hL hfg (hgk.mono fun x hx => hx.ofNorm L₄ hg hk) ?_\n  -- the following is similar to `Integrable.convolution_integrand`\n  have h_meas :\n    AEStronglyMeasurable (uncurry fun x y => L₃ (f y) (L₄ (g x) (k (x₀ - y - x))))\n      (μ.prod ν) := by\n    refine L₃.aestronglyMeasurable_comp₂ hf.snd ?_\n    refine L₄.aestronglyMeasurable_comp₂ hg.fst ?_\n    refine (hk.mono_ac ?_).comp_measurable\n      ((measurable_const.sub measurable_snd).sub measurable_fst)\n    refine QuasiMeasurePreserving.absolutelyContinuous ?_\n    refine QuasiMeasurePreserving.prod_of_left\n      ((measurable_const.sub measurable_snd).sub measurable_fst) (Eventually.of_forall fun y => ?_)\n    dsimp only\n    exact quasiMeasurePreserving_sub_left_of_right_invariant μ _\n  have h2_meas :\n    AEStronglyMeasurable (fun y => ∫ x, ‖L₃ (f y) (L₄ (g x) (k (x₀ - y - x)))‖ ∂μ) ν :=\n    h_meas.prod_swap.norm.integral_prod_right'\n  have h3 : map (fun z : G × G => (z.1 - z.2, z.2)) (μ.prod ν) = μ.prod ν :=\n    (measurePreserving_sub_prod μ ν).map_eq\n  suffices Integrable (uncurry fun x y => L₃ (f y) (L₄ (g x) (k (x₀ - y - x)))) (μ.prod ν) by\n    rw [← h3] at this\n    convert this.comp_measurable (measurable_sub.prod_mk measurable_snd)\n    ext ⟨x, y⟩\n    simp (config := { unfoldPartialApp := true }) only [uncurry, Function.comp_apply,\n      sub_sub_sub_cancel_right]\n  simp_rw [integrable_prod_iff' h_meas]\n  refine ⟨((quasiMeasurePreserving_sub_left_of_right_invariant ν x₀).ae hgk).mono fun t ht =>\n    (L₃ (f t)).integrable_comp <| ht.ofNorm L₄ hg hk, ?_⟩\n  refine (hfgk.const_mul (‖L₃‖ * ‖L₄‖)).mono' h2_meas\n    (((quasiMeasurePreserving_sub_left_of_right_invariant ν x₀).ae hgk).mono fun t ht => ?_)\n  simp_rw [convolution_def, mul_apply', mul_mul_mul_comm ‖L₃‖ ‖L₄‖, ← integral_mul_left]\n  rw [Real.norm_of_nonneg (by positivity)]\n  refine integral_mono_of_nonneg (Eventually.of_forall fun t => norm_nonneg _)\n    ((ht.const_mul _).const_mul _) (Eventually.of_forall fun s => ?_)\n  simp only [← mul_assoc ‖L₄‖]\n  apply_rules [ContinuousLinearMap.le_of_opNorm₂_le_of_le, le_rfl]\n\n"}
{"name":"MeasureTheory.convolution_precompR_apply","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nE'' : Type uE''\nF : Type uF\ninst✝¹² : NormedAddCommGroup E\ninst✝¹¹ : NormedAddCommGroup E'\ninst✝¹⁰ : NormedAddCommGroup E''\ninst✝⁹ : NormedAddCommGroup F\nf : G → E\ninst✝⁸ : RCLike 𝕜\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedSpace 𝕜 E'\ninst✝⁵ : NormedSpace 𝕜 E''\ninst✝⁴ : NormedSpace Real F\ninst✝³ : NormedSpace 𝕜 F\ninst✝² : MeasurableSpace G\nμ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : BorelSpace G\ng : G → ContinuousLinearMap (RingHom.id 𝕜) E'' E'\nhf : MeasureTheory.LocallyIntegrable f μ\nhcg : HasCompactSupport g\nhg : Continuous g\nx₀ : G\nx : E''\n⊢ Eq ((MeasureTheory.convolution f g (ContinuousLinearMap.precompR E'' L) μ x₀) x) (MeasureTheory.convolution f (fun a => (g a) x) L μ x₀)","decl":"theorem convolution_precompR_apply {g : G → E'' →L[𝕜] E'} (hf : LocallyIntegrable f μ)\n    (hcg : HasCompactSupport g) (hg : Continuous g) (x₀ : G) (x : E'') :\n    (f ⋆[L.precompR E'', μ] g) x₀ x = (f ⋆[L, μ] fun a => g a x) x₀ := by\n  have := hcg.convolutionExists_right (L.precompR E'' :) hf hg x₀\n  simp_rw [convolution_def, ContinuousLinearMap.integral_apply this]\n  rfl\n\n"}
{"name":"HasCompactSupport.hasFDerivAt_convolution_right","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹⁰ : RCLike 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace Real F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : MeasurableSpace G\nμ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : BorelSpace G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.IsAddLeftInvariant\nhcg : HasCompactSupport g\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : ContDiff 𝕜 1 g\nx₀ : G\n⊢ HasFDerivAt (MeasureTheory.convolution f g L μ) (MeasureTheory.convolution f (fderiv 𝕜 g) (ContinuousLinearMap.precompR G L) μ x₀) x₀","decl":"/-- Compute the total derivative of `f ⋆ g` if `g` is `C^1` with compact support and `f` is locally\nintegrable. To write down the total derivative as a convolution, we use\n`ContinuousLinearMap.precompR`. -/\ntheorem _root_.HasCompactSupport.hasFDerivAt_convolution_right (hcg : HasCompactSupport g)\n    (hf : LocallyIntegrable f μ) (hg : ContDiff 𝕜 1 g) (x₀ : G) :\n    HasFDerivAt (f ⋆[L, μ] g) ((f ⋆[L.precompR G, μ] fderiv 𝕜 g) x₀) x₀ := by\n  rcases hcg.eq_zero_or_finiteDimensional 𝕜 hg.continuous with (rfl | fin_dim)\n  · have : fderiv 𝕜 (0 : G → E') = 0 := fderiv_const (0 : E')\n    simp only [this, convolution_zero, Pi.zero_apply]\n    exact hasFDerivAt_const (0 : F) x₀\n  have : ProperSpace G := FiniteDimensional.proper_rclike 𝕜 G\n  set L' := L.precompR G\n  have h1 : ∀ᶠ x in 𝓝 x₀, AEStronglyMeasurable (fun t => L (f t) (g (x - t))) μ :=\n    Eventually.of_forall\n      (hf.aestronglyMeasurable.convolution_integrand_snd L hg.continuous.aestronglyMeasurable)\n  have h2 : ∀ x, AEStronglyMeasurable (fun t => L' (f t) (fderiv 𝕜 g (x - t))) μ :=\n    hf.aestronglyMeasurable.convolution_integrand_snd L'\n      (hg.continuous_fderiv le_rfl).aestronglyMeasurable\n  have h3 : ∀ x t, HasFDerivAt (fun x => g (x - t)) (fderiv 𝕜 g (x - t)) x := fun x t ↦ by\n    simpa using\n      (hg.differentiable le_rfl).differentiableAt.hasFDerivAt.comp x\n        ((hasFDerivAt_id x).sub (hasFDerivAt_const t x))\n  let K' := -tsupport (fderiv 𝕜 g) + closedBall x₀ 1\n  have hK' : IsCompact K' := (hcg.fderiv 𝕜).neg.add (isCompact_closedBall x₀ 1)\n  -- Porting note: was\n  -- `refine' hasFDerivAt_integral_of_dominated_of_fderiv_le zero_lt_one h1 _ (h2 x₀) _ _ _`\n  -- but it failed; surprisingly, `apply` works\n  apply hasFDerivAt_integral_of_dominated_of_fderiv_le zero_lt_one h1 _ (h2 x₀)\n  · filter_upwards with t x hx using\n      (hcg.fderiv 𝕜).convolution_integrand_bound_right L' (hg.continuous_fderiv le_rfl)\n        (ball_subset_closedBall hx)\n  · rw [integrable_indicator_iff hK'.measurableSet]\n    exact ((hf.integrableOn_isCompact hK').norm.const_mul _).mul_const _\n  · exact Eventually.of_forall fun t x _ => (L _).hasFDerivAt.comp x (h3 x t)\n  · exact hcg.convolutionExists_right L hf hg.continuous x₀\n\n"}
{"name":"HasCompactSupport.hasFDerivAt_convolution_left","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹⁴ : NormedAddCommGroup E\ninst✝¹³ : NormedAddCommGroup E'\ninst✝¹² : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹¹ : RCLike 𝕜\ninst✝¹⁰ : NormedSpace 𝕜 E\ninst✝⁹ : NormedSpace 𝕜 E'\ninst✝⁸ : NormedSpace Real F\ninst✝⁷ : NormedSpace 𝕜 F\ninst✝⁶ : MeasurableSpace G\nμ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝⁵ : NormedAddCommGroup G\ninst✝⁴ : BorelSpace G\ninst✝³ : NormedSpace 𝕜 G\ninst✝² : MeasureTheory.SFinite μ\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : μ.IsNegInvariant\nhcf : HasCompactSupport f\nhf : ContDiff 𝕜 1 f\nhg : MeasureTheory.LocallyIntegrable g μ\nx₀ : G\n⊢ HasFDerivAt (MeasureTheory.convolution f g L μ) (MeasureTheory.convolution (fderiv 𝕜 f) g (ContinuousLinearMap.precompL G L) μ x₀) x₀","decl":"theorem _root_.HasCompactSupport.hasFDerivAt_convolution_left [IsNegInvariant μ]\n    (hcf : HasCompactSupport f) (hf : ContDiff 𝕜 1 f) (hg : LocallyIntegrable g μ) (x₀ : G) :\n    HasFDerivAt (f ⋆[L, μ] g) ((fderiv 𝕜 f ⋆[L.precompL G, μ] g) x₀) x₀ := by\n  simp (config := { singlePass := true }) only [← convolution_flip]\n  exact hcf.hasFDerivAt_convolution_right L.flip hg hf x₀\n\n"}
{"name":"HasCompactSupport.hasDerivAt_convolution_right","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : NormedSpace Real F\ninst✝² : NormedSpace 𝕜 F\nf₀ : 𝕜 → E\ng₀ : 𝕜 → E'\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\nμ : MeasureTheory.Measure 𝕜\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : MeasureTheory.SFinite μ\nhf : MeasureTheory.LocallyIntegrable f₀ μ\nhcg : HasCompactSupport g₀\nhg : ContDiff 𝕜 1 g₀\nx₀ : 𝕜\n⊢ HasDerivAt (MeasureTheory.convolution f₀ g₀ L μ) (MeasureTheory.convolution f₀ (deriv g₀) L μ x₀) x₀","decl":"theorem _root_.HasCompactSupport.hasDerivAt_convolution_right (hf : LocallyIntegrable f₀ μ)\n    (hcg : HasCompactSupport g₀) (hg : ContDiff 𝕜 1 g₀) (x₀ : 𝕜) :\n    HasDerivAt (f₀ ⋆[L, μ] g₀) ((f₀ ⋆[L, μ] deriv g₀) x₀) x₀ := by\n  convert (hcg.hasFDerivAt_convolution_right L hf hg x₀).hasDerivAt using 1\n  rw [convolution_precompR_apply L hf (hcg.fderiv 𝕜) (hg.continuous_fderiv le_rfl)]\n  rfl\n\n"}
{"name":"HasCompactSupport.hasDerivAt_convolution_left","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹⁰ : NormedAddCommGroup E\ninst✝⁹ : NormedAddCommGroup E'\ninst✝⁸ : NormedAddCommGroup F\ninst✝⁷ : RCLike 𝕜\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜 E'\ninst✝⁴ : NormedSpace Real F\ninst✝³ : NormedSpace 𝕜 F\nf₀ : 𝕜 → E\ng₀ : 𝕜 → E'\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\nμ : MeasureTheory.Measure 𝕜\ninst✝² : μ.IsAddLeftInvariant\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.IsNegInvariant\nhcf : HasCompactSupport f₀\nhf : ContDiff 𝕜 1 f₀\nhg : MeasureTheory.LocallyIntegrable g₀ μ\nx₀ : 𝕜\n⊢ HasDerivAt (MeasureTheory.convolution f₀ g₀ L μ) (MeasureTheory.convolution (deriv f₀) g₀ L μ x₀) x₀","decl":"theorem _root_.HasCompactSupport.hasDerivAt_convolution_left [IsNegInvariant μ]\n    (hcf : HasCompactSupport f₀) (hf : ContDiff 𝕜 1 f₀) (hg : LocallyIntegrable g₀ μ) (x₀ : 𝕜) :\n    HasDerivAt (f₀ ⋆[L, μ] g₀) ((deriv f₀ ⋆[L, μ] g₀) x₀) x₀ := by\n  simp (config := { singlePass := true }) only [← convolution_flip]\n  exact hcf.hasDerivAt_convolution_right L.flip hg hf x₀\n\n"}
{"name":"MeasureTheory.hasFDerivAt_convolution_right_with_param","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ninst✝¹⁰ : RCLike 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace Real F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : BorelSpace G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup P\ninst✝ : NormedSpace 𝕜 P\nμ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ng : P → G → E'\ns : Set P\nk : Set G\nhs : IsOpen s\nhk : IsCompact k\nhgs : ∀ (p : P) (x : G), Membership.mem s p → Not (Membership.mem k x) → Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : ContDiffOn 𝕜 1 (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\nq₀ : Prod P G\nhq₀ : Membership.mem s q₀.1\n⊢ HasFDerivAt (fun q => MeasureTheory.convolution f (g q.1) L μ q.2) (MeasureTheory.convolution f (fun x => fderiv 𝕜 (Function.HasUncurry.uncurry g) { fst := q₀.1, snd := x }) (ContinuousLinearMap.precompR (Prod P G) L) μ q₀.2) q₀","decl":"/-- The derivative of the convolution `f * g` is given by `f * Dg`, when `f` is locally integrable\nand `g` is `C^1` and compactly supported. Version where `g` depends on an additional parameter in an\nopen subset `s` of a parameter space `P` (and the compact support `k` is independent of the\nparameter in `s`). -/\ntheorem hasFDerivAt_convolution_right_with_param {g : P → G → E'} {s : Set P} {k : Set G}\n    (hs : IsOpen s) (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)\n    (hf : LocallyIntegrable f μ) (hg : ContDiffOn 𝕜 1 (↿g) (s ×ˢ univ)) (q₀ : P × G)\n    (hq₀ : q₀.1 ∈ s) :\n    HasFDerivAt (fun q : P × G => (f ⋆[L, μ] g q.1) q.2)\n      ((f ⋆[L.precompR (P × G), μ] fun x : G => fderiv 𝕜 (↿g) (q₀.1, x)) q₀.2) q₀ := by\n  let g' := fderiv 𝕜 ↿g\n  have A : ∀ p ∈ s, Continuous (g p) := fun p hp ↦ by\n    refine hg.continuousOn.comp_continuous (continuous_const.prod_mk continuous_id') fun x => ?_\n    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hp\n  have A' : ∀ q : P × G, q.1 ∈ s → s ×ˢ univ ∈ 𝓝 q := fun q hq ↦ by\n    apply (hs.prod isOpen_univ).mem_nhds\n    simpa only [mem_prod, mem_univ, and_true] using hq\n  -- The derivative of `g` vanishes away from `k`.\n  have g'_zero : ∀ p x, p ∈ s → x ∉ k → g' (p, x) = 0 := by\n    intro p x hp hx\n    refine (hasFDerivAt_zero_of_eventually_const 0 ?_).fderiv\n    have M2 : kᶜ ∈ 𝓝 x := hk.isClosed.isOpen_compl.mem_nhds hx\n    have M1 : s ∈ 𝓝 p := hs.mem_nhds hp\n    rw [nhds_prod_eq]\n    filter_upwards [prod_mem_prod M1 M2]\n    rintro ⟨p, y⟩ ⟨hp, hy⟩\n    exact hgs p y hp hy\n  /- We find a small neighborhood of `{q₀.1} × k` on which the derivative is uniformly bounded. This\n    follows from the continuity at all points of the compact set `k`. -/\n  obtain ⟨ε, C, εpos, h₀ε, hε⟩ :\n      ∃ ε C, 0 < ε ∧ ball q₀.1 ε ⊆ s ∧ ∀ p x, ‖p - q₀.1‖ < ε → ‖g' (p, x)‖ ≤ C := by\n    have A : IsCompact ({q₀.1} ×ˢ k) := isCompact_singleton.prod hk\n    obtain ⟨t, kt, t_open, ht⟩ : ∃ t, {q₀.1} ×ˢ k ⊆ t ∧ IsOpen t ∧ IsBounded (g' '' t) := by\n      have B : ContinuousOn g' (s ×ˢ univ) :=\n        hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl\n      apply exists_isOpen_isBounded_image_of_isCompact_of_continuousOn A (hs.prod isOpen_univ) _ B\n      simp only [prod_subset_prod_iff, hq₀, singleton_subset_iff, subset_univ, and_self_iff,\n        true_or]\n    obtain ⟨ε, εpos, hε, h'ε⟩ :\n      ∃ ε : ℝ, 0 < ε ∧ thickening ε ({q₀.fst} ×ˢ k) ⊆ t ∧ ball q₀.1 ε ⊆ s := by\n      obtain ⟨ε, εpos, hε⟩ : ∃ ε : ℝ, 0 < ε ∧ thickening ε (({q₀.fst} : Set P) ×ˢ k) ⊆ t :=\n        A.exists_thickening_subset_open t_open kt\n      obtain ⟨δ, δpos, hδ⟩ : ∃ δ : ℝ, 0 < δ ∧ ball q₀.1 δ ⊆ s := Metric.isOpen_iff.1 hs _ hq₀\n      refine ⟨min ε δ, lt_min εpos δpos, ?_, ?_⟩\n      · exact Subset.trans (thickening_mono (min_le_left _ _) _) hε\n      · exact Subset.trans (ball_subset_ball (min_le_right _ _)) hδ\n    obtain ⟨C, Cpos, hC⟩ : ∃ C, 0 < C ∧ g' '' t ⊆ closedBall 0 C := ht.subset_closedBall_lt 0 0\n    refine ⟨ε, C, εpos, h'ε, fun p x hp => ?_⟩\n    have hps : p ∈ s := h'ε (mem_ball_iff_norm.2 hp)\n    by_cases hx : x ∈ k\n    · have H : (p, x) ∈ t := by\n        apply hε\n        refine mem_thickening_iff.2 ⟨(q₀.1, x), ?_, ?_⟩\n        · simp only [hx, singleton_prod, mem_image, Prod.mk.inj_iff, eq_self_iff_true, true_and,\n            exists_eq_right]\n        · rw [← dist_eq_norm] at hp\n          simpa only [Prod.dist_eq, εpos, dist_self, max_lt_iff, and_true] using hp\n      have : g' (p, x) ∈ closedBall (0 : P × G →L[𝕜] E') C := hC (mem_image_of_mem _ H)\n      rwa [mem_closedBall_zero_iff] at this\n    · have : g' (p, x) = 0 := g'_zero _ _ hps hx\n      rw [this]\n      simpa only [norm_zero] using Cpos.le\n  /- Now, we wish to apply a theorem on differentiation of integrals. For this, we need to check\n    trivial measurability or integrability assumptions (in `I1`, `I2`, `I3`), as well as a uniform\n    integrability assumption over the derivative (in `I4` and `I5`) and pointwise differentiability\n    in `I6`. -/\n  have I1 :\n    ∀ᶠ x : P × G in 𝓝 q₀, AEStronglyMeasurable (fun a : G => L (f a) (g x.1 (x.2 - a))) μ := by\n    filter_upwards [A' q₀ hq₀]\n    rintro ⟨p, x⟩ ⟨hp, -⟩\n    refine (HasCompactSupport.convolutionExists_right L ?_ hf (A _ hp) _).1\n    apply hk.of_isClosed_subset (isClosed_tsupport _)\n    exact closure_minimal (support_subset_iff'.2 fun z hz => hgs _ _ hp hz) hk.isClosed\n  have I2 : Integrable (fun a : G => L (f a) (g q₀.1 (q₀.2 - a))) μ := by\n    have M : HasCompactSupport (g q₀.1) := HasCompactSupport.intro hk fun x hx => hgs q₀.1 x hq₀ hx\n    apply M.convolutionExists_right L hf (A q₀.1 hq₀) q₀.2\n  have I3 : AEStronglyMeasurable (fun a : G => (L (f a)).comp (g' (q₀.fst, q₀.snd - a))) μ := by\n    have T : HasCompactSupport fun y => g' (q₀.1, y) :=\n      HasCompactSupport.intro hk fun x hx => g'_zero q₀.1 x hq₀ hx\n    apply (HasCompactSupport.convolutionExists_right (L.precompR (P × G) :) T hf _ q₀.2).1\n    have : ContinuousOn g' (s ×ˢ univ) :=\n      hg.continuousOn_fderiv_of_isOpen (hs.prod isOpen_univ) le_rfl\n    apply this.comp_continuous (continuous_const.prod_mk continuous_id')\n    intro x\n    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hq₀\n  set K' := (-k + {q₀.2} : Set G) with K'_def\n  have hK' : IsCompact K' := hk.neg.add isCompact_singleton\n  obtain ⟨U, U_open, K'U, hU⟩ : ∃ U, IsOpen U ∧ K' ⊆ U ∧ IntegrableOn f U μ :=\n    hf.integrableOn_nhds_isCompact hK'\n  obtain ⟨δ, δpos, δε, hδ⟩ : ∃ δ, (0 : ℝ) < δ ∧ δ ≤ ε ∧ K' + ball 0 δ ⊆ U := by\n    obtain ⟨V, V_mem, hV⟩ : ∃ V ∈ 𝓝 (0 : G), K' + V ⊆ U :=\n      compact_open_separated_add_right hK' U_open K'U\n    rcases Metric.mem_nhds_iff.1 V_mem with ⟨δ, δpos, hδ⟩\n    refine ⟨min δ ε, lt_min δpos εpos, min_le_right δ ε, ?_⟩\n    exact (add_subset_add_left ((ball_subset_ball (min_le_left _ _)).trans hδ)).trans hV\n  -- Porting note: added to speed up the line below.\n  letI := ContinuousLinearMap.hasOpNorm (𝕜 := 𝕜) (𝕜₂ := 𝕜) (E := E)\n    (F := (P × G →L[𝕜] E') →L[𝕜] P × G →L[𝕜] F) (σ₁₂ := RingHom.id 𝕜)\n  let bound : G → ℝ := indicator U fun t => ‖(L.precompR (P × G))‖ * ‖f t‖ * C\n  have I4 : ∀ᵐ a : G ∂μ, ∀ x : P × G, dist x q₀ < δ →\n      ‖L.precompR (P × G) (f a) (g' (x.fst, x.snd - a))‖ ≤ bound a := by\n    filter_upwards with a x hx\n    rw [Prod.dist_eq, dist_eq_norm, dist_eq_norm] at hx\n    have : (-tsupport fun a => g' (x.1, a)) + ball q₀.2 δ ⊆ U := by\n      apply Subset.trans _ hδ\n      rw [K'_def, add_assoc]\n      apply add_subset_add\n      · rw [neg_subset_neg]\n        refine closure_minimal (support_subset_iff'.2 fun z hz => ?_) hk.isClosed\n        apply g'_zero x.1 z (h₀ε _) hz\n        rw [mem_ball_iff_norm]\n        exact ((le_max_left _ _).trans_lt hx).trans_le δε\n      · simp only [add_ball, thickening_singleton, zero_vadd, subset_rfl]\n    apply convolution_integrand_bound_right_of_le_of_subset _ _ _ this\n    · intro y\n      exact hε _ _ (((le_max_left _ _).trans_lt hx).trans_le δε)\n    · rw [mem_ball_iff_norm]\n      exact (le_max_right _ _).trans_lt hx\n  have I5 : Integrable bound μ := by\n    rw [integrable_indicator_iff U_open.measurableSet]\n    exact (hU.norm.const_mul _).mul_const _\n  have I6 : ∀ᵐ a : G ∂μ, ∀ x : P × G, dist x q₀ < δ →\n      HasFDerivAt (fun x : P × G => L (f a) (g x.1 (x.2 - a)))\n        ((L (f a)).comp (g' (x.fst, x.snd - a))) x := by\n    filter_upwards with a x hx\n    apply (L _).hasFDerivAt.comp x\n    have N : s ×ˢ univ ∈ 𝓝 (x.1, x.2 - a) := by\n      apply A'\n      apply h₀ε\n      rw [Prod.dist_eq] at hx\n      exact lt_of_lt_of_le (lt_of_le_of_lt (le_max_left _ _) hx) δε\n    have Z := ((hg.differentiableOn le_rfl).differentiableAt N).hasFDerivAt\n    have Z' :\n        HasFDerivAt (fun x : P × G => (x.1, x.2 - a)) (ContinuousLinearMap.id 𝕜 (P × G)) x := by\n      have : (fun x : P × G => (x.1, x.2 - a)) = _root_.id - fun x => (0, a) := by\n        ext x <;> simp only [Pi.sub_apply, _root_.id, Prod.fst_sub, sub_zero, Prod.snd_sub]\n      rw [this]\n      exact (hasFDerivAt_id x).sub_const (0, a)\n    exact Z.comp x Z'\n  exact hasFDerivAt_integral_of_dominated_of_fderiv_le δpos I1 I2 I3 I4 I5 I6\n\n"}
{"name":"MeasureTheory.contDiffOn_convolution_right_with_param_aux","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nE : Type uE\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : RCLike 𝕜\ninst✝¹¹ : NormedSpace 𝕜 E\nG E' F P : Type uP\ninst✝¹⁰ : NormedAddCommGroup E'\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace Real F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : MeasurableSpace G\nμ : MeasureTheory.Measure G\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : BorelSpace G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup P\ninst✝ : NormedSpace 𝕜 P\nf : G → E\nn : ENat\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ng : P → G → E'\ns : Set P\nk : Set G\nhs : IsOpen s\nhk : IsCompact k\nhgs : ∀ (p : P) (x : G), Membership.mem s p → Not (Membership.mem k x) → Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : ContDiffOn 𝕜 (↑n) (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\n⊢ ContDiffOn 𝕜 (↑n) (fun q => MeasureTheory.convolution f (g q.1) L μ q.2) (SProd.sprod s Set.univ)","decl":"/-- The convolution `f * g` is `C^n` when `f` is locally integrable and `g` is `C^n` and compactly\nsupported. Version where `g` depends on an additional parameter in an open subset `s` of a\nparameter space `P` (and the compact support `k` is independent of the parameter in `s`).\nIn this version, all the types belong to the same universe (to get an induction working in the\nproof). Use instead `contDiffOn_convolution_right_with_param`, which removes this restriction. -/\ntheorem contDiffOn_convolution_right_with_param_aux {G : Type uP} {E' : Type uP} {F : Type uP}\n    {P : Type uP} [NormedAddCommGroup E'] [NormedAddCommGroup F] [NormedSpace 𝕜 E']\n    [NormedSpace ℝ F] [NormedSpace 𝕜 F] [MeasurableSpace G]\n    {μ : Measure G}\n    [NormedAddCommGroup G] [BorelSpace G] [NormedSpace 𝕜 G] [NormedAddCommGroup P] [NormedSpace 𝕜 P]\n    {f : G → E} {n : ℕ∞} (L : E →L[𝕜] E' →L[𝕜] F) {g : P → G → E'} {s : Set P} {k : Set G}\n    (hs : IsOpen s) (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)\n    (hf : LocallyIntegrable f μ) (hg : ContDiffOn 𝕜 n (↿g) (s ×ˢ univ)) :\n    ContDiffOn 𝕜 n (fun q : P × G => (f ⋆[L, μ] g q.1) q.2) (s ×ˢ univ) := by\n  /- We have a formula for the derivation of `f * g`, which is of the same form, thanks to\n    `hasFDerivAt_convolution_right_with_param`. Therefore, we can prove the result by induction on\n    `n` (but for this we need the spaces at the different steps of the induction to live in the same\n    universe, which is why we make the assumption in the lemma that all the relevant spaces\n    come from the same universe). -/\n  induction n using ENat.nat_induction generalizing g E' F with\n  | h0 =>\n    rw [WithTop.coe_zero, contDiffOn_zero] at hg ⊢\n    exact continuousOn_convolution_right_with_param L hk hgs hf hg\n  | hsuc n ih =>\n    simp only [Nat.succ_eq_add_one, Nat.cast_add, Nat.cast_one, WithTop.coe_add,\n      WithTop.coe_natCast, WithTop.coe_one] at hg ⊢\n    let f' : P → G → P × G →L[𝕜] F := fun p a =>\n      (f ⋆[L.precompR (P × G), μ] fun x : G => fderiv 𝕜 (uncurry g) (p, x)) a\n    have A : ∀ q₀ : P × G, q₀.1 ∈ s →\n        HasFDerivAt (fun q : P × G => (f ⋆[L, μ] g q.1) q.2) (f' q₀.1 q₀.2) q₀ :=\n      hasFDerivAt_convolution_right_with_param L hs hk hgs hf hg.one_of_succ\n    rw [contDiffOn_succ_iff_fderiv_of_isOpen (hs.prod (@isOpen_univ G _))] at hg ⊢\n    refine ⟨?_, by simp, ?_⟩\n    · rintro ⟨p, x⟩ ⟨hp, -⟩\n      exact (A (p, x) hp).differentiableAt.differentiableWithinAt\n    · suffices H : ContDiffOn 𝕜 n (↿f') (s ×ˢ univ) by\n        apply H.congr\n        rintro ⟨p, x⟩ ⟨hp, -⟩\n        exact (A (p, x) hp).fderiv\n      have B : ∀ (p : P) (x : G), p ∈ s → x ∉ k → fderiv 𝕜 (uncurry g) (p, x) = 0 := by\n        intro p x hp hx\n        apply (hasFDerivAt_zero_of_eventually_const (0 : E') _).fderiv\n        have M2 : kᶜ ∈ 𝓝 x := IsOpen.mem_nhds hk.isClosed.isOpen_compl hx\n        have M1 : s ∈ 𝓝 p := hs.mem_nhds hp\n        rw [nhds_prod_eq]\n        filter_upwards [prod_mem_prod M1 M2]\n        rintro ⟨p, y⟩ ⟨hp, hy⟩\n        exact hgs p y hp hy\n      apply ih (L.precompR (P × G) :) B\n      convert hg.2.2\n  | htop ih =>\n    rw [contDiffOn_infty] at hg ⊢\n    exact fun n ↦ ih n L hgs (hg n)\n\n"}
{"name":"MeasureTheory.contDiffOn_convolution_right_with_param","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\ninst✝¹⁰ : RCLike 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace Real F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : BorelSpace G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup P\ninst✝ : NormedSpace 𝕜 P\nμ : MeasureTheory.Measure G\nf : G → E\nn : ENat\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ng : P → G → E'\ns : Set P\nk : Set G\nhs : IsOpen s\nhk : IsCompact k\nhgs : ∀ (p : P) (x : G), Membership.mem s p → Not (Membership.mem k x) → Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : ContDiffOn 𝕜 (↑n) (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\n⊢ ContDiffOn 𝕜 (↑n) (fun q => MeasureTheory.convolution f (g q.1) L μ q.2) (SProd.sprod s Set.univ)","decl":"/-- The convolution `f * g` is `C^n` when `f` is locally integrable and `g` is `C^n` and compactly\nsupported. Version where `g` depends on an additional parameter in an open subset `s` of a\nparameter space `P` (and the compact support `k` is independent of the parameter in `s`). -/\ntheorem contDiffOn_convolution_right_with_param {f : G → E} {n : ℕ∞} (L : E →L[𝕜] E' →L[𝕜] F)\n    {g : P → G → E'} {s : Set P} {k : Set G} (hs : IsOpen s) (hk : IsCompact k)\n    (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0) (hf : LocallyIntegrable f μ)\n    (hg : ContDiffOn 𝕜 n (↿g) (s ×ˢ univ)) :\n    ContDiffOn 𝕜 n (fun q : P × G => (f ⋆[L, μ] g q.1) q.2) (s ×ˢ univ) := by\n  /- The result is known when all the universes are the same, from\n    `contDiffOn_convolution_right_with_param_aux`. We reduce to this situation by pushing\n    everything through `ULift` continuous linear equivalences. -/\n  let eG : Type max uG uE' uF uP := ULift.{max uE' uF uP} G\n  borelize eG\n  let eE' : Type max uE' uG uF uP := ULift.{max uG uF uP} E'\n  let eF : Type max uF uG uE' uP := ULift.{max uG uE' uP} F\n  let eP : Type max uP uG uE' uF := ULift.{max uG uE' uF} P\n  let isoG : eG ≃L[𝕜] G := ContinuousLinearEquiv.ulift\n  let isoE' : eE' ≃L[𝕜] E' := ContinuousLinearEquiv.ulift\n  let isoF : eF ≃L[𝕜] F := ContinuousLinearEquiv.ulift\n  let isoP : eP ≃L[𝕜] P := ContinuousLinearEquiv.ulift\n  let ef := f ∘ isoG\n  let eμ : Measure eG := Measure.map isoG.symm μ\n  let eg : eP → eG → eE' := fun ep ex => isoE'.symm (g (isoP ep) (isoG ex))\n  let eL :=\n    ContinuousLinearMap.comp\n      ((ContinuousLinearEquiv.arrowCongr isoE' isoF).symm : (E' →L[𝕜] F) →L[𝕜] eE' →L[𝕜] eF) L\n  let R := fun q : eP × eG => (ef ⋆[eL, eμ] eg q.1) q.2\n  have R_contdiff : ContDiffOn 𝕜 n R ((isoP ⁻¹' s) ×ˢ univ) := by\n    have hek : IsCompact (isoG ⁻¹' k) := isoG.toHomeomorph.isClosedEmbedding.isCompact_preimage hk\n    have hes : IsOpen (isoP ⁻¹' s) := isoP.continuous.isOpen_preimage _ hs\n    refine contDiffOn_convolution_right_with_param_aux eL hes hek ?_ ?_ ?_\n    · intro p x hp hx\n      simp only [eg, (· ∘ ·), ContinuousLinearEquiv.prod_apply, LinearIsometryEquiv.coe_coe,\n        ContinuousLinearEquiv.map_eq_zero_iff]\n      exact hgs _ _ hp hx\n    · exact (locallyIntegrable_map_homeomorph isoG.symm.toHomeomorph).2 hf\n    · apply isoE'.symm.contDiff.comp_contDiffOn\n      apply hg.comp (isoP.prod isoG).contDiff.contDiffOn\n      rintro ⟨p, x⟩ ⟨hp, -⟩\n      simpa only [mem_preimage, ContinuousLinearEquiv.prod_apply, prod_mk_mem_set_prod_eq, mem_univ,\n        and_true] using hp\n  have A : ContDiffOn 𝕜 n (isoF ∘ R ∘ (isoP.prod isoG).symm) (s ×ˢ univ) := by\n    apply isoF.contDiff.comp_contDiffOn\n    apply R_contdiff.comp (ContinuousLinearEquiv.contDiff _).contDiffOn\n    rintro ⟨p, x⟩ ⟨hp, -⟩\n    simpa only [mem_preimage, mem_prod, mem_univ, and_true, ContinuousLinearEquiv.prod_symm,\n      ContinuousLinearEquiv.prod_apply, ContinuousLinearEquiv.apply_symm_apply] using hp\n  have : isoF ∘ R ∘ (isoP.prod isoG).symm = fun q : P × G => (f ⋆[L, μ] g q.1) q.2 := by\n    apply funext\n    rintro ⟨p, x⟩\n    simp only [LinearIsometryEquiv.coe_coe, (· ∘ ·), ContinuousLinearEquiv.prod_symm,\n      ContinuousLinearEquiv.prod_apply]\n    simp only [R, convolution, coe_comp', ContinuousLinearEquiv.coe_coe, (· ∘ ·)]\n    rw [IsClosedEmbedding.integral_map, ← isoF.integral_comp_comm]\n    · rfl\n    · exact isoG.symm.toHomeomorph.isClosedEmbedding\n  simp_rw [this] at A\n  exact A\n\n"}
{"name":"MeasureTheory.contDiffOn_convolution_right_with_param_comp","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\ninst✝¹⁰ : RCLike 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace Real F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : BorelSpace G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup P\ninst✝ : NormedSpace 𝕜 P\nμ : MeasureTheory.Measure G\nn : ENat\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ns : Set P\nv : P → G\nhv : ContDiffOn 𝕜 (↑n) v s\nf : G → E\ng : P → G → E'\nk : Set G\nhs : IsOpen s\nhk : IsCompact k\nhgs : ∀ (p : P) (x : G), Membership.mem s p → Not (Membership.mem k x) → Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : ContDiffOn 𝕜 (↑n) (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\n⊢ ContDiffOn 𝕜 (↑n) (fun x => MeasureTheory.convolution f (g x) L μ (v x)) s","decl":"/-- The convolution `f * g` is `C^n` when `f` is locally integrable and `g` is `C^n` and compactly\nsupported. Version where `g` depends on an additional parameter in an open subset `s` of a\nparameter space `P` (and the compact support `k` is independent of the parameter in `s`),\ngiven in terms of composition with an additional `C^n` function. -/\ntheorem contDiffOn_convolution_right_with_param_comp {n : ℕ∞} (L : E →L[𝕜] E' →L[𝕜] F) {s : Set P}\n    {v : P → G} (hv : ContDiffOn 𝕜 n v s) {f : G → E} {g : P → G → E'} {k : Set G} (hs : IsOpen s)\n    (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0) (hf : LocallyIntegrable f μ)\n    (hg : ContDiffOn 𝕜 n (↿g) (s ×ˢ univ)) : ContDiffOn 𝕜 n (fun x => (f ⋆[L, μ] g x) (v x)) s := by\n  apply (contDiffOn_convolution_right_with_param L hs hk hgs hf hg).comp (contDiffOn_id.prod hv)\n  intro x hx\n  simp only [hx, mem_preimage, prod_mk_mem_set_prod_eq, mem_univ, and_self_iff, _root_.id]\n\n"}
{"name":"MeasureTheory.contDiffOn_convolution_left_with_param","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninst✝¹⁵ : NormedAddCommGroup E\ninst✝¹⁴ : NormedAddCommGroup E'\ninst✝¹³ : NormedAddCommGroup F\ninst✝¹² : RCLike 𝕜\ninst✝¹¹ : NormedSpace 𝕜 E\ninst✝¹⁰ : NormedSpace 𝕜 E'\ninst✝⁹ : NormedSpace Real F\ninst✝⁸ : NormedSpace 𝕜 F\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : NormedAddCommGroup G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : NormedSpace 𝕜 G\ninst✝³ : NormedAddCommGroup P\ninst✝² : NormedSpace 𝕜 P\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : μ.IsNegInvariant\nL : ContinuousLinearMap (RingHom.id 𝕜) E' (ContinuousLinearMap (RingHom.id 𝕜) E F)\nf : G → E\nn : ENat\ng : P → G → E'\ns : Set P\nk : Set G\nhs : IsOpen s\nhk : IsCompact k\nhgs : ∀ (p : P) (x : G), Membership.mem s p → Not (Membership.mem k x) → Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : ContDiffOn 𝕜 (↑n) (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\n⊢ ContDiffOn 𝕜 (↑n) (fun q => MeasureTheory.convolution (g q.1) f L μ q.2) (SProd.sprod s Set.univ)","decl":"/-- The convolution `g * f` is `C^n` when `f` is locally integrable and `g` is `C^n` and compactly\nsupported. Version where `g` depends on an additional parameter in an open subset `s` of a\nparameter space `P` (and the compact support `k` is independent of the parameter in `s`). -/\ntheorem contDiffOn_convolution_left_with_param [μ.IsAddLeftInvariant] [μ.IsNegInvariant]\n    (L : E' →L[𝕜] E →L[𝕜] F) {f : G → E} {n : ℕ∞} {g : P → G → E'} {s : Set P} {k : Set G}\n    (hs : IsOpen s) (hk : IsCompact k) (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0)\n    (hf : LocallyIntegrable f μ) (hg : ContDiffOn 𝕜 n (↿g) (s ×ˢ univ)) :\n    ContDiffOn 𝕜 n (fun q : P × G => (g q.1 ⋆[L, μ] f) q.2) (s ×ˢ univ) := by\n  simpa only [convolution_flip] using contDiffOn_convolution_right_with_param L.flip hs hk hgs hf hg\n\n"}
{"name":"MeasureTheory.contDiffOn_convolution_left_with_param_comp","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\nP : Type uP\ninst✝¹⁵ : NormedAddCommGroup E\ninst✝¹⁴ : NormedAddCommGroup E'\ninst✝¹³ : NormedAddCommGroup F\ninst✝¹² : RCLike 𝕜\ninst✝¹¹ : NormedSpace 𝕜 E\ninst✝¹⁰ : NormedSpace 𝕜 E'\ninst✝⁹ : NormedSpace Real F\ninst✝⁸ : NormedSpace 𝕜 F\ninst✝⁷ : MeasurableSpace G\ninst✝⁶ : NormedAddCommGroup G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : NormedSpace 𝕜 G\ninst✝³ : NormedAddCommGroup P\ninst✝² : NormedSpace 𝕜 P\nμ : MeasureTheory.Measure G\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : μ.IsNegInvariant\nL : ContinuousLinearMap (RingHom.id 𝕜) E' (ContinuousLinearMap (RingHom.id 𝕜) E F)\ns : Set P\nn : ENat\nv : P → G\nhv : ContDiffOn 𝕜 (↑n) v s\nf : G → E\ng : P → G → E'\nk : Set G\nhs : IsOpen s\nhk : IsCompact k\nhgs : ∀ (p : P) (x : G), Membership.mem s p → Not (Membership.mem k x) → Eq (g p x) 0\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : ContDiffOn 𝕜 (↑n) (Function.HasUncurry.uncurry g) (SProd.sprod s Set.univ)\n⊢ ContDiffOn 𝕜 (↑n) (fun x => MeasureTheory.convolution (g x) f L μ (v x)) s","decl":"/-- The convolution `g * f` is `C^n` when `f` is locally integrable and `g` is `C^n` and compactly\nsupported. Version where `g` depends on an additional parameter in an open subset `s` of a\nparameter space `P` (and the compact support `k` is independent of the parameter in `s`),\ngiven in terms of composition with additional `C^n` functions. -/\ntheorem contDiffOn_convolution_left_with_param_comp [μ.IsAddLeftInvariant] [μ.IsNegInvariant]\n    (L : E' →L[𝕜] E →L[𝕜] F) {s : Set P} {n : ℕ∞} {v : P → G} (hv : ContDiffOn 𝕜 n v s) {f : G → E}\n    {g : P → G → E'} {k : Set G} (hs : IsOpen s) (hk : IsCompact k)\n    (hgs : ∀ p, ∀ x, p ∈ s → x ∉ k → g p x = 0) (hf : LocallyIntegrable f μ)\n    (hg : ContDiffOn 𝕜 n (↿g) (s ×ˢ univ)) : ContDiffOn 𝕜 n (fun x => (g x ⋆[L, μ] f) (v x)) s := by\n  apply (contDiffOn_convolution_left_with_param L hs hk hgs hf hg).comp (contDiffOn_id.prod hv)\n  intro x hx\n  simp only [hx, mem_preimage, prod_mk_mem_set_prod_eq, mem_univ, and_self_iff, _root_.id]\n\n"}
{"name":"HasCompactSupport.contDiff_convolution_right","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedAddCommGroup E'\ninst✝⁹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝⁸ : RCLike 𝕜\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedSpace 𝕜 E'\ninst✝⁵ : NormedSpace Real F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : MeasurableSpace G\ninst✝² : NormedAddCommGroup G\ninst✝¹ : BorelSpace G\ninst✝ : NormedSpace 𝕜 G\nμ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\nn : ENat\nhcg : HasCompactSupport g\nhf : MeasureTheory.LocallyIntegrable f μ\nhg : ContDiff 𝕜 (↑n) g\n⊢ ContDiff 𝕜 (↑n) (MeasureTheory.convolution f g L μ)","decl":"theorem _root_.HasCompactSupport.contDiff_convolution_right {n : ℕ∞} (hcg : HasCompactSupport g)\n    (hf : LocallyIntegrable f μ) (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n (f ⋆[L, μ] g) := by\n  rcases exists_compact_iff_hasCompactSupport.2 hcg with ⟨k, hk, h'k⟩\n  rw [← contDiffOn_univ]\n  exact contDiffOn_convolution_right_with_param_comp L contDiffOn_id isOpen_univ hk\n    (fun p x _ hx => h'k x hx) hf (hg.comp contDiff_snd).contDiffOn\n\n"}
{"name":"HasCompactSupport.contDiff_convolution_left","module":"Mathlib.Analysis.Convolution","initialProofState":"𝕜 : Type u𝕜\nG : Type uG\nE : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedAddCommGroup E'\ninst✝¹¹ : NormedAddCommGroup F\nf : G → E\ng : G → E'\ninst✝¹⁰ : RCLike 𝕜\ninst✝⁹ : NormedSpace 𝕜 E\ninst✝⁸ : NormedSpace 𝕜 E'\ninst✝⁷ : NormedSpace Real F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : MeasurableSpace G\ninst✝⁴ : NormedAddCommGroup G\ninst✝³ : BorelSpace G\ninst✝² : NormedSpace 𝕜 G\nμ : MeasureTheory.Measure G\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) E' F)\ninst✝¹ : μ.IsAddLeftInvariant\ninst✝ : μ.IsNegInvariant\nn : ENat\nhcf : HasCompactSupport f\nhf : ContDiff 𝕜 (↑n) f\nhg : MeasureTheory.LocallyIntegrable g μ\n⊢ ContDiff 𝕜 (↑n) (MeasureTheory.convolution f g L μ)","decl":"theorem _root_.HasCompactSupport.contDiff_convolution_left [μ.IsAddLeftInvariant] [μ.IsNegInvariant]\n    {n : ℕ∞} (hcf : HasCompactSupport f) (hf : ContDiff 𝕜 n f) (hg : LocallyIntegrable g μ) :\n    ContDiff 𝕜 n (f ⋆[L, μ] g) := by\n  rw [← convolution_flip]\n  exact hcf.contDiff_convolution_right L.flip hg hf\n\n"}
{"name":"MeasureTheory.posConvolution_eq_convolution_indicator","module":"Mathlib.Analysis.Convolution","initialProofState":"E : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedAddCommGroup E'\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace Real E\ninst✝² : NormedSpace Real E'\ninst✝¹ : NormedSpace Real F\nf : Real → E\ng : Real → E'\nL : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E' F)\nν : autoParam (MeasureTheory.Measure Real) _auto✝\ninst✝ : MeasureTheory.NoAtoms ν\n⊢ Eq (MeasureTheory.posConvolution f g L ν) (MeasureTheory.convolution ((Set.Ioi 0).indicator f) ((Set.Ioi 0).indicator g) L ν)","decl":"theorem posConvolution_eq_convolution_indicator (f : ℝ → E) (g : ℝ → E') (L : E →L[ℝ] E' →L[ℝ] F)\n    (ν : Measure ℝ := by volume_tac) [NoAtoms ν] :\n    posConvolution f g L ν = convolution (indicator (Ioi 0) f) (indicator (Ioi 0) g) L ν := by\n  ext1 x\n  -- Porting note: was `rw [convolution, posConvolution, indicator]`, now `rw` can't do it\n  -- the `rw` unfolded only one `indicator`; now we unfold it everywhere, so we need to adjust\n  -- `rw`s below\n  unfold convolution posConvolution indicator; simp only\n  split_ifs with h\n  · rw [intervalIntegral.integral_of_le (le_of_lt h), integral_Ioc_eq_integral_Ioo, ←\n      integral_indicator (measurableSet_Ioo : MeasurableSet (Ioo 0 x))]\n    congr 1 with t : 1\n    have : t ≤ 0 ∨ t ∈ Ioo 0 x ∨ x ≤ t := by\n      rcases le_or_lt t 0 with (h | h)\n      · exact Or.inl h\n      · rcases lt_or_le t x with (h' | h')\n        exacts [Or.inr (Or.inl ⟨h, h'⟩), Or.inr (Or.inr h')]\n    rcases this with (ht | ht | ht)\n    · -- Porting note: was\n      -- rw [indicator_of_not_mem (not_mem_Ioo_of_le ht), indicator_of_not_mem (not_mem_Ioi.mpr ht),\n      --   ContinuousLinearMap.map_zero, ContinuousLinearMap.zero_apply]\n      rw [indicator_of_not_mem (not_mem_Ioo_of_le ht), if_neg (not_mem_Ioi.mpr ht),\n        ContinuousLinearMap.map_zero, ContinuousLinearMap.zero_apply]\n    · -- Porting note: was\n      -- rw [indicator_of_mem ht, indicator_of_mem (mem_Ioi.mpr ht.1),\n      --     indicator_of_mem (mem_Ioi.mpr <| sub_pos.mpr ht.2)]\n      rw [indicator_of_mem ht, if_pos (mem_Ioi.mpr ht.1),\n        if_pos (mem_Ioi.mpr <| sub_pos.mpr ht.2)]\n    · -- Porting note: was\n      -- rw [indicator_of_not_mem (not_mem_Ioo_of_ge ht),\n      --     indicator_of_not_mem (not_mem_Ioi.mpr (sub_nonpos_of_le ht)),\n      --     ContinuousLinearMap.map_zero]\n      rw [indicator_of_not_mem (not_mem_Ioo_of_ge ht),\n        if_neg (not_mem_Ioi.mpr (sub_nonpos_of_le ht)), ContinuousLinearMap.map_zero]\n  · convert (integral_zero ℝ F).symm with t\n    by_cases ht : 0 < t\n    · -- Porting note: was\n      -- rw [indicator_of_not_mem (_ : x - t ∉ Ioi 0), ContinuousLinearMap.map_zero]\n      rw [if_neg (_ : x - t ∉ Ioi 0), ContinuousLinearMap.map_zero]\n      rw [not_mem_Ioi] at h ⊢\n      exact sub_nonpos.mpr (h.trans ht.le)\n    · -- Porting note: was\n      -- rw [indicator_of_not_mem (mem_Ioi.not.mpr ht), ContinuousLinearMap.map_zero,\n      --  ContinuousLinearMap.zero_apply]\n      rw [if_neg (mem_Ioi.not.mpr ht), ContinuousLinearMap.map_zero,\n        ContinuousLinearMap.zero_apply]\n\n"}
{"name":"MeasureTheory.integrable_posConvolution","module":"Mathlib.Analysis.Convolution","initialProofState":"E : Type uE\nE' : Type uE'\nF : Type uF\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedAddCommGroup E'\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : NormedSpace Real E'\ninst✝⁴ : NormedSpace Real F\nf : Real → E\ng : Real → E'\nμ ν : MeasureTheory.Measure Real\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : μ.IsAddRightInvariant\ninst✝ : MeasureTheory.NoAtoms ν\nhf : MeasureTheory.IntegrableOn f (Set.Ioi 0) ν\nhg : MeasureTheory.IntegrableOn g (Set.Ioi 0) μ\nL : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E' F)\n⊢ MeasureTheory.Integrable (MeasureTheory.posConvolution f g L ν) μ","decl":"theorem integrable_posConvolution {f : ℝ → E} {g : ℝ → E'} {μ ν : Measure ℝ} [SFinite μ]\n    [SFinite ν] [IsAddRightInvariant μ] [NoAtoms ν] (hf : IntegrableOn f (Ioi 0) ν)\n    (hg : IntegrableOn g (Ioi 0) μ) (L : E →L[ℝ] E' →L[ℝ] F) :\n    Integrable (posConvolution f g L ν) μ := by\n  rw [← integrable_indicator_iff (measurableSet_Ioi : MeasurableSet (Ioi (0 : ℝ)))] at hf hg\n  rw [posConvolution_eq_convolution_indicator f g L ν]\n  exact (hf.convolution_integrand L hg).integral_prod_left\n\n"}
{"name":"MeasureTheory.integral_posConvolution","module":"Mathlib.Analysis.Convolution","initialProofState":"E : Type uE\nE' : Type uE'\nF : Type uF\ninst✝¹² : NormedAddCommGroup E\ninst✝¹¹ : NormedAddCommGroup E'\ninst✝¹⁰ : NormedAddCommGroup F\ninst✝⁹ : NormedSpace Real E\ninst✝⁸ : NormedSpace Real E'\ninst✝⁷ : NormedSpace Real F\ninst✝⁶ : CompleteSpace E\ninst✝⁵ : CompleteSpace E'\ninst✝⁴ : CompleteSpace F\nμ ν : MeasureTheory.Measure Real\ninst✝³ : MeasureTheory.SFinite μ\ninst✝² : MeasureTheory.SFinite ν\ninst✝¹ : μ.IsAddRightInvariant\ninst✝ : MeasureTheory.NoAtoms ν\nf : Real → E\ng : Real → E'\nhf : MeasureTheory.IntegrableOn f (Set.Ioi 0) ν\nhg : MeasureTheory.IntegrableOn g (Set.Ioi 0) μ\nL : ContinuousLinearMap (RingHom.id Real) E (ContinuousLinearMap (RingHom.id Real) E' F)\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Ioi 0)) fun x => intervalIntegral (fun t => (L (f t)) (g (HSub.hSub x t))) 0 x ν) ((L (MeasureTheory.integral (ν.restrict (Set.Ioi 0)) fun x => f x)) (MeasureTheory.integral (μ.restrict (Set.Ioi 0)) fun x => g x))","decl":"/-- The integral over `Ioi 0` of a forward convolution of two functions is equal to the product\nof their integrals over this set. (Compare `integral_convolution` for the two-sided convolution.) -/\ntheorem integral_posConvolution [CompleteSpace E] [CompleteSpace E'] [CompleteSpace F]\n    {μ ν : Measure ℝ}\n    [SFinite μ] [SFinite ν] [IsAddRightInvariant μ] [NoAtoms ν] {f : ℝ → E} {g : ℝ → E'}\n    (hf : IntegrableOn f (Ioi 0) ν) (hg : IntegrableOn g (Ioi 0) μ) (L : E →L[ℝ] E' →L[ℝ] F) :\n    ∫ x : ℝ in Ioi 0, ∫ t : ℝ in (0)..x, L (f t) (g (x - t)) ∂ν ∂μ =\n      L (∫ x : ℝ in Ioi 0, f x ∂ν) (∫ x : ℝ in Ioi 0, g x ∂μ) := by\n  rw [← integrable_indicator_iff measurableSet_Ioi] at hf hg\n  simp_rw [← integral_indicator measurableSet_Ioi]\n  convert integral_convolution L hf hg using 4 with x\n  apply posConvolution_eq_convolution_indicator\n\n"}
