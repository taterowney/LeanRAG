{"name":"Subgroup.leftTransversals.diff_mul_diff","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝² : Group G\nH : Subgroup G\nA : Type u_2\ninst✝¹ : CommGroup A\nϕ : MonoidHom (Subtype fun x => Membership.mem H x) A\nR S T : H.LeftTransversal\ninst✝ : H.FiniteIndex\n⊢ Eq (HMul.hMul (Subgroup.leftTransversals.diff ϕ R S) (Subgroup.leftTransversals.diff ϕ S T)) (Subgroup.leftTransversals.diff ϕ R T)","decl":"@[to_additive]\ntheorem diff_mul_diff : diff ϕ R S * diff ϕ S T = diff ϕ R T :=\n  prod_mul_distrib.symm.trans\n    (prod_congr rfl fun q _ =>\n      (ϕ.map_mul _ _).symm.trans\n        (congr_arg ϕ\n          (by simp_rw [Subtype.ext_iff, coe_mul, mul_assoc, mul_inv_cancel_left])))\n\n"}
{"name":"AddSubgroup.leftTransversals.diff_add_diff","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nH : AddSubgroup G\nA : Type u_2\ninst✝¹ : AddCommGroup A\nϕ : AddMonoidHom (Subtype fun x => Membership.mem H x) A\nR S T : H.LeftTransversal\ninst✝ : H.FiniteIndex\n⊢ Eq (HAdd.hAdd (AddSubgroup.leftTransversals.diff ϕ R S) (AddSubgroup.leftTransversals.diff ϕ S T)) (AddSubgroup.leftTransversals.diff ϕ R T)","decl":"@[to_additive]\ntheorem diff_mul_diff : diff ϕ R S * diff ϕ S T = diff ϕ R T :=\n  prod_mul_distrib.symm.trans\n    (prod_congr rfl fun q _ =>\n      (ϕ.map_mul _ _).symm.trans\n        (congr_arg ϕ\n          (by simp_rw [Subtype.ext_iff, coe_mul, mul_assoc, mul_inv_cancel_left])))\n\n"}
{"name":"Subgroup.leftTransversals.diff_self","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝² : Group G\nH : Subgroup G\nA : Type u_2\ninst✝¹ : CommGroup A\nϕ : MonoidHom (Subtype fun x => Membership.mem H x) A\nT : H.LeftTransversal\ninst✝ : H.FiniteIndex\n⊢ Eq (Subgroup.leftTransversals.diff ϕ T T) 1","decl":"@[to_additive]\ntheorem diff_self : diff ϕ T T = 1 :=\n  mul_right_eq_self.mp (diff_mul_diff ϕ T T T)\n\n"}
{"name":"AddSubgroup.leftTransversals.diff_self","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nH : AddSubgroup G\nA : Type u_2\ninst✝¹ : AddCommGroup A\nϕ : AddMonoidHom (Subtype fun x => Membership.mem H x) A\nT : H.LeftTransversal\ninst✝ : H.FiniteIndex\n⊢ Eq (AddSubgroup.leftTransversals.diff ϕ T T) 0","decl":"@[to_additive]\ntheorem diff_self : diff ϕ T T = 1 :=\n  mul_right_eq_self.mp (diff_mul_diff ϕ T T T)\n\n"}
{"name":"Subgroup.leftTransversals.diff_inv","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝² : Group G\nH : Subgroup G\nA : Type u_2\ninst✝¹ : CommGroup A\nϕ : MonoidHom (Subtype fun x => Membership.mem H x) A\nS T : H.LeftTransversal\ninst✝ : H.FiniteIndex\n⊢ Eq (Inv.inv (Subgroup.leftTransversals.diff ϕ S T)) (Subgroup.leftTransversals.diff ϕ T S)","decl":"@[to_additive]\ntheorem diff_inv : (diff ϕ S T)⁻¹ = diff ϕ T S :=\n  inv_eq_of_mul_eq_one_right <| (diff_mul_diff ϕ S T S).trans <| diff_self ϕ S\n\n"}
{"name":"AddSubgroup.leftTransversals.diff_neg","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nH : AddSubgroup G\nA : Type u_2\ninst✝¹ : AddCommGroup A\nϕ : AddMonoidHom (Subtype fun x => Membership.mem H x) A\nS T : H.LeftTransversal\ninst✝ : H.FiniteIndex\n⊢ Eq (Neg.neg (AddSubgroup.leftTransversals.diff ϕ S T)) (AddSubgroup.leftTransversals.diff ϕ T S)","decl":"@[to_additive]\ntheorem diff_inv : (diff ϕ S T)⁻¹ = diff ϕ T S :=\n  inv_eq_of_mul_eq_one_right <| (diff_mul_diff ϕ S T S).trans <| diff_self ϕ S\n\n"}
{"name":"Subgroup.leftTransversals.smul_diff_smul","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝² : Group G\nH : Subgroup G\nA : Type u_2\ninst✝¹ : CommGroup A\nϕ : MonoidHom (Subtype fun x => Membership.mem H x) A\nS T : H.LeftTransversal\ninst✝ : H.FiniteIndex\ng : G\n⊢ Eq (Subgroup.leftTransversals.diff ϕ (HSMul.hSMul g S) (HSMul.hSMul g T)) (Subgroup.leftTransversals.diff ϕ S T)","decl":"@[to_additive]\ntheorem smul_diff_smul (g : G) : diff ϕ (g • S) (g • T) = diff ϕ S T :=\n  let _ := H.fintypeQuotientOfFiniteIndex\n  Fintype.prod_equiv (MulAction.toPerm g).symm _ _ fun _ ↦ by\n    simp only [smul_apply_eq_smul_apply_inv_smul, smul_eq_mul, mul_inv_rev, mul_assoc,\n      inv_mul_cancel_left, toPerm_symm_apply]\n\n"}
{"name":"AddSubgroup.leftTransversals.vadd_diff_vadd","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nH : AddSubgroup G\nA : Type u_2\ninst✝¹ : AddCommGroup A\nϕ : AddMonoidHom (Subtype fun x => Membership.mem H x) A\nS T : H.LeftTransversal\ninst✝ : H.FiniteIndex\ng : G\n⊢ Eq (AddSubgroup.leftTransversals.diff ϕ (HVAdd.hVAdd g S) (HVAdd.hVAdd g T)) (AddSubgroup.leftTransversals.diff ϕ S T)","decl":"@[to_additive]\ntheorem smul_diff_smul (g : G) : diff ϕ (g • S) (g • T) = diff ϕ S T :=\n  let _ := H.fintypeQuotientOfFiniteIndex\n  Fintype.prod_equiv (MulAction.toPerm g).symm _ _ fun _ ↦ by\n    simp only [smul_apply_eq_smul_apply_inv_smul, smul_eq_mul, mul_inv_rev, mul_assoc,\n      inv_mul_cancel_left, toPerm_symm_apply]\n\n"}
{"name":"Subgroup.transferFunction_apply","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\nq : HasQuotient.Quotient G H\n⊢ Eq (H.transferFunction g q) (HMul.hMul (HPow.hPow g ((H.quotientEquivSigmaZMod g) q).snd.cast) (Quotient.out (Quotient.out ((H.quotientEquivSigmaZMod g) q).fst)))","decl":"lemma transferFunction_apply (q : G ⧸ H) :\n    transferFunction H g q =\n      g ^ (cast (quotientEquivSigmaZMod H g q).2 : ℤ) *\n        (quotientEquivSigmaZMod H g q).1.out.out := rfl\n\n"}
{"name":"Subgroup.coe_transferFunction","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\nq : HasQuotient.Quotient G H\n⊢ Eq (↑(H.transferFunction g q)) q","decl":"lemma coe_transferFunction (q : G ⧸ H) : ↑(transferFunction H g q) = q := by\n  rw [transferFunction_apply, ← smul_eq_mul, Quotient.coe_smul_out,\n    ← quotientEquivSigmaZMod_symm_apply, Sigma.eta, symm_apply_apply]\n\n"}
{"name":"Subgroup.mem_transferSet","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\nq : HasQuotient.Quotient G H\n⊢ Membership.mem (H.transferSet g) (H.transferFunction g q)","decl":"lemma mem_transferSet (q : G ⧸ H) : transferFunction H g q ∈ transferSet H g := ⟨q, rfl⟩\n\n"}
{"name":"Subgroup.transferTransversal_apply","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\nq : HasQuotient.Quotient G H\n⊢ Eq (↑(⋯.leftQuotientEquiv q)) (H.transferFunction g q)","decl":"lemma transferTransversal_apply (q : G ⧸ H) :\n    ↑((transferTransversal H g).2.leftQuotientEquiv q) = transferFunction H g q :=\n  IsComplement.leftQuotientEquiv_apply (coe_transferFunction g) q\n\n"}
{"name":"Subgroup.transferTransversal_apply'","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\nq : MulAction.orbitRel.Quotient (Subtype fun x => Membership.mem (Subgroup.zpowers g) x) (HasQuotient.Quotient G H)\nk : ZMod (Function.minimalPeriod (fun x => HSMul.hSMul g x) (Quotient.out q))\n⊢ Eq (↑(⋯.leftQuotientEquiv (HSMul.hSMul (HPow.hPow g k.cast) (Quotient.out q)))) (HMul.hMul (HPow.hPow g k.cast) (Quotient.out (Quotient.out q)))","decl":"lemma transferTransversal_apply' (q : orbitRel.Quotient (zpowers g) (G ⧸ H))\n    (k : ZMod (minimalPeriod (g • ·) q.out)) :\n    ↑((transferTransversal H g).2.leftQuotientEquiv (g ^ (cast k : ℤ) • q.out)) =\n      g ^ (cast k : ℤ) * q.out.out := by\n  rw [transferTransversal_apply, transferFunction_apply, ← quotientEquivSigmaZMod_symm_apply,\n    apply_symm_apply]\n\n"}
{"name":"Subgroup.transferTransversal_apply''","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\nq : MulAction.orbitRel.Quotient (Subtype fun x => Membership.mem (Subgroup.zpowers g) x) (HasQuotient.Quotient G H)\nk : ZMod (Function.minimalPeriod (fun x => HSMul.hSMul g x) (Quotient.out q))\n⊢ Eq (↑(⋯.leftQuotientEquiv (HSMul.hSMul (HPow.hPow g k.cast) (Quotient.out q)))) (ite (Eq k 0) (HMul.hMul (HPow.hPow g (Function.minimalPeriod (fun x => HSMul.hSMul g x) (Quotient.out q))) (Quotient.out (Quotient.out q))) (HMul.hMul (HPow.hPow g k.cast) (Quotient.out (Quotient.out q))))","decl":"lemma transferTransversal_apply'' (q : orbitRel.Quotient (zpowers g) (G ⧸ H))\n    (k : ZMod (minimalPeriod (g • ·) q.out)) :\n    ↑((g • transferTransversal H g).2.leftQuotientEquiv (g ^ (cast k : ℤ) • q.out)) =\n      if k = 0 then g ^ minimalPeriod (g • ·) q.out * q.out.out\n      else g ^ (cast k : ℤ) * q.out.out := by\n  rw [smul_apply_eq_smul_apply_inv_smul, transferTransversal_apply, transferFunction_apply, ←\n    mul_smul, ← zpow_neg_one, ← zpow_add, quotientEquivSigmaZMod_apply, smul_eq_mul, ← mul_assoc,\n    ← zpow_one_add, Int.cast_add, Int.cast_neg, Int.cast_one, intCast_cast, cast_id', id, ←\n    sub_eq_neg_add, cast_sub_one, add_sub_cancel]\n  by_cases hk : k = 0\n  · rw [if_pos hk, if_pos hk, zpow_natCast]\n  · rw [if_neg hk, if_neg hk]\n\n"}
{"name":"MonoidHom.transfer_def","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝² : Group G\nH : Subgroup G\nA : Type u_2\ninst✝¹ : CommGroup A\nϕ : MonoidHom (Subtype fun x => Membership.mem H x) A\nT : H.LeftTransversal\ninst✝ : H.FiniteIndex\ng : G\n⊢ Eq (ϕ.transfer g) (Subgroup.leftTransversals.diff ϕ T (HSMul.hSMul g T))","decl":"@[to_additive]\ntheorem transfer_def [FiniteIndex H] (g : G) : transfer ϕ g = diff ϕ T (g • T) := by\n  rw [transfer, ← diff_mul_diff, ← smul_diff_smul, mul_comm, diff_mul_diff] <;> rfl\n\n"}
{"name":"AddMonoidHom.transfer_def","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nH : AddSubgroup G\nA : Type u_2\ninst✝¹ : AddCommGroup A\nϕ : AddMonoidHom (Subtype fun x => Membership.mem H x) A\nT : H.LeftTransversal\ninst✝ : H.FiniteIndex\ng : G\n⊢ Eq (ϕ.transfer g) (AddSubgroup.leftTransversals.diff ϕ T (HVAdd.hVAdd g T))","decl":"@[to_additive]\ntheorem transfer_def [FiniteIndex H] (g : G) : transfer ϕ g = diff ϕ T (g • T) := by\n  rw [transfer, ← diff_mul_diff, ← smul_diff_smul, mul_comm, diff_mul_diff] <;> rfl\n\n"}
{"name":"MonoidHom.transfer_eq_prod_quotient_orbitRel_zpowers_quot","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝³ : Group G\nH : Subgroup G\nA : Type u_2\ninst✝² : CommGroup A\nϕ : MonoidHom (Subtype fun x => Membership.mem H x) A\ninst✝¹ : H.FiniteIndex\ng : G\ninst✝ : Fintype (Quotient (MulAction.orbitRel (Subtype fun x => Membership.mem (Subgroup.zpowers g) x) (HasQuotient.Quotient G H)))\n⊢ Eq (ϕ.transfer g) (Finset.univ.prod fun q => ϕ ⟨HMul.hMul (HMul.hMul (Inv.inv (Quotient.out q.out)) (HPow.hPow g (Function.minimalPeriod (fun x => HSMul.hSMul g x) q.out))) (Quotient.out q.out), ⋯⟩)","decl":"/-- Explicit computation of the transfer homomorphism. -/\ntheorem transfer_eq_prod_quotient_orbitRel_zpowers_quot [FiniteIndex H] (g : G)\n    [Fintype (Quotient (orbitRel (zpowers g) (G ⧸ H)))] :\n    transfer ϕ g =\n      ∏ q : Quotient (orbitRel (zpowers g) (G ⧸ H)),\n        ϕ\n          ⟨q.out.out⁻¹ * g ^ Function.minimalPeriod (g • ·) q.out * q.out.out,\n            QuotientGroup.out_conj_pow_minimalPeriod_mem H g q.out⟩ := by\n  classical\n    letI := H.fintypeQuotientOfFiniteIndex\n    calc\n      transfer ϕ g = ∏ q : G ⧸ H, _ := transfer_def ϕ (transferTransversal H g) g\n      _ = _ := ((quotientEquivSigmaZMod H g).symm.prod_comp _).symm\n      _ = _ := Finset.prod_sigma _ _ _\n      _ = _ := by\n        refine Fintype.prod_congr _ _ (fun q => ?_)\n        simp only [quotientEquivSigmaZMod_symm_apply, transferTransversal_apply',\n          transferTransversal_apply'']\n        rw [Fintype.prod_eq_single (0 : ZMod (Function.minimalPeriod (g • ·) q.out)) _]\n        · simp only [if_pos, ZMod.cast_zero, zpow_zero, one_mul, mul_assoc]\n        · intro k hk\n          simp only [if_neg hk, inv_mul_cancel]\n          exact map_one ϕ\n\n"}
{"name":"MonoidHom.transfer_eq_pow_aux","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\nkey : ∀ (k : Nat) (g₀ : G), Membership.mem H (HMul.hMul (HMul.hMul (Inv.inv g₀) (HPow.hPow g k)) g₀) → Eq (HMul.hMul (HMul.hMul (Inv.inv g₀) (HPow.hPow g k)) g₀) (HPow.hPow g k)\n⊢ Membership.mem H (HPow.hPow g H.index)","decl":"/-- Auxiliary lemma in order to state `transfer_eq_pow`. -/\ntheorem transfer_eq_pow_aux (g : G)\n    (key : ∀ (k : ℕ) (g₀ : G), g₀⁻¹ * g ^ k * g₀ ∈ H → g₀⁻¹ * g ^ k * g₀ = g ^ k) :\n    g ^ H.index ∈ H := by\n  by_cases hH : H.index = 0\n  · rw [hH, pow_zero]\n    exact H.one_mem\n  letI := fintypeOfIndexNeZero hH\n  classical\n    replace key : ∀ (k : ℕ) (g₀ : G), g₀⁻¹ * g ^ k * g₀ ∈ H → g ^ k ∈ H := fun k g₀ hk =>\n      (congr_arg (· ∈ H) (key k g₀ hk)).mp hk\n    replace key : ∀ q : G ⧸ H, g ^ Function.minimalPeriod (g • ·) q ∈ H := fun q =>\n      key (Function.minimalPeriod (g • ·) q) q.out\n        (QuotientGroup.out_conj_pow_minimalPeriod_mem H g q)\n    let f : Quotient (orbitRel (zpowers g) (G ⧸ H)) → zpowers g := fun q =>\n      (⟨g, mem_zpowers g⟩ : zpowers g) ^ Function.minimalPeriod (g • ·) q.out\n    have hf : ∀ q, f q ∈ H.subgroupOf (zpowers g) := fun q => key q.out\n    replace key :=\n      Subgroup.prod_mem (H.subgroupOf (zpowers g)) fun q (_ : q ∈ Finset.univ) => hf q\n    simpa only [f, minimalPeriod_eq_card, Finset.prod_pow_eq_pow_sum, Fintype.card_sigma,\n      Fintype.card_congr (selfEquivSigmaOrbits (zpowers g) (G ⧸ H)), index_eq_card,\n      Nat.card_eq_fintype_card] using key\n\n"}
{"name":"MonoidHom.transfer_eq_pow","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝² : Group G\nH : Subgroup G\nA : Type u_2\ninst✝¹ : CommGroup A\nϕ : MonoidHom (Subtype fun x => Membership.mem H x) A\ninst✝ : H.FiniteIndex\ng : G\nkey : ∀ (k : Nat) (g₀ : G), Membership.mem H (HMul.hMul (HMul.hMul (Inv.inv g₀) (HPow.hPow g k)) g₀) → Eq (HMul.hMul (HMul.hMul (Inv.inv g₀) (HPow.hPow g k)) g₀) (HPow.hPow g k)\n⊢ Eq (ϕ.transfer g) (ϕ ⟨HPow.hPow g H.index, ⋯⟩)","decl":"theorem transfer_eq_pow [FiniteIndex H] (g : G)\n    (key : ∀ (k : ℕ) (g₀ : G), g₀⁻¹ * g ^ k * g₀ ∈ H → g₀⁻¹ * g ^ k * g₀ = g ^ k) :\n    transfer ϕ g = ϕ ⟨g ^ H.index, transfer_eq_pow_aux g key⟩ := by\n  classical\n    letI := H.fintypeQuotientOfFiniteIndex\n    change ∀ (k g₀) (hk : g₀⁻¹ * g ^ k * g₀ ∈ H), ↑(⟨g₀⁻¹ * g ^ k * g₀, hk⟩ : H) = g ^ k at key\n    rw [transfer_eq_prod_quotient_orbitRel_zpowers_quot, ← Finset.prod_to_list]\n    refine (List.prod_map_hom _ _ _).trans ?_ -- Porting note: this used to be in the `rw`\n    refine congrArg ϕ (Subtype.coe_injective ?_)\n    simp only -- Porting note: added `simp only`\n    rw [H.coe_mk, ← (zpowers g).coe_mk g (mem_zpowers g), ← (zpowers g).coe_pow, index_eq_card,\n      Nat.card_eq_fintype_card, Fintype.card_congr (selfEquivSigmaOrbits (zpowers g) (G ⧸ H)),\n      Fintype.card_sigma, ← Finset.prod_pow_eq_pow_sum, ← Finset.prod_to_list]\n    simp only [Subgroup.val_list_prod, List.map_map, ← minimalPeriod_eq_card]\n    congr\n    funext\n    apply key\n\n"}
{"name":"MonoidHom.transfer_center_eq_pow","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : (Subgroup.center G).FiniteIndex\ng : G\n⊢ Eq ((MonoidHom.id (Subtype fun x => Membership.mem (Subgroup.center G) x)).transfer g) ⟨HPow.hPow g (Subgroup.center G).index, ⋯⟩","decl":"theorem transfer_center_eq_pow [FiniteIndex (center G)] (g : G) :\n    transfer (MonoidHom.id (center G)) g = ⟨g ^ (center G).index, (center G).pow_index_mem g⟩ :=\n  transfer_eq_pow (id (center G)) g fun k _ hk => by rw [← mul_right_inj, ← hk.comm,\n    mul_inv_cancel_right]\n\n"}
{"name":"MonoidHom.transferCenterPow_apply","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : (Subgroup.center G).FiniteIndex\ng : G\n⊢ Eq (↑((MonoidHom.transferCenterPow G) g)) (HPow.hPow g (Subgroup.center G).index)","decl":"@[simp]\ntheorem transferCenterPow_apply [FiniteIndex (center G)] (g : G) :\n    ↑(transferCenterPow G g) = g ^ (center G).index :=\n  rfl\n\n"}
{"name":"MonoidHom.transferSylow_eq_pow_aux","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝² : Group G\np : Nat\nP : Sylow p G\nhP : LE.le (↑P).normalizer (Subgroup.centralizer ↑P)\ninst✝¹ : Fact (Nat.Prime p)\ninst✝ : Finite (Sylow p G)\ng : G\nhg : Membership.mem P g\nk : Nat\ng₀ : G\nh : Membership.mem P (HMul.hMul (HMul.hMul (Inv.inv g₀) (HPow.hPow g k)) g₀)\n⊢ Eq (HMul.hMul (HMul.hMul (Inv.inv g₀) (HPow.hPow g k)) g₀) (HPow.hPow g k)","decl":"/-- Auxiliary lemma in order to state `transferSylow_eq_pow`. -/\ntheorem transferSylow_eq_pow_aux (g : G) (hg : g ∈ P) (k : ℕ) (g₀ : G)\n    (h : g₀⁻¹ * g ^ k * g₀ ∈ P) : g₀⁻¹ * g ^ k * g₀ = g ^ k := by\n  haveI : (P : Subgroup G).IsCommutative :=\n    ⟨⟨fun a b => Subtype.ext (hP (le_normalizer b.2) a a.2)⟩⟩\n  replace hg := (P : Subgroup G).pow_mem hg k\n  obtain ⟨n, hn, h⟩ := P.conj_eq_normalizer_conj_of_mem (g ^ k) g₀ hg h\n  exact h.trans (Commute.inv_mul_cancel (hP hn (g ^ k) hg).symm)\n\n"}
{"name":"MonoidHom.transferSylow_eq_pow","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝³ : Group G\np : Nat\nP : Sylow p G\nhP : LE.le (↑P).normalizer (Subgroup.centralizer ↑P)\ninst✝² : Fact (Nat.Prime p)\ninst✝¹ : Finite (Sylow p G)\ninst✝ : (↑P).FiniteIndex\ng : G\nhg : Membership.mem P g\n⊢ Eq ((MonoidHom.transferSylow P hP) g) ⟨HPow.hPow g (↑P).index, ⋯⟩","decl":"theorem transferSylow_eq_pow (g : G) (hg : g ∈ P) :\n    transferSylow P hP g =\n      ⟨g ^ (P : Subgroup G).index, transfer_eq_pow_aux g (transferSylow_eq_pow_aux P hP g hg)⟩ :=\n  @transfer_eq_pow G _ P P (@Subgroup.IsCommutative.commGroup G _ P\n    ⟨⟨fun a b => Subtype.ext (hP (le_normalizer b.2) a a.2)⟩⟩) _ _ g\n      (transferSylow_eq_pow_aux P hP g hg) -- Porting note: apply used to do this automatically\n\n"}
{"name":"MonoidHom.transferSylow_restrict_eq_pow","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝³ : Group G\np : Nat\nP : Sylow p G\nhP : LE.le (↑P).normalizer (Subgroup.centralizer ↑P)\ninst✝² : Fact (Nat.Prime p)\ninst✝¹ : Finite (Sylow p G)\ninst✝ : (↑P).FiniteIndex\n⊢ Eq ⇑((MonoidHom.transferSylow P hP).restrict ↑P) fun x => HPow.hPow x (↑P).index","decl":"theorem transferSylow_restrict_eq_pow : ⇑((transferSylow P hP).restrict (P : Subgroup G)) =\n    (fun x : P => x ^ (P : Subgroup G).index) :=\n  funext fun g => transferSylow_eq_pow P hP g g.2\n\n"}
{"name":"MonoidHom.ker_transferSylow_isComplement'","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝³ : Group G\np : Nat\nP : Sylow p G\nhP : LE.le (↑P).normalizer (Subgroup.centralizer ↑P)\ninst✝² : Fact (Nat.Prime p)\ninst✝¹ : Finite (Sylow p G)\ninst✝ : (↑P).FiniteIndex\n⊢ (MonoidHom.transferSylow P hP).ker.IsComplement' ↑P","decl":"/-- **Burnside's normal p-complement theorem**: If `N(P) ≤ C(P)`, then `P` has a normal\ncomplement. -/\ntheorem ker_transferSylow_isComplement' : IsComplement' (transferSylow P hP).ker P := by\n  have hf : Function.Bijective ((transferSylow P hP).restrict (P : Subgroup G)) :=\n    (transferSylow_restrict_eq_pow P hP).symm ▸ (P.2.powEquiv' P.not_dvd_index).bijective\n  rw [Function.Bijective, ← range_eq_top, restrict_range] at hf\n  have := range_eq_top.mp (top_le_iff.mp (hf.2.ge.trans\n    (map_le_range (transferSylow P hP) P)))\n  rw [← (comap_injective this).eq_iff, comap_top, comap_map_eq, sup_comm, SetLike.ext'_iff,\n    normal_mul, ← ker_eq_bot_iff, ← (map_injective (P : Subgroup G).subtype_injective).eq_iff,\n    ker_restrict, subgroupOf_map_subtype, Subgroup.map_bot, coe_top] at hf\n  exact isComplement'_of_disjoint_and_mul_eq_univ (disjoint_iff.2 hf.1) hf.2\n\n"}
{"name":"MonoidHom.not_dvd_card_ker_transferSylow","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝³ : Group G\np : Nat\nP : Sylow p G\nhP : LE.le (↑P).normalizer (Subgroup.centralizer ↑P)\ninst✝² : Fact (Nat.Prime p)\ninst✝¹ : Finite (Sylow p G)\ninst✝ : (↑P).FiniteIndex\n⊢ Not (Dvd.dvd p (Nat.card (Subtype fun x => Membership.mem (MonoidHom.transferSylow P hP).ker x)))","decl":"theorem not_dvd_card_ker_transferSylow : ¬p ∣ Nat.card (transferSylow P hP).ker :=\n  (ker_transferSylow_isComplement' P hP).index_eq_card ▸ P.not_dvd_index\n\n"}
{"name":"MonoidHom.ker_transferSylow_disjoint","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_1\ninst✝³ : Group G\np : Nat\nP : Sylow p G\nhP : LE.le (↑P).normalizer (Subgroup.centralizer ↑P)\ninst✝² : Fact (Nat.Prime p)\ninst✝¹ : Finite (Sylow p G)\ninst✝ : (↑P).FiniteIndex\nQ : Subgroup G\nhQ : IsPGroup p (Subtype fun x => Membership.mem Q x)\n⊢ Disjoint (MonoidHom.transferSylow P hP).ker Q","decl":"theorem ker_transferSylow_disjoint (Q : Subgroup G) (hQ : IsPGroup p Q) :\n    Disjoint (transferSylow P hP).ker Q :=\n  disjoint_iff.mpr <|\n    card_eq_one.mp <|\n      (hQ.to_le inf_le_right).card_eq_or_dvd.resolve_right fun h =>\n        not_dvd_card_ker_transferSylow P hP <| h.trans <| card_dvd_of_le inf_le_left\n\n"}
{"name":"IsCyclic.normalizer_le_centralizer","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_3\ninst✝¹ : Group G\ninst✝ : Finite G\np : Nat\nhp : Eq (Nat.card G).minFac p\nP : Sylow p G\nhP : IsCyclic (Subtype fun x => Membership.mem (↑P) x)\n⊢ LE.le (↑P).normalizer (Subgroup.centralizer ↑P)","decl":"include hp in\ntheorem normalizer_le_centralizer (hP : IsCyclic P) : P.normalizer ≤ centralizer (P : Set G) := by\n  subst hp\n  by_cases hn : Nat.card G = 1\n  · have := (Nat.card_eq_one_iff_unique.mp hn).1\n    rw [Subsingleton.elim P.normalizer (centralizer P)]\n  have := Fact.mk (Nat.minFac_prime hn)\n  have key := card_dvd_of_injective _ (QuotientGroup.kerLift_injective P.normalizerMonoidHom)\n  rw [normalizerMonoidHom_ker, ← index, ← relindex] at key\n  refine relindex_eq_one.mp (Nat.eq_one_of_dvd_coprimes ?_ dvd_rfl key)\n  obtain ⟨k, hk⟩ := P.2.exists_card_eq\n  rcases eq_zero_or_pos k with h0 | h0\n  · rw [hP.card_mulAut, hk, h0, pow_zero, Nat.totient_one]\n    apply Nat.coprime_one_right\n  rw [hP.card_mulAut, hk, Nat.totient_prime_pow Fact.out h0]\n  refine (Nat.Coprime.pow_right _ ?_).mul_right ?_\n  · apply Nat.Coprime.coprime_dvd_left (relindex_dvd_of_le_left P.normalizer P.le_centralizer)\n    apply Nat.Coprime.coprime_dvd_left (relindex_dvd_index_of_le P.le_normalizer)\n    rw [Nat.coprime_comm, Nat.Prime.coprime_iff_not_dvd Fact.out]\n    exact P.not_dvd_index\n  · apply Nat.Coprime.coprime_dvd_left (relindex_dvd_card (centralizer P) P.normalizer)\n    apply Nat.Coprime.coprime_dvd_left (card_subgroup_dvd_card P.normalizer)\n    have h1 := Nat.gcd_dvd_left (Nat.card G) ((Nat.card G).minFac - 1)\n    have h2 := Nat.gcd_le_right (m := Nat.card G) ((Nat.card G).minFac - 1)\n      (tsub_pos_iff_lt.mpr (Nat.minFac_prime hn).one_lt)\n    contrapose! h2\n    refine Nat.sub_one_lt_of_le (Nat.card G).minFac_pos (Nat.minFac_le_of_dvd ?_ h1)\n    exact (Nat.two_le_iff _).mpr ⟨ne_zero_of_dvd_ne_zero Nat.card_pos.ne' h1, h2⟩\n\n"}
{"name":"IsCyclic.isComplement'","module":"Mathlib.GroupTheory.Transfer","initialProofState":"G : Type u_3\ninst✝¹ : Group G\ninst✝ : Finite G\np : Nat\nhp : Eq (Nat.card G).minFac p\nP : Sylow p G\nhP : IsCyclic (Subtype fun x => Membership.mem (↑P) x)\n⊢ (MonoidHom.transferSylow P ⋯).ker.IsComplement' ↑P","decl":"include hp in\n/-- A cyclic Sylow subgroup for the smallest prime has a normal complement. -/\ntheorem isComplement' (hP : IsCyclic P) :\n    (MonoidHom.transferSylow P (hP.normalizer_le_centralizer hp)).ker.IsComplement' P := by\n  subst hp\n  by_cases hn : Nat.card G = 1\n  · have := (Nat.card_eq_one_iff_unique.mp hn).1\n    rw [Subsingleton.elim (MonoidHom.transferSylow P (hP.normalizer_le_centralizer rfl)).ker ⊥,\n      Subsingleton.elim P.1 ⊤]\n    exact isComplement'_bot_top\n  have := Fact.mk (Nat.minFac_prime hn)\n  exact MonoidHom.ker_transferSylow_isComplement' P (hP.normalizer_le_centralizer rfl)\n\n"}
