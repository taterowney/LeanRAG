{"name":"ContinuousLinearMap.IsPositive.isSelfAdjoint","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : T.IsPositive\nâŠ¢ IsSelfAdjoint T","decl":"theorem IsPositive.isSelfAdjoint {T : E â†’L[ğ•œ] E} (hT : IsPositive T) : IsSelfAdjoint T :=\n  hT.1\n\n"}
{"name":"ContinuousLinearMap.IsPositive.inner_nonneg_left","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : T.IsPositive\nx : E\nâŠ¢ LE.le 0 (RCLike.re (Inner.inner (T x) x))","decl":"theorem IsPositive.inner_nonneg_left {T : E â†’L[ğ•œ] E} (hT : IsPositive T) (x : E) :\n    0 â‰¤ re âŸªT x, xâŸ« :=\n  hT.2 x\n\n"}
{"name":"ContinuousLinearMap.IsPositive.inner_nonneg_right","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : T.IsPositive\nx : E\nâŠ¢ LE.le 0 (RCLike.re (Inner.inner x (T x)))","decl":"theorem IsPositive.inner_nonneg_right {T : E â†’L[ğ•œ] E} (hT : IsPositive T) (x : E) :\n    0 â‰¤ re âŸªx, T xâŸ« := by rw [inner_re_symm]; exact hT.inner_nonneg_left x\n\n"}
{"name":"ContinuousLinearMap.isPositive_zero","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nâŠ¢ ContinuousLinearMap.IsPositive 0","decl":"theorem isPositive_zero : IsPositive (0 : E â†’L[ğ•œ] E) := by\n  refine âŸ¨.zero _, fun x => ?_âŸ©\n  change 0 â‰¤ re âŸª_, _âŸ«\n  rw [zero_apply, inner_zero_left, ZeroHomClass.map_zero]\n\n"}
{"name":"ContinuousLinearMap.isPositive_one","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nâŠ¢ ContinuousLinearMap.IsPositive 1","decl":"theorem isPositive_one : IsPositive (1 : E â†’L[ğ•œ] E) :=\n  âŸ¨.one _, fun _ => inner_self_nonnegâŸ©\n\n"}
{"name":"ContinuousLinearMap.IsPositive.add","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nT S : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : T.IsPositive\nhS : S.IsPositive\nâŠ¢ (HAdd.hAdd T S).IsPositive","decl":"theorem IsPositive.add {T S : E â†’L[ğ•œ] E} (hT : T.IsPositive) (hS : S.IsPositive) :\n    (T + S).IsPositive := by\n  refine âŸ¨hT.isSelfAdjoint.add hS.isSelfAdjoint, fun x => ?_âŸ©\n  rw [reApplyInnerSelf, add_apply, inner_add_left, map_add]\n  exact add_nonneg (hT.inner_nonneg_left x) (hS.inner_nonneg_left x)\n\n"}
{"name":"ContinuousLinearMap.IsPositive.conj_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : T.IsPositive\nS : ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ (S.comp (T.comp (ContinuousLinearMap.adjoint S))).IsPositive","decl":"theorem IsPositive.conj_adjoint {T : E â†’L[ğ•œ] E} (hT : T.IsPositive) (S : E â†’L[ğ•œ] F) :\n    (S âˆ˜L T âˆ˜L Sâ€ ).IsPositive := by\n  refine âŸ¨hT.isSelfAdjoint.conj_adjoint S, fun x => ?_âŸ©\n  rw [reApplyInnerSelf, comp_apply, â† adjoint_inner_right]\n  exact hT.inner_nonneg_left _\n\n"}
{"name":"ContinuousLinearMap.IsPositive.adjoint_conj","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : T.IsPositive\nS : ContinuousLinearMap (RingHom.id ğ•œ) F E\nâŠ¢ ((ContinuousLinearMap.adjoint S).comp (T.comp S)).IsPositive","decl":"theorem IsPositive.adjoint_conj {T : E â†’L[ğ•œ] E} (hT : T.IsPositive) (S : F â†’L[ğ•œ] E) :\n    (Sâ€  âˆ˜L T âˆ˜L S).IsPositive := by\n  convert hT.conj_adjoint (Sâ€ )\n  rw [adjoint_adjoint]\n\n"}
{"name":"ContinuousLinearMap.IsPositive.conj_orthogonalProjection","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace E\nU : Submodule ğ•œ E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : T.IsPositive\ninstâœ : CompleteSpace (Subtype fun x => Membership.mem U x)\nâŠ¢ (U.subtypeL.comp ((orthogonalProjection U).comp (T.comp (U.subtypeL.comp (orthogonalProjection U))))).IsPositive","decl":"theorem IsPositive.conj_orthogonalProjection (U : Submodule ğ•œ E) {T : E â†’L[ğ•œ] E} (hT : T.IsPositive)\n    [CompleteSpace U] :\n    (U.subtypeL âˆ˜L\n        orthogonalProjection U âˆ˜L T âˆ˜L U.subtypeL âˆ˜L orthogonalProjection U).IsPositive := by\n  have := hT.conj_adjoint (U.subtypeL âˆ˜L orthogonalProjection U)\n  rwa [(orthogonalProjection_isSelfAdjoint U).adjoint_eq] at this\n\n"}
{"name":"ContinuousLinearMap.IsPositive.orthogonalProjection_comp","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhT : T.IsPositive\nU : Submodule ğ•œ E\ninstâœ : CompleteSpace (Subtype fun x => Membership.mem U x)\nâŠ¢ ((orthogonalProjection U).comp (T.comp U.subtypeL)).IsPositive","decl":"theorem IsPositive.orthogonalProjection_comp {T : E â†’L[ğ•œ] E} (hT : T.IsPositive) (U : Submodule ğ•œ E)\n    [CompleteSpace U] : (orthogonalProjection U âˆ˜L T âˆ˜L U.subtypeL).IsPositive := by\n  have := hT.conj_adjoint (orthogonalProjection U : E â†’L[ğ•œ] U)\n  rwa [U.adjoint_orthogonalProjection] at this\n\n"}
{"name":"ContinuousLinearMap.antilipschitz_of_forall_le_inner_map","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nH : Type u_4\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : InnerProductSpace ğ•œ H\nf : ContinuousLinearMap (RingHom.id ğ•œ) H H\nc : NNReal\nhc : LT.lt 0 c\nh : âˆ€ (x : H), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) 2) â†‘c) (Norm.norm (Inner.inner (f x) x))\nâŠ¢ AntilipschitzWith (Inv.inv c) â‡‘f","decl":"lemma antilipschitz_of_forall_le_inner_map {H : Type*} [NormedAddCommGroup H]\n    [InnerProductSpace ğ•œ H] (f : H â†’L[ğ•œ] H) {c : â„â‰¥0} (hc : 0 < c)\n    (h : âˆ€ x, â€–xâ€– ^ 2 * c â‰¤ â€–âŸªf x, xâŸ«_ğ•œâ€–) : AntilipschitzWith câ»Â¹ f := by\n  refine f.antilipschitz_of_bound (K := câ»Â¹) fun x â†¦ ?_\n  rw [NNReal.coe_inv, inv_mul_eq_div, le_div_iffâ‚€ (by exact_mod_cast hc)]\n  simp_rw [sq, mul_assoc] at h\n  by_cases hx0 : x = 0\n  Â· simp [hx0]\n  Â· apply (map_le_map_iff <| OrderIso.mulLeftâ‚€ â€–xâ€– (norm_pos_iff.mpr hx0)).mp\n    exact (h x).trans <| (norm_inner_le_norm _ _).trans <| (mul_comm _ _).le\n\n"}
{"name":"ContinuousLinearMap.isUnit_of_forall_le_norm_inner_map","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nf : ContinuousLinearMap (RingHom.id ğ•œ) E E\nc : NNReal\nhc : LT.lt 0 c\nh : âˆ€ (x : E), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) 2) â†‘c) (Norm.norm (Inner.inner (f x) x))\nâŠ¢ IsUnit f","decl":"lemma isUnit_of_forall_le_norm_inner_map (f : E â†’L[ğ•œ] E) {c : â„â‰¥0} (hc : 0 < c)\n    (h : âˆ€ x, â€–xâ€– ^ 2 * c â‰¤ â€–âŸªf x, xâŸ«_ğ•œâ€–) : IsUnit f := by\n  rw [isUnit_iff_bijective, bijective_iff_dense_range_and_antilipschitz]\n  have h_anti : AntilipschitzWith câ»Â¹ f := antilipschitz_of_forall_le_inner_map f hc h\n  refine âŸ¨?_, âŸ¨_, h_antiâŸ©âŸ©\n  have _inst := h_anti.completeSpace_range_clm\n  rw [Submodule.topologicalClosure_eq_top_iff, Submodule.eq_bot_iff]\n  intro x hx\n  have : â€–xâ€– ^ 2 * c = 0 := le_antisymm (by simpa only [hx (f x) âŸ¨x, rflâŸ©, norm_zero] using h x)\n    (by positivity)\n  aesop\n\n"}
{"name":"ContinuousLinearMap.isPositive_iff_complex","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"E' : Type u_4\ninstâœÂ² : NormedAddCommGroup E'\ninstâœÂ¹ : InnerProductSpace Complex E'\ninstâœ : CompleteSpace E'\nT : ContinuousLinearMap (RingHom.id Complex) E' E'\nâŠ¢ Iff T.IsPositive (âˆ€ (x : E'), And (Eq (â†‘(RCLike.re (Inner.inner (T x) x))) (Inner.inner (T x) x)) (LE.le 0 (RCLike.re (Inner.inner (T x) x))))","decl":"theorem isPositive_iff_complex (T : E' â†’L[â„‚] E') :\n    IsPositive T â†” âˆ€ x, (re âŸªT x, xâŸ«_â„‚ : â„‚) = âŸªT x, xâŸ«_â„‚ âˆ§ 0 â‰¤ re âŸªT x, xâŸ«_â„‚ := by\n  simp_rw [IsPositive, forall_and, isSelfAdjoint_iff_isSymmetric,\n    LinearMap.isSymmetric_iff_inner_map_self_real, conj_eq_iff_re]\n  rfl\n\n"}
{"name":"ContinuousLinearMap.le_def","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nf g : ContinuousLinearMap (RingHom.id ğ•œ) E E\nâŠ¢ Iff (LE.le f g) (HSub.hSub g f).IsPositive","decl":"lemma le_def (f g : E â†’L[ğ•œ] E) : f â‰¤ g â†” (g - f).IsPositive := Iff.rfl\n\n"}
{"name":"ContinuousLinearMap.nonneg_iff_isPositive","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nf : ContinuousLinearMap (RingHom.id ğ•œ) E E\nâŠ¢ Iff (LE.le 0 f) f.IsPositive","decl":"lemma nonneg_iff_isPositive (f : E â†’L[ğ•œ] E) : 0 â‰¤ f â†” f.IsPositive := by\n  simpa using le_def 0 f\n\n"}
