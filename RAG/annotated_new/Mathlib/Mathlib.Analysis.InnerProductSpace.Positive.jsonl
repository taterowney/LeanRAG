{"name":"ContinuousLinearMap.IsPositive.isSelfAdjoint","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : T.IsPositive\n⊢ IsSelfAdjoint T","decl":"theorem IsPositive.isSelfAdjoint {T : E →L[𝕜] E} (hT : IsPositive T) : IsSelfAdjoint T :=\n  hT.1\n\n"}
{"name":"ContinuousLinearMap.IsPositive.inner_nonneg_left","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : T.IsPositive\nx : E\n⊢ LE.le 0 (RCLike.re (Inner.inner (T x) x))","decl":"theorem IsPositive.inner_nonneg_left {T : E →L[𝕜] E} (hT : IsPositive T) (x : E) :\n    0 ≤ re ⟪T x, x⟫ :=\n  hT.2 x\n\n"}
{"name":"ContinuousLinearMap.IsPositive.inner_nonneg_right","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : T.IsPositive\nx : E\n⊢ LE.le 0 (RCLike.re (Inner.inner x (T x)))","decl":"theorem IsPositive.inner_nonneg_right {T : E →L[𝕜] E} (hT : IsPositive T) (x : E) :\n    0 ≤ re ⟪x, T x⟫ := by rw [inner_re_symm]; exact hT.inner_nonneg_left x\n\n"}
{"name":"ContinuousLinearMap.isPositive_zero","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\n⊢ ContinuousLinearMap.IsPositive 0","decl":"theorem isPositive_zero : IsPositive (0 : E →L[𝕜] E) := by\n  refine ⟨.zero _, fun x => ?_⟩\n  change 0 ≤ re ⟪_, _⟫\n  rw [zero_apply, inner_zero_left, ZeroHomClass.map_zero]\n\n"}
{"name":"ContinuousLinearMap.isPositive_one","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\n⊢ ContinuousLinearMap.IsPositive 1","decl":"theorem isPositive_one : IsPositive (1 : E →L[𝕜] E) :=\n  ⟨.one _, fun _ => inner_self_nonneg⟩\n\n"}
{"name":"ContinuousLinearMap.IsPositive.add","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nT S : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : T.IsPositive\nhS : S.IsPositive\n⊢ (HAdd.hAdd T S).IsPositive","decl":"theorem IsPositive.add {T S : E →L[𝕜] E} (hT : T.IsPositive) (hS : S.IsPositive) :\n    (T + S).IsPositive := by\n  refine ⟨hT.isSelfAdjoint.add hS.isSelfAdjoint, fun x => ?_⟩\n  rw [reApplyInnerSelf, add_apply, inner_add_left, map_add]\n  exact add_nonneg (hT.inner_nonneg_left x) (hS.inner_nonneg_left x)\n\n"}
{"name":"ContinuousLinearMap.IsPositive.conj_adjoint","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : T.IsPositive\nS : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ (S.comp (T.comp (ContinuousLinearMap.adjoint S))).IsPositive","decl":"theorem IsPositive.conj_adjoint {T : E →L[𝕜] E} (hT : T.IsPositive) (S : E →L[𝕜] F) :\n    (S ∘L T ∘L S†).IsPositive := by\n  refine ⟨hT.isSelfAdjoint.conj_adjoint S, fun x => ?_⟩\n  rw [reApplyInnerSelf, comp_apply, ← adjoint_inner_right]\n  exact hT.inner_nonneg_left _\n\n"}
{"name":"ContinuousLinearMap.IsPositive.adjoint_conj","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : T.IsPositive\nS : ContinuousLinearMap (RingHom.id 𝕜) F E\n⊢ ((ContinuousLinearMap.adjoint S).comp (T.comp S)).IsPositive","decl":"theorem IsPositive.adjoint_conj {T : E →L[𝕜] E} (hT : T.IsPositive) (S : F →L[𝕜] E) :\n    (S† ∘L T ∘L S).IsPositive := by\n  convert hT.conj_adjoint (S†)\n  rw [adjoint_adjoint]\n\n"}
{"name":"ContinuousLinearMap.IsPositive.conj_orthogonalProjection","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : CompleteSpace E\nU : Submodule 𝕜 E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : T.IsPositive\ninst✝ : CompleteSpace (Subtype fun x => Membership.mem U x)\n⊢ (U.subtypeL.comp ((orthogonalProjection U).comp (T.comp (U.subtypeL.comp (orthogonalProjection U))))).IsPositive","decl":"theorem IsPositive.conj_orthogonalProjection (U : Submodule 𝕜 E) {T : E →L[𝕜] E} (hT : T.IsPositive)\n    [CompleteSpace U] :\n    (U.subtypeL ∘L\n        orthogonalProjection U ∘L T ∘L U.subtypeL ∘L orthogonalProjection U).IsPositive := by\n  have := hT.conj_adjoint (U.subtypeL ∘L orthogonalProjection U)\n  rwa [(orthogonalProjection_isSelfAdjoint U).adjoint_eq] at this\n\n"}
{"name":"ContinuousLinearMap.IsPositive.orthogonalProjection_comp","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : CompleteSpace E\nT : ContinuousLinearMap (RingHom.id 𝕜) E E\nhT : T.IsPositive\nU : Submodule 𝕜 E\ninst✝ : CompleteSpace (Subtype fun x => Membership.mem U x)\n⊢ ((orthogonalProjection U).comp (T.comp U.subtypeL)).IsPositive","decl":"theorem IsPositive.orthogonalProjection_comp {T : E →L[𝕜] E} (hT : T.IsPositive) (U : Submodule 𝕜 E)\n    [CompleteSpace U] : (orthogonalProjection U ∘L T ∘L U.subtypeL).IsPositive := by\n  have := hT.conj_adjoint (orthogonalProjection U : E →L[𝕜] U)\n  rwa [U.adjoint_orthogonalProjection] at this\n\n"}
{"name":"ContinuousLinearMap.antilipschitz_of_forall_le_inner_map","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nH : Type u_4\ninst✝¹ : NormedAddCommGroup H\ninst✝ : InnerProductSpace 𝕜 H\nf : ContinuousLinearMap (RingHom.id 𝕜) H H\nc : NNReal\nhc : LT.lt 0 c\nh : ∀ (x : H), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) 2) ↑c) (Norm.norm (Inner.inner (f x) x))\n⊢ AntilipschitzWith (Inv.inv c) ⇑f","decl":"lemma antilipschitz_of_forall_le_inner_map {H : Type*} [NormedAddCommGroup H]\n    [InnerProductSpace 𝕜 H] (f : H →L[𝕜] H) {c : ℝ≥0} (hc : 0 < c)\n    (h : ∀ x, ‖x‖ ^ 2 * c ≤ ‖⟪f x, x⟫_𝕜‖) : AntilipschitzWith c⁻¹ f := by\n  refine f.antilipschitz_of_bound (K := c⁻¹) fun x ↦ ?_\n  rw [NNReal.coe_inv, inv_mul_eq_div, le_div_iff₀ (by exact_mod_cast hc)]\n  simp_rw [sq, mul_assoc] at h\n  by_cases hx0 : x = 0\n  · simp [hx0]\n  · apply (map_le_map_iff <| OrderIso.mulLeft₀ ‖x‖ (norm_pos_iff.mpr hx0)).mp\n    exact (h x).trans <| (norm_inner_le_norm _ _).trans <| (mul_comm _ _).le\n\n"}
{"name":"ContinuousLinearMap.isUnit_of_forall_le_norm_inner_map","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nf : ContinuousLinearMap (RingHom.id 𝕜) E E\nc : NNReal\nhc : LT.lt 0 c\nh : ∀ (x : E), LE.le (HMul.hMul (HPow.hPow (Norm.norm x) 2) ↑c) (Norm.norm (Inner.inner (f x) x))\n⊢ IsUnit f","decl":"lemma isUnit_of_forall_le_norm_inner_map (f : E →L[𝕜] E) {c : ℝ≥0} (hc : 0 < c)\n    (h : ∀ x, ‖x‖ ^ 2 * c ≤ ‖⟪f x, x⟫_𝕜‖) : IsUnit f := by\n  rw [isUnit_iff_bijective, bijective_iff_dense_range_and_antilipschitz]\n  have h_anti : AntilipschitzWith c⁻¹ f := antilipschitz_of_forall_le_inner_map f hc h\n  refine ⟨?_, ⟨_, h_anti⟩⟩\n  have _inst := h_anti.completeSpace_range_clm\n  rw [Submodule.topologicalClosure_eq_top_iff, Submodule.eq_bot_iff]\n  intro x hx\n  have : ‖x‖ ^ 2 * c = 0 := le_antisymm (by simpa only [hx (f x) ⟨x, rfl⟩, norm_zero] using h x)\n    (by positivity)\n  aesop\n\n"}
{"name":"ContinuousLinearMap.isPositive_iff_complex","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"E' : Type u_4\ninst✝² : NormedAddCommGroup E'\ninst✝¹ : InnerProductSpace Complex E'\ninst✝ : CompleteSpace E'\nT : ContinuousLinearMap (RingHom.id Complex) E' E'\n⊢ Iff T.IsPositive (∀ (x : E'), And (Eq (↑(RCLike.re (Inner.inner (T x) x))) (Inner.inner (T x) x)) (LE.le 0 (RCLike.re (Inner.inner (T x) x))))","decl":"theorem isPositive_iff_complex (T : E' →L[ℂ] E') :\n    IsPositive T ↔ ∀ x, (re ⟪T x, x⟫_ℂ : ℂ) = ⟪T x, x⟫_ℂ ∧ 0 ≤ re ⟪T x, x⟫_ℂ := by\n  simp_rw [IsPositive, forall_and, isSelfAdjoint_iff_isSymmetric,\n    LinearMap.isSymmetric_iff_inner_map_self_real, conj_eq_iff_re]\n  rfl\n\n"}
{"name":"ContinuousLinearMap.le_def","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nf g : ContinuousLinearMap (RingHom.id 𝕜) E E\n⊢ Iff (LE.le f g) (HSub.hSub g f).IsPositive","decl":"lemma le_def (f g : E →L[𝕜] E) : f ≤ g ↔ (g - f).IsPositive := Iff.rfl\n\n"}
{"name":"ContinuousLinearMap.nonneg_iff_isPositive","module":"Mathlib.Analysis.InnerProductSpace.Positive","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nf : ContinuousLinearMap (RingHom.id 𝕜) E E\n⊢ Iff (LE.le 0 f) f.IsPositive","decl":"lemma nonneg_iff_isPositive (f : E →L[𝕜] E) : 0 ≤ f ↔ f.IsPositive := by\n  simpa using le_def 0 f\n\n"}
