{"name":"UniformEquiv.mk.inj","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\ntoEquiv✝ : Equiv α β\nuniformContinuous_toFun✝ : UniformContinuous toEquiv✝.toFun\nuniformContinuous_invFun✝ : UniformContinuous toEquiv✝.invFun\ntoEquiv : Equiv α β\nuniformContinuous_toFun : UniformContinuous toEquiv.toFun\nuniformContinuous_invFun : UniformContinuous toEquiv.invFun\nx✝ : Eq { toEquiv := toEquiv✝, uniformContinuous_toFun := uniformContinuous_toFun✝, uniformContinuous_invFun := uniformContinuous_invFun✝ } { toEquiv := toEquiv, uniformContinuous_toFun := uniformContinuous_toFun, uniformContinuous_invFun := uniformContinuous_invFun }\n⊢ Eq toEquiv✝ toEquiv","decl":"/-- Uniform isomorphism between `α` and `β` -/\nstructure UniformEquiv (α : Type*) (β : Type*) [UniformSpace α] [UniformSpace β] extends\n  α ≃ β where\n  /-- Uniform continuity of the function -/\n  uniformContinuous_toFun : UniformContinuous toFun\n  /-- Uniform continuity of the inverse -/\n  uniformContinuous_invFun : UniformContinuous invFun\n\n"}
{"name":"UniformEquiv.uniformContinuous_invFun","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nself : UniformEquiv α β\n⊢ UniformContinuous self.invFun","decl":"/-- Uniform isomorphism between `α` and `β` -/\nstructure UniformEquiv (α : Type*) (β : Type*) [UniformSpace α] [UniformSpace β] extends\n  α ≃ β where\n  /-- Uniform continuity of the function -/\n  uniformContinuous_toFun : UniformContinuous toFun\n  /-- Uniform continuity of the inverse -/\n  uniformContinuous_invFun : UniformContinuous invFun\n\n"}
{"name":"UniformEquiv.uniformContinuous_toFun","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nself : UniformEquiv α β\n⊢ UniformContinuous self.toFun","decl":"/-- Uniform isomorphism between `α` and `β` -/\nstructure UniformEquiv (α : Type*) (β : Type*) [UniformSpace α] [UniformSpace β] extends\n  α ≃ β where\n  /-- Uniform continuity of the function -/\n  uniformContinuous_toFun : UniformContinuous toFun\n  /-- Uniform continuity of the inverse -/\n  uniformContinuous_invFun : UniformContinuous invFun\n\n"}
{"name":"UniformEquiv.mk.injEq","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\ntoEquiv✝ : Equiv α β\nuniformContinuous_toFun✝ : UniformContinuous toEquiv✝.toFun\nuniformContinuous_invFun✝ : UniformContinuous toEquiv✝.invFun\ntoEquiv : Equiv α β\nuniformContinuous_toFun : UniformContinuous toEquiv.toFun\nuniformContinuous_invFun : UniformContinuous toEquiv.invFun\n⊢ Eq (Eq { toEquiv := toEquiv✝, uniformContinuous_toFun := uniformContinuous_toFun✝, uniformContinuous_invFun := uniformContinuous_invFun✝ } { toEquiv := toEquiv, uniformContinuous_toFun := uniformContinuous_toFun, uniformContinuous_invFun := uniformContinuous_invFun }) (Eq toEquiv✝ toEquiv)","decl":"/-- Uniform isomorphism between `α` and `β` -/\nstructure UniformEquiv (α : Type*) (β : Type*) [UniformSpace α] [UniformSpace β] extends\n  α ≃ β where\n  /-- Uniform continuity of the function -/\n  uniformContinuous_toFun : UniformContinuous toFun\n  /-- Uniform continuity of the inverse -/\n  uniformContinuous_invFun : UniformContinuous invFun\n\n"}
{"name":"UniformEquiv.mk.sizeOf_spec","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝³ : UniformSpace α\ninst✝² : UniformSpace β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoEquiv : Equiv α β\nuniformContinuous_toFun : UniformContinuous toEquiv.toFun\nuniformContinuous_invFun : UniformContinuous toEquiv.invFun\n⊢ Eq (SizeOf.sizeOf { toEquiv := toEquiv, uniformContinuous_toFun := uniformContinuous_toFun, uniformContinuous_invFun := uniformContinuous_invFun }) (HAdd.hAdd 1 (SizeOf.sizeOf toEquiv))","decl":"/-- Uniform isomorphism between `α` and `β` -/\nstructure UniformEquiv (α : Type*) (β : Type*) [UniformSpace α] [UniformSpace β] extends\n  α ≃ β where\n  /-- Uniform continuity of the function -/\n  uniformContinuous_toFun : UniformContinuous toFun\n  /-- Uniform continuity of the inverse -/\n  uniformContinuous_invFun : UniformContinuous invFun\n\n"}
{"name":"UniformEquiv.toEquiv_injective","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\n⊢ Function.Injective UniformEquiv.toEquiv","decl":"theorem toEquiv_injective : Function.Injective (toEquiv : α ≃ᵤ β → α ≃ β)\n  | ⟨e, h₁, h₂⟩, ⟨e', h₁', h₂'⟩, h => by simpa only [mk.injEq]\n\n"}
{"name":"UniformEquiv.uniformEquiv_mk_coe","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\na : Equiv α β\nb : UniformContinuous a.toFun\nc : UniformContinuous a.invFun\n⊢ Eq ⇑{ toEquiv := a, uniformContinuous_toFun := b, uniformContinuous_invFun := c } ⇑a","decl":"@[simp]\ntheorem uniformEquiv_mk_coe (a : Equiv α β) (b c) : (UniformEquiv.mk a b c : α → β) = a :=\n  rfl\n\n"}
{"name":"UniformEquiv.coe_toEquiv","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Eq ⇑h.toEquiv ⇑h","decl":"@[simp]\ntheorem coe_toEquiv (h : α ≃ᵤ β) : ⇑h.toEquiv = h :=\n  rfl\n\n"}
{"name":"UniformEquiv.coe_symm_toEquiv","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Eq ⇑h.symm ⇑h.symm","decl":"@[simp]\ntheorem coe_symm_toEquiv (h : α ≃ᵤ β) : ⇑h.toEquiv.symm = h.symm :=\n  rfl\n\n"}
{"name":"UniformEquiv.ext","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh h' : UniformEquiv α β\nH : ∀ (x : α), Eq (h x) (h' x)\n⊢ Eq h h'","decl":"@[ext]\ntheorem ext {h h' : α ≃ᵤ β} (H : ∀ x, h x = h' x) : h = h' :=\n  toEquiv_injective <| Equiv.ext H\n\n"}
{"name":"UniformEquiv.ext_iff","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh h' : UniformEquiv α β\n⊢ Iff (Eq h h') (∀ (x : α), Eq (h x) (h' x))","decl":"@[ext]\ntheorem ext {h h' : α ≃ᵤ β} (H : ∀ x, h x = h' x) : h = h' :=\n  toEquiv_injective <| Equiv.ext H\n\n"}
{"name":"UniformEquiv.refl_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u_4\ninst✝ : UniformSpace α\n⊢ Eq (⇑(UniformEquiv.refl α)) id","decl":"/-- Identity map as a uniform isomorphism. -/\n@[simps! (config := .asFn) apply]\nprotected def refl (α : Type*) [UniformSpace α] : α ≃ᵤ α where\n  uniformContinuous_toFun := uniformContinuous_id\n  uniformContinuous_invFun := uniformContinuous_id\n  toEquiv := Equiv.refl α\n\n"}
{"name":"UniformEquiv.trans_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\ninst✝² : UniformSpace α\ninst✝¹ : UniformSpace β\ninst✝ : UniformSpace γ\nh₁ : UniformEquiv α β\nh₂ : UniformEquiv β γ\na : α\n⊢ Eq ((h₁.trans h₂) a) (h₂ (h₁ a))","decl":"@[simp]\ntheorem trans_apply (h₁ : α ≃ᵤ β) (h₂ : β ≃ᵤ γ) (a : α) : h₁.trans h₂ a = h₂ (h₁ a) :=\n  rfl\n\n"}
{"name":"UniformEquiv.uniformEquiv_mk_coe_symm","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\na : Equiv α β\nb : UniformContinuous a.toFun\nc : UniformContinuous a.invFun\n⊢ Eq ⇑{ toEquiv := a, uniformContinuous_toFun := b, uniformContinuous_invFun := c }.symm ⇑a.symm","decl":"@[simp]\ntheorem uniformEquiv_mk_coe_symm (a : Equiv α β) (b c) :\n    ((UniformEquiv.mk a b c).symm : β → α) = a.symm :=\n  rfl\n\n"}
{"name":"UniformEquiv.refl_symm","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\ninst✝ : UniformSpace α\n⊢ Eq (UniformEquiv.refl α).symm (UniformEquiv.refl α)","decl":"@[simp]\ntheorem refl_symm : (UniformEquiv.refl α).symm = UniformEquiv.refl α :=\n  rfl\n\n"}
{"name":"UniformEquiv.uniformContinuous","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ UniformContinuous ⇑h","decl":"protected theorem uniformContinuous (h : α ≃ᵤ β) : UniformContinuous h :=\n  h.uniformContinuous_toFun\n\n"}
{"name":"UniformEquiv.continuous","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Continuous ⇑h","decl":"@[continuity]\nprotected theorem continuous (h : α ≃ᵤ β) : Continuous h :=\n  h.uniformContinuous.continuous\n\n"}
{"name":"UniformEquiv.uniformContinuous_symm","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ UniformContinuous ⇑h.symm","decl":"protected theorem uniformContinuous_symm (h : α ≃ᵤ β) : UniformContinuous h.symm :=\n  h.uniformContinuous_invFun\n\n-- otherwise `by continuity` can't prove continuity of `h.to_equiv.symm`\n"}
{"name":"UniformEquiv.continuous_symm","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Continuous ⇑h.symm","decl":"@[continuity]\nprotected theorem continuous_symm (h : α ≃ᵤ β) : Continuous h.symm :=\n  h.uniformContinuous_symm.continuous\n\n"}
{"name":"UniformEquiv.toHomeomorph_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\ne : UniformEquiv α β\n⊢ Eq ⇑e.toHomeomorph ⇑e","decl":"lemma toHomeomorph_apply (e : α ≃ᵤ β) : (e.toHomeomorph : α → β) = e := rfl\n\n"}
{"name":"UniformEquiv.toHomeomorph_symm_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\ne : UniformEquiv α β\n⊢ Eq ⇑e.toHomeomorph.symm ⇑e.symm","decl":"lemma toHomeomorph_symm_apply (e : α ≃ᵤ β) : (e.toHomeomorph.symm : β → α) = e.symm := rfl\n\n"}
{"name":"UniformEquiv.apply_symm_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\nx : β\n⊢ Eq (h (h.symm x)) x","decl":"@[simp]\ntheorem apply_symm_apply (h : α ≃ᵤ β) (x : β) : h (h.symm x) = x :=\n  h.toEquiv.apply_symm_apply x\n\n"}
{"name":"UniformEquiv.symm_apply_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\nx : α\n⊢ Eq (h.symm (h x)) x","decl":"@[simp]\ntheorem symm_apply_apply (h : α ≃ᵤ β) (x : α) : h.symm (h x) = x :=\n  h.toEquiv.symm_apply_apply x\n\n"}
{"name":"UniformEquiv.bijective","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Function.Bijective ⇑h","decl":"protected theorem bijective (h : α ≃ᵤ β) : Function.Bijective h :=\n  h.toEquiv.bijective\n\n"}
{"name":"UniformEquiv.injective","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Function.Injective ⇑h","decl":"protected theorem injective (h : α ≃ᵤ β) : Function.Injective h :=\n  h.toEquiv.injective\n\n"}
{"name":"UniformEquiv.surjective","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Function.Surjective ⇑h","decl":"protected theorem surjective (h : α ≃ᵤ β) : Function.Surjective h :=\n  h.toEquiv.surjective\n\n"}
{"name":"UniformEquiv.symm_comp_self","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Eq (Function.comp ⇑h.symm ⇑h) id","decl":"@[simp]\ntheorem symm_comp_self (h : α ≃ᵤ β) : (h.symm : β → α) ∘ h = id :=\n  funext h.symm_apply_apply\n\n"}
{"name":"UniformEquiv.self_comp_symm","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Eq (Function.comp ⇑h ⇑h.symm) id","decl":"@[simp]\ntheorem self_comp_symm (h : α ≃ᵤ β) : (h : α → β) ∘ h.symm = id :=\n  funext h.apply_symm_apply\n\n"}
{"name":"UniformEquiv.range_coe","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Eq (Set.range ⇑h) Set.univ","decl":"@[simp]\ntheorem range_coe (h : α ≃ᵤ β) : range h = univ :=\n  h.surjective.range_eq\n\n"}
{"name":"UniformEquiv.image_symm","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Eq (Set.image ⇑h.symm) (Set.preimage ⇑h)","decl":"theorem image_symm (h : α ≃ᵤ β) : image h.symm = preimage h :=\n  funext h.symm.toEquiv.image_eq_preimage\n\n"}
{"name":"UniformEquiv.preimage_symm","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Eq (Set.preimage ⇑h.symm) (Set.image ⇑h)","decl":"theorem preimage_symm (h : α ≃ᵤ β) : preimage h.symm = image h :=\n  (funext h.toEquiv.image_eq_preimage).symm\n\n"}
{"name":"UniformEquiv.image_preimage","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\ns : Set β\n⊢ Eq (Set.image (⇑h) (Set.preimage (⇑h) s)) s","decl":"@[simp]\ntheorem image_preimage (h : α ≃ᵤ β) (s : Set β) : h '' (h ⁻¹' s) = s :=\n  h.toEquiv.image_preimage s\n\n"}
{"name":"UniformEquiv.preimage_image","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\ns : Set α\n⊢ Eq (Set.preimage (⇑h) (Set.image (⇑h) s)) s","decl":"@[simp]\ntheorem preimage_image (h : α ≃ᵤ β) (s : Set α) : h ⁻¹' (h '' s) = s :=\n  h.toEquiv.preimage_image s\n\n"}
{"name":"UniformEquiv.isUniformInducing","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ IsUniformInducing ⇑h","decl":"theorem isUniformInducing (h : α ≃ᵤ β) : IsUniformInducing h :=\n  IsUniformInducing.of_comp h.uniformContinuous h.symm.uniformContinuous <| by\n    simp only [symm_comp_self, IsUniformInducing.id]\n\n"}
{"name":"UniformEquiv.uniformInducing","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ IsUniformInducing ⇑h","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing := isUniformInducing\n\n"}
{"name":"UniformEquiv.comap_eq","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Eq (UniformSpace.comap (⇑h) inst✝) inst✝¹","decl":"theorem comap_eq (h : α ≃ᵤ β) : UniformSpace.comap h ‹_› = ‹_› :=\n  h.isUniformInducing.comap_uniformSpace\n\n"}
{"name":"UniformEquiv.isUniformEmbedding","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ IsUniformEmbedding ⇑h","decl":"lemma isUniformEmbedding (h : α ≃ᵤ β) : IsUniformEmbedding h := ⟨h.isUniformInducing, h.injective⟩\n\n"}
{"name":"UniformEquiv.uniformEmbedding","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ IsUniformEmbedding ⇑h","decl":"@[deprecated (since := \"2024-10-01\")] alias uniformEmbedding := isUniformEmbedding\n\n"}
{"name":"UniformEquiv.completeSpace_iff","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\nh : UniformEquiv α β\n⊢ Iff (CompleteSpace α) (CompleteSpace β)","decl":"theorem completeSpace_iff (h : α ≃ᵤ β) : CompleteSpace α ↔ CompleteSpace β :=\n  completeSpace_congr h.isUniformEmbedding\n\n"}
{"name":"UniformEquiv.prodCongr_symm","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\nδ : Type u_3\ninst✝³ : UniformSpace α\ninst✝² : UniformSpace β\ninst✝¹ : UniformSpace γ\ninst✝ : UniformSpace δ\nh₁ : UniformEquiv α β\nh₂ : UniformEquiv γ δ\n⊢ Eq (h₁.prodCongr h₂).symm (h₁.symm.prodCongr h₂.symm)","decl":"@[simp]\ntheorem prodCongr_symm (h₁ : α ≃ᵤ β) (h₂ : γ ≃ᵤ δ) :\n    (h₁.prodCongr h₂).symm = h₁.symm.prodCongr h₂.symm :=\n  rfl\n\n"}
{"name":"UniformEquiv.coe_prodCongr","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\nδ : Type u_3\ninst✝³ : UniformSpace α\ninst✝² : UniformSpace β\ninst✝¹ : UniformSpace γ\ninst✝ : UniformSpace δ\nh₁ : UniformEquiv α β\nh₂ : UniformEquiv γ δ\n⊢ Eq (⇑(h₁.prodCongr h₂)) (Prod.map ⇑h₁ ⇑h₂)","decl":"@[simp]\ntheorem coe_prodCongr (h₁ : α ≃ᵤ β) (h₂ : γ ≃ᵤ δ) : ⇑(h₁.prodCongr h₂) = Prod.map h₁ h₂ :=\n  rfl\n\n"}
{"name":"UniformEquiv.prodComm_symm","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\n⊢ Eq (UniformEquiv.prodComm α β).symm (UniformEquiv.prodComm β α)","decl":"@[simp]\ntheorem prodComm_symm : (prodComm α β).symm = prodComm β α :=\n  rfl\n\n"}
{"name":"UniformEquiv.coe_prodComm","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\nβ : Type u_1\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\n⊢ Eq (⇑(UniformEquiv.prodComm α β)) Prod.swap","decl":"@[simp]\ntheorem coe_prodComm : ⇑(prodComm α β) = Prod.swap :=\n  rfl\n\n"}
{"name":"UniformEquiv.prodPunit_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\ninst✝ : UniformSpace α\n⊢ Eq ⇑(UniformEquiv.prodPunit α) fun p => p.1","decl":"/-- `α × {*}` is uniformly isomorphic to `α`. -/\n@[simps! (config := .asFn) apply]\ndef prodPunit : α × PUnit ≃ᵤ α where\n  toEquiv := Equiv.prodPUnit α\n  uniformContinuous_toFun := uniformContinuous_fst\n  uniformContinuous_invFun := uniformContinuous_id.prod_mk uniformContinuous_const\n\n"}
{"name":"UniformEquiv.coe_punitProd","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u\ninst✝ : UniformSpace α\n⊢ Eq (⇑(UniformEquiv.punitProd α)) Prod.snd","decl":"@[simp]\ntheorem coe_punitProd : ⇑(punitProd α) = Prod.snd :=\n  rfl\n\n"}
{"name":"UniformEquiv.piCongrLeft_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"ι : Type u_4\nι' : Type u_5\nβ : ι' → Type u_6\ninst✝ : (j : ι') → UniformSpace (β j)\ne : Equiv ι ι'\na✝ : (b : ι) → β (e.symm.symm b)\na : ι'\n⊢ Eq ((UniformEquiv.piCongrLeft e) a✝ a) ((Equiv.piCongrLeft' β e.symm).symm a✝ a)","decl":"/-- `Equiv.piCongrLeft` as a uniform isomorphism: this is the natural isomorphism\n`Π i, β (e i) ≃ᵤ Π j, β j` obtained from a bijection `ι ≃ ι'`. -/\n@[simps! apply toEquiv]\ndef piCongrLeft {ι ι' : Type*} {β : ι' → Type*} [∀ j, UniformSpace (β j)]\n    (e : ι ≃ ι') : (∀ i, β (e i)) ≃ᵤ ∀ j, β j where\n  uniformContinuous_toFun := uniformContinuous_pi.mpr <| e.forall_congr_right.mp fun i ↦ by\n    simpa only [Equiv.toFun_as_coe, Equiv.piCongrLeft_apply_apply] using\n      Pi.uniformContinuous_proj _ i\n  uniformContinuous_invFun := Pi.uniformContinuous_precomp' _ e\n  toEquiv := Equiv.piCongrLeft _ e\n\n"}
{"name":"UniformEquiv.piCongrLeft_toEquiv","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"ι : Type u_4\nι' : Type u_5\nβ : ι' → Type u_6\ninst✝ : (j : ι') → UniformSpace (β j)\ne : Equiv ι ι'\n⊢ Eq (UniformEquiv.piCongrLeft e).toEquiv (Equiv.piCongrLeft β e)","decl":"/-- `Equiv.piCongrLeft` as a uniform isomorphism: this is the natural isomorphism\n`Π i, β (e i) ≃ᵤ Π j, β j` obtained from a bijection `ι ≃ ι'`. -/\n@[simps! apply toEquiv]\ndef piCongrLeft {ι ι' : Type*} {β : ι' → Type*} [∀ j, UniformSpace (β j)]\n    (e : ι ≃ ι') : (∀ i, β (e i)) ≃ᵤ ∀ j, β j where\n  uniformContinuous_toFun := uniformContinuous_pi.mpr <| e.forall_congr_right.mp fun i ↦ by\n    simpa only [Equiv.toFun_as_coe, Equiv.piCongrLeft_apply_apply] using\n      Pi.uniformContinuous_proj _ i\n  uniformContinuous_invFun := Pi.uniformContinuous_precomp' _ e\n  toEquiv := Equiv.piCongrLeft _ e\n\n"}
{"name":"UniformEquiv.piCongrRight_toEquiv","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"ι : Type u_4\nβ₁ : ι → Type u_5\nβ₂ : ι → Type u_6\ninst✝¹ : (i : ι) → UniformSpace (β₁ i)\ninst✝ : (i : ι) → UniformSpace (β₂ i)\nF : (i : ι) → UniformEquiv (β₁ i) (β₂ i)\n⊢ Eq (UniformEquiv.piCongrRight F).toEquiv (Equiv.piCongrRight fun i => (F i).toEquiv)","decl":"/-- `Equiv.piCongrRight` as a uniform isomorphism: this is the natural isomorphism\n`Π i, β₁ i ≃ᵤ Π j, β₂ i` obtained from uniform isomorphisms `β₁ i ≃ᵤ β₂ i` for each `i`. -/\n@[simps! apply toEquiv]\ndef piCongrRight {ι : Type*} {β₁ β₂ : ι → Type*} [∀ i, UniformSpace (β₁ i)]\n    [∀ i, UniformSpace (β₂ i)] (F : ∀ i, β₁ i ≃ᵤ β₂ i) : (∀ i, β₁ i) ≃ᵤ ∀ i, β₂ i where\n  uniformContinuous_toFun := Pi.uniformContinuous_postcomp' _ fun i ↦ (F i).uniformContinuous\n  uniformContinuous_invFun := Pi.uniformContinuous_postcomp' _ fun i ↦ (F i).symm.uniformContinuous\n  toEquiv := Equiv.piCongrRight fun i => (F i).toEquiv\n\n"}
{"name":"UniformEquiv.piCongrRight_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"ι : Type u_4\nβ₁ : ι → Type u_5\nβ₂ : ι → Type u_6\ninst✝¹ : (i : ι) → UniformSpace (β₁ i)\ninst✝ : (i : ι) → UniformSpace (β₂ i)\nF : (i : ι) → UniformEquiv (β₁ i) (β₂ i)\na✝ : (i : ι) → β₁ i\ni : ι\n⊢ Eq ((UniformEquiv.piCongrRight F) a✝ i) ((F i) (a✝ i))","decl":"/-- `Equiv.piCongrRight` as a uniform isomorphism: this is the natural isomorphism\n`Π i, β₁ i ≃ᵤ Π j, β₂ i` obtained from uniform isomorphisms `β₁ i ≃ᵤ β₂ i` for each `i`. -/\n@[simps! apply toEquiv]\ndef piCongrRight {ι : Type*} {β₁ β₂ : ι → Type*} [∀ i, UniformSpace (β₁ i)]\n    [∀ i, UniformSpace (β₂ i)] (F : ∀ i, β₁ i ≃ᵤ β₂ i) : (∀ i, β₁ i) ≃ᵤ ∀ i, β₂ i where\n  uniformContinuous_toFun := Pi.uniformContinuous_postcomp' _ fun i ↦ (F i).uniformContinuous\n  uniformContinuous_invFun := Pi.uniformContinuous_postcomp' _ fun i ↦ (F i).symm.uniformContinuous\n  toEquiv := Equiv.piCongrRight fun i => (F i).toEquiv\n\n"}
{"name":"UniformEquiv.piCongrRight_symm","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"ι : Type u_4\nβ₁ : ι → Type u_5\nβ₂ : ι → Type u_6\ninst✝¹ : (i : ι) → UniformSpace (β₁ i)\ninst✝ : (i : ι) → UniformSpace (β₂ i)\nF : (i : ι) → UniformEquiv (β₁ i) (β₂ i)\n⊢ Eq (UniformEquiv.piCongrRight F).symm (UniformEquiv.piCongrRight fun i => (F i).symm)","decl":"@[simp]\ntheorem piCongrRight_symm {ι : Type*} {β₁ β₂ : ι → Type*} [∀ i, UniformSpace (β₁ i)]\n    [∀ i, UniformSpace (β₂ i)] (F : ∀ i, β₁ i ≃ᵤ β₂ i) :\n    (piCongrRight F).symm = piCongrRight fun i => (F i).symm :=\n  rfl\n\n"}
{"name":"UniformEquiv.piCongr_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"ι₁ : Type u_4\nι₂ : Type u_5\nβ₁ : ι₁ → Type u_6\nβ₂ : ι₂ → Type u_7\ninst✝¹ : (i₁ : ι₁) → UniformSpace (β₁ i₁)\ninst✝ : (i₂ : ι₂) → UniformSpace (β₂ i₂)\ne : Equiv ι₁ ι₂\nF : (i₁ : ι₁) → UniformEquiv (β₁ i₁) (β₂ (e i₁))\na✝ : (i : ι₁) → β₁ i\ni₂ : ι₂\n⊢ Eq ((UniformEquiv.piCongr e F) a✝ i₂) (Eq.rec ((F (e.symm i₂)) (a✝ (e.symm i₂))) ⋯)","decl":"/-- `Equiv.piCongr` as a uniform isomorphism: this is the natural isomorphism\n`Π i₁, β₁ i ≃ᵤ Π i₂, β₂ i₂` obtained from a bijection `ι₁ ≃ ι₂` and isomorphisms\n`β₁ i₁ ≃ᵤ β₂ (e i₁)` for each `i₁ : ι₁`. -/\n@[simps! apply toEquiv]\ndef piCongr {ι₁ ι₂ : Type*} {β₁ : ι₁ → Type*} {β₂ : ι₂ → Type*}\n    [∀ i₁, UniformSpace (β₁ i₁)] [∀ i₂, UniformSpace (β₂ i₂)]\n    (e : ι₁ ≃ ι₂) (F : ∀ i₁, β₁ i₁ ≃ᵤ β₂ (e i₁)) : (∀ i₁, β₁ i₁) ≃ᵤ ∀ i₂, β₂ i₂ :=\n  (UniformEquiv.piCongrRight F).trans (UniformEquiv.piCongrLeft e)\n\n"}
{"name":"UniformEquiv.piCongr_toEquiv","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"ι₁ : Type u_4\nι₂ : Type u_5\nβ₁ : ι₁ → Type u_6\nβ₂ : ι₂ → Type u_7\ninst✝¹ : (i₁ : ι₁) → UniformSpace (β₁ i₁)\ninst✝ : (i₂ : ι₂) → UniformSpace (β₂ i₂)\ne : Equiv ι₁ ι₂\nF : (i₁ : ι₁) → UniformEquiv (β₁ i₁) (β₂ (e i₁))\n⊢ Eq (UniformEquiv.piCongr e F).toEquiv ((Equiv.piCongrRight fun i => (F i).toEquiv).trans (Equiv.piCongrLeft β₂ e))","decl":"/-- `Equiv.piCongr` as a uniform isomorphism: this is the natural isomorphism\n`Π i₁, β₁ i ≃ᵤ Π i₂, β₂ i₂` obtained from a bijection `ι₁ ≃ ι₂` and isomorphisms\n`β₁ i₁ ≃ᵤ β₂ (e i₁)` for each `i₁ : ι₁`. -/\n@[simps! apply toEquiv]\ndef piCongr {ι₁ ι₂ : Type*} {β₁ : ι₁ → Type*} {β₂ : ι₂ → Type*}\n    [∀ i₁, UniformSpace (β₁ i₁)] [∀ i₂, UniformSpace (β₂ i₂)]\n    (e : ι₁ ≃ ι₂) (F : ∀ i₁, β₁ i₁ ≃ᵤ β₂ (e i₁)) : (∀ i₁, β₁ i₁) ≃ᵤ ∀ i₂, β₂ i₂ :=\n  (UniformEquiv.piCongrRight F).trans (UniformEquiv.piCongrLeft e)\n\n"}
{"name":"UniformEquiv.funUnique_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"ι : Type u_4\nα : Type u_5\ninst✝¹ : Unique ι\ninst✝ : UniformSpace α\n⊢ Eq ⇑(UniformEquiv.funUnique ι α) fun f => f Inhabited.default","decl":"/-- If `ι` has a unique element, then `ι → α` is uniformly isomorphic to `α`. -/\n@[simps! (config := .asFn)]\ndef funUnique (ι α : Type*) [Unique ι] [UniformSpace α] : (ι → α) ≃ᵤ α where\n  toEquiv := Equiv.funUnique ι α\n  uniformContinuous_toFun := Pi.uniformContinuous_proj _ _\n  uniformContinuous_invFun := uniformContinuous_pi.mpr fun _ => uniformContinuous_id\n\n"}
{"name":"UniformEquiv.funUnique_symm_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"ι : Type u_4\nα : Type u_5\ninst✝¹ : Unique ι\ninst✝ : UniformSpace α\n⊢ Eq (⇑(UniformEquiv.funUnique ι α).symm) uniqueElim","decl":"/-- If `ι` has a unique element, then `ι → α` is uniformly isomorphic to `α`. -/\n@[simps! (config := .asFn)]\ndef funUnique (ι α : Type*) [Unique ι] [UniformSpace α] : (ι → α) ≃ᵤ α where\n  toEquiv := Equiv.funUnique ι α\n  uniformContinuous_toFun := Pi.uniformContinuous_proj _ _\n  uniformContinuous_invFun := uniformContinuous_pi.mpr fun _ => uniformContinuous_id\n\n"}
{"name":"UniformEquiv.piFinTwo_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Fin 2 → Type u\ninst✝ : (i : Fin 2) → UniformSpace (α i)\n⊢ Eq ⇑(UniformEquiv.piFinTwo α) fun f => { fst := f 0, snd := f 1 }","decl":"/-- Uniform isomorphism between dependent functions `Π i : Fin 2, α i` and `α 0 × α 1`. -/\n@[simps! (config := .asFn)]\ndef piFinTwo (α : Fin 2 → Type u) [∀ i, UniformSpace (α i)] : (∀ i, α i) ≃ᵤ α 0 × α 1 where\n  toEquiv := piFinTwoEquiv α\n  uniformContinuous_toFun := (Pi.uniformContinuous_proj _ 0).prod_mk (Pi.uniformContinuous_proj _ 1)\n  uniformContinuous_invFun :=\n    uniformContinuous_pi.mpr <| Fin.forall_fin_two.2 ⟨uniformContinuous_fst, uniformContinuous_snd⟩\n\n"}
{"name":"UniformEquiv.piFinTwo_symm_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Fin 2 → Type u\ninst✝ : (i : Fin 2) → UniformSpace (α i)\n⊢ Eq ⇑(UniformEquiv.piFinTwo α).symm fun p => Fin.cons p.1 (Fin.cons p.2 finZeroElim)","decl":"/-- Uniform isomorphism between dependent functions `Π i : Fin 2, α i` and `α 0 × α 1`. -/\n@[simps! (config := .asFn)]\ndef piFinTwo (α : Fin 2 → Type u) [∀ i, UniformSpace (α i)] : (∀ i, α i) ≃ᵤ α 0 × α 1 where\n  toEquiv := piFinTwoEquiv α\n  uniformContinuous_toFun := (Pi.uniformContinuous_proj _ 0).prod_mk (Pi.uniformContinuous_proj _ 1)\n  uniformContinuous_invFun :=\n    uniformContinuous_pi.mpr <| Fin.forall_fin_two.2 ⟨uniformContinuous_fst, uniformContinuous_snd⟩\n\n"}
{"name":"UniformEquiv.finTwoArrow_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u_4\ninst✝ : UniformSpace α\n⊢ Eq ⇑(UniformEquiv.finTwoArrow α) fun f => { fst := f 0, snd := f 1 }","decl":"/-- Uniform isomorphism between `α² = Fin 2 → α` and `α × α`. -/\n-- Porting note: made `α` explicit\n@[simps! (config := .asFn)]\ndef finTwoArrow (α : Type*) [UniformSpace α] : (Fin 2 → α) ≃ᵤ α × α :=\n  { piFinTwo fun _ => α with toEquiv := finTwoArrowEquiv α }\n\n"}
{"name":"UniformEquiv.finTwoArrow_symm_apply","module":"Mathlib.Topology.UniformSpace.Equiv","initialProofState":"α : Type u_4\ninst✝ : UniformSpace α\n⊢ Eq ⇑(UniformEquiv.finTwoArrow α).symm fun x => Matrix.vecCons x.1 (Matrix.vecCons x.2 Matrix.vecEmpty)","decl":"/-- Uniform isomorphism between `α² = Fin 2 → α` and `α × α`. -/\n-- Porting note: made `α` explicit\n@[simps! (config := .asFn)]\ndef finTwoArrow (α : Type*) [UniformSpace α] : (Fin 2 → α) ≃ᵤ α × α :=\n  { piFinTwo fun _ => α with toEquiv := finTwoArrowEquiv α }\n\n"}
