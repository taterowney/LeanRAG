{"name":"Set.restrict_def","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nπ : α → Type u_6\ns : Set α\n⊢ Eq s.restrict fun f x => f ↑x","decl":"theorem restrict_def (s : Set α) : s.restrict (π := π) = fun f x ↦ f x := rfl\n\n"}
{"name":"Set.restrict_eq","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Eq (s.restrict f) (Function.comp f Subtype.val)","decl":"theorem restrict_eq (f : α → β) (s : Set α) : s.restrict f = f ∘ Subtype.val :=\n  rfl\n\n"}
{"name":"Set.restrict_apply","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nπ : α → Type u_6\nf : (a : α) → π a\ns : Set α\nx : ↑s\n⊢ Eq (s.restrict f x) (f ↑x)","decl":"@[simp]\ntheorem restrict_apply (f : (a : α) → π a) (s : Set α) (x : s) : s.restrict f x = f x :=\n  rfl\n\n"}
{"name":"Set.restrict_eq_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nπ : α → Type u_6\nf : (a : α) → π a\ns : Set α\ng : (a : ↑s) → π ↑a\n⊢ Iff (Eq (s.restrict f) g) (∀ (a : α) (ha : Membership.mem s a), Eq (f a) (g ⟨a, ha⟩))","decl":"theorem restrict_eq_iff {f : ∀ a, π a} {s : Set α} {g : ∀ a : s, π a} :\n    restrict s f = g ↔ ∀ (a) (ha : a ∈ s), f a = g ⟨a, ha⟩ :=\n  funext_iff.trans Subtype.forall\n\n"}
{"name":"Set.eq_restrict_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nπ : α → Type u_6\ns : Set α\nf : (a : ↑s) → π ↑a\ng : (a : α) → π a\n⊢ Iff (Eq f (s.restrict g)) (∀ (a : α) (ha : Membership.mem s a), Eq (f ⟨a, ha⟩) (g a))","decl":"theorem eq_restrict_iff {s : Set α} {f : ∀ a : s, π a} {g : ∀ a, π a} :\n    f = restrict s g ↔ ∀ (a) (ha : a ∈ s), f ⟨a, ha⟩ = g a :=\n  funext_iff.trans Subtype.forall\n\n"}
{"name":"Set.range_restrict","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Eq (Set.range (s.restrict f)) (Set.image f s)","decl":"@[simp]\ntheorem range_restrict (f : α → β) (s : Set α) : Set.range (s.restrict f) = f '' s :=\n  (range_comp _ _).trans <| congr_arg (f '' ·) Subtype.range_coe\n\n"}
{"name":"Set.image_restrict","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set α\n⊢ Eq (Set.image (s.restrict f) (Set.preimage Subtype.val t)) (Set.image f (Inter.inter t s))","decl":"theorem image_restrict (f : α → β) (s t : Set α) :\n    s.restrict f '' (Subtype.val ⁻¹' t) = f '' (t ∩ s) := by\n  rw [restrict_eq, image_comp, image_preimage_eq_inter_range, Subtype.range_coe]\n\n"}
{"name":"Set.restrict_dite","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : (x : α) → Decidable (Membership.mem s x)\nf : (a : α) → Membership.mem s a → β\ng : (a : α) → Not (Membership.mem s a) → β\n⊢ Eq (s.restrict fun a => dite (Membership.mem s a) (fun h => f a h) fun h => g a h) fun a => f ↑a ⋯","decl":"@[simp]\ntheorem restrict_dite {s : Set α} [∀ x, Decidable (x ∈ s)] (f : ∀ a ∈ s, β)\n    (g : ∀ a ∉ s, β) :\n    (s.restrict fun a => if h : a ∈ s then f a h else g a h) = (fun a : s => f a a.2) :=\n  funext fun a => dif_pos a.2\n\n"}
{"name":"Set.restrict_dite_compl","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : (x : α) → Decidable (Membership.mem s x)\nf : (a : α) → Membership.mem s a → β\ng : (a : α) → Not (Membership.mem s a) → β\n⊢ Eq ((HasCompl.compl s).restrict fun a => dite (Membership.mem s a) (fun h => f a h) fun h => g a h) fun a => g ↑a ⋯","decl":"@[simp]\ntheorem restrict_dite_compl {s : Set α} [∀ x, Decidable (x ∈ s)] (f : ∀ a ∈ s, β)\n    (g : ∀ a ∉ s, β) :\n    (sᶜ.restrict fun a => if h : a ∈ s then f a h else g a h) = (fun a : (sᶜ : Set α) => g a a.2) :=\n  funext fun a => dif_neg a.2\n\n"}
{"name":"Set.restrict_ite","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\ns : Set α\ninst✝ : (x : α) → Decidable (Membership.mem s x)\n⊢ Eq (s.restrict fun a => ite (Membership.mem s a) (f a) (g a)) (s.restrict f)","decl":"@[simp]\ntheorem restrict_ite (f g : α → β) (s : Set α) [∀ x, Decidable (x ∈ s)] :\n    (s.restrict fun a => if a ∈ s then f a else g a) = s.restrict f :=\n  restrict_dite _ _\n\n"}
{"name":"Set.restrict_ite_compl","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\ns : Set α\ninst✝ : (x : α) → Decidable (Membership.mem s x)\n⊢ Eq ((HasCompl.compl s).restrict fun a => ite (Membership.mem s a) (f a) (g a)) ((HasCompl.compl s).restrict g)","decl":"@[simp]\ntheorem restrict_ite_compl (f g : α → β) (s : Set α) [∀ x, Decidable (x ∈ s)] :\n    (sᶜ.restrict fun a => if a ∈ s then f a else g a) = sᶜ.restrict g :=\n  restrict_dite_compl _ _\n\n"}
{"name":"Set.restrict_piecewise","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\ns : Set α\ninst✝ : (x : α) → Decidable (Membership.mem s x)\n⊢ Eq (s.restrict (s.piecewise f g)) (s.restrict f)","decl":"@[simp]\ntheorem restrict_piecewise (f g : α → β) (s : Set α) [∀ x, Decidable (x ∈ s)] :\n    s.restrict (piecewise s f g) = s.restrict f :=\n  restrict_ite _ _ _\n\n"}
{"name":"Set.restrict_piecewise_compl","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\ns : Set α\ninst✝ : (x : α) → Decidable (Membership.mem s x)\n⊢ Eq ((HasCompl.compl s).restrict (s.piecewise f g)) ((HasCompl.compl s).restrict g)","decl":"@[simp]\ntheorem restrict_piecewise_compl (f g : α → β) (s : Set α) [∀ x, Decidable (x ∈ s)] :\n    sᶜ.restrict (piecewise s f g) = sᶜ.restrict g :=\n  restrict_ite_compl _ _ _\n\n"}
{"name":"Set.restrict_extend_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : α → γ\ng' : β → γ\n⊢ Eq ((Set.range f).restrict (Function.extend f g g')) fun x => g (Exists.choose ⋯)","decl":"theorem restrict_extend_range (f : α → β) (g : α → γ) (g' : β → γ) :\n    (range f).restrict (extend f g g') = fun x => g x.coe_prop.choose := by\n  classical\n  exact restrict_dite _ _\n\n"}
{"name":"Set.restrict_extend_compl_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : α → γ\ng' : β → γ\n⊢ Eq ((HasCompl.compl (Set.range f)).restrict (Function.extend f g g')) (Function.comp g' Subtype.val)","decl":"@[simp]\ntheorem restrict_extend_compl_range (f : α → β) (g : α → γ) (g' : β → γ) :\n    (range f)ᶜ.restrict (extend f g g') = g' ∘ Subtype.val := by\n  classical\n  exact restrict_dite_compl _ _\n\n"}
{"name":"Set.restrict₂_def","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nπ : α → Type u_6\ns t : Set α\nhst : HasSubset.Subset s t\n⊢ Eq (Set.restrict₂ hst) fun f x => f ⟨↑x, ⋯⟩","decl":"theorem restrict₂_def {s t : Set α} (hst : s ⊆ t) :\n    restrict₂ (π := π) hst = fun f x ↦ f ⟨x.1, hst x.2⟩ := rfl\n\n"}
{"name":"Set.restrict₂_comp_restrict","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nπ : α → Type u_6\ns t : Set α\nhst : HasSubset.Subset s t\n⊢ Eq (Function.comp (Set.restrict₂ hst) t.restrict) s.restrict","decl":"theorem restrict₂_comp_restrict {s t : Set α} (hst : s ⊆ t) :\n    (restrict₂ (π := π) hst) ∘ t.restrict = s.restrict := rfl\n\n"}
{"name":"Set.restrict₂_comp_restrict₂","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nπ : α → Type u_6\ns t u : Set α\nhst : HasSubset.Subset s t\nhtu : HasSubset.Subset t u\n⊢ Eq (Function.comp (Set.restrict₂ hst) (Set.restrict₂ htu)) (Set.restrict₂ ⋯)","decl":"theorem restrict₂_comp_restrict₂ {s t u : Set α} (hst : s ⊆ t) (htu : t ⊆ u) :\n    (restrict₂ (π := π) hst) ∘ (restrict₂ htu) = restrict₂ (hst.trans htu) := rfl\n\n"}
{"name":"Set.range_extend_subset","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : α → γ\ng' : β → γ\n⊢ HasSubset.Subset (Set.range (Function.extend f g g')) (Union.union (Set.range g) (Set.image g' (HasCompl.compl (Set.range f))))","decl":"theorem range_extend_subset (f : α → β) (g : α → γ) (g' : β → γ) :\n    range (extend f g g') ⊆ range g ∪ g' '' (range f)ᶜ := by\n  classical\n  rintro _ ⟨y, rfl⟩\n  rw [extend_def]\n  split_ifs with h\n  exacts [Or.inl (mem_range_self _), Or.inr (mem_image_of_mem _ h)]\n\n"}
{"name":"Set.range_extend","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nhf : Function.Injective f\ng : α → γ\ng' : β → γ\n⊢ Eq (Set.range (Function.extend f g g')) (Union.union (Set.range g) (Set.image g' (HasCompl.compl (Set.range f))))","decl":"theorem range_extend {f : α → β} (hf : Injective f) (g : α → γ) (g' : β → γ) :\n    range (extend f g g') = range g ∪ g' '' (range f)ᶜ := by\n  refine (range_extend_subset _ _ _).antisymm ?_\n  rintro z (⟨x, rfl⟩ | ⟨y, hy, rfl⟩)\n  exacts [⟨f x, hf.extend_apply _ _ _⟩, ⟨y, extend_apply' _ _ _ hy⟩]\n\n"}
{"name":"Set.val_codRestrict_apply","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nι : Sort u_5\nf : ι → α\ns : Set α\nh : ∀ (x : ι), Membership.mem s (f x)\nx : ι\n⊢ Eq (↑(Set.codRestrict f s h x)) (f x)","decl":"@[simp]\ntheorem val_codRestrict_apply (f : ι → α) (s : Set α) (h : ∀ x, f x ∈ s) (x : ι) :\n    (codRestrict f s h x : α) = f x :=\n  rfl\n\n"}
{"name":"Set.restrict_comp_codRestrict","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nf : ι → α\ng : α → β\nb : Set α\nh : ∀ (x : ι), Membership.mem b (f x)\n⊢ Eq (Function.comp (b.restrict g) (Set.codRestrict f b h)) (Function.comp g f)","decl":"@[simp]\ntheorem restrict_comp_codRestrict {f : ι → α} {g : α → β} {b : Set α} (h : ∀ x, f x ∈ b) :\n    b.restrict g ∘ b.codRestrict f h = g ∘ f :=\n  rfl\n\n"}
{"name":"Set.injective_codRestrict","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nι : Sort u_5\nf : ι → α\ns : Set α\nh : ∀ (x : ι), Membership.mem s (f x)\n⊢ Iff (Function.Injective (Set.codRestrict f s h)) (Function.Injective f)","decl":"@[simp]\ntheorem injective_codRestrict {f : ι → α} {s : Set α} (h : ∀ x, f x ∈ s) :\n    Injective (codRestrict f s h) ↔ Injective f := by\n  simp only [Injective, Subtype.ext_iff, val_codRestrict_apply]\n\n"}
{"name":"Function.Injective.codRestrict","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nι : Sort u_5\nf : ι → α\ns : Set α\nh : ∀ (x : ι), Membership.mem s (f x)\na✝ : Function.Injective f\n⊢ Function.Injective (Set.codRestrict f s h)","decl":"alias ⟨_, _root_.Function.Injective.codRestrict⟩ := injective_codRestrict\n\n"}
{"name":"Set.eqOn_empty","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : α → β\n⊢ Set.EqOn f₁ f₂ EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem eqOn_empty (f₁ f₂ : α → β) : EqOn f₁ f₂ ∅ := fun _ => False.elim\n\n"}
{"name":"Set.eqOn_singleton","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : α → β\na : α\n⊢ Iff (Set.EqOn f₁ f₂ (Singleton.singleton a)) (Eq (f₁ a) (f₂ a))","decl":"@[simp]\ntheorem eqOn_singleton : Set.EqOn f₁ f₂ {a} ↔ f₁ a = f₂ a := by\n  simp [Set.EqOn]\n\n"}
{"name":"Set.eqOn_univ","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : α → β\n⊢ Iff (Set.EqOn f₁ f₂ Set.univ) (Eq f₁ f₂)","decl":"@[simp]\ntheorem eqOn_univ (f₁ f₂ : α → β) : EqOn f₁ f₂ univ ↔ f₁ = f₂ := by\n  simp [EqOn, funext_iff]\n\n"}
{"name":"Set.restrict_eq_restrict_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\n⊢ Iff (Eq (s.restrict f₁) (s.restrict f₂)) (Set.EqOn f₁ f₂ s)","decl":"@[simp]\ntheorem restrict_eq_restrict_iff : restrict s f₁ = restrict s f₂ ↔ EqOn f₁ f₂ s :=\n  restrict_eq_iff\n\n"}
{"name":"Set.EqOn.symm","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\nh : Set.EqOn f₁ f₂ s\n⊢ Set.EqOn f₂ f₁ s","decl":"@[symm]\ntheorem EqOn.symm (h : EqOn f₁ f₂ s) : EqOn f₂ f₁ s := fun _ hx => (h hx).symm\n\n"}
{"name":"Set.eqOn_comm","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\n⊢ Iff (Set.EqOn f₁ f₂ s) (Set.EqOn f₂ f₁ s)","decl":"theorem eqOn_comm : EqOn f₁ f₂ s ↔ EqOn f₂ f₁ s :=\n  ⟨EqOn.symm, EqOn.symm⟩\n\n-- This can not be tagged as `@[refl]` with the current argument order.\n-- See note below at `EqOn.trans`.\n"}
{"name":"Set.eqOn_refl","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Set.EqOn f f s","decl":"theorem eqOn_refl (f : α → β) (s : Set α) : EqOn f f s := fun _ _ => rfl\n\n-- Note: this was formerly tagged with `@[trans]`, and although the `trans` attribute accepted it\n-- the `trans` tactic could not use it.\n-- An update to the trans tactic coming in https://github.com/leanprover-community/mathlib4/pull/7014 will reject this attribute.\n-- It can be restored by changing the argument order from `EqOn f₁ f₂ s` to `EqOn s f₁ f₂`.\n-- This change will be made separately: [zulip](https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Reordering.20arguments.20of.20.60Set.2EEqOn.60/near/390467581).\n"}
{"name":"Set.EqOn.trans","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ f₃ : α → β\nh₁ : Set.EqOn f₁ f₂ s\nh₂ : Set.EqOn f₂ f₃ s\n⊢ Set.EqOn f₁ f₃ s","decl":"theorem EqOn.trans (h₁ : EqOn f₁ f₂ s) (h₂ : EqOn f₂ f₃ s) : EqOn f₁ f₃ s := fun _ hx =>\n  (h₁ hx).trans (h₂ hx)\n\n"}
{"name":"Set.EqOn.image_eq","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\nheq : Set.EqOn f₁ f₂ s\n⊢ Eq (Set.image f₁ s) (Set.image f₂ s)","decl":"theorem EqOn.image_eq (heq : EqOn f₁ f₂ s) : f₁ '' s = f₂ '' s :=\n  image_congr heq\n\n"}
{"name":"Set.EqOn.image_eq_self","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ns : Set α\nf : α → α\nh : Set.EqOn f id s\n⊢ Eq (Set.image f s) s","decl":"/-- Variant of `EqOn.image_eq`, for one function being the identity. -/\ntheorem EqOn.image_eq_self {f : α → α} (h : Set.EqOn f id s) : f '' s = s := by\n  rw [h.image_eq, image_id]\n\n"}
{"name":"Set.EqOn.inter_preimage_eq","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\nheq : Set.EqOn f₁ f₂ s\nt : Set β\n⊢ Eq (Inter.inter s (Set.preimage f₁ t)) (Inter.inter s (Set.preimage f₂ t))","decl":"theorem EqOn.inter_preimage_eq (heq : EqOn f₁ f₂ s) (t : Set β) : s ∩ f₁ ⁻¹' t = s ∩ f₂ ⁻¹' t :=\n  ext fun x => and_congr_right_iff.2 fun hx => by rw [mem_preimage, mem_preimage, heq hx]\n\n"}
{"name":"Set.EqOn.mono","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nf₁ f₂ : α → β\nhs : HasSubset.Subset s₁ s₂\nhf : Set.EqOn f₁ f₂ s₂\n⊢ Set.EqOn f₁ f₂ s₁","decl":"theorem EqOn.mono (hs : s₁ ⊆ s₂) (hf : EqOn f₁ f₂ s₂) : EqOn f₁ f₂ s₁ := fun _ hx => hf (hs hx)\n\n"}
{"name":"Set.eqOn_union","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nf₁ f₂ : α → β\n⊢ Iff (Set.EqOn f₁ f₂ (Union.union s₁ s₂)) (And (Set.EqOn f₁ f₂ s₁) (Set.EqOn f₁ f₂ s₂))","decl":"@[simp]\ntheorem eqOn_union : EqOn f₁ f₂ (s₁ ∪ s₂) ↔ EqOn f₁ f₂ s₁ ∧ EqOn f₁ f₂ s₂ :=\n  forall₂_or_left\n\n"}
{"name":"Set.EqOn.union","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nf₁ f₂ : α → β\nh₁ : Set.EqOn f₁ f₂ s₁\nh₂ : Set.EqOn f₁ f₂ s₂\n⊢ Set.EqOn f₁ f₂ (Union.union s₁ s₂)","decl":"theorem EqOn.union (h₁ : EqOn f₁ f₂ s₁) (h₂ : EqOn f₁ f₂ s₂) : EqOn f₁ f₂ (s₁ ∪ s₂) :=\n  eqOn_union.2 ⟨h₁, h₂⟩\n\n"}
{"name":"Set.EqOn.comp_left","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nf₁ f₂ : α → β\ng : β → γ\nh : Set.EqOn f₁ f₂ s\n⊢ Set.EqOn (Function.comp g f₁) (Function.comp g f₂) s","decl":"theorem EqOn.comp_left (h : s.EqOn f₁ f₂) : s.EqOn (g ∘ f₁) (g ∘ f₂) := fun _ ha =>\n  congr_arg _ <| h ha\n\n"}
{"name":"Set.eqOn_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_7\nf : ι → α\ng₁ g₂ : α → β\n⊢ Iff (Set.EqOn g₁ g₂ (Set.range f)) (Eq (Function.comp g₁ f) (Function.comp g₂ f))","decl":"@[simp]\ntheorem eqOn_range {ι : Sort*} {f : ι → α} {g₁ g₂ : α → β} :\n    EqOn g₁ g₂ (range f) ↔ g₁ ∘ f = g₂ ∘ f :=\n  forall_mem_range.trans <| funext_iff.symm\n\n"}
{"name":"Set.EqOn.comp_eq","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_7\nf : ι → α\ng₁ g₂ : α → β\na✝ : Set.EqOn g₁ g₂ (Set.range f)\n⊢ Eq (Function.comp g₁ f) (Function.comp g₂ f)","decl":"alias ⟨EqOn.comp_eq, _⟩ := eqOn_range\n\n"}
{"name":"Set.MapsTo.restrict_commutes","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\nh : Set.MapsTo f s t\n⊢ Eq (Function.comp Subtype.val (Set.MapsTo.restrict f s t h)) (Function.comp f Subtype.val)","decl":"theorem MapsTo.restrict_commutes (f : α → β) (s : Set α) (t : Set β) (h : MapsTo f s t) :\n    Subtype.val ∘ h.restrict f s t = f ∘ Subtype.val :=\n  rfl\n\n"}
{"name":"Set.MapsTo.val_restrict_apply","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.MapsTo f s t\nx : ↑s\n⊢ Eq (↑(Set.MapsTo.restrict f s t h x)) (f ↑x)","decl":"@[simp]\ntheorem MapsTo.val_restrict_apply (h : MapsTo f s t) (x : s) : (h.restrict f s t x : β) = f x :=\n  rfl\n\n"}
{"name":"Set.MapsTo.coe_iterate_restrict","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ns : Set α\nf : α → α\nh : Set.MapsTo f s s\nx : ↑s\nk : Nat\n⊢ Eq (↑(Nat.iterate (Set.MapsTo.restrict f s s h) k x)) (Nat.iterate f k ↑x)","decl":"theorem MapsTo.coe_iterate_restrict {f : α → α} (h : MapsTo f s s) (x : s) (k : ℕ) :\n    h.restrict^[k] x = f^[k] x := by\n  induction k with\n  | zero => simp\n  | succ k ih => simp only [iterate_succ', comp_apply, val_restrict_apply, ih]\n\n"}
{"name":"Set.codRestrict_restrict","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : ∀ (x : ↑s), Membership.mem t (f ↑x)\n⊢ Eq (Set.codRestrict (s.restrict f) t h) (Set.MapsTo.restrict f s t ⋯)","decl":"/-- Restricting the domain and then the codomain is the same as `MapsTo.restrict`. -/\n@[simp]\ntheorem codRestrict_restrict (h : ∀ x : s, f x ∈ t) :\n    codRestrict (s.restrict f) t h = MapsTo.restrict f s t fun x hx => h ⟨x, hx⟩ :=\n  rfl\n\n"}
{"name":"Set.MapsTo.restrict_eq_codRestrict","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.MapsTo f s t\n⊢ Eq (Set.MapsTo.restrict f s t h) (Set.codRestrict (s.restrict f) t ⋯)","decl":"/-- Reverse of `Set.codRestrict_restrict`. -/\ntheorem MapsTo.restrict_eq_codRestrict (h : MapsTo f s t) :\n    h.restrict f s t = codRestrict (s.restrict f) t fun x => h x.2 :=\n  rfl\n\n"}
{"name":"Set.MapsTo.coe_restrict","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.MapsTo f s t\n⊢ Eq (Function.comp Subtype.val (Set.MapsTo.restrict f s t h)) (s.restrict f)","decl":"theorem MapsTo.coe_restrict (h : Set.MapsTo f s t) :\n    Subtype.val ∘ h.restrict f s t = s.restrict f :=\n  rfl\n\n"}
{"name":"Set.MapsTo.range_restrict","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nt : Set β\nh : Set.MapsTo f s t\n⊢ Eq (Set.range (Set.MapsTo.restrict f s t h)) (Set.preimage Subtype.val (Set.image f s))","decl":"theorem MapsTo.range_restrict (f : α → β) (s : Set α) (t : Set β) (h : MapsTo f s t) :\n    range (h.restrict f s t) = Subtype.val ⁻¹' (f '' s) :=\n  Set.range_subtype_map f h\n\n"}
{"name":"Set.mapsTo_iff_exists_map_subtype","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\n⊢ Iff (Set.MapsTo f s t) (Exists fun g => ∀ (x : ↑s), Eq (f ↑x) ↑(g x))","decl":"theorem mapsTo_iff_exists_map_subtype : MapsTo f s t ↔ ∃ g : s → t, ∀ x : s, f x = g x :=\n  ⟨fun h => ⟨h.restrict f s t, fun _ => rfl⟩, fun ⟨g, hg⟩ x hx => by\n    rw [hg ⟨x, hx⟩]\n    apply Subtype.coe_prop⟩\n\n"}
{"name":"Set.mapsTo'","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\n⊢ Iff (Set.MapsTo f s t) (HasSubset.Subset (Set.image f s) t)","decl":"theorem mapsTo' : MapsTo f s t ↔ f '' s ⊆ t :=\n  image_subset_iff.symm\n\n"}
{"name":"Set.mapsTo_prod_map_diagonal","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Set.MapsTo (Prod.map f f) (Set.diagonal α) (Set.diagonal β)","decl":"theorem mapsTo_prod_map_diagonal : MapsTo (Prod.map f f) (diagonal α) (diagonal β) :=\n  diagonal_subset_iff.2 fun _ => rfl\n\n"}
{"name":"Set.MapsTo.subset_preimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nhf : Set.MapsTo f s t\n⊢ HasSubset.Subset s (Set.preimage f t)","decl":"theorem MapsTo.subset_preimage (hf : MapsTo f s t) : s ⊆ f ⁻¹' t := hf\n\n"}
{"name":"Set.mapsTo_iff_subset_preimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\n⊢ Iff (Set.MapsTo f s t) (HasSubset.Subset s (Set.preimage f t))","decl":"theorem mapsTo_iff_subset_preimage : MapsTo f s t ↔ s ⊆ f ⁻¹' t := Iff.rfl\n\n"}
{"name":"Set.mapsTo_singleton","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nx : α\n⊢ Iff (Set.MapsTo f (Singleton.singleton x) t) (Membership.mem t (f x))","decl":"@[simp]\ntheorem mapsTo_singleton {x : α} : MapsTo f {x} t ↔ f x ∈ t :=\n  singleton_subset_iff\n\n"}
{"name":"Set.mapsTo_empty","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nt : Set β\n⊢ Set.MapsTo f EmptyCollection.emptyCollection t","decl":"theorem mapsTo_empty (f : α → β) (t : Set β) : MapsTo f ∅ t :=\n  empty_subset _\n\n"}
{"name":"Set.mapsTo_empty_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Iff (Set.MapsTo f s EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp] theorem mapsTo_empty_iff : MapsTo f s ∅ ↔ s = ∅ := by\n  simp [mapsTo', subset_empty_iff]\n\n"}
{"name":"Set.MapsTo.nonempty","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.MapsTo f s t\nhs : s.Nonempty\n⊢ t.Nonempty","decl":"/-- If `f` maps `s` to `t` and `s` is non-empty, `t` is non-empty. -/\ntheorem MapsTo.nonempty (h : MapsTo f s t) (hs : s.Nonempty) : t.Nonempty :=\n  (hs.image f).mono (mapsTo'.mp h)\n\n"}
{"name":"Set.MapsTo.image_subset","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.MapsTo f s t\n⊢ HasSubset.Subset (Set.image f s) t","decl":"theorem MapsTo.image_subset (h : MapsTo f s t) : f '' s ⊆ t :=\n  mapsTo'.1 h\n\n"}
{"name":"Set.MapsTo.congr","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf₁ f₂ : α → β\nh₁ : Set.MapsTo f₁ s t\nh : Set.EqOn f₁ f₂ s\n⊢ Set.MapsTo f₂ s t","decl":"theorem MapsTo.congr (h₁ : MapsTo f₁ s t) (h : EqOn f₁ f₂ s) : MapsTo f₂ s t := fun _ hx =>\n  h hx ▸ h₁ hx\n\n"}
{"name":"Set.EqOn.comp_right","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nf : α → β\ng₁ g₂ : β → γ\nhg : Set.EqOn g₁ g₂ t\nhf : Set.MapsTo f s t\n⊢ Set.EqOn (Function.comp g₁ f) (Function.comp g₂ f) s","decl":"theorem EqOn.comp_right (hg : t.EqOn g₁ g₂) (hf : s.MapsTo f t) : s.EqOn (g₁ ∘ f) (g₂ ∘ f) :=\n  fun _ ha => hg <| hf ha\n\n"}
{"name":"Set.EqOn.mapsTo_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf₁ f₂ : α → β\nH : Set.EqOn f₁ f₂ s\n⊢ Iff (Set.MapsTo f₁ s t) (Set.MapsTo f₂ s t)","decl":"theorem EqOn.mapsTo_iff (H : EqOn f₁ f₂ s) : MapsTo f₁ s t ↔ MapsTo f₂ s t :=\n  ⟨fun h => h.congr H, fun h => h.congr H.symm⟩\n\n"}
{"name":"Set.MapsTo.comp","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\np : Set γ\nf : α → β\ng : β → γ\nh₁ : Set.MapsTo g t p\nh₂ : Set.MapsTo f s t\n⊢ Set.MapsTo (Function.comp g f) s p","decl":"theorem MapsTo.comp (h₁ : MapsTo g t p) (h₂ : MapsTo f s t) : MapsTo (g ∘ f) s p := fun _ h =>\n  h₁ (h₂ h)\n\n"}
{"name":"Set.mapsTo_id","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ns : Set α\n⊢ Set.MapsTo id s s","decl":"theorem mapsTo_id (s : Set α) : MapsTo id s s := fun _ => id\n\n"}
{"name":"Set.MapsTo.iterate","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nf : α → α\ns : Set α\nh : Set.MapsTo f s s\nn : Nat\n⊢ Set.MapsTo (Nat.iterate f n) s s","decl":"theorem MapsTo.iterate {f : α → α} {s : Set α} (h : MapsTo f s s) : ∀ n, MapsTo f^[n] s s\n  | 0 => fun _ => id\n  | n + 1 => (MapsTo.iterate h n).comp h\n\n"}
{"name":"Set.MapsTo.iterate_restrict","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nf : α → α\ns : Set α\nh : Set.MapsTo f s s\nn : Nat\n⊢ Eq (Nat.iterate (Set.MapsTo.restrict f s s h) n) (Set.MapsTo.restrict (Nat.iterate f n) s s ⋯)","decl":"theorem MapsTo.iterate_restrict {f : α → α} {s : Set α} (h : MapsTo f s s) (n : ℕ) :\n    (h.restrict f s s)^[n] = (h.iterate n).restrict _ _ _ := by\n  funext x\n  rw [Subtype.ext_iff, MapsTo.val_restrict_apply]\n  induction n generalizing x with\n  | zero => rfl\n  | succ n ihn => simp [Nat.iterate, ihn]\n\n"}
{"name":"Set.mapsTo_of_subsingleton'","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\ninst✝ : Subsingleton β\nf : α → β\nh : s.Nonempty → t.Nonempty\n⊢ Set.MapsTo f s t","decl":"lemma mapsTo_of_subsingleton' [Subsingleton β] (f : α → β) (h : s.Nonempty → t.Nonempty) :\n    MapsTo f s t :=\n  fun a ha ↦ Subsingleton.mem_iff_nonempty.2 <| h ⟨a, ha⟩\n\n"}
{"name":"Set.mapsTo_of_subsingleton","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\nf : α → α\ns : Set α\n⊢ Set.MapsTo f s s","decl":"lemma mapsTo_of_subsingleton [Subsingleton α] (f : α → α) (s : Set α) : MapsTo f s s :=\n  mapsTo_of_subsingleton' _ id\n\n"}
{"name":"Set.MapsTo.mono","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt₁ t₂ : Set β\nf : α → β\nhf : Set.MapsTo f s₁ t₁\nhs : HasSubset.Subset s₂ s₁\nht : HasSubset.Subset t₁ t₂\n⊢ Set.MapsTo f s₂ t₂","decl":"theorem MapsTo.mono (hf : MapsTo f s₁ t₁) (hs : s₂ ⊆ s₁) (ht : t₁ ⊆ t₂) : MapsTo f s₂ t₂ :=\n  fun _ hx => ht (hf <| hs hx)\n\n"}
{"name":"Set.MapsTo.mono_left","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt : Set β\nf : α → β\nhf : Set.MapsTo f s₁ t\nhs : HasSubset.Subset s₂ s₁\n⊢ Set.MapsTo f s₂ t","decl":"theorem MapsTo.mono_left (hf : MapsTo f s₁ t) (hs : s₂ ⊆ s₁) : MapsTo f s₂ t := fun _ hx =>\n  hf (hs hx)\n\n"}
{"name":"Set.MapsTo.mono_right","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt₁ t₂ : Set β\nf : α → β\nhf : Set.MapsTo f s t₁\nht : HasSubset.Subset t₁ t₂\n⊢ Set.MapsTo f s t₂","decl":"theorem MapsTo.mono_right (hf : MapsTo f s t₁) (ht : t₁ ⊆ t₂) : MapsTo f s t₂ := fun _ hx =>\n  ht (hf hx)\n\n"}
{"name":"Set.MapsTo.union_union","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt₁ t₂ : Set β\nf : α → β\nh₁ : Set.MapsTo f s₁ t₁\nh₂ : Set.MapsTo f s₂ t₂\n⊢ Set.MapsTo f (Union.union s₁ s₂) (Union.union t₁ t₂)","decl":"theorem MapsTo.union_union (h₁ : MapsTo f s₁ t₁) (h₂ : MapsTo f s₂ t₂) :\n    MapsTo f (s₁ ∪ s₂) (t₁ ∪ t₂) := fun _ hx =>\n  hx.elim (fun hx => Or.inl <| h₁ hx) fun hx => Or.inr <| h₂ hx\n\n"}
{"name":"Set.MapsTo.union","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt : Set β\nf : α → β\nh₁ : Set.MapsTo f s₁ t\nh₂ : Set.MapsTo f s₂ t\n⊢ Set.MapsTo f (Union.union s₁ s₂) t","decl":"theorem MapsTo.union (h₁ : MapsTo f s₁ t) (h₂ : MapsTo f s₂ t) : MapsTo f (s₁ ∪ s₂) t :=\n  union_self t ▸ h₁.union_union h₂\n\n"}
{"name":"Set.mapsTo_union","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt : Set β\nf : α → β\n⊢ Iff (Set.MapsTo f (Union.union s₁ s₂) t) (And (Set.MapsTo f s₁ t) (Set.MapsTo f s₂ t))","decl":"@[simp]\ntheorem mapsTo_union : MapsTo f (s₁ ∪ s₂) t ↔ MapsTo f s₁ t ∧ MapsTo f s₂ t :=\n  ⟨fun h =>\n    ⟨h.mono subset_union_left (Subset.refl t),\n      h.mono subset_union_right (Subset.refl t)⟩,\n    fun h => h.1.union h.2⟩\n\n"}
{"name":"Set.MapsTo.inter","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt₁ t₂ : Set β\nf : α → β\nh₁ : Set.MapsTo f s t₁\nh₂ : Set.MapsTo f s t₂\n⊢ Set.MapsTo f s (Inter.inter t₁ t₂)","decl":"theorem MapsTo.inter (h₁ : MapsTo f s t₁) (h₂ : MapsTo f s t₂) : MapsTo f s (t₁ ∩ t₂) := fun _ hx =>\n  ⟨h₁ hx, h₂ hx⟩\n\n"}
{"name":"Set.MapsTo.insert","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.MapsTo f s t\nx : α\n⊢ Set.MapsTo f (Insert.insert x s) (Insert.insert (f x) t)","decl":"lemma MapsTo.insert (h : MapsTo f s t) (x : α) : MapsTo f (insert x s) (insert (f x) t) := by\n  simpa [← singleton_union] using h.mono_right subset_union_right\n\n"}
{"name":"Set.MapsTo.inter_inter","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt₁ t₂ : Set β\nf : α → β\nh₁ : Set.MapsTo f s₁ t₁\nh₂ : Set.MapsTo f s₂ t₂\n⊢ Set.MapsTo f (Inter.inter s₁ s₂) (Inter.inter t₁ t₂)","decl":"theorem MapsTo.inter_inter (h₁ : MapsTo f s₁ t₁) (h₂ : MapsTo f s₂ t₂) :\n    MapsTo f (s₁ ∩ s₂) (t₁ ∩ t₂) := fun _ hx => ⟨h₁ hx.1, h₂ hx.2⟩\n\n"}
{"name":"Set.mapsTo_inter","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt₁ t₂ : Set β\nf : α → β\n⊢ Iff (Set.MapsTo f s (Inter.inter t₁ t₂)) (And (Set.MapsTo f s t₁) (Set.MapsTo f s t₂))","decl":"@[simp]\ntheorem mapsTo_inter : MapsTo f s (t₁ ∩ t₂) ↔ MapsTo f s t₁ ∧ MapsTo f s t₂ :=\n  ⟨fun h =>\n    ⟨h.mono (Subset.refl s) inter_subset_left,\n      h.mono (Subset.refl s) inter_subset_right⟩,\n    fun h => h.1.inter h.2⟩\n\n"}
{"name":"Set.mapsTo_univ","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Set.MapsTo f s Set.univ","decl":"theorem mapsTo_univ (f : α → β) (s : Set α) : MapsTo f s univ := fun _ _ => trivial\n\n"}
{"name":"Set.mapsTo_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Set.MapsTo f s (Set.range f)","decl":"theorem mapsTo_range (f : α → β) (s : Set α) : MapsTo f s (range f) :=\n  (mapsTo_image f s).mono (Subset.refl s) (image_subset_range _ _)\n\n"}
{"name":"Set.mapsTo_image_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : γ → α\ns : Set γ\nt : Set β\n⊢ Iff (Set.MapsTo f (Set.image g s) t) (Set.MapsTo (Function.comp f g) s t)","decl":"@[simp]\ntheorem mapsTo_image_iff {f : α → β} {g : γ → α} {s : Set γ} {t : Set β} :\n    MapsTo f (g '' s) t ↔ MapsTo (f ∘ g) s t :=\n  ⟨fun h c hc => h ⟨c, hc, rfl⟩, fun h _ ⟨_, hc⟩ => hc.2 ▸ h hc.1⟩\n\n"}
{"name":"Set.MapsTo.comp_left","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nf : α → β\ng : β → γ\nhf : Set.MapsTo f s t\n⊢ Set.MapsTo (Function.comp g f) s (Set.image g t)","decl":"lemma MapsTo.comp_left (g : β → γ) (hf : MapsTo f s t) : MapsTo (g ∘ f) s (g '' t) :=\n  fun x hx ↦ ⟨f x, hf hx, rfl⟩\n\n"}
{"name":"Set.MapsTo.comp_right","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ng : β → γ\ns : Set β\nt : Set γ\nhg : Set.MapsTo g s t\nf : α → β\n⊢ Set.MapsTo (Function.comp g f) (Set.preimage f s) t","decl":"lemma MapsTo.comp_right {s : Set β} {t : Set γ} (hg : MapsTo g s t) (f : α → β) :\n    MapsTo (g ∘ f) (f ⁻¹' s) t := fun _ hx ↦ hg hx\n\n"}
{"name":"Set.mapsTo_univ_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\n⊢ Iff (Set.MapsTo f Set.univ t) (∀ (x : α), Membership.mem t (f x))","decl":"@[simp]\nlemma mapsTo_univ_iff : MapsTo f univ t ↔ ∀ x, f x ∈ t :=\n  ⟨fun h _ => h (mem_univ _), fun h x _ => h x⟩\n\n"}
{"name":"Set.mapsTo_range_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\nt : Set β\nf : α → β\ng : ι → α\n⊢ Iff (Set.MapsTo f (Set.range g) t) (∀ (i : ι), Membership.mem t (f (g i)))","decl":"@[simp]\nlemma mapsTo_range_iff {g : ι → α} : MapsTo f (range g) t ↔ ∀ i, f (g i) ∈ t :=\n  forall_mem_range\n\n"}
{"name":"Set.surjective_mapsTo_image_restrict","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Function.Surjective (Set.MapsTo.restrict f s (Set.image f s) ⋯)","decl":"theorem surjective_mapsTo_image_restrict (f : α → β) (s : Set α) :\n    Surjective ((mapsTo_image f s).restrict f s (f '' s)) := fun ⟨_, x, hs, hxy⟩ =>\n  ⟨⟨x, hs⟩, Subtype.ext hxy⟩\n\n"}
{"name":"Set.MapsTo.mem_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.MapsTo f s t\nhc : Set.MapsTo f (HasCompl.compl s) (HasCompl.compl t)\nx : α\n⊢ Iff (Membership.mem t (f x)) (Membership.mem s x)","decl":"theorem MapsTo.mem_iff (h : MapsTo f s t) (hc : MapsTo f sᶜ tᶜ) {x} : f x ∈ t ↔ x ∈ s :=\n  ⟨fun ht => by_contra fun hs => hc hs ht, fun hx => h hx⟩\n\n"}
{"name":"Set.image_restrictPreimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\n⊢ Eq (Set.image (t.restrictPreimage f) (Set.preimage Subtype.val s)) (Set.preimage Subtype.val (Set.image f s))","decl":"variable (f s) in\ntheorem image_restrictPreimage :\n    t.restrictPreimage f '' (Subtype.val ⁻¹' s) = Subtype.val ⁻¹' (f '' s) := by\n  delta Set.restrictPreimage\n  rw [← (Subtype.coe_injective).image_injective.eq_iff, ← image_comp, MapsTo.restrict_commutes,\n    image_comp, Subtype.image_preimage_coe, Subtype.image_preimage_coe, image_preimage_inter]\n\n"}
{"name":"Set.range_restrictPreimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\n⊢ Eq (Set.range (t.restrictPreimage f)) (Set.preimage Subtype.val (Set.range f))","decl":"variable (f) in\ntheorem range_restrictPreimage : range (t.restrictPreimage f) = Subtype.val ⁻¹' range f := by\n  simp only [← image_univ, ← image_restrictPreimage, preimage_univ]\n\n"}
{"name":"Set.restrictPreimage_mk","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\na : α\nh : Membership.mem (Set.preimage f t) a\n⊢ Eq (t.restrictPreimage f ⟨a, h⟩) ⟨f a, h⟩","decl":"@[simp]\ntheorem restrictPreimage_mk (h : a ∈ f ⁻¹' t) : t.restrictPreimage f ⟨a, h⟩ = ⟨f a, h⟩ := rfl\n\n"}
{"name":"Set.image_val_preimage_restrictPreimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nu : Set ↑t\n⊢ Eq (Set.image Subtype.val (Set.preimage (t.restrictPreimage f) u)) (Set.preimage f (Set.image Subtype.val u))","decl":"theorem image_val_preimage_restrictPreimage {u : Set t} :\n    Subtype.val '' (t.restrictPreimage f ⁻¹' u) = f ⁻¹' (Subtype.val '' u) := by\n  ext\n  simp\n\n"}
{"name":"Set.preimage_restrictPreimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nu : Set ↑t\n⊢ Eq (Set.preimage (t.restrictPreimage f) u) (Set.preimage (fun a => f ↑a) (Set.image Subtype.val u))","decl":"theorem preimage_restrictPreimage {u : Set t} :\n    t.restrictPreimage f ⁻¹' u = (fun a : f ⁻¹' t ↦ f a) ⁻¹' (Subtype.val '' u) := by\n  rw [← preimage_preimage (g := f) (f := Subtype.val), ← image_val_preimage_restrictPreimage,\n    preimage_image_eq _ Subtype.val_injective]\n\n"}
{"name":"Set.restrictPreimage_injective","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nhf : Function.Injective f\n⊢ Function.Injective (t.restrictPreimage f)","decl":"lemma restrictPreimage_injective (hf : Injective f) : Injective (t.restrictPreimage f) :=\n  fun _ _ e => Subtype.coe_injective <| hf <| Subtype.mk.inj e\n\n"}
{"name":"Set.restrictPreimage_surjective","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nhf : Function.Surjective f\n⊢ Function.Surjective (t.restrictPreimage f)","decl":"lemma restrictPreimage_surjective (hf : Surjective f) : Surjective (t.restrictPreimage f) :=\n  fun x => ⟨⟨_, ((hf x).choose_spec.symm ▸ x.2 : _ ∈ t)⟩, Subtype.ext (hf x).choose_spec⟩\n\n"}
{"name":"Set.restrictPreimage_bijective","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nhf : Function.Bijective f\n⊢ Function.Bijective (t.restrictPreimage f)","decl":"lemma restrictPreimage_bijective (hf : Bijective f) : Bijective (t.restrictPreimage f) :=\n  ⟨t.restrictPreimage_injective hf.1, t.restrictPreimage_surjective hf.2⟩\n\n"}
{"name":"Function.Injective.restrictPreimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nhf : Function.Injective f\n⊢ Function.Injective (t.restrictPreimage f)","decl":"alias _root_.Function.Injective.restrictPreimage := Set.restrictPreimage_injective\n"}
{"name":"Function.Surjective.restrictPreimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nhf : Function.Surjective f\n⊢ Function.Surjective (t.restrictPreimage f)","decl":"alias _root_.Function.Surjective.restrictPreimage := Set.restrictPreimage_surjective\n"}
{"name":"Function.Bijective.restrictPreimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nhf : Function.Bijective f\n⊢ Function.Bijective (t.restrictPreimage f)","decl":"alias _root_.Function.Bijective.restrictPreimage := Set.restrictPreimage_bijective\n\n"}
{"name":"Set.Subsingleton.injOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nhs : s.Subsingleton\nf : α → β\n⊢ Set.InjOn f s","decl":"theorem Subsingleton.injOn (hs : s.Subsingleton) (f : α → β) : InjOn f s := fun _ hx _ hy _ =>\n  hs hx hy\n\n"}
{"name":"Set.injOn_empty","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Set.InjOn f EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem injOn_empty (f : α → β) : InjOn f ∅ :=\n  subsingleton_empty.injOn f\n"}
{"name":"Set.injOn_singleton","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\n⊢ Set.InjOn f (Singleton.singleton a)","decl":"@[simp]\ntheorem injOn_singleton (f : α → β) (a : α) : InjOn f {a} :=\n  subsingleton_singleton.injOn f\n\n"}
{"name":"Set.injOn_pair","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na b : α\n⊢ Iff (Set.InjOn f (Insert.insert a (Singleton.singleton b))) (Eq (f a) (f b) → Eq a b)","decl":"@[simp] lemma injOn_pair {b : α} : InjOn f {a, b} ↔ f a = f b → a = b := by unfold InjOn; aesop\n\n"}
{"name":"Set.InjOn.eq_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nx y : α\nh : Set.InjOn f s\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Iff (Eq (f x) (f y)) (Eq x y)","decl":"theorem InjOn.eq_iff {x y} (h : InjOn f s) (hx : x ∈ s) (hy : y ∈ s) : f x = f y ↔ x = y :=\n  ⟨h hx hy, fun h => h ▸ rfl⟩\n\n"}
{"name":"Set.InjOn.ne_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nx y : α\nh : Set.InjOn f s\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Iff (Ne (f x) (f y)) (Ne x y)","decl":"theorem InjOn.ne_iff {x y} (h : InjOn f s) (hx : x ∈ s) (hy : y ∈ s) : f x ≠ f y ↔ x ≠ y :=\n  (h.eq_iff hx hy).not\n\n"}
{"name":"Set.InjOn.ne","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nx y : α\nh : Set.InjOn f s\nhx : Membership.mem s x\nhy : Membership.mem s y\na✝ : Ne x y\n⊢ Ne (f x) (f y)","decl":"alias ⟨_, InjOn.ne⟩ := InjOn.ne_iff\n\n"}
{"name":"Set.InjOn.congr","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\nh₁ : Set.InjOn f₁ s\nh : Set.EqOn f₁ f₂ s\n⊢ Set.InjOn f₂ s","decl":"theorem InjOn.congr (h₁ : InjOn f₁ s) (h : EqOn f₁ f₂ s) : InjOn f₂ s := fun _ hx _ hy =>\n  h hx ▸ h hy ▸ h₁ hx hy\n\n"}
{"name":"Set.EqOn.injOn_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\nH : Set.EqOn f₁ f₂ s\n⊢ Iff (Set.InjOn f₁ s) (Set.InjOn f₂ s)","decl":"theorem EqOn.injOn_iff (H : EqOn f₁ f₂ s) : InjOn f₁ s ↔ InjOn f₂ s :=\n  ⟨fun h => h.congr H, fun h => h.congr H.symm⟩\n\n"}
{"name":"Set.InjOn.mono","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nf : α → β\nh : HasSubset.Subset s₁ s₂\nht : Set.InjOn f s₂\n⊢ Set.InjOn f s₁","decl":"theorem InjOn.mono (h : s₁ ⊆ s₂) (ht : InjOn f s₂) : InjOn f s₁ := fun _ hx _ hy H =>\n  ht (h hx) (h hy) H\n\n"}
{"name":"Set.injOn_union","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nf : α → β\nh : Disjoint s₁ s₂\n⊢ Iff (Set.InjOn f (Union.union s₁ s₂)) (And (Set.InjOn f s₁) (And (Set.InjOn f s₂) (∀ (x : α), Membership.mem s₁ x → ∀ (y : α), Membership.mem s₂ y → Ne (f x) (f y))))","decl":"theorem injOn_union (h : Disjoint s₁ s₂) :\n    InjOn f (s₁ ∪ s₂) ↔ InjOn f s₁ ∧ InjOn f s₂ ∧ ∀ x ∈ s₁, ∀ y ∈ s₂, f x ≠ f y := by\n  refine ⟨fun H => ⟨H.mono subset_union_left, H.mono subset_union_right, ?_⟩, ?_⟩\n  · intro x hx y hy hxy\n    obtain rfl : x = y := H (Or.inl hx) (Or.inr hy) hxy\n    exact h.le_bot ⟨hx, hy⟩\n  · rintro ⟨h₁, h₂, h₁₂⟩\n    rintro x (hx | hx) y (hy | hy) hxy\n    exacts [h₁ hx hy hxy, (h₁₂ _ hx _ hy hxy).elim, (h₁₂ _ hy _ hx hxy.symm).elim, h₂ hx hy hxy]\n\n"}
{"name":"Set.injOn_insert","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\na : α\nhas : Not (Membership.mem s a)\n⊢ Iff (Set.InjOn f (Insert.insert a s)) (And (Set.InjOn f s) (Not (Membership.mem (Set.image f s) (f a))))","decl":"theorem injOn_insert {f : α → β} {s : Set α} {a : α} (has : a ∉ s) :\n    Set.InjOn f (insert a s) ↔ Set.InjOn f s ∧ f a ∉ f '' s := by\n  rw [← union_singleton, injOn_union (disjoint_singleton_right.2 has)]\n  simp\n\n"}
{"name":"Set.injective_iff_injOn_univ","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Iff (Function.Injective f) (Set.InjOn f Set.univ)","decl":"theorem injective_iff_injOn_univ : Injective f ↔ InjOn f univ :=\n  ⟨fun h _ _ _ _ hxy => h hxy, fun h _ _ heq => h trivial trivial heq⟩\n\n"}
{"name":"Set.injOn_of_injective","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nh : Function.Injective f\ns : Set α\n⊢ Set.InjOn f s","decl":"theorem injOn_of_injective (h : Injective f) {s : Set α} : InjOn f s := fun _ _ _ _ hxy => h hxy\n\n"}
{"name":"Function.Injective.injOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nh : Function.Injective f\ns : Set α\n⊢ Set.InjOn f s","decl":"alias _root_.Function.Injective.injOn := injOn_of_injective\n\n-- A specialization of `injOn_of_injective` for `Subtype.val`.\n"}
{"name":"Set.injOn_subtype_val","module":"Mathlib.Data.Set.Function","initialProofState":"γ : Type u_3\np : Set γ\ns : Set (Subtype fun x => p x)\n⊢ Set.InjOn Subtype.val s","decl":"theorem injOn_subtype_val {s : Set { x // p x }} : Set.InjOn Subtype.val s :=\n  Subtype.coe_injective.injOn\n\n"}
{"name":"Set.injOn_id","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ns : Set α\n⊢ Set.InjOn id s","decl":"lemma injOn_id (s : Set α) : InjOn id s := injective_id.injOn\n\n"}
{"name":"Set.InjOn.comp","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nf : α → β\ng : β → γ\nhg : Set.InjOn g t\nhf : Set.InjOn f s\nh : Set.MapsTo f s t\n⊢ Set.InjOn (Function.comp g f) s","decl":"theorem InjOn.comp (hg : InjOn g t) (hf : InjOn f s) (h : MapsTo f s t) : InjOn (g ∘ f) s :=\n  fun _ hx _ hy heq => hf hx hy <| hg (h hx) (h hy) heq\n\n"}
{"name":"Set.InjOn.of_comp","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nf : α → β\ng : β → γ\nh : Set.InjOn (Function.comp g f) s\n⊢ Set.InjOn f s","decl":"lemma InjOn.of_comp (h : InjOn (g ∘ f) s) : InjOn f s :=\n  fun _ hx _ hy heq ↦ h hx hy (by simp [heq])\n\n"}
{"name":"Set.InjOn.image_of_comp","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nf : α → β\ng : β → γ\nh : Set.InjOn (Function.comp g f) s\n⊢ Set.InjOn g (Set.image f s)","decl":"lemma InjOn.image_of_comp (h : InjOn (g ∘ f) s) : InjOn g (f '' s) :=\n  forall_mem_image.2 fun _x hx ↦ forall_mem_image.2 fun _y hy heq ↦ congr_arg f <| h hx hy heq\n\n"}
{"name":"Set.InjOn.iterate","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nf : α → α\ns : Set α\nh : Set.InjOn f s\nhf : Set.MapsTo f s s\nn : Nat\n⊢ Set.InjOn (Nat.iterate f n) s","decl":"lemma InjOn.iterate {f : α → α} {s : Set α} (h : InjOn f s) (hf : MapsTo f s s) :\n    ∀ n, InjOn f^[n] s\n  | 0 => injOn_id _\n  | (n + 1) => (h.iterate hf n).comp h hf\n\n"}
{"name":"Set.injOn_of_subsingleton","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Subsingleton α\nf : α → β\ns : Set α\n⊢ Set.InjOn f s","decl":"lemma injOn_of_subsingleton [Subsingleton α] (f : α → β) (s : Set α) : InjOn f s :=\n  (injective_of_subsingleton _).injOn\n\n"}
{"name":"Function.Injective.injOn_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : β → γ\nh : Function.Injective (Function.comp g f)\n⊢ Set.InjOn g (Set.range f)","decl":"theorem _root_.Function.Injective.injOn_range (h : Injective (g ∘ f)) : InjOn g (range f) := by\n  rintro _ ⟨x, rfl⟩ _ ⟨y, rfl⟩ H\n  exact congr_arg f (h H)\n\n"}
{"name":"Set.InjOn.injective_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : β → γ\ns : Set β\nh : Set.InjOn g s\nhs : HasSubset.Subset (Set.range f) s\n⊢ Iff (Function.Injective (Function.comp g f)) (Function.Injective f)","decl":"theorem _root_.Set.InjOn.injective_iff (s : Set β) (h : InjOn g s) (hs : range f ⊆ s) :\n    Injective (g ∘ f) ↔ Injective f :=\n  ⟨(·.of_comp), fun h _ ↦ by aesop⟩\n\n"}
{"name":"Set.injOn_iff_injective","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Iff (Set.InjOn f s) (Function.Injective (s.restrict f))","decl":"theorem injOn_iff_injective : InjOn f s ↔ Injective (s.restrict f) :=\n  ⟨fun H a b h => Subtype.eq <| H a.2 b.2 h, fun H a as b bs h =>\n    congr_arg Subtype.val <| @H ⟨a, as⟩ ⟨b, bs⟩ h⟩\n\n"}
{"name":"Set.InjOn.injective","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\na✝ : Set.InjOn f s\n⊢ Function.Injective (s.restrict f)","decl":"alias ⟨InjOn.injective, _⟩ := Set.injOn_iff_injective\n\n"}
{"name":"Set.MapsTo.restrict_inj","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.MapsTo f s t\n⊢ Iff (Function.Injective (Set.MapsTo.restrict f s t h)) (Set.InjOn f s)","decl":"theorem MapsTo.restrict_inj (h : MapsTo f s t) : Injective (h.restrict f s t) ↔ InjOn f s := by\n  rw [h.restrict_eq_codRestrict, injective_codRestrict, injOn_iff_injective]\n\n"}
{"name":"Set.exists_injOn_iff_injective","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : Nonempty β\n⊢ Iff (Exists fun f => Set.InjOn f s) (Exists fun f => Function.Injective f)","decl":"theorem exists_injOn_iff_injective [Nonempty β] :\n    (∃ f : α → β, InjOn f s) ↔ ∃ f : s → β, Injective f :=\n  ⟨fun ⟨_, hf⟩ => ⟨_, hf.injective⟩,\n   fun ⟨f, hf⟩ => by\n    lift f to α → β using trivial\n    exact ⟨f, injOn_iff_injective.2 hf⟩⟩\n\n"}
{"name":"Set.injOn_preimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nB : Set (Set β)\nhB : HasSubset.Subset B (Set.range f).powerset\n⊢ Set.InjOn (Set.preimage f) B","decl":"theorem injOn_preimage {B : Set (Set β)} (hB : B ⊆ 𝒫 range f) : InjOn (preimage f) B :=\n  fun s hs t ht hst => (preimage_eq_preimage' (@hB s hs) (@hB t ht)).1 hst\n-- Porting note: is there a semi-implicit variable problem with `⊆`?\n\n"}
{"name":"Set.InjOn.mem_of_mem_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nf : α → β\nx : α\nhf : Set.InjOn f s\nhs : HasSubset.Subset s₁ s\nh : Membership.mem s x\nh₁ : Membership.mem (Set.image f s₁) (f x)\n⊢ Membership.mem s₁ x","decl":"theorem InjOn.mem_of_mem_image {x} (hf : InjOn f s) (hs : s₁ ⊆ s) (h : x ∈ s) (h₁ : f x ∈ f '' s₁) :\n    x ∈ s₁ :=\n  let ⟨_, h', Eq⟩ := h₁\n  hf (hs h') h Eq ▸ h'\n\n"}
{"name":"Set.InjOn.mem_image_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nf : α → β\nx : α\nhf : Set.InjOn f s\nhs : HasSubset.Subset s₁ s\nhx : Membership.mem s x\n⊢ Iff (Membership.mem (Set.image f s₁) (f x)) (Membership.mem s₁ x)","decl":"theorem InjOn.mem_image_iff {x} (hf : InjOn f s) (hs : s₁ ⊆ s) (hx : x ∈ s) :\n    f x ∈ f '' s₁ ↔ x ∈ s₁ :=\n  ⟨hf.mem_of_mem_image hs hx, mem_image_of_mem f⟩\n\n"}
{"name":"Set.InjOn.preimage_image_inter","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nf : α → β\nhf : Set.InjOn f s\nhs : HasSubset.Subset s₁ s\n⊢ Eq (Inter.inter (Set.preimage f (Set.image f s₁)) s) s₁","decl":"theorem InjOn.preimage_image_inter (hf : InjOn f s) (hs : s₁ ⊆ s) : f ⁻¹' (f '' s₁) ∩ s = s₁ :=\n  ext fun _ => ⟨fun ⟨h₁, h₂⟩ => hf.mem_of_mem_image hs h₂ h₁, fun h => ⟨mem_image_of_mem _ h, hs h⟩⟩\n\n"}
{"name":"Set.EqOn.cancel_left","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nf₁ f₂ : α → β\ng : β → γ\nh : Set.EqOn (Function.comp g f₁) (Function.comp g f₂) s\nhg : Set.InjOn g t\nhf₁ : Set.MapsTo f₁ s t\nhf₂ : Set.MapsTo f₂ s t\n⊢ Set.EqOn f₁ f₂ s","decl":"theorem EqOn.cancel_left (h : s.EqOn (g ∘ f₁) (g ∘ f₂)) (hg : t.InjOn g) (hf₁ : s.MapsTo f₁ t)\n    (hf₂ : s.MapsTo f₂ t) : s.EqOn f₁ f₂ := fun _ ha => hg (hf₁ ha) (hf₂ ha) (h ha)\n\n"}
{"name":"Set.InjOn.cancel_left","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nf₁ f₂ : α → β\ng : β → γ\nhg : Set.InjOn g t\nhf₁ : Set.MapsTo f₁ s t\nhf₂ : Set.MapsTo f₂ s t\n⊢ Iff (Set.EqOn (Function.comp g f₁) (Function.comp g f₂) s) (Set.EqOn f₁ f₂ s)","decl":"theorem InjOn.cancel_left (hg : t.InjOn g) (hf₁ : s.MapsTo f₁ t) (hf₂ : s.MapsTo f₂ t) :\n    s.EqOn (g ∘ f₁) (g ∘ f₂) ↔ s.EqOn f₁ f₂ :=\n  ⟨fun h => h.cancel_left hg hf₁ hf₂, EqOn.comp_left⟩\n\n"}
{"name":"Set.InjOn.image_inter","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t u : Set α\nhf : Set.InjOn f u\nhs : HasSubset.Subset s u\nht : HasSubset.Subset t u\n⊢ Eq (Set.image f (Inter.inter s t)) (Inter.inter (Set.image f s) (Set.image f t))","decl":"lemma InjOn.image_inter {s t u : Set α} (hf : u.InjOn f) (hs : s ⊆ u) (ht : t ⊆ u) :\n    f '' (s ∩ t) = f '' s ∩ f '' t := by\n  apply Subset.antisymm (image_inter_subset _ _ _)\n  intro x ⟨⟨y, ys, hy⟩, ⟨z, zt, hz⟩⟩\n  have : y = z := by\n    apply hf (hs ys) (ht zt)\n    rwa [← hz] at hy\n  rw [← this] at zt\n  exact ⟨y, ⟨ys, zt⟩, hy⟩\n\n"}
{"name":"Set.InjOn.image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nh : Set.InjOn f s\n⊢ Set.InjOn (Set.image f) s.powerset","decl":"lemma InjOn.image (h : s.InjOn f) : s.powerset.InjOn (image f) :=\n  fun s₁ hs₁ s₂ hs₂ h' ↦ by rw [← h.preimage_image_inter hs₁, h', h.preimage_image_inter hs₂]\n\n"}
{"name":"Set.InjOn.image_eq_image_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ s₂ : Set α\nf : α → β\nh : Set.InjOn f s\nh₁ : HasSubset.Subset s₁ s\nh₂ : HasSubset.Subset s₂ s\n⊢ Iff (Eq (Set.image f s₁) (Set.image f s₂)) (Eq s₁ s₂)","decl":"theorem InjOn.image_eq_image_iff (h : s.InjOn f) (h₁ : s₁ ⊆ s) (h₂ : s₂ ⊆ s) :\n    f '' s₁ = f '' s₂ ↔ s₁ = s₂ :=\n  h.image.eq_iff h₁ h₂\n\n"}
{"name":"Set.InjOn.image_subset_image_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ s₂ : Set α\nf : α → β\nh : Set.InjOn f s\nh₁ : HasSubset.Subset s₁ s\nh₂ : HasSubset.Subset s₂ s\n⊢ Iff (HasSubset.Subset (Set.image f s₁) (Set.image f s₂)) (HasSubset.Subset s₁ s₂)","decl":"lemma InjOn.image_subset_image_iff (h : s.InjOn f) (h₁ : s₁ ⊆ s) (h₂ : s₂ ⊆ s) :\n    f '' s₁ ⊆ f '' s₂ ↔ s₁ ⊆ s₂ := by\n  refine ⟨fun h' ↦ ?_, image_subset _⟩\n  rw [← h.preimage_image_inter h₁, ← h.preimage_image_inter h₂]\n  exact inter_subset_inter_left _ (preimage_mono h')\n\n"}
{"name":"Set.InjOn.image_ssubset_image_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ s₂ : Set α\nf : α → β\nh : Set.InjOn f s\nh₁ : HasSubset.Subset s₁ s\nh₂ : HasSubset.Subset s₂ s\n⊢ Iff (HasSSubset.SSubset (Set.image f s₁) (Set.image f s₂)) (HasSSubset.SSubset s₁ s₂)","decl":"lemma InjOn.image_ssubset_image_iff (h : s.InjOn f) (h₁ : s₁ ⊆ s) (h₂ : s₂ ⊆ s) :\n    f '' s₁ ⊂ f '' s₂ ↔ s₁ ⊂ s₂ := by\n  simp_rw [ssubset_def, h.image_subset_image_iff h₁ h₂, h.image_subset_image_iff h₂ h₁]\n\n-- TODO: can this move to a better place?\n"}
{"name":"Disjoint.image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns t u : Set α\nf : α → β\nh : Disjoint s t\nhf : Set.InjOn f u\nhs : HasSubset.Subset s u\nht : HasSubset.Subset t u\n⊢ Disjoint (Set.image f s) (Set.image f t)","decl":"theorem _root_.Disjoint.image {s t u : Set α} {f : α → β} (h : Disjoint s t) (hf : u.InjOn f)\n    (hs : s ⊆ u) (ht : t ⊆ u) : Disjoint (f '' s) (f '' t) := by\n  rw [disjoint_iff_inter_eq_empty] at h ⊢\n  rw [← hf.image_inter hs ht, h, image_empty]\n\n"}
{"name":"Set.InjOn.image_diff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nt : Set α\nh : Set.InjOn f s\n⊢ Eq (Set.image f (SDiff.sdiff s t)) (SDiff.sdiff (Set.image f s) (Set.image f (Inter.inter s t)))","decl":"lemma InjOn.image_diff {t : Set α} (h : s.InjOn f) : f '' (s \\ t) = f '' s \\ f '' (s ∩ t) := by\n  refine subset_antisymm (subset_diff.2 ⟨image_subset f diff_subset, ?_⟩)\n    (diff_subset_iff.2 (by rw [← image_union, inter_union_diff]))\n  exact Disjoint.image disjoint_sdiff_inter h diff_subset inter_subset_left\n\n"}
{"name":"Set.InjOn.image_diff_subset","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nt : Set α\nh : Set.InjOn f s\nhst : HasSubset.Subset t s\n⊢ Eq (Set.image f (SDiff.sdiff s t)) (SDiff.sdiff (Set.image f s) (Set.image f t))","decl":"lemma InjOn.image_diff_subset {f : α → β} {t : Set α} (h : InjOn f s) (hst : t ⊆ s) :\n    f '' (s \\ t) = f '' s \\ f '' t := by\n  rw [h.image_diff, inter_eq_self_of_subset_right hst]\n\n"}
{"name":"Set.image_diff_of_injOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nt : Set α\nh : Set.InjOn f s\nhst : HasSubset.Subset t s\n⊢ Eq (Set.image f (SDiff.sdiff s t)) (SDiff.sdiff (Set.image f s) (Set.image f t))","decl":"alias image_diff_of_injOn := InjOn.image_diff_subset\n\n"}
{"name":"Set.InjOn.imageFactorization_injective","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nh : Set.InjOn f s\n⊢ Function.Injective (Set.imageFactorization f s)","decl":"theorem InjOn.imageFactorization_injective (h : InjOn f s) :\n    Injective (s.imageFactorization f) :=\n  fun ⟨x, hx⟩ ⟨y, hy⟩ h' ↦ by simpa [imageFactorization, h.eq_iff hx hy] using h'\n\n"}
{"name":"Set.imageFactorization_injective_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Iff (Function.Injective (Set.imageFactorization f s)) (Set.InjOn f s)","decl":"@[simp] theorem imageFactorization_injective_iff : Injective (s.imageFactorization f) ↔ InjOn f s :=\n  ⟨fun h x hx y hy _ ↦ by simpa using @h ⟨x, hx⟩ ⟨y, hy⟩ (by simpa [imageFactorization]),\n    InjOn.imageFactorization_injective⟩\n\n"}
{"name":"Set.mem_graphOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nx : Prod α β\n⊢ Iff (Membership.mem (Set.graphOn f s) x) (And (Membership.mem s x.1) (Eq (f x.1) x.2))","decl":"@[simp] lemma mem_graphOn : x ∈ s.graphOn f ↔ x.1 ∈ s ∧ f x.1 = x.2 := by aesop (add simp graphOn)\n\n"}
{"name":"Set.graphOn_empty","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Set.graphOn f EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp] lemma graphOn_empty (f : α → β) : graphOn f ∅ = ∅ := image_empty _\n"}
{"name":"Set.graphOn_eq_empty","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Iff (Eq (Set.graphOn f s) EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp] lemma graphOn_eq_empty : graphOn f s = ∅ ↔ s = ∅ := image_eq_empty\n"}
{"name":"Set.graphOn_nonempty","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Iff (Set.graphOn f s).Nonempty s.Nonempty","decl":"@[simp] lemma graphOn_nonempty : (s.graphOn f).Nonempty ↔ s.Nonempty := image_nonempty\n\n"}
{"name":"Set.Nonempty.graphOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\na✝ : s.Nonempty\n⊢ (Set.graphOn f s).Nonempty","decl":"protected alias ⟨_, Nonempty.graphOn⟩ := graphOn_nonempty\n\n"}
{"name":"Set.graphOn_union","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns t : Set α\n⊢ Eq (Set.graphOn f (Union.union s t)) (Union.union (Set.graphOn f s) (Set.graphOn f t))","decl":"@[simp]\nlemma graphOn_union (f : α → β) (s t : Set α) : graphOn f (s ∪ t) = graphOn f s ∪ graphOn f t :=\n  image_union ..\n\n"}
{"name":"Set.graphOn_singleton","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : α\n⊢ Eq (Set.graphOn f (Singleton.singleton x)) (Singleton.singleton { fst := x, snd := f x })","decl":"@[simp]\nlemma graphOn_singleton (f : α → β) (x : α) : graphOn f {x} = {(x, f x)} :=\n  image_singleton ..\n\n"}
{"name":"Set.graphOn_insert","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : α\ns : Set α\n⊢ Eq (Set.graphOn f (Insert.insert x s)) (Insert.insert { fst := x, snd := f x } (Set.graphOn f s))","decl":"@[simp]\nlemma graphOn_insert (f : α → β) (x : α) (s : Set α) :\n    graphOn f (insert x s) = insert (x, f x) (graphOn f s) :=\n  image_insert_eq ..\n\n"}
{"name":"Set.image_fst_graphOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Eq (Set.image Prod.fst (Set.graphOn f s)) s","decl":"@[simp]\nlemma image_fst_graphOn (f : α → β) (s : Set α) : Prod.fst '' graphOn f s = s := by\n  simp [graphOn, image_image]\n\n"}
{"name":"Set.image_snd_graphOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Eq (Set.image Prod.snd (Set.graphOn f s)) (Set.image f s)","decl":"@[simp] lemma image_snd_graphOn (f : α → β) : Prod.snd '' s.graphOn f = f '' s := by ext x; simp\n\n"}
{"name":"Set.fst_injOn_graph","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Set.InjOn Prod.fst (Set.graphOn f s)","decl":"lemma fst_injOn_graph : (s.graphOn f).InjOn Prod.fst := by aesop (add simp InjOn)\n\n"}
{"name":"Set.graphOn_comp","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nf : α → β\ng : β → γ\n⊢ Eq (Set.graphOn (Function.comp g f) s) (Set.image (fun x => { fst := x.1, snd := g x.2 }) (Set.graphOn f s))","decl":"lemma graphOn_comp (s : Set α) (f : α → β) (g : β → γ) :\n    s.graphOn (g ∘ f) = (fun x ↦ (x.1, g x.2)) '' s.graphOn f := by\n  simpa using image_comp (fun x ↦ (x.1, g x.2)) (fun x ↦ (x, f x)) _\n\n"}
{"name":"Set.graphOn_univ_eq_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Eq (Set.graphOn f Set.univ) (Set.range fun x => { fst := x, snd := f x })","decl":"lemma graphOn_univ_eq_range : univ.graphOn f = range fun x ↦ (x, f x) := image_univ\n\n"}
{"name":"Set.graphOn_inj","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf g : α → β\n⊢ Iff (Eq (Set.graphOn f s) (Set.graphOn g s)) (Set.EqOn f g s)","decl":"@[simp] lemma graphOn_inj {g : α → β} : s.graphOn f = s.graphOn g ↔ s.EqOn f g := by\n  simp [Set.ext_iff, funext_iff, forall_swap, EqOn]\n\n"}
{"name":"Set.graphOn_univ_inj","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\n⊢ Iff (Eq (Set.graphOn f Set.univ) (Set.graphOn g Set.univ)) (Eq f g)","decl":"lemma graphOn_univ_inj {g : α → β} : univ.graphOn f = univ.graphOn g ↔ f = g := by simp\n\n"}
{"name":"Set.graphOn_univ_injective","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Function.Injective fun f => Set.graphOn f Set.univ","decl":"lemma graphOn_univ_injective : Injective (univ.graphOn : (α → β) → Set (α × β)) :=\n  fun _f _g ↦ graphOn_univ_inj.1\n\n"}
{"name":"Set.exists_eq_graphOn_image_fst","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty β\ns : Set (Prod α β)\n⊢ Iff (Exists fun f => Eq s (Set.graphOn f (Set.image Prod.fst s))) (Set.InjOn Prod.fst s)","decl":"lemma exists_eq_graphOn_image_fst [Nonempty β] {s : Set (α × β)} :\n    (∃ f : α → β, s = graphOn f (Prod.fst '' s)) ↔ InjOn Prod.fst s := by\n  refine ⟨?_, fun h ↦ ?_⟩\n  · rintro ⟨f, hf⟩\n    rw [hf]\n    exact InjOn.image_of_comp <| injOn_id _\n  · have : ∀ x ∈ Prod.fst '' s, ∃ y, (x, y) ∈ s := forall_mem_image.2 fun (x, y) h ↦ ⟨y, h⟩\n    choose! f hf using this\n    rw [forall_mem_image] at hf\n    use f\n    rw [graphOn, image_image, EqOn.image_eq_self]\n    exact fun x hx ↦ h (hf hx) hx rfl\n\n"}
{"name":"Set.exists_eq_graphOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty β\ns : Set (Prod α β)\n⊢ Iff (Exists fun f => Exists fun t => Eq s (Set.graphOn f t)) (Set.InjOn Prod.fst s)","decl":"lemma exists_eq_graphOn [Nonempty β] {s : Set (α × β)} :\n    (∃ f t, s = graphOn f t) ↔ InjOn Prod.fst s :=\n  .trans ⟨fun ⟨f, t, hs⟩ ↦ ⟨f, by rw [hs, image_fst_graphOn]⟩, fun ⟨f, hf⟩ ↦ ⟨f, _, hf⟩⟩\n    exists_eq_graphOn_image_fst\n\n"}
{"name":"Set.graphOn_prod_graphOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ns : Set α\nt : Set β\nf : α → γ\ng : β → δ\n⊢ Eq (SProd.sprod (Set.graphOn f s) (Set.graphOn g t)) (Set.preimage (⇑(Equiv.prodProdProdComm α γ β δ)) (Set.graphOn (Prod.map f g) (SProd.sprod s t)))","decl":"lemma graphOn_prod_graphOn (s : Set α) (t : Set β) (f : α → γ) (g : β → δ) :\n    s.graphOn f ×ˢ t.graphOn g = Equiv.prodProdProdComm .. ⁻¹' (s ×ˢ t).graphOn (Prod.map f g) := by\n  aesop\n\n"}
{"name":"Set.graphOn_prod_prodMap","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ns : Set α\nt : Set β\nf : α → γ\ng : β → δ\n⊢ Eq (Set.graphOn (Prod.map f g) (SProd.sprod s t)) (Set.preimage (⇑(Equiv.prodProdProdComm α β γ δ)) (SProd.sprod (Set.graphOn f s) (Set.graphOn g t)))","decl":"lemma graphOn_prod_prodMap (s : Set α) (t : Set β) (f : α → γ) (g : β → δ) :\n    (s ×ˢ t).graphOn (Prod.map f g) = Equiv.prodProdProdComm .. ⁻¹' s.graphOn f ×ˢ t.graphOn g := by\n  aesop\n\n"}
{"name":"Set.SurjOn.subset_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.SurjOn f s t\n⊢ HasSubset.Subset t (Set.range f)","decl":"theorem SurjOn.subset_range (h : SurjOn f s t) : t ⊆ range f :=\n  Subset.trans h <| image_subset_range f s\n\n"}
{"name":"Set.surjOn_iff_exists_map_subtype","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\n⊢ Iff (Set.SurjOn f s t) (Exists fun t' => Exists fun g => And (HasSubset.Subset t t') (And (Function.Surjective g) (∀ (x : ↑s), Eq (f ↑x) ↑(g x))))","decl":"theorem surjOn_iff_exists_map_subtype :\n    SurjOn f s t ↔ ∃ (t' : Set β) (g : s → t'), t ⊆ t' ∧ Surjective g ∧ ∀ x : s, f x = g x :=\n  ⟨fun h =>\n    ⟨_, (mapsTo_image f s).restrict f s _, h, surjective_mapsTo_image_restrict _ _, fun _ => rfl⟩,\n    fun ⟨t', g, htt', hg, hfg⟩ y hy =>\n    let ⟨x, hx⟩ := hg ⟨y, htt' hy⟩\n    ⟨x, x.2, by rw [hfg, hx, Subtype.coe_mk]⟩⟩\n\n"}
{"name":"Set.surjOn_empty","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Set.SurjOn f s EmptyCollection.emptyCollection","decl":"theorem surjOn_empty (f : α → β) (s : Set α) : SurjOn f s ∅ :=\n  empty_subset _\n\n"}
{"name":"Set.surjOn_empty_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\n⊢ Iff (Set.SurjOn f EmptyCollection.emptyCollection t) (Eq t EmptyCollection.emptyCollection)","decl":"@[simp] theorem surjOn_empty_iff : SurjOn f ∅ t ↔ t = ∅ := by\n  simp [SurjOn, subset_empty_iff]\n\n"}
{"name":"Set.surjOn_singleton","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nb : β\n⊢ Iff (Set.SurjOn f s (Singleton.singleton b)) (Membership.mem (Set.image f s) b)","decl":"@[simp] lemma surjOn_singleton : SurjOn f s {b} ↔ b ∈ f '' s := singleton_subset_iff\n\n"}
{"name":"Set.surjOn_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ Set.SurjOn f s (Set.image f s)","decl":"theorem surjOn_image (f : α → β) (s : Set α) : SurjOn f s (f '' s) :=\n  Subset.rfl\n\n"}
{"name":"Set.SurjOn.comap_nonempty","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.SurjOn f s t\nht : t.Nonempty\n⊢ s.Nonempty","decl":"theorem SurjOn.comap_nonempty (h : SurjOn f s t) (ht : t.Nonempty) : s.Nonempty :=\n  (ht.mono h).of_image\n\n"}
{"name":"Set.SurjOn.congr","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf₁ f₂ : α → β\nh : Set.SurjOn f₁ s t\nH : Set.EqOn f₁ f₂ s\n⊢ Set.SurjOn f₂ s t","decl":"theorem SurjOn.congr (h : SurjOn f₁ s t) (H : EqOn f₁ f₂ s) : SurjOn f₂ s t := by\n  rwa [SurjOn, ← H.image_eq]\n\n"}
{"name":"Set.EqOn.surjOn_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf₁ f₂ : α → β\nh : Set.EqOn f₁ f₂ s\n⊢ Iff (Set.SurjOn f₁ s t) (Set.SurjOn f₂ s t)","decl":"theorem EqOn.surjOn_iff (h : EqOn f₁ f₂ s) : SurjOn f₁ s t ↔ SurjOn f₂ s t :=\n  ⟨fun H => H.congr h, fun H => H.congr h.symm⟩\n\n"}
{"name":"Set.SurjOn.mono","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt₁ t₂ : Set β\nf : α → β\nhs : HasSubset.Subset s₁ s₂\nht : HasSubset.Subset t₁ t₂\nhf : Set.SurjOn f s₁ t₂\n⊢ Set.SurjOn f s₂ t₁","decl":"theorem SurjOn.mono (hs : s₁ ⊆ s₂) (ht : t₁ ⊆ t₂) (hf : SurjOn f s₁ t₂) : SurjOn f s₂ t₁ :=\n  Subset.trans ht <| Subset.trans hf <| image_subset _ hs\n\n"}
{"name":"Set.SurjOn.union","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt₁ t₂ : Set β\nf : α → β\nh₁ : Set.SurjOn f s t₁\nh₂ : Set.SurjOn f s t₂\n⊢ Set.SurjOn f s (Union.union t₁ t₂)","decl":"theorem SurjOn.union (h₁ : SurjOn f s t₁) (h₂ : SurjOn f s t₂) : SurjOn f s (t₁ ∪ t₂) := fun _ hx =>\n  hx.elim (fun hx => h₁ hx) fun hx => h₂ hx\n\n"}
{"name":"Set.SurjOn.union_union","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt₁ t₂ : Set β\nf : α → β\nh₁ : Set.SurjOn f s₁ t₁\nh₂ : Set.SurjOn f s₂ t₂\n⊢ Set.SurjOn f (Union.union s₁ s₂) (Union.union t₁ t₂)","decl":"theorem SurjOn.union_union (h₁ : SurjOn f s₁ t₁) (h₂ : SurjOn f s₂ t₂) :\n    SurjOn f (s₁ ∪ s₂) (t₁ ∪ t₂) :=\n  (h₁.mono subset_union_left (Subset.refl _)).union\n    (h₂.mono subset_union_right (Subset.refl _))\n\n"}
{"name":"Set.SurjOn.inter_inter","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt₁ t₂ : Set β\nf : α → β\nh₁ : Set.SurjOn f s₁ t₁\nh₂ : Set.SurjOn f s₂ t₂\nh : Set.InjOn f (Union.union s₁ s₂)\n⊢ Set.SurjOn f (Inter.inter s₁ s₂) (Inter.inter t₁ t₂)","decl":"theorem SurjOn.inter_inter (h₁ : SurjOn f s₁ t₁) (h₂ : SurjOn f s₂ t₂) (h : InjOn f (s₁ ∪ s₂)) :\n    SurjOn f (s₁ ∩ s₂) (t₁ ∩ t₂) := by\n  intro y hy\n  rcases h₁ hy.1 with ⟨x₁, hx₁, rfl⟩\n  rcases h₂ hy.2 with ⟨x₂, hx₂, heq⟩\n  obtain rfl : x₁ = x₂ := h (Or.inl hx₁) (Or.inr hx₂) heq.symm\n  exact mem_image_of_mem f ⟨hx₁, hx₂⟩\n\n"}
{"name":"Set.SurjOn.inter","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt : Set β\nf : α → β\nh₁ : Set.SurjOn f s₁ t\nh₂ : Set.SurjOn f s₂ t\nh : Set.InjOn f (Union.union s₁ s₂)\n⊢ Set.SurjOn f (Inter.inter s₁ s₂) t","decl":"theorem SurjOn.inter (h₁ : SurjOn f s₁ t) (h₂ : SurjOn f s₂ t) (h : InjOn f (s₁ ∪ s₂)) :\n    SurjOn f (s₁ ∩ s₂) t :=\n  inter_self t ▸ h₁.inter_inter h₂ h\n\n-- Porting note: Why does `simp` not call `refl` by itself?\n"}
{"name":"Set.surjOn_id","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ns : Set α\n⊢ Set.SurjOn id s s","decl":"lemma surjOn_id (s : Set α) : SurjOn id s s := by simp [SurjOn, subset_rfl]\n\n"}
{"name":"Set.SurjOn.comp","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\np : Set γ\nf : α → β\ng : β → γ\nhg : Set.SurjOn g t p\nhf : Set.SurjOn f s t\n⊢ Set.SurjOn (Function.comp g f) s p","decl":"theorem SurjOn.comp (hg : SurjOn g t p) (hf : SurjOn f s t) : SurjOn (g ∘ f) s p :=\n  Subset.trans hg <| Subset.trans (image_subset g hf) <| image_comp g f s ▸ Subset.refl _\n\n"}
{"name":"Set.SurjOn.of_comp","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\np : Set γ\nf : α → β\ng : β → γ\nh : Set.SurjOn (Function.comp g f) s p\nhr : Set.MapsTo f s t\n⊢ Set.SurjOn g t p","decl":"lemma SurjOn.of_comp (h : SurjOn (g ∘ f) s p) (hr : MapsTo f s t) : SurjOn g t p := by\n  intro z hz\n  obtain ⟨x, hx, rfl⟩ := h hz\n  exact ⟨f x, hr hx, rfl⟩\n\n"}
{"name":"Set.SurjOn.iterate","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nf : α → α\ns : Set α\nh : Set.SurjOn f s s\nn : Nat\n⊢ Set.SurjOn (Nat.iterate f n) s s","decl":"lemma SurjOn.iterate {f : α → α} {s : Set α} (h : SurjOn f s s) : ∀ n, SurjOn f^[n] s s\n  | 0 => surjOn_id _\n  | (n + 1) => (h.iterate n).comp h\n\n"}
{"name":"Set.SurjOn.comp_left","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nf : α → β\nhf : Set.SurjOn f s t\ng : β → γ\n⊢ Set.SurjOn (Function.comp g f) s (Set.image g t)","decl":"lemma SurjOn.comp_left (hf : SurjOn f s t) (g : β → γ) : SurjOn (g ∘ f) s (g '' t) := by\n  rw [SurjOn, image_comp g f]; exact image_subset _ hf\n\n"}
{"name":"Set.SurjOn.comp_right","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : β → γ\ns : Set β\nt : Set γ\nhf : Function.Surjective f\nhg : Set.SurjOn g s t\n⊢ Set.SurjOn (Function.comp g f) (Set.preimage f s) t","decl":"lemma SurjOn.comp_right {s : Set β} {t : Set γ} (hf : Surjective f) (hg : SurjOn g s t) :\n    SurjOn (g ∘ f) (f ⁻¹' s) t := by\n  rwa [SurjOn, image_comp g f, image_preimage_eq _ hf]\n\n"}
{"name":"Set.surjOn_of_subsingleton'","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\ninst✝ : Subsingleton β\nf : α → β\nh : t.Nonempty → s.Nonempty\n⊢ Set.SurjOn f s t","decl":"lemma surjOn_of_subsingleton' [Subsingleton β] (f : α → β) (h : t.Nonempty → s.Nonempty) :\n    SurjOn f s t :=\n  fun _ ha ↦ Subsingleton.mem_iff_nonempty.2 <| (h ⟨_, ha⟩).image _\n\n"}
{"name":"Set.surjOn_of_subsingleton","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\nf : α → α\ns : Set α\n⊢ Set.SurjOn f s s","decl":"lemma surjOn_of_subsingleton [Subsingleton α] (f : α → α) (s : Set α) : SurjOn f s s :=\n  surjOn_of_subsingleton' _ id\n\n"}
{"name":"Set.surjective_iff_surjOn_univ","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Iff (Function.Surjective f) (Set.SurjOn f Set.univ Set.univ)","decl":"theorem surjective_iff_surjOn_univ : Surjective f ↔ SurjOn f univ univ := by\n  simp [Surjective, SurjOn, subset_def]\n\n"}
{"name":"Set.surjOn_iff_surjective","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Iff (Set.SurjOn f s Set.univ) (Function.Surjective (s.restrict f))","decl":"theorem surjOn_iff_surjective : SurjOn f s univ ↔ Surjective (s.restrict f) :=\n  ⟨fun H b =>\n    let ⟨a, as, e⟩ := @H b trivial\n    ⟨⟨a, as⟩, e⟩,\n    fun H b _ =>\n    let ⟨⟨a, as⟩, e⟩ := H b\n    ⟨a, as, e⟩⟩\n\n"}
{"name":"Set.MapsTo.restrict_surjective_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.MapsTo f s t\n⊢ Iff (Function.Surjective (Set.MapsTo.restrict f s t h)) (Set.SurjOn f s t)","decl":"@[simp]\ntheorem MapsTo.restrict_surjective_iff (h : MapsTo f s t) :\n    Surjective (MapsTo.restrict _ _ _ h) ↔ SurjOn f s t := by\n  refine ⟨fun h' b hb ↦ ?_, fun h' ⟨b, hb⟩ ↦ ?_⟩\n  · obtain ⟨⟨a, ha⟩, ha'⟩ := h' ⟨b, hb⟩\n    replace ha' : f a = b := by simpa [Subtype.ext_iff] using ha'\n    rw [← ha']\n    exact mem_image_of_mem f ha\n  · obtain ⟨a, ha, rfl⟩ := h' hb\n    exact ⟨⟨a, ha⟩, rfl⟩\n\n"}
{"name":"Set.SurjOn.image_eq_of_mapsTo","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh₁ : Set.SurjOn f s t\nh₂ : Set.MapsTo f s t\n⊢ Eq (Set.image f s) t","decl":"theorem SurjOn.image_eq_of_mapsTo (h₁ : SurjOn f s t) (h₂ : MapsTo f s t) : f '' s = t :=\n  eq_of_subset_of_subset h₂.image_subset h₁\n\n"}
{"name":"Set.image_eq_iff_surjOn_mapsTo","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\n⊢ Iff (Eq (Set.image f s) t) (And (Set.SurjOn f s t) (Set.MapsTo f s t))","decl":"theorem image_eq_iff_surjOn_mapsTo : f '' s = t ↔ s.SurjOn f t ∧ s.MapsTo f t := by\n  refine ⟨?_, fun h => h.1.image_eq_of_mapsTo h.2⟩\n  rintro rfl\n  exact ⟨s.surjOn_image f, s.mapsTo_image f⟩\n\n"}
{"name":"Set.SurjOn.image_preimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt t₁ : Set β\nf : α → β\nh : Set.SurjOn f s t\nht : HasSubset.Subset t₁ t\n⊢ Eq (Set.image f (Set.preimage f t₁)) t₁","decl":"lemma SurjOn.image_preimage (h : Set.SurjOn f s t) (ht : t₁ ⊆ t) : f '' (f ⁻¹' t₁) = t₁ :=\n  image_preimage_eq_iff.2 fun _ hx ↦ mem_range_of_mem_image f s <| h <| ht hx\n\n"}
{"name":"Set.SurjOn.mapsTo_compl","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.SurjOn f s t\nh' : Function.Injective f\n⊢ Set.MapsTo f (HasCompl.compl s) (HasCompl.compl t)","decl":"theorem SurjOn.mapsTo_compl (h : SurjOn f s t) (h' : Injective f) : MapsTo f sᶜ tᶜ :=\n  fun _ hs ht =>\n  let ⟨_, hx', HEq⟩ := h ht\n  hs <| h' HEq ▸ hx'\n\n"}
{"name":"Set.MapsTo.surjOn_compl","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.MapsTo f s t\nh' : Function.Surjective f\n⊢ Set.SurjOn f (HasCompl.compl s) (HasCompl.compl t)","decl":"theorem MapsTo.surjOn_compl (h : MapsTo f s t) (h' : Surjective f) : SurjOn f sᶜ tᶜ :=\n  h'.forall.2 fun _ ht => (mem_image_of_mem _) fun hs => ht (h hs)\n\n"}
{"name":"Set.EqOn.cancel_right","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nf : α → β\ng₁ g₂ : β → γ\nhf : Set.EqOn (Function.comp g₁ f) (Function.comp g₂ f) s\nhf' : Set.SurjOn f s t\n⊢ Set.EqOn g₁ g₂ t","decl":"theorem EqOn.cancel_right (hf : s.EqOn (g₁ ∘ f) (g₂ ∘ f)) (hf' : s.SurjOn f t) : t.EqOn g₁ g₂ := by\n  intro b hb\n  obtain ⟨a, ha, rfl⟩ := hf' hb\n  exact hf ha\n\n"}
{"name":"Set.SurjOn.cancel_right","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nf : α → β\ng₁ g₂ : β → γ\nhf : Set.SurjOn f s t\nhf' : Set.MapsTo f s t\n⊢ Iff (Set.EqOn (Function.comp g₁ f) (Function.comp g₂ f) s) (Set.EqOn g₁ g₂ t)","decl":"theorem SurjOn.cancel_right (hf : s.SurjOn f t) (hf' : s.MapsTo f t) :\n    s.EqOn (g₁ ∘ f) (g₂ ∘ f) ↔ t.EqOn g₁ g₂ :=\n  ⟨fun h => h.cancel_right hf, fun h => h.comp_right hf'⟩\n\n"}
{"name":"Set.eqOn_comp_right_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nf : α → β\ng₁ g₂ : β → γ\n⊢ Iff (Set.EqOn (Function.comp g₁ f) (Function.comp g₂ f) s) (Set.EqOn g₁ g₂ (Set.image f s))","decl":"theorem eqOn_comp_right_iff : s.EqOn (g₁ ∘ f) (g₂ ∘ f) ↔ (f '' s).EqOn g₁ g₂ :=\n  (s.surjOn_image f).cancel_right <| s.mapsTo_image f\n\n"}
{"name":"Set.SurjOn.forall","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\np : β → Prop\nhf : Set.SurjOn f s t\nhf' : Set.MapsTo f s t\n⊢ Iff (∀ (y : β), Membership.mem t y → p y) (∀ (x : α), Membership.mem s x → p (f x))","decl":"theorem SurjOn.forall {p : β → Prop} (hf : s.SurjOn f t) (hf' : s.MapsTo f t) :\n    (∀ y ∈ t, p y) ↔ (∀ x ∈ s, p (f x)) :=\n  ⟨fun H x hx ↦ H (f x) (hf' hx), fun H _y hy ↦ let ⟨x, hx, hxy⟩ := hf hy; hxy ▸ H x hx⟩\n\n"}
{"name":"Set.BijOn.mapsTo","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.BijOn f s t\n⊢ Set.MapsTo f s t","decl":"theorem BijOn.mapsTo (h : BijOn f s t) : MapsTo f s t :=\n  h.left\n\n"}
{"name":"Set.BijOn.injOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.BijOn f s t\n⊢ Set.InjOn f s","decl":"theorem BijOn.injOn (h : BijOn f s t) : InjOn f s :=\n  h.right.left\n\n"}
{"name":"Set.BijOn.surjOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.BijOn f s t\n⊢ Set.SurjOn f s t","decl":"theorem BijOn.surjOn (h : BijOn f s t) : SurjOn f s t :=\n  h.right.right\n\n"}
{"name":"Set.BijOn.mk","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh₁ : Set.MapsTo f s t\nh₂ : Set.InjOn f s\nh₃ : Set.SurjOn f s t\n⊢ Set.BijOn f s t","decl":"theorem BijOn.mk (h₁ : MapsTo f s t) (h₂ : InjOn f s) (h₃ : SurjOn f s t) : BijOn f s t :=\n  ⟨h₁, h₂, h₃⟩\n\n"}
{"name":"Set.bijOn_empty","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Set.BijOn f EmptyCollection.emptyCollection EmptyCollection.emptyCollection","decl":"theorem bijOn_empty (f : α → β) : BijOn f ∅ ∅ :=\n  ⟨mapsTo_empty f ∅, injOn_empty f, surjOn_empty f ∅⟩\n\n"}
{"name":"Set.bijOn_empty_iff_left","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Iff (Set.BijOn f s EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp] theorem bijOn_empty_iff_left : BijOn f s ∅ ↔ s = ∅ :=\n  ⟨fun h ↦ by simpa using h.mapsTo, by rintro rfl; exact bijOn_empty f⟩\n\n"}
{"name":"Set.bijOn_empty_iff_right","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\n⊢ Iff (Set.BijOn f EmptyCollection.emptyCollection t) (Eq t EmptyCollection.emptyCollection)","decl":"@[simp] theorem bijOn_empty_iff_right : BijOn f ∅ t ↔ t = ∅ :=\n  ⟨fun h ↦ by simpa using h.surjOn, by rintro rfl; exact bijOn_empty f⟩\n\n"}
{"name":"Set.bijOn_singleton","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\nb : β\n⊢ Iff (Set.BijOn f (Singleton.singleton a) (Singleton.singleton b)) (Eq (f a) b)","decl":"@[simp] lemma bijOn_singleton : BijOn f {a} {b} ↔ f a = b := by simp [BijOn, eq_comm]\n\n"}
{"name":"Set.BijOn.inter_mapsTo","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt₁ t₂ : Set β\nf : α → β\nh₁ : Set.BijOn f s₁ t₁\nh₂ : Set.MapsTo f s₂ t₂\nh₃ : HasSubset.Subset (Inter.inter s₁ (Set.preimage f t₂)) s₂\n⊢ Set.BijOn f (Inter.inter s₁ s₂) (Inter.inter t₁ t₂)","decl":"theorem BijOn.inter_mapsTo (h₁ : BijOn f s₁ t₁) (h₂ : MapsTo f s₂ t₂) (h₃ : s₁ ∩ f ⁻¹' t₂ ⊆ s₂) :\n    BijOn f (s₁ ∩ s₂) (t₁ ∩ t₂) :=\n  ⟨h₁.mapsTo.inter_inter h₂, h₁.injOn.mono inter_subset_left, fun _ hy =>\n    let ⟨x, hx, hxy⟩ := h₁.surjOn hy.1\n    ⟨x, ⟨hx, h₃ ⟨hx, hxy.symm.subst hy.2⟩⟩, hxy⟩⟩\n\n"}
{"name":"Set.MapsTo.inter_bijOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt₁ t₂ : Set β\nf : α → β\nh₁ : Set.MapsTo f s₁ t₁\nh₂ : Set.BijOn f s₂ t₂\nh₃ : HasSubset.Subset (Inter.inter s₂ (Set.preimage f t₁)) s₁\n⊢ Set.BijOn f (Inter.inter s₁ s₂) (Inter.inter t₁ t₂)","decl":"theorem MapsTo.inter_bijOn (h₁ : MapsTo f s₁ t₁) (h₂ : BijOn f s₂ t₂) (h₃ : s₂ ∩ f ⁻¹' t₁ ⊆ s₁) :\n    BijOn f (s₁ ∩ s₂) (t₁ ∩ t₂) :=\n  inter_comm s₂ s₁ ▸ inter_comm t₂ t₁ ▸ h₂.inter_mapsTo h₁ h₃\n\n"}
{"name":"Set.BijOn.inter","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt₁ t₂ : Set β\nf : α → β\nh₁ : Set.BijOn f s₁ t₁\nh₂ : Set.BijOn f s₂ t₂\nh : Set.InjOn f (Union.union s₁ s₂)\n⊢ Set.BijOn f (Inter.inter s₁ s₂) (Inter.inter t₁ t₂)","decl":"theorem BijOn.inter (h₁ : BijOn f s₁ t₁) (h₂ : BijOn f s₂ t₂) (h : InjOn f (s₁ ∪ s₂)) :\n    BijOn f (s₁ ∩ s₂) (t₁ ∩ t₂) :=\n  ⟨h₁.mapsTo.inter_inter h₂.mapsTo, h₁.injOn.mono inter_subset_left,\n    h₁.surjOn.inter_inter h₂.surjOn h⟩\n\n"}
{"name":"Set.BijOn.union","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nt₁ t₂ : Set β\nf : α → β\nh₁ : Set.BijOn f s₁ t₁\nh₂ : Set.BijOn f s₂ t₂\nh : Set.InjOn f (Union.union s₁ s₂)\n⊢ Set.BijOn f (Union.union s₁ s₂) (Union.union t₁ t₂)","decl":"theorem BijOn.union (h₁ : BijOn f s₁ t₁) (h₂ : BijOn f s₂ t₂) (h : InjOn f (s₁ ∪ s₂)) :\n    BijOn f (s₁ ∪ s₂) (t₁ ∪ t₂) :=\n  ⟨h₁.mapsTo.union_union h₂.mapsTo, h, h₁.surjOn.union_union h₂.surjOn⟩\n\n"}
{"name":"Set.BijOn.subset_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.BijOn f s t\n⊢ HasSubset.Subset t (Set.range f)","decl":"theorem BijOn.subset_range (h : BijOn f s t) : t ⊆ range f :=\n  h.surjOn.subset_range\n\n"}
{"name":"Set.InjOn.bijOn_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nh : Set.InjOn f s\n⊢ Set.BijOn f s (Set.image f s)","decl":"theorem InjOn.bijOn_image (h : InjOn f s) : BijOn f s (f '' s) :=\n  BijOn.mk (mapsTo_image f s) h (Subset.refl _)\n\n"}
{"name":"Set.BijOn.congr","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf₁ f₂ : α → β\nh₁ : Set.BijOn f₁ s t\nh : Set.EqOn f₁ f₂ s\n⊢ Set.BijOn f₂ s t","decl":"theorem BijOn.congr (h₁ : BijOn f₁ s t) (h : EqOn f₁ f₂ s) : BijOn f₂ s t :=\n  BijOn.mk (h₁.mapsTo.congr h) (h₁.injOn.congr h) (h₁.surjOn.congr h)\n\n"}
{"name":"Set.EqOn.bijOn_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf₁ f₂ : α → β\nH : Set.EqOn f₁ f₂ s\n⊢ Iff (Set.BijOn f₁ s t) (Set.BijOn f₂ s t)","decl":"theorem EqOn.bijOn_iff (H : EqOn f₁ f₂ s) : BijOn f₁ s t ↔ BijOn f₂ s t :=\n  ⟨fun h => h.congr H, fun h => h.congr H.symm⟩\n\n"}
{"name":"Set.BijOn.image_eq","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.BijOn f s t\n⊢ Eq (Set.image f s) t","decl":"theorem BijOn.image_eq (h : BijOn f s t) : f '' s = t :=\n  h.surjOn.image_eq_of_mapsTo h.mapsTo\n\n"}
{"name":"Set.BijOn.forall","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\np : β → Prop\nhf : Set.BijOn f s t\n⊢ Iff (∀ (b : β), Membership.mem t b → p b) (∀ (a : α), Membership.mem s a → p (f a))","decl":"lemma BijOn.forall {p : β → Prop} (hf : BijOn f s t) : (∀ b ∈ t, p b) ↔ ∀ a ∈ s, p (f a) where\n  mp h _ ha := h _ <| hf.mapsTo ha\n  mpr h b hb := by obtain ⟨a, ha, rfl⟩ := hf.surjOn hb; exact h _ ha\n\n"}
{"name":"Set.BijOn.exists","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\np : β → Prop\nhf : Set.BijOn f s t\n⊢ Iff (Exists fun b => And (Membership.mem t b) (p b)) (Exists fun a => And (Membership.mem s a) (p (f a)))","decl":"lemma BijOn.exists {p : β → Prop} (hf : BijOn f s t) : (∃ b ∈ t, p b) ↔ ∃ a ∈ s, p (f a) where\n  mp := by rintro ⟨b, hb, h⟩; obtain ⟨a, ha, rfl⟩ := hf.surjOn hb; exact ⟨a, ha, h⟩\n  mpr := by rintro ⟨a, ha, h⟩; exact ⟨f a, hf.mapsTo ha, h⟩\n\n"}
{"name":"Equiv.image_eq_iff_bijOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\ne : Equiv α β\n⊢ Iff (Eq (Set.image (⇑e) s) t) (Set.BijOn (⇑e) s t)","decl":"lemma _root_.Equiv.image_eq_iff_bijOn (e : α ≃ β) : e '' s = t ↔ BijOn e s t :=\n  ⟨fun h ↦ ⟨(mapsTo_image e s).mono_right h.subset, e.injective.injOn, h ▸ surjOn_image e s⟩,\n  BijOn.image_eq⟩\n\n"}
{"name":"Set.bijOn_id","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ns : Set α\n⊢ Set.BijOn id s s","decl":"lemma bijOn_id (s : Set α) : BijOn id s s := ⟨s.mapsTo_id, s.injOn_id, s.surjOn_id⟩\n\n"}
{"name":"Set.BijOn.comp","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\np : Set γ\nf : α → β\ng : β → γ\nhg : Set.BijOn g t p\nhf : Set.BijOn f s t\n⊢ Set.BijOn (Function.comp g f) s p","decl":"theorem BijOn.comp (hg : BijOn g t p) (hf : BijOn f s t) : BijOn (g ∘ f) s p :=\n  BijOn.mk (hg.mapsTo.comp hf.mapsTo) (hg.injOn.comp hf.injOn hf.mapsTo) (hg.surjOn.comp hf.surjOn)\n\n"}
{"name":"Set.BijOn.iterate","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nf : α → α\ns : Set α\nh : Set.BijOn f s s\nn : Nat\n⊢ Set.BijOn (Nat.iterate f n) s s","decl":"lemma BijOn.iterate {f : α → α} {s : Set α} (h : BijOn f s s) : ∀ n, BijOn f^[n] s s\n  | 0 => s.bijOn_id\n  | (n + 1) => (h.iterate n).comp h\n\n"}
{"name":"Set.bijOn_of_subsingleton'","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\ninst✝¹ : Subsingleton α\ninst✝ : Subsingleton β\nf : α → β\nh : Iff s.Nonempty t.Nonempty\n⊢ Set.BijOn f s t","decl":"lemma bijOn_of_subsingleton' [Subsingleton α] [Subsingleton β] (f : α → β)\n    (h : s.Nonempty ↔ t.Nonempty) : BijOn f s t :=\n  ⟨mapsTo_of_subsingleton' _ h.1, injOn_of_subsingleton _ _, surjOn_of_subsingleton' _ h.2⟩\n\n"}
{"name":"Set.bijOn_of_subsingleton","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\nf : α → α\ns : Set α\n⊢ Set.BijOn f s s","decl":"lemma bijOn_of_subsingleton [Subsingleton α] (f : α → α) (s : Set α) : BijOn f s s :=\n  bijOn_of_subsingleton' _ Iff.rfl\n\n"}
{"name":"Set.BijOn.bijective","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nh : Set.BijOn f s t\n⊢ Function.Bijective (Set.MapsTo.restrict f s t ⋯)","decl":"theorem BijOn.bijective (h : BijOn f s t) : Bijective (h.mapsTo.restrict f s t) :=\n  ⟨fun x y h' => Subtype.ext <| h.injOn x.2 y.2 <| Subtype.ext_iff.1 h', fun ⟨_, hy⟩ =>\n    let ⟨x, hx, hxy⟩ := h.surjOn hy\n    ⟨⟨x, hx⟩, Subtype.eq hxy⟩⟩\n\n"}
{"name":"Set.bijective_iff_bijOn_univ","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Iff (Function.Bijective f) (Set.BijOn f Set.univ Set.univ)","decl":"theorem bijective_iff_bijOn_univ : Bijective f ↔ BijOn f univ univ :=\n  Iff.intro\n    (fun h =>\n      let ⟨inj, surj⟩ := h\n      ⟨mapsTo_univ f _, inj.injOn, Iff.mp surjective_iff_surjOn_univ surj⟩)\n    fun h =>\n    let ⟨_map, inj, surj⟩ := h\n    ⟨Iff.mpr injective_iff_injOn_univ inj, Iff.mpr surjective_iff_surjOn_univ surj⟩\n\n"}
{"name":"Function.Bijective.bijOn_univ","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na✝ : Function.Bijective f\n⊢ Set.BijOn f Set.univ Set.univ","decl":"alias ⟨_root_.Function.Bijective.bijOn_univ, _⟩ := bijective_iff_bijOn_univ\n\n"}
{"name":"Set.BijOn.compl","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nhst : Set.BijOn f s t\nhf : Function.Bijective f\n⊢ Set.BijOn f (HasCompl.compl s) (HasCompl.compl t)","decl":"theorem BijOn.compl (hst : BijOn f s t) (hf : Bijective f) : BijOn f sᶜ tᶜ :=\n  ⟨hst.surjOn.mapsTo_compl hf.1, hf.1.injOn, hst.mapsTo.surjOn_compl hf.2⟩\n\n"}
{"name":"Set.BijOn.subset_right","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nr : Set β\nhf : Set.BijOn f s t\nhrt : HasSubset.Subset r t\n⊢ Set.BijOn f (Inter.inter s (Set.preimage f r)) r","decl":"theorem BijOn.subset_right {r : Set β} (hf : BijOn f s t) (hrt : r ⊆ t) :\n    BijOn f (s ∩ f ⁻¹' r) r := by\n  refine ⟨inter_subset_right, hf.injOn.mono inter_subset_left, fun x hx ↦ ?_⟩\n  obtain ⟨y, hy, rfl⟩ := hf.surjOn (hrt hx)\n  exact ⟨y, ⟨hy, hx⟩, rfl⟩\n\n"}
{"name":"Set.BijOn.subset_left","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nr : Set α\nhf : Set.BijOn f s t\nhrs : HasSubset.Subset r s\n⊢ Set.BijOn f r (Set.image f r)","decl":"theorem BijOn.subset_left {r : Set α} (hf : BijOn f s t) (hrs : r ⊆ s) :\n    BijOn f r (f '' r) :=\n  (hf.injOn.mono hrs).bijOn_image\n\n"}
{"name":"Set.BijOn.insert_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\na : α\nha : Not (Membership.mem s a)\nhfa : Not (Membership.mem t (f a))\n⊢ Iff (Set.BijOn f (Insert.insert a s) (Insert.insert (f a) t)) (Set.BijOn f s t)","decl":"theorem BijOn.insert_iff (ha : a ∉ s) (hfa : f a ∉ t) :\n    BijOn f (insert a s) (insert (f a) t) ↔ BijOn f s t where\n  mp h := by\n    have := congrArg (· \\ {f a}) (image_insert_eq ▸ h.image_eq)\n    simp only [mem_singleton_iff, insert_diff_of_mem] at this\n    rw [diff_singleton_eq_self hfa, diff_singleton_eq_self] at this\n    · exact ⟨by simp [← this, mapsTo'], h.injOn.mono (subset_insert ..),\n        by simp [← this, surjOn_image]⟩\n    simp only [mem_image, not_exists, not_and]\n    intro x hx\n    rw [h.injOn.eq_iff (by simp [hx]) (by simp)]\n    exact ha ∘ (· ▸ hx)\n  mpr h := by\n    repeat rw [insert_eq]\n    refine (bijOn_singleton.mpr rfl).union h ?_\n    simp only [singleton_union, injOn_insert fun x ↦ (hfa (h.mapsTo x)), h.injOn, mem_image,\n      not_exists, not_and, true_and]\n    exact fun _ hx h₂ ↦ hfa (h₂ ▸ h.mapsTo hx)\n\n"}
{"name":"Set.BijOn.insert","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\na : α\nh₁ : Set.BijOn f s t\nh₂ : Not (Membership.mem t (f a))\n⊢ Set.BijOn f (Insert.insert a s) (Insert.insert (f a) t)","decl":"theorem BijOn.insert (h₁ : BijOn f s t) (h₂ : f a ∉ t) :\n    BijOn f (insert a s) (insert (f a) t) :=\n  (insert_iff (h₂ <| h₁.mapsTo ·) h₂).mpr h₁\n\n"}
{"name":"Set.BijOn.sdiff_singleton","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\na : α\nh₁ : Set.BijOn f s t\nh₂ : Membership.mem s a\n⊢ Set.BijOn f (SDiff.sdiff s (Singleton.singleton a)) (SDiff.sdiff t (Singleton.singleton (f a)))","decl":"theorem BijOn.sdiff_singleton (h₁ : BijOn f s t) (h₂ : a ∈ s) :\n    BijOn f (s \\ {a}) (t \\ {f a}) := by\n  convert h₁.subset_left diff_subset\n  simp [h₁.injOn.image_diff, h₁.image_eq, h₂, inter_eq_self_of_subset_right]\n\n"}
{"name":"Set.LeftInvOn.eqOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nf' : β → α\nh : Set.LeftInvOn f' f s\n⊢ Set.EqOn (Function.comp f' f) id s","decl":"theorem eqOn (h : LeftInvOn f' f s) : EqOn (f' ∘ f) id s :=\n  h\n\n"}
{"name":"Set.LeftInvOn.eq","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nf' : β → α\nh : Set.LeftInvOn f' f s\nx : α\nhx : Membership.mem s x\n⊢ Eq (f' (f x)) x","decl":"theorem eq (h : LeftInvOn f' f s) {x} (hx : x ∈ s) : f' (f x) = x :=\n  h hx\n\n"}
{"name":"Set.LeftInvOn.congr_left","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nf₁' f₂' : β → α\nh₁ : Set.LeftInvOn f₁' f s\nt : Set β\nh₁' : Set.MapsTo f s t\nheq : Set.EqOn f₁' f₂' t\n⊢ Set.LeftInvOn f₂' f s","decl":"theorem congr_left (h₁ : LeftInvOn f₁' f s) {t : Set β} (h₁' : MapsTo f s t)\n    (heq : EqOn f₁' f₂' t) : LeftInvOn f₂' f s := fun _ hx => heq (h₁' hx) ▸ h₁ hx\n\n"}
{"name":"Set.LeftInvOn.congr_right","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf₁ f₂ : α → β\nf₁' : β → α\nh₁ : Set.LeftInvOn f₁' f₁ s\nheq : Set.EqOn f₁ f₂ s\n⊢ Set.LeftInvOn f₁' f₂ s","decl":"theorem congr_right (h₁ : LeftInvOn f₁' f₁ s) (heq : EqOn f₁ f₂ s) : LeftInvOn f₁' f₂ s :=\n  fun _ hx => heq hx ▸ h₁ hx\n\n"}
{"name":"Set.LeftInvOn.injOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nf₁' : β → α\nh : Set.LeftInvOn f₁' f s\n⊢ Set.InjOn f s","decl":"theorem injOn (h : LeftInvOn f₁' f s) : InjOn f s := fun x₁ h₁ x₂ h₂ heq =>\n  calc\n    x₁ = f₁' (f x₁) := Eq.symm <| h h₁\n    _ = f₁' (f x₂) := congr_arg f₁' heq\n    _ = x₂ := h h₂\n\n"}
{"name":"Set.LeftInvOn.surjOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nf' : β → α\nh : Set.LeftInvOn f' f s\nhf : Set.MapsTo f s t\n⊢ Set.SurjOn f' t s","decl":"theorem surjOn (h : LeftInvOn f' f s) (hf : MapsTo f s t) : SurjOn f' t s := fun x hx =>\n  ⟨f x, hf hx, h hx⟩\n\n"}
{"name":"Set.LeftInvOn.mapsTo","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nf' : β → α\nh : Set.LeftInvOn f' f s\nhf : Set.SurjOn f s t\n⊢ Set.MapsTo f' t s","decl":"theorem mapsTo (h : LeftInvOn f' f s) (hf : SurjOn f s t) :\n    MapsTo f' t s := fun y hy => by\n  let ⟨x, hs, hx⟩ := hf hy\n  rwa [← hx, h hs]\n\n"}
{"name":"Set.leftInvOn_id","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ns : Set α\n⊢ Set.LeftInvOn id id s","decl":"lemma _root_.Set.leftInvOn_id (s : Set α) : LeftInvOn id id s := fun _ _ ↦ rfl\n\n"}
{"name":"Set.LeftInvOn.comp","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nf : α → β\ng : β → γ\nf' : β → α\ng' : γ → β\nhf' : Set.LeftInvOn f' f s\nhg' : Set.LeftInvOn g' g t\nhf : Set.MapsTo f s t\n⊢ Set.LeftInvOn (Function.comp f' g') (Function.comp g f) s","decl":"theorem comp (hf' : LeftInvOn f' f s) (hg' : LeftInvOn g' g t) (hf : MapsTo f s t) :\n    LeftInvOn (f' ∘ g') (g ∘ f) s := fun x h =>\n  calc\n    (f' ∘ g') ((g ∘ f) x) = f' (f x) := congr_arg f' (hg' (hf h))\n    _ = x := hf' h\n\n"}
{"name":"Set.LeftInvOn.mono","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nf : α → β\nf' : β → α\nhf : Set.LeftInvOn f' f s\nht : HasSubset.Subset s₁ s\n⊢ Set.LeftInvOn f' f s₁","decl":"theorem mono (hf : LeftInvOn f' f s) (ht : s₁ ⊆ s) : LeftInvOn f' f s₁ := fun _ hx =>\n  hf (ht hx)\n\n"}
{"name":"Set.LeftInvOn.image_inter'","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nf : α → β\nf' : β → α\nhf : Set.LeftInvOn f' f s\n⊢ Eq (Set.image f (Inter.inter s₁ s)) (Inter.inter (Set.preimage f' s₁) (Set.image f s))","decl":"theorem image_inter' (hf : LeftInvOn f' f s) : f '' (s₁ ∩ s) = f' ⁻¹' s₁ ∩ f '' s := by\n  apply Subset.antisymm\n  · rintro _ ⟨x, ⟨h₁, h⟩, rfl⟩\n    exact ⟨by rwa [mem_preimage, hf h], mem_image_of_mem _ h⟩\n  · rintro _ ⟨h₁, ⟨x, h, rfl⟩⟩\n    exact mem_image_of_mem _ ⟨by rwa [← hf h], h⟩\n\n"}
{"name":"Set.LeftInvOn.image_inter","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nf : α → β\nf' : β → α\nhf : Set.LeftInvOn f' f s\n⊢ Eq (Set.image f (Inter.inter s₁ s)) (Inter.inter (Set.preimage f' (Inter.inter s₁ s)) (Set.image f s))","decl":"theorem image_inter (hf : LeftInvOn f' f s) :\n    f '' (s₁ ∩ s) = f' ⁻¹' (s₁ ∩ s) ∩ f '' s := by\n  rw [hf.image_inter']\n  refine Subset.antisymm ?_ (inter_subset_inter_left _ (preimage_mono inter_subset_left))\n  rintro _ ⟨h₁, x, hx, rfl⟩; exact ⟨⟨h₁, by rwa [hf hx]⟩, mem_image_of_mem _ hx⟩\n\n"}
{"name":"Set.LeftInvOn.image_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nf' : β → α\nhf : Set.LeftInvOn f' f s\n⊢ Eq (Set.image f' (Set.image f s)) s","decl":"theorem image_image (hf : LeftInvOn f' f s) : f' '' (f '' s) = s := by\n  rw [Set.image_image, image_congr hf, image_id']\n\n"}
{"name":"Set.LeftInvOn.image_image'","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nf : α → β\nf' : β → α\nhf : Set.LeftInvOn f' f s\nhs : HasSubset.Subset s₁ s\n⊢ Eq (Set.image f' (Set.image f s₁)) s₁","decl":"theorem image_image' (hf : LeftInvOn f' f s) (hs : s₁ ⊆ s) : f' '' (f '' s₁) = s₁ :=\n  (hf.mono hs).image_image\n\n"}
{"name":"Set.RightInvOn.eqOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nf' : β → α\nh : Set.RightInvOn f' f t\n⊢ Set.EqOn (Function.comp f f') id t","decl":"theorem eqOn (h : RightInvOn f' f t) : EqOn (f ∘ f') id t :=\n  h\n\n"}
{"name":"Set.RightInvOn.eq","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nf' : β → α\nh : Set.RightInvOn f' f t\ny : β\nhy : Membership.mem t y\n⊢ Eq (f (f' y)) y","decl":"theorem eq (h : RightInvOn f' f t) {y} (hy : y ∈ t) : f (f' y) = y :=\n  h hy\n\n"}
{"name":"Set.LeftInvOn.rightInvOn_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nf' : β → α\nh : Set.LeftInvOn f' f s\n⊢ Set.RightInvOn f' f (Set.image f s)","decl":"theorem _root_.Set.LeftInvOn.rightInvOn_image (h : LeftInvOn f' f s) : RightInvOn f' f (f '' s) :=\n  fun _y ⟨_x, hx, heq⟩ => heq ▸ (congr_arg f <| h.eq hx)\n\n"}
{"name":"Set.RightInvOn.congr_left","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nf₁' f₂' : β → α\nh₁ : Set.RightInvOn f₁' f t\nheq : Set.EqOn f₁' f₂' t\n⊢ Set.RightInvOn f₂' f t","decl":"theorem congr_left (h₁ : RightInvOn f₁' f t) (heq : EqOn f₁' f₂' t) :\n    RightInvOn f₂' f t :=\n  h₁.congr_right heq\n\n"}
{"name":"Set.RightInvOn.congr_right","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf₁ f₂ : α → β\nf' : β → α\nh₁ : Set.RightInvOn f' f₁ t\nhg : Set.MapsTo f' t s\nheq : Set.EqOn f₁ f₂ s\n⊢ Set.RightInvOn f' f₂ t","decl":"theorem congr_right (h₁ : RightInvOn f' f₁ t) (hg : MapsTo f' t s) (heq : EqOn f₁ f₂ s) :\n    RightInvOn f' f₂ t :=\n  LeftInvOn.congr_left h₁ hg heq\n\n"}
{"name":"Set.RightInvOn.surjOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nf' : β → α\nhf : Set.RightInvOn f' f t\nhf' : Set.MapsTo f' t s\n⊢ Set.SurjOn f s t","decl":"theorem surjOn (hf : RightInvOn f' f t) (hf' : MapsTo f' t s) : SurjOn f s t :=\n  LeftInvOn.surjOn hf hf'\n\n"}
{"name":"Set.RightInvOn.mapsTo","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nf' : β → α\nh : Set.RightInvOn f' f t\nhf : Set.SurjOn f' t s\n⊢ Set.MapsTo f s t","decl":"theorem mapsTo (h : RightInvOn f' f t) (hf : SurjOn f' t s) : MapsTo f s t :=\n  LeftInvOn.mapsTo h hf\n\n"}
{"name":"Set.rightInvOn_id","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ns : Set α\n⊢ Set.RightInvOn id id s","decl":"lemma _root_.Set.rightInvOn_id (s : Set α) : RightInvOn id id s := fun _ _ ↦ rfl\n\n"}
{"name":"Set.RightInvOn.comp","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nt : Set β\np : Set γ\nf : α → β\ng : β → γ\nf' : β → α\ng' : γ → β\nhf : Set.RightInvOn f' f t\nhg : Set.RightInvOn g' g p\ng'pt : Set.MapsTo g' p t\n⊢ Set.RightInvOn (Function.comp f' g') (Function.comp g f) p","decl":"theorem comp (hf : RightInvOn f' f t) (hg : RightInvOn g' g p) (g'pt : MapsTo g' p t) :\n    RightInvOn (f' ∘ g') (g ∘ f) p :=\n  LeftInvOn.comp hg hf g'pt\n\n"}
{"name":"Set.RightInvOn.mono","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt t₁ : Set β\nf : α → β\nf' : β → α\nhf : Set.RightInvOn f' f t\nht : HasSubset.Subset t₁ t\n⊢ Set.RightInvOn f' f t₁","decl":"theorem mono (hf : RightInvOn f' f t) (ht : t₁ ⊆ t) : RightInvOn f' f t₁ :=\n  LeftInvOn.mono hf ht\n"}
{"name":"Set.InjOn.rightInvOn_of_leftInvOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nf' : β → α\nhf : Set.InjOn f s\nhf' : Set.LeftInvOn f f' t\nh₁ : Set.MapsTo f s t\nh₂ : Set.MapsTo f' t s\n⊢ Set.RightInvOn f f' s","decl":"theorem InjOn.rightInvOn_of_leftInvOn (hf : InjOn f s) (hf' : LeftInvOn f f' t)\n    (h₁ : MapsTo f s t) (h₂ : MapsTo f' t s) : RightInvOn f f' s := fun _ h =>\n  hf (h₂ <| h₁ h) h (hf' (h₁ h))\n\n"}
{"name":"Set.eqOn_of_leftInvOn_of_rightInvOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nf₁' f₂' : β → α\nh₁ : Set.LeftInvOn f₁' f s\nh₂ : Set.RightInvOn f₂' f t\nh : Set.MapsTo f₂' t s\n⊢ Set.EqOn f₁' f₂' t","decl":"theorem eqOn_of_leftInvOn_of_rightInvOn (h₁ : LeftInvOn f₁' f s) (h₂ : RightInvOn f₂' f t)\n    (h : MapsTo f₂' t s) : EqOn f₁' f₂' t := fun y hy =>\n  calc\n    f₁' y = (f₁' ∘ f ∘ f₂') y := congr_arg f₁' (h₂ hy).symm\n    _ = f₂' y := h₁ (h hy)\n\n"}
{"name":"Set.SurjOn.leftInvOn_of_rightInvOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nf' : β → α\nhf : Set.SurjOn f s t\nhf' : Set.RightInvOn f f' s\n⊢ Set.LeftInvOn f f' t","decl":"theorem SurjOn.leftInvOn_of_rightInvOn (hf : SurjOn f s t) (hf' : RightInvOn f f' s) :\n    LeftInvOn f f' t := fun y hy => by\n  let ⟨x, hx, heq⟩ := hf hy\n  rw [← heq, hf' hx]\n\n"}
{"name":"Set.invOn_id","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ns : Set α\n⊢ Set.InvOn id id s s","decl":"lemma _root_.Set.invOn_id (s : Set α) : InvOn id id s s := ⟨s.leftInvOn_id, s.rightInvOn_id⟩\n\n"}
{"name":"Set.InvOn.comp","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\np : Set γ\nf : α → β\ng : β → γ\nf' : β → α\ng' : γ → β\nhf : Set.InvOn f' f s t\nhg : Set.InvOn g' g t p\nfst : Set.MapsTo f s t\ng'pt : Set.MapsTo g' p t\n⊢ Set.InvOn (Function.comp f' g') (Function.comp g f) s p","decl":"lemma comp (hf : InvOn f' f s t) (hg : InvOn g' g t p) (fst : MapsTo f s t)\n    (g'pt : MapsTo g' p t) :\n    InvOn (f' ∘ g') (g ∘ f) s p :=\n  ⟨hf.1.comp hg.1 fst, hf.2.comp hg.2 g'pt⟩\n\n"}
{"name":"Set.InvOn.symm","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nf' : β → α\nh : Set.InvOn f' f s t\n⊢ Set.InvOn f f' t s","decl":"@[symm]\ntheorem symm (h : InvOn f' f s t) : InvOn f f' t s :=\n  ⟨h.right, h.left⟩\n\n"}
{"name":"Set.InvOn.mono","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nt t₁ : Set β\nf : α → β\nf' : β → α\nh : Set.InvOn f' f s t\nhs : HasSubset.Subset s₁ s\nht : HasSubset.Subset t₁ t\n⊢ Set.InvOn f' f s₁ t₁","decl":"theorem mono (h : InvOn f' f s t) (hs : s₁ ⊆ s) (ht : t₁ ⊆ t) : InvOn f' f s₁ t₁ :=\n  ⟨h.1.mono hs, h.2.mono ht⟩\n\n"}
{"name":"Set.InvOn.bijOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nf' : β → α\nh : Set.InvOn f' f s t\nhf : Set.MapsTo f s t\nhf' : Set.MapsTo f' t s\n⊢ Set.BijOn f s t","decl":"/-- If functions `f'` and `f` are inverse on `s` and `t`, `f` maps `s` into `t`, and `f'` maps `t`\ninto `s`, then `f` is a bijection between `s` and `t`. The `mapsTo` arguments can be deduced from\n`surjOn` statements using `LeftInvOn.mapsTo` and `RightInvOn.mapsTo`. -/\ntheorem bijOn (h : InvOn f' f s t) (hf : MapsTo f s t) (hf' : MapsTo f' t s) : BijOn f s t :=\n  ⟨hf, h.left.injOn, h.right.surjOn hf'⟩\n\n"}
{"name":"Function.invFunOn_pos","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nb : β\ninst✝ : Nonempty α\nh : Exists fun a => And (Membership.mem s a) (Eq (f a) b)\n⊢ And (Membership.mem s (Function.invFunOn f s b)) (Eq (f (Function.invFunOn f s b)) b)","decl":"theorem invFunOn_pos (h : ∃ a ∈ s, f a = b) : invFunOn f s b ∈ s ∧ f (invFunOn f s b) = b := by\n  rw [invFunOn, dif_pos h]\n  exact Classical.choose_spec h\n\n"}
{"name":"Function.invFunOn_mem","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nb : β\ninst✝ : Nonempty α\nh : Exists fun a => And (Membership.mem s a) (Eq (f a) b)\n⊢ Membership.mem s (Function.invFunOn f s b)","decl":"theorem invFunOn_mem (h : ∃ a ∈ s, f a = b) : invFunOn f s b ∈ s :=\n  (invFunOn_pos h).left\n\n"}
{"name":"Function.invFunOn_eq","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nb : β\ninst✝ : Nonempty α\nh : Exists fun a => And (Membership.mem s a) (Eq (f a) b)\n⊢ Eq (f (Function.invFunOn f s b)) b","decl":"theorem invFunOn_eq (h : ∃ a ∈ s, f a = b) : f (invFunOn f s b) = b :=\n  (invFunOn_pos h).right\n\n"}
{"name":"Function.invFunOn_neg","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nb : β\ninst✝ : Nonempty α\nh : Not (Exists fun a => And (Membership.mem s a) (Eq (f a) b))\n⊢ Eq (Function.invFunOn f s b) (Classical.choice ⋯)","decl":"theorem invFunOn_neg (h : ¬∃ a ∈ s, f a = b) : invFunOn f s b = Classical.choice ‹Nonempty α› := by\n  rw [invFunOn, dif_neg h]\n\n"}
{"name":"Function.invFunOn_apply_mem","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\na : α\ninst✝ : Nonempty α\nh : Membership.mem s a\n⊢ Membership.mem s (Function.invFunOn f s (f a))","decl":"@[simp]\ntheorem invFunOn_apply_mem (h : a ∈ s) : invFunOn f s (f a) ∈ s :=\n  invFunOn_mem ⟨a, h, rfl⟩\n\n"}
{"name":"Function.invFunOn_apply_eq","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\na : α\ninst✝ : Nonempty α\nh : Membership.mem s a\n⊢ Eq (f (Function.invFunOn f s (f a))) (f a)","decl":"theorem invFunOn_apply_eq (h : a ∈ s) : f (invFunOn f s (f a)) = f a :=\n  invFunOn_eq ⟨a, h, rfl⟩\n\n"}
{"name":"Set.InjOn.leftInvOn_invFunOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\ninst✝ : Nonempty α\nh : Set.InjOn f s\n⊢ Set.LeftInvOn (Function.invFunOn f s) f s","decl":"theorem InjOn.leftInvOn_invFunOn [Nonempty α] (h : InjOn f s) : LeftInvOn (invFunOn f s) f s :=\n  fun _a ha => h (invFunOn_apply_mem ha) ha (invFunOn_apply_eq ha)\n\n"}
{"name":"Set.InjOn.invFunOn_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Set α\nf : α → β\ninst✝ : Nonempty α\nh : Set.InjOn f s₂\nht : HasSubset.Subset s₁ s₂\n⊢ Eq (Set.image (Function.invFunOn f s₂) (Set.image f s₁)) s₁","decl":"theorem InjOn.invFunOn_image [Nonempty α] (h : InjOn f s₂) (ht : s₁ ⊆ s₂) :\n    invFunOn f s₂ '' (f '' s₁) = s₁ :=\n  h.leftInvOn_invFunOn.image_image' ht\n\n"}
{"name":"Function.leftInvOn_invFunOn_of_subset_image_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\ninst✝ : Nonempty α\nh : HasSubset.Subset s (Set.image (Function.invFunOn f s) (Set.image f s))\n⊢ Set.LeftInvOn (Function.invFunOn f s) f s","decl":"theorem _root_.Function.leftInvOn_invFunOn_of_subset_image_image [Nonempty α]\n    (h : s ⊆ (invFunOn f s) '' (f '' s)) : LeftInvOn (invFunOn f s) f s :=\n  fun x hx ↦ by\n    obtain ⟨-, ⟨x, hx', rfl⟩, rfl⟩ := h hx\n    rw [invFunOn_apply_eq (f := f) hx']\n\n"}
{"name":"Set.injOn_iff_invFunOn_image_image_eq_self","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\ninst✝ : Nonempty α\n⊢ Iff (Set.InjOn f s) (Eq (Set.image (Function.invFunOn f s) (Set.image f s)) s)","decl":"theorem injOn_iff_invFunOn_image_image_eq_self [Nonempty α] :\n    InjOn f s ↔ (invFunOn f s) '' (f '' s) = s :=\n  ⟨fun h ↦ h.invFunOn_image Subset.rfl, fun h ↦\n    (Function.leftInvOn_invFunOn_of_subset_image_image h.symm.subset).injOn⟩\n\n"}
{"name":"Function.invFunOn_injOn_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty α\nf : α → β\ns : Set α\n⊢ Set.InjOn (Function.invFunOn f s) (Set.image f s)","decl":"theorem _root_.Function.invFunOn_injOn_image [Nonempty α] (f : α → β) (s : Set α) :\n    Set.InjOn (invFunOn f s) (f '' s) := by\n  rintro _ ⟨x, hx, rfl⟩ _ ⟨x', hx', rfl⟩ he\n  rw [← invFunOn_apply_eq (f := f) hx, he, invFunOn_apply_eq (f := f) hx']\n\n"}
{"name":"Function.invFunOn_image_image_subset","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty α\nf : α → β\ns : Set α\n⊢ HasSubset.Subset (Set.image (Function.invFunOn f s) (Set.image f s)) s","decl":"theorem _root_.Function.invFunOn_image_image_subset [Nonempty α] (f : α → β) (s : Set α) :\n    (invFunOn f s) '' (f '' s) ⊆ s := by\n  rintro _ ⟨_, ⟨x,hx,rfl⟩, rfl⟩; exact invFunOn_apply_mem hx\n\n"}
{"name":"Set.SurjOn.rightInvOn_invFunOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\ninst✝ : Nonempty α\nh : Set.SurjOn f s t\n⊢ Set.RightInvOn (Function.invFunOn f s) f t","decl":"theorem SurjOn.rightInvOn_invFunOn [Nonempty α] (h : SurjOn f s t) :\n    RightInvOn (invFunOn f s) f t := fun _y hy => invFunOn_eq <| h hy\n\n"}
{"name":"Set.BijOn.invOn_invFunOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\ninst✝ : Nonempty α\nh : Set.BijOn f s t\n⊢ Set.InvOn (Function.invFunOn f s) f s t","decl":"theorem BijOn.invOn_invFunOn [Nonempty α] (h : BijOn f s t) : InvOn (invFunOn f s) f s t :=\n  ⟨h.injOn.leftInvOn_invFunOn, h.surjOn.rightInvOn_invFunOn⟩\n\n"}
{"name":"Set.SurjOn.invOn_invFunOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\ninst✝ : Nonempty α\nh : Set.SurjOn f s t\n⊢ Set.InvOn (Function.invFunOn f s) f (Set.image (Function.invFunOn f s) t) t","decl":"theorem SurjOn.invOn_invFunOn [Nonempty α] (h : SurjOn f s t) :\n    InvOn (invFunOn f s) f (invFunOn f s '' t) t := by\n  refine ⟨?_, h.rightInvOn_invFunOn⟩\n  rintro _ ⟨y, hy, rfl⟩\n  rw [h.rightInvOn_invFunOn hy]\n\n"}
{"name":"Set.SurjOn.mapsTo_invFunOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\ninst✝ : Nonempty α\nh : Set.SurjOn f s t\n⊢ Set.MapsTo (Function.invFunOn f s) t s","decl":"theorem SurjOn.mapsTo_invFunOn [Nonempty α] (h : SurjOn f s t) : MapsTo (invFunOn f s) t s :=\n  fun _y hy => mem_preimage.2 <| invFunOn_mem <| h hy\n\n"}
{"name":"Set.SurjOn.image_invFunOn_image_of_subset","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\ninst✝ : Nonempty α\nr : Set β\nhf : Set.SurjOn f s t\nhrt : HasSubset.Subset r t\n⊢ Eq (Set.image f (Set.image (Function.invFunOn f s) r)) r","decl":"/-- This lemma is a special case of `rightInvOn_invFunOn.image_image'`; it may make more sense\nto use the other lemma directly in an application. -/\ntheorem SurjOn.image_invFunOn_image_of_subset [Nonempty α] {r : Set β} (hf : SurjOn f s t)\n    (hrt : r ⊆ t) : f '' (f.invFunOn s '' r) = r :=\n  hf.rightInvOn_invFunOn.image_image' hrt\n\n"}
{"name":"Set.SurjOn.image_invFunOn_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\ninst✝ : Nonempty α\nhf : Set.SurjOn f s t\n⊢ Eq (Set.image f (Set.image (Function.invFunOn f s) t)) t","decl":"/-- This lemma is a special case of `rightInvOn_invFunOn.image_image`; it may make more sense\nto use the other lemma directly in an application. -/\ntheorem SurjOn.image_invFunOn_image [Nonempty α] (hf : SurjOn f s t) :\n    f '' (f.invFunOn s '' t) = t :=\n  hf.rightInvOn_invFunOn.image_image\n\n"}
{"name":"Set.SurjOn.bijOn_subset","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\ninst✝ : Nonempty α\nh : Set.SurjOn f s t\n⊢ Set.BijOn f (Set.image (Function.invFunOn f s) t) t","decl":"theorem SurjOn.bijOn_subset [Nonempty α] (h : SurjOn f s t) : BijOn f (invFunOn f s '' t) t := by\n  refine h.invOn_invFunOn.bijOn ?_ (mapsTo_image _ _)\n  rintro _ ⟨y, hy, rfl⟩\n  rwa [h.rightInvOn_invFunOn hy]\n\n"}
{"name":"Set.surjOn_iff_exists_bijOn_subset","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\n⊢ Iff (Set.SurjOn f s t) (Exists fun s' => And (HasSubset.Subset s' s) (Set.BijOn f s' t))","decl":"theorem surjOn_iff_exists_bijOn_subset : SurjOn f s t ↔ ∃ s' ⊆ s, BijOn f s' t := by\n  constructor\n  · rcases eq_empty_or_nonempty t with (rfl | ht)\n    · exact fun _ => ⟨∅, empty_subset _, bijOn_empty f⟩\n    · intro h\n      haveI : Nonempty α := ⟨Classical.choose (h.comap_nonempty ht)⟩\n      exact ⟨_, h.mapsTo_invFunOn.image_subset, h.bijOn_subset⟩\n  · rintro ⟨s', hs', hfs'⟩\n    exact hfs'.surjOn.mono hs' (Subset.refl _)\n\n"}
{"name":"Set.SurjOn.exists_bijOn_subset","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\na✝ : Set.SurjOn f s t\n⊢ Exists fun s' => And (HasSubset.Subset s' s) (Set.BijOn f s' t)","decl":"alias ⟨SurjOn.exists_bijOn_subset, _⟩ := Set.surjOn_iff_exists_bijOn_subset\n\n"}
{"name":"Set.exists_subset_bijOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Exists fun s' => And (HasSubset.Subset s' s) (Set.BijOn f s' (Set.image f s))","decl":"lemma exists_subset_bijOn : ∃ s' ⊆ s, BijOn f s' (f '' s) :=\n  surjOn_iff_exists_bijOn_subset.mp (surjOn_image f s)\n\n"}
{"name":"Set.exists_image_eq_and_injOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Exists fun u => And (Eq (Set.image f u) (Set.image f s)) (Set.InjOn f u)","decl":"lemma exists_image_eq_and_injOn : ∃ u, f '' u =  f '' s ∧ InjOn f u :=\n  let ⟨u, _, hfu⟩ := exists_subset_bijOn s f\n  ⟨u, hfu.image_eq, hfu.injOn⟩\n\n"}
{"name":"Set.exists_image_eq_injOn_of_subset_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nht : HasSubset.Subset t (Set.range f)\n⊢ Exists fun s => And (Eq (Set.image f s) t) (Set.InjOn f s)","decl":"lemma exists_image_eq_injOn_of_subset_range (ht : t ⊆ range f) :\n    ∃ s, f '' s = t ∧ InjOn f s :=\n  image_preimage_eq_of_subset ht ▸ exists_image_eq_and_injOn _ _\n\n"}
{"name":"Set.BijOn.exists_extend_of_subset","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ : Set α\nt : Set β\nf : α → β\nt' : Set β\nh : Set.BijOn f s t\nhss₁ : HasSubset.Subset s s₁\nhtt' : HasSubset.Subset t t'\nht' : Set.SurjOn f s₁ t'\n⊢ Exists fun s' => And (HasSubset.Subset s s') (And (HasSubset.Subset s' s₁) (Set.BijOn f s' t'))","decl":"/-- If `f` maps `s` bijectively to `t` and a set `t'` is contained in the image of some `s₁ ⊇ s`,\nthen `s₁` has a subset containing `s` that `f` maps bijectively to `t'`.-/\ntheorem BijOn.exists_extend_of_subset {t' : Set β} (h : BijOn f s t) (hss₁ : s ⊆ s₁) (htt' : t ⊆ t')\n    (ht' : SurjOn f s₁ t') : ∃ s', s ⊆ s' ∧ s' ⊆ s₁ ∧ Set.BijOn f s' t' := by\n  obtain ⟨r, hrss, hbij⟩ := exists_subset_bijOn ((s₁ ∩ f ⁻¹' t') \\ f ⁻¹' t) f\n  rw [image_diff_preimage, image_inter_preimage] at hbij\n  refine ⟨s ∪ r, subset_union_left, ?_, ?_, ?_, fun y hyt' ↦ ?_⟩\n  · exact union_subset hss₁ <| hrss.trans <| diff_subset.trans inter_subset_left\n  · rw [mapsTo', image_union, hbij.image_eq, h.image_eq, union_subset_iff]\n    exact ⟨htt', diff_subset.trans inter_subset_right⟩\n  · rw [injOn_union, and_iff_right h.injOn, and_iff_right hbij.injOn]\n    · refine fun x hxs y hyr hxy ↦ (hrss hyr).2 ?_\n      rw [← h.image_eq]\n      exact ⟨x, hxs, hxy⟩\n    exact (subset_diff.1 hrss).2.symm.mono_left h.mapsTo\n  rw [image_union, h.image_eq, hbij.image_eq, union_diff_self]\n  exact .inr ⟨ht' hyt', hyt'⟩\n\n"}
{"name":"Set.BijOn.exists_extend","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nt' : Set β\nh : Set.BijOn f s t\nhtt' : HasSubset.Subset t t'\nht' : HasSubset.Subset t' (Set.range f)\n⊢ Exists fun s' => And (HasSubset.Subset s s') (Set.BijOn f s' t')","decl":"/-- If `f` maps `s` bijectively to `t`, and `t'` is a superset of `t` contained in the range of `f`,\nthen `f` maps some superset of `s` bijectively to `t'`. -/\ntheorem BijOn.exists_extend {t' : Set β} (h : BijOn f s t) (htt' : t ⊆ t') (ht' : t' ⊆ range f) :\n    ∃ s', s ⊆ s' ∧ BijOn f s' t' := by\n  simpa using h.exists_extend_of_subset (subset_univ s) htt' (by simpa [SurjOn])\n\n"}
{"name":"Set.InjOn.exists_subset_injOn_subset_range_eq","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nr : Set α\nhinj : Set.InjOn f r\nhrs : HasSubset.Subset r s\n⊢ Exists fun u => And (HasSubset.Subset r u) (And (HasSubset.Subset u s) (And (Eq (Set.image f u) (Set.image f s)) (Set.InjOn f u)))","decl":"theorem InjOn.exists_subset_injOn_subset_range_eq {r : Set α} (hinj : InjOn f r) (hrs : r ⊆ s) :\n    ∃ u : Set α, r ⊆ u ∧ u ⊆ s ∧ f '' u = f '' s ∧ InjOn f u := by\n  obtain ⟨u, hru, hus, h⟩ := hinj.bijOn_image.exists_extend_of_subset hrs\n    (image_subset f hrs) Subset.rfl\n  exact ⟨u, hru, hus, h.image_eq, h.injOn⟩\n\n"}
{"name":"Set.preimage_invFun_of_mem","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nonempty α\nf : α → β\nhf : Function.Injective f\ns : Set α\nh : Membership.mem s (Classical.choice n)\n⊢ Eq (Set.preimage (Function.invFun f) s) (Union.union (Set.image f s) (HasCompl.compl (Set.range f)))","decl":"theorem preimage_invFun_of_mem [n : Nonempty α] {f : α → β} (hf : Injective f) {s : Set α}\n    (h : Classical.choice n ∈ s) : invFun f ⁻¹' s = f '' s ∪ (range f)ᶜ := by\n  ext x\n  rcases em (x ∈ range f) with (⟨a, rfl⟩ | hx)\n  · simp only [mem_preimage, mem_union, mem_compl_iff, mem_range_self, not_true, or_false,\n      leftInverse_invFun hf _, hf.mem_set_image]\n  · simp only [mem_preimage, invFun_neg hx, h, hx, mem_union, mem_compl_iff, not_false_iff, or_true]\n\n"}
{"name":"Set.preimage_invFun_of_not_mem","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nonempty α\nf : α → β\nhf : Function.Injective f\ns : Set α\nh : Not (Membership.mem s (Classical.choice n))\n⊢ Eq (Set.preimage (Function.invFun f) s) (Set.image f s)","decl":"theorem preimage_invFun_of_not_mem [n : Nonempty α] {f : α → β} (hf : Injective f) {s : Set α}\n    (h : Classical.choice n ∉ s) : invFun f ⁻¹' s = f '' s := by\n  ext x\n  rcases em (x ∈ range f) with (⟨a, rfl⟩ | hx)\n  · rw [mem_preimage, leftInverse_invFun hf, hf.mem_set_image]\n  · have : x ∉ f '' s := fun h' => hx (image_subset_range _ _ h')\n    simp only [mem_preimage, invFun_neg hx, h, this]\n\n"}
{"name":"Set.BijOn.symm","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\ng : β → α\nh : Set.InvOn f g t s\nhf : Set.BijOn f s t\n⊢ Set.BijOn g t s","decl":"lemma BijOn.symm {g : β → α} (h : InvOn f g t s) (hf : BijOn f s t) : BijOn g t s :=\n  ⟨h.2.mapsTo hf.surjOn, h.1.injOn, h.2.surjOn hf.mapsTo⟩\n\n"}
{"name":"Set.bijOn_comm","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\ng : β → α\nh : Set.InvOn f g t s\n⊢ Iff (Set.BijOn f s t) (Set.BijOn g t s)","decl":"lemma bijOn_comm {g : β → α} (h : InvOn f g t s) : BijOn f s t ↔ BijOn g t s :=\n  ⟨BijOn.symm h, BijOn.symm h.symm⟩\n\n"}
{"name":"Set.piecewise_empty","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Sort u_7\nf g : (i : α) → δ i\ninst✝ : (i : α) → Decidable (Membership.mem EmptyCollection.emptyCollection i)\n⊢ Eq (EmptyCollection.emptyCollection.piecewise f g) g","decl":"@[simp]\ntheorem piecewise_empty [∀ i : α, Decidable (i ∈ (∅ : Set α))] : piecewise ∅ f g = g := by\n  ext i\n  simp [piecewise]\n\n"}
{"name":"Set.piecewise_univ","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Sort u_7\nf g : (i : α) → δ i\ninst✝ : (i : α) → Decidable (Membership.mem Set.univ i)\n⊢ Eq (Set.univ.piecewise f g) f","decl":"@[simp]\ntheorem piecewise_univ [∀ i : α, Decidable (i ∈ (Set.univ : Set α))] :\n    piecewise Set.univ f g = f := by\n  ext i\n  simp [piecewise]\n\n"}
{"name":"Set.piecewise_insert_self","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Sort u_7\ns : Set α\nf g : (i : α) → δ i\nj : α\ninst✝ : (i : α) → Decidable (Membership.mem (Insert.insert j s) i)\n⊢ Eq ((Insert.insert j s).piecewise f g j) (f j)","decl":"theorem piecewise_insert_self {j : α} [∀ i, Decidable (i ∈ insert j s)] :\n    (insert j s).piecewise f g j = f j := by simp [piecewise]\n\n"}
{"name":"Set.piecewise_insert","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Sort u_7\ns : Set α\nf g : (i : α) → δ i\ninst✝² : (j : α) → Decidable (Membership.mem s j)\ninst✝¹ : DecidableEq α\nj : α\ninst✝ : (i : α) → Decidable (Membership.mem (Insert.insert j s) i)\n⊢ Eq ((Insert.insert j s).piecewise f g) (Function.update (s.piecewise f g) j (f j))","decl":"theorem piecewise_insert [DecidableEq α] (j : α) [∀ i, Decidable (i ∈ insert j s)] :\n    (insert j s).piecewise f g = Function.update (s.piecewise f g) j (f j) := by\n  simp (config := { unfoldPartialApp := true }) only [piecewise, mem_insert_iff]\n  ext i\n  by_cases h : i = j\n  · rw [h]\n    simp\n  · by_cases h' : i ∈ s <;> simp [h, h']\n\n"}
{"name":"Set.piecewise_eq_of_mem","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Sort u_7\ns : Set α\nf g : (i : α) → δ i\ninst✝ : (j : α) → Decidable (Membership.mem s j)\ni : α\nhi : Membership.mem s i\n⊢ Eq (s.piecewise f g i) (f i)","decl":"@[simp]\ntheorem piecewise_eq_of_mem {i : α} (hi : i ∈ s) : s.piecewise f g i = f i :=\n  if_pos hi\n\n"}
{"name":"Set.piecewise_eq_of_not_mem","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Sort u_7\ns : Set α\nf g : (i : α) → δ i\ninst✝ : (j : α) → Decidable (Membership.mem s j)\ni : α\nhi : Not (Membership.mem s i)\n⊢ Eq (s.piecewise f g i) (g i)","decl":"@[simp]\ntheorem piecewise_eq_of_not_mem {i : α} (hi : i ∉ s) : s.piecewise f g i = g i :=\n  if_neg hi\n\n"}
{"name":"Set.piecewise_singleton","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nx : α\ninst✝¹ : (y : α) → Decidable (Membership.mem (Singleton.singleton x) y)\ninst✝ : DecidableEq α\nf g : α → β\n⊢ Eq ((Singleton.singleton x).piecewise f g) (Function.update g x (f x))","decl":"theorem piecewise_singleton (x : α) [∀ y, Decidable (y ∈ ({x} : Set α))] [DecidableEq α]\n    (f g : α → β) : piecewise {x} f g = Function.update g x (f x) := by\n  ext y\n  by_cases hy : y = x\n  · subst y\n    simp\n  · simp [hy]\n\n"}
{"name":"Set.piecewise_eqOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nf g : α → β\n⊢ Set.EqOn (s.piecewise f g) f s","decl":"theorem piecewise_eqOn (f g : α → β) : EqOn (s.piecewise f g) f s := fun _ =>\n  piecewise_eq_of_mem _ _ _\n\n"}
{"name":"Set.piecewise_eqOn_compl","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nf g : α → β\n⊢ Set.EqOn (s.piecewise f g) g (HasCompl.compl s)","decl":"theorem piecewise_eqOn_compl (f g : α → β) : EqOn (s.piecewise f g) g sᶜ := fun _ =>\n  piecewise_eq_of_not_mem _ _ _\n\n"}
{"name":"Set.piecewise_le","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Type u_8\ninst✝¹ : (i : α) → Preorder (δ i)\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nf₁ f₂ g : (i : α) → δ i\nh₁ : ∀ (i : α), Membership.mem s i → LE.le (f₁ i) (g i)\nh₂ : ∀ (i : α), Not (Membership.mem s i) → LE.le (f₂ i) (g i)\n⊢ LE.le (s.piecewise f₁ f₂) g","decl":"theorem piecewise_le {δ : α → Type*} [∀ i, Preorder (δ i)] {s : Set α} [∀ j, Decidable (j ∈ s)]\n    {f₁ f₂ g : ∀ i, δ i} (h₁ : ∀ i ∈ s, f₁ i ≤ g i) (h₂ : ∀ i ∉ s, f₂ i ≤ g i) :\n    s.piecewise f₁ f₂ ≤ g := fun i => if h : i ∈ s then by simp [*] else by simp [*]\n\n"}
{"name":"Set.le_piecewise","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Type u_8\ninst✝¹ : (i : α) → Preorder (δ i)\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nf₁ f₂ g : (i : α) → δ i\nh₁ : ∀ (i : α), Membership.mem s i → LE.le (g i) (f₁ i)\nh₂ : ∀ (i : α), Not (Membership.mem s i) → LE.le (g i) (f₂ i)\n⊢ LE.le g (s.piecewise f₁ f₂)","decl":"theorem le_piecewise {δ : α → Type*} [∀ i, Preorder (δ i)] {s : Set α} [∀ j, Decidable (j ∈ s)]\n    {f₁ f₂ g : ∀ i, δ i} (h₁ : ∀ i ∈ s, g i ≤ f₁ i) (h₂ : ∀ i ∉ s, g i ≤ f₂ i) :\n    g ≤ s.piecewise f₁ f₂ :=\n  @piecewise_le α (fun i => (δ i)ᵒᵈ) _ s _ _ _ _ h₁ h₂\n\n"}
{"name":"Set.piecewise_mono","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Type u_8\ninst✝¹ : (i : α) → Preorder (δ i)\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nf₁ f₂ g₁ g₂ : (i : α) → δ i\nh₁ : ∀ (i : α), Membership.mem s i → LE.le (f₁ i) (g₁ i)\nh₂ : ∀ (i : α), Not (Membership.mem s i) → LE.le (f₂ i) (g₂ i)\n⊢ LE.le (s.piecewise f₁ f₂) (s.piecewise g₁ g₂)","decl":"@[gcongr]\ntheorem piecewise_mono {δ : α → Type*} [∀ i, Preorder (δ i)] {s : Set α}\n    [∀ j, Decidable (j ∈ s)] {f₁ f₂ g₁ g₂ : ∀ i, δ i} (h₁ : ∀ i ∈ s, f₁ i ≤ g₁ i)\n    (h₂ : ∀ i ∉ s, f₂ i ≤ g₂ i) : s.piecewise f₁ f₂ ≤ s.piecewise g₁ g₂ := by\n  apply piecewise_le <;> intros <;> simp [*]\n\n"}
{"name":"Set.piecewise_le_piecewise","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Type u_8\ninst✝¹ : (i : α) → Preorder (δ i)\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nf₁ f₂ g₁ g₂ : (i : α) → δ i\nh₁ : ∀ (i : α), Membership.mem s i → LE.le (f₁ i) (g₁ i)\nh₂ : ∀ (i : α), Not (Membership.mem s i) → LE.le (f₂ i) (g₂ i)\n⊢ LE.le (s.piecewise f₁ f₂) (s.piecewise g₁ g₂)","decl":"@[deprecated (since := \"2024-10-06\")] alias piecewise_le_piecewise := piecewise_mono\n\n"}
{"name":"Set.piecewise_insert_of_ne","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Sort u_7\ns : Set α\nf g : (i : α) → δ i\ninst✝¹ : (j : α) → Decidable (Membership.mem s j)\ni j : α\nh : Ne i j\ninst✝ : (i : α) → Decidable (Membership.mem (Insert.insert j s) i)\n⊢ Eq ((Insert.insert j s).piecewise f g i) (s.piecewise f g i)","decl":"@[simp]\ntheorem piecewise_insert_of_ne {i j : α} (h : i ≠ j) [∀ i, Decidable (i ∈ insert j s)] :\n    (insert j s).piecewise f g i = s.piecewise f g i := by simp [piecewise, h]\n\n"}
{"name":"Set.piecewise_compl","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Sort u_7\ns : Set α\nf g : (i : α) → δ i\ninst✝¹ : (j : α) → Decidable (Membership.mem s j)\ninst✝ : (i : α) → Decidable (Membership.mem (HasCompl.compl s) i)\n⊢ Eq ((HasCompl.compl s).piecewise f g) (s.piecewise g f)","decl":"@[simp]\ntheorem piecewise_compl [∀ i, Decidable (i ∈ sᶜ)] : sᶜ.piecewise f g = s.piecewise g f :=\n  funext fun x => if hx : x ∈ s then by simp [hx] else by simp [hx]\n\n"}
{"name":"Set.piecewise_range_comp","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_8\nf : ι → α\ninst✝ : (j : α) → Decidable (Membership.mem (Set.range f) j)\ng₁ g₂ : α → β\n⊢ Eq (Function.comp ((Set.range f).piecewise g₁ g₂) f) (Function.comp g₁ f)","decl":"@[simp]\ntheorem piecewise_range_comp {ι : Sort*} (f : ι → α) [∀ j, Decidable (j ∈ range f)]\n    (g₁ g₂ : α → β) : (range f).piecewise g₁ g₂ ∘ f = g₁ ∘ f :=\n  (piecewise_eqOn ..).comp_eq\n\n"}
{"name":"Set.MapsTo.piecewise_ite","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns s₁ s₂ : Set α\nt t₁ t₂ : Set β\nf₁ f₂ : α → β\ninst✝ : (i : α) → Decidable (Membership.mem s i)\nh₁ : Set.MapsTo f₁ (Inter.inter s₁ s) (Inter.inter t₁ t)\nh₂ : Set.MapsTo f₂ (Inter.inter s₂ (HasCompl.compl s)) (Inter.inter t₂ (HasCompl.compl t))\n⊢ Set.MapsTo (s.piecewise f₁ f₂) (s.ite s₁ s₂) (t.ite t₁ t₂)","decl":"theorem MapsTo.piecewise_ite {s s₁ s₂ : Set α} {t t₁ t₂ : Set β} {f₁ f₂ : α → β}\n    [∀ i, Decidable (i ∈ s)] (h₁ : MapsTo f₁ (s₁ ∩ s) (t₁ ∩ t))\n    (h₂ : MapsTo f₂ (s₂ ∩ sᶜ) (t₂ ∩ tᶜ)) :\n    MapsTo (s.piecewise f₁ f₂) (s.ite s₁ s₂) (t.ite t₁ t₂) := by\n  refine (h₁.congr ?_).union_union (h₂.congr ?_)\n  exacts [(piecewise_eqOn s f₁ f₂).symm.mono inter_subset_right,\n    (piecewise_eqOn_compl s f₁ f₂).symm.mono inter_subset_right]\n\n"}
{"name":"Set.eqOn_piecewise","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nf f' g : α → β\nt : Set α\n⊢ Iff (Set.EqOn (s.piecewise f f') g t) (And (Set.EqOn f g (Inter.inter t s)) (Set.EqOn f' g (Inter.inter t (HasCompl.compl s))))","decl":"theorem eqOn_piecewise {f f' g : α → β} {t} :\n    EqOn (s.piecewise f f') g t ↔ EqOn f g (t ∩ s) ∧ EqOn f' g (t ∩ sᶜ) := by\n  simp only [EqOn, ← forall_and]\n  refine forall_congr' fun a => ?_; by_cases a ∈ s <;> simp [*]\n\n"}
{"name":"Set.EqOn.piecewise_ite'","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nf f' g : α → β\nt t' : Set α\nh : Set.EqOn f g (Inter.inter t s)\nh' : Set.EqOn f' g (Inter.inter t' (HasCompl.compl s))\n⊢ Set.EqOn (s.piecewise f f') g (s.ite t t')","decl":"theorem EqOn.piecewise_ite' {f f' g : α → β} {t t'} (h : EqOn f g (t ∩ s))\n    (h' : EqOn f' g (t' ∩ sᶜ)) : EqOn (s.piecewise f f') g (s.ite t t') := by\n  simp [eqOn_piecewise, *]\n\n"}
{"name":"Set.EqOn.piecewise_ite","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nf f' g : α → β\nt t' : Set α\nh : Set.EqOn f g t\nh' : Set.EqOn f' g t'\n⊢ Set.EqOn (s.piecewise f f') g (s.ite t t')","decl":"theorem EqOn.piecewise_ite {f f' g : α → β} {t t'} (h : EqOn f g t) (h' : EqOn f' g t') :\n    EqOn (s.piecewise f f') g (s.ite t t') :=\n  (h.mono inter_subset_left).piecewise_ite' s (h'.mono inter_subset_left)\n\n"}
{"name":"Set.piecewise_preimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nf g : α → β\nt : Set β\n⊢ Eq (Set.preimage (s.piecewise f g) t) (s.ite (Set.preimage f t) (Set.preimage g t))","decl":"theorem piecewise_preimage (f g : α → β) (t) : s.piecewise f g ⁻¹' t = s.ite (f ⁻¹' t) (g ⁻¹' t) :=\n  ext fun x => by by_cases x ∈ s <;> simp [*, Set.ite]\n\n"}
{"name":"Set.apply_piecewise","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Sort u_7\ns : Set α\nf g : (i : α) → δ i\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nδ' : α → Sort u_8\nh : (i : α) → δ i → δ' i\nx : α\n⊢ Eq (h x (s.piecewise f g x)) (s.piecewise (fun x => h x (f x)) (fun x => h x (g x)) x)","decl":"theorem apply_piecewise {δ' : α → Sort*} (h : ∀ i, δ i → δ' i) {x : α} :\n    h x (s.piecewise f g x) = s.piecewise (fun x => h x (f x)) (fun x => h x (g x)) x := by\n  by_cases hx : x ∈ s <;> simp [hx]\n\n"}
{"name":"Set.apply_piecewise₂","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Sort u_7\ns : Set α\nf g : (i : α) → δ i\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nδ' : α → Sort u_8\nδ'' : α → Sort u_9\nf' g' : (i : α) → δ' i\nh : (i : α) → δ i → δ' i → δ'' i\nx : α\n⊢ Eq (h x (s.piecewise f g x) (s.piecewise f' g' x)) (s.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x)","decl":"theorem apply_piecewise₂ {δ' δ'' : α → Sort*} (f' g' : ∀ i, δ' i) (h : ∀ i, δ i → δ' i → δ'' i)\n    {x : α} :\n    h x (s.piecewise f g x) (s.piecewise f' g' x) =\n      s.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x := by\n  by_cases hx : x ∈ s <;> simp [hx]\n\n"}
{"name":"Set.piecewise_op","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Sort u_7\ns : Set α\nf g : (i : α) → δ i\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nδ' : α → Sort u_8\nh : (i : α) → δ i → δ' i\n⊢ Eq (s.piecewise (fun x => h x (f x)) fun x => h x (g x)) fun x => h x (s.piecewise f g x)","decl":"theorem piecewise_op {δ' : α → Sort*} (h : ∀ i, δ i → δ' i) :\n    (s.piecewise (fun x => h x (f x)) fun x => h x (g x)) = fun x => h x (s.piecewise f g x) :=\n  funext fun _ => (apply_piecewise _ _ _ _).symm\n\n"}
{"name":"Set.piecewise_op₂","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Sort u_7\ns : Set α\nf g : (i : α) → δ i\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nδ' : α → Sort u_8\nδ'' : α → Sort u_9\nf' g' : (i : α) → δ' i\nh : (i : α) → δ i → δ' i → δ'' i\n⊢ Eq (s.piecewise (fun x => h x (f x) (f' x)) fun x => h x (g x) (g' x)) fun x => h x (s.piecewise f g x) (s.piecewise f' g' x)","decl":"theorem piecewise_op₂ {δ' δ'' : α → Sort*} (f' g' : ∀ i, δ' i) (h : ∀ i, δ i → δ' i → δ'' i) :\n    (s.piecewise (fun x => h x (f x) (f' x)) fun x => h x (g x) (g' x)) = fun x =>\n      h x (s.piecewise f g x) (s.piecewise f' g' x) :=\n  funext fun _ => (apply_piecewise₂ _ _ _ _ _ _).symm\n\n"}
{"name":"Set.piecewise_same","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nδ : α → Sort u_7\ns : Set α\nf : (i : α) → δ i\ninst✝ : (j : α) → Decidable (Membership.mem s j)\n⊢ Eq (s.piecewise f f) f","decl":"@[simp]\ntheorem piecewise_same : s.piecewise f f = f := by\n  ext x\n  by_cases hx : x ∈ s <;> simp [hx]\n\n"}
{"name":"Set.range_piecewise","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nf g : α → β\n⊢ Eq (Set.range (s.piecewise f g)) (Union.union (Set.image f s) (Set.image g (HasCompl.compl s)))","decl":"theorem range_piecewise (f g : α → β) : range (s.piecewise f g) = f '' s ∪ g '' sᶜ := by\n  ext y; constructor\n  · rintro ⟨x, rfl⟩\n    by_cases h : x ∈ s <;> [left; right] <;> use x <;> simp [h]\n  · rintro (⟨x, hx, rfl⟩ | ⟨x, hx, rfl⟩) <;> use x <;> simp_all\n\n"}
{"name":"Set.injective_piecewise_iff","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nf g : α → β\n⊢ Iff (Function.Injective (s.piecewise f g)) (And (Set.InjOn f s) (And (Set.InjOn g (HasCompl.compl s)) (∀ (x : α), Membership.mem s x → ∀ (y : α), Not (Membership.mem s y) → Ne (f x) (g y))))","decl":"theorem injective_piecewise_iff {f g : α → β} :\n    Injective (s.piecewise f g) ↔\n      InjOn f s ∧ InjOn g sᶜ ∧ ∀ x ∈ s, ∀ y ∉ s, f x ≠ g y := by\n  rw [injective_iff_injOn_univ, ← union_compl_self s, injOn_union (@disjoint_compl_right _ _ s),\n    (piecewise_eqOn s f g).injOn_iff, (piecewise_eqOn_compl s f g).injOn_iff]\n  refine and_congr Iff.rfl (and_congr Iff.rfl <| forall₄_congr fun x hx y hy => ?_)\n  rw [piecewise_eq_of_mem s f g hx, piecewise_eq_of_not_mem s f g hy]\n\n"}
{"name":"Set.piecewise_mem_pi","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : (j : α) → Decidable (Membership.mem s j)\nδ : α → Type u_8\nt : Set α\nt' : (i : α) → Set (δ i)\nf g : (i : α) → δ i\nhf : Membership.mem (t.pi t') f\nhg : Membership.mem (t.pi t') g\n⊢ Membership.mem (t.pi t') (s.piecewise f g)","decl":"theorem piecewise_mem_pi {δ : α → Type*} {t : Set α} {t' : ∀ i, Set (δ i)} {f g} (hf : f ∈ pi t t')\n    (hg : g ∈ pi t t') : s.piecewise f g ∈ pi t t' := by\n  intro i ht\n  by_cases hs : i ∈ s <;> simp [hf i ht, hg i ht, hs]\n\n"}
{"name":"Set.pi_piecewise","module":"Mathlib.Data.Set.Function","initialProofState":"ι : Type u_8\nα : ι → Type u_9\ns s' : Set ι\nt t' : (i : ι) → Set (α i)\ninst✝ : (x : ι) → Decidable (Membership.mem s' x)\n⊢ Eq (s.pi (s'.piecewise t t')) (Inter.inter ((Inter.inter s s').pi t) ((SDiff.sdiff s s').pi t'))","decl":"@[simp]\ntheorem pi_piecewise {ι : Type*} {α : ι → Type*} (s s' : Set ι) (t t' : ∀ i, Set (α i))\n    [∀ x, Decidable (x ∈ s')] : pi s (s'.piecewise t t') = pi (s ∩ s') t ∩ pi (s \\ s') t' :=\n  pi_if _ _ _\n\n"}
{"name":"Set.univ_pi_piecewise","module":"Mathlib.Data.Set.Function","initialProofState":"ι : Type u_8\nα : ι → Type u_9\ns : Set ι\nt t' : (i : ι) → Set (α i)\ninst✝ : (x : ι) → Decidable (Membership.mem s x)\n⊢ Eq (Set.univ.pi (s.piecewise t t')) (Inter.inter (s.pi t) ((HasCompl.compl s).pi t'))","decl":"theorem univ_pi_piecewise {ι : Type*} {α : ι → Type*} (s : Set ι) (t t' : ∀ i, Set (α i))\n    [∀ x, Decidable (x ∈ s)] : pi univ (s.piecewise t t') = pi s t ∩ pi sᶜ t' := by\n  simp [compl_eq_univ_diff]\n\n"}
{"name":"Set.univ_pi_piecewise_univ","module":"Mathlib.Data.Set.Function","initialProofState":"ι : Type u_8\nα : ι → Type u_9\ns : Set ι\nt : (i : ι) → Set (α i)\ninst✝ : (x : ι) → Decidable (Membership.mem s x)\n⊢ Eq (Set.univ.pi (s.piecewise t fun x => Set.univ)) (s.pi t)","decl":"theorem univ_pi_piecewise_univ {ι : Type*} {α : ι → Type*} (s : Set ι) (t : ∀ i, Set (α i))\n    [∀ x, Decidable (x ∈ s)] : pi univ (s.piecewise t fun _ => univ) = pi s t := by simp\n\n"}
{"name":"Function.Injective.comp_injOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\ng : β → γ\ns : Set α\nhg : Function.Injective g\nhf : Set.InjOn f s\n⊢ Set.InjOn (Function.comp g f) s","decl":"theorem Injective.comp_injOn (hg : Injective g) (hf : s.InjOn f) : s.InjOn (g ∘ f) :=\n  hg.injOn.comp hf (mapsTo_univ _ _)\n\n"}
{"name":"Function.Surjective.surjOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Surjective f\ns : Set β\n⊢ Set.SurjOn f Set.univ s","decl":"theorem Surjective.surjOn (hf : Surjective f) (s : Set β) : SurjOn f univ s :=\n  (surjective_iff_surjOn_univ.1 hf).mono (Subset.refl _) (subset_univ _)\n\n"}
{"name":"Function.LeftInverse.leftInvOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ng : β → α\nh : Function.LeftInverse f g\ns : Set β\n⊢ Set.LeftInvOn f g s","decl":"theorem LeftInverse.leftInvOn {g : β → α} (h : LeftInverse f g) (s : Set β) : LeftInvOn f g s :=\n  fun x _ => h x\n\n"}
{"name":"Function.RightInverse.rightInvOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ng : β → α\nh : Function.RightInverse f g\ns : Set α\n⊢ Set.RightInvOn f g s","decl":"theorem RightInverse.rightInvOn {g : β → α} (h : RightInverse f g) (s : Set α) :\n    RightInvOn f g s := fun x _ => h x\n\n"}
{"name":"Function.LeftInverse.rightInvOn_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ng : β → α\nh : Function.LeftInverse f g\n⊢ Set.RightInvOn f g (Set.range g)","decl":"theorem LeftInverse.rightInvOn_range {g : β → α} (h : LeftInverse f g) :\n    RightInvOn f g (range g) :=\n  forall_mem_range.2 fun i => congr_arg g (h i)\n\n"}
{"name":"Function.Semiconj.mapsTo_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nfa : α → α\nfb : β → β\nf : α → β\ns t : Set α\nh : Function.Semiconj f fa fb\nha : Set.MapsTo fa s t\n⊢ Set.MapsTo fb (Set.image f s) (Set.image f t)","decl":"theorem mapsTo_image (h : Semiconj f fa fb) (ha : MapsTo fa s t) : MapsTo fb (f '' s) (f '' t) :=\n  fun _y ⟨x, hx, hy⟩ => hy ▸ ⟨fa x, ha hx, h x⟩\n\n"}
{"name":"Function.Semiconj.mapsTo_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nfa : α → α\nfb : β → β\nf : α → β\nh : Function.Semiconj f fa fb\n⊢ Set.MapsTo fb (Set.range f) (Set.range f)","decl":"theorem mapsTo_range (h : Semiconj f fa fb) : MapsTo fb (range f) (range f) := fun _y ⟨x, hy⟩ =>\n  hy ▸ ⟨fa x, h x⟩\n\n"}
{"name":"Function.Semiconj.surjOn_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nfa : α → α\nfb : β → β\nf : α → β\ns t : Set α\nh : Function.Semiconj f fa fb\nha : Set.SurjOn fa s t\n⊢ Set.SurjOn fb (Set.image f s) (Set.image f t)","decl":"theorem surjOn_image (h : Semiconj f fa fb) (ha : SurjOn fa s t) : SurjOn fb (f '' s) (f '' t) := by\n  rintro y ⟨x, hxt, rfl⟩\n  rcases ha hxt with ⟨x, hxs, rfl⟩\n  rw [h x]\n  exact mem_image_of_mem _ (mem_image_of_mem _ hxs)\n\n"}
{"name":"Function.Semiconj.surjOn_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nfa : α → α\nfb : β → β\nf : α → β\nh : Function.Semiconj f fa fb\nha : Function.Surjective fa\n⊢ Set.SurjOn fb (Set.range f) (Set.range f)","decl":"theorem surjOn_range (h : Semiconj f fa fb) (ha : Surjective fa) :\n    SurjOn fb (range f) (range f) := by\n  rw [← image_univ]\n  exact h.surjOn_image (ha.surjOn univ)\n\n"}
{"name":"Function.Semiconj.injOn_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nfa : α → α\nfb : β → β\nf : α → β\ns : Set α\nh : Function.Semiconj f fa fb\nha : Set.InjOn fa s\nhf : Set.InjOn f (Set.image fa s)\n⊢ Set.InjOn fb (Set.image f s)","decl":"theorem injOn_image (h : Semiconj f fa fb) (ha : InjOn fa s) (hf : InjOn f (fa '' s)) :\n    InjOn fb (f '' s) := by\n  rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩ H\n  simp only [← h.eq] at H\n  exact congr_arg f (ha hx hy <| hf (mem_image_of_mem fa hx) (mem_image_of_mem fa hy) H)\n\n"}
{"name":"Function.Semiconj.injOn_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nfa : α → α\nfb : β → β\nf : α → β\nh : Function.Semiconj f fa fb\nha : Function.Injective fa\nhf : Set.InjOn f (Set.range fa)\n⊢ Set.InjOn fb (Set.range f)","decl":"theorem injOn_range (h : Semiconj f fa fb) (ha : Injective fa) (hf : InjOn f (range fa)) :\n    InjOn fb (range f) := by\n  rw [← image_univ] at *\n  exact h.injOn_image ha.injOn hf\n\n"}
{"name":"Function.Semiconj.bijOn_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nfa : α → α\nfb : β → β\nf : α → β\ns t : Set α\nh : Function.Semiconj f fa fb\nha : Set.BijOn fa s t\nhf : Set.InjOn f t\n⊢ Set.BijOn fb (Set.image f s) (Set.image f t)","decl":"theorem bijOn_image (h : Semiconj f fa fb) (ha : BijOn fa s t) (hf : InjOn f t) :\n    BijOn fb (f '' s) (f '' t) :=\n  ⟨h.mapsTo_image ha.mapsTo, h.injOn_image ha.injOn (ha.image_eq.symm ▸ hf),\n    h.surjOn_image ha.surjOn⟩\n\n"}
{"name":"Function.Semiconj.bijOn_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nfa : α → α\nfb : β → β\nf : α → β\nh : Function.Semiconj f fa fb\nha : Function.Bijective fa\nhf : Function.Injective f\n⊢ Set.BijOn fb (Set.range f) (Set.range f)","decl":"theorem bijOn_range (h : Semiconj f fa fb) (ha : Bijective fa) (hf : Injective f) :\n    BijOn fb (range f) (range f) := by\n  rw [← image_univ]\n  exact h.bijOn_image (bijective_iff_bijOn_univ.1 ha) hf.injOn\n\n"}
{"name":"Function.Semiconj.mapsTo_preimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nfa : α → α\nfb : β → β\nf : α → β\nh : Function.Semiconj f fa fb\ns t : Set β\nhb : Set.MapsTo fb s t\n⊢ Set.MapsTo fa (Set.preimage f s) (Set.preimage f t)","decl":"theorem mapsTo_preimage (h : Semiconj f fa fb) {s t : Set β} (hb : MapsTo fb s t) :\n    MapsTo fa (f ⁻¹' s) (f ⁻¹' t) := fun x hx => by simp only [mem_preimage, h x, hb hx]\n\n"}
{"name":"Function.Semiconj.injOn_preimage","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nfa : α → α\nfb : β → β\nf : α → β\nh : Function.Semiconj f fa fb\ns : Set β\nhb : Set.InjOn fb s\nhf : Set.InjOn f (Set.preimage f s)\n⊢ Set.InjOn fa (Set.preimage f s)","decl":"theorem injOn_preimage (h : Semiconj f fa fb) {s : Set β} (hb : InjOn fb s)\n    (hf : InjOn f (f ⁻¹' s)) : InjOn fa (f ⁻¹' s) := by\n  intro x hx y hy H\n  have := congr_arg f H\n  rw [h.eq, h.eq] at this\n  exact hf hx hy (hb hx hy this)\n\n"}
{"name":"Function.update_comp_eq_of_not_mem_range'","module":"Mathlib.Data.Set.Function","initialProofState":"α : Sort u_7\nβ : Type u_8\nγ : β → Sort u_9\ninst✝ : DecidableEq β\ng : (b : β) → γ b\nf : α → β\ni : β\na : γ i\nh : Not (Membership.mem (Set.range f) i)\n⊢ Eq (fun j => Function.update g i a (f j)) fun j => g (f j)","decl":"theorem update_comp_eq_of_not_mem_range' {α : Sort*} {β : Type*} {γ : β → Sort*} [DecidableEq β]\n    (g : ∀ b, γ b) {f : α → β} {i : β} (a : γ i) (h : i ∉ Set.range f) :\n    (fun j => update g i a (f j)) = fun j => g (f j) :=\n  (update_comp_eq_of_forall_ne' _ _) fun x hx => h ⟨x, hx⟩\n\n"}
{"name":"Function.update_comp_eq_of_not_mem_range","module":"Mathlib.Data.Set.Function","initialProofState":"α : Sort u_7\nβ : Type u_8\nγ : Sort u_9\ninst✝ : DecidableEq β\ng : β → γ\nf : α → β\ni : β\na : γ\nh : Not (Membership.mem (Set.range f) i)\n⊢ Eq (Function.comp (Function.update g i a) f) (Function.comp g f)","decl":"/-- Non-dependent version of `Function.update_comp_eq_of_not_mem_range'` -/\ntheorem update_comp_eq_of_not_mem_range {α : Sort*} {β : Type*} {γ : Sort*} [DecidableEq β]\n    (g : β → γ) {f : α → β} {i : β} (a : γ) (h : i ∉ Set.range f) : update g i a ∘ f = g ∘ f :=\n  update_comp_eq_of_not_mem_range' g a h\n\n"}
{"name":"Function.insert_injOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ns : Set α\n⊢ Set.InjOn (fun a => Insert.insert a s) (HasCompl.compl s)","decl":"theorem insert_injOn (s : Set α) : sᶜ.InjOn fun a => insert a s := fun _a ha _ _ =>\n  (insert_inj ha).1\n\n"}
{"name":"Function.apply_eq_of_range_eq_singleton","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nb : β\nh : Eq (Set.range f) (Singleton.singleton b)\na : α\n⊢ Eq (f a) b","decl":"lemma apply_eq_of_range_eq_singleton {f : α → β} {b : β} (h : range f = {b}) (a : α) :\n    f a = b := by\n  simpa only [h, mem_singleton_iff] using mem_range_self (f := f) a\n\n"}
{"name":"Set.MapsTo.extendDomain","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\ng : Equiv.Perm α\ns t : Set α\nh : Set.MapsTo (⇑g) s t\n⊢ Set.MapsTo (⇑(g.extendDomain f)) (Set.image (Function.comp Subtype.val ⇑f) s) (Set.image (Function.comp Subtype.val ⇑f) t)","decl":"protected lemma MapsTo.extendDomain (h : MapsTo g s t) :\n    MapsTo (g.extendDomain f) ((↑) ∘ f '' s) ((↑) ∘ f '' t) := by\n  rintro _ ⟨a, ha, rfl⟩; exact ⟨_, h ha, by simp_rw [Function.comp_apply, extendDomain_apply_image]⟩\n\n"}
{"name":"Set.SurjOn.extendDomain","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\ng : Equiv.Perm α\ns t : Set α\nh : Set.SurjOn (⇑g) s t\n⊢ Set.SurjOn (⇑(g.extendDomain f)) (Set.image (Function.comp Subtype.val ⇑f) s) (Set.image (Function.comp Subtype.val ⇑f) t)","decl":"protected lemma SurjOn.extendDomain (h : SurjOn g s t) :\n    SurjOn (g.extendDomain f) ((↑) ∘ f '' s) ((↑) ∘ f '' t) := by\n  rintro _ ⟨a, ha, rfl⟩\n  obtain ⟨b, hb, rfl⟩ := h ha\n  exact ⟨_, ⟨_, hb, rfl⟩, by simp_rw [Function.comp_apply, extendDomain_apply_image]⟩\n\n"}
{"name":"Set.BijOn.extendDomain","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\ng : Equiv.Perm α\ns t : Set α\nh : Set.BijOn (⇑g) s t\n⊢ Set.BijOn (⇑(g.extendDomain f)) (Set.image (Function.comp Subtype.val ⇑f) s) (Set.image (Function.comp Subtype.val ⇑f) t)","decl":"protected lemma BijOn.extendDomain (h : BijOn g s t) :\n    BijOn (g.extendDomain f) ((↑) ∘ f '' s) ((↑) ∘ f '' t) :=\n  ⟨h.mapsTo.extendDomain, (g.extendDomain f).injective.injOn, h.surjOn.extendDomain⟩\n\n"}
{"name":"Set.LeftInvOn.extendDomain","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\ng₁ g₂ : Equiv.Perm α\ns : Set α\nh : Set.LeftInvOn (⇑g₁) (⇑g₂) s\n⊢ Set.LeftInvOn (⇑(g₁.extendDomain f)) (⇑(g₂.extendDomain f)) (Set.image (Function.comp Subtype.val ⇑f) s)","decl":"protected lemma LeftInvOn.extendDomain (h : LeftInvOn g₁ g₂ s) :\n    LeftInvOn (g₁.extendDomain f) (g₂.extendDomain f) ((↑) ∘ f '' s) := by\n  rintro _ ⟨a, ha, rfl⟩; simp_rw [Function.comp_apply, extendDomain_apply_image, h ha]\n\n"}
{"name":"Set.RightInvOn.extendDomain","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\ng₁ g₂ : Equiv.Perm α\nt : Set α\nh : Set.RightInvOn (⇑g₁) (⇑g₂) t\n⊢ Set.RightInvOn (⇑(g₁.extendDomain f)) (⇑(g₂.extendDomain f)) (Set.image (Function.comp Subtype.val ⇑f) t)","decl":"protected lemma RightInvOn.extendDomain (h : RightInvOn g₁ g₂ t) :\n    RightInvOn (g₁.extendDomain f) (g₂.extendDomain f) ((↑) ∘ f '' t) := by\n  rintro _ ⟨a, ha, rfl⟩; simp_rw [Function.comp_apply, extendDomain_apply_image, h ha]\n\n"}
{"name":"Set.InvOn.extendDomain","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\ng₁ g₂ : Equiv.Perm α\ns t : Set α\nh : Set.InvOn (⇑g₁) (⇑g₂) s t\n⊢ Set.InvOn (⇑(g₁.extendDomain f)) (⇑(g₂.extendDomain f)) (Set.image (Function.comp Subtype.val ⇑f) s) (Set.image (Function.comp Subtype.val ⇑f) t)","decl":"protected lemma InvOn.extendDomain (h : InvOn g₁ g₂ s t) :\n    InvOn (g₁.extendDomain f) (g₂.extendDomain f) ((↑) ∘ f '' s) ((↑) ∘ f '' t) :=\n  ⟨h.1.extendDomain, h.2.extendDomain⟩\n\n"}
{"name":"Set.InjOn.prodMap","module":"Mathlib.Data.Set.Function","initialProofState":"α₁ : Type u_7\nα₂ : Type u_8\nβ₁ : Type u_9\nβ₂ : Type u_10\ns₁ : Set α₁\ns₂ : Set α₂\nf₁ : α₁ → β₁\nf₂ : α₂ → β₂\nh₁ : Set.InjOn f₁ s₁\nh₂ : Set.InjOn f₂ s₂\n⊢ Set.InjOn (fun x => { fst := f₁ x.1, snd := f₂ x.2 }) (SProd.sprod s₁ s₂)","decl":"lemma InjOn.prodMap (h₁ : s₁.InjOn f₁) (h₂ : s₂.InjOn f₂) :\n    (s₁ ×ˢ s₂).InjOn fun x ↦ (f₁ x.1, f₂ x.2) :=\n  fun x hx y hy ↦ by simp_rw [Prod.ext_iff]; exact And.imp (h₁ hx.1 hy.1) (h₂ hx.2 hy.2)\n\n"}
{"name":"Set.SurjOn.prodMap","module":"Mathlib.Data.Set.Function","initialProofState":"α₁ : Type u_7\nα₂ : Type u_8\nβ₁ : Type u_9\nβ₂ : Type u_10\ns₁ : Set α₁\ns₂ : Set α₂\nt₁ : Set β₁\nt₂ : Set β₂\nf₁ : α₁ → β₁\nf₂ : α₂ → β₂\nh₁ : Set.SurjOn f₁ s₁ t₁\nh₂ : Set.SurjOn f₂ s₂ t₂\n⊢ Set.SurjOn (fun x => { fst := f₁ x.1, snd := f₂ x.2 }) (SProd.sprod s₁ s₂) (SProd.sprod t₁ t₂)","decl":"lemma SurjOn.prodMap (h₁ : SurjOn f₁ s₁ t₁) (h₂ : SurjOn f₂ s₂ t₂) :\n    SurjOn (fun x ↦ (f₁ x.1, f₂ x.2)) (s₁ ×ˢ s₂) (t₁ ×ˢ t₂) := by\n  rintro x hx\n  obtain ⟨a₁, ha₁, hx₁⟩ := h₁ hx.1\n  obtain ⟨a₂, ha₂, hx₂⟩ := h₂ hx.2\n  exact ⟨(a₁, a₂), ⟨ha₁, ha₂⟩, Prod.ext hx₁ hx₂⟩\n\n"}
{"name":"Set.MapsTo.prodMap","module":"Mathlib.Data.Set.Function","initialProofState":"α₁ : Type u_7\nα₂ : Type u_8\nβ₁ : Type u_9\nβ₂ : Type u_10\ns₁ : Set α₁\ns₂ : Set α₂\nt₁ : Set β₁\nt₂ : Set β₂\nf₁ : α₁ → β₁\nf₂ : α₂ → β₂\nh₁ : Set.MapsTo f₁ s₁ t₁\nh₂ : Set.MapsTo f₂ s₂ t₂\n⊢ Set.MapsTo (fun x => { fst := f₁ x.1, snd := f₂ x.2 }) (SProd.sprod s₁ s₂) (SProd.sprod t₁ t₂)","decl":"lemma MapsTo.prodMap (h₁ : MapsTo f₁ s₁ t₁) (h₂ : MapsTo f₂ s₂ t₂) :\n    MapsTo (fun x ↦ (f₁ x.1, f₂ x.2)) (s₁ ×ˢ s₂) (t₁ ×ˢ t₂) :=\n  fun _x hx ↦ ⟨h₁ hx.1, h₂ hx.2⟩\n\n"}
{"name":"Set.BijOn.prodMap","module":"Mathlib.Data.Set.Function","initialProofState":"α₁ : Type u_7\nα₂ : Type u_8\nβ₁ : Type u_9\nβ₂ : Type u_10\ns₁ : Set α₁\ns₂ : Set α₂\nt₁ : Set β₁\nt₂ : Set β₂\nf₁ : α₁ → β₁\nf₂ : α₂ → β₂\nh₁ : Set.BijOn f₁ s₁ t₁\nh₂ : Set.BijOn f₂ s₂ t₂\n⊢ Set.BijOn (fun x => { fst := f₁ x.1, snd := f₂ x.2 }) (SProd.sprod s₁ s₂) (SProd.sprod t₁ t₂)","decl":"lemma BijOn.prodMap (h₁ : BijOn f₁ s₁ t₁) (h₂ : BijOn f₂ s₂ t₂) :\n    BijOn (fun x ↦ (f₁ x.1, f₂ x.2)) (s₁ ×ˢ s₂) (t₁ ×ˢ t₂) :=\n  ⟨h₁.mapsTo.prodMap h₂.mapsTo, h₁.injOn.prodMap h₂.injOn, h₁.surjOn.prodMap h₂.surjOn⟩\n\n"}
{"name":"Set.LeftInvOn.prodMap","module":"Mathlib.Data.Set.Function","initialProofState":"α₁ : Type u_7\nα₂ : Type u_8\nβ₁ : Type u_9\nβ₂ : Type u_10\ns₁ : Set α₁\ns₂ : Set α₂\nf₁ : α₁ → β₁\nf₂ : α₂ → β₂\ng₁ : β₁ → α₁\ng₂ : β₂ → α₂\nh₁ : Set.LeftInvOn g₁ f₁ s₁\nh₂ : Set.LeftInvOn g₂ f₂ s₂\n⊢ Set.LeftInvOn (fun x => { fst := g₁ x.1, snd := g₂ x.2 }) (fun x => { fst := f₁ x.1, snd := f₂ x.2 }) (SProd.sprod s₁ s₂)","decl":"lemma LeftInvOn.prodMap (h₁ : LeftInvOn g₁ f₁ s₁) (h₂ : LeftInvOn g₂ f₂ s₂) :\n    LeftInvOn (fun x ↦ (g₁ x.1, g₂ x.2)) (fun x ↦ (f₁ x.1, f₂ x.2)) (s₁ ×ˢ s₂) :=\n  fun _x hx ↦ Prod.ext (h₁ hx.1) (h₂ hx.2)\n\n"}
{"name":"Set.RightInvOn.prodMap","module":"Mathlib.Data.Set.Function","initialProofState":"α₁ : Type u_7\nα₂ : Type u_8\nβ₁ : Type u_9\nβ₂ : Type u_10\nt₁ : Set β₁\nt₂ : Set β₂\nf₁ : α₁ → β₁\nf₂ : α₂ → β₂\ng₁ : β₁ → α₁\ng₂ : β₂ → α₂\nh₁ : Set.RightInvOn g₁ f₁ t₁\nh₂ : Set.RightInvOn g₂ f₂ t₂\n⊢ Set.RightInvOn (fun x => { fst := g₁ x.1, snd := g₂ x.2 }) (fun x => { fst := f₁ x.1, snd := f₂ x.2 }) (SProd.sprod t₁ t₂)","decl":"lemma RightInvOn.prodMap (h₁ : RightInvOn g₁ f₁ t₁) (h₂ : RightInvOn g₂ f₂ t₂) :\n    RightInvOn (fun x ↦ (g₁ x.1, g₂ x.2)) (fun x ↦ (f₁ x.1, f₂ x.2)) (t₁ ×ˢ t₂) :=\n  fun _x hx ↦ Prod.ext (h₁ hx.1) (h₂ hx.2)\n\n"}
{"name":"Set.InvOn.prodMap","module":"Mathlib.Data.Set.Function","initialProofState":"α₁ : Type u_7\nα₂ : Type u_8\nβ₁ : Type u_9\nβ₂ : Type u_10\ns₁ : Set α₁\ns₂ : Set α₂\nt₁ : Set β₁\nt₂ : Set β₂\nf₁ : α₁ → β₁\nf₂ : α₂ → β₂\ng₁ : β₁ → α₁\ng₂ : β₂ → α₂\nh₁ : Set.InvOn g₁ f₁ s₁ t₁\nh₂ : Set.InvOn g₂ f₂ s₂ t₂\n⊢ Set.InvOn (fun x => { fst := g₁ x.1, snd := g₂ x.2 }) (fun x => { fst := f₁ x.1, snd := f₂ x.2 }) (SProd.sprod s₁ s₂) (SProd.sprod t₁ t₂)","decl":"lemma InvOn.prodMap (h₁ : InvOn g₁ f₁ s₁ t₁) (h₂ : InvOn g₂ f₂ s₂ t₂) :\n    InvOn (fun x ↦ (g₁ x.1, g₂ x.2)) (fun x ↦ (f₁ x.1, f₂ x.2)) (s₁ ×ˢ s₂) (t₁ ×ˢ t₂) :=\n  ⟨h₁.1.prodMap h₂.1, h₁.2.prodMap h₂.2⟩\n\n"}
{"name":"Equiv.bijOn'","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\nh₁ : Set.MapsTo (⇑e) s t\nh₂ : Set.MapsTo (⇑e.symm) t s\n⊢ Set.BijOn (⇑e) s t","decl":"lemma bijOn' (h₁ : MapsTo e s t) (h₂ : MapsTo e.symm t s) : BijOn e s t :=\n  ⟨h₁, e.injective.injOn, fun b hb ↦ ⟨e.symm b, h₂ hb, apply_symm_apply _ _⟩⟩\n\n"}
{"name":"Equiv.bijOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\nh : ∀ (a : α), Iff (Membership.mem t (e a)) (Membership.mem s a)\n⊢ Set.BijOn (⇑e) s t","decl":"protected lemma bijOn (h : ∀ a, e a ∈ t ↔ a ∈ s) : BijOn e s t :=\n  e.bijOn' (fun _ ↦ (h _).2) fun b hb ↦ (h _).1 <| by rwa [apply_symm_apply]\n\n"}
{"name":"Equiv.invOn","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\n⊢ Set.InvOn (⇑e) (⇑e.symm) t s","decl":"lemma invOn : InvOn e e.symm t s :=\n  ⟨e.rightInverse_symm.leftInvOn _, e.leftInverse_symm.leftInvOn _⟩\n\n"}
{"name":"Equiv.bijOn_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\n⊢ Set.BijOn (⇑e) s (Set.image (⇑e) s)","decl":"lemma bijOn_image : BijOn e s (e '' s) := e.injective.injOn.bijOn_image\n"}
{"name":"Equiv.bijOn_symm_image","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\n⊢ Set.BijOn (⇑e.symm) (Set.image (⇑e) s) s","decl":"lemma bijOn_symm_image : BijOn e.symm (e '' s) s := e.bijOn_image.symm e.invOn\n\n"}
{"name":"Equiv.bijOn_symm","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\n⊢ Iff (Set.BijOn (⇑e.symm) t s) (Set.BijOn (⇑e) s t)","decl":"@[simp] lemma bijOn_symm : BijOn e.symm t s ↔ BijOn e s t := bijOn_comm e.symm.invOn\n\n"}
{"name":"Set.BijOn.of_equiv_symm","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\na✝ : Set.BijOn (⇑e.symm) t s\n⊢ Set.BijOn (⇑e) s t","decl":"alias ⟨_root_.Set.BijOn.of_equiv_symm, _root_.Set.BijOn.equiv_symm⟩ := bijOn_symm\n\n"}
{"name":"Set.BijOn.equiv_symm","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\na✝ : Set.BijOn (⇑e) s t\n⊢ Set.BijOn (⇑e.symm) t s","decl":"alias ⟨_root_.Set.BijOn.of_equiv_symm, _root_.Set.BijOn.equiv_symm⟩ := bijOn_symm\n\n"}
{"name":"Equiv.bijOn_swap","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : DecidableEq α\na b : α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Set.BijOn (⇑(Equiv.swap a b)) s s","decl":"lemma bijOn_swap (ha : a ∈ s) (hb : b ∈ s) : BijOn (swap a b) s s :=\n  (swap a b).bijOn fun x ↦ by\n    obtain rfl | hxa := eq_or_ne x a <;>\n    obtain rfl | hxb := eq_or_ne x b <;>\n    simp [*, swap_apply_of_ne_of_ne]\n\n"}
{"name":"Set.exists_range_eq_graphOn_univ","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → Prod β γ\nhf₁ : Function.Surjective (Function.comp Prod.fst f)\nhf : ∀ (g₁ g₂ : α), Eq (f g₁).1 (f g₂).1 → Eq (f g₁).2 (f g₂).2\n⊢ Exists fun f' => Eq (Set.range f) (Set.graphOn f' Set.univ)","decl":"/-- **Vertical line test** for functions.\n\nLet `f : α → β × γ` be a function to a product. Assume that `f` is surjective on the first factor\nand that the image of `f` intersects every \"vertical line\" `{(b, c) | c : γ}` at most once.\nThen the image of `f` is the graph of some monoid homomorphism `f' : β → γ`. -/\nlemma exists_range_eq_graphOn_univ {f : α → β × γ} (hf₁ : Surjective (Prod.fst ∘ f))\n    (hf : ∀ g₁ g₂, (f g₁).1 = (f g₂).1 → (f g₁).2 = (f g₂).2) :\n    ∃ f' : β → γ, range f = univ.graphOn f' := by\n  refine ⟨fun h ↦ (f (hf₁ h).choose).snd, ?_⟩\n  ext x\n  simp only [mem_range, comp_apply, mem_graphOn, mem_univ, true_and]\n  refine ⟨?_, fun hi ↦ ⟨(hf₁ x.1).choose, Prod.ext (hf₁ x.1).choose_spec hi⟩⟩\n  rintro ⟨g, rfl⟩\n  exact hf _ _ (hf₁ (f g).1).choose_spec\n\n"}
{"name":"Set.exists_equiv_range_eq_graphOn_univ","module":"Mathlib.Data.Set.Function","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → Prod β γ\nhf₁ : Function.Surjective (Function.comp Prod.fst f)\nhf₂ : Function.Surjective (Function.comp Prod.snd f)\nhf : ∀ (g₁ g₂ : α), Iff (Eq (f g₁).1 (f g₂).1) (Eq (f g₁).2 (f g₂).2)\n⊢ Exists fun e => Eq (Set.range f) (Set.graphOn (⇑e) Set.univ)","decl":"/-- **Line test** for equivalences.\n\nLet `f : α → β × γ` be a homomorphism to a product of monoids. Assume that `f` is surjective on both\nfactors and that the image of `f` intersects every \"vertical line\" `{(b, c) | c : γ}` and every\n\"horizontal line\" `{(b, c) | b : β}` at most once. Then the image of `f` is the graph of some\nequivalence `f' : β ≃ γ`. -/\nlemma exists_equiv_range_eq_graphOn_univ {f : α → β × γ} (hf₁ : Surjective (Prod.fst ∘ f))\n    (hf₂ : Surjective (Prod.snd ∘ f)) (hf : ∀ g₁ g₂, (f g₁).1 = (f g₂).1 ↔ (f g₁).2 = (f g₂).2) :\n    ∃ e : β ≃ γ, range f = univ.graphOn e := by\n  obtain ⟨e₁, he₁⟩ := exists_range_eq_graphOn_univ hf₁ fun _ _ ↦ (hf _ _).1\n  obtain ⟨e₂, he₂⟩ := exists_range_eq_graphOn_univ (f := Equiv.prodComm _ _ ∘ f) (by simpa) <|\n    by simp [hf]\n  have he₁₂ h i : e₁ h = i ↔ e₂ i = h := by\n    rw [Set.ext_iff] at he₁ he₂\n    aesop (add simp [Prod.swap_eq_iff_eq_swap])\n  exact ⟨\n  { toFun := e₁\n    invFun := e₂\n    left_inv := fun h ↦ by rw [← he₁₂]\n    right_inv := fun i ↦ by rw [he₁₂] }, he₁⟩\n\n"}
{"name":"Set.exists_eq_mgraphOn_univ","module":"Mathlib.Data.Set.Function","initialProofState":"β : Type u_2\nγ : Type u_3\ns : Set (Prod β γ)\nhs₁ : Function.Bijective (Function.comp Prod.fst Subtype.val)\n⊢ Exists fun f => Eq s (Set.graphOn f Set.univ)","decl":"/-- **Vertical line test** for functions.\n\nLet `s : Set (β × γ)` be a set in a product. Assume that `s` maps bijectively to the first factor.\nThen `s` is the graph of some function `f : β → γ`. -/\nlemma exists_eq_mgraphOn_univ {s : Set (β × γ)}\n    (hs₁ : Bijective (Prod.fst ∘ (Subtype.val : s → β × γ))) : ∃ f : β → γ, s = univ.graphOn f := by\n  simpa using exists_range_eq_graphOn_univ hs₁.surjective\n    fun a b h ↦ congr_arg (Prod.snd ∘ (Subtype.val : s → β × γ)) (hs₁.injective h)\n\n"}
