{"name":"ValuedCSP.Term.mk.injEq","module":"Mathlib.Combinatorics.Optimization.ValuedCSP","initialProofState":"D : Type u_1\nC : Type u_2\ninst✝ : OrderedAddCommMonoid C\nΓ : ValuedCSP D C\nι : Type u_3\nn✝ : Nat\nf✝ : (Fin n✝ → D) → C\ninΓ✝ : Membership.mem Γ ⟨n✝, f✝⟩\napp✝ : Fin n✝ → ι\nn : Nat\nf : (Fin n → D) → C\ninΓ : Membership.mem Γ ⟨n, f⟩\napp : Fin n → ι\n⊢ Eq (Eq { n := n✝, f := f✝, inΓ := inΓ✝, app := app✝ } { n := n, f := f, inΓ := inΓ, app := app }) (And (Eq n✝ n) (And (HEq f✝ f) (HEq app✝ app)))","decl":"/-- A term in a valued CSP instance over the template `Γ`. -/\nstructure ValuedCSP.Term (Γ : ValuedCSP D C) (ι : Type*) where\n  /-- Arity of the function -/\n  n : ℕ\n  /-- Which cost function is instantiated -/\n  f : (Fin n → D) → C\n  /-- The cost function comes from the template -/\n  inΓ : ⟨n, f⟩ ∈ Γ\n  /-- Which variables are plugged as arguments to the cost function -/\n  app : Fin n → ι\n\n"}
{"name":"ValuedCSP.Term.inΓ","module":"Mathlib.Combinatorics.Optimization.ValuedCSP","initialProofState":"D : Type u_1\nC : Type u_2\ninst✝ : OrderedAddCommMonoid C\nΓ : ValuedCSP D C\nι : Type u_3\nself : Γ.Term ι\n⊢ Membership.mem Γ ⟨self.n, self.f⟩","decl":"/-- A term in a valued CSP instance over the template `Γ`. -/\nstructure ValuedCSP.Term (Γ : ValuedCSP D C) (ι : Type*) where\n  /-- Arity of the function -/\n  n : ℕ\n  /-- Which cost function is instantiated -/\n  f : (Fin n → D) → C\n  /-- The cost function comes from the template -/\n  inΓ : ⟨n, f⟩ ∈ Γ\n  /-- Which variables are plugged as arguments to the cost function -/\n  app : Fin n → ι\n\n"}
{"name":"ValuedCSP.Term.mk.inj","module":"Mathlib.Combinatorics.Optimization.ValuedCSP","initialProofState":"D : Type u_1\nC : Type u_2\ninst✝ : OrderedAddCommMonoid C\nΓ : ValuedCSP D C\nι : Type u_3\nn✝ : Nat\nf✝ : (Fin n✝ → D) → C\ninΓ✝ : Membership.mem Γ ⟨n✝, f✝⟩\napp✝ : Fin n✝ → ι\nn : Nat\nf : (Fin n → D) → C\ninΓ : Membership.mem Γ ⟨n, f⟩\napp : Fin n → ι\nx✝ : Eq { n := n✝, f := f✝, inΓ := inΓ✝, app := app✝ } { n := n, f := f, inΓ := inΓ, app := app }\n⊢ And (Eq n✝ n) (And (HEq f✝ f) (HEq app✝ app))","decl":"/-- A term in a valued CSP instance over the template `Γ`. -/\nstructure ValuedCSP.Term (Γ : ValuedCSP D C) (ι : Type*) where\n  /-- Arity of the function -/\n  n : ℕ\n  /-- Which cost function is instantiated -/\n  f : (Fin n → D) → C\n  /-- The cost function comes from the template -/\n  inΓ : ⟨n, f⟩ ∈ Γ\n  /-- Which variables are plugged as arguments to the cost function -/\n  app : Fin n → ι\n\n"}
{"name":"ValuedCSP.Term.mk.sizeOf_spec","module":"Mathlib.Combinatorics.Optimization.ValuedCSP","initialProofState":"D : Type u_1\nC : Type u_2\ninst✝⁴ : OrderedAddCommMonoid C\nΓ : ValuedCSP D C\nι : Type u_3\ninst✝³ : SizeOf D\ninst✝² : SizeOf C\ninst✝¹ : (a : Sigma fun n => (Fin n → D) → C) → SizeOf (Γ a)\ninst✝ : SizeOf ι\nn : Nat\nf : (Fin n → D) → C\ninΓ : Membership.mem Γ ⟨n, f⟩\napp : Fin n → ι\n⊢ Eq (SizeOf.sizeOf { n := n, f := f, inΓ := inΓ, app := app }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf n)) (SizeOf.sizeOf inΓ))","decl":"/-- A term in a valued CSP instance over the template `Γ`. -/\nstructure ValuedCSP.Term (Γ : ValuedCSP D C) (ι : Type*) where\n  /-- Arity of the function -/\n  n : ℕ\n  /-- Which cost function is instantiated -/\n  f : (Fin n → D) → C\n  /-- The cost function comes from the template -/\n  inΓ : ⟨n, f⟩ ∈ Γ\n  /-- Which variables are plugged as arguments to the cost function -/\n  app : Fin n → ι\n\n"}
{"name":"FractionalOperation.IsValid.contains","module":"Mathlib.Combinatorics.Optimization.ValuedCSP","initialProofState":"D : Type u_1\nm : Nat\nω : FractionalOperation D m\nvalid : ω.IsValid\n⊢ Exists fun g => Membership.mem ω g","decl":"/-- Valid fractional operation contains an operation. -/\nlemma FractionalOperation.IsValid.contains {ω : FractionalOperation D m} (valid : ω.IsValid) :\n    ∃ g : (Fin m → D) → D, g ∈ ω :=\n  Multiset.exists_mem_of_ne_zero valid\n\n"}
{"name":"Function.HasMaxCutPropertyAt.rows_lt_aux","module":"Mathlib.Combinatorics.Optimization.ValuedCSP","initialProofState":"D : Type u_1\nC : Type u_3\ninst✝ : OrderedCancelAddCommMonoid C\nf : (Fin 2 → D) → C\na b : D\nmcf : Function.HasMaxCutPropertyAt f a b\nhab : Ne a b\nω : FractionalOperation D 2\nsymmega : ω.IsSymmetric\nr : Fin 2 → D\nrin : Membership.mem (ω.tt (Matrix.vecCons (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons b (Matrix.vecCons a Matrix.vecEmpty)) Matrix.vecEmpty))) r\n⊢ LT.lt (f (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty))) (f r)","decl":"lemma Function.HasMaxCutPropertyAt.rows_lt_aux\n    {f : (Fin 2 → D) → C} {a b : D} (mcf : f.HasMaxCutPropertyAt a b) (hab : a ≠ b)\n    {ω : FractionalOperation D 2} (symmega : ω.IsSymmetric)\n    {r : Fin 2 → D} (rin : r ∈ (ω.tt ![![a, b], ![b, a]])) :\n    f ![a, b] < f r := by\n  rw [FractionalOperation.tt, Multiset.mem_map] at rin\n  rw [show r = ![r 0, r 1] by simp [← List.ofFn_inj]]\n  apply lt_of_le_of_ne (mcf.right (r 0) (r 1)).left\n  intro equ\n  have asymm : r 0 ≠ r 1 := by\n    rcases (mcf.right (r 0) (r 1)).right equ with ⟨ha0, hb1⟩ | ⟨ha1, hb0⟩\n    · rw [ha0, hb1] at hab\n      exact hab\n    · rw [ha1, hb0] at hab\n      exact hab.symm\n  apply asymm\n  obtain ⟨o, in_omega, rfl⟩ := rin\n  show o (fun j => ![![a, b], ![b, a]] j 0) = o (fun j => ![![a, b], ![b, a]] j 1)\n  convert symmega ![a, b] ![b, a] (by simp [List.Perm.swap]) o in_omega using 2 <;>\n    simp [Matrix.const_fin1_eq]\n\n"}
{"name":"Function.HasMaxCutProperty.forbids_commutativeFractionalPolymorphism","module":"Mathlib.Combinatorics.Optimization.ValuedCSP","initialProofState":"D : Type u_1\nC : Type u_3\ninst✝ : OrderedCancelAddCommMonoid C\nf : (Fin 2 → D) → C\nmcf : Function.HasMaxCutProperty f\nω : FractionalOperation D 2\nvalid : ω.IsValid\nsymmega : ω.IsSymmetric\n⊢ Not (Function.AdmitsFractional f ω)","decl":"lemma Function.HasMaxCutProperty.forbids_commutativeFractionalPolymorphism\n    {f : (Fin 2 → D) → C} (mcf : f.HasMaxCutProperty)\n    {ω : FractionalOperation D 2} (valid : ω.IsValid) (symmega : ω.IsSymmetric) :\n    ¬ f.AdmitsFractional ω := by\n  intro contr\n  obtain ⟨a, b, hab, mcfab⟩ := mcf\n  specialize contr ![![a, b], ![b, a]]\n  rw [Fin.sum_univ_two', ← mcfab.left, ← two_nsmul] at contr\n  have sharp :\n    2 • ((ω.tt ![![a, b], ![b, a]]).map (fun _ => f ![a, b])).sum <\n    2 • ((ω.tt ![![a, b], ![b, a]]).map f).sum := by\n    have half_sharp :\n      ((ω.tt ![![a, b], ![b, a]]).map (fun _ => f ![a, b])).sum <\n      ((ω.tt ![![a, b], ![b, a]]).map f).sum := by\n      apply Multiset.sum_lt_sum\n      · intro r rin\n        exact le_of_lt (mcfab.rows_lt_aux hab symmega rin)\n      · obtain ⟨g, _⟩ := valid.contains\n        have : (fun i => g ((Function.swap ![![a, b], ![b, a]]) i)) ∈ ω.tt ![![a, b], ![b, a]] := by\n          simp only [FractionalOperation.tt, Multiset.mem_map]\n          use g\n        exact ⟨_, this, mcfab.rows_lt_aux hab symmega this⟩\n    rw [two_nsmul, two_nsmul]\n    exact add_lt_add half_sharp half_sharp\n  have impos : 2 • (ω.map (fun _ => f ![a, b])).sum < ω.size • 2 • f ![a, b] := by\n    convert lt_of_lt_of_le sharp contr\n    simp [FractionalOperation.tt, Multiset.map_map]\n  have rhs_swap : ω.size • 2 • f ![a, b] = 2 • ω.size • f ![a, b] := nsmul_left_comm ..\n  have distrib : (ω.map (fun _ => f ![a, b])).sum = ω.size • f ![a, b] := by simp\n  rw [rhs_swap, distrib] at impos\n  exact ne_of_lt impos rfl\n"}
