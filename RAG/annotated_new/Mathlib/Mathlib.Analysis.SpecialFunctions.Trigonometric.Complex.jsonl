{"name":"Complex.cos_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"θ : Complex\n⊢ Iff (Eq (Complex.cos θ) 0) (Exists fun k => Eq θ (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑k) 1) ↑Real.pi) 2))","decl":"theorem cos_eq_zero_iff {θ : ℂ} : cos θ = 0 ↔ ∃ k : ℤ, θ = (2 * k + 1) * π / 2 := by\n  have h : (exp (θ * I) + exp (-θ * I)) / 2 = 0 ↔ exp (2 * θ * I) = -1 := by\n    rw [@div_eq_iff _ _ (exp (θ * I) + exp (-θ * I)) 2 0 two_ne_zero, zero_mul,\n      add_eq_zero_iff_eq_neg, neg_eq_neg_one_mul, ← div_eq_iff (exp_ne_zero _), ← exp_sub]\n    ring_nf\n  rw [cos, h, ← exp_pi_mul_I, exp_eq_exp_iff_exists_int, mul_right_comm]\n  refine exists_congr fun x => ?_\n  refine (iff_of_eq <| congr_arg _ ?_).trans (mul_right_inj' <| mul_ne_zero two_ne_zero I_ne_zero)\n  field_simp; ring\n\n"}
{"name":"Complex.cos_ne_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"θ : Complex\n⊢ Iff (Ne (Complex.cos θ) 0) (∀ (k : Int), Ne θ (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑k) 1) ↑Real.pi) 2))","decl":"theorem cos_ne_zero_iff {θ : ℂ} : cos θ ≠ 0 ↔ ∀ k : ℤ, θ ≠ (2 * k + 1) * π / 2 := by\n  rw [← not_exists, not_iff_not, cos_eq_zero_iff]\n\n"}
{"name":"Complex.sin_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"θ : Complex\n⊢ Iff (Eq (Complex.sin θ) 0) (Exists fun k => Eq θ (HMul.hMul ↑k ↑Real.pi))","decl":"theorem sin_eq_zero_iff {θ : ℂ} : sin θ = 0 ↔ ∃ k : ℤ, θ = k * π := by\n  rw [← Complex.cos_sub_pi_div_two, cos_eq_zero_iff]\n  constructor\n  · rintro ⟨k, hk⟩\n    use k + 1\n    field_simp [eq_add_of_sub_eq hk]\n    ring\n  · rintro ⟨k, rfl⟩\n    use k - 1\n    field_simp\n    ring\n\n"}
{"name":"Complex.sin_ne_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"θ : Complex\n⊢ Iff (Ne (Complex.sin θ) 0) (∀ (k : Int), Ne θ (HMul.hMul ↑k ↑Real.pi))","decl":"theorem sin_ne_zero_iff {θ : ℂ} : sin θ ≠ 0 ↔ ∀ k : ℤ, θ ≠ k * π := by\n  rw [← not_exists, not_iff_not, sin_eq_zero_iff]\n\n"}
{"name":"Complex.tan_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"θ : Complex\n⊢ Iff (Eq (Complex.tan θ) 0) (Exists fun k => Eq (HDiv.hDiv (HMul.hMul ↑k ↑Real.pi) 2) θ)","decl":"/-- The tangent of a complex number is equal to zero\niff this number is equal to `k * π / 2` for an integer `k`.\n\nNote that this lemma takes into account that we use zero as the junk value for division by zero.\nSee also `Complex.tan_eq_zero_iff'`. -/\ntheorem tan_eq_zero_iff {θ : ℂ} : tan θ = 0 ↔ ∃ k : ℤ, k * π / 2 = θ := by\n  rw [tan, div_eq_zero_iff, ← mul_eq_zero, ← mul_right_inj' two_ne_zero, mul_zero,\n    ← mul_assoc, ← sin_two_mul, sin_eq_zero_iff]\n  field_simp [mul_comm, eq_comm]\n\n"}
{"name":"Complex.tan_ne_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"θ : Complex\n⊢ Iff (Ne (Complex.tan θ) 0) (∀ (k : Int), Ne (HDiv.hDiv (HMul.hMul ↑k ↑Real.pi) 2) θ)","decl":"theorem tan_ne_zero_iff {θ : ℂ} : tan θ ≠ 0 ↔ ∀ k : ℤ, (k * π / 2 : ℂ) ≠ θ := by\n  rw [← not_exists, not_iff_not, tan_eq_zero_iff]\n\n"}
{"name":"Complex.tan_int_mul_pi_div_two","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"n : Int\n⊢ Eq (Complex.tan (HDiv.hDiv (HMul.hMul ↑n ↑Real.pi) 2)) 0","decl":"theorem tan_int_mul_pi_div_two (n : ℤ) : tan (n * π / 2) = 0 :=\n  tan_eq_zero_iff.mpr (by use n)\n\n"}
{"name":"Complex.tan_eq_zero_iff'","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"θ : Complex\nhθ : Ne (Complex.cos θ) 0\n⊢ Iff (Eq (Complex.tan θ) 0) (Exists fun k => Eq (HMul.hMul ↑k ↑Real.pi) θ)","decl":"/-- If the tangent of a complex number is well-defined,\nthen it is equal to zero iff the number is equal to `k * π` for an integer `k`.\n\nSee also `Complex.tan_eq_zero_iff` for a version that takes into account junk values of `θ`. -/\ntheorem tan_eq_zero_iff' {θ : ℂ} (hθ : cos θ ≠ 0) : tan θ = 0 ↔ ∃ k : ℤ, k * π = θ := by\n  simp only [tan, hθ, div_eq_zero_iff, sin_eq_zero_iff]; simp [eq_comm]\n\n"}
{"name":"Complex.cos_eq_cos_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x y : Complex\n⊢ Iff (Eq (Complex.cos x) (Complex.cos y)) (Exists fun k => Or (Eq y (HAdd.hAdd (HMul.hMul (HMul.hMul 2 ↑k) ↑Real.pi) x)) (Eq y (HSub.hSub (HMul.hMul (HMul.hMul 2 ↑k) ↑Real.pi) x)))","decl":"theorem cos_eq_cos_iff {x y : ℂ} : cos x = cos y ↔ ∃ k : ℤ, y = 2 * k * π + x ∨ y = 2 * k * π - x :=\n  calc\n    cos x = cos y ↔ cos x - cos y = 0 := sub_eq_zero.symm\n    _ ↔ -2 * sin ((x + y) / 2) * sin ((x - y) / 2) = 0 := by rw [cos_sub_cos]\n    _ ↔ sin ((x + y) / 2) = 0 ∨ sin ((x - y) / 2) = 0 := by simp [(by norm_num : (2 : ℂ) ≠ 0)]\n    _ ↔ sin ((x - y) / 2) = 0 ∨ sin ((x + y) / 2) = 0 := or_comm\n    _ ↔ (∃ k : ℤ, y = 2 * k * π + x) ∨ ∃ k : ℤ, y = 2 * k * π - x := by\n      apply or_congr <;>\n        field_simp [sin_eq_zero_iff, (by norm_num : -(2 : ℂ) ≠ 0), eq_sub_iff_add_eq',\n          sub_eq_iff_eq_add, mul_comm (2 : ℂ), mul_right_comm _ (2 : ℂ)]\n      constructor <;> · rintro ⟨k, rfl⟩; use -k; simp\n    _ ↔ ∃ k : ℤ, y = 2 * k * π + x ∨ y = 2 * k * π - x := exists_or.symm\n\n"}
{"name":"Complex.sin_eq_sin_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x y : Complex\n⊢ Iff (Eq (Complex.sin x) (Complex.sin y)) (Exists fun k => Or (Eq y (HAdd.hAdd (HMul.hMul (HMul.hMul 2 ↑k) ↑Real.pi) x)) (Eq y (HSub.hSub (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑k) 1) ↑Real.pi) x)))","decl":"theorem sin_eq_sin_iff {x y : ℂ} :\n    sin x = sin y ↔ ∃ k : ℤ, y = 2 * k * π + x ∨ y = (2 * k + 1) * π - x := by\n  simp only [← Complex.cos_sub_pi_div_two, cos_eq_cos_iff, sub_eq_iff_eq_add]\n  refine exists_congr fun k => or_congr ?_ ?_ <;> refine Eq.congr rfl ?_ <;> field_simp <;> ring\n\n"}
{"name":"Complex.cos_eq_one_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x : Complex\n⊢ Iff (Eq (Complex.cos x) 1) (Exists fun k => Eq (HMul.hMul (↑k) (HMul.hMul 2 ↑Real.pi)) x)","decl":"theorem cos_eq_one_iff {x : ℂ} : cos x = 1 ↔ ∃ k : ℤ, k * (2 * π) = x := by\n  rw [← cos_zero, eq_comm, cos_eq_cos_iff]\n  simp [mul_assoc, mul_left_comm, eq_comm]\n\n"}
{"name":"Complex.cos_eq_neg_one_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x : Complex\n⊢ Iff (Eq (Complex.cos x) (-1)) (Exists fun k => Eq (HAdd.hAdd (↑Real.pi) (HMul.hMul (↑k) (HMul.hMul 2 ↑Real.pi))) x)","decl":"theorem cos_eq_neg_one_iff {x : ℂ} : cos x = -1 ↔ ∃ k : ℤ, π + k * (2 * π) = x := by\n  rw [← neg_eq_iff_eq_neg, ← cos_sub_pi, cos_eq_one_iff]\n  simp only [eq_sub_iff_add_eq']\n\n"}
{"name":"Complex.sin_eq_one_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x : Complex\n⊢ Iff (Eq (Complex.sin x) 1) (Exists fun k => Eq (HAdd.hAdd (HDiv.hDiv (↑Real.pi) 2) (HMul.hMul (↑k) (HMul.hMul 2 ↑Real.pi))) x)","decl":"theorem sin_eq_one_iff {x : ℂ} : sin x = 1 ↔ ∃ k : ℤ, π / 2 + k * (2 * π) = x := by\n  rw [← cos_sub_pi_div_two, cos_eq_one_iff]\n  simp only [eq_sub_iff_add_eq']\n\n"}
{"name":"Complex.sin_eq_neg_one_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x : Complex\n⊢ Iff (Eq (Complex.sin x) (-1)) (Exists fun k => Eq (HAdd.hAdd (Neg.neg (HDiv.hDiv (↑Real.pi) 2)) (HMul.hMul (↑k) (HMul.hMul 2 ↑Real.pi))) x)","decl":"theorem sin_eq_neg_one_iff {x : ℂ} : sin x = -1 ↔ ∃ k : ℤ, -(π / 2) + k * (2 * π) = x := by\n  rw [← neg_eq_iff_eq_neg, ← cos_add_pi_div_two, cos_eq_one_iff]\n  simp only [← sub_eq_neg_add, sub_eq_iff_eq_add]\n\n"}
{"name":"Complex.tan_add","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x y : Complex\nh : Or (And (∀ (k : Int), Ne x (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑k) 1) ↑Real.pi) 2)) (∀ (l : Int), Ne y (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑l) 1) ↑Real.pi) 2))) (And (Exists fun k => Eq x (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑k) 1) ↑Real.pi) 2)) (Exists fun l => Eq y (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑l) 1) ↑Real.pi) 2)))\n⊢ Eq (Complex.tan (HAdd.hAdd x y)) (HDiv.hDiv (HAdd.hAdd (Complex.tan x) (Complex.tan y)) (HSub.hSub 1 (HMul.hMul (Complex.tan x) (Complex.tan y))))","decl":"theorem tan_add {x y : ℂ}\n    (h : ((∀ k : ℤ, x ≠ (2 * k + 1) * π / 2) ∧ ∀ l : ℤ, y ≠ (2 * l + 1) * π / 2) ∨\n      (∃ k : ℤ, x = (2 * k + 1) * π / 2) ∧ ∃ l : ℤ, y = (2 * l + 1) * π / 2) :\n    tan (x + y) = (tan x + tan y) / (1 - tan x * tan y) := by\n  rcases h with (⟨h1, h2⟩ | ⟨⟨k, rfl⟩, ⟨l, rfl⟩⟩)\n  · rw [tan, sin_add, cos_add, ←\n      div_div_div_cancel_right₀ (mul_ne_zero (cos_ne_zero_iff.mpr h1) (cos_ne_zero_iff.mpr h2)),\n      add_div, sub_div]\n    simp only [← div_mul_div_comm, tan, mul_one, one_mul, div_self (cos_ne_zero_iff.mpr h1),\n      div_self (cos_ne_zero_iff.mpr h2)]\n  · haveI t := tan_int_mul_pi_div_two\n    obtain ⟨hx, hy, hxy⟩ := t (2 * k + 1), t (2 * l + 1), t (2 * k + 1 + (2 * l + 1))\n    simp only [Int.cast_add, Int.cast_two, Int.cast_mul, Int.cast_one, hx, hy] at hx hy hxy\n    rw [hx, hy, add_zero, zero_div, mul_div_assoc, mul_div_assoc, ←\n      add_mul (2 * (k : ℂ) + 1) (2 * l + 1) (π / 2), ← mul_div_assoc, hxy]\n\n"}
{"name":"Complex.tan_add'","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x y : Complex\nh : And (∀ (k : Int), Ne x (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑k) 1) ↑Real.pi) 2)) (∀ (l : Int), Ne y (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑l) 1) ↑Real.pi) 2))\n⊢ Eq (Complex.tan (HAdd.hAdd x y)) (HDiv.hDiv (HAdd.hAdd (Complex.tan x) (Complex.tan y)) (HSub.hSub 1 (HMul.hMul (Complex.tan x) (Complex.tan y))))","decl":"theorem tan_add' {x y : ℂ}\n    (h : (∀ k : ℤ, x ≠ (2 * k + 1) * π / 2) ∧ ∀ l : ℤ, y ≠ (2 * l + 1) * π / 2) :\n    tan (x + y) = (tan x + tan y) / (1 - tan x * tan y) :=\n  tan_add (Or.inl h)\n\n"}
{"name":"Complex.tan_two_mul","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"z : Complex\n⊢ Eq (Complex.tan (HMul.hMul 2 z)) (HDiv.hDiv (HMul.hMul 2 (Complex.tan z)) (HSub.hSub 1 (HPow.hPow (Complex.tan z) 2)))","decl":"theorem tan_two_mul {z : ℂ} : tan (2 * z) = (2 : ℂ) * tan z / ((1 : ℂ) - tan z ^ 2) := by\n  by_cases h : ∀ k : ℤ, z ≠ (2 * k + 1) * π / 2\n  · rw [two_mul, two_mul, sq, tan_add (Or.inl ⟨h, h⟩)]\n  · rw [not_forall_not] at h\n    rw [two_mul, two_mul, sq, tan_add (Or.inr ⟨h, h⟩)]\n\n"}
{"name":"Complex.tan_add_mul_I","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x y : Complex\nh : Or (And (∀ (k : Int), Ne x (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑k) 1) ↑Real.pi) 2)) (∀ (l : Int), Ne (HMul.hMul y Complex.I) (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑l) 1) ↑Real.pi) 2))) (And (Exists fun k => Eq x (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑k) 1) ↑Real.pi) 2)) (Exists fun l => Eq (HMul.hMul y Complex.I) (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑l) 1) ↑Real.pi) 2)))\n⊢ Eq (Complex.tan (HAdd.hAdd x (HMul.hMul y Complex.I))) (HDiv.hDiv (HAdd.hAdd (Complex.tan x) (HMul.hMul (Complex.tanh y) Complex.I)) (HSub.hSub 1 (HMul.hMul (HMul.hMul (Complex.tan x) (Complex.tanh y)) Complex.I)))","decl":"theorem tan_add_mul_I {x y : ℂ}\n    (h :\n      ((∀ k : ℤ, x ≠ (2 * k + 1) * π / 2) ∧ ∀ l : ℤ, y * I ≠ (2 * l + 1) * π / 2) ∨\n        (∃ k : ℤ, x = (2 * k + 1) * π / 2) ∧ ∃ l : ℤ, y * I = (2 * l + 1) * π / 2) :\n    tan (x + y * I) = (tan x + tanh y * I) / (1 - tan x * tanh y * I) := by\n  rw [tan_add h, tan_mul_I, mul_assoc]\n\n"}
{"name":"Complex.tan_eq","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"z : Complex\nh : Or (And (∀ (k : Int), Ne (↑z.re) (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑k) 1) ↑Real.pi) 2)) (∀ (l : Int), Ne (HMul.hMul (↑z.im) Complex.I) (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑l) 1) ↑Real.pi) 2))) (And (Exists fun k => Eq (↑z.re) (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑k) 1) ↑Real.pi) 2)) (Exists fun l => Eq (HMul.hMul (↑z.im) Complex.I) (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑l) 1) ↑Real.pi) 2)))\n⊢ Eq (Complex.tan z) (HDiv.hDiv (HAdd.hAdd (Complex.tan ↑z.re) (HMul.hMul (Complex.tanh ↑z.im) Complex.I)) (HSub.hSub 1 (HMul.hMul (HMul.hMul (Complex.tan ↑z.re) (Complex.tanh ↑z.im)) Complex.I)))","decl":"theorem tan_eq {z : ℂ}\n    (h :\n      ((∀ k : ℤ, (z.re : ℂ) ≠ (2 * k + 1) * π / 2) ∧\n          ∀ l : ℤ, (z.im : ℂ) * I ≠ (2 * l + 1) * π / 2) ∨\n        (∃ k : ℤ, (z.re : ℂ) = (2 * k + 1) * π / 2) ∧\n          ∃ l : ℤ, (z.im : ℂ) * I = (2 * l + 1) * π / 2) :\n    tan z = (tan z.re + tanh z.im * I) / (1 - tan z.re * tanh z.im * I) := by\n  convert tan_add_mul_I h; exact (re_add_im z).symm\n\n"}
{"name":"Complex.continuousOn_tan","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"⊢ ContinuousOn Complex.tan (setOf fun x => Ne (Complex.cos x) 0)","decl":"theorem continuousOn_tan : ContinuousOn tan {x | cos x ≠ 0} :=\n  continuousOn_sin.div continuousOn_cos fun _x => id\n\n"}
{"name":"Complex.continuous_tan","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"⊢ Continuous fun x => Complex.tan ↑x","decl":"@[continuity]\ntheorem continuous_tan : Continuous fun x : {x | cos x ≠ 0} => tan x :=\n  continuousOn_iff_continuous_restrict.1 continuousOn_tan\n\n"}
{"name":"Complex.cos_eq_iff_quadratic","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"z w : Complex\n⊢ Iff (Eq (Complex.cos z) w) (Eq (HAdd.hAdd (HSub.hSub (HPow.hPow (Complex.exp (HMul.hMul z Complex.I)) 2) (HMul.hMul (HMul.hMul 2 w) (Complex.exp (HMul.hMul z Complex.I)))) 1) 0)","decl":"theorem cos_eq_iff_quadratic {z w : ℂ} :\n    cos z = w ↔ exp (z * I) ^ 2 - 2 * w * exp (z * I) + 1 = 0 := by\n  rw [← sub_eq_zero]\n  field_simp [cos, exp_neg, exp_ne_zero]\n  refine Eq.congr ?_ rfl\n  ring\n\n"}
{"name":"Complex.cos_surjective","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"⊢ Function.Surjective Complex.cos","decl":"theorem cos_surjective : Function.Surjective cos := by\n  intro x\n  obtain ⟨w, w₀, hw⟩ : ∃ w ≠ 0, 1 * (w * w) + -2 * x * w + 1 = 0 := by\n    rcases exists_quadratic_eq_zero one_ne_zero\n        ⟨_, (cpow_nat_inv_pow _ two_ne_zero).symm.trans <| pow_two _⟩ with\n      ⟨w, hw⟩\n    refine ⟨w, ?_, hw⟩\n    rintro rfl\n    simp only [zero_add, one_ne_zero, mul_zero] at hw\n  refine ⟨log w / I, cos_eq_iff_quadratic.2 ?_⟩\n  rw [div_mul_cancel₀ _ I_ne_zero, exp_log w₀]\n  convert hw using 1\n  ring\n\n"}
{"name":"Complex.range_cos","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"⊢ Eq (Set.range Complex.cos) Set.univ","decl":"@[simp]\ntheorem range_cos : Set.range cos = Set.univ :=\n  cos_surjective.range_eq\n\n"}
{"name":"Complex.sin_surjective","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"⊢ Function.Surjective Complex.sin","decl":"theorem sin_surjective : Function.Surjective sin := by\n  intro x\n  rcases cos_surjective x with ⟨z, rfl⟩\n  exact ⟨z + π / 2, sin_add_pi_div_two z⟩\n\n"}
{"name":"Complex.range_sin","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"⊢ Eq (Set.range Complex.sin) Set.univ","decl":"@[simp]\ntheorem range_sin : Set.range sin = Set.univ :=\n  sin_surjective.range_eq\n\n"}
{"name":"Real.cos_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"θ : Real\n⊢ Iff (Eq (Real.cos θ) 0) (Exists fun k => Eq θ (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑k) 1) Real.pi) 2))","decl":"theorem cos_eq_zero_iff {θ : ℝ} : cos θ = 0 ↔ ∃ k : ℤ, θ = (2 * k + 1) * π / 2 :=\n  mod_cast @Complex.cos_eq_zero_iff θ\n\n"}
{"name":"Real.cos_ne_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"θ : Real\n⊢ Iff (Ne (Real.cos θ) 0) (∀ (k : Int), Ne θ (HDiv.hDiv (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑k) 1) Real.pi) 2))","decl":"theorem cos_ne_zero_iff {θ : ℝ} : cos θ ≠ 0 ↔ ∀ k : ℤ, θ ≠ (2 * k + 1) * π / 2 :=\n  mod_cast @Complex.cos_ne_zero_iff θ\n\n"}
{"name":"Real.cos_eq_cos_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x y : Real\n⊢ Iff (Eq (Real.cos x) (Real.cos y)) (Exists fun k => Or (Eq y (HAdd.hAdd (HMul.hMul (HMul.hMul 2 ↑k) Real.pi) x)) (Eq y (HSub.hSub (HMul.hMul (HMul.hMul 2 ↑k) Real.pi) x)))","decl":"theorem cos_eq_cos_iff {x y : ℝ} : cos x = cos y ↔ ∃ k : ℤ, y = 2 * k * π + x ∨ y = 2 * k * π - x :=\n  mod_cast @Complex.cos_eq_cos_iff x y\n\n"}
{"name":"Real.sin_eq_sin_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x y : Real\n⊢ Iff (Eq (Real.sin x) (Real.sin y)) (Exists fun k => Or (Eq y (HAdd.hAdd (HMul.hMul (HMul.hMul 2 ↑k) Real.pi) x)) (Eq y (HSub.hSub (HMul.hMul (HAdd.hAdd (HMul.hMul 2 ↑k) 1) Real.pi) x)))","decl":"theorem sin_eq_sin_iff {x y : ℝ} :\n    sin x = sin y ↔ ∃ k : ℤ, y = 2 * k * π + x ∨ y = (2 * k + 1) * π - x :=\n  mod_cast @Complex.sin_eq_sin_iff x y\n\n"}
{"name":"Real.cos_eq_neg_one_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x : Real\n⊢ Iff (Eq (Real.cos x) (-1)) (Exists fun k => Eq (HAdd.hAdd Real.pi (HMul.hMul (↑k) (HMul.hMul 2 Real.pi))) x)","decl":"theorem cos_eq_neg_one_iff {x : ℝ} : cos x = -1 ↔ ∃ k : ℤ, π + k * (2 * π) = x :=\n  mod_cast @Complex.cos_eq_neg_one_iff x\n\n"}
{"name":"Real.sin_eq_one_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x : Real\n⊢ Iff (Eq (Real.sin x) 1) (Exists fun k => Eq (HAdd.hAdd (HDiv.hDiv Real.pi 2) (HMul.hMul (↑k) (HMul.hMul 2 Real.pi))) x)","decl":"theorem sin_eq_one_iff {x : ℝ} : sin x = 1 ↔ ∃ k : ℤ, π / 2 + k * (2 * π) = x :=\n  mod_cast @Complex.sin_eq_one_iff x\n\n"}
{"name":"Real.sin_eq_neg_one_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"x : Real\n⊢ Iff (Eq (Real.sin x) (-1)) (Exists fun k => Eq (HAdd.hAdd (Neg.neg (HDiv.hDiv Real.pi 2)) (HMul.hMul (↑k) (HMul.hMul 2 Real.pi))) x)","decl":"theorem sin_eq_neg_one_iff {x : ℝ} : sin x = -1 ↔ ∃ k : ℤ, -(π / 2) + k * (2 * π) = x :=\n  mod_cast @Complex.sin_eq_neg_one_iff x\n\n"}
{"name":"Real.tan_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"θ : Real\n⊢ Iff (Eq (Real.tan θ) 0) (Exists fun k => Eq (HDiv.hDiv (HMul.hMul (↑k) Real.pi) 2) θ)","decl":"theorem tan_eq_zero_iff {θ : ℝ} : tan θ = 0 ↔ ∃ k : ℤ, k * π / 2 = θ :=\n  mod_cast @Complex.tan_eq_zero_iff θ\n\n"}
{"name":"Real.tan_eq_zero_iff'","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"θ : Real\nhθ : Ne (Real.cos θ) 0\n⊢ Iff (Eq (Real.tan θ) 0) (Exists fun k => Eq (HMul.hMul (↑k) Real.pi) θ)","decl":"theorem tan_eq_zero_iff' {θ : ℝ} (hθ : cos θ ≠ 0) : tan θ = 0 ↔ ∃ k : ℤ, k * π = θ := by\n  revert hθ\n  exact_mod_cast @Complex.tan_eq_zero_iff' θ\n\n"}
{"name":"Real.tan_ne_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.Complex","initialProofState":"θ : Real\n⊢ Iff (Ne (Real.tan θ) 0) (∀ (k : Int), Ne (HDiv.hDiv (HMul.hMul (↑k) Real.pi) 2) θ)","decl":"theorem tan_ne_zero_iff {θ : ℝ} : tan θ ≠ 0 ↔ ∀ k : ℤ, k * π / 2 ≠ θ :=\n  mod_cast @Complex.tan_ne_zero_iff θ\n\n"}
