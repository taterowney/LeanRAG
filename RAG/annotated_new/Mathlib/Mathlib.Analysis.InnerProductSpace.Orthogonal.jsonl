{"name":"Submodule.mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nv : E\nâŠ¢ Iff (Membership.mem K.orthogonal v) (âˆ€ (u : E), Membership.mem K u â†’ Eq (Inner.inner u v) 0)","decl":"/-- When a vector is in `Ká—®`. -/\ntheorem mem_orthogonal (v : E) : v âˆˆ Ká—® â†” âˆ€ u âˆˆ K, âŸªu, vâŸ« = 0 :=\n  Iff.rfl\n\n"}
{"name":"Submodule.mem_orthogonal'","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nv : E\nâŠ¢ Iff (Membership.mem K.orthogonal v) (âˆ€ (u : E), Membership.mem K u â†’ Eq (Inner.inner v u) 0)","decl":"/-- When a vector is in `Ká—®`, with the inner product the\nother way round. -/\ntheorem mem_orthogonal' (v : E) : v âˆˆ Ká—® â†” âˆ€ u âˆˆ K, âŸªv, uâŸ« = 0 := by\n  simp_rw [mem_orthogonal, inner_eq_zero_symm]\n\n"}
{"name":"Submodule.inner_right_of_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nu v : E\nhu : Membership.mem K u\nhv : Membership.mem K.orthogonal v\nâŠ¢ Eq (Inner.inner u v) 0","decl":"/-- A vector in `K` is orthogonal to one in `Ká—®`. -/\ntheorem inner_right_of_mem_orthogonal {u v : E} (hu : u âˆˆ K) (hv : v âˆˆ Ká—®) : âŸªu, vâŸ« = 0 :=\n  (K.mem_orthogonal v).1 hv u hu\n\n"}
{"name":"Submodule.inner_left_of_mem_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nu v : E\nhu : Membership.mem K u\nhv : Membership.mem K.orthogonal v\nâŠ¢ Eq (Inner.inner v u) 0","decl":"/-- A vector in `Ká—®` is orthogonal to one in `K`. -/\ntheorem inner_left_of_mem_orthogonal {u v : E} (hu : u âˆˆ K) (hv : v âˆˆ Ká—®) : âŸªv, uâŸ« = 0 := by\n  rw [inner_eq_zero_symm]; exact inner_right_of_mem_orthogonal hu hv\n\n"}
{"name":"Submodule.mem_orthogonal_singleton_iff_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nu v : E\nâŠ¢ Iff (Membership.mem (Submodule.span ğ•œ (Singleton.singleton u)).orthogonal v) (Eq (Inner.inner u v) 0)","decl":"/-- A vector is in `(ğ•œ âˆ™ u)á—®` iff it is orthogonal to `u`. -/\ntheorem mem_orthogonal_singleton_iff_inner_right {u v : E} : v âˆˆ (ğ•œ âˆ™ u)á—® â†” âŸªu, vâŸ« = 0 := by\n  refine âŸ¨inner_right_of_mem_orthogonal (mem_span_singleton_self u), ?_âŸ©\n  intro hv w hw\n  rw [mem_span_singleton] at hw\n  obtain âŸ¨c, rflâŸ© := hw\n  simp [inner_smul_left, hv]\n\n"}
{"name":"Submodule.mem_orthogonal_singleton_iff_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nu v : E\nâŠ¢ Iff (Membership.mem (Submodule.span ğ•œ (Singleton.singleton u)).orthogonal v) (Eq (Inner.inner v u) 0)","decl":"/-- A vector in `(ğ•œ âˆ™ u)á—®` is orthogonal to `u`. -/\ntheorem mem_orthogonal_singleton_iff_inner_left {u v : E} : v âˆˆ (ğ•œ âˆ™ u)á—® â†” âŸªv, uâŸ« = 0 := by\n  rw [mem_orthogonal_singleton_iff_inner_right, inner_eq_zero_symm]\n\n"}
{"name":"Submodule.sub_mem_orthogonal_of_inner_left","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nx y : E\nh : âˆ€ (v : Subtype fun x => Membership.mem K x), Eq (Inner.inner x â†‘v) (Inner.inner y â†‘v)\nâŠ¢ Membership.mem K.orthogonal (HSub.hSub x y)","decl":"theorem sub_mem_orthogonal_of_inner_left {x y : E} (h : âˆ€ v : K, âŸªx, vâŸ« = âŸªy, vâŸ«) : x - y âˆˆ Ká—® := by\n  rw [mem_orthogonal']\n  intro u hu\n  rw [inner_sub_left, sub_eq_zero]\n  exact h âŸ¨u, huâŸ©\n\n"}
{"name":"Submodule.sub_mem_orthogonal_of_inner_right","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nx y : E\nh : âˆ€ (v : Subtype fun x => Membership.mem K x), Eq (Inner.inner (â†‘v) x) (Inner.inner (â†‘v) y)\nâŠ¢ Membership.mem K.orthogonal (HSub.hSub x y)","decl":"theorem sub_mem_orthogonal_of_inner_right {x y : E} (h : âˆ€ v : K, âŸª(v : E), xâŸ« = âŸª(v : E), yâŸ«) :\n    x - y âˆˆ Ká—® := by\n  intro u hu\n  rw [inner_sub_right, sub_eq_zero]\n  exact h âŸ¨u, huâŸ©\n\n"}
{"name":"Submodule.inf_orthogonal_eq_bot","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nâŠ¢ Eq (Min.min K K.orthogonal) Bot.bot","decl":"/-- `K` and `Ká—®` have trivial intersection. -/\ntheorem inf_orthogonal_eq_bot : K âŠ“ Ká—® = âŠ¥ := by\n  rw [eq_bot_iff]\n  intro x\n  rw [mem_inf]\n  exact fun âŸ¨hx, hoâŸ© => inner_self_eq_zero.1 (ho x hx)\n\n"}
{"name":"Submodule.orthogonal_disjoint","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nâŠ¢ Disjoint K K.orthogonal","decl":"/-- `K` and `Ká—®` have trivial intersection. -/\ntheorem orthogonal_disjoint : Disjoint K Ká—® := by simp [disjoint_iff, K.inf_orthogonal_eq_bot]\n\n"}
{"name":"Submodule.orthogonal_eq_inter","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nâŠ¢ Eq K.orthogonal (iInf fun v => LinearMap.ker ((innerSL ğ•œ) â†‘v))","decl":"/-- `Ká—®` can be characterized as the intersection of the kernels of the operations of\ninner product with each of the elements of `K`. -/\ntheorem orthogonal_eq_inter : Ká—® = â¨… v : K, LinearMap.ker (innerSL ğ•œ (v : E)) := by\n  apply le_antisymm\n  Â· rw [le_iInf_iff]\n    rintro âŸ¨v, hvâŸ© w hw\n    simpa using hw _ hv\n  Â· intro v hv w hw\n    simp only [mem_iInf] at hv\n    exact hv âŸ¨w, hwâŸ©\n\n"}
{"name":"Submodule.isClosed_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nâŠ¢ IsClosed â†‘K.orthogonal","decl":"/-- The orthogonal complement of any submodule `K` is closed. -/\ntheorem isClosed_orthogonal : IsClosed (Ká—® : Set E) := by\n  rw [orthogonal_eq_inter K]\n  convert isClosed_iInter <| fun v : K => ContinuousLinearMap.isClosed_ker (innerSL ğ•œ (v : E))\n  simp only [iInf_coe]\n\n"}
{"name":"Submodule.instOrthogonalCompleteSpace","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\ninstâœ : CompleteSpace E\nâŠ¢ CompleteSpace (Subtype fun x => Membership.mem K.orthogonal x)","decl":"/-- In a complete space, the orthogonal complement of any submodule `K` is complete. -/\ninstance instOrthogonalCompleteSpace [CompleteSpace E] : CompleteSpace Ká—® :=\n  K.isClosed_orthogonal.completeSpace_coe\n\n"}
{"name":"Submodule.orthogonal_gc","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ GaloisConnection Submodule.orthogonal Submodule.orthogonal","decl":"/-- `orthogonal` gives a `GaloisConnection` between\n`Submodule ğ•œ E` and its `OrderDual`. -/\ntheorem orthogonal_gc :\n    @GaloisConnection (Submodule ğ•œ E) (Submodule ğ•œ E)áµ’áµˆ _ _ orthogonal orthogonal := fun _Kâ‚ _Kâ‚‚ =>\n  âŸ¨fun h _v hv _u hu => inner_left_of_mem_orthogonal hv (h hu), fun h _v hv _u hu =>\n    inner_left_of_mem_orthogonal hv (h hu)âŸ©\n\n"}
{"name":"Submodule.orthogonal_le","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nKâ‚ Kâ‚‚ : Submodule ğ•œ E\nh : LE.le Kâ‚ Kâ‚‚\nâŠ¢ LE.le Kâ‚‚.orthogonal Kâ‚.orthogonal","decl":"/-- `orthogonal` reverses the `â‰¤` ordering of two\nsubspaces. -/\ntheorem orthogonal_le {Kâ‚ Kâ‚‚ : Submodule ğ•œ E} (h : Kâ‚ â‰¤ Kâ‚‚) : Kâ‚‚á—® â‰¤ Kâ‚á—® :=\n  (orthogonal_gc ğ•œ E).monotone_l h\n\n"}
{"name":"Submodule.orthogonal_orthogonal_monotone","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nKâ‚ Kâ‚‚ : Submodule ğ•œ E\nh : LE.le Kâ‚ Kâ‚‚\nâŠ¢ LE.le Kâ‚.orthogonal.orthogonal Kâ‚‚.orthogonal.orthogonal","decl":"/-- `orthogonal.orthogonal` preserves the `â‰¤` ordering of two\nsubspaces. -/\ntheorem orthogonal_orthogonal_monotone {Kâ‚ Kâ‚‚ : Submodule ğ•œ E} (h : Kâ‚ â‰¤ Kâ‚‚) : Kâ‚á—®á—® â‰¤ Kâ‚‚á—®á—® :=\n  orthogonal_le (orthogonal_le h)\n\n"}
{"name":"Submodule.le_orthogonal_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nâŠ¢ LE.le K K.orthogonal.orthogonal","decl":"/-- `K` is contained in `Ká—®á—®`. -/\ntheorem le_orthogonal_orthogonal : K â‰¤ Ká—®á—® :=\n  (orthogonal_gc ğ•œ E).le_u_l _\n\n"}
{"name":"Submodule.inf_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nKâ‚ Kâ‚‚ : Submodule ğ•œ E\nâŠ¢ Eq (Min.min Kâ‚.orthogonal Kâ‚‚.orthogonal) (Max.max Kâ‚ Kâ‚‚).orthogonal","decl":"/-- The inf of two orthogonal subspaces equals the subspace orthogonal\nto the sup. -/\ntheorem inf_orthogonal (Kâ‚ Kâ‚‚ : Submodule ğ•œ E) : Kâ‚á—® âŠ“ Kâ‚‚á—® = (Kâ‚ âŠ” Kâ‚‚)á—® :=\n  (orthogonal_gc ğ•œ E).l_sup.symm\n\n"}
{"name":"Submodule.iInf_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nK : Î¹ â†’ Submodule ğ•œ E\nâŠ¢ Eq (iInf fun i => (K i).orthogonal) (iSup K).orthogonal","decl":"/-- The inf of an indexed family of orthogonal subspaces equals the\nsubspace orthogonal to the sup. -/\ntheorem iInf_orthogonal {Î¹ : Type*} (K : Î¹ â†’ Submodule ğ•œ E) : â¨… i, (K i)á—® = (iSup K)á—® :=\n  (orthogonal_gc ğ•œ E).l_iSup.symm\n\n"}
{"name":"Submodule.sInf_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\ns : Set (Submodule ğ•œ E)\nâŠ¢ Eq (iInf fun K => iInf fun h => K.orthogonal) (SupSet.sSup s).orthogonal","decl":"/-- The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. -/\ntheorem sInf_orthogonal (s : Set <| Submodule ğ•œ E) : â¨… K âˆˆ s, Ká—® = (sSup s)á—® :=\n  (orthogonal_gc ğ•œ E).l_sSup.symm\n\n"}
{"name":"Submodule.top_orthogonal_eq_bot","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ Eq Top.top.orthogonal Bot.bot","decl":"@[simp]\ntheorem top_orthogonal_eq_bot : (âŠ¤ : Submodule ğ•œ E)á—® = âŠ¥ := by\n  ext x\n  rw [mem_bot, mem_orthogonal]\n  exact\n    âŸ¨fun h => inner_self_eq_zero.mp (h x mem_top), by\n      rintro rfl\n      simpâŸ©\n\n"}
{"name":"Submodule.bot_orthogonal_eq_top","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ Eq Bot.bot.orthogonal Top.top","decl":"@[simp]\ntheorem bot_orthogonal_eq_top : (âŠ¥ : Submodule ğ•œ E)á—® = âŠ¤ := by\n  rw [â† top_orthogonal_eq_bot, eq_top_iff]\n  exact le_orthogonal_orthogonal âŠ¤\n\n"}
{"name":"Submodule.orthogonal_eq_top_iff","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nâŠ¢ Iff (Eq K.orthogonal Top.top) (Eq K Bot.bot)","decl":"@[simp]\ntheorem orthogonal_eq_top_iff : Ká—® = âŠ¤ â†” K = âŠ¥ := by\n  refine\n    âŸ¨?_, by\n      rintro rfl\n      exact bot_orthogonal_eq_topâŸ©\n  intro h\n  have : K âŠ“ Ká—® = âŠ¥ := K.orthogonal_disjoint.eq_bot\n  rwa [h, inf_comm, top_inf_eq] at this\n\n"}
{"name":"Submodule.orthogonalFamily_self","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nK : Submodule ğ•œ E\nâŠ¢ OrthogonalFamily ğ•œ (fun b => Subtype fun x => Membership.mem (cond b K K.orthogonal) x) fun b => (cond b K K.orthogonal).subtypeâ‚—áµ¢","decl":"theorem orthogonalFamily_self :\n    OrthogonalFamily ğ•œ (fun b => â†¥(cond b K Ká—®)) fun b => (cond b K Ká—®).subtypeâ‚—áµ¢\n  | true, true => absurd rfl\n  | true, false => fun _ x y => inner_right_of_mem_orthogonal x.prop y.prop\n  | false, true => fun _ x y => inner_left_of_mem_orthogonal y.prop x.prop\n  | false, false => absurd rfl\n\n"}
{"name":"bilinFormOfRealInner_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"E : Type u_4\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace Real E\nK : Submodule Real E\nâŠ¢ Eq (K.orthogonalBilin bilinFormOfRealInner) K.orthogonal","decl":"@[simp]\ntheorem bilinFormOfRealInner_orthogonal {E} [NormedAddCommGroup E] [InnerProductSpace â„ E]\n    (K : Submodule â„ E) : K.orthogonalBilin bilinFormOfRealInner = Ká—® :=\n  rfl\n\n"}
{"name":"Submodule.isOrtho_iff_le","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU V : Submodule ğ•œ E\nâŠ¢ Iff (U.IsOrtho V) (LE.le U V.orthogonal)","decl":"theorem isOrtho_iff_le {U V : Submodule ğ•œ E} : U âŸ‚ V â†” U â‰¤ Vá—® :=\n  Iff.rfl\n\n"}
{"name":"Submodule.IsOrtho.symm","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU V : Submodule ğ•œ E\nh : U.IsOrtho V\nâŠ¢ V.IsOrtho U","decl":"@[symm]\ntheorem IsOrtho.symm {U V : Submodule ğ•œ E} (h : U âŸ‚ V) : V âŸ‚ U :=\n  (le_orthogonal_orthogonal _).trans (orthogonal_le h)\n\n"}
{"name":"Submodule.isOrtho_comm","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU V : Submodule ğ•œ E\nâŠ¢ Iff (U.IsOrtho V) (V.IsOrtho U)","decl":"theorem isOrtho_comm {U V : Submodule ğ•œ E} : U âŸ‚ V â†” V âŸ‚ U :=\n  âŸ¨IsOrtho.symm, IsOrtho.symmâŸ©\n\n"}
{"name":"Submodule.symmetric_isOrtho","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nâŠ¢ Symmetric Submodule.IsOrtho","decl":"theorem symmetric_isOrtho : Symmetric (IsOrtho : Submodule ğ•œ E â†’ Submodule ğ•œ E â†’ Prop) := fun _ _ =>\n  IsOrtho.symm\n\n"}
{"name":"Submodule.IsOrtho.inner_eq","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU V : Submodule ğ•œ E\nh : U.IsOrtho V\nu v : E\nhu : Membership.mem U u\nhv : Membership.mem V v\nâŠ¢ Eq (Inner.inner u v) 0","decl":"theorem IsOrtho.inner_eq {U V : Submodule ğ•œ E} (h : U âŸ‚ V) {u v : E} (hu : u âˆˆ U) (hv : v âˆˆ V) :\n    âŸªu, vâŸ« = 0 :=\n  h.symm hv _ hu\n\n"}
{"name":"Submodule.isOrtho_iff_inner_eq","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU V : Submodule ğ•œ E\nâŠ¢ Iff (U.IsOrtho V) (âˆ€ (u : E), Membership.mem U u â†’ âˆ€ (v : E), Membership.mem V v â†’ Eq (Inner.inner u v) 0)","decl":"theorem isOrtho_iff_inner_eq {U V : Submodule ğ•œ E} : U âŸ‚ V â†” âˆ€ u âˆˆ U, âˆ€ v âˆˆ V, âŸªu, vâŸ« = 0 :=\n  forallâ‚„_congr fun _u _hu _v _hv => inner_eq_zero_symm\n\n/- TODO: generalize `Submodule.mapâ‚‚` to semilinear maps, so that we can state\n`U âŸ‚ V â†” Submodule.mapâ‚‚ (innerâ‚›â‚— ğ•œ) U V â‰¤ âŠ¥`. -/\n"}
{"name":"Submodule.isOrtho_bot_left","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nV : Submodule ğ•œ E\nâŠ¢ Bot.bot.IsOrtho V","decl":"@[simp]\ntheorem isOrtho_bot_left {V : Submodule ğ•œ E} : âŠ¥ âŸ‚ V :=\n  bot_le\n\n"}
{"name":"Submodule.isOrtho_bot_right","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU : Submodule ğ•œ E\nâŠ¢ U.IsOrtho Bot.bot","decl":"@[simp]\ntheorem isOrtho_bot_right {U : Submodule ğ•œ E} : U âŸ‚ âŠ¥ :=\n  isOrtho_bot_left.symm\n\n"}
{"name":"Submodule.IsOrtho.mono_left","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nUâ‚ Uâ‚‚ V : Submodule ğ•œ E\nhU : LE.le Uâ‚‚ Uâ‚\nh : Uâ‚.IsOrtho V\nâŠ¢ Uâ‚‚.IsOrtho V","decl":"theorem IsOrtho.mono_left {Uâ‚ Uâ‚‚ V : Submodule ğ•œ E} (hU : Uâ‚‚ â‰¤ Uâ‚) (h : Uâ‚ âŸ‚ V) : Uâ‚‚ âŸ‚ V :=\n  hU.trans h\n\n"}
{"name":"Submodule.IsOrtho.mono_right","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU Vâ‚ Vâ‚‚ : Submodule ğ•œ E\nhV : LE.le Vâ‚‚ Vâ‚\nh : U.IsOrtho Vâ‚\nâŠ¢ U.IsOrtho Vâ‚‚","decl":"theorem IsOrtho.mono_right {U Vâ‚ Vâ‚‚ : Submodule ğ•œ E} (hV : Vâ‚‚ â‰¤ Vâ‚) (h : U âŸ‚ Vâ‚) : U âŸ‚ Vâ‚‚ :=\n  (h.symm.mono_left hV).symm\n\n"}
{"name":"Submodule.IsOrtho.mono","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nUâ‚ Vâ‚ Uâ‚‚ Vâ‚‚ : Submodule ğ•œ E\nhU : LE.le Uâ‚‚ Uâ‚\nhV : LE.le Vâ‚‚ Vâ‚\nh : Uâ‚.IsOrtho Vâ‚\nâŠ¢ Uâ‚‚.IsOrtho Vâ‚‚","decl":"theorem IsOrtho.mono {Uâ‚ Vâ‚ Uâ‚‚ Vâ‚‚ : Submodule ğ•œ E} (hU : Uâ‚‚ â‰¤ Uâ‚) (hV : Vâ‚‚ â‰¤ Vâ‚) (h : Uâ‚ âŸ‚ Vâ‚) :\n    Uâ‚‚ âŸ‚ Vâ‚‚ :=\n  (h.mono_right hV).mono_left hU\n\n"}
{"name":"Submodule.isOrtho_self","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU : Submodule ğ•œ E\nâŠ¢ Iff (U.IsOrtho U) (Eq U Bot.bot)","decl":"@[simp]\ntheorem isOrtho_self {U : Submodule ğ•œ E} : U âŸ‚ U â†” U = âŠ¥ :=\n  âŸ¨fun h => eq_bot_iff.mpr fun x hx => inner_self_eq_zero.mp (h hx x hx), fun h =>\n    h.symm â–¸ isOrtho_bot_leftâŸ©\n\n"}
{"name":"Submodule.isOrtho_orthogonal_right","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU : Submodule ğ•œ E\nâŠ¢ U.IsOrtho U.orthogonal","decl":"@[simp]\ntheorem isOrtho_orthogonal_right (U : Submodule ğ•œ E) : U âŸ‚ Uá—® :=\n  le_orthogonal_orthogonal _\n\n"}
{"name":"Submodule.isOrtho_orthogonal_left","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU : Submodule ğ•œ E\nâŠ¢ U.orthogonal.IsOrtho U","decl":"@[simp]\ntheorem isOrtho_orthogonal_left (U : Submodule ğ•œ E) : Uá—® âŸ‚ U :=\n  (isOrtho_orthogonal_right U).symm\n\n"}
{"name":"Submodule.IsOrtho.le","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU V : Submodule ğ•œ E\nh : U.IsOrtho V\nâŠ¢ LE.le U V.orthogonal","decl":"theorem IsOrtho.le {U V : Submodule ğ•œ E} (h : U âŸ‚ V) : U â‰¤ Vá—® :=\n  h\n\n"}
{"name":"Submodule.IsOrtho.ge","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU V : Submodule ğ•œ E\nh : U.IsOrtho V\nâŠ¢ LE.le V U.orthogonal","decl":"theorem IsOrtho.ge {U V : Submodule ğ•œ E} (h : U âŸ‚ V) : V â‰¤ Uá—® :=\n  h.symm\n\n"}
{"name":"Submodule.isOrtho_top_right","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU : Submodule ğ•œ E\nâŠ¢ Iff (U.IsOrtho Top.top) (Eq U Bot.bot)","decl":"@[simp]\ntheorem isOrtho_top_right {U : Submodule ğ•œ E} : U âŸ‚ âŠ¤ â†” U = âŠ¥ :=\n  âŸ¨fun h => eq_bot_iff.mpr fun _x hx => inner_self_eq_zero.mp (h hx _ mem_top), fun h =>\n    h.symm â–¸ isOrtho_bot_leftâŸ©\n\n"}
{"name":"Submodule.isOrtho_top_left","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nV : Submodule ğ•œ E\nâŠ¢ Iff (Top.top.IsOrtho V) (Eq V Bot.bot)","decl":"@[simp]\ntheorem isOrtho_top_left {V : Submodule ğ•œ E} : âŠ¤ âŸ‚ V â†” V = âŠ¥ :=\n  isOrtho_comm.trans isOrtho_top_right\n\n"}
{"name":"Submodule.IsOrtho.disjoint","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU V : Submodule ğ•œ E\nh : U.IsOrtho V\nâŠ¢ Disjoint U V","decl":"/-- Orthogonal submodules are disjoint. -/\ntheorem IsOrtho.disjoint {U V : Submodule ğ•œ E} (h : U âŸ‚ V) : Disjoint U V :=\n  (Submodule.orthogonal_disjoint _).mono_right h.symm\n\n"}
{"name":"Submodule.isOrtho_sup_left","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nUâ‚ Uâ‚‚ V : Submodule ğ•œ E\nâŠ¢ Iff ((Max.max Uâ‚ Uâ‚‚).IsOrtho V) (And (Uâ‚.IsOrtho V) (Uâ‚‚.IsOrtho V))","decl":"@[simp]\ntheorem isOrtho_sup_left {Uâ‚ Uâ‚‚ V : Submodule ğ•œ E} : Uâ‚ âŠ” Uâ‚‚ âŸ‚ V â†” Uâ‚ âŸ‚ V âˆ§ Uâ‚‚ âŸ‚ V :=\n  sup_le_iff\n\n"}
{"name":"Submodule.isOrtho_sup_right","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU Vâ‚ Vâ‚‚ : Submodule ğ•œ E\nâŠ¢ Iff (U.IsOrtho (Max.max Vâ‚ Vâ‚‚)) (And (U.IsOrtho Vâ‚) (U.IsOrtho Vâ‚‚))","decl":"@[simp]\ntheorem isOrtho_sup_right {U Vâ‚ Vâ‚‚ : Submodule ğ•œ E} : U âŸ‚ Vâ‚ âŠ” Vâ‚‚ â†” U âŸ‚ Vâ‚ âˆ§ U âŸ‚ Vâ‚‚ :=\n  isOrtho_comm.trans <| isOrtho_sup_left.trans <| isOrtho_comm.and isOrtho_comm\n\n"}
{"name":"Submodule.isOrtho_sSup_left","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU : Set (Submodule ğ•œ E)\nV : Submodule ğ•œ E\nâŠ¢ Iff ((SupSet.sSup U).IsOrtho V) (âˆ€ (Uáµ¢ : Submodule ğ•œ E), Membership.mem U Uáµ¢ â†’ Uáµ¢.IsOrtho V)","decl":"@[simp]\ntheorem isOrtho_sSup_left {U : Set (Submodule ğ•œ E)} {V : Submodule ğ•œ E} :\n    sSup U âŸ‚ V â†” âˆ€ Uáµ¢ âˆˆ U, Uáµ¢ âŸ‚ V :=\n  sSup_le_iff\n\n"}
{"name":"Submodule.isOrtho_sSup_right","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nU : Submodule ğ•œ E\nV : Set (Submodule ğ•œ E)\nâŠ¢ Iff (U.IsOrtho (SupSet.sSup V)) (âˆ€ (Váµ¢ : Submodule ğ•œ E), Membership.mem V Váµ¢ â†’ U.IsOrtho Váµ¢)","decl":"@[simp]\ntheorem isOrtho_sSup_right {U : Submodule ğ•œ E} {V : Set (Submodule ğ•œ E)} :\n    U âŸ‚ sSup V â†” âˆ€ Váµ¢ âˆˆ V, U âŸ‚ Váµ¢ :=\n  isOrtho_comm.trans <| isOrtho_sSup_left.trans <| by simp_rw [isOrtho_comm]\n\n"}
{"name":"Submodule.isOrtho_iSup_left","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Sort u_4\nU : Î¹ â†’ Submodule ğ•œ E\nV : Submodule ğ•œ E\nâŠ¢ Iff ((iSup U).IsOrtho V) (âˆ€ (i : Î¹), (U i).IsOrtho V)","decl":"@[simp]\ntheorem isOrtho_iSup_left {Î¹ : Sort*} {U : Î¹ â†’ Submodule ğ•œ E} {V : Submodule ğ•œ E} :\n    iSup U âŸ‚ V â†” âˆ€ i, U i âŸ‚ V :=\n  iSup_le_iff\n\n"}
{"name":"Submodule.isOrtho_iSup_right","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Sort u_4\nU : Submodule ğ•œ E\nV : Î¹ â†’ Submodule ğ•œ E\nâŠ¢ Iff (U.IsOrtho (iSup V)) (âˆ€ (i : Î¹), U.IsOrtho (V i))","decl":"@[simp]\ntheorem isOrtho_iSup_right {Î¹ : Sort*} {U : Submodule ğ•œ E} {V : Î¹ â†’ Submodule ğ•œ E} :\n    U âŸ‚ iSup V â†” âˆ€ i, U âŸ‚ V i :=\n  isOrtho_comm.trans <| isOrtho_iSup_left.trans <| by simp_rw [isOrtho_comm]\n\n"}
{"name":"Submodule.isOrtho_span","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\ns t : Set E\nâŠ¢ Iff ((Submodule.span ğ•œ s).IsOrtho (Submodule.span ğ•œ t)) (âˆ€ â¦ƒu : Eâ¦„, Membership.mem s u â†’ âˆ€ â¦ƒv : Eâ¦„, Membership.mem t v â†’ Eq (Inner.inner u v) 0)","decl":"@[simp]\ntheorem isOrtho_span {s t : Set E} :\n    span ğ•œ s âŸ‚ span ğ•œ t â†” âˆ€ â¦ƒuâ¦„, u âˆˆ s â†’ âˆ€ â¦ƒvâ¦„, v âˆˆ t â†’ âŸªu, vâŸ« = 0 := by\n  simp_rw [span_eq_iSup_of_singleton_spans s, span_eq_iSup_of_singleton_spans t, isOrtho_iSup_left,\n    isOrtho_iSup_right, isOrtho_iff_le, span_le, Set.subset_def, SetLike.mem_coe,\n    mem_orthogonal_singleton_iff_inner_left, Set.mem_singleton_iff, forall_eq]\n\n"}
{"name":"Submodule.IsOrtho.map","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace ğ•œ F\nf : LinearIsometry (RingHom.id ğ•œ) E F\nU V : Submodule ğ•œ E\nh : U.IsOrtho V\nâŠ¢ (Submodule.map f U).IsOrtho (Submodule.map f V)","decl":"theorem IsOrtho.map (f : E â†’â‚—áµ¢[ğ•œ] F) {U V : Submodule ğ•œ E} (h : U âŸ‚ V) : U.map f âŸ‚ V.map f := by\n  rw [isOrtho_iff_inner_eq] at *\n  simp_rw [mem_map, forall_exists_index, and_imp, forall_apply_eq_imp_iffâ‚‚,\n    LinearIsometry.inner_map_map]\n  exact h\n\n"}
{"name":"Submodule.IsOrtho.comap","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace ğ•œ F\nf : LinearIsometry (RingHom.id ğ•œ) E F\nU V : Submodule ğ•œ F\nh : U.IsOrtho V\nâŠ¢ (Submodule.comap f U).IsOrtho (Submodule.comap f V)","decl":"theorem IsOrtho.comap (f : E â†’â‚—áµ¢[ğ•œ] F) {U V : Submodule ğ•œ F} (h : U âŸ‚ V) :\n    U.comap f âŸ‚ V.comap f := by\n  rw [isOrtho_iff_inner_eq] at *\n  simp_rw [mem_comap, â† f.inner_map_map]\n  intro u hu v hv\n  exact h _ hu _ hv\n\n"}
{"name":"Submodule.IsOrtho.map_iff","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace ğ•œ F\nf : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nU V : Submodule ğ•œ E\nâŠ¢ Iff ((Submodule.map f U).IsOrtho (Submodule.map f V)) (U.IsOrtho V)","decl":"@[simp]\ntheorem IsOrtho.map_iff (f : E â‰ƒâ‚—áµ¢[ğ•œ] F) {U V : Submodule ğ•œ E} : U.map f âŸ‚ V.map f â†” U âŸ‚ V :=\n  âŸ¨fun h => by\n    have hf : âˆ€ p : Submodule ğ•œ E, (p.map f).comap f.toLinearIsometry = p :=\n      comap_map_eq_of_injective f.injective\n    simpa only [hf] using h.comap f.toLinearIsometry, IsOrtho.map f.toLinearIsometryâŸ©\n\n"}
{"name":"Submodule.IsOrtho.comap_iff","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace ğ•œ F\nf : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nU V : Submodule ğ•œ F\nâŠ¢ Iff ((Submodule.comap f U).IsOrtho (Submodule.comap f V)) (U.IsOrtho V)","decl":"@[simp]\ntheorem IsOrtho.comap_iff (f : E â‰ƒâ‚—áµ¢[ğ•œ] F) {U V : Submodule ğ•œ F} : U.comap f âŸ‚ V.comap f â†” U âŸ‚ V :=\n  âŸ¨fun h => by\n    have hf : âˆ€ p : Submodule ğ•œ F, (p.comap f).map f.toLinearIsometry = p :=\n      map_comap_eq_of_surjective f.surjective\n    simpa only [hf] using h.map f.toLinearIsometry, IsOrtho.comap f.toLinearIsometryâŸ©\n\n"}
{"name":"orthogonalFamily_iff_pairwise","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nV : Î¹ â†’ Submodule ğ•œ E\nâŠ¢ Iff (OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢) (Pairwise (Function.onFun (fun x1 x2 => x1.IsOrtho x2) V))","decl":"open scoped Function in -- required for scoped `on` notation\ntheorem orthogonalFamily_iff_pairwise {Î¹} {V : Î¹ â†’ Submodule ğ•œ E} :\n    (OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) â†” Pairwise ((Â· âŸ‚ Â·) on V) :=\n  forallâ‚ƒ_congr fun _i _j _hij =>\n    Subtype.forall.trans <|\n      forallâ‚‚_congr fun _x _hx => Subtype.forall.trans <|\n        forallâ‚‚_congr fun _y _hy => inner_eq_zero_symm\n\n"}
{"name":"OrthogonalFamily.of_pairwise","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nV : Î¹ â†’ Submodule ğ•œ E\naâœ : Pairwise (Function.onFun (fun x1 x2 => x1.IsOrtho x2) V)\nâŠ¢ OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢","decl":"alias âŸ¨OrthogonalFamily.pairwise, OrthogonalFamily.of_pairwiseâŸ© := orthogonalFamily_iff_pairwise\n\n"}
{"name":"OrthogonalFamily.pairwise","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nV : Î¹ â†’ Submodule ğ•œ E\naâœ : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢\nâŠ¢ Pairwise (Function.onFun (fun x1 x2 => x1.IsOrtho x2) V)","decl":"alias âŸ¨OrthogonalFamily.pairwise, OrthogonalFamily.of_pairwiseâŸ© := orthogonalFamily_iff_pairwise\n\n"}
{"name":"OrthogonalFamily.isOrtho","module":"Mathlib.Analysis.InnerProductSpace.Orthogonal","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¹ : Type u_4\nV : Î¹ â†’ Submodule ğ•œ E\nhV : OrthogonalFamily ğ•œ (fun i => Subtype fun x => Membership.mem (V i) x) fun i => (V i).subtypeâ‚—áµ¢\ni j : Î¹\nhij : Ne i j\nâŠ¢ (V i).IsOrtho (V j)","decl":"/-- Two submodules in an orthogonal family with different indices are orthogonal. -/\ntheorem OrthogonalFamily.isOrtho {Î¹} {V : Î¹ â†’ Submodule ğ•œ E}\n    (hV : OrthogonalFamily ğ•œ (fun i => V i) fun i => (V i).subtypeâ‚—áµ¢) {i j : Î¹} (hij : i â‰  j) :\n    V i âŸ‚ V j :=\n  hV.pairwise hij\n"}
