{"name":"HasStrictFDerivAt.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₁ : E → F\nf₁' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nf₂ : E → G\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) E G\nhf₁ : HasStrictFDerivAt f₁ f₁' x\nhf₂ : HasStrictFDerivAt f₂ f₂' x\n⊢ HasStrictFDerivAt (fun x => { fst := f₁ x, snd := f₂ x }) (f₁'.prod f₂') x","decl":"protected theorem HasStrictFDerivAt.prod (hf₁ : HasStrictFDerivAt f₁ f₁' x)\n    (hf₂ : HasStrictFDerivAt f₂ f₂' x) :\n    HasStrictFDerivAt (fun x => (f₁ x, f₂ x)) (f₁'.prod f₂') x :=\n  .of_isLittleO <| hf₁.isLittleO.prod_left hf₂.isLittleO\n\n"}
{"name":"HasFDerivAtFilter.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₁ : E → F\nf₁' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nL : Filter E\nf₂ : E → G\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) E G\nhf₁ : HasFDerivAtFilter f₁ f₁' x L\nhf₂ : HasFDerivAtFilter f₂ f₂' x L\n⊢ HasFDerivAtFilter (fun x => { fst := f₁ x, snd := f₂ x }) (f₁'.prod f₂') x L","decl":"theorem HasFDerivAtFilter.prod (hf₁ : HasFDerivAtFilter f₁ f₁' x L)\n    (hf₂ : HasFDerivAtFilter f₂ f₂' x L) :\n    HasFDerivAtFilter (fun x => (f₁ x, f₂ x)) (f₁'.prod f₂') x L :=\n  .of_isLittleO <| hf₁.isLittleO.prod_left hf₂.isLittleO\n\n"}
{"name":"HasFDerivWithinAt.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₁ : E → F\nf₁' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nf₂ : E → G\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) E G\nhf₁ : HasFDerivWithinAt f₁ f₁' s x\nhf₂ : HasFDerivWithinAt f₂ f₂' s x\n⊢ HasFDerivWithinAt (fun x => { fst := f₁ x, snd := f₂ x }) (f₁'.prod f₂') s x","decl":"@[fun_prop]\nnonrec theorem HasFDerivWithinAt.prod (hf₁ : HasFDerivWithinAt f₁ f₁' s x)\n    (hf₂ : HasFDerivWithinAt f₂ f₂' s x) :\n    HasFDerivWithinAt (fun x => (f₁ x, f₂ x)) (f₁'.prod f₂') s x :=\n  hf₁.prod hf₂\n\n"}
{"name":"HasFDerivAt.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₁ : E → F\nf₁' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nf₂ : E → G\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) E G\nhf₁ : HasFDerivAt f₁ f₁' x\nhf₂ : HasFDerivAt f₂ f₂' x\n⊢ HasFDerivAt (fun x => { fst := f₁ x, snd := f₂ x }) (f₁'.prod f₂') x","decl":"@[fun_prop]\nnonrec theorem HasFDerivAt.prod (hf₁ : HasFDerivAt f₁ f₁' x) (hf₂ : HasFDerivAt f₂ f₂' x) :\n    HasFDerivAt (fun x => (f₁ x, f₂ x)) (f₁'.prod f₂') x :=\n  hf₁.prod hf₂\n\n"}
{"name":"hasFDerivAt_prod_mk_left","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ne₀ : E\nf₀ : F\n⊢ HasFDerivAt (fun e => { fst := e, snd := f₀ }) (ContinuousLinearMap.inl 𝕜 E F) e₀","decl":"@[fun_prop]\ntheorem hasFDerivAt_prod_mk_left (e₀ : E) (f₀ : F) :\n    HasFDerivAt (fun e : E => (e, f₀)) (inl 𝕜 E F) e₀ :=\n  (hasFDerivAt_id e₀).prod (hasFDerivAt_const f₀ e₀)\n\n"}
{"name":"hasFDerivAt_prod_mk_right","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ne₀ : E\nf₀ : F\n⊢ HasFDerivAt (fun f => { fst := e₀, snd := f }) (ContinuousLinearMap.inr 𝕜 E F) f₀","decl":"@[fun_prop]\ntheorem hasFDerivAt_prod_mk_right (e₀ : E) (f₀ : F) :\n    HasFDerivAt (fun f : F => (e₀, f)) (inr 𝕜 E F) f₀ :=\n  (hasFDerivAt_const e₀ f₀).prod (hasFDerivAt_id f₀)\n\n"}
{"name":"DifferentiableWithinAt.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₁ : E → F\nx : E\ns : Set E\nf₂ : E → G\nhf₁ : DifferentiableWithinAt 𝕜 f₁ s x\nhf₂ : DifferentiableWithinAt 𝕜 f₂ s x\n⊢ DifferentiableWithinAt 𝕜 (fun x => { fst := f₁ x, snd := f₂ x }) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.prod (hf₁ : DifferentiableWithinAt 𝕜 f₁ s x)\n    (hf₂ : DifferentiableWithinAt 𝕜 f₂ s x) :\n    DifferentiableWithinAt 𝕜 (fun x : E => (f₁ x, f₂ x)) s x :=\n  (hf₁.hasFDerivWithinAt.prod hf₂.hasFDerivWithinAt).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₁ : E → F\nx : E\nf₂ : E → G\nhf₁ : DifferentiableAt 𝕜 f₁ x\nhf₂ : DifferentiableAt 𝕜 f₂ x\n⊢ DifferentiableAt 𝕜 (fun x => { fst := f₁ x, snd := f₂ x }) x","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.prod (hf₁ : DifferentiableAt 𝕜 f₁ x) (hf₂ : DifferentiableAt 𝕜 f₂ x) :\n    DifferentiableAt 𝕜 (fun x : E => (f₁ x, f₂ x)) x :=\n  (hf₁.hasFDerivAt.prod hf₂.hasFDerivAt).differentiableAt\n\n"}
{"name":"DifferentiableOn.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₁ : E → F\ns : Set E\nf₂ : E → G\nhf₁ : DifferentiableOn 𝕜 f₁ s\nhf₂ : DifferentiableOn 𝕜 f₂ s\n⊢ DifferentiableOn 𝕜 (fun x => { fst := f₁ x, snd := f₂ x }) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.prod (hf₁ : DifferentiableOn 𝕜 f₁ s) (hf₂ : DifferentiableOn 𝕜 f₂ s) :\n    DifferentiableOn 𝕜 (fun x : E => (f₁ x, f₂ x)) s := fun x hx =>\n  DifferentiableWithinAt.prod (hf₁ x hx) (hf₂ x hx)\n\n"}
{"name":"Differentiable.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₁ : E → F\nf₂ : E → G\nhf₁ : Differentiable 𝕜 f₁\nhf₂ : Differentiable 𝕜 f₂\n⊢ Differentiable 𝕜 fun x => { fst := f₁ x, snd := f₂ x }","decl":"@[simp, fun_prop]\ntheorem Differentiable.prod (hf₁ : Differentiable 𝕜 f₁) (hf₂ : Differentiable 𝕜 f₂) :\n    Differentiable 𝕜 fun x : E => (f₁ x, f₂ x) := fun x => DifferentiableAt.prod (hf₁ x) (hf₂ x)\n\n"}
{"name":"DifferentiableAt.fderiv_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₁ : E → F\nx : E\nf₂ : E → G\nhf₁ : DifferentiableAt 𝕜 f₁ x\nhf₂ : DifferentiableAt 𝕜 f₂ x\n⊢ Eq (fderiv 𝕜 (fun x => { fst := f₁ x, snd := f₂ x }) x) ((fderiv 𝕜 f₁ x).prod (fderiv 𝕜 f₂ x))","decl":"theorem DifferentiableAt.fderiv_prod (hf₁ : DifferentiableAt 𝕜 f₁ x)\n    (hf₂ : DifferentiableAt 𝕜 f₂ x) :\n    fderiv 𝕜 (fun x : E => (f₁ x, f₂ x)) x = (fderiv 𝕜 f₁ x).prod (fderiv 𝕜 f₂ x) :=\n  (hf₁.hasFDerivAt.prod hf₂.hasFDerivAt).fderiv\n\n"}
{"name":"DifferentiableWithinAt.fderivWithin_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₁ : E → F\nx : E\ns : Set E\nf₂ : E → G\nhf₁ : DifferentiableWithinAt 𝕜 f₁ s x\nhf₂ : DifferentiableWithinAt 𝕜 f₂ s x\nhxs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 (fun x => { fst := f₁ x, snd := f₂ x }) s x) ((fderivWithin 𝕜 f₁ s x).prod (fderivWithin 𝕜 f₂ s x))","decl":"theorem DifferentiableWithinAt.fderivWithin_prod (hf₁ : DifferentiableWithinAt 𝕜 f₁ s x)\n    (hf₂ : DifferentiableWithinAt 𝕜 f₂ s x) (hxs : UniqueDiffWithinAt 𝕜 s x) :\n    fderivWithin 𝕜 (fun x : E => (f₁ x, f₂ x)) s x =\n      (fderivWithin 𝕜 f₁ s x).prod (fderivWithin 𝕜 f₂ s x) :=\n  (hf₁.hasFDerivWithinAt.prod hf₂.hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"hasStrictFDerivAt_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\n⊢ HasStrictFDerivAt Prod.fst (ContinuousLinearMap.fst 𝕜 E F) p","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_fst : HasStrictFDerivAt (@Prod.fst E F) (fst 𝕜 E F) p :=\n  (fst 𝕜 E F).hasStrictFDerivAt\n\n"}
{"name":"HasStrictFDerivAt.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nf₂ : E → Prod F G\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) E (Prod F G)\nh : HasStrictFDerivAt f₂ f₂' x\n⊢ HasStrictFDerivAt (fun x => (f₂ x).1) ((ContinuousLinearMap.fst 𝕜 F G).comp f₂') x","decl":"@[fun_prop]\nprotected theorem HasStrictFDerivAt.fst (h : HasStrictFDerivAt f₂ f₂' x) :\n    HasStrictFDerivAt (fun x => (f₂ x).1) ((fst 𝕜 F G).comp f₂') x :=\n  hasStrictFDerivAt_fst.comp x h\n\n"}
{"name":"hasFDerivAtFilter_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\nL : Filter (Prod E F)\n⊢ HasFDerivAtFilter Prod.fst (ContinuousLinearMap.fst 𝕜 E F) p L","decl":"theorem hasFDerivAtFilter_fst {L : Filter (E × F)} :\n    HasFDerivAtFilter (@Prod.fst E F) (fst 𝕜 E F) p L :=\n  (fst 𝕜 E F).hasFDerivAtFilter\n\n"}
{"name":"HasFDerivAtFilter.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nL : Filter E\nf₂ : E → Prod F G\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) E (Prod F G)\nh : HasFDerivAtFilter f₂ f₂' x L\n⊢ HasFDerivAtFilter (fun x => (f₂ x).1) ((ContinuousLinearMap.fst 𝕜 F G).comp f₂') x L","decl":"protected theorem HasFDerivAtFilter.fst (h : HasFDerivAtFilter f₂ f₂' x L) :\n    HasFDerivAtFilter (fun x => (f₂ x).1) ((fst 𝕜 F G).comp f₂') x L :=\n  hasFDerivAtFilter_fst.comp x h tendsto_map\n\n"}
{"name":"hasFDerivAt_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\n⊢ HasFDerivAt Prod.fst (ContinuousLinearMap.fst 𝕜 E F) p","decl":"@[fun_prop]\ntheorem hasFDerivAt_fst : HasFDerivAt (@Prod.fst E F) (fst 𝕜 E F) p :=\n  hasFDerivAtFilter_fst\n\n"}
{"name":"HasFDerivAt.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nf₂ : E → Prod F G\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) E (Prod F G)\nh : HasFDerivAt f₂ f₂' x\n⊢ HasFDerivAt (fun x => (f₂ x).1) ((ContinuousLinearMap.fst 𝕜 F G).comp f₂') x","decl":"@[fun_prop]\nprotected nonrec theorem HasFDerivAt.fst (h : HasFDerivAt f₂ f₂' x) :\n    HasFDerivAt (fun x => (f₂ x).1) ((fst 𝕜 F G).comp f₂') x :=\n  h.fst\n\n"}
{"name":"hasFDerivWithinAt_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\ns : Set (Prod E F)\n⊢ HasFDerivWithinAt Prod.fst (ContinuousLinearMap.fst 𝕜 E F) s p","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_fst {s : Set (E × F)} :\n    HasFDerivWithinAt (@Prod.fst E F) (fst 𝕜 E F) s p :=\n  hasFDerivAtFilter_fst\n\n"}
{"name":"HasFDerivWithinAt.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\ns : Set E\nf₂ : E → Prod F G\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) E (Prod F G)\nh : HasFDerivWithinAt f₂ f₂' s x\n⊢ HasFDerivWithinAt (fun x => (f₂ x).1) ((ContinuousLinearMap.fst 𝕜 F G).comp f₂') s x","decl":"@[fun_prop]\nprotected nonrec theorem HasFDerivWithinAt.fst (h : HasFDerivWithinAt f₂ f₂' s x) :\n    HasFDerivWithinAt (fun x => (f₂ x).1) ((fst 𝕜 F G).comp f₂') s x :=\n  h.fst\n\n"}
{"name":"differentiableAt_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\n⊢ DifferentiableAt 𝕜 Prod.fst p","decl":"@[fun_prop]\ntheorem differentiableAt_fst : DifferentiableAt 𝕜 Prod.fst p :=\n  hasFDerivAt_fst.differentiableAt\n\n"}
{"name":"DifferentiableAt.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nf₂ : E → Prod F G\nh : DifferentiableAt 𝕜 f₂ x\n⊢ DifferentiableAt 𝕜 (fun x => (f₂ x).1) x","decl":"@[simp, fun_prop]\nprotected theorem DifferentiableAt.fst (h : DifferentiableAt 𝕜 f₂ x) :\n    DifferentiableAt 𝕜 (fun x => (f₂ x).1) x :=\n  differentiableAt_fst.comp x h\n\n"}
{"name":"differentiable_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\n⊢ Differentiable 𝕜 Prod.fst","decl":"@[fun_prop]\ntheorem differentiable_fst : Differentiable 𝕜 (Prod.fst : E × F → E) := fun _ =>\n  differentiableAt_fst\n\n"}
{"name":"Differentiable.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₂ : E → Prod F G\nh : Differentiable 𝕜 f₂\n⊢ Differentiable 𝕜 fun x => (f₂ x).1","decl":"@[simp, fun_prop]\nprotected theorem Differentiable.fst (h : Differentiable 𝕜 f₂) :\n    Differentiable 𝕜 fun x => (f₂ x).1 :=\n  differentiable_fst.comp h\n\n"}
{"name":"differentiableWithinAt_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\ns : Set (Prod E F)\n⊢ DifferentiableWithinAt 𝕜 Prod.fst s p","decl":"@[fun_prop]\ntheorem differentiableWithinAt_fst {s : Set (E × F)} : DifferentiableWithinAt 𝕜 Prod.fst s p :=\n  differentiableAt_fst.differentiableWithinAt\n\n"}
{"name":"DifferentiableWithinAt.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\ns : Set E\nf₂ : E → Prod F G\nh : DifferentiableWithinAt 𝕜 f₂ s x\n⊢ DifferentiableWithinAt 𝕜 (fun x => (f₂ x).1) s x","decl":"@[fun_prop]\nprotected theorem DifferentiableWithinAt.fst (h : DifferentiableWithinAt 𝕜 f₂ s x) :\n    DifferentiableWithinAt 𝕜 (fun x => (f₂ x).1) s x :=\n  differentiableAt_fst.comp_differentiableWithinAt x h\n\n"}
{"name":"differentiableOn_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set (Prod E F)\n⊢ DifferentiableOn 𝕜 Prod.fst s","decl":"@[fun_prop]\ntheorem differentiableOn_fst {s : Set (E × F)} : DifferentiableOn 𝕜 Prod.fst s :=\n  differentiable_fst.differentiableOn\n\n"}
{"name":"DifferentiableOn.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf₂ : E → Prod F G\nh : DifferentiableOn 𝕜 f₂ s\n⊢ DifferentiableOn 𝕜 (fun x => (f₂ x).1) s","decl":"@[fun_prop]\nprotected theorem DifferentiableOn.fst (h : DifferentiableOn 𝕜 f₂ s) :\n    DifferentiableOn 𝕜 (fun x => (f₂ x).1) s :=\n  differentiable_fst.comp_differentiableOn h\n\n"}
{"name":"fderiv_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\n⊢ Eq (fderiv 𝕜 Prod.fst p) (ContinuousLinearMap.fst 𝕜 E F)","decl":"theorem fderiv_fst : fderiv 𝕜 Prod.fst p = fst 𝕜 E F :=\n  hasFDerivAt_fst.fderiv\n\n"}
{"name":"fderiv.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nf₂ : E → Prod F G\nh : DifferentiableAt 𝕜 f₂ x\n⊢ Eq (fderiv 𝕜 (fun x => (f₂ x).1) x) ((ContinuousLinearMap.fst 𝕜 F G).comp (fderiv 𝕜 f₂ x))","decl":"theorem fderiv.fst (h : DifferentiableAt 𝕜 f₂ x) :\n    fderiv 𝕜 (fun x => (f₂ x).1) x = (fst 𝕜 F G).comp (fderiv 𝕜 f₂ x) :=\n  h.hasFDerivAt.fst.fderiv\n\n"}
{"name":"fderivWithin_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\ns : Set (Prod E F)\nhs : UniqueDiffWithinAt 𝕜 s p\n⊢ Eq (fderivWithin 𝕜 Prod.fst s p) (ContinuousLinearMap.fst 𝕜 E F)","decl":"theorem fderivWithin_fst {s : Set (E × F)} (hs : UniqueDiffWithinAt 𝕜 s p) :\n    fderivWithin 𝕜 Prod.fst s p = fst 𝕜 E F :=\n  hasFDerivWithinAt_fst.fderivWithin hs\n\n"}
{"name":"fderivWithin.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\ns : Set E\nf₂ : E → Prod F G\nhs : UniqueDiffWithinAt 𝕜 s x\nh : DifferentiableWithinAt 𝕜 f₂ s x\n⊢ Eq (fderivWithin 𝕜 (fun x => (f₂ x).1) s x) ((ContinuousLinearMap.fst 𝕜 F G).comp (fderivWithin 𝕜 f₂ s x))","decl":"theorem fderivWithin.fst (hs : UniqueDiffWithinAt 𝕜 s x) (h : DifferentiableWithinAt 𝕜 f₂ s x) :\n    fderivWithin 𝕜 (fun x => (f₂ x).1) s x = (fst 𝕜 F G).comp (fderivWithin 𝕜 f₂ s x) :=\n  h.hasFDerivWithinAt.fst.fderivWithin hs\n\n"}
{"name":"hasStrictFDerivAt_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\n⊢ HasStrictFDerivAt Prod.snd (ContinuousLinearMap.snd 𝕜 E F) p","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_snd : HasStrictFDerivAt (@Prod.snd E F) (snd 𝕜 E F) p :=\n  (snd 𝕜 E F).hasStrictFDerivAt\n\n"}
{"name":"HasStrictFDerivAt.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nf₂ : E → Prod F G\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) E (Prod F G)\nh : HasStrictFDerivAt f₂ f₂' x\n⊢ HasStrictFDerivAt (fun x => (f₂ x).2) ((ContinuousLinearMap.snd 𝕜 F G).comp f₂') x","decl":"@[fun_prop]\nprotected theorem HasStrictFDerivAt.snd (h : HasStrictFDerivAt f₂ f₂' x) :\n    HasStrictFDerivAt (fun x => (f₂ x).2) ((snd 𝕜 F G).comp f₂') x :=\n  hasStrictFDerivAt_snd.comp x h\n\n"}
{"name":"hasFDerivAtFilter_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\nL : Filter (Prod E F)\n⊢ HasFDerivAtFilter Prod.snd (ContinuousLinearMap.snd 𝕜 E F) p L","decl":"theorem hasFDerivAtFilter_snd {L : Filter (E × F)} :\n    HasFDerivAtFilter (@Prod.snd E F) (snd 𝕜 E F) p L :=\n  (snd 𝕜 E F).hasFDerivAtFilter\n\n"}
{"name":"HasFDerivAtFilter.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nL : Filter E\nf₂ : E → Prod F G\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) E (Prod F G)\nh : HasFDerivAtFilter f₂ f₂' x L\n⊢ HasFDerivAtFilter (fun x => (f₂ x).2) ((ContinuousLinearMap.snd 𝕜 F G).comp f₂') x L","decl":"protected theorem HasFDerivAtFilter.snd (h : HasFDerivAtFilter f₂ f₂' x L) :\n    HasFDerivAtFilter (fun x => (f₂ x).2) ((snd 𝕜 F G).comp f₂') x L :=\n  hasFDerivAtFilter_snd.comp x h tendsto_map\n\n"}
{"name":"hasFDerivAt_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\n⊢ HasFDerivAt Prod.snd (ContinuousLinearMap.snd 𝕜 E F) p","decl":"@[fun_prop]\ntheorem hasFDerivAt_snd : HasFDerivAt (@Prod.snd E F) (snd 𝕜 E F) p :=\n  hasFDerivAtFilter_snd\n\n"}
{"name":"HasFDerivAt.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nf₂ : E → Prod F G\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) E (Prod F G)\nh : HasFDerivAt f₂ f₂' x\n⊢ HasFDerivAt (fun x => (f₂ x).2) ((ContinuousLinearMap.snd 𝕜 F G).comp f₂') x","decl":"@[fun_prop]\nprotected nonrec theorem HasFDerivAt.snd (h : HasFDerivAt f₂ f₂' x) :\n    HasFDerivAt (fun x => (f₂ x).2) ((snd 𝕜 F G).comp f₂') x :=\n  h.snd\n\n"}
{"name":"hasFDerivWithinAt_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\ns : Set (Prod E F)\n⊢ HasFDerivWithinAt Prod.snd (ContinuousLinearMap.snd 𝕜 E F) s p","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_snd {s : Set (E × F)} :\n    HasFDerivWithinAt (@Prod.snd E F) (snd 𝕜 E F) s p :=\n  hasFDerivAtFilter_snd\n\n"}
{"name":"HasFDerivWithinAt.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\ns : Set E\nf₂ : E → Prod F G\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) E (Prod F G)\nh : HasFDerivWithinAt f₂ f₂' s x\n⊢ HasFDerivWithinAt (fun x => (f₂ x).2) ((ContinuousLinearMap.snd 𝕜 F G).comp f₂') s x","decl":"@[fun_prop]\nprotected nonrec theorem HasFDerivWithinAt.snd (h : HasFDerivWithinAt f₂ f₂' s x) :\n    HasFDerivWithinAt (fun x => (f₂ x).2) ((snd 𝕜 F G).comp f₂') s x :=\n  h.snd\n\n"}
{"name":"differentiableAt_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\n⊢ DifferentiableAt 𝕜 Prod.snd p","decl":"@[fun_prop]\ntheorem differentiableAt_snd : DifferentiableAt 𝕜 Prod.snd p :=\n  hasFDerivAt_snd.differentiableAt\n\n"}
{"name":"DifferentiableAt.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nf₂ : E → Prod F G\nh : DifferentiableAt 𝕜 f₂ x\n⊢ DifferentiableAt 𝕜 (fun x => (f₂ x).2) x","decl":"@[simp, fun_prop]\nprotected theorem DifferentiableAt.snd (h : DifferentiableAt 𝕜 f₂ x) :\n    DifferentiableAt 𝕜 (fun x => (f₂ x).2) x :=\n  differentiableAt_snd.comp x h\n\n"}
{"name":"differentiable_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\n⊢ Differentiable 𝕜 Prod.snd","decl":"@[fun_prop]\ntheorem differentiable_snd : Differentiable 𝕜 (Prod.snd : E × F → F) := fun _ =>\n  differentiableAt_snd\n\n"}
{"name":"Differentiable.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₂ : E → Prod F G\nh : Differentiable 𝕜 f₂\n⊢ Differentiable 𝕜 fun x => (f₂ x).2","decl":"@[simp, fun_prop]\nprotected theorem Differentiable.snd (h : Differentiable 𝕜 f₂) :\n    Differentiable 𝕜 fun x => (f₂ x).2 :=\n  differentiable_snd.comp h\n\n"}
{"name":"differentiableWithinAt_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\ns : Set (Prod E F)\n⊢ DifferentiableWithinAt 𝕜 Prod.snd s p","decl":"@[fun_prop]\ntheorem differentiableWithinAt_snd {s : Set (E × F)} : DifferentiableWithinAt 𝕜 Prod.snd s p :=\n  differentiableAt_snd.differentiableWithinAt\n\n"}
{"name":"DifferentiableWithinAt.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\ns : Set E\nf₂ : E → Prod F G\nh : DifferentiableWithinAt 𝕜 f₂ s x\n⊢ DifferentiableWithinAt 𝕜 (fun x => (f₂ x).2) s x","decl":"@[fun_prop]\nprotected theorem DifferentiableWithinAt.snd (h : DifferentiableWithinAt 𝕜 f₂ s x) :\n    DifferentiableWithinAt 𝕜 (fun x => (f₂ x).2) s x :=\n  differentiableAt_snd.comp_differentiableWithinAt x h\n\n"}
{"name":"differentiableOn_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set (Prod E F)\n⊢ DifferentiableOn 𝕜 Prod.snd s","decl":"@[fun_prop]\ntheorem differentiableOn_snd {s : Set (E × F)} : DifferentiableOn 𝕜 Prod.snd s :=\n  differentiable_snd.differentiableOn\n\n"}
{"name":"DifferentiableOn.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf₂ : E → Prod F G\nh : DifferentiableOn 𝕜 f₂ s\n⊢ DifferentiableOn 𝕜 (fun x => (f₂ x).2) s","decl":"@[fun_prop]\nprotected theorem DifferentiableOn.snd (h : DifferentiableOn 𝕜 f₂ s) :\n    DifferentiableOn 𝕜 (fun x => (f₂ x).2) s :=\n  differentiable_snd.comp_differentiableOn h\n\n"}
{"name":"fderiv_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\n⊢ Eq (fderiv 𝕜 Prod.snd p) (ContinuousLinearMap.snd 𝕜 E F)","decl":"theorem fderiv_snd : fderiv 𝕜 Prod.snd p = snd 𝕜 E F :=\n  hasFDerivAt_snd.fderiv\n\n"}
{"name":"fderiv.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nf₂ : E → Prod F G\nh : DifferentiableAt 𝕜 f₂ x\n⊢ Eq (fderiv 𝕜 (fun x => (f₂ x).2) x) ((ContinuousLinearMap.snd 𝕜 F G).comp (fderiv 𝕜 f₂ x))","decl":"theorem fderiv.snd (h : DifferentiableAt 𝕜 f₂ x) :\n    fderiv 𝕜 (fun x => (f₂ x).2) x = (snd 𝕜 F G).comp (fderiv 𝕜 f₂ x) :=\n  h.hasFDerivAt.snd.fderiv\n\n"}
{"name":"fderivWithin_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : Prod E F\ns : Set (Prod E F)\nhs : UniqueDiffWithinAt 𝕜 s p\n⊢ Eq (fderivWithin 𝕜 Prod.snd s p) (ContinuousLinearMap.snd 𝕜 E F)","decl":"theorem fderivWithin_snd {s : Set (E × F)} (hs : UniqueDiffWithinAt 𝕜 s p) :\n    fderivWithin 𝕜 Prod.snd s p = snd 𝕜 E F :=\n  hasFDerivWithinAt_snd.fderivWithin hs\n\n"}
{"name":"fderivWithin.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\ns : Set E\nf₂ : E → Prod F G\nhs : UniqueDiffWithinAt 𝕜 s x\nh : DifferentiableWithinAt 𝕜 f₂ s x\n⊢ Eq (fderivWithin 𝕜 (fun x => (f₂ x).2) s x) ((ContinuousLinearMap.snd 𝕜 F G).comp (fderivWithin 𝕜 f₂ s x))","decl":"theorem fderivWithin.snd (hs : UniqueDiffWithinAt 𝕜 s x) (h : DifferentiableWithinAt 𝕜 f₂ s x) :\n    fderivWithin 𝕜 (fun x => (f₂ x).2) s x = (snd 𝕜 F G).comp (fderivWithin 𝕜 f₂ s x) :=\n  h.hasFDerivWithinAt.snd.fderivWithin hs\n\n"}
{"name":"HasStrictFDerivAt.prodMap","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nG' : Type u_5\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nf₂ : G → G'\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) G G'\np : Prod E G\nhf : HasStrictFDerivAt f f' p.1\nhf₂ : HasStrictFDerivAt f₂ f₂' p.2\n⊢ HasStrictFDerivAt (Prod.map f f₂) (f'.prodMap f₂') p","decl":"@[fun_prop]\nprotected theorem HasStrictFDerivAt.prodMap (hf : HasStrictFDerivAt f f' p.1)\n    (hf₂ : HasStrictFDerivAt f₂ f₂' p.2) : HasStrictFDerivAt (Prod.map f f₂) (f'.prodMap f₂') p :=\n  (hf.comp p hasStrictFDerivAt_fst).prod (hf₂.comp p hasStrictFDerivAt_snd)\n\n"}
{"name":"HasFDerivAt.prodMap","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nG' : Type u_5\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nf₂ : G → G'\nf₂' : ContinuousLinearMap (RingHom.id 𝕜) G G'\np : Prod E G\nhf : HasFDerivAt f f' p.1\nhf₂ : HasFDerivAt f₂ f₂' p.2\n⊢ HasFDerivAt (Prod.map f f₂) (f'.prodMap f₂') p","decl":"@[fun_prop]\nprotected theorem HasFDerivAt.prodMap (hf : HasFDerivAt f f' p.1) (hf₂ : HasFDerivAt f₂ f₂' p.2) :\n    HasFDerivAt (Prod.map f f₂) (f'.prodMap f₂') p :=\n  (hf.comp p hasFDerivAt_fst).prod (hf₂.comp p hasFDerivAt_snd)\n\n"}
{"name":"DifferentiableAt.prod_map","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nG' : Type u_5\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : E → F\nf₂ : G → G'\np : Prod E G\nhf : DifferentiableAt 𝕜 f p.1\nhf₂ : DifferentiableAt 𝕜 f₂ p.2\n⊢ DifferentiableAt 𝕜 (fun p => { fst := f p.1, snd := f₂ p.2 }) p","decl":"@[simp, fun_prop]\nprotected theorem DifferentiableAt.prod_map (hf : DifferentiableAt 𝕜 f p.1)\n    (hf₂ : DifferentiableAt 𝕜 f₂ p.2) : DifferentiableAt 𝕜 (fun p : E × G => (f p.1, f₂ p.2)) p :=\n  (hf.comp p differentiableAt_fst).prod (hf₂.comp p differentiableAt_snd)\n\n"}
{"name":"hasStrictFDerivAt_pi'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\nΦ' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : ι) → F' i)\n⊢ Iff (HasStrictFDerivAt Φ Φ' x) (∀ (i : ι), HasStrictFDerivAt (fun x => Φ x i) ((ContinuousLinearMap.proj i).comp Φ') x)","decl":"@[simp]\ntheorem hasStrictFDerivAt_pi' :\n    HasStrictFDerivAt Φ Φ' x ↔ ∀ i, HasStrictFDerivAt (fun x => Φ x i) ((proj i).comp Φ') x := by\n  simp only [hasStrictFDerivAt_iff_isLittleO, ContinuousLinearMap.coe_pi]\n  exact isLittleO_pi\n\n"}
{"name":"hasStrictFDerivAt_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\nΦ' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : ι) → F' i)\nhφ : ∀ (i : ι), HasStrictFDerivAt (fun x => Φ x i) ((ContinuousLinearMap.proj i).comp Φ') x\n⊢ HasStrictFDerivAt Φ Φ' x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_pi'' (hφ : ∀ i, HasStrictFDerivAt (fun x => Φ x i) ((proj i).comp Φ') x) :\n    HasStrictFDerivAt Φ Φ' x := hasStrictFDerivAt_pi'.2 hφ\n\n"}
{"name":"hasStrictFDerivAt_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\ni : ι\nf : (i : ι) → F' i\n⊢ HasStrictFDerivAt (fun f => f i) (ContinuousLinearMap.proj i) f","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_apply (i : ι) (f : ∀ i, F' i) :\n    HasStrictFDerivAt (𝕜 := 𝕜) (fun f : ∀ i, F' i => f i) (proj i) f := by\n  let id' := ContinuousLinearMap.id 𝕜 (∀ i, F' i)\n  have h := ((hasStrictFDerivAt_pi'\n             (Φ := fun (f : ∀ i, F' i) (i' : ι) => f i') (Φ' := id') (x := f))).1\n  have h' : comp (proj i) id' = proj i := by ext; simp [id']\n  rw [← h']; apply h; apply hasStrictFDerivAt_id\n\n"}
{"name":"hasStrictFDerivAt_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nφ : (i : ι) → E → F' i\nφ' : (i : ι) → ContinuousLinearMap (RingHom.id 𝕜) E (F' i)\n⊢ Iff (HasStrictFDerivAt (fun x i => φ i x) (ContinuousLinearMap.pi φ') x) (∀ (i : ι), HasStrictFDerivAt (φ i) (φ' i) x)","decl":"@[simp 1100] -- Porting note: increased priority to make lint happy\ntheorem hasStrictFDerivAt_pi :\n    HasStrictFDerivAt (fun x i => φ i x) (ContinuousLinearMap.pi φ') x ↔\n      ∀ i, HasStrictFDerivAt (φ i) (φ' i) x :=\n  hasStrictFDerivAt_pi'\n\n"}
{"name":"hasFDerivAtFilter_pi'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\nL : Filter E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\nΦ' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : ι) → F' i)\n⊢ Iff (HasFDerivAtFilter Φ Φ' x L) (∀ (i : ι), HasFDerivAtFilter (fun x => Φ x i) ((ContinuousLinearMap.proj i).comp Φ') x L)","decl":"@[simp]\ntheorem hasFDerivAtFilter_pi' :\n    HasFDerivAtFilter Φ Φ' x L ↔\n      ∀ i, HasFDerivAtFilter (fun x => Φ x i) ((proj i).comp Φ') x L := by\n  simp only [hasFDerivAtFilter_iff_isLittleO, ContinuousLinearMap.coe_pi]\n  exact isLittleO_pi\n\n"}
{"name":"hasFDerivAtFilter_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\nL : Filter E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nφ : (i : ι) → E → F' i\nφ' : (i : ι) → ContinuousLinearMap (RingHom.id 𝕜) E (F' i)\n⊢ Iff (HasFDerivAtFilter (fun x i => φ i x) (ContinuousLinearMap.pi φ') x L) (∀ (i : ι), HasFDerivAtFilter (φ i) (φ' i) x L)","decl":"theorem hasFDerivAtFilter_pi :\n    HasFDerivAtFilter (fun x i => φ i x) (ContinuousLinearMap.pi φ') x L ↔\n      ∀ i, HasFDerivAtFilter (φ i) (φ' i) x L :=\n  hasFDerivAtFilter_pi'\n\n"}
{"name":"hasFDerivAt_pi'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\nΦ' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : ι) → F' i)\n⊢ Iff (HasFDerivAt Φ Φ' x) (∀ (i : ι), HasFDerivAt (fun x => Φ x i) ((ContinuousLinearMap.proj i).comp Φ') x)","decl":"@[simp]\ntheorem hasFDerivAt_pi' :\n    HasFDerivAt Φ Φ' x ↔ ∀ i, HasFDerivAt (fun x => Φ x i) ((proj i).comp Φ') x :=\n  hasFDerivAtFilter_pi'\n\n"}
{"name":"hasFDerivAt_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\nΦ' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : ι) → F' i)\nhφ : ∀ (i : ι), HasFDerivAt (fun x => Φ x i) ((ContinuousLinearMap.proj i).comp Φ') x\n⊢ HasFDerivAt Φ Φ' x","decl":"@[fun_prop]\ntheorem hasFDerivAt_pi'' (hφ : ∀ i, HasFDerivAt (fun x => Φ x i) ((proj i).comp Φ') x) :\n    HasFDerivAt Φ Φ' x := hasFDerivAt_pi'.2 hφ\n\n"}
{"name":"hasFDerivAt_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\ni : ι\nf : (i : ι) → F' i\n⊢ HasFDerivAt (fun f => f i) (ContinuousLinearMap.proj i) f","decl":"@[fun_prop]\ntheorem hasFDerivAt_apply (i : ι) (f : ∀ i, F' i) :\n    HasFDerivAt (𝕜 := 𝕜) (fun f : ∀ i, F' i => f i) (proj i) f := by\n  apply HasStrictFDerivAt.hasFDerivAt\n  apply hasStrictFDerivAt_apply\n\n"}
{"name":"hasFDerivAt_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nφ : (i : ι) → E → F' i\nφ' : (i : ι) → ContinuousLinearMap (RingHom.id 𝕜) E (F' i)\n⊢ Iff (HasFDerivAt (fun x i => φ i x) (ContinuousLinearMap.pi φ') x) (∀ (i : ι), HasFDerivAt (φ i) (φ' i) x)","decl":"theorem hasFDerivAt_pi :\n    HasFDerivAt (fun x i => φ i x) (ContinuousLinearMap.pi φ') x ↔\n      ∀ i, HasFDerivAt (φ i) (φ' i) x :=\n  hasFDerivAtFilter_pi\n\n"}
{"name":"hasFDerivWithinAt_pi'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\ns : Set E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\nΦ' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : ι) → F' i)\n⊢ Iff (HasFDerivWithinAt Φ Φ' s x) (∀ (i : ι), HasFDerivWithinAt (fun x => Φ x i) ((ContinuousLinearMap.proj i).comp Φ') s x)","decl":"@[simp]\ntheorem hasFDerivWithinAt_pi' :\n    HasFDerivWithinAt Φ Φ' s x ↔ ∀ i, HasFDerivWithinAt (fun x => Φ x i) ((proj i).comp Φ') s x :=\n  hasFDerivAtFilter_pi'\n\n"}
{"name":"hasFDerivWithinAt_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\ns : Set E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\nΦ' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : ι) → F' i)\nhφ : ∀ (i : ι), HasFDerivWithinAt (fun x => Φ x i) ((ContinuousLinearMap.proj i).comp Φ') s x\n⊢ HasFDerivWithinAt Φ Φ' s x","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_pi''\n    (hφ : ∀ i, HasFDerivWithinAt (fun x => Φ x i) ((proj i).comp Φ') s x) :\n    HasFDerivWithinAt Φ Φ' s x := hasFDerivWithinAt_pi'.2 hφ\n\n"}
{"name":"hasFDerivWithinAt_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\ni : ι\nf : (i : ι) → F' i\ns' : Set ((i : ι) → F' i)\n⊢ HasFDerivWithinAt (fun f => f i) (ContinuousLinearMap.proj i) s' f","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_apply (i : ι) (f : ∀ i, F' i) (s' : Set (∀ i, F' i)) :\n    HasFDerivWithinAt (𝕜 := 𝕜) (fun f : ∀ i, F' i => f i) (proj i) s' f := by\n  let id' := ContinuousLinearMap.id 𝕜 (∀ i, F' i)\n  have h := ((hasFDerivWithinAt_pi'\n             (Φ := fun (f : ∀ i, F' i) (i' : ι) => f i') (Φ' := id') (x := f) (s := s'))).1\n  have h' : comp (proj i) id' = proj i := by rfl\n  rw [← h']; apply h; apply hasFDerivWithinAt_id\n\n"}
{"name":"hasFDerivWithinAt_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\ns : Set E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nφ : (i : ι) → E → F' i\nφ' : (i : ι) → ContinuousLinearMap (RingHom.id 𝕜) E (F' i)\n⊢ Iff (HasFDerivWithinAt (fun x i => φ i x) (ContinuousLinearMap.pi φ') s x) (∀ (i : ι), HasFDerivWithinAt (φ i) (φ' i) s x)","decl":"theorem hasFDerivWithinAt_pi :\n    HasFDerivWithinAt (fun x i => φ i x) (ContinuousLinearMap.pi φ') s x ↔\n      ∀ i, HasFDerivWithinAt (φ i) (φ' i) s x :=\n  hasFDerivAtFilter_pi\n\n"}
{"name":"differentiableWithinAt_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\ns : Set E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\n⊢ Iff (DifferentiableWithinAt 𝕜 Φ s x) (∀ (i : ι), DifferentiableWithinAt 𝕜 (fun x => Φ x i) s x)","decl":"@[simp]\ntheorem differentiableWithinAt_pi :\n    DifferentiableWithinAt 𝕜 Φ s x ↔ ∀ i, DifferentiableWithinAt 𝕜 (fun x => Φ x i) s x :=\n  ⟨fun h i => (hasFDerivWithinAt_pi'.1 h.hasFDerivWithinAt i).differentiableWithinAt, fun h =>\n    (hasFDerivWithinAt_pi.2 fun i => (h i).hasFDerivWithinAt).differentiableWithinAt⟩\n\n"}
{"name":"differentiableWithinAt_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\ns : Set E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\nhφ : ∀ (i : ι), DifferentiableWithinAt 𝕜 (fun x => Φ x i) s x\n⊢ DifferentiableWithinAt 𝕜 Φ s x","decl":"@[fun_prop]\ntheorem differentiableWithinAt_pi'' (hφ : ∀ i, DifferentiableWithinAt 𝕜 (fun x => Φ x i) s x) :\n    DifferentiableWithinAt 𝕜 Φ s x := differentiableWithinAt_pi.2 hφ\n\n"}
{"name":"differentiableWithinAt_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\ni : ι\nf : (i : ι) → F' i\ns' : Set ((i : ι) → F' i)\n⊢ DifferentiableWithinAt 𝕜 (fun f => f i) s' f","decl":"@[fun_prop]\ntheorem differentiableWithinAt_apply (i : ι) (f : ∀ i, F' i) (s' : Set (∀ i, F' i)) :\n    DifferentiableWithinAt (𝕜 := 𝕜) (fun f : ∀ i, F' i => f i) s' f := by\n  apply HasFDerivWithinAt.differentiableWithinAt\n  fun_prop\n\n"}
{"name":"differentiableAt_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\n⊢ Iff (DifferentiableAt 𝕜 Φ x) (∀ (i : ι), DifferentiableAt 𝕜 (fun x => Φ x i) x)","decl":"@[simp]\ntheorem differentiableAt_pi : DifferentiableAt 𝕜 Φ x ↔ ∀ i, DifferentiableAt 𝕜 (fun x => Φ x i) x :=\n  ⟨fun h i => (hasFDerivAt_pi'.1 h.hasFDerivAt i).differentiableAt, fun h =>\n    (hasFDerivAt_pi.2 fun i => (h i).hasFDerivAt).differentiableAt⟩\n\n"}
{"name":"differentiableAt_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\nhφ : ∀ (i : ι), DifferentiableAt 𝕜 (fun x => Φ x i) x\n⊢ DifferentiableAt 𝕜 Φ x","decl":"@[fun_prop]\ntheorem differentiableAt_pi'' (hφ : ∀ i, DifferentiableAt 𝕜 (fun x => Φ x i) x) :\n    DifferentiableAt 𝕜 Φ x := differentiableAt_pi.2 hφ\n\n"}
{"name":"differentiableAt_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\ni : ι\nf : (i : ι) → F' i\n⊢ DifferentiableAt 𝕜 (fun f => f i) f","decl":"@[fun_prop]\ntheorem differentiableAt_apply (i : ι) (f : ∀ i, F' i) :\n    DifferentiableAt (𝕜 := 𝕜) (fun f : ∀ i, F' i => f i) f := by\n  have h := ((differentiableAt_pi (𝕜 := 𝕜)\n             (Φ := fun (f : ∀ i, F' i) (i' : ι) => f i') (x := f))).1\n  apply h; apply differentiableAt_id\n\n"}
{"name":"differentiableOn_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ns : Set E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\n⊢ Iff (DifferentiableOn 𝕜 Φ s) (∀ (i : ι), DifferentiableOn 𝕜 (fun x => Φ x i) s)","decl":"theorem differentiableOn_pi : DifferentiableOn 𝕜 Φ s ↔ ∀ i, DifferentiableOn 𝕜 (fun x => Φ x i) s :=\n  ⟨fun h i x hx => differentiableWithinAt_pi.1 (h x hx) i, fun h x hx =>\n    differentiableWithinAt_pi.2 fun i => h i x hx⟩\n\n"}
{"name":"differentiableOn_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ns : Set E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\nhφ : ∀ (i : ι), DifferentiableOn 𝕜 (fun x => Φ x i) s\n⊢ DifferentiableOn 𝕜 Φ s","decl":"@[fun_prop]\ntheorem differentiableOn_pi'' (hφ : ∀ i, DifferentiableOn 𝕜 (fun x => Φ x i) s) :\n    DifferentiableOn 𝕜 Φ s := differentiableOn_pi.2 hφ\n\n"}
{"name":"differentiableOn_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\ni : ι\ns' : Set ((i : ι) → F' i)\n⊢ DifferentiableOn 𝕜 (fun f => f i) s'","decl":"@[fun_prop]\ntheorem differentiableOn_apply (i : ι) (s' : Set (∀ i, F' i)) :\n    DifferentiableOn (𝕜 := 𝕜) (fun f : ∀ i, F' i => f i) s' := by\n  have h := ((differentiableOn_pi (𝕜 := 𝕜)\n             (Φ := fun (f : ∀ i, F' i) (i' : ι) => f i') (s := s'))).1\n  apply h; apply differentiableOn_id\n\n"}
{"name":"differentiable_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\n⊢ Iff (Differentiable 𝕜 Φ) (∀ (i : ι), Differentiable 𝕜 fun x => Φ x i)","decl":"theorem differentiable_pi : Differentiable 𝕜 Φ ↔ ∀ i, Differentiable 𝕜 fun x => Φ x i :=\n  ⟨fun h i x => differentiableAt_pi.1 (h x) i, fun h x => differentiableAt_pi.2 fun i => h i x⟩\n\n"}
{"name":"differentiable_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\nhφ : ∀ (i : ι), Differentiable 𝕜 fun x => Φ x i\n⊢ Differentiable 𝕜 Φ","decl":"@[fun_prop]\ntheorem differentiable_pi'' (hφ : ∀ i, Differentiable 𝕜 fun x => Φ x i) :\n    Differentiable 𝕜 Φ := differentiable_pi.2 hφ\n\n"}
{"name":"differentiable_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\ni : ι\n⊢ Differentiable 𝕜 fun f => f i","decl":"@[fun_prop]\ntheorem differentiable_apply (i : ι) :\n    Differentiable (𝕜 := 𝕜) (fun f : ∀ i, F' i => f i) := by intro x; apply differentiableAt_apply\n\n-- TODO: find out which version (`φ` or `Φ`) works better with `rw`/`simp`\n"}
{"name":"fderivWithin_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\ns : Set E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nφ : (i : ι) → E → F' i\nh : ∀ (i : ι), DifferentiableWithinAt 𝕜 (φ i) s x\nhs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 (fun x i => φ i x) s x) (ContinuousLinearMap.pi fun i => fderivWithin 𝕜 (φ i) s x)","decl":"theorem fderivWithin_pi (h : ∀ i, DifferentiableWithinAt 𝕜 (φ i) s x)\n    (hs : UniqueDiffWithinAt 𝕜 s x) :\n    fderivWithin 𝕜 (fun x i => φ i x) s x = pi fun i => fderivWithin 𝕜 (φ i) s x :=\n  (hasFDerivWithinAt_pi.2 fun i => (h i).hasFDerivWithinAt).fderivWithin hs\n\n"}
{"name":"fderiv_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\nι : Type u_6\ninst✝² : Fintype ι\nF' : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nφ : (i : ι) → E → F' i\nh : ∀ (i : ι), DifferentiableAt 𝕜 (φ i) x\n⊢ Eq (fderiv 𝕜 (fun x i => φ i x) x) (ContinuousLinearMap.pi fun i => fderiv 𝕜 (φ i) x)","decl":"theorem fderiv_pi (h : ∀ i, DifferentiableAt 𝕜 (φ i) x) :\n    fderiv 𝕜 (fun x i => φ i x) x = pi fun i => fderiv 𝕜 (φ i) x :=\n  (hasFDerivAt_pi.2 fun i => (h i).hasFDerivAt).fderiv\n\n"}
{"name":"hasStrictFDerivAt_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nφ' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : Fin n.succ) → F' i)\n⊢ Iff (HasStrictFDerivAt (fun x => Fin.cons (φ x) (φs x)) φ' x) (And (HasStrictFDerivAt φ ((ContinuousLinearMap.proj 0).comp φ') x) (HasStrictFDerivAt φs ((Pi.compRightL 𝕜 F' Fin.succ).comp φ') x))","decl":"theorem hasStrictFDerivAt_finCons {φ' : E →L[𝕜] Π i, F' i} :\n    HasStrictFDerivAt (fun x => Fin.cons (φ x) (φs x)) φ' x ↔\n      HasStrictFDerivAt φ (.proj 0 ∘L φ') x ∧\n      HasStrictFDerivAt φs (Pi.compRightL 𝕜 F' Fin.succ ∘L φ') x := by\n  rw [hasStrictFDerivAt_pi', Fin.forall_fin_succ, hasStrictFDerivAt_pi']\n  dsimp [ContinuousLinearMap.comp, LinearMap.comp, Function.comp_def]\n  simp only [Fin.cons_zero, Fin.cons_succ]\n\n"}
{"name":"hasStrictFDerivAt_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nφ' : ContinuousLinearMap (RingHom.id 𝕜) E (F' 0)\nφs' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : Fin n) → F' i.succ)\n⊢ Iff (HasStrictFDerivAt (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') x) (And (HasStrictFDerivAt φ φ' x) (HasStrictFDerivAt φs φs' x))","decl":"/-- A variant of `hasStrictFDerivAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasStrictFDerivAt_finCons'\n    {φ' : E →L[𝕜] F' 0} {φs' : E →L[𝕜] Π i, F' (Fin.succ i)} :\n    HasStrictFDerivAt (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') x ↔\n      HasStrictFDerivAt φ φ' x ∧ HasStrictFDerivAt φs φs' x :=\n  hasStrictFDerivAt_finCons\n\n"}
{"name":"HasStrictFDerivAt.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nφ' : ContinuousLinearMap (RingHom.id 𝕜) E (F' 0)\nφs' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : Fin n) → F' i.succ)\nh : HasStrictFDerivAt φ φ' x\nhs : HasStrictFDerivAt φs φs' x\n⊢ HasStrictFDerivAt (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.finCons\n    {φ' : E →L[𝕜] F' 0} {φs' : E →L[𝕜] Π i, F' (Fin.succ i)}\n    (h : HasStrictFDerivAt φ φ' x) (hs : HasStrictFDerivAt φs φs' x) :\n    HasStrictFDerivAt (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') x :=\n  hasStrictFDerivAt_finCons'.mpr ⟨h, hs⟩\n\n"}
{"name":"hasFDerivAtFilter_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nφ' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : Fin n.succ) → F' i)\nl : Filter E\n⊢ Iff (HasFDerivAtFilter (fun x => Fin.cons (φ x) (φs x)) φ' x l) (And (HasFDerivAtFilter φ ((ContinuousLinearMap.proj 0).comp φ') x l) (HasFDerivAtFilter φs ((Pi.compRightL 𝕜 F' Fin.succ).comp φ') x l))","decl":"theorem hasFDerivAtFilter_finCons\n    {φ' : E →L[𝕜] Π i, F' i} {l : Filter E} :\n    HasFDerivAtFilter (fun x => Fin.cons (φ x) (φs x)) φ' x l ↔\n      HasFDerivAtFilter φ (.proj 0 ∘L φ') x l ∧\n      HasFDerivAtFilter φs (Pi.compRightL 𝕜 F' Fin.succ ∘L φ') x l := by\n  rw [hasFDerivAtFilter_pi', Fin.forall_fin_succ, hasFDerivAtFilter_pi']\n  dsimp [ContinuousLinearMap.comp, LinearMap.comp, Function.comp_def]\n  simp only [Fin.cons_zero, Fin.cons_succ]\n\n"}
{"name":"hasFDerivAtFilter_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nφ' : ContinuousLinearMap (RingHom.id 𝕜) E (F' 0)\nφs' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : Fin n) → F' i.succ)\nl : Filter E\n⊢ Iff (HasFDerivAtFilter (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') x l) (And (HasFDerivAtFilter φ φ' x l) (HasFDerivAtFilter φs φs' x l))","decl":"/-- A variant of `hasFDerivAtFilter_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasFDerivAtFilter_finCons'\n    {φ' : E →L[𝕜] F' 0} {φs' : E →L[𝕜] Π i, F' (Fin.succ i)} {l : Filter E} :\n    HasFDerivAtFilter (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') x l ↔\n      HasFDerivAtFilter φ φ' x l ∧ HasFDerivAtFilter φs φs' x l :=\n  hasFDerivAtFilter_finCons\n\n"}
{"name":"HasFDerivAtFilter.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nφ' : ContinuousLinearMap (RingHom.id 𝕜) E (F' 0)\nφs' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : Fin n) → F' i.succ)\nl : Filter E\nh : HasFDerivAtFilter φ φ' x l\nhs : HasFDerivAtFilter φs φs' x l\n⊢ HasFDerivAtFilter (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') x l","decl":"theorem HasFDerivAtFilter.finCons\n    {φ' : E →L[𝕜] F' 0} {φs' : E →L[𝕜] Π i, F' (Fin.succ i)} {l : Filter E}\n    (h : HasFDerivAtFilter φ φ' x l) (hs : HasFDerivAtFilter φs φs' x l) :\n    HasFDerivAtFilter (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') x l :=\n  hasFDerivAtFilter_finCons'.mpr ⟨h, hs⟩\n\n"}
{"name":"hasFDerivAt_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nφ' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : Fin n.succ) → F' i)\n⊢ Iff (HasFDerivAt (fun x => Fin.cons (φ x) (φs x)) φ' x) (And (HasFDerivAt φ ((ContinuousLinearMap.proj 0).comp φ') x) (HasFDerivAt φs ((Pi.compRightL 𝕜 F' Fin.succ).comp φ') x))","decl":"theorem hasFDerivAt_finCons\n    {φ' : E →L[𝕜] Π i, F' i} :\n    HasFDerivAt (fun x => Fin.cons (φ x) (φs x)) φ' x ↔\n      HasFDerivAt φ (.proj 0 ∘L φ') x ∧ HasFDerivAt φs (Pi.compRightL 𝕜 F' Fin.succ ∘L φ') x :=\n  hasFDerivAtFilter_finCons\n\n"}
{"name":"hasFDerivAt_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nφ' : ContinuousLinearMap (RingHom.id 𝕜) E (F' 0)\nφs' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : Fin n) → F' i.succ)\n⊢ Iff (HasFDerivAt (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') x) (And (HasFDerivAt φ φ' x) (HasFDerivAt φs φs' x))","decl":"/-- A variant of `hasFDerivAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasFDerivAt_finCons'\n    {φ' : E →L[𝕜] F' 0} {φs' : E →L[𝕜] Π i, F' (Fin.succ i)} :\n    HasFDerivAt (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') x ↔\n      HasFDerivAt φ φ' x ∧ HasFDerivAt φs φs' x :=\n  hasFDerivAt_finCons\n\n"}
{"name":"HasFDerivAt.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nφ' : ContinuousLinearMap (RingHom.id 𝕜) E (F' 0)\nφs' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : Fin n) → F' i.succ)\nh : HasFDerivAt φ φ' x\nhs : HasFDerivAt φs φs' x\n⊢ HasFDerivAt (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') x","decl":"@[fun_prop]\ntheorem HasFDerivAt.finCons\n    {φ' : E →L[𝕜] F' 0} {φs' : E →L[𝕜] Π i, F' (Fin.succ i)}\n    (h : HasFDerivAt φ φ' x) (hs : HasFDerivAt φs φs' x) :\n    HasFDerivAt (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') x :=\n  hasFDerivAt_finCons'.mpr ⟨h, hs⟩\n\n"}
{"name":"hasFDerivWithinAt_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nφ' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : Fin n.succ) → F' i)\n⊢ Iff (HasFDerivWithinAt (fun x => Fin.cons (φ x) (φs x)) φ' s x) (And (HasFDerivWithinAt φ ((ContinuousLinearMap.proj 0).comp φ') s x) (HasFDerivWithinAt φs ((Pi.compRightL 𝕜 F' Fin.succ).comp φ') s x))","decl":"theorem hasFDerivWithinAt_finCons\n    {φ' : E →L[𝕜] Π i, F' i} :\n    HasFDerivWithinAt (fun x => Fin.cons (φ x) (φs x)) φ' s x ↔\n      HasFDerivWithinAt φ (.proj 0 ∘L φ') s x ∧\n      HasFDerivWithinAt φs (Pi.compRightL 𝕜 F' Fin.succ ∘L φ') s x :=\n  hasFDerivAtFilter_finCons\n\n"}
{"name":"hasFDerivWithinAt_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nφ' : ContinuousLinearMap (RingHom.id 𝕜) E (F' 0)\nφs' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : Fin n) → F' i.succ)\n⊢ Iff (HasFDerivWithinAt (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') s x) (And (HasFDerivWithinAt φ φ' s x) (HasFDerivWithinAt φs φs' s x))","decl":"/-- A variant of `hasFDerivWithinAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasFDerivWithinAt_finCons'\n    {φ' : E →L[𝕜] F' 0} {φs' : E →L[𝕜] Π i, F' (Fin.succ i)} :\n    HasFDerivWithinAt (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') s x ↔\n      HasFDerivWithinAt φ φ' s x ∧ HasFDerivWithinAt φs φs' s x :=\n  hasFDerivAtFilter_finCons\n\n"}
{"name":"HasFDerivWithinAt.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nφ' : ContinuousLinearMap (RingHom.id 𝕜) E (F' 0)\nφs' : ContinuousLinearMap (RingHom.id 𝕜) E ((i : Fin n) → F' i.succ)\nh : HasFDerivWithinAt φ φ' s x\nhs : HasFDerivWithinAt φs φs' s x\n⊢ HasFDerivWithinAt (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.finCons\n    {φ' : E →L[𝕜] F' 0} {φs' : E →L[𝕜] Π i, F' (Fin.succ i)}\n    (h : HasFDerivWithinAt φ φ' s x) (hs : HasFDerivWithinAt φs φs' s x) :\n    HasFDerivWithinAt (fun x => Fin.cons (φ x) (φs x)) (φ'.finCons φs') s x :=\n  hasFDerivWithinAt_finCons'.mpr ⟨h, hs⟩\n\n"}
{"name":"differentiableWithinAt_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\n⊢ Iff (DifferentiableWithinAt 𝕜 (fun x => Fin.cons (φ x) (φs x)) s x) (And (DifferentiableWithinAt 𝕜 φ s x) (DifferentiableWithinAt 𝕜 φs s x))","decl":"theorem differentiableWithinAt_finCons :\n    DifferentiableWithinAt 𝕜 (fun x => Fin.cons (φ x) (φs x)) s x ↔\n      DifferentiableWithinAt 𝕜 φ s x ∧ DifferentiableWithinAt 𝕜 φs s x := by\n  rw [differentiableWithinAt_pi, Fin.forall_fin_succ, differentiableWithinAt_pi]\n  simp only [Fin.cons_zero, Fin.cons_succ]\n\n"}
{"name":"differentiableWithinAt_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\n⊢ Iff (DifferentiableWithinAt 𝕜 (fun x => Fin.cons (φ x) (φs x)) s x) (And (DifferentiableWithinAt 𝕜 φ s x) (DifferentiableWithinAt 𝕜 φs s x))","decl":"/-- A variant of `differentiableWithinAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem differentiableWithinAt_finCons' :\n    DifferentiableWithinAt 𝕜 (fun x => Fin.cons (φ x) (φs x)) s x ↔\n      DifferentiableWithinAt 𝕜 φ s x ∧ DifferentiableWithinAt 𝕜 φs s x :=\n  differentiableWithinAt_finCons\n\n"}
{"name":"DifferentiableWithinAt.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\ns : Set E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nh : DifferentiableWithinAt 𝕜 φ s x\nhs : DifferentiableWithinAt 𝕜 φs s x\n⊢ DifferentiableWithinAt 𝕜 (fun x => Fin.cons (φ x) (φs x)) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.finCons\n    (h : DifferentiableWithinAt 𝕜 φ s x) (hs : DifferentiableWithinAt 𝕜 φs s x) :\n    DifferentiableWithinAt 𝕜 (fun x => Fin.cons (φ x) (φs x)) s x :=\n  differentiableWithinAt_finCons'.mpr ⟨h, hs⟩\n\n"}
{"name":"differentiableAt_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\n⊢ Iff (DifferentiableAt 𝕜 (fun x => Fin.cons (φ x) (φs x)) x) (And (DifferentiableAt 𝕜 φ x) (DifferentiableAt 𝕜 φs x))","decl":"theorem differentiableAt_finCons :\n    DifferentiableAt 𝕜 (fun x => Fin.cons (φ x) (φs x)) x ↔\n      DifferentiableAt 𝕜 φ x ∧ DifferentiableAt 𝕜 φs x := by\n  rw [differentiableAt_pi, Fin.forall_fin_succ, differentiableAt_pi]\n  simp only [Fin.cons_zero, Fin.cons_succ]\n\n"}
{"name":"differentiableAt_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\n⊢ Iff (DifferentiableAt 𝕜 (fun x => Fin.cons (φ x) (φs x)) x) (And (DifferentiableAt 𝕜 φ x) (DifferentiableAt 𝕜 φs x))","decl":"/-- A variant of `differentiableAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem differentiableAt_finCons' :\n    DifferentiableAt 𝕜 (fun x => Fin.cons (φ x) (φs x)) x ↔\n      DifferentiableAt 𝕜 φ x ∧ DifferentiableAt 𝕜 φs x :=\n  differentiableAt_finCons\n\n"}
{"name":"DifferentiableAt.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nh : DifferentiableAt 𝕜 φ x\nhs : DifferentiableAt 𝕜 φs x\n⊢ DifferentiableAt 𝕜 (fun x => Fin.cons (φ x) (φs x)) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.finCons\n    (h : DifferentiableAt 𝕜 φ x) (hs : DifferentiableAt 𝕜 φs x) :\n    DifferentiableAt 𝕜 (fun x => Fin.cons (φ x) (φs x)) x :=\n  differentiableAt_finCons'.mpr ⟨h, hs⟩\n\n"}
{"name":"differentiableOn_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\n⊢ Iff (DifferentiableOn 𝕜 (fun x => Fin.cons (φ x) (φs x)) s) (And (DifferentiableOn 𝕜 φ s) (DifferentiableOn 𝕜 φs s))","decl":"theorem differentiableOn_finCons :\n    DifferentiableOn 𝕜 (fun x => Fin.cons (φ x) (φs x)) s ↔\n      DifferentiableOn 𝕜 φ s ∧ DifferentiableOn 𝕜 φs s := by\n  rw [differentiableOn_pi, Fin.forall_fin_succ, differentiableOn_pi]\n  simp only [Fin.cons_zero, Fin.cons_succ]\n\n"}
{"name":"differentiableOn_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\n⊢ Iff (DifferentiableOn 𝕜 (fun x => Fin.cons (φ x) (φs x)) s) (And (DifferentiableOn 𝕜 φ s) (DifferentiableOn 𝕜 φs s))","decl":"/-- A variant of `differentiableOn_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem differentiableOn_finCons' :\n    DifferentiableOn 𝕜 (fun x => Fin.cons (φ x) (φs x)) s ↔\n      DifferentiableOn 𝕜 φ s ∧ DifferentiableOn 𝕜 φs s :=\n  differentiableOn_finCons\n\n"}
{"name":"DifferentiableOn.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nh : DifferentiableOn 𝕜 φ s\nhs : DifferentiableOn 𝕜 φs s\n⊢ DifferentiableOn 𝕜 (fun x => Fin.cons (φ x) (φs x)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.finCons\n    (h : DifferentiableOn 𝕜 φ s) (hs : DifferentiableOn 𝕜 φs s) :\n    DifferentiableOn 𝕜 (fun x => Fin.cons (φ x) (φs x)) s :=\n  differentiableOn_finCons'.mpr ⟨h, hs⟩\n\n"}
{"name":"differentiable_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\n⊢ Iff (Differentiable 𝕜 fun x => Fin.cons (φ x) (φs x)) (And (Differentiable 𝕜 φ) (Differentiable 𝕜 φs))","decl":"theorem differentiable_finCons :\n    Differentiable 𝕜 (fun x => Fin.cons (φ x) (φs x)) ↔\n      Differentiable 𝕜 φ ∧ Differentiable 𝕜 φs := by\n  rw [differentiable_pi, Fin.forall_fin_succ, differentiable_pi]\n  simp only [Fin.cons_zero, Fin.cons_succ]\n\n"}
{"name":"differentiable_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\n⊢ Iff (Differentiable 𝕜 fun x => Fin.cons (φ x) (φs x)) (And (Differentiable 𝕜 φ) (Differentiable 𝕜 φs))","decl":"/-- A variant of `differentiable_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem differentiable_finCons' :\n    Differentiable 𝕜 (fun x => Fin.cons (φ x) (φs x)) ↔\n      Differentiable 𝕜 φ ∧ Differentiable 𝕜 φs :=\n  differentiable_finCons\n\n"}
{"name":"Differentiable.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nn : Nat\nF' : Fin n.succ → Type u_6\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : E → F' 0\nφs : E → (i : Fin n) → F' i.succ\nh : Differentiable 𝕜 φ\nhs : Differentiable 𝕜 φs\n⊢ Differentiable 𝕜 fun x => Fin.cons (φ x) (φs x)","decl":"@[fun_prop]\ntheorem Differentiable.finCons\n    (h : Differentiable 𝕜 φ) (hs : Differentiable 𝕜 φs) :\n    Differentiable 𝕜 (fun x => Fin.cons (φ x) (φs x)) :=\n  differentiable_finCons'.mpr ⟨h, hs⟩\n\n-- TODO: write the `Fin.cons` versions of `fderivWithin_pi` and `fderiv_pi`\n\n"}
