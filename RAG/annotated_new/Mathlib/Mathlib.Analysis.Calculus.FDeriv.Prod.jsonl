{"name":"HasStrictFDerivAt.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nfâ‚ : E â†’ F\nfâ‚' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nfâ‚‚ : E â†’ G\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) E G\nhfâ‚ : HasStrictFDerivAt fâ‚ fâ‚' x\nhfâ‚‚ : HasStrictFDerivAt fâ‚‚ fâ‚‚' x\nâŠ¢ HasStrictFDerivAt (fun x => { fst := fâ‚ x, snd := fâ‚‚ x }) (fâ‚'.prod fâ‚‚') x","decl":"protected theorem HasStrictFDerivAt.prod (hfâ‚ : HasStrictFDerivAt fâ‚ fâ‚' x)\n    (hfâ‚‚ : HasStrictFDerivAt fâ‚‚ fâ‚‚' x) :\n    HasStrictFDerivAt (fun x => (fâ‚ x, fâ‚‚ x)) (fâ‚'.prod fâ‚‚') x :=\n  .of_isLittleO <| hfâ‚.isLittleO.prod_left hfâ‚‚.isLittleO\n\n"}
{"name":"HasFDerivAtFilter.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nfâ‚ : E â†’ F\nfâ‚' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nL : Filter E\nfâ‚‚ : E â†’ G\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) E G\nhfâ‚ : HasFDerivAtFilter fâ‚ fâ‚' x L\nhfâ‚‚ : HasFDerivAtFilter fâ‚‚ fâ‚‚' x L\nâŠ¢ HasFDerivAtFilter (fun x => { fst := fâ‚ x, snd := fâ‚‚ x }) (fâ‚'.prod fâ‚‚') x L","decl":"theorem HasFDerivAtFilter.prod (hfâ‚ : HasFDerivAtFilter fâ‚ fâ‚' x L)\n    (hfâ‚‚ : HasFDerivAtFilter fâ‚‚ fâ‚‚' x L) :\n    HasFDerivAtFilter (fun x => (fâ‚ x, fâ‚‚ x)) (fâ‚'.prod fâ‚‚') x L :=\n  .of_isLittleO <| hfâ‚.isLittleO.prod_left hfâ‚‚.isLittleO\n\n"}
{"name":"HasFDerivWithinAt.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nfâ‚ : E â†’ F\nfâ‚' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nfâ‚‚ : E â†’ G\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) E G\nhfâ‚ : HasFDerivWithinAt fâ‚ fâ‚' s x\nhfâ‚‚ : HasFDerivWithinAt fâ‚‚ fâ‚‚' s x\nâŠ¢ HasFDerivWithinAt (fun x => { fst := fâ‚ x, snd := fâ‚‚ x }) (fâ‚'.prod fâ‚‚') s x","decl":"@[fun_prop]\nnonrec theorem HasFDerivWithinAt.prod (hfâ‚ : HasFDerivWithinAt fâ‚ fâ‚' s x)\n    (hfâ‚‚ : HasFDerivWithinAt fâ‚‚ fâ‚‚' s x) :\n    HasFDerivWithinAt (fun x => (fâ‚ x, fâ‚‚ x)) (fâ‚'.prod fâ‚‚') s x :=\n  hfâ‚.prod hfâ‚‚\n\n"}
{"name":"HasFDerivAt.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nfâ‚ : E â†’ F\nfâ‚' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nfâ‚‚ : E â†’ G\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) E G\nhfâ‚ : HasFDerivAt fâ‚ fâ‚' x\nhfâ‚‚ : HasFDerivAt fâ‚‚ fâ‚‚' x\nâŠ¢ HasFDerivAt (fun x => { fst := fâ‚ x, snd := fâ‚‚ x }) (fâ‚'.prod fâ‚‚') x","decl":"@[fun_prop]\nnonrec theorem HasFDerivAt.prod (hfâ‚ : HasFDerivAt fâ‚ fâ‚' x) (hfâ‚‚ : HasFDerivAt fâ‚‚ fâ‚‚' x) :\n    HasFDerivAt (fun x => (fâ‚ x, fâ‚‚ x)) (fâ‚'.prod fâ‚‚') x :=\n  hfâ‚.prod hfâ‚‚\n\n"}
{"name":"hasFDerivAt_prod_mk_left","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\neâ‚€ : E\nfâ‚€ : F\nâŠ¢ HasFDerivAt (fun e => { fst := e, snd := fâ‚€ }) (ContinuousLinearMap.inl ğ•œ E F) eâ‚€","decl":"@[fun_prop]\ntheorem hasFDerivAt_prod_mk_left (eâ‚€ : E) (fâ‚€ : F) :\n    HasFDerivAt (fun e : E => (e, fâ‚€)) (inl ğ•œ E F) eâ‚€ :=\n  (hasFDerivAt_id eâ‚€).prod (hasFDerivAt_const fâ‚€ eâ‚€)\n\n"}
{"name":"hasFDerivAt_prod_mk_right","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\neâ‚€ : E\nfâ‚€ : F\nâŠ¢ HasFDerivAt (fun f => { fst := eâ‚€, snd := f }) (ContinuousLinearMap.inr ğ•œ E F) fâ‚€","decl":"@[fun_prop]\ntheorem hasFDerivAt_prod_mk_right (eâ‚€ : E) (fâ‚€ : F) :\n    HasFDerivAt (fun f : F => (eâ‚€, f)) (inr ğ•œ E F) fâ‚€ :=\n  (hasFDerivAt_const eâ‚€ fâ‚€).prod (hasFDerivAt_id fâ‚€)\n\n"}
{"name":"DifferentiableWithinAt.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nfâ‚ : E â†’ F\nx : E\ns : Set E\nfâ‚‚ : E â†’ G\nhfâ‚ : DifferentiableWithinAt ğ•œ fâ‚ s x\nhfâ‚‚ : DifferentiableWithinAt ğ•œ fâ‚‚ s x\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => { fst := fâ‚ x, snd := fâ‚‚ x }) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.prod (hfâ‚ : DifferentiableWithinAt ğ•œ fâ‚ s x)\n    (hfâ‚‚ : DifferentiableWithinAt ğ•œ fâ‚‚ s x) :\n    DifferentiableWithinAt ğ•œ (fun x : E => (fâ‚ x, fâ‚‚ x)) s x :=\n  (hfâ‚.hasFDerivWithinAt.prod hfâ‚‚.hasFDerivWithinAt).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nfâ‚ : E â†’ F\nx : E\nfâ‚‚ : E â†’ G\nhfâ‚ : DifferentiableAt ğ•œ fâ‚ x\nhfâ‚‚ : DifferentiableAt ğ•œ fâ‚‚ x\nâŠ¢ DifferentiableAt ğ•œ (fun x => { fst := fâ‚ x, snd := fâ‚‚ x }) x","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.prod (hfâ‚ : DifferentiableAt ğ•œ fâ‚ x) (hfâ‚‚ : DifferentiableAt ğ•œ fâ‚‚ x) :\n    DifferentiableAt ğ•œ (fun x : E => (fâ‚ x, fâ‚‚ x)) x :=\n  (hfâ‚.hasFDerivAt.prod hfâ‚‚.hasFDerivAt).differentiableAt\n\n"}
{"name":"DifferentiableOn.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nfâ‚ : E â†’ F\ns : Set E\nfâ‚‚ : E â†’ G\nhfâ‚ : DifferentiableOn ğ•œ fâ‚ s\nhfâ‚‚ : DifferentiableOn ğ•œ fâ‚‚ s\nâŠ¢ DifferentiableOn ğ•œ (fun x => { fst := fâ‚ x, snd := fâ‚‚ x }) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.prod (hfâ‚ : DifferentiableOn ğ•œ fâ‚ s) (hfâ‚‚ : DifferentiableOn ğ•œ fâ‚‚ s) :\n    DifferentiableOn ğ•œ (fun x : E => (fâ‚ x, fâ‚‚ x)) s := fun x hx =>\n  DifferentiableWithinAt.prod (hfâ‚ x hx) (hfâ‚‚ x hx)\n\n"}
{"name":"Differentiable.prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nfâ‚ : E â†’ F\nfâ‚‚ : E â†’ G\nhfâ‚ : Differentiable ğ•œ fâ‚\nhfâ‚‚ : Differentiable ğ•œ fâ‚‚\nâŠ¢ Differentiable ğ•œ fun x => { fst := fâ‚ x, snd := fâ‚‚ x }","decl":"@[simp, fun_prop]\ntheorem Differentiable.prod (hfâ‚ : Differentiable ğ•œ fâ‚) (hfâ‚‚ : Differentiable ğ•œ fâ‚‚) :\n    Differentiable ğ•œ fun x : E => (fâ‚ x, fâ‚‚ x) := fun x => DifferentiableAt.prod (hfâ‚ x) (hfâ‚‚ x)\n\n"}
{"name":"DifferentiableAt.fderiv_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nfâ‚ : E â†’ F\nx : E\nfâ‚‚ : E â†’ G\nhfâ‚ : DifferentiableAt ğ•œ fâ‚ x\nhfâ‚‚ : DifferentiableAt ğ•œ fâ‚‚ x\nâŠ¢ Eq (fderiv ğ•œ (fun x => { fst := fâ‚ x, snd := fâ‚‚ x }) x) ((fderiv ğ•œ fâ‚ x).prod (fderiv ğ•œ fâ‚‚ x))","decl":"theorem DifferentiableAt.fderiv_prod (hfâ‚ : DifferentiableAt ğ•œ fâ‚ x)\n    (hfâ‚‚ : DifferentiableAt ğ•œ fâ‚‚ x) :\n    fderiv ğ•œ (fun x : E => (fâ‚ x, fâ‚‚ x)) x = (fderiv ğ•œ fâ‚ x).prod (fderiv ğ•œ fâ‚‚ x) :=\n  (hfâ‚.hasFDerivAt.prod hfâ‚‚.hasFDerivAt).fderiv\n\n"}
{"name":"DifferentiableWithinAt.fderivWithin_prod","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nfâ‚ : E â†’ F\nx : E\ns : Set E\nfâ‚‚ : E â†’ G\nhfâ‚ : DifferentiableWithinAt ğ•œ fâ‚ s x\nhfâ‚‚ : DifferentiableWithinAt ğ•œ fâ‚‚ s x\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun x => { fst := fâ‚ x, snd := fâ‚‚ x }) s x) ((fderivWithin ğ•œ fâ‚ s x).prod (fderivWithin ğ•œ fâ‚‚ s x))","decl":"theorem DifferentiableWithinAt.fderivWithin_prod (hfâ‚ : DifferentiableWithinAt ğ•œ fâ‚ s x)\n    (hfâ‚‚ : DifferentiableWithinAt ğ•œ fâ‚‚ s x) (hxs : UniqueDiffWithinAt ğ•œ s x) :\n    fderivWithin ğ•œ (fun x : E => (fâ‚ x, fâ‚‚ x)) s x =\n      (fderivWithin ğ•œ fâ‚ s x).prod (fderivWithin ğ•œ fâ‚‚ s x) :=\n  (hfâ‚.hasFDerivWithinAt.prod hfâ‚‚.hasFDerivWithinAt).fderivWithin hxs\n\n"}
{"name":"hasStrictFDerivAt_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\nâŠ¢ HasStrictFDerivAt Prod.fst (ContinuousLinearMap.fst ğ•œ E F) p","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_fst : HasStrictFDerivAt (@Prod.fst E F) (fst ğ•œ E F) p :=\n  (fst ğ•œ E F).hasStrictFDerivAt\n\n"}
{"name":"HasStrictFDerivAt.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nfâ‚‚ : E â†’ Prod F G\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) E (Prod F G)\nh : HasStrictFDerivAt fâ‚‚ fâ‚‚' x\nâŠ¢ HasStrictFDerivAt (fun x => (fâ‚‚ x).1) ((ContinuousLinearMap.fst ğ•œ F G).comp fâ‚‚') x","decl":"@[fun_prop]\nprotected theorem HasStrictFDerivAt.fst (h : HasStrictFDerivAt fâ‚‚ fâ‚‚' x) :\n    HasStrictFDerivAt (fun x => (fâ‚‚ x).1) ((fst ğ•œ F G).comp fâ‚‚') x :=\n  hasStrictFDerivAt_fst.comp x h\n\n"}
{"name":"hasFDerivAtFilter_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\nL : Filter (Prod E F)\nâŠ¢ HasFDerivAtFilter Prod.fst (ContinuousLinearMap.fst ğ•œ E F) p L","decl":"theorem hasFDerivAtFilter_fst {L : Filter (E Ã— F)} :\n    HasFDerivAtFilter (@Prod.fst E F) (fst ğ•œ E F) p L :=\n  (fst ğ•œ E F).hasFDerivAtFilter\n\n"}
{"name":"HasFDerivAtFilter.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nL : Filter E\nfâ‚‚ : E â†’ Prod F G\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) E (Prod F G)\nh : HasFDerivAtFilter fâ‚‚ fâ‚‚' x L\nâŠ¢ HasFDerivAtFilter (fun x => (fâ‚‚ x).1) ((ContinuousLinearMap.fst ğ•œ F G).comp fâ‚‚') x L","decl":"protected theorem HasFDerivAtFilter.fst (h : HasFDerivAtFilter fâ‚‚ fâ‚‚' x L) :\n    HasFDerivAtFilter (fun x => (fâ‚‚ x).1) ((fst ğ•œ F G).comp fâ‚‚') x L :=\n  hasFDerivAtFilter_fst.comp x h tendsto_map\n\n"}
{"name":"hasFDerivAt_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\nâŠ¢ HasFDerivAt Prod.fst (ContinuousLinearMap.fst ğ•œ E F) p","decl":"@[fun_prop]\ntheorem hasFDerivAt_fst : HasFDerivAt (@Prod.fst E F) (fst ğ•œ E F) p :=\n  hasFDerivAtFilter_fst\n\n"}
{"name":"HasFDerivAt.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nfâ‚‚ : E â†’ Prod F G\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) E (Prod F G)\nh : HasFDerivAt fâ‚‚ fâ‚‚' x\nâŠ¢ HasFDerivAt (fun x => (fâ‚‚ x).1) ((ContinuousLinearMap.fst ğ•œ F G).comp fâ‚‚') x","decl":"@[fun_prop]\nprotected nonrec theorem HasFDerivAt.fst (h : HasFDerivAt fâ‚‚ fâ‚‚' x) :\n    HasFDerivAt (fun x => (fâ‚‚ x).1) ((fst ğ•œ F G).comp fâ‚‚') x :=\n  h.fst\n\n"}
{"name":"hasFDerivWithinAt_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\ns : Set (Prod E F)\nâŠ¢ HasFDerivWithinAt Prod.fst (ContinuousLinearMap.fst ğ•œ E F) s p","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_fst {s : Set (E Ã— F)} :\n    HasFDerivWithinAt (@Prod.fst E F) (fst ğ•œ E F) s p :=\n  hasFDerivAtFilter_fst\n\n"}
{"name":"HasFDerivWithinAt.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\ns : Set E\nfâ‚‚ : E â†’ Prod F G\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) E (Prod F G)\nh : HasFDerivWithinAt fâ‚‚ fâ‚‚' s x\nâŠ¢ HasFDerivWithinAt (fun x => (fâ‚‚ x).1) ((ContinuousLinearMap.fst ğ•œ F G).comp fâ‚‚') s x","decl":"@[fun_prop]\nprotected nonrec theorem HasFDerivWithinAt.fst (h : HasFDerivWithinAt fâ‚‚ fâ‚‚' s x) :\n    HasFDerivWithinAt (fun x => (fâ‚‚ x).1) ((fst ğ•œ F G).comp fâ‚‚') s x :=\n  h.fst\n\n"}
{"name":"differentiableAt_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\nâŠ¢ DifferentiableAt ğ•œ Prod.fst p","decl":"@[fun_prop]\ntheorem differentiableAt_fst : DifferentiableAt ğ•œ Prod.fst p :=\n  hasFDerivAt_fst.differentiableAt\n\n"}
{"name":"DifferentiableAt.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nfâ‚‚ : E â†’ Prod F G\nh : DifferentiableAt ğ•œ fâ‚‚ x\nâŠ¢ DifferentiableAt ğ•œ (fun x => (fâ‚‚ x).1) x","decl":"@[simp, fun_prop]\nprotected theorem DifferentiableAt.fst (h : DifferentiableAt ğ•œ fâ‚‚ x) :\n    DifferentiableAt ğ•œ (fun x => (fâ‚‚ x).1) x :=\n  differentiableAt_fst.comp x h\n\n"}
{"name":"differentiable_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nâŠ¢ Differentiable ğ•œ Prod.fst","decl":"@[fun_prop]\ntheorem differentiable_fst : Differentiable ğ•œ (Prod.fst : E Ã— F â†’ E) := fun _ =>\n  differentiableAt_fst\n\n"}
{"name":"Differentiable.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nfâ‚‚ : E â†’ Prod F G\nh : Differentiable ğ•œ fâ‚‚\nâŠ¢ Differentiable ğ•œ fun x => (fâ‚‚ x).1","decl":"@[simp, fun_prop]\nprotected theorem Differentiable.fst (h : Differentiable ğ•œ fâ‚‚) :\n    Differentiable ğ•œ fun x => (fâ‚‚ x).1 :=\n  differentiable_fst.comp h\n\n"}
{"name":"differentiableWithinAt_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\ns : Set (Prod E F)\nâŠ¢ DifferentiableWithinAt ğ•œ Prod.fst s p","decl":"@[fun_prop]\ntheorem differentiableWithinAt_fst {s : Set (E Ã— F)} : DifferentiableWithinAt ğ•œ Prod.fst s p :=\n  differentiableAt_fst.differentiableWithinAt\n\n"}
{"name":"DifferentiableWithinAt.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\ns : Set E\nfâ‚‚ : E â†’ Prod F G\nh : DifferentiableWithinAt ğ•œ fâ‚‚ s x\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => (fâ‚‚ x).1) s x","decl":"@[fun_prop]\nprotected theorem DifferentiableWithinAt.fst (h : DifferentiableWithinAt ğ•œ fâ‚‚ s x) :\n    DifferentiableWithinAt ğ•œ (fun x => (fâ‚‚ x).1) s x :=\n  differentiableAt_fst.comp_differentiableWithinAt x h\n\n"}
{"name":"differentiableOn_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set (Prod E F)\nâŠ¢ DifferentiableOn ğ•œ Prod.fst s","decl":"@[fun_prop]\ntheorem differentiableOn_fst {s : Set (E Ã— F)} : DifferentiableOn ğ•œ Prod.fst s :=\n  differentiable_fst.differentiableOn\n\n"}
{"name":"DifferentiableOn.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nfâ‚‚ : E â†’ Prod F G\nh : DifferentiableOn ğ•œ fâ‚‚ s\nâŠ¢ DifferentiableOn ğ•œ (fun x => (fâ‚‚ x).1) s","decl":"@[fun_prop]\nprotected theorem DifferentiableOn.fst (h : DifferentiableOn ğ•œ fâ‚‚ s) :\n    DifferentiableOn ğ•œ (fun x => (fâ‚‚ x).1) s :=\n  differentiable_fst.comp_differentiableOn h\n\n"}
{"name":"fderiv_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\nâŠ¢ Eq (fderiv ğ•œ Prod.fst p) (ContinuousLinearMap.fst ğ•œ E F)","decl":"theorem fderiv_fst : fderiv ğ•œ Prod.fst p = fst ğ•œ E F :=\n  hasFDerivAt_fst.fderiv\n\n"}
{"name":"fderiv.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nfâ‚‚ : E â†’ Prod F G\nh : DifferentiableAt ğ•œ fâ‚‚ x\nâŠ¢ Eq (fderiv ğ•œ (fun x => (fâ‚‚ x).1) x) ((ContinuousLinearMap.fst ğ•œ F G).comp (fderiv ğ•œ fâ‚‚ x))","decl":"theorem fderiv.fst (h : DifferentiableAt ğ•œ fâ‚‚ x) :\n    fderiv ğ•œ (fun x => (fâ‚‚ x).1) x = (fst ğ•œ F G).comp (fderiv ğ•œ fâ‚‚ x) :=\n  h.hasFDerivAt.fst.fderiv\n\n"}
{"name":"fderivWithin_fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\ns : Set (Prod E F)\nhs : UniqueDiffWithinAt ğ•œ s p\nâŠ¢ Eq (fderivWithin ğ•œ Prod.fst s p) (ContinuousLinearMap.fst ğ•œ E F)","decl":"theorem fderivWithin_fst {s : Set (E Ã— F)} (hs : UniqueDiffWithinAt ğ•œ s p) :\n    fderivWithin ğ•œ Prod.fst s p = fst ğ•œ E F :=\n  hasFDerivWithinAt_fst.fderivWithin hs\n\n"}
{"name":"fderivWithin.fst","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\ns : Set E\nfâ‚‚ : E â†’ Prod F G\nhs : UniqueDiffWithinAt ğ•œ s x\nh : DifferentiableWithinAt ğ•œ fâ‚‚ s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun x => (fâ‚‚ x).1) s x) ((ContinuousLinearMap.fst ğ•œ F G).comp (fderivWithin ğ•œ fâ‚‚ s x))","decl":"theorem fderivWithin.fst (hs : UniqueDiffWithinAt ğ•œ s x) (h : DifferentiableWithinAt ğ•œ fâ‚‚ s x) :\n    fderivWithin ğ•œ (fun x => (fâ‚‚ x).1) s x = (fst ğ•œ F G).comp (fderivWithin ğ•œ fâ‚‚ s x) :=\n  h.hasFDerivWithinAt.fst.fderivWithin hs\n\n"}
{"name":"hasStrictFDerivAt_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\nâŠ¢ HasStrictFDerivAt Prod.snd (ContinuousLinearMap.snd ğ•œ E F) p","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_snd : HasStrictFDerivAt (@Prod.snd E F) (snd ğ•œ E F) p :=\n  (snd ğ•œ E F).hasStrictFDerivAt\n\n"}
{"name":"HasStrictFDerivAt.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nfâ‚‚ : E â†’ Prod F G\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) E (Prod F G)\nh : HasStrictFDerivAt fâ‚‚ fâ‚‚' x\nâŠ¢ HasStrictFDerivAt (fun x => (fâ‚‚ x).2) ((ContinuousLinearMap.snd ğ•œ F G).comp fâ‚‚') x","decl":"@[fun_prop]\nprotected theorem HasStrictFDerivAt.snd (h : HasStrictFDerivAt fâ‚‚ fâ‚‚' x) :\n    HasStrictFDerivAt (fun x => (fâ‚‚ x).2) ((snd ğ•œ F G).comp fâ‚‚') x :=\n  hasStrictFDerivAt_snd.comp x h\n\n"}
{"name":"hasFDerivAtFilter_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\nL : Filter (Prod E F)\nâŠ¢ HasFDerivAtFilter Prod.snd (ContinuousLinearMap.snd ğ•œ E F) p L","decl":"theorem hasFDerivAtFilter_snd {L : Filter (E Ã— F)} :\n    HasFDerivAtFilter (@Prod.snd E F) (snd ğ•œ E F) p L :=\n  (snd ğ•œ E F).hasFDerivAtFilter\n\n"}
{"name":"HasFDerivAtFilter.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nL : Filter E\nfâ‚‚ : E â†’ Prod F G\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) E (Prod F G)\nh : HasFDerivAtFilter fâ‚‚ fâ‚‚' x L\nâŠ¢ HasFDerivAtFilter (fun x => (fâ‚‚ x).2) ((ContinuousLinearMap.snd ğ•œ F G).comp fâ‚‚') x L","decl":"protected theorem HasFDerivAtFilter.snd (h : HasFDerivAtFilter fâ‚‚ fâ‚‚' x L) :\n    HasFDerivAtFilter (fun x => (fâ‚‚ x).2) ((snd ğ•œ F G).comp fâ‚‚') x L :=\n  hasFDerivAtFilter_snd.comp x h tendsto_map\n\n"}
{"name":"hasFDerivAt_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\nâŠ¢ HasFDerivAt Prod.snd (ContinuousLinearMap.snd ğ•œ E F) p","decl":"@[fun_prop]\ntheorem hasFDerivAt_snd : HasFDerivAt (@Prod.snd E F) (snd ğ•œ E F) p :=\n  hasFDerivAtFilter_snd\n\n"}
{"name":"HasFDerivAt.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nfâ‚‚ : E â†’ Prod F G\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) E (Prod F G)\nh : HasFDerivAt fâ‚‚ fâ‚‚' x\nâŠ¢ HasFDerivAt (fun x => (fâ‚‚ x).2) ((ContinuousLinearMap.snd ğ•œ F G).comp fâ‚‚') x","decl":"@[fun_prop]\nprotected nonrec theorem HasFDerivAt.snd (h : HasFDerivAt fâ‚‚ fâ‚‚' x) :\n    HasFDerivAt (fun x => (fâ‚‚ x).2) ((snd ğ•œ F G).comp fâ‚‚') x :=\n  h.snd\n\n"}
{"name":"hasFDerivWithinAt_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\ns : Set (Prod E F)\nâŠ¢ HasFDerivWithinAt Prod.snd (ContinuousLinearMap.snd ğ•œ E F) s p","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_snd {s : Set (E Ã— F)} :\n    HasFDerivWithinAt (@Prod.snd E F) (snd ğ•œ E F) s p :=\n  hasFDerivAtFilter_snd\n\n"}
{"name":"HasFDerivWithinAt.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\ns : Set E\nfâ‚‚ : E â†’ Prod F G\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) E (Prod F G)\nh : HasFDerivWithinAt fâ‚‚ fâ‚‚' s x\nâŠ¢ HasFDerivWithinAt (fun x => (fâ‚‚ x).2) ((ContinuousLinearMap.snd ğ•œ F G).comp fâ‚‚') s x","decl":"@[fun_prop]\nprotected nonrec theorem HasFDerivWithinAt.snd (h : HasFDerivWithinAt fâ‚‚ fâ‚‚' s x) :\n    HasFDerivWithinAt (fun x => (fâ‚‚ x).2) ((snd ğ•œ F G).comp fâ‚‚') s x :=\n  h.snd\n\n"}
{"name":"differentiableAt_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\nâŠ¢ DifferentiableAt ğ•œ Prod.snd p","decl":"@[fun_prop]\ntheorem differentiableAt_snd : DifferentiableAt ğ•œ Prod.snd p :=\n  hasFDerivAt_snd.differentiableAt\n\n"}
{"name":"DifferentiableAt.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nfâ‚‚ : E â†’ Prod F G\nh : DifferentiableAt ğ•œ fâ‚‚ x\nâŠ¢ DifferentiableAt ğ•œ (fun x => (fâ‚‚ x).2) x","decl":"@[simp, fun_prop]\nprotected theorem DifferentiableAt.snd (h : DifferentiableAt ğ•œ fâ‚‚ x) :\n    DifferentiableAt ğ•œ (fun x => (fâ‚‚ x).2) x :=\n  differentiableAt_snd.comp x h\n\n"}
{"name":"differentiable_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nâŠ¢ Differentiable ğ•œ Prod.snd","decl":"@[fun_prop]\ntheorem differentiable_snd : Differentiable ğ•œ (Prod.snd : E Ã— F â†’ F) := fun _ =>\n  differentiableAt_snd\n\n"}
{"name":"Differentiable.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nfâ‚‚ : E â†’ Prod F G\nh : Differentiable ğ•œ fâ‚‚\nâŠ¢ Differentiable ğ•œ fun x => (fâ‚‚ x).2","decl":"@[simp, fun_prop]\nprotected theorem Differentiable.snd (h : Differentiable ğ•œ fâ‚‚) :\n    Differentiable ğ•œ fun x => (fâ‚‚ x).2 :=\n  differentiable_snd.comp h\n\n"}
{"name":"differentiableWithinAt_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\ns : Set (Prod E F)\nâŠ¢ DifferentiableWithinAt ğ•œ Prod.snd s p","decl":"@[fun_prop]\ntheorem differentiableWithinAt_snd {s : Set (E Ã— F)} : DifferentiableWithinAt ğ•œ Prod.snd s p :=\n  differentiableAt_snd.differentiableWithinAt\n\n"}
{"name":"DifferentiableWithinAt.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\ns : Set E\nfâ‚‚ : E â†’ Prod F G\nh : DifferentiableWithinAt ğ•œ fâ‚‚ s x\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => (fâ‚‚ x).2) s x","decl":"@[fun_prop]\nprotected theorem DifferentiableWithinAt.snd (h : DifferentiableWithinAt ğ•œ fâ‚‚ s x) :\n    DifferentiableWithinAt ğ•œ (fun x => (fâ‚‚ x).2) s x :=\n  differentiableAt_snd.comp_differentiableWithinAt x h\n\n"}
{"name":"differentiableOn_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set (Prod E F)\nâŠ¢ DifferentiableOn ğ•œ Prod.snd s","decl":"@[fun_prop]\ntheorem differentiableOn_snd {s : Set (E Ã— F)} : DifferentiableOn ğ•œ Prod.snd s :=\n  differentiable_snd.differentiableOn\n\n"}
{"name":"DifferentiableOn.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nfâ‚‚ : E â†’ Prod F G\nh : DifferentiableOn ğ•œ fâ‚‚ s\nâŠ¢ DifferentiableOn ğ•œ (fun x => (fâ‚‚ x).2) s","decl":"@[fun_prop]\nprotected theorem DifferentiableOn.snd (h : DifferentiableOn ğ•œ fâ‚‚ s) :\n    DifferentiableOn ğ•œ (fun x => (fâ‚‚ x).2) s :=\n  differentiable_snd.comp_differentiableOn h\n\n"}
{"name":"fderiv_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\nâŠ¢ Eq (fderiv ğ•œ Prod.snd p) (ContinuousLinearMap.snd ğ•œ E F)","decl":"theorem fderiv_snd : fderiv ğ•œ Prod.snd p = snd ğ•œ E F :=\n  hasFDerivAt_snd.fderiv\n\n"}
{"name":"fderiv.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nfâ‚‚ : E â†’ Prod F G\nh : DifferentiableAt ğ•œ fâ‚‚ x\nâŠ¢ Eq (fderiv ğ•œ (fun x => (fâ‚‚ x).2) x) ((ContinuousLinearMap.snd ğ•œ F G).comp (fderiv ğ•œ fâ‚‚ x))","decl":"theorem fderiv.snd (h : DifferentiableAt ğ•œ fâ‚‚ x) :\n    fderiv ğ•œ (fun x => (fâ‚‚ x).2) x = (snd ğ•œ F G).comp (fderiv ğ•œ fâ‚‚ x) :=\n  h.hasFDerivAt.snd.fderiv\n\n"}
{"name":"fderivWithin_snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : Prod E F\ns : Set (Prod E F)\nhs : UniqueDiffWithinAt ğ•œ s p\nâŠ¢ Eq (fderivWithin ğ•œ Prod.snd s p) (ContinuousLinearMap.snd ğ•œ E F)","decl":"theorem fderivWithin_snd {s : Set (E Ã— F)} (hs : UniqueDiffWithinAt ğ•œ s p) :\n    fderivWithin ğ•œ Prod.snd s p = snd ğ•œ E F :=\n  hasFDerivWithinAt_snd.fderivWithin hs\n\n"}
{"name":"fderivWithin.snd","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\ns : Set E\nfâ‚‚ : E â†’ Prod F G\nhs : UniqueDiffWithinAt ğ•œ s x\nh : DifferentiableWithinAt ğ•œ fâ‚‚ s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun x => (fâ‚‚ x).2) s x) ((ContinuousLinearMap.snd ğ•œ F G).comp (fderivWithin ğ•œ fâ‚‚ s x))","decl":"theorem fderivWithin.snd (hs : UniqueDiffWithinAt ğ•œ s x) (h : DifferentiableWithinAt ğ•œ fâ‚‚ s x) :\n    fderivWithin ğ•œ (fun x => (fâ‚‚ x).2) s x = (snd ğ•œ F G).comp (fderivWithin ğ•œ fâ‚‚ s x) :=\n  h.hasFDerivWithinAt.snd.fderivWithin hs\n\n"}
{"name":"HasStrictFDerivAt.prodMap","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nfâ‚‚ : G â†’ G'\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) G G'\np : Prod E G\nhf : HasStrictFDerivAt f f' p.1\nhfâ‚‚ : HasStrictFDerivAt fâ‚‚ fâ‚‚' p.2\nâŠ¢ HasStrictFDerivAt (Prod.map f fâ‚‚) (f'.prodMap fâ‚‚') p","decl":"@[fun_prop]\nprotected theorem HasStrictFDerivAt.prodMap (hf : HasStrictFDerivAt f f' p.1)\n    (hfâ‚‚ : HasStrictFDerivAt fâ‚‚ fâ‚‚' p.2) : HasStrictFDerivAt (Prod.map f fâ‚‚) (f'.prodMap fâ‚‚') p :=\n  (hf.comp p hasStrictFDerivAt_fst).prod (hfâ‚‚.comp p hasStrictFDerivAt_snd)\n\n"}
{"name":"HasFDerivAt.prodMap","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nfâ‚‚ : G â†’ G'\nfâ‚‚' : ContinuousLinearMap (RingHom.id ğ•œ) G G'\np : Prod E G\nhf : HasFDerivAt f f' p.1\nhfâ‚‚ : HasFDerivAt fâ‚‚ fâ‚‚' p.2\nâŠ¢ HasFDerivAt (Prod.map f fâ‚‚) (f'.prodMap fâ‚‚') p","decl":"@[fun_prop]\nprotected theorem HasFDerivAt.prodMap (hf : HasFDerivAt f f' p.1) (hfâ‚‚ : HasFDerivAt fâ‚‚ fâ‚‚' p.2) :\n    HasFDerivAt (Prod.map f fâ‚‚) (f'.prodMap fâ‚‚') p :=\n  (hf.comp p hasFDerivAt_fst).prod (hfâ‚‚.comp p hasFDerivAt_snd)\n\n"}
{"name":"DifferentiableAt.prod_map","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : E â†’ F\nfâ‚‚ : G â†’ G'\np : Prod E G\nhf : DifferentiableAt ğ•œ f p.1\nhfâ‚‚ : DifferentiableAt ğ•œ fâ‚‚ p.2\nâŠ¢ DifferentiableAt ğ•œ (fun p => { fst := f p.1, snd := fâ‚‚ p.2 }) p","decl":"@[simp, fun_prop]\nprotected theorem DifferentiableAt.prod_map (hf : DifferentiableAt ğ•œ f p.1)\n    (hfâ‚‚ : DifferentiableAt ğ•œ fâ‚‚ p.2) : DifferentiableAt ğ•œ (fun p : E Ã— G => (f p.1, fâ‚‚ p.2)) p :=\n  (hf.comp p differentiableAt_fst).prod (hfâ‚‚.comp p differentiableAt_snd)\n\n"}
{"name":"hasStrictFDerivAt_pi'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nÎ¦' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Î¹) â†’ F' i)\nâŠ¢ Iff (HasStrictFDerivAt Î¦ Î¦' x) (âˆ€ (i : Î¹), HasStrictFDerivAt (fun x => Î¦ x i) ((ContinuousLinearMap.proj i).comp Î¦') x)","decl":"@[simp]\ntheorem hasStrictFDerivAt_pi' :\n    HasStrictFDerivAt Î¦ Î¦' x â†” âˆ€ i, HasStrictFDerivAt (fun x => Î¦ x i) ((proj i).comp Î¦') x := by\n  simp only [hasStrictFDerivAt_iff_isLittleO, ContinuousLinearMap.coe_pi]\n  exact isLittleO_pi\n\n"}
{"name":"hasStrictFDerivAt_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nÎ¦' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Î¹) â†’ F' i)\nhÏ† : âˆ€ (i : Î¹), HasStrictFDerivAt (fun x => Î¦ x i) ((ContinuousLinearMap.proj i).comp Î¦') x\nâŠ¢ HasStrictFDerivAt Î¦ Î¦' x","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_pi'' (hÏ† : âˆ€ i, HasStrictFDerivAt (fun x => Î¦ x i) ((proj i).comp Î¦') x) :\n    HasStrictFDerivAt Î¦ Î¦' x := hasStrictFDerivAt_pi'.2 hÏ†\n\n"}
{"name":"hasStrictFDerivAt_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\ni : Î¹\nf : (i : Î¹) â†’ F' i\nâŠ¢ HasStrictFDerivAt (fun f => f i) (ContinuousLinearMap.proj i) f","decl":"@[fun_prop]\ntheorem hasStrictFDerivAt_apply (i : Î¹) (f : âˆ€ i, F' i) :\n    HasStrictFDerivAt (ğ•œ := ğ•œ) (fun f : âˆ€ i, F' i => f i) (proj i) f := by\n  let id' := ContinuousLinearMap.id ğ•œ (âˆ€ i, F' i)\n  have h := ((hasStrictFDerivAt_pi'\n             (Î¦ := fun (f : âˆ€ i, F' i) (i' : Î¹) => f i') (Î¦' := id') (x := f))).1\n  have h' : comp (proj i) id' = proj i := by ext; simp [id']\n  rw [â† h']; apply h; apply hasStrictFDerivAt_id\n\n"}
{"name":"hasStrictFDerivAt_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÏ† : (i : Î¹) â†’ E â†’ F' i\nÏ†' : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) E (F' i)\nâŠ¢ Iff (HasStrictFDerivAt (fun x i => Ï† i x) (ContinuousLinearMap.pi Ï†') x) (âˆ€ (i : Î¹), HasStrictFDerivAt (Ï† i) (Ï†' i) x)","decl":"@[simp 1100] -- Porting note: increased priority to make lint happy\ntheorem hasStrictFDerivAt_pi :\n    HasStrictFDerivAt (fun x i => Ï† i x) (ContinuousLinearMap.pi Ï†') x â†”\n      âˆ€ i, HasStrictFDerivAt (Ï† i) (Ï†' i) x :=\n  hasStrictFDerivAt_pi'\n\n"}
{"name":"hasFDerivAtFilter_pi'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\nL : Filter E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nÎ¦' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Î¹) â†’ F' i)\nâŠ¢ Iff (HasFDerivAtFilter Î¦ Î¦' x L) (âˆ€ (i : Î¹), HasFDerivAtFilter (fun x => Î¦ x i) ((ContinuousLinearMap.proj i).comp Î¦') x L)","decl":"@[simp]\ntheorem hasFDerivAtFilter_pi' :\n    HasFDerivAtFilter Î¦ Î¦' x L â†”\n      âˆ€ i, HasFDerivAtFilter (fun x => Î¦ x i) ((proj i).comp Î¦') x L := by\n  simp only [hasFDerivAtFilter_iff_isLittleO, ContinuousLinearMap.coe_pi]\n  exact isLittleO_pi\n\n"}
{"name":"hasFDerivAtFilter_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\nL : Filter E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÏ† : (i : Î¹) â†’ E â†’ F' i\nÏ†' : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) E (F' i)\nâŠ¢ Iff (HasFDerivAtFilter (fun x i => Ï† i x) (ContinuousLinearMap.pi Ï†') x L) (âˆ€ (i : Î¹), HasFDerivAtFilter (Ï† i) (Ï†' i) x L)","decl":"theorem hasFDerivAtFilter_pi :\n    HasFDerivAtFilter (fun x i => Ï† i x) (ContinuousLinearMap.pi Ï†') x L â†”\n      âˆ€ i, HasFDerivAtFilter (Ï† i) (Ï†' i) x L :=\n  hasFDerivAtFilter_pi'\n\n"}
{"name":"hasFDerivAt_pi'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nÎ¦' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Î¹) â†’ F' i)\nâŠ¢ Iff (HasFDerivAt Î¦ Î¦' x) (âˆ€ (i : Î¹), HasFDerivAt (fun x => Î¦ x i) ((ContinuousLinearMap.proj i).comp Î¦') x)","decl":"@[simp]\ntheorem hasFDerivAt_pi' :\n    HasFDerivAt Î¦ Î¦' x â†” âˆ€ i, HasFDerivAt (fun x => Î¦ x i) ((proj i).comp Î¦') x :=\n  hasFDerivAtFilter_pi'\n\n"}
{"name":"hasFDerivAt_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nÎ¦' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Î¹) â†’ F' i)\nhÏ† : âˆ€ (i : Î¹), HasFDerivAt (fun x => Î¦ x i) ((ContinuousLinearMap.proj i).comp Î¦') x\nâŠ¢ HasFDerivAt Î¦ Î¦' x","decl":"@[fun_prop]\ntheorem hasFDerivAt_pi'' (hÏ† : âˆ€ i, HasFDerivAt (fun x => Î¦ x i) ((proj i).comp Î¦') x) :\n    HasFDerivAt Î¦ Î¦' x := hasFDerivAt_pi'.2 hÏ†\n\n"}
{"name":"hasFDerivAt_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\ni : Î¹\nf : (i : Î¹) â†’ F' i\nâŠ¢ HasFDerivAt (fun f => f i) (ContinuousLinearMap.proj i) f","decl":"@[fun_prop]\ntheorem hasFDerivAt_apply (i : Î¹) (f : âˆ€ i, F' i) :\n    HasFDerivAt (ğ•œ := ğ•œ) (fun f : âˆ€ i, F' i => f i) (proj i) f := by\n  apply HasStrictFDerivAt.hasFDerivAt\n  apply hasStrictFDerivAt_apply\n\n"}
{"name":"hasFDerivAt_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÏ† : (i : Î¹) â†’ E â†’ F' i\nÏ†' : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) E (F' i)\nâŠ¢ Iff (HasFDerivAt (fun x i => Ï† i x) (ContinuousLinearMap.pi Ï†') x) (âˆ€ (i : Î¹), HasFDerivAt (Ï† i) (Ï†' i) x)","decl":"theorem hasFDerivAt_pi :\n    HasFDerivAt (fun x i => Ï† i x) (ContinuousLinearMap.pi Ï†') x â†”\n      âˆ€ i, HasFDerivAt (Ï† i) (Ï†' i) x :=\n  hasFDerivAtFilter_pi\n\n"}
{"name":"hasFDerivWithinAt_pi'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\ns : Set E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nÎ¦' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Î¹) â†’ F' i)\nâŠ¢ Iff (HasFDerivWithinAt Î¦ Î¦' s x) (âˆ€ (i : Î¹), HasFDerivWithinAt (fun x => Î¦ x i) ((ContinuousLinearMap.proj i).comp Î¦') s x)","decl":"@[simp]\ntheorem hasFDerivWithinAt_pi' :\n    HasFDerivWithinAt Î¦ Î¦' s x â†” âˆ€ i, HasFDerivWithinAt (fun x => Î¦ x i) ((proj i).comp Î¦') s x :=\n  hasFDerivAtFilter_pi'\n\n"}
{"name":"hasFDerivWithinAt_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\ns : Set E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nÎ¦' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Î¹) â†’ F' i)\nhÏ† : âˆ€ (i : Î¹), HasFDerivWithinAt (fun x => Î¦ x i) ((ContinuousLinearMap.proj i).comp Î¦') s x\nâŠ¢ HasFDerivWithinAt Î¦ Î¦' s x","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_pi''\n    (hÏ† : âˆ€ i, HasFDerivWithinAt (fun x => Î¦ x i) ((proj i).comp Î¦') s x) :\n    HasFDerivWithinAt Î¦ Î¦' s x := hasFDerivWithinAt_pi'.2 hÏ†\n\n"}
{"name":"hasFDerivWithinAt_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\ni : Î¹\nf : (i : Î¹) â†’ F' i\ns' : Set ((i : Î¹) â†’ F' i)\nâŠ¢ HasFDerivWithinAt (fun f => f i) (ContinuousLinearMap.proj i) s' f","decl":"@[fun_prop]\ntheorem hasFDerivWithinAt_apply (i : Î¹) (f : âˆ€ i, F' i) (s' : Set (âˆ€ i, F' i)) :\n    HasFDerivWithinAt (ğ•œ := ğ•œ) (fun f : âˆ€ i, F' i => f i) (proj i) s' f := by\n  let id' := ContinuousLinearMap.id ğ•œ (âˆ€ i, F' i)\n  have h := ((hasFDerivWithinAt_pi'\n             (Î¦ := fun (f : âˆ€ i, F' i) (i' : Î¹) => f i') (Î¦' := id') (x := f) (s := s'))).1\n  have h' : comp (proj i) id' = proj i := by rfl\n  rw [â† h']; apply h; apply hasFDerivWithinAt_id\n\n"}
{"name":"hasFDerivWithinAt_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\ns : Set E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÏ† : (i : Î¹) â†’ E â†’ F' i\nÏ†' : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) E (F' i)\nâŠ¢ Iff (HasFDerivWithinAt (fun x i => Ï† i x) (ContinuousLinearMap.pi Ï†') s x) (âˆ€ (i : Î¹), HasFDerivWithinAt (Ï† i) (Ï†' i) s x)","decl":"theorem hasFDerivWithinAt_pi :\n    HasFDerivWithinAt (fun x i => Ï† i x) (ContinuousLinearMap.pi Ï†') s x â†”\n      âˆ€ i, HasFDerivWithinAt (Ï† i) (Ï†' i) s x :=\n  hasFDerivAtFilter_pi\n\n"}
{"name":"differentiableWithinAt_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\ns : Set E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ Î¦ s x) (âˆ€ (i : Î¹), DifferentiableWithinAt ğ•œ (fun x => Î¦ x i) s x)","decl":"@[simp]\ntheorem differentiableWithinAt_pi :\n    DifferentiableWithinAt ğ•œ Î¦ s x â†” âˆ€ i, DifferentiableWithinAt ğ•œ (fun x => Î¦ x i) s x :=\n  âŸ¨fun h i => (hasFDerivWithinAt_pi'.1 h.hasFDerivWithinAt i).differentiableWithinAt, fun h =>\n    (hasFDerivWithinAt_pi.2 fun i => (h i).hasFDerivWithinAt).differentiableWithinAtâŸ©\n\n"}
{"name":"differentiableWithinAt_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\ns : Set E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nhÏ† : âˆ€ (i : Î¹), DifferentiableWithinAt ğ•œ (fun x => Î¦ x i) s x\nâŠ¢ DifferentiableWithinAt ğ•œ Î¦ s x","decl":"@[fun_prop]\ntheorem differentiableWithinAt_pi'' (hÏ† : âˆ€ i, DifferentiableWithinAt ğ•œ (fun x => Î¦ x i) s x) :\n    DifferentiableWithinAt ğ•œ Î¦ s x := differentiableWithinAt_pi.2 hÏ†\n\n"}
{"name":"differentiableWithinAt_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\ni : Î¹\nf : (i : Î¹) â†’ F' i\ns' : Set ((i : Î¹) â†’ F' i)\nâŠ¢ DifferentiableWithinAt ğ•œ (fun f => f i) s' f","decl":"@[fun_prop]\ntheorem differentiableWithinAt_apply (i : Î¹) (f : âˆ€ i, F' i) (s' : Set (âˆ€ i, F' i)) :\n    DifferentiableWithinAt (ğ•œ := ğ•œ) (fun f : âˆ€ i, F' i => f i) s' f := by\n  apply HasFDerivWithinAt.differentiableWithinAt\n  fun_prop\n\n"}
{"name":"differentiableAt_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nâŠ¢ Iff (DifferentiableAt ğ•œ Î¦ x) (âˆ€ (i : Î¹), DifferentiableAt ğ•œ (fun x => Î¦ x i) x)","decl":"@[simp]\ntheorem differentiableAt_pi : DifferentiableAt ğ•œ Î¦ x â†” âˆ€ i, DifferentiableAt ğ•œ (fun x => Î¦ x i) x :=\n  âŸ¨fun h i => (hasFDerivAt_pi'.1 h.hasFDerivAt i).differentiableAt, fun h =>\n    (hasFDerivAt_pi.2 fun i => (h i).hasFDerivAt).differentiableAtâŸ©\n\n"}
{"name":"differentiableAt_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nhÏ† : âˆ€ (i : Î¹), DifferentiableAt ğ•œ (fun x => Î¦ x i) x\nâŠ¢ DifferentiableAt ğ•œ Î¦ x","decl":"@[fun_prop]\ntheorem differentiableAt_pi'' (hÏ† : âˆ€ i, DifferentiableAt ğ•œ (fun x => Î¦ x i) x) :\n    DifferentiableAt ğ•œ Î¦ x := differentiableAt_pi.2 hÏ†\n\n"}
{"name":"differentiableAt_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\ni : Î¹\nf : (i : Î¹) â†’ F' i\nâŠ¢ DifferentiableAt ğ•œ (fun f => f i) f","decl":"@[fun_prop]\ntheorem differentiableAt_apply (i : Î¹) (f : âˆ€ i, F' i) :\n    DifferentiableAt (ğ•œ := ğ•œ) (fun f : âˆ€ i, F' i => f i) f := by\n  have h := ((differentiableAt_pi (ğ•œ := ğ•œ)\n             (Î¦ := fun (f : âˆ€ i, F' i) (i' : Î¹) => f i') (x := f))).1\n  apply h; apply differentiableAt_id\n\n"}
{"name":"differentiableOn_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ns : Set E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nâŠ¢ Iff (DifferentiableOn ğ•œ Î¦ s) (âˆ€ (i : Î¹), DifferentiableOn ğ•œ (fun x => Î¦ x i) s)","decl":"theorem differentiableOn_pi : DifferentiableOn ğ•œ Î¦ s â†” âˆ€ i, DifferentiableOn ğ•œ (fun x => Î¦ x i) s :=\n  âŸ¨fun h i x hx => differentiableWithinAt_pi.1 (h x hx) i, fun h x hx =>\n    differentiableWithinAt_pi.2 fun i => h i x hxâŸ©\n\n"}
{"name":"differentiableOn_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ns : Set E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nhÏ† : âˆ€ (i : Î¹), DifferentiableOn ğ•œ (fun x => Î¦ x i) s\nâŠ¢ DifferentiableOn ğ•œ Î¦ s","decl":"@[fun_prop]\ntheorem differentiableOn_pi'' (hÏ† : âˆ€ i, DifferentiableOn ğ•œ (fun x => Î¦ x i) s) :\n    DifferentiableOn ğ•œ Î¦ s := differentiableOn_pi.2 hÏ†\n\n"}
{"name":"differentiableOn_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\ni : Î¹\ns' : Set ((i : Î¹) â†’ F' i)\nâŠ¢ DifferentiableOn ğ•œ (fun f => f i) s'","decl":"@[fun_prop]\ntheorem differentiableOn_apply (i : Î¹) (s' : Set (âˆ€ i, F' i)) :\n    DifferentiableOn (ğ•œ := ğ•œ) (fun f : âˆ€ i, F' i => f i) s' := by\n  have h := ((differentiableOn_pi (ğ•œ := ğ•œ)\n             (Î¦ := fun (f : âˆ€ i, F' i) (i' : Î¹) => f i') (s := s'))).1\n  apply h; apply differentiableOn_id\n\n"}
{"name":"differentiable_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nâŠ¢ Iff (Differentiable ğ•œ Î¦) (âˆ€ (i : Î¹), Differentiable ğ•œ fun x => Î¦ x i)","decl":"theorem differentiable_pi : Differentiable ğ•œ Î¦ â†” âˆ€ i, Differentiable ğ•œ fun x => Î¦ x i :=\n  âŸ¨fun h i x => differentiableAt_pi.1 (h x) i, fun h x => differentiableAt_pi.2 fun i => h i xâŸ©\n\n"}
{"name":"differentiable_pi''","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nhÏ† : âˆ€ (i : Î¹), Differentiable ğ•œ fun x => Î¦ x i\nâŠ¢ Differentiable ğ•œ Î¦","decl":"@[fun_prop]\ntheorem differentiable_pi'' (hÏ† : âˆ€ i, Differentiable ğ•œ fun x => Î¦ x i) :\n    Differentiable ğ•œ Î¦ := differentiable_pi.2 hÏ†\n\n"}
{"name":"differentiable_apply","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\ni : Î¹\nâŠ¢ Differentiable ğ•œ fun f => f i","decl":"@[fun_prop]\ntheorem differentiable_apply (i : Î¹) :\n    Differentiable (ğ•œ := ğ•œ) (fun f : âˆ€ i, F' i => f i) := by intro x; apply differentiableAt_apply\n\n-- TODO: find out which version (`Ï†` or `Î¦`) works better with `rw`/`simp`\n"}
{"name":"fderivWithin_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\ns : Set E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÏ† : (i : Î¹) â†’ E â†’ F' i\nh : âˆ€ (i : Î¹), DifferentiableWithinAt ğ•œ (Ï† i) s x\nhs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun x i => Ï† i x) s x) (ContinuousLinearMap.pi fun i => fderivWithin ğ•œ (Ï† i) s x)","decl":"theorem fderivWithin_pi (h : âˆ€ i, DifferentiableWithinAt ğ•œ (Ï† i) s x)\n    (hs : UniqueDiffWithinAt ğ•œ s x) :\n    fderivWithin ğ•œ (fun x i => Ï† i x) s x = pi fun i => fderivWithin ğ•œ (Ï† i) s x :=\n  (hasFDerivWithinAt_pi.2 fun i => (h i).hasFDerivWithinAt).fderivWithin hs\n\n"}
{"name":"fderiv_pi","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÏ† : (i : Î¹) â†’ E â†’ F' i\nh : âˆ€ (i : Î¹), DifferentiableAt ğ•œ (Ï† i) x\nâŠ¢ Eq (fderiv ğ•œ (fun x i => Ï† i x) x) (ContinuousLinearMap.pi fun i => fderiv ğ•œ (Ï† i) x)","decl":"theorem fderiv_pi (h : âˆ€ i, DifferentiableAt ğ•œ (Ï† i) x) :\n    fderiv ğ•œ (fun x i => Ï† i x) x = pi fun i => fderiv ğ•œ (Ï† i) x :=\n  (hasFDerivAt_pi.2 fun i => (h i).hasFDerivAt).fderiv\n\n"}
{"name":"hasStrictFDerivAt_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Fin n.succ) â†’ F' i)\nâŠ¢ Iff (HasStrictFDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' x) (And (HasStrictFDerivAt Ï† ((ContinuousLinearMap.proj 0).comp Ï†') x) (HasStrictFDerivAt Ï†s ((Pi.compRightL ğ•œ F' Fin.succ).comp Ï†') x))","decl":"theorem hasStrictFDerivAt_finCons {Ï†' : E â†’L[ğ•œ] Î  i, F' i} :\n    HasStrictFDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' x â†”\n      HasStrictFDerivAt Ï† (.proj 0 âˆ˜L Ï†') x âˆ§\n      HasStrictFDerivAt Ï†s (Pi.compRightL ğ•œ F' Fin.succ âˆ˜L Ï†') x := by\n  rw [hasStrictFDerivAt_pi', Fin.forall_fin_succ, hasStrictFDerivAt_pi']\n  dsimp [ContinuousLinearMap.comp, LinearMap.comp, Function.comp_def]\n  simp only [Fin.cons_zero, Fin.cons_succ]\n\n"}
{"name":"hasStrictFDerivAt_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : ContinuousLinearMap (RingHom.id ğ•œ) E (F' 0)\nÏ†s' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Fin n) â†’ F' i.succ)\nâŠ¢ Iff (HasStrictFDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') x) (And (HasStrictFDerivAt Ï† Ï†' x) (HasStrictFDerivAt Ï†s Ï†s' x))","decl":"/-- A variant of `hasStrictFDerivAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasStrictFDerivAt_finCons'\n    {Ï†' : E â†’L[ğ•œ] F' 0} {Ï†s' : E â†’L[ğ•œ] Î  i, F' (Fin.succ i)} :\n    HasStrictFDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') x â†”\n      HasStrictFDerivAt Ï† Ï†' x âˆ§ HasStrictFDerivAt Ï†s Ï†s' x :=\n  hasStrictFDerivAt_finCons\n\n"}
{"name":"HasStrictFDerivAt.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : ContinuousLinearMap (RingHom.id ğ•œ) E (F' 0)\nÏ†s' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Fin n) â†’ F' i.succ)\nh : HasStrictFDerivAt Ï† Ï†' x\nhs : HasStrictFDerivAt Ï†s Ï†s' x\nâŠ¢ HasStrictFDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') x","decl":"@[fun_prop]\ntheorem HasStrictFDerivAt.finCons\n    {Ï†' : E â†’L[ğ•œ] F' 0} {Ï†s' : E â†’L[ğ•œ] Î  i, F' (Fin.succ i)}\n    (h : HasStrictFDerivAt Ï† Ï†' x) (hs : HasStrictFDerivAt Ï†s Ï†s' x) :\n    HasStrictFDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') x :=\n  hasStrictFDerivAt_finCons'.mpr âŸ¨h, hsâŸ©\n\n"}
{"name":"hasFDerivAtFilter_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Fin n.succ) â†’ F' i)\nl : Filter E\nâŠ¢ Iff (HasFDerivAtFilter (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' x l) (And (HasFDerivAtFilter Ï† ((ContinuousLinearMap.proj 0).comp Ï†') x l) (HasFDerivAtFilter Ï†s ((Pi.compRightL ğ•œ F' Fin.succ).comp Ï†') x l))","decl":"theorem hasFDerivAtFilter_finCons\n    {Ï†' : E â†’L[ğ•œ] Î  i, F' i} {l : Filter E} :\n    HasFDerivAtFilter (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' x l â†”\n      HasFDerivAtFilter Ï† (.proj 0 âˆ˜L Ï†') x l âˆ§\n      HasFDerivAtFilter Ï†s (Pi.compRightL ğ•œ F' Fin.succ âˆ˜L Ï†') x l := by\n  rw [hasFDerivAtFilter_pi', Fin.forall_fin_succ, hasFDerivAtFilter_pi']\n  dsimp [ContinuousLinearMap.comp, LinearMap.comp, Function.comp_def]\n  simp only [Fin.cons_zero, Fin.cons_succ]\n\n"}
{"name":"hasFDerivAtFilter_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : ContinuousLinearMap (RingHom.id ğ•œ) E (F' 0)\nÏ†s' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Fin n) â†’ F' i.succ)\nl : Filter E\nâŠ¢ Iff (HasFDerivAtFilter (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') x l) (And (HasFDerivAtFilter Ï† Ï†' x l) (HasFDerivAtFilter Ï†s Ï†s' x l))","decl":"/-- A variant of `hasFDerivAtFilter_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasFDerivAtFilter_finCons'\n    {Ï†' : E â†’L[ğ•œ] F' 0} {Ï†s' : E â†’L[ğ•œ] Î  i, F' (Fin.succ i)} {l : Filter E} :\n    HasFDerivAtFilter (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') x l â†”\n      HasFDerivAtFilter Ï† Ï†' x l âˆ§ HasFDerivAtFilter Ï†s Ï†s' x l :=\n  hasFDerivAtFilter_finCons\n\n"}
{"name":"HasFDerivAtFilter.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : ContinuousLinearMap (RingHom.id ğ•œ) E (F' 0)\nÏ†s' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Fin n) â†’ F' i.succ)\nl : Filter E\nh : HasFDerivAtFilter Ï† Ï†' x l\nhs : HasFDerivAtFilter Ï†s Ï†s' x l\nâŠ¢ HasFDerivAtFilter (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') x l","decl":"theorem HasFDerivAtFilter.finCons\n    {Ï†' : E â†’L[ğ•œ] F' 0} {Ï†s' : E â†’L[ğ•œ] Î  i, F' (Fin.succ i)} {l : Filter E}\n    (h : HasFDerivAtFilter Ï† Ï†' x l) (hs : HasFDerivAtFilter Ï†s Ï†s' x l) :\n    HasFDerivAtFilter (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') x l :=\n  hasFDerivAtFilter_finCons'.mpr âŸ¨h, hsâŸ©\n\n"}
{"name":"hasFDerivAt_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Fin n.succ) â†’ F' i)\nâŠ¢ Iff (HasFDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' x) (And (HasFDerivAt Ï† ((ContinuousLinearMap.proj 0).comp Ï†') x) (HasFDerivAt Ï†s ((Pi.compRightL ğ•œ F' Fin.succ).comp Ï†') x))","decl":"theorem hasFDerivAt_finCons\n    {Ï†' : E â†’L[ğ•œ] Î  i, F' i} :\n    HasFDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' x â†”\n      HasFDerivAt Ï† (.proj 0 âˆ˜L Ï†') x âˆ§ HasFDerivAt Ï†s (Pi.compRightL ğ•œ F' Fin.succ âˆ˜L Ï†') x :=\n  hasFDerivAtFilter_finCons\n\n"}
{"name":"hasFDerivAt_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : ContinuousLinearMap (RingHom.id ğ•œ) E (F' 0)\nÏ†s' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Fin n) â†’ F' i.succ)\nâŠ¢ Iff (HasFDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') x) (And (HasFDerivAt Ï† Ï†' x) (HasFDerivAt Ï†s Ï†s' x))","decl":"/-- A variant of `hasFDerivAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasFDerivAt_finCons'\n    {Ï†' : E â†’L[ğ•œ] F' 0} {Ï†s' : E â†’L[ğ•œ] Î  i, F' (Fin.succ i)} :\n    HasFDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') x â†”\n      HasFDerivAt Ï† Ï†' x âˆ§ HasFDerivAt Ï†s Ï†s' x :=\n  hasFDerivAt_finCons\n\n"}
{"name":"HasFDerivAt.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : ContinuousLinearMap (RingHom.id ğ•œ) E (F' 0)\nÏ†s' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Fin n) â†’ F' i.succ)\nh : HasFDerivAt Ï† Ï†' x\nhs : HasFDerivAt Ï†s Ï†s' x\nâŠ¢ HasFDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') x","decl":"@[fun_prop]\ntheorem HasFDerivAt.finCons\n    {Ï†' : E â†’L[ğ•œ] F' 0} {Ï†s' : E â†’L[ğ•œ] Î  i, F' (Fin.succ i)}\n    (h : HasFDerivAt Ï† Ï†' x) (hs : HasFDerivAt Ï†s Ï†s' x) :\n    HasFDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') x :=\n  hasFDerivAt_finCons'.mpr âŸ¨h, hsâŸ©\n\n"}
{"name":"hasFDerivWithinAt_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Fin n.succ) â†’ F' i)\nâŠ¢ Iff (HasFDerivWithinAt (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' s x) (And (HasFDerivWithinAt Ï† ((ContinuousLinearMap.proj 0).comp Ï†') s x) (HasFDerivWithinAt Ï†s ((Pi.compRightL ğ•œ F' Fin.succ).comp Ï†') s x))","decl":"theorem hasFDerivWithinAt_finCons\n    {Ï†' : E â†’L[ğ•œ] Î  i, F' i} :\n    HasFDerivWithinAt (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' s x â†”\n      HasFDerivWithinAt Ï† (.proj 0 âˆ˜L Ï†') s x âˆ§\n      HasFDerivWithinAt Ï†s (Pi.compRightL ğ•œ F' Fin.succ âˆ˜L Ï†') s x :=\n  hasFDerivAtFilter_finCons\n\n"}
{"name":"hasFDerivWithinAt_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : ContinuousLinearMap (RingHom.id ğ•œ) E (F' 0)\nÏ†s' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Fin n) â†’ F' i.succ)\nâŠ¢ Iff (HasFDerivWithinAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') s x) (And (HasFDerivWithinAt Ï† Ï†' s x) (HasFDerivWithinAt Ï†s Ï†s' s x))","decl":"/-- A variant of `hasFDerivWithinAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasFDerivWithinAt_finCons'\n    {Ï†' : E â†’L[ğ•œ] F' 0} {Ï†s' : E â†’L[ğ•œ] Î  i, F' (Fin.succ i)} :\n    HasFDerivWithinAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') s x â†”\n      HasFDerivWithinAt Ï† Ï†' s x âˆ§ HasFDerivWithinAt Ï†s Ï†s' s x :=\n  hasFDerivAtFilter_finCons\n\n"}
{"name":"HasFDerivWithinAt.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : ContinuousLinearMap (RingHom.id ğ•œ) E (F' 0)\nÏ†s' : ContinuousLinearMap (RingHom.id ğ•œ) E ((i : Fin n) â†’ F' i.succ)\nh : HasFDerivWithinAt Ï† Ï†' s x\nhs : HasFDerivWithinAt Ï†s Ï†s' s x\nâŠ¢ HasFDerivWithinAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') s x","decl":"@[fun_prop]\ntheorem HasFDerivWithinAt.finCons\n    {Ï†' : E â†’L[ğ•œ] F' 0} {Ï†s' : E â†’L[ğ•œ] Î  i, F' (Fin.succ i)}\n    (h : HasFDerivWithinAt Ï† Ï†' s x) (hs : HasFDerivWithinAt Ï†s Ï†s' s x) :\n    HasFDerivWithinAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Ï†'.finCons Ï†s') s x :=\n  hasFDerivWithinAt_finCons'.mpr âŸ¨h, hsâŸ©\n\n"}
{"name":"differentiableWithinAt_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) s x) (And (DifferentiableWithinAt ğ•œ Ï† s x) (DifferentiableWithinAt ğ•œ Ï†s s x))","decl":"theorem differentiableWithinAt_finCons :\n    DifferentiableWithinAt ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) s x â†”\n      DifferentiableWithinAt ğ•œ Ï† s x âˆ§ DifferentiableWithinAt ğ•œ Ï†s s x := by\n  rw [differentiableWithinAt_pi, Fin.forall_fin_succ, differentiableWithinAt_pi]\n  simp only [Fin.cons_zero, Fin.cons_succ]\n\n"}
{"name":"differentiableWithinAt_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) s x) (And (DifferentiableWithinAt ğ•œ Ï† s x) (DifferentiableWithinAt ğ•œ Ï†s s x))","decl":"/-- A variant of `differentiableWithinAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem differentiableWithinAt_finCons' :\n    DifferentiableWithinAt ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) s x â†”\n      DifferentiableWithinAt ğ•œ Ï† s x âˆ§ DifferentiableWithinAt ğ•œ Ï†s s x :=\n  differentiableWithinAt_finCons\n\n"}
{"name":"DifferentiableWithinAt.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\ns : Set E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nh : DifferentiableWithinAt ğ•œ Ï† s x\nhs : DifferentiableWithinAt ğ•œ Ï†s s x\nâŠ¢ DifferentiableWithinAt ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) s x","decl":"@[fun_prop]\ntheorem DifferentiableWithinAt.finCons\n    (h : DifferentiableWithinAt ğ•œ Ï† s x) (hs : DifferentiableWithinAt ğ•œ Ï†s s x) :\n    DifferentiableWithinAt ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) s x :=\n  differentiableWithinAt_finCons'.mpr âŸ¨h, hsâŸ©\n\n"}
{"name":"differentiableAt_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nâŠ¢ Iff (DifferentiableAt ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) x) (And (DifferentiableAt ğ•œ Ï† x) (DifferentiableAt ğ•œ Ï†s x))","decl":"theorem differentiableAt_finCons :\n    DifferentiableAt ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) x â†”\n      DifferentiableAt ğ•œ Ï† x âˆ§ DifferentiableAt ğ•œ Ï†s x := by\n  rw [differentiableAt_pi, Fin.forall_fin_succ, differentiableAt_pi]\n  simp only [Fin.cons_zero, Fin.cons_succ]\n\n"}
{"name":"differentiableAt_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nâŠ¢ Iff (DifferentiableAt ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) x) (And (DifferentiableAt ğ•œ Ï† x) (DifferentiableAt ğ•œ Ï†s x))","decl":"/-- A variant of `differentiableAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem differentiableAt_finCons' :\n    DifferentiableAt ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) x â†”\n      DifferentiableAt ğ•œ Ï† x âˆ§ DifferentiableAt ğ•œ Ï†s x :=\n  differentiableAt_finCons\n\n"}
{"name":"DifferentiableAt.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nh : DifferentiableAt ğ•œ Ï† x\nhs : DifferentiableAt ğ•œ Ï†s x\nâŠ¢ DifferentiableAt ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) x","decl":"@[fun_prop]\ntheorem DifferentiableAt.finCons\n    (h : DifferentiableAt ğ•œ Ï† x) (hs : DifferentiableAt ğ•œ Ï†s x) :\n    DifferentiableAt ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) x :=\n  differentiableAt_finCons'.mpr âŸ¨h, hsâŸ©\n\n"}
{"name":"differentiableOn_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nâŠ¢ Iff (DifferentiableOn ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) s) (And (DifferentiableOn ğ•œ Ï† s) (DifferentiableOn ğ•œ Ï†s s))","decl":"theorem differentiableOn_finCons :\n    DifferentiableOn ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) s â†”\n      DifferentiableOn ğ•œ Ï† s âˆ§ DifferentiableOn ğ•œ Ï†s s := by\n  rw [differentiableOn_pi, Fin.forall_fin_succ, differentiableOn_pi]\n  simp only [Fin.cons_zero, Fin.cons_succ]\n\n"}
{"name":"differentiableOn_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nâŠ¢ Iff (DifferentiableOn ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) s) (And (DifferentiableOn ğ•œ Ï† s) (DifferentiableOn ğ•œ Ï†s s))","decl":"/-- A variant of `differentiableOn_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem differentiableOn_finCons' :\n    DifferentiableOn ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) s â†”\n      DifferentiableOn ğ•œ Ï† s âˆ§ DifferentiableOn ğ•œ Ï†s s :=\n  differentiableOn_finCons\n\n"}
{"name":"DifferentiableOn.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nh : DifferentiableOn ğ•œ Ï† s\nhs : DifferentiableOn ğ•œ Ï†s s\nâŠ¢ DifferentiableOn ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.finCons\n    (h : DifferentiableOn ğ•œ Ï† s) (hs : DifferentiableOn ğ•œ Ï†s s) :\n    DifferentiableOn ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) s :=\n  differentiableOn_finCons'.mpr âŸ¨h, hsâŸ©\n\n"}
{"name":"differentiable_finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nâŠ¢ Iff (Differentiable ğ•œ fun x => Fin.cons (Ï† x) (Ï†s x)) (And (Differentiable ğ•œ Ï†) (Differentiable ğ•œ Ï†s))","decl":"theorem differentiable_finCons :\n    Differentiable ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) â†”\n      Differentiable ğ•œ Ï† âˆ§ Differentiable ğ•œ Ï†s := by\n  rw [differentiable_pi, Fin.forall_fin_succ, differentiable_pi]\n  simp only [Fin.cons_zero, Fin.cons_succ]\n\n"}
{"name":"differentiable_finCons'","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nâŠ¢ Iff (Differentiable ğ•œ fun x => Fin.cons (Ï† x) (Ï†s x)) (And (Differentiable ğ•œ Ï†) (Differentiable ğ•œ Ï†s))","decl":"/-- A variant of `differentiable_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem differentiable_finCons' :\n    Differentiable ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) â†”\n      Differentiable ğ•œ Ï† âˆ§ Differentiable ğ•œ Ï†s :=\n  differentiable_finCons\n\n"}
{"name":"Differentiable.finCons","module":"Mathlib.Analysis.Calculus.FDeriv.Prod","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nn : Nat\nF' : Fin n.succ â†’ Type u_6\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)\nÏ† : E â†’ F' 0\nÏ†s : E â†’ (i : Fin n) â†’ F' i.succ\nh : Differentiable ğ•œ Ï†\nhs : Differentiable ğ•œ Ï†s\nâŠ¢ Differentiable ğ•œ fun x => Fin.cons (Ï† x) (Ï†s x)","decl":"@[fun_prop]\ntheorem Differentiable.finCons\n    (h : Differentiable ğ•œ Ï†) (hs : Differentiable ğ•œ Ï†s) :\n    Differentiable ğ•œ (fun x => Fin.cons (Ï† x) (Ï†s x)) :=\n  differentiable_finCons'.mpr âŸ¨h, hsâŸ©\n\n-- TODO: write the `Fin.cons` versions of `fderivWithin_pi` and `fderiv_pi`\n\n"}
