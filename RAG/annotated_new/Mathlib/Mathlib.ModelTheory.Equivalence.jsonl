{"name":"FirstOrder.Language.Theory.Imp.refl","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ : L.BoundedFormula α n\n⊢ T.Imp φ φ","decl":"@[refl]\nprotected theorem refl (φ : L.BoundedFormula α n) : φ ⟹[T] φ := fun _ _ _ => id\n\n"}
{"name":"FirstOrder.Language.Theory.Imp.instIsReflBoundedFormula","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\n⊢ IsRefl (L.BoundedFormula α n) T.Imp","decl":"instance : IsRefl (L.BoundedFormula α n) T.Imp := ⟨Imp.refl⟩\n\n"}
{"name":"FirstOrder.Language.Theory.Imp.trans","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ θ : L.BoundedFormula α n\nh1 : T.Imp φ ψ\nh2 : T.Imp ψ θ\n⊢ T.Imp φ θ","decl":"@[trans]\nprotected theorem trans {φ ψ θ : L.BoundedFormula α n} (h1 : φ ⟹[T] ψ) (h2 : ψ ⟹[T] θ) :\n    φ ⟹[T] θ := fun M v xs => (h2 M v xs) ∘ (h1 M v xs)\n\n"}
{"name":"FirstOrder.Language.Theory.Imp.instIsTransBoundedFormula","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\n⊢ IsTrans (L.BoundedFormula α n) T.Imp","decl":"instance : IsTrans (L.BoundedFormula α n) T.Imp := ⟨fun _ _ _ => Imp.trans⟩\n\n"}
{"name":"FirstOrder.Language.Theory.bot_imp","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ : L.BoundedFormula α n\n⊢ T.Imp Bot.bot φ","decl":"lemma bot_imp (φ : L.BoundedFormula α n) : ⊥ ⟹[T] φ := fun M v xs => by\n  simp only [BoundedFormula.realize_imp, BoundedFormula.realize_bot, false_implies]\n\n"}
{"name":"FirstOrder.Language.Theory.imp_top","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ : L.BoundedFormula α n\n⊢ T.Imp φ Top.top","decl":"lemma imp_top (φ : L.BoundedFormula α n) : φ ⟹[T] ⊤ := fun M v xs => by\n  simp only [BoundedFormula.realize_imp, BoundedFormula.realize_top, implies_true]\n\n"}
{"name":"FirstOrder.Language.Theory.imp_sup_left","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α n\n⊢ T.Imp φ (Max.max φ ψ)","decl":"lemma imp_sup_left (φ ψ : L.BoundedFormula α n) : φ ⟹[T] φ ⊔ ψ := fun M v xs => by\n  simp only [BoundedFormula.realize_imp, BoundedFormula.realize_sup]\n  exact Or.inl\n\n"}
{"name":"FirstOrder.Language.Theory.imp_sup_right","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α n\n⊢ T.Imp ψ (Max.max φ ψ)","decl":"lemma imp_sup_right (φ ψ : L.BoundedFormula α n) : ψ ⟹[T] φ ⊔ ψ := fun M v xs => by\n  simp only [BoundedFormula.realize_imp, BoundedFormula.realize_sup]\n  exact Or.inr\n\n"}
{"name":"FirstOrder.Language.Theory.sup_imp","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ θ : L.BoundedFormula α n\nh₁ : T.Imp φ θ\nh₂ : T.Imp ψ θ\n⊢ T.Imp (Max.max φ ψ) θ","decl":"lemma sup_imp {φ ψ θ : L.BoundedFormula α n} (h₁ : φ ⟹[T] θ) (h₂ : ψ ⟹[T] θ) :\n    φ ⊔ ψ ⟹[T] θ := fun M v xs => by\n  simp only [BoundedFormula.realize_imp, BoundedFormula.realize_sup]\n  exact fun h => h.elim (h₁ M v xs) (h₂ M v xs)\n\n"}
{"name":"FirstOrder.Language.Theory.sup_imp_iff","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ θ : L.BoundedFormula α n\n⊢ Iff (T.Imp (Max.max φ ψ) θ) (And (T.Imp φ θ) (T.Imp ψ θ))","decl":"lemma sup_imp_iff {φ ψ θ : L.BoundedFormula α n} :\n    (φ ⊔ ψ ⟹[T] θ) ↔ (φ ⟹[T] θ) ∧ (ψ ⟹[T] θ) :=\n  ⟨fun h => ⟨(imp_sup_left _ _).trans h, (imp_sup_right _ _).trans h⟩,\n    fun ⟨h₁, h₂⟩ => sup_imp h₁ h₂⟩\n\n"}
{"name":"FirstOrder.Language.Theory.inf_imp_left","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α n\n⊢ T.Imp (Min.min φ ψ) φ","decl":"lemma inf_imp_left (φ ψ : L.BoundedFormula α n) : φ ⊓ ψ ⟹[T] φ := fun M v xs => by\n  simp only [BoundedFormula.realize_imp, BoundedFormula.realize_inf]\n  exact And.left\n\n"}
{"name":"FirstOrder.Language.Theory.inf_imp_right","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α n\n⊢ T.Imp (Min.min φ ψ) ψ","decl":"lemma inf_imp_right (φ ψ : L.BoundedFormula α n) : φ ⊓ ψ ⟹[T] ψ := fun M v xs => by\n  simp only [BoundedFormula.realize_imp, BoundedFormula.realize_inf]\n  exact And.right\n\n"}
{"name":"FirstOrder.Language.Theory.imp_inf","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ θ : L.BoundedFormula α n\nh₁ : T.Imp φ ψ\nh₂ : T.Imp φ θ\n⊢ T.Imp φ (Min.min ψ θ)","decl":"lemma imp_inf {φ ψ θ : L.BoundedFormula α n} (h₁ : φ ⟹[T] ψ) (h₂ : φ ⟹[T] θ) :\n    φ ⟹[T] ψ ⊓ θ := fun M v xs => by\n  simp only [BoundedFormula.realize_imp, BoundedFormula.realize_inf]\n  exact fun h => ⟨h₁ M v xs h, h₂ M v xs h⟩\n\n"}
{"name":"FirstOrder.Language.Theory.imp_inf_iff","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ θ : L.BoundedFormula α n\n⊢ Iff (T.Imp φ (Min.min ψ θ)) (And (T.Imp φ ψ) (T.Imp φ θ))","decl":"lemma imp_inf_iff {φ ψ θ : L.BoundedFormula α n} :\n    (φ ⟹[T] ψ ⊓ θ) ↔ (φ ⟹[T] ψ) ∧ (φ ⟹[T] θ) :=\n  ⟨fun h => ⟨h.trans (inf_imp_left _ _), h.trans (inf_imp_right _ _)⟩,\n    fun ⟨h₁, h₂⟩ => imp_inf h₁ h₂⟩\n\n"}
{"name":"FirstOrder.Language.Theory.iff_iff_imp_and_imp","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α n\n⊢ Iff (T.Iff φ ψ) (And (T.Imp φ ψ) (T.Imp ψ φ))","decl":"theorem iff_iff_imp_and_imp {φ ψ : L.BoundedFormula α n} :\n    (φ ⇔[T] ψ) ↔ (φ ⟹[T] ψ) ∧ (ψ ⟹[T] φ) := by\n  simp only [Theory.Imp, ModelsBoundedFormula, BoundedFormula.realize_imp, ← forall_and,\n    Theory.Iff, BoundedFormula.realize_iff, iff_iff_implies_and_implies]\n\n"}
{"name":"FirstOrder.Language.Theory.imp_antisymm","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α n\nh₁ : T.Imp φ ψ\nh₂ : T.Imp ψ φ\n⊢ T.Iff φ ψ","decl":"theorem imp_antisymm {φ ψ : L.BoundedFormula α n} (h₁ : φ ⟹[T] ψ) (h₂ : ψ ⟹[T] φ) :\n    φ ⇔[T] ψ :=\n  iff_iff_imp_and_imp.2 ⟨h₁, h₂⟩\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.mp","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α n\nh : T.Iff φ ψ\n⊢ T.Imp φ ψ","decl":"protected theorem mp {φ ψ : L.BoundedFormula α n} (h : φ ⇔[T] ψ) :\n    φ ⟹[T] ψ := (iff_iff_imp_and_imp.1 h).1\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.mpr","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α n\nh : T.Iff φ ψ\n⊢ T.Imp ψ φ","decl":"protected theorem mpr {φ ψ : L.BoundedFormula α n} (h : φ ⇔[T] ψ) :\n    ψ ⟹[T] φ := (iff_iff_imp_and_imp.1 h).2\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.refl","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ : L.BoundedFormula α n\n⊢ T.Iff φ φ","decl":"@[refl]\nprotected theorem refl (φ : L.BoundedFormula α n) : φ ⇔[T] φ :=\n  fun M v xs => by rw [BoundedFormula.realize_iff]\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.instIsReflBoundedFormula","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\n⊢ IsRefl (L.BoundedFormula α n) T.Iff","decl":"instance : IsRefl (L.BoundedFormula α n) T.Iff :=\n  ⟨Iff.refl⟩\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.symm","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α n\nh : T.Iff φ ψ\n⊢ T.Iff ψ φ","decl":"@[symm]\nprotected theorem symm {φ ψ : L.BoundedFormula α n}\n    (h : φ ⇔[T] ψ) : ψ ⇔[T] φ := fun M v xs => by\n  rw [BoundedFormula.realize_iff, Iff.comm, ← BoundedFormula.realize_iff]\n  exact h M v xs\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.instIsSymmBoundedFormula","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\n⊢ IsSymm (L.BoundedFormula α n) T.Iff","decl":"instance : IsSymm (L.BoundedFormula α n) T.Iff :=\n  ⟨fun _ _ => Iff.symm⟩\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.trans","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ θ : L.BoundedFormula α n\nh1 : T.Iff φ ψ\nh2 : T.Iff ψ θ\n⊢ T.Iff φ θ","decl":"@[trans]\nprotected theorem trans {φ ψ θ : L.BoundedFormula α n}\n    (h1 : φ ⇔[T] ψ) (h2 : ψ ⇔[T] θ) :\n    φ ⇔[T] θ := fun M v xs => by\n  have h1' := h1 M v xs\n  have h2' := h2 M v xs\n  rw [BoundedFormula.realize_iff] at *\n  exact ⟨h2'.1 ∘ h1'.1, h1'.2 ∘ h2'.2⟩\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.instIsTransBoundedFormula","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\n⊢ IsTrans (L.BoundedFormula α n) T.Iff","decl":"instance : IsTrans (L.BoundedFormula α n) T.Iff :=\n  ⟨fun _ _ _ => Iff.trans⟩\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.realize_bd_iff","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nM : Type u_1\ninst✝² : Nonempty M\ninst✝¹ : L.Structure M\ninst✝ : FirstOrder.Language.Theory.Model M T\nφ ψ : L.BoundedFormula α n\nh : T.Iff φ ψ\nv : α → M\nxs : Fin n → M\n⊢ Iff (φ.Realize v xs) (ψ.Realize v xs)","decl":"theorem realize_bd_iff {φ ψ : L.BoundedFormula α n} (h : φ ⇔[T] ψ)\n    {v : α → M} {xs : Fin n → M} : φ.Realize v xs ↔ ψ.Realize v xs :=\n  BoundedFormula.realize_iff.1 (h.realize_boundedFormula M)\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.realize_iff","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nφ ψ : L.Formula α\nM : Type u_2\ninst✝² : Nonempty M\ninst✝¹ : L.Structure M\ninst✝ : FirstOrder.Language.Theory.Model M T\nh : T.Iff φ ψ\nv : α → M\n⊢ Iff (φ.Realize v) (ψ.Realize v)","decl":"theorem realize_iff {φ ψ : L.Formula α} {M : Type*} [Nonempty M]\n    [L.Structure M] [M ⊨ T] (h : φ ⇔[T] ψ) {v : α → M} :\n    φ.Realize v ↔ ψ.Realize v :=\n  h.realize_bd_iff\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.models_sentence_iff","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nφ ψ : L.Sentence\nM : Type u_2\ninst✝² : Nonempty M\ninst✝¹ : L.Structure M\ninst✝ : FirstOrder.Language.Theory.Model M T\nh : T.Iff φ ψ\n⊢ Iff (FirstOrder.Language.Sentence.Realize M φ) (FirstOrder.Language.Sentence.Realize M ψ)","decl":"theorem models_sentence_iff {φ ψ : L.Sentence} {M : Type*} [Nonempty M]\n    [L.Structure M] [M ⊨ T] (h : φ ⇔[T] ψ) :\n    M ⊨ φ ↔ M ⊨ ψ :=\n  h.realize_iff\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.all","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α (HAdd.hAdd n 1)\nh : T.Iff φ ψ\n⊢ T.Iff φ.all ψ.all","decl":"protected theorem all {φ ψ : L.BoundedFormula α (n + 1)}\n    (h : φ ⇔[T] ψ) : φ.all ⇔[T] ψ.all := by\n  simp_rw [Theory.Iff, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_all]\n  exact fun M v xs => forall_congr' fun a => h.realize_bd_iff\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.ex","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α (HAdd.hAdd n 1)\nh : T.Iff φ ψ\n⊢ T.Iff φ.ex ψ.ex","decl":"protected theorem ex {φ ψ : L.BoundedFormula α (n + 1)} (h : φ ⇔[T] ψ) :\n    φ.ex ⇔[T] ψ.ex := by\n  simp_rw [Theory.Iff, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_ex]\n  exact fun M v xs => exists_congr fun a => h.realize_bd_iff\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.not","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α n\nh : T.Iff φ ψ\n⊢ T.Iff φ.not ψ.not","decl":"protected theorem not {φ ψ : L.BoundedFormula α n} (h : φ ⇔[T] ψ) :\n    φ.not ⇔[T] ψ.not := by\n  simp_rw [Theory.Iff, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_not]\n  exact fun M v xs => not_congr h.realize_bd_iff\n\n"}
{"name":"FirstOrder.Language.Theory.Iff.imp","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ φ' ψ' : L.BoundedFormula α n\nh : T.Iff φ ψ\nh' : T.Iff φ' ψ'\n⊢ T.Iff (φ.imp φ') (ψ.imp ψ')","decl":"protected theorem imp {φ ψ φ' ψ' : L.BoundedFormula α n} (h : φ ⇔[T] ψ) (h' : φ' ⇔[T] ψ') :\n    (φ.imp φ') ⇔[T] (ψ.imp ψ') := by\n  simp_rw [Theory.Iff, ModelsBoundedFormula, BoundedFormula.realize_iff,\n    BoundedFormula.realize_imp]\n  exact fun M v xs => imp_congr h.realize_bd_iff h'.realize_bd_iff\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.iff_not_not","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ : L.BoundedFormula α n\n⊢ T.Iff φ φ.not.not","decl":"theorem iff_not_not : φ ⇔[T] φ.not.not := fun M v xs => by\n  simp\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.imp_iff_not_sup","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α n\n⊢ T.Iff (φ.imp ψ) (Max.max φ.not ψ)","decl":"theorem imp_iff_not_sup : (φ.imp ψ) ⇔[T] (φ.not ⊔ ψ) :=\n  fun M v xs => by simp [imp_iff_not_or]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.sup_iff_not_inf_not","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α n\n⊢ T.Iff (Max.max φ ψ) (Min.min φ.not ψ.not).not","decl":"theorem sup_iff_not_inf_not : (φ ⊔ ψ) ⇔[T] (φ.not ⊓ ψ.not).not :=\n  fun M v xs => by simp [imp_iff_not_or]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.inf_iff_not_sup_not","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ ψ : L.BoundedFormula α n\n⊢ T.Iff (Min.min φ ψ) (Max.max φ.not ψ.not).not","decl":"theorem inf_iff_not_sup_not : (φ ⊓ ψ) ⇔[T] (φ.not ⊔ ψ.not).not :=\n  fun M v xs => by simp\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.all_iff_not_ex_not","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ : L.BoundedFormula α (HAdd.hAdd n 1)\n⊢ T.Iff φ.all φ.not.ex.not","decl":"theorem all_iff_not_ex_not (φ : L.BoundedFormula α (n + 1)) :\n    φ.all ⇔[T] φ.not.ex.not := fun M v xs => by simp\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.ex_iff_not_all_not","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ : L.BoundedFormula α (HAdd.hAdd n 1)\n⊢ T.Iff φ.ex φ.not.all.not","decl":"theorem ex_iff_not_all_not (φ : L.BoundedFormula α (n + 1)) :\n    φ.ex ⇔[T] φ.not.all.not := fun M v xs => by simp\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.iff_all_liftAt","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ : L.BoundedFormula α n\n⊢ T.Iff φ (FirstOrder.Language.BoundedFormula.liftAt 1 n φ).all","decl":"theorem iff_all_liftAt : φ ⇔[T] (φ.liftAt 1 n).all :=\n  fun M v xs => by\n  rw [realize_iff, realize_all_liftAt_one_self]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.inf_not_iff_bot","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ : L.BoundedFormula α n\n⊢ T.Iff (Min.min φ φ.not) Bot.bot","decl":"lemma inf_not_iff_bot :\n    φ ⊓ ∼φ ⇔[T] ⊥ := fun M v xs => by\n  simp only [realize_iff, realize_inf, realize_not, and_not_self, realize_bot]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.sup_not_iff_top","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nn : Nat\nφ : L.BoundedFormula α n\n⊢ T.Iff (Max.max φ φ.not) Top.top","decl":"lemma sup_not_iff_top :\n    φ ⊔ ∼φ ⇔[T] ⊤ := fun M v xs => by\n  simp only [realize_iff, realize_sup, realize_not, realize_top, iff_true, or_not]\n\n"}
{"name":"FirstOrder.Language.Formula.iff_not_not","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nφ : L.Formula α\n⊢ T.Iff φ φ.not.not","decl":"theorem iff_not_not : φ ⇔[T] φ.not.not :=\n  BoundedFormula.iff_not_not φ\n\n"}
{"name":"FirstOrder.Language.Formula.imp_iff_not_sup","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nφ ψ : L.Formula α\n⊢ T.Iff (φ.imp ψ) (Max.max φ.not ψ)","decl":"theorem imp_iff_not_sup : (φ.imp ψ) ⇔[T] (φ.not ⊔ ψ) :=\n  BoundedFormula.imp_iff_not_sup φ ψ\n\n"}
{"name":"FirstOrder.Language.Formula.sup_iff_not_inf_not","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nφ ψ : L.Formula α\n⊢ T.Iff (Max.max φ ψ) (Min.min φ.not ψ.not).not","decl":"theorem sup_iff_not_inf_not : (φ ⊔ ψ) ⇔[T] (φ.not ⊓ ψ.not).not :=\n  BoundedFormula.sup_iff_not_inf_not φ ψ\n\n"}
{"name":"FirstOrder.Language.Formula.inf_iff_not_sup_not","module":"Mathlib.ModelTheory.Equivalence","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nφ ψ : L.Formula α\n⊢ T.Iff (Min.min φ ψ) (Max.max φ.not ψ.not).not","decl":"theorem inf_iff_not_sup_not : (φ ⊓ ψ) ⇔[T] (φ.not ⊔ ψ.not).not :=\n  BoundedFormula.inf_iff_not_sup_not φ ψ\n\n"}
