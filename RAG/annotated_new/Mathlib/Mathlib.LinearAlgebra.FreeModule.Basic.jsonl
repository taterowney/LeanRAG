{"name":"Module.Free.exists_basis","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nself : Module.Free R M\n⊢ Nonempty (Sigma fun I => Basis I R M)","decl":"/-- `Module.Free R M` is the statement that the `R`-module `M` is free. -/\nclass Module.Free : Prop where\n  exists_basis : Nonempty <| (I : Type v) × Basis I R M\n\n"}
{"name":"Module.free_iff_set","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (Module.Free R M) (Exists fun S => Nonempty (Basis (↑S) R M))","decl":"theorem Module.free_iff_set : Module.Free R M ↔ ∃ S : Set M, Nonempty (Basis S R M) :=\n  ⟨fun h => ⟨Set.range h.exists_basis.some.2, ⟨Basis.reindexRange h.exists_basis.some.2⟩⟩,\n    fun ⟨S, hS⟩ => ⟨nonempty_sigma.2 ⟨S, hS⟩⟩⟩\n\n"}
{"name":"Module.free_def","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Small.{w, v} M\n⊢ Iff (Module.Free R M) (Exists fun I => Nonempty (Basis I R M))","decl":"/-- If `M` fits in universe `w`, then freeness is equivalent to existence of a basis in that\nuniverse.\n\nNote that if `M` does not fit in `w`, the reverse direction of this implication is still true as\n`Module.Free.of_basis`. -/\ntheorem Module.free_def [Small.{w,v} M] :\n    Module.Free R M ↔ ∃ I : Type w, Nonempty (Basis I R M) :=\n  ⟨fun h =>\n    ⟨Shrink (Set.range h.exists_basis.some.2),\n      ⟨(Basis.reindexRange h.exists_basis.some.2).reindex (equivShrink _)⟩⟩,\n    fun h => ⟨(nonempty_sigma.2 h).map fun ⟨_, b⟩ => ⟨Set.range b, b.reindexRange⟩⟩⟩\n\n"}
{"name":"Module.Free.of_basis","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type w\nb : Basis ι R M\n⊢ Module.Free R M","decl":"theorem Module.Free.of_basis {ι : Type w} (b : Basis ι R M) : Module.Free R M :=\n  (Module.free_def R M).2 ⟨Set.range b, ⟨b.reindexRange⟩⟩\n\n"}
{"name":"Module.Free.noZeroSMulDivisors","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : NoZeroDivisors R\n⊢ NoZeroSMulDivisors R M","decl":"instance (priority := 100) noZeroSMulDivisors [NoZeroDivisors R] : NoZeroSMulDivisors R M :=\n  let ⟨⟨_, b⟩⟩ := exists_basis (R := R) (M := M)\n  b.noZeroSMulDivisors\n\n"}
{"name":"Module.Free.instNonemptyChooseBasisIndexOfNontrivial","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Nontrivial M\n⊢ Nonempty (Module.Free.ChooseBasisIndex R M)","decl":"instance [Nontrivial M] : Nonempty (Module.Free.ChooseBasisIndex R M) :=\n  (Module.Free.chooseBasis R M).index_nonempty\n\n"}
{"name":"Module.Free.infinite","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Module.Free R M\ninst✝¹ : Infinite R\ninst✝ : Nontrivial M\n⊢ Infinite M","decl":"theorem infinite [Infinite R] [Nontrivial M] : Infinite M :=\n  (Equiv.infinite_iff (chooseBasis R M).repr.toEquiv).mpr Finsupp.infinite_of_right\n\n"}
{"name":"Module.Free.of_equiv","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type z\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Module.Free R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\ne : LinearEquiv (RingHom.id R) M N\n⊢ Module.Free R N","decl":"theorem of_equiv (e : M ≃ₗ[R] N) : Module.Free R N :=\n  of_basis <| (chooseBasis R M).map e\n\n"}
{"name":"Module.Free.of_equiv'","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nN : Type z\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\nP : Type v\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nx✝ : Module.Free R P\ne : LinearEquiv (RingHom.id R) P N\n⊢ Module.Free R N","decl":"/-- A variation of `of_equiv`: the assumption `Module.Free R P` here is explicit rather than an\ninstance. -/\ntheorem of_equiv' {P : Type v} [AddCommMonoid P] [Module R P] (_ : Module.Free R P)\n    (e : P ≃ₗ[R] N) : Module.Free R N :=\n  of_equiv e\n\n"}
{"name":"Module.Free.of_ringEquiv","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u_2\nR' : Type u_3\nM : Type u_4\nM' : Type u_5\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Semiring R'\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R' M'\ne₁ : RingEquiv R R'\ne₂ : LinearEquiv (↑e₁) M M'\ninst✝ : Module.Free R M\n⊢ Module.Free R' M'","decl":"attribute [local instance] RingHomInvPair.of_ringEquiv in\nlemma of_ringEquiv {R R' M M'} [Semiring R] [AddCommMonoid M] [Module R M]\n    [Semiring R'] [AddCommMonoid M'] [Module R' M']\n    (e₁ : R ≃+* R') (e₂ : M ≃ₛₗ[RingHomClass.toRingHom e₁] M') [Module.Free R M] :\n    Module.Free R' M' := by\n  let I := Module.Free.ChooseBasisIndex R M\n  obtain ⟨e₃ : M ≃ₗ[R] I →₀ R⟩ := Module.Free.chooseBasis R M\n  let e : M' ≃+ (I →₀ R') :=\n    (e₂.symm.trans e₃).toAddEquiv.trans (Finsupp.mapRange.addEquiv (α := I) e₁.toAddEquiv)\n  have he (x) : e x = Finsupp.mapRange.addEquiv (α := I) e₁.toAddEquiv (e₃ (e₂.symm x)) := rfl\n  let e' : M' ≃ₗ[R'] (I →₀ R') :=\n    { __ := e, map_smul' := fun m x ↦ Finsupp.ext fun i ↦ by simp [he, map_smulₛₗ] }\n  exact of_basis (.ofRepr e')\n\n"}
{"name":"Module.Free.iff_of_ringEquiv","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u_2\nR' : Type u_3\nM : Type u_4\nM' : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Semiring R'\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R' M'\ne₁ : RingEquiv R R'\ne₂ : LinearEquiv (↑e₁) M M'\n⊢ Iff (Module.Free R M) (Module.Free R' M')","decl":"attribute [local instance] RingHomInvPair.of_ringEquiv in\nlemma iff_of_ringEquiv {R R' M M'} [Semiring R] [AddCommMonoid M] [Module R M]\n    [Semiring R'] [AddCommMonoid M'] [Module R' M']\n    (e₁ : R ≃+* R') (e₂ : M ≃ₛₗ[RingHomClass.toRingHom e₁] M') :\n    Module.Free R M ↔ Module.Free R' M' :=\n  ⟨fun _ ↦ of_ringEquiv e₁ e₂, fun _ ↦ of_ringEquiv e₁.symm e₂.symm⟩\n\n"}
{"name":"Module.Free.self","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Module.Free R R","decl":"/-- The module structure provided by `Semiring.toModule` is free. -/\ninstance self : Module.Free R R :=\n  of_basis (Basis.singleton Unit R)\n\n"}
{"name":"Module.Free.prod","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type z\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module.Free R M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : Module.Free R N\n⊢ Module.Free R (Prod M N)","decl":"instance prod [Module.Free R N] : Module.Free R (M × N) :=\n  of_basis <| (chooseBasis R M).prod (chooseBasis R N)\n\n"}
{"name":"Module.Free.pi","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"ι : Type u_1\nR : Type u\ninst✝⁴ : Semiring R\nM : ι → Type u_2\ninst✝³ : Finite ι\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : ∀ (i : ι), Module.Free R (M i)\n⊢ Module.Free R ((i : ι) → M i)","decl":"/-- The product of finitely many free modules is free. -/\ninstance pi (M : ι → Type*) [Finite ι] [∀ i : ι, AddCommMonoid (M i)] [∀ i : ι, Module R (M i)]\n    [∀ i : ι, Module.Free R (M i)] : Module.Free R (∀ i, M i) :=\n  let ⟨_⟩ := nonempty_fintype ι\n  of_basis <| Pi.basis fun i => chooseBasis R (M i)\n\n"}
{"name":"Module.Free.matrix","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Module.Free R M\nm : Type u_2\nn : Type u_3\ninst✝¹ : Finite m\ninst✝ : Finite n\n⊢ Module.Free R (Matrix m n M)","decl":"/-- The module of finite matrices is free. -/\ninstance matrix {m n : Type*} [Finite m] [Finite n] : Module.Free R (Matrix m n M) :=\n  Module.Free.pi R _\n\n"}
{"name":"Module.Free.ulift","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\n⊢ Module.Free R (ULift.{u_2, v} M)","decl":"instance ulift [Free R M] : Free R (ULift M) := of_equiv ULift.moduleEquiv.symm\n\n"}
{"name":"Module.Free.function","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"ι : Type u_1\nR : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Finite ι\n⊢ Module.Free R (ι → M)","decl":"/-- The product of finitely many free modules is free (non-dependent version to help with typeclass\nsearch). -/\ninstance function [Finite ι] : Module.Free R (ι → M) :=\n  Free.pi _ _\n\n"}
{"name":"Module.Free.finsupp","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"ι : Type u_1\nR : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\n⊢ Module.Free R (Finsupp ι M)","decl":"instance finsupp : Module.Free R (ι →₀ M) :=\n  of_basis (Finsupp.basis fun _ => chooseBasis R M)\n\n"}
{"name":"Module.Free.of_subsingleton","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nN : Type z\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : Subsingleton N\n⊢ Module.Free R N","decl":"instance (priority := 100) of_subsingleton [Subsingleton N] : Module.Free R N :=\n  of_basis.{u,z,z} (Basis.empty N : Basis PEmpty R N)\n\n"}
{"name":"Module.Free.of_subsingleton'","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nN : Type z\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : Subsingleton R\n⊢ Module.Free R N","decl":"instance (priority := 100) of_subsingleton' [Subsingleton R] : Module.Free R N :=\n  letI := Module.subsingleton R N\n  Module.Free.of_subsingleton R N\n\n"}
{"name":"Module.Free.dfinsupp","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type u_2\nM : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : ∀ (i : ι), Module.Free R (M i)\n⊢ Module.Free R (DFinsupp fun i => M i)","decl":"instance dfinsupp {ι : Type*} (M : ι → Type*) [∀ i : ι, AddCommMonoid (M i)]\n    [∀ i : ι, Module R (M i)] [∀ i : ι, Module.Free R (M i)] : Module.Free R (Π₀ i, M i) :=\n  of_basis <| DFinsupp.basis fun i => chooseBasis R (M i)\n\n"}
{"name":"Module.Free.directSum","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\ninst✝³ : Semiring R\nι : Type u_2\nM : ι → Type u_3\ninst✝² : (i : ι) → AddCommMonoid (M i)\ninst✝¹ : (i : ι) → Module R (M i)\ninst✝ : ∀ (i : ι), Module.Free R (M i)\n⊢ Module.Free R (DirectSum ι fun i => M i)","decl":"instance directSum {ι : Type*} (M : ι → Type*) [∀ i : ι, AddCommMonoid (M i)]\n    [∀ i : ι, Module R (M i)] [∀ i : ι, Module.Free R (M i)] : Module.Free R (⨁ i, M i) :=\n  Module.Free.dfinsupp R M\n\n"}
{"name":"Module.Free.tensor","module":"Mathlib.LinearAlgebra.FreeModule.Basic","initialProofState":"R : Type u\nM : Type v\nN : Type z\nS : Type u_2\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : Semiring S\ninst✝⁸ : Algebra R S\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module S M\ninst✝⁴ : IsScalarTower R S M\ninst✝³ : Module.Free S M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : Module.Free R N\n⊢ Module.Free S (TensorProduct R M N)","decl":"instance tensor : Module.Free S (M ⊗[R] N) :=\n  let ⟨bM⟩ := exists_basis (R := S) (M := M)\n  let ⟨bN⟩ := exists_basis (R := R) (M := N)\n  of_basis (bM.2.tensorProduct bN.2)\n\n"}
