{"name":"Nat.modEq_list_prod_iff","module":"Mathlib.Data.Nat.ChineseRemainder","initialProofState":"a b : Nat\nl : List Nat\nco : List.Pairwise Nat.Coprime l\n⊢ Iff (l.prod.ModEq a b) (∀ (i : Fin l.length), (l.get i).ModEq a b)","decl":"lemma modEq_list_prod_iff {a b} {l : List ℕ} (co : l.Pairwise Coprime) :\n    a ≡ b [MOD l.prod] ↔ ∀ i, a ≡ b [MOD l.get i] := by\n  induction' l with m l ih\n  · simp [modEq_one]\n  · have : Coprime m l.prod := coprime_list_prod_right_iff.mpr (List.pairwise_cons.mp co).1\n    simp only [List.prod_cons, ← modEq_and_modEq_iff_modEq_mul this, ih (List.Pairwise.of_cons co),\n      List.length_cons]\n    constructor\n    · rintro ⟨h0, hs⟩ i\n      cases i using Fin.cases <;> simp_all\n    · intro h; exact ⟨h 0, fun i => h i.succ⟩\n\n"}
{"name":"Nat.modEq_list_prod_iff'","module":"Mathlib.Data.Nat.ChineseRemainder","initialProofState":"ι : Type u_1\na b : Nat\ns : ι → Nat\nl : List ι\nco : List.Pairwise (Function.onFun Nat.Coprime s) l\n⊢ Iff ((List.map s l).prod.ModEq a b) (∀ (i : ι), Membership.mem l i → (s i).ModEq a b)","decl":"lemma modEq_list_prod_iff' {a b} {s : ι → ℕ} {l : List ι} (co : l.Pairwise (Coprime on s)) :\n    a ≡ b [MOD (l.map s).prod] ↔ ∀ i ∈ l, a ≡ b [MOD s i] := by\n  induction' l with i l ih\n  · simp [modEq_one]\n  · have : Coprime (s i) (l.map s).prod := by\n      simp only [coprime_list_prod_right_iff, List.mem_map, forall_exists_index, and_imp,\n        forall_apply_eq_imp_iff₂]\n      intro j hj\n      exact (List.pairwise_cons.mp co).1 j hj\n    simp [← modEq_and_modEq_iff_modEq_mul this, ih (List.Pairwise.of_cons co)]\n\n"}
{"name":"Nat.chineseRemainderOfList_nil","module":"Mathlib.Data.Nat.ChineseRemainder","initialProofState":"ι : Type u_1\na s : ι → Nat\n⊢ Eq (↑(Nat.chineseRemainderOfList a s List.nil ⋯)) 0","decl":"@[simp] theorem chineseRemainderOfList_nil :\n    (chineseRemainderOfList a s [] List.Pairwise.nil : ℕ) = 0 := rfl\n\n"}
{"name":"Nat.chineseRemainderOfList_lt_prod","module":"Mathlib.Data.Nat.ChineseRemainder","initialProofState":"ι : Type u_1\na s : ι → Nat\nl : List ι\nco : List.Pairwise (Function.onFun Nat.Coprime s) l\nhs : ∀ (i : ι), Membership.mem l i → Ne (s i) 0\n⊢ LT.lt (↑(Nat.chineseRemainderOfList a s l co)) (List.map s l).prod","decl":"theorem chineseRemainderOfList_lt_prod (l : List ι)\n    (co : l.Pairwise (Coprime on s)) (hs : ∀ i ∈ l, s i ≠ 0) :\n    chineseRemainderOfList a s l co < (l.map s).prod := by\n  cases l with\n  | nil => simp\n  | cons i l =>\n    simp only [chineseRemainderOfList, List.map_cons, List.prod_cons]\n    have : Coprime (s i) (l.map s).prod := by\n      simp only [coprime_list_prod_right_iff, List.mem_map, forall_exists_index, and_imp,\n        forall_apply_eq_imp_iff₂]\n      intro j hj\n      exact (List.pairwise_cons.mp co).1 j hj\n    refine chineseRemainder_lt_mul this (a i) (chineseRemainderOfList a s l co.of_cons)\n      (hs i (List.mem_cons_self _ l)) ?_\n    simp only [ne_eq, List.prod_eq_zero_iff, List.mem_map, not_exists, not_and]\n    intro j hj\n    exact hs j (List.mem_cons_of_mem _ hj)\n\n"}
{"name":"Nat.chineseRemainderOfList_modEq_unique","module":"Mathlib.Data.Nat.ChineseRemainder","initialProofState":"ι : Type u_1\na s : ι → Nat\nl : List ι\nco : List.Pairwise (Function.onFun Nat.Coprime s) l\nz : Nat\nhz : ∀ (i : ι), Membership.mem l i → (s i).ModEq z (a i)\n⊢ (List.map s l).prod.ModEq z ↑(Nat.chineseRemainderOfList a s l co)","decl":"theorem chineseRemainderOfList_modEq_unique (l : List ι)\n    (co : l.Pairwise (Coprime on s)) {z} (hz : ∀ i ∈ l, z ≡ a i [MOD s i]) :\n    z ≡ chineseRemainderOfList a s l co [MOD (l.map s).prod] := by\n  induction' l with i l ih\n  · simp [modEq_one]\n  · simp only [List.map_cons, List.prod_cons, chineseRemainderOfList]\n    have : Coprime (s i) (l.map s).prod := by\n      simp only [coprime_list_prod_right_iff, List.mem_map, forall_exists_index, and_imp,\n        forall_apply_eq_imp_iff₂]\n      intro j hj\n      exact (List.pairwise_cons.mp co).1 j hj\n    exact chineseRemainder_modEq_unique this\n      (hz i (List.mem_cons_self _ _)) (ih co.of_cons (fun j hj => hz j (List.mem_cons_of_mem _ hj)))\n\n"}
{"name":"Nat.chineseRemainderOfList_perm","module":"Mathlib.Data.Nat.ChineseRemainder","initialProofState":"ι : Type u_1\na s : ι → Nat\nl l' : List ι\nhl : l.Perm l'\nhs : ∀ (i : ι), Membership.mem l i → Ne (s i) 0\nco : List.Pairwise (Function.onFun Nat.Coprime s) l\n⊢ Eq ↑(Nat.chineseRemainderOfList a s l co) ↑(Nat.chineseRemainderOfList a s l' ⋯)","decl":"theorem chineseRemainderOfList_perm {l l' : List ι} (hl : l.Perm l')\n    (hs : ∀ i ∈ l, s i ≠ 0) (co : l.Pairwise (Coprime on s)) :\n    (chineseRemainderOfList a s l co : ℕ) =\n    chineseRemainderOfList a s l' (co.perm hl coprime_comm.mpr) := by\n  let z := chineseRemainderOfList a s l' (co.perm hl coprime_comm.mpr)\n  have hlp : (l.map s).prod = (l'.map s).prod := List.Perm.prod_eq (List.Perm.map s hl)\n  exact (chineseRemainderOfList_modEq_unique a s l co (z := z)\n    (fun i hi => z.prop i (hl.symm.mem_iff.mpr hi))).symm.eq_of_lt_of_lt\n      (chineseRemainderOfList_lt_prod _ _ _ _ hs)\n      (by rw [hlp]\n          exact chineseRemainderOfList_lt_prod _ _ _ _\n            (by simpa [List.Perm.mem_iff hl.symm] using hs))\n\n"}
{"name":"Nat.chineseRemainderOfMultiset_lt_prod","module":"Mathlib.Data.Nat.ChineseRemainder","initialProofState":"ι : Type u_1\na s : ι → Nat\nm : Multiset ι\nnod : m.Nodup\nhs : ∀ (i : ι), Membership.mem m i → Ne (s i) 0\npp : (setOf fun x => Membership.mem m x).Pairwise (Function.onFun Nat.Coprime s)\n⊢ LT.lt (↑(Nat.chineseRemainderOfMultiset a s nod hs pp)) (Multiset.map s m).prod","decl":"theorem chineseRemainderOfMultiset_lt_prod {m : Multiset ι}\n    (nod : m.Nodup) (hs : ∀ i ∈ m, s i ≠ 0) (pp : Set.Pairwise {x | x ∈ m} (Coprime on s)) :\n    chineseRemainderOfMultiset a s nod hs pp < (m.map s).prod := by\n  induction' m using Quot.ind with l\n  unfold chineseRemainderOfMultiset\n  simpa using chineseRemainderOfList_lt_prod a s l\n    (List.Nodup.pairwise_of_forall_ne nod pp) (by simpa using hs)\n\n"}
{"name":"Nat.chineseRemainderOfFinset_lt_prod","module":"Mathlib.Data.Nat.ChineseRemainder","initialProofState":"ι : Type u_1\na s : ι → Nat\nt : Finset ι\nhs : ∀ (i : ι), Membership.mem t i → Ne (s i) 0\npp : (↑t).Pairwise (Function.onFun Nat.Coprime s)\n⊢ LT.lt (↑(Nat.chineseRemainderOfFinset a s t hs pp)) (t.prod fun i => s i)","decl":"theorem chineseRemainderOfFinset_lt_prod {t : Finset ι}\n    (hs : ∀ i ∈ t, s i ≠ 0) (pp : Set.Pairwise t (Coprime on s)) :\n    chineseRemainderOfFinset a s t hs pp < ∏ i ∈ t, s i := by\n  simpa [chineseRemainderOfFinset] using\n    chineseRemainderOfMultiset_lt_prod a s t.nodup (by simpa using hs) (by simpa using pp)\n\n"}
