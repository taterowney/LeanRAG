{"name":"CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.prod_uniq","module":"Mathlib.CategoryTheory.Localization.Prod","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nE : Type u₅\ninst✝ : CategoryTheory.Category.{v₅, u₅} E\nF₁ F₂ : CategoryTheory.Functor (Prod W₁.Localization W₂.Localization) E\nh : Eq ((W₁.Q.prod W₂.Q).comp F₁) ((W₁.Q.prod W₂.Q).comp F₂)\n⊢ Eq F₁ F₂","decl":"lemma prod_uniq (F₁ F₂ : (W₁.Localization × W₂.Localization ⥤ E))\n    (h : (W₁.Q.prod W₂.Q) ⋙ F₁ = (W₁.Q.prod W₂.Q) ⋙ F₂) :\n      F₁ = F₂ := by\n  apply Functor.curry_obj_injective\n  apply Construction.uniq\n  apply Functor.flip_injective\n  apply Construction.uniq\n  apply Functor.flip_injective\n  apply Functor.uncurry_obj_injective\n  simpa only [Functor.uncurry_obj_curry_obj_flip_flip] using h\n\n"}
{"name":"CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.prod_fac₁","module":"Mathlib.CategoryTheory.Localization.Prod","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nE : Type u₅\ninst✝¹ : CategoryTheory.Category.{v₅, u₅} E\nF : CategoryTheory.Functor (Prod C₁ C₂) E\nhF : (W₁.prod W₂).IsInvertedBy F\ninst✝ : W₂.ContainsIdentities\n⊢ Eq (W₁.Q.comp (CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.prodLift₁ F hF)) (CategoryTheory.curry.obj F)","decl":"lemma prod_fac₁ [W₂.ContainsIdentities] :\n    W₁.Q ⋙ prodLift₁ F hF = curry.obj F :=\n  Construction.fac _ _\n\n"}
{"name":"CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.prod_fac₂","module":"Mathlib.CategoryTheory.Localization.Prod","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nE : Type u₅\ninst✝² : CategoryTheory.Category.{v₅, u₅} E\nF : CategoryTheory.Functor (Prod C₁ C₂) E\nhF : (W₁.prod W₂).IsInvertedBy F\ninst✝¹ : W₁.ContainsIdentities\ninst✝ : W₂.ContainsIdentities\n⊢ Eq (W₂.Q.comp (CategoryTheory.curry.obj (CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.prodLift F hF)).flip) (CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.prodLift₁ F hF).flip","decl":"lemma prod_fac₂ :\n    W₂.Q ⋙ (curry.obj (prodLift F hF)).flip = (prodLift₁ F hF).flip := by\n  simp only [prodLift, Functor.curry_obj_uncurry_obj, Functor.flip_flip]\n  apply Construction.fac\n\n"}
{"name":"CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.prod_fac","module":"Mathlib.CategoryTheory.Localization.Prod","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝³ : CategoryTheory.Category.{v₂, u₂} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nE : Type u₅\ninst✝² : CategoryTheory.Category.{v₅, u₅} E\nF : CategoryTheory.Functor (Prod C₁ C₂) E\nhF : (W₁.prod W₂).IsInvertedBy F\ninst✝¹ : W₁.ContainsIdentities\ninst✝ : W₂.ContainsIdentities\n⊢ Eq ((W₁.Q.prod W₂.Q).comp (CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.prodLift F hF)) F","decl":"lemma prod_fac :\n    (W₁.Q.prod W₂.Q) ⋙ prodLift F hF = F := by\n  rw [← Functor.uncurry_obj_curry_obj_flip_flip', prod_fac₂, Functor.flip_flip, prod_fac₁,\n    Functor.uncurry_obj_curry_obj]\n\n"}
{"name":"CategoryTheory.Localization.Construction.prodIsLocalization","module":"Mathlib.CategoryTheory.Localization.Prod","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝² : CategoryTheory.Category.{v₂, u₂} C₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\ninst✝¹ : W₁.ContainsIdentities\ninst✝ : W₂.ContainsIdentities\n⊢ (W₁.Q.prod W₂.Q).IsLocalization (W₁.prod W₂)","decl":"lemma Construction.prodIsLocalization :\n    (W₁.Q.prod W₂.Q).IsLocalization (W₁.prod W₂) :=\n  Functor.IsLocalization.mk' _ _\n    (StrictUniversalPropertyFixedTarget.prod W₁ W₂)\n    (StrictUniversalPropertyFixedTarget.prod W₁ W₂)\n\n"}
{"name":"CategoryTheory.Functor.IsLocalization.prod","module":"Mathlib.CategoryTheory.Localization.Prod","initialProofState":"C₁ : Type u₁\nC₂ : Type u₂\nD₁ : Type u₃\nD₂ : Type u₄\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C₁\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} C₂\ninst✝³ : CategoryTheory.Category.{v₃, u₃} D₁\ninst✝² : CategoryTheory.Category.{v₄, u₄} D₂\nL₁ : CategoryTheory.Functor C₁ D₁\nW₁ : CategoryTheory.MorphismProperty C₁\nL₂ : CategoryTheory.Functor C₂ D₂\nW₂ : CategoryTheory.MorphismProperty C₂\ninst✝¹ : L₁.IsLocalization W₁\ninst✝ : L₂.IsLocalization W₂\n⊢ (L₁.prod L₂).IsLocalization (W₁.prod W₂)","decl":"/-- If `L₁ : C₁ ⥤ D₁` and `L₂ : C₂ ⥤ D₂` are localization functors\nfor `W₁ : MorphismProperty C₁` and `W₂ : MorphismProperty C₂` respectively,\nand if both `W₁` and `W₂` contain identities, then the product\nfunctor `L₁.prod L₂ : C₁ × C₂ ⥤ D₁ × D₂` is a localization functor for `W₁.prod W₂`. -/\ninstance prod [L₁.IsLocalization W₁] [L₂.IsLocalization W₂] :\n    (L₁.prod L₂).IsLocalization (W₁.prod W₂) := by\n  haveI := Construction.prodIsLocalization W₁ W₂\n  exact of_equivalence_target (W₁.Q.prod W₂.Q) (W₁.prod W₂) (L₁.prod L₂)\n    ((uniq W₁.Q L₁ W₁).prod (uniq W₂.Q L₂ W₂))\n    (NatIso.prod (compUniqFunctor W₁.Q L₁ W₁) (compUniqFunctor W₂.Q L₂ W₂))\n\n"}
