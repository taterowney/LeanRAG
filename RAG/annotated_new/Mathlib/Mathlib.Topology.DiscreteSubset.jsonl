{"name":"tendsto_cofinite_cocompact_iff","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝ : TopologicalSpace Y\nf : X → Y\n⊢ Iff (Filter.Tendsto f Filter.cofinite (Filter.cocompact Y)) (∀ (K : Set Y), IsCompact K → (Set.preimage f K).Finite)","decl":"lemma tendsto_cofinite_cocompact_iff :\n    Tendsto f cofinite (cocompact _) ↔ ∀ K, IsCompact K → Set.Finite (f ⁻¹' K) := by\n  rw [hasBasis_cocompact.tendsto_right_iff]\n  refine forall₂_congr (fun K _ ↦ ?_)\n  simp only [mem_compl_iff, eventually_cofinite, not_not, preimage]\n\n"}
{"name":"Continuous.discrete_of_tendsto_cofinite_cocompact","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝³ : TopologicalSpace Y\nf : X → Y\ninst✝² : TopologicalSpace X\ninst✝¹ : T1Space X\ninst✝ : WeaklyLocallyCompactSpace Y\nhf' : Continuous f\nhf : Filter.Tendsto f Filter.cofinite (Filter.cocompact Y)\n⊢ DiscreteTopology X","decl":"lemma Continuous.discrete_of_tendsto_cofinite_cocompact [T1Space X] [WeaklyLocallyCompactSpace Y]\n    (hf' : Continuous f) (hf : Tendsto f cofinite (cocompact _)) :\n    DiscreteTopology X := by\n  refine singletons_open_iff_discrete.mp (fun x ↦ ?_)\n  obtain ⟨K : Set Y, hK : IsCompact K, hK' : K ∈ 𝓝 (f x)⟩ := exists_compact_mem_nhds (f x)\n  obtain ⟨U : Set Y, hU₁ : U ⊆ K, hU₂ : IsOpen U, hU₃ : f x ∈ U⟩ := mem_nhds_iff.mp hK'\n  have hU₄ : Set.Finite (f⁻¹' U) :=\n    Finite.subset (tendsto_cofinite_cocompact_iff.mp hf K hK) (preimage_mono hU₁)\n  exact isOpen_singleton_of_finite_mem_nhds _ ((hU₂.preimage hf').mem_nhds hU₃) hU₄\n\n"}
{"name":"tendsto_cofinite_cocompact_of_discrete","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝² : TopologicalSpace Y\nf : X → Y\ninst✝¹ : TopologicalSpace X\ninst✝ : DiscreteTopology X\nhf : Filter.Tendsto f (Filter.cocompact X) (Filter.cocompact Y)\n⊢ Filter.Tendsto f Filter.cofinite (Filter.cocompact Y)","decl":"lemma tendsto_cofinite_cocompact_of_discrete [DiscreteTopology X]\n    (hf : Tendsto f (cocompact _) (cocompact _)) :\n    Tendsto f cofinite (cocompact _) := by\n  convert hf\n  rw [cocompact_eq_cofinite X]\n\n"}
{"name":"IsClosed.tendsto_coe_cofinite_of_discreteTopology","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\ns : Set X\nhs : IsClosed s\n_hs' : DiscreteTopology ↑s\n⊢ Filter.Tendsto Subtype.val Filter.cofinite (Filter.cocompact X)","decl":"lemma IsClosed.tendsto_coe_cofinite_of_discreteTopology\n    {s : Set X} (hs : IsClosed s) (_hs' : DiscreteTopology s) :\n    Tendsto ((↑) : s → X) cofinite (cocompact _) :=\n  tendsto_cofinite_cocompact_of_discrete hs.isClosedEmbedding_subtypeVal.tendsto_cocompact\n\n"}
{"name":"IsClosed.tendsto_coe_cofinite_iff","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : T1Space X\ninst✝ : WeaklyLocallyCompactSpace X\ns : Set X\nhs : IsClosed s\n⊢ Iff (Filter.Tendsto Subtype.val Filter.cofinite (Filter.cocompact X)) (DiscreteTopology ↑s)","decl":"lemma IsClosed.tendsto_coe_cofinite_iff [T1Space X] [WeaklyLocallyCompactSpace X]\n    {s : Set X} (hs : IsClosed s) :\n    Tendsto ((↑) : s → X) cofinite (cocompact _) ↔ DiscreteTopology s :=\n  ⟨continuous_subtype_val.discrete_of_tendsto_cofinite_cocompact,\n   fun _ ↦ hs.tendsto_coe_cofinite_of_discreteTopology inferInstance⟩\n\n"}
{"name":"isClosed_and_discrete_iff","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS : Set X\n⊢ Iff (And (IsClosed S) (DiscreteTopology ↑S)) (∀ (x : X), Disjoint (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) (Filter.principal S))","decl":"/-- Criterion for a subset `S ⊆ X` to be closed and discrete in terms of the punctured\nneighbourhood filter at an arbitrary point of `X`. (Compare `discreteTopology_subtype_iff`.) -/\ntheorem isClosed_and_discrete_iff {S : Set X} :\n    IsClosed S ∧ DiscreteTopology S ↔ ∀ x, Disjoint (𝓝[≠] x) (𝓟 S) := by\n  rw [discreteTopology_subtype_iff, isClosed_iff_clusterPt, ← forall_and]\n  congrm (∀ x, ?_)\n  rw [← not_imp_not, clusterPt_iff_not_disjoint, not_not, ← disjoint_iff]\n  constructor <;> intro H\n  · by_cases hx : x ∈ S\n    exacts [H.2 hx, (H.1 hx).mono_left nhdsWithin_le_nhds]\n  · refine ⟨fun hx ↦ ?_, fun _ ↦ H⟩\n    simpa [disjoint_iff, nhdsWithin, inf_assoc, hx] using H\n\n"}
{"name":"mem_codiscreteWithin","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS T : Set X\n⊢ Iff (Membership.mem (Filter.codiscreteWithin T) S) (∀ (x : X), Membership.mem T x → Disjoint (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) (Filter.principal (SDiff.sdiff T S)))","decl":"lemma mem_codiscreteWithin {S T : Set X} :\n    S ∈ codiscreteWithin T ↔ ∀ x ∈ T, Disjoint (𝓝[≠] x) (𝓟 (T \\ S)) := by\n  simp only [codiscreteWithin, mem_iSup, mem_nhdsWithin, disjoint_principal_right, subset_def,\n    mem_diff, mem_inter_iff, mem_compl_iff]\n  congr! 7 with x - u y\n  tauto\n\n"}
{"name":"mem_codiscreteWithin_accPt","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS T : Set X\n⊢ Iff (Membership.mem (Filter.codiscreteWithin T) S) (∀ (x : X), Membership.mem T x → Not (AccPt x (Filter.principal (SDiff.sdiff T S))))","decl":"lemma mem_codiscreteWithin_accPt {S T : Set X} :\n    S ∈ codiscreteWithin T ↔ ∀ x ∈ T, ¬AccPt x (𝓟 (T \\ S)) := by\n  simp only [mem_codiscreteWithin, disjoint_iff, AccPt, not_neBot]\n\n"}
{"name":"mem_codiscrete","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS : Set X\n⊢ Iff (Membership.mem (Filter.codiscrete X) S) (∀ (x : X), Disjoint (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) (Filter.principal (HasCompl.compl S)))","decl":"lemma mem_codiscrete {S : Set X} :\n    S ∈ codiscrete X ↔ ∀ x, Disjoint (𝓝[≠] x) (𝓟 Sᶜ) := by\n  simp [codiscrete, mem_codiscreteWithin, compl_eq_univ_diff]\n\n"}
{"name":"mem_codiscrete_accPt","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS : Set X\n⊢ Iff (Membership.mem (Filter.codiscrete X) S) (∀ (x : X), Not (AccPt x (Filter.principal (HasCompl.compl S))))","decl":"lemma mem_codiscrete_accPt {S : Set X} :\n    S ∈ codiscrete X ↔ ∀ x, ¬AccPt x (𝓟 Sᶜ) := by\n  simp only [mem_codiscrete, disjoint_iff, AccPt, not_neBot]\n\n"}
{"name":"mem_codiscrete'","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS : Set X\n⊢ Iff (Membership.mem (Filter.codiscrete X) S) (And (IsOpen S) (DiscreteTopology ↑(HasCompl.compl S)))","decl":"lemma mem_codiscrete' {S : Set X} :\n    S ∈ codiscrete X ↔ IsOpen S ∧ DiscreteTopology ↑Sᶜ := by\n  rw [mem_codiscrete, ← isClosed_compl_iff, isClosed_and_discrete_iff]\n\n"}
{"name":"mem_codiscrete_subtype_iff_mem_codiscreteWithin","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nS : Set X\nU : Set ↑S\n⊢ Iff (Membership.mem (Filter.codiscrete ↑S) U) (Membership.mem (Filter.codiscreteWithin S) (Set.image Subtype.val U))","decl":"lemma mem_codiscrete_subtype_iff_mem_codiscreteWithin {S : Set X} {U : Set S} :\n    U ∈ codiscrete S ↔ (↑) '' U ∈ codiscreteWithin S := by\n  simp [mem_codiscrete, disjoint_principal_right, compl_compl, Subtype.forall,\n    mem_codiscreteWithin]\n  congr! with x hx\n  constructor\n  · rw [nhdsWithin_subtype, mem_comap]\n    rintro ⟨t, ht1, ht2⟩\n    rw [mem_nhdsWithin] at ht1 ⊢\n    obtain ⟨u, hu1, hu2, hu3⟩ := ht1\n    refine ⟨u, hu1, hu2, fun v hv ↦ ?_⟩\n    simpa using fun hv2 ↦ ⟨hv2, ht2 <| hu3 <| by simpa [hv2]⟩\n  · suffices Tendsto (↑) (𝓝[≠] (⟨x, hx⟩ : S)) (𝓝[≠] x) by convert tendsto_def.mp this _; ext; simp\n    exact tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n      continuous_subtype_val.continuousWithinAt <| eventually_mem_nhdsWithin.mono (by simp)\n\n"}
