{"name":"tendsto_cofinite_cocompact_iff","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nâŠ¢ Iff (Filter.Tendsto f Filter.cofinite (Filter.cocompact Y)) (âˆ€ (K : Set Y), IsCompact K â†’ (Set.preimage f K).Finite)","decl":"lemma tendsto_cofinite_cocompact_iff :\n    Tendsto f cofinite (cocompact _) â†” âˆ€ K, IsCompact K â†’ Set.Finite (f â»Â¹' K) := by\n  rw [hasBasis_cocompact.tendsto_right_iff]\n  refine forallâ‚‚_congr (fun K _ â†¦ ?_)\n  simp only [mem_compl_iff, eventually_cofinite, not_not, preimage]\n\n"}
{"name":"Continuous.discrete_of_tendsto_cofinite_cocompact","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace Y\nf : X â†’ Y\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : T1Space X\ninstâœ : WeaklyLocallyCompactSpace Y\nhf' : Continuous f\nhf : Filter.Tendsto f Filter.cofinite (Filter.cocompact Y)\nâŠ¢ DiscreteTopology X","decl":"lemma Continuous.discrete_of_tendsto_cofinite_cocompact [T1Space X] [WeaklyLocallyCompactSpace Y]\n    (hf' : Continuous f) (hf : Tendsto f cofinite (cocompact _)) :\n    DiscreteTopology X := by\n  refine singletons_open_iff_discrete.mp (fun x â†¦ ?_)\n  obtain âŸ¨K : Set Y, hK : IsCompact K, hK' : K âˆˆ ğ“ (f x)âŸ© := exists_compact_mem_nhds (f x)\n  obtain âŸ¨U : Set Y, hUâ‚ : U âŠ† K, hUâ‚‚ : IsOpen U, hUâ‚ƒ : f x âˆˆ UâŸ© := mem_nhds_iff.mp hK'\n  have hUâ‚„ : Set.Finite (fâ»Â¹' U) :=\n    Finite.subset (tendsto_cofinite_cocompact_iff.mp hf K hK) (preimage_mono hUâ‚)\n  exact isOpen_singleton_of_finite_mem_nhds _ ((hUâ‚‚.preimage hf').mem_nhds hUâ‚ƒ) hUâ‚„\n\n"}
{"name":"tendsto_cofinite_cocompact_of_discrete","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace Y\nf : X â†’ Y\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : DiscreteTopology X\nhf : Filter.Tendsto f (Filter.cocompact X) (Filter.cocompact Y)\nâŠ¢ Filter.Tendsto f Filter.cofinite (Filter.cocompact Y)","decl":"lemma tendsto_cofinite_cocompact_of_discrete [DiscreteTopology X]\n    (hf : Tendsto f (cocompact _) (cocompact _)) :\n    Tendsto f cofinite (cocompact _) := by\n  convert hf\n  rw [cocompact_eq_cofinite X]\n\n"}
{"name":"IsClosed.tendsto_coe_cofinite_of_discreteTopology","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\ns : Set X\nhs : IsClosed s\n_hs' : DiscreteTopology â†‘s\nâŠ¢ Filter.Tendsto Subtype.val Filter.cofinite (Filter.cocompact X)","decl":"lemma IsClosed.tendsto_coe_cofinite_of_discreteTopology\n    {s : Set X} (hs : IsClosed s) (_hs' : DiscreteTopology s) :\n    Tendsto ((â†‘) : s â†’ X) cofinite (cocompact _) :=\n  tendsto_cofinite_cocompact_of_discrete hs.isClosedEmbedding_subtypeVal.tendsto_cocompact\n\n"}
{"name":"IsClosed.tendsto_coe_cofinite_iff","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : T1Space X\ninstâœ : WeaklyLocallyCompactSpace X\ns : Set X\nhs : IsClosed s\nâŠ¢ Iff (Filter.Tendsto Subtype.val Filter.cofinite (Filter.cocompact X)) (DiscreteTopology â†‘s)","decl":"lemma IsClosed.tendsto_coe_cofinite_iff [T1Space X] [WeaklyLocallyCompactSpace X]\n    {s : Set X} (hs : IsClosed s) :\n    Tendsto ((â†‘) : s â†’ X) cofinite (cocompact _) â†” DiscreteTopology s :=\n  âŸ¨continuous_subtype_val.discrete_of_tendsto_cofinite_cocompact,\n   fun _ â†¦ hs.tendsto_coe_cofinite_of_discreteTopology inferInstanceâŸ©\n\n"}
{"name":"isClosed_and_discrete_iff","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nS : Set X\nâŠ¢ Iff (And (IsClosed S) (DiscreteTopology â†‘S)) (âˆ€ (x : X), Disjoint (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) (Filter.principal S))","decl":"/-- Criterion for a subset `S âŠ† X` to be closed and discrete in terms of the punctured\nneighbourhood filter at an arbitrary point of `X`. (Compare `discreteTopology_subtype_iff`.) -/\ntheorem isClosed_and_discrete_iff {S : Set X} :\n    IsClosed S âˆ§ DiscreteTopology S â†” âˆ€ x, Disjoint (ğ“[â‰ ] x) (ğ“Ÿ S) := by\n  rw [discreteTopology_subtype_iff, isClosed_iff_clusterPt, â† forall_and]\n  congrm (âˆ€ x, ?_)\n  rw [â† not_imp_not, clusterPt_iff_not_disjoint, not_not, â† disjoint_iff]\n  constructor <;> intro H\n  Â· by_cases hx : x âˆˆ S\n    exacts [H.2 hx, (H.1 hx).mono_left nhdsWithin_le_nhds]\n  Â· refine âŸ¨fun hx â†¦ ?_, fun _ â†¦ HâŸ©\n    simpa [disjoint_iff, nhdsWithin, inf_assoc, hx] using H\n\n"}
{"name":"mem_codiscreteWithin","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nS T : Set X\nâŠ¢ Iff (Membership.mem (Filter.codiscreteWithin T) S) (âˆ€ (x : X), Membership.mem T x â†’ Disjoint (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) (Filter.principal (SDiff.sdiff T S)))","decl":"lemma mem_codiscreteWithin {S T : Set X} :\n    S âˆˆ codiscreteWithin T â†” âˆ€ x âˆˆ T, Disjoint (ğ“[â‰ ] x) (ğ“Ÿ (T \\ S)) := by\n  simp only [codiscreteWithin, mem_iSup, mem_nhdsWithin, disjoint_principal_right, subset_def,\n    mem_diff, mem_inter_iff, mem_compl_iff]\n  congr! 7 with x - u y\n  tauto\n\n"}
{"name":"mem_codiscreteWithin_accPt","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nS T : Set X\nâŠ¢ Iff (Membership.mem (Filter.codiscreteWithin T) S) (âˆ€ (x : X), Membership.mem T x â†’ Not (AccPt x (Filter.principal (SDiff.sdiff T S))))","decl":"lemma mem_codiscreteWithin_accPt {S T : Set X} :\n    S âˆˆ codiscreteWithin T â†” âˆ€ x âˆˆ T, Â¬AccPt x (ğ“Ÿ (T \\ S)) := by\n  simp only [mem_codiscreteWithin, disjoint_iff, AccPt, not_neBot]\n\n"}
{"name":"mem_codiscrete","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nS : Set X\nâŠ¢ Iff (Membership.mem (Filter.codiscrete X) S) (âˆ€ (x : X), Disjoint (nhdsWithin x (HasCompl.compl (Singleton.singleton x))) (Filter.principal (HasCompl.compl S)))","decl":"lemma mem_codiscrete {S : Set X} :\n    S âˆˆ codiscrete X â†” âˆ€ x, Disjoint (ğ“[â‰ ] x) (ğ“Ÿ Sá¶œ) := by\n  simp [codiscrete, mem_codiscreteWithin, compl_eq_univ_diff]\n\n"}
{"name":"mem_codiscrete_accPt","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nS : Set X\nâŠ¢ Iff (Membership.mem (Filter.codiscrete X) S) (âˆ€ (x : X), Not (AccPt x (Filter.principal (HasCompl.compl S))))","decl":"lemma mem_codiscrete_accPt {S : Set X} :\n    S âˆˆ codiscrete X â†” âˆ€ x, Â¬AccPt x (ğ“Ÿ Sá¶œ) := by\n  simp only [mem_codiscrete, disjoint_iff, AccPt, not_neBot]\n\n"}
{"name":"mem_codiscrete'","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nS : Set X\nâŠ¢ Iff (Membership.mem (Filter.codiscrete X) S) (And (IsOpen S) (DiscreteTopology â†‘(HasCompl.compl S)))","decl":"lemma mem_codiscrete' {S : Set X} :\n    S âˆˆ codiscrete X â†” IsOpen S âˆ§ DiscreteTopology â†‘Sá¶œ := by\n  rw [mem_codiscrete, â† isClosed_compl_iff, isClosed_and_discrete_iff]\n\n"}
{"name":"mem_codiscrete_subtype_iff_mem_codiscreteWithin","module":"Mathlib.Topology.DiscreteSubset","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nS : Set X\nU : Set â†‘S\nâŠ¢ Iff (Membership.mem (Filter.codiscrete â†‘S) U) (Membership.mem (Filter.codiscreteWithin S) (Set.image Subtype.val U))","decl":"lemma mem_codiscrete_subtype_iff_mem_codiscreteWithin {S : Set X} {U : Set S} :\n    U âˆˆ codiscrete S â†” (â†‘) '' U âˆˆ codiscreteWithin S := by\n  simp [mem_codiscrete, disjoint_principal_right, compl_compl, Subtype.forall,\n    mem_codiscreteWithin]\n  congr! with x hx\n  constructor\n  Â· rw [nhdsWithin_subtype, mem_comap]\n    rintro âŸ¨t, ht1, ht2âŸ©\n    rw [mem_nhdsWithin] at ht1 âŠ¢\n    obtain âŸ¨u, hu1, hu2, hu3âŸ© := ht1\n    refine âŸ¨u, hu1, hu2, fun v hv â†¦ ?_âŸ©\n    simpa using fun hv2 â†¦ âŸ¨hv2, ht2 <| hu3 <| by simpa [hv2]âŸ©\n  Â· suffices Tendsto (â†‘) (ğ“[â‰ ] (âŸ¨x, hxâŸ© : S)) (ğ“[â‰ ] x) by convert tendsto_def.mp this _; ext; simp\n    exact tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _\n      continuous_subtype_val.continuousWithinAt <| eventually_mem_nhdsWithin.mono (by simp)\n\n"}
