{"name":"Monoid.Coprod.con_ker_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (Con.ker Monoid.Coprod.mk) (Monoid.coprodCon M N)","decl":"@[to_additive (attr := simp)]\ntheorem con_ker_mk : Con.ker mk = coprodCon M N := Con.mk'_ker _\n\n"}
{"name":"AddMonoid.Coprod.con_ker_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddCon.ker AddMonoid.Coprod.mk) (AddMonoid.coprodCon M N)","decl":"@[to_additive (attr := simp)]\ntheorem con_ker_mk : Con.ker mk = coprodCon M N := Con.mk'_ker _\n\n"}
{"name":"AddMonoid.Coprod.mk_surjective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Function.Surjective ⇑AddMonoid.Coprod.mk","decl":"@[to_additive]\ntheorem mk_surjective : Surjective (@mk M N _ _) := Quot.mk_surjective\n\n"}
{"name":"Monoid.Coprod.mk_surjective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Function.Surjective ⇑Monoid.Coprod.mk","decl":"@[to_additive]\ntheorem mk_surjective : Surjective (@mk M N _ _) := Quot.mk_surjective\n\n"}
{"name":"AddMonoid.Coprod.mrange_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mrange AddMonoid.Coprod.mk) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mrange_mk : MonoidHom.mrange (@mk M N _ _) = ⊤ := Con.mrange_mk'\n\n"}
{"name":"Monoid.Coprod.mrange_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mrange Monoid.Coprod.mk) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mrange_mk : MonoidHom.mrange (@mk M N _ _) = ⊤ := Con.mrange_mk'\n\n"}
{"name":"Monoid.Coprod.mk_eq_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nw₁ w₂ : FreeMonoid (Sum M N)\n⊢ Iff (Eq (Monoid.Coprod.mk w₁) (Monoid.Coprod.mk w₂)) ((Monoid.coprodCon M N) w₁ w₂)","decl":"@[to_additive]\ntheorem mk_eq_mk {w₁ w₂ : FreeMonoid (M ⊕ N)} : mk w₁ = mk w₂ ↔ coprodCon M N w₁ w₂ := Con.eq _\n\n"}
{"name":"AddMonoid.Coprod.mk_eq_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nw₁ w₂ : FreeAddMonoid (Sum M N)\n⊢ Iff (Eq (AddMonoid.Coprod.mk w₁) (AddMonoid.Coprod.mk w₂)) ((AddMonoid.coprodCon M N) w₁ w₂)","decl":"@[to_additive]\ntheorem mk_eq_mk {w₁ w₂ : FreeMonoid (M ⊕ N)} : mk w₁ = mk w₂ ↔ coprodCon M N w₁ w₂ := Con.eq _\n\n"}
{"name":"AddMonoid.Coprod.mk_of_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nx : M\n⊢ Eq (AddMonoid.Coprod.mk (FreeAddMonoid.of (Sum.inl x))) (AddMonoid.Coprod.inl x)","decl":"@[to_additive (attr := simp)]\ntheorem mk_of_inl (x : M) : (mk (of (.inl x)) : M ∗ N) = inl x := rfl\n\n"}
{"name":"Monoid.Coprod.mk_of_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nx : M\n⊢ Eq (Monoid.Coprod.mk (FreeMonoid.of (Sum.inl x))) (Monoid.Coprod.inl x)","decl":"@[to_additive (attr := simp)]\ntheorem mk_of_inl (x : M) : (mk (of (.inl x)) : M ∗ N) = inl x := rfl\n\n"}
{"name":"Monoid.Coprod.mk_of_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nx : N\n⊢ Eq (Monoid.Coprod.mk (FreeMonoid.of (Sum.inr x))) (Monoid.Coprod.inr x)","decl":"@[to_additive (attr := simp)]\ntheorem mk_of_inr (x : N) : (mk (of (.inr x)) : M ∗ N) = inr x := rfl\n\n"}
{"name":"AddMonoid.Coprod.mk_of_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nx : N\n⊢ Eq (AddMonoid.Coprod.mk (FreeAddMonoid.of (Sum.inr x))) (AddMonoid.Coprod.inr x)","decl":"@[to_additive (attr := simp)]\ntheorem mk_of_inr (x : N) : (mk (of (.inr x)) : M ∗ N) = inr x := rfl\n\n"}
{"name":"Monoid.Coprod.induction_on'","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nC : Monoid.Coprod M N → Prop\nm : Monoid.Coprod M N\none : C 1\ninl_mul : ∀ (m : M) (x : Monoid.Coprod M N), C x → C (HMul.hMul (Monoid.Coprod.inl m) x)\ninr_mul : ∀ (n : N) (x : Monoid.Coprod M N), C x → C (HMul.hMul (Monoid.Coprod.inr n) x)\n⊢ C m","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on' {C : M ∗ N → Prop} (m : M ∗ N)\n    (one : C 1)\n    (inl_mul : ∀ m x, C x → C (inl m * x))\n    (inr_mul : ∀ n x, C x → C (inr n * x)) : C m := by\n  rcases mk_surjective m with ⟨x, rfl⟩\n  induction x using FreeMonoid.inductionOn' with\n  | one => exact one\n  | mul_of x xs ih =>\n    cases x with\n    | inl m => simpa using inl_mul m _ ih\n    | inr n => simpa using inr_mul n _ ih\n\n"}
{"name":"AddMonoid.Coprod.induction_on'","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nC : AddMonoid.Coprod M N → Prop\nm : AddMonoid.Coprod M N\none : C 0\ninl_mul : ∀ (m : M) (x : AddMonoid.Coprod M N), C x → C (HAdd.hAdd (AddMonoid.Coprod.inl m) x)\ninr_mul : ∀ (n : N) (x : AddMonoid.Coprod M N), C x → C (HAdd.hAdd (AddMonoid.Coprod.inr n) x)\n⊢ C m","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on' {C : M ∗ N → Prop} (m : M ∗ N)\n    (one : C 1)\n    (inl_mul : ∀ m x, C x → C (inl m * x))\n    (inr_mul : ∀ n x, C x → C (inr n * x)) : C m := by\n  rcases mk_surjective m with ⟨x, rfl⟩\n  induction x using FreeMonoid.inductionOn' with\n  | one => exact one\n  | mul_of x xs ih =>\n    cases x with\n    | inl m => simpa using inl_mul m _ ih\n    | inr n => simpa using inr_mul n _ ih\n\n"}
{"name":"Monoid.Coprod.induction_on","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nC : Monoid.Coprod M N → Prop\nm : Monoid.Coprod M N\ninl : ∀ (m : M), C (Monoid.Coprod.inl m)\ninr : ∀ (n : N), C (Monoid.Coprod.inr n)\nmul : ∀ (x y : Monoid.Coprod M N), C x → C y → C (HMul.hMul x y)\n⊢ C m","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on {C : M ∗ N → Prop} (m : M ∗ N)\n    (inl : ∀ m, C (inl m)) (inr : ∀ n, C (inr n)) (mul : ∀ x y, C x → C y → C (x * y)) : C m :=\n  induction_on' m (by simpa using inl 1) (fun _ _ ↦ mul _ _ (inl _)) fun _ _ ↦ mul _ _ (inr _)\n\n"}
{"name":"AddMonoid.Coprod.induction_on","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nC : AddMonoid.Coprod M N → Prop\nm : AddMonoid.Coprod M N\ninl : ∀ (m : M), C (AddMonoid.Coprod.inl m)\ninr : ∀ (n : N), C (AddMonoid.Coprod.inr n)\nmul : ∀ (x y : AddMonoid.Coprod M N), C x → C y → C (HAdd.hAdd x y)\n⊢ C m","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on {C : M ∗ N → Prop} (m : M ∗ N)\n    (inl : ∀ m, C (inl m)) (inr : ∀ n, C (inr n)) (mul : ∀ x y, C x → C y → C (x * y)) : C m :=\n  induction_on' m (by simpa using inl 1) (fun _ _ ↦ mul _ _ (inl _)) fun _ _ ↦ mul _ _ (inr _)\n\n"}
{"name":"AddMonoid.Coprod.clift_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf : AddMonoidHom (FreeAddMonoid (Sum M N)) P\nhM₁ : Eq (f (FreeAddMonoid.of (Sum.inl 0))) 0\nhN₁ : Eq (f (FreeAddMonoid.of (Sum.inr 0))) 0\nhM : ∀ (x y : M), Eq (f (FreeAddMonoid.of (Sum.inl (HAdd.hAdd x y)))) (f (HAdd.hAdd (FreeAddMonoid.of (Sum.inl x)) (FreeAddMonoid.of (Sum.inl y))))\nhN : ∀ (x y : N), Eq (f (FreeAddMonoid.of (Sum.inr (HAdd.hAdd x y)))) (f (HAdd.hAdd (FreeAddMonoid.of (Sum.inr x)) (FreeAddMonoid.of (Sum.inr y))))\nx : M\n⊢ Eq ((AddMonoid.Coprod.clift f hM₁ hN₁ hM hN) (AddMonoid.Coprod.inl x)) (f (FreeAddMonoid.of (Sum.inl x)))","decl":"@[to_additive (attr := simp)]\ntheorem clift_apply_inl (f : FreeMonoid (M ⊕ N) →* P) (hM₁ hN₁ hM hN) (x : M) :\n    clift f hM₁ hN₁ hM hN (inl x) = f (of (.inl x)) :=\n  rfl\n\n"}
{"name":"Monoid.Coprod.clift_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf : MonoidHom (FreeMonoid (Sum M N)) P\nhM₁ : Eq (f (FreeMonoid.of (Sum.inl 1))) 1\nhN₁ : Eq (f (FreeMonoid.of (Sum.inr 1))) 1\nhM : ∀ (x y : M), Eq (f (FreeMonoid.of (Sum.inl (HMul.hMul x y)))) (f (HMul.hMul (FreeMonoid.of (Sum.inl x)) (FreeMonoid.of (Sum.inl y))))\nhN : ∀ (x y : N), Eq (f (FreeMonoid.of (Sum.inr (HMul.hMul x y)))) (f (HMul.hMul (FreeMonoid.of (Sum.inr x)) (FreeMonoid.of (Sum.inr y))))\nx : M\n⊢ Eq ((Monoid.Coprod.clift f hM₁ hN₁ hM hN) (Monoid.Coprod.inl x)) (f (FreeMonoid.of (Sum.inl x)))","decl":"@[to_additive (attr := simp)]\ntheorem clift_apply_inl (f : FreeMonoid (M ⊕ N) →* P) (hM₁ hN₁ hM hN) (x : M) :\n    clift f hM₁ hN₁ hM hN (inl x) = f (of (.inl x)) :=\n  rfl\n\n"}
{"name":"AddMonoid.Coprod.clift_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf : AddMonoidHom (FreeAddMonoid (Sum M N)) P\nhM₁ : Eq (f (FreeAddMonoid.of (Sum.inl 0))) 0\nhN₁ : Eq (f (FreeAddMonoid.of (Sum.inr 0))) 0\nhM : ∀ (x y : M), Eq (f (FreeAddMonoid.of (Sum.inl (HAdd.hAdd x y)))) (f (HAdd.hAdd (FreeAddMonoid.of (Sum.inl x)) (FreeAddMonoid.of (Sum.inl y))))\nhN : ∀ (x y : N), Eq (f (FreeAddMonoid.of (Sum.inr (HAdd.hAdd x y)))) (f (HAdd.hAdd (FreeAddMonoid.of (Sum.inr x)) (FreeAddMonoid.of (Sum.inr y))))\nx : N\n⊢ Eq ((AddMonoid.Coprod.clift f hM₁ hN₁ hM hN) (AddMonoid.Coprod.inr x)) (f (FreeAddMonoid.of (Sum.inr x)))","decl":"@[to_additive (attr := simp)]\ntheorem clift_apply_inr (f : FreeMonoid (M ⊕ N) →* P) (hM₁ hN₁ hM hN) (x : N) :\n    clift f hM₁ hN₁ hM hN (inr x) = f (of (.inr x)) :=\n  rfl\n\n"}
{"name":"Monoid.Coprod.clift_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf : MonoidHom (FreeMonoid (Sum M N)) P\nhM₁ : Eq (f (FreeMonoid.of (Sum.inl 1))) 1\nhN₁ : Eq (f (FreeMonoid.of (Sum.inr 1))) 1\nhM : ∀ (x y : M), Eq (f (FreeMonoid.of (Sum.inl (HMul.hMul x y)))) (f (HMul.hMul (FreeMonoid.of (Sum.inl x)) (FreeMonoid.of (Sum.inl y))))\nhN : ∀ (x y : N), Eq (f (FreeMonoid.of (Sum.inr (HMul.hMul x y)))) (f (HMul.hMul (FreeMonoid.of (Sum.inr x)) (FreeMonoid.of (Sum.inr y))))\nx : N\n⊢ Eq ((Monoid.Coprod.clift f hM₁ hN₁ hM hN) (Monoid.Coprod.inr x)) (f (FreeMonoid.of (Sum.inr x)))","decl":"@[to_additive (attr := simp)]\ntheorem clift_apply_inr (f : FreeMonoid (M ⊕ N) →* P) (hM₁ hN₁ hM hN) (x : N) :\n    clift f hM₁ hN₁ hM hN (inr x) = f (of (.inr x)) :=\n  rfl\n\n"}
{"name":"Monoid.Coprod.clift_apply_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf : MonoidHom (FreeMonoid (Sum M N)) P\nhM₁ : Eq (f (FreeMonoid.of (Sum.inl 1))) 1\nhN₁ : Eq (f (FreeMonoid.of (Sum.inr 1))) 1\nhM : ∀ (x y : M), Eq (f (FreeMonoid.of (Sum.inl (HMul.hMul x y)))) (f (HMul.hMul (FreeMonoid.of (Sum.inl x)) (FreeMonoid.of (Sum.inl y))))\nhN : ∀ (x y : N), Eq (f (FreeMonoid.of (Sum.inr (HMul.hMul x y)))) (f (HMul.hMul (FreeMonoid.of (Sum.inr x)) (FreeMonoid.of (Sum.inr y))))\nw : FreeMonoid (Sum M N)\n⊢ Eq ((Monoid.Coprod.clift f hM₁ hN₁ hM hN) (Monoid.Coprod.mk w)) (f w)","decl":"@[to_additive (attr := simp)]\ntheorem clift_apply_mk (f : FreeMonoid (M ⊕ N) →* P) (hM₁ hN₁ hM hN w) :\n    clift f hM₁ hN₁ hM hN (mk w) = f w :=\n  rfl\n\n"}
{"name":"AddMonoid.Coprod.clift_apply_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf : AddMonoidHom (FreeAddMonoid (Sum M N)) P\nhM₁ : Eq (f (FreeAddMonoid.of (Sum.inl 0))) 0\nhN₁ : Eq (f (FreeAddMonoid.of (Sum.inr 0))) 0\nhM : ∀ (x y : M), Eq (f (FreeAddMonoid.of (Sum.inl (HAdd.hAdd x y)))) (f (HAdd.hAdd (FreeAddMonoid.of (Sum.inl x)) (FreeAddMonoid.of (Sum.inl y))))\nhN : ∀ (x y : N), Eq (f (FreeAddMonoid.of (Sum.inr (HAdd.hAdd x y)))) (f (HAdd.hAdd (FreeAddMonoid.of (Sum.inr x)) (FreeAddMonoid.of (Sum.inr y))))\nw : FreeAddMonoid (Sum M N)\n⊢ Eq ((AddMonoid.Coprod.clift f hM₁ hN₁ hM hN) (AddMonoid.Coprod.mk w)) (f w)","decl":"@[to_additive (attr := simp)]\ntheorem clift_apply_mk (f : FreeMonoid (M ⊕ N) →* P) (hM₁ hN₁ hM hN w) :\n    clift f hM₁ hN₁ hM hN (mk w) = f w :=\n  rfl\n\n"}
{"name":"AddMonoid.Coprod.clift_comp_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf : AddMonoidHom (FreeAddMonoid (Sum M N)) P\nhM₁ : Eq (f (FreeAddMonoid.of (Sum.inl 0))) 0\nhN₁ : Eq (f (FreeAddMonoid.of (Sum.inr 0))) 0\nhM : ∀ (x y : M), Eq (f (FreeAddMonoid.of (Sum.inl (HAdd.hAdd x y)))) (f (HAdd.hAdd (FreeAddMonoid.of (Sum.inl x)) (FreeAddMonoid.of (Sum.inl y))))\nhN : ∀ (x y : N), Eq (f (FreeAddMonoid.of (Sum.inr (HAdd.hAdd x y)))) (f (HAdd.hAdd (FreeAddMonoid.of (Sum.inr x)) (FreeAddMonoid.of (Sum.inr y))))\n⊢ Eq ((AddMonoid.Coprod.clift f hM₁ hN₁ hM hN).comp AddMonoid.Coprod.mk) f","decl":"@[to_additive (attr := simp)]\ntheorem clift_comp_mk (f : FreeMonoid (M ⊕ N) →* P) (hM₁ hN₁ hM hN) :\n    (clift f hM₁ hN₁ hM hN).comp mk = f :=\n  DFunLike.ext' rfl\n\n"}
{"name":"Monoid.Coprod.clift_comp_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf : MonoidHom (FreeMonoid (Sum M N)) P\nhM₁ : Eq (f (FreeMonoid.of (Sum.inl 1))) 1\nhN₁ : Eq (f (FreeMonoid.of (Sum.inr 1))) 1\nhM : ∀ (x y : M), Eq (f (FreeMonoid.of (Sum.inl (HMul.hMul x y)))) (f (HMul.hMul (FreeMonoid.of (Sum.inl x)) (FreeMonoid.of (Sum.inl y))))\nhN : ∀ (x y : N), Eq (f (FreeMonoid.of (Sum.inr (HMul.hMul x y)))) (f (HMul.hMul (FreeMonoid.of (Sum.inr x)) (FreeMonoid.of (Sum.inr y))))\n⊢ Eq ((Monoid.Coprod.clift f hM₁ hN₁ hM hN).comp Monoid.Coprod.mk) f","decl":"@[to_additive (attr := simp)]\ntheorem clift_comp_mk (f : FreeMonoid (M ⊕ N) →* P) (hM₁ hN₁ hM hN) :\n    (clift f hM₁ hN₁ hM hN).comp mk = f :=\n  DFunLike.ext' rfl\n\n"}
{"name":"Monoid.Coprod.mclosure_range_inl_union_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (Submonoid.closure (Union.union (Set.range ⇑Monoid.Coprod.inl) (Set.range ⇑Monoid.Coprod.inr))) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mclosure_range_inl_union_inr :\n    Submonoid.closure (range (inl : M →* M ∗ N) ∪ range (inr : N →* M ∗ N)) = ⊤ := by\n  rw [← mrange_mk, MonoidHom.mrange_eq_map, ← closure_range_of, MonoidHom.map_mclosure,\n    ← range_comp, Sum.range_eq]; rfl\n\n"}
{"name":"AddMonoid.Coprod.mclosure_range_inl_union_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddSubmonoid.closure (Union.union (Set.range ⇑AddMonoid.Coprod.inl) (Set.range ⇑AddMonoid.Coprod.inr))) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mclosure_range_inl_union_inr :\n    Submonoid.closure (range (inl : M →* M ∗ N) ∪ range (inr : N →* M ∗ N)) = ⊤ := by\n  rw [← mrange_mk, MonoidHom.mrange_eq_map, ← closure_range_of, MonoidHom.map_mclosure,\n    ← range_comp, Sum.range_eq]; rfl\n\n"}
{"name":"Monoid.Coprod.mrange_inl_sup_mrange_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (Max.max (MonoidHom.mrange Monoid.Coprod.inl) (MonoidHom.mrange Monoid.Coprod.inr)) Top.top","decl":"@[to_additive (attr := simp)] theorem mrange_inl_sup_mrange_inr :\n    MonoidHom.mrange (inl : M →* M ∗ N) ⊔ MonoidHom.mrange (inr : N →* M ∗ N) = ⊤ := by\n  rw [← mclosure_range_inl_union_inr, Submonoid.closure_union, ← MonoidHom.coe_mrange,\n    ← MonoidHom.coe_mrange, Submonoid.closure_eq, Submonoid.closure_eq]\n\n"}
{"name":"AddMonoid.Coprod.mrange_inl_sup_mrange_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (Max.max (AddMonoidHom.mrange AddMonoid.Coprod.inl) (AddMonoidHom.mrange AddMonoid.Coprod.inr)) Top.top","decl":"@[to_additive (attr := simp)] theorem mrange_inl_sup_mrange_inr :\n    MonoidHom.mrange (inl : M →* M ∗ N) ⊔ MonoidHom.mrange (inr : N →* M ∗ N) = ⊤ := by\n  rw [← mclosure_range_inl_union_inr, Submonoid.closure_union, ← MonoidHom.coe_mrange,\n    ← MonoidHom.coe_mrange, Submonoid.closure_eq, Submonoid.closure_eq]\n\n"}
{"name":"Monoid.Coprod.codisjoint_mrange_inl_mrange_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Codisjoint (MonoidHom.mrange Monoid.Coprod.inl) (MonoidHom.mrange Monoid.Coprod.inr)","decl":"@[to_additive]\ntheorem codisjoint_mrange_inl_mrange_inr :\n    Codisjoint (MonoidHom.mrange (inl : M →* M ∗ N)) (MonoidHom.mrange inr) :=\n  codisjoint_iff.2 mrange_inl_sup_mrange_inr\n\n"}
{"name":"AddMonoid.Coprod.codisjoint_mrange_inl_mrange_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Codisjoint (AddMonoidHom.mrange AddMonoid.Coprod.inl) (AddMonoidHom.mrange AddMonoid.Coprod.inr)","decl":"@[to_additive]\ntheorem codisjoint_mrange_inl_mrange_inr :\n    Codisjoint (MonoidHom.mrange (inl : M →* M ∗ N)) (MonoidHom.mrange inr) :=\n  codisjoint_iff.2 mrange_inl_sup_mrange_inr\n\n"}
{"name":"AddMonoid.Coprod.mrange_eq","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf : AddMonoidHom (AddMonoid.Coprod M N) P\n⊢ Eq (AddMonoidHom.mrange f) (Max.max (AddMonoidHom.mrange (f.comp AddMonoid.Coprod.inl)) (AddMonoidHom.mrange (f.comp AddMonoid.Coprod.inr)))","decl":"@[to_additive] theorem mrange_eq (f : M ∗ N →* P) :\n    MonoidHom.mrange f = MonoidHom.mrange (f.comp inl) ⊔ MonoidHom.mrange (f.comp inr) := by\n  rw [MonoidHom.mrange_eq_map, ← mrange_inl_sup_mrange_inr, Submonoid.map_sup, MonoidHom.map_mrange,\n    MonoidHom.map_mrange]\n\n"}
{"name":"Monoid.Coprod.mrange_eq","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf : MonoidHom (Monoid.Coprod M N) P\n⊢ Eq (MonoidHom.mrange f) (Max.max (MonoidHom.mrange (f.comp Monoid.Coprod.inl)) (MonoidHom.mrange (f.comp Monoid.Coprod.inr)))","decl":"@[to_additive] theorem mrange_eq (f : M ∗ N →* P) :\n    MonoidHom.mrange f = MonoidHom.mrange (f.comp inl) ⊔ MonoidHom.mrange (f.comp inr) := by\n  rw [MonoidHom.mrange_eq_map, ← mrange_inl_sup_mrange_inr, Submonoid.map_sup, MonoidHom.map_mrange,\n    MonoidHom.map_mrange]\n\n"}
{"name":"AddMonoid.Coprod.hom_ext","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf g : AddMonoidHom (AddMonoid.Coprod M N) P\nh₁ : Eq (f.comp AddMonoid.Coprod.inl) (g.comp AddMonoid.Coprod.inl)\nh₂ : Eq (f.comp AddMonoid.Coprod.inr) (g.comp AddMonoid.Coprod.inr)\n⊢ Eq f g","decl":"/-- Extensionality lemma for monoid homomorphisms `M ∗ N →* P`.\nIf two homomorphisms agree on the ranges of `Monoid.Coprod.inl` and `Monoid.Coprod.inr`,\nthen they are equal. -/\n@[to_additive (attr := ext 1100)\n  \"Extensionality lemma for additive monoid homomorphisms `AddMonoid.Coprod M N →+ P`.\n  If two homomorphisms agree on the ranges of `AddMonoid.Coprod.inl` and `AddMonoid.Coprod.inr`,\n  then they are equal.\"]\ntheorem hom_ext {f g : M ∗ N →* P} (h₁ : f.comp inl = g.comp inl) (h₂ : f.comp inr = g.comp inr) :\n    f = g :=\n  MonoidHom.eq_of_eqOn_denseM mclosure_range_inl_union_inr <| eqOn_union.2\n    ⟨eqOn_range.2 <| DFunLike.ext'_iff.1 h₁, eqOn_range.2 <| DFunLike.ext'_iff.1 h₂⟩\n\n"}
{"name":"Monoid.Coprod.hom_ext","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf g : MonoidHom (Monoid.Coprod M N) P\nh₁ : Eq (f.comp Monoid.Coprod.inl) (g.comp Monoid.Coprod.inl)\nh₂ : Eq (f.comp Monoid.Coprod.inr) (g.comp Monoid.Coprod.inr)\n⊢ Eq f g","decl":"/-- Extensionality lemma for monoid homomorphisms `M ∗ N →* P`.\nIf two homomorphisms agree on the ranges of `Monoid.Coprod.inl` and `Monoid.Coprod.inr`,\nthen they are equal. -/\n@[to_additive (attr := ext 1100)\n  \"Extensionality lemma for additive monoid homomorphisms `AddMonoid.Coprod M N →+ P`.\n  If two homomorphisms agree on the ranges of `AddMonoid.Coprod.inl` and `AddMonoid.Coprod.inr`,\n  then they are equal.\"]\ntheorem hom_ext {f g : M ∗ N →* P} (h₁ : f.comp inl = g.comp inl) (h₂ : f.comp inr = g.comp inr) :\n    f = g :=\n  MonoidHom.eq_of_eqOn_denseM mclosure_range_inl_union_inr <| eqOn_union.2\n    ⟨eqOn_range.2 <| DFunLike.ext'_iff.1 h₁, eqOn_range.2 <| DFunLike.ext'_iff.1 h₂⟩\n\n"}
{"name":"Monoid.Coprod.hom_ext_iff","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : MulOneClass P\nf g : MonoidHom (Monoid.Coprod M N) P\n⊢ Iff (Eq f g) (And (Eq (f.comp Monoid.Coprod.inl) (g.comp Monoid.Coprod.inl)) (Eq (f.comp Monoid.Coprod.inr) (g.comp Monoid.Coprod.inr)))","decl":"/-- Extensionality lemma for monoid homomorphisms `M ∗ N →* P`.\nIf two homomorphisms agree on the ranges of `Monoid.Coprod.inl` and `Monoid.Coprod.inr`,\nthen they are equal. -/\n@[to_additive (attr := ext 1100)\n  \"Extensionality lemma for additive monoid homomorphisms `AddMonoid.Coprod M N →+ P`.\n  If two homomorphisms agree on the ranges of `AddMonoid.Coprod.inl` and `AddMonoid.Coprod.inr`,\n  then they are equal.\"]\ntheorem hom_ext {f g : M ∗ N →* P} (h₁ : f.comp inl = g.comp inl) (h₂ : f.comp inr = g.comp inr) :\n    f = g :=\n  MonoidHom.eq_of_eqOn_denseM mclosure_range_inl_union_inr <| eqOn_union.2\n    ⟨eqOn_range.2 <| DFunLike.ext'_iff.1 h₁, eqOn_range.2 <| DFunLike.ext'_iff.1 h₂⟩\n\n"}
{"name":"AddMonoid.Coprod.hom_ext_iff","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddZeroClass P\nf g : AddMonoidHom (AddMonoid.Coprod M N) P\n⊢ Iff (Eq f g) (And (Eq (f.comp AddMonoid.Coprod.inl) (g.comp AddMonoid.Coprod.inl)) (Eq (f.comp AddMonoid.Coprod.inr) (g.comp AddMonoid.Coprod.inr)))","decl":"/-- Extensionality lemma for monoid homomorphisms `M ∗ N →* P`.\nIf two homomorphisms agree on the ranges of `Monoid.Coprod.inl` and `Monoid.Coprod.inr`,\nthen they are equal. -/\n@[to_additive (attr := ext 1100)\n  \"Extensionality lemma for additive monoid homomorphisms `AddMonoid.Coprod M N →+ P`.\n  If two homomorphisms agree on the ranges of `AddMonoid.Coprod.inl` and `AddMonoid.Coprod.inr`,\n  then they are equal.\"]\ntheorem hom_ext {f g : M ∗ N →* P} (h₁ : f.comp inl = g.comp inl) (h₂ : f.comp inr = g.comp inr) :\n    f = g :=\n  MonoidHom.eq_of_eqOn_denseM mclosure_range_inl_union_inr <| eqOn_union.2\n    ⟨eqOn_range.2 <| DFunLike.ext'_iff.1 h₁, eqOn_range.2 <| DFunLike.ext'_iff.1 h₂⟩\n\n"}
{"name":"Monoid.Coprod.clift_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (Monoid.Coprod.clift Monoid.Coprod.mk ⋯ ⋯ ⋯ ⋯) (MonoidHom.id (Monoid.Coprod M N))","decl":"@[to_additive (attr := simp)]\ntheorem clift_mk :\n    clift (mk : FreeMonoid (M ⊕ N) →* M ∗ N) (map_one inl) (map_one inr) (map_mul inl)\n      (map_mul inr) = .id _ :=\n  hom_ext rfl rfl\n\n"}
{"name":"AddMonoid.Coprod.clift_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoid.Coprod.clift AddMonoid.Coprod.mk ⋯ ⋯ ⋯ ⋯) (AddMonoidHom.id (AddMonoid.Coprod M N))","decl":"@[to_additive (attr := simp)]\ntheorem clift_mk :\n    clift (mk : FreeMonoid (M ⊕ N) →* M ∗ N) (map_one inl) (map_one inr) (map_mul inl)\n      (map_mul inr) = .id _ :=\n  hom_ext rfl rfl\n\n"}
{"name":"AddMonoid.Coprod.map_mk_ofList","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddZeroClass M'\ninst✝ : AddZeroClass N'\nf : AddMonoidHom M M'\ng : AddMonoidHom N N'\nl : List (Sum M N)\n⊢ Eq ((AddMonoid.Coprod.map f g) (AddMonoid.Coprod.mk (FreeAddMonoid.ofList l))) (AddMonoid.Coprod.mk (FreeAddMonoid.ofList (List.map (Sum.map ⇑f ⇑g) l)))","decl":"@[to_additive (attr := simp)]\ntheorem map_mk_ofList (f : M →* M') (g : N →* N') (l : List (M ⊕ N)) :\n    map f g (mk (ofList l)) = mk (ofList (l.map (Sum.map f g))) :=\n  rfl\n\n"}
{"name":"Monoid.Coprod.map_mk_ofList","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : MulOneClass M'\ninst✝ : MulOneClass N'\nf : MonoidHom M M'\ng : MonoidHom N N'\nl : List (Sum M N)\n⊢ Eq ((Monoid.Coprod.map f g) (Monoid.Coprod.mk (FreeMonoid.ofList l))) (Monoid.Coprod.mk (FreeMonoid.ofList (List.map (Sum.map ⇑f ⇑g) l)))","decl":"@[to_additive (attr := simp)]\ntheorem map_mk_ofList (f : M →* M') (g : N →* N') (l : List (M ⊕ N)) :\n    map f g (mk (ofList l)) = mk (ofList (l.map (Sum.map f g))) :=\n  rfl\n\n"}
{"name":"Monoid.Coprod.map_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : MulOneClass M'\ninst✝ : MulOneClass N'\nf : MonoidHom M M'\ng : MonoidHom N N'\nx : M\n⊢ Eq ((Monoid.Coprod.map f g) (Monoid.Coprod.inl x)) (Monoid.Coprod.inl (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_apply_inl (f : M →* M') (g : N →* N') (x : M) : map f g (inl x) = inl (f x) := rfl\n\n"}
{"name":"AddMonoid.Coprod.map_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddZeroClass M'\ninst✝ : AddZeroClass N'\nf : AddMonoidHom M M'\ng : AddMonoidHom N N'\nx : M\n⊢ Eq ((AddMonoid.Coprod.map f g) (AddMonoid.Coprod.inl x)) (AddMonoid.Coprod.inl (f x))","decl":"@[to_additive (attr := simp)]\ntheorem map_apply_inl (f : M →* M') (g : N →* N') (x : M) : map f g (inl x) = inl (f x) := rfl\n\n"}
{"name":"Monoid.Coprod.map_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : MulOneClass M'\ninst✝ : MulOneClass N'\nf : MonoidHom M M'\ng : MonoidHom N N'\nx : N\n⊢ Eq ((Monoid.Coprod.map f g) (Monoid.Coprod.inr x)) (Monoid.Coprod.inr (g x))","decl":"@[to_additive (attr := simp)]\ntheorem map_apply_inr (f : M →* M') (g : N →* N') (x : N) : map f g (inr x) = inr (g x) := rfl\n\n"}
{"name":"AddMonoid.Coprod.map_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddZeroClass M'\ninst✝ : AddZeroClass N'\nf : AddMonoidHom M M'\ng : AddMonoidHom N N'\nx : N\n⊢ Eq ((AddMonoid.Coprod.map f g) (AddMonoid.Coprod.inr x)) (AddMonoid.Coprod.inr (g x))","decl":"@[to_additive (attr := simp)]\ntheorem map_apply_inr (f : M →* M') (g : N →* N') (x : N) : map f g (inr x) = inr (g x) := rfl\n\n"}
{"name":"Monoid.Coprod.map_comp_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : MulOneClass M'\ninst✝ : MulOneClass N'\nf : MonoidHom M M'\ng : MonoidHom N N'\n⊢ Eq ((Monoid.Coprod.map f g).comp Monoid.Coprod.inl) (Monoid.Coprod.inl.comp f)","decl":"@[to_additive (attr := simp)]\ntheorem map_comp_inl (f : M →* M') (g : N →* N') : (map f g).comp inl = inl.comp f := rfl\n\n"}
{"name":"AddMonoid.Coprod.map_comp_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddZeroClass M'\ninst✝ : AddZeroClass N'\nf : AddMonoidHom M M'\ng : AddMonoidHom N N'\n⊢ Eq ((AddMonoid.Coprod.map f g).comp AddMonoid.Coprod.inl) (AddMonoid.Coprod.inl.comp f)","decl":"@[to_additive (attr := simp)]\ntheorem map_comp_inl (f : M →* M') (g : N →* N') : (map f g).comp inl = inl.comp f := rfl\n\n"}
{"name":"AddMonoid.Coprod.map_comp_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddZeroClass M'\ninst✝ : AddZeroClass N'\nf : AddMonoidHom M M'\ng : AddMonoidHom N N'\n⊢ Eq ((AddMonoid.Coprod.map f g).comp AddMonoid.Coprod.inr) (AddMonoid.Coprod.inr.comp g)","decl":"@[to_additive (attr := simp)]\ntheorem map_comp_inr (f : M →* M') (g : N →* N') : (map f g).comp inr = inr.comp g := rfl\n\n"}
{"name":"Monoid.Coprod.map_comp_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : MulOneClass M'\ninst✝ : MulOneClass N'\nf : MonoidHom M M'\ng : MonoidHom N N'\n⊢ Eq ((Monoid.Coprod.map f g).comp Monoid.Coprod.inr) (Monoid.Coprod.inr.comp g)","decl":"@[to_additive (attr := simp)]\ntheorem map_comp_inr (f : M →* M') (g : N →* N') : (map f g).comp inr = inr.comp g := rfl\n\n"}
{"name":"AddMonoid.Coprod.map_id_id","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoid.Coprod.map (AddMonoidHom.id M) (AddMonoidHom.id N)) (AddMonoidHom.id (AddMonoid.Coprod M N))","decl":"@[to_additive (attr := simp)]\ntheorem map_id_id : map (.id M) (.id N) = .id (M ∗ N) := hom_ext rfl rfl\n\n"}
{"name":"Monoid.Coprod.map_id_id","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (Monoid.Coprod.map (MonoidHom.id M) (MonoidHom.id N)) (MonoidHom.id (Monoid.Coprod M N))","decl":"@[to_additive (attr := simp)]\ntheorem map_id_id : map (.id M) (.id N) = .id (M ∗ N) := hom_ext rfl rfl\n\n"}
{"name":"Monoid.Coprod.map_comp_map","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝⁵ : MulOneClass M\ninst✝⁴ : MulOneClass N\ninst✝³ : MulOneClass M'\ninst✝² : MulOneClass N'\nM'' : Type u_6\nN'' : Type u_7\ninst✝¹ : MulOneClass M''\ninst✝ : MulOneClass N''\nf' : MonoidHom M' M''\ng' : MonoidHom N' N''\nf : MonoidHom M M'\ng : MonoidHom N N'\n⊢ Eq ((Monoid.Coprod.map f' g').comp (Monoid.Coprod.map f g)) (Monoid.Coprod.map (f'.comp f) (g'.comp g))","decl":"@[to_additive]\ntheorem map_comp_map {M'' N''} [MulOneClass M''] [MulOneClass N''] (f' : M' →* M'') (g' : N' →* N'')\n    (f : M →* M') (g : N →* N') : (map f' g').comp (map f g) = map (f'.comp f) (g'.comp g) :=\n  hom_ext rfl rfl\n\n"}
{"name":"AddMonoid.Coprod.map_comp_map","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝⁵ : AddZeroClass M\ninst✝⁴ : AddZeroClass N\ninst✝³ : AddZeroClass M'\ninst✝² : AddZeroClass N'\nM'' : Type u_6\nN'' : Type u_7\ninst✝¹ : AddZeroClass M''\ninst✝ : AddZeroClass N''\nf' : AddMonoidHom M' M''\ng' : AddMonoidHom N' N''\nf : AddMonoidHom M M'\ng : AddMonoidHom N N'\n⊢ Eq ((AddMonoid.Coprod.map f' g').comp (AddMonoid.Coprod.map f g)) (AddMonoid.Coprod.map (f'.comp f) (g'.comp g))","decl":"@[to_additive]\ntheorem map_comp_map {M'' N''} [MulOneClass M''] [MulOneClass N''] (f' : M' →* M'') (g' : N' →* N'')\n    (f : M →* M') (g : N →* N') : (map f' g').comp (map f g) = map (f'.comp f) (g'.comp g) :=\n  hom_ext rfl rfl\n\n"}
{"name":"Monoid.Coprod.map_map","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝⁵ : MulOneClass M\ninst✝⁴ : MulOneClass N\ninst✝³ : MulOneClass M'\ninst✝² : MulOneClass N'\nM'' : Type u_6\nN'' : Type u_7\ninst✝¹ : MulOneClass M''\ninst✝ : MulOneClass N''\nf' : MonoidHom M' M''\ng' : MonoidHom N' N''\nf : MonoidHom M M'\ng : MonoidHom N N'\nx : Monoid.Coprod M N\n⊢ Eq ((Monoid.Coprod.map f' g') ((Monoid.Coprod.map f g) x)) ((Monoid.Coprod.map (f'.comp f) (g'.comp g)) x)","decl":"@[to_additive]\ntheorem map_map {M'' N''} [MulOneClass M''] [MulOneClass N''] (f' : M' →* M'') (g' : N' →* N'')\n    (f : M →* M') (g : N →* N') (x : M ∗ N) :\n    map f' g' (map f g x) = map (f'.comp f) (g'.comp g) x :=\n  DFunLike.congr_fun (map_comp_map f' g' f g) x\n\n"}
{"name":"AddMonoid.Coprod.map_map","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝⁵ : AddZeroClass M\ninst✝⁴ : AddZeroClass N\ninst✝³ : AddZeroClass M'\ninst✝² : AddZeroClass N'\nM'' : Type u_6\nN'' : Type u_7\ninst✝¹ : AddZeroClass M''\ninst✝ : AddZeroClass N''\nf' : AddMonoidHom M' M''\ng' : AddMonoidHom N' N''\nf : AddMonoidHom M M'\ng : AddMonoidHom N N'\nx : AddMonoid.Coprod M N\n⊢ Eq ((AddMonoid.Coprod.map f' g') ((AddMonoid.Coprod.map f g) x)) ((AddMonoid.Coprod.map (f'.comp f) (g'.comp g)) x)","decl":"@[to_additive]\ntheorem map_map {M'' N''} [MulOneClass M''] [MulOneClass N''] (f' : M' →* M'') (g' : N' →* N'')\n    (f : M →* M') (g : N →* N') (x : M ∗ N) :\n    map f' g' (map f g x) = map (f'.comp f) (g'.comp g) x :=\n  DFunLike.congr_fun (map_comp_map f' g' f g) x\n\n"}
{"name":"AddMonoid.Coprod.swap_comp_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq ((AddMonoid.Coprod.swap M N).comp (AddMonoid.Coprod.swap N M)) (AddMonoidHom.id (AddMonoid.Coprod N M))","decl":"@[to_additive (attr := simp)]\ntheorem swap_comp_swap : (swap M N).comp (swap N M) = .id _ := hom_ext rfl rfl\n\n"}
{"name":"Monoid.Coprod.swap_comp_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq ((Monoid.Coprod.swap M N).comp (Monoid.Coprod.swap N M)) (MonoidHom.id (Monoid.Coprod N M))","decl":"@[to_additive (attr := simp)]\ntheorem swap_comp_swap : (swap M N).comp (swap N M) = .id _ := hom_ext rfl rfl\n\n"}
{"name":"AddMonoid.Coprod.swap_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nx : AddMonoid.Coprod M N\n⊢ Eq ((AddMonoid.Coprod.swap N M) ((AddMonoid.Coprod.swap M N) x)) x","decl":"@[to_additive (attr := simp)]\ntheorem swap_swap (x : M ∗ N) : swap N M (swap M N x) = x :=\n  DFunLike.congr_fun (swap_comp_swap _ _) x\n\n"}
{"name":"Monoid.Coprod.swap_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nx : Monoid.Coprod M N\n⊢ Eq ((Monoid.Coprod.swap N M) ((Monoid.Coprod.swap M N) x)) x","decl":"@[to_additive (attr := simp)]\ntheorem swap_swap (x : M ∗ N) : swap N M (swap M N x) = x :=\n  DFunLike.congr_fun (swap_comp_swap _ _) x\n\n"}
{"name":"AddMonoid.Coprod.swap_comp_map","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddZeroClass M'\ninst✝ : AddZeroClass N'\nf : AddMonoidHom M M'\ng : AddMonoidHom N N'\n⊢ Eq ((AddMonoid.Coprod.swap M' N').comp (AddMonoid.Coprod.map f g)) ((AddMonoid.Coprod.map g f).comp (AddMonoid.Coprod.swap M N))","decl":"@[to_additive]\ntheorem swap_comp_map (f : M →* M') (g : N →* N') :\n    (swap M' N').comp (map f g) = (map g f).comp (swap M N) :=\n  hom_ext rfl rfl\n\n"}
{"name":"Monoid.Coprod.swap_comp_map","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : MulOneClass M'\ninst✝ : MulOneClass N'\nf : MonoidHom M M'\ng : MonoidHom N N'\n⊢ Eq ((Monoid.Coprod.swap M' N').comp (Monoid.Coprod.map f g)) ((Monoid.Coprod.map g f).comp (Monoid.Coprod.swap M N))","decl":"@[to_additive]\ntheorem swap_comp_map (f : M →* M') (g : N →* N') :\n    (swap M' N').comp (map f g) = (map g f).comp (swap M N) :=\n  hom_ext rfl rfl\n\n"}
{"name":"Monoid.Coprod.swap_map","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : MulOneClass M'\ninst✝ : MulOneClass N'\nf : MonoidHom M M'\ng : MonoidHom N N'\nx : Monoid.Coprod M N\n⊢ Eq ((Monoid.Coprod.swap M' N') ((Monoid.Coprod.map f g) x)) ((Monoid.Coprod.map g f) ((Monoid.Coprod.swap M N) x))","decl":"@[to_additive]\ntheorem swap_map (f : M →* M') (g : N →* N') (x : M ∗ N) :\n    swap M' N' (map f g x) = map g f (swap M N x) :=\n  DFunLike.congr_fun (swap_comp_map f g) x\n\n"}
{"name":"AddMonoid.Coprod.swap_map","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddZeroClass M'\ninst✝ : AddZeroClass N'\nf : AddMonoidHom M M'\ng : AddMonoidHom N N'\nx : AddMonoid.Coprod M N\n⊢ Eq ((AddMonoid.Coprod.swap M' N') ((AddMonoid.Coprod.map f g) x)) ((AddMonoid.Coprod.map g f) ((AddMonoid.Coprod.swap M N) x))","decl":"@[to_additive]\ntheorem swap_map (f : M →* M') (g : N →* N') (x : M ∗ N) :\n    swap M' N' (map f g x) = map g f (swap M N x) :=\n  DFunLike.congr_fun (swap_comp_map f g) x\n\n"}
{"name":"Monoid.Coprod.swap_comp_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq ((Monoid.Coprod.swap M N).comp Monoid.Coprod.inl) Monoid.Coprod.inr","decl":"@[to_additive (attr := simp)] theorem swap_comp_inl : (swap M N).comp inl = inr := rfl\n"}
{"name":"AddMonoid.Coprod.swap_comp_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq ((AddMonoid.Coprod.swap M N).comp AddMonoid.Coprod.inl) AddMonoid.Coprod.inr","decl":"@[to_additive (attr := simp)] theorem swap_comp_inl : (swap M N).comp inl = inr := rfl\n"}
{"name":"Monoid.Coprod.swap_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nx : M\n⊢ Eq ((Monoid.Coprod.swap M N) (Monoid.Coprod.inl x)) (Monoid.Coprod.inr x)","decl":"@[to_additive (attr := simp)] theorem swap_inl (x : M) : swap M N (inl x) = inr x := rfl\n"}
{"name":"AddMonoid.Coprod.swap_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nx : M\n⊢ Eq ((AddMonoid.Coprod.swap M N) (AddMonoid.Coprod.inl x)) (AddMonoid.Coprod.inr x)","decl":"@[to_additive (attr := simp)] theorem swap_inl (x : M) : swap M N (inl x) = inr x := rfl\n"}
{"name":"AddMonoid.Coprod.swap_comp_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq ((AddMonoid.Coprod.swap M N).comp AddMonoid.Coprod.inr) AddMonoid.Coprod.inl","decl":"@[to_additive (attr := simp)] theorem swap_comp_inr : (swap M N).comp inr = inl := rfl\n"}
{"name":"Monoid.Coprod.swap_comp_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq ((Monoid.Coprod.swap M N).comp Monoid.Coprod.inr) Monoid.Coprod.inl","decl":"@[to_additive (attr := simp)] theorem swap_comp_inr : (swap M N).comp inr = inl := rfl\n"}
{"name":"Monoid.Coprod.swap_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nx : N\n⊢ Eq ((Monoid.Coprod.swap M N) (Monoid.Coprod.inr x)) (Monoid.Coprod.inl x)","decl":"@[to_additive (attr := simp)] theorem swap_inr (x : N) : swap M N (inr x) = inl x := rfl\n\n"}
{"name":"AddMonoid.Coprod.swap_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nx : N\n⊢ Eq ((AddMonoid.Coprod.swap M N) (AddMonoid.Coprod.inr x)) (AddMonoid.Coprod.inl x)","decl":"@[to_additive (attr := simp)] theorem swap_inr (x : N) : swap M N (inr x) = inl x := rfl\n\n"}
{"name":"Monoid.Coprod.swap_injective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Function.Injective ⇑(Monoid.Coprod.swap M N)","decl":"@[to_additive]\ntheorem swap_injective : Injective (swap M N) := LeftInverse.injective swap_swap\n\n"}
{"name":"AddMonoid.Coprod.swap_injective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Function.Injective ⇑(AddMonoid.Coprod.swap M N)","decl":"@[to_additive]\ntheorem swap_injective : Injective (swap M N) := LeftInverse.injective swap_swap\n\n"}
{"name":"Monoid.Coprod.swap_inj","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nx y : Monoid.Coprod M N\n⊢ Iff (Eq ((Monoid.Coprod.swap M N) x) ((Monoid.Coprod.swap M N) y)) (Eq x y)","decl":"@[to_additive (attr := simp)]\ntheorem swap_inj {x y : M ∗ N} : swap M N x = swap M N y ↔ x = y := swap_injective.eq_iff\n\n"}
{"name":"AddMonoid.Coprod.swap_inj","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nx y : AddMonoid.Coprod M N\n⊢ Iff (Eq ((AddMonoid.Coprod.swap M N) x) ((AddMonoid.Coprod.swap M N) y)) (Eq x y)","decl":"@[to_additive (attr := simp)]\ntheorem swap_inj {x y : M ∗ N} : swap M N x = swap M N y ↔ x = y := swap_injective.eq_iff\n\n"}
{"name":"AddMonoid.Coprod.swap_eq_zero","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nx : AddMonoid.Coprod M N\n⊢ Iff (Eq ((AddMonoid.Coprod.swap M N) x) 0) (Eq x 0)","decl":"@[to_additive (attr := simp)]\ntheorem swap_eq_one {x : M ∗ N} : swap M N x = 1 ↔ x = 1 := swap_injective.eq_iff' (map_one _)\n\n"}
{"name":"Monoid.Coprod.swap_eq_one","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nx : Monoid.Coprod M N\n⊢ Iff (Eq ((Monoid.Coprod.swap M N) x) 1) (Eq x 1)","decl":"@[to_additive (attr := simp)]\ntheorem swap_eq_one {x : M ∗ N} : swap M N x = 1 ↔ x = 1 := swap_injective.eq_iff' (map_one _)\n\n"}
{"name":"Monoid.Coprod.swap_surjective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Function.Surjective ⇑(Monoid.Coprod.swap M N)","decl":"@[to_additive]\ntheorem swap_surjective : Surjective (swap M N) := LeftInverse.surjective swap_swap\n\n"}
{"name":"AddMonoid.Coprod.swap_surjective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Function.Surjective ⇑(AddMonoid.Coprod.swap M N)","decl":"@[to_additive]\ntheorem swap_surjective : Surjective (swap M N) := LeftInverse.surjective swap_swap\n\n"}
{"name":"Monoid.Coprod.swap_bijective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Function.Bijective ⇑(Monoid.Coprod.swap M N)","decl":"@[to_additive]\ntheorem swap_bijective : Bijective (swap M N) := ⟨swap_injective, swap_surjective⟩\n\n"}
{"name":"AddMonoid.Coprod.swap_bijective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Function.Bijective ⇑(AddMonoid.Coprod.swap M N)","decl":"@[to_additive]\ntheorem swap_bijective : Bijective (swap M N) := ⟨swap_injective, swap_surjective⟩\n\n"}
{"name":"AddMonoid.Coprod.mker_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mker (AddMonoid.Coprod.swap M N)) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem mker_swap : MonoidHom.mker (swap M N) = ⊥ := Submonoid.ext fun _ ↦ swap_eq_one\n\n"}
{"name":"Monoid.Coprod.mker_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mker (Monoid.Coprod.swap M N)) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem mker_swap : MonoidHom.mker (swap M N) = ⊥ := Submonoid.ext fun _ ↦ swap_eq_one\n\n"}
{"name":"Monoid.Coprod.mrange_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq (MonoidHom.mrange (Monoid.Coprod.swap M N)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mrange_swap : MonoidHom.mrange (swap M N) = ⊤ :=\n  MonoidHom.mrange_eq_top_of_surjective _ swap_surjective\n\n"}
{"name":"AddMonoid.Coprod.mrange_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq (AddMonoidHom.mrange (AddMonoid.Coprod.swap M N)) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem mrange_swap : MonoidHom.mrange (swap M N) = ⊤ :=\n  MonoidHom.mrange_eq_top_of_surjective _ swap_surjective\n\n"}
{"name":"Monoid.Coprod.lift_apply_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\nx : FreeMonoid (Sum M N)\n⊢ Eq ((Monoid.Coprod.lift f g) (Monoid.Coprod.mk x)) ((FreeMonoid.lift (Sum.elim ⇑f ⇑g)) x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_apply_mk (f : M →* P) (g : N →* P) (x : FreeMonoid (M ⊕ N)) :\n    lift f g (mk x) = FreeMonoid.lift (Sum.elim f g) x :=\n  rfl\n\n"}
{"name":"AddMonoid.Coprod.lift_apply_mk","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\nx : FreeAddMonoid (Sum M N)\n⊢ Eq ((AddMonoid.Coprod.lift f g) (AddMonoid.Coprod.mk x)) ((FreeAddMonoid.lift (Sum.elim ⇑f ⇑g)) x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_apply_mk (f : M →* P) (g : N →* P) (x : FreeMonoid (M ⊕ N)) :\n    lift f g (mk x) = FreeMonoid.lift (Sum.elim f g) x :=\n  rfl\n\n"}
{"name":"AddMonoid.Coprod.lift_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\nx : M\n⊢ Eq ((AddMonoid.Coprod.lift f g) (AddMonoid.Coprod.inl x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_apply_inl (f : M →* P) (g : N →* P) (x : M) : lift f g (inl x) = f x :=\n  rfl\n\n"}
{"name":"Monoid.Coprod.lift_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\nx : M\n⊢ Eq ((Monoid.Coprod.lift f g) (Monoid.Coprod.inl x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_apply_inl (f : M →* P) (g : N →* P) (x : M) : lift f g (inl x) = f x :=\n  rfl\n\n"}
{"name":"AddMonoid.Coprod.lift_unique","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\nfg : AddMonoidHom (AddMonoid.Coprod M N) P\nh₁ : Eq (fg.comp AddMonoid.Coprod.inl) f\nh₂ : Eq (fg.comp AddMonoid.Coprod.inr) g\n⊢ Eq fg (AddMonoid.Coprod.lift f g)","decl":"@[to_additive]\ntheorem lift_unique {f : M →* P} {g : N →* P} {fg : M ∗ N →* P} (h₁ : fg.comp inl = f)\n    (h₂ : fg.comp inr = g) : fg = lift f g :=\n  hom_ext h₁ h₂\n\n"}
{"name":"Monoid.Coprod.lift_unique","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\nfg : MonoidHom (Monoid.Coprod M N) P\nh₁ : Eq (fg.comp Monoid.Coprod.inl) f\nh₂ : Eq (fg.comp Monoid.Coprod.inr) g\n⊢ Eq fg (Monoid.Coprod.lift f g)","decl":"@[to_additive]\ntheorem lift_unique {f : M →* P} {g : N →* P} {fg : M ∗ N →* P} (h₁ : fg.comp inl = f)\n    (h₂ : fg.comp inr = g) : fg = lift f g :=\n  hom_ext h₁ h₂\n\n"}
{"name":"AddMonoid.Coprod.lift_comp_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\n⊢ Eq ((AddMonoid.Coprod.lift f g).comp AddMonoid.Coprod.inl) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_inl (f : M →* P) (g : N →* P) : (lift f g).comp inl = f := rfl\n\n"}
{"name":"Monoid.Coprod.lift_comp_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\n⊢ Eq ((Monoid.Coprod.lift f g).comp Monoid.Coprod.inl) f","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_inl (f : M →* P) (g : N →* P) : (lift f g).comp inl = f := rfl\n\n"}
{"name":"Monoid.Coprod.lift_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\nx : N\n⊢ Eq ((Monoid.Coprod.lift f g) (Monoid.Coprod.inr x)) (g x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_apply_inr (f : M →* P) (g : N →* P) (x : N) : lift f g (inr x) = g x :=\n  rfl\n\n"}
{"name":"AddMonoid.Coprod.lift_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\nx : N\n⊢ Eq ((AddMonoid.Coprod.lift f g) (AddMonoid.Coprod.inr x)) (g x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_apply_inr (f : M →* P) (g : N →* P) (x : N) : lift f g (inr x) = g x :=\n  rfl\n\n"}
{"name":"Monoid.Coprod.lift_comp_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\n⊢ Eq ((Monoid.Coprod.lift f g).comp Monoid.Coprod.inr) g","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_inr (f : M →* P) (g : N →* P) : (lift f g).comp inr = g := rfl\n\n"}
{"name":"AddMonoid.Coprod.lift_comp_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\n⊢ Eq ((AddMonoid.Coprod.lift f g).comp AddMonoid.Coprod.inr) g","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_inr (f : M →* P) (g : N →* P) : (lift f g).comp inr = g := rfl\n\n"}
{"name":"Monoid.Coprod.lift_comp_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\n⊢ Eq ((Monoid.Coprod.lift f g).comp (Monoid.Coprod.swap N M)) (Monoid.Coprod.lift g f)","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_swap (f : M →* P) (g : N →* P) : (lift f g).comp (swap N M) = lift g f :=\n  hom_ext rfl rfl\n\n"}
{"name":"AddMonoid.Coprod.lift_comp_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\n⊢ Eq ((AddMonoid.Coprod.lift f g).comp (AddMonoid.Coprod.swap N M)) (AddMonoid.Coprod.lift g f)","decl":"@[to_additive (attr := simp)]\ntheorem lift_comp_swap (f : M →* P) (g : N →* P) : (lift f g).comp (swap N M) = lift g f :=\n  hom_ext rfl rfl\n\n"}
{"name":"AddMonoid.Coprod.lift_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\nx : AddMonoid.Coprod N M\n⊢ Eq ((AddMonoid.Coprod.lift f g) ((AddMonoid.Coprod.swap N M) x)) ((AddMonoid.Coprod.lift g f) x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_swap (f : M →* P) (g : N →* P) (x : N ∗ M) : lift f g (swap N M x) = lift g f x :=\n  DFunLike.congr_fun (lift_comp_swap f g) x\n\n"}
{"name":"Monoid.Coprod.lift_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\nx : Monoid.Coprod N M\n⊢ Eq ((Monoid.Coprod.lift f g) ((Monoid.Coprod.swap N M) x)) ((Monoid.Coprod.lift g f) x)","decl":"@[to_additive (attr := simp)]\ntheorem lift_swap (f : M →* P) (g : N →* P) (x : N ∗ M) : lift f g (swap N M x) = lift g f x :=\n  DFunLike.congr_fun (lift_comp_swap f g) x\n\n"}
{"name":"AddMonoid.Coprod.comp_lift","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddMonoid P\nP' : Type u_4\ninst✝ : AddMonoid P'\nf : AddMonoidHom P P'\ng₁ : AddMonoidHom M P\ng₂ : AddMonoidHom N P\n⊢ Eq (f.comp (AddMonoid.Coprod.lift g₁ g₂)) (AddMonoid.Coprod.lift (f.comp g₁) (f.comp g₂))","decl":"@[to_additive]\ntheorem comp_lift {P' : Type*} [Monoid P'] (f : P →* P') (g₁ : M →* P) (g₂ : N →* P) :\n    f.comp (lift g₁ g₂) = lift (f.comp g₁) (f.comp g₂) :=\n  hom_ext (by rw [MonoidHom.comp_assoc, lift_comp_inl, lift_comp_inl]) <| by\n    rw [MonoidHom.comp_assoc, lift_comp_inr, lift_comp_inr]\n\n"}
{"name":"Monoid.Coprod.comp_lift","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : Monoid P\nP' : Type u_4\ninst✝ : Monoid P'\nf : MonoidHom P P'\ng₁ : MonoidHom M P\ng₂ : MonoidHom N P\n⊢ Eq (f.comp (Monoid.Coprod.lift g₁ g₂)) (Monoid.Coprod.lift (f.comp g₁) (f.comp g₂))","decl":"@[to_additive]\ntheorem comp_lift {P' : Type*} [Monoid P'] (f : P →* P') (g₁ : M →* P) (g₂ : N →* P) :\n    f.comp (lift g₁ g₂) = lift (f.comp g₁) (f.comp g₂) :=\n  hom_ext (by rw [MonoidHom.comp_assoc, lift_comp_inl, lift_comp_inl]) <| by\n    rw [MonoidHom.comp_assoc, lift_comp_inr, lift_comp_inr]\n\n"}
{"name":"AddMonoid.Coprod.mrange_lift","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddMonoid P\nf : AddMonoidHom M P\ng : AddMonoidHom N P\n⊢ Eq (AddMonoidHom.mrange (AddMonoid.Coprod.lift f g)) (Max.max (AddMonoidHom.mrange f) (AddMonoidHom.mrange g))","decl":"@[to_additive (attr := simp)]\ntheorem mrange_lift (f : M →* P) (g : N →* P) :\n    MonoidHom.mrange (lift f g) = MonoidHom.mrange f ⊔ MonoidHom.mrange g := by\n  simp [mrange_eq]\n\n"}
{"name":"Monoid.Coprod.mrange_lift","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : Monoid P\nf : MonoidHom M P\ng : MonoidHom N P\n⊢ Eq (MonoidHom.mrange (Monoid.Coprod.lift f g)) (Max.max (MonoidHom.mrange f) (MonoidHom.mrange g))","decl":"@[to_additive (attr := simp)]\ntheorem mrange_lift (f : M →* P) (g : N →* P) :\n    MonoidHom.mrange (lift f g) = MonoidHom.mrange f ⊔ MonoidHom.mrange g := by\n  simp [mrange_eq]\n\n"}
{"name":"Monoid.Coprod.fst_comp_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq (Monoid.Coprod.fst.comp Monoid.Coprod.inl) (MonoidHom.id M)","decl":"@[to_additive (attr := simp)] theorem fst_comp_inl : (fst : M ∗ N →* M).comp inl = .id _ := rfl\n"}
{"name":"AddMonoid.Coprod.fst_comp_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq (AddMonoid.Coprod.fst.comp AddMonoid.Coprod.inl) (AddMonoidHom.id M)","decl":"@[to_additive (attr := simp)] theorem fst_comp_inl : (fst : M ∗ N →* M).comp inl = .id _ := rfl\n"}
{"name":"AddMonoid.Coprod.fst_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nx : M\n⊢ Eq (AddMonoid.Coprod.fst (AddMonoid.Coprod.inl x)) x","decl":"@[to_additive (attr := simp)] theorem fst_apply_inl (x : M) : fst (inl x : M ∗ N) = x := rfl\n"}
{"name":"Monoid.Coprod.fst_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nx : M\n⊢ Eq (Monoid.Coprod.fst (Monoid.Coprod.inl x)) x","decl":"@[to_additive (attr := simp)] theorem fst_apply_inl (x : M) : fst (inl x : M ∗ N) = x := rfl\n"}
{"name":"Monoid.Coprod.fst_comp_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq (Monoid.Coprod.fst.comp Monoid.Coprod.inr) 1","decl":"@[to_additive (attr := simp)] theorem fst_comp_inr : (fst : M ∗ N →* M).comp inr = 1 := rfl\n"}
{"name":"AddMonoid.Coprod.fst_comp_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq (AddMonoid.Coprod.fst.comp AddMonoid.Coprod.inr) 0","decl":"@[to_additive (attr := simp)] theorem fst_comp_inr : (fst : M ∗ N →* M).comp inr = 1 := rfl\n"}
{"name":"Monoid.Coprod.fst_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nx : N\n⊢ Eq (Monoid.Coprod.fst (Monoid.Coprod.inr x)) 1","decl":"@[to_additive (attr := simp)] theorem fst_apply_inr (x : N) : fst (inr x : M ∗ N) = 1 := rfl\n"}
{"name":"AddMonoid.Coprod.fst_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nx : N\n⊢ Eq (AddMonoid.Coprod.fst (AddMonoid.Coprod.inr x)) 0","decl":"@[to_additive (attr := simp)] theorem fst_apply_inr (x : N) : fst (inr x : M ∗ N) = 1 := rfl\n"}
{"name":"Monoid.Coprod.snd_comp_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq (Monoid.Coprod.snd.comp Monoid.Coprod.inl) 1","decl":"@[to_additive (attr := simp)] theorem snd_comp_inl : (snd : M ∗ N →* N).comp inl = 1 := rfl\n"}
{"name":"AddMonoid.Coprod.snd_comp_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq (AddMonoid.Coprod.snd.comp AddMonoid.Coprod.inl) 0","decl":"@[to_additive (attr := simp)] theorem snd_comp_inl : (snd : M ∗ N →* N).comp inl = 1 := rfl\n"}
{"name":"AddMonoid.Coprod.snd_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nx : M\n⊢ Eq (AddMonoid.Coprod.snd (AddMonoid.Coprod.inl x)) 0","decl":"@[to_additive (attr := simp)] theorem snd_apply_inl (x : M) : snd (inl x : M ∗ N) = 1 := rfl\n"}
{"name":"Monoid.Coprod.snd_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nx : M\n⊢ Eq (Monoid.Coprod.snd (Monoid.Coprod.inl x)) 1","decl":"@[to_additive (attr := simp)] theorem snd_apply_inl (x : M) : snd (inl x : M ∗ N) = 1 := rfl\n"}
{"name":"Monoid.Coprod.snd_comp_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq (Monoid.Coprod.snd.comp Monoid.Coprod.inr) (MonoidHom.id N)","decl":"@[to_additive (attr := simp)] theorem snd_comp_inr : (snd : M ∗ N →* N).comp inr = .id _ := rfl\n"}
{"name":"AddMonoid.Coprod.snd_comp_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq (AddMonoid.Coprod.snd.comp AddMonoid.Coprod.inr) (AddMonoidHom.id N)","decl":"@[to_additive (attr := simp)] theorem snd_comp_inr : (snd : M ∗ N →* N).comp inr = .id _ := rfl\n"}
{"name":"Monoid.Coprod.snd_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nx : N\n⊢ Eq (Monoid.Coprod.snd (Monoid.Coprod.inr x)) x","decl":"@[to_additive (attr := simp)] theorem snd_apply_inr (x : N) : snd (inr x : M ∗ N) = x := rfl\n\n"}
{"name":"AddMonoid.Coprod.snd_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nx : N\n⊢ Eq (AddMonoid.Coprod.snd (AddMonoid.Coprod.inr x)) x","decl":"@[to_additive (attr := simp)] theorem snd_apply_inr (x : N) : snd (inr x : M ∗ N) = x := rfl\n\n"}
{"name":"AddMonoid.Coprod.toSum_comp_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq (AddMonoid.Coprod.toSum.comp AddMonoid.Coprod.inl) (AddMonoidHom.inl M N)","decl":"@[to_additive (attr := simp)]\ntheorem toProd_comp_inl : (toProd : M ∗ N →* M × N).comp inl = .inl _ _ := rfl\n\n"}
{"name":"Monoid.Coprod.toProd_comp_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq (Monoid.Coprod.toProd.comp Monoid.Coprod.inl) (MonoidHom.inl M N)","decl":"@[to_additive (attr := simp)]\ntheorem toProd_comp_inl : (toProd : M ∗ N →* M × N).comp inl = .inl _ _ := rfl\n\n"}
{"name":"Monoid.Coprod.toProd_comp_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq (Monoid.Coprod.toProd.comp Monoid.Coprod.inr) (MonoidHom.inr M N)","decl":"@[to_additive (attr := simp)]\ntheorem toProd_comp_inr : (toProd : M ∗ N →* M × N).comp inr = .inr _ _ := rfl\n\n"}
{"name":"AddMonoid.Coprod.toSum_comp_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq (AddMonoid.Coprod.toSum.comp AddMonoid.Coprod.inr) (AddMonoidHom.inr M N)","decl":"@[to_additive (attr := simp)]\ntheorem toProd_comp_inr : (toProd : M ∗ N →* M × N).comp inr = .inr _ _ := rfl\n\n"}
{"name":"Monoid.Coprod.toProd_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nx : M\n⊢ Eq (Monoid.Coprod.toProd (Monoid.Coprod.inl x)) { fst := x, snd := 1 }","decl":"@[to_additive (attr := simp)]\ntheorem toProd_apply_inl (x : M) : toProd (inl x : M ∗ N) = (x, 1) := rfl\n\n"}
{"name":"AddMonoid.Coprod.toSum_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nx : M\n⊢ Eq (AddMonoid.Coprod.toSum (AddMonoid.Coprod.inl x)) { fst := x, snd := 0 }","decl":"@[to_additive (attr := simp)]\ntheorem toProd_apply_inl (x : M) : toProd (inl x : M ∗ N) = (x, 1) := rfl\n\n"}
{"name":"AddMonoid.Coprod.toSum_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nx : N\n⊢ Eq (AddMonoid.Coprod.toSum (AddMonoid.Coprod.inr x)) { fst := 0, snd := x }","decl":"@[to_additive (attr := simp)]\ntheorem toProd_apply_inr (x : N) : toProd (inr x : M ∗ N) = (1, x) := rfl\n\n"}
{"name":"Monoid.Coprod.toProd_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nx : N\n⊢ Eq (Monoid.Coprod.toProd (Monoid.Coprod.inr x)) { fst := 1, snd := x }","decl":"@[to_additive (attr := simp)]\ntheorem toProd_apply_inr (x : N) : toProd (inr x : M ∗ N) = (1, x) := rfl\n\n"}
{"name":"AddMonoid.Coprod.fst_sum_snd","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq (AddMonoid.Coprod.fst.prod AddMonoid.Coprod.snd) AddMonoid.Coprod.toSum","decl":"@[to_additive (attr := simp)]\ntheorem fst_prod_snd : (fst : M ∗ N →* M).prod snd = toProd := by ext1 <;> rfl\n\n"}
{"name":"Monoid.Coprod.fst_prod_snd","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq (Monoid.Coprod.fst.prod Monoid.Coprod.snd) Monoid.Coprod.toProd","decl":"@[to_additive (attr := simp)]\ntheorem fst_prod_snd : (fst : M ∗ N →* M).prod snd = toProd := by ext1 <;> rfl\n\n"}
{"name":"Monoid.Coprod.prod_mk_fst_snd","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nx : Monoid.Coprod M N\n⊢ Eq { fst := Monoid.Coprod.fst x, snd := Monoid.Coprod.snd x } (Monoid.Coprod.toProd x)","decl":"@[to_additive (attr := simp)]\ntheorem prod_mk_fst_snd (x : M ∗ N) : (fst x, snd x) = toProd x := by\n  rw [← fst_prod_snd, MonoidHom.prod_apply]\n\n"}
{"name":"AddMonoid.Coprod.sum_mk_fst_snd","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nx : AddMonoid.Coprod M N\n⊢ Eq { fst := AddMonoid.Coprod.fst x, snd := AddMonoid.Coprod.snd x } (AddMonoid.Coprod.toSum x)","decl":"@[to_additive (attr := simp)]\ntheorem prod_mk_fst_snd (x : M ∗ N) : (fst x, snd x) = toProd x := by\n  rw [← fst_prod_snd, MonoidHom.prod_apply]\n\n"}
{"name":"AddMonoid.Coprod.fst_comp_toSum","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq ((AddMonoidHom.fst M N).comp AddMonoid.Coprod.toSum) AddMonoid.Coprod.fst","decl":"@[to_additive (attr := simp)]\ntheorem fst_comp_toProd : (MonoidHom.fst M N).comp toProd = fst := by\n  rw [← fst_prod_snd, MonoidHom.fst_comp_prod]\n\n"}
{"name":"Monoid.Coprod.fst_comp_toProd","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq ((MonoidHom.fst M N).comp Monoid.Coprod.toProd) Monoid.Coprod.fst","decl":"@[to_additive (attr := simp)]\ntheorem fst_comp_toProd : (MonoidHom.fst M N).comp toProd = fst := by\n  rw [← fst_prod_snd, MonoidHom.fst_comp_prod]\n\n"}
{"name":"AddMonoid.Coprod.fst_toSum","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nx : AddMonoid.Coprod M N\n⊢ Eq (AddMonoid.Coprod.toSum x).1 (AddMonoid.Coprod.fst x)","decl":"@[to_additive (attr := simp)]\ntheorem fst_toProd (x : M ∗ N) : (toProd x).1 = fst x := by\n  rw [← fst_comp_toProd]; rfl\n\n"}
{"name":"Monoid.Coprod.fst_toProd","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nx : Monoid.Coprod M N\n⊢ Eq (Monoid.Coprod.toProd x).1 (Monoid.Coprod.fst x)","decl":"@[to_additive (attr := simp)]\ntheorem fst_toProd (x : M ∗ N) : (toProd x).1 = fst x := by\n  rw [← fst_comp_toProd]; rfl\n\n"}
{"name":"AddMonoid.Coprod.snd_comp_toSum","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq ((AddMonoidHom.snd M N).comp AddMonoid.Coprod.toSum) AddMonoid.Coprod.snd","decl":"@[to_additive (attr := simp)]\ntheorem snd_comp_toProd : (MonoidHom.snd M N).comp toProd = snd := by\n  rw [← fst_prod_snd, MonoidHom.snd_comp_prod]\n\n"}
{"name":"Monoid.Coprod.snd_comp_toProd","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq ((MonoidHom.snd M N).comp Monoid.Coprod.toProd) Monoid.Coprod.snd","decl":"@[to_additive (attr := simp)]\ntheorem snd_comp_toProd : (MonoidHom.snd M N).comp toProd = snd := by\n  rw [← fst_prod_snd, MonoidHom.snd_comp_prod]\n\n"}
{"name":"AddMonoid.Coprod.snd_toSum","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nx : AddMonoid.Coprod M N\n⊢ Eq (AddMonoid.Coprod.toSum x).2 (AddMonoid.Coprod.snd x)","decl":"@[to_additive (attr := simp)]\ntheorem snd_toProd (x : M ∗ N) : (toProd x).2 = snd x := by\n  rw [← snd_comp_toProd]; rfl\n\n"}
{"name":"Monoid.Coprod.snd_toProd","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nx : Monoid.Coprod M N\n⊢ Eq (Monoid.Coprod.toProd x).2 (Monoid.Coprod.snd x)","decl":"@[to_additive (attr := simp)]\ntheorem snd_toProd (x : M ∗ N) : (toProd x).2 = snd x := by\n  rw [← snd_comp_toProd]; rfl\n\n"}
{"name":"AddMonoid.Coprod.fst_comp_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq (AddMonoid.Coprod.fst.comp (AddMonoid.Coprod.swap M N)) AddMonoid.Coprod.snd","decl":"@[to_additive (attr := simp)]\ntheorem fst_comp_swap : fst.comp (swap M N) = snd := lift_comp_swap _ _\n\n"}
{"name":"Monoid.Coprod.fst_comp_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq (Monoid.Coprod.fst.comp (Monoid.Coprod.swap M N)) Monoid.Coprod.snd","decl":"@[to_additive (attr := simp)]\ntheorem fst_comp_swap : fst.comp (swap M N) = snd := lift_comp_swap _ _\n\n"}
{"name":"Monoid.Coprod.fst_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nx : Monoid.Coprod M N\n⊢ Eq (Monoid.Coprod.fst ((Monoid.Coprod.swap M N) x)) (Monoid.Coprod.snd x)","decl":"@[to_additive (attr := simp)]\ntheorem fst_swap (x : M ∗ N) : fst (swap M N x) = snd x := lift_swap _ _ _\n\n"}
{"name":"AddMonoid.Coprod.fst_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nx : AddMonoid.Coprod M N\n⊢ Eq (AddMonoid.Coprod.fst ((AddMonoid.Coprod.swap M N) x)) (AddMonoid.Coprod.snd x)","decl":"@[to_additive (attr := simp)]\ntheorem fst_swap (x : M ∗ N) : fst (swap M N x) = snd x := lift_swap _ _ _\n\n"}
{"name":"Monoid.Coprod.snd_comp_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq (Monoid.Coprod.snd.comp (Monoid.Coprod.swap M N)) Monoid.Coprod.fst","decl":"@[to_additive (attr := simp)]\ntheorem snd_comp_swap : snd.comp (swap M N) = fst := lift_comp_swap _ _\n\n"}
{"name":"AddMonoid.Coprod.snd_comp_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq (AddMonoid.Coprod.snd.comp (AddMonoid.Coprod.swap M N)) AddMonoid.Coprod.fst","decl":"@[to_additive (attr := simp)]\ntheorem snd_comp_swap : snd.comp (swap M N) = fst := lift_comp_swap _ _\n\n"}
{"name":"AddMonoid.Coprod.snd_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nx : AddMonoid.Coprod M N\n⊢ Eq (AddMonoid.Coprod.snd ((AddMonoid.Coprod.swap M N) x)) (AddMonoid.Coprod.fst x)","decl":"@[to_additive (attr := simp)]\ntheorem snd_swap (x : M ∗ N) : snd (swap M N x) = fst x := lift_swap _ _ _\n\n"}
{"name":"Monoid.Coprod.snd_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nx : Monoid.Coprod M N\n⊢ Eq (Monoid.Coprod.snd ((Monoid.Coprod.swap M N) x)) (Monoid.Coprod.fst x)","decl":"@[to_additive (attr := simp)]\ntheorem snd_swap (x : M ∗ N) : snd (swap M N x) = fst x := lift_swap _ _ _\n\n"}
{"name":"AddMonoid.Coprod.lift_inr_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq (AddMonoid.Coprod.lift AddMonoid.Coprod.inr AddMonoid.Coprod.inl) (AddMonoid.Coprod.swap M N)","decl":"@[to_additive (attr := simp)]\ntheorem lift_inr_inl : lift (inr : M →* N ∗ M) inl = swap M N := hom_ext rfl rfl\n\n"}
{"name":"Monoid.Coprod.lift_inr_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq (Monoid.Coprod.lift Monoid.Coprod.inr Monoid.Coprod.inl) (Monoid.Coprod.swap M N)","decl":"@[to_additive (attr := simp)]\ntheorem lift_inr_inl : lift (inr : M →* N ∗ M) inl = swap M N := hom_ext rfl rfl\n\n"}
{"name":"Monoid.Coprod.lift_inl_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Eq (Monoid.Coprod.lift Monoid.Coprod.inl Monoid.Coprod.inr) (MonoidHom.id (Monoid.Coprod M N))","decl":"@[to_additive (attr := simp)]\ntheorem lift_inl_inr : lift (inl : M →* M ∗ N) inr = .id _ := hom_ext rfl rfl\n\n"}
{"name":"AddMonoid.Coprod.lift_inl_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Eq (AddMonoid.Coprod.lift AddMonoid.Coprod.inl AddMonoid.Coprod.inr) (AddMonoidHom.id (AddMonoid.Coprod M N))","decl":"@[to_additive (attr := simp)]\ntheorem lift_inl_inr : lift (inl : M →* M ∗ N) inr = .id _ := hom_ext rfl rfl\n\n"}
{"name":"Monoid.Coprod.inl_injective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Function.Injective ⇑Monoid.Coprod.inl","decl":"@[to_additive]\ntheorem inl_injective : Injective (inl : M →* M ∗ N) := LeftInverse.injective fst_apply_inl\n\n"}
{"name":"AddMonoid.Coprod.inl_injective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Function.Injective ⇑AddMonoid.Coprod.inl","decl":"@[to_additive]\ntheorem inl_injective : Injective (inl : M →* M ∗ N) := LeftInverse.injective fst_apply_inl\n\n"}
{"name":"Monoid.Coprod.inr_injective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Function.Injective ⇑Monoid.Coprod.inr","decl":"@[to_additive]\ntheorem inr_injective : Injective (inr : N →* M ∗ N) := LeftInverse.injective snd_apply_inr\n\n"}
{"name":"AddMonoid.Coprod.inr_injective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Function.Injective ⇑AddMonoid.Coprod.inr","decl":"@[to_additive]\ntheorem inr_injective : Injective (inr : N →* M ∗ N) := LeftInverse.injective snd_apply_inr\n\n"}
{"name":"Monoid.Coprod.fst_surjective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Function.Surjective ⇑Monoid.Coprod.fst","decl":"@[to_additive]\ntheorem fst_surjective : Surjective (fst : M ∗ N →* M) := LeftInverse.surjective fst_apply_inl\n\n"}
{"name":"AddMonoid.Coprod.fst_surjective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Function.Surjective ⇑AddMonoid.Coprod.fst","decl":"@[to_additive]\ntheorem fst_surjective : Surjective (fst : M ∗ N →* M) := LeftInverse.surjective fst_apply_inl\n\n"}
{"name":"AddMonoid.Coprod.snd_surjective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Function.Surjective ⇑AddMonoid.Coprod.snd","decl":"@[to_additive]\ntheorem snd_surjective : Surjective (snd : M ∗ N →* N) := LeftInverse.surjective snd_apply_inr\n\n"}
{"name":"Monoid.Coprod.snd_surjective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Function.Surjective ⇑Monoid.Coprod.snd","decl":"@[to_additive]\ntheorem snd_surjective : Surjective (snd : M ∗ N →* N) := LeftInverse.surjective snd_apply_inr\n\n"}
{"name":"Monoid.Coprod.toProd_surjective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Monoid M\ninst✝ : Monoid N\n⊢ Function.Surjective ⇑Monoid.Coprod.toProd","decl":"@[to_additive]\ntheorem toProd_surjective : Surjective (toProd : M ∗ N →* M × N) := fun x =>\n  ⟨inl x.1 * inr x.2, by rw [map_mul, toProd_apply_inl, toProd_apply_inr, Prod.fst_mul_snd]⟩\n\n"}
{"name":"AddMonoid.Coprod.toSum_surjective","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\n⊢ Function.Surjective ⇑AddMonoid.Coprod.toSum","decl":"@[to_additive]\ntheorem toProd_surjective : Surjective (toProd : M ∗ N →* M × N) := fun x =>\n  ⟨inl x.1 * inr x.2, by rw [map_mul, toProd_apply_inl, toProd_apply_inr, Prod.fst_mul_snd]⟩\n\n"}
{"name":"AddMonoid.Coprod.mk_of_neg_add","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nx : Sum G H\n⊢ Eq (HAdd.hAdd (AddMonoid.Coprod.mk (FreeAddMonoid.of (Sum.map Neg.neg Neg.neg x))) (AddMonoid.Coprod.mk (FreeAddMonoid.of x))) 0","decl":"@[to_additive]\ntheorem mk_of_inv_mul : ∀ x : G ⊕ H, mk (of (x.map Inv.inv Inv.inv)) * mk (of x) = 1\n  | Sum.inl _ => map_mul_eq_one inl (inv_mul_cancel _)\n  | Sum.inr _ => map_mul_eq_one inr (inv_mul_cancel _)\n\n"}
{"name":"Monoid.Coprod.mk_of_inv_mul","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nx : Sum G H\n⊢ Eq (HMul.hMul (Monoid.Coprod.mk (FreeMonoid.of (Sum.map Inv.inv Inv.inv x))) (Monoid.Coprod.mk (FreeMonoid.of x))) 1","decl":"@[to_additive]\ntheorem mk_of_inv_mul : ∀ x : G ⊕ H, mk (of (x.map Inv.inv Inv.inv)) * mk (of x) = 1\n  | Sum.inl _ => map_mul_eq_one inl (inv_mul_cancel _)\n  | Sum.inr _ => map_mul_eq_one inr (inv_mul_cancel _)\n\n"}
{"name":"AddMonoid.Coprod.con_neg_add_cancel","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nx : FreeAddMonoid (Sum G H)\n⊢ (AddMonoid.coprodCon G H) (HAdd.hAdd (FreeAddMonoid.ofList (List.map (Sum.map Neg.neg Neg.neg) (FreeAddMonoid.toList x)).reverse) x) 0","decl":"@[to_additive]\ntheorem con_inv_mul_cancel (x : FreeMonoid (G ⊕ H)) :\n    coprodCon G H (ofList (x.toList.map (Sum.map Inv.inv Inv.inv)).reverse * x) 1 := by\n  rw [← mk_eq_mk, map_mul, map_one]\n  induction x using FreeMonoid.inductionOn' with\n  | one => simp\n  | mul_of x xs ihx =>\n    simp only [toList_of_mul, map_cons, reverse_cons, ofList_append, map_mul, ihx, ofList_singleton]\n    rwa [mul_assoc, ← mul_assoc (mk (of _)), mk_of_inv_mul, one_mul]\n\n"}
{"name":"Monoid.Coprod.con_inv_mul_cancel","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nx : FreeMonoid (Sum G H)\n⊢ (Monoid.coprodCon G H) (HMul.hMul (FreeMonoid.ofList (List.map (Sum.map Inv.inv Inv.inv) (FreeMonoid.toList x)).reverse) x) 1","decl":"@[to_additive]\ntheorem con_inv_mul_cancel (x : FreeMonoid (G ⊕ H)) :\n    coprodCon G H (ofList (x.toList.map (Sum.map Inv.inv Inv.inv)).reverse * x) 1 := by\n  rw [← mk_eq_mk, map_mul, map_one]\n  induction x using FreeMonoid.inductionOn' with\n  | one => simp\n  | mul_of x xs ihx =>\n    simp only [toList_of_mul, map_cons, reverse_cons, ofList_append, map_mul, ihx, ofList_singleton]\n    rwa [mul_assoc, ← mul_assoc (mk (of _)), mk_of_inv_mul, one_mul]\n\n"}
{"name":"AddMonoid.Coprod.neg_def","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nw : FreeAddMonoid (Sum G H)\n⊢ Eq (Neg.neg (AddMonoid.Coprod.mk w)) (AddMonoid.Coprod.mk (FreeAddMonoid.ofList (List.map (Sum.map Neg.neg Neg.neg) (FreeAddMonoid.toList w)).reverse))","decl":"@[to_additive]\ntheorem inv_def (w : FreeMonoid (G ⊕ H)) :\n    (mk w)⁻¹ = mk (ofList (w.toList.map (Sum.map Inv.inv Inv.inv)).reverse) :=\n  rfl\n\n"}
{"name":"Monoid.Coprod.inv_def","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nw : FreeMonoid (Sum G H)\n⊢ Eq (Inv.inv (Monoid.Coprod.mk w)) (Monoid.Coprod.mk (FreeMonoid.ofList (List.map (Sum.map Inv.inv Inv.inv) (FreeMonoid.toList w)).reverse))","decl":"@[to_additive]\ntheorem inv_def (w : FreeMonoid (G ⊕ H)) :\n    (mk w)⁻¹ = mk (ofList (w.toList.map (Sum.map Inv.inv Inv.inv)).reverse) :=\n  rfl\n\n"}
{"name":"AddMonoid.Coprod.closure_range_inl_union_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\n⊢ Eq (AddSubgroup.closure (Union.union (Set.range ⇑AddMonoid.Coprod.inl) (Set.range ⇑AddMonoid.Coprod.inr))) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_range_inl_union_inr :\n    Subgroup.closure (range (inl : G →* G ∗ H) ∪ range inr) = ⊤ :=\n  Subgroup.closure_eq_top_of_mclosure_eq_top mclosure_range_inl_union_inr\n\n"}
{"name":"Monoid.Coprod.closure_range_inl_union_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\n⊢ Eq (Subgroup.closure (Union.union (Set.range ⇑Monoid.Coprod.inl) (Set.range ⇑Monoid.Coprod.inr))) Top.top","decl":"@[to_additive (attr := simp)]\ntheorem closure_range_inl_union_inr :\n    Subgroup.closure (range (inl : G →* G ∗ H) ∪ range inr) = ⊤ :=\n  Subgroup.closure_eq_top_of_mclosure_eq_top mclosure_range_inl_union_inr\n\n"}
{"name":"AddMonoid.Coprod.range_inl_sup_range_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\n⊢ Eq (Max.max AddMonoid.Coprod.inl.range AddMonoid.Coprod.inr.range) Top.top","decl":"@[to_additive (attr := simp)] theorem range_inl_sup_range_inr :\n    MonoidHom.range (inl : G →* G ∗ H) ⊔ MonoidHom.range inr = ⊤ := by\n  rw [← closure_range_inl_union_inr, Subgroup.closure_union, ← MonoidHom.coe_range,\n    ← MonoidHom.coe_range, Subgroup.closure_eq, Subgroup.closure_eq]\n\n"}
{"name":"Monoid.Coprod.range_inl_sup_range_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\n⊢ Eq (Max.max Monoid.Coprod.inl.range Monoid.Coprod.inr.range) Top.top","decl":"@[to_additive (attr := simp)] theorem range_inl_sup_range_inr :\n    MonoidHom.range (inl : G →* G ∗ H) ⊔ MonoidHom.range inr = ⊤ := by\n  rw [← closure_range_inl_union_inr, Subgroup.closure_union, ← MonoidHom.coe_range,\n    ← MonoidHom.coe_range, Subgroup.closure_eq, Subgroup.closure_eq]\n\n"}
{"name":"Monoid.Coprod.codisjoint_range_inl_range_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\n⊢ Codisjoint Monoid.Coprod.inl.range Monoid.Coprod.inr.range","decl":"@[to_additive]\ntheorem codisjoint_range_inl_range_inr :\n    Codisjoint (MonoidHom.range (inl : G →* G ∗ H)) (MonoidHom.range inr) :=\n  codisjoint_iff.2 range_inl_sup_range_inr\n\n"}
{"name":"AddMonoid.Coprod.codisjoint_range_inl_range_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\n⊢ Codisjoint AddMonoid.Coprod.inl.range AddMonoid.Coprod.inr.range","decl":"@[to_additive]\ntheorem codisjoint_range_inl_range_inr :\n    Codisjoint (MonoidHom.range (inl : G →* G ∗ H)) (MonoidHom.range inr) :=\n  codisjoint_iff.2 range_inl_sup_range_inr\n\n"}
{"name":"Monoid.Coprod.range_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\n⊢ Eq (Monoid.Coprod.swap G H).range Top.top","decl":"@[to_additive (attr := simp)] theorem range_swap : MonoidHom.range (swap G H) = ⊤ :=\n  MonoidHom.range_eq_top.2 swap_surjective\n\n"}
{"name":"AddMonoid.Coprod.range_swap","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\n⊢ Eq (AddMonoid.Coprod.swap G H).range Top.top","decl":"@[to_additive (attr := simp)] theorem range_swap : MonoidHom.range (swap G H) = ⊤ :=\n  MonoidHom.range_eq_top.2 swap_surjective\n\n"}
{"name":"AddMonoid.Coprod.range_eq","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝² : AddGroup G\ninst✝¹ : AddGroup H\nK : Type u_3\ninst✝ : AddGroup K\nf : AddMonoidHom (AddMonoid.Coprod G H) K\n⊢ Eq f.range (Max.max (f.comp AddMonoid.Coprod.inl).range (f.comp AddMonoid.Coprod.inr).range)","decl":"@[to_additive] theorem range_eq (f : G ∗ H →* K) :\n    MonoidHom.range f = MonoidHom.range (f.comp inl) ⊔ MonoidHom.range (f.comp inr) := by\n  rw [MonoidHom.range_eq_map, ← range_inl_sup_range_inr, Subgroup.map_sup, MonoidHom.map_range,\n    MonoidHom.map_range]\n\n"}
{"name":"Monoid.Coprod.range_eq","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝² : Group G\ninst✝¹ : Group H\nK : Type u_3\ninst✝ : Group K\nf : MonoidHom (Monoid.Coprod G H) K\n⊢ Eq f.range (Max.max (f.comp Monoid.Coprod.inl).range (f.comp Monoid.Coprod.inr).range)","decl":"@[to_additive] theorem range_eq (f : G ∗ H →* K) :\n    MonoidHom.range f = MonoidHom.range (f.comp inl) ⊔ MonoidHom.range (f.comp inr) := by\n  rw [MonoidHom.range_eq_map, ← range_inl_sup_range_inr, Subgroup.map_sup, MonoidHom.map_range,\n    MonoidHom.map_range]\n\n"}
{"name":"AddMonoid.Coprod.range_lift","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝² : AddGroup G\ninst✝¹ : AddGroup H\nK : Type u_3\ninst✝ : AddGroup K\nf : AddMonoidHom G K\ng : AddMonoidHom H K\n⊢ Eq (AddMonoid.Coprod.lift f g).range (Max.max f.range g.range)","decl":"@[to_additive (attr := simp)] theorem range_lift (f : G →* K) (g : H →* K) :\n    MonoidHom.range (lift f g) = MonoidHom.range f ⊔ MonoidHom.range g := by\n  simp [range_eq]\n\n"}
{"name":"Monoid.Coprod.range_lift","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝² : Group G\ninst✝¹ : Group H\nK : Type u_3\ninst✝ : Group K\nf : MonoidHom G K\ng : MonoidHom H K\n⊢ Eq (Monoid.Coprod.lift f g).range (Max.max f.range g.range)","decl":"@[to_additive (attr := simp)] theorem range_lift (f : G →* K) (g : H →* K) :\n    MonoidHom.range (lift f g) = MonoidHom.range f ⊔ MonoidHom.range g := by\n  simp [range_eq]\n\n"}
{"name":"AddMonoid.MulEquiv.coprodCongr_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddZeroClass M'\ninst✝ : AddZeroClass N'\ne : AddEquiv M N\ne' : AddEquiv M' N'\n⊢ Eq ⇑(AddMonoid.MulEquiv.coprodCongr e e') ⇑(AddMonoid.Coprod.map ↑e ↑e')","decl":"/-- Lift two monoid equivalences `e : M ≃* N` and `e' : M' ≃* N'` to a monoid equivalence\n`(M ∗ M') ≃* (N ∗ N')`. -/\n@[to_additive (attr := simps! (config := .asFn)) \"Lift two additive monoid\nequivalences `e : M ≃+ N` and `e' : M' ≃+ N'` to an additive monoid equivalence\n`(AddMonoid.Coprod M M') ≃+ (AddMonoid.Coprod N N')`.\"]\ndef coprodCongr (e : M ≃* N) (e' : M' ≃* N') : (M ∗ M') ≃* (N ∗ N') :=\n  (Coprod.map (e : M →* N) (e' : M' →* N')).toMulEquiv (Coprod.map e.symm e'.symm)\n    (by ext <;> simp) (by ext <;> simp)\n\n"}
{"name":"AddMonoid.MulEquiv.coprodCongr_symm_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : AddZeroClass M\ninst✝² : AddZeroClass N\ninst✝¹ : AddZeroClass M'\ninst✝ : AddZeroClass N'\ne : AddEquiv M N\ne' : AddEquiv M' N'\n⊢ Eq ⇑(AddMonoid.MulEquiv.coprodCongr e e').symm ⇑(AddMonoid.Coprod.map ↑e.symm ↑e'.symm)","decl":"/-- Lift two monoid equivalences `e : M ≃* N` and `e' : M' ≃* N'` to a monoid equivalence\n`(M ∗ M') ≃* (N ∗ N')`. -/\n@[to_additive (attr := simps! (config := .asFn)) \"Lift two additive monoid\nequivalences `e : M ≃+ N` and `e' : M' ≃+ N'` to an additive monoid equivalence\n`(AddMonoid.Coprod M M') ≃+ (AddMonoid.Coprod N N')`.\"]\ndef coprodCongr (e : M ≃* N) (e' : M' ≃* N') : (M ∗ M') ≃* (N ∗ N') :=\n  (Coprod.map (e : M →* N) (e' : M' →* N')).toMulEquiv (Coprod.map e.symm e'.symm)\n    (by ext <;> simp) (by ext <;> simp)\n\n"}
{"name":"Monoid.MulEquiv.coprodCongr_symm_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : MulOneClass M'\ninst✝ : MulOneClass N'\ne : MulEquiv M N\ne' : MulEquiv M' N'\n⊢ Eq ⇑(Monoid.MulEquiv.coprodCongr e e').symm ⇑(Monoid.Coprod.map ↑e.symm ↑e'.symm)","decl":"/-- Lift two monoid equivalences `e : M ≃* N` and `e' : M' ≃* N'` to a monoid equivalence\n`(M ∗ M') ≃* (N ∗ N')`. -/\n@[to_additive (attr := simps! (config := .asFn)) \"Lift two additive monoid\nequivalences `e : M ≃+ N` and `e' : M' ≃+ N'` to an additive monoid equivalence\n`(AddMonoid.Coprod M M') ≃+ (AddMonoid.Coprod N N')`.\"]\ndef coprodCongr (e : M ≃* N) (e' : M' ≃* N') : (M ∗ M') ≃* (N ∗ N') :=\n  (Coprod.map (e : M →* N) (e' : M' →* N')).toMulEquiv (Coprod.map e.symm e'.symm)\n    (by ext <;> simp) (by ext <;> simp)\n\n"}
{"name":"Monoid.MulEquiv.coprodCongr_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nM' : Type u_3\nN' : Type u_4\ninst✝³ : MulOneClass M\ninst✝² : MulOneClass N\ninst✝¹ : MulOneClass M'\ninst✝ : MulOneClass N'\ne : MulEquiv M N\ne' : MulEquiv M' N'\n⊢ Eq ⇑(Monoid.MulEquiv.coprodCongr e e') ⇑(Monoid.Coprod.map ↑e ↑e')","decl":"/-- Lift two monoid equivalences `e : M ≃* N` and `e' : M' ≃* N'` to a monoid equivalence\n`(M ∗ M') ≃* (N ∗ N')`. -/\n@[to_additive (attr := simps! (config := .asFn)) \"Lift two additive monoid\nequivalences `e : M ≃+ N` and `e' : M' ≃+ N'` to an additive monoid equivalence\n`(AddMonoid.Coprod M M') ≃+ (AddMonoid.Coprod N N')`.\"]\ndef coprodCongr (e : M ≃* N) (e' : M' ≃* N') : (M ∗ M') ≃* (N ∗ N') :=\n  (Coprod.map (e : M →* N) (e' : M' →* N')).toMulEquiv (Coprod.map e.symm e'.symm)\n    (by ext <;> simp) (by ext <;> simp)\n\n"}
{"name":"AddMonoid.MulEquiv.coprodComm_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq ⇑(AddMonoid.MulEquiv.coprodComm M N) ⇑(AddMonoid.Coprod.swap M N)","decl":"/-- A `MulEquiv` version of `Coprod.swap`. -/\n@[to_additive (attr := simps! (config := .asFn))\n  \"An `AddEquiv` version of `AddMonoid.Coprod.swap`.\"]\ndef coprodComm : M ∗ N ≃* N ∗ M :=\n  (Coprod.swap _ _).toMulEquiv (Coprod.swap _ _) (Coprod.swap_comp_swap _ _)\n    (Coprod.swap_comp_swap _ _)\n\n"}
{"name":"Monoid.MulEquiv.coprodComm_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq ⇑(Monoid.MulEquiv.coprodComm M N) ⇑(Monoid.Coprod.swap M N)","decl":"/-- A `MulEquiv` version of `Coprod.swap`. -/\n@[to_additive (attr := simps! (config := .asFn))\n  \"An `AddEquiv` version of `AddMonoid.Coprod.swap`.\"]\ndef coprodComm : M ∗ N ≃* N ∗ M :=\n  (Coprod.swap _ _).toMulEquiv (Coprod.swap _ _) (Coprod.swap_comp_swap _ _)\n    (Coprod.swap_comp_swap _ _)\n\n"}
{"name":"Monoid.MulEquiv.coprodComm_symm_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\n⊢ Eq ⇑(Monoid.MulEquiv.coprodComm M N).symm ⇑(Monoid.Coprod.swap N M)","decl":"/-- A `MulEquiv` version of `Coprod.swap`. -/\n@[to_additive (attr := simps! (config := .asFn))\n  \"An `AddEquiv` version of `AddMonoid.Coprod.swap`.\"]\ndef coprodComm : M ∗ N ≃* N ∗ M :=\n  (Coprod.swap _ _).toMulEquiv (Coprod.swap _ _) (Coprod.swap_comp_swap _ _)\n    (Coprod.swap_comp_swap _ _)\n\n"}
{"name":"AddMonoid.MulEquiv.coprodComm_symm_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\n⊢ Eq ⇑(AddMonoid.MulEquiv.coprodComm M N).symm ⇑(AddMonoid.Coprod.swap N M)","decl":"/-- A `MulEquiv` version of `Coprod.swap`. -/\n@[to_additive (attr := simps! (config := .asFn))\n  \"An `AddEquiv` version of `AddMonoid.Coprod.swap`.\"]\ndef coprodComm : M ∗ N ≃* N ∗ M :=\n  (Coprod.swap _ _).toMulEquiv (Coprod.swap _ _) (Coprod.swap_comp_swap _ _)\n    (Coprod.swap_comp_swap _ _)\n\n"}
{"name":"AddMonoid.MulEquiv.coprodAssoc_apply_inl_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : AddMonoid N\ninst✝ : AddMonoid P\nx : M\n⊢ Eq ((AddMonoid.MulEquiv.coprodAssoc M N P) (AddMonoid.Coprod.inl (AddMonoid.Coprod.inl x))) (AddMonoid.Coprod.inl x)","decl":"@[to_additive (attr := simp)]\ntheorem coprodAssoc_apply_inl_inl (x : M) : coprodAssoc M N P (inl (inl x)) = inl x := rfl\n\n"}
{"name":"Monoid.MulEquiv.coprodAssoc_apply_inl_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid N\ninst✝ : Monoid P\nx : M\n⊢ Eq ((Monoid.MulEquiv.coprodAssoc M N P) (Monoid.Coprod.inl (Monoid.Coprod.inl x))) (Monoid.Coprod.inl x)","decl":"@[to_additive (attr := simp)]\ntheorem coprodAssoc_apply_inl_inl (x : M) : coprodAssoc M N P (inl (inl x)) = inl x := rfl\n\n"}
{"name":"AddMonoid.MulEquiv.coprodAssoc_apply_inl_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : AddMonoid N\ninst✝ : AddMonoid P\nx : N\n⊢ Eq ((AddMonoid.MulEquiv.coprodAssoc M N P) (AddMonoid.Coprod.inl (AddMonoid.Coprod.inr x))) (AddMonoid.Coprod.inr (AddMonoid.Coprod.inl x))","decl":"@[to_additive (attr := simp)]\ntheorem coprodAssoc_apply_inl_inr (x : N) : coprodAssoc M N P (inl (inr x)) = inr (inl x) := rfl\n\n"}
{"name":"Monoid.MulEquiv.coprodAssoc_apply_inl_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid N\ninst✝ : Monoid P\nx : N\n⊢ Eq ((Monoid.MulEquiv.coprodAssoc M N P) (Monoid.Coprod.inl (Monoid.Coprod.inr x))) (Monoid.Coprod.inr (Monoid.Coprod.inl x))","decl":"@[to_additive (attr := simp)]\ntheorem coprodAssoc_apply_inl_inr (x : N) : coprodAssoc M N P (inl (inr x)) = inr (inl x) := rfl\n\n"}
{"name":"Monoid.MulEquiv.coprodAssoc_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid N\ninst✝ : Monoid P\nx : P\n⊢ Eq ((Monoid.MulEquiv.coprodAssoc M N P) (Monoid.Coprod.inr x)) (Monoid.Coprod.inr (Monoid.Coprod.inr x))","decl":"@[to_additive (attr := simp)]\ntheorem coprodAssoc_apply_inr (x : P) : coprodAssoc M N P (inr x) = inr (inr x) := rfl\n\n"}
{"name":"AddMonoid.MulEquiv.coprodAssoc_apply_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : AddMonoid N\ninst✝ : AddMonoid P\nx : P\n⊢ Eq ((AddMonoid.MulEquiv.coprodAssoc M N P) (AddMonoid.Coprod.inr x)) (AddMonoid.Coprod.inr (AddMonoid.Coprod.inr x))","decl":"@[to_additive (attr := simp)]\ntheorem coprodAssoc_apply_inr (x : P) : coprodAssoc M N P (inr x) = inr (inr x) := rfl\n\n"}
{"name":"Monoid.MulEquiv.coprodAssoc_symm_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid N\ninst✝ : Monoid P\nx : M\n⊢ Eq ((Monoid.MulEquiv.coprodAssoc M N P).symm (Monoid.Coprod.inl x)) (Monoid.Coprod.inl (Monoid.Coprod.inl x))","decl":"@[to_additive (attr := simp)]\ntheorem coprodAssoc_symm_apply_inl (x : M) : (coprodAssoc M N P).symm (inl x) = inl (inl x) :=\n  rfl\n\n"}
{"name":"AddMonoid.MulEquiv.coprodAssoc_symm_apply_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : AddMonoid N\ninst✝ : AddMonoid P\nx : M\n⊢ Eq ((AddMonoid.MulEquiv.coprodAssoc M N P).symm (AddMonoid.Coprod.inl x)) (AddMonoid.Coprod.inl (AddMonoid.Coprod.inl x))","decl":"@[to_additive (attr := simp)]\ntheorem coprodAssoc_symm_apply_inl (x : M) : (coprodAssoc M N P).symm (inl x) = inl (inl x) :=\n  rfl\n\n"}
{"name":"AddMonoid.MulEquiv.coprodAssoc_symm_apply_inr_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : AddMonoid N\ninst✝ : AddMonoid P\nx : N\n⊢ Eq ((AddMonoid.MulEquiv.coprodAssoc M N P).symm (AddMonoid.Coprod.inr (AddMonoid.Coprod.inl x))) (AddMonoid.Coprod.inl (AddMonoid.Coprod.inr x))","decl":"@[to_additive (attr := simp)]\ntheorem coprodAssoc_symm_apply_inr_inl (x : N) :\n    (coprodAssoc M N P).symm (inr (inl x)) = inl (inr x) :=\n  rfl\n\n"}
{"name":"Monoid.MulEquiv.coprodAssoc_symm_apply_inr_inl","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid N\ninst✝ : Monoid P\nx : N\n⊢ Eq ((Monoid.MulEquiv.coprodAssoc M N P).symm (Monoid.Coprod.inr (Monoid.Coprod.inl x))) (Monoid.Coprod.inl (Monoid.Coprod.inr x))","decl":"@[to_additive (attr := simp)]\ntheorem coprodAssoc_symm_apply_inr_inl (x : N) :\n    (coprodAssoc M N P).symm (inr (inl x)) = inl (inr x) :=\n  rfl\n\n"}
{"name":"AddMonoid.MulEquiv.coprodAssoc_symm_apply_inr_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : AddMonoid N\ninst✝ : AddMonoid P\nx : P\n⊢ Eq ((AddMonoid.MulEquiv.coprodAssoc M N P).symm (AddMonoid.Coprod.inr (AddMonoid.Coprod.inr x))) (AddMonoid.Coprod.inr x)","decl":"@[to_additive (attr := simp)]\ntheorem coprodAssoc_symm_apply_inr_inr (x : P) :\n    (coprodAssoc M N P).symm (inr (inr x)) = inr x :=\n  rfl\n\n"}
{"name":"Monoid.MulEquiv.coprodAssoc_symm_apply_inr_inr","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\nN : Type u_2\nP : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Monoid N\ninst✝ : Monoid P\nx : P\n⊢ Eq ((Monoid.MulEquiv.coprodAssoc M N P).symm (Monoid.Coprod.inr (Monoid.Coprod.inr x))) (Monoid.Coprod.inr x)","decl":"@[to_additive (attr := simp)]\ntheorem coprodAssoc_symm_apply_inr_inr (x : P) :\n    (coprodAssoc M N P).symm (inr (inr x)) = inr x :=\n  rfl\n\n"}
{"name":"Monoid.MulEquiv.coprodPUnit_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Eq ⇑(Monoid.MulEquiv.coprodPUnit M) ⇑Monoid.Coprod.fst","decl":"/-- Isomorphism between `M ∗ PUnit` and `M`. -/\n@[simps! (config := .asFn)]\ndef coprodPUnit : M ∗ PUnit ≃* M :=\n  MonoidHom.toMulEquiv fst inl (hom_ext rfl <| Subsingleton.elim _ _) fst_comp_inl\n\n"}
{"name":"Monoid.MulEquiv.coprodPUnit_symm_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Eq ⇑(Monoid.MulEquiv.coprodPUnit M).symm ⇑Monoid.Coprod.inl","decl":"/-- Isomorphism between `M ∗ PUnit` and `M`. -/\n@[simps! (config := .asFn)]\ndef coprodPUnit : M ∗ PUnit ≃* M :=\n  MonoidHom.toMulEquiv fst inl (hom_ext rfl <| Subsingleton.elim _ _) fst_comp_inl\n\n"}
{"name":"Monoid.MulEquiv.punitCoprod_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Eq ⇑(Monoid.MulEquiv.punitCoprod M) ⇑Monoid.Coprod.snd","decl":"/-- Isomorphism between `PUnit ∗ M` and `M`. -/\n@[simps! (config := .asFn)]\ndef punitCoprod : PUnit ∗ M ≃* M :=\n  MonoidHom.toMulEquiv snd inr (hom_ext (Subsingleton.elim _ _) rfl) snd_comp_inr\n\n"}
{"name":"Monoid.MulEquiv.punitCoprod_symm_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Eq ⇑(Monoid.MulEquiv.punitCoprod M).symm ⇑Monoid.Coprod.inr","decl":"/-- Isomorphism between `PUnit ∗ M` and `M`. -/\n@[simps! (config := .asFn)]\ndef punitCoprod : PUnit ∗ M ≃* M :=\n  MonoidHom.toMulEquiv snd inr (hom_ext (Subsingleton.elim _ _) rfl) snd_comp_inr\n\n"}
{"name":"Monoid.AddEquiv.coprodUnit_symm_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Eq ⇑Monoid.AddEquiv.coprodUnit.symm ⇑AddMonoid.Coprod.inl","decl":"/-- Isomorphism between `M ∗ PUnit` and `M`. -/\n@[simps! (config := .asFn)]\ndef coprodUnit : AddMonoid.Coprod M PUnit ≃+ M :=\n  AddMonoidHom.toAddEquiv AddMonoid.Coprod.fst AddMonoid.Coprod.inl\n    (AddMonoid.Coprod.hom_ext rfl <| Subsingleton.elim _ _) AddMonoid.Coprod.fst_comp_inl\n\n"}
{"name":"Monoid.AddEquiv.coprodUnit_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Eq ⇑Monoid.AddEquiv.coprodUnit ⇑AddMonoid.Coprod.fst","decl":"/-- Isomorphism between `M ∗ PUnit` and `M`. -/\n@[simps! (config := .asFn)]\ndef coprodUnit : AddMonoid.Coprod M PUnit ≃+ M :=\n  AddMonoidHom.toAddEquiv AddMonoid.Coprod.fst AddMonoid.Coprod.inl\n    (AddMonoid.Coprod.hom_ext rfl <| Subsingleton.elim _ _) AddMonoid.Coprod.fst_comp_inl\n\n"}
{"name":"Monoid.AddEquiv.punitCoprod_symm_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Eq ⇑Monoid.AddEquiv.punitCoprod.symm ⇑AddMonoid.Coprod.inr","decl":"/-- Isomorphism between `PUnit ∗ M` and `M`. -/\n@[simps! (config := .asFn)]\ndef punitCoprod : AddMonoid.Coprod PUnit M ≃+ M :=\n  AddMonoidHom.toAddEquiv AddMonoid.Coprod.snd AddMonoid.Coprod.inr\n    (AddMonoid.Coprod.hom_ext (Subsingleton.elim _ _) rfl) AddMonoid.Coprod.snd_comp_inr\n\n"}
{"name":"Monoid.AddEquiv.punitCoprod_apply","module":"Mathlib.GroupTheory.Coprod.Basic","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Eq ⇑Monoid.AddEquiv.punitCoprod ⇑AddMonoid.Coprod.snd","decl":"/-- Isomorphism between `PUnit ∗ M` and `M`. -/\n@[simps! (config := .asFn)]\ndef punitCoprod : AddMonoid.Coprod PUnit M ≃+ M :=\n  AddMonoidHom.toAddEquiv AddMonoid.Coprod.snd AddMonoid.Coprod.inr\n    (AddMonoid.Coprod.hom_ext (Subsingleton.elim _ _) rfl) AddMonoid.Coprod.snd_comp_inr\n\n"}
