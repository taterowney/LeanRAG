{"name":"Set.coe_projIci","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na x : α\n⊢ Eq (↑(Set.projIci a x)) (Max.max a x)","decl":"@[norm_cast]\ntheorem coe_projIci (a x : α) : (projIci a x : α) = max a x := rfl\n\n"}
{"name":"Set.coe_projIic","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb x : α\n⊢ Eq (↑(Set.projIic b x)) (Min.min b x)","decl":"@[norm_cast]\ntheorem coe_projIic (b x : α) : (projIic b x : α) = min b x := rfl\n\n"}
{"name":"Set.coe_projIcc","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nx : α\n⊢ Eq (↑(Set.projIcc a b h x)) (Max.max a (Min.min b x))","decl":"@[norm_cast]\ntheorem coe_projIcc (a b : α) (h : a ≤ b) (x : α) : (projIcc a b h x : α) = max a (min b x) := rfl\n\n"}
{"name":"Set.projIci_of_le","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na x : α\nhx : LE.le x a\n⊢ Eq (Set.projIci a x) ⟨a, ⋯⟩","decl":"theorem projIci_of_le (hx : x ≤ a) : projIci a x = ⟨a, le_rfl⟩ := Subtype.ext <| max_eq_left hx\n\n"}
{"name":"Set.projIic_of_le","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb x : α\nhx : LE.le b x\n⊢ Eq (Set.projIic b x) ⟨b, ⋯⟩","decl":"theorem projIic_of_le (hx : b ≤ x) : projIic b x = ⟨b, le_rfl⟩ := Subtype.ext <| min_eq_left hx\n\n"}
{"name":"Set.projIcc_of_le_left","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nx : α\nhx : LE.le x a\n⊢ Eq (Set.projIcc a b h x) ⟨a, ⋯⟩","decl":"theorem projIcc_of_le_left (hx : x ≤ a) : projIcc a b h x = ⟨a, left_mem_Icc.2 h⟩ := by\n  simp [projIcc, hx, hx.trans h]\n\n\n"}
{"name":"Set.projIcc_of_right_le","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nx : α\nhx : LE.le b x\n⊢ Eq (Set.projIcc a b h x) ⟨b, ⋯⟩","decl":"theorem projIcc_of_right_le (hx : b ≤ x) : projIcc a b h x = ⟨b, right_mem_Icc.2 h⟩ := by\n  simp [projIcc, hx, h]\n\n"}
{"name":"Set.projIci_self","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (Set.projIci a a) ⟨a, ⋯⟩","decl":"@[simp]\ntheorem projIci_self (a : α) : projIci a a = ⟨a, le_rfl⟩ := projIci_of_le le_rfl\n\n"}
{"name":"Set.projIic_self","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb : α\n⊢ Eq (Set.projIic b b) ⟨b, ⋯⟩","decl":"@[simp]\ntheorem projIic_self (b : α) : projIic b b = ⟨b, le_rfl⟩ := projIic_of_le le_rfl\n\n"}
{"name":"Set.projIcc_left","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Set.projIcc a b h a) ⟨a, ⋯⟩","decl":"@[simp]\ntheorem projIcc_left : projIcc a b h a = ⟨a, left_mem_Icc.2 h⟩ :=\n  projIcc_of_le_left h le_rfl\n\n"}
{"name":"Set.projIcc_right","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Set.projIcc a b h b) ⟨b, ⋯⟩","decl":"@[simp]\ntheorem projIcc_right : projIcc a b h b = ⟨b, right_mem_Icc.2 h⟩ :=\n  projIcc_of_right_le h le_rfl\n\n"}
{"name":"Set.projIci_eq_self","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na x : α\n⊢ Iff (Eq (Set.projIci a x) ⟨a, ⋯⟩) (LE.le x a)","decl":"theorem projIci_eq_self : projIci a x = ⟨a, le_rfl⟩ ↔ x ≤ a := by simp [projIci, Subtype.ext_iff]\n\n"}
{"name":"Set.projIic_eq_self","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb x : α\n⊢ Iff (Eq (Set.projIic b x) ⟨b, ⋯⟩) (LE.le b x)","decl":"theorem projIic_eq_self : projIic b x = ⟨b, le_rfl⟩ ↔ b ≤ x := by simp [projIic, Subtype.ext_iff]\n\n"}
{"name":"Set.projIcc_eq_left","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b x : α\nh : LT.lt a b\n⊢ Iff (Eq (Set.projIcc a b ⋯ x) ⟨a, ⋯⟩) (LE.le x a)","decl":"theorem projIcc_eq_left (h : a < b) : projIcc a b h.le x = ⟨a, left_mem_Icc.mpr h.le⟩ ↔ x ≤ a := by\n  simp [projIcc, Subtype.ext_iff, h.not_le]\n\n"}
{"name":"Set.projIcc_eq_right","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b x : α\nh : LT.lt a b\n⊢ Iff (Eq (Set.projIcc a b ⋯ x) ⟨b, ⋯⟩) (LE.le b x)","decl":"theorem projIcc_eq_right (h : a < b) : projIcc a b h.le x = ⟨b, right_mem_Icc.2 h.le⟩ ↔ b ≤ x := by\n  simp [projIcc, Subtype.ext_iff, max_min_distrib_left, h.le, h.not_le]\n\n"}
{"name":"Set.projIci_of_mem","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na x : α\nhx : Membership.mem (Set.Ici a) x\n⊢ Eq (Set.projIci a x) ⟨x, hx⟩","decl":"theorem projIci_of_mem (hx : x ∈ Ici a) : projIci a x = ⟨x, hx⟩ := by simpa [projIci]\n\n"}
{"name":"Set.projIic_of_mem","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb x : α\nhx : Membership.mem (Set.Iic b) x\n⊢ Eq (Set.projIic b x) ⟨x, hx⟩","decl":"theorem projIic_of_mem (hx : x ∈ Iic b) : projIic b x = ⟨x, hx⟩ := by simpa [projIic]\n\n"}
{"name":"Set.projIcc_of_mem","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nx : α\nhx : Membership.mem (Set.Icc a b) x\n⊢ Eq (Set.projIcc a b h x) ⟨x, hx⟩","decl":"theorem projIcc_of_mem (hx : x ∈ Icc a b) : projIcc a b h x = ⟨x, hx⟩ := by\n  simp [projIcc, hx.1, hx.2]\n\n"}
{"name":"Set.projIci_coe","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\nx : ↑(Set.Ici a)\n⊢ Eq (Set.projIci a ↑x) x","decl":"@[simp]\ntheorem projIci_coe (x : Ici a) : projIci a x = x := by cases x; apply projIci_of_mem\n\n"}
{"name":"Set.projIic_coe","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb : α\nx : ↑(Set.Iic b)\n⊢ Eq (Set.projIic b ↑x) x","decl":"@[simp]\ntheorem projIic_coe (x : Iic b) : projIic b x = x := by cases x; apply projIic_of_mem\n\n"}
{"name":"Set.projIcc_val","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nx : ↑(Set.Icc a b)\n⊢ Eq (Set.projIcc a b h ↑x) x","decl":"@[simp]\ntheorem projIcc_val (x : Icc a b) : projIcc a b h x = x := by\n  cases x\n  apply projIcc_of_mem\n\n"}
{"name":"Set.projIci_surjOn","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Set.SurjOn (Set.projIci a) (Set.Ici a) Set.univ","decl":"theorem projIci_surjOn : SurjOn (projIci a) (Ici a) univ := fun x _ => ⟨x, x.2, projIci_coe x⟩\n\n"}
{"name":"Set.projIic_surjOn","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb : α\n⊢ Set.SurjOn (Set.projIic b) (Set.Iic b) Set.univ","decl":"theorem projIic_surjOn : SurjOn (projIic b) (Iic b) univ := fun x _ => ⟨x, x.2, projIic_coe x⟩\n\n"}
{"name":"Set.projIcc_surjOn","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Set.SurjOn (Set.projIcc a b h) (Set.Icc a b) Set.univ","decl":"theorem projIcc_surjOn : SurjOn (projIcc a b h) (Icc a b) univ := fun x _ =>\n  ⟨x, x.2, projIcc_val h x⟩\n\n"}
{"name":"Set.projIci_surjective","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Function.Surjective (Set.projIci a)","decl":"theorem projIci_surjective : Surjective (projIci a) := fun x => ⟨x, projIci_coe x⟩\n\n"}
{"name":"Set.projIic_surjective","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb : α\n⊢ Function.Surjective (Set.projIic b)","decl":"theorem projIic_surjective : Surjective (projIic b) := fun x => ⟨x, projIic_coe x⟩\n\n"}
{"name":"Set.projIcc_surjective","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Function.Surjective (Set.projIcc a b h)","decl":"theorem projIcc_surjective : Surjective (projIcc a b h) := fun x => ⟨x, projIcc_val h x⟩\n\n"}
{"name":"Set.range_projIci","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (Set.range (Set.projIci a)) Set.univ","decl":"@[simp]\ntheorem range_projIci : range (projIci a) = univ := projIci_surjective.range_eq\n\n"}
{"name":"Set.range_projIic","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (Set.range (Set.projIic a)) Set.univ","decl":"@[simp]\ntheorem range_projIic : range (projIic a) = univ := projIic_surjective.range_eq\n\n"}
{"name":"Set.range_projIcc","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Set.range (Set.projIcc a b h)) Set.univ","decl":"@[simp]\ntheorem range_projIcc : range (projIcc a b h) = univ :=\n  (projIcc_surjective h).range_eq\n\n"}
{"name":"Set.monotone_projIci","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Monotone (Set.projIci a)","decl":"theorem monotone_projIci : Monotone (projIci a) := fun _ _ => max_le_max le_rfl\n\n"}
{"name":"Set.monotone_projIic","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Monotone (Set.projIic a)","decl":"theorem monotone_projIic : Monotone (projIic a) := fun _ _ => min_le_min le_rfl\n\n"}
{"name":"Set.monotone_projIcc","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Monotone (Set.projIcc a b h)","decl":"theorem monotone_projIcc : Monotone (projIcc a b h) := fun _ _ hxy =>\n  max_le_max le_rfl <| min_le_min le_rfl hxy\n\n"}
{"name":"Set.strictMonoOn_projIci","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ StrictMonoOn (Set.projIci a) (Set.Ici a)","decl":"theorem strictMonoOn_projIci : StrictMonoOn (projIci a) (Ici a) := fun x hx y hy hxy => by\n  simpa only [projIci_of_mem, hx, hy]\n\n"}
{"name":"Set.strictMonoOn_projIic","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb : α\n⊢ StrictMonoOn (Set.projIic b) (Set.Iic b)","decl":"theorem strictMonoOn_projIic : StrictMonoOn (projIic b) (Iic b) := fun x hx y hy hxy => by\n  simpa only [projIic_of_mem, hx, hy]\n\n"}
{"name":"Set.strictMonoOn_projIcc","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ StrictMonoOn (Set.projIcc a b h) (Set.Icc a b)","decl":"theorem strictMonoOn_projIcc : StrictMonoOn (projIcc a b h) (Icc a b) := fun x hx y hy hxy => by\n  simpa only [projIcc_of_mem, hx, hy]\n\n"}
{"name":"Set.IciExtend_apply","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na : α\nf : ↑(Set.Ici a) → β\nx : α\n⊢ Eq (Set.IciExtend f x) (f ⟨Max.max a x, ⋯⟩)","decl":"theorem IciExtend_apply (f : Ici a → β) (x : α) : IciExtend f x = f ⟨max a x, le_max_left _ _⟩ :=\n  rfl\n\n"}
{"name":"Set.IicExtend_apply","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\nb : α\nf : ↑(Set.Iic b) → β\nx : α\n⊢ Eq (Set.IicExtend f x) (f ⟨Min.min b x, ⋯⟩)","decl":"theorem IicExtend_apply (f : Iic b → β) (x : α) : IicExtend f x = f ⟨min b x, min_le_left _ _⟩ :=\n  rfl\n\n"}
{"name":"Set.IccExtend_apply","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nf : ↑(Set.Icc a b) → β\nx : α\n⊢ Eq (Set.IccExtend h f x) (f ⟨Max.max a (Min.min b x), ⋯⟩)","decl":"theorem IccExtend_apply (h : a ≤ b) (f : Icc a b → β) (x : α) :\n    IccExtend h f x = f ⟨max a (min b x), le_max_left _ _, max_le h (min_le_left _ _)⟩ := rfl\n\n"}
{"name":"Set.range_IciExtend","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na : α\nf : ↑(Set.Ici a) → β\n⊢ Eq (Set.range (Set.IciExtend f)) (Set.range f)","decl":"@[simp]\ntheorem range_IciExtend (f : Ici a → β) : range (IciExtend f) = range f := by\n  simp only [IciExtend, range_comp f, range_projIci, range_id', image_univ]\n\n"}
{"name":"Set.range_IicExtend","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\nb : α\nf : ↑(Set.Iic b) → β\n⊢ Eq (Set.range (Set.IicExtend f)) (Set.range f)","decl":"@[simp]\ntheorem range_IicExtend (f : Iic b → β) : range (IicExtend f) = range f := by\n  simp only [IicExtend, range_comp f, range_projIic, range_id', image_univ]\n\n"}
{"name":"Set.IccExtend_range","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nf : ↑(Set.Icc a b) → β\n⊢ Eq (Set.range (Set.IccExtend h f)) (Set.range f)","decl":"@[simp]\ntheorem IccExtend_range (f : Icc a b → β) : range (IccExtend h f) = range f := by\n  simp only [IccExtend, range_comp f, range_projIcc, image_univ]\n\n"}
{"name":"Set.IciExtend_of_le","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na x : α\nf : ↑(Set.Ici a) → β\nhx : LE.le x a\n⊢ Eq (Set.IciExtend f x) (f ⟨a, ⋯⟩)","decl":"theorem IciExtend_of_le (f : Ici a → β) (hx : x ≤ a) : IciExtend f x = f ⟨a, le_rfl⟩ :=\n  congr_arg f <| projIci_of_le hx\n\n"}
{"name":"Set.IicExtend_of_le","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\nb x : α\nf : ↑(Set.Iic b) → β\nhx : LE.le b x\n⊢ Eq (Set.IicExtend f x) (f ⟨b, ⋯⟩)","decl":"theorem IicExtend_of_le (f : Iic b → β) (hx : b ≤ x) : IicExtend f x = f ⟨b, le_rfl⟩ :=\n  congr_arg f <| projIic_of_le hx\n\n"}
{"name":"Set.IccExtend_of_le_left","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nx : α\nf : ↑(Set.Icc a b) → β\nhx : LE.le x a\n⊢ Eq (Set.IccExtend h f x) (f ⟨a, ⋯⟩)","decl":"theorem IccExtend_of_le_left (f : Icc a b → β) (hx : x ≤ a) :\n    IccExtend h f x = f ⟨a, left_mem_Icc.2 h⟩ :=\n  congr_arg f <| projIcc_of_le_left h hx\n\n"}
{"name":"Set.IccExtend_of_right_le","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nx : α\nf : ↑(Set.Icc a b) → β\nhx : LE.le b x\n⊢ Eq (Set.IccExtend h f x) (f ⟨b, ⋯⟩)","decl":"theorem IccExtend_of_right_le (f : Icc a b → β) (hx : b ≤ x) :\n    IccExtend h f x = f ⟨b, right_mem_Icc.2 h⟩ :=\n  congr_arg f <| projIcc_of_right_le h hx\n\n"}
{"name":"Set.IciExtend_self","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na : α\nf : ↑(Set.Ici a) → β\n⊢ Eq (Set.IciExtend f a) (f ⟨a, ⋯⟩)","decl":"@[simp]\ntheorem IciExtend_self (f : Ici a → β) : IciExtend f a = f ⟨a, le_rfl⟩ :=\n  IciExtend_of_le f le_rfl\n\n"}
{"name":"Set.IicExtend_self","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\nb : α\nf : ↑(Set.Iic b) → β\n⊢ Eq (Set.IicExtend f b) (f ⟨b, ⋯⟩)","decl":"@[simp]\ntheorem IicExtend_self (f : Iic b → β) : IicExtend f b = f ⟨b, le_rfl⟩ :=\n  IicExtend_of_le f le_rfl\n\n"}
{"name":"Set.IccExtend_left","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nf : ↑(Set.Icc a b) → β\n⊢ Eq (Set.IccExtend h f a) (f ⟨a, ⋯⟩)","decl":"@[simp]\ntheorem IccExtend_left (f : Icc a b → β) : IccExtend h f a = f ⟨a, left_mem_Icc.2 h⟩ :=\n  IccExtend_of_le_left h f le_rfl\n\n"}
{"name":"Set.IccExtend_right","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nf : ↑(Set.Icc a b) → β\n⊢ Eq (Set.IccExtend h f b) (f ⟨b, ⋯⟩)","decl":"@[simp]\ntheorem IccExtend_right (f : Icc a b → β) : IccExtend h f b = f ⟨b, right_mem_Icc.2 h⟩ :=\n  IccExtend_of_right_le h f le_rfl\n\n"}
{"name":"Set.IciExtend_of_mem","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na x : α\nf : ↑(Set.Ici a) → β\nhx : Membership.mem (Set.Ici a) x\n⊢ Eq (Set.IciExtend f x) (f ⟨x, hx⟩)","decl":"theorem IciExtend_of_mem (f : Ici a → β) (hx : x ∈ Ici a) : IciExtend f x = f ⟨x, hx⟩ :=\n  congr_arg f <| projIci_of_mem hx\n\n"}
{"name":"Set.IicExtend_of_mem","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\nb x : α\nf : ↑(Set.Iic b) → β\nhx : Membership.mem (Set.Iic b) x\n⊢ Eq (Set.IicExtend f x) (f ⟨x, hx⟩)","decl":"theorem IicExtend_of_mem (f : Iic b → β) (hx : x ∈ Iic b) : IicExtend f x = f ⟨x, hx⟩ :=\n  congr_arg f <| projIic_of_mem hx\n\n"}
{"name":"Set.IccExtend_of_mem","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nx : α\nf : ↑(Set.Icc a b) → β\nhx : Membership.mem (Set.Icc a b) x\n⊢ Eq (Set.IccExtend h f x) (f ⟨x, hx⟩)","decl":"theorem IccExtend_of_mem (f : Icc a b → β) (hx : x ∈ Icc a b) : IccExtend h f x = f ⟨x, hx⟩ :=\n  congr_arg f <| projIcc_of_mem h hx\n\n"}
{"name":"Set.IciExtend_coe","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na : α\nf : ↑(Set.Ici a) → β\nx : ↑(Set.Ici a)\n⊢ Eq (Set.IciExtend f ↑x) (f x)","decl":"@[simp]\ntheorem IciExtend_coe (f : Ici a → β) (x : Ici a) : IciExtend f x = f x :=\n  congr_arg f <| projIci_coe x\n\n"}
{"name":"Set.IicExtend_coe","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\nb : α\nf : ↑(Set.Iic b) → β\nx : ↑(Set.Iic b)\n⊢ Eq (Set.IicExtend f ↑x) (f x)","decl":"@[simp]\ntheorem IicExtend_coe (f : Iic b → β) (x : Iic b) : IicExtend f x = f x :=\n  congr_arg f <| projIic_coe x\n\n"}
{"name":"Set.IccExtend_val","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nf : ↑(Set.Icc a b) → β\nx : ↑(Set.Icc a b)\n⊢ Eq (Set.IccExtend h f ↑x) (f x)","decl":"@[simp]\ntheorem IccExtend_val (f : Icc a b → β) (x : Icc a b) : IccExtend h f x = f x :=\n  congr_arg f <| projIcc_val h x\n\n"}
{"name":"Set.IccExtend_eq_self","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\nf : α → β\nha : ∀ (x : α), LT.lt x a → Eq (f x) (f a)\nhb : ∀ (x : α), LT.lt b x → Eq (f x) (f b)\n⊢ Eq (Set.IccExtend h (Function.comp f Subtype.val)) f","decl":"/-- If `f : α → β` is a constant both on $(-∞, a]$ and on $[b, +∞)$, then the extension of this\nfunction from $[a, b]$ to the whole line is equal to the original function. -/\ntheorem IccExtend_eq_self (f : α → β) (ha : ∀ x < a, f x = f a) (hb : ∀ x, b < x → f x = f b) :\n    IccExtend h (f ∘ (↑)) = f := by\n  ext x\n  cases' lt_or_le x a with hxa hax\n  · simp [IccExtend_of_le_left _ _ hxa.le, ha x hxa]\n  · rcases le_or_lt x b with hxb | hbx\n    · lift x to Icc a b using ⟨hax, hxb⟩\n      rw [IccExtend_val, comp_apply]\n    · simp [IccExtend_of_right_le _ _ hbx.le, hb x hbx]\n\n"}
{"name":"Monotone.IciExtend","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\na : α\nf : ↑(Set.Ici a) → β\nhf : Monotone f\n⊢ Monotone (Set.IciExtend f)","decl":"protected theorem Monotone.IciExtend {f : Ici a → β} (hf : Monotone f) : Monotone (IciExtend f) :=\n  hf.comp monotone_projIci\n\n"}
{"name":"Monotone.IicExtend","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nb : α\nf : ↑(Set.Iic b) → β\nhf : Monotone f\n⊢ Monotone (Set.IicExtend f)","decl":"protected theorem Monotone.IicExtend {f : Iic b → β} (hf : Monotone f) : Monotone (IicExtend f) :=\n  hf.comp monotone_projIic\n\n"}
{"name":"Monotone.IccExtend","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\na b : α\nh : LE.le a b\nf : ↑(Set.Icc a b) → β\nhf : Monotone f\n⊢ Monotone (Set.IccExtend h f)","decl":"protected theorem Monotone.IccExtend (hf : Monotone f) : Monotone (IccExtend h f) :=\n  hf.comp <| monotone_projIcc h\n\n"}
{"name":"StrictMono.strictMonoOn_IciExtend","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\na : α\nf : ↑(Set.Ici a) → β\nhf : StrictMono f\n⊢ StrictMonoOn (Set.IciExtend f) (Set.Ici a)","decl":"theorem StrictMono.strictMonoOn_IciExtend {f : Ici a → β} (hf : StrictMono f) :\n    StrictMonoOn (IciExtend f) (Ici a) :=\n  hf.comp_strictMonoOn strictMonoOn_projIci\n\n"}
{"name":"StrictMono.strictMonoOn_IicExtend","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nb : α\nf : ↑(Set.Iic b) → β\nhf : StrictMono f\n⊢ StrictMonoOn (Set.IicExtend f) (Set.Iic b)","decl":"theorem StrictMono.strictMonoOn_IicExtend {f : Iic b → β} (hf : StrictMono f) :\n    StrictMonoOn (IicExtend f) (Iic b) :=\n  hf.comp_strictMonoOn strictMonoOn_projIic\n\n"}
{"name":"StrictMono.strictMonoOn_IccExtend","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\na b : α\nh : LE.le a b\nf : ↑(Set.Icc a b) → β\nhf : StrictMono f\n⊢ StrictMonoOn (Set.IccExtend h f) (Set.Icc a b)","decl":"theorem StrictMono.strictMonoOn_IccExtend (hf : StrictMono f) :\n    StrictMonoOn (IccExtend h f) (Icc a b) :=\n  hf.comp_strictMonoOn (strictMonoOn_projIcc h)\n\n"}
{"name":"Set.OrdConnected.IciExtend","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\ns : Set ↑(Set.Ici a)\nhs : s.OrdConnected\n⊢ (setOf fun x => Set.IciExtend (fun x => Membership.mem s x) x).OrdConnected","decl":"protected theorem Set.OrdConnected.IciExtend {s : Set (Ici a)} (hs : s.OrdConnected) :\n    {x | IciExtend (· ∈ s) x}.OrdConnected :=\n  ⟨fun _ hx _ hy _ hz => hs.out hx hy ⟨max_le_max le_rfl hz.1, max_le_max le_rfl hz.2⟩⟩\n\n"}
{"name":"Set.OrdConnected.IicExtend","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb : α\ns : Set ↑(Set.Iic b)\nhs : s.OrdConnected\n⊢ (setOf fun x => Set.IicExtend (fun x => Membership.mem s x) x).OrdConnected","decl":"protected theorem Set.OrdConnected.IicExtend {s : Set (Iic b)} (hs : s.OrdConnected) :\n    {x | IicExtend (· ∈ s) x}.OrdConnected :=\n  ⟨fun _ hx _ hy _ hz => hs.out hx hy ⟨min_le_min le_rfl hz.1, min_le_min le_rfl hz.2⟩⟩\n\n"}
{"name":"Set.OrdConnected.restrict","module":"Mathlib.Order.Interval.Set.ProjIcc","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns t : Set α\nhs : s.OrdConnected\n⊢ (setOf fun x => t.restrict (fun x => Membership.mem s x) x).OrdConnected","decl":"protected theorem Set.OrdConnected.restrict (hs : s.OrdConnected) :\n    {x | restrict t (· ∈ s) x}.OrdConnected :=\n  ⟨fun _ hx _ hy _ hz => hs.out hx hy hz⟩\n"}
