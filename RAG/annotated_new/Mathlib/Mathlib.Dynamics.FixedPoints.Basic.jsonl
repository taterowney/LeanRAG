{"name":"Function.isFixedPt_id","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nx : α\n⊢ Function.IsFixedPt id x","decl":"/-- Every point is a fixed point of `id`. -/\ntheorem isFixedPt_id (x : α) : IsFixedPt id x :=\n  (rfl :)\n\n"}
{"name":"Function.IsFixedPt.eq","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf : α → α\nx : α\nhf : Function.IsFixedPt f x\n⊢ Eq (f x) x","decl":"/-- If `x` is a fixed point of `f`, then `f x = x`. This is useful, e.g., for `rw` or `simp`. -/\nprotected theorem eq (hf : IsFixedPt f x) : f x = x :=\n  hf\n\n"}
{"name":"Function.IsFixedPt.comp","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf g : α → α\nx : α\nhf : Function.IsFixedPt f x\nhg : Function.IsFixedPt g x\n⊢ Function.IsFixedPt (Function.comp f g) x","decl":"/-- If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ∘ g`. -/\nprotected theorem comp (hf : IsFixedPt f x) (hg : IsFixedPt g x) : IsFixedPt (f ∘ g) x :=\n  calc\n    f (g x) = f x := congr_arg f hg\n    _ = x := hf\n\n"}
{"name":"Function.IsFixedPt.iterate","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf : α → α\nx : α\nhf : Function.IsFixedPt f x\nn : Nat\n⊢ Function.IsFixedPt (Nat.iterate f n) x","decl":"/-- If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. -/\nprotected theorem iterate (hf : IsFixedPt f x) (n : ℕ) : IsFixedPt f^[n] x :=\n  iterate_fixed hf n\n\n"}
{"name":"Function.IsFixedPt.left_of_comp","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf g : α → α\nx : α\nhfg : Function.IsFixedPt (Function.comp f g) x\nhg : Function.IsFixedPt g x\n⊢ Function.IsFixedPt f x","decl":"/-- If `x` is a fixed point of `f ∘ g` and `g`, then it is a fixed point of `f`. -/\ntheorem left_of_comp (hfg : IsFixedPt (f ∘ g) x) (hg : IsFixedPt g x) : IsFixedPt f x :=\n  calc\n    f x = f (g x) := congr_arg f hg.symm\n    _ = x := hfg\n\n"}
{"name":"Function.IsFixedPt.to_leftInverse","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf g : α → α\nx : α\nhf : Function.IsFixedPt f x\nh : Function.LeftInverse g f\n⊢ Function.IsFixedPt g x","decl":"/-- If `x` is a fixed point of `f` and `g` is a left inverse of `f`, then `x` is a fixed\npoint of `g`. -/\ntheorem to_leftInverse (hf : IsFixedPt f x) (h : LeftInverse g f) : IsFixedPt g x :=\n  calc\n    g x = g (f x) := congr_arg g hf.symm\n    _ = x := h x\n\n"}
{"name":"Function.IsFixedPt.map","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nβ : Type v\nfa : α → α\nfb : β → β\nx : α\nhx : Function.IsFixedPt fa x\ng : α → β\nh : Function.Semiconj g fa fb\n⊢ Function.IsFixedPt fb (g x)","decl":"/-- If `g` (semi)conjugates `fa` to `fb`, then it sends fixed points of `fa` to fixed points\nof `fb`. -/\nprotected theorem map {x : α} (hx : IsFixedPt fa x) {g : α → β} (h : Semiconj g fa fb) :\n    IsFixedPt fb (g x) :=\n  calc\n    fb (g x) = g (fa x) := (h.eq x).symm\n    _ = g x := congr_arg g hx\n\n"}
{"name":"Function.IsFixedPt.apply","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf : α → α\nx : α\nhx : Function.IsFixedPt f x\n⊢ Function.IsFixedPt f (f x)","decl":"protected theorem apply {x : α} (hx : IsFixedPt f x) : IsFixedPt f (f x) := by convert hx\n\n"}
{"name":"Function.IsFixedPt.preimage_iterate","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf : α → α\ns : Set α\nh : Function.IsFixedPt (Set.preimage f) s\nn : Nat\n⊢ Function.IsFixedPt (Set.preimage (Nat.iterate f n)) s","decl":"theorem preimage_iterate {s : Set α} (h : IsFixedPt (Set.preimage f) s) (n : ℕ) :\n    IsFixedPt (Set.preimage f^[n]) s := by\n  rw [Set.preimage_iterate_eq]\n  exact h.iterate n\n\n"}
{"name":"Function.IsFixedPt.image_iterate","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf : α → α\ns : Set α\nh : Function.IsFixedPt (Set.image f) s\nn : Nat\n⊢ Function.IsFixedPt (Set.image (Nat.iterate f n)) s","decl":"lemma image_iterate {s : Set α} (h : IsFixedPt (Set.image f) s) (n : ℕ) :\n    IsFixedPt (Set.image f^[n]) s :=\n  Set.image_iterate_eq ▸ h.iterate n\n\n"}
{"name":"Function.IsFixedPt.equiv_symm","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nx : α\ne : Equiv.Perm α\nh : Function.IsFixedPt (⇑e) x\n⊢ Function.IsFixedPt (⇑(Equiv.symm e)) x","decl":"protected theorem equiv_symm (h : IsFixedPt e x) : IsFixedPt e.symm x :=\n  h.to_leftInverse e.leftInverse_symm\n\n"}
{"name":"Function.IsFixedPt.perm_inv","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nx : α\ne : Equiv.Perm α\nh : Function.IsFixedPt (⇑e) x\n⊢ Function.IsFixedPt (⇑(Inv.inv e)) x","decl":"protected theorem perm_inv (h : IsFixedPt e x) : IsFixedPt (⇑e⁻¹) x :=\n  h.equiv_symm\n\n"}
{"name":"Function.IsFixedPt.perm_pow","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nx : α\ne : Equiv.Perm α\nh : Function.IsFixedPt (⇑e) x\nn : Nat\n⊢ Function.IsFixedPt (⇑(HPow.hPow e n)) x","decl":"protected theorem perm_pow (h : IsFixedPt e x) (n : ℕ) : IsFixedPt (⇑(e ^ n)) x := h.iterate _\n\n"}
{"name":"Function.IsFixedPt.perm_zpow","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nx : α\ne : Equiv.Perm α\nh : Function.IsFixedPt (⇑e) x\nn : Int\n⊢ Function.IsFixedPt (⇑(HPow.hPow e n)) x","decl":"protected theorem perm_zpow (h : IsFixedPt e x) : ∀ n : ℤ, IsFixedPt (⇑(e ^ n)) x\n  | Int.ofNat _ => h.perm_pow _\n  | Int.negSucc n => (h.perm_pow <| n + 1).perm_inv\n\n"}
{"name":"Function.Injective.isFixedPt_apply_iff","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf : α → α\nhf : Function.Injective f\nx : α\n⊢ Iff (Function.IsFixedPt f (f x)) (Function.IsFixedPt f x)","decl":"@[simp]\ntheorem Injective.isFixedPt_apply_iff (hf : Injective f) {x : α} :\n    IsFixedPt f (f x) ↔ IsFixedPt f x :=\n  ⟨fun h => hf h.eq, IsFixedPt.apply⟩\n\n"}
{"name":"Function.mem_fixedPoints","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf : α → α\nx : α\n⊢ Iff (Membership.mem (Function.fixedPoints f) x) (Function.IsFixedPt f x)","decl":"@[simp]\ntheorem mem_fixedPoints : x ∈ fixedPoints f ↔ IsFixedPt f x :=\n  Iff.rfl\n\n"}
{"name":"Function.mem_fixedPoints_iff","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u_1\nf : α → α\nx : α\n⊢ Iff (Membership.mem (Function.fixedPoints f) x) (Eq (f x) x)","decl":"theorem mem_fixedPoints_iff {α : Type*} {f : α → α} {x : α} : x ∈ fixedPoints f ↔ f x = x := by\n  rfl\n\n"}
{"name":"Function.fixedPoints_id","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\n⊢ Eq (Function.fixedPoints id) Set.univ","decl":"@[simp]\ntheorem fixedPoints_id : fixedPoints (@id α) = Set.univ :=\n  Set.ext fun _ => by simpa using isFixedPt_id _\n\n"}
{"name":"Function.fixedPoints_subset_range","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf : α → α\n⊢ HasSubset.Subset (Function.fixedPoints f) (Set.range f)","decl":"theorem fixedPoints_subset_range : fixedPoints f ⊆ Set.range f := fun x hx => ⟨x, hx⟩\n\n"}
{"name":"Function.Semiconj.mapsTo_fixedPoints","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nβ : Type v\nfa : α → α\nfb : β → β\ng : α → β\nh : Function.Semiconj g fa fb\n⊢ Set.MapsTo g (Function.fixedPoints fa) (Function.fixedPoints fb)","decl":"/-- If `g` semiconjugates `fa` to `fb`, then it sends fixed points of `fa` to fixed points\nof `fb`. -/\ntheorem Semiconj.mapsTo_fixedPoints {g : α → β} (h : Semiconj g fa fb) :\n    Set.MapsTo g (fixedPoints fa) (fixedPoints fb) := fun _ hx => hx.map h\n\n"}
{"name":"Function.invOn_fixedPoints_comp","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : β → α\n⊢ Set.InvOn f g (Function.fixedPoints (Function.comp f g)) (Function.fixedPoints (Function.comp g f))","decl":"/-- Any two maps `f : α → β` and `g : β → α` are inverse of each other on the sets of fixed points\nof `f ∘ g` and `g ∘ f`, respectively. -/\ntheorem invOn_fixedPoints_comp (f : α → β) (g : β → α) :\n    Set.InvOn f g (fixedPoints <| f ∘ g) (fixedPoints <| g ∘ f) :=\n  ⟨fun _ => id, fun _ => id⟩\n\n"}
{"name":"Function.mapsTo_fixedPoints_comp","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : β → α\n⊢ Set.MapsTo f (Function.fixedPoints (Function.comp g f)) (Function.fixedPoints (Function.comp f g))","decl":"/-- Any map `f` sends fixed points of `g ∘ f` to fixed points of `f ∘ g`. -/\ntheorem mapsTo_fixedPoints_comp (f : α → β) (g : β → α) :\n    Set.MapsTo f (fixedPoints <| g ∘ f) (fixedPoints <| f ∘ g) := fun _ hx => hx.map fun _ => rfl\n\n"}
{"name":"Function.bijOn_fixedPoints_comp","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ng : β → α\n⊢ Set.BijOn g (Function.fixedPoints (Function.comp f g)) (Function.fixedPoints (Function.comp g f))","decl":"/-- Given two maps `f : α → β` and `g : β → α`, `g` is a bijective map between the fixed points\nof `f ∘ g` and the fixed points of `g ∘ f`. The inverse map is `f`, see `invOn_fixedPoints_comp`. -/\ntheorem bijOn_fixedPoints_comp (f : α → β) (g : β → α) :\n    Set.BijOn g (fixedPoints <| f ∘ g) (fixedPoints <| g ∘ f) :=\n  (invOn_fixedPoints_comp f g).bijOn (mapsTo_fixedPoints_comp g f) (mapsTo_fixedPoints_comp f g)\n\n"}
{"name":"Function.Commute.invOn_fixedPoints_comp","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf g : α → α\nh : Function.Commute f g\n⊢ Set.InvOn f g (Function.fixedPoints (Function.comp f g)) (Function.fixedPoints (Function.comp f g))","decl":"/-- If self-maps `f` and `g` commute, then they are inverse of each other on the set of fixed points\nof `f ∘ g`. This is a particular case of `Function.invOn_fixedPoints_comp`. -/\ntheorem Commute.invOn_fixedPoints_comp (h : Commute f g) :\n    Set.InvOn f g (fixedPoints <| f ∘ g) (fixedPoints <| f ∘ g) := by\n  simpa only [h.comp_eq] using Function.invOn_fixedPoints_comp f g\n\n"}
{"name":"Function.Commute.left_bijOn_fixedPoints_comp","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf g : α → α\nh : Function.Commute f g\n⊢ Set.BijOn f (Function.fixedPoints (Function.comp f g)) (Function.fixedPoints (Function.comp f g))","decl":"/-- If self-maps `f` and `g` commute, then `f` is bijective on the set of fixed points of `f ∘ g`.\nThis is a particular case of `Function.bijOn_fixedPoints_comp`. -/\ntheorem Commute.left_bijOn_fixedPoints_comp (h : Commute f g) :\n    Set.BijOn f (fixedPoints <| f ∘ g) (fixedPoints <| f ∘ g) := by\n  simpa only [h.comp_eq] using bijOn_fixedPoints_comp g f\n\n"}
{"name":"Function.Commute.right_bijOn_fixedPoints_comp","module":"Mathlib.Dynamics.FixedPoints.Basic","initialProofState":"α : Type u\nf g : α → α\nh : Function.Commute f g\n⊢ Set.BijOn g (Function.fixedPoints (Function.comp f g)) (Function.fixedPoints (Function.comp f g))","decl":"/-- If self-maps `f` and `g` commute, then `g` is bijective on the set of fixed points of `f ∘ g`.\nThis is a particular case of `Function.bijOn_fixedPoints_comp`. -/\ntheorem Commute.right_bijOn_fixedPoints_comp (h : Commute f g) :\n    Set.BijOn g (fixedPoints <| f ∘ g) (fixedPoints <| f ∘ g) := by\n  simpa only [h.comp_eq] using bijOn_fixedPoints_comp f g\n\n"}
