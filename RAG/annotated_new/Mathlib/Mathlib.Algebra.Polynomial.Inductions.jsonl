{"name":"Polynomial.coeff_divX","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\nn : Nat\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (p.divX.coeff n) (p.coeff (HAdd.hAdd n 1))","decl":"@[simp]\ntheorem coeff_divX : (divX p).coeff n = p.coeff (n + 1) := by\n  rw [add_comm]; cases p; rfl\n\n"}
{"name":"Polynomial.divX_mul_X_add","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (HAdd.hAdd (HMul.hMul p.divX Polynomial.X) (Polynomial.C (p.coeff 0))) p","decl":"theorem divX_mul_X_add (p : R[X]) : divX p * X + C (p.coeff 0) = p :=\n  ext <| by rintro ⟨_ | _⟩ <;> simp [coeff_C, Nat.succ_ne_zero, coeff_mul_X]\n\n"}
{"name":"Polynomial.X_mul_divX_add","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (HAdd.hAdd (HMul.hMul Polynomial.X p.divX) (Polynomial.C (p.coeff 0))) p","decl":"@[simp]\ntheorem X_mul_divX_add (p : R[X]) : X * divX p + C (p.coeff 0) = p :=\n  ext <| by rintro ⟨_ | _⟩ <;> simp [coeff_C, Nat.succ_ne_zero, coeff_mul_X]\n\n"}
{"name":"Polynomial.divX_C","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\ninst✝ : Semiring R\na : R\n⊢ Eq (Polynomial.C a).divX 0","decl":"@[simp]\ntheorem divX_C (a : R) : divX (C a) = 0 :=\n  ext fun n => by simp [coeff_divX, coeff_C, Finsupp.single_eq_of_ne _]\n\n"}
{"name":"Polynomial.divX_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Iff (Eq p.divX 0) (Eq p (Polynomial.C (p.coeff 0)))","decl":"theorem divX_eq_zero_iff : divX p = 0 ↔ p = C (p.coeff 0) :=\n  ⟨fun h => by simpa [eq_comm, h] using divX_mul_X_add p, fun h => by rw [h, divX_C]⟩\n\n"}
{"name":"Polynomial.divX_add","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\n⊢ Eq (HAdd.hAdd p q).divX (HAdd.hAdd p.divX q.divX)","decl":"theorem divX_add : divX (p + q) = divX p + divX q :=\n  ext <| by simp\n\n"}
{"name":"Polynomial.divX_zero","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.divX 0) 0","decl":"@[simp]\ntheorem divX_zero : divX (0 : R[X]) = 0 := leadingCoeff_eq_zero.mp rfl\n\n"}
{"name":"Polynomial.divX_one","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Eq (Polynomial.divX 1) 0","decl":"@[simp]\ntheorem divX_one : divX (1 : R[X]) = 0 := by\n  ext\n  simpa only [coeff_divX, coeff_zero] using coeff_one\n\n"}
{"name":"Polynomial.divX_C_mul","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\na : R\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (HMul.hMul (Polynomial.C a) p).divX (HMul.hMul (Polynomial.C a) p.divX)","decl":"@[simp]\ntheorem divX_C_mul : divX (C a * p) = C a * divX p := by\n  ext\n  simp\n\n"}
{"name":"Polynomial.divX_X_pow","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\nn : Nat\ninst✝ : Semiring R\n⊢ Eq (HPow.hPow Polynomial.X n).divX (ite (Eq n 0) 0 (HPow.hPow Polynomial.X (HSub.hSub n 1)))","decl":"theorem divX_X_pow : divX (X ^ n : R[X]) = if (n = 0) then 0 else X ^ (n - 1) := by\n  cases n\n  · simp\n  · ext n\n    simp [coeff_X_pow]\n\n"}
{"name":"Polynomial.divX_hom_toFun","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (Polynomial.divX_hom p) p.divX","decl":"@[simp] theorem divX_hom_toFun : divX_hom p = divX p := rfl\n\n"}
{"name":"Polynomial.natDegree_divX_eq_natDegree_tsub_one","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq p.divX.natDegree (HSub.hSub p.natDegree 1)","decl":"theorem natDegree_divX_eq_natDegree_tsub_one : p.divX.natDegree = p.natDegree - 1 := by\n  apply map_natDegree_eq_sub (φ := divX_hom)\n  · intro f\n    simpa [divX_hom, divX_eq_zero_iff] using eq_C_of_natDegree_eq_zero\n  · intros n c c0\n    rw [← C_mul_X_pow_eq_monomial, divX_hom_toFun, divX_C_mul, divX_X_pow]\n    split_ifs with n0\n    · simp [n0]\n    · exact natDegree_C_mul_X_pow (n - 1) c c0\n\n"}
{"name":"Polynomial.natDegree_divX_le","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ LE.le p.divX.natDegree p.natDegree","decl":"theorem natDegree_divX_le : p.divX.natDegree ≤ p.natDegree :=\n  natDegree_divX_eq_natDegree_tsub_one.trans_le (Nat.pred_le _)\n\n"}
{"name":"Polynomial.divX_C_mul_X_pow","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\na : R\nn : Nat\ninst✝ : Semiring R\n⊢ Eq (HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X n)).divX (ite (Eq n 0) 0 (HMul.hMul (Polynomial.C a) (HPow.hPow Polynomial.X (HSub.hSub n 1))))","decl":"theorem divX_C_mul_X_pow : divX (C a * X ^ n) = if n = 0 then 0 else C a * X ^ (n - 1) := by\n  simp only [divX_C_mul, divX_X_pow, mul_ite, mul_zero]\n\n"}
{"name":"Polynomial.degree_divX_lt","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp0 : Ne p 0\n⊢ LT.lt p.divX.degree p.degree","decl":"theorem degree_divX_lt (hp0 : p ≠ 0) : (divX p).degree < p.degree := by\n  haveI := Nontrivial.of_polynomial_ne hp0\n  calc\n    degree (divX p) < (divX p * X + C (p.coeff 0)).degree :=\n      if h : degree p ≤ 0 then by\n        have h' : C (p.coeff 0) ≠ 0 := by rwa [← eq_C_of_degree_le_zero h]\n        rw [eq_C_of_degree_le_zero h, divX_C, degree_zero, zero_mul, zero_add]\n        exact lt_of_le_of_ne bot_le (Ne.symm (mt degree_eq_bot.1 <| by simpa using h'))\n      else by\n        have hXp0 : divX p ≠ 0 := by\n          simpa [divX_eq_zero_iff, -not_le, degree_le_zero_iff] using h\n        have : leadingCoeff (divX p) * leadingCoeff X ≠ 0 := by simpa\n        have : degree (C (p.coeff 0)) < degree (divX p * X) :=\n          calc\n            degree (C (p.coeff 0)) ≤ 0 := degree_C_le\n            _ < 1 := by decide\n            _ = degree (X : R[X]) := degree_X.symm\n            _ ≤ degree (divX p * X) := by\n              rw [← zero_add (degree X), degree_mul' this]\n              exact add_le_add\n                (by rw [zero_le_degree_iff, Ne, divX_eq_zero_iff]\n                    exact fun h0 => h (h0.symm ▸ degree_C_le))\n                    le_rfl\n        rw [degree_add_eq_left_of_degree_lt this]; exact degree_lt_degree_mul_X hXp0\n    _ = degree p := congr_arg _ (divX_mul_X_add _)\n\n"}
{"name":"Polynomial.degree_pos_induction_on","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\ninst✝ : Semiring R\nP : Polynomial R → Prop\np : Polynomial R\nh0 : LT.lt 0 p.degree\nhC : ∀ {a : R}, Ne a 0 → P (HMul.hMul (Polynomial.C a) Polynomial.X)\nhX : ∀ {p : Polynomial R}, LT.lt 0 p.degree → P p → P (HMul.hMul p Polynomial.X)\nhadd : ∀ {p : Polynomial R} {a : R}, LT.lt 0 p.degree → P p → P (HAdd.hAdd p (Polynomial.C a))\n⊢ P p","decl":"/-- A property holds for all polynomials of positive `degree` with coefficients in a semiring `R`\nif it holds for\n* `a * X`, with `a ∈ R`,\n* `p * X`, with `p ∈ R[X]`,\n* `p + a`, with `a ∈ R`, `p ∈ R[X]`,\nwith appropriate restrictions on each term.\n\nSee `natDegree_ne_zero_induction_on` for a similar statement involving no explicit multiplication.\n -/\n@[elab_as_elim]\ntheorem degree_pos_induction_on {P : R[X] → Prop} (p : R[X]) (h0 : 0 < degree p)\n    (hC : ∀ {a}, a ≠ 0 → P (C a * X)) (hX : ∀ {p}, 0 < degree p → P p → P (p * X))\n    (hadd : ∀ {p} {a}, 0 < degree p → P p → P (p + C a)) : P p :=\n  recOnHorner p (fun h => by rw [degree_zero] at h; exact absurd h (by decide))\n    (fun p a heq0 _ ih h0 =>\n      (have : 0 < degree p :=\n        (lt_of_not_ge fun h =>\n          not_lt_of_ge (degree_C_le (a := a)) <|\n            by rwa [eq_C_of_degree_le_zero h, ← C_add,heq0,zero_add] at h0)\n      hadd this (ih this)))\n    (fun p _ ih h0' =>\n      if h0 : 0 < degree p then hX h0 (ih h0)\n      else by\n        rw [eq_C_of_degree_le_zero (le_of_not_gt h0)] at h0' ⊢\n        exact hC fun h : coeff p 0 = 0 => by simp [h, Nat.not_lt_zero] at h0')\n    h0\n\n"}
{"name":"Polynomial.natDegree_ne_zero_induction_on","module":"Mathlib.Algebra.Polynomial.Inductions","initialProofState":"R : Type u\ninst✝ : Semiring R\nM : Polynomial R → Prop\nf : Polynomial R\nf0 : Ne f.natDegree 0\nh_C_add : ∀ {a : R} {p : Polynomial R}, M p → M (HAdd.hAdd (Polynomial.C a) p)\nh_add : ∀ {p q : Polynomial R}, M p → M q → M (HAdd.hAdd p q)\nh_monomial : ∀ {n : Nat} {a : R}, Ne a 0 → Ne n 0 → M ((Polynomial.monomial n) a)\n⊢ M f","decl":"/-- A property holds for all polynomials of non-zero `natDegree` with coefficients in a\nsemiring `R` if it holds for\n* `p + a`, with `a ∈ R`, `p ∈ R[X]`,\n* `p + q`, with `p, q ∈ R[X]`,\n* monomials with nonzero coefficient and non-zero exponent,\nwith appropriate restrictions on each term.\nNote that multiplication is \"hidden\" in the assumption on monomials, so there is no explicit\nmultiplication in the statement.\nSee `degree_pos_induction_on` for a similar statement involving more explicit multiplications.\n -/\n@[elab_as_elim]\ntheorem natDegree_ne_zero_induction_on {M : R[X] → Prop} {f : R[X]} (f0 : f.natDegree ≠ 0)\n    (h_C_add : ∀ {a p}, M p → M (C a + p)) (h_add : ∀ {p q}, M p → M q → M (p + q))\n    (h_monomial : ∀ {n : ℕ} {a : R}, a ≠ 0 → n ≠ 0 → M (monomial n a)) : M f := by\n  suffices f.natDegree = 0 ∨ M f from Or.recOn this (fun h => (f0 h).elim) id\n  refine Polynomial.induction_on f ?_ ?_ ?_\n  · exact fun a => Or.inl (natDegree_C _)\n  · rintro p q (hp | hp) (hq | hq)\n    · refine Or.inl ?_\n      rw [eq_C_of_natDegree_eq_zero hp, eq_C_of_natDegree_eq_zero hq, ← C_add, natDegree_C]\n    · refine Or.inr ?_\n      rw [eq_C_of_natDegree_eq_zero hp]\n      exact h_C_add hq\n    · refine Or.inr ?_\n      rw [eq_C_of_natDegree_eq_zero hq, add_comm]\n      exact h_C_add hp\n    · exact Or.inr (h_add hp hq)\n  · intro n a _\n    by_cases a0 : a = 0\n    · exact Or.inl (by rw [a0, C_0, zero_mul, natDegree_zero])\n    · refine Or.inr ?_\n      rw [C_mul_X_pow_eq_monomial]\n      exact h_monomial a0 n.succ_ne_zero\n\n"}
