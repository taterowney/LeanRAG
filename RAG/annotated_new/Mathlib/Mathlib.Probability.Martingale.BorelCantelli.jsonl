{"name":"MeasureTheory.Adapted.isStoppingTime_leastGE","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nr : Real\nn : Nat\nhf : MeasureTheory.Adapted ℱ f\n⊢ MeasureTheory.IsStoppingTime ℱ (MeasureTheory.leastGE f r n)","decl":"theorem Adapted.isStoppingTime_leastGE (r : ℝ) (n : ℕ) (hf : Adapted ℱ f) :\n    IsStoppingTime ℱ (leastGE f r n) :=\n  hitting_isStoppingTime hf measurableSet_Ici\n\n"}
{"name":"MeasureTheory.leastGE_le","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nf : Nat → Ω → Real\ni : Nat\nr : Real\nω : Ω\n⊢ LE.le (MeasureTheory.leastGE f r i ω) i","decl":"theorem leastGE_le {i : ℕ} {r : ℝ} (ω : Ω) : leastGE f r i ω ≤ i :=\n  hitting_le ω\n\n-- The following four lemmas shows `leastGE` behaves like a stopped process. Ideally we should\n-- define `leastGE` as a stopping time and take its stopped process. However, we can't do that\n-- with our current definition since a stopping time takes only finite indices. An upcoming\n-- refactor should hopefully make it possible to have stopping times taking infinity as a value\n"}
{"name":"MeasureTheory.leastGE_mono","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nf : Nat → Ω → Real\nn m : Nat\nhnm : LE.le n m\nr : Real\nω : Ω\n⊢ LE.le (MeasureTheory.leastGE f r n ω) (MeasureTheory.leastGE f r m ω)","decl":"theorem leastGE_mono {n m : ℕ} (hnm : n ≤ m) (r : ℝ) (ω : Ω) : leastGE f r n ω ≤ leastGE f r m ω :=\n  hitting_mono hnm\n\n"}
{"name":"MeasureTheory.leastGE_eq_min","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nf : Nat → Ω → Real\nπ : Ω → Nat\nr : Real\nω : Ω\nn : Nat\nhπn : ∀ (ω : Ω), LE.le (π ω) n\n⊢ Eq (MeasureTheory.leastGE f r (π ω) ω) (Min.min (π ω) (MeasureTheory.leastGE f r n ω))","decl":"theorem leastGE_eq_min (π : Ω → ℕ) (r : ℝ) (ω : Ω) {n : ℕ} (hπn : ∀ ω, π ω ≤ n) :\n    leastGE f r (π ω) ω = min (π ω) (leastGE f r n ω) := by\n  classical\n  refine le_antisymm (le_min (leastGE_le _) (leastGE_mono (hπn ω) r ω)) ?_\n  by_cases hle : π ω ≤ leastGE f r n ω\n  · rw [min_eq_left hle, leastGE]\n    by_cases h : ∃ j ∈ Set.Icc 0 (π ω), f j ω ∈ Set.Ici r\n    · refine hle.trans (Eq.le ?_)\n      rw [leastGE, ← hitting_eq_hitting_of_exists (hπn ω) h]\n    · simp only [hitting, if_neg h, le_rfl]\n  · rw [min_eq_right (not_le.1 hle).le, leastGE, leastGE, ←\n      hitting_eq_hitting_of_exists (hπn ω) _]\n    rw [not_le, leastGE, hitting_lt_iff _ (hπn ω)] at hle\n    exact\n      let ⟨j, hj₁, hj₂⟩ := hle\n      ⟨j, ⟨hj₁.1, hj₁.2.le⟩, hj₂⟩\n\n"}
{"name":"MeasureTheory.stoppedValue_stoppedValue_leastGE","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nf : Nat → Ω → Real\nπ : Ω → Nat\nr : Real\nn : Nat\nhπn : ∀ (ω : Ω), LE.le (π ω) n\n⊢ Eq (MeasureTheory.stoppedValue (fun i => MeasureTheory.stoppedValue f (MeasureTheory.leastGE f r i)) π) (MeasureTheory.stoppedValue (MeasureTheory.stoppedProcess f (MeasureTheory.leastGE f r n)) π)","decl":"theorem stoppedValue_stoppedValue_leastGE (f : ℕ → Ω → ℝ) (π : Ω → ℕ) (r : ℝ) {n : ℕ}\n    (hπn : ∀ ω, π ω ≤ n) : stoppedValue (fun i => stoppedValue f (leastGE f r i)) π =\n      stoppedValue (stoppedProcess f (leastGE f r n)) π := by\n  ext1 ω\n  simp (config := { unfoldPartialApp := true }) only [stoppedProcess, stoppedValue]\n  rw [leastGE_eq_min _ _ _ hπn]\n\n"}
{"name":"MeasureTheory.Submartingale.stoppedValue_leastGE","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nr : Real\n⊢ MeasureTheory.Submartingale (fun i => MeasureTheory.stoppedValue f (MeasureTheory.leastGE f r i)) ℱ μ","decl":"theorem Submartingale.stoppedValue_leastGE [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ) (r : ℝ) :\n    Submartingale (fun i => stoppedValue f (leastGE f r i)) ℱ μ := by\n  rw [submartingale_iff_expected_stoppedValue_mono]\n  · intro σ π hσ hπ hσ_le_π hπ_bdd\n    obtain ⟨n, hπ_le_n⟩ := hπ_bdd\n    simp_rw [stoppedValue_stoppedValue_leastGE f σ r fun i => (hσ_le_π i).trans (hπ_le_n i)]\n    simp_rw [stoppedValue_stoppedValue_leastGE f π r hπ_le_n]\n    refine hf.expected_stoppedValue_mono ?_ ?_ ?_ fun ω => (min_le_left _ _).trans (hπ_le_n ω)\n    · exact hσ.min (hf.adapted.isStoppingTime_leastGE _ _)\n    · exact hπ.min (hf.adapted.isStoppingTime_leastGE _ _)\n    · exact fun ω => min_le_min (hσ_le_π ω) le_rfl\n  · exact fun i => stronglyMeasurable_stoppedValue_of_le hf.adapted.progMeasurable_of_discrete\n      (hf.adapted.isStoppingTime_leastGE _ _) leastGE_le\n  · exact fun i => integrable_stoppedValue _ (hf.adapted.isStoppingTime_leastGE _ _) hf.integrable\n      leastGE_le\n\n"}
{"name":"MeasureTheory.norm_stoppedValue_leastGE_le","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nf : Nat → Ω → Real\nr : Real\nR : NNReal\nhr : LE.le 0 r\nhf0 : Eq (f 0) 0\nhbdd : Filter.Eventually (fun ω => ∀ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) ω) (f i ω))) ↑R) (MeasureTheory.ae μ)\ni : Nat\n⊢ Filter.Eventually (fun ω => LE.le (MeasureTheory.stoppedValue f (MeasureTheory.leastGE f r i) ω) (HAdd.hAdd r ↑R)) (MeasureTheory.ae μ)","decl":"theorem norm_stoppedValue_leastGE_le (hr : 0 ≤ r) (hf0 : f 0 = 0)\n    (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) (i : ℕ) :\n    ∀ᵐ ω ∂μ, stoppedValue f (leastGE f r i) ω ≤ r + R := by\n  filter_upwards [hbdd] with ω hbddω\n  change f (leastGE f r i ω) ω ≤ r + R\n  by_cases heq : leastGE f r i ω = 0\n  · rw [heq, hf0, Pi.zero_apply]\n    exact add_nonneg hr R.coe_nonneg\n  · obtain ⟨k, hk⟩ := Nat.exists_eq_succ_of_ne_zero heq\n    rw [hk, add_comm, ← sub_le_iff_le_add]\n    have := not_mem_of_lt_hitting (hk.symm ▸ k.lt_succ_self : k < leastGE f r i ω) (zero_le _)\n    simp only [Set.mem_union, Set.mem_Iic, Set.mem_Ici, not_or, not_le] at this\n    exact (sub_lt_sub_left this _).le.trans ((le_abs_self _).trans (hbddω _))\n\n"}
{"name":"MeasureTheory.Submartingale.stoppedValue_leastGE_eLpNorm_le","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nr : Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhr : LE.le 0 r\nhf0 : Eq (f 0) 0\nhbdd : Filter.Eventually (fun ω => ∀ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) ω) (f i ω))) ↑R) (MeasureTheory.ae μ)\ni : Nat\n⊢ LE.le (MeasureTheory.eLpNorm (MeasureTheory.stoppedValue f (MeasureTheory.leastGE f r i)) 1 μ) (HMul.hMul (HMul.hMul 2 (μ Set.univ)) (ENNReal.ofReal (HAdd.hAdd r ↑R)))","decl":"theorem Submartingale.stoppedValue_leastGE_eLpNorm_le [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)\n    (hr : 0 ≤ r) (hf0 : f 0 = 0) (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) (i : ℕ) :\n    eLpNorm (stoppedValue f (leastGE f r i)) 1 μ ≤ 2 * μ Set.univ * ENNReal.ofReal (r + R) := by\n  refine eLpNorm_one_le_of_le' ((hf.stoppedValue_leastGE r).integrable _) ?_\n    (norm_stoppedValue_leastGE_le hr hf0 hbdd i)\n  rw [← setIntegral_univ]\n  refine le_trans ?_ ((hf.stoppedValue_leastGE r).setIntegral_le (zero_le _) MeasurableSet.univ)\n  simp_rw [stoppedValue, leastGE, hitting_of_le le_rfl, hf0, integral_zero', le_rfl]\n\n"}
{"name":"MeasureTheory.Submartingale.stoppedValue_leastGE_eLpNorm_le'","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nr : Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhr : LE.le 0 r\nhf0 : Eq (f 0) 0\nhbdd : Filter.Eventually (fun ω => ∀ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) ω) (f i ω))) ↑R) (MeasureTheory.ae μ)\ni : Nat\n⊢ LE.le (MeasureTheory.eLpNorm (MeasureTheory.stoppedValue f (MeasureTheory.leastGE f r i)) 1 μ) ↑(HMul.hMul (HMul.hMul 2 (μ Set.univ)) (ENNReal.ofReal (HAdd.hAdd r ↑R))).toNNReal","decl":"theorem Submartingale.stoppedValue_leastGE_eLpNorm_le' [IsFiniteMeasure μ]\n    (hf : Submartingale f ℱ μ) (hr : 0 ≤ r) (hf0 : f 0 = 0)\n    (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) (i : ℕ) :\n    eLpNorm (stoppedValue f (leastGE f r i)) 1 μ ≤\n      ENNReal.toNNReal (2 * μ Set.univ * ENNReal.ofReal (r + R)) := by\n  refine (hf.stoppedValue_leastGE_eLpNorm_le hr hf0 hbdd i).trans ?_\n  simp [ENNReal.coe_toNNReal (measure_ne_top μ _), ENNReal.coe_toNNReal]\n\n"}
{"name":"MeasureTheory.Submartingale.exists_tendsto_of_abs_bddAbove_aux","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhf0 : Eq (f 0) 0\nhbdd : Filter.Eventually (fun ω => ∀ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) ω) (f i ω))) ↑R) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun ω => BddAbove (Set.range fun n => f n ω) → Exists fun c => Filter.Tendsto (fun n => f n ω) Filter.atTop (nhds c)) (MeasureTheory.ae μ)","decl":"/-- This lemma is superseded by `Submartingale.bddAbove_iff_exists_tendsto`. -/\ntheorem Submartingale.exists_tendsto_of_abs_bddAbove_aux [IsFiniteMeasure μ]\n    (hf : Submartingale f ℱ μ) (hf0 : f 0 = 0) (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :\n    ∀ᵐ ω ∂μ, BddAbove (Set.range fun n => f n ω) → ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) := by\n  have ht :\n    ∀ᵐ ω ∂μ, ∀ i : ℕ, ∃ c, Tendsto (fun n => stoppedValue f (leastGE f i n) ω) atTop (𝓝 c) := by\n    rw [ae_all_iff]\n    exact fun i => Submartingale.exists_ae_tendsto_of_bdd (hf.stoppedValue_leastGE i)\n      (hf.stoppedValue_leastGE_eLpNorm_le' i.cast_nonneg hf0 hbdd)\n  filter_upwards [ht] with ω hω hωb\n  rw [BddAbove] at hωb\n  obtain ⟨i, hi⟩ := exists_nat_gt hωb.some\n  have hib : ∀ n, f n ω < i := by\n    intro n\n    exact lt_of_le_of_lt ((mem_upperBounds.1 hωb.some_mem) _ ⟨n, rfl⟩) hi\n  have heq : ∀ n, stoppedValue f (leastGE f i n) ω = f n ω := by\n    intro n\n    rw [leastGE]; unfold hitting; rw [stoppedValue]\n    rw [if_neg]\n    simp only [Set.mem_Icc, Set.mem_union, Set.mem_Ici]\n    push_neg\n    exact fun j _ => hib j\n  simp only [← heq, hω i]\n\n"}
{"name":"MeasureTheory.Submartingale.bddAbove_iff_exists_tendsto_aux","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhf0 : Eq (f 0) 0\nhbdd : Filter.Eventually (fun ω => ∀ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) ω) (f i ω))) ↑R) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun ω => Iff (BddAbove (Set.range fun n => f n ω)) (Exists fun c => Filter.Tendsto (fun n => f n ω) Filter.atTop (nhds c))) (MeasureTheory.ae μ)","decl":"theorem Submartingale.bddAbove_iff_exists_tendsto_aux [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)\n    (hf0 : f 0 = 0) (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :\n    ∀ᵐ ω ∂μ, BddAbove (Set.range fun n => f n ω) ↔ ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) := by\n  filter_upwards [hf.exists_tendsto_of_abs_bddAbove_aux hf0 hbdd] with ω hω using\n    ⟨hω, fun ⟨c, hc⟩ => hc.bddAbove_range⟩\n\n"}
{"name":"MeasureTheory.Submartingale.bddAbove_iff_exists_tendsto","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Submartingale f ℱ μ\nhbdd : Filter.Eventually (fun ω => ∀ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) ω) (f i ω))) ↑R) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun ω => Iff (BddAbove (Set.range fun n => f n ω)) (Exists fun c => Filter.Tendsto (fun n => f n ω) Filter.atTop (nhds c))) (MeasureTheory.ae μ)","decl":"/-- One sided martingale bound: If `f` is a submartingale which has uniformly bounded differences,\nthen for almost every `ω`, `f n ω` is bounded above (in `n`) if and only if it converges. -/\ntheorem Submartingale.bddAbove_iff_exists_tendsto [IsFiniteMeasure μ] (hf : Submartingale f ℱ μ)\n    (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :\n    ∀ᵐ ω ∂μ, BddAbove (Set.range fun n => f n ω) ↔ ∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c) := by\n  set g : ℕ → Ω → ℝ := fun n ω => f n ω - f 0 ω\n  have hg : Submartingale g ℱ μ :=\n    hf.sub_martingale (martingale_const_fun _ _ (hf.adapted 0) (hf.integrable 0))\n  have hg0 : g 0 = 0 := by\n    ext ω\n    simp only [g, sub_self, Pi.zero_apply]\n  have hgbdd : ∀ᵐ ω ∂μ, ∀ i : ℕ, |g (i + 1) ω - g i ω| ≤ ↑R := by\n    simpa only [g, sub_sub_sub_cancel_right]\n  filter_upwards [hg.bddAbove_iff_exists_tendsto_aux hg0 hgbdd] with ω hω\n  convert hω using 1\n  · refine ⟨fun h => ?_, fun h => ?_⟩ <;> obtain ⟨b, hb⟩ := h <;>\n    refine ⟨b + |f 0 ω|, fun y hy => ?_⟩ <;> obtain ⟨n, rfl⟩ := hy\n    · simp_rw [g, sub_eq_add_neg]\n      exact add_le_add (hb ⟨n, rfl⟩) (neg_le_abs _)\n    · exact sub_le_iff_le_add.1 (le_trans (sub_le_sub_left (le_abs_self _) _) (hb ⟨n, rfl⟩))\n  · refine ⟨fun h => ?_, fun h => ?_⟩ <;> obtain ⟨c, hc⟩ := h\n    · exact ⟨c - f 0 ω, hc.sub_const _⟩\n    · refine ⟨c + f 0 ω, ?_⟩\n      have := hc.add_const (f 0 ω)\n      simpa only [g, sub_add_cancel]\n\n"}
{"name":"MeasureTheory.Martingale.bddAbove_range_iff_bddBelow_range","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Martingale f ℱ μ\nhbdd : Filter.Eventually (fun ω => ∀ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) ω) (f i ω))) ↑R) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun ω => Iff (BddAbove (Set.range fun n => f n ω)) (BddBelow (Set.range fun n => f n ω))) (MeasureTheory.ae μ)","decl":"theorem Martingale.bddAbove_range_iff_bddBelow_range [IsFiniteMeasure μ] (hf : Martingale f ℱ μ)\n    (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :\n    ∀ᵐ ω ∂μ, BddAbove (Set.range fun n => f n ω) ↔ BddBelow (Set.range fun n => f n ω) := by\n  have hbdd' : ∀ᵐ ω ∂μ, ∀ i, |(-f) (i + 1) ω - (-f) i ω| ≤ R := by\n    filter_upwards [hbdd] with ω hω i\n    erw [← abs_neg, neg_sub, sub_neg_eq_add, neg_add_eq_sub]\n    exact hω i\n  have hup := hf.submartingale.bddAbove_iff_exists_tendsto hbdd\n  have hdown := hf.neg.submartingale.bddAbove_iff_exists_tendsto hbdd'\n  filter_upwards [hup, hdown] with ω hω₁ hω₂\n  have : (∃ c, Tendsto (fun n => f n ω) atTop (𝓝 c)) ↔\n      ∃ c, Tendsto (fun n => (-f) n ω) atTop (𝓝 c) := by\n    constructor <;> rintro ⟨c, hc⟩\n    · exact ⟨-c, hc.neg⟩\n    · refine ⟨-c, ?_⟩\n      convert hc.neg\n      simp only [neg_neg, Pi.neg_apply]\n  rw [hω₁, this, ← hω₂]\n  constructor <;> rintro ⟨c, hc⟩ <;> refine ⟨-c, fun ω hω => ?_⟩\n  · rw [mem_upperBounds] at hc\n    refine neg_le.2 (hc _ ?_)\n    simpa only [Pi.neg_apply, Set.mem_range, neg_inj]\n  · rw [mem_lowerBounds] at hc\n    simp_rw [Set.mem_range, Pi.neg_apply, neg_eq_iff_eq_neg] at hω\n    refine le_neg.1 (hc _ ?_)\n    simpa only [Set.mem_range]\n\n"}
{"name":"MeasureTheory.Martingale.ae_not_tendsto_atTop_atTop","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Martingale f ℱ μ\nhbdd : Filter.Eventually (fun ω => ∀ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) ω) (f i ω))) ↑R) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun ω => Not (Filter.Tendsto (fun n => f n ω) Filter.atTop Filter.atTop)) (MeasureTheory.ae μ)","decl":"theorem Martingale.ae_not_tendsto_atTop_atTop [IsFiniteMeasure μ] (hf : Martingale f ℱ μ)\n    (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :\n    ∀ᵐ ω ∂μ, ¬Tendsto (fun n => f n ω) atTop atTop := by\n  filter_upwards [hf.bddAbove_range_iff_bddBelow_range hbdd] with ω hω htop using\n    unbounded_of_tendsto_atTop htop (hω.2 <| bddBelow_range_of_tendsto_atTop_atTop htop)\n\n"}
{"name":"MeasureTheory.Martingale.ae_not_tendsto_atTop_atBot","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhf : MeasureTheory.Martingale f ℱ μ\nhbdd : Filter.Eventually (fun ω => ∀ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) ω) (f i ω))) ↑R) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun ω => Not (Filter.Tendsto (fun n => f n ω) Filter.atTop Filter.atBot)) (MeasureTheory.ae μ)","decl":"theorem Martingale.ae_not_tendsto_atTop_atBot [IsFiniteMeasure μ] (hf : Martingale f ℱ μ)\n    (hbdd : ∀ᵐ ω ∂μ, ∀ i, |f (i + 1) ω - f i ω| ≤ R) :\n    ∀ᵐ ω ∂μ, ¬Tendsto (fun n => f n ω) atTop atBot := by\n  filter_upwards [hf.bddAbove_range_iff_bddBelow_range hbdd] with ω hω htop using\n    unbounded_of_tendsto_atBot htop (hω.1 <| bddAbove_range_of_tendsto_atTop_atBot htop)\n\n"}
{"name":"MeasureTheory.BorelCantelli.process_zero","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\ns : Nat → Set Ω\n⊢ Eq (MeasureTheory.BorelCantelli.process s 0) 0","decl":"theorem process_zero : process s 0 = 0 := by rw [process, Finset.range_zero, Finset.sum_empty]\n\n"}
{"name":"MeasureTheory.BorelCantelli.adapted_process","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nℱ : MeasureTheory.Filtration Nat m0\ns : Nat → Set Ω\nhs : ∀ (n : Nat), MeasurableSet (s n)\n⊢ MeasureTheory.Adapted ℱ (MeasureTheory.BorelCantelli.process s)","decl":"theorem adapted_process (hs : ∀ n, MeasurableSet[ℱ n] (s n)) : Adapted ℱ (process s) := fun _ =>\n  Finset.stronglyMeasurable_sum' _ fun _ hk =>\n    stronglyMeasurable_one.indicator <| ℱ.mono (Finset.mem_range.1 hk) _ <| hs _\n\n"}
{"name":"MeasureTheory.BorelCantelli.martingalePart_process_ae_eq","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nℱ : MeasureTheory.Filtration Nat m0\nμ : MeasureTheory.Measure Ω\ns : Nat → Set Ω\nn : Nat\n⊢ Eq (MeasureTheory.martingalePart (MeasureTheory.BorelCantelli.process s) ℱ μ n) ((Finset.range n).sum fun k => HSub.hSub ((s (HAdd.hAdd k 1)).indicator 1) (MeasureTheory.condExp (↑ℱ k) μ ((s (HAdd.hAdd k 1)).indicator 1)))","decl":"theorem martingalePart_process_ae_eq (ℱ : Filtration ℕ m0) (μ : Measure Ω) (s : ℕ → Set Ω) (n : ℕ) :\n    martingalePart (process s) ℱ μ n =\n      ∑ k ∈ Finset.range n, ((s (k + 1)).indicator 1 - μ[(s (k + 1)).indicator 1|ℱ k]) := by\n  simp only [martingalePart_eq_sum, process_zero, zero_add]\n  refine Finset.sum_congr rfl fun k _ => ?_\n  simp only [process, Finset.sum_range_succ_sub_sum]\n\n"}
{"name":"MeasureTheory.BorelCantelli.predictablePart_process_ae_eq","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nℱ : MeasureTheory.Filtration Nat m0\nμ : MeasureTheory.Measure Ω\ns : Nat → Set Ω\nn : Nat\n⊢ Eq (MeasureTheory.predictablePart (MeasureTheory.BorelCantelli.process s) ℱ μ n) ((Finset.range n).sum fun k => MeasureTheory.condExp (↑ℱ k) μ ((s (HAdd.hAdd k 1)).indicator 1))","decl":"theorem predictablePart_process_ae_eq (ℱ : Filtration ℕ m0) (μ : Measure Ω) (s : ℕ → Set Ω)\n    (n : ℕ) : predictablePart (process s) ℱ μ n =\n    ∑ k ∈ Finset.range n, μ[(s (k + 1)).indicator (1 : Ω → ℝ)|ℱ k] := by\n  have := martingalePart_process_ae_eq ℱ μ s n\n  simp_rw [martingalePart, process, Finset.sum_sub_distrib] at this\n  exact sub_right_injective this\n\n"}
{"name":"MeasureTheory.BorelCantelli.process_difference_le","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\ns : Nat → Set Ω\nω : Ω\nn : Nat\n⊢ LE.le (abs (HSub.hSub (MeasureTheory.BorelCantelli.process s (HAdd.hAdd n 1) ω) (MeasureTheory.BorelCantelli.process s n ω))) ↑1","decl":"theorem process_difference_le (s : ℕ → Set Ω) (ω : Ω) (n : ℕ) :\n    |process s (n + 1) ω - process s n ω| ≤ (1 : ℝ≥0) := by\n  norm_cast\n  rw [process, process, Finset.sum_apply, Finset.sum_apply,\n    Finset.sum_range_succ_sub_sum, ← Real.norm_eq_abs, norm_indicator_eq_indicator_norm]\n  refine Set.indicator_le' (fun _ _ => ?_) (fun _ _ => zero_le_one) _\n  rw [Pi.one_apply, norm_one]\n\n"}
{"name":"MeasureTheory.BorelCantelli.integrable_process","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nℱ : MeasureTheory.Filtration Nat m0\ns : Nat → Set Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhs : ∀ (n : Nat), MeasurableSet (s n)\nn : Nat\n⊢ MeasureTheory.Integrable (MeasureTheory.BorelCantelli.process s n) μ","decl":"theorem integrable_process (μ : Measure Ω) [IsFiniteMeasure μ] (hs : ∀ n, MeasurableSet[ℱ n] (s n))\n    (n : ℕ) : Integrable (process s n) μ :=\n  integrable_finset_sum' _ fun _ _ =>\n    IntegrableOn.integrable_indicator (integrable_const 1) <| ℱ.le _ _ <| hs _\n\n"}
{"name":"MeasureTheory.tendsto_sum_indicator_atTop_iff","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nR : NNReal\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhfmono : Filter.Eventually (fun ω => ∀ (n : Nat), LE.le (f n ω) (f (HAdd.hAdd n 1) ω)) (MeasureTheory.ae μ)\nhf : MeasureTheory.Adapted ℱ f\nhint : ∀ (n : Nat), MeasureTheory.Integrable (f n) μ\nhbdd : Filter.Eventually (fun ω => ∀ (n : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd n 1) ω) (f n ω))) ↑R) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun ω => Iff (Filter.Tendsto (fun n => f n ω) Filter.atTop Filter.atTop) (Filter.Tendsto (fun n => MeasureTheory.predictablePart f ℱ μ n ω) Filter.atTop Filter.atTop)) (MeasureTheory.ae μ)","decl":"/-- An a.e. monotone adapted process `f` with uniformly bounded differences converges to `+∞` if\nand only if its predictable part also converges to `+∞`. -/\ntheorem tendsto_sum_indicator_atTop_iff [IsFiniteMeasure μ]\n    (hfmono : ∀ᵐ ω ∂μ, ∀ n, f n ω ≤ f (n + 1) ω) (hf : Adapted ℱ f) (hint : ∀ n, Integrable (f n) μ)\n    (hbdd : ∀ᵐ ω ∂μ, ∀ n, |f (n + 1) ω - f n ω| ≤ R) :\n    ∀ᵐ ω ∂μ, Tendsto (fun n => f n ω) atTop atTop ↔\n      Tendsto (fun n => predictablePart f ℱ μ n ω) atTop atTop := by\n  have h₁ := (martingale_martingalePart hf hint).ae_not_tendsto_atTop_atTop\n    (martingalePart_bdd_difference ℱ hbdd)\n  have h₂ := (martingale_martingalePart hf hint).ae_not_tendsto_atTop_atBot\n    (martingalePart_bdd_difference ℱ hbdd)\n  have h₃ : ∀ᵐ ω ∂μ, ∀ n, 0 ≤ (μ[f (n + 1) - f n|ℱ n]) ω := by\n    refine ae_all_iff.2 fun n => condExp_nonneg ?_\n    filter_upwards [ae_all_iff.1 hfmono n] with ω hω using sub_nonneg.2 hω\n  filter_upwards [h₁, h₂, h₃, hfmono] with ω hω₁ hω₂ hω₃ hω₄\n  constructor <;> intro ht\n  · refine tendsto_atTop_atTop_of_monotone' ?_ ?_\n    · intro n m hnm\n      simp only [predictablePart, Finset.sum_apply]\n      exact Finset.sum_mono_set_of_nonneg hω₃ (Finset.range_mono hnm)\n    rintro ⟨b, hbdd⟩\n    rw [← tendsto_neg_atBot_iff] at ht\n    simp only [martingalePart, sub_eq_add_neg] at hω₁\n    exact hω₁ (tendsto_atTop_add_right_of_le _ (-b) (tendsto_neg_atBot_iff.1 ht) fun n =>\n      neg_le_neg (hbdd ⟨n, rfl⟩))\n  · refine tendsto_atTop_atTop_of_monotone' (monotone_nat_of_le_succ hω₄) ?_\n    rintro ⟨b, hbdd⟩\n    exact hω₂ ((tendsto_atBot_add_left_of_ge _ b fun n =>\n      hbdd ⟨n, rfl⟩) <| tendsto_neg_atBot_iff.2 ht)\n\n"}
{"name":"MeasureTheory.tendsto_sum_indicator_atTop_iff'","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration Nat m0\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Nat → Set Ω\nhs : ∀ (n : Nat), MeasurableSet (s n)\n⊢ Filter.Eventually (fun ω => Iff (Filter.Tendsto (fun n => (Finset.range n).sum fun k => (s (HAdd.hAdd k 1)).indicator 1 ω) Filter.atTop Filter.atTop) (Filter.Tendsto (fun n => (Finset.range n).sum fun k => MeasureTheory.condExp (↑ℱ k) μ ((s (HAdd.hAdd k 1)).indicator 1) ω) Filter.atTop Filter.atTop)) (MeasureTheory.ae μ)","decl":"theorem tendsto_sum_indicator_atTop_iff' [IsFiniteMeasure μ] {s : ℕ → Set Ω}\n    (hs : ∀ n, MeasurableSet[ℱ n] (s n)) : ∀ᵐ ω ∂μ,\n    Tendsto (fun n => ∑ k ∈ Finset.range n,\n      (s (k + 1)).indicator (1 : Ω → ℝ) ω) atTop atTop ↔\n    Tendsto (fun n => ∑ k ∈ Finset.range n,\n      (μ[(s (k + 1)).indicator (1 : Ω → ℝ)|ℱ k]) ω) atTop atTop := by\n  have := tendsto_sum_indicator_atTop_iff (Eventually.of_forall fun ω n => ?_) (adapted_process hs)\n    (integrable_process μ hs) (Eventually.of_forall <| process_difference_le s)\n  swap\n  · rw [process, process, ← sub_nonneg, Finset.sum_apply, Finset.sum_apply,\n      Finset.sum_range_succ_sub_sum]\n    exact Set.indicator_nonneg (fun _ _ => zero_le_one) _\n  simp_rw [process, predictablePart_process_ae_eq] at this\n  simpa using this\n\n"}
{"name":"MeasureTheory.ae_mem_limsup_atTop_iff","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nℱ : MeasureTheory.Filtration Nat m0\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Nat → Set Ω\nhs : ∀ (n : Nat), MeasurableSet (s n)\n⊢ Filter.Eventually (fun ω => Iff (Membership.mem (Filter.limsup s Filter.atTop) ω) (Filter.Tendsto (fun n => (Finset.range n).sum fun k => MeasureTheory.condExp (↑ℱ k) μ ((s (HAdd.hAdd k 1)).indicator 1) ω) Filter.atTop Filter.atTop)) (MeasureTheory.ae μ)","decl":"/-- **Lévy's generalization of the Borel-Cantelli lemma**: given a sequence of sets `s` and a\nfiltration `ℱ` such that for all `n`, `s n` is `ℱ n`-measurable, `limsup s atTop` is almost\neverywhere equal to the set for which `∑ k, ℙ(s (k + 1) | ℱ k) = ∞`. -/\ntheorem ae_mem_limsup_atTop_iff (μ : Measure Ω) [IsFiniteMeasure μ] {s : ℕ → Set Ω}\n    (hs : ∀ n, MeasurableSet[ℱ n] (s n)) : ∀ᵐ ω ∂μ, ω ∈ limsup s atTop ↔\n    Tendsto (fun n => ∑ k ∈ Finset.range n,\n      (μ[(s (k + 1)).indicator (1 : Ω → ℝ)|ℱ k]) ω) atTop atTop := by\n  rw [← limsup_nat_add s 1,\n    Set.limsup_eq_tendsto_sum_indicator_atTop (zero_lt_one (α := ℝ)) (fun n ↦ s (n + 1))]\n  exact tendsto_sum_indicator_atTop_iff' hs\n\n"}
