{"name":"MeasureTheory.Adapted.isStoppingTime_leastGE","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nr : Real\nn : Nat\nhf : MeasureTheory.Adapted â„± f\nâŠ¢ MeasureTheory.IsStoppingTime â„± (MeasureTheory.leastGE f r n)","decl":"theorem Adapted.isStoppingTime_leastGE (r : â„) (n : â„•) (hf : Adapted â„± f) :\n    IsStoppingTime â„± (leastGE f r n) :=\n  hitting_isStoppingTime hf measurableSet_Ici\n\n"}
{"name":"MeasureTheory.leastGE_le","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nf : Nat â†’ Î© â†’ Real\ni : Nat\nr : Real\nÏ‰ : Î©\nâŠ¢ LE.le (MeasureTheory.leastGE f r i Ï‰) i","decl":"theorem leastGE_le {i : â„•} {r : â„} (Ï‰ : Î©) : leastGE f r i Ï‰ â‰¤ i :=\n  hitting_le Ï‰\n\n-- The following four lemmas shows `leastGE` behaves like a stopped process. Ideally we should\n-- define `leastGE` as a stopping time and take its stopped process. However, we can't do that\n-- with our current definition since a stopping time takes only finite indices. An upcoming\n-- refactor should hopefully make it possible to have stopping times taking infinity as a value\n"}
{"name":"MeasureTheory.leastGE_mono","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nf : Nat â†’ Î© â†’ Real\nn m : Nat\nhnm : LE.le n m\nr : Real\nÏ‰ : Î©\nâŠ¢ LE.le (MeasureTheory.leastGE f r n Ï‰) (MeasureTheory.leastGE f r m Ï‰)","decl":"theorem leastGE_mono {n m : â„•} (hnm : n â‰¤ m) (r : â„) (Ï‰ : Î©) : leastGE f r n Ï‰ â‰¤ leastGE f r m Ï‰ :=\n  hitting_mono hnm\n\n"}
{"name":"MeasureTheory.leastGE_eq_min","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nf : Nat â†’ Î© â†’ Real\nÏ€ : Î© â†’ Nat\nr : Real\nÏ‰ : Î©\nn : Nat\nhÏ€n : âˆ€ (Ï‰ : Î©), LE.le (Ï€ Ï‰) n\nâŠ¢ Eq (MeasureTheory.leastGE f r (Ï€ Ï‰) Ï‰) (Min.min (Ï€ Ï‰) (MeasureTheory.leastGE f r n Ï‰))","decl":"theorem leastGE_eq_min (Ï€ : Î© â†’ â„•) (r : â„) (Ï‰ : Î©) {n : â„•} (hÏ€n : âˆ€ Ï‰, Ï€ Ï‰ â‰¤ n) :\n    leastGE f r (Ï€ Ï‰) Ï‰ = min (Ï€ Ï‰) (leastGE f r n Ï‰) := by\n  classical\n  refine le_antisymm (le_min (leastGE_le _) (leastGE_mono (hÏ€n Ï‰) r Ï‰)) ?_\n  by_cases hle : Ï€ Ï‰ â‰¤ leastGE f r n Ï‰\n  Â· rw [min_eq_left hle, leastGE]\n    by_cases h : âˆƒ j âˆˆ Set.Icc 0 (Ï€ Ï‰), f j Ï‰ âˆˆ Set.Ici r\n    Â· refine hle.trans (Eq.le ?_)\n      rw [leastGE, â† hitting_eq_hitting_of_exists (hÏ€n Ï‰) h]\n    Â· simp only [hitting, if_neg h, le_rfl]\n  Â· rw [min_eq_right (not_le.1 hle).le, leastGE, leastGE, â†\n      hitting_eq_hitting_of_exists (hÏ€n Ï‰) _]\n    rw [not_le, leastGE, hitting_lt_iff _ (hÏ€n Ï‰)] at hle\n    exact\n      let âŸ¨j, hjâ‚, hjâ‚‚âŸ© := hle\n      âŸ¨j, âŸ¨hjâ‚.1, hjâ‚.2.leâŸ©, hjâ‚‚âŸ©\n\n"}
{"name":"MeasureTheory.stoppedValue_stoppedValue_leastGE","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nf : Nat â†’ Î© â†’ Real\nÏ€ : Î© â†’ Nat\nr : Real\nn : Nat\nhÏ€n : âˆ€ (Ï‰ : Î©), LE.le (Ï€ Ï‰) n\nâŠ¢ Eq (MeasureTheory.stoppedValue (fun i => MeasureTheory.stoppedValue f (MeasureTheory.leastGE f r i)) Ï€) (MeasureTheory.stoppedValue (MeasureTheory.stoppedProcess f (MeasureTheory.leastGE f r n)) Ï€)","decl":"theorem stoppedValue_stoppedValue_leastGE (f : â„• â†’ Î© â†’ â„) (Ï€ : Î© â†’ â„•) (r : â„) {n : â„•}\n    (hÏ€n : âˆ€ Ï‰, Ï€ Ï‰ â‰¤ n) : stoppedValue (fun i => stoppedValue f (leastGE f r i)) Ï€ =\n      stoppedValue (stoppedProcess f (leastGE f r n)) Ï€ := by\n  ext1 Ï‰\n  simp (config := { unfoldPartialApp := true }) only [stoppedProcess, stoppedValue]\n  rw [leastGE_eq_min _ _ _ hÏ€n]\n\n"}
{"name":"MeasureTheory.Submartingale.stoppedValue_leastGE","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Submartingale f â„± Î¼\nr : Real\nâŠ¢ MeasureTheory.Submartingale (fun i => MeasureTheory.stoppedValue f (MeasureTheory.leastGE f r i)) â„± Î¼","decl":"theorem Submartingale.stoppedValue_leastGE [IsFiniteMeasure Î¼] (hf : Submartingale f â„± Î¼) (r : â„) :\n    Submartingale (fun i => stoppedValue f (leastGE f r i)) â„± Î¼ := by\n  rw [submartingale_iff_expected_stoppedValue_mono]\n  Â· intro Ïƒ Ï€ hÏƒ hÏ€ hÏƒ_le_Ï€ hÏ€_bdd\n    obtain âŸ¨n, hÏ€_le_nâŸ© := hÏ€_bdd\n    simp_rw [stoppedValue_stoppedValue_leastGE f Ïƒ r fun i => (hÏƒ_le_Ï€ i).trans (hÏ€_le_n i)]\n    simp_rw [stoppedValue_stoppedValue_leastGE f Ï€ r hÏ€_le_n]\n    refine hf.expected_stoppedValue_mono ?_ ?_ ?_ fun Ï‰ => (min_le_left _ _).trans (hÏ€_le_n Ï‰)\n    Â· exact hÏƒ.min (hf.adapted.isStoppingTime_leastGE _ _)\n    Â· exact hÏ€.min (hf.adapted.isStoppingTime_leastGE _ _)\n    Â· exact fun Ï‰ => min_le_min (hÏƒ_le_Ï€ Ï‰) le_rfl\n  Â· exact fun i => stronglyMeasurable_stoppedValue_of_le hf.adapted.progMeasurable_of_discrete\n      (hf.adapted.isStoppingTime_leastGE _ _) leastGE_le\n  Â· exact fun i => integrable_stoppedValue _ (hf.adapted.isStoppingTime_leastGE _ _) hf.integrable\n      leastGE_le\n\n"}
{"name":"MeasureTheory.norm_stoppedValue_leastGE_le","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nf : Nat â†’ Î© â†’ Real\nr : Real\nR : NNReal\nhr : LE.le 0 r\nhf0 : Eq (f 0) 0\nhbdd : Filter.Eventually (fun Ï‰ => âˆ€ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) Ï‰) (f i Ï‰))) â†‘R) (MeasureTheory.ae Î¼)\ni : Nat\nâŠ¢ Filter.Eventually (fun Ï‰ => LE.le (MeasureTheory.stoppedValue f (MeasureTheory.leastGE f r i) Ï‰) (HAdd.hAdd r â†‘R)) (MeasureTheory.ae Î¼)","decl":"theorem norm_stoppedValue_leastGE_le (hr : 0 â‰¤ r) (hf0 : f 0 = 0)\n    (hbdd : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i, |f (i + 1) Ï‰ - f i Ï‰| â‰¤ R) (i : â„•) :\n    âˆ€áµ Ï‰ âˆ‚Î¼, stoppedValue f (leastGE f r i) Ï‰ â‰¤ r + R := by\n  filter_upwards [hbdd] with Ï‰ hbddÏ‰\n  change f (leastGE f r i Ï‰) Ï‰ â‰¤ r + R\n  by_cases heq : leastGE f r i Ï‰ = 0\n  Â· rw [heq, hf0, Pi.zero_apply]\n    exact add_nonneg hr R.coe_nonneg\n  Â· obtain âŸ¨k, hkâŸ© := Nat.exists_eq_succ_of_ne_zero heq\n    rw [hk, add_comm, â† sub_le_iff_le_add]\n    have := not_mem_of_lt_hitting (hk.symm â–¸ k.lt_succ_self : k < leastGE f r i Ï‰) (zero_le _)\n    simp only [Set.mem_union, Set.mem_Iic, Set.mem_Ici, not_or, not_le] at this\n    exact (sub_lt_sub_left this _).le.trans ((le_abs_self _).trans (hbddÏ‰ _))\n\n"}
{"name":"MeasureTheory.Submartingale.stoppedValue_leastGE_eLpNorm_le","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nr : Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Submartingale f â„± Î¼\nhr : LE.le 0 r\nhf0 : Eq (f 0) 0\nhbdd : Filter.Eventually (fun Ï‰ => âˆ€ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) Ï‰) (f i Ï‰))) â†‘R) (MeasureTheory.ae Î¼)\ni : Nat\nâŠ¢ LE.le (MeasureTheory.eLpNorm (MeasureTheory.stoppedValue f (MeasureTheory.leastGE f r i)) 1 Î¼) (HMul.hMul (HMul.hMul 2 (Î¼ Set.univ)) (ENNReal.ofReal (HAdd.hAdd r â†‘R)))","decl":"theorem Submartingale.stoppedValue_leastGE_eLpNorm_le [IsFiniteMeasure Î¼] (hf : Submartingale f â„± Î¼)\n    (hr : 0 â‰¤ r) (hf0 : f 0 = 0) (hbdd : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i, |f (i + 1) Ï‰ - f i Ï‰| â‰¤ R) (i : â„•) :\n    eLpNorm (stoppedValue f (leastGE f r i)) 1 Î¼ â‰¤ 2 * Î¼ Set.univ * ENNReal.ofReal (r + R) := by\n  refine eLpNorm_one_le_of_le' ((hf.stoppedValue_leastGE r).integrable _) ?_\n    (norm_stoppedValue_leastGE_le hr hf0 hbdd i)\n  rw [â† setIntegral_univ]\n  refine le_trans ?_ ((hf.stoppedValue_leastGE r).setIntegral_le (zero_le _) MeasurableSet.univ)\n  simp_rw [stoppedValue, leastGE, hitting_of_le le_rfl, hf0, integral_zero', le_rfl]\n\n"}
{"name":"MeasureTheory.Submartingale.stoppedValue_leastGE_eLpNorm_le'","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nr : Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Submartingale f â„± Î¼\nhr : LE.le 0 r\nhf0 : Eq (f 0) 0\nhbdd : Filter.Eventually (fun Ï‰ => âˆ€ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) Ï‰) (f i Ï‰))) â†‘R) (MeasureTheory.ae Î¼)\ni : Nat\nâŠ¢ LE.le (MeasureTheory.eLpNorm (MeasureTheory.stoppedValue f (MeasureTheory.leastGE f r i)) 1 Î¼) â†‘(HMul.hMul (HMul.hMul 2 (Î¼ Set.univ)) (ENNReal.ofReal (HAdd.hAdd r â†‘R))).toNNReal","decl":"theorem Submartingale.stoppedValue_leastGE_eLpNorm_le' [IsFiniteMeasure Î¼]\n    (hf : Submartingale f â„± Î¼) (hr : 0 â‰¤ r) (hf0 : f 0 = 0)\n    (hbdd : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i, |f (i + 1) Ï‰ - f i Ï‰| â‰¤ R) (i : â„•) :\n    eLpNorm (stoppedValue f (leastGE f r i)) 1 Î¼ â‰¤\n      ENNReal.toNNReal (2 * Î¼ Set.univ * ENNReal.ofReal (r + R)) := by\n  refine (hf.stoppedValue_leastGE_eLpNorm_le hr hf0 hbdd i).trans ?_\n  simp [ENNReal.coe_toNNReal (measure_ne_top Î¼ _), ENNReal.coe_toNNReal]\n\n"}
{"name":"MeasureTheory.Submartingale.exists_tendsto_of_abs_bddAbove_aux","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Submartingale f â„± Î¼\nhf0 : Eq (f 0) 0\nhbdd : Filter.Eventually (fun Ï‰ => âˆ€ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) Ï‰) (f i Ï‰))) â†‘R) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun Ï‰ => BddAbove (Set.range fun n => f n Ï‰) â†’ Exists fun c => Filter.Tendsto (fun n => f n Ï‰) Filter.atTop (nhds c)) (MeasureTheory.ae Î¼)","decl":"/-- This lemma is superseded by `Submartingale.bddAbove_iff_exists_tendsto`. -/\ntheorem Submartingale.exists_tendsto_of_abs_bddAbove_aux [IsFiniteMeasure Î¼]\n    (hf : Submartingale f â„± Î¼) (hf0 : f 0 = 0) (hbdd : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i, |f (i + 1) Ï‰ - f i Ï‰| â‰¤ R) :\n    âˆ€áµ Ï‰ âˆ‚Î¼, BddAbove (Set.range fun n => f n Ï‰) â†’ âˆƒ c, Tendsto (fun n => f n Ï‰) atTop (ğ“ c) := by\n  have ht :\n    âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i : â„•, âˆƒ c, Tendsto (fun n => stoppedValue f (leastGE f i n) Ï‰) atTop (ğ“ c) := by\n    rw [ae_all_iff]\n    exact fun i => Submartingale.exists_ae_tendsto_of_bdd (hf.stoppedValue_leastGE i)\n      (hf.stoppedValue_leastGE_eLpNorm_le' i.cast_nonneg hf0 hbdd)\n  filter_upwards [ht] with Ï‰ hÏ‰ hÏ‰b\n  rw [BddAbove] at hÏ‰b\n  obtain âŸ¨i, hiâŸ© := exists_nat_gt hÏ‰b.some\n  have hib : âˆ€ n, f n Ï‰ < i := by\n    intro n\n    exact lt_of_le_of_lt ((mem_upperBounds.1 hÏ‰b.some_mem) _ âŸ¨n, rflâŸ©) hi\n  have heq : âˆ€ n, stoppedValue f (leastGE f i n) Ï‰ = f n Ï‰ := by\n    intro n\n    rw [leastGE]; unfold hitting; rw [stoppedValue]\n    rw [if_neg]\n    simp only [Set.mem_Icc, Set.mem_union, Set.mem_Ici]\n    push_neg\n    exact fun j _ => hib j\n  simp only [â† heq, hÏ‰ i]\n\n"}
{"name":"MeasureTheory.Submartingale.bddAbove_iff_exists_tendsto_aux","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Submartingale f â„± Î¼\nhf0 : Eq (f 0) 0\nhbdd : Filter.Eventually (fun Ï‰ => âˆ€ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) Ï‰) (f i Ï‰))) â†‘R) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun Ï‰ => Iff (BddAbove (Set.range fun n => f n Ï‰)) (Exists fun c => Filter.Tendsto (fun n => f n Ï‰) Filter.atTop (nhds c))) (MeasureTheory.ae Î¼)","decl":"theorem Submartingale.bddAbove_iff_exists_tendsto_aux [IsFiniteMeasure Î¼] (hf : Submartingale f â„± Î¼)\n    (hf0 : f 0 = 0) (hbdd : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i, |f (i + 1) Ï‰ - f i Ï‰| â‰¤ R) :\n    âˆ€áµ Ï‰ âˆ‚Î¼, BddAbove (Set.range fun n => f n Ï‰) â†” âˆƒ c, Tendsto (fun n => f n Ï‰) atTop (ğ“ c) := by\n  filter_upwards [hf.exists_tendsto_of_abs_bddAbove_aux hf0 hbdd] with Ï‰ hÏ‰ using\n    âŸ¨hÏ‰, fun âŸ¨c, hcâŸ© => hc.bddAbove_rangeâŸ©\n\n"}
{"name":"MeasureTheory.Submartingale.bddAbove_iff_exists_tendsto","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Submartingale f â„± Î¼\nhbdd : Filter.Eventually (fun Ï‰ => âˆ€ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) Ï‰) (f i Ï‰))) â†‘R) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun Ï‰ => Iff (BddAbove (Set.range fun n => f n Ï‰)) (Exists fun c => Filter.Tendsto (fun n => f n Ï‰) Filter.atTop (nhds c))) (MeasureTheory.ae Î¼)","decl":"/-- One sided martingale bound: If `f` is a submartingale which has uniformly bounded differences,\nthen for almost every `Ï‰`, `f n Ï‰` is bounded above (in `n`) if and only if it converges. -/\ntheorem Submartingale.bddAbove_iff_exists_tendsto [IsFiniteMeasure Î¼] (hf : Submartingale f â„± Î¼)\n    (hbdd : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i, |f (i + 1) Ï‰ - f i Ï‰| â‰¤ R) :\n    âˆ€áµ Ï‰ âˆ‚Î¼, BddAbove (Set.range fun n => f n Ï‰) â†” âˆƒ c, Tendsto (fun n => f n Ï‰) atTop (ğ“ c) := by\n  set g : â„• â†’ Î© â†’ â„ := fun n Ï‰ => f n Ï‰ - f 0 Ï‰\n  have hg : Submartingale g â„± Î¼ :=\n    hf.sub_martingale (martingale_const_fun _ _ (hf.adapted 0) (hf.integrable 0))\n  have hg0 : g 0 = 0 := by\n    ext Ï‰\n    simp only [g, sub_self, Pi.zero_apply]\n  have hgbdd : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i : â„•, |g (i + 1) Ï‰ - g i Ï‰| â‰¤ â†‘R := by\n    simpa only [g, sub_sub_sub_cancel_right]\n  filter_upwards [hg.bddAbove_iff_exists_tendsto_aux hg0 hgbdd] with Ï‰ hÏ‰\n  convert hÏ‰ using 1\n  Â· refine âŸ¨fun h => ?_, fun h => ?_âŸ© <;> obtain âŸ¨b, hbâŸ© := h <;>\n    refine âŸ¨b + |f 0 Ï‰|, fun y hy => ?_âŸ© <;> obtain âŸ¨n, rflâŸ© := hy\n    Â· simp_rw [g, sub_eq_add_neg]\n      exact add_le_add (hb âŸ¨n, rflâŸ©) (neg_le_abs _)\n    Â· exact sub_le_iff_le_add.1 (le_trans (sub_le_sub_left (le_abs_self _) _) (hb âŸ¨n, rflâŸ©))\n  Â· refine âŸ¨fun h => ?_, fun h => ?_âŸ© <;> obtain âŸ¨c, hcâŸ© := h\n    Â· exact âŸ¨c - f 0 Ï‰, hc.sub_const _âŸ©\n    Â· refine âŸ¨c + f 0 Ï‰, ?_âŸ©\n      have := hc.add_const (f 0 Ï‰)\n      simpa only [g, sub_add_cancel]\n\n"}
{"name":"MeasureTheory.Martingale.bddAbove_range_iff_bddBelow_range","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Martingale f â„± Î¼\nhbdd : Filter.Eventually (fun Ï‰ => âˆ€ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) Ï‰) (f i Ï‰))) â†‘R) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun Ï‰ => Iff (BddAbove (Set.range fun n => f n Ï‰)) (BddBelow (Set.range fun n => f n Ï‰))) (MeasureTheory.ae Î¼)","decl":"theorem Martingale.bddAbove_range_iff_bddBelow_range [IsFiniteMeasure Î¼] (hf : Martingale f â„± Î¼)\n    (hbdd : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i, |f (i + 1) Ï‰ - f i Ï‰| â‰¤ R) :\n    âˆ€áµ Ï‰ âˆ‚Î¼, BddAbove (Set.range fun n => f n Ï‰) â†” BddBelow (Set.range fun n => f n Ï‰) := by\n  have hbdd' : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i, |(-f) (i + 1) Ï‰ - (-f) i Ï‰| â‰¤ R := by\n    filter_upwards [hbdd] with Ï‰ hÏ‰ i\n    erw [â† abs_neg, neg_sub, sub_neg_eq_add, neg_add_eq_sub]\n    exact hÏ‰ i\n  have hup := hf.submartingale.bddAbove_iff_exists_tendsto hbdd\n  have hdown := hf.neg.submartingale.bddAbove_iff_exists_tendsto hbdd'\n  filter_upwards [hup, hdown] with Ï‰ hÏ‰â‚ hÏ‰â‚‚\n  have : (âˆƒ c, Tendsto (fun n => f n Ï‰) atTop (ğ“ c)) â†”\n      âˆƒ c, Tendsto (fun n => (-f) n Ï‰) atTop (ğ“ c) := by\n    constructor <;> rintro âŸ¨c, hcâŸ©\n    Â· exact âŸ¨-c, hc.negâŸ©\n    Â· refine âŸ¨-c, ?_âŸ©\n      convert hc.neg\n      simp only [neg_neg, Pi.neg_apply]\n  rw [hÏ‰â‚, this, â† hÏ‰â‚‚]\n  constructor <;> rintro âŸ¨c, hcâŸ© <;> refine âŸ¨-c, fun Ï‰ hÏ‰ => ?_âŸ©\n  Â· rw [mem_upperBounds] at hc\n    refine neg_le.2 (hc _ ?_)\n    simpa only [Pi.neg_apply, Set.mem_range, neg_inj]\n  Â· rw [mem_lowerBounds] at hc\n    simp_rw [Set.mem_range, Pi.neg_apply, neg_eq_iff_eq_neg] at hÏ‰\n    refine le_neg.1 (hc _ ?_)\n    simpa only [Set.mem_range]\n\n"}
{"name":"MeasureTheory.Martingale.ae_not_tendsto_atTop_atTop","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Martingale f â„± Î¼\nhbdd : Filter.Eventually (fun Ï‰ => âˆ€ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) Ï‰) (f i Ï‰))) â†‘R) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun Ï‰ => Not (Filter.Tendsto (fun n => f n Ï‰) Filter.atTop Filter.atTop)) (MeasureTheory.ae Î¼)","decl":"theorem Martingale.ae_not_tendsto_atTop_atTop [IsFiniteMeasure Î¼] (hf : Martingale f â„± Î¼)\n    (hbdd : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i, |f (i + 1) Ï‰ - f i Ï‰| â‰¤ R) :\n    âˆ€áµ Ï‰ âˆ‚Î¼, Â¬Tendsto (fun n => f n Ï‰) atTop atTop := by\n  filter_upwards [hf.bddAbove_range_iff_bddBelow_range hbdd] with Ï‰ hÏ‰ htop using\n    unbounded_of_tendsto_atTop htop (hÏ‰.2 <| bddBelow_range_of_tendsto_atTop_atTop htop)\n\n"}
{"name":"MeasureTheory.Martingale.ae_not_tendsto_atTop_atBot","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhf : MeasureTheory.Martingale f â„± Î¼\nhbdd : Filter.Eventually (fun Ï‰ => âˆ€ (i : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd i 1) Ï‰) (f i Ï‰))) â†‘R) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun Ï‰ => Not (Filter.Tendsto (fun n => f n Ï‰) Filter.atTop Filter.atBot)) (MeasureTheory.ae Î¼)","decl":"theorem Martingale.ae_not_tendsto_atTop_atBot [IsFiniteMeasure Î¼] (hf : Martingale f â„± Î¼)\n    (hbdd : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ i, |f (i + 1) Ï‰ - f i Ï‰| â‰¤ R) :\n    âˆ€áµ Ï‰ âˆ‚Î¼, Â¬Tendsto (fun n => f n Ï‰) atTop atBot := by\n  filter_upwards [hf.bddAbove_range_iff_bddBelow_range hbdd] with Ï‰ hÏ‰ htop using\n    unbounded_of_tendsto_atBot htop (hÏ‰.1 <| bddAbove_range_of_tendsto_atTop_atBot htop)\n\n"}
{"name":"MeasureTheory.BorelCantelli.process_zero","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\ns : Nat â†’ Set Î©\nâŠ¢ Eq (MeasureTheory.BorelCantelli.process s 0) 0","decl":"theorem process_zero : process s 0 = 0 := by rw [process, Finset.range_zero, Finset.sum_empty]\n\n"}
{"name":"MeasureTheory.BorelCantelli.adapted_process","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nâ„± : MeasureTheory.Filtration Nat m0\ns : Nat â†’ Set Î©\nhs : âˆ€ (n : Nat), MeasurableSet (s n)\nâŠ¢ MeasureTheory.Adapted â„± (MeasureTheory.BorelCantelli.process s)","decl":"theorem adapted_process (hs : âˆ€ n, MeasurableSet[â„± n] (s n)) : Adapted â„± (process s) := fun _ =>\n  Finset.stronglyMeasurable_sum' _ fun _ hk =>\n    stronglyMeasurable_one.indicator <| â„±.mono (Finset.mem_range.1 hk) _ <| hs _\n\n"}
{"name":"MeasureTheory.BorelCantelli.martingalePart_process_ae_eq","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nâ„± : MeasureTheory.Filtration Nat m0\nÎ¼ : MeasureTheory.Measure Î©\ns : Nat â†’ Set Î©\nn : Nat\nâŠ¢ Eq (MeasureTheory.martingalePart (MeasureTheory.BorelCantelli.process s) â„± Î¼ n) ((Finset.range n).sum fun k => HSub.hSub ((s (HAdd.hAdd k 1)).indicator 1) (MeasureTheory.condExp (â†‘â„± k) Î¼ ((s (HAdd.hAdd k 1)).indicator 1)))","decl":"theorem martingalePart_process_ae_eq (â„± : Filtration â„• m0) (Î¼ : Measure Î©) (s : â„• â†’ Set Î©) (n : â„•) :\n    martingalePart (process s) â„± Î¼ n =\n      âˆ‘ k âˆˆ Finset.range n, ((s (k + 1)).indicator 1 - Î¼[(s (k + 1)).indicator 1|â„± k]) := by\n  simp only [martingalePart_eq_sum, process_zero, zero_add]\n  refine Finset.sum_congr rfl fun k _ => ?_\n  simp only [process, Finset.sum_range_succ_sub_sum]\n\n"}
{"name":"MeasureTheory.BorelCantelli.predictablePart_process_ae_eq","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nâ„± : MeasureTheory.Filtration Nat m0\nÎ¼ : MeasureTheory.Measure Î©\ns : Nat â†’ Set Î©\nn : Nat\nâŠ¢ Eq (MeasureTheory.predictablePart (MeasureTheory.BorelCantelli.process s) â„± Î¼ n) ((Finset.range n).sum fun k => MeasureTheory.condExp (â†‘â„± k) Î¼ ((s (HAdd.hAdd k 1)).indicator 1))","decl":"theorem predictablePart_process_ae_eq (â„± : Filtration â„• m0) (Î¼ : Measure Î©) (s : â„• â†’ Set Î©)\n    (n : â„•) : predictablePart (process s) â„± Î¼ n =\n    âˆ‘ k âˆˆ Finset.range n, Î¼[(s (k + 1)).indicator (1 : Î© â†’ â„)|â„± k] := by\n  have := martingalePart_process_ae_eq â„± Î¼ s n\n  simp_rw [martingalePart, process, Finset.sum_sub_distrib] at this\n  exact sub_right_injective this\n\n"}
{"name":"MeasureTheory.BorelCantelli.process_difference_le","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\ns : Nat â†’ Set Î©\nÏ‰ : Î©\nn : Nat\nâŠ¢ LE.le (abs (HSub.hSub (MeasureTheory.BorelCantelli.process s (HAdd.hAdd n 1) Ï‰) (MeasureTheory.BorelCantelli.process s n Ï‰))) â†‘1","decl":"theorem process_difference_le (s : â„• â†’ Set Î©) (Ï‰ : Î©) (n : â„•) :\n    |process s (n + 1) Ï‰ - process s n Ï‰| â‰¤ (1 : â„â‰¥0) := by\n  norm_cast\n  rw [process, process, Finset.sum_apply, Finset.sum_apply,\n    Finset.sum_range_succ_sub_sum, â† Real.norm_eq_abs, norm_indicator_eq_indicator_norm]\n  refine Set.indicator_le' (fun _ _ => ?_) (fun _ _ => zero_le_one) _\n  rw [Pi.one_apply, norm_one]\n\n"}
{"name":"MeasureTheory.BorelCantelli.integrable_process","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nâ„± : MeasureTheory.Filtration Nat m0\ns : Nat â†’ Set Î©\nÎ¼ : MeasureTheory.Measure Î©\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhs : âˆ€ (n : Nat), MeasurableSet (s n)\nn : Nat\nâŠ¢ MeasureTheory.Integrable (MeasureTheory.BorelCantelli.process s n) Î¼","decl":"theorem integrable_process (Î¼ : Measure Î©) [IsFiniteMeasure Î¼] (hs : âˆ€ n, MeasurableSet[â„± n] (s n))\n    (n : â„•) : Integrable (process s n) Î¼ :=\n  integrable_finset_sum' _ fun _ _ =>\n    IntegrableOn.integrable_indicator (integrable_const 1) <| â„±.le _ _ <| hs _\n\n"}
{"name":"MeasureTheory.tendsto_sum_indicator_atTop_iff","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nR : NNReal\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhfmono : Filter.Eventually (fun Ï‰ => âˆ€ (n : Nat), LE.le (f n Ï‰) (f (HAdd.hAdd n 1) Ï‰)) (MeasureTheory.ae Î¼)\nhf : MeasureTheory.Adapted â„± f\nhint : âˆ€ (n : Nat), MeasureTheory.Integrable (f n) Î¼\nhbdd : Filter.Eventually (fun Ï‰ => âˆ€ (n : Nat), LE.le (abs (HSub.hSub (f (HAdd.hAdd n 1) Ï‰) (f n Ï‰))) â†‘R) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun Ï‰ => Iff (Filter.Tendsto (fun n => f n Ï‰) Filter.atTop Filter.atTop) (Filter.Tendsto (fun n => MeasureTheory.predictablePart f â„± Î¼ n Ï‰) Filter.atTop Filter.atTop)) (MeasureTheory.ae Î¼)","decl":"/-- An a.e. monotone adapted process `f` with uniformly bounded differences converges to `+âˆ` if\nand only if its predictable part also converges to `+âˆ`. -/\ntheorem tendsto_sum_indicator_atTop_iff [IsFiniteMeasure Î¼]\n    (hfmono : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ n, f n Ï‰ â‰¤ f (n + 1) Ï‰) (hf : Adapted â„± f) (hint : âˆ€ n, Integrable (f n) Î¼)\n    (hbdd : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ n, |f (n + 1) Ï‰ - f n Ï‰| â‰¤ R) :\n    âˆ€áµ Ï‰ âˆ‚Î¼, Tendsto (fun n => f n Ï‰) atTop atTop â†”\n      Tendsto (fun n => predictablePart f â„± Î¼ n Ï‰) atTop atTop := by\n  have hâ‚ := (martingale_martingalePart hf hint).ae_not_tendsto_atTop_atTop\n    (martingalePart_bdd_difference â„± hbdd)\n  have hâ‚‚ := (martingale_martingalePart hf hint).ae_not_tendsto_atTop_atBot\n    (martingalePart_bdd_difference â„± hbdd)\n  have hâ‚ƒ : âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ n, 0 â‰¤ (Î¼[f (n + 1) - f n|â„± n]) Ï‰ := by\n    refine ae_all_iff.2 fun n => condExp_nonneg ?_\n    filter_upwards [ae_all_iff.1 hfmono n] with Ï‰ hÏ‰ using sub_nonneg.2 hÏ‰\n  filter_upwards [hâ‚, hâ‚‚, hâ‚ƒ, hfmono] with Ï‰ hÏ‰â‚ hÏ‰â‚‚ hÏ‰â‚ƒ hÏ‰â‚„\n  constructor <;> intro ht\n  Â· refine tendsto_atTop_atTop_of_monotone' ?_ ?_\n    Â· intro n m hnm\n      simp only [predictablePart, Finset.sum_apply]\n      exact Finset.sum_mono_set_of_nonneg hÏ‰â‚ƒ (Finset.range_mono hnm)\n    rintro âŸ¨b, hbddâŸ©\n    rw [â† tendsto_neg_atBot_iff] at ht\n    simp only [martingalePart, sub_eq_add_neg] at hÏ‰â‚\n    exact hÏ‰â‚ (tendsto_atTop_add_right_of_le _ (-b) (tendsto_neg_atBot_iff.1 ht) fun n =>\n      neg_le_neg (hbdd âŸ¨n, rflâŸ©))\n  Â· refine tendsto_atTop_atTop_of_monotone' (monotone_nat_of_le_succ hÏ‰â‚„) ?_\n    rintro âŸ¨b, hbddâŸ©\n    exact hÏ‰â‚‚ ((tendsto_atBot_add_left_of_ge _ b fun n =>\n      hbdd âŸ¨n, rflâŸ©) <| tendsto_neg_atBot_iff.2 ht)\n\n"}
{"name":"MeasureTheory.tendsto_sum_indicator_atTop_iff'","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Nat m0\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ns : Nat â†’ Set Î©\nhs : âˆ€ (n : Nat), MeasurableSet (s n)\nâŠ¢ Filter.Eventually (fun Ï‰ => Iff (Filter.Tendsto (fun n => (Finset.range n).sum fun k => (s (HAdd.hAdd k 1)).indicator 1 Ï‰) Filter.atTop Filter.atTop) (Filter.Tendsto (fun n => (Finset.range n).sum fun k => MeasureTheory.condExp (â†‘â„± k) Î¼ ((s (HAdd.hAdd k 1)).indicator 1) Ï‰) Filter.atTop Filter.atTop)) (MeasureTheory.ae Î¼)","decl":"theorem tendsto_sum_indicator_atTop_iff' [IsFiniteMeasure Î¼] {s : â„• â†’ Set Î©}\n    (hs : âˆ€ n, MeasurableSet[â„± n] (s n)) : âˆ€áµ Ï‰ âˆ‚Î¼,\n    Tendsto (fun n => âˆ‘ k âˆˆ Finset.range n,\n      (s (k + 1)).indicator (1 : Î© â†’ â„) Ï‰) atTop atTop â†”\n    Tendsto (fun n => âˆ‘ k âˆˆ Finset.range n,\n      (Î¼[(s (k + 1)).indicator (1 : Î© â†’ â„)|â„± k]) Ï‰) atTop atTop := by\n  have := tendsto_sum_indicator_atTop_iff (Eventually.of_forall fun Ï‰ n => ?_) (adapted_process hs)\n    (integrable_process Î¼ hs) (Eventually.of_forall <| process_difference_le s)\n  swap\n  Â· rw [process, process, â† sub_nonneg, Finset.sum_apply, Finset.sum_apply,\n      Finset.sum_range_succ_sub_sum]\n    exact Set.indicator_nonneg (fun _ _ => zero_le_one) _\n  simp_rw [process, predictablePart_process_ae_eq] at this\n  simpa using this\n\n"}
{"name":"MeasureTheory.ae_mem_limsup_atTop_iff","module":"Mathlib.Probability.Martingale.BorelCantelli","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nâ„± : MeasureTheory.Filtration Nat m0\nÎ¼ : MeasureTheory.Measure Î©\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ns : Nat â†’ Set Î©\nhs : âˆ€ (n : Nat), MeasurableSet (s n)\nâŠ¢ Filter.Eventually (fun Ï‰ => Iff (Membership.mem (Filter.limsup s Filter.atTop) Ï‰) (Filter.Tendsto (fun n => (Finset.range n).sum fun k => MeasureTheory.condExp (â†‘â„± k) Î¼ ((s (HAdd.hAdd k 1)).indicator 1) Ï‰) Filter.atTop Filter.atTop)) (MeasureTheory.ae Î¼)","decl":"/-- **LÃ©vy's generalization of the Borel-Cantelli lemma**: given a sequence of sets `s` and a\nfiltration `â„±` such that for all `n`, `s n` is `â„± n`-measurable, `limsup s atTop` is almost\neverywhere equal to the set for which `âˆ‘ k, â„™(s (k + 1) | â„± k) = âˆ`. -/\ntheorem ae_mem_limsup_atTop_iff (Î¼ : Measure Î©) [IsFiniteMeasure Î¼] {s : â„• â†’ Set Î©}\n    (hs : âˆ€ n, MeasurableSet[â„± n] (s n)) : âˆ€áµ Ï‰ âˆ‚Î¼, Ï‰ âˆˆ limsup s atTop â†”\n    Tendsto (fun n => âˆ‘ k âˆˆ Finset.range n,\n      (Î¼[(s (k + 1)).indicator (1 : Î© â†’ â„)|â„± k]) Ï‰) atTop atTop := by\n  rw [â† limsup_nat_add s 1,\n    Set.limsup_eq_tendsto_sum_indicator_atTop (zero_lt_one (Î± := â„)) (fun n â†¦ s (n + 1))]\n  exact tendsto_sum_indicator_atTop_iff' hs\n\n"}
