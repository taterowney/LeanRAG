{"name":"IsometryEquiv.midpoint_fixed","module":"Mathlib.Analysis.Normed.Affine.MazurUlam","initialProofState":"E : Type u_1\nPE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : MetricSpace PE\ninst✝ : NormedAddTorsor E PE\nx y : PE\ne : IsometryEquiv PE PE\na✝¹ : Eq (e x) x\na✝ : Eq (e y) y\n⊢ Eq (e (midpoint Real x y)) (midpoint Real x y)","decl":"/-- If an isometric self-homeomorphism of a normed vector space over `ℝ` fixes `x` and `y`,\nthen it fixes the midpoint of `[x, y]`. This is a lemma for a more general Mazur-Ulam theorem,\nsee below. -/\ntheorem midpoint_fixed {x y : PE} :\n    ∀ e : PE ≃ᵢ PE, e x = x → e y = y → e (midpoint ℝ x y) = midpoint ℝ x y := by\n  set z := midpoint ℝ x y\n  -- Consider the set of `e : E ≃ᵢ E` such that `e x = x` and `e y = y`\n  set s := { e : PE ≃ᵢ PE | e x = x ∧ e y = y }\n  haveI : Nonempty s := ⟨⟨IsometryEquiv.refl PE, rfl, rfl⟩⟩\n  -- On the one hand, `e` cannot send the midpoint `z` of `[x, y]` too far\n  have h_bdd : BddAbove (range fun e : s => dist ((e : PE ≃ᵢ PE) z) z) := by\n    refine ⟨dist x z + dist x z, forall_mem_range.2 <| Subtype.forall.2 ?_⟩\n    rintro e ⟨hx, _⟩\n    calc\n      dist (e z) z ≤ dist (e z) x + dist x z := dist_triangle (e z) x z\n      _ = dist (e x) (e z) + dist x z := by rw [hx, dist_comm]\n      _ = dist x z + dist x z := by rw [e.dist_eq x z]\n  -- On the other hand, consider the map `f : (E ≃ᵢ E) → (E ≃ᵢ E)`\n  -- sending each `e` to `R ∘ e⁻¹ ∘ R ∘ e`, where `R` is the point reflection in the\n  -- midpoint `z` of `[x, y]`.\n  set R : PE ≃ᵢ PE := (pointReflection ℝ z).toIsometryEquiv\n  set f : PE ≃ᵢ PE → PE ≃ᵢ PE := fun e => ((e.trans R).trans e.symm).trans R\n  -- Note that `f` doubles the value of `dist (e z) z`\n  have hf_dist : ∀ e, dist (f e z) z = 2 * dist (e z) z := by\n    intro e\n    dsimp only [trans_apply, coe_toIsometryEquiv, f, R]\n    rw [dist_pointReflection_fixed, ← e.dist_eq, e.apply_symm_apply,\n      dist_pointReflection_self_real, dist_comm]\n  -- Also note that `f` maps `s` to itself\n  have hf_maps_to : MapsTo f s s := by\n    rintro e ⟨hx, hy⟩\n    constructor <;> simp [f, R, z, hx, hy, e.symm_apply_eq.2 hx.symm, e.symm_apply_eq.2 hy.symm]\n  -- Therefore, `dist (e z) z = 0` for all `e ∈ s`.\n  set c := ⨆ e : s, dist ((e : PE ≃ᵢ PE) z) z\n  have : c ≤ c / 2 := by\n    apply ciSup_le\n    rintro ⟨e, he⟩\n    simp only [Subtype.coe_mk, le_div_iff₀' (zero_lt_two' ℝ), ← hf_dist]\n    exact le_ciSup h_bdd ⟨f e, hf_maps_to he⟩\n  replace : c ≤ 0 := by linarith\n  refine fun e hx hy => dist_le_zero.1 (le_trans ?_ this)\n  exact le_ciSup h_bdd ⟨e, hx, hy⟩\n\n"}
{"name":"IsometryEquiv.map_midpoint","module":"Mathlib.Analysis.Normed.Affine.MazurUlam","initialProofState":"E : Type u_1\nPE : Type u_2\nF : Type u_3\nPF : Type u_4\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : MetricSpace PE\ninst✝⁴ : NormedAddTorsor E PE\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\ninst✝¹ : MetricSpace PF\ninst✝ : NormedAddTorsor F PF\nf : IsometryEquiv PE PF\nx y : PE\n⊢ Eq (f (midpoint Real x y)) (midpoint Real (f x) (f y))","decl":"/-- A bijective isometry sends midpoints to midpoints. -/\ntheorem map_midpoint (f : PE ≃ᵢ PF) (x y : PE) : f (midpoint ℝ x y) = midpoint ℝ (f x) (f y) := by\n  set e : PE ≃ᵢ PE :=\n    ((f.trans <| (pointReflection ℝ <| midpoint ℝ (f x) (f y)).toIsometryEquiv).trans f.symm).trans\n      (pointReflection ℝ <| midpoint ℝ x y).toIsometryEquiv\n  have hx : e x = x := by simp [e]\n  have hy : e y = y := by simp [e]\n  have hm := e.midpoint_fixed hx hy\n  simp only [e, trans_apply] at hm\n  rwa [← eq_symm_apply, toIsometryEquiv_symm, pointReflection_symm, coe_toIsometryEquiv,\n    coe_toIsometryEquiv, pointReflection_self, symm_apply_eq, @pointReflection_fixed_iff] at hm\n\n"}
{"name":"IsometryEquiv.coe_toRealLinearIsometryEquivOfMapZero","module":"Mathlib.Analysis.Normed.Affine.MazurUlam","initialProofState":"E : Type u_1\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : IsometryEquiv E F\nh0 : Eq (f 0) 0\n⊢ Eq ⇑(f.toRealLinearIsometryEquivOfMapZero h0) ⇑f","decl":"@[simp]\ntheorem coe_toRealLinearIsometryEquivOfMapZero (f : E ≃ᵢ F) (h0 : f 0 = 0) :\n    ⇑(f.toRealLinearIsometryEquivOfMapZero h0) = f :=\n  rfl\n\n"}
{"name":"IsometryEquiv.coe_toRealLinearIsometryEquivOfMapZero_symm","module":"Mathlib.Analysis.Normed.Affine.MazurUlam","initialProofState":"E : Type u_1\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : IsometryEquiv E F\nh0 : Eq (f 0) 0\n⊢ Eq ⇑(f.toRealLinearIsometryEquivOfMapZero h0).symm ⇑f.symm","decl":"@[simp]\ntheorem coe_toRealLinearIsometryEquivOfMapZero_symm (f : E ≃ᵢ F) (h0 : f 0 = 0) :\n    ⇑(f.toRealLinearIsometryEquivOfMapZero h0).symm = f.symm :=\n  rfl\n\n"}
{"name":"IsometryEquiv.toRealLinearIsometryEquiv_apply","module":"Mathlib.Analysis.Normed.Affine.MazurUlam","initialProofState":"E : Type u_1\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : IsometryEquiv E F\nx : E\n⊢ Eq (f.toRealLinearIsometryEquiv x) (HSub.hSub (f x) (f 0))","decl":"@[simp]\ntheorem toRealLinearIsometryEquiv_apply (f : E ≃ᵢ F) (x : E) :\n    (f.toRealLinearIsometryEquiv : E → F) x = f x - f 0 :=\n  (sub_eq_add_neg (f x) (f 0)).symm\n\n"}
{"name":"IsometryEquiv.toRealLinearIsometryEquiv_symm_apply","module":"Mathlib.Analysis.Normed.Affine.MazurUlam","initialProofState":"E : Type u_1\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : IsometryEquiv E F\ny : F\n⊢ Eq (f.toRealLinearIsometryEquiv.symm y) (f.symm (HAdd.hAdd y (f 0)))","decl":"@[simp]\ntheorem toRealLinearIsometryEquiv_symm_apply (f : E ≃ᵢ F) (y : F) :\n    (f.toRealLinearIsometryEquiv.symm : F → E) y = f.symm (y + f 0) :=\n  rfl\n\n"}
{"name":"IsometryEquiv.coeFn_toRealAffineIsometryEquiv","module":"Mathlib.Analysis.Normed.Affine.MazurUlam","initialProofState":"E : Type u_1\nPE : Type u_2\nF : Type u_3\nPF : Type u_4\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : MetricSpace PE\ninst✝⁴ : NormedAddTorsor E PE\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\ninst✝¹ : MetricSpace PF\ninst✝ : NormedAddTorsor F PF\nf : IsometryEquiv PE PF\n⊢ Eq ⇑f.toRealAffineIsometryEquiv ⇑f","decl":"@[simp]\ntheorem coeFn_toRealAffineIsometryEquiv (f : PE ≃ᵢ PF) : ⇑f.toRealAffineIsometryEquiv = f :=\n  rfl\n\n"}
{"name":"IsometryEquiv.coe_toRealAffineIsometryEquiv","module":"Mathlib.Analysis.Normed.Affine.MazurUlam","initialProofState":"E : Type u_1\nPE : Type u_2\nF : Type u_3\nPF : Type u_4\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : MetricSpace PE\ninst✝⁴ : NormedAddTorsor E PE\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real F\ninst✝¹ : MetricSpace PF\ninst✝ : NormedAddTorsor F PF\nf : IsometryEquiv PE PF\n⊢ Eq f.toRealAffineIsometryEquiv.toIsometryEquiv f","decl":"@[simp]\ntheorem coe_toRealAffineIsometryEquiv (f : PE ≃ᵢ PF) :\n    f.toRealAffineIsometryEquiv.toIsometryEquiv = f := by\n  ext\n  rfl\n\n"}
