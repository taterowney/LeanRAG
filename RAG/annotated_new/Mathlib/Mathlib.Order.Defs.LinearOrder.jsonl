{"name":"LinearOrder.compare_eq_compareOfLessAndEq","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_2\nself : LinearOrder α\na b : α\n⊢ Eq (Ord.compare a b) (compareOfLessAndEq a b)","decl":"/-- A linear order is reflexive, transitive, antisymmetric and total relation `≤`.\nWe assume that every linear ordered type has decidable `(≤)`, `(<)`, and `(=)`. -/\nclass LinearOrder (α : Type*) extends PartialOrder α, Min α, Max α, Ord α where\n  /-- A linear order is total. -/\n  le_total (a b : α) : a ≤ b ∨ b ≤ a\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (· ≤ · : α → α → Prop)\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq α := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (· < · : α → α → Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n  min := fun a b => if a ≤ b then a else b\n  max := fun a b => if a ≤ b then b else a\n  /-- The minimum function is equivalent to the one you get from `minOfLe`. -/\n  min_def : ∀ a b, min a b = if a ≤ b then a else b := by intros; rfl\n  /-- The minimum function is equivalent to the one you get from `maxOfLe`. -/\n  max_def : ∀ a b, max a b = if a ≤ b then b else a := by intros; rfl\n  compare a b := compareOfLessAndEq a b\n  /-- Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. -/\n  compare_eq_compareOfLessAndEq : ∀ a b, compare a b = compareOfLessAndEq a b := by\n    compareOfLessAndEq_rfl\n\n"}
{"name":"LinearOrder.min_def","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_2\nself : LinearOrder α\na b : α\n⊢ Eq (Min.min a b) (ite (LE.le a b) a b)","decl":"/-- A linear order is reflexive, transitive, antisymmetric and total relation `≤`.\nWe assume that every linear ordered type has decidable `(≤)`, `(<)`, and `(=)`. -/\nclass LinearOrder (α : Type*) extends PartialOrder α, Min α, Max α, Ord α where\n  /-- A linear order is total. -/\n  le_total (a b : α) : a ≤ b ∨ b ≤ a\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (· ≤ · : α → α → Prop)\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq α := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (· < · : α → α → Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n  min := fun a b => if a ≤ b then a else b\n  max := fun a b => if a ≤ b then b else a\n  /-- The minimum function is equivalent to the one you get from `minOfLe`. -/\n  min_def : ∀ a b, min a b = if a ≤ b then a else b := by intros; rfl\n  /-- The minimum function is equivalent to the one you get from `maxOfLe`. -/\n  max_def : ∀ a b, max a b = if a ≤ b then b else a := by intros; rfl\n  compare a b := compareOfLessAndEq a b\n  /-- Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. -/\n  compare_eq_compareOfLessAndEq : ∀ a b, compare a b = compareOfLessAndEq a b := by\n    compareOfLessAndEq_rfl\n\n"}
{"name":"LinearOrder.le_total","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_2\nself : LinearOrder α\na b : α\n⊢ Or (LE.le a b) (LE.le b a)","decl":"/-- A linear order is reflexive, transitive, antisymmetric and total relation `≤`.\nWe assume that every linear ordered type has decidable `(≤)`, `(<)`, and `(=)`. -/\nclass LinearOrder (α : Type*) extends PartialOrder α, Min α, Max α, Ord α where\n  /-- A linear order is total. -/\n  le_total (a b : α) : a ≤ b ∨ b ≤ a\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (· ≤ · : α → α → Prop)\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq α := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (· < · : α → α → Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n  min := fun a b => if a ≤ b then a else b\n  max := fun a b => if a ≤ b then b else a\n  /-- The minimum function is equivalent to the one you get from `minOfLe`. -/\n  min_def : ∀ a b, min a b = if a ≤ b then a else b := by intros; rfl\n  /-- The minimum function is equivalent to the one you get from `maxOfLe`. -/\n  max_def : ∀ a b, max a b = if a ≤ b then b else a := by intros; rfl\n  compare a b := compareOfLessAndEq a b\n  /-- Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. -/\n  compare_eq_compareOfLessAndEq : ∀ a b, compare a b = compareOfLessAndEq a b := by\n    compareOfLessAndEq_rfl\n\n"}
{"name":"LinearOrder.max_def","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_2\nself : LinearOrder α\na b : α\n⊢ Eq (Max.max a b) (ite (LE.le a b) b a)","decl":"/-- A linear order is reflexive, transitive, antisymmetric and total relation `≤`.\nWe assume that every linear ordered type has decidable `(≤)`, `(<)`, and `(=)`. -/\nclass LinearOrder (α : Type*) extends PartialOrder α, Min α, Max α, Ord α where\n  /-- A linear order is total. -/\n  le_total (a b : α) : a ≤ b ∨ b ≤ a\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLE : DecidableRel (· ≤ · : α → α → Prop)\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableEq : DecidableEq α := @decidableEqOfDecidableLE _ _ decidableLE\n  /-- In a linearly ordered type, we assume the order relations are all decidable. -/\n  decidableLT : DecidableRel (· < · : α → α → Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n  min := fun a b => if a ≤ b then a else b\n  max := fun a b => if a ≤ b then b else a\n  /-- The minimum function is equivalent to the one you get from `minOfLe`. -/\n  min_def : ∀ a b, min a b = if a ≤ b then a else b := by intros; rfl\n  /-- The minimum function is equivalent to the one you get from `maxOfLe`. -/\n  max_def : ∀ a b, max a b = if a ≤ b then b else a := by intros; rfl\n  compare a b := compareOfLessAndEq a b\n  /-- Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. -/\n  compare_eq_compareOfLessAndEq : ∀ a b, compare a b = compareOfLessAndEq a b := by\n    compareOfLessAndEq_rfl\n\n"}
{"name":"le_total","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Or (LE.le a b) (LE.le b a)","decl":"lemma le_total : ∀ a b : α, a ≤ b ∨ b ≤ a := LinearOrder.le_total\n\n"}
{"name":"le_of_not_ge","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\na✝ : Not (GE.ge a b)\n⊢ LE.le a b","decl":"lemma le_of_not_ge : ¬a ≥ b → a ≤ b := (le_total b a).resolve_left\n"}
{"name":"le_of_not_le","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\na✝ : Not (LE.le a b)\n⊢ LE.le b a","decl":"lemma le_of_not_le : ¬a ≤ b → b ≤ a := (le_total a b).resolve_left\n"}
{"name":"lt_of_not_ge","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : Not (GE.ge a b)\n⊢ LT.lt a b","decl":"lemma lt_of_not_ge (h : ¬a ≥ b) : a < b := lt_of_le_not_le (le_of_not_ge h) h\n\n"}
{"name":"lt_trichotomy","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Or (LT.lt a b) (Or (Eq a b) (LT.lt b a))","decl":"lemma lt_trichotomy (a b : α) : a < b ∨ a = b ∨ b < a :=\n  Or.elim (le_total a b)\n    (fun h : a ≤ b =>\n      Or.elim (Decidable.lt_or_eq_of_le h) (fun h : a < b => Or.inl h) fun h : a = b =>\n        Or.inr (Or.inl h))\n    fun h : b ≤ a =>\n    Or.elim (Decidable.lt_or_eq_of_le h) (fun h : b < a => Or.inr (Or.inr h)) fun h : b = a =>\n      Or.inr (Or.inl h.symm)\n\n"}
{"name":"le_of_not_lt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : Not (LT.lt b a)\n⊢ LE.le a b","decl":"lemma le_of_not_lt (h : ¬b < a) : a ≤ b :=\n  match lt_trichotomy a b with\n  | Or.inl hlt => le_of_lt hlt\n  | Or.inr (Or.inl HEq) => HEq ▸ le_refl a\n  | Or.inr (Or.inr hgt) => absurd hgt h\n\n"}
{"name":"le_of_not_gt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\na✝ : Not (GT.gt a b)\n⊢ LE.le a b","decl":"lemma le_of_not_gt : ¬a > b → a ≤ b := le_of_not_lt\n\n"}
{"name":"lt_or_le","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Or (LT.lt a b) (LE.le b a)","decl":"lemma lt_or_le (a b : α) : a < b ∨ b ≤ a :=\n  if hba : b ≤ a then Or.inr hba else Or.inl <| lt_of_not_ge hba\n\n"}
{"name":"le_or_lt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Or (LE.le a b) (LT.lt b a)","decl":"lemma le_or_lt (a b : α) : a ≤ b ∨ b < a := (lt_or_le b a).symm\n"}
{"name":"lt_or_ge","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Or (LT.lt a b) (GE.ge a b)","decl":"lemma lt_or_ge : ∀ a b : α, a < b ∨ a ≥ b := lt_or_le\n"}
{"name":"le_or_gt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Or (LE.le a b) (GT.gt a b)","decl":"lemma le_or_gt : ∀ a b : α, a ≤ b ∨ a > b := le_or_lt\n\n"}
{"name":"lt_or_gt_of_ne","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : Ne a b\n⊢ Or (LT.lt a b) (GT.gt a b)","decl":"lemma lt_or_gt_of_ne (h : a ≠ b) : a < b ∨ a > b := by simpa [h] using lt_trichotomy a b\n\n"}
{"name":"ne_iff_lt_or_gt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Ne a b) (Or (LT.lt a b) (GT.gt a b))","decl":"lemma ne_iff_lt_or_gt : a ≠ b ↔ a < b ∨ a > b := ⟨lt_or_gt_of_ne, (Or.elim · ne_of_lt ne_of_gt)⟩\n\n"}
{"name":"lt_iff_not_ge","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx y : α\n⊢ Iff (LT.lt x y) (Not (GE.ge x y))","decl":"lemma lt_iff_not_ge (x y : α) : x < y ↔ ¬x ≥ y := ⟨not_le_of_gt, lt_of_not_ge⟩\n\n"}
{"name":"not_lt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Not (LT.lt a b)) (LE.le b a)","decl":"@[simp] lemma not_lt : ¬a < b ↔ b ≤ a := ⟨le_of_not_gt, not_lt_of_ge⟩\n"}
{"name":"not_le","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Not (LE.le a b)) (LT.lt b a)","decl":"@[simp] lemma not_le : ¬a ≤ b ↔ b < a := (lt_iff_not_ge _ _).symm\n\n"}
{"name":"eq_or_lt_of_not_lt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : Not (LT.lt a b)\n⊢ Or (Eq a b) (LT.lt b a)","decl":"lemma eq_or_lt_of_not_lt (h : ¬a < b) : a = b ∨ b < a :=\n  if h₁ : a = b then Or.inl h₁ else Or.inr (lt_of_not_ge fun hge => h (lt_of_le_of_ne hge h₁))\n\n"}
{"name":"le_imp_le_of_lt_imp_lt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : LinearOrder β\na b : α\nc d : β\nH : LT.lt d c → LT.lt b a\nh : LE.le a b\n⊢ LE.le c d","decl":"theorem le_imp_le_of_lt_imp_lt {α β} [Preorder α] [LinearOrder β] {a b : α} {c d : β}\n    (H : d < c → b < a) (h : a ≤ b) : c ≤ d :=\n  le_of_not_lt fun h' => not_le_of_gt (H h') h\n\n"}
{"name":"min_def","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Min.min a b) (ite (LE.le a b) a b)","decl":"lemma min_def (a b : α) : min a b = if a ≤ b then a else b := by rw [LinearOrder.min_def a]\n"}
{"name":"max_def","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Max.max a b) (ite (LE.le a b) b a)","decl":"lemma max_def (a b : α) : max a b = if a ≤ b then b else a := by rw [LinearOrder.max_def a]\n\n-- Porting note: no `min_tac` tactic in the following series of lemmas\n\n"}
{"name":"min_le_left","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ LE.le (Min.min a b) a","decl":"lemma min_le_left (a b : α) : min a b ≤ a := by\n  if h : a ≤ b\n  then simp [min_def, if_pos h, le_refl]\n  else simpa [min_def, if_neg h] using le_of_not_le h\n\n"}
{"name":"min_le_right","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ LE.le (Min.min a b) b","decl":"lemma min_le_right (a b : α) : min a b ≤ b := by\n  if h : a ≤ b\n  then simpa [min_def, if_pos h] using h\n  else simp [min_def, if_neg h, le_refl]\n\n"}
{"name":"le_min","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le c a\nh₂ : LE.le c b\n⊢ LE.le c (Min.min a b)","decl":"lemma le_min (h₁ : c ≤ a) (h₂ : c ≤ b) : c ≤ min a b := by\n  if h : a ≤ b\n  then simpa [min_def, if_pos h] using h₁\n  else simpa [min_def, if_neg h] using h₂\n\n"}
{"name":"le_max_left","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ LE.le a (Max.max a b)","decl":"lemma le_max_left (a b : α) : a ≤ max a b := by\n  if h : a ≤ b\n  then simpa [max_def, if_pos h] using h\n  else simp [max_def, if_neg h, le_refl]\n\n"}
{"name":"le_max_right","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ LE.le b (Max.max a b)","decl":"lemma le_max_right (a b : α) : b ≤ max a b := by\n  if h : a ≤ b\n  then simp [max_def, if_pos h, le_refl]\n  else simpa [max_def, if_neg h] using le_of_not_le h\n\n"}
{"name":"max_le","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le a c\nh₂ : LE.le b c\n⊢ LE.le (Max.max a b) c","decl":"lemma max_le (h₁ : a ≤ c) (h₂ : b ≤ c) : max a b ≤ c := by\n  if h : a ≤ b\n  then simpa [max_def, if_pos h] using h₂\n  else simpa [max_def, if_neg h] using h₁\n\n"}
{"name":"eq_min","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le c a\nh₂ : LE.le c b\nh₃ : ∀ {d : α}, LE.le d a → LE.le d b → LE.le d c\n⊢ Eq c (Min.min a b)","decl":"lemma eq_min (h₁ : c ≤ a) (h₂ : c ≤ b) (h₃ : ∀ {d}, d ≤ a → d ≤ b → d ≤ c) : c = min a b :=\n  le_antisymm (le_min h₁ h₂) (h₃ (min_le_left a b) (min_le_right a b))\n\n"}
{"name":"min_comm","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Min.min a b) (Min.min b a)","decl":"lemma min_comm (a b : α) : min a b = min b a :=\n  eq_min (min_le_right a b) (min_le_left a b) fun h₁ h₂ => le_min h₂ h₁\n\n"}
{"name":"min_assoc","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (Min.min (Min.min a b) c) (Min.min a (Min.min b c))","decl":"lemma min_assoc (a b c : α) : min (min a b) c = min a (min b c) := by\n  apply eq_min\n  · apply le_trans (min_le_left ..) (min_le_left ..)\n  · apply le_min\n    · apply le_trans (min_le_left ..) (min_le_right ..)\n    · apply min_le_right\n  · intro d h₁ h₂; apply le_min\n    · apply le_min h₁; apply le_trans h₂; apply min_le_left\n    · apply le_trans h₂; apply min_le_right\n\n"}
{"name":"min_left_comm","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (Min.min a (Min.min b c)) (Min.min b (Min.min a c))","decl":"lemma min_left_comm (a b c : α) : min a (min b c) = min b (min a c) := by\n  rw [← min_assoc, min_comm a, min_assoc]\n\n"}
{"name":"min_self","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (Min.min a a) a","decl":"@[simp] lemma min_self (a : α) : min a a = a := by simp [min_def]\n\n"}
{"name":"min_eq_left","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Min.min a b) a","decl":"lemma min_eq_left (h : a ≤ b) : min a b = a := by\n  apply Eq.symm; apply eq_min (le_refl _) h; intros; assumption\n\n"}
{"name":"min_eq_right","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le b a\n⊢ Eq (Min.min a b) b","decl":"lemma min_eq_right (h : b ≤ a) : min a b = b := min_comm b a ▸ min_eq_left h\n\n"}
{"name":"eq_max","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le a c\nh₂ : LE.le b c\nh₃ : ∀ {d : α}, LE.le a d → LE.le b d → LE.le c d\n⊢ Eq c (Max.max a b)","decl":"lemma eq_max (h₁ : a ≤ c) (h₂ : b ≤ c) (h₃ : ∀ {d}, a ≤ d → b ≤ d → c ≤ d) :\n    c = max a b :=\n  le_antisymm (h₃ (le_max_left a b) (le_max_right a b)) (max_le h₁ h₂)\n\n"}
{"name":"max_comm","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Max.max a b) (Max.max b a)","decl":"lemma max_comm (a b : α) : max a b = max b a :=\n  eq_max (le_max_right a b) (le_max_left a b) fun h₁ h₂ => max_le h₂ h₁\n\n"}
{"name":"max_assoc","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (Max.max (Max.max a b) c) (Max.max a (Max.max b c))","decl":"lemma max_assoc (a b c : α) : max (max a b) c = max a (max b c) := by\n  apply eq_max\n  · apply le_trans (le_max_left a b) (le_max_left ..)\n  · apply max_le\n    · apply le_trans (le_max_right a b) (le_max_left ..)\n    · apply le_max_right\n  · intro d h₁ h₂; apply max_le\n    · apply max_le h₁; apply le_trans (le_max_left _ _) h₂\n    · apply le_trans (le_max_right _ _) h₂\n\n"}
{"name":"max_left_comm","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (Max.max a (Max.max b c)) (Max.max b (Max.max a c))","decl":"lemma max_left_comm (a b c : α) : max a (max b c) = max b (max a c) := by\n  rw [← max_assoc, max_comm a, max_assoc]\n\n"}
{"name":"max_self","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (Max.max a a) a","decl":"@[simp] lemma max_self (a : α) : max a a = a := by simp [max_def]\n\n"}
{"name":"max_eq_left","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le b a\n⊢ Eq (Max.max a b) a","decl":"lemma max_eq_left (h : b ≤ a) : max a b = a := by\n  apply Eq.symm; apply eq_max (le_refl _) h; intros; assumption\n\n"}
{"name":"max_eq_right","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Max.max a b) b","decl":"lemma max_eq_right (h : a ≤ b) : max a b = b := max_comm b a ▸ max_eq_left h\n\n"}
{"name":"min_eq_left_of_lt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (Min.min a b) a","decl":"lemma min_eq_left_of_lt (h : a < b) : min a b = a := min_eq_left (le_of_lt h)\n"}
{"name":"min_eq_right_of_lt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LT.lt b a\n⊢ Eq (Min.min a b) b","decl":"lemma min_eq_right_of_lt (h : b < a) : min a b = b := min_eq_right (le_of_lt h)\n"}
{"name":"max_eq_left_of_lt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LT.lt b a\n⊢ Eq (Max.max a b) a","decl":"lemma max_eq_left_of_lt (h : b < a) : max a b = a := max_eq_left (le_of_lt h)\n"}
{"name":"max_eq_right_of_lt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (Max.max a b) b","decl":"lemma max_eq_right_of_lt (h : a < b) : max a b = b := max_eq_right (le_of_lt h)\n\n"}
{"name":"lt_min","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LT.lt a b\nh₂ : LT.lt a c\n⊢ LT.lt a (Min.min b c)","decl":"lemma lt_min (h₁ : a < b) (h₂ : a < c) : a < min b c := by\n  cases le_total b c <;> simp [min_eq_left, min_eq_right, *]\n\n"}
{"name":"max_lt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LT.lt a c\nh₂ : LT.lt b c\n⊢ LT.lt (Max.max a b) c","decl":"lemma max_lt (h₁ : a < c) (h₂ : b < c) : max a b < c := by\n  cases le_total a b <;> simp [max_eq_left, max_eq_right, *]\n\n"}
{"name":"compare_lt_iff_lt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Eq (Ord.compare a b) Ordering.lt) (LT.lt a b)","decl":"lemma compare_lt_iff_lt : compare a b = .lt ↔ a < b := by\n  rw [LinearOrder.compare_eq_compareOfLessAndEq, compareOfLessAndEq]\n  split_ifs <;> simp only [*, lt_irrefl, reduceCtorEq]\n\n"}
{"name":"compare_gt_iff_gt","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Eq (Ord.compare a b) Ordering.gt) (GT.gt a b)","decl":"lemma compare_gt_iff_gt : compare a b = .gt ↔ a > b := by\n  rw [LinearOrder.compare_eq_compareOfLessAndEq, compareOfLessAndEq]\n  split_ifs <;> simp only [*, lt_irrefl, not_lt_of_gt, reduceCtorEq]\n  case _ h₁ h₂ =>\n    have h : b < a := lt_trichotomy a b |>.resolve_left h₁ |>.resolve_left h₂\n    rwa [true_iff]\n\n"}
{"name":"compare_eq_iff_eq","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Eq (Ord.compare a b) Ordering.eq) (Eq a b)","decl":"lemma compare_eq_iff_eq : compare a b = .eq ↔ a = b := by\n  rw [LinearOrder.compare_eq_compareOfLessAndEq, compareOfLessAndEq]\n  split_ifs <;> try simp only [reduceCtorEq]\n  case _ h   => rw [false_iff]; exact ne_iff_lt_or_gt.2 <| .inl h\n  case _ _ h => rwa [true_iff]\n  case _ _ h => rwa [false_iff]\n\n"}
{"name":"compare_le_iff_le","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Ne (Ord.compare a b) Ordering.gt) (LE.le a b)","decl":"lemma compare_le_iff_le : compare a b ≠ .gt ↔ a ≤ b := by\n  cases h : compare a b <;> simp\n  · exact le_of_lt <| compare_lt_iff_lt.1 h\n  · exact le_of_eq <| compare_eq_iff_eq.1 h\n  · exact compare_gt_iff_gt.1 h\n\n"}
{"name":"compare_ge_iff_ge","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Ne (Ord.compare a b) Ordering.lt) (GE.ge a b)","decl":"lemma compare_ge_iff_ge : compare a b ≠ .lt ↔ a ≥ b := by\n  cases h : compare a b <;> simp\n  · exact compare_lt_iff_lt.1 h\n  · exact le_of_eq <| (·.symm) <| compare_eq_iff_eq.1 h\n  · exact le_of_lt <| compare_gt_iff_gt.1 h\n\n"}
{"name":"compare_iff","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\no : Ordering\n⊢ Iff (Eq (Ord.compare a b) o) (o.Compares a b)","decl":"lemma compare_iff (a b : α) {o : Ordering} : compare a b = o ↔ o.Compares a b := by\n  cases o <;> simp only [Ordering.Compares]\n  · exact compare_lt_iff_lt\n  · exact compare_eq_iff_eq\n  · exact compare_gt_iff_gt\n\n"}
{"name":"cmp_eq_compare","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (cmp a b) (Ord.compare a b)","decl":"theorem cmp_eq_compare (a b : α) : cmp a b = compare a b := by\n  refine ((compare_iff ..).2 ?_).symm\n  unfold cmp cmpUsing; split_ifs with h1 h2\n  · exact h1\n  · exact h2\n  · exact le_antisymm (not_lt.1 h2) (not_lt.1 h1)\n\n"}
{"name":"cmp_eq_compareOfLessAndEq","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (cmp a b) (compareOfLessAndEq a b)","decl":"theorem cmp_eq_compareOfLessAndEq (a b : α) : cmp a b = compareOfLessAndEq a b :=\n  (cmp_eq_compare ..).trans (LinearOrder.compare_eq_compareOfLessAndEq ..)\n\n"}
{"name":"instLawfulCmpCompare","module":"Mathlib.Order.Defs.LinearOrder","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ Batteries.LawfulCmp Ord.compare","decl":"instance : Batteries.LawfulCmp (compare (α := α)) where\n  symm a b := by\n    cases h : compare a b <;>\n    simp only [Ordering.swap] <;> symm\n    · exact compare_gt_iff_gt.2 <| compare_lt_iff_lt.1 h\n    · exact compare_eq_iff_eq.2 <| compare_eq_iff_eq.1 h |>.symm\n    · exact compare_lt_iff_lt.2 <| compare_gt_iff_gt.1 h\n  le_trans := fun h₁ h₂ ↦\n    compare_le_iff_le.2 <| le_trans (compare_le_iff_le.1 h₁) (compare_le_iff_le.1 h₂)\n  cmp_iff_beq := by simp [compare_eq_iff_eq]\n  cmp_iff_lt := by simp [compare_lt_iff_lt]\n  cmp_iff_le := by simp [compare_le_iff_le]\n\n"}
