{"name":"AlgebraicGeometry.Scheme.PartialMap.mk.inj","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\ndomain✝ : X.Opens\ndense_domain✝ : Dense ↑domain✝\nhom✝ : Quiver.Hom (↑domain✝) Y\ndomain : X.Opens\ndense_domain : Dense ↑domain\nhom : Quiver.Hom (↑domain) Y\nx✝ : Eq { domain := domain✝, dense_domain := dense_domain✝, hom := hom✝ } { domain := domain, dense_domain := dense_domain, hom := hom }\n⊢ And (Eq domain✝ domain) (HEq hom✝ hom)","decl":"/--\nA partial map from `X` to `Y` (`X.PartialMap Y`) is a morphism into `Y`\ndefined on a dense open subscheme of `X`.\n-/\nstructure PartialMap (X Y : Scheme.{u}) where\n  /-- The domain of definition of a partial map. -/\n  domain : X.Opens\n  dense_domain : Dense (domain : Set X)\n  /-- The underlying morphism of a partial map. -/\n  hom : ↑domain ⟶ Y\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.mk.injEq","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\ndomain✝ : X.Opens\ndense_domain✝ : Dense ↑domain✝\nhom✝ : Quiver.Hom (↑domain✝) Y\ndomain : X.Opens\ndense_domain : Dense ↑domain\nhom : Quiver.Hom (↑domain) Y\n⊢ Eq (Eq { domain := domain✝, dense_domain := dense_domain✝, hom := hom✝ } { domain := domain, dense_domain := dense_domain, hom := hom }) (And (Eq domain✝ domain) (HEq hom✝ hom))","decl":"/--\nA partial map from `X` to `Y` (`X.PartialMap Y`) is a morphism into `Y`\ndefined on a dense open subscheme of `X`.\n-/\nstructure PartialMap (X Y : Scheme.{u}) where\n  /-- The domain of definition of a partial map. -/\n  domain : X.Opens\n  dense_domain : Dense (domain : Set X)\n  /-- The underlying morphism of a partial map. -/\n  hom : ↑domain ⟶ Y\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.dense_domain","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nself : X.PartialMap Y\n⊢ Dense ↑self.domain","decl":"/--\nA partial map from `X` to `Y` (`X.PartialMap Y`) is a morphism into `Y`\ndefined on a dense open subscheme of `X`.\n-/\nstructure PartialMap (X Y : Scheme.{u}) where\n  /-- The domain of definition of a partial map. -/\n  domain : X.Opens\n  dense_domain : Dense (domain : Set X)\n  /-- The underlying morphism of a partial map. -/\n  hom : ↑domain ⟶ Y\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.mk.sizeOf_spec","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\ndomain : X.Opens\ndense_domain : Dense ↑domain\nhom : Quiver.Hom (↑domain) Y\n⊢ Eq (SizeOf.sizeOf { domain := domain, dense_domain := dense_domain, hom := hom }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf domain)) (SizeOf.sizeOf hom))","decl":"/--\nA partial map from `X` to `Y` (`X.PartialMap Y`) is a morphism into `Y`\ndefined on a dense open subscheme of `X`.\n-/\nstructure PartialMap (X Y : Scheme.{u}) where\n  /-- The domain of definition of a partial map. -/\n  domain : X.Opens\n  dense_domain : Dense (domain : Set X)\n  /-- The underlying morphism of a partial map. -/\n  hom : ↑domain ⟶ Y\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.ext_iff","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf g : X.PartialMap Y\n⊢ Iff (Eq f g) (Exists fun e => Eq f.hom (CategoryTheory.CategoryStruct.comp (X.isoOfEq e).hom g.hom))","decl":"lemma ext_iff (f g : X.PartialMap Y) :\n    f = g ↔ ∃ e : f.domain = g.domain, f.hom = (X.isoOfEq e).hom ≫ g.hom := by\n  constructor\n  · rintro rfl\n    simp only [exists_true_left, Scheme.isoOfEq_rfl, Iso.refl_hom, Category.id_comp]\n  · obtain ⟨U, hU, f⟩ := f\n    obtain ⟨V, hV, g⟩ := g\n    rintro ⟨rfl : U = V, e⟩\n    congr 1\n    simpa using e\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.ext","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf g : X.PartialMap Y\ne : Eq f.domain g.domain\nH : Eq f.hom (CategoryTheory.CategoryStruct.comp (X.isoOfEq e).hom g.hom)\n⊢ Eq f g","decl":"@[ext]\nlemma ext (f g : X.PartialMap Y) (e : f.domain = g.domain)\n    (H : f.hom = (X.isoOfEq e).hom ≫ g.hom) : f = g := by\n  rw [ext_iff]\n  exact ⟨e, H⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.restrict_hom","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\nU : X.Opens\nhU : Dense ↑U\nhU' : LE.le U f.domain\n⊢ Eq (f.restrict U hU hU').hom (CategoryTheory.CategoryStruct.comp (X.homOfLE hU') f.hom)","decl":"/-- The restriction of a partial map to a smaller domain. -/\n@[simps hom domain]\nnoncomputable\ndef restrict (f : X.PartialMap Y) (U : X.Opens)\n    (hU : Dense (U : Set X)) (hU' : U ≤ f.domain) : X.PartialMap Y where\n  domain := U\n  dense_domain := hU\n  hom := X.homOfLE hU' ≫ f.hom\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.restrict_domain","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\nU : X.Opens\nhU : Dense ↑U\nhU' : LE.le U f.domain\n⊢ Eq (f.restrict U hU hU').domain U","decl":"/-- The restriction of a partial map to a smaller domain. -/\n@[simps hom domain]\nnoncomputable\ndef restrict (f : X.PartialMap Y) (U : X.Opens)\n    (hU : Dense (U : Set X)) (hU' : U ≤ f.domain) : X.PartialMap Y where\n  domain := U\n  dense_domain := hU\n  hom := X.homOfLE hU' ≫ f.hom\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.restrict_id","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\n⊢ Eq (f.restrict f.domain ⋯ ⋯) f","decl":"@[simp]\nlemma restrict_id (f : X.PartialMap Y) : f.restrict f.domain f.dense_domain le_rfl = f := by\n  ext1 <;> simp [restrict_domain]\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.restrict_id_hom","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\n⊢ Eq (f.restrict f.domain ⋯ ⋯).hom f.hom","decl":"lemma restrict_id_hom (f : X.PartialMap Y) :\n    (f.restrict f.domain f.dense_domain le_rfl).hom = f.hom := by\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.restrict_restrict","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\nU : X.Opens\nhU : Dense ↑U\nhU' : LE.le U f.domain\nV : X.Opens\nhV : Dense ↑V\nhV' : LE.le V U\n⊢ Eq ((f.restrict U hU hU').restrict V hV hV') (f.restrict V hV ⋯)","decl":"@[simp]\nlemma restrict_restrict (f : X.PartialMap Y)\n    (U : X.Opens) (hU : Dense (U : Set X)) (hU' : U ≤ f.domain)\n    (V : X.Opens) (hV : Dense (V : Set X)) (hV' : V ≤ U) :\n    (f.restrict U hU hU').restrict V hV hV' = f.restrict V hV (hV'.trans hU') := by\n  ext1 <;> simp [restrict_domain]\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.restrict_restrict_hom","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\nU : X.Opens\nhU : Dense ↑U\nhU' : LE.le U f.domain\nV : X.Opens\nhV : Dense ↑V\nhV' : LE.le V U\n⊢ Eq ((f.restrict U hU hU').restrict V hV hV').hom (f.restrict V hV ⋯).hom","decl":"lemma restrict_restrict_hom (f : X.PartialMap Y)\n    (U : X.Opens) (hU : Dense (U : Set X)) (hU' : U ≤ f.domain)\n    (V : X.Opens) (hV : Dense (V : Set X)) (hV' : V ≤ U) :\n    ((f.restrict U hU hU').restrict V hV hV').hom = (f.restrict V hV (hV'.trans hU')).hom := by\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.instIsOverRestrict","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝² : X.Over S\ninst✝¹ : Y.Over S\nf : X.PartialMap Y\ninst✝ : AlgebraicGeometry.Scheme.PartialMap.IsOver S f\nU : X.Opens\nhU : Dense ↑U\nhU' : LE.le U f.domain\n⊢ AlgebraicGeometry.Scheme.PartialMap.IsOver S (f.restrict U hU hU')","decl":"instance [X.Over S] [Y.Over S] (f : X.PartialMap Y) [f.IsOver S]\n    (U : X.Opens) (hU : Dense (U : Set X)) (hU' : U ≤ f.domain) :\n    (f.restrict U hU hU').IsOver S where\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.compHom_hom","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\ng : Quiver.Hom Y Z\n⊢ Eq (f.compHom g).hom (CategoryTheory.CategoryStruct.comp f.hom g)","decl":"/-- The composition of a partial map and a morphism on the right. -/\n@[simps]\ndef compHom (f : X.PartialMap Y) (g : Y ⟶ Z) : X.PartialMap Z where\n  domain := f.domain\n  dense_domain := f.dense_domain\n  hom := f.hom ≫ g\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.compHom_domain","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\ng : Quiver.Hom Y Z\n⊢ Eq (f.compHom g).domain f.domain","decl":"/-- The composition of a partial map and a morphism on the right. -/\n@[simps]\ndef compHom (f : X.PartialMap Y) (g : Y ⟶ Z) : X.PartialMap Z where\n  domain := f.domain\n  dense_domain := f.dense_domain\n  hom := f.hom ≫ g\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.instIsOverCompHomOfIsOver","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y Z S : AlgebraicGeometry.Scheme\ninst✝⁴ : X.Over S\ninst✝³ : Y.Over S\ninst✝² : Z.Over S\nf : X.PartialMap Y\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.Scheme.PartialMap.IsOver S f\ninst✝ : AlgebraicGeometry.Scheme.Hom.IsOver g S\n⊢ AlgebraicGeometry.Scheme.PartialMap.IsOver S (f.compHom g)","decl":"instance [X.Over S] [Y.Over S] [Z.Over S] (f : X.PartialMap Y) (g : Y ⟶ Z)\n    [f.IsOver S] [g.IsOver S] : (f.compHom g).IsOver S where\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.toPartialMap_domain","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\n⊢ Eq f.toPartialMap.domain Top.top","decl":"/-- A scheme morphism as a partial map. -/\n@[simps]\ndef _root_.AlgebraicGeometry.Scheme.Hom.toPartialMap (f : X.Hom Y) :\n    X.PartialMap Y := ⟨⊤, dense_univ, X.topIso.hom ≫ f⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.toPartialMap_hom","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\n⊢ Eq f.toPartialMap.hom (CategoryTheory.CategoryStruct.comp X.topIso.hom f)","decl":"/-- A scheme morphism as a partial map. -/\n@[simps]\ndef _root_.AlgebraicGeometry.Scheme.Hom.toPartialMap (f : X.Hom Y) :\n    X.PartialMap Y := ⟨⊤, dense_univ, X.topIso.hom ≫ f⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.instIsOverToPartialMapOfIsOver","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝² : X.Over S\ninst✝¹ : Y.Over S\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.Scheme.Hom.IsOver f S\n⊢ AlgebraicGeometry.Scheme.PartialMap.IsOver S (AlgebraicGeometry.Scheme.Hom.toPartialMap f)","decl":"instance [X.Over S] [Y.Over S] (f : X ⟶ Y) [f.IsOver S] : f.toPartialMap.IsOver S where\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.isOver_iff","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝¹ : X.Over S\ninst✝ : Y.Over S\nf : X.PartialMap Y\n⊢ Iff (AlgebraicGeometry.Scheme.PartialMap.IsOver S f) (Eq (f.compHom (CategoryTheory.over Y S inferInstance)).hom (CategoryTheory.CategoryStruct.comp f.domain.ι (CategoryTheory.over X S inferInstance)))","decl":"lemma isOver_iff [X.Over S] [Y.Over S] {f : X.PartialMap Y} :\n    f.IsOver S ↔ (f.compHom (Y ↘ S)).hom = f.domain.ι ≫ X ↘ S := by\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.isOver_iff_eq_restrict","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝¹ : X.Over S\ninst✝ : Y.Over S\nf : X.PartialMap Y\n⊢ Iff (AlgebraicGeometry.Scheme.PartialMap.IsOver S f) (Eq (f.compHom (CategoryTheory.over Y S inferInstance)) ((AlgebraicGeometry.Scheme.Hom.toPartialMap (CategoryTheory.over X S inferInstance)).restrict f.domain ⋯ ⋯))","decl":"lemma isOver_iff_eq_restrict [X.Over S] [Y.Over S] {f : X.PartialMap Y} :\n    f.IsOver S ↔ f.compHom (Y ↘ S) = (X ↘ S).toPartialMap.restrict _ f.dense_domain (by simp) := by\n  simp [isOver_iff, PartialMap.ext_iff]\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.fromSpecStalkOfMem_restrict","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\nU : X.Opens\nhU : Dense ↑U\nhU' : LE.le U f.domain\nx : ↑↑X.toPresheafedSpace\nhx : Membership.mem U x\n⊢ Eq ((f.restrict U hU hU').fromSpecStalkOfMem hx) (f.fromSpecStalkOfMem ⋯)","decl":"lemma fromSpecStalkOfMem_restrict (f : X.PartialMap Y)\n    {U : X.Opens} (hU : Dense (U : Set X)) (hU' : U ≤ f.domain) {x} (hx : x ∈ U) :\n    (f.restrict U hU hU').fromSpecStalkOfMem hx = f.fromSpecStalkOfMem (hU' hx) := by\n  dsimp only [fromSpecStalkOfMem, restrict, Scheme.Opens.fromSpecStalkOfMem]\n  have e : ⟨x, hU' hx⟩ = (X.homOfLE hU').base ⟨x, hx⟩ := by\n    rw [Scheme.homOfLE_base]\n    rfl\n  rw [Category.assoc, ← Spec_map_stalkMap_fromSpecStalk_assoc,\n    ← Spec_map_stalkSpecializes_fromSpecStalk (Inseparable.of_eq e).specializes,\n    ← TopCat.Presheaf.stalkCongr_inv _ (Inseparable.of_eq e)]\n  simp only [← Category.assoc, ← Spec.map_comp]\n  congr 3\n  rw [Iso.eq_inv_comp, ← Category.assoc, IsIso.comp_inv_eq, IsIso.eq_inv_comp,\n    stalkMap_congr_hom _ _ (X.homOfLE_ι hU').symm]\n  simp only [restrictFunctor_obj_left, homOfLE_leOfHom, TopCat.Presheaf.stalkCongr_hom]\n  rw [← stalkSpecializes_stalkMap_assoc, stalkMap_comp]\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.fromFunctionField_restrict","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\ninst✝ : IrreducibleSpace ↑↑X.toPresheafedSpace\nU : X.Opens\nhU : Dense ↑U\nhU' : LE.le U f.domain\n⊢ Eq (f.restrict U hU hU').fromFunctionField f.fromFunctionField","decl":"lemma fromFunctionField_restrict (f : X.PartialMap Y) [IrreducibleSpace X]\n    {U : X.Opens} (hU : Dense (U : Set X)) (hU' : U ≤ f.domain) :\n    (f.restrict U hU hU').fromFunctionField = f.fromFunctionField :=\n  fromSpecStalkOfMem_restrict f _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.ofFromSpecStalk_comp","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nsX : Quiver.Hom X S\nsY : Quiver.Hom Y S\ninst✝² : IrreducibleSpace ↑↑X.toPresheafedSpace\ninst✝¹ : AlgebraicGeometry.LocallyOfFiniteType sY\nx : ↑↑X.toPresheafedSpace\ninst✝ : X.IsGermInjectiveAt x\nφ : Quiver.Hom (AlgebraicGeometry.Spec (X.presheaf.stalk x)) Y\nh : Eq (CategoryTheory.CategoryStruct.comp φ sY) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) sX)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.PartialMap.ofFromSpecStalk sX sY φ h).hom sY) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.PartialMap.ofFromSpecStalk sX sY φ h).domain.ι sX)","decl":"lemma ofFromSpecStalk_comp [IrreducibleSpace X] [LocallyOfFiniteType sY]\n    {x : X} [X.IsGermInjectiveAt x] (φ : Spec (X.presheaf.stalk x) ⟶ Y)\n    (h : φ ≫ sY = X.fromSpecStalk x ≫ sX) :\n    (ofFromSpecStalk sX sY φ h).hom ≫ sY = (ofFromSpecStalk sX sY φ h).domain.ι ≫ sX :=\n  (spread_out_of_isGermInjective' sX sY φ h).choose_spec.choose_spec.choose_spec.2\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.mem_domain_ofFromSpecStalk","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nsX : Quiver.Hom X S\nsY : Quiver.Hom Y S\ninst✝² : IrreducibleSpace ↑↑X.toPresheafedSpace\ninst✝¹ : AlgebraicGeometry.LocallyOfFiniteType sY\nx : ↑↑X.toPresheafedSpace\ninst✝ : X.IsGermInjectiveAt x\nφ : Quiver.Hom (AlgebraicGeometry.Spec (X.presheaf.stalk x)) Y\nh : Eq (CategoryTheory.CategoryStruct.comp φ sY) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) sX)\n⊢ Membership.mem (AlgebraicGeometry.Scheme.PartialMap.ofFromSpecStalk sX sY φ h).domain x","decl":"lemma mem_domain_ofFromSpecStalk [IrreducibleSpace X] [LocallyOfFiniteType sY]\n    {x : X} [X.IsGermInjectiveAt x] (φ : Spec (X.presheaf.stalk x) ⟶ Y)\n    (h : φ ≫ sY = X.fromSpecStalk x ≫ sX) : x ∈ (ofFromSpecStalk sX sY φ h).domain :=\n  (spread_out_of_isGermInjective' sX sY φ h).choose_spec.choose\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.fromSpecStalkOfMem_ofFromSpecStalk","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nsX : Quiver.Hom X S\nsY : Quiver.Hom Y S\ninst✝² : IrreducibleSpace ↑↑X.toPresheafedSpace\ninst✝¹ : AlgebraicGeometry.LocallyOfFiniteType sY\nx : ↑↑X.toPresheafedSpace\ninst✝ : X.IsGermInjectiveAt x\nφ : Quiver.Hom (AlgebraicGeometry.Spec (X.presheaf.stalk x)) Y\nh : Eq (CategoryTheory.CategoryStruct.comp φ sY) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) sX)\n⊢ Eq ((AlgebraicGeometry.Scheme.PartialMap.ofFromSpecStalk sX sY φ h).fromSpecStalkOfMem ⋯) φ","decl":"lemma fromSpecStalkOfMem_ofFromSpecStalk [IrreducibleSpace X] [LocallyOfFiniteType sY]\n    {x : X} [X.IsGermInjectiveAt x] (φ : Spec (X.presheaf.stalk x) ⟶ Y)\n    (h : φ ≫ sY = X.fromSpecStalk x ≫ sX) :\n    (ofFromSpecStalk sX sY φ h).fromSpecStalkOfMem (mem_domain_ofFromSpecStalk sX sY φ h) = φ :=\n  (spread_out_of_isGermInjective' sX sY φ h).choose_spec.choose_spec.choose_spec.1.symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.fromSpecStalkOfMem_compHom","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\ng : Quiver.Hom Y Z\nx : ↑↑X.toPresheafedSpace\nhx : Membership.mem (f.compHom g).domain x\n⊢ Eq ((f.compHom g).fromSpecStalkOfMem hx) (CategoryTheory.CategoryStruct.comp (f.fromSpecStalkOfMem hx) g)","decl":"@[simp]\nlemma fromSpecStalkOfMem_compHom (f : X.PartialMap Y) (g : Y ⟶ Z) (x) (hx) :\n    (f.compHom g).fromSpecStalkOfMem (x := x) hx = f.fromSpecStalkOfMem hx ≫ g := by\n  simp [fromSpecStalkOfMem]\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.fromSpecStalkOfMem_toPartialMap","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nx : ↑↑X.toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.Scheme.Hom.toPartialMap f).fromSpecStalkOfMem trivial) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) f)","decl":"@[simp]\nlemma fromSpecStalkOfMem_toPartialMap (f : X ⟶ Y) (x) :\n    f.toPartialMap.fromSpecStalkOfMem (x := x) trivial = X.fromSpecStalk x ≫ f := by\n  simp [fromSpecStalkOfMem]\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.equivalence_rel","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\n⊢ Equivalence AlgebraicGeometry.Scheme.PartialMap.equiv","decl":"lemma equivalence_rel : Equivalence (@Scheme.PartialMap.equiv X Y) where\n  refl f := ⟨f.domain, f.dense_domain, by simp⟩\n  symm {f g} := by\n    intro ⟨W, hW, hWl, hWr, e⟩\n    exact ⟨W, hW, hWr, hWl, e.symm⟩\n  trans {f g h} := by\n    intro ⟨W₁, hW₁, hW₁l, hW₁r, e₁⟩ ⟨W₂, hW₂, hW₂l, hW₂r, e₂⟩\n    refine ⟨W₁ ⊓ W₂, hW₁.inter_of_isOpen_left hW₂ W₁.2, inf_le_left.trans hW₁l,\n      inf_le_right.trans hW₂r, ?_⟩\n    dsimp at e₁ e₂\n    simp only [restrict_domain, restrict_hom, restrictFunctor_obj_left, homOfLE_leOfHom,\n      ← X.homOfLE_homOfLE (U := W₁ ⊓ W₂) inf_le_left hW₁l, Functor.map_comp, Over.comp_left,\n      Category.assoc, e₁, ← X.homOfLE_homOfLE (U := W₁ ⊓ W₂) inf_le_right hW₂r, ← e₂]\n    simp only [homOfLE_homOfLE_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.restrict_equiv","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\nU : X.Opens\nhU : Dense ↑U\nhU' : LE.le U f.domain\n⊢ (f.restrict U hU hU').equiv f","decl":"lemma restrict_equiv (f : X.PartialMap Y) (U : X.Opens)\n    (hU : Dense (U : Set X)) (hU' : U ≤ f.domain) : (f.restrict U hU hU').equiv f :=\n  ⟨U, hU, le_rfl, hU', by simp⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.equiv_of_fromSpecStalkOfMem_eq","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝¹ : IrreducibleSpace ↑↑X.toPresheafedSpace\nx : ↑↑X.toPresheafedSpace\ninst✝ : X.IsGermInjectiveAt x\nf g : X.PartialMap Y\nhxf : Membership.mem f.domain x\nhxg : Membership.mem g.domain x\nH : Eq (f.fromSpecStalkOfMem hxf) (g.fromSpecStalkOfMem hxg)\n⊢ f.equiv g","decl":"lemma equiv_of_fromSpecStalkOfMem_eq [IrreducibleSpace X]\n    {x : X} [X.IsGermInjectiveAt x] (f g : X.PartialMap Y)\n    (hxf : x ∈ f.domain) (hxg : x ∈ g.domain)\n    (H : f.fromSpecStalkOfMem hxf = g.fromSpecStalkOfMem hxg) : f.equiv g := by\n  have hdense : Dense ((f.domain ⊓ g.domain) : Set X) :=\n    f.dense_domain.inter_of_isOpen_left g.dense_domain f.domain.2\n  have := (isGermInjectiveAt_iff_of_isOpenImmersion (f := (f.domain ⊓ g.domain).ι)\n    (x := ⟨x, hxf, hxg⟩)).mp ‹_›\n  have := spread_out_unique_of_isGermInjective' (X := (f.domain ⊓ g.domain).toScheme)\n    (X.homOfLE inf_le_left ≫ f.hom) (X.homOfLE inf_le_right ≫ g.hom) (x := ⟨x, hxf, hxg⟩) ?_\n  · obtain ⟨U, hxU, e⟩ := this\n    refine ⟨(f.domain ⊓ g.domain).ι ''ᵁ U, ((f.domain ⊓ g.domain).ι ''ᵁ U).2.dense\n      ⟨_, ⟨_, hxU, rfl⟩⟩,\n      ((Set.image_subset_range _ _).trans_eq (Subtype.range_val)).trans inf_le_left,\n      ((Set.image_subset_range _ _).trans_eq (Subtype.range_val)).trans inf_le_right, ?_⟩\n    rw [← cancel_epi (Scheme.Hom.isoImage _ _).hom]\n    simp only [TopologicalSpace.Opens.carrier_eq_coe, IsOpenMap.coe_functor_obj,\n      TopologicalSpace.Opens.coe_inf, restrict_hom, ← Category.assoc] at e ⊢\n    convert e using 2 <;> rw [← cancel_mono (Scheme.Opens.ι _)] <;> simp\n  · rw [← f.fromSpecStalkOfMem_restrict hdense inf_le_left ⟨hxf, hxg⟩,\n      ← g.fromSpecStalkOfMem_restrict hdense inf_le_right ⟨hxf, hxg⟩] at H\n    simpa only [fromSpecStalkOfMem, restrict_domain, Opens.fromSpecStalkOfMem, Spec.map_inv,\n      restrict_hom, Category.assoc, IsIso.eq_inv_comp, IsIso.hom_inv_id_assoc] using H\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.instIsReducedToScheme","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ninst✝ : AlgebraicGeometry.IsReduced X\n⊢ AlgebraicGeometry.IsReduced ↑U","decl":"instance (U : X.Opens) [IsReduced X] : IsReduced U := isReduced_of_isOpenImmersion U.ι\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.Opens.isDominant_ι","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : Dense ↑U\n⊢ AlgebraicGeometry.IsDominant U.ι","decl":"lemma Opens.isDominant_ι {U : X.Opens} (hU : Dense (X := X) U) : IsDominant U.ι :=\n  ⟨by simpa [DenseRange] using hU⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.Opens.isDominant_homOfLE","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\nhU : Dense ↑U\nhU' : LE.le U V\n⊢ AlgebraicGeometry.IsDominant (X.homOfLE hU')","decl":"lemma Opens.isDominant_homOfLE {U V : X.Opens} (hU : Dense (X := X) U) (hU' : U ≤ V) :\n    IsDominant (X.homOfLE hU') :=\n  have : IsDominant (X.homOfLE hU' ≫ Opens.ι _) := by simpa using Opens.isDominant_ι hU\n  IsDominant.of_comp_of_isOpenImmersion (g := Opens.ι _) _\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.equiv_iff_of_isSeparated_of_le","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝⁵ : X.Over S\ninst✝⁴ : Y.Over S\ninst✝³ : AlgebraicGeometry.IsReduced X\ninst✝² : AlgebraicGeometry.IsSeparated (CategoryTheory.over Y S inferInstance)\nf g : X.PartialMap Y\ninst✝¹ : AlgebraicGeometry.Scheme.PartialMap.IsOver S f\ninst✝ : AlgebraicGeometry.Scheme.PartialMap.IsOver S g\nW : X.Opens\nhW : Dense ↑W\nhWl : LE.le W f.domain\nhWr : LE.le W g.domain\n⊢ Iff (f.equiv g) (Eq (f.restrict W hW hWl).hom (g.restrict W hW hWr).hom)","decl":"/-- Two partial maps from reduced schemes to separated schemes are equivalent if and only if\nthey are equal on **any** open dense subset. -/\nlemma equiv_iff_of_isSeparated_of_le [X.Over S] [Y.Over S] [IsReduced X]\n    [IsSeparated (Y ↘ S)] {f g : X.PartialMap Y} [f.IsOver S] [g.IsOver S]\n    {W : X.Opens} (hW : Dense (X := X) W) (hWl : W ≤ f.domain) (hWr : W ≤ g.domain) : f.equiv g ↔\n      (f.restrict W hW hWl).hom = (g.restrict W hW hWr).hom := by\n  refine ⟨fun ⟨V, hV, hVl, hVr, e⟩ ↦ ?_, fun e ↦ ⟨_, _, _, _, e⟩⟩\n  have : IsDominant (X.homOfLE (inf_le_left : W ⊓ V ≤ W)) :=\n    Opens.isDominant_homOfLE (hW.inter_of_isOpen_left hV W.2) _\n  apply ext_of_isDominant_of_isSeparated' S (X.homOfLE (inf_le_left : W ⊓ V ≤ W))\n  simpa using congr(X.homOfLE (inf_le_right : W ⊓ V ≤ V) ≫ $e)\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.equiv_iff_of_isSeparated","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝⁵ : X.Over S\ninst✝⁴ : Y.Over S\ninst✝³ : AlgebraicGeometry.IsReduced X\ninst✝² : AlgebraicGeometry.IsSeparated (CategoryTheory.over Y S inferInstance)\nf g : X.PartialMap Y\ninst✝¹ : AlgebraicGeometry.Scheme.PartialMap.IsOver S f\ninst✝ : AlgebraicGeometry.Scheme.PartialMap.IsOver S g\n⊢ Iff (f.equiv g) (Eq (f.restrict (Min.min f.domain g.domain) ⋯ ⋯).hom (g.restrict (Min.min f.domain g.domain) ⋯ ⋯).hom)","decl":"/-- Two partial maps from reduced schemes to separated schemes are equivalent if and only if\nthey are equal on the intersection of the domains. -/\nlemma equiv_iff_of_isSeparated [X.Over S] [Y.Over S] [IsReduced X]\n    [IsSeparated (Y ↘ S)] {f g : X.PartialMap Y}\n    [f.IsOver S] [g.IsOver S] : f.equiv g ↔\n      (f.restrict _ (f.2.inter_of_isOpen_left g.2 f.domain.2) inf_le_left).hom =\n      (g.restrict _ (f.2.inter_of_isOpen_left g.2 f.domain.2) inf_le_right).hom :=\n  equiv_iff_of_isSeparated_of_le (S := S) _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.equiv_iff_of_domain_eq_of_isSeparated","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝⁵ : X.Over S\ninst✝⁴ : Y.Over S\ninst✝³ : AlgebraicGeometry.IsReduced X\ninst✝² : AlgebraicGeometry.IsSeparated (CategoryTheory.over Y S inferInstance)\nf g : X.PartialMap Y\nhfg : Eq f.domain g.domain\ninst✝¹ : AlgebraicGeometry.Scheme.PartialMap.IsOver S f\ninst✝ : AlgebraicGeometry.Scheme.PartialMap.IsOver S g\n⊢ Iff (f.equiv g) (Eq f g)","decl":"/-- Two partial maps from reduced schemes to separated schemes with the same domain are equivalent\nif and only if they are equal. -/\nlemma equiv_iff_of_domain_eq_of_isSeparated [X.Over S] [Y.Over S] [IsReduced X]\n    [IsSeparated (Y ↘ S)] {f g : X.PartialMap Y} (hfg : f.domain = g.domain)\n    [f.IsOver S] [g.IsOver S] : f.equiv g ↔ f = g := by\n  rw [equiv_iff_of_isSeparated_of_le (S := S) f.dense_domain le_rfl hfg.le]\n  obtain ⟨Uf, _, f⟩ := f\n  obtain ⟨Ug, _, g⟩ := g\n  obtain rfl : Uf = Ug := hfg\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.equiv_toPartialMap_iff_of_isSeparated","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝⁵ : X.Over S\ninst✝⁴ : Y.Over S\ninst✝³ : AlgebraicGeometry.IsReduced X\ninst✝² : AlgebraicGeometry.IsSeparated (CategoryTheory.over Y S inferInstance)\nf : X.PartialMap Y\ng : Quiver.Hom X Y\ninst✝¹ : AlgebraicGeometry.Scheme.PartialMap.IsOver S f\ninst✝ : AlgebraicGeometry.Scheme.Hom.IsOver g S\n⊢ Iff (f.equiv (AlgebraicGeometry.Scheme.Hom.toPartialMap g)) (Eq f.hom (CategoryTheory.CategoryStruct.comp f.domain.ι g))","decl":"/-- A partial map from a reduced scheme to a separated scheme is equivalent to a morphism\nif and only if it is equal to the restriction of the morphism. -/\nlemma equiv_toPartialMap_iff_of_isSeparated [X.Over S] [Y.Over S] [IsReduced X]\n    [IsSeparated (Y ↘ S)] {f : X.PartialMap Y} {g : X ⟶ Y}\n    [f.IsOver S] [g.IsOver S] : f.equiv g.toPartialMap ↔\n      f.hom = f.domain.ι ≫ g := by\n  rw [equiv_iff_of_isSeparated (S := S), ← cancel_epi (X.isoOfEq (inf_top_eq f.domain)).hom]\n  simp\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.RationalMap.IsOver.exists_partialMap_over","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝¹ : X.Over S\ninst✝ : Y.Over S\nf : X.RationalMap Y\nself : AlgebraicGeometry.Scheme.RationalMap.IsOver S f\n⊢ Exists fun g => And (AlgebraicGeometry.Scheme.PartialMap.IsOver S g) (Eq g.toRationalMap f)","decl":"variable (S) in\n/-- A rational map is a `S`-map if some partial map in the equivalence class is a `S`-map. -/\nclass RationalMap.IsOver [X.Over S] [Y.Over S] (f : X ⤏ Y) : Prop where\n  exists_partialMap_over : ∃ g : X.PartialMap Y, g.IsOver S ∧ g.toRationalMap = f\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.toRationalMap_surjective","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\n⊢ Function.Surjective AlgebraicGeometry.Scheme.PartialMap.toRationalMap","decl":"lemma PartialMap.toRationalMap_surjective : Function.Surjective (@toRationalMap X Y) :=\n  Quotient.exists_rep\n\n"}
{"name":"AlgebraicGeometry.Scheme.RationalMap.exists_rep","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.RationalMap Y\n⊢ Exists fun g => Eq g.toRationalMap f","decl":"lemma RationalMap.exists_rep (f : X ⤏ Y) : ∃ g : X.PartialMap Y, g.toRationalMap = f :=\n  Quotient.exists_rep f\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.toRationalMap_eq_iff","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf g : X.PartialMap Y\n⊢ Iff (Eq f.toRationalMap g.toRationalMap) (f.equiv g)","decl":"lemma PartialMap.toRationalMap_eq_iff {f g : X.PartialMap Y} :\n    f.toRationalMap = g.toRationalMap ↔ f.equiv g :=\n  Quotient.eq\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.restrict_toRationalMap","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\nU : X.Opens\nhU : Dense ↑U\nhU' : LE.le U f.domain\n⊢ Eq (f.restrict U hU hU').toRationalMap f.toRationalMap","decl":"@[simp]\nlemma PartialMap.restrict_toRationalMap (f : X.PartialMap Y) (U : X.Opens)\n    (hU : Dense (U : Set X)) (hU' : U ≤ f.domain) :\n    (f.restrict U hU hU').toRationalMap = f.toRationalMap :=\n  toRationalMap_eq_iff.mpr (f.restrict_equiv U hU hU')\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsOverToRationalMapOfIsOver","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝² : X.Over S\ninst✝¹ : Y.Over S\nf : X.PartialMap Y\ninst✝ : AlgebraicGeometry.Scheme.PartialMap.IsOver S f\n⊢ AlgebraicGeometry.Scheme.RationalMap.IsOver S f.toRationalMap","decl":"instance [X.Over S] [Y.Over S] (f : X.PartialMap Y) [f.IsOver S] : f.toRationalMap.IsOver S :=\n  ⟨f, ‹_›, rfl⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.RationalMap.exists_partialMap_over","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝² : X.Over S\ninst✝¹ : Y.Over S\nf : X.RationalMap Y\ninst✝ : AlgebraicGeometry.Scheme.RationalMap.IsOver S f\n⊢ Exists fun g => And (AlgebraicGeometry.Scheme.PartialMap.IsOver S g) (Eq g.toRationalMap f)","decl":"variable (S) in\nlemma RationalMap.exists_partialMap_over [X.Over S] [Y.Over S] (f : X ⤏ Y) [f.IsOver S] :\n    ∃ g : X.PartialMap Y, g.IsOver S ∧ g.toRationalMap = f :=\n  IsOver.exists_partialMap_over\n\n"}
{"name":"AlgebraicGeometry.Scheme.RationalMap.compHom_toRationalMap","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\ng : Quiver.Hom Y Z\n⊢ Eq (f.compHom g).toRationalMap (f.toRationalMap.compHom g)","decl":"@[simp]\nlemma RationalMap.compHom_toRationalMap (f : X.PartialMap Y) (g : Y ⟶ Z) :\n    (f.compHom g).toRationalMap = f.toRationalMap.compHom g := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsOverCompHomOfIsOver","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y Z S : AlgebraicGeometry.Scheme\ninst✝⁴ : X.Over S\ninst✝³ : Y.Over S\ninst✝² : Z.Over S\nf : X.RationalMap Y\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.Scheme.RationalMap.IsOver S f\ninst✝ : AlgebraicGeometry.Scheme.Hom.IsOver g S\n⊢ AlgebraicGeometry.Scheme.RationalMap.IsOver S (f.compHom g)","decl":"instance [X.Over S] [Y.Over S] [Z.Over S] (f : X ⤏ Y) (g : Y ⟶ Z)\n    [f.IsOver S] [g.IsOver S] : (f.compHom g).IsOver S where\n  exists_partialMap_over := by\n    obtain ⟨f, hf, rfl⟩ := f.exists_partialMap_over S\n    exact ⟨f.compHom g, inferInstance, rfl⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.exists_restrict_isOver","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝² : X.Over S\ninst✝¹ : Y.Over S\nf : X.PartialMap Y\ninst✝ : AlgebraicGeometry.Scheme.RationalMap.IsOver S f.toRationalMap\n⊢ Exists fun U => Exists fun hU => Exists fun hU' => AlgebraicGeometry.Scheme.PartialMap.IsOver S (f.restrict U hU hU')","decl":"variable (S) in\nlemma PartialMap.exists_restrict_isOver [X.Over S] [Y.Over S] (f : X.PartialMap Y)\n    [f.toRationalMap.IsOver S] : ∃ U hU hU', (f.restrict U hU hU').IsOver S := by\n  obtain ⟨f', hf₁, hf₂⟩ := RationalMap.IsOver.exists_partialMap_over (S := S) (f := f.toRationalMap)\n  obtain ⟨U, hU, hUl, hUr, e⟩ := PartialMap.toRationalMap_eq_iff.mp hf₂\n  exact ⟨U, hU, hUr, by rw [IsOver, ← e]; infer_instance⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.RationalMap.isOver_iff","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝¹ : X.Over S\ninst✝ : Y.Over S\nf : X.RationalMap Y\n⊢ Iff (AlgebraicGeometry.Scheme.RationalMap.IsOver S f) (Eq (f.compHom (CategoryTheory.over Y S inferInstance)) (AlgebraicGeometry.Scheme.Hom.toRationalMap (CategoryTheory.over X S inferInstance)))","decl":"lemma RationalMap.isOver_iff [X.Over S] [Y.Over S] {f : X ⤏ Y} :\n    f.IsOver S ↔ f.compHom (Y ↘ S) = (X ↘ S).toRationalMap := by\n  constructor\n  · intro h\n    obtain ⟨g, hg, e⟩ := f.exists_partialMap_over S\n    rw [← e, Hom.toRationalMap, ← compHom_toRationalMap, PartialMap.isOver_iff_eq_restrict.mp hg,\n      PartialMap.restrict_toRationalMap]\n  · intro e\n    obtain ⟨f, rfl⟩ := PartialMap.toRationalMap_surjective f\n    obtain ⟨U, hU, hUl, hUr, e⟩ := PartialMap.toRationalMap_eq_iff.mp e\n    exact ⟨⟨f.restrict U hU hUl, by simpa using e, by simp⟩⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.isOver_toRationalMap_iff_of_isSeparated","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝³ : X.Over S\ninst✝² : Y.Over S\ninst✝¹ : AlgebraicGeometry.IsReduced X\ninst✝ : S.IsSeparated\nf : X.PartialMap Y\n⊢ Iff (AlgebraicGeometry.Scheme.RationalMap.IsOver S f.toRationalMap) (AlgebraicGeometry.Scheme.PartialMap.IsOver S f)","decl":"lemma PartialMap.isOver_toRationalMap_iff_of_isSeparated [X.Over S] [Y.Over S] [IsReduced X]\n    [S.IsSeparated] {f : X.PartialMap Y} :\n    f.toRationalMap.IsOver S ↔ f.IsOver S := by\n  refine ⟨fun _ ↦ ?_, fun _ ↦ inferInstance⟩\n  obtain ⟨U, hU, hU', H⟩ := f.exists_restrict_isOver (S := S)\n  rw [isOver_iff]\n  have : IsDominant (X.homOfLE hU') := Opens.isDominant_homOfLE hU _\n  exact ext_of_isDominant (ι := X.homOfLE hU') (by simpa using H.1)\n\n"}
{"name":"AlgebraicGeometry.Scheme.RationalMap.fromFunctionField_toRationalMap","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝ : IrreducibleSpace ↑↑X.toPresheafedSpace\nf : X.PartialMap Y\n⊢ Eq f.toRationalMap.fromFunctionField f.fromFunctionField","decl":"@[simp]\nlemma RationalMap.fromFunctionField_toRationalMap [IrreducibleSpace X] (f : X.PartialMap Y) :\n    f.toRationalMap.fromFunctionField = f.fromFunctionField := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.RationalMap.fromFunctionField_ofFunctionField","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nsX : Quiver.Hom X S\nsY : Quiver.Hom Y S\ninst✝¹ : AlgebraicGeometry.IsIntegral X\ninst✝ : AlgebraicGeometry.LocallyOfFiniteType sY\nf : Quiver.Hom (AlgebraicGeometry.Spec X.functionField) Y\nh : Eq (CategoryTheory.CategoryStruct.comp f sY) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk (genericPoint ↑↑X.toPresheafedSpace)) sX)\n⊢ Eq (AlgebraicGeometry.Scheme.RationalMap.ofFunctionField sX sY f h).fromFunctionField f","decl":"lemma RationalMap.fromFunctionField_ofFunctionField [IsIntegral X] [LocallyOfFiniteType sY]\n    (f : Spec X.functionField ⟶ Y) (h : f ≫ sY = X.fromSpecStalk _ ≫ sX) :\n    (ofFunctionField sX sY f h).fromFunctionField = f :=\n  PartialMap.fromSpecStalkOfMem_ofFromSpecStalk sX sY _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.RationalMap.eq_of_fromFunctionField_eq","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝ : AlgebraicGeometry.IsIntegral X\nf g : X.RationalMap Y\nH : Eq f.fromFunctionField g.fromFunctionField\n⊢ Eq f g","decl":"lemma RationalMap.eq_of_fromFunctionField_eq [IsIntegral X] (f g : X.RationalMap Y)\n    (H : f.fromFunctionField = g.fromFunctionField) : f = g := by\n    obtain ⟨f, rfl⟩ := f.exists_rep\n    obtain ⟨g, rfl⟩ := g.exists_rep\n    refine PartialMap.toRationalMap_eq_iff.mpr ?_\n    exact PartialMap.equiv_of_fromSpecStalkOfMem_eq _ _ _ _ H\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.le_domain_toRationalMap","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.PartialMap Y\n⊢ LE.le f.domain f.toRationalMap.domain","decl":"lemma PartialMap.le_domain_toRationalMap (f : X.PartialMap Y) :\n    f.domain ≤ f.toRationalMap.domain :=\n  le_sSup ⟨f, rfl, rfl⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.RationalMap.mem_domain","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.RationalMap Y\nx : ↑↑X.toPresheafedSpace\n⊢ Iff (Membership.mem f.domain x) (Exists fun g => And (Membership.mem g.domain x) (Eq g.toRationalMap f))","decl":"lemma RationalMap.mem_domain {f : X ⤏ Y} {x} :\n    x ∈ f.domain ↔ ∃ g : X.PartialMap Y, x ∈ g.domain ∧ g.toRationalMap = f :=\n  TopologicalSpace.Opens.mem_sSup.trans (by simp [@and_comm (x ∈ _)])\n\n"}
{"name":"AlgebraicGeometry.Scheme.RationalMap.dense_domain","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.RationalMap Y\n⊢ Dense ↑f.domain","decl":"lemma RationalMap.dense_domain (f : X ⤏ Y) : Dense (X := X) f.domain :=\n  f.inductionOn (fun g ↦ g.dense_domain.mono g.le_domain_toRationalMap)\n\n"}
{"name":"AlgebraicGeometry.Scheme.PartialMap.toPartialMap_toRationalMap_restrict","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝¹ : AlgebraicGeometry.IsReduced X\ninst✝ : Y.IsSeparated\nf : X.PartialMap Y\n⊢ Eq (f.toRationalMap.toPartialMap.restrict f.domain ⋯ ⋯).hom f.hom","decl":"lemma PartialMap.toPartialMap_toRationalMap_restrict [IsReduced X] [Y.IsSeparated]\n    (f : X.PartialMap Y) : (f.toRationalMap.toPartialMap.restrict _ f.dense_domain\n      f.le_domain_toRationalMap).hom = f.hom := by\n  dsimp [RationalMap.toPartialMap]\n  refine (f.toRationalMap.openCoverDomain.ι_glueMorphisms _ _ ⟨_, f, rfl, rfl⟩).trans ?_\n  generalize_proofs _ _ H _\n  have : H.choose = f := (equiv_iff_of_domain_eq_of_isSeparated (S := ⊤_ _) H.choose_spec.2).mp\n    (toRationalMap_eq_iff.mp H.choose_spec.1)\n  exact ((ext_iff _ _).mp this.symm).choose_spec.symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.RationalMap.toRationalMap_toPartialMap","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y : AlgebraicGeometry.Scheme\ninst✝¹ : AlgebraicGeometry.IsReduced X\ninst✝ : Y.IsSeparated\nf : X.RationalMap Y\n⊢ Eq f.toPartialMap.toRationalMap f","decl":"@[simp]\nlemma RationalMap.toRationalMap_toPartialMap [IsReduced X] [Y.IsSeparated]\n    (f : X ⤏ Y) : f.toPartialMap.toRationalMap = f := by\n  obtain ⟨f, rfl⟩ := PartialMap.toRationalMap_surjective f\n  trans (f.toRationalMap.toPartialMap.restrict _\n    f.dense_domain f.le_domain_toRationalMap).toRationalMap\n  · simp\n  · congr 1\n    exact PartialMap.ext _ f rfl (by simpa using f.toPartialMap_toRationalMap_restrict)\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsOverToPartialMapOfIsSeparatedOfIsOver","module":"Mathlib.AlgebraicGeometry.RationalMap","initialProofState":"X Y S : AlgebraicGeometry.Scheme\ninst✝⁵ : AlgebraicGeometry.IsReduced X\ninst✝⁴ : Y.IsSeparated\ninst✝³ : S.IsSeparated\ninst✝² : X.Over S\ninst✝¹ : Y.Over S\nf : X.RationalMap Y\ninst✝ : AlgebraicGeometry.Scheme.RationalMap.IsOver S f\n⊢ AlgebraicGeometry.Scheme.PartialMap.IsOver S f.toPartialMap","decl":"instance [IsReduced X] [Y.IsSeparated] [S.IsSeparated] [X.Over S] [Y.Over S]\n    (f : X ⤏ Y) [f.IsOver S] : f.toPartialMap.IsOver S := by\n  rw [← PartialMap.isOver_toRationalMap_iff_of_isSeparated, f.toRationalMap_toPartialMap]\n  infer_instance\n\n"}
