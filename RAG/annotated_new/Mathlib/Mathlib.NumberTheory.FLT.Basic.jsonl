{"name":"fermatLastTheoremFor_zero","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"⊢ FermatLastTheoremFor 0","decl":"lemma fermatLastTheoremFor_zero : FermatLastTheoremFor 0 :=\n  fun _ _ _ _ _ _ ↦ by norm_num\n\n"}
{"name":"not_fermatLastTheoremFor_one","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"⊢ Not (FermatLastTheoremFor 1)","decl":"lemma not_fermatLastTheoremFor_one : ¬ FermatLastTheoremFor 1 :=\n  fun h ↦ h 1 1 2 (by norm_num) (by norm_num) (by norm_num) (by norm_num)\n\n"}
{"name":"not_fermatLastTheoremFor_two","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"⊢ Not (FermatLastTheoremFor 2)","decl":"lemma not_fermatLastTheoremFor_two : ¬ FermatLastTheoremFor 2 :=\n  fun h ↦ h 3 4 5 (by norm_num) (by norm_num) (by norm_num) (by norm_num)\n\n"}
{"name":"FermatLastTheoremWith.mono","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Semiring α\ninst✝ : NoZeroDivisors α\nm n : Nat\nhmn : Dvd.dvd m n\nhm : FermatLastTheoremWith α m\n⊢ FermatLastTheoremWith α n","decl":"lemma FermatLastTheoremWith.mono (hmn : m ∣ n) (hm : FermatLastTheoremWith α m) :\n    FermatLastTheoremWith α n := by\n  rintro a b c ha hb hc\n  obtain ⟨k, rfl⟩ := hmn\n  simp_rw [pow_mul']\n  refine hm _ _ _ ?_ ?_ ?_ <;> exact pow_ne_zero _ ‹_›\n\n"}
{"name":"FermatLastTheoremFor.mono","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"m n : Nat\nhmn : Dvd.dvd m n\nhm : FermatLastTheoremFor m\n⊢ FermatLastTheoremFor n","decl":"lemma FermatLastTheoremFor.mono (hmn : m ∣ n) (hm : FermatLastTheoremFor m) :\n    FermatLastTheoremFor n := by\n  exact FermatLastTheoremWith.mono hmn hm\n\n"}
{"name":"fermatLastTheoremWith_nat_int_rat_tfae","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"n : Nat\n⊢ (List.cons (FermatLastTheoremWith Nat n) (List.cons (FermatLastTheoremWith Int n) (List.cons (FermatLastTheoremWith Rat n) List.nil))).TFAE","decl":"lemma fermatLastTheoremWith_nat_int_rat_tfae (n : ℕ) :\n    TFAE [FermatLastTheoremWith ℕ n, FermatLastTheoremWith ℤ n, FermatLastTheoremWith ℚ n] := by\n  tfae_have 1 → 2\n  | h, a, b, c, ha, hb, hc, habc => by\n    obtain hn | hn := n.even_or_odd\n    · refine h a.natAbs b.natAbs c.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.natCast_inj.1 ?_)\n      push_cast\n      simp only [hn.pow_abs, habc]\n    obtain ha | ha := ha.lt_or_lt <;> obtain hb | hb := hb.lt_or_lt <;>\n      obtain hc | hc := hc.lt_or_lt\n    · refine h a.natAbs b.natAbs c.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.natCast_inj.1 ?_)\n      push_cast\n      simp only [abs_of_neg, neg_pow a, neg_pow b, neg_pow c, ← mul_add, habc, *]\n    · exact (by positivity : 0 < c ^ n).not_lt <| habc.symm.trans_lt <| add_neg (hn.pow_neg ha) <|\n        hn.pow_neg hb\n    · refine h b.natAbs c.natAbs a.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.natCast_inj.1 ?_)\n      push_cast\n      simp only [abs_of_pos, abs_of_neg, hn.neg_pow, habc, add_neg_eq_iff_eq_add,\n        eq_neg_add_iff_add_eq, *]\n    · refine h a.natAbs c.natAbs b.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.natCast_inj.1 ?_)\n      push_cast\n      simp only [abs_of_pos, abs_of_neg, hn.neg_pow, habc, neg_add_eq_iff_eq_add,\n        eq_neg_add_iff_add_eq, *]\n    · refine h c.natAbs a.natAbs b.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.natCast_inj.1 ?_)\n      push_cast\n      simp only [abs_of_pos, abs_of_neg, hn.neg_pow, habc, neg_add_eq_iff_eq_add,\n        eq_add_neg_iff_add_eq, *]\n    · refine h c.natAbs b.natAbs a.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.natCast_inj.1 ?_)\n      push_cast\n      simp only [abs_of_pos, abs_of_neg, hn.neg_pow, habc, add_neg_eq_iff_eq_add,\n        eq_add_neg_iff_add_eq, *]\n    · exact (by positivity : 0 < a ^ n + b ^ n).not_lt <| habc.trans_lt <| hn.pow_neg hc\n    · refine h a.natAbs b.natAbs c.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.natCast_inj.1 ?_)\n      push_cast\n      simp only [abs_of_pos, habc, *]\n  tfae_have 2 → 3\n  | h, a, b, c, ha, hb, hc, habc => by\n    rw [← Rat.num_ne_zero] at ha hb hc\n    refine h (a.num * b.den * c.den) (a.den * b.num * c.den) (a.den * b.den * c.num)\n      (by positivity) (by positivity) (by positivity) ?_\n    have : (a.den * b.den * c.den : ℚ) ^ n ≠ 0 := by positivity\n    refine Int.cast_injective <| (div_left_inj' this).1 ?_\n    push_cast\n    simp only [add_div, ← div_pow, mul_div_mul_comm, div_self (by positivity : (a.den : ℚ) ≠ 0),\n      div_self (by positivity : (b.den : ℚ) ≠ 0), div_self (by positivity : (c.den : ℚ) ≠ 0),\n      one_mul, mul_one, Rat.num_div_den, habc]\n  tfae_have 3 → 1\n  | h, a, b, c => mod_cast h a b c\n  tfae_finish\n\n"}
{"name":"fermatLastTheoremFor_iff_nat","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"n : Nat\n⊢ Iff (FermatLastTheoremFor n) (FermatLastTheoremWith Nat n)","decl":"lemma fermatLastTheoremFor_iff_nat {n : ℕ} : FermatLastTheoremFor n ↔ FermatLastTheoremWith ℕ n :=\n  Iff.rfl\n\n"}
{"name":"fermatLastTheoremFor_iff_int","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"n : Nat\n⊢ Iff (FermatLastTheoremFor n) (FermatLastTheoremWith Int n)","decl":"lemma fermatLastTheoremFor_iff_int {n : ℕ} : FermatLastTheoremFor n ↔ FermatLastTheoremWith ℤ n :=\n  (fermatLastTheoremWith_nat_int_rat_tfae n).out 0 1\n\n"}
{"name":"fermatLastTheoremFor_iff_rat","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"n : Nat\n⊢ Iff (FermatLastTheoremFor n) (FermatLastTheoremWith Rat n)","decl":"lemma fermatLastTheoremFor_iff_rat {n : ℕ} : FermatLastTheoremFor n ↔ FermatLastTheoremWith ℚ n :=\n  (fermatLastTheoremWith_nat_int_rat_tfae n).out 0 2\n\n"}
{"name":"FermatLastTheoremWith.fermatLastTheoremWith'","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"α : Type u_2\ninst✝ : CommSemiring α\nn : Nat\nh : FermatLastTheoremWith α n\n⊢ FermatLastTheoremWith' α n","decl":"lemma FermatLastTheoremWith.fermatLastTheoremWith' {α : Type*} [CommSemiring α] {n : ℕ}\n    (h : FermatLastTheoremWith α n) : FermatLastTheoremWith' α n :=\n  fun a b c _ _ _ _ ↦ by exfalso; apply h a b c <;> assumption\n\n"}
{"name":"fermatLastTheoremWith'_of_field","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"α : Type u_2\ninst✝ : Field α\nn : Nat\n⊢ FermatLastTheoremWith' α n","decl":"lemma fermatLastTheoremWith'_of_field (α : Type*) [Field α] (n : ℕ) : FermatLastTheoremWith' α n :=\n  fun a b c ha hb hc _ ↦\n    ⟨1, a, b, c,\n     ⟨(mul_one a).symm, (mul_one b).symm, (mul_one c).symm⟩,\n     ⟨ha.isUnit, hb.isUnit, hc.isUnit⟩⟩\n\n"}
{"name":"FermatLastTheoremWith'.fermatLastTheoremWith","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CommSemiring α\ninst✝ : IsDomain α\nn : Nat\nh : FermatLastTheoremWith' α n\nhn : ∀ (a b c : α), IsUnit a → IsUnit b → IsUnit c → Ne (HAdd.hAdd (HPow.hPow a n) (HPow.hPow b n)) (HPow.hPow c n)\n⊢ FermatLastTheoremWith α n","decl":"lemma FermatLastTheoremWith'.fermatLastTheoremWith {α : Type*} [CommSemiring α] [IsDomain α]\n    {n : ℕ} (h : FermatLastTheoremWith' α n)\n    (hn : ∀ a b c : α, IsUnit a → IsUnit b → IsUnit c → a ^ n + b ^ n ≠ c ^ n) :\n    FermatLastTheoremWith α n := by\n  intro a b c ha hb hc heq\n  rcases h a b c ha hb hc heq with ⟨d, a', b', c', ⟨rfl, rfl, rfl⟩, ⟨ua, ub, uc⟩⟩\n  rw [mul_pow, mul_pow, mul_pow, ← add_mul] at heq\n  exact hn _ _ _ ua ub uc <| mul_right_cancel₀ (pow_ne_zero _ (right_ne_zero_of_mul ha)) heq\n\n"}
{"name":"fermatLastTheoremWith'_iff_fermatLastTheoremWith","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CommSemiring α\ninst✝ : IsDomain α\nn : Nat\nhn : ∀ (a b c : α), IsUnit a → IsUnit b → IsUnit c → Ne (HAdd.hAdd (HPow.hPow a n) (HPow.hPow b n)) (HPow.hPow c n)\n⊢ Iff (FermatLastTheoremWith' α n) (FermatLastTheoremWith α n)","decl":"lemma fermatLastTheoremWith'_iff_fermatLastTheoremWith {α : Type*} [CommSemiring α] [IsDomain α]\n    {n : ℕ} (hn : ∀ a b c : α, IsUnit a → IsUnit b → IsUnit c → a ^ n + b ^ n ≠ c ^ n) :\n    FermatLastTheoremWith' α n ↔ FermatLastTheoremWith α n :=\n  Iff.intro (fun h ↦ h.fermatLastTheoremWith hn) (fun h ↦ h.fermatLastTheoremWith')\n\n"}
{"name":"fermatLastTheoremWith'_nat_int_tfae","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"n : Nat\n⊢ (List.cons (FermatLastTheoremFor n) (List.cons (FermatLastTheoremWith' Nat n) (List.cons (FermatLastTheoremWith' Int n) List.nil))).TFAE","decl":"lemma fermatLastTheoremWith'_nat_int_tfae (n : ℕ) :\n    TFAE [FermatLastTheoremFor n, FermatLastTheoremWith' ℕ n, FermatLastTheoremWith' ℤ n] := by\n  tfae_have 2 ↔ 1 := by\n    apply fermatLastTheoremWith'_iff_fermatLastTheoremWith\n    simp only [Nat.isUnit_iff]\n    intro _ _ _ ha hb hc\n    rw [ha, hb, hc]\n    simp only [one_pow, Nat.reduceAdd, ne_eq, OfNat.ofNat_ne_one, not_false_eq_true]\n  tfae_have 3 ↔ 1 := by\n    rw [fermatLastTheoremFor_iff_int]\n    apply fermatLastTheoremWith'_iff_fermatLastTheoremWith\n    intro a b c ha hb hc\n    by_cases hn : n = 0\n    · subst hn\n      simp only [pow_zero, Int.reduceAdd, ne_eq, OfNat.ofNat_ne_one, not_false_eq_true]\n    · rw [← isUnit_pow_iff hn, Int.isUnit_iff] at ha hb hc\n      -- case division\n      rcases ha with ha | ha <;> rcases hb with hb | hb <;> rcases hc with hc | hc <;>\n        rw [ha, hb, hc] <;> decide\n  tfae_finish\n\n"}
{"name":"fermatLastTheoremWith_of_fermatLastTheoremWith_coprime","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"n : Nat\nR : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : IsDomain R\ninst✝¹ : DecidableEq R\ninst✝ : NormalizedGCDMonoid R\nhn : ∀ (a b c : R), Ne a 0 → Ne b 0 → Ne c 0 → Eq ((Insert.insert a (Insert.insert b (Singleton.singleton c))).gcd id) 1 → Ne (HAdd.hAdd (HPow.hPow a n) (HPow.hPow b n)) (HPow.hPow c n)\n⊢ FermatLastTheoremWith R n","decl":"open Finset in\n/-- To prove Fermat Last Theorem in any semiring that is a `NormalizedGCDMonoid` one can assume\nthat the `gcd` of `{a, b, c}` is `1`. -/\nlemma fermatLastTheoremWith_of_fermatLastTheoremWith_coprime {n : ℕ} {R : Type*} [CommSemiring R]\n    [IsDomain R] [DecidableEq R] [NormalizedGCDMonoid R]\n    (hn : ∀ a b c : R, a ≠ 0 → b ≠ 0 → c ≠ 0 → ({a, b, c} : Finset R).gcd id = 1 →\n      a ^ n + b ^ n ≠ c ^ n) :\n    FermatLastTheoremWith R n := by\n  intro a b c ha hb hc habc\n  let s : Finset R := {a, b, c}; let d := s.gcd id\n  obtain ⟨A, hA⟩ : d ∣ a := gcd_dvd (by simp [s])\n  obtain ⟨B, hB⟩ : d ∣ b := gcd_dvd (by simp [s])\n  obtain ⟨C, hC⟩ : d ∣ c := gcd_dvd (by simp [s])\n  simp only [hA, hB, hC, mul_ne_zero_iff, mul_pow] at ha hb hc habc\n  rw [← mul_add, mul_right_inj' (pow_ne_zero n ha.1)] at habc\n  refine hn A B C ha.2 hb.2 hc.2 ?_ habc\n  rw [← Finset.normalize_gcd, normalize_eq_one]\n  obtain ⟨u, hu⟩ := normalize_associated d\n  refine ⟨u, mul_left_cancel₀ (mt normalize_eq_zero.mp ha.1) (hu.symm ▸ ?_)⟩\n  rw [← Finset.gcd_mul_left, gcd_eq_gcd_image, image_insert, image_insert, image_singleton,\n      id_eq, id_eq, id_eq, ← hA, ← hB, ← hC]\n\n"}
{"name":"dvd_c_of_prime_of_dvd_a_of_dvd_b_of_FLT","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"n : Nat\np : Int\nhp : Prime p\na b c : Int\nhpa : Dvd.dvd p a\nhpb : Dvd.dvd p b\nHF : Eq (HAdd.hAdd (HAdd.hAdd (HPow.hPow a n) (HPow.hPow b n)) (HPow.hPow c n)) 0\n⊢ Dvd.dvd p c","decl":"lemma dvd_c_of_prime_of_dvd_a_of_dvd_b_of_FLT {n : ℕ} {p : ℤ} (hp : Prime p) {a b c : ℤ}\n    (hpa : p ∣ a) (hpb : p ∣ b) (HF : a ^ n + b ^ n + c ^ n = 0) : p ∣ c := by\n  rcases eq_or_ne n 0 with rfl | hn\n  · simp at HF\n  refine hp.dvd_of_dvd_pow (n := n) (dvd_neg.1 ?_)\n  rw [add_eq_zero_iff_eq_neg] at HF\n  exact HF.symm ▸ dvd_add (dvd_pow hpa hn) (dvd_pow hpb hn)\n\n"}
{"name":"isCoprime_of_gcd_eq_one_of_FLT","module":"Mathlib.NumberTheory.FLT.Basic","initialProofState":"n : Nat\na b c : Int\nHgcd : Eq ((Insert.insert a (Insert.insert b (Singleton.singleton c))).gcd id) 1\nHF : Eq (HAdd.hAdd (HAdd.hAdd (HPow.hPow a n) (HPow.hPow b n)) (HPow.hPow c n)) 0\n⊢ IsCoprime a b","decl":"lemma isCoprime_of_gcd_eq_one_of_FLT {n : ℕ} {a b c : ℤ} (Hgcd : Finset.gcd {a, b, c} id = 1)\n    (HF : a ^ n + b ^ n + c ^ n = 0) : IsCoprime a b := by\n  rcases eq_or_ne n 0 with rfl | hn\n  · simp only [pow_zero, Int.reduceAdd, OfNat.ofNat_ne_zero] at HF\n  refine isCoprime_of_prime_dvd  ?_ <| (fun p hp hpa hpb ↦ hp.not_dvd_one ?_)\n  · rintro ⟨rfl, rfl⟩\n    simp only [ne_eq, hn, not_false_eq_true, zero_pow, add_zero, zero_add, pow_eq_zero_iff]\n      at HF\n    simp only [HF, Finset.mem_singleton, Finset.insert_eq_of_mem, Finset.gcd_singleton, id_eq,\n      map_zero, zero_ne_one] at Hgcd\n  · rw [← Hgcd]\n    refine Finset.dvd_gcd_iff.mpr fun x hx ↦ ?_\n    simp only [Finset.mem_insert, Finset.mem_singleton] at hx\n    rcases hx with hx | hx | hx <;> simp only [id_eq, hx, hpa, hpb,\n      dvd_c_of_prime_of_dvd_a_of_dvd_b_of_FLT hp hpa hpb HF]\n"}
