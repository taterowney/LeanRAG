{"name":"TopCat.PrelocalPredicate.mk.inj","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\npredâœ : {U : TopologicalSpace.Opens â†‘X} â†’ ((x : Subtype fun x => Membership.mem U x) â†’ T â†‘x) â†’ Prop\nresâœ : âˆ€ {U V : TopologicalSpace.Opens â†‘X} (i : Quiver.Hom U V) (f : (x : Subtype fun x => Membership.mem V x) â†’ T â†‘x), predâœ f â†’ predâœ fun x => f ((fun x => âŸ¨â†‘x, â‹¯âŸ©) x)\npred : {U : TopologicalSpace.Opens â†‘X} â†’ ((x : Subtype fun x => Membership.mem U x) â†’ T â†‘x) â†’ Prop\nres : âˆ€ {U V : TopologicalSpace.Opens â†‘X} (i : Quiver.Hom U V) (f : (x : Subtype fun x => Membership.mem V x) â†’ T â†‘x), pred f â†’ pred fun x => f ((fun x => âŸ¨â†‘x, â‹¯âŸ©) x)\nxâœ : Eq { pred := predâœ, res := resâœ } { pred := pred, res := res }\nâŠ¢ Eq predâœ pred","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X â†’ Type`,\na `P : PrelocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Î  x : U, T x) â†’ Prop`\n* a proof that if `f : Î  x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate.\n-/\nstructure PrelocalPredicate where\n  /-- The underlying predicate of a prelocal predicate -/\n  pred : âˆ€ {U : Opens X}, (âˆ€ x : U, T x) â†’ Prop\n  /-- The underlying predicate should be invariant under restriction -/\n  res : âˆ€ {U V : Opens X} (i : U âŸ¶ V) (f : âˆ€ x : V, T x) (_ : pred f), pred fun x : U => f (i x)\n\n"}
{"name":"TopCat.PrelocalPredicate.res","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\nself : TopCat.PrelocalPredicate T\nU V : TopologicalSpace.Opens â†‘X\ni : Quiver.Hom U V\nf : (x : Subtype fun x => Membership.mem V x) â†’ T â†‘x\nxâœ : self.pred f\nâŠ¢ self.pred fun x => f ((fun x => âŸ¨â†‘x, â‹¯âŸ©) x)","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X â†’ Type`,\na `P : PrelocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Î  x : U, T x) â†’ Prop`\n* a proof that if `f : Î  x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate.\n-/\nstructure PrelocalPredicate where\n  /-- The underlying predicate of a prelocal predicate -/\n  pred : âˆ€ {U : Opens X}, (âˆ€ x : U, T x) â†’ Prop\n  /-- The underlying predicate should be invariant under restriction -/\n  res : âˆ€ {U V : Opens X} (i : U âŸ¶ V) (f : âˆ€ x : V, T x) (_ : pred f), pred fun x : U => f (i x)\n\n"}
{"name":"TopCat.PrelocalPredicate.mk.injEq","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\npredâœ : {U : TopologicalSpace.Opens â†‘X} â†’ ((x : Subtype fun x => Membership.mem U x) â†’ T â†‘x) â†’ Prop\nresâœ : âˆ€ {U V : TopologicalSpace.Opens â†‘X} (i : Quiver.Hom U V) (f : (x : Subtype fun x => Membership.mem V x) â†’ T â†‘x), predâœ f â†’ predâœ fun x => f ((fun x => âŸ¨â†‘x, â‹¯âŸ©) x)\npred : {U : TopologicalSpace.Opens â†‘X} â†’ ((x : Subtype fun x => Membership.mem U x) â†’ T â†‘x) â†’ Prop\nres : âˆ€ {U V : TopologicalSpace.Opens â†‘X} (i : Quiver.Hom U V) (f : (x : Subtype fun x => Membership.mem V x) â†’ T â†‘x), pred f â†’ pred fun x => f ((fun x => âŸ¨â†‘x, â‹¯âŸ©) x)\nâŠ¢ Eq (Eq { pred := predâœ, res := resâœ } { pred := pred, res := res }) (Eq predâœ pred)","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X â†’ Type`,\na `P : PrelocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Î  x : U, T x) â†’ Prop`\n* a proof that if `f : Î  x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate.\n-/\nstructure PrelocalPredicate where\n  /-- The underlying predicate of a prelocal predicate -/\n  pred : âˆ€ {U : Opens X}, (âˆ€ x : U, T x) â†’ Prop\n  /-- The underlying predicate should be invariant under restriction -/\n  res : âˆ€ {U V : Opens X} (i : U âŸ¶ V) (f : âˆ€ x : V, T x) (_ : pred f), pred fun x : U => f (i x)\n\n"}
{"name":"TopCat.PrelocalPredicate.mk.sizeOf_spec","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\ninstâœ : (a : â†‘X) â†’ SizeOf (T a)\npred : {U : TopologicalSpace.Opens â†‘X} â†’ ((x : Subtype fun x => Membership.mem U x) â†’ T â†‘x) â†’ Prop\nres : âˆ€ {U V : TopologicalSpace.Opens â†‘X} (i : Quiver.Hom U V) (f : (x : Subtype fun x => Membership.mem V x) â†’ T â†‘x), pred f â†’ pred fun x => f ((fun x => âŸ¨â†‘x, â‹¯âŸ©) x)\nâŠ¢ Eq (SizeOf.sizeOf { pred := pred, res := res }) 1","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X â†’ Type`,\na `P : PrelocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Î  x : U, T x) â†’ Prop`\n* a proof that if `f : Î  x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate.\n-/\nstructure PrelocalPredicate where\n  /-- The underlying predicate of a prelocal predicate -/\n  pred : âˆ€ {U : Opens X}, (âˆ€ x : U, T x) â†’ Prop\n  /-- The underlying predicate should be invariant under restriction -/\n  res : âˆ€ {U V : Opens X} (i : U âŸ¶ V) (f : âˆ€ x : V, T x) (_ : pred f), pred fun x : U => f (i x)\n\n"}
{"name":"TopCat.continuousPrelocal_pred","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X T : TopCat\nxâœ : TopologicalSpace.Opens â†‘X\nf : (Subtype fun x => Membership.mem xâœ x) â†’ â†‘T\nâŠ¢ Eq ((X.continuousPrelocal T).pred f) (Continuous f)","decl":"/-- Continuity is a \"prelocal\" predicate on functions to a fixed topological space `T`.\n-/\n@[simps!]\ndef continuousPrelocal (T : TopCat.{v}) : PrelocalPredicate fun _ : X => T where\n  pred {_} f := Continuous f\n  res {_ _} i _ h := Continuous.comp h (Opens.isOpenEmbedding_of_le i.le).continuous\n\n"}
{"name":"TopCat.LocalPredicate.mk.sizeOf_spec","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\ninstâœ : (a : â†‘X) â†’ SizeOf (T a)\ntoPrelocalPredicate : TopCat.PrelocalPredicate T\nlocality : âˆ€ {U : TopologicalSpace.Opens â†‘X} (f : (x : Subtype fun x => Membership.mem U x) â†’ T â†‘x), (âˆ€ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun i => toPrelocalPredicate.pred fun x => f ((fun x => âŸ¨â†‘x, â‹¯âŸ©) x)) â†’ toPrelocalPredicate.pred f\nâŠ¢ Eq (SizeOf.sizeOf { toPrelocalPredicate := toPrelocalPredicate, locality := locality }) (HAdd.hAdd 1 (SizeOf.sizeOf toPrelocalPredicate))","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X â†’ Type`,\na `P : LocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Î  x : U, T x) â†’ Prop`\n* a proof that if `f : Î  x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate, and\n* a proof that given some `f : Î  x : U, T x`,\n  if for every `x : U` we can find an open set `x âˆˆ V â‰¤ U`\n  so that the restriction of `f` to `V` satisfies the predicate,\n  then `f` itself satisfies the predicate.\n-/\nstructure LocalPredicate extends PrelocalPredicate T where\n  /-- A local predicate must be local --- provided that it is locally satisfied, it is also globally\n    satisfied -/\n  locality :\n    âˆ€ {U : Opens X} (f : âˆ€ x : U, T x)\n      (_ : âˆ€ x : U, âˆƒ (V : Opens X) (_ : x.1 âˆˆ V) (i : V âŸ¶ U),\n        pred fun x : V => f (i x : U)), pred f\n\n"}
{"name":"TopCat.LocalPredicate.mk.inj","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\ntoPrelocalPredicateâœ : TopCat.PrelocalPredicate T\nlocalityâœ : âˆ€ {U : TopologicalSpace.Opens â†‘X} (f : (x : Subtype fun x => Membership.mem U x) â†’ T â†‘x), (âˆ€ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun i => toPrelocalPredicateâœ.pred fun x => f ((fun x => âŸ¨â†‘x, â‹¯âŸ©) x)) â†’ toPrelocalPredicateâœ.pred f\ntoPrelocalPredicate : TopCat.PrelocalPredicate T\nlocality : âˆ€ {U : TopologicalSpace.Opens â†‘X} (f : (x : Subtype fun x => Membership.mem U x) â†’ T â†‘x), (âˆ€ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun i => toPrelocalPredicate.pred fun x => f ((fun x => âŸ¨â†‘x, â‹¯âŸ©) x)) â†’ toPrelocalPredicate.pred f\nxâœ : Eq { toPrelocalPredicate := toPrelocalPredicateâœ, locality := localityâœ } { toPrelocalPredicate := toPrelocalPredicate, locality := locality }\nâŠ¢ Eq toPrelocalPredicateâœ toPrelocalPredicate","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X â†’ Type`,\na `P : LocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Î  x : U, T x) â†’ Prop`\n* a proof that if `f : Î  x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate, and\n* a proof that given some `f : Î  x : U, T x`,\n  if for every `x : U` we can find an open set `x âˆˆ V â‰¤ U`\n  so that the restriction of `f` to `V` satisfies the predicate,\n  then `f` itself satisfies the predicate.\n-/\nstructure LocalPredicate extends PrelocalPredicate T where\n  /-- A local predicate must be local --- provided that it is locally satisfied, it is also globally\n    satisfied -/\n  locality :\n    âˆ€ {U : Opens X} (f : âˆ€ x : U, T x)\n      (_ : âˆ€ x : U, âˆƒ (V : Opens X) (_ : x.1 âˆˆ V) (i : V âŸ¶ U),\n        pred fun x : V => f (i x : U)), pred f\n\n"}
{"name":"TopCat.LocalPredicate.mk.injEq","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\ntoPrelocalPredicateâœ : TopCat.PrelocalPredicate T\nlocalityâœ : âˆ€ {U : TopologicalSpace.Opens â†‘X} (f : (x : Subtype fun x => Membership.mem U x) â†’ T â†‘x), (âˆ€ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun i => toPrelocalPredicateâœ.pred fun x => f ((fun x => âŸ¨â†‘x, â‹¯âŸ©) x)) â†’ toPrelocalPredicateâœ.pred f\ntoPrelocalPredicate : TopCat.PrelocalPredicate T\nlocality : âˆ€ {U : TopologicalSpace.Opens â†‘X} (f : (x : Subtype fun x => Membership.mem U x) â†’ T â†‘x), (âˆ€ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun i => toPrelocalPredicate.pred fun x => f ((fun x => âŸ¨â†‘x, â‹¯âŸ©) x)) â†’ toPrelocalPredicate.pred f\nâŠ¢ Eq (Eq { toPrelocalPredicate := toPrelocalPredicateâœ, locality := localityâœ } { toPrelocalPredicate := toPrelocalPredicate, locality := locality }) (Eq toPrelocalPredicateâœ toPrelocalPredicate)","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X â†’ Type`,\na `P : LocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Î  x : U, T x) â†’ Prop`\n* a proof that if `f : Î  x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate, and\n* a proof that given some `f : Î  x : U, T x`,\n  if for every `x : U` we can find an open set `x âˆˆ V â‰¤ U`\n  so that the restriction of `f` to `V` satisfies the predicate,\n  then `f` itself satisfies the predicate.\n-/\nstructure LocalPredicate extends PrelocalPredicate T where\n  /-- A local predicate must be local --- provided that it is locally satisfied, it is also globally\n    satisfied -/\n  locality :\n    âˆ€ {U : Opens X} (f : âˆ€ x : U, T x)\n      (_ : âˆ€ x : U, âˆƒ (V : Opens X) (_ : x.1 âˆˆ V) (i : V âŸ¶ U),\n        pred fun x : V => f (i x : U)), pred f\n\n"}
{"name":"TopCat.LocalPredicate.locality","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\nself : TopCat.LocalPredicate T\nU : TopologicalSpace.Opens â†‘X\nf : (x : Subtype fun x => Membership.mem U x) â†’ T â†‘x\nxâœ : âˆ€ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun i => self.pred fun x => f ((fun x => âŸ¨â†‘x, â‹¯âŸ©) x)\nâŠ¢ self.pred f","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X â†’ Type`,\na `P : LocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Î  x : U, T x) â†’ Prop`\n* a proof that if `f : Î  x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate, and\n* a proof that given some `f : Î  x : U, T x`,\n  if for every `x : U` we can find an open set `x âˆˆ V â‰¤ U`\n  so that the restriction of `f` to `V` satisfies the predicate,\n  then `f` itself satisfies the predicate.\n-/\nstructure LocalPredicate extends PrelocalPredicate T where\n  /-- A local predicate must be local --- provided that it is locally satisfied, it is also globally\n    satisfied -/\n  locality :\n    âˆ€ {U : Opens X} (f : âˆ€ x : U, T x)\n      (_ : âˆ€ x : U, âˆƒ (V : Opens X) (_ : x.1 âˆˆ V) (i : V âŸ¶ U),\n        pred fun x : V => f (i x : U)), pred f\n\n"}
{"name":"TopCat.PrelocalPredicate.sheafifyOf","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\nP : TopCat.PrelocalPredicate T\nU : TopologicalSpace.Opens â†‘X\nf : (x : Subtype fun x => Membership.mem U x) â†’ T â†‘x\nh : P.pred f\nâŠ¢ P.sheafify.pred f","decl":"theorem PrelocalPredicate.sheafifyOf {T : X â†’ Type v} {P : PrelocalPredicate T} {U : Opens X}\n    {f : âˆ€ x : U, T x} (h : P.pred f) : P.sheafify.pred f := fun x =>\n  âŸ¨U, x.2, ğŸ™ _, by convert hâŸ©\n\n"}
{"name":"TopCat.subpresheafToTypes_obj","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\nP : TopCat.PrelocalPredicate T\nU : Opposite (TopologicalSpace.Opens â†‘X)\nâŠ¢ Eq ((TopCat.subpresheafToTypes P).obj U) (Subtype fun f => P.pred f)","decl":"/-- The subpresheaf of dependent functions on `X` satisfying the \"pre-local\" predicate `P`.\n-/\n@[simps!]\ndef subpresheafToTypes (P : PrelocalPredicate T) : Presheaf (Type v) X where\n  obj U := { f : âˆ€ x : U.unop , T x // P.pred f }\n  map {_ _} i f := âŸ¨fun x => f.1 (i.unop x), P.res i.unop f.1 f.2âŸ©\n\n"}
{"name":"TopCat.subpresheafToTypes_map_coe","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\nP : TopCat.PrelocalPredicate T\nxâœÂ¹ xâœ : Opposite (TopologicalSpace.Opens â†‘X)\ni : Quiver.Hom xâœÂ¹ xâœ\nf : Subtype fun f => P.pred f\nx : Subtype fun x => Membership.mem (Opposite.unop xâœ) x\nâŠ¢ Eq (â†‘((TopCat.subpresheafToTypes P).map i f) x) (â†‘f âŸ¨â†‘x, â‹¯âŸ©)","decl":"/-- The subpresheaf of dependent functions on `X` satisfying the \"pre-local\" predicate `P`.\n-/\n@[simps!]\ndef subpresheafToTypes (P : PrelocalPredicate T) : Presheaf (Type v) X where\n  obj U := { f : âˆ€ x : U.unop , T x // P.pred f }\n  map {_ _} i f := âŸ¨fun x => f.1 (i.unop x), P.res i.unop f.1 f.2âŸ©\n\n"}
{"name":"TopCat.subpresheafToTypes.isSheaf","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\nP : TopCat.LocalPredicate T\nâŠ¢ (TopCat.subpresheafToTypes P.toPrelocalPredicate).IsSheaf","decl":"/-- The functions satisfying a local predicate satisfy the sheaf condition.\n-/\ntheorem isSheaf (P : LocalPredicate T) : (subpresheafToTypes P.toPrelocalPredicate).IsSheaf :=\n  Presheaf.isSheaf_of_isSheafUniqueGluing_types.{v} _ fun Î¹ U sf sf_comp => by\n    -- We show the sheaf condition in terms of unique gluing.\n    -- First we obtain a family of sections for the underlying sheaf of functions,\n    -- by forgetting that the predicate holds\n    let sf' : âˆ€ i : Î¹, (presheafToTypes X T).obj (op (U i)) := fun i => (sf i).val\n    -- Since our original family is compatible, this one is as well\n    have sf'_comp : (presheafToTypes X T).IsCompatible U sf' := fun i j =>\n      congr_arg Subtype.val (sf_comp i j)\n    -- So, we can obtain a unique gluing\n    obtain âŸ¨gl, gl_spec, gl_uniqâŸ© := (sheafToTypes X T).existsUnique_gluing U sf' sf'_comp\n    refine âŸ¨âŸ¨gl, ?_âŸ©, ?_, ?_âŸ©\n    Â· -- Our first goal is to show that this chosen gluing satisfies the\n      -- predicate. Of course, we use locality of the predicate.\n      apply P.locality\n      rintro âŸ¨x, memâŸ©\n      -- Once we're at a particular point `x`, we can select some open set `x âˆˆ U i`.\n      choose i hi using Opens.mem_iSup.mp mem\n      -- We claim that the predicate holds in `U i`\n      use U i, hi, Opens.leSupr U i\n      -- This follows, since our original family `sf` satisfies the predicate\n      convert (sf i).property using 1\n      exact gl_spec i\n\n    -- It remains to show that the chosen lift is really a gluing for the subsheaf and\n    -- that it is unique. Both of which follow immediately from the corresponding facts\n    -- in the sheaf of functions without the local predicate.\n    Â· exact fun i => Subtype.ext (gl_spec i)\n    Â· intro gl' hgl'\n      refine Subtype.ext ?_\n      exact gl_uniq gl'.1 fun i => congr_arg Subtype.val (hgl' i)\n\n"}
{"name":"TopCat.subsheafToTypes_val","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\nP : TopCat.LocalPredicate T\nâŠ¢ Eq (TopCat.subsheafToTypes P).val (TopCat.subpresheafToTypes P.toPrelocalPredicate)","decl":"/-- The subsheaf of the sheaf of all dependently typed functions satisfying the local predicate `P`.\n-/\n@[simps]\ndef subsheafToTypes (P : LocalPredicate T) : Sheaf (Type v) X :=\n  âŸ¨subpresheafToTypes P.toPrelocalPredicate, subpresheafToTypes.isSheaf PâŸ©\n\n"}
{"name":"TopCat.stalkToFiber_germ","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\nP : TopCat.LocalPredicate T\nU : TopologicalSpace.Opens â†‘X\nx : â†‘X\nhx : Membership.mem U x\nf : (TopCat.subsheafToTypes P).presheaf.obj { unop := U }\nâŠ¢ Eq (TopCat.stalkToFiber P x ((TopCat.subsheafToTypes P).presheaf.germ U x hx f)) (â†‘f âŸ¨x, hxâŸ©)","decl":"theorem stalkToFiber_germ (P : LocalPredicate T) (U : Opens X) (x : X) (hx : x âˆˆ U) (f) :\n    stalkToFiber P x ((subsheafToTypes P).presheaf.germ U x hx f) = f.1 âŸ¨x, hxâŸ© := by\n  simp [Presheaf.germ, stalkToFiber]\n\n"}
{"name":"TopCat.stalkToFiber_surjective","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\nP : TopCat.LocalPredicate T\nx : â†‘X\nw : âˆ€ (t : T x), Exists fun U => Exists fun f => Exists fun x_1 => Eq (f âŸ¨x, â‹¯âŸ©) t\nâŠ¢ Function.Surjective (TopCat.stalkToFiber P x)","decl":"/-- The `stalkToFiber` map is surjective at `x` if\nevery point in the fiber `T x` has an allowed section passing through it.\n-/\ntheorem stalkToFiber_surjective (P : LocalPredicate T) (x : X)\n    (w : âˆ€ t : T x, âˆƒ (U : OpenNhds x) (f : âˆ€ y : U.1, T y) (_ : P.pred f), f âŸ¨x, U.2âŸ© = t) :\n    Function.Surjective (stalkToFiber P x) := fun t => by\n  rcases w t with âŸ¨U, f, h, rflâŸ©\n  fconstructor\n  Â· exact (subsheafToTypes P).presheaf.germ _ x U.2 âŸ¨f, hâŸ©\n  Â· exact stalkToFiber_germ P U.1 x U.2 âŸ¨f, hâŸ©\n\n"}
{"name":"TopCat.stalkToFiber_injective","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : â†‘X â†’ Type v\nP : TopCat.LocalPredicate T\nx : â†‘X\nw : âˆ€ (U V : TopologicalSpace.OpenNhds x) (fU : (y : Subtype fun x_1 => Membership.mem U.obj x_1) â†’ T â†‘y), P.pred fU â†’ âˆ€ (fV : (y : Subtype fun x_2 => Membership.mem V.obj x_2) â†’ T â†‘y), P.pred fV â†’ Eq (fU âŸ¨x, â‹¯âŸ©) (fV âŸ¨x, â‹¯âŸ©) â†’ Exists fun W => Exists fun iU => Exists fun iV => âˆ€ (w : Subtype fun x_4 => Membership.mem W.obj x_4), Eq (fU ((fun x_4 => âŸ¨â†‘x_4, â‹¯âŸ©) w)) (fV ((fun x_4 => âŸ¨â†‘x_4, â‹¯âŸ©) w))\nâŠ¢ Function.Injective (TopCat.stalkToFiber P x)","decl":"/-- The `stalkToFiber` map is injective at `x` if any two allowed sections which agree at `x`\nagree on some neighborhood of `x`.\n-/\ntheorem stalkToFiber_injective (P : LocalPredicate T) (x : X)\n    (w :\n      âˆ€ (U V : OpenNhds x) (fU : âˆ€ y : U.1, T y) (_ : P.pred fU) (fV : âˆ€ y : V.1, T y)\n        (_ : P.pred fV) (_ : fU âŸ¨x, U.2âŸ© = fV âŸ¨x, V.2âŸ©),\n        âˆƒ (W : OpenNhds x) (iU : W âŸ¶ U) (iV : W âŸ¶ V), âˆ€ w : W.1,\n          fU (iU w : U.1) = fV (iV w : V.1)) :\n    Function.Injective (stalkToFiber P x) := fun tU tV h => by\n  -- We promise to provide all the ingredients of the proof later:\n  let Q :\n    âˆƒ (W : (OpenNhds x)áµ’áµ–) (s : âˆ€ w : (unop W).1, T w) (hW : P.pred s),\n      tU = (subsheafToTypes P).presheaf.germ _ x (unop W).2 âŸ¨s, hWâŸ© âˆ§\n        tV = (subsheafToTypes P).presheaf.germ _ x (unop W).2 âŸ¨s, hWâŸ© :=\n    ?_\n  Â· choose W s hW e using Q\n    exact e.1.trans e.2.symm\n  -- Then use induction to pick particular representatives of `tU tV : stalk x`\n  obtain âŸ¨U, âŸ¨fU, hUâŸ©, rflâŸ© := jointly_surjective'.{v, v} tU\n  obtain âŸ¨V, âŸ¨fV, hVâŸ©, rflâŸ© := jointly_surjective'.{v, v} tV\n  -- Decompose everything into its constituent parts:\n  dsimp\n  simp only [stalkToFiber, Types.Colimit.Î¹_desc_apply'] at h\n  specialize w (unop U) (unop V) fU hU fV hV h\n  rcases w with âŸ¨W, iU, iV, wâŸ©\n  -- and put it back together again in the correct order.\n  refine âŸ¨op W, fun w => fU (iU w : (unop U).1), P.res ?_ _ hU, ?_âŸ©\n  Â· rcases W with âŸ¨W, mâŸ©\n    exact iU\n  Â· exact âŸ¨colimit_sound iU.op (Subtype.eq rfl), colimit_sound iV.op (Subtype.eq (funext w).symm)âŸ©\n\n"}
