{"name":"TopCat.PrelocalPredicate.mk.inj","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\npred✝ : {U : TopologicalSpace.Opens ↑X} → ((x : Subtype fun x => Membership.mem U x) → T ↑x) → Prop\nres✝ : ∀ {U V : TopologicalSpace.Opens ↑X} (i : Quiver.Hom U V) (f : (x : Subtype fun x => Membership.mem V x) → T ↑x), pred✝ f → pred✝ fun x => f ((fun x => ⟨↑x, ⋯⟩) x)\npred : {U : TopologicalSpace.Opens ↑X} → ((x : Subtype fun x => Membership.mem U x) → T ↑x) → Prop\nres : ∀ {U V : TopologicalSpace.Opens ↑X} (i : Quiver.Hom U V) (f : (x : Subtype fun x => Membership.mem V x) → T ↑x), pred f → pred fun x => f ((fun x => ⟨↑x, ⋯⟩) x)\nx✝ : Eq { pred := pred✝, res := res✝ } { pred := pred, res := res }\n⊢ Eq pred✝ pred","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X → Type`,\na `P : PrelocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Π x : U, T x) → Prop`\n* a proof that if `f : Π x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate.\n-/\nstructure PrelocalPredicate where\n  /-- The underlying predicate of a prelocal predicate -/\n  pred : ∀ {U : Opens X}, (∀ x : U, T x) → Prop\n  /-- The underlying predicate should be invariant under restriction -/\n  res : ∀ {U V : Opens X} (i : U ⟶ V) (f : ∀ x : V, T x) (_ : pred f), pred fun x : U => f (i x)\n\n"}
{"name":"TopCat.PrelocalPredicate.res","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\nself : TopCat.PrelocalPredicate T\nU V : TopologicalSpace.Opens ↑X\ni : Quiver.Hom U V\nf : (x : Subtype fun x => Membership.mem V x) → T ↑x\nx✝ : self.pred f\n⊢ self.pred fun x => f ((fun x => ⟨↑x, ⋯⟩) x)","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X → Type`,\na `P : PrelocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Π x : U, T x) → Prop`\n* a proof that if `f : Π x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate.\n-/\nstructure PrelocalPredicate where\n  /-- The underlying predicate of a prelocal predicate -/\n  pred : ∀ {U : Opens X}, (∀ x : U, T x) → Prop\n  /-- The underlying predicate should be invariant under restriction -/\n  res : ∀ {U V : Opens X} (i : U ⟶ V) (f : ∀ x : V, T x) (_ : pred f), pred fun x : U => f (i x)\n\n"}
{"name":"TopCat.PrelocalPredicate.mk.injEq","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\npred✝ : {U : TopologicalSpace.Opens ↑X} → ((x : Subtype fun x => Membership.mem U x) → T ↑x) → Prop\nres✝ : ∀ {U V : TopologicalSpace.Opens ↑X} (i : Quiver.Hom U V) (f : (x : Subtype fun x => Membership.mem V x) → T ↑x), pred✝ f → pred✝ fun x => f ((fun x => ⟨↑x, ⋯⟩) x)\npred : {U : TopologicalSpace.Opens ↑X} → ((x : Subtype fun x => Membership.mem U x) → T ↑x) → Prop\nres : ∀ {U V : TopologicalSpace.Opens ↑X} (i : Quiver.Hom U V) (f : (x : Subtype fun x => Membership.mem V x) → T ↑x), pred f → pred fun x => f ((fun x => ⟨↑x, ⋯⟩) x)\n⊢ Eq (Eq { pred := pred✝, res := res✝ } { pred := pred, res := res }) (Eq pred✝ pred)","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X → Type`,\na `P : PrelocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Π x : U, T x) → Prop`\n* a proof that if `f : Π x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate.\n-/\nstructure PrelocalPredicate where\n  /-- The underlying predicate of a prelocal predicate -/\n  pred : ∀ {U : Opens X}, (∀ x : U, T x) → Prop\n  /-- The underlying predicate should be invariant under restriction -/\n  res : ∀ {U V : Opens X} (i : U ⟶ V) (f : ∀ x : V, T x) (_ : pred f), pred fun x : U => f (i x)\n\n"}
{"name":"TopCat.PrelocalPredicate.mk.sizeOf_spec","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\ninst✝ : (a : ↑X) → SizeOf (T a)\npred : {U : TopologicalSpace.Opens ↑X} → ((x : Subtype fun x => Membership.mem U x) → T ↑x) → Prop\nres : ∀ {U V : TopologicalSpace.Opens ↑X} (i : Quiver.Hom U V) (f : (x : Subtype fun x => Membership.mem V x) → T ↑x), pred f → pred fun x => f ((fun x => ⟨↑x, ⋯⟩) x)\n⊢ Eq (SizeOf.sizeOf { pred := pred, res := res }) 1","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X → Type`,\na `P : PrelocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Π x : U, T x) → Prop`\n* a proof that if `f : Π x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate.\n-/\nstructure PrelocalPredicate where\n  /-- The underlying predicate of a prelocal predicate -/\n  pred : ∀ {U : Opens X}, (∀ x : U, T x) → Prop\n  /-- The underlying predicate should be invariant under restriction -/\n  res : ∀ {U V : Opens X} (i : U ⟶ V) (f : ∀ x : V, T x) (_ : pred f), pred fun x : U => f (i x)\n\n"}
{"name":"TopCat.continuousPrelocal_pred","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X T : TopCat\nx✝ : TopologicalSpace.Opens ↑X\nf : (Subtype fun x => Membership.mem x✝ x) → ↑T\n⊢ Eq ((X.continuousPrelocal T).pred f) (Continuous f)","decl":"/-- Continuity is a \"prelocal\" predicate on functions to a fixed topological space `T`.\n-/\n@[simps!]\ndef continuousPrelocal (T : TopCat.{v}) : PrelocalPredicate fun _ : X => T where\n  pred {_} f := Continuous f\n  res {_ _} i _ h := Continuous.comp h (Opens.isOpenEmbedding_of_le i.le).continuous\n\n"}
{"name":"TopCat.LocalPredicate.mk.sizeOf_spec","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\ninst✝ : (a : ↑X) → SizeOf (T a)\ntoPrelocalPredicate : TopCat.PrelocalPredicate T\nlocality : ∀ {U : TopologicalSpace.Opens ↑X} (f : (x : Subtype fun x => Membership.mem U x) → T ↑x), (∀ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun i => toPrelocalPredicate.pred fun x => f ((fun x => ⟨↑x, ⋯⟩) x)) → toPrelocalPredicate.pred f\n⊢ Eq (SizeOf.sizeOf { toPrelocalPredicate := toPrelocalPredicate, locality := locality }) (HAdd.hAdd 1 (SizeOf.sizeOf toPrelocalPredicate))","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X → Type`,\na `P : LocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Π x : U, T x) → Prop`\n* a proof that if `f : Π x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate, and\n* a proof that given some `f : Π x : U, T x`,\n  if for every `x : U` we can find an open set `x ∈ V ≤ U`\n  so that the restriction of `f` to `V` satisfies the predicate,\n  then `f` itself satisfies the predicate.\n-/\nstructure LocalPredicate extends PrelocalPredicate T where\n  /-- A local predicate must be local --- provided that it is locally satisfied, it is also globally\n    satisfied -/\n  locality :\n    ∀ {U : Opens X} (f : ∀ x : U, T x)\n      (_ : ∀ x : U, ∃ (V : Opens X) (_ : x.1 ∈ V) (i : V ⟶ U),\n        pred fun x : V => f (i x : U)), pred f\n\n"}
{"name":"TopCat.LocalPredicate.mk.inj","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\ntoPrelocalPredicate✝ : TopCat.PrelocalPredicate T\nlocality✝ : ∀ {U : TopologicalSpace.Opens ↑X} (f : (x : Subtype fun x => Membership.mem U x) → T ↑x), (∀ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun i => toPrelocalPredicate✝.pred fun x => f ((fun x => ⟨↑x, ⋯⟩) x)) → toPrelocalPredicate✝.pred f\ntoPrelocalPredicate : TopCat.PrelocalPredicate T\nlocality : ∀ {U : TopologicalSpace.Opens ↑X} (f : (x : Subtype fun x => Membership.mem U x) → T ↑x), (∀ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun i => toPrelocalPredicate.pred fun x => f ((fun x => ⟨↑x, ⋯⟩) x)) → toPrelocalPredicate.pred f\nx✝ : Eq { toPrelocalPredicate := toPrelocalPredicate✝, locality := locality✝ } { toPrelocalPredicate := toPrelocalPredicate, locality := locality }\n⊢ Eq toPrelocalPredicate✝ toPrelocalPredicate","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X → Type`,\na `P : LocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Π x : U, T x) → Prop`\n* a proof that if `f : Π x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate, and\n* a proof that given some `f : Π x : U, T x`,\n  if for every `x : U` we can find an open set `x ∈ V ≤ U`\n  so that the restriction of `f` to `V` satisfies the predicate,\n  then `f` itself satisfies the predicate.\n-/\nstructure LocalPredicate extends PrelocalPredicate T where\n  /-- A local predicate must be local --- provided that it is locally satisfied, it is also globally\n    satisfied -/\n  locality :\n    ∀ {U : Opens X} (f : ∀ x : U, T x)\n      (_ : ∀ x : U, ∃ (V : Opens X) (_ : x.1 ∈ V) (i : V ⟶ U),\n        pred fun x : V => f (i x : U)), pred f\n\n"}
{"name":"TopCat.LocalPredicate.mk.injEq","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\ntoPrelocalPredicate✝ : TopCat.PrelocalPredicate T\nlocality✝ : ∀ {U : TopologicalSpace.Opens ↑X} (f : (x : Subtype fun x => Membership.mem U x) → T ↑x), (∀ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun i => toPrelocalPredicate✝.pred fun x => f ((fun x => ⟨↑x, ⋯⟩) x)) → toPrelocalPredicate✝.pred f\ntoPrelocalPredicate : TopCat.PrelocalPredicate T\nlocality : ∀ {U : TopologicalSpace.Opens ↑X} (f : (x : Subtype fun x => Membership.mem U x) → T ↑x), (∀ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun i => toPrelocalPredicate.pred fun x => f ((fun x => ⟨↑x, ⋯⟩) x)) → toPrelocalPredicate.pred f\n⊢ Eq (Eq { toPrelocalPredicate := toPrelocalPredicate✝, locality := locality✝ } { toPrelocalPredicate := toPrelocalPredicate, locality := locality }) (Eq toPrelocalPredicate✝ toPrelocalPredicate)","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X → Type`,\na `P : LocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Π x : U, T x) → Prop`\n* a proof that if `f : Π x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate, and\n* a proof that given some `f : Π x : U, T x`,\n  if for every `x : U` we can find an open set `x ∈ V ≤ U`\n  so that the restriction of `f` to `V` satisfies the predicate,\n  then `f` itself satisfies the predicate.\n-/\nstructure LocalPredicate extends PrelocalPredicate T where\n  /-- A local predicate must be local --- provided that it is locally satisfied, it is also globally\n    satisfied -/\n  locality :\n    ∀ {U : Opens X} (f : ∀ x : U, T x)\n      (_ : ∀ x : U, ∃ (V : Opens X) (_ : x.1 ∈ V) (i : V ⟶ U),\n        pred fun x : V => f (i x : U)), pred f\n\n"}
{"name":"TopCat.LocalPredicate.locality","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\nself : TopCat.LocalPredicate T\nU : TopologicalSpace.Opens ↑X\nf : (x : Subtype fun x => Membership.mem U x) → T ↑x\nx✝ : ∀ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun i => self.pred fun x => f ((fun x => ⟨↑x, ⋯⟩) x)\n⊢ self.pred f","decl":"/-- Given a topological space `X : TopCat` and a type family `T : X → Type`,\na `P : LocalPredicate T` consists of:\n* a family of predicates `P.pred`, one for each `U : Opens X`, of the form `(Π x : U, T x) → Prop`\n* a proof that if `f : Π x : V, T x` satisfies the predicate on `V : Opens X`, then\n  the restriction of `f` to any open subset `U` also satisfies the predicate, and\n* a proof that given some `f : Π x : U, T x`,\n  if for every `x : U` we can find an open set `x ∈ V ≤ U`\n  so that the restriction of `f` to `V` satisfies the predicate,\n  then `f` itself satisfies the predicate.\n-/\nstructure LocalPredicate extends PrelocalPredicate T where\n  /-- A local predicate must be local --- provided that it is locally satisfied, it is also globally\n    satisfied -/\n  locality :\n    ∀ {U : Opens X} (f : ∀ x : U, T x)\n      (_ : ∀ x : U, ∃ (V : Opens X) (_ : x.1 ∈ V) (i : V ⟶ U),\n        pred fun x : V => f (i x : U)), pred f\n\n"}
{"name":"TopCat.PrelocalPredicate.sheafifyOf","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\nP : TopCat.PrelocalPredicate T\nU : TopologicalSpace.Opens ↑X\nf : (x : Subtype fun x => Membership.mem U x) → T ↑x\nh : P.pred f\n⊢ P.sheafify.pred f","decl":"theorem PrelocalPredicate.sheafifyOf {T : X → Type v} {P : PrelocalPredicate T} {U : Opens X}\n    {f : ∀ x : U, T x} (h : P.pred f) : P.sheafify.pred f := fun x =>\n  ⟨U, x.2, 𝟙 _, by convert h⟩\n\n"}
{"name":"TopCat.subpresheafToTypes_obj","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\nP : TopCat.PrelocalPredicate T\nU : Opposite (TopologicalSpace.Opens ↑X)\n⊢ Eq ((TopCat.subpresheafToTypes P).obj U) (Subtype fun f => P.pred f)","decl":"/-- The subpresheaf of dependent functions on `X` satisfying the \"pre-local\" predicate `P`.\n-/\n@[simps!]\ndef subpresheafToTypes (P : PrelocalPredicate T) : Presheaf (Type v) X where\n  obj U := { f : ∀ x : U.unop , T x // P.pred f }\n  map {_ _} i f := ⟨fun x => f.1 (i.unop x), P.res i.unop f.1 f.2⟩\n\n"}
{"name":"TopCat.subpresheafToTypes_map_coe","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\nP : TopCat.PrelocalPredicate T\nx✝¹ x✝ : Opposite (TopologicalSpace.Opens ↑X)\ni : Quiver.Hom x✝¹ x✝\nf : Subtype fun f => P.pred f\nx : Subtype fun x => Membership.mem (Opposite.unop x✝) x\n⊢ Eq (↑((TopCat.subpresheafToTypes P).map i f) x) (↑f ⟨↑x, ⋯⟩)","decl":"/-- The subpresheaf of dependent functions on `X` satisfying the \"pre-local\" predicate `P`.\n-/\n@[simps!]\ndef subpresheafToTypes (P : PrelocalPredicate T) : Presheaf (Type v) X where\n  obj U := { f : ∀ x : U.unop , T x // P.pred f }\n  map {_ _} i f := ⟨fun x => f.1 (i.unop x), P.res i.unop f.1 f.2⟩\n\n"}
{"name":"TopCat.subpresheafToTypes.isSheaf","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\nP : TopCat.LocalPredicate T\n⊢ (TopCat.subpresheafToTypes P.toPrelocalPredicate).IsSheaf","decl":"/-- The functions satisfying a local predicate satisfy the sheaf condition.\n-/\ntheorem isSheaf (P : LocalPredicate T) : (subpresheafToTypes P.toPrelocalPredicate).IsSheaf :=\n  Presheaf.isSheaf_of_isSheafUniqueGluing_types.{v} _ fun ι U sf sf_comp => by\n    -- We show the sheaf condition in terms of unique gluing.\n    -- First we obtain a family of sections for the underlying sheaf of functions,\n    -- by forgetting that the predicate holds\n    let sf' : ∀ i : ι, (presheafToTypes X T).obj (op (U i)) := fun i => (sf i).val\n    -- Since our original family is compatible, this one is as well\n    have sf'_comp : (presheafToTypes X T).IsCompatible U sf' := fun i j =>\n      congr_arg Subtype.val (sf_comp i j)\n    -- So, we can obtain a unique gluing\n    obtain ⟨gl, gl_spec, gl_uniq⟩ := (sheafToTypes X T).existsUnique_gluing U sf' sf'_comp\n    refine ⟨⟨gl, ?_⟩, ?_, ?_⟩\n    · -- Our first goal is to show that this chosen gluing satisfies the\n      -- predicate. Of course, we use locality of the predicate.\n      apply P.locality\n      rintro ⟨x, mem⟩\n      -- Once we're at a particular point `x`, we can select some open set `x ∈ U i`.\n      choose i hi using Opens.mem_iSup.mp mem\n      -- We claim that the predicate holds in `U i`\n      use U i, hi, Opens.leSupr U i\n      -- This follows, since our original family `sf` satisfies the predicate\n      convert (sf i).property using 1\n      exact gl_spec i\n\n    -- It remains to show that the chosen lift is really a gluing for the subsheaf and\n    -- that it is unique. Both of which follow immediately from the corresponding facts\n    -- in the sheaf of functions without the local predicate.\n    · exact fun i => Subtype.ext (gl_spec i)\n    · intro gl' hgl'\n      refine Subtype.ext ?_\n      exact gl_uniq gl'.1 fun i => congr_arg Subtype.val (hgl' i)\n\n"}
{"name":"TopCat.subsheafToTypes_val","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\nP : TopCat.LocalPredicate T\n⊢ Eq (TopCat.subsheafToTypes P).val (TopCat.subpresheafToTypes P.toPrelocalPredicate)","decl":"/-- The subsheaf of the sheaf of all dependently typed functions satisfying the local predicate `P`.\n-/\n@[simps]\ndef subsheafToTypes (P : LocalPredicate T) : Sheaf (Type v) X :=\n  ⟨subpresheafToTypes P.toPrelocalPredicate, subpresheafToTypes.isSheaf P⟩\n\n"}
{"name":"TopCat.stalkToFiber_germ","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\nP : TopCat.LocalPredicate T\nU : TopologicalSpace.Opens ↑X\nx : ↑X\nhx : Membership.mem U x\nf : (TopCat.subsheafToTypes P).presheaf.obj { unop := U }\n⊢ Eq (TopCat.stalkToFiber P x ((TopCat.subsheafToTypes P).presheaf.germ U x hx f)) (↑f ⟨x, hx⟩)","decl":"theorem stalkToFiber_germ (P : LocalPredicate T) (U : Opens X) (x : X) (hx : x ∈ U) (f) :\n    stalkToFiber P x ((subsheafToTypes P).presheaf.germ U x hx f) = f.1 ⟨x, hx⟩ := by\n  simp [Presheaf.germ, stalkToFiber]\n\n"}
{"name":"TopCat.stalkToFiber_surjective","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\nP : TopCat.LocalPredicate T\nx : ↑X\nw : ∀ (t : T x), Exists fun U => Exists fun f => Exists fun x_1 => Eq (f ⟨x, ⋯⟩) t\n⊢ Function.Surjective (TopCat.stalkToFiber P x)","decl":"/-- The `stalkToFiber` map is surjective at `x` if\nevery point in the fiber `T x` has an allowed section passing through it.\n-/\ntheorem stalkToFiber_surjective (P : LocalPredicate T) (x : X)\n    (w : ∀ t : T x, ∃ (U : OpenNhds x) (f : ∀ y : U.1, T y) (_ : P.pred f), f ⟨x, U.2⟩ = t) :\n    Function.Surjective (stalkToFiber P x) := fun t => by\n  rcases w t with ⟨U, f, h, rfl⟩\n  fconstructor\n  · exact (subsheafToTypes P).presheaf.germ _ x U.2 ⟨f, h⟩\n  · exact stalkToFiber_germ P U.1 x U.2 ⟨f, h⟩\n\n"}
{"name":"TopCat.stalkToFiber_injective","module":"Mathlib.Topology.Sheaves.LocalPredicate","initialProofState":"X : TopCat\nT : ↑X → Type v\nP : TopCat.LocalPredicate T\nx : ↑X\nw : ∀ (U V : TopologicalSpace.OpenNhds x) (fU : (y : Subtype fun x_1 => Membership.mem U.obj x_1) → T ↑y), P.pred fU → ∀ (fV : (y : Subtype fun x_2 => Membership.mem V.obj x_2) → T ↑y), P.pred fV → Eq (fU ⟨x, ⋯⟩) (fV ⟨x, ⋯⟩) → Exists fun W => Exists fun iU => Exists fun iV => ∀ (w : Subtype fun x_4 => Membership.mem W.obj x_4), Eq (fU ((fun x_4 => ⟨↑x_4, ⋯⟩) w)) (fV ((fun x_4 => ⟨↑x_4, ⋯⟩) w))\n⊢ Function.Injective (TopCat.stalkToFiber P x)","decl":"/-- The `stalkToFiber` map is injective at `x` if any two allowed sections which agree at `x`\nagree on some neighborhood of `x`.\n-/\ntheorem stalkToFiber_injective (P : LocalPredicate T) (x : X)\n    (w :\n      ∀ (U V : OpenNhds x) (fU : ∀ y : U.1, T y) (_ : P.pred fU) (fV : ∀ y : V.1, T y)\n        (_ : P.pred fV) (_ : fU ⟨x, U.2⟩ = fV ⟨x, V.2⟩),\n        ∃ (W : OpenNhds x) (iU : W ⟶ U) (iV : W ⟶ V), ∀ w : W.1,\n          fU (iU w : U.1) = fV (iV w : V.1)) :\n    Function.Injective (stalkToFiber P x) := fun tU tV h => by\n  -- We promise to provide all the ingredients of the proof later:\n  let Q :\n    ∃ (W : (OpenNhds x)ᵒᵖ) (s : ∀ w : (unop W).1, T w) (hW : P.pred s),\n      tU = (subsheafToTypes P).presheaf.germ _ x (unop W).2 ⟨s, hW⟩ ∧\n        tV = (subsheafToTypes P).presheaf.germ _ x (unop W).2 ⟨s, hW⟩ :=\n    ?_\n  · choose W s hW e using Q\n    exact e.1.trans e.2.symm\n  -- Then use induction to pick particular representatives of `tU tV : stalk x`\n  obtain ⟨U, ⟨fU, hU⟩, rfl⟩ := jointly_surjective'.{v, v} tU\n  obtain ⟨V, ⟨fV, hV⟩, rfl⟩ := jointly_surjective'.{v, v} tV\n  -- Decompose everything into its constituent parts:\n  dsimp\n  simp only [stalkToFiber, Types.Colimit.ι_desc_apply'] at h\n  specialize w (unop U) (unop V) fU hU fV hV h\n  rcases w with ⟨W, iU, iV, w⟩\n  -- and put it back together again in the correct order.\n  refine ⟨op W, fun w => fU (iU w : (unop U).1), P.res ?_ _ hU, ?_⟩\n  · rcases W with ⟨W, m⟩\n    exact iU\n  · exact ⟨colimit_sound iU.op (Subtype.eq rfl), colimit_sound iV.op (Subtype.eq (funext w).symm)⟩\n\n"}
