{"name":"RingHom.kerLift_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : Semiring S\nf : RingHom R S\nr : R\n⊢ Eq (f.kerLift ((Ideal.Quotient.mk (RingHom.ker f)) r)) (f r)","decl":"@[simp]\ntheorem kerLift_mk (r : R) : kerLift f (Ideal.Quotient.mk (ker f) r) = f r :=\n  Ideal.Quotient.lift_mk _ _ _\n\n"}
{"name":"RingHom.lift_injective_of_ker_le_ideal","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : Semiring S\nI : Ideal R\nf : RingHom R S\nH : ∀ (a : R), Membership.mem I a → Eq (f a) 0\nhI : LE.le (RingHom.ker f) I\n⊢ Function.Injective ⇑(Ideal.Quotient.lift I f H)","decl":"theorem lift_injective_of_ker_le_ideal (I : Ideal R) {f : R →+* S} (H : ∀ a : R, a ∈ I → f a = 0)\n    (hI : ker f ≤ I) : Function.Injective (Ideal.Quotient.lift I f H) := by\n  rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero]\n  intro u hu\n  obtain ⟨v, rfl⟩ := Ideal.Quotient.mk_surjective u\n  rw [Ideal.Quotient.lift_mk] at hu\n  rw [Ideal.Quotient.eq_zero_iff_mem]\n  exact hI (RingHom.mem_ker.mpr hu)\n\n"}
{"name":"RingHom.kerLift_injective","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Function.Injective ⇑f.kerLift","decl":"/-- The induced map from the quotient by the kernel is injective. -/\ntheorem kerLift_injective : Function.Injective (kerLift f) :=\n  lift_injective_of_ker_le_ideal (ker f) (fun a => by simp only [mem_ker, imp_self]) le_rfl\n\n\n"}
{"name":"RingHom.quotientKerEquivOfRightInverse.apply","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : Semiring S\nf : RingHom R S\ng : S → R\nhf : Function.RightInverse g ⇑f\nx : HasQuotient.Quotient R (RingHom.ker f)\n⊢ Eq ((RingHom.quotientKerEquivOfRightInverse hf) x) (f.kerLift x)","decl":"@[simp]\ntheorem quotientKerEquivOfRightInverse.apply {g : S → R} (hf : Function.RightInverse g f)\n    (x : R ⧸ ker f) : quotientKerEquivOfRightInverse hf x = kerLift f x :=\n  rfl\n\n"}
{"name":"RingHom.quotientKerEquivOfRightInverse.Symm.apply","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : Semiring S\nf : RingHom R S\ng : S → R\nhf : Function.RightInverse g ⇑f\nx : S\n⊢ Eq ((RingHom.quotientKerEquivOfRightInverse hf).symm x) ((Ideal.Quotient.mk (RingHom.ker f)) (g x))","decl":"@[simp]\ntheorem quotientKerEquivOfRightInverse.Symm.apply {g : S → R} (hf : Function.RightInverse g f)\n    (x : S) : (quotientKerEquivOfRightInverse hf).symm x = Ideal.Quotient.mk (ker f) (g x) :=\n  rfl\n\n"}
{"name":"Ideal.map_quotient_self","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq (Ideal.map (Ideal.Quotient.mk I) I) Bot.bot","decl":"@[simp]\ntheorem map_quotient_self (I : Ideal R) : map (Quotient.mk I) I = ⊥ :=\n  eq_bot_iff.2 <|\n    Ideal.map_le_iff_le_comap.2 fun _ hx =>\n      (Submodule.mem_bot (R ⧸ I)).2 <| Ideal.Quotient.eq_zero_iff_mem.2 hx\n\n"}
{"name":"Ideal.mk_ker","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq (RingHom.ker (Ideal.Quotient.mk I)) I","decl":"@[simp]\ntheorem mk_ker {I : Ideal R} : ker (Quotient.mk I) = I := by\n  ext\n  rw [ker, mem_comap, Submodule.mem_bot, Quotient.eq_zero_iff_mem]\n\n"}
{"name":"Ideal.map_mk_eq_bot_of_le","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\nh : LE.le I J\n⊢ Eq (Ideal.map (Ideal.Quotient.mk J) I) Bot.bot","decl":"theorem map_mk_eq_bot_of_le {I J : Ideal R} (h : I ≤ J) : I.map (Quotient.mk J) = ⊥ := by\n  rw [map_eq_bot_iff_le_ker, mk_ker]\n  exact h\n\n"}
{"name":"Ideal.ker_quotient_lift","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : Semiring S\nI : Ideal R\nf : RingHom R S\nH : LE.le I (RingHom.ker f)\n⊢ Eq (RingHom.ker (Ideal.Quotient.lift I f H)) (Ideal.map (Ideal.Quotient.mk I) (RingHom.ker f))","decl":"theorem ker_quotient_lift {I : Ideal R} (f : R →+* S)\n    (H : I ≤ ker f) :\n    ker (Ideal.Quotient.lift I f H) = f.ker.map (Quotient.mk I) := by\n  apply Ideal.ext\n  intro x\n  constructor\n  · intro hx\n    obtain ⟨y, hy⟩ := Quotient.mk_surjective x\n    rw [mem_ker, ← hy, Ideal.Quotient.lift_mk, ← mem_ker] at hx\n    rw [← hy, mem_map_iff_of_surjective (Quotient.mk I) Quotient.mk_surjective]\n    exact ⟨y, hx, rfl⟩\n  · intro hx\n    rw [mem_map_iff_of_surjective (Quotient.mk I) Quotient.mk_surjective] at hx\n    obtain ⟨y, hy⟩ := hx\n    rw [mem_ker, ← hy.right, Ideal.Quotient.lift_mk]\n    exact hy.left\n\n"}
{"name":"Ideal.injective_lift_iff","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : CommRing R\ninst✝ : Semiring S\nI : Ideal R\nf : RingHom R S\nH : ∀ (a : R), Membership.mem I a → Eq (f a) 0\n⊢ Iff (Function.Injective ⇑(Ideal.Quotient.lift I f H)) (Eq (RingHom.ker f) I)","decl":"lemma injective_lift_iff {I : Ideal R} {f : R →+* S} (H : ∀ (a : R), a ∈ I → f a = 0) :\n    Injective (Quotient.lift I f H) ↔ ker f = I := by\n  rw [injective_iff_ker_eq_bot, ker_quotient_lift, map_eq_bot_iff_le_ker, mk_ker]\n  constructor\n  · exact fun h ↦ le_antisymm h H\n  · rintro rfl; rfl\n\n"}
{"name":"Ideal.ker_Pi_Quotient_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nι : Type u_1\nI : ι → Ideal R\n⊢ Eq (RingHom.ker (Pi.ringHom fun i => Ideal.Quotient.mk (I i))) (iInf fun i => I i)","decl":"lemma ker_Pi_Quotient_mk {ι : Type*} (I : ι → Ideal R) :\n    ker (Pi.ringHom fun i : ι ↦ Quotient.mk (I i)) = ⨅ i, I i := by\n  simp [Pi.ker_ringHom, mk_ker]\n\n"}
{"name":"Ideal.bot_quotient_isMaximal_iff","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Iff Bot.bot.IsMaximal I.IsMaximal","decl":"@[simp]\ntheorem bot_quotient_isMaximal_iff (I : Ideal R) : (⊥ : Ideal (R ⧸ I)).IsMaximal ↔ I.IsMaximal :=\n  ⟨fun hI =>\n    mk_ker (I := I) ▸\n      comap_isMaximal_of_surjective (Quotient.mk I) Quotient.mk_surjective (K := ⊥) (H := hI),\n    fun hI => by\n    letI := Quotient.field I\n    exact bot_isMaximal⟩\n\n"}
{"name":"Ideal.mem_quotient_iff_mem_sup","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\nx : R\n⊢ Iff (Membership.mem (Ideal.map (Ideal.Quotient.mk I) J) ((Ideal.Quotient.mk I) x)) (Membership.mem (Max.max J I) x)","decl":"/-- See also `Ideal.mem_quotient_iff_mem` in case `I ≤ J`. -/\n@[simp]\ntheorem mem_quotient_iff_mem_sup {I J : Ideal R} {x : R} :\n    Quotient.mk I x ∈ J.map (Quotient.mk I) ↔ x ∈ J ⊔ I := by\n  rw [← mem_comap, comap_map_of_surjective (Quotient.mk I) Quotient.mk_surjective, ←\n    ker_eq_comap_bot, mk_ker]\n\n"}
{"name":"Ideal.mem_quotient_iff_mem","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\nhIJ : LE.le I J\nx : R\n⊢ Iff (Membership.mem (Ideal.map (Ideal.Quotient.mk I) J) ((Ideal.Quotient.mk I) x)) (Membership.mem J x)","decl":"/-- See also `Ideal.mem_quotient_iff_mem_sup` if the assumption `I ≤ J` is not available. -/\ntheorem mem_quotient_iff_mem {I J : Ideal R} (hIJ : I ≤ J) {x : R} :\n    Quotient.mk I x ∈ J.map (Quotient.mk I) ↔ x ∈ J := by\n  rw [mem_quotient_iff_mem_sup, sup_eq_left.mpr hIJ]\n\n"}
{"name":"Ideal.quotientInfToPiQuotient_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nι : Type u_1\nI : ι → Ideal R\nx : R\n⊢ Eq ((Ideal.quotientInfToPiQuotient I) ((Ideal.Quotient.mk (iInf fun i => I i)) x)) fun i => (Ideal.Quotient.mk (I i)) x","decl":"lemma quotientInfToPiQuotient_mk (I : ι → Ideal R) (x : R) :\n    quotientInfToPiQuotient I (Quotient.mk _ x) = fun i : ι ↦ Quotient.mk (I i) x :=\n  rfl\n\n"}
{"name":"Ideal.quotientInfToPiQuotient_mk'","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nι : Type u_1\nI : ι → Ideal R\nx : R\ni : ι\n⊢ Eq ((Ideal.quotientInfToPiQuotient I) ((Ideal.Quotient.mk (iInf fun i => I i)) x) i) ((Ideal.Quotient.mk (I i)) x)","decl":"lemma quotientInfToPiQuotient_mk' (I : ι → Ideal R) (x : R) (i : ι) :\n    quotientInfToPiQuotient I (Quotient.mk _ x) i = Quotient.mk (I i) x :=\n  rfl\n\n"}
{"name":"Ideal.quotientInfToPiQuotient_inj","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nι : Type u_1\nI : ι → Ideal R\n⊢ Function.Injective ⇑(Ideal.quotientInfToPiQuotient I)","decl":"lemma quotientInfToPiQuotient_inj (I : ι → Ideal R) : Injective (quotientInfToPiQuotient I) := by\n  rw [quotientInfToPiQuotient, injective_lift_iff, ker_Pi_Quotient_mk]\n\n"}
{"name":"Ideal.quotientInfToPiQuotient_surj","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nι : Type u_1\ninst✝ : Finite ι\nI : ι → Ideal R\nhI : Pairwise (Function.onFun IsCoprime I)\n⊢ Function.Surjective ⇑(Ideal.quotientInfToPiQuotient I)","decl":"lemma quotientInfToPiQuotient_surj [Finite ι] {I : ι → Ideal R}\n    (hI : Pairwise (IsCoprime on I)) : Surjective (quotientInfToPiQuotient I) := by\n  classical\n  cases nonempty_fintype ι\n  intro g\n  choose f hf using fun i ↦ mk_surjective (g i)\n  have key : ∀ i, ∃ e : R, mk (I i) e = 1 ∧ ∀ j, j ≠ i → mk (I j) e = 0 := by\n    intro i\n    have hI' : ∀ j ∈ ({i} : Finset ι)ᶜ, IsCoprime (I i) (I j) := by\n      intros j hj\n      exact hI (by simpa [ne_comm, isCoprime_iff_add] using hj)\n    rcases isCoprime_iff_exists.mp (isCoprime_biInf hI') with ⟨u, hu, e, he, hue⟩\n    replace he : ∀ j, j ≠ i → e ∈ I j := by simpa using he\n    refine ⟨e, ?_, ?_⟩\n    · simp [eq_sub_of_add_eq' hue, map_sub, eq_zero_iff_mem.mpr hu]\n    · exact fun j hj ↦ eq_zero_iff_mem.mpr (he j hj)\n  choose e he using key\n  use mk _ (∑ i, f i*e i)\n  ext i\n  rw [quotientInfToPiQuotient_mk', map_sum, Fintype.sum_eq_single i]\n  · simp [(he i).1, hf]\n  · intros j hj\n    simp [(he j).2 i hj.symm]\n\n"}
{"name":"Ideal.pi_quotient_surjective","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u_2\ninst✝¹ : CommRing R\nι : Type u_3\ninst✝ : Finite ι\nI : ι → Ideal R\nhf : Pairwise fun i j => IsCoprime (I i) (I j)\nx : (i : ι) → HasQuotient.Quotient R (I i)\n⊢ Exists fun r => ∀ (i : ι), Eq ((Ideal.Quotient.mk (I i)) r) (x i)","decl":"/-- Corollary of Chinese Remainder Theorem: if `Iᵢ` are pairwise coprime ideals in a\ncommutative ring then the canonical map `R → ∏ (R ⧸ Iᵢ)` is surjective. -/\nlemma pi_quotient_surjective {R : Type*} [CommRing R] {ι : Type*} [Finite ι] {I : ι → Ideal R}\n    (hf : Pairwise fun i j ↦ IsCoprime (I i) (I j)) (x : (i : ι) → R ⧸ I i) :\n    ∃ r : R, ∀ i, r = x i := by\n  obtain ⟨y, rfl⟩ := Ideal.quotientInfToPiQuotient_surj hf x\n  obtain ⟨r, rfl⟩ := Ideal.Quotient.mk_surjective y\n  exact ⟨r, fun i ↦ rfl⟩\n\n-- variant of `IsDedekindDomain.exists_forall_sub_mem_ideal` which doesn't assume Dedekind domain!\n"}
{"name":"Ideal.exists_forall_sub_mem_ideal","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u_2\ninst✝¹ : CommRing R\nι : Type u_3\ninst✝ : Finite ι\nI : ι → Ideal R\nhI : Pairwise fun i j => IsCoprime (I i) (I j)\nx : ι → R\n⊢ Exists fun r => ∀ (i : ι), Membership.mem (I i) (HSub.hSub r (x i))","decl":"/-- Corollary of Chinese Remainder Theorem: if `Iᵢ` are pairwise coprime ideals in a\ncommutative ring then given elements `xᵢ` you can find `r` with `r - xᵢ ∈ Iᵢ` for all `i`. -/\nlemma exists_forall_sub_mem_ideal {R : Type*} [CommRing R] {ι : Type*} [Finite ι]\n    {I : ι → Ideal R} (hI : Pairwise fun i j ↦ IsCoprime (I i) (I j)) (x : ι → R) :\n    ∃ r : R, ∀ i, r - x i ∈ I i := by\n  obtain ⟨y, hy⟩ := Ideal.pi_quotient_surjective hI (fun i ↦ x i)\n  exact ⟨y, fun i ↦ (Submodule.Quotient.eq (I i)).mp <| hy i⟩\n\n"}
{"name":"Ideal.quotientInfEquivQuotientProd_fst","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\ncoprime : IsCoprime I J\nx : HasQuotient.Quotient R (Min.min I J)\n⊢ Eq ((I.quotientInfEquivQuotientProd J coprime) x).1 ((Ideal.Quotient.factor (Min.min I J) I ⋯) x)","decl":"@[simp]\ntheorem quotientInfEquivQuotientProd_fst (I J : Ideal R) (coprime : IsCoprime I J) (x : R ⧸ I ⊓ J) :\n    (quotientInfEquivQuotientProd I J coprime x).fst =\n      Ideal.Quotient.factor (I ⊓ J) I inf_le_left x :=\n  Quot.inductionOn x fun _ => rfl\n\n"}
{"name":"Ideal.quotientInfEquivQuotientProd_snd","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\ncoprime : IsCoprime I J\nx : HasQuotient.Quotient R (Min.min I J)\n⊢ Eq ((I.quotientInfEquivQuotientProd J coprime) x).2 ((Ideal.Quotient.factor (Min.min I J) J ⋯) x)","decl":"@[simp]\ntheorem quotientInfEquivQuotientProd_snd (I J : Ideal R) (coprime : IsCoprime I J) (x : R ⧸ I ⊓ J) :\n    (quotientInfEquivQuotientProd I J coprime x).snd =\n      Ideal.Quotient.factor (I ⊓ J) J inf_le_right x :=\n  Quot.inductionOn x fun _ => rfl\n\n"}
{"name":"Ideal.fst_comp_quotientInfEquivQuotientProd","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\ncoprime : IsCoprime I J\n⊢ Eq ((RingHom.fst (HasQuotient.Quotient R I) (HasQuotient.Quotient R J)).comp ↑(I.quotientInfEquivQuotientProd J coprime)) (Ideal.Quotient.factor (Min.min I J) I ⋯)","decl":"@[simp]\ntheorem fst_comp_quotientInfEquivQuotientProd (I J : Ideal R) (coprime : IsCoprime I J) :\n    (RingHom.fst _ _).comp\n        (quotientInfEquivQuotientProd I J coprime : R ⧸ I ⊓ J →+* (R ⧸ I) × R ⧸ J) =\n      Ideal.Quotient.factor (I ⊓ J) I inf_le_left := by\n  apply Quotient.ringHom_ext; ext; rfl\n\n"}
{"name":"Ideal.snd_comp_quotientInfEquivQuotientProd","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\ncoprime : IsCoprime I J\n⊢ Eq ((RingHom.snd (HasQuotient.Quotient R I) (HasQuotient.Quotient R J)).comp ↑(I.quotientInfEquivQuotientProd J coprime)) (Ideal.Quotient.factor (Min.min I J) J ⋯)","decl":"@[simp]\ntheorem snd_comp_quotientInfEquivQuotientProd (I J : Ideal R) (coprime : IsCoprime I J) :\n    (RingHom.snd _ _).comp\n        (quotientInfEquivQuotientProd I J coprime : R ⧸ I ⊓ J →+* (R ⧸ I) × R ⧸ J) =\n      Ideal.Quotient.factor (I ⊓ J) J inf_le_right := by\n  apply Quotient.ringHom_ext; ext; rfl\n\n"}
{"name":"Ideal.quotientMulEquivQuotientProd_fst","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\ncoprime : IsCoprime I J\nx : HasQuotient.Quotient R (HMul.hMul I J)\n⊢ Eq ((I.quotientMulEquivQuotientProd J coprime) x).1 ((Ideal.Quotient.factor (HMul.hMul I J) I ⋯) x)","decl":"@[simp]\ntheorem quotientMulEquivQuotientProd_fst (I J : Ideal R) (coprime : IsCoprime I J) (x : R ⧸ I * J) :\n    (quotientMulEquivQuotientProd I J coprime x).fst =\n      Ideal.Quotient.factor (I * J) I mul_le_right x :=\n  Quot.inductionOn x fun _ => rfl\n\n"}
{"name":"Ideal.quotientMulEquivQuotientProd_snd","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\ncoprime : IsCoprime I J\nx : HasQuotient.Quotient R (HMul.hMul I J)\n⊢ Eq ((I.quotientMulEquivQuotientProd J coprime) x).2 ((Ideal.Quotient.factor (HMul.hMul I J) J ⋯) x)","decl":"@[simp]\ntheorem quotientMulEquivQuotientProd_snd (I J : Ideal R) (coprime : IsCoprime I J) (x : R ⧸ I * J) :\n    (quotientMulEquivQuotientProd I J coprime x).snd =\n      Ideal.Quotient.factor (I * J) J mul_le_left x :=\n  Quot.inductionOn x fun _ => rfl\n\n"}
{"name":"Ideal.fst_comp_quotientMulEquivQuotientProd","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\ncoprime : IsCoprime I J\n⊢ Eq ((RingHom.fst (HasQuotient.Quotient R I) (HasQuotient.Quotient R J)).comp ↑(I.quotientMulEquivQuotientProd J coprime)) (Ideal.Quotient.factor (HMul.hMul I J) I ⋯)","decl":"@[simp]\ntheorem fst_comp_quotientMulEquivQuotientProd (I J : Ideal R) (coprime : IsCoprime I J) :\n    (RingHom.fst _ _).comp\n        (quotientMulEquivQuotientProd I J coprime : R ⧸ I * J →+* (R ⧸ I) × R ⧸ J) =\n      Ideal.Quotient.factor (I * J) I mul_le_right := by\n  apply Quotient.ringHom_ext; ext; rfl\n\n"}
{"name":"Ideal.snd_comp_quotientMulEquivQuotientProd","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\ncoprime : IsCoprime I J\n⊢ Eq ((RingHom.snd (HasQuotient.Quotient R I) (HasQuotient.Quotient R J)).comp ↑(I.quotientMulEquivQuotientProd J coprime)) (Ideal.Quotient.factor (HMul.hMul I J) J ⋯)","decl":"@[simp]\ntheorem snd_comp_quotientMulEquivQuotientProd (I J : Ideal R) (coprime : IsCoprime I J) :\n    (RingHom.snd _ _).comp\n        (quotientMulEquivQuotientProd I J coprime : R ⧸ I * J →+* (R ⧸ I) × R ⧸ J) =\n      Ideal.Quotient.factor (I * J) J mul_le_left := by\n  apply Quotient.ringHom_ext; ext; rfl\n\n"}
{"name":"Ideal.Quotient.isScalarTower","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nR₂ : Type u_2\nA : Type u_3\ninst✝⁶ : CommSemiring R₁\ninst✝⁵ : CommSemiring R₂\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R₁ A\ninst✝² : Algebra R₂ A\ninst✝¹ : SMul R₁ R₂\ninst✝ : IsScalarTower R₁ R₂ A\nI : Ideal A\n⊢ IsScalarTower R₁ R₂ (HasQuotient.Quotient A I)","decl":"instance Quotient.isScalarTower [SMul R₁ R₂] [IsScalarTower R₁ R₂ A] (I : Ideal A) :\n    IsScalarTower R₁ R₂ (A ⧸ I) := by infer_instance\n\n"}
{"name":"Ideal.Quotient.algHom_ext","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\ninst✝⁴ : CommSemiring R₁\ninst✝³ : CommRing A\ninst✝² : Algebra R₁ A\nI : Ideal A\nS : Type u_5\ninst✝¹ : Semiring S\ninst✝ : Algebra R₁ S\nf g : AlgHom R₁ (HasQuotient.Quotient A I) S\nh : Eq (f.comp (Ideal.Quotient.mkₐ R₁ I)) (g.comp (Ideal.Quotient.mkₐ R₁ I))\n⊢ Eq f g","decl":"theorem Quotient.algHom_ext {I : Ideal A} {S} [Semiring S] [Algebra R₁ S] ⦃f g : A ⧸ I →ₐ[R₁] S⦄\n    (h : f.comp (Quotient.mkₐ R₁ I) = g.comp (Quotient.mkₐ R₁ I)) : f = g :=\n  AlgHom.ext fun x => Quotient.inductionOn' x <| AlgHom.congr_fun h\n\n"}
{"name":"Ideal.Quotient.alg_map_eq","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\ninst✝² : CommSemiring R₁\ninst✝¹ : CommRing A\ninst✝ : Algebra R₁ A\nI : Ideal A\n⊢ Eq (algebraMap R₁ (HasQuotient.Quotient A I)) ((algebraMap A (HasQuotient.Quotient A I)).comp (algebraMap R₁ A))","decl":"theorem Quotient.alg_map_eq (I : Ideal A) :\n    algebraMap R₁ (A ⧸ I) = (algebraMap A (A ⧸ I)).comp (algebraMap R₁ A) :=\n  rfl\n\n"}
{"name":"Ideal.Quotient.mkₐ_toRingHom","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\ninst✝² : CommSemiring R₁\ninst✝¹ : CommRing A\ninst✝ : Algebra R₁ A\nI : Ideal A\n⊢ Eq (Ideal.Quotient.mkₐ R₁ I).toRingHom (Ideal.Quotient.mk I)","decl":"theorem Quotient.mkₐ_toRingHom (I : Ideal A) :\n    (Quotient.mkₐ R₁ I).toRingHom = Ideal.Quotient.mk I :=\n  rfl\n\n"}
{"name":"Ideal.Quotient.mkₐ_eq_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\ninst✝² : CommSemiring R₁\ninst✝¹ : CommRing A\ninst✝ : Algebra R₁ A\nI : Ideal A\n⊢ Eq ⇑(Ideal.Quotient.mkₐ R₁ I) ⇑(Ideal.Quotient.mk I)","decl":"@[simp]\ntheorem Quotient.mkₐ_eq_mk (I : Ideal A) : ⇑(Quotient.mkₐ R₁ I) = Quotient.mk I :=\n  rfl\n\n"}
{"name":"Ideal.Quotient.algebraMap_eq","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq (algebraMap R (HasQuotient.Quotient R I)) (Ideal.Quotient.mk I)","decl":"@[simp]\ntheorem Quotient.algebraMap_eq (I : Ideal R) : algebraMap R (R ⧸ I) = Quotient.mk I :=\n  rfl\n\n"}
{"name":"Ideal.Quotient.mk_comp_algebraMap","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\ninst✝² : CommSemiring R₁\ninst✝¹ : CommRing A\ninst✝ : Algebra R₁ A\nI : Ideal A\n⊢ Eq ((Ideal.Quotient.mk I).comp (algebraMap R₁ A)) (algebraMap R₁ (HasQuotient.Quotient A I))","decl":"@[simp]\ntheorem Quotient.mk_comp_algebraMap (I : Ideal A) :\n    (Quotient.mk I).comp (algebraMap R₁ A) = algebraMap R₁ (A ⧸ I) :=\n  rfl\n\n"}
{"name":"Ideal.Quotient.mk_algebraMap","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\ninst✝² : CommSemiring R₁\ninst✝¹ : CommRing A\ninst✝ : Algebra R₁ A\nI : Ideal A\nx : R₁\n⊢ Eq ((Ideal.Quotient.mk I) ((algebraMap R₁ A) x)) ((algebraMap R₁ (HasQuotient.Quotient A I)) x)","decl":"@[simp]\ntheorem Quotient.mk_algebraMap (I : Ideal A) (x : R₁) :\n    Quotient.mk I (algebraMap R₁ A x) = algebraMap R₁ (A ⧸ I) x :=\n  rfl\n\n"}
{"name":"Ideal.Quotient.mkₐ_surjective","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\ninst✝² : CommSemiring R₁\ninst✝¹ : CommRing A\ninst✝ : Algebra R₁ A\nI : Ideal A\n⊢ Function.Surjective ⇑(Ideal.Quotient.mkₐ R₁ I)","decl":"/-- The canonical morphism `A →ₐ[R₁] I.quotient` is surjective. -/\ntheorem Quotient.mkₐ_surjective (I : Ideal A) : Function.Surjective (Quotient.mkₐ R₁ I) :=\n  Quot.mk_surjective\n\n"}
{"name":"Ideal.Quotient.mkₐ_ker","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\ninst✝² : CommSemiring R₁\ninst✝¹ : CommRing A\ninst✝ : Algebra R₁ A\nI : Ideal A\n⊢ Eq (RingHom.ker ↑(Ideal.Quotient.mkₐ R₁ I)) I","decl":"/-- The kernel of `A →ₐ[R₁] I.quotient` is `I`. -/\n@[simp]\ntheorem Quotient.mkₐ_ker (I : Ideal A) : RingHom.ker (Quotient.mkₐ R₁ I : A →+* A ⧸ I) = I :=\n  Ideal.mk_ker\n\n"}
{"name":"Ideal.Quotient.liftₐ_apply","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁴ : CommSemiring R₁\ninst✝³ : CommRing A\ninst✝² : Algebra R₁ A\ninst✝¹ : Semiring B\ninst✝ : Algebra R₁ B\nI : Ideal A\nf : AlgHom R₁ A B\nhI : ∀ (a : A), Membership.mem I a → Eq (f a) 0\nx : HasQuotient.Quotient A I\n⊢ Eq ((Ideal.Quotient.liftₐ I f hI) x) ((Ideal.Quotient.lift I (↑f) hI) x)","decl":"@[simp]\ntheorem Quotient.liftₐ_apply (I : Ideal A) (f : A →ₐ[R₁] B) (hI : ∀ a : A, a ∈ I → f a = 0) (x) :\n    Ideal.Quotient.liftₐ I f hI x = Ideal.Quotient.lift I (f : A →+* B) hI x :=\n  rfl\n\n"}
{"name":"Ideal.Quotient.liftₐ_comp","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁴ : CommSemiring R₁\ninst✝³ : CommRing A\ninst✝² : Algebra R₁ A\ninst✝¹ : Semiring B\ninst✝ : Algebra R₁ B\nI : Ideal A\nf : AlgHom R₁ A B\nhI : ∀ (a : A), Membership.mem I a → Eq (f a) 0\n⊢ Eq ((Ideal.Quotient.liftₐ I f hI).comp (Ideal.Quotient.mkₐ R₁ I)) f","decl":"theorem Quotient.liftₐ_comp (I : Ideal A) (f : A →ₐ[R₁] B) (hI : ∀ a : A, a ∈ I → f a = 0) :\n    (Ideal.Quotient.liftₐ I f hI).comp (Ideal.Quotient.mkₐ R₁ I) = f :=\n  AlgHom.ext fun _ => (Ideal.Quotient.lift_mk I (f : A →+* B) hI :)\n\n"}
{"name":"Ideal.KerLift.map_smul","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁴ : CommSemiring R₁\ninst✝³ : CommRing A\ninst✝² : Algebra R₁ A\ninst✝¹ : Semiring B\ninst✝ : Algebra R₁ B\nf : AlgHom R₁ A B\nr : R₁\nx : HasQuotient.Quotient A (RingHom.ker f)\n⊢ Eq (f.kerLift (HSMul.hSMul r x)) (HSMul.hSMul r (f.kerLift x))","decl":"theorem KerLift.map_smul (f : A →ₐ[R₁] B) (r : R₁) (x : A ⧸ (RingHom.ker f)) :\n    f.kerLift (r • x) = r • f.kerLift x := by\n  obtain ⟨a, rfl⟩ := Quotient.mkₐ_surjective R₁ _ x\n  exact _root_.map_smul f _ _\n\n"}
{"name":"Ideal.kerLiftAlg_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁴ : CommSemiring R₁\ninst✝³ : CommRing A\ninst✝² : Algebra R₁ A\ninst✝¹ : Semiring B\ninst✝ : Algebra R₁ B\nf : AlgHom R₁ A B\na : A\n⊢ Eq ((Ideal.kerLiftAlg f) ((Ideal.Quotient.mk (RingHom.ker f)) a)) (f a)","decl":"@[simp]\ntheorem kerLiftAlg_mk (f : A →ₐ[R₁] B) (a : A) :\n    kerLiftAlg f (Quotient.mk (RingHom.ker f) a) = f a := by\n  rfl\n\n"}
{"name":"Ideal.kerLiftAlg_toRingHom","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁴ : CommSemiring R₁\ninst✝³ : CommRing A\ninst✝² : Algebra R₁ A\ninst✝¹ : Semiring B\ninst✝ : Algebra R₁ B\nf : AlgHom R₁ A B\n⊢ Eq (↑(Ideal.kerLiftAlg f)) (↑f).kerLift","decl":"@[simp]\ntheorem kerLiftAlg_toRingHom (f : A →ₐ[R₁] B) :\n    (kerLiftAlg f : A ⧸ ker f →+* B) = RingHom.kerLift (f : A →+* B) :=\n  rfl\n\n"}
{"name":"Ideal.kerLiftAlg_injective","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁴ : CommSemiring R₁\ninst✝³ : CommRing A\ninst✝² : Algebra R₁ A\ninst✝¹ : Semiring B\ninst✝ : Algebra R₁ B\nf : AlgHom R₁ A B\n⊢ Function.Injective ⇑(Ideal.kerLiftAlg f)","decl":"/-- The induced algebra morphism from the quotient by the kernel is injective. -/\ntheorem kerLiftAlg_injective (f : A →ₐ[R₁] B) : Function.Injective (kerLiftAlg f) :=\n  RingHom.kerLift_injective (R := A) (S := B) f\n\n"}
{"name":"Ideal.quotientKerAlgEquivOfRightInverse_apply","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁴ : CommSemiring R₁\ninst✝³ : CommRing A\ninst✝² : Algebra R₁ A\ninst✝¹ : Semiring B\ninst✝ : Algebra R₁ B\nf : AlgHom R₁ A B\ng : B → A\nhf : Function.RightInverse g ⇑f\na : HasQuotient.Quotient A (RingHom.ker f.toRingHom)\n⊢ Eq ((Ideal.quotientKerAlgEquivOfRightInverse hf) a) ((↑f).kerLift a)","decl":"/-- The **first isomorphism** theorem for algebras, computable version. -/\n@[simps!]\ndef quotientKerAlgEquivOfRightInverse {f : A →ₐ[R₁] B} {g : B → A}\n    (hf : Function.RightInverse g f) : (A ⧸ RingHom.ker f) ≃ₐ[R₁] B :=\n  { RingHom.quotientKerEquivOfRightInverse hf,\n    kerLiftAlg f with }\n\n"}
{"name":"Ideal.quotientKerAlgEquivOfRightInverse_symm_apply","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁴ : CommSemiring R₁\ninst✝³ : CommRing A\ninst✝² : Algebra R₁ A\ninst✝¹ : Semiring B\ninst✝ : Algebra R₁ B\nf : AlgHom R₁ A B\ng : B → A\nhf : Function.RightInverse g ⇑f\na✝ : B\n⊢ Eq ((Ideal.quotientKerAlgEquivOfRightInverse hf).symm a✝) ((Ideal.Quotient.mk (RingHom.ker ↑f)) (g a✝))","decl":"/-- The **first isomorphism** theorem for algebras, computable version. -/\n@[simps!]\ndef quotientKerAlgEquivOfRightInverse {f : A →ₐ[R₁] B} {g : B → A}\n    (hf : Function.RightInverse g f) : (A ⧸ RingHom.ker f) ≃ₐ[R₁] B :=\n  { RingHom.quotientKerEquivOfRightInverse hf,\n    kerLiftAlg f with }\n\n"}
{"name":"Ideal.quotientKerAlgEquivOfSurjective_apply","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁴ : CommSemiring R₁\ninst✝³ : CommRing A\ninst✝² : Algebra R₁ A\ninst✝¹ : Semiring B\ninst✝ : Algebra R₁ B\nf : AlgHom R₁ A B\nhf : Function.Surjective ⇑f\na : HasQuotient.Quotient A (RingHom.ker f.toRingHom)\n⊢ Eq ((Ideal.quotientKerAlgEquivOfSurjective hf) a) ((↑f).kerLift a)","decl":"/-- The **first isomorphism theorem** for algebras. -/\n@[simps!]\nnoncomputable def quotientKerAlgEquivOfSurjective {f : A →ₐ[R₁] B} (hf : Function.Surjective f) :\n    (A ⧸ (RingHom.ker f)) ≃ₐ[R₁] B :=\n  quotientKerAlgEquivOfRightInverse (Classical.choose_spec hf.hasRightInverse)\n\n"}
{"name":"Ideal.quotientKerAlgEquivOfSurjective_symm_apply","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁴ : CommSemiring R₁\ninst✝³ : CommRing A\ninst✝² : Algebra R₁ A\ninst✝¹ : Semiring B\ninst✝ : Algebra R₁ B\nf : AlgHom R₁ A B\nhf : Function.Surjective ⇑f\na✝ : B\n⊢ Eq ((Ideal.quotientKerAlgEquivOfSurjective hf).symm a✝) ((Ideal.Quotient.mk (RingHom.ker ↑f)) (Classical.choose ⋯ a✝))","decl":"/-- The **first isomorphism theorem** for algebras. -/\n@[simps!]\nnoncomputable def quotientKerAlgEquivOfSurjective {f : A →ₐ[R₁] B} (hf : Function.Surjective f) :\n    (A ⧸ (RingHom.ker f)) ≃ₐ[R₁] B :=\n  quotientKerAlgEquivOfRightInverse (Classical.choose_spec hf.hasRightInverse)\n\n"}
{"name":"Ideal.quotientMap_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nJ : Ideal R\nI : Ideal S\nf : RingHom R S\nH : LE.le J (Ideal.comap f I)\nx : R\n⊢ Eq ((Ideal.quotientMap I f H) ((Ideal.Quotient.mk J) x)) ((Ideal.Quotient.mk I) (f x))","decl":"@[simp]\ntheorem quotientMap_mk {J : Ideal R} {I : Ideal S} {f : R →+* S} {H : J ≤ I.comap f} {x : R} :\n    quotientMap I f H (Quotient.mk J x) = Quotient.mk I (f x) :=\n  Quotient.lift_mk J _ _\n\n"}
{"name":"Ideal.quotientMap_algebraMap","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\ninst✝³ : CommSemiring R₁\ninst✝² : CommRing A\ninst✝¹ : Algebra R₁ A\nS : Type v\ninst✝ : CommRing S\nJ : Ideal A\nI : Ideal S\nf : RingHom A S\nH : LE.le J (Ideal.comap f I)\nx : R₁\n⊢ Eq ((Ideal.quotientMap I f H) ((algebraMap R₁ (HasQuotient.Quotient A J)) x)) ((Ideal.Quotient.mk I) (f ((algebraMap R₁ A) x)))","decl":"@[simp]\ntheorem quotientMap_algebraMap {J : Ideal A} {I : Ideal S} {f : A →+* S} {H : J ≤ I.comap f}\n    {x : R₁} : quotientMap I f H (algebraMap R₁ (A ⧸ J) x) = Quotient.mk I (f (algebraMap _ _ x)) :=\n  Quotient.lift_mk J _ _\n\n"}
{"name":"Ideal.quotientMap_comp_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nJ : Ideal R\nI : Ideal S\nf : RingHom R S\nH : LE.le J (Ideal.comap f I)\n⊢ Eq ((Ideal.quotientMap I f H).comp (Ideal.Quotient.mk J)) ((Ideal.Quotient.mk I).comp f)","decl":"theorem quotientMap_comp_mk {J : Ideal R} {I : Ideal S} {f : R →+* S} (H : J ≤ I.comap f) :\n    (quotientMap I f H).comp (Quotient.mk J) = (Quotient.mk I).comp f :=\n  RingHom.ext fun x => by simp only [Function.comp_apply, RingHom.coe_comp, Ideal.quotientMap_mk]\n\n"}
{"name":"Ideal.ker_quotientMap_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\n⊢ Eq (RingHom.ker (Ideal.quotientMap (Ideal.map (Ideal.Quotient.mk I) J) (Ideal.Quotient.mk I) ⋯)) (Ideal.map (Ideal.Quotient.mk J) I)","decl":"lemma ker_quotientMap_mk {I J : Ideal R} :\n    RingHom.ker (quotientMap (J.map _) (Quotient.mk I) le_comap_map) = I.map (Quotient.mk J) := by\n  rw [Ideal.quotientMap, Ideal.ker_quotient_lift, ← RingHom.comap_ker, Ideal.mk_ker,\n    Ideal.comap_map_of_surjective _ Ideal.Quotient.mk_surjective,\n    ← RingHom.ker_eq_comap_bot, Ideal.mk_ker, Ideal.map_sup, Ideal.map_quotient_self, bot_sup_eq]\n\n"}
{"name":"Ideal.quotientEquiv_apply","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nI : Ideal R\nJ : Ideal S\nf : RingEquiv R S\nhIJ : Eq J (Ideal.map (↑f) I)\na✝ : HasQuotient.Quotient R I\n⊢ Eq ((I.quotientEquiv J f hIJ) a✝) ((↑↑(Ideal.quotientMap J ↑f ⋯)).toFun a✝)","decl":"/-- The ring equiv `R/I ≃+* S/J` induced by a ring equiv `f : R ≃+* S`, where `J = f(I)`. -/\n@[simps]\ndef quotientEquiv (I : Ideal R) (J : Ideal S) (f : R ≃+* S) (hIJ : J = I.map (f : R →+* S)) :\n    R ⧸ I ≃+* S ⧸ J :=\n  {\n    quotientMap J (↑f) (by\n      rw [hIJ]\n      exact le_comap_map)\n  with\n    invFun :=\n      quotientMap I (↑f.symm)\n        (by\n          rw [hIJ]\n          exact le_of_eq (map_comap_of_equiv f))\n    left_inv := by\n      rintro ⟨r⟩\n      simp only [Submodule.Quotient.quot_mk_eq_mk, Quotient.mk_eq_mk, RingHom.toFun_eq_coe,\n        quotientMap_mk, RingEquiv.coe_toRingHom, RingEquiv.symm_apply_apply]\n    right_inv := by\n      rintro ⟨s⟩\n      simp only [Submodule.Quotient.quot_mk_eq_mk, Quotient.mk_eq_mk, RingHom.toFun_eq_coe,\n        quotientMap_mk, RingEquiv.coe_toRingHom, RingEquiv.apply_symm_apply] }\n\n/- Porting note: removed simp. LHS simplified. Slightly different version of the simplified\nform closed this and was itself closed by simp -/\n"}
{"name":"Ideal.quotientEquiv_symm_apply","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nI : Ideal R\nJ : Ideal S\nf : RingEquiv R S\nhIJ : Eq J (Ideal.map (↑f) I)\na : HasQuotient.Quotient S J\n⊢ Eq ((I.quotientEquiv J f hIJ).symm a) ((Ideal.quotientMap I ↑f.symm ⋯) a)","decl":"/-- The ring equiv `R/I ≃+* S/J` induced by a ring equiv `f : R ≃+* S`, where `J = f(I)`. -/\n@[simps]\ndef quotientEquiv (I : Ideal R) (J : Ideal S) (f : R ≃+* S) (hIJ : J = I.map (f : R →+* S)) :\n    R ⧸ I ≃+* S ⧸ J :=\n  {\n    quotientMap J (↑f) (by\n      rw [hIJ]\n      exact le_comap_map)\n  with\n    invFun :=\n      quotientMap I (↑f.symm)\n        (by\n          rw [hIJ]\n          exact le_of_eq (map_comap_of_equiv f))\n    left_inv := by\n      rintro ⟨r⟩\n      simp only [Submodule.Quotient.quot_mk_eq_mk, Quotient.mk_eq_mk, RingHom.toFun_eq_coe,\n        quotientMap_mk, RingEquiv.coe_toRingHom, RingEquiv.symm_apply_apply]\n    right_inv := by\n      rintro ⟨s⟩\n      simp only [Submodule.Quotient.quot_mk_eq_mk, Quotient.mk_eq_mk, RingHom.toFun_eq_coe,\n        quotientMap_mk, RingEquiv.coe_toRingHom, RingEquiv.apply_symm_apply] }\n\n/- Porting note: removed simp. LHS simplified. Slightly different version of the simplified\nform closed this and was itself closed by simp -/\n"}
{"name":"Ideal.quotientEquiv_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nI : Ideal R\nJ : Ideal S\nf : RingEquiv R S\nhIJ : Eq J (Ideal.map (↑f) I)\nx : R\n⊢ Eq ((I.quotientEquiv J f hIJ) ((Ideal.Quotient.mk I) x)) ((Ideal.Quotient.mk J) (f x))","decl":"theorem quotientEquiv_mk (I : Ideal R) (J : Ideal S) (f : R ≃+* S) (hIJ : J = I.map (f : R →+* S))\n    (x : R) : quotientEquiv I J f hIJ (Ideal.Quotient.mk I x) = Ideal.Quotient.mk J (f x) :=\n  rfl\n\n"}
{"name":"Ideal.quotientEquiv_symm_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nI : Ideal R\nJ : Ideal S\nf : RingEquiv R S\nhIJ : Eq J (Ideal.map (↑f) I)\nx : S\n⊢ Eq ((I.quotientEquiv J f hIJ).symm ((Ideal.Quotient.mk J) x)) ((Ideal.Quotient.mk I) (f.symm x))","decl":"@[simp]\ntheorem quotientEquiv_symm_mk (I : Ideal R) (J : Ideal S) (f : R ≃+* S)\n    (hIJ : J = I.map (f : R →+* S)) (x : S) :\n    (quotientEquiv I J f hIJ).symm (Ideal.Quotient.mk J x) = Ideal.Quotient.mk I (f.symm x) :=\n  rfl\n\n"}
{"name":"Ideal.quotientMap_injective'","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nJ : Ideal R\nI : Ideal S\nf : RingHom R S\nH : LE.le J (Ideal.comap f I)\nh : LE.le (Ideal.comap f I) J\n⊢ Function.Injective ⇑(Ideal.quotientMap I f H)","decl":"/-- `H` and `h` are kept as separate hypothesis since H is used in constructing the quotient map. -/\ntheorem quotientMap_injective' {J : Ideal R} {I : Ideal S} {f : R →+* S} {H : J ≤ I.comap f}\n    (h : I.comap f ≤ J) : Function.Injective (quotientMap I f H) := by\n  refine (injective_iff_map_eq_zero (quotientMap I f H)).2 fun a ha => ?_\n  obtain ⟨r, rfl⟩ := Quotient.mk_surjective a\n  rw [quotientMap_mk, Quotient.eq_zero_iff_mem] at ha\n  exact Quotient.eq_zero_iff_mem.mpr (h ha)\n\n"}
{"name":"Ideal.quotientMap_injective","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nI : Ideal S\nf : RingHom R S\n⊢ Function.Injective ⇑(Ideal.quotientMap I f ⋯)","decl":"/-- If we take `J = I.comap f` then `quotientMap` is injective automatically. -/\ntheorem quotientMap_injective {I : Ideal S} {f : R →+* S} :\n    Function.Injective (quotientMap I f le_rfl) :=\n  quotientMap_injective' le_rfl\n\n"}
{"name":"Ideal.quotientMap_surjective","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nS : Type v\ninst✝ : CommRing S\nJ : Ideal R\nI : Ideal S\nf : RingHom R S\nH : LE.le J (Ideal.comap f I)\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective ⇑(Ideal.quotientMap I f H)","decl":"theorem quotientMap_surjective {J : Ideal R} {I : Ideal S} {f : R →+* S} {H : J ≤ I.comap f}\n    (hf : Function.Surjective f) : Function.Surjective (quotientMap I f H) := fun x =>\n  let ⟨x, hx⟩ := Quotient.mk_surjective x\n  let ⟨y, hy⟩ := hf x\n  ⟨(Quotient.mk J) y, by simp [hx, hy]⟩\n\n"}
{"name":"Ideal.comp_quotientMap_eq_of_comp_eq","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝³ : CommRing R\nS : Type v\ninst✝² : CommRing S\nR' : Type u_5\nS' : Type u_6\ninst✝¹ : CommRing R'\ninst✝ : CommRing S'\nf : RingHom R S\nf' : RingHom R' S'\ng : RingHom R R'\ng' : RingHom S S'\nhfg : Eq (f'.comp g) (g'.comp f)\nI : Ideal S'\n⊢ let leq := ⋯;\n  Eq ((Ideal.quotientMap I g' ⋯).comp (Ideal.quotientMap (Ideal.comap g' I) f ⋯)) ((Ideal.quotientMap I f' ⋯).comp (Ideal.quotientMap (Ideal.comap f' I) g leq))","decl":"/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem comp_quotientMap_eq_of_comp_eq {R' S' : Type*} [CommRing R'] [CommRing S'] {f : R →+* S}\n    {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'} (hfg : f'.comp g = g'.comp f) (I : Ideal S') :\n    -- Porting note: was losing track of I\n    let leq := le_of_eq (_root_.trans (comap_comap (I := I) f g') (hfg ▸ comap_comap (I := I) g f'))\n    (quotientMap I g' le_rfl).comp (quotientMap (I.comap g') f le_rfl) =\n    (quotientMap I f' le_rfl).comp (quotientMap (I.comap f') g leq) := by\n  refine RingHom.ext fun a => ?_\n  obtain ⟨r, rfl⟩ := Quotient.mk_surjective a\n  simp only [RingHom.comp_apply, quotientMap_mk]\n  exact (Ideal.Quotient.mk I).congr_arg (_root_.trans (g'.comp_apply f r).symm\n    (hfg ▸ f'.comp_apply g r))\n\n"}
{"name":"Ideal.quotient_map_mkₐ","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁴ : CommSemiring R₁\ninst✝³ : CommRing A\ninst✝² : Algebra R₁ A\ninst✝¹ : CommRing B\ninst✝ : Algebra R₁ B\nI : Ideal A\nJ : Ideal B\nf : AlgHom R₁ A B\nH : LE.le I (Ideal.comap f J)\nx : A\n⊢ Eq ((Ideal.quotientMapₐ J f H) ((Ideal.Quotient.mk I) x)) ((Ideal.Quotient.mkₐ R₁ J) (f x))","decl":"@[simp]\ntheorem quotient_map_mkₐ {I : Ideal A} (J : Ideal B) (f : A →ₐ[R₁] B) (H : I ≤ J.comap f) {x : A} :\n    quotientMapₐ J f H (Quotient.mk I x) = Quotient.mkₐ R₁ J (f x) :=\n  rfl\n\n"}
{"name":"Ideal.quotient_map_comp_mkₐ","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\nB : Type u_4\ninst✝⁴ : CommSemiring R₁\ninst✝³ : CommRing A\ninst✝² : Algebra R₁ A\ninst✝¹ : CommRing B\ninst✝ : Algebra R₁ B\nI : Ideal A\nJ : Ideal B\nf : AlgHom R₁ A B\nH : LE.le I (Ideal.comap f J)\n⊢ Eq ((Ideal.quotientMapₐ J f H).comp (Ideal.Quotient.mkₐ R₁ I)) ((Ideal.Quotient.mkₐ R₁ J).comp f)","decl":"theorem quotient_map_comp_mkₐ {I : Ideal A} (J : Ideal B) (f : A →ₐ[R₁] B) (H : I ≤ J.comap f) :\n    (quotientMapₐ J f H).comp (Quotient.mkₐ R₁ I) = (Quotient.mkₐ R₁ J).comp f :=\n  AlgHom.ext fun x => by simp only [quotient_map_mkₐ, Quotient.mkₐ_eq_mk, AlgHom.comp_apply]\n\n"}
{"name":"Ideal.algebraMap_quotient_injective","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝² : CommRing R\nA : Type u_3\ninst✝¹ : CommRing A\nI : Ideal A\ninst✝ : Algebra R A\n⊢ Function.Injective ⇑(algebraMap (HasQuotient.Quotient R (Ideal.comap (algebraMap R A) I)) (HasQuotient.Quotient A I))","decl":"theorem algebraMap_quotient_injective {I : Ideal A} [Algebra R A] :\n    Function.Injective (algebraMap (R ⧸ I.comap (algebraMap R A)) (A ⧸ I)) := by\n  rintro ⟨a⟩ ⟨b⟩ hab\n  replace hab := Quotient.eq.mp hab\n  rw [← RingHom.map_sub] at hab\n  exact Quotient.eq.mpr hab\n\n"}
{"name":"Ideal.quotientEquivAlgOfEq_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\ninst✝² : CommSemiring R₁\ninst✝¹ : CommRing A\ninst✝ : Algebra R₁ A\nI J : Ideal A\nh : Eq I J\nx : A\n⊢ Eq ((Ideal.quotientEquivAlgOfEq R₁ h) ((Ideal.Quotient.mk I) x)) ((Ideal.Quotient.mk J) x)","decl":"@[simp]\ntheorem quotientEquivAlgOfEq_mk {I J : Ideal A} (h : I = J) (x : A) :\n    quotientEquivAlgOfEq R₁ h (Ideal.Quotient.mk I x) = Ideal.Quotient.mk J x :=\n  rfl\n\n"}
{"name":"Ideal.quotientEquivAlgOfEq_symm","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R₁ : Type u_1\nA : Type u_3\ninst✝² : CommSemiring R₁\ninst✝¹ : CommRing A\ninst✝ : Algebra R₁ A\nI J : Ideal A\nh : Eq I J\n⊢ Eq (Ideal.quotientEquivAlgOfEq R₁ h).symm (Ideal.quotientEquivAlgOfEq R₁ ⋯)","decl":"@[simp]\ntheorem quotientEquivAlgOfEq_symm {I J : Ideal A} (h : I = J) :\n    (quotientEquivAlgOfEq R₁ h).symm = quotientEquivAlgOfEq R₁ h.symm := by\n  ext\n  rfl\n\n"}
{"name":"Ideal.comap_map_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\nh : LE.le I J\n⊢ Eq (Ideal.comap (Ideal.Quotient.mk I) (Ideal.map (Ideal.Quotient.mk I) J)) J","decl":"lemma comap_map_mk {I J : Ideal R} (h : I ≤ J) :\n    Ideal.comap (Ideal.Quotient.mk I) (Ideal.map (Ideal.Quotient.mk I) J) = J := by\n  ext; rw [← Ideal.mem_quotient_iff_mem h, Ideal.mem_comap]\n\n"}
{"name":"DoubleQuot.ker_quotLeftToQuotSup","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\n⊢ Eq (RingHom.ker (DoubleQuot.quotLeftToQuotSup I J)) (Ideal.map (Ideal.Quotient.mk I) J)","decl":"/-- The kernel of `quotLeftToQuotSup` -/\ntheorem ker_quotLeftToQuotSup : RingHom.ker (quotLeftToQuotSup I J) =\n    J.map (Ideal.Quotient.mk I) := by\n  simp only [mk_ker, sup_idem, sup_comm, quotLeftToQuotSup, Quotient.factor, ker_quotient_lift,\n    map_eq_iff_sup_ker_eq_of_surjective (Ideal.Quotient.mk I) Quotient.mk_surjective, ← sup_assoc]\n\n"}
{"name":"DoubleQuot.ker_quotQuotMk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\n⊢ Eq (RingHom.ker (DoubleQuot.quotQuotMk I J)) (Max.max I J)","decl":"/-- The kernel of `quotQuotMk` -/\ntheorem ker_quotQuotMk : RingHom.ker (quotQuotMk I J) = I ⊔ J := by\n  rw [RingHom.ker_eq_comap_bot, quotQuotMk, ← comap_comap, ← RingHom.ker, mk_ker,\n    comap_map_of_surjective (Ideal.Quotient.mk I) Ideal.Quotient.mk_surjective, ← RingHom.ker,\n    mk_ker, sup_comm]\n\n"}
{"name":"DoubleQuot.quotQuotEquivQuotSup_quotQuotMk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\nx : R\n⊢ Eq ((DoubleQuot.quotQuotEquivQuotSup I J) ((DoubleQuot.quotQuotMk I J) x)) ((Ideal.Quotient.mk (Max.max I J)) x)","decl":"@[simp]\ntheorem quotQuotEquivQuotSup_quotQuotMk (x : R) :\n    quotQuotEquivQuotSup I J (quotQuotMk I J x) = Ideal.Quotient.mk (I ⊔ J) x :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivQuotSup_symm_quotQuotMk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\nx : R\n⊢ Eq ((DoubleQuot.quotQuotEquivQuotSup I J).symm ((Ideal.Quotient.mk (Max.max I J)) x)) ((DoubleQuot.quotQuotMk I J) x)","decl":"@[simp]\ntheorem quotQuotEquivQuotSup_symm_quotQuotMk (x : R) :\n    (quotQuotEquivQuotSup I J).symm (Ideal.Quotient.mk (I ⊔ J) x) = quotQuotMk I J x :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivComm_quotQuotMk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\nx : R\n⊢ Eq ((DoubleQuot.quotQuotEquivComm I J) ((DoubleQuot.quotQuotMk I J) x)) ((DoubleQuot.quotQuotMk J I) x)","decl":"@[simp]\ntheorem quotQuotEquivComm_quotQuotMk (x : R) :\n    quotQuotEquivComm I J (quotQuotMk I J x) = quotQuotMk J I x :=\n  rfl\n\n-- Porting note: mismatched instances\n"}
{"name":"DoubleQuot.quotQuotEquivComm_comp_quotQuotMk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\n⊢ Eq ((↑(DoubleQuot.quotQuotEquivComm I J)).comp (DoubleQuot.quotQuotMk I J)) (DoubleQuot.quotQuotMk J I)","decl":"@[simp]\ntheorem quotQuotEquivComm_comp_quotQuotMk :\n    RingHom.comp (↑(quotQuotEquivComm I J)) (quotQuotMk I J) = quotQuotMk J I :=\n  RingHom.ext <| quotQuotEquivComm_quotQuotMk I J\n\n"}
{"name":"DoubleQuot.quotQuotEquivComm_symm","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\n⊢ Eq (DoubleQuot.quotQuotEquivComm I J).symm (DoubleQuot.quotQuotEquivComm J I)","decl":"@[simp]\ntheorem quotQuotEquivComm_symm : (quotQuotEquivComm I J).symm = quotQuotEquivComm J I := by\n  /-  Porting note: this proof used to just be rfl but currently rfl opens up a bottomless pit\n  of processor cycles. Synthesizing instances does not seem to be an issue.\n  -/\n  change (((quotQuotEquivQuotSup I J).trans (quotEquivOfEq (sup_comm ..))).trans\n    (quotQuotEquivQuotSup J I).symm).symm =\n      ((quotQuotEquivQuotSup J I).trans (quotEquivOfEq (sup_comm ..))).trans\n        (quotQuotEquivQuotSup I J).symm\n  ext r\n  dsimp\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivQuotOfLE_quotQuotMk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\nx : R\nh : LE.le I J\n⊢ Eq ((DoubleQuot.quotQuotEquivQuotOfLE h) ((DoubleQuot.quotQuotMk I J) x)) ((Ideal.Quotient.mk J) x)","decl":"@[simp]\ntheorem quotQuotEquivQuotOfLE_quotQuotMk (x : R) (h : I ≤ J) :\n    quotQuotEquivQuotOfLE h (quotQuotMk I J x) = (Ideal.Quotient.mk J) x :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivQuotOfLE_symm_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\nx : R\nh : LE.le I J\n⊢ Eq ((DoubleQuot.quotQuotEquivQuotOfLE h).symm ((Ideal.Quotient.mk J) x)) ((DoubleQuot.quotQuotMk I J) x)","decl":"@[simp]\ntheorem quotQuotEquivQuotOfLE_symm_mk (x : R) (h : I ≤ J) :\n    (quotQuotEquivQuotOfLE h).symm ((Ideal.Quotient.mk J) x) = quotQuotMk I J x :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivQuotOfLE_comp_quotQuotMk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\nh : LE.le I J\n⊢ Eq ((↑(DoubleQuot.quotQuotEquivQuotOfLE h)).comp (DoubleQuot.quotQuotMk I J)) (Ideal.Quotient.mk J)","decl":"theorem quotQuotEquivQuotOfLE_comp_quotQuotMk (h : I ≤ J) :\n    RingHom.comp (↑(quotQuotEquivQuotOfLE h)) (quotQuotMk I J) = (Ideal.Quotient.mk J) := by\n  ext\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivQuotOfLE_symm_comp_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\nh : LE.le I J\n⊢ Eq ((↑(DoubleQuot.quotQuotEquivQuotOfLE h).symm).comp (Ideal.Quotient.mk J)) (DoubleQuot.quotQuotMk I J)","decl":"theorem quotQuotEquivQuotOfLE_symm_comp_mk (h : I ≤ J) :\n    RingHom.comp (↑(quotQuotEquivQuotOfLE h).symm) (Ideal.Quotient.mk J) = quotQuotMk I J := by\n  ext\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivComm_mk_mk","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝ : CommRing R\nI J : Ideal R\nx : R\n⊢ Eq ((DoubleQuot.quotQuotEquivComm I J) ((Ideal.Quotient.mk (Ideal.map (Ideal.Quotient.mk I) J)) ((Ideal.Quotient.mk I) x))) ((algebraMap R (HasQuotient.Quotient (HasQuotient.Quotient R J) (Ideal.map (Ideal.Quotient.mk J) I))) x)","decl":"@[simp]\ntheorem quotQuotEquivComm_mk_mk [CommRing R] (I J : Ideal R) (x : R) :\n    quotQuotEquivComm I J (Ideal.Quotient.mk _ (Ideal.Quotient.mk _ x)) = algebraMap R _ x :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivQuotSup_quot_quot_algebraMap","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\nx : R\n⊢ Eq ((DoubleQuot.quotQuotEquivQuotSup I J) ((algebraMap R (HasQuotient.Quotient (HasQuotient.Quotient A I) (Ideal.map (Ideal.Quotient.mk I) J))) x)) ((algebraMap R (HasQuotient.Quotient A (Max.max I J))) x)","decl":"@[simp]\ntheorem quotQuotEquivQuotSup_quot_quot_algebraMap (x : R) :\n    DoubleQuot.quotQuotEquivQuotSup I J (algebraMap R _ x) = algebraMap _ _ x :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivComm_algebraMap","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type v\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\nx : R\n⊢ Eq ((DoubleQuot.quotQuotEquivComm I J) ((algebraMap R (HasQuotient.Quotient (HasQuotient.Quotient A I) (Ideal.map (Ideal.Quotient.mk I) J))) x)) ((algebraMap R (HasQuotient.Quotient (HasQuotient.Quotient A J) (Ideal.map (Ideal.Quotient.mk J) I))) x)","decl":"@[simp]\ntheorem quotQuotEquivComm_algebraMap (x : R) :\n    quotQuotEquivComm I J (algebraMap R _ x) = algebraMap _ _ x :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotLeftToQuotSupₐ_toRingHom","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq (↑(DoubleQuot.quotLeftToQuotSupₐ R I J)) (DoubleQuot.quotLeftToQuotSup I J)","decl":"@[simp]\ntheorem quotLeftToQuotSupₐ_toRingHom :\n    (quotLeftToQuotSupₐ R I J : _ →+* _) = quotLeftToQuotSup I J :=\n  rfl\n\n"}
{"name":"DoubleQuot.coe_quotLeftToQuotSupₐ","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq ⇑(DoubleQuot.quotLeftToQuotSupₐ R I J) ⇑(DoubleQuot.quotLeftToQuotSup I J)","decl":"@[simp]\ntheorem coe_quotLeftToQuotSupₐ : ⇑(quotLeftToQuotSupₐ R I J) = quotLeftToQuotSup I J :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotToQuotSupₐ_toRingHom","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq (↑(DoubleQuot.quotQuotToQuotSupₐ R I J)) (DoubleQuot.quotQuotToQuotSup I J)","decl":"@[simp]\ntheorem quotQuotToQuotSupₐ_toRingHom :\n    ((quotQuotToQuotSupₐ R I J) : _ ⧸ map (Ideal.Quotient.mkₐ R I) J →+* _) =\n      quotQuotToQuotSup I J :=\n  rfl\n\n"}
{"name":"DoubleQuot.coe_quotQuotToQuotSupₐ","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq ⇑(DoubleQuot.quotQuotToQuotSupₐ R I J) ⇑(DoubleQuot.quotQuotToQuotSup I J)","decl":"@[simp]\ntheorem coe_quotQuotToQuotSupₐ : ⇑(quotQuotToQuotSupₐ R I J) = quotQuotToQuotSup I J :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotMkₐ_toRingHom","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq (↑(DoubleQuot.quotQuotMkₐ R I J)) (DoubleQuot.quotQuotMk I J)","decl":"@[simp]\ntheorem quotQuotMkₐ_toRingHom :\n    (quotQuotMkₐ R I J : _ →+* _ ⧸ J.map (Quotient.mkₐ R I)) = quotQuotMk I J :=\n  rfl\n\n"}
{"name":"DoubleQuot.coe_quotQuotMkₐ","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq ⇑(DoubleQuot.quotQuotMkₐ R I J) ⇑(DoubleQuot.quotQuotMk I J)","decl":"@[simp]\ntheorem coe_quotQuotMkₐ : ⇑(quotQuotMkₐ R I J) = quotQuotMk I J :=\n  rfl\n\n"}
{"name":"DoubleQuot.liftSupQuotQuotMkₐ_toRingHom","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq (↑(DoubleQuot.liftSupQuotQuotMkₐ R I J)) (DoubleQuot.liftSupQuotQuotMk I J)","decl":"@[simp]\ntheorem liftSupQuotQuotMkₐ_toRingHom :\n    (liftSupQuotQuotMkₐ R I J : _ →+* _ ⧸ J.map (Quotient.mkₐ R I)) = liftSupQuotQuotMk I J :=\n  rfl\n\n"}
{"name":"DoubleQuot.coe_liftSupQuotQuotMkₐ","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq ⇑(DoubleQuot.liftSupQuotQuotMkₐ R I J) ⇑(DoubleQuot.liftSupQuotQuotMk I J)","decl":"@[simp]\ntheorem coe_liftSupQuotQuotMkₐ : ⇑(liftSupQuotQuotMkₐ R I J) = liftSupQuotQuotMk I J :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivQuotSupₐ_toRingEquiv","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq (↑(DoubleQuot.quotQuotEquivQuotSupₐ R I J)) (DoubleQuot.quotQuotEquivQuotSup I J)","decl":"@[simp]\ntheorem quotQuotEquivQuotSupₐ_toRingEquiv :\n    (quotQuotEquivQuotSupₐ R I J : _ ⧸ J.map (Quotient.mkₐ R I) ≃+* _) = quotQuotEquivQuotSup I J :=\n  rfl\n\n"}
{"name":"DoubleQuot.coe_quotQuotEquivQuotSupₐ","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq ⇑(DoubleQuot.quotQuotEquivQuotSupₐ R I J) ⇑(DoubleQuot.quotQuotEquivQuotSup I J)","decl":"@[simp]\n-- Porting note: had to add an extra coercion arrow on the right hand side.\ntheorem coe_quotQuotEquivQuotSupₐ : ⇑(quotQuotEquivQuotSupₐ R I J) = ⇑(quotQuotEquivQuotSup I J) :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivQuotSupₐ_symm_toRingEquiv","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq (↑(DoubleQuot.quotQuotEquivQuotSupₐ R I J).symm) (DoubleQuot.quotQuotEquivQuotSup I J).symm","decl":"@[simp]\ntheorem quotQuotEquivQuotSupₐ_symm_toRingEquiv :\n    ((quotQuotEquivQuotSupₐ R I J).symm : _ ≃+* _ ⧸ J.map (Quotient.mkₐ R I)) =\n      (quotQuotEquivQuotSup I J).symm :=\n  rfl\n\n"}
{"name":"DoubleQuot.coe_quotQuotEquivQuotSupₐ_symm","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq ⇑(DoubleQuot.quotQuotEquivQuotSupₐ R I J).symm ⇑(DoubleQuot.quotQuotEquivQuotSup I J).symm","decl":"@[simp]\n-- Porting note: had to add an extra coercion arrow on the right hand side.\ntheorem coe_quotQuotEquivQuotSupₐ_symm :\n    ⇑(quotQuotEquivQuotSupₐ R I J).symm = ⇑(quotQuotEquivQuotSup I J).symm :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivCommₐ_toRingEquiv","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq (↑(DoubleQuot.quotQuotEquivCommₐ R I J)) (DoubleQuot.quotQuotEquivComm I J)","decl":"@[simp]\ntheorem quotQuotEquivCommₐ_toRingEquiv :\n    (quotQuotEquivCommₐ R I J : _ ⧸ J.map (Quotient.mkₐ R I) ≃+* _ ⧸ I.map (Quotient.mkₐ R J)) =\n      quotQuotEquivComm I J :=\n  -- Porting note: should just be `rfl` but `AlgEquiv.toRingEquiv` and `AlgEquiv.ofRingEquiv`\n  -- involve repacking everything in the structure, so Lean ends up unfolding `quotQuotEquivComm`\n  -- and timing out.\n  RingEquiv.ext fun _ => rfl\n\n"}
{"name":"DoubleQuot.coe_quotQuotEquivCommₐ","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq ⇑(DoubleQuot.quotQuotEquivCommₐ R I J) ⇑(DoubleQuot.quotQuotEquivComm I J)","decl":"@[simp]\ntheorem coe_quotQuotEquivCommₐ : ⇑(quotQuotEquivCommₐ R I J) = ⇑(quotQuotEquivComm I J) :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivComm_symmₐ","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq (DoubleQuot.quotQuotEquivCommₐ R I J).symm (DoubleQuot.quotQuotEquivCommₐ R J I)","decl":"@[simp]\ntheorem quotQuotEquivComm_symmₐ : (quotQuotEquivCommₐ R I J).symm = quotQuotEquivCommₐ R J I := by\n  -- Porting note: should just be `rfl` but `AlgEquiv.toRingEquiv` and `AlgEquiv.ofRingEquiv`\n  -- involve repacking everything in the structure, so Lean ends up unfolding `quotQuotEquivComm`\n  -- and timing out.\n  ext\n  unfold quotQuotEquivCommₐ\n  congr\n\n"}
{"name":"DoubleQuot.quotQuotEquivComm_comp_quotQuotMkₐ","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\n⊢ Eq ((↑(DoubleQuot.quotQuotEquivCommₐ R I J)).comp (DoubleQuot.quotQuotMkₐ R I J)) (DoubleQuot.quotQuotMkₐ R J I)","decl":"@[simp]\ntheorem quotQuotEquivComm_comp_quotQuotMkₐ :\n    AlgHom.comp (↑(quotQuotEquivCommₐ R I J)) (quotQuotMkₐ R I J) = quotQuotMkₐ R J I :=\n  AlgHom.ext <| quotQuotEquivComm_quotQuotMk I J\n\n"}
{"name":"DoubleQuot.quotQuotEquivQuotOfLEₐ_toRingEquiv","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\nh : LE.le I J\n⊢ Eq (↑(DoubleQuot.quotQuotEquivQuotOfLEₐ R h)) (DoubleQuot.quotQuotEquivQuotOfLE h)","decl":"@[simp]\ntheorem quotQuotEquivQuotOfLEₐ_toRingEquiv (h : I ≤ J) :\n    (quotQuotEquivQuotOfLEₐ R h : _ ⧸ J.map (Quotient.mkₐ R I) ≃+* _) = quotQuotEquivQuotOfLE h :=\n  rfl\n\n"}
{"name":"DoubleQuot.coe_quotQuotEquivQuotOfLEₐ","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\nh : LE.le I J\n⊢ Eq ⇑(DoubleQuot.quotQuotEquivQuotOfLEₐ R h) ⇑(DoubleQuot.quotQuotEquivQuotOfLE h)","decl":"@[simp]\n-- Porting note: had to add an extra coercion arrow on the right hand side.\ntheorem coe_quotQuotEquivQuotOfLEₐ (h : I ≤ J) :\n    ⇑(quotQuotEquivQuotOfLEₐ R h) = ⇑(quotQuotEquivQuotOfLE h) :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivQuotOfLEₐ_symm_toRingEquiv","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\nh : LE.le I J\n⊢ Eq (↑(DoubleQuot.quotQuotEquivQuotOfLEₐ R h).symm) (DoubleQuot.quotQuotEquivQuotOfLE h).symm","decl":"@[simp]\ntheorem quotQuotEquivQuotOfLEₐ_symm_toRingEquiv (h : I ≤ J) :\n    ((quotQuotEquivQuotOfLEₐ R h).symm : _ ≃+* _ ⧸ J.map (Quotient.mkₐ R I)) =\n      (quotQuotEquivQuotOfLE h).symm :=\n  rfl\n\n"}
{"name":"DoubleQuot.coe_quotQuotEquivQuotOfLEₐ_symm","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\nh : LE.le I J\n⊢ Eq ⇑(DoubleQuot.quotQuotEquivQuotOfLEₐ R h).symm ⇑(DoubleQuot.quotQuotEquivQuotOfLE h).symm","decl":"@[simp]\n-- Porting note: had to add an extra coercion arrow on the right hand side.\ntheorem coe_quotQuotEquivQuotOfLEₐ_symm (h : I ≤ J) :\n    ⇑(quotQuotEquivQuotOfLEₐ R h).symm = ⇑(quotQuotEquivQuotOfLE h).symm :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivQuotOfLE_comp_quotQuotMkₐ","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\nh : LE.le I J\n⊢ Eq ((↑(DoubleQuot.quotQuotEquivQuotOfLEₐ R h)).comp (DoubleQuot.quotQuotMkₐ R I J)) (Ideal.Quotient.mkₐ R J)","decl":"@[simp]\ntheorem quotQuotEquivQuotOfLE_comp_quotQuotMkₐ (h : I ≤ J) :\n    AlgHom.comp (↑(quotQuotEquivQuotOfLEₐ R h)) (quotQuotMkₐ R I J) = Quotient.mkₐ R J :=\n  rfl\n\n"}
{"name":"DoubleQuot.quotQuotEquivQuotOfLE_symm_comp_mkₐ","module":"Mathlib.RingTheory.Ideal.Quotient.Operations","initialProofState":"R : Type u\nA : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI J : Ideal A\nh : LE.le I J\n⊢ Eq ((↑(DoubleQuot.quotQuotEquivQuotOfLEₐ R h).symm).comp (Ideal.Quotient.mkₐ R J)) (DoubleQuot.quotQuotMkₐ R I J)","decl":"@[simp]\ntheorem quotQuotEquivQuotOfLE_symm_comp_mkₐ (h : I ≤ J) :\n    AlgHom.comp (↑(quotQuotEquivQuotOfLEₐ R h).symm) (Quotient.mkₐ R J) = quotQuotMkₐ R I J :=\n  rfl\n\n"}
