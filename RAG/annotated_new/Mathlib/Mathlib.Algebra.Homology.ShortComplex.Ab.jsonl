{"name":"CategoryTheory.ShortComplex.ab_zero_apply","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\nx : ↑S.X₁\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom S.g) ((CategoryTheory.ConcreteCategory.hom S.f) x)) 0","decl":"@[simp]\nlemma ab_zero_apply (x : S.X₁) : S.g (S.f x) = 0 := by\n  rw [← ConcreteCategory.comp_apply, S.zero]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.abToCycles_apply_coe","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\nx : ↑S.X₁\n⊢ Eq (↑(S.abToCycles x)) ((CategoryTheory.ConcreteCategory.hom S.f) x)","decl":"/-- The canonical additive morphism `S.X₁ →+ AddMonoidHom.ker S.g` induced by `S.f`. -/\n@[simps!]\ndef abToCycles : S.X₁ →+ AddMonoidHom.ker S.g.hom :=\n    AddMonoidHom.mk' (fun x => ⟨S.f x, S.ab_zero_apply x⟩) (by aesop)\n\n"}
{"name":"CategoryTheory.ShortComplex.abLeftHomologyData_π","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\n⊢ Eq S.abLeftHomologyData.π (AddCommGrp.ofHom (QuotientAddGroup.mk' S.abToCycles.range))","decl":"/-- The explicit left homology data of a short complex of abelian group that is\ngiven by a kernel and a quotient given by the `AddMonoidHom` API. -/\n@[simps]\ndef abLeftHomologyData : S.LeftHomologyData where\n  K := AddCommGrp.of (AddMonoidHom.ker S.g.hom)\n  H := AddCommGrp.of ((AddMonoidHom.ker S.g.hom) ⧸ AddMonoidHom.range S.abToCycles)\n  i := AddCommGrp.ofHom <| (AddMonoidHom.ker S.g.hom).subtype\n  π := AddCommGrp.ofHom <| QuotientAddGroup.mk' _\n  wi := by\n    ext ⟨_, hx⟩\n    exact hx\n  hi := AddCommGrp.kernelIsLimit _\n  wπ := by\n    ext (x : S.X₁)\n    erw [QuotientAddGroup.eq_zero_iff]\n    rw [AddMonoidHom.mem_range]\n    apply exists_apply_eq_apply\n  hπ := AddCommGrp.cokernelIsColimit (AddCommGrp.ofHom S.abToCycles)\n\n"}
{"name":"CategoryTheory.ShortComplex.abLeftHomologyData_K_coe","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\n⊢ Eq (↑S.abLeftHomologyData.K) (Subtype fun x => Membership.mem (AddCommGrp.Hom.hom S.g).ker x)","decl":"/-- The explicit left homology data of a short complex of abelian group that is\ngiven by a kernel and a quotient given by the `AddMonoidHom` API. -/\n@[simps]\ndef abLeftHomologyData : S.LeftHomologyData where\n  K := AddCommGrp.of (AddMonoidHom.ker S.g.hom)\n  H := AddCommGrp.of ((AddMonoidHom.ker S.g.hom) ⧸ AddMonoidHom.range S.abToCycles)\n  i := AddCommGrp.ofHom <| (AddMonoidHom.ker S.g.hom).subtype\n  π := AddCommGrp.ofHom <| QuotientAddGroup.mk' _\n  wi := by\n    ext ⟨_, hx⟩\n    exact hx\n  hi := AddCommGrp.kernelIsLimit _\n  wπ := by\n    ext (x : S.X₁)\n    erw [QuotientAddGroup.eq_zero_iff]\n    rw [AddMonoidHom.mem_range]\n    apply exists_apply_eq_apply\n  hπ := AddCommGrp.cokernelIsColimit (AddCommGrp.ofHom S.abToCycles)\n\n"}
{"name":"CategoryTheory.ShortComplex.abLeftHomologyData_i","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\n⊢ Eq S.abLeftHomologyData.i (AddCommGrp.ofHom (AddCommGrp.Hom.hom S.g).ker.subtype)","decl":"/-- The explicit left homology data of a short complex of abelian group that is\ngiven by a kernel and a quotient given by the `AddMonoidHom` API. -/\n@[simps]\ndef abLeftHomologyData : S.LeftHomologyData where\n  K := AddCommGrp.of (AddMonoidHom.ker S.g.hom)\n  H := AddCommGrp.of ((AddMonoidHom.ker S.g.hom) ⧸ AddMonoidHom.range S.abToCycles)\n  i := AddCommGrp.ofHom <| (AddMonoidHom.ker S.g.hom).subtype\n  π := AddCommGrp.ofHom <| QuotientAddGroup.mk' _\n  wi := by\n    ext ⟨_, hx⟩\n    exact hx\n  hi := AddCommGrp.kernelIsLimit _\n  wπ := by\n    ext (x : S.X₁)\n    erw [QuotientAddGroup.eq_zero_iff]\n    rw [AddMonoidHom.mem_range]\n    apply exists_apply_eq_apply\n  hπ := AddCommGrp.cokernelIsColimit (AddCommGrp.ofHom S.abToCycles)\n\n"}
{"name":"CategoryTheory.ShortComplex.abLeftHomologyData_H_coe","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\n⊢ Eq (↑S.abLeftHomologyData.H) (HasQuotient.Quotient (Subtype fun x => Membership.mem (AddCommGrp.Hom.hom S.g).ker x) S.abToCycles.range)","decl":"/-- The explicit left homology data of a short complex of abelian group that is\ngiven by a kernel and a quotient given by the `AddMonoidHom` API. -/\n@[simps]\ndef abLeftHomologyData : S.LeftHomologyData where\n  K := AddCommGrp.of (AddMonoidHom.ker S.g.hom)\n  H := AddCommGrp.of ((AddMonoidHom.ker S.g.hom) ⧸ AddMonoidHom.range S.abToCycles)\n  i := AddCommGrp.ofHom <| (AddMonoidHom.ker S.g.hom).subtype\n  π := AddCommGrp.ofHom <| QuotientAddGroup.mk' _\n  wi := by\n    ext ⟨_, hx⟩\n    exact hx\n  hi := AddCommGrp.kernelIsLimit _\n  wπ := by\n    ext (x : S.X₁)\n    erw [QuotientAddGroup.eq_zero_iff]\n    rw [AddMonoidHom.mem_range]\n    apply exists_apply_eq_apply\n  hπ := AddCommGrp.cokernelIsColimit (AddCommGrp.ofHom S.abToCycles)\n\n"}
{"name":"CategoryTheory.ShortComplex.abLeftHomologyData_f'","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\n⊢ Eq S.abLeftHomologyData.f' (AddCommGrp.ofHom S.abToCycles)","decl":"@[simp]\nlemma abLeftHomologyData_f' : S.abLeftHomologyData.f' = AddCommGrp.ofHom S.abToCycles := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.abCyclesIso_inv_apply_iCycles","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\nx : Subtype fun x => Membership.mem (AddCommGrp.Hom.hom S.g).ker x\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom S.iCycles) ((CategoryTheory.ConcreteCategory.hom S.abCyclesIso.inv) x)) ↑x","decl":"lemma abCyclesIso_inv_apply_iCycles (x : AddMonoidHom.ker S.g.hom) :\n    S.iCycles (S.abCyclesIso.inv x) = x := by\n  dsimp only [abCyclesIso]\n  rw [← ConcreteCategory.comp_apply, S.abLeftHomologyData.cyclesIso_inv_comp_iCycles]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_surjective_abToCycles","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\n⊢ Iff S.Exact (Function.Surjective ⇑S.abToCycles)","decl":"lemma exact_iff_surjective_abToCycles :\n    S.Exact ↔ Function.Surjective S.abToCycles := by\n  rw [S.abLeftHomologyData.exact_iff_epi_f', abLeftHomologyData_f',\n    AddCommGrp.epi_iff_surjective]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.ab_exact_iff","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\n⊢ Iff S.Exact (∀ (x₂ : ↑S.X₂), Eq ((CategoryTheory.ConcreteCategory.hom S.g) x₂) 0 → Exists fun x₁ => Eq ((CategoryTheory.ConcreteCategory.hom S.f) x₁) x₂)","decl":"lemma ab_exact_iff :\n    S.Exact ↔ ∀ (x₂ : S.X₂) (_ : S.g x₂ = 0), ∃ (x₁ : S.X₁), S.f x₁ = x₂ := by\n  rw [exact_iff_surjective_abToCycles]\n  constructor\n  · intro h x₂ hx₂\n    obtain ⟨x₁, hx₁⟩ := h ⟨x₂, hx₂⟩\n    exact ⟨x₁, by simpa only [Subtype.ext_iff, abToCycles_apply_coe] using hx₁⟩\n  · rintro h ⟨x₂, hx₂⟩\n    obtain ⟨x₁, rfl⟩ := h x₂ hx₂\n    exact ⟨x₁, rfl⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.ab_exact_iff_function_exact","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\n⊢ Iff S.Exact (Function.Exact ⇑(CategoryTheory.ConcreteCategory.hom S.f) ⇑(CategoryTheory.ConcreteCategory.hom S.g))","decl":"lemma ab_exact_iff_function_exact :\n    S.Exact ↔ Function.Exact S.f S.g := by\n  rw [S.ab_exact_iff]\n  apply forall_congr'\n  intro x₂\n  constructor\n  · intro h\n    refine ⟨h, ?_⟩\n    rintro ⟨x₁, rfl⟩\n    simp only [ab_zero_apply]\n  · tauto\n\n"}
{"name":"CategoryTheory.ShortComplex.ab_exact_iff_ker_le_range","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\n⊢ Iff S.Exact (LE.le (AddCommGrp.Hom.hom S.g).ker (AddCommGrp.Hom.hom S.f).range)","decl":"lemma ab_exact_iff_ker_le_range : S.Exact ↔ S.g.hom.ker ≤ S.f.hom.range := S.ab_exact_iff\n\n"}
{"name":"CategoryTheory.ShortComplex.ab_exact_iff_range_eq_ker","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\n⊢ Iff S.Exact (Eq (AddCommGrp.Hom.hom S.f).range (AddCommGrp.Hom.hom S.g).ker)","decl":"lemma ab_exact_iff_range_eq_ker : S.Exact ↔ S.f.hom.range = S.g.hom.ker := by\n  rw [ab_exact_iff_ker_le_range]\n  constructor\n  · intro h\n    refine le_antisymm ?_ h\n    rintro _ ⟨x₁, rfl⟩\n    rw [AddMonoidHom.mem_ker, ← ConcreteCategory.comp_apply, S.zero]\n    rfl\n  · intro h\n    rw [h]\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.ab_injective_f","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\nhS : S.ShortExact\n⊢ Function.Injective ⇑(CategoryTheory.ConcreteCategory.hom S.f)","decl":"lemma ShortExact.ab_injective_f (hS : S.ShortExact) :\n    Function.Injective S.f :=\n  (AddCommGrp.mono_iff_injective _).1 hS.mono_f\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.ab_surjective_g","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\nhS : S.ShortExact\n⊢ Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom S.g)","decl":"lemma ShortExact.ab_surjective_g (hS : S.ShortExact) :\n    Function.Surjective S.g :=\n  (AddCommGrp.epi_iff_surjective _).1 hS.epi_g\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.ab_exact_iff_function_exact","module":"Mathlib.Algebra.Homology.ShortComplex.Ab","initialProofState":"S : CategoryTheory.ShortComplex Ab\n⊢ Iff S.Exact (Function.Exact ⇑(CategoryTheory.ConcreteCategory.hom S.f) ⇑(CategoryTheory.ConcreteCategory.hom S.g))","decl":"lemma ShortExact.ab_exact_iff_function_exact :\n    S.Exact ↔ Function.Exact S.f S.g := by\n  rw [ab_exact_iff_range_eq_ker, AddMonoidHom.exact_iff]\n  tauto\n\n"}
