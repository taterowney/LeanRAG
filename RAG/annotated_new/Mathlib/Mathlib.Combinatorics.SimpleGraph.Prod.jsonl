{"name":"SimpleGraph.boxProd_adj","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\nx y : Prod α β\n⊢ Iff ((G.boxProd H).Adj x y) (Or (And (G.Adj x.1 y.1) (Eq x.2 y.2)) (And (H.Adj x.2 y.2) (Eq x.1 y.1)))","decl":"@[simp]\ntheorem boxProd_adj {x y : α × β} :\n    (G □ H).Adj x y ↔ G.Adj x.1 y.1 ∧ x.2 = y.2 ∨ H.Adj x.2 y.2 ∧ x.1 = y.1 :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.boxProd_adj_left","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\na₁ : α\nb : β\na₂ : α\n⊢ Iff ((G.boxProd H).Adj { fst := a₁, snd := b } { fst := a₂, snd := b }) (G.Adj a₁ a₂)","decl":"theorem boxProd_adj_left {a₁ : α} {b : β} {a₂ : α} :\n    (G □ H).Adj (a₁, b) (a₂, b) ↔ G.Adj a₁ a₂ := by\n  simp only [boxProd_adj, and_true, SimpleGraph.irrefl, false_and, or_false]\n\n"}
{"name":"SimpleGraph.boxProd_adj_right","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\na : α\nb₁ b₂ : β\n⊢ Iff ((G.boxProd H).Adj { fst := a, snd := b₁ } { fst := a, snd := b₂ }) (H.Adj b₁ b₂)","decl":"theorem boxProd_adj_right {a : α} {b₁ b₂ : β} : (G □ H).Adj (a, b₁) (a, b₂) ↔ H.Adj b₁ b₂ := by\n  simp only [boxProd_adj, SimpleGraph.irrefl, false_and, and_true, false_or]\n\n"}
{"name":"SimpleGraph.boxProd_neighborSet","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\nx : Prod α β\n⊢ Eq ((G.boxProd H).neighborSet x) (Union.union (SProd.sprod (G.neighborSet x.1) (Singleton.singleton x.2)) (SProd.sprod (Singleton.singleton x.1) (H.neighborSet x.2)))","decl":"theorem boxProd_neighborSet (x : α × β) :\n    (G □ H).neighborSet x = G.neighborSet x.1 ×ˢ {x.2} ∪ {x.1} ×ˢ H.neighborSet x.2 := by\n  ext ⟨a', b'⟩\n  simp only [mem_neighborSet, Set.mem_union, boxProd_adj, Set.mem_prod, Set.mem_singleton_iff]\n  simp only [eq_comm, and_comm]\n\n"}
{"name":"SimpleGraph.boxProdComm_symm_apply","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\na✝ : Prod β α\n⊢ Eq ((RelIso.symm (G.boxProdComm H)) a✝) a✝.swap","decl":"/-- The box product is commutative up to isomorphism. `Equiv.prodComm` as a graph isomorphism. -/\n@[simps!]\ndef boxProdComm : G □ H ≃g H □ G := ⟨Equiv.prodComm _ _, or_comm⟩\n\n"}
{"name":"SimpleGraph.boxProdComm_apply","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\na✝ : Prod α β\n⊢ Eq ((G.boxProdComm H) a✝) a✝.swap","decl":"/-- The box product is commutative up to isomorphism. `Equiv.prodComm` as a graph isomorphism. -/\n@[simps!]\ndef boxProdComm : G □ H ≃g H □ G := ⟨Equiv.prodComm _ _, or_comm⟩\n\n"}
{"name":"SimpleGraph.boxProdAssoc_apply","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nG : SimpleGraph α\nH : SimpleGraph β\nI : SimpleGraph γ\np : Prod (Prod α β) γ\n⊢ Eq ((G.boxProdAssoc H I) p) { fst := p.1.1, snd := { fst := p.1.2, snd := p.2 } }","decl":"/-- The box product is associative up to isomorphism. `Equiv.prodAssoc` as a graph isomorphism. -/\n@[simps!]\ndef boxProdAssoc (I : SimpleGraph γ) : G □ H □ I ≃g G □ (H □ I) :=\n  ⟨Equiv.prodAssoc _ _ _, fun {x y} => by\n    simp only [boxProd_adj, Equiv.prodAssoc_apply, or_and_right, or_assoc, Prod.ext_iff,\n      and_assoc, @and_comm (x.fst.fst = _)]⟩\n\n"}
{"name":"SimpleGraph.boxProdAssoc_symm_apply","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nG : SimpleGraph α\nH : SimpleGraph β\nI : SimpleGraph γ\np : Prod α (Prod β γ)\n⊢ Eq ((RelIso.symm (G.boxProdAssoc H I)) p) { fst := { fst := p.1, snd := p.2.1 }, snd := p.2.2 }","decl":"/-- The box product is associative up to isomorphism. `Equiv.prodAssoc` as a graph isomorphism. -/\n@[simps!]\ndef boxProdAssoc (I : SimpleGraph γ) : G □ H □ I ≃g G □ (H □ I) :=\n  ⟨Equiv.prodAssoc _ _ _, fun {x y} => by\n    simp only [boxProd_adj, Equiv.prodAssoc_apply, or_and_right, or_assoc, Prod.ext_iff,\n      and_assoc, @and_comm (x.fst.fst = _)]⟩\n\n"}
{"name":"SimpleGraph.boxProdLeft_apply","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\nb : β\na : α\n⊢ Eq ((G.boxProdLeft H b) a) { fst := a, snd := b }","decl":"/-- The embedding of `G` into `G □ H` given by `b`. -/\n@[simps]\ndef boxProdLeft (b : β) : G ↪g G □ H where\n  toFun a := (a, b)\n  inj' _ _ := congr_arg Prod.fst\n  map_rel_iff' {_ _} := boxProd_adj_left\n\n"}
{"name":"SimpleGraph.boxProdRight_apply","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\na : α\nsnd : β\n⊢ Eq ((G.boxProdRight H a) snd) { fst := a, snd := snd }","decl":"/-- The embedding of `H` into `G □ H` given by `a`. -/\n@[simps]\ndef boxProdRight (a : α) : H ↪g G □ H where\n  toFun := Prod.mk a\n  inj' _ _ := congr_arg Prod.snd\n  map_rel_iff' {_ _} := boxProd_adj_right\n\n"}
{"name":"SimpleGraph.Walk.ofBoxProdLeft_boxProdLeft","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\ninst✝¹ : DecidableEq β\ninst✝ : DecidableRel G.Adj\na₁ a₂ : α\nb : β\nw : G.Walk a₁ a₂\n⊢ Eq (SimpleGraph.Walk.boxProdLeft H b w).ofBoxProdLeft w","decl":"@[simp]\ntheorem ofBoxProdLeft_boxProdLeft [DecidableEq β] [DecidableRel G.Adj] {a₁ a₂ : α} {b : β} :\n    ∀ (w : G.Walk a₁ a₂), (w.boxProdLeft H b).ofBoxProdLeft = w\n  | nil => rfl\n  | cons' x y z h w => by\n    rw [Walk.boxProdLeft, map_cons, ofBoxProdLeft, Or.by_cases, dif_pos, ← Walk.boxProdLeft]\n    · simp [ofBoxProdLeft_boxProdLeft]\n    · exact ⟨h, rfl⟩\n\n"}
{"name":"SimpleGraph.Walk.ofBoxProdLeft_boxProdRight","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nG : SimpleGraph α\ninst✝¹ : DecidableEq α\ninst✝ : DecidableRel G.Adj\na b₁ b₂ : α\nw : G.Walk b₁ b₂\n⊢ Eq (SimpleGraph.Walk.boxProdRight G a w).ofBoxProdRight w","decl":"@[simp]\ntheorem ofBoxProdLeft_boxProdRight [DecidableEq α] [DecidableRel G.Adj] {a b₁ b₂ : α} :\n    ∀ (w : G.Walk b₁ b₂), (w.boxProdRight G a).ofBoxProdRight = w\n  | nil => rfl\n  | cons' x y z h w => by\n    rw [Walk.boxProdRight, map_cons, ofBoxProdRight, Or.by_cases, dif_pos, ←\n      Walk.boxProdRight]\n    · simp [ofBoxProdLeft_boxProdRight]\n    · exact ⟨h, rfl⟩\n\n"}
{"name":"SimpleGraph.Preconnected.boxProd","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\nhG : G.Preconnected\nhH : H.Preconnected\n⊢ (G.boxProd H).Preconnected","decl":"protected theorem Preconnected.boxProd (hG : G.Preconnected) (hH : H.Preconnected) :\n    (G □ H).Preconnected := by\n  rintro x y\n  obtain ⟨w₁⟩ := hG x.1 y.1\n  obtain ⟨w₂⟩ := hH x.2 y.2\n  exact ⟨(w₁.boxProdLeft _ _).append (w₂.boxProdRight _ _)⟩\n\n"}
{"name":"SimpleGraph.Preconnected.ofBoxProdLeft","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\ninst✝ : Nonempty β\nh : (G.boxProd H).Preconnected\n⊢ G.Preconnected","decl":"protected theorem Preconnected.ofBoxProdLeft [Nonempty β] (h : (G □ H).Preconnected) :\n    G.Preconnected := by\n  classical\n  rintro a₁ a₂\n  obtain ⟨w⟩ := h (a₁, Classical.arbitrary _) (a₂, Classical.arbitrary _)\n  exact ⟨w.ofBoxProdLeft⟩\n\n"}
{"name":"SimpleGraph.Preconnected.ofBoxProdRight","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\ninst✝ : Nonempty α\nh : (G.boxProd H).Preconnected\n⊢ H.Preconnected","decl":"protected theorem Preconnected.ofBoxProdRight [Nonempty α] (h : (G □ H).Preconnected) :\n    H.Preconnected := by\n  classical\n  rintro b₁ b₂\n  obtain ⟨w⟩ := h (Classical.arbitrary _, b₁) (Classical.arbitrary _, b₂)\n  exact ⟨w.ofBoxProdRight⟩\n\n"}
{"name":"SimpleGraph.Connected.boxProd","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\nhG : G.Connected\nhH : H.Connected\n⊢ (G.boxProd H).Connected","decl":"protected theorem Connected.boxProd (hG : G.Connected) (hH : H.Connected) : (G □ H).Connected := by\n  haveI := hG.nonempty\n  haveI := hH.nonempty\n  exact ⟨hG.preconnected.boxProd hH.preconnected⟩\n\n"}
{"name":"SimpleGraph.Connected.ofBoxProdLeft","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\nh : (G.boxProd H).Connected\n⊢ G.Connected","decl":"protected theorem Connected.ofBoxProdLeft (h : (G □ H).Connected) : G.Connected := by\n  haveI := (nonempty_prod.1 h.nonempty).1\n  haveI := (nonempty_prod.1 h.nonempty).2\n  exact ⟨h.preconnected.ofBoxProdLeft⟩\n\n"}
{"name":"SimpleGraph.Connected.ofBoxProdRight","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\nh : (G.boxProd H).Connected\n⊢ H.Connected","decl":"protected theorem Connected.ofBoxProdRight (h : (G □ H).Connected) : H.Connected := by\n  haveI := (nonempty_prod.1 h.nonempty).1\n  haveI := (nonempty_prod.1 h.nonempty).2\n  exact ⟨h.preconnected.ofBoxProdRight⟩\n\n"}
{"name":"SimpleGraph.boxProd_connected","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\n⊢ Iff (G.boxProd H).Connected (And G.Connected H.Connected)","decl":"@[simp]\ntheorem boxProd_connected : (G □ H).Connected ↔ G.Connected ∧ H.Connected :=\n  ⟨fun h => ⟨h.ofBoxProdLeft, h.ofBoxProdRight⟩, fun h => h.1.boxProd h.2⟩\n\n"}
{"name":"SimpleGraph.boxProd_neighborFinset","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\nx : Prod α β\ninst✝² : Fintype ↑(G.neighborSet x.1)\ninst✝¹ : Fintype ↑(H.neighborSet x.2)\ninst✝ : Fintype ↑((G.boxProd H).neighborSet x)\n⊢ Eq ((G.boxProd H).neighborFinset x) ((SProd.sprod (G.neighborFinset x.1) (Singleton.singleton x.2)).disjUnion (SProd.sprod (Singleton.singleton x.1) (H.neighborFinset x.2)) ⋯)","decl":"theorem boxProd_neighborFinset (x : α × β)\n    [Fintype (G.neighborSet x.1)] [Fintype (H.neighborSet x.2)] [Fintype ((G □ H).neighborSet x)] :\n    (G □ H).neighborFinset x =\n      (G.neighborFinset x.1 ×ˢ {x.2}).disjUnion ({x.1} ×ˢ H.neighborFinset x.2)\n        (Finset.disjoint_product.mpr <| Or.inl <| neighborFinset_disjoint_singleton _ _) := by\n  -- swap out the fintype instance for the canonical one\n  letI : Fintype ((G □ H).neighborSet x) := SimpleGraph.boxProdFintypeNeighborSet _\n  convert_to (G □ H).neighborFinset x = _ using 2\n  exact Eq.trans (Finset.map_map _ _ _) Finset.attach_map_val\n\n"}
{"name":"SimpleGraph.boxProd_degree","module":"Mathlib.Combinatorics.SimpleGraph.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nG : SimpleGraph α\nH : SimpleGraph β\nx : Prod α β\ninst✝² : Fintype ↑(G.neighborSet x.1)\ninst✝¹ : Fintype ↑(H.neighborSet x.2)\ninst✝ : Fintype ↑((G.boxProd H).neighborSet x)\n⊢ Eq ((G.boxProd H).degree x) (HAdd.hAdd (G.degree x.1) (H.degree x.2))","decl":"theorem boxProd_degree (x : α × β)\n    [Fintype (G.neighborSet x.1)] [Fintype (H.neighborSet x.2)] [Fintype ((G □ H).neighborSet x)] :\n    (G □ H).degree x = G.degree x.1 + H.degree x.2 := by\n  rw [degree, degree, degree, boxProd_neighborFinset, Finset.card_disjUnion]\n  simp_rw [Finset.card_product, Finset.card_singleton, mul_one, one_mul]\n\n"}
