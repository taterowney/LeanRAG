{"name":"Int.le.elim","module":"Mathlib.Data.Int.Order.Basic","initialProofState":"a b : Int\nh : LE.le a b\nP : Prop\nh' : ∀ (n : Nat), Eq (HAdd.hAdd a ↑n) b → P\n⊢ P","decl":"theorem le.elim {a b : ℤ} (h : a ≤ b) {P : Prop} (h' : ∀ n : ℕ, a + ↑n = b → P) : P :=\n  Exists.elim (le.dest h) h'\n\n"}
{"name":"Int.ofNat_le_ofNat_of_le","module":"Mathlib.Data.Int.Order.Basic","initialProofState":"m n : Nat\na✝ : LE.le m n\n⊢ LE.le ↑m ↑n","decl":"alias ⟨le_of_ofNat_le_ofNat, ofNat_le_ofNat_of_le⟩ := ofNat_le\n\n"}
{"name":"Int.le_of_ofNat_le_ofNat","module":"Mathlib.Data.Int.Order.Basic","initialProofState":"m n : Nat\na✝ : LE.le ↑m ↑n\n⊢ LE.le m n","decl":"alias ⟨le_of_ofNat_le_ofNat, ofNat_le_ofNat_of_le⟩ := ofNat_le\n\n"}
{"name":"Int.lt.elim","module":"Mathlib.Data.Int.Order.Basic","initialProofState":"a b : Int\nh : LT.lt a b\nP : Prop\nh' : ∀ (n : Nat), Eq (HAdd.hAdd a ↑n.succ) b → P\n⊢ P","decl":"theorem lt.elim {a b : ℤ} (h : a < b) {P : Prop} (h' : ∀ n : ℕ, a + ↑(Nat.succ n) = b → P) : P :=\n  Exists.elim (lt.dest h) h'\n\n"}
{"name":"Int.lt_of_ofNat_lt_ofNat","module":"Mathlib.Data.Int.Order.Basic","initialProofState":"n m : Nat\na✝ : LT.lt ↑n ↑m\n⊢ LT.lt n m","decl":"alias ⟨lt_of_ofNat_lt_ofNat, ofNat_lt_ofNat_of_lt⟩ := ofNat_lt\n\n"}
{"name":"Int.ofNat_lt_ofNat_of_lt","module":"Mathlib.Data.Int.Order.Basic","initialProofState":"n m : Nat\na✝ : LT.lt n m\n⊢ LT.lt ↑n ↑m","decl":"alias ⟨lt_of_ofNat_lt_ofNat, ofNat_lt_ofNat_of_lt⟩ := ofNat_lt\n\n"}
{"name":"Int.eq_zero_or_eq_zero_of_mul_eq_zero","module":"Mathlib.Data.Int.Order.Basic","initialProofState":"a b : Int\nh : Eq (HMul.hMul a b) 0\n⊢ Or (Eq a 0) (Eq b 0)","decl":"protected theorem eq_zero_or_eq_zero_of_mul_eq_zero {a b : ℤ} (h : a * b = 0) : a = 0 ∨ b = 0 :=\n  Int.mul_eq_zero.mp h\n\n"}
{"name":"Int.nonneg_or_nonpos_of_mul_nonneg","module":"Mathlib.Data.Int.Order.Basic","initialProofState":"a b : Int\na✝ : LE.le 0 (HMul.hMul a b)\n⊢ Or (And (LE.le 0 a) (LE.le 0 b)) (And (LE.le a 0) (LE.le b 0))","decl":"theorem nonneg_or_nonpos_of_mul_nonneg {a b : ℤ} : 0 ≤ a * b → 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 := by\n  intro h\n  by_cases ha : 0 ≤ a <;> by_cases hb : 0 ≤ b\n  · exact .inl ⟨ha, hb⟩\n  · refine .inr ⟨?_, le_of_not_le hb⟩\n    obtain _ | _ := Int.mul_eq_zero.mp <|\n      Int.le_antisymm (Int.mul_nonpos_of_nonneg_of_nonpos ha <| le_of_not_le hb) h\n    all_goals omega\n  · refine .inr ⟨le_of_not_le ha, ?_⟩\n    obtain _ | _ := Int.mul_eq_zero.mp <|\n      Int.le_antisymm (Int.mul_nonpos_of_nonpos_of_nonneg (le_of_not_le ha) hb) h\n    all_goals omega\n  · exact .inr ⟨le_of_not_ge ha, le_of_not_ge hb⟩\n\n"}
{"name":"Int.mul_nonneg_of_nonneg_or_nonpos","module":"Mathlib.Data.Int.Order.Basic","initialProofState":"a b : Int\na✝ : Or (And (LE.le 0 a) (LE.le 0 b)) (And (LE.le a 0) (LE.le b 0))\n⊢ LE.le 0 (HMul.hMul a b)","decl":"theorem mul_nonneg_of_nonneg_or_nonpos {a b : ℤ} : 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 → 0 ≤ a * b\n  | .inl ⟨ha, hb⟩ => Int.mul_nonneg ha hb\n  | .inr ⟨ha, hb⟩ => Int.mul_nonneg_of_nonpos_of_nonpos ha hb\n\n"}
{"name":"Int.mul_nonneg_iff","module":"Mathlib.Data.Int.Order.Basic","initialProofState":"a b : Int\n⊢ Iff (LE.le 0 (HMul.hMul a b)) (Or (And (LE.le 0 a) (LE.le 0 b)) (And (LE.le a 0) (LE.le b 0)))","decl":"protected theorem mul_nonneg_iff {a b : ℤ} : 0 ≤ a * b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 :=\n  ⟨nonneg_or_nonpos_of_mul_nonneg, mul_nonneg_of_nonneg_or_nonpos⟩\n"}
