{"name":"ascPochhammer_zero","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝ : Semiring S\n⊢ Eq (ascPochhammer S 0) 1","decl":"@[simp]\ntheorem ascPochhammer_zero : ascPochhammer S 0 = 1 :=\n  rfl\n\n"}
{"name":"ascPochhammer_one","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝ : Semiring S\n⊢ Eq (ascPochhammer S 1) Polynomial.X","decl":"@[simp]\ntheorem ascPochhammer_one : ascPochhammer S 1 = X := by simp [ascPochhammer]\n\n"}
{"name":"ascPochhammer_succ_left","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝ : Semiring S\nn : Nat\n⊢ Eq (ascPochhammer S (HAdd.hAdd n 1)) (HMul.hMul Polynomial.X ((ascPochhammer S n).comp (HAdd.hAdd Polynomial.X 1)))","decl":"theorem ascPochhammer_succ_left (n : ℕ) :\n    ascPochhammer S (n + 1) = X * (ascPochhammer S n).comp (X + 1) := by\n  rw [ascPochhammer]\n\n"}
{"name":"monic_ascPochhammer","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝² : Semiring S\nn : Nat\ninst✝¹ : Nontrivial S\ninst✝ : NoZeroDivisors S\n⊢ (ascPochhammer S n).Monic","decl":"theorem monic_ascPochhammer (n : ℕ) [Nontrivial S] [NoZeroDivisors S] :\n    Monic <| ascPochhammer S n := by\n  induction' n with n hn\n  · simp\n  · have : leadingCoeff (X + 1 : S[X]) = 1 := leadingCoeff_X_add_C 1\n    rw [ascPochhammer_succ_left, Monic.def, leadingCoeff_mul,\n      leadingCoeff_comp (ne_zero_of_eq_one <| natDegree_X_add_C 1 : natDegree (X + 1) ≠ 0), hn,\n      monic_X, one_mul, one_mul, this, one_pow]\n\n"}
{"name":"ascPochhammer_map","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝¹ : Semiring S\nT : Type v\ninst✝ : Semiring T\nf : RingHom S T\nn : Nat\n⊢ Eq (Polynomial.map f (ascPochhammer S n)) (ascPochhammer T n)","decl":"@[simp]\ntheorem ascPochhammer_map (f : S →+* T) (n : ℕ) :\n    (ascPochhammer S n).map f = ascPochhammer T n := by\n  induction n with\n  | zero => simp\n  | succ n ih => simp [ih, ascPochhammer_succ_left, map_comp]\n\n"}
{"name":"ascPochhammer_eval₂","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝¹ : Semiring S\nT : Type v\ninst✝ : Semiring T\nf : RingHom S T\nn : Nat\nt : T\n⊢ Eq (Polynomial.eval t (ascPochhammer T n)) (Polynomial.eval₂ f t (ascPochhammer S n))","decl":"theorem ascPochhammer_eval₂ (f : S →+* T) (n : ℕ) (t : T) :\n    (ascPochhammer T n).eval t = (ascPochhammer S n).eval₂ f t := by\n  rw [← ascPochhammer_map f]\n  exact eval_map f t\n\n"}
{"name":"ascPochhammer_eval_comp","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝² : Semiring S\nR : Type u_1\ninst✝¹ : CommSemiring R\nn : Nat\np : Polynomial R\ninst✝ : Algebra R S\nx : S\n⊢ Eq (Polynomial.eval x ((ascPochhammer S n).comp (Polynomial.map (algebraMap R S) p))) (Polynomial.eval (Polynomial.eval₂ (algebraMap R S) x p) (ascPochhammer S n))","decl":"theorem ascPochhammer_eval_comp {R : Type*} [CommSemiring R] (n : ℕ) (p : R[X]) [Algebra R S]\n    (x : S) : ((ascPochhammer S n).comp (p.map (algebraMap R S))).eval x =\n    (ascPochhammer S n).eval (p.eval₂ (algebraMap R S) x) := by\n  rw [ascPochhammer_eval₂ (algebraMap R S), ← eval₂_comp', ← ascPochhammer_map (algebraMap R S),\n    ← map_comp, eval_map]\n\n"}
{"name":"ascPochhammer_eval_cast","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝ : Semiring S\nn k : Nat\n⊢ Eq (↑(Polynomial.eval k (ascPochhammer Nat n))) (Polynomial.eval (↑k) (ascPochhammer S n))","decl":"@[simp, norm_cast]\ntheorem ascPochhammer_eval_cast (n k : ℕ) :\n    (((ascPochhammer ℕ n).eval k : ℕ) : S) = ((ascPochhammer S n).eval k : S) := by\n  rw [← ascPochhammer_map (algebraMap ℕ S), eval_map, ← eq_natCast (algebraMap ℕ S),\n      eval₂_at_natCast,Nat.cast_id]\n\n"}
{"name":"ascPochhammer_eval_zero","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝ : Semiring S\nn : Nat\n⊢ Eq (Polynomial.eval 0 (ascPochhammer S n)) (ite (Eq n 0) 1 0)","decl":"theorem ascPochhammer_eval_zero {n : ℕ} : (ascPochhammer S n).eval 0 = if n = 0 then 1 else 0 := by\n  cases n\n  · simp\n  · simp [X_mul, Nat.succ_ne_zero, ascPochhammer_succ_left]\n\n"}
{"name":"ascPochhammer_zero_eval_zero","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝ : Semiring S\n⊢ Eq (Polynomial.eval 0 (ascPochhammer S 0)) 1","decl":"theorem ascPochhammer_zero_eval_zero : (ascPochhammer S 0).eval 0 = 1 := by simp\n\n"}
{"name":"ascPochhammer_ne_zero_eval_zero","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝ : Semiring S\nn : Nat\nh : Ne n 0\n⊢ Eq (Polynomial.eval 0 (ascPochhammer S n)) 0","decl":"@[simp]\ntheorem ascPochhammer_ne_zero_eval_zero {n : ℕ} (h : n ≠ 0) : (ascPochhammer S n).eval 0 = 0 := by\n  simp [ascPochhammer_eval_zero, h]\n\n"}
{"name":"ascPochhammer_succ_right","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝ : Semiring S\nn : Nat\n⊢ Eq (ascPochhammer S (HAdd.hAdd n 1)) (HMul.hMul (ascPochhammer S n) (HAdd.hAdd Polynomial.X ↑n))","decl":"theorem ascPochhammer_succ_right (n : ℕ) :\n    ascPochhammer S (n + 1) = ascPochhammer S n * (X + (n : S[X])) := by\n  suffices h : ascPochhammer ℕ (n + 1) = ascPochhammer ℕ n * (X + (n : ℕ[X])) by\n    apply_fun Polynomial.map (algebraMap ℕ S) at h\n    simpa only [ascPochhammer_map, Polynomial.map_mul, Polynomial.map_add, map_X,\n      Polynomial.map_natCast] using h\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    conv_lhs =>\n      rw [ascPochhammer_succ_left, ih, mul_comp, ← mul_assoc, ← ascPochhammer_succ_left, add_comp,\n          X_comp, natCast_comp, add_assoc, add_comm (1 : ℕ[X]), ← Nat.cast_succ]\n\n"}
{"name":"ascPochhammer_succ_eval","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u_1\ninst✝ : Semiring S\nn : Nat\nk : S\n⊢ Eq (Polynomial.eval k (ascPochhammer S (HAdd.hAdd n 1))) (HMul.hMul (Polynomial.eval k (ascPochhammer S n)) (HAdd.hAdd k ↑n))","decl":"theorem ascPochhammer_succ_eval {S : Type*} [Semiring S] (n : ℕ) (k : S) :\n    (ascPochhammer S (n + 1)).eval k = (ascPochhammer S n).eval k * (k + n) := by\n  rw [ascPochhammer_succ_right, mul_add, eval_add, eval_mul_X, ← Nat.cast_comm, ← C_eq_natCast,\n    eval_C_mul, Nat.cast_comm, ← mul_add]\n\n"}
{"name":"ascPochhammer_succ_comp_X_add_one","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝ : Semiring S\nn : Nat\n⊢ Eq ((ascPochhammer S (HAdd.hAdd n 1)).comp (HAdd.hAdd Polynomial.X 1)) (HAdd.hAdd (ascPochhammer S (HAdd.hAdd n 1)) (HSMul.hSMul (HAdd.hAdd n 1) ((ascPochhammer S n).comp (HAdd.hAdd Polynomial.X 1))))","decl":"theorem ascPochhammer_succ_comp_X_add_one (n : ℕ) :\n    (ascPochhammer S (n + 1)).comp (X + 1) =\n      ascPochhammer S (n + 1) + (n + 1) • (ascPochhammer S n).comp (X + 1) := by\n  suffices (ascPochhammer ℕ (n + 1)).comp (X + 1) =\n      ascPochhammer ℕ (n + 1) + (n + 1) * (ascPochhammer ℕ n).comp (X + 1)\n    by simpa [map_comp] using congr_arg (Polynomial.map (Nat.castRingHom S)) this\n  nth_rw 2 [ascPochhammer_succ_left]\n  rw [← add_mul, ascPochhammer_succ_right ℕ n, mul_comp, mul_comm, add_comp, X_comp, natCast_comp,\n    add_comm, ← add_assoc]\n  ring\n\n"}
{"name":"ascPochhammer_mul","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝ : Semiring S\nn m : Nat\n⊢ Eq (HMul.hMul (ascPochhammer S n) ((ascPochhammer S m).comp (HAdd.hAdd Polynomial.X ↑n))) (ascPochhammer S (HAdd.hAdd n m))","decl":"theorem ascPochhammer_mul (n m : ℕ) :\n    ascPochhammer S n * (ascPochhammer S m).comp (X + (n : S[X])) = ascPochhammer S (n + m) := by\n  induction' m with m ih\n  · simp\n  · rw [ascPochhammer_succ_right, Polynomial.mul_X_add_natCast_comp, ← mul_assoc, ih,\n      ← add_assoc, ascPochhammer_succ_right, Nat.cast_add, add_assoc]\n\n"}
{"name":"ascPochhammer_nat_eq_ascFactorial","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"n k : Nat\n⊢ Eq (Polynomial.eval n (ascPochhammer Nat k)) (n.ascFactorial k)","decl":"theorem ascPochhammer_nat_eq_ascFactorial (n : ℕ) :\n    ∀ k, (ascPochhammer ℕ k).eval n = n.ascFactorial k\n  | 0 => by rw [ascPochhammer_zero, eval_one, Nat.ascFactorial_zero]\n  | t + 1 => by\n    rw [ascPochhammer_succ_right, eval_mul, ascPochhammer_nat_eq_ascFactorial n t, eval_add, eval_X,\n      eval_natCast, Nat.cast_id, Nat.ascFactorial_succ, mul_comm]\n\n"}
{"name":"ascPochhammer_nat_eq_natCast_ascFactorial","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u_1\ninst✝ : Semiring S\nn k : Nat\n⊢ Eq (Polynomial.eval (↑n) (ascPochhammer S k)) ↑(n.ascFactorial k)","decl":"theorem ascPochhammer_nat_eq_natCast_ascFactorial (S : Type*) [Semiring S] (n k : ℕ) :\n    (ascPochhammer S k).eval (n : S) = n.ascFactorial k := by\n  norm_cast\n  rw [ascPochhammer_nat_eq_ascFactorial]\n\n"}
{"name":"ascPochhammer_nat_eq_descFactorial","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"a b : Nat\n⊢ Eq (Polynomial.eval a (ascPochhammer Nat b)) ((HSub.hSub (HAdd.hAdd a b) 1).descFactorial b)","decl":"theorem ascPochhammer_nat_eq_descFactorial (a b : ℕ) :\n    (ascPochhammer ℕ b).eval a = (a + b - 1).descFactorial b := by\n  rw [ascPochhammer_nat_eq_ascFactorial, Nat.add_descFactorial_eq_ascFactorial']\n\n"}
{"name":"ascPochhammer_nat_eq_natCast_descFactorial","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u_1\ninst✝ : Semiring S\na b : Nat\n⊢ Eq (Polynomial.eval (↑a) (ascPochhammer S b)) ↑((HSub.hSub (HAdd.hAdd a b) 1).descFactorial b)","decl":"theorem ascPochhammer_nat_eq_natCast_descFactorial (S : Type*) [Semiring S] (a b : ℕ) :\n    (ascPochhammer S b).eval (a : S) = (a + b - 1).descFactorial b := by\n  norm_cast\n  rw [ascPochhammer_nat_eq_descFactorial]\n\n"}
{"name":"ascPochhammer_natDegree","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u\ninst✝² : Semiring S\nn : Nat\ninst✝¹ : NoZeroDivisors S\ninst✝ : Nontrivial S\n⊢ Eq (ascPochhammer S n).natDegree n","decl":"@[simp]\ntheorem ascPochhammer_natDegree (n : ℕ) [NoZeroDivisors S] [Nontrivial S] :\n    (ascPochhammer S n).natDegree = n := by\n  induction' n with n hn\n  · simp\n  · have : natDegree (X + (n : S[X])) = 1 := natDegree_X_add_C (n : S)\n    rw [ascPochhammer_succ_right,\n        natDegree_mul _ (ne_zero_of_natDegree_gt <| this.symm ▸ Nat.zero_lt_one), hn, this]\n    cases n\n    · simp\n    · refine ne_zero_of_natDegree_gt <| hn.symm ▸ Nat.add_one_pos _\n\n"}
{"name":"ascPochhammer_pos","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u_1\ninst✝ : StrictOrderedSemiring S\nn : Nat\ns : S\nh : LT.lt 0 s\n⊢ LT.lt 0 (Polynomial.eval s (ascPochhammer S n))","decl":"theorem ascPochhammer_pos (n : ℕ) (s : S) (h : 0 < s) : 0 < (ascPochhammer S n).eval s := by\n  induction n with\n  | zero =>\n    simp only [ascPochhammer_zero, eval_one]\n    exact zero_lt_one\n  | succ n ih =>\n    rw [ascPochhammer_succ_right, mul_add, eval_add, ← Nat.cast_comm, eval_natCast_mul, eval_mul_X,\n      Nat.cast_comm, ← mul_add]\n    exact mul_pos ih (lt_of_lt_of_le h (le_add_of_nonneg_right (Nat.cast_nonneg n)))\n\n"}
{"name":"ascPochhammer_eval_one","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u_2\ninst✝ : Semiring S\nn : Nat\n⊢ Eq (Polynomial.eval 1 (ascPochhammer S n)) ↑n.factorial","decl":"@[simp]\ntheorem ascPochhammer_eval_one (S : Type*) [Semiring S] (n : ℕ) :\n    (ascPochhammer S n).eval (1 : S) = (n ! : S) := by\n  rw_mod_cast [ascPochhammer_nat_eq_ascFactorial, Nat.one_ascFactorial]\n\n"}
{"name":"factorial_mul_ascPochhammer","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u_2\ninst✝ : Semiring S\nr n : Nat\n⊢ Eq (HMul.hMul (↑r.factorial) (Polynomial.eval (HAdd.hAdd (↑r) 1) (ascPochhammer S n))) ↑(HAdd.hAdd r n).factorial","decl":"theorem factorial_mul_ascPochhammer (S : Type*) [Semiring S] (r n : ℕ) :\n    (r ! : S) * (ascPochhammer S n).eval (r + 1 : S) = (r + n)! := by\n  rw_mod_cast [ascPochhammer_nat_eq_ascFactorial, Nat.factorial_mul_ascFactorial]\n\n"}
{"name":"ascPochhammer_nat_eval_succ","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"r n : Nat\n⊢ Eq (HMul.hMul n (Polynomial.eval (HAdd.hAdd n 1) (ascPochhammer Nat r))) (HMul.hMul (HAdd.hAdd n r) (Polynomial.eval n (ascPochhammer Nat r)))","decl":"theorem ascPochhammer_nat_eval_succ (r : ℕ) :\n    ∀ n : ℕ, n * (ascPochhammer ℕ r).eval (n + 1) = (n + r) * (ascPochhammer ℕ r).eval n\n  | 0 => by\n    by_cases h : r = 0\n    · simp only [h, zero_mul, zero_add]\n    · simp only [ascPochhammer_eval_zero, zero_mul, if_neg h, mul_zero]\n  | k + 1 => by simp only [ascPochhammer_nat_eq_ascFactorial, Nat.succ_ascFactorial, add_right_comm]\n\n"}
{"name":"ascPochhammer_eval_succ","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u_1\ninst✝ : Semiring S\nr n : Nat\n⊢ Eq (HMul.hMul (↑n) (Polynomial.eval (HAdd.hAdd (↑n) 1) (ascPochhammer S r))) (HMul.hMul (HAdd.hAdd ↑n ↑r) (Polynomial.eval (↑n) (ascPochhammer S r)))","decl":"theorem ascPochhammer_eval_succ (r n : ℕ) :\n    (n : S) * (ascPochhammer S r).eval (n + 1 : S) =\n    (n + r) * (ascPochhammer S r).eval (n : S) :=\n  mod_cast congr_arg Nat.cast (ascPochhammer_nat_eval_succ r n)\n\n"}
{"name":"descPochhammer_zero","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Eq (descPochhammer R 0) 1","decl":"@[simp]\ntheorem descPochhammer_zero : descPochhammer R 0 = 1 :=\n  rfl\n\n"}
{"name":"descPochhammer_one","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Eq (descPochhammer R 1) Polynomial.X","decl":"@[simp]\ntheorem descPochhammer_one : descPochhammer R 1 = X := by simp [descPochhammer]\n\n"}
{"name":"descPochhammer_succ_left","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\nn : Nat\n⊢ Eq (descPochhammer R (HAdd.hAdd n 1)) (HMul.hMul Polynomial.X ((descPochhammer R n).comp (HSub.hSub Polynomial.X 1)))","decl":"theorem descPochhammer_succ_left (n : ℕ) :\n    descPochhammer R (n + 1) = X * (descPochhammer R n).comp (X - 1) := by\n  rw [descPochhammer]\n\n"}
{"name":"monic_descPochhammer","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝² : Ring R\nn : Nat\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroDivisors R\n⊢ (descPochhammer R n).Monic","decl":"theorem monic_descPochhammer (n : ℕ) [Nontrivial R] [NoZeroDivisors R] :\n    Monic <| descPochhammer R n := by\n  induction' n with n hn\n  · simp\n  · have h : leadingCoeff (X - 1 : R[X]) = 1 := leadingCoeff_X_sub_C 1\n    have : natDegree (X - (1 : R[X])) ≠ 0 := ne_zero_of_eq_one <| natDegree_X_sub_C (1 : R)\n    rw [descPochhammer_succ_left, Monic.def, leadingCoeff_mul, leadingCoeff_comp this, hn, monic_X,\n        one_mul, one_mul, h, one_pow]\n\n"}
{"name":"descPochhammer_map","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝¹ : Ring R\nT : Type v\ninst✝ : Ring T\nf : RingHom R T\nn : Nat\n⊢ Eq (Polynomial.map f (descPochhammer R n)) (descPochhammer T n)","decl":"@[simp]\ntheorem descPochhammer_map (f : R →+* T) (n : ℕ) :\n    (descPochhammer R n).map f = descPochhammer T n := by\n  induction n with\n  | zero => simp\n  | succ n ih => simp [ih, descPochhammer_succ_left, map_comp]\n"}
{"name":"descPochhammer_eval_cast","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\nn : Nat\nk : Int\n⊢ Eq (↑(Polynomial.eval k (descPochhammer Int n))) (Polynomial.eval (↑k) (descPochhammer R n))","decl":"@[simp, norm_cast]\ntheorem descPochhammer_eval_cast (n : ℕ) (k : ℤ) :\n    (((descPochhammer ℤ n).eval k : ℤ) : R) = ((descPochhammer R n).eval k : R) := by\n  rw [← descPochhammer_map (algebraMap ℤ R), eval_map, ← eq_intCast (algebraMap ℤ R)]\n  simp only [algebraMap_int_eq, eq_intCast, eval₂_at_intCast, Nat.cast_id, eq_natCast, Int.cast_id]\n\n"}
{"name":"descPochhammer_eval_zero","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\nn : Nat\n⊢ Eq (Polynomial.eval 0 (descPochhammer R n)) (ite (Eq n 0) 1 0)","decl":"theorem descPochhammer_eval_zero {n : ℕ} :\n    (descPochhammer R n).eval 0 = if n = 0 then 1 else 0 := by\n  cases n\n  · simp\n  · simp [X_mul, Nat.succ_ne_zero, descPochhammer_succ_left]\n\n"}
{"name":"descPochhammer_zero_eval_zero","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ Eq (Polynomial.eval 0 (descPochhammer R 0)) 1","decl":"theorem descPochhammer_zero_eval_zero : (descPochhammer R 0).eval 0 = 1 := by simp\n\n"}
{"name":"descPochhammer_ne_zero_eval_zero","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\nn : Nat\nh : Ne n 0\n⊢ Eq (Polynomial.eval 0 (descPochhammer R n)) 0","decl":"@[simp]\ntheorem descPochhammer_ne_zero_eval_zero {n : ℕ} (h : n ≠ 0) : (descPochhammer R n).eval 0 = 0 := by\n  simp [descPochhammer_eval_zero, h]\n\n"}
{"name":"descPochhammer_succ_right","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\nn : Nat\n⊢ Eq (descPochhammer R (HAdd.hAdd n 1)) (HMul.hMul (descPochhammer R n) (HSub.hSub Polynomial.X ↑n))","decl":"theorem descPochhammer_succ_right (n : ℕ) :\n    descPochhammer R (n + 1) = descPochhammer R n * (X - (n : R[X])) := by\n  suffices h : descPochhammer ℤ (n + 1) = descPochhammer ℤ n * (X - (n : ℤ[X])) by\n    apply_fun Polynomial.map (algebraMap ℤ R) at h\n    simpa [descPochhammer_map, Polynomial.map_mul, Polynomial.map_add, map_X,\n      Polynomial.map_intCast] using h\n  induction n with\n  | zero => simp [descPochhammer]\n  | succ n ih =>\n    conv_lhs =>\n      rw [descPochhammer_succ_left, ih, mul_comp, ← mul_assoc, ← descPochhammer_succ_left, sub_comp,\n          X_comp, natCast_comp]\n    rw [Nat.cast_add, Nat.cast_one, sub_add_eq_sub_sub_swap]\n\n"}
{"name":"descPochhammer_natDegree","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝² : Ring R\nn : Nat\ninst✝¹ : NoZeroDivisors R\ninst✝ : Nontrivial R\n⊢ Eq (descPochhammer R n).natDegree n","decl":"@[simp]\ntheorem descPochhammer_natDegree (n : ℕ) [NoZeroDivisors R] [Nontrivial R] :\n    (descPochhammer R n).natDegree = n := by\n  induction' n with n hn\n  · simp\n  · have : natDegree (X - (n : R[X])) = 1 := natDegree_X_sub_C (n : R)\n    rw [descPochhammer_succ_right,\n        natDegree_mul _ (ne_zero_of_natDegree_gt <| this.symm ▸ Nat.zero_lt_one), hn, this]\n    cases n\n    · simp\n    · refine ne_zero_of_natDegree_gt <| hn.symm ▸ Nat.add_one_pos _\n\n"}
{"name":"descPochhammer_succ_eval","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"S : Type u_1\ninst✝ : Ring S\nn : Nat\nk : S\n⊢ Eq (Polynomial.eval k (descPochhammer S (HAdd.hAdd n 1))) (HMul.hMul (Polynomial.eval k (descPochhammer S n)) (HSub.hSub k ↑n))","decl":"theorem descPochhammer_succ_eval {S : Type*} [Ring S] (n : ℕ) (k : S) :\n    (descPochhammer S (n + 1)).eval k = (descPochhammer S n).eval k * (k - n) := by\n  rw [descPochhammer_succ_right, mul_sub, eval_sub, eval_mul_X, ← Nat.cast_comm, ← C_eq_natCast,\n    eval_C_mul, Nat.cast_comm, ← mul_sub]\n\n"}
{"name":"descPochhammer_succ_comp_X_sub_one","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\nn : Nat\n⊢ Eq ((descPochhammer R (HAdd.hAdd n 1)).comp (HSub.hSub Polynomial.X 1)) (HSub.hSub (descPochhammer R (HAdd.hAdd n 1)) (HSMul.hSMul (HAdd.hAdd (↑n) 1) ((descPochhammer R n).comp (HSub.hSub Polynomial.X 1))))","decl":"theorem descPochhammer_succ_comp_X_sub_one (n : ℕ) :\n    (descPochhammer R (n + 1)).comp (X - 1) =\n      descPochhammer R (n + 1) - (n + (1 : R[X])) • (descPochhammer R n).comp (X - 1) := by\n  suffices (descPochhammer ℤ (n + 1)).comp (X - 1) =\n      descPochhammer ℤ (n + 1) - (n + 1) * (descPochhammer ℤ n).comp (X - 1)\n    by simpa [map_comp] using congr_arg (Polynomial.map (Int.castRingHom R)) this\n  nth_rw 2 [descPochhammer_succ_left]\n  rw [← sub_mul, descPochhammer_succ_right ℤ n, mul_comp, mul_comm, sub_comp, X_comp, natCast_comp]\n  ring\n\n"}
{"name":"descPochhammer_eq_ascPochhammer","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"n : Nat\n⊢ Eq (descPochhammer Int n) ((ascPochhammer Int n).comp (HAdd.hAdd (HSub.hSub Polynomial.X ↑n) 1))","decl":"theorem descPochhammer_eq_ascPochhammer (n : ℕ) :\n    descPochhammer ℤ n = (ascPochhammer ℤ n).comp ((X : ℤ[X]) - n + 1) := by\n  induction n with\n  | zero => rw [descPochhammer_zero, ascPochhammer_zero, one_comp]\n  | succ n ih =>\n    rw [Nat.cast_succ, sub_add, add_sub_cancel_right, descPochhammer_succ_right,\n      ascPochhammer_succ_left, ih, X_mul, mul_X_comp, comp_assoc, add_comp, X_comp, one_comp]\n\n"}
{"name":"descPochhammer_eval_eq_ascPochhammer","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\nr : R\nn : Nat\n⊢ Eq (Polynomial.eval r (descPochhammer R n)) (Polynomial.eval (HAdd.hAdd (HSub.hSub r ↑n) 1) (ascPochhammer R n))","decl":"theorem descPochhammer_eval_eq_ascPochhammer (r : R) (n : ℕ) :\n    (descPochhammer R n).eval r = (ascPochhammer R n).eval (r - n + 1) := by\n  induction n with\n  | zero => rw [descPochhammer_zero, eval_one, ascPochhammer_zero, eval_one]\n  | succ n ih =>\n    rw [Nat.cast_succ, sub_add, add_sub_cancel_right, descPochhammer_succ_eval, ih,\n      ascPochhammer_succ_left, X_mul, eval_mul_X, show (X + 1 : R[X]) =\n      (X + 1 : ℕ[X]).map (algebraMap ℕ R) by simp only [Polynomial.map_add, map_X,\n      Polynomial.map_one], ascPochhammer_eval_comp, eval₂_add, eval₂_X, eval₂_one]\n\n"}
{"name":"descPochhammer_mul","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\nn m : Nat\n⊢ Eq (HMul.hMul (descPochhammer R n) ((descPochhammer R m).comp (HSub.hSub Polynomial.X ↑n))) (descPochhammer R (HAdd.hAdd n m))","decl":"theorem descPochhammer_mul (n m : ℕ) :\n    descPochhammer R n * (descPochhammer R m).comp (X - (n : R[X])) = descPochhammer R (n + m) := by\n  induction' m with m ih\n  · simp\n  · rw [descPochhammer_succ_right, Polynomial.mul_X_sub_intCast_comp, ← mul_assoc, ih,\n      ← add_assoc, descPochhammer_succ_right, Nat.cast_add, sub_add_eq_sub_sub]\n\n"}
{"name":"ascPochhammer_eval_neg_eq_descPochhammer","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\nr : R\nk : Nat\n⊢ Eq (Polynomial.eval (Neg.neg r) (ascPochhammer R k)) (HMul.hMul (HPow.hPow (-1) k) (Polynomial.eval r (descPochhammer R k)))","decl":"theorem ascPochhammer_eval_neg_eq_descPochhammer (r : R) : ∀ (k : ℕ),\n    (ascPochhammer R k).eval (-r) = (-1)^k * (descPochhammer R k).eval r\n  | 0 => by\n    rw [ascPochhammer_zero, descPochhammer_zero]\n    simp only [eval_one, pow_zero, mul_one]\n  | (k+1) => by\n    rw [ascPochhammer_succ_right, mul_add, eval_add, eval_mul_X, ← Nat.cast_comm, eval_natCast_mul,\n      Nat.cast_comm, ← mul_add, ascPochhammer_eval_neg_eq_descPochhammer r k, mul_assoc,\n      descPochhammer_succ_right, mul_sub, eval_sub, eval_mul_X, ← Nat.cast_comm, eval_natCast_mul,\n      pow_add, pow_one, mul_assoc ((-1)^k) (-1), mul_sub, neg_one_mul, neg_mul_eq_mul_neg,\n      Nat.cast_comm, sub_eq_add_neg, neg_one_mul, neg_neg, ← mul_add]\n\n"}
{"name":"descPochhammer_eval_eq_descFactorial","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\nn k : Nat\n⊢ Eq (Polynomial.eval (↑n) (descPochhammer R k)) ↑(n.descFactorial k)","decl":"theorem descPochhammer_eval_eq_descFactorial (n k : ℕ) :\n    (descPochhammer R k).eval (n : R) = n.descFactorial k := by\n  induction k with\n  | zero => rw [descPochhammer_zero, eval_one, Nat.descFactorial_zero, Nat.cast_one]\n  | succ k ih =>\n    rw [descPochhammer_succ_right, Nat.descFactorial_succ, mul_sub, eval_sub, eval_mul_X,\n      ← Nat.cast_comm k, eval_natCast_mul, ← Nat.cast_comm n, ← sub_mul, ih]\n    by_cases h : n < k\n    · rw [Nat.descFactorial_eq_zero_iff_lt.mpr h, Nat.cast_zero, mul_zero, mul_zero, Nat.cast_zero]\n    · rw [Nat.cast_mul, Nat.cast_sub <| not_lt.mp h]\n\n"}
{"name":"descPochhammer_int_eq_ascFactorial","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"a b : Nat\n⊢ Eq (Polynomial.eval (HAdd.hAdd ↑a ↑b) (descPochhammer Int b)) ↑((HAdd.hAdd a 1).ascFactorial b)","decl":"theorem descPochhammer_int_eq_ascFactorial (a b : ℕ) :\n    (descPochhammer ℤ b).eval (a + b : ℤ) = (a + 1).ascFactorial b := by\n  rw [← Nat.cast_add, descPochhammer_eval_eq_descFactorial ℤ (a + b) b,\n    Nat.add_descFactorial_eq_ascFactorial]\n\n"}
{"name":"ascPochhammer_eval_neg_coe_nat_of_lt","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝ : Ring R\nn k : Nat\nh : LT.lt k n\n⊢ Eq (Polynomial.eval (Neg.neg ↑k) (ascPochhammer R n)) 0","decl":"/-- The Pochhammer polynomial of degree `n` has roots at `0`, `-1`, ..., `-(n - 1)`. -/\ntheorem ascPochhammer_eval_neg_coe_nat_of_lt {n k : ℕ} (h : k < n) :\n    (ascPochhammer R n).eval (-(k : R)) = 0 := by\n  induction n with\n  | zero => contradiction\n  | succ n ih =>\n    rw [ascPochhammer_succ_eval]\n    rcases lt_trichotomy k n with hkn | rfl | hkn\n    · simp [ih hkn]\n    · simp\n    · omega\n\n"}
{"name":"ascPochhammer_eval_eq_zero_iff","module":"Mathlib.RingTheory.Polynomial.Pochhammer","initialProofState":"R : Type u\ninst✝¹ : Ring R\ninst✝ : IsDomain R\nn : Nat\nr : R\n⊢ Iff (Eq (Polynomial.eval r (ascPochhammer R n)) 0) (Exists fun k => And (LT.lt k n) (Eq (↑k) (Neg.neg r)))","decl":"/-- Over an integral domain, the Pochhammer polynomial of degree `n` has roots *only* at\n`0`, `-1`, ..., `-(n - 1)`. -/\n@[simp]\ntheorem ascPochhammer_eval_eq_zero_iff [IsDomain R]\n    (n : ℕ) (r : R) : (ascPochhammer R n).eval r = 0 ↔ ∃ k < n, k = -r := by\n  refine ⟨fun zero' ↦ ?_, fun hrn ↦ ?_⟩\n  · induction n with\n    | zero => simp only [ascPochhammer_zero, Polynomial.eval_one, one_ne_zero] at zero'\n    | succ n ih =>\n      rw [ascPochhammer_succ_eval, mul_eq_zero] at zero'\n      cases zero' with\n      | inl h =>\n        obtain ⟨rn, hrn, rrn⟩ := ih h\n        exact ⟨rn, by omega, rrn⟩\n      | inr h =>\n        exact ⟨n, lt_add_one n, eq_neg_of_add_eq_zero_right h⟩\n  · obtain ⟨rn, hrn, rnn⟩ := hrn\n    convert ascPochhammer_eval_neg_coe_nat_of_lt hrn\n    simp [rnn]\n\n"}
