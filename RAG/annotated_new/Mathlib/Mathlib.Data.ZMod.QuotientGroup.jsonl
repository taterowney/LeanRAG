{"name":"Int.index_zmultiples","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"a : Int\n⊢ Eq (AddSubgroup.zmultiples a).index a.natAbs","decl":"@[simp]\nlemma index_zmultiples (a : ℤ) : (AddSubgroup.zmultiples a).index = a.natAbs := by\n  rw [AddSubgroup.index, Nat.card_congr (quotientZMultiplesEquivZMod a).toEquiv, Nat.card_zmod]\n\n"}
{"name":"AddAction.zmultiplesQuotientStabilizerEquiv_symm_apply","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddGroup α\na : α\ninst✝ : AddAction α β\nb : β\nn : ZMod (Function.minimalPeriod (fun x => HVAdd.hVAdd a x) b)\n⊢ Eq ((AddAction.zmultiplesQuotientStabilizerEquiv a b).symm n) (HSMul.hSMul n.cast ↑⟨a, ⋯⟩)","decl":"theorem zmultiplesQuotientStabilizerEquiv_symm_apply (n : ZMod (minimalPeriod (a +ᵥ ·) b)) :\n    (zmultiplesQuotientStabilizerEquiv a b).symm n =\n      (cast n : ℤ) • (⟨a, mem_zmultiples a⟩ : zmultiples a) :=\n  rfl\n\n"}
{"name":"MulAction.zpowersQuotientStabilizerEquiv_symm_apply","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Group α\na : α\ninst✝ : MulAction α β\nb : β\nn : ZMod (Function.minimalPeriod (fun x => HSMul.hSMul a x) b)\n⊢ Eq ((MulAction.zpowersQuotientStabilizerEquiv a b).symm n) (HPow.hPow (↑⟨a, ⋯⟩) n.cast)","decl":"theorem zpowersQuotientStabilizerEquiv_symm_apply (n : ZMod (minimalPeriod (a • ·) b)) :\n    (zpowersQuotientStabilizerEquiv a b).symm n = (⟨a, mem_zpowers a⟩ : zpowers a) ^ (cast n : ℤ) :=\n  rfl\n\n"}
{"name":"AddAction.orbitZMultiplesEquiv_symm_apply","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddGroup α\na : α\ninst✝ : AddAction α β\nb : β\nk : ZMod (Function.minimalPeriod (fun x => HVAdd.hVAdd a x) b)\n⊢ Eq ((AddAction.orbitZMultiplesEquiv a b).symm k) (HVAdd.hVAdd (HSMul.hSMul k.cast ⟨a, ⋯⟩) ⟨b, ⋯⟩)","decl":"@[to_additive]\ntheorem orbitZPowersEquiv_symm_apply (k : ZMod (minimalPeriod (a • ·) b)) :\n    (orbitZPowersEquiv a b).symm k =\n      (⟨a, mem_zpowers a⟩ : zpowers a) ^ (cast k : ℤ) • ⟨b, mem_orbit_self b⟩ :=\n  rfl\n\n"}
{"name":"MulAction.orbitZPowersEquiv_symm_apply","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Group α\na : α\ninst✝ : MulAction α β\nb : β\nk : ZMod (Function.minimalPeriod (fun x => HSMul.hSMul a x) b)\n⊢ Eq ((MulAction.orbitZPowersEquiv a b).symm k) (HSMul.hSMul (HPow.hPow ⟨a, ⋯⟩ k.cast) ⟨b, ⋯⟩)","decl":"@[to_additive]\ntheorem orbitZPowersEquiv_symm_apply (k : ZMod (minimalPeriod (a • ·) b)) :\n    (orbitZPowersEquiv a b).symm k =\n      (⟨a, mem_zpowers a⟩ : zpowers a) ^ (cast k : ℤ) • ⟨b, mem_orbit_self b⟩ :=\n  rfl\n\n"}
{"name":"MulAction.orbitZPowersEquiv_symm_apply'","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : Group α\na : α\ninst✝ : MulAction α β\nb : β\nk : Int\n⊢ Eq ((MulAction.orbitZPowersEquiv a b).symm ↑k) (HSMul.hSMul (HPow.hPow ⟨a, ⋯⟩ k) ⟨b, ⋯⟩)","decl":"theorem orbitZPowersEquiv_symm_apply' (k : ℤ) :\n    (orbitZPowersEquiv a b).symm k =\n      (⟨a, mem_zpowers a⟩ : zpowers a) ^ k • ⟨b, mem_orbit_self b⟩ := by\n  rw [orbitZPowersEquiv_symm_apply, ZMod.coe_intCast]\n  exact Subtype.ext (zpow_smul_mod_minimalPeriod _ _ k)\n\n"}
{"name":"AddAction.orbitZMultiplesEquiv_symm_apply'","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝¹ : AddGroup α\na : α\ninst✝ : AddAction α β\nb : β\nk : Int\n⊢ Eq ((AddAction.orbitZMultiplesEquiv a b).symm ↑k) (HVAdd.hVAdd (HSMul.hSMul k ⟨a, ⋯⟩) ⟨b, ⋯⟩)","decl":"theorem _root_.AddAction.orbitZMultiplesEquiv_symm_apply' {α β : Type*} [AddGroup α] (a : α)\n    [AddAction α β] (b : β) (k : ℤ) :\n    (AddAction.orbitZMultiplesEquiv a b).symm k =\n      k • (⟨a, mem_zmultiples a⟩ : zmultiples a) +ᵥ ⟨b, AddAction.mem_orbit_self b⟩ := by\n  rw [AddAction.orbitZMultiplesEquiv_symm_apply, ZMod.coe_intCast]\n  -- Porting note: times out without `a b` explicit\n  exact Subtype.ext (zsmul_vadd_mod_minimalPeriod a b k)\n\n"}
{"name":"MulAction.minimalPeriod_eq_card","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : Group α\na : α\ninst✝¹ : MulAction α β\nb : β\ninst✝ : Fintype ↑(MulAction.orbit (Subtype fun x => Membership.mem (Subgroup.zpowers a) x) b)\n⊢ Eq (Function.minimalPeriod (fun x => HSMul.hSMul a x) b) (Fintype.card ↑(MulAction.orbit (Subtype fun x => Membership.mem (Subgroup.zpowers a) x) b))","decl":"@[to_additive]\ntheorem minimalPeriod_eq_card [Fintype (orbit (zpowers a) b)] :\n    minimalPeriod (a • ·) b = Fintype.card (orbit (zpowers a) b) := by\n  -- Porting note: added `(_)` to find `Fintype` by unification\n  rw [← Fintype.ofEquiv_card (orbitZPowersEquiv a b), @ZMod.card _ (_)]\n\n"}
{"name":"AddAction.minimalPeriod_eq_card","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : AddGroup α\na : α\ninst✝¹ : AddAction α β\nb : β\ninst✝ : Fintype ↑(AddAction.orbit (Subtype fun x => Membership.mem (AddSubgroup.zmultiples a) x) b)\n⊢ Eq (Function.minimalPeriod (fun x => HVAdd.hVAdd a x) b) (Fintype.card ↑(AddAction.orbit (Subtype fun x => Membership.mem (AddSubgroup.zmultiples a) x) b))","decl":"@[to_additive]\ntheorem minimalPeriod_eq_card [Fintype (orbit (zpowers a) b)] :\n    minimalPeriod (a • ·) b = Fintype.card (orbit (zpowers a) b) := by\n  -- Porting note: added `(_)` to find `Fintype` by unification\n  rw [← Fintype.ofEquiv_card (orbitZPowersEquiv a b), @ZMod.card _ (_)]\n\n"}
{"name":"MulAction.minimalPeriod_pos","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : Group α\na : α\ninst✝¹ : MulAction α β\nb : β\ninst✝ : Finite ↑(MulAction.orbit (Subtype fun x => Membership.mem (Subgroup.zpowers a) x) b)\n⊢ NeZero (Function.minimalPeriod (fun x => HSMul.hSMul a x) b)","decl":"@[to_additive]\ninstance minimalPeriod_pos [Finite <| orbit (zpowers a) b] :\n    NeZero <| minimalPeriod (a • ·) b :=\n  ⟨by\n    cases nonempty_fintype (orbit (zpowers a) b)\n    haveI : Nonempty (orbit (zpowers a) b) := (orbit_nonempty b).to_subtype\n    rw [minimalPeriod_eq_card]\n    exact Fintype.card_ne_zero⟩\n\n"}
{"name":"AddAction.minimalPeriod_pos","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : AddGroup α\na : α\ninst✝¹ : AddAction α β\nb : β\ninst✝ : Finite ↑(AddAction.orbit (Subtype fun x => Membership.mem (AddSubgroup.zmultiples a) x) b)\n⊢ NeZero (Function.minimalPeriod (fun x => HVAdd.hVAdd a x) b)","decl":"@[to_additive]\ninstance minimalPeriod_pos [Finite <| orbit (zpowers a) b] :\n    NeZero <| minimalPeriod (a • ·) b :=\n  ⟨by\n    cases nonempty_fintype (orbit (zpowers a) b)\n    haveI : Nonempty (orbit (zpowers a) b) := (orbit_nonempty b).to_subtype\n    rw [minimalPeriod_eq_card]\n    exact Fintype.card_ne_zero⟩\n\n"}
{"name":"Nat.card_zpowers","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\ninst✝ : Group α\na : α\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (Subgroup.zpowers a) x)) (orderOf a)","decl":"/-- See also `Fintype.card_zpowers`. -/\n@[to_additive (attr := simp) \"See also `Fintype.card_zmultiples`.\"]\ntheorem Nat.card_zpowers : Nat.card (zpowers a) = orderOf a := by\n  have := Nat.card_congr (MulAction.orbitZPowersEquiv a (1 : α))\n  rwa [Nat.card_zmod, orbit_subgroup_one_eq_self] at this\n\n"}
{"name":"Nat.card_zmultiples","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\ninst✝ : AddGroup α\na : α\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (AddSubgroup.zmultiples a) x)) (addOrderOf a)","decl":"/-- See also `Fintype.card_zpowers`. -/\n@[to_additive (attr := simp) \"See also `Fintype.card_zmultiples`.\"]\ntheorem Nat.card_zpowers : Nat.card (zpowers a) = orderOf a := by\n  have := Nat.card_congr (MulAction.orbitZPowersEquiv a (1 : α))\n  rwa [Nat.card_zmod, orbit_subgroup_one_eq_self] at this\n\n"}
{"name":"finite_zmultiples","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\ninst✝ : AddGroup α\na : α\n⊢ Iff (↑(AddSubgroup.zmultiples a)).Finite (IsOfFinAddOrder a)","decl":"@[to_additive (attr := simp)]\nlemma finite_zpowers : (zpowers a : Set α).Finite ↔ IsOfFinOrder a := by\n  simp only [← orderOf_pos_iff, ← Nat.card_zpowers, Nat.card_pos_iff, ← SetLike.coe_sort_coe,\n    nonempty_coe_sort, Nat.card_pos_iff, Set.finite_coe_iff, Subgroup.coe_nonempty, true_and]\n\n"}
{"name":"finite_zpowers","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\ninst✝ : Group α\na : α\n⊢ Iff (↑(Subgroup.zpowers a)).Finite (IsOfFinOrder a)","decl":"@[to_additive (attr := simp)]\nlemma finite_zpowers : (zpowers a : Set α).Finite ↔ IsOfFinOrder a := by\n  simp only [← orderOf_pos_iff, ← Nat.card_zpowers, Nat.card_pos_iff, ← SetLike.coe_sort_coe,\n    nonempty_coe_sort, Nat.card_pos_iff, Set.finite_coe_iff, Subgroup.coe_nonempty, true_and]\n\n"}
{"name":"infinite_zpowers","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\ninst✝ : Group α\na : α\n⊢ Iff (↑(Subgroup.zpowers a)).Infinite (Not (IsOfFinOrder a))","decl":"@[to_additive (attr := simp)]\nlemma infinite_zpowers : (zpowers a : Set α).Infinite ↔ ¬IsOfFinOrder a := finite_zpowers.not\n\n"}
{"name":"infinite_zmultiples","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\ninst✝ : AddGroup α\na : α\n⊢ Iff (↑(AddSubgroup.zmultiples a)).Infinite (Not (IsOfFinAddOrder a))","decl":"@[to_additive (attr := simp)]\nlemma infinite_zpowers : (zpowers a : Set α).Infinite ↔ ¬IsOfFinOrder a := finite_zpowers.not\n\n"}
{"name":"IsOfFinAddOrder.finite_zmultiples","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\ninst✝ : AddGroup α\na : α\na✝ : IsOfFinAddOrder a\n⊢ (↑(AddSubgroup.zmultiples a)).Finite","decl":"@[to_additive]\nprotected alias ⟨_, IsOfFinOrder.finite_zpowers⟩ := finite_zpowers\n\n"}
{"name":"IsOfFinOrder.finite_zpowers","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"α : Type u_3\ninst✝ : Group α\na : α\na✝ : IsOfFinOrder a\n⊢ (↑(Subgroup.zpowers a)).Finite","decl":"@[to_additive]\nprotected alias ⟨_, IsOfFinOrder.finite_zpowers⟩ := finite_zpowers\n\n"}
{"name":"Subgroup.quotientEquivSigmaZMod_symm_apply","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"G : Type u_3\ninst✝ : Group G\nH : Subgroup G\ng : G\nq : MulAction.orbitRel.Quotient (Subtype fun x => Membership.mem (Subgroup.zpowers g) x) (HasQuotient.Quotient G H)\nk : ZMod (Function.minimalPeriod (fun x => HSMul.hSMul g x) (Quotient.out q))\n⊢ Eq ((H.quotientEquivSigmaZMod g).symm ⟨q, k⟩) (HSMul.hSMul (HPow.hPow g k.cast) (Quotient.out q))","decl":"lemma quotientEquivSigmaZMod_symm_apply (q : orbitRel.Quotient (zpowers g) (G ⧸ H))\n    (k : ZMod (minimalPeriod (g • ·) q.out)) :\n    (quotientEquivSigmaZMod H g).symm ⟨q, k⟩ = g ^ (cast k : ℤ) • q.out := rfl\n\n"}
{"name":"Subgroup.quotientEquivSigmaZMod_apply","module":"Mathlib.Data.ZMod.QuotientGroup","initialProofState":"G : Type u_3\ninst✝ : Group G\nH : Subgroup G\ng : G\nq : MulAction.orbitRel.Quotient (Subtype fun x => Membership.mem (Subgroup.zpowers g) x) (HasQuotient.Quotient G H)\nk : Int\n⊢ Eq ((H.quotientEquivSigmaZMod g) (HSMul.hSMul (HPow.hPow g k) (Quotient.out q))) ⟨q, ↑k⟩","decl":"lemma quotientEquivSigmaZMod_apply (q : orbitRel.Quotient (zpowers g) (G ⧸ H)) (k : ℤ) :\n    quotientEquivSigmaZMod H g (g ^ k • q.out) = ⟨q, k⟩ := by\n  rw [apply_eq_iff_eq_symm_apply, quotientEquivSigmaZMod_symm_apply, ZMod.coe_intCast,\n    zpow_smul_mod_minimalPeriod]\n\n"}
