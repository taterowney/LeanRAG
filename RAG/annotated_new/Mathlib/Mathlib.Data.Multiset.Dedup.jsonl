{"name":"Multiset.coe_dedup","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (↑l).dedup ↑l.dedup","decl":"@[simp]\ntheorem coe_dedup (l : List α) : @dedup α _ l = l.dedup :=\n  rfl\n\n"}
{"name":"Multiset.dedup_zero","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq (Multiset.dedup 0) 0","decl":"@[simp]\ntheorem dedup_zero : @dedup α _ 0 = 0 :=\n  rfl\n\n"}
{"name":"Multiset.mem_dedup","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Iff (Membership.mem s.dedup a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_dedup {a : α} {s : Multiset α} : a ∈ dedup s ↔ a ∈ s :=\n  Quot.induction_on s fun _ => List.mem_dedup\n\n"}
{"name":"Multiset.dedup_cons_of_mem","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\na✝ : Membership.mem s a\n⊢ Eq (Multiset.cons a s).dedup s.dedup","decl":"@[simp]\ntheorem dedup_cons_of_mem {a : α} {s : Multiset α} : a ∈ s → dedup (a ::ₘ s) = dedup s :=\n  Quot.induction_on s fun _ m => @congr_arg _ _ _ _ ofList <| List.dedup_cons_of_mem m\n\n"}
{"name":"Multiset.dedup_cons_of_not_mem","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\na✝ : Not (Membership.mem s a)\n⊢ Eq (Multiset.cons a s).dedup (Multiset.cons a s.dedup)","decl":"@[simp]\ntheorem dedup_cons_of_not_mem {a : α} {s : Multiset α} : a ∉ s → dedup (a ::ₘ s) = a ::ₘ dedup s :=\n  Quot.induction_on s fun _ m => congr_arg ofList <| List.dedup_cons_of_not_mem m\n\n"}
{"name":"Multiset.dedup_le","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ LE.le s.dedup s","decl":"theorem dedup_le (s : Multiset α) : dedup s ≤ s :=\n  Quot.induction_on s fun _ => (dedup_sublist _).subperm\n\n"}
{"name":"Multiset.dedup_subset","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ HasSubset.Subset s.dedup s","decl":"theorem dedup_subset (s : Multiset α) : dedup s ⊆ s :=\n  subset_of_le <| dedup_le _\n\n"}
{"name":"Multiset.subset_dedup","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ HasSubset.Subset s s.dedup","decl":"theorem subset_dedup (s : Multiset α) : s ⊆ dedup s := fun _ => mem_dedup.2\n\n"}
{"name":"Multiset.dedup_subset'","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Iff (HasSubset.Subset s.dedup t) (HasSubset.Subset s t)","decl":"@[simp]\ntheorem dedup_subset' {s t : Multiset α} : dedup s ⊆ t ↔ s ⊆ t :=\n  ⟨Subset.trans (subset_dedup _), Subset.trans (dedup_subset _)⟩\n\n"}
{"name":"Multiset.subset_dedup'","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Iff (HasSubset.Subset s t.dedup) (HasSubset.Subset s t)","decl":"@[simp]\ntheorem subset_dedup' {s t : Multiset α} : s ⊆ dedup t ↔ s ⊆ t :=\n  ⟨fun h => Subset.trans h (dedup_subset _), fun h => Subset.trans h (subset_dedup _)⟩\n\n"}
{"name":"Multiset.nodup_dedup","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ s.dedup.Nodup","decl":"@[simp]\ntheorem nodup_dedup (s : Multiset α) : Nodup (dedup s) :=\n  Quot.induction_on s List.nodup_dedup\n\n"}
{"name":"Multiset.dedup_eq_self","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Iff (Eq s.dedup s) s.Nodup","decl":"theorem dedup_eq_self {s : Multiset α} : dedup s = s ↔ Nodup s :=\n  ⟨fun e => e ▸ nodup_dedup s, Quot.induction_on s fun _ h => congr_arg ofList h.dedup⟩\n\n"}
{"name":"Multiset.Nodup.dedup","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\na✝ : s.Nodup\n⊢ Eq s.dedup s","decl":"alias ⟨_, Nodup.dedup⟩ := dedup_eq_self\n\n"}
{"name":"Multiset.count_dedup","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\na : α\n⊢ Eq (Multiset.count a m.dedup) (ite (Membership.mem m a) 1 0)","decl":"theorem count_dedup (m : Multiset α) (a : α) : m.dedup.count a = if a ∈ m then 1 else 0 :=\n  Quot.induction_on m fun _ => by\n    simp only [quot_mk_to_coe'', coe_dedup, mem_coe, List.mem_dedup, coe_nodup, coe_count]\n    apply List.count_dedup _ _\n\n"}
{"name":"Multiset.dedup_idem","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Eq m.dedup.dedup m.dedup","decl":"@[simp]\ntheorem dedup_idem {m : Multiset α} : m.dedup.dedup = m.dedup :=\n  Quot.induction_on m fun _ => @congr_arg _ _ _ _ ofList List.dedup_idem\n\n"}
{"name":"Multiset.dedup_eq_zero","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Iff (Eq s.dedup 0) (Eq s 0)","decl":"theorem dedup_eq_zero {s : Multiset α} : dedup s = 0 ↔ s = 0 :=\n  ⟨fun h => eq_zero_of_subset_zero <| h ▸ subset_dedup _, fun h => h.symm ▸ dedup_zero⟩\n\n"}
{"name":"Multiset.dedup_singleton","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Singleton.singleton a).dedup (Singleton.singleton a)","decl":"@[simp]\ntheorem dedup_singleton {a : α} : dedup ({a} : Multiset α) = {a} :=\n  (nodup_singleton _).dedup\n\n"}
{"name":"Multiset.le_dedup","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Iff (LE.le s t.dedup) (And (LE.le s t) s.Nodup)","decl":"theorem le_dedup {s t : Multiset α} : s ≤ dedup t ↔ s ≤ t ∧ Nodup s :=\n  ⟨fun h => ⟨le_trans h (dedup_le _), nodup_of_le h (nodup_dedup _)⟩,\n   fun ⟨l, d⟩ => (le_iff_subset d).2 <| Subset.trans (subset_of_le l) (subset_dedup _)⟩\n\n"}
{"name":"Multiset.le_dedup_self","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Iff (LE.le s s.dedup) s.Nodup","decl":"theorem le_dedup_self {s : Multiset α} : s ≤ dedup s ↔ Nodup s := by\n  rw [le_dedup, and_iff_right le_rfl]\n\n"}
{"name":"Multiset.dedup_ext","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Iff (Eq s.dedup t.dedup) (∀ (a : α), Iff (Membership.mem s a) (Membership.mem t a))","decl":"theorem dedup_ext {s t : Multiset α} : dedup s = dedup t ↔ ∀ a, a ∈ s ↔ a ∈ t := by\n  simp [Nodup.ext]\n\n"}
{"name":"Multiset.dedup_map_of_injective","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\nhf : Function.Injective f\ns : Multiset α\n⊢ Eq (Multiset.map f s).dedup (Multiset.map f s.dedup)","decl":"theorem dedup_map_of_injective [DecidableEq β] {f : α → β} (hf : Function.Injective f)\n    (s : Multiset α) :\n    (s.map f).dedup = s.dedup.map f :=\n  Quot.induction_on s fun l => by simp [List.dedup_map_of_injective hf l]\n\n"}
{"name":"Multiset.dedup_map_dedup_eq","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\ns : Multiset α\n⊢ Eq (Multiset.map f s.dedup).dedup (Multiset.map f s).dedup","decl":"theorem dedup_map_dedup_eq [DecidableEq β] (f : α → β) (s : Multiset α) :\n    dedup (map f (dedup s)) = dedup (map f s) := by\n  simp [dedup_ext]\n\n"}
{"name":"Multiset.Nodup.le_dedup_iff_le","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nhno : s.Nodup\n⊢ Iff (LE.le s t.dedup) (LE.le s t)","decl":"theorem Nodup.le_dedup_iff_le {s t : Multiset α} (hno : s.Nodup) : s ≤ t.dedup ↔ s ≤ t := by\n  simp [le_dedup, hno]\n\n"}
{"name":"Multiset.Subset.dedup_add_right","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : HasSubset.Subset s t\n⊢ Eq (HAdd.hAdd s t).dedup t.dedup","decl":"theorem Subset.dedup_add_right {s t : Multiset α} (h : s ⊆ t) :\n    dedup (s + t) = dedup t := by\n  induction s, t using Quot.induction_on₂\n  exact congr_arg ((↑) : List α → Multiset α) <| List.Subset.dedup_append_right h\n\n"}
{"name":"Multiset.Subset.dedup_add_left","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : HasSubset.Subset t s\n⊢ Eq (HAdd.hAdd s t).dedup s.dedup","decl":"theorem Subset.dedup_add_left {s t : Multiset α} (h : t ⊆ s) :\n    dedup (s + t) = dedup s := by\n  rw [s.add_comm, Subset.dedup_add_right h]\n\n"}
{"name":"Multiset.Disjoint.dedup_add","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : Disjoint s t\n⊢ Eq (HAdd.hAdd s t).dedup (HAdd.hAdd s.dedup t.dedup)","decl":"theorem Disjoint.dedup_add {s t : Multiset α} (h : Disjoint s t) :\n    dedup (s + t) = dedup s + dedup t := by\n  induction s, t using Quot.induction_on₂\n  exact congr_arg ((↑) : List α → Multiset α) <| List.Disjoint.dedup_append (by simpa using h)\n\n"}
{"name":"List.Subset.dedup_append_left","module":"Mathlib.Data.Multiset.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : List α\nh : HasSubset.Subset t s\n⊢ (HAppend.hAppend s t).dedup.Perm s.dedup","decl":"/-- Note that the stronger `List.Subset.dedup_append_right` is proved earlier. -/\ntheorem _root_.List.Subset.dedup_append_left {s t : List α} (h : t ⊆ s) :\n    List.dedup (s ++ t) ~ List.dedup s := by\n  rw [← coe_eq_coe, ← coe_dedup, ← coe_add, Subset.dedup_add_left h, coe_dedup]\n\n"}
