{"name":"lipschitzOnWith_empty","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\n‚ä¢ LipschitzOnWith K f EmptyCollection.emptyCollection","decl":"/-- Every function is Lipschitz on the empty set (with any Lipschitz constant). -/\n@[simp]\ntheorem lipschitzOnWith_empty (K : ‚Ñù‚â•0) (f : Œ± ‚Üí Œ≤) : LipschitzOnWith K f ‚àÖ := fun _ => False.elim\n\n"}
{"name":"locallyLipschitzOn_empty","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ LocallyLipschitzOn EmptyCollection.emptyCollection f","decl":"@[simp] lemma locallyLipschitzOn_empty (f : Œ± ‚Üí Œ≤) : LocallyLipschitzOn ‚àÖ f := fun _ ‚Ü¶ False.elim\n\n"}
{"name":"LipschitzOnWith.mono","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\ns t : Set Œ±\nf : Œ± ‚Üí Œ≤\nhf : LipschitzOnWith K f t\nh : HasSubset.Subset s t\n‚ä¢ LipschitzOnWith K f s","decl":"/-- Being Lipschitz on a set is monotone w.r.t. that set. -/\ntheorem LipschitzOnWith.mono (hf : LipschitzOnWith K f t) (h : s ‚äÜ t) : LipschitzOnWith K f s :=\n  fun _x x_in _y y_in => hf (h x_in) (h y_in)\n\n"}
{"name":"LocallyLipschitzOn.mono","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\ns t : Set Œ±\nf : Œ± ‚Üí Œ≤\nhf : LocallyLipschitzOn t f\nh : HasSubset.Subset s t\n‚ä¢ LocallyLipschitzOn s f","decl":"lemma LocallyLipschitzOn.mono (hf : LocallyLipschitzOn t f) (h : s ‚äÜ t) : LocallyLipschitzOn s f :=\n  fun x hx ‚Ü¶ by obtain ‚ü®K, u, hu, hfu‚ü© := hf (h hx); exact ‚ü®K, u, nhdsWithin_mono _ h hu, hfu‚ü©\n\n"}
{"name":"lipschitzOnWith_univ","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (LipschitzOnWith K f Set.univ) (LipschitzWith K f)","decl":"/-- `f` is Lipschitz iff it is Lipschitz on the entire space. -/\n@[simp] lemma lipschitzOnWith_univ : LipschitzOnWith K f univ ‚Üî LipschitzWith K f := by\n  simp [LipschitzOnWith, LipschitzWith]\n\n"}
{"name":"locallyLipschitzOn_univ","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (LocallyLipschitzOn Set.univ f) (LocallyLipschitz f)","decl":"@[simp] lemma locallyLipschitzOn_univ : LocallyLipschitzOn univ f ‚Üî LocallyLipschitz f := by\n  simp [LocallyLipschitzOn, LocallyLipschitz]\n\n"}
{"name":"LocallyLipschitz.locallyLipschitzOn","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\nh : LocallyLipschitz f\n‚ä¢ LocallyLipschitzOn s f","decl":"protected lemma LocallyLipschitz.locallyLipschitzOn (h : LocallyLipschitz f) :\n    LocallyLipschitzOn s f := (locallyLipschitzOn_univ.2 h).mono s.subset_univ\n\n"}
{"name":"lipschitzOnWith_iff_restrict","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (LipschitzOnWith K f s) (LipschitzWith K (s.restrict f))","decl":"theorem lipschitzOnWith_iff_restrict : LipschitzOnWith K f s ‚Üî LipschitzWith K (s.restrict f) := by\n  simp [LipschitzOnWith, LipschitzWith]\n\n"}
{"name":"lipschitzOnWith_restrict","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\nt : Set ‚Üës\n‚ä¢ Iff (LipschitzOnWith K (s.restrict f) t) (LipschitzOnWith K f (Inter.inter s (Set.image Subtype.val t)))","decl":"lemma lipschitzOnWith_restrict {t : Set s} :\n    LipschitzOnWith K (s.restrict f) t ‚Üî LipschitzOnWith K f (s ‚à© Subtype.val '' t) := by\n  simp [LipschitzOnWith, LipschitzWith]\n\n"}
{"name":"locallyLipschitzOn_iff_restrict","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (LocallyLipschitzOn s f) (LocallyLipschitz (s.restrict f))","decl":"lemma locallyLipschitzOn_iff_restrict :\n    LocallyLipschitzOn s f ‚Üî LocallyLipschitz (s.restrict f) := by\n  simp only [LocallyLipschitzOn, LocallyLipschitz, SetCoe.forall', restrict_apply,\n    Subtype.edist_mk_mk, ‚Üê lipschitzOnWith_iff_restrict, lipschitzOnWith_restrict,\n    nhds_subtype_eq_comap_nhdsWithin, mem_comap]\n  congr! with x K\n  constructor\n  ¬∑ rintro ‚ü®t, ht, hft‚ü©\n    exact ‚ü®_, ‚ü®t, ht, Subset.rfl‚ü©, hft.mono <| inter_subset_right.trans <| image_preimage_subset ..‚ü©\n  ¬∑ rintro ‚ü®t, ‚ü®u, hu, hut‚ü©, hft‚ü©\n    exact ‚ü®s ‚à© u, Filter.inter_mem self_mem_nhdsWithin hu,\n      hft.mono fun x hx ‚Ü¶ ‚ü®hx.1, ‚ü®x, hx.1‚ü©, hut hx.2, rfl‚ü©‚ü©\n\n"}
{"name":"LipschitzOnWith.to_restrict","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\na‚úù : LipschitzOnWith K f s\n‚ä¢ LipschitzWith K (s.restrict f)","decl":"alias ‚ü®LipschitzOnWith.to_restrict, _‚ü© := lipschitzOnWith_iff_restrict\n"}
{"name":"LocallyLipschitzOn.restrict","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\na‚úù : LocallyLipschitzOn s f\n‚ä¢ LocallyLipschitz (s.restrict f)","decl":"alias ‚ü®LocallyLipschitzOn.restrict, _‚ü© := locallyLipschitzOn_iff_restrict\n\n"}
{"name":"Set.MapsTo.lipschitzOnWith_iff_restrict","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\nt : Set Œ≤\nh : Set.MapsTo f s t\n‚ä¢ Iff (LipschitzOnWith K f s) (LipschitzWith K (Set.MapsTo.restrict f s t h))","decl":"lemma Set.MapsTo.lipschitzOnWith_iff_restrict {t : Set Œ≤} (h : MapsTo f s t) :\n    LipschitzOnWith K f s ‚Üî LipschitzWith K (h.restrict f s t) :=\n  _root_.lipschitzOnWith_iff_restrict\n\n"}
{"name":"LipschitzOnWith.to_restrict_mapsTo","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\nt : Set Œ≤\nh : Set.MapsTo f s t\na‚úù : LipschitzOnWith K f s\n‚ä¢ LipschitzWith K (Set.MapsTo.restrict f s t h)","decl":"alias ‚ü®LipschitzOnWith.to_restrict_mapsTo, _‚ü© := Set.MapsTo.lipschitzOnWith_iff_restrict\n\n"}
{"name":"LipschitzWith.lipschitzOnWith","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nh : LipschitzWith K f\n‚ä¢ LipschitzOnWith K f s","decl":"protected theorem lipschitzOnWith (h : LipschitzWith K f) : LipschitzOnWith K f s :=\n  fun x _ y _ => h x y\n\n"}
{"name":"LipschitzWith.edist_le_mul","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nh : LipschitzWith K f\nx y : Œ±\n‚ä¢ LE.le (EDist.edist (f x) (f y)) (HMul.hMul (‚ÜëK) (EDist.edist x y))","decl":"theorem edist_le_mul (h : LipschitzWith K f) (x y : Œ±) : edist (f x) (f y) ‚â§ K * edist x y :=\n  h x y\n\n"}
{"name":"LipschitzWith.edist_le_mul_of_le","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nx y : Œ±\nr : ENNReal\nh : LipschitzWith K f\nhr : LE.le (EDist.edist x y) r\n‚ä¢ LE.le (EDist.edist (f x) (f y)) (HMul.hMul (‚ÜëK) r)","decl":"theorem edist_le_mul_of_le (h : LipschitzWith K f) (hr : edist x y ‚â§ r) :\n    edist (f x) (f y) ‚â§ K * r :=\n  (h x y).trans <| mul_left_mono hr\n\n"}
{"name":"LipschitzWith.edist_lt_mul_of_lt","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nx y : Œ±\nr : ENNReal\nh : LipschitzWith K f\nhK : Ne K 0\nhr : LT.lt (EDist.edist x y) r\n‚ä¢ LT.lt (EDist.edist (f x) (f y)) (HMul.hMul (‚ÜëK) r)","decl":"theorem edist_lt_mul_of_lt (h : LipschitzWith K f) (hK : K ‚â† 0) (hr : edist x y < r) :\n    edist (f x) (f y) < K * r :=\n  (h x y).trans_lt <| (ENNReal.mul_lt_mul_left (ENNReal.coe_ne_zero.2 hK) ENNReal.coe_ne_top).2 hr\n\n"}
{"name":"LipschitzWith.mapsTo_emetric_closedBall","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nh : LipschitzWith K f\nx : Œ±\nr : ENNReal\n‚ä¢ Set.MapsTo f (EMetric.closedBall x r) (EMetric.closedBall (f x) (HMul.hMul (‚ÜëK) r))","decl":"theorem mapsTo_emetric_closedBall (h : LipschitzWith K f) (x : Œ±) (r : ‚Ñù‚â•0‚àû) :\n    MapsTo f (closedBall x r) (closedBall (f x) (K * r)) := fun _y hy => h.edist_le_mul_of_le hy\n\n"}
{"name":"LipschitzWith.mapsTo_emetric_ball","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nh : LipschitzWith K f\nhK : Ne K 0\nx : Œ±\nr : ENNReal\n‚ä¢ Set.MapsTo f (EMetric.ball x r) (EMetric.ball (f x) (HMul.hMul (‚ÜëK) r))","decl":"theorem mapsTo_emetric_ball (h : LipschitzWith K f) (hK : K ‚â† 0) (x : Œ±) (r : ‚Ñù‚â•0‚àû) :\n    MapsTo f (ball x r) (ball (f x) (K * r)) := fun _y hy => h.edist_lt_mul_of_lt hK hy\n\n"}
{"name":"LipschitzWith.edist_lt_top","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : LipschitzWith K f\nx y : Œ±\nh : Ne (EDist.edist x y) Top.top\n‚ä¢ LT.lt (EDist.edist (f x) (f y)) Top.top","decl":"theorem edist_lt_top (hf : LipschitzWith K f) {x y : Œ±} (h : edist x y ‚â† ‚ä§) :\n    edist (f x) (f y) < ‚ä§ :=\n  (hf x y).trans_lt <| ENNReal.mul_lt_top ENNReal.coe_lt_top h.lt_top\n\n"}
{"name":"LipschitzWith.mul_edist_le","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nh : LipschitzWith K f\nx y : Œ±\n‚ä¢ LE.le (HMul.hMul (Inv.inv ‚ÜëK) (EDist.edist (f x) (f y))) (EDist.edist x y)","decl":"theorem mul_edist_le (h : LipschitzWith K f) (x y : Œ±) :\n    (K‚Åª¬π : ‚Ñù‚â•0‚àû) * edist (f x) (f y) ‚â§ edist x y := by\n  rw [mul_comm, ‚Üê div_eq_mul_inv]\n  exact ENNReal.div_le_of_le_mul' (h x y)\n\n"}
{"name":"LipschitzWith.of_edist_le","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : ‚àÄ (x y : Œ±), LE.le (EDist.edist (f x) (f y)) (EDist.edist x y)\n‚ä¢ LipschitzWith 1 f","decl":"protected theorem of_edist_le (h : ‚àÄ x y, edist (f x) (f y) ‚â§ edist x y) : LipschitzWith 1 f :=\n  fun x y => by simp only [ENNReal.coe_one, one_mul, h]\n\n"}
{"name":"LipschitzWith.weaken","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : LipschitzWith K f\nK' : NNReal\nh : LE.le K K'\n‚ä¢ LipschitzWith K' f","decl":"protected theorem weaken (hf : LipschitzWith K f) {K' : ‚Ñù‚â•0} (h : K ‚â§ K') : LipschitzWith K' f :=\n  fun x y => le_trans (hf x y) <| mul_right_mono (ENNReal.coe_le_coe.2 h)\n\n"}
{"name":"LipschitzWith.ediam_image_le","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : LipschitzWith K f\ns : Set Œ±\n‚ä¢ LE.le (EMetric.diam (Set.image f s)) (HMul.hMul (‚ÜëK) (EMetric.diam s))","decl":"theorem ediam_image_le (hf : LipschitzWith K f) (s : Set Œ±) :\n    EMetric.diam (f '' s) ‚â§ K * EMetric.diam s := by\n  apply EMetric.diam_le\n  rintro _ ‚ü®x, hx, rfl‚ü© _ ‚ü®y, hy, rfl‚ü©\n  exact hf.edist_le_mul_of_le (EMetric.edist_le_diam_of_mem hx hy)\n\n"}
{"name":"LipschitzWith.edist_lt_of_edist_lt_div","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : LipschitzWith K f\nx y : Œ±\nd : ENNReal\nh : LT.lt (EDist.edist x y) (HDiv.hDiv d ‚ÜëK)\n‚ä¢ LT.lt (EDist.edist (f x) (f y)) d","decl":"theorem edist_lt_of_edist_lt_div (hf : LipschitzWith K f) {x y : Œ±} {d : ‚Ñù‚â•0‚àû}\n    (h : edist x y < d / K) : edist (f x) (f y) < d :=\n  calc\n    edist (f x) (f y) ‚â§ K * edist x y := hf x y\n    _ < d := ENNReal.mul_lt_of_lt_div' h\n\n"}
{"name":"LipschitzWith.uniformContinuous","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : LipschitzWith K f\n‚ä¢ UniformContinuous f","decl":"/-- A Lipschitz function is uniformly continuous. -/\nprotected theorem uniformContinuous (hf : LipschitzWith K f) : UniformContinuous f :=\n  EMetric.uniformContinuous_iff.2 fun Œµ Œµpos =>\n    ‚ü®Œµ / K, ENNReal.div_pos_iff.2 ‚ü®ne_of_gt Œµpos, ENNReal.coe_ne_top‚ü©, hf.edist_lt_of_edist_lt_div‚ü©\n\n"}
{"name":"LipschitzWith.continuous","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : LipschitzWith K f\n‚ä¢ Continuous f","decl":"/-- A Lipschitz function is continuous. -/\nprotected theorem continuous (hf : LipschitzWith K f) : Continuous f :=\n  hf.uniformContinuous.continuous\n\n"}
{"name":"LipschitzWith.const","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nb : Œ≤\n‚ä¢ LipschitzWith 0 fun x => b","decl":"/-- Constant functions are Lipschitz (with any constant). -/\nprotected theorem const (b : Œ≤) : LipschitzWith 0 fun _ : Œ± => b := fun x y => by\n  simp only [edist_self, zero_le]\n\n"}
{"name":"LipschitzWith.const'","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nb : Œ≤\nK : NNReal\n‚ä¢ LipschitzWith K fun x => b","decl":"protected theorem const' (b : Œ≤) {K : ‚Ñù‚â•0} : LipschitzWith K fun _ : Œ± => b := fun x y => by\n  simp only [edist_self, zero_le]\n\n"}
{"name":"LipschitzWith.id","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\n‚ä¢ LipschitzWith 1 id","decl":"/-- The identity is 1-Lipschitz. -/\nprotected theorem id : LipschitzWith 1 (@id Œ±) :=\n  LipschitzWith.of_edist_le fun _ _ => le_rfl\n\n"}
{"name":"LipschitzWith.subtype_val","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\ns : Set Œ±\n‚ä¢ LipschitzWith 1 Subtype.val","decl":"/-- The inclusion of a subset is 1-Lipschitz. -/\nprotected theorem subtype_val (s : Set Œ±) : LipschitzWith 1 (Subtype.val : s ‚Üí Œ±) :=\n  LipschitzWith.of_edist_le fun _ _ => le_rfl\n\n"}
{"name":"LipschitzWith.subtype_mk","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : LipschitzWith K f\np : Œ≤ ‚Üí Prop\nhp : ‚àÄ (x : Œ±), p (f x)\n‚ä¢ LipschitzWith K fun x => ‚ü®f x, ‚ãØ‚ü©","decl":"theorem subtype_mk (hf : LipschitzWith K f) {p : Œ≤ ‚Üí Prop} (hp : ‚àÄ x, p (f x)) :\n    LipschitzWith K (fun x => ‚ü®f x, hp x‚ü© : Œ± ‚Üí { y // p y }) :=\n  hf\n\n"}
{"name":"LipschitzWith.eval","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œπ : Type x\nŒ± : Œπ ‚Üí Type u\ninst‚úù¬π : (i : Œπ) ‚Üí PseudoEMetricSpace (Œ± i)\ninst‚úù : Fintype Œπ\ni : Œπ\n‚ä¢ LipschitzWith 1 (Function.eval i)","decl":"protected theorem eval {Œ± : Œπ ‚Üí Type u} [‚àÄ i, PseudoEMetricSpace (Œ± i)] [Fintype Œπ] (i : Œπ) :\n    LipschitzWith 1 (Function.eval i : (‚àÄ i, Œ± i) ‚Üí Œ± i) :=\n  LipschitzWith.of_edist_le fun f g => by convert edist_le_pi_edist f g i\n\n"}
{"name":"LipschitzWith.restrict","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : LipschitzWith K f\ns : Set Œ±\n‚ä¢ LipschitzWith K (s.restrict f)","decl":"/-- The restriction of a `K`-Lipschitz function is `K`-Lipschitz. -/\nprotected theorem restrict (hf : LipschitzWith K f) (s : Set Œ±) : LipschitzWith K (s.restrict f) :=\n  fun x y => hf x y\n\n"}
{"name":"LipschitzWith.comp","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : PseudoEMetricSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\nKf Kg : NNReal\nf : Œ≤ ‚Üí Œ≥\ng : Œ± ‚Üí Œ≤\nhf : LipschitzWith Kf f\nhg : LipschitzWith Kg g\n‚ä¢ LipschitzWith (HMul.hMul Kf Kg) (Function.comp f g)","decl":"/-- The composition of Lipschitz functions is Lipschitz. -/\nprotected theorem comp {Kf Kg : ‚Ñù‚â•0} {f : Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ≤} (hf : LipschitzWith Kf f)\n    (hg : LipschitzWith Kg g) : LipschitzWith (Kf * Kg) (f ‚àò g) := fun x y =>\n  calc\n    edist (f (g x)) (f (g y)) ‚â§ Kf * edist (g x) (g y) := hf _ _\n    _ ‚â§ Kf * (Kg * edist x y) := mul_left_mono (hg _ _)\n    _ = (Kf * Kg : ‚Ñù‚â•0) * edist x y := by rw [‚Üê mul_assoc, ENNReal.coe_mul]\n\n"}
{"name":"LipschitzWith.comp_lipschitzOnWith","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : PseudoEMetricSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\nKf Kg : NNReal\nf : Œ≤ ‚Üí Œ≥\ng : Œ± ‚Üí Œ≤\ns : Set Œ±\nhf : LipschitzWith Kf f\nhg : LipschitzOnWith Kg g s\n‚ä¢ LipschitzOnWith (HMul.hMul Kf Kg) (Function.comp f g) s","decl":"theorem comp_lipschitzOnWith {Kf Kg : ‚Ñù‚â•0} {f : Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ≤} {s : Set Œ±}\n    (hf : LipschitzWith Kf f) (hg : LipschitzOnWith Kg g s) : LipschitzOnWith (Kf * Kg) (f ‚àò g) s :=\n  lipschitzOnWith_iff_restrict.mpr <| hf.comp hg.to_restrict\n\n"}
{"name":"LipschitzWith.prod_fst","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\n‚ä¢ LipschitzWith 1 Prod.fst","decl":"protected theorem prod_fst : LipschitzWith 1 (@Prod.fst Œ± Œ≤) :=\n  LipschitzWith.of_edist_le fun _ _ => le_max_left _ _\n\n"}
{"name":"LipschitzWith.prod_snd","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\n‚ä¢ LipschitzWith 1 Prod.snd","decl":"protected theorem prod_snd : LipschitzWith 1 (@Prod.snd Œ± Œ≤) :=\n  LipschitzWith.of_edist_le fun _ _ => le_max_right _ _\n\n"}
{"name":"LipschitzWith.prod","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : PseudoEMetricSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\nf : Œ± ‚Üí Œ≤\nKf : NNReal\nhf : LipschitzWith Kf f\ng : Œ± ‚Üí Œ≥\nKg : NNReal\nhg : LipschitzWith Kg g\n‚ä¢ LipschitzWith (Max.max Kf Kg) fun x => { fst := f x, snd := g x }","decl":"/-- If `f` and `g` are Lipschitz functions, so is the induced map `f √ó g` to the product type. -/\nprotected theorem prod {f : Œ± ‚Üí Œ≤} {Kf : ‚Ñù‚â•0} (hf : LipschitzWith Kf f) {g : Œ± ‚Üí Œ≥} {Kg : ‚Ñù‚â•0}\n    (hg : LipschitzWith Kg g) : LipschitzWith (max Kf Kg) fun x => (f x, g x) := by\n  intro x y\n  rw [ENNReal.coe_mono.map_max, Prod.edist_eq, max_mul]\n  exact max_le_max (hf x y) (hg x y)\n\n"}
{"name":"LipschitzWith.prod_mk_left","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\na : Œ±\n‚ä¢ LipschitzWith 1 (Prod.mk a)","decl":"protected theorem prod_mk_left (a : Œ±) : LipschitzWith 1 (Prod.mk a : Œ≤ ‚Üí Œ± √ó Œ≤) := by\n  simpa only [max_eq_right zero_le_one] using (LipschitzWith.const a).prod LipschitzWith.id\n\n"}
{"name":"LipschitzWith.prod_mk_right","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nb : Œ≤\n‚ä¢ LipschitzWith 1 fun a => { fst := a, snd := b }","decl":"protected theorem prod_mk_right (b : Œ≤) : LipschitzWith 1 fun a : Œ± => (a, b) := by\n  simpa only [max_eq_left zero_le_one] using LipschitzWith.id.prod (LipschitzWith.const b)\n\n"}
{"name":"LipschitzWith.uncurry","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : PseudoEMetricSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\nKŒ± KŒ≤ : NNReal\nhŒ± : ‚àÄ (b : Œ≤), LipschitzWith KŒ± fun a => f a b\nhŒ≤ : ‚àÄ (a : Œ±), LipschitzWith KŒ≤ (f a)\n‚ä¢ LipschitzWith (HAdd.hAdd KŒ± KŒ≤) (Function.uncurry f)","decl":"protected theorem uncurry {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {KŒ± KŒ≤ : ‚Ñù‚â•0} (hŒ± : ‚àÄ b, LipschitzWith KŒ± fun a => f a b)\n    (hŒ≤ : ‚àÄ a, LipschitzWith KŒ≤ (f a)) : LipschitzWith (KŒ± + KŒ≤) (Function.uncurry f) := by\n  rintro ‚ü®a‚ÇÅ, b‚ÇÅ‚ü© ‚ü®a‚ÇÇ, b‚ÇÇ‚ü©\n  simp only [Function.uncurry, ENNReal.coe_add, add_mul]\n  apply le_trans (edist_triangle _ (f a‚ÇÇ b‚ÇÅ) _)\n  exact\n    add_le_add (le_trans (hŒ± _ _ _) <| mul_left_mono <| le_max_left _ _)\n      (le_trans (hŒ≤ _ _ _) <| mul_left_mono <| le_max_right _ _)\n\n"}
{"name":"LipschitzWith.iterate","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : LipschitzWith K f\nn : Nat\n‚ä¢ LipschitzWith (HPow.hPow K n) (Nat.iterate f n)","decl":"/-- Iterates of a Lipschitz function are Lipschitz. -/\nprotected theorem iterate {f : Œ± ‚Üí Œ±} (hf : LipschitzWith K f) : ‚àÄ n, LipschitzWith (K ^ n) f^[n]\n  | 0 => by simpa only [pow_zero] using LipschitzWith.id\n  | n + 1 => by rw [pow_succ]; exact (LipschitzWith.iterate hf n).comp hf\n\n"}
{"name":"LipschitzWith.edist_iterate_succ_le_geometric","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ±\nhf : LipschitzWith K f\nx : Œ±\nn : Nat\n‚ä¢ LE.le (EDist.edist (Nat.iterate f n x) (Nat.iterate f (HAdd.hAdd n 1) x)) (HMul.hMul (EDist.edist x (f x)) (HPow.hPow (‚ÜëK) n))","decl":"theorem edist_iterate_succ_le_geometric {f : Œ± ‚Üí Œ±} (hf : LipschitzWith K f) (x n) :\n    edist (f^[n] x) (f^[n + 1] x) ‚â§ edist x (f x) * (K : ‚Ñù‚â•0‚àû) ^ n := by\n  rw [iterate_succ, mul_comm]\n  simpa only [ENNReal.coe_pow] using (hf.iterate n) x (f x)\n\n"}
{"name":"LipschitzWith.mul_end","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nf g : Function.End Œ±\nKf Kg : NNReal\nhf : LipschitzWith Kf f\nhg : LipschitzWith Kg g\n‚ä¢ LipschitzWith (HMul.hMul Kf Kg) (HMul.hMul f g)","decl":"protected theorem mul_end {f g : Function.End Œ±} {Kf Kg} (hf : LipschitzWith Kf f)\n    (hg : LipschitzWith Kg g) : LipschitzWith (Kf * Kg) (f * g : Function.End Œ±) :=\n  hf.comp hg\n\n"}
{"name":"LipschitzWith.list_prod","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒπ : Type x\ninst‚úù : PseudoEMetricSpace Œ±\nf : Œπ ‚Üí Function.End Œ±\nK : Œπ ‚Üí NNReal\nh : ‚àÄ (i : Œπ), LipschitzWith (K i) (f i)\nl : List Œπ\n‚ä¢ LipschitzWith (List.map K l).prod (List.map f l).prod","decl":"/-- The product of a list of Lipschitz continuous endomorphisms is a Lipschitz continuous\nendomorphism. -/\nprotected theorem list_prod (f : Œπ ‚Üí Function.End Œ±) (K : Œπ ‚Üí ‚Ñù‚â•0)\n    (h : ‚àÄ i, LipschitzWith (K i) (f i)) : ‚àÄ l : List Œπ, LipschitzWith (l.map K).prod (l.map f).prod\n  | [] => by simpa using LipschitzWith.id\n  | i::l => by\n    simp only [List.map_cons, List.prod_cons]\n    exact (h i).mul_end (LipschitzWith.list_prod f K h l)\n\n"}
{"name":"LipschitzWith.pow_end","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nf : Function.End Œ±\nK : NNReal\nh : LipschitzWith K f\nn : Nat\n‚ä¢ LipschitzWith (HPow.hPow K n) (HPow.hPow f n)","decl":"protected theorem pow_end {f : Function.End Œ±} {K} (h : LipschitzWith K f) :\n    ‚àÄ n : ‚Ñï, LipschitzWith (K ^ n) (f ^ n : Function.End Œ±)\n  | 0 => by simpa only [pow_zero] using LipschitzWith.id\n  | n + 1 => by\n    rw [pow_succ, pow_succ]\n    exact (LipschitzWith.pow_end h n).mul_end h\n\n"}
{"name":"LipschitzOnWith.uniformContinuousOn","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\nhf : LipschitzOnWith K f s\n‚ä¢ UniformContinuousOn f s","decl":"protected theorem uniformContinuousOn (hf : LipschitzOnWith K f s) : UniformContinuousOn f s :=\n  uniformContinuousOn_iff_restrict.mpr hf.to_restrict.uniformContinuous\n\n"}
{"name":"LipschitzOnWith.continuousOn","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\nhf : LipschitzOnWith K f s\n‚ä¢ ContinuousOn f s","decl":"protected theorem continuousOn (hf : LipschitzOnWith K f s) : ContinuousOn f s :=\n  hf.uniformContinuousOn.continuousOn\n\n"}
{"name":"LipschitzOnWith.edist_le_mul_of_le","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\nh : LipschitzOnWith K f s\nx y : Œ±\nhx : Membership.mem s x\nhy : Membership.mem s y\nr : ENNReal\nhr : LE.le (EDist.edist x y) r\n‚ä¢ LE.le (EDist.edist (f x) (f y)) (HMul.hMul (‚ÜëK) r)","decl":"theorem edist_le_mul_of_le (h : LipschitzOnWith K f s) {x y : Œ±} (hx : x ‚àà s) (hy : y ‚àà s)\n    {r : ‚Ñù‚â•0‚àû} (hr : edist x y ‚â§ r) :\n    edist (f x) (f y) ‚â§ K * r :=\n  (h hx hy).trans <| mul_left_mono hr\n\n"}
{"name":"LipschitzOnWith.edist_lt_of_edist_lt_div","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\nhf : LipschitzOnWith K f s\nx y : Œ±\nhx : Membership.mem s x\nhy : Membership.mem s y\nd : ENNReal\nhd : LT.lt (EDist.edist x y) (HDiv.hDiv d ‚ÜëK)\n‚ä¢ LT.lt (EDist.edist (f x) (f y)) d","decl":"theorem edist_lt_of_edist_lt_div (hf : LipschitzOnWith K f s) {x y : Œ±} (hx : x ‚àà s) (hy : y ‚àà s)\n    {d : ‚Ñù‚â•0‚àû} (hd : edist x y < d / K) : edist (f x) (f y) < d :=\n   hf.to_restrict.edist_lt_of_edist_lt_div <|\n    show edist (‚ü®x, hx‚ü© : s) ‚ü®y, hy‚ü© < d / K from hd\n\n"}
{"name":"LipschitzOnWith.comp","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : PseudoEMetricSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\nK : NNReal\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\ng : Œ≤ ‚Üí Œ≥\nt : Set Œ≤\nKg : NNReal\nhg : LipschitzOnWith Kg g t\nhf : LipschitzOnWith K f s\nhmaps : Set.MapsTo f s t\n‚ä¢ LipschitzOnWith (HMul.hMul Kg K) (Function.comp g f) s","decl":"protected theorem comp {g : Œ≤ ‚Üí Œ≥} {t : Set Œ≤} {Kg : ‚Ñù‚â•0} (hg : LipschitzOnWith Kg g t)\n    (hf : LipschitzOnWith K f s) (hmaps : MapsTo f s t) : LipschitzOnWith (Kg * K) (g ‚àò f) s :=\n  lipschitzOnWith_iff_restrict.mpr <| hg.to_restrict.comp (hf.to_restrict_mapsTo hmaps)\n\n"}
{"name":"LipschitzOnWith.prod","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : PseudoEMetricSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\ns : Set Œ±\nf : Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≥\nKf Kg : NNReal\nhf : LipschitzOnWith Kf f s\nhg : LipschitzOnWith Kg g s\n‚ä¢ LipschitzOnWith (Max.max Kf Kg) (fun x => { fst := f x, snd := g x }) s","decl":"/-- If `f` and `g` are Lipschitz on `s`, so is the induced map `f √ó g` to the product type. -/\nprotected theorem prod {g : Œ± ‚Üí Œ≥} {Kf Kg : ‚Ñù‚â•0} (hf : LipschitzOnWith Kf f s)\n    (hg : LipschitzOnWith Kg g s) : LipschitzOnWith (max Kf Kg) (fun x => (f x, g x)) s := by\n  intro _ hx _ hy\n  rw [ENNReal.coe_mono.map_max, Prod.edist_eq, max_mul]\n  exact max_le_max (hf hx hy) (hg hx hy)\n\n"}
{"name":"LipschitzOnWith.ediam_image2_le","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : PseudoEMetricSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\nK‚ÇÅ K‚ÇÇ : NNReal\ns : Set Œ±\nt : Set Œ≤\nhf‚ÇÅ : ‚àÄ (b : Œ≤), Membership.mem t b ‚Üí LipschitzOnWith K‚ÇÅ (fun x => f x b) s\nhf‚ÇÇ : ‚àÄ (a : Œ±), Membership.mem s a ‚Üí LipschitzOnWith K‚ÇÇ (f a) t\n‚ä¢ LE.le (EMetric.diam (Set.image2 f s t)) (HAdd.hAdd (HMul.hMul (‚ÜëK‚ÇÅ) (EMetric.diam s)) (HMul.hMul (‚ÜëK‚ÇÇ) (EMetric.diam t)))","decl":"theorem ediam_image2_le (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) {K‚ÇÅ K‚ÇÇ : ‚Ñù‚â•0} (s : Set Œ±) (t : Set Œ≤)\n    (hf‚ÇÅ : ‚àÄ b ‚àà t, LipschitzOnWith K‚ÇÅ (f ¬∑ b) s) (hf‚ÇÇ : ‚àÄ a ‚àà s, LipschitzOnWith K‚ÇÇ (f a) t) :\n    EMetric.diam (Set.image2 f s t) ‚â§ ‚ÜëK‚ÇÅ * EMetric.diam s + ‚ÜëK‚ÇÇ * EMetric.diam t := by\n  simp only [EMetric.diam_le_iff, forall_mem_image2]\n  intro a‚ÇÅ ha‚ÇÅ b‚ÇÅ hb‚ÇÅ a‚ÇÇ ha‚ÇÇ b‚ÇÇ hb‚ÇÇ\n  refine (edist_triangle _ (f a‚ÇÇ b‚ÇÅ) _).trans ?_\n  exact\n    add_le_add\n      ((hf‚ÇÅ b‚ÇÅ hb‚ÇÅ ha‚ÇÅ ha‚ÇÇ).trans <| mul_left_mono <| EMetric.edist_le_diam_of_mem ha‚ÇÅ ha‚ÇÇ)\n      ((hf‚ÇÇ a‚ÇÇ ha‚ÇÇ hb‚ÇÅ hb‚ÇÇ).trans <| mul_left_mono <| EMetric.edist_le_diam_of_mem hb‚ÇÅ hb‚ÇÇ)\n\n"}
{"name":"LipschitzWith.locallyLipschitz","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\nK : NNReal\nhf : LipschitzWith K f\n‚ä¢ LocallyLipschitz f","decl":"/-- A Lipschitz function is locally Lipschitz. -/\nprotected lemma _root_.LipschitzWith.locallyLipschitz {K : ‚Ñù‚â•0} (hf : LipschitzWith K f) :\n    LocallyLipschitz f :=\n  fun _ ‚Ü¶ ‚ü®K, univ, Filter.univ_mem, lipschitzOnWith_univ.mpr hf‚ü©\n\n"}
{"name":"LocallyLipschitz.id","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\n‚ä¢ LocallyLipschitz id","decl":"/-- The identity function is locally Lipschitz. -/\nprotected lemma id : LocallyLipschitz (@id Œ±) := LipschitzWith.id.locallyLipschitz\n\n"}
{"name":"LocallyLipschitz.const","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nb : Œ≤\n‚ä¢ LocallyLipschitz fun x => b","decl":"/-- Constant functions are locally Lipschitz. -/\nprotected lemma const (b : Œ≤) : LocallyLipschitz (fun _ : Œ± ‚Ü¶ b) :=\n  (LipschitzWith.const b).locallyLipschitz\n\n"}
{"name":"LocallyLipschitz.continuous","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : LocallyLipschitz f\n‚ä¢ Continuous f","decl":"/-- A locally Lipschitz function is continuous. (The converse is false: for example,\n$x ‚Ü¶ \\sqrt{x}$ is continuous, but not locally Lipschitz at 0.) -/\nprotected theorem continuous {f : Œ± ‚Üí Œ≤} (hf : LocallyLipschitz f) : Continuous f := by\n  rw [continuous_iff_continuousAt]\n  intro x\n  rcases (hf x) with ‚ü®K, t, ht, hK‚ü©\n  exact (hK.continuousOn).continuousAt ht\n\n"}
{"name":"LocallyLipschitz.comp","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : PseudoEMetricSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\nf : Œ≤ ‚Üí Œ≥\ng : Œ± ‚Üí Œ≤\nhf : LocallyLipschitz f\nhg : LocallyLipschitz g\n‚ä¢ LocallyLipschitz (Function.comp f g)","decl":"/-- The composition of locally Lipschitz functions is locally Lipschitz. --/\nprotected lemma comp  {f : Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ≤}\n    (hf : LocallyLipschitz f) (hg : LocallyLipschitz g) : LocallyLipschitz (f ‚àò g) := by\n  intro x\n  -- g is Lipschitz on t ‚àã x, f is Lipschitz on u ‚àã g(x)\n  rcases hg x with ‚ü®Kg, t, ht, hgL‚ü©\n  rcases hf (g x) with ‚ü®Kf, u, hu, hfL‚ü©\n  refine ‚ü®Kf * Kg, t ‚à© g‚Åª¬π' u, inter_mem ht (hg.continuous.continuousAt hu), ?_‚ü©\n  exact hfL.comp (hgL.mono inter_subset_left)\n    ((mapsTo_preimage g u).mono_left inter_subset_right)\n\n"}
{"name":"LocallyLipschitz.prod","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : PseudoEMetricSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\nf : Œ± ‚Üí Œ≤\nhf : LocallyLipschitz f\ng : Œ± ‚Üí Œ≥\nhg : LocallyLipschitz g\n‚ä¢ LocallyLipschitz fun x => { fst := f x, snd := g x }","decl":"/-- If `f` and `g` are locally Lipschitz, so is the induced map `f √ó g` to the product type. -/\nprotected lemma prod {f : Œ± ‚Üí Œ≤} (hf : LocallyLipschitz f) {g : Œ± ‚Üí Œ≥} (hg : LocallyLipschitz g) :\n    LocallyLipschitz fun x => (f x, g x) := by\n  intro x\n  rcases hf x with ‚ü®Kf, t‚ÇÅ, h‚ÇÅt, hfL‚ü©\n  rcases hg x with ‚ü®Kg, t‚ÇÇ, h‚ÇÇt, hgL‚ü©\n  refine ‚ü®max Kf Kg, t‚ÇÅ ‚à© t‚ÇÇ, Filter.inter_mem h‚ÇÅt h‚ÇÇt, ?_‚ü©\n  exact (hfL.mono inter_subset_left).prod (hgL.mono inter_subset_right)\n\n"}
{"name":"LocallyLipschitz.prod_mk_left","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\na : Œ±\n‚ä¢ LocallyLipschitz (Prod.mk a)","decl":"protected theorem prod_mk_left (a : Œ±) : LocallyLipschitz (Prod.mk a : Œ≤ ‚Üí Œ± √ó Œ≤) :=\n  (LipschitzWith.prod_mk_left a).locallyLipschitz\n\n"}
{"name":"LocallyLipschitz.prod_mk_right","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nb : Œ≤\n‚ä¢ LocallyLipschitz fun a => { fst := a, snd := b }","decl":"protected theorem prod_mk_right (b : Œ≤) : LocallyLipschitz (fun a : Œ± => (a, b)) :=\n  (LipschitzWith.prod_mk_right b).locallyLipschitz\n\n"}
{"name":"LocallyLipschitz.iterate","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nf : Œ± ‚Üí Œ±\nhf : LocallyLipschitz f\nn : Nat\n‚ä¢ LocallyLipschitz (Nat.iterate f n)","decl":"protected theorem iterate {f : Œ± ‚Üí Œ±} (hf : LocallyLipschitz f) : ‚àÄ n, LocallyLipschitz f^[n]\n  | 0 => by simpa only [pow_zero] using LocallyLipschitz.id\n  | n + 1 => by rw [iterate_add, iterate_one]; exact (hf.iterate n).comp hf\n\n"}
{"name":"LocallyLipschitz.mul_end","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nf g : Function.End Œ±\nhf : LocallyLipschitz f\nhg : LocallyLipschitz g\n‚ä¢ LocallyLipschitz (HMul.hMul f g)","decl":"protected theorem mul_end {f g : Function.End Œ±} (hf : LocallyLipschitz f)\n    (hg : LocallyLipschitz g) : LocallyLipschitz (f * g : Function.End Œ±) := hf.comp hg\n\n"}
{"name":"LocallyLipschitz.pow_end","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\ninst‚úù : PseudoEMetricSpace Œ±\nf : Function.End Œ±\nh : LocallyLipschitz f\nn : Nat\n‚ä¢ LocallyLipschitz (HPow.hPow f n)","decl":"protected theorem pow_end {f : Function.End Œ±} (h : LocallyLipschitz f) :\n    ‚àÄ n : ‚Ñï, LocallyLipschitz (f ^ n : Function.End Œ±)\n  | 0 => by simpa only [pow_zero] using LocallyLipschitz.id\n  | n + 1 => by\n    rw [pow_succ]\n    exact (h.pow_end n).mul_end h\n\n"}
{"name":"LocallyLipschitzOn.continuousOn","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nhf : LocallyLipschitzOn s f\n‚ä¢ ContinuousOn f s","decl":"protected lemma continuousOn (hf : LocallyLipschitzOn s f) : ContinuousOn f s :=\n  continuousOn_iff_continuous_restrict.2 hf.restrict.continuous\n\n"}
{"name":"continuousOn_prod_of_subset_closure_continuousOn_lipschitzOnWith","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\nf : Prod Œ± Œ≤ ‚Üí Œ≥\ns s' : Set Œ±\nt : Set Œ≤\nhs' : HasSubset.Subset s' s\nhss' : HasSubset.Subset s (closure s')\nK : NNReal\nha : ‚àÄ (a : Œ±), Membership.mem s' a ‚Üí ContinuousOn (fun y => f { fst := a, snd := y }) t\nhb : ‚àÄ (b : Œ≤), Membership.mem t b ‚Üí LipschitzOnWith K (fun x => f { fst := x, snd := b }) s\n‚ä¢ ContinuousOn f (SProd.sprod s t)","decl":"/-- Consider a function `f : Œ± √ó Œ≤ ‚Üí Œ≥`. Suppose that it is continuous on each ‚Äúvertical fiber‚Äù\n`{a} √ó t`, `a ‚àà s`, and is Lipschitz continuous on each ‚Äúhorizontal fiber‚Äù `s √ó {b}`, `b ‚àà t`\nwith the same Lipschitz constant `K`. Then it is continuous on `s √ó t`. Moreover, it suffices\nto require continuity on vertical fibers for `a` from a subset `s' ‚äÜ s` that is dense in `s`.\n\nThe actual statement uses (Lipschitz) continuity of `fun y ‚Ü¶ f (a, y)` and `fun x ‚Ü¶ f (x, b)`\ninstead of continuity of `f` on subsets of the product space. -/\ntheorem continuousOn_prod_of_subset_closure_continuousOn_lipschitzOnWith [PseudoEMetricSpace Œ±]\n    [TopologicalSpace Œ≤] [PseudoEMetricSpace Œ≥] (f : Œ± √ó Œ≤ ‚Üí Œ≥) {s s' : Set Œ±} {t : Set Œ≤}\n    (hs' : s' ‚äÜ s) (hss' : s ‚äÜ closure s') (K : ‚Ñù‚â•0)\n    (ha : ‚àÄ a ‚àà s', ContinuousOn (fun y => f (a, y)) t)\n    (hb : ‚àÄ b ‚àà t, LipschitzOnWith K (fun x => f (x, b)) s) : ContinuousOn f (s √óÀ¢ t) := by\n  rintro ‚ü®x, y‚ü© ‚ü®hx : x ‚àà s, hy : y ‚àà t‚ü©\n  refine EMetric.nhds_basis_closed_eball.tendsto_right_iff.2 fun Œµ (Œµ0 : 0 < Œµ) => ?_\n  replace Œµ0 : 0 < Œµ / 2 := ENNReal.half_pos Œµ0.ne'\n  obtain ‚ü®Œ¥, Œ¥pos, hŒ¥‚ü© : ‚àÉ Œ¥ : ‚Ñù‚â•0, 0 < Œ¥ ‚àß (Œ¥ : ‚Ñù‚â•0‚àû) * ‚Üë(3 * K) < Œµ / 2 :=\n    ENNReal.exists_nnreal_pos_mul_lt ENNReal.coe_ne_top Œµ0.ne'\n  rw [‚Üê ENNReal.coe_pos] at Œ¥pos\n  rcases EMetric.mem_closure_iff.1 (hss' hx) Œ¥ Œ¥pos with ‚ü®x', hx', hxx'‚ü©\n  have A : s ‚à© EMetric.ball x Œ¥ ‚àà ùìù[s] x :=\n    inter_mem_nhdsWithin _ (EMetric.ball_mem_nhds _ Œ¥pos)\n  have B : t ‚à© { b | edist (f (x', b)) (f (x', y)) ‚â§ Œµ / 2 } ‚àà ùìù[t] y :=\n    inter_mem self_mem_nhdsWithin (ha x' hx' y hy (EMetric.closedBall_mem_nhds (f (x', y)) Œµ0))\n  filter_upwards [nhdsWithin_prod A B] with ‚ü®a, b‚ü© ‚ü®‚ü®has, hax‚ü©, ‚ü®hbt, hby‚ü©‚ü©\n  calc\n    edist (f (a, b)) (f (x, y)) ‚â§ edist (f (a, b)) (f (x', b)) + edist (f (x', b)) (f (x', y)) +\n        edist (f (x', y)) (f (x, y)) := edist_triangle4 _ _ _ _\n    _ ‚â§ K * (Œ¥ + Œ¥) + Œµ / 2 + K * Œ¥ := by\n      gcongr\n      ¬∑ refine (hb b hbt).edist_le_mul_of_le has (hs' hx') ?_\n        exact (edist_triangle _ _ _).trans (add_le_add (le_of_lt hax) hxx'.le)\n      ¬∑ exact hby\n      ¬∑ exact (hb y hy).edist_le_mul_of_le (hs' hx') hx ((edist_comm _ _).trans_le hxx'.le)\n    _ = Œ¥ * ‚Üë(3 * K) + Œµ / 2 := by push_cast; ring\n    _ ‚â§ Œµ / 2 + Œµ / 2 := by gcongr\n    _ = Œµ := ENNReal.add_halves _\n\n"}
{"name":"continuousOn_prod_of_continuousOn_lipschitzOnWith","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\nf : Prod Œ± Œ≤ ‚Üí Œ≥\ns : Set Œ±\nt : Set Œ≤\nK : NNReal\nha : ‚àÄ (a : Œ±), Membership.mem s a ‚Üí ContinuousOn (fun y => f { fst := a, snd := y }) t\nhb : ‚àÄ (b : Œ≤), Membership.mem t b ‚Üí LipschitzOnWith K (fun x => f { fst := x, snd := b }) s\n‚ä¢ ContinuousOn f (SProd.sprod s t)","decl":"/-- Consider a function `f : Œ± √ó Œ≤ ‚Üí Œ≥`. Suppose that it is continuous on each ‚Äúvertical fiber‚Äù\n`{a} √ó t`, `a ‚àà s`, and is Lipschitz continuous on each ‚Äúhorizontal fiber‚Äù `s √ó {b}`, `b ‚àà t`\nwith the same Lipschitz constant `K`. Then it is continuous on `s √ó t`.\n\nThe actual statement uses (Lipschitz) continuity of `fun y ‚Ü¶ f (a, y)` and `fun x ‚Ü¶ f (x, b)`\ninstead of continuity of `f` on subsets of the product space. -/\ntheorem continuousOn_prod_of_continuousOn_lipschitzOnWith [PseudoEMetricSpace Œ±]\n    [TopologicalSpace Œ≤] [PseudoEMetricSpace Œ≥] (f : Œ± √ó Œ≤ ‚Üí Œ≥) {s : Set Œ±} {t : Set Œ≤} (K : ‚Ñù‚â•0)\n    (ha : ‚àÄ a ‚àà s, ContinuousOn (fun y => f (a, y)) t)\n    (hb : ‚àÄ b ‚àà t, LipschitzOnWith K (fun x => f (x, b)) s) : ContinuousOn f (s √óÀ¢ t) :=\n  continuousOn_prod_of_subset_closure_continuousOn_lipschitzOnWith\n    f Subset.rfl subset_closure K ha hb\n\n"}
{"name":"continuous_prod_of_dense_continuous_lipschitzWith","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\nf : Prod Œ± Œ≤ ‚Üí Œ≥\nK : NNReal\ns : Set Œ±\nhs : Dense s\nha : ‚àÄ (a : Œ±), Membership.mem s a ‚Üí Continuous fun y => f { fst := a, snd := y }\nhb : ‚àÄ (b : Œ≤), LipschitzWith K fun x => f { fst := x, snd := b }\n‚ä¢ Continuous f","decl":"/-- Consider a function `f : Œ± √ó Œ≤ ‚Üí Œ≥`. Suppose that it is continuous on each ‚Äúvertical section‚Äù\n`{a} √ó univ` for `a : Œ±` from a dense set. Suppose that it is Lipschitz continuous on each\n‚Äúhorizontal section‚Äù `univ √ó {b}`, `b : Œ≤` with the same Lipschitz constant `K`. Then it is\ncontinuous.\n\nThe actual statement uses (Lipschitz) continuity of `fun y ‚Ü¶ f (a, y)` and `fun x ‚Ü¶ f (x, b)`\ninstead of continuity of `f` on subsets of the product space. -/\ntheorem continuous_prod_of_dense_continuous_lipschitzWith [PseudoEMetricSpace Œ±]\n    [TopologicalSpace Œ≤] [PseudoEMetricSpace Œ≥] (f : Œ± √ó Œ≤ ‚Üí Œ≥) (K : ‚Ñù‚â•0) {s : Set Œ±}\n    (hs : Dense s) (ha : ‚àÄ a ‚àà s, Continuous fun y => f (a, y))\n    (hb : ‚àÄ b, LipschitzWith K fun x => f (x, b)) : Continuous f := by\n  simp only [continuous_iff_continuousOn_univ, ‚Üê univ_prod_univ, ‚Üê lipschitzOnWith_univ] at *\n  exact continuousOn_prod_of_subset_closure_continuousOn_lipschitzOnWith f (subset_univ _)\n    hs.closure_eq.ge K ha fun b _ => hb b\n\n"}
{"name":"continuous_prod_of_continuous_lipschitzWith","module":"Mathlib.Topology.EMetricSpace.Lipschitz","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\nf : Prod Œ± Œ≤ ‚Üí Œ≥\nK : NNReal\nha : ‚àÄ (a : Œ±), Continuous fun y => f { fst := a, snd := y }\nhb : ‚àÄ (b : Œ≤), LipschitzWith K fun x => f { fst := x, snd := b }\n‚ä¢ Continuous f","decl":"/-- Consider a function `f : Œ± √ó Œ≤ ‚Üí Œ≥`. Suppose that it is continuous on each ‚Äúvertical section‚Äù\n`{a} √ó univ`, `a : Œ±`, and is Lipschitz continuous on each ‚Äúhorizontal section‚Äù\n`univ √ó {b}`, `b : Œ≤` with the same Lipschitz constant `K`. Then it is continuous.\n\nThe actual statement uses (Lipschitz) continuity of `fun y ‚Ü¶ f (a, y)` and `fun x ‚Ü¶ f (x, b)`\ninstead of continuity of `f` on subsets of the product space. -/\ntheorem continuous_prod_of_continuous_lipschitzWith [PseudoEMetricSpace Œ±] [TopologicalSpace Œ≤]\n    [PseudoEMetricSpace Œ≥] (f : Œ± √ó Œ≤ ‚Üí Œ≥) (K : ‚Ñù‚â•0) (ha : ‚àÄ a, Continuous fun y => f (a, y))\n    (hb : ‚àÄ b, LipschitzWith K fun x => f (x, b)) : Continuous f :=\n  continuous_prod_of_dense_continuous_lipschitzWith f K dense_univ (fun _ _ ‚Ü¶ ha _) hb\n"}
