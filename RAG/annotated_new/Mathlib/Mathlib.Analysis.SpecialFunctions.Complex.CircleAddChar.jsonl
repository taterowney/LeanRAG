{"name":"ZMod.toCircle_intCast","module":"Mathlib.Analysis.SpecialFunctions.Complex.CircleAddChar","initialProofState":"N : Nat\ninst✝ : NeZero N\nj : Int\n⊢ Eq (↑(ZMod.toCircle ↑j)) (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑j) ↑N))","decl":"lemma toCircle_intCast (j : ℤ) :\n    toCircle (j : ZMod N) = exp (2 * π * I * j / N) := by\n  rw [toCircle, AddChar.compAddMonoidHom_apply, toCircle_addChar, AddChar.coe_mk,\n    AddCircle.toCircle, toAddCircle_intCast, Function.Periodic.lift_coe, Circle.coe_exp]\n  push_cast\n  ring_nf\n\n"}
{"name":"ZMod.toCircle_natCast","module":"Mathlib.Analysis.SpecialFunctions.Complex.CircleAddChar","initialProofState":"N : Nat\ninst✝ : NeZero N\nj : Nat\n⊢ Eq (↑(ZMod.toCircle ↑j)) (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑j) ↑N))","decl":"lemma toCircle_natCast (j : ℕ) :\n    toCircle (j : ZMod N) = exp (2 * π * I * j / N) := by\n  simpa using toCircle_intCast (N := N) j\n\n"}
{"name":"ZMod.toCircle_apply","module":"Mathlib.Analysis.SpecialFunctions.Complex.CircleAddChar","initialProofState":"N : Nat\ninst✝ : NeZero N\nj : ZMod N\n⊢ Eq (↑(ZMod.toCircle j)) (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑j.val) ↑N))","decl":"/--\nExplicit formula for `toCircle j`. Note that this is \"evil\" because it uses `ZMod.val`. Where\npossible, it is recommended to lift `j` to `ℤ` and use `toCircle_intCast` instead.\n-/\nlemma toCircle_apply (j : ZMod N) :\n    toCircle j = exp (2 * π * I * j.val / N) := by\n  rw [← toCircle_natCast, natCast_zmod_val]\n\n"}
{"name":"ZMod.injective_toCircle","module":"Mathlib.Analysis.SpecialFunctions.Complex.CircleAddChar","initialProofState":"N : Nat\ninst✝ : NeZero N\n⊢ Function.Injective ⇑ZMod.toCircle","decl":"lemma injective_toCircle : Injective (toCircle : ZMod N → Circle) :=\n  (AddCircle.injective_toCircle one_ne_zero).comp (toAddCircle_injective N)\n\n"}
{"name":"ZMod.stdAddChar_coe","module":"Mathlib.Analysis.SpecialFunctions.Complex.CircleAddChar","initialProofState":"N : Nat\ninst✝ : NeZero N\nj : Int\n⊢ Eq (ZMod.stdAddChar ↑j) (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑j) ↑N))","decl":"lemma stdAddChar_coe (j : ℤ) :\n    stdAddChar (j : ZMod N) = exp (2 * π * I * j / N) := by simp [stdAddChar, toCircle_intCast]\n\n"}
{"name":"ZMod.stdAddChar_apply","module":"Mathlib.Analysis.SpecialFunctions.Complex.CircleAddChar","initialProofState":"N : Nat\ninst✝ : NeZero N\nj : ZMod N\n⊢ Eq (ZMod.stdAddChar j) ↑(ZMod.toCircle j)","decl":"lemma stdAddChar_apply (j : ZMod N) : stdAddChar j = ↑(toCircle j) := rfl\n\n"}
{"name":"ZMod.injective_stdAddChar","module":"Mathlib.Analysis.SpecialFunctions.Complex.CircleAddChar","initialProofState":"N : Nat\ninst✝ : NeZero N\n⊢ Function.Injective ⇑ZMod.stdAddChar","decl":"lemma injective_stdAddChar : Injective (stdAddChar : AddChar (ZMod N) ℂ) :=\n  Subtype.coe_injective.comp injective_toCircle\n\n"}
{"name":"ZMod.isPrimitive_stdAddChar","module":"Mathlib.Analysis.SpecialFunctions.Complex.CircleAddChar","initialProofState":"N : Nat\ninst✝ : NeZero N\n⊢ ZMod.stdAddChar.IsPrimitive","decl":"/-- The standard additive character `ZMod N → ℂ` is primitive. -/\nlemma isPrimitive_stdAddChar (N : ℕ) [NeZero N] :\n    (stdAddChar (N := N)).IsPrimitive := by\n  refine AddChar.zmod_char_primitive_of_eq_one_only_at_zero _ _ (fun t ht ↦ ?_)\n  rwa [← (stdAddChar (N := N)).map_zero_eq_one, injective_stdAddChar.eq_iff] at ht\n\n"}
