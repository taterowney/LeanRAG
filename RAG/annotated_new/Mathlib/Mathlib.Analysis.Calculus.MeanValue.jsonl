{"name":"image_le_of_liminf_slope_right_lt_deriv_boundary'","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f f' : Real ‚Üí Real\na b : Real\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí ‚àÄ (r : Real), LT.lt (f' x) r ‚Üí Filter.Frequently (fun z => LT.lt (slope f x z) r) (nhdsWithin x (Set.Ioi x))\nB B' : Real ‚Üí Real\nha : LE.le (f a) (B a)\nhB : ContinuousOn B (Set.Icc a b)\nhB' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt B (B' x) (Set.Ici x) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí Eq (f x) (B x) ‚Üí LT.lt (f' x) (B' x)\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (f x) (B x)","decl":"/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ‚â§ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* for each `x ‚àà [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x ‚â§ B x` everywhere on `[a, b]`. -/\ntheorem image_le_of_liminf_slope_right_lt_deriv_boundary' {f f' : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}\n    (hf : ContinuousOn f (Icc a b))\n    -- `hf'` actually says `liminf (f z - f x) / (z - x) ‚â§ f' x`\n    (hf' : ‚àÄ x ‚àà Ico a b, ‚àÄ r, f' x < r ‚Üí ‚àÉ·∂† z in ùìù[>] x, slope f x z < r)\n    {B B' : ‚Ñù ‚Üí ‚Ñù} (ha : f a ‚â§ B a) (hB : ContinuousOn B (Icc a b))\n    (hB' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)\n    (bound : ‚àÄ x ‚àà Ico a b, f x = B x ‚Üí f' x < B' x) : ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà Icc a b ‚Üí f x ‚â§ B x := by\n  change Icc a b ‚äÜ { x | f x ‚â§ B x }\n  set s := { x | f x ‚â§ B x } ‚à© Icc a b\n  have A : ContinuousOn (fun x => (f x, B x)) (Icc a b) := hf.prod hB\n  have : IsClosed s := by\n    simp only [s, inter_comm]\n    exact A.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'\n  apply this.Icc_subset_of_forall_exists_gt ha\n  rintro x ‚ü®hxB : f x ‚â§ B x, xab‚ü© y hy\n  cases' hxB.lt_or_eq with hxB hxB\n  ¬∑ -- If `f x < B x`, then all we need is continuity of both sides\n    refine nonempty_of_mem (inter_mem ?_ (Ioc_mem_nhdsGT hy))\n    have : ‚àÄ·∂† x in ùìù[Icc a b] x, f x < B x :=\n      A x (Ico_subset_Icc_self xab) (IsOpen.mem_nhds (isOpen_lt continuous_fst continuous_snd) hxB)\n    have : ‚àÄ·∂† x in ùìù[>] x, f x < B x := nhdsWithin_le_of_mem (Icc_mem_nhdsGT_of_mem xab) this\n    exact this.mono fun y => le_of_lt\n  ¬∑ rcases exists_between (bound x xab hxB) with ‚ü®r, hfr, hrB‚ü©\n    specialize hf' x xab r hfr\n    have HB : ‚àÄ·∂† z in ùìù[>] x, r < slope B x z :=\n      (hasDerivWithinAt_iff_tendsto_slope' <| lt_irrefl x).1 (hB' x xab).Ioi_of_Ici\n        (Ioi_mem_nhds hrB)\n    obtain ‚ü®z, hfz, hzB, hz‚ü© : ‚àÉ z, slope f x z < r ‚àß r < slope B x z ‚àß z ‚àà Ioc x y :=\n      hf'.and_eventually (HB.and (Ioc_mem_nhdsGT hy)) |>.exists\n    refine ‚ü®z, ?_, hz‚ü©\n    have := (hfz.trans hzB).le\n    rwa [slope_def_field, slope_def_field, div_le_div_iff_of_pos_right (sub_pos.2 hz.1), hxB,\n      sub_le_sub_iff_right] at this\n\n"}
{"name":"image_le_of_liminf_slope_right_lt_deriv_boundary","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f f' : Real ‚Üí Real\na b : Real\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí ‚àÄ (r : Real), LT.lt (f' x) r ‚Üí Filter.Frequently (fun z => LT.lt (slope f x z) r) (nhdsWithin x (Set.Ioi x))\nB B' : Real ‚Üí Real\nha : LE.le (f a) (B a)\nhB : ‚àÄ (x : Real), HasDerivAt B (B' x) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí Eq (f x) (B x) ‚Üí LT.lt (f' x) (B' x)\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (f x) (B x)","decl":"/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ‚â§ B a`;\n* `B` has derivative `B'` everywhere on `‚Ñù`;\n* for each `x ‚àà [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x ‚â§ B x` everywhere on `[a, b]`. -/\ntheorem image_le_of_liminf_slope_right_lt_deriv_boundary {f f' : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}\n    (hf : ContinuousOn f (Icc a b))\n    -- `hf'` actually says `liminf (f z - f x) / (z - x) ‚â§ f' x`\n    (hf' : ‚àÄ x ‚àà Ico a b, ‚àÄ r, f' x < r ‚Üí ‚àÉ·∂† z in ùìù[>] x, slope f x z < r)\n    {B B' : ‚Ñù ‚Üí ‚Ñù} (ha : f a ‚â§ B a) (hB : ‚àÄ x, HasDerivAt B (B' x) x)\n    (bound : ‚àÄ x ‚àà Ico a b, f x = B x ‚Üí f' x < B' x) : ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà Icc a b ‚Üí f x ‚â§ B x :=\n  image_le_of_liminf_slope_right_lt_deriv_boundary' hf hf' ha\n    (fun x _ => (hB x).continuousAt.continuousWithinAt) (fun x _ => (hB x).hasDerivWithinAt) bound\n\n"}
{"name":"image_le_of_liminf_slope_right_le_deriv_boundary","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\na b : Real\nhf : ContinuousOn f (Set.Icc a b)\nB B' : Real ‚Üí Real\nha : LE.le (f a) (B a)\nhB : ContinuousOn B (Set.Icc a b)\nhB' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt B (B' x) (Set.Ici x) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí ‚àÄ (r : Real), LT.lt (B' x) r ‚Üí Filter.Frequently (fun z => LT.lt (slope f x z) r) (nhdsWithin x (Set.Ioi x))\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (f x) (B x)","decl":"/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ‚â§ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* for each `x ‚àà [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by `B'`.\n\nThen `f x ‚â§ B x` everywhere on `[a, b]`. -/\ntheorem image_le_of_liminf_slope_right_le_deriv_boundary {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}\n    (hf : ContinuousOn f (Icc a b)) {B B' : ‚Ñù ‚Üí ‚Ñù} (ha : f a ‚â§ B a) (hB : ContinuousOn B (Icc a b))\n    (hB' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)\n    -- `bound` actually says `liminf (f z - f x) / (z - x) ‚â§ B' x`\n    (bound : ‚àÄ x ‚àà Ico a b, ‚àÄ r, B' x < r ‚Üí ‚àÉ·∂† z in ùìù[>] x, slope f x z < r) :\n    ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà Icc a b ‚Üí f x ‚â§ B x := by\n  have Hr : ‚àÄ x ‚àà Icc a b, ‚àÄ r > 0, f x ‚â§ B x + r * (x - a) := fun x hx r hr => by\n    apply image_le_of_liminf_slope_right_lt_deriv_boundary' hf bound\n    ¬∑ rwa [sub_self, mul_zero, add_zero]\n    ¬∑ exact hB.add (continuousOn_const.mul (continuousOn_id.sub continuousOn_const))\n    ¬∑ intro x hx\n      exact (hB' x hx).add (((hasDerivWithinAt_id x (Ici x)).sub_const a).const_mul r)\n    ¬∑ intro x _ _\n      rw [mul_one]\n      exact (lt_add_iff_pos_right _).2 hr\n    exact hx\n  intro x hx\n  have : ContinuousWithinAt (fun r => B x + r * (x - a)) (Ioi 0) 0 :=\n    continuousWithinAt_const.add (continuousWithinAt_id.mul continuousWithinAt_const)\n  convert continuousWithinAt_const.closure_le _ this (Hr x hx) using 1 <;> simp\n\n"}
{"name":"image_le_of_deriv_right_lt_deriv_boundary'","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f f' : Real ‚Üí Real\na b : Real\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt f (f' x) (Set.Ici x) x\nB B' : Real ‚Üí Real\nha : LE.le (f a) (B a)\nhB : ContinuousOn B (Set.Icc a b)\nhB' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt B (B' x) (Set.Ici x) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí Eq (f x) (B x) ‚Üí LT.lt (f' x) (B' x)\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (f x) (B x)","decl":"/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ‚â§ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x ‚â§ B x` everywhere on `[a, b]`. -/\ntheorem image_le_of_deriv_right_lt_deriv_boundary' {f f' : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}\n    (hf : ContinuousOn f (Icc a b)) (hf' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt f (f' x) (Ici x) x)\n    {B B' : ‚Ñù ‚Üí ‚Ñù} (ha : f a ‚â§ B a) (hB : ContinuousOn B (Icc a b))\n    (hB' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)\n    (bound : ‚àÄ x ‚àà Ico a b, f x = B x ‚Üí f' x < B' x) : ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà Icc a b ‚Üí f x ‚â§ B x :=\n  image_le_of_liminf_slope_right_lt_deriv_boundary' hf\n    (fun x hx _ hr => (hf' x hx).liminf_right_slope_le hr) ha hB hB' bound\n\n"}
{"name":"image_le_of_deriv_right_lt_deriv_boundary","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f f' : Real ‚Üí Real\na b : Real\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt f (f' x) (Set.Ici x) x\nB B' : Real ‚Üí Real\nha : LE.le (f a) (B a)\nhB : ‚àÄ (x : Real), HasDerivAt B (B' x) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí Eq (f x) (B x) ‚Üí LT.lt (f' x) (B' x)\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (f x) (B x)","decl":"/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ‚â§ B a`;\n* `B` has derivative `B'` everywhere on `‚Ñù`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x ‚â§ B x` everywhere on `[a, b]`. -/\ntheorem image_le_of_deriv_right_lt_deriv_boundary {f f' : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}\n    (hf : ContinuousOn f (Icc a b)) (hf' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt f (f' x) (Ici x) x)\n    {B B' : ‚Ñù ‚Üí ‚Ñù} (ha : f a ‚â§ B a) (hB : ‚àÄ x, HasDerivAt B (B' x) x)\n    (bound : ‚àÄ x ‚àà Ico a b, f x = B x ‚Üí f' x < B' x) : ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà Icc a b ‚Üí f x ‚â§ B x :=\n  image_le_of_deriv_right_lt_deriv_boundary' hf hf' ha\n    (fun x _ => (hB x).continuousAt.continuousWithinAt) (fun x _ => (hB x).hasDerivWithinAt) bound\n\n"}
{"name":"image_le_of_deriv_right_le_deriv_boundary","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f f' : Real ‚Üí Real\na b : Real\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt f (f' x) (Set.Ici x) x\nB B' : Real ‚Üí Real\nha : LE.le (f a) (B a)\nhB : ContinuousOn B (Set.Icc a b)\nhB' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt B (B' x) (Set.Ici x) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí LE.le (f' x) (B' x)\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (f x) (B x)","decl":"/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ‚â§ B a`;\n* `B` has derivative `B'` everywhere on `‚Ñù`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x ‚â§ B' x` on `[a, b)`.\n\nThen `f x ‚â§ B x` everywhere on `[a, b]`. -/\ntheorem image_le_of_deriv_right_le_deriv_boundary {f f' : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù}\n    (hf : ContinuousOn f (Icc a b)) (hf' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt f (f' x) (Ici x) x)\n    {B B' : ‚Ñù ‚Üí ‚Ñù} (ha : f a ‚â§ B a) (hB : ContinuousOn B (Icc a b))\n    (hB' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)\n    (bound : ‚àÄ x ‚àà Ico a b, f' x ‚â§ B' x) : ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà Icc a b ‚Üí f x ‚â§ B x :=\n  image_le_of_liminf_slope_right_le_deriv_boundary hf ha hB hB' fun x hx _ hr =>\n    (hf' x hx).liminf_right_slope_le (lt_of_le_of_lt (bound x hx) hr)\n\n"}
{"name":"image_norm_le_of_liminf_right_slope_norm_lt_deriv_boundary","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"a b : Real\nE : Type u_3\ninst‚úù : NormedAddCommGroup E\nf : Real ‚Üí E\nf' : Real ‚Üí Real\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí ‚àÄ (r : Real), LT.lt (f' x) r ‚Üí Filter.Frequently (fun z => LT.lt (slope (Function.comp Norm.norm f) x z) r) (nhdsWithin x (Set.Ioi x))\nB B' : Real ‚Üí Real\nha : LE.le (Norm.norm (f a)) (B a)\nhB : ContinuousOn B (Set.Icc a b)\nhB' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt B (B' x) (Set.Ici x) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí Eq (Norm.norm (f x)) (B x) ‚Üí LT.lt (f' x) (B' x)\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (Norm.norm (f x)) (B x)","decl":"/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `‚Äñf a‚Äñ ‚â§ B a`;\n* `B` has right derivative at every point of `[a, b)`;\n* for each `x ‚àà [a, b)` the right-side limit inferior of `(‚Äñf z‚Äñ - ‚Äñf x‚Äñ) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `‚Äñf x‚Äñ = B x`.\n\nThen `‚Äñf x‚Äñ ‚â§ B x` everywhere on `[a, b]`. -/\ntheorem image_norm_le_of_liminf_right_slope_norm_lt_deriv_boundary {E : Type*}\n    [NormedAddCommGroup E] {f : ‚Ñù ‚Üí E} {f' : ‚Ñù ‚Üí ‚Ñù} (hf : ContinuousOn f (Icc a b))\n    -- `hf'` actually says `liminf (‚Äñf z‚Äñ - ‚Äñf x‚Äñ) / (z - x) ‚â§ f' x`\n    (hf' : ‚àÄ x ‚àà Ico a b, ‚àÄ r, f' x < r ‚Üí ‚àÉ·∂† z in ùìù[>] x, slope (norm ‚àò f) x z < r)\n    {B B' : ‚Ñù ‚Üí ‚Ñù} (ha : ‚Äñf a‚Äñ ‚â§ B a) (hB : ContinuousOn B (Icc a b))\n    (hB' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)\n    (bound : ‚àÄ x ‚àà Ico a b, ‚Äñf x‚Äñ = B x ‚Üí f' x < B' x) : ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà Icc a b ‚Üí ‚Äñf x‚Äñ ‚â§ B x :=\n  image_le_of_liminf_slope_right_lt_deriv_boundary' (continuous_norm.comp_continuousOn hf) hf' ha hB\n    hB' bound\n\n"}
{"name":"image_norm_le_of_norm_deriv_right_lt_deriv_boundary'","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Real ‚Üí E\na b : Real\nf' : Real ‚Üí E\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt f (f' x) (Set.Ici x) x\nB B' : Real ‚Üí Real\nha : LE.le (Norm.norm (f a)) (B a)\nhB : ContinuousOn B (Set.Icc a b)\nhB' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt B (B' x) (Set.Ici x) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí Eq (Norm.norm (f x)) (B x) ‚Üí LT.lt (Norm.norm (f' x)) (B' x)\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (Norm.norm (f x)) (B x)","decl":"/-- General fencing theorem for continuous functions with an estimate on the norm of the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `‚Äñf a‚Äñ ‚â§ B a`;\n* `f` and `B` have right derivatives `f'` and `B'` respectively at every point of `[a, b)`;\n* the norm of `f'` is strictly less than `B'` whenever `‚Äñf x‚Äñ = B x`.\n\nThen `‚Äñf x‚Äñ ‚â§ B x` everywhere on `[a, b]`. We use one-sided derivatives in the assumptions\nto make this theorem work for piecewise differentiable functions.\n-/\ntheorem image_norm_le_of_norm_deriv_right_lt_deriv_boundary' {f' : ‚Ñù ‚Üí E}\n    (hf : ContinuousOn f (Icc a b)) (hf' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt f (f' x) (Ici x) x)\n    {B B' : ‚Ñù ‚Üí ‚Ñù} (ha : ‚Äñf a‚Äñ ‚â§ B a) (hB : ContinuousOn B (Icc a b))\n    (hB' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)\n    (bound : ‚àÄ x ‚àà Ico a b, ‚Äñf x‚Äñ = B x ‚Üí ‚Äñf' x‚Äñ < B' x) : ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà Icc a b ‚Üí ‚Äñf x‚Äñ ‚â§ B x :=\n  image_norm_le_of_liminf_right_slope_norm_lt_deriv_boundary hf\n    (fun x hx _ hr => (hf' x hx).liminf_right_slope_norm_le hr) ha hB hB' bound\n\n"}
{"name":"image_norm_le_of_norm_deriv_right_lt_deriv_boundary","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Real ‚Üí E\na b : Real\nf' : Real ‚Üí E\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt f (f' x) (Set.Ici x) x\nB B' : Real ‚Üí Real\nha : LE.le (Norm.norm (f a)) (B a)\nhB : ‚àÄ (x : Real), HasDerivAt B (B' x) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí Eq (Norm.norm (f x)) (B x) ‚Üí LT.lt (Norm.norm (f' x)) (B' x)\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (Norm.norm (f x)) (B x)","decl":"/-- General fencing theorem for continuous functions with an estimate on the norm of the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `‚Äñf a‚Äñ ‚â§ B a`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* `B` has derivative `B'` everywhere on `‚Ñù`;\n* the norm of `f'` is strictly less than `B'` whenever `‚Äñf x‚Äñ = B x`.\n\nThen `‚Äñf x‚Äñ ‚â§ B x` everywhere on `[a, b]`. We use one-sided derivatives in the assumptions\nto make this theorem work for piecewise differentiable functions.\n-/\ntheorem image_norm_le_of_norm_deriv_right_lt_deriv_boundary {f' : ‚Ñù ‚Üí E}\n    (hf : ContinuousOn f (Icc a b)) (hf' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt f (f' x) (Ici x) x)\n    {B B' : ‚Ñù ‚Üí ‚Ñù} (ha : ‚Äñf a‚Äñ ‚â§ B a) (hB : ‚àÄ x, HasDerivAt B (B' x) x)\n    (bound : ‚àÄ x ‚àà Ico a b, ‚Äñf x‚Äñ = B x ‚Üí ‚Äñf' x‚Äñ < B' x) : ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà Icc a b ‚Üí ‚Äñf x‚Äñ ‚â§ B x :=\n  image_norm_le_of_norm_deriv_right_lt_deriv_boundary' hf hf' ha\n    (fun x _ => (hB x).continuousAt.continuousWithinAt) (fun x _ => (hB x).hasDerivWithinAt) bound\n\n"}
{"name":"image_norm_le_of_norm_deriv_right_le_deriv_boundary'","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Real ‚Üí E\na b : Real\nf' : Real ‚Üí E\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt f (f' x) (Set.Ici x) x\nB B' : Real ‚Üí Real\nha : LE.le (Norm.norm (f a)) (B a)\nhB : ContinuousOn B (Set.Icc a b)\nhB' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt B (B' x) (Set.Ici x) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí LE.le (Norm.norm (f' x)) (B' x)\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (Norm.norm (f x)) (B x)","decl":"/-- General fencing theorem for continuous functions with an estimate on the norm of the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `‚Äñf a‚Äñ ‚â§ B a`;\n* `f` and `B` have right derivatives `f'` and `B'` respectively at every point of `[a, b)`;\n* we have `‚Äñf' x‚Äñ ‚â§ B x` everywhere on `[a, b)`.\n\nThen `‚Äñf x‚Äñ ‚â§ B x` everywhere on `[a, b]`. We use one-sided derivatives in the assumptions\nto make this theorem work for piecewise differentiable functions.\n-/\ntheorem image_norm_le_of_norm_deriv_right_le_deriv_boundary' {f' : ‚Ñù ‚Üí E}\n    (hf : ContinuousOn f (Icc a b)) (hf' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt f (f' x) (Ici x) x)\n    {B B' : ‚Ñù ‚Üí ‚Ñù} (ha : ‚Äñf a‚Äñ ‚â§ B a) (hB : ContinuousOn B (Icc a b))\n    (hB' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt B (B' x) (Ici x) x)\n    (bound : ‚àÄ x ‚àà Ico a b, ‚Äñf' x‚Äñ ‚â§ B' x) : ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà Icc a b ‚Üí ‚Äñf x‚Äñ ‚â§ B x :=\n  image_le_of_liminf_slope_right_le_deriv_boundary (continuous_norm.comp_continuousOn hf) ha hB hB'\n    fun x hx _ hr => (hf' x hx).liminf_right_slope_norm_le ((bound x hx).trans_lt hr)\n\n"}
{"name":"image_norm_le_of_norm_deriv_right_le_deriv_boundary","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Real ‚Üí E\na b : Real\nf' : Real ‚Üí E\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt f (f' x) (Set.Ici x) x\nB B' : Real ‚Üí Real\nha : LE.le (Norm.norm (f a)) (B a)\nhB : ‚àÄ (x : Real), HasDerivAt B (B' x) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí LE.le (Norm.norm (f' x)) (B' x)\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (Norm.norm (f x)) (B x)","decl":"/-- General fencing theorem for continuous functions with an estimate on the norm of the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `‚Äñf a‚Äñ ‚â§ B a`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* `B` has derivative `B'` everywhere on `‚Ñù`;\n* we have `‚Äñf' x‚Äñ ‚â§ B x` everywhere on `[a, b)`.\n\nThen `‚Äñf x‚Äñ ‚â§ B x` everywhere on `[a, b]`. We use one-sided derivatives in the assumptions\nto make this theorem work for piecewise differentiable functions.\n-/\ntheorem image_norm_le_of_norm_deriv_right_le_deriv_boundary {f' : ‚Ñù ‚Üí E}\n    (hf : ContinuousOn f (Icc a b)) (hf' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt f (f' x) (Ici x) x)\n    {B B' : ‚Ñù ‚Üí ‚Ñù} (ha : ‚Äñf a‚Äñ ‚â§ B a) (hB : ‚àÄ x, HasDerivAt B (B' x) x)\n    (bound : ‚àÄ x ‚àà Ico a b, ‚Äñf' x‚Äñ ‚â§ B' x) : ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà Icc a b ‚Üí ‚Äñf x‚Äñ ‚â§ B x :=\n  image_norm_le_of_norm_deriv_right_le_deriv_boundary' hf hf' ha\n    (fun x _ => (hB x).continuousAt.continuousWithinAt) (fun x _ => (hB x).hasDerivWithinAt) bound\n\n"}
{"name":"norm_image_sub_le_of_norm_deriv_right_le_segment","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Real ‚Üí E\na b : Real\nf' : Real ‚Üí E\nC : Real\nhf : ContinuousOn f (Set.Icc a b)\nhf' : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt f (f' x) (Set.Ici x) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí LE.le (Norm.norm (f' x)) C\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (Norm.norm (HSub.hSub (f x) (f a))) (HMul.hMul C (HSub.hSub x a))","decl":"/-- A function on `[a, b]` with the norm of the right derivative bounded by `C`\nsatisfies `‚Äñf x - f a‚Äñ ‚â§ C * (x - a)`. -/\ntheorem norm_image_sub_le_of_norm_deriv_right_le_segment {f' : ‚Ñù ‚Üí E} {C : ‚Ñù}\n    (hf : ContinuousOn f (Icc a b)) (hf' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt f (f' x) (Ici x) x)\n    (bound : ‚àÄ x ‚àà Ico a b, ‚Äñf' x‚Äñ ‚â§ C) : ‚àÄ x ‚àà Icc a b, ‚Äñf x - f a‚Äñ ‚â§ C * (x - a) := by\n  let g x := f x - f a\n  have hg : ContinuousOn g (Icc a b) := hf.sub continuousOn_const\n  have hg' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt g (f' x) (Ici x) x := by\n    intro x hx\n    simpa using (hf' x hx).sub (hasDerivWithinAt_const _ _ _)\n  let B x := C * (x - a)\n  have hB : ‚àÄ x, HasDerivAt B C x := by\n    intro x\n    simpa using (hasDerivAt_const x C).mul ((hasDerivAt_id x).sub (hasDerivAt_const x a))\n  convert image_norm_le_of_norm_deriv_right_le_deriv_boundary hg hg' _ hB bound\n  simp only [g, B]; rw [sub_self, norm_zero, sub_self, mul_zero]\n\n"}
{"name":"norm_image_sub_le_of_norm_deriv_le_segment'","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Real ‚Üí E\na b : Real\nf' : Real ‚Üí E\nC : Real\nhf : ‚àÄ (x : Real), Membership.mem (Set.Icc a b) x ‚Üí HasDerivWithinAt f (f' x) (Set.Icc a b) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí LE.le (Norm.norm (f' x)) C\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (Norm.norm (HSub.hSub (f x) (f a))) (HMul.hMul C (HSub.hSub x a))","decl":"/-- A function on `[a, b]` with the norm of the derivative within `[a, b]`\nbounded by `C` satisfies `‚Äñf x - f a‚Äñ ‚â§ C * (x - a)`, `HasDerivWithinAt`\nversion. -/\ntheorem norm_image_sub_le_of_norm_deriv_le_segment' {f' : ‚Ñù ‚Üí E} {C : ‚Ñù}\n    (hf : ‚àÄ x ‚àà Icc a b, HasDerivWithinAt f (f' x) (Icc a b) x)\n    (bound : ‚àÄ x ‚àà Ico a b, ‚Äñf' x‚Äñ ‚â§ C) : ‚àÄ x ‚àà Icc a b, ‚Äñf x - f a‚Äñ ‚â§ C * (x - a) := by\n  refine\n    norm_image_sub_le_of_norm_deriv_right_le_segment (fun x hx => (hf x hx).continuousWithinAt)\n      (fun x hx => ?_) bound\n  exact (hf x <| Ico_subset_Icc_self hx).mono_of_mem_nhdsWithin (Icc_mem_nhdsGE_of_mem hx)\n\n"}
{"name":"norm_image_sub_le_of_norm_deriv_le_segment","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Real ‚Üí E\na b C : Real\nhf : DifferentiableOn Real f (Set.Icc a b)\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí LE.le (Norm.norm (derivWithin f (Set.Icc a b) x)) C\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ LE.le (Norm.norm (HSub.hSub (f x) (f a))) (HMul.hMul C (HSub.hSub x a))","decl":"/-- A function on `[a, b]` with the norm of the derivative within `[a, b]`\nbounded by `C` satisfies `‚Äñf x - f a‚Äñ ‚â§ C * (x - a)`, `derivWithin`\nversion. -/\ntheorem norm_image_sub_le_of_norm_deriv_le_segment {C : ‚Ñù} (hf : DifferentiableOn ‚Ñù f (Icc a b))\n    (bound : ‚àÄ x ‚àà Ico a b, ‚ÄñderivWithin f (Icc a b) x‚Äñ ‚â§ C) :\n    ‚àÄ x ‚àà Icc a b, ‚Äñf x - f a‚Äñ ‚â§ C * (x - a) := by\n  refine norm_image_sub_le_of_norm_deriv_le_segment' ?_ bound\n  exact fun x hx => (hf x hx).hasDerivWithinAt\n\n"}
{"name":"norm_image_sub_le_of_norm_deriv_le_segment_01'","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf f' : Real ‚Üí E\nC : Real\nhf : ‚àÄ (x : Real), Membership.mem (Set.Icc 0 1) x ‚Üí HasDerivWithinAt f (f' x) (Set.Icc 0 1) x\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico 0 1) x ‚Üí LE.le (Norm.norm (f' x)) C\n‚ä¢ LE.le (Norm.norm (HSub.hSub (f 1) (f 0))) C","decl":"/-- A function on `[0, 1]` with the norm of the derivative within `[0, 1]`\nbounded by `C` satisfies `‚Äñf 1 - f 0‚Äñ ‚â§ C`, `HasDerivWithinAt`\nversion. -/\ntheorem norm_image_sub_le_of_norm_deriv_le_segment_01' {f' : ‚Ñù ‚Üí E} {C : ‚Ñù}\n    (hf : ‚àÄ x ‚àà Icc (0 : ‚Ñù) 1, HasDerivWithinAt f (f' x) (Icc (0 : ‚Ñù) 1) x)\n    (bound : ‚àÄ x ‚àà Ico (0 : ‚Ñù) 1, ‚Äñf' x‚Äñ ‚â§ C) : ‚Äñf 1 - f 0‚Äñ ‚â§ C := by\n  simpa only [sub_zero, mul_one] using\n    norm_image_sub_le_of_norm_deriv_le_segment' hf bound 1 (right_mem_Icc.2 zero_le_one)\n\n"}
{"name":"norm_image_sub_le_of_norm_deriv_le_segment_01","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Real ‚Üí E\nC : Real\nhf : DifferentiableOn Real f (Set.Icc 0 1)\nbound : ‚àÄ (x : Real), Membership.mem (Set.Ico 0 1) x ‚Üí LE.le (Norm.norm (derivWithin f (Set.Icc 0 1) x)) C\n‚ä¢ LE.le (Norm.norm (HSub.hSub (f 1) (f 0))) C","decl":"/-- A function on `[0, 1]` with the norm of the derivative within `[0, 1]`\nbounded by `C` satisfies `‚Äñf 1 - f 0‚Äñ ‚â§ C`, `derivWithin` version. -/\ntheorem norm_image_sub_le_of_norm_deriv_le_segment_01 {C : ‚Ñù}\n    (hf : DifferentiableOn ‚Ñù f (Icc (0 : ‚Ñù) 1))\n    (bound : ‚àÄ x ‚àà Ico (0 : ‚Ñù) 1, ‚ÄñderivWithin f (Icc (0 : ‚Ñù) 1) x‚Äñ ‚â§ C) : ‚Äñf 1 - f 0‚Äñ ‚â§ C := by\n  simpa only [sub_zero, mul_one] using\n    norm_image_sub_le_of_norm_deriv_le_segment hf bound 1 (right_mem_Icc.2 zero_le_one)\n\n"}
{"name":"constant_of_has_deriv_right_zero","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Real ‚Üí E\na b : Real\nhcont : ContinuousOn f (Set.Icc a b)\nhderiv : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt f 0 (Set.Ici x) x\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ Eq (f x) (f a)","decl":"theorem constant_of_has_deriv_right_zero (hcont : ContinuousOn f (Icc a b))\n    (hderiv : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt f 0 (Ici x) x) : ‚àÄ x ‚àà Icc a b, f x = f a := by\n  have : ‚àÄ x ‚àà Icc a b, ‚Äñf x - f a‚Äñ ‚â§ 0 * (x - a) := fun x hx =>\n    norm_image_sub_le_of_norm_deriv_right_le_segment hcont hderiv (fun _ _ => norm_zero.le) x hx\n  simpa only [zero_mul, norm_le_zero_iff, sub_eq_zero] using this\n\n"}
{"name":"constant_of_derivWithin_zero","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Real ‚Üí E\na b : Real\nhdiff : DifferentiableOn Real f (Set.Icc a b)\nhderiv : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí Eq (derivWithin f (Set.Icc a b) x) 0\nx : Real\na‚úù : Membership.mem (Set.Icc a b) x\n‚ä¢ Eq (f x) (f a)","decl":"theorem constant_of_derivWithin_zero (hdiff : DifferentiableOn ‚Ñù f (Icc a b))\n    (hderiv : ‚àÄ x ‚àà Ico a b, derivWithin f (Icc a b) x = 0) : ‚àÄ x ‚àà Icc a b, f x = f a := by\n  have H : ‚àÄ x ‚àà Ico a b, ‚ÄñderivWithin f (Icc a b) x‚Äñ ‚â§ 0 := by\n    simpa only [norm_le_zero_iff] using fun x hx => hderiv x hx\n  simpa only [zero_mul, norm_le_zero_iff, sub_eq_zero] using fun x hx =>\n    norm_image_sub_le_of_norm_deriv_le_segment hdiff H x hx\n\n"}
{"name":"eq_of_has_deriv_right_eq","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Real ‚Üí E\na b : Real\nf' g : Real ‚Üí E\nderivf : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt f (f' x) (Set.Ici x) x\nderivg : ‚àÄ (x : Real), Membership.mem (Set.Ico a b) x ‚Üí HasDerivWithinAt g (f' x) (Set.Ici x) x\nfcont : ContinuousOn f (Set.Icc a b)\ngcont : ContinuousOn g (Set.Icc a b)\nhi : Eq (f a) (g a)\ny : Real\na‚úù : Membership.mem (Set.Icc a b) y\n‚ä¢ Eq (f y) (g y)","decl":"/-- If two continuous functions on `[a, b]` have the same right derivative and are equal at `a`,\n  then they are equal everywhere on `[a, b]`. -/\ntheorem eq_of_has_deriv_right_eq (derivf : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt f (f' x) (Ici x) x)\n    (derivg : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt g (f' x) (Ici x) x) (fcont : ContinuousOn f (Icc a b))\n    (gcont : ContinuousOn g (Icc a b)) (hi : f a = g a) : ‚àÄ y ‚àà Icc a b, f y = g y := by\n  simp only [‚Üê @sub_eq_zero _ _ (f _)] at hi ‚ä¢\n  exact hi ‚ñ∏ constant_of_has_deriv_right_zero (fcont.sub gcont) fun y hy => by\n    simpa only [sub_self] using (derivf y hy).sub (derivg y hy)\n\n"}
{"name":"eq_of_derivWithin_eq","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : Real ‚Üí E\na b : Real\ng : Real ‚Üí E\nfdiff : DifferentiableOn Real f (Set.Icc a b)\ngdiff : DifferentiableOn Real g (Set.Icc a b)\nhderiv : Set.EqOn (derivWithin f (Set.Icc a b)) (derivWithin g (Set.Icc a b)) (Set.Ico a b)\nhi : Eq (f a) (g a)\ny : Real\na‚úù : Membership.mem (Set.Icc a b) y\n‚ä¢ Eq (f y) (g y)","decl":"/-- If two differentiable functions on `[a, b]` have the same derivative within `[a, b]` everywhere\n  on `[a, b)` and are equal at `a`, then they are equal everywhere on `[a, b]`. -/\ntheorem eq_of_derivWithin_eq (fdiff : DifferentiableOn ‚Ñù f (Icc a b))\n    (gdiff : DifferentiableOn ‚Ñù g (Icc a b))\n    (hderiv : EqOn (derivWithin f (Icc a b)) (derivWithin g (Icc a b)) (Ico a b)) (hi : f a = g a) :\n    ‚àÄ y ‚àà Icc a b, f y = g y := by\n  have A : ‚àÄ y ‚àà Ico a b, HasDerivWithinAt f (derivWithin f (Icc a b) y) (Ici y) y := fun y hy =>\n    (fdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.mono_of_mem_nhdsWithin\n    (Icc_mem_nhdsGE_of_mem hy)\n  have B : ‚àÄ y ‚àà Ico a b, HasDerivWithinAt g (derivWithin g (Icc a b) y) (Ici y) y := fun y hy =>\n    (gdiff y (mem_Icc_of_Ico hy)).hasDerivWithinAt.mono_of_mem_nhdsWithin\n    (Icc_mem_nhdsGE_of_mem hy)\n  exact eq_of_has_deriv_right_eq A (fun y hy => (hderiv hy).symm ‚ñ∏ B y hy) fdiff.continuousOn\n    gdiff.continuousOn hi\n\n"}
{"name":"Convex.instPathConnectedSpace","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\ninst‚úù : NontriviallyNormedField ùïú\n‚ä¢ PathConnectedSpace ùïú","decl":"instance (priority := 100) : PathConnectedSpace ùïú := by\n  letI : RCLike ùïú := IsRCLikeNormedField.rclike ùïú\n  infer_instance\n\n"}
{"name":"Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nùïú : Type u_3\nG : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : E ‚Üí G\nC : Real\ns : Set E\nx y : E\nf' : E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\nhf : ‚àÄ (x : E), Membership.mem s x ‚Üí HasFDerivWithinAt f (f' x) s x\nbound : ‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (Norm.norm (f' x)) C\nhs : Convex Real s\nxs : Membership.mem s x\nys : Membership.mem s y\n‚ä¢ LE.le (Norm.norm (HSub.hSub (f y) (f x))) (HMul.hMul C (Norm.norm (HSub.hSub y x)))","decl":"/-- The mean value theorem on a convex set: if the derivative of a function is bounded by `C`, then\nthe function is `C`-Lipschitz. Version with `HasFDerivWithinAt`. -/\ntheorem norm_image_sub_le_of_norm_hasFDerivWithin_le\n    (hf : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) (bound : ‚àÄ x ‚àà s, ‚Äñf' x‚Äñ ‚â§ C) (hs : Convex ‚Ñù s)\n    (xs : x ‚àà s) (ys : y ‚àà s) : ‚Äñf y - f x‚Äñ ‚â§ C * ‚Äñy - x‚Äñ := by\n  letI : RCLike ùïú := IsRCLikeNormedField.rclike ùïú\n  letI : NormedSpace ‚Ñù G := RestrictScalars.normedSpace ‚Ñù ùïú G\n  /- By composition with `AffineMap.lineMap x y`, we reduce to a statement for functions defined\n    on `[0,1]`, for which it is proved in `norm_image_sub_le_of_norm_deriv_le_segment`.\n    We just have to check the differentiability of the composition and bounds on its derivative,\n    which is straightforward but tedious for lack of automation. -/\n  set g := (AffineMap.lineMap x y : ‚Ñù ‚Üí E)\n  have segm : MapsTo g (Icc 0 1 : Set ‚Ñù) s := hs.mapsTo_lineMap xs ys\n  have hD : ‚àÄ t ‚àà Icc (0 : ‚Ñù) 1,\n      HasDerivWithinAt (f ‚àò g) (f' (g t) (y - x)) (Icc 0 1) t := fun t ht => by\n    simpa using ((hf (g t) (segm ht)).restrictScalars ‚Ñù).comp_hasDerivWithinAt _\n      AffineMap.hasDerivWithinAt_lineMap segm\n  have bound : ‚àÄ t ‚àà Ico (0 : ‚Ñù) 1, ‚Äñf' (g t) (y - x)‚Äñ ‚â§ C * ‚Äñy - x‚Äñ := fun t ht =>\n    le_of_opNorm_le _ (bound _ <| segm <| Ico_subset_Icc_self ht) _\n  simpa [g] using norm_image_sub_le_of_norm_deriv_le_segment_01' hD bound\n\n"}
{"name":"Convex.lipschitzOnWith_of_nnnorm_hasFDerivWithin_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nùïú : Type u_3\nG : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : E ‚Üí G\ns : Set E\nf' : E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\nC : NNReal\nhf : ‚àÄ (x : E), Membership.mem s x ‚Üí HasFDerivWithinAt f (f' x) s x\nbound : ‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (NNNorm.nnnorm (f' x)) C\nhs : Convex Real s\n‚ä¢ LipschitzOnWith C f s","decl":"/-- The mean value theorem on a convex set: if the derivative of a function is bounded by `C` on\n`s`, then the function is `C`-Lipschitz on `s`. Version with `HasFDerivWithinAt` and\n`LipschitzOnWith`. -/\ntheorem lipschitzOnWith_of_nnnorm_hasFDerivWithin_le {C : ‚Ñù‚â•0}\n    (hf : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) (bound : ‚àÄ x ‚àà s, ‚Äñf' x‚Äñ‚Çä ‚â§ C)\n    (hs : Convex ‚Ñù s) : LipschitzOnWith C f s := by\n  rw [lipschitzOnWith_iff_norm_sub_le]\n  intro x x_in y y_in\n  exact hs.norm_image_sub_le_of_norm_hasFDerivWithin_le hf bound y_in x_in\n\n"}
{"name":"Convex.exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt_of_nnnorm_lt","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nùïú : Type u_3\nG : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\ns : Set E\nx : E\nf' : E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\nhs : Convex Real s\nf : E ‚Üí G\nhder : Filter.Eventually (fun y => HasFDerivWithinAt f (f' y) s y) (nhdsWithin x s)\nhcont : ContinuousWithinAt f' s x\nK : NNReal\nhK : LT.lt (NNNorm.nnnorm (f' x)) K\n‚ä¢ Exists fun t => And (Membership.mem (nhdsWithin x s) t) (LipschitzOnWith K f t)","decl":"/-- Let `s` be a convex set in a real normed vector space `E`, let `f : E ‚Üí G` be a function\ndifferentiable within `s` in a neighborhood of `x : E` with derivative `f'`. Suppose that `f'` is\ncontinuous within `s` at `x`. Then for any number `K : ‚Ñù‚â•0` larger than `‚Äñf' x‚Äñ‚Çä`, `f` is\n`K`-Lipschitz on some neighborhood of `x` within `s`. See also\n`Convex.exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt` for a version that claims\nexistence of `K` instead of an explicit estimate. -/\ntheorem exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt_of_nnnorm_lt (hs : Convex ‚Ñù s)\n    {f : E ‚Üí G} (hder : ‚àÄ·∂† y in ùìù[s] x, HasFDerivWithinAt f (f' y) s y)\n    (hcont : ContinuousWithinAt f' s x) (K : ‚Ñù‚â•0) (hK : ‚Äñf' x‚Äñ‚Çä < K) :\n    ‚àÉ t ‚àà ùìù[s] x, LipschitzOnWith K f t := by\n  obtain ‚ü®Œµ, Œµ0, hŒµ‚ü© : ‚àÉ Œµ > 0,\n      ball x Œµ ‚à© s ‚äÜ { y | HasFDerivWithinAt f (f' y) s y ‚àß ‚Äñf' y‚Äñ‚Çä < K } :=\n    mem_nhdsWithin_iff.1 (hder.and <| hcont.nnnorm.eventually (gt_mem_nhds hK))\n  rw [inter_comm] at hŒµ\n  refine ‚ü®s ‚à© ball x Œµ, inter_mem_nhdsWithin _ (ball_mem_nhds _ Œµ0), ?_‚ü©\n  exact\n    (hs.inter (convex_ball _ _)).lipschitzOnWith_of_nnnorm_hasFDerivWithin_le\n      (fun y hy => (hŒµ hy).1.mono inter_subset_left) fun y hy => (hŒµ hy).2.le\n\n"}
{"name":"Convex.exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nùïú : Type u_3\nG : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\ns : Set E\nx : E\nf' : E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\nhs : Convex Real s\nf : E ‚Üí G\nhder : Filter.Eventually (fun y => HasFDerivWithinAt f (f' y) s y) (nhdsWithin x s)\nhcont : ContinuousWithinAt f' s x\n‚ä¢ Exists fun K => Exists fun t => And (Membership.mem (nhdsWithin x s) t) (LipschitzOnWith K f t)","decl":"/-- Let `s` be a convex set in a real normed vector space `E`, let `f : E ‚Üí G` be a function\ndifferentiable within `s` in a neighborhood of `x : E` with derivative `f'`. Suppose that `f'` is\ncontinuous within `s` at `x`. Then for any number `K : ‚Ñù‚â•0` larger than `‚Äñf' x‚Äñ‚Çä`, `f` is Lipschitz\non some neighborhood of `x` within `s`. See also\n`Convex.exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt_of_nnnorm_lt` for a version\nwith an explicit estimate on the Lipschitz constant. -/\ntheorem exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt (hs : Convex ‚Ñù s) {f : E ‚Üí G}\n    (hder : ‚àÄ·∂† y in ùìù[s] x, HasFDerivWithinAt f (f' y) s y) (hcont : ContinuousWithinAt f' s x) :\n    ‚àÉ K, ‚àÉ t ‚àà ùìù[s] x, LipschitzOnWith K f t :=\n  (exists_gt _).imp <|\n    hs.exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt_of_nnnorm_lt hder hcont\n\n"}
{"name":"Convex.norm_image_sub_le_of_norm_fderivWithin_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nùïú : Type u_3\nG : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : E ‚Üí G\nC : Real\ns : Set E\nx y : E\nhf : DifferentiableOn ùïú f s\nbound : ‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (Norm.norm (fderivWithin ùïú f s x)) C\nhs : Convex Real s\nxs : Membership.mem s x\nys : Membership.mem s y\n‚ä¢ LE.le (Norm.norm (HSub.hSub (f y) (f x))) (HMul.hMul C (Norm.norm (HSub.hSub y x)))","decl":"/-- The mean value theorem on a convex set: if the derivative of a function within this set is\nbounded by `C`, then the function is `C`-Lipschitz. Version with `fderivWithin`. -/\ntheorem norm_image_sub_le_of_norm_fderivWithin_le (hf : DifferentiableOn ùïú f s)\n    (bound : ‚àÄ x ‚àà s, ‚ÄñfderivWithin ùïú f s x‚Äñ ‚â§ C) (hs : Convex ‚Ñù s) (xs : x ‚àà s) (ys : y ‚àà s) :\n    ‚Äñf y - f x‚Äñ ‚â§ C * ‚Äñy - x‚Äñ :=\n  hs.norm_image_sub_le_of_norm_hasFDerivWithin_le (fun x hx => (hf x hx).hasFDerivWithinAt) bound\n    xs ys\n\n"}
{"name":"Convex.lipschitzOnWith_of_nnnorm_fderivWithin_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nùïú : Type u_3\nG : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : E ‚Üí G\ns : Set E\nC : NNReal\nhf : DifferentiableOn ùïú f s\nbound : ‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (NNNorm.nnnorm (fderivWithin ùïú f s x)) C\nhs : Convex Real s\n‚ä¢ LipschitzOnWith C f s","decl":"/-- The mean value theorem on a convex set: if the derivative of a function is bounded by `C` on\n`s`, then the function is `C`-Lipschitz on `s`. Version with `fderivWithin` and\n`LipschitzOnWith`. -/\ntheorem lipschitzOnWith_of_nnnorm_fderivWithin_le {C : ‚Ñù‚â•0} (hf : DifferentiableOn ùïú f s)\n    (bound : ‚àÄ x ‚àà s, ‚ÄñfderivWithin ùïú f s x‚Äñ‚Çä ‚â§ C) (hs : Convex ‚Ñù s) : LipschitzOnWith C f s :=\n  hs.lipschitzOnWith_of_nnnorm_hasFDerivWithin_le (fun x hx => (hf x hx).hasFDerivWithinAt) bound\n\n"}
{"name":"Convex.norm_image_sub_le_of_norm_fderiv_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nùïú : Type u_3\nG : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : E ‚Üí G\nC : Real\ns : Set E\nx y : E\nhf : ‚àÄ (x : E), Membership.mem s x ‚Üí DifferentiableAt ùïú f x\nbound : ‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (Norm.norm (fderiv ùïú f x)) C\nhs : Convex Real s\nxs : Membership.mem s x\nys : Membership.mem s y\n‚ä¢ LE.le (Norm.norm (HSub.hSub (f y) (f x))) (HMul.hMul C (Norm.norm (HSub.hSub y x)))","decl":"/-- The mean value theorem on a convex set: if the derivative of a function is bounded by `C`,\nthen the function is `C`-Lipschitz. Version with `fderiv`. -/\ntheorem norm_image_sub_le_of_norm_fderiv_le (hf : ‚àÄ x ‚àà s, DifferentiableAt ùïú f x)\n    (bound : ‚àÄ x ‚àà s, ‚Äñfderiv ùïú f x‚Äñ ‚â§ C) (hs : Convex ‚Ñù s) (xs : x ‚àà s) (ys : y ‚àà s) :\n    ‚Äñf y - f x‚Äñ ‚â§ C * ‚Äñy - x‚Äñ :=\n  hs.norm_image_sub_le_of_norm_hasFDerivWithin_le\n    (fun x hx => (hf x hx).hasFDerivAt.hasFDerivWithinAt) bound xs ys\n\n"}
{"name":"Convex.lipschitzOnWith_of_nnnorm_fderiv_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nùïú : Type u_3\nG : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : E ‚Üí G\ns : Set E\nC : NNReal\nhf : ‚àÄ (x : E), Membership.mem s x ‚Üí DifferentiableAt ùïú f x\nbound : ‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (NNNorm.nnnorm (fderiv ùïú f x)) C\nhs : Convex Real s\n‚ä¢ LipschitzOnWith C f s","decl":"/-- The mean value theorem on a convex set: if the derivative of a function is bounded by `C` on\n`s`, then the function is `C`-Lipschitz on `s`. Version with `fderiv` and `LipschitzOnWith`. -/\ntheorem lipschitzOnWith_of_nnnorm_fderiv_le {C : ‚Ñù‚â•0} (hf : ‚àÄ x ‚àà s, DifferentiableAt ùïú f x)\n    (bound : ‚àÄ x ‚àà s, ‚Äñfderiv ùïú f x‚Äñ‚Çä ‚â§ C) (hs : Convex ‚Ñù s) : LipschitzOnWith C f s :=\n  hs.lipschitzOnWith_of_nnnorm_hasFDerivWithin_le\n    (fun x hx => (hf x hx).hasFDerivAt.hasFDerivWithinAt) bound\n\n"}
{"name":"lipschitzWith_of_nnnorm_fderiv_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\nG : Type u_4\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : IsRCLikeNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace ùïú G\nE : Type u_5\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace ùïú E\nf : E ‚Üí G\nC : NNReal\nhf : Differentiable ùïú f\nbound : ‚àÄ (x : E), LE.le (NNNorm.nnnorm (fderiv ùïú f x)) C\n‚ä¢ LipschitzWith C f","decl":"/-- The mean value theorem: if the derivative of a function is bounded by `C`, then the function is\n`C`-Lipschitz. Version with `fderiv` and `LipschitzWith`. -/\ntheorem _root_.lipschitzWith_of_nnnorm_fderiv_le\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace ùïú E] {f : E ‚Üí G}\n    {C : ‚Ñù‚â•0} (hf : Differentiable ùïú f)\n    (bound : ‚àÄ x, ‚Äñfderiv ùïú f x‚Äñ‚Çä ‚â§ C) : LipschitzWith C f := by\n  letI : RCLike ùïú := IsRCLikeNormedField.rclike ùïú\n  let A : NormedSpace ‚Ñù E := RestrictScalars.normedSpace ‚Ñù ùïú E\n  rw [‚Üê lipschitzOnWith_univ]\n  exact lipschitzOnWith_of_nnnorm_fderiv_le (fun x _ ‚Ü¶ hf x) (fun x _ ‚Ü¶ bound x) convex_univ\n\n"}
{"name":"Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le'","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nùïú : Type u_3\nG : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : E ‚Üí G\nC : Real\ns : Set E\nx y : E\nf' : E ‚Üí ContinuousLinearMap (RingHom.id ùïú) E G\nœÜ : ContinuousLinearMap (RingHom.id ùïú) E G\nhf : ‚àÄ (x : E), Membership.mem s x ‚Üí HasFDerivWithinAt f (f' x) s x\nbound : ‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (Norm.norm (HSub.hSub (f' x) œÜ)) C\nhs : Convex Real s\nxs : Membership.mem s x\nys : Membership.mem s y\n‚ä¢ LE.le (Norm.norm (HSub.hSub (HSub.hSub (f y) (f x)) (œÜ (HSub.hSub y x)))) (HMul.hMul C (Norm.norm (HSub.hSub y x)))","decl":"/-- Variant of the mean value inequality on a convex set, using a bound on the difference between\nthe derivative and a fixed linear map, rather than a bound on the derivative itself. Version with\n`HasFDerivWithinAt`. -/\ntheorem norm_image_sub_le_of_norm_hasFDerivWithin_le'\n    (hf : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) (bound : ‚àÄ x ‚àà s, ‚Äñf' x - œÜ‚Äñ ‚â§ C)\n    (hs : Convex ‚Ñù s) (xs : x ‚àà s) (ys : y ‚àà s) : ‚Äñf y - f x - œÜ (y - x)‚Äñ ‚â§ C * ‚Äñy - x‚Äñ := by\n  /- We subtract `œÜ` to define a new function `g` for which `g' = 0`, for which the previous theorem\n    applies, `Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le`. Then, we just need to glue\n    together the pieces, expressing back `f` in terms of `g`. -/\n  let g y := f y - œÜ y\n  have hg : ‚àÄ x ‚àà s, HasFDerivWithinAt g (f' x - œÜ) s x := fun x xs =>\n    (hf x xs).sub œÜ.hasFDerivWithinAt\n  calc\n    ‚Äñf y - f x - œÜ (y - x)‚Äñ = ‚Äñf y - f x - (œÜ y - œÜ x)‚Äñ := by simp\n    _ = ‚Äñf y - œÜ y - (f x - œÜ x)‚Äñ := by congr 1; abel\n    _ = ‚Äñg y - g x‚Äñ := by simp [g]\n    _ ‚â§ C * ‚Äñy - x‚Äñ := Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le hg bound hs xs ys\n\n"}
{"name":"Convex.norm_image_sub_le_of_norm_fderivWithin_le'","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nùïú : Type u_3\nG : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : E ‚Üí G\nC : Real\ns : Set E\nx y : E\nœÜ : ContinuousLinearMap (RingHom.id ùïú) E G\nhf : DifferentiableOn ùïú f s\nbound : ‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (Norm.norm (HSub.hSub (fderivWithin ùïú f s x) œÜ)) C\nhs : Convex Real s\nxs : Membership.mem s x\nys : Membership.mem s y\n‚ä¢ LE.le (Norm.norm (HSub.hSub (HSub.hSub (f y) (f x)) (œÜ (HSub.hSub y x)))) (HMul.hMul C (Norm.norm (HSub.hSub y x)))","decl":"/-- Variant of the mean value inequality on a convex set. Version with `fderivWithin`. -/\ntheorem norm_image_sub_le_of_norm_fderivWithin_le' (hf : DifferentiableOn ùïú f s)\n    (bound : ‚àÄ x ‚àà s, ‚ÄñfderivWithin ùïú f s x - œÜ‚Äñ ‚â§ C) (hs : Convex ‚Ñù s) (xs : x ‚àà s) (ys : y ‚àà s) :\n    ‚Äñf y - f x - œÜ (y - x)‚Äñ ‚â§ C * ‚Äñy - x‚Äñ :=\n  hs.norm_image_sub_le_of_norm_hasFDerivWithin_le' (fun x hx => (hf x hx).hasFDerivWithinAt) bound\n    xs ys\n\n"}
{"name":"Convex.norm_image_sub_le_of_norm_fderiv_le'","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nùïú : Type u_3\nG : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : E ‚Üí G\nC : Real\ns : Set E\nx y : E\nœÜ : ContinuousLinearMap (RingHom.id ùïú) E G\nhf : ‚àÄ (x : E), Membership.mem s x ‚Üí DifferentiableAt ùïú f x\nbound : ‚àÄ (x : E), Membership.mem s x ‚Üí LE.le (Norm.norm (HSub.hSub (fderiv ùïú f x) œÜ)) C\nhs : Convex Real s\nxs : Membership.mem s x\nys : Membership.mem s y\n‚ä¢ LE.le (Norm.norm (HSub.hSub (HSub.hSub (f y) (f x)) (œÜ (HSub.hSub y x)))) (HMul.hMul C (Norm.norm (HSub.hSub y x)))","decl":"/-- Variant of the mean value inequality on a convex set. Version with `fderiv`. -/\ntheorem norm_image_sub_le_of_norm_fderiv_le' (hf : ‚àÄ x ‚àà s, DifferentiableAt ùïú f x)\n    (bound : ‚àÄ x ‚àà s, ‚Äñfderiv ùïú f x - œÜ‚Äñ ‚â§ C) (hs : Convex ‚Ñù s) (xs : x ‚àà s) (ys : y ‚àà s) :\n    ‚Äñf y - f x - œÜ (y - x)‚Äñ ‚â§ C * ‚Äñy - x‚Äñ :=\n  hs.norm_image_sub_le_of_norm_hasFDerivWithin_le'\n    (fun x hx => (hf x hx).hasFDerivAt.hasFDerivWithinAt) bound xs ys\n\n"}
{"name":"Convex.is_const_of_fderivWithin_eq_zero","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nùïú : Type u_3\nG : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : E ‚Üí G\ns : Set E\nx y : E\nhs : Convex Real s\nhf : DifferentiableOn ùïú f s\nhf' : ‚àÄ (x : E), Membership.mem s x ‚Üí Eq (fderivWithin ùïú f s x) 0\nhx : Membership.mem s x\nhy : Membership.mem s y\n‚ä¢ Eq (f x) (f y)","decl":"/-- If a function has zero Fr√©chet derivative at every point of a convex set,\nthen it is a constant on this set. -/\ntheorem is_const_of_fderivWithin_eq_zero (hs : Convex ‚Ñù s) (hf : DifferentiableOn ùïú f s)\n    (hf' : ‚àÄ x ‚àà s, fderivWithin ùïú f s x = 0) (hx : x ‚àà s) (hy : y ‚àà s) : f x = f y := by\n  have bound : ‚àÄ x ‚àà s, ‚ÄñfderivWithin ùïú f s x‚Äñ ‚â§ 0 := fun x hx => by\n    simp only [hf' x hx, norm_zero, le_rfl]\n  simpa only [(dist_eq_norm _ _).symm, zero_mul, dist_le_zero, eq_comm] using\n    hs.norm_image_sub_le_of_norm_fderivWithin_le hf bound hx hy\n\n"}
{"name":"is_const_of_fderiv_eq_zero","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\nG : Type u_4\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : IsRCLikeNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace ùïú G\nE : Type u_5\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace ùïú E\nf : E ‚Üí G\nhf : Differentiable ùïú f\nhf' : ‚àÄ (x : E), Eq (fderiv ùïú f x) 0\nx y : E\n‚ä¢ Eq (f x) (f y)","decl":"theorem _root_.is_const_of_fderiv_eq_zero\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace ùïú E] {f : E ‚Üí G}\n    (hf : Differentiable ùïú f) (hf' : ‚àÄ x, fderiv ùïú f x = 0)\n    (x y : E) : f x = f y := by\n  letI : RCLike ùïú := IsRCLikeNormedField.rclike ùïú\n  let A : NormedSpace ‚Ñù E := RestrictScalars.normedSpace ‚Ñù ùïú E\n  exact convex_univ.is_const_of_fderivWithin_eq_zero hf.differentiableOn\n    (fun x _ => by rw [fderivWithin_univ]; exact hf' x) trivial trivial\n\n"}
{"name":"Convex.eqOn_of_fderivWithin_eq","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace Real E\nùïú : Type u_3\nG : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\ninst‚úù¬≥ : IsRCLikeNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf g : E ‚Üí G\ns : Set E\nx : E\nhs : Convex Real s\nhf : DifferentiableOn ùïú f s\nhg : DifferentiableOn ùïú g s\nhs' : UniqueDiffOn ùïú s\nhf' : ‚àÄ (x : E), Membership.mem s x ‚Üí Eq (fderivWithin ùïú f s x) (fderivWithin ùïú g s x)\nhx : Membership.mem s x\nhfgx : Eq (f x) (g x)\n‚ä¢ Set.EqOn f g s","decl":"/-- If two functions have equal Fr√©chet derivatives at every point of a convex set, and are equal at\none point in that set, then they are equal on that set. -/\ntheorem eqOn_of_fderivWithin_eq (hs : Convex ‚Ñù s) (hf : DifferentiableOn ùïú f s)\n    (hg : DifferentiableOn ùïú g s) (hs' : UniqueDiffOn ùïú s)\n    (hf' : ‚àÄ x ‚àà s, fderivWithin ùïú f s x = fderivWithin ùïú g s x) (hx : x ‚àà s) (hfgx : f x = g x) :\n    s.EqOn f g := fun y hy => by\n  suffices f x - g x = f y - g y by rwa [hfgx, sub_self, eq_comm, sub_eq_zero] at this\n  refine hs.is_const_of_fderivWithin_eq_zero (hf.sub hg) (fun z hz => ?_) hx hy\n  rw [fderivWithin_sub (hs' _ hz) (hf _ hz) (hg _ hz), sub_eq_zero, hf' _ hz]\n\n"}
{"name":"eq_of_fderiv_eq","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\nG : Type u_4\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : IsRCLikeNormedField ùïú\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace ùïú G\nE : Type u_5\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace ùïú E\nf g : E ‚Üí G\nhf : Differentiable ùïú f\nhg : Differentiable ùïú g\nhf' : ‚àÄ (x : E), Eq (fderiv ùïú f x) (fderiv ùïú g x)\nx : E\nhfgx : Eq (f x) (g x)\n‚ä¢ Eq f g","decl":"theorem _root_.eq_of_fderiv_eq\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace ùïú E] {f g : E ‚Üí G}\n    (hf : Differentiable ùïú f) (hg : Differentiable ùïú g)\n    (hf' : ‚àÄ x, fderiv ùïú f x = fderiv ùïú g x) (x : E) (hfgx : f x = g x) : f = g := by\n  letI : RCLike ùïú := IsRCLikeNormedField.rclike ùïú\n  let A : NormedSpace ‚Ñù E := RestrictScalars.normedSpace ‚Ñù ùïú E\n  suffices Set.univ.EqOn f g from funext fun x => this <| mem_univ x\n  exact convex_univ.eqOn_of_fderivWithin_eq hf.differentiableOn hg.differentiableOn\n    uniqueDiffOn_univ (fun x _ => by simpa using hf' _) (mem_univ _) hfgx\n\n"}
{"name":"Convex.norm_image_sub_le_of_norm_hasDerivWithin_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\nG : Type u_4\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf f' : ùïú ‚Üí G\ns : Set ùïú\nx y : ùïú\nC : Real\nhf : ‚àÄ (x : ùïú), Membership.mem s x ‚Üí HasDerivWithinAt f (f' x) s x\nbound : ‚àÄ (x : ùïú), Membership.mem s x ‚Üí LE.le (Norm.norm (f' x)) C\nhs : Convex Real s\nxs : Membership.mem s x\nys : Membership.mem s y\n‚ä¢ LE.le (Norm.norm (HSub.hSub (f y) (f x))) (HMul.hMul C (Norm.norm (HSub.hSub y x)))","decl":"/-- The mean value theorem on a convex set in dimension 1: if the derivative of a function is\nbounded by `C`, then the function is `C`-Lipschitz. Version with `HasDerivWithinAt`. -/\ntheorem norm_image_sub_le_of_norm_hasDerivWithin_le {C : ‚Ñù}\n    (hf : ‚àÄ x ‚àà s, HasDerivWithinAt f (f' x) s x) (bound : ‚àÄ x ‚àà s, ‚Äñf' x‚Äñ ‚â§ C) (hs : Convex ‚Ñù s)\n    (xs : x ‚àà s) (ys : y ‚àà s) : ‚Äñf y - f x‚Äñ ‚â§ C * ‚Äñy - x‚Äñ :=\n  Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le (fun x hx => (hf x hx).hasFDerivWithinAt)\n    (fun x hx => le_trans (by simp) (bound x hx)) hs xs ys\n\n"}
{"name":"Convex.lipschitzOnWith_of_nnnorm_hasDerivWithin_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\nG : Type u_4\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf f' : ùïú ‚Üí G\ns : Set ùïú\nC : NNReal\nhs : Convex Real s\nhf : ‚àÄ (x : ùïú), Membership.mem s x ‚Üí HasDerivWithinAt f (f' x) s x\nbound : ‚àÄ (x : ùïú), Membership.mem s x ‚Üí LE.le (NNNorm.nnnorm (f' x)) C\n‚ä¢ LipschitzOnWith C f s","decl":"/-- The mean value theorem on a convex set in dimension 1: if the derivative of a function is\nbounded by `C` on `s`, then the function is `C`-Lipschitz on `s`.\nVersion with `HasDerivWithinAt` and `LipschitzOnWith`. -/\ntheorem lipschitzOnWith_of_nnnorm_hasDerivWithin_le {C : ‚Ñù‚â•0} (hs : Convex ‚Ñù s)\n    (hf : ‚àÄ x ‚àà s, HasDerivWithinAt f (f' x) s x) (bound : ‚àÄ x ‚àà s, ‚Äñf' x‚Äñ‚Çä ‚â§ C) :\n    LipschitzOnWith C f s :=\n  Convex.lipschitzOnWith_of_nnnorm_hasFDerivWithin_le (fun x hx => (hf x hx).hasFDerivWithinAt)\n    (fun x hx => le_trans (by simp) (bound x hx)) hs\n\n"}
{"name":"Convex.norm_image_sub_le_of_norm_derivWithin_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\nG : Type u_4\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : ùïú ‚Üí G\ns : Set ùïú\nx y : ùïú\nC : Real\nhf : DifferentiableOn ùïú f s\nbound : ‚àÄ (x : ùïú), Membership.mem s x ‚Üí LE.le (Norm.norm (derivWithin f s x)) C\nhs : Convex Real s\nxs : Membership.mem s x\nys : Membership.mem s y\n‚ä¢ LE.le (Norm.norm (HSub.hSub (f y) (f x))) (HMul.hMul C (Norm.norm (HSub.hSub y x)))","decl":"/-- The mean value theorem on a convex set in dimension 1: if the derivative of a function within\nthis set is bounded by `C`, then the function is `C`-Lipschitz. Version with `derivWithin` -/\ntheorem norm_image_sub_le_of_norm_derivWithin_le {C : ‚Ñù} (hf : DifferentiableOn ùïú f s)\n    (bound : ‚àÄ x ‚àà s, ‚ÄñderivWithin f s x‚Äñ ‚â§ C) (hs : Convex ‚Ñù s) (xs : x ‚àà s) (ys : y ‚àà s) :\n    ‚Äñf y - f x‚Äñ ‚â§ C * ‚Äñy - x‚Äñ :=\n  hs.norm_image_sub_le_of_norm_hasDerivWithin_le (fun x hx => (hf x hx).hasDerivWithinAt) bound xs\n    ys\n\n"}
{"name":"Convex.lipschitzOnWith_of_nnnorm_derivWithin_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\nG : Type u_4\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : ùïú ‚Üí G\ns : Set ùïú\nC : NNReal\nhs : Convex Real s\nhf : DifferentiableOn ùïú f s\nbound : ‚àÄ (x : ùïú), Membership.mem s x ‚Üí LE.le (NNNorm.nnnorm (derivWithin f s x)) C\n‚ä¢ LipschitzOnWith C f s","decl":"/-- The mean value theorem on a convex set in dimension 1: if the derivative of a function is\nbounded by `C` on `s`, then the function is `C`-Lipschitz on `s`.\nVersion with `derivWithin` and `LipschitzOnWith`. -/\ntheorem lipschitzOnWith_of_nnnorm_derivWithin_le {C : ‚Ñù‚â•0} (hs : Convex ‚Ñù s)\n    (hf : DifferentiableOn ùïú f s) (bound : ‚àÄ x ‚àà s, ‚ÄñderivWithin f s x‚Äñ‚Çä ‚â§ C) :\n    LipschitzOnWith C f s :=\n  hs.lipschitzOnWith_of_nnnorm_hasDerivWithin_le (fun x hx => (hf x hx).hasDerivWithinAt) bound\n\n"}
{"name":"Convex.norm_image_sub_le_of_norm_deriv_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\nG : Type u_4\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : ùïú ‚Üí G\ns : Set ùïú\nx y : ùïú\nC : Real\nhf : ‚àÄ (x : ùïú), Membership.mem s x ‚Üí DifferentiableAt ùïú f x\nbound : ‚àÄ (x : ùïú), Membership.mem s x ‚Üí LE.le (Norm.norm (deriv f x)) C\nhs : Convex Real s\nxs : Membership.mem s x\nys : Membership.mem s y\n‚ä¢ LE.le (Norm.norm (HSub.hSub (f y) (f x))) (HMul.hMul C (Norm.norm (HSub.hSub y x)))","decl":"/-- The mean value theorem on a convex set in dimension 1: if the derivative of a function is\nbounded by `C`, then the function is `C`-Lipschitz. Version with `deriv`. -/\ntheorem norm_image_sub_le_of_norm_deriv_le {C : ‚Ñù} (hf : ‚àÄ x ‚àà s, DifferentiableAt ùïú f x)\n    (bound : ‚àÄ x ‚àà s, ‚Äñderiv f x‚Äñ ‚â§ C) (hs : Convex ‚Ñù s) (xs : x ‚àà s) (ys : y ‚àà s) :\n    ‚Äñf y - f x‚Äñ ‚â§ C * ‚Äñy - x‚Äñ :=\n  hs.norm_image_sub_le_of_norm_hasDerivWithin_le\n    (fun x hx => (hf x hx).hasDerivAt.hasDerivWithinAt) bound xs ys\n\n"}
{"name":"Convex.lipschitzOnWith_of_nnnorm_deriv_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\nG : Type u_4\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : ùïú ‚Üí G\ns : Set ùïú\nC : NNReal\nhf : ‚àÄ (x : ùïú), Membership.mem s x ‚Üí DifferentiableAt ùïú f x\nbound : ‚àÄ (x : ùïú), Membership.mem s x ‚Üí LE.le (NNNorm.nnnorm (deriv f x)) C\nhs : Convex Real s\n‚ä¢ LipschitzOnWith C f s","decl":"/-- The mean value theorem on a convex set in dimension 1: if the derivative of a function is\nbounded by `C` on `s`, then the function is `C`-Lipschitz on `s`.\nVersion with `deriv` and `LipschitzOnWith`. -/\ntheorem lipschitzOnWith_of_nnnorm_deriv_le {C : ‚Ñù‚â•0} (hf : ‚àÄ x ‚àà s, DifferentiableAt ùïú f x)\n    (bound : ‚àÄ x ‚àà s, ‚Äñderiv f x‚Äñ‚Çä ‚â§ C) (hs : Convex ‚Ñù s) : LipschitzOnWith C f s :=\n  hs.lipschitzOnWith_of_nnnorm_hasDerivWithin_le\n    (fun x hx => (hf x hx).hasDerivAt.hasDerivWithinAt) bound\n\n"}
{"name":"lipschitzWith_of_nnnorm_deriv_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\nG : Type u_4\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : ùïú ‚Üí G\nC : NNReal\nhf : Differentiable ùïú f\nbound : ‚àÄ (x : ùïú), LE.le (NNNorm.nnnorm (deriv f x)) C\n‚ä¢ LipschitzWith C f","decl":"/-- The mean value theorem set in dimension 1: if the derivative of a function is bounded by `C`,\nthen the function is `C`-Lipschitz. Version with `deriv` and `LipschitzWith`. -/\ntheorem _root_.lipschitzWith_of_nnnorm_deriv_le {C : ‚Ñù‚â•0} (hf : Differentiable ùïú f)\n    (bound : ‚àÄ x, ‚Äñderiv f x‚Äñ‚Çä ‚â§ C) : LipschitzWith C f :=\n  lipschitzOnWith_univ.1 <|\n    convex_univ.lipschitzOnWith_of_nnnorm_deriv_le (fun x _ => hf x) fun x _ => bound x\n\n"}
{"name":"is_const_of_deriv_eq_zero","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\nG : Type u_4\ninst‚úù¬≤ : RCLike ùïú\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf : ùïú ‚Üí G\nhf : Differentiable ùïú f\nhf' : ‚àÄ (x : ùïú), Eq (deriv f x) 0\nx y : ùïú\n‚ä¢ Eq (f x) (f y)","decl":"/-- If `f : ùïú ‚Üí G`, `ùïú = R` or `ùïú = ‚ÑÇ`, is differentiable everywhere and its derivative equal zero,\nthen it is a constant function. -/\ntheorem _root_.is_const_of_deriv_eq_zero (hf : Differentiable ùïú f) (hf' : ‚àÄ x, deriv f x = 0)\n    (x y : ùïú) : f x = f y :=\n  is_const_of_fderiv_eq_zero hf (fun z => by ext; simp [‚Üê deriv_fderiv, hf']) _ _\n\n"}
{"name":"exists_ratio_hasDerivAt_eq_ratio_slope","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f f' : Real ‚Üí Real\na b : Real\nhab : LT.lt a b\nhfc : ContinuousOn f (Set.Icc a b)\nhff' : ‚àÄ (x : Real), Membership.mem (Set.Ioo a b) x ‚Üí HasDerivAt f (f' x) x\ng g' : Real ‚Üí Real\nhgc : ContinuousOn g (Set.Icc a b)\nhgg' : ‚àÄ (x : Real), Membership.mem (Set.Ioo a b) x ‚Üí HasDerivAt g (g' x) x\n‚ä¢ Exists fun c => And (Membership.mem (Set.Ioo a b) c) (Eq (HMul.hMul (HSub.hSub (g b) (g a)) (f' c)) (HMul.hMul (HSub.hSub (f b) (f a)) (g' c)))","decl":"include hab hfc hff' hgc hgg' in\n/-- Cauchy's **Mean Value Theorem**, `HasDerivAt` version. -/\ntheorem exists_ratio_hasDerivAt_eq_ratio_slope :\n    ‚àÉ c ‚àà Ioo a b, (g b - g a) * f' c = (f b - f a) * g' c := by\n  let h x := (g b - g a) * f x - (f b - f a) * g x\n  have hI : h a = h b := by simp only [h]; ring\n  let h' x := (g b - g a) * f' x - (f b - f a) * g' x\n  have hhh' : ‚àÄ x ‚àà Ioo a b, HasDerivAt h (h' x) x := fun x hx =>\n    ((hff' x hx).const_mul (g b - g a)).sub ((hgg' x hx).const_mul (f b - f a))\n  have hhc : ContinuousOn h (Icc a b) :=\n    (continuousOn_const.mul hfc).sub (continuousOn_const.mul hgc)\n  rcases exists_hasDerivAt_eq_zero hab hhc hI hhh' with ‚ü®c, cmem, hc‚ü©\n  exact ‚ü®c, cmem, sub_eq_zero.1 hc‚ü©\n\n"}
{"name":"exists_ratio_hasDerivAt_eq_ratio_slope'","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f f' : Real ‚Üí Real\na b : Real\nhab : LT.lt a b\ng g' : Real ‚Üí Real\nlfa lga lfb lgb : Real\nhff' : ‚àÄ (x : Real), Membership.mem (Set.Ioo a b) x ‚Üí HasDerivAt f (f' x) x\nhgg' : ‚àÄ (x : Real), Membership.mem (Set.Ioo a b) x ‚Üí HasDerivAt g (g' x) x\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds lfa)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds lga)\nhfb : Filter.Tendsto f (nhdsWithin b (Set.Iio b)) (nhds lfb)\nhgb : Filter.Tendsto g (nhdsWithin b (Set.Iio b)) (nhds lgb)\n‚ä¢ Exists fun c => And (Membership.mem (Set.Ioo a b) c) (Eq (HMul.hMul (HSub.hSub lgb lga) (f' c)) (HMul.hMul (HSub.hSub lfb lfa) (g' c)))","decl":"include hab in\n/-- Cauchy's **Mean Value Theorem**, extended `HasDerivAt` version. -/\ntheorem exists_ratio_hasDerivAt_eq_ratio_slope' {lfa lga lfb lgb : ‚Ñù}\n    (hff' : ‚àÄ x ‚àà Ioo a b, HasDerivAt f (f' x) x) (hgg' : ‚àÄ x ‚àà Ioo a b, HasDerivAt g (g' x) x)\n    (hfa : Tendsto f (ùìù[>] a) (ùìù lfa)) (hga : Tendsto g (ùìù[>] a) (ùìù lga))\n    (hfb : Tendsto f (ùìù[<] b) (ùìù lfb)) (hgb : Tendsto g (ùìù[<] b) (ùìù lgb)) :\n    ‚àÉ c ‚àà Ioo a b, (lgb - lga) * f' c = (lfb - lfa) * g' c := by\n  let h x := (lgb - lga) * f x - (lfb - lfa) * g x\n  have hha : Tendsto h (ùìù[>] a) (ùìù <| lgb * lfa - lfb * lga) := by\n    have : Tendsto h (ùìù[>] a) (ùìù <| (lgb - lga) * lfa - (lfb - lfa) * lga) :=\n      (tendsto_const_nhds.mul hfa).sub (tendsto_const_nhds.mul hga)\n    convert this using 2\n    ring\n  have hhb : Tendsto h (ùìù[<] b) (ùìù <| lgb * lfa - lfb * lga) := by\n    have : Tendsto h (ùìù[<] b) (ùìù <| (lgb - lga) * lfb - (lfb - lfa) * lgb) :=\n      (tendsto_const_nhds.mul hfb).sub (tendsto_const_nhds.mul hgb)\n    convert this using 2\n    ring\n  let h' x := (lgb - lga) * f' x - (lfb - lfa) * g' x\n  have hhh' : ‚àÄ x ‚àà Ioo a b, HasDerivAt h (h' x) x := by\n    intro x hx\n    exact ((hff' x hx).const_mul _).sub ((hgg' x hx).const_mul _)\n  rcases exists_hasDerivAt_eq_zero' hab hha hhb hhh' with ‚ü®c, cmem, hc‚ü©\n  exact ‚ü®c, cmem, sub_eq_zero.1 hc‚ü©\n\n"}
{"name":"exists_hasDerivAt_eq_slope","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f f' : Real ‚Üí Real\na b : Real\nhab : LT.lt a b\nhfc : ContinuousOn f (Set.Icc a b)\nhff' : ‚àÄ (x : Real), Membership.mem (Set.Ioo a b) x ‚Üí HasDerivAt f (f' x) x\n‚ä¢ Exists fun c => And (Membership.mem (Set.Ioo a b) c) (Eq (f' c) (HDiv.hDiv (HSub.hSub (f b) (f a)) (HSub.hSub b a)))","decl":"include hab hfc hff' in\n/-- Lagrange's Mean Value Theorem, `HasDerivAt` version -/\ntheorem exists_hasDerivAt_eq_slope : ‚àÉ c ‚àà Ioo a b, f' c = (f b - f a) / (b - a) := by\n  obtain ‚ü®c, cmem, hc‚ü© : ‚àÉ c ‚àà Ioo a b, (b - a) * f' c = (f b - f a) * 1 :=\n    exists_ratio_hasDerivAt_eq_ratio_slope f f' hab hfc hff' id 1 continuousOn_id\n      fun x _ => hasDerivAt_id x\n  use c, cmem\n  rwa [mul_one, mul_comm, ‚Üê eq_div_iff (sub_ne_zero.2 hab.ne')] at hc\n\n"}
{"name":"exists_ratio_deriv_eq_ratio_slope","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\na b : Real\nhab : LT.lt a b\nhfc : ContinuousOn f (Set.Icc a b)\nhfd : DifferentiableOn Real f (Set.Ioo a b)\ng : Real ‚Üí Real\nhgc : ContinuousOn g (Set.Icc a b)\nhgd : DifferentiableOn Real g (Set.Ioo a b)\n‚ä¢ Exists fun c => And (Membership.mem (Set.Ioo a b) c) (Eq (HMul.hMul (HSub.hSub (g b) (g a)) (deriv f c)) (HMul.hMul (HSub.hSub (f b) (f a)) (deriv g c)))","decl":"include hab hfc hgc hgd hfd in\n/-- Cauchy's Mean Value Theorem, `deriv` version. -/\ntheorem exists_ratio_deriv_eq_ratio_slope :\n    ‚àÉ c ‚àà Ioo a b, (g b - g a) * deriv f c = (f b - f a) * deriv g c :=\n  exists_ratio_hasDerivAt_eq_ratio_slope f (deriv f) hab hfc\n    (fun x hx => ((hfd x hx).differentiableAt <| IsOpen.mem_nhds isOpen_Ioo hx).hasDerivAt) g\n    (deriv g) hgc fun x hx =>\n    ((hgd x hx).differentiableAt <| IsOpen.mem_nhds isOpen_Ioo hx).hasDerivAt\n\n"}
{"name":"exists_ratio_deriv_eq_ratio_slope'","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\na b : Real\nhab : LT.lt a b\ng : Real ‚Üí Real\nlfa lga lfb lgb : Real\nhdf : DifferentiableOn Real f (Set.Ioo a b)\nhdg : DifferentiableOn Real g (Set.Ioo a b)\nhfa : Filter.Tendsto f (nhdsWithin a (Set.Ioi a)) (nhds lfa)\nhga : Filter.Tendsto g (nhdsWithin a (Set.Ioi a)) (nhds lga)\nhfb : Filter.Tendsto f (nhdsWithin b (Set.Iio b)) (nhds lfb)\nhgb : Filter.Tendsto g (nhdsWithin b (Set.Iio b)) (nhds lgb)\n‚ä¢ Exists fun c => And (Membership.mem (Set.Ioo a b) c) (Eq (HMul.hMul (HSub.hSub lgb lga) (deriv f c)) (HMul.hMul (HSub.hSub lfb lfa) (deriv g c)))","decl":"include hab in\n/-- Cauchy's Mean Value Theorem, extended `deriv` version. -/\ntheorem exists_ratio_deriv_eq_ratio_slope' {lfa lga lfb lgb : ‚Ñù}\n    (hdf : DifferentiableOn ‚Ñù f <| Ioo a b) (hdg : DifferentiableOn ‚Ñù g <| Ioo a b)\n    (hfa : Tendsto f (ùìù[>] a) (ùìù lfa)) (hga : Tendsto g (ùìù[>] a) (ùìù lga))\n    (hfb : Tendsto f (ùìù[<] b) (ùìù lfb)) (hgb : Tendsto g (ùìù[<] b) (ùìù lgb)) :\n    ‚àÉ c ‚àà Ioo a b, (lgb - lga) * deriv f c = (lfb - lfa) * deriv g c :=\n  exists_ratio_hasDerivAt_eq_ratio_slope' _ _ hab _ _\n    (fun x hx => ((hdf x hx).differentiableAt <| Ioo_mem_nhds hx.1 hx.2).hasDerivAt)\n    (fun x hx => ((hdg x hx).differentiableAt <| Ioo_mem_nhds hx.1 hx.2).hasDerivAt) hfa hga hfb hgb\n\n"}
{"name":"exists_deriv_eq_slope","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\na b : Real\nhab : LT.lt a b\nhfc : ContinuousOn f (Set.Icc a b)\nhfd : DifferentiableOn Real f (Set.Ioo a b)\n‚ä¢ Exists fun c => And (Membership.mem (Set.Ioo a b) c) (Eq (deriv f c) (HDiv.hDiv (HSub.hSub (f b) (f a)) (HSub.hSub b a)))","decl":"include hab hfc hfd in\n/-- Lagrange's **Mean Value Theorem**, `deriv` version. -/\ntheorem exists_deriv_eq_slope : ‚àÉ c ‚àà Ioo a b, deriv f c = (f b - f a) / (b - a) :=\n  exists_hasDerivAt_eq_slope f (deriv f) hab hfc fun x hx =>\n    ((hfd x hx).differentiableAt <| IsOpen.mem_nhds isOpen_Ioo hx).hasDerivAt\n\n"}
{"name":"exists_deriv_eq_slope'","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\na b : Real\nhab : LT.lt a b\nhfc : ContinuousOn f (Set.Icc a b)\nhfd : DifferentiableOn Real f (Set.Ioo a b)\n‚ä¢ Exists fun c => And (Membership.mem (Set.Ioo a b) c) (Eq (deriv f c) (slope f a b))","decl":"include hab hfc hfd in\n/-- Lagrange's **Mean Value Theorem**, `deriv` version. -/\ntheorem exists_deriv_eq_slope' : ‚àÉ c ‚àà Ioo a b, deriv f c = slope f a b := by\n  rw [slope_def_field]\n  exact exists_deriv_eq_slope f hab hfc hfd\n\n"}
{"name":"not_differentiableWithinAt_of_deriv_tendsto_atTop_Ioi","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\na : Real\nhf : Filter.Tendsto (deriv f) (nhdsWithin a (Set.Ioi a)) Filter.atTop\n‚ä¢ Not (DifferentiableWithinAt Real f (Set.Ioi a) a)","decl":"/-- A real function whose derivative tends to infinity from the right at a point is not\ndifferentiable on the right at that point -/\ntheorem not_differentiableWithinAt_of_deriv_tendsto_atTop_Ioi (f : ‚Ñù ‚Üí ‚Ñù) {a : ‚Ñù}\n    (hf : Tendsto (deriv f) (ùìù[>] a) atTop) : ¬¨ DifferentiableWithinAt ‚Ñù f (Ioi a) a := by\n  replace hf : Tendsto (derivWithin f (Ioi a)) (ùìù[>] a) atTop := by\n    refine hf.congr' ?_\n    filter_upwards [eventually_mem_nhdsWithin] with x hx\n    have : Ioi a ‚àà ùìù x := by simp [‚Üê mem_interior_iff_mem_nhds, hx]\n    exact (derivWithin_of_mem_nhds this).symm\n  by_cases hcont_at_a : ContinuousWithinAt f (Ici a) a\n  case neg =>\n    intro hcontra\n    have := hcontra.continuousWithinAt\n    rw [‚Üê ContinuousWithinAt.diff_iff this] at hcont_at_a\n    simp at hcont_at_a\n  case pos =>\n    intro hdiff\n    replace hdiff := hdiff.hasDerivWithinAt\n    rw [hasDerivWithinAt_iff_tendsto_slope, Set.diff_singleton_eq_self not_mem_Ioi_self] at hdiff\n    have h‚ÇÄ : ‚àÄ·∂† b in ùìù[>] a,\n        ‚àÄ x ‚àà Ioc a b, max (derivWithin f (Ioi a) a + 1) 0 < derivWithin f (Ioi a) x := by\n      rw [(nhdsGT_basis a).eventually_iff]\n      rw [(nhdsGT_basis a).tendsto_left_iff] at hf\n      obtain ‚ü®b, hab, hb‚ü© := hf (Ioi (max (derivWithin f (Ioi a) a + 1) 0)) (Ioi_mem_atTop _)\n      refine ‚ü®b, hab, fun x hx z hz => ?_‚ü©\n      simp only [MapsTo, mem_Ioo, mem_Ioi, and_imp] at hb\n      exact hb hz.1 <| hz.2.trans_lt hx.2\n    have h‚ÇÅ : ‚àÄ·∂† b in ùìù[>] a, slope f a b < derivWithin f (Ioi a) a + 1 := by\n      rw [(nhds_basis_Ioo _).tendsto_right_iff] at hdiff\n      specialize hdiff ‚ü®derivWithin f (Ioi a) a - 1, derivWithin f (Ioi a) a + 1‚ü© <| by simp\n      filter_upwards [hdiff] with z hz using hz.2\n    have hcontra : ‚àÄ·∂† _ in ùìù[>] a, False := by\n      filter_upwards [h‚ÇÄ, h‚ÇÅ, eventually_mem_nhdsWithin] with b hb hslope (hab : a < b)\n      have hdiff' : DifferentiableOn ‚Ñù f (Ioc a b) := fun z hz => by\n        refine DifferentiableWithinAt.mono (t := Ioi a) ?_ Ioc_subset_Ioi_self\n        have : derivWithin f (Ioi a) z ‚â† 0 := ne_of_gt <| by\n          simp_all only [mem_Ioo, and_imp, mem_Ioc, max_lt_iff]\n        exact differentiableWithinAt_of_derivWithin_ne_zero this\n      have hcont_Ioc : ‚àÄ z ‚àà Ioc a b, ContinuousWithinAt f (Icc a b) z := by\n        intro z hz''\n        refine (hdiff'.continuousOn z hz'').mono_of_mem_nhdsWithin ?_\n        have hfinal : ùìù[Ioc a b] z = ùìù[Icc a b] z := by\n          refine nhdsWithin_eq_nhdsWithin' (s := Ioi a) (Ioi_mem_nhds hz''.1) ?_\n          simp only [Ioc_inter_Ioi, le_refl, sup_of_le_left]\n          ext y\n          exact ‚ü®fun h => ‚ü®mem_Icc_of_Ioc h, mem_of_mem_inter_left h‚ü©, fun ‚ü®H1, H2‚ü© => ‚ü®H2, H1.2‚ü©‚ü©\n        rw [‚Üê hfinal]\n        exact self_mem_nhdsWithin\n      have hcont : ContinuousOn f (Icc a b) := by\n        intro z hz\n        by_cases hz' : z = a\n        ¬∑ rw [hz']\n          exact hcont_at_a.mono Icc_subset_Ici_self\n        ¬∑ exact hcont_Ioc z ‚ü®lt_of_le_of_ne hz.1 (Ne.symm hz'), hz.2‚ü©\n      obtain ‚ü®x, hx‚ÇÅ, hx‚ÇÇ‚ü© :=\n        exists_deriv_eq_slope' f hab hcont (hdiff'.mono (Ioo_subset_Ioc_self))\n      specialize hb x ‚ü®hx‚ÇÅ.1, le_of_lt hx‚ÇÅ.2‚ü©\n      replace hx‚ÇÇ : derivWithin f (Ioi a) x = slope f a b := by\n        have : Ioi a ‚àà ùìù x := by simp [‚Üê mem_interior_iff_mem_nhds, hx‚ÇÅ.1]\n        rwa [derivWithin_of_mem_nhds this]\n      rw [hx‚ÇÇ, max_lt_iff] at hb\n      linarith\n    simp [Filter.eventually_false_iff_eq_bot, ‚Üê not_mem_closure_iff_nhdsWithin_eq_bot] at hcontra\n\n"}
{"name":"not_differentiableWithinAt_of_deriv_tendsto_atBot_Ioi","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\na : Real\nhf : Filter.Tendsto (deriv f) (nhdsWithin a (Set.Ioi a)) Filter.atBot\n‚ä¢ Not (DifferentiableWithinAt Real f (Set.Ioi a) a)","decl":"/-- A real function whose derivative tends to minus infinity from the right at a point is not\ndifferentiable on the right at that point -/\ntheorem not_differentiableWithinAt_of_deriv_tendsto_atBot_Ioi (f : ‚Ñù ‚Üí ‚Ñù) {a : ‚Ñù}\n    (hf : Tendsto (deriv f) (ùìù[>] a) atBot) : ¬¨ DifferentiableWithinAt ‚Ñù f (Ioi a) a := by\n  intro h\n  have hf' : Tendsto (deriv (-f)) (ùìù[>] a) atTop := by\n    rw [Pi.neg_def, deriv.neg']\n    exact tendsto_neg_atBot_atTop.comp hf\n  exact not_differentiableWithinAt_of_deriv_tendsto_atTop_Ioi (-f) hf' h.neg\n\n"}
{"name":"not_differentiableWithinAt_of_deriv_tendsto_atBot_Iio","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\na : Real\nhf : Filter.Tendsto (deriv f) (nhdsWithin a (Set.Iio a)) Filter.atBot\n‚ä¢ Not (DifferentiableWithinAt Real f (Set.Iio a) a)","decl":"/-- A real function whose derivative tends to minus infinity from the left at a point is not\ndifferentiable on the left at that point -/\ntheorem not_differentiableWithinAt_of_deriv_tendsto_atBot_Iio (f : ‚Ñù ‚Üí ‚Ñù) {a : ‚Ñù}\n    (hf : Tendsto (deriv f) (ùìù[<] a) atBot) : ¬¨ DifferentiableWithinAt ‚Ñù f (Iio a) a := by\n  let f' := f ‚àò Neg.neg\n  have hderiv : deriv f' =·∂†[ùìù[>] (-a)] -(deriv f ‚àò Neg.neg) := by\n    rw [atBot_basis.tendsto_right_iff] at hf\n    specialize hf (-1) trivial\n    rw [(nhdsLT_basis a).eventually_iff] at hf\n    rw [EventuallyEq, (nhdsGT_basis (-a)).eventually_iff]\n    obtain ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü© := hf\n    refine ‚ü®-b, by linarith, fun x hx => ?_‚ü©\n    simp only [Pi.neg_apply, Function.comp_apply]\n    suffices deriv f' x = deriv f (-x) * deriv (Neg.neg : ‚Ñù ‚Üí ‚Ñù) x by simpa using this\n    refine deriv_comp x (differentiableAt_of_deriv_ne_zero ?_) (by fun_prop)\n    rw [mem_Ioo] at hx\n    have h‚ÇÅ : -x ‚àà Ioo b a := ‚ü®by linarith, by linarith‚ü©\n    have h‚ÇÇ : deriv f (-x) ‚â§ -1 := hb‚ÇÇ h‚ÇÅ\n    exact ne_of_lt (by linarith)\n  have hmain : ¬¨ DifferentiableWithinAt ‚Ñù f' (Ioi (-a)) (-a) := by\n    refine not_differentiableWithinAt_of_deriv_tendsto_atTop_Ioi f' <| Tendsto.congr' hderiv.symm ?_\n    refine Tendsto.comp (g := -deriv f) ?_ tendsto_neg_nhdsGT_neg\n    exact Tendsto.comp (g := Neg.neg) tendsto_neg_atBot_atTop hf\n  intro h\n  have : DifferentiableWithinAt ‚Ñù f' (Ioi (-a)) (-a) := by\n    refine DifferentiableWithinAt.comp (g := f) (f := Neg.neg) (t := Iio a) (-a) ?_ ?_ ?_\n    ¬∑ simp [h]\n    ¬∑ fun_prop\n    ¬∑ intro x\n      simp [neg_lt]\n  exact hmain this\n\n"}
{"name":"not_differentiableWithinAt_of_deriv_tendsto_atTop_Iio","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\na : Real\nhf : Filter.Tendsto (deriv f) (nhdsWithin a (Set.Iio a)) Filter.atTop\n‚ä¢ Not (DifferentiableWithinAt Real f (Set.Iio a) a)","decl":"/-- A real function whose derivative tends to infinity from the left at a point is not\ndifferentiable on the left at that point -/\ntheorem not_differentiableWithinAt_of_deriv_tendsto_atTop_Iio (f : ‚Ñù ‚Üí ‚Ñù) {a : ‚Ñù}\n    (hf : Tendsto (deriv f) (ùìù[<] a) atTop) : ¬¨ DifferentiableWithinAt ‚Ñù f (Iio a) a := by\n  intro h\n  have hf' : Tendsto (deriv (-f)) (ùìù[<] a) atBot := by\n    rw [Pi.neg_def, deriv.neg']\n    exact tendsto_neg_atTop_atBot.comp hf\n  exact not_differentiableWithinAt_of_deriv_tendsto_atBot_Iio (-f) hf' h.neg\n\n"}
{"name":"Convex.mul_sub_lt_image_sub_of_lt_deriv","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"D : Set Real\nhD : Convex Real D\nf : Real ‚Üí Real\nhf : ContinuousOn f D\nhf' : DifferentiableOn Real f (interior D)\nC : Real\nhf'_gt : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí LT.lt C (deriv f x)\nx : Real\na‚úù¬≤ : Membership.mem D x\ny : Real\na‚úù¬π : Membership.mem D y\na‚úù : LT.lt x y\n‚ä¢ LT.lt (HMul.hMul C (HSub.hSub y x)) (HSub.hSub (f y) (f x))","decl":"/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y ‚àà D`,\n`x < y`. -/\ntheorem Convex.mul_sub_lt_image_sub_of_lt_deriv {D : Set ‚Ñù} (hD : Convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù}\n    (hf : ContinuousOn f D) (hf' : DifferentiableOn ‚Ñù f (interior D)) {C}\n    (hf'_gt : ‚àÄ x ‚àà interior D, C < deriv f x) :\n    ‚àÄ·µâ (x ‚àà D) (y ‚àà D), x < y ‚Üí C * (y - x) < f y - f x := by\n  intro x hx y hy hxy\n  have hxyD : Icc x y ‚äÜ D := hD.ordConnected.out hx hy\n  have hxyD' : Ioo x y ‚äÜ interior D :=\n    subset_sUnion_of_mem ‚ü®isOpen_Ioo, Ioo_subset_Icc_self.trans hxyD‚ü©\n  obtain ‚ü®a, a_mem, ha‚ü© : ‚àÉ a ‚àà Ioo x y, deriv f a = (f y - f x) / (y - x) :=\n    exists_deriv_eq_slope f hxy (hf.mono hxyD) (hf'.mono hxyD')\n  have : C < (f y - f x) / (y - x) := ha ‚ñ∏ hf'_gt _ (hxyD' a_mem)\n  exact (lt_div_iff‚ÇÄ (sub_pos.2 hxy)).1 this\n\n"}
{"name":"mul_sub_lt_image_sub_of_lt_deriv","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\nhf : Differentiable Real f\nC : Real\nhf'_gt : ‚àÄ (x : Real), LT.lt C (deriv f x)\nx y : Real\nhxy : LT.lt x y\n‚ä¢ LT.lt (HMul.hMul C (HSub.hSub y x)) (HSub.hSub (f y) (f x))","decl":"/-- Let `f : ‚Ñù ‚Üí ‚Ñù` be a differentiable function. If `C < f'`, then `f` grows faster than\n`C * x`, i.e., `C * (y - x) < f y - f x` whenever `x < y`. -/\ntheorem mul_sub_lt_image_sub_of_lt_deriv {f : ‚Ñù ‚Üí ‚Ñù} (hf : Differentiable ‚Ñù f) {C}\n    (hf'_gt : ‚àÄ x, C < deriv f x) ‚¶Éx y‚¶Ñ (hxy : x < y) : C * (y - x) < f y - f x :=\n  convex_univ.mul_sub_lt_image_sub_of_lt_deriv hf.continuous.continuousOn hf.differentiableOn\n    (fun x _ => hf'_gt x) x trivial y trivial hxy\n\n"}
{"name":"Convex.mul_sub_le_image_sub_of_le_deriv","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"D : Set Real\nhD : Convex Real D\nf : Real ‚Üí Real\nhf : ContinuousOn f D\nhf' : DifferentiableOn Real f (interior D)\nC : Real\nhf'_ge : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí LE.le C (deriv f x)\nx : Real\na‚úù¬≤ : Membership.mem D x\ny : Real\na‚úù¬π : Membership.mem D y\na‚úù : LE.le x y\n‚ä¢ LE.le (HMul.hMul C (HSub.hSub y x)) (HSub.hSub (f y) (f x))","decl":"/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C ‚â§ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ‚â§ f y - f x` whenever `x, y ‚àà D`,\n`x ‚â§ y`. -/\ntheorem Convex.mul_sub_le_image_sub_of_le_deriv {D : Set ‚Ñù} (hD : Convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù}\n    (hf : ContinuousOn f D) (hf' : DifferentiableOn ‚Ñù f (interior D)) {C}\n    (hf'_ge : ‚àÄ x ‚àà interior D, C ‚â§ deriv f x) :\n    ‚àÄ·µâ (x ‚àà D) (y ‚àà D), x ‚â§ y ‚Üí C * (y - x) ‚â§ f y - f x := by\n  intro x hx y hy hxy\n  cases' eq_or_lt_of_le hxy with hxy' hxy'\n  ¬∑ rw [hxy', sub_self, sub_self, mul_zero]\n  have hxyD : Icc x y ‚äÜ D := hD.ordConnected.out hx hy\n  have hxyD' : Ioo x y ‚äÜ interior D :=\n    subset_sUnion_of_mem ‚ü®isOpen_Ioo, Ioo_subset_Icc_self.trans hxyD‚ü©\n  obtain ‚ü®a, a_mem, ha‚ü© : ‚àÉ a ‚àà Ioo x y, deriv f a = (f y - f x) / (y - x) :=\n    exists_deriv_eq_slope f hxy' (hf.mono hxyD) (hf'.mono hxyD')\n  have : C ‚â§ (f y - f x) / (y - x) := ha ‚ñ∏ hf'_ge _ (hxyD' a_mem)\n  exact (le_div_iff‚ÇÄ (sub_pos.2 hxy')).1 this\n\n"}
{"name":"mul_sub_le_image_sub_of_le_deriv","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\nhf : Differentiable Real f\nC : Real\nhf'_ge : ‚àÄ (x : Real), LE.le C (deriv f x)\nx y : Real\nhxy : LE.le x y\n‚ä¢ LE.le (HMul.hMul C (HSub.hSub y x)) (HSub.hSub (f y) (f x))","decl":"/-- Let `f : ‚Ñù ‚Üí ‚Ñù` be a differentiable function. If `C ‚â§ f'`, then `f` grows at least as fast\nas `C * x`, i.e., `C * (y - x) ‚â§ f y - f x` whenever `x ‚â§ y`. -/\ntheorem mul_sub_le_image_sub_of_le_deriv {f : ‚Ñù ‚Üí ‚Ñù} (hf : Differentiable ‚Ñù f) {C}\n    (hf'_ge : ‚àÄ x, C ‚â§ deriv f x) ‚¶Éx y‚¶Ñ (hxy : x ‚â§ y) : C * (y - x) ‚â§ f y - f x :=\n  convex_univ.mul_sub_le_image_sub_of_le_deriv hf.continuous.continuousOn hf.differentiableOn\n    (fun x _ => hf'_ge x) x trivial y trivial hxy\n\n"}
{"name":"Convex.image_sub_lt_mul_sub_of_deriv_lt","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"D : Set Real\nhD : Convex Real D\nf : Real ‚Üí Real\nhf : ContinuousOn f D\nhf' : DifferentiableOn Real f (interior D)\nC : Real\nlt_hf' : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí LT.lt (deriv f x) C\nx : Real\nhx : Membership.mem D x\ny : Real\nhy : Membership.mem D y\nhxy : LT.lt x y\n‚ä¢ LT.lt (HSub.hSub (f y) (f x)) (HMul.hMul C (HSub.hSub y x))","decl":"/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y ‚àà D`,\n`x < y`. -/\ntheorem Convex.image_sub_lt_mul_sub_of_deriv_lt {D : Set ‚Ñù} (hD : Convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù}\n    (hf : ContinuousOn f D) (hf' : DifferentiableOn ‚Ñù f (interior D)) {C}\n    (lt_hf' : ‚àÄ x ‚àà interior D, deriv f x < C) (x : ‚Ñù) (hx : x ‚àà D) (y : ‚Ñù) (hy : y ‚àà D)\n    (hxy : x < y) : f y - f x < C * (y - x) :=\n  have hf'_gt : ‚àÄ x ‚àà interior D, -C < deriv (fun y => -f y) x := fun x hx => by\n    rw [deriv.neg, neg_lt_neg_iff]\n    exact lt_hf' x hx\n  by linarith [hD.mul_sub_lt_image_sub_of_lt_deriv hf.neg hf'.neg hf'_gt x hx y hy hxy]\n\n"}
{"name":"image_sub_lt_mul_sub_of_deriv_lt","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\nhf : Differentiable Real f\nC : Real\nlt_hf' : ‚àÄ (x : Real), LT.lt (deriv f x) C\nx y : Real\nhxy : LT.lt x y\n‚ä¢ LT.lt (HSub.hSub (f y) (f x)) (HMul.hMul C (HSub.hSub y x))","decl":"/-- Let `f : ‚Ñù ‚Üí ‚Ñù` be a differentiable function. If `f' < C`, then `f` grows slower than\n`C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x < y`. -/\ntheorem image_sub_lt_mul_sub_of_deriv_lt {f : ‚Ñù ‚Üí ‚Ñù} (hf : Differentiable ‚Ñù f) {C}\n    (lt_hf' : ‚àÄ x, deriv f x < C) ‚¶Éx y‚¶Ñ (hxy : x < y) : f y - f x < C * (y - x) :=\n  convex_univ.image_sub_lt_mul_sub_of_deriv_lt hf.continuous.continuousOn hf.differentiableOn\n    (fun x _ => lt_hf' x) x trivial y trivial hxy\n\n"}
{"name":"Convex.image_sub_le_mul_sub_of_deriv_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"D : Set Real\nhD : Convex Real D\nf : Real ‚Üí Real\nhf : ContinuousOn f D\nhf' : DifferentiableOn Real f (interior D)\nC : Real\nle_hf' : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí LE.le (deriv f x) C\nx : Real\nhx : Membership.mem D x\ny : Real\nhy : Membership.mem D y\nhxy : LE.le x y\n‚ä¢ LE.le (HSub.hSub (f y) (f x)) (HMul.hMul C (HSub.hSub y x))","decl":"/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' ‚â§ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x ‚â§ C * (y - x)` whenever `x, y ‚àà D`,\n`x ‚â§ y`. -/\ntheorem Convex.image_sub_le_mul_sub_of_deriv_le {D : Set ‚Ñù} (hD : Convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù}\n    (hf : ContinuousOn f D) (hf' : DifferentiableOn ‚Ñù f (interior D)) {C}\n    (le_hf' : ‚àÄ x ‚àà interior D, deriv f x ‚â§ C) (x : ‚Ñù) (hx : x ‚àà D) (y : ‚Ñù) (hy : y ‚àà D)\n    (hxy : x ‚â§ y) : f y - f x ‚â§ C * (y - x) :=\n  have hf'_ge : ‚àÄ x ‚àà interior D, -C ‚â§ deriv (fun y => -f y) x := fun x hx => by\n    rw [deriv.neg, neg_le_neg_iff]\n    exact le_hf' x hx\n  by linarith [hD.mul_sub_le_image_sub_of_le_deriv hf.neg hf'.neg hf'_ge x hx y hy hxy]\n\n"}
{"name":"image_sub_le_mul_sub_of_deriv_le","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\nhf : Differentiable Real f\nC : Real\nle_hf' : ‚àÄ (x : Real), LE.le (deriv f x) C\nx y : Real\nhxy : LE.le x y\n‚ä¢ LE.le (HSub.hSub (f y) (f x)) (HMul.hMul C (HSub.hSub y x))","decl":"/-- Let `f : ‚Ñù ‚Üí ‚Ñù` be a differentiable function. If `f' ‚â§ C`, then `f` grows at most as fast\nas `C * x`, i.e., `f y - f x ‚â§ C * (y - x)` whenever `x ‚â§ y`. -/\ntheorem image_sub_le_mul_sub_of_deriv_le {f : ‚Ñù ‚Üí ‚Ñù} (hf : Differentiable ‚Ñù f) {C}\n    (le_hf' : ‚àÄ x, deriv f x ‚â§ C) ‚¶Éx y‚¶Ñ (hxy : x ‚â§ y) : f y - f x ‚â§ C * (y - x) :=\n  convex_univ.image_sub_le_mul_sub_of_deriv_le hf.continuous.continuousOn hf.differentiableOn\n    (fun x _ => le_hf' x) x trivial y trivial hxy\n\n"}
{"name":"strictMonoOn_of_deriv_pos","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"D : Set Real\nhD : Convex Real D\nf : Real ‚Üí Real\nhf : ContinuousOn f D\nhf' : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí LT.lt 0 (deriv f x)\n‚ä¢ StrictMonoOn f D","decl":"/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is positive, then\n`f` is a strictly monotone function on `D`.\nNote that we don't require differentiability explicitly as it already implied by the derivative\nbeing strictly positive. -/\ntheorem strictMonoOn_of_deriv_pos {D : Set ‚Ñù} (hD : Convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù}\n    (hf : ContinuousOn f D) (hf' : ‚àÄ x ‚àà interior D, 0 < deriv f x) : StrictMonoOn f D := by\n  intro x hx y hy\n  have : DifferentiableOn ‚Ñù f (interior D) := fun z hz =>\n    (differentiableAt_of_deriv_ne_zero (hf' z hz).ne').differentiableWithinAt\n  simpa only [zero_mul, sub_pos] using\n    hD.mul_sub_lt_image_sub_of_lt_deriv hf this hf' x hx y hy\n\n"}
{"name":"strictMono_of_deriv_pos","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\nhf' : ‚àÄ (x : Real), LT.lt 0 (deriv f x)\n‚ä¢ StrictMono f","decl":"/-- Let `f : ‚Ñù ‚Üí ‚Ñù` be a differentiable function. If `f'` is positive, then\n`f` is a strictly monotone function.\nNote that we don't require differentiability explicitly as it already implied by the derivative\nbeing strictly positive. -/\ntheorem strictMono_of_deriv_pos {f : ‚Ñù ‚Üí ‚Ñù} (hf' : ‚àÄ x, 0 < deriv f x) : StrictMono f :=\n  strictMonoOn_univ.1 <| strictMonoOn_of_deriv_pos convex_univ (fun z _ =>\n    (differentiableAt_of_deriv_ne_zero (hf' z).ne').differentiableWithinAt.continuousWithinAt)\n    fun x _ => hf' x\n\n"}
{"name":"strictMonoOn_of_hasDerivWithinAt_pos","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"D : Set Real\nhD : Convex Real D\nf f' : Real ‚Üí Real\nhf : ContinuousOn f D\nhf' : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí HasDerivWithinAt f (f' x) (interior D) x\nhf'‚ÇÄ : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí LT.lt 0 (f' x)\n‚ä¢ StrictMonoOn f D","decl":"/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is strictly positive,\nthen `f` is a strictly monotone function on `D`. -/\nlemma strictMonoOn_of_hasDerivWithinAt_pos {D : Set ‚Ñù} (hD : Convex ‚Ñù D) {f f' : ‚Ñù ‚Üí ‚Ñù}\n    (hf : ContinuousOn f D) (hf' : ‚àÄ x ‚àà interior D, HasDerivWithinAt f (f' x) (interior D) x)\n    (hf'‚ÇÄ : ‚àÄ x ‚àà interior D, 0 < f' x) : StrictMonoOn f D :=\n  strictMonoOn_of_deriv_pos hD hf fun x hx ‚Ü¶ by\n    rw [deriv_eqOn isOpen_interior hf' hx]; exact hf'‚ÇÄ _ hx\n\n"}
{"name":"strictMono_of_hasDerivAt_pos","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f f' : Real ‚Üí Real\nhf : ‚àÄ (x : Real), HasDerivAt f (f' x) x\nhf' : ‚àÄ (x : Real), LT.lt 0 (f' x)\n‚ä¢ StrictMono f","decl":"/-- Let `f : ‚Ñù ‚Üí ‚Ñù` be a differentiable function. If `f'` is strictly positive, then\n`f` is a strictly monotone function. -/\nlemma strictMono_of_hasDerivAt_pos {f f' : ‚Ñù ‚Üí ‚Ñù} (hf : ‚àÄ x, HasDerivAt f (f' x) x)\n    (hf' : ‚àÄ x, 0 < f' x) : StrictMono f :=\n  strictMono_of_deriv_pos fun x ‚Ü¶ by rw [(hf _).deriv]; exact hf' _\n\n"}
{"name":"monotoneOn_of_deriv_nonneg","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"D : Set Real\nhD : Convex Real D\nf : Real ‚Üí Real\nhf : ContinuousOn f D\nhf' : DifferentiableOn Real f (interior D)\nhf'_nonneg : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí LE.le 0 (deriv f x)\n‚ä¢ MonotoneOn f D","decl":"/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is nonnegative, then\n`f` is a monotone function on `D`. -/\ntheorem monotoneOn_of_deriv_nonneg {D : Set ‚Ñù} (hD : Convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù}\n    (hf : ContinuousOn f D) (hf' : DifferentiableOn ‚Ñù f (interior D))\n    (hf'_nonneg : ‚àÄ x ‚àà interior D, 0 ‚â§ deriv f x) : MonotoneOn f D := fun x hx y hy hxy => by\n  simpa only [zero_mul, sub_nonneg] using\n    hD.mul_sub_le_image_sub_of_le_deriv hf hf' hf'_nonneg x hx y hy hxy\n\n"}
{"name":"monotone_of_deriv_nonneg","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\nhf : Differentiable Real f\nhf' : ‚àÄ (x : Real), LE.le 0 (deriv f x)\n‚ä¢ Monotone f","decl":"/-- Let `f : ‚Ñù ‚Üí ‚Ñù` be a differentiable function. If `f'` is nonnegative, then\n`f` is a monotone function. -/\ntheorem monotone_of_deriv_nonneg {f : ‚Ñù ‚Üí ‚Ñù} (hf : Differentiable ‚Ñù f) (hf' : ‚àÄ x, 0 ‚â§ deriv f x) :\n    Monotone f :=\n  monotoneOn_univ.1 <|\n    monotoneOn_of_deriv_nonneg convex_univ hf.continuous.continuousOn hf.differentiableOn fun x _ =>\n      hf' x\n\n"}
{"name":"monotoneOn_of_hasDerivWithinAt_nonneg","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"D : Set Real\nhD : Convex Real D\nf f' : Real ‚Üí Real\nhf : ContinuousOn f D\nhf' : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí HasDerivWithinAt f (f' x) (interior D) x\nhf'‚ÇÄ : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí LE.le 0 (f' x)\n‚ä¢ MonotoneOn f D","decl":"/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is nonnegative, then\n`f` is a monotone function on `D`. -/\nlemma monotoneOn_of_hasDerivWithinAt_nonneg {D : Set ‚Ñù} (hD : Convex ‚Ñù D) {f f' : ‚Ñù ‚Üí ‚Ñù}\n    (hf : ContinuousOn f D) (hf' : ‚àÄ x ‚àà interior D, HasDerivWithinAt f (f' x) (interior D) x)\n    (hf'‚ÇÄ : ‚àÄ x ‚àà interior D, 0 ‚â§ f' x) : MonotoneOn f D :=\n  monotoneOn_of_deriv_nonneg hD hf (fun _ hx ‚Ü¶ (hf' _ hx).differentiableWithinAt) fun x hx ‚Ü¶ by\n    rw [deriv_eqOn isOpen_interior hf' hx]; exact hf'‚ÇÄ _ hx\n\n"}
{"name":"monotone_of_hasDerivAt_nonneg","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f f' : Real ‚Üí Real\nhf : ‚àÄ (x : Real), HasDerivAt f (f' x) x\nhf' : LE.le 0 f'\n‚ä¢ Monotone f","decl":"/-- Let `f : ‚Ñù ‚Üí ‚Ñù` be a differentiable function. If `f'` is nonnegative, then\n`f` is a monotone function. -/\nlemma monotone_of_hasDerivAt_nonneg {f f' : ‚Ñù ‚Üí ‚Ñù} (hf : ‚àÄ x, HasDerivAt f (f' x) x)\n    (hf' : 0 ‚â§ f') : Monotone f :=\n  monotone_of_deriv_nonneg (fun _ ‚Ü¶ (hf _).differentiableAt) fun x ‚Ü¶ by\n    rw [(hf _).deriv]; exact hf' _\n\n"}
{"name":"strictAntiOn_of_deriv_neg","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"D : Set Real\nhD : Convex Real D\nf : Real ‚Üí Real\nhf : ContinuousOn f D\nhf' : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí LT.lt (deriv f x) 0\n‚ä¢ StrictAntiOn f D","decl":"/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is negative, then\n`f` is a strictly antitone function on `D`. -/\ntheorem strictAntiOn_of_deriv_neg {D : Set ‚Ñù} (hD : Convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù}\n    (hf : ContinuousOn f D) (hf' : ‚àÄ x ‚àà interior D, deriv f x < 0) : StrictAntiOn f D :=\n  fun x hx y => by\n  simpa only [zero_mul, sub_lt_zero] using\n    hD.image_sub_lt_mul_sub_of_deriv_lt hf\n      (fun z hz => (differentiableAt_of_deriv_ne_zero (hf' z hz).ne).differentiableWithinAt) hf' x\n      hx y\n\n"}
{"name":"strictAnti_of_deriv_neg","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\nhf' : ‚àÄ (x : Real), LT.lt (deriv f x) 0\n‚ä¢ StrictAnti f","decl":"/-- Let `f : ‚Ñù ‚Üí ‚Ñù` be a differentiable function. If `f'` is negative, then\n`f` is a strictly antitone function.\nNote that we don't require differentiability explicitly as it already implied by the derivative\nbeing strictly negative. -/\ntheorem strictAnti_of_deriv_neg {f : ‚Ñù ‚Üí ‚Ñù} (hf' : ‚àÄ x, deriv f x < 0) : StrictAnti f :=\n  strictAntiOn_univ.1 <| strictAntiOn_of_deriv_neg convex_univ\n      (fun z _ =>\n        (differentiableAt_of_deriv_ne_zero (hf' z).ne).differentiableWithinAt.continuousWithinAt)\n      fun x _ => hf' x\n\n"}
{"name":"strictAntiOn_of_hasDerivWithinAt_neg","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"D : Set Real\nhD : Convex Real D\nf f' : Real ‚Üí Real\nhf : ContinuousOn f D\nhf' : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí HasDerivWithinAt f (f' x) (interior D) x\nhf'‚ÇÄ : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí LT.lt (f' x) 0\n‚ä¢ StrictAntiOn f D","decl":"/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is strictly positive,\nthen `f` is a strictly monotone function on `D`. -/\nlemma strictAntiOn_of_hasDerivWithinAt_neg {D : Set ‚Ñù} (hD : Convex ‚Ñù D) {f f' : ‚Ñù ‚Üí ‚Ñù}\n    (hf : ContinuousOn f D) (hf' : ‚àÄ x ‚àà interior D, HasDerivWithinAt f (f' x) (interior D) x)\n    (hf'‚ÇÄ : ‚àÄ x ‚àà interior D, f' x < 0) : StrictAntiOn f D :=\n  strictAntiOn_of_deriv_neg hD hf fun x hx ‚Ü¶ by\n    rw [deriv_eqOn isOpen_interior hf' hx]; exact hf'‚ÇÄ _ hx\n\n"}
{"name":"strictAnti_of_hasDerivAt_neg","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f f' : Real ‚Üí Real\nhf : ‚àÄ (x : Real), HasDerivAt f (f' x) x\nhf' : ‚àÄ (x : Real), LT.lt (f' x) 0\n‚ä¢ StrictAnti f","decl":"/-- Let `f : ‚Ñù ‚Üí ‚Ñù` be a differentiable function. If `f'` is strictly positive, then\n`f` is a strictly monotone function. -/\nlemma strictAnti_of_hasDerivAt_neg {f f' : ‚Ñù ‚Üí ‚Ñù} (hf : ‚àÄ x, HasDerivAt f (f' x) x)\n    (hf' : ‚àÄ x, f' x < 0) : StrictAnti f :=\n  strictAnti_of_deriv_neg fun x ‚Ü¶ by rw [(hf _).deriv]; exact hf' _\n\n"}
{"name":"antitoneOn_of_deriv_nonpos","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"D : Set Real\nhD : Convex Real D\nf : Real ‚Üí Real\nhf : ContinuousOn f D\nhf' : DifferentiableOn Real f (interior D)\nhf'_nonpos : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí LE.le (deriv f x) 0\n‚ä¢ AntitoneOn f D","decl":"/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is nonpositive, then\n`f` is an antitone function on `D`. -/\ntheorem antitoneOn_of_deriv_nonpos {D : Set ‚Ñù} (hD : Convex ‚Ñù D) {f : ‚Ñù ‚Üí ‚Ñù}\n    (hf : ContinuousOn f D) (hf' : DifferentiableOn ‚Ñù f (interior D))\n    (hf'_nonpos : ‚àÄ x ‚àà interior D, deriv f x ‚â§ 0) : AntitoneOn f D := fun x hx y hy hxy => by\n  simpa only [zero_mul, sub_nonpos] using\n    hD.image_sub_le_mul_sub_of_deriv_le hf hf' hf'_nonpos x hx y hy hxy\n\n"}
{"name":"antitone_of_deriv_nonpos","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f : Real ‚Üí Real\nhf : Differentiable Real f\nhf' : ‚àÄ (x : Real), LE.le (deriv f x) 0\n‚ä¢ Antitone f","decl":"/-- Let `f : ‚Ñù ‚Üí ‚Ñù` be a differentiable function. If `f'` is nonpositive, then\n`f` is an antitone function. -/\ntheorem antitone_of_deriv_nonpos {f : ‚Ñù ‚Üí ‚Ñù} (hf : Differentiable ‚Ñù f) (hf' : ‚àÄ x, deriv f x ‚â§ 0) :\n    Antitone f :=\n  antitoneOn_univ.1 <|\n    antitoneOn_of_deriv_nonpos convex_univ hf.continuous.continuousOn hf.differentiableOn fun x _ =>\n      hf' x\n\n"}
{"name":"antitoneOn_of_hasDerivWithinAt_nonpos","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"D : Set Real\nhD : Convex Real D\nf f' : Real ‚Üí Real\nhf : ContinuousOn f D\nhf' : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí HasDerivWithinAt f (f' x) (interior D) x\nhf'‚ÇÄ : ‚àÄ (x : Real), Membership.mem (interior D) x ‚Üí LE.le (f' x) 0\n‚ä¢ AntitoneOn f D","decl":"/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is nonpositive, then\n`f` is an antitone function on `D`. -/\nlemma antitoneOn_of_hasDerivWithinAt_nonpos {D : Set ‚Ñù} (hD : Convex ‚Ñù D) {f f' : ‚Ñù ‚Üí ‚Ñù}\n    (hf : ContinuousOn f D) (hf' : ‚àÄ x ‚àà interior D, HasDerivWithinAt f (f' x) (interior D) x)\n    (hf'‚ÇÄ : ‚àÄ x ‚àà interior D, f' x ‚â§ 0) : AntitoneOn f D :=\n  antitoneOn_of_deriv_nonpos hD hf (fun _ hx ‚Ü¶ (hf' _ hx).differentiableWithinAt) fun x hx ‚Ü¶ by\n    rw [deriv_eqOn isOpen_interior hf' hx]; exact hf'‚ÇÄ _ hx\n\n"}
{"name":"antitone_of_hasDerivAt_nonpos","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"f f' : Real ‚Üí Real\nhf : ‚àÄ (x : Real), HasDerivAt f (f' x) x\nhf' : LE.le f' 0\n‚ä¢ Antitone f","decl":"/-- Let `f : ‚Ñù ‚Üí ‚Ñù` be a differentiable function. If `f'` is nonpositive, then `f` is an antitone\nfunction. -/\nlemma antitone_of_hasDerivAt_nonpos {f f' : ‚Ñù ‚Üí ‚Ñù} (hf : ‚àÄ x, HasDerivAt f (f' x) x)\n    (hf' : f' ‚â§ 0) : Antitone f :=\n  antitone_of_deriv_nonpos (fun _ ‚Ü¶ (hf _).differentiableAt) fun x ‚Ü¶ by\n    rw [(hf _).deriv]; exact hf' _\n\n"}
{"name":"domain_mvt","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\ns : Set E\nx y : E\nf' : E ‚Üí ContinuousLinearMap (RingHom.id Real) E Real\nhf : ‚àÄ (x : E), Membership.mem s x ‚Üí HasFDerivWithinAt f (f' x) s x\nhs : Convex Real s\nxs : Membership.mem s x\nys : Membership.mem s y\n‚ä¢ Exists fun z => And (Membership.mem (segment Real x y) z) (Eq (HSub.hSub (f y) (f x)) ((f' z) (HSub.hSub y x)))","decl":"/-- Lagrange's **Mean Value Theorem**, applied to convex domains. -/\ntheorem domain_mvt {f : E ‚Üí ‚Ñù} {s : Set E} {x y : E} {f' : E ‚Üí E ‚ÜíL[‚Ñù] ‚Ñù}\n    (hf : ‚àÄ x ‚àà s, HasFDerivWithinAt f (f' x) s x) (hs : Convex ‚Ñù s) (xs : x ‚àà s) (ys : y ‚àà s) :\n    ‚àÉ z ‚àà segment ‚Ñù x y, f y - f x = f' z (y - x) := by\n  -- Use `g = AffineMap.lineMap x y` to parametrize the segment\n  set g : ‚Ñù ‚Üí E := fun t => AffineMap.lineMap x y t\n  set I := Icc (0 : ‚Ñù) 1\n  have hsub : Ioo (0 : ‚Ñù) 1 ‚äÜ I := Ioo_subset_Icc_self\n  have hmaps : MapsTo g I s := hs.mapsTo_lineMap xs ys\n  -- The one-variable function `f ‚àò g` has derivative `f' (g t) (y - x)` at each `t ‚àà I`\n  have hfg : ‚àÄ t ‚àà I, HasDerivWithinAt (f ‚àò g) (f' (g t) (y - x)) I t := fun t ht =>\n    (hf _ (hmaps ht)).comp_hasDerivWithinAt t AffineMap.hasDerivWithinAt_lineMap hmaps\n  -- apply 1-variable mean value theorem to pullback\n  have hMVT : ‚àÉ t ‚àà Ioo (0 : ‚Ñù) 1, f' (g t) (y - x) = (f (g 1) - f (g 0)) / (1 - 0) := by\n    refine exists_hasDerivAt_eq_slope (f ‚àò g) _ (by norm_num) ?_ ?_\n    ¬∑ exact fun t Ht => (hfg t Ht).continuousWithinAt\n    ¬∑ exact fun t Ht => (hfg t <| hsub Ht).hasDerivAt (Icc_mem_nhds Ht.1 Ht.2)\n  -- reinterpret on domain\n  rcases hMVT with ‚ü®t, Ht, hMVT'‚ü©\n  rw [segment_eq_image_lineMap, exists_mem_image]\n  refine ‚ü®t, hsub Ht, ?_‚ü©\n  simpa [g] using hMVT'.symm\n\n"}
{"name":"hasStrictFDerivAt_of_hasFDerivAt_of_continuousAt","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\ninst‚úù‚Å¥ : RCLike ùïú\nG : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace ùïú G\nH : Type u_5\ninst‚úù¬π : NormedAddCommGroup H\ninst‚úù : NormedSpace ùïú H\nf : G ‚Üí H\nf' : G ‚Üí ContinuousLinearMap (RingHom.id ùïú) G H\nx : G\nhder : Filter.Eventually (fun y => HasFDerivAt f (f' y) y) (nhds x)\nhcont : ContinuousAt f' x\n‚ä¢ HasStrictFDerivAt f (f' x) x","decl":"/-- Over the reals or the complexes, a continuously differentiable function is strictly\ndifferentiable. -/\ntheorem hasStrictFDerivAt_of_hasFDerivAt_of_continuousAt\n    (hder : ‚àÄ·∂† y in ùìù x, HasFDerivAt f (f' y) y) (hcont : ContinuousAt f' x) :\n    HasStrictFDerivAt f (f' x) x := by\n  -- turn little-o definition of strict_fderiv into an epsilon-delta statement\n  rw [hasStrictFDerivAt_iff_isLittleO, isLittleO_iff]\n  refine fun c hc => Metric.eventually_nhds_iff_ball.mpr ?_\n  -- the correct Œµ is the modulus of continuity of f'\n  rcases Metric.mem_nhds_iff.mp (inter_mem hder (hcont <| ball_mem_nhds _ hc)) with ‚ü®Œµ, Œµ0, hŒµ‚ü©\n  refine ‚ü®Œµ, Œµ0, ?_‚ü©\n  -- simplify formulas involving the product E √ó E\n  rintro ‚ü®a, b‚ü© h\n  rw [‚Üê ball_prod_same, prod_mk_mem_set_prod_eq] at h\n  -- exploit the choice of Œµ as the modulus of continuity of f'\n  have hf' : ‚àÄ x' ‚àà ball x Œµ, ‚Äñf' x' - f' x‚Äñ ‚â§ c := fun x' H' => by\n    rw [‚Üê dist_eq_norm]\n    exact le_of_lt (hŒµ H').2\n  -- apply mean value theorem\n  letI : NormedSpace ‚Ñù G := RestrictScalars.normedSpace ‚Ñù ùïú G\n  refine (convex_ball _ _).norm_image_sub_le_of_norm_hasFDerivWithin_le' ?_ hf' h.2 h.1\n  exact fun y hy => (hŒµ hy).1.hasFDerivWithinAt\n\n"}
{"name":"hasStrictDerivAt_of_hasDerivAt_of_continuousAt","module":"Mathlib.Analysis.Calculus.MeanValue","initialProofState":"ùïú : Type u_3\ninst‚úù¬≤ : RCLike ùïú\nG : Type u_4\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace ùïú G\nf f' : ùïú ‚Üí G\nx : ùïú\nhder : Filter.Eventually (fun y => HasDerivAt f (f' y) y) (nhds x)\nhcont : ContinuousAt f' x\n‚ä¢ HasStrictDerivAt f (f' x) x","decl":"/-- Over the reals or the complexes, a continuously differentiable function is strictly\ndifferentiable. -/\ntheorem hasStrictDerivAt_of_hasDerivAt_of_continuousAt {f f' : ùïú ‚Üí G} {x : ùïú}\n    (hder : ‚àÄ·∂† y in ùìù x, HasDerivAt f (f' y) y) (hcont : ContinuousAt f' x) :\n    HasStrictDerivAt f (f' x) x :=\n  hasStrictFDerivAt_of_hasFDerivAt_of_continuousAt (hder.mono fun _ hy => hy.hasFDerivAt) <|\n    (smulRightL ùïú ùïú G 1).continuous.continuousAt.comp hcont\n\n"}
