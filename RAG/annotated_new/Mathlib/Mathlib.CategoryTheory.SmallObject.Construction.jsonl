{"name":"CategoryTheory.SmallObject.FunctorObjIndex.w","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\nself : CategoryTheory.SmallObject.FunctorObjIndex f Ï€X\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.t Ï€X) (CategoryTheory.CategoryStruct.comp (f self.i) self.b)","decl":"/-- Given a family of morphisms `f i : A i âŸ¶ B i` and a morphism `Ï€X : X âŸ¶ S`,\nthis type parametrizes the commutative squares with a morphism `f i` on the left\nand `Ï€X` in the right. -/\nstructure FunctorObjIndex where\n  /-- an element in the index type -/\n  i : I\n  /-- the top morphism in the square -/\n  t : A i âŸ¶ X\n  /-- the bottom morphism in the square -/\n  b : B i âŸ¶ S\n  w : t â‰« Ï€X = f i â‰« b\n\n"}
{"name":"CategoryTheory.SmallObject.FunctorObjIndex.mk.inj","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\niâœ : I\ntâœ : Quiver.Hom (A iâœ) X\nbâœ : Quiver.Hom (B iâœ) S\nwâœ : Eq (CategoryTheory.CategoryStruct.comp tâœ Ï€X) (CategoryTheory.CategoryStruct.comp (f iâœ) bâœ)\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t Ï€X) (CategoryTheory.CategoryStruct.comp (f i) b)\nxâœ : Eq { i := iâœ, t := tâœ, b := bâœ, w := wâœ } { i := i, t := t, b := b, w := w }\nâŠ¢ And (Eq iâœ i) (And (HEq tâœ t) (HEq bâœ b))","decl":"/-- Given a family of morphisms `f i : A i âŸ¶ B i` and a morphism `Ï€X : X âŸ¶ S`,\nthis type parametrizes the commutative squares with a morphism `f i` on the left\nand `Ï€X` in the right. -/\nstructure FunctorObjIndex where\n  /-- an element in the index type -/\n  i : I\n  /-- the top morphism in the square -/\n  t : A i âŸ¶ X\n  /-- the bottom morphism in the square -/\n  b : B i âŸ¶ S\n  w : t â‰« Ï€X = f i â‰« b\n\n"}
{"name":"CategoryTheory.SmallObject.FunctorObjIndex.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\ninstâœÂ¹ : SizeOf C\ninstâœ : SizeOf I\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t Ï€X) (CategoryTheory.CategoryStruct.comp (f i) b)\nâŠ¢ Eq (SizeOf.sizeOf { i := i, t := t, b := b, w := w }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf i)) (SizeOf.sizeOf t)) (SizeOf.sizeOf b)) (SizeOf.sizeOf w))","decl":"/-- Given a family of morphisms `f i : A i âŸ¶ B i` and a morphism `Ï€X : X âŸ¶ S`,\nthis type parametrizes the commutative squares with a morphism `f i` on the left\nand `Ï€X` in the right. -/\nstructure FunctorObjIndex where\n  /-- an element in the index type -/\n  i : I\n  /-- the top morphism in the square -/\n  t : A i âŸ¶ X\n  /-- the bottom morphism in the square -/\n  b : B i âŸ¶ S\n  w : t â‰« Ï€X = f i â‰« b\n\n"}
{"name":"CategoryTheory.SmallObject.FunctorObjIndex.mk.injEq","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\niâœ : I\ntâœ : Quiver.Hom (A iâœ) X\nbâœ : Quiver.Hom (B iâœ) S\nwâœ : Eq (CategoryTheory.CategoryStruct.comp tâœ Ï€X) (CategoryTheory.CategoryStruct.comp (f iâœ) bâœ)\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t Ï€X) (CategoryTheory.CategoryStruct.comp (f i) b)\nâŠ¢ Eq (Eq { i := iâœ, t := tâœ, b := bâœ, w := wâœ } { i := i, t := t, b := b, w := w }) (And (Eq iâœ i) (And (HEq tâœ t) (HEq bâœ b)))","decl":"/-- Given a family of morphisms `f i : A i âŸ¶ B i` and a morphism `Ï€X : X âŸ¶ S`,\nthis type parametrizes the commutative squares with a morphism `f i` on the left\nand `Ï€X` in the right. -/\nstructure FunctorObjIndex where\n  /-- an element in the index type -/\n  i : I\n  /-- the top morphism in the square -/\n  t : A i âŸ¶ X\n  /-- the bottom morphism in the square -/\n  b : B i âŸ¶ S\n  w : t â‰« Ï€X = f i â‰« b\n\n"}
{"name":"CategoryTheory.SmallObject.FunctorObjIndex.w_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\nself : CategoryTheory.SmallObject.FunctorObjIndex f Ï€X\nZ : C\nh : Quiver.Hom S Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.t (CategoryTheory.CategoryStruct.comp Ï€X h)) (CategoryTheory.CategoryStruct.comp (f self.i) (CategoryTheory.CategoryStruct.comp self.b h))","decl":"attribute [reassoc (attr := simp)] FunctorObjIndex.w\n\n"}
{"name":"CategoryTheory.SmallObject.functorObj_comm","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.Î¹FunctorObj f Ï€X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjLeft f Ï€X) (CategoryTheory.SmallObject.ÏFunctorObj f Ï€X))","decl":"@[reassoc]\nlemma functorObj_comm :\n    functorObjTop f Ï€X â‰« Î¹FunctorObj f Ï€X = functorObjLeft f Ï€X â‰« ÏFunctorObj f Ï€X :=\n  pushout.condition\n\n"}
{"name":"CategoryTheory.SmallObject.functorObj_comm_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\nZ : C\nh : Quiver.Hom (CategoryTheory.SmallObject.functorObj f Ï€X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.Î¹FunctorObj f Ï€X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjLeft f Ï€X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ÏFunctorObj f Ï€X) h))","decl":"@[reassoc]\nlemma functorObj_comm :\n    functorObjTop f Ï€X â‰« Î¹FunctorObj f Ï€X = functorObjLeft f Ï€X â‰« ÏFunctorObj f Ï€X :=\n  pushout.condition\n\n"}
{"name":"CategoryTheory.SmallObject.FunctorObjIndex.comm_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\nx : CategoryTheory.SmallObject.FunctorObjIndex f Ï€X\nZ : C\nh : Quiver.Hom (CategoryTheory.SmallObject.functorObj f Ï€X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (f x.i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (CategoryTheory.SmallObject.functorObjTgtFamily f Ï€X) x) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ÏFunctorObj f Ï€X) h))) (CategoryTheory.CategoryStruct.comp x.t (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.Î¹FunctorObj f Ï€X) h))","decl":"@[reassoc]\nlemma FunctorObjIndex.comm (x : FunctorObjIndex f Ï€X) :\n    f x.i â‰« Sigma.Î¹ (functorObjTgtFamily f Ï€X) x â‰« ÏFunctorObj f Ï€X = x.t â‰« Î¹FunctorObj f Ï€X := by\n  simpa using (Sigma.Î¹ (functorObjSrcFamily f Ï€X) x â‰«= functorObj_comm f Ï€X).symm\n\n"}
{"name":"CategoryTheory.SmallObject.FunctorObjIndex.comm","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\nx : CategoryTheory.SmallObject.FunctorObjIndex f Ï€X\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (f x.i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (CategoryTheory.SmallObject.functorObjTgtFamily f Ï€X) x) (CategoryTheory.SmallObject.ÏFunctorObj f Ï€X))) (CategoryTheory.CategoryStruct.comp x.t (CategoryTheory.SmallObject.Î¹FunctorObj f Ï€X))","decl":"@[reassoc]\nlemma FunctorObjIndex.comm (x : FunctorObjIndex f Ï€X) :\n    f x.i â‰« Sigma.Î¹ (functorObjTgtFamily f Ï€X) x â‰« ÏFunctorObj f Ï€X = x.t â‰« Î¹FunctorObj f Ï€X := by\n  simpa using (Sigma.Î¹ (functorObjSrcFamily f Ï€X) x â‰«= functorObj_comm f Ï€X).symm\n\n"}
{"name":"CategoryTheory.SmallObject.ÏFunctorObj_Ï€","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ÏFunctorObj f Ï€X) (CategoryTheory.SmallObject.Ï€FunctorObj f Ï€X)) (CategoryTheory.SmallObject.Ï€'FunctorObj f Ï€X)","decl":"@[reassoc (attr := simp)]\nlemma ÏFunctorObj_Ï€ : ÏFunctorObj f Ï€X â‰« Ï€FunctorObj f Ï€X = Ï€'FunctorObj f Ï€X := by\n  simp [Ï€FunctorObj]\n\n"}
{"name":"CategoryTheory.SmallObject.ÏFunctorObj_Ï€_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\nZ : C\nh : Quiver.Hom S Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ÏFunctorObj f Ï€X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.Ï€FunctorObj f Ï€X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.Ï€'FunctorObj f Ï€X) h)","decl":"@[reassoc (attr := simp)]\nlemma ÏFunctorObj_Ï€ : ÏFunctorObj f Ï€X â‰« Ï€FunctorObj f Ï€X = Ï€'FunctorObj f Ï€X := by\n  simp [Ï€FunctorObj]\n\n"}
{"name":"CategoryTheory.SmallObject.Î¹FunctorObj_Ï€FunctorObj_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\nZ : C\nh : Quiver.Hom S Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.Î¹FunctorObj f Ï€X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.Ï€FunctorObj f Ï€X) h)) (CategoryTheory.CategoryStruct.comp Ï€X h)","decl":"@[reassoc (attr := simp)]\nlemma Î¹FunctorObj_Ï€FunctorObj : Î¹FunctorObj f Ï€X â‰« Ï€FunctorObj f Ï€X = Ï€X := by\n  simp [Î¹FunctorObj, Ï€FunctorObj]\n\n"}
{"name":"CategoryTheory.SmallObject.Î¹FunctorObj_Ï€FunctorObj","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.Î¹FunctorObj f Ï€X) (CategoryTheory.SmallObject.Ï€FunctorObj f Ï€X)) Ï€X","decl":"@[reassoc (attr := simp)]\nlemma Î¹FunctorObj_Ï€FunctorObj : Î¹FunctorObj f Ï€X â‰« Ï€FunctorObj f Ï€X = Ï€X := by\n  simp [Î¹FunctorObj, Ï€FunctorObj]\n\n"}
{"name":"CategoryTheory.SmallObject.Î¹_functorMapSrc_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X Y : C\nÏ€X : Quiver.Hom X S\nÏ€Y : Quiver.Hom Y S\nÏ† : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€Y)) C\nhÏ† : Eq (CategoryTheory.CategoryStruct.comp Ï† Ï€Y) Ï€X\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t Ï€X) (CategoryTheory.CategoryStruct.comp (f i) b)\nt' : Quiver.Hom (A i) Y\nfac : Eq (CategoryTheory.CategoryStruct.comp t Ï†) t'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj (CategoryTheory.SmallObject.functorObjSrcFamily f Ï€Y)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (CategoryTheory.SmallObject.functorObjSrcFamily f Ï€X) { i := i, t := t, b := b, w := w }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMapSrc f Ï€X Ï€Y Ï† hÏ†) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (CategoryTheory.SmallObject.functorObjSrcFamily f Ï€Y) { i := i, t := t', b := b, w := â‹¯ }) h)","decl":"@[reassoc]\nlemma Î¹_functorMapSrc (i : I) (t : A i âŸ¶ X) (b : B i âŸ¶ S) (w : t â‰« Ï€X = f i â‰« b)\n    (t' : A i âŸ¶ Y) (fac : t â‰« Ï† = t') :\n    Sigma.Î¹ _ (FunctorObjIndex.mk i t b w) â‰« functorMapSrc f Ï€X Ï€Y Ï† hÏ† =\n      Sigma.Î¹ (functorObjSrcFamily f Ï€Y)\n        (FunctorObjIndex.mk i t' b (by rw [â† w, â† fac, assoc, hÏ†])) := by\n  subst fac\n  simp [functorMapSrc]\n\n"}
{"name":"CategoryTheory.SmallObject.Î¹_functorMapSrc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X Y : C\nÏ€X : Quiver.Hom X S\nÏ€Y : Quiver.Hom Y S\nÏ† : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€Y)) C\nhÏ† : Eq (CategoryTheory.CategoryStruct.comp Ï† Ï€Y) Ï€X\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t Ï€X) (CategoryTheory.CategoryStruct.comp (f i) b)\nt' : Quiver.Hom (A i) Y\nfac : Eq (CategoryTheory.CategoryStruct.comp t Ï†) t'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (CategoryTheory.SmallObject.functorObjSrcFamily f Ï€X) { i := i, t := t, b := b, w := w }) (CategoryTheory.SmallObject.functorMapSrc f Ï€X Ï€Y Ï† hÏ†)) (CategoryTheory.Limits.Sigma.Î¹ (CategoryTheory.SmallObject.functorObjSrcFamily f Ï€Y) { i := i, t := t', b := b, w := â‹¯ })","decl":"@[reassoc]\nlemma Î¹_functorMapSrc (i : I) (t : A i âŸ¶ X) (b : B i âŸ¶ S) (w : t â‰« Ï€X = f i â‰« b)\n    (t' : A i âŸ¶ Y) (fac : t â‰« Ï† = t') :\n    Sigma.Î¹ _ (FunctorObjIndex.mk i t b w) â‰« functorMapSrc f Ï€X Ï€Y Ï† hÏ† =\n      Sigma.Î¹ (functorObjSrcFamily f Ï€Y)\n        (FunctorObjIndex.mk i t' b (by rw [â† w, â† fac, assoc, hÏ†])) := by\n  subst fac\n  simp [functorMapSrc]\n\n"}
{"name":"CategoryTheory.SmallObject.functorMapSrc_functorObjTop_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X Y : C\nÏ€X : Quiver.Hom X S\nÏ€Y : Quiver.Hom Y S\nÏ† : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€Y)) C\nhÏ† : Eq (CategoryTheory.CategoryStruct.comp Ï† Ï€Y) Ï€X\nZ : C\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMapSrc f Ï€X Ï€Y Ï† hÏ†) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjTop f Ï€Y) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.CategoryStruct.comp Ï† h))","decl":"@[reassoc (attr := simp)]\nlemma functorMapSrc_functorObjTop :\n    functorMapSrc f Ï€X Ï€Y Ï† hÏ† â‰« functorObjTop f Ï€Y = functorObjTop f Ï€X â‰« Ï† := by\n  ext âŸ¨i, t, b, wâŸ©\n  simp [Î¹_functorMapSrc_assoc f Ï€X Ï€Y Ï† hÏ† i t b w _ rfl]\n\n"}
{"name":"CategoryTheory.SmallObject.functorMapSrc_functorObjTop","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X Y : C\nÏ€X : Quiver.Hom X S\nÏ€Y : Quiver.Hom Y S\nÏ† : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€Y)) C\nhÏ† : Eq (CategoryTheory.CategoryStruct.comp Ï† Ï€Y) Ï€X\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMapSrc f Ï€X Ï€Y Ï† hÏ†) (CategoryTheory.SmallObject.functorObjTop f Ï€Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjTop f Ï€X) Ï†)","decl":"@[reassoc (attr := simp)]\nlemma functorMapSrc_functorObjTop :\n    functorMapSrc f Ï€X Ï€Y Ï† hÏ† â‰« functorObjTop f Ï€Y = functorObjTop f Ï€X â‰« Ï† := by\n  ext âŸ¨i, t, b, wâŸ©\n  simp [Î¹_functorMapSrc_assoc f Ï€X Ï€Y Ï† hÏ† i t b w _ rfl]\n\n"}
{"name":"CategoryTheory.SmallObject.Î¹_functorMapTgt_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X Y : C\nÏ€X : Quiver.Hom X S\nÏ€Y : Quiver.Hom Y S\nÏ† : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€Y)) C\nhÏ† : Eq (CategoryTheory.CategoryStruct.comp Ï† Ï€Y) Ï€X\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t Ï€X) (CategoryTheory.CategoryStruct.comp (f i) b)\nt' : Quiver.Hom (A i) Y\nfac : Eq (CategoryTheory.CategoryStruct.comp t Ï†) t'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj (CategoryTheory.SmallObject.functorObjTgtFamily f Ï€Y)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (CategoryTheory.SmallObject.functorObjTgtFamily f Ï€X) { i := i, t := t, b := b, w := w }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMapTgt f Ï€X Ï€Y Ï† hÏ†) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (CategoryTheory.SmallObject.functorObjTgtFamily f Ï€Y) { i := i, t := t', b := b, w := â‹¯ }) h)","decl":"@[reassoc]\nlemma Î¹_functorMapTgt (i : I) (t : A i âŸ¶ X) (b : B i âŸ¶ S) (w : t â‰« Ï€X = f i â‰« b)\n    (t' : A i âŸ¶ Y) (fac : t â‰« Ï† = t') :\n    Sigma.Î¹ _ (FunctorObjIndex.mk i t b w) â‰« functorMapTgt f Ï€X Ï€Y Ï† hÏ† =\n      Sigma.Î¹ (functorObjTgtFamily f Ï€Y)\n        (FunctorObjIndex.mk i t' b (by rw [â† w, â† fac, assoc, hÏ†])) := by\n  subst fac\n  simp [functorMapTgt]\n\n"}
{"name":"CategoryTheory.SmallObject.Î¹_functorMapTgt","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X Y : C\nÏ€X : Quiver.Hom X S\nÏ€Y : Quiver.Hom Y S\nÏ† : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€Y)) C\nhÏ† : Eq (CategoryTheory.CategoryStruct.comp Ï† Ï€Y) Ï€X\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t Ï€X) (CategoryTheory.CategoryStruct.comp (f i) b)\nt' : Quiver.Hom (A i) Y\nfac : Eq (CategoryTheory.CategoryStruct.comp t Ï†) t'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.Î¹ (CategoryTheory.SmallObject.functorObjTgtFamily f Ï€X) { i := i, t := t, b := b, w := w }) (CategoryTheory.SmallObject.functorMapTgt f Ï€X Ï€Y Ï† hÏ†)) (CategoryTheory.Limits.Sigma.Î¹ (CategoryTheory.SmallObject.functorObjTgtFamily f Ï€Y) { i := i, t := t', b := b, w := â‹¯ })","decl":"@[reassoc]\nlemma Î¹_functorMapTgt (i : I) (t : A i âŸ¶ X) (b : B i âŸ¶ S) (w : t â‰« Ï€X = f i â‰« b)\n    (t' : A i âŸ¶ Y) (fac : t â‰« Ï† = t') :\n    Sigma.Î¹ _ (FunctorObjIndex.mk i t b w) â‰« functorMapTgt f Ï€X Ï€Y Ï† hÏ† =\n      Sigma.Î¹ (functorObjTgtFamily f Ï€Y)\n        (FunctorObjIndex.mk i t' b (by rw [â† w, â† fac, assoc, hÏ†])) := by\n  subst fac\n  simp [functorMapTgt]\n\n"}
{"name":"CategoryTheory.SmallObject.functorMap_comm","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X Y : C\nÏ€X : Quiver.Hom X S\nÏ€Y : Quiver.Hom Y S\nÏ† : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€Y)) C\nhÏ† : Eq (CategoryTheory.CategoryStruct.comp Ï† Ï€Y) Ï€X\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjLeft f Ï€X) (CategoryTheory.SmallObject.functorMapTgt f Ï€X Ï€Y Ï† hÏ†)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMapSrc f Ï€X Ï€Y Ï† hÏ†) (CategoryTheory.SmallObject.functorObjLeft f Ï€Y))","decl":"lemma functorMap_comm :\n    functorObjLeft f Ï€X â‰« functorMapTgt f Ï€X Ï€Y Ï† hÏ† =\n      functorMapSrc f Ï€X Ï€Y Ï† hÏ† â‰« functorObjLeft f Ï€Y := by\n  ext âŸ¨i, t, b, wâŸ©\n  simp only [Î¹_colimMap_assoc, Discrete.natTrans_app, Î¹_colimMap,\n    Î¹_functorMapTgt f Ï€X Ï€Y Ï† hÏ† i t b w _ rfl,\n    Î¹_functorMapSrc_assoc f Ï€X Ï€Y Ï† hÏ† i t b w _ rfl]\n\n"}
{"name":"CategoryTheory.SmallObject.functorMap_Ï€_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X Y : C\nÏ€X : Quiver.Hom X S\nÏ€Y : Quiver.Hom Y S\nÏ† : Quiver.Hom X Y\ninstâœÂ³ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€Y)) C\nhÏ† : Eq (CategoryTheory.CategoryStruct.comp Ï† Ï€Y) Ï€X\ninstâœÂ¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€Y) (CategoryTheory.SmallObject.functorObjLeft f Ï€Y)\nZ : C\nh : Quiver.Hom S Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMap f Ï€X Ï€Y Ï† hÏ†) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.Ï€FunctorObj f Ï€Y) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.Ï€FunctorObj f Ï€X) h)","decl":"@[reassoc (attr := simp)]\nlemma functorMap_Ï€ : functorMap f Ï€X Ï€Y Ï† hÏ† â‰« Ï€FunctorObj f Ï€Y = Ï€FunctorObj f Ï€X := by\n  ext âŸ¨i, t, b, wâŸ©\n  Â· simp [functorMap, hÏ†]\n  Â· simp [functorMap, Î¹_functorMapTgt_assoc f Ï€X Ï€Y Ï† hÏ† i t b w _ rfl]\n\n"}
{"name":"CategoryTheory.SmallObject.functorMap_Ï€","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X Y : C\nÏ€X : Quiver.Hom X S\nÏ€Y : Quiver.Hom Y S\nÏ† : Quiver.Hom X Y\ninstâœÂ³ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€Y)) C\nhÏ† : Eq (CategoryTheory.CategoryStruct.comp Ï† Ï€Y) Ï€X\ninstâœÂ¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€Y) (CategoryTheory.SmallObject.functorObjLeft f Ï€Y)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMap f Ï€X Ï€Y Ï† hÏ†) (CategoryTheory.SmallObject.Ï€FunctorObj f Ï€Y)) (CategoryTheory.SmallObject.Ï€FunctorObj f Ï€X)","decl":"@[reassoc (attr := simp)]\nlemma functorMap_Ï€ : functorMap f Ï€X Ï€Y Ï† hÏ† â‰« Ï€FunctorObj f Ï€Y = Ï€FunctorObj f Ï€X := by\n  ext âŸ¨i, t, b, wâŸ©\n  Â· simp [functorMap, hÏ†]\n  Â· simp [functorMap, Î¹_functorMapTgt_assoc f Ï€X Ï€Y Ï† hÏ† i t b w _ rfl]\n\n"}
{"name":"CategoryTheory.SmallObject.functorMap_id","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\nâŠ¢ Eq (CategoryTheory.SmallObject.functorMap f Ï€X Ï€X (CategoryTheory.CategoryStruct.id X) â‹¯) (CategoryTheory.CategoryStruct.id (CategoryTheory.SmallObject.functorObj f Ï€X))","decl":"variable (X) in\n@[simp]\nlemma functorMap_id : functorMap f Ï€X Ï€X (ğŸ™ X) (by simp) = ğŸ™ _ := by\n  ext âŸ¨i, t, b, wâŸ©\n  Â· simp [functorMap]\n  Â· simp [functorMap, Î¹_functorMapTgt_assoc f Ï€X Ï€X (ğŸ™ X) (by simp) i t b w t (by simp)]\n\n"}
{"name":"CategoryTheory.SmallObject.Î¹FunctorObj_naturality","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X Y : C\nÏ€X : Quiver.Hom X S\nÏ€Y : Quiver.Hom Y S\nÏ† : Quiver.Hom X Y\ninstâœÂ³ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€Y)) C\nhÏ† : Eq (CategoryTheory.CategoryStruct.comp Ï† Ï€Y) Ï€X\ninstâœÂ¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€Y) (CategoryTheory.SmallObject.functorObjLeft f Ï€Y)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.Î¹FunctorObj f Ï€X) (CategoryTheory.SmallObject.functorMap f Ï€X Ï€Y Ï† hÏ†)) (CategoryTheory.CategoryStruct.comp Ï† (CategoryTheory.SmallObject.Î¹FunctorObj f Ï€Y))","decl":"@[reassoc (attr := simp)]\nlemma Î¹FunctorObj_naturality :\n    Î¹FunctorObj f Ï€X â‰« functorMap f Ï€X Ï€Y Ï† hÏ† = Ï† â‰« Î¹FunctorObj f Ï€Y := by\n  simp [Î¹FunctorObj, functorMap]\n\n"}
{"name":"CategoryTheory.SmallObject.Î¹FunctorObj_naturality_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X Y : C\nÏ€X : Quiver.Hom X S\nÏ€Y : Quiver.Hom Y S\nÏ† : Quiver.Hom X Y\ninstâœÂ³ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€Y)) C\nhÏ† : Eq (CategoryTheory.CategoryStruct.comp Ï† Ï€Y) Ï€X\ninstâœÂ¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€Y) (CategoryTheory.SmallObject.functorObjLeft f Ï€Y)\nZ : C\nh : Quiver.Hom (CategoryTheory.SmallObject.functorObj f Ï€Y) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.Î¹FunctorObj f Ï€X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMap f Ï€X Ï€Y Ï† hÏ†) h)) (CategoryTheory.CategoryStruct.comp Ï† (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.Î¹FunctorObj f Ï€Y) h))","decl":"@[reassoc (attr := simp)]\nlemma Î¹FunctorObj_naturality :\n    Î¹FunctorObj f Ï€X â‰« functorMap f Ï€X Ï€Y Ï† hÏ† = Ï† â‰« Î¹FunctorObj f Ï€Y := by\n  simp [Î¹FunctorObj, functorMap]\n\n"}
{"name":"CategoryTheory.SmallObject.Î¹FunctorObj_extension","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS X : C\nÏ€X : Quiver.Hom X S\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\ninstâœ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f Ï€X) (CategoryTheory.SmallObject.functorObjLeft f Ï€X)\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nsq : CategoryTheory.CommSq t (f i) Ï€X b\nâŠ¢ Exists fun l => And (Eq (CategoryTheory.CategoryStruct.comp (f i) l) (CategoryTheory.CategoryStruct.comp t (CategoryTheory.SmallObject.Î¹FunctorObj f Ï€X))) (Eq (CategoryTheory.CategoryStruct.comp l (CategoryTheory.SmallObject.Ï€FunctorObj f Ï€X)) b)","decl":"lemma Î¹FunctorObj_extension {i : I} (t : A i âŸ¶ X) (b : B i âŸ¶ S)\n    (sq : CommSq t (f i) Ï€X b) :\n    âˆƒ (l : B i âŸ¶ functorObj f Ï€X), f i â‰« l = t â‰« Î¹FunctorObj f Ï€X âˆ§\n      l â‰« Ï€FunctorObj f Ï€X = b :=\n  âŸ¨Sigma.Î¹ (functorObjTgtFamily f Ï€X) (FunctorObjIndex.mk i t b sq.w) â‰«\n    ÏFunctorObj f Ï€X, (FunctorObjIndex.mk i t b _).comm, by simpâŸ©\n\n"}
{"name":"CategoryTheory.SmallObject.functor_map","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS : C\ninstâœÂ¹ : CategoryTheory.Limits.HasPushouts C\ninstâœ : âˆ€ {X : C} (Ï€X : Quiver.Hom X S), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\nÏ€â‚ Ï€â‚‚ : CategoryTheory.Over S\nÏ† : Quiver.Hom Ï€â‚ Ï€â‚‚\nâŠ¢ Eq ((CategoryTheory.SmallObject.functor f S).map Ï†) (CategoryTheory.Over.homMk (CategoryTheory.SmallObject.functorMap f Ï€â‚.hom Ï€â‚‚.hom Ï†.left â‹¯) â‹¯)","decl":"/-- The functor `Over S â¥¤ Over S` that is constructed in order to apply the small\nobject argument to a family of morphisms `f i : A i âŸ¶ B i`, see the introduction\nof the file `Mathlib.CategoryTheory.SmallObject.Construction` -/\n@[simps! obj map]\nnoncomputable def functor : Over S â¥¤ Over S where\n  obj Ï€ := Over.mk (Ï€FunctorObj f Ï€.hom)\n  map {Ï€â‚ Ï€â‚‚} Ï† := Over.homMk (functorMap f Ï€â‚.hom Ï€â‚‚.hom Ï†.left (Over.w Ï†))\n  map_id _ := by ext; dsimp; simp\n  map_comp {Ï€â‚ Ï€â‚‚ Ï€â‚ƒ} Ï† Ï†' := by\n    ext1\n    dsimp\n    ext âŸ¨i, t, b, wâŸ©\n    Â· simp\n    Â· simp [functorMap, Î¹_functorMapTgt_assoc f Ï€â‚.hom Ï€â‚‚.hom Ï†.left (Over.w Ï†) i t b w _ rfl,\n        Î¹_functorMapTgt_assoc f Ï€â‚.hom Ï€â‚ƒ.hom (Ï†.left â‰« Ï†'.left) (Over.w (Ï† â‰« Ï†')) i t b w _ rfl,\n        Î¹_functorMapTgt_assoc f Ï€â‚‚.hom Ï€â‚ƒ.hom (Ï†'.left) (Over.w Ï†') i (t â‰« Ï†.left) b\n          (by simp [w]) (t â‰« Ï†.left â‰« Ï†'.left) (by simp)]\n\n"}
{"name":"CategoryTheory.SmallObject.functor_obj","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS : C\ninstâœÂ¹ : CategoryTheory.Limits.HasPushouts C\ninstâœ : âˆ€ {X : C} (Ï€X : Quiver.Hom X S), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\nÏ€ : CategoryTheory.Over S\nâŠ¢ Eq ((CategoryTheory.SmallObject.functor f S).obj Ï€) (CategoryTheory.Over.mk (CategoryTheory.SmallObject.Ï€FunctorObj f Ï€.hom))","decl":"/-- The functor `Over S â¥¤ Over S` that is constructed in order to apply the small\nobject argument to a family of morphisms `f i : A i âŸ¶ B i`, see the introduction\nof the file `Mathlib.CategoryTheory.SmallObject.Construction` -/\n@[simps! obj map]\nnoncomputable def functor : Over S â¥¤ Over S where\n  obj Ï€ := Over.mk (Ï€FunctorObj f Ï€.hom)\n  map {Ï€â‚ Ï€â‚‚} Ï† := Over.homMk (functorMap f Ï€â‚.hom Ï€â‚‚.hom Ï†.left (Over.w Ï†))\n  map_id _ := by ext; dsimp; simp\n  map_comp {Ï€â‚ Ï€â‚‚ Ï€â‚ƒ} Ï† Ï†' := by\n    ext1\n    dsimp\n    ext âŸ¨i, t, b, wâŸ©\n    Â· simp\n    Â· simp [functorMap, Î¹_functorMapTgt_assoc f Ï€â‚.hom Ï€â‚‚.hom Ï†.left (Over.w Ï†) i t b w _ rfl,\n        Î¹_functorMapTgt_assoc f Ï€â‚.hom Ï€â‚ƒ.hom (Ï†.left â‰« Ï†'.left) (Over.w (Ï† â‰« Ï†')) i t b w _ rfl,\n        Î¹_functorMapTgt_assoc f Ï€â‚‚.hom Ï€â‚ƒ.hom (Ï†'.left) (Over.w Ï†') i (t â‰« Ï†.left) b\n          (by simp [w]) (t â‰« Ï†.left â‰« Ï†'.left) (by simp)]\n\n"}
{"name":"CategoryTheory.SmallObject.Îµ_app","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I â†’ C\nf : (i : I) â†’ Quiver.Hom (A i) (B i)\nS : C\ninstâœÂ¹ : CategoryTheory.Limits.HasPushouts C\ninstâœ : âˆ€ {X : C} (Ï€X : Quiver.Hom X S), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f Ï€X)) C\nw : CategoryTheory.Over S\nâŠ¢ Eq ((CategoryTheory.SmallObject.Îµ f S).app w) (CategoryTheory.Over.homMk (CategoryTheory.SmallObject.Î¹FunctorObj f w.hom) â‹¯)","decl":"/-- The canonical natural transformation `ğŸ­ (Over S) âŸ¶ functor f S`. -/\n@[simps! app]\nnoncomputable def Îµ : ğŸ­ (Over S) âŸ¶ functor f S where\n  app w := Over.homMk (Î¹FunctorObj f w.hom)\n\n"}
