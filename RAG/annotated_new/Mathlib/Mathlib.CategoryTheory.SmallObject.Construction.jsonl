{"name":"CategoryTheory.SmallObject.FunctorObjIndex.w","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\nself : CategoryTheory.SmallObject.FunctorObjIndex f πX\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.t πX) (CategoryTheory.CategoryStruct.comp (f self.i) self.b)","decl":"/-- Given a family of morphisms `f i : A i ⟶ B i` and a morphism `πX : X ⟶ S`,\nthis type parametrizes the commutative squares with a morphism `f i` on the left\nand `πX` in the right. -/\nstructure FunctorObjIndex where\n  /-- an element in the index type -/\n  i : I\n  /-- the top morphism in the square -/\n  t : A i ⟶ X\n  /-- the bottom morphism in the square -/\n  b : B i ⟶ S\n  w : t ≫ πX = f i ≫ b\n\n"}
{"name":"CategoryTheory.SmallObject.FunctorObjIndex.mk.inj","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\ni✝ : I\nt✝ : Quiver.Hom (A i✝) X\nb✝ : Quiver.Hom (B i✝) S\nw✝ : Eq (CategoryTheory.CategoryStruct.comp t✝ πX) (CategoryTheory.CategoryStruct.comp (f i✝) b✝)\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t πX) (CategoryTheory.CategoryStruct.comp (f i) b)\nx✝ : Eq { i := i✝, t := t✝, b := b✝, w := w✝ } { i := i, t := t, b := b, w := w }\n⊢ And (Eq i✝ i) (And (HEq t✝ t) (HEq b✝ b))","decl":"/-- Given a family of morphisms `f i : A i ⟶ B i` and a morphism `πX : X ⟶ S`,\nthis type parametrizes the commutative squares with a morphism `f i` on the left\nand `πX` in the right. -/\nstructure FunctorObjIndex where\n  /-- an element in the index type -/\n  i : I\n  /-- the top morphism in the square -/\n  t : A i ⟶ X\n  /-- the bottom morphism in the square -/\n  b : B i ⟶ S\n  w : t ≫ πX = f i ≫ b\n\n"}
{"name":"CategoryTheory.SmallObject.FunctorObjIndex.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\ninst✝¹ : SizeOf C\ninst✝ : SizeOf I\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t πX) (CategoryTheory.CategoryStruct.comp (f i) b)\n⊢ Eq (SizeOf.sizeOf { i := i, t := t, b := b, w := w }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf i)) (SizeOf.sizeOf t)) (SizeOf.sizeOf b)) (SizeOf.sizeOf w))","decl":"/-- Given a family of morphisms `f i : A i ⟶ B i` and a morphism `πX : X ⟶ S`,\nthis type parametrizes the commutative squares with a morphism `f i` on the left\nand `πX` in the right. -/\nstructure FunctorObjIndex where\n  /-- an element in the index type -/\n  i : I\n  /-- the top morphism in the square -/\n  t : A i ⟶ X\n  /-- the bottom morphism in the square -/\n  b : B i ⟶ S\n  w : t ≫ πX = f i ≫ b\n\n"}
{"name":"CategoryTheory.SmallObject.FunctorObjIndex.mk.injEq","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\ni✝ : I\nt✝ : Quiver.Hom (A i✝) X\nb✝ : Quiver.Hom (B i✝) S\nw✝ : Eq (CategoryTheory.CategoryStruct.comp t✝ πX) (CategoryTheory.CategoryStruct.comp (f i✝) b✝)\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t πX) (CategoryTheory.CategoryStruct.comp (f i) b)\n⊢ Eq (Eq { i := i✝, t := t✝, b := b✝, w := w✝ } { i := i, t := t, b := b, w := w }) (And (Eq i✝ i) (And (HEq t✝ t) (HEq b✝ b)))","decl":"/-- Given a family of morphisms `f i : A i ⟶ B i` and a morphism `πX : X ⟶ S`,\nthis type parametrizes the commutative squares with a morphism `f i` on the left\nand `πX` in the right. -/\nstructure FunctorObjIndex where\n  /-- an element in the index type -/\n  i : I\n  /-- the top morphism in the square -/\n  t : A i ⟶ X\n  /-- the bottom morphism in the square -/\n  b : B i ⟶ S\n  w : t ≫ πX = f i ≫ b\n\n"}
{"name":"CategoryTheory.SmallObject.FunctorObjIndex.w_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\nself : CategoryTheory.SmallObject.FunctorObjIndex f πX\nZ : C\nh : Quiver.Hom S Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.t (CategoryTheory.CategoryStruct.comp πX h)) (CategoryTheory.CategoryStruct.comp (f self.i) (CategoryTheory.CategoryStruct.comp self.b h))","decl":"attribute [reassoc (attr := simp)] FunctorObjIndex.w\n\n"}
{"name":"CategoryTheory.SmallObject.functorObj_comm","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.ιFunctorObj f πX)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjLeft f πX) (CategoryTheory.SmallObject.ρFunctorObj f πX))","decl":"@[reassoc]\nlemma functorObj_comm :\n    functorObjTop f πX ≫ ιFunctorObj f πX = functorObjLeft f πX ≫ ρFunctorObj f πX :=\n  pushout.condition\n\n"}
{"name":"CategoryTheory.SmallObject.functorObj_comm_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\nZ : C\nh : Quiver.Hom (CategoryTheory.SmallObject.functorObj f πX) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ιFunctorObj f πX) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjLeft f πX) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ρFunctorObj f πX) h))","decl":"@[reassoc]\nlemma functorObj_comm :\n    functorObjTop f πX ≫ ιFunctorObj f πX = functorObjLeft f πX ≫ ρFunctorObj f πX :=\n  pushout.condition\n\n"}
{"name":"CategoryTheory.SmallObject.FunctorObjIndex.comm_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\nx : CategoryTheory.SmallObject.FunctorObjIndex f πX\nZ : C\nh : Quiver.Hom (CategoryTheory.SmallObject.functorObj f πX) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f x.i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (CategoryTheory.SmallObject.functorObjTgtFamily f πX) x) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ρFunctorObj f πX) h))) (CategoryTheory.CategoryStruct.comp x.t (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ιFunctorObj f πX) h))","decl":"@[reassoc]\nlemma FunctorObjIndex.comm (x : FunctorObjIndex f πX) :\n    f x.i ≫ Sigma.ι (functorObjTgtFamily f πX) x ≫ ρFunctorObj f πX = x.t ≫ ιFunctorObj f πX := by\n  simpa using (Sigma.ι (functorObjSrcFamily f πX) x ≫= functorObj_comm f πX).symm\n\n"}
{"name":"CategoryTheory.SmallObject.FunctorObjIndex.comm","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\nx : CategoryTheory.SmallObject.FunctorObjIndex f πX\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f x.i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (CategoryTheory.SmallObject.functorObjTgtFamily f πX) x) (CategoryTheory.SmallObject.ρFunctorObj f πX))) (CategoryTheory.CategoryStruct.comp x.t (CategoryTheory.SmallObject.ιFunctorObj f πX))","decl":"@[reassoc]\nlemma FunctorObjIndex.comm (x : FunctorObjIndex f πX) :\n    f x.i ≫ Sigma.ι (functorObjTgtFamily f πX) x ≫ ρFunctorObj f πX = x.t ≫ ιFunctorObj f πX := by\n  simpa using (Sigma.ι (functorObjSrcFamily f πX) x ≫= functorObj_comm f πX).symm\n\n"}
{"name":"CategoryTheory.SmallObject.ρFunctorObj_π","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ρFunctorObj f πX) (CategoryTheory.SmallObject.πFunctorObj f πX)) (CategoryTheory.SmallObject.π'FunctorObj f πX)","decl":"@[reassoc (attr := simp)]\nlemma ρFunctorObj_π : ρFunctorObj f πX ≫ πFunctorObj f πX = π'FunctorObj f πX := by\n  simp [πFunctorObj]\n\n"}
{"name":"CategoryTheory.SmallObject.ρFunctorObj_π_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\nZ : C\nh : Quiver.Hom S Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ρFunctorObj f πX) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.πFunctorObj f πX) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.π'FunctorObj f πX) h)","decl":"@[reassoc (attr := simp)]\nlemma ρFunctorObj_π : ρFunctorObj f πX ≫ πFunctorObj f πX = π'FunctorObj f πX := by\n  simp [πFunctorObj]\n\n"}
{"name":"CategoryTheory.SmallObject.ιFunctorObj_πFunctorObj_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\nZ : C\nh : Quiver.Hom S Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ιFunctorObj f πX) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.πFunctorObj f πX) h)) (CategoryTheory.CategoryStruct.comp πX h)","decl":"@[reassoc (attr := simp)]\nlemma ιFunctorObj_πFunctorObj : ιFunctorObj f πX ≫ πFunctorObj f πX = πX := by\n  simp [ιFunctorObj, πFunctorObj]\n\n"}
{"name":"CategoryTheory.SmallObject.ιFunctorObj_πFunctorObj","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ιFunctorObj f πX) (CategoryTheory.SmallObject.πFunctorObj f πX)) πX","decl":"@[reassoc (attr := simp)]\nlemma ιFunctorObj_πFunctorObj : ιFunctorObj f πX ≫ πFunctorObj f πX = πX := by\n  simp [ιFunctorObj, πFunctorObj]\n\n"}
{"name":"CategoryTheory.SmallObject.ι_functorMapSrc_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X Y : C\nπX : Quiver.Hom X S\nπY : Quiver.Hom Y S\nφ : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πY)) C\nhφ : Eq (CategoryTheory.CategoryStruct.comp φ πY) πX\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t πX) (CategoryTheory.CategoryStruct.comp (f i) b)\nt' : Quiver.Hom (A i) Y\nfac : Eq (CategoryTheory.CategoryStruct.comp t φ) t'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj (CategoryTheory.SmallObject.functorObjSrcFamily f πY)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (CategoryTheory.SmallObject.functorObjSrcFamily f πX) { i := i, t := t, b := b, w := w }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMapSrc f πX πY φ hφ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (CategoryTheory.SmallObject.functorObjSrcFamily f πY) { i := i, t := t', b := b, w := ⋯ }) h)","decl":"@[reassoc]\nlemma ι_functorMapSrc (i : I) (t : A i ⟶ X) (b : B i ⟶ S) (w : t ≫ πX = f i ≫ b)\n    (t' : A i ⟶ Y) (fac : t ≫ φ = t') :\n    Sigma.ι _ (FunctorObjIndex.mk i t b w) ≫ functorMapSrc f πX πY φ hφ =\n      Sigma.ι (functorObjSrcFamily f πY)\n        (FunctorObjIndex.mk i t' b (by rw [← w, ← fac, assoc, hφ])) := by\n  subst fac\n  simp [functorMapSrc]\n\n"}
{"name":"CategoryTheory.SmallObject.ι_functorMapSrc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X Y : C\nπX : Quiver.Hom X S\nπY : Quiver.Hom Y S\nφ : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πY)) C\nhφ : Eq (CategoryTheory.CategoryStruct.comp φ πY) πX\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t πX) (CategoryTheory.CategoryStruct.comp (f i) b)\nt' : Quiver.Hom (A i) Y\nfac : Eq (CategoryTheory.CategoryStruct.comp t φ) t'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (CategoryTheory.SmallObject.functorObjSrcFamily f πX) { i := i, t := t, b := b, w := w }) (CategoryTheory.SmallObject.functorMapSrc f πX πY φ hφ)) (CategoryTheory.Limits.Sigma.ι (CategoryTheory.SmallObject.functorObjSrcFamily f πY) { i := i, t := t', b := b, w := ⋯ })","decl":"@[reassoc]\nlemma ι_functorMapSrc (i : I) (t : A i ⟶ X) (b : B i ⟶ S) (w : t ≫ πX = f i ≫ b)\n    (t' : A i ⟶ Y) (fac : t ≫ φ = t') :\n    Sigma.ι _ (FunctorObjIndex.mk i t b w) ≫ functorMapSrc f πX πY φ hφ =\n      Sigma.ι (functorObjSrcFamily f πY)\n        (FunctorObjIndex.mk i t' b (by rw [← w, ← fac, assoc, hφ])) := by\n  subst fac\n  simp [functorMapSrc]\n\n"}
{"name":"CategoryTheory.SmallObject.functorMapSrc_functorObjTop_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X Y : C\nπX : Quiver.Hom X S\nπY : Quiver.Hom Y S\nφ : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πY)) C\nhφ : Eq (CategoryTheory.CategoryStruct.comp φ πY) πX\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMapSrc f πX πY φ hφ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjTop f πY) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.CategoryStruct.comp φ h))","decl":"@[reassoc (attr := simp)]\nlemma functorMapSrc_functorObjTop :\n    functorMapSrc f πX πY φ hφ ≫ functorObjTop f πY = functorObjTop f πX ≫ φ := by\n  ext ⟨i, t, b, w⟩\n  simp [ι_functorMapSrc_assoc f πX πY φ hφ i t b w _ rfl]\n\n"}
{"name":"CategoryTheory.SmallObject.functorMapSrc_functorObjTop","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X Y : C\nπX : Quiver.Hom X S\nπY : Quiver.Hom Y S\nφ : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πY)) C\nhφ : Eq (CategoryTheory.CategoryStruct.comp φ πY) πX\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMapSrc f πX πY φ hφ) (CategoryTheory.SmallObject.functorObjTop f πY)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjTop f πX) φ)","decl":"@[reassoc (attr := simp)]\nlemma functorMapSrc_functorObjTop :\n    functorMapSrc f πX πY φ hφ ≫ functorObjTop f πY = functorObjTop f πX ≫ φ := by\n  ext ⟨i, t, b, w⟩\n  simp [ι_functorMapSrc_assoc f πX πY φ hφ i t b w _ rfl]\n\n"}
{"name":"CategoryTheory.SmallObject.ι_functorMapTgt_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X Y : C\nπX : Quiver.Hom X S\nπY : Quiver.Hom Y S\nφ : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πY)) C\nhφ : Eq (CategoryTheory.CategoryStruct.comp φ πY) πX\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t πX) (CategoryTheory.CategoryStruct.comp (f i) b)\nt' : Quiver.Hom (A i) Y\nfac : Eq (CategoryTheory.CategoryStruct.comp t φ) t'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.sigmaObj (CategoryTheory.SmallObject.functorObjTgtFamily f πY)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (CategoryTheory.SmallObject.functorObjTgtFamily f πX) { i := i, t := t, b := b, w := w }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMapTgt f πX πY φ hφ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (CategoryTheory.SmallObject.functorObjTgtFamily f πY) { i := i, t := t', b := b, w := ⋯ }) h)","decl":"@[reassoc]\nlemma ι_functorMapTgt (i : I) (t : A i ⟶ X) (b : B i ⟶ S) (w : t ≫ πX = f i ≫ b)\n    (t' : A i ⟶ Y) (fac : t ≫ φ = t') :\n    Sigma.ι _ (FunctorObjIndex.mk i t b w) ≫ functorMapTgt f πX πY φ hφ =\n      Sigma.ι (functorObjTgtFamily f πY)\n        (FunctorObjIndex.mk i t' b (by rw [← w, ← fac, assoc, hφ])) := by\n  subst fac\n  simp [functorMapTgt]\n\n"}
{"name":"CategoryTheory.SmallObject.ι_functorMapTgt","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X Y : C\nπX : Quiver.Hom X S\nπY : Quiver.Hom Y S\nφ : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πY)) C\nhφ : Eq (CategoryTheory.CategoryStruct.comp φ πY) πX\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nw : Eq (CategoryTheory.CategoryStruct.comp t πX) (CategoryTheory.CategoryStruct.comp (f i) b)\nt' : Quiver.Hom (A i) Y\nfac : Eq (CategoryTheory.CategoryStruct.comp t φ) t'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι (CategoryTheory.SmallObject.functorObjTgtFamily f πX) { i := i, t := t, b := b, w := w }) (CategoryTheory.SmallObject.functorMapTgt f πX πY φ hφ)) (CategoryTheory.Limits.Sigma.ι (CategoryTheory.SmallObject.functorObjTgtFamily f πY) { i := i, t := t', b := b, w := ⋯ })","decl":"@[reassoc]\nlemma ι_functorMapTgt (i : I) (t : A i ⟶ X) (b : B i ⟶ S) (w : t ≫ πX = f i ≫ b)\n    (t' : A i ⟶ Y) (fac : t ≫ φ = t') :\n    Sigma.ι _ (FunctorObjIndex.mk i t b w) ≫ functorMapTgt f πX πY φ hφ =\n      Sigma.ι (functorObjTgtFamily f πY)\n        (FunctorObjIndex.mk i t' b (by rw [← w, ← fac, assoc, hφ])) := by\n  subst fac\n  simp [functorMapTgt]\n\n"}
{"name":"CategoryTheory.SmallObject.functorMap_comm","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X Y : C\nπX : Quiver.Hom X S\nπY : Quiver.Hom Y S\nφ : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πY)) C\nhφ : Eq (CategoryTheory.CategoryStruct.comp φ πY) πX\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorObjLeft f πX) (CategoryTheory.SmallObject.functorMapTgt f πX πY φ hφ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMapSrc f πX πY φ hφ) (CategoryTheory.SmallObject.functorObjLeft f πY))","decl":"lemma functorMap_comm :\n    functorObjLeft f πX ≫ functorMapTgt f πX πY φ hφ =\n      functorMapSrc f πX πY φ hφ ≫ functorObjLeft f πY := by\n  ext ⟨i, t, b, w⟩\n  simp only [ι_colimMap_assoc, Discrete.natTrans_app, ι_colimMap,\n    ι_functorMapTgt f πX πY φ hφ i t b w _ rfl,\n    ι_functorMapSrc_assoc f πX πY φ hφ i t b w _ rfl]\n\n"}
{"name":"CategoryTheory.SmallObject.functorMap_π_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X Y : C\nπX : Quiver.Hom X S\nπY : Quiver.Hom Y S\nφ : Quiver.Hom X Y\ninst✝³ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πY)) C\nhφ : Eq (CategoryTheory.CategoryStruct.comp φ πY) πX\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πY) (CategoryTheory.SmallObject.functorObjLeft f πY)\nZ : C\nh : Quiver.Hom S Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMap f πX πY φ hφ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.πFunctorObj f πY) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.πFunctorObj f πX) h)","decl":"@[reassoc (attr := simp)]\nlemma functorMap_π : functorMap f πX πY φ hφ ≫ πFunctorObj f πY = πFunctorObj f πX := by\n  ext ⟨i, t, b, w⟩\n  · simp [functorMap, hφ]\n  · simp [functorMap, ι_functorMapTgt_assoc f πX πY φ hφ i t b w _ rfl]\n\n"}
{"name":"CategoryTheory.SmallObject.functorMap_π","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X Y : C\nπX : Quiver.Hom X S\nπY : Quiver.Hom Y S\nφ : Quiver.Hom X Y\ninst✝³ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πY)) C\nhφ : Eq (CategoryTheory.CategoryStruct.comp φ πY) πX\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πY) (CategoryTheory.SmallObject.functorObjLeft f πY)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMap f πX πY φ hφ) (CategoryTheory.SmallObject.πFunctorObj f πY)) (CategoryTheory.SmallObject.πFunctorObj f πX)","decl":"@[reassoc (attr := simp)]\nlemma functorMap_π : functorMap f πX πY φ hφ ≫ πFunctorObj f πY = πFunctorObj f πX := by\n  ext ⟨i, t, b, w⟩\n  · simp [functorMap, hφ]\n  · simp [functorMap, ι_functorMapTgt_assoc f πX πY φ hφ i t b w _ rfl]\n\n"}
{"name":"CategoryTheory.SmallObject.functorMap_id","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\n⊢ Eq (CategoryTheory.SmallObject.functorMap f πX πX (CategoryTheory.CategoryStruct.id X) ⋯) (CategoryTheory.CategoryStruct.id (CategoryTheory.SmallObject.functorObj f πX))","decl":"variable (X) in\n@[simp]\nlemma functorMap_id : functorMap f πX πX (𝟙 X) (by simp) = 𝟙 _ := by\n  ext ⟨i, t, b, w⟩\n  · simp [functorMap]\n  · simp [functorMap, ι_functorMapTgt_assoc f πX πX (𝟙 X) (by simp) i t b w t (by simp)]\n\n"}
{"name":"CategoryTheory.SmallObject.ιFunctorObj_naturality","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X Y : C\nπX : Quiver.Hom X S\nπY : Quiver.Hom Y S\nφ : Quiver.Hom X Y\ninst✝³ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πY)) C\nhφ : Eq (CategoryTheory.CategoryStruct.comp φ πY) πX\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πY) (CategoryTheory.SmallObject.functorObjLeft f πY)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ιFunctorObj f πX) (CategoryTheory.SmallObject.functorMap f πX πY φ hφ)) (CategoryTheory.CategoryStruct.comp φ (CategoryTheory.SmallObject.ιFunctorObj f πY))","decl":"@[reassoc (attr := simp)]\nlemma ιFunctorObj_naturality :\n    ιFunctorObj f πX ≫ functorMap f πX πY φ hφ = φ ≫ ιFunctorObj f πY := by\n  simp [ιFunctorObj, functorMap]\n\n"}
{"name":"CategoryTheory.SmallObject.ιFunctorObj_naturality_assoc","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X Y : C\nπX : Quiver.Hom X S\nπY : Quiver.Hom Y S\nφ : Quiver.Hom X Y\ninst✝³ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πY)) C\nhφ : Eq (CategoryTheory.CategoryStruct.comp φ πY) πX\ninst✝¹ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πY) (CategoryTheory.SmallObject.functorObjLeft f πY)\nZ : C\nh : Quiver.Hom (CategoryTheory.SmallObject.functorObj f πY) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ιFunctorObj f πX) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.functorMap f πX πY φ hφ) h)) (CategoryTheory.CategoryStruct.comp φ (CategoryTheory.CategoryStruct.comp (CategoryTheory.SmallObject.ιFunctorObj f πY) h))","decl":"@[reassoc (attr := simp)]\nlemma ιFunctorObj_naturality :\n    ιFunctorObj f πX ≫ functorMap f πX πY φ hφ = φ ≫ ιFunctorObj f πY := by\n  simp [ιFunctorObj, functorMap]\n\n"}
{"name":"CategoryTheory.SmallObject.ιFunctorObj_extension","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS X : C\nπX : Quiver.Hom X S\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.SmallObject.functorObjTop f πX) (CategoryTheory.SmallObject.functorObjLeft f πX)\ni : I\nt : Quiver.Hom (A i) X\nb : Quiver.Hom (B i) S\nsq : CategoryTheory.CommSq t (f i) πX b\n⊢ Exists fun l => And (Eq (CategoryTheory.CategoryStruct.comp (f i) l) (CategoryTheory.CategoryStruct.comp t (CategoryTheory.SmallObject.ιFunctorObj f πX))) (Eq (CategoryTheory.CategoryStruct.comp l (CategoryTheory.SmallObject.πFunctorObj f πX)) b)","decl":"lemma ιFunctorObj_extension {i : I} (t : A i ⟶ X) (b : B i ⟶ S)\n    (sq : CommSq t (f i) πX b) :\n    ∃ (l : B i ⟶ functorObj f πX), f i ≫ l = t ≫ ιFunctorObj f πX ∧\n      l ≫ πFunctorObj f πX = b :=\n  ⟨Sigma.ι (functorObjTgtFamily f πX) (FunctorObjIndex.mk i t b sq.w) ≫\n    ρFunctorObj f πX, (FunctorObjIndex.mk i t b _).comm, by simp⟩\n\n"}
{"name":"CategoryTheory.SmallObject.functor_map","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS : C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\ninst✝ : ∀ {X : C} (πX : Quiver.Hom X S), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\nπ₁ π₂ : CategoryTheory.Over S\nφ : Quiver.Hom π₁ π₂\n⊢ Eq ((CategoryTheory.SmallObject.functor f S).map φ) (CategoryTheory.Over.homMk (CategoryTheory.SmallObject.functorMap f π₁.hom π₂.hom φ.left ⋯) ⋯)","decl":"/-- The functor `Over S ⥤ Over S` that is constructed in order to apply the small\nobject argument to a family of morphisms `f i : A i ⟶ B i`, see the introduction\nof the file `Mathlib.CategoryTheory.SmallObject.Construction` -/\n@[simps! obj map]\nnoncomputable def functor : Over S ⥤ Over S where\n  obj π := Over.mk (πFunctorObj f π.hom)\n  map {π₁ π₂} φ := Over.homMk (functorMap f π₁.hom π₂.hom φ.left (Over.w φ))\n  map_id _ := by ext; dsimp; simp\n  map_comp {π₁ π₂ π₃} φ φ' := by\n    ext1\n    dsimp\n    ext ⟨i, t, b, w⟩\n    · simp\n    · simp [functorMap, ι_functorMapTgt_assoc f π₁.hom π₂.hom φ.left (Over.w φ) i t b w _ rfl,\n        ι_functorMapTgt_assoc f π₁.hom π₃.hom (φ.left ≫ φ'.left) (Over.w (φ ≫ φ')) i t b w _ rfl,\n        ι_functorMapTgt_assoc f π₂.hom π₃.hom (φ'.left) (Over.w φ') i (t ≫ φ.left) b\n          (by simp [w]) (t ≫ φ.left ≫ φ'.left) (by simp)]\n\n"}
{"name":"CategoryTheory.SmallObject.functor_obj","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS : C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\ninst✝ : ∀ {X : C} (πX : Quiver.Hom X S), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\nπ : CategoryTheory.Over S\n⊢ Eq ((CategoryTheory.SmallObject.functor f S).obj π) (CategoryTheory.Over.mk (CategoryTheory.SmallObject.πFunctorObj f π.hom))","decl":"/-- The functor `Over S ⥤ Over S` that is constructed in order to apply the small\nobject argument to a family of morphisms `f i : A i ⟶ B i`, see the introduction\nof the file `Mathlib.CategoryTheory.SmallObject.Construction` -/\n@[simps! obj map]\nnoncomputable def functor : Over S ⥤ Over S where\n  obj π := Over.mk (πFunctorObj f π.hom)\n  map {π₁ π₂} φ := Over.homMk (functorMap f π₁.hom π₂.hom φ.left (Over.w φ))\n  map_id _ := by ext; dsimp; simp\n  map_comp {π₁ π₂ π₃} φ φ' := by\n    ext1\n    dsimp\n    ext ⟨i, t, b, w⟩\n    · simp\n    · simp [functorMap, ι_functorMapTgt_assoc f π₁.hom π₂.hom φ.left (Over.w φ) i t b w _ rfl,\n        ι_functorMapTgt_assoc f π₁.hom π₃.hom (φ.left ≫ φ'.left) (Over.w (φ ≫ φ')) i t b w _ rfl,\n        ι_functorMapTgt_assoc f π₂.hom π₃.hom (φ'.left) (Over.w φ') i (t ≫ φ.left) b\n          (by simp [w]) (t ≫ φ.left ≫ φ'.left) (by simp)]\n\n"}
{"name":"CategoryTheory.SmallObject.ε_app","module":"Mathlib.CategoryTheory.SmallObject.Construction","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type w\nA B : I → C\nf : (i : I) → Quiver.Hom (A i) (B i)\nS : C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\ninst✝ : ∀ {X : C} (πX : Quiver.Hom X S), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (CategoryTheory.SmallObject.FunctorObjIndex f πX)) C\nw : CategoryTheory.Over S\n⊢ Eq ((CategoryTheory.SmallObject.ε f S).app w) (CategoryTheory.Over.homMk (CategoryTheory.SmallObject.ιFunctorObj f w.hom) ⋯)","decl":"/-- The canonical natural transformation `𝟭 (Over S) ⟶ functor f S`. -/\n@[simps! app]\nnoncomputable def ε : 𝟭 (Over S) ⟶ functor f S where\n  app w := Over.homMk (ιFunctorObj f w.hom)\n\n"}
