{"name":"ProbabilityTheory.Kernel.withDensity_of_not_measurable","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β → ENNReal\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nhf : Not (Measurable (Function.uncurry f))\n⊢ Eq (κ.withDensity f) 0","decl":"theorem withDensity_of_not_measurable (κ : Kernel α β) [IsSFiniteKernel κ]\n    (hf : ¬Measurable (Function.uncurry f)) : withDensity κ f = 0 := by classical exact dif_neg hf\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_apply","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β → ENNReal\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nhf : Measurable (Function.uncurry f)\na : α\n⊢ Eq ((κ.withDensity f) a) ((κ a).withDensity (f a))","decl":"protected theorem withDensity_apply (κ : Kernel α β) [IsSFiniteKernel κ]\n    (hf : Measurable (Function.uncurry f)) (a : α) :\n    withDensity κ f a = (κ a).withDensity (f a) := by\n  classical\n  rw [withDensity, dif_pos hf]\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_apply'","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β → ENNReal\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nhf : Measurable (Function.uncurry f)\na : α\ns : Set β\n⊢ Eq (((κ.withDensity f) a) s) (MeasureTheory.lintegral ((κ a).restrict s) fun b => f a b)","decl":"protected theorem withDensity_apply' (κ : Kernel α β) [IsSFiniteKernel κ]\n    (hf : Measurable (Function.uncurry f)) (a : α) (s : Set β) :\n    withDensity κ f a s = ∫⁻ b in s, f a b ∂κ a := by\n  rw [Kernel.withDensity_apply κ hf, withDensity_apply' _ s]\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_congr_ae","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf g : α → β → ENNReal\nhf : Measurable (Function.uncurry f)\nhg : Measurable (Function.uncurry g)\nhfg : ∀ (a : α), (MeasureTheory.ae (κ a)).EventuallyEq (f a) (g a)\n⊢ Eq (κ.withDensity f) (κ.withDensity g)","decl":"nonrec lemma withDensity_congr_ae (κ : Kernel α β) [IsSFiniteKernel κ] {f g : α → β → ℝ≥0∞}\n    (hf : Measurable (Function.uncurry f)) (hg : Measurable (Function.uncurry g))\n    (hfg : ∀ a, f a =ᵐ[κ a] g a) :\n    withDensity κ f = withDensity κ g := by\n  ext a\n  rw [Kernel.withDensity_apply _ hf,Kernel.withDensity_apply _ hg, withDensity_congr_ae (hfg a)]\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_absolutelyContinuous","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : α → β → ENNReal\na : α\n⊢ ((κ.withDensity f) a).AbsolutelyContinuous (κ a)","decl":"nonrec lemma withDensity_absolutelyContinuous [IsSFiniteKernel κ]\n    (f : α → β → ℝ≥0∞) (a : α) :\n    Kernel.withDensity κ f a ≪ κ a := by\n  by_cases hf : Measurable (Function.uncurry f)\n  · rw [Kernel.withDensity_apply _ hf]\n    exact withDensity_absolutelyContinuous _ _\n  · rw [withDensity_of_not_measurable _ hf]\n    simp [Measure.AbsolutelyContinuous.zero]\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_one","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ Eq (κ.withDensity 1) κ","decl":"@[simp]\nlemma withDensity_one (κ : Kernel α β) [IsSFiniteKernel κ] :\n    Kernel.withDensity κ 1 = κ := by\n  ext; rw [Kernel.withDensity_apply _ measurable_const]; simp\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_one'","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ Eq (κ.withDensity fun x x => 1) κ","decl":"@[simp]\nlemma withDensity_one' (κ : Kernel α β) [IsSFiniteKernel κ] :\n    Kernel.withDensity κ (fun _ _ ↦ 1) = κ := Kernel.withDensity_one _\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_zero","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ Eq (κ.withDensity 0) 0","decl":"@[simp]\nlemma withDensity_zero (κ : Kernel α β) [IsSFiniteKernel κ] :\n    Kernel.withDensity κ 0 = 0 := by\n  ext; rw [Kernel.withDensity_apply _ measurable_const]; simp\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_zero'","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ Eq (κ.withDensity fun x x => 0) 0","decl":"@[simp]\nlemma withDensity_zero' (κ : Kernel α β) [IsSFiniteKernel κ] :\n    Kernel.withDensity κ (fun _ _ ↦ 0) = 0 := Kernel.withDensity_zero _\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_withDensity","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β → ENNReal\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nhf : Measurable (Function.uncurry f)\na : α\ng : β → ENNReal\nhg : Measurable g\n⊢ Eq (MeasureTheory.lintegral ((κ.withDensity f) a) fun b => g b) (MeasureTheory.lintegral (κ a) fun b => HMul.hMul (f a b) (g b))","decl":"theorem lintegral_withDensity (κ : Kernel α β) [IsSFiniteKernel κ]\n    (hf : Measurable (Function.uncurry f)) (a : α) {g : β → ℝ≥0∞} (hg : Measurable g) :\n    ∫⁻ b, g b ∂withDensity κ f a = ∫⁻ b, f a b * g b ∂κ a := by\n  rw [Kernel.withDensity_apply _ hf,\n    lintegral_withDensity_eq_lintegral_mul _ (Measurable.of_uncurry_left hf) hg]\n  simp_rw [Pi.mul_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.integral_withDensity","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : β → E\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\na : α\ng : α → β → NNReal\nhg : Measurable (Function.uncurry g)\n⊢ Eq (MeasureTheory.integral ((κ.withDensity fun a b => ↑(g a b)) a) fun b => f b) (MeasureTheory.integral (κ a) fun b => HSMul.hSMul (g a b) (f b))","decl":"theorem integral_withDensity {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    {f : β → E} [IsSFiniteKernel κ] {a : α} {g : α → β → ℝ≥0}\n    (hg : Measurable (Function.uncurry g)) :\n    ∫ b, f b ∂withDensity κ (fun a b => g a b) a = ∫ b, g a b • f b ∂κ a := by\n  rw [Kernel.withDensity_apply, integral_withDensity_eq_integral_smul]\n  · exact Measurable.of_uncurry_left hg\n  · exact measurable_coe_nnreal_ennreal.comp hg\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_add_left","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nf : α → β → ENNReal\n⊢ Eq ((HAdd.hAdd κ η).withDensity f) (HAdd.hAdd (κ.withDensity f) (η.withDensity f))","decl":"theorem withDensity_add_left (κ η : Kernel α β) [IsSFiniteKernel κ] [IsSFiniteKernel η]\n    (f : α → β → ℝ≥0∞) : withDensity (κ + η) f = withDensity κ f + withDensity η f := by\n  by_cases hf : Measurable (Function.uncurry f)\n  · ext a s\n    simp only [Kernel.withDensity_apply _ hf, coe_add, Pi.add_apply, withDensity_add_measure,\n      Measure.add_apply]\n  · simp_rw [withDensity_of_not_measurable _ hf]\n    rw [zero_add]\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_kernel_sum","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Countable ι\nκ : ι → ProbabilityTheory.Kernel α β\nhκ : ∀ (i : ι), ProbabilityTheory.IsSFiniteKernel (κ i)\nf : α → β → ENNReal\n⊢ Eq ((ProbabilityTheory.Kernel.sum κ).withDensity f) (ProbabilityTheory.Kernel.sum fun i => (κ i).withDensity f)","decl":"theorem withDensity_kernel_sum [Countable ι] (κ : ι → Kernel α β) (hκ : ∀ i, IsSFiniteKernel (κ i))\n    (f : α → β → ℝ≥0∞) :\n    @withDensity _ _ _ _ (Kernel.sum κ) (isSFiniteKernel_sum hκ) f =\n      Kernel.sum fun i => withDensity (κ i) f := by\n  by_cases hf : Measurable (Function.uncurry f)\n  · ext1 a\n    simp_rw [sum_apply, Kernel.withDensity_apply _ hf, sum_apply,\n      withDensity_sum (fun n => κ n a) (f a)]\n  · simp_rw [withDensity_of_not_measurable _ hf]\n    exact sum_zero.symm\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_add_right","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf g : α → β → ENNReal\nhf : Measurable (Function.uncurry f)\nhg : Measurable (Function.uncurry g)\n⊢ Eq (κ.withDensity (HAdd.hAdd f g)) (HAdd.hAdd (κ.withDensity f) (κ.withDensity g))","decl":"lemma withDensity_add_right [IsSFiniteKernel κ] {f g : α → β → ℝ≥0∞}\n    (hf : Measurable (Function.uncurry f)) (hg : Measurable (Function.uncurry g)) :\n    withDensity κ (f + g) = withDensity κ f + withDensity κ g := by\n  ext a\n  rw [coe_add, Pi.add_apply, Kernel.withDensity_apply _ hf, Kernel.withDensity_apply _ hg,\n    Kernel.withDensity_apply, Pi.add_apply, MeasureTheory.withDensity_add_right]\n  · exact hg.comp measurable_prod_mk_left\n  · exact hf.add hg\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_sub_add_cancel","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf g : α → β → ENNReal\nhf : Measurable (Function.uncurry f)\nhg : Measurable (Function.uncurry g)\nhfg : ∀ (a : α), (MeasureTheory.ae (κ a)).EventuallyLE (g a) (f a)\n⊢ Eq (HAdd.hAdd (κ.withDensity fun a x => HSub.hSub (f a x) (g a x)) (κ.withDensity g)) (κ.withDensity f)","decl":"lemma withDensity_sub_add_cancel [IsSFiniteKernel κ] {f g : α → β → ℝ≥0∞}\n    (hf : Measurable (Function.uncurry f)) (hg : Measurable (Function.uncurry g))\n    (hfg : ∀ a, g a ≤ᵐ[κ a] f a) :\n    withDensity κ (fun a x ↦ f a x - g a x) + withDensity κ g = withDensity κ f := by\n  rw [← withDensity_add_right _ hg]\n  swap; · exact hf.sub hg\n  refine withDensity_congr_ae κ ((hf.sub hg).add hg) hf (fun a ↦ ?_)\n  filter_upwards [hfg a] with x hx\n  rwa [Pi.add_apply, Pi.add_apply, tsub_add_cancel_iff_le]\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_tsum","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝¹ : Countable ι\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : ι → α → β → ENNReal\nhf : ∀ (i : ι), Measurable (Function.uncurry (f i))\n⊢ Eq (κ.withDensity (tsum fun n => f n)) (ProbabilityTheory.Kernel.sum fun n => κ.withDensity (f n))","decl":"theorem withDensity_tsum [Countable ι] (κ : Kernel α β) [IsSFiniteKernel κ] {f : ι → α → β → ℝ≥0∞}\n    (hf : ∀ i, Measurable (Function.uncurry (f i))) :\n    withDensity κ (∑' n, f n) = Kernel.sum fun n => withDensity κ (f n) := by\n  have h_sum_a : ∀ a, Summable fun n => f n a := fun a => Pi.summable.mpr fun b => ENNReal.summable\n  have h_sum : Summable fun n => f n := Pi.summable.mpr h_sum_a\n  ext a s hs\n  rw [sum_apply' _ a hs, Kernel.withDensity_apply' κ _ a s]\n  swap\n  · have : Function.uncurry (∑' n, f n) = ∑' n, Function.uncurry (f n) := by\n      ext1 p\n      simp only [Function.uncurry_def]\n      rw [tsum_apply h_sum, tsum_apply (h_sum_a _), tsum_apply]\n      exact Pi.summable.mpr fun p => ENNReal.summable\n    rw [this]\n    exact Measurable.ennreal_tsum' hf\n  have : ∫⁻ b in s, (∑' n, f n) a b ∂κ a = ∫⁻ b in s, ∑' n, (fun b => f n a b) b ∂κ a := by\n    congr with b\n    rw [tsum_apply h_sum, tsum_apply (h_sum_a a)]\n  rw [this, lintegral_tsum fun n => (Measurable.of_uncurry_left (hf n)).aemeasurable]\n  congr with n\n  rw [Kernel.withDensity_apply' _ (hf n) a s]\n\n"}
{"name":"ProbabilityTheory.Kernel.isFiniteKernel_withDensity_of_bounded","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β → ENNReal\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nB : ENNReal\nhB_top : Ne B Top.top\nhf_B : ∀ (a : α) (b : β), LE.le (f a b) B\n⊢ ProbabilityTheory.IsFiniteKernel (κ.withDensity f)","decl":"/-- If a kernel `κ` is finite and a function `f : α → β → ℝ≥0∞` is bounded, then `withDensity κ f`\nis finite. -/\ntheorem isFiniteKernel_withDensity_of_bounded (κ : Kernel α β) [IsFiniteKernel κ] {B : ℝ≥0∞}\n    (hB_top : B ≠ ∞) (hf_B : ∀ a b, f a b ≤ B) : IsFiniteKernel (withDensity κ f) := by\n  by_cases hf : Measurable (Function.uncurry f)\n  · exact ⟨⟨B * IsFiniteKernel.bound κ, ENNReal.mul_lt_top hB_top.lt_top\n      (IsFiniteKernel.bound_lt_top κ), fun a => by\n        rw [Kernel.withDensity_apply' κ hf a Set.univ]\n        calc\n          ∫⁻ b in Set.univ, f a b ∂κ a ≤ ∫⁻ _ in Set.univ, B ∂κ a := lintegral_mono (hf_B a)\n          _ = B * κ a Set.univ := by\n            simp only [Measure.restrict_univ, MeasureTheory.lintegral_const]\n          _ ≤ B * IsFiniteKernel.bound κ := mul_le_mul_left' (measure_le_bound κ a Set.univ) _⟩⟩\n  · rw [withDensity_of_not_measurable _ hf]\n    infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.isSFiniteKernel_withDensity_of_isFiniteKernel","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β → ENNReal\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nhf_ne_top : ∀ (a : α) (b : β), Ne (f a b) Top.top\n⊢ ProbabilityTheory.IsSFiniteKernel (κ.withDensity f)","decl":"/-- Auxiliary lemma for `IsSFiniteKernel.withDensity`.\nIf a kernel `κ` is finite, then `withDensity κ f` is s-finite. -/\ntheorem isSFiniteKernel_withDensity_of_isFiniteKernel (κ : Kernel α β) [IsFiniteKernel κ]\n    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) := by\n  -- We already have that for `f` bounded from above and a `κ` a finite kernel,\n  -- `withDensity κ f` is finite. We write any function as a countable sum of bounded\n  -- functions, and decompose an s-finite kernel as a sum of finite kernels. We then use that\n  -- `withDensity` commutes with sums for both arguments and get a sum of finite kernels.\n  by_cases hf : Measurable (Function.uncurry f)\n  swap; · rw [withDensity_of_not_measurable _ hf]; infer_instance\n  let fs : ℕ → α → β → ℝ≥0∞ := fun n a b => min (f a b) (n + 1) - min (f a b) n\n  have h_le : ∀ a b n, ⌈(f a b).toReal⌉₊ ≤ n → f a b ≤ n := by\n    intro a b n hn\n    have : (f a b).toReal ≤ n := Nat.le_of_ceil_le hn\n    rw [← ENNReal.le_ofReal_iff_toReal_le (hf_ne_top a b) _] at this\n    · refine this.trans (le_of_eq ?_)\n      rw [ENNReal.ofReal_natCast]\n    · norm_cast\n      exact zero_le _\n  have h_zero : ∀ a b n, ⌈(f a b).toReal⌉₊ ≤ n → fs n a b = 0 := by\n    intro a b n hn\n    suffices min (f a b) (n + 1) = f a b ∧ min (f a b) n = f a b by\n      simp_rw [fs, this.1, this.2, tsub_self (f a b)]\n    exact ⟨min_eq_left ((h_le a b n hn).trans (le_add_of_nonneg_right zero_le_one)),\n      min_eq_left (h_le a b n hn)⟩\n  have hf_eq_tsum : f = ∑' n, fs n := by\n    have h_sum_a : ∀ a, Summable fun n => fs n a := by\n      refine fun a => Pi.summable.mpr fun b => ?_\n      suffices ∀ n, n ∉ Finset.range ⌈(f a b).toReal⌉₊ → fs n a b = 0 from\n        summable_of_ne_finset_zero this\n      intro n hn_not_mem\n      rw [Finset.mem_range, not_lt] at hn_not_mem\n      exact h_zero a b n hn_not_mem\n    ext a b : 2\n    rw [tsum_apply (Pi.summable.mpr h_sum_a), tsum_apply (h_sum_a a),\n      ENNReal.tsum_eq_liminf_sum_nat]\n    have h_finset_sum : ∀ n, ∑ i ∈ Finset.range n, fs i a b = min (f a b) n := by\n      intro n\n      induction' n with n hn\n      · simp\n      rw [Finset.sum_range_succ, hn]\n      simp [fs]\n    simp_rw [h_finset_sum]\n    refine (Filter.Tendsto.liminf_eq ?_).symm\n    refine Filter.Tendsto.congr' ?_ tendsto_const_nhds\n    rw [Filter.EventuallyEq, Filter.eventually_atTop]\n    exact ⟨⌈(f a b).toReal⌉₊, fun n hn => (min_eq_left (h_le a b n hn)).symm⟩\n  rw [hf_eq_tsum, withDensity_tsum _ fun n : ℕ => _]\n  swap; · exact fun _ => (hf.min measurable_const).sub (hf.min measurable_const)\n  refine isSFiniteKernel_sum fun n => ?_\n  suffices IsFiniteKernel (withDensity κ (fs n)) by haveI := this; infer_instance\n  refine isFiniteKernel_withDensity_of_bounded _ (ENNReal.coe_ne_top : ↑n + 1 ≠ ∞) fun a b => ?_\n  -- After https://github.com/leanprover/lean4/pull/2734, we need to do beta reduction before `norm_cast`\n  beta_reduce\n  norm_cast\n  calc\n    fs n a b ≤ min (f a b) (n + 1) := tsub_le_self\n    _ ≤ n + 1 := min_le_right _ _\n    _ = ↑(n + 1) := by norm_cast\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.withDensity","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β → ENNReal\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nhf_ne_top : ∀ (a : α) (b : β), Ne (f a b) Top.top\n⊢ ProbabilityTheory.IsSFiniteKernel (κ.withDensity f)","decl":"/-- For an s-finite kernel `κ` and a function `f : α → β → ℝ≥0∞` which is everywhere finite,\n`withDensity κ f` is s-finite. -/\nnonrec theorem IsSFiniteKernel.withDensity (κ : Kernel α β) [IsSFiniteKernel κ]\n    (hf_ne_top : ∀ a b, f a b ≠ ∞) : IsSFiniteKernel (withDensity κ f) := by\n  have h_eq_sum : withDensity κ f = Kernel.sum fun i => withDensity (seq κ i) f := by\n    rw [← withDensity_kernel_sum _ _]\n    congr\n    exact (kernel_sum_seq κ).symm\n  rw [h_eq_sum]\n  exact isSFiniteKernel_sum fun n =>\n    isSFiniteKernel_withDensity_of_isFiniteKernel (seq κ n) hf_ne_top\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsSFiniteKernelWithDensityOfNNReal","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : α → β → NNReal\n⊢ ProbabilityTheory.IsSFiniteKernel (κ.withDensity fun a b => ↑(f a b))","decl":"/-- For an s-finite kernel `κ` and a function `f : α → β → ℝ≥0`, `withDensity κ f` is s-finite. -/\ninstance (κ : Kernel α β) [IsSFiniteKernel κ] (f : α → β → ℝ≥0) :\n    IsSFiniteKernel (withDensity κ fun a b => f a b) :=\n  IsSFiniteKernel.withDensity κ fun _ _ => ENNReal.coe_ne_top\n\n"}
{"name":"ProbabilityTheory.Kernel.withDensity_mul","module":"Mathlib.Probability.Kernel.WithDensity","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : α → β → NNReal\ng : α → β → ENNReal\nhf : Measurable (Function.uncurry f)\nhg : Measurable (Function.uncurry g)\n⊢ Eq (κ.withDensity fun a x => HMul.hMul (↑(f a x)) (g a x)) ((κ.withDensity fun a x => ↑(f a x)).withDensity g)","decl":"nonrec lemma withDensity_mul [IsSFiniteKernel κ] {f : α → β → ℝ≥0} {g : α → β → ℝ≥0∞}\n    (hf : Measurable (Function.uncurry f)) (hg : Measurable (Function.uncurry g)) :\n    withDensity κ (fun a x ↦ f a x * g a x)\n      = withDensity (withDensity κ fun a x ↦ f a x) g := by\n  ext a : 1\n  rw [Kernel.withDensity_apply]\n  swap; · exact (measurable_coe_nnreal_ennreal.comp hf).mul hg\n  change (Measure.withDensity (κ a) ((fun x ↦ (f a x : ℝ≥0∞)) * (fun x ↦ (g a x : ℝ≥0∞)))) =\n      (withDensity (withDensity κ fun a x ↦ f a x) g) a\n  rw [withDensity_mul]\n  · rw [Kernel.withDensity_apply _ hg, Kernel.withDensity_apply]\n    exact measurable_coe_nnreal_ennreal.comp hf\n  · rw [measurable_coe_nnreal_ennreal_iff]\n    exact hf.comp measurable_prod_mk_left\n  · exact hg.comp measurable_prod_mk_left\n\n"}
