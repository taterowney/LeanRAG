{"name":"lebesgue_number_lemma","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"α : Type ua\ninst✝ : UniformSpace α\nK : Set α\nι : Sort u_2\nU : ι → Set α\nhK : IsCompact K\nhopen : ∀ (i : ι), IsOpen (U i)\nhcover : HasSubset.Subset K (Set.iUnion fun i => U i)\n⊢ Exists fun V => And (Membership.mem (uniformity α) V) (∀ (x : α), Membership.mem K x → Exists fun i => HasSubset.Subset (UniformSpace.ball x V) (U i))","decl":"/-- Let `c : ι → Set α` be an open cover of a compact set `s`. Then there exists an entourage\n`n` such that for each `x ∈ s` its `n`-neighborhood is contained in some `c i`. -/\ntheorem lebesgue_number_lemma {ι : Sort*} {U : ι → Set α} (hK : IsCompact K)\n    (hopen : ∀ i, IsOpen (U i)) (hcover : K ⊆ ⋃ i, U i) :\n    ∃ V ∈ 𝓤 α, ∀ x ∈ K, ∃ i, ball x V ⊆ U i := by\n  have : ∀ x ∈ K, ∃ i, ∃ V ∈ 𝓤 α, ball x (V ○ V) ⊆ U i := fun x hx ↦ by\n    obtain ⟨i, hi⟩ := mem_iUnion.1 (hcover hx)\n    rw [← (hopen i).mem_nhds_iff, nhds_eq_comap_uniformity, ← lift'_comp_uniformity] at hi\n    exact ⟨i, (((basis_sets _).lift' <| monotone_id.compRel monotone_id).comap _).mem_iff.1 hi⟩\n  choose ind W hW hWU using this\n  rcases hK.elim_nhds_subcover' (fun x hx ↦ ball x (W x hx)) (fun x hx ↦ ball_mem_nhds _ (hW x hx))\n    with ⟨t, ht⟩\n  refine ⟨⋂ x ∈ t, W x x.2, (biInter_finset_mem _).2 fun x _ ↦ hW x x.2, fun x hx ↦ ?_⟩\n  rcases mem_iUnion₂.1 (ht hx) with ⟨y, hyt, hxy⟩\n  exact ⟨ind y y.2, fun z hz ↦ hWU _ _ ⟨x, hxy, mem_iInter₂.1 hz _ hyt⟩⟩\n\n"}
{"name":"Filter.HasBasis.lebesgue_number_lemma","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"α : Type ua\ninst✝ : UniformSpace α\nK : Set α\nι' : Sort u_2\nι : Sort u_3\np : ι' → Prop\nV : ι' → Set (Prod α α)\nU : ι → Set α\nhbasis : (uniformity α).HasBasis p V\nhK : IsCompact K\nhopen : ∀ (j : ι), IsOpen (U j)\nhcover : HasSubset.Subset K (Set.iUnion fun j => U j)\n⊢ Exists fun i => And (p i) (∀ (x : α), Membership.mem K x → Exists fun j => HasSubset.Subset (UniformSpace.ball x (V i)) (U j))","decl":"/-- Let `U : ι → Set α` be an open cover of a compact set `K`.\nThen there exists an entourage `V`\nsuch that for each `x ∈ K` its `V`-neighborhood is included in some `U i`.\n\nMoreover, one can choose an entourage from a given basis. -/\nprotected theorem Filter.HasBasis.lebesgue_number_lemma {ι' ι : Sort*} {p : ι' → Prop}\n    {V : ι' → Set (α × α)} {U : ι → Set α} (hbasis : (𝓤 α).HasBasis p V) (hK : IsCompact K)\n    (hopen : ∀ j, IsOpen (U j)) (hcover : K ⊆ ⋃ j, U j) :\n    ∃ i, p i ∧ ∀ x ∈ K, ∃ j, ball x (V i) ⊆ U j := by\n  refine (hbasis.exists_iff ?_).1 (lebesgue_number_lemma hK hopen hcover)\n  exact fun s t hst ht x hx ↦ (ht x hx).imp fun i hi ↦ Subset.trans (ball_mono hst _) hi\n\n"}
{"name":"lebesgue_number_lemma_sUnion","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"α : Type ua\ninst✝ : UniformSpace α\nK : Set α\nS : Set (Set α)\nhK : IsCompact K\nhopen : ∀ (s : Set α), Membership.mem S s → IsOpen s\nhcover : HasSubset.Subset K S.sUnion\n⊢ Exists fun V => And (Membership.mem (uniformity α) V) (∀ (x : α), Membership.mem K x → Exists fun s => And (Membership.mem S s) (HasSubset.Subset (UniformSpace.ball x V) s))","decl":"/-- Let `c : Set (Set α)` be an open cover of a compact set `s`. Then there exists an entourage\n`n` such that for each `x ∈ s` its `n`-neighborhood is contained in some `t ∈ c`. -/\ntheorem lebesgue_number_lemma_sUnion {S : Set (Set α)}\n    (hK : IsCompact K) (hopen : ∀ s ∈ S, IsOpen s) (hcover : K ⊆ ⋃₀ S) :\n    ∃ V ∈ 𝓤 α, ∀ x ∈ K, ∃ s ∈ S, ball x V ⊆ s := by\n  rw [sUnion_eq_iUnion] at hcover\n  simpa using lebesgue_number_lemma hK (by simpa) hcover\n\n"}
{"name":"IsCompact.nhdsSet_basis_uniformity","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"α : Type ua\nι : Sort u_1\ninst✝ : UniformSpace α\nK : Set α\np : ι → Prop\nV : ι → Set (Prod α α)\nhbasis : (uniformity α).HasBasis p V\nhK : IsCompact K\n⊢ (nhdsSet K).HasBasis p fun i => Set.iUnion fun x => Set.iUnion fun h => UniformSpace.ball x (V i)","decl":"/-- If `K` is a compact set in a uniform space and `{V i | p i}` is a basis of entourages,\nthen `{⋃ x ∈ K, UniformSpace.ball x (V i) | p i}` is a basis of `𝓝ˢ K`.\n\nHere \"`{s i | p i}` is a basis of a filter `l`\" means `Filter.HasBasis l p s`. -/\ntheorem IsCompact.nhdsSet_basis_uniformity {p : ι → Prop} {V : ι → Set (α × α)}\n    (hbasis : (𝓤 α).HasBasis p V) (hK : IsCompact K) :\n    (𝓝ˢ K).HasBasis p fun i => ⋃ x ∈ K, ball x (V i) where\n  mem_iff' U := by\n    constructor\n    · intro H\n      have HKU : K ⊆ ⋃ _ : Unit, interior U := by\n        simpa only [iUnion_const, subset_interior_iff_mem_nhdsSet] using H\n      obtain ⟨i, hpi, hi⟩ : ∃ i, p i ∧ ⋃ x ∈ K, ball x (V i) ⊆ interior U := by\n        simpa using hbasis.lebesgue_number_lemma hK (fun _ ↦ isOpen_interior) HKU\n      exact ⟨i, hpi, hi.trans interior_subset⟩\n    · rintro ⟨i, hpi, hi⟩\n      refine mem_of_superset (bUnion_mem_nhdsSet fun x _ ↦ ?_) hi\n      exact ball_mem_nhds _ <| hbasis.mem_of_mem hpi\n\n-- TODO: move to a separate file, golf using the regularity of a uniform space.\n"}
{"name":"Disjoint.exists_uniform_thickening","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"α : Type ua\ninst✝ : UniformSpace α\nA B : Set α\nhA : IsCompact A\nhB : IsClosed B\nh : Disjoint A B\n⊢ Exists fun V => And (Membership.mem (uniformity α) V) (Disjoint (Set.iUnion fun x => Set.iUnion fun h => UniformSpace.ball x V) (Set.iUnion fun x => Set.iUnion fun h => UniformSpace.ball x V))","decl":"theorem Disjoint.exists_uniform_thickening {A B : Set α} (hA : IsCompact A) (hB : IsClosed B)\n    (h : Disjoint A B) : ∃ V ∈ 𝓤 α, Disjoint (⋃ x ∈ A, ball x V) (⋃ x ∈ B, ball x V) := by\n  have : Bᶜ ∈ 𝓝ˢ A := hB.isOpen_compl.mem_nhdsSet.mpr h.le_compl_right\n  rw [(hA.nhdsSet_basis_uniformity (Filter.basis_sets _)).mem_iff] at this\n  rcases this with ⟨U, hU, hUAB⟩\n  rcases comp_symm_mem_uniformity_sets hU with ⟨V, hV, hVsymm, hVU⟩\n  refine ⟨V, hV, Set.disjoint_left.mpr fun x => ?_⟩\n  simp only [mem_iUnion₂]\n  rintro ⟨a, ha, hxa⟩ ⟨b, hb, hxb⟩\n  rw [mem_ball_symmetry hVsymm] at hxa hxb\n  exact hUAB (mem_iUnion₂_of_mem ha <| hVU <| mem_comp_of_mem_ball hVsymm hxa hxb) hb\n\n"}
{"name":"Disjoint.exists_uniform_thickening_of_basis","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"α : Type ua\nι : Sort u_1\ninst✝ : UniformSpace α\np : ι → Prop\ns : ι → Set (Prod α α)\nhU : (uniformity α).HasBasis p s\nA B : Set α\nhA : IsCompact A\nhB : IsClosed B\nh : Disjoint A B\n⊢ Exists fun i => And (p i) (Disjoint (Set.iUnion fun x => Set.iUnion fun h => UniformSpace.ball x (s i)) (Set.iUnion fun x => Set.iUnion fun h => UniformSpace.ball x (s i)))","decl":"theorem Disjoint.exists_uniform_thickening_of_basis {p : ι → Prop} {s : ι → Set (α × α)}\n    (hU : (𝓤 α).HasBasis p s) {A B : Set α} (hA : IsCompact A) (hB : IsClosed B)\n    (h : Disjoint A B) : ∃ i, p i ∧ Disjoint (⋃ x ∈ A, ball x (s i)) (⋃ x ∈ B, ball x (s i)) := by\n  rcases h.exists_uniform_thickening hA hB with ⟨V, hV, hVAB⟩\n  rcases hU.mem_iff.1 hV with ⟨i, hi, hiV⟩\n  exact ⟨i, hi, hVAB.mono (iUnion₂_mono fun a _ => ball_mono hiV a)\n    (iUnion₂_mono fun b _ => ball_mono hiV b)⟩\n\n"}
{"name":"lebesgue_number_of_compact_open","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"α : Type ua\ninst✝ : UniformSpace α\nK U : Set α\nhK : IsCompact K\nhU : IsOpen U\nhKU : HasSubset.Subset K U\n⊢ Exists fun V => And (Membership.mem (uniformity α) V) (And (IsOpen V) (∀ (x : α), Membership.mem K x → HasSubset.Subset (UniformSpace.ball x V) U))","decl":"/-- A useful consequence of the Lebesgue number lemma: given any compact set `K` contained in an\nopen set `U`, we can find an (open) entourage `V` such that the ball of size `V` about any point of\n`K` is contained in `U`. -/\ntheorem lebesgue_number_of_compact_open {K U : Set α} (hK : IsCompact K)\n    (hU : IsOpen U) (hKU : K ⊆ U) : ∃ V ∈ 𝓤 α, IsOpen V ∧ ∀ x ∈ K, UniformSpace.ball x V ⊆ U :=\n  let ⟨V, ⟨hV, hVo⟩, hVU⟩ :=\n    (hK.nhdsSet_basis_uniformity uniformity_hasBasis_open).mem_iff.1 (hU.mem_nhdsSet.2 hKU)\n  ⟨V, hV, hVo, iUnion₂_subset_iff.1 hVU⟩\n\n\n"}
{"name":"nhdsSet_diagonal_eq_uniformity","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"α : Type ua\ninst✝¹ : UniformSpace α\ninst✝ : CompactSpace α\n⊢ Eq (nhdsSet (Set.diagonal α)) (uniformity α)","decl":"/-- On a compact uniform space, the topology determines the uniform structure, entourages are\nexactly the neighborhoods of the diagonal. -/\ntheorem nhdsSet_diagonal_eq_uniformity [CompactSpace α] : 𝓝ˢ (diagonal α) = 𝓤 α := by\n  refine nhdsSet_diagonal_le_uniformity.antisymm ?_\n  have :\n    (𝓤 (α × α)).HasBasis (fun U => U ∈ 𝓤 α) fun U =>\n      (fun p : (α × α) × α × α => ((p.1.1, p.2.1), p.1.2, p.2.2)) ⁻¹' U ×ˢ U := by\n    rw [uniformity_prod_eq_comap_prod]\n    exact (𝓤 α).basis_sets.prod_self.comap _\n  refine (isCompact_diagonal.nhdsSet_basis_uniformity this).ge_iff.2 fun U hU => ?_\n  exact mem_of_superset hU fun ⟨x, y⟩ hxy => mem_iUnion₂.2\n    ⟨(x, x), rfl, refl_mem_uniformity hU, hxy⟩\n\n"}
{"name":"compactSpace_uniformity","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"α : Type ua\ninst✝¹ : UniformSpace α\ninst✝ : CompactSpace α\n⊢ Eq (uniformity α) (iSup fun x => nhds { fst := x, snd := x })","decl":"/-- On a compact uniform space, the topology determines the uniform structure, entourages are\nexactly the neighborhoods of the diagonal. -/\ntheorem compactSpace_uniformity [CompactSpace α] : 𝓤 α = ⨆ x, 𝓝 (x, x) :=\n  nhdsSet_diagonal_eq_uniformity.symm.trans (nhdsSet_diagonal _)\n\n"}
{"name":"unique_uniformity_of_compact","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"γ : Type uc\nt : TopologicalSpace γ\ninst✝ : CompactSpace γ\nu u' : UniformSpace γ\nh : Eq UniformSpace.toTopologicalSpace t\nh' : Eq UniformSpace.toTopologicalSpace t\n⊢ Eq u u'","decl":"theorem unique_uniformity_of_compact [t : TopologicalSpace γ] [CompactSpace γ]\n    {u u' : UniformSpace γ} (h : u.toTopologicalSpace = t) (h' : u'.toTopologicalSpace = t) :\n    u = u' := by\n  refine UniformSpace.ext ?_\n  have : @CompactSpace γ u.toTopologicalSpace := by rwa [h]\n  have : @CompactSpace γ u'.toTopologicalSpace := by rwa [h']\n  rw [@compactSpace_uniformity _ u, compactSpace_uniformity, h, h']\n\n"}
