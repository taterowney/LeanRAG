{"name":"lebesgue_number_lemma","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nK : Set Œ±\nŒπ : Sort u_2\nU : Œπ ‚Üí Set Œ±\nhK : IsCompact K\nhopen : ‚àÄ (i : Œπ), IsOpen (U i)\nhcover : HasSubset.Subset K (Set.iUnion fun i => U i)\n‚ä¢ Exists fun V => And (Membership.mem (uniformity Œ±) V) (‚àÄ (x : Œ±), Membership.mem K x ‚Üí Exists fun i => HasSubset.Subset (UniformSpace.ball x V) (U i))","decl":"/-- Let `c : Œπ ‚Üí Set Œ±` be an open cover of a compact set `s`. Then there exists an entourage\n`n` such that for each `x ‚àà s` its `n`-neighborhood is contained in some `c i`. -/\ntheorem lebesgue_number_lemma {Œπ : Sort*} {U : Œπ ‚Üí Set Œ±} (hK : IsCompact K)\n    (hopen : ‚àÄ i, IsOpen (U i)) (hcover : K ‚äÜ ‚ãÉ i, U i) :\n    ‚àÉ V ‚àà ùì§ Œ±, ‚àÄ x ‚àà K, ‚àÉ i, ball x V ‚äÜ U i := by\n  have : ‚àÄ x ‚àà K, ‚àÉ i, ‚àÉ V ‚àà ùì§ Œ±, ball x (V ‚óã V) ‚äÜ U i := fun x hx ‚Ü¶ by\n    obtain ‚ü®i, hi‚ü© := mem_iUnion.1 (hcover hx)\n    rw [‚Üê (hopen i).mem_nhds_iff, nhds_eq_comap_uniformity, ‚Üê lift'_comp_uniformity] at hi\n    exact ‚ü®i, (((basis_sets _).lift' <| monotone_id.compRel monotone_id).comap _).mem_iff.1 hi‚ü©\n  choose ind W hW hWU using this\n  rcases hK.elim_nhds_subcover' (fun x hx ‚Ü¶ ball x (W x hx)) (fun x hx ‚Ü¶ ball_mem_nhds _ (hW x hx))\n    with ‚ü®t, ht‚ü©\n  refine ‚ü®‚ãÇ x ‚àà t, W x x.2, (biInter_finset_mem _).2 fun x _ ‚Ü¶ hW x x.2, fun x hx ‚Ü¶ ?_‚ü©\n  rcases mem_iUnion‚ÇÇ.1 (ht hx) with ‚ü®y, hyt, hxy‚ü©\n  exact ‚ü®ind y y.2, fun z hz ‚Ü¶ hWU _ _ ‚ü®x, hxy, mem_iInter‚ÇÇ.1 hz _ hyt‚ü©‚ü©\n\n"}
{"name":"Filter.HasBasis.lebesgue_number_lemma","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nK : Set Œ±\nŒπ' : Sort u_2\nŒπ : Sort u_3\np : Œπ' ‚Üí Prop\nV : Œπ' ‚Üí Set (Prod Œ± Œ±)\nU : Œπ ‚Üí Set Œ±\nhbasis : (uniformity Œ±).HasBasis p V\nhK : IsCompact K\nhopen : ‚àÄ (j : Œπ), IsOpen (U j)\nhcover : HasSubset.Subset K (Set.iUnion fun j => U j)\n‚ä¢ Exists fun i => And (p i) (‚àÄ (x : Œ±), Membership.mem K x ‚Üí Exists fun j => HasSubset.Subset (UniformSpace.ball x (V i)) (U j))","decl":"/-- Let `U : Œπ ‚Üí Set Œ±` be an open cover of a compact set `K`.\nThen there exists an entourage `V`\nsuch that for each `x ‚àà K` its `V`-neighborhood is included in some `U i`.\n\nMoreover, one can choose an entourage from a given basis. -/\nprotected theorem Filter.HasBasis.lebesgue_number_lemma {Œπ' Œπ : Sort*} {p : Œπ' ‚Üí Prop}\n    {V : Œπ' ‚Üí Set (Œ± √ó Œ±)} {U : Œπ ‚Üí Set Œ±} (hbasis : (ùì§ Œ±).HasBasis p V) (hK : IsCompact K)\n    (hopen : ‚àÄ j, IsOpen (U j)) (hcover : K ‚äÜ ‚ãÉ j, U j) :\n    ‚àÉ i, p i ‚àß ‚àÄ x ‚àà K, ‚àÉ j, ball x (V i) ‚äÜ U j := by\n  refine (hbasis.exists_iff ?_).1 (lebesgue_number_lemma hK hopen hcover)\n  exact fun s t hst ht x hx ‚Ü¶ (ht x hx).imp fun i hi ‚Ü¶ Subset.trans (ball_mono hst _) hi\n\n"}
{"name":"lebesgue_number_lemma_sUnion","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nK : Set Œ±\nS : Set (Set Œ±)\nhK : IsCompact K\nhopen : ‚àÄ (s : Set Œ±), Membership.mem S s ‚Üí IsOpen s\nhcover : HasSubset.Subset K S.sUnion\n‚ä¢ Exists fun V => And (Membership.mem (uniformity Œ±) V) (‚àÄ (x : Œ±), Membership.mem K x ‚Üí Exists fun s => And (Membership.mem S s) (HasSubset.Subset (UniformSpace.ball x V) s))","decl":"/-- Let `c : Set (Set Œ±)` be an open cover of a compact set `s`. Then there exists an entourage\n`n` such that for each `x ‚àà s` its `n`-neighborhood is contained in some `t ‚àà c`. -/\ntheorem lebesgue_number_lemma_sUnion {S : Set (Set Œ±)}\n    (hK : IsCompact K) (hopen : ‚àÄ s ‚àà S, IsOpen s) (hcover : K ‚äÜ ‚ãÉ‚ÇÄ S) :\n    ‚àÉ V ‚àà ùì§ Œ±, ‚àÄ x ‚àà K, ‚àÉ s ‚àà S, ball x V ‚äÜ s := by\n  rw [sUnion_eq_iUnion] at hcover\n  simpa using lebesgue_number_lemma hK (by simpa) hcover\n\n"}
{"name":"IsCompact.nhdsSet_basis_uniformity","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"Œ± : Type ua\nŒπ : Sort u_1\ninst‚úù : UniformSpace Œ±\nK : Set Œ±\np : Œπ ‚Üí Prop\nV : Œπ ‚Üí Set (Prod Œ± Œ±)\nhbasis : (uniformity Œ±).HasBasis p V\nhK : IsCompact K\n‚ä¢ (nhdsSet K).HasBasis p fun i => Set.iUnion fun x => Set.iUnion fun h => UniformSpace.ball x (V i)","decl":"/-- If `K` is a compact set in a uniform space and `{V i | p i}` is a basis of entourages,\nthen `{‚ãÉ x ‚àà K, UniformSpace.ball x (V i) | p i}` is a basis of `ùìùÀ¢ K`.\n\nHere \"`{s i | p i}` is a basis of a filter `l`\" means `Filter.HasBasis l p s`. -/\ntheorem IsCompact.nhdsSet_basis_uniformity {p : Œπ ‚Üí Prop} {V : Œπ ‚Üí Set (Œ± √ó Œ±)}\n    (hbasis : (ùì§ Œ±).HasBasis p V) (hK : IsCompact K) :\n    (ùìùÀ¢ K).HasBasis p fun i => ‚ãÉ x ‚àà K, ball x (V i) where\n  mem_iff' U := by\n    constructor\n    ¬∑ intro H\n      have HKU : K ‚äÜ ‚ãÉ _ : Unit, interior U := by\n        simpa only [iUnion_const, subset_interior_iff_mem_nhdsSet] using H\n      obtain ‚ü®i, hpi, hi‚ü© : ‚àÉ i, p i ‚àß ‚ãÉ x ‚àà K, ball x (V i) ‚äÜ interior U := by\n        simpa using hbasis.lebesgue_number_lemma hK (fun _ ‚Ü¶ isOpen_interior) HKU\n      exact ‚ü®i, hpi, hi.trans interior_subset‚ü©\n    ¬∑ rintro ‚ü®i, hpi, hi‚ü©\n      refine mem_of_superset (bUnion_mem_nhdsSet fun x _ ‚Ü¶ ?_) hi\n      exact ball_mem_nhds _ <| hbasis.mem_of_mem hpi\n\n-- TODO: move to a separate file, golf using the regularity of a uniform space.\n"}
{"name":"Disjoint.exists_uniform_thickening","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nA B : Set Œ±\nhA : IsCompact A\nhB : IsClosed B\nh : Disjoint A B\n‚ä¢ Exists fun V => And (Membership.mem (uniformity Œ±) V) (Disjoint (Set.iUnion fun x => Set.iUnion fun h => UniformSpace.ball x V) (Set.iUnion fun x => Set.iUnion fun h => UniformSpace.ball x V))","decl":"theorem Disjoint.exists_uniform_thickening {A B : Set Œ±} (hA : IsCompact A) (hB : IsClosed B)\n    (h : Disjoint A B) : ‚àÉ V ‚àà ùì§ Œ±, Disjoint (‚ãÉ x ‚àà A, ball x V) (‚ãÉ x ‚àà B, ball x V) := by\n  have : B·∂ú ‚àà ùìùÀ¢ A := hB.isOpen_compl.mem_nhdsSet.mpr h.le_compl_right\n  rw [(hA.nhdsSet_basis_uniformity (Filter.basis_sets _)).mem_iff] at this\n  rcases this with ‚ü®U, hU, hUAB‚ü©\n  rcases comp_symm_mem_uniformity_sets hU with ‚ü®V, hV, hVsymm, hVU‚ü©\n  refine ‚ü®V, hV, Set.disjoint_left.mpr fun x => ?_‚ü©\n  simp only [mem_iUnion‚ÇÇ]\n  rintro ‚ü®a, ha, hxa‚ü© ‚ü®b, hb, hxb‚ü©\n  rw [mem_ball_symmetry hVsymm] at hxa hxb\n  exact hUAB (mem_iUnion‚ÇÇ_of_mem ha <| hVU <| mem_comp_of_mem_ball hVsymm hxa hxb) hb\n\n"}
{"name":"Disjoint.exists_uniform_thickening_of_basis","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"Œ± : Type ua\nŒπ : Sort u_1\ninst‚úù : UniformSpace Œ±\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod Œ± Œ±)\nhU : (uniformity Œ±).HasBasis p s\nA B : Set Œ±\nhA : IsCompact A\nhB : IsClosed B\nh : Disjoint A B\n‚ä¢ Exists fun i => And (p i) (Disjoint (Set.iUnion fun x => Set.iUnion fun h => UniformSpace.ball x (s i)) (Set.iUnion fun x => Set.iUnion fun h => UniformSpace.ball x (s i)))","decl":"theorem Disjoint.exists_uniform_thickening_of_basis {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set (Œ± √ó Œ±)}\n    (hU : (ùì§ Œ±).HasBasis p s) {A B : Set Œ±} (hA : IsCompact A) (hB : IsClosed B)\n    (h : Disjoint A B) : ‚àÉ i, p i ‚àß Disjoint (‚ãÉ x ‚àà A, ball x (s i)) (‚ãÉ x ‚àà B, ball x (s i)) := by\n  rcases h.exists_uniform_thickening hA hB with ‚ü®V, hV, hVAB‚ü©\n  rcases hU.mem_iff.1 hV with ‚ü®i, hi, hiV‚ü©\n  exact ‚ü®i, hi, hVAB.mono (iUnion‚ÇÇ_mono fun a _ => ball_mono hiV a)\n    (iUnion‚ÇÇ_mono fun b _ => ball_mono hiV b)‚ü©\n\n"}
{"name":"lebesgue_number_of_compact_open","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"Œ± : Type ua\ninst‚úù : UniformSpace Œ±\nK U : Set Œ±\nhK : IsCompact K\nhU : IsOpen U\nhKU : HasSubset.Subset K U\n‚ä¢ Exists fun V => And (Membership.mem (uniformity Œ±) V) (And (IsOpen V) (‚àÄ (x : Œ±), Membership.mem K x ‚Üí HasSubset.Subset (UniformSpace.ball x V) U))","decl":"/-- A useful consequence of the Lebesgue number lemma: given any compact set `K` contained in an\nopen set `U`, we can find an (open) entourage `V` such that the ball of size `V` about any point of\n`K` is contained in `U`. -/\ntheorem lebesgue_number_of_compact_open {K U : Set Œ±} (hK : IsCompact K)\n    (hU : IsOpen U) (hKU : K ‚äÜ U) : ‚àÉ V ‚àà ùì§ Œ±, IsOpen V ‚àß ‚àÄ x ‚àà K, UniformSpace.ball x V ‚äÜ U :=\n  let ‚ü®V, ‚ü®hV, hVo‚ü©, hVU‚ü© :=\n    (hK.nhdsSet_basis_uniformity uniformity_hasBasis_open).mem_iff.1 (hU.mem_nhdsSet.2 hKU)\n  ‚ü®V, hV, hVo, iUnion‚ÇÇ_subset_iff.1 hVU‚ü©\n\n\n"}
{"name":"nhdsSet_diagonal_eq_uniformity","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"Œ± : Type ua\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : CompactSpace Œ±\n‚ä¢ Eq (nhdsSet (Set.diagonal Œ±)) (uniformity Œ±)","decl":"/-- On a compact uniform space, the topology determines the uniform structure, entourages are\nexactly the neighborhoods of the diagonal. -/\ntheorem nhdsSet_diagonal_eq_uniformity [CompactSpace Œ±] : ùìùÀ¢ (diagonal Œ±) = ùì§ Œ± := by\n  refine nhdsSet_diagonal_le_uniformity.antisymm ?_\n  have :\n    (ùì§ (Œ± √ó Œ±)).HasBasis (fun U => U ‚àà ùì§ Œ±) fun U =>\n      (fun p : (Œ± √ó Œ±) √ó Œ± √ó Œ± => ((p.1.1, p.2.1), p.1.2, p.2.2)) ‚Åª¬π' U √óÀ¢ U := by\n    rw [uniformity_prod_eq_comap_prod]\n    exact (ùì§ Œ±).basis_sets.prod_self.comap _\n  refine (isCompact_diagonal.nhdsSet_basis_uniformity this).ge_iff.2 fun U hU => ?_\n  exact mem_of_superset hU fun ‚ü®x, y‚ü© hxy => mem_iUnion‚ÇÇ.2\n    ‚ü®(x, x), rfl, refl_mem_uniformity hU, hxy‚ü©\n\n"}
{"name":"compactSpace_uniformity","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"Œ± : Type ua\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : CompactSpace Œ±\n‚ä¢ Eq (uniformity Œ±) (iSup fun x => nhds { fst := x, snd := x })","decl":"/-- On a compact uniform space, the topology determines the uniform structure, entourages are\nexactly the neighborhoods of the diagonal. -/\ntheorem compactSpace_uniformity [CompactSpace Œ±] : ùì§ Œ± = ‚®Ü x, ùìù (x, x) :=\n  nhdsSet_diagonal_eq_uniformity.symm.trans (nhdsSet_diagonal _)\n\n"}
{"name":"unique_uniformity_of_compact","module":"Mathlib.Topology.UniformSpace.Compact","initialProofState":"Œ≥ : Type uc\nt : TopologicalSpace Œ≥\ninst‚úù : CompactSpace Œ≥\nu u' : UniformSpace Œ≥\nh : Eq UniformSpace.toTopologicalSpace t\nh' : Eq UniformSpace.toTopologicalSpace t\n‚ä¢ Eq u u'","decl":"theorem unique_uniformity_of_compact [t : TopologicalSpace Œ≥] [CompactSpace Œ≥]\n    {u u' : UniformSpace Œ≥} (h : u.toTopologicalSpace = t) (h' : u'.toTopologicalSpace = t) :\n    u = u' := by\n  refine UniformSpace.ext ?_\n  have : @CompactSpace Œ≥ u.toTopologicalSpace := by rwa [h]\n  have : @CompactSpace Œ≥ u'.toTopologicalSpace := by rwa [h']\n  rw [@compactSpace_uniformity _ u, compactSpace_uniformity, h, h']\n\n"}
