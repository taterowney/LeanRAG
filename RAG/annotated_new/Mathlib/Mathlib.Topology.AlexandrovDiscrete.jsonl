{"name":"AlexandrovDiscrete.isOpen_sInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_1\ninstâœ : TopologicalSpace Î±\nself : AlexandrovDiscrete Î±\nS : Set (Set Î±)\naâœ : âˆ€ (s : Set Î±), Membership.mem S s â†’ IsOpen s\nâŠ¢ IsOpen S.sInter","decl":"/-- A topological space is **Alexandrov-discrete** or **finitely generated** if the intersection of\na family of open sets is open. -/\nclass AlexandrovDiscrete (Î± : Type*) [TopologicalSpace Î±] : Prop where\n  /-- The intersection of a family of open sets is an open set. Use `isOpen_sInter` in the root\n  namespace instead. -/\n  protected isOpen_sInter : âˆ€ S : Set (Set Î±), (âˆ€ s âˆˆ S, IsOpen s) â†’ IsOpen (â‹‚â‚€ S)\n\n"}
{"name":"DiscreteTopology.toAlexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : DiscreteTopology Î±\nâŠ¢ AlexandrovDiscrete Î±","decl":"instance DiscreteTopology.toAlexandrovDiscrete [DiscreteTopology Î±] : AlexandrovDiscrete Î± where\n  isOpen_sInter _ _ := isOpen_discrete _\n\n"}
{"name":"Finite.toAlexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : Finite Î±\nâŠ¢ AlexandrovDiscrete Î±","decl":"instance Finite.toAlexandrovDiscrete [Finite Î±] : AlexandrovDiscrete Î± where\n  isOpen_sInter S := (toFinite S).isOpen_sInter\n\n"}
{"name":"isOpen_sInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nS : Set (Set Î±)\naâœ : âˆ€ (s : Set Î±), Membership.mem S s â†’ IsOpen s\nâŠ¢ IsOpen S.sInter","decl":"lemma isOpen_sInter : (âˆ€ s âˆˆ S, IsOpen s) â†’ IsOpen (â‹‚â‚€ S) := AlexandrovDiscrete.isOpen_sInter _\n\n"}
{"name":"isOpen_iInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nf : Î¹ â†’ Set Î±\nhf : âˆ€ (i : Î¹), IsOpen (f i)\nâŠ¢ IsOpen (Set.iInter fun i => f i)","decl":"lemma isOpen_iInter (hf : âˆ€ i, IsOpen (f i)) : IsOpen (â‹‚ i, f i) :=\n  isOpen_sInter <| forall_mem_range.2 hf\n\n"}
{"name":"isOpen_iInterâ‚‚","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î¹ : Sort u_1\nÎº : Î¹ â†’ Sort u_2\nÎ± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nf : (i : Î¹) â†’ Îº i â†’ Set Î±\nhf : âˆ€ (i : Î¹) (j : Îº i), IsOpen (f i j)\nâŠ¢ IsOpen (Set.iInter fun i => Set.iInter fun j => f i j)","decl":"lemma isOpen_iInterâ‚‚ {f : âˆ€ i, Îº i â†’ Set Î±} (hf : âˆ€ i j, IsOpen (f i j)) :\n    IsOpen (â‹‚ i, â‹‚ j, f i j) :=\n  isOpen_iInter fun _ â†¦ isOpen_iInter <| hf _\n\n"}
{"name":"isClosed_sUnion","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nS : Set (Set Î±)\nhS : âˆ€ (s : Set Î±), Membership.mem S s â†’ IsClosed s\nâŠ¢ IsClosed S.sUnion","decl":"lemma isClosed_sUnion (hS : âˆ€ s âˆˆ S, IsClosed s) : IsClosed (â‹ƒâ‚€ S) := by\n  simp only [â† isOpen_compl_iff, compl_sUnion] at hS âŠ¢; exact isOpen_sInter <| forall_mem_image.2 hS\n\n"}
{"name":"isClosed_iUnion","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nf : Î¹ â†’ Set Î±\nhf : âˆ€ (i : Î¹), IsClosed (f i)\nâŠ¢ IsClosed (Set.iUnion fun i => f i)","decl":"lemma isClosed_iUnion (hf : âˆ€ i, IsClosed (f i)) : IsClosed (â‹ƒ i, f i) :=\n  isClosed_sUnion <| forall_mem_range.2 hf\n\n"}
{"name":"isClosed_iUnionâ‚‚","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î¹ : Sort u_1\nÎº : Î¹ â†’ Sort u_2\nÎ± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nf : (i : Î¹) â†’ Îº i â†’ Set Î±\nhf : âˆ€ (i : Î¹) (j : Îº i), IsClosed (f i j)\nâŠ¢ IsClosed (Set.iUnion fun i => Set.iUnion fun j => f i j)","decl":"lemma isClosed_iUnionâ‚‚ {f : âˆ€ i, Îº i â†’ Set Î±} (hf : âˆ€ i j, IsClosed (f i j)) :\n    IsClosed (â‹ƒ i, â‹ƒ j, f i j) :=\n  isClosed_iUnion fun _ â†¦ isClosed_iUnion <| hf _\n\n"}
{"name":"isClopen_sInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nS : Set (Set Î±)\nhS : âˆ€ (s : Set Î±), Membership.mem S s â†’ IsClopen s\nâŠ¢ IsClopen S.sInter","decl":"lemma isClopen_sInter (hS : âˆ€ s âˆˆ S, IsClopen s) : IsClopen (â‹‚â‚€ S) :=\n  âŸ¨isClosed_sInter fun s hs â†¦ (hS s hs).1, isOpen_sInter fun s hs â†¦ (hS s hs).2âŸ©\n\n"}
{"name":"isClopen_iInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nf : Î¹ â†’ Set Î±\nhf : âˆ€ (i : Î¹), IsClopen (f i)\nâŠ¢ IsClopen (Set.iInter fun i => f i)","decl":"lemma isClopen_iInter (hf : âˆ€ i, IsClopen (f i)) : IsClopen (â‹‚ i, f i) :=\n  âŸ¨isClosed_iInter fun i â†¦ (hf i).1, isOpen_iInter fun i â†¦ (hf i).2âŸ©\n\n"}
{"name":"isClopen_iInterâ‚‚","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î¹ : Sort u_1\nÎº : Î¹ â†’ Sort u_2\nÎ± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nf : (i : Î¹) â†’ Îº i â†’ Set Î±\nhf : âˆ€ (i : Î¹) (j : Îº i), IsClopen (f i j)\nâŠ¢ IsClopen (Set.iInter fun i => Set.iInter fun j => f i j)","decl":"lemma isClopen_iInterâ‚‚ {f : âˆ€ i, Îº i â†’ Set Î±} (hf : âˆ€ i j, IsClopen (f i j)) :\n    IsClopen (â‹‚ i, â‹‚ j, f i j) :=\n  isClopen_iInter fun _ â†¦ isClopen_iInter <| hf _\n\n"}
{"name":"isClopen_sUnion","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nS : Set (Set Î±)\nhS : âˆ€ (s : Set Î±), Membership.mem S s â†’ IsClopen s\nâŠ¢ IsClopen S.sUnion","decl":"lemma isClopen_sUnion (hS : âˆ€ s âˆˆ S, IsClopen s) : IsClopen (â‹ƒâ‚€ S) :=\n  âŸ¨isClosed_sUnion fun s hs â†¦ (hS s hs).1, isOpen_sUnion fun s hs â†¦ (hS s hs).2âŸ©\n\n"}
{"name":"isClopen_iUnion","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nf : Î¹ â†’ Set Î±\nhf : âˆ€ (i : Î¹), IsClopen (f i)\nâŠ¢ IsClopen (Set.iUnion fun i => f i)","decl":"lemma isClopen_iUnion (hf : âˆ€ i, IsClopen (f i)) : IsClopen (â‹ƒ i, f i) :=\n  âŸ¨isClosed_iUnion fun i â†¦ (hf i).1, isOpen_iUnion fun i â†¦ (hf i).2âŸ©\n\n"}
{"name":"isClopen_iUnionâ‚‚","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î¹ : Sort u_1\nÎº : Î¹ â†’ Sort u_2\nÎ± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nf : (i : Î¹) â†’ Îº i â†’ Set Î±\nhf : âˆ€ (i : Î¹) (j : Îº i), IsClopen (f i j)\nâŠ¢ IsClopen (Set.iUnion fun i => Set.iUnion fun j => f i j)","decl":"lemma isClopen_iUnionâ‚‚ {f : âˆ€ i, Îº i â†’ Set Î±} (hf : âˆ€ i j, IsClopen (f i j)) :\n    IsClopen (â‹ƒ i, â‹ƒ j, f i j) :=\n  isClopen_iUnion fun _ â†¦ isClopen_iUnion <| hf _\n\n"}
{"name":"interior_iInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nf : Î¹ â†’ Set Î±\nâŠ¢ Eq (interior (Set.iInter fun i => f i)) (Set.iInter fun i => interior (f i))","decl":"lemma interior_iInter (f : Î¹ â†’ Set Î±) : interior (â‹‚ i, f i) = â‹‚ i, interior (f i) :=\n  (interior_maximal (iInter_mono fun _ â†¦ interior_subset) <| isOpen_iInter fun _ â†¦\n    isOpen_interior).antisymm' <| subset_iInter fun _ â†¦ interior_mono <| iInter_subset _ _\n\n"}
{"name":"interior_sInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nS : Set (Set Î±)\nâŠ¢ Eq (interior S.sInter) (Set.iInter fun s => Set.iInter fun h => interior s)","decl":"lemma interior_sInter (S : Set (Set Î±)) : interior (â‹‚â‚€ S) = â‹‚ s âˆˆ S, interior s := by\n  simp_rw [sInter_eq_biInter, interior_iInter]\n\n"}
{"name":"closure_iUnion","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nf : Î¹ â†’ Set Î±\nâŠ¢ Eq (closure (Set.iUnion fun i => f i)) (Set.iUnion fun i => closure (f i))","decl":"lemma closure_iUnion (f : Î¹ â†’ Set Î±) : closure (â‹ƒ i, f i) = â‹ƒ i, closure (f i) :=\n  compl_injective <| by\n    simpa only [â† interior_compl, compl_iUnion] using interior_iInter fun i â†¦ (f i)á¶œ\n\n"}
{"name":"closure_sUnion","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nS : Set (Set Î±)\nâŠ¢ Eq (closure S.sUnion) (Set.iUnion fun s => Set.iUnion fun h => closure s)","decl":"lemma closure_sUnion (S : Set (Set Î±)) : closure (â‹ƒâ‚€ S) = â‹ƒ s âˆˆ S, closure s := by\n  simp_rw [sUnion_eq_biUnion, closure_iUnion]\n\n"}
{"name":"Topology.IsInducing.alexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\nÎ² : Type u_4\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : AlexandrovDiscrete Î±\nf : Î² â†’ Î±\nh : Topology.IsInducing f\nâŠ¢ AlexandrovDiscrete Î²","decl":"lemma Topology.IsInducing.alexandrovDiscrete [AlexandrovDiscrete Î±] {f : Î² â†’ Î±} (h : IsInducing f) :\n    AlexandrovDiscrete Î² where\n  isOpen_sInter S hS := by\n    simp_rw [h.isOpen_iff] at hS âŠ¢\n    choose U hU htU using hS\n    refine âŸ¨_, isOpen_iInterâ‚‚ hU, ?_âŸ©\n    simp_rw [preimage_iInter, htU, sInter_eq_biInter]\n\n"}
{"name":"Inducing.alexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\nÎ² : Type u_4\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : TopologicalSpace Î²\ninstâœ : AlexandrovDiscrete Î±\nf : Î² â†’ Î±\nh : Topology.IsInducing f\nâŠ¢ AlexandrovDiscrete Î²","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.alexandrovDiscrete := IsInducing.alexandrovDiscrete\n\n"}
{"name":"AlexandrovDiscrete.sup","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ntâ‚ tâ‚‚ : TopologicalSpace Î±\nxâœÂ¹ : AlexandrovDiscrete Î±\nxâœ : AlexandrovDiscrete Î±\nâŠ¢ AlexandrovDiscrete Î±","decl":"lemma AlexandrovDiscrete.sup {tâ‚ tâ‚‚ : TopologicalSpace Î±} (_ : @AlexandrovDiscrete Î± tâ‚)\n    (_ : @AlexandrovDiscrete Î± tâ‚‚) :\n    @AlexandrovDiscrete Î± (tâ‚ âŠ” tâ‚‚) :=\n  @AlexandrovDiscrete.mk Î± (tâ‚ âŠ” tâ‚‚) fun _S hS â†¦\n    âŸ¨@isOpen_sInter _ tâ‚ _ _ fun _s hs â†¦ (hS _ hs).1, isOpen_sInter fun _s hs â†¦ (hS _ hs).2âŸ©\n\n"}
{"name":"alexandrovDiscrete_iSup","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_3\nt : Î¹ â†’ TopologicalSpace Î±\nxâœ : âˆ€ (i : Î¹), AlexandrovDiscrete Î±\nâŠ¢ AlexandrovDiscrete Î±","decl":"lemma alexandrovDiscrete_iSup {t : Î¹ â†’ TopologicalSpace Î±} (_ : âˆ€ i, @AlexandrovDiscrete Î± (t i)) :\n    @AlexandrovDiscrete Î± (â¨† i, t i) :=\n  @AlexandrovDiscrete.mk Î± (â¨† i, t i)\n    fun _S hS â†¦ isOpen_iSup_iff.2\n      fun i â†¦ @isOpen_sInter _ (t i) _ _\n        fun _s hs â†¦ isOpen_iSup_iff.1 (hS _ hs) _\n\n"}
{"name":"isOpen_exterior","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\ns : Set Î±\nâŠ¢ IsOpen (exterior s)","decl":"@[simp] lemma isOpen_exterior : IsOpen (exterior s) := by\n  rw [exterior_def]; exact isOpen_sInter fun _ â†¦ And.left\n\n"}
{"name":"exterior_mem_nhdsSet","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\ns : Set Î±\nâŠ¢ Membership.mem (nhdsSet s) (exterior s)","decl":"lemma exterior_mem_nhdsSet : exterior s âˆˆ ğ“Ë¢ s := isOpen_exterior.mem_nhdsSet.2 subset_exterior\n\n"}
{"name":"exterior_eq_iff_isOpen","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\ns : Set Î±\nâŠ¢ Iff (Eq (exterior s) s) (IsOpen s)","decl":"@[simp] lemma exterior_eq_iff_isOpen : exterior s = s â†” IsOpen s :=\n  âŸ¨fun h â†¦ h â–¸ isOpen_exterior, IsOpen.exterior_eqâŸ©\n\n"}
{"name":"exterior_subset_iff_isOpen","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\ns : Set Î±\nâŠ¢ Iff (HasSubset.Subset (exterior s) s) (IsOpen s)","decl":"@[simp] lemma exterior_subset_iff_isOpen : exterior s âŠ† s â†” IsOpen s := by\n  simp only [exterior_eq_iff_isOpen.symm, Subset.antisymm_iff, subset_exterior, and_true]\n\n"}
{"name":"exterior_subset_iff","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\ns t : Set Î±\nâŠ¢ Iff (HasSubset.Subset (exterior s) t) (Exists fun U => And (IsOpen U) (And (HasSubset.Subset s U) (HasSubset.Subset U t)))","decl":"lemma exterior_subset_iff : exterior s âŠ† t â†” âˆƒ U, IsOpen U âˆ§ s âŠ† U âˆ§ U âŠ† t :=\n  âŸ¨fun h â†¦ âŸ¨exterior s, isOpen_exterior, subset_exterior, hâŸ©,\n    fun âŸ¨_U, hU, hsU, hUtâŸ© â†¦ (exterior_minimal hsU hU).trans hUtâŸ©\n\n"}
{"name":"exterior_subset_iff_mem_nhdsSet","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\ns t : Set Î±\nâŠ¢ Iff (HasSubset.Subset (exterior s) t) (Membership.mem (nhdsSet s) t)","decl":"lemma exterior_subset_iff_mem_nhdsSet : exterior s âŠ† t â†” t âˆˆ ğ“Ë¢ s :=\n  exterior_subset_iff.trans mem_nhdsSet_iff_exists.symm\n\n"}
{"name":"exterior_singleton_subset_iff_mem_nhds","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nt : Set Î±\na : Î±\nâŠ¢ Iff (HasSubset.Subset (exterior (Singleton.singleton a)) t) (Membership.mem (nhds a) t)","decl":"lemma exterior_singleton_subset_iff_mem_nhds : exterior {a} âŠ† t â†” t âˆˆ ğ“ a := by\n  simp [exterior_subset_iff_mem_nhdsSet]\n\n"}
{"name":"gc_exterior_interior","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nâŠ¢ GaloisConnection exterior interior","decl":"lemma gc_exterior_interior : GaloisConnection (exterior : Set Î± â†’ Set Î±) interior :=\n  fun s t â†¦ by simp [exterior_subset_iff, subset_interior_iff]\n\n"}
{"name":"principal_exterior","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\ns : Set Î±\nâŠ¢ Eq (Filter.principal (exterior s)) (nhdsSet s)","decl":"@[simp] lemma principal_exterior (s : Set Î±) : ğ“Ÿ (exterior s) = ğ“Ë¢ s := by\n  rw [â† nhdsSet_exterior, isOpen_exterior.nhdsSet_eq]\n\n"}
{"name":"isOpen_iff_forall_specializes","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\ns : Set Î±\nâŠ¢ Iff (IsOpen s) (âˆ€ (x y : Î±), Specializes x y â†’ Membership.mem s y â†’ Membership.mem s x)","decl":"lemma isOpen_iff_forall_specializes : IsOpen s â†” âˆ€ x y, x â¤³ y â†’ y âˆˆ s â†’ x âˆˆ s := by\n  simp only [â† exterior_subset_iff_isOpen, Set.subset_def, mem_exterior_iff_specializes, exists_imp,\n    and_imp, @forall_swap (_ â¤³ _)]\n\n"}
{"name":"alexandrovDiscrete_coinduced","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nÎ² : Type u_5\nf : Î± â†’ Î²\nâŠ¢ AlexandrovDiscrete Î²","decl":"lemma alexandrovDiscrete_coinduced {Î² : Type*} {f : Î± â†’ Î²} :\n    @AlexandrovDiscrete Î² (coinduced f â€¹_â€º) :=\n  @AlexandrovDiscrete.mk Î² (coinduced f â€¹_â€º) fun S hS â†¦ by\n    rw [isOpen_coinduced, preimage_sInter]; exact isOpen_iInterâ‚‚ hS\n\n"}
{"name":"AlexandrovDiscrete.toFirstCountable","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœ : TopologicalSpace Î±\nâŠ¢ FirstCountableTopology Î±","decl":"instance AlexandrovDiscrete.toFirstCountable : FirstCountableTopology Î± where\n  nhds_generated_countable a := âŸ¨{exterior {a}}, countable_singleton _, by simpâŸ©\n\n"}
{"name":"AlexandrovDiscrete.toLocallyCompactSpace","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\nâŠ¢ LocallyCompactSpace Î±","decl":"instance AlexandrovDiscrete.toLocallyCompactSpace : LocallyCompactSpace Î± where\n  local_compact_nhds a _U hU := âŸ¨exterior {a},\n    isOpen_exterior.mem_nhds <| subset_exterior <| mem_singleton _,\n      exterior_singleton_subset_iff_mem_nhds.2 hU, isCompact_singleton.exteriorâŸ©\n\n"}
{"name":"Subtype.instAlexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\np : Î± â†’ Prop\nâŠ¢ AlexandrovDiscrete (Subtype fun a => p a)","decl":"instance Subtype.instAlexandrovDiscrete {p : Î± â†’ Prop} : AlexandrovDiscrete {a // p a} :=\n  IsInducing.subtypeVal.alexandrovDiscrete\n\n"}
{"name":"Quotient.instAlexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AlexandrovDiscrete Î±\ns : Setoid Î±\nâŠ¢ AlexandrovDiscrete (Quotient s)","decl":"instance Quotient.instAlexandrovDiscrete {s : Setoid Î±} : AlexandrovDiscrete (Quotient s) :=\n  alexandrovDiscrete_coinduced\n\n"}
{"name":"Sum.instAlexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î± : Type u_3\nÎ² : Type u_4\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : AlexandrovDiscrete Î±\ninstâœ : AlexandrovDiscrete Î²\nâŠ¢ AlexandrovDiscrete (Sum Î± Î²)","decl":"instance Sum.instAlexandrovDiscrete : AlexandrovDiscrete (Î± âŠ• Î²) :=\n  alexandrovDiscrete_coinduced.sup alexandrovDiscrete_coinduced\n\n"}
{"name":"Sigma.instAlexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"Î¹ : Type u_5\nÏ€ : Î¹ â†’ Type u_6\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ninstâœ : âˆ€ (i : Î¹), AlexandrovDiscrete (Ï€ i)\nâŠ¢ AlexandrovDiscrete (Sigma fun i => Ï€ i)","decl":"instance Sigma.instAlexandrovDiscrete {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (Ï€ i)]\n    [âˆ€ i, AlexandrovDiscrete (Ï€ i)] : AlexandrovDiscrete (Î£ i, Ï€ i) :=\n  alexandrovDiscrete_iSup fun _ â†¦ alexandrovDiscrete_coinduced\n\n"}
