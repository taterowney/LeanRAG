{"name":"AlexandrovDiscrete.isOpen_sInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nself : AlexandrovDiscrete α\nS : Set (Set α)\na✝ : ∀ (s : Set α), Membership.mem S s → IsOpen s\n⊢ IsOpen S.sInter","decl":"/-- A topological space is **Alexandrov-discrete** or **finitely generated** if the intersection of\na family of open sets is open. -/\nclass AlexandrovDiscrete (α : Type*) [TopologicalSpace α] : Prop where\n  /-- The intersection of a family of open sets is an open set. Use `isOpen_sInter` in the root\n  namespace instead. -/\n  protected isOpen_sInter : ∀ S : Set (Set α), (∀ s ∈ S, IsOpen s) → IsOpen (⋂₀ S)\n\n"}
{"name":"DiscreteTopology.toAlexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : DiscreteTopology α\n⊢ AlexandrovDiscrete α","decl":"instance DiscreteTopology.toAlexandrovDiscrete [DiscreteTopology α] : AlexandrovDiscrete α where\n  isOpen_sInter _ _ := isOpen_discrete _\n\n"}
{"name":"Finite.toAlexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : Finite α\n⊢ AlexandrovDiscrete α","decl":"instance Finite.toAlexandrovDiscrete [Finite α] : AlexandrovDiscrete α where\n  isOpen_sInter S := (toFinite S).isOpen_sInter\n\n"}
{"name":"isOpen_sInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nS : Set (Set α)\na✝ : ∀ (s : Set α), Membership.mem S s → IsOpen s\n⊢ IsOpen S.sInter","decl":"lemma isOpen_sInter : (∀ s ∈ S, IsOpen s) → IsOpen (⋂₀ S) := AlexandrovDiscrete.isOpen_sInter _\n\n"}
{"name":"isOpen_iInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"ι : Sort u_1\nα : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nf : ι → Set α\nhf : ∀ (i : ι), IsOpen (f i)\n⊢ IsOpen (Set.iInter fun i => f i)","decl":"lemma isOpen_iInter (hf : ∀ i, IsOpen (f i)) : IsOpen (⋂ i, f i) :=\n  isOpen_sInter <| forall_mem_range.2 hf\n\n"}
{"name":"isOpen_iInter₂","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"ι : Sort u_1\nκ : ι → Sort u_2\nα : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nf : (i : ι) → κ i → Set α\nhf : ∀ (i : ι) (j : κ i), IsOpen (f i j)\n⊢ IsOpen (Set.iInter fun i => Set.iInter fun j => f i j)","decl":"lemma isOpen_iInter₂ {f : ∀ i, κ i → Set α} (hf : ∀ i j, IsOpen (f i j)) :\n    IsOpen (⋂ i, ⋂ j, f i j) :=\n  isOpen_iInter fun _ ↦ isOpen_iInter <| hf _\n\n"}
{"name":"isClosed_sUnion","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nS : Set (Set α)\nhS : ∀ (s : Set α), Membership.mem S s → IsClosed s\n⊢ IsClosed S.sUnion","decl":"lemma isClosed_sUnion (hS : ∀ s ∈ S, IsClosed s) : IsClosed (⋃₀ S) := by\n  simp only [← isOpen_compl_iff, compl_sUnion] at hS ⊢; exact isOpen_sInter <| forall_mem_image.2 hS\n\n"}
{"name":"isClosed_iUnion","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"ι : Sort u_1\nα : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nf : ι → Set α\nhf : ∀ (i : ι), IsClosed (f i)\n⊢ IsClosed (Set.iUnion fun i => f i)","decl":"lemma isClosed_iUnion (hf : ∀ i, IsClosed (f i)) : IsClosed (⋃ i, f i) :=\n  isClosed_sUnion <| forall_mem_range.2 hf\n\n"}
{"name":"isClosed_iUnion₂","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"ι : Sort u_1\nκ : ι → Sort u_2\nα : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nf : (i : ι) → κ i → Set α\nhf : ∀ (i : ι) (j : κ i), IsClosed (f i j)\n⊢ IsClosed (Set.iUnion fun i => Set.iUnion fun j => f i j)","decl":"lemma isClosed_iUnion₂ {f : ∀ i, κ i → Set α} (hf : ∀ i j, IsClosed (f i j)) :\n    IsClosed (⋃ i, ⋃ j, f i j) :=\n  isClosed_iUnion fun _ ↦ isClosed_iUnion <| hf _\n\n"}
{"name":"isClopen_sInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nS : Set (Set α)\nhS : ∀ (s : Set α), Membership.mem S s → IsClopen s\n⊢ IsClopen S.sInter","decl":"lemma isClopen_sInter (hS : ∀ s ∈ S, IsClopen s) : IsClopen (⋂₀ S) :=\n  ⟨isClosed_sInter fun s hs ↦ (hS s hs).1, isOpen_sInter fun s hs ↦ (hS s hs).2⟩\n\n"}
{"name":"isClopen_iInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"ι : Sort u_1\nα : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nf : ι → Set α\nhf : ∀ (i : ι), IsClopen (f i)\n⊢ IsClopen (Set.iInter fun i => f i)","decl":"lemma isClopen_iInter (hf : ∀ i, IsClopen (f i)) : IsClopen (⋂ i, f i) :=\n  ⟨isClosed_iInter fun i ↦ (hf i).1, isOpen_iInter fun i ↦ (hf i).2⟩\n\n"}
{"name":"isClopen_iInter₂","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"ι : Sort u_1\nκ : ι → Sort u_2\nα : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nf : (i : ι) → κ i → Set α\nhf : ∀ (i : ι) (j : κ i), IsClopen (f i j)\n⊢ IsClopen (Set.iInter fun i => Set.iInter fun j => f i j)","decl":"lemma isClopen_iInter₂ {f : ∀ i, κ i → Set α} (hf : ∀ i j, IsClopen (f i j)) :\n    IsClopen (⋂ i, ⋂ j, f i j) :=\n  isClopen_iInter fun _ ↦ isClopen_iInter <| hf _\n\n"}
{"name":"isClopen_sUnion","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nS : Set (Set α)\nhS : ∀ (s : Set α), Membership.mem S s → IsClopen s\n⊢ IsClopen S.sUnion","decl":"lemma isClopen_sUnion (hS : ∀ s ∈ S, IsClopen s) : IsClopen (⋃₀ S) :=\n  ⟨isClosed_sUnion fun s hs ↦ (hS s hs).1, isOpen_sUnion fun s hs ↦ (hS s hs).2⟩\n\n"}
{"name":"isClopen_iUnion","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"ι : Sort u_1\nα : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nf : ι → Set α\nhf : ∀ (i : ι), IsClopen (f i)\n⊢ IsClopen (Set.iUnion fun i => f i)","decl":"lemma isClopen_iUnion (hf : ∀ i, IsClopen (f i)) : IsClopen (⋃ i, f i) :=\n  ⟨isClosed_iUnion fun i ↦ (hf i).1, isOpen_iUnion fun i ↦ (hf i).2⟩\n\n"}
{"name":"isClopen_iUnion₂","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"ι : Sort u_1\nκ : ι → Sort u_2\nα : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nf : (i : ι) → κ i → Set α\nhf : ∀ (i : ι) (j : κ i), IsClopen (f i j)\n⊢ IsClopen (Set.iUnion fun i => Set.iUnion fun j => f i j)","decl":"lemma isClopen_iUnion₂ {f : ∀ i, κ i → Set α} (hf : ∀ i j, IsClopen (f i j)) :\n    IsClopen (⋃ i, ⋃ j, f i j) :=\n  isClopen_iUnion fun _ ↦ isClopen_iUnion <| hf _\n\n"}
{"name":"interior_iInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"ι : Sort u_1\nα : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nf : ι → Set α\n⊢ Eq (interior (Set.iInter fun i => f i)) (Set.iInter fun i => interior (f i))","decl":"lemma interior_iInter (f : ι → Set α) : interior (⋂ i, f i) = ⋂ i, interior (f i) :=\n  (interior_maximal (iInter_mono fun _ ↦ interior_subset) <| isOpen_iInter fun _ ↦\n    isOpen_interior).antisymm' <| subset_iInter fun _ ↦ interior_mono <| iInter_subset _ _\n\n"}
{"name":"interior_sInter","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nS : Set (Set α)\n⊢ Eq (interior S.sInter) (Set.iInter fun s => Set.iInter fun h => interior s)","decl":"lemma interior_sInter (S : Set (Set α)) : interior (⋂₀ S) = ⋂ s ∈ S, interior s := by\n  simp_rw [sInter_eq_biInter, interior_iInter]\n\n"}
{"name":"closure_iUnion","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"ι : Sort u_1\nα : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nf : ι → Set α\n⊢ Eq (closure (Set.iUnion fun i => f i)) (Set.iUnion fun i => closure (f i))","decl":"lemma closure_iUnion (f : ι → Set α) : closure (⋃ i, f i) = ⋃ i, closure (f i) :=\n  compl_injective <| by\n    simpa only [← interior_compl, compl_iUnion] using interior_iInter fun i ↦ (f i)ᶜ\n\n"}
{"name":"closure_sUnion","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nS : Set (Set α)\n⊢ Eq (closure S.sUnion) (Set.iUnion fun s => Set.iUnion fun h => closure s)","decl":"lemma closure_sUnion (S : Set (Set α)) : closure (⋃₀ S) = ⋃ s ∈ S, closure s := by\n  simp_rw [sUnion_eq_biUnion, closure_iUnion]\n\n"}
{"name":"Topology.IsInducing.alexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : AlexandrovDiscrete α\nf : β → α\nh : Topology.IsInducing f\n⊢ AlexandrovDiscrete β","decl":"lemma Topology.IsInducing.alexandrovDiscrete [AlexandrovDiscrete α] {f : β → α} (h : IsInducing f) :\n    AlexandrovDiscrete β where\n  isOpen_sInter S hS := by\n    simp_rw [h.isOpen_iff] at hS ⊢\n    choose U hU htU using hS\n    refine ⟨_, isOpen_iInter₂ hU, ?_⟩\n    simp_rw [preimage_iInter, htU, sInter_eq_biInter]\n\n"}
{"name":"Inducing.alexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : AlexandrovDiscrete α\nf : β → α\nh : Topology.IsInducing f\n⊢ AlexandrovDiscrete β","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.alexandrovDiscrete := IsInducing.alexandrovDiscrete\n\n"}
{"name":"AlexandrovDiscrete.sup","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\nt₁ t₂ : TopologicalSpace α\nx✝¹ : AlexandrovDiscrete α\nx✝ : AlexandrovDiscrete α\n⊢ AlexandrovDiscrete α","decl":"lemma AlexandrovDiscrete.sup {t₁ t₂ : TopologicalSpace α} (_ : @AlexandrovDiscrete α t₁)\n    (_ : @AlexandrovDiscrete α t₂) :\n    @AlexandrovDiscrete α (t₁ ⊔ t₂) :=\n  @AlexandrovDiscrete.mk α (t₁ ⊔ t₂) fun _S hS ↦\n    ⟨@isOpen_sInter _ t₁ _ _ fun _s hs ↦ (hS _ hs).1, isOpen_sInter fun _s hs ↦ (hS _ hs).2⟩\n\n"}
{"name":"alexandrovDiscrete_iSup","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"ι : Sort u_1\nα : Type u_3\nt : ι → TopologicalSpace α\nx✝ : ∀ (i : ι), AlexandrovDiscrete α\n⊢ AlexandrovDiscrete α","decl":"lemma alexandrovDiscrete_iSup {t : ι → TopologicalSpace α} (_ : ∀ i, @AlexandrovDiscrete α (t i)) :\n    @AlexandrovDiscrete α (⨆ i, t i) :=\n  @AlexandrovDiscrete.mk α (⨆ i, t i)\n    fun _S hS ↦ isOpen_iSup_iff.2\n      fun i ↦ @isOpen_sInter _ (t i) _ _\n        fun _s hs ↦ isOpen_iSup_iff.1 (hS _ hs) _\n\n"}
{"name":"isOpen_exterior","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\ns : Set α\n⊢ IsOpen (exterior s)","decl":"@[simp] lemma isOpen_exterior : IsOpen (exterior s) := by\n  rw [exterior_def]; exact isOpen_sInter fun _ ↦ And.left\n\n"}
{"name":"exterior_mem_nhdsSet","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\ns : Set α\n⊢ Membership.mem (nhdsSet s) (exterior s)","decl":"lemma exterior_mem_nhdsSet : exterior s ∈ 𝓝ˢ s := isOpen_exterior.mem_nhdsSet.2 subset_exterior\n\n"}
{"name":"exterior_eq_iff_isOpen","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\ns : Set α\n⊢ Iff (Eq (exterior s) s) (IsOpen s)","decl":"@[simp] lemma exterior_eq_iff_isOpen : exterior s = s ↔ IsOpen s :=\n  ⟨fun h ↦ h ▸ isOpen_exterior, IsOpen.exterior_eq⟩\n\n"}
{"name":"exterior_subset_iff_isOpen","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\ns : Set α\n⊢ Iff (HasSubset.Subset (exterior s) s) (IsOpen s)","decl":"@[simp] lemma exterior_subset_iff_isOpen : exterior s ⊆ s ↔ IsOpen s := by\n  simp only [exterior_eq_iff_isOpen.symm, Subset.antisymm_iff, subset_exterior, and_true]\n\n"}
{"name":"exterior_subset_iff","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\ns t : Set α\n⊢ Iff (HasSubset.Subset (exterior s) t) (Exists fun U => And (IsOpen U) (And (HasSubset.Subset s U) (HasSubset.Subset U t)))","decl":"lemma exterior_subset_iff : exterior s ⊆ t ↔ ∃ U, IsOpen U ∧ s ⊆ U ∧ U ⊆ t :=\n  ⟨fun h ↦ ⟨exterior s, isOpen_exterior, subset_exterior, h⟩,\n    fun ⟨_U, hU, hsU, hUt⟩ ↦ (exterior_minimal hsU hU).trans hUt⟩\n\n"}
{"name":"exterior_subset_iff_mem_nhdsSet","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\ns t : Set α\n⊢ Iff (HasSubset.Subset (exterior s) t) (Membership.mem (nhdsSet s) t)","decl":"lemma exterior_subset_iff_mem_nhdsSet : exterior s ⊆ t ↔ t ∈ 𝓝ˢ s :=\n  exterior_subset_iff.trans mem_nhdsSet_iff_exists.symm\n\n"}
{"name":"exterior_singleton_subset_iff_mem_nhds","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nt : Set α\na : α\n⊢ Iff (HasSubset.Subset (exterior (Singleton.singleton a)) t) (Membership.mem (nhds a) t)","decl":"lemma exterior_singleton_subset_iff_mem_nhds : exterior {a} ⊆ t ↔ t ∈ 𝓝 a := by\n  simp [exterior_subset_iff_mem_nhdsSet]\n\n"}
{"name":"gc_exterior_interior","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\n⊢ GaloisConnection exterior interior","decl":"lemma gc_exterior_interior : GaloisConnection (exterior : Set α → Set α) interior :=\n  fun s t ↦ by simp [exterior_subset_iff, subset_interior_iff]\n\n"}
{"name":"principal_exterior","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\ns : Set α\n⊢ Eq (Filter.principal (exterior s)) (nhdsSet s)","decl":"@[simp] lemma principal_exterior (s : Set α) : 𝓟 (exterior s) = 𝓝ˢ s := by\n  rw [← nhdsSet_exterior, isOpen_exterior.nhdsSet_eq]\n\n"}
{"name":"isOpen_iff_forall_specializes","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\ns : Set α\n⊢ Iff (IsOpen s) (∀ (x y : α), Specializes x y → Membership.mem s y → Membership.mem s x)","decl":"lemma isOpen_iff_forall_specializes : IsOpen s ↔ ∀ x y, x ⤳ y → y ∈ s → x ∈ s := by\n  simp only [← exterior_subset_iff_isOpen, Set.subset_def, mem_exterior_iff_specializes, exists_imp,\n    and_imp, @forall_swap (_ ⤳ _)]\n\n"}
{"name":"alexandrovDiscrete_coinduced","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\nβ : Type u_5\nf : α → β\n⊢ AlexandrovDiscrete β","decl":"lemma alexandrovDiscrete_coinduced {β : Type*} {f : α → β} :\n    @AlexandrovDiscrete β (coinduced f ‹_›) :=\n  @AlexandrovDiscrete.mk β (coinduced f ‹_›) fun S hS ↦ by\n    rw [isOpen_coinduced, preimage_sInter]; exact isOpen_iInter₂ hS\n\n"}
{"name":"AlexandrovDiscrete.toFirstCountable","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝ : TopologicalSpace α\n⊢ FirstCountableTopology α","decl":"instance AlexandrovDiscrete.toFirstCountable : FirstCountableTopology α where\n  nhds_generated_countable a := ⟨{exterior {a}}, countable_singleton _, by simp⟩\n\n"}
{"name":"AlexandrovDiscrete.toLocallyCompactSpace","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\n⊢ LocallyCompactSpace α","decl":"instance AlexandrovDiscrete.toLocallyCompactSpace : LocallyCompactSpace α where\n  local_compact_nhds a _U hU := ⟨exterior {a},\n    isOpen_exterior.mem_nhds <| subset_exterior <| mem_singleton _,\n      exterior_singleton_subset_iff_mem_nhds.2 hU, isCompact_singleton.exterior⟩\n\n"}
{"name":"Subtype.instAlexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\np : α → Prop\n⊢ AlexandrovDiscrete (Subtype fun a => p a)","decl":"instance Subtype.instAlexandrovDiscrete {p : α → Prop} : AlexandrovDiscrete {a // p a} :=\n  IsInducing.subtypeVal.alexandrovDiscrete\n\n"}
{"name":"Quotient.instAlexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AlexandrovDiscrete α\ns : Setoid α\n⊢ AlexandrovDiscrete (Quotient s)","decl":"instance Quotient.instAlexandrovDiscrete {s : Setoid α} : AlexandrovDiscrete (Quotient s) :=\n  alexandrovDiscrete_coinduced\n\n"}
{"name":"Sum.instAlexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : AlexandrovDiscrete α\ninst✝ : AlexandrovDiscrete β\n⊢ AlexandrovDiscrete (Sum α β)","decl":"instance Sum.instAlexandrovDiscrete : AlexandrovDiscrete (α ⊕ β) :=\n  alexandrovDiscrete_coinduced.sup alexandrovDiscrete_coinduced\n\n"}
{"name":"Sigma.instAlexandrovDiscrete","module":"Mathlib.Topology.AlexandrovDiscrete","initialProofState":"ι : Type u_5\nπ : ι → Type u_6\ninst✝¹ : (i : ι) → TopologicalSpace (π i)\ninst✝ : ∀ (i : ι), AlexandrovDiscrete (π i)\n⊢ AlexandrovDiscrete (Sigma fun i => π i)","decl":"instance Sigma.instAlexandrovDiscrete {ι : Type*} {π : ι → Type*} [∀ i, TopologicalSpace (π i)]\n    [∀ i, AlexandrovDiscrete (π i)] : AlexandrovDiscrete (Σ i, π i) :=\n  alexandrovDiscrete_iSup fun _ ↦ alexandrovDiscrete_coinduced\n\n"}
