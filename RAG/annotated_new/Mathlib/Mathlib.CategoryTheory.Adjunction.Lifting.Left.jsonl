{"name":"CategoryTheory.LiftLeftAdjoint.instIsReflexivePairMapAppCounitOtherMap","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Left","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nU : CategoryTheory.Functor B C\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor A B\nF' : CategoryTheory.Functor C A\nadj₁ : CategoryTheory.Adjunction F U\nadj₂ : CategoryTheory.Adjunction F' (R.comp U)\nX : B\n⊢ CategoryTheory.IsReflexivePair (F'.map (U.map (adj₁.counit.app X))) (CategoryTheory.LiftLeftAdjoint.otherMap R F' adj₁ adj₂ X)","decl":"/-- `(F'Uε_X, otherMap X)` is a reflexive pair: in particular if `A` has reflexive coequalizers then\nthis pair has a coequalizer.\n-/\ninstance (X : B) :\n    IsReflexivePair (F'.map (U.map (adj₁.counit.app X))) (otherMap _ _ adj₁ adj₂ X) :=\n  IsReflexivePair.mk' (F'.map (adj₁.unit.app (U.obj X)))\n    (by\n      rw [← F'.map_comp, adj₁.right_triangle_components]\n      apply F'.map_id)\n    (by\n      dsimp [otherMap]\n      rw [← F'.map_comp_assoc, U.map_comp, adj₁.unit_naturality_assoc,\n        adj₁.right_triangle_components, comp_id, adj₂.left_triangle_components])\n\n"}
{"name":"CategoryTheory.LiftLeftAdjoint.constructLeftAdjointEquiv_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Left","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nU : CategoryTheory.Functor B C\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor A B\nF' : CategoryTheory.Functor C A\nadj₁ : CategoryTheory.Adjunction F U\nadj₂ : CategoryTheory.Adjunction F' (R.comp U)\ninst✝¹ : CategoryTheory.Limits.HasReflexiveCoequalizers A\ninst✝ : (X : B) → CategoryTheory.RegularEpi (adj₁.counit.app X)\nY : A\nX : B\na✝ : Quiver.Hom X (R.obj Y)\n⊢ Eq ((CategoryTheory.LiftLeftAdjoint.constructLeftAdjointEquiv R F' adj₁ adj₂ Y X).symm a✝) ((CategoryTheory.Limits.Cofork.IsColimit.homIso (CategoryTheory.Limits.colimit.isColimit (CategoryTheory.Limits.parallelPair (F'.map (U.map (adj₁.counit.app X))) (CategoryTheory.LiftLeftAdjoint.otherMap R F' adj₁ adj₂ X))) Y).symm ⟨(adj₂.homEquiv (U.obj X) Y).symm ((adj₁.homEquiv (U.obj X) (R.obj Y)) ↑((CategoryTheory.Limits.Cofork.IsColimit.homIso (CategoryTheory.LiftLeftAdjoint.counitCoequalises adj₁ X) (R.obj Y)) a✝)), ⋯⟩)","decl":"/-- The homset equivalence which helps show that `R` is a right adjoint. -/\n@[simps!]\nnoncomputable def constructLeftAdjointEquiv [∀ X : B, RegularEpi (adj₁.counit.app X)] (Y : A)\n    (X : B) : (constructLeftAdjointObj _ _ adj₁ adj₂ X ⟶ Y) ≃ (X ⟶ R.obj Y) :=\n  calc\n    (constructLeftAdjointObj _ _ adj₁ adj₂ X ⟶ Y) ≃\n        { f : F'.obj (U.obj X) ⟶ Y //\n          F'.map (U.map (adj₁.counit.app X)) ≫ f = otherMap _ _ adj₁ adj₂ _ ≫ f } :=\n      Cofork.IsColimit.homIso (colimit.isColimit _) _\n    _ ≃ { g : U.obj X ⟶ U.obj (R.obj Y) //\n          U.map (F.map g ≫ adj₁.counit.app _) = U.map (adj₁.counit.app _) ≫ g } := by\n      apply (adj₂.homEquiv _ _).subtypeEquiv _\n      intro f\n      rw [← (adj₂.homEquiv _ _).injective.eq_iff, eq_comm, adj₂.homEquiv_naturality_left,\n        otherMap, assoc, adj₂.homEquiv_naturality_left, ← adj₂.counit_naturality,\n        adj₂.homEquiv_naturality_left, adj₂.homEquiv_unit, adj₂.right_triangle_components,\n        comp_id, Functor.comp_map, ← U.map_comp, assoc, ← adj₁.counit_naturality,\n        adj₂.homEquiv_unit, adj₂.homEquiv_unit, F.map_comp, assoc]\n      rfl\n    _ ≃ { z : F.obj (U.obj X) ⟶ R.obj Y // _ } := by\n      apply (adj₁.homEquiv _ _).symm.subtypeEquiv\n      intro g\n      rw [← (adj₁.homEquiv _ _).symm.injective.eq_iff, adj₁.homEquiv_counit,\n        adj₁.homEquiv_counit, adj₁.homEquiv_counit, F.map_comp, assoc, U.map_comp, F.map_comp,\n        assoc, adj₁.counit_naturality, adj₁.counit_naturality_assoc]\n      apply eq_comm\n    _ ≃ (X ⟶ R.obj Y) := (Cofork.IsColimit.homIso (counitCoequalises adj₁ X) _).symm\n\n"}
{"name":"CategoryTheory.LiftLeftAdjoint.constructLeftAdjointEquiv_apply","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Left","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nU : CategoryTheory.Functor B C\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor A B\nF' : CategoryTheory.Functor C A\nadj₁ : CategoryTheory.Adjunction F U\nadj₂ : CategoryTheory.Adjunction F' (R.comp U)\ninst✝¹ : CategoryTheory.Limits.HasReflexiveCoequalizers A\ninst✝ : (X : B) → CategoryTheory.RegularEpi (adj₁.counit.app X)\nY : A\nX : B\na✝ : Quiver.Hom (CategoryTheory.LiftLeftAdjoint.constructLeftAdjointObj R F' adj₁ adj₂ X) Y\n⊢ Eq ((CategoryTheory.LiftLeftAdjoint.constructLeftAdjointEquiv R F' adj₁ adj₂ Y X) a✝) ((CategoryTheory.Limits.Cofork.IsColimit.homIso (CategoryTheory.LiftLeftAdjoint.counitCoequalises adj₁ X) (R.obj Y)).symm ⟨(adj₁.homEquiv (U.obj X) (R.obj Y)).symm ((adj₂.homEquiv (U.obj X) Y) ↑((CategoryTheory.Limits.Cofork.IsColimit.homIso (CategoryTheory.Limits.colimit.isColimit (CategoryTheory.Limits.parallelPair (F'.map (U.map (adj₁.counit.app X))) (CategoryTheory.LiftLeftAdjoint.otherMap R F' adj₁ adj₂ X))) Y) a✝)), ⋯⟩)","decl":"/-- The homset equivalence which helps show that `R` is a right adjoint. -/\n@[simps!]\nnoncomputable def constructLeftAdjointEquiv [∀ X : B, RegularEpi (adj₁.counit.app X)] (Y : A)\n    (X : B) : (constructLeftAdjointObj _ _ adj₁ adj₂ X ⟶ Y) ≃ (X ⟶ R.obj Y) :=\n  calc\n    (constructLeftAdjointObj _ _ adj₁ adj₂ X ⟶ Y) ≃\n        { f : F'.obj (U.obj X) ⟶ Y //\n          F'.map (U.map (adj₁.counit.app X)) ≫ f = otherMap _ _ adj₁ adj₂ _ ≫ f } :=\n      Cofork.IsColimit.homIso (colimit.isColimit _) _\n    _ ≃ { g : U.obj X ⟶ U.obj (R.obj Y) //\n          U.map (F.map g ≫ adj₁.counit.app _) = U.map (adj₁.counit.app _) ≫ g } := by\n      apply (adj₂.homEquiv _ _).subtypeEquiv _\n      intro f\n      rw [← (adj₂.homEquiv _ _).injective.eq_iff, eq_comm, adj₂.homEquiv_naturality_left,\n        otherMap, assoc, adj₂.homEquiv_naturality_left, ← adj₂.counit_naturality,\n        adj₂.homEquiv_naturality_left, adj₂.homEquiv_unit, adj₂.right_triangle_components,\n        comp_id, Functor.comp_map, ← U.map_comp, assoc, ← adj₁.counit_naturality,\n        adj₂.homEquiv_unit, adj₂.homEquiv_unit, F.map_comp, assoc]\n      rfl\n    _ ≃ { z : F.obj (U.obj X) ⟶ R.obj Y // _ } := by\n      apply (adj₁.homEquiv _ _).symm.subtypeEquiv\n      intro g\n      rw [← (adj₁.homEquiv _ _).symm.injective.eq_iff, adj₁.homEquiv_counit,\n        adj₁.homEquiv_counit, adj₁.homEquiv_counit, F.map_comp, assoc, U.map_comp, F.map_comp,\n        assoc, adj₁.counit_naturality, adj₁.counit_naturality_assoc]\n      apply eq_comm\n    _ ≃ (X ⟶ R.obj Y) := (Cofork.IsColimit.homIso (counitCoequalises adj₁ X) _).symm\n\n"}
{"name":"CategoryTheory.isRightAdjoint_triangle_lift","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Left","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\ninst✝³ : CategoryTheory.Category.{v₃, u₃} C\nU : CategoryTheory.Functor B C\nF : CategoryTheory.Functor C B\nR : CategoryTheory.Functor A B\nadj₁ : CategoryTheory.Adjunction F U\ninst✝² : (X : B) → CategoryTheory.RegularEpi (adj₁.counit.app X)\ninst✝¹ : CategoryTheory.Limits.HasReflexiveCoequalizers A\ninst✝ : (R.comp U).IsRightAdjoint\n⊢ R.IsRightAdjoint","decl":"/-- The adjoint triangle theorem: Suppose `U : B ⥤ C` has a left adjoint `F` such that each counit\n`ε_X : FUX ⟶ X` is a regular epimorphism. Then if a category `A` has coequalizers of reflexive\npairs, then a functor `R : A ⥤ B` has a left adjoint if the composite `R ⋙ U` does.\n\nNote the converse is true (with weaker assumptions), by `Adjunction.comp`.\nSee https://ncatlab.org/nlab/show/adjoint+triangle+theorem\n-/\nlemma isRightAdjoint_triangle_lift {U : B ⥤ C} {F : C ⥤ B} (R : A ⥤ B) (adj₁ : F ⊣ U)\n    [∀ X : B, RegularEpi (adj₁.counit.app X)] [HasReflexiveCoequalizers A]\n    [(R ⋙ U).IsRightAdjoint ] : R.IsRightAdjoint where\n  exists_leftAdjoint :=\n    ⟨LiftLeftAdjoint.constructLeftAdjoint R _ adj₁ (Adjunction.ofIsRightAdjoint _),\n      ⟨Adjunction.adjunctionOfEquivLeft _ _⟩⟩\n\n"}
{"name":"CategoryTheory.isRightAdjoint_triangle_lift_monadic","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Left","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\ninst✝³ : CategoryTheory.Category.{v₃, u₃} C\nU : CategoryTheory.Functor B C\ninst✝² : CategoryTheory.MonadicRightAdjoint U\nR : CategoryTheory.Functor A B\ninst✝¹ : CategoryTheory.Limits.HasReflexiveCoequalizers A\ninst✝ : (R.comp U).IsRightAdjoint\n⊢ R.IsRightAdjoint","decl":"/-- If `R ⋙ U` has a left adjoint, the domain of `R` has reflexive coequalizers and `U` is a monadic\nfunctor, then `R` has a left adjoint.\nThis is a special case of `isRightAdjoint_triangle_lift` which is often more useful in practice.\n-/\nlemma isRightAdjoint_triangle_lift_monadic (U : B ⥤ C) [MonadicRightAdjoint U] {R : A ⥤ B}\n    [HasReflexiveCoequalizers A] [(R ⋙ U).IsRightAdjoint] : R.IsRightAdjoint := by\n  let R' : A ⥤ _ := R ⋙ Monad.comparison (monadicAdjunction U)\n  rsuffices : R'.IsRightAdjoint\n  · let this : (R' ⋙ (Monad.comparison (monadicAdjunction U)).inv).IsRightAdjoint := by\n      infer_instance\n    refine ((Adjunction.ofIsRightAdjoint\n      (R' ⋙ (Monad.comparison (monadicAdjunction U)).inv)).ofNatIsoRight ?_).isRightAdjoint\n    exact isoWhiskerLeft R (Monad.comparison _).asEquivalence.unitIso.symm ≪≫ R.rightUnitor\n  let this : (R' ⋙ Monad.forget (monadicAdjunction U).toMonad).IsRightAdjoint := by\n    refine ((Adjunction.ofIsRightAdjoint (R ⋙ U)).ofNatIsoRight ?_).isRightAdjoint\n    exact isoWhiskerLeft R (Monad.comparisonForget (monadicAdjunction U)).symm\n  let this : ∀ X, RegularEpi ((Monad.adj (monadicAdjunction U).toMonad).counit.app X) := by\n    intro X\n    simp only [Monad.adj_counit]\n    exact ⟨_, _, _, _, Monad.beckAlgebraCoequalizer X⟩\n  exact isRightAdjoint_triangle_lift R' (Monad.adj _)\n\n"}
{"name":"CategoryTheory.isRightAdjoint_square_lift","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Left","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁶ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝⁵ : CategoryTheory.Category.{v₄, u₄} D\nQ : CategoryTheory.Functor A B\nV : CategoryTheory.Functor B D\nU : CategoryTheory.Functor A C\nR : CategoryTheory.Functor C D\ncomm : CategoryTheory.Iso (U.comp R) (Q.comp V)\ninst✝⁴ : U.IsRightAdjoint\ninst✝³ : V.IsRightAdjoint\ninst✝² : R.IsRightAdjoint\ninst✝¹ : (X : B) → CategoryTheory.RegularEpi ((CategoryTheory.Adjunction.ofIsRightAdjoint V).counit.app X)\ninst✝ : CategoryTheory.Limits.HasReflexiveCoequalizers A\n⊢ Q.IsRightAdjoint","decl":"/-- Suppose we have a commutative square of functors\n\n```\n      Q\n    A → B\n  U ↓   ↓ V\n    C → D\n      R\n```\n\nwhere `U` has a left adjoint, `A` has reflexive coequalizers and `V` has a left adjoint such that\neach component of the counit is a regular epi.\nThen `Q` has a left adjoint if `R` has a left adjoint.\n\nSee https://ncatlab.org/nlab/show/adjoint+lifting+theorem\n-/\nlemma isRightAdjoint_square_lift (Q : A ⥤ B) (V : B ⥤ D) (U : A ⥤ C) (R : C ⥤ D)\n    (comm : U ⋙ R ≅ Q ⋙ V) [U.IsRightAdjoint] [V.IsRightAdjoint] [R.IsRightAdjoint]\n    [∀ X, RegularEpi ((Adjunction.ofIsRightAdjoint V).counit.app X)] [HasReflexiveCoequalizers A] :\n    Q.IsRightAdjoint :=\n  have := ((Adjunction.ofIsRightAdjoint (U ⋙ R)).ofNatIsoRight comm).isRightAdjoint\n  isRightAdjoint_triangle_lift Q (Adjunction.ofIsRightAdjoint V)\n\n"}
{"name":"CategoryTheory.isRightAdjoint_square_lift_monadic","module":"Mathlib.CategoryTheory.Adjunction.Lifting.Left","initialProofState":"A : Type u₁\nB : Type u₂\nC : Type u₃\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} A\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} B\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝⁴ : CategoryTheory.Category.{v₄, u₄} D\nQ : CategoryTheory.Functor A B\nV : CategoryTheory.Functor B D\nU : CategoryTheory.Functor A C\nR : CategoryTheory.Functor C D\ncomm : CategoryTheory.Iso (U.comp R) (Q.comp V)\ninst✝³ : U.IsRightAdjoint\ninst✝² : CategoryTheory.MonadicRightAdjoint V\ninst✝¹ : R.IsRightAdjoint\ninst✝ : CategoryTheory.Limits.HasReflexiveCoequalizers A\n⊢ Q.IsRightAdjoint","decl":"/-- Suppose we have a commutative square of functors\n\n```\n      Q\n    A → B\n  U ↓   ↓ V\n    C → D\n      R\n```\n\nwhere `U` has a left adjoint, `A` has reflexive coequalizers and `V` is monadic.\nThen `Q` has a left adjoint if `R` has a left adjoint.\n\nSee https://ncatlab.org/nlab/show/adjoint+lifting+theorem\n-/\nlemma isRightAdjoint_square_lift_monadic (Q : A ⥤ B) (V : B ⥤ D) (U : A ⥤ C) (R : C ⥤ D)\n    (comm : U ⋙ R ≅ Q ⋙ V) [U.IsRightAdjoint] [MonadicRightAdjoint V] [R.IsRightAdjoint]\n    [HasReflexiveCoequalizers A] : Q.IsRightAdjoint :=\n  have := ((Adjunction.ofIsRightAdjoint (U ⋙ R)).ofNatIsoRight comm).isRightAdjoint\n  isRightAdjoint_triangle_lift_monadic V\n\n"}
