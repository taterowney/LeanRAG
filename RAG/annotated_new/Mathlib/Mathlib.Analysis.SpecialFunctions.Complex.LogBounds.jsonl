{"name":"Complex.continuousOn_one_add_mul_inv","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"z : Complex\nhz : Membership.mem Complex.slitPlane (HAdd.hAdd 1 z)\n⊢ ContinuousOn (fun t => Inv.inv (HAdd.hAdd 1 (HSMul.hSMul t z))) (Set.Icc 0 1)","decl":"lemma continuousOn_one_add_mul_inv {z : ℂ} (hz : 1 + z ∈ slitPlane) :\n    ContinuousOn (fun t : ℝ ↦ (1 + t • z)⁻¹) (Set.Icc 0 1) :=\n  ContinuousOn.inv₀ (by fun_prop)\n    (fun _ ht ↦ slitPlane_ne_zero <| StarConvex.add_smul_mem starConvex_one_slitPlane hz ht.1 ht.2)\n\n"}
{"name":"Complex.log_eq_integral","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"z : Complex\nhz : Membership.mem Complex.slitPlane (HAdd.hAdd 1 z)\n⊢ Eq (Complex.log (HAdd.hAdd 1 z)) (HMul.hMul z (intervalIntegral (fun t => Inv.inv (HAdd.hAdd 1 (HSMul.hSMul t z))) 0 1 MeasureTheory.MeasureSpace.volume))","decl":"open intervalIntegral in\n/-- Represent `log (1 + z)` as an integral over the unit interval -/\nlemma log_eq_integral {z : ℂ} (hz : 1 + z ∈ slitPlane) :\n    log (1 + z) = z * ∫ (t : ℝ) in (0 : ℝ)..1, (1 + t • z)⁻¹ := by\n  convert (integral_unitInterval_deriv_eq_sub (continuousOn_one_add_mul_inv hz)\n    (fun _ ht ↦ hasDerivAt_log <|\n      StarConvex.add_smul_mem starConvex_one_slitPlane hz ht.1 ht.2)).symm using 1\n  simp only [log_one, sub_zero]\n\n"}
{"name":"Complex.log_inv_eq_integral","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"z : Complex\nhz : Membership.mem Complex.slitPlane (HSub.hSub 1 z)\n⊢ Eq (Complex.log (Inv.inv (HSub.hSub 1 z))) (HMul.hMul z (intervalIntegral (fun t => Inv.inv (HSub.hSub 1 (HSMul.hSMul t z))) 0 1 MeasureTheory.MeasureSpace.volume))","decl":"/-- Represent `log (1 - z)⁻¹` as an integral over the unit interval -/\nlemma log_inv_eq_integral {z : ℂ} (hz : 1 - z ∈ slitPlane) :\n    log (1 - z)⁻¹ = z * ∫ (t : ℝ) in (0 : ℝ)..1, (1 - t • z)⁻¹ := by\n  rw [sub_eq_add_neg 1 z] at hz ⊢\n  rw [log_inv _ <| slitPlane_arg_ne_pi hz, neg_eq_iff_eq_neg, ← neg_mul]\n  convert log_eq_integral hz using 5\n  rw [sub_eq_add_neg, smul_neg]\n\n"}
{"name":"Complex.logTaylor_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"⊢ Eq (Complex.logTaylor 0) fun x => 0","decl":"lemma logTaylor_zero : logTaylor 0 = fun _ ↦ 0 := by\n  funext\n  simp only [logTaylor, Finset.range_zero, ← Nat.not_even_iff_odd, Int.cast_pow, Int.cast_neg,\n    Int.cast_one, Finset.sum_empty]\n\n"}
{"name":"Complex.logTaylor_succ","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"n : Nat\n⊢ Eq (Complex.logTaylor (HAdd.hAdd n 1)) (HAdd.hAdd (Complex.logTaylor n) fun z => HDiv.hDiv (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd n 1)) (HPow.hPow z n)) ↑n)","decl":"lemma logTaylor_succ (n : ℕ) :\n    logTaylor (n + 1) = logTaylor n + (fun z : ℂ ↦ (-1) ^ (n + 1) * z ^ n / n) := by\n  funext\n  simpa only [logTaylor] using Finset.sum_range_succ ..\n\n"}
{"name":"Complex.logTaylor_at_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"n : Nat\n⊢ Eq (Complex.logTaylor n 0) 0","decl":"lemma logTaylor_at_zero (n : ℕ) : logTaylor n 0 = 0 := by\n  induction n with\n  | zero => simp [logTaylor_zero]\n  | succ n ih => simpa [logTaylor_succ, ih] using ne_or_eq n 0\n\n"}
{"name":"Complex.hasDerivAt_logTaylor","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"n : Nat\nz : Complex\n⊢ HasDerivAt (Complex.logTaylor (HAdd.hAdd n 1)) ((Finset.range n).sum fun j => HMul.hMul (HPow.hPow (-1) j) (HPow.hPow z j)) z","decl":"lemma hasDerivAt_logTaylor (n : ℕ) (z : ℂ) :\n    HasDerivAt (logTaylor (n + 1)) (∑ j ∈ Finset.range n, (-1) ^ j * z ^ j) z := by\n  induction n with\n  | zero => simp [logTaylor_succ, logTaylor_zero, Pi.add_def, hasDerivAt_const]\n  | succ n ih =>\n    rw [logTaylor_succ]\n    simp only [cpow_natCast, Nat.cast_add, Nat.cast_one, ← Nat.not_even_iff_odd,\n      Finset.sum_range_succ, (show (-1) ^ (n + 1 + 1) = (-1) ^ n by ring)]\n    refine HasDerivAt.add ih ?_\n    simp only [← Nat.not_even_iff_odd, Int.cast_pow, Int.cast_neg, Int.cast_one, mul_div_assoc]\n    have : HasDerivAt (fun x : ℂ ↦ (x ^ (n + 1) / (n + 1))) (z ^ n) z := by\n      simp_rw [div_eq_mul_inv]\n      convert HasDerivAt.mul_const (hasDerivAt_pow (n + 1) z) (((n : ℂ) + 1)⁻¹) using 1\n      field_simp [Nat.cast_add_one_ne_zero n]\n    convert HasDerivAt.const_mul _ this using 2\n    ring\n\n"}
{"name":"Complex.hasDerivAt_log_sub_logTaylor","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"n : Nat\nz : Complex\nhz : Membership.mem Complex.slitPlane (HAdd.hAdd 1 z)\n⊢ HasDerivAt (fun z => HSub.hSub (Complex.log (HAdd.hAdd 1 z)) (Complex.logTaylor (HAdd.hAdd n 1) z)) (HMul.hMul (HPow.hPow (Neg.neg z) n) (Inv.inv (HAdd.hAdd 1 z))) z","decl":"lemma hasDerivAt_log_sub_logTaylor (n : ℕ) {z : ℂ} (hz : 1 + z ∈ slitPlane) :\n    HasDerivAt (fun z : ℂ ↦ log (1 + z) - logTaylor (n + 1) z) ((-z) ^ n * (1 + z)⁻¹) z := by\n  convert ((hasDerivAt_log hz).comp_const_add 1 z).sub (hasDerivAt_logTaylor n z) using 1\n  have hz' : -z ≠ 1 := by\n    intro H\n    rw [neg_eq_iff_eq_neg] at H\n    simp only [H, add_neg_cancel] at hz\n    exact slitPlane_ne_zero hz rfl\n  simp_rw [← mul_pow, neg_one_mul, geom_sum_eq hz', ← neg_add', div_neg, add_comm z]\n  field_simp [slitPlane_ne_zero hz]\n\n"}
{"name":"Complex.norm_one_add_mul_inv_le","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"t : Real\nht : Membership.mem (Set.Icc 0 1) t\nz : Complex\nhz : LT.lt (Norm.norm z) 1\n⊢ LE.le (Norm.norm (Inv.inv (HAdd.hAdd 1 (HMul.hMul (↑t) z)))) (Inv.inv (HSub.hSub 1 (Norm.norm z)))","decl":"/-- Give a bound on `‖(1 + t * z)⁻¹‖` for `0 ≤ t ≤ 1` and `‖z‖ < 1`. -/\nlemma norm_one_add_mul_inv_le {t : ℝ} (ht : t ∈ Set.Icc 0 1) {z : ℂ} (hz : ‖z‖ < 1) :\n    ‖(1 + t * z)⁻¹‖ ≤ (1 - ‖z‖)⁻¹ := by\n  rw [Set.mem_Icc] at ht\n  rw [norm_inv, norm_eq_abs]\n  refine inv_anti₀ (by linarith) ?_\n  calc 1 - ‖z‖\n    _ ≤ 1 - t * ‖z‖ := by\n      nlinarith [norm_nonneg z]\n    _ = 1 - ‖t * z‖ := by\n      rw [norm_mul, norm_eq_abs (t : ℂ), abs_of_nonneg ht.1]\n    _ ≤ ‖1 + t * z‖ := by\n      rw [← norm_neg (t * z), ← sub_neg_eq_add]\n      convert norm_sub_norm_le 1 (-(t * z))\n      exact norm_one.symm\n\n"}
{"name":"Complex.integrable_pow_mul_norm_one_add_mul_inv","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"n : Nat\nz : Complex\nhz : LT.lt (Norm.norm z) 1\n⊢ IntervalIntegrable (fun t => HMul.hMul (HPow.hPow t n) (Norm.norm (Inv.inv (HAdd.hAdd 1 (HMul.hMul (↑t) z))))) MeasureTheory.MeasureSpace.volume 0 1","decl":"lemma integrable_pow_mul_norm_one_add_mul_inv (n : ℕ) {z : ℂ} (hz : ‖z‖ < 1) :\n    IntervalIntegrable (fun t : ℝ ↦ t ^ n * ‖(1 + t * z)⁻¹‖) MeasureTheory.volume 0 1 := by\n  have := continuousOn_one_add_mul_inv <| mem_slitPlane_of_norm_lt_one hz\n  rw [← Set.uIcc_of_le zero_le_one] at this\n  exact ContinuousOn.intervalIntegrable (by fun_prop)\n\n"}
{"name":"Complex.norm_log_sub_logTaylor_le","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"n : Nat\nz : Complex\nhz : LT.lt (Norm.norm z) 1\n⊢ LE.le (Norm.norm (HSub.hSub (Complex.log (HAdd.hAdd 1 z)) (Complex.logTaylor (HAdd.hAdd n 1) z))) (HDiv.hDiv (HMul.hMul (HPow.hPow (Norm.norm z) (HAdd.hAdd n 1)) (Inv.inv (HSub.hSub 1 (Norm.norm z)))) (HAdd.hAdd (↑n) 1))","decl":"open intervalIntegral in\n/-- The difference of `log (1+z)` and its `(n+1)`st Taylor polynomial can be bounded in\nterms of `‖z‖`. -/\nlemma norm_log_sub_logTaylor_le (n : ℕ) {z : ℂ} (hz : ‖z‖ < 1) :\n    ‖log (1 + z) - logTaylor (n + 1) z‖ ≤ ‖z‖ ^ (n + 1) * (1 - ‖z‖)⁻¹ / (n + 1) := by\n  have help : IntervalIntegrable (fun t : ℝ ↦ t ^ n * (1 - ‖z‖)⁻¹) MeasureTheory.volume 0 1 :=\n    IntervalIntegrable.mul_const (Continuous.intervalIntegrable (by fun_prop) 0 1) (1 - ‖z‖)⁻¹\n  let f (z : ℂ) : ℂ := log (1 + z) - logTaylor (n + 1) z\n  let f' (z : ℂ) : ℂ := (-z) ^ n * (1 + z)⁻¹\n  have hderiv : ∀ t ∈ Set.Icc (0 : ℝ) 1, HasDerivAt f (f' (0 + t * z)) (0 + t * z) := by\n    intro t ht\n    rw [zero_add]\n    exact hasDerivAt_log_sub_logTaylor n <|\n      StarConvex.add_smul_mem starConvex_one_slitPlane (mem_slitPlane_of_norm_lt_one hz) ht.1 ht.2\n  have hcont : ContinuousOn (fun t : ℝ ↦ f' (0 + t * z)) (Set.Icc 0 1) := by\n    simp only [zero_add, zero_le_one, not_true_eq_false]\n    exact (Continuous.continuousOn (by fun_prop)).mul <|\n      continuousOn_one_add_mul_inv <| mem_slitPlane_of_norm_lt_one hz\n  have H : f z = z * ∫ t in (0 : ℝ)..1, (-(t * z)) ^ n * (1 + t * z)⁻¹ := by\n    convert (integral_unitInterval_deriv_eq_sub hcont hderiv).symm using 1\n    · simp only [f, zero_add, add_zero, log_one, logTaylor_at_zero, sub_self, sub_zero]\n    · simp only [f', add_zero, log_one, logTaylor_at_zero, sub_self, real_smul, zero_add,\n        smul_eq_mul]\n  unfold f at H\n  simp only [H, norm_mul]\n  simp_rw [neg_pow (_ * z) n, mul_assoc, intervalIntegral.integral_const_mul, mul_pow,\n    mul_comm _ (z ^ n), mul_assoc, intervalIntegral.integral_const_mul, norm_mul, norm_pow,\n    norm_neg, norm_one, one_pow, one_mul, ← mul_assoc, ← pow_succ', mul_div_assoc]\n  refine mul_le_mul_of_nonneg_left ?_ (pow_nonneg (norm_nonneg z) (n + 1))\n  calc ‖∫ t in (0 : ℝ)..1, (t : ℂ) ^ n * (1 + t * z)⁻¹‖\n    _ ≤ ∫ t in (0 : ℝ)..1, ‖(t : ℂ) ^ n * (1 + t * z)⁻¹‖ :=\n        intervalIntegral.norm_integral_le_integral_norm zero_le_one\n    _ = ∫ t in (0 : ℝ)..1, t ^ n * ‖(1 + t * z)⁻¹‖ := by\n        refine intervalIntegral.integral_congr <| fun t ht ↦ ?_\n        rw [Set.uIcc_of_le zero_le_one, Set.mem_Icc] at ht\n        simp_rw [norm_mul, norm_pow, norm_eq_abs, abs_of_nonneg ht.1]\n    _ ≤ ∫ t in (0 : ℝ)..1, t ^ n * (1 - ‖z‖)⁻¹ :=\n        intervalIntegral.integral_mono_on zero_le_one\n          (integrable_pow_mul_norm_one_add_mul_inv n hz) help <|\n          fun t ht ↦ mul_le_mul_of_nonneg_left (norm_one_add_mul_inv_le ht hz)\n                       (pow_nonneg ((Set.mem_Icc.mp ht).1) _)\n    _ = (1 - ‖z‖)⁻¹ / (n + 1) := by\n        rw [intervalIntegral.integral_mul_const, mul_comm, integral_pow]\n        field_simp\n\n"}
{"name":"Complex.norm_log_one_add_sub_self_le","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"z : Complex\nhz : LT.lt (Norm.norm z) 1\n⊢ LE.le (Norm.norm (HSub.hSub (Complex.log (HAdd.hAdd 1 z)) z)) (HDiv.hDiv (HMul.hMul (HPow.hPow (Norm.norm z) 2) (Inv.inv (HSub.hSub 1 (Norm.norm z)))) 2)","decl":"/-- The difference `log (1+z) - z` is bounded by `‖z‖^2/(2*(1-‖z‖))` when `‖z‖ < 1`. -/\nlemma norm_log_one_add_sub_self_le {z : ℂ} (hz : ‖z‖ < 1) :\n    ‖log (1 + z) - z‖ ≤ ‖z‖ ^ 2 * (1 - ‖z‖)⁻¹ / 2 := by\n  convert norm_log_sub_logTaylor_le 1 hz using 2\n  · simp [logTaylor_succ, logTaylor_zero, sub_eq_add_neg]\n  · norm_num\n\n"}
{"name":"Complex.norm_log_one_add_le","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"z : Complex\nhz : LT.lt (Norm.norm z) 1\n⊢ LE.le (Norm.norm (Complex.log (HAdd.hAdd 1 z))) (HAdd.hAdd (HDiv.hDiv (HMul.hMul (HPow.hPow (Norm.norm z) 2) (Inv.inv (HSub.hSub 1 (Norm.norm z)))) 2) (Norm.norm z))","decl":"lemma norm_log_one_add_le {z : ℂ} (hz : ‖z‖ < 1) :\n    ‖log (1 + z)‖ ≤ ‖z‖ ^ 2 * (1 - ‖z‖)⁻¹ / 2 + ‖z‖ := by\n  rw [← sub_add_cancel (log (1 + z)) z]\n  apply le_trans (norm_add_le _ _)\n  exact add_le_add_right (Complex.norm_log_one_add_sub_self_le hz) ‖z‖\n\n"}
{"name":"Complex.norm_log_one_add_half_le_self","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"z : Complex\nhz : LE.le (Norm.norm z) (1 / 2)\n⊢ LE.le (Norm.norm (Complex.log (HAdd.hAdd 1 z))) (HMul.hMul (3 / 2) (Norm.norm z))","decl":"/--For `‖z‖ ≤ 1/2`, the complex logarithm is bounded by `(3/2) * ‖z‖`. -/\nlemma norm_log_one_add_half_le_self {z : ℂ} (hz : ‖z‖ ≤ 1/2) : ‖(log (1 + z))‖ ≤ (3/2) * ‖z‖ := by\n  apply le_trans (norm_log_one_add_le (lt_of_le_of_lt hz one_half_lt_one))\n  have hz3 : (1 - ‖z‖)⁻¹ ≤ 2 := by\n    rw [inv_eq_one_div, div_le_iff₀]\n    · linarith\n    · linarith\n  have hz4 : ‖z‖^2 * (1 - ‖z‖)⁻¹ / 2 ≤ ‖z‖/2 * 2 / 2 := by\n    gcongr\n    · rw [inv_nonneg]\n      linarith\n    · rw [sq, div_eq_mul_one_div]\n      apply mul_le_mul (by simp only [norm_eq_abs, mul_one, le_refl])\n        (by simpa only [norm_eq_abs, one_div] using hz) (norm_nonneg z)\n        (by simp only [norm_eq_abs, mul_one, apply_nonneg])\n  simp only [isUnit_iff_ne_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,\n    IsUnit.div_mul_cancel] at hz4\n  linarith\n\n"}
{"name":"Complex.norm_log_one_sub_inv_add_logTaylor_neg_le","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"n : Nat\nz : Complex\nhz : LT.lt (Norm.norm z) 1\n⊢ LE.le (Norm.norm (HAdd.hAdd (Complex.log (Inv.inv (HSub.hSub 1 z))) (Complex.logTaylor (HAdd.hAdd n 1) (Neg.neg z)))) (HDiv.hDiv (HMul.hMul (HPow.hPow (Norm.norm z) (HAdd.hAdd n 1)) (Inv.inv (HSub.hSub 1 (Norm.norm z)))) (HAdd.hAdd (↑n) 1))","decl":"/-- The difference of `log (1-z)⁻¹` and its `(n+1)`st Taylor polynomial can be bounded in\nterms of `‖z‖`. -/\nlemma norm_log_one_sub_inv_add_logTaylor_neg_le (n : ℕ) {z : ℂ} (hz : ‖z‖ < 1) :\n    ‖log (1 - z)⁻¹ + logTaylor (n + 1) (-z)‖ ≤ ‖z‖ ^ (n + 1) * (1 - ‖z‖)⁻¹ / (n + 1) := by\n  rw [sub_eq_add_neg,\n    log_inv _ <| slitPlane_arg_ne_pi <| mem_slitPlane_of_norm_lt_one <| (norm_neg z).symm ▸ hz,\n    ← sub_neg_eq_add, ← neg_sub', norm_neg]\n  convert norm_log_sub_logTaylor_le n <| (norm_neg z).symm ▸ hz using 4 <;> rw [norm_neg]\n\n"}
{"name":"Complex.norm_log_one_sub_inv_sub_self_le","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"z : Complex\nhz : LT.lt (Norm.norm z) 1\n⊢ LE.le (Norm.norm (HSub.hSub (Complex.log (Inv.inv (HSub.hSub 1 z))) z)) (HDiv.hDiv (HMul.hMul (HPow.hPow (Norm.norm z) 2) (Inv.inv (HSub.hSub 1 (Norm.norm z)))) 2)","decl":"/-- The difference `log (1-z)⁻¹ - z` is bounded by `‖z‖^2/(2*(1-‖z‖))` when `‖z‖ < 1`. -/\nlemma norm_log_one_sub_inv_sub_self_le {z : ℂ} (hz : ‖z‖ < 1) :\n    ‖log (1 - z)⁻¹ - z‖ ≤ ‖z‖ ^ 2 * (1 - ‖z‖)⁻¹ / 2 := by\n  convert norm_log_one_sub_inv_add_logTaylor_neg_le 1 hz using 2\n  · simp [logTaylor_succ, logTaylor_zero, sub_eq_add_neg]\n  · norm_num\n\n"}
{"name":"Complex.hasSum_taylorSeries_log","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"z : Complex\nhz : LT.lt (Norm.norm z) 1\n⊢ HasSum (fun n => HDiv.hDiv (HMul.hMul (HPow.hPow (-1) (HAdd.hAdd n 1)) (HPow.hPow z n)) ↑n) (Complex.log (HAdd.hAdd 1 z))","decl":"open Filter Asymptotics in\n/-- The Taylor series of the complex logarithm at `1` converges to the logarithm in the\nopen unit disk. -/\nlemma hasSum_taylorSeries_log {z : ℂ} (hz : ‖z‖ < 1) :\n    HasSum (fun n : ℕ ↦ (-1) ^ (n + 1) * z ^ n / n) (log (1 + z)) := by\n  refine (hasSum_iff_tendsto_nat_of_summable_norm ?_).mpr ?_\n  · refine (summable_geometric_of_norm_lt_one hz).norm.of_nonneg_of_le (fun _ ↦ norm_nonneg _) ?_\n    intro n\n    simp only [norm_div, norm_mul, norm_pow, norm_neg, norm_one, one_pow, one_mul, norm_natCast]\n    rcases n.eq_zero_or_pos with rfl | hn\n    · simp\n    conv => enter [2]; rw [← div_one (‖z‖ ^ n)]\n    gcongr\n    norm_cast\n  · rw [← tendsto_sub_nhds_zero_iff]\n    conv => enter [1, x]; rw [← div_one (_ - _), ← logTaylor]\n    rw [← isLittleO_iff_tendsto fun _ h ↦ (one_ne_zero h).elim]\n    refine IsLittleO.trans_isBigO ?_ <| isBigO_const_one ℂ (1 : ℝ) atTop\n    have H : (fun n ↦ logTaylor n z - log (1 + z)) =O[atTop] (fun n : ℕ ↦ ‖z‖ ^ n) := by\n      have (n : ℕ) : ‖logTaylor n z - log (1 + z)‖\n          ≤ (max ‖log (1 + z)‖ (1 - ‖z‖)⁻¹) * ‖(‖z‖ ^ n)‖ := by\n        rw [norm_sub_rev, norm_pow, norm_norm]\n        cases n with\n        | zero => simp [logTaylor_zero]\n        | succ n =>\n            refine (norm_log_sub_logTaylor_le n hz).trans ?_\n            rw [mul_comm, ← div_one ((max _ _) * _)]\n            gcongr\n            · exact le_max_right ..\n            · linarith\n      exact (isBigOWith_of_le' atTop this).isBigO\n    refine IsBigO.trans_isLittleO H ?_\n    convert isLittleO_pow_pow_of_lt_left (norm_nonneg z) hz\n    exact (one_pow _).symm\n\n"}
{"name":"Complex.hasSum_taylorSeries_neg_log","module":"Mathlib.Analysis.SpecialFunctions.Complex.LogBounds","initialProofState":"z : Complex\nhz : LT.lt (Norm.norm z) 1\n⊢ HasSum (fun n => HDiv.hDiv (HPow.hPow z n) ↑n) (Neg.neg (Complex.log (HSub.hSub 1 z)))","decl":"/-- The series `∑ z^n/n` converges to `-log (1-z)` on the open unit disk. -/\nlemma hasSum_taylorSeries_neg_log {z : ℂ} (hz : ‖z‖ < 1) :\n    HasSum (fun n : ℕ ↦ z ^ n / n) (-log (1 - z)) := by\n  conv => enter [1, n]; rw [← neg_neg (z ^ n / n)]\n  refine HasSum.neg ?_\n  convert hasSum_taylorSeries_log (z := -z) (norm_neg z ▸ hz) using 2 with n\n  rcases n.eq_zero_or_pos with rfl | hn\n  · simp\n  field_simp\n  rw [div_eq_div_iff, pow_succ', mul_assoc (-1), ← mul_pow, neg_mul_neg, neg_one_mul, one_mul]\n  all_goals {norm_cast; exact hn.ne'}\n\n"}
