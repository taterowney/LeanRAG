{"name":"gcd_eq_nat_gcd","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"m n : Nat\n⊢ Eq (GCDMonoid.gcd m n) (m.gcd n)","decl":"theorem gcd_eq_nat_gcd (m n : ℕ) : gcd m n = Nat.gcd m n :=\n  rfl\n\n"}
{"name":"lcm_eq_nat_lcm","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"m n : Nat\n⊢ Eq (GCDMonoid.lcm m n) (m.lcm n)","decl":"theorem lcm_eq_nat_lcm (m n : ℕ) : lcm m n = Nat.lcm m n :=\n  rfl\n\n"}
{"name":"Int.normUnit_eq","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"z : Int\n⊢ Eq (NormalizationMonoid.normUnit z) (ite (LE.le 0 z) 1 (-1))","decl":"theorem normUnit_eq (z : ℤ) : normUnit z = if 0 ≤ z then 1 else -1 := rfl\n\n"}
{"name":"Int.normalize_of_nonneg","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"z : Int\nh : LE.le 0 z\n⊢ Eq (normalize z) z","decl":"theorem normalize_of_nonneg {z : ℤ} (h : 0 ≤ z) : normalize z = z := by\n  rw [normalize_apply, normUnit_eq, if_pos h, Units.val_one, mul_one]\n\n"}
{"name":"Int.normalize_of_nonpos","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"z : Int\nh : LE.le z 0\n⊢ Eq (normalize z) (Neg.neg z)","decl":"theorem normalize_of_nonpos {z : ℤ} (h : z ≤ 0) : normalize z = -z := by\n  obtain rfl | h := h.eq_or_lt\n  · simp\n  · rw [normalize_apply, normUnit_eq, if_neg (not_le_of_gt h), Units.val_neg, Units.val_one,\n      mul_neg_one]\n\n"}
{"name":"Int.normalize_coe_nat","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"n : Nat\n⊢ Eq (normalize ↑n) ↑n","decl":"theorem normalize_coe_nat (n : ℕ) : normalize (n : ℤ) = n :=\n  normalize_of_nonneg (ofNat_le_ofNat_of_le <| Nat.zero_le n)\n\n"}
{"name":"Int.abs_eq_normalize","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"z : Int\n⊢ Eq (abs z) (normalize z)","decl":"theorem abs_eq_normalize (z : ℤ) : |z| = normalize z := by\n  cases le_total 0 z <;>\n  simp [abs_of_nonneg, abs_of_nonpos, normalize_of_nonneg, normalize_of_nonpos, *]\n\n"}
{"name":"Int.nonneg_of_normalize_eq_self","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"z : Int\nhz : Eq (normalize z) z\n⊢ LE.le 0 z","decl":"theorem nonneg_of_normalize_eq_self {z : ℤ} (hz : normalize z = z) : 0 ≤ z := by\n  by_cases h : 0 ≤ z\n  · exact h\n  · rw [normalize_of_nonpos (le_of_not_le h)] at hz\n    omega\n\n"}
{"name":"Int.nonneg_iff_normalize_eq_self","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"z : Int\n⊢ Iff (Eq (normalize z) z) (LE.le 0 z)","decl":"theorem nonneg_iff_normalize_eq_self (z : ℤ) : normalize z = z ↔ 0 ≤ z :=\n  ⟨nonneg_of_normalize_eq_self, normalize_of_nonneg⟩\n\n"}
{"name":"Int.eq_of_associated_of_nonneg","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"a b : Int\nh : Associated a b\nha : LE.le 0 a\nhb : LE.le 0 b\n⊢ Eq a b","decl":"theorem eq_of_associated_of_nonneg {a b : ℤ} (h : Associated a b) (ha : 0 ≤ a) (hb : 0 ≤ b) :\n    a = b :=\n  dvd_antisymm_of_normalize_eq (normalize_of_nonneg ha) (normalize_of_nonneg hb) h.dvd h.symm.dvd\n\n"}
{"name":"Int.coe_gcd","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"i j : Int\n⊢ Eq (↑(i.gcd j)) (GCDMonoid.gcd i j)","decl":"theorem coe_gcd (i j : ℤ) : ↑(Int.gcd i j) = GCDMonoid.gcd i j :=\n  rfl\n\n"}
{"name":"Int.coe_lcm","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"i j : Int\n⊢ Eq (↑(i.lcm j)) (GCDMonoid.lcm i j)","decl":"theorem coe_lcm (i j : ℤ) : ↑(Int.lcm i j) = GCDMonoid.lcm i j :=\n  rfl\n\n"}
{"name":"Int.natAbs_gcd","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"i j : Int\n⊢ Eq (GCDMonoid.gcd i j).natAbs (i.gcd j)","decl":"theorem natAbs_gcd (i j : ℤ) : natAbs (GCDMonoid.gcd i j) = Int.gcd i j :=\n  rfl\n\n"}
{"name":"Int.natAbs_lcm","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"i j : Int\n⊢ Eq (GCDMonoid.lcm i j).natAbs (i.lcm j)","decl":"theorem natAbs_lcm (i j : ℤ) : natAbs (GCDMonoid.lcm i j) = Int.lcm i j :=\n  rfl\n\n"}
{"name":"Int.exists_unit_of_abs","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"a : Int\n⊢ Exists fun u => Exists fun x => Eq (↑a.natAbs) (HMul.hMul u a)","decl":"theorem exists_unit_of_abs (a : ℤ) : ∃ (u : ℤ) (_ : IsUnit u), (Int.natAbs a : ℤ) = u * a := by\n  rcases natAbs_eq a with h | h\n  · use 1, isUnit_one\n    rw [← h, one_mul]\n  · use -1, isUnit_one.neg\n    rw [← neg_eq_iff_eq_neg.mpr h]\n    simp only [neg_mul, one_mul]\n\n"}
{"name":"Int.gcd_eq_natAbs","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"a b : Int\n⊢ Eq (a.gcd b) (a.natAbs.gcd b.natAbs)","decl":"theorem gcd_eq_natAbs {a b : ℤ} : Int.gcd a b = Nat.gcd a.natAbs b.natAbs :=\n  rfl\n"}
{"name":"Int.associated_natAbs","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"k : Int\n⊢ Associated k ↑k.natAbs","decl":"theorem Int.associated_natAbs (k : ℤ) : Associated k k.natAbs :=\n  associated_of_dvd_dvd (Int.dvd_natCast.mpr dvd_rfl) (Int.natAbs_dvd.mpr dvd_rfl)\n\n"}
{"name":"Int.associated_iff_natAbs","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"a b : Int\n⊢ Iff (Associated a b) (Eq a.natAbs b.natAbs)","decl":"theorem Int.associated_iff_natAbs {a b : ℤ} : Associated a b ↔ a.natAbs = b.natAbs := by\n  rw [← dvd_dvd_iff_associated, ← Int.natAbs_dvd_natAbs, ← Int.natAbs_dvd_natAbs,\n    dvd_dvd_iff_associated]\n  exact associated_iff_eq\n\n"}
{"name":"Int.associated_iff","module":"Mathlib.Algebra.GCDMonoid.Nat","initialProofState":"a b : Int\n⊢ Iff (Associated a b) (Or (Eq a b) (Eq a (Neg.neg b)))","decl":"theorem Int.associated_iff {a b : ℤ} : Associated a b ↔ a = b ∨ a = -b := by\n  rw [Int.associated_iff_natAbs]\n  exact Int.natAbs_eq_natAbs_iff\n"}
