{"name":"DistLat.coe_of","module":"Mathlib.Order.Category.DistLat","initialProofState":"α : Type u_1\ninst✝ : DistribLattice α\n⊢ Eq (↑(DistLat.of α)) α","decl":"@[simp]\ntheorem coe_of (α : Type*) [DistribLattice α] : ↥(of α) = α :=\n  rfl\n\n"}
{"name":"DistLat.instParentProjectionLatticeDistribLatticeToLattice","module":"Mathlib.Order.Category.DistLat","initialProofState":"⊢ CategoryTheory.BundledHom.ParentProjection @DistribLattice.toLattice","decl":"instance : BundledHom.ParentProjection @DistribLattice.toLattice :=\n  ⟨⟩\n\n"}
{"name":"DistLat.Iso.mk_inv_toSupHom_toFun","module":"Mathlib.Order.Category.DistLat","initialProofState":"α β : DistLat\ne : OrderIso ↑α ↑β\na : ↑β\n⊢ Eq ((DistLat.Iso.mk e).inv.toSupHom a) (e.symm a)","decl":"/-- Constructs an equivalence between distributive lattices from an order isomorphism between them.\n-/\n@[simps]\ndef Iso.mk {α β : DistLat.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : LatticeHom α β)\n  inv := (e.symm : LatticeHom β α)\n  hom_inv_id := by\n    ext\n    exact e.symm_apply_apply _\n  inv_hom_id := by\n    ext\n    exact e.apply_symm_apply _\n\n"}
{"name":"DistLat.Iso.mk_hom_toSupHom_toFun","module":"Mathlib.Order.Category.DistLat","initialProofState":"α β : DistLat\ne : OrderIso ↑α ↑β\na : ↑α\n⊢ Eq ((DistLat.Iso.mk e).hom.toSupHom a) (e a)","decl":"/-- Constructs an equivalence between distributive lattices from an order isomorphism between them.\n-/\n@[simps]\ndef Iso.mk {α β : DistLat.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : LatticeHom α β)\n  inv := (e.symm : LatticeHom β α)\n  hom_inv_id := by\n    ext\n    exact e.symm_apply_apply _\n  inv_hom_id := by\n    ext\n    exact e.apply_symm_apply _\n\n"}
{"name":"DistLat.dual_obj","module":"Mathlib.Order.Category.DistLat","initialProofState":"X : DistLat\n⊢ Eq (DistLat.dual.obj X) (DistLat.of (OrderDual ↑X))","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : DistLat ⥤ DistLat where\n  obj X := of Xᵒᵈ\n  map := LatticeHom.dual\n\n"}
{"name":"DistLat.dual_map","module":"Mathlib.Order.Category.DistLat","initialProofState":"X✝ Y✝ : DistLat\na : LatticeHom ↑X✝ ↑Y✝\n⊢ Eq (DistLat.dual.map a) (LatticeHom.dual a)","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : DistLat ⥤ DistLat where\n  obj X := of Xᵒᵈ\n  map := LatticeHom.dual\n\n"}
{"name":"DistLat.dualEquiv_inverse","module":"Mathlib.Order.Category.DistLat","initialProofState":"⊢ Eq DistLat.dualEquiv.inverse DistLat.dual","decl":"/-- The equivalence between `DistLat` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : DistLat ≌ DistLat where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents (fun X => Iso.mk <| OrderIso.dualDual X) fun _ => rfl\n  counitIso := NatIso.ofComponents (fun X => Iso.mk <| OrderIso.dualDual X) fun _ => rfl\n\n"}
{"name":"DistLat.dualEquiv_functor","module":"Mathlib.Order.Category.DistLat","initialProofState":"⊢ Eq DistLat.dualEquiv.functor DistLat.dual","decl":"/-- The equivalence between `DistLat` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : DistLat ≌ DistLat where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents (fun X => Iso.mk <| OrderIso.dualDual X) fun _ => rfl\n  counitIso := NatIso.ofComponents (fun X => Iso.mk <| OrderIso.dualDual X) fun _ => rfl\n\n"}
{"name":"distLat_dual_comp_forget_to_Lat","module":"Mathlib.Order.Category.DistLat","initialProofState":"⊢ Eq (DistLat.dual.comp (CategoryTheory.forget₂ DistLat Lat)) ((CategoryTheory.forget₂ DistLat Lat).comp Lat.dual)","decl":"theorem distLat_dual_comp_forget_to_Lat :\n    DistLat.dual ⋙ forget₂ DistLat Lat = forget₂ DistLat Lat ⋙ Lat.dual :=\n  rfl\n"}
