{"name":"Nat.exists_prime_gt_modEq_one","module":"Mathlib.NumberTheory.PrimesCongruentOne","initialProofState":"k n : Nat\nhk0 : Ne k 0\n⊢ Exists fun p => And (Nat.Prime p) (And (LT.lt n p) (k.ModEq p 1))","decl":"/-- For any positive `k : ℕ` there exists an arbitrarily large prime `p` such that\n`p ≡ 1 [MOD k]`. -/\ntheorem exists_prime_gt_modEq_one {k : ℕ} (n : ℕ) (hk0 : k ≠ 0) :\n    ∃ p : ℕ, Nat.Prime p ∧ n < p ∧ p ≡ 1 [MOD k] := by\n  rcases (one_le_iff_ne_zero.2 hk0).eq_or_lt with (rfl | hk1)\n  · rcases exists_infinite_primes (n + 1) with ⟨p, hnp, hp⟩\n    exact ⟨p, hp, hnp, modEq_one⟩\n  let b := k * (n !)\n  have hgt : 1 < (eval (↑b) (cyclotomic k ℤ)).natAbs := by\n    rcases le_iff_exists_add'.1 hk1.le with ⟨k, rfl⟩\n    have hb : 2 ≤ b := le_mul_of_le_of_one_le hk1 n.factorial_pos\n    calc\n      1 ≤ b - 1 := le_tsub_of_add_le_left hb\n      _ < (eval (b : ℤ) (cyclotomic (k + 1) ℤ)).natAbs :=\n        sub_one_lt_natAbs_cyclotomic_eval hk1 (succ_le_iff.1 hb).ne'\n  let p := minFac (eval (↑b) (cyclotomic k ℤ)).natAbs\n  haveI hprime : Fact p.Prime := ⟨minFac_prime (ne_of_lt hgt).symm⟩\n  have hroot : IsRoot (cyclotomic k (ZMod p)) (castRingHom (ZMod p) b) := by\n    have : ((b : ℤ) : ZMod p) = ↑(Int.castRingHom (ZMod p) b) := by simp\n    rw [IsRoot.def, ← map_cyclotomic_int k (ZMod p), eval_map, coe_castRingHom,\n      ← Int.cast_natCast, this, eval₂_hom, Int.coe_castRingHom, ZMod.intCast_zmod_eq_zero_iff_dvd]\n    apply Int.dvd_natAbs.1\n    exact mod_cast minFac_dvd (eval (↑b) (cyclotomic k ℤ)).natAbs\n  have hpb : ¬p ∣ b :=\n    hprime.1.coprime_iff_not_dvd.1 (coprime_of_root_cyclotomic hk0.bot_lt hroot).symm\n  refine ⟨p, hprime.1, not_le.1 fun habs => ?_, ?_⟩\n  · exact hpb (dvd_mul_of_dvd_right (dvd_factorial (minFac_pos _) habs) _)\n  · have hdiv : orderOf (b : ZMod p) ∣ p - 1 :=\n      ZMod.orderOf_dvd_card_sub_one (mt (CharP.cast_eq_zero_iff _ _ _).1 hpb)\n    haveI : NeZero (k : ZMod p) :=\n      NeZero.of_not_dvd (ZMod p) fun hpk => hpb (dvd_mul_of_dvd_left hpk _)\n    have : k = orderOf (b : ZMod p) := (isRoot_cyclotomic_iff.mp hroot).eq_orderOf\n    rw [← this] at hdiv\n    exact ((modEq_iff_dvd' hprime.1.pos).2 hdiv).symm\n\n"}
{"name":"Nat.frequently_atTop_modEq_one","module":"Mathlib.NumberTheory.PrimesCongruentOne","initialProofState":"k : Nat\nhk0 : Ne k 0\n⊢ Filter.Frequently (fun p => And (Nat.Prime p) (k.ModEq p 1)) Filter.atTop","decl":"theorem frequently_atTop_modEq_one {k : ℕ} (hk0 : k ≠ 0) :\n    ∃ᶠ p in atTop, Nat.Prime p ∧ p ≡ 1 [MOD k] := by\n  refine frequently_atTop.2 fun n => ?_\n  obtain ⟨p, hp⟩ := exists_prime_gt_modEq_one n hk0\n  exact ⟨p, ⟨hp.2.1.le, hp.1, hp.2.2⟩⟩\n\n"}
{"name":"Nat.infinite_setOf_prime_modEq_one","module":"Mathlib.NumberTheory.PrimesCongruentOne","initialProofState":"k : Nat\nhk0 : Ne k 0\n⊢ (setOf fun p => And (Nat.Prime p) (k.ModEq p 1)).Infinite","decl":"/-- For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. -/\ntheorem infinite_setOf_prime_modEq_one {k : ℕ} (hk0 : k ≠ 0) :\n    Set.Infinite {p : ℕ | Nat.Prime p ∧ p ≡ 1 [MOD k]} :=\n  frequently_atTop_iff_infinite.1 (frequently_atTop_modEq_one hk0)\n\n"}
